int main(int argc, const char **argv, const char **envp)
{
  os_log_t v5;
  BOOL v6;
  os_log_t v7;
  os_log_t v8;
  os_log_t v9;
  os_log_t v10;
  os_log_t v11;
  os_log_t v12;
  os_log_t v13;
  os_log_t v14;
  os_log_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  _BYTE *v26;
  _BYTE *v27;
  const char *v28;
  const char *v29;
  int v30;
  const char *v31;
  uint64_t v32;
  const char *v33;
  const char *v34;
  uint64_t v35;
  _BYTE *v36;
  const char *v37;
  int v38;
  const char *v39;
  int v40;
  CFStringRef v41;
  CFStringRef v42;
  CFURLRef v43;
  __CFReadStream *v44;
  __CFReadStream *v45;
  os_log_s **v46;
  CFPropertyListRef v47;
  const void *v48;
  CFTypeID v49;
  int Code;
  unsigned int v51;
  CFNumberRef Value;
  CFNumberRef v53;
  CFTypeID v54;
  int64_t v55;
  CFURLRef v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  int v62;
  int v63;
  os_log_s *v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  os_log_s *v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  int v82;
  uint64_t v83;
  const char *v84;
  os_log_s *v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  os_log_s *v94;
  os_log_type_t v95;
  uint32_t v96;
  kern_return_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  int v111;
  int v112;
  uint64_t i;
  void *v114;
  uint64_t v115;
  int *v116;
  uint64_t v117;
  _DWORD *v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  uint64_t v122;
  uint64_t v123;
  _DWORD *v124;
  _UNKNOWN **v125;
  void (*v126)(_DWORD *);
  uint64_t v127;
  void *v128;
  int v129;
  _BYTE *v130;
  uint64_t v131;
  const char *j;
  uint64_t v134;
  unsigned int v135;
  uint64_t v136;
  uint64_t v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  char *v141;
  uint64_t v142;
  uint64_t v143;
  uint64_t v144;
  uint64_t v145;
  uint64_t v146;
  char v147;
  char v148;
  int v149;
  const char *v150;
  os_log_s *v151;
  char *v152;
  int v153;
  int v154;
  int v155;
  os_log_s *v156;
  int *v157;
  uint64_t v158;
  uint64_t v159;
  uint64_t v160;
  uint64_t v161;
  uint64_t v162;
  uint64_t v163;
  uint64_t v164;
  uint64_t v165;
  uint64_t v166;
  uint64_t v167;
  int v168;
  unsigned int v169;
  unsigned int v170;
  unsigned int v171;
  uint64_t v172;
  int v173;
  int v174;
  os_log_s *v175;
  int *v176;
  uint64_t v177;
  uint64_t v178;
  uint64_t v179;
  uint64_t v180;
  uint64_t v181;
  int v182;
  int v183;
  os_log_s *v184;
  int *v185;
  uint64_t v186;
  uint64_t v187;
  uint64_t v188;
  uint64_t v189;
  uint64_t v190;
  os_log_s *v191;
  int v192;
  int *v193;
  uint64_t v194;
  uint64_t v195;
  uint64_t v196;
  uint64_t v197;
  uint64_t v198;
  uint64_t v199;
  int v200;
  os_log_s *v201;
  int v202;
  int *v203;
  uint64_t v204;
  uint64_t v205;
  uint64_t v206;
  uint64_t v207;
  uint64_t v208;
  CFStringRef NetworkInterfaceEntity;
  const __SCDynamicStore *v210;
  __CFArray *Mutable;
  CFStringRef v212;
  CFStringRef v213;
  CFMutableArrayRef v214;
  __CFArray *v215;
  CFRunLoopSourceRef RunLoopSource;
  __CFRunLoop *Main;
  int v218;
  os_log_s *v219;
  int v220;
  int v221;
  uint64_t v222;
  uint64_t v223;
  uint64_t v224;
  uint64_t v225;
  uint64_t v226;
  uint64_t v227;
  uint64_t v228;
  uint64_t v229;
  uint64_t v230;
  uint64_t v231;
  const __SCDynamicStore *v232;
  char *v233;
  uint64_t v234;
  os_log_s *v235;
  uint64_t v236;
  os_log_s *v237;
  uint64_t v238;
  int v239;
  os_log_s *v240;
  uint64_t v241;
  uint64_t v242;
  uint64_t v243;
  uint64_t v244;
  uint64_t v245;
  int v246;
  int v247;
  int v248;
  uint64_t v249;
  void *v250;
  time_t v251;
  int v252;
  uint64_t v253;
  uint64_t v254;
  uint64_t v255;
  uint64_t v256;
  uint64_t v257;
  uint64_t v258;
  uint64_t v259;
  uint64_t v260;
  uint64_t v261;
  uint64_t v262;
  uint64_t v263;
  uint64_t v264;
  uint64_t v265;
  uint64_t v266;
  uint64_t v267;
  uint64_t v268;
  uint64_t v269;
  uint64_t v270;
  uint64_t v271;
  uint64_t v272;
  uint64_t v273;
  uint64_t v274;
  uint64_t v275;
  uint64_t v276;
  uint64_t v277;
  io_connect_t v278;
  uint64_t v279;
  uint64_t v280;
  uint64_t v281;
  uint64_t v282;
  uint64_t v283;
  __CFRunLoop *v284;
  __CFRunLoopSource *v285;
  const char *v286;
  int v287;
  char v288;
  char v289;
  int v290;
  os_log_s *v291;
  int *v292;
  uint64_t v293;
  uint64_t v294;
  uint64_t v295;
  uint64_t v296;
  uint64_t v297;
  uint64_t v298;
  uint64_t v299;
  uint64_t v300;
  uint64_t v301;
  uint64_t v302;
  int v303;
  os_log_s *v304;
  int *v305;
  uint64_t v306;
  uint64_t v307;
  uint64_t v308;
  uint64_t v309;
  uint64_t v310;
  os_log_s *v311;
  os_log_type_t v312;
  os_log_s *v313;
  _BYTE *v314;
  char v315;
  uint64_t v316;
  uint64_t v317;
  uint64_t v318;
  uint64_t v319;
  uint64_t v320;
  uint64_t v321;
  uint64_t v322;
  uint64_t v323;
  uint64_t v324;
  uint64_t v325;
  uint64_t v326;
  uint64_t v327;
  uint64_t v328;
  uint64_t v329;
  uint64_t v330;
  uint64_t v331;
  uint64_t v332;
  uint64_t v333;
  uint64_t v334;
  uint64_t v335;
  uint64_t v336;
  uint64_t v337;
  os_log_s *v338;
  uint64_t v340;
  uint64_t v341;
  uint64_t v342;
  uint64_t v343;
  uint64_t v344;
  uint64_t v345;
  int v346;
  __CFMachPort *v347;
  __CFRunLoopSource *v348;
  __CFRunLoop *v349;
  xpc_connection_t mach_service;
  _xpc_connection_s *v351;
  os_log_s *v352;
  int v353;
  int v354;
  os_log_s *v355;
  uint64_t v356;
  uint64_t v357;
  uint64_t v358;
  uint64_t v359;
  uint64_t v360;
  int *v361;
  uint64_t v362;
  int v363;
  int v364;
  mode_t v365;
  uint64_t v366;
  int v367;
  int8x16_t v368;
  BOOL v369;
  uint64_t v370;
  uint64_t v371;
  uint64_t v372;
  uint64_t v373;
  uint64_t v374;
  uint64_t v375;
  uint64_t v376;
  uint64_t v377;
  uint64_t v378;
  uint64_t v379;
  uint64_t v380;
  uint64_t v381;
  uint64_t v382;
  uint64_t v383;
  uint64_t v384;
  uint64_t v385;
  int v386;
  os_log_s *v387;
  uint64_t v388;
  uint64_t v389;
  uint64_t v390;
  uint64_t v391;
  uint64_t v392;
  const char *v393;
  uint64_t v394;
  uint64_t v395;
  uint64_t v396;
  uint64_t v397;
  uint64_t v398;
  int v399;
  int v400;
  int v401;
  int v402;
  int v403;
  int v404;
  int v405;
  pthread_t v406;
  socklen_t v407;
  socklen_t v408;
  size_t v409;
  int v410[2];
  int v411[2];
  CFErrorRef error[2];
  __int128 v413;
  __int128 v414;
  __int128 v415;
  __int128 v416;
  __int128 v417;
  __int128 v418;
  __int128 v419;
  __int128 v420;
  __int128 v421;
  __int128 v422;
  __int128 v423;
  __int128 v424;
  __int128 v425;
  __int128 v426;
  __int128 v427;
  _BYTE cStr[112];
  __int128 v429;
  __int128 v430;
  __int128 v431;
  __int128 v432;
  __int128 v433;
  __int128 v434;
  __int128 v435;
  __int128 v436;
  __int128 v437;
  sockaddr v438;
  mDNSLogCategory_Default = (uint64_t)os_log_create("com.apple.mDNSResponder", "Default");
  v5 = os_log_create("com.apple.mDNSResponder", "Default_redacted");
  mDNSLogCategory_Default_redacted = (uint64_t)v5;
  if (mDNSLogCategory_Default) {
    v6 = v5 == 0LL;
  }
  else {
    v6 = 1;
  }
  if (v6)
  {
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)cStr = 0;
      _os_log_error_impl( (void *)&_mh_execute_header,  (os_log_t)&_os_log_default,  OS_LOG_TYPE_ERROR,  "Could NOT create the Default log handle in mDNSResponder",  cStr,  2u);
    }

    mDNSLogCategory_Default = (uint64_t)&_os_log_default;
  }

  mDNSLogCategory_State = (uint64_t)os_log_create("com.apple.mDNSResponder", "State");
  v7 = os_log_create("com.apple.mDNSResponder", "State_redacted");
  mDNSLogCategory_State_redacted = (uint64_t)v7;
  if (!mDNSLogCategory_State || !v7)
  {
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)cStr = 0;
      _os_log_error_impl( (void *)&_mh_execute_header,  (os_log_t)&_os_log_default,  OS_LOG_TYPE_ERROR,  "Could NOT create the State log handle in mDNSResponder",  cStr,  2u);
    }

    mDNSLogCategory_State = (uint64_t)&_os_log_default;
  }

  mDNSLogCategory_mDNS = (uint64_t)os_log_create("com.apple.mDNSResponder", "mDNS");
  v8 = os_log_create("com.apple.mDNSResponder", "mDNS_redacted");
  mDNSLogCategory_mDNS_redacted = (uint64_t)v8;
  if (!mDNSLogCategory_mDNS || !v8)
  {
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)cStr = 0;
      _os_log_error_impl( (void *)&_mh_execute_header,  (os_log_t)&_os_log_default,  OS_LOG_TYPE_ERROR,  "Could NOT create the mDNS log handle in mDNSResponder",  cStr,  2u);
    }

    mDNSLogCategory_mDNS = (uint64_t)&_os_log_default;
  }

  mDNSLogCategory_uDNS = (uint64_t)os_log_create("com.apple.mDNSResponder", "uDNS");
  v9 = os_log_create("com.apple.mDNSResponder", "uDNS_redacted");
  mDNSLogCategory_uDNS_redacted = (uint64_t)v9;
  if (!mDNSLogCategory_uDNS || !v9)
  {
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)cStr = 0;
      _os_log_error_impl( (void *)&_mh_execute_header,  (os_log_t)&_os_log_default,  OS_LOG_TYPE_ERROR,  "Could NOT create the uDNS log handle in mDNSResponder",  cStr,  2u);
    }

    mDNSLogCategory_uDNS = (uint64_t)&_os_log_default;
  }

  mDNSLogCategory_SPS = (uint64_t)os_log_create("com.apple.mDNSResponder", "SPS");
  v10 = os_log_create("com.apple.mDNSResponder", "SPS_redacted");
  mDNSLogCategory_SPS_redacted = (uint64_t)v10;
  if (!mDNSLogCategory_SPS || !v10)
  {
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)cStr = 0;
      _os_log_error_impl( (void *)&_mh_execute_header,  (os_log_t)&_os_log_default,  OS_LOG_TYPE_ERROR,  "Could NOT create the SPS log handle in mDNSResponder",  cStr,  2u);
    }

    mDNSLogCategory_SPS = (uint64_t)&_os_log_default;
  }

  mDNSLogCategory_NAT = (uint64_t)os_log_create("com.apple.mDNSResponder", "NAT");
  v11 = os_log_create("com.apple.mDNSResponder", "NAT_redacted");
  mDNSLogCategory_NAT_redacted = (uint64_t)v11;
  if (!mDNSLogCategory_NAT || !v11)
  {
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)cStr = 0;
      _os_log_error_impl( (void *)&_mh_execute_header,  (os_log_t)&_os_log_default,  OS_LOG_TYPE_ERROR,  "Could NOT create the NAT log handle in mDNSResponder",  cStr,  2u);
    }

    mDNSLogCategory_NAT = (uint64_t)&_os_log_default;
  }

  mDNSLogCategory_D2D = (uint64_t)os_log_create("com.apple.mDNSResponder", "D2D");
  v12 = os_log_create("com.apple.mDNSResponder", "D2D_redacted");
  mDNSLogCategory_D2D_redacted = (uint64_t)v12;
  if (!mDNSLogCategory_D2D || !v12)
  {
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)cStr = 0;
      _os_log_error_impl( (void *)&_mh_execute_header,  (os_log_t)&_os_log_default,  OS_LOG_TYPE_ERROR,  "Could NOT create the D2D log handle in mDNSResponder",  cStr,  2u);
    }

    mDNSLogCategory_D2D = (uint64_t)&_os_log_default;
  }

  mDNSLogCategory_XPC = (uint64_t)os_log_create("com.apple.mDNSResponder", "XPC");
  v13 = os_log_create("com.apple.mDNSResponder", "XPC_redacted");
  mDNSLogCategory_XPC_redacted = (uint64_t)v13;
  if (!mDNSLogCategory_XPC || !v13)
  {
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)cStr = 0;
      _os_log_error_impl( (void *)&_mh_execute_header,  (os_log_t)&_os_log_default,  OS_LOG_TYPE_ERROR,  "Could NOT create the XPC log handle in mDNSResponder",  cStr,  2u);
    }

    mDNSLogCategory_XPC = (uint64_t)&_os_log_default;
  }

  mDNSLogCategory_Analytics = (uint64_t)os_log_create("com.apple.mDNSResponder", "Analytics");
  v14 = os_log_create("com.apple.mDNSResponder", "Analytics_redacted");
  mDNSLogCategory_Analytics_redacted = (uint64_t)v14;
  if (!mDNSLogCategory_Analytics || !v14)
  {
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)cStr = 0;
      _os_log_error_impl( (void *)&_mh_execute_header,  (os_log_t)&_os_log_default,  OS_LOG_TYPE_ERROR,  "Could NOT create the Analytics log handle in mDNSResponder",  cStr,  2u);
    }

    mDNSLogCategory_Analytics = (uint64_t)&_os_log_default;
  }

  mDNSLogCategory_DNSSEC = (uint64_t)os_log_create("com.apple.mDNSResponder", "DNSSEC");
  v15 = os_log_create("com.apple.mDNSResponder", "DNSSEC_redacted");
  mDNSLogCategory_DNSSEC_redacted = (uint64_t)v15;
  if (!mDNSLogCategory_DNSSEC || !v15)
  {
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)cStr = 0;
      _os_log_error_impl( (void *)&_mh_execute_header,  (os_log_t)&_os_log_default,  OS_LOG_TYPE_ERROR,  "Could NOT create the DNSSEC log handle in mDNSResponder",  cStr,  2u);
    }

    mDNSLogCategory_DNSSEC = (uint64_t)&_os_log_default;
  }

  mDNSMacOSXSystemBuildNumber(0LL);
  LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "%s starting %s %d",  v16,  v17,  v18,  v19,  v20,  (int)"mDNSResponder mDNSResponder-2559.60.39.0.1 (Nov 10 2024 02:11:03)");
  if (geteuid())
  {
    v26 = &unk_100150000;
    v27 = &unk_100158000;
    if (argc >= 2)
    {
      v28 = "-NoMulticastAdvertisements";
      v29 = "-DisableSleepProxyClient";
      v30 = 1;
      do
      {
        v31 = argv[v30];
        if (!strcasecmp(v31, v28)) {
          v26[1240] = 1;
        }
        if (!strcasecmp(v31, v29)) {
          DisableSleepProxyClient = 1;
        }
        if (!strcasecmp(v31, "-DebugLogging")) {
          v27[2840] = 1;
        }
        if (!strcasecmp(v31, "-UnicastPacketLogging")) {
          mDNS_PacketLoggingEnabled = 1;
        }
        v32 = v30;
        if (!strcasecmp(v31, "-OfferSleepProxyService"))
        {
          v33 = v29;
          v34 = v28;
          v35 = v30 + 1LL;
          if (v30 + 1 >= argc)
          {
            v38 = 100;
          }

          else
          {
            v36 = v27;
            v37 = argv[v35];
            if (*(unsigned __int8 *)v37 - 48 > 9
              || *((unsigned __int8 *)v37 + 1) - 48 > 9
              || v37[2])
            {
              v38 = 100;
            }

            else
            {
              v38 = atoi(argv[v35]);
              v31 = v37;
              v32 = ++v30;
            }

            v27 = v36;
            v26 = (_BYTE *)&unk_100150000;
          }

          OfferSleepProxyService = v38;
          v28 = v34;
          v29 = v33;
        }

        if (!strcasecmp(v31, "-UseInternalSleepProxy"))
        {
          if (v30 + 1 >= argc || (v39 = argv[v30 + 1], *(unsigned __int8 *)v39 - 48 > 9) || v39[1])
          {
            v40 = 1;
          }

          else
          {
            v40 = atoi(v39);
            ++v30;
          }

          UseInternalSleepProxy = v40;
          v32 = v30;
          v31 = argv[v30];
        }

        if (!strcasecmp(v31, "-StrictUnicastOrdering"))
        {
          StrictUnicastOrdering = 1;
          v31 = argv[v32];
        }

        if (!strcasecmp(v31, "-AlwaysAppendSearchDomains"))
        {
          AlwaysAppendSearchDomains = 1;
          v31 = argv[v32];
        }

        if (!strcasecmp(v31, "-DisableAllowExpired")) {
          EnableAllowExpired = 0;
        }
        ++v30;
      }

      while (v30 < argc);
    }

    v27[2840] = 1;
    mDNS_PacketLoggingEnabled = 1;
    v26[1240] = PreferencesGetValueBool(@"NoMulticastAdvertisements", v26[1240]);
    StrictUnicastOrdering = PreferencesGetValueBool( @"StrictUnicastOrdering",  StrictUnicastOrdering);
    AlwaysAppendSearchDomains = PreferencesGetValueBool( @"AlwaysAppendSearchDomains",  AlwaysAppendSearchDomains);
    EnableAllowExpired = PreferencesGetValueBool(@"EnableAllowExpired", EnableAllowExpired);
    OfferSleepProxyService = PreferencesGetValueInt( @"OfferSleepProxyService",  OfferSleepProxyService);
    UseInternalSleepProxy = PreferencesGetValueInt(@"UseInternalSleepProxy", UseInternalSleepProxy);
    PQWorkaroundThreshold = PreferencesGetValueInt(@"PQWorkaroundThreshold", PQWorkaroundThreshold);
    *(void *)cStr = 0LL;
    asprintf((char **)cStr, "/Library/Managed Preferences/mobile/%s.plist", "com.apple.mDNSResponder");
    if (*(void *)cStr)
    {
      v41 = CFStringCreateWithCStringNoCopy(0LL, *(const char **)cStr, 0x8000100u, kCFAllocatorMalloc);
      if (v41)
      {
        v42 = v41;
        *(void *)cStr = 0LL;
        v43 = CFURLCreateWithFileSystemPath(kCFAllocatorDefault, v41, kCFURLPOSIXPathStyle, 0);
        CFRelease(v42);
        if (v43)
        {
          v44 = CFReadStreamCreateWithFile(kCFAllocatorDefault, v43);
          v45 = v44;
          v46 = (os_log_s **)&unk_100164000;
          if (v44)
          {
            if (CFReadStreamOpen(v44))
            {
              error[0] = 0LL;
              v47 = CFPropertyListCreateWithStream(0LL, v45, 0LL, 0LL, 0LL, error);
              if (v47)
              {
                v48 = v47;
                v49 = CFGetTypeID(v47);
                if (v49 == CFDictionaryGetTypeID())
                {
                  Code = 0;
                }

                else
                {
                  CFRelease(v48);
                  v48 = 0LL;
                  Code = -6756;
                }
              }

              else
              {
                if (error[0]) {
                  Code = CFErrorGetCode(error[0]);
                }
                else {
                  Code = -6700;
                }
                if (_mdns_managed_defaults_log_s_once != -1) {
                  dispatch_once(&_mdns_managed_defaults_log_s_once, &__block_literal_global_2302);
                }
                v313 = (os_log_s *)_mdns_managed_defaults_log_s_log;
                if (os_log_type_enabled((os_log_t)_mdns_managed_defaults_log_s_log, OS_LOG_TYPE_ERROR))
                {
                  *(_DWORD *)cStr = 138543362;
                  *(CFErrorRef *)&cStr[4] = error[0];
                  _os_log_error_impl( (void *)&_mh_execute_header,  v313,  OS_LOG_TYPE_ERROR,  "CFPropertyListCreateWithStream failed: %{public}@",  cStr,  0xCu);
                }

                v48 = 0LL;
              }

              if (error[0]) {
                CFRelease(error[0]);
              }
              CFRelease(v45);
              if (v48)
              {
                CFRelease(v43);
                v51 = PQWorkaroundThreshold;
                Value = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)v48, @"PQWorkaroundThreshold");
                if (Value)
                {
                  v53 = Value;
                  v54 = CFGetTypeID(Value);
                  if (v54 == CFNumberGetTypeID() && !CFNumberIsFloatType(v53))
                  {
                    *(void *)cStr = 0LL;
                    if (CFNumberGetValue(v53, kCFNumberSInt64Type, cStr))
                    {
                      v55 = *(void *)cStr;
                      else {
                        v51 = v55;
                      }
                    }
                  }
                }

                PQWorkaroundThreshold = v51;
                v56 = (const __CFURL *)v48;
                goto LABEL_111;
              }

              if (_mdns_managed_defaults_log_s_once != -1) {
                dispatch_once(&_mdns_managed_defaults_log_s_once, &__block_literal_global_2302);
              }
              v237 = (os_log_s *)_mdns_managed_defaults_log_s_log;
              if (os_log_type_enabled((os_log_t)_mdns_managed_defaults_log_s_log, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)cStr = 138543618;
                *(void *)&cStr[4] = v43;
                *(_WORD *)&cStr[12] = 2048;
                *(void *)&cStr[14] = Code;
                _os_log_error_impl( (void *)&_mh_execute_header,  v237,  OS_LOG_TYPE_ERROR,  "Failed to create dictionary -- url: %{public}@, error: %{mdns:err}ld",  cStr,  0x16u);
              }

LABEL_311:
              v56 = v43;
LABEL_111:
              CFRelease(v56);
              v26 = &unk_100150000;
              goto LABEL_112;
            }

            CFRelease(v45);
            v236 = -6755LL;
          }

          else
          {
            v236 = -6729LL;
          }

          if (_mdns_managed_defaults_log_s_once != -1) {
            dispatch_once(&_mdns_managed_defaults_log_s_once, &__block_literal_global_2302);
          }
          v311 = (os_log_s *)_mdns_managed_defaults_log_s_log;
          if (v45) {
            v312 = OS_LOG_TYPE_DEBUG;
          }
          else {
            v312 = OS_LOG_TYPE_ERROR;
          }
          if (os_log_type_enabled((os_log_t)_mdns_managed_defaults_log_s_log, v312))
          {
            *(_DWORD *)cStr = 138543618;
            *(void *)&cStr[4] = v43;
            *(_WORD *)&cStr[12] = 2048;
            *(void *)&cStr[14] = v236;
            _os_log_impl( (void *)&_mh_execute_header,  v311,  v312,  "Failed to create read stream -- url: %{public}@, error: %{mdns:err}ld",  cStr,  0x16u);
          }

          goto LABEL_311;
        }

        v234 = -6729LL;
        v26 = (_BYTE *)&unk_100150000;
      }

      else
      {
        if (*(void *)cStr) {
          free(*(void **)cStr);
        }
        v234 = -6729LL;
      }
    }

    else
    {
      v234 = -6728LL;
    }

    v46 = (os_log_s **)&unk_100164000;
    if (_mdns_managed_defaults_log_s_once != -1) {
      dispatch_once(&_mdns_managed_defaults_log_s_once, &__block_literal_global_2302);
    }
    v235 = (os_log_s *)_mdns_managed_defaults_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_managed_defaults_log_s_log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)cStr = 136446466;
      *(void *)&cStr[4] = "com.apple.mDNSResponder";
      *(_WORD *)&cStr[12] = 2048;
      *(void *)&cStr[14] = v234;
      _os_log_error_impl( (void *)&_mh_execute_header,  v235,  OS_LOG_TYPE_ERROR,  "Failed to create URL -- domain: %{public}s, error: %{mdns:err}ld",  cStr,  0x16u);
    }

              GetRRDisplayString_rdb(v322, (unsigned __int16 *)(*(void *)(v81 + 48) + 4LL), v334);
              *(_DWORD *)__dst = 134219779;
              *(void *)&__dst[4] = v194;
              *(_WORD *)&__dst[12] = 2160;
              *(void *)&__dst[14] = 1752392040LL;
              *(_WORD *)&__dst[22] = 2085;
              *(void *)&__dst[24] = v328;
              *(_WORD *)&__dst[32] = 2160;
              *(void *)&__dst[34] = 1752392040LL;
              *(_WORD *)&__dst[42] = 1040;
              *(_DWORD *)&__dst[44] = v204;
              *(_WORD *)&__dst[48] = 2101;
              *(void *)&__dst[50] = v196;
              *(_WORD *)&__dst[58] = 2160;
              *(void *)&__dst[60] = 1752392040LL;
              *(_WORD *)&__dst[68] = 2085;
              *(void *)&__dst[70] = a1 + 46976;
              _os_log_impl( (void *)&_mh_execute_header,  v193,  OS_LOG_TYPE_DEFAULT,  "ProbeRRMatchAndTSRCheck: Conflict with our ar %p rrtype: %{sensitive, mask.hash}s, name: %{sensitive, ma sk.hash, mdnsresponder:domain_name}.*P%{sensitive, mask.hash}s",  __dst,  0x4Eu);
              v11 = a2;
              v17 = a1 + 37865;
            }
          }

          else
          {
            v193 = (os_log_s *)mDNSLogCategory_mDNS_redacted;
            if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
            {
              v194 = *(void *)(v81 + 32);
              v195 = DNSTypeName(*(unsigned __int16 *)(v81 + 12));
              v196 = *(void *)(v81 + 40);
              v328 = v195;
              if (v196)
              {
                v197 = *(_BYTE **)(v81 + 40);
                if (v196 == -256)
                {
                  while (1)
                  {
LABEL_289:
                    if (!v197) {
                      goto LABEL_303;
                    }
                    v198 = *v197;
                    if (!*v197) {
                      break;
                    }
                    v197 += v198 + 1;
                    if (v196 != -256) {
                      goto LABEL_288;
                    }
                  }

                  v202 = (_WORD)v197 - v196 + 1;
                }

                else
                {
LABEL_288:
LABEL_303:
                  v202 = 257;
                }

                v204 = v202;
              }

              else
              {
                v204 = 0;
              }

              goto LABEL_311;
            }
          }

          v205 = (os_log_s *)mDNSLogCategory_mDNS;
          v67 = a4;
          if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
          {
            if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
            {
              v206 = *(void *)(v81 + 40);
              if (v206)
              {
                v210 = *(_BYTE **)(v81 + 40);
                if (v206 == -256) {
                  goto LABEL_331;
                }
LABEL_328:
                v211 = 257;
                if ((unint64_t)v210 < v206 + 256 && v210)
                {
                  while (1)
                  {
                    v212 = *v210;
                    if (v212 > 0x3F)
                    {
LABEL_339:
                      v211 = 257;
                      goto LABEL_343;
                    }

                    if (!*v210) {
                      break;
                    }
                    v210 += v212 + 1;
                    if (v206 != -256) {
                      goto LABEL_328;
                    }
LABEL_331:
                    if (!v210) {
                      goto LABEL_339;
                    }
                  }

                  v211 = (_WORD)v210 - v206 + 1;
                }

        v30 = (unsigned int *)&v113[v114];
        if (!&v113[v114]) {
          return 0LL;
        }
        goto LABEL_37;
      }

      DomainName = getDomainName(a1, __src, a3, (_BYTE *)v13 + 4);
      if (!DomainName) {
        return 0LL;
      }
      v30 = (unsigned int *)getDomainName(v12, DomainName, v10, (_BYTE *)v13 + 260);
      if (!v30) {
        return 0LL;
      }
LABEL_37:
      *((_DWORD *)v13 + 129) = bswap32(*v30);
      *((_DWORD *)v13 + 130) = bswap32(v30[1]);
      *((_DWORD *)v13 + 131) = bswap32(v30[2]);
      *((_DWORD *)v13 + 132) = bswap32(v30[3]);
      *((_DWORD *)v13 + 133) = bswap32(v30[4]);
      return 1LL;
    case 0xA:
    case 0xB:
    case 0x10:
    case 0x13:
    case 0x14:
    case 0x16:
    case 0x18:
    case 0x19:
    case 0x1B:
    case 0x1D:
    case 0x1E:
    case 0x1F:
    case 0x20:
    case 0x22:
    case 0x25:
    case 0x26:
    case 0x28:
    case 0x2A:
    case 0x2B:
    case 0x2C:
    case 0x2D:
    case 0x2E:
    case 0x30:
    case 0x31:
    case 0x32:
    case 0x33:
    case 0x34:
    case 0x35:
    case 0x36:
    case 0x37:
    case 0x38:
    case 0x39:
    case 0x3A:
    case 0x3B:
    case 0x3C:
    case 0x3D:
    case 0x3E:
    case 0x3F:
    case 0x40:
    case 0x41:
      goto LABEL_43;
    case 0xD:
      if (a3 > (unint64_t)__src && (_DWORD)__n == (_DWORD)a3 - (_DWORD)__src)
      {
        v31 = *__src + 1LL;
        if (v31 >= __n)
        {
          v102 = mDNSLogCategory_Default;
          if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
          {
            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEBUG)) {
              return 0LL;
            }
            *(_WORD *)buf = 0;
            v73 = "SetRData: Malformed HINFO RDATA - CPU character string goes out of boundary";
          }

          else
          {
            v102 = mDNSLogCategory_Default_redacted;
            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEBUG)) {
              return 0LL;
            }
            *(_WORD *)buf = 0;
            v73 = "SetRData: Malformed HINFO RDATA - CPU character string goes out of boundary";
          }
        }

        else
        {
          if (__src[v31] + 1 == (_DWORD)a3 - ((_DWORD)__src + (_DWORD)v31)) {
            goto LABEL_43;
          }
          v102 = mDNSLogCategory_Default;
          if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
          {
            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEBUG)) {
              return 0LL;
            }
            *(_WORD *)buf = 0;
            v73 = "SetRData: Malformed HINFO RDATA - OS character string does not end at the RDATA ending";
          }

          else
          {
            v102 = mDNSLogCategory_Default_redacted;
            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEBUG)) {
              return 0LL;
            }
            *(_WORD *)buf = 0;
            v73 = "SetRData: Malformed HINFO RDATA - OS character string does not end at the RDATA ending";
          }
        }

        v87 = (os_log_s *)v102;
        v88 = 2;
      }

      else
      {
        v71 = mDNSLogCategory_Default;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
        {
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEBUG)) {
            return 0LL;
          }
          *(_DWORD *)buf = 67109120;
          *(_DWORD *)&buf[4] = v8;
          v73 = "SetRData: Malformed HINFO RDATA - invalid RDATA length: %u";
        }

        else
        {
          v71 = mDNSLogCategory_Default_redacted;
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEBUG)) {
            return 0LL;
          }
          *(_DWORD *)buf = 67109120;
          *(_DWORD *)&buf[4] = v8;
          v73 = "SetRData: Malformed HINFO RDATA - invalid RDATA length: %u";
        }

        v87 = (os_log_s *)v71;
        v88 = 8;
      }

      _os_log_impl((void *)&_mh_execute_header, v87, OS_LOG_TYPE_DEBUG, v73, buf, v88);
      return 0LL;
    case 0xE:
    case 0x11:
      if (a1)
      {
        v28 = getDomainName(a1, __src, a3, (_BYTE *)v13 + 4);
        if (!v28) {
          return 0LL;
        }
        v16 = v28;
        v17 = v13 + 130;
        goto LABEL_50;
      }

      v67 = v13 + 130;
      v68 = 257LL;
      v69 = v13 + 2;
      while (2)
      {
        if (v69)
        {
          v70 = *(unsigned __int8 *)v69;
          if (v70 <= 0x3F)
          {
            if (*(_BYTE *)v69)
            {
              v69 = (unsigned __int16 *)((char *)v69 + v70 + 1);
              if (v13 != (unsigned __int16 *)-260LL)
              {
LABEL_125:
                if (v69 >= v67) {
                  break;
                }
              }

              continue;
            }

            v68 = (unsigned __int16)((_WORD)v69 - (_WORD)v14 + 1);
          }
        }

        break;
      }

      v11 += v68;
      if (v11 && AssignDomainNameWithLimit((_BYTE *)v13 + 260, v11, v10))
      {
        v19 = 257LL;
        v92 = v13 + 130;
        while (1)
        {
          if (v92 >= (_BYTE *)v13 + 516) {
            goto LABEL_303;
          }
          do
          {
LABEL_189:
            if (!v92) {
              goto LABEL_303;
            }
            v93 = *v92;
            if (!*v92)
            {
              v117 = (_WORD)v92 - (_WORD)v67;
              goto LABEL_302;
            }

            v92 += v93 + 1;
          }

          while (v13 == (unsigned __int16 *)-516LL);
        }
      }

      return 0LL;
    case 0xF:
    case 0x12:
    case 0x15:
    case 0x24:
      v11 = __src + 2;
      v13[2] = bswap32(*(unsigned __int16 *)__src) >> 16;
      v14 = v13 + 3;
      if (a1) {
        goto LABEL_3;
      }
      v19 = 257LL;
      v20 = v13 + 3;
      while (2)
      {
        if (!v20) {
          goto LABEL_303;
        }
        v21 = *v20;
        if (*v20)
        {
          v20 += v21 + 1;
          if (v13 != (unsigned __int16 *)-262LL)
          {
LABEL_9:
            if (v20 >= (_BYTE *)v13 + 262) {
              goto LABEL_303;
            }
          }

          continue;
        }

        goto LABEL_301;
      }

    case 0x1A:
      v35 = (char *)(__src + 2);
      v13[2] = bswap32(*(unsigned __int16 *)__src) >> 16;
      if (a1)
      {
        v36 = getDomainName(a1, __src + 2, a3, (_BYTE *)v13 + 6);
        if (!v36) {
          return 0LL;
        }
        v16 = v36;
        v17 = v13 + 131;
LABEL_50:
        a1 = v12;
        a3 = v10;
LABEL_4:
        v18 = getDomainName(a1, v16, a3, v17);
        return v18 == (unsigned __int8 *)v10;
      }

      v14 = v13 + 131;
      v89 = 257LL;
      v90 = v13 + 3;
      while (2)
      {
        if (v90)
        {
          v91 = *v90;
          if (v91 <= 0x3F)
          {
            if (*v90)
            {
              v90 += v91 + 1;
              if (v13 != (unsigned __int16 *)-262LL)
              {
LABEL_174:
                if (v90 >= (_BYTE *)v14) {
                  break;
                }
              }

              continue;
            }

            v89 = (unsigned __int16)((_WORD)v90 - ((_WORD)v13 + 6) + 1);
          }
        }

        break;
      }

      v11 = (unsigned __int8 *)&v35[v89];
      if (v11 && AssignDomainNameWithLimit((_BYTE *)v13 + 262, v11, v10))
      {
        v19 = 257LL;
        v20 = v13 + 131;
        while (1)
        {
          if (v20 >= (_BYTE *)v13 + 518) {
            goto LABEL_303;
          }
          do
          {
LABEL_296:
            if (!v20) {
              goto LABEL_303;
            }
            v122 = *v20;
            if (!*v20) {
              goto LABEL_301;
            }
            v20 += v122 + 1;
          }

          while (v13 == (unsigned __int16 *)-518LL);
        }
      }

      return 0LL;
    case 0x1C:
      if ((_DWORD)__n != 16) {
        return 0LL;
      }
      *v14 = *(_OWORD *)__src;
      return 1LL;
    case 0x21:
      v13[2] = bswap32(*(unsigned __int16 *)__src) >> 16;
      v13[3] = bswap32(*((unsigned __int16 *)__src + 1)) >> 16;
      *((_BYTE *)v13 + 8) = __src[4];
      *((_BYTE *)v13 + 9) = __src[5];
      v11 = __src + 6;
      v14 = v13 + 5;
      if (a1)
      {
LABEL_3:
        v16 = v11;
        v17 = v14;
        goto LABEL_4;
      }

      v19 = 257LL;
      v20 = v13 + 5;
      while (2)
      {
        if (v20)
        {
          v37 = *v20;
          if (v37 <= 0x3F)
          {
            if (*v20)
            {
              v20 += v37 + 1;
              if (v13 != (unsigned __int16 *)-266LL)
              {
LABEL_57:
                if (v20 >= (_BYTE *)v13 + 266) {
                  break;
                }
              }

              continue;
            }

LABEL_112:
    if (v26[1240]) {
      LogMsgWithLevel( v46[170],  OS_LOG_TYPE_DEFAULT,  "-NoMulticastAdvertisements is set: Administratively prohibiting multicast advertisements",  v57,  v58,  v59,  v60,  v61,  v400);
    }
    if (AlwaysAppendSearchDomains) {
      LogMsgWithLevel(v46[170], OS_LOG_TYPE_DEFAULT, "-AlwaysAppendSearchDomains is set", v57, v58, v59, v60, v61, v400);
    }
    if (StrictUnicastOrdering) {
      LogMsgWithLevel(v46[170], OS_LOG_TYPE_DEFAULT, "-StrictUnicastOrdering is set", v57, v58, v59, v60, v61, v400);
    }
    signal(1, (void (__cdecl *)(int))HandleSIG);
    signal(2, (void (__cdecl *)(int))HandleSIG);
    signal(13, (void (__cdecl *)(int))1);
    signal(15, (void (__cdecl *)(int))HandleSIG);
    signal(29, (void (__cdecl *)(int))HandleSIG);
    signal(30, (void (__cdecl *)(int))HandleSIG);
    signal(31, (void (__cdecl *)(int))HandleSIG);
    signal(27, (void (__cdecl *)(int))HandleSIG);
    signal(18, (void (__cdecl *)(int))HandleSIG);
    signal(28, (void (__cdecl *)(int))HandleSIG);
    mDNSStorage[0] = (uint64_t)&PlatformStorage;
    KQueueFD = kqueue();
    if (KQueueFD == -1)
    {
      v63 = *__error();
      v75 = v46[170];
      strerror(v63);
      LogMsgWithLevel(v75, OS_LOG_TYPE_DEFAULT, "kqueue() failed errno %d (%s)", v76, v77, v78, v79, v80, v63);
      if (v63) {
        goto LABEL_350;
      }
LABEL_342:
      CFRunLoopRun();
      v338 = v46[170];
      if (gSensitiveLoggingEnabled != 1 || v338 == (os_log_s *)mDNSLogCategory_State)
      {
        if (os_log_type_enabled(v46[170], OS_LOG_TYPE_FAULT))
        {
          *(_WORD *)cStr = 0;
          goto LABEL_348;
        }
      }

      else
      {
        v338 = (os_log_s *)mDNSLogCategory_Default_redacted;
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_FAULT))
        {
          *(_WORD *)cStr = 0;
LABEL_348:
          _os_log_impl((void *)&_mh_execute_header, v338, OS_LOG_TYPE_FAULT, "ERROR: CFRunLoopRun Exiting.", cStr, 2u);
        }
      }

      mDNS_StartExit();
      mDNS_FinalExit();
      v63 = 0;
      goto LABEL_350;
    }

    v62 = pthread_mutex_init(&stru_100150758, 0LL);
    if (v62)
    {
      v63 = v62;
      v64 = v46[170];
      strerror(v62);
      LogMsgWithLevel( v64,  OS_LOG_TYPE_DEFAULT,  "pthread_mutex_init() failed error %d (%s)",  v65,  v66,  v67,  v68,  v69,  v63);
LABEL_350:
      LogMsgWithLevel( v46[170],  OS_LOG_TYPE_DEFAULT,  "%s exiting",  v70,  v71,  v72,  v73,  v74,  (int)"mDNSResponder mDNSResponder-2559.60.39.0.1 (Nov 10 2024 02:11:03)");
      return v63;
    }

    pthread_mutex_lock(&stru_100150758);
    *(void *)v410 = 0LL;
    if (socketpair(1, 1, 0, v410) == -1)
    {
      v63 = *__error();
      v85 = v46[170];
      strerror(v63);
      LogMsgWithLevel(v85, OS_LOG_TYPE_DEFAULT, "socketpair() failed errno %d (%s)", v86, v87, v88, v89, v90, v63);
      goto LABEL_341;
    }

    dword_10015079C = v410[0];
    KQueueSet(v410[1], 1u, -1, &main_wakeKQEntry);
    v81 = getpid();
    v82 = sandbox_check(v81, 0LL, 0LL);
    switch(v82)
    {
      case -1:
        v82 = *__error();
        break;
      case 0:
        v93 = (uint64_t)v46[170];
        if (gSensitiveLoggingEnabled != 1 || v93 == mDNSLogCategory_State)
        {
          if (!os_log_type_enabled(v46[170], OS_LOG_TYPE_FAULT)) {
            goto LABEL_153;
          }
          *(_WORD *)cStr = 0;
          v84 = "mDNSResponder is not sandboxed (check for com.apple.private.sandbox.profile:embedded entitlement)";
        }

        else
        {
          v93 = mDNSLogCategory_Default_redacted;
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_FAULT)) {
            goto LABEL_153;
          }
          *(_WORD *)cStr = 0;
          v84 = "mDNSResponder is not sandboxed (check for com.apple.private.sandbox.profile:embedded entitlement)";
        }

        v94 = (os_log_s *)v93;
        v95 = OS_LOG_TYPE_FAULT;
        goto LABEL_151;
      case 1:
        v83 = (uint64_t)v46[170];
        if (gSensitiveLoggingEnabled != 1 || v83 == mDNSLogCategory_State)
        {
          if (!os_log_type_enabled(v46[170], OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_153;
          }
          *(_WORD *)cStr = 0;
          v84 = "mDNSResponder is sandboxed via com.apple.private.sandbox.profile:embedded entitlement";
        }

        else
        {
          v83 = mDNSLogCategory_Default_redacted;
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_153;
          }
          *(_WORD *)cStr = 0;
          v84 = "mDNSResponder is sandboxed via com.apple.private.sandbox.profile:embedded entitlement";
        }

        v94 = (os_log_s *)v83;
        v95 = OS_LOG_TYPE_DEFAULT;
LABEL_151:
        v96 = 2;
LABEL_152:
        _os_log_impl((void *)&_mh_execute_header, v94, v95, v84, cStr, v96);
LABEL_153:
        mDNSStorage[0] = (uint64_t)&PlatformStorage;
        dword_100158BC0 = 0;
        byte_100158BC4[0] = 0;
        byte_100158BC5 = NoMulticastAdvertisements == 0;
        byte_100158BC6 = 0;
        dword_100158BC8 = 1;
        *(void *)&word_100158BCC = 0LL;
        word_100158BD4 = 0;
        *((_BYTE *)mDNSStorage + &loc_1000093E8) = 0;
        dword_100158C04 = 0;
        qword_100158BE0 = 0LL;
        *(void *)&dword_100158BE8 = 0LL;
        off_100158BD8 = (uint64_t (*)(void, void))mDNS_StatusCallback;
        *(int *)((char *)&dword_100158BEC + 3) = 0;
        *(void *)cStr = 0LL;
        v97 = mach_timebase_info((mach_timebase_info_t)cStr);
        if (v97)
        {
          v63 = v97;
LABEL_340:
          LogMsgWithLevel( v46[170],  OS_LOG_TYPE_DEFAULT,  "Daemon start: mDNS_Init failed %d",  v98,  v99,  v100,  v101,  v102,  v63);
          LogMsgWithLevel( v46[170],  OS_LOG_TYPE_DEFAULT,  "Daemon start: mDNSDaemonInitialize failed",  v333,  v334,  v335,  v336,  v337,  v405);
          goto LABEL_341;
        }

        mDNSPlatformClockDivisor = 1000000 * (unint64_t)*(unsigned int *)&cStr[4] / *(unsigned int *)cStr;
        v103 = arc4random();
        dword_100158BF4 = v103;
        v111 = v103 + mDNSPlatformRawTime(v103, v104, v105, v106, v107, v108, v109, v110);
        dword_100158BF8 = 0;
        dword_100158BFC = v111;
        dword_100158C00 = v111;
        LODWORD(qword_100158C08) = v111;
        HIDWORD(qword_100158C08) = v111;
        *(int32x4_t *)&dword_100158C10 = vdupq_n_s32(v111 + 939524096);
        dword_100158C20 = v111 + 939524096;
        dword_100158C24 = v111 + 939524096;
        *(void *)&dword_100158C74 = (v111 + 939524096);
        *(void *)&dword_100158C28 = (v111 + 939524096);
        byte_100158C30 = 0;
        qword_100158C34 = 0LL;
        unk_100158C3C = 0LL;
        *(void *)((char *)&dword_100158C40 + 1) = 0LL;
        v112 = v111 + 60000;
        dword_100158C4C = v112;
        *(void *)&dword_100158C50 = 0LL;
        qword_100158C64 = 0LL;
        dword_100158C6C = 0;
        *(void *)&dword_100158CB0 = 0LL;
        *(_OWORD *)&qword_100158CA0 = 0u;
        *(_OWORD *)&qword_100158C90 = 0u;
        *(_OWORD *)&qword_100158C80 = 0u;
        qword_100158CBC = 0xA00000000LL;
        bzero(&qword_100158CD0, 0xF98uLL);
        for (i = 0LL; i != 1996; i += 4LL)
          *(_DWORD *)((char *)&mDNSStorage[534] + i) = v111 + 939524096;
        v114 = &unk_1001509D0;
        v115 = 146LL;
        do
        {
          *(v114 - 28) = v114;
          v114 += 28;
          --v115;
        }

        while (v115);
        qword_1001587D0 = 0LL;
        v116 = &dword_100158CB0;
        qword_100158CC8 = (uint64_t)&rrcachestorage;
        *((_BYTE *)&dword_100158CB0 + &unk_100002778) = 0;
        *((_BYTE *)&dword_100158CB0 + &unk_1000027B8) = 0;
        *((_BYTE *)&dword_100158CB0 + &unk_1000028B8) = 0;
        v117 = (uint64_t)mDNSStorage;
        *((_BYTE *)&dword_100158CB0 + &unk_1000029C0) = 0;
        dword_100158CB0 += 146;
        *((_BYTE *)&dword_100158CB0 + &unk_100002AC0) = 0;
        bzero((char *)&dword_100158CB0 + &unk_100001798, 0xFA1uLL);
        byte_10015BD28 = 0;
        xmmword_10015BD18 = 0u;
        xmmword_10015BD08 = 0u;
        xmmword_10015BD30 = 0u;
        dword_10015BD40 = 0;
        dword_10015BD48 = v111 + 939524096;
        dword_10015BD4C = v111 + 939524096;
        qword_10015BD98 = 0LL;
        xmmword_10015BD58 = 0u;
        xmmword_10015BD68 = 0u;
        unk_10015BD78 = 0u;
        *(_OWORD *)&qword_10015BD84 = 0u;
        dword_10015BE74 = -1;
        *((_BYTE *)&dword_100158CB0 + &unk_100003618) = 0;
        *((_BYTE *)&dword_100158CB0 + &unk_100003718) = 0;
        *(void *)((char *)&dword_100158CB0 + &loc_100004C8C) = 0LL;
        *(int *)((char *)&dword_100158CB0 + &loc_100004C94) = 0;
        dword_10015C4D8 = 0;
        xmmword_10015C4C8 = 0u;
        xmmword_10015C4F0 = 0u;
        dword_10015C500 = 0;
        dword_10015C504 = v111 + 939524096;
        dword_10015C508 = 0;
        dword_10015C50C = arc4random();
        dword_10015C510 = arc4random();
        dword_10015C514 = arc4random();
        qword_10015C518 = 0LL;
        dword_10015C520 = 0;
        dword_10015C524 = v111;
        *(_WORD *)((char *)&dword_100158CB0 + &unk_100003878) = 0;
        xmmword_10015C618 = 0u;
        *(int *)((char *)&dword_100158CB0 + &unk_10000397A) = 0;
        byte_10015C628 = 0;
        qword_10015C630 = 0LL;
        *((_BYTE *)&dword_100158CB0 + &unk_100003988) = 0;
        off_10015D920 = 0LL;
        *(int *)((char *)&dword_100158CB0 + &loc_100004C80) = 0;
        xmmword_10015C640 = 0u;
        xmmword_10015C650 = 0u;
        qword_10015C660 = 0LL;
        *(_WORD *)((char *)&dword_100158CB4 + &unk_1000039C0) = 0;
        dword_10015C670 = 0;
        xmmword_10015C678 = 0u;
        *(_DWORD *)cStr = 0;
        v118 = calloc(1uLL, 0x18uLL);
        if (!v118) {
          goto LABEL_401;
        }
        v124 = v118;
        v125 = &_dnssec_obj_trust_anchor_manager_kind;
        *((void *)v118 + 1) = &_dnssec_obj_trust_anchor_manager_kind;
        do
        {
          v126 = (void (*)(_DWORD *))v125[2];
          if (v126) {
            v126(v124);
          }
          v125 = (_UNKNOWN **)*v125;
        }

        while (v125);
        ++*v124;
        *(_DWORD *)cStr = 0;
        v116 = (int *)dnssec_obj_trust_anchor_create_with_ds_data( byte_1001005F0,  20326,  8,  (__int128 *)&unk_1001005F2,  1485993600,  -661490049,  (int *)cStr);
        v117 = *(unsigned int *)cStr;
        if (!*(_DWORD *)cStr)
        {
          v127 = dnssec_obj_trust_anchor_manager_add_anchor((uint64_t)v124, (uint64_t)v116);
          *(_DWORD *)cStr = v127;
          if (!(_DWORD)v127)
          {
            if (is_apple_internal_build_is_internal)
            {
              v128 = dnssec_obj_trust_anchor_create_with_ds_data( "\x06dnssec\x04test",  36815,  14,  (__int128 *)&unk_100100612,  1645819915,  -501663734,  (int *)cStr);
              v117 = *(unsigned int *)cStr;
              if (!*(_DWORD *)cStr)
              {
                v117 = dnssec_obj_trust_anchor_manager_add_anchor((uint64_t)v124, (uint64_t)v128);
                *(_DWORD *)cStr = v117;
                if (!v116) {
                  goto LABEL_177;
                }
                goto LABEL_176;
              }
            }

            else
            {
              v128 = 0LL;
              v117 = *(unsigned int *)cStr;
            }

            if (!v116) {
              goto LABEL_177;
            }
            goto LABEL_176;
          }

          v117 = v127;
        }

        v128 = 0LL;
        if (!v116)
        {
LABEL_177:
          if (v128) {
            ref_count_obj_release(v128);
          }
          qword_10015D9A0 = (uint64_t)v124;
          if ((_DWORD)v117)
          {
            v63 = -65537;
            goto LABEL_340;
          }

          v129 = v111 + 1800000;
          dword_100158C60 = v129;
          v130 = calloc(1uLL, 0x130uLL);
          if (v130)
          {
            v131 = (uint64_t)v130;
            for (j = "\x05local"; ; j += v134 + 1)
            {
              if ("\x05local" == (char *)-256LL)
              {
                if (!j) {
                  goto LABEL_197;
                }
              }

              else if (j >= "xyTCPCallback: free" || j == 0LL)
              {
                goto LABEL_197;
              }

              v134 = *(unsigned __int8 *)j;
              if (!*j) {
                break;
              }
            }

            v135 = (_DWORD)j - "\x05local" + 1;
            if ((unsigned __int16)v135 <= 0x100u)
            {
              memcpy(v130, "\x05local", (unsigned __int16)v135);
              goto LABEL_198;
            }

      v49 = *(void *)v49;
      if (!v49) {
        goto LABEL_113;
      }
    }
  }

  v36 = __rev16(a7->u16[2]);
  if (v36 < 8) {
    return;
  }
  v37 = v36 - 8;
  if (v16 == 54028)
  {
    v41 = 0;
    if (a7[1].i8[0] == 19)
    {
      v41 = a7[1].u8[1] == 136;
      goto LABEL_153;
    }

        if ((unint64_t)v11 >= v10 || v48 - (char *)v14 <= 23)
        {
          v13 = *(unsigned __int16 **)(a4 + 40);
LABEL_118:
          *(_WORD *)(a4 + 12) = (_WORD)v14 - (_WORD)v13 - 4;
          if (mDNS_LoggingEnabled != 1) {
            return 0LL;
          }
          v64 = (os_log_s *)mDNSLogCategory_Default;
          v65 = "SetRData: Malformed OptRdata";
LABEL_330:
          LogMsgWithLevel(v64, OS_LOG_TYPE_DEFAULT, v65, a4, __n, a6, a7, a8, v131);
          return 0LL;
        }
      }

    case 0x2F:
      v146 = 0u;
      v147 = 0u;
      v144 = 0u;
      v145 = 0u;
      v142 = 0u;
      v143 = 0u;
      v140 = 0u;
      v141 = 0u;
      v138 = 0u;
      v139 = 0u;
      v136 = 0u;
      v137 = 0u;
      v134 = 0u;
      v135 = 0u;
      *(_OWORD *)buf = 0u;
      v133 = 0u;
      if (a1)
      {
        v66 = getDomainName(a1, __src, a3, buf);
        goto LABEL_233;
      }

      v82 = buf;
      v83 = 257LL;
      while (2)
      {
        v84 = *v82;
        if (v84 <= 0x3F)
        {
          if (*v82)
          {
            v82 += v84 + 1;
            if (v82 >= v148 || v82 == 0LL) {
              break;
            }
            continue;
          }

          v83 = (unsigned __int16)((_WORD)v82 - (unsigned __int16)buf + 1);
        }

        break;
      }

      v66 = &v11[v83];
LABEL_233:
      if (!v66)
      {
        if (mDNS_LoggingEnabled == 1)
        {
          v64 = (os_log_s *)mDNSLogCategory_Default;
          v65 = "SetRData: Malformed NSEC nextname";
          goto LABEL_330;
        }

        return 0LL;
      }

      v103 = buf;
      v104 = 257LL;
      do
      {
        v105 = *v103;
        if (!*v103)
        {
          v104 = (unsigned __int16)((_WORD)v103 - (unsigned __int16)buf + 1);
          break;
        }

        v103 += v105 + 1;
      }

      while (v103 < v148 && v103 != 0LL);
      v107 = (_DWORD)v11 - (_DWORD)v66 + v8;
      v108 = SanityCheckBitMap((unint64_t)v66, v10, v107, a4, __n, a6, a7, a8);
      if (!v108) {
        return 0LL;
      }
      if (v108 == v10)
      {
        v109 = buf;
        while (1)
        {
          v110 = *v109;
          if (v110 > 0x3F)
          {
LABEL_258:
            LOWORD(v112) = 257;
            goto LABEL_279;
          }

          if (!*v109) {
            break;
          }
          v109 += v110 + 1;
          if (v109 >= v148 || v109 == 0LL) {
            goto LABEL_258;
          }
        }

        v112 = (_DWORD)v109 - buf + 1;
LABEL_279:
        v118 = v112 + v107;
        *(_WORD *)(a4 + 12) = v118;
        if (v118 > 0x2000u)
        {
          if (mDNS_LoggingEnabled == 1) {
            LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "SetRData: Malformed NSEC rdlength %d, rr->rdlength %d, bmaplen %d, name %##s",  a4,  __n,  a6,  a7,  a8,  v8);
          }
          return 0LL;
        }

        v119 = buf;
        do
        {
          v120 = *v119;
          if (!*v119)
          {
            v126 = (_DWORD)v119 - buf + 1;
            if ((unsigned __int16)v126 <= 0x100u)
            {
              memcpy(v14, buf, (unsigned __int16)v126);
              goto LABEL_322;
            }

            break;
          }

          v119 += v120 + 1;
        }

        while (v119 < v148 && v119 != 0LL);
        *(_BYTE *)v14 = 0;
LABEL_322:
        v33 = (char *)v14 + v104;
        v32 = v107;
        v34 = v66;
LABEL_45:
        memcpy(v33, v34, v32);
        return 1LL;
      }

      else
      {
        if (mDNS_LoggingEnabled == 1)
        {
          v64 = (os_log_s *)mDNSLogCategory_Default;
          v65 = "SetRData: Malformed NSEC length not right";
          goto LABEL_330;
        }

        return 0LL;
      }

    default:
      if ((v15 - 249) >= 2)
      {
        if (v15 == 65323)
        {
          *(_DWORD *)v14 = bswap32(*(_DWORD *)__src);
          return 1LL;
        }

LABEL_197:
            *v130 = 0;
LABEL_198:
            qword_10015C2C0 = v131;
            byte_100158BC6 = byte_100158BC5 == 0;
            off_10015D920 = (uint64_t (*)(void, void, void, void))UpdateSPSStatus;
            v426 = 0u;
            v427 = 0u;
            v424 = 0u;
            v425 = 0u;
            v422 = 0u;
            v423 = 0u;
            v420 = 0u;
            v421 = 0u;
            v418 = 0u;
            v419 = 0u;
            v416 = 0u;
            v417 = 0u;
            v414 = 0u;
            v415 = 0u;
            *(_OWORD *)error = 0u;
            v413 = 0u;
            mDNSMacOSXSystemBuildNumber(error);
            if ((MEMORY[0xFFFFFC021] & 1) != 0)
            {
              SameDomainLabelPointer = (uint64_t (*)(void, void))vectorSameDomainLabel;
              v141 = "setSameDomainLabelPointer: using vector code";
            }

            else
            {
              v141 = "setSameDomainLabelPointer: using scalar code";
            }

            LogMsgWithLevel(v46[170], OS_LOG_TYPE_DEFAULT, v141, v136, v137, v138, v139, v140, v400);
            HelperQueue = (uint64_t)dispatch_queue_create("com.apple.mDNSResponder.HelperQueue", 0LL);
            if (!HelperQueue)
            {
              v63 = -65539;
              v151 = v46[170];
              v152 = "dispatch_queue_create: Helper queue NULL";
              goto LABEL_251;
            }

            if (iOSVers) {
              v147 = 3;
            }
            else {
              v147 = 4;
            }
            if (OSXVers) {
              v148 = 1;
            }
            else {
              v148 = v147;
            }
            byte_10015BD44 = v148;
            v149 = 100;
            do
            {
              memset(cStr, 0, 64);
              GetUserSpecifiedLocalHostName(cStr);
              if (cStr[0]) {
                break;
              }
              usleep(0xC350u);
              --v149;
            }

            while (v149);
            LOBYTE(xmmword_10015B428) = 0;
            GetRandomUUIDLocalHostname(byte_10015B568);
            *(void *)v411 = 0x200000006LL;
            v409 = 32LL;
            v150 = HINFO_HWstring_buffer;
            if (sysctl(v411, 2u, HINFO_HWstring_buffer, &v409, 0LL, 0LL)) {
              v150 = HINFO_HWstring;
            }
            else {
              HINFO_HWstring = HINFO_HWstring_buffer;
            }
            if (strchr(HINFO_HWstring_buffer, 44)) {
              v153 = strcspn(v150, "0123456789");
            }
            else {
              v153 = strlen(v150);
            }
            HINFO_HWstring_prefixlen = v153;
            v154 = socket(2, 2, 17);
            v155 = v154;
            if (v154 > 2)
            {
              *(void *)cStr = 3910402560LL;
              *(void *)&cStr[8] = 0LL;
              v168 = bind(v154, (const sockaddr *)cStr, 0x10u);
              close(v155);
              if (!v168)
              {
                byte_100158BC4[0] = 1;
                goto LABEL_222;
              }
            }

            else
            {
              v156 = v46[170];
              __error();
              v157 = __error();
              strerror(*v157);
              LogMsgWithLevel( v156,  OS_LOG_TYPE_DEFAULT,  "mDNSPlatformInit_CanReceiveUnicast: socket error %d errno %d (%s)",  v158,  v159,  v160,  v161,  v162,  v155);
            }

            LogMsgWithLevel( v46[170],  OS_LOG_TYPE_DEFAULT,  "No unicast UDP responses",  v163,  v164,  v165,  v166,  v167,  v401);
LABEL_222:
            v169 = strlen(HINFO_HWstring);
            v170 = strlen((const char *)error);
            v171 = v170;
            if (v170 + v169 <= 0xFD)
            {
              byte_10015B670 = v169;
              byte_10015B770 = v170;
              memcpy(&unk_10015B671, HINFO_HWstring, v169);
              memcpy(&unk_10015B771, error, v171);
            }

            v172 = mDNSStorage[0];
            *(_WORD *)(mDNSStorage[0] + 8) = -5868;
            v172 += 8LL;
            *(void *)(v172 + 8) = mDNSStorage;
            *(_DWORD *)(v172 + 16) = -1;
            *(void *)(v172 + 24) = myKQSocketCallBack;
            *(void *)(v172 + 32) = v172;
            *(void *)(v172 + 40) = "IPv4 UDP packet reception";
            *(_DWORD *)(v172 + 48) = -1;
            *(void *)(v172 + 56) = myKQSocketCallBack;
            *(void *)(v172 + 64) = v172;
            *(void *)(v172 + 72) = "IPv6 UDP packet reception";
            v173 = SetupSocket((void *)v172, 0xE914u, 2, 0LL);
            if (v173)
            {
              v174 = v173;
              v175 = v46[170];
              __error();
              v176 = __error();
              strerror(*v176);
              LogMsgWithLevel( v175,  OS_LOG_TYPE_DEFAULT,  "mDNSPlatformInit_setup: SetupSocket(AF_INET) failed error %d errno %d (%s)",  v177,  v178,  v179,  v180,  v181,  v174);
            }

            v182 = SetupSocket((void *)(mDNSStorage[0] + 8), 0xE914u, 30, 0LL);
            if (v182)
            {
              v183 = v182;
              v184 = v46[170];
              __error();
              v185 = __error();
              strerror(*v185);
              LogMsgWithLevel( v184,  OS_LOG_TYPE_DEFAULT,  "mDNSPlatformInit_setup: SetupSocket(AF_INET6) failed error %d errno %d (%s)",  v186,  v187,  v188,  v189,  v190,  v183);
            }

            *(void *)&v438.sa_len = 0LL;
            *(void *)&v438.sa_data[6] = 0LL;
            v408 = 16;
            if (getsockname(*(_DWORD *)(mDNSStorage[0] + 24), &v438, &v408) < 0)
            {
              v191 = v46[170];
              v192 = *__error();
              v193 = __error();
              strerror(*v193);
              LogMsgWithLevel( v191,  OS_LOG_TYPE_DEFAULT,  "getsockname v4 error %d (%s)",  v194,  v195,  v196,  v197,  v198,  v192);
            }

            else
            {
              word_100158BCC = *(_WORD *)v438.sa_data;
            }

            v199 = mDNSStorage[0];
            v200 = *(_DWORD *)(mDNSStorage[0] + 56);
            if ((v200 & 0x80000000) == 0)
            {
              memset(cStr, 0, 28);
              v407 = 28;
              if (getsockname(v200, (sockaddr *)cStr, &v407) < 0)
              {
                v201 = v46[170];
                v202 = *__error();
                v203 = __error();
                strerror(*v203);
                LogMsgWithLevel( v201,  OS_LOG_TYPE_DEFAULT,  "getsockname v6 error %d (%s)",  v204,  v205,  v206,  v207,  v208,  v202);
              }

              else
              {
                word_100158BCE = *(_WORD *)&cStr[2];
              }

              v199 = mDNSStorage[0];
            }

            *(void *)v199 = 0LL;
            *(_BYTE *)(v199 + 108) = 0;
            *(_BYTE *)(v199 + 172) = 0;
            *(_BYTE *)(v199 + 364) = 0;
            *(_BYTE *)(v199 + 428) = 0;
            *(_BYTE *)(v199 + 236) = 0;
            *(_BYTE *)(v199 + 300) = 0;
            *(_DWORD *)(v199 + 492) = 0;
            *(_DWORD *)(v199 + 500) = 0;
            *(void *)(v199 + 600) = 0LL;
            *(_DWORD *)(v199 + 608) = 0;
            *(_WORD *)(v199 + 688) = 257;
            *(_DWORD *)(v199 + 692) = 0;
            *(void *)(v199 + 696) = 0LL;
            NetworkChangedKey_IPv4 = (uint64_t)SCDynamicStoreKeyCreateNetworkGlobalEntity( 0LL,  kSCDynamicStoreDomainState,  kSCEntNetIPv4);
            NetworkChangedKey_IPv6 = (uint64_t)SCDynamicStoreKeyCreateNetworkGlobalEntity( 0LL,  kSCDynamicStoreDomainState,  kSCEntNetIPv6);
            NetworkChangedKey_Hostnames = (uint64_t)SCDynamicStoreKeyCreateHostNames(0LL);
            NetworkChangedKey_Computername = (uint64_t)SCDynamicStoreKeyCreateComputerName(0LL);
            NetworkChangedKey_DNS = (uint64_t)SCDynamicStoreKeyCreateNetworkGlobalEntity( 0LL,  kSCDynamicStoreDomainState,  kSCEntNetDNS);
            NetworkInterfaceEntity = SCDynamicStoreKeyCreateNetworkInterfaceEntity( 0LL,  kSCDynamicStoreDomainState,  &stru_10013F428,  0LL);
            NetworkChangedKey_StateInterfacePrefix = (uint64_t)NetworkInterfaceEntity;
            if (NetworkChangedKey_IPv4
              && NetworkChangedKey_IPv6
              && NetworkChangedKey_Hostnames
              && NetworkChangedKey_Computername
              && NetworkChangedKey_DNS
              && NetworkInterfaceEntity)
            {
              *(void *)cStr = 0LL;
              memset(&cStr[16], 0, 24);
              *(void *)&cStr[8] = mDNSStorage;
              v210 = SCDynamicStoreCreate( 0LL,  @"mDNSResponder:WatchForNetworkChanges",  (SCDynamicStoreCallBack)NetworkChanged,  (SCDynamicStoreContext *)cStr);
              Mutable = CFArrayCreateMutable(0LL, 0LL, &kCFTypeArrayCallBacks);
              v212 = SCDynamicStoreKeyCreateNetworkInterfaceEntity( 0LL,  kSCDynamicStoreDomainState,  kSCCompAnyRegex,  kSCEntNetIPv4);
              v213 = SCDynamicStoreKeyCreateNetworkInterfaceEntity( 0LL,  kSCDynamicStoreDomainState,  kSCCompAnyRegex,  kSCEntNetIPv6);
              v214 = CFArrayCreateMutable(0LL, 0LL, &kCFTypeArrayCallBacks);
              v215 = v214;
              v46 = (os_log_s **)&unk_100164000;
              if (v210)
              {
                if (Mutable && v212 && v213 && v214)
                {
                  CFArrayAppendValue(Mutable, (const void *)NetworkChangedKey_IPv4);
                  CFArrayAppendValue(Mutable, (const void *)NetworkChangedKey_IPv6);
                  CFArrayAppendValue(Mutable, (const void *)NetworkChangedKey_Hostnames);
                  CFArrayAppendValue(Mutable, (const void *)NetworkChangedKey_Computername);
                  CFArrayAppendValue(Mutable, (const void *)NetworkChangedKey_DNS);
                  CFArrayAppendValue(Mutable, @"Setup:/Network/DynamicDNS");
                  CFArrayAppendValue(Mutable, @"State:/IOKit/PowerManagement/CurrentSettings");
                  CFArrayAppendValue(v215, v212);
                  CFArrayAppendValue(v215, v213);
                  CFArrayAppendValue(v215, @"State:/Network/Interface/[^/]+/AirPort");
                  if (SCDynamicStoreSetNotificationKeys(v210, Mutable, v215))
                  {
                    RunLoopSource = SCDynamicStoreCreateRunLoopSource(0LL, v210, 0LL);
                    *(void *)(mDNSStorage[0] + 512) = RunLoopSource;
                    if (RunLoopSource)
                    {
                      Main = CFRunLoopGetMain();
                      CFRunLoopAddSource(Main, *(CFRunLoopSourceRef *)(mDNSStorage[0] + 512), kCFRunLoopDefaultMode);
                      SCDynamicStoreSetDisconnectCallBack(v210, DynamicStoreReconnected);
                      v218 = 0;
                      *(void *)(mDNSStorage[0] + 504) = v210;
LABEL_274:
                      CFRelease(v215);
LABEL_275:
                      if (v213) {
                        CFRelease(v213);
                      }
                      v117 = (uint64_t)&unk_100158000;
                      if (v212) {
                        CFRelease(v212);
                      }
                      if (Mutable) {
                        CFRelease(Mutable);
                      }
                      if (v218)
                      {
                        v63 = -1;
                        LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "mDNSPlatformInit_setup: WatchForNetworkChanges failed %d",  v227,  v228,  v229,  v230,  v231,  -1);
                        goto LABEL_335;
                      }

                      v246 = socket(32, 3, 1);
                      v247 = v246;
                      *(_DWORD *)(mDNSStorage[0] + 528) = v246;
                      if (v246 < 0)
                      {
                        v290 = -65539;
                        v291 = (os_log_s *)mDNSLogCategory_Default;
                        __error();
                        v292 = __error();
                        strerror(*v292);
                        LogMsgWithLevel( v291,  OS_LOG_TYPE_DEFAULT,  "WatchForSysEvents: socket failed error %d errno %d (%s)",  v293,  v294,  v295,  v296,  v297,  v247);
                      }

                      else
                      {
                        *(_DWORD *)&cStr[8] = 2;
                        *(void *)cStr = 0x100000001LL;
                        v248 = ioctl(v246, 0x800C6502uLL);
                        if ((v248 & 0x80000000) == 0)
                        {
                          v249 = mDNSStorage[0];
                          v250 = (void *)(mDNSStorage[0] + 536);
                          *(void *)(mDNSStorage[0] + 536) = SysEventCallBack;
                          *(void *)(v249 + 544) = mDNSStorage;
                          *(void *)(v249 + 552) = "System Event Notifier";
                          KQueueSet(*(_DWORD *)(v249 + 528), 1u, -1, v250);
                          v251 = time(0LL);
                          v252 = v251;
                          byte_100158C47[0] = SystemWakeForNetworkAccess(v251, v253, v254, v255, v256, v257, v258, v259);
                          myGetIfAddrs();
                          UpdateInterfaceList(v252);
                          SetupActiveInterfaces(v252);
                          mDNS_Lock_((unsigned int *)mDNSStorage, (uint64_t)"mDNSPlatformInit_setup", 8182);
                          LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "Note: SetDomainSecrets: no keychain support",  v260,  v261,  v262,  v263,  v264,  (int)cStr);
                          SetLocalDomains(v265, v266, v267, v268, v269, v270, v271, v272, v403);
                          mDNS_Unlock_((uint64_t)mDNSStorage, (uint64_t)"mDNSPlatformInit_setup", 8185);
                          LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "Note: Compiled without SnowLeopard Fine-Grained Power Management support",  v273,  v274,  v275,  v276,  v277,  v404);
                          v278 = IORegisterForSystemPower( mDNSStorage,  (IONotificationPortRef *)(mDNSStorage[0] + 560),  (IOServiceInterestCallback)PowerChanged,  (io_object_t *)(mDNSStorage[0] + 572));
                          *(_DWORD *)(mDNSStorage[0] + 568) = v278;
                          if (!v278)
                          {
                            LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "mDNSPlatformInit_setup: IORegisterForSystemPower failed",  v279,  v280,  v281,  v282,  v283,  v400);
                            v63 = -1;
                            goto LABEL_335;
                          }

                          v284 = CFRunLoopGetMain();
                          v285 = IONotificationPortGetRunLoopSource(*(IONotificationPortRef *)(mDNSStorage[0] + 560));
                          CFRunLoopAddSource(v284, v285, kCFRunLoopDefaultMode);
                          v286 = HINFO_HWstring;
                          if (strncasecmp(HINFO_HWstring, "Xserve", 6uLL))
                          {
                            v116 = (int *)&unk_100158000;
                            if (!strncasecmp(v286, "RackMac", 7uLL))
                            {
                              v314 = (_BYTE *)&unk_10014C000;
                              v315 = 25;
                            }

                            else
                            {
                              if (strncasecmp(v286, "MacPro", 6uLL))
                              {
                                if (strncasecmp(v286, "PowerMac", 8uLL))
                                {
                                  if (strncasecmp(v286, "iMac", 4uLL))
                                  {
                                    if (!strncasecmp(v286, "Macmini", 7uLL))
                                    {
                                      SPMetricPortability = 33;
                                      v288 = 73;
                                      v289 = 74;
                                    }

                                    else if (!strncasecmp(v286, "TimeCapsule", 0xBuLL))
                                    {
                                      SPMetricPortability = 34;
                                      v288 = 10;
                                      v289 = 70;
                                    }

                                    else
                                    {
                                      v287 = strncasecmp(v286, "AirPort", 7uLL);
                                      SPMetricPortability = 35;
                                      if (v287) {
                                        v288 = 60;
                                      }
                                      else {
                                        v288 = 10;
                                      }
                                      if (v287) {
                                        v289 = 63;
                                      }
                                      else {
                                        v289 = 70;
                                      }
                                    }

                                    goto LABEL_323;
                                  }

                                  goto LABEL_402;
                                }

                                SPMetricPortability = 27;
                                v288 = 82;
                                v289 = 83;
LABEL_323:
                                SPMetricMarginalPower = v288;
                                SPMetricTotalPower = v289;
                                if (*((_BYTE *)v116 + 2840) == 1) {
                                  LogMsgWithLevel( v46[170],  OS_LOG_TYPE_DEFAULT,  "HW_MODEL: %.*s (%s) Portability %d Marginal Power %d Total Power %d Features %d",  v119,  v120,  v121,  v122,  v123,  HINFO_HWstring_prefixlen);
                                }
                                SSLqueue = (uint64_t)dispatch_get_global_queue(0LL, 0LL);
                                if (!SSLqueue) {
                                  LogMsgWithLevel( v46[170],  OS_LOG_TYPE_DEFAULT,  "dispatch_queue_create: SSL queue NULL",  v316,  v317,  v318,  v319,  v320,  v400);
                                }
                                if (*(_BYTE *)(v117 + 2432))
                                {
                                  mDNSMacOSXUpdateEtcHosts_internal();
                                }

                                else
                                {
                                  v407 = 16777343;
                                  RegisterLocalOnlyAddressRecord("\tlocalhost", 1, &v407, 4u);
                                  RegisterLocalOnlyAddressRecord("\rbroadcasthost", 1, &onesIPv4Addr, 4u);
                                  *(void *)cStr = 0LL;
                                  *(void *)&cStr[8] = 0x100000000000000LL;
                                  RegisterLocalOnlyAddressRecord("\tlocalhost", 28, cStr, 0x10u);
                                }

                                v436 = 0u;
                                v437 = 0u;
                                v434 = 0u;
                                v435 = 0u;
                                v432 = 0u;
                                v433 = 0u;
                                v430 = 0u;
                                v431 = 0u;
                                v429 = 0u;
                                memset(cStr, 0, sizeof(cStr));
                                AppendDNSNameString(cStr, "1.0.0.127.in-addr.arpa.", v321, v322, v323, v324, v325, v326);
                                CreatePTRRecord(cStr);
                                cStr[0] = 0;
                                AppendDNSNameString( cStr,  "1.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.ip6.arpa.",  v327,  v328,  v329,  v330,  v331,  v332);
                                CreatePTRRecord(cStr);
                                if (dnssd_analytics_init_sInitAnalyticsOnce != -1) {
                                  dispatch_once(&dnssd_analytics_init_sInitAnalyticsOnce, &__block_literal_global_7061);
                                }
                                mDNSCoreInitComplete();
                                initializeD2DPlugins();
                                v63 = 0;
LABEL_335:
                                uDNS_SetupDNSConfig();
                                if (DPCFeatureEnabled_sOnce != -1) {
                                  dispatch_once(&DPCFeatureEnabled_sOnce, &__block_literal_global_3237);
                                }
                                if (DPCFeatureEnabled_sEnabled)
                                {
                                  bzero(&DPCBrowse, 0x290uLL);
                                  mDNS_StartBrowse_internal( (uint64_t)&DPCBrowse,  "\x06_local\t_dnssd-dp\x04_tcp",  "\x05local",  0LL,  0,  0,  0,  (uint64_t)DPCBrowseHandler,  0LL);
                                  dword_10014E034 = -1;
                                }

                                if (v63) {
                                  goto LABEL_340;
                                }
                                if (_os_feature_enabled_impl("mDNSResponder", "preallocated_cache"))
                                {
                                  v346 = 31;
                                  do
                                  {
                                    mDNS_StatusCallback( (__int128 *)mDNSStorage,  -65790,  v340,  v341,  v342,  v343,  v344,  v345);
                                    --v346;
                                  }

                                  while (v346);
                                }

                                v347 = CFMachPortCreate(0LL, (CFMachPortCallBack)SignalCallback, 0LL, 0LL);
                                v348 = CFMachPortCreateRunLoopSource(0LL, v347, 0LL);
                                signal_port = CFMachPortGetPort(v347);
                                v349 = CFRunLoopGetMain();
                                CFRunLoopAddSource(v349, v348, kCFRunLoopDefaultMode);
                                if (v348) {
                                  CFRelease(v348);
                                }
                                mach_service = xpc_connection_create_mach_service( "com.apple.mDNSResponder.log_utility",  0LL,  1uLL);
                                if (mach_service
                                  && (v351 = mach_service,
                                      xpc_get_type(mach_service) == (xpc_type_t)&_xpc_type_connection))
                                {
                                  log_utility_server_queue = (uint64_t)dispatch_queue_create( "com.apple.mDNSResponder.log_utility_server_queue",  0LL);
                                  xpc_connection_set_event_handler(v351, &__block_literal_global_7142);
                                  xpc_connection_resume(v351);
                                }

                                else
                                {
                                  v352 = (os_log_s *)mDNSLogCategory_XPC;
                                  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_XPC == mDNSLogCategory_State)
                                  {
                                    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_XPC, OS_LOG_TYPE_ERROR)) {
                                      goto LABEL_367;
                                    }
                                    *(_WORD *)cStr = 0;
                                  }

                                  else
                                  {
                                    v352 = (os_log_s *)mDNSLogCategory_XPC_redacted;
                                    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_XPC_redacted, OS_LOG_TYPE_ERROR)) {
                                      goto LABEL_367;
                                    }
                                    *(_WORD *)cStr = 0;
                                  }

                                  _os_log_impl( (void *)&_mh_execute_header,  v352,  OS_LOG_TYPE_ERROR,  "Error Creating XPC Listener for Log Utility Server!",  cStr,  2u);
                                }

        if (!(_DWORD)v23) {
          goto LABEL_199;
        }
      }

LABEL_367:
                                v353 = launch_activate_socket( "Listeners",  (int **)&launchd_fds,  (size_t *)&launchd_fds_count);
                                if (v353)
                                {
                                  v354 = v353;
                                  v355 = v46[170];
                                  strerror(v353);
                                  LogMsgWithLevel( v355,  OS_LOG_TYPE_DEFAULT,  "launch_activate_socket() failed error %d (%s)",  v356,  v357,  v358,  v359,  v360,  v354);
                                }

                                v361 = (int *)launchd_fds;
                                v362 = launchd_fds_count;
                                memset(cStr, 0, 106);
                                if (launchd_fds)
                                {
                                  if (launchd_fds_count)
                                  {
                                    do
                                    {
                                      v364 = *v361++;
                                      v363 = v364;
                                    }

                                    while (--v362);
                                  }

LABEL_381:
                                  error[0] = 0LL;
                                  error[1] = 0LL;
                                  if (getrlimit(8, (rlimit *)error) < 0) {
                                    goto LABEL_393;
                                  }
                                  if (setrlimit(8, (const rlimit *)error) < 0) {
                                    my_perror((int)"ERROR: Unable to set maximum file descriptor limit");
                                  }
                                  if (getrlimit(8, (rlimit *)error) < 0) {
                                    goto LABEL_393;
                                  }
                                  v368 = (int8x16_t)vdupq_n_s64(0x2800uLL);
                                  v438 = (sockaddr)vbslq_s8( (int8x16_t)vcgtq_u64(*(uint64x2_t *)error, (uint64x2_t)v368),  *(int8x16_t *)error,  v368);
                                  v369 = (unint64_t)error[1] >> 11 >= 5 && (unint64_t)error[0] >> 11 > 4;
                                  if (!v369 && setrlimit(8, (const rlimit *)&v438) < 0) {
                                    my_perror((int)"ERROR: Unable to set maximum file descriptor limit");
                                  }
                                  if (getrlimit(8, (rlimit *)error) < 0)
                                  {
LABEL_393:
                                    my_perror((int)"ERROR: Unable to get file descriptor limit");
                                  }

                                  else
                                  {
                                    mDNS_GetDomains( (uint64_t)mDNSStorage + &unk_100003478,  2,  0LL,  -2LL,  (uint64_t)AutomaticBrowseDomainChange,  0LL);
                                    RegisterLocalOnlyDomainEnumPTR((unsigned int *)mDNSStorage, "\x05local", 3);
                                    RegisterLocalOnlyDomainEnumPTR((unsigned int *)mDNSStorage, "\x05local", 0);
                                    AddAutoBrowseDomain(0, "\x05local");
                                    udsserver_handle_configchange((uint64_t)mDNSStorage);
                                  }

                                  mDNSMacOSXNetworkChanged(v370, v371, v372, v373, v374, v375, v376, v377);
                                  UpdateDebugState(v378, v379, v380, v381, v382, v383, v384, v385, v400);
                                  v406 = 0LL;
                                  v386 = pthread_create(&v406, 0LL, (void *(__cdecl *)(void *))KQueueLoop, mDNSStorage);
                                  v63 = v386;
                                  if (v386)
                                  {
                                    v387 = v46[170];
                                    strerror(v386);
                                    LogMsgWithLevel( v387,  OS_LOG_TYPE_DEFAULT,  "pthread_create() failed error %d (%s)",  v388,  v389,  v390,  v391,  v392,  v63);
                                  }

LABEL_341:
                                  pthread_mutex_unlock(&stru_100150758);
                                  if (v63) {
                                    goto LABEL_350;
                                  }
                                  goto LABEL_342;
                                }

                                listenfd = socket(1, 1, 0);
                                if (listenfd < 0)
                                {
                                  v393 = "ERROR: socket(AF_DNSSD, SOCK_STREAM, 0); failed";
                                }

                                else
                                {
                                  memset(&cStr[2], 0, 104);
                                  v365 = umask(0);
                                  unlink("/var/run/mDNSResponder");
                                  v366 = 0LL;
                                  *(_WORD *)cStr = 362;
                                  while (1)
                                  {
                                    cStr[v366 + 2] = aVarRunMdnsresp[v366];
                                    if (v366 == 22) {
                                      break;
                                    }
                                    ++v366;
                                  }

                                  v367 = bind(listenfd, (const sockaddr *)cStr, 0x6Au);
                                  umask(v365);
                                  if ((v367 & 0x80000000) == 0)
                                  {
LABEL_399:
                                    my_perror((int)"ERROR: udsserver_init");
                                    LogMsgWithLevel( v46[170],  OS_LOG_TYPE_DEFAULT,  "Daemon start: udsserver_init failed",  v394,  v395,  v396,  v397,  v398,  v400);
                                    v63 = -1;
                                    goto LABEL_341;
                                  }

                                  v393 = "ERROR: bind(listenfd, (struct sockaddr *) &laddr, sizeof(laddr)); failed";
                                }

                                my_perror((int)v393);
                                goto LABEL_399;
                              }

                              v314 = &unk_10014C000;
                              v315 = 27;
                            }

                            v314[1297] = v315;
                            v288 = 84;
                            v289 = 85;
                            goto LABEL_323;
                          }

                          SPMetricPortability = 25;
                          v288 = 84;
                          v289 = 85;
                          v116 = (_DWORD *)&unk_100158000;
                          goto LABEL_323;
                        }

                        v303 = v248;
                        v304 = (os_log_s *)mDNSLogCategory_Default;
                        __error();
                        v305 = __error();
                        strerror(*v305);
                        LogMsgWithLevel( v304,  OS_LOG_TYPE_DEFAULT,  "WatchForSysEvents: SIOCSKEVFILT failed error %d errno %d (%s)",  v306,  v307,  v308,  v309,  v310,  v303);
                        close(*(_DWORD *)(mDNSStorage[0] + 528));
                        *(_DWORD *)(mDNSStorage[0] + 528) = -1;
                        v290 = -65537;
                      }

                      LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "mDNSPlatformInit_setup: WatchForSysEvents failed %d",  v298,  v299,  v300,  v301,  v302,  v290);
                      v63 = v290;
                      goto LABEL_335;
                    }

                    v232 = v210;
                    v233 = "SCDynamicStoreCreateRunLoopSource failed: %s";
                  }

                  else
                  {
                    v232 = v210;
                    v233 = "SCDynamicStoreSetNotificationKeys failed: %s";
                  }

                  v238 = mDNSLogCategory_Default;
                  v239 = SCError();
                  v402 = SCErrorString(v239);
                  v240 = (os_log_s *)v238;
                  v46 = (os_log_s **)&unk_100164000;
                  LogMsgWithLevel(v240, OS_LOG_TYPE_DEFAULT, v233, v241, v242, v243, v244, v245, v402);
                  v210 = v232;
                }

                CFRelease(v210);
              }

              else
              {
                v219 = (os_log_s *)mDNSLogCategory_Default;
                v220 = SCError();
                v221 = SCErrorString(v220);
                LogMsgWithLevel( v219,  OS_LOG_TYPE_DEFAULT,  "SCDynamicStoreCreate failed: %s",  v222,  v223,  v224,  v225,  v226,  v221);
              }

              v218 = -1;
              if (!v215) {
                goto LABEL_275;
              }
              goto LABEL_274;
            }

            v63 = -65539;
            v151 = v46[170];
            v152 = "SCDynamicStore string setup failed";
LABEL_251:
            LogMsgWithLevel(v151, OS_LOG_TYPE_DEFAULT, v152, v142, v143, v144, v145, v146, v401);
            goto LABEL_335;
          }

                v213 = v208;
              }

              else
              {
                v213 = 0;
              }

              goto LABEL_344;
            }
          }

          mDNS_Deregister_internal(a1, v81, 4);
          goto LABEL_198;
        }

LABEL_401:
          __break(1u);
LABEL_402:
          SPMetricPortability = 30;
          v288 = 77;
          v289 = 78;
          goto LABEL_323;
        }

LABEL_176:
        ref_count_obj_release(v116);
        goto LABEL_177;
    }

    v91 = v82;
    v92 = (uint64_t)v46[170];
    if (gSensitiveLoggingEnabled != 1 || v92 == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled(v46[170], OS_LOG_TYPE_FAULT)) {
        goto LABEL_153;
      }
      *(_DWORD *)cStr = 134217984;
      *(void *)&cStr[4] = v91;
      v84 = "Couldn't determine if mDNSResponder is sandboxed because of sandbox_check() error: %{mdns:err}ld";
    }

    else
    {
      v92 = mDNSLogCategory_Default_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_FAULT)) {
        goto LABEL_153;
      }
      *(_DWORD *)cStr = 134217984;
      *(void *)&cStr[4] = v91;
      v84 = "Couldn't determine if mDNSResponder is sandboxed because of sandbox_check() error: %{mdns:err}ld";
    }

    v94 = (os_log_s *)v92;
    v95 = OS_LOG_TYPE_FAULT;
    v96 = 12;
    goto LABEL_152;
  }

  LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "mDNSResponder cannot be run as root !! Exiting..",  v21,  v22,  v23,  v24,  v25,  v399);
  return -1;
}

      v67 = buf;
      v68 = (os_log_s *)v40;
      v69 = OS_LOG_TYPE_DEFAULT;
      v70 = 12;
      goto LABEL_152;
    case 5:
      if (a2) {
        goto LABEL_153;
      }
      if ((_DWORD)a4 == 2)
      {
        v46 = &AWDLInterfaceID;
      }

      else
      {
        if ((_DWORD)a4 != 3) {
          goto LABEL_153;
        }
        v46 = &WiFiAwareInterfaceID;
      }

      if (a8 != 16) {
        goto LABEL_153;
      }
      v51 = *v46;
      *(_DWORD *)v125 = 6;
      *(_OWORD *)&v125[4] = *a7;
      mDNS_Lock_((unsigned int *)mDNSStorage, (uint64_t)"removeCachedPeerRecords", 695);
      v52 = 0LL;
      while (1)
      {
        v124 = v52;
        v53 = (void *)mDNSStorage[v52 + 35];
        if (v53) {
          break;
        }
LABEL_137:
        v52 = v124 + 1;
        if (v124 == 498)
        {
          mDNS_Unlock_((uint64_t)mDNSStorage, (uint64_t)"removeCachedPeerRecords", 710);
          goto LABEL_153;
        }
      }

      while (1)
      {
        v54 = v53[2];
        if (v54) {
          break;
        }
LABEL_136:
        v53 = (void *)*v53;
        if (!v53) {
          goto LABEL_137;
        }
      }

      break;
    default:
      goto LABEL_153;
  }

  while (1)
  {
    v55 = (os_log_s *)mDNSLogCategory_D2D;
    if (gSensitiveLoggingEnabled == 1 && mDNSLogCategory_D2D != mDNSLogCategory_State) {
      break;
    }
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_D2D, OS_LOG_TYPE_INFO))
    {
      v57 = *(void *)(v54 + 40);
      if (v57)
      {
        v58 = *(_BYTE **)(v54 + 40);
        if (v57 == -256) {
          goto LABEL_109;
        }
LABEL_106:
        v59 = 257;
        if ((unint64_t)v58 < v57 + 256 && v58)
        {
          while (1)
          {
            v60 = *v58;
            if (v60 > 0x3F)
            {
LABEL_127:
              v59 = 257;
              goto LABEL_130;
            }

            if (!*v58) {
              break;
            }
            v58 += v60 + 1;
            if (v57 != -256) {
              goto LABEL_106;
            }
LABEL_109:
            if (!v58) {
              goto LABEL_127;
            }
          }

          v59 = (_WORD)v58 - v57 + 1;
        }

          if (!*(_BYTE *)(a1 + 631))
          {
            uuid_clear((unsigned __int8 *)(a1 + 340));
            *(void *)buf = 0LL;
            *(void *)&v94 = buf;
            *((void *)&v94 + 1) = 0x2000000000LL;
            *(void *)v95 = 0LL;
            v91[0] = 0LL;
            v91[1] = v91;
            v91[2] = 0x2000000000LL;
            v92 = 0;
            v89[0] = 0LL;
            v89[1] = v89;
            v89[2] = 0x2000000000LL;
            v90 = 0;
            v88[0] = _NSConcreteStackBlock;
            v88[1] = 0x40000000LL;
            v88[2] = __mDNSPlatformGetDNSRoutePolicy_block_invoke;
            v88[3] = &unk_10013EA40;
            v88[4] = v89;
            v88[5] = buf;
            v88[6] = v91;
            v88[7] = a1;
            nw_path_enumerate_resolver_configs(v36, v88);
            v87 = *(void *)(v94 + 24);
            if (v87) {
              nw_resolver_config_get_identifier(v87, a1 + 340);
            }
            _Block_object_dispose(v89, 8);
            _Block_object_dispose(v91, 8);
            _Block_object_dispose(buf, 8);
          }

          v51 = 0;
          goto LABEL_182;
        }

        v47 = (os_log_s *)mDNSLogCategory_Default;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
        {
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_ERROR))
          {
            v48 = bswap32(*(unsigned __int16 *)(a1 + 320)) >> 16;
            v54 = (_BYTE *)(a1 + 356);
            if (a1 == -612)
            {
LABEL_125:
              while (v54)
              {
                v55 = *v54;
                if (!*v54)
                {
                  v73 = (unsigned __int16)((_WORD)v54 - v2 + 1);
                  goto LABEL_168;
                }

                v54 += v55 + 1;
                if (a1 != -612) {
                  goto LABEL_124;
                }
              }
            }

            else
            {
LABEL_124:
            }

            v73 = 257;
            goto LABEL_168;
          }
        }

        else
        {
          v47 = (os_log_s *)mDNSLogCategory_Default_redacted;
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_ERROR))
          {
            v48 = bswap32(*(unsigned __int16 *)(a1 + 320)) >> 16;
            v49 = (_BYTE *)(a1 + 356);
            if (a1 == -612)
            {
LABEL_105:
              while (v49)
              {
                v50 = *v49;
                if (!*v49)
                {
                  v73 = (unsigned __int16)((_WORD)v49 - v2 + 1);
                  goto LABEL_168;
                }

                v49 += v50 + 1;
                if (a1 != -612) {
                  goto LABEL_104;
                }
              }
            }

            else
            {
LABEL_104:
            }

            v73 = 257;
LABEL_168:
            v79 = DNSTypeName(*(unsigned __int16 *)(a1 + 322));
            v80 = *(_DWORD *)(a1 + 244);
            v81 = *(_DWORD *)(a1 + 248);
            v82 = *(_DWORD *)(a1 + 280);
            *(_DWORD *)buf = 67110915;
            *(_DWORD *)&buf[4] = v48;
            LOWORD(v94) = 2160;
            *(void *)((char *)&v94 + 2) = 1752392040LL;
            WORD5(v94) = 1040;
            HIDWORD(v94) = v73;
            *(_WORD *)v95 = 2101;
            *(void *)&v95[2] = a1 + 356;
            v96 = 2082;
            v97 = v79;
            v98 = 1024;
            v99 = v80;
            v100 = 1024;
            v101 = v81;
            v102 = 1024;
            v103 = v82;
            _os_log_impl( (void *)&_mh_execute_header,  v47,  OS_LOG_TYPE_ERROR,  "[Q%u] mDNSPlatformGetDNSRoutePolicy: Query for %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%{pu blic}s), PID[%d], EUID[%d], ServiceID[%d] path is NULL",  buf,  0x3Eu);
          }
        }

        v51 = 0;
LABEL_183:
        nw_release(v34);
        goto LABEL_163;
      }

      v43 = (os_log_s *)mDNSLogCategory_Default;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
      {
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_ERROR))
        {
          v44 = bswap32(*(unsigned __int16 *)(a1 + 320)) >> 16;
          v52 = (_BYTE *)(a1 + 356);
          if (a1 == -612)
          {
LABEL_117:
            while (v52)
            {
              v53 = *v52;
              if (!*v52)
              {
                v65 = (unsigned __int16)((_WORD)v52 - v2 + 1);
                goto LABEL_159;
              }

              v52 += v53 + 1;
              if (a1 != -612) {
                goto LABEL_116;
              }
            }
          }

          else
          {
LABEL_116:
          }

          v65 = 257;
          goto LABEL_159;
        }
      }

      else
      {
        v43 = (os_log_s *)mDNSLogCategory_Default_redacted;
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_ERROR))
        {
          v44 = bswap32(*(unsigned __int16 *)(a1 + 320)) >> 16;
          v45 = (_BYTE *)(a1 + 356);
          if (a1 == -612)
          {
LABEL_95:
            while (v45)
            {
              v46 = *v45;
              if (!*v45)
              {
                v65 = (unsigned __int16)((_WORD)v45 - v2 + 1);
                goto LABEL_159;
              }

              v45 += v46 + 1;
              if (a1 != -612) {
                goto LABEL_94;
              }
            }
          }

          else
          {
LABEL_94:
          }

          v65 = 257;
LABEL_159:
          v74 = DNSTypeName(*(unsigned __int16 *)(a1 + 322));
          v75 = *(_DWORD *)(a1 + 244);
          v76 = *(_DWORD *)(a1 + 248);
          v77 = *(_DWORD *)(a1 + 280);
          *(_DWORD *)buf = 67110915;
          *(_DWORD *)&buf[4] = v44;
          LOWORD(v94) = 2160;
          *(void *)((char *)&v94 + 2) = 1752392040LL;
          WORD5(v94) = 1040;
          HIDWORD(v94) = v65;
          *(_WORD *)v95 = 2101;
          *(void *)&v95[2] = a1 + 356;
          v96 = 2082;
          v97 = v74;
          v98 = 1024;
          v99 = v75;
          v100 = 1024;
          v101 = v76;
          v102 = 1024;
          v103 = v77;
          _os_log_impl( (void *)&_mh_execute_header,  v43,  OS_LOG_TYPE_ERROR,  "[Q%u] mDNSPlatformGetDNSRoutePolicy: Query for %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%{publ ic}s), PID[%d], EUID[%d], ServiceID[%d] evaluator is NULL",  buf,  0x3Eu);
        }
      }

      nw_release(v4);
      v72 = v6;
      goto LABEL_161;
    }

    v20 = (os_log_s *)mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_ERROR))
      {
        v21 = bswap32(*(unsigned __int16 *)(a1 + 320)) >> 16;
        v26 = (_BYTE *)(a1 + 356);
        if (a1 == -612)
        {
LABEL_57:
          while (v26)
          {
            v27 = *v26;
            if (!*v26)
            {
              v56 = (unsigned __int16)((_WORD)v26 - v2 + 1);
              goto LABEL_153;
            }

            v26 += v27 + 1;
            if (a1 != -612) {
              goto LABEL_56;
            }
          }
        }

        else
        {
LABEL_56:
        }

        v56 = 257;
        goto LABEL_153;
      }
    }

    else
    {
      v20 = (os_log_s *)mDNSLogCategory_Default_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_ERROR))
      {
        v21 = bswap32(*(unsigned __int16 *)(a1 + 320)) >> 16;
        v22 = (_BYTE *)(a1 + 356);
        if (a1 == -612)
        {
LABEL_41:
          while (v22)
          {
            v23 = *v22;
            if (!*v22)
            {
              v56 = (unsigned __int16)((_WORD)v22 - v2 + 1);
              goto LABEL_153;
            }

            v22 += v23 + 1;
            if (a1 != -612) {
              goto LABEL_40;
            }
          }
        }

        else
        {
LABEL_40:
        }

        v56 = 257;
LABEL_153:
        v68 = DNSTypeName(*(unsigned __int16 *)(a1 + 322));
        v69 = *(_DWORD *)(a1 + 244);
        v70 = *(_DWORD *)(a1 + 248);
        v71 = *(_DWORD *)(a1 + 280);
        *(_DWORD *)buf = 67110915;
        *(_DWORD *)&buf[4] = v21;
        LOWORD(v94) = 2160;
        *(void *)((char *)&v94 + 2) = 1752392040LL;
        WORD5(v94) = 1040;
        HIDWORD(v94) = v56;
        *(_WORD *)v95 = 2101;
        *(void *)&v95[2] = a1 + 356;
        v96 = 2082;
        v97 = v68;
        v98 = 1024;
        v99 = v69;
        v100 = 1024;
        v101 = v70;
        v102 = 1024;
        v103 = v71;
        _os_log_impl( (void *)&_mh_execute_header,  v20,  OS_LOG_TYPE_ERROR,  "[Q%u] mDNSPlatformGetDNSRoutePolicy: Query for %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%{public }s), PID[%d], EUID[%d], ServiceID[%d] parameters is NULL",  buf,  0x3Eu);
      }
    }

    v72 = v4;
LABEL_161:
    nw_release(v72);
    goto LABEL_162;
  }

  v16 = (os_log_s *)mDNSLogCategory_Default;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
  {
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_ERROR))
    {
      v17 = bswap32(*(unsigned __int16 *)(a1 + 320)) >> 16;
      v24 = (_BYTE *)(a1 + 356);
      if (a1 == -612)
      {
LABEL_49:
        while (v24)
        {
          v25 = *v24;
          if (!*v24)
          {
            v29 = (unsigned __int16)((_WORD)v24 - v2 + 1);
            goto LABEL_134;
          }

          v24 += v25 + 1;
          if (a1 != -612) {
            goto LABEL_48;
          }
        }
      }

      else
      {
LABEL_48:
      }

      v29 = 257;
      goto LABEL_134;
    }
  }

  else
  {
    v16 = (os_log_s *)mDNSLogCategory_Default_redacted;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_ERROR))
    {
      v17 = bswap32(*(unsigned __int16 *)(a1 + 320)) >> 16;
      v18 = (_BYTE *)(a1 + 356);
      if (a1 == -612)
      {
LABEL_31:
        while (v18)
        {
          v19 = *v18;
          if (!*v18)
          {
            v29 = (unsigned __int16)((_WORD)v18 - v2 + 1);
            goto LABEL_134;
          }

          v18 += v19 + 1;
          if (a1 != -612) {
            goto LABEL_30;
          }
        }
      }

      else
      {
LABEL_30:
      }

      v29 = 257;
LABEL_134:
      v57 = DNSTypeName(*(unsigned __int16 *)(a1 + 322));
      v58 = *(_DWORD *)(a1 + 244);
      v59 = *(_DWORD *)(a1 + 248);
      v60 = *(_DWORD *)(a1 + 280);
      *(_DWORD *)buf = 67110915;
      *(_DWORD *)&buf[4] = v17;
      LOWORD(v94) = 2160;
      *(void *)((char *)&v94 + 2) = 1752392040LL;
      WORD5(v94) = 1040;
      HIDWORD(v94) = v29;
      *(_WORD *)v95 = 2101;
      *(void *)&v95[2] = a1 + 356;
      v96 = 2082;
      v97 = v57;
      v98 = 1024;
      v99 = v58;
      v100 = 1024;
      v101 = v59;
      v102 = 1024;
      v103 = v60;
      _os_log_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_ERROR,  "[Q%u] mDNSPlatformGetDNSRoutePolicy: Query for %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%{public}s), PID[%d], EUID[%d], ServiceID[%d] host is NULL",  buf,  0x3Eu);
    }
  }

void LogMsgWithLevel( os_log_s *a1, os_log_type_t a2, char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9)
{
  if (!a1) {
    a1 = (os_log_s *)mDNSLogCategory_Default;
  }
  if (os_log_type_enabled(a1, a2))
  {
    *(_DWORD *)buf = 136380675;
    v12 = __b;
    _os_log_impl((void *)&_mh_execute_header, a1, a2, "%{private}s", buf, 0xCu);
  }
}

uint64_t mDNS_vsnprintf(char *__b, int a2, char *a3, int *a4)
{
  if (!a2) {
    return 0LL;
  }
  unsigned int v6 = a2 - 1;
  if (a2 == 1)
  {
    uint64_t v8 = 0LL;
    goto LABEL_286;
  }

  v7 = (unsigned __int8 *)a3;
  uint64_t v8 = 0LL;
  int v9 = *a3;
  int v102 = a2 - 2;
  unsigned int v104 = a2 - 1;
LABEL_4:
  if (v9 != 37)
  {
    if (!v9) {
      goto LABEL_286;
    }
    *__b++ = v9;
    uint64_t v8 = (v8 + 1);
    goto LABEL_199;
  }

  char v10 = 0;
  char v11 = 0;
  int v12 = 0;
  memset(v107, 0, sizeof(v107));
  while (2)
  {
    int v9 = (char)*++v7;
    int v13 = *v7;
    int v14 = 4;
    switch(*v7)
    {
      case '*':
        v17 = a4;
        a4 += 2;
        int v18 = *v17;
        if (v18 >= 0) {
          unsigned int v15 = v18;
        }
        else {
          unsigned int v15 = -v18;
        }
        v12 |= v18 >> 31;
        int v9 = (char)*++v7;
        goto LABEL_26;
      case '+':
        int v14 = 2;
        goto LABEL_12;
      case ',':
      case '.':
      case '/':
        goto LABEL_17;
      case '-':
        int v14 = 1;
        goto LABEL_12;
      case '0':
LABEL_12:
        v12 |= v14;
        continue;
      default:
        if (v13 == 32)
        {
          char v10 = 32;
          continue;
        }

        if (v13 == 35)
        {
          ++v11;
          continue;
        }

LABEL_17:
        if ((v13 - 48) > 9)
        {
          unsigned int v15 = 0;
        }

        else
        {
          unsigned int v15 = 0;
          do
          {
            unsigned int v15 = v9 + 10 * v15 - 48;
            int v16 = (char)*++v7;
            int v9 = v16;
          }

          while ((v16 - 48) < 0xA);
        }

  v7[3] = (uint64_t)v9;
  return v7;
}

  v18.tv_sec = 0LL;
  v18.tv_nsec = 0LL;
  clock_gettime(_CLOCK_MONOTONIC_RAW, &v18);
  char v11 = LODWORD(v18.tv_sec) - v5;
  int v12 = v6 - (LODWORD(v18.tv_sec) - v5);
  if (v12 < 0) {
    int v12 = LODWORD(v18.tv_sec) - v5 - v6;
  }
  if (v6 < v11) {
    v2 = 0xFFFFFFFFLL;
  }
  else {
    v2 = 2LL;
  }
  int v13 = (os_log_s *)mDNSLogCategory_mDNS;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
  {
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
    {
      int v14 = a1[1];
      unsigned int v15 = "win";
      int v16 = *(_DWORD *)(v4 + 12);
      if (v6 < v11) {
        unsigned int v15 = "lose";
      }
      goto LABEL_33;
    }
  }

  else
  {
    int v13 = (os_log_s *)mDNSLogCategory_mDNS_redacted;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
    {
      int v14 = a1[1];
      unsigned int v15 = "win";
      int v16 = *(_DWORD *)(v4 + 12);
      if (v6 < v11) {
        unsigned int v15 = "lose";
      }
LABEL_33:
      LODWORD(v18.tv_sec) = 67110146;
      HIDWORD(v18.tv_sec) = v11;
      LOWORD(v18.tv_nsec) = 1024;
      *(_DWORD *)((char *)&v18.tv_nsec + 2) = v14;
      HIWORD(v18.tv_nsec) = 2082;
      v19 = v15;
      v20 = 1024;
      unsigned int v21 = v6;
      int v22 = 1024;
      char v23 = v16;
      _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEFAULT,  "CheckTSR - pktTimeOfReceipt: %d %x %{public}s ourTimeOfReceipt: %d %x",  (uint8_t *)&v18,  0x24u);
    }
  }

  return v2;
}

      if (*(_BYTE *)(v1 + 8) == 1)
      {
        if (*(unsigned __int8 *)(v1 + 191) >= 2u)
        {
          *(_BYTE *)(v1 + 191) = 1;
          *(_DWORD *)(v1 + 284) = dword_100158BF8 - *(_DWORD *)(v1 + 280);
          SetNextAnnounceProbeTime((uint64_t)mDNSStorage, v1);
        }
      }

      else
      {
        mDNS_Deregister_internal((uint64_t)mDNSStorage, v1, 1);
      }

      uint64_t v8 = *((void *)&xmmword_10015BD18 + 1);
      if (*((void *)&xmmword_10015BD18 + 1) == v1)
      {
        uint64_t v8 = *(void *)v1;
        *((void *)&xmmword_10015BD18 + 1) = *(void *)v1;
      }

      v1 = v8;
      if (!v8) {
        return;
      }
    }

    v2 = (os_log_s *)mDNSLogCategory_Default_redacted;
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_17;
    }
    uint64_t v4 = (unsigned __int8 *)(v1 + 8);
    v5 = *(unsigned __int8 *)(v1 + 8);
    if (v5 == 1) {
      unsigned int v6 = "Accelerating";
    }
    else {
      unsigned int v6 = "Initiating  ";
    }
    goto LABEL_16;
  }

  v42 = mdns_snprintf_add(&v48, v12, ", nat64 prefix: %s/%d", v35, v36, v37, v38, v39, v40);
  if ((v42 & 0x80000000) != 0) {
    return 4294960596LL;
  }
  v33 += v42;
LABEL_19:
  if (*(_BYTE *)(a1 + 77)) {
    unint64_t v43 = "yes";
  }
  else {
    unint64_t v43 = "no";
  }
  v44 = mdns_snprintf_add(&v48, v12, ", forces AAAA synthesis: %s", v28, v29, v30, v31, v32, (char)v43);
  if (v44 < 0) {
    return 4294960596LL;
  }
  v45 = v44;
  if (a5) {
    *a5 = v48 - a3;
  }
  result = 0LL;
  if (v47) {
    unint64_t *v47 = v33 + (v45 & ~(v45 >> 31));
  }
  return result;
}

  v155 = v8;
  __src = (_BYTE *)(v11 + 692);
  v19 = (unsigned __int8 *)(v11 + 80);
  v20 = v11 + 948;
  unsigned int v21 = *(uint64_t **)(v11 + 1016);
  int v22 = *(void *)(v11 + 1000);
  v161 = (unsigned __int8 *)(v11 + 80);
  while (2)
  {
    v170 = *v21;
    v171 = *((_DWORD *)v21 + 2);
    v172 = 0;
    mDNS_Lock_((unsigned int *)mDNSStorage, (uint64_t)"AddResourceRecord", 305);
    v162 = dword_100158BF8;
    mDNS_Unlock_((uint64_t)mDNSStorage, (uint64_t)"AddResourceRecord", 307);
    if (*(_BYTE *)(v11 + 48))
    {
      v28 = *(_WORD *)(v11 + 1008);
LABEL_21:
      v29 = v28;
      goto LABEL_22;
    }

    v29 = *(_WORD *)(v11 + 68);
    v28 = *(_WORD *)(v11 + 1008);
LABEL_22:
    v163 = *(void *)(v11 + 1016) + v29 + 12LL;
    if (mDNS_LoggingEnabled == 1) {
      LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "AddResourceRecord: Limit is %d",  v23,  v24,  v25,  v26,  v27,  v163 - *(_DWORD *)(v11 + 1000));
    }
    v30 = CacheGroupForName((uint64_t)mDNSStorage, *(_DWORD *)(v11 + 536), __src);
    if (!v30)
    {
      if (mDNS_LoggingEnabled == 1) {
        LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "AddResourceRecord: CacheGroup not found for %##s",  v31,  v32,  v33,  v34,  v35,  (int)__src);
      }
      unsigned int v48 = 0LL;
      int v85 = 0;
      goto LABEL_95;
    }

    v158 = v21;
    v159 = v22;
    v36 = v30[2];
    if (!v36)
    {
LABEL_81:
      if (mDNS_LoggingEnabled == 1) {
        LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "AddResourceRecord: Did not find any valid ResourceRecords",  v31,  v32,  v33,  v34,  v35,  v154);
      }
      unsigned int v48 = 0LL;
      int v85 = 0;
      goto LABEL_94;
    }

    v37 = 0LL;
    v38 = 0LL;
    v39 = 12;
    while (1)
    {
      unint64_t v40 = (unsigned __int8 *)(v36 + 8);
      v41 = *(_WORD **)(v11 + 1016);
      if (!v41[2]) {
        break;
      }
      if (!v38) {
        v38 = *(void *)(v11 + 1000);
      }
LABEL_44:
      if (*v40 == 240)
      {
        BOOL v49 = 0;
      }

      else
      {
        v186 = 0u;
        memset(v187, 0, sizeof(v187));
        v184 = 0u;
        v185 = 0u;
        v182 = 0u;
        v183 = 0u;
        v180 = 0u;
        v181 = 0u;
        v178 = 0u;
        v179 = 0u;
        v176 = 0u;
        v177 = 0u;
        v174 = 0u;
        v175 = 0u;
        memset(v173, 0, sizeof(v173));
        v168 = 0u;
        v169 = 0u;
        uint64_t v50 = *(void *)(v11 + 1024);
        char v51 = *(unsigned __int8 *)(v50 + 76);
        char v52 = v50 + 24;
        if (v51) {
          unint64_t v53 = v52;
        }
        else {
          unint64_t v53 = 0LL;
        }
        unsigned int v54 = (unsigned __int8 *)(v36 + 8);
        v166 = 0uLL;
        v167 = 0uLL;
        if (v51)
        {
          unsigned int v54 = (unsigned __int8 *)(v36 + 8);
          if (*(_DWORD *)(v11 + 996) == 1)
          {
            unsigned int v54 = (unsigned __int8 *)(v36 + 8);
            if (*(_WORD *)(v36 + 12) == 1)
            {
              v164 = 0uLL;
              int v55 = *(_OWORD *)(v36 + 24);
              v166 = *(_OWORD *)v40;
              v167 = v55;
              v56 = *(_OWORD *)(v36 + 56);
              *(void *)&v168 = *(void *)(v36 + 40);
              v169 = v56;
              WORD2(v166) = 28;
              WORD6(v166) = 16;
              LOWORD(v173[0]) = 16;
              *((void *)&v168 + 1) = v173;
              v165 = *(_DWORD *)(*(void *)(v36 + 48) + 4LL);
              *(_OWORD *)((char *)v173 + 4) = v164;
              unsigned int v54 = (unsigned __int8 *)&v166;
            }
          }
        }

        if (mDNS_LoggingEnabled == 1)
        {
          int v57 = (os_log_s *)mDNSLogCategory_Default;
          GetRRDisplayString_rdb(v54, (unsigned __int16 *)(*((void *)v54 + 5) + 4LL), word_100164338);
          v20 = v11 + 948;
          LogMsgWithLevel( v57,  OS_LOG_TYPE_DEFAULT,  "AddResourceRecord: Answering question with %s",  v58,  v59,  v60,  v61,  v62,  (int)word_100164338);
        }

        char v63 = -274877907LL * (v162 - *(_DWORD *)(v36 + 80));
        uint64_t v64 = PutResourceRecordTTLWithLimit( *(void *)(v11 + 1016),  v38,  (_WORD *)(*(void *)(v11 + 1016) + 6LL),  (uint64_t)v54,  (v63 >> 38) + ((unint64_t)v63 >> 63) + *(_DWORD *)(v36 + 16),  v163,  v34,  v35);
        unsigned int v48 = *(_BYTE **)(v11 + 1000);
        if (!v64) {
          goto LABEL_93;
        }
        v38 = v64;
        v39 += v64 - (_DWORD)v48;
        *(void *)(v11 + 1000) = v64;
        BOOL v49 = *(unsigned __int16 *)(v36 + 12) == 5;
      }

      if (*(void *)(v36 + 120))
      {
        v37 = *(void *)(v36 + 120);
        if (mDNS_LoggingEnabled == 1)
        {
          unsigned int v65 = (os_log_s *)mDNSLogCategory_Default;
          GetRRDisplayString_rdb( (unsigned __int8 *)(v36 + 8),  (unsigned __int16 *)(*(void *)(v36 + 48) + 4LL),  word_100164338);
          LogMsgWithLevel( v65,  OS_LOG_TYPE_DEFAULT,  "AddResourceRecord: soa set for %s",  v66,  v67,  v68,  v69,  v70,  (int)word_100164338);
          v37 = *(void *)(v36 + 120);
        }
      }

      v71 = *(unsigned __int16 *)(v36 + 12);
      if (*(unsigned __int16 *)(v11 + 658) != v71 && v71 == 5 && mDNS_LoggingEnabled)
      {
        v72 = (os_log_s *)mDNSLogCategory_Default;
        GetRRDisplayString_rdb( (unsigned __int8 *)(v36 + 8),  (unsigned __int16 *)(*(void *)(v36 + 48) + 4LL),  word_100164338);
        v20 = v11 + 948;
        LogMsgWithLevel( v72,  OS_LOG_TYPE_DEFAULT,  "AddResourceRecord: cname set for %s",  v73,  v74,  v75,  v76,  v77,  (int)word_100164338);
      }

      if (v49)
      {
LABEL_67:
        if (v37)
        {
          v19 = (unsigned __int8 *)(v11 + 80);
          if (mDNS_LoggingEnabled == 1)
          {
            int v78 = (os_log_s *)mDNSLogCategory_Default;
            GetRRDisplayString_rdb( (unsigned __int8 *)(v37 + 8),  (unsigned __int16 *)(*(void *)(v37 + 48) + 4LL),  word_100164338);
            LogMsgWithLevel( v78,  OS_LOG_TYPE_DEFAULT,  "AddResourceRecord: SOA Answering question with %s",  v79,  v80,  v81,  v82,  v83,  (int)word_100164338);
          }

          int v84 = PutResourceRecordTTLWithLimit( *(void *)(v11 + 1016),  v38,  (_WORD *)(*(void *)(v11 + 1016) + 8LL),  v37 + 8,  *(unsigned int *)(v37 + 16),  v163,  v34,  v35);
          unsigned int v48 = *(_BYTE **)(v11 + 1000);
          if (v84)
          {
            v38 = v84;
            v39 += v84 - (_DWORD)v48;
            *(void *)(v11 + 1000) = v84;
            goto LABEL_76;
          }

    char v23 = fcntl(a1, 3, 0LL);
    if ((fcntl(a1, 4, v23 | 4u) & 0x80000000) == 0)
    {
      LODWORD(a2[v10]) = a1;
      a2[v11] = myKQSocketCallBack;
      v12[1] = a2;
      v12[2] = "UDP Proxy packet reception";
      KQueueSet(a1, 1u, -1, v12);
      return v14;
    }

    uint64_t v31 = (os_log_s *)mDNSLogCategory_Default;
    char v52 = *__error();
    LogMsgWithLevel(v31, OS_LOG_TYPE_DEFAULT, "SetupUDPProxySocket: fnctl failed %d", v32, v33, v34, v35, v36, v52);
    return 0xFFFFFFFFLL;
  }

  int v13 = setsockopt(a1, 0, 7, &v53, 4u);
  if ((v13 & 0x80000000) != 0)
  {
    int v14 = v13;
    char v24 = (os_log_s *)mDNSLogCategory_Default;
    __error();
    int v25 = __error();
    strerror(*v25);
    LogMsgWithLevel( v24,  OS_LOG_TYPE_DEFAULT,  "SetupUDPProxySocket: IP_RECVDSTADDR %d errno %d (%s)",  v26,  v27,  v28,  v29,  v30,  a1);
    return v14;
  }

  int v14 = setsockopt(a1, 0, 20, &v53, 4u);
  if ((v14 & 0x80000000) == 0) {
    goto LABEL_17;
  }
  unsigned int v15 = (os_log_s *)mDNSLogCategory_Default;
  __error();
  int v16 = __error();
  strerror(*v16);
  LogMsgWithLevel( v15,  OS_LOG_TYPE_DEFAULT,  "SetupUDPProxySocket: IP_RECVIF %d errno %d (%s)",  v17,  v18,  v19,  v20,  v21,  a1);
  return v14;
}

LABEL_26:
        if (v9 == 46)
        {
          v19 = v7 + 1;
          int v9 = (char)v7[1];
          if (v9 == 42)
          {
            v20 = (unsigned int *)a4;
            a4 += 2;
            unsigned int v21 = *v20;
            int v9 = (char)v7[2];
            v19 = v7 + 2;
          }

          else if ((v9 - 48) > 9)
          {
            unsigned int v21 = 0;
          }

          else
          {
            unsigned int v21 = 0;
            do
            {
              unsigned int v21 = v9 + 10 * v21 - 48;
              int v22 = (char)*++v19;
              int v9 = v22;
            }

            while ((v22 - 48) < 0xA);
          }

          LOBYTE(v12) = v12 | 8;
          v7 = v19;
        }

        else
        {
          unsigned int v21 = 0;
        }

        if ((v12 & 1) != 0) {
          char v23 = v12 & 0xFB;
        }
        else {
          char v23 = v12;
        }
        while (2)
        {
          char v24 = 32;
          if (v9 > 87)
          {
            switch(v9)
            {
              case 'a':
                v33 = a4;
                a4 += 2;
                v34 = *(_DWORD **)v33;
                if (!v34)
                {
                  char v27 = 1;
                  LODWORD(v26) = 8;
                  int v9 = 97;
                  v29 = "<<NULL>>";
                  goto LABEL_155;
                }

                if (!v11)
                {
                  switch(v21)
                  {
                    case 4u:
LABEL_219:
                      v29 = v107;
                      LODWORD(v26) = mDNS_snprintf(v107);
                      char v27 = 1;
                      unsigned int v21 = 4;
                      int v9 = 97;
                      unsigned int v6 = v104;
                      goto LABEL_155;
                    case 6u:
                      v29 = v107;
                      break;
                    case 0x10u:
LABEL_222:
                      int v82 = 0;
                      int v83 = 0;
                      int v84 = 0;
                      int v85 = 0;
                      int v86 = 0;
                      v87 = (char *)v34 + 1;
                      uint64_t v88 = 7LL;
                      while (1)
                      {
                        if (__rev16(*(unsigned __int16 *)(v87 - 1)))
                        {
                          if (v88 <= v84) {
                            goto LABEL_232;
                          }
                          int v86 = 0;
                        }

                        else
                        {
                          if (!v86) {
                            int v85 = v82;
                          }
                          if (v86 + 1 > v84)
                          {
                            int v84 = v86 + 1;
                            int v83 = v85;
                          }

                          ++v86;
                        }

                        v87 += 2;
                        --v88;
                        ++v82;
                        if (v88 == -1)
                        {
LABEL_232:
                          if (v84 <= 1) {
                            int v89 = -1;
                          }
                          else {
                            int v89 = v84 + v83 - 1;
                          }
                          int v90 = 7;
                          v29 = &v108;
                          while (1)
                          {
                            if (v90 == v89)
                            {
                              if (v89 == 7) {
                                *--v29 = 58;
                              }
                              --v29;
                              int v90 = v83;
                            }

                            else
                            {
                              unsigned int v91 = *((unsigned __int8 *)v34 + 2 * v90 + 1) | (*((unsigned __int8 *)v34 + 2 * v90) << 8);
                              do
                              {
                                v92 = v29;
                                *--v29 = a0123456789abcd[v91 & 0xF];
                                BOOL v59 = v91 > 0xF;
                                v91 >>= 4;
                              }

                              while (v59);
                              if (v90 < 1)
                              {
LABEL_245:
                                LODWORD(v26) = &v108 - (_DWORD)v29;
                                char v27 = 1;
                                unsigned int v21 = 16;
                                goto LABEL_261;
                              }

                              v29 = v92 - 2;
                            }

                            char *v29 = 58;
                            if (--v90 < 0) {
                              goto LABEL_245;
                            }
                          }
                        }
                      }

                    default:
                      v29 = v107;
                      break;
                  }

                  int v97 = mDNS_snprintf(v107);
                  unsigned int v6 = v104;
                  LODWORD(v26) = v97;
                  goto LABEL_260;
                }

                int v35 = *v34;
                if (!*v34)
                {
                  v29 = v107;
                  goto LABEL_247;
                }

                if (v35 == 6)
                {
                  ++v34;
                  goto LABEL_222;
                }

                if (v35 == 4) {
                  goto LABEL_219;
                }
                v29 = v107;
LABEL_247:
                int v93 = mDNS_snprintf(v107);
                unsigned int v6 = v104;
                LODWORD(v26) = v93;
                unsigned int v21 = 0;
LABEL_260:
                char v27 = 1;
LABEL_261:
                int v9 = 97;
LABEL_155:
                if (v26 < v15 && (v23 & 1) == 0)
                {
                  LODWORD(v64) = v15 + ~(_DWORD)v26;
                  else {
                    unsigned int v65 = v6;
                  }
                  unsigned int v103 = v21;
                  char v66 = v23;
                  uint64_t v67 = v4;
                  char v68 = v27;
                  unsigned int v69 = v65 + ~(_DWORD)v8;
                  else {
                    uint64_t v64 = v64;
                  }
                  memset(__b, 32, v64 + 1);
                  char v27 = v68;
                  uint64_t v4 = v67;
                  char v23 = v66;
                  unsigned int v21 = v103;
                  unsigned int v6 = v104;
                  do
                  {
                    ++__b;
                    uint64_t v8 = (v8 + 1);
                  }

                  while (v26 < --v15);
                }

                unsigned int v70 = v6 - v8;
                if ((v27 & 1) != 0)
                {
                  if (v26 <= v70)
                  {
                    if ((_DWORD)v26) {
                      goto LABEL_188;
                    }
                    unsigned int v70 = 0;
                  }

                  else if (v70)
                  {
                    while ((v29[v70] & 0xC0) == 0x80)
                    {
                      if (!--v70) {
                        goto LABEL_191;
                      }
                    }

                    LODWORD(v26) = v70;
LABEL_188:
                    uint64_t v75 = 0LL;
                    unsigned int v70 = v26;
                    do
                    {
                      __b[v75] = v29[v75];
                      ++v75;
                    }

                    while ((_DWORD)v26 != (_DWORD)v75);
                    __b += v75;
                  }
                }

                else
                {
                  v71 = __b;
                  if ((v23 & 8) != 0)
                  {
                    v71 = __b;
                    if (v21)
                    {
                      v72 = &__b[v70];
                      v71 = __b;
                      if (__b < v72)
                      {
                        uint64_t v73 = 0LL;
                        v71 = __b;
                        do
                        {
                          unint64_t v74 = v29[v73];
                          if ((_DWORD)v73) {
                            *v71++ = 32;
                          }
                          if (v71 < v72) {
                            *v71++ = a0123456789abcd[v74 >> 4];
                          }
                          if (v71 < v72) {
                            *v71++ = a0123456789abcd[v74 & 0xF];
                          }
                          ++v73;
                        }

                        while (v73 < v21 && v71 < v72);
                      }
                    }
                  }

                  unsigned int v70 = (_DWORD)v71 - (_DWORD)__b;
                  __b = v71;
                }

      free(v19);
      return 0LL;
    }

    *((_DWORD *)v18 + 2242) = v20;
    memcpy(v18 + 2, a2, (a3 - (_DWORD)a2));
  }

  unsigned __int8 *v19 = a1;
  int v22 = mDNSPlatformTCPSocket(v13, *a5, &v68, a7, v17);
  v19[1] = v22;
  v19[1122] = a8;
  v19[1123] = a9;
  v28 = a5[4];
  *((_OWORD *)v19 + 562) = *(_OWORD *)a5;
  *((_DWORD *)v19 + 2252) = v28;
  *((_WORD *)v19 + 4506) = v11;
  v19[1127] = 0LL;
  *((_WORD *)v19 + 4512) = 0;
  v19[1129] = 0LL;
  *((_DWORD *)v19 + 2260) = 0;
  *((_WORD *)v19 + 4507) = v68;
  if (!v22)
  {
    LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "MakeTCPConn: unable to create TCP socket",  v23,  v24,  v25,  v26,  v27,  v65);
    goto LABEL_26;
  }

  if (a8)
  {
    v29 = *((unsigned int *)v22 + 4);
    if ((v29 & 0x80000000) == 0)
    {
      bzero(buf, 0x3F1uLL);
      if (*(_DWORD *)(a8 + 244))
      {
        if (setsockopt(v29, 0xFFFF, 4359, (const void *)(a8 + 244), 4u) == -1)
        {
          v30 = (os_log_s *)mDNSLogCategory_Default;
          uint64_t v31 = __error();
          char v66 = strerror(*v31);
          LogMsgWithLevel( v30,  OS_LOG_TYPE_DEFAULT,  "mDNSPlatformSetSocktOpt: Delegate PID failed %s for PID %d",  v32,  v33,  v34,  v35,  v36,  v66);
        }
      }

      else if (setsockopt(v29, 0xFFFF, 4360, (const void *)(a8 + 636), 0x10u) == -1)
      {
        v39 = (os_log_s *)mDNSLogCategory_Default;
        unint64_t v40 = __error();
        uint64_t v67 = strerror(*v40);
        LogMsgWithLevel( v39,  OS_LOG_TYPE_DEFAULT,  "mDNSPlatformSetSocktOpt: Delegate UUID failed %s",  v41,  v42,  v43,  v44,  v45,  v67);
      }

      ConvertDomainNameToCString_withescape((unsigned __int8 *)(a8 + 356), buf);
      if ((ne_session_set_socket_attributes(v29, buf, 0LL) & 1) == 0 && mDNS_LoggingEnabled) {
        LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "mDNSPlatformSetSocktOpt: ne_session_set_socket_attributes()-> setting domain failed for %s",  v46,  v47,  v48,  v49,  v50,  (int)buf);
      }
      unsigned int v69 = 1;
      if (setsockopt(v29, 0xFFFF, 0x10000, &v69, 4u) == -1 && mDNS_LoggingEnabled)
      {
        char v51 = (os_log_s *)mDNSLogCategory_Default;
        char v52 = __error();
        unint64_t v53 = strerror(*v52);
        LogMsgWithLevel( v51,  OS_LOG_TYPE_DEFAULT,  "mDNSPlatformSetSocktOpt: SO_NOWAKEFROMSLEEP failed %s",  v54,  v55,  v56,  v57,  v58,  v53);
      }

      int v22 = (void *)v19[1];
    }

    v38 = *(void *)(a8 + 136);
  }

  else
  {
    v38 = 0LL;
  }

  BOOL v59 = mDNSPlatformTCPConnect((uint64_t)v22, a5, v11, v38, (uint64_t)tcpCallback, (uint64_t)v19);
  if (v59 != -65787)
  {
    if (v59 == -65789)
    {
      tcpCallback(v19[1], (uint64_t)v19, 1, 0LL, v61, v62, v63, v64);
      return v19;
    }

    if (mDNS_LoggingEnabled == 1) {
      LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "MakeTCPConn: connection failed",  v60,  v61,  v62,  v63,  v64,  v65);
    }
    DisposeTCPConn((uint64_t)v19);
    return 0LL;
  }

  return v19;
}

      *((_BYTE *)v9 + 6379) = 1;
      while (1)
      {
        int v9 = (uint64_t *)*v9;
        if (!v9) {
          break;
        }
        if (*((_BYTE *)v9 + 16)) {
          goto LABEL_26;
        }
      }
    }
  }

      *a3 = v14;
      goto LABEL_27;
    }
  }

  __break(1u);
  return result;
}

      os_release((void *)v24);
      goto LABEL_27;
    }

    os_release(v16);
    v41 = 4294960591LL;
  }

  else
  {
    v41 = 4294960567LL;
  }

          free(v19);
          return;
        }
      }
    }

    if (_mdns_resolver_log_s_once != -1) {
      dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_48);
    }
    unint64_t v40 = _mdns_resolver_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_DEFAULT))
    {
      v41 = *(void *)(a2 + 32);
      v42 = a3[4];
      unint64_t v43 = 136448258;
      v44 = v10;
      v45 = 1024;
      unint64_t v46 = a4;
      v47 = 2048;
      unsigned int v48 = v11;
      BOOL v49 = 2112;
      uint64_t v50 = v41;
      char v51 = 1024;
      char v52 = v13;
      unint64_t v53 = 2082;
      unsigned int v54 = interface_log_string;
      int v55 = 1040;
      *(_DWORD *)v56 = v11;
      *(_WORD *)&v56[4] = 2098;
      *(void *)&v56[6] = v42;
      *(_WORD *)&v56[14] = 2112;
      *(void *)&v56[16] = a3;
      v37 = "%{public}sReceived %{mdns:acceptable}d %zu-byte response from %@ over %{mdns:protocol}d via %{public}s -- %{"
            "public,mdns:dnshdr}.*P, %@";
      v38 = (os_log_s *)v40;
      v39 = 80;
      goto LABEL_35;
    }
  }

  else
  {
    unsigned int v15 = a3[4];
    if (a6)
    {
      int v16 = a3 + 2;
      while (1)
      {
        int v16 = (void *)*v16;
        if (!v16) {
          break;
        }
        v17 = (uint64_t (*)(void *, void, uint64_t))v16[3];
        if (v17)
        {
          int v18 = v17(a3, 0LL, 1LL);
          if (!v18) {
            break;
          }
          v19 = (void *)v18;
          if (_mdns_resolver_log_s_once != -1) {
            dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_48);
          }
          v20 = _mdns_resolver_log_s_log;
          if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_DEFAULT))
          {
            unsigned int v21 = *(void *)(a2 + 32);
            int v22 = bswap32(*(_DWORD *)v15);
            char v23 = bswap64(*(void *)(v15 + 4));
            unint64_t v43 = 136448258;
            v44 = v10;
            v45 = 1024;
            unint64_t v46 = a4;
            v47 = 2048;
            unsigned int v48 = v11;
            BOOL v49 = 2112;
            uint64_t v50 = v21;
            char v51 = 1024;
            char v52 = v13;
            unint64_t v53 = 2082;
            unsigned int v54 = interface_log_string;
            int v55 = 2048;
            *(void *)v56 = v22;
            *(_WORD *)&v56[8] = 2048;
            *(void *)&v56[10] = v23;
            *(_WORD *)&v56[18] = 2082;
            *(void *)&v56[20] = v19;
            char v24 = "%{public}sReceived %{mdns:acceptable}d %zu-byte response from %@ over %{mdns:protocol}d via %{public}s"
                  " -- %{mdns:dns.idflags}08lX, counts: %{mdns:dns.counts}016llX, %{public}s";
            int v25 = (os_log_s *)v20;
            unint64_t v26 = 84;
            goto LABEL_25;
          }

          goto LABEL_26;
        }
      }
    }

    if (_mdns_resolver_log_s_once != -1) {
      dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_48);
    }
    v33 = _mdns_resolver_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_DEFAULT))
    {
      v34 = *(void *)(a2 + 32);
      int v35 = bswap32(*(_DWORD *)v15);
      v36 = bswap64(*(void *)(v15 + 4));
      unint64_t v43 = 136448258;
      v44 = v10;
      v45 = 1024;
      unint64_t v46 = a4;
      v47 = 2048;
      unsigned int v48 = v11;
      BOOL v49 = 2112;
      uint64_t v50 = v34;
      char v51 = 1024;
      char v52 = v13;
      unint64_t v53 = 2082;
      unsigned int v54 = interface_log_string;
      int v55 = 2048;
      *(void *)v56 = v35;
      *(_WORD *)&v56[8] = 2048;
      *(void *)&v56[10] = v36;
      *(_WORD *)&v56[18] = 2112;
      *(void *)&v56[20] = a3;
      v37 = "%{public}sReceived %{mdns:acceptable}d %zu-byte response from %@ over %{mdns:protocol}d via %{public}s -- %{"
            "mdns:dns.idflags}08lX, counts: %{mdns:dns.counts}016llX, %@";
      v38 = (os_log_s *)v33;
      v39 = 84;
LABEL_35:
      _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_DEFAULT, v37, (uint8_t *)&v43, v39);
    }
  }

  *(_BYTE *)(v6 + v9) = 0;
LABEL_27:
  int v18 = (os_log_s *)mDNSLogCategory_State;
  v19 = os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT);
  if (a1 != 1)
  {
    if (!v19) {
      goto LABEL_43;
    }
    char v24 = *(unsigned __int8 *)(v6 + v7) + 1;
    int v25 = *(unsigned __int8 *)(v6 + v9) + 1;
    if (a2)
    {
      unint64_t v26 = *(unsigned __int8 *)a2 + 1;
      if (a3)
      {
LABEL_35:
        char v27 = *(unsigned __int8 *)a3 + 1;
LABEL_41:
        *(_DWORD *)buf = 141560835;
        *(void *)&uint8_t buf[4] = 1752392040LL;
        *(_WORD *)&buf[12] = 1040;
        *(_DWORD *)&buf[14] = v24;
        *(_WORD *)&buf[18] = 2101;
        *(void *)&buf[20] = v8;
        *(_WORD *)&buf[28] = 2160;
        *(void *)&buf[30] = 1752392040LL;
        *(_WORD *)&buf[38] = 1040;
        *(_DWORD *)&buf[40] = v25;
        *(_WORD *)&buf[44] = 2101;
        *(void *)&buf[46] = v10;
        *(_WORD *)&buf[54] = 2160;
        *(void *)&buf[56] = 1752392040LL;
        LOWORD(v59) = 1040;
        *(_DWORD *)((char *)&v59 + 2) = v26;
        WORD3(v59) = 2101;
        *((void *)&v59 + 1) = a2;
        LOWORD(v60) = 2160;
        *(void *)((char *)&v60 + 2) = 1752392040LL;
        WORD5(v60) = 1040;
        HIDWORD(v60) = v27;
        LOWORD(v61) = 2101;
        *(void *)((char *)&v61 + 2) = a3;
        v28 = "mDNSPreferencesSetNames: changing local host name -- last change: %{sensitive, mask.hash, mdnsresponder:do"
              "main_label}.*P -> %{sensitive, mask.hash, mdnsresponder:domain_label}.*P, current change: %{sensitive, mas"
              "k.hash, mdnsresponder:domain_label}.*P -> %{sensitive, mask.hash, mdnsresponder:domain_label}.*P";
        goto LABEL_42;
      }
    }

    else
    {
      unint64_t v26 = 0;
      if (a3) {
        goto LABEL_35;
      }
    }

    char v27 = 0;
    goto LABEL_41;
  }

  if (!v19) {
    goto LABEL_43;
  }
  v20 = *(unsigned __int8 *)(v6 + v7) + 1;
  unsigned int v21 = *(unsigned __int8 *)(v6 + v9) + 1;
  if (!a2)
  {
    int v22 = 0;
    if (a3) {
      goto LABEL_31;
    }
LABEL_37:
    char v23 = 0;
    goto LABEL_38;
  }

  int v22 = *(unsigned __int8 *)a2 + 1;
  if (!a3) {
    goto LABEL_37;
  }
LABEL_31:
  char v23 = *(unsigned __int8 *)a3 + 1;
LABEL_38:
  *(_DWORD *)buf = 141560835;
  *(void *)&uint8_t buf[4] = 1752392040LL;
  *(_WORD *)&buf[12] = 1040;
  *(_DWORD *)&buf[14] = v20;
  *(_WORD *)&buf[18] = 2101;
  *(void *)&buf[20] = v8;
  *(_WORD *)&buf[28] = 2160;
  *(void *)&buf[30] = 1752392040LL;
  *(_WORD *)&buf[38] = 1040;
  *(_DWORD *)&buf[40] = v21;
  *(_WORD *)&buf[44] = 2101;
  *(void *)&buf[46] = v10;
  *(_WORD *)&buf[54] = 2160;
  *(void *)&buf[56] = 1752392040LL;
  LOWORD(v59) = 1040;
  *(_DWORD *)((char *)&v59 + 2) = v22;
  WORD3(v59) = 2101;
  *((void *)&v59 + 1) = a2;
  LOWORD(v60) = 2160;
  *(void *)((char *)&v60 + 2) = 1752392040LL;
  WORD5(v60) = 1040;
  HIDWORD(v60) = v23;
  LOWORD(v61) = 2101;
  *(void *)((char *)&v61 + 2) = a3;
  v28 = "mDNSPreferencesSetNames: changing computer name -- last change: %{sensitive, mask.hash, mdnsresponder:domain_lab"
        "el}.*P -> %{sensitive, mask.hash, mdnsresponder:domain_label}.*P, current change: %{sensitive, mask.hash, mdnsre"
        "sponder:domain_label}.*P -> %{sensitive, mask.hash, mdnsresponder:domain_label}.*P";
LABEL_42:
  _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, v28, buf, 0x6Au);
LABEL_43:
  uint64_t v31 = *(unsigned __int8 *)a2;
  v30 = (uint8_t *)a2 + 1;
  v29 = v31;
  uint64_t v61 = 0u;
  uint64_t v62 = 0u;
  BOOL v59 = 0u;
  unsigned int v60 = 0u;
  memset(buf, 0, sizeof(buf));
  if (v31 <= 0x3FuLL)
  {
    if (v30 >= &v30[v29])
    {
      int v32 = buf;
    }

    else
    {
      int v32 = buf;
      do
      {
        v33 = *v30++;
        *v32++ = v33;
        --v29;
      }

      while (v29);
    }

    *int v32 = 0;
  }

  if (a3)
  {
    v36 = *(unsigned __int8 *)a3;
    int v35 = (char *)a3 + 1;
    v34 = v36;
    if (v36 <= 0x3FuLL)
    {
      v37 = &v59;
      if (v35 < &v35[v34])
      {
        v37 = &v59;
        do
        {
          v38 = *v35++;
          *(_BYTE *)v37 = v38;
          v37 = (__int128 *)((char *)v37 + 1);
          --v34;
        }

        while (v34);
      }

      *(_BYTE *)v37 = 0;
    }
  }

  if ((_BYTE)v59 && strcmp((const char *)buf, (const char *)&v59))
  {
    if (a1 != 2)
    {
      if (a1 != 1) {
        return;
      }
      v39 = CFStringCreateWithCString(kCFAllocatorDefault, (const char *)&v59, 0x8000100u);
      if (!v39)
      {
        BOOL v49 = -6700;
LABEL_77:
        uint64_t v50 = (os_log_s *)mDNSLogCategory_Default;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
        {
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_ERROR)) {
            return;
          }
        }

        else
        {
          uint64_t v50 = (os_log_s *)mDNSLogCategory_Default_redacted;
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_ERROR)) {
            return;
          }
        }

        nameEncoding = 141558531;
        uint64_t v64 = 1752392040LL;
        unsigned int v65 = 2085;
        char v66 = (uint64_t)&v59;
        uint64_t v67 = 2048;
        char v68 = v49;
        char v51 = "Failed to set computer name -- name: %{sensitive, mask.hash}s, error: %ld";
LABEL_93:
        _os_log_impl((void *)&_mh_execute_header, v50, OS_LOG_TYPE_ERROR, v51, (uint8_t *)&nameEncoding, 0x20u);
        return;
      }

      unint64_t v40 = v39;
      int v57 = 0;
      v41 = _mdns_system_create_locked_prefs(&v57);
      v56 = v41;
      if (!v57)
      {
        v42 = v41;
        nameEncoding = 0;
        unint64_t v43 = SCDynamicStoreCopyComputerName(0LL, &nameEncoding);
        if (v43) {
          v44 = nameEncoding;
        }
        else {
          v44 = 134217984LL;
        }
        if (v43) {
          CFRelease(v43);
        }
        if (SCPreferencesSetComputerName(v42, v40, v44))
        {
          int v57 = 0;
LABEL_75:
          int v57 = _mdns_system_commit_and_apply_prefs(v42);
          goto LABEL_76;
        }

        if (SCError())
        {
          int v57 = SCError();
          if (!v57) {
            goto LABEL_75;
          }
        }

        else
        {
          int v57 = -6700;
        }

        if (mdns_system_log_s_once != -1) {
          dispatch_once(&mdns_system_log_s_once, &__block_literal_global_6614);
        }
        unint64_t v53 = (os_log_s *)mdns_system_log_s_log;
        if (os_log_type_enabled((os_log_t)mdns_system_log_s_log, OS_LOG_TYPE_ERROR))
        {
          nameEncoding = 138412802;
          uint64_t v64 = (uint64_t)v40;
          unsigned int v65 = 2048;
          char v66 = v44;
          uint64_t v67 = 2048;
          char v68 = v57;
          _os_log_error_impl( (void *)&_mh_execute_header,  v53,  OS_LOG_TYPE_ERROR,  "SCPreferencesSetComputerName failed -- name: '%@', encoding: 0x%lX, error: %{mdns:err}ld",  (uint8_t *)&nameEncoding,  0x20u);
        }
      }

    int v9 = (os_log_s *)v5;
    char v10 = OS_LOG_TYPE_ERROR;
LABEL_27:
    _os_log_impl((void *)&_mh_execute_header, v9, v10, v6, v7, 2u);
    return;
  }

  dispatch_async((dispatch_queue_t)dnssd_analytics_init_sAnalyticsQueue, &__block_literal_global_10_7073);
  if (xpc_activity_set_state(a2, 5LL)) {
    return;
  }
  v5 = mDNSLogCategory_Analytics;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Analytics == mDNSLogCategory_State)
  {
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Analytics, OS_LOG_TYPE_ERROR)) {
      return;
    }
    int v13 = 0;
    unsigned int v6 = "com.apple.mDNSResponder.analytics.daily: Analytics XPC_ACTIVITY_STATE_DONE failed";
    v7 = (uint8_t *)&v13;
    goto LABEL_26;
  }

  v5 = mDNSLogCategory_Analytics_redacted;
  if (os_log_type_enabled((os_log_t)mDNSLogCategory_Analytics_redacted, OS_LOG_TYPE_ERROR))
  {
    int v12 = 0;
    unsigned int v6 = "com.apple.mDNSResponder.analytics.daily: Analytics XPC_ACTIVITY_STATE_DONE failed";
    v7 = (uint8_t *)&v12;
    goto LABEL_26;
  }

LABEL_191:
                uint64_t v8 = v70 + v8;
                unsigned int v76 = v15 - v70;
                if (v15 > v70)
                {
                  LODWORD(v77) = v15 + ~v70;
                  else {
                    uint64_t v77 = v77;
                  }
                  memset(__b, 32, v77 + 1);
                  unsigned int v6 = v104;
                  do
                  {
                    ++__b;
                    uint64_t v8 = (v8 + 1);
                  }

                  while (--v76);
                }

LABEL_199:
                int v78 = v9;
                int v9 = 0;
                if (v78)
                {
LABEL_200:
                  int v79 = (char)*++v7;
                  int v9 = v79;
                }

                goto LABEL_4;
              case 'b':
              case 'e':
              case 'f':
              case 'g':
              case 'j':
              case 'k':
              case 'm':
              case 'q':
              case 'r':
              case 't':
              case 'v':
              case 'w':
                goto LABEL_50;
              case 'c':
                v36 = a4;
                a4 += 2;
                v107[299] = *v36;
                LODWORD(v26) = 1;
                int v9 = 99;
                v29 = &v107[299];
                goto LABEL_154;
              case 'd':
              case 'i':
                v30 = a4;
                a4 += 2;
                if ((v23 & 0x20) != 0) {
                  uint64_t v31 = *(void *)v30;
                }
                else {
                  uint64_t v31 = *v30;
                }
                if ((v23 & 0x10) != 0) {
                  uint64_t v31 = (__int16)v31;
                }
                if ((v23 & 2) != 0) {
                  char v10 = 43;
                }
                if (v31 < 0) {
                  char v52 = 45;
                }
                else {
                  char v52 = v10;
                }
                if (v31 >= 0) {
                  unint64_t v46 = v31;
                }
                else {
                  unint64_t v46 = -v31;
                }
                goto LABEL_136;
              case 'h':
                char v24 = 16;
                goto LABEL_43;
              case 'l':
                goto LABEL_43;
              case 'n':
                v37 = a4;
                a4 += 2;
                v38 = *(_WORD **)v37;
                if ((v23 & 0x10) != 0)
                {
                  _WORD *v38 = v8;
                }

                else if ((v23 & 0x20) != 0)
                {
                  *(void *)v38 = v8;
                }

                else
                {
                  *(_DWORD *)v38 = v8;
                }

                goto LABEL_200;
              case 'o':
                v39 = (unsigned int *)a4;
                a4 += 2;
                if ((v23 & 0x20) != 0) {
                  unint64_t v40 = *(void *)v39;
                }
                else {
                  unint64_t v40 = *v39;
                }
                if ((v23 & 0x10) != 0) {
                  unint64_t v53 = (unsigned __int16)v40;
                }
                else {
                  unint64_t v53 = v40;
                }
                if ((v23 & 4) != 0) {
                  unsigned int v54 = v15;
                }
                else {
                  unsigned int v54 = v21;
                }
                if (v54 <= 1) {
                  unsigned int v54 = 1;
                }
                if ((v23 & 8) != 0) {
                  unsigned int v54 = v21;
                }
                if (v54 >= 0x12B) {
                  unsigned int v21 = 299;
                }
                else {
                  unsigned int v21 = v54;
                }
                if (v53)
                {
                  int v55 = -1;
                  v56 = v109;
                  do
                  {
                    int v57 = v53 & 7 | 0x30;
                    *(v56 - 2) = v53 & 7 | 0x30;
                    v29 = v56 - 2;
                    int v58 = v55++;
                    --v56;
                    BOOL v59 = v53 > 7;
                    v53 >>= 3;
                  }

                  while (v59);
                  LODWORD(v26) = v58 + 2;
                  if (v11 && v57 != 48)
                  {
                    *(v56 - 2) = 48;
                    LODWORD(v26) = v55 + 2;
                    v29 = v56 - 2;
                  }
                }

                else
                {
                  LODWORD(v26) = 0;
                  v29 = &v108;
                }

                if (v26 >= v21)
                {
                  char v27 = 1;
                  int v9 = 111;
                }

                else
                {
                  uint64_t v80 = v21 + ~(_DWORD)v26;
                  v29 += ~v80;
                  memset(v29, 48, v80 + 1);
                  unsigned int v6 = v104;
                  char v27 = 1;
                  int v9 = 111;
                  LODWORD(v26) = v21;
                }

                goto LABEL_155;
              case 'p':
                v23 |= 0x28u;
                unsigned int v21 = 16;
                goto LABEL_66;
              case 's':
                v44 = (char **)a4;
                a4 += 2;
                v29 = *v44;
                if (*v44)
                {
                  if (v11)
                  {
                    if (v11 == 1)
                    {
                      int v81 = *v29++;
                      LODWORD(v26) = v81;
                    }

                    else
                    {
                      if (v11 != 2)
                      {
                        LODWORD(v26) = 0;
                        goto LABEL_218;
                      }

                      if (*v29)
                      {
                        unint64_t v26 = (unint64_t)v107;
                        goto LABEL_254;
                      }

                      v107[0] = 46;
                      unint64_t v26 = (unint64_t)&v107[1];
                      if (*v29)
                      {
                        while (1)
                        {
LABEL_254:
                          memset(v106, 0, 253);
                          if (*v29 >= 0x40u)
                          {
                            v98 = (void *)v26;
                            goto LABEL_264;
                          }

                          ConvertDomainLabelToCString_withescape((unsigned __int8 *)v29, (unsigned __int8 *)v106, 92);
                          v26 += mDNS_snprintf((void *)v26);
                          v95 = &v29[*v29];
                          int v96 = v95[1];
                          v29 = v95 + 1;
                          unsigned int v6 = v104;
                          if (!v96) {
                            goto LABEL_265;
                          }
                        }

                        v98 = (void *)v26;
LABEL_264:
                        LODWORD(v26) = v26 + mDNS_snprintf(v98);
                        unsigned int v6 = v104;
                      }

LABEL_265:
                      v29 = v107;
                      LODWORD(v26) = v26 - v107;
                    }
                  }

                  else if ((v23 & 8) != 0)
                  {
                    if (v21)
                    {
                      uint64_t v94 = 0LL;
                      while (v29[v94])
                      {
                        if (v21 == ++v94)
                        {
                          LODWORD(v94) = v21;
                          break;
                        }
                      }
                    }

                    else
                    {
                      LODWORD(v94) = 0;
                    }

                    unint64_t v26 = v94;
                    do
                    {
                      if (!v26) {
                        goto LABEL_218;
                      }
                      v99 = (_BYTE *)v26--;
                      int v100 = (char)v99[(void)v29 - 1];
                    }

                    while ((v100 & 0xFFFFFFC0) == 0xFFFFFF80);
                    if (v100 < 0xFFFFFFC0)
                    {
                      LODWORD(v26) = (_DWORD)v99;
                    }

                    else if ((v94 - v26) <= 6 && (v100 >> (7 - (v94 - v26))) == 254)
                    {
                      LODWORD(v26) = v94;
                    }
                  }

                  else
                  {
                    LODWORD(v26) = -1;
                    do
                      LODWORD(v26) = v26 + 1;
                    while (v29[v26]);
                  }
                }

                else
                {
                  LODWORD(v26) = 8;
                  v29 = "<<NULL>>";
                }

                char v27 = 1;
                int v9 = 115;
                if (!v21)
                {
                  LODWORD(v26) = 0;
                  goto LABEL_155;
                }

                LODWORD(v26) = v21;
                while ((v29[v26] & 0xC0) == 0x80)
                {
                  char v27 = 1;
                  int v9 = 115;
                  LODWORD(v26) = v26 - 1;
                  if (!(_DWORD)v26) {
                    goto LABEL_155;
                  }
                }

LABEL_218:
                char v27 = 1;
                int v9 = 115;
                goto LABEL_155;
              case 'u':
                v45 = (unsigned int *)a4;
                a4 += 2;
                if ((v23 & 0x20) != 0) {
                  unint64_t v46 = *(void *)v45;
                }
                else {
                  unint64_t v46 = *v45;
                }
                char v52 = 0;
                if ((v23 & 0x10) != 0) {
                  unint64_t v46 = (unsigned __int16)v46;
                }
                int v9 = 117;
LABEL_136:
                unsigned int v60 = v15 - (v52 != 0);
                if ((v23 & 4) == 0) {
                  unsigned int v60 = v21;
                }
                if (v60 <= 1) {
                  unsigned int v60 = 1;
                }
                if ((v23 & 8) != 0) {
                  unsigned int v60 = v21;
                }
                if (v60 >= 0x12B) {
                  unsigned int v21 = 299;
                }
                else {
                  unsigned int v21 = v60;
                }
                if (v46)
                {
                  uint64_t v61 = 0LL;
                  do
                  {
                    v107[v61-- + 299] = (v46 % 0xA) | 0x30;
                    BOOL v49 = v46 >= 0xA;
                    v46 /= 0xAuLL;
                  }

                  while (v49);
                  LODWORD(v26) = -(int)v61;
                  v29 = &v109[v61 - 1];
                }

                else
                {
                  LODWORD(v26) = 0;
                  v29 = &v108;
                }

                if (v26 < v21)
                {
                  uint64_t v62 = v21 + ~(_DWORD)v26;
                  v29 += ~v62;
                  char v63 = v52;
                  memset(v29, 48, v62 + 1);
                  char v52 = v63;
                  unsigned int v6 = v104;
                  LODWORD(v26) = v21;
                }

                if (v52)
                {
                  *--v29 = v52;
                  LODWORD(v26) = v26 + 1;
                }

                goto LABEL_154;
              case 'x':
                v41 = "0123456789abcdef";
                if ((v23 & 0x20) != 0) {
                  goto LABEL_77;
                }
                goto LABEL_67;
              default:
                if (v9 != 88) {
                  goto LABEL_50;
                }
LABEL_66:
                v41 = "0123456789ABCDEF";
                if ((v23 & 0x20) != 0)
                {
LABEL_77:
                  v47 = (unint64_t *)a4;
                  a4 += 2;
                  unint64_t v43 = *v47;
                }

                else
                {
LABEL_67:
                  v42 = (unsigned int *)a4;
                  a4 += 2;
                  unint64_t v43 = *v42;
                }

                if ((v23 & 0x10) != 0) {
                  unint64_t v43 = (unsigned __int16)v43;
                }
                unsigned int v48 = v15 - 2;
                if (!v11) {
                  unsigned int v48 = v15;
                }
                if ((v23 & 4) == 0) {
                  unsigned int v48 = v21;
                }
                if (v48 <= 1) {
                  unsigned int v48 = 1;
                }
                if ((v23 & 8) != 0) {
                  unsigned int v48 = v21;
                }
                if (v48 >= 0x12B) {
                  unsigned int v21 = 299;
                }
                else {
                  unsigned int v21 = v48;
                }
                LODWORD(v26) = 0;
                if (v43)
                {
                  v29 = &v108;
                  do
                  {
                    *--v29 = v41[v43 & 0xF];
                    LODWORD(v26) = v26 + 1;
                    BOOL v49 = v43 >= 0x10;
                    v43 >>= 4;
                  }

                  while (v49);
                }

                else
                {
                  v29 = &v108;
                }

                if (v26 < v21)
                {
                  uint64_t v50 = v21 + ~(_DWORD)v26;
                  v29 += ~v50;
                  char v51 = v11;
                  memset(v29, 48, v50 + 1);
                  char v11 = v51;
                  unsigned int v6 = v104;
                  LODWORD(v26) = v21;
                }

                if (v11)
                {
                  *(v29 - 2) = 48;
                  v29 -= 2;
                  v29[1] = v9;
                  LODWORD(v26) = v26 + 2;
                }

                goto LABEL_154;
            }
          }

          if (v9 == 76)
          {
LABEL_43:
            v23 |= v24;
            int v25 = (char)*++v7;
            int v9 = v25;
            continue;
          }

          break;
        }

        if (v9 != 37)
        {
          if (v9 == 72)
          {
            LODWORD(v26) = 0;
            char v27 = 0;
            v28 = (char **)a4;
            a4 += 2;
            v29 = *v28;
          }

          else
          {
LABEL_50:
            v29 = v107;
            int v32 = mDNS_snprintf(v107);
            unsigned int v6 = v104;
            LODWORD(v26) = v32;
LABEL_154:
            char v27 = 1;
          }

          goto LABEL_155;
        }

        *__b++ = 37;
        uint64_t v8 = (v8 + 1);
        if (v8 < v6)
        {
          LODWORD(v26) = 0;
          char v27 = 1;
          v29 = &v108;
          goto LABEL_155;
        }

LABEL_286:
        *__b = 0;
        return v8;
    }
  }

        v130 = *(unsigned __int16 *)(a2 + 12);
        v131 = v104 + 2;
        if ((int)v104 + 2 <= v106)
        {
          v132 = v142;
          *v142 = __rev16(v130);
          v133 = v104;
          v134 = v130;
          memcpy(v142 + 1, __src, v133);
          v130 = v134;
        }

        else
        {
          v132 = 0LL;
        }

        *(_DWORD *)buf = 141559811;
        *(void *)&uint8_t buf[4] = 1752392040LL;
        *(_WORD *)&buf[12] = 1040;
        *(_DWORD *)&buf[14] = v119;
        *(_WORD *)&buf[18] = 2101;
        *(void *)&buf[20] = v87;
        *(_WORD *)&buf[28] = 1024;
        *(_DWORD *)&buf[30] = v149;
        *(_WORD *)&buf[34] = 1024;
        *(_DWORD *)&buf[36] = v130;
        *(_WORD *)&buf[40] = 2160;
        *(void *)&buf[42] = 1752392040LL;
        v153 = 1040;
        v154 = v131;
        v155 = 2101;
        v156 = v132;
        _os_log_impl( (void *)&_mh_execute_header,  log,  OS_LOG_TYPE_DEFAULT,  "mDNS_Register_internal: adding to active record list -- name: %{sensitive, mask.hash, mdnsresponder:domain_nam e}.*P (%x), type: %{mdns:rrtype}d, rdata: %{sensitive, mask.hash, mdns:rdata}.*P",  buf,  0x42u);
        v105 = v141;
      }

      if (v105) {
        free(v105);
      }
      goto LABEL_292;
    }

    v106 = v150 + 2;
    result = (uint64_t)malloc(v150 + 2LL);
    if (result)
    {
      v142 = (__int16 *)result;
      v105 = (void *)result;
      goto LABEL_239;
    }

uint64_t KQueueSet(int a1, uint16_t a2, int16_t a3, void *a4)
{
  v6.ident = a1;
  v6.filter = a3;
  v6.flags = a2;
  v6.fflags = 0;
  v6.data = 0LL;
  v6.udata = a4;
  int v4 = kevent(KQueueFD, &v6, 1, 0LL, 0, 0LL);
  uint64_t result = 0LL;
  if (v4 < 0) {
    return *__error();
  }
  return result;
}

void mDNSMacOSXSystemBuildNumber(void *a1)
{
  uint64_t v15 = 0LL;
  char v14 = 0;
  buffer[0] = *(_OWORD *)"<Unknown>";
  memset(&buffer[1], 0, 240);
  v32[0] = *(_OWORD *)"<Unknown>";
  memset(&v32[1], 0, 240);
  __int128 v28 = xmmword_1000FFFCC;
  __int128 v29 = unk_1000FFFDC;
  __int128 v30 = xmmword_1000FFFEC;
  __int128 v31 = unk_1000FFFFC;
  __int128 v24 = xmmword_1000FFF8C;
  __int128 v25 = unk_1000FFF9C;
  __int128 v26 = xmmword_1000FFFAC;
  __int128 v27 = unk_1000FFFBC;
  __int128 v20 = xmmword_1000FFF4C;
  __int128 v21 = unk_1000FFF5C;
  __int128 v22 = xmmword_1000FFF6C;
  __int128 v23 = unk_1000FFF7C;
  *(_OWORD *)int v16 = *(_OWORD *)"<Unknown>";
  __int128 v17 = unk_1000FFF1C;
  __int128 v18 = xmmword_1000FFF2C;
  __int128 v19 = unk_1000FFF3C;
  v2 = (const __CFDictionary *)_CFCopySystemVersionDictionary();
  if (!v2) {
    goto LABEL_10;
  }
  uint64_t v8 = v2;
  Value = (const __CFString *)CFDictionaryGetValue(v2, _kCFSystemVersionProductNameKey);
  char v10 = (const __CFString *)CFDictionaryGetValue(v8, _kCFSystemVersionProductVersionKey);
  char v11 = (const __CFString *)CFDictionaryGetValue(v8, _kCFSystemVersionBuildVersionKey);
  if (Value) {
    CFStringGetCString(Value, (char *)buffer, 256LL, 0x8000100u);
  }
  if (v10) {
    CFStringGetCString(v10, (char *)v32, 256LL, 0x8000100u);
  }
  if (v11 && CFStringGetCString(v11, v16, 256LL, 0x8000100u)) {
    sscanf(v16, "%d%c%d", (char *)&v15 + 4, &v14, &v15);
  }
  CFRelease(v8);
  if (!HIDWORD(v15))
  {
LABEL_10:
    HIDWORD(v15) = 13;
    LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "Note: No Major Build Version number found; assuming 13",
      v3,
      v4,
      v5,
      v6,
      v7,
      v13);
  }

  if (a1) {
    mDNS_snprintf(a1);
  }
  if ((buffer[0] & 0xDF) == 0x4D) {
    int v12 = &OSXVers;
  }
  else {
    int v12 = &iOSVers;
  }
  int *v12 = HIDWORD(v15);
}

unint64_t mDNSPlatformRawTime( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (mDNSPlatformClockDivisor)
  {
    uint64_t v13 = mach_absolute_time();
    if ((uint64_t)(v13 - mDNSPlatformRawTime_last_mach_absolute_time) < 0)
    {
      LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "mDNSPlatformRawTime: last_mach_absolute_time %08X%08X",  v8,  v9,  v10,  v11,  v12,  mDNSPlatformRawTime_last_mach_absolute_time);
      LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "mDNSPlatformRawTime: this_mach_absolute_time %08X%08X",  v14,  v15,  v16,  v17,  v18,  v13);
      mDNSPlatformRawTime_last_mach_absolute_time = v13;
      NotifyOfElusiveBug( (int)"mach_absolute_time went backwards!",  (int)"This error occurs from time to time, often on newly released hardware, and usually the exact cause is diffe rent in each instance.\r\rPlease file a new Radar bug report with the title “mach_absolute_time went backwa rds” and assign it to Radar Component “Kernel” Version “X”.",  v19,  v20,  v21,  v22,  v23,  v24);
    }

    mDNSPlatformRawTime_last_mach_absolute_time = v13;
    return v13 / mDNSPlatformClockDivisor;
  }

  else
  {
    LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "mDNSPlatformRawTime called before mDNSPlatformTimeInit",  a4,  a5,  a6,  a7,  a8,  v26);
    return 0LL;
  }

uint64_t mDNS_snprintf(void *a1)
{
  return mDNS_vsnprintf(a1);
}

void GetUserSpecifiedLocalHostName(_BYTE *a1)
{
  v2 = SCDynamicStoreCopyLocalHostName(0LL);
  if (v2)
  {
    uint64_t v3 = v2;
    mDNSDomainLabelFromCFString(v2, a1);
    CFRelease(v3);
  }

uint64_t SetupSocket(void *a1, unsigned __int16 a2, int a3, _WORD *a4)
{
  if (a3 == 2) {
    uint64_t v8 = 2LL;
  }
  else {
    uint64_t v8 = 6LL;
  }
  int v83 = 1;
  int v81 = 0;
  int v82 = 255;
  if (a3 == 2) {
    uint64_t v9 = 3LL;
  }
  else {
    uint64_t v9 = 7LL;
  }
  if (a3 == 2) {
    uint64_t v10 = a1 + 3;
  }
  else {
    uint64_t v10 = a1 + 7;
  }
  a1[10] = 0LL;
  uint64_t v11 = socket(a3, 2, 17);
  uint64_t v12 = v11;
  if ((int)v11 <= 2)
  {
    if (*__error() != 47)
    {
      uint64_t v13 = (os_log_s *)mDNSLogCategory_Default;
      __error();
      uint64_t v14 = __error();
      strerror(*v14);
      LogMsgWithLevel( v13,  OS_LOG_TYPE_DEFAULT,  "SetupSocket: socket error %d errno %d (%s)",  v15,  v16,  v17,  v18,  v19,  v12);
    }

    return v12;
  }

  *(_DWORD *)int v84 = 900;
  setsockopt(v11, 0xFFFF, 4230, v84, 4u);
  if (a2 != 59668)
  {
    if (a2 != 58900) {
      goto LABEL_31;
    }
    int v21 = setsockopt(v12, 0xFFFF, 512, &v83, 4u);
    if ((v21 & 0x80000000) == 0)
    {
      int v32 = 1;
      goto LABEL_32;
    }

LABEL_27:
    unsigned int v33 = v21;
    v34 = "setsockopt - SO_REUSEPORT";
    goto LABEL_73;
  }

  int v20 = setsockopt(v12, 0xFFFF, 4356, &v83, 4u);
  if (v20 < 0)
  {
    unsigned int v33 = v20;
    v34 = "setsockopt - SO_RECV_ANYIF";
    goto LABEL_73;
  }

  int v21 = setsockopt(v12, 0xFFFF, 512, &v83, 4u);
  if (v21 < 0) {
    goto LABEL_27;
  }
  *(_DWORD *)int v84 = 1;
  if (setsockopt(v12, 0xFFFF, 0x10000, v84, 4u) == -1 && mDNS_LoggingEnabled)
  {
    uint64_t v22 = (os_log_s *)mDNSLogCategory_Default;
    uint64_t v23 = __error();
    int v24 = strerror(*v23);
    LogMsgWithLevel(v22, OS_LOG_TYPE_DEFAULT, "SetupSocket: SO_NOWAKEFROMSLEEP failed %s", v25, v26, v27, v28, v29, v24);
  }

  *(_OWORD *)int v84 = xmmword_1001008C0;
  if (!setsockopt(v12, 0xFFFF, 4360, v84, 0x10u)) {
    goto LABEL_31;
  }
  int v30 = *__error();
  __int128 v31 = (os_log_s *)mDNSLogCategory_Default;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
  {
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_ERROR))
    {
LABEL_30:
      int v35 = strerror(v30);
      *(_DWORD *)buf = 136446210;
      v87 = v35;
      _os_log_impl( (void *)&_mh_execute_header,  v31,  OS_LOG_TYPE_ERROR,  "SetupSocket: Attributing mDNS traffic to com.apple.datausage.dns.multicast failed: %{public}s",  buf,  0xCu);
    }
  }

  else
  {
    __int128 v31 = (os_log_s *)mDNSLogCategory_Default_redacted;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_ERROR)) {
      goto LABEL_30;
    }
  }

  uint64_t v17 = *(unsigned __int16 *)(a1 + 4);
  __int128 v31 = 141558787;
  int v32 = 1752392040LL;
  unsigned int v33 = 1040;
  v34 = v16;
  int v35 = 2101;
  int v36 = v11;
  int v37 = 1024;
  int v38 = v17;
  _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "internal_start_advertising_service - name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P, rrtype: %{mdns:rrtype}d",  (uint8_t *)&v31,  0x22u);
LABEL_28:
  uint64_t v18 = *(_WORD *)(a1 + 4);
  uint64_t v19 = putDomainNameAsLabels( (unint64_t)&compression_base_msg,  (unint64_t)&unk_100149887,  (unint64_t)&compression_base_msg + &unk_1000022F8,  (unsigned __int8 *)v39,  v7,  v8,  v9,  v10);
  if (v19)
  {
    unsigned __int8 *v19 = HIBYTE(v18);
    v19[1] = v18;
    v19[2] = 1;
    int v24 = v19 + 3;
  }

  else
  {
    int v24 = 0LL;
  }

  __int128 v31 = 0;
  uint64_t v25 = putRData( (unint64_t)&compression_base_msg,  v24,  (unint64_t)&compression_base_msg + &unk_1000022F8,  a1,  v20,  v21,  v22,  v23);
  uint64_t v26 = v25 - v24;
  PrintHelper( (uint64_t)"internal_start_advertising_service",  (uint64_t)&unk_100149887,  (unsigned __int16)((_WORD)v24 - (unsigned __int16)&unk_100149887),  (uint64_t)v24,  (unsigned __int16)((_WORD)v25 - (_WORD)v24));
  uint64_t result = xD2DMapToTransportType(*(void *)(a1 + 24), a2, &v31);
  if ((_DWORD)result == 4)
  {
    uint64_t v28 = 0LL;
    uint64_t v29 = v31;
    do
    {
      if (v29 != (_DWORD)v28 && &_D2DStartAdvertisingPairOnTransport)
      {
        if ((v28 & 0x7FFFFFFE) == 2) {
          _mdns_powerlog_awdl_event( (uint64_t)@"startAWDLAdvertise",  (unsigned __int8 *)v39,  *(unsigned __int16 *)(a1 + 4),  a3);
        }
        uint64_t result = D2DStartAdvertisingPairOnTransport(&unk_100149887, v24 - (char *)&unk_100149887, v24, v26, v28);
      }

      uint64_t v28 = (v28 + 1);
    }

    while ((_DWORD)v28 != 4);
  }

  else if (&_D2DStartAdvertisingPairOnTransport)
  {
    int v30 = result;
    if ((result & 6) == 2) {
      _mdns_powerlog_awdl_event( (uint64_t)@"startAWDLAdvertise",  (unsigned __int8 *)v39,  *(unsigned __int16 *)(a1 + 4),  a3);
    }
    return D2DStartAdvertisingPairOnTransport(&unk_100149887, v24 - (char *)&unk_100149887, v24, v26, v30);
  }

  return result;
}

  os_release(v7);
LABEL_28:
  _Block_object_dispose(&v19, 8);
  return v8;
}

  KQueueUnlock((uint64_t)"discovery_proxy_start_handler", v17, v18, v19, v20, v21, v22, v23);
  return v41;
}

    for (i = a1[2]; i; i = *(void *)(i + 16))
    {
      if (*(void **)(i + 24) == a1) {
        LogMcastClientInfo(i);
      }
    }
  }

  else if (mDNS_McastLoggingEnabled)
  {
    LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "No operation yet on this socket",  a4,  a5,  a6,  a7,  a8,  a9);
  }

    uint64_t v14 = DNSTypeName(*(unsigned __int16 *)(a2 + 322));
    v16[0] = 67110403;
    v16[1] = v7;
    uint64_t v17 = 2160;
    uint64_t v18 = 1752392040LL;
    uint64_t v19 = 1040;
    int v20 = v13;
    int v21 = 2101;
    uint64_t v22 = a2 + 356;
    uint64_t v23 = 2082;
    int v24 = v14;
    uint64_t v25 = 1024;
    uint64_t v26 = started;
    _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "[R%u] ERROR: QueryRecordOpStartQuestion mDNS_StartQuery for %{sensitive, mask.hash, mdnsresponder:domain_name}.*P %{public}s failed with error %d",  (uint8_t *)v16,  0x32u);
    goto LABEL_28;
  }

  return started;
}

LABEL_31:
  int v32 = 0;
LABEL_32:
  if (a3 == 2)
  {
    int v36 = setsockopt(v12, 0, 7, &v83, 4u);
    if (v36 < 0)
    {
      unsigned int v33 = v36;
      v34 = "setsockopt - IP_RECVDSTADDR";
    }

    else
    {
      int v37 = setsockopt(v12, 0, 20, &v83, 4u);
      if (v37 < 0)
      {
        unsigned int v33 = v37;
        v34 = "setsockopt - IP_RECVIF";
      }

      else
      {
        int v38 = setsockopt(v12, 0, 24, &v83, 4u);
        if (v38 < 0)
        {
          unsigned int v33 = v38;
          v34 = "setsockopt - IP_RECVTTL";
        }

        else
        {
          int v39 = setsockopt(v12, 0, 4, &v82, 4u);
          if (v39 < 0)
          {
            unsigned int v33 = v39;
            v34 = "setsockopt - IP_TTL";
          }

          else
          {
            int v40 = setsockopt(v12, 0, 10, &v82, 4u);
            if ((v40 & 0x80000000) == 0)
            {
              *(void *)int v84 = 512LL;
              *(void *)&v84[8] = 0LL;
              *(_WORD *)&v84[2] = a2;
              if (v32) {
                int v41 = 16777440;
              }
              else {
                int v41 = 0;
              }
              *(_DWORD *)&v84[4] = v41;
              int v42 = v12;
              socklen_t v43 = 16;
LABEL_42:
              int v44 = bind(v42, (const sockaddr *)v84, v43);
              if (v44)
              {
                unsigned int v33 = v44;
                v34 = "bind";
                goto LABEL_73;
              }

              if (a4) {
                *a4 = *(_WORD *)&v84[2];
              }
              goto LABEL_67;
            }

            unsigned int v33 = v40;
            v34 = "setsockopt - IP_MULTICAST_TTL";
          }
        }
      }
    }
  }

  else
  {
    if (a3 != 30)
    {
LABEL_67:
      int v61 = fcntl(v12, 3, 0LL, v78, v79, v80);
      fcntl(v12, 4, v61 | 4u);
      fcntl(v12, 2, 1LL);
      LODWORD(a1[v8]) = v12;
      a1[v9] = myKQSocketCallBack;
      v10[1] = a1;
      v10[2] = "UDP packet reception";
      KQueueSet(v12, 1u, -1, v10);
      return 0LL;
    }

    if (v32)
    {
      if (a4) {
        *a4 = 0;
      }
      close(v12);
      return 0LL;
    }

    int v45 = setsockopt(v12, 41, 61, &v83, 4u);
    if (v45 < 0)
    {
      unsigned int v33 = v45;
      v34 = "setsockopt - IPV6_RECVPKTINFO";
    }

    else
    {
      int v46 = setsockopt(v12, 41, 37, &v83, 4u);
      if (v46 < 0)
      {
        unsigned int v33 = v46;
        v34 = "setsockopt - IPV6_RECVHOPLIMIT";
      }

      else
      {
        int v47 = setsockopt(v12, 41, 27, &v83, 4u);
        if (v47 < 0)
        {
          unsigned int v33 = v47;
          v34 = "setsockopt - IPV6_V6ONLY";
        }

        else
        {
          int v48 = setsockopt(v12, 41, 4, &v82, 4u);
          if (v48 < 0)
          {
            unsigned int v33 = v48;
            v34 = "setsockopt - IPV6_UNICAST_HOPS";
          }

          else
          {
            int v49 = setsockopt(v12, 41, 10, &v82, 4u);
            if (v49 < 0)
            {
              unsigned int v33 = v49;
              v34 = "setsockopt - IPV6_MULTICAST_HOPS";
            }

            else
            {
              int v50 = setsockopt(v12, 41, 11, &v83, 4u);
              if ((v50 & 0x80000000) == 0)
              {
                uint64_t v51 = setsockopt(v12, 41, 42, &v81, 4u);
                if ((v51 & 0x80000000) != 0)
                {
                  uint64_t v52 = v51;
                  unint64_t v53 = (os_log_s *)mDNSLogCategory_Default;
                  uint64_t v54 = *__error();
                  int v55 = __error();
                  uint64_t v79 = v54;
                  uint64_t v80 = strerror(*v55);
                  uint64_t v78 = v52;
                  LogMsgWithLevel( v53,  OS_LOG_TYPE_DEFAULT,  "SetupSocket: setsockopt - IPV6_USE_MIN_MTU: IP6PO_MINMTU_DISABLE socket %d err %d errno %d (%s)",  v56,  v57,  v58,  v59,  v60,  v12);
                }

                *(_WORD *)int v84 = 7708;
                *(_WORD *)&v84[2] = a2;
                *(_DWORD *)&v84[4] = 0;
                *(in6_addr *)&v84[8] = in6addr_any;
                int v85 = 0;
                int v42 = v12;
                socklen_t v43 = 28;
                goto LABEL_42;
              }

              unsigned int v33 = v50;
              v34 = "setsockopt - IPV6_MULTICAST_LOOP";
            }
          }
        }
      }
    }
  }

        int v21 = v14[4];
        if (v21) {
          uint64_t v22 = v21 == v18;
        }
        else {
          uint64_t v22 = 1;
        }
        if (v22)
        {
          uint64_t v23 = *((_WORD *)v14 + 179);
          if (v15[2840] == 1)
          {
            int v24 = mDNSLogCategory_Default;
            uint64_t v25 = *((_DWORD *)v14 + 91);
            GetRRDisplayString_rdb((unsigned __int8 *)v14 + 8, (unsigned __int16 *)(v14[6] + 4), v16);
            uint64_t v8 = a1;
            uint64_t v26 = (os_log_s *)v24;
            uint64_t v15 = (_BYTE *)&unk_100158000;
            LogMsgWithLevel( v26,  OS_LOG_TYPE_DEFAULT,  "RetrySPSRegistrations: 0x%x 0x%x (updateid %d) %s",  v27,  v28,  v29,  v30,  v31,  v25);
            uint64_t v23 = *((_WORD *)v14 + 179);
          }

          SendSPSRegistration(v8, v17, v23, (uint64_t)a4, a5, a6, a7, a8);
        }

  int v32 = 141558531;
  unsigned int v33 = 1752392040LL;
  v34 = 1040;
  int v35 = v16;
  int v36 = 2101;
  int v37 = a2;
  _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "external_start_resolving_service - fqdn: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P",  (uint8_t *)&v32,  0x1Cu);
LABEL_32:
  int v20 = putDomainNameAsLabels( (unint64_t)compression_base_msg,  (unint64_t)byte_100149887,  (unint64_t)&compression_base_msg[&unk_1000022F8],  (unsigned __int8 *)v38,  v11,  v12,  v13,  v14);
  if (v20)
  {
    *(_WORD *)int v20 = 3072;
    v20[2] = 1;
    uint64_t v25 = (unint64_t)(v20 + 3);
  }

  else
  {
    uint64_t v25 = 0LL;
  }

  int v32 = 0;
  uint64_t v26 = putDomainNameAsLabels( (unint64_t)compression_base_msg,  v25,  (unint64_t)&compression_base_msg[&unk_1000022F8],  a2,  v21,  v22,  v23,  v24);
  uint64_t v27 = &v26[-v25];
  PrintHelper( (uint64_t)"external_start_resolving_service",  (uint64_t)byte_100149887,  (unsigned __int16)(v25 - (unsigned __int16)byte_100149887),  v25,  (unsigned __int16)((_WORD)v26 - v25));
  uint64_t result = xD2DMapToTransportType(a1, a3, &v32);
  if ((_DWORD)result == 4)
  {
    uint64_t v29 = 0LL;
    int v30 = v32;
    do
    {
      if (v30 != (_DWORD)v29 && &_D2DStartResolvingPairOnTransport)
      {
        if ((v29 & 0x7FFFFFFE) == 2) {
          _mdns_powerlog_awdl_event((uint64_t)@"startAWDLResolve", (unsigned __int8 *)v38, 12, a4);
        }
        uint64_t result = D2DStartResolvingPairOnTransport(byte_100149887, v25 - (void)byte_100149887, v25, v27, v29);
      }

      uint64_t v29 = (v29 + 1);
    }

    while ((_DWORD)v29 != 4);
  }

  else if (&_D2DStartResolvingPairOnTransport)
  {
    __int128 v31 = result;
    if ((result & 6) == 2) {
      _mdns_powerlog_awdl_event((uint64_t)@"startAWDLResolve", (unsigned __int8 *)v38, 12, a4);
    }
    return D2DStartResolvingPairOnTransport(byte_100149887, v25 - (void)byte_100149887, v25, v27, v31);
  }

  return result;
}

    if (v10)
    {
      for (i = *(void *)(a1 + 12664); i; i = *(void *)i)
      {
        if (*(_BYTE *)(i + 6374)) {
          AdvertiseInterfaceIfNeeded((_DWORD *)a1, i);
        }
      }
    }
  }

        free(v1);
        nw_release(v7);
        return;
      }
    }

    else
    {
      __break(1u);
    }

    free(v1);
  }

          free(v21);
          goto LABEL_41;
        }
      }
    }

    if (_mdns_resolver_log_s_once != -1) {
      dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_48);
    }
    int v45 = _mdns_resolver_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_DEFAULT))
    {
      int v46 = *(_DWORD *)(a1 + 208);
      int v47 = *(void *)(a2 + 32);
      int v48 = *(void *)(*(void *)(a1 + 88) + 32LL);
      unsigned int v91 = 136448258;
      v92 = v10;
      int v93 = 2048;
      uint64_t v94 = v11;
      v95 = 1024;
      int v96 = v46;
      int v97 = 2112;
      v98 = v47;
      v99 = 1024;
      int v100 = v14;
      v101 = 2082;
      int v102 = interface_log_string;
      unsigned int v103 = 1040;
      *(_DWORD *)unsigned int v104 = v11;
      *(_WORD *)&v104[4] = 2098;
      *(void *)&v104[6] = v48;
      *(_WORD *)&v104[14] = 2112;
      *(void *)&v104[16] = v16;
      int v42 = "%{public}sSent %zu-byte query #%u to %@ over %{mdns:protocol}d via %{public}s -- %{public,mdns:dnshdr}.*P, %@";
      socklen_t v43 = (os_log_s *)v45;
      int v44 = 80;
      goto LABEL_40;
    }
  }

  else
  {
    uint64_t v17 = *(void *)(v16 + 32);
    if (*(_BYTE *)(a1 + 255))
    {
      uint64_t v18 = (void *)(v16 + 16);
      while (1)
      {
        uint64_t v18 = (void *)*v18;
        if (!v18) {
          break;
        }
        uint64_t v19 = (uint64_t (*)(void, void, uint64_t))v18[3];
        if (v19)
        {
          int v20 = v19(*(void *)(a1 + 88), 0LL, 1LL);
          if (!v20) {
            break;
          }
          int v21 = (void *)v20;
          if (_mdns_resolver_log_s_once != -1) {
            dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_48);
          }
          uint64_t v22 = _mdns_resolver_log_s_log;
          if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v23 = *v8;
            int v24 = *(void *)(a2 + 32);
            uint64_t v25 = bswap32(*(_DWORD *)v17);
            uint64_t v26 = bswap64(*(void *)(v17 + 4));
            unsigned int v91 = 136448258;
            v92 = v10;
            int v93 = 2048;
            uint64_t v94 = v11;
            v95 = 1024;
            int v96 = v23;
            int v97 = 2112;
            v98 = v24;
            v99 = 1024;
            int v100 = v14;
            v101 = 2082;
            int v102 = interface_log_string;
            unsigned int v103 = 2048;
            *(void *)unsigned int v104 = v25;
            *(_WORD *)&v104[8] = 2048;
            *(void *)&v104[10] = v26;
            *(_WORD *)&v104[18] = 2082;
            *(void *)&v104[20] = v21;
            uint64_t v27 = "%{public}sSent %zu-byte query #%u to %@ over %{mdns:protocol}d via %{public}s -- %{mdns:dns.idflags}08"
                  "lX, counts: %{mdns:dns.counts}016llX, %{public}s";
            uint64_t v28 = (os_log_s *)v22;
            uint64_t v29 = 84;
            goto LABEL_30;
          }

          goto LABEL_31;
        }
      }
    }

    if (_mdns_resolver_log_s_once != -1) {
      dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_48);
    }
    int v37 = _mdns_resolver_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_DEFAULT))
    {
      int v38 = *v8;
      int v39 = *(void *)(a2 + 32);
      int v40 = bswap32(*(_DWORD *)v17);
      int v41 = bswap64(*(void *)(v17 + 4));
      unsigned int v91 = 136448258;
      v92 = v10;
      int v93 = 2048;
      uint64_t v94 = v11;
      v95 = 1024;
      int v96 = v38;
      int v97 = 2112;
      v98 = v39;
      v99 = 1024;
      int v100 = v14;
      v101 = 2082;
      int v102 = interface_log_string;
      unsigned int v103 = 2048;
      *(void *)unsigned int v104 = v40;
      *(_WORD *)&v104[8] = 2048;
      *(void *)&v104[10] = v41;
      *(_WORD *)&v104[18] = 2112;
      *(void *)&v104[20] = v16;
      int v42 = "%{public}sSent %zu-byte query #%u to %@ over %{mdns:protocol}d via %{public}s -- %{mdns:dns.idflags}08lX, co"
            "unts: %{mdns:dns.counts}016llX, %@";
      socklen_t v43 = (os_log_s *)v37;
      int v44 = 84;
LABEL_40:
      _os_log_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_DEFAULT, v42, (uint8_t *)&v91, v44);
    }
  }

  _mdns_resolver_start_pending_queriers(a1);
}

  __int128 v31 = 0;
LABEL_32:
  memset(buf, 0, sizeof(buf));
  int v40 = 0u;
  int v41 = 0u;
  memset(v43, 0, sizeof(v43));
  int v42 = 0u;
  *(_DWORD *)buf = *a2;
  *(void *)&buf[8] = &v44;
  *(_WORD *)&buf[18] = 1;
  *(void *)&buf[24] = v24;
  *(void *)&int v40 = __PAIR64__(v22, v23);
  BYTE8(v40) = v31;
  HIDWORD(v40) = a2[7];
  *(void *)&int v41 = *((void *)a2 + 4);
  DWORD2(v41) = a2[10];
  int v32 = *((void *)a2 + 7);
  *(void *)&int v42 = *((void *)a2 + 6);
  *((void *)&v42 + 1) = v32;
  LODWORD(v43[0]) = a2[16];
  *(_OWORD *)((char *)v43 + 8) = *(_OWORD *)(a2 + 18);
  BYTE12(v41) = *((_BYTE *)a2 + 88);
  WORD4(v43[1]) = *(_WORD *)((char *)a2 + 89);
  unsigned int v33 = *(_DWORD *)(a1 + 8);
  if ((v33 & 2) != 0)
  {
    v34 = calloc(1uLL, 0x2F8uLL);
    if (v34)
    {
      *(void *)(a1 + 24) = v34;
      *(_WORD *)&buf[16] = 28;
      RecordOpStart = QueryRecordOpStart((uint64_t)v34, (uint64_t)buf, a3, a4);
      if (!(_DWORD)RecordOpStart)
      {
        unsigned int v33 = *(_DWORD *)(a1 + 8);
        goto LABEL_36;
      }

      goto LABEL_40;
    }

  uint64_t v29 = dispatch_data_create(v32, v19, 0LL, 0LL);
  if (!v29) {
    return 4294960568LL;
  }
  int v30 = v29;
  int v20 = _mdns_message_set_msg_data((void *)a1, v29);
  dispatch_release(v30);
  if (!(_DWORD)v20) {
    *(_BYTE *)(a1 + 70) |= 0x20u;
  }
  return v20;
}

LABEL_73:
  int v62 = *__error();
  if (strcmp(v34, "bind") || !a2 || a2 == 59668)
  {
    char v63 = (os_log_s *)mDNSLogCategory_Default;
    strerror(v62);
    LogMsgWithLevel( v63,  OS_LOG_TYPE_DEFAULT,  "%s skt %d port %d error %d errno %d (%s)",  v64,  v65,  v66,  v67,  v68,  (int)v34);
  }

  BOOL v75 = !strcmp(v34, "bind") && v62 == 48;
  if (v75) {
    uint64_t v76 = 48LL;
  }
  else {
    uint64_t v76 = v33;
  }
  if (v75 && a2 == 59668)
  {
    NotifyOfElusiveBug( (int)"Setsockopt SO_REUSEPORT failed",  (int)"Congratulations, you've reproduced an elusive bug.\rPlease contact the current assignee of <rdar://problem/38 14904>.\rAlternatively, you can send email to radar-3387020@group.apple.com. (Note number is different.)\rIf possible, please leave your machine undisturbed so that someone can come to investigate the problem.",  v69,  v70,  v71,  v72,  v73,  v74);
    uint64_t v76 = 48LL;
  }

  close(v12);
  return v76;
}

      __break(1u);
LABEL_74:
      dispatch_once(&_dns_push_discovery_interface_monitor_queue_s_once, &__block_literal_global_2208);
LABEL_43:
      mdns_interface_monitor_set_queue(v15, (dispatch_object_t)_dns_push_discovery_interface_monitor_queue_s_queue);
      os_retain((void *)v15);
      aBlock[0] = _NSConcreteStackBlock;
      aBlock[1] = 0x40000000LL;
      aBlock[2] = ___dns_push_discovery_start_mdns_interface_monitor_block_invoke;
      aBlock[3] = &__block_descriptor_tmp_2209;
      aBlock[4] = v15;
      mdns_interface_monitor_set_event_handler(v15, aBlock);
      v38[0] = _NSConcreteStackBlock;
      v38[1] = 0x40000000LL;
      v38[2] = ___dns_push_discovery_start_mdns_interface_monitor_block_invoke_2;
      v38[3] = &__block_descriptor_tmp_3_2210;
      v38[4] = v15;
      mdns_interface_monitor_set_update_handler(v15, v38);
      if (!*(_BYTE *)(v15 + 154))
      {
        if (*(void *)(v15 + 32)) {
          _mdns_interface_monitor_activate_async((void *)v15);
        }
        *(_BYTE *)(v15 + 154) = 1;
      }

      *uint64_t v4 = v15;
      os_retain((void *)v15);
      __int128 v31 = &g_interface_monitors;
      do
      {
        int v32 = v31;
        unsigned int v33 = *v31;
        __int128 v31 = (uint64_t *)(*v31 + 16);
      }

      while (v33);
      *int v32 = (uint64_t)v4;
      ++v4[1];
      if (v15)
      {
LABEL_52:
        dns_push_obj_context_set_interface_monitor(v8, (void *)v15);
        if (!mDNS_StartQuery((unsigned int *)a1, v5))
        {
          os_release((void *)v15);
          *(void *)(v8 + 48) = v5;
          if (!v12)
          {
LABEL_59:
            if (!v13) {
              return;
            }
            goto LABEL_60;
          }

              *(_DWORD *)buf = 67110915;
              uint64_t v58 = v30;
              uint64_t v59 = 2160;
              *(void *)uint64_t v60 = 1752392040LL;
              *(_WORD *)&v60[8] = 1040;
              *(_DWORD *)&v60[10] = v21;
              int v61 = 2101;
              *(void *)int v62 = v22;
              *(_WORD *)&v62[8] = 2160;
              *(void *)&v62[10] = 1752392040LL;
              *(_WORD *)&v62[18] = 1040;
              char v63 = v31;
              uint64_t v64 = 2101;
              uint64_t v65 = v32;
              uint64_t v66 = 1024;
              uint64_t v67 = v12;
              _os_log_impl( (void *)&_mh_execute_header,  v20,  OS_LOG_TYPE_INFO,  "[Q%u] New validation key requestor replaces the old one - new name: %{sensitive, mask.hash, mdnsresponde r:domain_name}.*P, old name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P, qtype: %{mdns:rrtype}d",  buf,  0x42u);
            }
          }

          else if (os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC, OS_LOG_TYPE_INFO))
          {
            if (v6)
            {
              int v21 = *(_DWORD *)(v6 + 24);
              uint64_t v22 = *(void *)(v6 + 16);
            }

            else
            {
              int v21 = 0;
              uint64_t v22 = 0LL;
            }

            int v30 = *(unsigned __int16 *)(v1 + 24);
            if (v17)
            {
              __int128 v31 = *((_DWORD *)v17 + 6);
              int v32 = *((void *)v17 + 2);
            }

            else
            {
              __int128 v31 = 0;
              int v32 = 0LL;
            }

            goto LABEL_73;
          }

          _dnssec_obj_validation_manager_reset_validation_key_requestor(v1);
LABEL_75:
          if (v12 != 43) {
            goto LABEL_99;
          }
          unsigned int v33 = **(unsigned __int8 **)(v6 + 16);
          v34 = *(_DWORD *)(a1 + 48);
          int v35 = *(void **)(v1 + 120);
          if (!v35)
          {
            int v36 = *(void *)(a1 + 56);
            if (v36)
            {
              *(void *)(v1 + 128) = 0LL;
              int v37 = (void *)(v36 + 16);
              do
              {
                int v37 = (void *)*v37;
                if (!v37)
                {
                  int v35 = 0LL;
                  int v42 = -6727;
LABEL_90:
                  int v55 = v42;
                  *(void *)(v1 + 120) = v35;
                  *(_DWORD *)(v1 + 140) = 0;
                  *(_BYTE *)(v1 + 144) = 0;
                  goto LABEL_91;
                }
              }

              while (ref_count_obj_compare(*(void *)(*(void *)(v37[2] + 16LL) + 16LL), v6, 1LL));
              int v38 = 0LL;
              int v39 = v37;
              do
              {
                ++v38;
                int v39 = (void *)v39[1];
              }

              while (v39);
              if (v38)
              {
                if (!(v38 >> 61))
                {
                  int v35 = calloc(v38, 8uLL);
                  if (v35)
                  {
                    int v40 = *(void *)(v1 + 128);
                    do
                    {
                      int v41 = (_DWORD *)v37[2];
                      v35[v40] = v41;
                      ++*v41;
                      ++v40;
                      int v37 = (void *)v37[1];
                    }

                    while (v37);
                    int v42 = 0;
                    *(void *)(v1 + 128) = v40;
                    goto LABEL_90;
                  }
                }
              }

              __break(1u);
LABEL_133:
              uint64_t v51 = (os_log_s *)mDNSLogCategory_DNSSEC;
              if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_DNSSEC == mDNSLogCategory_State)
              {
                if (os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC, OS_LOG_TYPE_ERROR))
                {
                  uint64_t v52 = *(unsigned __int16 *)(v1 + 24);
                  if (v6)
                  {
                    unint64_t v53 = *(_DWORD *)(v6 + 24);
                    uint64_t v54 = *(void *)(v6 + 16);
                  }

                  else
                  {
                    unint64_t v53 = 0;
                    uint64_t v54 = 0LL;
                  }

                  goto LABEL_143;
                }
              }

              else
              {
                uint64_t v51 = (os_log_s *)mDNSLogCategory_DNSSEC_redacted;
                if (os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC_redacted, OS_LOG_TYPE_ERROR))
                {
                  uint64_t v52 = *(unsigned __int16 *)(v1 + 24);
                  if (v6)
                  {
                    unint64_t v53 = *(_DWORD *)(v6 + 24);
                    uint64_t v54 = *(void *)(v6 + 16);
                  }

                  else
                  {
                    unint64_t v53 = 0;
                    uint64_t v54 = 0LL;
                  }

BOOL SystemWakeForNetworkAccess( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int valuePtr = 0;
  if (DisableSleepProxyClient == 1)
  {
    if (mDNS_LoggingEnabled == 1) {
      LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "SystemWakeForNetworkAccess: Sleep Proxy Client disabled by command-line option",  a4,  a5,  a6,  a7,  a8,  v25);
    }
    return 0LL;
  }

  uint64_t v8 = (const __CFDictionary *)SCDynamicStoreCopyValue(0LL, @"State:/IOKit/PowerManagement/CurrentSettings");
  if (v8)
  {
    uint64_t v14 = v8;
    Value = (const __CFNumber *)CFDictionaryGetValue(v8, @"Wake On LAN");
    if (!Value
      || (uint64_t v16 = Value, v17 = CFGetTypeID(Value), v17 != CFNumberGetTypeID())
      || !CFNumberGetValue(v16, kCFNumberSInt32Type, &valuePtr))
    {
      int valuePtr = 0;
    }

    CFRelease(v14);
    BOOL v23 = valuePtr != 0;
  }

  else
  {
    if (mDNS_LoggingEnabled != 1) {
      return 0LL;
    }
    LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "GetCurrentPMSetting: Could not get IOPM CurrentSettings dict",  v9,  v10,  v11,  v12,  v13,  v25);
    BOOL v23 = 0LL;
  }

  if (mDNS_LoggingEnabled == 1) {
    LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "SystemWakeForNetworkAccess: Wake On LAN: %d",  v18,  v19,  v20,  v21,  v22,  v23);
  }
  return v23;
}

void UpdateInterfaceList(int a1)
{
  uint64_t v1 = myGetIfAddrs_ifa;
  if (!myGetIfAddrs_ifa)
  {
    getifaddrs((ifaddrs **)&myGetIfAddrs_ifa);
    uint64_t v1 = myGetIfAddrs_ifa;
  }

  memset(v223, 0, sizeof(v223));
  int v2 = socket(30, 2, 0);
  uint64_t v3 = &unk_100164000;
  if (v2 <= 2 && *__error() != 47)
  {
    uint64_t v4 = (os_log_s *)mDNSLogCategory_Default;
    uint64_t v5 = *__error();
    uint64_t v6 = __error();
    uint64_t v201 = v5;
    v202 = strerror(*v6);
    LogMsgWithLevel( v4,  OS_LOG_TYPE_DEFAULT,  "UpdateInterfaceList: InfoSocket error %d errno %d (%s)",  v7,  v8,  v9,  v10,  v11,  v2);
  }

  if (byte_100158C45 != 2 && v1 != 0)
  {
    do
    {
      if (!*(void *)(v1 + 24)) {
        goto LABEL_97;
      }
      uint64_t v16 = *(const char **)(v1 + 8);
      if (!strncmp(v16, "llw", 3uLL))
      {
        uint64_t v30 = mDNSLogCategory_State;
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEBUG))
        {
          nameEncoding[0] = 136446210;
          *(void *)&nameEncoding[1] = v16;
          uint64_t v26 = (uint8_t *)nameEncoding;
          uint64_t v27 = (os_log_s *)v30;
          os_log_type_t v28 = OS_LOG_TYPE_DEBUG;
          uint64_t v29 = "isExcludedInterface: excluding %{public}s";
          goto LABEL_30;
        }

        goto LABEL_97;
      }

      if (v2 < 0)
      {
        uint64_t v32 = mDNSLogCategory_State;
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEBUG))
        {
          nameEncoding[0] = 67109120;
          nameEncoding[1] = v2;
          unsigned int v33 = (os_log_s *)v32;
          v34 = "isExcludedInterface: invalid socket FD passed: %d";
LABEL_36:
          _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEBUG, v34, (uint8_t *)nameEncoding, 8u);
        }
      }

      else
      {
        memset(buf, 0, 32);
        if (!v16) {
          goto LABEL_267;
        }
        uint64_t v17 = 0LL;
        while (1)
        {
          int v18 = v16[v17];
          buf[v17] = v18;
          if (!v18) {
            break;
          }
          if (++v17 == 15)
          {
            buf[15] = 0;
            break;
          }
        }

        if (ioctl(v2, 0xC02069ADuLL, buf, v201, v202, v203, v204, v205) == -1)
        {
          int v35 = __error();
          uint64_t v36 = mDNSLogCategory_State;
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEBUG))
          {
            CFStringEncoding v37 = *v35;
            nameEncoding[0] = 67109120;
            nameEncoding[1] = v37;
            unsigned int v33 = (os_log_s *)v36;
            v34 = "isExcludedInterface: SIOCGIFFUNCTIONALTYPE failed -- error: %{darwin.errno}d";
            goto LABEL_36;
          }
        }

        else if (*(_DWORD *)&buf[16] == 6)
        {
          uint64_t v25 = mDNSLogCategory_State;
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEBUG))
          {
            nameEncoding[0] = 136446210;
            *(void *)&nameEncoding[1] = v16;
            uint64_t v26 = (uint8_t *)nameEncoding;
            uint64_t v27 = (os_log_s *)v25;
            os_log_type_t v28 = OS_LOG_TYPE_DEBUG;
            uint64_t v29 = "isExcludedInterface: excluding coprocessor interface %{public}s";
LABEL_30:
            uint32_t v31 = 12;
LABEL_31:
            _os_log_impl((void *)&_mh_execute_header, v27, v28, v29, v26, v31);
            goto LABEL_97;
          }

          goto LABEL_97;
        }
      }

      uint64_t v38 = *(void *)(v1 + 24);
      if (*(_BYTE *)(v38 + 1) != 18) {
        goto LABEL_80;
      }
      if (*(_BYTE *)(v38 + 4) == 6)
      {
        BOOL v39 = *(_BYTE *)(v38 + 6) == 6 && (unsigned __int16)dword_100158BD0 == 0;
        BOOL v40 = v39 && HIWORD(dword_100158BD0) == 0;
        if (v40 && word_100158BD4 == 0)
        {
          uint64_t v42 = v38 + *(unsigned __int8 *)(v38 + 5);
          int v43 = *(_DWORD *)(v42 + 8);
          word_100158BD4 = *(_WORD *)(v42 + 12);
          dword_100158BD0 = v43;
        }
      }

      if ((getExtendedFlags(*(void *)(v1 + 8)) & 0x100000) == 0 || AWDLInterfaceID && WiFiAwareInterfaceID) {
        goto LABEL_80;
      }
      *(void *)nameEncoding = @"IOInterfaceName";
      *(void *)&__int128 values = 0LL;
      *(void *)&__int128 values = CFStringCreateWithCString(kCFAllocatorDefault, *(const char **)(v1 + 8), 0x8000100u);
      *(void *)v226 = 0LL;
      *(void *)v226 = CFDictionaryCreate( kCFAllocatorDefault,  (const void **)nameEncoding,  (const void **)&values,  1LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
      *(void *)nameEncoding = @"IOPropertyMatch";
      int v44 = CFDictionaryCreate( kCFAllocatorDefault,  (const void **)nameEncoding,  (const void **)v226,  1LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
      io_service_t MatchingService = IOServiceGetMatchingService(kIOMainPortDefault, v44);
      if ((void)values)
      {
        CFRelease((CFTypeRef)values);
        *(void *)&__int128 values = 0LL;
      }

      if (*(void *)v226)
      {
        CFRelease(*(CFTypeRef *)v226);
        *(void *)v226 = 0LL;
      }

      if (MatchingService)
      {
        CFProperty = (const __CFString *)IORegistryEntryCreateCFProperty( MatchingService,  @"IO80211VirtualInterfaceRole",  kCFAllocatorDefault,  0);
        if (CFProperty)
        {
          int v47 = CFProperty;
          CFTypeID v48 = CFGetTypeID(CFProperty);
          if (v48 == CFStringGetTypeID())
          {
            if (!AWDLInterfaceID && CFStringCompare(v47, @"AirLink", 0LL) == kCFCompareEqualTo)
            {
              *(void *)v211 = *(unsigned __int16 *)(v38 + 2);
              AWDLInterfaceID = *(void *)v211;
              int v49 = (os_log_s *)mDNSLogCategory_Default;
              if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
              {
                if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
                  goto LABEL_68;
                }
              }

              else
              {
                int v49 = (os_log_s *)mDNSLogCategory_Default_redacted;
                if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
                {
LABEL_68:
                  *(_DWORD *)buf = 134217984;
                  *(void *)&uint8_t buf[4] = *(void *)v211;
                  _os_log_impl( (void *)&_mh_execute_header,  v49,  OS_LOG_TYPE_DEFAULT,  "UpdateInterfaceList: AWDLInterfaceID = %lu",  buf,  0xCu);
                }
              }
            }

            if (!WiFiAwareInterfaceID
              && CFStringCompare(v47, @"WiFi-Aware Discovery+Data", 0LL) == kCFCompareEqualTo)
            {
              uint64_t v50 = *(unsigned __int16 *)(v38 + 2);
              WiFiAwareInterfaceID = v50;
              uint64_t v51 = (os_log_s *)mDNSLogCategory_Default;
              if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
              {
                if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
                  goto LABEL_76;
                }
              }

              else
              {
                uint64_t v51 = (os_log_s *)mDNSLogCategory_Default_redacted;
                if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
                {
LABEL_76:
                  *(_DWORD *)buf = 134217984;
                  *(void *)&uint8_t buf[4] = v50;
                  _os_log_impl( (void *)&_mh_execute_header,  v51,  OS_LOG_TYPE_DEFAULT,  "UpdateInterfaceList: WiFiAwareInstanceID = %lu",  buf,  0xCu);
                }
              }
            }
          }

          CFRelease(v47);
        }

        IOObjectRelease(MatchingService);
      }

      uint64_t v3 = &unk_100164000;
LABEL_80:
      if ((*(_BYTE *)(v1 + 16) & 1) == 0) {
        goto LABEL_97;
      }
      uint64_t v52 = *(void *)(v1 + 24);
      int v53 = *(unsigned __int8 *)(v52 + 1);
      if (v53 != 30 && v53 != 2) {
        goto LABEL_97;
      }
      uint64_t v55 = *(void *)(v1 + 32);
      if (!v55)
      {
        memset(buf, 0, 20);
        SetupAddr((uint64_t)buf, v52, v19, v20, v21, v22, v23, v24);
        uint64_t v65 = (os_log_s *)*((void *)v3 + 170);
        uint64_t v66 = *(const char **)(v1 + 8);
        uint64_t v67 = if_nametoindex(v66);
        v203 = (CFStringEncoding *)*(unsigned __int8 *)(*(void *)(v1 + 24) + 1LL);
        v204 = buf;
        uint64_t v201 = v67;
        v202 = (char *)*(unsigned int *)(v1 + 16);
        LogMsgWithLevel( v65,  OS_LOG_TYPE_DEFAULT,  "UpdateInterfaceList: ifa_netmask is NULL for %5s(%d) Flags %04X Family %2d %#a",  v68,  v69,  v70,  v71,  v72,  (int)v66);
        goto LABEL_97;
      }

      int v56 = *(unsigned __int8 *)(v55 + 1);
      if (v56 != v53 && v56)
      {
        memset(buf, 0, 20);
        SetupAddr((uint64_t)buf, v52, v19, v20, v21, v22, v23, v24);
        uint64_t v57 = (os_log_s *)*((void *)v3 + 170);
        uint64_t v58 = *(const char **)(v1 + 8);
        uint64_t v59 = if_nametoindex(v58);
        v204 = buf;
        uint64_t v205 = *(unsigned __int8 *)(*(void *)(v1 + 32) + 1LL);
        v202 = (char *)*(unsigned int *)(v1 + 16);
        v203 = (CFStringEncoding *)*(unsigned __int8 *)(*(void *)(v1 + 24) + 1LL);
        uint64_t v201 = v59;
        LogMsgWithLevel( v57,  OS_LOG_TYPE_DEFAULT,  "UpdateInterfaceList: ifa_netmask for %5s(%d) Flags %04X Family %2d %#a has different family: %d",  v60,  v61,  v62,  v63,  v64,  (int)v58);
        goto LABEL_97;
      }

      if ((int)if_nametoindex(*(const char **)(v1 + 8)) <= 0)
      {
        uint64_t v76 = (os_log_s *)*((void *)v3 + 170);
        uint64_t v77 = *(const char **)(v1 + 8);
        uint64_t v201 = if_nametoindex(v77);
        LogMsgWithLevel( v76,  OS_LOG_TYPE_DEFAULT,  "UpdateInterfaceList: if_nametoindex returned zero/negative value for %5s(%d)",  v78,  v79,  v80,  v81,  v82,  (int)v77);
        goto LABEL_97;
      }

      uint64_t v73 = *(__int128 **)(v1 + 24);
      uint64_t v74 = *(void *)(v1 + 32);
      int v75 = *((unsigned __int8 *)v73 + 1);
      *(_BYTE *)(v74 + 1) = v75;
      if (v75 == 30)
      {
        if ((v2 & 0x80000000) == 0)
        {
          memset(v222, 0, sizeof(v222));
          __int128 v221 = 0u;
          memset(buf, 0, sizeof(buf));
          uint64_t v83 = *(void *)(v1 + 8);
          if (!v83) {
            goto LABEL_267;
          }
          uint64_t v84 = 0LL;
          while (1)
          {
            int v85 = *(unsigned __int8 *)(v83 + v84);
            buf[v84] = v85;
            if (!v85) {
              break;
            }
            if (++v84 == 15)
            {
              buf[15] = 0;
              break;
            }
          }

          __int128 v86 = *v73;
          *(_OWORD *)&buf[28] = *(__int128 *)((char *)v73 + 12);
          *(_OWORD *)&buf[16] = v86;
          if (ioctl(v2, 0xC1206949uLL, buf) != -1 && (buf[16] & 0x9A) != 0) {
            goto LABEL_97;
          }
        }
      }

      else if (v75 == 2 && *(_DWORD *)(v74 + 4) == -1)
      {
        goto LABEL_97;
      }

      uint64_t v87 = if_nametoindex(*(const char **)(v1 + 8));
      uint64_t v88 = *(void *)(v1 + 8);
      *(_WORD *)&uint8_t buf[4] = 0;
      *(_DWORD *)buf = 0;
      int v89 = CFStringCreateWithFormat(0LL, 0LL, @"State:/Network/Interface/%s/AirPort", v88);
      if (v89)
      {
        int v90 = v89;
        unsigned int v91 = (const __CFDictionary *)SCDynamicStoreCopyValue(0LL, v89);
        if (v91)
        {
          v92 = v91;
          Value = (const __CFData *)CFDictionaryGetValue(v91, @"BSSID");
          if (Value)
          {
            uint64_t v94 = Value;
            if (CFDataGetLength(Value) == 6)
            {
              v227.location = 0LL;
              v227.length = 6LL;
              CFDataGetBytes(v94, v227, buf);
            }
          }

          CFRelease(v92);
          uint64_t v3 = &unk_100164000;
        }

        CFRelease(v90);
      }

      *(void *)v212 = *(unsigned __int16 *)&buf[4];
      uint64_t v95 = *(unsigned int *)buf;
      int ExtendedFlags = getExtendedFlags(*(void *)(v1 + 8));
      memset(nameEncoding, 0, sizeof(nameEncoding));
      LODWORD(v217) = 0;
      __int128 values = 0uLL;
      int v225 = 0;
      if (SetupAddr((uint64_t)nameEncoding, *(void *)(v1 + 24), v97, v98, v99, v100, v101, v102)
        || SetupAddr((uint64_t)&values, *(void *)(v1 + 32), v103, v104, v105, v106, v107, v108))
      {
        goto LABEL_97;
      }

      unint64_t v109 = v95 | (*(void *)v212 << 32);
      int v206 = ExtendedFlags;
      os_log_t log = (os_log_t)(v109 >> 16);
      uint64_t v110 = mDNSStorage[0];
      uint64_t v111 = *(void *)mDNSStorage[0];
      if (!*(void *)mDNSStorage[0])
      {
LABEL_124:
        v112 = (char *)calloc(1uLL, 0x1958uLL);
        if (!v112
          || (v118 = v112,
              *((void *)v112 + 782) = v87,
              *(_OWORD *)(v112 + 6264) = *(_OWORD *)nameEncoding,
              *((_DWORD *)v112 + 1570) = v217,
              *(_OWORD *)(v112 + 6284) = values,
              *((_DWORD *)v112 + 1575) = v225,
              (v119 = *(unsigned __int8 **)(v1 + 8)) == 0LL))
        {
LABEL_267:
          __break(1u);
        }

        v120 = v112 + 6310;
        uint64_t v121 = 64LL;
        v122 = v112 + 6310;
        while (1)
        {
          int v123 = *v119;
          _BYTE *v122 = v123;
          if (!v123) {
            break;
          }
          ++v122;
          ++v119;
          if ((unint64_t)--v121 <= 1)
          {
            _BYTE *v122 = 0;
            break;
          }
        }

        v112[6373] = 0;
        if (byte_100158BC6)
        {
          int v124 = (*(unsigned __int8 *)(v1 + 16) >> 3) & 1;
          char v125 = v124;
        }

        else
        {
          char v125 = byte_100158BC5;
          int v124 = (*(unsigned __int8 *)(v1 + 16) >> 3) & 1;
        }

        v112[6374] = v125;
        v112[6377] = v124;
        v112[6378] = (v206 & 0x800) == 0LL;
        uint64_t v210 = (uint64_t)v112;
        if ((v206 & 0x20100000) != 0 || (int v126 = strncmp(v112 + 6310, "p2p", 3uLL), v118 = (char *)v210, !v126))
        {
          v120[70] = 1;
          if (mDNS_LoggingEnabled == 1)
          {
            LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "AddInterfaceToList: DirectLink set for %s",  v113,  v114,  v115,  v116,  v117,  *(void *)(v1 + 8));
            v118 = (char *)v210;
          }
        }

        else
        {
          v120[70] = 0;
        }

        *((void *)v118 + 798) = 0LL;
        *((void *)v118 + 799) = mDNSStorage;
        BOOL v127 = 1;
        *((_WORD *)v120 + 45) = 1;
        v120[92] = 0;
        if ((v206 & 0x20000) == 0)
        {
          int v128 = strncmp(v120, "p2p", 3uLL);
          v118 = (char *)v210;
          BOOL v127 = v128 == 0;
        }

        v120[93] = v127;
        if (v127 && mDNS_LoggingEnabled)
        {
          LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "AddInterfaceToList: D2DInterface set for %s",  v113,  v114,  v115,  v116,  v117,  *(void *)(v1 + 8));
          v118 = (char *)v210;
        }

        v120[146] = (unint64_t)(v206 & 0x100000) >> 20;
        v120[71] = (v206 & 0x100000) == 0;
        *((_DWORD *)v118 + 1601) = a1;
        *((_DWORD *)v118 + 1602) = a1;
        *((_DWORD *)v118 + 1604) = *(_DWORD *)(v1 + 16);
        *((_DWORD *)v118 + 1606) = v87;
        *((_WORD *)v118 + 3214) = v95;
        *((_WORD *)v118 + 3215) = (_WORD)log;
        *((_WORD *)v118 + 3216) = v212[0];
        *((_WORD *)v118 + 3217) = *(unsigned __int8 *)(*(void *)(v1 + 24) + 1LL);
        *((void *)v118 + 810) = 0LL;
        *(_OWORD *)(v120 + 126) = xmmword_100100820;
        int v129 = socket(2, 2, 0);
        if (v129 != -1)
        {
          uint64_t v130 = 0LL;
          memset(buf, 0, 32);
          while (1)
          {
            int v131 = v120[v130];
            buf[v130] = v131;
            if (!v131) {
              break;
            }
            if (++v130 == 15)
            {
              buf[15] = 0;
              break;
            }
          }

          int v213 = v129;
          if (ioctl(v129, 0xC020699FuLL, buf) != -1)
          {
            int v132 = *(_DWORD *)&buf[20];
            *(_DWORD *)(v210 + 6448) = *(_DWORD *)&buf[24];
            goto LABEL_166;
          }

          if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
          {
            loga = (os_log_s *)mDNSLogCategory_Default;
            int v132 = 0;
            if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_165;
            }
          }

          else
          {
            loga = (os_log_s *)mDNSLogCategory_Default_redacted;
            BOOL v137 = os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT);
            int v132 = 0;
            if (v137)
            {
LABEL_165:
              v138 = __error();
              v139 = strerror(*v138);
              *(_DWORD *)v226 = 136446210;
              *(void *)&v226[4] = v139;
              _os_log_impl( (void *)&_mh_execute_header,  loga,  OS_LOG_TYPE_DEFAULT,  "GetIFTFamily: SIOCGIFTYPE failed: %{public}s",  v226,  0xCu);
              int v132 = 0;
            }
          }

LABEL_166:
          close(v213);
LABEL_167:
          *(_DWORD *)(v210 + 6412) = v132;
          int v140 = socket(30, 2, 0);
          *(void *)v214 = v87;
          if (v140 == -1)
          {
            int v149 = 0;
          }

          else
          {
            int v146 = v140;
            uint64_t v147 = 0LL;
            memset(buf, 0, 32);
            while (1)
            {
              int v148 = v120[v147];
              buf[v147] = v148;
              if (!v148) {
                break;
              }
              if (++v147 == 15)
              {
                buf[15] = 0;
                break;
              }
            }

            if (ioctl(v140, 0xC02069ADuLL, buf) == -1) {
              int v149 = 0;
            }
            else {
              int v149 = *(_DWORD *)&buf[16];
            }
            close(v146);
          }

          uint64_t v150 = v210;
          *(_DWORD *)(v210 + 6452) = v149;
          char v151 = *(_BYTE *)(*(void *)(v210 + 6392) + 120LL);
          if (v151) {
            char v151 = (*(_DWORD *)(v210 + 6416) & 0x8000) != 0 && (*(_DWORD *)(v210 + 6416) & 0x10) == 0;
          }
          uint64_t v152 = *(void *)v214;
          v120[65] = v151;
          if ((v206 & 0x4000) != 0)
          {
            BOOL v153 = 0;
          }

          else
          {
            BOOL v153 = NetWakeInterface(v210);
            uint64_t v150 = v210;
          }

          v120[66] = v153;
          uint64_t v154 = v150 + 6304;
          v155 = (void *)myGetIfAddrs_ifa;
          if (myGetIfAddrs_ifa
            || (getifaddrs((ifaddrs **)&myGetIfAddrs_ifa),
                v155 = (void *)myGetIfAddrs_ifa,
                uint64_t v150 = v210,
                uint64_t v152 = *(void *)v214,
                myGetIfAddrs_ifa))
          {
            while (1)
            {
              uint64_t v156 = v155[3];
              if (v156)
              {
              }

              v155 = (void *)*v155;
              if (!v155) {
                goto LABEL_190;
              }
            }

            uint64_t v157 = v156 + *(unsigned __int8 *)(v156 + 5);
            int v158 = *(_DWORD *)(v157 + 8);
            *(_WORD *)(v154 + 4) = *(_WORD *)(v157 + 12);
            *(_DWORD *)uint64_t v154 = v158;
          }

          else
          {
LABEL_190:
            *(_WORD *)(v154 + 4) = 0;
            *(_DWORD *)uint64_t v154 = 0;
          }

          if (v120[66] && !*(_DWORD *)v154)
          {
            v202 = v120;
            v203 = nameEncoding;
            uint64_t v201 = v152;
            LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "AddInterfaceToList: Bad MAC address %.6a for %d %s %#a",  v141,  v142,  v143,  v144,  v145,  v154);
            uint64_t v150 = v210;
          }

          if (*(_DWORD *)(v150 + 6412) == 2 && *(_DWORD *)(v150 + 6448) == 1) {
            v120[72] = 1;
          }
          if (v120[65] && !v120[67] && *(_DWORD *)(v150 + 6452) == 3)
          {
            v159 = *(void **)(v150 + 8);
            uint64_t v160 = v150;
            if (v159)
            {
              os_release(v159);
              *(void *)(v160 + 8) = 0LL;
            }

            *(void *)(v160 + 8) = mdns_multicast_delay_histogram_create();
            uint64_t v150 = v160;
          }

          *(void *)uint64_t v110 = v150;
          uint64_t v3 = &unk_100164000;
          goto LABEL_97;
        }

        v133 = (os_log_s *)mDNSLogCategory_Default;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
        {
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_ERROR)) {
            goto LABEL_162;
          }
        }

        else
        {
          v133 = (os_log_s *)mDNSLogCategory_Default_redacted;
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_ERROR))
          {
LABEL_162:
            v135 = __error();
            v136 = strerror(*v135);
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = v136;
            _os_log_impl( (void *)&_mh_execute_header,  v133,  OS_LOG_TYPE_ERROR,  "GetIFTFamily: socket() failed: %{public}s",  buf,  0xCu);
          }
        }

        int v132 = 0;
        goto LABEL_167;
      }

      unint64_t v209 = HIDWORD(v109);
      while ((_DWORD)v87 != *(_DWORD *)(v111 + 6424)
           || !mDNSSameAddress((int *)nameEncoding, (_DWORD *)(v111 + 6264))
           || *(unsigned __int16 *)(v111 + 6428) != (unsigned __int16)v95
           || *(unsigned __int16 *)(v111 + 6430) != (unsigned __int16)log
           || (_DWORD)v209 != *(unsigned __int16 *)(v111 + 6432))
      {
        uint64_t v110 = v111 + 6384;
        uint64_t v111 = *(void *)(v111 + 6384);
        if (!v111) {
          goto LABEL_124;
        }
      }

      v161 = (_BYTE *)(v111 + 6310);
      if (*(_BYTE *)(v111 + 6400))
      {
        uint64_t v3 = &unk_100164000;
        uint64_t v162 = mDNSLogCategory_Default;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
        {
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_97;
          }
        }

        else
        {
          uint64_t v162 = mDNSLogCategory_Default_redacted;
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_97;
          }
        }

        uint64_t v168 = *(void *)(v1 + 8);
        *(_DWORD *)buf = 136446979;
        *(void *)&uint8_t buf[4] = v168;
        *(_WORD *)&buf[12] = 2160;
        *(void *)&buf[14] = 1752392040LL;
        *(_WORD *)&buf[22] = 1045;
        *(_DWORD *)&buf[24] = 20;
        *(_WORD *)&buf[28] = 2101;
        *(void *)&buf[30] = nameEncoding;
        uint64_t v26 = buf;
        uint64_t v27 = (os_log_s *)v162;
        os_log_type_t v28 = OS_LOG_TYPE_DEFAULT;
        uint64_t v29 = "Ignoring attempt to re-add interface (%{public}s, %{sensitive, mask.hash, mdnsresponder:ip_addr}.20P) alre"
              "ady marked as existing";
        uint32_t v31 = 38;
        goto LABEL_31;
      }

      v163 = *(unsigned __int8 **)(v1 + 8);
      uint64_t v3 = &unk_100164000;
      if (!v163) {
        goto LABEL_267;
      }
      uint64_t v164 = 64LL;
      while (1)
      {
        int v165 = *v163;
        _BYTE *v161 = v165;
        if (!v165) {
          break;
        }
        ++v161;
        ++v163;
        if ((unint64_t)--v164 <= 1)
        {
          _BYTE *v161 = 0;
          break;
        }
      }

      uint64_t v166 = *(void *)v110;
      if (*(_BYTE *)(*(void *)(*(void *)v110 + 6392LL) + 120LL))
      {
        int v167 = (*(_DWORD *)(v166 + 6416) & 0x10) == 0;
        if ((*(_DWORD *)(v166 + 6416) & 0x8000) == 0) {
          int v167 = 0;
        }
      }

      else
      {
        int v167 = 0;
      }

      if (*(unsigned __int8 *)(v166 + 6375) == v167)
      {
        char v169 = 1;
      }

      else
      {
        *(_BYTE *)(v166 + 6375) = v167;
        char v169 = 2;
      }

      *(_BYTE *)(v166 + 6400) = v169;
      if (*(_DWORD *)(v166 + 6408) != a1) {
        *(_DWORD *)(v166 + 6404) = a1;
      }
      int v170 = NetWakeInterface(v166);
      uint64_t v171 = *(void *)v110;
      v172 = (_BYTE *)(*(void *)v110 + 6376LL);
      if (*v172 != v170)
      {
        int v173 = v170;
        _BYTE *v172 = v170;
        if (*(void *)(v171 + 6480))
        {
          mDNS_Lock_((unsigned int *)mDNSStorage, (uint64_t)"AddInterfaceToList", 3913);
          v174 = *(__int128 **)v110;
          if (v173) {
            mDNS_ActivateNetWake_internal((uint64_t)v174);
          }
          else {
            mDNS_DeactivateNetWake_internal(v174);
          }
          mDNS_Unlock_((uint64_t)mDNSStorage, (uint64_t)"AddInterfaceToList", 3916);
          uint64_t v171 = *(void *)v110;
        }
      }

      *(_BYTE *)(v171 + 6378) = (v206 & 0x800) == 0LL;
      if (*(_BYTE *)(v171 + 6375)
        && !*(_BYTE *)(v171 + 6377)
        && *(_DWORD *)(v171 + 6452) == 3
        && !*(void *)(v171 + 8))
      {
        *(void *)(*(void *)v110 + 8LL) = mdns_multicast_delay_histogram_create();
      }

  uint64_t v76 = *(void *)(a2 + 40);
  uint64_t v77 = (_BYTE *)v76;
  if (v76 != -256LL)
  {
LABEL_167:
LABEL_177:
    uint64_t v16 = 4294901747LL;
    uint64_t v15 = mDNSLogCategory_State;
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT)) {
      return v16;
    }
    GetRRDisplayString_rdb( (unsigned __int8 *)(a2 + 8),  (unsigned __int16 *)(*(void *)(a2 + 48) + 4LL),  (_BYTE *)(a1 + 46976));
    *(_DWORD *)buf = 141558275;
    *(void *)&uint8_t buf[4] = 1752392040LL;
    *(_WORD *)&buf[12] = 2085;
    *(void *)&buf[14] = a1 + 46976;
    uint64_t v17 = "Attempt to register record with invalid name: %{sensitive, mask.hash}s";
    goto LABEL_24;
  }

  while (1)
  {
LABEL_168:
    if (!v77) {
      goto LABEL_177;
    }
    uint64_t v78 = *v77;
    if (!*v77) {
      break;
    }
    v77 += v78 + 1;
    if (v76 != -256LL) {
      goto LABEL_167;
    }
  }

  uint64_t v79 = *(void *)(a2 + 48);
  if (!ValidateRData(*(unsigned __int16 *)(a2 + 12), *(unsigned __int16 *)(a2 + 20), (_BYTE *)v79))
  {
    uint64_t v16 = 4294901747LL;
    uint64_t v81 = mDNSLogCategory_State;
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT)) {
      return v16;
    }
    uint64_t v82 = (_BYTE *)(a1 + 46976);
    GetRRDisplayString_rdb(v13, (unsigned __int16 *)(v79 + 4), v82);
    *(_DWORD *)buf = 141558275;
    *(void *)&uint8_t buf[4] = 1752392040LL;
    *(_WORD *)&buf[12] = 2085;
    *(void *)&buf[14] = v82;
    uint64_t v17 = "Attempt to register record with invalid rdata: %{sensitive, mask.hash}s";
    uint64_t v19 = (os_log_s *)v81;
    goto LABEL_25;
  }

  *(_DWORD *)(a2 + 24) = DomainNameHashValue(v76);
  if (v10) {
    uint64_t v80 = DomainNameHashValue((unint64_t)v10);
  }
  else {
    uint64_t v80 = RDataHashValue(a2 + 8);
  }
  *(_DWORD *)(a2 + 28) = v80;
  if ((*(_DWORD *)(a2 + 172) & 0xFFFFFFFE) == 4
    && (*v13 & 0x32) != 0
    && CheckAuthRecordConflict(a1 + 6272, a2))
  {
    uint64_t v83 = mDNSLogCategory_State;
    uint64_t v16 = 4294901748LL;
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT)) {
      return v16;
    }
    uint64_t v84 = (_BYTE *)(a1 + 46976);
    GetRRDisplayString_rdb((unsigned __int8 *)(a2 + 8), (unsigned __int16 *)(*(void *)(a2 + 48) + 4LL), v84);
    int v85 = *(void *)(a2 + 32);
    *(_DWORD *)buf = 141558787;
    *(void *)&uint8_t buf[4] = 1752392040LL;
    *(_WORD *)&buf[12] = 2085;
    *(void *)&buf[14] = v84;
    *(_WORD *)&buf[22] = 2048;
    *(void *)&buf[24] = a2;
    *(_WORD *)&buf[32] = 2048;
    *(void *)&buf[34] = v85;
    uint64_t v17 = "mDNS_Register_internal: Name conflict %{sensitive, mask.hash}s (%p), InterfaceID %p";
    uint64_t v19 = (os_log_s *)v83;
    uint64_t v20 = 42;
    goto LABEL_26;
  }

  if (!*(void *)(a2 + 32) && !*(_BYTE *)(a2 + 122) && !IsLocalDomain(*(_BYTE **)(a2 + 40)))
  {
    if (!*(void *)(a1 + 12640)) {
      *(void *)(a1 + 12640) = a2;
    }
    do
    {
      char v125 = v25;
      uint64_t v25 = (uint64_t *)*v25;
    }

    while (v25);
    *char v125 = a2;
    if (*(_BYTE *)(a2 + 8) == 2) {
      *uint64_t v13 = 16;
    }
    uint64_t v16 = 0LL;
    *(_WORD *)(a2 + 189) = 0;
    *(_BYTE *)(a2 + 191) = 0;
    if (*(_DWORD *)(a2 + 344) == 8) {
      return v16;
    }
    ActivateUnicastRegistration(a1, a2);
    return 0LL;
  }

  if ((*(_DWORD *)(a2 + 172) & 0xFFFFFFFE) == 4)
  {
    *(_WORD *)(a2 + 189) = 0;
    *(_BYTE *)(a2 + 191) = 0;
    __int128 v86 = CheckAuthIdenticalRecord(a1 + 6272, a2);
    uint64_t v87 = *(unsigned __int8 **)(a2 + 40);
    unsigned int v91 = mDNS_DomainNameFNV1aHash(v87);
    if (v86) {
      goto LABEL_192;
    }
    goto LABEL_213;
  }

  __int128 v86 = *v21;
  if (!*v21)
  {
LABEL_212:
    uint64_t v87 = *(unsigned __int8 **)(a2 + 40);
    unsigned int v91 = mDNS_DomainNameFNV1aHash(v87);
LABEL_213:
    uint64_t v100 = *(unsigned __int16 *)(a2 + 20);
    if (v100 >= 0x201)
    {
      uint64_t result = (uint64_t)malloc(*(unsigned __int16 *)(a2 + 20));
      uint64_t v101 = (void *)result;
      uint64_t v102 = (char *)result;
      if (!result) {
        goto LABEL_340;
      }
    }

    else
    {
      if (!*(_WORD *)(a2 + 20))
      {
        uint64_t v114 = (os_log_s *)mDNSLogCategory_State;
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT))
        {
          if (v87)
          {
            uint64_t v115 = v87;
LABEL_229:
            uint64_t v116 = 257;
            if (v115 < v87 + 256 && v115)
            {
              while (1)
              {
                uint64_t v117 = *v115;
                if (v117 > 0x3F)
                {
LABEL_306:
                  uint64_t v116 = 257;
                  goto LABEL_309;
                }

                if (!*v115) {
                  break;
                }
                v115 += v117 + 1;
LABEL_232:
                if (!v115) {
                  goto LABEL_306;
                }
              }

              uint64_t v116 = (unsigned __int16)((_WORD)v115 - (_WORD)v87 + 1);
            }
          }

          else
          {
            uint64_t v116 = 0;
          }

LABEL_97:
      uint64_t v1 = *(void *)v1;
    }

    while (v1);
  }

  if ((v2 & 0x80000000) == 0) {
    close(v2);
  }
  mDNS_snprintf(v223);
  __int128 v221 = 0u;
  memset(buf, 0, sizeof(buf));
  nameEncoding[0] = 134217984;
  uint64_t v13 = SCDynamicStoreCopyComputerName(0LL, nameEncoding);
  if (v13)
  {
    uint64_t v14 = v13;
    mDNSDomainLabelFromCFString(v13, buf);
    CFRelease(v14);
    uint64_t v15 = (void *)&unk_100158000;
    if (buf[0]) {
      goto LABEL_247;
    }
  }

  else
  {
    uint64_t v15 = &unk_100158000;
  }

  v175 = &buf[1];
  uint8_t v176 = v223[0];
  if (LOBYTE(v223[0]))
  {
    v177 = (unsigned __int8 *)v223 + 1;
    do
    {
      *v175++ = v176;
      int v178 = *v177++;
      uint8_t v176 = v178;
      if (v178) {
        BOOL v179 = v175 >= (uint8_t *)v222;
      }
      else {
        BOOL v179 = 1;
      }
    }

    while (!v179);
  }

  buf[0] = (_BYTE)v175 + ~buf;
LABEL_247:
  __int128 v218 = 0u;
  __int128 v219 = 0u;
  *(_OWORD *)nameEncoding = 0u;
  __int128 v217 = 0u;
  GetUserSpecifiedLocalHostName(nameEncoding);
  unsigned int v185 = LOBYTE(nameEncoding[0]);
  if (!LOBYTE(nameEncoding[0]))
  {
    v186 = (char *)nameEncoding + 1;
    char v187 = v223[0];
    if (LOBYTE(v223[0]))
    {
      v188 = (unsigned __int8 *)v223 + 1;
      do
      {
        *v186++ = v187;
        int v189 = *v188++;
        char v187 = v189;
        if (v189) {
          BOOL v190 = v186 >= (char *)buf;
        }
        else {
          BOOL v190 = 1;
        }
      }

      while (!v190);
    }

    unsigned int v191 = (_DWORD)v186 + ~nameEncoding;
    unsigned int v185 = v191;
    LOBYTE(nameEncoding[0]) = v191;
  }

  uint64_t v192 = v15[375];
  size_t v193 = *(unsigned __int8 *)(v192 + 172);
  if (*(unsigned __int8 *)(v192 + 172) != buf[0] || memcmp((const void *)(v192 + 173), &buf[1], v193))
  {
    if ((_DWORD)v193)
    {
      LogMsgWithLevel( *((os_log_s **)v3 + 170),  OS_LOG_TYPE_DEFAULT,  "User updated Computer Name from “%#s” to “%#s”",  v180,  v181,  v182,  v183,  v184,  v192 + 172);
      uint64_t v192 = v15[375];
      unsigned int v185 = LOBYTE(nameEncoding[0]);
    }

    __int128 v194 = *(_OWORD *)&buf[16];
    xmmword_10015B3E8 = *(_OWORD *)buf;
    unk_10015B3F8 = *(_OWORD *)&buf[16];
    __int128 v195 = *(_OWORD *)&buf[32];
    __int128 v196 = v221;
    xmmword_10015B408 = *(_OWORD *)&buf[32];
    unk_10015B418 = v221;
    *(_OWORD *)(v192 + 172) = *(_OWORD *)buf;
    *(_OWORD *)(v192 + 188) = v194;
    *(_OWORD *)(v192 + 204) = v195;
    *(_OWORD *)(v192 + 220) = v196;
  }

  int v197 = *(unsigned __int8 *)(v192 + 108);
  if (v197 != v185 || memcmp((const void *)(v192 + 109), (char *)nameEncoding + 1, v185))
  {
    if (v197)
    {
      LogMsgWithLevel( *((os_log_s **)v3 + 170),  OS_LOG_TYPE_DEFAULT,  "User updated Local Hostname from “%#s” to “%#s”",  v180,  v181,  v182,  v183,  v184,  v192 + 108);
      uint64_t v192 = v15[375];
    }

    __int128 v198 = v217;
    xmmword_10015B428 = *(_OWORD *)nameEncoding;
    xmmword_10015B438 = v217;
    __int128 v199 = v218;
    __int128 v200 = v219;
    xmmword_10015B448 = v218;
    xmmword_10015B458 = v219;
    *(_OWORD *)(v192 + 108) = *(_OWORD *)nameEncoding;
    *(_OWORD *)(v192 + 124) = v198;
    *(_OWORD *)(v192 + 140) = v199;
    *(_OWORD *)(v192 + 156) = v200;
    mDNS_SetFQDN((uint64_t)mDNSStorage);
  }

    AdjustAddressRecordSetsEx(v1, 0);
    AdjustAddressRecordSetsEx(v1, 1);
    if (*(_BYTE *)(v1 + 6374)) {
      DeadvertiseInterface((uint64_t)mDNSStorage, v1, 3);
    }
    if (dword_100158C04) {
      int v43 = 0;
    }
    else {
      int v43 = v26;
    }
    if (v43 == 1)
    {
      for (n = 0LL; n != 499; ++n)
      {
        for (ii = (void *)mDNSStorage[n + 35]; ii; ii = (void *)*ii)
        {
          for (jj = (void *)ii[2]; jj; jj = (void *)*jj)
          {
            if (jj[4] == *(void *)(v1 + 6256)) {
              mDNS_Reconfirm_internal((uint64_t)mDNSStorage, (uint64_t)jj, 0x2710u);
            }
          }
        }
      }
    }

    mDNS_UpdateAllowSleep((uint64_t)mDNSStorage);
    uint64_t v30 = 17292;
LABEL_112:
    mDNS_Unlock_((uint64_t)mDNSStorage, (uint64_t)"mDNS_DeregisterInterface", v30);
    *(void *)(v1 + 6480) = 0LL;
LABEL_113:
    uint64_t v1 = *(void *)(v1 + 6384);
  }

  while (v1);
  int v47 = (uint64_t *)mDNSStorage[0];
  CFTypeID v48 = *(void *)mDNSStorage[0];
  if (*(void *)mDNSStorage[0])
  {
    uint64_t v71 = v2 - 1;
    while (2)
    {
      while (*(_BYTE *)(v48 + 6400))
      {
LABEL_132:
        int v47 = (uint64_t *)(v48 + 6384);
        CFTypeID v48 = *(void *)(v48 + 6384);
        if (!v48) {
          return;
        }
      }

      int v49 = *(_DWORD *)(v48 + 6408);
      if (v49 == v2)
      {
        int v49 = v71;
        *(_DWORD *)(v48 + 6408) = v71;
      }

      uint64_t v50 = v2 - v49;
      uint64_t v51 = (os_log_s *)*((void *)v3 + 171);
      uint64_t v52 = os_log_type_enabled(v51, OS_LOG_TYPE_DEFAULT);
      if (v50 < 60)
      {
        if (v52)
        {
          uint64_t v66 = *(_DWORD *)(v48 + 6424);
          uint64_t v67 = *(void *)(v48 + 6256);
          uint64_t v68 = CountMaskBits((int *)(v48 + 6284));
          uint64_t v69 = *(unsigned __int8 *)(v48 + 16);
          *(_DWORD *)buf = 136449283;
          *(void *)uint64_t v74 = v48 + 6310;
          int v2 = a1;
          *(_WORD *)&v74[8] = 1024;
          *(_DWORD *)&v74[10] = v66;
          uint64_t v3 = &unk_100164000;
          *(_WORD *)&v74[14] = 2160;
          *(void *)&v74[16] = 1752392040LL;
          int v75 = 1045;
          *(_DWORD *)uint64_t v76 = 6;
          *(_WORD *)&v76[4] = 2101;
          *(void *)&v76[6] = v48 + 6428;
          uint64_t v77 = 2048;
          uint64_t v78 = v67;
          uint64_t v79 = 2048;
          uint64_t v80 = v48;
          uint64_t v81 = 2160;
          uint64_t v82 = 1752392040LL;
          uint64_t v83 = 1045;
          *(_DWORD *)uint64_t v84 = 20;
          *(_WORD *)&v84[4] = 2101;
          *(void *)&v84[6] = v48 + 6264;
          int v85 = 1024;
          *(_DWORD *)__int128 v86 = v68;
          *(_WORD *)&v86[4] = 1024;
          *(_DWORD *)&v86[6] = v50;
          *(_WORD *)uint64_t v87 = 1024;
          *(_DWORD *)&v87[2] = v69;
          uint64_t v64 = v51;
          uint64_t v65 = "ClearInactiveInterfaces: Holding %{public}s(%u) %{sensitive, mask.hash, mdnsresponder:mac_addr}.6P Inter"
                "faceID %p(%p) %{sensitive, mask.hash, mdnsresponder:ip_addr}.20P/%d Age %d -- primary: %{mdns:yesno}d";
LABEL_124:
          _os_log_impl((void *)&_mh_execute_header, v64, OS_LOG_TYPE_DEFAULT, v65, buf, 0x6Cu);
        }
      }

      else if (v52)
      {
        uint64_t v60 = *(_DWORD *)(v48 + 6424);
        uint64_t v61 = *(void *)(v48 + 6256);
        uint64_t v62 = CountMaskBits((int *)(v48 + 6284));
        uint64_t v63 = *(unsigned __int8 *)(v48 + 16);
        *(_DWORD *)buf = 136449283;
        *(void *)uint64_t v74 = v48 + 6310;
        *(_WORD *)&v74[8] = 1024;
        *(_DWORD *)&v74[10] = v60;
        int v2 = a1;
        *(_WORD *)&v74[14] = 2160;
        *(void *)&v74[16] = 1752392040LL;
        int v75 = 1045;
        *(_DWORD *)uint64_t v76 = 6;
        *(_WORD *)&v76[4] = 2101;
        *(void *)&v76[6] = v48 + 6428;
        uint64_t v3 = &unk_100164000;
        uint64_t v77 = 2048;
        uint64_t v78 = v61;
        uint64_t v79 = 2048;
        uint64_t v80 = v48;
        uint64_t v81 = 2160;
        uint64_t v82 = 1752392040LL;
        uint64_t v83 = 1045;
        *(_DWORD *)uint64_t v84 = 20;
        *(_WORD *)&v84[4] = 2101;
        *(void *)&v84[6] = v48 + 6264;
        int v85 = 1024;
        *(_DWORD *)__int128 v86 = v62;
        *(_WORD *)&v86[4] = 1024;
        *(_DWORD *)&v86[6] = v50;
        *(_WORD *)uint64_t v87 = 1024;
        *(_DWORD *)&v87[2] = v63;
        uint64_t v64 = v51;
        uint64_t v65 = "ClearInactiveInterfaces: Deleting %{public}s(%u) %{sensitive, mask.hash, mdnsresponder:mac_addr}.6P Interf"
              "aceID %p(%p) %{sensitive, mask.hash, mdnsresponder:ip_addr}.20P/%d Age %d -- primary: %{mdns:yesno}d";
        goto LABEL_124;
      }

      if ((*(_DWORD *)(v48 + 6436) & 0x80000000) == 0) {
        CloseBPF(v48, v53, v54, v55, v56, v57, v58, v59);
      }
      if (v50 < 60) {
        goto LABEL_132;
      }
      CFStringRef v47 = *(void *)(v48 + 6384);
      uint64_t v70 = *(void **)(v48 + 8);
      if (v70) {
        os_release(v70);
      }
      free((void *)v48);
      CFTypeID v48 = *v47;
      if (!*v47) {
        return;
      }
      continue;
    }
  }

  int v41 = 136446979;
  uint64_t v42 = "automatic browse domain";
  int v43 = 2160;
  *(void *)int v44 = 1752392040LL;
  *(_WORD *)&v44[8] = 1040;
  *(_DWORD *)&v44[10] = v31;
  int v45 = 2101;
  *(void *)int v46 = a2;
  _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "Starting the %{public}s enumeration - domain: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P.",  (uint8_t *)&v41,  0x26u);
LABEL_98:
  uint64_t result = mDNS_GetDomains_Internal( (uint64_t)a1,  (uint64_t)(v4 + 2),  2,  (char *)a2,  0LL,  (uint64_t)FoundNonLocalOnlyAutomaticBrowseDomain,  0LL);
  if (!(_DWORD)result) {
    goto LABEL_112;
  }
  return result;
}

          _dx_release((char *)v8);
          _dx_request_set_error((os_unfair_lock_s *)a1, 0xFFFEFFFD);
          return;
        }

uint64_t myGetIfAddrs()
{
  if (myGetIfAddrs_ifa)
  {
    freeifaddrs((ifaddrs *)myGetIfAddrs_ifa);
    myGetIfAddrs_ifa = 0LL;
  }

  getifaddrs((ifaddrs **)&myGetIfAddrs_ifa);
  return myGetIfAddrs_ifa;
}

uint64_t SetupAddr( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a2)
  {
    uint64_t v9 = 4294901747LL;
    uint64_t v11 = (os_log_s *)mDNSLogCategory_Default;
    uint64_t v12 = "SetupAddr ERROR: NULL sockaddr";
    goto LABEL_10;
  }

  int v8 = *(unsigned __int8 *)(a2 + 1);
  if (v8 != 30)
  {
    if (v8 == 2)
    {
      uint64_t v9 = 0LL;
      int v10 = *(_DWORD *)(a2 + 4);
      *(_DWORD *)a1 = 4;
      *(_DWORD *)(a1 + 4) = v10;
      return v9;
    }

    uint64_t v9 = 4294901747LL;
    uint64_t v11 = (os_log_s *)mDNSLogCategory_Default;
    int v14 = *(unsigned __int8 *)(a2 + 1);
    uint64_t v12 = "SetupAddr invalid sa_family %d";
    LOBYTE(a2) = 0;
LABEL_10:
    LogMsgWithLevel(v11, (os_log_type_t)a2, v12, a4, a5, a6, a7, a8, v14);
    return v9;
  }

  *(_DWORD *)a1 = 6;
  *(_OWORD *)(a1 + 4) = *(_OWORD *)(a2 + 8);
  uint64_t v9 = 0LL;
  *(_WORD *)(a1 + 6) = 0;
  return v9;
}

BOOL NetWakeInterface(uint64_t a1)
{
  if (*(_BYTE *)(*(void *)(a1 + 6392) + 120LL)
    && (*(_DWORD *)(a1 + 6416) & 0x8018) == 0x8000
    && !*(_BYTE *)(a1 + 6403))
  {
    uint64_t v9 = a1 + 6310;
    if (!strcmp((const char *)(a1 + 6310), "ap1"))
    {
      uint64_t v11 = mDNSLogCategory_SPS;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_SPS == mDNSLogCategory_State)
      {
        BOOL v19 = os_log_type_enabled((os_log_t)mDNSLogCategory_SPS, OS_LOG_TYPE_DEFAULT);
        BOOL result = 0LL;
        if (!v19) {
          return result;
        }
        *(_DWORD *)buf = 136446210;
        *(void *)uint64_t v29 = v9;
        uint64_t v4 = "NetWakeInterface: returning false for %{public}s";
      }

      else
      {
        uint64_t v11 = mDNSLogCategory_SPS_redacted;
        BOOL v12 = os_log_type_enabled((os_log_t)mDNSLogCategory_SPS_redacted, OS_LOG_TYPE_DEFAULT);
        BOOL result = 0LL;
        if (!v12) {
          return result;
        }
        *(_DWORD *)buf = 136446210;
        *(void *)uint64_t v29 = v9;
        uint64_t v4 = "NetWakeInterface: returning false for %{public}s";
      }

      uint64_t v6 = (os_log_s *)v11;
      os_log_type_t v7 = OS_LOG_TYPE_DEFAULT;
      goto LABEL_14;
    }

    if (CheckInterfaceSupport(a1, "mDNS_Keepalive"))
    {
      int v10 = (os_log_s *)mDNSLogCategory_SPS;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_SPS == mDNSLogCategory_State)
      {
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_SPS, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)uint64_t v29 = v9;
          goto LABEL_38;
        }
      }

      else
      {
        int v10 = (os_log_s *)mDNSLogCategory_SPS_redacted;
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_SPS_redacted, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)uint64_t v29 = v9;
LABEL_38:
          _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "NetWakeInterface: interface supports TCP Keepalive -- ifname: %{public}s",  buf,  0xCu);
        }
      }

      return 1LL;
    }

    int v13 = socket(2, 2, 0);
    int v14 = v13;
    if (v13 < 0)
    {
      int v20 = *__error();
      uint64_t v21 = mDNSLogCategory_SPS;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_SPS == mDNSLogCategory_State)
      {
        BOOL result = os_log_type_enabled((os_log_t)mDNSLogCategory_SPS, OS_LOG_TYPE_ERROR);
        if (!result) {
          return result;
        }
      }

      else
      {
        uint64_t v21 = mDNSLogCategory_SPS_redacted;
        BOOL result = os_log_type_enabled((os_log_t)mDNSLogCategory_SPS_redacted, OS_LOG_TYPE_ERROR);
        if (!result) {
          return result;
        }
      }

      *(_DWORD *)buf = 67109634;
      *(_DWORD *)uint64_t v29 = v14;
      *(_WORD *)&v29[4] = 2082;
      *(void *)&v29[6] = v9;
      *(_WORD *)&v29[14] = 1024;
      *(_DWORD *)&v29[16] = v20;
      uint64_t v4 = "NetWakeInterface: socket failed -- socket: %d, ifname: %{public}s, error: %{darwin.errno}d";
      uint64_t v6 = (os_log_s *)v21;
      os_log_type_t v7 = OS_LOG_TYPE_ERROR;
      uint32_t v8 = 24;
      goto LABEL_15;
    }

    uint64_t v15 = 0LL;
    __int128 v35 = 0u;
    __int128 v36 = 0u;
    while (1)
    {
      int v16 = *(unsigned __int8 *)(v9 + v15);
      *((_BYTE *)&v35 + v15) = v16;
      if (!v16) {
        break;
      }
      if (++v15 == 15)
      {
        HIBYTE(v35) = 0;
        break;
      }
    }

    if ((ioctl(v13, 0xC0206988uLL, &v35) & 0x80000000) == 0)
    {
LABEL_60:
      close(v14);
      uint64_t v25 = (os_log_s *)mDNSLogCategory_SPS;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_SPS == mDNSLogCategory_State)
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_SPS, OS_LOG_TYPE_DEFAULT)) {
          return v36 & 1;
        }
      }

      else
      {
        uint64_t v25 = (os_log_s *)mDNSLogCategory_SPS_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_SPS_redacted, OS_LOG_TYPE_DEFAULT)) {
          return v36 & 1;
        }
      }

      *(_DWORD *)buf = 136447235;
      *(void *)uint64_t v29 = a1 + 6310;
      *(_WORD *)&v29[8] = 2160;
      *(void *)&v29[10] = 1752392040LL;
      *(_WORD *)&v29[18] = 1045;
      int v30 = 20;
      __int16 v31 = 2101;
      uint64_t v32 = a1 + 6264;
      __int16 v33 = 1024;
      int v34 = v36 & 1;
      _os_log_impl( (void *)&_mh_execute_header,  v25,  OS_LOG_TYPE_DEFAULT,  "NetWakeInterface: interface -- ifname: %{public}s, address: %{sensitive, mask.hash, mdnsresponder:ip_addr}.20P, supports Wake-On-Lan: %{mdns:yesno}d",  buf,  0x2Cu);
      return v36 & 1;
    }

    int v17 = *__error();
    if (v17 == 102)
    {
      if (!*(_DWORD *)(a1 + 6428))
      {
        BOOL v18 = *(_BYTE *)(*(void *)(a1 + 6392) + 143LL) != 0;
LABEL_59:
        LODWORD(v36) = v18;
        goto LABEL_60;
      }

LABEL_58:
      BOOL v18 = 0;
      goto LABEL_59;
    }

    uint64_t v22 = (os_log_s *)mDNSLogCategory_SPS;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_SPS == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_SPS, OS_LOG_TYPE_ERROR)) {
        goto LABEL_58;
      }
    }

    else
    {
      uint64_t v22 = (os_log_s *)mDNSLogCategory_SPS_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_SPS_redacted, OS_LOG_TYPE_ERROR)) {
        goto LABEL_58;
      }
    }

    *(_DWORD *)buf = 136446466;
    *(void *)uint64_t v29 = a1 + 6310;
    *(_WORD *)&v29[8] = 1024;
    *(_DWORD *)&v29[10] = v17;
    _os_log_impl( (void *)&_mh_execute_header,  v22,  OS_LOG_TYPE_ERROR,  "NetWakeInterface: SIOCGIFWAKEFLAGS failed -- ifname: %{public}s, error: %{darwin.errno}d",  buf,  0x12u);
    goto LABEL_58;
  }

  uint64_t v2 = mDNSLogCategory_SPS;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_SPS == mDNSLogCategory_State)
  {
    BOOL result = os_log_type_enabled((os_log_t)mDNSLogCategory_SPS, OS_LOG_TYPE_DEBUG);
    if (!result) {
      return result;
    }
    *(_DWORD *)buf = 136446210;
    *(void *)uint64_t v29 = a1 + 6310;
    uint64_t v4 = "NetWakeInterface: returning false for %{public}s";
    goto LABEL_13;
  }

  uint64_t v2 = mDNSLogCategory_SPS_redacted;
  BOOL result = os_log_type_enabled((os_log_t)mDNSLogCategory_SPS_redacted, OS_LOG_TYPE_DEBUG);
  if (result)
  {
    *(_DWORD *)buf = 136446210;
    *(void *)uint64_t v29 = a1 + 6310;
    uint64_t v4 = "NetWakeInterface: returning false for %{public}s";
LABEL_13:
    uint64_t v6 = (os_log_s *)v2;
    os_log_type_t v7 = OS_LOG_TYPE_DEBUG;
LABEL_14:
    uint32_t v8 = 12;
LABEL_15:
    _os_log_impl((void *)&_mh_execute_header, v6, v7, v4, buf, v8);
    return 0LL;
  }

  return result;
}

  *(_BYTE *)(a1 + 37864) = 0;
  *(_WORD *)(v17 + 101) = 0;
  *(_BYTE *)int v17 = 0;
  uint64_t v61 = *(void **)(v17 + 55);
  uint64_t v27 = a3;
  if (v61)
  {
    ref_count_obj_release(v61);
    *(void *)(v17 + 55) = 0LL;
  }

    uint64_t v58 = *a6 != 6;
    goto LABEL_60;
  }

  uint64_t v58 = *a4 != 6;
  if (a6 && *a4 != 6) {
    goto LABEL_58;
  }
LABEL_60:
  uint64_t v59 = a2[3];
  uint64_t v54 = *a2;
  uint64_t v55 = a2[1];
  uint64_t v60 = (v54 << 24) | (v55 << 16) | (v97 << 8);
  uint64_t v61 = ((unint64_t)*((unsigned __int16 *)a2 + 2) << 48) & 0xFF00000000000000LL | ((unint64_t)*((_WORD *)a2 + 2) << 48) | ((unint64_t)HIBYTE(*((_WORD *)a2 + 3)) << 40) | ((unint64_t)*((_WORD *)a2 + 3) << 32) | ((unint64_t)HIBYTE(*((unsigned __int16 *)a2 + 4)) << 24) | ((unint64_t)*((_WORD *)a2 + 4) << 16);
  uint64_t v62 = *((unsigned __int16 *)a2 + 5);
  memset(v117, 0, 60);
  unsigned int v91 = a6;
  if (!v46)
  {
    uint64_t v68 = 0;
    goto LABEL_102;
  }

  v92 = a8;
  int v89 = v53;
  int v90 = v46;
  uint64_t v87 = (v54 << 24) | (v55 << 16) | (v97 << 8);
  uint64_t v88 = v59;
  __int128 v86 = v62;
  if (v56)
  {
    uint64_t v63 = v58;
    uint64_t v64 = 0;
    uint64_t v65 = v117;
    while (1)
    {
      *(_DWORD *)buf = 0;
      uint64_t v98 = 0;
      *(_DWORD *)uint64_t v65 = bswap32(*(unsigned int *)buf);
      *((_WORD *)v65 + 2) = bswap32(v98) >> 16;
      uint64_t v66 = skipDomainName((unint64_t)a2, v15, a3);
      uint64_t v15 = v66 + 4;
      uint64_t v65 = (_OWORD *)((char *)v65 + 6);
      uint64_t v67 = v64 + 1;
      if (v64 <= 8)
      {
        ++v64;
      }

      uint64_t v57 = *((unsigned __int16 *)a2 + 3);
      uint64_t v58 = v63;
      a8 = v92;
      goto LABEL_73;
    }

    uint64_t v58 = v63;
    a8 = v92;
    goto LABEL_101;
  }

  uint64_t v67 = 0;
  uint64_t v65 = v117;
LABEL_73:
  int v85 = v58;
  if (v67 <= 9 && v57)
  {
    uint64_t v69 = 1;
    while (1)
    {
      uint64_t v64 = v67 + v69 - 1;
      *(_DWORD *)buf = 0;
      uint64_t v98 = 0;
      *(_DWORD *)uint64_t v65 = bswap32(*(unsigned int *)buf);
      *((_WORD *)v65 + 2) = bswap32(v98) >> 16;
      uint64_t v70 = skipResourceRecord((unint64_t)a2, v15, a3);
      if (!v70)
      {
LABEL_97:
        uint64_t v76 = v67 + v69;
LABEL_98:
        uint64_t v64 = v76 - 1;
        break;
      }

      uint64_t v15 = v70;
      uint64_t v65 = (_OWORD *)((char *)v65 + 6);
      uint64_t v71 = v69 + 1;
      if (v69 < *((unsigned __int16 *)a2 + 3))
      {
        ++v69;
        if (v64 < 9) {
          continue;
        }
      }

      uint64_t v67 = v67 + v71 - 1;
      a8 = v92;
      uint64_t v58 = v85;
      goto LABEL_81;
    }
  }

  else
  {
LABEL_81:
    if (*((_WORD *)a2 + 4) && v67 <= 9)
    {
      uint64_t v69 = 1;
      while (1)
      {
        uint64_t v64 = v67 + v69 - 1;
        *(_DWORD *)buf = 0;
        uint64_t v98 = 0;
        *(_DWORD *)uint64_t v65 = bswap32(*(unsigned int *)buf);
        *((_WORD *)v65 + 2) = bswap32(v98) >> 16;
        uint64_t v72 = skipResourceRecord((unint64_t)a2, v15, a3);
        if (!v72) {
          goto LABEL_97;
        }
        uint64_t v15 = v72;
        uint64_t v65 = (_OWORD *)((char *)v65 + 6);
        uint64_t v73 = v69 + 1;
        if (v69 < *((unsigned __int16 *)a2 + 4))
        {
          ++v69;
          if (v64 < 9) {
            continue;
          }
        }

        uint64_t v67 = v67 + v73 - 1;
        a8 = v92;
        uint64_t v58 = v85;
        goto LABEL_89;
      }
    }

    else
    {
LABEL_89:
      if (!*((_WORD *)a2 + 5) || v67 > 9)
      {
        uint64_t v64 = v67;
        goto LABEL_101;
      }

      uint64_t v69 = 1;
      while (1)
      {
        uint64_t v64 = v67 + v69 - 1;
        *(_DWORD *)buf = 0;
        uint64_t v98 = 0;
        *(_DWORD *)uint64_t v65 = bswap32(*(unsigned int *)buf);
        *((_WORD *)v65 + 2) = bswap32(v98) >> 16;
        uint64_t v74 = skipResourceRecord((unint64_t)a2, v15, a3);
        if (!v74) {
          goto LABEL_97;
        }
        int v75 = v69 + 1;
        if (v69 < *((unsigned __int16 *)a2 + 5))
        {
          uint64_t v15 = v74;
          uint64_t v65 = (_OWORD *)((char *)v65 + 6);
          ++v69;
          if (v64 < 9) {
            continue;
          }
        }

        uint64_t v76 = v67 + v75;
        goto LABEL_98;
      }
    }
  }

  a8 = v92;
  uint64_t v58 = v85;
LABEL_101:
  uint64_t v68 = 6 * v64;
  uint64_t v38 = a9;
  int v53 = v89;
  LOBYTE(v46) = v90;
  uint64_t v60 = v87;
  uint64_t v59 = v88;
  uint64_t v62 = v86;
LABEL_102:
  uint64_t v77 = v60 | v59;
  uint64_t v78 = (_OWORD *)(v61 | v62);
  uint64_t v79 = gSensitiveLoggingEnabled;
  uint64_t v80 = mDNSLogCategory_mDNS;
  if (mDNSLogCategory_mDNS == mDNSLogCategory_State) {
    uint64_t v79 = 0;
  }
  if (!v94)
  {
    if (v58)
    {
      if (!a1)
      {
        if ((v97 & 0x80) != 0)
        {
          if ((v53 & 1) != 0)
          {
            if ((v46 & 1) != 0)
            {
              if ((v79 & 1) != 0)
              {
                uint64_t v80 = mDNSLogCategory_mDNS_redacted;
                if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
                  return;
                }
              }

              else if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
              {
                return;
              }

              *(_DWORD *)buf = 67112195;
              uint64_t v100 = v19;
              uint64_t v101 = 1024;
              uint64_t v102 = v27;
              uint64_t v103 = 1024;
              *(_DWORD *)uint64_t v104 = v93;
              *(_WORD *)&v104[4] = 2160;
              *(void *)&v104[6] = 1752392040LL;
              uint64_t v105 = 1045;
              *(_DWORD *)uint64_t v106 = 20;
              *(_WORD *)&v106[4] = 2101;
              *(void *)&v106[6] = a4;
              *(_WORD *)&v106[14] = 2082;
              *(void *)&_OWORD v106[16] = v38;
              uint64_t v107 = 1024;
              *(_DWORD *)uint64_t v108 = a8;
              *(_WORD *)&v108[4] = 2048;
              *(void *)&v108[6] = v77;
              unint64_t v109 = 2048;
              uint64_t v110 = v78;
              uint64_t v111 = 2160;
              v112 = 1752392040LL;
              uint64_t v113 = 1040;
              uint64_t v114 = v68;
              uint64_t v115 = 2101;
              uint64_t v116 = v117;
              uint64_t v81 = "[Q(%x, %x)] Received %u-byte IPv4 mDNS response from %{sensitive, mask.hash, mdnsresponder:ip_addr}."
                    "20P over multicast via %{public}s/%u -- %{mdns:dns.idflags}08lX, counts: %{mdns:dns.counts}016llX %{"
                    "sensitive, mask.hash, mdnsresponder:mdns_name_hash_type_bytes}.*P";
              goto LABEL_388;
            }

            if ((v79 & 1) != 0)
            {
              uint64_t v80 = mDNSLogCategory_mDNS_redacted;
              if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
                return;
              }
            }

            else if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
            {
              return;
            }

            *(_DWORD *)buf = 67110659;
            uint64_t v100 = v19;
            uint64_t v101 = 1024;
            uint64_t v102 = v27;
            uint64_t v103 = 2160;
            *(void *)uint64_t v104 = 1752392040LL;
            *(_WORD *)&v104[8] = 1045;
            *(_DWORD *)&v104[10] = 20;
            uint64_t v105 = 2101;
            *(void *)uint64_t v106 = a4;
            *(_WORD *)&v106[8] = 2082;
            *(void *)&v106[10] = v38;
            *(_WORD *)&v106[18] = 1024;
            *(_DWORD *)&v106[20] = a8;
            uint64_t v81 = "[Q(%x, %x)] Received a previous IPv4 mDNS response from %{sensitive, mask.hash, mdnsresponder:ip_addr}"
                  ".20P over multicast via %{public}s/%u";
            goto LABEL_397;
          }

          if ((v79 & 1) != 0)
          {
            uint64_t v82 = mDNSLogCategory_mDNS_redacted;
            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
              return;
            }
            *(_DWORD *)buf = 67109376;
            uint64_t v100 = v19;
            uint64_t v101 = 1024;
            uint64_t v102 = v27;
            uint64_t v81 = "[Q(%x, %x)] Received a previous IPv4 mDNS response over multicast";
            goto LABEL_267;
          }

          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
            return;
          }
          *(_DWORD *)buf = 67109376;
          uint64_t v100 = v19;
          uint64_t v101 = 1024;
          uint64_t v102 = v27;
          uint64_t v81 = "[Q(%x, %x)] Received a previous IPv4 mDNS response over multicast";
        }

        else
        {
          if ((v53 & 1) != 0)
          {
            if ((v46 & 1) != 0)
            {
              if ((v79 & 1) != 0)
              {
                uint64_t v80 = mDNSLogCategory_mDNS_redacted;
                if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
                  return;
                }
              }

              else if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
              {
                return;
              }

              *(_DWORD *)buf = 67112195;
              uint64_t v100 = v19;
              uint64_t v101 = 1024;
              uint64_t v102 = v27;
              uint64_t v103 = 1024;
              *(_DWORD *)uint64_t v104 = v93;
              *(_WORD *)&v104[4] = 2160;
              *(void *)&v104[6] = 1752392040LL;
              uint64_t v105 = 1045;
              *(_DWORD *)uint64_t v106 = 20;
              *(_WORD *)&v106[4] = 2101;
              *(void *)&v106[6] = a4;
              *(_WORD *)&v106[14] = 2082;
              *(void *)&_OWORD v106[16] = v38;
              uint64_t v107 = 1024;
              *(_DWORD *)uint64_t v108 = a8;
              *(_WORD *)&v108[4] = 2048;
              *(void *)&v108[6] = v77;
              unint64_t v109 = 2048;
              uint64_t v110 = v78;
              uint64_t v111 = 2160;
              v112 = 1752392040LL;
              uint64_t v113 = 1040;
              uint64_t v114 = v68;
              uint64_t v115 = 2101;
              uint64_t v116 = v117;
              uint64_t v81 = "[A(%x, %x)] Received %u-byte IPv4 mDNS query from %{sensitive, mask.hash, mdnsresponder:ip_addr}.20P"
                    " over multicast via %{public}s/%u -- %{mdns:dns.idflags}08lX, counts: %{mdns:dns.counts}016llX %{sen"
                    "sitive, mask.hash, mdnsresponder:mdns_name_hash_type_bytes}.*P";
              goto LABEL_388;
            }

            if ((v79 & 1) != 0)
            {
              uint64_t v80 = mDNSLogCategory_mDNS_redacted;
              if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
                return;
              }
            }

            else if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
            {
              return;
            }

            *(_DWORD *)buf = 67110659;
            uint64_t v100 = v19;
            uint64_t v101 = 1024;
            uint64_t v102 = v27;
            uint64_t v103 = 2160;
            *(void *)uint64_t v104 = 1752392040LL;
            *(_WORD *)&v104[8] = 1045;
            *(_DWORD *)&v104[10] = 20;
            uint64_t v105 = 2101;
            *(void *)uint64_t v106 = a4;
            *(_WORD *)&v106[8] = 2082;
            *(void *)&v106[10] = v38;
            *(_WORD *)&v106[18] = 1024;
            *(_DWORD *)&v106[20] = a8;
            uint64_t v81 = "[A(%x, %x)] Received a previous IPv4 mDNS query from %{sensitive, mask.hash, mdnsresponder:ip_addr}.20"
                  "P over multicast via %{public}s/%u";
            goto LABEL_397;
          }

          if ((v79 & 1) != 0)
          {
            uint64_t v82 = mDNSLogCategory_mDNS_redacted;
            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
              return;
            }
            *(_DWORD *)buf = 67109376;
            uint64_t v100 = v19;
            uint64_t v101 = 1024;
            uint64_t v102 = v27;
            uint64_t v81 = "[A(%x, %x)] Received a previous IPv4 mDNS query over multicast";
            goto LABEL_267;
          }

          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
            return;
          }
          *(_DWORD *)buf = 67109376;
          uint64_t v100 = v19;
          uint64_t v101 = 1024;
          uint64_t v102 = v27;
          uint64_t v81 = "[A(%x, %x)] Received a previous IPv4 mDNS query over multicast";
        }

        goto LABEL_344;
      }

      if ((v97 & 0x80) != 0)
      {
        if ((v53 & 1) == 0)
        {
          if ((v79 & 1) != 0)
          {
            uint64_t v82 = mDNSLogCategory_mDNS_redacted;
            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
              return;
            }
            *(_DWORD *)buf = 67109376;
            uint64_t v100 = v19;
            uint64_t v101 = 1024;
            uint64_t v102 = v27;
            uint64_t v81 = "[A(%x, %x)] Sent a previous IPv4 mDNS response over multicast";
            goto LABEL_267;
          }

          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
            return;
          }
          *(_DWORD *)buf = 67109376;
          uint64_t v100 = v19;
          uint64_t v101 = 1024;
          uint64_t v102 = v27;
          uint64_t v81 = "[A(%x, %x)] Sent a previous IPv4 mDNS response over multicast";
          goto LABEL_344;
        }

        if ((v46 & 1) != 0)
        {
          if ((v79 & 1) != 0)
          {
            uint64_t v80 = mDNSLogCategory_mDNS_redacted;
            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
              return;
            }
          }

          else if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
          {
            return;
          }

          *(_DWORD *)buf = 67111427;
          uint64_t v100 = v19;
          uint64_t v101 = 1024;
          uint64_t v102 = v27;
          uint64_t v103 = 1024;
          *(_DWORD *)uint64_t v104 = v93;
          *(_WORD *)&v104[4] = 2082;
          *(void *)&v104[6] = v38;
          uint64_t v105 = 1024;
          *(_DWORD *)uint64_t v106 = a8;
          *(_WORD *)&v106[4] = 2048;
          *(void *)&v106[6] = v77;
          *(_WORD *)&v106[14] = 2048;
          *(void *)&_OWORD v106[16] = v78;
          uint64_t v107 = 2160;
          *(void *)uint64_t v108 = 1752392040LL;
          *(_WORD *)&v108[8] = 1040;
          *(_DWORD *)&v108[10] = v68;
          unint64_t v109 = 2101;
          uint64_t v110 = v117;
          uint64_t v81 = "[A(%x, %x)] Sent %u-byte IPv4 mDNS response over multicast via %{public}s/%u -- %{mdns:dns.idflags}08lX,"
                " counts: %{mdns:dns.counts}016llX %{sensitive, mask.hash, mdnsresponder:mdns_name_hash_type_bytes}.*P";
          goto LABEL_362;
        }

        if ((v79 & 1) != 0)
        {
          uint64_t v80 = mDNSLogCategory_mDNS_redacted;
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
            return;
          }
        }

        else if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
        {
          return;
        }

        *(_DWORD *)buf = 67109890;
        uint64_t v100 = v19;
        uint64_t v101 = 1024;
        uint64_t v102 = v27;
        uint64_t v103 = 2082;
        *(void *)uint64_t v104 = v38;
        *(_WORD *)&v104[8] = 1024;
        *(_DWORD *)&v104[10] = a8;
        uint64_t v81 = "[A(%x, %x)] Sent a previous IPv4 mDNS response over multicast via %{public}s/%u";
      }

      else
      {
        if ((v53 & 1) == 0)
        {
          if ((v79 & 1) != 0)
          {
            uint64_t v82 = mDNSLogCategory_mDNS_redacted;
            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
              return;
            }
            *(_DWORD *)buf = 67109376;
            uint64_t v100 = v19;
            uint64_t v101 = 1024;
            uint64_t v102 = v27;
            uint64_t v81 = "[Q(%x, %x)] Sent a previous IPv4 mDNS query over multicast";
            goto LABEL_267;
          }

          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
            return;
          }
          *(_DWORD *)buf = 67109376;
          uint64_t v100 = v19;
          uint64_t v101 = 1024;
          uint64_t v102 = v27;
          uint64_t v81 = "[Q(%x, %x)] Sent a previous IPv4 mDNS query over multicast";
LABEL_344:
          uint64_t v83 = (os_log_s *)v80;
          goto LABEL_345;
        }

        if ((v46 & 1) != 0)
        {
          if ((v79 & 1) != 0)
          {
            uint64_t v80 = mDNSLogCategory_mDNS_redacted;
            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
              return;
            }
          }

          else if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
          {
            return;
          }

          *(_DWORD *)buf = 67111427;
          uint64_t v100 = v19;
          uint64_t v101 = 1024;
          uint64_t v102 = v27;
          uint64_t v103 = 1024;
          *(_DWORD *)uint64_t v104 = v93;
          *(_WORD *)&v104[4] = 2082;
          *(void *)&v104[6] = v38;
          uint64_t v105 = 1024;
          *(_DWORD *)uint64_t v106 = a8;
          *(_WORD *)&v106[4] = 2048;
          *(void *)&v106[6] = v77;
          *(_WORD *)&v106[14] = 2048;
          *(void *)&_OWORD v106[16] = v78;
          uint64_t v107 = 2160;
          *(void *)uint64_t v108 = 1752392040LL;
          *(_WORD *)&v108[8] = 1040;
          *(_DWORD *)&v108[10] = v68;
          unint64_t v109 = 2101;
          uint64_t v110 = v117;
          uint64_t v81 = "[Q(%x, %x)] Sent %u-byte IPv4 mDNS query over multicast via %{public}s/%u -- %{mdns:dns.idflags}08lX, co"
                "unts: %{mdns:dns.counts}016llX %{sensitive, mask.hash, mdnsresponder:mdns_name_hash_type_bytes}.*P";
LABEL_362:
          uint64_t v83 = (os_log_s *)v80;
          uint64_t v84 = 82;
          goto LABEL_398;
        }

        if ((v79 & 1) != 0)
        {
          uint64_t v80 = mDNSLogCategory_mDNS_redacted;
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
            return;
          }
        }

        else if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
        {
          return;
        }

        *(_DWORD *)buf = 67109890;
        uint64_t v100 = v19;
        uint64_t v101 = 1024;
        uint64_t v102 = v27;
        uint64_t v103 = 2082;
        *(void *)uint64_t v104 = v38;
        *(_WORD *)&v104[8] = 1024;
        *(_DWORD *)&v104[10] = a8;
        uint64_t v81 = "[Q(%x, %x)] Sent a previous IPv4 mDNS query over multicast via %{public}s/%u";
      }
    }

    else
    {
      if (!a1)
      {
        if ((v97 & 0x80) != 0)
        {
          if ((v53 & 1) != 0)
          {
            if ((v46 & 1) != 0)
            {
              if ((v79 & 1) != 0)
              {
                uint64_t v80 = mDNSLogCategory_mDNS_redacted;
                if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
                  return;
                }
              }

              else if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
              {
                return;
              }

              *(_DWORD *)buf = 67112195;
              uint64_t v100 = v19;
              uint64_t v101 = 1024;
              uint64_t v102 = v27;
              uint64_t v103 = 1024;
              *(_DWORD *)uint64_t v104 = v93;
              *(_WORD *)&v104[4] = 2160;
              *(void *)&v104[6] = 1752392040LL;
              uint64_t v105 = 1045;
              *(_DWORD *)uint64_t v106 = 20;
              *(_WORD *)&v106[4] = 2101;
              *(void *)&v106[6] = a4;
              *(_WORD *)&v106[14] = 2082;
              *(void *)&_OWORD v106[16] = v38;
              uint64_t v107 = 1024;
              *(_DWORD *)uint64_t v108 = a8;
              *(_WORD *)&v108[4] = 2048;
              *(void *)&v108[6] = v77;
              unint64_t v109 = 2048;
              uint64_t v110 = v78;
              uint64_t v111 = 2160;
              v112 = 1752392040LL;
              uint64_t v113 = 1040;
              uint64_t v114 = v68;
              uint64_t v115 = 2101;
              uint64_t v116 = v117;
              uint64_t v81 = "[Q(%x, %x)] Received %u-byte IPv6 mDNS response from %{sensitive, mask.hash, mdnsresponder:ip_addr}."
                    "20P over multicast via %{public}s/%u -- %{mdns:dns.idflags}08lX, counts: %{mdns:dns.counts}016llX %{"
                    "sensitive, mask.hash, mdnsresponder:mdns_name_hash_type_bytes}.*P";
              goto LABEL_388;
            }

            if ((v79 & 1) != 0)
            {
              uint64_t v80 = mDNSLogCategory_mDNS_redacted;
              if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
                return;
              }
            }

            else if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
            {
              return;
            }

            *(_DWORD *)buf = 67110659;
            uint64_t v100 = v19;
            uint64_t v101 = 1024;
            uint64_t v102 = v27;
            uint64_t v103 = 2160;
            *(void *)uint64_t v104 = 1752392040LL;
            *(_WORD *)&v104[8] = 1045;
            *(_DWORD *)&v104[10] = 20;
            uint64_t v105 = 2101;
            *(void *)uint64_t v106 = a4;
            *(_WORD *)&v106[8] = 2082;
            *(void *)&v106[10] = v38;
            *(_WORD *)&v106[18] = 1024;
            *(_DWORD *)&v106[20] = a8;
            uint64_t v81 = "[Q(%x, %x)] Received a previous IPv6 mDNS response from %{sensitive, mask.hash, mdnsresponder:ip_addr}"
                  ".20P over multicast via %{public}s/%u";
            goto LABEL_397;
          }

          if ((v79 & 1) != 0)
          {
            uint64_t v82 = mDNSLogCategory_mDNS_redacted;
            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
              return;
            }
            *(_DWORD *)buf = 67109376;
            uint64_t v100 = v19;
            uint64_t v101 = 1024;
            uint64_t v102 = v27;
            uint64_t v81 = "[Q(%x, %x)] Received a previous IPv6 mDNS response over multicast";
            goto LABEL_267;
          }

          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
            return;
          }
          *(_DWORD *)buf = 67109376;
          uint64_t v100 = v19;
          uint64_t v101 = 1024;
          uint64_t v102 = v27;
          uint64_t v81 = "[Q(%x, %x)] Received a previous IPv6 mDNS response over multicast";
        }

        else
        {
          if ((v53 & 1) != 0)
          {
            if ((v46 & 1) != 0)
            {
              if ((v79 & 1) != 0)
              {
                uint64_t v80 = mDNSLogCategory_mDNS_redacted;
                if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
                  return;
                }
              }

              else if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
              {
                return;
              }

              *(_DWORD *)buf = 67112195;
              uint64_t v100 = v19;
              uint64_t v101 = 1024;
              uint64_t v102 = v27;
              uint64_t v103 = 1024;
              *(_DWORD *)uint64_t v104 = v93;
              *(_WORD *)&v104[4] = 2160;
              *(void *)&v104[6] = 1752392040LL;
              uint64_t v105 = 1045;
              *(_DWORD *)uint64_t v106 = 20;
              *(_WORD *)&v106[4] = 2101;
              *(void *)&v106[6] = a4;
              *(_WORD *)&v106[14] = 2082;
              *(void *)&_OWORD v106[16] = v38;
              uint64_t v107 = 1024;
              *(_DWORD *)uint64_t v108 = a8;
              *(_WORD *)&v108[4] = 2048;
              *(void *)&v108[6] = v77;
              unint64_t v109 = 2048;
              uint64_t v110 = v78;
              uint64_t v111 = 2160;
              v112 = 1752392040LL;
              uint64_t v113 = 1040;
              uint64_t v114 = v68;
              uint64_t v115 = 2101;
              uint64_t v116 = v117;
              uint64_t v81 = "[A(%x, %x)] Received %u-byte IPv6 mDNS query from %{sensitive, mask.hash, mdnsresponder:ip_addr}.20P"
                    " over multicast via %{public}s/%u -- %{mdns:dns.idflags}08lX, counts: %{mdns:dns.counts}016llX %{sen"
                    "sitive, mask.hash, mdnsresponder:mdns_name_hash_type_bytes}.*P";
              goto LABEL_388;
            }

            if ((v79 & 1) != 0)
            {
              uint64_t v80 = mDNSLogCategory_mDNS_redacted;
              if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
                return;
              }
            }

            else if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
            {
              return;
            }

            *(_DWORD *)buf = 67110659;
            uint64_t v100 = v19;
            uint64_t v101 = 1024;
            uint64_t v102 = v27;
            uint64_t v103 = 2160;
            *(void *)uint64_t v104 = 1752392040LL;
            *(_WORD *)&v104[8] = 1045;
            *(_DWORD *)&v104[10] = 20;
            uint64_t v105 = 2101;
            *(void *)uint64_t v106 = a4;
            *(_WORD *)&v106[8] = 2082;
            *(void *)&v106[10] = v38;
            *(_WORD *)&v106[18] = 1024;
            *(_DWORD *)&v106[20] = a8;
            uint64_t v81 = "[A(%x, %x)] Received a previous IPv6 mDNS query from %{sensitive, mask.hash, mdnsresponder:ip_addr}.20"
                  "P over multicast via %{public}s/%u";
            goto LABEL_397;
          }

          if ((v79 & 1) != 0)
          {
            uint64_t v82 = mDNSLogCategory_mDNS_redacted;
            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
              return;
            }
            *(_DWORD *)buf = 67109376;
            uint64_t v100 = v19;
            uint64_t v101 = 1024;
            uint64_t v102 = v27;
            uint64_t v81 = "[A(%x, %x)] Received a previous IPv6 mDNS query over multicast";
            goto LABEL_267;
          }

          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
            return;
          }
          *(_DWORD *)buf = 67109376;
          uint64_t v100 = v19;
          uint64_t v101 = 1024;
          uint64_t v102 = v27;
          uint64_t v81 = "[A(%x, %x)] Received a previous IPv6 mDNS query over multicast";
        }

        goto LABEL_344;
      }

      if ((v97 & 0x80) != 0)
      {
        if ((v53 & 1) == 0)
        {
          if ((v79 & 1) != 0)
          {
            uint64_t v82 = mDNSLogCategory_mDNS_redacted;
            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
              return;
            }
            *(_DWORD *)buf = 67109376;
            uint64_t v100 = v19;
            uint64_t v101 = 1024;
            uint64_t v102 = v27;
            uint64_t v81 = "[A(%x, %x)] Sent a previous IPv6 mDNS response over multicast";
            goto LABEL_267;
          }

          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
            return;
          }
          *(_DWORD *)buf = 67109376;
          uint64_t v100 = v19;
          uint64_t v101 = 1024;
          uint64_t v102 = v27;
          uint64_t v81 = "[A(%x, %x)] Sent a previous IPv6 mDNS response over multicast";
          goto LABEL_344;
        }

        if ((v46 & 1) != 0)
        {
          if ((v79 & 1) != 0)
          {
            uint64_t v80 = mDNSLogCategory_mDNS_redacted;
            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
              return;
            }
          }

          else if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
          {
            return;
          }

          *(_DWORD *)buf = 67111427;
          uint64_t v100 = v19;
          uint64_t v101 = 1024;
          uint64_t v102 = v27;
          uint64_t v103 = 1024;
          *(_DWORD *)uint64_t v104 = v93;
          *(_WORD *)&v104[4] = 2082;
          *(void *)&v104[6] = v38;
          uint64_t v105 = 1024;
          *(_DWORD *)uint64_t v106 = a8;
          *(_WORD *)&v106[4] = 2048;
          *(void *)&v106[6] = v77;
          *(_WORD *)&v106[14] = 2048;
          *(void *)&_OWORD v106[16] = v78;
          uint64_t v107 = 2160;
          *(void *)uint64_t v108 = 1752392040LL;
          *(_WORD *)&v108[8] = 1040;
          *(_DWORD *)&v108[10] = v68;
          unint64_t v109 = 2101;
          uint64_t v110 = v117;
          uint64_t v81 = "[A(%x, %x)] Sent %u-byte IPv6 mDNS response over multicast via %{public}s/%u -- %{mdns:dns.idflags}08lX,"
                " counts: %{mdns:dns.counts}016llX %{sensitive, mask.hash, mdnsresponder:mdns_name_hash_type_bytes}.*P";
          goto LABEL_362;
        }

        if ((v79 & 1) != 0)
        {
          uint64_t v80 = mDNSLogCategory_mDNS_redacted;
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
            return;
          }
        }

        else if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
        {
          return;
        }

        *(_DWORD *)buf = 67109890;
        uint64_t v100 = v19;
        uint64_t v101 = 1024;
        uint64_t v102 = v27;
        uint64_t v103 = 2082;
        *(void *)uint64_t v104 = v38;
        *(_WORD *)&v104[8] = 1024;
        *(_DWORD *)&v104[10] = a8;
        uint64_t v81 = "[A(%x, %x)] Sent a previous IPv6 mDNS response over multicast via %{public}s/%u";
      }

      else
      {
        if ((v53 & 1) == 0)
        {
          if ((v79 & 1) != 0)
          {
            uint64_t v82 = mDNSLogCategory_mDNS_redacted;
            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
              return;
            }
            *(_DWORD *)buf = 67109376;
            uint64_t v100 = v19;
            uint64_t v101 = 1024;
            uint64_t v102 = v27;
            uint64_t v81 = "[Q(%x, %x)] Sent a previous IPv6 mDNS query over multicast";
            goto LABEL_267;
          }

          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
            return;
          }
          *(_DWORD *)buf = 67109376;
          uint64_t v100 = v19;
          uint64_t v101 = 1024;
          uint64_t v102 = v27;
          uint64_t v81 = "[Q(%x, %x)] Sent a previous IPv6 mDNS query over multicast";
          goto LABEL_344;
        }

        if ((v46 & 1) != 0)
        {
          if ((v79 & 1) != 0)
          {
            uint64_t v80 = mDNSLogCategory_mDNS_redacted;
            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
              return;
            }
          }

          else if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
          {
            return;
          }

          *(_DWORD *)buf = 67111427;
          uint64_t v100 = v19;
          uint64_t v101 = 1024;
          uint64_t v102 = v27;
          uint64_t v103 = 1024;
          *(_DWORD *)uint64_t v104 = v93;
          *(_WORD *)&v104[4] = 2082;
          *(void *)&v104[6] = v38;
          uint64_t v105 = 1024;
          *(_DWORD *)uint64_t v106 = a8;
          *(_WORD *)&v106[4] = 2048;
          *(void *)&v106[6] = v77;
          *(_WORD *)&v106[14] = 2048;
          *(void *)&_OWORD v106[16] = v78;
          uint64_t v107 = 2160;
          *(void *)uint64_t v108 = 1752392040LL;
          *(_WORD *)&v108[8] = 1040;
          *(_DWORD *)&v108[10] = v68;
          unint64_t v109 = 2101;
          uint64_t v110 = v117;
          uint64_t v81 = "[Q(%x, %x)] Sent %u-byte IPv6 mDNS query over multicast via %{public}s/%u -- %{mdns:dns.idflags}08lX, co"
                "unts: %{mdns:dns.counts}016llX %{sensitive, mask.hash, mdnsresponder:mdns_name_hash_type_bytes}.*P";
          goto LABEL_362;
        }

        if ((v79 & 1) != 0)
        {
          uint64_t v80 = mDNSLogCategory_mDNS_redacted;
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
            return;
          }
        }

        else if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
        {
          return;
        }

        *(_DWORD *)buf = 67109890;
        uint64_t v100 = v19;
        uint64_t v101 = 1024;
        uint64_t v102 = v27;
        uint64_t v103 = 2082;
        *(void *)uint64_t v104 = v38;
        *(_WORD *)&v104[8] = 1024;
        *(_DWORD *)&v104[10] = a8;
        uint64_t v81 = "[Q(%x, %x)] Sent a previous IPv6 mDNS query over multicast via %{public}s/%u";
      }
    }

    uint64_t v83 = (os_log_s *)v80;
    uint64_t v84 = 30;
    goto LABEL_398;
  }

  if (!v58)
  {
    if (a1)
    {
      if ((v97 & 0x80) != 0)
      {
        if ((v53 & 1) != 0)
        {
          if ((v46 & 1) != 0)
          {
            if ((v79 & 1) != 0)
            {
              uint64_t v80 = mDNSLogCategory_mDNS_redacted;
              if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
                return;
              }
            }

            else if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
            {
              return;
            }

            *(_DWORD *)buf = 67112195;
            uint64_t v100 = v19;
            uint64_t v101 = 1024;
            uint64_t v102 = v27;
            uint64_t v103 = 1024;
            *(_DWORD *)uint64_t v104 = v93;
            *(_WORD *)&v104[4] = 2160;
            *(void *)&v104[6] = 1752392040LL;
            uint64_t v105 = 1045;
            *(_DWORD *)uint64_t v106 = 20;
            *(_WORD *)&v106[4] = 2101;
            *(void *)&v106[6] = v91;
            *(_WORD *)&v106[14] = 2082;
            *(void *)&_OWORD v106[16] = v38;
            uint64_t v107 = 1024;
            *(_DWORD *)uint64_t v108 = a8;
            *(_WORD *)&v108[4] = 2048;
            *(void *)&v108[6] = v77;
            unint64_t v109 = 2048;
            uint64_t v110 = v78;
            uint64_t v111 = 2160;
            v112 = 1752392040LL;
            uint64_t v113 = 1040;
            uint64_t v114 = v68;
            uint64_t v115 = 2101;
            uint64_t v116 = v117;
            uint64_t v81 = "[A(%x, %x)] Sent %u-byte IPv6 mDNS response to %{sensitive, mask.hash, mdnsresponder:ip_addr}.20P over"
                  " unicast via %{public}s/%u -- %{mdns:dns.idflags}08lX, counts: %{mdns:dns.counts}016llX %{sensitive, m"
                  "ask.hash, mdnsresponder:mdns_name_hash_type_bytes}.*P";
            goto LABEL_388;
          }

          if ((v79 & 1) != 0)
          {
            uint64_t v80 = mDNSLogCategory_mDNS_redacted;
            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
              return;
            }
          }

          else if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
          {
            return;
          }

          *(_DWORD *)buf = 67110659;
          uint64_t v100 = v19;
          uint64_t v101 = 1024;
          uint64_t v102 = v27;
          uint64_t v103 = 2160;
          *(void *)uint64_t v104 = 1752392040LL;
          *(_WORD *)&v104[8] = 1045;
          *(_DWORD *)&v104[10] = 20;
          uint64_t v105 = 2101;
          *(void *)uint64_t v106 = v91;
          *(_WORD *)&v106[8] = 2082;
          *(void *)&v106[10] = v38;
          *(_WORD *)&v106[18] = 1024;
          *(_DWORD *)&v106[20] = a8;
          uint64_t v81 = "[A(%x, %x)] Sent a previous IPv6 mDNS response to %{sensitive, mask.hash, mdnsresponder:ip_addr}.20P ove"
                "r unicast via %{public}s/%u";
          goto LABEL_397;
        }

        if ((v79 & 1) != 0)
        {
          uint64_t v82 = mDNSLogCategory_mDNS_redacted;
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
            return;
          }
          *(_DWORD *)buf = 67109376;
          uint64_t v100 = v19;
          uint64_t v101 = 1024;
          uint64_t v102 = v27;
          uint64_t v81 = "[A(%x, %x)] Sent a previous IPv6 mDNS response over unicast";
          goto LABEL_267;
        }

        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
          return;
        }
        *(_DWORD *)buf = 67109376;
        uint64_t v100 = v19;
        uint64_t v101 = 1024;
        uint64_t v102 = v27;
        uint64_t v81 = "[A(%x, %x)] Sent a previous IPv6 mDNS response over unicast";
      }

      else
      {
        if ((v53 & 1) != 0)
        {
          if ((v46 & 1) != 0)
          {
            if ((v79 & 1) != 0)
            {
              uint64_t v80 = mDNSLogCategory_mDNS_redacted;
              if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
                return;
              }
            }

            else if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
            {
              return;
            }

            *(_DWORD *)buf = 67112195;
            uint64_t v100 = v19;
            uint64_t v101 = 1024;
            uint64_t v102 = v27;
            uint64_t v103 = 1024;
            *(_DWORD *)uint64_t v104 = v93;
            *(_WORD *)&v104[4] = 2160;
            *(void *)&v104[6] = 1752392040LL;
            uint64_t v105 = 1045;
            *(_DWORD *)uint64_t v106 = 20;
            *(_WORD *)&v106[4] = 2101;
            *(void *)&v106[6] = v91;
            *(_WORD *)&v106[14] = 2082;
            *(void *)&_OWORD v106[16] = v38;
            uint64_t v107 = 1024;
            *(_DWORD *)uint64_t v108 = a8;
            *(_WORD *)&v108[4] = 2048;
            *(void *)&v108[6] = v77;
            unint64_t v109 = 2048;
            uint64_t v110 = v78;
            uint64_t v111 = 2160;
            v112 = 1752392040LL;
            uint64_t v113 = 1040;
            uint64_t v114 = v68;
            uint64_t v115 = 2101;
            uint64_t v116 = v117;
            uint64_t v81 = "[Q(%x, %x)] Sent %u-byte IPv6 mDNS query to %{sensitive, mask.hash, mdnsresponder:ip_addr}.20P over un"
                  "icast via %{public}s/%u -- %{mdns:dns.idflags}08lX, counts: %{mdns:dns.counts}016llX %{sensitive, mask"
                  ".hash, mdnsresponder:mdns_name_hash_type_bytes}.*P";
            goto LABEL_388;
          }

          if ((v79 & 1) != 0)
          {
            uint64_t v80 = mDNSLogCategory_mDNS_redacted;
            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
              return;
            }
          }

          else if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
          {
            return;
          }

          *(_DWORD *)buf = 67110659;
          uint64_t v100 = v19;
          uint64_t v101 = 1024;
          uint64_t v102 = v27;
          uint64_t v103 = 2160;
          *(void *)uint64_t v104 = 1752392040LL;
          *(_WORD *)&v104[8] = 1045;
          *(_DWORD *)&v104[10] = 20;
          uint64_t v105 = 2101;
          *(void *)uint64_t v106 = v91;
          *(_WORD *)&v106[8] = 2082;
          *(void *)&v106[10] = v38;
          *(_WORD *)&v106[18] = 1024;
          *(_DWORD *)&v106[20] = a8;
          uint64_t v81 = "[Q(%x, %x)] Sent a previous IPv6 mDNS query to %{sensitive, mask.hash, mdnsresponder:ip_addr}.20P over u"
                "nicast via %{public}s/%u";
LABEL_397:
          uint64_t v83 = (os_log_s *)v80;
          uint64_t v84 = 56;
          goto LABEL_398;
        }

        if ((v79 & 1) != 0)
        {
          uint64_t v82 = mDNSLogCategory_mDNS_redacted;
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
            return;
          }
          *(_DWORD *)buf = 67109376;
          uint64_t v100 = v19;
          uint64_t v101 = 1024;
          uint64_t v102 = v27;
          uint64_t v81 = "[Q(%x, %x)] Sent a previous IPv6 mDNS query over unicast";
          goto LABEL_267;
        }

        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
          return;
        }
        *(_DWORD *)buf = 67109376;
        uint64_t v100 = v19;
        uint64_t v101 = 1024;
        uint64_t v102 = v27;
        uint64_t v81 = "[Q(%x, %x)] Sent a previous IPv6 mDNS query over unicast";
      }
    }

    else if ((v97 & 0x80) != 0)
    {
      if ((v53 & 1) != 0)
      {
        if ((v46 & 1) != 0)
        {
          if ((v79 & 1) != 0)
          {
            uint64_t v80 = mDNSLogCategory_mDNS_redacted;
            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
              return;
            }
          }

          else if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
          {
            return;
          }

          *(_DWORD *)buf = 67112195;
          uint64_t v100 = v19;
          uint64_t v101 = 1024;
          uint64_t v102 = v27;
          uint64_t v103 = 1024;
          *(_DWORD *)uint64_t v104 = v93;
          *(_WORD *)&v104[4] = 2160;
          *(void *)&v104[6] = 1752392040LL;
          uint64_t v105 = 1045;
          *(_DWORD *)uint64_t v106 = 20;
          *(_WORD *)&v106[4] = 2101;
          *(void *)&v106[6] = a4;
          *(_WORD *)&v106[14] = 2082;
          *(void *)&_OWORD v106[16] = v38;
          uint64_t v107 = 1024;
          *(_DWORD *)uint64_t v108 = a8;
          *(_WORD *)&v108[4] = 2048;
          *(void *)&v108[6] = v77;
          unint64_t v109 = 2048;
          uint64_t v110 = v78;
          uint64_t v111 = 2160;
          v112 = 1752392040LL;
          uint64_t v113 = 1040;
          uint64_t v114 = v68;
          uint64_t v115 = 2101;
          uint64_t v116 = v117;
          uint64_t v81 = "[Q(%x, %x)] Received %u-byte IPv6 mDNS response from %{sensitive, mask.hash, mdnsresponder:ip_addr}.20P "
                "over unicast via %{public}s/%u -- %{mdns:dns.idflags}08lX, counts: %{mdns:dns.counts}016llX %{sensitive,"
                " mask.hash, mdnsresponder:mdns_name_hash_type_bytes}.*P";
          goto LABEL_388;
        }

        if ((v79 & 1) != 0)
        {
          uint64_t v80 = mDNSLogCategory_mDNS_redacted;
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
            return;
          }
        }

        else if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
        {
          return;
        }

        *(_DWORD *)buf = 67110659;
        uint64_t v100 = v19;
        uint64_t v101 = 1024;
        uint64_t v102 = v27;
        uint64_t v103 = 2160;
        *(void *)uint64_t v104 = 1752392040LL;
        *(_WORD *)&v104[8] = 1045;
        *(_DWORD *)&v104[10] = 20;
        uint64_t v105 = 2101;
        *(void *)uint64_t v106 = a4;
        *(_WORD *)&v106[8] = 2082;
        *(void *)&v106[10] = v38;
        *(_WORD *)&v106[18] = 1024;
        *(_DWORD *)&v106[20] = a8;
        uint64_t v81 = "[Q(%x, %x)] Received a previous IPv6 mDNS response from %{sensitive, mask.hash, mdnsresponder:ip_addr}.20P"
              " over unicast via %{public}s/%u";
        goto LABEL_397;
      }

      if ((v79 & 1) != 0)
      {
        uint64_t v82 = mDNSLogCategory_mDNS_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
          return;
        }
        *(_DWORD *)buf = 67109376;
        uint64_t v100 = v19;
        uint64_t v101 = 1024;
        uint64_t v102 = v27;
        uint64_t v81 = "[Q(%x, %x)] Received a previous IPv6 mDNS response over unicast";
        goto LABEL_267;
      }

      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
        return;
      }
      *(_DWORD *)buf = 67109376;
      uint64_t v100 = v19;
      uint64_t v101 = 1024;
      uint64_t v102 = v27;
      uint64_t v81 = "[Q(%x, %x)] Received a previous IPv6 mDNS response over unicast";
    }

    else
    {
      if ((v53 & 1) != 0)
      {
        if ((v46 & 1) != 0)
        {
          if ((v79 & 1) != 0)
          {
            uint64_t v80 = mDNSLogCategory_mDNS_redacted;
            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
              return;
            }
          }

          else if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
          {
            return;
          }

          *(_DWORD *)buf = 67112195;
          uint64_t v100 = v19;
          uint64_t v101 = 1024;
          uint64_t v102 = v27;
          uint64_t v103 = 1024;
          *(_DWORD *)uint64_t v104 = v93;
          *(_WORD *)&v104[4] = 2160;
          *(void *)&v104[6] = 1752392040LL;
          uint64_t v105 = 1045;
          *(_DWORD *)uint64_t v106 = 20;
          *(_WORD *)&v106[4] = 2101;
          *(void *)&v106[6] = a4;
          *(_WORD *)&v106[14] = 2082;
          *(void *)&_OWORD v106[16] = v38;
          uint64_t v107 = 1024;
          *(_DWORD *)uint64_t v108 = a8;
          *(_WORD *)&v108[4] = 2048;
          *(void *)&v108[6] = v77;
          unint64_t v109 = 2048;
          uint64_t v110 = v78;
          uint64_t v111 = 2160;
          v112 = 1752392040LL;
          uint64_t v113 = 1040;
          uint64_t v114 = v68;
          uint64_t v115 = 2101;
          uint64_t v116 = v117;
          uint64_t v81 = "[A(%x, %x)] Received %u-byte IPv6 mDNS query from %{sensitive, mask.hash, mdnsresponder:ip_addr}.20P ove"
                "r unicast via %{public}s/%u -- %{mdns:dns.idflags}08lX, counts: %{mdns:dns.counts}016llX %{sensitive, ma"
                "sk.hash, mdnsresponder:mdns_name_hash_type_bytes}.*P";
          goto LABEL_388;
        }

        if ((v79 & 1) != 0)
        {
          uint64_t v80 = mDNSLogCategory_mDNS_redacted;
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
            return;
          }
        }

        else if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
        {
          return;
        }

        *(_DWORD *)buf = 67110659;
        uint64_t v100 = v19;
        uint64_t v101 = 1024;
        uint64_t v102 = v27;
        uint64_t v103 = 2160;
        *(void *)uint64_t v104 = 1752392040LL;
        *(_WORD *)&v104[8] = 1045;
        *(_DWORD *)&v104[10] = 20;
        uint64_t v105 = 2101;
        *(void *)uint64_t v106 = a4;
        *(_WORD *)&v106[8] = 2082;
        *(void *)&v106[10] = v38;
        *(_WORD *)&v106[18] = 1024;
        *(_DWORD *)&v106[20] = a8;
        uint64_t v81 = "[A(%x, %x)] Received a previous IPv6 mDNS query from %{sensitive, mask.hash, mdnsresponder:ip_addr}.20P ov"
              "er unicast via %{public}s/%u";
        goto LABEL_397;
      }

      if ((v79 & 1) != 0)
      {
        uint64_t v82 = mDNSLogCategory_mDNS_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
          return;
        }
        *(_DWORD *)buf = 67109376;
        uint64_t v100 = v19;
        uint64_t v101 = 1024;
        uint64_t v102 = v27;
        uint64_t v81 = "[A(%x, %x)] Received a previous IPv6 mDNS query over unicast";
        goto LABEL_267;
      }

      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
        return;
      }
      *(_DWORD *)buf = 67109376;
      uint64_t v100 = v19;
      uint64_t v101 = 1024;
      uint64_t v102 = v27;
      uint64_t v81 = "[A(%x, %x)] Received a previous IPv6 mDNS query over unicast";
    }

    goto LABEL_344;
  }

  if (!a1)
  {
    if ((v97 & 0x80) != 0)
    {
      if ((v53 & 1) != 0)
      {
        if ((v46 & 1) != 0)
        {
          if ((v79 & 1) != 0)
          {
            uint64_t v80 = mDNSLogCategory_mDNS_redacted;
            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
              return;
            }
          }

          else if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
          {
            return;
          }

          *(_DWORD *)buf = 67112195;
          uint64_t v100 = v19;
          uint64_t v101 = 1024;
          uint64_t v102 = v27;
          uint64_t v103 = 1024;
          *(_DWORD *)uint64_t v104 = v93;
          *(_WORD *)&v104[4] = 2160;
          *(void *)&v104[6] = 1752392040LL;
          uint64_t v105 = 1045;
          *(_DWORD *)uint64_t v106 = 20;
          *(_WORD *)&v106[4] = 2101;
          *(void *)&v106[6] = a4;
          *(_WORD *)&v106[14] = 2082;
          *(void *)&_OWORD v106[16] = v38;
          uint64_t v107 = 1024;
          *(_DWORD *)uint64_t v108 = a8;
          *(_WORD *)&v108[4] = 2048;
          *(void *)&v108[6] = v77;
          unint64_t v109 = 2048;
          uint64_t v110 = v78;
          uint64_t v111 = 2160;
          v112 = 1752392040LL;
          uint64_t v113 = 1040;
          uint64_t v114 = v68;
          uint64_t v115 = 2101;
          uint64_t v116 = v117;
          uint64_t v81 = "[Q(%x, %x)] Received %u-byte IPv4 mDNS response from %{sensitive, mask.hash, mdnsresponder:ip_addr}.20P "
                "over unicast via %{public}s/%u -- %{mdns:dns.idflags}08lX, counts: %{mdns:dns.counts}016llX %{sensitive,"
                " mask.hash, mdnsresponder:mdns_name_hash_type_bytes}.*P";
          goto LABEL_388;
        }

        if ((v79 & 1) != 0)
        {
          uint64_t v80 = mDNSLogCategory_mDNS_redacted;
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
            return;
          }
        }

        else if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
        {
          return;
        }

        *(_DWORD *)buf = 67110659;
        uint64_t v100 = v19;
        uint64_t v101 = 1024;
        uint64_t v102 = v27;
        uint64_t v103 = 2160;
        *(void *)uint64_t v104 = 1752392040LL;
        *(_WORD *)&v104[8] = 1045;
        *(_DWORD *)&v104[10] = 20;
        uint64_t v105 = 2101;
        *(void *)uint64_t v106 = a4;
        *(_WORD *)&v106[8] = 2082;
        *(void *)&v106[10] = v38;
        *(_WORD *)&v106[18] = 1024;
        *(_DWORD *)&v106[20] = a8;
        uint64_t v81 = "[Q(%x, %x)] Received a previous IPv4 mDNS response from %{sensitive, mask.hash, mdnsresponder:ip_addr}.20P"
              " over unicast via %{public}s/%u";
        goto LABEL_397;
      }

      if ((v79 & 1) != 0)
      {
        uint64_t v82 = mDNSLogCategory_mDNS_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
          return;
        }
        *(_DWORD *)buf = 67109376;
        uint64_t v100 = v19;
        uint64_t v101 = 1024;
        uint64_t v102 = v27;
        uint64_t v81 = "[Q(%x, %x)] Received a previous IPv4 mDNS response over unicast";
        goto LABEL_267;
      }

      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
        return;
      }
      *(_DWORD *)buf = 67109376;
      uint64_t v100 = v19;
      uint64_t v101 = 1024;
      uint64_t v102 = v27;
      uint64_t v81 = "[Q(%x, %x)] Received a previous IPv4 mDNS response over unicast";
    }

    else
    {
      if ((v53 & 1) != 0)
      {
        if ((v46 & 1) != 0)
        {
          if ((v79 & 1) != 0)
          {
            uint64_t v80 = mDNSLogCategory_mDNS_redacted;
            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
              return;
            }
          }

          else if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
          {
            return;
          }

          *(_DWORD *)buf = 67112195;
          uint64_t v100 = v19;
          uint64_t v101 = 1024;
          uint64_t v102 = v27;
          uint64_t v103 = 1024;
          *(_DWORD *)uint64_t v104 = v93;
          *(_WORD *)&v104[4] = 2160;
          *(void *)&v104[6] = 1752392040LL;
          uint64_t v105 = 1045;
          *(_DWORD *)uint64_t v106 = 20;
          *(_WORD *)&v106[4] = 2101;
          *(void *)&v106[6] = a4;
          *(_WORD *)&v106[14] = 2082;
          *(void *)&_OWORD v106[16] = v38;
          uint64_t v107 = 1024;
          *(_DWORD *)uint64_t v108 = a8;
          *(_WORD *)&v108[4] = 2048;
          *(void *)&v108[6] = v77;
          unint64_t v109 = 2048;
          uint64_t v110 = v78;
          uint64_t v111 = 2160;
          v112 = 1752392040LL;
          uint64_t v113 = 1040;
          uint64_t v114 = v68;
          uint64_t v115 = 2101;
          uint64_t v116 = v117;
          uint64_t v81 = "[A(%x, %x)] Received %u-byte IPv4 mDNS query from %{sensitive, mask.hash, mdnsresponder:ip_addr}.20P ove"
                "r unicast via %{public}s/%u -- %{mdns:dns.idflags}08lX, counts: %{mdns:dns.counts}016llX %{sensitive, ma"
                "sk.hash, mdnsresponder:mdns_name_hash_type_bytes}.*P";
          goto LABEL_388;
        }

        if ((v79 & 1) != 0)
        {
          uint64_t v80 = mDNSLogCategory_mDNS_redacted;
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
            return;
          }
        }

        else if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
        {
          return;
        }

        *(_DWORD *)buf = 67110659;
        uint64_t v100 = v19;
        uint64_t v101 = 1024;
        uint64_t v102 = v27;
        uint64_t v103 = 2160;
        *(void *)uint64_t v104 = 1752392040LL;
        *(_WORD *)&v104[8] = 1045;
        *(_DWORD *)&v104[10] = 20;
        uint64_t v105 = 2101;
        *(void *)uint64_t v106 = a4;
        *(_WORD *)&v106[8] = 2082;
        *(void *)&v106[10] = v38;
        *(_WORD *)&v106[18] = 1024;
        *(_DWORD *)&v106[20] = a8;
        uint64_t v81 = "[A(%x, %x)] Received a previous IPv4 mDNS query from %{sensitive, mask.hash, mdnsresponder:ip_addr}.20P ov"
              "er unicast via %{public}s/%u";
        goto LABEL_397;
      }

      if ((v79 & 1) != 0)
      {
        uint64_t v82 = mDNSLogCategory_mDNS_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
          return;
        }
        *(_DWORD *)buf = 67109376;
        uint64_t v100 = v19;
        uint64_t v101 = 1024;
        uint64_t v102 = v27;
        uint64_t v81 = "[A(%x, %x)] Received a previous IPv4 mDNS query over unicast";
        goto LABEL_267;
      }

      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
        return;
      }
      *(_DWORD *)buf = 67109376;
      uint64_t v100 = v19;
      uint64_t v101 = 1024;
      uint64_t v102 = v27;
      uint64_t v81 = "[A(%x, %x)] Received a previous IPv4 mDNS query over unicast";
    }

    goto LABEL_344;
  }

  if ((v97 & 0x80) != 0)
  {
    if ((v53 & 1) != 0)
    {
      if ((v46 & 1) != 0)
      {
        if ((v79 & 1) != 0)
        {
          uint64_t v80 = mDNSLogCategory_mDNS_redacted;
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
            return;
          }
        }

        else if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
        {
          return;
        }

        *(_DWORD *)buf = 67112195;
        uint64_t v100 = v19;
        uint64_t v101 = 1024;
        uint64_t v102 = v27;
        uint64_t v103 = 1024;
        *(_DWORD *)uint64_t v104 = v93;
        *(_WORD *)&v104[4] = 2160;
        *(void *)&v104[6] = 1752392040LL;
        uint64_t v105 = 1045;
        *(_DWORD *)uint64_t v106 = 20;
        *(_WORD *)&v106[4] = 2101;
        *(void *)&v106[6] = v91;
        *(_WORD *)&v106[14] = 2082;
        *(void *)&_OWORD v106[16] = v38;
        uint64_t v107 = 1024;
        *(_DWORD *)uint64_t v108 = a8;
        *(_WORD *)&v108[4] = 2048;
        *(void *)&v108[6] = v77;
        unint64_t v109 = 2048;
        uint64_t v110 = v78;
        uint64_t v111 = 2160;
        v112 = 1752392040LL;
        uint64_t v113 = 1040;
        uint64_t v114 = v68;
        uint64_t v115 = 2101;
        uint64_t v116 = v117;
        uint64_t v81 = "[A(%x, %x)] Sent %u-byte IPv4 mDNS response to %{sensitive, mask.hash, mdnsresponder:ip_addr}.20P over uni"
              "cast via %{public}s/%u -- %{mdns:dns.idflags}08lX, counts: %{mdns:dns.counts}016llX %{sensitive, mask.hash"
              ", mdnsresponder:mdns_name_hash_type_bytes}.*P";
        goto LABEL_388;
      }

      if ((v79 & 1) != 0)
      {
        uint64_t v80 = mDNSLogCategory_mDNS_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
          return;
        }
      }

      else if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
      {
        return;
      }

      *(_DWORD *)buf = 67110659;
      uint64_t v100 = v19;
      uint64_t v101 = 1024;
      uint64_t v102 = v27;
      uint64_t v103 = 2160;
      *(void *)uint64_t v104 = 1752392040LL;
      *(_WORD *)&v104[8] = 1045;
      *(_DWORD *)&v104[10] = 20;
      uint64_t v105 = 2101;
      *(void *)uint64_t v106 = v91;
      *(_WORD *)&v106[8] = 2082;
      *(void *)&v106[10] = v38;
      *(_WORD *)&v106[18] = 1024;
      *(_DWORD *)&v106[20] = a8;
      uint64_t v81 = "[A(%x, %x)] Sent a previous IPv4 mDNS response to %{sensitive, mask.hash, mdnsresponder:ip_addr}.20P over un"
            "icast via %{public}s/%u";
      goto LABEL_397;
    }

    if ((v79 & 1) != 0)
    {
      uint64_t v82 = mDNSLogCategory_mDNS_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
        return;
      }
      *(_DWORD *)buf = 67109376;
      uint64_t v100 = v19;
      uint64_t v101 = 1024;
      uint64_t v102 = v27;
      uint64_t v81 = "[A(%x, %x)] Sent a previous IPv4 mDNS response over unicast";
      goto LABEL_267;
    }

    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    *(_DWORD *)buf = 67109376;
    uint64_t v100 = v19;
    uint64_t v101 = 1024;
    uint64_t v102 = v27;
    uint64_t v81 = "[A(%x, %x)] Sent a previous IPv4 mDNS response over unicast";
    goto LABEL_344;
  }

  if ((v53 & 1) != 0)
  {
    if ((v46 & 1) != 0)
    {
      if ((v79 & 1) != 0)
      {
        uint64_t v80 = mDNSLogCategory_mDNS_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
          return;
        }
      }

      else if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
      {
        return;
      }

      *(_DWORD *)buf = 67112195;
      uint64_t v100 = v19;
      uint64_t v101 = 1024;
      uint64_t v102 = v27;
      uint64_t v103 = 1024;
      *(_DWORD *)uint64_t v104 = v93;
      *(_WORD *)&v104[4] = 2160;
      *(void *)&v104[6] = 1752392040LL;
      uint64_t v105 = 1045;
      *(_DWORD *)uint64_t v106 = 20;
      *(_WORD *)&v106[4] = 2101;
      *(void *)&v106[6] = v91;
      *(_WORD *)&v106[14] = 2082;
      *(void *)&_OWORD v106[16] = v38;
      uint64_t v107 = 1024;
      *(_DWORD *)uint64_t v108 = a8;
      *(_WORD *)&v108[4] = 2048;
      *(void *)&v108[6] = v77;
      unint64_t v109 = 2048;
      uint64_t v110 = v78;
      uint64_t v111 = 2160;
      v112 = 1752392040LL;
      uint64_t v113 = 1040;
      uint64_t v114 = v68;
      uint64_t v115 = 2101;
      uint64_t v116 = v117;
      uint64_t v81 = "[Q(%x, %x)] Sent %u-byte IPv4 mDNS query to %{sensitive, mask.hash, mdnsresponder:ip_addr}.20P over unicast "
            "via %{public}s/%u -- %{mdns:dns.idflags}08lX, counts: %{mdns:dns.counts}016llX %{sensitive, mask.hash, mdnsr"
            "esponder:mdns_name_hash_type_bytes}.*P";
LABEL_388:
      uint64_t v83 = (os_log_s *)v80;
      uint64_t v84 = 108;
      goto LABEL_398;
    }

    if ((v79 & 1) != 0)
    {
      uint64_t v80 = mDNSLogCategory_mDNS_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
        return;
      }
    }

    else if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
    {
      return;
    }

    *(_DWORD *)buf = 67110659;
    uint64_t v100 = v19;
    uint64_t v101 = 1024;
    uint64_t v102 = v27;
    uint64_t v103 = 2160;
    *(void *)uint64_t v104 = 1752392040LL;
    *(_WORD *)&v104[8] = 1045;
    *(_DWORD *)&v104[10] = 20;
    uint64_t v105 = 2101;
    *(void *)uint64_t v106 = v91;
    *(_WORD *)&v106[8] = 2082;
    *(void *)&v106[10] = v38;
    *(_WORD *)&v106[18] = 1024;
    *(_DWORD *)&v106[20] = a8;
    uint64_t v81 = "[Q(%x, %x)] Sent a previous IPv4 mDNS query to %{sensitive, mask.hash, mdnsresponder:ip_addr}.20P over unicast"
          " via %{public}s/%u";
    goto LABEL_397;
  }

  if ((v79 & 1) == 0)
  {
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    *(_DWORD *)buf = 67109376;
    uint64_t v100 = v19;
    uint64_t v101 = 1024;
    uint64_t v102 = v27;
    uint64_t v81 = "[Q(%x, %x)] Sent a previous IPv4 mDNS query over unicast";
    goto LABEL_344;
  }

  uint64_t v82 = mDNSLogCategory_mDNS_redacted;
  if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
    return;
  }
  *(_DWORD *)buf = 67109376;
  uint64_t v100 = v19;
  uint64_t v101 = 1024;
  uint64_t v102 = v27;
  uint64_t v81 = "[Q(%x, %x)] Sent a previous IPv4 mDNS query over unicast";
LABEL_267:
  uint64_t v83 = (os_log_s *)v82;
LABEL_345:
  uint64_t v84 = 14;
LABEL_398:
  _os_log_impl((void *)&_mh_execute_header, v83, OS_LOG_TYPE_DEFAULT, v81, buf, v84);
}

          ref_count_obj_release(v12);
          goto LABEL_59;
        }

        free((void *)v5);
        os_release((void *)v15);
        goto LABEL_56;
      }

void mDNS_SetFQDN(uint64_t a1)
{
  if (AppendDomainLabel(v32, (unsigned __int8 *)(a1 + 10352)) && AppendLiteralLabelString(v32, "local"))
  {
    mDNS_Lock_((unsigned int *)a1, (uint64_t)"mDNS_SetFQDN", 16638);
    os_log_type_t v7 = (uint64_t *)v32;
    if (!SameDomainNameCS((_BYTE *)(a1 + 10416), v32))
    {
      while (v7 < &v33)
      {
        if (!v7) {
          break;
        }
        uint64_t v15 = *(unsigned __int8 *)v7;
        if (!*(_BYTE *)v7)
        {
          if ((unsigned __int16)((_WORD)v7 - (unsigned __int16)v32 + 1) <= 0x100u)
          {
            memcpy((void *)(a1 + 10416), v32, (unsigned __int16)((_WORD)v7 - (unsigned __int16)v32 + 1));
            goto LABEL_13;
          }

          break;
        }

        os_log_type_t v7 = (uint64_t *)((char *)v7 + v15 + 1);
      }

      *(_BYTE *)(a1 + 10416) = 0;
LABEL_13:
      DeadvertiseAllInterfaceRecords(a1, 1);
      AdvertiseNecessaryInterfaceRecords(a1);
    }

    for (uint64_t i = *(void *)(a1 + 12624); i; uint64_t i = *(void *)i)
    {
      if (*(_BYTE *)(i + 120))
      {
        D2D_stop_advertising_record(i, v8, v9, v10, v11, v12, v13, v14);
        SetTargetToHostName(a1, i);
        D2D_start_advertising_record(i, v17, v18, v19, v20, v21, v22, v23);
      }
    }

    for (uint64_t j = *(void *)(a1 + 12632); j; uint64_t j = *(void *)j)
    {
      if (*(_BYTE *)(j + 120))
      {
        D2D_stop_advertising_record(j, v8, v9, v10, v11, v12, v13, v14);
        SetTargetToHostName(a1, j);
        D2D_start_advertising_record(j, v25, v26, v27, v28, v29, v30, v31);
      }
    }

    mDNS_Unlock_(a1, (uint64_t)"mDNS_SetFQDN", 16652);
  }

  else
  {
    LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "ERROR: mDNS_SetFQDN: Cannot create MulticastHostname",  v2,  v3,  v4,  v5,  v6,  v32[0]);
  }

uint64_t AppendDomainLabel(_BYTE *a1, unsigned __int8 *a2)
{
  unint64_t v2 = (unint64_t)(a1 + 256);
  uint64_t v3 = 257LL;
  uint64_t v4 = a1;
  if (a1 == (_BYTE *)-256LL)
  {
LABEL_3:
    while (v4)
    {
      uint64_t v5 = *v4;
      if (!*v4)
      {
        uint64_t v3 = (unsigned __int16)((_WORD)v4 - (_WORD)a1 + 1);
        break;
      }

      v4 += v5 + 1;
      if (a1 != (_BYTE *)-256LL) {
        goto LABEL_2;
      }
    }
  }

  else
  {
LABEL_2:
  }

  uint64_t v6 = &a1[v3];
  unint64_t v7 = *a2;
  unint64_t v10 = -1LL;
  do
  {
    v6[v10] = a2[v10 + 1];
    ++v10;
  }

  while (v10 < *a2);
  uint64_t result = (uint64_t)&v6[v10 + 1];
  v6[v10] = 0;
  return result;
}

_BYTE *AppendLiteralLabelString(_BYTE *a1, char *a2)
{
  uint64_t v2 = 257LL;
  uint64_t v3 = a1;
  if (a1 == (_BYTE *)-256LL)
  {
LABEL_3:
    while (v3)
    {
      uint64_t v4 = *v3;
      if (!*v3)
      {
        uint64_t v2 = (unsigned __int16)((_WORD)v3 - (_WORD)a1 + 1);
        break;
      }

      v3 += v4 + 1;
      if (a1 != (_BYTE *)-256LL) {
        goto LABEL_2;
      }
    }
  }

  else
  {
LABEL_2:
    if (v3 < a1 + 256) {
      goto LABEL_3;
    }
  }

  uint64_t v5 = &a1[v2];
  unint64_t v6 = (unint64_t)(v5 + 63);
  if (a1 + 255 < v5 + 63) {
    unint64_t v6 = (unint64_t)(a1 + 255);
  }
  char v7 = *a2;
  uint64_t v8 = v5;
  if (*a2) {
    BOOL v9 = (unint64_t)v5 >= v6;
  }
  else {
    BOOL v9 = 1;
  }
  if (!v9)
  {
    do
    {
      *v8++ = v7;
      int v10 = *++a2;
      char v7 = v10;
      if (v10) {
        BOOL v11 = (unint64_t)v8 >= v6;
      }
      else {
        BOOL v11 = 1;
      }
    }

    while (!v11);
  }

  *(v5 - 1) = (_BYTE)v8 - (_BYTE)v5;
  *uint64_t v8 = 0;
  uint64_t v12 = v8 + 1;
  if (*a2) {
    return 0LL;
  }
  else {
    return v12;
  }
}

void mDNS_Lock_(unsigned int *a1, uint64_t a2, int a3)
{
  unsigned int v13 = a1[12];
  int v14 = a1[16];
  if (!v13)
  {
    if (!v14) {
      goto LABEL_23;
    }
    uint64_t v17 = mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      BOOL v5 = os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT);
      if (!v5) {
        goto LABEL_23;
      }
    }

    else
    {
      uint64_t v17 = mDNSLogCategory_Default_redacted;
      BOOL v5 = os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT);
      if (!v5) {
        goto LABEL_23;
      }
    }

    unsigned int v22 = a1[15] + mDNSPlatformRawTime(v5, v6, v7, v8, v9, v10, v11, v12);
    int v29 = 136446722;
    uint64_t v30 = a2;
    __int16 v31 = 1024;
    int v32 = v14;
    __int16 v33 = 1024;
    unsigned int v34 = v22;
    uint64_t v19 = "%{public}s: mDNS_Lock: m->timenow already set (%u/%u)";
    uint64_t v20 = (os_log_s *)v17;
    uint32_t v21 = 24;
    goto LABEL_22;
  }

  if (v14) {
    goto LABEL_27;
  }
  uint64_t v15 = mDNSLogCategory_Default;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
  {
    BOOL v5 = os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT);
    if (v5)
    {
LABEL_19:
      int v29 = 136446466;
      uint64_t v30 = a2;
      __int16 v31 = 1024;
      int v32 = v13;
      uint64_t v19 = "%{public}s: mDNS_Lock: m->mDNS_busy is %u but m->timenow not set";
      uint64_t v20 = (os_log_s *)v15;
      uint32_t v21 = 18;
LABEL_22:
      _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, v19, (uint8_t *)&v29, v21);
    }
  }

  else
  {
    uint64_t v15 = mDNSLogCategory_Default_redacted;
    BOOL v5 = os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT);
    if (v5) {
      goto LABEL_19;
    }
  }

LABEL_23:
  unsigned int v23 = a1[15] + mDNSPlatformRawTime(v5, v6, v7, v8, v9, v10, v11, v12);
  if (v23 <= 1) {
    int v14 = 1;
  }
  else {
    int v14 = v23;
  }
  a1[16] = v14;
LABEL_27:
  int v24 = a1[17] - v14;
  if (v24 >= 1)
  {
    unsigned int v25 = a1[15] + v24;
    a1[15] = v25;
    uint64_t v26 = (os_log_s *)mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
      {
LABEL_37:
        int v14 = a1[17];
        a1[16] = v14;
        goto LABEL_38;
      }
    }

    else
    {
      uint64_t v26 = (os_log_s *)mDNSLogCategory_Default_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_37;
      }
    }

    int v29 = 136446722;
    uint64_t v30 = a2;
    __int16 v31 = 1024;
    int v32 = v24;
    __int16 v33 = 1024;
    unsigned int v34 = v25;
    _os_log_impl( (void *)&_mh_execute_header,  v26,  OS_LOG_TYPE_DEFAULT,  "%{public}s: mDNSPlatformRawTime went backwards by %d ticks; setting correction factor to %d",
      (uint8_t *)&v29,
      0x18u);
    goto LABEL_37;
  }

  uint64_t v8 = 0LL;
  return v8;
}

    if (v20)
    {
      while (1)
      {
        unsigned int v22 = *v20;
        if (!*v20)
        {
          uint32_t v21 = (_WORD)v14 - (_WORD)v20 + 1;
          goto LABEL_30;
        }

        v20 += v22 + 1;
LABEL_20:
        if (v20 >= v13 + 260 || !v20) {
          goto LABEL_30;
        }
      }
    }

    uint32_t v21 = -255;
LABEL_30:
    unsigned int v23 = RRAssertsExistence(a1, 0x2Fu, a3, a4, a5, a6, a7, a8);
    uint64_t v12 = *(_WORD *)(a1 + 12);
    if (a2) {
      int v24 = v21;
    }
    else {
      int v24 = 0;
    }
    unsigned int v25 = v24 + v12;
    if (!v23) {
      return v25;
    }
  }

  return v12;
}

        uint64_t v18 = *(void *)(v17 + 6256);
        uint64_t v19 = (unint64_t)(v18 + 3) < 2 || v18 == -5;
        if (!v19)
        {
          if (v18)
          {
            uint64_t v20 = *(void *)(v17 + 6256);
          }

          else
          {
            LODWORD(v20) = 0;
          }
        }

  *(_DWORD *)buf = 141558787;
  int v49 = 1752392040LL;
  uint64_t v50 = 1040;
  uint64_t v51 = (unsigned __int16)v20;
  uint64_t v52 = 2101;
  int v53 = __src;
  uint64_t v54 = 1024;
  uint64_t v55 = a3;
  _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "internal_start_browsing_for_service: starting browse - qname: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P, qtype: %{mdns:rrtype}d",  buf,  0x22u);
LABEL_24:
  uint32_t v21 = putDomainNameAsLabels( (unint64_t)&compression_base_msg,  (unint64_t)&unk_100149887,  (unint64_t)&compression_base_msg + &unk_1000022F8,  (unsigned __int8 *)__src,  v12,  v13,  v14,  v15);
  if (v21)
  {
    *uint32_t v21 = BYTE1(a3);
    v21[1] = a3;
    v21[2] = 1;
    unsigned int v22 = v21 + 3;
  }

  else
  {
    unsigned int v22 = 0LL;
  }

  unsigned int v23 = v22 - (_BYTE *)&unk_100149887;
  PrintHelper( (uint64_t)"internal_start_browsing_for_service",  (uint64_t)&unk_100149887,  (unsigned __int16)(v22 - (_BYTE *)&unk_100149887),  0LL,  0);
  int v24 = xD2DMapToTransportType(a1, a4, &v46);
  if ((_DWORD)v24 == 4)
  {
    unsigned int v25 = 0LL;
    uint64_t v26 = v46;
    do
    {
      if (v26 != (_DWORD)v25 && &_D2DStartBrowsingForKeyOnTransport)
      {
        if ((v25 & 0x7FFFFFFE) == 2) {
          _mdns_powerlog_awdl_event((uint64_t)@"startAWDLBrowse", a2, a3, a5);
        }
        D2DStartBrowsingForKeyOnTransport(&unk_100149887, v23, v25);
      }

      unsigned int v25 = (v25 + 1);
    }

    while ((_DWORD)v25 != 4);
  }

  else if (&_D2DStartBrowsingForKeyOnTransport)
  {
    uint64_t v27 = v24;
    if ((v24 & 6) == 2) {
      _mdns_powerlog_awdl_event((uint64_t)@"startAWDLBrowse", a2, a3, a5);
    }
    D2DStartBrowsingForKeyOnTransport(&unk_100149887, v23, v27);
  }

    uint64_t v15 = 0;
    uint64_t result = dns_obj_domain_name_create_with_labels(v16, &v15);
    if (a2) {
LABEL_24:
    }
      *a2 = v15;
    return result;
  }

  mDNS_Unlock_((uint64_t)mDNSStorage, (uint64_t)"mDNS_StopDomainEnumeration", 16194);
LABEL_24:
  __int128 v36 = *(unsigned int **)(v9 + 272);
  if (v36)
  {
    uint64_t v74 = (unsigned __int8 *)(v9 + 10);
    CFStringEncoding v37 = (int *)(a1 + 188);
    uint64_t v38 = (_DWORD *)(a1 + 192);
    uint64_t v73 = v9;
    do
    {
      if (callExternalHelpers(*((void *)v36 + 50), (_BYTE *)v36 + 8, v36[142], a4, a5, a6, a7, a8))
      {
        uint64_t v87 = 0u;
        uint64_t v88 = 0u;
        int v85 = 0u;
        __int128 v86 = 0u;
        uint64_t v83 = 0u;
        uint64_t v84 = 0u;
        uint64_t v81 = 0u;
        uint64_t v82 = 0u;
        uint64_t v79 = 0u;
        uint64_t v80 = 0u;
        uint64_t v77 = 0u;
        uint64_t v78 = 0u;
        uint64_t v76 = 0u;
        memset(__tp, 0, sizeof(__tp));
        ConstructServiceName(__tp, 0LL, v74, (_BYTE *)v36 + 8);
        external_stop_browsing_for_service( *((void *)v36 + 50),  (unsigned __int8 *)__tp,  12,  v36[142],  *(_DWORD *)(a1 + 172));
      }

      BOOL v39 = _shouldLogFullRequestInfo(v37, v38);
      BOOL v40 = (_WORD)v36 + 620;
      int v41 = v10[1384];
      uint64_t v42 = (os_log_s *)*((void *)v11 + 145);
      if (v42 == v12[171]) {
        int v41 = 0;
      }
      if (v39)
      {
        if ((v41 & 1) != 0)
        {
          int v43 = mDNSLogCategory_mDNS_redacted;
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
          {
            int v44 = *(_DWORD *)(a1 + 184);
            int v45 = v36 + 155;
            if (v36 == (unsigned int *)-876LL)
            {
LABEL_35:
              while (v45)
              {
                int v46 = *v45;
                if (!*v45)
                {
                  int v53 = (_WORD)v45 - v40 + 1;
                  goto LABEL_56;
                }

                v45 += v46 + 1;
              }
            }

            else
            {
LABEL_34:
              if (v45 < (_BYTE *)v36 + 876) {
                goto LABEL_35;
              }
            }

            int v53 = 257;
LABEL_56:
            uint64_t v55 = v53;
            int v56 = *(_DWORD *)(a1 + 232);
            uint64_t v57 = *(_DWORD *)(a1 + 236);
            uint64_t v58 = *(_DWORD *)(a1 + 172);
            uint64_t v59 = mDNS_DomainNameFNV1aHash((unsigned __int8 *)v36 + 620);
            __tp[0].tv_sec = 0LL;
            __tp[0].tv_nsec = 0LL;
            clock_gettime(_CLOCK_MONOTONIC_RAW, __tp);
            uint64_t v60 = LODWORD(__tp[0].tv_sec) - *(_DWORD *)(a1 + 188);
            LODWORD(__tp[0].tv_sec) = 67111427;
            HIDWORD(__tp[0].tv_sec) = v44;
            LOWORD(__tp[0].tv_nsec) = 2160;
            *(uint64_t *)((char *)&__tp[0].tv_nsec + 2) = 1752392040LL;
            WORD1(__tp[1].tv_sec) = 1040;
            HIDWORD(__tp[1].tv_sec) = v55;
            LOWORD(__tp[1].tv_nsec) = 2101;
            *(uint64_t *)((char *)&__tp[1].tv_nsec + 2) = (uint64_t)(v36 + 155);
            WORD1(__tp[2].tv_sec) = 1024;
            HIDWORD(__tp[2].tv_sec) = v56;
            LOWORD(__tp[2].tv_nsec) = 1024;
            *(_DWORD *)((char *)&__tp[2].tv_nsec + 2) = v57;
            HIWORD(__tp[2].tv_nsec) = 1024;
            LODWORD(v76) = v58;
            WORD2(v76) = 2082;
            *(void *)((char *)&v76 + 6) = a1 + 240;
            HIWORD(v76) = 1024;
            LODWORD(v77) = v59;
            WORD2(v77) = 1024;
            *(_DWORD *)((char *)&v77 + 6) = v60;
            uint64_t v61 = (os_log_s *)v43;
LABEL_59:
            _os_log_impl( (void *)&_mh_execute_header,  v61,  OS_LOG_TYPE_DEFAULT,  "[R%u] DNSServiceBrowse STOP -- service name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P, flags: 0x%X, interface index: %d, client pid: %d (%{public}s), name hash: %x, duration: %{mdns:time_duration}u",  (uint8_t *)__tp,  0x4Au);
            uint64_t v9 = v73;
            uint64_t v38 = (_DWORD *)(a1 + 192);
            uint64_t v10 = (_BYTE *)&unk_100164000;
            uint64_t v11 = &unk_100150000;
            uint64_t v12 = (os_log_s **)&unk_100164000;
            CFStringEncoding v37 = (int *)(a1 + 188);
          }
        }

        else if (os_log_type_enabled(*((os_log_t *)v11 + 145), OS_LOG_TYPE_DEFAULT))
        {
          int v47 = *(_DWORD *)(a1 + 184);
          CFTypeID v48 = v36 + 155;
          if (v36 == (unsigned int *)-876LL)
          {
LABEL_46:
            while (v48)
            {
              int v49 = *v48;
              if (!*v48)
              {
                uint64_t v54 = (_WORD)v48 - v40 + 1;
                goto LABEL_58;
              }

              v48 += v49 + 1;
            }
          }

          else
          {
LABEL_45:
            if (v48 < (_BYTE *)v36 + 876) {
              goto LABEL_46;
            }
          }

          uint64_t v54 = 257;
LABEL_58:
          uint64_t v62 = v54;
          uint64_t v63 = *(_DWORD *)(a1 + 232);
          uint64_t v64 = *(_DWORD *)(a1 + 236);
          uint64_t v65 = *(_DWORD *)(a1 + 172);
          uint64_t v66 = mDNS_DomainNameFNV1aHash((unsigned __int8 *)v36 + 620);
          __tp[0].tv_sec = 0LL;
          __tp[0].tv_nsec = 0LL;
          clock_gettime(_CLOCK_MONOTONIC_RAW, __tp);
          uint64_t v67 = LODWORD(__tp[0].tv_sec) - *(_DWORD *)(a1 + 188);
          LODWORD(__tp[0].tv_sec) = 67111427;
          HIDWORD(__tp[0].tv_sec) = v47;
          LOWORD(__tp[0].tv_nsec) = 2160;
          *(uint64_t *)((char *)&__tp[0].tv_nsec + 2) = 1752392040LL;
          WORD1(__tp[1].tv_sec) = 1040;
          HIDWORD(__tp[1].tv_sec) = v62;
          LOWORD(__tp[1].tv_nsec) = 2101;
          *(uint64_t *)((char *)&__tp[1].tv_nsec + 2) = (uint64_t)(v36 + 155);
          WORD1(__tp[2].tv_sec) = 1024;
          HIDWORD(__tp[2].tv_sec) = v63;
          LOWORD(__tp[2].tv_nsec) = 1024;
          *(_DWORD *)((char *)&__tp[2].tv_nsec + 2) = v64;
          HIWORD(__tp[2].tv_nsec) = 1024;
          LODWORD(v76) = v65;
          WORD2(v76) = 2082;
          *(void *)((char *)&v76 + 6) = a1 + 240;
          HIWORD(v76) = 1024;
          LODWORD(v77) = v66;
          WORD2(v77) = 1024;
          *(_DWORD *)((char *)&v77 + 6) = v67;
          uint64_t v61 = v42;
          goto LABEL_59;
        }
      }

      else if ((v41 & 1) != 0)
      {
        uint64_t v42 = (os_log_s *)mDNSLogCategory_mDNS_redacted;
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_52;
        }
      }

      else if (os_log_type_enabled(*((os_log_t *)v11 + 145), OS_LOG_TYPE_DEFAULT))
      {
LABEL_52:
        uint64_t v50 = *(_DWORD *)(a1 + 184);
        uint64_t v51 = mDNS_DomainNameFNV1aHash((unsigned __int8 *)v36 + 620);
        __tp[0].tv_sec = 0LL;
        __tp[0].tv_nsec = 0LL;
        clock_gettime(_CLOCK_MONOTONIC_RAW, __tp);
        uint64_t v52 = LODWORD(__tp[0].tv_sec) - *(_DWORD *)(a1 + 188);
        LODWORD(__tp[0].tv_sec) = 67109632;
        HIDWORD(__tp[0].tv_sec) = v50;
        LOWORD(__tp[0].tv_nsec) = 1024;
        *(_DWORD *)((char *)&__tp[0].tv_nsec + 2) = v51;
        uint64_t v38 = (_DWORD *)(a1 + 192);
        CFStringEncoding v37 = (int *)(a1 + 188);
        HIWORD(__tp[0].tv_nsec) = 1024;
        LODWORD(__tp[1].tv_sec) = v52;
        _os_log_impl( (void *)&_mh_execute_header,  v42,  OS_LOG_TYPE_DEFAULT,  "[R%u] DNSServiceBrowse STOP -- name hash: %x, duration: %{mdns:time_duration}u",  (uint8_t *)__tp,  0x14u);
      }

      *(void *)(v9 + 272) = *(void *)v36;
      mDNS_StopQuery((unsigned int *)mDNSStorage, (uint64_t)(v36 + 66));
      if (mDNS_McastLoggingEnabled) {
        LogMcastQuestion((uint64_t)(v36 + 66), a1, 0);
      }
      free(v36);
      __int128 v36 = *(unsigned int **)(v9 + 272);
    }

    while (v36);
  }

  uint64_t v68 = *(void *)(a1 + 8);
  if (v68)
  {
    uint64_t v69 = *(unsigned int *)(a1 + 236);
    if ((_DWORD)v69)
    {
      if (AWDLInterfaceID && AWDLInterfaceID == v69)
      {
        uint64_t v70 = 1;
      }

      else
      {
        if (WiFiAwareInterfaceID) {
          uint64_t v71 = WiFiAwareInterfaceID == v69;
        }
        else {
          uint64_t v71 = 0;
        }
        uint64_t v70 = v71;
      }
    }

    else
    {
      uint64_t v70 = (*(unsigned __int8 *)(a1 + 234) >> 4) & 1;
    }

    bzero(__tp, 0x3F1uLL);
    service_type_from_domain_name = _mdns_get_service_type_from_domain_name( (unsigned __int8 *)(v9 + 10),  (unsigned __int8 *)__tp);
    _mdns_powerlog_bonjour_event(3u, v70, (const char *)(a1 + 240), (const char *)service_type_from_domain_name, v68);
    *(void *)(a1 + 8) = 0LL;
  }

    if ((unint64_t)++v17 >= a1[5])
    {
      __int128 v35 = 0LL;
      a4 = v105;
      goto LABEL_42;
    }
  }

  uint64_t v30 = *(_BYTE **)(v24 + 24);
  if ((*v30 & 1) == 0)
  {
    __int16 v33 = -88888;
    goto LABEL_40;
  }

  __int16 v31 = *(void *)(v18 + 24);
  int v32 = v30[3];
  __int16 v33 = -89895;
  __int16 v33 = -89895;
  if (ref_count_obj_compare(*(void *)(v18 + 80), *(void *)(v24 + 16), 1LL))
  {
    __int16 v33 = -89895;
    goto LABEL_40;
  }

  uint64_t v106 = 0;
  CFStringEncoding v37 = a1[2];
  uint64_t v38 = a1[3];
  if (v38)
  {
    BOOL v39 = *(void *)(v18 + 24);
    BOOL v40 = bswap32(*(_DWORD *)(v39 + 4));
    int v41 = *(_BYTE *)(v39 + 3);
    uint64_t v42 = (uint64_t *)a1[2];
    int v43 = a1[3];
    do
    {
      int v44 = *v42++;
      *(_DWORD *)(v44 + 44) = v40;
      *(_BYTE *)(v44 + 48) = v41;
      --v43;
    }

    while (v43);
  }

  dnssec_objs_sort(v37, v38);
  int v45 = *(void *)(v18 + 24);
  int v46 = *(unsigned __int16 *)(v18 + 36);
  int v49 = *(unsigned __int8 *)(v45 + 18);
  int v47 = v45 + 18;
  CFTypeID v48 = v49;
  LOWORD(v50) = v47;
  if (v49)
  {
    uint64_t v50 = v47;
    do
    {
      uint64_t v51 = v50 + v48;
      uint64_t v52 = *(unsigned __int8 *)(v51 + 1);
      uint64_t v50 = v51 + 1;
      CFTypeID v48 = v52;
    }

    while (v52);
  }

  int v53 = v46 + v47 - 18 + ~(_WORD)v50;
  uint64_t v54 = v46 - v53;
  uint64_t v55 = v54;
  if (v38)
  {
    uint64_t v26 = (uint64_t *)v37;
    RSAPublicKey = (__SecKey *)v38;
    uint64_t v55 = v46 - v53;
    do
    {
      int v56 = *v26++;
      dnssec_obj_rr_get_signed_data(v56);
      v55 += *(void *)(v56 + 64);
      RSAPublicKey = (__SecKey *)((char *)RSAPublicKey - 1);
    }

    while (RSAPublicKey);
  }

  if (!v55) {
    goto LABEL_118;
  }
  uint64_t v57 = (uint64_t *)malloc(v55);
  if (!v57) {
    goto LABEL_118;
  }
  uint64_t v58 = v57;
  memcpy(v57, *(const void **)(v18 + 24), v54);
  uint64_t v104 = v58;
  if (v38)
  {
    uint64_t v59 = (char *)v58 + v54;
    uint64_t v60 = (uint64_t *)v37;
    uint64_t v61 = v38;
    do
    {
      uint64_t v62 = *v60;
      dnssec_obj_rr_get_signed_data(*v60);
      uint64_t v63 = *(void *)(v62 + 64);
      uint64_t v64 = *v60++;
      signed_data = dnssec_obj_rr_get_signed_data(v64);
      memcpy(v59, signed_data, v63);
      v59 += v63;
      --v61;
    }

    while (v61);
    uint64_t v106 = 0;
    do
    {
      uint64_t v66 = *(void *)v37;
      *(_DWORD *)(v66 + 44) = 0;
      *(_BYTE *)(v66 + 48) = 0;
      *(void *)(v66 + 64) = 0LL;
      uint64_t v67 = *(void **)(v66 + 56);
      if (v67)
      {
        free(v67);
        *(void *)(v66 + 56) = 0LL;
      }

      v37 += 8LL;
      --v38;
    }

    while (v38);
  }

  else
  {
    uint64_t v106 = 0;
  }

  if (v103)
  {
    *uint64_t v103 = v24;
    ++*(_DWORD *)v24;
  }

  uint64_t v68 = *(void *)(v24 + 24);
  uint64_t v69 = *(unsigned __int8 *)(v68 + 3);
  public_key_size = rdata_parser_dnskey_get_public_key_size(*(unsigned __int16 *)(v24 + 36));
  uint64_t v71 = *(void *)(v18 + 24);
  uint64_t v73 = *(unsigned __int8 *)(v71 + 18);
  uint64_t v26 = (uint64_t *)(v71 + 18);
  uint64_t v72 = v73;
  uint64_t v74 = v26;
  if (v73)
  {
    uint64_t v74 = v26;
    do
    {
      int v75 = (char *)v74 + v72;
      uint64_t v76 = v75[1];
      uint64_t v74 = (uint64_t *)(v75 + 1);
      uint64_t v72 = v76;
    }

    while (v76);
  }

  RSAPublicKey = 0LL;
  uint64_t v77 = -88890;
  if (v69 > 0xE)
  {
LABEL_126:
    __int128 v35 = 0LL;
    uint64_t v106 = v77;
    a4 = v105;
    uint64_t v26 = v104;
    if (RSAPublicKey) {
      goto LABEL_103;
    }
    goto LABEL_104;
  }

  uint64_t v78 = *(_WORD *)(v18 + 36);
  uint64_t v79 = (const UInt8 *)(v68 + 4);
  CFStringEncoding v37 = public_key_size;
  if (((1 << v69) & 0x5A0) == 0)
  {
    if (((1 << v69) & 0x6000) == 0) {
      goto LABEL_126;
    }
    uint64_t v83 = v78;
    bytes = 4;
    int v85 = kCFAllocatorDefault;
    Mutable = CFDataCreateMutable(kCFAllocatorDefault, public_key_size + 1LL);
    if (!Mutable)
    {
      RSAPublicKey = 0LL;
LABEL_122:
      uint64_t v77 = -6728;
      goto LABEL_126;
    }

    uint64_t v87 = Mutable;
    CFDataAppendBytes(Mutable, &bytes, 1LL);
    CFDataAppendBytes(v87, v79, v37);
    *(void *)buf = kSecAttrKeyType;
    *(void *)&buf[8] = kSecAttrKeyClass;
    values[0] = (void *)kSecAttrKeyTypeECSECPrimeRandom;
    values[1] = (void *)kSecAttrKeyClassPublic;
    uint64_t v88 = CFDictionaryCreate( kCFAllocatorDefault,  (const void **)buf,  (const void **)values,  2LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
    if (v88)
    {
      int v89 = v88;
      RSAPublicKey = SecKeyCreateWithData(v87, v88, 0LL);
      CFRelease(v89);
      if (RSAPublicKey)
      {
        CFRelease(v87);
        goto LABEL_84;
      }

      uint64_t v77 = -6700;
    }

    else
    {
      uint64_t v77 = -6728;
    }

    CFRelease(v87);
    RSAPublicKey = 0LL;
    goto LABEL_126;
  }

  if (!public_key_size || (uint64_t v80 = (unsigned __int8 *)malloc(public_key_size)) == 0LL)
  {
LABEL_118:
    __break(1u);
    goto LABEL_119;
  }

  uint64_t v81 = v80;
  memcpy(v80, v79, v37);
  uint64_t v82 = *v81;
  uint64_t v83 = v78;
  if (*v81)
  {
    uint64_t v84 = 1LL;
  }

  else
  {
    uint64_t v82 = __rev16(*(unsigned __int16 *)(v81 + 1));
    uint64_t v84 = 3LL;
  }

  *(void *)&buf[16] = &v81[v84];
  *(void *)&buf[24] = v82;
  *(void *)buf = &v81[v84 + v82];
  *(void *)&buf[8] = v37 - v82 - v84;
  int v85 = kCFAllocatorDefault;
  RSAPublicKey = (__SecKey *)SecKeyCreateRSAPublicKey(kCFAllocatorDefault, buf, 32LL, 3LL);
  free(v81);
LABEL_84:
  int v90 = CFDataCreate(v85, (const UInt8 *)v74 + 1, (unsigned __int16)(~((_WORD)v74 - (_WORD)v26) + v83 - 18));
  if (!v90) {
    goto LABEL_122;
  }
  CFStringEncoding v37 = (size_t)v90;
  unsigned int v91 = -88890;
  uint64_t v26 = v104;
  if (((1 << v69) & 0x5A0) != 0)
  {
    v92 = v85;
    int v93 = (uint8_t *)v104;
    OutputSize = v55;
    goto LABEL_92;
  }

  if (v69 == 13)
  {
    uint64_t v95 = 10LL;
    goto LABEL_91;
  }

  if (v69 != 14) {
    goto LABEL_120;
  }
  uint64_t v95 = 11LL;
LABEL_91:
  uint64_t v110 = 0u;
  uint64_t v111 = 0u;
  memset(buf, 0, sizeof(buf));
  CCDigest(v95, v104, v55, buf);
  OutputSize = CCDigestGetOutputSize(v95);
  int v93 = buf;
  v92 = v85;
LABEL_92:
  int v96 = CFDataCreate(v92, v93, OutputSize);
  if (!v96)
  {
LABEL_119:
    unsigned int v91 = -6728;
LABEL_120:
    __int128 v35 = 0LL;
    uint64_t v106 = v91;
    a4 = v105;
    goto LABEL_102;
  }

  __int128 v35 = 3LL;
  if (((0x32Du >> (v69 - 5)) & 1) != 0)
  {
    uint64_t v98 = SecKeyVerifySignature( RSAPublicKey,  *(SecKeyAlgorithm *)*(&off_10013C218 + (v69 - 5)),  v96,  (CFDataRef)v37,  0LL);
    if (v98) {
      __int128 v35 = 1LL;
    }
    else {
      __int128 v35 = 3LL;
    }
    if (v98) {
      uint64_t v97 = 0;
    }
    else {
      uint64_t v97 = -6748;
    }
  }

  else
  {
    uint64_t v97 = -6735;
  }

  a4 = v105;
  uint64_t v106 = v97;
  CFRelease(v96);
LABEL_102:
  CFRelease((CFTypeRef)v37);
  if (RSAPublicKey) {
LABEL_103:
  }
    CFRelease(RSAPublicKey);
LABEL_104:
  free(v26);
LABEL_42:
  if (a4) {
    *a4 = v106;
  }
  return v35;
}

  v14[4] = a2;
  os_retain(a2);
  unsigned int v22 = v14[2];
  unsigned int v23 = *(uint64_t (**)(void *, uint64_t, uint64_t, uint64_t, uint64_t))(v22 + 56);
  if (v23)
  {
    int v24 = v23(v14, a1, a3, a4, a5);
    if (v24)
    {
      uint64_t v19 = v24;
      unsigned int v13 = v14;
      int v14 = 0LL;
      goto LABEL_33;
    }

    unsigned int v22 = v14[2];
  }

  unsigned int v25 = *(uint64_t (**)(void *))(v22 + 88);
  if (v25) {
    uint64_t v26 = v25(v14);
  }
  else {
    uint64_t v26 = *(_BYTE *)(v22 + 104) != 0;
  }
  *((_BYTE *)v14 + 89) = v26;
  uint64_t v27 = *(uint64_t (**)(void *))(v22 + 96);
  if (v27) {
    uint64_t v28 = v27(v14);
  }
  else {
    uint64_t v28 = *(_BYTE *)(v22 + 105) != 0;
  }
  unsigned int v13 = 0LL;
  uint64_t v19 = 0;
  *((_BYTE *)v14 + 90) = v28;
LABEL_33:
  if (a6) {
    *a6 = v19;
  }
  if (v13) {
    os_release(v13);
  }
  return v14;
}

  while ((unint64_t)v21 < v13)
  {
    if ((*v21 & 0xDF) == 0x43 && !strncasecmp(v21, "controlURL", 0xAuLL)) {
      break;
    }
    if (!++v21) {
      break;
    }
  }

  if (!v21 || v21 == (char *)v13)
  {
    if (mDNS_LoggingEnabled != 1) {
      return;
    }
    __int128 v35 = (os_log_s *)mDNSLogCategory_Default;
    __int128 v36 = "handleLNTDeviceDescriptionResponse: didn't find controlURL string";
    goto LABEL_64;
  }

  unsigned int v22 = (uint64_t)(v21 + 11);
  int v41 = v21 + 11;
  if ((unint64_t)(v21 + 11) >= v13)
  {
    if (mDNS_LoggingEnabled != 1) {
      return;
    }
    __int128 v35 = (os_log_s *)mDNSLogCategory_Default;
    __int128 v36 = "handleLNTDeviceDescriptionResponse: past end of buffer and no body!";
    goto LABEL_64;
  }

  unsigned int v23 = &v10[v12] - v21 - 11;
  int v24 = v21 + 11;
  while (*v24 != 60)
  {
    ++v24;
    if (!--v23)
    {
      int v24 = &v10[v12];
      break;
    }
  }

  *(_WORD *)(v9 + 14964) = *(_WORD *)(v9 + 14962);
  unsigned int v25 = (uint64_t *)(v9 + 15000);
  uint64_t v26 = *(void **)(v9 + 15000);
  if (v26)
  {
    free(v26);
    *unsigned int v25 = 0LL;
  }

  uint64_t v27 = (uint64_t *)(v9 + 14984);
  uint64_t v28 = *(void **)(v9 + 14984);
  if (v28)
  {
    free(v28);
    *uint64_t v27 = 0LL;
  }

  if (!ParseHttpUrl( v22,  (unint64_t)v24,  (void *)(v9 + 15000),  (_WORD *)(v9 + 14964),  (void *)(v9 + 14984)))
  {
    uint64_t v30 = *v25;
    if (*v25) {
      goto LABEL_71;
    }
    __int16 v31 = a1[10];
    int v32 = v31 < (unint64_t)v24;
    if (v31 && v31 < (unint64_t)v24)
    {
      while ((*(_BYTE *)v31 & 0xDF) != 0x55 || strncasecmp((const char *)v31, "URLBase", 7uLL))
      {
        int v32 = ++v31 < (unint64_t)v24;
      }
    }

    else
    {
LABEL_48:
      if (!v32) {
        goto LABEL_69;
      }
    }

    if (mDNS_LoggingEnabled == 1) {
      LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "handleLNTDeviceDescriptionResponse: found URLBase",  v15,  v16,  v17,  v18,  v19,  v40);
    }
    int v41 = (char *)(v31 + 8);
    if (v31 + 8 < (unint64_t)v24)
    {
      __int16 v33 = (uint64_t)&v24[-v31 - 8];
      unsigned int v34 = (char *)(v31 + 8);
      while (!v34 || *v34 != 60)
      {
        ++v34;
        if (!--v33) {
          goto LABEL_66;
        }
      }

      int v24 = v34;
    }

LABEL_38:
  a1[17] = v14;
  ++a1[12];
}

  if (*(_BYTE *)(a2 + 618)
    || *(_BYTE *)(a2 + 632)
    || ((v39 = *(void *)(a2 + 136) + 5LL, v39 <= 3) ? (BOOL v40 = v39 == 1) : (BOOL v40 = 1),
        v40 && !*(_BYTE *)(a2 + 614) && !IsLocalDomain(v6)))
  {
    __int128 v35 = mDNS_NewMessageID(a1);
  }

  else
  {
    __int128 v35 = 0;
  }

  *(_WORD *)(a2 + 320) = v35;
  if (DNSQuestionIsEligibleForMDNSAlternativeService(a2)
    && Querier_IsMDNSAlternativeServiceAvailableForQuestion(a2))
  {
    *(_WORD *)(a2 + 320) = mDNS_NewMessageID(a1);
  }

  __int128 v36 = &unk_100164000;
  if (DNSQuestionNeedsSensitiveLogging(a2))
  {
    uint64_t v10 = ++gNumOfSensitiveLoggingEnabledQuestions;
    if ((gSensitiveLoggingEnabled & 1) == 0)
    {
      gSensitiveLoggingEnabled = 1;
      uint64_t v38 = mDNSLogCategory_Default;
      if (mDNSLogCategory_Default == mDNSLogCategory_State)
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_62;
        }
      }

      else
      {
        uint64_t v38 = mDNSLogCategory_Default_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_62;
        }
      }

      int v46 = bswap32(*(unsigned __int16 *)(a2 + 320)) >> 16;
      LODWORD(__src[0]) = 67109120;
      DWORD1(__src[0]) = v46;
      uint64_t v42 = "[Q%u] Question enables sensitive logging, all the sensitive level logs and the state dump of the question wi"
            "ll now be redacted.";
      int v43 = (os_log_s *)v38;
      int v44 = OS_LOG_TYPE_DEFAULT;
      int v45 = 8;
      goto LABEL_61;
    }

    CFStringEncoding v37 = mDNSLogCategory_Default;
    if (mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEBUG))
      {
LABEL_58:
        int v41 = bswap32(*(unsigned __int16 *)(a2 + 320));
        LODWORD(__src[0]) = 67109376;
        DWORD1(__src[0]) = HIWORD(v41);
        WORD4(__src[0]) = 1024;
        *(_DWORD *)((char *)__src + 10) = v10;
        uint64_t v42 = "[Q%u] Question enables sensitive logging, redaction already in effect. - number of enabled questions: %d.";
        int v43 = (os_log_s *)v37;
        int v44 = OS_LOG_TYPE_DEBUG;
        int v45 = 14;
LABEL_61:
        _os_log_impl((void *)&_mh_execute_header, v43, v44, v42, (uint8_t *)__src, v45);
      }
    }

    else
    {
      CFStringEncoding v37 = mDNSLogCategory_Default_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEBUG)) {
        goto LABEL_58;
      }
    }
  }

  a1[27] = 0LL;
  if ((*(_DWORD *)(a2 + 172) & 0xFFFFFFFE) == 4)
  {
    unsigned int v23 = a1[25];
    a1[27] = v23;
    if (v23)
    {
      while (1)
      {
        if (v23 == a1[26]) {
          goto LABEL_49;
        }
        if (*(_DWORD *)(a2 + 172) <= 3u) {
          break;
        }
        if (LocalOnlyRecordAnswersQuestion(a2, v23, a3, a4, a5, a6, a7, a8)) {
          goto LABEL_45;
        }
LABEL_46:
        int v24 = a1[27];
        if (v24 == v23)
        {
          int v24 = *(void *)(v23 + 8);
          a1[27] = v24;
        }

        unsigned int v23 = v24;
        if (!v24) {
          goto LABEL_49;
        }
      }

      if (!RecordAnswersQuestion(a2 + 8, 1, v23, a4, a5, a6, a7, a8)) {
        goto LABEL_46;
      }
LABEL_45:
      AnswerLocalQuestionWithLocalAuthRecord((uint64_t)a1, a2, a3);
      goto LABEL_46;
    }

    uint64_t v18 = WORD6(xmmword_100161F98);
    GetRRDisplayString_rdb( (unsigned __int8 *)&xmmword_100161F98 + 8,  (unsigned __int16 *)(qword_100161FC8 + 4),  (_BYTE *)&xmmword_100161F98 + &unk_100002398 + 8);
    *(_DWORD *)buf = 141559299;
    __int128 v35 = 1752392040LL;
    __int128 v36 = 1040;
    CFStringEncoding v37 = v17;
    uint64_t v38 = 2101;
    BOOL v39 = v10;
    BOOL v40 = 1024;
    int v41 = v18;
    uint64_t v42 = 2160;
    int v43 = 1752392040LL;
    int v44 = 2085;
    int v45 = (char *)&xmmword_100161F98 + &unk_100002398 + 8;
    _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEFAULT,  "xD2DParse got record - name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P, rrtype: %{mdns:rrtype}d, rdata : %{sensitive, mask.hash}s",  buf,  0x36u);
LABEL_39:
    if (WORD2(xmmword_100161FA8) >= 0x109u) {
      uint64_t v19 = WORD2(xmmword_100161FA8) + 936LL;
    }
    else {
      uint64_t v19 = 1200LL;
    }
    uint64_t v20 = (char *)calloc(1uLL, v19);
    if (!v20) {
      __break(1u);
    }
    uint32_t v21 = v20;
    *a5 = v20;
    mDNS_SetupResourceRecord( (uint64_t)(v20 + 24),  0LL,  -3LL,  SWORD6(xmmword_100161F98),  0x1C20u,  8,  5,  (uint64_t)FreeD2DARElemCallback,  0LL);
    for (uint64_t i = (char *)&xmmword_100161F98 + &unk_100002090 + 12;
          mDNSStorage == (uint64_t *)-46460LL || i < byte_100164134;
          i += v23 + 1)
    {
      if (!i) {
        break;
      }
      unsigned int v23 = *i;
      if (!*i)
      {
        int v24 = (_DWORD)i - mDNSStorage + 19333;
        if ((unsigned __int16)v24 <= 0x100u)
        {
          memcpy(v21 + 676, &byte_100164034, (unsigned __int16)v24);
          goto LABEL_53;
        }

        break;
      }
    }

    v21[676] = 0;
LABEL_53:
    unsigned int v25 = WORD2(xmmword_100161FA8);
    *((_WORD *)v21 + 22) = WORD2(xmmword_100161FA8);
    uint64_t v26 = (_WORD *)*((void *)v21 + 9);
    *uint64_t v26 = v25;
    memcpy(v26 + 2, (const void *)(qword_100161FC8 + 4), v25);
    *((_DWORD *)v21 + 12) = DomainNameHashValue(*((void *)v21 + 8));
    SetNewRData((uint64_t)(v21 + 32), 0LL, 0LL, v27, v28, v29, v30, v31);
    uint64_t v6 = 0LL;
    goto LABEL_54;
  }

  if ((v8 & 1) != 0)
  {
    unsigned int v13 = mDNSLogCategory_D2D_redacted;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_D2D_redacted, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      int v14 = (os_log_s *)v13;
LABEL_30:
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "xD2DParse: failed to get large RR", buf, 2u);
    }
  }

  else if (os_log_type_enabled((os_log_t)mDNSLogCategory_D2D, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)buf = 0;
    int v14 = v9;
    goto LABEL_30;
  }

  uint64_t v6 = 4294901759LL;
LABEL_54:
  WORD4(xmmword_100161F98) = 0;
  HIWORD(xmmword_100161FF8) = 0;
  if ((void)xmmword_100161FD8)
  {
    ref_count_obj_release((void *)xmmword_100161FD8);
    *(void *)&xmmword_100161FD8 = 0LL;
  }

  return v6;
}

      uint64_t v28 = "mDNS_AddDomainDiscoveredForDomainEnumeration";
      int v29 = a1;
      uint64_t v30 = 16237;
    }

    else
    {
      DeregisterLocalOnlyDomainEnumPTR_Internal((unsigned int *)a1, v16, 2LL, 0LL, a5, a6, a7, a8);
      mDNS_Lock_((unsigned int *)a1, (uint64_t)"mDNS_RemoveDomainDiscoveredForDomainEnumeration", 16245);
      uint64_t v18 = *(void *)(a1 + 14088);
      if (v18)
      {
        while (!SameDomainNameBytes((_BYTE *)v18, "\x05local"))
        {
          uint64_t v18 = *(void *)(v18 + 296);
          if (!v18) {
            goto LABEL_40;
          }
        }

        unsigned int v23 = *(uint64_t **)(v18 + 272);
        if (v23)
        {
          int v24 = *v23;
          if (*v23)
          {
            while (1)
            {
              unsigned int v25 = SameDomainNameBytes((_BYTE *)v24, (_BYTE *)(v14 + 4));
              uint64_t v26 = *(void *)(v24 + 256);
              if (v25) {
                break;
              }
              unsigned int v23 = (uint64_t *)(v24 + 256);
              int v24 = *(void *)(v24 + 256);
              if (!v26) {
                goto LABEL_40;
              }
            }

            *unsigned int v23 = v26;
            free((void *)v24);
          }
        }
      }

      uint64_t v19 = -6728;
      goto LABEL_33;
    }

    unsigned int v13 = (void *)_os_object_alloc(&OBJC_CLASS___OS_mdns_session, 144LL);
    int v14 = v13;
    if (!v13) {
      goto LABEL_38;
    }
    uint64_t v20 = &_mdns_udp_socket_session_kind;
    v13[2] = &_mdns_udp_socket_session_kind;
    do
    {
      uint32_t v21 = (void (*)(void *))v20[2];
      if (v21) {
        v21(v14);
      }
      uint64_t v20 = (_UNKNOWN **)*v20;
    }

    while (v20);
  }

          if (mDNS_LoggingEnabled == 1 && v20 != 200 && (unsigned __int16)v20 != 500) {
            LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "handleLNTPortMappingResponse: HTTP Result code: %d",  v15,  v16,  v17,  v18,  v19,  v20);
          }
          return;
        }

        int v29 = (os_log_s *)mDNSLogCategory_Default;
        uint64_t v30 = "handleLNTPortMappingResponse got data that was not a valid HTTP response";
      }

      LogMsgWithLevel(v29, OS_LOG_TYPE_DEFAULT, v30, v15, v16, v17, v18, v19, v39);
      goto LABEL_38;
    }
  }

  if (mDNS_LoggingEnabled == 1) {
    LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "handleLNTPortMappingResponse: can't find matching tcpInfo in NATTraversals!",  a4,  a5,  a6,  a7,  a8,  a9);
  }
}

BOOL SameDomainNameCS(_BYTE *a1, _BYTE *a2)
{
  uint64_t v2 = a1;
  if (a1 == (_BYTE *)-256LL) {
    goto LABEL_5;
  }
LABEL_2:
  unsigned __int16 v3 = 257;
  if (v2 < a1 + 256 && v2)
  {
    while (1)
    {
      uint64_t v4 = *v2;
      if (v4 > 0x3F)
      {
LABEL_10:
        unsigned __int16 v3 = 257;
        goto LABEL_12;
      }

      if (!*v2) {
        break;
      }
      v2 += v4 + 1;
      if (a1 != (_BYTE *)-256LL) {
        goto LABEL_2;
      }
LABEL_5:
      if (!v2) {
        goto LABEL_10;
      }
    }

    unsigned __int16 v3 = (_WORD)v2 - (_WORD)a1 + 1;
  }

LABEL_12:
  BOOL v5 = a2;
  if (a2 == (_BYTE *)-256LL) {
    goto LABEL_16;
  }
LABEL_13:
  __int16 v6 = 257;
  if (v5 < a2 + 256 && v5)
  {
    while (1)
    {
      uint64_t v7 = *v5;
      if (v7 > 0x3F)
      {
LABEL_21:
        __int16 v6 = 257;
        goto LABEL_23;
      }

      if (!*v5) {
        break;
      }
      v5 += v7 + 1;
      if (a2 != (_BYTE *)-256LL) {
        goto LABEL_13;
      }
LABEL_16:
      if (!v5) {
        goto LABEL_21;
      }
    }

    __int16 v6 = (_WORD)v5 - (_WORD)a2 + 1;
  }

  if (a1[16]) {
    goto LABEL_20;
  }
  uint64_t v12 = (os_log_s *)mDNSLogCategory_Default;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
  {
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_ERROR)) {
      goto LABEL_20;
    }
    int v14 = a1[12];
    int v16 = 67109120;
    uint64_t v17 = v14;
  }

  else
  {
    uint64_t v12 = (os_log_s *)mDNSLogCategory_Default_redacted;
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_ERROR)) {
      goto LABEL_20;
    }
    unsigned int v13 = a1[12];
    int v16 = 67109120;
    uint64_t v17 = v13;
  }

  _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_ERROR,  "Lock failure: mDNS_TimeNow: m->mDNS_busy is %u but m->timenow not set",  (uint8_t *)&v16,  8u);
LABEL_20:
  uint64_t result = a1[16];
  if (!(_DWORD)result) {
    return a1[15] + mDNSPlatformRawTime(result, a2, a3, a4, a5, a6, a7, a8);
  }
  return result;
}

  uint64_t v17 = a1 + 37865;
  v339 = (_WORD *)(a1 + 28904);
  uint64_t v18 = (_DWORD *)(a1 + 19868);
  uint64_t v19 = v9;
  v351 = v9 != 59668LL;
  v314 = a6;
  v318 = mDNSAddrIsDNSMulticast(a6);
  IsLocalSubnet = mDNS_AddressIsLocalSubnet(a1, a8, a4);
  v358 = (uint64_t *)&v359;
  v359 = 0LL;
  IsD2D = mDNSPlatformInterfaceIsD2D(a8, v20, v21, v22, v23, v24, v25, v26);
  v356 = 0LL;
  v357 = 0LL;
  v355 = 0LL;
  uint64_t v27 = a3;
  OptRR = LocateOptRR(v11, a3, 12);
  v336 = v19;
  v347 = (_DWORD *)(a1 + 19868);
  v354 = (_BYTE *)(a1 + 37865);
  if (!OptRR) {
    goto LABEL_60;
  }
  if (!GetLargeResourceRecord(a1, v11, OptRR, a3, a8, 128, a1 + 37856)) {
    goto LABEL_58;
  }
  if (*(_WORD *)(a1 + 37868) != 41) {
    goto LABEL_58;
  }
  __int16 v33 = *(void *)(a1 + 37904);
  unsigned int v34 = v33 + 4 + *(unsigned __int16 *)(a1 + 37876);
  if (v33 + 4 >= v34) {
    goto LABEL_58;
  }
  __int128 v35 = 0;
  v345 = 0LL;
  __int128 v36 = v33 + 8;
  do
  {
    CFStringEncoding v37 = *(unsigned __int16 *)(v36 - 4);
    if (v37 == 65002)
    {
      ++v35;
      uint64_t v38 = *(unsigned __int16 *)(v36 + 8);
      BOOL v39 = DomainNamePtrAtTSRIndex((unsigned __int16 *)v11, a3, v38);
      if (v39)
      {
        BOOL v40 = UnsafeBufferPointer(v11, v39, a3, v36 - 4);
        if (v40)
        {
          uint64_t v18 = (_DWORD *)(a1 + 19868);
          *(void *)BOOL v40 = v345;
          v355 = v40;
          v345 = v40;
LABEL_26:
          uint64_t v17 = a1 + 37865;
          goto LABEL_46;
        }

        CFTypeID v48 = mDNSLogCategory_mDNS;
        int v49 = gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State;
        uint64_t v18 = (_DWORD *)(a1 + 19868);
        if (v49)
        {
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_ERROR)) {
            goto LABEL_26;
          }
        }

        else
        {
          CFTypeID v48 = mDNSLogCategory_mDNS_redacted;
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_ERROR)) {
            goto LABEL_26;
          }
        }

        uint64_t v52 = *(void *)(a1 + 37888);
        int v53 = *(_DWORD *)v36;
        uint64_t v54 = *(_DWORD *)(v36 + 4);
        uint64_t v55 = *(unsigned __int16 *)(v36 + 8);
        *(_DWORD *)buf = 67110144;
        v374 = v35;
        v375 = 2048;
        v376 = v52;
        v377 = 1024;
        *(_DWORD *)v378 = v53;
        *(_WORD *)&v378[4] = 1024;
        *(_DWORD *)&v378[6] = v54;
        v379 = 1024;
        v380 = v55;
        int v46 = (os_log_s *)v48;
        uint64_t v17 = a1 + 37865;
        int v47 = "ProcessQuery: Create TSR(%u) failed - if %p tsrTime %d tsrHost %x recIndex %d";
      }

      else
      {
        int v41 = mDNSLogCategory_mDNS;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
        {
          uint64_t v18 = (_DWORD *)(a1 + 19868);
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_ERROR)) {
            goto LABEL_26;
          }
        }

        else
        {
          int v41 = mDNSLogCategory_mDNS_redacted;
          uint64_t v50 = os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_ERROR);
          uint64_t v18 = (_DWORD *)(a1 + 19868);
          if (!v50) {
            goto LABEL_26;
          }
        }

        int v43 = *(void *)(a1 + 37888);
        int v44 = *(_DWORD *)v36;
        int v45 = *(_DWORD *)(v36 + 4);
        *(_DWORD *)buf = 67110144;
        v374 = v35;
        v375 = 2048;
        v376 = v43;
        v377 = 1024;
        *(_DWORD *)v378 = v44;
        *(_WORD *)&v378[4] = 1024;
        *(_DWORD *)&v378[6] = v45;
        v379 = 1024;
        v380 = v38;
        uint64_t v17 = a1 + 37865;
        int v46 = (os_log_s *)v41;
        int v47 = "ProcessQuery: No Domain Name for TSR(%u) if %p tsrTime %d tsrHost %x recIndex %d";
      }

      _os_log_impl((void *)&_mh_execute_header, v46, OS_LOG_TYPE_ERROR, v47, buf, 0x24u);
    }

    else if (v37 == 4 && !*(_BYTE *)v36 && *(_DWORD *)(v36 + 2))
    {
      ClearProxyRecords(a1, v36, *(void *)(a1 + 12632));
      ClearProxyRecords(a1, v36, *(void *)(a1 + 12624));
    }

  if (a8 < 0x10000) {
    goto LABEL_23;
  }
  uint64_t v27 = (os_log_s *)mDNSLogCategory_D2D;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_D2D == mDNSLogCategory_State)
  {
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D, OS_LOG_TYPE_ERROR)) {
      goto LABEL_23;
    }
    *(_DWORD *)buf = 134217984;
    *(void *)&uint8_t buf[4] = a8;
  }

  else
  {
    uint64_t v27 = (os_log_s *)mDNSLogCategory_D2D_redacted;
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D_redacted, OS_LOG_TYPE_ERROR)) {
      goto LABEL_23;
    }
    *(_DWORD *)buf = 134217984;
    *(void *)&uint8_t buf[4] = a8;
  }

  _os_log_impl( (void *)&_mh_execute_header,  v27,  OS_LOG_TYPE_ERROR,  "xD2DServiceCallback: valueSize too large - value size: %zu",  buf,  0xCu);
LABEL_23:
  uint64_t v30 = (os_log_s *)mDNSLogCategory_D2D;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_D2D == mDNSLogCategory_State)
  {
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_33;
    }
    *(_DWORD *)buf = 67240192;
    *(_DWORD *)&uint8_t buf[4] = a1;
    goto LABEL_32;
  }

  uint64_t v30 = (os_log_s *)mDNSLogCategory_D2D_redacted;
  if (os_log_type_enabled((os_log_t)mDNSLogCategory_D2D_redacted, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 67240192;
    *(_DWORD *)&uint8_t buf[4] = a1;
LABEL_32:
    _os_log_impl( (void *)&_mh_execute_header,  v30,  OS_LOG_TYPE_DEFAULT,  "xD2DServiceCallback -- event: %{public, mdnsresponder:d2d_service_event}d",  buf,  8u);
  }

  MakeNegativeCacheRecord( a1,  a1 + 37856,  v9 + 356,  *(_DWORD *)(v9 + 200),  *(_WORD *)(v9 + 322),  *(_WORD *)(v9 + 324),  60,  a2,  *(void **)(v9 + 80),  v10);
  AnswerCurrentQuestionWithResourceRecord(a1, a1 + 37856, a3);
  if (*(void *)(a1 + 216) == v9) {
    *(_DWORD *)(v9 + 212) = 0;
  }
  *(_WORD *)int v14 = 0;
  *(_WORD *)(v14 + 102) = 0;
  uint64_t v19 = *(void **)(v14 + 56);
  if (v19)
  {
    ref_count_obj_release(v19);
    *(void *)(v14 + 56) = 0LL;
  }

  if (a3 != -65548) {
    return;
  }
  mDNS_Lock_((unsigned int *)a1, (uint64_t)"SPSRecordCallback", 12936);
  uint64_t v9 = (os_log_s *)mDNSLogCategory_SPS;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_SPS == mDNSLogCategory_State)
  {
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_SPS, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v10 = (unsigned __int8 *)(a2 + 8);
      unsigned int v13 = (void *)(a1 + 12664);
      while (1)
      {
        unsigned int v13 = (void *)*v13;
        if (!v13) {
          break;
        }
        int v14 = v13;
        if (v13[782] == *((void *)a2 + 4)) {
          goto LABEL_32;
        }
      }

      int v14 = 0LL;
LABEL_32:
      if (v13) {
        uint64_t v15 = (char *)v14 + 6310;
      }
      else {
        uint64_t v15 = 0LL;
      }
      goto LABEL_35;
    }
  }

  else
  {
    uint64_t v9 = (os_log_s *)mDNSLogCategory_SPS_redacted;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_SPS_redacted, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v10 = (unsigned __int8 *)(a2 + 8);
      uint64_t v11 = (void *)(a1 + 12664);
      while (1)
      {
        uint64_t v11 = (void *)*v11;
        if (!v11) {
          break;
        }
        uint64_t v12 = v11;
        if (v11[782] == *((void *)a2 + 4)) {
          goto LABEL_28;
        }
      }

      uint64_t v12 = 0LL;
LABEL_28:
      if (v11) {
        uint64_t v15 = (char *)v12 + 6310;
      }
      else {
        uint64_t v15 = 0LL;
      }
LABEL_35:
      GetRRDisplayString_rdb(v10, (unsigned __int16 *)(*((void *)a2 + 6) + 4LL), (_BYTE *)(a1 + 46976));
      uint32_t v21 = 136447491;
      *(void *)unsigned int v22 = v15;
      *(_WORD *)&v22[8] = 2160;
      *(void *)&v22[10] = 1752392040LL;
      *(_WORD *)&v22[18] = 1045;
      *(_DWORD *)&v22[20] = 6;
      unsigned int v23 = 2101;
      int v24 = a2 + 126;
      unsigned int v25 = 2160;
      uint64_t v26 = 1752392040LL;
      uint64_t v27 = 2085;
      uint64_t v28 = a1 + 46976;
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEFAULT,  "%{public}s Conflicting mDNS -- waking %{sensitive, mask.hash, mdnsresponder:mac_addr}.6P %{sensitive, mask.hash}s",  (uint8_t *)&v21,  0x3Au);
    }
  }

  if (*(_DWORD *)(a2 + 126))
  {
    SendWakeup(a1, *((void *)a2 + 4), (uint64_t)(a2 + 132), (uint64_t)(a2 + 138), 0);
    ScheduleWakeup(a1, *((void *)a2 + 4), (unsigned __int16 *)a2 + 63, v16, v17, v18, v19, v20, v21);
  }

  mDNS_Unlock_(a1, (uint64_t)"SPSRecordCallback", 12944);
  --*(_DWORD *)(a1 + 19832);
LABEL_39:
  free(a2);
LABEL_40:
  mDNS_UpdateAllowSleep(a1);
}

  if (a3) {
    *a3 = v14;
  }
  return result;
}

  uint64_t v10 = 4294901747LL;
  uint64_t v11 = mDNSLogCategory_Default;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
  {
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEBUG))
    {
LABEL_29:
      *(_DWORD *)buf = 134218240;
      unsigned int v25 = v21;
      uint64_t v26 = 2048;
      uint64_t v27 = v9;
      uint64_t v15 = "get_signed_browse_tlvs len %ld data invalid %ld";
      uint64_t v17 = (os_log_s *)v11;
      uint64_t v18 = 22;
LABEL_33:
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEBUG, v15, buf, v18);
    }
  }

  else
  {
    uint64_t v11 = mDNSLogCategory_Default_redacted;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEBUG)) {
      goto LABEL_29;
    }
  }

  return v10;
}

  mDNS_Lock_((unsigned int *)mDNSStorage, (uint64_t)"_Querier_StartNEDNSProxyStateWatch_block_invoke", 104);
  Querier_ProcessDNSServiceChanges(0LL);
  for (uint64_t i = 0LL; i != 499; ++i)
  {
    for (uint64_t j = (void *)mDNSStorage[i + 35]; j; uint64_t j = (void *)*j)
    {
      for (k = (void *)j[2]; k; k = (void *)*k)
      {
        int v24 = k[7];
        if (v24)
        {
          unsigned int v25 = *(void *)(v24 + 24);
          if (v25)
          {
            if (*(_BYTE *)(v25 + 281) == 1) {
              mDNS_PurgeCacheResourceRecord((unsigned int *)mDNSStorage, (uint64_t)k);
            }
          }
        }
      }
    }
  }

  mDNS_Unlock_((uint64_t)mDNSStorage, (uint64_t)"_Querier_StartNEDNSProxyStateWatch_block_invoke", 131);
LABEL_23:
  KQueueUnlock((uint64_t)"NetworkExtension DNS proxy state update", v11, v12, v13, v14, v15, v16, v17);
}

  uint64_t v12 = v10;
  unsigned int v13 = malloc(v10);
  if (!v13) {
    goto LABEL_129;
  }
  *(void *)(a1 + 656) = v13;
  memcpy(v13, v8, v12);
  *(void *)(a1 + 664) = *(void *)(a2 + 24);
  *(_DWORD *)(a1 + 688) = *(_DWORD *)a2;
  *(void *)(a1 + 672) = a3;
  *(void *)(a1 + 680) = a4;
  *(_BYTE *)(a1 + 719) = *(_BYTE *)(a2 + 61);
  *(_WORD *)(a1 + 724) = *(_WORD *)(a2 + 81);
  int v14 = *(unsigned __int8 *)(a2 + 83);
  *(_BYTE *)(a1 + 726) = v14;
  uint64_t v15 = *(unsigned __int8 *)(a2 + 84);
  *(_BYTE *)(a1 + 727) = v15;
  *(_WORD *)(a1 + 722) = *(_WORD *)(a2 + 16);
  if (!v14 || v15)
  {
    int v16 = *(_OWORD **)(a2 + 64);
    if (v16) {
      *(_OWORD *)(a1 + 728) = *v16;
    }
  }

  uint64_t v17 = *(void **)(a2 + 88);
  if (v17) {
    os_retain(v17);
  }
  uint64_t v18 = *(void **)(a1 + 744);
  if (v18) {
    os_release(v18);
  }
  *(void *)(a1 + 744) = *(void *)(a2 + 88);
  uint64_t v19 = *(void **)(a2 + 96);
  if (v19) {
    os_retain(v19);
  }
  uint64_t v20 = *(void **)(a1 + 752);
  if (v20) {
    os_release(v20);
  }
  uint32_t v21 = *(void *)(a2 + 96);
  *(void *)(a1 + 752) = v21;
  unsigned int v22 = *(_DWORD *)(a2 + 36);
  if (EnableAllowExpired) {
    unsigned int v23 = v22 < 0;
  }
  else {
    unsigned int v23 = 0;
  }
  int v24 = v23;
  *(_BYTE *)(a1 + 626) = v24;
  *(_DWORD *)(a1 + 280) = *(_DWORD *)(a2 + 32);
  *(_BYTE *)(a1 + 633) = *(_BYTE *)(a2 + 60);
  *(void *)(a1 + 120) = *(void *)(a1 + 744);
  *(void *)(a1 + 128) = v21;
  *(void *)(a1 + 136) = *(void *)(a2 + 24);
  *(_DWORD *)(a1 + 304) = v22;
  unsigned int v25 = *(_BYTE **)(a2 + 8);
  uint64_t v26 = v25;
  if (v25 == (_BYTE *)-256LL)
  {
LABEL_33:
    while (v26)
    {
      uint64_t v27 = *v26;
      if (!*v26)
      {
        uint64_t v28 = (_WORD)v26 - (_WORD)v25 + 1;
        if (v28 > 0x100u) {
          break;
        }
        memcpy((void *)(a1 + 356), v25, v28);
        goto LABEL_41;
      }

      v26 += v27 + 1;
      if (v25 != (_BYTE *)-256LL) {
        goto LABEL_32;
      }
    }
  }

  else
  {
LABEL_32:
    if (v26 < v25 + 256) {
      goto LABEL_33;
    }
  }

  *(_BYTE *)(a1 + 356) = 0;
LABEL_41:
  *(_DWORD *)(a1 + 322) = *(_DWORD *)(a2 + 16);
  int v29 = *(_DWORD *)(a2 + 36);
  *(_BYTE *)(a1 + 612) = BYTE1(v29) & 1;
  uint64_t v30 = (int16x8_t)vshlq_u32((uint32x4_t)vdupq_n_s32(v29), (uint32x4_t)xmmword_100100880);
  *(int8x8_t *)v30.i8 = vand_s8((int8x8_t)vmovn_s32((int32x4_t)v30), (int8x8_t)0x1000100010001LL);
  *(_DWORD *)(a1 + 614) = vmovn_s16(v30).u32[0];
  *(_BYTE *)(a1 + 620) = (v29 & 0x80000) != 0;
  *(_BYTE *)(a1 + 635) = _os_feature_enabled_impl("mDNSResponder", "dnssec") & (v29 >> 21);
  __int16 v31 = *(unsigned __int8 *)(a2 + 40);
  *(_BYTE *)(a1 + 621) = v31;
  int v32 = *(_WORD *)(a2 + 16) == 1 && *(_BYTE *)(a2 + 105) != 0;
  *(_BYTE *)(a1 + 624) = v32;
  *(_BYTE *)(a1 + 627) = *(_BYTE *)(a2 + 80);
  *(void *)a1 = *(void *)(a2 + 72);
  *(_WORD *)(a1 + 630) = *(_WORD *)(a1 + 726);
  if (*(_BYTE *)(a1 + 725))
  {
    *(_BYTE *)(a1 + 623) = 1;
    if (!*(void *)(a1 + 136)) {
      *(_BYTE *)(a1 + 622) = 1;
    }
  }

  *(_OWORD *)(a1 + 340) = *(_OWORD *)(a1 + 728);
  *(_BYTE *)(a1 + 337) = 0;
  *(_BYTE *)(a1 + 653) = *(_BYTE *)(a2 + 104);
  *(_DWORD *)(a1 + 244) = *(_DWORD *)(a2 + 44);
  __int16 v33 = *(_OWORD **)(a2 + 48);
  if (v33) {
    *(_OWORD *)(a1 + 636) = *v33;
  }
  *(_DWORD *)(a1 + 248) = *(_DWORD *)(a2 + 56);
  *(_DWORD *)(a1 + 252) = *(_DWORD *)a2;
  *(void *)(a1 + 152) = QueryRecordOpCallback;
  *(void *)(a1 + 160) = QueryRecordOpResetHandler;
  *(void *)(a1 + 168) = QueryRecordOpEventHandler;
  if (v31)
  {
    unsigned int v34 = *(_BYTE **)(a1 + 656);
    if (*v34)
    {
    }
  }

  __int128 v35 = *(unsigned __int16 *)(a1 + 322);
  if (v35 != 1 && v35 != 28)
  {
    if (v35 != 33) {
      goto LABEL_65;
    }
    __int128 v36 = (_BYTE *)(a1 + 356);
    CFStringEncoding v37 = *(_BYTE *)(a1 + 356) ? *(unsigned __int8 *)(a1 + 356) + 1LL : 0LL;
    if (!SameDomainLabelPointer(&v36[v37], "\x04_tcp"))
    {
      uint64_t v38 = *v36 ? *v36 + 1LL : 0LL;
    }
  }

  if (*(_BYTE *)(a1 + 614)) {
    goto LABEL_65;
  }
  uint64_t v57 = a1 + 356;
  uint64_t v58 = *(unsigned __int8 *)(a1 + 356);
  if (*(_BYTE *)(a1 + 356))
  {
    do
    {
      uint64_t v59 = v57;
      uint64_t v60 = v57 + v58;
      uint64_t v61 = *(unsigned __int8 *)(v60 + 1);
      uint64_t v57 = v60 + 1;
      uint64_t v58 = v61;
    }

    while (v61);
  }

  else
  {
    uint64_t v59 = a1 + 356;
  }

  if (!SameDomainLabelPointer(v59, "\x05local"))
  {
LABEL_65:
    BOOL v39 = 0;
    goto LABEL_66;
  }

  uint64_t v62 = calloc(1uLL, 0x290uLL);
  if (!v62) {
LABEL_129:
  }
    __break(1u);
  *(void *)(a1 + 704) = v62;
  memcpy(v62, (const void *)a1, 0x290uLL);
  BOOL v39 = 1;
LABEL_66:
  RecordOpStartQuestion = QueryRecordOpStartQuestion(a1, a1);
  if (!(_DWORD)RecordOpStartQuestion)
  {
    if (callExternalHelpers( *(void *)(a1 + 136),  (_BYTE *)(a1 + 356),  *(unsigned int *)(a1 + 304),  v40,  v41,  v42,  v43,  v44))
    {
      external_start_browsing_for_service( *(void *)(a1 + 136),  (unsigned __int8 *)(a1 + 356),  *(unsigned __int16 *)(a1 + 322),  *(_DWORD *)(a1 + 304),  *(_DWORD *)(a1 + 244));
    }

    if (!v39) {
      return 0LL;
    }
    int v47 = *(void *)(a1 + 704);
    if (!v47)
    {
      RecordOpStartQuestion = 4294901754LL;
      goto LABEL_67;
    }

    CFTypeID v48 = (_BYTE *)(v47 + 356);
    int v49 = *(unsigned __int8 *)(v47 + 356);
    if (*(_BYTE *)(v47 + 356))
    {
      uint64_t v50 = 0;
      uint64_t v51 = v47 + 356;
      do
      {
        ++v50;
        uint64_t v52 = v51 + v49;
        int v53 = *(unsigned __int8 *)(v52 + 1);
        uint64_t v51 = v52 + 1;
        int v49 = v53;
      }

      while (v53);
      if (v50 == 2
        && !SameDomainNameBytes((_BYTE *)(v47 + 356), ActiveDirectoryPrimaryDomain)
        && !DomainNameIsInSearchList((_BYTE *)(v47 + 356), 0))
      {
        *(_WORD *)(a1 + 712) = *(_WORD *)(v47 + 322);
        *(_BYTE *)(a1 + 714) = *(_BYTE *)(v47 + 612);
        *(_BYTE *)(a1 + 715) = *(_BYTE *)(v47 + 615);
        *(_BYTE *)(a1 + 716) = *(_BYTE *)(v47 + 617);
        *(_BYTE *)(a1 + 717) = *(_BYTE *)(v47 + 621);
        for (uint64_t i = "\x05local"; ; i += v56 + 1)
        {
          if ("\x05local" == (char *)-256LL)
          {
            if (!i) {
              goto LABEL_101;
            }
          }

          else if (i >= "xyTCPCallback: free" || i == 0LL)
          {
            goto LABEL_101;
          }

          int v56 = *(unsigned __int8 *)i;
          if (!*i) {
            break;
          }
        }

        uint64_t v63 = (_DWORD)i - "\x05local" + 1;
        if ((unsigned __int16)v63 <= 0x100u)
        {
          memcpy((void *)(v47 + 356), "\x05local", (unsigned __int16)v63);
          goto LABEL_102;
        }

void mDNS_Unlock_(uint64_t a1, uint64_t a2, int a3)
{
  unsigned int v6 = *(_DWORD *)(a1 + 52);
  unsigned int v7 = *(_DWORD *)(a1 + 48) - 1;
  *(_DWORD *)(a1 + 48) = v7;
  mDNS_VerifyLockState("Unlock", 0, v7, v6, a2, a3);
  if (!*(_DWORD *)(a1 + 48))
  {
    int v8 = *(_DWORD *)(a1 + 64);
    int v9 = v8 + 939524096;
    if (*(_DWORD *)(a1 + 16))
    {
      int v10 = v8 + 939524096;
    }

    else
    {
      uint64_t v11 = *(void *)(a1 + 208);
      if (!v11 || (int v9 = *(_DWORD *)(v11 + 204), v10 = *(_DWORD *)(a1 + 64), v9))
      {
        int v10 = *(_DWORD *)(a1 + 64);
        if (!*(void *)(a1 + 232))
        {
          uint64_t v12 = *(uint64_t **)(a1 + 12640);
          if (v12)
          {
            while (*((_BYTE *)v12 + 8) == 2)
            {
              uint64_t v12 = (uint64_t *)*v12;
              if (!v12) {
                goto LABEL_10;
              }
            }

            int v10 = *(_DWORD *)(a1 + 64);
          }

          else
          {
LABEL_10:
            int v10 = *(_DWORD *)(a1 + 64);
            if (!*(_BYTE *)(a1 + 12656))
            {
              int v10 = *(_DWORD *)(a1 + 64);
              if (!*(void *)(a1 + 15040))
              {
                int v10 = *(_DWORD *)(a1 + 64);
                if (!*(_BYTE *)(a1 + 140))
                {
                  if (v9 - *(_DWORD *)(a1 + 12688) > 0) {
                    int v9 = *(_DWORD *)(a1 + 12688);
                  }
                  if (v9 - *(_DWORD *)(a1 + 104) > 0) {
                    int v9 = *(_DWORD *)(a1 + 104);
                  }
                  int v13 = *(_DWORD *)(a1 + 12692);
                  if (v9 - v13 > 0 && v13 != 0) {
                    int v9 = *(_DWORD *)(a1 + 12692);
                  }
                  if (v9 - *(_DWORD *)(a1 + 88) > 0) {
                    int v9 = *(_DWORD *)(a1 + 88);
                  }
                  if (v9 - *(_DWORD *)(a1 + 108) > 0) {
                    int v9 = *(_DWORD *)(a1 + 108);
                  }
                  int v15 = *(_DWORD *)(a1 + 116);
                  if (v9 - *(_DWORD *)(a1 + 112) > 0) {
                    int v9 = *(_DWORD *)(a1 + 112);
                  }
                  if (v9 - v15 <= 0 || v15 == 0) {
                    int v17 = v9;
                  }
                  else {
                    int v17 = *(_DWORD *)(a1 + 116);
                  }
                  for (uint64_t i = *(void *)(a1 + 14088); i; uint64_t i = *(void *)(i + 296))
                  {
                    for (uint64_t j = 0LL; j != 40; j += 8LL)
                    {
                      uint64_t v20 = *(void *)(i + 256 + j);
                      if (v20)
                      {
                        if (*(_DWORD *)(v20 + 664) == 2)
                        {
                          int v21 = *(_DWORD *)(v20 + 672);
                          if (v17 - v21 > 0) {
                            int v17 = v21;
                          }
                        }
                      }
                    }
                  }

                  int next_scheduled_event = resolver_discovery_get_next_scheduled_event();
                  if (v17 - next_scheduled_event <= 0 || next_scheduled_event == 0) {
                    int v24 = v17;
                  }
                  else {
                    int v24 = next_scheduled_event;
                  }
                  int v25 = *(_DWORD *)(a1 + 152);
                  if (!v25 && *(_DWORD *)(a1 + 156) && v24 - *(_DWORD *)(a1 + 184) > 0) {
                    int v24 = *(_DWORD *)(a1 + 184);
                  }
                  if (v24 - v25 > 0 && v25 != 0) {
                    int v24 = *(_DWORD *)(a1 + 152);
                  }
                  int v27 = *(_DWORD *)(a1 + 80);
                  if (v27)
                  {
                    if (v24 - v27 > 0) {
                      int v24 = *(_DWORD *)(a1 + 80);
                    }
                  }

                  else
                  {
                    if (v24 - *(_DWORD *)(a1 + 92) > 0) {
                      int v24 = *(_DWORD *)(a1 + 92);
                    }
                    if (v24 - *(_DWORD *)(a1 + 96) > 0) {
                      int v24 = *(_DWORD *)(a1 + 96);
                    }
                  }

                  int v31 = *(_DWORD *)(a1 + 84);
                  if (!v31) {
                    int v31 = *(_DWORD *)(a1 + 100);
                  }
                  if (v24 - v31 > 0) {
                    int v24 = v31;
                  }
                  int v32 = *(_DWORD *)(a1 + 192);
                  if (v24 - *(_DWORD *)(a1 + 188) > 0) {
                    int v24 = *(_DWORD *)(a1 + 188);
                  }
                  if (v24 - v32 > 0 && v32 != 0) {
                    int v24 = *(_DWORD *)(a1 + 192);
                  }
                  int v34 = *(_DWORD *)(a1 + 164);
                  int v35 = *(_DWORD *)(a1 + 168);
                  if (v24 - v34 > 0 && v34 != 0) {
                    int v24 = *(_DWORD *)(a1 + 164);
                  }
                  if (v24 - v35 <= 0 || v35 == 0) {
                    int v10 = v24;
                  }
                  else {
                    int v10 = *(_DWORD *)(a1 + 168);
                  }
                }
              }
            }
          }
        }
      }
    }

    *(_DWORD *)(a1 + 72) = v10;
    if (v8) {
      goto LABEL_73;
    }
    uint64_t v28 = (os_log_s *)mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_ERROR))
      {
LABEL_73:
        *(_DWORD *)(a1 + 64) = 0;
        return;
      }

      int v38 = 136446210;
      uint64_t v39 = a2;
    }

    else
    {
      uint64_t v28 = (os_log_s *)mDNSLogCategory_Default_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_ERROR)) {
        goto LABEL_73;
      }
      int v38 = 136446210;
      uint64_t v39 = a2;
    }

    _os_log_impl( (void *)&_mh_execute_header,  v28,  OS_LOG_TYPE_ERROR,  "%{public}s: mDNS_Unlock: ERROR! m->timenow aready zero",  (uint8_t *)&v38,  0xCu);
    goto LABEL_73;
  }

void SetupActiveInterfaces(int a1)
{
  dword_10015BD40 = 0;
  uint64_t v1 = *(int8x8_t **)mDNSStorage[0];
  if (*(void *)mDNSStorage[0])
  {
    int v72 = 136447235;
    do
    {
      if (!v1[800].i8[0]) {
        goto LABEL_178;
      }
      uint64_t v2 = SearchForInterfaceByName((char *)&v1[788] + 6, 0);
      uint64_t v3 = v2;
      int8x8_t v4 = v1[810];
      if (v4) {
        BOOL v5 = *(void *)&v4 == v2;
      }
      else {
        BOOL v5 = 1;
      }
      if (v5)
      {
        if (v4) {
          goto LABEL_178;
        }
      }

      else
      {
        unsigned int v6 = (os_log_s *)mDNSLogCategory_State;
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 134218240;
          *(int8x8_t *)int v75 = v4;
          *(_WORD *)&v75[8] = 2048;
          *(void *)&v75[10] = v3;
          _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_ERROR,  "SetupActiveInterfaces ERROR! n->Registered %p != primary %p",  buf,  0x16u);
        }
      }

      v1[810] = (int8x8_t)v3;
      BOOL v8 = (v1[802].i8[0] & 8) == 0 && (~v1[801].i32[0] + a1) < 0x3B;
      v1[800].i8[2] = v8;
      if (!strncmp((const char *)&v1[788] + 6, "p2p", 3uLL) || v1[797].i8[4])
      {
        int v9 = (os_log_s *)mDNSLogCategory_State;
        int v10 = 1;
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_INFO))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)int v75 = (char *)v1 + 6310;
          _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_INFO,  "SetupActiveInterfaces: %{public}s DirectLink interface registering",  buf,  0xCu);
        }
      }

      else
      {
        int v10 = 0;
      }

      if (v1[782])
      {
        __int32 v11 = v1[785].i32[1];
        if (v11 == 6)
        {
          if (vorr_s8( v1[786],  (int8x8_t)*(_OWORD *)&vextq_s8(*(int8x16_t *)v1[786].i8, *(int8x16_t *)v1[786].i8, 8uLL)))
          {
            goto LABEL_25;
          }
        }

        else if (v11 == 4 && v1[786].i32[0])
        {
LABEL_25:
          mDNS_Lock_((unsigned int *)mDNSStorage, (uint64_t)"mDNS_RegisterInterface", 16886);
          v1[2].i8[0] = 1;
          __int32 v12 = v1[783].i32[0];
          if (v12 == 4)
          {
            BOOL v13 = 0;
            v1[2].i8[1] = v1[796].i8[7] != 0;
          }

          else
          {
            BOOL v13 = 0;
            v1[2].i8[1] = 0;
            if (v12 == 6) {
              BOOL v13 = v1[796].i8[7] != 0;
            }
          }

          v1[2].i8[2] = v13;
          v1[29].i32[1] = -1;
          uint64_t v19 = 662LL;
          for (uint64_t i = 223LL; i != 715; i += 164LL)
          {
            v1->i32[i] = -1;
            v1->i32[v19] = 0;
            v19 += 5LL;
          }

          v1[339].i32[1] = -1;
          v1[340].i32[0] = dword_100158BF8;
          int v21 = (int8x8_t *)xmmword_10015BD30;
          if ((void)xmmword_10015BD30)
          {
            int v22 = 1;
            char v23 = 1;
            while (v21 != v1)
            {
              int v24 = (int8x8_t **)v21;
              if (*(void *)&v21[782] == *(void *)&v1[782])
              {
                v1[2].i8[0] = 0;
                __int32 v25 = v1[783].i32[0];
                if (v25 == v21[783].i32[0]) {
                  char v23 = 0;
                }
                if (v25 == 6)
                {
                  int v22 = v1[796].u8[7];
                  if (v1[796].i8[7])
                  {
                    int v22 = 0;
                    v21[2].i8[2] = 1;
                  }
                }

                else if (v25 == 4)
                {
                  int v22 = v1[796].u8[7];
                  if (v1[796].i8[7])
                  {
                    int v22 = 0;
                    v21[2].i8[1] = 1;
                  }
                }

                else
                {
                  int v22 = 0;
                }
              }

              int v21 = (int8x8_t *)*v21;
              if (!*v24) {
                goto LABEL_61;
              }
            }

            __int128 v36 = (os_log_s *)mDNSLogCategory_mDNS;
            if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
            {
              if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_ERROR)) {
                goto LABEL_82;
              }
            }

            else
            {
              __int128 v36 = (os_log_s *)mDNSLogCategory_mDNS_redacted;
              if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_ERROR))
              {
LABEL_82:
                *(_DWORD *)buf = 136446979;
                *(void *)int v75 = (char *)v1 + 6310;
                *(_WORD *)&v75[8] = 2160;
                *(void *)&v75[10] = 1752392040LL;
                *(_WORD *)&v75[18] = 1045;
                *(_DWORD *)&v75[20] = 20;
                __int16 v76 = 2101;
                *(void *)uint64_t v77 = v1 + 783;
                _os_log_impl( (void *)&_mh_execute_header,  v36,  OS_LOG_TYPE_ERROR,  "Tried to register a NetworkInterfaceInfo that's already in the list - ifname: %{public}s, ifaddr: %{se nsitive, mask.hash, mdnsresponder:ip_addr}.20P",  buf,  0x26u);
              }
            }

            int v39 = 16904;
LABEL_157:
            mDNS_Unlock_((uint64_t)mDNSStorage, (uint64_t)"mDNS_RegisterInterface", v39);
            goto LABEL_158;
          }

          int v24 = (int8x8_t **)((char *)&dword_100158BF8 + &unk_100003138);
          int v22 = 1;
          char v23 = 1;
LABEL_61:
          *uint64_t v1 = 0LL;
          *int v24 = v1;
          if (v1[796].i8[6])
          {
            AdvertiseInterfaceIfNeeded(mDNSStorage, (uint64_t)v1);
            int v22 = v1[2].u8[0];
          }

          char v26 = gSensitiveLoggingEnabled;
          uint64_t v27 = mDNSLogCategory_mDNS;
          if (mDNSLogCategory_mDNS == mDNSLogCategory_State) {
            char v26 = 0;
          }
          if (v22)
          {
            if ((v26 & 1) != 0)
            {
              uint64_t v27 = mDNSLogCategory_mDNS_redacted;
              if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
                goto LABEL_68;
              }
LABEL_87:
              if (v1[797].i8[0]) {
                mDNS_ActivateNetWake_internal((uint64_t)v1);
              }
              if (!v1[796].i8[7] || !v23 && !v1[2].i8[0]) {
                goto LABEL_145;
              }
              if (v10)
              {
                int v41 = (os_log_s *)mDNSLogCategory_mDNS;
                if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
                {
                  int v42 = 0;
                  if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
                    goto LABEL_99;
                  }
                }

                else
                {
                  int v41 = (os_log_s *)mDNSLogCategory_mDNS_redacted;
                  int v42 = 0;
                  if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
                  {
LABEL_99:
                    *(_DWORD *)buf = 136446979;
                    *(void *)int v75 = (char *)v1 + 6310;
                    *(_WORD *)&v75[8] = 2160;
                    *(void *)&v75[10] = 1752392040LL;
                    *(_WORD *)&v75[18] = 1045;
                    *(_DWORD *)&v75[20] = 20;
                    __int16 v76 = 2101;
                    *(void *)uint64_t v77 = v1 + 783;
                    _os_log_impl( (void *)&_mh_execute_header,  v41,  OS_LOG_TYPE_DEFAULT,  "Using fast activation for DirectLink interface - ifname: %{public}s, ifaddr: %{sensitive, mask.has h, mdnsresponder:ip_addr}.20P",  buf,  0x26u);
                    int v42 = 0;
                  }
                }
              }

              else
              {
                int v42 = 500;
              }

              int v43 = (os_log_s *)mDNSLogCategory_mDNS;
              if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
              {
                if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
                  goto LABEL_105;
                }
              }

              else
              {
                int v43 = (os_log_s *)mDNSLogCategory_mDNS_redacted;
                if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
                {
LABEL_105:
                  *(_DWORD *)buf = v72;
                  *(void *)int v75 = (char *)v1 + 6310;
                  *(_WORD *)&v75[8] = 2160;
                  *(void *)&v75[10] = 1752392040LL;
                  *(_WORD *)&v75[18] = 1045;
                  *(_DWORD *)&v75[20] = 20;
                  __int16 v76 = 2101;
                  *(void *)uint64_t v77 = v1 + 783;
                  *(_WORD *)&v77[8] = 1024;
                  *(_DWORD *)&v77[10] = v42;
                  _os_log_impl( (void *)&_mh_execute_header,  v43,  OS_LOG_TYPE_DEFAULT,  "Interface probe will be delayed - ifname: %{public}s, ifaddr: %{sensitive, mask.hash, mdnsresponder: ip_addr}.20P, probe delay: %d",  buf,  0x2Cu);
                }
              }

              if (v10)
              {
                qword_100158C08 = 0LL;
                dword_10015BD40 = 0;
                int v44 = dword_100158BF8;
              }

              else
              {
                int v44 = dword_100158BF8;
                if (!(_DWORD)qword_100158C08)
                {
                  do
                    uint32_t v45 = arc4random() & 0x1FF;
                  while (v45 > 0x14E);
                  unsigned int v46 = v45 + v44;
                  if (v46 <= 1) {
                    unsigned int v46 = 1;
                  }
                  LODWORD(qword_100158C08) = v46;
                  int v44 = dword_100158BF8;
                }

                int v47 = v44 + v42;
                if (!dword_10015BD40 || dword_10015BD40 - v47 < 0) {
                  dword_10015BD40 = v47;
                }
              }

              int v48 = v44 + 60000;
              dword_100158C4C = v48;
              int v49 = (os_log_s *)mDNSLogCategory_mDNS;
              if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
              {
                if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEBUG)) {
                  goto LABEL_125;
                }
              }

              else
              {
                int v49 = (os_log_s *)mDNSLogCategory_mDNS_redacted;
                if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEBUG))
                {
LABEL_125:
                  *(_WORD *)buf = 0;
                  _os_log_impl((void *)&_mh_execute_header, v49, OS_LOG_TYPE_DEBUG, "Setting AnnounceOwner", buf, 2u);
                }
              }

              ++*(_DWORD *)((char *)&qword_100158C80 + &loc_100004D00);
              uint64_t v51 = qword_100158C80;
              if (qword_100158C80)
              {
                while (2)
                {
                  if (*(_WORD *)(v51 + 320)) {
                    goto LABEL_136;
                  }
                  uint64_t v52 = *(void *)(v51 + 136);
                  if (v52)
                  {
                    if (v52 != *(void *)&v1[782]) {
                      goto LABEL_136;
                    }
                  }

                  else if (!mDNSPlatformValidQuestionForInterface( v51,  (uint64_t)v1,  v50,  v28,  v29,  v30,  v31,  v32))
                  {
                    goto LABEL_136;
                  }

                  int v53 = *(_DWORD *)(v51 + 212);
                  if (!v53 || v53 >= 335)
                  {
                    int v53 = 334;
                    *(_DWORD *)(v51 + 212) = 334;
                    *(_BYTE *)(v51 + 332) = 2;
                  }

                  *(_DWORD *)(v51 + 208) = dword_100158BF8 - v53;
                  *(_DWORD *)(v51 + 224) = 0;
                  SetNextQueryTime((uint64_t)mDNSStorage, v51);
LABEL_136:
                  uint64_t v51 = *(void *)(v51 + 8);
                  if (!v51) {
                    break;
                  }
                  continue;
                }
              }

              uint64_t v54 = (void *)xmmword_10015BD08;
              if (!(void)xmmword_10015BD08)
              {
LABEL_145:
                if (mDNS_LoggingEnabled == 1) {
                  LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "RestartRecordGetZoneData: ResourceRecords",  v28,  v29,  v30,  v31,  v32,  v72);
                }
                for (uint64_t j = xmmword_10015BD08; j; uint64_t j = *(void *)j)
                {
                  if (!*(void *)(j + 32)
                    && !*(_BYTE *)(j + 122)
                    && !IsLocalDomain(*(_BYTE **)(j + 40))
                    && *(_DWORD *)(j + 344) != 8)
                  {
                    uint64_t v58 = *(_DWORD **)(j + 376);
                    if (v58)
                    {
                      *(_WORD *)(j + 358) = 0;
                      CancelGetZoneData((uint64_t)mDNSStorage, v58);
                    }

                    *(void *)(j + 376) = StartGetZoneData((unsigned int *)mDNSStorage, *(_BYTE **)(j + 40), j);
                  }
                }

                mDNS_UpdateAllowSleep((uint64_t)mDNSStorage);
                int v39 = 17072;
                goto LABEL_157;
              }

              while (2)
              {
                uint64_t v55 = (uint64_t)v1[782];
                uint64_t v56 = v54[4];
                if (v56)
                {
                  if (v56 == v55) {
                    goto LABEL_140;
                  }
                }

                else if (mDNSPlatformValidRecordForInterface( (uint64_t)v54,  v55,  v50,  v28,  v29,  v30,  v31,  v32))
                {
LABEL_140:
                  mDNSCoreRestartRegistration(mDNSStorage, (uint64_t)v54, 4);
                }

                uint64_t v54 = (void *)*v54;
                if (!v54) {
                  goto LABEL_145;
                }
                continue;
              }
            }

            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_87;
            }
LABEL_68:
            int8x8_t v33 = v1[782];
            *(_DWORD *)buf = 67110147;
            *(_DWORD *)int v75 = v33.i32[0];
            *(_WORD *)&v75[4] = 2082;
            *(void *)&v75[6] = (char *)v1 + 6310;
            *(_WORD *)&v75[14] = 2160;
            *(void *)&v75[16] = 1752392040LL;
            __int16 v76 = 1045;
            *(_DWORD *)uint64_t v77 = 20;
            *(_WORD *)&v77[4] = 2101;
            *(void *)&v77[6] = v1 + 783;
            int v34 = (os_log_s *)v27;
            int v35 = "Interface not represented in list; marking active and retriggering queries - ifid: %d, ifname: %{publi"
                  "c}s, ifaddr: %{sensitive, mask.hash, mdnsresponder:ip_addr}.20P";
          }

          else
          {
            if ((v26 & 1) != 0)
            {
              uint64_t v27 = mDNSLogCategory_mDNS_redacted;
              if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
                goto LABEL_87;
              }
            }

            else if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
            {
              goto LABEL_87;
            }

            int8x8_t v40 = v1[782];
            *(_DWORD *)buf = 67110147;
            *(_DWORD *)int v75 = v40.i32[0];
            *(_WORD *)&v75[4] = 2082;
            *(void *)&v75[6] = (char *)v1 + 6310;
            *(_WORD *)&v75[14] = 2160;
            *(void *)&v75[16] = 1752392040LL;
            __int16 v76 = 1045;
            *(_DWORD *)uint64_t v77 = 20;
            *(_WORD *)&v77[4] = 2101;
            *(void *)&v77[6] = v1 + 783;
            int v34 = (os_log_s *)v27;
            int v35 = "Interface already represented in list - ifid: %d, ifname: %{public}s, ifaddr: %{sensitive, mask.hash, "
                  "mdnsresponder:ip_addr}.20P";
          }

          _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, v35, buf, 0x2Cu);
          goto LABEL_87;
        }

        uint64_t v15 = mDNSLogCategory_mDNS;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
        {
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_ERROR))
          {
LABEL_39:
            *(_DWORD *)buf = 141559043;
            *(void *)int v75 = 1752392040LL;
            *(_WORD *)&v75[8] = 1045;
            *(_DWORD *)&v75[10] = 20;
            *(_WORD *)&v75[14] = 2101;
            *(void *)&v75[16] = v1 + 783;
            __int16 v76 = 1042;
            *(_DWORD *)uint64_t v77 = 20;
            *(_WORD *)&v77[4] = 2098;
            *(void *)&v77[6] = (char *)v1 + 6284;
            int v16 = (os_log_s *)v15;
            int v17 = "Tried to register a NetworkInterfaceInfo with invalid mask - ifaddr: %{sensitive, mask.hash, mdnsrespo"
                  "nder:ip_addr}.20P, ifmask: %{public, mdnsresponder:ip_addr}.20P";
            uint32_t v18 = 44;
            goto LABEL_40;
          }
        }

        else
        {
          uint64_t v15 = mDNSLogCategory_mDNS_redacted;
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_ERROR)) {
            goto LABEL_39;
          }
        }
      }

      else
      {
        uint64_t v14 = mDNSLogCategory_mDNS;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
        {
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_ERROR))
          {
LABEL_37:
            *(_DWORD *)buf = 141558531;
            *(void *)int v75 = 1752392040LL;
            *(_WORD *)&v75[8] = 1045;
            *(_DWORD *)&v75[10] = 20;
            *(_WORD *)&v75[14] = 2101;
            *(void *)&v75[16] = v1 + 783;
            int v16 = (os_log_s *)v14;
            int v17 = "Tried to register a NetworkInterfaceInfo with zero InterfaceID - ifaddr: %{sensitive, mask.hash, mdnsr"
                  "esponder:ip_addr}.20P";
            uint32_t v18 = 28;
LABEL_40:
            _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, v17, buf, v18);
          }
        }

        else
        {
          uint64_t v14 = mDNSLogCategory_mDNS_redacted;
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_ERROR)) {
            goto LABEL_37;
          }
        }
      }

LABEL_158:
      uint64_t v59 = (os_log_s *)mDNSLogCategory_State;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT))
      {
        __int32 v60 = v1[803].i32[0];
        int v61 = CountMaskBits((int *)&v1[785] + 1);
        uint64_t v62 = " (Flashing)";
        if (!v1[800].i8[1]) {
          uint64_t v62 = "";
        }
        uint64_t v63 = " (Occulting)";
        if (!v1[800].i8[2]) {
          uint64_t v63 = "";
        }
        uint64_t v64 = " (Primary)";
        if (!v1[2].i8[0]) {
          uint64_t v64 = "";
        }
        *(_DWORD *)buf = 136449539;
        *(void *)int v75 = (char *)v1 + 6310;
        *(_WORD *)&v75[8] = 1024;
        *(_DWORD *)&v75[10] = v60;
        *(_WORD *)&v75[14] = 2160;
        *(void *)&v75[16] = 1752392040LL;
        __int16 v76 = 1045;
        *(_DWORD *)uint64_t v77 = 6;
        *(_WORD *)&v77[4] = 2101;
        *(void *)&v77[6] = (char *)v1 + 6428;
        __int16 v78 = 2048;
        uint64_t v79 = v1;
        __int16 v80 = 2048;
        uint64_t v81 = v3;
        __int16 v82 = 2160;
        uint64_t v83 = 1752392040LL;
        __int16 v84 = 1045;
        int v85 = 20;
        __int16 v86 = 2101;
        uint64_t v87 = v1 + 783;
        __int16 v88 = 1024;
        int v89 = v61;
        __int16 v90 = 2082;
        unsigned int v91 = v62;
        __int16 v92 = 2082;
        int v93 = v63;
        __int16 v94 = 2082;
        uint64_t v95 = v64;
        _os_log_impl( (void *)&_mh_execute_header,  v59,  OS_LOG_TYPE_DEFAULT,  "SetupActiveInterfaces: Registered %{public}s (%u) BSSID %{sensitive, mask.hash, mdnsresponder:mac_addr}.6P Str uct addr %p, primary %p, %{sensitive, mask.hash, mdnsresponder:ip_addr}.20P/%d%{public}s%{public}s%{public}s",  buf,  0x7Eu);
      }

      int v65 = v1[804].u16[1];
      if (v1[796].i8[7])
      {
        if (v65 != 30 && v65 != 2) {
          goto LABEL_178;
        }
        uint64_t v66 = 56LL;
        if (v65 == 2) {
          uint64_t v66 = 24LL;
        }
        int v67 = *(_DWORD *)(mDNSStorage[0] + v66);
        int v68 = v67;
        uint64_t v69 = (uint64_t)v1;
        int v70 = 1;
      }

      else
      {
        uint64_t v71 = 56LL;
        if (v65 == 2) {
          uint64_t v71 = 24LL;
        }
        int v68 = *(_DWORD *)(mDNSStorage[0] + v71);
        uint64_t v69 = (uint64_t)v1;
        int v70 = 0;
      }

      mDNSGroupJoinOrLeave(v68, v69, v70);
LABEL_178:
      uint64_t v1 = (int8x8_t *)v1[798];
    }

    while (v1);
  }

uint64_t SearchForInterfaceByName(char *__s2, int a2)
{
  for (uint64_t i = *(void *)mDNSStorage; i; uint64_t i = *(void *)(i + 6384))
  {
    if (*(_BYTE *)(i + 6400) && !strcmp((const char *)(i + 6310), __s2))
    {
      switch(a2)
      {
        case 2:
          if (*(_DWORD *)(i + 6264) == 4) {
            return i;
          }
          break;
        case 30:
          if (*(_DWORD *)(i + 6264) == 6) {
            return i;
          }
          break;
        case 0:
          return i;
      }
    }
  }

  return i;
}

void AdvertiseInterface(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v5 = *(void *)(a2 + 6256);
  if (AWDLInterfaceID) {
    BOOL v6 = AWDLInterfaceID == v5;
  }
  else {
    BOOL v6 = 0;
  }
  if (v6)
  {
    int v8 = 1;
  }

  else
  {
    if (WiFiAwareInterfaceID) {
      BOOL v7 = WiFiAwareInterfaceID == v5;
    }
    else {
      BOOL v7 = 0;
    }
    int v8 = v7;
  }

  int v9 = v8 | a3;
  if (v8 | a3) {
    int v10 = (_BYTE *)(a1 + 10672);
  }
  else {
    int v10 = (_BYTE *)(a1 + 10416);
  }
  if (v9) {
    __int32 v11 = mDNS_RandomizedHostNameCallback;
  }
  else {
    __int32 v11 = mDNS_HostNameCallback;
  }
  if (a3) {
    int v12 = v8;
  }
  else {
    int v12 = 1;
  }
  FirstAddressRecord = (uint64_t *)(a2 + 2728);
  if (v12) {
    uint64_t v14 = a2 + 2728;
  }
  else {
    uint64_t v14 = a2 + 5080;
  }
  if (*(_BYTE *)(v14 + 8)) {
    return;
  }
  int v43 = v12;
  uint64_t v42 = a2 + 3904;
  uint64_t v40 = a2 + 4556;
  int v15 = v9 | *(unsigned __int8 *)(a2 + 6380);
  memset(v49, 0, 74);
  if (v15) {
    char v16 = 32;
  }
  else {
    char v16 = 2;
  }
  char v41 = v16;
  int v17 = (os_log_s *)mDNSLogCategory_Default;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
  {
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEBUG)) {
      goto LABEL_38;
    }
    uint32_t v18 = "randomized";
    if (!v9) {
      uint32_t v18 = "normal";
    }
  }

  else
  {
    int v17 = (os_log_s *)mDNSLogCategory_Default_redacted;
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEBUG)) {
      goto LABEL_38;
    }
    uint32_t v18 = "randomized";
    if (!v9) {
      uint32_t v18 = "normal";
    }
  }

  *(_DWORD *)buf = 136446466;
  uint64_t v46 = (uint64_t)v18;
  __int16 v47 = 2082;
  uint64_t v48 = a2 + 6310;
  _os_log_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_DEBUG,  "AdvertiseInterface: Advertising %{public}s hostname on interface %{public}s",  buf,  0x16u);
LABEL_38:
  mDNS_SetupResourceRecord(v14, 0LL, *(void *)(a2 + 6256), 1, 0x1194u, v41, 0, (uint64_t)v11, a2);
  if (v43) {
    mDNS_SetupResourceRecord(v42, 0LL, *(void *)(a2 + 6256), 12, 0x1194u, 32, 0, 0LL, 0LL);
  }
  __int32 v25 = v10;
  if (v10 == (_BYTE *)-256LL)
  {
LABEL_42:
    while (v25)
    {
      uint64_t v26 = *v25;
      if (!*v25)
      {
        unsigned __int16 v27 = (_WORD)v25 - (_WORD)v10 + 1;
        if (v27 > 0x100u) {
          break;
        }
        memcpy((void *)(v14 + 652), v10, v27);
        goto LABEL_50;
      }

      v25 += v26 + 1;
      if (v10 != (_BYTE *)-256LL) {
        goto LABEL_41;
      }
    }
  }

  else
  {
LABEL_41:
    if (v25 < v10 + 256) {
      goto LABEL_42;
    }
  }

  *(_BYTE *)(v14 + 652) = 0;
LABEL_50:
  int v28 = *(_DWORD *)(a2 + 6264);
  if (v28 == 6)
  {
    uint64_t v30 = 0LL;
    *(_WORD *)(v14 + 12) = 28;
    *(_OWORD *)(*(void *)(v14 + 48) + 4LL) = *(_OWORD *)(a2 + 6268);
    uint64_t v31 = (char *)v49 + 3;
    do
    {
      unint64_t v32 = *(unsigned __int8 *)(a2 + 6283 + v30);
      *(v31 - 3) = a0123456789abcd_0[v32 & 0xF];
      LOBYTE(v32) = a0123456789abcd_0[v32 >> 4];
      *(v31 - 2) = 46;
      *(v31 - 1) = v32;
      *uint64_t v31 = 46;
      v31 += 4;
      --v30;
    }

    while (v30 != -16);
    uint64_t v29 = &v49[4];
    goto LABEL_56;
  }

  if (v28 == 4)
  {
    *(_WORD *)(v14 + 12) = 1;
    *(_DWORD *)(*(void *)(v14 + 48) + 4LL) = *(_DWORD *)(v40 + 1712);
    uint64_t v29 = v49;
LABEL_56:
    mDNS_snprintf(v29);
  }

  if (!v43
    || (*(_BYTE *)uint64_t v40 = 0,
        AppendDNSNameString((_BYTE *)v40, (unsigned __int8 *)v49, v19, v20, v21, v22, v23, v24),
        *(_BYTE *)(a2 + 4024) = 1,
        *(_BYTE *)(a2 + 4026) = 1,
        (v8 & 1) == 0))
  {
    FirstAddressRecord = GetFirstAddressRecordEx(*(uint64_t **)(a1 + 12664), a3);
  }

  if (FirstAddressRecord) {
    uint64_t v33 = (uint64_t)FirstAddressRecord;
  }
  else {
    uint64_t v33 = v14;
  }
  *(void *)(v14 + 96) = v33;
  mDNS_Register_internal(a1, v14);
  int v34 = (os_log_s *)mDNSLogCategory_Default;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
  {
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEBUG))
    {
LABEL_68:
      GetRRDisplayString_rdb( (unsigned __int8 *)(v14 + 8),  (unsigned __int16 *)(*(void *)(v14 + 48) + 4LL),  (_BYTE *)(a1 + 46976));
      *(_DWORD *)buf = 141558275;
      uint64_t v46 = 1752392040LL;
      __int16 v47 = 2085;
      uint64_t v48 = a1 + 46976;
      _os_log_impl( (void *)&_mh_execute_header,  v34,  OS_LOG_TYPE_DEBUG,  "Initialized RRSet for %{sensitive, mask.hash}s",  buf,  0x16u);
    }
  }

  else
  {
    int v34 = (os_log_s *)mDNSLogCategory_Default_redacted;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEBUG)) {
      goto LABEL_68;
    }
  }

  int v35 = (os_log_s *)mDNSLogCategory_Default;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
  {
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEBUG)) {
      goto LABEL_76;
    }
    uint64_t v37 = *(void *)(v14 + 96);
    *(_DWORD *)buf = 134217984;
    uint64_t v46 = v37;
  }

  else
  {
    int v35 = (os_log_s *)mDNSLogCategory_Default_redacted;
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEBUG)) {
      goto LABEL_76;
    }
    uint64_t v36 = *(void *)(v14 + 96);
    *(_DWORD *)buf = 134217984;
    uint64_t v46 = v36;
  }

  _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_DEBUG, "RRSet:                %lx", buf, 0xCu);
LABEL_76:
  if (v43) {
    mDNS_Register_internal(a1, v42);
  }
  uint64_t v38 = *(void *)(a2 + 6256);
  if (v38 == AWDLInterfaceID || v38 == WiFiAwareInterfaceID)
  {
    if (!*(_BYTE *)(a2 + 2736) && !*(_BYTE *)(a2 + 3912)) {
      goto LABEL_89;
    }
    int v39 = (os_log_s *)mDNSLogCategory_D2D;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_D2D == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_D2D, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v46 = a2 + 6310;
        goto LABEL_88;
      }
    }

    else
    {
      int v39 = (os_log_s *)mDNSLogCategory_D2D_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_D2D_redacted, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v46 = a2 + 6310;
LABEL_88:
        _os_log_impl( (void *)&_mh_execute_header,  v39,  OS_LOG_TYPE_DEFAULT,  "D2D_start_advertising_interface - ifname: %{public}s",  buf,  0xCu);
      }
    }

LABEL_89:
    if (*(_BYTE *)(a2 + 2736)) {

    }
      internal_start_advertising_service(a2 + 2736, 0, 0);
    if (*(_BYTE *)(a2 + 3912)) {

    }
      internal_start_advertising_service(a2 + 3912, 0, 0);
  }

  *(void *)a2 = 0LL;
  int v44 = *(unsigned __int8 *)(a2 + 120);
  if (*(_BYTE *)(a2 + 120) && v10)
  {
    *int v10 = 0;
    int v44 = *(unsigned __int8 *)(a2 + 120);
  }

  *(_WORD *)(a2 + 188) = 0;
  if (*(_BYTE *)(a2 + 8) == 2) {
    uint32_t v45 = 3;
  }
  else {
    uint32_t v45 = 0;
  }
  *(_BYTE *)(a2 + 190) = v45;
  *(_BYTE *)(a2 + 191) = 4;
  *(_DWORD *)(a2 + 192) = 0;
  *(void *)(a2 + 264) = 0LL;
  *(void *)(a2 + 272) = 0LL;
  *(void *)(a2 + 256) = 0LL;
  *(_OWORD *)(a2 + 200) = 0u;
  *(_OWORD *)(a2 + 216) = 0u;
  *(_OWORD *)(a2 + 232) = 0u;
  *(_DWORD *)(a2 + 248) = 0;
  if (!v44) {
    InitializeLastAPTime((_DWORD *)a1, a2);
  }
  *(void *)(a2 + 304) = 0LL;
  *(_WORD *)(a2 + 312) = 0;
  *(void *)(a2 + 320) = 0LL;
  *(void *)(a2 + 328) = 10LL;
  *(_DWORD *)(a2 + 336) = 0;
  if (*(_DWORD *)(a2 + 126) && !*(_DWORD *)(a2 + 144)) {
    *(_BYTE *)(a2 + 191) = 2;
  }
  *(_DWORD *)(a2 + 344) = 0;
  *(_BYTE *)(a2 + 348) = 0;
  *(_DWORD *)(a2 + 352) = 0;
  *(_BYTE *)(a2 + 356) = 0;
  *(_WORD *)(a2 + 358) = 0;
  uint64_t v46 = *(void *)(a2 + 40);
  *(void *)(a2 + 360) = 0LL;
  *(void *)(a2 + 368) = v46;
  *(_DWORD *)(a2 + 616) = 0;
  *(_WORD *)(a2 + 620) = 0;
  *(void *)(a2 + 376) = 0LL;
  *(void *)(a2 + 384) = 0LL;
  *(void *)(a2 + 624) = 0LL;
  *(void *)(a2 + 640) = 0LL;
  *(void *)(a2 + 632) = 0LL;
  if (*(_WORD *)(a2 + 12) == 16 && !*(_WORD *)(a2 + 20))
  {
    *(_WORD *)(a2 + 20) = 1;
    *(_BYTE *)(*(void *)(a2 + 48) + 4LL) = 0;
  }

  if (*(_BYTE *)(a2 + 120))
  {
    SetTargetToHostName(a1, a2);
    if (*(_DWORD *)(a2 + 344) == 8)
    {
      __int16 v47 = *(unsigned __int16 *)(a2 + 12);
      if (v47 <= 0x20)
      {
        switch(*(_WORD *)(a2 + 12))
        {
          case 0xC:
            goto LABEL_155;
          case 0xD:
          case 0xE:
          case 0x10:
          case 0x11:
          case 0x13:
          case 0x14:
            goto LABEL_164;
          case 0xF:
          case 0x12:
          case 0x15:
            goto LABEL_152;
          default:
            if (v47 == 2 || v47 == 5) {
              goto LABEL_155;
            }
            break;
        }

        goto LABEL_164;
      }

      switch(v47)
      {
        case '!':
          uint64_t v71 = (_BYTE *)(*(void *)(a2 + 48) + 10LL);
          break;
        case '$':
LABEL_152:
          uint64_t v71 = (_BYTE *)(*(void *)(a2 + 48) + 6LL);
          break;
        case '\'':
LABEL_155:
          uint64_t v71 = (_BYTE *)(*(void *)(a2 + 48) + 4LL);
          break;
        default:
LABEL_164:
          int v75 = (os_log_s *)mDNSLogCategory_State;
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT))
          {
            GetRRDisplayString_rdb( (unsigned __int8 *)(a2 + 8),  (unsigned __int16 *)(*(void *)(a2 + 48) + 4LL),  (_BYTE *)(a1 + 46976));
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = a1 + 46976;
            _os_log_impl( (void *)&_mh_execute_header,  v75,  OS_LOG_TYPE_DEFAULT,  "mDNS_Register_internal: record %{public}s in NoTarget state",  buf,  0xCu);
          }

          goto LABEL_166;
      }

      char *v71 = 0;
      goto LABEL_164;
    }
  }

  else
  {
    *(_WORD *)(a2 + 20) = GetRDLength(a2 + 8, 0, a3, a4, a5, a6, a7, a8);
    *(_WORD *)(a2 + 22) = GetRDLength(a2 + 8, 1, v51, v52, v53, v54, v55, v56);
  }

      uint64_t v62 = (int *)*((void *)v62 + 3);
    }

    while (v62);
    uint64_t v59 = v870;
    if ((v63 & 1) == 0) {
      goto LABEL_109;
    }
LABEL_103:
    uint64_t v79 = Querier_RegisterNativeDNSService(v59);
    *(void *)(v51 + 1592) = v79;
    if (v865) {
      __int16 v80 = 2;
    }
    else {
      __int16 v80 = 1;
    }
    if (v79) {
      uint64_t v81 = v80;
    }
    else {
      uint64_t v81 = -1;
    }
LABEL_112:
    os_release((void *)v59);
    __int16 v82 = &unk_100164000;
    __int16 v47 = v862;
LABEL_113:
    uint64_t v83 = (os_log_s *)*((void *)v82 + 170);
    if (gSensitiveLoggingEnabled != 1 || v83 == (os_log_s *)mDNSLogCategory_State)
    {
      if (os_log_type_enabled(v83, OS_LOG_TYPE_DEFAULT))
      {
        for (n = (_BYTE *)v48; ; n += v86 + 1)
        {
          if ((unint64_t)n >= v48 + 256 || !n || (__int16 v86 = *n, v86 > 0x3F))
          {
            __int16 v90 = 257;
            goto LABEL_136;
          }

          if (!*n) {
            break;
          }
        }

        __int16 v90 = (_WORD)n - v48 + 1;
LABEL_136:
        *(_DWORD *)buf = 141558787;
        *(void *)&uint8_t buf[4] = 1752392040LL;
        *(_WORD *)&buf[12] = 1040;
        *(_DWORD *)&buf[14] = v90;
        *(_WORD *)&buf[18] = 2101;
        *(void *)&buf[20] = v48;
        *(_WORD *)&buf[28] = 1024;
        *(_DWORD *)&buf[30] = v81;
        _os_log_impl( (void *)&_mh_execute_header,  v83,  OS_LOG_TYPE_DEFAULT,  "Discovered local resolver configuration updated - name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P, result: %d",  buf,  0x22u);
      }
    }

    else
    {
      uint64_t v83 = (os_log_s *)mDNSLogCategory_Default_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
      {
        for (iuint64_t i = (_BYTE *)v48; ; ii += v89 + 1)
        {
          if ((unint64_t)ii >= v48 + 256 || !ii || (int v89 = *ii, v89 > 0x3F))
          {
            __int16 v90 = 257;
            goto LABEL_136;
          }

          if (!*ii) {
            break;
          }
        }

        __int16 v90 = (_WORD)ii - v48 + 1;
        goto LABEL_136;
      }
    }

    *(_DWORD *)(v51 + 1584) = 0;
  }

  while (v46);
  if (g_discover_resolvers)
  {
    unsigned int v91 = *(void **)g_discover_resolvers;
    if (*(void *)g_discover_resolvers)
    {
      __int16 v92 = dword_100158BF8;
      while (2)
      {
        int v93 = v91;
        unsigned int v91 = (void *)*v91;
        __int16 v94 = v93[1];
        if (*(_DWORD *)(v94 + 264)) {
          goto LABEL_187;
        }
        uint64_t v95 = *(_DWORD *)(v94 + 256);
        if (!v95 || v92 - v95 < 0) {
          goto LABEL_187;
        }
        int v96 = v94 + 256;
        uint64_t v97 = (os_log_s *)mDNSLogCategory_Default;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
        {
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
          {
            for (juint64_t j = (_BYTE *)v94; ; jj += v100 + 1)
            {
              if ((unint64_t)jj >= v96 || !jj || (uint64_t v100 = *jj, v100 > 0x3F))
              {
                uint64_t v104 = 257;
                goto LABEL_172;
              }

              if (!*jj) {
                break;
              }
            }

            uint64_t v104 = (_WORD)jj - v94 + 1;
LABEL_172:
            *(_DWORD *)buf = 141558531;
            *(void *)&uint8_t buf[4] = 1752392040LL;
            *(_WORD *)&buf[12] = 1040;
            *(_DWORD *)&buf[14] = v104;
            *(_WORD *)&buf[18] = 2101;
            *(void *)&buf[20] = v94;
            _os_log_impl( (void *)&_mh_execute_header,  v97,  OS_LOG_TYPE_DEFAULT,  "Stopping the resolver discovery -- domain: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P",  buf,  0x1Cu);
          }
        }

        else
        {
          uint64_t v97 = (os_log_s *)mDNSLogCategory_Default_redacted;
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
          {
            for (kk = (_BYTE *)v94; ; kk += v103 + 1)
            {
              if ((unint64_t)kk >= v96 || !kk || (uint64_t v103 = *kk, v103 > 0x3F))
              {
                uint64_t v104 = 257;
                goto LABEL_172;
              }

              if (!*kk) {
                break;
              }
            }

            uint64_t v104 = (_WORD)kk - v94 + 1;
            goto LABEL_172;
          }
        }

        uint64_t v105 = v93[1];
        if (v105)
        {
          uint64_t v106 = *(_DWORD *)(v105 + 260) - 1;
          *(_DWORD *)(v105 + 260) = v106;
          uint64_t v107 = (os_log_s *)mDNSLogCategory_Default;
          if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
          {
            if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEBUG)) {
              goto LABEL_179;
            }
          }

          else
          {
            uint64_t v107 = (os_log_s *)mDNSLogCategory_Default_redacted;
            if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEBUG))
            {
LABEL_179:
              *(_DWORD *)buf = 67109120;
              *(_DWORD *)&uint8_t buf[4] = v106;
              _os_log_impl( (void *)&_mh_execute_header,  v107,  OS_LOG_TYPE_DEBUG,  "discover_resolver_t released - ref count after releasing: %u.",  buf,  8u);
            }
          }

          uint64_t v108 = v93[1];
          if (v108 && !*(_DWORD *)(v108 + 260)) {
            (*(void (**)(void))(v108 + 280))();
          }
        }

        unint64_t v109 = (void *)g_discover_resolvers;
        for (mm = *(void **)g_discover_resolvers; mm != v93; mm = (void *)*mm)
          unint64_t v109 = mm;
        *unint64_t v109 = *v93;
        free(v93);
LABEL_187:
        if (!v91) {
          break;
        }
        continue;
      }
    }
  }

              *((_WORD *)v67 + 10) = v74;
              *((_DWORD *)v67 + 6) = DomainNameHashValue(*((void *)v67 + 5));
              *((_WORD *)v67 + 7) = *((_WORD *)v47 + 7);
              uint64_t v81 = *((unsigned __int16 *)v47 + 6);
              if (v81 == 28)
              {
                *(_OWORD *)(*((void *)v67 + 6) + 4LL) = *(_OWORD *)(v47[6] + 4);
              }

              else if (v81 == 1)
              {
                *(_DWORD *)(*((void *)v67 + 6) + 4LL) = *(_DWORD *)(v47[6] + 4);
              }

              SetNewRData((uint64_t)(v67 + 8), 0LL, 0LL, v76, v77, v78, v79, v80);
              *(void *)int v67 = *v44;
              *int v44 = v67;
              if (*(_BYTE *)(v35 + 2840) == 1)
              {
                __int16 v82 = (os_log_s *)mDNSLogCategory_Default;
                GetRRDisplayString_rdb( (unsigned __int8 *)v47 + 8,  (unsigned __int16 *)(v47[6] + 4),  (_BYTE *)(a1 + 46976));
                LogMsgWithLevel( v82,  OS_LOG_TYPE_DEFAULT,  "%s : Storing proxy record : %s ",  v83,  v84,  v85,  v86,  v87,  (int)"mDNSCoreStoreProxyRR");
              }

              goto LABEL_95;
            }

            v47[26] = -1LL;
            uint64_t v183 = 1;
          }

        uint64_t v23 = 0LL;
LABEL_90:
        *(void *)(a1 + 160) = v23;
        LODWORD(v56) = *(unsigned __int8 *)(*(void *)(a1 + 64) + 133LL);
        if (!*(_BYTE *)(*(void *)(a1 + 64) + 133LL)) {
          goto LABEL_116;
        }
        uint64_t v56 = *(void *)(a1 + 136);
        if (!v56) {
          goto LABEL_116;
        }
        uint64_t v57 = *(void *)(v56 + 32);
        if (!v57) {
          goto LABEL_105;
        }
        uint64_t v81 = 0;
        size = 0LL;
        uint64_t v58 = DNSMessageCollapse(v57, *(void *)(v56 + 40), &size, (char **)&v81);
        if (!v58) {
          goto LABEL_102;
        }
        uint64_t v59 = v58;
        __int32 v60 = dispatch_data_create(v58, size, 0LL, _dispatch_data_destructor_free);
        if (v60)
        {
          int v61 = v60;
          uint64_t v62 = mdns_message_create_with_dispatch_data(v60, 1);
          dispatch_release(v61);
          if (v62)
          {
            os_retain(v62);
            uint64_t v63 = *(void **)(a1 + 136);
            if (v63) {
              os_release(v63);
            }
            *(void *)(a1 + 136) = v62;
            os_release(v62);
            uint64_t v64 = *(void *)(a1 + 136);
            if (v64)
            {
              int v65 = *(void *)(v64 + 32);
              uint64_t v66 = *(void *)(v64 + 40);
            }

            else
            {
              int v65 = 0LL;
              uint64_t v66 = 0LL;
            }

            if (_mdns_resolver_log_s_once != -1) {
              dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_48);
            }
            int v68 = (os_log_s *)_mdns_resolver_log_s_log;
            if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v69 = "";
              int v70 = *(void *)(a1 + 136);
              if (*(void *)(a1 + 128)) {
                uint64_t v69 = *(const char **)(a1 + 128);
              }
              uint64_t v71 = 12;
              *(_DWORD *)buf = 136446978;
              if (v66 < 0xC) {
                uint64_t v71 = v66;
              }
              *(void *)&uint8_t buf[4] = v69;
              uint64_t v83 = 1040;
              *(_DWORD *)__int16 v84 = v71;
              *(_WORD *)&v84[4] = 2098;
              *(void *)&v84[6] = v65;
              int v85 = 2112;
              __int16 v86 = v70;
              _os_log_impl( (void *)&_mh_execute_header,  v68,  OS_LOG_TYPE_DEFAULT,  "%{public}sUsing squashed response -- %{public,mdns:dnshdr}.*P, %@",  buf,  0x26u);
            }

            LODWORD(v56) = 1;
            goto LABEL_116;
          }
        }

        else
        {
          free(v59);
        }

        uint64_t v81 = -6729;
LABEL_102:
        if (_mdns_resolver_log_s_once != -1) {
          dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_48);
        }
        int v67 = (os_log_s *)_mdns_resolver_log_s_log;
        if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_ERROR))
        {
          uint64_t v77 = *(const char **)(a1 + 128);
          if (!v77) {
            uint64_t v77 = "";
          }
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = v77;
          uint64_t v83 = 2048;
          *(void *)__int16 v84 = v81;
          _os_log_error_impl( (void *)&_mh_execute_header,  v67,  OS_LOG_TYPE_ERROR,  "%{public}sFailed to squash response -- error:%{mdns:err}ld",  buf,  0x16u);
        }

double mDNS_SetupResourceRecord( uint64_t a1, uint64_t a2, uint64_t a3, __int16 a4, unsigned int a5, char a6, int a7, uint64_t a8, uint64_t a9)
{
  if (a3 != -2 || a7 == 4)
  {
    if (a3 != -3 || a7 == 5)
    {
      if (a3 || (a7 & 0xFFFFFFFE) != 4) {
        goto LABEL_35;
      }
      int v17 = (os_log_s *)mDNSLogCategory_Default;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_35;
        }
      }

      else
      {
        int v17 = (os_log_s *)mDNSLogCategory_Default_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_35;
        }
      }

      int v28 = 134218240;
      uint64_t v29 = 0LL;
      __int16 v30 = 1024;
      int v31 = a7;
      uint64_t v19 = "mDNS_SetupResourceRecord: ERROR!! Mismatch InterfaceAny record InterfaceID %p called with artype %d";
    }

    else
    {
      int v17 = (os_log_s *)mDNSLogCategory_Default;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_35;
        }
      }

      else
      {
        int v17 = (os_log_s *)mDNSLogCategory_Default_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_35;
        }
      }

      int v28 = 134218240;
      uint64_t v29 = -3LL;
      __int16 v30 = 1024;
      int v31 = a7;
      uint64_t v19 = "mDNS_SetupResourceRecord: ERROR!! Mismatch P2P record InterfaceID %p called with artype %d";
    }
  }

  else
  {
    int v17 = (os_log_s *)mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_35;
      }
    }

    else
    {
      int v17 = (os_log_s *)mDNSLogCategory_Default_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_35;
      }
    }

    int v28 = 134218240;
    uint64_t v29 = -2LL;
    __int16 v30 = 1024;
    int v31 = a7;
    uint64_t v19 = "mDNS_SetupResourceRecord: ERROR!! Mismatch LocalOnly record InterfaceID %p called with artype %d";
  }

  _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, v19, (uint8_t *)&v28, 0x12u);
LABEL_35:
  if (a5) {
    int v25 = a5;
  }
  else {
    int v25 = 4500;
  }
  *(_BYTE *)(a1 + 8) = a6;
  if (a5 <= 0x20C49B) {
    int v26 = v25;
  }
  else {
    int v26 = 2147483;
  }
  *(void *)(a1 + 32) = a3;
  *(void *)(a1 + 40) = a1 + 652;
  *(_WORD *)(a1 + 12) = a4;
  *(_WORD *)(a1 + 14) = 1;
  *(_DWORD *)(a1 + 16) = v26;
  *(void *)(a1 + 56) = 0LL;
  if (!a2)
  {
    a2 = a1 + 908;
    *(_WORD *)(a1 + 908) = 264;
  }

  *(void *)(a1 + 48) = a2;
  double result = 0.0;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(void *)(a1 + 104) = a8;
  *(void *)(a1 + 112) = a9;
  *(_OWORD *)(a1 + 124) = 0u;
  *(_OWORD *)(a1 + 140) = 0u;
  *(_OWORD *)(a1 + 156) = 0u;
  *(_DWORD *)(a1 + 172) = a7;
  *(_DWORD *)(a1 + 120) = 0;
  *(_DWORD *)(a1 + 344) = 0;
  *(_BYTE *)(a1 + 348) = 0;
  *(_DWORD *)(a1 + 352) = 0;
  *(_BYTE *)(a1 + 356) = 0;
  *(_WORD *)(a1 + 358) = 0;
  *(void *)(a1 + 368) = a1 + 652;
  *(_DWORD *)(a1 + 616) = 0;
  *(_WORD *)(a1 + 620) = 0;
  *(void *)(a1 + 640) = 0LL;
  *(_OWORD *)(a1 + 624) = 0u;
  *(_DWORD *)(a1 + 596) = 0;
  *(_BYTE *)(a1 + 652) = 0;
  *(_OWORD *)(a1 + 376) = 0u;
  *(_OWORD *)(a1 + 392) = 0u;
  *(_OWORD *)(a1 + 408) = 0u;
  *(_OWORD *)(a1 + 424) = 0u;
  *(_OWORD *)(a1 + 440) = 0u;
  *(_OWORD *)(a1 + 456) = 0u;
  *(_OWORD *)(a1 + 472) = 0u;
  *(_OWORD *)(a1 + 488) = 0u;
  *(_OWORD *)(a1 + 504) = 0u;
  *(_OWORD *)(a1 + 520) = 0u;
  *(_OWORD *)(a1 + 536) = 0u;
  *(_OWORD *)(a1 + 552) = 0u;
  *(_OWORD *)(a1 + 568) = 0u;
  *(_OWORD *)(a1 + 577) = 0u;
  return result;
}

_BYTE *AppendDNSNameString( _BYTE *a1, unsigned __int8 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = 257LL;
  int v9 = a1;
  if (a1 == (_BYTE *)-256LL)
  {
LABEL_3:
    while (v9)
    {
      uint64_t v10 = *v9;
      if (!*v9)
      {
        uint64_t v8 = (unsigned __int16)((_WORD)v9 - (_WORD)a1 + 1);
        break;
      }

      v9 += v10 + 1;
      if (a1 != (_BYTE *)-256LL) {
        goto LABEL_2;
      }
    }
  }

  else
  {
LABEL_2:
    if (v9 < a1 + 256) {
      goto LABEL_3;
    }
  }

  unint64_t v11 = (unint64_t)&a1[v8 - 1];
  int v12 = *a2;
  BOOL v13 = a2;
  if (v12 == 46)
  {
    if (a2[1]) {
      int v12 = 46;
    }
    else {
      int v12 = 0;
    }
    if (a2[1]) {
      BOOL v13 = a2;
    }
    else {
      BOOL v13 = a2 + 1;
    }
  }

  if (!v12 || (unint64_t v14 = (unint64_t)(a1 + 255), v11 >= (unint64_t)(a1 + 255)))
  {
    uint64_t i = (_BYTE *)v11;
    goto LABEL_44;
  }

  while (2)
  {
    if (v12 == 46)
    {
      LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "AppendDNSNameString: Illegal empty label in name %s",  a4,  a5,  a6,  a7,  a8,  (int)a2);
      return 0LL;
    }

    for (uint64_t i = (_BYTE *)(v11 + 1); ; ++i)
    {
      if (!(_BYTE)v12 || v12 == 46 || (unint64_t)i >= v14)
      {
        char v16 = v13;
        goto LABEL_32;
      }

      char v16 = v13 + 1;
LABEL_30:
      *uint64_t i = v12;
      LOBYTE(v12) = *v16;
      BOOL v13 = v16;
    }

    int v17 = (char)*v16;
    if (*v16)
    {
      LOBYTE(v12) = *v16;
      char v16 = v13 + 2;
      if (v17 - 48 <= 9)
      {
        int v18 = (char)*v16;
        if ((v18 - 48) <= 9)
        {
          int v19 = v13[3];
          a4 = (v19 - 48);
          if (a4 <= 9)
          {
            int v20 = 100 * v17 + 10 * v18 + v19;
            uint64_t v21 = v13 + 4;
            if (v20 < 5584)
            {
              LOBYTE(v12) = v20 + 48;
              char v16 = v21;
            }
          }
        }
      }

      goto LABEL_30;
    }

    LOBYTE(v12) = 0;
LABEL_32:
    uint64_t v22 = (uint64_t)&i[~v11];
    if (v22 > 63) {
      return 0LL;
    }
    else {
      BOOL v13 = v16;
    }
    *(_BYTE *)unint64_t v11 = v22;
    LOBYTE(v12) = *v13;
    if (*v13) {
      BOOL v23 = (unint64_t)i >= v14;
    }
    else {
      BOOL v23 = 1;
    }
    unint64_t v11 = (unint64_t)i;
    if (!v23) {
      continue;
    }
    break;
  }

LABEL_44:
  *uint64_t i = 0;
  uint64_t v24 = i + 1;
  if (*v13) {
    return 0LL;
  }
  else {
    return v24;
  }
}

    unint64_t v14 = (os_log_s *)mDNSLogCategory_Default_redacted;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
    {
      char v16 = *(void *)(a2 + 40);
      if (v16)
      {
        int v28 = *(_BYTE **)(a2 + 40);
        if (v16 == -256)
        {
LABEL_48:
          while (v28)
          {
            uint64_t v29 = *v28;
            if (!*v28)
            {
              uint64_t v42 = (unsigned __int16)((_WORD)v28 - v16 + 1);
              goto LABEL_94;
            }

            v28 += v29 + 1;
            if (v16 != -256) {
              goto LABEL_47;
            }
          }
        }

        else
        {
LABEL_47:
        }

        uint64_t v42 = 257;
      }

      else
      {
        uint64_t v42 = 0;
      }

        *(void *)(*(void *)(v5 + 56) + 40LL) = 0LL;
        *(_BYTE *)(v5 + 109) = 0;
        mDNS_PurgeCacheResourceRecord((unsigned int *)mDNSStorage, v5);
LABEL_45:
        uint64_t v5 = *(void *)v5;
        if (!v5) {
          goto LABEL_46;
        }
      }

      uint64_t v8 = (os_log_s *)mDNSLogCategory_Default_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEBUG)) {
        goto LABEL_44;
      }
      uint64_t v10 = *(void *)(v5 + 40);
      if (v10)
      {
        int v15 = *(_BYTE **)(v5 + 40);
        if (v10 == -256) {
          goto LABEL_30;
        }
LABEL_27:
        char v16 = 257;
        if ((unint64_t)v15 < v10 + 256 && v15)
        {
          while (1)
          {
            int v17 = *v15;
            if (v17 > 0x3F)
            {
LABEL_38:
              char v16 = 257;
              goto LABEL_42;
            }

            if (!*v15) {
              break;
            }
            v15 += v17 + 1;
            if (v10 != -256) {
              goto LABEL_27;
            }
LABEL_30:
            if (!v15) {
              goto LABEL_38;
            }
          }

          char v16 = (_WORD)v15 - v10 + 1;
        }

    _mdns_querier_handle_stream_termination((int8x8_t *)a4, v17);
    return;
  }

  if (a2 != 2)
  {
    if (a2 == 1) {
      _mdns_querier_send_query(a4, a1);
    }
    return;
  }

  if (*(_BYTE *)(a1 + 89))
  {
    int v19 = *(void *)(a4 + 64);
    int v20 = *(void *)(a4 + 128) ? *(const char **)(a4 + 128) : "";
    uint64_t v21 = _mdns_resolver_handle_stream_lateness(*(void *)(a4 + 64), *(void *)(a1 + 32), *(void *)(a1 + 56), v20);
    if (*(_BYTE *)(v19 + 140))
    {
      if (v21) {
LABEL_43:
      }
        _mdns_querier_conclude_ex(a4, 6, 0, 0LL);
    }
  }

          mDNS_Unlock_((uint64_t)&mDNSStorage, (uint64_t)"_purge_validated_record_from_cache", 1962);
          if (++v7 == v6) {
            goto LABEL_78;
          }
        }

        int v18 = (os_log_s *)mDNSLogCategory_DNSSEC_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC_redacted, OS_LOG_TYPE_FAULT)) {
          goto LABEL_44;
        }
        int v20 = *(void *)(v8 + 32);
        if (v20)
        {
          uint64_t v21 = *(_BYTE **)(v8 + 32);
          if (v20 == -256)
          {
LABEL_64:
            while (v21)
            {
              uint64_t v24 = *v21;
              if (!*v21)
              {
                LOWORD(v21) = (_WORD)v21 - v20 + 1;
                goto LABEL_76;
              }

              v21 += v24 + 1;
              if (v20 != -256) {
                goto LABEL_63;
              }
            }
          }

          else
          {
LABEL_63:
          }

          LOWORD(v21) = 257;
LABEL_76:
          LODWORD(v21) = (unsigned __int16)v21;
        }

        else
        {
          LODWORD(v21) = 0;
        }

        goto LABEL_77;
      }

uint64_t mDNS_Register_internal( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10 = 0LL;
  unsigned int v11 = *(unsigned __int16 *)(a2 + 12);
  if (v11 > 0x20)
  {
    switch(v11)
    {
      case '!':
        uint64_t v10 = (_BYTE *)(*(void *)(a2 + 48) + 10LL);
        break;
      case '$':
LABEL_7:
        uint64_t v10 = (_BYTE *)(*(void *)(a2 + 48) + 6LL);
        break;
      case '\'':
LABEL_13:
        uint64_t v10 = (_BYTE *)(*(void *)(a2 + 48) + 4LL);
        break;
    }
  }

  else
  {
    switch(*(_WORD *)(a2 + 12))
    {
      case 0xC:
        goto LABEL_13;
      case 0xD:
      case 0xE:
      case 0x10:
      case 0x11:
      case 0x13:
      case 0x14:
        break;
      case 0xF:
      case 0x12:
      case 0x15:
        goto LABEL_7;
      default:
        if (v11 == 2 || v11 == 5) {
          goto LABEL_13;
        }
        break;
    }
  }

  BOOL v13 = (unsigned __int8 *)(a2 + 8);
  int v14 = *(_DWORD *)(a2 + 16);
  if (v14 <= 0)
  {
    uint64_t v18 = mDNSLogCategory_State;
    uint64_t v16 = 4294901756LL;
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT)) {
      return v16;
    }
    GetRRDisplayString_rdb( (unsigned __int8 *)(a2 + 8),  (unsigned __int16 *)(*(void *)(a2 + 48) + 4LL),  (_BYTE *)(a1 + 46976));
    *(_DWORD *)buf = 67109635;
    *(_DWORD *)&uint8_t buf[4] = v14;
    *(_WORD *)&buf[8] = 2160;
    *(void *)&buf[10] = 1752392040LL;
    *(_WORD *)&buf[18] = 2085;
    *(void *)&buf[20] = a1 + 46976;
    int v17 = "mDNS_Register_internal: TTL %X should be 1 - 0x7FFFFFFF %{sensitive, mask.hash}s";
    int v19 = (os_log_s *)v18;
    uint32_t v20 = 28;
    goto LABEL_26;
  }

  if (!*v13)
  {
    uint64_t v15 = mDNSLogCategory_State;
    uint64_t v16 = 4294901756LL;
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT)) {
      return v16;
    }
    GetRRDisplayString_rdb( (unsigned __int8 *)(a2 + 8),  (unsigned __int16 *)(*(void *)(a2 + 48) + 4LL),  (_BYTE *)(a1 + 46976));
    *(_DWORD *)buf = 141558275;
    *(void *)&uint8_t buf[4] = 1752392040LL;
    *(_WORD *)&buf[12] = 2085;
    *(void *)&buf[14] = a1 + 46976;
    int v17 = "mDNS_Register_internal: RecordType must be non-zero %{sensitive, mask.hash}s";
    goto LABEL_24;
  }

  if (*(_DWORD *)(a1 + 76))
  {
    uint64_t v15 = mDNSLogCategory_State;
    uint64_t v16 = 4294901733LL;
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT)) {
      return v16;
    }
    GetRRDisplayString_rdb( (unsigned __int8 *)(a2 + 8),  (unsigned __int16 *)(*(void *)(a2 + 48) + 4LL),  (_BYTE *)(a1 + 46976));
    *(_DWORD *)buf = 141558275;
    *(void *)&uint8_t buf[4] = 1752392040LL;
    *(_WORD *)&buf[12] = 2085;
    *(void *)&buf[14] = a1 + 46976;
    int v17 = "mDNS_Register_internal: Shutting down, can't register %{sensitive, mask.hash}s";
LABEL_24:
    int v19 = (os_log_s *)v15;
LABEL_25:
    uint32_t v20 = 22;
    goto LABEL_26;
  }

  uint64_t v21 = (uint64_t *)(a1 + 12624);
  if (*(_BYTE *)(a1 + 14))
  {
    uint64_t v22 = *(void *)(a2 + 32);
    if (!v22)
    {
      if (*(_BYTE *)(a2 + 122))
      {
        *(void *)(a2 + 32) = -2LL;
        *(_DWORD *)(a2 + 172) = 4;
LABEL_35:
        BOOL v23 = (os_log_s *)mDNSLogCategory_State;
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT))
        {
          GetRRDisplayString_rdb( (unsigned __int8 *)(a2 + 8),  (unsigned __int16 *)(*(void *)(a2 + 48) + 4LL),  (_BYTE *)(a1 + 46976));
          *(_DWORD *)buf = 141558275;
          *(void *)&uint8_t buf[4] = 1752392040LL;
          *(_WORD *)&buf[12] = 2085;
          *(void *)&buf[14] = a1 + 46976;
          _os_log_impl( (void *)&_mh_execute_header,  v23,  OS_LOG_TYPE_DEFAULT,  "mDNS_Register_internal: Diverting record to local-only %{sensitive, mask.hash}s",  buf,  0x16u);
        }

        goto LABEL_37;
      }

      if (!IsLocalDomain(*(_BYTE **)(a2 + 40))) {
        goto LABEL_37;
      }
      uint64_t v22 = *(void *)(a2 + 32);
    }

    switch(v22)
    {
      case -3LL:
        goto LABEL_32;
      case -2LL:
        goto LABEL_37;
      case 0LL:
LABEL_32:
        *(void *)(a2 + 32) = -2LL;
        *(_DWORD *)(a2 + 172) = 4;
        goto LABEL_35;
    }

    uint64_t v48 = a1 + 12664;
    while (1)
    {
      uint64_t v48 = *(void *)v48;
      if (!v48) {
        break;
      }
      if (*(void *)(v48 + 6256) == v22)
      {
        if (*(_BYTE *)(v48 + 6374)) {
          break;
        }
        goto LABEL_32;
      }
    }
  }

LABEL_37:
  if ((*(_DWORD *)(a2 + 172) & 0xFFFFFFFE) == 4)
  {
    uint64_t v24 = AuthGroupForName(a1 + 6272, *(_DWORD *)(a2 + 24), *(_BYTE **)(a2 + 40));
    int v25 = (uint64_t *)(a1 + 12624);
    if (v24)
    {
      int v26 = v24 + 2;
      while (1)
      {
        int v26 = (void *)*v26;
        if (!v26) {
          break;
        }
        if (v26 == (void *)a2)
        {
          unsigned __int16 v27 = (os_log_s *)mDNSLogCategory_State;
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v28 = *(void *)(a2 + 40);
            if (v28)
            {
              uint64_t v29 = *(_BYTE **)(a2 + 40);
              if (v28 == -256)
              {
LABEL_46:
                while (v29)
                {
                  uint64_t v30 = *v29;
                  if (!*v29)
                  {
                    int v63 = (unsigned __int16)((_WORD)v29 - v28 + 1);
                    goto LABEL_144;
                  }

                  v29 += v30 + 1;
                  if (v28 != -256) {
                    goto LABEL_45;
                  }
                }
              }

              else
              {
LABEL_45:
              }

              int v63 = 257;
            }

            else
            {
              int v63 = 0;
            }

  if (v4)
  {
    SameDomainNameBytes(v4, v9);
    if (!SameDomainNameBytes(v4, v9))
    {
      uint64_t v18 = v9;
      if (v9 == (char *)-256LL)
      {
LABEL_41:
        while (v18)
        {
          int v19 = *v18;
          if (!*v18)
          {
            uint32_t v20 = (_WORD)v18 - (_WORD)v9 + 1;
            if (v20 > 0x100u) {
              break;
            }
            memcpy(v4, v9, v20);
            goto LABEL_50;
          }

          v18 += v19 + 1;
        }
      }

      else
      {
LABEL_40:
        if (v18 < v9 + 256) {
          goto LABEL_41;
        }
      }

      *int8x8_t v4 = 0;
LABEL_50:
      SetNewRData(a2 + 8, 0LL, 0LL, v13, v14, v15, v16, v17);
      if (*(_BYTE *)(a2 + 8) == 2) {
        uint64_t v21 = 3;
      }
      else {
        uint64_t v21 = 0;
      }
      *(_BYTE *)(a2 + 190) = v21;
      *(_WORD *)(a2 + 191) = 4;
      *(_BYTE *)(a2 + 189) = 0;
      InitializeLastAPTime((_DWORD *)a1, a2);
    }
  }

        uint64_t v24 = *(unsigned __int8 **)(a2 + 2448);
        int v25 = mDNS_DomainNameFNV1aHash(v24);
        int v26 = (os_log_s *)mDNSLogCategory_mDNS;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
        {
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
          {
            if (v24)
            {
              uint64_t v30 = v24;
LABEL_53:
              int v31 = 257;
              if (v30 < v24 + 256 && v30)
              {
                while (1)
                {
                  BOOL v32 = *v30;
                  if (v32 > 0x3F)
                  {
LABEL_64:
                    int v31 = 257;
                    goto LABEL_68;
                  }

                  if (!*v30) {
                    break;
                  }
                  v30 += v32 + 1;
LABEL_56:
                  if (!v30) {
                    goto LABEL_64;
                  }
                }

                int v31 = (_WORD)v30 - (_WORD)v24 + 1;
              }

    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, v12, (uint8_t *)&v25, 2u);
    return 0LL;
  }

  if ((a2 & 0x100000) != 0)
  {
    int v14 = (os_log_s *)mDNSLogCategory_D2D;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_D2D == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D, OS_LOG_TYPE_DEFAULT))
      {
LABEL_41:
        *a3 = 0;
        return 4LL;
      }

      LOWORD(v25) = 0;
    }

    else
    {
      int v14 = (os_log_s *)mDNSLogCategory_D2D_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D_redacted, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_41;
      }
      LOWORD(v25) = 0;
    }

    _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_DEFAULT,  "xD2DMapToTransportType: call AWDL and NAN plugins since kDNSServiceFlagsIncludeAWDL is set",  (uint8_t *)&v25,  2u);
    goto LABEL_41;
  }

  if (a1 != -3)
  {
    if (AWDLInterfaceID && AWDLInterfaceID == a1)
    {
      BOOL v6 = (os_log_s *)mDNSLogCategory_D2D;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_D2D == mDNSLogCategory_State)
      {
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_D2D, OS_LOG_TYPE_DEFAULT))
        {
          int v25 = 134217984;
          int v26 = a1;
          goto LABEL_62;
        }
      }

      else
      {
        BOOL v6 = (os_log_s *)mDNSLogCategory_D2D_redacted;
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_D2D_redacted, OS_LOG_TYPE_DEFAULT))
        {
          int v25 = 134217984;
          int v26 = a1;
LABEL_62:
          _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "xD2DMapToTransportType: returning D2DAWDLTransport for interface index %p",  (uint8_t *)&v25,  0xCu);
        }
      }

      return 2LL;
    }

    uint64_t v21 = gSensitiveLoggingEnabled;
    uint64_t v22 = (os_log_s *)mDNSLogCategory_D2D;
    if (mDNSLogCategory_D2D == mDNSLogCategory_State) {
      uint64_t v21 = 0;
    }
    if (WiFiAwareInterfaceID && WiFiAwareInterfaceID == a1)
    {
      if ((v21 & 1) != 0)
      {
        uint64_t v22 = (os_log_s *)mDNSLogCategory_D2D_redacted;
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_D2D_redacted, OS_LOG_TYPE_DEFAULT))
        {
          int v25 = 134217984;
          int v26 = a1;
LABEL_69:
          _os_log_impl( (void *)&_mh_execute_header,  v22,  OS_LOG_TYPE_DEFAULT,  "xD2DMapToTransportType: returning D2DWiFiAwareTransport for interface index %p",  (uint8_t *)&v25,  0xCu);
        }
      }

      else if (os_log_type_enabled((os_log_t)mDNSLogCategory_D2D, OS_LOG_TYPE_DEFAULT))
      {
        int v25 = 134217984;
        int v26 = a1;
        goto LABEL_69;
      }

      return 3LL;
    }

    if ((v21 & 1) != 0)
    {
      uint64_t v22 = (os_log_s *)mDNSLogCategory_D2D_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_D2D_redacted, OS_LOG_TYPE_DEFAULT))
      {
        int v25 = 134217984;
        int v26 = a1;
LABEL_73:
        _os_log_impl( (void *)&_mh_execute_header,  v22,  OS_LOG_TYPE_DEFAULT,  "xD2DMapToTransportType: no matching plugins for interface index %p",  (uint8_t *)&v25,  0xCu);
      }
    }

    else if (os_log_type_enabled((os_log_t)mDNSLogCategory_D2D, OS_LOG_TYPE_DEFAULT))
    {
      int v25 = 134217984;
      int v26 = a1;
      goto LABEL_73;
    }

    return 1LL;
  }

  uint64_t v8 = (os_log_s *)mDNSLogCategory_D2D;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_D2D == mDNSLogCategory_State)
  {
    uint32_t v20 = os_log_type_enabled((os_log_t)mDNSLogCategory_D2D, OS_LOG_TYPE_DEFAULT);
    uint64_t result = 0LL;
    if (!v20) {
      return result;
    }
    LOWORD(v25) = 0;
    int v12 = "xD2DMapToTransportType: returning D2DBluetoothTransport for interface index mDNSInterface_P2P";
    goto LABEL_37;
  }

  uint64_t v8 = (os_log_s *)mDNSLogCategory_D2D_redacted;
  BOOL v23 = os_log_type_enabled((os_log_t)mDNSLogCategory_D2D_redacted, OS_LOG_TYPE_DEFAULT);
  uint64_t v24 = v23;
  uint64_t result = 0LL;
  if (v24)
  {
    LOWORD(v25) = 0;
    int v12 = "xD2DMapToTransportType: returning D2DBluetoothTransport for interface index mDNSInterface_P2P";
    goto LABEL_37;
  }

  return result;
}

    CacheEntity = GetCacheEntity(a1, 0LL, 0LL, a4, a5, a6, a7, a8);
    if (!CacheEntity)
    {
      LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "GetCacheGroup: Failed to allocate memory for %##s",  v48,  v49,  v50,  v51,  v52,  *(void *)(v13 + 28));
      goto LABEL_42;
    }

    uint64_t v10 = (uint64_t *)CacheEntity;
    int v25 = a1 + 8LL * a2;
    *(void *)CacheEntity = *(void *)(v25 + 280);
    *(_DWORD *)(CacheEntity + 8) = *(_DWORD *)(v13 + 12);
    *(void *)(CacheEntity + 16) = 0LL;
    *(void *)(CacheEntity + 24) = CacheEntity + 16;
    if (v43 <= 0xB8u)
    {
      uint64_t v53 = (_BYTE *)(CacheEntity + 40);
    }

    else
    {
      uint64_t v53 = malloc(v43);
      if (!v53) {
        goto LABEL_150;
      }
    }

    uint64_t v69 = (uint64_t **)(v25 + 280);
    v10[4] = (uint64_t)v53;
    int v70 = *(_BYTE **)(v13 + 28);
    uint64_t v71 = v70;
    if (v70 == (_BYTE *)-256LL)
    {
LABEL_54:
      while (v71)
      {
        int v72 = *v71;
        if (!*v71)
        {
          int v116 = (_WORD)v71 - (_WORD)v70 + 1;
          if (v116 > 0x100u) {
            break;
          }
          memcpy(v53, v70, v116);
          goto LABEL_132;
        }

        v71 += v72 + 1;
        if (v70 != (_BYTE *)-256LL) {
          goto LABEL_53;
        }
      }
    }

    else
    {
LABEL_53:
      if (v71 < v70 + 256) {
        goto LABEL_54;
      }
    }

    *uint64_t v53 = 0;
LABEL_132:
    if (CacheGroupForName(a1, *(_DWORD *)(v13 + 12), *(_BYTE **)(v13 + 28))) {
      LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "GetCacheGroup: Already have CacheGroup for %##s",  v117,  v118,  v119,  v120,  v121,  *(void *)(v13 + 28));
    }
    *uint64_t v69 = v10;
    if (CacheGroupForName(a1, *(_DWORD *)(v13 + 12), *(_BYTE **)(v13 + 28)) != v10) {
      LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "GetCacheGroup: Not finding CacheGroup for %##s",  a4,  a5,  a6,  a7,  a8,  *(void *)(v13 + 28));
    }
  }

  int v19 = GetCacheEntity(a1, v10, a3, a4, a5, a6, a7, a8);
  if (!v19)
  {
LABEL_42:
    LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "No cache space: Delivering non-cached result for %##s",  v20,  v21,  v22,  v23,  v24,  *(void *)(v13 + 28));
    uint64_t v59 = *(void *)(a1 + 216);
    if (v59)
    {
      uint64_t v60 = (os_log_s *)mDNSLogCategory_Default;
      int v61 = v59 + 356;
      DNSTypeName(*(unsigned __int16 *)(v59 + 322));
      LogMsgWithLevel( v60,  OS_LOG_TYPE_DEFAULT,  "NoCacheAnswer ERROR m->CurrentQuestion already set: %##s (%s)",  v62,  v63,  v64,  v65,  v66,  v61);
    }

    int v67 = *(void *)(a1 + 200);
    *(void *)(a1 + 216) = v67;
    if (v67)
    {
      do
      {
        if (RecordAnswersQuestion(a1 + 37864, 0, v67, v54, v55, v56, v57, v58)) {
          AnswerCurrentQuestionWithResourceRecord(a1, a1 + 37856, 2LL);
        }
        uint64_t v68 = *(void *)(a1 + 216);
        if (v68 == v67)
        {
          uint64_t v68 = *(void *)(v67 + 8);
          *(void *)(a1 + 216) = v68;
        }

        int v67 = v68;
      }

      while (v68);
    }

    int v25 = 0LL;
    *(void *)(a1 + 216) = 0LL;
    return v25;
  }

  int v25 = v19;
  int v128 = v9;
  int v26 = (void *)(v19 + 152);
  *(void *)(v19 + 48) = v19 + 152;
  unsigned __int16 v27 = (void *)(v19 + 152);
  if (v15 < 0x45) {
    goto LABEL_19;
  }
  uint64_t v28 = calloc(1uLL, v15 + 4LL);
  if (!v28)
  {
LABEL_150:
    __break(1u);
    goto LABEL_151;
  }

  unsigned __int16 v27 = v28;
  *(void *)(v25 + 48) = v28;
  *(_WORD *)(v25 + 20) = v15;
  *uint64_t v28 = v15;
LABEL_19:
  uint64_t v29 = *(_OWORD *)(a1 + 37872);
  *(_OWORD *)int v25 = *(_OWORD *)(a1 + 37856);
  *(_OWORD *)(v25 + 16) = v29;
  uint64_t v30 = *(_OWORD *)(a1 + 37888);
  int v31 = *(_OWORD *)(a1 + 37904);
  BOOL v32 = *(_OWORD *)(a1 + 37936);
  *(_OWORD *)(v25 + 64) = *(_OWORD *)(a1 + 37920);
  *(_OWORD *)(v25 + 80) = v32;
  *(_OWORD *)(v25 + 32) = v30;
  *(_OWORD *)(v25 + 48) = v31;
  uint64_t v33 = *(_OWORD *)(a1 + 37952);
  int v34 = *(_OWORD *)(a1 + 37968);
  uint64_t v35 = *(_OWORD *)(a1 + 38000);
  *(_OWORD *)(v25 + 128) = *(_OWORD *)(a1 + 37984);
  *(_OWORD *)(v25 + 144) = v35;
  *(_OWORD *)(v25 + 96) = v33;
  *(_OWORD *)(v25 + 112) = v34;
  uint64_t v36 = *(_OWORD *)(a1 + 38016);
  uint64_t v37 = *(_OWORD *)(a1 + 38032);
  BOOL v38 = *(_OWORD *)(a1 + 38064);
  *(_OWORD *)(v25 + 192) = *(_OWORD *)(a1 + 38048);
  *(_OWORD *)(v25 + 208) = v38;
  *(_OWORD *)(v25 + 160) = v36;
  *(_OWORD *)(v25 + 176) = v37;
  uint64_t v39 = *(void **)(v25 + 56);
  if (v39) {
    os_retain(v39);
  }
  *(void *)(v25 + 40) = v10[4];
  *(void *)(v25 + 48) = v27;
  *(_BYTE *)(v25 + 10) = 0;
  if ((v16 & 2) != 0)
  {
    char v45 = *(unsigned __int8 *)(v25 + 8) != 240;
    uint64_t v46 = _dnssec_obj_resource_record_member_new();
    v46[8] = 0;
    *((void *)v46 + 2) = v25;
    *((_BYTE *)v46 + 40) = v45;
LABEL_61:
    ++*v46;
    ref_count_obj_release(v46);
    *(void *)(v25 + 64) = v46;
    unsigned __int16 v27 = *(void **)(v25 + 48);
    uint64_t v40 = v134;
    goto LABEL_62;
  }

  uint64_t v40 = v134;
  if (v132)
  {
    if ((v131 & v130 & 1) != 0) {
      return 0LL;
    }
    if (!v129)
    {
LABEL_151:
      *(void *)(v25 + 64) = 0LL;
      return 0LL;
    }

    uint64_t v46 = _dnssec_obj_resource_record_member_new();
    v46[8] = 1;
    *((void *)v46 + 2) = v25;
    v46[10] = v129;
    *((_BYTE *)v46 + 44) = (v16 & 0x10) != 0;
    goto LABEL_61;
  }

  int v12 = xmmword_10015C4C8;
  if (!(void)xmmword_10015C4C8) {
    goto LABEL_47;
  }
  BOOL v13 = (void **)&xmmword_10015C4C8;
  while (1)
  {
    int v14 = SameDomainNameBytes(a1, (_BYTE *)(v12 + 208));
    uint64_t v15 = *v13;
    if (v14) {
      break;
    }
    int v12 = *(void *)v15;
    BOOL v13 = (void **)*v13;
    if (!*(void *)v15) {
      goto LABEL_47;
    }
  }

  if (!v15)
  {
LABEL_47:
    uint64_t v18 = (os_log_s *)mDNSLogCategory_uDNS;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_uDNS == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_uDNS, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_101;
      }
      if (a1)
      {
        uint32_t v20 = a1;
        if (a1 == (_BYTE *)-256LL) {
          goto LABEL_58;
        }
LABEL_55:
        uint64_t v21 = 257;
        if (v20 < a1 + 256 && v20)
        {
          while (1)
          {
            uint64_t v22 = *v20;
            if (v22 > 0x3F)
            {
LABEL_95:
              uint64_t v21 = 257;
              goto LABEL_100;
            }

            if (!*v20) {
              break;
            }
            v20 += v22 + 1;
            if (a1 != (_BYTE *)-256LL) {
              goto LABEL_55;
            }
LABEL_58:
            if (!v20) {
              goto LABEL_95;
            }
          }

          uint64_t v21 = (unsigned __int16)((_WORD)v20 - (_WORD)a1 + 1);
        }
      }

      else
      {
        uint64_t v21 = 0;
      }
    }

    else
    {
      uint64_t v18 = (os_log_s *)mDNSLogCategory_uDNS_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_uDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_101;
      }
      if (a1)
      {
        uint64_t v24 = a1;
        if (a1 == (_BYTE *)-256LL) {
          goto LABEL_69;
        }
LABEL_66:
        uint64_t v21 = 257;
        if (v24 < a1 + 256 && v24)
        {
          while (1)
          {
            int v25 = *v24;
            if (v25 > 0x3F)
            {
LABEL_96:
              uint64_t v21 = 257;
              goto LABEL_100;
            }

            if (!*v24) {
              break;
            }
            v24 += v25 + 1;
            if (a1 != (_BYTE *)-256LL) {
              goto LABEL_66;
            }
LABEL_69:
            if (!v24) {
              goto LABEL_96;
            }
          }

          uint64_t v21 = (unsigned __int16)((_WORD)v24 - (_WORD)a1 + 1);
        }
      }

      else
      {
        uint64_t v21 = 0;
      }
    }

  int v31 = *(void *)(v2 + 136);
  if (!v31) {
    goto LABEL_39;
  }
  BOOL v32 = *(void *)(v31 + 32);
LABEL_40:
  __memcpy_chk(byte_10015D9A8, v32, v28, 27536LL);
  if ((*(_WORD *)(v24 + 276) & 0x2000) != 0) {
    uint64_t v33 = *(unsigned int *)(v24 + 256);
  }
  else {
    uint64_t v33 = 0LL;
  }
  mDNSCoreReceiveForQuerier((unint64_t)&byte_10015D9A8[v28], v2, (void *)v24, v33);
LABEL_44:
  Mutable = (__CFSet *)_Querier_GetOrphanedQuerierSet_sOrphanedQuerierSet;
  if (_Querier_GetOrphanedQuerierSet_sOrphanedQuerierSet
    || (Mutable = CFSetCreateMutable(kCFAllocatorDefault, 0LL, (const CFSetCallBacks *)&gMDNSObjectSetCallbacks),
        (_Querier_GetOrphanedQuerierSet_sOrphanedQuerierSet = (uint64_t)Mutable) != 0))
  {
    CFSetRemoveValue(Mutable, (const void *)v2);
  }

  uint64_t v52 = 0;
  DNSQuestion = Querier_GetDNSQuestion(v2, &v52);
  if (DNSQuestion)
  {
    int v43 = DNSQuestion;
    char v45 = (void **)(DNSQuestion + 96);
    int v44 = *(void **)(DNSQuestion + 96);
    if (v44)
    {
      os_release(v44);
      unsigned int *v45 = 0LL;
    }

    uint64_t v46 = *(unsigned __int8 *)(v43 + 628);
    *(_BYTE *)(v43 + 628) = 0;
    if (!(*(unsigned __int8 *)(v43 + 334) | v52))
    {
      switch(v25)
      {
        case 0:
          if (v46) {
            goto LABEL_53;
          }
          goto LABEL_69;
        case 1:
LABEL_53:
          mDNS_Lock_((unsigned int *)mDNSStorage, (uint64_t)"_Querier_HandleQuerierResponse", 969);
          Querier_HandleUnicastQuestion(v43);
          unsigned int v47 = 971;
          goto LABEL_68;
        case 4:
          mDNS_Lock_((unsigned int *)mDNSStorage, (uint64_t)"_Querier_HandleQuerierResponse", 916);
          *(_DWORD *)(v43 + 208) = dword_100158BF8;
          *(_DWORD *)(v43 + 212) = 5000;
          SetNextQueryTime((uint64_t)mDNSStorage, v43);
          unsigned int v47 = 920;
          goto LABEL_68;
        case 5:
          if ((*(_WORD *)(v24 + 276) & 0x800) == 0)
          {
            DNSServiceManager = Querier_GetDNSServiceManager();
            if (DNSServiceManager)
            {
              int v49 = DNSServiceManager;
              if (_mdns_dns_service_queue_s_once != -1) {
                dispatch_once(&_mdns_dns_service_queue_s_once, &__block_literal_global_237);
              }
              *(void *)buf = _NSConcreteStackBlock;
              *(void *)uint64_t v54 = 0x40000000LL;
              *(void *)&v54[8] = __mdns_dns_service_manager_apply_pending_connection_problem_updates_block_invoke;
              *(void *)&v54[16] = &__block_descriptor_tmp_40;
              uint64_t v55 = v49;
              dispatch_sync((dispatch_queue_t)_mdns_dns_service_queue_s_queue, buf);
            }
          }

          mDNS_Lock_((unsigned int *)mDNSStorage, (uint64_t)"_Querier_HandleQuerierResponse", 937);
          mdns_client_replace(v45, (void *)v2);
          break;
        default:
          goto LABEL_69;
      }

      while (1)
      {
        mDNS_StopQuery_internal((uint64_t)mDNSStorage, v43);
        *(_BYTE *)(v43 + 629) = 1;
        mDNS_StartQuery_internal((uint64_t)mDNSStorage, v43);
        int v50 = Querier_GetDNSQuestion(v2, &v52);
        int v43 = v50;
        if (v50)
        {
          if (v52) {
            break;
          }
        }

        if (!v50) {
          goto LABEL_67;
        }
      }

      uint64_t v51 = *(void **)(v50 + 96);
      if (v51)
      {
        os_release(v51);
        *(void *)(v43 + 96) = 0LL;
      }

LABEL_144:
            uint64_t v69 = DNSTypeName(*(unsigned __int16 *)(a2 + 12));
            *(_DWORD *)buf = 134219011;
            *(void *)&uint8_t buf[4] = a2;
            *(_WORD *)&buf[12] = 2160;
            *(void *)&buf[14] = 1752392040LL;
            *(_WORD *)&buf[22] = 1040;
            *(_DWORD *)&buf[24] = v63;
            *(_WORD *)&buf[28] = 2101;
            *(void *)&buf[30] = v28;
            *(_WORD *)&buf[38] = 2082;
            *(void *)&buf[40] = v69;
            uint64_t v62 = "mDNS_Register_internal: ERROR!! Tried to register LocalOnly AuthRecord %p %{sensitive, mask.hash, mdns"
                  "responder:domain_name}.*P (%{public}s) that's already in the list";
            goto LABEL_145;
          }

          return 4294901749LL;
        }
      }

      int v25 = (uint64_t *)(a1 + 12624);
    }
  }

  else
  {
    int v31 = (uint64_t *)(a1 + 12624);
    do
    {
      int v25 = v31;
      int v31 = (uint64_t *)*v31;
      if (v31) {
        BOOL v32 = v31 == (uint64_t *)a2;
      }
      else {
        BOOL v32 = 1;
      }
    }

    while (!v32);
    if (v31)
    {
      unsigned __int16 v27 = (os_log_s *)mDNSLogCategory_State;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT)) {
        return 4294901749LL;
      }
      uint64_t v33 = *(void *)(a2 + 40);
      if (v33)
      {
        int v34 = *(_BYTE **)(a2 + 40);
        if (v33 == -256)
        {
          while (1)
          {
LABEL_62:
            if (!v34) {
              goto LABEL_115;
            }
            uint64_t v35 = *v34;
            if (!*v34) {
              break;
            }
            v34 += v35 + 1;
            if (v33 != -256) {
              goto LABEL_61;
            }
          }

          int v50 = (unsigned __int16)((_WORD)v34 - v33 + 1);
        }

        else
        {
LABEL_61:
LABEL_115:
          int v50 = 257;
        }
      }

      else
      {
        int v50 = 0;
      }

      uint64_t v64 = DNSTypeName(*(unsigned __int16 *)(a2 + 12));
      *(_DWORD *)buf = 134219011;
      *(void *)&uint8_t buf[4] = a2;
      *(_WORD *)&buf[12] = 2160;
      *(void *)&buf[14] = 1752392040LL;
      *(_WORD *)&buf[22] = 1040;
      *(_DWORD *)&buf[24] = v50;
      *(_WORD *)&buf[28] = 2101;
      *(void *)&buf[30] = v33;
      *(_WORD *)&buf[38] = 2082;
      *(void *)&buf[40] = v64;
      uint64_t v62 = "mDNS_Register_internal: ERROR!! Tried to register AuthRecord %p %{sensitive, mask.hash, mdnsresponder:domain"
            "_name}.*P (%{public}s) that's already in the list";
      goto LABEL_145;
    }
  }

  uint64_t v36 = (uint64_t *)(a1 + 12632);
  do
  {
    uint64_t v37 = v36;
    uint64_t v36 = (uint64_t *)*v36;
    if (v36) {
      BOOL v38 = v36 == (uint64_t *)a2;
    }
    else {
      BOOL v38 = 1;
    }
  }

  while (!v38);
  if (v36)
  {
    unsigned __int16 v27 = (os_log_s *)mDNSLogCategory_State;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v39 = *(void *)(a2 + 40);
      if (v39)
      {
        uint64_t v40 = *(_BYTE **)(a2 + 40);
        if (v39 == -256)
        {
LABEL_79:
          while (v40)
          {
            uint64_t v41 = *v40;
            if (!*v40)
            {
              int v49 = (unsigned __int16)((_WORD)v40 - v39 + 1);
              goto LABEL_129;
            }

            v40 += v41 + 1;
            if (v39 != -256) {
              goto LABEL_78;
            }
          }
        }

        else
        {
LABEL_78:
        }

        int v49 = 257;
      }

      else
      {
        int v49 = 0;
      }

    mDNS_Unlock_(v12, (uint64_t)"tcpCallback", 1603);
    DisposeTCPConn(a2);
    return;
  }

    dispatch_once(&_mdns_crypto_log_s_once, &__block_literal_global_115);
    goto LABEL_16;
  }

  uint64_t v71 = bswap32(*bytes_ptr) >> 16;
  if (length - 2 == v71)
  {
    ++bytes_ptr;
    while (!mdns_odoh_config_is_valid_inner(bytes_ptr, v71))
    {
      if (v71 >= 4)
      {
        int v72 = bswap32(bytes_ptr[1]) >> 16;
        bytes_ptr = (unsigned __int16 *)((char *)bytes_ptr + v72);
        int v73 = v71 > v72;
        v71 -= v72;
        if (v73) {
          continue;
        }
      }

      goto LABEL_80;
    }

    if (!bytes_ptr) {
      goto LABEL_80;
    }
  }

  else if (!mdns_odoh_config_is_valid_inner(bytes_ptr, length))
  {
    goto LABEL_80;
  }

  uint64_t v79 = cchpke_params_x25519_AESGCM128_HKDF_SHA256();
  p_applier = cchpke_params_sizeof_kdf_hash();
  buffera = (void *)ccsha256_di(p_applier);
  if (!p_applier) {
    goto LABEL_143;
  }
  length = bytes_ptr[5];
  int v80 = calloc(1uLL, p_applier);
  if (!v80) {
    goto LABEL_143;
  }
  uint64_t v81 = v80;
  __int16 v82 = cchkdf_extract(buffera, 0LL, 0LL, (bswap32(length) >> 16) + 8LL, bytes_ptr + 2, v80);
  if (v82)
  {
    uint64_t v83 = v82;
    free(v81);
    if (_mdns_crypto_log_s_once != -1) {
      dispatch_once(&_mdns_crypto_log_s_once, &__block_literal_global_115);
    }
    __int16 v84 = _mdns_crypto_log_s_log;
    if (!os_log_type_enabled((os_log_t)_mdns_crypto_log_s_log, OS_LOG_TYPE_ERROR)) {
      goto LABEL_83;
    }
    *(_DWORD *)buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v83;
    uint64_t v69 = "Extract error: %d";
    uint64_t v85 = (os_log_s *)v84;
    uint64_t v86 = 8;
    goto LABEL_111;
  }

  uint64_t v111 = dispatch_data_get_size(a2);
  size_t v110 = arc4random_uniform(0x10u);
  __sizea = v111 + v110 + 4;
  length = cchpke_params_sizeof_aead_tag(v79);
  uint64_t v115 = v79;
  uint64_t v113 = length;
  contexta = (char *)cchpke_params_sizeof_kem_enc(v79);
  uint64_t v87 = &contexta[length + __sizea];
  length = 1LL;
  size = (uint64_t)&v87[p_applier + 5];
  uint64_t v88 = (char *)calloc(1uLL, size);
  if (!v88) {
    goto LABEL_143;
  }
  *uint64_t v88 = 1;
  *(_WORD *)(v88 + 1) = bswap32(p_applier) >> 16;
  uint64_t v89 = v88;
  uint64_t v90 = cchkdf_expand(buffera, p_applier, v81, 11LL, "odoh key id", p_applier, v88 + 3);
  int v91 = v81;
  unint64_t v92 = v90;
  free(v91);
  if (v92)
  {
    if (_mdns_crypto_log_s_once != -1) {
      dispatch_once(&_mdns_crypto_log_s_once, &__block_literal_global_115);
    }
    int v93 = (os_log_s *)_mdns_crypto_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_crypto_log_s_log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 67109120;
      *(_DWORD *)&uint8_t buf[4] = v92;
      _os_log_error_impl((void *)&_mh_execute_header, v93, OS_LOG_TYPE_ERROR, "Expand error: %d", buf, 8u);
    }

    __int16 v94 = v89;
    goto LABEL_127;
  }

  p_applier += 3LL;
  bufferb = v89;
  length = (size_t)v89 + p_applier;
  *(_WORD *)length = bswap32(v87) >> 16;
  int v95 = calloc(1uLL, 0x60uLL);
  if (!v95) {
    goto LABEL_143;
  }
  int v96 = v95;
  LODWORD(v141) = 0;
  BOOL v97 = ccrng(&v141);
  length += 2LL;
  BOOL v98 = cchpke_initiator_setup( v96,  v115,  v97,  bswap32(bytes_ptr[5]) >> 16,  bytes_ptr + 6,  10LL,  "odoh query",  contexta,  length);
  if (v98)
  {
    BOOL v99 = v98;
    if (_mdns_crypto_log_s_once != -1) {
      dispatch_once(&_mdns_crypto_log_s_once, &__block_literal_global_115);
    }
    unint64_t v100 = (os_log_s *)_mdns_crypto_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_crypto_log_s_log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 67109120;
      *(_DWORD *)&uint8_t buf[4] = v99;
      _os_log_error_impl((void *)&_mh_execute_header, v100, OS_LOG_TYPE_ERROR, "Setup error: %d", buf, 8u);
    }

LABEL_129:
      int v61 = DNSTypeName(*(unsigned __int16 *)(a2 + 12));
      *(_DWORD *)buf = 134219011;
      *(void *)&uint8_t buf[4] = a2;
      *(_WORD *)&buf[12] = 2160;
      *(void *)&buf[14] = 1752392040LL;
      *(_WORD *)&buf[22] = 1040;
      *(_DWORD *)&buf[24] = v49;
      *(_WORD *)&buf[28] = 2101;
      *(void *)&buf[30] = v39;
      *(_WORD *)&buf[38] = 2082;
      *(void *)&buf[40] = v61;
      uint64_t v62 = "mDNS_Register_internal: ERROR!! Tried to register AuthRecord %p %{sensitive, mask.hash, mdnsresponder:domain"
            "_name}.*P (%{public}s) that's already in the Duplicate list";
LABEL_145:
      _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, v62, buf, 0x30u);
    }

    return 4294901749LL;
  }

  uint64_t v42 = *(void *)(a2 + 88);
  if (v42)
  {
    int v43 = *v13;
    if (v43 != 32)
    {
      if (v43 != 2)
      {
        uint64_t v16 = 4294901747LL;
        uint64_t v57 = mDNSLogCategory_State;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT)) {
          return v16;
        }
        uint64_t v58 = *(void *)(a2 + 40);
        if (v58)
        {
          uint64_t v59 = *(_BYTE **)(a2 + 40);
          if (v58 == -256)
          {
            while (1)
            {
LABEL_123:
              if (!v59) {
                goto LABEL_156;
              }
              uint64_t v60 = *v59;
              if (!*v59) {
                break;
              }
              v59 += v60 + 1;
              if (v58 != -256) {
                goto LABEL_122;
              }
            }

            int v72 = (unsigned __int16)((_WORD)v59 - v58 + 1);
          }

          else
          {
LABEL_122:
LABEL_156:
            int v72 = 257;
          }
        }

        else
        {
          int v72 = 0;
        }

        uint64_t v74 = DNSTypeName(*(unsigned __int16 *)(a2 + 12));
        *(_DWORD *)buf = 141558787;
        *(void *)&uint8_t buf[4] = 1752392040LL;
        *(_WORD *)&buf[12] = 1040;
        *(_DWORD *)&buf[14] = v72;
        *(_WORD *)&buf[18] = 2101;
        *(void *)&buf[20] = v58;
        *(_WORD *)&buf[28] = 2082;
        *(void *)&buf[30] = v74;
        int v17 = "mDNS_Register_internal: ERROR! %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%{public}s): rr->Dep"
              "endentOn && RecordType != kDNSRecordTypeUnique or kDNSRecordTypeKnownUnique";
        int v19 = (os_log_s *)v57;
        uint32_t v20 = 38;
        goto LABEL_26;
      }

      *BOOL v13 = 16;
    }

    if ((*(_BYTE *)(v42 + 8) & 0x32) != 0) {
      goto LABEL_89;
    }
    uint64_t v16 = 4294901747LL;
    uint64_t v65 = mDNSLogCategory_State;
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT)) {
      return v16;
    }
    uint64_t v66 = *(void *)(a2 + 40);
    if (v66)
    {
      int v67 = *(_BYTE **)(a2 + 40);
      if (v66 == -256)
      {
        while (1)
        {
LABEL_137:
          if (!v67) {
            goto LABEL_158;
          }
          uint64_t v68 = *v67;
          if (!*v67) {
            break;
          }
          v67 += v68 + 1;
          if (v66 != -256) {
            goto LABEL_136;
          }
        }

        int v73 = (unsigned __int16)((_WORD)v67 - v66 + 1);
      }

      else
      {
LABEL_136:
LABEL_158:
        int v73 = 257;
      }
    }

    else
    {
      int v73 = 0;
    }

    uint64_t v107 = DNSTypeName(*(unsigned __int16 *)(a2 + 12));
    int v108 = *(unsigned __int8 *)(*(void *)(a2 + 88) + 8LL);
    *(_DWORD *)buf = 141559043;
    *(void *)&uint8_t buf[4] = 1752392040LL;
    *(_WORD *)&buf[12] = 1040;
    *(_DWORD *)&buf[14] = v73;
    *(_WORD *)&buf[18] = 2101;
    *(void *)&buf[20] = v66;
    *(_WORD *)&buf[28] = 2082;
    *(void *)&buf[30] = v107;
    *(_WORD *)&buf[38] = 1024;
    *(_DWORD *)&buf[40] = v108;
    int v17 = "mDNS_Register_internal: ERROR! %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%{public}s): rr->Depende"
          "ntOn->RecordType bad type %X";
    int v19 = (os_log_s *)v65;
    uint32_t v20 = 44;
LABEL_26:
    _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, v17, buf, v20);
    return v16;
  }

                        unint64_t v76 = v71;
                        uint64_t v77 = DNSTypeName(v969);
                        uint64_t v78 = *(void *)(v66 + 32);
                        GetRRDisplayString_rdb( (unsigned __int8 *)(v66 + 8),  (unsigned __int16 *)(*(void *)(v66 + 48) + 4LL),  v879);
                        *(_DWORD *)v934 = 134220035;
                        *(void *)&v934[4] = v874;
                        *(_WORD *)&v934[12] = 2160;
                        *(void *)&v934[14] = 1752392040LL;
                        v935 = 1040;
                        v936 = v76;
                        v937 = 2101;
                        v938 = v970;
                        v939 = 2160;
                        v940 = 1752392040LL;
                        v941 = 2085;
                        v942 = v77;
                        v943 = 2048;
                        v944 = v78;
                        v945 = 2160;
                        v946 = 1752392040LL;
                        v947 = 2085;
                        v948 = v879;
                        _os_log_impl( (void *)&_mh_execute_header,  v68,  OS_LOG_TYPE_DEBUG,  "Making record answered by the current response as expired if it is not refreshed in the respon se - Q interface ID: %p, qname: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P, qtype: %{sensitive, mask.hash}s, RR interface ID: %p, RR description: %{sensitive, mask.hash}s.",  v934,  0x58u);
                        a2 = v900;
                        a3 = v870;
                        a8 = v901;
                      }
                    }

                    else
                    {
                      uint64_t v68 = (os_log_s *)mDNSLogCategory_Default_redacted;
                      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEBUG))
                      {
                        v874 = *(void *)((char *)&v962 + 7);
                        for (uint64_t j = v970; ; j += v75 + 1)
                        {
                          uint64_t v71 = 257;
                          if (j >= v972 || !j) {
                            break;
                          }
                          int v75 = *j;
                          if (v75 > 0x3F)
                          {
                            uint64_t v71 = 257;
                            goto LABEL_129;
                          }

                          if (!*j)
                          {
                            uint64_t v71 = (_WORD)j - (unsigned __int16)v970 + 1;
                            goto LABEL_129;
                          }
                        }

                        goto LABEL_129;
                      }
                    }

                    a1 = v878;
                    *(_DWORD *)(v66 + 80) = *(_DWORD *)(v878 + 64) + ~(1000 * *(_DWORD *)(v66 + 16));
                    *(_BYTE *)(v66 + 108) = 4;
                    goto LABEL_131;
                  }

LABEL_309:
          int v136 = *(unsigned __int16 *)(a2 + 12);
          *(_DWORD *)buf = 141559043;
          *(void *)&uint8_t buf[4] = 1752392040LL;
          *(_WORD *)&buf[12] = 1040;
          *(_DWORD *)&buf[14] = v116;
          *(_WORD *)&buf[18] = 2101;
          *(void *)&buf[20] = v87;
          *(_WORD *)&buf[28] = 1024;
          *(_DWORD *)&buf[30] = v91;
          *(_WORD *)&buf[34] = 1024;
          *(_DWORD *)&buf[36] = v136;
          _os_log_impl( (void *)&_mh_execute_header,  v114,  OS_LOG_TYPE_DEFAULT,  "mDNS_Register_internal: adding to active record list -- name: %{sensitive, mask.hash, mdnsresponder:domain_n ame}.*P (%x), type: %{mdns:rrtype}d, rdata: <none>",  buf,  0x28u);
        }

        goto LABEL_294;
      }

      uint64_t v101 = 0LL;
      uint64_t v102 = (char *)&unk_100164138;
      LODWORD(v100) = 512;
    }

    int v151 = 0;
    unsigned __int16 v150 = 0;
    uint64_t RDataBytesPointer = ResourceRecordGetRDataBytesPointer(a2 + 8, v102, v100, &v150, &v151, v88, v89, v90);
    if (v151)
    {
LABEL_292:
      if (v101) {
        free(v101);
      }
LABEL_294:
      if ((*(_DWORD *)(a2 + 172) & 0xFFFFFFFE) != 4)
      {
        if (!*(void *)(a1 + 12640)) {
          *(void *)(a1 + 12640) = a2;
        }
        *int v25 = a2;
        goto LABEL_323;
      }

      inserted = InsertAuthRecord(a1 + 6272, a2);
      if (inserted && !inserted[5])
      {
        *(_BYTE *)(a1 + 12656) = 1;
        inserted[5] = a2;
      }

      if (*v13 == 2) {
        *BOOL v13 = 16;
      }
      AcknowledgeRecord(a1, a2);
      return 0LL;
    }

    size_t v104 = v150;
    __src = (void *)RDataBytesPointer;
    if (v150 < 0x1FFu)
    {
      uint64_t v105 = 0LL;
      unsigned int v106 = 512;
      uint64_t v142 = word_100164338;
LABEL_239:
      os_log_t log = (os_log_s *)mDNSLogCategory_State;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v141 = v105;
        int v149 = v91;
        if (v87)
        {
          v118 = v87;
          int v119 = 257;
LABEL_242:
          if (v118 < v87 + 256 && v118)
          {
            while (1)
            {
              uint64_t v120 = *v118;
              if (v120 > 0x3F)
              {
LABEL_283:
                int v119 = 257;
                goto LABEL_286;
              }

              if (!*v118) {
                break;
              }
              v118 += v120 + 1;
LABEL_245:
              if (!v118) {
                goto LABEL_283;
              }
            }

            int v119 = (unsigned __int16)((_WORD)v118 - (_WORD)v87 + 1);
          }
        }

        else
        {
          int v119 = 0;
        }

            if (v115)
            {
              v161 = *(_BYTE *)(v159 + 8);
              if (!v300 && (*(_BYTE *)(v159 + 8) & 0x30) != 0 && !*(void *)(v159 + 200)) {
                *(void *)(v159 + 200) = -1LL;
              }
              if ((v161 & 0x32) != 0) {
                *(_WORD *)(v159 + 14) |= 0x8000u;
              }
              uint64_t v164 = UnsafeBufferPointer(*(uint64_t **)(v109 + 12624), v159, (uint64_t **)&v307);
              int v165 = v305;
              if (v164) {
                int v165 = v305 + 1;
              }
              if (*v306 || *(_WORD *)(a1 + 28912) || *v295) {
                uint64_t v166 = 1440LL;
              }
              else {
                uint64_t v166 = 8940LL;
              }
              int v167 = v303 + v166;
              int v19 = v165 == 0;
              uint64_t v168 = v302 + 14 * v165;
              char v169 = v301;
              if (v19) {
                char v169 = 1;
              }
              if (v169) {
                int v170 = 0;
              }
              else {
                int v170 = 11;
              }
              uint64_t v171 = PutResourceRecordTTLWithLimit( (unint64_t)v304,  v115,  v295,  v159 + 8,  *(unsigned int *)(v159 + 16),  v167 - (v168 + v170),  v162,  v163);
              uint64_t v115 = v171;
              if (v164)
              {
                if (v171)
                {
                  v172 = v171;
                  int v173 = *(void *)(v159 + 40);
                  v174 = *v306;
                  v175 = *v295;
                  uint8_t v176 = calloc(1uLL, 0x18uLL);
                  if (!v176) {
                    goto LABEL_549;
                  }
                  LOWORD(v305) = v305 + 1;
                  *((_WORD *)v164 + 4) = v174 + v175 - 1;
                  v176[1] = v164;
                  v176[2] = v173;
                  *uint8_t v176 = v307;
                  v307 = v176;
                  *(_WORD *)(v159 + 14) &= ~0x8000u;
                  uint64_t v109 = a1;
                  uint64_t v115 = v172;
LABEL_341:
                  *(void *)(v159 + 216) = 0LL;
                  *(_BYTE *)(v159 + 192) = 1;
                  *(_DWORD *)(v159 + 288) = *v296;
                  *(void *)(v159 + 296) = *(void *)(v110 + 6256);
                  uint64_t v160 = v115;
                }

                else
                {
                  *(_WORD *)(v159 + 14) &= ~0x8000u;
                }
              }

              else
              {
                *(_WORD *)(v159 + 14) &= ~0x8000u;
                if (v171) {
                  goto LABEL_341;
                }
              }
            }
          }

          else
          {
LABEL_339:
            *(void *)(v159 + 216) = 0LL;
          }
        }

        v159 = *(void *)v159;
        if (v159) {
          continue;
        }
        break;
      }

      int v178 = *(void *)(v109 + 12624);
      BOOL v179 = v115;
      uint64_t v115 = v160;
      if (v178)
      {
        while (2)
        {
          uint64_t v180 = *(void *)(v178 + 200);
          if (v180 == -1 || v180 == *(void *)(v110 + 6256))
          {
            bzero(v322, 0x498uLL);
            v186 = *(_DWORD *)(v178 + 16);
            if (v186) {
              char v187 = *(_DWORD *)(v178 + 16);
            }
            else {
              char v187 = 4500;
            }
            v322[8] = 2;
            if (v186 <= 0x20C49B) {
              v188 = v187;
            }
            else {
              v188 = 2147483;
            }
            strcpy((char *)&v322[12], "/");
            v323 = v188;
            v357[0] = 264;
            v327 = v356;
            v328 = v357;
            v336 = 0;
            v337 = 0;
            v329 = 0u;
            v330 = 0u;
            v331 = 0u;
            v332 = 0u;
            v333 = 0u;
            v334 = 0u;
            v335 = 0LL;
            v338 = v356;
            v352 = 0;
            v354 = 0LL;
            v355 = 0LL;
            v353 = 0LL;
            v356[0] = 0;
            v339 = 0u;
            v340 = 0u;
            v341 = 0u;
            v342 = 0u;
            v343 = 0u;
            v344 = 0u;
            v345 = 0u;
            v346 = 0u;
            v347 = 0u;
            v348 = 0u;
            v349 = 0u;
            v350 = 0u;
            memset(v351, 0, sizeof(v351));
            int v189 = *(_BYTE **)(v178 + 40);
            BOOL v190 = v189;
            *(_WORD *)&v322[14] = -32767;
            if (v189 == (_BYTE *)-256LL)
            {
LABEL_355:
              while (v190)
              {
                unsigned int v191 = *v190;
                if (!*v190)
                {
                  uint64_t v192 = (_WORD)v190 - (_WORD)v189 + 1;
                  if (v192 <= 0x100u) {
                    memcpy(v356, v189, v192);
                  }
                  break;
                }

                v190 += v191 + 1;
                if (v189 != (_BYTE *)-256LL) {
                  goto LABEL_354;
                }
              }
            }

            else
            {
LABEL_354:
              if (v190 < v189 + 256) {
                goto LABEL_355;
              }
            }

            size_t v193 = *(_BYTE **)(v178 + 40);
            __int128 v194 = v193;
            if (v193 != (_BYTE *)-256LL)
            {
LABEL_363:
              if (v194 < v193 + 256) {
                goto LABEL_364;
              }
LABEL_369:
              __int128 v196 = 291;
              *(_WORD *)v324 = 291;
              goto LABEL_370;
            }

            while (1)
            {
LABEL_364:
              if (!v194) {
                goto LABEL_369;
              }
              __int128 v195 = *v194;
              if (!*v194) {
                break;
              }
              v194 += v195 + 1;
              if (v193 != (_BYTE *)-256LL) {
                goto LABEL_363;
              }
            }

            __int128 v199 = (_WORD)v194 - (_WORD)v193;
            __int128 v196 = (_WORD)v194 - (_WORD)v193 + 35;
            *(_WORD *)v324 = v196;
            if (v196 > 0x108u)
            {
LABEL_370:
              LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "SendResponses: not enough space (%d)  in authrecord for nsec",  v181,  v182,  v183,  v184,  v185,  v196);
            }

            else
            {
              __int128 v200 = v199 + 1;
              bzero(v358, v196);
              uint64_t v201 = *(_BYTE **)(v178 + 40);
              v202 = v201;
              v203 = v115;
              if (v201 == (_BYTE *)-256LL)
              {
LABEL_385:
                while (v202)
                {
                  v204 = *v202;
                  if (!*v202)
                  {
                    uint64_t v205 = (_WORD)v202 - (_WORD)v201 + 1;
                    if (v205 > 0x100u) {
                      break;
                    }
                    memcpy(v358, v201, v205);
                    goto LABEL_393;
                  }

                  v202 += v204 + 1;
                  if (v201 != (_BYTE *)-256LL) {
                    goto LABEL_384;
                  }
                }
              }

              else
              {
LABEL_384:
                if (v202 < v201 + 256) {
                  goto LABEL_385;
                }
              }

              v358[0] = 0;
LABEL_393:
              int v206 = &v358[v200];
              *int v206 = 0x2000;
              v207 = v206 + 1;
              v208 = *(void *)(v109 + 12624);
              if (v208)
              {
                while (1)
                {
                  if (ResourceRecordIsValidAnswer(v208)
                    && SameResourceRecordNameClassInterface(v208, v178, v209, v210, v211, v212, v213, v214))
                  {
                    v215 = *(unsigned __int16 *)(v208 + 12);
                    if (v215 >= 0xFF)
                    {
                      v231 = (os_log_s *)mDNSLogCategory_Default;
                      GetRRDisplayString_rdb( (unsigned __int8 *)(v208 + 8),  (unsigned __int16 *)(*(void *)(v208 + 48) + 4LL),  v290);
                      LogMsgWithLevel( v231,  OS_LOG_TYPE_DEFAULT,  "SendResponses: Can't create NSEC for record %s",  v232,  v233,  v234,  v235,  v236,  (int)v290);
                      uint64_t v115 = v203;
                      BOOL v179 = v203;
                      goto LABEL_371;
                    }

                    *((_BYTE *)v207 + (v215 >> 3)) |= 0x80u >> (v215 & 7);
                  }

                  v208 = *(void *)v208;
                  if (!v208)
                  {
                    v216 = *(uint64_t **)(v109 + 12624);
                    goto LABEL_401;
                  }
                }
              }

              v216 = 0LL;
LABEL_401:
              __int128 v219 = UnsafeBufferPointer(v216, v178, (uint64_t **)&v307);
              v220 = v305;
              if (v219) {
                v220 = v305 + 1;
              }
              uint64_t v115 = v203;
              if (*v306 || *(_WORD *)(a1 + 28912) || *v295) {
                __int128 v221 = 1440LL;
              }
              else {
                __int128 v221 = 8940LL;
              }
              v222 = v303 + v221;
              int v19 = v220 == 0;
              v223 = v302 + 14 * v220;
              v224 = v301;
              if (v19) {
                v224 = 1;
              }
              if (v224) {
                int v225 = 0;
              }
              else {
                int v225 = 11;
              }
              v226 = PutResourceRecordTTLWithLimit( (unint64_t)v304,  v203,  v295,  (uint64_t)&v322[8],  v323,  v222 - (v223 + v225),  v217,  v218);
              BOOL v179 = v226;
              if (v219 && v226)
              {
                CFRange v227 = *(void *)(v178 + 40);
                v228 = *v306;
                v229 = *v295;
                v230 = calloc(1uLL, 0x18uLL);
                if (!v230) {
                  goto LABEL_549;
                }
                LOWORD(v305) = v305 + 1;
                *((_WORD *)v219 + 4) = v228 + v229 - 1;
                v230[1] = v219;
                v230[2] = v227;
                *v230 = v307;
                v307 = v230;
                uint64_t v109 = a1;
                uint64_t v115 = v203;
              }

              if (v179) {
                uint64_t v115 = v179;
              }
            }

LABEL_340:
    __break(1u);
    return result;
  }

  while (1)
  {
    if (*(void *)(v86 + 32) != *(void *)(a2 + 32)) {
      goto LABEL_211;
    }
    int v95 = *(unsigned __int8 *)(v86 + 8);
    int v96 = *v13;
    BOOL v97 = v96 == 1 || v95 == 1;
    BOOL v98 = v97 || v95 == v96;
    BOOL v99 = v98 || (v96 | v95) == 18;
    if (*(_BYTE *)(v86 + 8) != 1) {
      break;
    }
    *(_BYTE *)(v86 + 191) = 0;
LABEL_211:
    uint64_t v86 = *(void *)v86;
    if (!v86) {
      goto LABEL_212;
    }
  }

  uint64_t v87 = *(unsigned __int8 **)(a2 + 40);
  int v91 = mDNS_DomainNameFNV1aHash(v87);
LABEL_192:
  unint64_t v92 = *(unsigned __int16 *)(a2 + 20);
  if (v92 >= 0x201)
  {
    uint64_t result = (uint64_t)malloc(*(unsigned __int16 *)(a2 + 20));
    int v93 = (void *)result;
    __int16 v94 = (char *)result;
    if (result)
    {
LABEL_223:
      int v151 = 0;
      unsigned __int16 v150 = 0;
      uint64_t v109 = ResourceRecordGetRDataBytesPointer(a2 + 8, v94, v92, &v150, &v151, v88, v89, v90);
      if (!v151)
      {
        __srca = (void *)v109;
        size_t v110 = v150;
        int v148 = v91;
        if (v150 >= 0x1FFu)
        {
          unsigned int v112 = v150 + 2;
          uint64_t result = (uint64_t)malloc(v150 + 2LL);
          if (!result) {
            goto LABEL_340;
          }
          uint64_t v113 = (__int16 *)result;
          uint64_t v111 = (void *)result;
        }

        else
        {
          uint64_t v111 = 0LL;
          unsigned int v112 = 512;
          uint64_t v113 = word_100164338;
        }

        loga = (os_log_s *)mDNSLogCategory_State;
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT))
        {
          int v126 = v113;
          if (v87)
          {
            BOOL v127 = v87;
            int v128 = 257;
LABEL_273:
            if (v127 < v87 + 256 && v127)
            {
              while (1)
              {
                uint64_t v129 = *v127;
                if (v129 > 0x3F)
                {
LABEL_307:
                  int v128 = 257;
                  goto LABEL_312;
                }

                if (!*v127) {
                  break;
                }
                v127 += v129 + 1;
LABEL_276:
                if (!v127) {
                  goto LABEL_307;
                }
              }

              int v128 = (unsigned __int16)((_WORD)v127 - (_WORD)v87 + 1);
            }
          }

          else
          {
            int v128 = 0;
          }

LABEL_312:
          unsigned int v143 = *(unsigned __int16 *)(a2 + 12);
          if ((int)v110 + 2 <= v112)
          {
            BOOL v137 = v126;
            *int v126 = __rev16(v143);
            memcpy(v126 + 1, __srca, v110);
          }

          else
          {
            BOOL v137 = 0LL;
          }

          *(_DWORD *)buf = 141559811;
          *(void *)&uint8_t buf[4] = 1752392040LL;
          *(_WORD *)&buf[12] = 1040;
          *(_DWORD *)&buf[14] = v128;
          *(_WORD *)&buf[18] = 2101;
          *(void *)&buf[20] = v87;
          *(_WORD *)&buf[28] = 1024;
          *(_DWORD *)&buf[30] = v148;
          *(_WORD *)&buf[34] = 1024;
          *(_DWORD *)&buf[36] = v143;
          *(_WORD *)&buf[40] = 2160;
          *(void *)&buf[42] = 1752392040LL;
          __int16 v153 = 1040;
          int v154 = v110 + 2;
          __int16 v155 = 2101;
          uint64_t v156 = v137;
          _os_log_impl( (void *)&_mh_execute_header,  loga,  OS_LOG_TYPE_DEFAULT,  "mDNS_Register_internal: adding to duplicate list -- name: %{sensitive, mask.hash, mdnsresponder:domain_name} .*P (%x), type: %{mdns:rrtype}d, rdata: %{sensitive, mask.hash, mdns:rdata}.*P",  buf,  0x42u);
        }

        if (v111) {
          free(v111);
        }
      }

      if (v93) {
        free(v93);
      }
      goto LABEL_320;
    }

    goto LABEL_340;
  }

  if (*(_WORD *)(a2 + 20))
  {
    int v93 = 0LL;
    __int16 v94 = (char *)&unk_100164138;
    LODWORD(v92) = 512;
    goto LABEL_223;
  }

  uint64_t v121 = (os_log_s *)mDNSLogCategory_State;
  if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT))
  {
    if (v87)
    {
      v122 = v87;
LABEL_253:
      int v123 = 257;
      if (v122 < v87 + 256 && v122)
      {
        while (1)
        {
          uint64_t v124 = *v122;
          if (v124 > 0x3F)
          {
LABEL_337:
            int v123 = 257;
            goto LABEL_339;
          }

          if (!*v122) {
            break;
          }
          v122 += v124 + 1;
LABEL_256:
          if (!v122) {
            goto LABEL_337;
          }
        }

        int v123 = (unsigned __int16)((_WORD)v122 - (_WORD)v87 + 1);
      }
    }

    else
    {
      int v123 = 0;
    }

LABEL_339:
    int v140 = *(unsigned __int16 *)(a2 + 12);
    *(_DWORD *)buf = 141559043;
    *(void *)&uint8_t buf[4] = 1752392040LL;
    *(_WORD *)&buf[12] = 1040;
    *(_DWORD *)&buf[14] = v123;
    *(_WORD *)&buf[18] = 2101;
    *(void *)&buf[20] = v87;
    *(_WORD *)&buf[28] = 1024;
    *(_DWORD *)&buf[30] = v91;
    *(_WORD *)&buf[34] = 1024;
    *(_DWORD *)&buf[36] = v140;
    _os_log_impl( (void *)&_mh_execute_header,  v121,  OS_LOG_TYPE_DEFAULT,  "mDNS_Register_internal: adding to duplicate list -- name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (% x), type: %{mdns:rrtype}d, rdata: <none>",  buf,  0x28u);
  }

LABEL_320:
  uint64_t *v37 = a2;
  if (*(_BYTE *)(a2 + 8) == 2 && *(_BYTE *)(v86 + 8) == 16) {
    *(_BYTE *)(a2 + 190) = 0;
  }
LABEL_323:
  if (*(void *)(a2 + 32) || *(_BYTE *)(a2 + 122) || IsLocalDomain(*(_BYTE **)(a2 + 40)))
  {
    IncrementAutoTargetServices(a1, a2);
    mDNS_UpdateAllowSleep(a1);
  }

  if (!*(_DWORD *)(a2 + 126) && *(_WORD *)(a2 + 12) == 10)
  {
    v138 = *(_BYTE **)(a2 + 40);
    if (*v138) {
      uint64_t v139 = *v138 + 1LL;
    }
    else {
      uint64_t v139 = 0LL;
    }
    if (SameDomainLabelPointer(&v138[v139], "\n_keepalive"))
    {
      memset(buf, 0, 20);
      *(_BYTE *)(a2 + 8) = 32;
      *(_BYTE *)(a2 + 191) = 0;
      getKeepaliveRaddr(a1, a2, (uint64_t)buf);
      mDNSPlatformGetRemoteMacAddr((int *)buf);
    }
  }

  uint64_t v16 = 0LL;
  *(_DWORD *)(a2 + 648) = *(_DWORD *)(a1 + 64);
  return v16;
}

    if ((_DWORD)v232) {
      break;
    }
    if (!v88) {
      goto LABEL_377;
    }
LABEL_367:
    v15[3] = v88;
    ++*v88;
    v204 = v227;
    if (!(_DWORD)v227) {
      goto LABEL_377;
    }
    LODWORD(v16) = 0;
    *(_DWORD *)buf = 0;
    a4 = v226;
    unsigned __int16 v27 = (uint64_t *)v226;
    a5 = v227;
    do
    {
      uint64_t v205 = *v27++;
      uint64_t v16 = (v16 + dnssec_obj_rr_rrsig_covers_rr(v205, (uint64_t)v88, (int *)buf));
      --a5;
    }

    while (a5);
    if (!(_DWORD)v16) {
      goto LABEL_377;
    }
    int v206 = calloc(8uLL, v16);
    if (v206)
    {
      v207 = v206;
      do
      {
        v208 = *(_DWORD **)a4;
        if (dnssec_obj_rr_rrsig_covers_rr(*(void *)a4, (uint64_t)v88, (int *)buf))
        {
          unint64_t v209 = *((unsigned __int8 *)v15 + 40);
          v207[v209] = v208;
          ++*v208;
          *((_BYTE *)v15 + 40) = v209 + 1;
        }

        a4 += 8;
        --v204;
      }

      while (v204);
      v15[4] = v207;
LABEL_377:
      __int16 v82 = 0;
      uint64_t v83 = 0LL;
      uint64_t v81 = v15;
      goto LABEL_378;
    }

void InitializeLastAPTime(_DWORD *a1, uint64_t a2)
{
  int v4 = *(_DWORD *)(a2 + 144);
  if (v4)
  {
    unsigned int v5 = 1000;
  }

  else
  {
    if ((*(_BYTE *)(a2 + 8) & 0x30) != 0) {
      int v6 = 500;
    }
    else {
      int v6 = 0;
    }
    if ((*(_BYTE *)(a2 + 8) & 2) != 0) {
      int v7 = 250;
    }
    else {
      int v7 = v6;
    }
    if ((*(_BYTE *)(a2 + 8) & 0xC) != 0) {
      unsigned int v5 = 500;
    }
    else {
      unsigned int v5 = v7;
    }
  }

  *(_DWORD *)(a2 + 280) = v5;
  if (!*(_BYTE *)(a2 + 190))
  {
    int v16 = *(unsigned __int8 *)(a2 + 8);
    if (v16 == 8 || v16 == 32 || (v17 = a1[3170]) == 0 || (unsigned int v9 = a1[16], (int)(v17 - v9) < 0))
    {
      unsigned int v9 = a1[16];
      int v18 = v9 - v5;
    }

    else
    {
      int v18 = v17 - v5 + (v5 >> 1) + 750;
    }

    *(_DWORD *)(a2 + 284) = v18;
    if (v4) {
      goto LABEL_56;
    }
    goto LABEL_57;
  }

  *(_DWORD *)(a2 + 180) = 0;
  unsigned int v8 = a1[3170];
  unsigned int v9 = a1[16];
  if (!v8 || ((v8 - v9) & 0x80000000) != 0)
  {
    do
      uint32_t v10 = arc4random() & 0x7F;
    while (v10 > 0x7D);
    unsigned int v8 = v9 + v10 + 125;
    if (v8 <= 1) {
      unsigned int v8 = 1;
    }
    a1[3170] = v8;
    unsigned int v11 = a1[24];
    if ((int)(v8 - v11) >= 0)
    {
      if (v11 <= 1) {
        unsigned int v8 = 1;
      }
      else {
        unsigned int v8 = a1[24];
      }
      a1[3170] = v8;
    }

    unsigned int v9 = a1[16];
    if ((int)(v8 - v9) < 0)
    {
      a1[3170] = v9;
      unsigned int v8 = v9;
    }

    unsigned int v12 = a1[23];
    if ((int)(v8 - v12) >= 0)
    {
      if (v12 <= 1) {
        unsigned int v8 = 1;
      }
      else {
        unsigned int v8 = a1[23];
      }
      a1[3170] = v8;
    }

    if ((int)(v8 - v9) < 0)
    {
      a1[3170] = v9;
      unsigned int v8 = v9;
    }

    unsigned int v13 = a1[20];
    if (v13 && ((v8 - v13) & 0x80000000) != 0)
    {
      a1[3170] = v13;
      unsigned int v8 = v13;
    }

    unsigned int v14 = v8 - v9;
    if ((int)(v8 - v9) >= 8001)
    {
      uint64_t v15 = (os_log_s *)mDNSLogCategory_Default;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_50;
        }
      }

      else
      {
        uint64_t v15 = (os_log_s *)mDNSLogCategory_Default_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_50;
        }
      }

      v21[0] = 67110144;
      v21[1] = v14;
      __int16 v22 = 1024;
      unsigned int v23 = v11 - v9;
      __int16 v24 = 1024;
      unsigned int v25 = v12 - v9;
      __int16 v26 = 1024;
      unsigned int v27 = v13;
      __int16 v28 = 1024;
      unsigned int v29 = v13 - v9;
      _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_DEFAULT,  "InitializeLastAPTime ERROR m->SuppressProbes %d m->NextScheduledProbe %d m->NextScheduledQuery %d m->SuppressQueries %d %d",  (uint8_t *)v21,  0x20u);
LABEL_50:
      int v19 = a1[16];
      do
        uint32_t v20 = arc4random() & 0x7F;
      while (v20 > 0x7D);
      unsigned int v8 = v19 + v20 + 125;
      if (v8 <= 1) {
        unsigned int v8 = 1;
      }
      a1[3170] = v8;
      unsigned int v9 = a1[16];
    }
  }

  *(_DWORD *)(a2 + 284) = v8 - *(_DWORD *)(a2 + 280);
  if (*(_DWORD *)(a2 + 144)) {
LABEL_56:
  }
    *(_DWORD *)(a2 + 284) = v9;
LABEL_57:
  *(_DWORD *)(a2 + 288) = v9;
  *(void *)(a2 + 296) = -1LL;
  SetNextAnnounceProbeTime((uint64_t)a1, a2);
}

void SetNextAnnounceProbeTime(uint64_t a1, uint64_t a2)
{
  int v4 = (unsigned __int8 *)(a2 + 8);
  int v5 = *(unsigned __int8 *)(a2 + 8);
  if (v5 == 2)
  {
    int v6 = *(_DWORD *)(a2 + 280) + *(_DWORD *)(a2 + 284) - *(_DWORD *)(a1 + 64);
    if (v6 < 10001) {
      goto LABEL_25;
    }
    int v7 = (os_log_s *)mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
      {
LABEL_18:
        int v13 = *(unsigned __int8 *)(a2 + 190);
        GetRRDisplayString_rdb(v4, (unsigned __int16 *)(*(void *)(a2 + 48) + 4LL), (_BYTE *)(a1 + 46976));
        int v20 = 67109891;
        int v21 = v13;
        __int16 v22 = 1024;
        int v23 = v6;
        __int16 v24 = 2160;
        uint64_t v25 = 1752392040LL;
        __int16 v26 = 2085;
        uint64_t v27 = a1 + 46976;
        _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "SetNextAnnounceProbeTime: ProbeCount %d Next in %d %{sensitive, mask.hash}s",  (uint8_t *)&v20,  0x22u);
      }
    }

    else
    {
      int v7 = (os_log_s *)mDNSLogCategory_Default_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_18;
      }
    }

    unsigned int v14 = (os_log_s *)mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
      {
LABEL_24:
        int v15 = *(_DWORD *)(a1 + 12680);
        int v16 = *(_DWORD *)(a1 + 64);
        int v20 = 67109632;
        int v21 = v15;
        __int16 v22 = 1024;
        int v23 = v16;
        __int16 v24 = 1024;
        LODWORD(v25) = v15 - v16;
        _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_DEFAULT,  "SetNextAnnounceProbeTime: m->SuppressProbes %d m->timenow %d diff %d",  (uint8_t *)&v20,  0x14u);
      }
    }

    else
    {
      unsigned int v14 = (os_log_s *)mDNSLogCategory_Default_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_24;
      }
    }

LABEL_25:
    int v17 = *(_DWORD *)(a1 + 96);
    int v18 = *(_DWORD *)(a2 + 280) + *(_DWORD *)(a2 + 284);
    if (v17 - v18 >= 0)
    {
      *(_DWORD *)(a1 + 96) = v18;
      int v17 = v18;
    }

    int v19 = *(_DWORD *)(a1 + 64);
    if (v17 - v19 < 0) {
      *(_DWORD *)(a1 + 96) = v19;
    }
    return;
  }

  if (*(_BYTE *)(a2 + 191))
  {
    BOOL IsValidAnswer = ResourceRecordIsValidAnswer(a2);
    if (v5 == 1 || IsValidAnswer)
    {
      int v11 = *(_DWORD *)(a2 + 280) + *(_DWORD *)(a2 + 284);
      if (*(_DWORD *)(a1 + 100) - v11 >= 0) {
        *(_DWORD *)(a1 + 100) = v11;
      }
    }
  }

  if (v14)
  {
    while (1)
    {
      int v16 = *v14;
      if (!*v14)
      {
        int v15 = (_WORD)v14 - (_WORD)v6 + 1;
        goto LABEL_32;
      }

      v14 += v16 + 1;
      if (v5 == -260) {
        goto LABEL_25;
      }
LABEL_22:
      int v15 = 257;
    }
  }

  int v15 = 257;
LABEL_32:
  int v17 = v15;
  int v18 = a2;
LABEL_33:
  int v19 = 257;
  if (v18 < a2 + 128 && v18)
  {
    while (1)
    {
      int v20 = *(unsigned __int8 *)v18;
      if (v20 > 0x3F)
      {
LABEL_41:
        int v19 = 257;
        goto LABEL_43;
      }

      if (!*(_BYTE *)v18) {
        break;
      }
      int v18 = (unsigned __int16 *)((char *)v18 + v20 + 1);
LABEL_36:
      if (!v18) {
        goto LABEL_41;
      }
    }

    int v19 = (_WORD)v18 - (_WORD)a2 + 1;
  }

    *(void *)(a2 + 112) = v11;
    return;
  }

  if ((_DWORD)a3 != -65792)
  {
    if (*(_WORD *)(a2 + 12) == 1) {
      BOOL v32 = "HostnameCallback: Error %d for registration of %##s IP %.4a";
    }
    else {
      BOOL v32 = "HostnameCallback: Error %d for registration of %##s IP %.16a";
    }
    LogMsgWithLevel((os_log_s *)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, v32, a4, a5, a6, a7, a8, a3);
    if (!v11)
    {
      BOOL v38 = (void *)a2;
LABEL_38:
      free(v38);
      return;
    }

    if (*(_DWORD *)(a2 + 344) != 4) {
      LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "Error: HostnameCallback invoked with error code for record not in regState_Unregistered!",  v33,  v34,  v35,  v36,  v37,  v39);
    }
    if (*(_DWORD *)(v11 + 808) != 4 || *(_DWORD *)(v11 + 1984) != 4) {
      return;
    }
    *(void *)(a2 + 112) = *(void *)(v11 + 2824);
    __int16 v28 = *(void (**)(uint64_t, uint64_t, uint64_t))(v11 + 2816);
    if (v28)
    {
      unsigned int v29 = a1;
      uint64_t v30 = a2;
      int v31 = a3;
      goto LABEL_24;
    }

    goto LABEL_25;
  }

  if (v11)
  {
    if (mDNS_LoggingEnabled == 1)
    {
      int v13 = (os_log_s *)mDNSLogCategory_Default;
      GetRRDisplayString_rdb( (unsigned __int8 *)(a2 + 8),  (unsigned __int16 *)(*(void *)(a2 + 48) + 4LL),  (_BYTE *)(a1 + 46976));
      LogMsgWithLevel( v13,  OS_LOG_TYPE_DEFAULT,  "HostnameCallback: Got mStatus_MemFree for %p %p %s",  v14,  v15,  v16,  v17,  v18,  v11);
    }

    int v19 = (void *)(a1 + 14608);
    while (1)
    {
      int v19 = (void *)*v19;
      if (!v19) {
        break;
      }
      if (v19 + 58 == (void *)a2 || v19 + 205 == (void *)a2)
      {
        mDNS_Lock_((unsigned int *)a1, (uint64_t)"HostnameCallback", 2500);
        AdvertiseHostname(a1, v19);
        mDNS_Unlock_(a1, (uint64_t)"HostnameCallback", 2500);
        return;
      }
    }

    if (!*(_BYTE *)(v11 + 472) && !*(_BYTE *)(v11 + 1648))
    {
      if (*(void *)(v11 + 200)) {
        mDNS_StopNATOperation_internal(a1, v11 + 8);
      }
      BOOL v38 = (void *)v11;
      goto LABEL_38;
    }
  }

  mDNS_StopQuery_internal((uint64_t)mDNSStorage, (uint64_t)a1 + 24);
  for (uint64_t i = 0LL; i != 123; i += 41LL)
  {
    if ((HIDWORD(a1[i + 55]) & 0x80000000) == 0) {
      mDNS_StopQuery_internal((uint64_t)mDNSStorage, (uint64_t)&a1[i + 42] + 8);
    }
  }

  if (off_10015D920)
  {
    mDNS_VerifyLockState( "Drop Lock",  0,  dword_100158BE8,  ++dword_100158BEC,  (uint64_t)"mDNS_DeactivateNetWake_internal",  16839);
    off_10015D920(mDNSStorage, (char *)a1 + 24, 0LL, 0LL);
    mDNS_VerifyLockState( "Reclaim Lock",  0,  dword_100158BE8,  dword_100158BEC,  (uint64_t)"mDNS_DeactivateNetWake_internal",  16841);
    --dword_100158BEC;
  }

  uint32_t v10 = 0LL;
  *((_DWORD *)a1 + 59) = -1;
  int v11 = (_DWORD *)a1 + 662;
  do
  {
    HIDWORD(a1[v10 + 55]) = -1;
    *int v11 = 0;
    v11 += 5;
    v10 += 41LL;
  }

  while (v10 != 123);
  *((_DWORD *)a1 + 679) = -1;
  *((_DWORD *)a1 + 680) = dword_100158BF8;
}

            uint64_t v25 = (char *)calloc(1uLL, 0xB10uLL);
            if (v25)
            {
              const char *v17 = (uint64_t)v25;
              for (uint64_t i = byte_10015C3C8; i < (char *)&xmmword_10015C4C8 && i != 0LL; i += v28 + 1)
              {
                __int16 v28 = *i;
                if (!*i)
                {
                  unsigned int v29 = (_DWORD)i - mDNSStorage - 14351;
                  if ((unsigned __int16)v29 <= 0x100u)
                  {
                    memcpy(v25 + 208, byte_10015C3C8, (unsigned __int16)v29);
                    goto LABEL_37;
                  }

                  break;
                }
              }

              v25[208] = 0;
LABEL_37:
              uint64_t v30 = *v17;
              *(_DWORD *)(v30 + 808) = 4;
              *(_DWORD *)(v30 + 1984) = 4;
              *(void *)(v30 + 2816) = DynDNSHostNameCallback;
              *(void *)(*v17 + 2824) = 0LL;
              AdvertiseHostname((uint64_t)mDNSStorage, *v17);
            }

            else
            {
              __break(1u);
            }
          }

          return;
        }

        v2 += v3 + 1;
        if (a1 != (_BYTE *)-256LL) {
          goto LABEL_5;
        }
      }
    }

    else
    {
LABEL_5:
      if (v2 < a1 + 256) {
        goto LABEL_6;
      }
    }

    byte_10015C3C8[0] = 0;
  }

    int v13 = 0LL;
  }

  if (a6) {
    *a6 = v30;
  }
  if (v13) {
    free(v13);
  }
  return (char *)v15;
}

  int v23 = *(unsigned __int8 *)(v2 + 248);
  __int16 v24 = *(void *)(v2 + 32);
  uint64_t v25 = v23 - 1;
  if (v23 != 1 || (*(_WORD *)(v24 + 276) & 1) != 0) {
    goto LABEL_44;
  }
  __int16 v26 = *(void *)(v2 + 136);
  if (!v26)
  {
    __int16 v28 = 0LL;
LABEL_39:
    BOOL v32 = 0LL;
    goto LABEL_40;
  }

  uint64_t v27 = *(void *)(v26 + 40);
  __int16 v28 = v27;
  if (v27 >= 0x22F9)
  {
    unsigned int v29 = (os_log_s *)mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
      {
LABEL_35:
        uint64_t v30 = *(_DWORD *)(v2 + 232);
        *(_DWORD *)buf = 67109632;
        *(_DWORD *)&uint8_t buf[4] = v30;
        *(_WORD *)uint64_t v54 = 2048;
        *(void *)&v54[2] = v28;
        *(_WORD *)&v54[10] = 2048;
        __int16 v28 = 8952LL;
        *(void *)&v54[12] = 8952LL;
        _os_log_impl( (void *)&_mh_execute_header,  v29,  OS_LOG_TYPE_DEFAULT,  "[Q%u] Large %lu-byte response will be truncated to fit mDNSCore's %lu-byte message buffer",  buf,  0x1Cu);
        goto LABEL_37;
      }
    }

    else
    {
      unsigned int v29 = (os_log_s *)mDNSLogCategory_Default_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_35;
      }
    }

    __int16 v28 = &unk_1000022F8;
  }

              int v19 = 0LL;
              else {
                int v20 = 1 << (*(_BYTE *)(v3 + 100) - 1);
              }
              *(_DWORD *)(a1 + 228) |= v20;
              *(void *)(a1 + 72) = 0LL;
              *(_BYTE *)(a1 + 247) = 0;
              goto LABEL_31;
            }
          }
        }
      }
    }

    int v19 = *(void *)(a1 + 72);
LABEL_31:
    uint64_t v3 = 0LL;
    if (v19)
    {
      oneshot_timer = _mdns_resolver_create_oneshot_timer(*(_DWORD *)(a1 + 204), 5u);
      *(void *)(a1 + 96) = oneshot_timer;
      if (!oneshot_timer)
      {
        uint64_t v40 = (void *)a1;
        uint64_t v39 = -6729;
        goto LABEL_93;
      }

      handler[0] = _NSConcreteStackBlock;
      handler[1] = 0x40000000LL;
      handler[2] = ___mdns_querier_initiate_send_block_invoke;
      handler[3] = &__block_descriptor_tmp_64;
      handler[4] = a1;
      dispatch_source_set_event_handler(oneshot_timer, handler);
      dispatch_activate(*(dispatch_object_t *)(a1 + 96));
      uint64_t v25 = *(void **)(a1 + 72);
      if (*(_BYTE *)(a1 + 252))
      {
        if (!v25) {
          return;
        }
        __int16 v26 = (void *)v25[4];
        if (v26) {
          goto LABEL_68;
        }
        if (_mdns_resolver_log_s_once != -1) {
          dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_48);
        }
        uint64_t v27 = (os_log_s *)*((void *)v4 + 131);
        if (os_log_type_enabled(v27, OS_LOG_TYPE_DEBUG))
        {
          BOOL v38 = *(const char **)(a1 + 128);
          if (!v38) {
            BOOL v38 = "";
          }
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = v38;
          *(_WORD *)&buf[12] = 2112;
          *(void *)&buf[14] = v25;
          _os_log_debug_impl( (void *)&_mh_execute_header,  v27,  OS_LOG_TYPE_DEBUG,  "%{public}sCreating shared session to %@",  buf,  0x16u);
        }

        int v44 = 0;
        __int16 v26 = _mdns_resolver_create_session(*(void *)(a1 + 64), v25, 1LL, 0LL, 0LL, &v44);
        if (v26)
        {
          os_retain(*(void **)(a1 + 64));
          if (!*((_BYTE *)v26 + 88))
          {
            v26[6] = *(void *)(a1 + 64);
            v26[9] = _mdns_querier_get_shared_session_s_resolver_callbacks;
            *((_DWORD *)v26 + 20) = 10000;
          }

          _mdns_session_activate((uint64_t)v26);
          v25[4] = v26;
LABEL_68:
          else {
            BOOL v32 = 1 << (*(_BYTE *)(v26[4] + 100LL) - 1);
          }
          *(_DWORD *)(a1 + 212) |= v32;
          _mdns_querier_send_query(a1, (uint64_t)v26);
          return;
        }

        if (_mdns_resolver_log_s_once != -1) {
          dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_48);
        }
        uint64_t v41 = (os_log_s *)_mdns_resolver_log_s_log;
        if (!os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_ERROR)) {
          goto LABEL_102;
        }
        *(_DWORD *)buf = 138412546;
        *(void *)&uint8_t buf[4] = v25;
        *(_WORD *)&buf[12] = 2048;
        *(void *)&buf[14] = v44;
        uint64_t v42 = "Failed to create session to %@ for resolver: %{mdns:err}ld";
      }

      else
      {
        if (!v25) {
          return;
        }
        __int16 v28 = 112LL;
        if (*(_BYTE *)(a1 + 251))
        {
          unsigned int v29 = (void *)(a1 + 112);
        }

        else
        {
          __int16 v28 = 104LL;
          unsigned int v29 = (void *)(a1 + 104);
        }

        uint64_t v30 = *(void *)(a1 + v28);
        if (v30)
        {
          while (1)
          {
            __int16 v26 = (void *)v30;
            if (*(void **)(v30 + 32) == v25) {
              goto LABEL_68;
            }
            uint64_t v30 = *(void *)(v30 + 24);
            if (!v30)
            {
              unsigned int v29 = v26 + 3;
              break;
            }
          }
        }

        if (_mdns_resolver_log_s_once != -1) {
          dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_48);
        }
        int v31 = (os_log_s *)*((void *)v4 + 131);
        if (os_log_type_enabled(v31, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v37 = *(const char **)(a1 + 128);
          if (!v37) {
            uint64_t v37 = "";
          }
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = v37;
          *(_WORD *)&buf[12] = 2112;
          *(void *)&buf[14] = v25;
          _os_log_debug_impl( (void *)&_mh_execute_header,  v31,  OS_LOG_TYPE_DEBUG,  "%{public}sCreating session to %@",  buf,  0x16u);
        }

        int v44 = 0;
        __int16 v26 = _mdns_resolver_create_session( *(void *)(a1 + 64),  v25,  *(unsigned __int8 *)(a1 + 251),  a1 + 168,  *(void *)(*(void *)(*(void *)(a1 + 88) + 56LL) + 24LL),  &v44);
        if (v26)
        {
          os_retain((void *)a1);
          if (!*((_BYTE *)v26 + 88))
          {
            v26[6] = a1;
            v26[9] = _mdns_querier_get_unshared_session_s_querier_callbacks;
            if (*(_BYTE *)(a1 + 251)) {
              *((_DWORD *)v26 + 20) = 10000;
            }
          }

          _mdns_session_activate((uint64_t)v26);
          _BYTE *v29 = v26;
          goto LABEL_68;
        }

        if (_mdns_resolver_log_s_once != -1) {
          dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_48);
        }
        uint64_t v41 = (os_log_s *)_mdns_resolver_log_s_log;
        if (!os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_ERROR))
        {
LABEL_102:
          _mdns_resolver_penalize_server_ex(*(void *)(a1 + 64), (uint64_t)v25, 0, 0LL, 0LL);
          *(void *)(a1 + 72) = 0LL;
          *(_BYTE *)(a1 + 247) = 0;
          return;
        }

        *(_DWORD *)buf = 138412546;
        *(void *)&uint8_t buf[4] = v25;
        *(_WORD *)&buf[12] = 2048;
        *(void *)&buf[14] = v44;
        uint64_t v42 = "Failed to create session to %@ for querier: %{mdns:err}ld";
      }

      _os_log_error_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_ERROR, v42, buf, 0x16u);
      goto LABEL_102;
    }
  }

  uint64_t v35 = *(unsigned __int16 *)(a1 + 244);
  uint64_t v36 = *(void **)(a1 + 144);
  os_retain((void *)a1);
  os_retain(v36);
  if (_mdns_resolver_queue_s_once != -1) {
    dispatch_once(&_mdns_resolver_queue_s_once, &__block_literal_global_138);
  }
  *(void *)buf = _NSConcreteStackBlock;
  *(void *)&buf[8] = 0x40000000LL;
  *(void *)&buf[16] = ___mdns_querier_conclude_with_response_async_block_invoke;
  uint64_t v46 = &__block_descriptor_tmp_65_4650;
  int v49 = v35 >> 15;
  unsigned int v47 = a1;
  uint64_t v48 = v36;
  dispatch_async((dispatch_queue_t)_mdns_resolver_queue_s_queue, buf);
}

    if (a5 - *(void *)(a2 + 80) < 0) {
      return;
    }
  }

  __int16 v26 = (void *)(a1 + 24);
  do
  {
    uint64_t v27 = v26;
    __int16 v28 = *v26;
    __int16 v26 = (void *)(*v26 + 24LL);
    if (v28) {
      unsigned int v29 = v28 == a2;
    }
    else {
      unsigned int v29 = 1;
    }
  }

  while (!v29);
  if (v28)
  {
    *uint64_t v27 = *(void *)(a2 + 24);
    *(void *)(a2 + 24) = 0LL;
    uint64_t v30 = mach_continuous_time();
    if (mdns_mach_ticks_per_second_s_once != -1) {
      dispatch_once(&mdns_mach_ticks_per_second_s_once, &__block_literal_global_3412);
    }
    *(void *)(a2 + 72) = v30 + 60 * mdns_mach_ticks_per_second_s_ticks_per_second;
    *(_BYTE *)(a2 + 108) = 1;
    do
    {
      int v31 = v27;
      BOOL v32 = *v27;
      uint64_t v27 = (void *)(*v27 + 24LL);
    }

    while (v32);
    *int v31 = a2;
  }

  if (_mdns_resolver_log_s_once != -1) {
    dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_48);
  }
  uint64_t v33 = (os_log_s *)_mdns_resolver_log_s_log;
  if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_INFO))
  {
    int v34 = "";
    if (a4 && *(void *)(a4 + 128)) {
      int v34 = *(const char **)(a4 + 128);
    }
    uint64_t v36 = 136446466;
    uint64_t v37 = v34;
    BOOL v38 = 2112;
    *(void *)uint64_t v39 = a2;
    _os_log_impl( (void *)&_mh_execute_header,  v33,  OS_LOG_TYPE_INFO,  "%{public}sPenalizing server %@ for 60 seconds",  (uint8_t *)&v36,  0x16u);
  }

  if (a3)
  {
    if (!*(_BYTE *)(a2 + 109)) {
      *(_BYTE *)(a2 + 109) = 1;
    }
    if (*(_BYTE *)(a1 + 132))
    {
      if (nw_endpoint_get_type(*(nw_endpoint_t *)(a2 + 48)) == nw_endpoint_type_address)
      {
        address = nw_endpoint_get_address(*(nw_endpoint_t *)(a2 + 48));
        _mdns_symptoms_report_dns_server_symptom(413697LL, (uint64_t)address);
      }
    }
  }

  if (*(_BYTE *)(a1 + 139))
  {
    int v17 = *(void *)(a1 + 24);
    if (v17)
    {
      while ((*(char *)(v17 + 106) - 1) > 3 || *(_BYTE *)(v17 + 110) || *(_DWORD *)(v17 + 96) >= 3u)
      {
        int v17 = *(void *)(v17 + 24);
        if (!v17) {
          goto LABEL_31;
        }
      }

      *(_BYTE *)(a1 + 139) = 0;
      int v18 = *(dispatch_object_s **)(a1 + 104);
      if (v18)
      {
        dispatch_source_cancel(*(dispatch_source_t *)(a1 + 104));
        dispatch_release(v18);
        *(void *)(a1 + 104) = 0LL;
      }

      int v19 = *(void *)(a1 + 112);
      if (v19)
      {
        mdns_client_invalidate(v19);
        os_release(*(void **)(a1 + 112));
        *(void *)(a1 + 112) = 0LL;
      }

      _mdns_resolver_generate_connection_event(a1);
      os_retain((void *)a1);
      if (_mdns_resolver_queue_s_once != -1) {
        dispatch_once(&_mdns_resolver_queue_s_once, &__block_literal_global_138);
      }
      int v21 = _NSConcreteStackBlock;
      *(void *)&__int16 v22 = 0x40000000LL;
      *((void *)&v22 + 1) = ___mdns_resolver_start_serverless_queries_async_block_invoke;
      int v23 = &__block_descriptor_tmp_113_4672;
      __int16 v24 = a1;
      dispatch_async((dispatch_queue_t)_mdns_resolver_queue_s_queue, &v21);
    }
  }

    int v15 = 0;
    uint64_t result = 4294960560LL;
    goto LABEL_36;
  }

  if (v11) {
    goto LABEL_24;
  }
  uint64_t result = _mdns_dso_client_session_accept_keepalive_message(a1, (uint64_t)a2, a3);
  int v15 = 0;
  if (!(_DWORD)result) {
    goto LABEL_35;
  }
LABEL_36:
  if (a4) {
    *a4 = v15;
  }
  return result;
}

uint64_t GetRDLength( uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a2) {
    uint32_t v10 = *(_BYTE **)(a1 + 32);
  }
  else {
    uint32_t v10 = 0LL;
  }
  if (*(_WORD *)(a1 + 6) == 255)
  {
    return *(unsigned __int16 *)(a1 + 12);
  }

  else
  {
    int v11 = *(unsigned __int16 *)(a1 + 4);
    unsigned __int16 v12 = 4;
    int v13 = *(unsigned __int8 **)(a1 + 40);
    unsigned int v14 = v13 + 4;
    switch(*(_WORD *)(a1 + 4))
    {
      case 1:
        return v12;
      case 2:
      case 5:
      case 0xC:
      case 0x27:
        return CompressedDomainNameLength(v14, v10);
      case 3:
      case 4:
      case 7:
      case 8:
      case 9:
      case 0xA:
      case 0xB:
      case 0x10:
      case 0x13:
      case 0x14:
      case 0x16:
      case 0x17:
      case 0x18:
      case 0x19:
      case 0x1B:
      case 0x1D:
      case 0x1E:
      case 0x1F:
      case 0x20:
      case 0x22:
      case 0x23:
      case 0x25:
      case 0x26:
      case 0x28:
      case 0x29:
      case 0x2A:
      case 0x2B:
      case 0x2C:
      case 0x2D:
      case 0x2E:
      case 0x30:
      case 0x31:
        return *(unsigned __int16 *)(a1 + 12);
      case 6:
        __int16 v17 = CompressedDomainNameLength(v14, v10);
        return (unsigned __int16)(v17 + CompressedDomainNameLength(v13 + 260, v10) + 20);
      case 0xD:
        LOWORD(v18) = *v14 + v14[*v14 + 1];
        return (unsigned __int16)(v18 + 2);
      case 0xE:
      case 0x11:
        __int16 v16 = CompressedDomainNameLength(v14, v10);
        return (unsigned __int16)(CompressedDomainNameLength(v13 + 260, v10) + v16);
      case 0xF:
      case 0x12:
      case 0x15:
      case 0x24:
        return (unsigned __int16)(CompressedDomainNameLength(v13 + 6, v10) + 2);
      case 0x1A:
        int v19 = CompressedDomainNameLength(v13 + 6, v10);
        int v18 = v19 + CompressedDomainNameLength(v13 + 262, v10);
        return (unsigned __int16)(v18 + 2);
      case 0x1C:
        return 16;
      case 0x21:
        return (unsigned __int16)(CompressedDomainNameLength(v13 + 10, v10) + 6);
      case 0x2F:
        int v20 = v13 + 4;
        __int16 v21 = -255;
        break;
      default:
        if (v11 == 65323) {
          return v12;
        }
        return *(unsigned __int16 *)(a1 + 12);
    }

uint64_t ValidateRData(int a1, int a2, _BYTE *a3)
{
  uint64_t result = 1LL;
  switch(a1)
  {
    case 1:
      return a2 == 4;
    case 2:
    case 3:
    case 4:
    case 5:
    case 7:
    case 8:
    case 9:
    case 12:
      unint64_t v5 = (unint64_t)&a3[a2 + 4];
      int v6 = a3 + 4;
      if (v5) {
        goto LABEL_3;
      }
      while (2)
      {
        if (!v6) {
          goto LABEL_11;
        }
LABEL_7:
        uint64_t v8 = *v6;
        if (v8 > 0x3F)
        {
LABEL_11:
          unsigned __int16 v7 = 257;
        }

        else
        {
          if (*v6)
          {
            v6 += v8 + 1;
            if (!v5) {
              continue;
            }
LABEL_3:
            unsigned __int16 v7 = 257;
            goto LABEL_7;
          }

          unsigned __int16 v7 = (_WORD)v6 - ((_WORD)a3 + 4) + 1;
        }

        break;
      }

      int v11 = v7;
      BOOL v12 = v7 >= 0x101u;
      return !v12 && v11 == a2;
    case 13:
    case 14:
    case 16:
      if (!a2) {
        return 0LL;
      }
      unsigned int v9 = a3 + 4;
      unint64_t v10 = (unint64_t)&a3[a2 + 4];
      return v9 == (unsigned __int8 *)v10;
    case 15:
      unsigned int v14 = a3 + 6;
      if (&a3[a2] != (_BYTE *)-4LL) {
        goto LABEL_28;
      }
      while (2)
      {
        if (!v14) {
          goto LABEL_46;
        }
LABEL_32:
        uint64_t v16 = *v14;
        if (v16 > 0x3F)
        {
LABEL_46:
          unsigned __int16 v15 = 257;
        }

        else
        {
          if (*v14)
          {
            v14 += v16 + 1;
            if (&a3[a2] == (_BYTE *)-4LL) {
              continue;
            }
LABEL_28:
            unsigned __int16 v15 = 257;
            if (v14 >= &a3[a2 + 4] || !v14) {
              break;
            }
            goto LABEL_32;
          }

          unsigned __int16 v15 = (_WORD)v14 - ((_WORD)a3 + 6) + 1;
        }

        break;
      }

      BOOL v12 = v15 >= 0x101u;
      int v11 = v15 + 2;
      return !v12 && v11 == a2;
    case 28:
      return a2 == 16;
    case 33:
      __int16 v17 = a3 + 10;
      if (&a3[a2] != (_BYTE *)-4LL) {
        goto LABEL_38;
      }
      break;
    default:
      return result;
  }

LABEL_41:
  if (v17)
  {
    while (1)
    {
      uint64_t v19 = *v17;
      if (!*v17)
      {
        unsigned __int16 v18 = (_WORD)v17 - ((_WORD)a3 + 10) + 1;
        goto LABEL_51;
      }

      v17 += v19 + 1;
      if (&a3[a2] == (_BYTE *)-4LL) {
        goto LABEL_41;
      }
LABEL_38:
      unsigned __int16 v18 = 257;
      if (v17 >= &a3[a2 + 4] || !v17) {
        goto LABEL_51;
      }
    }
  }

  unsigned __int16 v18 = 257;
LABEL_51:
  BOOL v12 = v18 >= 0x101u;
  int v11 = v18 + 6;
  return !v12 && v11 == a2;
}

        v186 = *v184++;
        v182 |= v186 << 16;
        goto LABEL_42;
      }
    }

    else
    {
      uint64_t v184 = v4 + 1;
      uint64_t v182 = *v4;
      uint64_t v183 = v14;
    }

    unsigned int v185 = *v184++;
    v182 |= v185 << 8;
    goto LABEL_41;
  }

  if ((int)(len >> 6) >= 1)
  {
    __int128 v200 = (char *)data + len;
    unsigned __int16 v18 = c->C;
    D = c->D;
    A = c->A;
    B = c->B;
    __int128 v198 = v11 >> 6;
    __int16 v21 = data;
    uint64_t v22 = v11 >> 6;
    v203 = c;
    do
    {
      int v23 = v21[1];
      __int16 v24 = A + (v18 & B | D & ~B) - 680876936 + *v21;
      unsigned __int16 v25 = B + (v24 << 7) + (v24 >> 25);
      __int16 v26 = D + v23 - 389564586 + (B & v25 | v18 & ~v25);
      uint64_t v27 = v25 + (v26 << 12) + (v26 >> 20);
      unsigned int v29 = v21[2];
      __int16 v28 = v21[3];
      uint64_t v30 = v18 + v29 + 606105819 + (v25 & v27 | B & ~v27);
      int v31 = v27 + (v30 << 17) + (v30 >> 15);
      BOOL v32 = B + v28 - 1044525330 + (v27 & v31 | v25 & ~v31);
      uint64_t v33 = v31 + (v32 << 22) + (v32 >> 10);
      uint64_t v35 = v21[4];
      int v34 = v21[5];
      uint64_t v36 = v25 + v35 - 176418897 + (v31 & v33 | v27 & ~v33);
      uint64_t v37 = v33 + (v36 << 7) + (v36 >> 25);
      BOOL v38 = v27 + v34 + 1200080426 + (v33 & v37 | v31 & ~v37);
      uint64_t v39 = v37 + (v38 << 12) + (v38 >> 20);
      uint64_t v41 = v21[6];
      uint64_t v40 = v21[7];
      uint64_t v42 = v31 + v41 - 1473231341 + (v37 & v39 | v33 & ~v39);
      int v43 = v39 + (v42 << 17) + (v42 >> 15);
      int v44 = v40 + v33 - 45705983 + (v39 & v43 | v37 & ~v43);
      char v45 = v43 + (v44 << 22) + (v44 >> 10);
      uint64_t v46 = v21[8];
      unsigned int v47 = v21[9];
      uint64_t v48 = v46 + v37 + 1770035416 + (v43 & v45 | v39 & ~v45);
      int v49 = v45 + (v48 << 7) + (v48 >> 25);
      int v50 = v47 + v39 - 1958414417 + (v45 & v49 | v43 & ~v49);
      uint64_t v51 = v49 + (v50 << 12) + (v50 >> 20);
      uint64_t v52 = v21[10];
      uint64_t v53 = v21[11];
      uint64_t v54 = v52 + v43 - 42063 + (v49 & v51 | v45 & ~v51);
      uint64_t v55 = v51 + (v54 << 17) + (v54 >> 15);
      uint64_t v56 = v53 + v45 - 1990404162 + (v51 & v55 | v49 & ~v55);
      uint64_t v57 = v55 + (v56 << 22) + (v56 >> 10);
      uint64_t v59 = v21[12];
      uint64_t v58 = v21[13];
      uint64_t v60 = v59 + v49 + 1804603682 + (v55 & v57 | v51 & ~v57);
      int v61 = v57 + (v60 << 7) + (v60 >> 25);
      uint64_t v62 = v58 + v51 - 40341101 + (v57 & v61 | v55 & ~v61);
      int v63 = v61 + (v62 << 12) + (v62 >> 20);
      uint64_t v65 = v21[14];
      uint64_t v64 = v21[15];
      uint64_t v66 = v65 + v55 - 1502002290 + (v61 & v63 | v57 & ~v63);
      int v67 = v63 + (v66 << 17) + (v66 >> 15);
      uint64_t v68 = v64 + v57 + 1236535329 + (v63 & v67 | v61 & ~v67);
      uint64_t v69 = v67 + (v68 << 22) + (v68 >> 10);
      int v70 = v23 + v61 - 165796510 + (v69 & v63 | v67 & ~v63);
      uint64_t v71 = v69 + 32 * v70 + (v70 >> 27);
      int v72 = v41 + v63 - 1069501632 + (v71 & v67 | v69 & ~v67);
      int v73 = v71 + (v72 << 9) + (v72 >> 23);
      uint64_t v74 = v53 + v67 + 643717713 + (v73 & v69 | v71 & ~v69);
      int v75 = v73 + (v74 << 14) + (v74 >> 18);
      unint64_t v76 = *v21 + v69 - 373897302 + (v75 & v71 | v73 & ~v71);
      uint64_t v77 = v75 + (v76 << 20) + (v76 >> 12);
      uint64_t v78 = v34 + v71 - 701558691 + (v77 & v73 | v75 & ~v73);
      uint64_t v79 = v77 + 32 * v78 + (v78 >> 27);
      int v80 = v52 + v73 + 38016083 + (v79 & v75 | v77 & ~v75);
      uint64_t v81 = v79 + (v80 << 9) + (v80 >> 23);
      __int16 v82 = v64 + v75 - 660478335 + (v81 & v77 | v79 & ~v77);
      uint64_t v83 = v81 + (v82 << 14) + (v82 >> 18);
      __int16 v84 = v35 + v77 - 405537848 + (v83 & v79 | v81 & ~v79);
      uint64_t v85 = v83 + (v84 << 20) + (v84 >> 12);
      uint64_t v86 = v47 + v79 + 568446438 + (v85 & v81 | v83 & ~v81);
      uint64_t v87 = v85 + 32 * v86 + (v86 >> 27);
      uint64_t v88 = v65 + v81 - 1019803690 + (v87 & v83 | v85 & ~v83);
      uint64_t v89 = v87 + (v88 << 9) + (v88 >> 23);
      uint64_t v90 = v28 + v83 - 187363961 + (v89 & v85 | v87 & ~v85);
      int v91 = v89 + (v90 << 14) + (v90 >> 18);
      unint64_t v92 = v46 + v85 + 1163531501 + (v91 & v87 | v89 & ~v87);
      int v93 = v91 + (v92 << 20) + (v92 >> 12);
      __int16 v94 = v58 + v87 - 1444681467 + (v93 & v89 | v91 & ~v89);
      int v95 = v93 + 32 * v94 + (v94 >> 27);
      int v96 = v29 + v89 - 51403784 + (v95 & v91 | v93 & ~v91);
      BOOL v97 = v95 + (v96 << 9) + (v96 >> 23);
      BOOL v98 = v40 + v91 + 1735328473 + (v97 & v93 | v95 & ~v93);
      BOOL v99 = v97 + (v98 << 14) + (v98 >> 18);
      unint64_t v100 = v59 + v93 - 1926607734 + ((v99 ^ v97) & v95 ^ v97);
      uint64_t v101 = v99 + (v100 << 20) + (v100 >> 12);
      uint64_t v102 = v34 + v95 - 378558 + (v99 ^ v97 ^ v101);
      uint64_t v103 = v101 + 16 * v102 + (v102 >> 28);
      size_t v104 = v46 + v97 - 2022574463 + (v101 ^ v99 ^ v103);
      uint64_t v105 = v103 + (v104 << 11) + (v104 >> 21);
      unsigned int v106 = v53 + v99 + 1839030562 + (v103 ^ v101 ^ v105);
      uint64_t v107 = v105 + (v106 << 16) + HIWORD(v106);
      int v108 = v65 + v101 - 35309556 + (v105 ^ v103 ^ v107);
      uint64_t v109 = v107 + (v108 << 23) + (v108 >> 9);
      size_t v110 = v23 + v103 - 1530992060 + (v107 ^ v105 ^ v109);
      uint64_t v111 = v109 + 16 * v110 + (v110 >> 28);
      unsigned int v112 = v35 + v105 + 1272893353 + (v109 ^ v107 ^ v111);
      uint64_t v113 = v111 + (v112 << 11) + (v112 >> 21);
      uint64_t v114 = v40 + v107 - 155497632 + (v111 ^ v109 ^ v113);
      uint64_t v115 = v113 + (v114 << 16) + HIWORD(v114);
      int v116 = v52 + v109 - 1094730640 + (v113 ^ v111 ^ v115);
      uint64_t v117 = v115 + (v116 << 23) + (v116 >> 9);
      v118 = v58 + v111 + 681279174 + (v115 ^ v113 ^ v117);
      int v119 = v117 + 16 * v118 + (v118 >> 28);
      uint64_t v120 = *v21 + v113 - 358537222 + (v117 ^ v115 ^ v119);
      uint64_t v121 = v119 + (v120 << 11) + (v120 >> 21);
      v122 = v28 + v115 - 722521979 + (v119 ^ v117 ^ v121);
      int v123 = v121 + (v122 << 16) + HIWORD(v122);
      uint64_t v124 = v41 + v117 + 76029189 + (v121 ^ v119 ^ v123);
      char v125 = v123 + (v124 << 23) + (v124 >> 9);
      int v126 = v47 + v119 - 640364487 + (v123 ^ v121 ^ v125);
      BOOL v127 = v125 + 16 * v126 + (v126 >> 28);
      int v128 = v59 + v121 - 421815835 + (v125 ^ v123 ^ v127);
      uint64_t v129 = v127 + (v128 << 11) + (v128 >> 21);
      unsigned int v130 = v64 + v123 + 530742520 + (v127 ^ v125 ^ v129);
      int v131 = v129 + (v130 << 16) + HIWORD(v130);
      int v132 = v29 + v125 - 995338651 + (v129 ^ v127 ^ v131);
      size_t v133 = v131 + (v132 << 23) + (v132 >> 9);
      unsigned int v134 = *v21 + v127 - 198630844 + ((v133 | ~v129) ^ v131);
      v135 = v133 + (v134 << 6) + (v134 >> 26);
      int v136 = v40 + v129 + 1126891415 + ((v135 | ~v131) ^ v133);
      BOOL v137 = v135 + (v136 << 10) + (v136 >> 22);
      v138 = v65 + v131 - 1416354905 + ((v137 | ~v133) ^ v135);
      uint64_t v139 = v137 + (v138 << 15) + (v138 >> 17);
      int v140 = v34 + v133 - 57434055 + ((v139 | ~v135) ^ v137);
      uint64_t v141 = v139 + (v140 << 21) + (v140 >> 11);
      uint64_t v142 = v59 + v135 + 1700485571 + ((v141 | ~v137) ^ v139);
      unsigned int v143 = v141 + (v142 << 6) + (v142 >> 26);
      uint64_t v144 = v28 + v137 - 1894986606 + ((v143 | ~v139) ^ v141);
      uint64_t v145 = v143 + (v144 << 10) + (v144 >> 22);
      int v146 = v52 + v139;
      unint64_t v5 = v203;
      uint64_t v147 = v146 - 1051523 + ((v145 | ~v141) ^ v143);
      int v148 = v145 + (v147 << 15) + (v147 >> 17);
      int v149 = v23 + v141 - 2054922799 + ((v148 | ~v143) ^ v145);
      unsigned __int16 v150 = v148 + (v149 << 21) + (v149 >> 11);
      int v151 = v46 + v143 + 1873313359 + ((v150 | ~v145) ^ v148);
      uint64_t v152 = v150 + (v151 << 6) + (v151 >> 26);
      __int16 v153 = v64 + v145 - 30611744 + ((v152 | ~v148) ^ v150);
      int v154 = v152 + (v153 << 10) + (v153 >> 22);
      __int16 v155 = v41 + v148 - 1560198380 + ((v154 | ~v150) ^ v152);
      uint64_t v156 = v154 + (v155 << 15) + (v155 >> 17);
      uint64_t v157 = v58 + v150 + 1309151649 + ((v156 | ~v152) ^ v154);
      int v158 = v156 + (v157 << 21) + (v157 >> 11);
      LODWORD(c) = -145523070;
      v159 = v35 + v152 - 145523070 + ((v158 | ~v154) ^ v156);
      uint64_t v160 = v158 + (v159 << 6) + (v159 >> 26);
      v161 = v53 + v154 - 1120210379 + ((v160 | ~v156) ^ v158);
      uint64_t v162 = v160 + (v161 << 10) + (v161 >> 22);
      v163 = v29 + v156 + 718787259 + ((v162 | ~v158) ^ v160);
      uint64_t v164 = v162 + (v163 << 15) + (v163 >> 17);
      int v165 = v47 + v158 - 343485551 + ((v164 | ~v160) ^ v162);
      A += v160;
      B += v164 + (v165 << 21) + (v165 >> 11);
      v18 += v164;
      D += v162;
      v203->A = A;
      v203->B = B;
      v203->C = v18;
      v203->D = D;
      v21 += 16;
      LODWORD(v22) = v22 - 1;
    }

    while ((_DWORD)v22);
    BOOL v12 = (unsigned __int8 *)data + (int)((_DWORD)v198 << 6);
    int v6 = v200;
    int v11 = len - (int)((_DWORD)v198 << 6);
    uint64_t v3 = len;
    int v4 = (unsigned __int8 *)data;
  }

  if (v11)
  {
    uint64_t v166 = v5->data;
    v5->num = v11;
    int v167 = v11 & 3;
    if ((v11 >> 2) && v6 - (char *)v12 >= 4)
    {
      uint64_t v168 = (v11 >> 2) - 1;
      char v169 = &v4[v3] - v12 - 4;
      do
      {
        int v170 = *(_DWORD *)v12;
        v12 += 4;
        *v166++ = v170;
        if (v168-- == 0) {
          break;
        }
        v172 = v169 <= 3;
        v169 -= 4LL;
      }

      while (!v172);
    }

    int v173 = 0;
    v174 = &v12[v11 & 3];
    if (v167 != 1)
    {
      if (v167 != 2)
      {
        if (v167 != 3)
        {
LABEL_26:
          *uint64_t v166 = v173;
          return (int)c;
        }

        v175 = *--v174;
        int v173 = v175 << 16;
      }

      uint8_t v176 = *--v174;
      v173 |= v176 << 8;
    }

    v173 |= *(v174 - 1);
    goto LABEL_26;
  }

  return (int)c;
}

    uint64_t v19 = DNSTypeName(*(unsigned __int16 *)(a2 + 12));
    uint64_t v27 = 141558787;
    __int16 v28 = 1752392040LL;
    unsigned int v29 = 1040;
    uint64_t v30 = v18;
    int v31 = 2101;
    BOOL v32 = v12;
    uint64_t v33 = 2082;
    int v34 = v19;
    _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "ReleaseCacheRecord: ERROR!! cg NULL for %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%{public}s)",  (uint8_t *)&v27,  0x26u);
    goto LABEL_42;
  }

  uint64_t v8 = v7;
  unsigned int v9 = *(void **)(a2 + 40);
LABEL_42:
  *(void *)(a2 + 40) = 0LL;
  if (!*(void *)(a2 + 32)) {
    *(_DWORD *)(a1 + 256) -= *(unsigned __int16 *)(a2 + 20);
  }
  int v20 = *(void **)(a2 + 64);
  if (v20)
  {
    ref_count_obj_release(v20);
    *(void *)(a2 + 64) = 0LL;
  }

  __int16 v21 = *(void **)(a2 + 120);
  if (v21)
  {
    do
    {
      uint64_t v22 = v21;
      *(void *)(a2 + 120) = *v21;
      int v23 = (void *)v21[6];
      __int16 v24 = v21 + 19;
      if (v23) {
        unsigned __int16 v25 = v23 == v24;
      }
      else {
        unsigned __int16 v25 = 1;
      }
      if (!v25)
      {
        free(v23);
        v22[6] = 0LL;
      }

      __int16 v26 = (void *)v22[5];
      if (v26)
      {
        free(v26);
        v22[5] = 0LL;
      }

      if (!v22[4]) {
        *(_DWORD *)(a1 + 256) -= *((unsigned __int16 *)v22 + 10);
      }
      *uint64_t v22 = *(void *)(a1 + 272);
      *(void *)(a1 + 272) = v22;
      --*(_DWORD *)(a1 + 252);
      __int16 v21 = *(void **)(a2 + 120);
    }

    while (v21);
  }

  else
  {
    uint64_t v22 = *(void **)(a1 + 272);
  }

  *(void *)a2 = v22;
  *(void *)(a1 + 272) = a2;
  --*(_DWORD *)(a1 + 252);
}

  int v11 = *(void *)(a2 + 376);
  if (!v11) {
    goto LABEL_14;
  }
  if (*(_DWORD *)(v11 + 788) == 4)
  {
    uint64_t v27 = *(unsigned __int8 *)(v11 + 792);
    switch(v27)
    {
      case 10:
        unsigned int v29 = 1;
        goto LABEL_71;
      case 192:
        __int16 v28 = *(unsigned __int8 *)(v11 + 793) == 168;
LABEL_68:
        unsigned int v29 = v28;
        goto LABEL_71;
      case 172:
        __int16 v28 = (*(_BYTE *)(v11 + 793) & 0xF0) == 16;
        goto LABEL_68;
    }
  }

  unsigned int v29 = 0;
LABEL_71:
  LODWORD(v11) = v29 ^ 1;
LABEL_14:
  if (*(void *)(a2 + 584))
  {
    BOOL v12 = *(unsigned __int16 *)(a2 + 568) != v9;
  }

  else
  {
    if ((v11 & 1) != 0)
    {
      unsigned int v14 = 1;
      goto LABEL_25;
    }

    BOOL v12 = 0;
  }

  unsigned int v14 = v12 & ~(_DWORD)v11;
LABEL_25:
  if (mDNS_LoggingEnabled == 1)
  {
    unsigned __int16 v15 = (os_log_s *)mDNSLogCategory_Default;
    GetRRDisplayString_rdb((unsigned __int8 *)(a2 + 8), (unsigned __int16 *)(v8 + 4), (_BYTE *)(a1 + 46976));
    LogMsgWithLevel( v15,  OS_LOG_TYPE_DEFAULT,  "UpdateOneSRVRecord: Resource Record %s TargetChanged %d, NewTarget %##s",  v16,  v17,  v18,  v19,  v20,  a1 + 46976);
  }

  mDNS_VerifyLockState("Check Lock", 1, *(_DWORD *)(a1 + 48), *(_DWORD *)(a1 + 52), (uint64_t)"UpdateOneSRVRecord", 2307);
  if ((v7 | v14) == 1)
  {
    if (*(_BYTE *)(a2 + 8) == 1)
    {
      if (mDNS_LoggingEnabled) {
        LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "UpdateOneSRVRecord: Deregistering record, Ignoring TargetChanged %d, NATChanged %d for %##s, state %d",  v22,  v23,  v24,  v25,  v26,  v7);
      }
    }

    else
    {
      if (mDNS_LoggingEnabled) {
        LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "UpdateOneSRVRecord: TargetChanged %d, NATChanged %d for %##s, state %d, newtarget %##s",  v22,  v23,  v24,  v25,  v26,  v7);
      }
      switch(*(_DWORD *)(a2 + 344))
      {
        case 1:
        case 2:
        case 3:
        case 5:
          *(_BYTE *)(a2 + 592) = 1;
          *(_DWORD *)(a2 + 280) = 1000;
          *(_DWORD *)(a2 + 284) = *(_DWORD *)(a1 + 64) - 1000;
          if (!*v6)
          {
            if (mDNS_LoggingEnabled) {
              LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "UpdateOneSRVRecord: SRV record changed for service %##s de-registering",  v22,  v23,  v24,  v25,  v26,  *(void *)(a2 + 40));
            }
            *(_DWORD *)(a2 + 344) = 3;
            uint64_t v30 = a1;
            int v31 = a2;
            BOOL v32 = 0;
            goto LABEL_76;
          }

          if (mDNS_LoggingEnabled) {
            LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "UpdateOneSRVRecord: SRV record changed for service %##s, registering with new target %##s",  v22,  v23,  v24,  v25,  v26,  *(void *)(a2 + 40));
          }
          *(_DWORD *)(a2 + 344) = 1;
          break;
        case 6:
        case 7:
          return;
        case 8:
          goto LABEL_53;
        case 9:
          if (v14)
          {
LABEL_53:
            if (*v6)
            {
              if (mDNS_LoggingEnabled) {
                LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "RegisterAllServiceRecords: Service Record %##s",  v22,  v23,  v24,  v25,  v26,  *(void *)(a2 + 40));
              }
              *(_BYTE *)(a2 + 592) = 0;
              uint64_t v33 = (void *)(a1 + 12624);
              do
              {
                int v34 = v33;
                uint64_t v33 = (void *)*v33;
                if (v33) {
                  uint64_t v35 = v33 == (void *)a2;
                }
                else {
                  uint64_t v35 = 1;
                }
              }

              while (!v35);
              if (v33)
              {
                _BYTE *v34 = *(void *)a2;
                *(void *)a2 = 0LL;
                if (*(void *)(a2 + 584))
                {
                  mDNS_StopNATOperation_internal(a1, a2 + 392);
                  *(void *)(a2 + 584) = 0LL;
                  if (*(_WORD *)(a2 + 12) == 33) {
                    *(_WORD *)(*(void *)(a2 + 48) + 8LL) = *(_WORD *)(a2 + 566);
                  }
                }
              }

              else
              {
                LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "UnlinkResourceRecord:ERROR!! - no such active record %##s",  v22,  v23,  v24,  v25,  v26,  *(void *)(a2 + 40));
              }

              mDNS_Register_internal(a1, a2, v21, v22, v23, v24, v25, v26);
              uint64_t v30 = a1;
              int v31 = a2;
              BOOL v32 = 1;
LABEL_76:
              UpdateAllServiceRecords(v30, v31, v32);
            }

            else if (mDNS_LoggingEnabled)
            {
              uint64_t v36 = (os_log_s *)mDNSLogCategory_Default;
              GetRRDisplayString_rdb( (unsigned __int8 *)(a2 + 8),  (unsigned __int16 *)(*(void *)(a2 + 48) + 4LL),  (_BYTE *)(a1 + 46976));
              LogMsgWithLevel( v36,  OS_LOG_TYPE_DEFAULT,  "UpdateOneSRVRecord: No target yet for Resource Record %s",  v37,  v38,  v39,  v40,  v41,  a1 + 46976);
            }
          }

          break;
        default:
          LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "UpdateOneSRVRecord: Unknown state %d for %##s",  v22,  v23,  v24,  v25,  v26,  *(_DWORD *)(a2 + 344));
          break;
      }
    }
  }

  if (!*(_DWORD *)(*(void *)(a1 + 64) + 128LL)) {
    goto LABEL_48;
  }
  int v49 = *(void *)(a2 + 32);
  if (*(_BYTE *)(v49 + 107)) {
    goto LABEL_48;
  }
  int v50 = *(void *)(a1 + 88);
  if ((*(_WORD *)(v50 + 64) & 0xFFFE) != 0x40) {
    goto LABEL_48;
  }
  uint64_t v51 = (*(_DWORD *)(v49 + 100) - 1) >= 0x20 ? 0 : 1 << (*(_BYTE *)(v49 + 100) - 1);
  if ((v51 & *(_DWORD *)(a1 + 200)) != 0) {
    goto LABEL_48;
  }
  uint64_t v52 = *(uint64_t **)(v49 + 64);
  if (v52)
  {
  }

  uint64_t v53 = *(void *)(a1 + 192);
  if (v53) {
    goto LABEL_72;
  }
  uint64_t v54 = *(_WORD *)(v49 + 104);
  if (!v54)
  {
    if (nw_endpoint_get_type(*(nw_endpoint_t *)(v49 + 48)) == nw_endpoint_type_address)
    {
      else {
        uint64_t v54 = 1;
      }
    }

    else
    {
      uint64_t v54 = 1;
    }

    *(_WORD *)(v49 + 104) = v54;
  }

  uint64_t v55 = mdns_query_message_create();
  if (!v55)
  {
LABEL_107:
    *(void *)(a1 + 192) = 0LL;
    if (_mdns_resolver_log_s_once != -1) {
      dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_48);
    }
    uint64_t v89 = (os_log_s *)_mdns_resolver_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_ERROR))
    {
      uint64_t v90 = *(const char **)(a1 + 128);
      if (!v90) {
        uint64_t v90 = "";
      }
      int v91 = 136446210;
      unint64_t v92 = v90;
      _os_log_error_impl( (void *)&_mh_execute_header,  v89,  OS_LOG_TYPE_ERROR,  "%{public}sFailed to create test query",  (uint8_t *)&v91,  0xCu);
    }

    goto LABEL_48;
  }

  uint64_t v53 = v55;
  mdns_query_message_set_qname(v55, *(void **)(v50 + 56));
  if ((*(_BYTE *)(v53 + 70) & 0x20) == 0)
  {
    *(_WORD *)(v53 + 64) = v54;
    *(_WORD *)(v53 + 66) = *(_WORD *)(v50 + 66);
  }

  uint64_t v56 = arc4random();
  if ((*(_BYTE *)(v53 + 70) & 0x20) == 0)
  {
    if (v56 % 0xFFFF == 65534) {
      uint64_t v57 = 1;
    }
    else {
      uint64_t v57 = -2 - v56 % 0xFFFF;
    }
    else {
      uint64_t v58 = v56 % 0xFFFF + 1;
    }
    *(_WORD *)(v53 + 68) = v58;
  }

  if (mdns_query_message_construct(v53))
  {
    os_release((void *)v53);
    goto LABEL_107;
  }

  *(void *)(a1 + 192) = v53;
LABEL_72:
  if (*(_BYTE *)(a2 + 88) == 1)
  {
    uint64_t v59 = *(void *)(v53 + 24);
    uint64_t v60 = *(unsigned __int16 *)(v53 + 64);
    *(void *)(a2 + 64) = mach_continuous_time();
    int v61 = *(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a2 + 16) + 80LL);
    if (v61) {
      v61(a2, v59, v60);
    }
  }

  uint64_t v62 = *(unsigned __int8 *)(a1 + 246);
  if (v62 != 255) {
    *(_BYTE *)(a1 + 246) = v62 + 1;
  }
  int v63 = *(void *)(a1 + 192);
  if (v63)
  {
    uint64_t v64 = *(void *)(v63 + 40);
    if (*(_BYTE *)(a1 + 255))
    {
      uint64_t v65 = (void *)(v63 + 16);
      while (1)
      {
        uint64_t v65 = (void *)*v65;
        if (!v65) {
          break;
        }
        uint64_t v66 = (uint64_t (*)(void, void, uint64_t))v65[3];
        if (v66)
        {
          int v67 = v66(*(void *)(a1 + 192), 0LL, 1LL);
          if (!v67) {
            break;
          }
          uint64_t v68 = (void *)v67;
          if (_mdns_resolver_log_s_once != -1) {
            dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_48);
          }
          uint64_t v69 = (os_log_s *)_mdns_resolver_log_s_log;
          if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_DEFAULT))
          {
            if (*(void *)(a1 + 128)) {
              int v70 = *(const char **)(a1 + 128);
            }
            else {
              int v70 = "";
            }
            uint64_t v71 = *(unsigned __int8 *)(a1 + 246);
            int v72 = *(void *)(a2 + 32);
            int v73 = *(void *)(a1 + 64);
            uint64_t v74 = 152LL;
            if (!*(_BYTE *)(a2 + 89)) {
              uint64_t v74 = 148LL;
            }
            int v75 = *(_DWORD *)(*(void *)(v73 + 16) + v74);
            unint64_t v76 = _mdns_resolver_get_interface_log_string(v73);
            uint64_t v77 = 12;
            uint64_t v78 = *(void *)(*(void *)(a1 + 192) + 32LL);
            if (v64 < 0xC) {
              uint64_t v77 = v64;
            }
            int v91 = 136448258;
            unint64_t v92 = v70;
            int v93 = 2048;
            __int16 v94 = v64;
            int v95 = 1024;
            int v96 = v71;
            BOOL v97 = 2112;
            BOOL v98 = v72;
            BOOL v99 = 1024;
            unint64_t v100 = v75;
            uint64_t v101 = 2082;
            uint64_t v102 = v76;
            uint64_t v103 = 1040;
            *(_DWORD *)size_t v104 = v77;
            *(_WORD *)&v104[4] = 2098;
            *(void *)&v104[6] = v78;
            *(_WORD *)&v104[14] = 2082;
            *(void *)&v104[16] = v68;
            _os_log_impl( (void *)&_mh_execute_header,  v69,  OS_LOG_TYPE_DEFAULT,  "%{public}sSent %zu-byte test query #%u to %@ over %{mdns:protocol}d via %{public}s -- %{public,mdns:dnshdr }.*P, %{public}s",  (uint8_t *)&v91,  0x50u);
          }

          free(v68);
          goto LABEL_48;
        }
      }
    }

    if (_mdns_resolver_log_s_once != -1) {
      dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_48);
    }
    uint64_t v79 = (os_log_s *)_mdns_resolver_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_DEFAULT))
    {
      if (*(void *)(a1 + 128)) {
        int v80 = *(const char **)(a1 + 128);
      }
      else {
        int v80 = "";
      }
      uint64_t v81 = *(unsigned __int8 *)(a1 + 246);
      __int16 v82 = *(void *)(a2 + 32);
      uint64_t v83 = *(void *)(a1 + 64);
      __int16 v84 = 152LL;
      if (!*(_BYTE *)(a2 + 89)) {
        __int16 v84 = 148LL;
      }
      uint64_t v85 = *(_DWORD *)(*(void *)(v83 + 16) + v84);
      uint64_t v86 = _mdns_resolver_get_interface_log_string(v83);
      uint64_t v87 = 12;
      uint64_t v88 = *(void *)(*(void *)(a1 + 192) + 32LL);
      if (v64 < 0xC) {
        uint64_t v87 = v64;
      }
      int v91 = 136448258;
      unint64_t v92 = v80;
      int v93 = 2048;
      __int16 v94 = v64;
      int v95 = 1024;
      int v96 = v81;
      BOOL v97 = 2112;
      BOOL v98 = v82;
      BOOL v99 = 1024;
      unint64_t v100 = v85;
      uint64_t v101 = 2082;
      uint64_t v102 = v86;
      uint64_t v103 = 1040;
      *(_DWORD *)size_t v104 = v87;
      *(_WORD *)&v104[4] = 2098;
      *(void *)&v104[6] = v88;
      *(_WORD *)&v104[14] = 2112;
      *(void *)&v104[16] = v63;
      _os_log_impl( (void *)&_mh_execute_header,  v79,  OS_LOG_TYPE_DEFAULT,  "%{public}sSent %zu-byte test query #%u to %@ over %{mdns:protocol}d via %{public}s -- %{public,mdns:dnshdr}.*P, %@",  (uint8_t *)&v91,  0x50u);
    }
  }

                  __int16 v17 = *(unsigned __int16 *)(v8 + 4);
                  *(_DWORD *)buf = 141558787;
                  uint64_t v33 = 1752392040LL;
                  int v34 = 1040;
                  *(_DWORD *)uint64_t v35 = (_DWORD)v14;
                  *(_WORD *)&v35[4] = 2101;
                  *(void *)&v35[6] = v13;
                  *(_WORD *)&v35[14] = 1024;
                  *(_DWORD *)&v35[16] = v17;
                  _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_INFO,  "Make validated RR expire soon - name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P, rr_type : %{mdns:rrtype}d",  buf,  0x22u);
                }
              }

              else
              {
                BOOL v12 = (os_log_s *)mDNSLogCategory_DNSSEC_redacted;
                if (os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC_redacted, OS_LOG_TYPE_INFO))
                {
                  int v13 = *(void *)(v8 + 32);
                  if (v13)
                  {
                    unsigned int v14 = *(_BYTE **)(v8 + 32);
                    if (v13 == -256)
                    {
LABEL_19:
                      while (v14)
                      {
                        unsigned __int16 v15 = *v14;
                        if (!*v14)
                        {
                          LOWORD(v14) = (_WORD)v14 - v13 + 1;
                          goto LABEL_38;
                        }

                        v14 += v15 + 1;
                        if (v13 != -256) {
                          goto LABEL_18;
                        }
                      }
                    }

                    else
                    {
LABEL_18:
                    }

                    LOWORD(v14) = 257;
LABEL_38:
                    LODWORD(v14) = (unsigned __int16)v14;
                  }

                  else
                  {
                    LODWORD(v14) = 0;
                  }

                  goto LABEL_41;
                }
              }

              *((_DWORD *)v10 + 20) = dword_100158BF8 + 1000 * (3 - *((_DWORD *)v10 + 4));
            }

            *((_BYTE *)v10 + 108) = 4;
            goto LABEL_44;
          }

          unsigned __int16 v18 = (os_log_s *)mDNSLogCategory_DNSSEC;
          if (gSensitiveLoggingEnabled == 1 && mDNSLogCategory_DNSSEC != mDNSLogCategory_State) {
            break;
          }
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC, OS_LOG_TYPE_FAULT))
          {
            int v20 = *(void *)(v8 + 32);
            if (v20)
            {
              __int16 v21 = *(_BYTE **)(v8 + 32);
              if (v20 == -256)
              {
LABEL_55:
                while (v21)
                {
                  uint64_t v22 = *v21;
                  if (!*v21)
                  {
                    LOWORD(v21) = (_WORD)v21 - v20 + 1;
                    goto LABEL_74;
                  }

                  v21 += v22 + 1;
                  if (v20 != -256) {
                    goto LABEL_54;
                  }
                }
              }

              else
              {
LABEL_54:
              }

              LOWORD(v21) = 257;
LABEL_74:
              LODWORD(v21) = (unsigned __int16)v21;
            }

            else
            {
              LODWORD(v21) = 0;
            }

            int v61 = calloc(1uLL, 0x408uLL);
            if (v61)
            {
              uint64_t v62 = (uint64_t)v61;
              DNSProxyPrepareOmsg(0x1F4u, (uint64_t)v61);
              *(void *)(v62 + 1024) = v22;
              os_retain(v22);
              uint64_t v68 = a4[4];
              *(_OWORD *)(v62 + 8) = *(_OWORD *)a4;
              *(_DWORD *)(v62 + 24) = v68;
              *(_WORD *)(v62 + 28) = v11;
              *(_WORD *)(v62 + 30) = *(_WORD *)a2;
              *(void *)(v62 + 32) = a6;
              *(void *)(v62 + 40) = a1;
              *(_BYTE *)(v62 + 48) = v10;
              *(_WORD *)(v62 + 50) = *((_WORD *)a2 + 1);
              *(void *)(v62 + 72) = a8;
              for (uint64_t i = (int *)v100; i < &v101; uint64_t i = (int *)((char *)i + v70 + 1))
              {
                if (!i) {
                  break;
                }
                int v70 = *(unsigned __int8 *)i;
                if (!*(_BYTE *)i)
                {
                  uint64_t v71 = (_DWORD)i - v100 + 1;
                  if ((unsigned __int16)v71 <= 0x100u)
                  {
                    memcpy((void *)(v62 + 80), v100, (unsigned __int16)v71);
                    goto LABEL_51;
                  }

                  break;
                }
              }

              *(_BYTE *)(v62 + 80) = 0;
LABEL_51:
              if (!v93) {
                goto LABEL_57;
              }
              if (v91 <= 0xA)
              {
                if (mDNS_LoggingEnabled == 1) {
                  LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "ProxyCallbackCommon: Invalid EDNS0 option for pkt from %#a:%d, ignoring this",  v63,  v64,  v65,  v66,  v67,  (int)a4);
                }
                goto LABEL_57;
              }

              *(_WORD *)(v62 + 68) = bswap32(*(unsigned __int16 *)(v93 + 3)) >> 16;
              int v72 = malloc(v91);
              if (v72)
              {
                *(void *)(v62 + 56) = v72;
                memcpy(v72, v93, v91);
                *(_DWORD *)(v62 + 64) = v91;
LABEL_57:
                mDNS_SetupQuestion( v62 + 336,  *(unsigned int *)(*(void *)(v62 + 1024) + 64LL),  v100,  v98,  (uint64_t)ProxyClientCallback,  v62);
                *(_BYTE *)(v62 + 953) = 1;
                *(_BYTE *)(v62 + 951) = 1;
                *(_BYTE *)(v62 + 968) = 1;
                *(_WORD *)(v62 + 662) = 0;
                int v73 = *(void *)(v62 + 1024);
                *(_DWORD *)(v62 + 584) = *(_DWORD *)(v73 + 72);
                uint64_t v74 = *(unsigned __int16 *)(v62 + 658);
                *(_WORD *)(v62 + 992) = v74;
                if (*(_BYTE *)(v73 + 76)) {
                  int v75 = v73 + 24;
                }
                else {
                  int v75 = 0LL;
                }
                if (*(_BYTE *)(v73 + 76))
                {
                  if (v74 == 28)
                  {
                    if (*(_BYTE *)(v73 + 77))
                    {
                      *(_DWORD *)(v62 + 996) = 1;
                      *(_WORD *)(v62 + 658) = 1;
                    }
                  }

                  else if (v74 == 12)
                  {
                    int v95 = 0uLL;
                    __int16 v94 = 0;
                    if (GetReverseIPv6Addr((_BYTE *)(v62 + 80), &v95))
                    {
                      if (nw_nat64_extract_v4(v75, &v95, &v94))
                      {
                        memset(v96, 0, 30);
                        mDNS_snprintf(v96);
                        *(_BYTE *)(v62 + 692) = 0;
                        AppendDNSNameString((_BYTE *)(v62 + 692), (unsigned __int8 *)v96, v76, v77, v78, v79, v80, v81);
                        *(_DWORD *)(v62 + 536) = DomainNameHashValue(v62 + 692);
                        *(_DWORD *)(v62 + 996) = 2;
                      }
                    }
                  }
                }

                __int16 v82 = &DNSProxyClients;
                do
                {
                  uint64_t v83 = v82;
                  __int16 v82 = (uint64_t *)*v82;
                }

                while (v82);
                *uint64_t v83 = v62;
                mDNS_StartQuery((unsigned int *)mDNSStorage, v62 + 336);
                return;
              }
            }

            __break(1u);
          }

          if (mDNS_LoggingEnabled == 1) {
            LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "ProxyCallbackCommon: EDNS0 cannot be parsed for pkt from %#a:%d, ignoring",  v37,  v38,  v39,  v40,  v41,  (int)a4);
          }
        }

        else if (mDNS_LoggingEnabled == 1)
        {
          uint64_t v48 = (os_log_s *)mDNSLogCategory_Default;
          DNSTypeName(v98);
          LogMsgWithLevel( v48,  OS_LOG_TYPE_DEFAULT,  "ProxyCallbackCommon: EDNS0 opt not present in Question %##s (%s), ptr %p",  v49,  v50,  v51,  v52,  v53,  (int)v100);
        }

        int v91 = 0;
        goto LABEL_32;
      }

      if (mDNS_LoggingEnabled) {
        LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "ProxyCallbackCommon: Question cannot be parsed for pkt from %#a:%d",  v23,  v24,  v25,  v26,  v27,  (int)a4);
      }
    }

    int v20 = v11;
    __int16 v21 = 1;
LABEL_25:
    SendError(a1, (uint64_t)a2, a3, a4, v20, a6, v10, a8, v21);
  }

        uint64_t v71 = v20;
      }

      else
      {
        uint64_t v71 = 0;
      }

      uint64_t v74 = *a3 != 240;
      __int16 v26 = *((void *)a3 + 7);
      if (v26)
      {
        if (*(_DWORD *)(v26 + 32) || *(_BYTE *)(v26 + 40)) {
          uint64_t v27 = 0LL;
        }
        else {
          uint64_t v27 = *(void *)(v26 + 48);
        }
        int v73 = v27 != 0;
      }

      else
      {
        int v73 = 0;
      }

      __int16 v28 = bswap32(*(unsigned __int16 *)(a2 + 320));
      unsigned int v29 = *((void *)a3 + 3);
      uint64_t v30 = v29 + 5;
      os_log_t log = (os_log_s *)v17;
      int v31 = HIWORD(v28);
      BOOL v32 = *(unsigned __int16 *)(a2 + 322);
      uint64_t v33 = *((unsigned __int16 *)a3 + 2);
      unint64_t v76 = a3[2];
      uint64_t v78 = *((_DWORD *)a3 + 2);
      int v34 = resource_record_get_actual_ttl(v13, (uint64_t)a3);
      uint64_t v35 = *((void *)a3 + 7);
      if (v35) {
        LODWORD(v35) = *(_DWORD *)(v35 + 32) == 1;
      }
      *(_DWORD *)buf = 67112451;
      *(_DWORD *)uint64_t v86 = v31;
      *(_WORD *)&v86[4] = 2160;
      *(void *)&v86[6] = 1752392040LL;
      *(_WORD *)&v86[14] = 1040;
      *(_DWORD *)&v86[16] = v71;
      *(_WORD *)uint64_t v87 = 2101;
      *(void *)&v87[2] = v18;
      *(_WORD *)uint64_t v88 = 1024;
      *(_DWORD *)&v88[2] = v32;
      LOWORD(v89) = 1024;
      *(_DWORD *)((char *)&v89 + 2) = v33;
      HIWORD(v89) = 1024;
      uint64_t v90 = v74;
      int v91 = 1024;
      unint64_t v92 = v73;
      int v93 = 1024;
      __int16 v94 = a4;
      int v95 = 1024;
      int v96 = v29;
      BOOL v97 = 1024;
      BOOL v98 = v76;
      BOOL v99 = 1024;
      unint64_t v100 = v78;
      uint64_t v101 = 1024;
      uint64_t v102 = v34;
      uint64_t v103 = 1024;
      size_t v104 = v35;
      _os_log_impl( (void *)&_mh_execute_header,  log,  OS_LOG_TYPE_INFO,  "[Q%u] DNSSEC record changes - qname: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P, qtype: %{mdns:rrtype }d, rrtype: %{mdns:rrtype}d, %{mdns:pos/neg}d, contains denial: %{mdns:yesno}d, %{mdns:addrmv}d, interface index : %d, motality: %{mdns:mortality}d, original ttl: %u, actual ttl: %u, validated: %{mdns:yesno}d.",  buf,  0x5Eu);
      unsigned int v9 = (void *)&unk_100164000;
      uint64_t v8 = (void *)&unk_100158000;
      unsigned __int16 v7 = (_BYTE *)&unk_100164000;
    }
  }

  uint64_t v46 = *((void *)a3 + 7);
  if (v46)
  {
    unsigned int v47 = *(_DWORD *)(v46 + 32);
    if (v47)
    {
      if (v47 == 1 && (v84 || *a3 != 240 && (*((_WORD *)a3 + 2) != 5 || *(_WORD *)(a2 + 322) == 5))) {
        v83(v13, a2, a3, a4);
      }
      return;
    }

    uint64_t v48 = *(void *)(v11 + 64);
    if ((_DWORD)a4 != 1)
    {
      dnssec_obj_validation_manager_remove_validated_cache(*(void *)(v11 + 64));
      uint64_t v51 = *(void *)(v11 + 64);
      if (*a3 == 240) {
        uint64_t v52 = 40LL;
      }
      else {
        uint64_t v52 = 32LL;
      }
      uint64_t v53 = *(void *)(v51 + v52);
      if (!v53) {
        goto LABEL_140;
      }
      uint64_t v54 = dnssec_obj_rrset_remove_rr(v53, a3);
      if (!v54)
      {
        uint64_t v55 = *(void **)(v51 + v52);
        if (!v55[4] && v55)
        {
          ref_count_obj_release(v55);
          *(void *)(v51 + v52) = 0LL;
        }

        *(void *)(v51 + 48) = 0xFFFFE5C200000000LL;
        *(_DWORD *)(v51 + 140) = 0;
        *(_BYTE *)(v51 + 144) = 0;
        if (*((_WORD *)a3 + 2) == 46) {
          *(_BYTE *)(v51 + 72) = 1;
        }
        goto LABEL_106;
      }

      if (v54 == -6727)
      {
LABEL_140:
        uint64_t v58 = v8[345];
        if (v7[1384] != 1 || v58 == v9[171])
        {
          if (!os_log_type_enabled((os_log_t)v8[345], OS_LOG_TYPE_DEBUG)) {
            return;
          }
        }

        else
        {
          uint64_t v58 = mDNSLogCategory_DNSSEC_redacted;
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC_redacted, OS_LOG_TYPE_DEBUG)) {
            return;
          }
        }

        uint64_t v69 = bswap32(*(unsigned __int16 *)(a2 + 320)) >> 16;
        *(_DWORD *)buf = 67109120;
        *(_DWORD *)uint64_t v86 = v69;
        uint64_t v60 = "[Q%u] Added record not found due to possible primary DNSSEC question change";
        goto LABEL_110;
      }

      int v70 = v54;
      uint64_t v64 = v8[345];
      if (v7[1384] != 1 || v64 == v9[171])
      {
        if (!os_log_type_enabled((os_log_t)v8[345], OS_LOG_TYPE_FAULT)) {
          return;
        }
      }

      else
      {
        uint64_t v64 = mDNSLogCategory_DNSSEC_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC_redacted, OS_LOG_TYPE_FAULT)) {
          return;
        }
      }

      *(_DWORD *)buf = 136447234;
      *(void *)uint64_t v86 = "err == 0";
      *(_WORD *)&v86[8] = 2082;
      *(void *)&v86[10] = "";
      *(_WORD *)&v86[18] = 2082;
      *(void *)uint64_t v87 = "/Library/Caches/com.apple.xbs/Sources/mDNSResponder/mDNSMacOSX/dnssec_v2/dnssec.c";
      *(_WORD *)&v87[8] = 1024;
      *(_DWORD *)uint64_t v88 = 207;
      *(_WORD *)&v88[4] = 2048;
      uint64_t v89 = v70;
      uint64_t v60 = "AssertMacros: %{public}s, %{public}s file: %{public}s, line: %d, value: %ld";
LABEL_138:
      int v61 = (os_log_s *)v64;
      uint64_t v62 = OS_LOG_TYPE_FAULT;
      int v63 = 48;
      goto LABEL_111;
    }

    *(_DWORD *)buf = 0;
    int v49 = 32LL;
    if (*a3 == 240) {
      int v49 = 40LL;
    }
    int v50 = *(void **)(v48 + v49);
    if (v50)
    {
      ++*(_DWORD *)v50;
    }

    else
    {
      int v50 = dnssec_obj_rrset_create(*(_DWORD **)(v48 + 16), *(_DWORD *)(v48 + 136), buf);
      if (*(_DWORD *)buf)
      {
LABEL_100:
        ref_count_obj_release(v50);
        uint64_t v57 = *(int *)buf;
        if (*(_DWORD *)buf == -6730)
        {
          uint64_t v58 = v8[345];
          if (v7[1384] != 1 || v58 == v9[171])
          {
            if (!os_log_type_enabled((os_log_t)v8[345], OS_LOG_TYPE_DEBUG)) {
              return;
            }
          }

          else
          {
            uint64_t v58 = mDNSLogCategory_DNSSEC_redacted;
            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC_redacted, OS_LOG_TYPE_DEBUG)) {
              return;
            }
          }

          uint64_t v59 = bswap32(*(unsigned __int16 *)(a2 + 320)) >> 16;
          *(_DWORD *)buf = 67109120;
          *(_DWORD *)uint64_t v86 = v59;
          uint64_t v60 = "[Q%u] Getting duplicate record add event due to possible primary DNSSEC question change";
LABEL_110:
          int v61 = (os_log_s *)v58;
          uint64_t v62 = OS_LOG_TYPE_DEBUG;
          int v63 = 8;
LABEL_111:
          _os_log_impl((void *)&_mh_execute_header, v61, v62, v60, buf, v63);
          return;
        }

        if (!*(_DWORD *)buf)
        {
LABEL_106:
          _dnssec_fetch_key_records(v11);
          _dnssec_make_validation_progress(*(void *)(v11 + 64));
          _dnssec_fetch_key_records(v11);
          return;
        }

        uint64_t v64 = v8[345];
        if (v7[1384] != 1 || v64 == v9[171])
        {
          if (!os_log_type_enabled((os_log_t)v8[345], OS_LOG_TYPE_FAULT)) {
            return;
          }
        }

        else
        {
          uint64_t v64 = mDNSLogCategory_DNSSEC_redacted;
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC_redacted, OS_LOG_TYPE_FAULT)) {
            return;
          }
        }

        *(_DWORD *)buf = 136447234;
        *(void *)uint64_t v86 = "err == 0";
        *(_WORD *)&v86[8] = 2082;
        *(void *)&v86[10] = "";
        *(_WORD *)&v86[18] = 2082;
        *(void *)uint64_t v87 = "/Library/Caches/com.apple.xbs/Sources/mDNSResponder/mDNSMacOSX/dnssec_v2/dnssec.c";
        *(_WORD *)&v87[8] = 1024;
        *(_DWORD *)uint64_t v88 = 193;
        *(_WORD *)&v88[4] = 2048;
        uint64_t v89 = v57;
        uint64_t v60 = "AssertMacros: %{public}s, %{public}s file: %{public}s, line: %d, value: %ld";
        goto LABEL_138;
      }
    }

    *(_DWORD *)buf = dnssec_obj_rrset_add_rr((uint64_t)v50, a3);
    if (!*(_DWORD *)buf)
    {
      if (*a3 == 240) {
        uint64_t v56 = (void *)(v48 + 40);
      }
      else {
        uint64_t v56 = (void *)(v48 + 32);
      }
      if (!*v56)
      {
        _BYTE *v56 = v50;
        ++*(_DWORD *)v50;
      }

      *(void *)(v48 + 48) = 0xFFFFE5C200000000LL;
      *(_DWORD *)(v48 + 140) = 0;
      *(_BYTE *)(v48 + 144) = 0;
      *(_DWORD *)buf = 0;
    }

    goto LABEL_100;
  }

unint64_t DomainNameHashValue(unint64_t result)
{
  int v1 = *(unsigned __int8 *)result;
  if (!*(_BYTE *)result) {
    return 0LL;
  }
  unint64_t v2 = result;
  LODWORD(result) = 0;
  for (uint64_t i = (unsigned __int8 *)(v2 + 2); ; i += 2)
  {
    int v4 = *(i - 1);
    unsigned int v5 = v1 - 65;
    int v6 = v1 << 8;
    if (v5 < 0x1A) {
      v6 += 0x2000;
    }
    if (!*(i - 1)) {
      break;
    }
    HIDWORD(v7) = (v4 | v6) + result;
    LODWORD(v7) = HIDWORD(v7);
    uint64_t result = (v7 >> 29);
    int v8 = *i;
    int v1 = v8;
    if (!v8) {
      return result;
    }
  }

  return (v6 + result);
}

unint64_t RDataHashValue(uint64_t a1)
{
  unint64_t result = 0LL;
  int v3 = *(unsigned __int16 *)(a1 + 12);
  uint64_t v4 = *(void *)(a1 + 40);
  unint64_t v5 = v4 + 4;
  switch(*(_WORD *)(a1 + 4))
  {
    case 2:
    case 3:
    case 4:
    case 5:
    case 7:
    case 8:
    case 9:
    case 0xC:
    case 0x17:
    case 0x27:
      unint64_t v6 = v4 + 4;
      return DomainNameHashValue(v6);
    case 6:
      int32x4_t v19 = *(int32x4_t *)(v4 + 516);
      int v9 = *(_DWORD *)(v4 + 532);
      int v10 = DomainNameHashValue(v4 + 4);
      return vaddvq_s32(v19) + v9 + DomainNameHashValue(v4 + 260) + v10;
    case 0xE:
    case 0x11:
      int v7 = DomainNameHashValue(v4 + 4);
      unint64_t v8 = v4 + 260;
      return DomainNameHashValue(v8) + v7;
    case 0xF:
    case 0x12:
    case 0x15:
    case 0x24:
      unint64_t v6 = v4 + 6;
      return DomainNameHashValue(v6);
    case 0x1A:
      int v7 = DomainNameHashValue(v4 + 6);
      unint64_t v8 = v4 + 262;
      return DomainNameHashValue(v8) + v7;
    case 0x21:
      unint64_t v6 = v4 + 10;
      return DomainNameHashValue(v6);
    case 0x29:
      return result;
    case 0x2F:
      unint64_t v11 = v4 + 260;
      BOOL v12 = (_BYTE *)(v4 + 4);
      if (v4 != -260) {
        goto LABEL_11;
      }
      break;
    default:
      goto LABEL_22;
  }

LABEL_14:
  if (v12)
  {
    while (1)
    {
      uint64_t v14 = *v12;
      if (!*v12)
      {
        unsigned __int16 v13 = (_WORD)v12 - v5 + 1;
        goto LABEL_21;
      }

      v12 += v14 + 1;
      if (!v11) {
        goto LABEL_14;
      }
LABEL_11:
      unsigned __int16 v13 = 257;
    }
  }

  unsigned __int16 v13 = 257;
LABEL_21:
  unint64_t result = DomainNameHashValue(v5);
  v5 += v13;
  v3 -= v13;
LABEL_22:
  if (v3 < 2)
  {
    unsigned int v18 = 0;
  }

  else
  {
    uint64_t v15 = 0LL;
    do
    {
      HIDWORD(v16) = result + (bswap32(*(unsigned __int16 *)(v5 + v15)) >> 16);
      LODWORD(v16) = HIDWORD(v16);
      unint64_t result = (v16 >> 29);
      unint64_t v17 = v15 + 3;
      v15 += 2LL;
    }

    while (v17 < v3);
    unsigned int v18 = v3 & 0xFFFFFFFE;
  }

  return result;
}

  unsigned int v18 = (unsigned int *)&v16[v17];
  if (v16) {
    int32x4_t v19 = (unint64_t)v18 > v7;
  }
  else {
    int32x4_t v19 = 1;
  }
  if (v19)
  {
    unsigned int v18 = 0LL;
    __int16 v21 = 0LL;
  }

  else
  {
    __int16 v21 = v16;
  }

  *(void *)(a1 + 72) = v18;
  uint64_t v22 = 0;
  if (a2)
  {
    int v23 = 0LL;
    if (v18 && (unint64_t)(v18 + 1) <= v7)
    {
      uint64_t v22 = bswap32(*v18);
      int v23 = v18 + 1;
    }

    *(void *)(a1 + 72) = v23;
    unsigned int v18 = v23;
  }

  *(_DWORD *)(a1 + 232) = v10;
  *(_DWORD *)(a1 + 236) = v26;
  if ((v13 & 1) == 0)
  {
    __int16 v24 = (os_log_s *)mDNSLogCategory_Default;
    unsigned __int16 v25 = "ERROR: read_rr_from_ipc_msg - get_string";
    goto LABEL_48;
  }

  if (!v18)
  {
    __int16 v24 = (os_log_s *)mDNSLogCategory_Default;
    unsigned __int16 v25 = "Error reading Resource Record from client";
    goto LABEL_48;
  }

  if (a3 && (v10 & 0x10) == 0 && (v10 & 0x20) == 0 && (v10 & 0x800) == 0)
  {
    __int16 v24 = (os_log_s *)mDNSLogCategory_Default;
    unsigned __int16 v25 = "ERROR: Bad resource record flags (must be one of either kDNSServiceFlagsShared, kDNSServiceFlagsUnique or kDNS"
          "ServiceFlagsKnownUnique)";
LABEL_48:
    LogMsgWithLevel(v24, OS_LOG_TYPE_DEFAULT, v25, v30, v31, v32, v33, v34, v76);
    return 0LL;
  }

  uint64_t v77 = v15;
  uint64_t v40 = mDNSPlatformInterfaceIDfromInterfaceIndex(v26, v28, v29, v30, v31, v32, v33, v34);
  if ((_DWORD)v26) {
    uint64_t v41 = v40 == 0;
  }
  else {
    uint64_t v41 = 0;
  }
  if (v41) {
    __int16 v26 = v26;
  }
  else {
    __int16 v26 = v40;
  }
  else {
    uint64_t v42 = v17;
  }
  int v43 = calloc(1uLL, v42 + 912);
  if (!v43) {
    __break(1u);
  }
  BOOL v38 = v43;
  if (v26 == -2)
  {
    int v44 = 4;
  }

  else
  {
    int v44 = 5;
    if (v26 != -5 && v26 != -3)
    {
      char v45 = (v10 & 0x20000) != 0 && v26 == 0;
      uint64_t v46 = !v45;
      unsigned int v47 = (v10 & 0x100000) == 0 || v46;
      int v44 = v47 ? 1 : 3;
      if (v46)
      {
        if ((v10 & 0x100000) != 0 && v26 == 0) {
          int v44 = 2;
        }
        else {
          int v44 = 0;
        }
      }
    }
  }

  if ((v10 & 0x800) != 0) {
    int v49 = 32;
  }
  else {
    int v49 = 2;
  }
  if ((v10 & 0x10) != 0) {
    int v50 = 8;
  }
  else {
    int v50 = v49;
  }
  mDNS_SetupResourceRecord((uint64_t)v43, 0LL, v26, v77, 0, v50, v44, 0LL, 0LL);
  *((_BYTE *)v38 + 652) = 0;
  if (!AppendDNSNameString((_BYTE *)v38 + 652, &v88, v51, v52, v53, v54, v55, v56))
  {
    LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "ERROR: bad name: %s",  v57,  v58,  v59,  v60,  v61,  (int)&v88);
    goto LABEL_128;
  }

  if ((v10 & 0x200) != 0) {
    *((_BYTE *)v38 + 121) = 1;
  }
  *((_WORD *)v38 + 7) = v14;
  *((_WORD *)v38 + 10) = v17;
  **((_WORD **)v38 + 6) = v42;
  if (!SetRData(0LL, v21, (unint64_t)&v21[v17], (uint64_t)v38 + 8, v17, v59, v60, v61))
  {
    int v67 = (os_log_s *)mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_ERROR))
      {
        uint64_t v68 = *(_DWORD *)(a1 + 184);
        uint64_t v69 = *((void *)v38 + 5);
        if (v69)
        {
          int v73 = (_BYTE *)*((void *)v38 + 5);
          uint64_t v71 = v77;
          if (v69 == -256)
          {
LABEL_116:
            while (v73)
            {
              uint64_t v74 = *v73;
              if (!*v73)
              {
                int v75 = (unsigned __int16)((_WORD)v73 - v69 + 1);
                goto LABEL_127;
              }

              v73 += v74 + 1;
              if (v69 != -256) {
                goto LABEL_115;
              }
            }
          }

          else
          {
LABEL_115:
          }

          int v75 = 257;
        }

        else
        {
          int v75 = 0;
          uint64_t v71 = v77;
        }

        goto LABEL_127;
      }
    }

    else
    {
      int v67 = (os_log_s *)mDNSLogCategory_Default_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_ERROR))
      {
        uint64_t v68 = *(_DWORD *)(a1 + 184);
        uint64_t v69 = *((void *)v38 + 5);
        if (v69)
        {
          int v70 = (_BYTE *)*((void *)v38 + 5);
          uint64_t v71 = v77;
          if (v69 == -256)
          {
LABEL_107:
            while (v70)
            {
              int v72 = *v70;
              if (!*v70)
              {
                int v75 = (unsigned __int16)((_WORD)v70 - v69 + 1);
                goto LABEL_127;
              }

              v70 += v72 + 1;
              if (v69 != -256) {
                goto LABEL_106;
              }
            }
          }

          else
          {
LABEL_106:
          }

          int v75 = 257;
        }

        else
        {
          int v75 = 0;
          uint64_t v71 = v77;
        }

  if (v11 < v10 + 256) {
    goto LABEL_15;
  }
LABEL_20:
  unsigned __int16 v13 = (_BYTE *)(a2 + 1188);
LABEL_21:
  *unsigned __int16 v13 = 0;
LABEL_22:
  AppendDomainName(v13, (_BYTE *)(a2 + 272));
LABEL_23:
  *(_DWORD *)(a2 + 1044) = -1;
  *(void *)(a2 + 968) = 0LL;
  *(_DWORD *)(a2 + 1136) = 0;
  *(_WORD *)(a2 + 1154) = v3;
  *(_WORD *)(a2 + 1156) = 1;
  *(_DWORD *)(a2 + 1444) = 16777472;
  *(_WORD *)(a2 + 1448) = 0;
  *(_BYTE *)(a2 + 1453) = 0;
  *(_WORD *)(a2 + 1451) = 0;
  *(_BYTE *)(a2 + 1464) = 0;
  *(_DWORD *)(a2 + 1076) = getpid();
  *(_DWORD *)(a2 + 1080) = 0;
  *(void *)(a2 + 984) = GetZoneData_QuestionCallback;
  *(void *)(a2 + 1008) = a2;
  return mDNS_StartQuery(a1, a2 + 832);
}

  mDNS_VerifyLockState( "Check Lock",  1,  *(_DWORD *)(a1 + 48),  *(_DWORD *)(a1 + 52),  (uint64_t)"SendRecordRegistration",  2994);
  int v9 = *(void *)(a2 + 376);
  if (!v9 || !*(_DWORD *)(v9 + 792))
  {
    uint64_t v37 = (os_log_s *)mDNSLogCategory_Default;
    GetRRDisplayString_rdb(v4, (unsigned __int16 *)(*(void *)(a2 + 48) + 4LL), (_BYTE *)(a1 + 46976));
    LogMsgWithLevel( v37,  OS_LOG_TYPE_DEFAULT,  "SendRecordRegistration: No Zone information, should not happen %s",  v38,  v39,  v40,  v41,  v42,  a1 + 46976);
    return;
  }

  int v10 = a1 + 37856 + v7;
  unint64_t v11 = mDNS_NewMessageID(a1);
  *(_WORD *)(a2 + 358) = v11;
  *(_WORD *)(a1 + 28904) = v11;
  *(_WORD *)(a1 + 28906) = 40;
  *(void *)(a1 + 28908) = 0LL;
  uint64_t v15 = putZone( a1 + 28904,  a1 + 28916,  v10,  *(unsigned __int8 **)(a2 + 368),  bswap32(*(unsigned __int16 *)(a2 + 14)) >> 16,  v12,  v13,  v14);
  if (!v15
    || (updated = BuildUpdateMessage(a1, (unint64_t)v15, a2, v10, v16, v17, v18, v19)) == 0
    || (__int16 v21 = updated, *(_BYTE *)(a2 + 348)) && (__int16 v21 = putUpdateLeaseWithLimit(a1 + 28904, updated, v10)) == 0)
  {
    int v43 = (os_log_s *)mDNSLogCategory_Default;
    int v44 = (_BYTE *)(a1 + 46976);
    GetRRDisplayString_rdb(v4, (unsigned __int16 *)(*(void *)(a2 + 48) + 4LL), v44);
    LogMsgWithLevel( v43,  OS_LOG_TYPE_DEFAULT,  "SendRecordRegistration: Error formatting message for %s, disabling further updates",  v45,  v46,  v47,  v48,  v49,  (int)v44);
    *(_DWORD *)(a2 + 344) = 8;
    return;
  }

  if (*(_BYTE *)(a2 + 356))
  {
    if ((mDNS_LoggingEnabled & 1) != 0)
    {
      uint64_t v22 = (os_log_s *)mDNSLogCategory_Default;
      int v23 = (uint64_t *)(a2 + 384);
      __int16 v24 = *(void *)(a2 + 384);
      GetRRDisplayString_rdb(v4, (unsigned __int16 *)(*(void *)(a2 + 48) + 4LL), (_BYTE *)(a1 + 46976));
      LogMsgWithLevel(v22, OS_LOG_TYPE_DEFAULT, "SendRecordRegistration TCP %p %s", v25, v26, v27, v28, v29, v24);
      uint64_t v30 = *(void *)(a2 + 384);
      if (!v30 || !mDNS_LoggingEnabled)
      {
LABEL_33:
        if (v30)
        {
          DisposeTCPConn(v30);
          *int v23 = 0LL;
        }

        uint64_t v58 = *(void *)(a2 + 376);
        if (v58)
        {
          *(void *)(a2 + 384) = MakeTCPConn( a1,  (const void *)(a1 + 28904),  v21,  1LL,  (int *)(v58 + 788),  *(unsigned __int16 *)(v58 + 786),  (_BYTE *)(v58 + 530),  0LL,  a2);
          goto LABEL_37;
        }

        uint64_t v59 = (os_log_s *)mDNSLogCategory_Default;
        GetRRDisplayString_rdb(v4, (unsigned __int16 *)(*(void *)(a2 + 48) + 4LL), (_BYTE *)(a1 + 46976));
        LogMsgWithLevel( v59,  OS_LOG_TYPE_DEFAULT,  "SendRecordRegistration:Private:ERROR!! nta is NULL for %s",  v60,  v61,  v62,  v63,  v64,  a1 + 46976);
        return;
      }

      int v31 = (os_log_s *)mDNSLogCategory_Default;
      GetRRDisplayString_rdb(v4, (unsigned __int16 *)(*(void *)(a2 + 48) + 4LL), (_BYTE *)(a1 + 46976));
      LogMsgWithLevel( v31,  OS_LOG_TYPE_DEFAULT,  "SendRecordRegistration: Disposing existing TCP connection for %s",  v32,  v33,  v34,  v35,  v36,  a1 + 46976);
    }

    else
    {
      int v23 = (uint64_t *)(a2 + 384);
    }

    uint64_t v30 = *v23;
    goto LABEL_33;
  }

  if (mDNS_LoggingEnabled)
  {
    int v50 = (os_log_s *)mDNSLogCategory_Default;
    GetRRDisplayString_rdb(v4, (unsigned __int16 *)(*(void *)(a2 + 48) + 4LL), (_BYTE *)(a1 + 46976));
    LogMsgWithLevel(v50, OS_LOG_TYPE_DEFAULT, "SendRecordRegistration UDP %s", v51, v52, v53, v54, v55, a1 + 46976);
  }

  uint64_t v56 = *(void *)(a2 + 376);
  if (v56)
  {
    uint64_t v57 = GetAuthInfoForName_internal(a1, *(_BYTE **)(a2 + 40));
    mDNSSendDNSMessage(a1, a1 + 28904, v21, 0LL, 0LL, 0LL, (int *)(v56 + 788), *(_WORD *)(v56 + 786), v57, 0);
LABEL_37:
    SetRecordRetry(a1, a2, 0);
    return;
  }

  uint64_t v65 = (os_log_s *)mDNSLogCategory_Default;
  GetRRDisplayString_rdb(v4, (unsigned __int16 *)(*(void *)(a2 + 48) + 4LL), (_BYTE *)(a1 + 46976));
  LogMsgWithLevel( v65,  OS_LOG_TYPE_DEFAULT,  "SendRecordRegistration:ERROR!! nta is NULL for %s",  v66,  v67,  v68,  v69,  v70,  a1 + 46976);
}

  if (*(_BYTE *)(a1 + 12))
  {
    LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "GetFreeCacheRR ERROR! Cache already locked!",  v4,  v5,  v6,  v7,  v8,  v52);
    uint64_t v14 = (os_log_s *)mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
      {
        unint64_t v16 = *(void *)(a2 + 40);
        if (v16)
        {
          unint64_t v17 = *(_BYTE **)(a2 + 40);
          if (v16 == -256)
          {
LABEL_24:
            while (v17)
            {
              unsigned int v18 = *v17;
              if (!*v17)
              {
                uint64_t v42 = (unsigned __int16)((_WORD)v17 - v16 + 1);
                goto LABEL_94;
              }

              v17 += v18 + 1;
              if (v16 != -256) {
                goto LABEL_23;
              }
            }
          }

          else
          {
LABEL_23:
          }

          uint64_t v42 = 257;
        }

        else
        {
          uint64_t v42 = 0;
        }

        goto LABEL_94;
      }

      return 0LL;
    }

  if (a2)
  {
    if (*(_BYTE *)(a1 + 141)) {
      return;
    }
    mDNS_Lock_((unsigned int *)a1, (uint64_t)"mDNSCoreMachineSleep", 8244);
    if (*(void *)(a1 + 15048))
    {
      unint64_t v11 = v4[5];
      BOOL v12 = *(_DWORD *)(a1 + 48);
      unsigned __int16 v13 = *(_DWORD *)(a1 + 52) + 1;
      *(_DWORD *)(a1 + 52) = v13;
      mDNS_VerifyLockState("Drop Lock", 0, v12, v13, (uint64_t)"mDNSCoreMachineSleep", 8249);
      v4[5] = 2;
      if (v11 == 1) {
        mDNS_DeregisterService_drt((unsigned int *)a1, a1 + 15056, 0, v14, v15, v16, v17, v18);
      }
      mDNS_VerifyLockState( "Reclaim Lock",  0,  *(_DWORD *)(a1 + 48),  *(_DWORD *)(a1 + 52),  (uint64_t)"mDNSCoreMachineSleep",  8256);
      --*(_DWORD *)(a1 + 52);
    }

    int32x4_t v19 = *(void **)(a1 + 14952);
    if (v19)
    {
      CloseSocketSet(*(void *)(a1 + 14952));
      free(v19);
      *(void *)(a1 + 14952) = 0LL;
    }

    *(_BYTE *)(a1 + 141) = 1;
    if (!*(_BYTE *)(a1 + 143) || (int v20 = *(_DWORD *)(a1 + 152)) == 0)
    {
      uint64_t v59 = *(_DWORD *)(a1 + 64) + 10000;
      if (v59 <= 1) {
        uint64_t v59 = 1;
      }
      *(_DWORD *)(a1 + 152) = 0;
      *(_DWORD *)(a1 + 156) = v59;
      ++*((_DWORD *)v4 + 1218);
      DNSServiceManager = Querier_GetDNSServiceManager();
      if (DNSServiceManager)
      {
        mdns_dns_service_manager_enumerate(DNSServiceManager, (uint64_t)&__block_literal_global_47);
        if (_mdns_resolver_queue_s_once != -1) {
          dispatch_once(&_mdns_resolver_queue_s_once, &__block_literal_global_138);
        }
        dispatch_async((dispatch_queue_t)_mdns_resolver_queue_s_queue, &__block_literal_global_4776);
      }

      BeginSleepProcessing(a1);
LABEL_125:
      int v63 = (os_log_s *)mDNSLogCategory_Default;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
      {
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v64 = "?";
          int v67 = *(unsigned __int8 *)(a1 + 141);
          if (v67 == 2) {
            uint64_t v64 = "Sleeping";
          }
          uint64_t v66 = *(unsigned __int8 *)(a1 + 142);
          *(_DWORD *)buf = 67109634;
          *(_DWORD *)&uint8_t buf[4] = v67;
          if (v67 == 1) {
            uint64_t v64 = "Transferring";
          }
          goto LABEL_138;
        }
      }

      else
      {
        int v63 = (os_log_s *)mDNSLogCategory_Default_redacted;
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v64 = "?";
          uint64_t v65 = *(unsigned __int8 *)(a1 + 141);
          if (v65 == 2) {
            uint64_t v64 = "Sleeping";
          }
          uint64_t v66 = *(unsigned __int8 *)(a1 + 142);
          *(_DWORD *)buf = 67109634;
          *(_DWORD *)&uint8_t buf[4] = v65;
          if (v65 == 1) {
            uint64_t v64 = "Transferring";
          }
LABEL_138:
          *(_WORD *)&buf[8] = 2082;
          *(void *)&buf[10] = v64;
          *(_WORD *)&buf[18] = 1024;
          *(_DWORD *)&buf[20] = v66;
          _os_log_impl( (void *)&_mh_execute_header,  v63,  OS_LOG_TYPE_DEBUG,  "mDNSCoreMachineSleep: m->SleepState %d (%{public}s) seq %d",  buf,  0x18u);
        }
      }

      uint64_t v57 = a1;
      uint64_t v58 = 8292;
      goto LABEL_140;
    }

    __int16 v21 = (os_log_s *)mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEBUG))
      {
        int v61 = v20 - *(_DWORD *)(a1 + 64);
        *(_DWORD *)buf = 67109120;
        *(_DWORD *)&uint8_t buf[4] = v61;
        goto LABEL_121;
      }
    }

    else
    {
      __int16 v21 = (os_log_s *)mDNSLogCategory_Default_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v22 = v20 - *(_DWORD *)(a1 + 64);
        *(_DWORD *)buf = 67109120;
        *(_DWORD *)&uint8_t buf[4] = v22;
LABEL_121:
        _os_log_impl( (void *)&_mh_execute_header,  v21,  OS_LOG_TYPE_DEBUG,  "mDNSCoreMachineSleep: Re-sleeping immediately after waking; will delay for %d ticks",
          buf,
          8u);
      }
    }

    uint64_t v62 = *(_DWORD *)(a1 + 152) + 10000;
    if (v62 <= 1) {
      uint64_t v62 = 1;
    }
    *(_DWORD *)(a1 + 156) = v62;
    goto LABEL_125;
  }

  mDNS_Lock_((unsigned int *)a1, (uint64_t)"mDNSCoreMachineSleep", 8301);
  *(_DWORD *)(a1 + 156) = 0;
  if (*(_BYTE *)(a1 + 141))
  {
    *(_BYTE *)(a1 + 141) = 0;
    ++*(_BYTE *)(a1 + 142);
    if (*(_BYTE *)(a1 + 144))
    {
      *(_BYTE *)(a1 + 144) = 0;
      __int16 v28 = *(_DWORD *)(a1 + 64) + 60000;
      if (v28 <= 1) {
        __int16 v28 = 1;
      }
      *(_DWORD *)(a1 + 148) = v28;
      if (mDNS_LoggingEnabled == 1) {
        LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "mDNSCoreMachineSleep: Waking, Setting AnnounceOwner",  v23,  v24,  v25,  v26,  v27,  v68);
      }
    }

    unsigned int v29 = *(_DWORD *)(a1 + 64) + 5000;
    if (v29 <= 1) {
      unsigned int v29 = 1;
    }
    *(_DWORD *)(a1 + 152) = v29;
  }

  if (v4[5] == 3)
  {
    v4[5] = 0;
    mDNSCoreBeSleepProxyServer_internal(a1, *v4, v4[1], v4[2], v4[3], v4[4]);
  }

  ++*((_DWORD *)v4 + 1219);
  uint64_t v30 = *(uint64_t **)(a1 + 12664);
  if (v30)
  {
    while (!*((_BYTE *)v30 + 16))
    {
      uint64_t v30 = (uint64_t *)*v30;
      if (!v30) {
        goto LABEL_42;
      }
    }

  unint64_t v11 = *(void *)(a1 + 32);
  if (v9 == 240)
  {
    if (v11 != 1) {
      return 4294960587LL;
    }
  }

  else if (!v11)
  {
    return 4294960587LL;
  }

  if (!*(_DWORD *)(a1 + 40)) {
    return 4294960587LL;
  }
  *uint64_t v4 = v3[1];
  free(v3);
  *(_DWORD *)(a1 + 40) = 3;
  uint64_t v14 = *(void *)(a1 + 32) - 1LL;
  *(void *)(a1 + 32) = v14;
  uint64_t v15 = *((void *)a2 + 7);
  if (v9 == 240)
  {
    *(_DWORD *)(a1 + 40) = 4;
    if (!v15) {
      return 0LL;
    }
  }

  else if (*(_BYTE *)(v15 + 36) && v14 == *(void *)(v15 + 24))
  {
    *(_DWORD *)(a1 + 40) = 4;
  }

  if (*(_DWORD *)(v15 + 32)) {
    return 0LL;
  }
  unint64_t result = 0LL;
  *(void *)(a1 + 44) = 0xFFFFE5C200000000LL;
  return result;
}

  nw_release(v5);
  uint64_t v14 = v7[3];
LABEL_15:
  *(void *)(*(void *)(a1[4] + 8LL) + 24LL) = v14;
}

              if (SCError())
              {
                int v10 = SCError();
                if (!v10)
                {
LABEL_19:
                  _mdns_start_interface_availability_monitoring_s_store = (uint64_t)v3;
LABEL_42:
                  if (NetworkInterface) {
                    CFRelease(NetworkInterface);
                  }
                  if (v8) {
                    CFRelease(v8);
                  }
                  goto LABEL_46;
                }

                unsigned int v18 = v10;
              }

              else
              {
                unsigned int v18 = -6700;
              }

              if (_mdns_ifmon_log_s_once != -1) {
                dispatch_once(&_mdns_ifmon_log_s_once, &__block_literal_global_1442);
              }
              unint64_t v16 = (os_log_s *)_mdns_ifmon_log_s_log;
              if (!os_log_type_enabled((os_log_t)_mdns_ifmon_log_s_log, OS_LOG_TYPE_ERROR)) {
                goto LABEL_40;
              }
              LODWORD(buf) = 134217984;
              *(void *)((char *)&buf + 4) = v18;
              unint64_t v17 = "Failed to set dispatch queue for interface availability monitoring: %{mdns:err}ld";
              goto LABEL_72;
            }

            if (_mdns_ifmon_log_s_once != -1) {
              dispatch_once(&_mdns_ifmon_log_s_once, &__block_literal_global_1442);
            }
            uint64_t v39 = _mdns_ifmon_log_s_log;
            if (os_log_type_enabled((os_log_t)_mdns_ifmon_log_s_log, OS_LOG_TYPE_ERROR))
            {
              LOWORD(buf) = 0;
              uint64_t v36 = "Failed to create notification keys array for interface availability monitoring";
              uint64_t v37 = (os_log_s *)v39;
              BOOL v38 = 2;
              goto LABEL_70;
            }

            goto LABEL_29;
          }

          unsigned __int16 v13 = v6;
        }

        else
        {
          unsigned __int16 v13 = -6700;
        }

        if (_mdns_ifmon_log_s_once != -1) {
          dispatch_once(&_mdns_ifmon_log_s_once, &__block_literal_global_1442);
        }
        uint64_t v14 = _mdns_ifmon_log_s_log;
        if (os_log_type_enabled((os_log_t)_mdns_ifmon_log_s_log, OS_LOG_TYPE_ERROR))
        {
          LODWORD(buf) = 134217984;
          *(void *)((char *)&buf + 4) = v13;
          uint64_t v36 = "Failed to create interfaces state key for interface availability monitoring: %{mdns:err}ld";
          uint64_t v37 = (os_log_s *)v14;
          BOOL v38 = 12;
LABEL_70:
          _os_log_error_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_ERROR, v36, (uint8_t *)&buf, v38);
        }

  os_release((void *)v2);
}

void SetTargetToHostName(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = 0LL;
  unsigned int v5 = *(unsigned __int16 *)(a2 + 12);
  if (v5 > 0x20)
  {
    switch(v5)
    {
      case '!':
        uint64_t v4 = (_BYTE *)(*(void *)(a2 + 48) + 10LL);
        break;
      case '$':
LABEL_7:
        uint64_t v4 = (_BYTE *)(*(void *)(a2 + 48) + 6LL);
        break;
      case '\'':
LABEL_13:
        uint64_t v4 = (_BYTE *)(*(void *)(a2 + 48) + 4LL);
        break;
    }
  }

  else
  {
    switch(*(_WORD *)(a2 + 12))
    {
      case 0xC:
        goto LABEL_13;
      case 0xD:
      case 0xE:
      case 0x10:
      case 0x11:
      case 0x13:
      case 0x14:
        break;
      case 0xF:
      case 0x12:
      case 0x15:
        goto LABEL_7;
      default:
        if (v5 == 2 || v5 == 5) {
          goto LABEL_13;
        }
        break;
    }
  }

  uint64_t v7 = *(void *)(a2 + 32);
  if (v7 == -2)
  {
    int v9 = "\tlocalhost";
  }

  else
  {
    if ((*(_DWORD *)(a2 + 172) & 0xFFFFFFFE) == 2
      || AWDLInterfaceID && AWDLInterfaceID == v7
      || WiFiAwareInterfaceID && WiFiAwareInterfaceID == v7)
    {
      uint64_t v8 = 10672LL;
    }

    else
    {
      uint64_t v8 = 10416LL;
    }

    int v9 = (char *)(a1 + v8);
  }

  if (!v4)
  {
    int v10 = (os_log_s *)mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
      {
LABEL_33:
        int v36 = 136446210;
        uint64_t v37 = (uint64_t)DNSTypeName(v5);
        _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "SetTargetToHostName: Don't know how to set the target of rrtype %{public}s",  (uint8_t *)&v36,  0xCu);
      }
    }

    else
    {
      int v10 = (os_log_s *)mDNSLogCategory_Default_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_33;
      }
    }
  }

  if (!*(_BYTE *)(a2 + 122) && (*(_DWORD *)(a2 + 172) & 0xFFFFFFFE) != 4 && !IsLocalDomain((_BYTE *)(a2 + 652)))
  {
    if (*(_BYTE *)(a2 + 120)) {
      *(_BYTE *)(a2 + 120) = 2;
    }
    ServiceTarget = (char *)GetServiceTarget(a1, a2);
    if (ServiceTarget)
    {
      int v9 = ServiceTarget;
      if (*ServiceTarget)
      {
        int v23 = (os_log_s *)mDNSLogCategory_Default;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
        {
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_37;
          }
          uint64_t v33 = v9;
          if (v9 == (char *)-256LL)
          {
LABEL_81:
            while (v33)
            {
              uint64_t v34 = *v33;
              if (!*v33)
              {
                int v35 = (unsigned __int16)((_WORD)v33 - (_WORD)v9 + 1);
                goto LABEL_90;
              }

              v33 += v34 + 1;
            }
          }

          else
          {
LABEL_80:
            if (v33 < v9 + 256) {
              goto LABEL_81;
            }
          }

          int v35 = 257;
        }

        else
        {
          int v23 = (os_log_s *)mDNSLogCategory_Default_redacted;
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_37;
          }
          __int16 v24 = v9;
          if (v9 == (char *)-256LL)
          {
LABEL_64:
            while (v24)
            {
              uint64_t v25 = *v24;
              if (!*v24)
              {
                int v35 = (unsigned __int16)((_WORD)v24 - (_WORD)v9 + 1);
                goto LABEL_90;
              }

              v24 += v25 + 1;
            }
          }

          else
          {
LABEL_63:
            if (v24 < v9 + 256) {
              goto LABEL_64;
            }
          }

          int v35 = 257;
        }

LABEL_90:
        GetRRDisplayString_rdb( (unsigned __int8 *)(a2 + 8),  (unsigned __int16 *)(*(void *)(a2 + 48) + 4LL),  (_BYTE *)(a1 + 46976));
        int v36 = 141558787;
        uint64_t v37 = 1752392040LL;
        __int16 v38 = 1040;
        *(_DWORD *)uint64_t v39 = v35;
        *(_WORD *)&v39[4] = 2101;
        *(void *)&v39[6] = v9;
        __int16 v40 = 2082;
        uint64_t v41 = a1 + 46976;
        _os_log_impl( (void *)&_mh_execute_header,  v23,  OS_LOG_TYPE_DEFAULT,  "SetUnicastTargetToHostName target %{sensitive, mask.hash, mdnsresponder:domain_name}.*P for resource record %{public}s",  (uint8_t *)&v36,  0x26u);
        goto LABEL_37;
      }
    }

    __int16 v26 = (os_log_s *)mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
      {
LABEL_74:
        BOOL v32 = (_BYTE *)(a1 + 46976);
        GetRRDisplayString_rdb((unsigned __int8 *)(a2 + 8), (unsigned __int16 *)(*(void *)(a2 + 48) + 4LL), v32);
        int v36 = 141558275;
        uint64_t v37 = 1752392040LL;
        __int16 v38 = 2085;
        *(void *)uint64_t v39 = v32;
        _os_log_impl( (void *)&_mh_execute_header,  v26,  OS_LOG_TYPE_DEFAULT,  "SetUnicastTargetToHostName No target for %{sensitive, mask.hash}s",  (uint8_t *)&v36,  0x16u);
      }
    }

    else
    {
      __int16 v26 = (os_log_s *)mDNSLogCategory_Default_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_74;
      }
    }

    *(_DWORD *)(a2 + 344) = 8;
    if (v4) {
      *uint64_t v4 = 0;
    }
    SetNewRData(a2 + 8, 0LL, 0LL, v27, v28, v29, v30, v31);
    return;
  }

unint64_t SetNewRData( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a2)
  {
    *(void *)(a1 + 40) = a2;
    *(_WORD *)(a1 + 12) = a3;
  }

  *(_WORD *)(a1 + 12) = GetRDLength(a1, 0, a3, a4, a5, a6, a7, a8);
  *(_WORD *)(a1 + 14) = GetRDLength(a1, 1, v9, v10, v11, v12, v13, v14);
  unint64_t result = RDataHashValue(a1);
  *(_DWORD *)(a1 + 20) = result;
  return result;
}

uint64_t CompressedDomainNameLength(unsigned __int8 *a1, _BYTE *a2)
{
  if (a2)
  {
    if (*a2) {
      int v3 = a2;
    }
    else {
      int v3 = 0LL;
    }
  }

  else
  {
    int v3 = 0LL;
  }

  uint64_t v4 = a1;
  while (1)
  {
    unsigned int v5 = *v4;
    if (!*v4) {
      return (unsigned __int16)((_WORD)v4 - (_WORD)a1 + 1);
    }
    if (v5 > 0x3F) {
      return 257;
    }
    if (v3) {
      break;
    }
LABEL_12:
    v4 += v5 + 1;
    if (v4 - a1 > 255) {
      return 257;
    }
  }

  if (!SameDomainNameBytes(v4, v3))
  {
    unsigned int v5 = *v4;
    goto LABEL_12;
  }

  return (unsigned __int16)((_WORD)v4 - (_WORD)a1 + 2);
}

void AcknowledgeRecord(uint64_t a1, uint64_t a2)
{
  if (*(void *)(a2 + 104))
  {
    *(_BYTE *)(a2 + 188) = 1;
    unsigned int v4 = *(_DWORD *)(a1 + 48);
    unsigned int v5 = *(_DWORD *)(a1 + 52) + 1;
    *(_DWORD *)(a1 + 52) = v5;
    mDNS_VerifyLockState("Drop Lock", 0, v4, v5, (uint64_t)"AcknowledgeRecord", 1373);
    (*(void (**)(uint64_t, uint64_t, void))(a2 + 104))(a1, a2, 0LL);
    mDNS_VerifyLockState( "Reclaim Lock",  0,  *(_DWORD *)(a1 + 48),  *(_DWORD *)(a1 + 52),  (uint64_t)"AcknowledgeRecord",  1375);
    --*(_DWORD *)(a1 + 52);
  }

uint64_t mDNS_StartBrowse_internal( uint64_t a1, unsigned __int8 *a2, _BYTE *a3, uint64_t a4, int a5, char a6, char a7, uint64_t a8, uint64_t a9)
{
  *(void *)(a1 + 136) = a4;
  *(_DWORD *)(a1 + 304) = a5;
  *(_DWORD *)(a1 + 322) = 65548;
  *(_WORD *)(a1 + 612) = 1;
  *(_BYTE *)(a1 + 614) = a6;
  *(_BYTE *)(a1 + 615) = (a5 & 0x1000) != 0;
  *(_WORD *)(a1 + 616) = 0;
  *(_BYTE *)(a1 + 621) = 0;
  *(_BYTE *)(a1 + 619) = 0;
  *(_BYTE *)(a1 + 620) = a7;
  *(_BYTE *)(a1 + 632) = 0;
  *(void *)(a1 + 152) = a8;
  uint64_t v10 = (unsigned __int8 *)(a1 + 356);
  *(void *)(a1 + 176) = a9;
  int v11 = *(_DWORD *)(a1 + 252);
  if (v11)
  {
    unint64_t v12 = a1 + 612;
    uint64_t v13 = (os_log_s *)mDNSLogCategory_mDNS;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
      {
        for (uint64_t i = v10; ; i += v18 + 1)
        {
          if ((unint64_t)i >= v12 || !i || (uint64_t v18 = *i, v18 > 0x3F))
          {
            int v19 = 257;
            goto LABEL_24;
          }

          if (!*i) {
            break;
          }
        }

        int v19 = (unsigned __int16)((_WORD)i - (_WORD)v10 + 1);
        goto LABEL_24;
      }
    }

    else
    {
      uint64_t v13 = (os_log_s *)mDNSLogCategory_mDNS_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
      {
        for (uint64_t j = v10; ; j += v15 + 1)
        {
          if ((unint64_t)j >= v12 || !j || (uint64_t v15 = *j, v15 > 0x3F))
          {
            int v19 = 257;
            goto LABEL_24;
          }

          if (!*j) {
            break;
          }
        }

        int v19 = (unsigned __int16)((_WORD)j - (_WORD)v10 + 1);
LABEL_24:
        v20[0] = 67110147;
        v20[1] = v11;
        __int16 v21 = 2160;
        uint64_t v22 = 1752392040LL;
        __int16 v23 = 1040;
        int v24 = v19;
        __int16 v25 = 2101;
        __int16 v26 = v10;
        __int16 v27 = 1024;
        int v28 = mDNS_DomainNameFNV1aHash(v10);
        _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEFAULT,  "[R%u] DNSServiceBrowse -> SubBrowser START -- qname: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%x)",  (uint8_t *)v20,  0x28u);
      }
    }
  }

  return mDNS_StartQuery_internal((uint64_t)mDNSStorage, a1);
}

_BYTE *ConstructServiceName(_BYTE *a1, const char *a2, unsigned __int8 *a3, _BYTE *a4)
{
  unsigned int v5 = a3;
  uint64_t v7 = &unk_100164000;
  uint64_t v8 = &unk_100164000;
  uint64_t v9 = (os_log_s **)&unk_100164000;
  if (a2)
  {
    uint64_t v10 = a2;
    unsigned int v11 = *(unsigned __int8 *)a2;
    if (*a2)
    {
      if (v11 > 0x3F)
      {
        unint64_t v12 = "Service instance name too long";
        goto LABEL_141;
      }

      uint64_t v20 = 0LL;
      unsigned int v21 = v11 + 1;
      do
      {
        a1[v20] = a2[v20];
        ++v20;
      }

      while (v21 != (_DWORD)v20);
      uint64_t v19 = (uint64_t)&a1[v20];
      goto LABEL_13;
    }

    goto LABEL_9;
  }

  uint64_t v13 = *a3;
  if ((v13 - 1) <= 0x3E)
  {
    uint64_t v14 = a3[v13 + 1];
    if ((v14 - 1) <= 0x3E)
    {
      uint64_t v15 = &a3[v13 + 1 + v14];
      unsigned int v18 = v15[1];
      uint64_t v16 = v15 + 1;
      uint64_t v17 = v18;
      if (v18 - 1 <= 0x3E && !v16[v17 + 1])
      {
        uint64_t v52 = 0LL;
        do
        {
          a1[v52] = a3[v52];
          ++v52;
        }

        while ((_DWORD)v13 + 1 != (_DWORD)v52);
        uint64_t v53 = &a1[v52];
        v53[4] = 98;
        *(_DWORD *)uint64_t v53 = 1970495236;
        int v54 = SameDomainNameBytes(a3, "\t_services\a_dns-sd\x04_udp");
        uint64_t v55 = -5LL;
        if (!v54) {
          uint64_t v55 = 0LL;
        }
        uint64_t v19 = (uint64_t)&a1[v13 + 6 + v55];
        uint64_t v10 = "";
        v5 += v13 + 1;
        goto LABEL_13;
      }
    }

LABEL_9:
    uint64_t v10 = "";
    uint64_t v19 = (uint64_t)a1;
LABEL_13:
    LODWORD(v13) = *v5;
    goto LABEL_15;
  }

  uint64_t v10 = "";
  uint64_t v19 = (uint64_t)a1;
LABEL_15:
  if ((v13 - 17) <= 0xFFFFFFF0)
  {
    uint64_t v22 = (os_log_s *)mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
      {
        int v24 = *(unsigned __int8 *)v10 + 1;
        __int16 v25 = v5;
        if (v5 == (unsigned __int8 *)-256LL)
        {
LABEL_24:
          while (v25)
          {
            uint64_t v26 = *v25;
            if (!*v25)
            {
              LOWORD(v25) = (_WORD)v25 - (_WORD)v5 + 1;
              goto LABEL_40;
            }

            v25 += v26 + 1;
          }
        }

        else
        {
LABEL_23:
          if (v25 < v5 + 256) {
            goto LABEL_24;
          }
        }

        LOWORD(v25) = 257;
LABEL_40:
        LODWORD(v25) = (unsigned __int16)v25;
        if (a4)
        {
          uint64_t v29 = a4;
          if (a4 == (_BYTE *)-256LL) {
            goto LABEL_45;
          }
LABEL_42:
          unsigned __int16 v30 = 257;
          if (v29 < a4 + 256 && v29)
          {
            while (1)
            {
              uint64_t v31 = *v29;
              if (v31 > 0x3F)
              {
LABEL_63:
                unsigned __int16 v30 = 257;
                goto LABEL_66;
              }

              if (!*v29) {
                break;
              }
              v29 += v31 + 1;
              if (a4 != (_BYTE *)-256LL) {
                goto LABEL_42;
              }
LABEL_45:
              if (!v29) {
                goto LABEL_63;
              }
            }

            unsigned __int16 v30 = (_WORD)v29 - (_WORD)a4 + 1;
          }

    unint64_t v2 = 1LL;
LABEL_10:
    a1 += v2;
  }

  if (*a1) {
    goto LABEL_9;
  }
  int v3 = 0LL;
  while (v1)
  {
    if (v1 == 44) {
      return 0xFFFFFFFFLL;
    }
    int v3 = (v3 + 1);
    while (v1 > 91)
    {
      if (v1 == 92 && a1[1])
      {
        unsigned int v4 = 2LL;
        goto LABEL_22;
      }

        mDNS_Unlock_(a1, (uint64_t)"mDNSCoreReceive", 13759);
        return;
      }

      uint64_t v62 = a2 + 9;
      do
      {
        int v63 = v62;
        uint64_t v65 = *v62++;
        uint64_t v64 = v65;
      }

      while (v63 < (unsigned __int8 *)v40 && v64 == 32);
      uint64_t v66 = (uint64_t)(v62 - 1);
      int v67 = v62 - 1;
      while (*v67 != 13)
      {
        if (++v67 == (unsigned __int8 *)v40)
        {
          int v67 = (unsigned __int8 *)v40;
          break;
        }
      }

      os_log_s *v41 = 20480;
      uint64_t v68 = *(void **)(a1 + 14992);
      if (v68)
      {
        free(v68);
        *(void *)(a1 + 14992) = 0LL;
      }

      uint64_t v69 = (void *)(a1 + 14968);
      uint64_t v70 = *(void **)(a1 + 14968);
      if (v70)
      {
        free(v70);
        *uint64_t v69 = 0LL;
      }

      if (ParseHttpUrl( v66,  (unint64_t)v67,  (void *)(a1 + 14992),  (_WORD *)(a1 + 14962),  (void *)(a1 + 14968)))
      {
        if (mDNS_LoggingEnabled == 1)
        {
          uint64_t v71 = (os_log_s *)mDNSLogCategory_Default;
          int v72 = "LNT_ConfigureRouterInfo: Failed to parse URL";
LABEL_84:
          LogMsgWithLevel(v71, OS_LOG_TYPE_DEFAULT, v72, v24, v25, v26, v27, v28, v136);
          goto LABEL_9;
        }

        goto LABEL_9;
      }

      *(void *)(a1 + 14944) = a8;
      if (*(void *)(a1 + 14992))
      {
        if (mDNS_LoggingEnabled == 1) {
          LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "LNT_ConfigureRouterInfo: Router address string [%s]",  v24,  v25,  v26,  v27,  v28,  *(void *)(a1 + 14992));
        }
      }

      else
      {
        LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "LNT_ConfigureRouterInfo: UPnPRouterAddressString is NULL",  v24,  v25,  v26,  v27,  v28,  v136);
      }

      if (*v69)
      {
        if (mDNS_LoggingEnabled != 1)
        {
LABEL_184:
          int v123 = *(void **)(a1 + 14952);
          if (v123)
          {
            CloseSocketSet(*(void *)(a1 + 14952));
            free(v123);
            *(void *)(a1 + 14952) = 0LL;
          }

          GetDeviceDescription(a1, a1 + 14824);
          goto LABEL_9;
        }

        LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "LNT_ConfigureRouterInfo: Router URL [%s]",  v24,  v25,  v26,  v27,  v28,  *v69);
      }

      else
      {
        LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "LNT_ConfigureRouterInfo: UPnPRouterURL is NULL",  v24,  v25,  v26,  v27,  v28,  v136);
      }

      if (mDNS_LoggingEnabled == 1)
      {
        LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "LNT_ConfigureRouterInfo: Router port %d",  v113,  v114,  v115,  v116,  v117,  bswap32((unsigned __int16)*v41) >> 16);
        if (mDNS_LoggingEnabled == 1) {
          LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "LNT_ConfigureRouterInfo: Router interface %d",  v118,  v119,  v120,  v121,  v122,  *(void *)(a1 + 14944));
        }
      }

      goto LABEL_184;
    }

    if (a5 == 59156)
    {
      mDNS_Lock_((unsigned int *)a1, (uint64_t)"mDNSCoreReceive", 13765);
      uint64_t v35 = (unsigned __int16)(a3 - (_WORD)a2);
      if ((_WORD)a3 == (_WORD)a2)
      {
        uint64_t v58 = (os_log_s *)mDNSLogCategory_Default;
        int v59 = "uDNS_ReceiveNATPacket: zero length packet";
      }

      else
      {
        if (*a2)
        {
          if (*a2 != 2)
          {
            LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "uDNS_ReceiveNATPacket: packet with version %u (expected %u or %u)",  v30,  v31,  v32,  v33,  v34,  *a2);
            goto LABEL_195;
          }

          int v36 = (unsigned __int16)(a3 - (_WORD)a2);
          if (v35 <= 0x17)
          {
            LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "uDNS_ReceivePCPPacket: message too short (%d bytes)",  v30,  v31,  v32,  v33,  v34,  v36);
            goto LABEL_195;
          }

          __int16 v78 = a2[1];
          if ((v78 & 0x80000000) == 0 || (uint64_t v79 = v78 & 0x7F, v79 >= 2))
          {
            LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "uDNS_ReceivePCPPacket: unhandled opCode %u",  v30,  v31,  v32,  v33,  v34,  a2[1]);
            goto LABEL_195;
          }

          BOOL v99 = *(_DWORD *)(a1 + 14696);
          unint64_t v100 = bswap32(*((_DWORD *)a2 + 2));
          *((_DWORD *)a2 + 1) = bswap32(*((_DWORD *)a2 + 1));
          *((_DWORD *)a2 + 2) = v100;
          uint64_t v101 = *(_DWORD *)(a1 + 64);
          BOOL v137 = *(_DWORD *)(a1 + 14700);
          v138 = v99;
          if (v100 <= 1) {
            uint64_t v102 = 1;
          }
          else {
            uint64_t v102 = v100;
          }
          *(_DWORD *)(a1 + 14696) = v102;
          *(_DWORD *)(a1 + 14700) = v101;
          LNT_ClearState(a1);
          int v108 = *(void **)(a1 + 14952);
          if (v108)
          {
            CloseSocketSet(*(void *)(a1 + 14952));
            free(v108);
            *(void *)(a1 + 14952) = 0LL;
          }

          if (v138)
          {
            uint64_t v109 = (v101 - v137) / 1000;
            size_t v110 = v100 - v138;
            if (v109 + 2 < v110 - (v110 >> 4) || v110 + 2 < v109 - (v109 >> 4))
            {
              if (v79)
              {
                uint64_t v111 = 0;
              }

              else
              {
                do
                  uint64_t v111 = arc4random() & 0x1FFF;
                while (v111 > 0x1388);
              }

              LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "uDNS_ReceivePCPPacket: Epoch invalid, %#a likely rebooted, waiting %u ticks",  v103,  v104,  v105,  v106,  v107,  v16);
              RecreateNATMappings(a1, v111);
              goto LABEL_195;
            }
          }

          if (!v79)
          {
LABEL_195:
            mDNS_Unlock_(a1, (uint64_t)"mDNSCoreReceive", 13767);
            return;
          }

          uint64_t v124 = a2[3];
          *uint64_t v22 = v124;
          if (v124)
          {
            if (mDNS_LoggingEnabled == 1) {
              LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "uDNS_ReceivePCPPacket: error received from server. opcode %X result %X lifetime %X epoch %X",  v103,  v104,  v105,  v106,  v107,  a2[1]);
            }
            char v125 = 0;
            if (v35 < 0x3C)
            {
              BOOL v127 = 0;
              int v128 = 0;
              int v126 = 0;
            }

            else
            {
              int v126 = 0;
              BOOL v127 = a2[36];
              int v128 = *((unsigned __int16 *)a2 + 20);
            }

            goto LABEL_210;
          }

          if (v35 <= 0x3B)
          {
            LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "uDNS_ReceivePCPPacket: mapping response too short (%d bytes)",  v103,  v104,  v105,  v106,  v107,  v36);
            goto LABEL_195;
          }

          if (*((void *)a2 + 3) != *(void *)(a1 + 14676) || *((_DWORD *)a2 + 8) != *(_DWORD *)(a1 + 14684))
          {
            LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "uDNS_ReceivePCPPacket: invalid nonce, ignoring. received { %x %x %x } expected { %x %x %x }",  v103,  v104,  v105,  v106,  v107,  *((_DWORD *)a2 + 6));
            goto LABEL_195;
          }

          BOOL v127 = a2[36];
          int v128 = *((unsigned __int16 *)a2 + 20);
          int v126 = *((unsigned __int16 *)a2 + 21);
          if (*((_DWORD *)a2 + 11) || *((_DWORD *)a2 + 12) || *((_WORD *)a2 + 26) || *((__int16 *)a2 + 27) != -1)
          {
            LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "uDNS_ReceivePCPPacket: unexpected external address: %.16a",  v103,  v104,  v105,  v106,  v107,  (_DWORD)a2 + 44);
            char v125 = 0;
          }

          else
          {
            char v125 = *((_DWORD *)a2 + 14);
            if (v125)
            {
LABEL_210:
              int v131 = *(void *)(a1 + 14648);
              if (v131)
              {
                int v132 = v125;
                do
                {
                  if ((*(_BYTE *)(v131 + 172) & 2) != 0) {
                    size_t v133 = 6;
                  }
                  else {
                    size_t v133 = 17;
                  }
                  if (v133 == v127 && *(unsigned __int16 *)(v131 + 174) == v128
                    || (!*(_BYTE *)(v131 + 172) ? (unsigned int v134 = v127 == 6) : (unsigned int v134 = 0), v134 && v128 == 2304))
                  {
                    if (a2[3]) {
                      v135 = 3LL;
                    }
                    else {
                      v135 = 0LL;
                    }
                    natTraversalHandlePortMapReplyWithAddress( a1,  v131,  a8,  v135,  v132,  v126,  *((unsigned int *)a2 + 1),  3LL);
                  }

                  int v131 = *(void *)v131;
                }

                while (v131);
              }

              goto LABEL_195;
            }
          }

          a2[3] = 3;
          goto LABEL_210;
        }

        int v75 = (unsigned __int16)(a3 - (_WORD)a2);
        if (v35 <= 3)
        {
          LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "NAT-PMP message too short (%d bytes)",  v30,  v31,  v32,  v33,  v34,  (unsigned __int16)(a3 - (_WORD)a2));
          goto LABEL_195;
        }

        __int16 v80 = __rev16(*((unsigned __int16 *)a2 + 1));
        *((_WORD *)a2 + 1) = v80;
        if (v80 == 1)
        {
          if (mDNS_LoggingEnabled == 1) {
            LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "NAT-PMP version unsupported message received",  v30,  v31,  v32,  v33,  v34,  v136);
          }
          for (uint64_t i = *(void **)(a1 + 14648); i; uint64_t i = (void *)*i)
            uDNS_SendNATMsg(a1, (uint64_t)i, 0, 0);
          *(_DWORD *)(a1 + 104) = *(_DWORD *)(a1 + 64);
          goto LABEL_195;
        }

        if (v35 <= 7)
        {
          LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "NAT-PMP message too short (%d bytes) 0x%X 0x%X",  v30,  v31,  v32,  v33,  v34,  (unsigned __int16)(a3 - (_WORD)a2));
          goto LABEL_195;
        }

        __int16 v82 = bswap32(*((_DWORD *)a2 + 1));
        *((_DWORD *)a2 + 1) = v82;
        uint64_t v83 = *(_DWORD *)(a1 + 14696);
        __int16 v84 = v82 - v83;
        if (v82 < v83
          || (uint64_t v85 = *(_DWORD *)(a1 + 64),
              uint64_t v86 = 274877907LL * (v85 - *(_DWORD *)(a1 + 14700)),
              LODWORD(v86) = (v86 >> 38) + ((unint64_t)v86 >> 63),
              v84 + 2 < v86 - (v86 >> 3)))
        {
          LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "NAT-PMP epoch time check failed: assuming NAT gateway %#a rebooted",  v30,  v31,  v32,  v33,  v34,  v16);
          RecreateNATMappings(a1, 0);
          __int16 v82 = *((_DWORD *)a2 + 1);
          uint64_t v85 = *(_DWORD *)(a1 + 64);
        }

        *(_DWORD *)(a1 + 14696) = v82;
        *(_DWORD *)(a1 + 14700) = v85;
        LNT_ClearState(a1);
        uint64_t v87 = a2[1];
        if ((v87 - 129) < 2)
        {
          if (mDNS_LoggingEnabled == 1)
          {
            uint64_t v88 = "failure";
            if (!*((_WORD *)a2 + 1)) {
              uint64_t v88 = "success";
            }
            LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "uDNS_ReceiveNATPMPPacket: PortMapRequest %s %s - error %d",  v30,  v31,  v32,  v33,  v34,  (int)v88);
          }

          uint64_t v89 = *((_WORD *)a2 + 1);
          if (!v89)
          {
            if (v35 <= 0xF)
            {
              LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "NAT-PMP PortMapReply message too short (%d bytes)",  v30,  v31,  v32,  v33,  v34,  v75);
              goto LABEL_195;
            }

            *((_DWORD *)a2 + 3) = bswap32(*((_DWORD *)a2 + 3));
          }

          *uint64_t v22 = v89;
          for (uint64_t j = *(void *)(a1 + 14648); j; uint64_t j = *(void *)j)
          {
            if (*(_BYTE *)(j + 172) == (v87 & 0x7F) && *(unsigned __int16 *)(j + 174) == *((unsigned __int16 *)a2 + 4)) {
              natTraversalHandlePortMapReplyWithAddress( a1,  j,  a8,  *((unsigned __int16 *)a2 + 1),  *(unsigned int *)(a1 + 14672),  *((unsigned __int16 *)a2 + 5),  *((unsigned int *)a2 + 3),  1LL);
            }
          }

  if (a6) {
    *a6 = v14;
  }
  if (v6) {
    ref_count_obj_release(v6);
  }
  return v17;
}

  os_release(v7);
  return v9;
}

    unsigned int v18 = (unsigned __int16 *)((char *)a2 + v13);
    uint64_t v19 = mDNS_snprintf(&v80[v6]);
    if (v18 <= a2) {
      return v80;
    }
    uint64_t v20 = v19 + v12;
    while (1)
    {
      unsigned int v21 = *a2;
      if (v21 <= 3)
      {
        if (v21 != 1)
        {
          if (v21 == 2) {
            uint64_t v26 = &v80[v20];
          }
          else {
LABEL_25:
          }
            uint64_t v26 = &v80[v20];
LABEL_26:
          v20 += mDNS_snprintf(v26);
          goto LABEL_27;
        }

        uint64_t v31 = mDNS_snprintf(&v80[v20]) + v20;
        int v32 = mDNS_snprintf(&v80[v31]) + v31;
        uint64_t v33 = mDNS_snprintf(&v80[v32]) + v32;
        unsigned __int16 v34 = mDNS_snprintf(&v80[v33]) + v33;
        int v24 = mDNS_snprintf(&v80[v34]) + v34;
        __int16 v25 = &v80[v24];
      }

      else
      {
        switch(v21)
        {
          case 4u:
            __int16 v27 = mDNS_snprintf(&v80[v20]) + v20;
            uint64_t v28 = mDNS_snprintf(&v80[v27]) + v27;
            uint64_t v29 = mDNS_snprintf(&v80[v28]) + v28;
            uint64_t v20 = v29 + mDNS_snprintf(&v80[v29]);
            if (a2[1] < 0xEu) {
              goto LABEL_27;
            }
            v20 += mDNS_snprintf(&v80[v20]);
            if (a2[1] < 0xFu) {
              goto LABEL_27;
            }
            uint64_t v26 = &v80[v20];
            goto LABEL_26;
          case 0xFDE9u:
            unsigned __int16 v30 = mDNS_snprintf(&v80[v20]) + v20;
            int v24 = mDNS_snprintf(&v80[v30]) + v30;
            __int16 v25 = &v80[v24];
            break;
          case 0xFDEAu:
            uint64_t v22 = mDNS_snprintf(&v80[v20]) + v20;
            __int16 v23 = mDNS_snprintf(&v80[v22]) + v22;
            int v24 = mDNS_snprintf(&v80[v23]) + v23;
            __int16 v25 = &v80[v24];
            break;
          default:
            goto LABEL_25;
        }
      }

      uint64_t v20 = mDNS_snprintf(v25) + v24;
LABEL_27:
      a2 += 12;
      if (a2 >= v18) {
        return v80;
      }
    }
  }

  if (*((unsigned __int16 *)a1 + 2) <= 0x20u)
  {
    switch(*((_WORD *)a1 + 2))
    {
      case 1:
        uint64_t v35 = &v80[v6];
        break;
      case 2:
      case 5:
      case 0xC:
        uint64_t v35 = &v80[v6];
        break;
      case 3:
      case 4:
      case 7:
      case 8:
      case 9:
      case 0xA:
      case 0xB:
      case 0xE:
      case 0xF:
        goto LABEL_116;
      case 6:
        uint64_t v35 = &v80[v6];
        break;
      case 0xD:
      case 0x10:
        uint64_t v37 = &v80[v6];
        unint64_t v38 = (_DWORD)a2 + v13;
        if ((unsigned __int16 *)((char *)a2 + v13) <= a2)
        {
          uint64_t v39 = 0;
          goto LABEL_151;
        }

        uint64_t v39 = 0;
        unint64_t v40 = 1;
        uint64_t v77 = (unsigned __int16 *)((char *)a2 + v13);
        __int16 v78 = &v80[v6];
        while (2)
        {
          int v43 = *(unsigned __int8 *)a2;
          uint64_t v42 = (char *)a2 + 1;
          int v41 = v43;
          int v44 = &v37[v39];
          unsigned __int16 v45 = 506 - (v12 + v39);
          if ((v40 & 1) != 0)
          {
            uint64_t v46 = 0;
LABEL_45:
            unsigned int v47 = (unsigned __int16 *)&v42[v41];
            if (v42 >= &v42[v41])
            {
LABEL_94:
              unint64_t v40 = 0;
              v39 += v46;
              a2 = v47;
              unint64_t v38 = (int)v77;
              uint64_t v37 = v78;
              if (v47 >= v77) {
                goto LABEL_151;
              }
              continue;
            }

            while (1)
            {
              uint64_t v48 = &v42[(_DWORD)v47 - (_DWORD)v42];
              if (v48 > v42) {
                break;
              }
LABEL_81:
              uint64_t v49 = 0LL;
LABEL_82:
              if (v49) {
                uint64_t v53 = (_DWORD)v49 - (_DWORD)v42;
              }
              else {
                uint64_t v53 = (_DWORD)v47 - (_DWORD)v42;
              }
              if (v53)
              {
                int v54 = mDNS_snprintf(&v44[v46]);
                v46 += v54;
                if (v54 != v53) {
                  goto LABEL_150;
                }
              }

              if (v49)
              {
                uint64_t v55 = v45 - v46;
                if ((*v49 & 0xDF) == 0x5C)
                {
                  if (v55 <= 2) {
                    goto LABEL_150;
                  }
                }

                else if (v55 < 5)
                {
                  goto LABEL_150;
                }

                v46 += mDNS_snprintf(&v44[v46]);
                uint64_t v48 = v49 + 1;
              }

              uint64_t v42 = v48;
            }

            uint64_t v49 = v42;
            while (1)
            {
              int v50 = (_DWORD)v47 - (_DWORD)v49;
              if ((_DWORD)v47 == (_DWORD)v49) {
                goto LABEL_82;
              }
              int v51 = *v49;
              if (v51 < 0)
              {
                if (v50 < 2) {
                  goto LABEL_82;
                }
                if ((v51 + 32) >= 0xE2u && v49[1] < -64)
                {
                  uint64_t v52 = 2LL;
                  goto LABEL_53;
                }

                if (v50 < 3 || v49[2] > -65) {
                  goto LABEL_82;
                }
                if (v51 == -32)
                {
                  if ((v49[1] & 0xE0) == 0xA0) {
                    goto LABEL_67;
                  }
                }

                else if ((v51 + 31) < 0xC || (v51 & 0xFFFFFFFE) == 0xFFFFFFEE)
                {
                  if (v49[1] <= -65) {
                    goto LABEL_67;
                  }
                }

                else if (v51 == -19 && v49[1] < -96)
                {
LABEL_67:
                  uint64_t v52 = 3LL;
                  goto LABEL_53;
                }

                if (v50 < 4 || v49[3] > -65) {
                  goto LABEL_82;
                }
                if (v51 == -16)
                {
                }

                else if ((v51 + 12) >= 0xFDu)
                {
                  if (v49[1] > -65) {
                    goto LABEL_82;
                  }
                }

                else if (v51 != -12 || v49[1] > -113)
                {
                  goto LABEL_82;
                }

                uint64_t v52 = 4LL;
              }

              else
              {
                uint64_t v52 = 1LL;
              }

    sa_family = 30;
  }

  if (a5) {
    *a5 = v12;
  }
  if (v15) {
    ref_count_obj_release(v15);
  }
  return v5;
}

LABEL_66:
          int v32 = v30;
        }

        else
        {
          int v32 = 0;
        }

        goto LABEL_69;
      }
    }

    else
    {
      uint64_t v22 = (os_log_s *)mDNSLogCategory_Default_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
      {
        int v24 = *(unsigned __int8 *)v10 + 1;
        __int16 v25 = v5;
        if (v5 == (unsigned __int8 *)-256LL)
        {
LABEL_32:
          while (v25)
          {
            uint64_t v28 = *v25;
            if (!*v25)
            {
              LOWORD(v25) = (_WORD)v25 - (_WORD)v5 + 1;
              goto LABEL_52;
            }

            v25 += v28 + 1;
          }
        }

        else
        {
LABEL_31:
          if (v25 < v5 + 256) {
            goto LABEL_32;
          }
        }

        LOWORD(v25) = 257;
LABEL_52:
        LODWORD(v25) = (unsigned __int16)v25;
        if (a4)
        {
          uint64_t v33 = a4;
          if (a4 == (_BYTE *)-256LL) {
            goto LABEL_57;
          }
LABEL_54:
          unsigned __int16 v34 = 257;
          if (v33 < a4 + 256 && v33)
          {
            while (1)
            {
              uint64_t v35 = *v33;
              if (v35 > 0x3F)
              {
LABEL_64:
                unsigned __int16 v34 = 257;
                goto LABEL_68;
              }

              if (!*v33) {
                break;
              }
              v33 += v35 + 1;
              if (a4 != (_BYTE *)-256LL) {
                goto LABEL_54;
              }
LABEL_57:
              if (!v33) {
                goto LABEL_64;
              }
            }

            unsigned __int16 v34 = (_WORD)v33 - (_WORD)a4 + 1;
          }

              uint64_t v33 = v28;
            }

            else
            {
              uint64_t v33 = 0;
            }

              int v36 = v34;
            }

            else
            {
              int v36 = 0;
            }

            uint64_t v37 = v30[7];
            unint64_t v38 = v37 + 4;
            uint64_t v39 = v37 + 260;
            unint64_t v40 = (_BYTE *)(v37 + 4);
            if (v39)
            {
LABEL_68:
            }

            else
            {
LABEL_69:
              while (v40)
              {
                int v41 = *v40;
                if (!*v40)
                {
                  uint64_t v42 = (_WORD)v40 - v38 + 1;
                  goto LABEL_76;
                }

                v40 += v41 + 1;
                if (v39) {
                  goto LABEL_68;
                }
              }
            }

            uint64_t v42 = 257;
LABEL_76:
            *(_DWORD *)buf = 141559299;
            *(void *)int v93 = 1752392040LL;
            *(_WORD *)&v93[8] = 1040;
            LODWORD(v94) = v36;
            WORD2(v94) = 2101;
            *(void *)((char *)&v94 + 6) = v32;
            HIWORD(v94) = 2160;
            *(void *)int v95 = 1752392040LL;
            *(_WORD *)&v95[8] = 1040;
            *(_DWORD *)int v96 = v42;
            *(_WORD *)&v96[4] = 2101;
            BOOL v97 = v38;
            _os_log_impl( (void *)&_mh_execute_header,  v31,  OS_LOG_TYPE_DEFAULT,  "uDNS_SetupWABQueries: DELETE Deregistering PTR -- record: %{sensitive, mask.hash, mdnsresponder:domain_nam e}.*P PTR %{sensitive, mask.hash, mdnsresponder:domain_name}.*P",  buf,  0x36u);
          }

          int v43 = mDNS_Deregister((unsigned int *)mDNSStorage, (uint64_t)(v30 + 1));
          if (v43)
          {
            int v44 = v43;
            unsigned __int16 v45 = (os_log_s *)mDNSLogCategory_State;
            if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 67109120;
              *(_DWORD *)int v93 = v44;
              _os_log_impl( (void *)&_mh_execute_header,  v45,  OS_LOG_TYPE_ERROR,  "uDNS_SetupWABQueries: mDNS_Deregister returned error -- error: %d",  buf,  8u);
            }
          }

          if (!v23) {
            goto LABEL_81;
          }
          continue;
        }
      }

      if ((v4 & 1) != 0 || (v14 & 2) == 0)
      {
        if ((v4 & 2) == 0 && (v14 & 4) != 0)
        {
LABEL_88:
          if (!SameDomainNameBytes((_BYTE *)(v5 + 8), "\x05local") && !*(void *)(v5 + 272))
          {
            uint64_t v46 = v7;
            unsigned int v47 = (os_log_s *)mDNSLogCategory_State;
            if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)buf = 67109120;
              *(_DWORD *)int v93 = v46;
              _os_log_impl( (void *)&_mh_execute_header,  v47,  OS_LOG_TYPE_DEFAULT,  "uDNS_SetupWABQueries: Deleting Legacy Browse for domain -- name hash: %x",  buf,  8u);
            }

            *(_DWORD *)(v5 + 264) &= ~4u;
            uDNS_DeleteWABQueries(v5, 2, v48, v49, v50, v51, v52, v53, v89);
            uint64_t v7 = v46;
          }

          goto LABEL_93;
        }

        if (v4 > 3 || (v14 & 8) == 0) {
          goto LABEL_100;
        }
      }

      else if (!SameDomainNameBytes((_BYTE *)(v5 + 8), "\x05local") && !*(void *)(v5 + 272))
      {
        uint64_t v15 = v7;
        uint64_t v16 = (os_log_s *)mDNSLogCategory_State;
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 67109120;
          *(_DWORD *)int v93 = v15;
          _os_log_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_DEFAULT,  "uDNS_SetupWABQueries: Deleting Browse for domain -- name hash: %x",  buf,  8u);
        }

        *(_DWORD *)(v5 + 264) &= ~2u;
        uDNS_DeleteWABQueries(v5, 1, v17, v18, v19, v20, v21, v22, v89);
        uint64_t v7 = v15;
      }

      if ((v4 & 2) == 0 && (*(_BYTE *)(v5 + 264) & 4) != 0) {
        goto LABEL_88;
      }
LABEL_93:
      if (v4 <= 3
        && (*(_BYTE *)(v5 + 264) & 8) != 0
        && !SameDomainNameBytes((_BYTE *)(v5 + 8), "\x05local")
        && !*(void *)(v5 + 272))
      {
        int v54 = v7;
        uint64_t v55 = (os_log_s *)mDNSLogCategory_State;
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 67109120;
          *(_DWORD *)int v93 = v54;
          _os_log_impl( (void *)&_mh_execute_header,  v55,  OS_LOG_TYPE_DEFAULT,  "uDNS_SetupWABQueries: Deleting Registration for domain -- name hash: %x",  buf,  8u);
        }

        *(_DWORD *)(v5 + 264) &= ~8u;
        uDNS_DeleteWABQueries(v5, 4, v56, v57, v58, v59, v60, v61, v89);
        uint64_t v7 = v54;
      }

    if (ParseHttpUrl(v31 + 8, (unint64_t)v24, (void *)(v9 + 15000), (_WORD *)(v9 + 14964), 0LL)
      && mDNS_LoggingEnabled)
    {
      LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "handleLNTDeviceDescriptionResponse: failed to parse URLBase",  v15,  v16,  v17,  v18,  v19,  v40);
    }

    if (*((void *)v27 + 7)) {
      uint64_t v39 = -6705;
    }
    else {
      uint64_t v39 = -6709;
    }
    if (*((void *)v27 + 7)) {
      unint64_t v40 = (v119 - 3) >= 0xFFFFFFFE;
    }
    else {
      unint64_t v40 = 0;
    }
    if (!v40)
    {
      uint64_t v29 = 0LL;
LABEL_155:
      unint64_t v2 = v26;
      goto LABEL_102;
    }

    int v41 = *((_DWORD *)v27 + 4);
    uint64_t v42 = CacheGroupForName((uint64_t)mDNSStorage, v41, *((_BYTE **)v27 + 4));
    int v44 = *(__int128 **)(*((void *)v27 + 7) + 16LL);
    if (v44)
    {
      unsigned __int16 v45 = (uint64_t)v42;
      else {
        uint64_t v46 = dword_100158BF8;
      }
      unsigned int v47 = *(void **)((char *)&dword_100158BF8 + &loc_1000093D8);
      uint64_t v48 = v46;
      if (v47)
      {
        os_release(v47);
        uint64_t v48 = dword_100158BF8;
      }

      xmmword_100162058 = 0u;
      unk_100162068 = 0u;
      xmmword_100162038 = 0u;
      unk_100162048 = 0u;
      xmmword_100162018 = 0u;
      unk_100162028 = 0u;
      xmmword_100161FF8 = 0u;
      *(_OWORD *)&qword_100162008 = 0u;
      xmmword_100161FD8 = 0u;
      unk_100161FE8 = 0u;
      unk_100161FB8 = 0u;
      *(_OWORD *)&qword_100161FC8 = 0u;
      xmmword_100161F98 = 0u;
      xmmword_100161FA8 = 0u;
      uint64_t v49 = v44[1];
      xmmword_100161F98 = *v44;
      int v50 = v44[2];
      int v51 = v44[3];
      uint64_t v52 = v44[5];
      xmmword_100161FD8 = v44[4];
      unk_100161FE8 = v52;
      uint64_t v53 = v44[8];
      int v54 = v44[9];
      uint64_t v55 = v44[7];
      xmmword_100161FF8 = v44[6];
      *(_OWORD *)&qword_100162008 = v55;
      unk_100161FB8 = v50;
      *(_OWORD *)&qword_100161FC8 = v51;
      xmmword_100161FA8 = v49;
      xmmword_100162018 = v53;
      unk_100162028 = v54;
      uint64_t v56 = v44[10];
      uint64_t v57 = v44[11];
      uint64_t v58 = v44[13];
      xmmword_100162058 = v44[12];
      unk_100162068 = v58;
      xmmword_100162038 = v56;
      unk_100162048 = v57;
      *(void *)&xmmword_100161F98 = 0LL;
      *((void *)&xmmword_100161FD8 + 1) = 0LL;
      dword_100161FEC = v48;
      *(void *)&xmmword_100161FF8 = 0LL;
      BYTE12(xmmword_100161FF8) = 0;
      qword_100162008 = 0LL;
      unk_100162010 = 0LL;
      LODWORD(xmmword_100161FA8) = a2;
      if (*((void *)&v51 + 1)) {
        os_retain(*((void **)&v51 + 1));
      }
      if (v119 == 1)
      {
        int v59 = 4LL;
LABEL_87:
        if (*v27 == 240)
        {
          uint64_t v60 = *((void *)v27 + 7);
          if (v60)
          {
            if (!*(_DWORD *)(v60 + 32) && !*(_BYTE *)(v60 + 40))
            {
              int v61 = *(void *)(v60 + 48);
              if (v61)
              {
                if (*(_BYTE *)(v61 + 107)) {
                  int v59 = v59 | 0x10;
                }
                else {
                  int v59 = v59;
                }
              }
            }
          }
        }

        NewCacheEntry = CreateNewCacheEntryEx( (uint64_t)mDNSStorage,  v41 % 0x1F3,  v45,  v46,  1LL,  (uint64_t)v44 + 132,  v59,  v43);
        uint64_t v29 = NewCacheEntry;
        if (NewCacheEntry)
        {
          int v63 = *(_DWORD *)(NewCacheEntry + 84);
          uint64_t v64 = (char *)mDNSStorage + 4 * (v41 % 0x1F3);
          unint64_t v2 = v26;
          if (*((_DWORD *)v64 + 1068) - v63 >= 1) {
            *((_DWORD *)v64 + 1068) = v63;
          }
          __int16 v23 = v25;
          uint64_t v39 = 0;
          if (dword_100158C10 - v63 >= 1) {
            dword_100158C10 = v63;
          }
          goto LABEL_103;
        }

        uint64_t v39 = -6728;
        goto LABEL_155;
      }

      if (v119 == 2)
      {
        int v59 = 8LL;
        goto LABEL_87;
      }

      uint64_t v29 = 0LL;
      uint64_t v39 = -6736;
    }

    else
    {
      uint64_t v29 = 0LL;
      uint64_t v39 = -6709;
    }

    unint64_t v2 = v26;
LABEL_102:
    __int16 v23 = v25;
LABEL_103:
    uint64_t v65 = v120;
    int v126 = v39;
    if (qword_100161FD0)
    {
      os_release((void *)qword_100161FD0);
      uint64_t v39 = v126;
    }

    xmmword_100162058 = 0u;
    unk_100162068 = 0u;
    xmmword_100162038 = 0u;
    unk_100162048 = 0u;
    xmmword_100162018 = 0u;
    unk_100162028 = 0u;
    xmmword_100161FF8 = 0u;
    *(_OWORD *)&qword_100162008 = 0u;
    xmmword_100161FD8 = 0u;
    unk_100161FE8 = 0u;
    unk_100161FB8 = 0u;
    *(_OWORD *)&qword_100161FC8 = 0u;
    xmmword_100161F98 = 0u;
    xmmword_100161FA8 = 0u;
    if (v39) {
      goto LABEL_197;
    }
    ++v124;
LABEL_107:
    uint64_t v66 = *(void *)(v29 + 64);
    if (!v66) {
      goto LABEL_197;
    }
    *(void *)(v66 + 24) = v2;
    v144[v22] = v29 + 8;
    if (*(_BYTE *)(v29 + 109)) {
      int v67 = dword_100158BF8 + 939524096;
    }
    else {
      int v67 = *(_DWORD *)(v29 + 80) + 1000 * *(_DWORD *)(v29 + 16);
    }
    if (v67 <= 1) {
      uint64_t v68 = 1LL;
    }
    else {
      uint64_t v68 = v67;
    }
    if ((_DWORD)v23)
    {
      uint64_t v69 = v23 - v68;
      if ((_DWORD)v23 != (_DWORD)v68)
      {
        uint64_t v70 = (os_log_s *)mDNSLogCategory_DNSSEC;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_DNSSEC == mDNSLogCategory_State)
        {
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC, OS_LOG_TYPE_FAULT)) {
            goto LABEL_122;
          }
        }

        else
        {
          uint64_t v70 = (os_log_s *)mDNSLogCategory_DNSSEC_redacted;
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC_redacted, OS_LOG_TYPE_FAULT))
          {
LABEL_122:
            *(_DWORD *)buf = 67109120;
            *(_DWORD *)int v128 = v69 / 1000;
            _os_log_impl( (void *)&_mh_execute_header,  v70,  OS_LOG_TYPE_FAULT,  "DNSSEC validated records in the same RRSet have different expiration time - difference in second: %d",  buf,  8u);
          }
        }

        if (v69 <= 0) {
          __int16 v23 = v23;
        }
        else {
          __int16 v23 = v68;
        }
      }
    }

    else
    {
      __int16 v23 = v68;
    }

    if (++v22 == v65)
    {
      if ((int)v23 - dword_100158BF8 >= 1)
      {
        uint64_t v85 = ((int)v23 - dword_100158BF8) / 0x3E8u;
        if (v118 && !v124)
        {
          uint64_t v86 = v144;
          do
          {
            uint64_t v87 = *v86++;
            *(_BYTE *)(*(void *)(v87 + 56) + 36LL) = 1;
            --v65;
          }

          while (v65);
        }

        uint64_t v88 = (os_log_s *)mDNSLogCategory_DNSSEC;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_DNSSEC == mDNSLogCategory_State)
        {
          uint64_t v90 = v117;
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC, OS_LOG_TYPE_INFO))
          {
            int v91 = bswap32(*(unsigned __int16 *)(v115 + 320)) >> 16;
            unint64_t v92 = v114;
            if (v115 == -612)
            {
LABEL_175:
              while (v92)
              {
                int v93 = *v92;
                if (!*v92)
                {
                  BOOL v97 = (unsigned __int16)((_WORD)v92 - (_WORD)v114 + 1);
                  goto LABEL_192;
                }

                v92 += v93 + 1;
                if (v115 != -612) {
                  goto LABEL_174;
                }
              }
            }

            else
            {
LABEL_174:
            }

            BOOL v97 = 257;
LABEL_192:
            BOOL v98 = *(unsigned __int16 *)(v115 + 322);
            BOOL v99 = *(unsigned __int16 *)(*v123 + 4);
            unint64_t v100 = *(unsigned __int8 *)*v123 != 240;
            *(_DWORD *)buf = 67112451;
            *(_DWORD *)int v128 = v91;
            *(_WORD *)&v128[4] = 2160;
            *(void *)&v128[6] = 1752392040LL;
            *(_WORD *)&v128[14] = 1040;
            *(_DWORD *)&v128[16] = v97;
            *(_WORD *)&v128[20] = 2101;
            *(void *)&v128[22] = v114;
            *(_WORD *)&v128[30] = 1024;
            *(_DWORD *)&v128[32] = v98;
            *(_WORD *)&v128[36] = 1024;
            *(_DWORD *)&v128[38] = v99;
            *(_WORD *)&v128[42] = 1024;
            uint64_t v129 = a2;
            unsigned int v130 = 1024;
            int v131 = v85;
            int v132 = 1024;
            size_t v133 = v100;
            unsigned int v134 = 1026;
            v135 = v119;
            int v136 = 2048;
            BOOL v137 = v117;
            v138 = 2048;
            uint64_t v139 = v124;
            int v140 = 2048;
            uint64_t v141 = v2;
            uint64_t v142 = 2048;
            unsigned int v143 = v118;
            _os_log_impl( (void *)&_mh_execute_header,  v88,  OS_LOG_TYPE_INFO,  "[Q%u] Update cache for DNSSEC question - qname: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P, qty pe: %{mdns:rrtype}d, rr_type: %{mdns:rrtype}d, new original ttl: %u, actual ttl: %u, %{mdns:pos/neg}d, DNS SEC result: %{public, mdns:dnssec_result}d, rescued: %zu, added: %zu, total: %zu, purged: %zu.",  buf,  0x6Eu);
          }
        }

        else
        {
          uint64_t v88 = (os_log_s *)mDNSLogCategory_DNSSEC_redacted;
          __int16 v94 = os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC_redacted, OS_LOG_TYPE_INFO);
          uint64_t v90 = v117;
          if (v94)
          {
            int v91 = bswap32(*(unsigned __int16 *)(v115 + 320)) >> 16;
            int v95 = v114;
            if (v115 == -612)
            {
LABEL_183:
              while (v95)
              {
                int v96 = *v95;
                if (!*v95)
                {
                  BOOL v97 = (unsigned __int16)((_WORD)v95 - (_WORD)v114 + 1);
                  goto LABEL_192;
                }

                v95 += v96 + 1;
                if (v115 != -612) {
                  goto LABEL_182;
                }
              }
            }

            else
            {
LABEL_182:
            }

            BOOL v97 = 257;
            goto LABEL_192;
          }
        }

        if (v90)
        {
          uint64_t v101 = dword_100158BF8;
          dword_100158C5C = v101;
        }

      int v36 = *(void *)v36;
      if (!v36) {
        goto LABEL_67;
      }
    }

    uint64_t v42 = *(_WORD *)(v36 + 110) & 0xFE | *(_BYTE *)(v11 + 50) & 1 | ((*(_BYTE *)(v11 + 51) & 0x10 | HIBYTE(*(unsigned __int16 *)(v36 + 110)) & 0xFFFFFFEF) << 8);
    os_log_s *v41 = *(_WORD *)(v11 + 30);
    v41[1] = v42;
    *(void *)(v41 + 2) = 0LL;
    int v43 = putQuestion( *(void *)(v11 + 1016),  *(void *)(v11 + 1016) + 12LL,  v163,  v161,  *(unsigned __int16 *)(v11 + 992),  *(unsigned __int16 *)(v11 + 660),  v34,  v35);
    if (v43)
    {
      unint64_t v38 = (unint64_t)v43;
      v39 += (_DWORD)v43 - *(_DWORD *)(v11 + 1000);
      *(void *)(v11 + 1000) = v43;
      if (*(_DWORD *)(v11 + 996) == 3)
      {
        v186 = 0u;
        memset(v187, 0, sizeof(v187));
        uint64_t v184 = 0u;
        unsigned int v185 = 0u;
        uint64_t v182 = 0u;
        uint64_t v183 = 0u;
        uint64_t v180 = 0u;
        uint64_t v181 = 0u;
        int v178 = 0u;
        BOOL v179 = 0u;
        uint8_t v176 = 0u;
        v177 = 0u;
        v174 = 0u;
        v175 = 0u;
        memset(v173, 0, sizeof(v173));
        char v169 = 0u;
        uint64_t v166 = 0u;
        int v167 = 0u;
        LOBYTE(v166) = -64;
        DWORD1(v166) = 65541;
        int v44 = (_BYTE *)(v11 + 692);
        uint64_t v168 = (unint64_t)v161;
        if (v20)
        {
LABEL_34:
        }

        else
        {
LABEL_35:
          while (v44)
          {
            unsigned __int16 v45 = *v44;
            if (!*v44)
            {
              uint64_t v46 = (_WORD)v44 - (_WORD)__src + 1;
              if (v46 <= 0x100u) {
                memcpy((char *)v173 + 4, __src, v46);
              }
              break;
            }

            v44 += v45 + 1;
            if (v20) {
              goto LABEL_34;
            }
          }
        }

        LOWORD(v173[0]) = 264;
        *((void *)&v168 + 1) = v173;
        unsigned int v47 = PutResourceRecordTTLWithLimit( *(void *)(v11 + 1016),  v38,  (_WORD *)(*(void *)(v11 + 1016) + 6LL),  (uint64_t)&v166,  0LL,  v163,  v34,  v35);
        uint64_t v48 = *(_BYTE **)(v11 + 1000);
        if (!v47) {
          goto LABEL_93;
        }
        unint64_t v38 = v47;
        v39 += v47 - (_DWORD)v48;
        *(void *)(v11 + 1000) = v47;
      }

      goto LABEL_44;
    }

    if (mDNS_LoggingEnabled == 1)
    {
      uint64_t v88 = (os_log_s *)mDNSLogCategory_Default;
      uint64_t v19 = (unsigned __int8 *)(v11 + 80);
      DNSTypeName(*(unsigned __int16 *)(v11 + 992));
      LogMsgWithLevel( v88,  OS_LOG_TYPE_DEFAULT,  "AddResourceRecord: putQuestion NULL for %##s (%s)",  v89,  v90,  v91,  v92,  v93,  (int)v161);
      uint64_t v48 = 0LL;
      goto LABEL_91;
    }

    uint64_t v48 = 0LL;
LABEL_93:
    uint64_t v85 = 1;
    uint64_t v19 = (unsigned __int8 *)(v11 + 80);
LABEL_94:
    unsigned int v21 = v158;
    uint64_t v22 = v159;
LABEL_95:
    if (*(_BYTE *)(v11 + 48))
    {
      __int16 v94 = 8940;
    }

    else
    {
      int v95 = *(unsigned __int16 *)(v11 + 68);
      if (*(_WORD *)(v11 + 68))
      {
        if (v95 - 12 >= 0x22EC) {
          int v96 = 8940;
        }
        else {
          int v96 = (unsigned __int16)(v95 - 12);
        }
        if (v95 <= 0xC) {
          __int16 v94 = 500;
        }
        else {
          __int16 v94 = v96;
        }
      }

      else
      {
        __int16 v94 = 500;
      }
    }

    if (*(unsigned __int16 *)(v11 + 1008) < v94)
    {
      if (mDNS_LoggingEnabled == 1)
      {
        BOOL v97 = (os_log_s *)mDNSLogCategory_Default;
        DNSTypeName(*(unsigned __int16 *)(v11 + 992));
        LogMsgWithLevel( v97,  OS_LOG_TYPE_DEFAULT,  "ProxyClientCallback: Increase omsg buffer size to %d for %##s (%s)",  v98,  v99,  v100,  v101,  v102,  v94);
      }

      uint64_t v103 = v22 - (void)v21 - 12;
      DNSProxyPrepareOmsg(v94, v11);
      size_t v104 = *(void *)(v11 + 1016);
      *(void *)size_t v104 = v170;
      *(_DWORD *)(v104 + 8) = v171;
      unsigned int v21 = *(uint64_t **)(v11 + 1016);
      uint64_t v22 = (uint64_t)v21 + v103 + 12;
      *(void *)(v11 + 1000) = v22;
      continue;
    }

    break;
  }

  if (mDNS_LoggingEnabled == 1)
  {
    uint64_t v105 = (os_log_s *)mDNSLogCategory_Default;
    DNSTypeName(*(unsigned __int16 *)(v11 + 992));
    LogMsgWithLevel( v105,  OS_LOG_TYPE_DEFAULT,  "ProxyClientCallback: AddResourceRecord NULL for %##s (%s)",  v106,  v107,  v108,  v109,  v110,  (int)v19);
  }

  if (v48) {
    uint64_t v111 = v85;
  }
  else {
    uint64_t v111 = 0;
  }
  uint64_t v8 = v155;
  if (v111 == 1)
  {
    if (*(_BYTE *)(v11 + 48))
    {
      if (mDNS_LoggingEnabled == 1)
      {
        unsigned int v112 = (os_log_s *)mDNSLogCategory_Default;
        DNSTypeName(*(unsigned __int16 *)(v11 + 992));
        LogMsgWithLevel( v112,  OS_LOG_TYPE_DEFAULT,  "ProxyClientCallback: ERROR!! Not enough space to return in TCP for %##s (%s)",  v113,  v114,  v115,  v116,  v117,  (int)v19);
      }
    }

    else
    {
      *(_BYTE *)(*(void *)(v11 + 1016) + 2LL) |= 2u;
    }

    uint64_t v86 = v48;
    goto LABEL_142;
  }

  if (mDNS_LoggingEnabled == 1) {
    LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "ProxyClientCallback: No response",  v31,  v32,  v33,  v34,  v35,  v154);
  }
  v118 = *(_WORD *)(v11 + 662);
  if (!v118) {
    v118 = 640;
  }
  int v119 = *(void *)(v11 + 1016);
  *(_WORD *)int v119 = *(_WORD *)(v11 + 30);
  *(_WORD *)(v119 + 2) = v118;
  *(void *)(v119 + 4) = 0LL;
  uint64_t v86 = putQuestion( *(void *)(v11 + 1016),  *(void *)(v11 + 1016) + 12LL,  *(void *)(v11 + 1016) + 12LL + *(unsigned __int16 *)(v11 + 1008),  v19,  *(unsigned __int16 *)(v11 + 992),  *(unsigned __int16 *)(v11 + 660),  v34,  v35);
  if (v86)
  {
LABEL_142:
    if (!v157)
    {
      if (mDNS_LoggingEnabled == 1)
      {
        int v148 = (os_log_s *)mDNSLogCategory_Default;
        GetRRDisplayString_rdb(a3, (unsigned __int16 *)(*((void *)a3 + 5) + 4LL), (_BYTE *)(a1 + 46976));
        LogMsgWithLevel( v148,  OS_LOG_TYPE_DEFAULT,  "ProxyClientCallback: Received %s, not answering yet",  v149,  v150,  v151,  v152,  v153,  a1 + 46976);
      }

      return;
    }

LABEL_68:
          int v32 = v34;
        }

        else
        {
          int v32 = 0;
        }

      uint64_t v56 = *(void *)(v56 + 6384);
      if (!v56) {
        goto LABEL_79;
      }
    }

    LogMsgWithLevel( v57[170],  OS_LOG_TYPE_DEFAULT,  "%s mDNSMacOSXNetworkChanged: requesting BPF",  v51,  v52,  v53,  v54,  v55,  v56 + 6310);
    *(_DWORD *)(v56 + 6436) = -2;
    if (mDNSMacOSXNetworkChanged_once != -1) {
      dispatch_once(&mDNSMacOSXNetworkChanged_once, &__block_literal_global_3525);
    }
    uint64_t v58 = (dispatch_object_s *)mDNSMacOSXNetworkChanged_queue;
    int v59 = v57[170];
    if (gSensitiveLoggingEnabled != 1 || v59 == (os_log_s *)mDNSLogCategory_State)
    {
      if (os_log_type_enabled(v59, OS_LOG_TYPE_DEBUG))
      {
LABEL_71:
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v59, OS_LOG_TYPE_DEBUG, "Requesting BPF from helper", buf, 2u);
      }
    }

    else
    {
      int v59 = (os_log_s *)mDNSLogCategory_Default_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEBUG)) {
        goto LABEL_71;
      }
    }

    uint64_t v62 = xpc_dictionary_create(0LL, 0LL, 0LL);
    xpc_dictionary_set_string(v62, "command", "bpf_open");
    xpc_dictionary_set_int64(v62, "open_flags", 2LL);
    dispatch_retain(v58);
    int v63 = _Block_copy(&__block_literal_global_126_3526);
    *(void *)aBlock = _NSConcreteStackBlock;
    *(void *)&aBlock[8] = 0x40000000LL;
    *(void *)&aBlock[16] = __mhc_bpf_open_block_invoke;
    *(void *)&aBlock[24] = &unk_10013E5F0;
    __int16 v94 = v63;
    int v95 = v58;
    if (_mhc_queue_s_once != -1) {
      dispatch_once(&_mhc_queue_s_once, &__block_literal_global_12_6401);
    }
    mach_service = xpc_connection_create_mach_service( "com.apple.mDNSResponder_Helper",  (dispatch_queue_t)_mhc_queue_s_queue,  2uLL);
    *(void *)buf = _NSConcreteStackBlock;
    *(void *)&buf[8] = 0x40000000LL;
    *(void *)&v77[0] = ___mhc_create_connection_block_invoke;
    *((void *)&v77[0] + 1) = &__block_descriptor_tmp_10_6415;
    *(void *)&v77[1] = mach_service;
    xpc_connection_set_event_handler(mach_service, buf);
    xpc_connection_activate(mach_service);
    xpc_retain(v62);
    uint64_t v65 = _Block_copy(aBlock);
    if (_mhc_queue_s_once != -1) {
      dispatch_once(&_mhc_queue_s_once, &__block_literal_global_12_6401);
    }
    *(void *)buf = _NSConcreteStackBlock;
    *(void *)&buf[8] = 0x40000000LL;
    *(void *)&v77[0] = ___mhc_send_message_with_reply_block_invoke;
    *((void *)&v77[0] + 1) = &unk_10013E658;
    *((void *)&v77[1] + 1) = mach_service;
    *(void *)&__int16 v78 = v62;
    *(void *)&v77[1] = v65;
    xpc_connection_send_message_with_reply(mach_service, v62, (dispatch_queue_t)_mhc_queue_s_queue, buf);
    if (v62) {
      xpc_release(v62);
    }
    uint64_t v57 = (os_log_s **)&unk_100164000;
    goto LABEL_68;
  }

  uint64_t v15 = (void *)IfAddrs;
  while (1)
  {
    uint64_t v16 = v15[3];
    if (v16 && *(_BYTE *)(v16 + 1) == 30)
    {
      int v91 = 0u;
      unint64_t v92 = 0u;
      uint64_t v89 = 0u;
      uint64_t v90 = 0u;
      uint64_t v87 = 0u;
      uint64_t v88 = 0u;
      uint64_t v85 = 0u;
      uint64_t v86 = 0u;
      uint64_t v83 = 0u;
      __int16 v84 = 0u;
      uint64_t v81 = 0u;
      __int16 v82 = 0u;
      uint64_t v79 = 0u;
      __int16 v80 = 0u;
      __int16 v78 = 0u;
      *(_OWORD *)buf = 0u;
      memset(v77, 0, sizeof(v77));
      uint64_t v17 = v15[1];
      if (!v17) {
        __break(1u);
      }
      unsigned int v18 = 0LL;
      while (1)
      {
        uint64_t v19 = *(unsigned __int8 *)(v17 + v18);
        buf[v18] = v19;
        if (!v19) {
          break;
        }
        if (++v18 == 15)
        {
          buf[15] = 0;
          break;
        }
      }

      uint64_t v20 = (__int128 *)v15[3];
      unsigned int v21 = *v20;
      *(_OWORD *)((char *)v77 + 12) = *(__int128 *)((char *)v20 + 12);
      v77[0] = v21;
      if (ioctl(v13, 0xC1206949uLL, buf) != -1 && (v77[0] & 2) != 0) {
        break;
      }
    }

    uint64_t v15 = (void *)*v15;
    if (!v15) {
      goto LABEL_19;
    }
  }

  __int16 v74 = (os_log_s *)mDNSLogCategory_State;
  if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)aBlock = 141558531;
    *(void *)&aBlock[4] = 1752392040LL;
    *(_WORD *)&aBlock[12] = 1045;
    *(_DWORD *)&aBlock[14] = 16;
    *(_WORD *)&aBlock[18] = 2101;
    *(void *)&aBlock[20] = (char *)v77 + 8;
    _os_log_impl( (void *)&_mh_execute_header,  v74,  OS_LOG_TYPE_DEFAULT,  "*** Network Configuration Change ***  IPv6 address %{sensitive, mask.hash, network:in6_addr}.16P TENTATIVE, will retry",  aBlock,  0x1Cu);
  }

  close(v13);
  mDNS_Lock_((unsigned int *)mDNSStorage, (uint64_t)"mDNSMacOSXNetworkChanged", 6379);
  SetNetworkChanged(500);
  mDNS_Unlock_((uint64_t)mDNSStorage, (uint64_t)"mDNSMacOSXNetworkChanged", 6381);
}

      __int16 v84 = (void *)(v82 + 88);
      uint64_t v83 = *(int8x16_t **)(v82 + 88);
      if (!v83) {
        goto LABEL_105;
      }
      while (1)
      {
        if (v83->i64[0]) {
          v83[2].i32[3] |= 0x1000000u;
        }
        uint64_t v85 = v83->u32[3];
        uint64_t v86 = (v83->i32[2] - v85);
        v83[1] = vrev32q_s8(v83[1]);
        v83[2].i32[2] = bswap32(v83[2].u32[2]);
        uint64_t v87 = send(*(_DWORD *)(v82 + 168), &v83[1].i8[v85], v86, 0);
        v83[1] = vrev32q_s8(v83[1]);
        v83[2].i32[2] = bswap32(v83[2].u32[2]);
        if ((v87 & 0x8000000000000000LL) == 0) {
          goto LABEL_75;
        }
        if (*__error() != 4 && *__error() != 35) {
          break;
        }
        LODWORD(v87) = 0;
LABEL_75:
        uint64_t v88 = v83->i32[2];
        uint64_t v89 = v83->i32[3] + v87;
        v83->i32[3] = v89;
        if (v89 != v88) {
          goto LABEL_94;
        }
        uint64_t v90 = *(void **)(v82 + 88);
        *(void *)(v82 + 88) = *v90;
        free(v90);
        *(_DWORD *)(v82 + 228) = 0;
        *(_BYTE *)(v82 + 277) = 0;
        uint64_t v83 = *(int8x16_t **)(v82 + 88);
        if (!v83) {
          goto LABEL_105;
        }
      }

      if (*__error() == 32)
      {
        *(_BYTE *)(v82 + 275) = 4;
        if (mDNS_LoggingEnabled == 1) {
          LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "%3d: Could not write data to client PID[%d](%s) because connection is terminated by the client",  v95,  v96,  v97,  v98,  v99,  *(_DWORD *)(v82 + 168));
        }
      }

      else
      {
        unint64_t v100 = (os_log_s *)mDNSLogCategory_Default;
        __error();
        uint64_t v101 = __error();
        strerror(*v101);
        unsigned int v5 = &unk_100164000;
        LogMsgWithLevel( v100,  OS_LOG_TYPE_DEFAULT,  "send_msg ERROR: failed to write %u of %d bytes to fd %d errno %d (%s)",  v102,  v103,  v104,  v105,  v106,  v86);
        uint64_t v81 = &unk_100158000;
        LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "%3d: Could not write data to client PID[%d](%s) because of error - aborting connection",  v107,  v108,  v109,  v110,  v111,  *(_DWORD *)(v82 + 168));
        LogClientInfo(v82);
      }

      abort_request(v82);
LABEL_94:
      if (!*v84) {
        goto LABEL_105;
      }
      unsigned int v112 = v459;
      v459 = v112;
      uint64_t v113 = (os_log_s *)mDNSLogCategory_Default;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
      {
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_102;
        }
      }

      else
      {
        uint64_t v113 = (os_log_s *)*((void *)v5 + 172);
        if (os_log_type_enabled(v113, OS_LOG_TYPE_DEFAULT))
        {
LABEL_102:
          uint64_t v114 = *(_DWORD *)(v82 + 184);
          *(_DWORD *)block = 67109376;
          *(_DWORD *)&block[4] = v114;
          *(_WORD *)&block[8] = 1024;
          *(_DWORD *)&block[10] = v459 - v78;
          _os_log_impl( (void *)&_mh_execute_header,  v113,  OS_LOG_TYPE_DEFAULT,  "[R%u] Could not send all replies. Will try again in %d ticks.",  block,  0xEu);
        }
      }

      if (v81[3141])
      {
        *(_DWORD *)(v82 + 228) = 0;
        goto LABEL_105;
      }

      uint64_t v115 = *(_DWORD *)(v82 + 228);
      if (!v115)
      {
        *(_DWORD *)(v82 + 228) = v466;
LABEL_105:
        unsigned int v4 = (void *)&unk_100164000;
        goto LABEL_106;
      }

      int v116 = -1;
      do
      {
        __int16 v84 = (void *)*v84;
        ++v116;
      }

      while (v84);
      LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "%3d: Could not write data to client PID[%d](%s) after %ld seconds, %d repl%s waiting",  v73,  v74,  v75,  v76,  v77,  *(_DWORD *)(v82 + 168));
      uint64_t v117 = ++*(_BYTE *)(v82 + 277);
      unsigned int v4 = (void *)&unk_100164000;
      if (v117 >= 0x3C)
      {
        LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "%3d: Client PID[%d](%s) unresponsive; aborting connection",
          v73,
          v74,
          v75,
          v76,
          v77,
          *(_DWORD *)(v82 + 168));
        LogClientInfo(v82);
        abort_request(v82);
      }

              uint64_t v33 = v31;
            }

            else
            {
              uint64_t v33 = 0;
            }

            goto LABEL_69;
          }
        }

        else
        {
          uint64_t v26 = (os_log_s *)mDNSLogCategory_mDNS_redacted;
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
          {
            if (v24)
            {
              __int16 v27 = v24;
LABEL_42:
              uint64_t v28 = 257;
              if (v27 < v24 + 256 && v27)
              {
                while (1)
                {
                  uint64_t v29 = *v27;
                  if (v29 > 0x3F)
                  {
LABEL_63:
                    uint64_t v28 = 257;
                    goto LABEL_66;
                  }

                  if (!*v27) {
                    break;
                  }
                  v27 += v29 + 1;
LABEL_45:
                  if (!v27) {
                    goto LABEL_63;
                  }
                }

                uint64_t v28 = (_WORD)v27 - (_WORD)v24 + 1;
              }

    close(v19);
    uint64_t v37 = (os_log_s *)mDNSLogCategory_NAT;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_NAT == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_NAT, OS_LOG_TYPE_DEFAULT))
      {
LABEL_73:
        unint64_t v38 = *((_DWORD *)v12 + 4);
        uint64_t v39 = *__error();
        unint64_t v40 = __error();
        int v41 = strerror(*v40);
        *(_DWORD *)&v48[0].sa_len = 67109634;
        *(_DWORD *)&v48[0].sa_data[2] = v38;
        *(_WORD *)&v48[0].sa_data[6] = 1024;
        *(_DWORD *)&v48[0].sa_data[8] = v39;
        *(_WORD *)&v48[0].sa_data[12] = 2082;
        *(void *)&v48[1].sa_len = v41;
        _os_log_impl( (void *)&_mh_execute_header,  v37,  OS_LOG_TYPE_DEFAULT,  "mDNSPlatformTCPSocket: socket error %d errno %d (%{public}s)",  &v48[0].sa_len,  0x18u);
      }
    }

    else
    {
      uint64_t v37 = (os_log_s *)mDNSLogCategory_NAT_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_NAT_redacted, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_73;
      }
    }

    free(v12);
    return 0LL;
  }

    if (mDNS_LoggingEnabled == 1) {
      LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "Ignoring %d-byte IP packet unknown protocol %d from %#a to %#a",  (uint64_t)a4,  a5,  a6,  (uint64_t)a7,  a8,  a8 - a6);
    }
    return;
  }

  if ((_DWORD)a5 != 17)
  {
    if ((_DWORD)a5 != 58) {
      goto LABEL_68;
    }
    uint64_t v29 = (int8x8_t *)(a3 + 1);
    unsigned __int16 v30 = IPv6CheckSum((uint64_t)(a3 + 1), (uint64_t)(a4 + 1), (unsigned __int16 *)a7, a10);
    if (v30)
    {
      if (mDNS_LoggingEnabled == 1) {
        LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "IPv6CheckSum bad %04X %02X%02X from %#a to %#a",  v31,  v32,  v33,  v34,  v35,  v30);
      }
      return;
    }

    int v44 = v13 + 12664;
    do
    {
      int v44 = *(void *)v44;
      if (!v44) {
        return;
      }
    }

    while (*(void *)(v44 + 6256) != a9);
    unsigned __int16 v45 = v13;
    mDNS_Lock_((unsigned int *)v13, (uint64_t)"mDNSCoreReceiveRawND", 17967);
    if (a7->u8[0] != 135 || (uint64_t v49 = *(void *)(v13 + 12624)) == 0)
    {
LABEL_113:
      if (*a2 != *(unsigned __int16 *)(v44 + 6304)
        || a2[1] != *(unsigned __int16 *)(v44 + 6306)
        || a2[2] != *(unsigned __int16 *)(v44 + 6308))
      {
        __int16 v78 = a7->u8[0] == 136 ? &a7[1] : v29;
        if (v78->i32[0] || v78->i32[1] || v78[1].i32[0] || v78[1].i32[1])
        {
          uint64_t v79 = *(void *)(v45 + 12624);
          if (v79)
          {
            __int16 v80 = v44 + 6310;
            do
            {
              if (*(void *)(v79 + 32) == a9
                && *(_BYTE *)(v79 + 8) != 1
                && *(_DWORD *)(v79 + 144) == 6
                && *(_DWORD *)(v79 + 148) == v78->i32[0]
                && *(_DWORD *)(v79 + 152) == v78->i32[1]
                && *(_DWORD *)(v79 + 156) == v78[1].i32[0]
                && *(_DWORD *)(v79 + 160) == v78[1].i32[1]
                && *(unsigned __int8 *)(v79 + 189) <= 0x13u)
              {
                if (*(_WORD *)(v79 + 126) || *(_WORD *)(v79 + 128) || *(_WORD *)(v79 + 130))
                {
                  RestartARPProbing((_DWORD *)v45, v79);
                  if (*a2 == *(unsigned __int16 *)(v79 + 132)
                    && a2[1] == *(unsigned __int16 *)(v79 + 134)
                    && a2[2] == *(unsigned __int16 *)(v79 + 136))
                  {
                    if (mDNS_LoggingEnabled == 1)
                    {
                      int v154 = (os_log_s *)mDNSLogCategory_Default;
                      GetRRDisplayString_rdb( (unsigned __int8 *)(v79 + 8),  (unsigned __int16 *)(*(void *)(v79 + 48) + 4LL),  (_BYTE *)(v45 + 46976));
                      LogMsgWithLevel( v154,  OS_LOG_TYPE_DEFAULT,  "%-7s NDP %s from owner %.6a %.16a for %.16a -- re-starting probing for %s",  v81,  v82,  v83,  v84,  v85,  v80);
                    }
                  }

                  else
                  {
                    unsigned __int16 v150 = (os_log_s *)mDNSLogCategory_Default;
                    GetRRDisplayString_rdb( (unsigned __int8 *)(v79 + 8),  (unsigned __int16 *)(*(void *)(v79 + 48) + 4LL),  (_BYTE *)(v45 + 46976));
                    LogMsgWithLevel( v150,  OS_LOG_TYPE_DEFAULT,  "%-7s Conflicting NDP from %.6a %.16a for %.16a -- waking H-MAC %.6a I-MAC %.6a %s",  v86,  v87,  v88,  v89,  v90,  v80);
                    ScheduleWakeup( v45,  *(void *)(v79 + 32),  (unsigned __int16 *)(v79 + 126),  v91,  v92,  v93,  v94,  v95,  v140);
                  }
                }

                else if (mDNS_LoggingEnabled == 1)
                {
                  int v151 = (os_log_s *)mDNSLogCategory_Default;
                  GetRRDisplayString_rdb( (unsigned __int8 *)(v79 + 8),  (unsigned __int16 *)(*(void *)(v79 + 48) + 4LL),  (_BYTE *)(v45 + 46976));
                  LogMsgWithLevel( v151,  OS_LOG_TYPE_DEFAULT,  "%-7s NDP from %.6a %.16a for %.16a -- Invalid H-MAC %.6a I-MAC %.6a %s",  v96,  v97,  v98,  v99,  v100,  v80);
                }
              }

              uint64_t v79 = *(void *)v79;
            }

            while (v79);
          }
        }
      }

      mDNS_Unlock_(v45, (uint64_t)"mDNSCoreReceiveRawND", 18043);
      return;
    }

    int v50 = v44 + 6310;
    int v51 = (_BYTE *)(v13 + 46976);
    uint64_t v52 = "NDP Req from owner -- re-probing";
    uint64_t v53 = &unk_100158000;
    int v54 = &unk_100164000;
    uint64_t v55 = "Reached maximum number of restarts for probing - %s";
    uint64_t v56 = &AllHosts_v6;
    uint64_t v57 = &AllHosts_v6_Eth;
    while (1)
    {
      if (*(void *)(v49 + 32) != a9
        || *(_BYTE *)(v49 + 8) == 1
        || *(_DWORD *)(v49 + 144) != 6
        || *(_DWORD *)(v49 + 148) != a7[1].i32[0]
        || *(_DWORD *)(v49 + 152) != a7[1].i32[1]
        || *(_DWORD *)(v49 + 156) != a7[2].i32[0]
        || *(_DWORD *)(v49 + 160) != a7[2].i32[1])
      {
        goto LABEL_112;
      }

      __int16 v153 = v50;
      uint64_t v58 = *a2;
      if (v58 != *(unsigned __int16 *)(v49 + 132)
        || a2[1] != *(unsigned __int16 *)(v49 + 134)
        || (int v59 = (char *)v52, a2[2] != *(unsigned __int16 *)(v49 + 136)))
      {
        int v59 = "Ignoring  NDP Request from      ";
        if (*(_BYTE *)(v49 + 191) != 4)
        {
          if (v58 != *(unsigned __int16 *)(v44 + 6304)
            || a2[1] != *(unsigned __int16 *)(v44 + 6306)
            || (int v59 = "Creating Local NDP Cache entry  ", a2[2] != *(unsigned __int16 *)(v44 + 6308)))
          {
            else {
              int v59 = "Answering NDP Request from      ";
            }
          }
        }
      }

      uint64_t v156 = v51;
      if (v53[2840] == 1)
      {
        uint64_t v144 = (os_log_s *)*((void *)v54 + 170);
        int v146 = v59;
        GetRRDisplayString_rdb((unsigned __int8 *)(v49 + 8), (unsigned __int16 *)(*(void *)(v49 + 48) + 4LL), v51);
        LogMsgWithLevel( v144,  OS_LOG_TYPE_DEFAULT,  "%-7s %s %.6a %.16a for %.16a -- H-MAC %.6a I-MAC %.6a %s",  v60,  v61,  v62,  v63,  v64,  v153);
        int v59 = v146;
        uint64_t v57 = &AllHosts_v6_Eth;
        uint64_t v56 = &AllHosts_v6;
        uint64_t v55 = "Reached maximum number of restarts for probing - %s";
        int v54 = &unk_100164000;
        uint64_t v53 = &unk_100158000;
        uint64_t v52 = "NDP Req from owner -- re-probing";
        int v51 = v156;
      }

      if (v59 == v52)
      {
        if (*(unsigned __int8 *)(v49 + 189) <= 0x13u)
        {
          int v67 = v51;
          uint64_t v68 = v52;
          RestartARPProbing((_DWORD *)v45, v49);
          uint64_t v57 = &AllHosts_v6_Eth;
          uint64_t v56 = &AllHosts_v6;
          uint64_t v55 = "Reached maximum number of restarts for probing - %s";
          int v54 = &unk_100164000;
          uint64_t v53 = (_BYTE *)&unk_100158000;
          uint64_t v52 = v68;
          int v51 = v67;
LABEL_111:
          int v50 = v153;
          goto LABEL_112;
        }

        int v50 = v153;
        if (v53[2840] == 1)
        {
          int v149 = (os_log_s *)*((void *)v54 + 170);
          uint64_t v71 = v51;
          int v72 = (char *)v55;
          GetRRDisplayString_rdb((unsigned __int8 *)(v49 + 8), (unsigned __int16 *)(*(void *)(v49 + 48) + 4LL), v51);
          LogMsgWithLevel(v149, OS_LOG_TYPE_DEFAULT, v72, v73, v74, v75, v76, v77, (int)v71);
          uint64_t v57 = &AllHosts_v6_Eth;
          uint64_t v56 = &AllHosts_v6;
          uint64_t v55 = v72;
          int v54 = &unk_100164000;
          uint64_t v53 = (_BYTE *)&unk_100158000;
          uint64_t v52 = "NDP Req from owner -- re-probing";
          int v51 = v71;
          goto LABEL_111;
        }
      }

      else
      {
        if (v59 == "Creating Local NDP Cache entry  ")
        {
          uint64_t v69 = v52;
          uint64_t v70 = v53;
          mDNSPlatformSetLocalAddressCacheEntry( (int *)(v49 + 144),  (const void *)(v49 + 132),  a9,  v46,  v47,  v48,  (uint64_t)v56,  (uint64_t)v57,  v139);
LABEL_109:
          uint64_t v57 = &AllHosts_v6_Eth;
          uint64_t v56 = &AllHosts_v6;
          uint64_t v55 = "Reached maximum number of restarts for probing - %s";
          int v54 = &unk_100164000;
          uint64_t v53 = v70;
          uint64_t v52 = v69;
          goto LABEL_110;
        }

        if (v59 == "Answering NDP Request from      ")
        {
          uint64_t v69 = v52;
          uint64_t v70 = v53;
          SendNDP(v45, 136, 64, v49, a7 + 1, 0LL, (uint64_t)v29, (uint64_t)a2);
          goto LABEL_109;
        }

        int v50 = v153;
        if (v59 == "Answering NDP Probe   from      ")
        {
          uint64_t v65 = v56;
          uint64_t v66 = v57;
          SendNDP(v45, 136, 0, v49, a7 + 1, 0LL, (uint64_t)v56, (uint64_t)v57);
          uint64_t v57 = v66;
          uint64_t v56 = v65;
          uint64_t v55 = "Reached maximum number of restarts for probing - %s";
          int v54 = &unk_100164000;
          uint64_t v53 = (_BYTE *)&unk_100158000;
          uint64_t v52 = "NDP Req from owner -- re-probing";
LABEL_110:
          int v51 = v156;
          goto LABEL_111;
        }
      }

      _dns_push_discovery_stop(a1, &v46, v6, 1);
      uint64_t v42 = *(void *)(v6 + 40);
      int v43 = *(_DWORD *)(v42 + 252);
      int v44 = bswap32(*(unsigned __int16 *)(v42 + 320)) >> 16;
      unsigned __int16 v45 = (os_log_s *)mDNSLogCategory_Default;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
      {
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
        {
LABEL_73:
          *(_DWORD *)buf = 67109376;
          int v50 = v43;
          int v51 = 1024;
          *(_DWORD *)uint64_t v52 = v44;
          _os_log_impl( (void *)&_mh_execute_header,  v45,  OS_LOG_TYPE_DEFAULT,  "[R%u->Q%u] Stopping long-lived DNS polling",  buf,  0xEu);
        }
      }

      else
      {
        unsigned __int16 v45 = (os_log_s *)mDNSLogCategory_Default_redacted;
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_73;
        }
      }

      *(_BYTE *)(v6 + 68) = 0;
      goto LABEL_32;
    }

    if ((v35 & 1) != 0)
    {
      int v36 = mDNSLogCategory_Default_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_68;
      }
    }

    else if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
    {
      goto LABEL_68;
    }

    int v41 = *(void *)(v11 + 16);
    unint64_t v40 = *(void *)(v11 + 24);
    *(_DWORD *)buf = 67110146;
    int v50 = v7;
    int v51 = 1040;
    *(_DWORD *)uint64_t v52 = v40;
    *(_WORD *)&v52[4] = 2098;
    *(void *)&v52[6] = v41;
    uint64_t v53 = 2048;
    int v54 = v27;
    uint64_t v55 = 1024;
    uint64_t v56 = 0;
    uint64_t v37 = "[Q%u] DNS push discovery finished, using service with SRV name _dns-push-tls._tcp.%{public, mdnsresponder:doma"
          "in_name}.*P -- service id: %llu, re registered: %{mdns:yesno}d";
    unint64_t v38 = (os_log_s *)v36;
    uint64_t v39 = 40;
    goto LABEL_67;
  }

      uint64_t v39 = 0LL;
LABEL_69:
      (*(void (**)(uint64_t, void, uint64_t, uint64_t, void *))(a1 + 16))(a1, v26[5], v34, v39, v40);
LABEL_70:
      os_release(v26);
LABEL_71:
      __int16 v23 = *(void *)v23;
    }

    while (v23);
  }

  KQueueUnlock((uint64_t)"enumerate .local records", v11, v12, v13, v14, v15, v16, v17);
  if (Mutable) {
    CFRelease(Mutable);
  }
}

LABEL_69:
        *(_DWORD *)buf = 141560067;
        uint64_t v73 = 1752392040LL;
        __int16 v74 = 1040;
        *(_DWORD *)int v75 = v24;
        *(_WORD *)&v75[4] = 2101;
        *(void *)&v75[6] = v10;
        __int16 v76 = 2160;
        uint64_t v77 = 1752392040LL;
        __int16 v78 = 1040;
        *(_DWORD *)uint64_t v79 = (_DWORD)v25;
        *(_WORD *)&v79[4] = 2101;
        *(void *)&v79[6] = v5;
        __int16 v80 = 2160;
        uint64_t v81 = 1752392040LL;
        __int16 v82 = 1040;
        *(_DWORD *)uint64_t v83 = v32;
        *(_WORD *)&v83[4] = 2101;
        *(void *)&v83[6] = a4;
        _os_log_impl( (void *)&_mh_execute_header,  v22,  OS_LOG_TYPE_DEFAULT,  "Bad service type in %{sensitive, mask.hash, mdnsresponder:domain_label}.*P.%{sensitive, mask.hash, mdnsrespond er:domain_name}.*P%{sensitive, mask.hash, mdnsresponder:domain_name}.*P Application protocol name must be unde rscore plus 1-15 characters. See <http://www.dns-sd.org/ServiceTypes.html>",  buf,  0x50u);
      }
    }

    if ((v13 - 64) < 0xFFFFFFC2
      || v13 >= 0x11 && !SameDomainNameBytes(a4, "\x05local"))
    {
      return 0LL;
    }
  }

  if (v5[1] != 95)
  {
    unint64_t v12 = "Application protocol name must begin with underscore";
    goto LABEL_141;
  }

  int v36 = 0;
  uint64_t v37 = v5 + 256;
  unint64_t v38 = v13;
  uint64_t v39 = (v13 + 1);
  unint64_t v40 = 2LL;
  do
  {
    int v41 = v5[v40];
    if (v41 != 45)
    {
      if (v40 >= v38 || v40 < 3 || v41 != 95)
      {
LABEL_127:
        uint64_t v7 = (_BYTE *)&unk_100164000;
        uint64_t v8 = &unk_100164000;
        uint64_t v9 = (os_log_s **)&unk_100164000;
        unint64_t v12 = "Application protocol name must contain only letters, digits, and hyphens";
        goto LABEL_141;
      }

      if (v36) {
        goto LABEL_116;
      }
      int v43 = (os_log_s *)mDNSLogCategory_Default;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
      {
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
        {
          unsigned int v47 = v5;
LABEL_102:
          unsigned __int16 v45 = 257;
          if (v47 < v37 && v47)
          {
            while (1)
            {
              uint64_t v48 = *v47;
              if (v48 > 0x3F)
              {
LABEL_111:
                unsigned __int16 v45 = 257;
                goto LABEL_115;
              }

              if (!*v47) {
                break;
              }
              v47 += v48 + 1;
LABEL_105:
              if (!v47) {
                goto LABEL_111;
              }
            }

            unsigned __int16 v45 = (_WORD)v47 - (_WORD)v5 + 1;
          }

          goto LABEL_115;
        }
      }

      else
      {
        int v43 = (os_log_s *)mDNSLogCategory_Default_redacted;
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
        {
          int v44 = v5;
LABEL_92:
          unsigned __int16 v45 = 257;
          if (v44 < v37 && v44)
          {
            while (1)
            {
              uint64_t v46 = *v44;
              if (v46 > 0x3F)
              {
LABEL_110:
                unsigned __int16 v45 = 257;
                goto LABEL_115;
              }

              if (!*v44) {
                break;
              }
              v44 += v46 + 1;
LABEL_95:
              if (!v44) {
                goto LABEL_110;
              }
            }

            unsigned __int16 v45 = (_WORD)v44 - (_WORD)v5 + 1;
          }

  if (v47[1]) {
    unint64_t v40 = v47;
  }
  else {
    unint64_t v40 = 0LL;
  }
  else {
    int v41 = 0LL;
  }
  if (v12) {
    uint64_t v42 = v45;
  }
  else {
    uint64_t v42 = 0LL;
  }
  mDNS_SetPrimaryInterfaceInfo((uint64_t)v40, v41, (uint64_t)v42);
}

            unsigned __int16 v34 = bswap32(*(unsigned __int16 *)(*(void *)(a2 + 2456) + 8LL)) >> 16;
            *(_DWORD *)buf = 67110659;
            __int16 v94 = v18;
            int v95 = 2160;
            int v96 = 1752392040LL;
            BOOL v97 = 1040;
            BOOL v98 = v33;
            BOOL v99 = 2101;
            unint64_t v100 = v24;
            uint64_t v101 = 1024;
            uint64_t v102 = v25;
            uint64_t v103 = 1024;
            size_t v104 = v34;
            uint64_t v105 = 2080;
            unsigned int v106 = v19;
            _os_log_impl( (void *)&_mh_execute_header,  v26,  OS_LOG_TYPE_DEFAULT,  "[R%u] DNSServiceRegister(%{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%x), %u) %s",  buf,  0x38u);
          }
        }

        unint64_t v12 = *(void *)(v10 + 8);
        goto LABEL_71;
      }
    }

    uint64_t v19 = "REGISTERED";
    goto LABEL_37;
  }

  KQueueUnlock((uint64_t)"_Querier_HandleQuerierResponse", v36, v37, v38, v39, v40, v41, v42);
  os_release(*(void **)(a1 + 32));
}

    unsigned __int16 v30 = *v25;
    if (!*v25)
    {
      AllocAndCopy((void *)(v9 + 15000), *(char **)(v9 + 14992), v29, v15, v16, v17, v18, v19, v40);
      unsigned __int16 v30 = *(void *)(v9 + 15000);
      if (!v30)
      {
        uint64_t v37 = (os_log_s *)mDNSLogCategory_Default;
        unint64_t v38 = "handleLNTDeviceDescriptionResponse: UPnPSOAPAddressString is NULL";
        goto LABEL_73;
      }
    }

LABEL_115:
          *(_DWORD *)buf = 141558531;
          uint64_t v73 = 1752392040LL;
          __int16 v74 = 1040;
          *(_DWORD *)int v75 = v45;
          *(_WORD *)&v75[4] = 2101;
          *(void *)&v75[6] = v5;
          _os_log_impl( (void *)&_mh_execute_header,  v43,  OS_LOG_TYPE_DEFAULT,  "ConstructServiceName: Service type with non-leading underscore %{sensitive, mask.hash, mdnsresponder:domain_name}.*P",  buf,  0x1Cu);
        }
      }

        uint64_t v10 = *(unsigned __int8 *)(v8 + 275);
        goto LABEL_116;
      }

      uint64_t v15 = *(_DWORD *)(v8 + 196) + v14;
      *(_DWORD *)(v8 + 196) = v15;
      if (v15 >= 0x1D)
      {
        v1290 = mDNSLogCategory_Default;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
        {
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_ERROR)) {
            goto LABEL_2251;
          }
          v1305 = *(_DWORD *)(v8 + 184);
          v1489.st_dev = 67109120;
          *(_DWORD *)&v1489.st_mode = v1305;
          v1293 = "[R%u] ERROR: read_msg - read too many header bytes";
        }

        else
        {
          v1290 = mDNSLogCategory_Default_redacted;
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_ERROR)) {
            goto LABEL_2251;
          }
          v1303 = *(_DWORD *)(v8 + 184);
          v1489.st_dev = 67109120;
          *(_DWORD *)&v1489.st_mode = v1303;
          v1293 = "[R%u] ERROR: read_msg - read too many header bytes";
        }

        goto LABEL_2221;
      }

      if (v15 != 28) {
        goto LABEL_115;
      }
      uint64_t v16 = vrev32q_s8(*(int8x16_t *)(v8 + 200));
      *(int8x16_t *)(v8 + 200) = v16;
      *(_DWORD *)(v8 + 224) = bswap32(*(_DWORD *)(v8 + 224));
      uint64_t v17 = v16.i32[0];
      if (v16.i32[0] == 1)
      {
        unsigned int v18 = v16.u32[1];
        if (v16.i32[1] < 0x11171u)
        {
          uint64_t v19 = (char *)calloc(1uLL, (v16.i32[1] + 5));
          if (!v19) {
            goto LABEL_2255;
          }
          *(void *)(v8 + 64) = v19;
          *(void *)(v8 + 72) = v19;
          *(void *)(v8 + 80) = &v19[*(unsigned int *)(v8 + 204)];
          LODWORD(v13) = *(_DWORD *)(v8 + 196);
LABEL_19:
          if ((_DWORD)v13 != 28) {
            goto LABEL_115;
          }
          uint64_t v20 = *(void *)(v8 + 56);
          unsigned int v21 = *(unsigned int *)(v8 + 204);
          if (v21 > v20)
          {
            *(void *)buf = *(void *)(v8 + 64) + v20;
            *(void *)&buf[8] = v21 - v20;
            *(&v1489.st_rdev + 1) = 0;
            memset(__src, 0, 28);
            *(void *)&v1489.st_dev = 0LL;
            v1489.st_ino = 0LL;
            *(void *)&v1489.st_uid = buf;
            v1489.st_rdev = 1;
            v1489.st_atimespec.tv_sec = (__darwin_time_t)__src;
            v1489.st_atimespec.tv_nsec = 28LL;
            uint64_t v22 = recvmsg(*(_DWORD *)(v8 + 168), (msghdr *)&v1489, 0);
            if (!v22)
            {
              uint64_t v10 = 4;
              goto LABEL_36;
            }

            if (v22 < 0) {
              goto LABEL_28;
            }
            uint64_t v20 = *(void *)(v8 + 56) + v22;
            *(void *)(v8 + 56) = v20;
            unsigned int v21 = *(unsigned int *)(v8 + 204);
            if (v20 > v21)
            {
              __int16 v23 = mDNSLogCategory_Default;
              if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
              {
                if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_ERROR)) {
                  goto LABEL_35;
                }
              }

              else
              {
                __int16 v23 = mDNSLogCategory_Default_redacted;
                if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_ERROR)) {
                  goto LABEL_35;
                }
              }

              int v24 = *(_DWORD *)(v8 + 184);
              *(_DWORD *)&v1504[0].sa_len = 67109120;
              *(_DWORD *)&v1504[0].sa_data[2] = v24;
              __int16 v25 = v1504;
              uint64_t v26 = (os_log_s *)v23;
              __int16 v27 = OS_LOG_TYPE_ERROR;
              uint64_t v28 = "[R%u] ERROR: read_msg - read too many data bytes";
LABEL_33:
              unsigned __int16 v30 = 8;
LABEL_34:
              _os_log_impl((void *)&_mh_execute_header, v26, v27, v28, &v25->sa_len, v30);
              goto LABEL_35;
            }

            if ((*(_BYTE *)(v8 + 208) & 4) == 0 && LODWORD(v1489.st_atimespec.tv_nsec) >= 0xC)
            {
              if (v1489.st_atimespec.tv_sec)
              {
                if (*(_DWORD *)(v1489.st_atimespec.tv_sec + 4) == 0xFFFF
                  && *(_DWORD *)(v1489.st_atimespec.tv_sec + 8) == 1)
                {
                  uint64_t v31 = *(_DWORD *)(v1489.st_atimespec.tv_sec + 12);
                  *(_DWORD *)(v8 + 176) = v31;
                  if (v20 < v21)
                  {
                    int v32 = mDNSLogCategory_Default;
                    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
                    {
                      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEBUG)) {
                        goto LABEL_35;
                      }
                    }

                    else
                    {
                      int v32 = mDNSLogCategory_Default_redacted;
                      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEBUG)) {
                        goto LABEL_35;
                      }
                    }

                    uint64_t v65 = *(_DWORD *)(v8 + 184);
                    uint64_t v66 = *(_DWORD *)(v8 + 172);
                    *(_DWORD *)&v1504[0].sa_len = 67110402;
                    *(_DWORD *)&v1504[0].sa_data[2] = v65;
                    *(_WORD *)&v1504[0].sa_data[6] = 1024;
                    *(_DWORD *)&v1504[0].sa_data[8] = v66;
                    *(_WORD *)&v1504[0].sa_data[12] = 2082;
                    *(void *)&v1504[1].sa_len = v8 + 240;
                    *(_WORD *)&v1504[1].sa_data[6] = 1024;
                    *(_DWORD *)&v1504[1].sa_data[8] = v31;
                    *(_WORD *)&v1504[1].sa_data[12] = 2048;
                    *(void *)&v1505 = v20;
                    WORD4(v1505) = 1024;
                    *(_DWORD *)((char *)&v1505 + 10) = v21;
                    __int16 v25 = v1504;
                    uint64_t v26 = (os_log_s *)v32;
                    __int16 v27 = OS_LOG_TYPE_DEBUG;
                    uint64_t v28 = "[R%u] Client(PID [%d](%{public}s)) sent result code socket %d via SCM_RIGHTS with req->data_by"
                          "tes %lu < req->hdr.datalen %d";
                    unsigned __int16 v30 = 46;
                    goto LABEL_34;
                  }
                }
              }
            }

            if (*(_DWORD *)(v8 + 196) != 28) {
              goto LABEL_115;
            }
          }

          if (v20 != v21) {
            goto LABEL_115;
          }
          if ((*(_BYTE *)(v8 + 208) & 4) != 0 || !*(void *)(v8 + 96) || *(_DWORD *)(v8 + 212) == 63)
          {
LABEL_53:
            *(_BYTE *)(v8 + 275) = 2;
            goto LABEL_117;
          }

          memset(v1508, 0, 26);
          v1507 = 0u;
          v1506 = 0u;
          v1505 = 0u;
          memset(v1504, 0, sizeof(v1504));
          *(void *)&v1463 = 0LL;
          v1462 = 0u;
          memset(v1461, 0, sizeof(v1461));
          memset(__src, 0, sizeof(__src));
          if (*(void *)(v8 + 72))
          {
            uint64_t v33 = *(void *)(v8 + 80);
            unsigned __int16 v34 = __src;
            while (1)
            {
              uint64_t v35 = *(unsigned __int8 **)(v8 + 72);
              *(void *)(v8 + 72) = v35 + 1;
              uint64_t v37 = *v35;
              *(_BYTE *)unsigned __int16 v34 = v37;
              unsigned __int16 v34 = (socklen_t *)((char *)v34 + 1);
              if (!v37) {
                goto LABEL_65;
              }
            }

            *((_BYTE *)v34 - (v34 == (socklen_t *)((char *)&v1463 + 8))) = 0;
            *(void *)(v8 + 72) = 0LL;
          }

      int v41 = 136446979;
      uint64_t v42 = "automatic browse domain";
      int v43 = 2160;
      *(void *)int v44 = 1752392040LL;
      *(_WORD *)&v44[8] = 1040;
      *(_DWORD *)&v44[10] = v34;
      unsigned __int16 v45 = 2101;
      *(void *)uint64_t v46 = a2;
      _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEBUG,  "Stopping the %{public}s enumeration - domain: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P.",  (uint8_t *)&v41,  0x26u);
LABEL_116:
      unint64_t result = mDNS_StopQuery_internal((uint64_t)a1, (uint64_t)(v4 + 2));
      if (!(_DWORD)result)
      {
        mDNS_DeregisterDomainsDiscoveredForDomainEnumeration(a1, a2, 2LL, v36, v37, v38, v39, v40);
        unint64_t result = 0LL;
        v4[166] = 0;
      }

      return result;
    }

    unsigned int v18 = (os_log_s *)mDNSLogCategory_mDNS;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
      {
LABEL_111:
        unint64_t result = 0LL;
LABEL_112:
        v4[166] = 1;
        return result;
      }

      uint64_t v20 = (_BYTE *)a2;
      if (a2 == -256)
      {
LABEL_52:
        while (v20)
        {
          unsigned int v21 = *v20;
          if (!*v20)
          {
            uint64_t v33 = (unsigned __int16)((_WORD)v20 - a2 + 1);
            goto LABEL_110;
          }

          v20 += v21 + 1;
          if (a2 != -256) {
            goto LABEL_51;
          }
        }
      }

      else
      {
LABEL_51:
      }

      uint64_t v33 = 257;
    }

    else
    {
      unsigned int v18 = (os_log_s *)mDNSLogCategory_mDNS_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_111;
      }
      __int16 v27 = (_BYTE *)a2;
      if (a2 == -256)
      {
LABEL_76:
        while (v27)
        {
          uint64_t v28 = *v27;
          if (!*v27)
          {
            uint64_t v33 = (unsigned __int16)((_WORD)v27 - a2 + 1);
            goto LABEL_110;
          }

          v27 += v28 + 1;
          if (a2 != -256) {
            goto LABEL_75;
          }
        }
      }

      else
      {
LABEL_75:
      }

      uint64_t v33 = 257;
    }

    *((_DWORD *)v30 + 679) = -1;
    while (1)
    {
      unsigned __int16 v30 = (uint64_t *)*v30;
      if (!v30) {
        break;
      }
      if (*((_BYTE *)v30 + 16)) {
        goto LABEL_115;
      }
    }
  }

LABEL_116:
      int v36 = 1;
      goto LABEL_117;
    }

    if (v40 < 3 || v40 >= v38) {
      goto LABEL_127;
    }
LABEL_117:
    ++v40;
  }

  while (v40 != v39);
  uint64_t v49 = 0LL;
  do
  {
    *(_BYTE *)(v19 + v49) = v5[v49];
    ++v49;
  }

  while ((_DWORD)v39 != (_DWORD)v49);
  uint64_t v8 = &unk_100164000;
  uint64_t v9 = (os_log_s **)&unk_100164000;
  if (v5[v49] != 4)
  {
    unint64_t v12 = "Transport protocol name must be _udp or _tcp";
    uint64_t v7 = (_BYTE *)&unk_100164000;
    goto LABEL_141;
  }

  int v50 = &v5[v49];
  uint64_t v7 = &unk_100164000;
  if (v5[v49 + 1] != 95) {
    goto LABEL_140;
  }
  int v51 = v50[2] & 0xDF;
  if (v51 == 84)
  {
    if ((v50[3] & 0xDF) != 0x43) {
      goto LABEL_140;
    }
  }

  else if (v51 != 85 || (v50[3] & 0xDF) != 0x44)
  {
LABEL_140:
    unint64_t v12 = "Transport protocol name must be _udp or _tcp";
    goto LABEL_141;
  }

  if ((v50[4] & 0xDF) != 0x50) {
    goto LABEL_140;
  }
  uint64_t v56 = 0LL;
  do
  {
    *(_BYTE *)(v19 + v56 + v49) = v5[v56 + v49];
    ++v56;
  }

  while ((_DWORD)v56 != 5);
  if (v5[v49 + v56])
  {
    unint64_t v12 = "Service type must have only two labels";
    goto LABEL_141;
  }

  *(_BYTE *)(v19 + v49 + v56) = 0;
  if (!*a4)
  {
    unint64_t v12 = "Service domain must be non-empty";
    goto LABEL_141;
  }

  if (SameDomainNameBytes(a4, "\x05local\x04arpa"))
  {
    unint64_t v12 = "Illegal domain local.arpa. Use local. (or empty string)";
    goto LABEL_141;
  }

  unint64_t result = AppendDomainName(a1, a4);
  if (result) {
    return result;
  }
  unint64_t v12 = "Service domain too long";
LABEL_141:
  uint64_t v57 = (os_log_s *)*((void *)v8 + 170);
  if (v7[1384] != 1 || v57 == v9[171])
  {
    if (!os_log_type_enabled(*((os_log_t *)v8 + 170), OS_LOG_TYPE_DEFAULT)) {
      return 0LL;
    }
    int v59 = *(unsigned __int8 *)v10 + 1;
    if (v5)
    {
      uint64_t v60 = v5;
LABEL_149:
      int v61 = 257;
      if (v60 < v5 + 256 && v60)
      {
        while (1)
        {
          uint64_t v62 = *v60;
          if (v62 > 0x3F)
          {
LABEL_172:
            int v61 = 257;
            goto LABEL_173;
          }

          if (!*v60) {
            break;
          }
          v60 += v62 + 1;
LABEL_152:
          if (!v60) {
            goto LABEL_172;
          }
        }

        int v61 = (unsigned __int16)((_WORD)v60 - (_WORD)v5 + 1);
        if (a4) {
          goto LABEL_174;
        }
      }

      else
      {
LABEL_173:
        if (a4)
        {
LABEL_174:
          uint64_t v66 = a4;
          if (a4 == (_BYTE *)-256LL) {
            goto LABEL_178;
          }
LABEL_175:
          int v67 = 257;
          if (v66 < a4 + 256 && v66)
          {
            while (1)
            {
              uint64_t v68 = *v66;
              if (v68 > 0x3F)
              {
LABEL_194:
                int v67 = 257;
                goto LABEL_203;
              }

              if (!*v66) {
                break;
              }
              v66 += v68 + 1;
              if (a4 != (_BYTE *)-256LL) {
                goto LABEL_175;
              }
LABEL_178:
              if (!v66) {
                goto LABEL_194;
              }
            }

            int v67 = (unsigned __int16)((_WORD)v66 - (_WORD)a4 + 1);
          }

          goto LABEL_203;
        }
      }
    }

    else
    {
      int v61 = 0;
      if (a4) {
        goto LABEL_174;
      }
    }

    int v67 = 0;
    goto LABEL_203;
  }

  uint64_t v57 = (os_log_s *)mDNSLogCategory_Default_redacted;
  if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
    return 0LL;
  }
  int v59 = *(unsigned __int8 *)v10 + 1;
  if (!v5)
  {
    int v61 = 0;
    if (!a4) {
      goto LABEL_199;
    }
LABEL_185:
    uint64_t v69 = a4;
    if (a4 == (_BYTE *)-256LL) {
      goto LABEL_189;
    }
LABEL_186:
    int v67 = 257;
    if (v69 < a4 + 256 && v69)
    {
      while (1)
      {
        uint64_t v70 = *v69;
        if (v70 > 0x3F)
        {
LABEL_195:
          int v67 = 257;
          goto LABEL_203;
        }

        if (!*v69) {
          break;
        }
        v69 += v70 + 1;
        if (a4 != (_BYTE *)-256LL) {
          goto LABEL_186;
        }
LABEL_189:
        if (!v69) {
          goto LABEL_195;
        }
      }

      int v67 = (unsigned __int16)((_WORD)v69 - (_WORD)a4 + 1);
    }

    goto LABEL_203;
  }

  uint64_t v64 = v5;
LABEL_160:
  int v61 = 257;
  if (v64 < v5 + 256 && v64)
  {
    while (1)
    {
      uint64_t v65 = *v64;
      if (v65 > 0x3F)
      {
LABEL_183:
        int v61 = 257;
        goto LABEL_184;
      }

      if (!*v64) {
        break;
      }
      v64 += v65 + 1;
LABEL_163:
      if (!v64) {
        goto LABEL_183;
      }
    }

    int v61 = (unsigned __int16)((_WORD)v64 - (_WORD)v5 + 1);
    if (!a4) {
      goto LABEL_199;
    }
    goto LABEL_185;
  }

              uint64_t v77 = ++mDNSPlatformSendUDP_MessageCount;
              __int16 v78 = gSensitiveLoggingEnabled;
              uint64_t v79 = mDNSLogCategory_Default;
              if (mDNSLogCategory_Default == mDNSLogCategory_State) {
                __int16 v78 = 0;
              }
              if (v77 > 49)
              {
                if ((v78 & 1) != 0)
                {
                  uint64_t v79 = mDNSLogCategory_Default_redacted;
                  if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
                    return 4294901759LL;
                  }
                }

                else if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
                {
                  return 4294901759LL;
                }

                int v95 = bswap32(*a2) >> 16;
                int v96 = strerror(v56);
                BOOL v97 = *((_DWORD *)v109 + 16);
                *(_DWORD *)buf = 67112707;
                *(_DWORD *)uint64_t v111 = v95;
                *(_WORD *)&v111[4] = 1024;
                *(_DWORD *)&v111[6] = v28;
                *(_WORD *)&v111[10] = 2048;
                *(void *)&v111[12] = a4;
                *(_WORD *)&v111[20] = 2082;
                *(void *)&v111[22] = v108;
                unsigned int v112 = 1024;
                uint64_t v113 = v74;
                uint64_t v114 = 2160;
                *(void *)uint64_t v115 = 1752392040LL;
                *(_WORD *)&v115[8] = 1045;
                *(_DWORD *)&v115[10] = 20;
                int v116 = 2101;
                uint64_t v117 = a6;
                v118 = 1024;
                int v119 = bswap32(a7) >> 16;
                uint64_t v120 = 1024;
                uint64_t v121 = v28;
                v122 = 2048;
                int v123 = v55;
                uint64_t v124 = 1024;
                char v125 = v56;
                int v126 = 2082;
                BOOL v127 = v96;
                int v128 = 1024;
                uint64_t v129 = v97;
                unsigned int v130 = 1024;
                int v131 = mDNSPlatformSendUDP_MessageCount;
                uint64_t v88 = "[Q%u] mDNSPlatformSendUDP: sendto(%d) failed to send packet on InterfaceID %p %{public}s/%d to %{s"
                      "ensitive, mask.hash, mdnsresponder:ip_addr}.20P:%d skt %d error %ld errno %d (%{public}s) %u MessageCount is %d";
                uint64_t v89 = (os_log_s *)v79;
                uint64_t v90 = OS_LOG_TYPE_DEFAULT;
              }

              else
              {
                if ((v78 & 1) != 0)
                {
                  uint64_t v79 = mDNSLogCategory_Default_redacted;
                  if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_ERROR)) {
                    return 4294901759LL;
                  }
                }

                else if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_ERROR))
                {
                  return 4294901759LL;
                }

                unint64_t v92 = bswap32(*a2) >> 16;
                int v93 = strerror(v56);
                __int16 v94 = *((_DWORD *)v109 + 16);
                *(_DWORD *)buf = 67112707;
                *(_DWORD *)uint64_t v111 = v92;
                *(_WORD *)&v111[4] = 1024;
                *(_DWORD *)&v111[6] = v28;
                *(_WORD *)&v111[10] = 2048;
                *(void *)&v111[12] = a4;
                *(_WORD *)&v111[20] = 2082;
                *(void *)&v111[22] = v108;
                unsigned int v112 = 1024;
                uint64_t v113 = v74;
                uint64_t v114 = 2160;
                *(void *)uint64_t v115 = 1752392040LL;
                *(_WORD *)&v115[8] = 1045;
                *(_DWORD *)&v115[10] = 20;
                int v116 = 2101;
                uint64_t v117 = a6;
                v118 = 1024;
                int v119 = bswap32(a7) >> 16;
                uint64_t v120 = 1024;
                uint64_t v121 = v28;
                v122 = 2048;
                int v123 = v55;
                uint64_t v124 = 1024;
                char v125 = v56;
                int v126 = 2082;
                BOOL v127 = v93;
                int v128 = 1024;
                uint64_t v129 = v94;
                unsigned int v130 = 1024;
                int v131 = mDNSPlatformSendUDP_MessageCount;
                uint64_t v88 = "[Q%u] mDNSPlatformSendUDP: sendto(%d) failed to send packet on InterfaceID %p %{public}s/%d to %{s"
                      "ensitive, mask.hash, mdnsresponder:ip_addr}.20P:%d skt %d error %ld errno %d (%{public}s) %u MessageCount is %d";
                uint64_t v89 = (os_log_s *)v79;
                uint64_t v90 = OS_LOG_TYPE_ERROR;
              }

              int v91 = 116;
              goto LABEL_144;
            }

        mDNS_snprintf(&v80[v6]);
        int v61 = *v80;
        if (*v80)
        {
          uint64_t v62 = v80 + 1;
          do
          {
            if (v61 <= 31) {
              *(v62 - 1) = 46;
            }
            int v63 = *v62++;
            int v61 = v63;
          }

          while (v63);
        }

        return v80;
    }

LABEL_184:
  if (a4) {
    goto LABEL_185;
  }
LABEL_199:
  int v67 = 0;
LABEL_203:
  *(_DWORD *)buf = 136448515;
  uint64_t v73 = (uint64_t)v12;
  __int16 v74 = 2160;
  *(void *)int v75 = 1752392040LL;
  *(_WORD *)&v75[8] = 1040;
  *(_DWORD *)&v75[10] = v59;
  __int16 v76 = 2101;
  uint64_t v77 = (uint64_t)v10;
  __int16 v78 = 2160;
  *(void *)uint64_t v79 = 1752392040LL;
  *(_WORD *)&v79[8] = 1040;
  *(_DWORD *)&v79[10] = v61;
  __int16 v80 = 2101;
  uint64_t v81 = (uint64_t)v5;
  __int16 v82 = 2160;
  *(void *)uint64_t v83 = 1752392040LL;
  *(_WORD *)&v83[8] = 1040;
  *(_DWORD *)&v83[10] = v67;
  __int16 v84 = 2101;
  uint64_t v85 = a4;
  _os_log_impl( (void *)&_mh_execute_header,  v57,  OS_LOG_TYPE_DEFAULT,  "ConstructServiceName: %{public}s: %{sensitive, mask.hash, mdnsresponder:domain_label}.*P.%{sensitive, mask.hash, mdn sresponder:domain_name}.*P%{sensitive, mask.hash, mdnsresponder:domain_name}.*P",  buf,  0x5Au);
  return 0LL;
}

          int v140 = LocateAuthorities(v11, v27);
          uint64_t v66 = (os_log_s **)&unk_100164000;
          if (!v140
            || !*(_WORD *)(v11 + 8)
            || (uint64_t v141 = v140,
                CheckTSRForAuthRecord( *(uint64_t **)(a1 + 12624),  v325,  *(_DWORD *)(v81 + 24),  *(_BYTE **)(v81 + 40)) != -1)
            || !*(_WORD *)(v11 + 8))
          {
LABEL_187:
            if (ResourceRecordIsValidAnswer(v81))
            {
              ++v342;
              int v67 = a4;
              unsigned int v18 = (_DWORD *)(a1 + 19868);
              uint64_t v65 = v323;
              if ((v349 & v330 & 1) != 0)
              {
                if (*(void *)(v81 + 264)) {
                  goto LABEL_83;
                }
                uint64_t v142 = v329;
              }

              else
              {
                if ((*(_DWORD *)(a1 + 64) - *(_DWORD *)(v81 + 288)) <= 0x3E7)
                {
                  uint64_t v152 = *(void *)(v81 + 296);
                  if (v152 == a8 || v152 == -1) {
                    goto LABEL_83;
                  }
                }

                uint64_t v142 = -1LL;
              }

              *(void *)(v81 + 264) = v142;
              goto LABEL_83;
            }

            int v67 = a4;
            goto LABEL_198;
          }

          __int16 v153 = 0;
          while (1)
          {
            int v154 = GetLargeResourceRecord(a1, v11, v141, v27, v382, 160, v344);
            if (!v154) {
              goto LABEL_187;
            }
            uint64_t v141 = v154;
            if (PacketRRMatchesSignature(v344, v81, v155, v156, v157, v158, v159, v160))
            {
              if ((*v322 & 0x32) != 0) {
                break;
              }
            }

            *v341 = 0;
            *(_WORD *)(a1 + 37966) = 0;
            *v354 = 0;
            v161 = *(void **)(a1 + 37920);
            if (v161)
            {
              ref_count_obj_release(v161);
              *(void *)(a1 + 37920) = 0LL;
            }
          }

          *v341 = 0;
          *(_WORD *)(a1 + 37966) = 0;
          *v354 = 0;
          char v169 = *(void **)(a1 + 37920);
          if (v169)
          {
            ref_count_obj_release(v169);
            *(void *)(a1 + 37920) = 0LL;
          }

          int v170 = mDNSLogCategory_mDNS;
          if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
          {
            if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
            {
              v177 = v382;
              int v178 = DNSTypeName(*(unsigned __int16 *)(a1 + 37868));
              BOOL v179 = *(void *)(a1 + 37896);
              v327 = v177;
              v317 = v178;
              if (v179)
              {
                uint64_t v180 = *(_BYTE **)(a1 + 37896);
                if (v179 == -256)
                {
                  while (1)
                  {
LABEL_254:
                    if (!v180) {
                      goto LABEL_273;
                    }
                    uint64_t v181 = *v180;
                    if (!*v180) {
                      break;
                    }
                    v180 += v181 + 1;
                    if (v179 != -256) {
                      goto LABEL_253;
                    }
                  }

                  v188 = (_WORD)v180 - v179 + 1;
                }

                else
                {
LABEL_253:
LABEL_273:
                  v188 = 257;
                }

                unsigned int v191 = v188;
              }

              else
              {
                unsigned int v191 = 0;
              }

              uint64_t v17 = a1 + 37865;
              GetRRDisplayString_rdb(v341, (unsigned __int16 *)(*(void *)(a1 + 37904) + 4LL), v334);
              *(_DWORD *)__dst = 134219779;
              *(void *)&__dst[4] = v327;
              *(_WORD *)&__dst[12] = 2160;
              *(void *)&__dst[14] = 1752392040LL;
              *(_WORD *)&__dst[22] = 2085;
              *(void *)&__dst[24] = v317;
              *(_WORD *)&__dst[32] = 2160;
              *(void *)&__dst[34] = 1752392040LL;
              *(_WORD *)&__dst[42] = 1040;
              *(_DWORD *)&__dst[44] = v191;
              *(_WORD *)&__dst[48] = 2101;
              *(void *)&__dst[50] = v179;
              *(_WORD *)&__dst[58] = 2160;
              *(void *)&__dst[60] = 1752392040LL;
              *(_WORD *)&__dst[68] = 2085;
              *(void *)&__dst[70] = a1 + 46976;
              uint64_t v192 = (os_log_s *)v170;
LABEL_282:
              _os_log_impl( (void *)&_mh_execute_header,  v192,  OS_LOG_TYPE_DEFAULT,  "ProbeRRMatchAndTSRCheck: pkt ar on interface  %p rrtype: %{sensitive, mask.hash}s, name: %{sensitive, ma sk.hash, mdnsresponder:domain_name}.*P%{sensitive, mask.hash}s",  __dst,  0x4Eu);
              unsigned int v11 = a2;
            }
          }

          else
          {
            uint64_t v171 = mDNSLogCategory_mDNS_redacted;
            if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
            {
              v172 = v382;
              int v173 = DNSTypeName(*(unsigned __int16 *)(a1 + 37868));
              v174 = *(void *)(a1 + 37896);
              v326 = v172;
              v316 = (os_log_s *)v171;
              if (v174)
              {
                v175 = *(_BYTE **)(a1 + 37896);
                if (v174 == -256)
                {
                  while (1)
                  {
LABEL_245:
                    if (!v175) {
                      goto LABEL_272;
                    }
                    uint8_t v176 = *v175;
                    if (!*v175) {
                      break;
                    }
                    v175 += v176 + 1;
                    if (v174 != -256) {
                      goto LABEL_244;
                    }
                  }

                  char v187 = (_WORD)v175 - v174 + 1;
                }

                else
                {
LABEL_244:
LABEL_272:
                  char v187 = 257;
                }

                int v189 = v173;
                BOOL v190 = v187;
              }

              else
              {
                int v189 = v173;
                BOOL v190 = 0;
              }

              uint64_t v17 = a1 + 37865;
              GetRRDisplayString_rdb(v341, (unsigned __int16 *)(*(void *)(a1 + 37904) + 4LL), v334);
              *(_DWORD *)__dst = 134219779;
              *(void *)&__dst[4] = v326;
              *(_WORD *)&__dst[12] = 2160;
              *(void *)&__dst[14] = 1752392040LL;
              *(_WORD *)&__dst[22] = 2085;
              *(void *)&__dst[24] = v189;
              *(_WORD *)&__dst[32] = 2160;
              *(void *)&__dst[34] = 1752392040LL;
              *(_WORD *)&__dst[42] = 1040;
              *(_DWORD *)&__dst[44] = v190;
              *(_WORD *)&__dst[48] = 2101;
              *(void *)&__dst[50] = v174;
              *(_WORD *)&__dst[58] = 2160;
              *(void *)&__dst[60] = 1752392040LL;
              *(_WORD *)&__dst[68] = 2085;
              *(void *)&__dst[70] = a1 + 46976;
              uint64_t v192 = v316;
              goto LABEL_282;
            }
          }

          size_t v193 = (os_log_s *)mDNSLogCategory_mDNS;
          if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
          {
            if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
            {
              __int128 v194 = *(void *)(v81 + 32);
              __int128 v199 = DNSTypeName(*(unsigned __int16 *)(v81 + 12));
              __int128 v196 = *(void *)(v81 + 40);
              v328 = v199;
              if (v196)
              {
                __int128 v200 = *(_BYTE **)(v81 + 40);
                if (v196 == -256)
                {
                  while (1)
                  {
LABEL_298:
                    if (!v200) {
                      goto LABEL_304;
                    }
                    uint64_t v201 = *v200;
                    if (!*v200) {
                      break;
                    }
                    v200 += v201 + 1;
                    if (v196 != -256) {
                      goto LABEL_297;
                    }
                  }

                  v203 = (_WORD)v200 - v196 + 1;
                }

                else
                {
LABEL_297:
LABEL_304:
                  v203 = 257;
                }

                v204 = v203;
              }

              else
              {
                v204 = 0;
              }

                LODWORD(v25) = v144;
                goto LABEL_42;
              }

              uint64_t v115 = -6714;
LABEL_221:
              uint64_t v144 = v115;
              goto LABEL_223;
            }
          }

          else
          {
LABEL_219:
            unsigned int v112 = 0LL;
          }

          uint64_t v115 = -6705;
          goto LABEL_221;
        }

        size_t v133 = -6729;
      }

      else
      {
LABEL_195:
        size_t v133 = -6705;
      }

      uint64_t v144 = v133;
      unsigned int v134 = v95;
LABEL_197:
      CFRelease(v134);
      goto LABEL_184;
    case 6u:
      if ((uint64_t *)g_current_discovery_proxy_owner != v6)
      {
        LODWORD(v25) = -6718;
        goto LABEL_42;
      }

      v118 = *(uint64_t (**)(void))(g_discovery_proxy_handlers + 8);
      if (v118)
      {
        LODWORD(v25) = v118();
        int v119 = (uint64_t *)g_current_discovery_proxy_owner;
        if (!g_current_discovery_proxy_owner) {
          goto LABEL_42;
        }
      }

      else
      {
        LODWORD(v25) = -6714;
        int v119 = v6;
      }

      os_release(v119);
      g_current_discovery_proxy_owner = 0LL;
      goto LABEL_42;
    case 7u:
      int v44 = xpc_dictionary_create_empty();
      if (!v44)
      {
        uint64_t v26 = object;
        __int16 v27 = -6729;
        goto LABEL_43;
      }

      uint64_t v35 = v44;
      length = (size_t)_NSConcreteStackBlock;
      int v146 = 0x40000000LL;
      uint64_t v147 = (const char *)___mrcs_session_handle_record_cache_local_record_inquiry_block_invoke;
      int v148 = (uint64_t)&__block_descriptor_tmp_28_4214;
      int v149 = (const char *)v44;
      if (*(void *)g_record_cache_handlers)
      {
        (*(void (**)(size_t *))g_record_cache_handlers)(&length);
LABEL_65:
        unsigned __int16 v45 = 0;
      }

      else
      {
LABEL_84:
        unsigned __int16 v45 = -6714;
      }

_BYTE *AppendDomainName(_BYTE *a1, _BYTE *a2)
{
  uint64_t v2 = 257LL;
  int v3 = a1;
  if (a1 == (_BYTE *)-256LL)
  {
LABEL_3:
    while (v3)
    {
      uint64_t v4 = *v3;
      if (!*v3)
      {
        uint64_t v2 = (unsigned __int16)((_WORD)v3 - (_WORD)a1 + 1);
        break;
      }

      v3 += v4 + 1;
      if (a1 != (_BYTE *)-256LL) {
        goto LABEL_2;
      }
    }
  }

  else
  {
LABEL_2:
    if (v3 < a1 + 256) {
      goto LABEL_3;
    }
  }

  unsigned int v5 = &a1[v2 - 1];
  int v6 = *a2;
  if (*a2)
  {
    while (&v5[v6 + 1] <= a1 + 255)
    {
      unint64_t v7 = 0LL;
      do
      {
        unint64_t v8 = v7;
        v5[v7] = a2[v7];
        ++v7;
      }

      while (v8 < *a2);
      v5 += v7;
      *unsigned int v5 = 0;
      a2 += v7;
      int v6 = *a2;
      if (!*a2) {
        return v5;
      }
    }

    return 0LL;
  }

  return v5;
}

uint64_t mDNS_StartQuery_internal(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = 4294901749LL;
  if (!*(_DWORD *)(a1 + 248)) {
    return 4294901750LL;
  }
  unsigned int v5 = (_DWORD *)(a1 + 19848);
  int v6 = (_BYTE *)(a2 + 356);
  unint64_t v7 = (_BYTE *)(a2 + 612);
  unint64_t v8 = (_BYTE *)(a2 + 356);
  if (a2 != -612)
  {
LABEL_3:
    if (v8 < v7) {
      goto LABEL_4;
    }
LABEL_21:
    uint64_t v19 = (os_log_s *)mDNSLogCategory_Default;
    DNSTypeName(*(unsigned __int16 *)(a2 + 322));
    LogMsgWithLevel( v19,  OS_LOG_TYPE_DEFAULT,  "ValidateParameters: Attempt to start query with invalid qname %##s (%s)",  v20,  v21,  v22,  v23,  v24,  (int)v6);
    return 4294901747LL;
  }

  while (1)
  {
LABEL_4:
    if (!v8) {
      goto LABEL_21;
    }
    uint64_t v9 = *v8;
    if (!*v8) {
      break;
    }
    v8 += v9 + 1;
    if (a2 != -612) {
      goto LABEL_3;
    }
  }

  unint64_t v10 = *(void *)(a2 + 136);
  if (v10 != 0 && v10 < 0xFFFFFFFFFFFFFFFBLL || ((1LL << (v10 + 5)) & 0x2D) == 0)
  {
    uint64_t v26 = (void *)(a1 + 12664);
    while (1)
    {
      uint64_t v26 = (void *)*v26;
      if (!v26) {
        break;
      }
      if (v26[782] == v10) {
        goto LABEL_13;
      }
    }

    if (mDNS_LoggingEnabled == 1)
    {
      uint64_t v29 = (os_log_s *)mDNSLogCategory_Default;
      DNSTypeName(*(unsigned __int16 *)(a2 + 322));
      LogMsgWithLevel( v29,  OS_LOG_TYPE_DEFAULT,  "ValidateParameters: Note: InterfaceID %d for question %##s (%s) not currently found in active interface list",  v30,  v31,  v32,  v33,  v34,  v10);
    }
  }

LABEL_13:
  int v11 = *v6;
  if (*v6)
  {
    unint64_t v12 = v6;
    do
    {
      uint64_t v13 = v12;
      uint64_t v14 = &v12[v11];
      int v15 = v14[1];
      unint64_t v12 = v14 + 1;
      int v11 = v15;
    }

    while (v15);
    uint64_t v16 = *v13;
    if (*v13)
    {
      uint64_t v17 = v13 + 1;
      while (1)
      {
        int v18 = *v17++;
        if (v18 < 0) {
          break;
        }
        if (!--v16) {
          goto LABEL_38;
        }
      }

      memset(__src, 0, sizeof(__src));
      __int16 v27 = (uint64_t *)__src;
      if (PerformNextPunycodeConversion(a2, (char *)__src))
      {
        while (v27 < &v275)
        {
          if (!v27) {
            break;
          }
          uint64_t v28 = *(unsigned __int8 *)v27;
          if (!*(_BYTE *)v27)
          {
            if ((unsigned __int16)((_WORD)v27 - (unsigned __int16)__src + 1) <= 0x100u)
            {
              memcpy(v6, __src, (unsigned __int16)((_WORD)v27 - (unsigned __int16)__src + 1));
              goto LABEL_38;
            }

            break;
          }

          __int16 v27 = (uint64_t *)((char *)v27 + v28 + 1);
        }

        *int v6 = 0;
      }
    }
  }

  uint64_t v30 = mDNSPlatformInterfaceIndexfromInterfaceID(a1, *((void *)a3 + 3), 0LL, v20, v21, v22, v23, v24);
  uint64_t v31 = a2 + 356;
  uint64_t v32 = mDNS_DomainNameFNV1aHash((unsigned __int8 *)(a2 + 356));
  uint64_t v33 = *(_DWORD *)(v8 + 192);
  __tp.tv_sec = 0LL;
  __tp.tv_nsec = 0LL;
  clock_gettime(_CLOCK_MONOTONIC_RAW, &__tp);
  v309 = v30;
  if (!v33 || LODWORD(__tp.tv_sec) - v33 >= 300)
  {
    v304 = v32;
    *(_DWORD *)(v8 + 192) = __tp.tv_sec;
    uint32_t v45 = *((void *)a3 + 7);
    if (v45)
    {
      validation_unint64_t result = dnssec_obj_resource_record_member_get_validation_result(v45);
      uint64_t v47 = *(unsigned __int16 *)(a2 + 320);
      BOOL v48 = *((unsigned __int16 *)a3 + 6);
      uint64_t v49 = v48 < 0x201;
      if (validation_result)
      {
        int v50 = validation_result;
        if (*(_WORD *)(a2 + 320))
        {
          if (v48 >= 0x201)
          {
            int v43 = (char *)malloc(*((unsigned __int16 *)a3 + 6));
            uint64_t v51 = v43;
            if (!v43) {
              goto LABEL_487;
            }
          }

          else
          {
            if (!*((_WORD *)a3 + 6))
            {
              if (v14) {
                uint64_t v121 = (os_log_s *)mDNSLogCategory_Default;
              }
              else {
                uint64_t v121 = (os_log_s *)mDNSLogCategory_mDNS;
              }
              if (gSensitiveLoggingEnabled != 1 || v121 == (os_log_s *)mDNSLogCategory_State)
              {
                if (!os_log_type_enabled(v121, OS_LOG_TYPE_DEFAULT)) {
                  goto LABEL_482;
                }
                int v122 = *(_DWORD *)(v8 + 184);
                BOOL v123 = __rev16(v47);
                int v189 = (_BYTE *)(a2 + 356);
                char v125 = v304;
                if (a2 == -612)
                {
LABEL_339:
                  while (v189)
                  {
                    int v190 = *v189;
                    if (!*v189)
                    {
                      v229 = (unsigned __int16)((_WORD)v189 - v31 + 1);
                      goto LABEL_464;
                    }

                    v189 += v190 + 1;
                    if (a2 != -612) {
                      goto LABEL_338;
                    }
                  }
                }

                else
                {
LABEL_338:
                }

                v229 = 257;
              }

              else
              {
                if (v14) {
                  uint64_t v121 = (os_log_s *)mDNSLogCategory_Default_redacted;
                }
                else {
                  uint64_t v121 = (os_log_s *)mDNSLogCategory_mDNS;
                }
                if (!os_log_type_enabled(v121, OS_LOG_TYPE_DEFAULT)) {
                  goto LABEL_482;
                }
                int v122 = *(_DWORD *)(v8 + 184);
                BOOL v123 = __rev16(v47);
                char v124 = (_BYTE *)(a2 + 356);
                char v125 = v304;
                if (a2 == -612)
                {
LABEL_165:
                  while (v124)
                  {
                    int v126 = *v124;
                    if (!*v124)
                    {
                      v229 = (unsigned __int16)((_WORD)v124 - v31 + 1);
                      goto LABEL_464;
                    }

                    v124 += v126 + 1;
                    if (a2 != -612) {
                      goto LABEL_164;
                    }
                  }
                }

                else
                {
LABEL_164:
                }

                v229 = 257;
              }

  *a2 = v6;
  *unsigned int v5 = a2;
  uint64_t v9 = *(void **)(a1 + 24);
  unint64_t result = (void *)(a1 + 24);
  if (v5 == v9) {
    goto LABEL_4;
  }
  return result;
}

  else {
    return Answers;
  }
}

  uint64_t v14 = *(unsigned __int16 *)(a1 + 12) - v12;
  if (v14 < 1) {
    return 0LL;
  }
  int v15 = (unsigned __int8 *)(v9 + v12);
  while (1)
  {
    uint64_t v16 = v14 - 2;
    if (v14 <= 2)
    {
      if (mDNS_LoggingEnabled == 1) {
        LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "BitmapTypeCheck: malformed nsec, bitmaplen %d short",  a4,  a5,  a6,  a7,  a8,  v14);
      }
      return 0LL;
    }

    uint64_t v17 = v15[1];
    uint64_t v14 = v16 - v17;
    if (v16 < v17 || (v17 - 33) <= 0xFFFFFFDF)
    {
      if (mDNS_LoggingEnabled == 1) {
        LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "BitmapTypeCheck: malformed nsec, bitmaplen %d wlen %d, win %d",  a4,  a5,  a6,  a7,  a8,  v16);
      }
      return 0LL;
    }

    int v18 = v15 + 2;
    if (a2 >> 8 == *v15) {
      break;
    }
    int v15 = &v18[v17];
    if (v14 <= 0) {
      return 0LL;
    }
  }

  uint64_t v19 = a2 >> 3;
  return v18[v19] & (0x80u >> (a2 & 7));
}

  uint64_t v17 = (os_log_s *)mDNSLogCategory_Default;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
  {
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
    {
LABEL_21:
      uint64_t v20 = *(_DWORD *)(v2 + 232);
      *(_DWORD *)buf = 67109378;
      *(_DWORD *)&uint8_t buf[4] = v20;
      *(_WORD *)int v54 = 2112;
      *(void *)&v54[2] = v2;
      _os_log_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_DEFAULT,  "[Q%u] Handling concluded querier: %@",  buf,  0x12u);
    }
  }

  else
  {
    uint64_t v17 = (os_log_s *)mDNSLogCategory_Default_redacted;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_21;
    }
  }

  uint64_t v9 = *(void **)(a1 + 64);
  if (v9)
  {
    ref_count_obj_release(v9);
    *(void *)(a1 + 64) = 0LL;
  }

  *(_DWORD *)(a1 + 112) = 0;
  *(void *)(a1 + 88) = 0LL;
  _dnssec_obj_validation_manager_stop_negative_ds_query(a1);
}

          unint64_t v7 = *(void *)(a1 + 32);
          if (v7) {
            break;
          }
LABEL_16:
          *(_WORD *)(a1 + 100) = v5;
          if (!v3)
          {
            unint64_t v8 = _os_object_alloc(&OBJC_CLASS___OS_mdns_dso_subscribe_message_builder, 48LL);
            int v3 = v8;
            if (v8)
            {
              uint64_t v9 = &_mdns_dso_subscribe_message_builder_kind;
              *(void *)(v8 + 16) = &_mdns_dso_subscribe_message_builder_kind;
              do
              {
                unint64_t v10 = (void (*)(uint64_t))v9[2];
                if (v10) {
                  v10(v3);
                }
                uint64_t v9 = (_UNKNOWN **)*v9;
              }

              while (v9);
              if (_mdns_domain_name_get_root_s_once != -1) {
                dispatch_once(&_mdns_domain_name_get_root_s_once, &__block_literal_global);
              }
              int v11 = _mdns_domain_name_get_root_s_root;
              *(void *)(v3 + 32) = _mdns_domain_name_get_root_s_root;
              if (!v11)
              {
                os_release((void *)v3);
                int v3 = 0LL;
              }
            }
          }

          *(_WORD *)(v3 + 28) = v5;
          unint64_t v12 = *(void *)(v2 + 80);
          if (v12) {
            os_retain(*(void **)(v2 + 80));
          }
          uint64_t v13 = *(void **)(v3 + 32);
          if (v13) {
            os_release(v13);
          }
          *(void *)(v3 + 32) = v12;
          *(_DWORD *)(v3 + 40) = *(_DWORD *)(v2 + 128);
          message = (dispatch_object_s **)mdns_dso_message_builder_create_message(v3);
          mdns_dso_session_send(*(void **)(a1 + 40), message[3]);
          int v15 = *(void **)(a1 + 40);
          if ((*(unsigned int (**)(void *))(v15[2] + 104LL))(v15))
          {
            os_retain(v15);
            if (_mdns_dso_session_queue_s_once != -1) {
              dispatch_once(&_mdns_dso_session_queue_s_once, &__block_literal_global_66);
            }
            block[0] = _NSConcreteStackBlock;
            block[1] = 0x40000000LL;
            block[2] = __mdns_dso_session_add_activity_block_invoke;
            block[3] = &__block_descriptor_tmp_3_5949;
            block[4] = v15;
            dispatch_async((dispatch_queue_t)_mdns_dso_session_queue_s_queue, block);
          }

          os_release(message);
          uint64_t v16 = v2;
          do
          {
            *(_WORD *)(v16 + 132) = v5;
            uint64_t v16 = *(void *)(v16 + 72);
          }

          while (v16);
LABEL_36:
          uint64_t v2 = *(void *)(v2 + 64);
          if (!v2)
          {
LABEL_37:
            if (v3) {
              os_release((void *)v3);
            }
            return;
          }
        }

        while (*(unsigned __int16 *)(v7 + 132) != v5)
        {
          unint64_t v7 = *(void *)(v7 + 64);
          if (!v7) {
            goto LABEL_16;
          }
        }

        goto LABEL_8;
      }
    }
  }

LABEL_62:
  uint64_t v47 = *(void *)(a2 + 136);
  BOOL v48 = v47 == -2 || v47 == -3;
  uint64_t v273 = *(void *)(a2 + 136);
  int v50 = v48 || v47 == -5;
  unsigned int v83 = *(unsigned __int16 *)(a2 + 322);
  if (v83 > 0x1C || ((1 << v83) & 0x10000022) == 0) {
    goto LABEL_77;
  }
  __int16 v84 = &s_head_0;
  while (1)
  {
    __int16 v84 = (uint64_t *)*v84;
    if (!v84) {
      break;
    }
    if (v84[1] == a2)
    {
      uint64_t v85 = kCFAllocatorDefault;
LABEL_197:
      bzero(__src, 0x3F1uLL);
      ConvertDomainNameToCString_withescape(v6, (unsigned __int8 *)__src);
      CFStringRef v110 = CFStringCreateWithCString(v85, (const char *)__src, 0x8000100u);
      if (v110)
      {
        CFStringRef v111 = v110;
        unsigned int v112 = (const __CFArray *)v84[5];
        v276.length = CFArrayGetCount(v112);
        v276.location = 0LL;
        if (CFArrayGetFirstIndexOfValue(v112, v276, v111) == -1) {
          CFArrayInsertValueAtIndex((CFMutableArrayRef)v84[5], 0LL, v111);
        }
        CFRelease(v111);
        int v36 = (_BYTE *)&unk_100164000;
      }

      goto LABEL_77;
    }
  }

  uint64_t v107 = (uint64_t *)calloc(1uLL, 0x38uLL);
  if (!v107) {
    goto LABEL_573;
  }
  __int16 v84 = v107;
  uint64_t v85 = kCFAllocatorDefault;
  CFMutableArrayRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeArrayCallBacks);
  v84[5] = (uint64_t)Mutable;
  if (Mutable)
  {
    CFMutableArrayRef v109 = CFArrayCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeArrayCallBacks);
    v84[6] = (uint64_t)v109;
    if (v109)
    {
      *__int16 v84 = s_head_0;
      v84[1] = a2;
      s_head_0 = (uint64_t)v84;
      goto LABEL_197;
    }

    v269 = (const void *)v84[5];
    if (v269)
    {
      CFRelease(v269);
      v84[5] = 0LL;
    }
  }

  v270 = (const void *)v84[6];
  if (v270) {
    CFRelease(v270);
  }
  free(v84);
LABEL_77:
  uint64_t v51 = 200LL;
  if (v50) {
    uint64_t v51 = 224LL;
  }
  for (uint64_t i = *(void *)(a1 + v51); i != a2 && i != 0; uint64_t i = *(void *)(i + 8))
    ;
  if (!i)
  {
    int v59 = *(unsigned __int8 *)(a2 + 612);
    BOOL v60 = Querier_QuestionBelongsToSelf(a2);
    BOOL v61 = IsLocalDomain(v6);
    if (v59)
    {
      if (!v60 && !v61)
      {
        uint64_t DNSServiceManager = Querier_GetDNSServiceManager(v61);
        if ((!DNSServiceManager || !_Querier_GetCustomPushService(DNSServiceManager, a2))
          && !*(void *)(a2 + 184)
          && dns_push_handle_question_start(a1, a2))
        {
          return 4294901756LL;
        }
      }
    }

    *(void *)(a2 + 8) = 0LL;
    *(_DWORD *)(a2 + 212) = 334;
    unsigned int v63 = DomainNameHashValue((unint64_t)v6);
    *(_DWORD *)(a2 + 200) = v63;
    if (*(_WORD *)(a2 + 320)) {
      int v69 = 0;
    }
    else {
      int v69 = CheckForSoonToExpireRecordsEx(a1, v6, v63, *(unsigned __int16 *)(a2 + 322), *(unsigned __int16 *)(a2 + 324));
    }
    *(_DWORD *)(a2 + 204) = v69;
    *(_DWORD *)(a2 + 208) = *(_DWORD *)(a1 + 64);
    *(_DWORD *)(a2 + 216) = 0;
    int v73 = *(_DWORD *)(a1 + 132);
    *(void *)(a2 + 224) = 0LL;
    *(_DWORD *)(a2 + 220) = v73;
    int v74 = *(_DWORD *)(a2 + 304);
    if ((v74 & 0x2000000) != 0)
    {
      char v75 = 1;
    }

    else
    {
      if ((v74 & 0x4000000) == 0)
      {
        *(_BYTE *)(a2 + 331) = 0;
        goto LABEL_126;
      }

      char v75 = 20;
    }

    *(_BYTE *)(a2 + 331) = v75;
LABEL_126:
    *(_BYTE *)(a2 + 339) = 0;
    *(void *)(a2 + 232) = 0LL;
    *(_BYTE *)(a2 + 335) = 0;
    *(_BYTE *)(a2 + 634) = 0;
    unint64_t v10 = (unint64_t)&unk_100158000;
    *(void *)(a2 + 16) = 0LL;
    *(void *)(a2 + 24) = 0LL;
    if ((v74 & 0x10000000) != 0)
    {
      if (mDNS_LoggingEnabled == 1)
      {
        uint64_t v77 = (os_log_s *)mDNSLogCategory_Default;
        DNSTypeName(*(unsigned __int16 *)(a2 + 322));
        LogMsgWithLevel( v77,  OS_LOG_TYPE_DEFAULT,  "InitCommonState: Query for %##s (%s), PID[%d], EUID[%d], ServiceID[%d] is already set by client",  v78,  v79,  v80,  v81,  v82,  (int)v6);
      }

      unint64_t v10 = *(void *)(v10 + 256);
      if (!v10) {
        return result;
      }
    }

    if (v19 != 28)
    {
      if (v19 == 33)
      {
        for (uint64_t i = v11[1578]; i; uint64_t i = *(void *)i)
        {
          uint64_t v22 = *(unsigned __int16 *)(i + 12);
          if (v22 == 28 || v22 == 1)
          {
            unint64_t result = ResourceRecordIsValidInterfaceAnswer(i, a4, (uint64_t)a3, a4, a5, a6, a7, a8);
            if ((_DWORD)result)
            {
              if (*(_DWORD *)(v10 + 28) == *(_DWORD *)(i + 24))
              {
                unint64_t result = SameDomainNameBytes((_BYTE *)(*(void *)(v10 + 48) + 10LL), *(_BYTE **)(i + 40));
                if ((_DWORD)result)
                {
                  if (!*(void *)(i + 256) && *a3 != (uint64_t *)(i + 256))
                  {
                    **a3 = i;
                    uint64_t v24 = *(void *)(v10 + 272);
                    if (!v24) {
                      uint64_t v24 = v10;
                    }
                    *(void *)(i + 272) = v24;
                    *a3 = (uint64_t *)(i + 256);
                  }
                }
              }
            }
          }
        }
      }

      goto LABEL_62;
    }

  *(_DWORD *)(v25 + 84) = v133;
  if (v27 == v26 && v15 >= 0x45)
  {
    LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "rr->resrec.rdata == &rr->rdatastorage but length > InlineCacheRDSize %##s",  v20,  v21,  v22,  v23,  v24,  *(void *)(v13 + 28));
    __int16 v27 = *(void **)(v25 + 48);
LABEL_69:
    memcpy(v27, *(const void **)(v13 + 36), v15 + 4LL);
    goto LABEL_70;
  }

  if (v27 != v26 && v15 <= 0x44)
  {
    LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "rr->resrec.rdata != &rr->rdatastorage but length <= InlineCacheRDSize %##s",  v20,  v21,  v22,  v23,  v24,  *(void *)(v13 + 28));
    goto LABEL_70;
  }

  if (v15 >= 0x45) {
    goto LABEL_69;
  }
LABEL_70:
  *(void *)__int16 v25 = 0LL;
  *(void *)(v25 + 120) = 0LL;
  if (v40)
  {
    int v73 = *(_OWORD *)v40;
    *(_DWORD *)(v25 + 148) = *(_DWORD *)(v40 + 16);
    *(_OWORD *)(v25 + 132) = v73;
  }

  if (!*(void *)(v25 + 32)) {
    *(_DWORD *)(a1 + 256) += *(unsigned __int16 *)(v25 + 20);
  }
  if ((v8 & 1) != 0) {
    *(_BYTE *)(v25 + 109) = 1;
  }
  *(_BYTE *)(v25 + 129) = 0;
  if (!v128)
  {
    CFStringRef v110 = (char *)v10[4];
    CFStringRef v111 = v110 + 256;
    unsigned int v112 = v110;
LABEL_116:
    uint64_t v113 = 257;
    if (v112 >= v111 || !v112) {
      goto LABEL_137;
    }
    while (1)
    {
      uint64_t v114 = *v112;
      if (v114 > 0x3F)
      {
LABEL_128:
        uint64_t v113 = 257;
        goto LABEL_137;
      }

      if (!*v112) {
        break;
      }
      v112 += v114 + 1;
LABEL_119:
      if (!v112) {
        goto LABEL_128;
      }
    }

    uint64_t v113 = (unsigned __int16)((_WORD)v112 - (_WORD)v110 + 1);
    if ((_WORD)v112 - (_WORD)v110 != 0xFFFF)
    {
LABEL_137:
      int v122 = malloc(v113);
      if (v122)
      {
        BOOL v123 = v122;
        char v124 = v110;
        if (v110 == (char *)-256LL)
        {
LABEL_140:
          while (v124)
          {
            char v125 = *v124;
            if (!*v124)
            {
              int v126 = (_WORD)v124 - (_WORD)v110 + 1;
              if (v126 > 0x100u) {
                break;
              }
              memcpy(v122, v110, v126);
              goto LABEL_148;
            }

            v124 += v125 + 1;
          }
        }

        else
        {
LABEL_139:
          if (v124 < v111) {
            goto LABEL_140;
          }
        }

        unsigned __int8 *v122 = 0;
LABEL_148:
        *(void *)(v25 + 40) = v123;
        return v25;
      }
    }

    goto LABEL_150;
  }

  AddCacheRecordToCacheGroup((uint64_t)v10, (void *)v25);
  for (uint64_t i = *(void *)(a1 + 200); i; uint64_t i = *(void *)(i + 8))
  {
    if (i == *(void *)(a1 + 208)) {
      break;
    }
    if (RecordAnswersQuestion(v25 + 8, 0, i, v74, v75, v76, v77, v78))
    {
      uint64_t v80 = *(_DWORD *)(a1 + 132);
      if (*(_DWORD *)(i + 220) != v80)
      {
        *(_DWORD *)(i + 220) = v80;
        if (!*(_WORD *)(i + 320))
        {
          uint64_t v89 = *(_DWORD *)(i + 212);
          if (v89 >= 1 && !*(void *)(i + 40))
          {
            int v90 = *(_DWORD *)(i + 224) + 1;
            *(_DWORD *)(i + 224) = v90;
            if (v90 >= 0xA && v89 >= 9019 && *(_DWORD *)(a1 + 64) - *(_DWORD *)(i + 256) <= 999)
            {
              int v91 = (os_log_s *)mDNSLogCategory_Default;
              DNSTypeName(*(unsigned __int16 *)(i + 322));
              LogMsgWithLevel( v91,  OS_LOG_TYPE_DEFAULT,  "CacheRecordAdd: %##s (%s) got immediate answer burst (%d); restarting exponential backoff sequence (%d)",
                v92,
                v93,
                v94,
                v95,
                v96,
                i + 356);
              BOOL v97 = *(_DWORD *)(a1 + 64);
              do
                unsigned __int16 v98 = arc4random() & 0xFFF;
              while (v98 > 0xFA0);
              *(_DWORD *)(i + 208) = v98 + v97 - 334;
              *(_DWORD *)(i + 212) = 334;
              SetNextQueryTime(a1, i);
            }
          }
        }
      }

      uint64_t v81 = *(_DWORD *)(i + 228) + 1;
      *(_DWORD *)(i + 228) = v81;
      if ((*(_BYTE *)(v25 + 8) & 0x10) != 0) {
        ++*(_DWORD *)(i + 236);
      }
      if (v81 >= 0xFA1)
      {
        uint64_t v82 = CacheRecordAdd_msgcount++;
        if (v82 <= 9)
        {
          unsigned int v83 = (os_log_s *)mDNSLogCategory_Default;
          DNSTypeName(*(unsigned __int16 *)(i + 322));
          LogMsgWithLevel( v83,  OS_LOG_TYPE_DEFAULT,  "CacheRecordAdd: %##s (%s) has %d answers; shedding records to resist DOS attack",
            v84,
            v85,
            v86,
            v87,
            v88,
            i + 356);
        }

        *(_DWORD *)(v25 + 16) = 0;
        *(_BYTE *)(v25 + 108) = 4;
      }
    }
  }

  if (!*(_DWORD *)(v25 + 84))
  {
    uint64_t v99 = *(void *)(a1 + 216);
    if (v99)
    {
      int v100 = (os_log_s *)mDNSLogCategory_Default;
      int v101 = v99 + 356;
      DNSTypeName(*(unsigned __int16 *)(v99 + 322));
      LogMsgWithLevel( v100,  OS_LOG_TYPE_DEFAULT,  "CacheRecordAdd ERROR m->CurrentQuestion already set: %##s (%s)",  v102,  v103,  v104,  v105,  v106,  v101);
    }

    uint64_t v107 = *(void *)(a1 + 200);
    *(void *)(a1 + 216) = v107;
    if (v107)
    {
      do
      {
        if (v107 == *(void *)(a1 + 208)) {
          break;
        }
        if (RecordAnswersQuestion(v25 + 8, 0, v107, v74, v75, v76, v77, v78)) {
          AnswerCurrentQuestionWithResourceRecord(a1, v25, 1LL);
        }
        int v108 = *(void *)(a1 + 216);
        if (v108 == v107)
        {
          int v108 = *(void *)(v107 + 8);
          *(void *)(a1 + 216) = v108;
        }

        uint64_t v107 = v108;
      }

      while (v108);
    }

    *(void *)(a1 + 216) = 0LL;
  }

  SetNextCacheCheckTimeForRecord(a1, v25);
  CFMutableArrayRef v109 = *(_DWORD *)(v25 + 132);
  if (v109 == 6)
  {
    if (!*(void *)&vorr_s8( *(int8x8_t *)(v25 + 136),  (int8x8_t)*(_OWORD *)&vextq_s8(*(int8x16_t *)(v25 + 136), *(int8x16_t *)(v25 + 136), 8uLL))) {
      return v25;
    }
  }

  else if (v109 != 4 || !*(_DWORD *)(v25 + 136))
  {
    return v25;
  }

  if (!mDNSAddrIsDNSMulticast((_DWORD *)(v25 + 132)))
  {
    int v115 = *(void *)(v25 + 32);
    if (mDNS_AddressIsLocalSubnet(a1, v115, (_DWORD *)(v25 + 132))) {
      unicast_assist_addr_add( *(_BYTE **)(v25 + 40),  *(_DWORD *)(v25 + 24),  *(unsigned __int16 *)(v25 + 12),  *(unsigned __int8 *)(v25 + 8),  (int *)(v25 + 132),  v115);
    }
  }

  return v25;
}

LABEL_152:
      uint64_t v89 = *(void **)(a2 + 80);
      if (v89)
      {
        os_release(v89);
        *(void *)(a2 + 80) = 0LL;
      }

      *(_BYTE *)(a2 + 628) = 0;
      int v90 = *(unsigned __int8 *)(a2 + 617);
      if (*(_BYTE *)(a2 + 617)) {
        int v91 = *(_DWORD *)(a2 + 240);
      }
      else {
        int v91 = 0;
      }
      *(_DWORD *)(a2 + 240) = v91;
      if ((unint64_t)(*(void *)(a2 + 136) + 5LL) <= 3 && *(void *)(a2 + 136) != -4LL)
      {
        if (!v90)
        {
LABEL_377:
          if (*(unsigned int *(**)(unsigned int *, uint64_t, uint64_t, int))(a2 + 152) == GetZoneData_QuestionCallback
            || *(_WORD *)(a2 + 322) == 6)
          {
            AuthInfoForName_internal = 0LL;
          }

          else
          {
            AuthInfoForName_internal = GetAuthInfoForName_internal(a1, v6);
          }

          *(void *)(a2 + 32) = AuthInfoForName_internal;
          if (*(_WORD *)(a2 + 320)) {
            int Suppression = DetermineUnicastQuerySuppression(a2, *(void *)(a2 + 80));
          }
          else {
            int Suppression = 0;
          }
          *(_BYTE *)(a2 + 334) = Suppression != 0;
          if (*(_BYTE *)(a2 + 624)) {
            BOOL v193 = Suppression == 6;
          }
          else {
            BOOL v193 = 0;
          }
          char v194 = v193;
          *(_BYTE *)(a2 + 625) = v194;
          *(void *)(a2 + 48) = 0LL;
          *(void *)(a2 + 64) = 0LL;
          *(_BYTE *)(a2 + 338) = 0;
          *(_WORD *)(a2 + 332) = 2;
          *(_DWORD *)(a2 + 256) = *(_DWORD *)(a1 + 64);
          if (*(_BYTE *)(a2 + 619)) {
            char v195 = 3;
          }
          else {
            char v195 = 0;
          }
          *(_BYTE *)(a2 + 336) = v195;
          *(void *)(a2 + 144) = 0LL;
          int v196 = *(_DWORD *)(a2 + 204);
          if (v196 && *(_BYTE *)(v10 + 2840))
          {
            int v197 = (os_log_s *)mDNSLogCategory_Default;
            int v198 = v196 - *(_DWORD *)(a1 + 64);
            DNSTypeName(*(unsigned __int16 *)(a2 + 322));
            LogMsgWithLevel( v197,  OS_LOG_TYPE_DEFAULT,  "InitCommonState: Delaying answering for %d ticks while cache stabilizes for %##s (%s)",  v199,  v200,  v201,  v202,  v203,  v198);
          }

          *(void *)(a2 + 72) = 0LL;
          uint64_t v204 = *(void *)(a2 + 96);
          if (v204)
          {
            mdns_client_invalidate(v204);
            os_release(*(void **)(a2 + 96));
            *(void *)(a2 + 96) = 0LL;
          }

          *(_DWORD *)(a2 + 300) = 0;
          *(_OWORD *)(a2 + 284) = 0u;
          *(_WORD *)(a2 + 316) = 0;
          *(_OWORD *)(a2 + 104) = 0u;
          *(_BYTE *)(a2 + 330) = 1;
          *(void *)(a2 + 272) = 0LL;
          *(void *)(a2 + 308) = 0LL;
          *(_DWORD *)(a2 + 326) = 0;
          uint64_t v2 = *(void *)(a1 + 200);
          if (!v2 || v2 == a2)
          {
LABEL_432:
            uint64_t v2 = 0LL;
            *(void *)(a2 + 40) = 0LL;
            int v209 = 1;
            goto LABEL_433;
          }

          while (1)
          {
            if ((*(_WORD *)(v2 + 320) == 0) == (*(_WORD *)(a2 + 320) != 0)
              || *(_DWORD *)(v2 + 200) != *(_DWORD *)(a2 + 200)
              || *(void *)(v2 + 136) != *(void *)(a2 + 136)
              || *(unsigned __int16 *)(v2 + 322) != *(unsigned __int16 *)(a2 + 322)
              || *(unsigned __int16 *)(v2 + 324) != *(unsigned __int16 *)(a2 + 324))
            {
              goto LABEL_427;
            }

            BOOL v205 = !*(_BYTE *)(v2 + 612) || *(_WORD *)(v2 + 320) == 0;
            BOOL v206 = !v205;
            if (!*v7) {
              break;
            }
            if ((((*(_WORD *)(a2 + 320) != 0) ^ v206) & 1) == 0) {
              goto LABEL_415;
            }
LABEL_427:
            uint64_t v2 = *(void *)(v2 + 8);
            if (v2) {
              BOOL v208 = v2 == a2;
            }
            else {
              BOOL v208 = 1;
            }
            if (v208) {
              goto LABEL_432;
            }
          }

          if (v206) {
            goto LABEL_427;
          }
LABEL_415:
          if (*(void *)(v2 + 32) && !*(void *)(a2 + 32)) {
            goto LABEL_427;
          }
          if ((*(_BYTE *)(v2 + 334) != 0) == (*(_BYTE *)(a2 + 334) == 0)) {
            goto LABEL_427;
          }
          if (((*(_DWORD *)(a2 + 304) ^ *(_DWORD *)(v2 + 304)) & 0x100000) != 0) {
            goto LABEL_427;
          }
          if (*(void *)(v2 + 80) != *(void *)(a2 + 80)) {
            goto LABEL_427;
          }
          if ((*(_BYTE *)(v2 + 635) != 0) == (*(_BYTE *)(a2 + 635) == 0)) {
            goto LABEL_427;
          }
          if (*(_BYTE *)(v2 + 635))
          {
            uint64_t v207 = *(void *)(v2 + 144);
            if (!v207 || !*(_BYTE *)(v207 + 24)) {
              goto LABEL_427;
            }
          }

          if (!SameDomainNameBytes((_BYTE *)(v2 + 356), v6)
            || (*(void *)(v2 + 184) != 0LL) != (*(void *)(a2 + 184) != 0LL))
          {
            goto LABEL_427;
          }

          int v209 = 0;
          *(void *)(a2 + 40) = v2;
          *(void *)(a2 + 32) = *(void *)(v2 + 32);
LABEL_433:
          unint64_t v210 = *(void *)(a2 + 136) + 5LL;
          if (v210 > 3)
          {
            v212 = &qword_100158C80;
            v211 = &qword_100158C88;
          }

          else
          {
            v211 = (uint64_t *)off_10013F1E8[v210];
            v212 = (uint64_t *)off_10013F208[v210];
          }

          uint64_t v213 = *v211;
          uint64_t v214 = *v212;
          if (*v212)
          {
            char v215 = 0;
            int v216 = 0;
            do
            {
              if (v213)
              {
                if (v216 || v214 == v213)
                {
                  int v217 = *(_DWORD *)(v214 + 204);
                  if (v217)
                  {
                    if (v215) {
                      int v218 = 1;
                    }
                    else {
                      int v218 = v209;
                    }
                    if (v218 != 1)
                    {
                      int v216 = 1;
LABEL_454:
                      if (v2) {
                        BOOL v220 = v214 == v2;
                      }
                      else {
                        BOOL v220 = 0;
                      }
                      char v215 = v220;
                      goto LABEL_460;
                    }

                    int v219 = *(_DWORD *)(a2 + 204);
                    if (!v219) {
                      int v219 = dword_100158BF8;
                    }
                    if (v217 - v219 > 0) {
                      break;
                    }
                  }

                  int v216 = 1;
                }

                else
                {
                  int v216 = 0;
                }

                if (!v215) {
                  goto LABEL_454;
                }
                char v215 = 1;
              }

        unsigned __int16 v150 = _unicast_assist_cache_log();
        uint64_t v151 = (os_log_s *)objc_claimAutoreleasedReturnValue(v150);
        if (os_log_type_enabled(v151, OS_LOG_TYPE_DEBUG))
        {
          int v154 = *(void *)(v461 + 24);
          uint64_t v155 = *(_DWORD *)(v461 + 32);
          *(void *)block = 0x1404120402LL;
          *(_WORD *)&block[8] = 2098;
          *(void *)&block[10] = v131 + 2;
          *(_WORD *)&block[18] = 1024;
          *(_DWORD *)&block[20] = v154;
          LOWORD(v474) = 1024;
          *(_DWORD *)((char *)&v474 + 2) = v155;
          _os_log_debug_impl( (void *)&_mh_execute_header,  v151,  OS_LOG_TYPE_DEBUG,  "unicast assist record flushed (0 qhashes) - %{public, mdnsresponder:ip_addr}.20P %2.2d ifhash %x",  block,  0x1Eu);
        }

        if ((void *)*v462 == v131)
        {
          uint64_t v152 = (void *)*v131;
          *v462 = *v131;
          uint64_t v153 = v462;
        }

        else
        {
          uint64_t v152 = (void *)**v132;
          *int v132 = v152;
          uint64_t v153 = v132;
        }

        uint64_t v4 = (void *)&unk_100164000;
        if (!v152) {
          *(void *)(v461 + 16) = v153;
        }
        _unicast_assist_cache_free_addr(v131);
        unsigned int v131 = 0LL;
LABEL_160:
        if (v131) {
          int v132 = (void **)v131;
        }
        unsigned int v131 = v133;
        if (v133) {
          continue;
        }
        break;
      }

      uint64_t v129 = v458;
      if (v464)
      {
        v457 += v464;
        unsigned int v5 = &unk_100164000;
        int v130 = v467;
        uint64_t v156 = (uint64_t *)v461;
        goto LABEL_172;
      }

      unsigned int v5 = &unk_100164000;
      int v130 = v467;
      BOOL v127 = v461;
LABEL_166:
      uint64_t v157 = _unicast_assist_cache_log();
      int v158 = (os_log_s *)objc_claimAutoreleasedReturnValue(v157);
      if (os_log_type_enabled(v158, OS_LOG_TYPE_DEBUG))
      {
        v161 = *(void *)(v127 + 24);
        unsigned __int16 v162 = *(_DWORD *)(v127 + 32);
        *(_DWORD *)block = 67109376;
        *(_DWORD *)&block[4] = v161;
        *(_WORD *)&block[8] = 1024;
        *(_DWORD *)&block[10] = v162;
        _os_log_debug_impl( (void *)&_mh_execute_header,  v158,  OS_LOG_TYPE_DEBUG,  "unicast assist interface flushed (0 addrs) - interface %2.2d ifhash %x",  block,  0xEu);
      }

      int v159 = &s_interface_head_0;
      if (s_interface_head_0 == v127)
      {
        unsigned int v160 = (uint64_t *)v127;
      }

      else
      {
        unsigned int v160 = (uint64_t *)*v129;
        int v159 = v129;
      }

      void *v159 = *v160;
      _unicast_assist_cache_free_interface((uint64_t **)v127);
      uint64_t v156 = 0LL;
LABEL_172:
      if (v156) {
        uint64_t v129 = v156;
      }
      BOOL v127 = (uint64_t)v460;
      if (v460) {
        continue;
      }
      break;
    }

    a1 = v454;
    if (v130 > 0x8000)
    {
      uint64_t v163 = v130;
      int v164 = 0LL;
      int v165 = v457;
      while (1)
      {
        unsigned __int16 v166 = (void *)s_interface_head_0;
        uint64_t v167 = 0;
        uint64_t v168 = 0LL;
        do
        {
          char v169 = v166[1];
          if (v169)
          {
            int v170 = *(void *)(v169 + 8);
            if (v170)
            {
              int v171 = v128 - *(_DWORD *)(v170 + 12);
              if (v171 > v167)
              {
                uint64_t v168 = v166;
                uint64_t v167 = v171;
              }
            }
          }

          unsigned __int16 v166 = (void *)*v166;
        }

        while (v166);
        if (!v168) {
          break;
        }
        uint64_t v173 = (void **)(v168 + 1);
        unsigned int v172 = (void *)v168[1];
        if (!v172) {
          break;
        }
        int v174 = v172 + 1;
        v164 += 16LL;
        do
        {
          int v174 = (void *)*v174;
          v164 += 24LL;
        }

        while (v174);
        v175 = _unicast_assist_cache_log();
        uint64_t v176 = (os_log_s *)objc_claimAutoreleasedReturnValue(v175);
        if (os_log_type_enabled(v176, OS_LOG_TYPE_DEBUG))
        {
          BOOL v179 = v168[3];
          uint64_t v180 = *((_DWORD *)v168 + 8);
          *(_DWORD *)block = 67110146;
          *(_DWORD *)&block[4] = v167 / 0x3E8u;
          *(_WORD *)&block[8] = 1042;
          *(_DWORD *)&block[10] = 20;
          *(_WORD *)&block[14] = 2098;
          *(void *)&block[16] = v172 + 2;
          LOWORD(v474) = 1024;
          *(_DWORD *)((char *)&v474 + 2) = v179;
          HIWORD(v474) = 1024;
          LODWORD(v475[0]) = v180;
          _os_log_debug_impl( (void *)&_mh_execute_header,  v176,  OS_LOG_TYPE_DEBUG,  "unicast assist cache maintenance record flushed (memory) - age %ds %{public, mdnsresponder:ip_addr}.20P %2.2d ifhash %x",  block,  0x24u);
        }

        v177 = (void *)**v173;
        *uint64_t v173 = v177;
        if (!v177) {
          v168[2] = v173;
        }
        _unicast_assist_cache_free_addr(v172);
        --v165;
        unsigned int v178 = (void *)(v163 - v164);
        if (v163 - v164 <= 0x8000) {
          goto LABEL_195;
        }
      }

      unsigned int v178 = (void *)(v163 - v164);
LABEL_195:
      int v181 = _unicast_assist_cache_log();
      unsigned int v182 = (os_log_s *)objc_claimAutoreleasedReturnValue(v181);
      uint64_t v4 = &unk_100164000;
      if (os_log_type_enabled(v182, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)block = 134218752;
        *(void *)&block[4] = v163;
        *(_WORD *)&block[12] = 2048;
        *(void *)&block[14] = v457;
        *(_WORD *)&block[22] = 2048;
        v474 = v178;
        LOWORD(v475[0]) = 2048;
        *(void *)((char *)v475 + 2) = v165;
        _os_log_debug_impl( (void *)&_mh_execute_header,  v182,  OS_LOG_TYPE_DEBUG,  "unicast assist cache maintenance - (Was) size %zu count %zu | (Is) size %zu count %zu",  block,  0x2Au);
      }

      a1 = v454;
    }

                  if (v132) {
                    uint64_t v106 = 1;
                  }
                  else {
                    uint64_t v106 = v131 << 31 >> 31;
                  }
                  if (v132)
                  {
                    uint64_t v99 = (unsigned __int8 *)(a1 + 37864);
                    if (v131)
                    {
                      uint64_t v134 = *v125;
                      unsigned __int16 v133 = *v121;
                      goto LABEL_159;
                    }
                  }

                  else
                  {
                    uint64_t v99 = (unsigned __int8 *)(a1 + 37864);
                  }

                    if (*(_DWORD *)(v47 + 144))
                    {
                      unsigned int v131 = *(void *)(a1 + 15040);
                      if (v131) {
                        int v132 = v131 == a8;
                      }
                      else {
                        int v132 = 1;
                      }
                      if (!v132) {
                        mDNSPlatformUpdateProxyList(v131, v62, v63, v64, v65, v66, v67, v68);
                      }
                      *(void *)(a1 + 15040) = a8;
                    }
                  }

                  unsigned __int16 v133 = *(_DWORD *)(a1 + 64);
                  *(_DWORD *)(v47 + 164) = v133;
                  *(_DWORD *)(v47 + 168) = v149 + v133;
                  if (*(_DWORD *)(a1 + 108) - (v149 + v133) >= 1) {
                    *(_DWORD *)(a1 + 108) = v149 + v133;
                  }
                  *(_DWORD *)(v47 + 176) = 0;
                  mDNS_Register_internal(a1, v47, v63, v64, v65, v66, v67, v68);
                  ++*v150;
                  mDNS_UpdateAllowSleep(a1);
                  uint64_t v42 = a1 + 37856;
                  if (mDNS_LoggingEnabled == 1)
                  {
                    uint64_t v134 = (unsigned __int8 *)(v47 + 8);
                    unsigned __int16 v148 = (os_log_s *)mDNSLogCategory_Default;
                    v135 = (unsigned __int16 *)(*(void *)(v47 + 48) + 4LL);
                    uint64_t v136 = *v150;
                    GetRRDisplayString_rdb(v134, v135, (_BYTE *)(a1 + 46976));
                    uint64_t v42 = a1 + 37856;
                    LogMsgWithLevel( v148,  OS_LOG_TYPE_DEFAULT,  "SPS Registered %4d %X %s",  v137,  v138,  v139,  v140,  v141,  v136);
                  }
                }

                *int v43 = 0;
                *(_WORD *)(a1 + 37966) = 0;
                char *v17 = 0;
                uint64_t v142 = *(void **)(a1 + 37920);
                if (v142)
                {
                  ref_count_obj_release(v142);
                  *(void *)(a1 + 37920) = 0LL;
                }
              }

              while (++v41 < *(unsigned __int16 *)(a2 + 8)
                   && Authorities != 0LL
                   && (unint64_t)Authorities < a3);
            }

            __int16 v25 = a1 + 28904;
            if ((*(_BYTE *)(a1 + 28907) & 0xF) != 0)
            {
              int v11 = v146;
              unint64_t v12 = v147;
              LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "Refusing sleep proxy registration from %#a:%d: Out of memory",  v36,  v37,  v38,  v39,  v40,  (int)v147);
              ClearProxyRecords(a1, (uint64_t)&v152, *(void *)(a1 + 12632));
              ClearProxyRecords(a1, (uint64_t)&v152, *(void *)(a1 + 12624));
              int v18 = a1 + 28916;
            }

            else
            {
              v155[0] = 32;
              unsigned int v160 = 0LL;
              v161 = v195;
              uint64_t v156 = 41;
              v196[0] = 264;
              unsigned __int16 v162 = v196;
              uint64_t v163 = 0LL;
              int v171 = 0;
              unsigned int v172 = 0;
              uint64_t v173 = 0;
              int v174 = 0;
              v175 = 0;
              int v164 = 0u;
              int v165 = 0u;
              unsigned __int16 v166 = 0u;
              uint64_t v167 = 0u;
              uint64_t v168 = 0u;
              char v169 = 0u;
              int v170 = 0LL;
              uint64_t v176 = v195;
              unsigned int v191 = 0;
              uint64_t v192 = 0;
              char v194 = 0LL;
              BOOL v193 = 0u;
              int v190 = 0;
              v195[0] = 0;
              v177 = 0u;
              unsigned int v178 = 0u;
              BOOL v179 = 0u;
              uint64_t v180 = 0u;
              int v181 = 0u;
              unsigned int v182 = 0u;
              uint64_t v183 = 0u;
              unsigned __int16 v184 = 0u;
              uint64_t v185 = 0u;
              v186 = 0u;
              uint64_t v187 = 0u;
              int v188 = 0u;
              memset(v189, 0, sizeof(v189));
              uint64_t v157 = 1440;
              int v158 = 4500;
              int v159 = 1572888;
              v196[2] = 2;
              int v197 = v145;
              int v18 = PutResourceRecordTTLWithLimit( a1 + 28904,  a1 + 28916,  (_WORD *)(a1 + 28914),  (uint64_t)v155,  0x1194uLL,  a1 + 37856,  v39,  v40);
              int v11 = v146;
              unint64_t v12 = v147;
              if (!v18) {
                goto LABEL_178;
              }
            }
          }

          else
          {
            uint64_t v32 = 5;
            if (mDNSCoreReceiveUpdate_msgs_286 <= 99)
            {
              ++mDNSCoreReceiveUpdate_msgs_286;
              LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "Refusing sleep proxy registration from %#a:%d: Too many records %d + %d = %d > %d",  v20,  v21,  v22,  v23,  v24,  (int)v12);
              uint64_t v32 = *(_BYTE *)(v25 + 3) | 5;
            }

            *(_BYTE *)(v25 + 3) = v32;
          }
        }

        else
        {
          if (mDNSCoreReceiveUpdate_msgs > 99)
          {
            uint64_t v33 = 1;
          }

          else
          {
            ++mDNSCoreReceiveUpdate_msgs;
            LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "Refusing sleep proxy registration from %#a:%d:%s%s",  v20,  v21,  v22,  v23,  v24,  (int)v12);
            uint64_t v33 = *(_BYTE *)(v25 + 3) | 1;
          }

          *(_BYTE *)(v25 + 3) = v33;
        }

        mDNSSendDNSMessage(a1, v25, v18, a8, 0LL, *(unsigned __int16 **)(a1 + 15048), (int *)v12, v11, 0LL, 0);
LABEL_178:
        mDNS_SendKeepalives(a1);
      }
    }
  }

    unsigned int v41 = 0;
    goto LABEL_153;
  }

  if (v16 != 37905)
  {
    unsigned int v41 = 1;
    goto LABEL_153;
  }

  if ((unint64_t)&a7[1] + 4 > a8 || a7[1].i8[0] || a7[1].i8[1] || a7[1].i8[2])
  {
    uint64_t v38 = 0;
    unint64_t v39 = 8;
  }

  else
  {
    unint64_t v39 = 12;
    if (a7[1].i8[3])
    {
      unint64_t v39 = 8;
      uint64_t v38 = 0;
    }

    else
    {
      uint64_t v38 = -4;
    }
  }

  BOOL v40 = &a7[3 * v39];
  unsigned int v41 = 1;
  if ((unint64_t)&v40[3] + 4 <= a8 && (unsigned __int16)(v38 + v37) >= 0x1Cu && (v40[2].i8[1] & 0x10) != 0)
  {
    uint64_t v42 = v40[2].u8[2];
    if (v42 == 34 || v42 == 5)
    {
      unsigned int v41 = 0;
      int v43 = "Ignoring";
    }

    else
    {
      int v43 = "Received";
    }

    if (mDNS_LoggingEnabled != 1) {
      goto LABEL_157;
    }
    LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "%s %d-byte IKE ExchangeType %d",  (uint64_t)a4,  a5,  a6,  (uint64_t)a7,  a8,  (int)v43);
  }

LABEL_460:
              v212 = (uint64_t *)(v214 + 8);
              uint64_t v214 = *(void *)(v214 + 8);
            }

            while (v214);
          }

          *(void *)(a2 + 8) = v214;
          uint64_t *v212 = a2;
          if (!v213 || v213 == v214) {
            uint64_t *v211 = a2;
          }
          if (!*(_BYTE *)(a2 + 635))
          {
LABEL_498:
            if (!*(_DWORD *)(a2 + 252))
            {
              v241 = (os_log_s *)mDNSLogCategory_mDNS;
              if (v36[1384] != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
              {
                if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
                {
                  unsigned int v242 = bswap32(*(unsigned __int16 *)(a2 + 320)) >> 16;
                  v246 = v6;
                  int v244 = 257;
                  while (v246 < v7 && v246)
                  {
                    uint64_t v247 = *v246;
                    if (v247 > 0x3F)
                    {
                      int v244 = 257;
                      goto LABEL_520;
                    }

                    if (!*v246)
                    {
                      int v244 = (unsigned __int16)((_WORD)v246 - (_WORD)v6 + 1);
                      goto LABEL_520;
                    }

                    v246 += v247 + 1;
                  }

                  goto LABEL_520;
                }
              }

              else
              {
                v241 = (os_log_s *)mDNSLogCategory_mDNS_redacted;
                if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
                {
                  unsigned int v242 = bswap32(*(unsigned __int16 *)(a2 + 320)) >> 16;
                  v243 = v6;
                  int v244 = 257;
                  while (v243 < v7 && v243)
                  {
                    uint64_t v245 = *v243;
                    if (v245 > 0x3F)
                    {
                      int v244 = 257;
                      break;
                    }

                    if (!*v243)
                    {
                      int v244 = (unsigned __int16)((_WORD)v243 - (_WORD)v6 + 1);
                      break;
                    }

                    v243 += v245 + 1;
                  }

LABEL_520:
                  int v248 = mDNS_DomainNameFNV1aHash(v6);
                  int v249 = *(unsigned __int16 *)(a2 + 322);
                  LODWORD(__src[0]) = 67110403;
                  DWORD1(__src[0]) = v242;
                  WORD4(__src[0]) = 2160;
                  *(void *)((char *)__src + 10) = 1752392040LL;
                  WORD1(__src[1]) = 1040;
                  DWORD1(__src[1]) = v244;
                  WORD4(__src[1]) = 2101;
                  *(void *)((char *)&__src[1] + 10) = v6;
                  WORD1(__src[2]) = 1024;
                  DWORD1(__src[2]) = v248;
                  WORD4(__src[2]) = 1024;
                  *(_DWORD *)((char *)&__src[2] + 10) = v249;
                  _os_log_impl( (void *)&_mh_execute_header,  v241,  OS_LOG_TYPE_DEFAULT,  "[Q%u] mDNS_StartQuery_internal START -- qname: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%x), qtype: %{mdns:rrtype}d",  (uint8_t *)__src,  0x2Eu);
                }
              }
            }

            if (*(_WORD *)(a2 + 320))
            {
              uint64_t v250 = *(void *)(a2 + 40);
              if (v250)
              {
                v251 = *(void **)(v250 + 80);
                if (v251) {
                  os_retain(v251);
                }
                v252 = *(void **)(a2 + 80);
                if (v252) {
                  os_release(v252);
                }
                *(void *)(a2 + 80) = *(void *)(v250 + 80);
                v253 = (os_log_s *)mDNSLogCategory_Default;
                if (v36[1384] != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
                {
                  if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
                  {
                    int v254 = *(_DWORD *)(a2 + 252);
                    unsigned int v255 = bswap32(*(unsigned __int16 *)(a2 + 320)) >> 16;
                    unsigned int v256 = bswap32(*(unsigned __int16 *)(v250 + 320)) >> 16;
                    v263 = v6;
                    int v258 = 257;
                    while (v263 < v7 && v263)
                    {
                      uint64_t v264 = *v263;
                      if (v264 > 0x3F)
                      {
                        int v258 = 257;
                        goto LABEL_562;
                      }

                      if (!*v263)
                      {
                        int v258 = (unsigned __int16)((_WORD)v263 - (_WORD)v6 + 1);
                        goto LABEL_562;
                      }

                      v263 += v264 + 1;
                    }

                    goto LABEL_562;
                  }
                }

                else
                {
                  v253 = (os_log_s *)mDNSLogCategory_Default_redacted;
                  if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
                  {
                    int v254 = *(_DWORD *)(a2 + 252);
                    unsigned int v255 = bswap32(*(unsigned __int16 *)(a2 + 320)) >> 16;
                    unsigned int v256 = bswap32(*(unsigned __int16 *)(v250 + 320)) >> 16;
                    v257 = v6;
                    int v258 = 257;
                    while (v257 < v7 && v257)
                    {
                      uint64_t v259 = *v257;
                      if (v259 > 0x3F)
                      {
                        int v258 = 257;
                        break;
                      }

                      if (!*v257)
                      {
                        int v258 = (unsigned __int16)((_WORD)v257 - (_WORD)v6 + 1);
                        break;
                      }

                      v257 += v259 + 1;
                    }

                    v339 = *(void (**)(uint64_t))(v76 + 96);
                    v340 = v76;
                    if (v339 == connection_termination)
                    {
                      v340 = LocateSubordinateRequest(v76);
                      v339 = *(void (**)(uint64_t))(v340 + 96);
                    }

                    if ((char *)v339 != (char *)regservice_termination_callback)
                    {
                      v341 = mDNSLogCategory_mDNS;
                      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
                      {
                        updated = -65540;
                        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
                          goto LABEL_1122;
                        }
                      }

                      else
                      {
                        v341 = mDNSLogCategory_mDNS_redacted;
                        updated = -65540;
                        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
                          goto LABEL_1122;
                        }
                      }

                      v342 = *(_DWORD *)(v340 + 184);
                      v1489.st_dev = 67109120;
                      *(_DWORD *)&v1489.st_mode = v342;
                      uint64_t v114 = &v1489;
                      int v115 = (os_log_s *)v341;
                      unsigned int v116 = OS_LOG_TYPE_DEFAULT;
                      int v117 = "[R%d] DNSServiceAddRecord(not a registered service ref)";
                      goto LABEL_1119;
                    }

                    v393 = gSensitiveLoggingEnabled;
                    v394 = mDNSLogCategory_mDNS;
                    if (mDNSLogCategory_mDNS == mDNSLogCategory_State) {
                      v393 = 0;
                    }
                    if (!*(_WORD *)(*(void *)(v340 + 112) + 24LL))
                    {
                      if ((v393 & 1) != 0)
                      {
                        v495 = mDNSLogCategory_mDNS_redacted;
                        updated = -65540;
                        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
                          goto LABEL_1122;
                        }
                        v496 = *(_DWORD *)(v340 + 184);
                        v1489.st_dev = 67109120;
                        *(_DWORD *)&v1489.st_mode = v496;
                        uint64_t v114 = &v1489;
                        int v115 = (os_log_s *)v495;
                        unsigned int v116 = OS_LOG_TYPE_DEFAULT;
                        int v117 = "[R%d] DNSServiceAddRecord: adding record to a service registered with zero port";
                      }

                      else
                      {
                        updated = -65540;
                        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
                          goto LABEL_1122;
                        }
                        v572 = *(_DWORD *)(v340 + 184);
                        v1489.st_dev = 67109120;
                        *(_DWORD *)&v1489.st_mode = v572;
                        uint64_t v114 = &v1489;
                        int v115 = (os_log_s *)v394;
                        unsigned int v116 = OS_LOG_TYPE_DEFAULT;
                        int v117 = "[R%d] DNSServiceAddRecord: adding record to a service registered with zero port";
                      }

                      goto LABEL_1119;
                    }

                    v1406 = *(void *)(v340 + 112);
                    if ((v393 & 1) != 0)
                    {
                      v395 = mDNSLogCategory_mDNS_redacted;
                      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
                        goto LABEL_1302;
                      }
                      v396 = *(void *)(v1406 + 1624);
                      v1389 = (os_log_s *)v395;
                      if (v396)
                      {
                        v397 = *(void *)(v396 + 2736);
                        if (v397)
                        {
                          v398 = *(_BYTE **)(v396 + 2736);
                          if (v397 == -256) {
                            goto LABEL_630;
                          }
LABEL_627:
                          v399 = 257;
                          if ((unint64_t)v398 < v397 + 256 && v398)
                          {
                            while (1)
                            {
                              v400 = *v398;
                              if (v400 > 0x3F)
                              {
LABEL_1224:
                                v399 = 257;
                                goto LABEL_1294;
                              }

                              if (!*v398) {
                                break;
                              }
                              v398 += v400 + 1;
                              if (v397 != -256) {
                                goto LABEL_627;
                              }
LABEL_630:
                              if (!v398) {
                                goto LABEL_1224;
                              }
                            }

                            v399 = (_WORD)v398 - v397 + 1;
                          }

LABEL_562:
                    v266 = DNSTypeName(*(unsigned __int16 *)(a2 + 322));
                    LODWORD(__src[0]) = 67110659;
                    DWORD1(__src[0]) = v254;
                    WORD4(__src[0]) = 1024;
                    *(_DWORD *)((char *)__src + 10) = v255;
                    HIWORD(__src[0]) = 1024;
                    LODWORD(__src[1]) = v256;
                    WORD2(__src[1]) = 2160;
                    *(void *)((char *)&__src[1] + 6) = 1752392040LL;
                    HIWORD(__src[1]) = 1040;
                    LODWORD(__src[2]) = v258;
                    WORD2(__src[2]) = 2101;
                    *(void *)((char *)&__src[2] + 6) = v6;
                    HIWORD(__src[2]) = 2082;
                    *(void *)&__src[3] = v266;
                    _os_log_impl( (void *)&_mh_execute_header,  v253,  OS_LOG_TYPE_DEFAULT,  "[R%u->DupQ%u->Q%u] Duplicate question %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%{public}s)",  (uint8_t *)__src,  0x38u);
                  }
                }
              }

              ActivateUnicastQuery(a1, a2, 0);
              return 0LL;
            }

            int v260 = *v5;
            int v261 = v5[1] + 1;
            v5[1] = v261;
            if (v260 + v261 == 1)
            {
              *(_DWORD *)(a1 + 116) = 0;
              if (!*(_BYTE *)(a1 + 120))
              {
                *(_BYTE *)(a1 + 120) = 1;
                *(_DWORD *)(a1 + 8) = *(_DWORD *)(a1 + 64);
              }
            }

            if (!*(_BYTE *)(a2 + 619)) {
              return 0LL;
            }
            v262 = (os_log_s *)mDNSLogCategory_mDNS;
            if (v36[1384] != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
            {
              if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
              {
LABEL_555:
                unsigned int v265 = bswap32(*(unsigned __int16 *)(a2 + 320)) >> 16;
                LODWORD(__src[0]) = 67109120;
                DWORD1(__src[0]) = v265;
                _os_log_impl( (void *)&_mh_execute_header,  v262,  OS_LOG_TYPE_DEFAULT,  "[Q%u] mDNS_StartQuery_internal: Purging records before resolving",  (uint8_t *)__src,  8u);
              }
            }

            else
            {
              v262 = (os_log_s *)mDNSLogCategory_mDNS_redacted;
              if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
                goto LABEL_555;
              }
            }

            mDNS_PurgeBeforeResolve(a1, a2);
            return 0LL;
          }

          __int16 v84 = *(uint64_t **)(a2 + 40);
          __int128 v221 = calloc(1uLL, 0x20uLL);
          if (v221)
          {
            uint64_t v2 = (uint64_t)v221;
            v222 = &_dnssec_obj_dns_question_member_kind;
            v221[1] = &_dnssec_obj_dns_question_member_kind;
            do
            {
              v223 = (void (*)(uint64_t))v222[2];
              if (v223) {
                v223(v2);
              }
              v222 = (_UNKNOWN **)*v222;
            }

            while (v222);
            int v224 = *(_DWORD *)v2;
            *(void *)(v2 + 16) = 0LL;
            *(_BYTE *)(v2 + 24) = v84 == 0LL;
            *(_DWORD *)uint64_t v2 = v224 + 2;
            ref_count_obj_release((void *)v2);
            if (v84)
            {
              ++*(_DWORD *)v2;
              int v225 = *(void **)(a2 + 144);
              if (v225) {
                ref_count_obj_release(v225);
              }
              *(void *)(a2 + 144) = v2;
LABEL_497:
              ref_count_obj_release((void *)v2);
              goto LABEL_498;
            }

            unint64_t v10 = *(void *)(a2 + 152);
            BOOL v226 = *(_BYTE *)(a2 + 615) != 0;
            LODWORD(__src[0]) = 0;
            if (!v10) {
              goto LABEL_576;
            }
            v272 = v5;
            CFRange v227 = (uint64_t *)calloc(1uLL, 0x48uLL);
            if (v227)
            {
              __int16 v84 = v227;
              v228 = &_dnssec_obj_context_kind;
              v227[1] = (uint64_t)&_dnssec_obj_context_kind;
              do
              {
                v229 = (void (*)(uint64_t *))v228[2];
                if (v229) {
                  v229(v84);
                }
                v228 = (_UNKNOWN **)*v228;
              }

              while (v228);
              ++*(_DWORD *)v84;
              v84[2] = a1;
              v84[3] = a2;
              uint64_t v230 = *(void *)(a2 + 136);
              uint64_t v231 = v230 + 5;
              *((_DWORD *)v84 + 8) = v230;
              v84[5] = v10;
              *((_BYTE *)v84 + 36) = v226;
              *((_DWORD *)v84 + 12) = 0;
              unint64_t v10 = (unint64_t)dnssec_obj_domain_name_create_with_labels(v6, 1, (int *)__src);
              if (LODWORD(__src[0])) {
                goto LABEL_574;
              }
              int v232 = *((_DWORD *)v84 + 12);
              v233 = calloc(1uLL, 0x98uLL);
              if (v233)
              {
                v234 = v233;
                v235 = &_dnssec_obj_validation_manager_kind;
                v233[1] = &_dnssec_obj_validation_manager_kind;
                do
                {
                  v236 = (void (*)(void *))v235[2];
                  if (v236) {
                    v236(v234);
                  }
                  v235 = (_UNKNOWN **)*v235;
                }

                while (v235);
                ++*(_DWORD *)v234;
                v234[2] = v10;
                ++*(_DWORD *)v10;
                v234[4] = 0LL;
                v234[5] = 0LL;
                *((_DWORD *)v234 + 12) = 0;
                *((_DWORD *)v234 + 13) = -6718;
                *((_DWORD *)v234 + 28) = 0;
                v234[7] = 0LL;
                v234[8] = 0LL;
                v234[11] = 0LL;
                v234[12] = 0LL;
                v234[10] = 0LL;
                v234[15] = 0LL;
                v234[16] = 0LL;
                *((_DWORD *)v234 + 34) = v232;
                *((_DWORD *)v234 + 35) = 0;
                *((_BYTE *)v234 + 144) = 0;
                ++*(_DWORD *)v234;
                LODWORD(__src[0]) = 0;
                ref_count_obj_release(v234);
                int v237 = __src[0];
                if (LODWORD(__src[0]))
                {
                  v238 = 0LL;
                }

                else
                {
                  v84[8] = (uint64_t)v234;
                  ++*(_DWORD *)v234;
                  ++*(_DWORD *)v84;
                  LODWORD(__src[0]) = 0;
                  v238 = v84;
                }

                ref_count_obj_release(v84);
                ref_count_obj_release((void *)v10);
                ref_count_obj_release(v234);
                if (!v237)
                {
                  *((_DWORD *)v238 + 12) = 0;
                  ++*(_DWORD *)v238;
                  v239 = *(void **)(v2 + 16);
                  int v36 = &unk_100164000;
                  if (v239) {
                    ref_count_obj_release(v239);
                  }
                  *(void *)(v2 + 16) = v238;
                  ++*(_DWORD *)v2;
                  v240 = *(void **)(a2 + 144);
                  unsigned int v5 = v272;
                  if (v240) {
                    ref_count_obj_release(v240);
                  }
                  *(void *)(a2 + 144) = v2;
                  *(void *)(a2 + 152) = dnssec_query_record_result_reply;
                  *(_BYTE *)(a2 + 615) = 1;
                  ref_count_obj_release((void *)v2);
                  uint64_t v2 = (uint64_t)v238;
                  goto LABEL_497;
                }

                ref_count_obj_release((void *)v2);
                uint64_t v2 = (uint64_t)v238;
                if (!v238) {
                  return 4294901759LL;
                }
LABEL_576:
                ref_count_obj_release((void *)v2);
                return 4294901759LL;
              }
            }
          }

LABEL_573:
          __break(1u);
LABEL_574:
          ref_count_obj_release(v84);
          if (v10) {
            ref_count_obj_release((void *)v10);
          }
          goto LABEL_576;
        }

        unsigned int v92 = *(unsigned __int16 *)(a2 + 320);
        if (!*(_WORD *)(a2 + 320))
        {
          if (v91) {
            goto LABEL_371;
          }
LABEL_162:
          int v93 = 5;
LABEL_346:
          unsigned int v178 = *(_DWORD *)(a1 + 64) + 1000 * v93;
          if (v178 <= 1) {
            unsigned int v178 = 1;
          }
          *(_DWORD *)(a2 + 240) = v178;
          BOOL v179 = (os_log_s *)mDNSLogCategory_Default;
          if (v36[1384] != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
          {
            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEBUG)) {
              goto LABEL_371;
            }
            uint64_t v180 = v36;
            int v181 = *(_DWORD *)(a2 + 252);
            unsigned int v182 = bswap32(*(unsigned __int16 *)(a2 + 320)) >> 16;
            for (uint64_t j = v6; ; j += v187 + 1)
            {
              unsigned __int16 v184 = 257;
              if (j >= v7 || !j) {
                break;
              }
              uint64_t v187 = *j;
              if (v187 > 0x3F)
              {
                unsigned __int16 v184 = 257;
                break;
              }

              if (!*j)
              {
                unsigned __int16 v184 = (_WORD)j - (_WORD)v6 + 1;
                break;
              }
            }
          }

          else
          {
            BOOL v179 = (os_log_s *)mDNSLogCategory_Default_redacted;
            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEBUG)) {
              goto LABEL_371;
            }
            uint64_t v180 = v36;
            int v181 = *(_DWORD *)(a2 + 252);
            unsigned int v182 = bswap32(*(unsigned __int16 *)(a2 + 320)) >> 16;
            for (k = v6; ; k += v185 + 1)
            {
              unsigned __int16 v184 = 257;
              if (k >= v7 || !k) {
                break;
              }
              uint64_t v185 = *k;
              if (v185 > 0x3F)
              {
                unsigned __int16 v184 = 257;
                break;
              }

              if (!*k)
              {
                unsigned __int16 v184 = (_WORD)k - (_WORD)v6 + 1;
                break;
              }
            }
          }

          int v188 = v184;
          int v189 = DNSTypeName(*(unsigned __int16 *)(a2 + 322));
          LODWORD(__src[0]) = 67110659;
          DWORD1(__src[0]) = v181;
          WORD4(__src[0]) = 1024;
          *(_DWORD *)((char *)__src + 10) = v182;
          HIWORD(__src[0]) = 2048;
          *(void *)&__src[1] = a2;
          WORD4(__src[1]) = 2160;
          *(void *)((char *)&__src[1] + 10) = 1752392040LL;
          WORD1(__src[2]) = 1040;
          DWORD1(__src[2]) = v188;
          WORD4(__src[2]) = 2101;
          *(void *)((char *)&__src[2] + 10) = v6;
          WORD1(__src[3]) = 2082;
          *(void *)((char *)&__src[3] + 4) = v189;
          _os_log_impl( (void *)&_mh_execute_header,  v179,  OS_LOG_TYPE_DEBUG,  "[R%u->Q%u] InitDNSConfig: Setting StopTime on the uDNS question %p %{sensitive, mask.hash, mdnsresponder:dom ain_name}.*P (%{public}s)",  (uint8_t *)__src,  0x3Cu);
          int v36 = v180;
          goto LABEL_370;
        }

LABEL_165:
        if (!v91)
        {
          unsigned int v94 = *(_DWORD *)(a1 + 64) + 30000;
          if (v94 <= 1) {
            unsigned int v94 = 1;
          }
          *(_DWORD *)(a2 + 240) = v94;
          int v95 = (os_log_s *)mDNSLogCategory_Default;
          if (v36[1384] != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
          {
            if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEBUG))
            {
              unsigned int v96 = __rev16(v92);
              for (m = v6; ; m += v106 + 1)
              {
                unsigned __int16 v98 = 257;
                if (m >= v7 || !m) {
                  break;
                }
                uint64_t v106 = *m;
                if (v106 > 0x3F)
                {
                  unsigned __int16 v98 = 257;
                  goto LABEL_234;
                }

                if (!*m)
                {
                  unsigned __int16 v98 = (_WORD)m - (_WORD)v6 + 1;
                  goto LABEL_234;
                }
              }

              goto LABEL_234;
            }
          }

          else
          {
            int v95 = (os_log_s *)mDNSLogCategory_Default_redacted;
            if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEBUG))
            {
              unsigned int v96 = __rev16(v92);
              for (n = v6; ; n += v99 + 1)
              {
                unsigned __int16 v98 = 257;
                if (n >= v7 || !n) {
                  break;
                }
                uint64_t v99 = *n;
                if (v99 > 0x3F)
                {
                  unsigned __int16 v98 = 257;
                  break;
                }

                if (!*n)
                {
                  unsigned __int16 v98 = (_WORD)n - (_WORD)v6 + 1;
                  break;
                }
              }

                  uint64_t v17 = a1 + 37865;
                  if (!v106)
                  {
                    int v100 = 1;
                    int v11 = a2;
                    goto LABEL_167;
                  }
                }

      reply = mrc_xpc_create_reply(object, v45, v35);
      xpc_release(v35);
      if (!reply) {
        return;
      }
      goto LABEL_44;
    case 8u:
      uint64_t v51 = _mdns_xpc_dictionary_get_object(object, "params", (const _xpc_type_s *)&_xpc_type_dictionary);
      if (!v51) {
        goto LABEL_129;
      }
      uint64_t v52 = v51;
      uint64_t v53 = xpc_dictionary_get_string(v51, "record_name");
      if (!v53) {
        goto LABEL_129;
      }
      int v54 = v53;
      LOBYTE(length) = 0;
      key_tag = mrc_xpc_record_cache_flush_params_get_key_tag(v52, (BOOL *)&length);
      if ((_BYTE)length)
      {
        uint64_t v56 = *(void (**)(const char *, uint64_t))(g_record_cache_handlers + 16);
        if (v56)
        {
          v56(v54, key_tag);
          goto LABEL_187;
        }
      }

      else
      {
        int v130 = *(void (**)(const char *))(g_record_cache_handlers + 8);
        if (v130)
        {
          v130(v54);
          goto LABEL_187;
        }
      }

      LODWORD(v25) = -6714;
      goto LABEL_42;
    default:
      goto LABEL_41;
  }

LABEL_234:
              int v126 = v98;
              BOOL v127 = DNSTypeName(*(unsigned __int16 *)(a2 + 322));
              LODWORD(__src[0]) = 67110403;
              DWORD1(__src[0]) = v96;
              WORD4(__src[0]) = 2048;
              *(void *)((char *)__src + 10) = a2;
              WORD1(__src[1]) = 2160;
              *(void *)((char *)&__src[1] + 4) = 1752392040LL;
              WORD6(__src[1]) = 1040;
              *(_DWORD *)((char *)&__src[1] + 14) = v126;
              WORD1(__src[2]) = 2101;
              *(void *)((char *)&__src[2] + 4) = v6;
              WORD6(__src[2]) = 2082;
              *(void *)((char *)&__src[2] + 14) = v127;
              _os_log_impl( (void *)&_mh_execute_header,  v95,  OS_LOG_TYPE_DEBUG,  "[Q%u] InitDNSConfig: Setting StopTime on the uDNS question %p %{sensitive, mask.hash, mdnsresponder:doma in_name}.*P (%{public}s)",  (uint8_t *)__src,  0x36u);
            }
          }
        }

        remove(__str);
        goto LABEL_235;
      }

      __int16 v84 = mDNSLogCategory_Default;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
      {
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_ERROR))
        {
LABEL_176:
          int v93 = __error();
          unsigned int v94 = strerror(*v93);
          *(_DWORD *)unsigned __int16 v133 = 136446466;
          *(void *)uint64_t v134 = __str;
          *(_WORD *)&v134[8] = 2082;
          v135 = v94;
          int v90 = "State Dump: file %{public}s cannot be opened, reason: %{public}s";
          int v91 = (os_log_s *)v84;
          unsigned int v92 = 22;
          goto LABEL_177;
        }
      }

      else
      {
        __int16 v84 = mDNSLogCategory_Default_redacted;
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_ERROR)) {
          goto LABEL_176;
        }
      }

LABEL_235:
        BOOL v128 = _Querier_ExcludeEncryptedDNSServices(a2);
        uint64_t v2 = a2 + 340;
        if (!uuid_is_null((const unsigned __int8 *)(a2 + 340)) && v128)
        {
          uuid_clear((unsigned __int8 *)(a2 + 340));
          uint64_t v129 = (os_log_s *)mDNSLogCategory_Default;
          if (v36[1384] != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
          {
            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_259;
            }
            v271 = v5;
            int v130 = *(_DWORD *)(a2 + 252);
            unsigned int v131 = bswap32(*(unsigned __int16 *)(a2 + 320)) >> 16;
            for (iuint64_t i = v6; ; ii += v136 + 1)
            {
              unsigned __int16 v133 = 257;
              if (ii >= v7 || !ii) {
                break;
              }
              uint64_t v136 = *ii;
              if (v136 > 0x3F)
              {
                unsigned __int16 v133 = 257;
                break;
              }

              if (!*ii)
              {
                unsigned __int16 v133 = (_WORD)ii - (_WORD)v6 + 1;
                break;
              }
            }
          }

          else
          {
            uint64_t v129 = (os_log_s *)mDNSLogCategory_Default_redacted;
            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_259;
            }
            v271 = v5;
            int v130 = *(_DWORD *)(a2 + 252);
            unsigned int v131 = bswap32(*(unsigned __int16 *)(a2 + 320)) >> 16;
            for (juint64_t j = v6; ; jj += v134 + 1)
            {
              unsigned __int16 v133 = 257;
              if (jj >= v7 || !jj) {
                break;
              }
              uint64_t v134 = *jj;
              if (v134 > 0x3F)
              {
                unsigned __int16 v133 = 257;
                break;
              }

              if (!*jj)
              {
                unsigned __int16 v133 = (_WORD)jj - (_WORD)v6 + 1;
                break;
              }
            }
          }

          int v137 = v133;
          v138 = DNSTypeName(*(unsigned __int16 *)(a2 + 322));
          LODWORD(__src[0]) = 67110403;
          DWORD1(__src[0]) = v130;
          WORD4(__src[0]) = 1024;
          *(_DWORD *)((char *)__src + 10) = v131;
          HIWORD(__src[0]) = 2160;
          *(void *)&__src[1] = 1752392040LL;
          WORD4(__src[1]) = 1040;
          *(_DWORD *)((char *)&__src[1] + 10) = v137;
          HIWORD(__src[1]) = 2101;
          *(void *)&__src[2] = v6;
          WORD4(__src[2]) = 2082;
          *(void *)((char *)&__src[2] + 10) = v138;
          _os_log_impl( (void *)&_mh_execute_header,  v129,  OS_LOG_TYPE_DEFAULT,  "[R%u->Q%u] Cleared resolver UUID for question: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%{public}s)",  (uint8_t *)__src,  0x32u);
          unsigned int v5 = v271;
          int v36 = &unk_100164000;
        }

                      __str[0] = 0;
                      uint64_t v119 = (os_log_s *)mDNSLogCategory_XPC;
                      uint64 = v128;
                      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_XPC == mDNSLogCategory_State)
                      {
                        if (os_log_type_enabled((os_log_t)mDNSLogCategory_XPC, OS_LOG_TYPE_DEFAULT))
                        {
LABEL_240:
                          unsigned int v120 = __error();
                          uint64_t v121 = strerror(*v120);
                          buf[0].st_dev = 136315138;
                          *(void *)&buf[0].st_mode = v121;
                          _os_log_impl( (void *)&_mh_execute_header,  v119,  OS_LOG_TYPE_DEFAULT,  "State Dump: Error happens when trying to compress the state dump, reason: %s",  (uint8_t *)buf,  0xCu);
                        }
                      }

                      else
                      {
                        uint64_t v119 = (os_log_s *)mDNSLogCategory_XPC_redacted;
                        if (os_log_type_enabled((os_log_t)mDNSLogCategory_XPC_redacted, OS_LOG_TYPE_DEFAULT)) {
                          goto LABEL_240;
                        }
                      }

                      uint64_t v29 = 255;
                      goto LABEL_242;
                    }

                    osos_log_t log = (os_log_s *)mDNSLogCategory_XPC;
                    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_XPC == mDNSLogCategory_State)
                    {
                      if (os_log_type_enabled((os_log_t)mDNSLogCategory_XPC, OS_LOG_TYPE_DEBUG))
                      {
LABEL_250:
                        *(_DWORD *)uint64_t v136 = 134218240;
                        *(void *)&v136[4] = v79;
                        *(_WORD *)&v136[12] = 1024;
                        *(_DWORD *)&v136[14] = st_size;
                        _os_log_impl( (void *)&_mh_execute_header,  oslog,  OS_LOG_TYPE_DEBUG,  "archive_write_data fails: amount_written(%ld) != (%u)",  v136,  0x12u);
                      }
                    }

                    else
                    {
                      osos_log_t log = (os_log_s *)mDNSLogCategory_XPC_redacted;
                      if (os_log_type_enabled((os_log_t)mDNSLogCategory_XPC_redacted, OS_LOG_TYPE_DEBUG)) {
                        goto LABEL_250;
                      }
                    }

                    munmap(v77, st_size);
                    close(v75);
                    archive_entry_free(v69);
                    archive_write_close(v127);
                    uint64_t v118 = v127;
                    goto LABEL_233;
                  }

                  int v100 = (os_log_s *)mDNSLogCategory_XPC;
                  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_XPC == mDNSLogCategory_State)
                  {
                    if (os_log_type_enabled((os_log_t)mDNSLogCategory_XPC, OS_LOG_TYPE_DEBUG))
                    {
LABEL_228:
                      unsigned int v116 = __error();
                      int v117 = strerror(*v116);
                      *(_DWORD *)uint64_t v136 = 136446210;
                      *(void *)&v136[4] = v117;
                      _os_log_impl( (void *)&_mh_execute_header,  v100,  OS_LOG_TYPE_DEBUG,  "mmap fails: %{public}s",  v136,  0xCu);
                    }
                  }

                  else
                  {
                    int v100 = (os_log_s *)mDNSLogCategory_XPC_redacted;
                    if (os_log_type_enabled((os_log_t)mDNSLogCategory_XPC_redacted, OS_LOG_TYPE_DEBUG)) {
                      goto LABEL_228;
                    }
                  }

                  close(v75);
                  goto LABEL_230;
                }

                unsigned __int16 v98 = (os_log_s *)mDNSLogCategory_XPC;
                if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_XPC == mDNSLogCategory_State)
                {
                  if (!os_log_type_enabled((os_log_t)mDNSLogCategory_XPC, OS_LOG_TYPE_DEBUG))
                  {
LABEL_230:
                    archive_entry_free(v69);
                    goto LABEL_231;
                  }
                }

                else
                {
                  unsigned __int16 v98 = (os_log_s *)mDNSLogCategory_XPC_redacted;
                  if (!os_log_type_enabled((os_log_t)mDNSLogCategory_XPC_redacted, OS_LOG_TYPE_DEBUG)) {
                    goto LABEL_230;
                  }
                }

                int v115 = archive_error_string(v64);
                *(_DWORD *)uint64_t v136 = 136446210;
                *(void *)&v136[4] = v115;
                _os_log_impl( (void *)&_mh_execute_header,  v98,  OS_LOG_TYPE_DEBUG,  "archive_write_header fails: %{public}s",  v136,  0xCu);
                goto LABEL_230;
              }

              BOOL v97 = (os_log_s *)mDNSLogCategory_XPC;
              if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_XPC == mDNSLogCategory_State)
              {
                if (os_log_type_enabled((os_log_t)mDNSLogCategory_XPC, OS_LOG_TYPE_DEBUG))
                {
LABEL_224:
                  unsigned int v112 = __error();
                  uint64_t v113 = strerror(*v112);
                  *(_DWORD *)uint64_t v136 = 136446210;
                  *(void *)&v136[4] = v113;
                  _os_log_impl( (void *)&_mh_execute_header,  v97,  OS_LOG_TYPE_DEBUG,  "archive_entry_new fails: %{public}s",  v136,  0xCu);
                }
              }

              else
              {
                BOOL v97 = (os_log_s *)mDNSLogCategory_XPC_redacted;
                if (os_log_type_enabled((os_log_t)mDNSLogCategory_XPC_redacted, OS_LOG_TYPE_DEBUG)) {
                  goto LABEL_224;
                }
              }

LABEL_259:
        uint64_t v139 = *(void **)(a2 + 80);
        if (v139)
        {
          os_release(v139);
          *(void *)(a2 + 80) = 0LL;
        }

        uint64_t DNSService = _Querier_GetDNSService(a2, v128);
        uint64_t v141 = (void *)DNSService;
        if (v128)
        {
LABEL_262:
          *(void *)(a2 + 80) = v141;
          if (!v141) {
            goto LABEL_276;
          }
LABEL_297:
          uint64_t v152 = v36;
          os_retain(v141);
          uint64_t v153 = *(void *)(a2 + 80);
          __int16 v84 = *(uint64_t **)(a2 + 144);
          if (v153)
          {
            int v154 = *(uint64_t **)(v153 + 112);
            if (!v154)
            {
              uint64_t v168 = malloc(8uLL);
              unint64_t v10 = 0x100158000LL;
              if (!v168) {
                goto LABEL_573;
              }
              char v169 = v168;
              *uint64_t v168 = mach_continuous_time();
              *(void *)(v153 + 112) = v169;
              *(void *)(v153 + 120) = mdns_free_context_finalizer;
              int v36 = v152;
              goto LABEL_305;
            }

            uint64_t v155 = mach_continuous_time();
            uint64_t v156 = v155 - *v154;
            if (mdns_mach_ticks_per_second_s_once != -1) {
              dispatch_once(&mdns_mach_ticks_per_second_s_once, &__block_literal_global_3412);
            }
            if (v156 / mdns_mach_ticks_per_second_s_ticks_per_second < 0x3C)
            {
              int v36 = v152;
              int v170 = (os_log_s *)mDNSLogCategory_Default;
              if (v152[1384] != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
              {
                unint64_t v10 = 0x100158000LL;
                if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
                  goto LABEL_371;
                }
                int v171 = *(_DWORD *)(a2 + 252);
                unsigned int v172 = bswap32(*(unsigned __int16 *)(a2 + 320)) >> 16;
                uint64_t v173 = *(void *)(a2 + 80);
                if (v173) {
                  uint64_t v173 = *(void *)(v173 + 24);
                }
              }

              else
              {
                int v170 = (os_log_s *)mDNSLogCategory_Default_redacted;
                unint64_t v10 = 0x100158000LL;
                if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
                  goto LABEL_371;
                }
                int v171 = *(_DWORD *)(a2 + 252);
                unsigned int v172 = bswap32(*(unsigned __int16 *)(a2 + 320)) >> 16;
                uint64_t v173 = *(void *)(a2 + 80);
                if (v173) {
                  uint64_t v173 = *(void *)(v173 + 24);
                }
              }

              LODWORD(__src[0]) = 67109632;
              DWORD1(__src[0]) = v171;
              WORD4(__src[0]) = 1024;
              *(_DWORD *)((char *)__src + 10) = v172;
              HIWORD(__src[0]) = 2048;
              *(void *)&__src[1] = v173;
              _os_log_impl( (void *)&_mh_execute_header,  v170,  OS_LOG_TYPE_DEFAULT,  "[R%u->Q%u] Question assigned DNS service %llu",  (uint8_t *)__src,  0x18u);
LABEL_371:
              if (*(_DWORD *)(a2 + 240))
              {
                mDNS_VerifyLockState( "Check Lock",  1,  *(_DWORD *)(a1 + 48),  *(_DWORD *)(a1 + 52),  (uint64_t)"SetNextQueryStopTime",  399);
                int v190 = *(_DWORD *)(a2 + 240);
                if (*(_DWORD *)(a1 + 188) - v190 >= 1) {
                  *(_DWORD *)(a1 + 188) = v190;
                }
              }

              goto LABEL_377;
            }

            *int v154 = v155;
          }

          int v36 = v152;
LABEL_304:
          unint64_t v10 = 0x100158000LL;
LABEL_305:
          uint64_t v157 = (os_log_s *)mDNSLogCategory_Default;
          if (v36[1384] != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
          {
            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_371;
            }
            int v158 = v5;
            int v164 = *(_DWORD *)(a2 + 252);
            unsigned int v160 = bswap32(*(unsigned __int16 *)(a2 + 320)) >> 16;
            for (kk = v6; ; kk += v167 + 1)
            {
              unsigned __int16 v166 = 257;
              if (kk >= v7 || !kk) {
                break;
              }
              uint64_t v167 = *kk;
              if (v167 > 0x3F)
              {
                unsigned __int16 v166 = 257;
                break;
              }

              if (!*kk)
              {
                unsigned __int16 v166 = (_WORD)kk - (_WORD)v6 + 1;
                break;
              }
            }

            int v174 = v166;
            v175 = DNSTypeName(*(unsigned __int16 *)(a2 + 322));
            uint64_t v176 = *(void *)(a2 + 80);
            v177 = ", DNSSEC";
            LODWORD(__src[0]) = 67110915;
            DWORD1(__src[0]) = v164;
            if (!v84) {
              v177 = "";
            }
          }

          else
          {
            uint64_t v157 = (os_log_s *)mDNSLogCategory_Default_redacted;
            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_371;
            }
            int v158 = v5;
            int v159 = *(_DWORD *)(a2 + 252);
            unsigned int v160 = bswap32(*(unsigned __int16 *)(a2 + 320)) >> 16;
            for (mm = v6; ; mm += v163 + 1)
            {
              unsigned __int16 v162 = 257;
              if (mm >= v7 || !mm) {
                break;
              }
              uint64_t v163 = *mm;
              if (v163 > 0x3F)
              {
                unsigned __int16 v162 = 257;
                break;
              }

              if (!*mm)
              {
                unsigned __int16 v162 = (_WORD)mm - (_WORD)v6 + 1;
                break;
              }
            }

            int v174 = v162;
            v175 = DNSTypeName(*(unsigned __int16 *)(a2 + 322));
            uint64_t v176 = *(void *)(a2 + 80);
            v177 = ", DNSSEC";
            LODWORD(__src[0]) = 67110915;
            DWORD1(__src[0]) = v159;
            if (!v84) {
              v177 = "";
            }
          }

          WORD4(__src[0]) = 1024;
          *(_DWORD *)((char *)__src + 10) = v160;
          HIWORD(__src[0]) = 2160;
          *(void *)&__src[1] = 1752392040LL;
          WORD4(__src[1]) = 1040;
          *(_DWORD *)((char *)&__src[1] + 10) = v174;
          HIWORD(__src[1]) = 2101;
          *(void *)&__src[2] = v6;
          WORD4(__src[2]) = 2082;
          *(void *)((char *)&__src[2] + 10) = v175;
          WORD1(__src[3]) = 2082;
          *(void *)((char *)&__src[3] + 4) = v177;
          WORD6(__src[3]) = 2112;
          *(void *)((char *)&__src[3] + 14) = v176;
          _os_log_impl( (void *)&_mh_execute_header,  v157,  OS_LOG_TYPE_DEFAULT,  "[R%u->Q%u] Question for %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%{public}s%{public}s) assigne d DNS service -- %@",  (uint8_t *)__src,  0x46u);
          unsigned int v5 = v158;
          int v36 = (_BYTE *)&unk_100164000;
LABEL_370:
          unint64_t v10 = (unint64_t)&unk_100158000;
          goto LABEL_371;
        }

        if (DNSService)
        {
          if ((*(_BYTE *)(a2 + 307) & 0x40) != 0)
          {
            uint64_t v142 = *(void *)(a2 + 88);
            if (v142)
            {
              if (!*(void *)(a2 + 136) && *(_BYTE *)(DNSService + 282) != 1)
              {
                if (*(void *)(DNSService + 24) != v142
                  && *(_BYTE *)(DNSService + 280) == 1
                  && *(unsigned __int8 *)(DNSService + 281) - 2 >= 4
                  && (*(_WORD *)(DNSService + 276) & 0x200) == 0)
                {
                  unsigned int v143 = "avoid non-private DNS service";
                  goto LABEL_278;
                }

                if (!uuid_is_null((const unsigned __int8 *)(a2 + 340))
                  && _Querier_VPNDNSServiceExistsForQName((uint64_t)v6))
                {
                  unsigned int v143 = "QNAME is in a VPN DNS service's domain";
                  goto LABEL_278;
                }
              }
            }
          }

          *(void *)(a2 + 80) = v141;
          goto LABEL_297;
        }

        if (uuid_is_null((const unsigned __int8 *)(a2 + 340)))
        {
          *(void *)(a2 + 80) = 0LL;
LABEL_276:
          __int16 v84 = *(uint64_t **)(a2 + 144);
          goto LABEL_304;
        }

        unsigned int v143 = "ResolverUUID may be stale";
LABEL_278:
        uint64_t v2 = mDNSLogCategory_Default;
        if (v36[1384] != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
        {
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEBUG))
          {
            uint64_t v144 = v5;
            int v145 = *(_DWORD *)(a2 + 252);
            unsigned int v146 = bswap32(*(unsigned __int16 *)(a2 + 320)) >> 16;
            for (nn = v6; ; nn += v151 + 1)
            {
              unsigned __int16 v148 = 257;
              if (nn >= v7 || !nn) {
                break;
              }
              uint64_t v151 = *nn;
              if (v151 > 0x3F)
              {
                unsigned __int16 v148 = 257;
                goto LABEL_571;
              }

              if (!*nn)
              {
                unsigned __int16 v148 = (_WORD)nn - (_WORD)v6 + 1;
                goto LABEL_571;
              }
            }

            goto LABEL_571;
          }
        }

        else
        {
          uint64_t v2 = mDNSLogCategory_Default_redacted;
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEBUG))
          {
            uint64_t v144 = v5;
            int v145 = *(_DWORD *)(a2 + 252);
            unsigned int v146 = bswap32(*(unsigned __int16 *)(a2 + 320)) >> 16;
            for (i1 = v6; ; i1 += v149 + 1)
            {
              unsigned __int16 v148 = 257;
              if (i1 >= v7 || !i1) {
                break;
              }
              uint64_t v149 = *i1;
              if (v149 > 0x3F)
              {
                unsigned __int16 v148 = 257;
                break;
              }

              if (!*i1)
              {
                unsigned __int16 v148 = (_WORD)i1 - (_WORD)v6 + 1;
                break;
              }
            }

LABEL_571:
            int v267 = v148;
            v268 = DNSTypeName(*(unsigned __int16 *)(a2 + 322));
            LODWORD(__src[0]) = 67110659;
            DWORD1(__src[0]) = v145;
            WORD4(__src[0]) = 1024;
            *(_DWORD *)((char *)__src + 10) = v146;
            HIWORD(__src[0]) = 2160;
            *(void *)&__src[1] = 1752392040LL;
            WORD4(__src[1]) = 1040;
            *(_DWORD *)((char *)&__src[1] + 10) = v267;
            HIWORD(__src[1]) = 2101;
            *(void *)&__src[2] = v6;
            WORD4(__src[2]) = 2082;
            *(void *)((char *)&__src[2] + 10) = v268;
            WORD1(__src[3]) = 2082;
            *(void *)((char *)&__src[3] + 4) = v143;
            _os_log_impl( (void *)&_mh_execute_header,  (os_log_t)v2,  OS_LOG_TYPE_DEBUG,  "[R%u->Q%u] Retrying path evaluation -- qname: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P, qtype : %{public}s, reason: %{public}s",  (uint8_t *)__src,  0x3Cu);
            unsigned int v5 = v144;
            int v36 = (_BYTE *)&unk_100164000;
          }
        }

        mDNSPlatformGetDNSRoutePolicy(a2);
        uint64_t v141 = (void *)_Querier_GetDNSService(a2, 0);
        goto LABEL_262;
      }

      unsigned int v92 = *(unsigned __int16 *)(a2 + 320);
      if (*(_WORD *)(a2 + 320))
      {
        if (!v90) {
          goto LABEL_235;
        }
        goto LABEL_165;
      }

      if (!v90 || v91) {
        goto LABEL_371;
      }
      int v100 = *v6;
      if (*v6)
      {
        int v101 = 0;
        uint64_t v102 = v6;
        do
        {
          ++v101;
          uint64_t v103 = &v102[v100];
          int v104 = v103[1];
          uint64_t v102 = v103 + 1;
          int v100 = v104;
        }

        while (v104);
      }

      else
      {
        int v101 = 0;
      }

      uint64_t v113 = *(uint64_t **)(a1 + 12696);
      if (v113)
      {
        uint64_t v114 = 0LL;
        int v115 = -1;
        do
        {
          unsigned int v116 = *((unsigned __int8 *)v113 + 20);
          if (*((_BYTE *)v113 + 20))
          {
            int v117 = 0;
            uint64_t v118 = (uint64_t)v113 + 20;
            do
            {
              ++v117;
              uint64_t v119 = v118 + v116;
              unsigned int v120 = *(unsigned __int8 *)(v119 + 1);
              uint64_t v118 = v119 + 1;
              unsigned int v116 = v120;
            }

            while (v120);
          }

          else
          {
            int v117 = 0;
          }

          if (v101 >= v117 && v117 >= v115)
          {
            uint64_t v121 = v6;
            if (v101 - v117 >= 1)
            {
              int v122 = v101 + 1 - v117;
              uint64_t v121 = v6;
              do
              {
                if (!*v121) {
                  break;
                }
                v121 += *v121 + 1;
                --v122;
              }

              while (v122 > 1);
            }

            else {
              BOOL v123 = 1;
            }
            char v124 = !v123;
            if ((v124 & 1) != 0)
            {
              uint64_t v114 = v113;
              int v115 = v117;
            }
          }

          uint64_t v113 = (uint64_t *)*v113;
        }

        while (v113);
        unint64_t v10 = (unint64_t)&unk_100158000;
        if ((mDNS_LoggingEnabled & 1) == 0)
        {
          int v36 = (_BYTE *)&unk_100164000;
          goto LABEL_344;
        }

        char v125 = (os_log_s *)mDNSLogCategory_Default;
        int v36 = &unk_100164000;
      }

      else
      {
        unint64_t v10 = (unint64_t)&unk_100158000;
        if (mDNS_LoggingEnabled != 1)
        {
          int v93 = 5;
          int v36 = (_BYTE *)&unk_100164000;
          goto LABEL_346;
        }

        uint64_t v114 = 0LL;
        char v125 = (os_log_s *)mDNSLogCategory_Default;
        int v36 = (_BYTE *)&unk_100164000;
      }

      LogMsgWithLevel( v125,  OS_LOG_TYPE_DEFAULT,  "GetTimeoutForMcastQuestion: question %##s curmatch %p, Timeout %d",  v64,  v65,  v66,  v67,  v68,  (int)v6);
LABEL_344:
      if (v114)
      {
        int v93 = *((_DWORD *)v114 + 69);
        goto LABEL_346;
      }

      goto LABEL_162;
    }

    *(_DWORD *)(a2 + 280) = -1;
    if ((v74 & 0x40000000) != 0)
    {
      if (!*(_BYTE *)(a2 + 622)) {
        goto LABEL_152;
      }
      __int16 v76 = (os_log_s *)mDNSLogCategory_Default;
      if (v36[1384] != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
      {
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
        {
LABEL_150:
          int v87 = *(_DWORD *)(a2 + 252);
          unsigned int v88 = bswap32(*(unsigned __int16 *)(a2 + 320)) >> 16;
          LODWORD(__src[0]) = 67109376;
          DWORD1(__src[0]) = v87;
          WORD4(__src[0]) = 1024;
          *(_DWORD *)((char *)__src + 10) = v88;
          _os_log_impl( (void *)&_mh_execute_header,  v76,  OS_LOG_TYPE_DEFAULT,  "[R%u->Q%u] Forcing another path evaluation",  (uint8_t *)__src,  0xEu);
        }
      }

      else
      {
        __int16 v76 = (os_log_s *)mDNSLogCategory_Default_redacted;
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_150;
        }
      }
    }

    *(_BYTE *)(a2 + 622) = 0;
    mDNSPlatformGetDNSRoutePolicy(a2);
    goto LABEL_152;
  }

  int v54 = (os_log_s *)mDNSLogCategory_Default;
  if (v36[1384] != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
  {
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
      return v2;
    }
    uint64_t v56 = v6;
    int v57 = 257;
    if (!v7) {
      goto LABEL_96;
    }
LABEL_93:
    if (v56 < v7 && v56)
    {
      while (1)
      {
        uint64_t v58 = *v56;
        if (v58 > 0x3F)
        {
LABEL_141:
          int v57 = 257;
          goto LABEL_148;
        }

        if (!*v56) {
          break;
        }
        v56 += v58 + 1;
        if (v7) {
          goto LABEL_93;
        }
LABEL_96:
        if (!v56) {
          goto LABEL_141;
        }
      }

      int v57 = (unsigned __int16)((_WORD)v56 - (_WORD)v6 + 1);
    }

LABEL_148:
    uint64_t v86 = DNSTypeName(*(unsigned __int16 *)(a2 + 322));
    LODWORD(__src[0]) = 141559043;
    *(void *)((char *)__src + 4) = 1752392040LL;
    WORD6(__src[0]) = 1040;
    *(_DWORD *)((char *)__src + 14) = v57;
    WORD1(__src[1]) = 2101;
    *(void *)((char *)&__src[1] + 4) = v6;
    WORD6(__src[1]) = 2082;
    *(void *)((char *)&__src[1] + 14) = v86;
    WORD3(__src[2]) = 2048;
    *((void *)&__src[2] + 1) = a2;
    _os_log_impl( (void *)&_mh_execute_header,  v54,  OS_LOG_TYPE_DEFAULT,  "mDNS_StartQuery_internal: Error! Tried to add a question %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%{ public}s) %p that's already in the active list",  (uint8_t *)__src,  0x30u);
    return v2;
  }

  int v54 = (os_log_s *)mDNSLogCategory_Default_redacted;
  if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v71 = v6;
    int v57 = 257;
    if (!v7) {
      goto LABEL_114;
    }
LABEL_111:
    if (v71 < v7 && v71)
    {
      while (1)
      {
        uint64_t v72 = *v71;
        if (v72 > 0x3F)
        {
LABEL_142:
          int v57 = 257;
          goto LABEL_148;
        }

        if (!*v71) {
          break;
        }
        v71 += v72 + 1;
        if (v7) {
          goto LABEL_111;
        }
LABEL_114:
        if (!v71) {
          goto LABEL_142;
        }
      }

      int v57 = (unsigned __int16)((_WORD)v71 - (_WORD)v6 + 1);
    }

    goto LABEL_148;
  }

  return v2;
}

                uint64_t v79 = *(_DWORD *)(v76 + 212);
                switch(v79)
                {
                  case 1:
                    uint64_t v80 = (os_log_s *)mDNSLogCategory_Default;
                    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
                    {
                      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
                        goto LABEL_429;
                      }
                    }

                    else
                    {
                      uint64_t v80 = (os_log_s *)mDNSLogCategory_Default_redacted;
                      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
                        goto LABEL_429;
                      }
                    }

                    v286 = *(_DWORD *)(v76 + 184);
                    v287 = *(_DWORD *)(v76 + 172);
                    v1489.st_dev = 67109634;
                    *(_DWORD *)&v1489.st_mode = v286;
                    LOWORD(v1489.st_ino) = 1024;
                    *(_DWORD *)((char *)&v1489.st_ino + 2) = v287;
                    HIWORD(v1489.st_ino) = 2082;
                    *(void *)&v1489.st_uid = v76 + 240;
                    _os_log_impl( (void *)&_mh_execute_header,  v80,  OS_LOG_TYPE_DEFAULT,  "[R%d] DNSServiceCreateConnection START PID[%d](%{public}s)",  (uint8_t *)&v1489,  0x18u);
LABEL_429:
                    updated = 0;
                    *(void *)(v76 + 96) = connection_termination;
                    goto LABEL_1122;
                  case 2:
                    if (*(void (**)(uint64_t))(v76 + 96) != connection_termination)
                    {
                      LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "%3d: DNSServiceRegisterRecord(not a shared connection ref)",  a4,  a5,  a6,  a7,  a8,  *(_DWORD *)(v76 + 168));
                      goto LABEL_1121;
                    }

                    rr_from_ipc_msg = read_rr_from_ipc_msg(v76, 1, 1);
                    __src[0] = 0;
                    *(_DWORD *)buf = 0;
                    service_attr_tsr_params = get_service_attr_tsr_params(v76, (int *)__src, buf);
                    updated = -65540;
                    if (!rr_from_ipc_msg) {
                      goto LABEL_1122;
                    }
                    v318 = service_attr_tsr_params;
                    if (service_attr_tsr_params)
                    {
                      v319 = __src[0];
                      if (__src[0] > 0x93A80)
                      {
                        v320 = mDNSLogCategory_mDNS;
                        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
                        {
                          updated = -65540;
                          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_ERROR)) {
                            goto LABEL_1122;
                          }
                          v321 = rr_from_ipc_msg[5];
                          if (v321)
                          {
                            v322 = (_BYTE *)rr_from_ipc_msg[5];
                            if (v321 == -256)
                            {
LABEL_992:
                              while (v322)
                              {
                                v595 = *v322;
                                if (!*v322)
                                {
                                  LOWORD(v322) = (_WORD)v322 - v321 + 1;
                                  goto LABEL_1324;
                                }

                                v322 += v595 + 1;
                                if (v321 != -256) {
                                  goto LABEL_991;
                                }
                              }
                            }

                            else
                            {
LABEL_991:
                            }

                            LOWORD(v322) = 257;
LABEL_1324:
                            LODWORD(v322) = (unsigned __int16)v322;
                          }

                          else
                          {
                            LODWORD(v322) = 0;
                          }
                        }

                        else
                        {
                          v320 = mDNSLogCategory_mDNS_redacted;
                          updated = -65540;
                          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_ERROR)) {
                            goto LABEL_1122;
                          }
                          v321 = rr_from_ipc_msg[5];
                          if (v321)
                          {
                            v322 = (_BYTE *)rr_from_ipc_msg[5];
                            if (v321 == -256)
                            {
LABEL_470:
                              while (v322)
                              {
                                v323 = *v322;
                                if (!*v322)
                                {
                                  LOWORD(v322) = (_WORD)v322 - v321 + 1;
                                  goto LABEL_1322;
                                }

                                v322 += v323 + 1;
                                if (v321 != -256) {
                                  goto LABEL_469;
                                }
                              }
                            }

                            else
                            {
LABEL_469:
                            }

                            LOWORD(v322) = 257;
LABEL_1322:
                            LODWORD(v322) = (unsigned __int16)v322;
                          }

                          else
                          {
                            LODWORD(v322) = 0;
                          }
                        }

                        v1489.st_dev = 67110147;
                        *(_DWORD *)&v1489.st_mode = v319;
                        v1489.st_ino = 0x87000093A800400LL;
                        *(void *)&v1489.st_uid = 1752392040LL;
                        LOWORD(v1489.st_rdev) = 1040;
                        *(dev_t *)((char *)&v1489.st_rdev + 2) = (int)v322;
                        *((_WORD *)&v1489.st_rdev + 3) = 2101;
                        v1489.st_atimespec.tv_sec = v321;
                        uint64_t v114 = &v1489;
                        int v115 = (os_log_s *)v320;
                        unsigned int v116 = OS_LOG_TYPE_ERROR;
                        int v117 = "tsrTimestamp[%u] out of range (%u) on TSR for %{sensitive, mask.hash, mdnsresponder:domain_name}.*P";
                        v674 = 40;
                        goto LABEL_1120;
                      }

                      v1489.st_ino = 0LL;
                      *(void *)&v1489.st_dev = 0LL;
                      clock_gettime(_CLOCK_MONOTONIC_RAW, (timespec *)&v1489);
                      v494 = v1489.st_dev - v319;
                    }

                    else
                    {
                      v494 = 0;
                    }

                    v502 = mDNSGetTSRForAuthRecordNamed( (uint64_t *)xmmword_10015BD08,  (_BYTE *)rr_from_ipc_msg[5],  *((_DWORD *)rr_from_ipc_msg + 6));
                    v509 = v502;
                    v510 = (void *)*(int *)(v76 + 168);
                    rr_from_ipc_msg[12] = v510;
                    v1409 = v494;
                    if (!v318 && !v502) {
                      goto LABEL_852;
                    }
                    v511 = v318;
                    v512 = v502;
                    if ((_DWORD)v510) {
                      v513 = v510;
                    }
                    else {
                      v513 = rr_from_ipc_msg;
                    }
                    v514 = xmmword_10015BD08;
                    if ((void)xmmword_10015BD08)
                    {
                      while (1)
                      {
                        v515 = *(void *)(v514 + 96);
                        if (!v515) {
                          v515 = v514;
                        }
                        v516 = *(_WORD *)(v514 + 12) == 41 || v513 == (void *)v515;
                        if (!v516
                          && SameResourceRecordNameClassInterface( v514,  (uint64_t)rr_from_ipc_msg,  v503,  v504,  v505,  v506,  v507,  v508)
                          && (!resource_records_have_same_dnssec_rr_category( *(void *)(v514 + 64),  rr_from_ipc_msg[8])
                           || *(unsigned __int16 *)(v514 + 12) != *((unsigned __int16 *)rr_from_ipc_msg + 6)
                           || *(unsigned __int16 *)(v514 + 14) != *((unsigned __int16 *)rr_from_ipc_msg + 7)
                           || *(unsigned __int16 *)(v514 + 20) != *((unsigned __int16 *)rr_from_ipc_msg + 10)
                           || *(_DWORD *)(v514 + 28) != *((_DWORD *)rr_from_ipc_msg + 7)
                           || !SameRDataBody( v514 + 8,  (unsigned __int16 *)(rr_from_ipc_msg[6] + 4LL),  (uint64_t (*)(uint64_t, unsigned __int16 *))SameDomainName))
                          && ((rr_from_ipc_msg[1] & 0x32) != 0 || (*(_BYTE *)(v514 + 8) & 0x32) != 0))
                        {
                          break;
                        }

                        v514 = *(void *)v514;
                        if (!v514) {
                          goto LABEL_839;
                        }
                      }

                      v636 = (os_log_s *)mDNSLogCategory_mDNS;
                      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
                      {
                        if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
                          goto LABEL_1178;
                        }
                      }

                      else
                      {
                        v636 = (os_log_s *)mDNSLogCategory_mDNS_redacted;
                        if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
                        {
LABEL_1178:
                          GetRRDisplayString_rdb( (unsigned __int8 *)(v514 + 8),  (unsigned __int16 *)(*(void *)(v514 + 48) + 4LL),  word_100164338);
                          v706 = *(void *)(v514 + 32);
                          v1489.st_dev = 141558787;
                          *(void *)&v1489.st_mode = 1752392040LL;
                          WORD2(v1489.st_ino) = 2085;
                          *(__darwin_ino64_t *)((char *)&v1489.st_ino + 6) = (__darwin_ino64_t)word_100164338;
                          HIWORD(v1489.st_gid) = 2048;
                          *(void *)&v1489.st_rdev = v514;
                          LOWORD(v1489.st_atimespec.tv_sec) = 2048;
                          *(__darwin_time_t *)((char *)&v1489.st_atimespec.tv_sec + 2) = v706;
                          _os_log_impl( (void *)&_mh_execute_header,  v636,  OS_LOG_TYPE_DEFAULT,  "Conflict with %{sensitive, mask.hash}s (%p), InterfaceID %p",  (uint8_t *)&v1489,  0x2Au);
                        }
                      }

                      v707 = (os_log_s *)mDNSLogCategory_mDNS;
                      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
                      {
                        if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
                          goto LABEL_1184;
                        }
                      }

                      else
                      {
                        v707 = (os_log_s *)mDNSLogCategory_mDNS_redacted;
                        if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
                        {
LABEL_1184:
                          GetRRDisplayString_rdb( (unsigned __int8 *)rr_from_ipc_msg + 8,  (unsigned __int16 *)(rr_from_ipc_msg[6] + 4LL),  word_100164338);
                          v708 = rr_from_ipc_msg[4];
                          v1489.st_dev = 141558787;
                          *(void *)&v1489.st_mode = 1752392040LL;
                          WORD2(v1489.st_ino) = 2085;
                          *(__darwin_ino64_t *)((char *)&v1489.st_ino + 6) = (__darwin_ino64_t)word_100164338;
                          HIWORD(v1489.st_gid) = 2048;
                          *(void *)&v1489.st_rdev = rr_from_ipc_msg;
                          LOWORD(v1489.st_atimespec.tv_sec) = 2048;
                          *(__darwin_time_t *)((char *)&v1489.st_atimespec.tv_sec + 2) = v708;
                          _os_log_impl( (void *)&_mh_execute_header,  v707,  OS_LOG_TYPE_DEFAULT,  "handle_regrecord_request: Name conflict %{sensitive, mask.hash}s (%p), InterfaceID %p",  (uint8_t *)&v1489,  0x2Au);
                        }
                      }

                      free(rr_from_ipc_msg);
                      updated = -65548;
                      goto LABEL_1122;
                    }

  BOOL v123 = v12 + 40;
  do
  {
    char v124 = v123;
    char v125 = *v123;
    BOOL v123 = (void *)(*v123 + 8LL);
    if (v125) {
      int v126 = v125 == v11;
    }
    else {
      int v126 = 1;
    }
  }

  while (!v126);
  if (v125)
  {
    *char v124 = *v123;
    BOOL v127 = *(void **)(v11 + 24);
    if (v127) {
      free(v127);
    }
    unint64_t v39 = (void *)v11;
LABEL_158:
    free(v39);
    return;
  }

  uint64_t v121 = mDNSLogCategory_mDNS;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
  {
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v129 = v12[46];
      *(_DWORD *)buf = 67109120;
      *(_DWORD *)unsigned __int16 v162 = v129;
      uint64_t v33 = "[R%u] regrecord_callback - record not in list!";
      goto LABEL_175;
    }
  }

  else
  {
    uint64_t v121 = mDNSLogCategory_mDNS_redacted;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
    {
      unsigned __int16 v133 = v12[46];
      *(_DWORD *)buf = 67109120;
      *(_DWORD *)unsigned __int16 v162 = v133;
      uint64_t v33 = "[R%u] regrecord_callback - record not in list!";
      goto LABEL_175;
    }
  }

BOOL IsLocalDomain(_BYTE *a1)
{
  int v1 = *a1;
  if (!*a1) {
    return 0LL;
  }
  uint64_t v2 = 0LL;
  int v3 = 0LL;
  uint64_t v4 = 0LL;
  unsigned int v5 = 0LL;
  do
  {
    int v6 = a1;
    unint64_t v7 = v3;
    unint64_t v8 = v2;
    uint64_t v9 = &a1[v1];
    int v10 = v9[1];
    a1 = v9 + 1;
    int v1 = v10;
    uint64_t v2 = v3;
    int v3 = v4;
    uint64_t v4 = v5;
    unsigned int v5 = v6;
  }

  while (v10);
  return SameDomainNameBytes(v6, "\x05local")
      || v7 && SameDomainNameBytes(v7, "\x03254\x03169\ain-addr\x04arpa")
      || v8
      && (SameDomainNameBytes(v8, "\x018\x01e\x01f\x03ip6\x04arpa")
       || SameDomainNameBytes(v8, "\x019\x01e\x01f\x03ip6\x04arpa")
}

uint64_t *GetAuthInfoForName_internal(uint64_t a1, _BYTE *a2)
{
  int v3 = *(char **)(a1 + 12768);
  if (v3)
  {
    uint64_t v4 = (void **)(a1 + 12768);
    while (1)
    {
      int v5 = *((_DWORD *)v3 + 2);
      if (v5)
      {
        if (*(_DWORD *)(a1 + 64) - v5 >= 0) {
          break;
        }
      }

      uint64_t v4 = (void **)v3;
LABEL_55:
      int v3 = (char *)*v4;
      if (!*v4) {
        return GetAuthInfoForName_direct(a1, a2);
      }
    }

    int v6 = (os_log_s *)mDNSLogCategory_uDNS;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_uDNS == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_uDNS, OS_LOG_TYPE_DEFAULT))
      {
LABEL_50:
        *uint64_t v4 = *(void **)v3;
        for (uint64_t i = *(void *)(a1 + 200); i; uint64_t i = *(void *)(i + 8))
        {
        }

        free(v3);
        goto LABEL_55;
      }

      unint64_t v8 = v3 + 268;
      uint64_t v9 = v3 + 12;
      if (v3 == (char *)-268LL)
      {
LABEL_13:
        while (v9)
        {
          uint64_t v10 = *v9;
          if (!*v9)
          {
            LOWORD(v9) = (_WORD)v9 - ((_WORD)v3 + 12) + 1;
            goto LABEL_30;
          }

          v9 += v10 + 1;
        }
      }

      else
      {
LABEL_12:
        if (v9 < v8) {
          goto LABEL_13;
        }
      }

      LOWORD(v9) = 257;
LABEL_30:
      LODWORD(v9) = (unsigned __int16)v9;
      uint64_t v14 = v3 + 268;
      if (v3 == (char *)-524LL)
      {
LABEL_32:
        while (v14)
        {
          uint64_t v15 = *v14;
          if (!*v14)
          {
            unsigned __int16 v16 = (_WORD)v14 - (_WORD)v8 + 1;
            goto LABEL_49;
          }

          v14 += v15 + 1;
        }
      }

      else
      {
LABEL_31:
        if (v14 < v3 + 524) {
          goto LABEL_32;
        }
      }

      unsigned __int16 v16 = 257;
    }

    else
    {
      int v6 = (os_log_s *)mDNSLogCategory_uDNS_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_uDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_50;
      }
      unint64_t v12 = v3 + 268;
      uint64_t v9 = v3 + 12;
      if (v3 == (char *)-268LL)
      {
LABEL_22:
        while (v9)
        {
          uint64_t v13 = *v9;
          if (!*v9)
          {
            LOWORD(v9) = (_WORD)v9 - ((_WORD)v3 + 12) + 1;
            goto LABEL_39;
          }

          v9 += v13 + 1;
        }
      }

      else
      {
LABEL_21:
        if (v9 < v12) {
          goto LABEL_22;
        }
      }

      LOWORD(v9) = 257;
LABEL_39:
      LODWORD(v9) = (unsigned __int16)v9;
      uint64_t v17 = v3 + 268;
      if (v3 == (char *)-524LL)
      {
LABEL_41:
        while (v17)
        {
          uint64_t v18 = *v17;
          if (!*v17)
          {
            unsigned __int16 v16 = (_WORD)v17 - (_WORD)v12 + 1;
            goto LABEL_49;
          }

          v17 += v18 + 1;
        }
      }

      else
      {
LABEL_40:
        if (v17 < v3 + 524) {
          goto LABEL_41;
        }
      }

      unsigned __int16 v16 = 257;
    }

LABEL_49:
    *(_DWORD *)buf = 141559299;
    uint64_t v23 = 1752392040LL;
    __int16 v24 = 1040;
    int v25 = (int)v9;
    __int16 v26 = 2101;
    __int16 v27 = v3 + 12;
    __int16 v28 = 2160;
    uint64_t v29 = 1752392040LL;
    __int16 v30 = 1040;
    int v31 = v16;
    __int16 v32 = 2101;
    uint64_t v33 = v3 + 268;
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "GetAuthInfoForName_internal deleting expired key %{sensitive, mask.hash, mdnsresponder:domain_name}.*P %{sensitive , mask.hash, mdnsresponder:domain_name}.*P",  buf,  0x36u);
    goto LABEL_50;
  }

  return GetAuthInfoForName_direct(a1, a2);
}

    a1[27] = 0LL;
  }

      dispatch_once(&_mdns_powerlog_log_s_once, &__block_literal_global_1361);
      goto LABEL_30;
    }

    if (_mdns_powerlog_log_s_once != -1) {
      dispatch_once(&_mdns_powerlog_log_s_once, &__block_literal_global_1361);
    }
    int v36 = _mdns_powerlog_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_powerlog_log_s_log, OS_LOG_TYPE_FAULT))
    {
      LODWORD(v37) = 67109378;
      HIDWORD(v37) = (_DWORD)v8;
      uint64_t v38 = 2082;
      unint64_t v39 = a3;
      int v25 = "No powerlog client info found for %{mdns:powerlog_event_subtype}u event -- client name: %{public}s";
      __int16 v26 = (os_log_s *)v36;
      __int16 v27 = 18;
      goto LABEL_47;
    }
  }

        os_release(v6);
        return;
      }

      *(_BYTE *)(a3 + 250) = 2;
      uint64_t v22 = *(void *)(a3 + 64);
      if (mdns_mach_ticks_per_second_s_once != -1) {
        dispatch_once(&mdns_mach_ticks_per_second_s_once, &__block_literal_global_3412);
      }
      uint64_t v23 = mdns_mach_ticks_per_second_s_ticks_per_second;
      *(void *)(v22 + 88) = mach_continuous_time() + 10 * v23;
      *(_BYTE *)(v22 + 134) = 1;
      if (_mdns_resolver_log_s_once != -1) {
        dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_48);
      }
      __int16 v24 = (os_log_s *)_mdns_resolver_log_s_log;
      if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)buf = 67109120;
        __int16 v30 = 10;
        _os_log_impl( (void *)&_mh_execute_header,  v24,  OS_LOG_TYPE_INFO,  "Got suspicious response, entering suspicious mode for %d seconds",  buf,  8u);
      }
    }

    _mdns_resolver_deregister_querier(*(void *)(a3 + 64), a3);
    _mdns_resolver_register_querier_ex(*(void *)(a3 + 64), (_WORD *)a3, 1);
    goto LABEL_49;
  }

  _mdns_querier_conclude_ex(a3, 5, -6729, 0LL);
}

void SetNextQueryTime(uint64_t a1, uint64_t a2)
{
  int v4 = *(_DWORD *)(a2 + 212);
  if (v4 >= 1 && !*(void *)(a2 + 40))
  {
    uint64_t v5 = 12688LL;
    if (!*(_WORD *)(a2 + 320)) {
      uint64_t v5 = 92LL;
    }
    int v6 = *(_DWORD *)(a2 + 208) + v4;
    if (*(_DWORD *)(a1 + v5) - v6 >= 1) {
      *(_DWORD *)(a1 + v5) = v6;
    }
  }

unsigned __int8 *ConvertDomainLabelToCString_withescape(unsigned __int8 *a1, unsigned __int8 *a2, int a3)
{
  unsigned int v5 = *a1;
  int v3 = a1 + 1;
  uint64_t v4 = v5;
  if (v5 > 0x3FuLL) {
    return 0LL;
  }
  if (v3 < &v3[v4])
  {
    do
    {
      unsigned __int8 v7 = *v3++;
      unsigned __int8 v6 = v7;
      if (a3)
      {
        if (v6 == 46 || v6 == a3)
        {
          *a2++ = a3;
        }

        else if (v6 <= 0x20u)
        {
          *a2 = a3;
          a2[1] = 48;
          a2[2] = (v6 / 0xAu) | 0x30;
          a2 += 3;
          unsigned __int8 v6 = (v6 % 0xAu) | 0x30;
        }
      }

      *a2++ = v6;
      --v4;
    }

    while (v4);
  }

  *a2 = 0;
  return a2;
}

void mDNSDynamicStoreSetConfig( int a1, const char *a2, CFPropertyListRef propertyList, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9)
{
  if (propertyList)
  {
    CFPropertyListRef DeepCopy = CFPropertyListCreateDeepCopy(0LL, propertyList, 0LL);
    if (!DeepCopy)
    {
      LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "mDNSDynamicStoreSetConfig: ERROR valueCopy NULL",  v12,  v13,  v14,  v15,  v16,  a9);
      return;
    }

    CFPropertyListRef v17 = DeepCopy;
    if (a2)
    {
      unsigned int v18 = strlen(a2);
      if (v18 == -1 || (uint64_t v19 = malloc(v18 + 1)) == 0LL)
      {
        __break(1u);
        return;
      }

      uint64_t v20 = v19;
      memcpy(v19, a2, v18);
      v20[v18] = 0;
    }

    else
    {
      uint64_t v20 = 0LL;
    }

    block[0] = _NSConcreteStackBlock;
    block[1] = 0x40000000LL;
    block[2] = __mDNSDynamicStoreSetConfig_block_invoke;
    block[3] = &__block_descriptor_tmp_3492;
    int v22 = a1;
    block[4] = v17;
    block[5] = v20;
    dispatch_async(&_dispatch_main_q, block);
  }

unsigned __int8 *ConvertDomainNameToCString_withescape(unsigned __int8 *a1, unsigned __int8 *a2)
{
  uint64_t v2 = a1;
  int v3 = *a1;
  if (*a1 || (*a2 = 46, ++a2, (int v3 = *a1) != 0))
  {
    unint64_t v4 = (unint64_t)(a1 + 256);
    while ((unint64_t)&v2[v3 + 1] < v4)
    {
      unsigned int v5 = ConvertDomainLabelToCString_withescape(v2, a2, 92);
      unsigned __int8 v6 = v5;
      if (!v5) {
        return v6;
      }
      unsigned __int8 v7 = &v2[*v2];
      *unsigned int v5 = 46;
      a2 = v5 + 1;
      int v8 = v7[1];
      uint64_t v2 = v7 + 1;
      int v3 = v8;
      if (!v8) {
        goto LABEL_7;
      }
    }

    return 0LL;
  }

  else
  {
LABEL_7:
    *a2 = 0;
    return a2 + 1;
  }

void mDNSCoreInitComplete()
{
  dword_100158BC8 = 0;
  if (off_100158BD8)
  {
    mDNS_Lock_((unsigned int *)mDNSStorage, (uint64_t)"mDNSCoreInitComplete", 19148);
    mDNS_VerifyLockState("Drop Lock", 0, dword_100158BE8, ++dword_100158BEC, (uint64_t)"mDNSCoreInitComplete", 19149);
    off_100158BD8(mDNSStorage, 0LL);
    mDNS_VerifyLockState("Reclaim Lock", 0, dword_100158BE8, dword_100158BEC, (uint64_t)"mDNSCoreInitComplete", 19151);
    --dword_100158BEC;
    mDNS_Unlock_((uint64_t)mDNSStorage, (uint64_t)"mDNSCoreInitComplete", 19152);
  }

void mDNS_StatusCallback( __int128 *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a2 <= -65549)
  {
    if (a2 == -65791)
    {
      mDNSPreferencesSetNames(1, (__int128 *)(*(void *)a1 + 172LL), a1 + 643);
      mDNSPreferencesSetNames(2, (__int128 *)(*(void *)a1 + 108LL), a1 + 647);
      udsserver_handle_configchange((uint64_t)a1);
    }

    else if (a2 == -65790 && mDNS_StatusCallback_allocated <= 0xF423F)
    {
      mDNS_StatusCallback_allocated += 32704;
      uint64_t v9 = malloc(0x7FC0uLL);
      if (v9)
      {
        uint64_t v10 = v9;
        mDNS_Lock_((unsigned int *)a1, (uint64_t)"mDNS_GrowCache", 18371);
        int v11 = (char *)(v10 + 28);
        uint64_t v12 = 146LL;
        do
        {
          *((void *)v11 - 28) = v11;
          v11 += 224;
          --v12;
        }

        while (v12);
        v10[4060] = *((void *)a1 + 34);
        *((void *)a1 + 34) = v10;
        *((_DWORD *)a1 + 62) += 146;
        mDNS_Unlock_((uint64_t)a1, (uint64_t)"mDNS_GrowCache", 18373);
      }

      else
      {
        __break(1u);
      }
    }

    return;
  }

  if (a2 != -65548)
  {
    if (a2) {
      return;
    }
    uint64_t v14 = (unsigned __int8 *)(*(void *)a1 + 108LL);
    size_t v13 = *v14;
    if ((_DWORD)v13 == *((unsigned __int8 *)a1 + 10352))
    {
    }

    else if (mDNS_LoggingEnabled != 1)
    {
LABEL_23:
      int v18 = dword_100158BF8 + 1000;
      *(_DWORD *)(mDNSStorage[0] + 492) = v18;
      return;
    }

    LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "Local Hostname changed from %#s.local to %#s.local",  a4,  a5,  a6,  a7,  a8,  (int)v14);
    goto LABEL_23;
  }

  if (mDNS_LoggingEnabled == 1) {
    LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "Local Hostname conflict for %#s.local",  a4,  a5,  a6,  a7,  a8,  (_DWORD)a1 + 10352);
  }
  uint64_t v15 = *(void *)a1;
  int v16 = *(_DWORD *)(*(void *)a1 + 496LL);
  unsigned int v17 = *((_DWORD *)a1 + 16);
  if (v16)
  {
  }

  else
  {
    if (v17 <= 1) {
      unsigned int v17 = 1;
    }
    *(_DWORD *)(v15 + 496) = v17;
  }

void uDNS_SetupDNSConfig()
{
  for (uint64_t i = qword_10015BD50; i; uint64_t i = *(void *)i)
    *(_DWORD *)(i + 16) |= 1u;
  if (!mDNSPlatformSetDNSConfig(1, 0, v48, 0LL, 0LL, 1))
  {
    SetDynDNSHostNameIfChanged(v48);
    for (uint64_t j = qword_10015BD50; j; uint64_t j = *(void *)j)
      *(_DWORD *)(j + 16) &= ~1u;
    mDNS_Unlock_((uint64_t)mDNSStorage, (uint64_t)"uDNS_SetupDNSConfig", 18840);
    uint64_t v14 = (os_log_s *)mDNSLogCategory_State;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buffer[0]) = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_DEFAULT,  "uDNS_SetupDNSConfig: No configuration change",  (uint8_t *)buffer,  2u);
    }

    return;
  }

  int v1 = (_DWORD *)qword_10015BD50;
  if (qword_10015BD50)
  {
    uint64_t v2 = &qword_10015BD50;
    do
    {
      int v3 = v1[4];
      if ((v3 & 1) != 0)
      {
        uint64_t *v2 = *(void *)v1;
        free(v1);
      }

      else
      {
        v1[4] = v3 & 0xFFFFFFFD;
        uint64_t v2 = (uint64_t *)v1;
      }

      int v1 = (_DWORD *)*v2;
    }

    while (*v2);
  }

  Querier_ProcessDNSServiceChanges(0LL);
  SetDynDNSHostNameIfChanged(v48);
  mDNS_Unlock_((uint64_t)mDNSStorage, (uint64_t)"uDNS_SetupDNSConfig", 19122);
  *(_OWORD *)((char *)v45 + 4) = 0uLL;
  memset(v46, 0, sizeof(v46));
  *(_OWORD *)&v47[1] = 0uLL;
  LODWORD(v45[0]) = 4;
  v47[0] = 4;
  unint64_t v4 = (const __CFDictionary *)SCDynamicStoreCopyValue(0LL, (CFStringRef)NetworkChangedKey_IPv4);
  if (!v4)
  {
    int v12 = 0;
    goto LABEL_69;
  }

  unsigned int v5 = v4;
  memset(buffer, 0, sizeof(buffer));
  v45[0] = 4LL;
  Value = (const __CFString *)CFDictionaryGetValue(v4, kSCPropNetIPv4Router);
  if (!Value) {
    goto LABEL_20;
  }
  if (!CFStringGetCString(Value, (char *)buffer, 256LL, 0x8000100u))
  {
    LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "Could not convert router to CString",  v7,  v8,  v9,  v10,  v11,  v43);
LABEL_20:
    int v12 = 0;
    goto LABEL_21;
  }

  __int128 v49 = 0x210uLL;
  inet_aton((const char *)buffer, (in_addr *)&v49 + 1);
  int v12 = DWORD1(v49);
  HIDWORD(v45[0]) = DWORD1(v49);
LABEL_21:
  uint64_t v15 = (const __CFString *)CFDictionaryGetValue(v5, kSCDynamicStorePropNetPrimaryInterface);
  if (!v15) {
    goto LABEL_64;
  }
  int v16 = v15;
  uint64_t IfAddrs = myGetIfAddrs();
  memset(v46, 0, sizeof(v46));
  memset(v47, 0, 20);
  if (!CFStringGetCString(v16, (char *)buffer, 256LL, 0x8000100u))
  {
    LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "Could not convert router to CString",  v18,  v19,  v20,  v21,  v22,  v43);
    goto LABEL_64;
  }

  if (!IfAddrs)
  {
LABEL_64:
    int v26 = 0;
    int v25 = 0;
    goto LABEL_65;
  }

  int v44 = v12;
  int v23 = 0;
  do
  {
    int v24 = v47[1];
    int v25 = LOBYTE(v47[1]);
    int v26 = BYTE1(v47[1]);
    BOOL v28 = BYTE1(v47[1]) == 254 || v23 == 0;
    while (1)
    {
      if (v24)
      {
        if (v25 == 169)
        {
          if (!v28) {
            goto LABEL_62;
          }
        }

        else if (v23)
        {
          goto LABEL_62;
        }
      }

      uint64_t v29 = *(void *)(IfAddrs + 24);
      if (v29) {
        break;
      }
      __int16 v30 = *(const char **)(IfAddrs + 8);
      if (!v30) {
        __int16 v30 = "name not found";
      }
      LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "Skip interface, %s, since ifa_addr is not set.",  v18,  v19,  v20,  v21,  v22,  (int)v30);
      uint64_t IfAddrs = *(void *)IfAddrs;
      if (!IfAddrs) {
        goto LABEL_62;
      }
    }

    int v50 = 0;
    __int128 v49 = 0uLL;
    if (!strcmp((const char *)buffer, *(const char **)(IfAddrs + 8)))
    {
      int v32 = *(unsigned __int8 *)(v29 + 1);
      if (v32 == 30)
      {
        SetupAddr((uint64_t)&v49, v29, v31, v18, v19, v20, v21, v22);
        if ((BYTE4(v49) & 0xE0) == 0x20)
        {
          *(_OWORD *)unsigned int v46 = v49;
          *(_DWORD *)&v46[16] = v50;
LABEL_43:
          int v23 = 1;
        }
      }

      else if (v32 == 2 && (!v24 || v25 == 169 && v26 == 254))
      {
        SetupAddr((uint64_t)v47, v29, v31, v18, v19, v20, v21, v22);
      }
    }

    else
    {
      if (v23) {
        goto LABEL_43;
      }
      BOOL v33 = *(_BYTE *)(v29 + 1) == 30 && v46[4] == 0;
      if (v33 && (SetupAddr((uint64_t)&v49, v29, v31, v18, v19, v20, v21, v22), (BYTE4(v49) & 0xE0) == 0x20))
      {
        int v23 = 0;
        *(_OWORD *)unsigned int v46 = v49;
        *(_DWORD *)&v46[16] = v50;
      }

      else
      {
        int v23 = 0;
      }
    }

    uint64_t IfAddrs = *(void *)IfAddrs;
  }

  while (IfAddrs);
  int v25 = LOBYTE(v47[1]);
  int v26 = BYTE1(v47[1]);
LABEL_62:
  int v12 = v44;
LABEL_65:
  CFRelease(v5);
  if (v25 == 169 && v26 == 254)
  {
    mDNS_SetPrimaryInterfaceInfo(0LL, 0LL, 0LL);
    if (byte_10015C3C8[0]) {
      mDNSPlatformDynDNSHostNameStatusChanged((unsigned __int8 *)byte_10015C3C8, 1, v34, v35, v36, v37, v38, v39);
    }
    return;
  }

uint64_t mDNSPlatformSetDNSConfig(int a1, int a2, _BYTE *a3, void *a4, void *a5, int a6)
{
  if (a3) {
    *a3 = 0;
  }
  if (a4) {
    *a4 = 0LL;
  }
  if (a5) {
    *a5 = 0LL;
  }
  memset(&v151, 0, sizeof(v151));
  uint64_t v11 = (os_log_s *)mDNSLogCategory_State;
  if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 67110144;
    *(_DWORD *)&uint8_t buf[4] = a1;
    *(_WORD *)&buf[8] = 1024;
    *(_DWORD *)&buf[10] = a2;
    *(_WORD *)&buf[14] = 1024;
    *(_DWORD *)&buf[16] = a3 != 0LL;
    *(_WORD *)&buf[20] = 1024;
    *(_DWORD *)&buf[22] = a4 != 0LL;
    *(_WORD *)&buf[26] = 1024;
    *(_DWORD *)&buf[28] = a5 != 0LL;
    _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "mDNSPlatformSetDNSConfig new updates -- setservers: %{mdns:yesno}d, setsearch: %{mdns:yesno}d, fqdn: %{mdns:yesno} d, RegDomains: %{mdns:yesno}d, BrowseDomains: %{mdns:yesno}d",  buf,  0x20u);
  }

  if (a2)
  {
    *(_OWORD *)&v151.A = xmmword_100100870;
    *(void *)&v151.Nl = 0LL;
    v151.unsigned int num = 0;
    uint64_t v154 = 0LL;
    *(_DWORD *)bytes = 528;
    int v153 = DWORD1(xmmword_10015BD58);
    CFMutableArrayRef Mutable = CFDictionaryCreateMutable(0LL, 0LL, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    CFDataRef v13 = CFDataCreate(0LL, bytes, 16LL);
    CFDictionarySetValue(Mutable, @"remote-address", v13);
    CFDictionarySetValue(Mutable, @"ServerBypass", kCFBooleanTrue);
    uint64_t v19 = (const void *)SCNetworkReachabilityCreateWithOptions(kCFAllocatorDefault, Mutable);
    if (Mutable) {
      CFRelease(Mutable);
    }
    if (v13) {
      CFRelease(v13);
    }
    if (v19)
    {
      *(_DWORD *)buf = 0;
      if (SCNetworkReachabilityGetFlags((SCNetworkReachabilityRef)v19, (SCNetworkReachabilityFlags *)buf))
      {
        uint8_t v25 = buf[0];
        CFRelease(v19);
        if ((v25 & 4) != 0) {
          goto LABEL_33;
        }
      }

      else
      {
        LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "ERROR: AddrRequiresPPPConnection - SCNetworkReachabilityGetFlags",  v20,  v21,  v22,  v23,  v24,  v145);
        CFRelease(v19);
      }
    }

    else
    {
      LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "ERROR: RequiresConnection - SCNetworkReachabilityCreateWithOptions",  v14,  v15,  v16,  v17,  v18,  v145);
    }

    uint64_t IfAddrs = myGetIfAddrs();
    if (IfAddrs)
    {
      uint64_t v33 = IfAddrs;
      __int128 v34 = 0uLL;
      do
      {
        v149[0] = 0LL;
        v149[1] = 0LL;
        int v150 = 0;
        v147[0] = 0LL;
        v147[1] = 0LL;
        int v148 = 0;
        __int128 v157 = v34;
        __int128 v158 = v34;
        __int128 v155 = v34;
        __int128 v156 = v34;
        uint64_t v35 = *(void *)(v33 + 24);
        if (*(_BYTE *)(v35 + 1) == 2)
        {
          if (*(void *)(v33 + 32))
          {
            if ((*(_BYTE *)(v33 + 16) & 8) == 0)
            {
              int v36 = SetupAddr((uint64_t)v149, v35, v27, v28, v29, v30, v31, v32);
              __int128 v34 = 0uLL;
              if (!v36 && (BYTE4(v149[0]) != 169 || BYTE5(v149[0]) != 254))
              {
                uint64_t v37 = *(void *)(v33 + 32);
                *(_BYTE *)(v37 + 1) = *(_BYTE *)(*(void *)(v33 + 24) + 1LL);
                SetupAddr((uint64_t)v147, v37, v27, v28, v29, v30, v31, v32);
                int v145 = (HIBYTE(v147[0]) & HIBYTE(v149[0]));
                mDNS_snprintf(&v155);
                UpdateSearchDomainHash(&v151, (const char *)&v155, 0LL);
                __int128 v183 = 0u;
                __int128 v184 = 0u;
                __int128 v181 = 0u;
                __int128 v182 = 0u;
                __int128 v179 = 0u;
                __int128 v180 = 0u;
                __int128 v177 = 0u;
                __int128 v178 = 0u;
                __int128 v175 = 0u;
                __int128 v176 = 0u;
                __int128 v173 = 0u;
                __int128 v174 = 0u;
                __int128 v172 = 0u;
                memset(buf, 0, sizeof(buf));
                __int128 v34 = 0uLL;
              }
            }
          }
        }

        uint64_t v33 = *(void *)v33;
      }

      while (v33);
    }
  }

LABEL_33:
  if (!(a2 | a1)) {
    goto LABEL_101;
  }
  uint64_t v44 = dns_configuration_copy();
  if (!v44)
  {
    if (mDNSPlatformRawTime(0LL, v45, v46, v47, v48, v49, v50, v51) >= 0x2BF21)
    {
      uint64_t v71 = (os_log_s *)mDNSLogCategory_State;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v71,  OS_LOG_TYPE_ERROR,  "mDNSPlatformSetDNSConfig Error: dns_configuration_copy returned NULL",  buf,  2u);
      }
    }

    goto LABEL_101;
  }

  uint64_t v52 = v44;
  uint64_t v53 = (os_log_s *)mDNSLogCategory_State;
  if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT))
  {
    int v60 = *(_DWORD *)v52;
    uint64_t v61 = *(void *)(v52 + 24);
    uint64_t v62 = *(void *)(mDNSStorage[0] + 696);
    *(_DWORD *)buf = 67109888;
    *(_DWORD *)&uint8_t buf[4] = v60;
    *(_WORD *)&buf[8] = 2048;
    *(void *)&buf[10] = v61;
    *(_WORD *)&buf[18] = 2048;
    *(void *)&buf[20] = v62;
    *(_WORD *)&buf[28] = 1024;
    *(_DWORD *)&buf[30] = v61 != v62;
    _os_log_impl( (void *)&_mh_execute_header,  v53,  OS_LOG_TYPE_DEFAULT,  "mDNSPlatformSetDNSConfig -- config->n_resolver: %d, this config generagtion: %llu, last config generation: %llu, c hanged: %{mdns:yesno}d",  buf,  0x22u);
  }

  if (a1 && *(void *)(mDNSStorage[0] + 696) == *(void *)(v52 + 24))
  {
    dns_configuration_free(v52);
    uint64_t v63 = 0LL;
    goto LABEL_102;
  }

  if (*(_DWORD *)v52
    && (uint64_t v64 = **(void **)(v52 + 4), (v65 = *(unsigned __int8 **)v64) != 0LL)
    && *(_DWORD *)(v64 + 8)
    && **(void **)(v64 + 12))
  {
    ActiveDirectoryPrimaryDomain[0] = 0;
    AppendDNSNameString(ActiveDirectoryPrimaryDomain, v65, v54, v55, v56, v57, v58, v59);
    int v66 = ActiveDirectoryPrimaryDomain[0];
    if (ActiveDirectoryPrimaryDomain[0])
    {
      uint64_t v67 = ActiveDirectoryPrimaryDomain;
      int v68 = -1;
      do
      {
        int v69 = &v67[v66];
        int v70 = v69[1];
        uint64_t v67 = v69 + 1;
        int v66 = v70;
        ++v68;
      }

      while (v70);
      goto LABEL_53;
    }
  }

  else
  {
    ActiveDirectoryPrimaryDomain[0] = 0;
  }

  int v68 = -1;
  if (!*(_DWORD *)v52 || !*(_DWORD *)(**(void **)(v52 + 4) + 8LL)) {
    goto LABEL_63;
  }
LABEL_53:
  if (v68 < 1)
  {
    int v73 = ActiveDirectoryPrimaryDomain;
  }

  else
  {
    int v72 = v68 + 1;
    int v73 = ActiveDirectoryPrimaryDomain;
    do
    {
      if (!*v73) {
        break;
      }
      v73 += *v73 + 1;
      --v72;
    }

    while (v72 > 1);
  }

  if (SameDomainNameBytes(v73, "\x05local"))
  {
    SetupAddr( (uint64_t)&ActiveDirectoryPrimaryDomainServer,  **(void **)(**(void **)(v52 + 4) + 12LL),  v74,  v75,  v76,  v77,  v78,  v79);
  }

  else
  {
LABEL_63:
    ActiveDirectoryPrimaryDomain[0] = 0;
    ActiveDirectoryPrimaryDomainServer = 0LL;
    *(void *)algn_1001502D8 = 0LL;
    dword_1001502E0 = 0;
  }

  if (a1)
  {
    uint64_t DNSServiceManager = Querier_GetDNSServiceManager();
    if (DNSServiceManager)
    {
      uint64_t v81 = DNSServiceManager;
      if (_mdns_dns_service_queue_s_once != -1) {
        dispatch_once(&_mdns_dns_service_queue_s_once, &__block_literal_global_237);
      }
      *(void *)buf = _NSConcreteStackBlock;
      *(void *)&buf[8] = 0x40000000LL;
      *(void *)&buf[16] = __mdns_dns_service_manager_apply_dns_config_block_invoke;
      *(void *)&buf[24] = &__block_descriptor_tmp_12_793;
      *(void *)&buf[32] = v81;
      *(void *)&buf[40] = v52;
      dispatch_sync((dispatch_queue_t)_mdns_dns_service_queue_s_queue, buf);
      _Querier_LogDNSServices(v81);
    }

    a1 = 1;
  }

  ConfigResolvers((int *)v52, 0LL, a2, a1, &v151);
  ConfigResolvers((int *)v52, 1LL, a2, a1, &v151);
  ConfigResolvers((int *)v52, 2LL, a2, a1, &v151);
  if (a6)
  {
    *(void *)(mDNSStorage[0] + 696) = *(void *)(v52 + 24);
    uint64_t v82 = (os_log_s *)mDNSLogCategory_State;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v82,  OS_LOG_TYPE_DEFAULT,  "mDNSPlatformSetDNSConfig: acking configuration",  buf,  2u);
    }

    AckConfigd(v52);
  }

  dns_configuration_free(v52);
  if (a2)
  {
    unsigned int num = v151.num;
    unint64_t v84 = (unint64_t)v151.num >> 2;
    int v85 = v151.num & 3;
    if ((v151.num & 3) != 0)
    {
      unsigned int v86 = v151.data[v84];
      int v87 = &MD5_Final_end;
      if (v85 == 3) {
        goto LABEL_82;
      }
      if (v85 == 2)
      {
LABEL_81:
        int v89 = *v87++;
        v86 |= v89 << 16;
LABEL_82:
        v151.data[v84] = v86 | (*v87 << 24);
        if (num <= 0x37)
        {
          if (num > 0x33) {
            goto LABEL_89;
          }
          int v90 = v84 + 1;
        }

        else
        {
          if (num <= 0x3B) {
            v151.data[15] = 0;
          }
          md5_block_host_order(&v151, (int *)v151.data);
          int v90 = 0;
        }

        bzero(&v151.data[v90], 4LL * (13 - v90) + 4);
LABEL_89:
        *(void *)&v151.data[14] = *(void *)&v151.Nl;
        md5_block_host_order(&v151, (int *)v151.data);
        *(void *)&uint8_t buf[4] = *(void *)&v151.B;
        *(_DWORD *)buf = v151.A;
        *(_DWORD *)&buf[12] = v151.D;
        v151.unsigned int num = 0;
        if (*(void *)buf != (void)xmmword_10015C4DC || *(void *)&buf[8] != *((void *)&xmmword_10015C4DC + 1))
        {
          *(_OWORD *)((char *)&qword_100158C80 + &unk_10000385C) = *(_OWORD *)buf;
          uint64_t v97 = qword_100158C80;
          if (qword_100158C80)
          {
            while (!*(_BYTE *)(v97 + 621))
            {
              uint64_t v97 = *(void *)(v97 + 8);
              if (!v97) {
                goto LABEL_96;
              }
            }

            if (mDNS_LoggingEnabled == 1)
            {
              unsigned __int16 v98 = (os_log_s *)mDNSLogCategory_Default;
              int v99 = v97 + 356;
              DNSTypeName(*(unsigned __int16 *)(v97 + 322));
              LogMsgWithLevel( v98,  OS_LOG_TYPE_DEFAULT,  "RetrySearchDomainQuestions: Question with AppendSearchDomain found %##s (%s)",  v100,  v101,  v102,  v103,  v104,  v99);
            }

            mDNSCoreRestartAddressQueries(1, (void (*)(uint64_t *))FlushAddressCacheRecords, 0LL, 0LL);
          }

          else
          {
LABEL_96:
            if (mDNS_LoggingEnabled == 1) {
              LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "RetrySearchDomainQuestions: Questions with AppendSearchDomain not found",  v91,  v92,  v93,  v94,  v95,  v145);
            }
          }
        }

        goto LABEL_101;
      }
    }

    else
    {
      int v87 = &byte_1000FFD1D;
      unsigned int v86 = 128;
    }

    int v88 = *v87++;
    v86 |= v88 << 8;
    goto LABEL_81;
  }

          ++v35;
          ++v29;
          if (!--v34) {
            goto LABEL_34;
          }
        }

        uint64_t v19 = v40;
LABEL_32:
        uint64_t v33 = cf;
        goto LABEL_33;
      }

      LOBYTE(v81) = 0;
LABEL_40:
      CFRelease(v24);
    }

    else
    {
LABEL_38:
      LOBYTE(v81) = 0;
    }
  }

  else
  {
    LOBYTE(v81) = 0;
  }

  if (Count >= 1)
  {
    unint64_t v84 = a3;
    uint64_t v47 = 0LL;
    while (1)
    {
      uint64_t v48 = (const __CFString *)CFArrayGetValueAtIndex(a2, v47);
      if (CFStringHasPrefix(v48, (CFStringRef)NetworkChangedKey_StateInterfacePrefix)
        && (CFStringHasSuffix(v48, kSCEntNetIPv6) || CFStringHasSuffix(v48, kSCEntNetIPv4)))
      {
        ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings(0LL, v48, @"/");
        if (!ArrayBySeparatingStrings) {
          goto LABEL_53;
        }
        uint64_t v50 = ArrayBySeparatingStrings;
        if (CFArrayGetCount(ArrayBySeparatingStrings) == 5)
        {
          uint64_t v100 = 0u;
          uint64_t v101 = 0u;
          unsigned __int16 v98 = 0u;
          int v99 = 0u;
          unsigned int v96 = 0u;
          uint64_t v97 = 0u;
          uint64_t v94 = 0u;
          uint64_t v95 = 0u;
          uint64_t v92 = 0u;
          uint64_t v93 = 0u;
          int v90 = 0u;
          uint64_t v91 = 0u;
          int v88 = 0u;
          int v89 = 0u;
          memset(buffer, 0, sizeof(buffer));
          uint64_t v51 = (const __CFString *)CFArrayGetValueAtIndex(v50, 3LL);
          if (CFStringGetCString(v51, buffer, 256LL, 0x8000100u))
          {
            if (strstr(buffer, "p2p") || (getExtendedFlags((uint64_t)buffer) & 0x20100000) != 0)
            {
              CFRelease(v50);
              uint64_t v52 = 0;
LABEL_54:
              if ((mDNS_LoggingEnabled & 1) != 0)
              {
                for (int i = 0LL; i != Count; ++i)
                {
                  uint64_t v100 = 0u;
                  uint64_t v101 = 0u;
                  unsigned __int16 v98 = 0u;
                  int v99 = 0u;
                  unsigned int v96 = 0u;
                  uint64_t v97 = 0u;
                  uint64_t v94 = 0u;
                  uint64_t v95 = 0u;
                  uint64_t v92 = 0u;
                  uint64_t v93 = 0u;
                  int v90 = 0u;
                  uint64_t v91 = 0u;
                  int v88 = 0u;
                  int v89 = 0u;
                  memset(buffer, 0, sizeof(buffer));
                  uint64_t v54 = (const __CFString *)CFArrayGetValueAtIndex(a2, i);
                  if (!CFStringGetCString(v54, buffer, 256LL, 0x8000100u)) {
                    buffer[0] = 0;
                  }
                  uint64_t v55 = (os_log_s *)mDNSLogCategory_State;
                  if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT))
                  {
                    *(_DWORD *)buf = 136446210;
                    unsigned int v86 = buffer;
                    _os_log_impl( (void *)&_mh_execute_header,  v55,  OS_LOG_TYPE_DEFAULT,  "*** Network Configuration Change *** SC key: %{public}s",  buf,  0xCu);
                  }
                }

                a3 = v84;
LABEL_64:
                uint64_t v56 = (os_log_s *)mDNSLogCategory_State;
                if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT))
                {
                  uint64_t v57 = v80 != 0;
                  if (v79) {
                    v57 |= 2u;
                  }
                  if (v78) {
                    v57 |= 4u;
                  }
                  if (v14) {
                    v57 |= 8u;
                  }
                  if ((_BYTE)v81) {
                    v57 |= 0x10u;
                  }
                  *(_DWORD *)buffer = 134218496;
                  *(void *)&buffer[4] = Count;
                  if (!v52) {
                    v57 |= 0x20u;
                  }
                  *(_WORD *)&buffer[12] = 1024;
                  *(_DWORD *)&buffer[14] = 25;
                  *(_WORD *)&buffer[18] = 1026;
                  *(_DWORD *)&buffer[20] = v57;
                  _os_log_impl( (void *)&_mh_execute_header,  v56,  OS_LOG_TYPE_DEFAULT,  "*** Network Configuration Change *** -- change count: %ld, delay: %d, flags: %{public, mdnsresponder :net_change_flags}d",  (uint8_t *)buffer,  0x18u);
                }
              }

              goto LABEL_76;
            }
          }
        }

        CFRelease(v50);
      }

      if (Count == ++v47)
      {
LABEL_53:
        uint64_t v52 = 1;
        goto LABEL_54;
      }
    }
  }

  if ((mDNS_LoggingEnabled & 1) != 0)
  {
    uint64_t v52 = 1;
    goto LABEL_64;
  }

        *(_BYTE *)(a7 + 8) = -16;
        *(_DWORD *)(a7 + memset(v45, 0, 20) = 0;
        *(_DWORD *)(a7 + 28) = 0;
        return v43;
      }
    }
  }

  return 0LL;
}

  PrintHelper((uint64_t)"xD2DServiceCallback", (uint64_t)a5, (unsigned __int16)a6, (uint64_t)a7, (unsigned __int16)a8);
  switch(a1)
  {
    case 0:
      if (a2)
      {
        uint64_t v40 = mDNSLogCategory_D2D;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_D2D == mDNSLogCategory_State)
        {
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_D2D, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 67109120;
            *(_DWORD *)&uint8_t buf[4] = a2;
            uint64_t v41 = "xD2DAddToCache: Unexpected result - result: %d";
            goto LABEL_149;
          }
        }

        else
        {
          uint64_t v40 = mDNSLogCategory_D2D_redacted;
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_D2D_redacted, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 67109120;
            *(_DWORD *)&uint8_t buf[4] = a2;
            uint64_t v41 = "xD2DAddToCache: Unexpected result - result: %d";
            goto LABEL_149;
          }
        }

        goto LABEL_153;
      }

      if (!a8 || !a6 || !a5 || !a7)
      {
        uint64_t v71 = mDNSLogCategory_D2D;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_D2D == mDNSLogCategory_State)
        {
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_D2D, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)buf = 0;
            uint64_t v41 = "xD2DAddToCache: NULL Byte * passed in or length == 0";
            goto LABEL_193;
          }
        }

        else
        {
          uint64_t v71 = mDNSLogCategory_D2D_redacted;
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_D2D_redacted, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)buf = 0;
            uint64_t v41 = "xD2DAddToCache: NULL Byte * passed in or length == 0";
            goto LABEL_193;
          }
        }

        goto LABEL_153;
      }

      if ((a4 & 0xFFFFFFFE) != 2)
      {
        *(void *)uint64_t v125 = 0LL;
        uint64_t v76 = xD2DParse(a5, (unsigned __int16)a6, a7, (unsigned __int16)a8, (char **)v125);
        if (v76)
        {
          uint64_t v77 = v76;
          uint64_t v78 = (os_log_s *)mDNSLogCategory_D2D;
          if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_D2D == mDNSLogCategory_State)
          {
            if (os_log_type_enabled((os_log_t)mDNSLogCategory_D2D, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 67109120;
              *(_DWORD *)&uint8_t buf[4] = v77;
              goto LABEL_239;
            }
          }

          else
          {
            uint64_t v78 = (os_log_s *)mDNSLogCategory_D2D_redacted;
            if (os_log_type_enabled((os_log_t)mDNSLogCategory_D2D_redacted, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 67109120;
              *(_DWORD *)&uint8_t buf[4] = v77;
LABEL_239:
              _os_log_impl( (void *)&_mh_execute_header,  v78,  OS_LOG_TYPE_ERROR,  "xD2DAddToCache: xD2DParse failed - error: %d",  buf,  8u);
            }
          }

          PrintHelper((uint64_t)"xD2DAddToCache", (uint64_t)a5, (unsigned __int16)a6, (uint64_t)a7, (unsigned __int16)a8);
          unsigned int v86 = *(void *)v125;
          goto LABEL_241;
        }

        unsigned int v86 = *(void *)v125;
        int v87 = mDNS_Register((unsigned int *)mDNSStorage, *(void *)v125 + 24LL);
        int v88 = gSensitiveLoggingEnabled;
        int v89 = (os_log_s *)mDNSLogCategory_D2D;
        if (mDNSLogCategory_D2D == mDNSLogCategory_State) {
          int v88 = 0;
        }
        if (v87)
        {
          int v90 = v87;
          if ((v88 & 1) != 0)
          {
            uint64_t v91 = mDNSLogCategory_D2D_redacted;
            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D_redacted, OS_LOG_TYPE_ERROR)) {
              goto LABEL_241;
            }
            uint64_t v92 = *(void *)(v86 + 64);
            if (v92)
            {
              uint64_t v93 = *(_BYTE **)(v86 + 64);
              if (v92 == -256)
              {
                while (1)
                {
LABEL_224:
                  if (!v93) {
                    goto LABEL_286;
                  }
                  uint64_t v94 = *v93;
                  if (!*v93) {
                    break;
                  }
                  v93 += v94 + 1;
                  if (v92 != -256) {
                    goto LABEL_223;
                  }
                }

                uint64_t v107 = (unsigned __int16)((_WORD)v93 - v92 + 1);
              }

              else
              {
LABEL_223:
LABEL_286:
                uint64_t v107 = 257;
              }
            }

            else
            {
              uint64_t v107 = 0;
            }

            CFStringRef v110 = *(unsigned __int16 *)(v86 + 36);
            GetRRDisplayString_rdb( (unsigned __int8 *)(v86 + 32),  (unsigned __int16 *)(*(void *)(v86 + 72) + 4LL),  word_100164338);
            *(_DWORD *)buf = 67110659;
            *(_DWORD *)&uint8_t buf[4] = v90;
            *(_WORD *)&buf[8] = 2160;
            *(void *)&buf[10] = 1752392040LL;
            uint64_t v127 = 1040;
            *(_DWORD *)uint64_t v128 = v107;
            *(_WORD *)&v128[4] = 2101;
            *(void *)&v128[6] = v92;
            *(_WORD *)&v128[14] = 1024;
            *(_DWORD *)&v128[16] = v110;
            *(_WORD *)&v128[20] = 2160;
            *(void *)&v128[22] = 1752392040LL;
            *(_WORD *)&v128[30] = 2085;
            *(void *)&v128[32] = word_100164338;
            CFStringRef v111 = (os_log_s *)v91;
          }

          else
          {
            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D, OS_LOG_TYPE_ERROR))
            {
LABEL_241:
              if (!v86) {
                goto LABEL_153;
              }
LABEL_301:
              uint64_t v95 = (void *)v86;
              goto LABEL_305;
            }

            uint64_t v101 = *(void *)(v86 + 64);
            if (v101)
            {
              uint64_t v102 = *(_BYTE **)(v86 + 64);
              if (v101 == -256)
              {
                while (1)
                {
LABEL_269:
                  if (!v102) {
                    goto LABEL_287;
                  }
                  uint64_t v103 = *v102;
                  if (!*v102) {
                    break;
                  }
                  v102 += v103 + 1;
                  if (v101 != -256) {
                    goto LABEL_268;
                  }
                }

                int v108 = (unsigned __int16)((_WORD)v102 - v101 + 1);
              }

              else
              {
LABEL_268:
LABEL_287:
                int v108 = 257;
              }
            }

            else
            {
              int v108 = 0;
            }

            uint64_t v112 = *(unsigned __int16 *)(v86 + 36);
            GetRRDisplayString_rdb( (unsigned __int8 *)(v86 + 32),  (unsigned __int16 *)(*(void *)(v86 + 72) + 4LL),  word_100164338);
            *(_DWORD *)buf = 67110659;
            *(_DWORD *)&uint8_t buf[4] = v90;
            *(_WORD *)&buf[8] = 2160;
            *(void *)&buf[10] = 1752392040LL;
            uint64_t v127 = 1040;
            *(_DWORD *)uint64_t v128 = v108;
            *(_WORD *)&v128[4] = 2101;
            *(void *)&v128[6] = v101;
            *(_WORD *)&v128[14] = 1024;
            *(_DWORD *)&v128[16] = v112;
            *(_WORD *)&v128[20] = 2160;
            *(void *)&v128[22] = 1752392040LL;
            *(_WORD *)&v128[30] = 2085;
            *(void *)&v128[32] = word_100164338;
            CFStringRef v111 = v89;
          }

          _os_log_impl( (void *)&_mh_execute_header,  v111,  OS_LOG_TYPE_ERROR,  "xD2DAddToCache: mDNS_Register failed - error: %d, name: %{sensitive, mask.hash, mdnsresponder:domain_name}.* P, type: %{mdns:rrtype}d, auth record: %{sensitive, mask.hash}s",  buf,  0x3Cu);
          goto LABEL_301;
        }

        if ((v88 & 1) != 0)
        {
          int v89 = (os_log_s *)mDNSLogCategory_D2D_redacted;
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_D2D_redacted, OS_LOG_TYPE_DEFAULT))
          {
            unsigned __int16 v98 = *(void *)(v86 + 64);
            if (v98)
            {
              int v99 = *(_BYTE **)(v86 + 64);
              if (v98 == -256)
              {
LABEL_260:
                while (v99)
                {
                  uint64_t v100 = *v99;
                  if (!*v99)
                  {
                    CFMutableArrayRef v109 = (unsigned __int16)((_WORD)v99 - v98 + 1);
                    goto LABEL_308;
                  }

                  v99 += v100 + 1;
                  if (v98 != -256) {
                    goto LABEL_259;
                  }
                }
              }

              else
              {
LABEL_259:
              }

              CFMutableArrayRef v109 = 257;
            }

            else
            {
              CFMutableArrayRef v109 = 0;
            }

      uint64_t v15 = DNSTypeName(*(unsigned __int16 *)(a2 + 12));
      v16[0] = 67110147;
      v16[1] = v3;
      uint64_t v17 = 2160;
      uint64_t v18 = 1752392040LL;
      uint64_t v19 = 1040;
      uint64_t v20 = v14;
      uint64_t v21 = 2101;
      uint64_t v22 = v8;
      uint64_t v23 = 2082;
      uint64_t v24 = v15;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "Excessive name conflicts (%u) for %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%{public}s); rate limiting in effect",
        (uint8_t *)v16,
        0x2Cu);
    }
  }

        *(_DWORD *)buf = 68158466;
        uint64_t v27 = v23;
        uint64_t v28 = 2098;
        uint64_t v29 = v17;
        uint64_t v30 = 1024;
        uint64_t v31 = v18;
        uint64_t v32 = 1024;
        uint64_t v33 = v19;
        _os_log_debug_impl( (void *)&_mh_execute_header,  v21,  OS_LOG_TYPE_DEBUG,  "unicast assist auth_rmv %{public, mdnsresponder:domain_name}.*P qhash %x ifid %2.2d",  buf,  0x1Eu);
      }

      [(id)s_presense removeQhash:v18 forInterface:v19];
    }

    uint64_t v22 = mDNS_Deregister_internal((uint64_t)a1, v14, a3);
    mDNS_Unlock_((uint64_t)a1, (uint64_t)"mDNS_DeregisterService_drt", 17734);
    return v22;
  }

  return result;
}

              if (++v15 == v14)
              {
                os_retain(v11);
                os_retain((void *)v10);
                if (_mdns_dns_service_queue_s_once != -1) {
                  dispatch_once(&_mdns_dns_service_queue_s_once, &__block_literal_global_237);
                }
                block = _NSConcreteStackBlock;
                uint64_t v113 = 0x40000000LL;
                uint64_t v114 = ___mdns_dns_service_manager_process_ddr_response_block_invoke_2;
                uint64_t v115 = &__block_descriptor_tmp_210;
                uint64_t v116 = (_BYTE *)v10;
                uint64_t v117 = v11;
                uint64_t v118 = group;
                dispatch_group_notify(group, (dispatch_queue_t)_mdns_dns_service_queue_s_queue, &block);
                goto LABEL_171;
              }
            }
          }
        }

        goto LABEL_172;
      }
    }

      uint64_t v11 = v5;
    }

    else
    {
      uint64_t v11 = 0;
    }

      int v1 = (const char *)&DNSTypeName_buffer;
      mDNS_snprintf(&DNSTypeName_buffer);
      return v1;
    }

    switch(a1)
    {
      case '!':
        int v1 = "SRV";
        break;
      case ')':
        int v1 = "OPT";
        break;
      case '+':
        int v1 = "DS";
        break;
      case '.':
        int v1 = "RRSIG";
        break;
      case '/':
        int v1 = "NSEC";
        break;
      case '0':
        int v1 = "DNSKEY";
        break;
      case '2':
        int v1 = "NSEC3";
        break;
      case '3':
        int v1 = "NSEC3PARAM";
        break;
      default:
        goto LABEL_33;
    }
  }

  return v1;
}

  mDNS_StopQuery((unsigned int *)mDNSStorage, v2);
  mDNS_StopQuery((unsigned int *)mDNSStorage, v2 + 656);
  if (mDNS_McastLoggingEnabled) {
    LogMcastQuestion(v2 + 656, a1, 0);
  }
  if (*(_BYTE *)(v2 + 1336))
  {
    uint64_t v30 = *(void *)(v2 + 792);
    uint64_t v31 = v2 + 1012;
    uint64_t v32 = *(_DWORD *)(a1 + 232);
    uint64_t v61 = *(_DWORD *)(a1 + 172);
    uint64_t v80 = 0u;
    uint64_t v81 = 0u;
    uint64_t v78 = 0u;
    uint64_t v79 = 0u;
    uint64_t v76 = 0u;
    uint64_t v77 = 0u;
    uint64_t v74 = 0u;
    uint64_t v75 = 0u;
    int v72 = 0u;
    int v73 = 0u;
    int v70 = 0u;
    uint64_t v71 = 0u;
    *(_OWORD *)&__tp[32] = 0u;
    int v69 = 0u;
    if (*(_BYTE *)(v2 + 1012)) {
      uint64_t v33 = (_BYTE *)(v2 + 1012 + *(unsigned __int8 *)(v2 + 1012) + 1);
    }
    else {
      uint64_t v33 = (_BYTE *)(v2 + 1012);
    }
    memset(__tp, 0, 32);
    DomainnameToLower(v33, (uint64_t)__tp);
    __int128 v34 = (os_log_s *)mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_62;
      }
      uint64_t v41 = (_BYTE *)(v2 + 1012);
      if (v2 == -1268)
      {
LABEL_52:
        while (v41)
        {
          uint64_t v42 = *v41;
          if (!*v41)
          {
            uint64_t v43 = (unsigned __int16)((_WORD)v41 - v31 + 1);
            goto LABEL_61;
          }

          v41 += v42 + 1;
          if (v2 != -1268) {
            goto LABEL_51;
          }
        }
      }

      else
      {
LABEL_51:
      }

      uint64_t v43 = 257;
    }

    else
    {
      __int128 v34 = (os_log_s *)mDNSLogCategory_Default_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_62;
      }
      uint64_t v39 = (_BYTE *)(v2 + 1012);
      if (v2 == -1268)
      {
LABEL_44:
        while (v39)
        {
          uint64_t v40 = *v39;
          if (!*v39)
          {
            uint64_t v43 = (unsigned __int16)((_WORD)v39 - v31 + 1);
            goto LABEL_61;
          }

          v39 += v40 + 1;
          if (v2 != -1268) {
            goto LABEL_43;
          }
        }
      }

      else
      {
LABEL_43:
      }

      uint64_t v43 = 257;
    }

LABEL_101:
  uint64_t v63 = 1LL;
LABEL_102:
  v149[0] = a4;
  v147[0] = a5;
  uint64_t v105 = (const __CFDictionary *)SCDynamicStoreCopyValue(0LL, @"Setup:/Network/DynamicDNS");
  if (v105)
  {
    uint64_t v106 = v105;
    bzero(buf, 0x3F1uLL);
    __int128 v169 = 0u;
    __int128 v170 = 0u;
    __int128 v167 = 0u;
    __int128 v168 = 0u;
    __int128 v165 = 0u;
    __int128 v166 = 0u;
    __int128 v163 = 0u;
    __int128 v164 = 0u;
    __int128 v161 = 0u;
    __int128 v162 = 0u;
    __int128 v159 = 0u;
    __int128 v160 = 0u;
    __int128 v157 = 0u;
    __int128 v158 = 0u;
    __int128 v155 = 0u;
    __int128 v156 = 0u;
    if (a3)
    {
      Value = (const __CFArray *)CFDictionaryGetValue(v106, @"HostNames");
      if (Value)
      {
        int v108 = Value;
        if (CFArrayGetCount(Value) >= 1)
        {
          ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v108, 0LL);
          if (ValueAtIndex)
          {
            CFStringRef v110 = ValueAtIndex;
            if (DictionaryIsEnabled(ValueAtIndex))
            {
              CFStringRef v111 = (const __CFString *)CFDictionaryGetValue(v110, @"Domain");
              if (v111)
              {
                if (!CFStringGetCString(v111, (char *)buf, 1009LL, 0x8000100u)
                  || (*a3 = 0, !AppendDNSNameString(a3, buf, v112, v113, v114, v115, v116, v117))
                  || !*a3)
                {
                  if (buf[0]) {
                    uint64_t v118 = buf;
                  }
                  else {
                    uint64_t v118 = (uint8_t *)"(unknown)";
                  }
                  LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "GetUserSpecifiedDDNSConfig SCDynamicStore bad DDNS host name: %s",  v113,  v114,  v115,  v116,  v117,  (int)v118);
                }
              }
            }
          }
        }
      }
    }

    if (a4)
    {
      uint64_t v119 = (const __CFArray *)CFDictionaryGetValue(v106, @"RegistrationDomains");
      if (v119)
      {
        unsigned int v120 = v119;
        if (CFArrayGetCount(v119) >= 1)
        {
          uint64_t v121 = (const __CFDictionary *)CFArrayGetValueAtIndex(v120, 0LL);
          if (v121)
          {
            int v122 = v121;
            if (DictionaryIsEnabled(v121))
            {
              BOOL v123 = (const __CFString *)CFDictionaryGetValue(v122, @"Domain");
              if (v123)
              {
                if (CFStringGetCString(v123, (char *)buf, 1009LL, 0x8000100u)
                  && (LOBYTE(v155) = 0, AppendDNSNameString(&v155, buf, v124, v125, v126, v127, v128, v129))
                  && (_BYTE)v155)
                {
                  AppendDNameListElem(v149, &v155);
                }

                else
                {
                  if (buf[0]) {
                    int v130 = buf;
                  }
                  else {
                    int v130 = (uint8_t *)"(unknown)";
                  }
                  LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "GetUserSpecifiedDDNSConfig SCDynamicStore bad DDNS registration domain: %s",  v125,  v126,  v127,  v128,  v129,  (int)v130);
                }
              }
            }
          }
        }
      }
    }

    if (a5)
    {
      unsigned int v131 = (const __CFArray *)CFDictionaryGetValue(v106, @"BrowseDomains");
      if (v131)
      {
        int v132 = v131;
        for (int i = 0; CFArrayGetCount(v132) > i; ++i)
        {
          uint64_t v134 = (const __CFDictionary *)CFArrayGetValueAtIndex(v132, i);
          if (v134)
          {
            v135 = v134;
            if (DictionaryIsEnabled(v134))
            {
              uint64_t v136 = (const __CFString *)CFDictionaryGetValue(v135, @"Domain");
              if (v136)
              {
                if (CFStringGetCString(v136, (char *)buf, 1009LL, 0x8000100u)
                  && (LOBYTE(v155) = 0, AppendDNSNameString(&v155, buf, v137, v138, v139, v140, v141, v142))
                  && (_BYTE)v155)
                {
                  AppendDNameListElem(v147, &v155);
                }

                else
                {
                  if (buf[0]) {
                    unsigned int v143 = buf;
                  }
                  else {
                    unsigned int v143 = (uint8_t *)"(unknown)";
                  }
                  LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "GetUserSpecifiedDDNSConfig SCDynamicStore bad DDNS browsing domain: %s",  v138,  v139,  v140,  v141,  v142,  (int)v143);
                }
              }
            }
          }
        }
      }
    }

    CFRelease(v106);
  }

  return v63;
}

      if (mDNS_LoggingEnabled) {
        int v73 = 50;
      }
      else {
        int v73 = 250;
      }
      WatchDogReportingThreshold = v73;
      UpdateDebugState(v65, v66, v67, v68, v69, v70, v71, v72, v82);
      uint64_t v38 = mDNSLogCategory_Default;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_145;
        }
        LOWORD(v82) = 0;
        uint64_t v27 = "USR1 Logging Enabled";
      }

      else
      {
        uint64_t v38 = mDNSLogCategory_Default_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_145;
        }
        LOWORD(v82) = 0;
        uint64_t v27 = "USR1 Logging Enabled";
      }

        *uint64_t v48 = 0;
LABEL_102:
        *(_WORD *)(v47 + 322) = 6;
        *(_BYTE *)(v47 + 615) = 1;
        *(_BYTE *)(v47 + 617) = 0;
        *(_BYTE *)(v47 + 621) = 0;
      }
    }

    *(_BYTE *)(v47 + 618) = 1;
    uint64_t v64 = v47 + 612;
    *(_BYTE *)(v47 + 612) = 0;
    uint64_t v65 = (os_log_s *)mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_127;
      }
      uint64_t v67 = *(_DWORD *)(a1 + 688);
      for (uint64_t j = (_BYTE *)(v47 + 356); ; j += v69 + 1)
      {
        if ((unint64_t)j >= v64 || !j || (int v69 = *j, v69 > 0x3F))
        {
          int v73 = 257;
          goto LABEL_126;
        }

        if (!*j) {
          break;
        }
      }

      int v73 = (unsigned __int16)((_WORD)j - (_WORD)v48 + 1);
    }

    else
    {
      uint64_t v65 = (os_log_s *)mDNSLogCategory_Default_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
      {
LABEL_127:
        RecordOpStartQuestion = QueryRecordOpStartQuestion(a1, v47);
        if (!(_DWORD)RecordOpStartQuestion) {
          return RecordOpStartQuestion;
        }
        goto LABEL_67;
      }

      uint64_t v67 = *(_DWORD *)(a1 + 688);
      for (k = (_BYTE *)(v47 + 356); ; k += v72 + 1)
      {
        if ((unint64_t)k >= v64 || !k || (int v72 = *k, v72 > 0x3F))
        {
          int v73 = 257;
          goto LABEL_126;
        }

        if (!*k) {
          break;
        }
      }

      int v73 = (unsigned __int16)((_WORD)k - (_WORD)v48 + 1);
    }

                  CFRelease(v26);
                  unint64_t v4 = v61;
                }

                goto LABEL_102;
              }

void mDNS_SetPrimaryInterfaceInfo(uint64_t a1, __int128 *a2, uint64_t a3)
{
  if (a1 && *(_DWORD *)a1 != 4)
  {
    LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "mDNS_SetPrimaryInterfaceInfo v4 address - incorrect type.  Discarding. %#a",  v6,  v7,  v8,  v9,  v10,  a1);
  }

  else if (a2 && *(_DWORD *)a2 != 6)
  {
    LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "mDNS_SetPrimaryInterfaceInfo v6 address - incorrect type.  Discarding. %#a",  v6,  v7,  v8,  v9,  v10,  (int)a2);
  }

  else if (a3 && *(_DWORD *)a3 != 4)
  {
    LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "mDNS_SetPrimaryInterfaceInfo passed non-v4 router.  Discarding. %#a",  v6,  v7,  v8,  v9,  v10,  a3);
  }

  else
  {
    uint64_t v11 = &zerov4Addr;
    if (a1) {
      int v12 = (int *)(a1 + 4);
    }
    else {
      int v12 = &zerov4Addr;
    }
    CFDataRef v13 = (_DWORD *)a2 + 1;
    if (!a2) {
      CFDataRef v13 = &zerov6Addr;
    }
    if ((_DWORD)qword_10015BD84 != *v13) {
      goto LABEL_23;
    }
    uint64_t v14 = (_DWORD *)a2 + 2;
    if (!a2) {
      uint64_t v14 = &unk_1000FFCD8;
    }
    if (HIDWORD(qword_10015BD84) != *v14) {
      goto LABEL_23;
    }
    uint64_t v15 = (_DWORD *)a2 + 3;
    if (!a2) {
      uint64_t v15 = &unk_1000FFCDC;
    }
    if (dword_10015BD8C == *v15)
    {
      uint64_t v16 = &unk_1000FFCE0;
      if (a2) {
        uint64_t v16 = a2 + 1;
      }
      BOOL v17 = dword_10015BD90 == *v16;
    }

    else
    {
LABEL_23:
      BOOL v17 = 0;
    }

    int v18 = DWORD2(xmmword_10015BD68);
    int v19 = *v12;
    if (a3) {
      uint64_t v11 = (int *)(a3 + 4);
    }
    int v20 = *v11;
    if (a1)
    {
      __int128 v21 = *(_OWORD *)a1;
      unk_10015BD7C = *(_DWORD *)(a1 + 16);
      *(__int128 *)((char *)&xmmword_10015BD68 + 4) = v21;
    }

    else
    {
      DWORD2(xmmword_10015BD68) = 0;
    }

    if (a2)
    {
      __int128 v22 = *a2;
      dword_10015BD90 = *((_DWORD *)a2 + 4);
      unk_10015BD80 = v22;
    }

    else
    {
      qword_10015BD84 = 0LL;
      *(void *)&dword_10015BD8C = 0LL;
    }

    int v23 = DWORD1(xmmword_10015BD58);
    if (a3)
    {
      __int128 v24 = *(_OWORD *)a3;
      LODWORD(xmmword_10015BD68) = *(_DWORD *)(a3 + 16);
      xmmword_10015BD58 = v24;
    }

    else
    {
      DWORD1(xmmword_10015BD58) = 0;
    }

    BOOL v25 = v18 == v19 && v23 == v20;
    int v26 = !v25;
    int v27 = !v25 || !v17;
    if (v27 == 1)
    {
      int v56 = v26;
      if (mDNS_LoggingEnabled == 1)
      {
        uint64_t v28 = "v4Changed ";
        if (v18 == v19) {
          uint64_t v28 = "";
        }
        LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "mDNS_SetPrimaryInterfaceInfo: %s%s%s%#a %#a %#a",  v6,  v7,  v8,  v9,  v10,  (int)v28);
      }

      int v55 = v18;
      for (uint64_t i = xmmword_10015C4C8; i; uint64_t i = *(void *)i)
      {
        if (mDNS_LoggingEnabled == 1) {
          LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "mDNS_SetPrimaryInterfaceInfo updating host name registrations for %##s",  v6,  v7,  v8,  v9,  v10,  i + 208);
        }
        if (*(unsigned __int8 *)(i + 472) >= 2u)
        {
          uint64_t v30 = *(void *)(i + 512);
          int v32 = *(_DWORD *)(v30 + 4);
          uint64_t v31 = (unsigned __int16 *)(v30 + 4);
          if (v32 != DWORD2(xmmword_10015BD68))
          {
            if (mDNS_LoggingEnabled == 1)
            {
              uint64_t v33 = (os_log_s *)mDNSLogCategory_Default;
              GetRRDisplayString_rdb((unsigned __int8 *)(i + 472), v31, word_100164338);
              LogMsgWithLevel( v33,  OS_LOG_TYPE_DEFAULT,  "mDNS_SetPrimaryInterfaceInfo deregistering %s",  v34,  v35,  v36,  v37,  v38,  (int)word_100164338);
            }

            mDNS_Deregister_internal((uint64_t)mDNSStorage, i + 464, 0);
          }
        }

        if (*(unsigned __int8 *)(i + 1648) >= 2u)
        {
          uint64_t v39 = *(void *)(i + 1688);
          if (*(void *)(v39 + 4) != qword_10015BD84
            || *(_DWORD *)(v39 + 12) != dword_10015BD8C
            || *(_DWORD *)(v39 + 16) != dword_10015BD90)
          {
            if (mDNS_LoggingEnabled == 1)
            {
              uint64_t v40 = (os_log_s *)mDNSLogCategory_Default;
              GetRRDisplayString_rdb((unsigned __int8 *)(i + 1648), (unsigned __int16 *)(v39 + 4), word_100164338);
              LogMsgWithLevel( v40,  OS_LOG_TYPE_DEFAULT,  "mDNS_SetPrimaryInterfaceInfo deregistering %s",  v41,  v42,  v43,  v44,  v45,  (int)word_100164338);
            }

            mDNS_Deregister_internal((uint64_t)mDNSStorage, i + 1640, 0);
          }
        }

        AdvertiseHostname((uint64_t)mDNSStorage, i);
      }

      if (v56)
      {
        if (a1) {
          int v46 = 0;
        }
        else {
          int v46 = 5;
        }
        dword_10015C508 = 0;
        *(_WORD *)((char *)mDNSStorage + &unk_100003970) = 0;
        RecreateNATMappings((uint64_t)mDNSStorage, 1000 * v46);
        if (mDNS_LoggingEnabled == 1)
        {
          uint64_t v53 = " v4Changed";
          if (v55 == v19) {
            uint64_t v53 = "";
          }
          LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "mDNS_SetPrimaryInterfaceInfo:%s%s: recreating NAT mappings in %d seconds",  v47,  v48,  v49,  v50,  v51,  (int)v53);
        }
      }

      if (dword_10015BE74 != -1) {
        mDNS_StopQuery_internal((uint64_t)mDNSStorage, (uint64_t)mDNSStorage + &unk_1000031E8);
      }
      *((_BYTE *)&dword_100158BF8 + &unk_1000036D0) = 0;
      int v54 = dword_100158BF8;
      dword_10015BD4C = v54;
    }
  }

  mDNS_Unlock_((uint64_t)mDNSStorage, (uint64_t)"mDNS_SetPrimaryInterfaceInfo", 2786);
}

uint64_t udsSupportAddFDToEventLoop(int a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = &gEventSources;
  do
  {
    uint64_t v7 = *v6;
    if (!*v6)
    {
      uint64_t v11 = (char *)calloc(1uLL, 0x38uLL);
      if (!v11) {
        __break(1u);
      }
      int v12 = v11;
      *(void *)uint64_t v11 = 0LL;
      *((_DWORD *)v11 + 2) = a1;
      *((void *)v11 + 5) = a2;
      *((void *)v11 + 6) = a3;
      *((void *)v11 + 2) = kqUDSEventCallback;
      *((void *)v11 + 3) = v11;
      *((void *)v11 + 4) = "UDS client";
      if (!KQueueSet(a1, 1u, -1, v11 + 16))
      {
        uint64_t v9 = 0LL;
        *uint64_t v6 = (uint64_t)v12;
        return v9;
      }

      CFDataRef v13 = (os_log_s *)mDNSLogCategory_Default;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
      {
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
        {
LABEL_22:
          int v15 = *__error();
          uint64_t v16 = __error();
          BOOL v17 = strerror(*v16);
          int v19 = 67109634;
          int v20 = a1;
          __int16 v21 = 1024;
          int v22 = v15;
          __int16 v23 = 2082;
          __int128 v24 = v17;
          _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEFAULT,  "KQueueSet failed for fd %d errno %d (%{public}s)",  (uint8_t *)&v19,  0x18u);
        }
      }

      else
      {
        CFDataRef v13 = (os_log_s *)mDNSLogCategory_Default_redacted;
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_22;
        }
      }

      free(v12);
      return 4294901756LL;
    }

    uint64_t v6 = (uint64_t *)*v6;
  }

  while (*(_DWORD *)(v7 + 8) != a1);
  uint64_t v8 = (os_log_s *)mDNSLogCategory_Default;
  uint64_t v9 = 4294901749LL;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
  {
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
      return v9;
    }
    int v19 = 67109120;
    int v20 = a1;
    goto LABEL_19;
  }

  uint64_t v8 = (os_log_s *)mDNSLogCategory_Default_redacted;
  if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
  {
    int v19 = 67109120;
    int v20 = a1;
LABEL_19:
    _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "udsSupportAddFDToEventLoop: ERROR fd %d already has EventLoop source entry",  (uint8_t *)&v19,  8u);
  }

  return v9;
}

uint64_t mDNS_GetDomains(uint64_t a1, int a2, char *a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t Domains_Internal = mDNS_GetDomains_Internal((uint64_t)mDNSStorage, a1, a2, a3, a4, a5, a6);
  mDNS_Unlock_((uint64_t)mDNSStorage, (uint64_t)"mDNS_GetDomains", 15996);
  return Domains_Internal;
}

uint64_t mDNS_StartQuery(unsigned int *a1, uint64_t a2)
{
  uint64_t started = mDNS_StartQuery_internal(a1, a2);
  mDNS_Unlock_((uint64_t)a1, (uint64_t)"mDNS_StartQuery", 15801);
  return started;
}

void RegisterLocalOnlyDomainEnumPTR(unsigned int *a1, _BYTE *a2, int a3)
{
  uint64_t v6 = calloc(1uLL, 0x4A0uLL);
  if (v6)
  {
    uint64_t v7 = v6;
    uint64_t v8 = (uint64_t)(v6 + 1);
    mDNS_SetupResourceRecord( (uint64_t)(v6 + 1),  0LL,  -2LL,  12,  0x1C20u,  8,  4,  (uint64_t)FreeARElemCallback_2533,  (uint64_t)v6);
    uint64_t v9 = (unsigned __int8 *)mDNS_DomainTypeNames[a3];
    *((_BYTE *)v7 + 660) = 0;
    AppendDNSNameString((_BYTE *)v7 + 660, v9, v10, v11, v12, v13, v14, v15);
    AppendDNSNameString((_BYTE *)v7 + 660, "local", v16, v17, v18, v19, v20, v21);
    int v22 = a2;
    if (a2 == (_BYTE *)-256LL)
    {
LABEL_4:
      while (v22)
      {
        uint64_t v23 = *v22;
        if (!*v22)
        {
          unsigned __int16 v24 = (_WORD)v22 - (_WORD)a2 + 1;
          if (v24 > 0x100u) {
            break;
          }
          memcpy((void *)(v7[7] + 4LL), a2, v24);
          goto LABEL_12;
        }

        v22 += v23 + 1;
        if (a2 != (_BYTE *)-256LL) {
          goto LABEL_3;
        }
      }
    }

    else
    {
LABEL_3:
      if (v22 < a2 + 256) {
        goto LABEL_4;
      }
    }

    *(_BYTE *)(v7[7] + 4LL) = 0;
LABEL_12:
    int v25 = mDNS_Register(a1, v8);
    if (v25)
    {
      LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "SetSCPrefsBrowseDomain: mDNS_Register returned error %d",  v26,  v27,  v28,  v29,  v30,  v25);
      free(v7);
    }

    else
    {
      void *v7 = LocalDomainEnumRecords;
      LocalDomainEnumRecords = (uint64_t)v7;
    }
  }

  else
  {
    __break(1u);
  }

uint64_t mDNS_Register(unsigned int *a1, uint64_t a2)
{
  uint64_t v4 = mDNS_Register_internal(a1, a2);
  mDNS_Unlock_((uint64_t)a1, (uint64_t)"mDNS_Register", 16319);
  return v4;
}

void AddAutoBrowseDomain(int a1, char *a2)
{
  uint64_t v4 = AutoBrowseDomains;
  if (!AutoBrowseDomains)
  {
LABEL_5:
    unsigned int v5 = (char *)calloc(1uLL, 0x110uLL);
    if (!v5) {
      __break(1u);
    }
    uint64_t v6 = (uint64_t)v5;
    uint64_t v7 = a2 + 256;
    uint64_t v8 = a2;
    if (a2 == (char *)-256LL)
    {
LABEL_8:
      while (v8)
      {
        uint64_t v9 = *v8;
        if (!*v8)
        {
          unsigned __int16 v10 = (_WORD)v8 - (_WORD)a2 + 1;
          if (v10 > 0x100u) {
            break;
          }
          memcpy(v5 + 12, a2, v10);
          goto LABEL_16;
        }

        v8 += v9 + 1;
      }
    }

    else
    {
LABEL_7:
      if (v8 < v7) {
        goto LABEL_8;
      }
    }

    v5[12] = 0;
LABEL_16:
    *(_DWORD *)(v6 + 8) = a1;
    *(void *)uint64_t v6 = AutoBrowseDomains;
    AutoBrowseDomains = v6;
    uint64_t v11 = (os_log_s *)mDNSLogCategory_mDNS;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
      {
LABEL_51:
        udsserver_automatic_browse_domain_changed(v6, 1, v17, v18, v19, v20, v21, v22);
        return;
      }

      if (a2)
      {
        uint64_t v13 = a2;
LABEL_24:
        int v14 = 257;
        if (v13 < v7 && v13)
        {
          while (1)
          {
            uint64_t v15 = *v13;
            if (v15 > 0x3F)
            {
LABEL_45:
              int v14 = 257;
              goto LABEL_50;
            }

            if (!*v13) {
              break;
            }
            v13 += v15 + 1;
LABEL_27:
            if (!v13) {
              goto LABEL_45;
            }
          }

          int v14 = (unsigned __int16)((_WORD)v13 - (_WORD)a2 + 1);
        }
      }

      else
      {
        int v14 = 0;
      }
    }

    else
    {
      uint64_t v11 = (os_log_s *)mDNSLogCategory_mDNS_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_51;
      }
      if (a2)
      {
        uint64_t v23 = a2;
LABEL_35:
        int v14 = 257;
        if (v23 < v7 && v23)
        {
          while (1)
          {
            uint64_t v24 = *v23;
            if (v24 > 0x3F)
            {
LABEL_46:
              int v14 = 257;
              goto LABEL_50;
            }

            if (!*v23) {
              break;
            }
            v23 += v24 + 1;
LABEL_38:
            if (!v23) {
              goto LABEL_46;
            }
          }

          int v14 = (unsigned __int16)((_WORD)v23 - (_WORD)a2 + 1);
        }
      }

      else
      {
        int v14 = 0;
      }
    }

LABEL_50:
    int v25 = 141558787;
    uint64_t v26 = 1752392040LL;
    __int16 v27 = 1040;
    int v28 = v14;
    __int16 v29 = 2101;
    uint64_t v30 = a2;
    __int16 v31 = 1024;
    int v32 = a1;
    _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "Automatic browsing domain is added - domain name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P, uid: %u",  (uint8_t *)&v25,  0x22u);
    goto LABEL_51;
  }

  while (!SameDomainNameBytes(a2, (_BYTE *)(v4 + 12)) || *(_DWORD *)(v4 + 8) != a1)
  {
    uint64_t v4 = *(void *)v4;
    if (!v4) {
      goto LABEL_5;
    }
  }

      uint64_t v15 = (void *)*v15;
      if (!v15) {
        goto LABEL_51;
      }
    }
  }

  return result;
}

  char *v30 = (void *)*((void *)v17 + 1);
  *((void *)v17 + 1) = v30;
  uint64_t v40 = *((unsigned __int8 *)v30 + 16);
  *((_BYTE *)v30 + 16) = 0;
  *((_BYTE *)v30 + 17) = (a4 & 0x10) != 0;
  if (v40)
  {
    uint64_t v41 = _unicast_assist_cache_log();
    uint64_t v42 = (os_log_s *)objc_claimAutoreleasedReturnValue(v41);
    if (os_log_type_enabled(v42, OS_LOG_TYPE_DEBUG))
    {
      if (a7) {
        uint64_t v43 = "refreshed";
      }
      else {
        uint64_t v43 = v49;
      }
      uint64_t v44 = a1;
      if (a1)
      {
        uint64_t v45 = 257;
        if (a1 == (_BYTE *)-256LL) {
          goto LABEL_64;
        }
LABEL_61:
        if (v44 < a1 + 256 && v44)
        {
          while (1)
          {
            int v46 = *v44;
            if (v46 > 0x3F)
            {
LABEL_69:
              uint64_t v45 = 257;
              goto LABEL_71;
            }

            if (!*v44) {
              break;
            }
            v44 += v46 + 1;
            if (a1 != (_BYTE *)-256LL) {
              goto LABEL_61;
            }
LABEL_64:
            if (!v44) {
              goto LABEL_69;
            }
          }

          uint64_t v45 = (unsigned __int16)((_WORD)v44 - (_WORD)a1 + 1);
        }
      }

      else
      {
        uint64_t v45 = 0;
      }

void udsserver_automatic_browse_domain_changed( uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = all_requests;
  if (all_requests)
  {
    uint64_t v11 = (_BYTE *)(a1 + 12);
    p_opt_inst_meths = &OBJC_PROTOCOL___OS_mdns_dso_keepalive_message_builder.opt_inst_meths;
    while (1)
    {
      uint64_t v13 = *(void *)(v8 + 136);
      if (!*(_BYTE *)(v13 + 8)) {
        goto LABEL_4;
      }
      int v14 = *(_DWORD *)(a1 + 8);
      if (v14)
      {
        unsigned int v15 = *(_DWORD *)(v8 + 180);
        if (v15 >= 0x1F5 && v15 != v14) {
          goto LABEL_4;
        }
      }

      uint64_t v17 = (void *)(v13 + 272);
      uint64_t v18 = *(void *)(v13 + 272);
      if (v18)
      {
        while (1)
        {
          int v19 = SameDomainNameBytes((_BYTE *)(v18 + 8), v11);
          uint64_t v20 = (void *)*v17;
          if (v19) {
            break;
          }
          uint64_t v18 = *v20;
          uint64_t v17 = (void *)*v17;
          if (!*v20)
          {
            uint64_t v21 = 0LL;
            uint64_t v17 = v20;
            if (a2) {
              goto LABEL_19;
            }
            goto LABEL_22;
          }
        }

        uint64_t v21 = (void *)*v17;
        if (a2) {
          goto LABEL_19;
        }
      }

      else
      {
        uint64_t v21 = 0LL;
        if (a2)
        {
LABEL_19:
          if (!v21) {
            add_domain_to_browser(v8, v11);
          }
          goto LABEL_4;
        }
      }

LABEL_22:
      if (!v21)
      {
        LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "udsserver_automatic_browse_domain_changed ERROR %##s not found",  a4,  a5,  a6,  a7,  a8,  (int)v11);
        goto LABEL_4;
      }

      uint64_t v22 = p_opt_inst_meths[486];
      if (v22)
      {
        while (1)
        {
          uint32_t entrysize = v22[1].entrysize;
          if (!entrysize || ((unsigned int v24 = *(_DWORD *)(v8 + 180), v24 >= 0x1F5) ? (v25 = v24 == entrysize) : (v25 = 1), v25))
          {
          }

          uint64_t v22 = (__objc2_meth_list *)*v22;
          if (!v22)
          {
            uint64_t v21 = (void *)*v17;
            break;
          }
        }
      }

      void *v17 = *v21;
      uint64_t v26 = v21 + 33;
      mDNS_Lock_((unsigned int *)mDNSStorage, (uint64_t)"mDNS_StopQueryWithRemoves", 15846);
      __int16 v27 = &qword_100158C88;
      do
      {
        uint64_t v28 = *v27;
        __int16 v27 = (uint64_t *)(*v27 + 8);
        if (v28) {
          BOOL v29 = v28 == (void)v26;
        }
        else {
          BOOL v29 = 1;
        }
      }

      while (!v29);
      uint64_t v30 = v21[50];
      BOOL v32 = v30 == -5 || v30 == -3 || v30 == -2;
      uint64_t v33 = 25LL;
      if (v32) {
        uint64_t v33 = 28LL;
      }
      uint64_t v34 = &mDNSStorage[v33];
      do
      {
        uint64_t v35 = *v34;
        uint64_t v34 = (uint64_t *)(*v34 + 8);
        if (v35) {
          BOOL v36 = v35 == (void)v26;
        }
        else {
          BOOL v36 = 1;
        }
      }

      while (!v36);
      if (v35) {
        break;
      }
      p_opt_inst_meths = (__objc2_meth_list **)(&OBJC_PROTOCOL___OS_mdns_dso_keepalive_message_builder + 40);
      if ((*((_DWORD *)v21 + 119) & 0x80000000) != 0) {
        goto LABEL_57;
      }
      uint64_t v37 = (os_log_s *)mDNSLogCategory_Default;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_FAULT)) {
          goto LABEL_57;
        }
        uint64_t v39 = (char *)v21 + 620;
        if (v21 == (void *)-876LL)
        {
LABEL_68:
          while (v39)
          {
            uint64_t v40 = *v39;
            if (!*v39)
            {
              unsigned __int16 v58 = (_WORD)v39 - ((_WORD)v21 + 620) + 1;
              goto LABEL_110;
            }

            v39 += v40 + 1;
            if (v21 != (void *)-876LL) {
              goto LABEL_67;
            }
          }
        }

        else
        {
LABEL_67:
          if (v39 < (_BYTE *)v21 + 876) {
            goto LABEL_68;
          }
        }

        unsigned __int16 v58 = 257;
      }

      else
      {
        uint64_t v37 = (os_log_s *)mDNSLogCategory_Default_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_FAULT)) {
          goto LABEL_57;
        }
        uint64_t v47 = (char *)v21 + 620;
        if (v21 == (void *)-876LL)
        {
LABEL_89:
          while (v47)
          {
            uint64_t v48 = *v47;
            if (!*v47)
            {
              unsigned __int16 v58 = (_WORD)v47 - ((_WORD)v21 + 620) + 1;
              goto LABEL_110;
            }

            v47 += v48 + 1;
            if (v21 != (void *)-876LL) {
              goto LABEL_88;
            }
          }
        }

        else
        {
LABEL_88:
          if (v47 < (_BYTE *)v21 + 876) {
            goto LABEL_89;
          }
        }

        unsigned __int16 v58 = 257;
      }

            if (v19 == ++v20) {
              goto LABEL_25;
            }
          }

          uint64_t v28 = ValueAtIndex[12];
          BOOL v29 = _mdns_address_new();
          if (!v29)
          {
LABEL_24:
            _mdns_dns_service_append_address(v15, 0LL);
            goto LABEL_22;
          }

          __int16 v27 = (void *)v29;
          *(_WORD *)(v29 + 24) = 7708;
          *(_WORD *)(v29 + 26) = v21;
          *(_OWORD *)(v29 + 32) = *((_OWORD *)v23 + 2);
          *(_DWORD *)(v29 + 48) = v28;
          goto LABEL_21;
        }
      }
    }

  uint64_t v20 = *(unsigned __int16 *)(a3 + 4);
  if (v20 == 5)
  {
    if (a6) {
      return;
    }
    uint64_t v21 = *(unsigned __int16 *)(a2 + 322);
    if (v21 == 28)
    {
      uint64_t v22 = a7 + 160;
      uint64_t v23 = a7 + 246;
    }

    else
    {
      if (v21 != 1) {
        goto LABEL_39;
      }
      uint64_t v22 = a7 + 152;
      uint64_t v23 = a7 + 245;
    }

    __int16 v27 = (unsigned __int8 *)(*(void *)(a3 + 40) + 4LL);
    bzero(v38, 0x3F1uLL);
    if (!ConvertDomainNameToCString_withescape(v27, v38)) {
      v38[0] = 0;
    }
    v37[0] = _NSConcreteStackBlock;
    v37[1] = 0x40000000LL;
    v37[2] = ___dx_gai_request_append_cname_block_invoke;
    v37[3] = &__block_descriptor_tmp_46_964;
    v37[4] = v38;
    v37[5] = v22;
    v37[6] = v23;
    os_unfair_lock_lock((os_unfair_lock_t)(a7 + 56));
    ___dx_gai_request_append_cname_block_invoke((uint64_t)v37);
    os_unfair_lock_unlock((os_unfair_lock_t)(a7 + 56));
    if (v21 == 1 && !a4 && (*(_BYTE *)(a7 + 242) & 0x10) != 0)
    {
      uint64_t v28 = *(char **)(a7 + 200);
      if (v28)
      {
        _dx_release(v28);
        *(void *)(a7 + 200) = 0LL;
      }
    }

  if (v34 != 4
    && *(_WORD *)(a1 + 12) != 41
    && (*(_DWORD *)(a1 + 16) != a4
     || *(unsigned __int16 *)(a1 + 20) != v26
     || memcmp((const void *)(*(void *)(a1 + 48) + 4LL), v17 + 2, v26)))
  {
    *(_BYTE *)(a1 + 191) = 4;
    InitializeLastAPTime(mDNSStorage, a1);
    unsigned __int16 v60 = *(_DWORD *)(a1 + 332);
    if (v60)
    {
      uint64_t v61 = dword_100158BF8;
      while ((int)(v61 - v60) >= 0)
      {
        uint64_t v62 = *(_DWORD *)(a1 + 328) + 1;
        *(_DWORD *)(a1 + 328) = v62;
        v60 += 6000;
        if (v60 <= 1) {
          unsigned __int16 v60 = 1;
        }
        if (v62 <= 9) {
          int v63 = v60;
        }
        else {
          int v63 = 0;
        }
        *(_DWORD *)(a1 + 332) = v63;
        if (v62 >= 0xA) {
          goto LABEL_60;
        }
      }

      uint64_t v64 = 0;
    }

    else
    {
LABEL_60:
      uint64_t v64 = 1;
    }

    int v68 = *(_DWORD *)(a1 + 336);
    if (!v68)
    {
      unsigned int v69 = *(_DWORD *)(a1 + 328);
      if (v69) {
        *(_DWORD *)(a1 + 328) = v69 - 1;
      }
    }

    if (v64)
    {
      int v70 = dword_100158BF8 + 6000;
      *(_DWORD *)(a1 + 332) = v70;
    }

    uint64_t v71 = *(_DWORD *)(a1 + 328);
    if (v71 <= 5)
    {
      if (!v68)
      {
        if (dword_100158BF8 + 1000 * (6 - v71) <= 1) {
          int v68 = 1;
        }
        else {
          int v68 = dword_100158BF8 + 1000 * (6 - v71);
        }
        *(_DWORD *)(a1 + 336) = v68;
      }

      int v72 = *(_DWORD *)(a1 + 280);
      *(_DWORD *)(a1 + 280) = 4 * v72;
      *(_DWORD *)(a1 + 284) = v68 - 4 * v72;
      LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "Excessive update rate for %##s; delaying announcement by %ld second%s",
        v55,
        v56,
        v57,
        v58,
        v59,
        *(void *)(a1 + 40));
    }

    *(_DWORD *)(a1 + 16) = a4;
    goto LABEL_25;
  }

                  if (++v21)
                  {
                    --v22;
                    if (v21 != v13) {
                      continue;
                    }
                  }

                  break;
                }
              }
            }
          }

LABEL_110:
      int v63 = v58;
      uint64_t v64 = DNSTypeName(*((unsigned __int16 *)v21 + 293));
      *(_DWORD *)buf = 141558787;
      *(void *)uint64_t v75 = 1752392040LL;
      *(_WORD *)&v75[8] = 1040;
      *(_DWORD *)&v75[10] = v63;
      __int16 v76 = 2101;
      *(void *)uint64_t v77 = (char *)v21 + 620;
      *(_WORD *)&v77[8] = 2082;
      *(void *)&v77[10] = v64;
      _os_log_impl( (void *)&_mh_execute_header,  v37,  OS_LOG_TYPE_FAULT,  "Question not found in the active list - qname: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P, qtype: %{public}s.",  buf,  0x26u);
LABEL_56:
      p_opt_inst_meths = (__objc2_meth_list **)(&OBJC_PROTOCOL___OS_mdns_dso_keepalive_message_builder + 40);
LABEL_57:
      mDNS_Unlock_((uint64_t)mDNSStorage, (uint64_t)"mDNS_StopQueryWithRemoves", 15883);
      free(v21);
LABEL_4:
      uint64_t v8 = *(void *)(v8 + 16);
      if (!v8) {
        return;
      }
    }

    if (v28)
    {
LABEL_55:
      mDNS_StopQuery_internal((uint64_t)mDNSStorage, (uint64_t)(v21 + 33));
      goto LABEL_56;
    }

    __int16 v41 = (_WORD)v21 + 620;
    int v73 = CacheGroupForName((uint64_t)mDNSStorage, *((_DWORD *)v21 + 116), (_BYTE *)v21 + 620);
    uint64_t v42 = mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
      {
        unsigned int log = bswap32(*((unsigned __int16 *)v21 + 292)) >> 16;
        uint64_t v44 = (char *)v21 + 620;
        if (v21 == (void *)-876LL)
        {
LABEL_81:
          while (v44)
          {
            uint64_t v45 = *v44;
            if (!*v44)
            {
              unsigned __int16 v59 = (_WORD)v44 - v41 + 1;
              goto LABEL_108;
            }

            v44 += v45 + 1;
            if (v21 != (void *)-876LL) {
              goto LABEL_80;
            }
          }
        }

        else
        {
LABEL_80:
          if (v44 < (_BYTE *)v21 + 876) {
            goto LABEL_81;
          }
        }

        unsigned __int16 v59 = 257;
LABEL_108:
        int v70 = v59;
        uint64_t v61 = DNSTypeName(*((unsigned __int16 *)v21 + 293));
        *(_DWORD *)buf = 67110147;
        *(_DWORD *)uint64_t v75 = log;
        *(_WORD *)&v75[4] = 2160;
        *(void *)&v75[6] = 1752392040LL;
        __int16 v76 = 1040;
        *(_DWORD *)uint64_t v77 = v70;
        *(_WORD *)&v77[4] = 2101;
        *(void *)&v77[6] = (char *)v21 + 620;
        *(_WORD *)&_BYTE v77[14] = 2082;
        *(void *)&v77[16] = v61;
        uint64_t v62 = (os_log_s *)v42;
        goto LABEL_113;
      }
    }

    else
    {
      uint64_t v49 = mDNSLogCategory_Default_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
      {
        unsigned int v69 = bswap32(*((unsigned __int16 *)v21 + 292)) >> 16;
        int v56 = (char *)v21 + 620;
        os_log_t loga = (os_log_t)v49;
        if (v21 == (void *)-876LL)
        {
LABEL_97:
          while (v56)
          {
            uint64_t v57 = *v56;
            if (!*v56)
            {
              unsigned __int16 v60 = (_WORD)v56 - v41 + 1;
              goto LABEL_112;
            }

            v56 += v57 + 1;
            if (v21 != (void *)-876LL) {
              goto LABEL_96;
            }
          }
        }

        else
        {
LABEL_96:
          if (v56 < (_BYTE *)v21 + 876) {
            goto LABEL_97;
          }
        }

        unsigned __int16 v60 = 257;
LABEL_112:
        int v65 = v60;
        int v66 = DNSTypeName(*((unsigned __int16 *)v21 + 293));
        *(_DWORD *)buf = 67110147;
        *(_DWORD *)uint64_t v75 = v69;
        *(_WORD *)&v75[4] = 2160;
        *(void *)&v75[6] = 1752392040LL;
        __int16 v76 = 1040;
        *(_DWORD *)uint64_t v77 = v65;
        *(_WORD *)&v77[4] = 2101;
        *(void *)&v77[6] = (char *)v21 + 620;
        *(_WORD *)&_BYTE v77[14] = 2082;
        *(void *)&v77[16] = v66;
        uint64_t v62 = loga;
LABEL_113:
        _os_log_impl( (void *)&_mh_execute_header,  v62,  OS_LOG_TYPE_DEFAULT,  "[Q%u] Generating RMV events because the question will be stopped - qname: %{sensitive, mask.hash, mdnsresponde r:domain_name}.*P, qtype: %{public}s.",  buf,  0x2Cu);
      }
    }

    if (v73)
    {
      for (uint64_t i = v73[2]; i; uint64_t i = *(void *)i)
      {
        if (*(unsigned __int8 *)(i + 8) != 240
          && SameNameRecordAnswersQuestion((unsigned __int8 *)(i + 8), 0, (uint64_t)(v21 + 33), v51, v52, v53, v54, v55))
        {
          int v68 = (void (*)(uint64_t *, void *, uint64_t, void))v21[52];
          if (v68) {
            v68(mDNSStorage, v21 + 33, i + 8, 0LL);
          }
        }
      }
    }

    goto LABEL_55;
  }

    __int16 v41 = 136447235;
    uint64_t v42 = "automatic browse domain";
    uint64_t v43 = 1024;
    *(_DWORD *)uint64_t v44 = 1;
    *(_WORD *)&v44[4] = 2160;
    *(void *)&v44[6] = 1752392040LL;
    uint64_t v45 = 1040;
    *(_DWORD *)int v46 = v33;
    *(_WORD *)&v46[4] = 2101;
    *(void *)&v46[6] = a2;
    _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_DEFAULT,  "Resuming the %{public}s enumeration - active client count: %u, domain: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P.",  (uint8_t *)&v41,  0x2Cu);
    goto LABEL_111;
  }

  if (v6 == 1)
  {
    if (v4[167]) {
      return 0LL;
    }
    unsigned int v15 = (os_log_s *)mDNSLogCategory_mDNS;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEBUG))
      {
        unsigned int v24 = (_BYTE *)a2;
        if (a2 == -256)
        {
LABEL_68:
          while (v24)
          {
            BOOL v25 = *v24;
            if (!*v24)
            {
              BOOL v32 = (unsigned __int16)((_WORD)v24 - a2 + 1);
              goto LABEL_104;
            }

            v24 += v25 + 1;
            if (a2 != -256) {
              goto LABEL_67;
            }
          }
        }

        else
        {
LABEL_67:
        }

        BOOL v32 = 257;
        goto LABEL_104;
      }
    }

    else
    {
      unsigned int v15 = (os_log_s *)mDNSLogCategory_mDNS_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v16 = (_BYTE *)a2;
        if (a2 == -256)
        {
LABEL_39:
          while (v16)
          {
            uint64_t v17 = *v16;
            if (!*v16)
            {
              BOOL v32 = (unsigned __int16)((_WORD)v16 - a2 + 1);
              goto LABEL_104;
            }

            v16 += v17 + 1;
            if (a2 != -256) {
              goto LABEL_38;
            }
          }
        }

        else
        {
LABEL_38:
        }

        BOOL v32 = 257;
LABEL_104:
        __int16 v41 = 136447235;
        uint64_t v42 = "automatic browse domain";
        uint64_t v43 = 2160;
        *(void *)uint64_t v44 = 1752392040LL;
        *(_WORD *)&v44[8] = 1040;
        *(_DWORD *)&v44[10] = v32;
        uint64_t v45 = 2101;
        *(void *)int v46 = a2;
        *(_WORD *)&v46[8] = 1024;
        *(_DWORD *)&v46[10] = 60;
        _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_DEBUG,  "Planning to stop the %{public}s enumeration - domain: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P, g race period: %ds.",  (uint8_t *)&v41,  0x2Cu);
      }
    }

    unint64_t result = 0LL;
    v4[166] = 2;
    uint64_t v35 = a1[16] + 60000;
    if (v35 <= 1) {
      uint64_t v35 = 1;
    }
    v4[168] = v35;
    return result;
  }

  if (v6 || v4[167] != 1) {
    return 0LL;
  }
  uint64_t v7 = (os_log_s *)mDNSLogCategory_mDNS;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
  {
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_98;
    }
    uint64_t v22 = (_BYTE *)a2;
    if (a2 == -256)
    {
LABEL_60:
      while (v22)
      {
        uint64_t v23 = *v22;
        if (!*v22)
        {
          __int16 v31 = (unsigned __int16)((_WORD)v22 - a2 + 1);
          goto LABEL_97;
        }

        v22 += v23 + 1;
        if (a2 != -256) {
          goto LABEL_59;
        }
      }
    }

    else
    {
LABEL_59:
    }

    __int16 v31 = 257;
  }

  else
  {
    uint64_t v7 = (os_log_s *)mDNSLogCategory_mDNS_redacted;
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_98;
    }
    uint64_t v8 = (_BYTE *)a2;
    if (a2 == -256)
    {
LABEL_12:
      while (v8)
      {
        uint64_t v9 = *v8;
        if (!*v8)
        {
          __int16 v31 = (unsigned __int16)((_WORD)v8 - a2 + 1);
          goto LABEL_97;
        }

        v8 += v9 + 1;
        if (a2 != -256) {
          goto LABEL_11;
        }
      }
    }

    else
    {
LABEL_11:
    }

    __int16 v31 = 257;
  }

  *(_DWORD *)(a2 + 344) = 3;
  *(_DWORD *)(a2 + 280) = 1000;
  *(_DWORD *)(a2 + 284) = *(_DWORD *)(a1 + 64) - 1000;
  AuthInfoForName_internal = GetAuthInfoForName_internal(a1, *(_BYTE **)(a2 + 40));
  if (IsRecordMergeable(a1, a2, *(_DWORD *)(a1 + 64) + 1000))
  {
    else {
      uint64_t v33 = *(_DWORD *)(a2 + 284) + 1000;
    }
    *(_DWORD *)(a2 + 284) = v33;
  }

  else
  {
    uint64_t v33 = *(_DWORD *)(a2 + 284);
  }

  uint64_t v34 = *(_DWORD *)(a2 + 280) + v33;
  if (*(_DWORD *)(a1 + 12688) - v34 >= 0) {
    *(_DWORD *)(a1 + 12688) = v34;
  }
}

      if (v16) {
        ref_count_obj_release(v16);
      }
      if (v17) {
        free(v17);
      }
      return v80;
    default:
      if (v14 == 33)
      {
        uint64_t v35 = &v80[v6];
      }

      else
      {
        if (v14 != 65323) {
          goto LABEL_116;
        }
        uint64_t v35 = &v80[v6];
      }

      goto LABEL_32;
  }

                      if (dnssec_obj_validation_manager_contains_possibly_unsigned_rrset( *(void *)(v18 + 32),  *(void *)(v18 + 40)))
                      {
                        dnssec_obj_validation_manager_start_insecure_validation(v18, v7);
                      }

                      goto LABEL_112;
                    }

                    BOOL v29 = -90021;
                  }

                  else
                  {
                    BOOL v29 = -6756;
                  }
                }

                else
                {
                  BOOL v29 = -6736;
                }

                _dnssec_obj_validation_manager_fail_insecure_validation(v18, v29);
                goto LABEL_109;
              }

              dnssec_obj_validation_manager_remove_validated_cache(*(void *)(v7 + 64));
              uint64_t v18 = *(void *)(v7 + 64);
              if (*(_DWORD *)(v18 + 112)) {
                goto LABEL_28;
              }
              uint64_t v30 = *((unsigned __int16 *)a3 + 2);
              if (v30 != 43 && v30 != 48)
              {
                uint64_t v33 = (os_log_s *)mDNSLogCategory_DNSSEC;
                if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_DNSSEC == mDNSLogCategory_State)
                {
                  if (!os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC, OS_LOG_TYPE_FAULT)) {
                    goto LABEL_98;
                  }
                }

                else
                {
                  uint64_t v33 = (os_log_s *)mDNSLogCategory_DNSSEC_redacted;
                  if (!os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC_redacted, OS_LOG_TYPE_FAULT)) {
                    goto LABEL_98;
                  }
                }

                *(_DWORD *)buf = 136447234;
                *(void *)int v46 = "validated_key->rrtype == kDNSRecordType_DNSKEY || validated_key->rrtype == kDNSRecordType_DS";
                *(_WORD *)&v46[8] = 2082;
                uint64_t v47 = "";
                *(_WORD *)uint64_t v48 = 2082;
                *(void *)&v48[2] = "/Library/Caches/com.apple.xbs/Sources/mDNSResponder/mDNSMacOSX/dnssec_v2/dnssec.c";
                LOWORD(v49) = 1024;
                *(_DWORD *)((char *)&v49 + 2) = 397;
                WORD3(v49) = 2048;
                *((void *)&v49 + 1) = 0LL;
                goto LABEL_97;
              }

              __int16 v31 = dnssec_obj_rrset_remove_rr(*(void *)(v18 + 64), a3);
              if (!v31)
              {
                BOOL v32 = *(void **)(v18 + 64);
                if (!v32[4] && v32)
                {
                  ref_count_obj_release(v32);
                  *(void *)(v18 + 64) = 0LL;
                }

                *(void *)(v18 + 48) = 0xFFFFE5C200000000LL;
                *(_DWORD *)(v18 + 140) = 0;
                *(_BYTE *)(v18 + 144) = 0;
                uint64_t v44 = 0;
                goto LABEL_113;
              }

              uint64_t v44 = v31;
              if (v31 == -6727)
              {
                uint64_t v37 = (os_log_s *)mDNSLogCategory_DNSSEC;
                if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_DNSSEC == mDNSLogCategory_State)
                {
                  if (os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC, OS_LOG_TYPE_DEBUG)) {
                    goto LABEL_122;
                  }
                }

                else
                {
                  uint64_t v37 = (os_log_s *)mDNSLogCategory_DNSSEC_redacted;
                  if (os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC_redacted, OS_LOG_TYPE_DEBUG))
                  {
LABEL_122:
                    uint64_t v43 = bswap32(*(unsigned __int16 *)(v10 + 320)) >> 16;
                    *(_DWORD *)buf = 67109120;
                    *(_DWORD *)int v46 = v43;
                    uint64_t v39 = "[Q%u] Added secure record not found due to possible primary DNSSEC question change";
LABEL_94:
                    _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEBUG, v39, buf, 8u);
                  }
                }
              }

void udsserver_handle_configchange(uint64_t a1)
{
  uint64_t v39 = 0LL;
  uint64_t v40 = 0LL;
  UpdateDeviceInfoRecord(a1);
  uint64_t v7 = all_requests;
  if (all_requests)
  {
    uint64_t v8 = (unsigned __int8 *)(a1 + 10288);
    do
    {
      if (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, int))(v7 + 96) == regservice_termination_callback)
      {
        uint64_t v9 = *(void *)(v7 + 112);
        if (*(_BYTE *)(v9 + 1612))
        {
          size_t v10 = *(unsigned __int8 *)(v9 + 26);
          if ((_DWORD)v10 != *v8 || memcmp((const void *)(v9 + 27), (const void *)(a1 + 10289), v10))
          {
            __int128 v11 = *(_OWORD *)v8;
            __int128 v12 = *(_OWORD *)(a1 + 10304);
            __int128 v13 = *(_OWORD *)(a1 + 10336);
            *(_OWORD *)(v9 + 58) = *(_OWORD *)(a1 + 10320);
            *(_OWORD *)(v9 + 74) = v13;
            *(_OWORD *)(v9 + 26) = v11;
            *(_OWORD *)(v9 + 42) = v12;
            for (uint64_t i = *(uint64_t **)(v9 + 1624); i; uint64_t i = (uint64_t *)*i)
            {
              *((_BYTE *)i + 24) = 1;
              if (*((_BYTE *)i + 25)) {
                SendServiceRemovalNotification((uint64_t)(i + 36));
              }
              if (mDNS_LoggingEnabled == 1) {
                LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "udsserver_handle_configchange: Calling deregister for Service %##s",  v2,  v3,  v4,  v5,  v6,  i[195]);
              }
              if (mDNS_DeregisterService_drt( (unsigned int *)a1,  (uint64_t)(i + 36),  1,  v2,  v3,  v4,  v5,  v6)) {
                regservice_callback(a1, (uint64_t)(i + 36), 0xFFFEFF00, v2, v3, v4, v5, v6);
              }
            }
          }
        }
      }

      uint64_t v7 = *(void *)(v7 + 16);
    }

    while (v7);
  }

  mDNS_Lock_((unsigned int *)a1, (uint64_t)"udsserver_handle_configchange", 3938);
  mDNSPlatformSetDNSConfig(0, 0, 0LL, &v40, &v39, 0);
  mDNS_Unlock_(a1, (uint64_t)"udsserver_handle_configchange", 3940);
  if (v40) {
    SetPrefsBrowseDomains((unsigned int *)a1, v40, 1);
  }
  if (AutoRegistrationDomains) {
    SetPrefsBrowseDomains((unsigned int *)a1, (uint64_t *)AutoRegistrationDomains, 0);
  }
  for (uint64_t j = v40; j; uint64_t j = (uint64_t *)*j)
  {
    uint64_t v20 = (_BYTE *)AutoRegistrationDomains;
    if (!AutoRegistrationDomains) {
      goto LABEL_28;
    }
    uint64_t v21 = (void **)&AutoRegistrationDomains;
    while (1)
    {
      if (*((_DWORD *)v20 + 2) == *((_DWORD *)j + 2))
      {
        int v22 = SameDomainNameBytes(v20 + 12, (_BYTE *)j + 12);
        uint64_t v20 = *v21;
        if (v22) {
          break;
        }
      }

      uint64_t v21 = (void **)v20;
      uint64_t v20 = *(_BYTE **)v20;
      if (!v20) {
        goto LABEL_28;
      }
    }

    if (v20)
    {
      *uint64_t v21 = *(void **)v20;
      free(v20);
    }

    else
    {
LABEL_28:
      RegisterLocalOnlyDomainEnumPTR((unsigned int *)a1, (_BYTE *)j + 12, 3);
      udsserver_default_reg_domain_changed((uint64_t)j, 1, v23, v24, v25, v26, v27, v28);
    }
  }

  while (1)
  {
    BOOL v36 = (void *)AutoRegistrationDomains;
    if (!AutoRegistrationDomains) {
      break;
    }
    BOOL v29 = (_BYTE *)(AutoRegistrationDomains + 12);
    AutoRegistrationDomains = *(void *)AutoRegistrationDomains;
    DeregisterLocalOnlyDomainEnumPTR_Internal((unsigned int *)a1, v29, 3LL, 0LL, v15, v16, v17, v18);
    udsserver_default_reg_domain_changed((uint64_t)v36, 0, v30, v31, v32, v33, v34, v35);
    free(v36);
  }

  AutoRegistrationDomains = (uint64_t)v40;
  if (v39) {
    SetPrefsBrowseDomains((unsigned int *)a1, v39, 1);
  }
  if (SCPrefBrowseDomains)
  {
    SetPrefsBrowseDomains((unsigned int *)a1, (uint64_t *)SCPrefBrowseDomains, 0);
    uint64_t v37 = (void *)SCPrefBrowseDomains;
    if (SCPrefBrowseDomains)
    {
      do
      {
        uint64_t v38 = (void *)*v37;
        free(v37);
        uint64_t v37 = v38;
      }

      while (v38);
    }
  }

  SCPrefBrowseDomains = (uint64_t)v39;
}

uint64_t UpdateDeviceInfoRecord(uint64_t result)
{
  uint64_t v1 = result;
  uint64_t v2 = result + 11456;
  uint64_t v3 = all_requests;
  if (!all_requests)
  {
    if (!*(_BYTE *)v2) {
      return result;
    }
    int v4 = 0;
    uint64_t v5 = result + 11448;
    goto LABEL_15;
  }

  int v4 = 0;
  do
  {
    if (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, int))(v3 + 96) == regservice_termination_callback
      && *(_BYTE *)(*(void *)(v3 + 112) + 1612LL)
      && *(_DWORD *)(v3 + 236) != -1)
    {
      ++v4;
    }

    uint64_t v3 = *(void *)(v3 + 16);
  }

  while (v3);
  uint64_t v5 = result + 11448;
  if (!*(_BYTE *)v2) {
    goto LABEL_47;
  }
  if (!v4
    || (uint64_t v6 = *(unsigned __int8 **)(result + 11488), v7 = *v6, (_DWORD)v7 != *(unsigned __int8 *)(result + 10288))
    || (unint64_t result = memcmp(v6 + 1, (const void *)(result + 10289), v7), (_DWORD)result))
  {
LABEL_15:
    uint64_t v8 = (os_log_s *)mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_46;
      }
      uint64_t v10 = *(void *)(v1 + 11488);
      if (v10)
      {
        __int128 v11 = *(_BYTE **)(v1 + 11488);
        if (v10 == -256)
        {
LABEL_24:
          while (v11)
          {
            uint64_t v12 = *v11;
            if (!*v11)
            {
              int v16 = (unsigned __int16)((_WORD)v11 - v10 + 1);
              goto LABEL_45;
            }

            v11 += v12 + 1;
            if (v10 != -256) {
              goto LABEL_23;
            }
          }
        }

        else
        {
LABEL_23:
        }

        int v16 = 257;
      }

      else
      {
        int v16 = 0;
      }
    }

    else
    {
      uint64_t v8 = (os_log_s *)mDNSLogCategory_Default_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
      {
LABEL_46:
        unint64_t result = mDNS_Deregister((unsigned int *)v1, v5);
        if (*(_BYTE *)v2) {
          return result;
        }
LABEL_47:
        if (v4 < 1) {
          return result;
        }
        mDNS_SetupResourceRecord(v5, 0LL, 0LL, 16, 0x1194u, 4, 0, 0LL, 0LL);
        ConstructServiceName((_BYTE *)(v1 + 12100), (const char *)(v1 + 10288), "\f_device-info\x04_tcp", "\x05local");
        uint64_t v17 = *(void *)(v1 + 11496);
        else {
          size_t v18 = *(unsigned __int8 *)(v1 + 10936);
        }
        *(_BYTE *)(v17 + 4) = v18 + 6;
        uint64_t v19 = v17 + 4;
        *(_DWORD *)(v19 + 1) = 1701080941;
        *(_WORD *)(v19 + 5) = 15724;
        memcpy((void *)(v19 + 7), (const void *)(v1 + 10937), v18);
        size_t v20 = v19 + 7 + v18;
        if (OSXVers)
        {
          buf[2] = 0;
          *(_WORD *)buf = 0;
          *(_BYTE *)size_t v20 = 10;
          *(void *)(v20 + 1) = 0x3D7372657678736FLL;
          snprintf((char *)buf, 3uLL, "%d", OSXVers);
          *(_WORD *)(v20 + 9) = *(_WORD *)buf;
          LOWORD(vmemset(v45, 0, 20) = v20 + 11;
        }

        *(_WORD *)(v2 + 12) = v20 - v19;
        uint64_t v21 = (os_log_s *)mDNSLogCategory_Default;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
        {
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v22 = *(void *)(v1 + 11488);
            if (v22)
            {
              uint64_t v25 = *(_BYTE **)(v1 + 11488);
              if (v22 == -256)
              {
LABEL_68:
                while (v25)
                {
                  uint64_t v26 = *v25;
                  if (!*v25)
                  {
                    int v27 = (unsigned __int16)((_WORD)v25 - v22 + 1);
                    goto LABEL_79;
                  }

                  v25 += v26 + 1;
                  if (v22 != -256) {
                    goto LABEL_67;
                  }
                }
              }

              else
              {
LABEL_67:
              }

              int v27 = 257;
            }

            else
            {
              int v27 = 0;
            }

            goto LABEL_79;
          }
        }

        else
        {
          uint64_t v21 = (os_log_s *)mDNSLogCategory_Default_redacted;
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v22 = *(void *)(v1 + 11488);
            if (v22)
            {
              uint64_t v23 = *(_BYTE **)(v1 + 11488);
              if (v22 == -256)
              {
LABEL_59:
                while (v23)
                {
                  uint64_t v24 = *v23;
                  if (!*v23)
                  {
                    int v27 = (unsigned __int16)((_WORD)v23 - v22 + 1);
                    goto LABEL_79;
                  }

                  v23 += v24 + 1;
                  if (v22 != -256) {
                    goto LABEL_58;
                  }
                }
              }

              else
              {
LABEL_58:
              }

              int v27 = 257;
            }

            else
            {
              int v27 = 0;
            }

LABEL_79:
            *(_DWORD *)buf = 141558531;
            uint64_t v29 = 1752392040LL;
            __int16 v30 = 1040;
            int v31 = v27;
            __int16 v32 = 2101;
            uint64_t v33 = v22;
            _os_log_impl( (void *)&_mh_execute_header,  v21,  OS_LOG_TYPE_DEFAULT,  "UpdateDeviceInfoRecord Register %{sensitive, mask.hash, mdnsresponder:domain_name}.*P",  buf,  0x1Cu);
          }
        }

        return mDNS_Register((unsigned int *)v1, v5);
      }

      uint64_t v10 = *(void *)(v1 + 11488);
      if (v10)
      {
        int v14 = *(_BYTE **)(v1 + 11488);
        if (v10 == -256)
        {
LABEL_33:
          while (v14)
          {
            uint64_t v15 = *v14;
            if (!*v14)
            {
              int v16 = (unsigned __int16)((_WORD)v14 - v10 + 1);
              goto LABEL_45;
            }

            v14 += v15 + 1;
            if (v10 != -256) {
              goto LABEL_32;
            }
          }
        }

        else
        {
LABEL_32:
        }

        int v16 = 257;
      }

      else
      {
        int v16 = 0;
      }
    }

          v23 += (*(_DWORD *)(v23 + 8) + *(unsigned __int16 *)(v23 + 16) + 3LL) & 0x1FFFFFFFCLL;
        }

        while (v23 < v24);
      }
    }
  }

  KQueueUnlock((uint64_t)"bpf_callback", v14, v15, v16, v17, v18, (uint64_t)v19, v20);
}

LABEL_45:
    *(_DWORD *)buf = 141558531;
    uint64_t v29 = 1752392040LL;
    __int16 v30 = 1040;
    int v31 = v16;
    __int16 v32 = 2101;
    uint64_t v33 = v10;
    _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "UpdateDeviceInfoRecord Deregister %{sensitive, mask.hash, mdnsresponder:domain_name}.*P",  buf,  0x1Cu);
    goto LABEL_46;
  }

  return result;
}

        BOOL v36 = *(void *)(a1 + 216);
        if (v36 == v28)
        {
          BOOL v36 = *(void *)(v28 + 8);
          *(void *)(a1 + 216) = v36;
        }

        uint64_t v28 = v36;
        if (!v36) {
          goto LABEL_67;
        }
      }

      int v46 = (os_log_s *)mDNSLogCategory_DNSSEC;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_DNSSEC == mDNSLogCategory_State)
      {
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC, OS_LOG_TYPE_INFO))
        {
          uint64_t v47 = *(void *)(v11 + 64);
          if (v47) {
            LODWORD(v47) = *(_DWORD *)(v47 + 32) == 1;
          }
LABEL_66:
          uint64_t v48 = bswap32(*(unsigned __int16 *)(v28 + 320));
          uint64_t v49 = *(unsigned __int16 *)(v11 + 12);
          *(_DWORD *)buf = 67109632;
          uint64_t v54 = HIWORD(v48);
          uint64_t v55 = 1024;
          int v56 = v49;
          uint64_t v57 = 1024;
          unsigned __int16 v58 = v47;
          _os_log_impl( (void *)&_mh_execute_header,  v46,  OS_LOG_TYPE_INFO,  "[Q%u] Delivering RMV event for the negative record - rr type: %{mdns:rrtype}d, validated: %{mdns:yesno}d",  buf,  0x14u);
        }
      }

      else
      {
        int v46 = (os_log_s *)mDNSLogCategory_DNSSEC_redacted;
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC_redacted, OS_LOG_TYPE_INFO))
        {
          uint64_t v47 = *(void *)(v11 + 64);
          if (v47) {
            LODWORD(v47) = *(_DWORD *)(v47 + 32) == 1;
          }
          goto LABEL_66;
        }
      }

  v296 = v12;
  __int16 v32 = *(uint64_t **)(v8 + 12624);
  if (!v32) {
    goto LABEL_208;
  }
  uint64_t v33 = a1;
  uint64_t v34 = (_BYTE *)(a1 + 46976);
  do
  {
    if (*((_BYTE *)v32 + 195))
    {
      *(_OWORD *)v322 = xmmword_1000FFD08;
      *(_DWORD *)buf = 6;
      uint64_t v35 = *((_DWORD *)v32 + 58);
      v323 = 0;
      *(_DWORD *)&v322[4] = v35;
      *(_OWORD *)v309 = *(_OWORD *)((char *)v32 + 236);
      if (v35) {
        SendDelayedUnicastResponse(v33, (int *)v322, v32[26], (uint64_t)a4, a5, a6, a7, a8);
      }
      if (vorr_s8( *(int8x8_t *)((char *)v32 + 236),  (int8x8_t)*(_OWORD *)&vextq_s8(*(int8x16_t *)((char *)v32 + 236), *(int8x16_t *)((char *)v32 + 236), 8uLL)))
      {
        SendDelayedUnicastResponse(v33, (int *)buf, v32[26], (uint64_t)a4, a5, a6, a7, a8);
      }

      if (*((_BYTE *)v32 + 195))
      {
        BOOL v36 = (os_log_s *)mDNSLogCategory_Default;
        GetRRDisplayString_rdb((unsigned __int8 *)v32 + 8, (unsigned __int16 *)(v32[6] + 4), v34);
        uint64_t v33 = a1;
        LogMsgWithLevel( v36,  OS_LOG_TYPE_DEFAULT,  "SendResponses: ERROR: rr->ImmedUnicast still set: %s",  v37,  v38,  v39,  v40,  v41,  (int)v34);
        *((_BYTE *)v32 + 195) = 0;
      }
    }

    __int16 v32 = (uint64_t *)*v32;
  }

  while (v32);
  uint64_t v42 = *(void *)(v33 + 12624);
  if (!v42) {
    goto LABEL_208;
  }
  uint64_t v43 = 0;
  uint64_t v44 = a1;
  do
  {
    uint64_t v45 = *(_DWORD *)(v42 + 332);
    if (v45)
    {
      int v46 = *v12;
      do
      {
        uint64_t v47 = *(_DWORD *)(v42 + 328) + 1;
        *(_DWORD *)(v42 + 328) = v47;
        v45 += 6000;
        if (v45 <= 1) {
          uint64_t v45 = 1;
        }
        uint64_t v48 = v47 <= 9 ? v45 : 0;
        *(_DWORD *)(v42 + 332) = v48;
      }

      while (v47 < 0xA);
    }

    uint64_t v49 = *(unsigned __int8 *)(v42 + 191);
    if (*(_BYTE *)(v42 + 191))
    {
      uint64_t v50 = *v12;
      uint64_t v51 = *(_DWORD *)(v42 + 280);
      if (*v12 - (*(_DWORD *)(v42 + 284) + v51) < 0) {
        goto LABEL_101;
      }
      if (*(_BYTE *)(v42 + 8) == 1)
      {
        uint64_t v44 = a1;
        if (*(_DWORD *)(v42 + 126))
        {
          if (mDNS_LoggingEnabled == 1)
          {
            uint64_t v52 = mDNSLogCategory_Default;
            GetRRDisplayString_rdb((unsigned __int8 *)(v42 + 8), (unsigned __int16 *)(*(void *)(v42 + 48) + 4LL), v34);
            uint64_t v53 = (os_log_s *)v52;
            uint64_t v44 = a1;
            LogMsgWithLevel( v53,  OS_LOG_TYPE_DEFAULT,  "SendResponses: Sending wakeup %2d for %.6a %s",  v54,  v55,  v56,  v57,  v58,  v49 - 3);
            uint64_t v49 = *(unsigned __int8 *)(v42 + 191);
          }

          SendWakeup(v44, *(void *)(v42 + 32), v42 + 132, v42 + 138, (v49 - 17) < 2);
          unsigned __int16 v59 = v42;
          do
          {
            if (*(_BYTE *)(v59 + 8) == 1)
            {
              unsigned __int16 v60 = *(unsigned __int8 *)(v59 + 191);
              if (*(_BYTE *)(v59 + 191))
              {
                if (*(void *)(v59 + 32) == *(void *)(v42 + 32)
                  && *(unsigned __int16 *)(v59 + 132) == *(unsigned __int16 *)(v42 + 132)
                  && *(unsigned __int16 *)(v59 + 134) == *(unsigned __int16 *)(v42 + 134)
                  && *(unsigned __int16 *)(v59 + 136) == *(unsigned __int16 *)(v42 + 136)
                  && (*(_WORD *)(v59 + 126) || *(_WORD *)(v59 + 128) || *(_WORD *)(v59 + 130)))
                {
                  if (v60 == 18 && *(_DWORD *)(v59 + 144) == 6)
                  {
                    if (mDNS_LoggingEnabled == 1)
                    {
                      uint64_t v61 = (os_log_s *)mDNSLogCategory_Default;
                      GetRRDisplayString_rdb( (unsigned __int8 *)(v59 + 8),  (unsigned __int16 *)(*(void *)(v59 + 48) + 4LL),  v34);
                      LogMsgWithLevel( v61,  OS_LOG_TYPE_DEFAULT,  "NDP Announcement %2d Releasing traffic for H-MAC %.6a I-MAC %.6a %s",  v62,  v63,  v64,  v65,  v66,  15);
                    }

                    SendNDP( a1,  136,  32,  v59,  (int8x8_t *)(v59 + 148),  (int *)(v59 + 132),  (uint64_t)&AllHosts_v6,  (uint64_t)&AllHosts_v6_Eth);
                    LOBYTE(v60) = *(_BYTE *)(v59 + 191);
                  }

                  *(_DWORD *)(v59 + 284) = *v12;
                  uint64_t v67 = v60 - 1;
                  *(_BYTE *)(v59 + 191) = v67;
                  if (v67 <= 3u)
                  {
                    *(_WORD *)(v59 + 130) = 0;
                    *(_DWORD *)(v59 + 126) = 0;
                  }
                }
              }
            }

            unsigned __int16 v59 = *(void *)v59;
          }

          while (v59);
LABEL_101:
          uint64_t v44 = a1;
          goto LABEL_102;
        }

        *(void *)(v42 + 208) = -1LL;
      }

      else
      {
        if (!ResourceRecordIsValidAnswer(v42)) {
          goto LABEL_101;
        }
        int v68 = *(_DWORD *)(v42 + 144);
        if (v68)
        {
          if (!*(_WORD *)(v42 + 126) && !*(_WORD *)(v42 + 128) && !*(_WORD *)(v42 + 130)) {
            goto LABEL_101;
          }
          unsigned int v69 = v49 - 1;
          *(_BYTE *)(v42 + 191) = v69;
          *(_DWORD *)(v42 + 280) = 2 * v51;
          *(_DWORD *)(v42 + 284) = v50;
          if (v68 == 6)
          {
            if (mDNS_LoggingEnabled == 1)
            {
              uint64_t v77 = (os_log_s *)mDNSLogCategory_Default;
              GetRRDisplayString_rdb( (unsigned __int8 *)(v42 + 8),  (unsigned __int16 *)(*(void *)(v42 + 48) + 4LL),  v34);
              LogMsgWithLevel( v77,  OS_LOG_TYPE_DEFAULT,  "NDP Announcement %2d Capturing traffic for H-MAC %.6a I-MAC %.6a %s",  v78,  v79,  v80,  v81,  v82,  v69);
            }

            uint64_t v44 = a1;
            SendNDP(a1, 136, 32, v42, (int8x8_t *)(v42 + 148), 0LL, (uint64_t)&AllHosts_v6, (uint64_t)&AllHosts_v6_Eth);
          }

          else
          {
            uint64_t v44 = a1;
            if (v68 == 4)
            {
              if (mDNS_LoggingEnabled == 1)
              {
                int v70 = mDNSLogCategory_Default;
                GetRRDisplayString_rdb( (unsigned __int8 *)(v42 + 8),  (unsigned __int16 *)(*(void *)(v42 + 48) + 4LL),  v34);
                uint64_t v71 = (os_log_s *)v70;
                uint64_t v44 = a1;
                LogMsgWithLevel( v71,  OS_LOG_TYPE_DEFAULT,  "ARP Announcement %2d Capturing traffic for H-MAC %.6a I-MAC %.6a %s",  v72,  v73,  v74,  v75,  v76,  v69);
              }

              SendARP(v44, 1, v42, v42 + 148, (uint64_t)&zeroEthAddr, v42 + 148, (uint64_t)&onesEthAddr);
            }
          }
        }

        else
        {
          *(void *)(v42 + 208) = -1LL;
          if (v43 <= v51) {
            uint64_t v43 = v51;
          }
          uint64_t v44 = a1;
          if (*(_DWORD *)(v42 + 336)) {
            *(_DWORD *)(v42 + 336) = 0;
          }
        }
      }
    }

  if (a5) {
    __int16 v30 = 100;
  }
  else {
    __int16 v30 = 900;
  }
  *(_DWORD *)&v48[0].sa_len = v30;
  setsockopt(v19, 0xFFFF, 4230, v48, 4u);
  *((_DWORD *)v12 + 4) = v19;
  v12[3] = tcpKQSocketCallback;
  v12[4] = v12;
  v12[5] = "mDNSPlatformTCPSocket";
  if (setsockopt(v19, 6, 513, &v43, 4u) < 0)
  {
    int v31 = (os_log_s *)mDNSLogCategory_NAT;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_NAT == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_NAT, OS_LOG_TYPE_DEFAULT))
      {
LABEL_55:
        __int16 v32 = *__error();
        *(_DWORD *)&v48[0].sa_len = 67109120;
        *(_DWORD *)&v48[0].sa_data[2] = v32;
        _os_log_impl( (void *)&_mh_execute_header,  v31,  OS_LOG_TYPE_DEFAULT,  "mDNSPlatformTCPSocket: TCP_NOTSENT_LOWAT returned %d",  &v48[0].sa_len,  8u);
      }
    }

    else
    {
      int v31 = (os_log_s *)mDNSLogCategory_NAT_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_NAT_redacted, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_55;
      }
    }

    mDNSPlatformTCPCloseConnection(v12);
    return 0LL;
  }

  v12[1] = 0LL;
  *((_DWORD *)v12 + 1) = a1;
  v12[7] = 0LL;
  *((_WORD *)v12 + 32) = 0;
  *((_DWORD *)v12 + 17) = 0;
  v12[9] = &mDNSStorage;
  *((_DWORD *)v12 + memset(v45, 0, 20) = 0;
  return v12;
}

    __break(1u);
LABEL_46:
    int v16 = 0LL;
    if (v4) {
      goto LABEL_20;
    }
  }

  ref_count_obj_release(v2);
  if (v16) {
    ref_count_obj_release(v16);
  }
LABEL_42:
  dns_push_handle_question_stop(a1, a2);
  return v5;
}

                      ;
                    }

                    __int16 v30 = [v55 countByEnumeratingWithState:&v57 objects:v73 count:16];
                  }

                  while (v30);
                }

                size_t v20 = v54 + 1;
              }

              while ((id)(v54 + 1) != v53);
              uint64_t v53 = [v51 countByEnumeratingWithState:&v61 objects:v77 count:16];
            }

            while (v53);
          }

          __int128 v13 = v50 + 1;
        }

        while ((id)(v50 + 1) != v48);
        uint64_t v48 = [obj countByEnumeratingWithState:&v65 objects:v78 count:16];
      }

      while (v48);
    }

    mDNS_Unlock_((uint64_t)mDNSStorage, (uint64_t)"-[UAPresenceManager updatePresenseData]", 743);
    KQueueUnlock((uint64_t)"UAPresence updatePresenseData", v39, v40, v41, v42, v43, v44, v45);
  }
}

    int v31 = (os_log_s *)mDNSLogCategory_XPC;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_XPC == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_XPC, OS_LOG_TYPE_DEFAULT))
      {
LABEL_53:
        buf[0].st_dev = 134218240;
        *(void *)&buf[0].st_mode = remote_connection;
        WORD2(buf[0].st_ino) = 1024;
        *(_DWORD *)((char *)&buf[0].st_ino + 6) = pid;
        _os_log_impl( (void *)&_mh_execute_header,  v31,  OS_LOG_TYPE_DEFAULT,  "C%p {client_pid=%d,error='Client is missing entitlement'}",  (uint8_t *)buf,  0x12u);
      }
    }

    else
    {
      int v31 = (os_log_s *)mDNSLogCategory_XPC_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_XPC_redacted, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_53;
      }
    }

    __int16 v30 = "Client is missing the entitlement";
    goto LABEL_55;
  }

  if (!xpc_dictionary_get_uint64(object, "mDNSResponderStateDump"))
  {
    uint64_t v33 = (os_log_s *)mDNSLogCategory_XPC;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_XPC == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_XPC, OS_LOG_TYPE_ERROR))
      {
        buf[0].st_dev = 134217984;
        *(void *)&buf[0].st_mode = remote_connection;
        goto LABEL_89;
      }
    }

    else
    {
      uint64_t v33 = (os_log_s *)mDNSLogCategory_XPC_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_XPC_redacted, OS_LOG_TYPE_ERROR))
      {
        buf[0].st_dev = 134217984;
        *(void *)&buf[0].st_mode = remote_connection;
LABEL_89:
        _os_log_impl( (void *)&_mh_execute_header,  v33,  OS_LOG_TYPE_ERROR,  "C%p {error='unknown log utility request from client'}",  (uint8_t *)buf,  0xCu);
      }
    }

    xpc_dictionary_set_string(v15, "ErrorDescription", "unknown log utility request from client");
    __int16 v32 = 2LL;
    goto LABEL_56;
  }

  uint64 = xpc_dictionary_get_uint64(object, "mDNSResponderStateDump");
  bzero(__str, 0x400uLL);
  if (!is_apple_internal_build_is_internal)
  {
    __int16 v30 = "State dump is only enabled in internal builds";
    goto LABEL_55;
  }

  uint64_t v21 = xpc_dictionary_dup_fd(object, "mDNSResponderDumpFD");
  v129.tv_sec = 0LL;
  *(void *)&v129.tv_usec = 0LL;
  gettimeofday(&v129, 0LL);
  KQueueLock();
  if (uint64 == 3)
  {
    dump_state_to_fd(v21);
    uint64_t v29 = 0;
    goto LABEL_243;
  }

  bzero(__s, 0x400uLL);
  uint64_t v128 = uint64;
  uint64_t v125 = v21;
  if ((snprintf(__str, 0x400uLL, "%s/%s", "/private/var/log/mDNSResponder", "mDNSResponder_state_dump")
                    - 1024) <= 0xFFFFFC00)
  {
    uint64_t v45 = mDNSLogCategory_XPC;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_XPC == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_XPC, OS_LOG_TYPE_ERROR)) {
        goto LABEL_121;
      }
    }

    else
    {
      uint64_t v45 = mDNSLogCategory_XPC_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_XPC_redacted, OS_LOG_TYPE_ERROR)) {
        goto LABEL_121;
      }
    }

    buf[0].st_dev = 67109632;
    *(_DWORD *)&buf[0].st_mode = 1024;
    LOWORD(buf[0].st_ino) = 2048;
    *(__darwin_ino64_t *)((char *)&buf[0].st_ino + 2) = 30LL;
    HIWORD(buf[0].st_uid) = 2048;
    *(void *)&buf[0].st_gid = 24LL;
    uint64_t v47 = "snprintf truncates the final string - full name buffer length: %u, directory name length: %zu, file name length: %zu";
    uint64_t v48 = (os_log_s *)v45;
    uint64_t v49 = 28;
    goto LABEL_103;
  }

  uint64_t v34 = opendir("/private/var/log/mDNSResponder");
  if (!v34)
  {
    int v46 = mDNSLogCategory_XPC;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_XPC == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_XPC, OS_LOG_TYPE_ERROR)) {
        goto LABEL_121;
      }
    }

    else
    {
      int v46 = mDNSLogCategory_XPC_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_XPC_redacted, OS_LOG_TYPE_ERROR)) {
        goto LABEL_121;
      }
    }

    uint64_t v50 = __error();
    uint64_t v51 = strerror(*v50);
    buf[0].st_dev = 136446466;
    *(void *)&buf[0].st_mode = "/private/var/log/mDNSResponder";
    WORD2(buf[0].st_ino) = 2082;
    *(__darwin_ino64_t *)((char *)&buf[0].st_ino + 6) = (__darwin_ino64_t)v51;
    uint64_t v47 = "State Dump: directory %{public}s cannot be opened, reason: %{public}s";
    uint64_t v48 = (os_log_s *)v46;
    uint64_t v49 = 22;
LABEL_103:
    _os_log_impl((void *)&_mh_execute_header, v48, OS_LOG_TYPE_ERROR, v47, (uint8_t *)buf, v49);
LABEL_121:
    v130.tv_sec = 0LL;
    *(void *)&v130.tv_usec = 0LL;
    memset(buf, 0, 56);
    memset(&v138, 0, 32);
    memset(v136, 0, sizeof(v136));
    gettimeofday(&v130, 0LL);
    localtime_r(&v130.tv_sec, (tm *)buf);
    strftime((char *)&v138, 0x20uLL, "%F_%H-%M-%S", (const tm *)buf);
    strftime((char *)v136, 0x20uLL, "%z", (const tm *)buf);
    unsigned __int16 v60 = snprintf( __str,  0x400uLL,  "%s/%s_%s-%06lu%s.txt",  "/private/var/log/mDNSResponder",  "mDNSResponder_state_dump",  (const char *)&v138,  v130.tv_usec,  (const char *)v136);
    if ((v60 - 1024) > 0xFFFFFC00)
    {
      uint64_t v61 = open(__str, 513, 420LL);
      if ((v61 & 0x80000000) == 0)
      {
        uint64_t v62 = v61;
        dump_state_to_fd(v61);
        close(v62);
        if (uint64 != 2)
        {
LABEL_144:
          uint64_t v29 = 0;
          goto LABEL_242;
        }

        memset(&v138, 0, sizeof(v138));
        bzero(buf, 0x400uLL);
        int v63 = archive_write_new();
        if (v63)
        {
          uint64_t v64 = v63;
          archive_write_add_filter_bzip2();
          archive_write_set_format_ustar(v64);
          int v65 = strlen(__str);
          int v66 = v65 + 4;
          if (v65 + 4 < 0x400)
          {
            snprintf((char *)buf, 0x400uLL, "%.*s%s", v65 - 3, __str, "tar.bz2");
            if (!archive_write_open_filename(v64, buf))
            {
              uint64_t v67 = stat(__str, &v138);
              int v68 = archive_entry_new(v67);
              if (v68)
              {
                unsigned int v69 = v68;
                int v70 = strstr(__str, "mDNSResponder_state_dump");
                if (v70) {
                  uint64_t v71 = v70;
                }
                else {
                  uint64_t v71 = "mDNSResponder_state_dump.txt";
                }
                archive_entry_copy_stat(v69, &v138);
                archive_entry_set_pathname(v69, v71);
                do
                  int v72 = archive_write_header(v64, v69);
                while (v72 == -10);
                if (!v72)
                {
                  st_size = v138.st_size;
                  uint64_t v74 = open(__str, 0);
                  if (v74 == -1) {
                    goto LABEL_230;
                  }
                  uint64_t v75 = v74;
                  __int16 v76 = mmap(0LL, st_size, 1, 2, v74, 0LL);
                  if (v76 != (void *)-1LL)
                  {
                    uint64_t v77 = v76;
                    uint64_t v127 = v64;
                    uint64_t v78 = archive_write_data(v64, v76, st_size);
                    uint64_t v79 = v78;
                    if ((v78 & 0x8000000000000000LL) == 0 && v78 == st_size)
                    {
                      munmap(v77, st_size);
                      close(v75);
                      archive_entry_free(v69);
                      archive_write_close(v127);
                      archive_write_free(v127);
                      remove(__str);
                      if (strlen((const char *)buf) <= 0x3FF)
                      {
                        uint64_t v80 = 0LL;
                        uint64 = v128;
                        while (1)
                        {
                          uint64_t v81 = *((unsigned __int8 *)&buf[0].st_dev + v80);
                          __str[v80] = v81;
                          if (!v81) {
                            goto LABEL_144;
                          }
                          if (++v80 == 1023)
                          {
                            uint64_t v29 = 0;
                            __str[1023] = 0;
                            goto LABEL_242;
                          }
                        }
                      }

_DWORD *AppendDNameListElem(void **a1, _BYTE *a2)
{
  unint64_t result = calloc(1uLL, 0x110uLL);
  if (result)
  {
    uint64_t v5 = result;
    *(void *)unint64_t result = 0LL;
    result[2] = 0;
    uint64_t v6 = a2;
    if (a2 == (_BYTE *)-256LL)
    {
LABEL_4:
      while (v6)
      {
        uint64_t v7 = *v6;
        if (!*v6)
        {
          unsigned __int16 v8 = (_WORD)v6 - (_WORD)a2 + 1;
          result += 3;
          if (v8 > 0x100u) {
            goto LABEL_10;
          }
          unint64_t result = (_DWORD *)__memcpy_chk(result, a2, v8, 260LL);
          goto LABEL_11;
        }

        v6 += v7 + 1;
        if (a2 != (_BYTE *)-256LL) {
          goto LABEL_3;
        }
      }
    }

    else
    {
LABEL_3:
      if (v6 < a2 + 256) {
        goto LABEL_4;
      }
    }

    result += 3;
LABEL_10:
    *(_BYTE *)unint64_t result = 0;
LABEL_11:
    **a1 = v5;
    *a1 = v5;
  }

  else
  {
    __break(1u);
  }

  return result;
}

void SetPrefsBrowseDomains(unsigned int *a1, uint64_t *a2, int a3)
{
  if (a3) {
    uint64_t v6 = "add";
  }
  else {
    uint64_t v6 = "remove";
  }
  do
  {
    uint64_t v7 = (os_log_s *)mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_30;
      }
      uint64_t v9 = (char *)a2 + 12;
      if (a2 == (uint64_t *)-268LL)
      {
LABEL_12:
        while (v9)
        {
          uint64_t v10 = *v9;
          if (!*v9)
          {
            unsigned __int16 v18 = (_WORD)v9 - ((_WORD)a2 + 12) + 1;
            goto LABEL_29;
          }

          v9 += v10 + 1;
        }
      }

      else
      {
LABEL_11:
        if (v9 < (_BYTE *)a2 + 268) {
          goto LABEL_12;
        }
      }

      unsigned __int16 v18 = 257;
    }

    else
    {
      uint64_t v7 = (os_log_s *)mDNSLogCategory_Default_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_30;
      }
      int v16 = (char *)a2 + 12;
      if (a2 == (uint64_t *)-268LL)
      {
LABEL_20:
        while (v16)
        {
          uint64_t v17 = *v16;
          if (!*v16)
          {
            unsigned __int16 v18 = (_WORD)v16 - ((_WORD)a2 + 12) + 1;
            goto LABEL_29;
          }

          v16 += v17 + 1;
        }
      }

      else
      {
LABEL_19:
        if (v16 < (_BYTE *)a2 + 268) {
          goto LABEL_20;
        }
      }

      unsigned __int16 v18 = 257;
    }

LABEL_29:
    int v19 = *((_DWORD *)a2 + 2);
    *(_DWORD *)buf = 141559043;
    uint64_t v30 = 1752392040LL;
    __int16 v31 = 1040;
    int v32 = v18;
    __int16 v33 = 2101;
    uint64_t v34 = (uint64_t)a2 + 12;
    __int16 v35 = 1024;
    int v36 = v19;
    __int16 v37 = 2082;
    uint64_t v38 = v6;
    _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "SetPrefsBrowseDomains is adding/removing domain for Browsing and Automatic Browsing domains - domain name: %{sensi tive, mask.hash, mdnsresponder:domain_name}.*P, uid: %u, result: %{public}s",  buf,  0x2Cu);
LABEL_30:
    size_t v20 = (char *)a2 + 12;
    if (a3)
    {
      RegisterLocalOnlyDomainEnumPTR(a1, v20, 0);
      int v21 = *((_DWORD *)a2 + 2);
      if (v21) {
        AddAutoBrowseDomain(v21, (char *)a2 + 12);
      }
      else {
        RegisterLocalOnlyDomainEnumPTR(a1, (_BYTE *)a2 + 12, 2);
      }
    }

    else
    {
      DeregisterLocalOnlyDomainEnumPTR_Internal(a1, v20, 0LL, 0LL, v12, v13, v14, v15);
      int v28 = *((_DWORD *)a2 + 2);
      if (v28) {
        RmvAutoBrowseDomain(v28, (_BYTE *)a2 + 12, v22, v23, v24, v25, v26, v27);
      }
      else {
        DeregisterLocalOnlyDomainEnumPTR_Internal(a1, (_BYTE *)a2 + 12, 2LL, 0LL, v24, v25, v26, v27);
      }
    }

    a2 = (uint64_t *)*a2;
  }

  while (a2);
}

  if (*(void *)(a1 + 240) != a2 && *(void *)(a2 + 184)) {
    dns_push_handle_question_stop((unsigned int *)a1, a2);
  }
  int v16 = (_BYTE *)(a2 + 356);
  uint64_t v22 = CacheGroupForName(a1, *(_DWORD *)(a2 + 200), (_BYTE *)(a2 + 356));
  uint64_t v23 = (uint64_t *)(a1 + 200);
  uint64_t v24 = *(_DWORD *)(a2 + 252);
  uint64_t v25 = *(void *)(a2 + 136);
  uint64_t v27 = v25 == -5 || v25 == -3 || v25 == -2;
  int v28 = (void *)(a1 + 224);
  if (!v27) {
    int v28 = (void *)(a1 + 200);
  }
  do
  {
    uint64_t v29 = v28;
    uint64_t v30 = *v28;
    int v28 = (void *)(*v28 + 8LL);
    if (v30) {
      __int16 v31 = v30 == a2;
    }
    else {
      __int16 v31 = 1;
    }
  }

  while (!v31);
  if (!v30)
  {
    int v36 = 4294901755LL;
    if ((*(_DWORD *)(a2 + 212) & 0x80000000) != 0) {
      return v36;
    }
    __int16 v37 = __rev16(*(unsigned __int16 *)(a2 + 320));
    uint64_t v38 = (os_log_s *)mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_FAULT)) {
        return v36;
      }
      uint64_t v40 = (_BYTE *)(a2 + 356);
      if (a2 == -612)
      {
LABEL_67:
        while (v40)
        {
          __int16 v41 = *v40;
          if (!*v40)
          {
            uint64_t v105 = (unsigned __int16)((_WORD)v40 - (_WORD)v16 + 1);
            goto LABEL_273;
          }

          v40 += v41 + 1;
          if (a2 != -612) {
            goto LABEL_66;
          }
        }
      }

      else
      {
LABEL_66:
      }

      uint64_t v105 = 257;
    }

    else
    {
      uint64_t v38 = (os_log_s *)mDNSLogCategory_Default_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_FAULT)) {
        return v36;
      }
      uint64_t v101 = (_BYTE *)(a2 + 356);
      if (a2 == -612)
      {
LABEL_193:
        while (v101)
        {
          uint64_t v102 = *v101;
          if (!*v101)
          {
            uint64_t v105 = (unsigned __int16)((_WORD)v101 - (_WORD)v16 + 1);
            goto LABEL_273;
          }

          v101 += v102 + 1;
          if (a2 != -612) {
            goto LABEL_192;
          }
        }
      }

      else
      {
LABEL_192:
      }

      uint64_t v105 = 257;
    }

        unsigned __int16 v8 = 0LL;
        if (!v3) {
          goto LABEL_42;
        }
        goto LABEL_41;
      }

      __int128 v11 = v4;
    }

    else
    {
      __int128 v11 = -6700;
    }

    if (_mdns_ifmon_log_s_once != -1) {
      dispatch_once(&_mdns_ifmon_log_s_once, &__block_literal_global_1442);
    }
    uint64_t v12 = (os_log_s *)_mdns_ifmon_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_ifmon_log_s_log, OS_LOG_TYPE_ERROR))
    {
      LODWORD(buf) = 134217984;
      *(void *)((char *)&buf + 4) = v11;
      _os_log_error_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_ERROR,  "Failed to create store for interface availability monitoring: %{mdns:err}ld",  (uint8_t *)&buf,  0xCu);
    }
  }

  int v21 = -6705;
  uint64_t v38 = -6705;
LABEL_30:
  int v4 = (void *)v5;
  uint64_t v5 = 0LL;
  if (a2) {
    goto LABEL_31;
  }
LABEL_32:
  if (v4) {
    os_release(v4);
  }
  return v5;
}

  dispatch_release(v4);
  return v14;
}

void udsserver_default_reg_domain_changed( uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10 = "Adding";
  if (!a2) {
    uint64_t v10 = "Removing";
  }
  LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "%s registration domain %##s",  a4,  a5,  a6,  a7,  a8,  (int)v10);
  for (uint64_t i = all_requests; i; uint64_t i = *(void *)(i + 16))
  {
    if (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, int))(i + 96) == regservice_termination_callback)
    {
      uint64_t v17 = *(void *)(i + 112);
      if (*(_BYTE *)(v17 + 1355))
      {
        int v18 = *(_DWORD *)(a1 + 8);
        if (!v18 || ((unsigned int v19 = *(_DWORD *)(i + 180), v19 >= 0x1F5) ? (v20 = v19 == v18) : (v20 = 1), v20))
        {
          int v21 = (void *)(v17 + 1624);
          uint64_t v22 = *(void *)(v17 + 1624);
          if (v22)
          {
            while (1)
            {
              int v23 = SameDomainNameBytes((_BYTE *)(v22 + 28), (_BYTE *)(a1 + 12));
              uint64_t v24 = (void *)*v21;
              if (v23) {
                break;
              }
              uint64_t v22 = *v24;
              int v21 = (void *)*v21;
              if (!*v24)
              {
                uint64_t v25 = 0LL;
                int v21 = v24;
                if (a2) {
                  goto LABEL_20;
                }
                goto LABEL_23;
              }
            }

            uint64_t v25 = (void *)*v21;
            if (a2) {
              goto LABEL_20;
            }
LABEL_23:
            if (v25)
            {
              uint64_t v26 = AutoRegistrationDomains;
              if (AutoRegistrationDomains)
              {
                while (1)
                {
                  int v27 = *(_DWORD *)(v26 + 8);
                  if (!v27 || ((unsigned int v28 = *(_DWORD *)(i + 180), v28 >= 0x1F5) ? (v29 = v28 == v27) : (v29 = 1), v29))
                  {
                  }

                  uint64_t v26 = *(void *)v26;
                  if (!v26)
                  {
                    uint64_t v25 = (void *)*v21;
                    goto LABEL_34;
                  }
                }
              }

              else
              {
LABEL_34:
                *int v21 = *v25;
                if (*((_BYTE *)v25 + 25)) {
                  SendServiceRemovalNotification((uint64_t)(v25 + 36));
                }
                v25[1] = 0LL;
                int v30 = mDNS_DeregisterService_drt( (unsigned int *)mDNSStorage,  (uint64_t)(v25 + 36),  0,  v11,  v12,  v13,  v14,  v15);
                if (v30)
                {
                  LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "udsserver_default_reg_domain_changed err %d",  v11,  v12,  v13,  v14,  v15,  v30);
                  unlink_and_free_service_instance(v25, v31, v32, v33, v34, v35, v36, v37);
                }
              }
            }

            else
            {
              LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "udsserver_default_reg_domain_changed domain %##s not found for service %#s type %s",  v11,  v12,  v13,  v14,  v15,  a1 + 12);
            }

            continue;
          }

          uint64_t v25 = 0LL;
          if (!a2) {
            goto LABEL_23;
          }
LABEL_20:
          if (!v25) {
            register_service_instance(i, (_BYTE *)(a1 + 12));
          }
        }
      }
    }
  }

void mDNSMacOSXNetworkChanged( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (dword_100158BC0)
  {
    int v8 = mDNS_TimeNow(mDNSStorage, a2, a3, a4, a5, a6, a7, a8);
    int v9 = dword_100158BC0;
    int v10 = v8 - dword_100158BC0;
  }

  else
  {
    int v9 = 0;
    int v10 = 0;
  }

  uint64_t v11 = (os_log_s *)mDNSLogCategory_State;
  if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 67109376;
    *(_DWORD *)&uint8_t buf[4] = v9;
    *(_WORD *)&buf[8] = 1024;
    *(_DWORD *)&buf[10] = v10;
    _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "*** Network Configuration Change *** -- network changed: %{mdns:yesno}d, delay: %d ticks",  buf,  0xEu);
  }

  dword_100158BC0 = 0;
  int v12 = socket(30, 2, 0);
  if (v12 < 1) {
    goto LABEL_21;
  }
  int v13 = v12;
  uint64_t IfAddrs = myGetIfAddrs();
  if (!IfAddrs)
  {
LABEL_19:
    close(v13);
    uint64_t v22 = (os_log_s *)mDNSLogCategory_State;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v22,  OS_LOG_TYPE_DEFAULT,  "*** Network Configuration Change ***  No IPv6 address TENTATIVE, will continue",  buf,  2u);
    }

LABEL_21:
    time_t v23 = time(0LL);
    int v24 = v23;
    byte_100158C47 = SystemWakeForNetworkAccess(v23, v25, v26, v27, v28, v29, v30, v31);
    byte_100158C49 = 1;
    for (uint64_t i = *(void *)mDNSStorage[0]; i; uint64_t i = *(void *)(i + 6384))
    {
      if (*(_BYTE *)(i + 6400)) {
        *(_DWORD *)(i + 6408) = v24;
      }
      *(_BYTE *)(i + 6400) = 0;
    }

    UpdateInterfaceList(v24);
    ClearInactiveInterfaces(v24);
    SetupActiveInterfaces(v24);
    int v33 = OfferSleepProxyService;
    if (OfferSleepProxyService)
    {
      *(_DWORD *)buf = -1;
      uint64_t v34 = SCDynamicStoreCreate(0LL, @"mDNSResponder:GetSystemSleepTimerSetting", 0LL, 0LL);
      if (v34)
      {
        uint64_t v35 = v34;
        uint64_t v36 = (const __CFDictionary *)SCDynamicStoreCopyValue( v34,  @"State:/IOKit/PowerManagement/CurrentSettings");
        if (v36)
        {
          uint64_t v37 = v36;
          Value = (const __CFNumber *)CFDictionaryGetValue(v36, @"System Sleep Timer");
          if (Value) {
            CFNumberGetValue(Value, kCFNumberSInt32Type, buf);
          }
          CFRelease(v37);
        }

        CFRelease(v35);
        if (*(_DWORD *)buf) {
          int v33 = 0;
        }
        else {
          int v33 = 80;
        }
      }

      else
      {
        uint64_t v39 = (os_log_s *)mDNSLogCategory_Default;
        int v40 = SCError();
        int v41 = SCErrorString(v40);
        LogMsgWithLevel( v39,  OS_LOG_TYPE_DEFAULT,  "GetSystemSleepTimerSetting: SCDynamicStoreCreate failed: %s",  v42,  v43,  v44,  v45,  v46,  v41);
        int v33 = 0;
      }
    }

    if (OfferSleepProxyService >= 100 || OfferSleepProxyService == 0 || v33 == 0) {
      unsigned __int8 v50 = v33;
    }
    else {
      unsigned __int8 v50 = OfferSleepProxyService;
    }
    mDNS_Lock_((unsigned int *)mDNSStorage, (uint64_t)"SetSPS", 5941);
    mDNSCoreBeSleepProxyServer_internal( (uint64_t)mDNSStorage,  v50,  SPMetricPortability,  SPMetricMarginalPower,  SPMetricTotalPower,  1u);
    mDNS_Unlock_((uint64_t)mDNSStorage, (uint64_t)"SetSPS", 5941);
    uint64_t v56 = *(void *)mDNSStorage[0];
    if (!*(void *)mDNSStorage[0])
    {
LABEL_79:
      uDNS_SetupDNSConfig();
      uint64_t v66 = mDNS_ConfigChanged((uint64_t)mDNSStorage);
      if (mDNS_McastTracingEnabled)
      {
        mDNS_McastTracingEnabled = 0;
        if (mDNS_LoggingEnabled == 1) {
          LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "mDNSMacOSXNetworkChanged: Multicast Tracing %s",  v69,  v70,  v71,  v72,  v73,  (int)"Disabled");
        }
        UpdateDebugState(v66, v67, v68, v69, v70, v71, v72, v73, v75);
      }

      return;
    }

    uint64_t v57 = (os_log_s **)&unk_100164000;
    while (1)
    {
      if (!*((void *)&xmmword_10015C678 + 1))
      {
        if ((*(_DWORD *)(v56 + 6436) & 0x80000000) == 0
          && !CountProxyTargets(v56, 0LL, 0LL, v51, v52, v53, v54, v55))
        {
          CloseBPF(v56, v60, v61, v51, v52, v53, v54, v55);
        }

        goto LABEL_68;
      }

      if (*(_BYTE *)(v56 + 6400)
        && *(void *)(v56 + 6480) == v56
        && *(_BYTE *)(v56 + 6375)
        && (*(_BYTE *)(v56 + 6416) & 8) == 0
        && !*(_BYTE *)(v56 + 6403)
        && *(_DWORD *)(v56 + 6436) == -1)
      {
        break;
      }

      int v4 = 1LL;
LABEL_22:
      a1 += v4;
      uint64_t v1 = *a1;
    }

    if (!v1) {
      continue;
    }
    if (v1 != 44)
    {
      if (v1 == 46) {
        return 0xFFFFFFFFLL;
      }
      goto LABEL_21;
    }

    if (a1[1])
    {
      uint64_t v1 = a1[1];
LABEL_27:
      *a1++ = 0;
    }
  }

  return v3;
}

          uint64_t v14 = (uint64_t *)*v14;
          if (!v14)
          {
            int v9 = *(uint64_t **)(v8 + 12664);
            goto LABEL_42;
          }
        }

        while (!*(_BYTE *)(v17 + 16))
        {
          uint64_t v17 = *(void *)v17;
          if (!v17) {
            goto LABEL_21;
          }
        }

    if ((unint64_t)ValueForIPv6Addr >= v24)
    {
      uint64_t v25 = 0;
      goto LABEL_30;
    }

    uint64_t v25 = 0;
    int v33 = v24 - (void)ValueForIPv6Addr;
    uint64_t v34 = ValueForIPv6Addr;
    while (1)
    {
      uint64_t v35 = *v34;
      if (v35 == 32) {
        goto LABEL_31;
      }
      ValueForIPv6Addr = v34 + 1;
      uint64_t v25 = v35 + 10 * v25 - 48;
      ++v34;
      if (!--v33)
      {
        ValueForIPv6Addr = (unsigned __int8 *)v24;
        goto LABEL_30;
      }
    }

    if (v34 != v45 || *v34) {
      break;
    }
LABEL_30:
    uint64_t v34 = ValueForIPv6Addr;
    if (!ValueForIPv6Addr) {
      goto LABEL_54;
    }
LABEL_31:
    switch(v27)
    {
      case 'a':
        uint64_t v36 = bswap32(v25);
        uint64_t v37 = a7;
        goto LABEL_45;
      case 'b':
      case 'e':
      case 'f':
      case 'g':
      case 'j':
      case 'k':
      case 'n':
      case 'o':
      case 'p':
      case 'q':
      case 'u':
      case 'v':
        goto LABEL_35;
      case 'c':
      case 'd':
      case 'h':
      case 'i':
      case 'm':
        goto LABEL_49;
      case 'l':
        int v41 = bswap32(v25) >> 16;
        uint64_t v42 = a8;
        goto LABEL_48;
      case 'r':
        int v41 = bswap32(v25) >> 16;
        uint64_t v42 = a9;
        goto LABEL_48;
      case 's':
        uint64_t v36 = bswap32(v25);
        uint64_t v37 = a6;
LABEL_45:
        CFDictionaryRef v37 = v36;
        goto LABEL_49;
      case 't':
        *a2 = v25;
        goto LABEL_49;
      case 'w':
        int v41 = bswap32(v25) >> 16;
        uint64_t v42 = a10;
LABEL_48:
        void *v42 = v41;
        goto LABEL_49;
      default:
        if (v27 == 68 || v27 == 72) {
          goto LABEL_49;
        }
LABEL_35:
        uint64_t v38 = (os_log_s *)mDNSLogCategory_Default;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
        {
          int v40 = os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT);
          uint64_t v34 = (unsigned __int8 *)v24;
          if (!v40) {
            goto LABEL_49;
          }
LABEL_52:
          *(_DWORD *)buf = 67109120;
          unsigned __int8 v50 = v27;
          _os_log_impl( (void *)&_mh_execute_header,  v38,  OS_LOG_TYPE_DEFAULT,  "mDNS_ExtractKeepaliveInfo: unknown value %c\n",  buf,  8u);
          uint64_t v34 = (unsigned __int8 *)v24;
          goto LABEL_49;
        }

        uint64_t v38 = (os_log_s *)mDNSLogCategory_Default_redacted;
        uint64_t v43 = os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT);
        uint64_t v34 = (unsigned __int8 *)v24;
        if (v43) {
          goto LABEL_52;
        }
LABEL_49:
        uint64_t v22 = v34 + 1;
        break;
    }
  }

  LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "GetValueForKeepalive: *ptr %d, ptr %p, limit %p, ptr +1 %d",  v17,  v18,  v19,  v20,  v21,  v35);
LABEL_54:
  uint64_t v44 = (os_log_s *)mDNSLogCategory_Default;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
  {
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
LABEL_60:
      _os_log_impl( (void *)&_mh_execute_header,  v44,  OS_LOG_TYPE_DEFAULT,  "mDNS_ExtractKeepaliveInfo: Cannot parse\n",  buf,  2u);
    }
  }

  else
  {
    uint64_t v44 = (os_log_s *)mDNSLogCategory_Default_redacted;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      goto LABEL_60;
    }
  }

        uint64_t v2 = *(void *)(v2 + 16);
      }

      while (v2);
    }
  }

  if (v9) {
    freeifaddrs(v9);
  }
}

      *(void *)(v1 + 72) = 0LL;
      goto LABEL_22;
    }
  }

  return _mdns_querier_initiate_send(v1);
}

    int v41 = v21;
  }

  if (!v21)
  {
LABEL_62:
    if (mDNS_LoggingEnabled != 1) {
      return;
    }
    uint64_t v35 = (os_log_s *)mDNSLogCategory_Default;
    uint64_t v36 = "handleLNTDeviceDescriptionResponse: didn't find WANIPConnection:1 or WANPPPConnection:1 string";
    goto LABEL_64;
  }

  int v13 = _os_object_alloc(&OBJC_CLASS___OS_mdns_message, 56LL);
  uint64_t v14 = (_BYTE *)v13;
  if (v13)
  {
    uint64_t v15 = &_mdns_message_kind;
    *(void *)(v13 + 16) = &_mdns_message_kind;
    do
    {
      uint64_t v16 = (void (*)(_BYTE *))v15[2];
      if (v16) {
        v16(v14);
      }
      uint64_t v15 = (_UNKNOWN **)*v15;
    }

    while (v15);
LABEL_26:
    if ((a2 & 1) != 0) {
      v14[48] = 1;
    }
    if (_mdns_message_set_msg_data(v14, v4))
    {
      os_release(v14);
LABEL_79:
      uint64_t v14 = 0LL;
    }
  }

            ++v13;
          }

          goto LABEL_21;
        }

        return 0LL;
      }
    }
  }

  return result;
}

uint64_t mDNSSameAddress(int *a1, _DWORD *a2)
{
  int v2 = *a1;
  if (*a1 == *a2)
  {
    switch(v2)
    {
      case 0:
        return 1LL;
      case 6:
        if (a1[1] == a2[1] && a1[2] == a2[2] && a1[3] == a2[3])
        {
          int v3 = a1[4];
          int v4 = a2[4];
          return v3 == v4;
        }

        break;
      case 4:
        int v3 = a1[1];
        int v4 = a2[1];
        return v3 == v4;
    }
  }

  return 0LL;
}

void ClearInactiveInterfaces(int a1)
{
  uint64_t v1 = *(void *)mDNSStorage[0];
  if (!*(void *)mDNSStorage[0]) {
    return;
  }
  int v2 = a1;
  int v3 = &unk_100164000;
  do
  {
    uint64_t v4 = SearchForInterfaceByName((char *)(v1 + 6310), 0);
    uint64_t v5 = *(void *)(v1 + 6480);
    if (!v5) {
      goto LABEL_113;
    }
    uint64_t v6 = v4;
    BOOL v8 = (*(_BYTE *)(v1 + 6416) & 8) == 0 && v2 - *(_DWORD *)(v1 + 6404) < 60;
    *(_BYTE *)(v1 + 6401) = v8;
    int v9 = (os_log_s *)*((void *)v3 + 171);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      int v10 = *(_DWORD *)(v1 + 6424);
      uint64_t v11 = *(void *)(v1 + 6256);
      int v12 = CountMaskBits((int *)(v1 + 6284));
      int v13 = *(unsigned __int8 *)(v1 + 6402);
      int v14 = *(unsigned __int8 *)(v1 + 16);
      *(_DWORD *)buf = 136449795;
      *(void *)uint64_t v74 = v1 + 6310;
      *(_WORD *)&v74[8] = 1024;
      *(_DWORD *)&v74[10] = v10;
      int v3 = &unk_100164000;
      *(_WORD *)&v74[14] = 2160;
      *(void *)&v74[16] = 1752392040LL;
      __int16 v75 = 1045;
      *(_DWORD *)__int16 v76 = 6;
      *(_WORD *)&v76[4] = 2101;
      *(void *)&v76[6] = v1 + 6428;
      __int16 v77 = 2048;
      uint64_t v78 = v11;
      int v2 = a1;
      __int16 v79 = 2048;
      uint64_t v80 = v1;
      __int16 v81 = 2048;
      uint64_t v82 = v6;
      __int16 v83 = 2160;
      *(void *)__int128 v84 = 1752392040LL;
      *(_WORD *)&v84[8] = 1045;
      *(_DWORD *)&v84[10] = 20;
      __int16 v85 = 2101;
      *(void *)__int128 v86 = v1 + 6264;
      *(_WORD *)&v86[8] = 1024;
      *(_DWORD *)__int128 v87 = v12;
      *(_WORD *)&v87[4] = 1024;
      BOOL v88 = v8;
      __int16 v89 = 1024;
      int v90 = v13;
      __int16 v91 = 1024;
      int v92 = v14;
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEFAULT,  "ClearInactiveInterfaces: Deregistering %{public}s(%u) %{sensitive, mask.hash, mdnsresponder:mac_addr}.6P Interfa ceID %p(%p), primary %p, %{sensitive, mask.hash, mdnsresponder:ip_addr}.20P/%d -- flashing: %{mdns:yesno}d, occu lting: %{mdns:yesno}d, primary: %{mdns:yesno}d",  buf,  0x7Cu);
    }

    if (!strncmp((const char *)(v1 + 6310), "p2p", 3uLL) || *(_BYTE *)(v1 + 6380))
    {
      uint64_t v15 = (os_log_s *)*((void *)v3 + 171);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)uint64_t v74 = v1 + 6310;
        _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_DEFAULT,  "ClearInactiveInterfaces: %{public}s DirectLink interface deregistering",  buf,  0xCu);
      }
    }

    mDNS_Lock_((unsigned int *)mDNSStorage, (uint64_t)"mDNS_DeregisterInterface", 17118);
    uint64_t v16 = (uint64_t *)((char *)mDNSStorage + &unk_100003178);
    do
    {
      uint64_t v17 = (void **)v16;
      uint64_t v16 = (void *)*v16;
      if (v16) {
        BOOL v18 = v16 == (void *)v1;
      }
      else {
        BOOL v18 = 1;
      }
    }

    while (!v18);
    if (!v16)
    {
      time_t v23 = (os_log_s *)mDNSLogCategory_mDNS;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == *((void *)v3 + 171))
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEBUG))
        {
LABEL_57:
          int v30 = 17125;
          goto LABEL_112;
        }
      }

      else
      {
        time_t v23 = (os_log_s *)mDNSLogCategory_mDNS_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEBUG)) {
          goto LABEL_57;
        }
      }

      *(_WORD *)buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v23,  OS_LOG_TYPE_DEBUG,  "NetworkInterfaceInfo not found in list",  buf,  2u);
      goto LABEL_57;
    }

    mDNS_DeactivateNetWake_internal((__int128 *)v1);
    void *v17 = (void *)**v17;
    *(void *)uint64_t v1 = 0LL;
    if (!*(_BYTE *)(v1 + 16))
    {
      for (uint64_t i = xmmword_10015BD30; i; uint64_t i = *(void *)i)
      {
        if (*(_BYTE *)(i + 16) && *(void *)(i + 6256) == *(void *)(v1 + 6256)) {
          UpdateInterfaceProtocols(i);
        }
      }

      goto LABEL_47;
    }

    uint64_t v19 = *(void *)(v1 + 6256);
    BOOL v20 = &xmmword_10015BD30;
    do
    {
      BOOL v20 = *(__int128 **)v20;
      if (!v20)
      {
        uint64_t v27 = (os_log_s *)mDNSLogCategory_mDNS;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == *((void *)v3 + 171))
        {
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_60;
          }
        }

        else
        {
          uint64_t v27 = (os_log_s *)mDNSLogCategory_mDNS_redacted;
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
          {
LABEL_60:
            ++dword_10015D988;
            uint64_t v32 = *(void **)(v1 + 6256);
            if (DPCFeatureEnabled_sOnce != -1) {
              dispatch_once(&DPCFeatureEnabled_sOnce, &__block_literal_global_3237);
            }
            if (DPCFeatureEnabled_sEnabled) {
              _DPCRemovePushServer(v32);
            }
            uint64_t v33 = qword_100158C80;
            if (!qword_100158C80)
            {
LABEL_72:
              for (uint64_t j = 0LL; j != 499; ++j)
              {
                for (k = (void *)mDNSStorage[j + 35]; k; k = (void *)*k)
                {
                  for (m = (void *)k[2]; m; m = (void *)*m)
                  {
                    if (m[4] == *(void *)(v1 + 6256)) {
                      mDNS_PurgeCacheResourceRecord((unsigned int *)mDNSStorage, (uint64_t)m);
                    }
                  }
                }
              }

              int v26 = 0;
              int v3 = &unk_100164000;
              goto LABEL_97;
            }

            while (1)
            {
              if (!*(_WORD *)(v33 + 320))
              {
                uint64_t v34 = *(void *)(v33 + 136);
                uint64_t v35 = *(void *)(v1 + 6256);
                if (v34 == v35)
                {
                  *(_DWORD *)(v33 + 212) = 0;
LABEL_70:
                  uint64_t v36 = *(void *)(v33 + 16);
                  *(void *)(v33 + 16) = v35;
                  *(void *)(v33 + 24) = v36;
                  goto LABEL_71;
                }

                if (!v34) {
                  goto LABEL_70;
                }
              }

LABEL_71:
              uint64_t v33 = *(void *)(v33 + 8);
              if (!v33) {
                goto LABEL_72;
              }
            }
          }
        }

        *(_DWORD *)buf = 67110147;
        *(_DWORD *)uint64_t v74 = v19;
        *(_WORD *)&v74[4] = 2082;
        *(void *)&v74[6] = v1 + 6310;
        *(_WORD *)&v74[14] = 2160;
        *(void *)&v74[16] = 1752392040LL;
        __int16 v75 = 1045;
        *(_DWORD *)__int16 v76 = 20;
        *(_WORD *)&v76[4] = 2101;
        *(void *)&v76[6] = v1 + 6264;
        _os_log_impl( (void *)&_mh_execute_header,  v27,  OS_LOG_TYPE_DEFAULT,  "Last representative of InterfaceID deregistered; marking questions etc. dormant - ifid: %d, ifname: %{public}s"
          ", ifaddr: %{sensitive, mask.hash, mdnsresponder:ip_addr}.20P",
          buf,
          0x2Cu);
        goto LABEL_60;
      }
    }

    while (*((void *)v20 + 782) != v19);
    __int128 v21 = (os_log_s *)mDNSLogCategory_mDNS;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == *((void *)v3 + 171))
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_82;
      }
    }

    else
    {
      __int128 v21 = (os_log_s *)mDNSLogCategory_mDNS_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
      {
LABEL_82:
        *(_DWORD *)buf = 67110147;
        *(_DWORD *)uint64_t v74 = v19;
        *(_WORD *)&v74[4] = 2082;
        *(void *)&v74[6] = v1 + 6310;
        *(_WORD *)&v74[14] = 2160;
        *(void *)&v74[16] = 1752392040LL;
        __int16 v75 = 1045;
        *(_DWORD *)__int16 v76 = 20;
        *(_WORD *)&v76[4] = 2101;
        *(void *)&v76[6] = v1 + 6264;
        _os_log_impl( (void *)&_mh_execute_header,  v21,  OS_LOG_TYPE_DEFAULT,  "Another representative of InterfaceID exists - ifid: %d, ifname: %{public}s, ifaddr: %{sensitive, mask.hash, m dnsresponder:ip_addr}.20P",  buf,  0x2Cu);
      }
    }

    if (*((_BYTE *)v20 + 16))
    {
      int v41 = (os_log_s *)mDNSLogCategory_mDNS;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == *((void *)v3 + 171))
      {
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_ERROR)) {
          goto LABEL_89;
        }
      }

      else
      {
        int v41 = (os_log_s *)mDNSLogCategory_mDNS_redacted;
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_ERROR))
        {
LABEL_89:
          *(_DWORD *)buf = 136446979;
          *(void *)uint64_t v74 = v1 + 6310;
          *(_WORD *)&v74[8] = 2160;
          *(void *)&v74[10] = 1752392040LL;
          *(_WORD *)&v74[18] = 1045;
          *(_DWORD *)&v74[20] = 20;
          __int16 v75 = 2101;
          *(void *)__int16 v76 = v1 + 6264;
          _os_log_impl( (void *)&_mh_execute_header,  v41,  OS_LOG_TYPE_ERROR,  "intf->InterfaceActive already set for interface - ifname: %{public}s, ifaddr: %{sensitive, mask.hash, mdnsre sponder:ip_addr}.20P",  buf,  0x26u);
        }
      }
    }

    *((_BYTE *)v20 + 16) = 1;
    UpdateInterfaceProtocols((uint64_t)v20);
    if (*((_BYTE *)v20 + 6376)) {
      mDNS_ActivateNetWake_internal((uint64_t)v20);
    }
    uint64_t v42 = (uint64_t *)xmmword_10015BD30;
    if ((void)xmmword_10015BD30)
    {
      while (v42[782] != *(void *)(v1 + 6256) || *((_DWORD *)v42 + 1566) != *(_DWORD *)(v1 + 6264))
      {
        uint64_t v42 = (uint64_t *)*v42;
        if (!v42) {
          goto LABEL_96;
        }
      }

  if (a3 != -65792 && !v12)
  {
    int v14 = mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
        return;
      }
      *(_DWORD *)buf = 67109120;
      uint64_t v94 = a3;
      uint64_t v16 = "regservice_callback: instance->request is NULL %d";
    }

    else
    {
      int v14 = mDNSLogCategory_Default_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
        return;
      }
      *(_DWORD *)buf = 67109120;
      uint64_t v94 = a3;
      uint64_t v16 = "regservice_callback: instance->request is NULL %d";
    }

    goto LABEL_100;
  }

  if (a3 == -65792)
  {
    if (v12 && *(_BYTE *)(v10 + 24))
    {
      external_stop_advertising_helper(v10, a2, v12, a4, a5, a6, a7, a8);
      *(_BYTE *)(v10 + 24) = 0;
      uint64_t v45 = mDNS_RenameAndReregisterService( (unsigned int *)a1,  a2,  (const char *)(*(void *)(*(void *)(v10 + 8) + 112LL) + 26LL));
      if (!v45) {
        return;
      }
      uint64_t v46 = v45;
      uint64_t v47 = mDNSLogCategory_Default;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
          return;
        }
      }

      else
      {
        uint64_t v47 = mDNSLogCategory_Default_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
          return;
        }
      }

      int v69 = *(_DWORD *)(*(void *)(v10 + 8) + 184LL);
      *(_DWORD *)buf = 67109376;
      uint64_t v94 = v69;
      uint64_t v95 = 1024;
      LODWORD(v96) = v46;
      uint64_t v16 = "[R%u] ERROR: regservice_callback - RenameAndReregisterService returned %d";
      int v43 = (os_log_s *)v47;
      uint64_t v44 = 14;
      goto LABEL_101;
    }

    goto LABEL_220;
  }

  if (a3 != -65548)
  {
    if (a3)
    {
      if (!v13) {
        return;
      }
      if (!GenerateNTDResponse( *(char **)(a2 + 2448),  *(void *)(a2 + 2440),  v12,  (char **)&v92,  (char *)0x41,  2u,  a3))
      {
        append_reply(*(void *)(v10 + 8), v92);
        *(_BYTE *)(v10 + 25) = 1;
        return;
      }

      int v49 = mDNSLogCategory_Default;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
          return;
        }
        int v50 = *(_DWORD *)(*(void *)(v10 + 8) + 184LL);
        uint64_t v51 = *(unsigned __int8 **)(a2 + 2448);
        if (v51)
        {
          uint64_t v67 = *(unsigned __int8 **)(a2 + 2448);
          if (v51 == (unsigned __int8 *)-256LL)
          {
LABEL_157:
            while (v67)
            {
              int v68 = *v67;
              if (!*v67)
              {
                uint64_t v73 = (unsigned __int16)((_WORD)v67 - (_WORD)v51 + 1);
                goto LABEL_212;
              }

              v67 += v68 + 1;
            }
          }

          else
          {
LABEL_156:
            if (v67 < v51 + 256) {
              goto LABEL_157;
            }
          }

          uint64_t v73 = 257;
        }

        else
        {
          uint64_t v73 = 0;
        }
      }

      else
      {
        int v49 = mDNSLogCategory_Default_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
          return;
        }
        int v50 = *(_DWORD *)(*(void *)(v10 + 8) + 184LL);
        uint64_t v51 = *(unsigned __int8 **)(a2 + 2448);
        if (v51)
        {
          BOOL v52 = *(unsigned __int8 **)(a2 + 2448);
          if (v51 == (unsigned __int8 *)-256LL)
          {
LABEL_124:
            while (v52)
            {
              uint64_t v53 = *v52;
              if (!*v52)
              {
                uint64_t v73 = (unsigned __int16)((_WORD)v52 - (_WORD)v51 + 1);
                goto LABEL_212;
              }

              v52 += v53 + 1;
            }
          }

          else
          {
LABEL_123:
            if (v52 < v51 + 256) {
              goto LABEL_124;
            }
          }

          uint64_t v73 = 257;
        }

        else
        {
          uint64_t v73 = 0;
        }
      }

    _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, v28, buf, v35);
    return v19;
  }

  for (uint64_t i = *(void *)mDNSStorage; i; uint64_t i = *(void *)(i + 6384))
  {
    if (*(void *)(i + 6480) && *(_DWORD *)(i + 6424) == (_DWORD)a4) {
      break;
    }
  }

  if (*a2 == 4)
  {
    if (i)
    {
      uint64_t v15 = *(_DWORD *)(a1 + 16);
      uint64_t v16 = (const void *)(i + 6424);
      uint64_t v17 = 0;
      BOOL v18 = 25;
LABEL_29:
      setsockopt(v15, v17, v18, v16, 4u);
      goto LABEL_30;
    }

    int v26 = mDNSLogCategory_NAT;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_NAT == mDNSLogCategory_State)
    {
      uint64_t v19 = 4294901756LL;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT, OS_LOG_TYPE_DEFAULT)) {
        return v19;
      }
      *(_DWORD *)buf = 134217984;
      *(void *)uint64_t v44 = a4;
      uint64_t v28 = "mDNSPlatformTCPConnect: Invalid interface index %p";
      goto LABEL_70;
    }

    int v26 = mDNSLogCategory_NAT_redacted;
    uint64_t v36 = os_log_type_enabled((os_log_t)mDNSLogCategory_NAT_redacted, OS_LOG_TYPE_DEFAULT);
    uint64_t v19 = 4294901756LL;
    if (v36)
    {
      *(_DWORD *)buf = 134217984;
      *(void *)uint64_t v44 = a4;
      uint64_t v28 = "mDNSPlatformTCPConnect: Invalid interface index %p";
LABEL_70:
      uint64_t v34 = (os_log_s *)v26;
      uint64_t v35 = 12;
      goto LABEL_71;
    }
  }

  else
  {
    if (i)
    {
      uint64_t v15 = *(_DWORD *)(a1 + 16);
      uint64_t v16 = (const void *)(i + 6424);
      uint64_t v17 = 41;
      BOOL v18 = 125;
      goto LABEL_29;
    }

    int v26 = mDNSLogCategory_NAT;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_NAT == mDNSLogCategory_State)
    {
      uint64_t v19 = 4294901756LL;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT, OS_LOG_TYPE_DEFAULT)) {
        return v19;
      }
      *(_DWORD *)buf = 134217984;
      *(void *)uint64_t v44 = a4;
      uint64_t v28 = "mDNSPlatformTCPConnect: Invalid interface index %p";
      goto LABEL_70;
    }

    int v26 = mDNSLogCategory_NAT_redacted;
    uint64_t v37 = os_log_type_enabled((os_log_t)mDNSLogCategory_NAT_redacted, OS_LOG_TYPE_DEFAULT);
    uint64_t v19 = 4294901756LL;
    if (v37)
    {
      *(_DWORD *)buf = 134217984;
      *(void *)uint64_t v44 = a4;
      uint64_t v28 = "mDNSPlatformTCPConnect: Invalid interface index %p";
      goto LABEL_70;
    }
  }

  return v19;
}

                int v50 = v31;
                uint64_t v51 = mDNS_DomainNameFNV1aHash(v17);
                BOOL v52 = bswap32(*(unsigned __int16 *)(v11[343] + 8LL)) >> 16;
                uint64_t v54 = *(_DWORD *)(a1 + 232);
                uint64_t v53 = *(_DWORD *)(a1 + 236);
                int v92 = *(_DWORD *)(a1 + 172);
                if (*v17) {
                  uint64_t v55 = &v18[*v17];
                }
                else {
                  uint64_t v55 = v17;
                }
                uint64_t v56 = mDNS_DomainNameFNV1aHash(v55);
                *(void *)__tp = 0LL;
                *(void *)&__tp[8] = 0LL;
                clock_gettime(_CLOCK_MONOTONIC_RAW, (timespec *)__tp);
                uint64_t v57 = *(_DWORD *)__tp - *(_DWORD *)(a1 + 188);
                *(_DWORD *)__tp = 67111939;
                *(_DWORD *)&__tp[4] = v94;
                *(_WORD *)&__tp[8] = 2160;
                *(void *)&__tp[10] = 1752392040LL;
                *(_WORD *)&__tp[18] = 1040;
                uint64_t v103 = v50;
                uint64_t v104 = 2101;
                uint64_t v105 = v17;
                uint64_t v106 = 1024;
                uint64_t v107 = v51;
                int v10 = v99;
                int v14 = v100;
                int v108 = 1024;
                CFMutableArrayRef v109 = v52;
                CFStringRef v110 = 1024;
                CFStringRef v111 = v54;
                int v13 = v97;
                int v12 = v98;
                uint64_t v112 = 1024;
                uint64_t v113 = v53;
                uint64_t v15 = (_BYTE *)&unk_100164000;
                uint64_t v114 = 1024;
                uint64_t v115 = v92;
                uint64_t v116 = 2082;
                uint64_t v117 = v100;
                uint64_t v118 = 1024;
                uint64_t v119 = v56;
                unsigned int v120 = 1024;
                uint64_t v121 = v57;
                int v43 = (os_log_s *)v22;
                uint64_t v44 = "[R%u] DNSServiceRegister STOP -- SRV name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P ("
                      "%x), port: %u, flags: 0x%X, interface index: %d, client pid: %d (%{public}s), name hash: %x, durat"
                      "ion: %{mdns:time_duration}u";
LABEL_80:
                uint64_t v45 = 86;
                goto LABEL_87;
              }
            }

            else if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
            {
              unsigned int v96 = *(_DWORD *)(a1 + 184);
              uint64_t v38 = v17;
LABEL_40:
              uint64_t v39 = 257;
              if (v38 < v17 + 256 && v38)
              {
                while (1)
                {
                  int v40 = *v38;
                  if (v40 > 0x3F)
                  {
LABEL_69:
                    uint64_t v39 = 257;
                    goto LABEL_76;
                  }

                  if (!*v38) {
                    break;
                  }
                  v38 += v40 + 1;
LABEL_43:
                  if (!v38) {
                    goto LABEL_69;
                  }
                }

                uint64_t v39 = (_WORD)v38 - (_WORD)v17 + 1;
              }

      uint64_t v47 = DNSTypeName(a3);
      *(_DWORD *)buf = 136317698;
      uint64_t v48 = "*";
      *(void *)uint64_t v56 = v43;
      *(void *)&v56[10] = " (pending)";
      *(_WORD *)&v56[18] = 1042;
      *(_WORD *)&v56[8] = 2080;
      if ((a4 & 0x10) == 0) {
        uint64_t v48 = "";
      }
      uint64_t v57 = 20;
      uint64_t v58 = 2098;
      uint64_t v59 = a5;
      int v60 = 1024;
      uint64_t v61 = a6;
      int v62 = 1040;
      int v63 = v45;
      uint64_t v64 = 2098;
      int v65 = a1;
      int v66 = 2082;
      uint64_t v67 = v47;
      int v68 = 1024;
      int v69 = a2;
      uint64_t v70 = 1024;
      int v71 = a4;
      uint64_t v72 = 2080;
      uint64_t v73 = v48;
      _os_log_debug_impl( (void *)&_mh_execute_header,  v42,  OS_LOG_TYPE_DEBUG,  "unicast assist record %s%s - %{public, mdnsresponder:ip_addr}.20P %2.2d %{public, mdnsresponder:domain_name}.*P %{public}s qhash %x rectype 0x%X%s",  buf,  0x5Cu);
    }
  }

    if (mDNS_LoggingEnabled != 1) {
      goto LABEL_74;
    }
    uint64_t v37 = (os_log_s *)mDNSLogCategory_Default;
    int v40 = v30;
    uint64_t v38 = "handleLNTDeviceDescriptionResponse: SOAP address string [%s]";
LABEL_73:
    LogMsgWithLevel(v37, OS_LOG_TYPE_DEFAULT, v38, v15, v16, v17, v18, v19, v40);
LABEL_74:
    uint64_t v39 = *v27;
    if (*v27
      || (AllocAndCopy((void *)(v9 + 14984), *(char **)(v9 + 14968), v29, v15, v16, v17, v18, v19, v40),
          (uint64_t v39 = *(void *)(v9 + 14984)) != 0))
    {
      if (mDNS_LoggingEnabled == 1) {
        LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "handleLNTDeviceDescriptionResponse: SOAP URL [%s]",  v15,  v16,  v17,  v18,  v19,  v39);
      }
      return;
    }

    uint64_t v35 = (os_log_s *)mDNSLogCategory_Default;
    uint64_t v36 = "handleLNTDeviceDescriptionResponse: UPnPSOAPURL is NULL";
LABEL_64:
    LogMsgWithLevel(v35, OS_LOG_TYPE_DEFAULT, v36, v15, v16, v17, v18, v19, a9);
  }

LABEL_47:
      int v26 = 0;
    }

    else
    {
LABEL_96:
      int v26 = 1;
    }

    for (uint64_t j = v11[1578]; j; uint64_t j = *(void *)j)
    {
      int v26 = *(unsigned __int16 *)(j + 12);
      if (v26 == 28 || v26 == 1)
      {
        unint64_t result = ResourceRecordIsValidInterfaceAnswer(j, a4, (uint64_t)a3, a4, a5, a6, a7, a8);
        if ((_DWORD)result)
        {
          if (*(_DWORD *)(v10 + 24) == *(_DWORD *)(j + 24))
          {
            unint64_t result = SameDomainNameBytes(*(_BYTE **)(v10 + 40), *(_BYTE **)(j + 40));
            if ((_DWORD)result)
            {
              if (!*(void *)(j + 256) && *a3 != (uint64_t *)(j + 256))
              {
                **a3 = j;
                uint64_t v28 = *(void *)(v10 + 272);
                if (!v28) {
                  uint64_t v28 = v10;
                }
                *(void *)(j + 272) = v28;
                *a3 = (uint64_t *)(j + 256);
              }
            }
          }
        }
      }
    }

    goto LABEL_62;
  }

  return result;
}

          *(_BYTE *)(v8 + 102) = *(_BYTE *)(v8 + 102) & 0xFD | (2 * (*(_BYTE *)(a1 + 244) == 1));
          uint64_t v35 = *(unsigned __int16 *)(*(void *)(v8 + 24) + 52LL);
          if (a2)
          {
            if (!a7)
            {
              uint64_t v36 = *(void *)(a1 + 184);
              if (v36)
              {
                if (v35 == 28 || v35 == 1)
                {
                  LODWORD(string) = 0;
                  uint64_t v37 = v35 == 1
                  *(void *)(v8 + 64) = v37;
                  if (!v37)
                  {
                    if (_mdns_server_log_s_once != -1) {
                      dispatch_once(&_mdns_server_log_s_once, &__block_literal_global_16);
                    }
                    uint64_t v38 = (os_log_s *)_mdns_server_log_s_log;
                    if (os_log_type_enabled((os_log_t)_mdns_server_log_s_log, OS_LOG_TYPE_ERROR))
                    {
                      uint64_t v48 = *(_DWORD *)(a1 + 48);
                      if (v35 == 1) {
                        int v49 = 4;
                      }
                      else {
                        int v49 = 6;
                      }
                      *(_DWORD *)buf = 67109632;
                      *(_DWORD *)&uint8_t buf[4] = v48;
                      uint64_t v54 = 1024;
                      uint64_t v55 = v49;
                      uint64_t v56 = 2048;
                      uint64_t v57 = (int)string;
                      _os_log_error_impl( (void *)&_mh_execute_header,  v38,  OS_LOG_TYPE_ERROR,  "[R%u] Failed to create IPv%d signed hostname result: %{mdns:err}ld",  buf,  0x18u);
                    }
                  }
                }
              }
            }
          }

          if (&_NEHelperTrackerGetAppInfo)
          {
            uint64_t v39 = 1;
            if (!a2) {
              goto LABEL_74;
            }
          }

          else
          {
            uint64_t v39 = _os_feature_enabled_impl("symptomsd", "networking_transparency");
            if (!a2) {
              goto LABEL_74;
            }
          }

          if (!v39
            || (string = 0LL,
                *(void *)buf = 0LL,
                uint64_t v51 = 0,
                resolved_cache_get_tracker_state(a8, buf, &string, (BOOL *)&v51 + 1, &v51) != 2)
            || !*(void *)buf)
          {
LABEL_74:
            uint64_t v42 = *(_BYTE *)(a1 + 242);
            if ((v42 & 0x10) == 0 || (v12 & 1) != 0) {
              goto LABEL_90;
            }
            if (v35 == 28)
            {
              uint64_t v46 = (void *)(a1 + 200);
              uint64_t v45 = *(void *)(a1 + 200);
              if (!v45) {
                goto LABEL_88;
              }
              _dx_gai_request_append_result((os_unfair_lock_s *)a1, v45);
              uint64_t v47 = *(char **)(a1 + 200);
              if (!v47) {
                goto LABEL_88;
              }
            }

            else
            {
              if (v35 != 1)
              {
LABEL_90:
                _dx_gai_request_append_result((os_unfair_lock_s *)a1, v8);
LABEL_91:
                _dx_release((char *)v8);
                return;
              }

              if (*(_DWORD *)(v8 + 84) == 3)
              {
                do
                  int v43 = __ldaxr(v9);
                while (__stlxr(v43 + 1, v9));
                uint64_t v44 = *(char **)(a1 + 200);
                if (v44) {
                  _dx_release(v44);
                }
                *(void *)(a1 + 200) = v8;
                goto LABEL_91;
              }

              uint64_t v46 = (void *)(a1 + 200);
              uint64_t v47 = *(char **)(a1 + 200);
              if (!v47)
              {
LABEL_89:
                *(_BYTE *)(a1 + 242) = v42 & 0xEF;
                goto LABEL_90;
              }
            }

            _dx_release(v47);
            *uint64_t v46 = 0LL;
LABEL_88:
            uint64_t v42 = *(_BYTE *)(a1 + 242);
            goto LABEL_89;
          }

          mdns_xpc_string_recreate((xpc_object_t *)(a1 + 120), *(char **)buf);
          int v40 = *(void **)(a1 + 120);
          if (v40)
          {
            *(void *)(v8 + 48) = v40;
            xpc_retain(v40);
            if (!string)
            {
LABEL_70:
              if (HIBYTE(v51)) {
                *(_BYTE *)(v8 + 102) |= 1u;
              }
              if ((_BYTE)v51) {
                *(_BYTE *)(v8 + 102) |= 4u;
              }
              goto LABEL_74;
            }

            mdns_xpc_string_recreate((xpc_object_t *)(a1 + 128), string);
            int v41 = *(void **)(a1 + 128);
            if (v41)
            {
              *(void *)(v8 + 56) = v41;
              xpc_retain(v41);
              goto LABEL_70;
            }
          }

        v135 = 0u;
        uint64_t v134 = 0u;
        unsigned __int16 v133 = 0u;
        int v132 = 0u;
        unsigned int v131 = 0u;
        int v130 = 0u;
        uint64_t v129 = 0u;
        uint64_t v128 = 0u;
        uint64_t v127 = 0u;
        uint64_t v126 = 0u;
        uint64_t v125 = 0u;
        uint64_t v124 = 0u;
        BOOL v123 = 0u;
        int v122 = 0u;
        uint64_t v121 = 0u;
        unsigned int v120 = 0u;
        memset(v119, 0, sizeof(v119));
        memset(&v98, 0, sizeof(v98));
        v98.ai_flags = 4;
        uint64_t v97 = 0LL;
        if (getaddrinfo(i, 0LL, &v98, &v97))
        {
          if (v7[2840] == 1) {
            LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "mDNSMacOSXParseEtcHostsLine: getaddrinfo returning null",  v28,  v29,  v30,  v31,  v32,  v94);
          }
        }

        else
        {
          if (v27)
          {
            uint64_t v95 = (char *)&i[v27];
            else {
              LODWORD(v24) = v17;
            }
            uint64_t v33 = v27 + 1;
            while (1)
            {
              uint64_t v34 = v33;
              uint64_t v35 = i[v33++];
              ++v27;
              uint64_t v36 = v35 > 0x2C;
              uint64_t v37 = (1LL << v35) & 0x100100000200LL;
              if (!v36 && v37 != 0)
              {
                i[v34] = 0;
                LODWORD(v24) = v27;
                break;
              }
            }
          }

          else
          {
            uint64_t v95 = 0LL;
          }

          uint64_t v100 = 0LL;
          int v99 = 0LL;
          uint64_t v39 = EtcHostsParseOneName((v24 + 1), v17, (uint64_t)i, &v100);
          if (v39 == (_DWORD)v17)
          {
            uint64_t v46 = (int)v100;
            LOBYTE(v1memset(v45, 0, 20) = 0;
            if (AppendDNSNameString(&v120, v100, v40, v41, v42, v43, v44, v45)) {
              mDNSMacOSXCreateEtcHostsEntry(&v120, (uint64_t)v97->ai_addr, 0LL, v95, (uint64_t)v96, v49, v50, v51);
            }
            else {
              LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "mDNSMacOSXParseEtcHostsLine: ERROR!! cannot convert to domain name %s",  v47,  v48,  v49,  v50,  v51,  v46);
            }
            goto LABEL_83;
          }

          BOOL v52 = v39;
          if (v39 == -1) {
            goto LABEL_83;
          }
          uint64_t v117 = 0u;
          memset(v118, 0, sizeof(v118));
          uint64_t v115 = 0u;
          uint64_t v116 = 0u;
          uint64_t v113 = 0u;
          uint64_t v114 = 0u;
          CFStringRef v111 = 0u;
          uint64_t v112 = 0u;
          CFMutableArrayRef v109 = 0u;
          CFStringRef v110 = 0u;
          uint64_t v107 = 0u;
          int v108 = 0u;
          uint64_t v105 = 0u;
          uint64_t v106 = 0u;
          uint64_t v104 = 0u;
          uint64_t v53 = (int)v100;
          uint64_t v103 = 0;
          if (AppendDNSNameString(&v103, v100, v40, v41, v42, v43, v44, v45))
          {
            mDNSMacOSXCreateEtcHostsEntry(&v103, (uint64_t)v97->ai_addr, 0LL, v95, (uint64_t)v96, v56, v57, v58);
            uint64_t v59 = 0;
            while (1)
            {
              BOOL v52 = EtcHostsParseOneName((v52 + 1), v17, (uint64_t)i, &v99);
              uint64_t v53 = (int)v99;
              if (!v99) {
                break;
              }
              v119[0] = 0;
              if (!AppendDNSNameString(v119, v99, v60, v61, v62, v63, v64, v65)) {
                goto LABEL_84;
              }
              if (SameDomainNameBytes(&v103, v119))
              {
                if (mDNS_LoggingEnabled == 1) {
                  LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "mDNSMacOSXParseEtcHostsLine: Ignoring entry with same names first %##s, name2 %##s",  v66,  v67,  v68,  v69,  v70,  (int)&v103);
                }
              }

              else if (!mDNSMacOSXCreateEtcHostsEntry( v119,  0LL,  (unint64_t)&v103,  v95,  (uint64_t)v96,  v68,  v69,  v70))
              {
                goto LABEL_85;
              }

              ++v59;
LABEL_80:
            }

            if (v59) {
              goto LABEL_80;
            }
            if (mDNS_LoggingEnabled == 1) {
              LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "mDNSMacOSXParseEtcHostsLine: White space at the end of %##s",  v61,  v62,  v63,  v64,  v65,  (int)&v103);
            }
LABEL_81:
            uint64_t v7 = (_BYTE *)&unk_100158000;
LABEL_83:
            freeaddrinfo(v97);
          }

          else
          {
LABEL_84:
            LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "mDNSMacOSXParseEtcHostsLine: ERROR!! cannot convert to domain name %s",  v54,  v55,  v56,  v57,  v58,  v53);
LABEL_85:
            freeaddrinfo(v97);
            uint64_t v7 = (_BYTE *)&unk_100158000;
          }
        }
      }

      else
      {
LABEL_28:
        LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "mDNSMacOSXParseEtcHosts: Length is zero!",  v12,  v13,  v14,  v15,  v16,  v94);
      }
    }
  }

  fclose(v9);
LABEL_104:
  mDNS_Lock_((unsigned int *)mDNSStorage, (uint64_t)"mDNSMacOSXUpdateEtcHosts_internal", 7811);
  if (EtcHostsAddNewEntries((uint64_t)v96, 1) || EtcHostsDeleteOldEntries((uint64_t)v96, 1))
  {
    mDNSCoreRestartAddressQueries( 0,  (void (*)(uint64_t *))FlushAllCacheRecords,  (void (*)(uint64_t *, uint64_t))UpdateEtcHosts,  (uint64_t)v96);
  }

  else if (mDNS_LoggingEnabled == 1)
  {
    LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "mDNSMacOSXUpdateEtcHosts: No work",  v80,  v81,  v82,  v83,  v84,  v94);
  }

  for (uint64_t j = 0LL; j != 499; ++j)
  {
    __int128 v86 = v96[j + 3];
    if (v86)
    {
      do
      {
        __int128 v87 = *(addrinfo **)&v86->ai_flags;
        BOOL v88 = *(void **)&v86->ai_addrlen;
        if (v88)
        {
          do
          {
            __int16 v89 = (void *)*v88;
            free(v88);
            BOOL v88 = v89;
          }

          while (v89);
        }

        free(v86);
        __int128 v86 = v87;
      }

      while (v87);
    }
  }

  mDNS_Unlock_((uint64_t)mDNSStorage, (uint64_t)"mDNSMacOSXUpdateEtcHosts_internal", 7845);
}

  uint64_t v25 = *(void **)(*((void *)&v34 + 1) + 24LL);
  if (v25)
  {
    nw_release(v25);
    *(void *)(*((void *)&v34 + 1) + 24LL) = 0LL;
  }

  int v26 = *(void *)(a1 + 32);
  uint64_t v27 = *(void *)(v26 + 136);
  if (v27)
  {
    uint64_t v28 = v18 ? 2LL : 3LL;
    nw_connection_end_activity(*(void *)(v26 + 128), v27);
    nw_activity_complete_with_reason(v27, v28);
    uint64_t v29 = *(void **)(*(void *)(a1 + 32) + 136LL);
    if (v29)
    {
      nw_release(v29);
      *(void *)(*(void *)(a1 + 32) + 136LL) = 0LL;
    }
  }

  if ((v18 & 1) != 0)
  {
    int v30 = v19 ^ 1;
    if (!a5) {
      int v30 = 1;
    }
    if ((v30 & 1) == 0) {
      error_code = nw_error_get_error_code(a5);
    }
  }

  else
  {
    if ((_DWORD)a3 == 401)
    {
      error_code = 4294960520LL;
    }

    else if ((_DWORD)a3)
    {
      error_code = 4294960560LL;
    }

    else if (a5)
    {
      error_code = nw_error_get_error_code(a5);
    }

    else
    {
      error_code = 4294960543LL;
    }

    *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 184LL) + 230LL) = 0;
  }

  _mdns_common_session_finish(*(void *)(a1 + 32), 3LL, error_code);
  _Block_object_dispose(&v34, 8);
}

uint64_t mDNS_ConfigChanged(uint64_t result)
{
  uint64_t v1 = result;
  uint64_t v2 = result + 15032;
  if (*(_BYTE *)(result + 15037) == 1)
  {
    memset(v12, 0, sizeof(v12));
    memset(&v11[256], 0, 64);
    DeconstructServiceName(*(char **)(result + 17504), v12, (uint64_t)v11, v10);
    unsigned __int8 v3 = mDNS_snprintf(&v11[257]);
    v11[256] = v3;
    if (LOBYTE(v12[0]) != v3 || (unint64_t result = memcmp((char *)v12 + 1, &v11[257], v3), (_DWORD)result))
    {
      if (mDNS_LoggingEnabled == 1) {
        LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "Renaming SPS from “%#s” to “%#s”",  v4,  v5,  v6,  v7,  v8,  (int)v12);
      }
      *(_BYTE *)(v2 + 5) = 2;
      unint64_t result = mDNS_DeregisterService_drt((unsigned int *)v1, v1 + 15056, 1, v4, v5, v6, v7, v8);
    }
  }

  int v9 = *(uint64_t (**)(uint64_t, uint64_t))(v1 + 32);
  if (v9) {
    return v9(v1, 4294901505LL);
  }
  return result;
}

uint64_t SameRDataBody( uint64_t a1, unsigned __int16 *a2, uint64_t (*a3)(uint64_t, unsigned __int16 *))
{
  unsigned __int8 v3 = a2;
  uint64_t v5 = *(void *)(a1 + 40);
  uint64_t v6 = (unsigned __int16 *)(v5 + 4);
  int v7 = *(unsigned __int16 *)(a1 + 4) - 2;
  uint64_t result = 0LL;
  switch(v7)
  {
    case 0:
    case 1:
    case 2:
    case 3:
    case 5:
    case 6:
    case 7:
    case 10:
    case 21:
    case 37:
      return SameDomainNameBytes((_BYTE *)(v5 + 4), a2);
    case 4:
      if (*(_DWORD *)(v5 + 516) != *((_DWORD *)a2 + 128)
        || *(_DWORD *)(v5 + 520) != *((_DWORD *)a2 + 129)
        || *(_DWORD *)(v5 + 524) != *((_DWORD *)a2 + 130)
        || *(_DWORD *)(v5 + 528) != *((_DWORD *)a2 + 131)
        || *(_DWORD *)(v5 + 532) != *((_DWORD *)a2 + 132))
      {
        return 0LL;
      }

      goto LABEL_15;
    case 12:
    case 15:
LABEL_15:
      uint64_t result = a3(v5 + 4, a2);
      if (!(_DWORD)result) {
        return result;
      }
      uint64_t v10 = v5 + 260;
      uint64_t v11 = v3 + 128;
      return a3(v10, v11) != 0;
    case 13:
    case 16:
    case 19:
    case 34:
      if (*v6 != *a2) {
        return 0LL;
      }
      uint64_t v10 = v5 + 6;
      uint64_t v11 = a2 + 1;
      return a3(v10, v11) != 0;
    case 24:
      if (*v6 != *a2) {
        return 0LL;
      }
      uint64_t result = a3(v5 + 6, a2 + 1);
      if (!(_DWORD)result) {
        return result;
      }
      uint64_t v10 = v5 + 262;
      uint64_t v11 = v3 + 129;
      return a3(v10, v11) != 0;
    case 31:
      uint64_t v10 = v5 + 10;
      uint64_t v11 = a2 + 3;
      return a3(v10, v11) != 0;
    case 39:
      return result;
    case 45:
      int v14 = (_BYTE *)(v5 + 4);
      if (v5 != -260) {
        goto LABEL_22;
      }
      break;
    default:
      size_t v12 = *(unsigned __int16 *)(a1 + 12);
      int v13 = (char *)(v5 + 4);
      return memcmp(v13, a2, v12) == 0;
  }

LABEL_43:
  if ((_DWORD)v17 != v19) {
    return 0LL;
  }
  uint64_t result = a3((uint64_t)v6, a2);
  if ((_DWORD)result)
  {
    int v13 = (char *)v6 + v17;
    a2 = (unsigned __int16 *)((char *)v3 + v17);
    size_t v12 = *(unsigned __int16 *)(a1 + 12) - v17;
    return memcmp(v13, a2, v12) == 0;
  }

  return result;
}

    int v26 = 4;
LABEL_45:
    uint64_t v25 = (_DWORD *)(*(void *)(a3 + 40) + 4LL);
    int v24 = 1;
LABEL_46:
    if ((_dx_gai_request_check_for_failover_restart(a7, a3, a4 != 0, v24) & 1) != 0) {
      _dx_gai_request_restart_client_requests_in_failover_mode(a7, v30, v31, v32, v33, v34, v35, v36);
    }
    else {
      _dx_gai_request_enqueue_result(a7, a5, a3, a4 != 0, v25, v26, a6, a2);
    }
    return;
  }

  if (v20 == 1 || v20 == 28)
  {
    if (a6)
    {
      int v24 = 0;
      uint64_t v25 = 0LL;
      int v26 = 0;
      goto LABEL_46;
    }

    if (v20 != 1) {
      goto LABEL_44;
    }
    goto LABEL_43;
  }

        *(_WORD *)(a4 + 12) = __n;
        uint64_t v32 = __n;
        uint64_t v33 = (char *)(v13 + 2);
      }

      else
      {
        unsigned int v146 = 0u;
        uint64_t v147 = 0u;
        uint64_t v144 = 0u;
        int v145 = 0u;
        uint64_t v142 = 0u;
        unsigned int v143 = 0u;
        uint64_t v140 = 0u;
        uint64_t v141 = 0u;
        uint64_t v138 = 0u;
        uint64_t v139 = 0u;
        uint64_t v136 = 0u;
        uint64_t v137 = 0u;
        uint64_t v134 = 0u;
        v135 = 0u;
        *(_OWORD *)buf = 0u;
        unsigned __int16 v133 = 0u;
        if (a1)
        {
          uint64_t v11 = getDomainName(a1, __src, a3, buf);
          if (!v11) {
            goto LABEL_206;
          }
        }

        else
        {
          uint64_t v74 = buf;
          __int16 v75 = 257LL;
          while (1)
          {
            __int16 v76 = *v74;
            if (!*v74) {
              break;
            }
            v74 += v76 + 1;
            if (v74 >= v148 || v74 == 0LL) {
              goto LABEL_195;
            }
          }

          __int16 v75 = (unsigned __int16)((_WORD)v74 - (unsigned __int16)buf + 1);
LABEL_195:
          v11 += v75;
          if (!v11)
          {
LABEL_206:
            if (mDNS_LoggingEnabled == 1) {
              LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "SetRData: Malformed name for TSIG/TKEY type %d",  v23,  v24,  v25,  v26,  v27,  *(unsigned __int16 *)(a4 + 4));
            }
            return 0LL;
          }
        }

        uint64_t v94 = buf;
        do
        {
          uint64_t v95 = *v94;
          if (!*v94)
          {
            uint64_t v97 = (_DWORD)v94 - buf + 1;
            goto LABEL_209;
          }

          v94 += v95 + 1;
        }

        while (v94 < v148 && v94 != 0LL);
        LOWORD(v97) = 257;
LABEL_209:
        unsigned __int16 v98 = v10 - (_DWORD)v11;
        *(_WORD *)(a4 + 12) = v97 + v98;
        if ((unsigned __int16)(v97 + v98) > 0x2000u)
        {
          if (mDNS_LoggingEnabled == 1) {
            LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "SetRData: Malformed TSIG/TKEY rdlength %d, rr->rdlength %d, bmaplen %d, name %##s",  v23,  v24,  v25,  v26,  v27,  v8);
          }
          return 0LL;
        }

        int v99 = buf;
        while (1)
        {
          uint64_t v100 = *v99;
          if (!*v99) {
            break;
          }
          v99 += v100 + 1;
          if (v99 >= v148 || v99 == 0LL) {
            goto LABEL_223;
          }
        }

        if ((unsigned __int16)((_WORD)v99 - (unsigned __int16)buf + 1) > 0x100u) {
LABEL_223:
        }
          *(_BYTE *)int v14 = 0;
        else {
          memcpy(v13 + 2, buf, (unsigned __int16)((_WORD)v99 - (unsigned __int16)buf + 1));
        }
        uint64_t v33 = (char *)v14 + (unsigned __int16)v97;
        uint64_t v32 = v98;
      }

      uint64_t v34 = v11;
      goto LABEL_45;
  }

          unsigned __int16 v19 = *(unsigned __int16 *)(v5 + 12);
          uint64_t v20 = *(_DWORD *)(v5 + 16);
          *(_DWORD *)buf = 134219267;
          uint64_t v22 = v6;
          time_t v23 = 2160;
          int v24 = 1752392040LL;
          uint64_t v25 = 1040;
          int v26 = v18;
          uint64_t v27 = 2101;
          uint64_t v28 = v10;
          uint64_t v29 = 1024;
          int v30 = v19;
          uint64_t v31 = 1024;
          uint64_t v32 = v20;
          _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEBUG,  "[Sub%llu] Removing record from the cache due to subscriber invalidation -- name: %{sensitive, mask.hash, mdn sresponder:domain_name}.*P, type: %{mdns:rrtype}d, TTL: %us",  buf,  0x32u);
        }

  if (!setsockopt(v14, 0xFFFF, 4130, &v52, 4u)) {
    goto LABEL_52;
  }
  if (*__error())
  {
    uint64_t v25 = *__error();
    if (!v25) {
      goto LABEL_52;
    }
  }

  else
  {
    uint64_t v25 = -6700;
  }

  if (_mdns_resolver_log_s_once != -1) {
    dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_48);
  }
  int v26 = (os_log_s *)_mdns_resolver_log_s_log;
  if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_ERROR))
  {
    v53[0].val[0] = 67109120;
    v53[0].val[1] = v25;
    _os_log_error_impl( (void *)&_mh_execute_header,  v26,  OS_LOG_TYPE_ERROR,  "setsockopt() for SOL_SOCKET/SO_NOSIGPIPE failed %{darwin.errno}d",  (uint8_t *)v53,  8u);
  }

    if (v24 == ++v22)
    {
LABEL_44:
      unsigned __int16 v19 = 4294960560LL;
      goto LABEL_45;
    }
  }

  if (v26) {
    goto LABEL_43;
  }
  if (!v21) {
    goto LABEL_44;
  }
  if (--v21) {
    goto LABEL_43;
  }
LABEL_66:
  uint64_t v1 = v41;
  *(void *)(v41 + 176) = v25;
  os_retain(v25);
  int v43 = 0;
  uint64_t v34 = (void *)(*(uint64_t (**)(uint64_t, unsigned int *))(*(void *)(v1 + 16) + 64LL))(v1, &v43);
  uint64_t v35 = v34;
  if (!v43)
  {
    *(void *)(v41 + 80) = v34;
    nw_retain(v34);
    os_retain((void *)v41);
    nw_retain(v35);
    uint64_t v36 = *(nw_connection **)(v41 + 80);
    if (_mdns_dso_session_queue_s_once != -1) {
      dispatch_once(&_mdns_dso_session_queue_s_once, &__block_literal_global_66);
    }
    nw_connection_set_queue(v36, (dispatch_queue_t)_mdns_dso_session_queue_s_queue);
    uint64_t v37 = *(nw_connection **)(v41 + 80);
    *(void *)handler = _NSConcreteStackBlock;
    *(void *)&handler[8] = 0x40000000LL;
    *(void *)&handler[16] = ___mdns_dso_session_prepare_connection_with_nw_connection_block_invoke;
    *(void *)&handler[24] = &__block_descriptor_tmp_15_5897;
    uint64_t v46 = v41;
    uint64_t v47 = v35;
    nw_connection_set_state_changed_handler(v37, handler);
    nw_connection_start(*(nw_connection_t *)(v41 + 80));
    uint64_t v38 = *(nw_connection **)(v41 + 80);
    completion[0] = _NSConcreteStackBlock;
    completion[1] = 0x40000000LL;
    completion[2] = ___mdns_dso_session_schedule_receive_block_invoke;
    completion[3] = &__block_descriptor_tmp_17_5898;
    completion[4] = v41;
    nw_connection_receive_message(v38, completion);
    if (_mdns_dso_session_log_s_once != -1) {
      dispatch_once(&_mdns_dso_session_log_s_once, &__block_literal_global_5889);
    }
    uint64_t v39 = (os_log_s *)_mdns_dso_session_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_dso_session_log_s_log, OS_LOG_TYPE_DEFAULT))
    {
      int v40 = *(void *)(v41 + 40);
      *(_DWORD *)handler = 134218242;
      *(void *)&handler[4] = v40;
      *(_WORD *)&handler[12] = 2112;
      *(void *)&handler[14] = v35;
      _os_log_impl( (void *)&_mh_execute_header,  v39,  OS_LOG_TYPE_DEFAULT,  "[DSO%llu] Start connection -- connection: %@",  handler,  0x16u);
    }
  }

  if (v35) {
    nw_release(v35);
  }
  unsigned __int16 v19 = v43;
  if (v43) {
    goto LABEL_46;
  }
  return v19;
}

uint64_t mDNS_Deregister(unsigned int *a1, uint64_t a2)
{
  uint64_t v4 = mDNS_Deregister_internal((uint64_t)a1, a2, 0);
  mDNS_Unlock_((uint64_t)a1, (uint64_t)"mDNS_Deregister", 16397);
  return v4;
}

uint64_t mDNS_Deregister_internal(uint64_t a1, uint64_t a2, int a3)
{
  int v7 = (unsigned __int8 *)(a2 + 8);
  int v6 = *(unsigned __int8 *)(a2 + 8);
  unsigned int v8 = *(_DWORD *)(a2 + 24);
  int v9 = (int *)(a1 + 19844);
  uint64_t v10 = (uint64_t *)(a1 + 12624);
  memset(__dst, 0, sizeof(__dst));
  uint64_t v11 = *(_BYTE **)(a2 + 40);
  size_t v12 = v11;
  if (v11 == (_BYTE *)-256LL)
  {
LABEL_3:
    while (v12)
    {
      uint64_t v13 = *v12;
      if (!*v12)
      {
        unsigned __int16 v14 = (_WORD)v12 - (_WORD)v11 + 1;
        if (v14 <= 0x100u) {
          memcpy(__dst, *(const void **)(a2 + 40), v14);
        }
        break;
      }

      v12 += v13 + 1;
      if (v11 != (_BYTE *)-256LL) {
        goto LABEL_2;
      }
    }
  }

  else
  {
LABEL_2:
    if (v12 < v11 + 256) {
      goto LABEL_3;
    }
  }

  unsigned int v143 = v9;
  uint64_t v15 = *(unsigned __int16 *)(a2 + 12);
  if ((*(_DWORD *)(a2 + 172) & 0xFFFFFFFE) == 4)
  {
    uint64_t v16 = AuthGroupForName(a1 + 6272, v8, v11);
    if (!v16) {
      return 0LL;
    }
    uint64_t v142 = (uint64_t **)v10;
    unsigned int v144 = v8;
    uint64_t v10 = v16 + 2;
    do
    {
      uint64_t v17 = v10;
      uint64_t v10 = (uint64_t *)*v10;
      if (v10) {
        BOOL v18 = v10 == (uint64_t *)a2;
      }
      else {
        BOOL v18 = 1;
      }
    }

    while (!v18);
  }

  else
  {
    unsigned int v144 = v8;
    uint64_t v142 = (uint64_t **)v10;
    do
    {
      uint64_t v17 = v10;
      uint64_t v10 = (uint64_t *)*v10;
      if (v10) {
        BOOL v19 = v10 == (uint64_t *)a2;
      }
      else {
        BOOL v19 = 1;
      }
    }

    while (!v19);
  }

  uint64_t v146 = a1;
  if (!v10)
  {
    uint64_t v29 = (uint64_t *)(a1 + 12632);
    do
    {
      uint64_t v17 = v29;
      uint64_t v29 = (uint64_t *)*v29;
      if (v29) {
        BOOL v30 = v29 == (uint64_t *)a2;
      }
      else {
        BOOL v30 = 1;
      }
    }

    while (!v30);
    if (v29)
    {
      int j = v6;
      *(_WORD *)(a2 + 130) = 0;
      *(_DWORD *)(a2 + 126) = 0;
      *(_BYTE *)(a2 + 192) = 0;
      *(_BYTE *)(a2 + 8) = 1;
      goto LABEL_110;
    }

LABEL_131:
    uint64_t v54 = 4294901755LL;
    if (a3 == 3) {
      return v54;
    }
    uint64_t v55 = mDNSLogCategory_State;
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT)) {
      return v54;
    }
    GetRRDisplayString_rdb(v7, (unsigned __int16 *)(*(void *)(a2 + 48) + 4LL), (_BYTE *)(v146 + 46976));
    *(_DWORD *)buf = 134218499;
    *(void *)int v148 = a2;
    *(_WORD *)&v148[8] = 2160;
    *(void *)&v148[10] = 1752392040LL;
    *(_WORD *)&v148[18] = 2085;
    *(void *)&v148[20] = v146 + 46976;
    uint64_t v56 = "mDNS_Deregister_internal: Record %p not found in list %{sensitive, mask.hash}s";
    uint64_t v57 = (os_log_s *)v55;
    uint32_t v58 = 32;
LABEL_136:
    _os_log_impl((void *)&_mh_execute_header, v57, OS_LOG_TYPE_DEFAULT, v56, buf, v58);
    return v54;
  }

  BOOL v18 = a3 == 4;
  int v20 = a3;
  uint64_t v21 = v15;
  if (v18)
  {
    uint64_t v31 = *(void *)(a2 + 32);
    *(void *)(a2 + 32) = 0LL;
    for (uint64_t i = *(uint64_t **)(v146 + 12632); i; uint64_t i = (uint64_t *)*i)
    {
      if (i[4] == *(void *)(a2 + 32))
      {
        int v33 = *((unsigned __int8 *)i + 8);
        int v34 = *v7;
        BOOL v35 = v34 == 1 || v33 == 1;
        BOOL v36 = v35 || v33 == v34;
        BOOL v37 = v36 || (v34 | v33) == 18;
        if (v37
          && *((_DWORD *)i + 6) == *(_DWORD *)(a2 + 24)
          && resource_records_have_same_dnssec_rr_category(i[8], *(void *)(a2 + 64))
          && *((unsigned __int16 *)i + 6) == *(unsigned __int16 *)(a2 + 12)
          && *((unsigned __int16 *)i + 7) == *(unsigned __int16 *)(a2 + 14)
          && *((unsigned __int16 *)i + 10) == *(unsigned __int16 *)(a2 + 20)
          && *((_DWORD *)i + 7) == *(_DWORD *)(a2 + 28)
          && SameRDataBody( (uint64_t)(i + 1),  (unsigned __int16 *)(*(void *)(a2 + 48) + 4LL),  (uint64_t (*)(uint64_t, unsigned __int16 *))SameDomainName)
          && SameDomainNameBytes((_BYTE *)i[5], *(_BYTE **)(a2 + 40)))
        {
          *((_BYTE *)i + 190) = -1;
        }
      }
    }

    *(void *)(a2 + 32) = v31;
    uint64_t v15 = v21;
    a3 = v20;
    int j = v6;
    goto LABEL_110;
  }

  int v139 = v20;
  if (v20 == 2)
  {
    uint64_t v22 = *(uint64_t **)(v146 + 12632);
    for (j = v6; v22; uint64_t v22 = (uint64_t *)*v22)
    {
      if (v22[4] == *(void *)(a2 + 32))
      {
        int v24 = *((unsigned __int8 *)v22 + 8);
        int v25 = *v7;
        BOOL v26 = v25 == 1 || v24 == 1;
        BOOL v27 = v26 || v24 == v25;
        BOOL v28 = v27 || (v25 | v24) == 18;
        if (v28
          && *((_DWORD *)v22 + 6) == *(_DWORD *)(a2 + 24)
          && resource_records_have_same_dnssec_rr_category(v22[8], *(void *)(a2 + 64))
          && *((unsigned __int16 *)v22 + 6) == *(unsigned __int16 *)(a2 + 12)
          && *((unsigned __int16 *)v22 + 7) == *(unsigned __int16 *)(a2 + 14)
          && *((unsigned __int16 *)v22 + 10) == *(unsigned __int16 *)(a2 + 20)
          && *((_DWORD *)v22 + 7) == *(_DWORD *)(a2 + 28)
          && SameRDataBody( (uint64_t)(v22 + 1),  (unsigned __int16 *)(*(void *)(a2 + 48) + 4LL),  (uint64_t (*)(uint64_t, unsigned __int16 *))SameDomainName)
          && SameDomainNameBytes((_BYTE *)v22[5], *(_BYTE **)(a2 + 40)))
        {
          *((_BYTE *)v22 + 190) = -1;
        }
      }
    }

    goto LABEL_109;
  }

  uint64_t v38 = *(void *)(v146 + 12632);
  int j = v6;
  if (!v38) {
    goto LABEL_109;
  }
  uint64_t v39 = (uint64_t *)(v146 + 12632);
  while (1)
  {
    if (*(void *)(v38 + 32) != *(void *)(a2 + 32)) {
      goto LABEL_108;
    }
    int v40 = *(unsigned __int8 *)(v38 + 8);
    int v41 = *v7;
    BOOL v42 = v41 == 1 || v40 == 1;
    BOOL v43 = v42 || v40 == v41;
    BOOL v44 = v43 || (v41 | v40) == 18;
    if (!v44
      || *(_DWORD *)(v38 + 24) != *(_DWORD *)(a2 + 24)
      || !resource_records_have_same_dnssec_rr_category(*(void *)(v38 + 64), *(void *)(a2 + 64))
      || *(unsigned __int16 *)(v38 + 12) != *(unsigned __int16 *)(a2 + 12)
      || *(unsigned __int16 *)(v38 + 14) != *(unsigned __int16 *)(a2 + 14)
      || *(unsigned __int16 *)(v38 + 20) != *(unsigned __int16 *)(a2 + 20)
      || *(_DWORD *)(v38 + 28) != *(_DWORD *)(a2 + 28))
    {
      goto LABEL_108;
    }

    if (!SameRDataBody( v38 + 8,  (unsigned __int16 *)(*(void *)(a2 + 48) + 4LL),  (uint64_t (*)(uint64_t, unsigned __int16 *))SameDomainName))
    {
      uint64_t v38 = *v39;
      goto LABEL_108;
    }

    int v45 = SameDomainNameBytes(*(_BYTE **)(v38 + 40), *(_BYTE **)(a2 + 40));
    uint64_t v38 = *v39;
    if (v45) {
      break;
    }
LABEL_108:
    uint64_t v39 = (uint64_t *)v38;
    uint64_t v38 = *(void *)v38;
    if (!v38) {
      goto LABEL_109;
    }
  }

  if (v38)
  {
    uint64_t *v39 = *(void *)v38;
    if ((*(_DWORD *)(a2 + 172) & 0xFFFFFFFE) == 4)
    {
      *(void *)uint64_t v38 = 0LL;
      if (!InsertAuthRecord(v146 + 6272, v38))
      {
        v135 = (os_log_s *)mDNSLogCategory_State;
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT))
        {
          GetRRDisplayString_rdb( (unsigned __int8 *)(v38 + 8),  (unsigned __int16 *)(*(void *)(v38 + 48) + 4LL),  (_BYTE *)(v146 + 46976));
          *(_DWORD *)buf = 141558275;
          *(void *)int v148 = 1752392040LL;
          *(_WORD *)&v148[8] = 2085;
          *(void *)&v148[10] = v146 + 46976;
          _os_log_impl( (void *)&_mh_execute_header,  v135,  OS_LOG_TYPE_DEFAULT,  "mDNS_Deregister_internal: ERROR!! cannot insert %{sensitive, mask.hash}s",  buf,  0x16u);
        }
      }
    }

    else
    {
      *(void *)uint64_t v38 = *(void *)a2;
      *(void *)a2 = v38;
    }

    *(_BYTE *)(v38 + 8) = *(_BYTE *)(a2 + 8);
    *(_DWORD *)(v38 + 189) = *(_DWORD *)(a2 + 189);
    *(_BYTE *)(v38 + 193) = *(_BYTE *)(a2 + 193);
    *(_BYTE *)(v38 + 195) = *(_BYTE *)(a2 + 195);
    *(_OWORD *)(v38 + 208) = *(_OWORD *)(a2 + 208);
    *(_DWORD *)(v38 + 232) = *(_DWORD *)(a2 + 232);
    *(_OWORD *)(v38 + 236) = *(_OWORD *)(a2 + 236);
    *(void *)(v38 + 280) = *(void *)(a2 + 280);
    *(_DWORD *)(v38 + 288) = *(_DWORD *)(a2 + 288);
    *(void *)(v38 + 296) = *(void *)(a2 + 296);
    *(_BYTE *)(v38 + 356) = *(_BYTE *)(a2 + 356);
    *(_DWORD *)(v38 + 344) = *(_DWORD *)(a2 + 344);
    *(_WORD *)(a2 + 192) = 0;
  }

        *(_DWORD *)buf = 141558531;
        uint64_t v54 = 1752392040LL;
        uint64_t v55 = 1040;
        uint64_t v56 = v51;
        uint64_t v57 = 2101;
        uint32_t v58 = v46;
        _os_log_impl( (void *)&_mh_execute_header,  v45,  OS_LOG_TYPE_DEFAULT,  "GetAuthGroup: Not finding AuthGroup for %{sensitive, mask.hash, mdnsresponder:domain_name}.*P",  buf,  0x1Cu);
      }
    }
  }

      os_release((void *)v31);
      goto LABEL_42;
    case 5u:
      unsigned int v144 = 0;
      if (g_current_discovery_proxy_owner)
      {
        BOOL v43 = -6719;
        goto LABEL_183;
      }

      __int128 v86 = _mdns_xpc_dictionary_get_object(object, "params", (const _xpc_type_s *)&_xpc_type_dictionary);
      if (!v86) {
        goto LABEL_182;
      }
      uint64_t v87 = v86;
      unsigned int v143 = 0;
      interface = mrc_xpc_discovery_proxy_params_get_interface(v86, &v143);
      if (!v143) {
        goto LABEL_182;
      }
      uint64_t v89 = interface;
      uint64_t v90 = mdns_xpc_dictionary_get_optional_array(v87, "addresses");
      if (!v90) {
        goto LABEL_182;
      }
      uint64_t v91 = v90;
      uint64_t v92 = xpc_array_get_count(v90);
      if (!v92) {
        goto LABEL_182;
      }
      uint64_t v93 = v92;
      CFMutableArrayRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, v92, (const CFArrayCallBacks *)&mdns_cfarray_callbacks);
      if (!Mutable)
      {
        BOOL v43 = -6729;
LABEL_183:
        unsigned int v144 = v43;
        goto LABEL_184;
      }

      uint64_t v95 = Mutable;
      for (uint64_t k = 0LL; k != v93; ++k)
      {
        uint64_t v97 = (char *)xpc_array_get_string(v91, k);
        if (!v97) {
          goto LABEL_195;
        }
        int v98 = (void *)mdns_address_create_from_ip_address_string(v97);
        if (!v98) {
          goto LABEL_195;
        }
        int v99 = v98;
        CFArrayAppendValue(v95, v98);
        os_release(v99);
      }

      xarraya = v87;
      BOOL v100 = mdns_xpc_dictionary_get_optional_array(v87, "match_domains");
      if (v100 && (v101 = v100, (uint64_t v102 = xpc_array_get_count(v100)) != 0))
      {
        int v103 = v102;
        uint64_t v104 = CFArrayCreateMutable(kCFAllocatorDefault, 0LL, (const CFArrayCallBacks *)&mdns_cfarray_callbacks);
        if (v104)
        {
          uint64_t v105 = v104;
          for (uint64_t m = 0LL; m != v103; ++m)
          {
            BOOL v107 = (char *)xpc_array_get_string(v101, m);
            if (!v107) {
              goto LABEL_219;
            }
            BOOL v108 = mdns_domain_name_create(v107, &v144);
            if (v144)
            {
              uint64_t v112 = 0LL;
              goto LABEL_223;
            }

            char v109 = v108;
            CFArrayAppendValue(v105, v108);
            if (v109) {
              os_release(v109);
            }
          }

          xarrayb = mdns_xpc_dictionary_get_optional_array(xarraya, "server_certificates");
          int v110 = xpc_array_get_count(xarrayb);
          if (v110)
          {
            CFStringRef v111 = v110;
            uint64_t v112 = CFArrayCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeArrayCallBacks);
            if (v112)
            {
              for (uint64_t n = 0LL; n != v111; ++n)
              {
                length = 0LL;
                data = (const UInt8 *)xpc_array_get_data(xarrayb, n, &length);
                int v115 = -6705;
                if (!data || !length) {
                  goto LABEL_221;
                }
                unsigned int v116 = CFDataCreate(kCFAllocatorDefault, data, length);
                if (!v116)
                {
                  int v115 = -6729;
                  goto LABEL_221;
                }

                int v117 = v116;
                CFArrayAppendValue(v112, v116);
                CFRelease(v117);
              }

              if (*(void *)g_discovery_proxy_handlers)
              {
                unsigned int v144 = (*(uint64_t (**)(void *, __CFArray *, __CFArray *, __CFArray *))g_discovery_proxy_handlers)( v89,  v95,  v105,  v112);
                if (!v144)
                {
                  g_current_discovery_proxy_owner = (uint64_t)v6;
                  os_retain(v6);
                }

LABEL_109:
  uint64_t v15 = v21;
  a3 = v139;
LABEL_110:
  if (!*v17) {
    goto LABEL_131;
  }
  if (!*(void *)(a2 + 32) && !*(_BYTE *)(a2 + 122) && !IsLocalDomain(*(_BYTE **)(a2 + 40)))
  {
    if (*(_BYTE *)(a2 + 192))
    {
      uint64_t v69 = *(void *)(a2 + 384);
      if (v69)
      {
        DisposeTCPConn(v69);
        *(void *)(a2 + 384) = 0LL;
      }

      *(_BYTE *)(a2 + 8) = 1;
      *(_BYTE *)(v146 + 140) = 1;
      uDNS_DeregisterRecord(v146, a2);
      return 0LL;
    }

    *(_WORD *)(a2 + 358) = 0;
    if (*(void *)(a2 + 584))
    {
      mDNS_StopNATOperation_internal(v146, a2 + 392);
      *(void *)(a2 + 584) = 0LL;
    }

    __int128 v86 = *(_DWORD **)(a2 + 376);
    if (v86)
    {
      CancelGetZoneData(v146, v86);
      *(void *)(a2 + 376) = 0LL;
    }

    uint64_t v87 = *(void *)(a2 + 384);
    if (v87)
    {
      DisposeTCPConn(v87);
      *(void *)(a2 + 384) = 0LL;
    }
  }

  if (j == 1)
  {
    uint64_t v54 = 4294901755LL;
    uint64_t v59 = mDNSLogCategory_State;
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT)) {
      return v54;
    }
    GetRRDisplayString_rdb(v7, (unsigned __int16 *)(*(void *)(a2 + 48) + 4LL), (_BYTE *)(v146 + 46976));
    *(_DWORD *)buf = 141558275;
    *(void *)int v148 = 1752392040LL;
    *(_WORD *)&v148[8] = 2085;
    *(void *)&v148[10] = v146 + 46976;
    uint64_t v56 = "mDNS_Deregister_internal: %{sensitive, mask.hash}s already marked kDNSRecordTypeDeregistering";
    uint64_t v57 = (os_log_s *)v59;
    uint32_t v58 = 22;
    goto LABEL_136;
  }

  if (!j)
  {
    uint64_t v46 = (os_log_s *)mDNSLogCategory_State;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT))
    {
      GetRRDisplayString_rdb(v7, (unsigned __int16 *)(*(void *)(a2 + 48) + 4LL), (_BYTE *)(v146 + 46976));
      *(_DWORD *)buf = 141558275;
      *(void *)int v148 = 1752392040LL;
      *(_WORD *)&v148[8] = 2085;
      *(void *)&v148[10] = v146 + 46976;
      _os_log_impl( (void *)&_mh_execute_header,  v46,  OS_LOG_TYPE_DEFAULT,  "mDNS_Deregister_internal: %{sensitive, mask.hash}s already marked kDNSRecordTypeUnregistered",  buf,  0x16u);
    }
  }

  int v47 = *(_DWORD *)(a2 + 126);
  if (v47 || (j == 8 || *(_DWORD *)(a2 + 172) == 4) && (*(_BYTE *)(a2 + 192) || *(_BYTE *)(a2 + 193)))
  {
    *(_BYTE *)(a2 + 8) = 1;
    *(_DWORD *)(a2 + 16) = 0;
    if (a3 == 1) {
      char v48 = 1;
    }
    else {
      char v48 = 3;
    }
    if (v47) {
      char v49 = 18;
    }
    else {
      char v49 = v48;
    }
    *(_BYTE *)(a2 + 191) = v49;
    *(_DWORD *)(a2 + 280) = 2000;
    uint64_t v50 = v146;
    int v51 = *(_DWORD *)(v146 + 64);
    *(_DWORD *)(a2 + 284) = v51 - 2000;
    *(_BYTE *)(v146 + 140) = 1;
    int v52 = v51 + 100;
    uint64_t v53 = 0LL;
    if (*(_DWORD *)(v146 + 100) - v52 >= 0) {
      *(_DWORD *)(v146 + 100) = v52;
    }
    int v60 = v144;
    goto LABEL_138;
  }

  if (!v10)
  {
    uint64_t v53 = 0LL;
    int v60 = v144;
    uint64_t v50 = v146;
    goto LABEL_216;
  }

  uint64_t v50 = v146;
  if ((*(_DWORD *)(a2 + 172) & 0xFFFFFFFE) != 4)
  {
    int v60 = v144;
    if ((*v7 & 0x32) == 0)
    {
      uint64_t v53 = 0LL;
      goto LABEL_213;
    }

    int v71 = CacheGroupForName(v146, *(_DWORD *)(a2 + 24), *(_BYTE **)(a2 + 40));
    uint64_t v53 = (uint64_t)v71;
    if (!v71) {
      goto LABEL_213;
    }
    uint64_t v78 = v71[2];
    if (!v78) {
      goto LABEL_213;
    }
    int v140 = a3;
    while (1)
    {
      uint64_t v79 = *(void *)(v78 + 32);
      uint64_t v80 = *(void *)(a2 + 32);
      if (v80)
      {
        uint64_t v81 = v15;
        if (v80 == v79) {
          goto LABEL_187;
        }
      }

      else
      {
        uint64_t v81 = v15;
        if (mDNSPlatformValidRecordForInterface(a2, *(void *)(v78 + 32), v72, v73, v74, v75, v76, v77))
        {
LABEL_187:
          if (resource_records_have_same_dnssec_rr_category(*(void *)(v78 + 64), *(void *)(a2 + 64))
            && *(unsigned __int16 *)(v78 + 12) == *(unsigned __int16 *)(a2 + 12)
            && *(unsigned __int16 *)(v78 + 14) == *(unsigned __int16 *)(a2 + 14)
            && *(unsigned __int16 *)(v78 + 20) == *(unsigned __int16 *)(a2 + 20)
            && *(_DWORD *)(v78 + 28) == *(_DWORD *)(a2 + 28)
            && SameRDataBody( v78 + 8,  (unsigned __int16 *)(*(void *)(a2 + 48) + 4LL),  (uint64_t (*)(uint64_t, unsigned __int16 *))SameDomainName))
          {
            unsigned int log = (os_log_s *)mDNSLogCategory_State;
            if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEBUG))
            {
              int v145 = v60;
              uint64_t v82 = &xmmword_10015BD30;
              while (1)
              {
                uint64_t v82 = *(__int128 **)v82;
                if (!v82) {
                  break;
                }
                __int16 v83 = v82;
                if (*((void *)v82 + 782) == v79) {
                  goto LABEL_199;
                }
              }

              __int16 v83 = 0LL;
LABEL_199:
              __int128 v84 = (char *)v83 + 6310;
              if (v82) {
                __int16 v85 = v84;
              }
              else {
                __int16 v85 = "";
              }
              GetRRDisplayString_rdb( (unsigned __int8 *)(v78 + 8),  (unsigned __int16 *)(*(void *)(v78 + 48) + 4LL),  (_BYTE *)(v146 + 46976));
              *(_DWORD *)buf = 136446979;
              *(void *)int v148 = v85;
              *(_WORD *)&v148[8] = 1024;
              *(_DWORD *)&v148[10] = v79;
              *(_WORD *)&v148[14] = 2160;
              *(void *)&v148[16] = 1752392040LL;
              *(_WORD *)&v148[24] = 2085;
              *(void *)&v148[26] = v146 + 46976;
              _os_log_impl( (void *)&_mh_execute_header,  log,  OS_LOG_TYPE_DEBUG,  "mDNS_Deregister_internal: Purging cached record that matches deregistered AuthRecord -- interface: %{pub lic}s/%u, record: %{sensitive, mask.hash}s",  buf,  0x26u);
              int v60 = v145;
            }

            mDNS_PurgeCacheResourceRecord((unsigned int *)v146, v78);
          }
        }
      }

      uint64_t v78 = *(void *)v78;
      uint64_t v15 = v81;
      if (!v78)
      {
        a3 = v140;
        uint64_t v50 = v146;
        goto LABEL_213;
      }
    }
  }

  uint64_t v53 = 0LL;
  int v60 = v144;
LABEL_213:
  if ((*(_DWORD *)(a2 + 172) & 0xFFFFFFFE) == 4)
  {
    BOOL v88 = RemoveAuthRecord(v50, v50 + 6272, a2);
    if (v88[5] == a2) {
      v88[5] = *(void *)a2;
    }
    goto LABEL_276;
  }

        if (v56 > 50)
        {
          uint64_t v16 = 4294901510LL;
          switch(v56)
          {
            case '3':
              return v16;
            case '@':
              return 4294901734LL;
            case 'A':
              return v16;
          }

          goto LABEL_116;
        }

        if (v56 != 49)
        {
          if (v56 == 50) {
            return 4294901734LL;
          }
          goto LABEL_116;
        }

        goto LABEL_126;
      }

      uint64_t v38 = (uint8_t *)(v14 + 6424);
      uint64_t v39 = v28;
      int v40 = 41;
      int v41 = 125;
LABEL_79:
      setsockopt(v39, v40, v41, v38, 4u);
      goto LABEL_80;
    }

    if ((v36 & 1) != 0)
    {
      BOOL v42 = mDNSLogCategory_NAT_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT_redacted, OS_LOG_TYPE_ERROR)) {
        goto LABEL_75;
      }
    }

    else
    {
      BOOL v42 = mDNSLogCategory_NAT;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT, OS_LOG_TYPE_ERROR)) {
        goto LABEL_75;
      }
    }

    uint64_t v53 = bswap32(*a2);
    uint64_t v54 = *v32;
    *(_DWORD *)buf = 67109376;
    *(_DWORD *)CFStringRef v111 = HIWORD(v53);
    *(_WORD *)&v111[4] = 1024;
    *(_DWORD *)&v111[6] = v54;
    BOOL v43 = "[Q%u] setsockopt - IPV6_MUTLICAST_IF scopeid %d, not a valid interface";
    BOOL v44 = (os_log_s *)v42;
    int v45 = 14;
    goto LABEL_74;
  }

  if (*a6 == 4)
  {
    *(_WORD *)&v134[0].sa_leuint64_t n = 528;
    *(_WORD *)v134[0].sa_data = a7;
    *(_DWORD *)&v134[0].sa_data[2] = a6[1];
    char v109 = a1;
    if (a5) {
      int v20 = (int *)(a5 + 16);
    }
    else {
      int v20 = (int *)(*a1 + 24LL);
    }
    BOOL v28 = *v20;
    if (mDNSAddrIsDNSMulticast(a6))
    {
      if (v14 && setsockopt(v28, 0, 66, (const void *)(v14 + 6424), 4u) < 0)
      {
        BOOL v107 = v19;
        if (*__error() != 42)
        {
          uint64_t v29 = (os_log_s *)mDNSLogCategory_NAT;
          if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_NAT == mDNSLogCategory_State)
          {
            if (os_log_type_enabled((os_log_t)mDNSLogCategory_NAT, OS_LOG_TYPE_ERROR))
            {
LABEL_65:
              __errnuma = bswap32(*a2) >> 16;
              uint64_t v46 = *__error();
              int v47 = __error();
              char v48 = strerror(*v47);
              *(_DWORD *)buf = 67109634;
              *(_DWORD *)CFStringRef v111 = __errnuma;
              *(_WORD *)&v111[4] = 1024;
              *(_DWORD *)&v111[6] = v46;
              *(_WORD *)&v111[10] = 2082;
              *(void *)&v111[12] = v48;
              _os_log_impl( (void *)&_mh_execute_header,  v29,  OS_LOG_TYPE_ERROR,  "[Q%u] mDNSPlatformSendUDP: setsockopt: IP_MUTLTICAST_IFINDEX returned %d (%{public}s)",  buf,  0x18u);
            }
          }

          else
          {
            uint64_t v29 = (os_log_s *)mDNSLogCategory_NAT_redacted;
            if (os_log_type_enabled((os_log_t)mDNSLogCategory_NAT_redacted, OS_LOG_TYPE_ERROR)) {
              goto LABEL_65;
            }
          }
        }

        char v49 = v14 + 6420;
        uint64_t v50 = setsockopt(v28, 0, 9, (const void *)(v14 + 6420), 4u);
        if ((v50 & 0x80000000) == 0 || *((_DWORD *)v109 + 2)) {
          goto LABEL_76;
        }
        int v51 = v50;
        int v52 = mDNSLogCategory_NAT;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_NAT == mDNSLogCategory_State)
        {
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_NAT, OS_LOG_TYPE_ERROR))
          {
LABEL_149:
            __errnumb = (os_log_s *)v52;
            int v99 = bswap32(*a2) >> 16;
            int v103 = *__error();
            BOOL v100 = __error();
            char v101 = strerror(*v100);
            *(_DWORD *)buf = 67110659;
            *(_DWORD *)CFStringRef v111 = v99;
            *(_WORD *)&v111[4] = 2160;
            *(void *)&v111[6] = 1752392040LL;
            *(_WORD *)&v111[14] = 1045;
            *(_DWORD *)&v111[16] = 4;
            *(_WORD *)&v111[20] = 2101;
            *(void *)&v111[22] = v49;
            uint64_t v112 = 1024;
            int v113 = v51;
            int v114 = 1024;
            *(_DWORD *)int v115 = v103;
            *(_WORD *)&v115[4] = 2082;
            *(void *)&v115[6] = v101;
            _os_log_impl( (void *)&_mh_execute_header,  __errnumb,  OS_LOG_TYPE_ERROR,  "[Q%u] setsockopt - IP_MULTICAST_IF error %{sensitive, mask.hash, network:in_addr}.4P %d errno %d (%{public}s)",  buf,  0x38u);
          }
        }

        else
        {
          int v52 = mDNSLogCategory_NAT_redacted;
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_NAT_redacted, OS_LOG_TYPE_ERROR)) {
            goto LABEL_149;
          }
        }

LABEL_216:
  uint64_t *v17 = *(void *)a2;
  if (*(void *)(v50 + 12640) == a2) {
    *(void *)(v50 + 12640) = *(void *)a2;
  }
  if ((*(_DWORD *)(a2 + 172) & 0xFFFFFFFE) == 4)
  {
    uint64_t v95 = (os_log_s *)mDNSLogCategory_State;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEBUG))
    {
      GetRRDisplayString_rdb(v7, (unsigned __int16 *)(*(void *)(a2 + 48) + 4LL), (_BYTE *)(v50 + 46976));
      *(_DWORD *)buf = 136446210;
      *(void *)int v148 = v50 + 46976;
      _os_log_impl( (void *)&_mh_execute_header,  v95,  OS_LOG_TYPE_DEBUG,  "DecrementAutoTargetServices: called for RRLocalOnly() record: %{public}s",  buf,  0xCu);
    }

    goto LABEL_276;
  }

  if (!*(void *)(a2 + 32) && !*(_BYTE *)(a2 + 122) && !IsLocalDomain(*(_BYTE **)(a2 + 40))
    || *(_WORD *)(a2 + 12) != 33
    || *(_BYTE *)(a2 + 120) != 1)
  {
    goto LABEL_266;
  }

  unsigned int v138 = *(_DWORD *)(a2 + 172) & 0xFFFFFFFE;
  if (v138 == 2)
  {
    int v96 = *(_DWORD *)(v50 + 10928) - 1;
    *(_DWORD *)(v50 + 10928) = v96;
    uint64_t v97 = (os_log_s *)mDNSLogCategory_State;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEBUG))
    {
      GetRRDisplayString_rdb(v7, (unsigned __int16 *)(*(void *)(a2 + 48) + 4LL), (_BYTE *)(v146 + 46976));
      *(_DWORD *)buf = 67109635;
      *(_DWORD *)int v148 = v96;
      *(_WORD *)&v148[4] = 2160;
      *(void *)&v148[6] = 1752392040LL;
      *(_WORD *)&v148[14] = 2085;
      *(void *)&v148[16] = v146 + 46976;
      uint64_t v50 = v146;
      _os_log_impl( (void *)&_mh_execute_header,  v97,  OS_LOG_TYPE_DEBUG,  "DecrementAutoTargetServices: AutoTargetAWDLIncludedCount %u Record %{sensitive, mask.hash}s",  buf,  0x1Cu);
      int v96 = *(_DWORD *)(v146 + 10928);
    }

    if (v96) {
      goto LABEL_266;
    }
    int v141 = a3;
    int v98 = v15;
    int v99 = *(_DWORD *)(v50 + 10932);
    BOOL v100 = v99 == 0;
    char v101 = 2 * (v99 == 0);
    char loga = 2;
  }

  else
  {
    uint64_t v102 = *(void *)(a2 + 32);
    if ((!AWDLInterfaceID || AWDLInterfaceID != v102) && (!WiFiAwareInterfaceID || WiFiAwareInterfaceID != v102))
    {
      int v110 = *v143 - 1;
      *unsigned int v143 = v110;
      CFStringRef v111 = (os_log_s *)mDNSLogCategory_State;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEBUG))
      {
        GetRRDisplayString_rdb(v7, (unsigned __int16 *)(*(void *)(a2 + 48) + 4LL), (_BYTE *)(v146 + 46976));
        *(_DWORD *)buf = 67109635;
        *(_DWORD *)int v148 = v110;
        *(_WORD *)&v148[4] = 2160;
        *(void *)&v148[6] = 1752392040LL;
        *(_WORD *)&v148[14] = 2085;
        *(void *)&v148[16] = v146 + 46976;
        _os_log_impl( (void *)&_mh_execute_header,  v111,  OS_LOG_TYPE_DEBUG,  "DecrementAutoTargetServices: AutoTargetServices %u Record %{sensitive, mask.hash}s",  buf,  0x1Cu);
        int v110 = *v143;
      }

      uint64_t v50 = v146;
      if (!v110)
      {
        for (uint64_t k = *(void *)(v146 + 12664); k; uint64_t k = *(void *)k)
        {
          if (*(_BYTE *)(k + 6374)) {
            DeadvertiseInterface(v146, k, 1);
          }
        }
      }

      goto LABEL_266;
    }

    int v103 = *(_DWORD *)(v50 + 10932) - 1;
    *(_DWORD *)(v50 + 10932) = v103;
    uint64_t v104 = (os_log_s *)mDNSLogCategory_State;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEBUG))
    {
      GetRRDisplayString_rdb(v7, (unsigned __int16 *)(*(void *)(a2 + 48) + 4LL), (_BYTE *)(v146 + 46976));
      *(_DWORD *)buf = 67109635;
      *(_DWORD *)int v148 = v103;
      *(_WORD *)&v148[4] = 2160;
      *(void *)&v148[6] = 1752392040LL;
      *(_WORD *)&v148[14] = 2085;
      *(void *)&v148[16] = v146 + 46976;
      uint64_t v50 = v146;
      _os_log_impl( (void *)&_mh_execute_header,  v104,  OS_LOG_TYPE_DEBUG,  "DecrementAutoTargetServices: AutoTargetAWDLOnlyCount %u Record %{sensitive, mask.hash}s",  buf,  0x1Cu);
    }

    if (*(_DWORD *)(v50 + 10928)) {
      goto LABEL_266;
    }
    int v99 = *(_DWORD *)(v50 + 10932);
    if (v99) {
      goto LABEL_266;
    }
    int v141 = a3;
    int v98 = v15;
    char loga = 0;
    BOOL v100 = 1;
    char v101 = 2;
  }

  uint64_t v105 = *(void *)(v50 + 12664);
  if (!v105)
  {
LABEL_257:
    LODWORD(v15) = v98;
    a3 = v141;
    uint64_t v50 = v146;
    if (!v99) {
      GetRandomUUIDLocalHostname((_BYTE *)(v146 + 10672));
    }
    goto LABEL_266;
  }

  while (2)
  {
    if (*(_BYTE *)(v105 + 6374))
    {
      uint64_t v106 = *(void *)(v105 + 6256);
      if (AWDLInterfaceID) {
        BOOL v107 = AWDLInterfaceID == v106;
      }
      else {
        BOOL v107 = 0;
      }
      if (v107 || (WiFiAwareInterfaceID ? (BOOL v108 = WiFiAwareInterfaceID == v106) : (BOOL v108 = 0), v108))
      {
        char v109 = v101;
        if (!v100) {
          goto LABEL_254;
        }
      }

      else
      {
        char v109 = loga;
        if (v138 != 2) {
          goto LABEL_254;
        }
      }

      DeadvertiseInterface(v146, v105, v109);
    }

          uint64_t v125 = *(void *)(v116 + 88);
          if (v125 && !*(_DWORD *)(v125 + 8)) {
            goto LABEL_229;
          }
          if (*(_DWORD *)(v116 + 52)) {
            goto LABEL_281;
          }
          if (v119)
          {
            uint64_t v126 = dword_100158BF8;
            rr_expire_time = dnssec_obj_rrset_get_rr_expire_time(v119);
            if (rr_expire_time - dword_100158BF8 < 1) {
              goto LABEL_281;
            }
            if (v126 + 939524096 - rr_expire_time <= 0 || rr_expire_time == 0) {
              uint64_t v129 = v126 + 939524096;
            }
            else {
              uint64_t v129 = rr_expire_time;
            }
            unsigned int v121 = *(void *)(v116 + 40);
            if (!v121)
            {
LABEL_248:
              uint64_t v137 = *(void *)(v116 + 64);
              if (v137)
              {
                unsigned int v138 = dnssec_obj_rrset_get_rr_expire_time(v137);
                if (v138 - dword_100158BF8 < 1) {
                  goto LABEL_281;
                }
                if (v129 - v138 > 0 && v138 != 0) {
                  uint64_t v129 = v138;
                }
              }

              if (*(_DWORD *)(v116 + 112))
              {
                int v140 = *(void *)(v116 + 88);
                if (!v140) {
                  goto LABEL_281;
                }
                expiration_time = resource_record_get_expiration_time(*(void *)(v140 + 56));
                if (expiration_time - dword_100158BF8 < 1) {
                  goto LABEL_281;
                }
                if (v129 - expiration_time > 0 && expiration_time != 0) {
                  uint64_t v129 = expiration_time;
                }
              }

              unsigned int v143 = *(void *)(v116 + 32);
              if (!v143) {
                unsigned int v143 = *(void *)(v116 + 40);
              }
              unsigned int v144 = v129 - dnssec_obj_rrset_get_time_received(v143);
              if (v144 >= 1000)
              {
                int v145 = v144 / 0x3E8u;
                if (v145 >= 0xE10) {
                  int v145 = 3600;
                }
                uint64_t v146 = v145 + (v145 >> 2) + 2;
                if (v146 <= 0xF) {
                  uint64_t v147 = 15;
                }
                else {
                  uint64_t v147 = v146;
                }
                int v148 = *(void *)(v116 + 32);
                if (v148 && dnssec_obj_rrset_needs_to_update_cache(v148, v147))
                {
                  uint64_t v149 = *(void *)(v116 + 32);
                }

                else
                {
                  int v150 = *(void *)(v116 + 40);
                  uint64_t v149 = *(void *)(v116 + 40);
                }

                _update_validated_cache_with_rrset(v149, v147);
              }

      if (v116 == v117)
      {
LABEL_219:
        uint64_t v118 = v115;
        uint64_t v119 = *(unsigned __int8 *)(v113 + 8);
        unsigned int v120 = *(void *)(v113 + 48);
        unsigned int v121 = *(unsigned __int16 *)(v113 + 20);
        if (v119 == 1)
        {
          int v122 = 0;
          uint64_t v123 = (void *)(v113 + 304);
          goto LABEL_256;
        }

        uint64_t v124 = *v294;
        if ((*(_BYTE *)(v113 + 123) & 1) != 0)
        {
LABEL_224:
          uint64_t v125 = v124 != 0;
        }

        else
        {
          if (v124 == 2)
          {
            uint64_t v124 = *v293;
            goto LABEL_224;
          }

          uint64_t v125 = 0;
        }

        uint64_t v126 = *(void *)(v113 + 304);
        if (!v126 || v125) {
          goto LABEL_254;
        }
        BOOL IsValidAnswer = ResourceRecordIsValidAnswer(v113);
        if (v119 != 8) {
          goto LABEL_253;
        }
        int v115 = v118;
        if (!IsValidAnswer || !*(_BYTE *)(v113 + 192)) {
          goto LABEL_253;
        }
        int v130 = UnsafeBufferPointer(*(uint64_t **)(v109 + 12624), v113, (uint64_t **)&v307);
        unsigned int v131 = v305;
        if (v130) {
          unsigned int v131 = v305 + 1;
        }
        if (*v306 || *(_WORD *)(a1 + 28912) || *v295) {
          unsigned int v132 = 1440LL;
        }
        else {
          unsigned int v132 = 8940LL;
        }
        int v110 = v299;
        unsigned __int16 v133 = v303 + v132;
        BOOL v19 = v131 == 0;
        uint64_t v134 = v302 + 14 * v131;
        v135 = v301;
        if (v19) {
          v135 = 1;
        }
        if (v135) {
          uint64_t v136 = 0;
        }
        else {
          uint64_t v136 = 11;
        }
        uint64_t v137 = PutResourceRecordTTLWithLimit( (unint64_t)v304,  v118,  v306,  v113 + 8,  0LL,  v133 - (v134 + v136),  v128,  v129);
        uint64_t v118 = v137;
        if (!v130)
        {
          if (v137) {
            goto LABEL_252;
          }
          goto LABEL_292;
        }

        if (!v137) {
          goto LABEL_292;
        }
        unsigned int v138 = *(void *)(v113 + 40);
        int v139 = *v306;
        int v140 = calloc(1uLL, 0x18uLL);
        if (!v140) {
          goto LABEL_549;
        }
        ++v305;
        *((_WORD *)v130 + 4) = v139 - 1;
        v140[1] = v130;
        v140[2] = v138;
        *int v140 = v307;
        v307 = v140;
LABEL_252:
        *(_BYTE *)(v113 + 192) = 0;
        uint64_t v126 = *(void *)(v113 + 304);
LABEL_253:
        SetNewRData(v113 + 8, v126, *(unsigned __int16 *)(v113 + 312), (uint64_t)a4, a5, a6, a7, a8);
        LOBYTE(v119) = *(_BYTE *)(v113 + 8);
LABEL_254:
        int v122 = !v125;
        uint64_t v123 = (void *)(v113 + 304);
        if ((v119 & 0x32) != 0) {
          *(_WORD *)(v113 + 14) |= 0x8000u;
        }
LABEL_256:
        uint64_t v142 = v118;
        int v145 = UnsafeBufferPointer(*(uint64_t **)(v109 + 12624), v113, (uint64_t **)&v307);
        uint64_t v146 = v305;
        if (v145) {
          uint64_t v146 = v305 + 1;
        }
        if (v122) {
          uint64_t v147 = *(unsigned int *)(v113 + 16);
        }
        else {
          uint64_t v147 = 0LL;
        }
        if (*v306 || *(_WORD *)(a1 + 28912) || *v295) {
          int v148 = 1440LL;
        }
        else {
          int v148 = 8940LL;
        }
        uint64_t v149 = v303 + v148;
        BOOL v19 = v146 == 0;
        int v150 = v302 + 14 * v146;
        _MD5_CTX v151 = v301;
        if (v19) {
          _MD5_CTX v151 = 1;
        }
        if (v151) {
          uint64_t v152 = 0;
        }
        else {
          uint64_t v152 = 11;
        }
        int v153 = PutResourceRecordTTLWithLimit( (unint64_t)v304,  v118,  v306,  v113 + 8,  v147,  v149 - (v150 + v152),  v143,  v144);
        int v141 = v153;
        if (v145)
        {
          if (v153)
          {
            uint64_t v154 = *(void *)(v113 + 40);
            __int128 v155 = *v306;
            __int128 v156 = calloc(1uLL, 0x18uLL);
            if (!v156) {
LABEL_549:
            }
              __break(1u);
            ++v305;
            *((_WORD *)v145 + 4) = v155 - 1;
            v156[1] = v145;
            v156[2] = v154;
            *__int128 v156 = v307;
            v307 = v156;
            *(_WORD *)(v113 + 14) &= ~0x8000u;
            char v109 = a1;
LABEL_276:
            __int128 v157 = 0;
            *(_BYTE *)(v113 + 192) = v122;
LABEL_279:
            if (*v123 && v122) {
              SetNewRData(v113 + 8, v120, v121, (uint64_t)a4, a5, a6, a7, a8);
            }
            int v110 = v299;
            if (!v300 && v122 && (*(_BYTE *)(v113 + 8) & 0x30) != 0 && !*(void *)(v113 + 200))
            {
              *(void *)(v113 + 200) = -1LL;
              if ((v157 & 1) == 0) {
                goto LABEL_287;
              }
            }

            else if ((v157 & 1) == 0)
            {
LABEL_287:
              if (*(void *)(v113 + 208) != -1LL || *(void *)(v113 + 32))
              {
                __int128 v158 = 0LL;
                goto LABEL_290;
              }

LABEL_254:
    uint64_t v105 = *(void *)v105;
    if (v105) {
      continue;
    }
    break;
  }

  uint64_t v50 = v146;
  LODWORD(v15) = v98;
  a3 = v141;
  if (!*(_DWORD *)(v146 + 10928))
  {
    int v98 = v15;
    int v99 = *(_DWORD *)(v146 + 10932);
    goto LABEL_257;
  }

LABEL_266:
  if (*(void *)(a2 + 32) || *(_BYTE *)(a2 + 122) || IsLocalDomain(*(_BYTE **)(a2 + 40)))
  {
    int v113 = v60;
    int v114 = v143[1];
    int v115 = v143[2];
    if (v115 + v114 == 1)
    {
      unsigned int v116 = *(_DWORD *)(v146 + 64) + 60000;
      if (v116 <= 1) {
        unsigned int v116 = 1;
      }
      *(_DWORD *)(v146 + 116) = v116;
    }

    int v117 = v114 - 1;
    v143[1] = v114 - 1;
    uint64_t v118 = (os_log_s *)mDNSLogCategory_State;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v50 = v146;
      GetRRDisplayString_rdb(v7, (unsigned __int16 *)(*(void *)(a2 + 48) + 4LL), (_BYTE *)(v146 + 46976));
      *(_DWORD *)buf = 67109891;
      *(_DWORD *)int v148 = v117;
      *(_WORD *)&v148[4] = 1024;
      *(_DWORD *)&v148[6] = v115;
      *(_WORD *)&v148[10] = 2160;
      *(void *)&v148[12] = 1752392040LL;
      *(_WORD *)&v148[20] = 2085;
      *(void *)&v148[22] = v146 + 46976;
      _os_log_impl( (void *)&_mh_execute_header,  v118,  OS_LOG_TYPE_DEBUG,  "DecrementAutoTargetServices: NumAllInterfaceRecords %u NumAllInterfaceQuestions %u %{sensitive, mask.hash}s",  buf,  0x22u);
      int v60 = v113;
    }

    else
    {
      int v60 = v113;
      uint64_t v50 = v146;
    }
  }

LABEL_276:
  if (*(void *)(v50 + 12648) == a2) {
    *(void *)(v50 + 12648) = *(void *)a2;
  }
  *(void *)a2 = 0LL;
  *(_BYTE *)(a2 + 8) = 0;
  if (*(void *)(a2 + 304)) {
    CompleteRDataUpdate(v50, a2, v89, v90, v91, v92, v93, v94);
  }
  if (a3 == 2 || a3 == 4)
  {
    if (a3 == 2) {
      uint64_t v119 = 4294901748LL;
    }
    else {
      uint64_t v119 = 4294901724LL;
    }
    RecordProbeFailure((_DWORD *)v50, a2);
    unsigned int v120 = *(_DWORD *)(v50 + 48);
    unsigned int v121 = *(_DWORD *)(v50 + 52) + 1;
    *(_DWORD *)(v50 + 52) = v121;
    mDNS_VerifyLockState("Drop Lock", 0, v120, v121, (uint64_t)"mDNS_Deregister_internal", 2520);
    int v122 = *(void (**)(uint64_t, uint64_t, uint64_t))(a2 + 104);
    if (v122) {
      v122(v50, a2, v119);
    }
    mDNS_VerifyLockState( "Reclaim Lock",  0,  *(_DWORD *)(v50 + 48),  *(_DWORD *)(v50 + 52),  (uint64_t)"mDNS_Deregister_internal",  2523);
    --*(_DWORD *)(v50 + 52);
    for (uint64_t m = *(void *)(v50 + 12632); m; uint64_t m = *(void *)m)
    {
      if (*(unsigned __int8 *)(m + 190) == 255)
      {
        D2D_stop_advertising_record(m, v123, v124, v125, v126, v127, v128, v129);
        mDNS_Deregister_internal(v50, m, v119);
        uint64_t m = v50 + 12632;
      }
    }
  }

  else
  {
    unsigned int v131 = *(_DWORD *)(v50 + 48);
    unsigned int v132 = *(_DWORD *)(v50 + 52) + 1;
    *(_DWORD *)(v50 + 52) = v132;
    mDNS_VerifyLockState("Drop Lock", 0, v131, v132, (uint64_t)"mDNS_Deregister_internal", 2510);
    unsigned __int16 v133 = (os_log_s *)mDNSLogCategory_State;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT))
    {
      GetRRDisplayString_rdb(v7, (unsigned __int16 *)(*(void *)(a2 + 48) + 4LL), (_BYTE *)(v50 + 46976));
      *(_DWORD *)buf = 141558275;
      *(void *)int v148 = 1752392040LL;
      *(_WORD *)&v148[8] = 2085;
      *(void *)&v148[10] = v50 + 46976;
      _os_log_impl( (void *)&_mh_execute_header,  v133,  OS_LOG_TYPE_DEFAULT,  "mDNS_Deregister_internal: callback with mStatus_MemFree for %{sensitive, mask.hash}s",  buf,  0x16u);
    }

    uint64_t v134 = *(void (**)(uint64_t, uint64_t, uint64_t))(a2 + 104);
    if (v134) {
      v134(v50, a2, 4294901504LL);
    }
    mDNS_VerifyLockState( "Reclaim Lock",  0,  *(_DWORD *)(v50 + 48),  *(_DWORD *)(v50 + 52),  (uint64_t)"mDNS_Deregister_internal",  2514);
    --*(_DWORD *)(v50 + 52);
  }

LABEL_138:
  mDNS_UpdateAllowSleep(v50);
  if ((_DWORD)v15 == 41) {
    return 0LL;
  }
  uint64_t v61 = mDNSGetTSRForAuthRecordNamed(*v142, __dst, v60);
  int v62 = v61;
  int v63 = *v142;
  if (*v142 && v61)
  {
    do
    {
      if (*((_WORD *)v63 + 6) != 41
        && *((_DWORD *)v63 + 6) == v60
        && SameDomainNameBytes((_BYTE *)v63[5], __dst))
      {
        int v62 = 0LL;
      }

      int v63 = (uint64_t *)*v63;
      if (v63) {
        BOOL v64 = v62 == 0LL;
      }
      else {
        BOOL v64 = 1;
      }
    }

    while (!v64);
  }

  if (!v62) {
    return 0LL;
  }
  int v65 = (os_log_s *)mDNSLogCategory_mDNS;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
  {
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_159;
    }
  }

  else
  {
    int v65 = (os_log_s *)mDNSLogCategory_mDNS_redacted;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
    {
LABEL_159:
      GetRRDisplayString_rdb((unsigned __int8 *)v62 + 8, (unsigned __int16 *)(v62[6] + 4), (_BYTE *)(v50 + 46976));
      *(_DWORD *)buf = 141558275;
      *(void *)int v148 = 1752392040LL;
      *(_WORD *)&v148[8] = 2085;
      *(void *)&v148[10] = v50 + 46976;
      _os_log_impl( (void *)&_mh_execute_header,  v65,  OS_LOG_TYPE_DEFAULT,  "Deregistering orphaned TSR - %{sensitive, mask.hash}s",  buf,  0x16u);
    }
  }

  mDNS_Deregister_internal(v50, v62, 3LL);
  if (!v53) {
    return 0LL;
  }
  uint64_t v54 = (uint64_t)mDNSGetTSRForCacheGroup(v53);
  if (v54)
  {
    int v68 = (os_log_s *)mDNSLogCategory_mDNS;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEBUG)) {
        goto LABEL_174;
      }
    }

    else
    {
      int v68 = (os_log_s *)mDNSLogCategory_mDNS_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEBUG))
      {
LABEL_174:
        GetRRDisplayString_rdb( (unsigned __int8 *)(v54 + 8),  (unsigned __int16 *)(*(void *)(v54 + 48) + 4LL),  (_BYTE *)(v50 + 46976));
        *(_DWORD *)buf = 141558275;
        *(void *)int v148 = 1752392040LL;
        *(_WORD *)&v148[8] = 2085;
        *(void *)&v148[10] = v50 + 46976;
        _os_log_impl( (void *)&_mh_execute_header,  v68,  OS_LOG_TYPE_DEBUG,  "Purging cached TSR record that matches orphaned TSR -- %{sensitive, mask.hash}s",  buf,  0x16u);
      }
    }

    mDNS_PurgeCacheResourceRecord((unsigned int *)v50, v54);
    return 0LL;
  }

  return v54;
}

              uint64_t v76 = v8;
              goto LABEL_139;
            }

            LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "request_callback: Reg/Add/Update/Remove %d require existing connection PID[%d][%s]",  a4,  a5,  a6,  a7,  a8,  v75);
          }

          break;
      }

      goto LABEL_2253;
    }

    break;
  }

  if ((v10 - 3) >= 2)
  {
    if (v10 == 1) {
      return;
    }
    LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "request_callback: req->ts %d != t_complete PID[%d][%s]",  a4,  a5,  a6,  a7,  a8,  v10);
  }

            __srca = v58;
          }

          else
          {
            __srca = 0;
          }

          uint64_t v87 = *(_DWORD *)(a1 + 184);
          BOOL v88 = *((_DWORD *)v15 + 14);
          uint64_t v89 = *(_DWORD *)(a1 + 236);
          uint64_t v90 = *(_DWORD *)(a1 + 172);
          __n_6.tv_sec = 0LL;
          __n_6.tv_nsec = 0LL;
          clock_gettime(_CLOCK_MONOTONIC_RAW, &__n_6);
          uint64_t v91 = LODWORD(__n_6.tv_sec) - *v20;
          uint64_t v92 = *(unsigned __int16 *)(v18 + 12);
          LODWORD(__n_6.tv_sec) = 67111683;
          HIDWORD(__n_6.tv_sec) = v87;
          LOWORD(__n_6.tv_nsec) = 1024;
          *(_DWORD *)((char *)&__n_6.tv_nsec + 2) = v88;
          HIWORD(__n_6.tv_nsec) = 2160;
          *(void *)int v115 = 1752392040LL;
          *(_WORD *)&v115[8] = 1040;
          unsigned int v116 = __srca;
          int v117 = 2101;
          uint64_t v118 = v56;
          uint64_t v119 = 1024;
          unsigned int v120 = v19;
          unsigned int v121 = 1024;
          int v122 = v89;
          uint64_t v123 = 2082;
          uint64_t v17 = (const char *)(a1 + 240);
          __int128 v86 = v110;
          uint64_t v124 = a1 + 240;
          uint64_t v125 = 1024;
          uint64_t v126 = v90;
          uint64_t v127 = 1024;
          uint64_t v128 = v91;
          uint64_t v129 = 1024;
          int v130 = v92;
          goto LABEL_140;
        }

        if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v39 = *(void *)(v18 + 40);
          if (v39)
          {
            int v40 = *(_BYTE **)(v18 + 40);
            if (v39 == -256) {
              goto LABEL_50;
            }
LABEL_47:
            int v41 = 257;
            if ((unint64_t)v40 < v39 + 256 && v40)
            {
              while (1)
              {
                BOOL v42 = *v40;
                if (v42 > 0x3F)
                {
LABEL_132:
                  int v41 = 257;
                  goto LABEL_135;
                }

                if (!*v40) {
                  break;
                }
                v40 += v42 + 1;
                if (v39 != -256) {
                  goto LABEL_47;
                }
LABEL_50:
                if (!v40) {
                  goto LABEL_132;
                }
              }

              int v41 = (_WORD)v40 - v39 + 1;
            }

void RmvAutoBrowseDomain( int a1, _BYTE *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = AutoBrowseDomains;
  if (AutoBrowseDomains)
  {
    uint64_t v11 = (void **)&AutoBrowseDomains;
    while (1)
    {
      int v12 = SameDomainNameBytes((_BYTE *)(v9 + 12), a2);
      unsigned __int16 v14 = *v11;
      if (v12)
      {
        if (v14[2] == a1) {
          break;
        }
      }

      uint64_t v9 = *(void *)v14;
      uint64_t v11 = (void **)*v11;
      if (!*(void *)v14) {
        goto LABEL_6;
      }
    }

    *uint64_t v11 = *(void **)v14;
    udsserver_automatic_browse_domain_changed((uint64_t)v14, 0, v13, a4, a5, a6, a7, a8);
    free(v14);
    uint64_t v15 = (os_log_s *)mDNSLogCategory_mDNS;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
      {
        if (a2)
        {
          uint64_t v17 = a2;
          if (a2 == (_BYTE *)-256LL) {
            goto LABEL_19;
          }
LABEL_16:
          int v18 = 257;
          if (v17 < a2 + 256 && v17)
          {
            while (1)
            {
              uint64_t v19 = *v17;
              if (v19 > 0x3F)
              {
LABEL_37:
                int v18 = 257;
                goto LABEL_42;
              }

              if (!*v17) {
                break;
              }
              v17 += v19 + 1;
              if (a2 != (_BYTE *)-256LL) {
                goto LABEL_16;
              }
LABEL_19:
              if (!v17) {
                goto LABEL_37;
              }
            }

            int v18 = (unsigned __int16)((_WORD)v17 - (_WORD)a2 + 1);
          }
        }

        else
        {
          int v18 = 0;
        }

        goto LABEL_42;
      }
    }

    else
    {
      uint64_t v15 = (os_log_s *)mDNSLogCategory_mDNS_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
      {
        if (a2)
        {
          uint64_t v21 = a2;
          if (a2 == (_BYTE *)-256LL) {
            goto LABEL_30;
          }
LABEL_27:
          int v18 = 257;
          if (v21 < a2 + 256 && v21)
          {
            while (1)
            {
              uint64_t v22 = *v21;
              if (v22 > 0x3F)
              {
LABEL_38:
                int v18 = 257;
                goto LABEL_42;
              }

              if (!*v21) {
                break;
              }
              v21 += v22 + 1;
              if (a2 != (_BYTE *)-256LL) {
                goto LABEL_27;
              }
LABEL_30:
              if (!v21) {
                goto LABEL_38;
              }
            }

            int v18 = (unsigned __int16)((_WORD)v21 - (_WORD)a2 + 1);
          }
        }

        else
        {
          int v18 = 0;
        }

LABEL_42:
        *(_DWORD *)buf = 141558787;
        uint64_t v24 = 1752392040LL;
        __int16 v25 = 1040;
        int v26 = v18;
        __int16 v27 = 2101;
        BOOL v28 = a2;
        __int16 v29 = 1024;
        int v30 = a1;
        _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_DEFAULT,  "Automatic browsing domain is removed - domain name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P, uid: %u",  buf,  0x22u);
      }
    }
  }

  else
  {
LABEL_6:
    LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "RmvAutoBrowseDomain: Got remove event for domain %##s not in list",  a4,  a5,  a6,  a7,  a8,  (int)a2);
  }

      if (v9)
      {
        while (!*((_BYTE *)v9 + 16))
        {
          uint64_t v9 = (uint64_t *)*v9;
          if (!v9) {
            goto LABEL_45;
          }
        }

    if (*(_BYTE *)(a2 + 2736)) {

    }
      internal_stop_advertising_service(a2 + 2736, 0, 0);
    if (*(_BYTE *)(a2 + 3912)) {

    }
      internal_stop_advertising_service(a2 + 3912, 0, 0);
  }

  if (*(_BYTE *)(a2 + 2736)) {
    mDNS_Deregister_internal(a1, a2 + 2728, 0LL);
  }
  if (*(_BYTE *)(a2 + 3912)) {
    mDNS_Deregister_internal(a1, a2 + 3904, 0LL);
  }
LABEL_50:
  if ((a3 & 2) != 0 && (v9 & 1) == 0)
  {
    uint64_t v16 = (os_log_s *)mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEBUG)) {
        goto LABEL_62;
      }
      uint64_t v19 = 136446210;
      int v20 = (const char *)(a2 + 6310);
    }

    else
    {
      uint64_t v16 = (os_log_s *)mDNSLogCategory_Default_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEBUG)) {
        goto LABEL_62;
      }
      uint64_t v19 = 136446210;
      int v20 = (const char *)(a2 + 6310);
    }

    _os_log_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_DEBUG,  "DeadvertiseInterface: Deadvertising randomized hostname on interface %{public}s",  (uint8_t *)&v19,  0xCu);
LABEL_62:
    if (*(_BYTE *)(a2 + 5088)) {
      mDNS_Deregister_internal(a1, a2 + 5080, 0LL);
    }
  }

  uint64_t v31 = Querier_GetDNSServiceManager();
  if (v31)
  {
    *(void *)buf = _NSConcreteStackBlock;
    *(void *)&buf[8] = 0x40000000LL;
    *(void *)&uint8_t buf[16] = __mdns_dns_service_manager_handle_wake_block_invoke;
    *(void *)&int v71 = &__block_descriptor_tmp_48;
    *((void *)&v71 + 1) = v31;
    mdns_dns_service_manager_enumerate(v31, (uint64_t)buf);
  }

  mDNSCoreRestartQueries(a1);
  uint64_t v32 = *(_DWORD *)(a1 + 64);
  else {
    int v33 = v32 + 1000;
  }
  *(_DWORD *)(a1 + 12692) = v33;
  int v34 = (os_log_s *)mDNSLogCategory_Default;
  if (gSensitiveLoggingEnabled == 1 && mDNSLogCategory_Default != mDNSLogCategory_State)
  {
    int v34 = (os_log_s *)mDNSLogCategory_Default_redacted;
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEBUG)) {
      goto LABEL_56;
    }
    goto LABEL_55;
  }

  if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEBUG))
  {
LABEL_55:
    *(_DWORD *)buf = 67109376;
    *(_DWORD *)&uint8_t buf[4] = v33 - v32;
    *(_WORD *)&buf[8] = 1024;
    *(_DWORD *)&buf[10] = v32;
    _os_log_impl( (void *)&_mh_execute_header,  v34,  OS_LOG_TYPE_DEBUG,  "mDNSCoreMachineSleep waking: NextSRVUpdate in %d %d",  buf,  0xEu);
  }

        int v18 = v16;
      }

      else
      {
        int v18 = 0;
      }

      goto LABEL_43;
    }
  }

    __break(1u);
  }

  KQueueUnlock((uint64_t)"DNSProxyStartHandler", v12, v13, v14, v15, v16, v17, v18);
  return v23;
}

void KQueueLoop(uint64_t a1)
{
  if (dnssd_server_init_s_once != -1) {
    dispatch_once(&dnssd_server_init_s_once, &__block_literal_global_909);
  }
  if (unicast_assist_init_s_once != -1) {
    dispatch_once(&unicast_assist_init_s_once, &__block_literal_global_115_4478);
  }
  if (_mrcs_server_queue_s_once != -1) {
    dispatch_once(&_mrcs_server_queue_s_once, &__block_literal_global_17);
  }
  *(void *)blocuint64_t k = _NSConcreteStackBlock;
  *(void *)&block[8] = 0x40000000LL;
  *(void *)&block[16] = __mrcs_server_set_dns_service_registration_handlers_block_invoke;
  v474 = &__block_descriptor_tmp_4_4201;
  v475[0] = kMRCSServerDNSServiceRegistrationHandlers;
  dispatch_async((dispatch_queue_t)_mrcs_server_queue_s_queue, block);
  if (_mrcs_server_queue_s_once != -1) {
    dispatch_once(&_mrcs_server_queue_s_once, &__block_literal_global_17);
  }
  *(void *)blocuint64_t k = _NSConcreteStackBlock;
  *(void *)&block[8] = 0x40000000LL;
  *(void *)&block[16] = __mrcs_server_set_dns_proxy_handlers_block_invoke;
  v474 = &__block_descriptor_tmp_4197;
  v475[0] = kMRCSServerDNSProxyHandlers;
  dispatch_async((dispatch_queue_t)_mrcs_server_queue_s_queue, block);
  if (_mrcs_server_queue_s_once != -1) {
    dispatch_once(&_mrcs_server_queue_s_once, &__block_literal_global_17);
  }
  *(void *)blocuint64_t k = _NSConcreteStackBlock;
  *(void *)&block[8] = 0x40000000LL;
  *(void *)&block[16] = __mrcs_server_set_discovery_proxy_handlers_block_invoke;
  v474 = &__block_descriptor_tmp_5_4202;
  v475[0] = kMRCSServerDiscoveryProxyHandlers;
  dispatch_async((dispatch_queue_t)_mrcs_server_queue_s_queue, block);
  if (_mrcs_server_queue_s_once != -1) {
    dispatch_once(&_mrcs_server_queue_s_once, &__block_literal_global_17);
  }
  *(void *)blocuint64_t k = _NSConcreteStackBlock;
  *(void *)&block[8] = 0x40000000LL;
  *(void *)&block[16] = __mrcs_server_set_record_cache_handlers_block_invoke;
  v474 = &__block_descriptor_tmp_6_4203;
  v475[0] = kMRCServerRecordCacheHandlers;
  dispatch_async((dispatch_queue_t)_mrcs_server_queue_s_queue, block);
  if (_mrcs_server_queue_s_once != -1) {
    dispatch_once(&_mrcs_server_queue_s_once, &__block_literal_global_17);
  }
  v453 = (__int128 *)(a1 + 10288);
  dispatch_async((dispatch_queue_t)_mrcs_server_queue_s_queue, &__block_literal_global_4204);
  pthread_mutex_lock(&stru_100150758);
  uint64_t v2 = (os_log_s **)&unk_100164000;
  unsigned __int8 v3 = (os_log_s *)mDNSLogCategory_Default;
  uint64_t v4 = &unk_100164000;
  uint64_t v5 = &unk_100164000;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
  {
    uint64_t v6 = os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT);
    if ((_DWORD)v6)
    {
LABEL_20:
      *(_DWORD *)blocuint64_t k = 67109376;
      *(_DWORD *)&block[4] = dword_100158BFC;
      *(_WORD *)&block[8] = 1024;
      *(_DWORD *)&block[10] = dword_100158BFC;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Starting time value 0x%08X (%d)", block, 0xEu);
    }
  }

  else
  {
    unsigned __int8 v3 = (os_log_s *)mDNSLogCategory_Default_redacted;
    uint64_t v6 = os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT);
    if ((_DWORD)v6) {
      goto LABEL_20;
    }
  }

  __s2 = (void *)(a1 + 10289);
  v452 = (__int128 *)(a1 + 10352);
  v450 = (void *)(a1 + 10353);
  v456 = (_BYTE *)(a1 + 46976);
  uint64_t v454 = a1;
  while (1)
  {
    memset(&eventlist, 0, sizeof(eventlist));
    int v455 = mDNSPlatformRawTime(v6, v7, v8, v9, v10, v11, v12, v13);
    uint64_t v21 = mDNS_TimeNow((_DWORD *)a1, v14, v15, v16, v17, v18, v19, v20);
    int v29 = v21;
    int v30 = *(_DWORD *)(*(void *)a1 + 500LL);
    if (v30 && (((_DWORD)v21 - v30) & 0x80000000) == 0)
    {
      *(_DWORD *)(*(void *)a1 + 500LL) = 0;
      mDNS_Lock_((unsigned int *)a1, (uint64_t)"mDNSDaemonIdle", 861);
      LogMsgWithLevel( v2[170],  OS_LOG_TYPE_DEFAULT,  "Note: SetDomainSecrets: no keychain support",  v31,  v32,  v33,  v34,  v35,  v447);
      mDNS_Unlock_(a1, (uint64_t)"mDNSDaemonIdle", 863);
    }

    int v36 = *(_DWORD *)(a1 + 8);
    if (v36 && ((v29 - v36) & 0x80000000) == 0) {
      mDNSMacOSXNetworkChanged(v21, v22, v23, v24, v25, v26, v27, v28);
    }
    int v37 = *(_DWORD *)(*(void *)a1 + 608LL);
    if (v37 && ((v29 - v37) & 0x80000000) == 0)
    {
      *(_DWORD *)(*(void *)a1 + 608LL) = 0;
      mdns_power_cancel_all_events(@"com.apple.mDNSResponder");
      xpc_object_t v38 = xpc_dictionary_create(0LL, 0LL, 0LL);
      xpc_dictionary_set_uint64(v38, "HelperMode", 5uLL);
      xpc_dictionary_set_uint64(v38, "powerreq_key", 0LL);
      xpc_dictionary_set_uint64(v38, "powerreq_interval", 0LL);
      int v44 = SendDict_ToServer(v38);
      if (v38) {
        xpc_release(v38);
      }
      if (mDNS_LoggingEnabled == 1) {
        LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "mDNSPowerRequest: Using XPC IPC returning error_code %d",  v39,  v40,  v41,  v42,  v43,  v44);
      }
    }

    unsigned int v45 = mDNS_Execute(a1);
    unsigned int v53 = *(_DWORD *)(a1 + 8);
    uint64_t v55 = *(void *)a1;
    int v56 = *(_DWORD *)(*(void *)a1 + 500LL);
    int v58 = *(_DWORD *)(v55 + 608);
    unsigned int v459 = v53;
    int v60 = *(_DWORD *)(v55 + 492);
    if (v60)
    {
      if (v60 - v29 < 0)
      {
        size_t v62 = *(unsigned __int8 *)(v55 + 172);
        if ((_DWORD)v62 != *(unsigned __int8 *)v453 || memcmp((const void *)(v55 + 173), __s2, v62))
        {
          LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "Name Conflict: Updated Computer Name from %#s to %#s",  v48,  v49,  v50,  v51,  v52,  v55 + 172);
          mDNSPreferencesSetNames(1, (__int128 *)(*(void *)a1 + 172LL), v453);
          uint64_t v63 = *(void *)a1;
          __int128 v64 = *v453;
          __int128 v65 = v453[1];
          __int128 v66 = v453[2];
          *(_OWORD *)(v63 + 2memset(v45, 0, 20) = v453[3];
          *(_OWORD *)(v63 + 204) = v66;
          *(_OWORD *)(v63 + 188) = v65;
          *(_OWORD *)(v63 + 172) = v64;
          uint64_t v55 = *(void *)a1;
        }

        size_t v67 = *(unsigned __int8 *)(v55 + 108);
        if ((_DWORD)v67 != *(unsigned __int8 *)v452 || memcmp((const void *)(v55 + 109), v450, v67))
        {
          LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "Name Conflict: Updated Local Hostname from %#s.local to %#s.local",  v48,  v49,  v50,  v51,  v52,  v55 + 108);
          mDNSPreferencesSetNames(2, (__int128 *)(*(void *)a1 + 108LL), v452);
          uint64_t v68 = *(void *)a1;
          *(_DWORD *)(v68 + 496) = 0;
          __int128 v69 = *v452;
          __int128 v70 = v453[5];
          __int128 v71 = v453[6];
          *(_OWORD *)(v68 + 156) = v453[7];
          *(_OWORD *)(v68 + 140) = v71;
          *(_OWORD *)(v68 + 124) = v70;
          *(_OWORD *)(v68 + 108) = v69;
          uint64_t v55 = *(void *)a1;
        }

        *(_DWORD *)(v55 + 492) = 0;
      }

      else
      {
        unsigned int v61 = v459;
        unsigned int v459 = v61;
      }
    }

    unsigned int v72 = mDNS_TimeNow(mDNSStorage, v46, v47, v48, v49, v50, v51, v52);
    if (!all_requests) {
      goto LABEL_118;
    }
    unsigned int v78 = v72;
    if (v72 <= 1) {
      int v79 = 1;
    }
    else {
      int v79 = v72;
    }
    int v466 = v79;
    unsigned int v469 = v72 + 1000;
    uint64_t v80 = &all_requests;
    uint64_t v81 = (_BYTE *)&unk_100158000;
    do
    {
      timeout.tv_sec = 0LL;
      __darwin_time_t v82 = *v80;
      timeout.tv_sec = v82;
      if (*(void (**)(uint64_t))(v82 + 96) == resolve_termination_callback)
      {
        uint64_t v91 = *(void *)(v82 + 120);
        int v92 = *(_DWORD *)(v91 + 1332);
        if (v92)
        {
          if (((v78 - v92) & 0x80000000) == 0)
          {
            *(_DWORD *)(v91 + 1332) = 0;
            if (*(_BYTE *)(v91 + 1337)) {
              BOOL v93 = 1;
            }
            else {
              BOOL v93 = *(void *)(v91 + 1312) != 0LL;
            }
            if (*(_BYTE *)(v91 + 1338))
            {
              BOOL v94 = 1;
              if (!v93) {
                goto LABEL_68;
              }
            }

            else
            {
              BOOL v94 = *(void *)(v91 + 1320) != 0LL;
              if (!v93) {
                goto LABEL_68;
              }
            }

            if (v94) {
              LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "Client application PID[%d](%s) has received results for DNSServiceResolve(%##s) yet remains active over two minutes.",  v73,  v74,  v75,  v76,  v77,  *(_DWORD *)(v82 + 172));
            }
          }
        }
      }

LABEL_106:
      if ((*(_DWORD *)(v82 + 168) & 0x80000000) != 0)
      {
        *uint64_t v80 = *(void *)(v82 + 16);
        request_state_forget(&timeout);
      }

      else
      {
        uint64_t v80 = (__darwin_time_t *)(v82 + 16);
      }
    }

    while (*v80);
LABEL_118:
    if (dnssd_server_idle_s_once != -1) {
      dispatch_once(&dnssd_server_idle_s_once, &__block_literal_global_12);
    }
    a1 = v454;
    dispatch_source_merge_data((dispatch_source_t)dnssd_server_idle_s_source, 1uLL);
    if (&_NEHelperTrackerGetAppInfo || _os_feature_enabled_impl("symptomsd", "networking_transparency"))
    {
      uint64_t v118 = (void *)s_head_0;
      if (s_head_0)
      {
        do
        {
          _cache_item_report((uint64_t)v118);
          uint64_t v118 = (void *)*v118;
        }

        while (v118);
      }
    }

    uint64_t v119 = _os_feature_enabled_impl("mDNSResponder", "unicast_assist_cache");
    if (!(_DWORD)v119) {
      goto LABEL_198;
    }
    uint64_t v119 = mDNS_TimeNow(mDNSStorage, v120, v121, v122, v123, v124, v125, v126);
    uint64_t v127 = s_interface_head_0;
    int v128 = v119;
    uint64_t v129 = 0LL;
    uint64_t v457 = 0LL;
    unint64_t v130 = 0LL;
    while (2)
    {
      v460 = *(uint64_t **)v127;
      v130 += 40LL;
      unsigned int v131 = *(void **)(v127 + 8);
      v462 = (void *)(v127 + 8);
      if (!v131) {
        goto LABEL_166;
      }
      uint64_t v461 = v127;
      v458 = v129;
      unint64_t v467 = v130;
      unsigned int v132 = 0LL;
      unsigned int v464 = 0;
      while (2)
      {
        unsigned __int16 v133 = (void *)*v131;
        uint64_t v134 = (void *)v131[1];
        if (!v134) {
          goto LABEL_152;
        }
        unsigned int v135 = 0;
        uint64_t v136 = 0LL;
        while (2)
        {
          uint64_t v137 = v134;
          uint64_t v134 = (void *)*v134;
          int v138 = v128 - *((_DWORD *)v137 + 3);
          if (v138 >= 86400000)
          {
            id v140 = _unicast_assist_cache_log();
            int v145 = (os_log_s *)objc_claimAutoreleasedReturnValue(v140);
            if (!os_log_type_enabled(v145, OS_LOG_TYPE_DEBUG)) {
              goto LABEL_141;
            }
            int v141 = *((_DWORD *)v137 + 2);
            *(void *)blocuint64_t k = 0x1404120302LL;
            *(_WORD *)&block[8] = 2098;
            *(void *)&block[10] = v131 + 2;
            *(_WORD *)&block[18] = 1024;
            *(_DWORD *)&block[20] = v141;
            uint64_t v142 = v145;
            unsigned int v143 = "unicast assist qhash flushed (aged) - %{public, mdnsresponder:ip_addr}.20P qhash %x";
            goto LABEL_149;
          }

          if (v138 < 10000 || *((_BYTE *)v137 + 16) == 0)
          {
            ++v135;
            goto LABEL_144;
          }

          id v144 = _unicast_assist_cache_log();
          int v145 = (os_log_s *)objc_claimAutoreleasedReturnValue(v144);
          if (os_log_type_enabled(v145, OS_LOG_TYPE_DEBUG))
          {
            int v149 = *((_DWORD *)v137 + 2);
            *(void *)blocuint64_t k = 0x1404120302LL;
            *(_WORD *)&block[8] = 2098;
            *(void *)&block[10] = v131 + 2;
            *(_WORD *)&block[18] = 1024;
            *(_DWORD *)&block[20] = v149;
            uint64_t v142 = v145;
            unsigned int v143 = "unicast assist qhash flushed (pending) - %{public, mdnsresponder:ip_addr}.20P qhash %x";
LABEL_149:
            _os_log_debug_impl((void *)&_mh_execute_header, v142, OS_LOG_TYPE_DEBUG, v143, block, 0x18u);
          }

LABEL_141:
          uint64_t v147 = v137;
          int v148 = v131 + 1;
          if ((void *)v131[1] != v137)
          {
            uint64_t v147 = *v136;
            int v148 = v136;
          }

          *int v148 = *v147;
          free(v137);
          uint64_t v137 = 0LL;
LABEL_144:
          if (v137) {
            uint64_t v136 = (void **)v137;
          }
          if (v134) {
            continue;
          }
          break;
        }

        if (v135)
        {
          ++v464;
          v467 += 24LL * v135 + 40;
          uint64_t v4 = (void *)&unk_100164000;
          goto LABEL_160;
        }

    int v56 = DNSTypeName(*(unsigned __int16 *)(a4 + 4));
    __int128 v69 = 141558787;
    __int128 v70 = 1752392040LL;
    __int128 v71 = 1040;
    unsigned int v72 = v25;
    uint64_t v73 = 2101;
    uint64_t v74 = v23;
    uint64_t v75 = 2082;
    uint64_t v76 = v56;
    uint64_t v57 = "Attempt to put kDNSRecordTypeUnregistered %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%{public}s)";
    goto LABEL_142;
  }

  return v12;
}

LABEL_198:
    int v190 = mDNSPlatformRawTime(v119, v120, v121, v122, v123, v124, v125, v126) - v455;
    unsigned int v191 = &unk_100164000;
    if (v190 >= WatchDogReportingThreshold)
    {
      uint64_t v192 = (os_log_s *)mDNSLogCategory_Default;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == v4[171])
      {
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_204;
        }
      }

      else
      {
        uint64_t v192 = (os_log_s *)*((void *)v5 + 172);
        if (os_log_type_enabled(v192, OS_LOG_TYPE_DEFAULT))
        {
LABEL_204:
          *(_DWORD *)blocuint64_t k = 67109120;
          *(_DWORD *)&block[4] = v190;
          _os_log_impl( (void *)&_mh_execute_header,  v192,  OS_LOG_TYPE_DEFAULT,  "WARNING: Idle task took %d ms to complete",  block,  8u);
        }
      }
    }

    int v193 = mDNS_TimeNow((_DWORD *)a1, v183, v184, v185, v186, v187, v188, v189);
    int v194 = *(_DWORD *)(a1 + 76);
    if (v194)
    {
      char v195 = (unsigned __int8 *)xmmword_10015BD08;
      if ((void)xmmword_10015BD08)
      {
        while (1)
        {
          int v196 = (os_log_s *)mDNSLogCategory_Default;
          if (gSensitiveLoggingEnabled == 1 && mDNSLogCategory_Default != v4[171]) {
            break;
          }
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_215;
          }
LABEL_216:
          if (mDNS_LoggingEnabled == 1) {
            usleep(0x2710u);
          }
          char v195 = *(unsigned __int8 **)v195;
          if (!v195)
          {
            int v194 = *(_DWORD *)(a1 + 76);
            goto LABEL_220;
          }
        }

        int v196 = (os_log_s *)*((void *)v5 + 172);
        if (!os_log_type_enabled(v196, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_216;
        }
LABEL_215:
        GetRRDisplayString_rdb(v195 + 8, (unsigned __int16 *)(*((void *)v195 + 6) + 4LL), v456);
        *(_DWORD *)blocuint64_t k = 141558275;
        *(void *)&block[4] = 1752392040LL;
        *(_WORD *)&block[12] = 2085;
        *(void *)&block[14] = v456;
        _os_log_impl( (void *)&_mh_execute_header,  v196,  OS_LOG_TYPE_DEFAULT,  "Cannot exit yet; Resource Record still exists: %{sensitive, mask.hash}s",
          block,
          0x16u);
        goto LABEL_216;
      }

            uint64_t v18 = (_DWORD *)(a1 + 19868);
            __int128 v65 = v323;
            goto LABEL_83;
          }

          uint64_t v322 = (unsigned __int8 *)(v81 + 8);
          uint64_t v18 = (_DWORD *)(a1 + 19868);
          uint64_t v27 = v89;
          uint64_t v17 = a1 + 37865;
          if (Authorities && *(_WORD *)(v11 + 8))
          {
            uint64_t v136 = 0;
            while (1)
            {
              uint64_t v137 = GetLargeResourceRecord(a1, v11, v98, v27, v382, 160, v344);
              if (!v137) {
                goto LABEL_184;
              }
              uint64_t v98 = v137;
              int v138 = *(void **)(a1 + 37920);
              if (resource_records_have_same_dnssec_rr_category((uint64_t)v138, *(void *)(v81 + 64)))
              {
                if (*(unsigned __int16 *)(a1 + 37868) == *(unsigned __int16 *)(v81 + 12)
                  && *(unsigned __int16 *)(a1 + 37870) == *(unsigned __int16 *)(v81 + 14)
                  && *(unsigned __int16 *)(a1 + 37876) == *(unsigned __int16 *)(v81 + 20)
                  && *(_DWORD *)(a1 + 37884) == *(_DWORD *)(v81 + 28))
                {
                  int v139 = SameRDataBody( (uint64_t)v341,  (unsigned __int16 *)(*(void *)(v81 + 48) + 4LL),  (uint64_t (*)(uint64_t, unsigned __int16 *))SameDomainName);
                  int v138 = *(void **)(a1 + 37920);
                  if (v139) {
                    break;
                  }
                }
              }

              *int v341 = 0;
              *(_WORD *)(a1 + 37966) = 0;
              *int v354 = 0;
              if (v138)
              {
                ref_count_obj_release(v138);
                *(void *)(a1 + 379memset(v45, 0, 20) = 0LL;
              }
            }

            *int v341 = 0;
            *(_WORD *)(a1 + 37966) = 0;
            *int v354 = 0;
            if (v138)
            {
              ref_count_obj_release(v138);
              *(void *)(a1 + 379memset(v45, 0, 20) = 0LL;
            }

            size_t v67 = a4;
            __int128 v65 = v323;
            __int128 v66 = (os_log_s **)&unk_100164000;
            goto LABEL_83;
          }

        __break(1u);
      }

      goto LABEL_139;
    }

    if (*(_WORD *)(a2 + 20))
    {
      id v157 = v15;
      uint64_t v21 = 0LL;
      uint64_t v22 = (char *)&unk_100164138;
      LODWORD(vmemset(v45, 0, 20) = 512;
      goto LABEL_30;
    }

    unsigned int v45 = mDNSLogCategory_mDNS;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_141;
      }
      uint64_t v46 = v12[46];
      uint64_t v47 = *(_DWORD *)(v11 + 56);
      uint64_t v48 = *(void *)(a2 + 40);
      if (v48)
      {
        uint64_t v63 = *(_BYTE **)(a2 + 40);
        if (v48 == -256) {
          goto LABEL_97;
        }
LABEL_94:
        __int128 v64 = 257;
        if ((unint64_t)v63 < v48 + 256 && v63)
        {
          while (1)
          {
            __int128 v65 = *v63;
            if (v65 > 0x3F)
            {
LABEL_191:
              __int128 v64 = 257;
              goto LABEL_195;
            }

            if (!*v63) {
              break;
            }
            v63 += v65 + 1;
            if (v48 != -256) {
              goto LABEL_94;
            }
LABEL_97:
            if (!v63) {
              goto LABEL_191;
            }
          }

          __int128 v64 = (_WORD)v63 - v48 + 1;
        }

      *(_BYTE *)(a1 + 60) = 1;
      *(_DWORD *)(a1 + 52) = v23;
      goto LABEL_199;
    }
  }

  uint64_t v126 = -6736;
  LODWORD(v23) = v25;
  if ((_DWORD)v25) {
    goto LABEL_198;
  }
LABEL_199:
  free(v123);
  return v126;
}

LABEL_220:
      if (v193 - v194 < 0 && *(void *)(a1 + 12624))
      {
        int v199 = v459;
        unsigned int v459 = v199;
        goto LABEL_225;
      }

    unlink_and_free_service_instance((void *)v10, a2, v12, a4, a5, a6, a7, a8);
    return;
  }

  external_stop_advertising_helper(v10, a2, v12, a4, a5, a6, a7, a8);
  if (*(_BYTE *)(v48 + 1612) && !CountPeerRegistrations(a2))
  {
    IncrementLabelSuffix((unsigned __int8 *)(a1 + 10288), 1);
    mDNS_ConfigChanged(a1);
  }

  else
  {
    if (*(_BYTE *)(v10 + 25)) {
      SendServiceRemovalNotification(a2);
    }
    mDNS_RenameAndReregisterService((unsigned int *)a1, a2, 0LL);
  }

LABEL_533:
      v446 = (os_log_s *)*((void *)v191 + 170);
      if (gSensitiveLoggingEnabled != 1 || v446 == (os_log_s *)v4[171])
      {
        if (os_log_type_enabled(*((os_log_t *)v191 + 170), OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)blocuint64_t k = 0;
LABEL_539:
          _os_log_impl((void *)&_mh_execute_header, v446, OS_LOG_TYPE_DEFAULT, "mDNS_FinalExit", block, 2u);
        }
      }

      else
      {
        v446 = (os_log_s *)*((void *)v5 + 172);
        if (os_log_type_enabled(v446, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)blocuint64_t k = 0;
          goto LABEL_539;
        }
      }

      mDNS_FinalExit();
      usleep(0x3E8u);
      exit(0);
    }

LABEL_225:
    if (!*(_DWORD *)(a1 + 156)) {
      goto LABEL_410;
    }
    mDNS_Lock_((unsigned int *)mDNSStorage, (uint64_t)"mDNSCoreReadyForSleep", 8452);
    if (dword_100158C50 || dword_100158C54 - v193 >= 1 && dword_100158C70 - v193 > 0) {
      goto LABEL_227;
    }
    dword_100158C70 = v193 + 0x40000000;
    uint64_t v277 = xmmword_10015BD30;
    if ((void)xmmword_10015BD30)
    {
      while (!*(_BYTE *)(v277 + 16))
      {
        uint64_t v277 = *(void *)v277;
        if (!v277) {
          goto LABEL_287;
        }
      }

LABEL_324:
      if ((*(_DWORD *)(v277 + 2716) & 0x80000000) == 0)
      {
        int v300 = *(_DWORD *)(v277 + 2720);
        if (v193 - v300 < 0)
        {
          if (dword_100158C70 - v300 >= 1) {
            dword_100158C70 = *(_DWORD *)(v277 + 2720);
          }
        }

        else
        {
          if (mDNS_LoggingEnabled == 1) {
            LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "mDNSCoreReadyForSleep: retrying for %s SPS %d try %d",  v200,  v201,  v202,  v203,  v204,  v277 + 6310);
          }
          SendSPSRegistration((uint64_t)mDNSStorage, v277, 0, v200, v201, v202, v203, v204);
        }
      }

      while (1)
      {
        uint64_t v277 = *(void *)v277;
        if (!v277) {
          break;
        }
        if (*(_BYTE *)(v277 + 16)) {
          goto LABEL_324;
        }
      }

LABEL_287:
      v278 = (uint64_t *)xmmword_10015BD30;
      if ((void)xmmword_10015BD30)
      {
        while (!*((_BYTE *)v278 + 16))
        {
          v278 = (uint64_t *)*v278;
          if (!v278) {
            goto LABEL_290;
          }
        }

    *(_DWORD *)(a1 + 168) = *(_DWORD *)(a1 + 64) + 1800000;
  }

  v861 = (_WORD *)(a1 + 28904);
  int v153 = a1 + 12656;
  uint64_t v154 = (void *)(a1 + 208);
  int v155 = *(void *)(a1 + 208);
  __int128 v156 = (os_log_s **)&unk_100164000;
  v845 = (void *)(a1 + 208);
  if (!v155) {
    goto LABEL_477;
  }
  id v157 = 0;
  __int128 v158 = (_BYTE *)(a1 + 46976);
  while (2)
  {
    __int128 v159 = v157;
    __int128 v160 = *(_DWORD *)(v155 + 204);
    if (v160)
    {
      if (*(_DWORD *)(a1 + 64) - v160 < 0) {
        goto LABEL_477;
      }
    }

    uint64_t v161 = CacheGroupForName(a1, *(_DWORD *)(v155 + 200), (_BYTE *)(v155 + 356));
    if (v161) {
      CheckCacheExpiration(a1, *(_DWORD *)(v155 + 200) % 0x1F3u, (uint64_t)v161, (uint64_t)v4, v5, v6, v7, v8, v820);
    }
    if (*v154 == v155)
    {
      *(void *)(a1 + 208) = *(void *)(v155 + 8);
      if (*(_BYTE *)(a1 + 56)) {
        LogMsgWithLevel( v156[170],  OS_LOG_TYPE_DEFAULT,  "AnswerNewQuestion ERROR! Cache already locked!",  (uint64_t)v4,  v5,  v6,  v7,  v8,  v820);
      }
      *(_BYTE *)(a1 + 56) = 1;
      uint64_t v164 = *(void *)(a1 + 216);
      if (v164)
      {
        uint64_t v165 = (os_log_s *)mDNSLogCategory_Default;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
        {
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_323;
          }
          v856 = *(_DWORD *)(v164 + 252);
          __int128 v166 = bswap32(*(unsigned __int16 *)(v164 + 320)) >> 16;
          uint64_t v169 = (_BYTE *)(v164 + 356);
          if (v164 == -612)
          {
LABEL_313:
            while (v169)
            {
              uint64_t v170 = *v169;
              if (!*v169)
              {
                int v171 = (_WORD)v169 - (v164 + 356) + 1;
                goto LABEL_322;
              }

              v169 += v170 + 1;
              if (v164 != -612) {
                goto LABEL_312;
              }
            }
          }

          else
          {
LABEL_312:
          }

          int v171 = 257;
        }

        else
        {
          uint64_t v165 = (os_log_s *)mDNSLogCategory_Default_redacted;
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_323;
          }
          v856 = *(_DWORD *)(v164 + 252);
          __int128 v166 = bswap32(*(unsigned __int16 *)(v164 + 320)) >> 16;
          int v167 = (_BYTE *)(v164 + 356);
          if (v164 == -612)
          {
LABEL_305:
            while (v167)
            {
              __int128 v168 = *v167;
              if (!*v167)
              {
                int v171 = (_WORD)v167 - (v164 + 356) + 1;
                goto LABEL_322;
              }

              v167 += v168 + 1;
              if (v164 != -612) {
                goto LABEL_304;
              }
            }
          }

          else
          {
LABEL_304:
          }

          int v171 = 257;
        }

LABEL_315:
        int v285 = *((_DWORD *)v278 + 679);
        if (v285) {
          int v285 = (v285 - 1) / 3;
        }
        if ((v278[82 * v285 + 111] & 0x8000000000000000LL) == 0)
        {
          v280 = (void *)&unk_10015D000;
          if (mDNS_LoggingEnabled == 1)
          {
            uint64_t v286 = mDNSLogCategory_Default;
            int v287 = (_DWORD)v278 + 6310;
            DNSTypeName(WORD1(v278[82 * v285 + 125]));
            v288 = (os_log_s *)v286;
            v280 = (void *)&unk_10015D000;
            LogMsgWithLevel( v288,  OS_LOG_TYPE_DEFAULT,  "mDNSCoreReadyForSleep: waiting for SPS Resolve %s %##s (%s)",  v289,  v290,  v291,  v292,  v293,  v287);
          }

          goto LABEL_337;
        }

        while (1)
        {
          v278 = (uint64_t *)*v278;
          if (!v278) {
            break;
          }
          if (*((_BYTE *)v278 + 16)) {
            goto LABEL_315;
          }
        }
      }
    }

LABEL_290:
    v279 = (uint64_t *)xmmword_10015BD08;
    v280 = &unk_10015D000;
    if (!(void)xmmword_10015BD08)
    {
LABEL_297:
      v282 = (void *)qword_10015D928;
      if (qword_10015D928)
      {
        CloseSocketSet(qword_10015D928);
        free(v282);
        qword_10015D928 = 0LL;
      }

      uint64_t v283 = qword_100158C80;
      unsigned int v191 = &unk_100164000;
      if (qword_100158C80)
      {
        while (!*(_WORD *)(v283 + 320)
             || !*(_BYTE *)(v283 + 612)
             || *(_DWORD *)(v283 + 272)
             || !*(void *)(v283 + 112))
        {
          uint64_t v283 = *(void *)(v283 + 8);
          if (!v283) {
            goto LABEL_305;
          }
        }

        if (mDNS_LoggingEnabled == 1)
        {
          v424 = (os_log_s *)mDNSLogCategory_Default;
          int v425 = v283 + 356;
          DNSTypeName(*(unsigned __int16 *)(v283 + 322));
          LogMsgWithLevel( v424,  OS_LOG_TYPE_DEFAULT,  "mDNSCoreReadyForSleep: waiting for LLQ %##s (%s)",  v426,  v427,  v428,  v429,  v430,  v425);
        }
      }

      else
      {
LABEL_305:
        v284 = (uint64_t *)xmmword_10015BD08;
        if (!(void)xmmword_10015BD08)
        {
LABEL_312:
          int v206 = 0;
          char v205 = 1;
          int v207 = 8517;
          goto LABEL_228;
        }

        while (v284[4]
             || *((_BYTE *)v284 + 122)
             || IsLocalDomain((_BYTE *)v284[5])
             || *((_DWORD *)v284 + 86) != 5
             || !v284[48])
        {
          v284 = (uint64_t *)*v284;
          if (!v284) {
            goto LABEL_312;
          }
        }

        if (mDNS_LoggingEnabled == 1)
        {
          v431 = (os_log_s *)mDNSLogCategory_Default;
          int v432 = *((_DWORD *)v284 + 91);
          GetRRDisplayString_rdb((unsigned __int8 *)v284 + 8, (unsigned __int16 *)(v284[6] + 4), word_100164338);
          int v449 = v432;
          unsigned int v191 = &unk_100164000;
          LogMsgWithLevel( v431,  OS_LOG_TYPE_DEFAULT,  "mDNSCoreReadyForSleep: waiting for Record updateIntID 0x%x 0x%x (updateid %d) %s",  v433,  v434,  v435,  v436,  v437,  v449);
        }
      }

              *(void *)(v113 + 224) = v158;
            }

            int v115 = v141;
            goto LABEL_292;
          }

          *(_WORD *)(v113 + 14) &= ~0x8000u;
        }

        else
        {
          *(_WORD *)(v113 + 14) &= ~0x8000u;
          if (v153) {
            goto LABEL_276;
          }
        }

        id v157 = 1;
        int v141 = v142;
        goto LABEL_279;
      }

LABEL_227:
      char v205 = 0;
      int v206 = 1;
      int v207 = 8559;
      goto LABEL_228;
    }

    while (1)
    {
      if ((v279[4] || *((_BYTE *)v279 + 122) || IsLocalDomain((_BYTE *)v279[5]))
        && *((unsigned __int8 *)v279 + 8) >= 2u)
      {
        int v281 = *((_DWORD *)v279 + 91);
        if (v279[45]) {
          break;
        }
      }

      v279 = (uint64_t *)*v279;
      if (!v279) {
        goto LABEL_297;
      }
    }

    if (mDNS_LoggingEnabled == 1)
    {
      uint64_t v301 = mDNSLogCategory_Default;
      GetRRDisplayString_rdb((unsigned __int8 *)v279 + 8, (unsigned __int16 *)(v279[6] + 4), word_100164338);
      v302 = (os_log_s *)v301;
      v280 = &unk_10015D000;
      LogMsgWithLevel( v302,  OS_LOG_TYPE_DEFAULT,  "mDNSCoreReadyForSleep: waiting for SPS updateIntID 0x%x 0x%x (updateid %d) %s",  v303,  v304,  v305,  v306,  v307,  v281);
    }

LABEL_337:
    if (v193 - dword_100158C54 < 0)
    {
      char v205 = 0;
      int v206 = 1;
    }

    else
    {
      LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "Failed to register with SPS, now sending goodbyes",  v200,  v201,  v202,  v203,  v204,  v447);
      v313 = v280;
      v314 = (void *)v280[293];
      if (v314)
      {
        CloseSocketSet((uint64_t)v314);
        free(v314);
        v313[293] = 0LL;
      }

      v315 = (uint64_t *)xmmword_10015BD30;
      if ((void)xmmword_10015BD30)
      {
        while (!*((_BYTE *)v315 + 16))
        {
          v315 = (uint64_t *)*v315;
          if (!v315) {
            goto LABEL_343;
          }
        }

LABEL_508:
        if ((*((_DWORD *)v315 + 59) & 0x80000000) == 0)
        {
          if (mDNS_LoggingEnabled == 1)
          {
            v418 = (os_log_s *)mDNSLogCategory_Default;
            DNSTypeName(*((unsigned __int16 *)v315 + 501));
            LogMsgWithLevel( v418,  OS_LOG_TYPE_DEFAULT,  "ReadyForSleep mDNS_DeactivateNetWake %s %##s (%s)",  v419,  v420,  v421,  v422,  v423,  (_DWORD)v315 + 6310);
          }

          mDNS_DeactivateNetWake_internal((__int128 *)v315);
        }

        while (1)
        {
          v315 = (uint64_t *)*v315;
          if (!v315) {
            break;
          }
          if (*((_BYTE *)v315 + 16)) {
            goto LABEL_508;
          }
        }
      }

LABEL_343:
      for (uint64_t i = (uint64_t *)xmmword_10015BD08; i; uint64_t i = (uint64_t *)*i)
      {
        if (i[4] || *((_BYTE *)i + 122) || IsLocalDomain((_BYTE *)i[5]))
        {
          int v317 = *((_DWORD *)i + 91);
          if (i[45])
          {
            if (mDNS_LoggingEnabled == 1)
            {
              v318 = (os_log_s *)mDNSLogCategory_Default;
              GetRRDisplayString_rdb((unsigned __int8 *)i + 8, (unsigned __int16 *)(i[6] + 4), word_100164338);
              LogMsgWithLevel( v318,  OS_LOG_TYPE_DEFAULT,  "ReadyForSleep clearing updateIntID 0x%x 0x%x (updateid %d) for %s",  v319,  v320,  v321,  v322,  v323,  v317);
            }

            i[45] = 0LL;
          }
        }
      }

      dword_100158C54 = v193 + 1000;
      int v206 = 1;
      SendSleepGoodbyes((uint64_t)mDNSStorage, 1LL, 1LL, v308, v309, v310, v311, v312);
      char v205 = 0;
    }

    int v207 = 8559;
    unsigned int v191 = &unk_100164000;
LABEL_228:
    mDNS_Unlock_((uint64_t)mDNSStorage, (uint64_t)"mDNSCoreReadyForSleep", v207);
    int v216 = byte_100158C45;
    if (!byte_100158C45 || (v205 & 1) != 0)
    {
      *(void *)(mDNSStorage[0] + 600) = 0LL;
      if (v216) {
        goto LABEL_233;
      }
      LogMsgWithLevel( *((os_log_s **)v191 + 170),  OS_LOG_TYPE_DEFAULT,  "AllowSleepNow: Sleep request was canceled with %d ticks remaining",  v211,  v212,  v213,  v214,  v215,  dword_100158C54 - v193);
      int v276 = 0;
      goto LABEL_402;
    }

    if (v193 - dword_100158C54 < 0)
    {
      unsigned int v294 = v459;
      unsigned int v459 = v294;
    }

    else
    {
      *(void *)(mDNSStorage[0] + 600) = 0LL;
LABEL_233:
      if (byte_100158C47[0]
        && (time_t HaveAdvertisedMulticastServices = mDNSCoreHaveAdvertisedMulticastServices(xmmword_10015BD08),
            (_DWORD)HaveAdvertisedMulticastServices))
      {
        *(void *)blocuint64_t k = SCDynamicStoreKeyCreateNetworkServiceEntity( 0LL,  kSCDynamicStoreDomainState,  kSCCompAnyRegex,  kSCEntNetDHCP);
        int v470 = v206;
        if (!*(void *)block)
        {
          LogMsgWithLevel( *((os_log_s **)v191 + 170),  OS_LOG_TYPE_DEFAULT,  "DHCPWakeTime: SCDynamicStoreKeyCreateNetworkServiceEntity failed\n",  v217,  v218,  v219,  v220,  v221,  v447);
          int v228 = 86400;
          goto LABEL_356;
        }

        CFRange v227 = CFArrayCreate(0LL, (const void **)block, 1LL, &kCFTypeArrayCallBacks);
        if (*(void *)block)
        {
          CFRelease(*(CFTypeRef *)block);
          *(void *)blocuint64_t k = 0LL;
        }

        int v228 = 86400;
        if (v227)
        {
          v229 = SCDynamicStoreCreate(0LL, @"DHCP-LEASES", 0LL, 0LL);
          int v228 = 86400;
          if (!v229) {
            goto LABEL_355;
          }
          uint64_t v230 = v229;
          uint64_t v231 = SCDynamicStoreCopyMultiple(v229, 0LL, v227);
          unsigned int v468 = 86400;
          if (!v231) {
            goto LABEL_354;
          }
          int v232 = v231;
          v465 = v227;
          int64_t Count = CFDictionaryGetCount(v231);
          unsigned int v468 = 86400;
          if (Count < 1) {
            goto LABEL_353;
          }
          int64_t v234 = Count;
          if ((unint64_t)Count >> 61 || (v235 = (const void **)calloc(Count, 8uLL)) == 0LL)
          {
            __break(1u);
            goto LABEL_533;
          }

          v236 = v235;
          v463 = v230;
          CFDictionaryGetKeysAndValues(v232, 0LL, v235);
          uint64_t v237 = 0LL;
          unsigned int v468 = 86400;
          while (2)
          {
            v238 = (const __CFDictionary *)v236[v237];
            if (v238)
            {
              int64_t v239 = v234;
              LeaseStartTime = DHCPInfoGetLeaseStartTime((CFDictionaryRef)v236[v237]);
              OptionData = DHCPInfoGetOptionData(v238, 0x33u);
              uint64_t v247 = OptionData;
              if (LeaseStartTime) {
                BOOL v248 = OptionData == 0LL;
              }
              else {
                BOOL v248 = 1;
              }
              if (v248)
              {
                int v249 = (os_log_s *)mDNSLogCategory_Default;
                if (OptionData) {
                  goto LABEL_256;
                }
                goto LABEL_257;
              }

              if (CFDataGetLength(OptionData) > 3)
              {
                BytePtr = CFDataGetBytePtr(v247);
                if (!BytePtr)
                {
                  unsigned int v191 = &unk_100164000;
                  LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "DHCPWakeTime: CFDataGetBytePtr %ld failed",  v251,  v252,  v253,  v254,  v255,  v237);
                  goto LABEL_258;
                }

                unsigned int v256 = (unsigned int *)BytePtr;
                double Current = CFAbsoluteTimeGetCurrent();
                double v263 = Current - CFDateGetAbsoluteTime(LeaseStartTime);
                unsigned int v264 = fmin(v263, 4294967300.0);
                if (v263 < 0.0) {
                  unsigned int v264 = 0;
                }
                unsigned int v265 = bswap32(*v256);
                unsigned int v266 = v265 - v264;
                if (v265 < v264) {
                  unsigned int v266 = 0;
                }
                int64_t v234 = v239;
                if (v266 < 0x3D) {
                  unsigned int v267 = 54;
                }
                else {
                  unsigned int v267 = v266 - v266 / 0xA;
                }
                unsigned int v191 = &unk_100164000;
                if (mDNS_LoggingEnabled == 1) {
                  LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "DHCP Address Lease Elapsed %6u Lifetime %6u Remaining %6u Wake %6u",  v258,  v259,  v260,  v261,  v262,  v264);
                }
                if (v468 >= v267) {
                  unsigned int v268 = v267;
                }
                else {
                  unsigned int v268 = v468;
                }
                unsigned int v468 = v268;
              }

              else
              {
                int v249 = (os_log_s *)mDNSLogCategory_Default;
LABEL_256:
                CFDataGetLength(v247);
LABEL_257:
                LogMsgWithLevel( v249,  OS_LOG_TYPE_DEFAULT,  "DHCPWakeTime: SCDynamicStoreCopyDHCPInfo index %d failed CFDateRef start %p CFDataRef lease %p CFDataG etLength(lease) %d",  v242,  v243,  v244,  v245,  v246,  v237);
                unsigned int v191 = &unk_100164000;
LABEL_258:
                int64_t v234 = v239;
              }
            }

            else
            {
              unsigned int v191 = &unk_100164000;
            }

            if (v234 == ++v237)
            {
              free(v236);
              uint64_t v230 = v463;
LABEL_353:
              CFRelease(v232);
              CFRange v227 = v465;
LABEL_354:
              CFRelease(v230);
              int v228 = v468;
LABEL_355:
              CFRelease(v227);
              break;
            }

            continue;
          }
        }

    *(void *)(a1 + 216) = 0LL;
    *(_BYTE *)(a1 + 56) = 0;
    int v155 = *(void *)(a1 + 208);
    if (v155)
    {
      id v157 = v159 + 1;
      if (v159 < 0x3E7) {
        continue;
      }
    }

    break;
  }

  if (v159 >= 0x3E7) {
    LogMsgWithLevel( v156[170],  OS_LOG_TYPE_DEFAULT,  "mDNS_Execute: AnswerNewQuestion exceeded loop limit",  (uint64_t)v4,  v5,  v6,  v7,  v8,  v820);
  }
LABEL_477:
  int v232 = 0;
  v871 = (uint64_t **)(a1 + 12624);
  while (*(_BYTE *)(a1 + 140))
  {
    *(_BYTE *)(a1 + 140) = 0;
    *(void *)(a1 + 12648) = *(void *)(a1 + 12624);
    CheckRmvEventsForLocalRecords((void *)a1, v2, v3, (uint64_t)v4, v5, v6, v7, v8);
    for (i1 = 0LL; i1 != 499; ++i1)
    {
      for (i2 = *(void **)(a1 + 8 * i1 + 6296); i2; i2 = (void *)*i2)
      {
        v235 = i2[2];
        *(void *)(a1 + 12648) = v235;
        if (v235) {
          CheckRmvEventsForLocalRecords((void *)a1, v2, v3, (uint64_t)v4, v5, v6, v7, v8);
        }
      }
    }

    if (++v232 == 1000)
    {
      LogMsgWithLevel( v156[170],  OS_LOG_TYPE_DEFAULT,  "mDNS_Execute: m->LocalRemoveEvents exceeded loop limit",  (uint64_t)v4,  v5,  v6,  v7,  v8,  v820);
      break;
    }
  }

  v236 = *(void *)(a1 + 232);
  if (v236)
  {
    uint64_t v237 = 0;
    v238 = *(void *)(a1 + 216);
    do
    {
      int64_t v239 = v237;
      *(void *)(a1 + 232) = *(void *)(v236 + 8);
      if (v238)
      {
        v240 = v156[170];
        v241 = v238 + 356;
        DNSTypeName(*(unsigned __int16 *)(v238 + 322));
        LogMsgWithLevel( v240,  OS_LOG_TYPE_DEFAULT,  "AnswerNewLocalOnlyQuestion ERROR m->CurrentQuestion already set: %##s (%s)",  v242,  v243,  v244,  v245,  v246,  v241);
      }

      *(void *)(a1 + 216) = v236;
      uint64_t v247 = *(void *)(a1 + 12648);
      if (v247)
      {
        BOOL v248 = v156[170];
        GetRRDisplayString_rdb( (unsigned __int8 *)(v247 + 8),  (unsigned __int16 *)(*(void *)(v247 + 48) + 4LL),  (_BYTE *)(a1 + 46976));
        LogMsgWithLevel( v248,  OS_LOG_TYPE_DEFAULT,  "AnswerNewLocalOnlyQuestion ERROR m->CurrentRecord already set %s",  v249,  v250,  v251,  v252,  v253,  a1 + 46976);
      }

      uint64_t v254 = AuthGroupForName(a1 + 6272, *(_DWORD *)(v236 + 200), (_BYTE *)(v236 + 356));
      if (v254 && (uint64_t v255 = v254, v256 = (void *)v254[2], (*(void *)(a1 + 12648) = v256) != 0LL))
      {
        v257 = 0;
        do
        {
          if (v256 == (void *)v255[5]) {
            break;
          }
          *(void *)(a1 + 12648) = *v256;
          if (LocalOnlyRecordAnswersQuestion((uint64_t)v256, v236, v3, (uint64_t)v4, v5, v6, v7, v8))
          {
            v257 = 1;
            AnswerLocalQuestionWithLocalAuthRecord(a1, (uint64_t)v256, 1LL);
            if (*(void *)(a1 + 216) != v236) {
              break;
            }
          }

          unsigned int v256 = *(void **)(a1 + 12648);
        }

        while (v256);
      }

      else
      {
        v257 = 0;
      }

      if (*(void *)(a1 + 216) == v236)
      {
        uint64_t v258 = *(void **)(a1 + 12624);
        *(void *)(a1 + 12648) = v258;
        int v153 = a1 + 12656;
        if (v258)
        {
          while (v258 != *(void **)(a1 + 12640))
          {
            *(void *)(a1 + 12648) = *v258;
            if (RecordAnswersQuestion((uint64_t)(v258 + 1), 1, v236, (uint64_t)v4, v5, v6, v7, v8))
            {
              v257 = 1;
              AnswerLocalQuestionWithLocalAuthRecord(a1, (uint64_t)v258, 1LL);
              if (*(void *)(a1 + 216) != v236) {
                goto LABEL_508;
              }
            }

            uint64_t v258 = *(void **)(a1 + 12648);
            if (!v258) {
              break;
            }
          }
        }
      }

      else
      {
        int v153 = a1 + 12656;
      }

      if (!v257 && *(void *)(a1 + 216) == v236 && *(_BYTE *)(v236 + 615)) {
        GenerateNegativeResponseEx(a1, -2LL, 3LL, 0LL, v5, v6, v7, v8, v820);
      }
LABEL_508:
      *(void *)(a1 + 216) = 0LL;
      *(void *)(a1 + 12648) = 0LL;
      v236 = *(void *)(a1 + 232);
      __int128 v156 = (os_log_s **)&unk_100164000;
      if (!v236) {
        break;
      }
      v238 = 0LL;
      uint64_t v237 = v239 + 1;
    }

    while (v239 < 0x3E7);
    if (v239 >= 0x3E7) {
      LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "mDNS_Execute: AnswerNewLocalOnlyQuestion exceeded loop limit",  (uint64_t)v4,  v5,  v6,  v7,  v8,  v820);
    }
  }

  uint64_t v259 = 0LL;
  uint64_t v260 = 0LL;
  uint64_t v261 = 0;
  while (1)
  {
    uint64_t v262 = *(void *)(a1 + 12640);
    if (!v262 || v262 == v260) {
      break;
    }
    unsigned int v264 = *(uint64_t **)v262;
    *(void *)(a1 + 12640) = *(void *)v262;
    if (*(_BYTE *)(v262 + 8) == 2)
    {
      unsigned int v265 = (uint64_t *)(a1 + 12624);
      if (v264)
      {
        do
        {
          unsigned int v266 = (uint64_t **)v265;
          unsigned int v265 = (uint64_t *)*v265;
          if (v265) {
            unsigned int v267 = v265 == (uint64_t *)v262;
          }
          else {
            unsigned int v267 = 1;
          }
        }

        while (!v267);
        if (!v265)
        {
          v269 = v156[170];
          GetRRDisplayString_rdb( (unsigned __int8 *)(v262 + 8),  (unsigned __int16 *)(*(void *)(v262 + 48) + 4LL),  (_BYTE *)(a1 + 46976));
          LogMsgWithLevel( v269,  OS_LOG_TYPE_DEFAULT,  "mDNS_Execute: ERROR!! Cannot find record %s in ResourceRecords list",  v270,  v271,  v272,  v273,  v274,  a1 + 46976);
          break;
        }

        const char *v266 = v264;
        if (v260)
        {
          *uint64_t v259 = v262;
          *(void *)uint64_t v262 = 0LL;
        }

        else
        {
          do
          {
            unsigned int v268 = v264;
            unsigned int v264 = (uint64_t *)*v264;
          }

          while (v264);
          const char *v268 = v262;
          *(void *)uint64_t v262 = 0LL;
          uint64_t v260 = v262;
        }

        uint64_t v259 = (void *)v262;
      }

      else
      {
        if (v260) {
          LogMsgWithLevel( v156[170],  OS_LOG_TYPE_DEFAULT,  "mDNS_Execute: ERROR!!: head %p, NewLocalRecords %p",  (uint64_t)v4,  v5,  v6,  v7,  v8,  v260);
        }
        uint64_t v260 = v262;
      }
    }

    else
    {
      AnswerAllLocalQuestionsWithLocalAuthRecord((void *)a1, v262, 1LL, (uint64_t)v4, v5, v6, v7, v8);
    }

    if (++v261 == 1000)
    {
      *(void *)(a1 + 12640) = v260;
      LogMsgWithLevel( v156[170],  OS_LOG_TYPE_DEFAULT,  "mDNS_Execute: m->NewLocalRecords exceeded loop limit",  (uint64_t)v4,  v5,  v6,  v7,  v8,  v820);
      goto LABEL_545;
    }
  }

  *(void *)(a1 + 12640) = v260;
LABEL_545:
  if (*(_BYTE *)v153)
  {
    uint64_t v275 = 0LL;
    *(_BYTE *)int v153 = 0;
    do
    {
      for (i3 = *(void **)(a1 + 8 * v275 + 6296); i3; i3 = (void *)*i3)
      {
        uint64_t v277 = 100;
        while (1)
        {
          uint64_t v2 = i3[5];
          if (!v2) {
            break;
          }
          i3[5] = *(void *)v2;
          if (*(_BYTE *)(v2 + 8) == 2)
          {
            v278 = v156[170];
            GetRRDisplayString_rdb( (unsigned __int8 *)(v2 + 8),  (unsigned __int16 *)(*(void *)(v2 + 48) + 4LL),  (_BYTE *)(a1 + 46976));
            LogMsgWithLevel( v278,  OS_LOG_TYPE_DEFAULT,  "mDNS_Execute: LocalOnlyRecord %s not ready",  v279,  v280,  v281,  v282,  v283,  a1 + 46976);
          }

          else
          {
            AnswerAllLocalQuestionsWithLocalAuthRecord((void *)a1, v2, 1LL, (uint64_t)v4, v5, v6, v7, v8);
          }

          if (!--v277)
          {
            LogMsgWithLevel( v156[170],  OS_LOG_TYPE_DEFAULT,  "mDNS_Execute: ag->NewLocalOnlyRecords exceeded loop limit",  (uint64_t)v4,  v5,  v6,  v7,  v8,  v820);
            break;
          }
        }
      }

      ++v275;
    }

    while (v275 != 499);
  }

  if (*(_DWORD *)(a1 + 16) || *(_BYTE *)(a1 + 141) == 2)
  {
    DiscardDeregistrations(a1);
    v284 = *(_DWORD *)(a1 + 64);
    if (*(_DWORD *)(a1 + 16)) {
      goto LABEL_1175;
    }
  }

  else
  {
    v284 = *(_DWORD *)(a1 + 64);
  }

  int v285 = *(_DWORD *)(a1 + 80);
  if (v285 && ((v284 - v285) & 0x80000000) != 0) {
    goto LABEL_1170;
  }
  *(_DWORD *)(a1 + 80) = 0;
  uint64_t v286 = *(void *)(a1 + 12664);
  if (v286)
  {
    while (!*(_BYTE *)(v286 + 16))
    {
      uint64_t v286 = *(void *)v286;
      if (!v286) {
        goto LABEL_569;
      }
    }

    v858 = v286;
  }

  else
  {
LABEL_569:
    v858 = 0LL;
  }

  uint64_t v299 = 0LL;
  v880 = 0LL;
  v851 = a1 + 28916;
  v863 = a1 + 37856;
  while (2)
  {
    v866 = v299;
    int v300 = *(void **)(a1 + 8 * v299 + 280);
    if (v300)
    {
      while (1)
      {
        uint64_t v301 = (uint64_t *)v300[2];
        if (v301) {
          break;
        }
LABEL_661:
        int v300 = (void *)*v300;
        if (!v300) {
          goto LABEL_662;
        }
      }

      while (2)
      {
        v302 = v301[12];
        if (!v302) {
          goto LABEL_626;
        }
        uint64_t v303 = *((unsigned __int8 *)v301 + 108);
        if (v303 > 3) {
          goto LABEL_626;
        }
        uint64_t v304 = 1000 * *((_DWORD *)v301 + 4);
        uint64_t v305 = *(void *)(v302 + 56);
        uint64_t v306 = v301[4];
        if (v305)
        {
          uint64_t v307 = 0LL;
          v308 = v304 / 20 - v284;
          do
          {
            v307 += 16LL;
          }

          while (v307 != 128);
        }

        if (*(_WORD *)(v302 + 320))
        {
          *(_DWORD *)(v302 + 208) = v284 - *(_DWORD *)(v302 + 212);
          *((_BYTE *)v301 + 108) = v303 + 1;
          ++*(_DWORD *)(v153 + 7272);
          if (!*(_WORD *)(v302 + 320)) {
            goto LABEL_624;
          }
LABEL_626:
          uint64_t v301 = (uint64_t *)*v301;
          if (!v301) {
            goto LABEL_661;
          }
          continue;
        }

        break;
      }

      uint64_t v309 = *(void *)(v302 + 64);
      if (v309)
      {
        if (v309 == v306) {
          goto LABEL_624;
        }
        uint64_t v306 = -1LL;
      }

      *(void *)(v302 + 64) = v306;
LABEL_624:
      if (*((_BYTE *)v301 + 130))
      {
LABEL_625:
        *(_BYTE *)(v302 + 339) = 1;
        goto LABEL_626;
      }

      uint64_t v310 = *((_DWORD *)v301 + 33);
      if (v310 == 6)
      {
        if (!*(void *)&vorr_s8( (int8x8_t)v301[17],  (int8x8_t)*(_OWORD *)&vextq_s8(*(int8x16_t *)(v301 + 17), *(int8x16_t *)(v301 + 17), 8uLL))) {
          goto LABEL_625;
        }
      }

      else if (v310 != 4 || !*((_DWORD *)v301 + 34))
      {
        goto LABEL_625;
      }

      if (mDNSAddrIsDNSMulticast((_DWORD *)v301 + 33)) {
        goto LABEL_625;
      }
      uint64_t v311 = (os_log_s *)mDNSLogCategory_Default;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
      {
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_INFO))
        {
          v316 = (_BYTE *)(v302 + 356);
          v847 = v302 + 356;
          if (v302 == -612)
          {
LABEL_647:
            while (v316)
            {
              int v317 = *v316;
              if (!*v316)
              {
                v318 = (_WORD)v316 - (v302 + 356) + 1;
                goto LABEL_656;
              }

              v316 += v317 + 1;
              if (v302 != -612) {
                goto LABEL_646;
              }
            }
          }

          else
          {
LABEL_646:
          }

          v318 = 257;
LABEL_656:
          uint64_t v319 = v318;
          uint64_t v320 = DNSTypeName(*(unsigned __int16 *)(v302 + 322));
          uint64_t v321 = *(_DWORD *)(v302 + 200);
          *(_DWORD *)buf = 67111171;
          *(_DWORD *)&uint8_t buf[4] = 0;
          *(_WORD *)&buf[8] = 2160;
          *(void *)&buf[10] = 1752392040LL;
          *(_WORD *)&buf[18] = 1045;
          *(_DWORD *)&buf[20] = 20;
          *(_WORD *)&buf[24] = 2101;
          *(void *)&buf[26] = (char *)v301 + 132;
          *(_WORD *)&buf[34] = 2160;
          *(void *)&buf[36] = 1752392040LL;
          *(_WORD *)&buf[44] = 1040;
          *(_DWORD *)&buf[46] = v319;
          *(_WORD *)&_BYTE buf[50] = 2101;
          *(void *)&buf[52] = v847;
          v896 = 2080;
          v897 = v320;
          v898 = 1024;
          LODWORD(v899) = v321;
          _os_log_impl( (void *)&_mh_execute_header,  v311,  OS_LOG_TYPE_INFO,  "[Q%u] Sending unicast assist query (expiring) - %{sensitive, mask.hash, mdnsresponder:ip_addr}.20P %{sensiti ve, mask.hash, mdnsresponder:domain_name}.*P %s qhash %x",  buf,  0x4Cu);
        }
      }

      else
      {
        uint64_t v311 = (os_log_s *)mDNSLogCategory_Default_redacted;
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_INFO))
        {
          v314 = (_BYTE *)(v302 + 356);
          v847 = v302 + 356;
          if (v302 == -612)
          {
LABEL_639:
            while (v314)
            {
              v315 = *v314;
              if (!*v314)
              {
                v318 = (_WORD)v314 - (v302 + 356) + 1;
                goto LABEL_656;
              }

              v314 += v315 + 1;
              if (v302 != -612) {
                goto LABEL_638;
              }
            }
          }

          else
          {
LABEL_638:
          }

          v318 = 257;
          goto LABEL_656;
        }
      }

      *v861 = *(_WORD *)(v302 + 320);
      *(_WORD *)(a1 + 28906) = 0;
      *(void *)(a1 + 28908) = 0LL;
      uint64_t v322 = putQuestion( (unint64_t)v861,  v851,  v863,  (unsigned __int8 *)(v302 + 356),  *(unsigned __int16 *)(v302 + 322),  *(unsigned __int16 *)(v302 + 324) | 0x8000u,  v312,  v313);
      mDNSSendDNSMessage( a1,  (unint64_t)v861,  (unint64_t)v322,  v301[4],  0LL,  0LL,  (int *)v301 + 33,  0xE914u,  0LL,  *(_BYTE *)(v302 + 620));
      v284 = *(_DWORD *)(a1 + 64);
      *(_DWORD *)(v302 + 208) = v284;
      *(_DWORD *)(v302 + 256) = v284;
      *(_DWORD *)(v302 + 224) = 0;
      if (v284 <= 1) {
        uint64_t v323 = 1;
      }
      else {
        uint64_t v323 = v284;
      }
      *(_DWORD *)(v302 + 216) = v323;
      *(void *)(v302 + 64) = 0LL;
      *((_BYTE *)v301 + 130) = 1;
      *((_DWORD *)v301 + 26) = v284;
      int v153 = a1 + 12656;
      goto LABEL_626;
    }

                uint64_t v213 = v211;
              }

              else
              {
                uint64_t v213 = 0;
              }

LABEL_356:
        if (mDNS_LoggingEnabled == 1) {
          LogMsgWithLevel( *((os_log_s **)v191 + 170),  OS_LOG_TYPE_DEFAULT,  "ComputeWakeTime: DHCP Wake %d",  v222,  v223,  v224,  v225,  v226,  v228);
        }
        int v324 = v193 + 7200000;
        for (int j = (uint64_t *)xmmword_10015C4F0; j; int j = (uint64_t *)*j)
        {
          if (*((_BYTE *)j + 172))
          {
            int v326 = *((_DWORD *)j + 2);
            if (v326)
            {
              if (v326 - v193 >= 4001)
              {
                int v327 = (v326 - v193) / -10 + v326;
                if (v324 - v327 > 0) {
                  int v324 = v327;
                }
                if (mDNS_LoggingEnabled == 1) {
                  LogMsgWithLevel( *((os_log_s **)v191 + 170),  OS_LOG_TYPE_DEFAULT,  "ComputeWakeTime: %p %s Int %5d Ext %5d Err %d Retry %5d Interval %5d Expire %5d Wake %5d",  v222,  v223,  v224,  v225,  v226,  (int)j);
                }
              }
            }
          }
        }

        unsigned int v328 = v228;
        for (uint64_t k = (uint64_t *)xmmword_10015BD08; k; uint64_t k = (uint64_t *)*k)
        {
          int v330 = *((_DWORD *)k + 88);
          if (v330 && v330 - v193 >= 4001)
          {
            int v331 = (v330 - v193) / -10 + v330;
            if (v324 - v331 > 0) {
              int v324 = v331;
            }
            if (mDNS_LoggingEnabled == 1)
            {
              v332 = (os_log_s *)*((void *)v191 + 170);
              GetRRDisplayString_rdb((unsigned __int8 *)k + 8, (unsigned __int16 *)(k[6] + 4), word_100164338);
              uint64_t v5 = &unk_100164000;
              unsigned int v191 = &unk_100164000;
              uint64_t v4 = (void *)&unk_100164000;
              LogMsgWithLevel( v332,  OS_LOG_TYPE_DEFAULT,  "ComputeWakeTime: %p Int %7d Next %7d Expire %7d Wake %7d %s",  v333,  v334,  v335,  v336,  v337,  (int)k);
            }
          }
        }

        if ((v324 - v193) / 1000 <= v328 || v324 - v193 <= -1000) {
          int v339 = (v324 - v193) / 1000;
        }
        else {
          int v339 = v328;
        }
        BOOL v340 = v339 > 3600;
        if (v339 <= 60) {
          int v339 = 60;
        }
        if ((v470 & v340) != 0) {
          int v341 = 3600;
        }
        else {
          int v341 = v339;
        }
        mdns_power_cancel_all_events(@"com.apple.mDNSResponder");
        int v342 = mdns_power_schedule_wake(v341);
        int v276 = v342;
        if (v342)
        {
          a1 = v454;
          if (v342 != -536870184) {
            goto LABEL_399;
          }
          LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "AllowSleepNow: Requested wakeup in %d seconds unsuccessful; retrying with longer intervals",
            v343,
            v344,
            v345,
            v346,
            v347,
            v341);
          do
          {
            int v348 = v341 + 3;
            if (v341 + 3 < 0) {
              int v348 = v341 + 6;
            }
            int v349 = v348 >> 2;
            if (v341 < 20) {
              int v349 = 1;
            }
            v341 += v349;
            int v350 = mdns_power_schedule_wake(v341);
          }

          while (v350 == -536870184);
          if (v350)
          {
LABEL_399:
            LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "AllowSleepNow: Requested wakeup in %d seconds unsuccessful: %d %X",  v343,  v344,  v345,  v346,  v347,  v341);
          }

          else if (mDNS_LoggingEnabled == 1)
          {
            LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "AllowSleepNow: Requested later wakeup in %d seconds; will also attempt IOCancelPowerChange",
              v343,
              v344,
              v345,
              v346,
              v347,
              v341);
          }
        }

        else
        {
          a1 = v454;
          if (mDNS_LoggingEnabled == 1) {
            LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "AllowSleepNow: Requested wakeup in %d seconds",  v343,  v344,  v345,  v346,  v347,  v341);
          }
        }

        time_t HaveAdvertisedMulticastServices = time(0LL);
        *(void *)(mDNSStorage[0] + 600) = v341 + (int)HaveAdvertisedMulticastServices;
      }

      else
      {
        if (mDNS_LoggingEnabled == 1)
        {
          v269 = (os_log_s *)*((void *)v191 + 170);
          if (byte_100158C47[0]) {
            v270 = "is";
          }
          else {
            v270 = "not";
          }
          mDNSCoreHaveAdvertisedMulticastServices(*(void *)&byte_100158C47[&unk_1000030C1]);
          LogMsgWithLevel( v269,  OS_LOG_TYPE_DEFAULT,  "AllowSleepNow: Not scheduling wakeup: SystemWakeOnLAN %s enabled; %s advertised services",
            v271,
            v272,
            v273,
            v274,
            v275,
            (int)v270);
        }

        int v276 = 0;
      }

      byte_100158C45 = 2;
      mDNSMacOSXNetworkChanged(HaveAdvertisedMulticastServices, v209, v210, v211, v212, v213, v214, v215);
LABEL_402:
      if (mDNS_LoggingEnabled == 1)
      {
        v351 = "IOCancelPowerChange";
        if (!v276) {
          v351 = "IOAllowPowerChange";
        }
        LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "AllowSleepNow: %s(%lX) %s at %ld (%d ticks remaining)",  v295,  v296,  v297,  v298,  v299,  (int)v351);
      }

      dword_100158C54 = 0;
      dword_100158C58 = time(0LL);
      io_connect_t v352 = *(_DWORD *)(mDNSStorage[0] + 568);
      intptr_t v353 = *(void *)(mDNSStorage[0] + 592);
      if (v276) {
        IOCancelPowerChange(v352, v353);
      }
      else {
        IOAllowPowerChange(v352, v353);
      }
      unsigned int v191 = &unk_100164000;
    }

      if (*(_WORD *)(v155 + 320)) {
        uint64_t v192 = *(_BYTE *)(v155 + 626) == 1;
      }
      else {
        uint64_t v192 = 0;
      }
      int v193 = v192;
      if (*(_BYTE *)(v155 + 334) && !*(_BYTE *)(v155 + 625))
      {
        int v196 = 1;
      }

      else
      {
        if (v161)
        {
          int v194 = v161[2];
          if (v194)
          {
            v857 = 0;
            v850 = 0;
            v846 = 0;
            char v195 = 0;
            int v196 = 1;
            while (1)
            {
              int v197 = (_BYTE *)(v194 + 8);
              if (!SameNameRecordAnswersQuestion((unsigned __int8 *)(v194 + 8), 0, v155, (uint64_t)v4, v5, v6, v7, v8))
              {
                if (!*(_WORD *)(v155 + 320))
                {
                  uint64_t v201 = *(unsigned __int16 *)(v194 + 12);
                  if (v201 == 28 || v201 == 1)
                  {
                    uint64_t v203 = *(unsigned __int16 *)(v155 + 322);
                    if (v203 == 28 || v203 == 1) {
                      int v196 = 0;
                    }
                  }
                }

                goto LABEL_402;
              }

              int v198 = (*(_DWORD *)(a1 + 64) - *(_DWORD *)(v194 + 80)) / 0x3E8u;
              int v199 = *(_DWORD *)(v194 + 16);
              if (v199 <= v198)
              {
                if (!v193) {
                  goto LABEL_402;
                }
                uint64_t v200 = *v197;
                if (v200 == 240) {
                  goto LABEL_402;
                }
              }

              else
              {
                uint64_t v200 = *v197;
              }

              if ((v200 & 0x10) != 0 || *(_BYTE *)(v155 + 613))
              {
                if (v199 > v198) {
                  int v196 = 0;
                }
                uint64_t v204 = *(void *)(v155 + 144);
                if (v204)
                {
                  if (*(_BYTE *)(v204 + 24))
                  {
                    char v205 = *(void *)(v194 + 64);
                    if (v205)
                    {
                      if (!*(_DWORD *)(v205 + 32))
                      {
                        ++v195;
                        int v206 = (unsigned __int8 *)(v194 + 8);
                        if (v200 == 240)
                        {
                          v850 = resource_record_as_denial_of_existence_proves_wildcard_answer(v206);
                        }

                        else
                        {
                          if (resource_record_as_rrsig_get_covered_type((uint64_t)v206) == 5)
                          {
                            int v207 = resource_record_as_rrsig_covers_wildcard_rr(v194 + 8);
                            BOOL v208 = v846;
                            if (v207) {
                              BOOL v208 = 1;
                            }
                            v846 = v208;
                          }

                          if (!v857) {
                            v857 = *(_DWORD *)(*(void *)(v194 + 64) + 24LL);
                          }
                        }
                      }
                    }
                  }
                }
              }

              ++*(_DWORD *)(v155 + 228);
              if ((*v197 & 0x10) != 0) {
                ++*(_DWORD *)(v155 + 236);
              }
              AnswerCurrentQuestionWithResourceRecord(a1, v194, 1LL);
              if (*(void *)(a1 + 216) != v155) {
                goto LABEL_405;
              }
LABEL_402:
              int v194 = *(void *)v194;
              if (!v194) {
                goto LABEL_405;
              }
            }
          }
        }

        char v195 = 0;
        LOBYTE(v846) = 0;
        v850 = 0;
        v857 = 0;
        int v196 = 1;
LABEL_405:
        if (*(void *)(a1 + 216) == v155)
        {
          uint64_t v209 = *(void *)(v155 + 144);
          __int128 v156 = (os_log_s **)&unk_100164000;
          if (!v209 || (*(_BYTE *)(v209 + 24) ? (uint64_t v210 = v196 == 0) : (uint64_t v210 = 0), !v210))
          {
LABEL_429:
            uint64_t v215 = *(void *)(a1 + 216);
            if (v215 != v155) {
              goto LABEL_430;
            }
            if (v193)
            {
              if (*(void *)(v155 + 168))
              {
                int v216 = *(_DWORD *)(a1 + 48);
                uint64_t v217 = *(_DWORD *)(a1 + 52) + 1;
                *(_DWORD *)(a1 + 52) = v217;
                mDNS_VerifyLockState("Drop Lock", 0, v216, v217, (uint64_t)"AnswerNewQuestion", 6249);
                (*(void (**)(uint64_t, uint64_t))(v155 + 168))(v155, 1LL);
                mDNS_VerifyLockState( "Reclaim Lock",  0,  *(_DWORD *)(a1 + 48),  *(_DWORD *)(a1 + 52),  (uint64_t)"AnswerNewQuestion",  6251);
                --*(_DWORD *)(a1 + 52);
                uint64_t v215 = *(void *)(a1 + 216);
                if (v215 != v155)
                {
LABEL_430:
                  int v153 = a1 + 12656;
                  if (v215 != v155) {
                    goto LABEL_343;
                  }
                  goto LABEL_442;
                }
              }

              *(_BYTE *)(v155 + 626) = 2;
            }

            int v153 = a1 + 12656;
            if (*(_BYTE *)(v155 + 334))
            {
              if (*(_BYTE *)(v155 + 615))
              {
                GenerateNegativeResponseEx(a1, 0LL, 4LL, 0LL, v5, v6, v7, v8, v820);
                uint64_t v215 = *(void *)(a1 + 216);
                goto LABEL_430;
              }

              *(_DWORD *)(v155 + 212) = 0;
            }

LABEL_410:
    else {
      int v354 = v459 - v193;
    }
    if (v354 > 1)
    {
LABEL_475:
      KQueueLoop_RepeatedBusy = 0;
    }

    else if (++KQueueLoop_RepeatedBusy >= 1000)
    {
      mDNS_Lock_((unsigned int *)mDNSStorage, (uint64_t)"ShowTaskSchedulingError", 5628);
      LogMsgWithLevel( *((os_log_s **)v191 + 170),  OS_LOG_TYPE_DEFAULT,  "Task Scheduling Error: *** Continuously busy for more than a second",  v355,  v356,  v357,  v358,  v359,  v447);
      if (!qword_100158C88 || (int v365 = *(_DWORD *)(qword_100158C88 + 204)) != 0 && dword_100158BF8 - v365 < 0)
      {
        int v373 = 0;
      }

      else
      {
        v366 = (os_log_s *)*((void *)v191 + 170);
        int v367 = qword_100158C88 + 356;
        DNSTypeName(*(unsigned __int16 *)(qword_100158C88 + 322));
        LogMsgWithLevel( v366,  OS_LOG_TYPE_DEFAULT,  "Task Scheduling Error: NewQuestion %##s (%s)",  v368,  v369,  v370,  v371,  v372,  v367);
        int v373 = 1;
      }

      if (qword_100158CA0)
      {
        ++v373;
        v374 = (os_log_s *)mDNSLogCategory_Default;
        int v375 = qword_100158CA0 + 356;
        DNSTypeName(*(unsigned __int16 *)(qword_100158CA0 + 322));
        LogMsgWithLevel( v374,  OS_LOG_TYPE_DEFAULT,  "Task Scheduling Error: NewLocalOnlyQuestions %##s (%s)",  v376,  v377,  v378,  v379,  v380,  v375);
      }

      v381 = (uint64_t *)xmmword_10015BD18;
      v382 = (_DWORD *)&unk_100158000;
      if ((void)xmmword_10015BD18)
      {
        while (*((_BYTE *)v381 + 8) == 2)
        {
          v381 = (uint64_t *)*v381;
          if (!v381) {
            goto LABEL_427;
          }
        }

        ++v373;
        uint64_t v383 = mDNSLogCategory_Default;
        GetRRDisplayString_rdb((unsigned __int8 *)v381 + 8, (unsigned __int16 *)(v381[6] + 4), word_100164338);
        v384 = (os_log_s *)v383;
        v382 = &unk_100158000;
        LogMsgWithLevel( v384,  OS_LOG_TYPE_DEFAULT,  "Task Scheduling Error: NewLocalRecords %s",  v385,  v386,  v387,  v388,  v389,  (int)word_100164338);
      }

LABEL_427:
      if (byte_10015BD28)
      {
        ++v373;
        LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "Task Scheduling Error: NewLocalOnlyRecords",  v360,  v361,  v362,  v363,  v364,  v448);
      }

      if ((void)xmmword_10015C678)
      {
        ++v373;
        LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "Task Scheduling Error: SPSProxyListChanged",  v360,  v361,  v362,  v363,  v364,  v448);
      }

      if (byte_100158C44)
      {
        ++v373;
        LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "Task Scheduling Error: LocalRemoveEvents",  v360,  v361,  v362,  v363,  v364,  v448);
      }

      int v390 = dword_100158BF8;
      if (dword_100158BF8 - dword_10015BD48 >= 0)
      {
        ++v373;
        LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "Task Scheduling Error: m->NextuDNSEvent %d",  v360,  v361,  v362,  v363,  v364,  dword_100158BF8 - dword_10015BD48);
        int v390 = v382[766];
      }

      if (v390 - dword_100158C20 >= 0)
      {
        ++v373;
        LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "Task Scheduling Error: m->NextScheduledNATOp %d",  v360,  v361,  v362,  v363,  v364,  v390 - dword_100158C20);
        int v390 = v382[766];
      }

      if (dword_10015BD4C && v390 - dword_10015BD4C >= 0)
      {
        ++v373;
        LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "Task Scheduling Error: m->NextSRVUpdate %d",  v360,  v361,  v362,  v363,  v364,  v390 - dword_10015BD4C);
        int v390 = v382[766];
      }

      if (v390 - dword_100158C10 >= 0)
      {
        ++v373;
        LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "Task Scheduling Error: m->NextCacheCheck %d",  v360,  v361,  v362,  v363,  v364,  v390 - dword_100158C10);
        int v390 = v382[766];
      }

      if (v390 - dword_100158C24 >= 0)
      {
        ++v373;
        LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "Task Scheduling Error: m->NextScheduledSPS %d",  v360,  v361,  v362,  v363,  v364,  v390 - dword_100158C24);
        int v390 = v382[766];
      }

      int v391 = v390 - dword_100158C28;
      if (v391 >= 0)
      {
        ++v373;
        LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "Task Scheduling Error: m->NextScheduledKA %d",  v360,  v361,  v362,  v363,  v364,  v391);
      }

      int v392 = dword_100158C50;
      if (dword_100158C50
        || dword_100158C54
        && dword_100158BF8 - dword_100158C70 >= 0
        && (++v373,
            LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "Task Scheduling Error: m->NextScheduledSPRetry %d",  v360,  v361,  v362,  v363,  v364,  dword_100158BF8 - dword_100158C70),  (int v392 = dword_100158C50) != 0))
      {
        int v393 = v382[766] - v392;
        if (v393 >= 0)
        {
          ++v373;
          LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "Task Scheduling Error: m->DelaySleep %d",  v360,  v361,  v362,  v363,  v364,  v393);
        }
      }

      int v394 = dword_100158BF8;
      if ((_DWORD)qword_100158C08 && dword_100158BF8 - (int)qword_100158C08 >= 0)
      {
        ++v373;
        LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "Task Scheduling Error: m->SuppressQueries %d",  v360,  v361,  v362,  v363,  v364,  dword_100158BF8 - qword_100158C08);
        int v394 = v382[766];
      }

      if (HIDWORD(qword_100158C08) && v394 - HIDWORD(qword_100158C08) >= 0)
      {
        ++v373;
        LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "Task Scheduling Error: m->SuppressResponses %d",  v360,  v361,  v362,  v363,  v364,  v394 - HIDWORD(qword_100158C08));
        int v394 = v382[766];
      }

      if (v394 - dword_100158C14 >= 0)
      {
        ++v373;
        LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "Task Scheduling Error: m->NextScheduledQuery %d",  v360,  v361,  v362,  v363,  v364,  v394 - dword_100158C14);
        int v394 = v382[766];
      }

      if (v394 - dword_100158C18 >= 0)
      {
        ++v373;
        LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "Task Scheduling Error: m->NextScheduledProbe %d",  v360,  v361,  v362,  v363,  v364,  v394 - dword_100158C18);
        int v394 = v382[766];
      }

      if (v394 - dword_100158C1C >= 0)
      {
        ++v373;
        LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "Task Scheduling Error: m->NextScheduledResponse %d",  v360,  v361,  v362,  v363,  v364,  v394 - dword_100158C1C);
        int v394 = v382[766];
      }

      if (v394 - dword_100158C74 >= 0)
      {
        ++v373;
        LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "Task Scheduling Error: m->NextScheduledStopTime %d",  v360,  v361,  v362,  v363,  v364,  v394 - dword_100158C74);
        int v394 = v382[766];
      }

      int v395 = v394 - dword_100158C00;
      if (v395 >= 0)
      {
        ++v373;
        LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "Task Scheduling Error: m->NextScheduledEvent %d",  v360,  v361,  v362,  v363,  v364,  v395);
      }

      if (dword_100158BC0)
      {
        int v396 = v382[766] - dword_100158BC0;
        if (v396 >= 0)
        {
          ++v373;
          LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "Task Scheduling Error: NetworkChanged %d",  v360,  v361,  v362,  v363,  v364,  v396);
        }
      }

      if (v373) {
        LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "Task Scheduling Error: *** %d potential cause%s identified (significant only if the same cause consistently appears)",  v360,  v361,  v362,  v363,  v364,  v373);
      }
      else {
        LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "Task Scheduling Error: *** No likely causes identified",  v360,  v361,  v362,  v363,  v364,  v448);
      }
      mDNS_Unlock_((uint64_t)mDNSStorage, (uint64_t)"ShowTaskSchedulingError", 5696);
      unsigned int v191 = &unk_100164000;
      goto LABEL_475;
    }

    pthread_mutex_unlock(&stru_100150758);
    if (*(_DWORD *)(*(void *)a1 + 104LL))
    {
      SetLowWater(*(void *)a1 + 8LL, 0x10000);
      if (v354 >= 125) {
        int v354 = 125;
      }
    }

    timeout.tv_sec = v354 / 1000;
    timeout.tv_nsec = 1000000 * (v354 % 1000);
    if (kevent(KQueueFD, 0LL, 0, &eventlist, 1, &timeout) < 0)
    {
      v397 = (os_log_s *)*((void *)v191 + 170);
      if (gSensitiveLoggingEnabled != 1 || v397 == (os_log_s *)v4[171])
      {
        if (os_log_type_enabled(*((os_log_t *)v191 + 170), OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_485;
        }
      }

      else
      {
        v397 = (os_log_s *)*((void *)v5 + 172);
        if (os_log_type_enabled(v397, OS_LOG_TYPE_DEFAULT))
        {
LABEL_485:
          int v398 = KQueueFD;
          int v399 = *__error();
          v400 = __error();
          v401 = strerror(*v400);
          *(_DWORD *)blocuint64_t k = 67109634;
          *(_DWORD *)&block[4] = v398;
          *(_WORD *)&block[8] = 1024;
          *(_DWORD *)&block[10] = v399;
          *(_WORD *)&block[14] = 2082;
          *(void *)&block[16] = v401;
          _os_log_impl( (void *)&_mh_execute_header,  v397,  OS_LOG_TYPE_DEFAULT,  "kevent(%d) failed errno %d (%{public}s)",  block,  0x18u);
        }
      }

      sleep(1u);
    }

    pthread_mutex_lock(&stru_100150758);
    if (*(_DWORD *)(*(void *)a1 + 104LL))
    {
      SetLowWater(*(void *)a1 + 8LL, 1);
      *(_DWORD *)(*(void *)a1 + 104LL) = 0;
    }

LABEL_489:
    while (2)
    {
      uint64_t v6 = kevent(KQueueFD, 0LL, 0, &eventlist, 1, &KQueueLoop_zero_timeout);
      if ((_DWORD)v6)
      {
        if ((v6 & 0x80000000) == 0)
        {
          uint64_t v402 = 0LL;
          uint64_t v403 = 32LL * v6;
          while (1)
          {
            uint64_t v404 = *(uint64_t *)((char *)&eventlist.udata + v402);
            int v405 = mDNSPlatformRawTime(v6, v7, v8, v9, v10, v11, v12, v13);
            uint64_t v406 = *(void *)(v404 + 16);
            uint64_t v407 = (*(uint64_t (**)(void, void, void, void))v404)( LODWORD(eventlist.ident),  *(__int16 *)((char *)&eventlist.filter + v402),  *(void *)(v404 + 8),  *(unsigned __int16 *)((char *)&eventlist.flags + v402) >> 15);
            uint64_t v6 = mDNSPlatformRawTime(v407, v408, v409, v410, v411, v412, v413, v414);
            int v415 = v6 - v405;
            if ((int)v6 - v405 >= WatchDogReportingThreshold)
            {
              v416 = (os_log_s *)mDNSLogCategory_Default;
              if (gSensitiveLoggingEnabled == 1 && mDNSLogCategory_Default != v4[171])
              {
                v416 = (os_log_s *)*((void *)v5 + 172);
                uint64_t v6 = os_log_type_enabled(v416, OS_LOG_TYPE_DEFAULT);
                if (!(_DWORD)v6) {
                  goto LABEL_503;
                }
LABEL_502:
                *(_DWORD *)blocuint64_t k = 136446466;
                *(void *)&block[4] = v406;
                *(_WORD *)&block[12] = 1024;
                *(_DWORD *)&block[14] = v415;
                _os_log_impl( (void *)&_mh_execute_header,  v416,  OS_LOG_TYPE_DEFAULT,  "WARNING: %{public}s took %d ms to complete",  block,  0x12u);
                goto LABEL_503;
              }

              uint64_t v6 = os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT);
              if ((_DWORD)v6) {
                goto LABEL_502;
              }
            }

LABEL_503:
            v402 += 32LL;
            if (v403 == v402) {
              goto LABEL_489;
            }
          }
        }

        if (*__error() == 4) {
          continue;
        }
LABEL_521:
        int v438 = *__error();
        uint64_t v439 = mDNSLogCategory_Default;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == v4[171])
        {
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
          {
            v441 = strerror(v438);
            *(_DWORD *)blocuint64_t k = 67109378;
            *(_DWORD *)&block[4] = v438;
            *(_WORD *)&block[8] = 2082;
            *(void *)&block[10] = v441;
            v442 = (os_log_s *)v439;
            goto LABEL_530;
          }
        }

        else
        {
          v443 = (os_log_s *)*((void *)v5 + 172);
          if (os_log_type_enabled(v443, OS_LOG_TYPE_DEFAULT))
          {
            v445 = strerror(v438);
            *(_DWORD *)blocuint64_t k = 67109378;
            *(_DWORD *)&block[4] = v438;
            *(_WORD *)&block[8] = 2082;
            *(void *)&block[10] = v445;
            v442 = v443;
LABEL_530:
            _os_log_impl( (void *)&_mh_execute_header,  v442,  OS_LOG_TYPE_DEFAULT,  "ERROR: KQueueLoop - kevent failed errno %d (%{public}s)",  block,  0x12u);
          }
        }

        exit(v438);
      }

      break;
    }

    uint64_t v2 = (os_log_s **)&unk_100164000;
  }

uint64_t mDNS_TimeNow( _DWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1[12]) {
    goto LABEL_20;
  }
  uint64_t v9 = (os_log_s *)mDNSLogCategory_Default;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
  {
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_ERROR)) {
      goto LABEL_12;
    }
    LOWORD(v16) = 0;
    goto LABEL_11;
  }

  uint64_t v9 = (os_log_s *)mDNSLogCategory_Default_redacted;
  if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_ERROR))
  {
    LOWORD(v16) = 0;
LABEL_11:
    _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_ERROR,  "Lock failure: mDNS_TimeNow called while holding mDNS lock. This is incorrect. Code protected by lock should just use m->timenow.",  (uint8_t *)&v16,  2u);
  }

uint64_t mDNS_Execute(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 64) - *(_DWORD *)(a1 + 72) < 0) {
    goto LABEL_1533;
  }
  uint64_t v9 = *(void *)(a1 + 216);
  if (v9)
  {
    uint64_t v10 = (os_log_s *)mDNSLogCategory_Default;
    int v11 = v9 + 356;
    DNSTypeName(*(unsigned __int16 *)(v9 + 322));
    LogMsgWithLevel( v10,  OS_LOG_TYPE_DEFAULT,  "mDNS_Execute: ERROR m->CurrentQuestion already set: %##s (%s)",  v12,  v13,  v14,  v15,  v16,  v11);
  }

  uint64_t v17 = *(void *)(a1 + 12648);
  if (v17)
  {
    uint64_t v18 = (os_log_s *)mDNSLogCategory_Default;
    GetRRDisplayString_rdb( (unsigned __int8 *)(v17 + 8),  (unsigned __int16 *)(*(void *)(v17 + 48) + 4LL),  (_BYTE *)(a1 + 46976));
    LogMsgWithLevel( v18,  OS_LOG_TYPE_DEFAULT,  "mDNS_Execute: ERROR m->CurrentRecord already set: %s",  v19,  v20,  v21,  v22,  v23,  a1 + 46976);
  }

  int v24 = *(_DWORD *)(a1 + 12680);
  int v25 = *(_DWORD *)(a1 + 64);
  if (v24 && ((v25 - v24) & 0x80000000) == 0) {
    *(_DWORD *)(a1 + 12680) = 0;
  }
  if (*(_DWORD *)(a1 + 12676) && v25 - *(_DWORD *)(a1 + 12672) >= 10000) {
    *(_DWORD *)(a1 + 12676) = 0;
  }
  if (*(_DWORD *)(a1 + 248) && v25 - *(_DWORD *)(a1 + 88) >= 0)
  {
    uint64_t v26 = 0LL;
    *(_DWORD *)(a1 + 88) = v25 + 939524096;
    do
    {
      int v27 = *(_DWORD *)(a1 + 64);
      uint64_t v28 = a1 + 4 * v26;
      int v29 = *(_DWORD *)(v28 + 4272);
      if (v27 - v29 >= 0)
      {
        int v30 = (int *)(v28 + 4272);
        uint64_t v31 = a1 + 8 * v26;
        int v29 = v27 + 939524096;
        int *v30 = v27 + 939524096;
        uint64_t v3 = *(void *)(v31 + 280);
        if (v3)
        {
          uint64_t v32 = (uint64_t *)(v31 + 280);
          do
          {
            CheckCacheExpiration(a1, v26, v3, (uint64_t)v4, v5, v6, v7, v8, v820);
            uint64_t v33 = (uint64_t *)*v32;
            if (!*(void *)(*v32 + 16))
            {
              ReleaseCacheGroup(a1, (void **)v32);
              uint64_t v33 = v32;
            }

            uint64_t v3 = *v33;
            uint64_t v32 = v33;
          }

          while (*v33);
          int v29 = *v30;
        }
      }

      if (*(_DWORD *)(a1 + 88) - v29 >= 1) {
        *(_DWORD *)(a1 + 88) = v29;
      }
      ++v26;
    }

    while (v26 != 499);
    int v25 = *(_DWORD *)(a1 + 64);
  }

  if (v25 - *(_DWORD *)(a1 + 108) >= 0)
  {
    *(_DWORD *)(a1 + 108) = v25 + 939524096;
    CheckProxyRecords(a1, *(void *)(a1 + 12632), v3, (uint64_t)v4, v5, v6, v7, v8);
    CheckProxyRecords(a1, *(void *)(a1 + 12624), v34, v35, v36, v37, v38, v39);
  }

  uint64_t v40 = *(void *)(a1 + 15040);
  if (v40) {
    mDNSPlatformUpdateProxyList(v40, v2, v3, (uint64_t)v4, v5, v6, v7, v8);
  }
  *(void *)(a1 + 15040) = 0LL;
  int v41 = *(_DWORD *)(a1 + 64);
  if (v41 - *(_DWORD *)(a1 + 112) >= 0)
  {
    *(_DWORD *)(a1 + 112) = v41 + 939524096;
    mDNS_SendKeepalives(a1);
  }

  int v42 = *(_DWORD *)(a1 + 116);
  if (v42)
  {
    int v43 = *(_DWORD *)(a1 + 64);
    if (v43 - v42 >= 0)
    {
      *(_DWORD *)(a1 + 8) = v43;
      *(_DWORD *)(a1 + 116) = 0;
      *(_BYTE *)(a1 + 1memset(v45, 0, 20) = 0;
      if (mDNS_LoggingEnabled == 1) {
        LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "mDNS_Execute: Scheduled network changed processing to leave multicast group.",  (uint64_t)v4,  v5,  v6,  v7,  v8,  v820);
      }
    }
  }

  for (uint64_t i = *(void *)(a1 + 14088); i; uint64_t i = *(void *)(i + 296))
  {
    for (int j = 0; j != 5; ++j)
      mDNS_SetUpDomainEnumeration((unsigned int *)a1, i, j);
  }

  if (!g_discover_resolvers) {
    goto LABEL_188;
  }
  uint64_t v46 = *(void **)g_discover_resolvers;
  if (!*(void *)g_discover_resolvers) {
    goto LABEL_188;
  }
  int v47 = dword_100158BF8;
  int v862 = dword_100158BF8;
  do
  {
    uint64_t v49 = v46;
    uint64_t v46 = (void *)*v46;
    uint64_t v48 = v49[1];
    if (!v48) {
      continue;
    }
    uint64_t v50 = *(void *)(v48 + 272);
    if (!v50) {
      continue;
    }
    uint64_t v51 = *(void *)(v50 + 656);
    if (!v51) {
      continue;
    }
    int v52 = *(_DWORD *)(v51 + 1584);
    BOOL v53 = v52 && v52 - v47 <= 0;
    if (!v53) {
      continue;
    }
    uint64_t v54 = *(void *)(v51 + 1592);
    if (v54)
    {
      uint64_t DNSServiceManager = Querier_GetDNSServiceManager();
      if (DNSServiceManager) {
        mdns_dns_service_manager_deregister_native_service(DNSServiceManager, v54);
      }
      *(void *)(v51 + 1592) = 0LL;
    }

    uint64_t v56 = *(void *)(v51 + 256);
    uint64_t v57 = v56 + 5;
    int v58 = mdns_dns_service_definition_create();
    if (!v58) {
      goto LABEL_142;
    }
    uint64_t v59 = (uint64_t)v58;
    mdns_dns_service_definition_set_interface_index((uint64_t)v58, v56, 2);
    bzero(buf, 0x3F1uLL);
    ConvertDomainNameToCString_withescape((unsigned __int8 *)v48, buf);
    int v60 = mdns_domain_name_create((char *)buf, 0LL);
    if (!v60)
    {
      os_release((void *)v59);
LABEL_142:
      char v81 = -1;
      __darwin_time_t v82 = &unk_100164000;
      goto LABEL_113;
    }

    unsigned int v61 = v60;
    uint64_t v865 = v54;
    CFSetAddValue(*(CFMutableSetRef *)(v59 + 32), v60);
    *(_BYTE *)(v59 + 53) = 1;
    os_release(v61);
    size_t v62 = *(int **)(v51 + 1576);
    if (!v62)
    {
LABEL_109:
      if (v865) {
        char v81 = 3;
      }
      else {
        char v81 = 0;
      }
      goto LABEL_112;
    }

    char v63 = 0;
    unint64_t v64 = v51 + 256;
    uint64_t v870 = v59;
    do
    {
      while (1)
      {
        int v65 = *v62;
        if (*v62 == 6)
        {
          if (*((unsigned __int8 *)v62 + 4) == 254)
          {
            if ((*((_BYTE *)v62 + 5) & 0xC0) == 0x80) {
              int v74 = v56;
            }
            else {
              int v74 = 0;
            }
          }

          else
          {
            int v74 = 0;
          }

          uint64_t v78 = _mdns_address_new();
          if (!v78)
          {
LABEL_140:
            char v81 = -1;
            uint64_t v59 = v870;
            goto LABEL_112;
          }

          uint64_t v77 = (void *)v78;
          *(_DWORD *)(v78 + 24) = 7708;
          *(_OWORD *)(v78 + 32) = *(_OWORD *)(v62 + 1);
          *(_DWORD *)(v78 + 48) = v74;
          goto LABEL_100;
        }

        if (v65 != 4) {
          break;
        }
        int v75 = v62[1];
        uint64_t v76 = _mdns_address_new();
        if (!v76) {
          goto LABEL_140;
        }
        uint64_t v77 = (void *)v76;
        *(_DWORD *)(v76 + 24) = 528;
        *(_DWORD *)(v76 + 28) = v75;
LABEL_100:
        uint64_t v59 = v870;
        CFArrayAppendValue(*(CFMutableArrayRef *)(v870 + 24), v77);
        os_release(v77);
        size_t v62 = (int *)*((void *)v62 + 3);
        char v63 = 1;
        if (!v62) {
          goto LABEL_103;
        }
      }

      __int128 v66 = (os_log_s *)mDNSLogCategory_Default;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_FAULT)) {
          goto LABEL_89;
        }
        for (uint64_t k = (_BYTE *)v51; ; k += v70 + 1)
        {
          unsigned __int16 v69 = 257;
          uint64_t v70 = *k;
          if (v70 > 0x3F)
          {
            unsigned __int16 v69 = 257;
            goto LABEL_88;
          }

          if (!*k)
          {
            unsigned __int16 v69 = (_WORD)k - v51 + 1;
            goto LABEL_88;
          }
        }

        goto LABEL_88;
      }

      __int128 v66 = (os_log_s *)mDNSLogCategory_Default_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_FAULT))
      {
        for (uint64_t m = (_BYTE *)v51; ; m += v73 + 1)
        {
          unsigned __int16 v69 = 257;
          uint64_t v73 = *m;
          if (v73 > 0x3F)
          {
            unsigned __int16 v69 = 257;
            break;
          }

          if (!*m)
          {
            unsigned __int16 v69 = (_WORD)m - v51 + 1;
            break;
          }
        }

LABEL_88:
        *(_DWORD *)buf = 141559043;
        *(void *)&uint8_t buf[4] = 1752392040LL;
        *(_WORD *)&buf[12] = 1040;
        *(_DWORD *)&buf[14] = v69;
        *(_WORD *)&buf[18] = 2101;
        *(void *)&buf[20] = v51;
        *(_WORD *)&buf[28] = 1024;
        *(_DWORD *)&buf[30] = v56;
        *(_WORD *)&buf[34] = 1024;
        *(_DWORD *)&buf[36] = v65;
        _os_log_impl( (void *)&_mh_execute_header,  v66,  OS_LOG_TYPE_FAULT,  "Invalid mDNSAddrType - domain: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P, interface index: %u, mDNSAddrType: v%d.",  buf,  0x28u);
      }

    uint64_t v38 = v69 + 1;
  }

  while (v69 != 498);
  for (uint64_t i = *(void *)(a1 + 12624); i; uint64_t i = *(void *)i)
  {
    if (*(void *)(i + 32) || *(_BYTE *)(i + 122) || IsLocalDomain(*(_BYTE **)(i + 40))) {
      mDNSCoreRestartRegistration((_DWORD *)a1, i, -1);
    }
    else {
      ActivateUnicastRegistration(a1, i);
    }
  }

  uint64_t v54 = (os_log_s *)mDNSLogCategory_Default;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
  {
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)buf = 0;
      goto LABEL_106;
    }
  }

  else
  {
    uint64_t v54 = (os_log_s *)mDNSLogCategory_Default_redacted;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)buf = 0;
LABEL_106:
      _os_log_impl( (void *)&_mh_execute_header,  v54,  OS_LOG_TYPE_DEBUG,  "mDNSCoreMachineSleep: recreating NAT mappings in 5 seconds",  buf,  2u);
    }
  }

  RecreateNATMappings(a1, 5000);
  uint64_t v57 = a1;
  int v58 = 8431;
LABEL_140:
  mDNS_Unlock_(v57, (uint64_t)"mDNSCoreMachineSleep", v58);
}

LABEL_188:
  int v111 = *(_DWORD *)(a1 + 148);
  if (v111 && *(_DWORD *)(a1 + 64) - v111 >= 0) {
    *(_DWORD *)(a1 + 148) = 0;
  }
  int v112 = *(_DWORD *)(a1 + 152);
  if (v112)
  {
    if (*(_DWORD *)(a1 + 64) - v112 >= 0)
    {
      *(_DWORD *)(a1 + 152) = 0;
      if (*(_BYTE *)(a1 + 141) == 1)
      {
        if (mDNS_LoggingEnabled == 1) {
          LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "Re-sleep delay passed; now checking for Sleep Proxy Servers",
        }
            (uint64_t)v4,
            v5,
            v6,
            v7,
            v8,
            v820);
        BeginSleepProcessing(a1);
      }
    }
  }

  int v113 = *(_DWORD *)(a1 + 164);
  if (v113)
  {
    if (*(_DWORD *)(a1 + 64) - v113 >= 0)
    {
      *(_DWORD *)(a1 + 164) = 0;
      uint64_t v114 = *(void *)(a1 + 200);
      if (v114)
      {
        while (2)
        {
          if (v114 == *(void *)(a1 + 208)) {
            goto LABEL_282;
          }
          uint64_t v115 = *(void *)(v114 + 144);
          if (!v115) {
            goto LABEL_281;
          }
          if (!*(_BYTE *)(v115 + 24)) {
            goto LABEL_281;
          }
          uint64_t v116 = *(void *)(*(void *)(v115 + 16) + 64LL);
          unsigned int v117 = bswap32(*(unsigned __int16 *)(v114 + 320));
          unsigned int v118 = HIWORD(v117);
          *(_WORD *)(v116 + 24) = HIWORD(v117);
          uint64_t v119 = *(void *)(v116 + 32);
          if (v119)
          {
            uint64_t v120 = *(void **)(v119 + 24);
            if (v120)
            {
              while (*(_DWORD *)(*v120 + 8LL))
              {
                uint64_t v120 = (void *)v120[1];
                if (!v120) {
                  goto LABEL_208;
                }
              }

LABEL_229:
              unint64_t v130 = (os_log_s *)mDNSLogCategory_DNSSEC;
              if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_DNSSEC == mDNSLogCategory_State)
              {
                if (os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC, OS_LOG_TYPE_INFO))
                {
                  uint64_t v132 = *(void *)(v116 + 16);
                  if (v132)
                  {
                    int v133 = *(_DWORD *)(v132 + 24);
                    uint64_t v132 = *(void *)(v132 + 16);
                  }

                  else
                  {
                    int v133 = 0;
                  }

LABEL_280:
                  *(_DWORD *)buf = 67109891;
                  *(_DWORD *)&uint8_t buf[4] = v118;
                  *(_WORD *)&buf[8] = 2160;
                  *(void *)&buf[10] = 1752392040LL;
                  *(_WORD *)&buf[18] = 1040;
                  *(_DWORD *)&buf[20] = v133;
                  *(_WORD *)&buf[24] = 2101;
                  *(void *)&buf[26] = v132;
                  _os_log_impl( (void *)&_mh_execute_header,  v130,  OS_LOG_TYPE_INFO,  "[Q%u] Current DNSSEC validation manager contains record(s) that are to be removed soon, wait for the coming update before updating the cache - name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P",  buf,  0x22u);
                }
              }

              else
              {
                unint64_t v130 = (os_log_s *)mDNSLogCategory_DNSSEC_redacted;
                if (os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC_redacted, OS_LOG_TYPE_INFO))
                {
                  uint64_t v132 = *(void *)(v116 + 16);
                  if (v132)
                  {
                    int v133 = *(_DWORD *)(v132 + 24);
                    uint64_t v132 = *(void *)(v132 + 16);
                  }

                  else
                  {
                    int v133 = 0;
                  }

                  goto LABEL_280;
                }
              }

              goto LABEL_281;
            }
          }

LABEL_208:
          uint64_t v121 = *(void *)(v116 + 40);
          if (v121)
          {
            uint64_t v122 = *(void **)(v121 + 24);
            if (v122)
            {
              while (*(_DWORD *)(*v122 + 8LL))
              {
                uint64_t v122 = (void *)v122[1];
                if (!v122) {
                  goto LABEL_212;
                }
              }

              goto LABEL_229;
            }
          }

  uint64_t v109 = a1;
  uint64_t v110 = v298;
  if (!v298) {
    goto LABEL_502;
  }
  int v300 = 0;
  unsigned int v303 = a1 + 28916;
  int v304 = (_DWORD *)(a1 + 28904);
  uint64_t v306 = (__int16 *)(a1 + 28910);
  uint64_t v295 = (__int16 *)(a1 + 28914);
  int v290 = (_BYTE *)(a1 + 46976);
  while (2)
  {
    int v111 = DetermineOwnerRecordSpace(v110);
    int v112 = mDNS_McastTracingEnabled;
    uint64_t v307 = 0LL;
    *int v304 = 8650752;
    *(void *)(a1 + 28908) = 0LL;
    int v113 = *(void *)(v109 + 12624);
    uint64_t v299 = v110;
    uint64_t v291 = v111;
    uint64_t v292 = v112;
    if (!v113)
    {
      LOWORD(v305) = 0;
      uint64_t v115 = a1 + 28916;
      goto LABEL_423;
    }

    uint64_t v305 = 0;
    if (v112) {
      uint64_t v114 = 20;
    }
    else {
      uint64_t v114 = 0;
    }
    uint64_t v293 = (unsigned __int8 *)(v110 + 6379);
    uint64_t v302 = v114 + v111;
    uint64_t v301 = (v111 | v112) != 0;
    uint64_t v115 = a1 + 28916;
    while (2)
    {
      uint64_t v116 = *(void *)(v113 + 224);
      unsigned int v117 = *(void *)(v110 + 6256);
      if (v116 == v117)
      {
        if (*(void *)(v113 + 32)) {
          goto LABEL_219;
        }
        if (mDNSPlatformValidRecordForInterface(v113, v116, a3, (uint64_t)a4, a5, a6, a7, a8))
        {
          uint64_t v116 = *(void *)(v113 + 224);
          unsigned int v117 = *(void *)(v110 + 6256);
          goto LABEL_216;
        }

        int v141 = v115;
        goto LABEL_294;
      }

  int v95 = (os_log_s *)mDNSLogCategory_XPC;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_XPC == mDNSLogCategory_State)
  {
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_XPC, OS_LOG_TYPE_DEBUG))
    {
      LOWORD(buf[0].st_dev) = 0;
      unint64_t v96 = "remove_state_dump_if_too_many fails";
LABEL_214:
      _os_log_impl((void *)&_mh_execute_header, v95, OS_LOG_TYPE_DEBUG, v96, (uint8_t *)buf, 2u);
    }
  }

  else
  {
    int v95 = (os_log_s *)mDNSLogCategory_XPC_redacted;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_XPC_redacted, OS_LOG_TYPE_DEBUG))
    {
      LOWORD(buf[0].st_dev) = 0;
      unint64_t v96 = "remove_state_dump_if_too_many fails";
      goto LABEL_214;
    }
  }

LABEL_212:
          uint64_t v123 = *(void *)(v116 + 64);
          if (v123)
          {
            uint64_t v124 = *(void **)(v123 + 24);
            if (v124)
            {
              while (*(_DWORD *)(*v124 + 8LL))
              {
                uint64_t v124 = (void *)v124[1];
                if (!v124) {
                  goto LABEL_216;
                }
              }

              goto LABEL_229;
            }
          }

      *(_DWORD *)buf = 67109891;
      uint64_t v94 = v50;
      int v95 = 2160;
      unint64_t v96 = 1752392040LL;
      uint64_t v97 = 1040;
      uint64_t v98 = v73;
      uint64_t v99 = 2101;
      uint64_t v100 = v51;
      uint64_t v16 = "[R%u] regservice_callback: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P is not valid DNS-SD SRV name";
      int v43 = (os_log_s *)v49;
      int v44 = 34;
      goto LABEL_101;
    }

    uint64_t v35 = *(void *)(v12 + 112);
    if (*(_BYTE *)(v35 + 1614))
    {
      *(_BYTE *)(a2 + 177) = 1;
      *(_BYTE *)(a2 + 1353) = 1;
      *(_BYTE *)(a2 + 2529) = 1;
      *(_BYTE *)(a2 + 3705) = 1;
    }

    if (!GenerateNTDResponse( *(char **)(a2 + 2448),  *(void *)(a2 + 2440),  v12,  (char **)&v92,  (char *)0x41,  2u,  0))
    {
      append_reply(*(void *)(v10 + 8), v92);
      *(_BYTE *)(v10 + 25) = 1;
      goto LABEL_184;
    }

    uint64_t v37 = (os_log_s *)mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_184;
      }
      uint64_t v39 = *(_DWORD *)(*(void *)(v10 + 8) + 184LL);
      uint64_t v40 = *(unsigned __int8 **)(a2 + 2448);
      if (v40)
      {
        int v41 = *(unsigned __int8 **)(a2 + 2448);
        if (v40 == (unsigned __int8 *)-256LL)
        {
LABEL_93:
          while (v41)
          {
            int v42 = *v41;
            if (!*v41)
            {
              uint64_t v70 = (unsigned __int16)((_WORD)v41 - (_WORD)v40 + 1);
              goto LABEL_183;
            }

            v41 += v42 + 1;
          }
        }

        else
        {
LABEL_92:
          if (v41 < v40 + 256) {
            goto LABEL_93;
          }
        }

        uint64_t v70 = 257;
      }

      else
      {
        uint64_t v70 = 0;
      }
    }

    else
    {
      uint64_t v37 = (os_log_s *)mDNSLogCategory_Default_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
      {
LABEL_184:
        if (!callExternalHelpers( *(void *)v35,  (_BYTE *)(v10 + 28),  *(unsigned int *)(*(void *)(v10 + 8) + 232LL),  v60,  v61,  v62,  v63,  v64))
        {
LABEL_203:
          if (*(_BYTE *)(v35 + 1612) && !CountPeerRegistrations(a2))
          {
            uint64_t v89 = dword_100158BF8;
            *(_DWORD *)(mDNSStorage[0] + 492) = v89;
          }

          return;
        }

        int v74 = (os_log_s *)mDNSLogCategory_Default;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
        {
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_192;
          }
          char v81 = *(_DWORD *)(*(void *)(v10 + 8) + 184LL);
          *(_DWORD *)buf = 67109120;
          uint64_t v94 = v81;
        }

        else
        {
          int v74 = (os_log_s *)mDNSLogCategory_Default_redacted;
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_192;
          }
          char v80 = *(_DWORD *)(*(void *)(v10 + 8) + 184LL);
          *(_DWORD *)buf = 67109120;
          uint64_t v94 = v80;
        }

        _os_log_impl( (void *)&_mh_execute_header,  v74,  OS_LOG_TYPE_DEFAULT,  "[R%u] regservice_callback: calling external_start_advertising_helper()",  buf,  8u);
LABEL_192:
        __darwin_time_t v82 = *(void *)(v10 + 8);
        __int16 v83 = *(void *)(v82 + 112);
        if (*(_WORD *)(v83 + 24))
        {
          __int128 v84 = *(void *)(v10 + 16);
          uint64_t v85 = *(_DWORD *)(v82 + 172);
          if (*(_BYTE *)(v10 + 27)) {
            LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "external_start_advertising_helper: external_advertise already set!",  v75,  v76,  v77,  v78,  v79,  v91);
          }
          if (*(_DWORD *)(v83 + 1616))
          {
            uint64_t v86 = 0LL;
            ssize_t v87 = v84 + 8;
            do
            {
              internal_start_advertising_service(v87, *(_DWORD *)(*(void *)(v10 + 8) + 232LL), v85);
              ++v86;
              v87 += 1176LL;
            }

            while (v86 < *(unsigned int *)(v83 + 1616));
          }

          internal_start_advertising_service(v10 + 1528, *(_DWORD *)(*(void *)(v10 + 8) + 232LL), v85);
          internal_start_advertising_service(v10 + 2704, *(_DWORD *)(*(void *)(v10 + 8) + 232LL), v85);
          internal_start_advertising_service(v10 + 3880, *(_DWORD *)(*(void *)(v10 + 8) + 232LL), v85);
          for (int j = *(void **)(v10 + 312); j; int j = (void *)*j)

            internal_start_advertising_service((uint64_t)(j + 3), *(_DWORD *)(*(void *)(v10 + 8) + 232LL), v85);
          *(_BYTE *)(v10 + 27) = 1;
        }

        else if (mDNS_LoggingEnabled == 1)
        {
          LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "external_start_advertising_helper: Not registering service with port number zero",  v75,  v76,  v77,  v78,  v79,  v91);
        }

        goto LABEL_203;
      }

      uint64_t v39 = *(_DWORD *)(*(void *)(v10 + 8) + 184LL);
      uint64_t v40 = *(unsigned __int8 **)(a2 + 2448);
      if (v40)
      {
        int v65 = *(unsigned __int8 **)(a2 + 2448);
        if (v40 == (unsigned __int8 *)-256LL)
        {
LABEL_147:
          while (v65)
          {
            __int128 v66 = *v65;
            if (!*v65)
            {
              uint64_t v70 = (unsigned __int16)((_WORD)v65 - (_WORD)v40 + 1);
              goto LABEL_183;
            }

            v65 += v66 + 1;
          }
        }

        else
        {
LABEL_146:
          if (v65 < v40 + 256) {
            goto LABEL_147;
          }
        }

        uint64_t v70 = 257;
      }

      else
      {
        uint64_t v70 = 0;
      }
    }

LABEL_281:
              uint64_t v114 = *(void *)(v114 + 8);
              if (!v114) {
                goto LABEL_282;
              }
              continue;
            }
          }

          else
          {
            if (!v121) {
              goto LABEL_281;
            }
            int v129 = dword_100158BF8 + 939524096;
          }

          break;
        }

        int v135 = dnssec_obj_rrset_get_rr_expire_time(v121);
        if (v135 - dword_100158BF8 < 1) {
          goto LABEL_281;
        }
        if (v129 - v135 > 0 && v135 != 0) {
          int v129 = v135;
        }
        goto LABEL_248;
      }
    }
  }

LABEL_282:
  int v151 = *(_DWORD *)(a1 + 168);
  if (v151 && *(_DWORD *)(a1 + 64) - v151 >= 0)
  {
    uint64_t v152 = *(uint64_t **)(a1 + 12664);
    if (v152)
    {
      while (!*((_BYTE *)v152 + 16))
      {
        uint64_t v152 = (uint64_t *)*v152;
        if (!v152) {
          goto LABEL_287;
        }
      }

      int v287 = 0;
      __int128 v288 = 0uLL;
LABEL_571:
      uint64_t v289 = v152[1];
      if (!v289) {
        goto LABEL_601;
      }
      int v290 = 0;
      for (nuint64_t n = 28LL; nn != 62; nn += 2LL)
        v290 += *(unsigned __int16 *)(v289 + nn);
      if (v290)
      {
        uint64_t v292 = (os_log_s *)mDNSLogCategory_mDNS;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
        {
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v294 = v152[782];
            uint64_t v295 = v294 + 5;
LABEL_589:
            *(_DWORD *)buf = 136446722;
            *(void *)&uint8_t buf[4] = (char *)v152 + 6310;
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = v294;
            *(_WORD *)&buf[18] = 2112;
            *(void *)&buf[20] = v289;
            _os_log_impl( (void *)&_mh_execute_header,  v292,  OS_LOG_TYPE_DEFAULT,  "mDNS response delay distribution - interface name: %{public}s, interface index: %u, report: %@",  buf,  0x1Cu);
          }
        }

        else
        {
          uint64_t v292 = (os_log_s *)mDNSLogCategory_mDNS_redacted;
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v294 = v152[782];
            uint64_t v297 = v294 + 5;
            goto LABEL_589;
          }
        }

        __int128 v288 = 0uLL;
        if (v287)
        {
          int v287 = 1;
          goto LABEL_600;
        }

        *(void *)buf = _NSConcreteStackBlock;
        *(void *)&buf[8] = 0x40000000LL;
        *(void *)&uint8_t buf[16] = __mDNSPostResponseDelayMetrics_block_invoke;
        *(void *)&buf[24] = &__block_descriptor_tmp_503;
        *(void *)&buf[32] = v289;
        if ((analytics_send_event_lazy("com.apple.mDNSResponder.mDNSResponseDelayEvent", buf, (__n128)0LL) & 1) == 0)
        {
          uint64_t v298 = (os_log_s *)mDNSLogCategory_mDNS;
          if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
          {
            if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_598;
            }
          }

          else
          {
            uint64_t v298 = (os_log_s *)mDNSLogCategory_mDNS_redacted;
            if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
            {
LABEL_598:
              *(_WORD *)__dst = 0;
              _os_log_impl( (void *)&_mh_execute_header,  v298,  OS_LOG_TYPE_DEFAULT,  "com.apple.mDNSResponder.mDNSResponseDelayEvent: Analytic not posted",  __dst,  2u);
            }
          }
        }

        int v287 = 1;
        __int128 v288 = 0uLL;
      }

LABEL_600:
      *(void *)(v289 + 54) = 0LL;
      *(_OWORD *)(v289 + 40) = v288;
      *(_OWORD *)(v289 + 24) = v288;
LABEL_601:
      while (1)
      {
        uint64_t v152 = (uint64_t *)*v152;
        if (!v152) {
          break;
        }
        if (*((_BYTE *)v152 + 16)) {
          goto LABEL_571;
        }
      }
    }

LABEL_322:
        int v172 = v171;
        __int128 v173 = DNSTypeName(*(unsigned __int16 *)(v164 + 322));
        *(_DWORD *)buf = 67110403;
        *(_DWORD *)&uint8_t buf[4] = v856;
        *(_WORD *)&buf[8] = 1024;
        *(_DWORD *)&buf[10] = v166;
        *(_WORD *)&buf[14] = 2160;
        *(void *)&uint8_t buf[16] = 1752392040LL;
        *(_WORD *)&buf[24] = 1040;
        *(_DWORD *)&buf[26] = v172;
        *(_WORD *)&buf[30] = 2101;
        *(void *)&buf[32] = v164 + 356;
        *(_WORD *)&buf[40] = 2082;
        *(void *)&buf[42] = v173;
        _os_log_impl( (void *)&_mh_execute_header,  v165,  OS_LOG_TYPE_DEFAULT,  "[R%d->Q%d] AnswerNewQuestion ERROR m->CurrentQuestion already set: %{sensitive, mask.hash, mdnsresponder:domai n_name}.*P (%{public}s)",  buf,  0x32u);
        uint64_t v154 = (void *)(a1 + 208);
        __int128 v158 = (_BYTE *)(a1 + 46976);
      }

LABEL_323:
      *(void *)(a1 + 216) = v155;
      uint64_t v174 = *(void *)(a1 + 12648);
      if (v174)
      {
        id v175 = (os_log_s *)mDNSLogCategory_Default;
        GetRRDisplayString_rdb((unsigned __int8 *)(v174 + 8), (unsigned __int16 *)(*(void *)(v174 + 48) + 4LL), v158);
        LogMsgWithLevel( v175,  OS_LOG_TYPE_DEFAULT,  "AnswerQuestionWithLORecord ERROR m->CurrentRecord already set %s",  v176,  v177,  v178,  v179,  v180,  (int)v158);
      }

      id v181 = AuthGroupForName(a1 + 6272, *(_DWORD *)(v155 + 200), (_BYTE *)(v155 + 356));
      __int128 v182 = v181;
      if (v181)
      {
        uint64_t v183 = v181[2];
        if (v183)
        {
          while (1)
          {
            if (v183 == v182[5]) {
              goto LABEL_336;
            }
            uint64_t v184 = *(void *)v183;
            *(void *)(a1 + 12648) = *(void *)v183;
            int v185 = *(_DWORD *)(v183 + 172);
            if (v185 == 4) {
              goto LABEL_332;
            }
            if (v185 == 5) {
              break;
            }
LABEL_335:
            uint64_t v183 = v184;
            if (!v184) {
              goto LABEL_336;
            }
          }

          uint64_t v186 = *(void *)(v155 + 136);
          if (!v186 || v186 == -5)
          {
LABEL_332:
            if (LocalOnlyRecordAnswersQuestion(v183, v155, v3, (uint64_t)v4, v5, v6, v7, v8))
            {
              AnswerLocalQuestionWithLocalAuthRecord(a1, v183, 1LL);
              if (*(void *)(a1 + 216) != v155) {
                goto LABEL_336;
              }
            }
          }

          uint64_t v184 = *(void *)(a1 + 12648);
          goto LABEL_335;
        }
      }

LABEL_336:
      *(void *)(a1 + 12648) = 0LL;
      if (*(void *)(a1 + 216) != v155)
      {
        __int128 v156 = (os_log_s **)&unk_100164000;
        uint64_t v153 = a1 + 12656;
        if (mDNS_LoggingEnabled != 1) {
          goto LABEL_343;
        }
        int v162 = (os_log_s *)mDNSLogCategory_Default;
        unint64_t v163 = "AnswerQuestionWithLORecord: Question deleted while while answering LocalOnly record answers";
LABEL_342:
        LogMsgWithLevel(v162, OS_LOG_TYPE_DEFAULT, v163, (uint64_t)v4, v5, v6, v7, v8, v820);
        goto LABEL_343;
      }

      uint64_t v153 = a1 + 12656;
      if (*(_BYTE *)(v155 + 335))
      {
        __int128 v156 = (os_log_s **)&unk_100164000;
        if (mDNS_LoggingEnabled != 1) {
          goto LABEL_343;
        }
        uint64_t v187 = mDNSLogCategory_Default;
        DNSTypeName(*(unsigned __int16 *)(v155 + 322));
        int v820 = v155;
        int v162 = (os_log_s *)v187;
        unint64_t v163 = "AnswerQuestionWithLORecord: Question %p %##s (%s) answered using local auth records LOAddressAnswers %d";
        goto LABEL_342;
      }

      if (v182)
      {
        uint64_t v188 = v182[5];
        if (v188)
        {
          while (1)
          {
            __int128 v156 = (os_log_s **)&unk_100164000;
            if (*(_DWORD *)(v188 + 172) == 4 && (*(_BYTE *)(v188 + 8) & 0x32) != 0)
            {
              unsigned int v189 = *(unsigned __int16 *)(v188 + 12);
              BOOL v53 = v189 > 0x1C;
              int v190 = (1 << v189) & 0x10001022;
              BOOL v191 = v53 || v190 == 0;
            }

            uint64_t v188 = *(void *)v188;
            if (!v188) {
              goto LABEL_356;
            }
          }

          uint64_t v153 = a1 + 12656;
          if (mDNS_LoggingEnabled == 1)
          {
            uint64_t v218 = (os_log_s *)mDNSLogCategory_Default;
            DNSTypeName(*(unsigned __int16 *)(v155 + 322));
            LogMsgWithLevel( v218,  OS_LOG_TYPE_DEFAULT,  "AnswerQuestionWithLORecord: Question %p %##s (%s) will be answered using new local auth records  LOAddressAnswers %d",  v219,  v220,  v221,  v222,  v223,  v155);
          }

          goto LABEL_343;
        }
      }

            uint64_t v123 = *(unsigned __int16 *)(v72 + 36);
            GetRRDisplayString_rdb( (unsigned __int8 *)(v72 + 32),  (unsigned __int16 *)(*(void *)(v72 + 72) + 4LL),  word_100164338);
            *(_DWORD *)buf = 141559299;
            *(void *)&uint8_t buf[4] = 1752392040LL;
            *(_WORD *)&buf[12] = 1040;
            *(_DWORD *)&buf[14] = v122;
            uint64_t v127 = 2101;
            *(void *)int v128 = v117;
            *(_WORD *)&v128[8] = 1024;
            *(_DWORD *)&v128[10] = v123;
            *(_WORD *)&v128[14] = 2160;
            *(void *)&v128[16] = 1752392040LL;
            *(_WORD *)&v128[24] = 2085;
            *(void *)&v128[26] = word_100164338;
            _os_log_impl( (void *)&_mh_execute_header,  v116,  OS_LOG_TYPE_DEFAULT,  "xD2DRemoveFromCache: removing record from cache - name: %{sensitive, mask.hash, mdnsresponder:domain_name} .*P, type: %{mdns:rrtype}d, auth record: %{sensitive, mask.hash}s",  buf,  0x36u);
          }
        }

        mDNS_Deregister((unsigned int *)mDNSStorage, v72 + 24);
        goto LABEL_153;
      }

LABEL_442:
            *(_BYTE *)(v155 + 337) = 1;
            if (v196)
            {
              if (*(int *)(v155 + 212) >= 1 && !*(void *)(v155 + 40))
              {
                *(_DWORD *)(v155 + 212) = 334;
                int v224 = *(_DWORD *)(a1 + 64) - 334;
                *(_DWORD *)(v155 + 208) = v224;
                if (!*(_WORD *)(v155 + 320))
                {
                  int v225 = *(_DWORD *)(a1 + 124);
                  if (!v225)
                  {
                    do
                      uint32_t v226 = arc4random() & 0x1FFF;
                    while (v226 > 0x1388);
                    int v225 = ((85899346 * (unint64_t)(v226 + 999)) >> 32) + 1;
                    *(_DWORD *)(a1 + 124) = v225;
                    int v224 = *(_DWORD *)(v155 + 208);
                  }

                  *(_DWORD *)(v155 + 208) = v225 + v224;
                }
              }
            }

            if (DPCFeatureEnabled_sOnce != -1) {
              dispatch_once(&DPCFeatureEnabled_sOnce, &__block_literal_global_3237);
            }
            if (DPCFeatureEnabled_sEnabled
              && !*(_WORD *)(v155 + 320)
              && *(int *)(v155 + 212) >= 1
              && !*(void *)(v155 + 40))
            {
              CFRange v227 = *(void **)(v155 + 136);
              if (v227)
              {
                _DPCSubscribe(v155, v227);
              }

              else if (gDPCPushServers)
              {
                *(void *)buf = _NSConcreteStackBlock;
                *(void *)&buf[8] = 0x40000000LL;
                *(void *)&uint8_t buf[16] = __DPCHandleNewQuestion_block_invoke;
                *(void *)&buf[24] = &__block_descriptor_tmp_27_3243;
                *(void *)&buf[32] = v155;
                mdns_cfdictionary_apply((const __CFDictionary *)gDPCPushServers, (uint64_t)buf);
              }
            }

            if (*(int *)(v155 + 212) >= 1 && !*(void *)(v155 + 40))
            {
              uint64_t v228 = *(void *)(v155 + 184);
              if (v228)
              {
                uint64_t v229 = *(void *)(v228 + 16);
                if (v229)
                {
                  if (*(_BYTE *)(v229 + 68))
                  {
                    *(_BYTE *)(v155 + 612) = 1;
                    *(_BYTE *)(v155 + 330) = 30;
                    *(_DWORD *)(v155 + 212) = 900000;
                    *(_DWORD *)(v155 + 208) = *(_DWORD *)(a1 + 64) - 899999;
                  }
                }
              }
            }

            SetNextQueryTime(a1, v155);
            goto LABEL_343;
          }

          if ((_BYTE)v846) {
            BOOL v211 = v195 == v857 + 1;
          }
          else {
            BOOL v211 = 1;
          }
          int v212 = !v211;
          int v214 = v850 && v195 == 1;
          if ((v212 & 1) == 0 && !v214)
          {
            char v196 = 0;
LABEL_472:
            __int128 v158 = (_BYTE *)(a1 + 46976);
            goto LABEL_429;
          }

          uint64_t v230 = (os_log_s *)mDNSLogCategory_DNSSEC;
          if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_DNSSEC == mDNSLogCategory_State)
          {
            if (os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC, OS_LOG_TYPE_DEFAULT))
            {
LABEL_470:
              unsigned int v231 = bswap32(*(unsigned __int16 *)(v155 + 320));
              *(_DWORD *)buf = 67109632;
              *(_DWORD *)&uint8_t buf[4] = HIWORD(v231);
              *(_WORD *)&buf[8] = 1024;
              *(_DWORD *)&buf[10] = v212;
              *(_WORD *)&buf[14] = 1024;
              *(_DWORD *)&uint8_t buf[16] = v214;
              _os_log_impl( (void *)&_mh_execute_header,  v230,  OS_LOG_TYPE_DEFAULT,  "[Q%u] Continue sending out query for the primary DNSSEC question due to incomplete answer set - only pos itive: %{mdns:yesno}d, only negative: %{mdns:yesno}d",  buf,  0x14u);
            }
          }

          else
          {
            uint64_t v230 = (os_log_s *)mDNSLogCategory_DNSSEC_redacted;
            if (os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC_redacted, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_470;
            }
          }

          char v196 = 1;
          goto LABEL_472;
        }
      }

      __int128 v156 = (os_log_s **)&unk_100164000;
      goto LABEL_429;
    }

    if (mDNS_LoggingEnabled == 1)
    {
      int v162 = v156[170];
      unint64_t v163 = "AnswerNewQuestion: Question deleted while doing CheckCacheExpiration";
      goto LABEL_342;
    }

                    LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "%3d: DNSServiceSetDefaultDomainForUser(unreadable parameters)",  a4,  a5,  a6,  a7,  a8,  *(_DWORD *)(v76 + 168));
                    goto LABEL_1121;
                  case 13:
                    __src[0] = -50331905;
                    v1496 = 0u;
                    v1495 = 0u;
                    v1494 = 0u;
                    v1493 = 0u;
                    v1492 = 0u;
                    v1491 = 0u;
                    v1490 = 0u;
                    memset(&v1489, 0, sizeof(v1489));
                    if (!*(void *)(v76 + 72)) {
                      goto LABEL_664;
                    }
                    int v203 = *(void *)(v76 + 80);
                    uint64_t v204 = &v1489;
                    while (1)
                    {
                      uint64_t v205 = *(unsigned __int8 **)(v76 + 72);
                      *(void *)(v76 + 72) = v205 + 1;
                      BOOL v207 = *v205;
                      LOBYTE(v204->st_dev) = v207;
                      uint64_t v204 = (stat *)((char *)v204 + 1);
                      if (!v207)
                      {
                        int v208 = (os_log_s *)mDNSLogCategory_Default;
                        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
                        {
                          if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
                            goto LABEL_659;
                          }
                        }

                        else
                        {
                          int v208 = (os_log_s *)mDNSLogCategory_Default_redacted;
                          if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
                          {
LABEL_659:
                            uint64_t v408 = *(_DWORD *)(v76 + 184);
                            *(_DWORD *)&v1504[0].sa_leuint64_t n = 67109378;
                            *(_DWORD *)&v1504[0].sa_data[2] = v408;
                            *(_WORD *)&v1504[0].sa_data[6] = 2082;
                            *(void *)&v1504[0].sa_data[8] = &v1489;
                            _os_log_impl( (void *)&_mh_execute_header,  v208,  OS_LOG_TYPE_DEFAULT,  "[R%d] DNSServiceGetProperty(%{public}s)",  &v1504[0].sa_len,  0x12u);
                          }
                        }

                        if (*(void *)&v1489.st_dev == 0x65566E6F6D656144LL
                          && *(void *)&v1489.st_nlink == 0x6E6F6973726556LL)
                        {
                          *(void *)&v1504[0].sa_leuint64_t n = 0x400000000000000LL;
                          *(_DWORD *)&v1504[0].sa_data[6] = 1193838744;
                          uint64_t v410 = *(_DWORD *)(v76 + 168);
                          uint64_t v411 = (socklen_t *)v1504;
                          uint64_t v412 = 12LL;
                        }

                        else
                        {
LABEL_664:
                          uint64_t v410 = *(_DWORD *)(v76 + 168);
                          uint64_t v411 = __src;
                          uint64_t v412 = 4LL;
                        }

                        send_all(v410, v411, v412);
                        goto LABEL_666;
                      }
                    }

                    *((_BYTE *)&v204->st_dev - (v204 == (stat *)v1497)) = 0;
                    *(void *)(v76 + 72) = 0LL;
                    goto LABEL_664;
                  case 14:
                    BOOL v210 = 0LL;
                    BOOL v211 = 0;
                    int v212 = *(unsigned int **)(v76 + 72);
                    if (v212)
                    {
                      uint64_t v213 = *(void *)(v76 + 80);
                      int v214 = 0;
                      if ((unint64_t)(v212 + 1) <= v213)
                      {
                        int v214 = 0;
                        BOOL v210 = 0LL;
                        BOOL v211 = bswap32(*v212);
                        *(void *)(v76 + 72) = v212 + 1;
                        if (v212 != (unsigned int *)-4LL && (unint64_t)(v212 + 2) <= v213)
                        {
                          int v214 = bswap32(v212[1]);
                          BOOL v210 = v212 + 2;
                        }
                      }
                    }

                    else
                    {
                      int v214 = 0;
                    }

                    *(void *)(v76 + 72) = v210;
                    uint64_t v345 = mDNSPlatformInterfaceIDfromInterfaceIndex(v214, a2, a3, a4, a5, a6, a7, a8);
                    uint64_t v346 = 0;
                    uint64_t v347 = 0LL;
                    uint64_t v349 = *(void *)(v76 + 72);
                    uint64_t v348 = *(void *)(v76 + 80);
                    if (v349 && v349 + 4 <= v348)
                    {
                      uint64_t v346 = *(unsigned __int8 *)(v349 + 3);
                      uint64_t v347 = (_BYTE *)(v349 + 4);
                    }

                    *(void *)(v76 + 72) = v347;
                    if (v214)
                    {
                      unint64_t updated = -65540;
                      if (!v345) {
                        goto LABEL_1122;
                      }
                    }

                    uint64_t v350 = *(unsigned __int16 **)(v76 + 144);
                    if (v350) {
                      goto LABEL_542;
                    }
                    int v351 = (unsigned __int16 *)calloc(1uLL, 0xD0uLL);
                    if (!v351) {
                      goto LABEL_2255;
                    }
                    uint64_t v350 = v351;
                    *(void *)(v76 + 144) = v351;
                    uint64_t v347 = *(_BYTE **)(v76 + 72);
                    uint64_t v348 = *(void *)(v76 + 80);
                    *(void *)(v76 + 72) = v347 + 1;
                    *((_BYTE *)v350 + 182) = *v347;
                    int v357 = *(_BYTE **)(v76 + 72);
                    *(void *)(v76 + 72) = v357 + 1;
                    *((_BYTE *)v350 + 183) = *v357;
                    int v358 = *(_BYTE **)(v76 + 72);
                    *(void *)(v76 + 72) = v358 + 1;
                    *(_BYTE *)uint64_t v350 = *v358;
                    int v359 = *(_BYTE **)(v76 + 72);
                    *(void *)(v76 + 72) = v359 + 1;
                    *((_BYTE *)v350 + 1) = *v359;
                    uint64_t v360 = *(unsigned int **)(v76 + 72);
                    if (!v360) {
                      goto LABEL_543;
                    }
LABEL_542:
                    uint64_t v361 = v360 + 1;
                    if ((unint64_t)(v360 + 1) <= *(void *)(v76 + 80))
                    {
                      unsigned __int16 v362 = *v360;
                      *(void *)(v76 + 72) = v361;
                      if (v361)
                      {
                        uint64_t v363 = bswap32(v362);
                        unint64_t updated = -65540;
                        if (v346)
                        {
                          if (!v350[91]) {
                            goto LABEL_1122;
                          }
                          unint64_t updated = -65540;
                          if ((v346 & 0x30) == 0) {
                            goto LABEL_1122;
                          }
                        }

                        else
                        {
                          if (v350[91]) {
                            goto LABEL_1122;
                          }
                          unint64_t updated = -65540;
                          if (*v350) {
                            goto LABEL_1122;
                          }
                          unint64_t updated = -65540;
                          if (v363) {
                            goto LABEL_1122;
                          }
                        }

                        *(_DWORD *)(v76 + 232) = v211;
                        *(_DWORD *)(v76 + 236) = v214;
                        if (v346 == 16) {
                          uint64_t v364 = 1;
                        }
                        else {
                          uint64_t v364 = 2;
                        }
                        if (!v346) {
                          uint64_t v364 = 0;
                        }
                        *((_BYTE *)v350 + 180) = v364;
                        int v365 = *v350;
                        v350[92] = v365;
                        *((_DWORD *)v350 + 47) = v363;
                        *((void *)v350 + 24) = port_mapping_create_request_callback;
                        *((void *)v350 + 25) = v76;
                        uint64_t v366 = (os_log_s *)mDNSLogCategory_Default;
                        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
                        {
                          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
                            goto LABEL_1114;
                          }
                        }

                        else
                        {
                          uint64_t v366 = (os_log_s *)mDNSLogCategory_Default_redacted;
                          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
                            goto LABEL_1114;
                          }
                        }

                        int v671 = *(_DWORD *)(v76 + 184);
                        int v672 = bswap32(v350[91]);
                        v673 = *(_DWORD *)(v76 + 172);
                        v1489.st_dev = 67110658;
                        *(_DWORD *)&v1489.st_mode = v671;
                        LOWORD(v1489.st_ino) = 1024;
                        *(_DWORD *)((char *)&v1489.st_ino + 2) = v346;
                        HIWORD(v1489.st_ino) = 1024;
                        v1489.st_uid = HIWORD(v672);
                        LOWORD(v1489.st_gid) = 1024;
                        *(gid_t *)((char *)&v1489.st_gid + 2) = __rev16(v365);
                        HIWORD(v1489.st_rdev) = 1024;
                        *(&v1489.st_rdev + 1) = v363;
                        LOWORD(v1489.st_atimespec.tv_sec) = 1024;
                        *(_DWORD *)((char *)&v1489.st_atimespec.tv_sec + 2) = v673;
                        HIWORD(v1489.st_atimespec.tv_sec) = 2082;
                        v1489.st_atimespec.tv_nsec = v76 + 240;
                        _os_log_impl( (void *)&_mh_execute_header,  v366,  OS_LOG_TYPE_DEFAULT,  "[R%d] DNSServiceNATPortMappingCreate(%X, %u, %u, %d) START PID[%d](%{public}s)",  (uint8_t *)&v1489,  0x30u);
LABEL_1114:
                        unint64_t updated = mDNS_StartNATOperation((uint64_t)(v350 + 4));
                        if (updated) {
                          LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "ERROR: mDNS_StartNATOperation: %d",  a4,  a5,  a6,  a7,  a8,  updated);
                        }
                        else {
                          *(void *)(v76 + 96) = port_mapping_termination_callback;
                        }
                        goto LABEL_1122;
                      }
                    }

                    else
                    {
LABEL_543:
                      *(void *)(v76 + 72) = 0LL;
                    }

                    int v352 = mDNSLogCategory_Default;
                    if (gSensitiveLoggingEnabled == 1 && mDNSLogCategory_Default != mDNSLogCategory_State)
                    {
                      int v352 = mDNSLogCategory_Default_redacted;
                      unint64_t updated = -65540;
                      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
                        goto LABEL_1122;
                      }
LABEL_547:
                      int v353 = *(_DWORD *)(v76 + 184);
                      v1489.st_dev = 67109120;
                      *(_DWORD *)&v1489.st_mode = v353;
                      uint64_t v114 = &v1489;
                      uint64_t v115 = (os_log_s *)v352;
                      uint64_t v116 = OS_LOG_TYPE_DEFAULT;
                      unsigned int v117 = "[R%d] DNSServiceNATPortMappingCreate(unreadable parameters)";
                      goto LABEL_1119;
                    }

                    unint64_t updated = -65540;
                    if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
                      goto LABEL_547;
                    }
                    goto LABEL_1122;
                  case 15:
                    if (*(void *)(v76 + 152)) {
                      goto LABEL_344;
                    }
                    uint64_t v215 = calloc(1uLL, 0x20uLL);
                    if (!v215) {
                      goto LABEL_2255;
                    }
                    *(void *)(v76 + 152) = v215;
LABEL_344:
                    bzero(&v1489.st_mode, 0x3F4uLL);
                    unsigned int v216 = *(unsigned __int8 **)(v76 + 72);
                    if (!v216) {
                      goto LABEL_894;
                    }
                    unsigned int v217 = *(void *)(v76 + 80);
                    uint64_t v218 = v216[1];
                    uint64_t v219 = *v216;
                    uint64_t v220 = *((unsigned __int16 *)v216 + 1);
                    *(void *)(v76 + 72) = v216 + 4;
                    uint64_t v221 = *((_DWORD *)v216 + 1);
                    *(void *)(v76 + 72) = v216 + 8;
                    uint64_t v222 = v216 + 12;
                    uint64_t v223 = bswap32(*((_DWORD *)v216 + 2));
                    *(void *)(v76 + 72) = v222;
                    v1489.st_dev = v223;
                    unint64_t updated = -65540;
                    if (!v222) {
                      goto LABEL_1122;
                    }
                    int v224 = (v219 << 24) | (v218 << 16) | (bswap32(v220) >> 16);
                    int v225 = bswap32(v221);
                    p_st_size = &v1489.st_mode;
                    uint64_t v164 = v1499;
                    do
                    {
                      uint32_t v226 = *(unsigned __int8 **)(v76 + 72);
                      if ((unint64_t)v226 >= v217 || p_st_size >= v1499)
                      {
LABEL_671:
                        BOOL v418 = &p_st_size[-(p_st_size == v164)];
LABEL_893:
                        os_log_s *v418 = 0;
LABEL_894:
                        *(void *)(v76 + 72) = 0LL;
                        goto LABEL_1121;
                      }

                      *(void *)(v76 + 72) = v226 + 1;
                      uint64_t v228 = *v226;
                      *p_st_size++ = v228;
                    }

                    while (v228);
                    uint64_t v229 = *(unsigned __int8 **)(v76 + 72);
                    if (!v229)
                    {
                      LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "%3d: DNSServiceGetAddrInfo(unreadable parameters)",  a4,  a5,  a6,  a7,  a8,  *(_DWORD *)(v76 + 168));
                      goto LABEL_1121;
                    }

                    v1499[0] = 0;
                    if ((*(_BYTE *)(v76 + 208) & 2) == 0) {
                      goto LABEL_366;
                    }
                    uint64_t v230 = *(void *)(v76 + 80);
                    unsigned int v231 = v229;
                    do
                    {
                      int v232 = v231 + 4;
                      v233 = __rev16(*((unsigned __int16 *)v231 + 1));
                      int64_t v234 = __rev16(*(unsigned __int16 *)v231);
                      unsigned int v231 = (unsigned __int8 *)&v232[v233];
                    }

                    while (v234 != 1);
                    *(void *)uint64_t v76 = Querier_RegisterCustomDNSServiceWithPListData(v232, v233);
LABEL_365:
                    v1499[0] = get_tlv_uint32(v229, v230, 2, 0LL) != 0;
LABEL_366:
                    *(void *)buf = 0LL;
                    signed_data_tlvs = _get_signed_data_tlvs(v76, (uint64_t *)buf);
                    if (!*(_BYTE *)(v76 + 274)) {
                      goto LABEL_371;
                    }
                    if (signed_data_tlvs)
                    {
                      *(_DWORD *)v1449 = 0;
                      uint64_t v236 = mdns_signed_resolve_result_create_from_data( (uint64_t)signed_data_tlvs,  *(size_t *)buf,  (int *)v1449);
                      if (v236 && !*(_DWORD *)v1449)
                      {
                        *(void *)(v76 + 48) = v236;
LABEL_371:
                        *(_DWORD *)(v76 + 232) = v224;
                        *(_DWORD *)(v76 + 236) = v225;
                        unsigned int v237 = _os_feature_enabled_impl("mDNSResponder", "dnssec");
                        memset(v1504, 0, sizeof(v1504));
                        v1505 = 0u;
                        v1506 = 0u;
                        v1507 = 0u;
                        memset(v1508, 0, sizeof(v1508));
                        v1509 = 0u;
                        v1510 = 0u;
                        v1511 = 0u;
                        v1512 = 0u;
                        v1513 = 0u;
                        v1514 = 0u;
                        v1515 = 0u;
                        v1516 = 0u;
                        v1517 = 0u;
                        AppendDNSNameString( v1504,  (unsigned __int8 *)&v1489.st_mode,  v238,  v239,  v240,  v241,  v242,  v243);
                        uint64_t v244 = _shouldLogFullRequestInfo((int *)(v76 + 188), (_DWORD *)(v76 + 192));
                        uint64_t v245 = gSensitiveLoggingEnabled;
                        uint64_t v246 = mDNSLogCategory_Default;
                        if (mDNSLogCategory_Default == mDNSLogCategory_State) {
                          uint64_t v245 = 0;
                        }
                        if ((v218 & 0x20) != 0 && v237)
                        {
                          if (v244)
                          {
                            if ((v245 & 1) != 0)
                            {
                              uint64_t v246 = mDNSLogCategory_Default_redacted;
                              if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
                                goto LABEL_1919;
                              }
                              v1404 = *(_DWORD *)(v76 + 184);
                              for (uint64_t i1 = v1504; ; uint64_t i1 = (sockaddr *)((char *)i1 + v249 + 1))
                              {
                                LOWORD(v248) = 257;
                                if (i1 >= (sockaddr *)v1518 || !i1) {
                                  goto LABEL_1910;
                                }
                                uint64_t v249 = i1->sa_len;
                                if (v249 > 0x3F)
                                {
                                  LOWORD(v248) = 257;
                                  goto LABEL_1910;
                                }

                                if (!i1->sa_len) {
                                  break;
                                }
                              }

                              BOOL v248 = (_DWORD)i1 - (v1501 + 32) + 1;
                            }

                            else
                            {
                              if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
                                goto LABEL_1919;
                              }
                              v1404 = *(_DWORD *)(v76 + 184);
                              for (i2 = v1504; ; i2 = (sockaddr *)((char *)i2 + v826 + 1))
                              {
                                LOWORD(v248) = 257;
                                if (i2 >= (sockaddr *)v1518 || !i2) {
                                  goto LABEL_1910;
                                }
                                int v826 = i2->sa_len;
                                if (v826 > 0x3F)
                                {
                                  LOWORD(v248) = 257;
                                  goto LABEL_1910;
                                }

                                if (!i2->sa_len) {
                                  break;
                                }
                              }

                              BOOL v248 = (_DWORD)i2 - (v1501 + 32) + 1;
                            }

                            BOOL v210 = v186;
                          }

                          else
                          {
                            BOOL v210 = 0;
                          }

        a4 = v25;
        goto LABEL_470;
      }

      if (a2 >= 0x201)
      {
        int v25 = a4;
        int v41 = (unsigned __int8 *)malloc(*(unsigned __int16 *)(a3 + 12));
        uint64_t v26 = v41;
        int v27 = (char *)v41;
        if (!v41) {
          goto LABEL_612;
        }
LABEL_70:
        uint64_t v371 = 0;
        uint64_t v370 = 0;
        char v63 = ResourceRecordGetRDataBytesPointer(a3, v27, a2, &v370, &v371, v18, v19, v20);
        if (!v371)
        {
          unint64_t v64 = (const void *)v63;
          int v65 = v370;
          if (v370 >= 0x1FFuLL)
          {
            size_t v67 = v370 + 2;
            int v41 = (unsigned __int8 *)malloc(v370 + 2LL);
            if (!v41) {
              goto LABEL_612;
            }
            uint64_t v68 = (__int16 *)v41;
            __int128 v66 = v41;
          }

          else
          {
            __int128 v66 = 0LL;
            size_t v67 = 512;
            uint64_t v68 = word_100164338;
          }

          uint64_t v364 = (size_t)v66;
          if (v11) {
            uint64_t v10 = (void *)mDNSLogCategory_Default;
          }
          else {
            uint64_t v10 = (void *)mDNSLogCategory_mDNS;
          }
          if (gSensitiveLoggingEnabled != 1 || v10 == (void *)mDNSLogCategory_State)
          {
            if (!os_log_type_enabled((os_log_t)v10, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_440;
            }
            uint64_t v127 = *(_DWORD *)(v369 + 184);
            int v128 = bswap32(*(unsigned __int16 *)(v368 + 320)) >> 16;
            int v129 = *(unsigned __int16 *)(a3 + 4);
            unint64_t v130 = v65 + 2;
            if ((int)v65 + 2 <= v67)
            {
              *uint64_t v68 = __rev16(v129);
              int v201 = v65;
              uint64_t v202 = v64;
              int v203 = v129;
              uint64_t v204 = v127;
              uint64_t v205 = v128;
              memcpy(v68 + 1, v202, v201);
              int v128 = v205;
              uint64_t v127 = v204;
              int v129 = v203;
            }

            else
            {
              uint64_t v68 = 0LL;
            }

            goto LABEL_397;
          }

          if (v11) {
            uint64_t v10 = (void *)mDNSLogCategory_Default_redacted;
          }
          else {
            uint64_t v10 = (void *)mDNSLogCategory_mDNS;
          }
          if (os_log_type_enabled((os_log_t)v10, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v127 = *(_DWORD *)(v369 + 184);
            int v128 = bswap32(*(unsigned __int16 *)(v368 + 320)) >> 16;
            int v129 = *(unsigned __int16 *)(a3 + 4);
            unint64_t v130 = v65 + 2;
            if ((int)v65 + 2 <= v67)
            {
              *uint64_t v68 = __rev16(v129);
              char v196 = v64;
              int v197 = v65;
              unsigned int v198 = v129;
              unsigned int v199 = v127;
              int v200 = v128;
              memcpy(v68 + 1, v196, v197);
              int v128 = v200;
              uint64_t v127 = v199;
              int v129 = v198;
            }

            else
            {
              uint64_t v68 = 0LL;
            }

LABEL_662:
    uint64_t v299 = v866 + 1;
    if (v866 != 498) {
      continue;
    }
    break;
  }

  uint64_t v324 = *(void *)(a1 + 216);
  v325 = &unk_100164000;
  if (v324)
  {
    int v326 = (os_log_s *)mDNSLogCategory_Default;
    int v327 = v324 + 356;
    DNSTypeName(*(unsigned __int16 *)(v324 + 322));
    LogMsgWithLevel( v326,  OS_LOG_TYPE_DEFAULT,  "SendQueries ERROR m->CurrentQuestion already set: %##s (%s)",  v328,  v329,  v330,  v331,  v332,  v327);
  }

  uint64_t v333 = *(void *)(a1 + 200);
  *(void *)(a1 + 216) = v333;
  if (!v333)
  {
    *(void *)(a1 + 216) = 0LL;
    int v342 = *(_DWORD *)(a1 + 64) + 939524096;
    *(_DWORD *)(a1 + 92) = v342;
    goto LABEL_774;
  }

  int v334 = 0;
  while (2)
  {
    if (v333 != *v845)
    {
      if (!*(_WORD *)(v333 + 320))
      {
        int v336 = *(_DWORD *)(v333 + 212);
        if (v336 >= 1 && !*(void *)(v333 + 40) && *(_DWORD *)(a1 + 64) - (v336 + *(_DWORD *)(v333 + 208)) >= 0)
        {
          if (*(_BYTE *)(v333 + 652))
          {
LABEL_677:
            *(void *)(v333 + 64) = -1LL;
            if (v334 <= v336) {
              int v334 = v336;
            }
          }

          else
          {
            *(void *)buf = 0LL;
            *(void *)&buf[8] = buf;
            *(void *)&uint8_t buf[16] = 0x2000000000LL;
            *(void *)&buf[24] = 0LL;
            *(void *)&buf[24] = CacheGroupForName(a1, *(_DWORD *)(v333 + 200), (_BYTE *)(v333 + 356));
            *(void *)__dst = 0LL;
            *(void *)&__dst[8] = __dst;
            *(void *)&_OWORD __dst[16] = 0x2000000000LL;
            LOBYTE(v882) = 0;
            *(_BYTE *)(v333 + 652) = 1;
            int v853 = *(_DWORD *)(v333 + 200);
            uint64_t v337 = *(void *)(v333 + 136);
            v879[0] = _NSConcreteStackBlock;
            v879[1] = 0x40000000LL;
            v879[2] = __SendQueries_block_invoke;
            v879[3] = &unk_100139DA0;
            v879[6] = v333;
            v879[7] = a1;
            v879[4] = buf;
            v879[5] = __dst;
            v338 = v879;
            if (_os_feature_enabled_impl("mDNSResponder", "unicast_assist_cache"))
            {
              LODWORD(v878) = 0;
              if (v337)
              {
                for (uint64_t i4 = 0LL; ; ++i4)
                {
                  if (_unicast_assist_hash_for_interface(v337, dword_1000FF5D0[i4], &v878))
                  {
                    if (i4) {
                      goto LABEL_692;
                    }
                  }

                  else if (_unicast_assist_addr_enumerate_interface_hash(v853, v337, (int)v878, v338) | i4)
                  {
                    goto LABEL_692;
                  }
                }
              }

              for (uint64_t i5 = s_interface_head_0; i5; uint64_t i5 = *(void *)i5)
              {
                if (!_unicast_assist_hash_for_interface( *(void *)(i5 + 24),  *(_DWORD *)(i5 + 36),  &v878)
                  && (_DWORD)v878 == *(_DWORD *)(i5 + 32)
                  && _unicast_assist_addr_enumerate_interface_hash( v853,  *(void *)(i5 + 24),  (int)v878,  v338))
                {
                  break;
                }
              }
            }

LABEL_692:
            int v341 = *(unsigned __int8 *)(*(void *)&__dst[8] + 24LL);
            _Block_object_dispose(__dst, 8);
            _Block_object_dispose(buf, 8);
            uint64_t v153 = a1 + 12656;
            if (!v341)
            {
              int v336 = *(_DWORD *)(v333 + 212);
              goto LABEL_677;
            }
          }
        }
      }

      uint64_t v335 = *(void *)(a1 + 216);
      if (v333 == v335)
      {
        uint64_t v335 = *(void *)(v333 + 8);
        *(void *)(a1 + 216) = v335;
      }

      uint64_t v333 = v335;
      if (!v335) {
        goto LABEL_699;
      }
      continue;
    }

    break;
  }

  int v343 = mDNS_LoggingEnabled;
  do
  {
    if (v343)
    {
      uint64_t v344 = (os_log_s *)mDNSLogCategory_Default;
      DNSTypeName(*(unsigned __int16 *)(v333 + 322));
      LogMsgWithLevel( v344,  OS_LOG_TYPE_DEFAULT,  "SendQueries question loop 1: Skipping NewQuestion %##s (%s)",  v345,  v346,  v347,  v348,  v349,  v333 + 356);
      int v343 = mDNS_LoggingEnabled;
      uint64_t v333 = *(void *)(a1 + 216);
    }

    uint64_t v333 = *(void *)(v333 + 8);
    *(void *)(a1 + 216) = v333;
  }

  while (v333);
LABEL_699:
  uint64_t v350 = *(void *)(a1 + 200);
  *(void *)(a1 + 216) = 0LL;
  int v342 = *(_DWORD *)(a1 + 64) + 939524096;
  *(_DWORD *)(a1 + 92) = v342;
  if (v350)
  {
    while (2)
    {
      if (v350 == *v845) {
        goto LABEL_772;
      }
      if (*(_WORD *)(v350 + 320)) {
        goto LABEL_749;
      }
      if (*(void *)(v350 + 64))
      {
        int v351 = *(_DWORD *)(a1 + 64);
        int v352 = *(_DWORD *)(v350 + 208);
        goto LABEL_704;
      }

      int v357 = *(_DWORD *)(v350 + 212);
      if (v357 < 1 || *(void *)(v350 + 40) || v357 > v334) {
        goto LABEL_749;
      }
      int v358 = *(_DWORD *)(a1 + 64);
      int v359 = *(_DWORD *)(v350 + 208) + v357;
      if ((int)(v358 + (v357 >> 1) - v359) < 0)
      {
LABEL_749:
        SetNextQueryTime(a1, v350);
        uint64_t v350 = *(void *)(v350 + 8);
        if (!v350)
        {
LABEL_772:
          int v342 = *(_DWORD *)(a1 + 64) + 939524096;
          v325 = &unk_100164000;
          uint64_t v153 = a1 + 12656;
          goto LABEL_774;
        }

        continue;
      }

      break;
    }

    uint64_t v360 = (_BYTE *)(v350 + 356);
    uint64_t v361 = (_BYTE *)(v350 + 356);
    if (v350 == -612) {
      goto LABEL_727;
    }
LABEL_724:
    unsigned __int16 v362 = 257;
    if ((unint64_t)v361 < v350 + 612 && v361)
    {
      do
      {
        uint64_t v363 = *v361;
        if (!*v361)
        {
          unsigned __int16 v362 = (_WORD)v361 - (_WORD)v360 + 1;
          goto LABEL_762;
        }

        v361 += v363 + 1;
        if (v350 != -612) {
          goto LABEL_724;
        }
LABEL_727:
        ;
      }

      while (v361);
      unsigned __int16 v362 = 257;
    }

LABEL_762:
    uint64_t v379 = CacheGroupForName(a1, *(_DWORD *)(v350 + 200), v360);
    if (v379)
    {
      uint64_t v385 = v379[2];
      if (v385)
      {
        unsigned int v386 = v362 + 4;
        do
        {
          if (*(unsigned __int16 *)(v385 + 20) <= 0x400u
            && SameNameRecordAnswersQuestion((unsigned __int8 *)(v385 + 8), 0, v350, v380, v381, v382, v383, v384))
          {
            int v387 = *(_DWORD *)(a1 + 64);
            if (*(_DWORD *)(v385 + 80) - v387 + ((1000 * *(_DWORD *)(v385 + 16)) >> 1) >= 0
              && *(_DWORD *)(v385 + 88) - (v387 + *(_DWORD *)(v350 + 212)) >= 1)
            {
              v386 += *(unsigned __int16 *)(v385 + 22) + 12;
              if (v386 > 0x1FF) {
                goto LABEL_749;
              }
            }
          }

          uint64_t v385 = *(void *)v385;
        }

        while (v385);
      }
    }

LABEL_720:
    int v352 = *(_DWORD *)(v350 + 208);
    int v351 = *(_DWORD *)(a1 + 64);
    if (v352 == v351) {
      goto LABEL_749;
    }
LABEL_704:
    int v353 = *(_DWORD *)(v350 + 212);
    if (v353 >= 0) {
      int v354 = *(_DWORD *)(v350 + 212);
    }
    else {
      int v354 = v353 + 1;
    }
    uint64_t v355 = v858;
    if (v351 - v352 - (v354 >> 1) >= 0)
    {
      if (!*(_BYTE *)(v350 + 331)
        || *(_DWORD *)(v350 + 228) < *(unsigned __int8 *)(v350 + 331)
        || *(_BYTE *)(v350 + 339)
        || (*(_BYTE *)(v350 + 307) & 4) != 0 && v353 == 334)
      {
        *(void *)(v350 + 64) = -1LL;
        int v356 = 3 * v353;
        *(_DWORD *)(v350 + 212) = 3 * v353;
        goto LABEL_714;
      }

      *(void *)(v350 + 64) = 0LL;
      *(_DWORD *)(v350 + 208) = v351;
      *(_DWORD *)(v350 + 212) = 3600000;
      *(_BYTE *)(v350 + 332) = 0;
      int v356 = 3600000;
      if (mDNS_LoggingEnabled != 1) {
        goto LABEL_1539;
      }
      uint64_t v364 = mDNSLogCategory_Default;
      int v821 = DNSTypeName(*(unsigned __int16 *)(v350 + 322));
      int v365 = (os_log_s *)v364;
      uint64_t v355 = v858;
      LogMsgWithLevel( v365,  OS_LOG_TYPE_DEFAULT,  "SendQueries: (%s) %##s reached threshold of %d answers",  v366,  v367,  v368,  v369,  v370,  v821);
      int v356 = *(_DWORD *)(v350 + 212);
LABEL_714:
      if (v356 <= 3600000)
      {
LABEL_1539:
        if (*(_WORD *)(v350 + 320)) {
          goto LABEL_735;
        }
        uint64_t v377 = *(void *)(v350 + 136);
        if (!v377 || *(_DWORD *)(v350 + 228) || v356 != 9018 || *(_BYTE *)(v350 + 332)) {
          goto LABEL_735;
        }
        int v378 = *(unsigned __int16 *)(v350 + 322);
        if (v378 == 28 || v378 == 1)
        {
          if (CacheHasAddressTypeForName(a1, (_BYTE *)(v350 + 356), *(_DWORD *)(v350 + 200))) {
            goto LABEL_735;
          }
          uint64_t v377 = *(void *)(v350 + 136);
        }

        ReconfirmAntecedents(a1, (_BYTE *)(v350 + 356), *(_DWORD *)(v350 + 200), v377, 0);
        goto LABEL_735;
      }

      *(_DWORD *)(v350 + 212) = 3600000;
    }

LABEL_735:
    uint64_t v371 = *(void *)(v350 + 64);
    *(_BYTE *)(v350 + 338) = v371 == -1;
    if (v371 == -1)
    {
      if (v355)
      {
        uint64_t v373 = *(void *)(v350 + 136);
        if (!v373) {
          uint64_t v373 = *(void *)(v355 + 6256);
        }
      }

      else
      {
        uint64_t v373 = 0LL;
      }

      *(void *)(v350 + 64) = v373;
      int v372 = *(_DWORD *)(a1 + 64);
      *(_DWORD *)(v350 + 208) = v372;
    }

    else
    {
      int v372 = *(_DWORD *)(a1 + 64);
    }

    uint64_t v374 = *(void *)(v350 + 56);
    if (v374)
    {
      uint64_t v375 = 0LL;
      int v376 = *(_DWORD *)(v350 + 212) / 2 - v372;
      do
      {
        if (v376 + *(_DWORD *)(v374 + v375 + 8) < 0) {
          *(void *)(v374 + v375) = 0LL;
        }
        v375 += 16LL;
      }

      while (v375 != 128);
    }

    *(_DWORD *)(v350 + 256) = v372;
    *(_DWORD *)(v350 + 224) = 0;
    if (*(_BYTE *)(v350 + 332)) {
      --*(_BYTE *)(v350 + 332);
    }
    goto LABEL_749;
  }

  v325 = &unk_100164000;
LABEL_774:
  *(_DWORD *)(a1 + 96) = v342;
  uint64_t v388 = *(void *)(a1 + 12648);
  if (v388)
  {
    uint64_t v389 = (os_log_s *)*((void *)v325 + 170);
    GetRRDisplayString_rdb( (unsigned __int8 *)(v388 + 8),  (unsigned __int16 *)(*(void *)(v388 + 48) + 4LL),  (_BYTE *)(a1 + 46976));
    LogMsgWithLevel( v389,  OS_LOG_TYPE_DEFAULT,  "SendQueries ERROR m->CurrentRecord already set %s",  v390,  v391,  v392,  v393,  v394,  a1 + 46976);
  }

  int v395 = *v871;
  if (*v871)
  {
    while (2)
    {
      *(void *)(a1 + 12648) = *v395;
      if (!v395[4] && !*((_BYTE *)v395 + 122) && !IsLocalDomain((_BYTE *)v395[5])
        || *((_BYTE *)v395 + 8) != 2
        || *((_WORD *)v395 + 6) == 41)
      {
        goto LABEL_832;
      }

      int v396 = *(_DWORD *)(a1 + 64);
      if (v396 - (*((_DWORD *)v395 + 71) + *((_DWORD *)v395 + 70)) >= 0)
      {
        int v397 = *((unsigned __int8 *)v395 + 190);
        if (*((_BYTE *)v395 + 190))
        {
          int v398 = *((_DWORD *)v395 + 36);
          if (v398 == 6)
          {
            if (mDNS_LoggingEnabled == 1)
            {
              v401 = (os_log_s *)mDNSLogCategory_Default;
              uint64_t v402 = (void *)(a1 + 12664);
              do
                uint64_t v402 = (void *)*v402;
              while (v402 && v402[782] != v395[4]);
              GetRRDisplayString_rdb( (unsigned __int8 *)v395 + 8,  (unsigned __int16 *)(v395[6] + 4),  (_BYTE *)(a1 + 46976));
              LogMsgWithLevel( v401,  OS_LOG_TYPE_DEFAULT,  "SendQueries NDP Probe %d %s %s",  v408,  v409,  v410,  v411,  v412,  v397);
              uint64_t v153 = a1 + 12656;
            }

            SendNDP(a1, 135, 0, (uint64_t)v395, (int8x8_t *)&zerov6Addr, 0LL, (uint64_t)v395 + 148, (uint64_t)v395 + 132);
          }

          else if (v398 == 4)
          {
            if (mDNS_LoggingEnabled == 1)
            {
              int v399 = (os_log_s *)mDNSLogCategory_Default;
              v400 = (void *)(a1 + 12664);
              do
                v400 = (void *)*v400;
              while (v400 && v400[782] != v395[4]);
              GetRRDisplayString_rdb( (unsigned __int8 *)v395 + 8,  (unsigned __int16 *)(v395[6] + 4),  (_BYTE *)(a1 + 46976));
              LogMsgWithLevel( v399,  OS_LOG_TYPE_DEFAULT,  "SendQueries ARP Probe %d %s %s",  v403,  v404,  v405,  v406,  v407,  v397);
              uint64_t v153 = a1 + 12656;
            }

            SendARP( a1,  1,  (uint64_t)v395,  (uint64_t)&zerov4Addr,  (uint64_t)&zeroEthAddr,  (uint64_t)v395 + 148,  (uint64_t)v395 + 132);
          }

          uint64_t v413 = v858;
          if (v858)
          {
            if (*(_DWORD *)((char *)v395 + 126))
            {
              uint64_t v413 = 0LL;
            }

            else
            {
              uint64_t v413 = v395[4];
              if (!v413) {
                uint64_t v413 = *(void *)(v858 + 6256);
              }
            }
          }

          v395[28] = v413;
          *((_DWORD *)v395 + 71) = *(_DWORD *)(a1 + 64);
          unsigned int v414 = *((unsigned __int8 *)v395 + 190);
          if (v414 >= 3) {
            LOBYTE(v414) = 3;
          }
          *((_BYTE *)v395 + 190) = v414 - 1;
          SetNextAnnounceProbeTime(a1, (uint64_t)v395);
          if (!*((_BYTE *)v395 + 190))
          {
            for (i6 = *(uint64_t **)(a1 + 12632); i6; i6 = (uint64_t *)*i6)
            {
              if (*((_BYTE *)i6 + 8) == 2 && i6[4] == v395[4])
              {
                unsigned int v416 = *((unsigned __int8 *)v395 + 8);
                BOOL v53 = v416 > 0x12;
                int v417 = (1 << v416) & 0x50006;
                BOOL v418 = v53 || v417 == 0;
                if (!v418
                  && *((_DWORD *)i6 + 6) == *((_DWORD *)v395 + 6)
                  && resource_records_have_same_dnssec_rr_category(i6[8], v395[8])
                  && *((unsigned __int16 *)i6 + 6) == *((unsigned __int16 *)v395 + 6)
                  && *((unsigned __int16 *)i6 + 7) == *((unsigned __int16 *)v395 + 7)
                  && *((unsigned __int16 *)i6 + 10) == *((unsigned __int16 *)v395 + 10)
                  && *((_DWORD *)i6 + 7) == *((_DWORD *)v395 + 7)
                  && SameRDataBody( (uint64_t)(i6 + 1),  (unsigned __int16 *)(v395[6] + 4),  (uint64_t (*)(uint64_t, unsigned __int16 *))SameDomainName)
                  && SameDomainNameBytes((_BYTE *)i6[5], (_BYTE *)v395[5]))
                {
                  *((_BYTE *)i6 + 190) = 0;
                }
              }
            }

            uint64_t v153 = a1 + 12656;
            if (!*((_BYTE *)v395 + 188)) {
              AcknowledgeRecord(a1, (uint64_t)v395);
            }
          }

LABEL_832:
          int v395 = *(uint64_t **)(a1 + 12648);
          if (!v395) {
            goto LABEL_833;
          }
          continue;
        }

        if (!*((_BYTE *)v395 + 188))
        {
          AcknowledgeRecord(a1, (uint64_t)v395);
          int v396 = *(_DWORD *)(a1 + 64);
        }

        *((_BYTE *)v395 + 8) = 16;
        *((_DWORD *)v395 + 70) = 500;
        *((_DWORD *)v395 + 71) = v396 - 500;
      }

      break;
    }

    SetNextAnnounceProbeTime(a1, (uint64_t)v395);
    goto LABEL_832;
  }

LABEL_833:
  uint64_t v2 = *(void *)(a1 + 12632);
  *(void *)(a1 + 12648) = v2;
  uint64_t v419 = (os_log_s **)&unk_100164000;
  uint64_t v420 = (void *)(a1 + 208);
  uint64_t v421 = v858;
  unint64_t v422 = a1 + 28904;
  unint64_t v423 = a1 + 28916;
  if (v2)
  {
    do
    {
      uint64_t v424 = *(void *)v2;
      *(void *)(a1 + 12648) = *(void *)v2;
      if (*(_BYTE *)(v2 + 8) == 2 && !*(_BYTE *)(v2 + 190) && !*(_BYTE *)(v2 + 188))
      {
        AcknowledgeRecord(a1, v2);
        uint64_t v424 = *(void *)(a1 + 12648);
      }

      uint64_t v2 = v424;
    }

    while (v424);
  }

  if (!v858) {
    goto LABEL_1122;
  }
  int v830 = 0;
  int v829 = 0;
  int v425 = (__int16 *)(a1 + 28910);
  unint64_t v854 = a1 + 30356;
  v867 = (__int16 *)(a1 + 28912);
  v843 = (_BYTE *)(a1 + 46976);
  v848 = (unsigned __int16 *)(a1 + 28914);
  while (2)
  {
    int v426 = DetermineOwnerRecordSpace(v421);
    if (mDNS_McastTracingEnabled) {
      int v427 = 20;
    }
    else {
      int v427 = 0;
    }
    v877 = 0LL;
    v878 = (_BYTE *)v423;
    int v831 = v426;
    int v834 = mDNS_McastTracingEnabled;
    BOOL v838 = (v426 | mDNS_McastTracingEnabled) == 0;
    *(_DWORD *)unint64_t v422 = 0;
    *(void *)(v422 + 4) = 0LL;
    uint64_t v428 = v880;
    uint64_t v859 = v421;
    if (v880)
    {
      LOBYTE(v837) = 0;
      int v429 = v427 + v426;
      unint64_t v430 = v423;
      goto LABEL_846;
    }

    v876 = &v880;
    int v825 = v427 + v426;
    unsigned int v875 = v427 + v426;
    uint64_t v435 = *(void *)(a1 + 200);
    if (!v435)
    {
      LOBYTE(v837) = 0;
      goto LABEL_924;
    }

    int v837 = 0;
    while (v435 != *v420)
    {
      if (*(_WORD *)(v435 + 320) || *(void *)(v435 + 64) != *(void *)(v421 + 6256)) {
        goto LABEL_900;
      }
      uint64_t v436 = *(void *)(v421 + 6256);
      if (DPCFeatureEnabled_sOnce != -1) {
        dispatch_once(&DPCFeatureEnabled_sOnce, &__block_literal_global_3237);
      }
      if (DPCFeatureEnabled_sEnabled && _DPCQuestionGetSubscriber(*(const __CFSet **)(v435 + 192), v436))
      {
        uint64_t v420 = (void *)(a1 + 208);
        uint64_t v421 = v859;
        goto LABEL_897;
      }

      uint64_t v437 = *(void *)(v435 + 56);
      uint64_t v420 = (void *)(a1 + 208);
      uint64_t v421 = v859;
      if (v437)
      {
        uint64_t v438 = 0LL;
        BOOL v439 = *(_BYTE *)(v859 + 17) == 0;
        BOOL v440 = *(_BYTE *)(v859 + 18) == 0;
        while (1)
        {
          if (*(void *)(v437 + v438) == *(void *)(v859 + 6256))
          {
            int v441 = *(_DWORD *)(v437 + v438 + 12);
            int v442 = v441 == 6 || v440;
            if (v441 == 4) {
              BOOL v439 = 1;
            }
            else {
              BOOL v440 = v442;
            }
            if (v439 && v440) {
              break;
            }
          }

          v438 += 16LL;
          if (v438 == 128) {
            goto LABEL_879;
          }
        }

        ++*(_DWORD *)(v153 + 7208);
      }

      else
      {
LABEL_879:
        if (!*(void *)(v435 + 40) && !*(_WORD *)(v435 + 320))
        {
          if (!*(_DWORD *)(v435 + 264) || *(_BYTE *)(v435 + 268))
          {
            unsigned int v443 = *(_DWORD *)(a1 + 64);
            if (v443 <= 1) {
              unsigned int v443 = 1;
            }
            *(_DWORD *)(v435 + 264) = v443;
            *(_BYTE *)(v435 + 268) = 0;
          }

          ++*(_DWORD *)(v435 + 260);
        }
      }

      if (!*(_BYTE *)(v435 + 336)) {
        goto LABEL_894;
      }
      unint64_t v444 = *(void *)(v435 + 136);
      v445 = (unsigned __int8 *)(v435 + 356);
      if ((v444 == 0 || v444 >= 0xFFFFFFFFFFFFFFFBLL) && ((1LL << (v444 + 5)) & 0x2D) != 0)
      {
        LogMsgWithLevel( v419[170],  OS_LOG_TYPE_DEFAULT,  "mDNSSendWakeOnResolve: ERROR!! Invalid InterfaceID %p for question %##s",  (uint64_t)v4,  v5,  v6,  v7,  v8,  *(void *)(v435 + 136));
        goto LABEL_893;
      }

      uint64_t v448 = *v445;
      if (v448 < 2)
      {
LABEL_915:
        LogMsgWithLevel( v419[170],  OS_LOG_TYPE_DEFAULT,  "mDNSSendWakeOnResolve: ERROR!! Malformed WakeOnResolve name %##s",  (uint64_t)v4,  v5,  v6,  v7,  v8,  v435 + 356);
        goto LABEL_893;
      }

      uint64_t v449 = 0LL;
      int v450 = 0;
      while (2)
      {
        int v451 = *(unsigned __int8 *)(v435 + 357 + v449);
        if (v451 == 58)
        {
          ++v450;
LABEL_914:
          if (v448 - 1 == ++v449) {
            goto LABEL_915;
          }
          continue;
        }

        break;
      }

      if (v451 != 64) {
        goto LABEL_914;
      }
      memset(__dst, 0, 18);
      memset(buf, 0, 47);
      if (v450 == 5)
      {
        int v452 = v449 + 1;
        int v453 = v449;
        if ((v449 + 1) < 0x13)
        {
          uint64_t v454 = v448 - v452;
          if ((int)v454 < 47)
          {
            memcpy(__dst, (const void *)(v435 + 357), v449);
            __dst[v453] = 0;
            memcpy(buf, &v445[v452 + 1], v454);
            buf[v454] = 0;
            ++*(_DWORD *)(v153 + 7280);
            mDNSPlatformSendWakeupPacket( v444,  (const char *)__dst,  (const char *)buf,  3 - *(unsigned __int8 *)(v435 + 336),  v455,  v456,  v457,  v458);
            uint64_t v419 = (os_log_s **)&unk_100164000;
          }

          else
          {
            uint64_t v419 = (os_log_s **)&unk_100164000;
            LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "mDNSSendWakeOnResolve: ERROR!! Malformed IP address %##s, length %d",  (uint64_t)v4,  v5,  v6,  v7,  v8,  v435 + 356);
          }
        }

        else
        {
          uint64_t v419 = (os_log_s **)&unk_100164000;
          LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "mDNSSendWakeOnResolve: ERROR!! Malformed Ethernet address %##s, length %d",  (uint64_t)v4,  v5,  v6,  v7,  v8,  v435 + 356);
        }
      }

      else
      {
        LogMsgWithLevel( v419[170],  OS_LOG_TYPE_DEFAULT,  "mDNSSendWakeOnResolve: ERROR!! Malformed Ethernet address %##s, cnt %d",  (uint64_t)v4,  v5,  v6,  v7,  v8,  v435 + 356);
      }

LABEL_893:
      --*(_BYTE *)(v435 + 336);
      uint64_t v420 = (void *)(a1 + 208);
      uint64_t v421 = v859;
LABEL_894:
      int v446 = v837;
      if (*(_BYTE *)(v435 + 620)) {
        int v446 = 1;
      }
      int v837 = v446;
LABEL_897:
      if (*(void *)(v435 + 136) || !*(_BYTE *)(v435 + 338))
      {
        uint64_t v447 = 0LL;
      }

      else
      {
        uint64_t v447 = *(void *)v421;
        if (*(void *)v421)
        {
          while (!*(_BYTE *)(v447 + 16))
          {
            uint64_t v447 = *(void *)v447;
            if (!v447) {
              goto LABEL_899;
            }
          }

          uint64_t v447 = *(void *)(v447 + 6256);
        }
      }

              LODWORD(buf.tv_sec) = 67112451;
              HIDWORD(buf.tv_sec) = v254;
              LOWORD(buf.tv_nsec) = 1024;
              *(_DWORD *)((char *)&buf.tv_nsec + 2) = v255;
              HIWORD(buf.tv_nsec) = 1024;
              *(_DWORD *)uint64_t v625 = v620;
              *(_WORD *)&v625[4] = 1024;
              *(_DWORD *)&v625[6] = a4;
              LOWORD(v626) = 1024;
              *(_DWORD *)((char *)&v626 + 2) = v605;
              HIWORD(v626) = 2160;
              *(void *)uint64_t v627 = 1752392040LL;
              *(_WORD *)&v627[8] = 1040;
              *(_DWORD *)&v627[10] = v443;
              *(_WORD *)&v627[14] = 2101;
              *(void *)&v627[16] = a2 + 356;
              *(_WORD *)&v627[24] = 1024;
              *(_DWORD *)&v627[26] = v592;
              *(_WORD *)&v627[30] = 1026;
              *(_DWORD *)&v627[32] = v43;
              *(_WORD *)&v627[36] = 1024;
              *(_DWORD *)&v627[38] = v444;
              *(_WORD *)&v627[42] = 2160;
              *(void *)&v627[44] = 1752392040LL;
              *(_WORD *)&v627[52] = 1040;
              *(_DWORD *)&v627[54] = v445;
              *(_WORD *)&v627[58] = 2101;
              *(void *)&v627[60] = v446;
              int v450 = "[R%u->Q%u] DNSServiceQueryRecord result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex"
                     ": %d, name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%x), dnssec: %{public, mdns:dnss"
                     "ec_result}d, type: %{mdns:rrtype}d, rdata: %{sensitive, mask.hash, mdns:rdata}.*P";
LABEL_907:
              int v464 = v253;
              BOOL v465 = 102;
LABEL_968:
              _os_log_impl((void *)&_mh_execute_header, v464, OS_LOG_TYPE_DEFAULT, v450, (uint8_t *)&buf, v465);
              a7 = v588;
              unsigned int v131 = v569;
            }

LABEL_899:
      *(void *)(v435 + 64) = v447;
LABEL_900:
      uint64_t v435 = *(void *)(v435 + 8);
      if (v435) {
        continue;
      }
      break;
    }

LABEL_924:
    if (DPCFeatureEnabled_sOnce != -1) {
      dispatch_once(&DPCFeatureEnabled_sOnce, &__block_literal_global_3237);
    }
    if (DPCFeatureEnabled_sEnabled) {
      BOOL v459 = v830 == 0;
    }
    else {
      BOOL v459 = 0;
    }
    if (v459)
    {
      if (*(_WORD *)(v422 + 4))
      {
        int v460 = 0;
        unint64_t v461 = (unint64_t)v878;
        v462 = (unsigned __int8 *)(a1 + 28916);
        while (1)
        {
          bzero(buf, 0x290uLL);
          Questiouint64_t n = getQuestion(v422, v462, v461, 0LL, buf);
          if (!Question)
          {
LABEL_942:
            uint64_t v421 = v859;
            qword_10014DFA0 = *(void *)(v859 + 6256);
            byte_10014E0AC = 2;
            BuildQuestion(a1, v859, v422, (unint64_t *)&v878, (uint64_t)&DPCBrowse, &v876, &v875, v8);
            qword_10014DFA0 = 0LL;
            int v830 = 1;
            goto LABEL_944;
          }

          v462 = Question;
          int v464 = v908 & 0x7FFF;
          v908 &= ~0x8000u;
          BOOL v465 = v907 == word_10014E0A2 && v464 == (unsigned __int16)word_10014E0A4;
        }

        int v830 = 1;
        uint64_t v421 = v859;
      }

      else
      {
        int v830 = 0;
      }
    }

LABEL_944:
    uint64_t v466 = (uint64_t)*v871;
    if (!*v871)
    {
      unsigned __int16 v467 = 0;
      goto LABEL_1019;
    }

    int v823 = 0;
    unsigned __int16 v467 = 0;
    v822 = (_BYTE *)(v421 + 6381);
    unsigned int v827 = v875;
    while (2)
    {
      if (!*(_BYTE *)(v466 + 194))
      {
        uint64_t v2 = *(void *)(v466 + 224);
        if (v2 == *(void *)(v421 + 6256) && *(_WORD *)(v466 + 12) != 41)
        {
          if (mDNSPlatformValidRecordForInterface(v466, v2, v3, (uint64_t)v4, v5, v6, v7, v8))
          {
            if (*(unsigned __int8 *)(v466 + 190) >= 2u && *(_BYTE *)(a1 + 12))
            {
              int v468 = *(unsigned __int16 *)(v422 + 4);
              uint64_t v469 = 1440LL;
              if (!*(_WORD *)(v422 + 4)) {
                uint64_t v469 = 8940LL;
              }
              if (*v822) {
                __int16 v470 = 0x8000;
              }
              else {
                __int16 v470 = 0;
              }
            }

            else
            {
              __int16 v470 = 0;
              int v468 = *(unsigned __int16 *)(v422 + 4);
              uint64_t v469 = 1440LL;
              if (!*(_WORD *)(v422 + 4)) {
                uint64_t v469 = 8940LL;
              }
            }

            v471 = (unsigned __int8 *)(a1 + 28916);
            unint64_t v472 = v851 + v469;
            unsigned __int16 v473 = *(_WORD *)(v466 + 14) | v470;
            bzero(buf, 0x290uLL);
            if (v468)
            {
              int v474 = 0;
              while (1)
              {
                v471 = getQuestion(v422, v471, v472, 0LL, buf);
                if (v471)
                {
                  if (v907 == 255
                    && v908 == v473
                    && v906 == *(_DWORD *)(v466 + 24)
                    && SameDomainNameBytes(v910, *(_BYTE **)(v466 + 40)))
                  {
                    break;
                  }
                }

                LOBYTE(v468) = 0;
                if (v471)
                {
                }

                goto LABEL_977;
              }

              LOBYTE(v468) = 1;
            }

LABEL_977:
            uint64_t v476 = a1 + 12624;
            v477 = UnsafeBufferPointer(*v871, v466, (uint64_t **)&v877);
            if (v467 == 0 && v838) {
              int v478 = 25;
            }
            else {
              int v478 = 14;
            }
            unsigned int v479 = v827 + v478;
            if (v477)
            {
              ++v467;
              unsigned int v480 = v479;
            }

            else
            {
              unsigned int v480 = v827;
            }

            while (1)
            {
              uint64_t v476 = *(void *)v476;
              if (!v476) {
                break;
              }
              if (AddRecordInProbe(a1, v466, v476, *(void *)(v859 + 6256))) {
                v480 += *(unsigned __int16 *)(v476 + 22) + 12;
              }
            }

            uint64_t v2 = (uint64_t)v878;
            if ((v468 & 1) != 0)
            {
            }

            else
            {
              v481 = putQuestion( v422,  (unint64_t)v878,  v472 - v480,  *(unsigned __int8 **)(v466 + 40),  0xFFuLL,  v473,  v7,  v8);
              if (!v481)
              {
                ++v823;
                goto LABEL_1004;
              }

              v878 = v481;
            }

            for (i7 = *v871; i7; i7 = (uint64_t *)*i7)
            {
              if (AddRecordInProbe(a1, v466, (uint64_t)i7, *(void *)(v859 + 6256)))
              {
                if (*(void *)(v466 + 32))
                {
                  uint64_t v483 = 0LL;
                }

                else
                {
                  uint64_t v483 = v859;
                  while (1)
                  {
                    uint64_t v483 = *(void *)v483;
                    if (!v483) {
                      break;
                    }
                    if (*(_BYTE *)(v483 + 16))
                    {
                      uint64_t v483 = *(void *)(v483 + 6256);
                      break;
                    }
                  }
                }

                i7[28] = v483;
                *((_BYTE *)i7 + 194) = 1;
              }
            }

            unsigned int v827 = v480;
LABEL_1004:
            uint64_t v421 = v859;
          }

          else
          {
            if (*(void *)(v466 + 32))
            {
              uint64_t v475 = 0LL;
            }

            else
            {
              uint64_t v475 = *(void *)v421;
              if (*(void *)v421)
              {
                while (!*(_BYTE *)(v475 + 16))
                {
                  uint64_t v475 = *(void *)v475;
                  if (!v475) {
                    goto LABEL_971;
                  }
                }

                uint64_t v475 = *(void *)(v475 + 6256);
              }
            }

LABEL_971:
            *(void *)(v466 + 224) = v475;
            *(_BYTE *)(v466 + 194) = 0;
          }
        }
      }

      uint64_t v466 = *(void *)v466;
      if (v466) {
        continue;
      }
      break;
    }

    if (v823)
    {
      v484 = (os_log_s *)mDNSLogCategory_mDNS;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
      {
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEBUG)) {
          goto LABEL_1018;
        }
      }

      else
      {
        v484 = (os_log_s *)mDNSLogCategory_mDNS_redacted;
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEBUG))
        {
LABEL_1018:
          uint64_t v487 = *(void *)(v859 + 6256);
          *(_DWORD *)buf = 67109376;
          *(_DWORD *)&uint8_t buf[4] = v823;
          *(_WORD *)&buf[8] = 2048;
          *(void *)&buf[10] = v487;
          _os_log_impl( (void *)&_mh_execute_header,  v484,  OS_LOG_TYPE_DEBUG,  "SendQueries: %u questions will be sent in a later request on InterfaceID= %p",  buf,  0x12u);
        }
      }
    }

LABEL_1019:
    uint64_t v428 = v880;
    unint64_t v430 = (unint64_t)v878;
    if (v880)
    {
      int v429 = v825 + 14 * v467;
      if (v467)
      {
        int v431 = 11;
        uint64_t v153 = a1 + 12656;
        goto LABEL_847;
      }

      uint64_t v153 = a1 + 12656;
LABEL_846:
      int v431 = 0;
LABEL_847:
      if (!v838) {
        int v431 = 0;
      }
      unint64_t v432 = v854 - (v431 + v429);
      while (1)
      {
        unint64_t v433 = PutResourceRecordTTLWithLimit( v422,  v430,  v425,  v428 + 8,  *(_DWORD *)(v428 + 16) - (*(_DWORD *)(a1 + 64) - *(_DWORD *)(v428 + 80)) / 0x3E8u,  v432,  v7,  v8);
        if (!v433) {
          break;
        }
        unint64_t v430 = v433;
        v878 = (_BYTE *)v433;
        uint64_t v880 = *(void *)(v428 + 72);
        uint64_t v434 = v880;
        *(void *)(v428 + 72) = 0LL;
        uint64_t v428 = v434;
        if (!v434) {
          goto LABEL_1023;
        }
      }

      if (*(unsigned __int16 *)(v422 + 4) >= 2u) {
        LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "SendQueries:   Put %d answers; No more space for known answers",
      }
          (uint64_t)v4,
          v5,
          v6,
          v7,
          v8,
          (unsigned __int16)*v425);
      *(_BYTE *)(v422 + 2) |= 2u;
      unint64_t v430 = (unint64_t)v878;
    }

    else
    {
      uint64_t v153 = a1 + 12656;
    }

LABEL_1023:
    v488 = *v871;
    if (*v871)
    {
      unsigned __int16 v489 = 0;
      unint64_t v490 = v430;
      do
      {
        if (*((_BYTE *)v488 + 194))
        {
          else {
            unint64_t v491 = a1 + 30356;
          }
          unint64_t v430 = PutResourceRecordTTLWithLimit( v422,  v490,  v867,  (uint64_t)(v488 + 1),  *((unsigned int *)v488 + 4),  v491,  v7,  v8);
          *((_BYTE *)v488 + 194) = 0;
          if (!v430)
          {
            v492 = (os_log_s *)mDNSLogCategory_Default;
            GetRRDisplayString_rdb((unsigned __int8 *)v488 + 8, (unsigned __int16 *)(v488[6] + 4), v843);
            LogMsgWithLevel( v492,  OS_LOG_TYPE_DEFAULT,  "SendQueries:   How did we fail to have space for the Update record %s",  v493,  v494,  v495,  v496,  v497,  (int)v843);
            unint64_t v430 = v490;
          }

          v498 = UnsafeBufferPointer(*v871, (uint64_t)v488, (uint64_t **)&v877);
          if (v498)
          {
            v499 = v498;
            uint64_t v500 = v488[5];
            __int16 v501 = *v425;
            __int16 v502 = *v848;
            __int16 v503 = *v867;
            v504 = calloc(1uLL, 0x18uLL);
            if (!v504) {
              __break(1u);
            }
            ++v489;
            *((_WORD *)v499 + 4) = v501 + v502 + v503 - 1;
            v504[1] = v499;
            v504[2] = v500;
            void *v504 = v877;
            v877 = v504;
            unint64_t v422 = a1 + 28904;
          }

          uint64_t v153 = a1 + 12656;
        }

        else
        {
          unint64_t v430 = v490;
        }

        v488 = (uint64_t *)*v488;
        unint64_t v490 = v430;
      }

      while (v488);
    }

    else
    {
      unsigned __int16 v489 = 0;
    }

    v878 = (_BYTE *)v430;
    unint64_t v423 = a1 + 28916;
    if (v430 <= v851)
    {
      uint64_t v421 = *(void *)v859;
      uint64_t v420 = (void *)(a1 + 208);
      if (*(void *)v859)
      {
        uint64_t v419 = (os_log_s **)&unk_100164000;
        do
        {
          if (*(_BYTE *)(v421 + 16)) {
            break;
          }
          uint64_t v421 = *(void *)v421;
        }

        while (v421);
        int v830 = 0;
      }

      else
      {
        int v830 = 0;
        uint64_t v419 = (os_log_s **)&unk_100164000;
      }

      goto LABEL_1116;
    }

    v505 = (void **)v877;
    BOOL v506 = v838;
    if (v877) {
      BOOL v506 = 0;
    }
    uint64_t v420 = (void *)(a1 + 208);
    uint64_t v421 = v859;
    if (!v506)
    {
      bzero(buf, 0x498uLL);
      buf[8] = 32;
      strcpy((char *)&buf[12], ")");
      *(_DWORD *)&uint8_t buf[16] = 4500;
      __int16 v930 = 264;
      *(void *)&buf[40] = v929;
      *(void *)&uint8_t buf[48] = &v930;
      char v909 = 0;
      v910[0] = 0;
      __int128 v899 = 0u;
      __int128 v900 = 0u;
      __int128 v901 = 0u;
      __int128 v902 = 0u;
      __int128 v903 = 0u;
      __int128 v904 = 0u;
      uint64_t v905 = 0LL;
      v911 = v929;
      __int16 v925 = 0;
      uint64_t v927 = 0LL;
      uint64_t v928 = 0LL;
      uint64_t v926 = 0LL;
      v929[0] = 0;
      __int128 v912 = 0u;
      __int128 v913 = 0u;
      __int128 v914 = 0u;
      __int128 v915 = 0u;
      __int128 v916 = 0u;
      __int128 v917 = 0u;
      __int128 v918 = 0u;
      __int128 v919 = 0u;
      __int128 v920 = 0u;
      __int128 v921 = 0u;
      __int128 v922 = 0u;
      __int128 v923 = 0u;
      memset(v924, 0, sizeof(v924));
      *(_WORD *)&buf[14] = 1440;
      *(_WORD *)&buf[22] = 0;
      if (v831)
      {
        *(_DWORD *)&buf[20] = 1572888;
        SetupOwnerOpt(a1, v859, (uint64_t)&v931);
        unsigned int v510 = 1;
      }

      else
      {
        unsigned int v510 = 0;
      }

      if (v834)
      {
        *(_WORD *)&buf[20] += 24;
        *(_WORD *)&buf[22] += 24;
        uint64_t v511 = *(void *)&buf[48] + 24LL * v510++;
        *(_BYTE *)(v511 + 8) = *(_BYTE *)(v153 + 28);
        *(_DWORD *)(v511 + 12) = -1735907257;
        *(_DWORD *)(v511 + 4) = 392681;
      }

      if (v505)
      {
        *(_WORD *)&buf[20] += 24;
        *(_WORD *)&buf[22] += 24;
        v512 = (int *)v505[1];
        uint64_t v513 = *(void *)&buf[48] + 24LL * v510;
        *(_DWORD *)(v513 + 12) = v512[1];
        *(_WORD *)(v513 + 16) = *((_WORD *)v512 + 4);
        int v514 = *v512;
        *(_DWORD *)(v513 + 4) = 720362;
        *(_DWORD *)(v513 + 8) = v514;
        v877 = *v505;
        free(v505);
      }

      v507 = (char *)PutResourceRecordTTLWithLimit( v422,  v430,  v848,  (uint64_t)&buf[8],  *(unsigned int *)&buf[16],  v863,  v508,  v509);
      v878 = v507;
      if (v507 && v877)
      {
        v507 = AddTSRROptsToMessage(&v877, v422, (_WORD *)(v430 + 9), v507, v863, v6, v7, v8);
        v878 = v507;
      }

      uint64_t v419 = (os_log_s **)&unk_100164000;
      if (!v507)
      {
        v515 = (os_log_s *)mDNSLogCategory_mDNS;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
        {
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_ERROR))
          {
            if (v831) {
              v516 = "OWNER";
            }
            else {
              v516 = "";
            }
            if (v834) {
              v517 = "TRACER";
            }
            else {
              v517 = "";
            }
LABEL_1078:
            int v824 = *(unsigned __int16 *)(a1 + 28908);
            int v826 = *(unsigned __int16 *)(a1 + 28910);
            int v828 = *(unsigned __int16 *)(a1 + 28912);
            int v839 = *(unsigned __int16 *)(a1 + 28914);
            GetRRDisplayString_rdb(&buf[8], (unsigned __int16 *)(*(void *)&buf[48] + 4LL), v843);
            *(_DWORD *)__dst = 136316930;
            *(void *)&__dst[4] = v516;
            *(_WORD *)&__dst[12] = 2080;
            *(void *)&__dst[14] = v517;
            *(_WORD *)&__dst[22] = 1024;
            int v882 = v489;
            unint64_t v422 = a1 + 28904;
            __int16 v883 = 1024;
            *(_DWORD *)v884 = v824;
            *(_WORD *)&v884[4] = 1024;
            *(_DWORD *)&v884[6] = v826;
            uint64_t v419 = (os_log_s **)&unk_100164000;
            LOWORD(v885) = 1024;
            *(_DWORD *)((char *)&v885 + 2) = v828;
            HIWORD(v885) = 1024;
            LODWORD(v886) = v839;
            WORD2(v886) = 2080;
            *(void *)((char *)&v886 + 6) = a1 + 46976;
            uint64_t v153 = a1 + 12656;
            _os_log_impl( (void *)&_mh_execute_header,  v515,  OS_LOG_TYPE_ERROR,  "SendQueries: How did we fail to have space for %s %s TSR(%d) OPT record (%d/%d/%d/%d) %s",  __dst,  0x3Eu);
          }
        }

        else
        {
          v515 = (os_log_s *)mDNSLogCategory_mDNS_redacted;
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_ERROR))
          {
            if (v831) {
              v516 = "OWNER";
            }
            else {
              v516 = "";
            }
            if (v834) {
              v517 = "TRACER";
            }
            else {
              v517 = "";
            }
            goto LABEL_1078;
          }
        }
      }

      if ((unint64_t)v507 > v854)
      {
        int v518 = *(unsigned __int16 *)(v422 + 4);
        if (v518 != 1 || *v425 || *v867 != 1 || *v848 != 1)
        {
          uint64_t v519 = mDNSLogCategory_mDNS;
          if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
          {
            if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_ERROR))
            {
              if (v831) {
                v524 = "OWNER";
              }
              else {
                v524 = "";
              }
              if (v834) {
                v525 = "TRACER";
              }
              else {
                v525 = "";
              }
              int v833 = (unsigned __int16)*v425;
              int v836 = (unsigned __int16)*v867;
              int v841 = *v848;
              GetRRDisplayString_rdb(&buf[8], (unsigned __int16 *)(*(void *)&buf[48] + 4LL), v843);
              *(_DWORD *)__dst = 136317698;
              *(void *)&__dst[4] = v524;
              *(_WORD *)&__dst[12] = 2080;
              *(void *)&__dst[14] = v525;
              unint64_t v422 = a1 + 28904;
              *(_WORD *)&__dst[22] = 1024;
              int v882 = v489;
              __int16 v883 = 2048;
              *(void *)v884 = a1 + 28916;
              *(_WORD *)&v884[8] = 2048;
              uint64_t v885 = a1 + 30356;
              LOWORD(v886) = 2048;
              *(void *)((char *)&v886 + 2) = v507;
              WORD5(v886) = 1024;
              HIDWORD(v886) = v518;
              __int16 v887 = 1024;
              int v888 = v833;
              __int16 v889 = 1024;
              int v890 = v836;
              uint64_t v419 = (os_log_s **)&unk_100164000;
              __int16 v891 = 1024;
              int v892 = v841;
              __int16 v893 = 2080;
              uint64_t v894 = a1 + 46976;
              uint64_t v153 = a1 + 12656;
              v523 = (os_log_s *)v519;
LABEL_1102:
              _os_log_impl( (void *)&_mh_execute_header,  v523,  OS_LOG_TYPE_ERROR,  "SendQueries: Why did we generate oversized packet with %s %s TSR(%d) OPT record %p %p %p (%d/%d/%d/%d) %s",  __dst,  0x5Cu);
            }
          }

          else
          {
            uint64_t v520 = mDNSLogCategory_mDNS_redacted;
            if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_ERROR))
            {
              if (v831) {
                v521 = "OWNER";
              }
              else {
                v521 = "";
              }
              if (v834) {
                v522 = "TRACER";
              }
              else {
                v522 = "";
              }
              int v832 = (unsigned __int16)*v425;
              int v835 = (unsigned __int16)*v867;
              int v840 = *v848;
              GetRRDisplayString_rdb(&buf[8], (unsigned __int16 *)(*(void *)&buf[48] + 4LL), v843);
              *(_DWORD *)__dst = 136317698;
              *(void *)&__dst[4] = v521;
              *(_WORD *)&__dst[12] = 2080;
              *(void *)&__dst[14] = v522;
              unint64_t v422 = a1 + 28904;
              *(_WORD *)&__dst[22] = 1024;
              int v882 = v489;
              __int16 v883 = 2048;
              *(void *)v884 = a1 + 28916;
              *(_WORD *)&v884[8] = 2048;
              uint64_t v885 = a1 + 30356;
              LOWORD(v886) = 2048;
              *(void *)((char *)&v886 + 2) = v507;
              WORD5(v886) = 1024;
              HIDWORD(v886) = v518;
              __int16 v887 = 1024;
              int v888 = v832;
              __int16 v889 = 1024;
              int v890 = v835;
              uint64_t v419 = (os_log_s **)&unk_100164000;
              __int16 v891 = 1024;
              int v892 = v840;
              __int16 v893 = 2080;
              uint64_t v894 = a1 + 46976;
              uint64_t v153 = a1 + 12656;
              v523 = (os_log_s *)v520;
              goto LABEL_1102;
            }
          }
        }
      }

      uint64_t v420 = (void *)(a1 + 208);
      uint64_t v421 = v859;
      goto LABEL_1104;
    }

    v507 = (char *)v430;
    uint64_t v419 = (os_log_s **)&unk_100164000;
LABEL_1104:
    if ((*(_BYTE *)(v422 + 2) & 2) != 0 && *(unsigned __int16 *)(v422 + 4) >= 2u) {
      LogMsgWithLevel( v419[170],  OS_LOG_TYPE_DEFAULT,  "SendQueries: Should not have more than one question (%d) in a truncated packet",  (uint64_t)v4,  v5,  v6,  v7,  v8,  *(unsigned __int16 *)(v422 + 4));
    }
    if (*(_BYTE *)(v421 + 17)) {
      mDNSSendDNSMessage( a1,  v422,  (unint64_t)v507,  *(void *)(v421 + 6256),  0LL,  0LL,  AllDNSLinkGroup_v4,  0xE914u,  0LL,  v837);
    }
    if (*(_BYTE *)(v421 + 18)) {
      mDNSSendDNSMessage( a1,  v422,  (unint64_t)v878,  *(void *)(v421 + 6256),  0LL,  0LL,  &AllDNSLinkGroup_v6,  0xE914u,  0LL,  v837);
    }
    unint64_t v423 = a1 + 28916;
    if (!*(_DWORD *)(a1 + 80))
    {
      unsigned int v526 = *(_DWORD *)(a1 + 64) + 100;
      if (v526 <= 1) {
        unsigned int v526 = 1;
      }
      *(_DWORD *)(a1 + 80) = v526;
    }

    if (++v829 >= 1000)
    {
      LogMsgWithLevel( v419[170],  OS_LOG_TYPE_DEFAULT,  "SendQueries exceeded loop limit %d: giving up",  (uint64_t)v4,  v5,  v6,  v7,  v8,  v829);
      break;
    }

                        uint64_t v557 = 14;
                        goto LABEL_1208;
                      }

                      if ((v388 & 1) != 0)
                      {
                        uint64_t v545 = mDNSLogCategory_mDNS_redacted;
                        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
                          goto LABEL_1209;
                        }
                        v546 = *(_DWORD *)(v76 + 184);
                        v1489.st_dev = 67109120;
                        *(_DWORD *)&v1489.st_mode = v546;
                        unsigned int v416 = (os_log_s *)v545;
                        int v417 = "[R%u] DNSServiceReconfirmRecord START -- ";
                      }

                      else
                      {
                        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
                          goto LABEL_1209;
                        }
                        int v611 = *(_DWORD *)(v76 + 184);
                        v1489.st_dev = 67109120;
                        *(_DWORD *)&v1489.st_mode = v611;
                        unsigned int v416 = (os_log_s *)v389;
                        int v417 = "[R%u] DNSServiceReconfirmRecord START -- ";
                      }
                    }

                    else
                    {
                      if (v386)
                      {
                        if (v387)
                        {
                          if ((v388 & 1) != 0)
                          {
                            v401 = mDNSLogCategory_mDNS_redacted;
                            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
                              goto LABEL_1209;
                            }
                            v1390 = *(_DWORD *)(v76 + 184);
                            uint64_t v402 = v387;
                            v1407 = (os_log_s *)v401;
                            if (v387 == (unsigned __int8 *)-256LL)
                            {
                              while (1)
                              {
LABEL_641:
                                if (!v402) {
                                  goto LABEL_1102;
                                }
                                uint64_t v403 = *v402;
                                if (!*v402) {
                                  break;
                                }
                                v402 += v403 + 1;
                              }

                              int v668 = (_WORD)v402 - (_WORD)v387 + 1;
                            }

                            else
                            {
LABEL_640:
                              if (v402 < v387 + 256) {
                                goto LABEL_641;
                              }
LABEL_1102:
                              int v668 = 257;
                            }

                            uint64_t v723 = v668;
                            uint64_t v724 = v175[6];
                            uint64_t v725 = *(_DWORD *)(v76 + 232);
                            v1367 = *(_DWORD *)(v76 + 236);
                            uint64_t v726 = *(_DWORD *)(v76 + 172);
                            v727 = mDNS_DomainNameFNV1aHash(v387);
                            v1489.st_dev = 67111683;
                            *(_DWORD *)&v1489.st_mode = v1390;
                            LOWORD(v1489.st_ino) = 2160;
                            *(__darwin_ino64_t *)((char *)&v1489.st_ino + 2) = 1752392040LL;
                            HIWORD(v1489.st_uid) = 1040;
                            v1489.st_gid = v723;
                            LOWORD(v1489.st_rdev) = 2101;
                            *(void *)((char *)&v1489.st_rdev + 2) = v387;
                            WORD1(v1489.st_atimespec.tv_sec) = 1024;
                            HIDWORD(v1489.st_atimespec.tv_sec) = v724;
                            LOWORD(v1489.st_atimespec.tv_nsec) = 1024;
                            *(_DWORD *)((char *)&v1489.st_atimespec.tv_nsec + 2) = updated;
                            HIWORD(v1489.st_atimespec.tv_nsec) = 1024;
                            LODWORD(v1489.st_mtimespec.tv_sec) = v725;
                            WORD2(v1489.st_mtimespec.tv_sec) = 1024;
                            *(_DWORD *)((char *)&v1489.st_mtimespec.tv_sec + 6) = v1367;
                            WORD1(v1489.st_mtimespec.tv_nsec) = 1024;
                            HIDWORD(v1489.st_mtimespec.tv_nsec) = v726;
                            LOWORD(v1489.st_ctimespec.tv_sec) = 2082;
                            *(__darwin_time_t *)((char *)&v1489.st_ctimespec.tv_sec + 2) = v76 + 240;
                            WORD1(v1489.st_ctimespec.tv_nsec) = 1024;
                            HIDWORD(v1489.st_ctimespec.tv_nsec) = v727;
                            unsigned int v416 = v1407;
                            int v417 = "[R%u] DNSServiceReconfirmRecord FAILED -- rr name: %{sensitive, mask.hash, mdnsrespon"
                                   "der:domain_name}.*P, rr type: %{mdns:rrtype}d, error: %d, flags: 0x%X, interface inde"
                                   "x: %d, client pid: %d (%{public}s), name hash: %x";
                          }

                          else
                          {
                            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
                              goto LABEL_1209;
                            }
                            v1410 = *(_DWORD *)(v76 + 184);
                            v548 = v387;
                            if (v387 == (unsigned __int8 *)-256LL)
                            {
                              while (1)
                              {
LABEL_911:
                                if (!v548) {
                                  goto LABEL_1103;
                                }
                                uint64_t v549 = *v548;
                                if (!*v548) {
                                  break;
                                }
                                v548 += v549 + 1;
                              }

                              int v669 = (_WORD)v548 - (_WORD)v387 + 1;
                            }

                            else
                            {
LABEL_910:
                              if (v548 < v387 + 256) {
                                goto LABEL_911;
                              }
LABEL_1103:
                              int v669 = 257;
                            }

                            v728 = v669;
                            uint64_t v729 = v175[6];
                            v730 = *(_DWORD *)(v76 + 232);
                            __nuint64_t k = *(_DWORD *)(v76 + 236);
                            v1368 = *(_DWORD *)(v76 + 172);
                            unsigned int v731 = mDNS_DomainNameFNV1aHash(v387);
                            v1489.st_dev = 67111683;
                            *(_DWORD *)&v1489.st_mode = v1410;
                            LOWORD(v1489.st_ino) = 2160;
                            *(__darwin_ino64_t *)((char *)&v1489.st_ino + 2) = 1752392040LL;
                            HIWORD(v1489.st_uid) = 1040;
                            v1489.st_gid = v728;
                            LOWORD(v1489.st_rdev) = 2101;
                            *(void *)((char *)&v1489.st_rdev + 2) = v387;
                            WORD1(v1489.st_atimespec.tv_sec) = 1024;
                            HIDWORD(v1489.st_atimespec.tv_sec) = v729;
                            LOWORD(v1489.st_atimespec.tv_nsec) = 1024;
                            *(_DWORD *)((char *)&v1489.st_atimespec.tv_nsec + 2) = updated;
                            HIWORD(v1489.st_atimespec.tv_nsec) = 1024;
                            LODWORD(v1489.st_mtimespec.tv_sec) = v730;
                            WORD2(v1489.st_mtimespec.tv_sec) = 1024;
                            *(_DWORD *)((char *)&v1489.st_mtimespec.tv_sec + 6) = __nk;
                            WORD1(v1489.st_mtimespec.tv_nsec) = 1024;
                            HIDWORD(v1489.st_mtimespec.tv_nsec) = v1368;
                            LOWORD(v1489.st_ctimespec.tv_sec) = 2082;
                            *(__darwin_time_t *)((char *)&v1489.st_ctimespec.tv_sec + 2) = v76 + 240;
                            WORD1(v1489.st_ctimespec.tv_nsec) = 1024;
                            HIDWORD(v1489.st_ctimespec.tv_nsec) = v731;
                            unsigned int v416 = (os_log_s *)v389;
                            int v417 = "[R%u] DNSServiceReconfirmRecord FAILED -- rr name: %{sensitive, mask.hash, mdnsrespon"
                                   "der:domain_name}.*P, rr type: %{mdns:rrtype}d, error: %d, flags: 0x%X, interface inde"
                                   "x: %d, client pid: %d (%{public}s), name hash: %x";
                          }

                          uint64_t v557 = 80;
                          goto LABEL_1208;
                        }

                        if ((v388 & 1) != 0)
                        {
                          v539 = mDNSLogCategory_mDNS_redacted;
                          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
                            goto LABEL_1209;
                          }
                          v540 = *(_DWORD *)(v76 + 184);
                          uint64_t v541 = *(_DWORD *)(v76 + 172);
                          int v543 = *(_DWORD *)(v76 + 232);
                          unsigned int v542 = *(_DWORD *)(v76 + 236);
                          uint64_t v544 = v175[6];
                          v1489.st_dev = 67111427;
                          *(_DWORD *)&v1489.st_mode = v540;
                          LOWORD(v1489.st_ino) = 2160;
                          *(__darwin_ino64_t *)((char *)&v1489.st_ino + 2) = 1752392040LL;
                          HIWORD(v1489.st_uid) = 1040;
                          v1489.st_gid = 0;
                          LOWORD(v1489.st_rdev) = 2101;
                          *(void *)((char *)&v1489.st_rdev + 2) = 0LL;
                          WORD1(v1489.st_atimespec.tv_sec) = 1024;
                          HIDWORD(v1489.st_atimespec.tv_sec) = v544;
                          LOWORD(v1489.st_atimespec.tv_nsec) = 1024;
                          *(_DWORD *)((char *)&v1489.st_atimespec.tv_nsec + 2) = updated;
                          HIWORD(v1489.st_atimespec.tv_nsec) = 1024;
                          LODWORD(v1489.st_mtimespec.tv_sec) = v543;
                          WORD2(v1489.st_mtimespec.tv_sec) = 1024;
                          *(_DWORD *)((char *)&v1489.st_mtimespec.tv_sec + 6) = v542;
                          WORD1(v1489.st_mtimespec.tv_nsec) = 1024;
                          HIDWORD(v1489.st_mtimespec.tv_nsec) = v541;
                          LOWORD(v1489.st_ctimespec.tv_sec) = 2082;
                          *(__darwin_time_t *)((char *)&v1489.st_ctimespec.tv_sec + 2) = v76 + 240;
                          unsigned int v416 = (os_log_s *)v539;
                          int v417 = "[R%u] DNSServiceReconfirmRecord FAILED -- rr name: %{sensitive, mask.hash, mdnsresponde"
                                 "r:domain_name}.*P, rr type: %{mdns:rrtype}d, error: %d, flags: 0x%X, interface index: %"
                                 "d, client pid: %d (%{public}s), ";
                        }

                        else
                        {
                          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
                            goto LABEL_1209;
                          }
                          int v606 = *(_DWORD *)(v76 + 184);
                          int v607 = *(_DWORD *)(v76 + 172);
                          int v609 = *(_DWORD *)(v76 + 232);
                          int v608 = *(_DWORD *)(v76 + 236);
                          int v610 = v175[6];
                          v1489.st_dev = 67111427;
                          *(_DWORD *)&v1489.st_mode = v606;
                          LOWORD(v1489.st_ino) = 2160;
                          *(__darwin_ino64_t *)((char *)&v1489.st_ino + 2) = 1752392040LL;
                          HIWORD(v1489.st_uid) = 1040;
                          v1489.st_gid = 0;
                          LOWORD(v1489.st_rdev) = 2101;
                          *(void *)((char *)&v1489.st_rdev + 2) = 0LL;
                          WORD1(v1489.st_atimespec.tv_sec) = 1024;
                          HIDWORD(v1489.st_atimespec.tv_sec) = v610;
                          LOWORD(v1489.st_atimespec.tv_nsec) = 1024;
                          *(_DWORD *)((char *)&v1489.st_atimespec.tv_nsec + 2) = updated;
                          HIWORD(v1489.st_atimespec.tv_nsec) = 1024;
                          LODWORD(v1489.st_mtimespec.tv_sec) = v609;
                          WORD2(v1489.st_mtimespec.tv_sec) = 1024;
                          *(_DWORD *)((char *)&v1489.st_mtimespec.tv_sec + 6) = v608;
                          WORD1(v1489.st_mtimespec.tv_nsec) = 1024;
                          HIDWORD(v1489.st_mtimespec.tv_nsec) = v607;
                          LOWORD(v1489.st_ctimespec.tv_sec) = 2082;
                          *(__darwin_time_t *)((char *)&v1489.st_ctimespec.tv_sec + 2) = v76 + 240;
                          unsigned int v416 = (os_log_s *)v389;
                          int v417 = "[R%u] DNSServiceReconfirmRecord FAILED -- rr name: %{sensitive, mask.hash, mdnsresponde"
                                 "r:domain_name}.*P, rr type: %{mdns:rrtype}d, error: %d, flags: 0x%X, interface index: %"
                                 "d, client pid: %d (%{public}s), ";
                        }

                        goto LABEL_1166;
                      }

                      if (v387)
                      {
                        if ((v388 & 1) != 0)
                        {
                          uint64_t v497 = mDNSLogCategory_mDNS_redacted;
                          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
                            goto LABEL_1209;
                          }
                          v498 = *(_DWORD *)(v76 + 184);
                          v499 = mDNS_DomainNameFNV1aHash(v387);
                          v1489.st_dev = 67109376;
                          *(_DWORD *)&v1489.st_mode = v498;
                          LOWORD(v1489.st_ino) = 1024;
                          *(_DWORD *)((char *)&v1489.st_ino + 2) = v499;
                          unsigned int v416 = (os_log_s *)v497;
                          int v417 = "[R%u] DNSServiceReconfirmRecord FAILED -- name hash: %x";
                        }

                        else
                        {
                          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
                            goto LABEL_1209;
                          }
                          int v604 = *(_DWORD *)(v76 + 184);
                          int v605 = mDNS_DomainNameFNV1aHash(v387);
                          v1489.st_dev = 67109376;
                          *(_DWORD *)&v1489.st_mode = v604;
                          LOWORD(v1489.st_ino) = 1024;
                          *(_DWORD *)((char *)&v1489.st_ino + 2) = v605;
                          unsigned int v416 = (os_log_s *)v389;
                          int v417 = "[R%u] DNSServiceReconfirmRecord FAILED -- name hash: %x";
                        }

                        goto LABEL_1023;
                      }

                      if ((v388 & 1) != 0)
                      {
                        int v596 = mDNSLogCategory_mDNS_redacted;
                        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
                          goto LABEL_1209;
                        }
                        int v597 = *(_DWORD *)(v76 + 184);
                        v1489.st_dev = 67109120;
                        *(_DWORD *)&v1489.st_mode = v597;
                        unsigned int v416 = (os_log_s *)v596;
                        int v417 = "[R%u] DNSServiceReconfirmRecord FAILED -- ";
                      }

                      else
                      {
                        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
                          goto LABEL_1209;
                        }
                        uint64_t v661 = *(_DWORD *)(v76 + 184);
                        v1489.st_dev = 67109120;
                        *(_DWORD *)&v1489.st_mode = v661;
                        unsigned int v416 = (os_log_s *)v389;
                        int v417 = "[R%u] DNSServiceReconfirmRecord FAILED -- ";
                      }
                    }

                    uint64_t v557 = 8;
                    goto LABEL_1208;
                  case 10:
                    uint64_t v178 = 0LL;
                    uint64_t v179 = 0;
                    id v181 = *(void *)(v76 + 72);
                    uint64_t v180 = *(void *)(v76 + 80);
                    if (!v181)
                    {
                      __int128 v182 = 0;
LABEL_506:
                      uint64_t v183 = 0LL;
                      goto LABEL_507;
                    }

                    __int128 v182 = 0;
                    uint64_t v183 = 0LL;
                    if (v181 + 4 > v180) {
                      goto LABEL_507;
                    }
                    uint64_t v178 = 0LL;
                    uint64_t v179 = 0;
                    uint64_t v184 = v181 + 6;
                    __int128 v182 = bswap32(*(_DWORD *)v181);
                    *(void *)(v76 + 72) = v181 + 4;
                    if (v181 == -4 || v184 > v180) {
                      goto LABEL_506;
                    }
                    uint64_t v183 = 0LL;
                    uint64_t v178 = 0LL;
                    uint64_t v179 = bswap32(*(unsigned __int16 *)(v181 + 4)) >> 16;
                    *(void *)(v76 + 72) = v184;
                    if (v181 != -6 && v181 + 8 <= v180)
                    {
                      uint64_t v183 = bswap32(*(unsigned __int16 *)(v181 + 6)) >> 16;
                      uint64_t v178 = (unsigned __int8 *)(v181 + 8);
                    }

LABEL_1116:
    v527 = v877;
    if (v877)
    {
      do
      {
        v528 = (void *)*v527;
        free(v527);
        v527 = v528;
      }

      while (v528);
    }

    if (v421) {
      continue;
    }
    break;
  }

LABEL_1122:
  for (i8 = *v871; i8; i8 = (uint64_t *)*i8)
  {
    uint64_t v530 = i8[28];
    if (v530)
    {
      if ((*((_DWORD *)i8 + 43) & 0xFFFFFFFE) != 4 && *((_WORD *)i8 + 6) != 41 && mDNS_LoggingEnabled != 0)
      {
        v532 = v419[170];
        GetRRDisplayString_rdb((unsigned __int8 *)i8 + 8, (unsigned __int16 *)(i8[6] + 4), (_BYTE *)(a1 + 46976));
        LogMsgWithLevel( v532,  OS_LOG_TYPE_DEFAULT,  "SendQueries: No active interface %d to send probe: %d %s",  v533,  v534,  v535,  v536,  v537,  v530);
      }

      i8[28] = 0LL;
    }
  }

  for (uint64_t i9 = 0LL; i9 != 499; ++i9)
  {
    for (i10 = *(void **)(a1 + 8 * i9 + 280); i10; i10 = (void *)*i10)
    {
      for (uint64_t i11 = i10[2]; i11; uint64_t i11 = *(void *)i11)
      {
        uint64_t v541 = *(void *)(i11 + 96);
        if (v541)
        {
          unsigned int v542 = *(unsigned __int8 *)(i11 + 108);
          if (v542 <= 3)
          {
            int v543 = *(_DWORD *)(a1 + 64);
            uint64_t v544 = 1374389535000LL * *(_DWORD *)(i11 + 16);
            if ((int)(v543 - *(_DWORD *)(i11 + 88) + (v544 >> 36) + ((unint64_t)v544 >> 63)) >= 0)
            {
              if (*(_DWORD *)(i11 + 104) != v543) {
                *(_BYTE *)(i11 + 108) = v542 + 1;
              }
              *(void *)(v541 + 64) = 0LL;
              SetNextCacheCheckTimeForRecord(a1, i11);
            }
          }
        }
      }
    }
  }

  uint64_t v545 = *(void *)(a1 + 200);
  for (i12 = (void *)(a1 + 208); v545; uint64_t v545 = *(void *)(v545 + 8))
  {
    uint64_t v547 = *(void *)(v545 + 64);
    if (v547)
    {
      v548 = i12;
      do
      {
        uint64_t v549 = *v548;
        v548 = (void *)(*v548 + 8LL);
        if (v549) {
          BOOL v550 = v549 == v545;
        }
        else {
          BOOL v550 = 1;
        }
      }

      while (!v550);
      if (*(void *)(v545 + 136) != -5LL && mDNS_LoggingEnabled != 0)
      {
        v552 = v419[170];
        DNSTypeName(*(unsigned __int16 *)(v545 + 322));
        uint64_t v419 = (os_log_s **)&unk_100164000;
        uint64_t v153 = a1 + 12656;
        v553 = v552;
        i12 = (void *)(a1 + 208);
        LogMsgWithLevel( v553,  OS_LOG_TYPE_DEFAULT,  "SendQueries: No active interface %d to send %s question: %d %##s (%s)",  v554,  v555,  v556,  v557,  v558,  v547);
      }

      *(void *)(v545 + 64) = 0LL;
    }

    *(_BYTE *)(v545 + 339) = 0;
  }

  unsigned int v284 = *(_DWORD *)(a1 + 64);
  if ((int)(v284 - *(_DWORD *)(a1 + 92)) >= 0)
  {
    LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "mDNS_Execute: SendQueries didn't send all its queries (%d - %d = %d) will try again in one second",  (uint64_t)v4,  v5,  v6,  v7,  v8,  v284);
    unsigned int v284 = *(_DWORD *)(a1 + 64);
    *(_DWORD *)(a1 + 92) = v284 + 1000;
    uint64_t v559 = *(void *)(a1 + 200);
    if (v559)
    {
      do
      {
        if (v559 == *i12) {
          break;
        }
        int v560 = *(_DWORD *)(v559 + 212);
        if (v560 >= 1 && !*(void *)(v559 + 40) && *(_DWORD *)(a1 + 64) - (v560 + *(_DWORD *)(v559 + 208)) >= 0)
        {
          uint64_t v561 = mDNSLogCategory_Default;
          DNSTypeName(*(unsigned __int16 *)(v559 + 322));
          v562 = (os_log_s *)v561;
          i12 = (void *)(a1 + 208);
          LogMsgWithLevel( v562,  OS_LOG_TYPE_DEFAULT,  "mDNS_Execute: SendQueries didn't send %##s (%s)",  v563,  v564,  v565,  v566,  v567,  v559 + 356);
        }

        uint64_t v559 = *(void *)(v559 + 8);
      }

      while (v559);
      unsigned int v284 = *(_DWORD *)(a1 + 64);
    }
  }

LABEL_1168:
  if ((int)(v284 - *(_DWORD *)(a1 + 96)) >= 0)
  {
    LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "mDNS_Execute: SendQueries didn't send all its probes (%d - %d = %d) will try again in one second",  (uint64_t)v4,  v5,  v6,  v7,  v8,  v284);
    unsigned int v284 = *(_DWORD *)(a1 + 64);
    *(_DWORD *)(a1 + 96) = v284 + 1000;
  }

LABEL_1170:
  int v568 = *(_DWORD *)(a1 + 84);
  if (!v568 || ((v284 - v568) & 0x80000000) == 0)
  {
    *(_DWORD *)(a1 + 84) = 0;
    if ((int)(v284 - *(_DWORD *)(a1 + 100)) >= 0)
    {
      SendResponses(a1, v2, v3, v4, v5, v6, v7, v8);
      unsigned int v284 = *(_DWORD *)(a1 + 64);
      if ((int)(v284 - *(_DWORD *)(a1 + 100)) >= 0)
      {
        LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "mDNS_Execute: SendResponses didn't send all its responses; will try again in one second",
          (uint64_t)v4,
          v5,
          v6,
          v7,
          v8,
          v820);
        unsigned int v284 = *(_DWORD *)(a1 + 64);
        *(_DWORD *)(a1 + 100) = v284 + 1000;
      }
    }
  }

LABEL_1175:
  *(_DWORD *)(a1 + 124) = 0;
  *(_DWORD *)(a1 + 128) = 0;
  int v569 = *(_DWORD *)(a1 + 188);
  if (v569 && ((v284 - v569) & 0x80000000) == 0)
  {
    *(_DWORD *)(a1 + 188) = v284 + 939524096;
    TimeoutQuestions_internal(a1, *(void *)(a1 + 200), 0LL, (uint64_t)v4, v5, v6, v7, v8);
    TimeoutQuestions_internal(a1, *(void *)(a1 + 224), -2LL, v570, v571, v572, v573, v574);
    unsigned int v284 = *(_DWORD *)(a1 + 64);
  }

  int v575 = *(_DWORD *)(a1 + 12692);
  if (v575 && ((v284 - v575) & 0x80000000) == 0)
  {
    *(_DWORD *)(a1 + 12692) = 0;
    if (mDNS_LoggingEnabled == 1) {
      LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "UpdateAllSRVRecords %d",  (uint64_t)v4,  v5,  v6,  v7,  v8,  *(unsigned __int8 *)(a1 + 141));
    }
    uint64_t v576 = *(void *)(a1 + 12648);
    if (v576)
    {
      v577 = (os_log_s *)mDNSLogCategory_Default;
      GetRRDisplayString_rdb( (unsigned __int8 *)(v576 + 8),  (unsigned __int16 *)(*(void *)(v576 + 48) + 4LL),  (_BYTE *)(a1 + 46976));
      LogMsgWithLevel( v577,  OS_LOG_TYPE_DEFAULT,  "UpdateAllSRVRecords ERROR m->CurrentRecord already set %s",  v578,  v579,  v580,  v581,  v582,  a1 + 46976);
    }

    uint64_t v583 = *(void *)(a1 + 12624);
    *(void *)(a1 + 12648) = v583;
    if (v583)
    {
      do
      {
        uint64_t v584 = *(void *)v583;
        *(void *)(a1 + 12648) = *(void *)v583;
        if (!*(void *)(v583 + 32))
        {
          if (!*(_BYTE *)(v583 + 122) && !IsLocalDomain(*(_BYTE **)(v583 + 40)) && *(_WORD *)(v583 + 12) == 33) {
            UpdateOneSRVRecord(a1, v583);
          }
          uint64_t v584 = *(void *)(a1 + 12648);
        }

        uint64_t v583 = v584;
      }

      while (v584);
    }

    unsigned int v284 = *(_DWORD *)(a1 + 64);
  }

  v586 = (_DWORD *)(v153 + 72);
  int v585 = *(unsigned __int8 *)(v153 + 72);
  if (v585 == 10) {
    goto LABEL_1198;
  }
  if (v585 == 172)
  {
    if ((*(_BYTE *)(v153 + 73) & 0xF0) == 0x10) {
      goto LABEL_1198;
    }
    goto LABEL_1202;
  }

  if (v585 != 192 || *(unsigned __int8 *)(v153 + 73) != 168)
  {
LABEL_1202:
    int v588 = *(_DWORD *)(a1 + 12728);
    BOOL v587 = v588 != 0;
    *(_DWORD *)(a1 + 104) = v284 + 939524096;
    if (v588) {
      *(_DWORD *)(a1 + 14672) = v588;
    }
    goto LABEL_1205;
  }

LABEL_1198:
  *(_DWORD *)(a1 + 104) = v284 + 939524096;
  if (!*(void *)(a1 + 14648))
  {
    BOOL v587 = 0;
LABEL_1205:
    v589 = *(void **)(a1 + 14688);
    if (v589)
    {
      CloseSocketSet(*(void *)(a1 + 14688));
      free(v589);
      *(void *)(a1 + 14688) = 0LL;
    }

    v590 = *(void **)(a1 + 14952);
    if (v590)
    {
      CloseSocketSet(*(void *)(a1 + 14952));
      free(v590);
      *(void *)(a1 + 14952) = 0LL;
    }

    goto LABEL_1209;
  }

  if (*(void *)(a1 + 14688)) {
    goto LABEL_1200;
  }
  v594 = mDNSPlatformUDPSocket(0xE614u);
  *(void *)(a1 + 14688) = v594;
  if (v594)
  {
    BOOL v587 = 0;
    CheckNATMappings_needLog = 0;
  }

  else if ((CheckNATMappings_needLog & 1) != 0)
  {
LABEL_1200:
    BOOL v587 = 0;
  }

  else
  {
    LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "CheckNATMappings: Failed to allocate port 5350 UDP multicast socket for PCP & NAT-PMP announcements",  (uint64_t)v4,  v5,  v6,  v7,  v8,  v820);
    BOOL v587 = 0;
    CheckNATMappings_needLog = 1;
  }

LABEL_1209:
  int v591 = *(_DWORD *)(a1 + 64);
  if (*(void *)(a1 + 14648))
  {
    unsigned int v592 = *(_DWORD *)(a1 + 14668);
    if ((int)(v591 - v592) >= 0)
    {
      int v593 = *(unsigned __int8 *)(a1 + 12708);
      if (v593 != 10)
      {
        if (v593 == 172)
        {
          if ((*(_BYTE *)(a1 + 12709) & 0xF0) != 0x10) {
            goto LABEL_1228;
          }
        }

        else if (v593 != 192 || *(unsigned __int8 *)(a1 + 12709) != 168)
        {
          goto LABEL_1228;
        }
      }

      mDNSPlatformSendUDP( (void *)a1,  uDNS_RequestAddress_req,  (uint64_t)&uDNS_RequestAddress_req[1],  0LL,  0LL,  (int *)(a1 + 12704),  0xE714u,  0);
      if (*(_WORD *)(a1 + 14962) && *(_WORD *)(a1 + 14964))
      {
        int v595 = SendSOAPMsgControlAction(a1, a1 + 14712, (uint64_t)"GetExternalIPAddress", 0, 0LL, 2);
        if (v595) {
          LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "uDNS_RequestAddress: LNT_GetExternalAddress returned error %d",  (uint64_t)v4,  v5,  v6,  v7,  v8,  v595);
        }
      }

      else
      {
        LNT_SendDiscoveryMsg(a1);
      }

LABEL_1228:
      int v596 = *(_DWORD *)(a1 + 14664);
      int v597 = 2 * v596;
      if (v596 >= 450000) {
        int v597 = 900000;
      }
      if (v596 >= 250) {
        int v598 = v597;
      }
      else {
        int v598 = 250;
      }
      *(_DWORD *)(a1 + 14664) = v598;
      unsigned int v592 = *(_DWORD *)(a1 + 64) + v598;
      if (v592 <= 1) {
        unsigned int v592 = 1;
      }
      *(_DWORD *)(a1 + 14668) = v592;
    }
  }

  else
  {
    unsigned int v592 = v591 + 939524096;
    *(_DWORD *)(a1 + 14668) = v592;
    if (mDNS_LoggingEnabled == 1)
    {
      LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "uDNS_RequestAddress: Setting retryGetAddr to future",  (uint64_t)v4,  v5,  v6,  v7,  v8,  v820);
      unsigned int v592 = *(_DWORD *)(a1 + 14668);
    }
  }

  if (*(void *)(a1 + 14656)) {
    LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "WARNING m->CurrentNATTraversal already in use",  (uint64_t)v4,  v5,  v6,  v7,  v8,  v820);
  }
  uint64_t v599 = *(void *)(a1 + 14648);
  *(void *)(a1 + 14656) = v599;
  if (v599)
  {
    while (2)
    {
      v600 = (_DWORD *)(v599 + 156);
      uint64_t v601 = *(void *)v599;
      if (v587) {
        v600 = v586;
      }
      *(_DWORD *)buf = *v600;
      *(void *)(a1 + 14656) = v601;
      if (v587)
      {
        *(_DWORD *)(v599 + 8) = 0;
        *(_DWORD *)(v599 + memset(v45, 0, 20) = 0;
      }

      else
      {
        int v602 = *(_DWORD *)(a1 + 64);
        int v603 = *(_DWORD *)(v599 + 16);
        if (v602 - v603 >= 0)
        {
          int v604 = *(_DWORD *)(v599 + 8);
          if (v604 && v604 - v602 < 0) {
            *(void *)(v599 + 8) = 0xFA00000000LL;
          }
          uDNS_SendNATMsg(a1, v599, 1, 0);
          int v605 = *(_DWORD *)(v599 + 8);
          if (v605)
          {
            int v606 = (v605 - *(_DWORD *)(a1 + 64)) / 2;
            if (v606 <= 2000) {
              int v606 = 2000;
            }
            *(_DWORD *)(v599 + 12) = v606;
            int v607 = *(_DWORD *)(a1 + 64);
          }

          else
          {
            int v608 = *(_DWORD *)(v599 + 12);
            int v607 = 2 * v608;
            if (v608 >= 450000) {
              int v607 = 900000;
            }
            if (v608 < 250) {
              int v607 = 250;
            }
            *(_DWORD *)(v599 + 12) = v607;
            int v606 = *(_DWORD *)(a1 + 64);
          }

          int v603 = v607 + v606;
          *(_DWORD *)(v599 + 16) = v603;
        }

        if (*(_DWORD *)(a1 + 104) - v603 >= 1) {
          *(_DWORD *)(a1 + 104) = v603;
        }
      }

      int v609 = *(_DWORD *)buf;
      int v610 = *(_DWORD *)(v599 + 20);
      if (v610)
      {
        if (v587) {
          goto LABEL_1265;
        }
LABEL_1274:
        if (*(_DWORD *)buf)
        {
          if (*(_DWORD *)(v599 + 8)) {
            v613 = (__int16 *)(v599 + 176);
          }
          else {
            v613 = &zeroIPPort;
          }
        }

        else
        {
          v613 = &zeroIPPort;
        }

        int v611 = (unsigned __int16)*v613;
        int v612 = *(unsigned __int8 *)(v599 + 172);
        if (*(_BYTE *)(v599 + 172))
        {
          if (*(_DWORD *)(v599 + 8) || *(int *)(v599 + 12) >= 2001)
          {
            int v612 = 1;
            goto LABEL_1283;
          }
        }

        else
        {
LABEL_1283:
          if (*(_DWORD *)(v599 + 152) != *(_DWORD *)buf
            || *(unsigned __int16 *)(v599 + 160) != v611
            || *(_DWORD *)(v599 + 168) != v610)
          {
            if (!v612 || v611)
            {
              int v614 = 0;
              *(_DWORD *)(v599 + 152) = *(_DWORD *)buf;
              *(_WORD *)(v599 + 160) = v611;
              int v615 = *(_DWORD *)(v599 + 8);
              if (v615 && v611)
              {
                uint64_t v616 = 274877907LL * (v615 - *(_DWORD *)(a1 + 64) + 500);
                int v614 = (v616 >> 38) + ((unint64_t)v616 >> 63);
              }
            }

            else
            {
              if (*(_DWORD *)(a1 + 12708) && (v610 || mDNS_LoggingEnabled == 1))
              {
                LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "CheckNATMapping: Failed to obtain NAT port mapping %p from router %#a external address %.4a internal p ort %5d interval %d error %d",  (uint64_t)v4,  v5,  v6,  v7,  v8,  v599);
                int v609 = *(_DWORD *)buf;
              }

              int v614 = 0;
              *(_DWORD *)(v599 + 152) = v609;
              *(_WORD *)(v599 + 160) = 0;
            }

            *(_DWORD *)(v599 + 164) = v614;
            *(_DWORD *)(v599 + 168) = v610;
            unsigned int v617 = *(_DWORD *)(a1 + 48);
            unsigned int v618 = *(_DWORD *)(a1 + 52) + 1;
            *(_DWORD *)(a1 + 52) = v618;
            mDNS_VerifyLockState("Drop Lock", 0, v617, v618, (uint64_t)"CheckNATMappings", 5109);
            v619 = *(void (**)(uint64_t, uint64_t))(v599 + 184);
            if (v619) {
              v619(a1, v599);
            }
            mDNS_VerifyLockState( "Reclaim Lock",  0,  *(_DWORD *)(a1 + 48),  *(_DWORD *)(a1 + 52),  (uint64_t)"CheckNATMappings",  5112);
            --*(_DWORD *)(a1 + 52);
          }
        }

LABEL_1299:
        uint64_t v599 = *(void *)(a1 + 14656);
        if (!v599) {
          goto LABEL_1300;
        }
        continue;
      }

      break;
    }

    if (buf[0] != 10)
    {
      if (buf[0] != 172)
      {
        if (buf[0] == 192 && buf[1] == 168) {
          goto LABEL_1270;
        }
LABEL_1273:
        int v610 = 0;
        if (!v587) {
          goto LABEL_1274;
        }
LABEL_1265:
        int v611 = *(unsigned __int16 *)(v599 + 174);
        int v612 = *(unsigned __int8 *)(v599 + 172);
        goto LABEL_1283;
      }

      if ((buf[1] & 0xF0) != 0x10) {
        goto LABEL_1273;
      }
    }

LABEL_1270:
    int v610 = -65558;
    if (!v587) {
      goto LABEL_1274;
    }
    goto LABEL_1265;
  }

LABEL_1300:
  unsigned int v284 = *(_DWORD *)(a1 + 64);
LABEL_1301:
  unsigned int v842 = v284 + 939524096;
  *(_DWORD *)(a1 + 12688) = v284 + 939524096;
  v620 = *(uint64_t **)(a1 + 12624);
  if (!v620) {
    goto LABEL_1490;
  }
  uint64_t v621 = 0LL;
  v874 = (_BYTE *)(a1 + 46976);
  unint64_t v849 = a1 + 28916;
  while (2)
  {
    int v622 = v284 + 1000;
    if (v621)
    {
      v628 = &unk_100164000;
      goto LABEL_1308;
    }

    BOOL v629 = IsRecordMergeable(a1, (uint64_t)v620, v284 + 1000);
    uint64_t v621 = (uint64_t)v620;
    v628 = &unk_100164000;
    if (!v629)
    {
      v620 = (uint64_t *)*v620;
      if (v620) {
        goto LABEL_1408;
      }
      v728 = *v871;
      if (!*v871) {
        goto LABEL_1490;
      }
      uint64_t v729 = a1 + 37856;
      v730 = "SendRecordDeregistration: Error formatting message for %s";
      while (1)
      {
        if (!v728[4] && !*((_BYTE *)v728 + 122) && !IsLocalDomain((_BYTE *)v728[5]))
        {
          unsigned int v731 = *((_DWORD *)v728 + 86);
          if (v731 > 8) {
            goto LABEL_1477;
          }
          int v732 = 1 << v731;
          if ((v732 & 0xAE) != 0)
          {
            if (*((_DWORD *)v728 + 70) + *((_DWORD *)v728 + 71) - *(_DWORD *)(a1 + 64) > 0) {
              goto LABEL_1477;
            }
            uint64_t v733 = v728[48];
            if (v733)
            {
              DisposeTCPConn(v733);
              v728[48] = 0LL;
            }

            v734 = (_DWORD *)v728[47];
            if (v734)
            {
              if (v734[198])
              {
                if (*((_DWORD *)v728 + 86) == 3)
                {
                  mDNS_VerifyLockState( "Check Lock",  1,  *(_DWORD *)(a1 + 48),  *(_DWORD *)(a1 + 52),  (uint64_t)"SendRecordDeregistration",  4294);
                  uint64_t v735 = v728[47];
                  if (v735 && *(_DWORD *)(v735 + 792))
                  {
                    AuthInfoForName_internal = GetAuthInfoForName_internal(a1, (_BYTE *)v728[5]);
                    if (AuthInfoForName_internal)
                    {
                      v737 = (char *)AuthInfoForName_internal + 268;
LABEL_1446:
                      if (v737 >= (_BYTE *)AuthInfoForName_internal + 524)
                      {
LABEL_1461:
                        unsigned __int16 v738 = 257;
                      }

                      else
                      {
                        unsigned __int16 v738 = 257;
                        if (v737)
                        {
                          while (1)
                          {
                            uint64_t v739 = *v737;
                            if (!*v737) {
                              break;
                            }
                            v737 += v739 + 1;
LABEL_1449:
                            if (!v737) {
                              goto LABEL_1461;
                            }
                          }

                          unsigned __int16 v738 = (_WORD)v737 - ((_WORD)AuthInfoForName_internal + 268) + 1;
                        }
                      }

                      uint64_t v748 = -103LL - v738;
                    }

                    else
                    {
                      uint64_t v748 = -35LL;
                    }

                    v873 = (unsigned __int8 *)(v728 + 1);
                    unint64_t v749 = v729 + v748;
                    __int16 v750 = mDNS_NewMessageID(a1);
                    *((_WORD *)v728 + 179) = v750;
                    _WORD *v861 = v750;
                    *(_WORD *)(a1 + 28906) = 40;
                    *(void *)(a1 + 28908) = 0LL;
                    v754 = putZone( (unint64_t)v861,  v849,  v749,  (unsigned __int8 *)v728[46],  bswap32(*((unsigned __int16 *)v728 + 7)) >> 16,  v751,  v752,  v753);
                    if (v754
                      && (unint64_t updated = BuildUpdateMessage( a1,  (unint64_t)v754,  (uint64_t)v728,  v749,  v755,  v756,  v757,  v758)) != 0)
                    {
                      unint64_t v760 = updated;
                      if (*((_BYTE *)v728 + 356))
                      {
                        if (!mDNS_LoggingEnabled) {
                          goto LABEL_1471;
                        }
                        v869 = (os_log_s *)mDNSLogCategory_Default;
                        uint64_t v761 = v728[48];
                        GetRRDisplayString_rdb(v873, (unsigned __int16 *)(v728[6] + 4), v874);
                        LogMsgWithLevel( v869,  OS_LOG_TYPE_DEFAULT,  "SendRecordDeregistration TCP %p %s",  v762,  v763,  v764,  v765,  v766,  v761);
                        uint64_t v767 = v728[48];
                        if (v767 && mDNS_LoggingEnabled)
                        {
                          v768 = (os_log_s *)mDNSLogCategory_Default;
                          GetRRDisplayString_rdb(v873, (unsigned __int16 *)(v728[6] + 4), v874);
                          LogMsgWithLevel( v768,  OS_LOG_TYPE_DEFAULT,  "SendRecordDeregistration: Disposing existing TCP connection for %s",  v769,  v770,  v771,  v772,  v773,  (int)v874);
LABEL_1471:
                          uint64_t v767 = v728[48];
                        }

                        if (v767)
                        {
                          DisposeTCPConn(v767);
                          v728[48] = 0LL;
                        }

                        uint64_t v774 = v728[47];
                        if (v774)
                        {
                          v728[48] = (uint64_t)MakeTCPConn( a1,  v861,  v760,  1LL,  (int *)(v774 + 788),  *(unsigned __int16 *)(v774 + 786),  (_BYTE *)(v774 + 530),  0LL,  (uint64_t)v728);
                          goto LABEL_1486;
                        }

                        v791 = (os_log_s *)mDNSLogCategory_Default;
                        GetRRDisplayString_rdb(v873, (unsigned __int16 *)(v728[6] + 4), v874);
                        LogMsgWithLevel( v791,  OS_LOG_TYPE_DEFAULT,  "SendRecordDeregistration:Private:ERROR!! nta is NULL for %s",  v792,  v793,  v794,  v795,  v796,  (int)v874);
                      }

                      else
                      {
                        if (mDNS_LoggingEnabled)
                        {
                          v783 = (os_log_s *)mDNSLogCategory_Default;
                          GetRRDisplayString_rdb(v873, (unsigned __int16 *)(v728[6] + 4), v874);
                          LogMsgWithLevel( v783,  OS_LOG_TYPE_DEFAULT,  "SendRecordDeregistration UDP %s",  v784,  v785,  v786,  v787,  v788,  (int)v874);
                        }

                        uint64_t v789 = v728[47];
                        if (v789)
                        {
                          v790 = GetAuthInfoForName_internal(a1, (_BYTE *)v728[5]);
                          mDNSSendDNSMessage( a1,  (unint64_t)v861,  v760,  0LL,  0LL,  0LL,  (int *)(v789 + 788),  *(_WORD *)(v789 + 786),  v790,  0);
LABEL_1486:
                          SetRecordRetry(a1, (uint64_t)v728, 0);
                        }

                        else
                        {
                          v797 = (os_log_s *)mDNSLogCategory_Default;
                          GetRRDisplayString_rdb(v873, (unsigned __int16 *)(v728[6] + 4), v874);
                          LogMsgWithLevel( v797,  OS_LOG_TYPE_DEFAULT,  "SendRecordDeregistration:ERROR!! nta is NULL for %s",  v798,  v799,  v800,  v801,  v802,  (int)v874);
                        }
                      }

                      v730 = "SendRecordDeregistration: Error formatting message for %s";
                    }

                    else
                    {
                      uint64_t v775 = mDNSLogCategory_Default;
                      GetRRDisplayString_rdb(v873, (unsigned __int16 *)(v728[6] + 4), v874);
                      v776 = (os_log_s *)v775;
                      v730 = "SendRecordDeregistration: Error formatting message for %s";
                      LogMsgWithLevel( v776,  OS_LOG_TYPE_DEFAULT,  "SendRecordDeregistration: Error formatting message for %s",  v777,  v778,  v779,  v780,  v781,  (int)v874);
                    }
                  }

                  else
                  {
                    uint64_t v872 = v729;
                    v740 = v730;
                    uint64_t v741 = mDNSLogCategory_Default;
                    GetRRDisplayString_rdb((unsigned __int8 *)v728 + 8, (unsigned __int16 *)(v728[6] + 4), v874);
                    v742 = (os_log_s *)v741;
                    v730 = v740;
                    uint64_t v729 = v872;
                    LogMsgWithLevel( v742,  OS_LOG_TYPE_DEFAULT,  "SendRecordDeRegistration: No zone info for Resource record %s RecordType %d",  v743,  v744,  v745,  v746,  v747,  (int)v874);
                  }
                }

                else
                {
                  SendRecordRegistration(a1, (uint64_t)v728);
                }

LABEL_1477:
                int v782 = v842;
                unsigned int v842 = v782;
                goto LABEL_1480;
              }

              *((_WORD *)v728 + 179) = 0;
              CancelGetZoneData(a1, v734);
            }

            v728[47] = (uint64_t)StartGetZoneData((unsigned int *)a1, (_BYTE *)v728[5], (uint64_t)v728);
            SetRecordRetry(a1, (uint64_t)v728, 0);
            goto LABEL_1477;
          }

          if ((v732 & 0x140) == 0) {
            goto LABEL_1477;
          }
        }

LABEL_1480:
        v728 = (uint64_t *)*v728;
        if (!v728) {
          goto LABEL_1490;
        }
      }
    }

                                                                  ref_count_obj_release((void *)v592);
                                                                }
                                                              }

LABEL_1308:
    if (v620[28])
    {
      v630 = (os_log_s *)*((void *)v628 + 170);
      GetRRDisplayString_rdb((unsigned __int8 *)v620 + 8, (unsigned __int16 *)(v620[6] + 4), v874);
      LogMsgWithLevel( v630,  OS_LOG_TYPE_DEFAULT,  "MarkRRForSending: Resourcerecord %s already marked for sending",  v631,  v632,  v633,  v634,  v635,  (int)v874);
    }

    v620[28] = -4LL;
LABEL_1311:
    v620 = (uint64_t *)*v620;
    if (v620) {
      goto LABEL_1409;
    }
    v636 = *v871;
    if (!*v871) {
      goto LABEL_1490;
    }
    int v637 = 0;
    do
    {
      int v638 = *((_DWORD *)v636 + 86);
      BOOL v639 = v638 == 5 || v638 == 2;
      if (v639
        && v636[28] != -4
        && AreRecordsMergeable(a1, v621, (uint64_t)v636, *(_DWORD *)(a1 + 64) + *((_DWORD *)v636 + 70) / 2))
      {
        v636[28] = -4LL;
        ++v637;
      }

      v636 = (uint64_t *)*v636;
    }

    while (v636);
    if (v637 && mDNS_LoggingEnabled) {
      LogMsgWithLevel( *((os_log_s **)v628 + 170),  OS_LOG_TYPE_DEFAULT,  "MarkRRForSending: Accelereated %d records",  v623,  v624,  v625,  v626,  v627,  v637);
    }
    v640 = *v871;
    if (!*v871) {
      goto LABEL_1490;
    }
    __int16 v641 = 0;
    unint64_t v860 = 0LL;
    int v642 = 0;
    int v844 = 1;
    unint64_t v643 = a1 + 28916;
LABEL_1328:
    v852 = 0LL;
    int v644 = 0;
    uint64_t v868 = 0LL;
    int v864 = 0;
    while (2)
    {
      if (v640[28] != -4)
      {
LABEL_1390:
        v640 = (uint64_t *)*v640;
        if (!v640) {
          goto LABEL_1400;
        }
        continue;
      }

      break;
    }

    v640[28] = 0LL;
    if (v868) {
      goto LABEL_1359;
    }
    v645 = GetAuthInfoForName_internal(a1, (_BYTE *)v640[46]);
    v651 = v645;
    if (!v645)
    {
      int v654 = 35;
      unint64_t v653 = a1 + 28904;
      goto LABEL_1345;
    }

    v652 = (char *)v645 + 268;
    unint64_t v653 = a1 + 28904;
LABEL_1333:
    int v654 = 360;
    if (v652 < (_BYTE *)v645 + 524 && v652)
    {
      while (1)
      {
        uint64_t v655 = *v652;
        if (v655 > 0x3F)
        {
LABEL_1342:
          int v654 = 360;
          goto LABEL_1345;
        }

        if (!*v652) {
          break;
        }
        v652 += v655 + 1;
LABEL_1336:
        if (!v652) {
          goto LABEL_1342;
        }
      }

      unsigned int v656 = (unsigned __int16)((_WORD)v652 - ((_WORD)v645 + 268) + 1);
      if (v656 < 0x539)
      {
        int v654 = v656 + 103;
        goto LABEL_1345;
      }

      LogMsgWithLevel( *((os_log_s **)v628 + 170),  OS_LOG_TYPE_DEFAULT,  "SendGroupUpdates: ERROR!!: spaceleft is zero at the beginning",  v646,  v647,  v648,  v649,  v650,  v820);
      v727 = *v871;
      if (!*v871) {
        goto LABEL_1490;
      }
      do
      {
        *((_DWORD *)v727 + 149) = 1;
        v727[28] = 0LL;
        ActivateUnicastRegistration(a1, (uint64_t)v727);
        v727 = (uint64_t *)*v727;
      }

      while (v727);
      goto LABEL_1418;
    }

LABEL_1345:
    int v657 = 1440 - v654;
    __int16 v641 = mDNS_NewMessageID(a1);
    *(_WORD *)unint64_t v653 = v641;
    *(_WORD *)(v653 + 2) = 40;
    *(void *)(v653 + 4) = 0LL;
    v662 = (unsigned __int8 *)v640[46];
    v663 = v662;
LABEL_1346:
    unsigned __int16 v664 = 257;
    if (v663 < v662 + 256 && v663)
    {
      while (1)
      {
        uint64_t v665 = *v663;
        if (v665 > 0x3F)
        {
LABEL_1354:
          unsigned __int16 v664 = 257;
          goto LABEL_1356;
        }

        if (!*v663) {
          break;
        }
        v663 += v665 + 1;
LABEL_1349:
        if (!v663) {
          goto LABEL_1354;
        }
      }

      unsigned __int16 v664 = (_WORD)v663 - (_WORD)v662 + 1;
    }

LABEL_1356:
    int v864 = v664 + 4;
    int v642 = v657 - v864;
    if (v657 <= v864)
    {
      LogMsgWithLevel( *((os_log_s **)v628 + 170),  OS_LOG_TYPE_DEFAULT,  "SendGroupUpdates: ERROR no space for zone information, disabling merge",  (uint64_t)v662,  v658,  v659,  v660,  v661,  v820);
      v717 = *v871;
      if (!*v871) {
        goto LABEL_1490;
      }
      do
      {
        *((_DWORD *)v717 + 149) = 1;
        v717[28] = 0LL;
        ActivateUnicastRegistration(a1, (uint64_t)v717);
        v717 = (uint64_t *)*v717;
      }

      while (v717);
      goto LABEL_1418;
    }

    v852 = v651;
    unint64_t v860 = v849 + v657;
    v666 = putZone(v653, v849, v860, v662, bswap32(*((unsigned __int16 *)v640 + 7)) >> 16, v659, v660, v661);
    if (!v666)
    {
      LogMsgWithLevel( *((os_log_s **)v628 + 170),  OS_LOG_TYPE_DEFAULT,  "SendGroupUpdates: ERROR! Cannot put zone, disabling merge",  v667,  v624,  v625,  v626,  v627,  v820);
      v718 = *v871;
      if (!*v871) {
        goto LABEL_1490;
      }
      do
      {
        *((_DWORD *)v718 + 149) = 1;
        v718[28] = 0LL;
        ActivateUnicastRegistration(a1, (uint64_t)v718);
        v718 = (uint64_t *)*v718;
      }

      while (v718);
LABEL_1418:
      v719 = *v871;
      if (!*v871) {
        goto LABEL_1490;
      }
      while (1)
      {
        while (1)
        {
          uint64_t v720 = (uint64_t)v719;
          v719 = (uint64_t *)*v719;
          if (*(void *)(v720 + 224) == -4LL) {
            break;
          }
LABEL_1422:
          if (!v719) {
            goto LABEL_1405;
          }
        }

        if (*(_DWORD *)(v720 + 280) + *(_DWORD *)(v720 + 284) - *(_DWORD *)(a1 + 64) >= 1)
        {
          v721 = (os_log_s *)*((void *)v628 + 170);
          GetRRDisplayString_rdb( (unsigned __int8 *)(v720 + 8),  (unsigned __int16 *)(*(void *)(v720 + 48) + 4LL),  v874);
          LogMsgWithLevel( v721,  OS_LOG_TYPE_DEFAULT,  "CheckGroupRecordUpdates: ERROR!! Resourcerecord %s not ready",  v722,  v723,  v724,  v725,  v726,  (int)v874);
          goto LABEL_1422;
        }

        *(void *)(v720 + 224) = 0LL;
        SendRecordRegistration(a1, v720);
        if (!v719) {
          goto LABEL_1405;
        }
      }
    }

    unint64_t v643 = (unint64_t)v666;
    uint64_t v868 = (uint64_t)v640;
LABEL_1359:
    int v668 = *((_DWORD *)v640 + 86);
    if (v668 == 7)
    {
      int v669 = *((unsigned __int16 *)v640 + 309) + *((unsigned __int16 *)v640 + 308);
      goto LABEL_1363;
    }

    int v669 = *((unsigned __int16 *)v640 + 11);
    if (v668 == 3)
    {
      int v670 = 12;
    }

    else
    {
LABEL_1363:
      int v671 = *((unsigned __int8 *)v640 + 8);
      if (v671 == 32) {
        int v672 = 24;
      }
      else {
        int v672 = 12;
      }
      if (v671 == 16) {
        int v670 = 24;
      }
      else {
        int v670 = v672;
      }
    }

    v673 = (_BYTE *)v640[5];
    v674 = v673;
    if (v673 == (_BYTE *)-256LL) {
      goto LABEL_1373;
    }
LABEL_1370:
    unsigned __int16 v675 = 257;
    if (v674 < v673 + 256 && v674)
    {
      while (1)
      {
        uint64_t v676 = *v674;
        if (v676 > 0x3F)
        {
LABEL_1378:
          unsigned __int16 v675 = 257;
          goto LABEL_1380;
        }

        if (!*v674) {
          break;
        }
        v674 += v676 + 1;
        if (v673 != (_BYTE *)-256LL) {
          goto LABEL_1370;
        }
LABEL_1373:
        if (!v674) {
          goto LABEL_1378;
        }
      }

      unsigned __int16 v675 = (_WORD)v674 - (_WORD)v673 + 1;
    }

LABEL_1380:
    int v677 = v670 - v864 + v669 + v675 + 4;
    if (v642 - v677 < 0)
    {
      if (v644)
      {
        if (mDNS_LoggingEnabled)
        {
          v692 = (os_log_s *)*((void *)v628 + 170);
          GetRRDisplayString_rdb( (unsigned __int8 *)(v868 + 8),  (unsigned __int16 *)(*(void *)(v868 + 48) + 4LL),  v874);
          LogMsgWithLevel( v692,  OS_LOG_TYPE_DEFAULT,  "SendGroupUpdates:1: Parsed %d records and sending using %s, spaceleft %d, rrSize %d",  v693,  v694,  v695,  v696,  v697,  v644);
        }

        SendGroupRRMessage(a1, v868, v643, v852);
        if (!v640) {
          goto LABEL_1400;
        }
      }

      else
      {
        if (mDNS_LoggingEnabled)
        {
          v698 = (os_log_s *)*((void *)v628 + 170);
          GetRRDisplayString_rdb((unsigned __int8 *)v640 + 8, (unsigned __int16 *)(v640[6] + 4), v874);
          LogMsgWithLevel( v698,  OS_LOG_TYPE_DEFAULT,  "SendGroupUpdates: Skipping message %s, spaceleft %d, rrSize %d",  v699,  v700,  v701,  v702,  v703,  (int)v874);
        }

        uint64_t v868 = 0LL;
        int v844 = 0;
        v640[28] = -4LL;
        *((_DWORD *)v640 + 70) = 1000;
        *((_DWORD *)v640 + 71) = *(_DWORD *)(a1 + 64) - 1000;
        v640 = (uint64_t *)*v640;
        if (!v640)
        {
LABEL_1400:
          if (v868)
          {
            if (mDNS_LoggingEnabled == 1)
            {
              v704 = (os_log_s *)*((void *)v628 + 170);
              GetRRDisplayString_rdb( (unsigned __int8 *)(v868 + 8),  (unsigned __int16 *)(*(void *)(v868 + 48) + 4LL),  v874);
              LogMsgWithLevel( v704,  OS_LOG_TYPE_DEFAULT,  "SendGroupUpdates: Parsed %d records and sending using %s",  v705,  v706,  v707,  v708,  v709,  v644);
            }

            SendGroupRRMessage(a1, v868, v643, v852);
          }

          if (!v844) {
            goto LABEL_1418;
          }
LABEL_1405:
          v620 = *v871;
          if (!*v871) {
            goto LABEL_1490;
          }
LABEL_1408:
          uint64_t v621 = 0LL;
LABEL_1409:
          unsigned int v284 = *(_DWORD *)(a1 + 64);
          continue;
        }
      }

      goto LABEL_1328;
    }

    break;
  }

  if (mDNS_LoggingEnabled == 1)
  {
    v855 = (os_log_s *)*((void *)v628 + 170);
    GetRRDisplayString_rdb((unsigned __int8 *)v640 + 8, (unsigned __int16 *)(v640[6] + 4), v874);
    LogMsgWithLevel( v855,  OS_LOG_TYPE_DEFAULT,  "SendGroupUpdates: Building a message with resource record %s, next %p, state %d, ttl %d",  v678,  v679,  v680,  v681,  v682,  (int)v874);
  }

  unint64_t v683 = BuildUpdateMessage(a1, v643, (uint64_t)v640, v860, v624, v625, v626, v627);
  if (v683)
  {
    unint64_t v684 = v683;
    if ((uint64_t)(v683 - v643) <= v677)
    {
      v642 -= v683 - v643;
    }

    else
    {
      v685 = (os_log_s *)mDNSLogCategory_Default;
      GetRRDisplayString_rdb((unsigned __int8 *)v640 + 8, (unsigned __int16 *)(v640[6] + 4), v874);
      LogMsgWithLevel( v685,  OS_LOG_TYPE_DEFAULT,  "SendGroupUpdates: ERROR!! Record size estimation is wrong for %s, Estimate %d, Actual %d, state %d",  v686,  v687,  v688,  v689,  v690,  (int)v874);
      v642 -= v677;
    }

    uint64_t v691 = v640[48];
    if (v691)
    {
      DisposeTCPConn(v691);
      v640[48] = 0LL;
    }

    ++v644;
    *((_WORD *)v640 + 179) = v641;
    SetRecordRetry(a1, (uint64_t)v640, 0);
    unint64_t v643 = v684;
    v628 = &unk_100164000;
    goto LABEL_1390;
  }

  v710 = (os_log_s *)*((void *)v628 + 170);
  GetRRDisplayString_rdb((unsigned __int8 *)v640 + 8, (unsigned __int16 *)(v640[6] + 4), v874);
  LogMsgWithLevel( v710,  OS_LOG_TYPE_DEFAULT,  "SendGroupUpdates: ptr NULL while building message with %s",  v711,  v712,  v713,  v714,  v715,  (int)v874);
  v716 = *v871;
  if (*v871)
  {
    do
    {
      *((_DWORD *)v716 + 149) = 1;
      v716[28] = 0LL;
      ActivateUnicastRegistration(a1, (uint64_t)v716);
      v716 = (uint64_t *)*v716;
    }

    while (v716);
    goto LABEL_1418;
  }

LABEL_1490:
  uint64_t v803 = *(void *)(a1 + 216);
  v804 = (void *)(a1 + 208);
  if (v803)
  {
    v805 = (os_log_s *)mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
      {
        v807 = (_BYTE *)(v803 + 356);
        if (v803 == -612)
        {
LABEL_1501:
          while (v807)
          {
            uint64_t v808 = *v807;
            if (!*v807)
            {
              int v812 = (unsigned __int16)((_WORD)v807 - (v803 + 356) + 1);
              goto LABEL_1518;
            }

            v807 += v808 + 1;
            if (v803 != -612) {
              goto LABEL_1500;
            }
          }
        }

        else
        {
LABEL_1500:
        }

        int v812 = 257;
LABEL_1518:
        v813 = DNSTypeName(*(unsigned __int16 *)(v803 + 322));
        *(_DWORD *)buf = 141559043;
        *(void *)&uint8_t buf[4] = 1752392040LL;
        *(_WORD *)&buf[12] = 1040;
        *(_DWORD *)&buf[14] = v812;
        *(_WORD *)&buf[18] = 2101;
        *(void *)&buf[20] = v803 + 356;
        *(_WORD *)&buf[28] = 2160;
        *(void *)&buf[30] = 1752392040LL;
        *(_WORD *)&buf[38] = 2085;
        *(void *)&buf[40] = v813;
        _os_log_impl( (void *)&_mh_execute_header,  v805,  OS_LOG_TYPE_DEFAULT,  "uDNS_Tasks ERROR m->CurrentQuestion already set: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%{sens itive, mask.hash}s)",  buf,  0x30u);
        v804 = (void *)(a1 + 208);
      }
    }

    else
    {
      v805 = (os_log_s *)mDNSLogCategory_Default_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
      {
        v810 = (_BYTE *)(v803 + 356);
        if (v803 == -612)
        {
LABEL_1509:
          while (v810)
          {
            uint64_t v811 = *v810;
            if (!*v810)
            {
              int v812 = (unsigned __int16)((_WORD)v810 - (v803 + 356) + 1);
              goto LABEL_1518;
            }

            v810 += v811 + 1;
            if (v803 != -612) {
              goto LABEL_1508;
            }
          }
        }

        else
        {
LABEL_1508:
        }

        int v812 = 257;
        goto LABEL_1518;
      }
    }
  }

  uint64_t v814 = *(void *)(a1 + 200);
  *(void *)(a1 + 216) = v814;
  if (v814)
  {
    while (v814 != *v804)
    {
      int v815 = *(_DWORD *)(v814 + 212);
      if (v815 < 1 || *(void *)(v814 + 40) || !*(_WORD *)(v814 + 320))
      {
LABEL_1523:
        uint64_t v816 = *(void *)(v814 + 8);
        *(void *)(a1 + 216) = v816;
      }

      else
      {
        int v817 = v815 + *(_DWORD *)(v814 + 208);
        uint64_t v816 = v814;
        if (*(_DWORD *)(a1 + 64) - v817 >= 0)
        {
          Querier_HandleUnicastQuestion(v814);
          uint64_t v816 = *(void *)(a1 + 216);
        }

        if (v814 == v816)
        {
          int v818 = *(_DWORD *)(v814 + 212) + *(_DWORD *)(v814 + 208);
          if (*(_DWORD *)(a1 + 12688) - v818 >= 1) {
            *(_DWORD *)(a1 + 12688) = v818;
          }
          goto LABEL_1523;
        }
      }

      uint64_t v814 = v816;
      if (!v816) {
        break;
      }
      continue;
    }
  }

  *(void *)(a1 + 216) = 0LL;
LABEL_1533:
  mDNS_Unlock_(a1, (uint64_t)"mDNS_Execute", 7051);
  return *(unsigned int *)(a1 + 72);
}

void connect_callback(int a1)
{
  __int128 v34 = 0u;
  memset(v35, 0, sizeof(v35));
  __int128 v32 = 0u;
  __int128 v33 = 0u;
  __int128 v31 = 0u;
  sockaddr v30 = (sockaddr)0;
  socklen_t v21 = 106;
  int v1 = accept(a1, &v30, &v21);
  uint64_t v20 = 1LL;
  if ((v1 & 0x80000000) == 0)
  {
    int v2 = v1;
    if ((setsockopt(v1, 0xFFFF, 4130, &v20, 8u) & 0x80000000) == 0) {
      goto LABEL_12;
    }
    uint64_t v3 = (os_log_s *)mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_12;
      }
    }

    else
    {
      uint64_t v3 = (os_log_s *)mDNSLogCategory_Default_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_12;
      }
    }

    int v6 = *__error();
    uint64_t v7 = __error();
    uint64_t v8 = strerror(*v7);
    *(_DWORD *)buf = 67109634;
    *(_DWORD *)&uint8_t buf[4] = v2;
    *(_WORD *)&buf[8] = 1024;
    *(_DWORD *)&buf[10] = v6;
    *(_WORD *)&buf[14] = 2082;
    *(void *)&__int128 v27 = v8;
    _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEFAULT,  "%3d: WARNING: setsockopt - SO_NOSIGPIPE %d (%{public}s)",  buf,  0x18u);
LABEL_12:
    int v9 = fcntl(v2, 3, 0LL);
    if (fcntl(v2, 4, v9 | 4u))
    {
      my_perror((int)"ERROR: fcntl(sd, F_SETFL, O_NONBLOCK) - aborting client");
      close(v2);
      return;
    }

    uint64_t v10 = calloc(1uLL, 0x118uLL);
    if (!v10) {
      __break(1u);
    }
    uint64_t v11 = (uint64_t)v10;
    uint64_t v12 = &all_requests;
    do
    {
      uint64_t v13 = v12;
      uint64_t v14 = *v12;
      uint64_t v12 = (uint64_t *)(*v12 + 16);
    }

    while (v14);
    *uint64_t v13 = (uint64_t)v10;
    v10[275] = 1;
    *((_DWORD *)v10 + 42) = v2;
    *((_DWORD *)v10 + 44) = v2;
    do
      unsigned int v15 = __ldaxr(&dnssd_server_get_new_request_id_s_next_id);
    while (__stlxr(v15 + 1, &dnssd_server_get_new_request_id_s_next_id));
    *((_DWORD *)v10 + 47) = 0;
    *((_DWORD *)v10 + 48) = 0;
    *((_DWORD *)v10 + 46) = v15;
    set_peer_pid((uint64_t)v10);
    __int128 v28 = 0u;
    memset(v29, 0, sizeof(v29));
    *(_OWORD *)buf = 0u;
    __int128 v27 = 0u;
    socklen_t v19 = 76;
    if (getsockopt(v2, 0, 1, buf, &v19) < 0 || *(_DWORD *)buf) {
      my_perror((int)"ERROR: getsockopt, LOCAL_PEERCRED");
    }
    else {
      *(_DWORD *)(v11 + 180) = *(_DWORD *)&buf[4];
    }
    uint64_t v16 = (os_log_s *)mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEBUG))
      {
LABEL_28:
        int v17 = *(_DWORD *)(v11 + 168);
        int v18 = *(_DWORD *)(v11 + 180);
        *(_DWORD *)uint64_t v22 = 67109376;
        int v23 = v17;
        __int16 v24 = 1024;
        int v25 = v18;
        _os_log_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_DEBUG,  "%3d: connect_callback: Adding FD for uid %u",  v22,  0xEu);
      }
    }

    else
    {
      uint64_t v16 = (os_log_s *)mDNSLogCategory_Default_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEBUG)) {
        goto LABEL_28;
      }
    }

    udsSupportAddFDToEventLoop(v2, (uint64_t)request_callback, v11);
    return;
  }

  if (*__error() != 35)
  {
    int v4 = my_throttled_perror_uds_throttle_count++;
    HIDWORD(v5) = 652835029 * v4 + 17179868;
    LODWORD(v5) = HIDWORD(v5);
  }

void request_callback( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = a2;
  unsigned __int8 v9 = *(_BYTE *)(a2 + 275);
  while (2)
  {
    if (v9 == 1)
    {
      uint64_t v13 = *(unsigned int *)(v8 + 196);
      ssize_t v14 = recv(*(_DWORD *)(v8 + 168), (void *)(v8 + v13 + 200), 28 - v13, 0);
      if (!v14)
      {
        char v1302 = 4;
LABEL_2252:
        *(_BYTE *)(v8 + 275) = v1302;
        goto LABEL_2253;
      }

      if (v14 < 0)
      {
LABEL_28:
        if (*__error() != 35 && *__error() != 4)
        {
          uint64_t v1304 = mDNSLogCategory_Default;
          if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
          {
            if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_ERROR))
            {
LABEL_2244:
              int v1308 = *(_DWORD *)(v8 + 184);
              int v1309 = *__error();
              v1310 = __error();
              v1311 = strerror(*v1310);
              v1489.dev_t st_dev = 67109634;
              *(_DWORD *)&v1489.st_mode = v1308;
              LOWORD(v1489.st_ino) = 1024;
              *(_DWORD *)((char *)&v1489.st_ino + 2) = v1309;
              HIWORD(v1489.st_ino) = 2082;
              *(void *)&v1489.st_uid = v1311;
              v1293 = "[R%u] ERROR: read_msg errno %d (%{public}s)";
              v1298 = (os_log_s *)v1304;
              uint32_t v1299 = 24;
              goto LABEL_2250;
            }
          }

          else
          {
            uint64_t v1304 = mDNSLogCategory_Default_redacted;
            if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_ERROR)) {
              goto LABEL_2244;
            }
          }

LABEL_2251:
          char v1302 = 3;
          goto LABEL_2252;
        }

LABEL_65:
          uint64_t v38 = 0LL;
          memset(v1508, 0, 26);
          __int128 v1507 = 0u;
          __int128 v1506 = 0u;
          __int128 v1505 = 0u;
          memset(v1504, 0, sizeof(v1504));
          v1504[0].sa_family = 1;
          while (1)
          {
            int v39 = *((unsigned __int8 *)__src + v38);
            v1504[0].sa_data[v38] = v39;
            if (!v39) {
              break;
            }
            if (++v38 == 103)
            {
              BYTE9(v1508[1]) = 0;
              break;
            }
          }

          if (!LOBYTE(__src[0]))
          {
            int v41 = *(_DWORD *)(v8 + 176);
            if (v41 == *(_DWORD *)(v8 + 168))
            {
              uint64_t v42 = mDNSLogCategory_Default;
              if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
              {
                if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_ERROR)) {
                  goto LABEL_114;
                }
              }

              else
              {
                uint64_t v42 = mDNSLogCategory_Default_redacted;
                if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_ERROR)) {
                  goto LABEL_114;
                }
              }

              int v57 = *(_DWORD *)(v8 + 184);
              v1489.dev_t st_dev = 67109120;
              *(_DWORD *)&v1489.st_mode = v57;
              int v52 = (uint8_t *)&v1489;
              BOOL v53 = (os_log_s *)v42;
              uint64_t v54 = "[R%u] read_msg: ERROR failed to get errsd via SCM_RIGHTS";
              uint32_t v55 = 8;
              goto LABEL_113;
            }

    *(_DWORD *)buf = 141558787;
    int v62 = 1752392040LL;
    char v63 = 1040;
    uint64_t v64 = v40;
    int v65 = 2101;
    int v66 = v60;
    int v67 = 1024;
    int v68 = a3;
    _os_log_impl( (void *)&_mh_execute_header,  v31,  OS_LOG_TYPE_DEFAULT,  "internal_stop_browsing_for_service: stopping browse - qname: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P , qtype: %{mdns:rrtype}d",  buf,  0x22u);
LABEL_66:
    int v41 = putDomainNameAsLabels( (unint64_t)&compression_base_msg,  (unint64_t)&unk_100149887,  (unint64_t)&compression_base_msg + &unk_1000022F8,  (unsigned __int8 *)v60,  v32,  v33,  v34,  v35);
    if (v41)
    {
      os_log_s *v41 = BYTE1(a3);
      v41[1] = a3;
      v41[2] = 1;
      uint64_t v42 = v41 + 3;
    }

    else
    {
      uint64_t v42 = 0LL;
    }

    int v43 = v42 - (_BYTE *)&unk_100149887;
    PrintHelper( (uint64_t)"internal_stop_browsing_for_service",  (uint64_t)&unk_100149887,  (unsigned __int16)(v42 - (_BYTE *)&unk_100149887),  0LL,  0);
    uint64_t v44 = xD2DMapToTransportType(a1, a4, &v59);
    if ((_DWORD)v44 == 4)
    {
      int v45 = 0LL;
      unint64_t v46 = v59;
      do
      {
        if (v46 != (_DWORD)v45)
        {
          if (&_D2DStopBrowsingForKeyOnTransport)
          {
            D2DStopBrowsingForKeyOnTransport(&unk_100149887, v43, v45);
            if ((v45 & 0x7FFFFFFE) == 2) {
              _mdns_powerlog_awdl_event((uint64_t)@"stopAWDLBrowse", a2, a3, a5);
            }
          }
        }

        int v45 = (v45 + 1);
      }

      while ((_DWORD)v45 != 4);
    }

    else if (&_D2DStopBrowsingForKeyOnTransport)
    {
      int v47 = v44;
      D2DStopBrowsingForKeyOnTransport(&unk_100149887, v43, v44);
      if ((v47 & 6) == 2) {
        _mdns_powerlog_awdl_event((uint64_t)@"stopAWDLBrowse", a2, a3, a5);
      }
    }

    int v48 = (void *)D2DRecords;
    if (D2DRecords)
    {
      while (1)
      {
        int v49 = v48;
        int v48 = (void *)*v48;
        uint64_t v50 = (os_log_s *)mDNSLogCategory_D2D;
        if (gSensitiveLoggingEnabled == 1 && mDNSLogCategory_D2D != mDNSLogCategory_State) {
          break;
        }
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_D2D, OS_LOG_TYPE_DEFAULT))
        {
          for (uint64_t n = (uint8_t *)v60; ; n += v54 + 1)
          {
            LOWORD(v53) = 257;
            if (n >= buf || !n) {
              break;
            }
            uint64_t v54 = *n;
            if (v54 > 0x3F)
            {
              LOWORD(v53) = 257;
              break;
            }

            if (!*n)
            {
              BOOL v53 = (_DWORD)n - v60 + 1;
              break;
            }
          }

                  uint64_t v64 = *((unsigned __int16 *)v47 + 6);
                  if (v64 != 28 && v64 != 1) {
                    goto LABEL_95;
                  }
                  int v65 = v47[4];
                  int v66 = (char *)calloc(1uLL, 0x498uLL);
                  if (!v66) {
                    goto LABEL_256;
                  }
                  int v67 = v66;
                  mDNS_SetupResourceRecord( (uint64_t)v66,  0LL,  v65,  *((_WORD *)v47 + 6),  *((_DWORD *)v47 + 4),  *((_BYTE *)v47 + 8),  *((_DWORD *)v47 + 43),  0LL,  0LL);
                  int v68 = (char *)v47 + 652;
                  int v69 = (char *)v47 + 652;
                  break;
              }

              while (1)
              {
                if (!v69) {
                  goto LABEL_77;
                }
                uint64_t v70 = *v69;
                if (!*v69) {
                  break;
                }
                v69 += v70 + 1;
                if (v47 != (uint64_t *)-908LL)
                {
LABEL_69:
                  if (v69 >= (_BYTE *)v47 + 908) {
                    goto LABEL_77;
                  }
                }
              }

              __int128 v71 = (_WORD)v69 - (_WORD)v68 + 1;
              if (v71 > 0x100u) {
LABEL_77:
              }
                v67[652] = 0;
              else {
                memcpy(v67 + 652, v68, v71);
              }
              int v72 = (_BYTE *)v47[5];
              int v73 = v72;
              if (v72 == (_BYTE *)-256LL) {
                goto LABEL_82;
              }
LABEL_79:
              uint64_t v74 = 257;
              if (v73 < v72 + 256 && v73)
              {
                do
                {
                  unsigned int v75 = *v73;
                  if (!*v73)
                  {
                    uint64_t v74 = (_WORD)v73 - (_WORD)v72 + 1;
                    goto LABEL_89;
                  }

                  v73 += v75 + 1;
                  if (v72 != (_BYTE *)-256LL) {
                    goto LABEL_79;
                  }
LABEL_82:
                  ;
                }

                while (v73);
                uint64_t v74 = 257;
              }

    *(_DWORD *)uint32_t v30 = 141558531;
    *(void *)&v30[4] = 1752392040LL;
    *(_WORD *)&v30[12] = 1040;
    *(_DWORD *)&v30[14] = v29;
    *(_WORD *)&v30[18] = 2101;
    *(void *)&v30[20] = v21;
    _os_log_impl( (void *)&_mh_execute_header,  v19,  OS_LOG_TYPE_ERROR,  "No existing TSR for %{sensitive, mask.hash, mdnsresponder:domain_name}.*P",  v30,  0x1Cu);
    return v15;
  }

  socklen_t v19 = (os_log_s *)mDNSLogCategory_mDNS_redacted;
  if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_ERROR))
  {
    unint64_t v21 = *(void *)(a2 + 40);
    if (v21)
    {
      int v25 = *(_BYTE **)(a2 + 40);
      if (v21 == -256)
      {
LABEL_45:
        while (v25)
        {
          uint64_t v26 = *v25;
          if (!*v25)
          {
            int v29 = (unsigned __int16)((_WORD)v25 - v21 + 1);
            goto LABEL_65;
          }

          v25 += v26 + 1;
          if (v21 != -256) {
            goto LABEL_44;
          }
        }
      }

      else
      {
LABEL_44:
      }

      int v29 = 257;
    }

    else
    {
      int v29 = 0;
    }

    goto LABEL_65;
  }

  return v15;
}

LABEL_81:
            int v1313 = fcntl(v41, 3, 0LL, v1314, v1315, v1316, v1317) | 4;
            if (!fcntl(v41, 4)) {
              goto LABEL_53;
            }
            uint64_t v44 = mDNSLogCategory_Default;
            if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
            {
              if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_ERROR))
              {
LABEL_93:
                int v48 = *(_DWORD *)(v8 + 184);
                int v49 = *__error();
                uint64_t v50 = __error();
                uint64_t v51 = strerror(*v50);
                v1489.dev_t st_dev = 67109634;
                *(_DWORD *)&v1489.st_mode = v48;
                LOWORD(v1489.st_ino) = 1024;
                *(_DWORD *)((char *)&v1489.st_ino + 2) = v49;
                HIWORD(v1489.st_ino) = 2082;
                *(void *)&v1489.st_uid = v51;
                int v52 = (uint8_t *)&v1489;
                BOOL v53 = (os_log_s *)v44;
                uint64_t v54 = "[R%u] ERROR: could not set control socket to non-blocking mode errno %d (%{public}s)";
                uint32_t v55 = 24;
LABEL_113:
                _os_log_impl((void *)&_mh_execute_header, v53, OS_LOG_TYPE_ERROR, v54, v52, v55);
              }
            }

            else
            {
              uint64_t v44 = mDNSLogCategory_Default_redacted;
              if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_ERROR)) {
                goto LABEL_93;
              }
            }

LABEL_114:
            *(_BYTE *)(v8 + 275) = 3;
            goto LABEL_115;
          }

          int v40 = socket(1, 1, 0);
          *(_DWORD *)(v8 + 176) = v40;
          if (v40 < 0)
          {
            int v45 = my_throttled_perror_uds_throttle_count++;
            HIDWORD(v46) = 652835029 * v45 + 17179868;
            LODWORD(v46) = HIDWORD(v46);
            goto LABEL_114;
          }

          if ((connect(v40, v1504, 0x6Au) & 0x80000000) == 0)
          {
            int v41 = *(_DWORD *)(v8 + 176);
            goto LABEL_81;
          }

          memset(&v1489, 0, sizeof(v1489));
          int v47 = (os_log_s *)mDNSLogCategory_Default;
          if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
          {
            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_ERROR)) {
              goto LABEL_98;
            }
          }

          else
          {
            int v47 = (os_log_s *)mDNSLogCategory_Default_redacted;
            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_ERROR)) {
              goto LABEL_98;
            }
          }

          int v58 = *(_DWORD *)(v8 + 184);
          int v59 = *__error();
          int v60 = __error();
          unsigned int v61 = strerror(*v60);
          *(_DWORD *)buf = 67109890;
          *(_DWORD *)&uint8_t buf[4] = v58;
          *(_WORD *)&buf[8] = 2082;
          *(void *)&buf[10] = v1504[0].sa_data;
          *(_WORD *)&buf[18] = 1024;
          *(_DWORD *)&buf[20] = v59;
          *(_WORD *)&buf[24] = 2082;
          *(void *)&buf[26] = v61;
          _os_log_impl( (void *)&_mh_execute_header,  v47,  OS_LOG_TYPE_ERROR,  "[R%u] read_msg: Couldn't connect to error return path socket %{public}s errno %d (%{public}s)",  buf,  0x22u);
LABEL_98:
          int v62 = stat(v1504[0].sa_data, &v1489);
          char v63 = gSensitiveLoggingEnabled;
          uint64_t v64 = mDNSLogCategory_Default;
          if (mDNSLogCategory_Default == mDNSLogCategory_State) {
            char v63 = 0;
          }
          if (v62 < 0)
          {
            if ((v63 & 1) != 0)
            {
              uint64_t v64 = mDNSLogCategory_Default_redacted;
              if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_ERROR)) {
                goto LABEL_114;
              }
            }

            else if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_ERROR))
            {
              goto LABEL_114;
            }

            int v68 = *(_DWORD *)(v8 + 184);
            int v69 = *__error();
            uint64_t v70 = __error();
            __int128 v71 = strerror(*v70);
            *(_DWORD *)buf = 67109890;
            *(_DWORD *)&uint8_t buf[4] = v68;
            *(_WORD *)&buf[8] = 2082;
            *(void *)&buf[10] = v1504[0].sa_data;
            *(_WORD *)&buf[18] = 1024;
            *(_DWORD *)&buf[20] = v69;
            *(_WORD *)&buf[24] = 2082;
            *(void *)&buf[26] = v71;
            int v52 = buf;
            BOOL v53 = (os_log_s *)v64;
            uint64_t v54 = "[R%u] read_msg: stat failed %{public}s errno %d (%{public}s)";
            uint32_t v55 = 34;
            goto LABEL_113;
          }

          if ((v63 & 1) != 0)
          {
            uint64_t v64 = mDNSLogCategory_Default_redacted;
            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_ERROR)) {
              goto LABEL_114;
            }
          }

          else if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_ERROR))
          {
            goto LABEL_114;
          }

          int v67 = *(_DWORD *)(v8 + 184);
          *(_DWORD *)buf = 67110146;
          *(_DWORD *)&uint8_t buf[4] = v67;
          *(_WORD *)&buf[8] = 2082;
          *(void *)&buf[10] = v1504[0].sa_data;
          *(_WORD *)&buf[18] = 1024;
          *(_DWORD *)&buf[20] = v1489.st_mode;
          *(_WORD *)&buf[24] = 1024;
          *(_DWORD *)&buf[26] = v1489.st_uid;
          *(_WORD *)&buf[30] = 1024;
          *(_DWORD *)&buf[32] = v1489.st_gid;
          int v52 = buf;
          BOOL v53 = (os_log_s *)v64;
          uint64_t v54 = "[R%u] read_msg: file %{public}s mode %o (octal) uid %d gid %d";
          uint32_t v55 = 36;
          goto LABEL_113;
        }

        uint64_t v1306 = mDNSLogCategory_Default;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
        {
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_ERROR)) {
            goto LABEL_2251;
          }
        }

        else
        {
          uint64_t v1306 = mDNSLogCategory_Default_redacted;
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_ERROR)) {
            goto LABEL_2251;
          }
        }

        int v1312 = *(_DWORD *)(v8 + 184);
        v1489.dev_t st_dev = 67109632;
        *(_DWORD *)&v1489.st_mode = v1312;
        LOWORD(v1489.st_ino) = 1024;
        *(_DWORD *)((char *)&v1489.st_ino + 2) = v18;
        HIWORD(v1489.st_ino) = 1024;
        v1489.st_uid = v18;
        v1293 = "[R%u] ERROR: read_msg: hdr.datalen %u (0x%X) > 70000";
      }

      else
      {
        uint64_t v1306 = mDNSLogCategory_Default;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
        {
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_ERROR)) {
            goto LABEL_2251;
          }
        }

        else
        {
          uint64_t v1306 = mDNSLogCategory_Default_redacted;
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_ERROR)) {
            goto LABEL_2251;
          }
        }

        int v1307 = *(_DWORD *)(v8 + 184);
        v1489.dev_t st_dev = 67109632;
        *(_DWORD *)&v1489.st_mode = v1307;
        LOWORD(v1489.st_ino) = 1024;
        *(_DWORD *)((char *)&v1489.st_ino + 2) = v17;
        HIWORD(v1489.st_ino) = 1024;
        v1489.st_uid = 1;
        v1293 = "[R%u] ERROR: client version 0x%08X daemon version 0x%08X";
      }

      v1298 = (os_log_s *)v1306;
      uint32_t v1299 = 20;
      goto LABEL_2250;
    }

    if (v9 != 2)
    {
      if (v9 - 3 > 1)
      {
        uint64_t v1294 = mDNSLogCategory_Default;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
        {
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_ERROR)) {
            goto LABEL_2251;
          }
        }

        else
        {
          uint64_t v1294 = mDNSLogCategory_Default_redacted;
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_ERROR)) {
            goto LABEL_2251;
          }
        }

        int v1301 = *(_DWORD *)(v8 + 184);
        v1489.dev_t st_dev = 67109376;
        *(_DWORD *)&v1489.st_mode = v1301;
        LOWORD(v1489.st_ino) = 1024;
        *(_DWORD *)((char *)&v1489.st_ino + 2) = v9;
        v1293 = "[R%u] ERROR: read_msg called with invalid transfer state (%d)";
        v1298 = (os_log_s *)v1294;
        uint32_t v1299 = 14;
LABEL_2250:
        _os_log_impl((void *)&_mh_execute_header, v1298, OS_LOG_TYPE_ERROR, v1293, (uint8_t *)&v1489, v1299);
        goto LABEL_2251;
      }

      uint64_t v1290 = mDNSLogCategory_Default;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_ERROR)) {
          goto LABEL_2251;
        }
        int v1292 = *(_DWORD *)(v8 + 184);
        v1489.dev_t st_dev = 67109120;
        *(_DWORD *)&v1489.st_mode = v1292;
        v1293 = "[R%u] ERROR: read_msg called with transfer state terminated or error";
      }

      else
      {
        uint64_t v1290 = mDNSLogCategory_Default_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_ERROR)) {
          goto LABEL_2251;
        }
        int v1297 = *(_DWORD *)(v8 + 184);
        v1489.dev_t st_dev = 67109120;
        *(_DWORD *)&v1489.st_mode = v1297;
        v1293 = "[R%u] ERROR: read_msg called with transfer state terminated or error";
      }

      __int128 v90 = DNSTypeName(*(unsigned __int16 *)(v13 + 322));
      unsigned int v91 = LLQStateToString(*(unsigned __int8 *)(v13 + 330));
      *(_DWORD *)buf = 67110659;
      *(_DWORD *)&uint8_t buf[4] = v104;
      *(_WORD *)&buf[8] = 1024;
      *(_DWORD *)&buf[10] = v105;
      *(_WORD *)&buf[14] = 2160;
      *(void *)uint64_t v108 = 1752392040LL;
      *(_WORD *)&v108[8] = 1040;
      *(_DWORD *)&v108[10] = v88;
      uint64_t v109 = 2101;
      *(void *)uint64_t v110 = v13 + 356;
      *(_WORD *)&v110[8] = 2082;
      *(void *)&v110[10] = v90;
      *(_WORD *)&v110[18] = 2082;
      *(void *)&v110[20] = v91;
      _os_log_impl( (void *)&_mh_execute_header,  v67,  OS_LOG_TYPE_DEFAULT,  "[R%u->Q%u] Starting long-lived query polling - qname: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P, qty pe: %{public}s, LLQ_State: %{public}s.",  buf,  0x3Cu);
LABEL_115:
      int v92 = *(void *)(v13 + 104);
      if (!v92)
      {
LABEL_140:
        *(_BYTE *)(v13 + 330) = 30;
        *(_DWORD *)(v13 + 212) = 3000;
        *(_DWORD *)(v13 + 208) = *(_DWORD *)(v12 + 64) - 2999;
        SetNextQueryTime(v12, v13);
        goto LABEL_144;
      }

      BOOL v93 = bswap32(*(unsigned __int16 *)(v92 + 1152)) >> 16;
      uint64_t v94 = (os_log_s *)mDNSLogCategory_Default;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
      {
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
        {
          int v97 = (_BYTE *)(v92 + 1188);
          if (v92 == -1444)
          {
LABEL_129:
            while (v97)
            {
              uint64_t v98 = *v97;
              if (!*v97)
              {
                unint64_t v99 = (unsigned __int16)((_WORD)v97 - (v92 + 1188) + 1);
                goto LABEL_138;
              }

              v97 += v98 + 1;
              if (v92 != -1444) {
                goto LABEL_128;
              }
            }
          }

          else
          {
LABEL_128:
          }

          unint64_t v99 = 257;
          goto LABEL_138;
        }
      }

      else
      {
        uint64_t v94 = (os_log_s *)mDNSLogCategory_Default_redacted;
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
        {
          int v95 = (_BYTE *)(v92 + 1188);
          if (v92 == -1444)
          {
LABEL_121:
            while (v95)
            {
              uint64_t v96 = *v95;
              if (!*v95)
              {
                unint64_t v99 = (unsigned __int16)((_WORD)v95 - (v92 + 1188) + 1);
                goto LABEL_138;
              }

              v95 += v96 + 1;
              if (v92 != -1444) {
                goto LABEL_120;
              }
            }
          }

          else
          {
LABEL_120:
          }

          unint64_t v99 = 257;
LABEL_138:
          int v100 = DNSTypeName(*(unsigned __int16 *)(v92 + 1154));
          *(_DWORD *)buf = 67110659;
          *(_DWORD *)&uint8_t buf[4] = v104;
          *(_WORD *)&buf[8] = 1024;
          *(_DWORD *)&buf[10] = v105;
          *(_WORD *)&buf[14] = 1024;
          *(_DWORD *)uint64_t v108 = v93;
          *(_WORD *)&v108[4] = 2160;
          *(void *)&v108[6] = 1752392040LL;
          uint64_t v109 = 1040;
          *(_DWORD *)uint64_t v110 = v99;
          *(_WORD *)&v110[4] = 2101;
          *(void *)&v110[6] = v92 + 1188;
          *(_WORD *)&v110[14] = 2082;
          *(void *)&v110[16] = v100;
          _os_log_impl( (void *)&_mh_execute_header,  v94,  OS_LOG_TYPE_DEFAULT,  "[R%u->Q%u->subQ%u] Stop getting the zone data - zone qname: %{sensitive, mask.hash, mdnsresponder:domain_nam e}.*P, zone qtype: %{public}s.",  buf,  0x38u);
        }
      }

      CancelGetZoneData(v12, *(_DWORD **)(v13 + 104));
      *(void *)(v13 + 104) = 0LL;
      goto LABEL_140;
    }

    if ((v66 & 1) != 0)
    {
      int v67 = (os_log_s *)mDNSLogCategory_Default_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_FAULT))
      {
        for (uint64_t k = (_BYTE *)(v13 + 356); ; k += v72 + 1)
        {
          if ((unint64_t)k >= v65 || !k || (int v72 = *k, v72 > 0x3F))
          {
            uint64_t v89 = 257;
            goto LABEL_143;
          }

          if (!*k) {
            break;
          }
        }

        uint64_t v89 = (unsigned __int16)((_WORD)k - (v13 + 356) + 1);
LABEL_143:
        char v101 = DNSTypeName(*(unsigned __int16 *)(v13 + 322));
        uint64_t v102 = LLQStateToString(*(unsigned __int8 *)(v13 + 330));
        *(_DWORD *)buf = 67110659;
        *(_DWORD *)&uint8_t buf[4] = v104;
        *(_WORD *)&buf[8] = 1024;
        *(_DWORD *)&buf[10] = v105;
        *(_WORD *)&buf[14] = 2160;
        *(void *)uint64_t v108 = 1752392040LL;
        *(_WORD *)&v108[8] = 1040;
        *(_DWORD *)&v108[10] = v89;
        uint64_t v109 = 2101;
        *(void *)uint64_t v110 = v13 + 356;
        *(_WORD *)&v110[8] = 2082;
        *(void *)&v110[10] = v101;
        *(_WORD *)&v110[18] = 2082;
        *(void *)&v110[20] = v102;
        _os_log_impl( (void *)&_mh_execute_header,  v67,  OS_LOG_TYPE_FAULT,  "[R%u->Q%u] Not starting long-lived query polling since the question has been stopped - qname: %{sensitive, mas k.hash, mdnsresponder:domain_name}.*P, qtype: %{public}s, LLQ_State: %{public}s.",  buf,  0x3Cu);
      }
    }

    else if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_FAULT))
    {
      for (uint64_t m = (_BYTE *)(v13 + 356); ; m += v78 + 1)
      {
        if ((unint64_t)m >= v65 || !m || (uint64_t v78 = *m, v78 > 0x3F))
        {
          uint64_t v89 = 257;
          goto LABEL_143;
        }

        if (!*m) {
          break;
        }
      }

      uint64_t v89 = (unsigned __int16)((_WORD)m - (v13 + 356) + 1);
      goto LABEL_143;
    }

LABEL_2221:
      v1298 = (os_log_s *)v1290;
      uint32_t v1299 = 8;
      goto LABEL_2250;
    }

    *(_DWORD *)&v1504[0].sa_leuint64_t n = 0;
    int v10 = 4;
    ssize_t v11 = recv(*(_DWORD *)(v8 + 168), v1504, 4uLL, 0);
    if (v11)
    {
      if ((v11 & 0x8000000000000000LL) == 0)
      {
        uint64_t v12 = mDNSLogCategory_Default;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
        {
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_ERROR))
          {
LABEL_32:
            int v29 = *(_DWORD *)(v8 + 184);
            v1489.dev_t st_dev = 67109120;
            *(_DWORD *)&v1489.st_mode = v29;
            int v25 = (sockaddr *)&v1489;
            uint64_t v26 = (os_log_s *)v12;
            os_log_type_t v27 = OS_LOG_TYPE_ERROR;
            __int128 v28 = "[R%u] ERROR: read data from a completed request";
            goto LABEL_33;
          }
        }

        else
        {
          uint64_t v12 = mDNSLogCategory_Default_redacted;
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_ERROR)) {
            goto LABEL_32;
          }
        }

LABEL_35:
        int v10 = 3;
        goto LABEL_36;
      }

      goto LABEL_28;
    }

          if (++v30 == v16)
          {
            free(values);
            free(v29);
            a3 = v83;
            int v24 = theDict;
            goto LABEL_40;
          }
        }

        unint64_t v33 = v32;
        if (mDNS_LoggingEnabled == 1 && !CFStringGetCString(v32, buffer, 256LL, 0x8000100u)) {
          buffer[0] = 0;
        }
        __int128 v34 = v75;
        uint64_t v35 = (CFTypeRef *)values;
        cf = v33;
        while (1)
        {
          if (!CFStringHasSuffix(*v29, kSCEntNetInterface)) {
            goto LABEL_33;
          }
          TypeID = CFDictionaryGetTypeID();
          if (TypeID != CFGetTypeID(*v35)) {
            goto LABEL_33;
          }
          Value = CFDictionaryGetValue((CFDictionaryRef)*v35, kSCPropNetInterfaceDeviceName);
          if (!Value) {
            goto LABEL_33;
          }
          if (!CFEqual(v33, Value)) {
            goto LABEL_33;
          }
          uint64_t v38 = (const __CFString *)CopyNameFromKey(*v29);
          if (!v38) {
            goto LABEL_33;
          }
          int v39 = v38;
          int v40 = v19;
          int v41 = SCDynamicStoreKeyCreateNetworkServiceEntity(0LL, v19, v38, kSCEntNetIPv4);
          CFRelease(v39);
          if (!v41) {
            break;
          }
          uint64_t v42 = CFDictionaryGetValue(theDict, v41);
          CFRelease(v41);
          if (!v42) {
            break;
          }
          int v43 = CFDictionaryGetTypeID();
          if (v43 != CFGetTypeID(v42)) {
            break;
          }
          uint64_t v44 = CFDictionaryGetValue((CFDictionaryRef)v42, kSCPropNetIPv4ConfigMethod);
          socklen_t v19 = v40;
          if (!v44) {
            goto LABEL_32;
          }
          int v45 = CFEqual(v44, kSCValNetIPv4ConfigMethodLinkLocal);
          unint64_t v46 = v81;
          if (v45) {
            unint64_t v46 = v81 + 1;
          }
          int v81 = v46;
          unint64_t v33 = cf;
          if (v45)
          {
LABEL_34:
            CFRelease(v33);
            int v29 = v73;
            int8x16_t v16 = v74;
            goto LABEL_35;
          }

  *(void *)(*(void *)(a1[4] + 8LL) + 24LL) = v18;
  if (*(void *)(*(void *)(a1[4] + 8LL) + 24LL))
  {
    unint64_t v20 = *(dispatch_source_s **)(a1[6] + 96LL);
    if (v20) {
      dispatch_source_merge_data(v20, 1uLL);
    }
  }

      ssize_t v11 = v9;
    }

    else
    {
      ssize_t v11 = 0;
    }

    goto LABEL_36;
  }

  if (os_log_type_enabled((os_log_t)mDNSLogCategory_uDNS, OS_LOG_TYPE_DEFAULT))
  {
    if (a1)
    {
      int v4 = a1;
      if (a1 == (_BYTE *)-256LL) {
        goto LABEL_12;
      }
LABEL_9:
      unint64_t v5 = 257;
      if (v4 < a1 + 256 && v4)
      {
        while (1)
        {
          int v6 = *v4;
          if (v6 > 0x3F)
          {
LABEL_30:
            unint64_t v5 = 257;
            goto LABEL_33;
          }

          if (!*v4) {
            break;
          }
          v4 += v6 + 1;
          if (a1 != (_BYTE *)-256LL) {
            goto LABEL_9;
          }
LABEL_12:
          if (!v4) {
            goto LABEL_30;
          }
        }

        unint64_t v5 = (_WORD)v4 - (_WORD)a1 + 1;
      }

      ssize_t v11 = 0;
    }

    int v10 = *(void *)v10;
  }

  while (v10);
  if (v11) {
    return LogToFD(v8, "<None>", a3, (uint64_t)a4, a5, a6, a7, a8, v29);
  }
  return result;
}

  for (int j = *(int8x8_t **)(a4 + 32); j; int j = (int8x8_t *)j[7])
  {
    if (j[31].i8[3]) {
      _mdns_querier_handle_stream_termination(j, v13);
    }
  }

          (*(void (**)(uint64_t, void, void, void *, void, void *, uint64_t, uint64_t, uint64_t, void *, void *, uint64_t, uint64_t, uint64_t))(**(void **)(a3 + 72) + 984LL))( a3,  *(void *)(a3 + 88),  *(void *)(a3 + 88) + *(unsigned __int16 *)(a3 + 96),  v78,  v42,  v77,  13568LL,  v41,  a3,  v46,  v47,  v48,  v49,  v50);
          return;
        }

        if (v86[0].sa_family == 2)
        {
          LODWORD(v78[0]) = 4;
          HIDWORD(v78[0]) = *(_DWORD *)&v86[0].sa_data[2];
          uint64_t v42 = *(unsigned __int16 *)v86[0].sa_data;
          LODWORD(v77[0]) = 4;
          HIDWORD(v77[0]) = *(_DWORD *)&v79[0].sa_data[2];
          if ((mDNS_LoggingEnabled & 1) != 0)
          {
            int v43 = "ProxyTCPReceive received IPv4 packet(len %d) from %#-15a to %#-15a on skt %d %s ifindex %d";
LABEL_34:
            int v49 = 0LL;
            uint64_t v50 = SHIDWORD(v54);
            int v47 = v77;
            int v48 = a1;
            unint64_t v46 = v78;
            LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  v43,  v21,  v22,  v23,  v24,  v25,  *(unsigned __int16 *)(a3 + 96));
            goto LABEL_35;
          }

          goto LABEL_35;
        }

        LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "ProxyTCPReceive from is unknown address family %d",  v21,  v22,  v23,  v24,  v25,  v86[0].sa_family);
        goto LABEL_26;
      }

      __int128 v34 = (os_log_s *)mDNSLogCategory_Default;
      int v45 = a1;
      __error();
      int v40 = "ProxyTCPReceive: getpeername(fd=%d) errno %d";
    }

    LogMsgWithLevel(v34, OS_LOG_TYPE_DEFAULT, v40, v35, v36, v37, v38, v39, v45);
LABEL_26:
    mDNSPlatformDisposeProxyContext((_DWORD *)a3);
  }

LABEL_36:
    *(_BYTE *)(v8 + 275) = v10;
LABEL_116:
    if (v10 == 2)
    {
LABEL_117:
      int v72 = *(_DWORD *)(v8 + 212);
      int v73 = 4;
      switch(v72)
      {
        case 1:
          goto LABEL_122;
        case 2:
          int v73 = 19;
          goto LABEL_132;
        case 3:
        case 19:
          goto LABEL_132;
        case 4:
          int v73 = 8;
          goto LABEL_132;
        case 5:
          int v73 = 16;
          goto LABEL_132;
        case 6:
        case 11:
          int v73 = 10;
          goto LABEL_132;
        case 7:
        case 18:
          int v73 = 11;
          goto LABEL_132;
        case 8:
        case 15:
          int v73 = 13;
          goto LABEL_132;
        case 9:
          int v73 = 15;
          goto LABEL_132;
        case 10:
          int v73 = 12;
          goto LABEL_132;
        case 12:
          int v73 = 5;
          goto LABEL_132;
        case 13:
          int v73 = 2;
          goto LABEL_132;
        case 14:
          int v73 = 20;
          goto LABEL_132;
        case 16:
        case 17:
          goto LABEL_123;
        default:
          if (v72 == 63)
          {
LABEL_122:
            int v73 = 0;
          }

          else
          {
LABEL_123:
            v1314 = (sockaddr *)*(unsigned int *)(v8 + 172);
            unint64_t v1315 = v8 + 240;
            LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "request_callback: ERROR: validate_message - unsupported req type: %d PID[%d][%s]",  a4,  a5,  a6,  a7,  a8,  v72);
            int v73 = -1;
          }

          int v25 = *(_DWORD *)(a1[1] + 4LL);
          *(_DWORD *)buf = 141558787;
          int v31 = 1752392040LL;
          uint64_t v32 = 1040;
          unint64_t v33 = v24;
          __int128 v34 = 2101;
          uint64_t v35 = v18;
          uint64_t v36 = 1024;
          int v37 = v25;
          _os_log_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_ERROR,  "AddTSRRDataToMessage: TSR can't be written -- name %{sensitive, mask.hash, mdnsresponder:domain_name}.*P hashkey %x",  buf,  0x22u);
        }
      }

      else
      {
        int8x16_t v16 = (os_log_s *)mDNSLogCategory_mDNS_redacted;
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_ERROR))
        {
          uid_t v18 = a1[2];
          if (v18)
          {
            ssize_t v22 = (_BYTE *)a1[2];
            if (v18 == -256)
            {
LABEL_24:
              while (v22)
              {
                uint64_t v23 = *v22;
                if (!*v22)
                {
                  int v24 = (unsigned __int16)((_WORD)v22 - v18 + 1);
                  goto LABEL_36;
                }

                v22 += v23 + 1;
                if (v18 != -256) {
                  goto LABEL_23;
                }
              }
            }

            else
            {
LABEL_23:
            }

            int v24 = 257;
          }

          else
          {
            int v24 = 0;
          }

          goto LABEL_36;
        }
      }

      return 0LL;
    }
  }

  if (v14 == __dst) {
    return __dst;
  }
  *a3 = bswap32((_DWORD)v14 - (_DWORD)__dst + v13) >> 16;
  return v14;
}

    uint64_t v12 = i;
LABEL_37:
    uint64_t i = v12;
  }

  if (a3) {
    a3(mDNSStorage, a4);
  }
  if (i)
  {
    do
    {
      int v47 = *(void *)(i + 8);
      *(void *)(i + 8) = 0LL;
      if (mDNS_LoggingEnabled == 1)
      {
        int v48 = (os_log_s *)mDNSLogCategory_Default;
        DNSTypeName(*(unsigned __int16 *)(i + 322));
        LogMsgWithLevel( v48,  OS_LOG_TYPE_DEFAULT,  "mDNSCoreRestartAddressQueries: Start question %p %##s (%s)",  v49,  v50,  v51,  v52,  v53,  i);
      }

      mDNS_StartQuery_internal((uint64_t)mDNSStorage, i);
      uint64_t i = v47;
    }

    while (v47);
  }

  socklen_t v19 = (os_log_s *)mDNSLogCategory_Default;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
  {
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
LABEL_45:
      _os_log_impl( (void *)&_mh_execute_header,  v19,  OS_LOG_TYPE_DEFAULT,  "mDNS_StartExit: Deregistering duplicate resource records",  buf,  2u);
    }
  }

  else
  {
    socklen_t v19 = (os_log_s *)mDNSLogCategory_Default_redacted;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      goto LABEL_45;
    }
  }

  DeregLoop(*((uint64_t *)&xmmword_10015BD08 + 1));
  ssize_t v22 = (os_log_s *)mDNSLogCategory_Default;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
  {
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_53;
    }
    *(_WORD *)buf = 0;
  }

  else
  {
    ssize_t v22 = (os_log_s *)mDNSLogCategory_Default_redacted;
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_53;
    }
    *(_WORD *)buf = 0;
  }

  _os_log_impl( (void *)&_mh_execute_header,  v22,  OS_LOG_TYPE_DEFAULT,  "mDNS_StartExit: Deregistering resource records",  buf,  2u);
LABEL_53:
  DeregLoop(xmmword_10015BD08);
  if (dword_100158C1C - dword_100158BF8 <= 999)
  {
    dword_100158C1C = dword_100158BF8;
    HIDWORD(qword_100158C08) = 0;
  }

  uint64_t v23 = gSensitiveLoggingEnabled;
  int v24 = (os_log_s *)mDNSLogCategory_Default;
  if (mDNSLogCategory_Default == mDNSLogCategory_State) {
    uint64_t v23 = 0;
  }
  if ((void)xmmword_10015BD08)
  {
    if ((v23 & 1) != 0)
    {
      int v24 = (os_log_s *)mDNSLogCategory_Default_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_69;
      }
      *(_WORD *)buf = 0;
      int v25 = "mDNS_StartExit: Sending final record deregistrations";
    }

    else
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_69;
      }
      *(_WORD *)buf = 0;
      int v25 = "mDNS_StartExit: Sending final record deregistrations";
    }
  }

  else if ((v23 & 1) != 0)
  {
    int v24 = (os_log_s *)mDNSLogCategory_Default_redacted;
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_69;
    }
    *(_WORD *)buf = 0;
    int v25 = "mDNS_StartExit: No deregistering records remain";
  }

  else
  {
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_69;
    }
    *(_WORD *)buf = 0;
    int v25 = "mDNS_StartExit: No deregistering records remain";
  }

  _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, v25, buf, 2u);
LABEL_69:
  uint64_t v26 = (unsigned __int8 *)*((void *)&xmmword_10015BD08 + 1);
  if (*((void *)&xmmword_10015BD08 + 1))
  {
    while (1)
    {
      os_log_type_t v27 = (os_log_s *)mDNSLogCategory_Default;
      if (gSensitiveLoggingEnabled == 1 && mDNSLogCategory_Default != mDNSLogCategory_State) {
        break;
      }
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_78;
      }
LABEL_79:
      uint64_t v26 = *(unsigned __int8 **)v26;
      if (!v26) {
        goto LABEL_80;
      }
    }

    os_log_type_t v27 = (os_log_s *)mDNSLogCategory_Default_redacted;
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_79;
    }
LABEL_78:
    uint32_t v30 = v26[8];
    GetRRDisplayString_rdb(v26 + 8, (unsigned __int16 *)(*((void *)v26 + 6) + 4LL), word_100164338);
    *(_DWORD *)buf = 67109635;
    *(_DWORD *)unint64_t v33 = v30;
    *(_WORD *)&v33[4] = 2160;
    *(void *)&v33[6] = 1752392040LL;
    *(_WORD *)&v33[14] = 2085;
    *(void *)&v33[16] = word_100164338;
    _os_log_impl( (void *)&_mh_execute_header,  v27,  OS_LOG_TYPE_DEFAULT,  "mDNS_StartExit: Should not still have Duplicate Records remaining: %02X %{sensitive, mask.hash}s",  buf,  0x1Cu);
    goto LABEL_79;
  }

    int v40 = 141558531;
    int v41 = 1752392040LL;
    uint64_t v42 = 1040;
    int v43 = v11;
    uint64_t v44 = 2101;
    int v45 = a1;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "mDNS_RemoveDynDNSHostName %{sensitive, mask.hash, mdnsresponder:domain_name}.*P",  (uint8_t *)&v40,  0x1Cu);
  }

  if (v6)
  {
    uint32_t v30 = (char *)(*(void *)(a3 + 40) + 4LL);
    if (a4) {
      AddAutoBrowseDomain(0, v30);
    }
    else {
      RmvAutoBrowseDomain(0, v30, v15, v16, v17, v18, v19, v20);
    }
  }

    uint64_t v32 = *(void *)v32;
    if (!v32) {
      goto LABEL_37;
    }
  }

  unint64_t v33 = *(_DWORD **)(v32 + 48);
  if (v33[1] != *(_DWORD *)(a2 + 8)
    || v33[2] != *(_DWORD *)(a2 + 12)
    || v33[3] != *(_DWORD *)(a2 + 16)
    || v33[4] != *(_DWORD *)(a2 + 20)
    || v20 != *(void *)(v32 + 32))
  {
    goto LABEL_36;
  }

  if (mDNS_LoggingEnabled == 1) {
    LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "mDNSMacOSXCreateEtcHostsEntry: Same IPv6 address and InterfaceID for name %##s ID %d",  v27,  v28,  v29,  v30,  v31,  (int)a1);
  }
  return 0LL;
}

  __break(1u);
  return result;
}

  if ((v33 & 1) == 0) {
    return 0LL;
  }
  uint64_t v35 = calloc(1uLL, 0x2F8uLL);
  if (!v35) {
    goto LABEL_42;
  }
  *(void *)(a1 + 16) = v35;
  *(_WORD *)&uint8_t buf[16] = 1;
  RecordOpStart = QueryRecordOpStart((uint64_t)v35, (uint64_t)buf, a3, a4);
  if ((_DWORD)RecordOpStart) {
    goto LABEL_40;
  }
  return RecordOpStart;
}

LABEL_132:
          uint64_t v74 = *(void *)(v8 + 56);
          if (v73 > (int)v74)
          {
            LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "request_callback: Invalid message %d bytes; min for %d is %d PID[%d][%s]",
              a4,
              a5,
              a6,
              a7,
              a8,
              v74);
          }

          else
          {
            unsigned int v75 = *(_DWORD *)(v8 + 212);
            if (v75 > 0x3F || ((1LL << v75) & 0x8000000000000C0CLL) == 0)
            {
              if (!*(void *)(v8 + 96)) {
                goto LABEL_138;
              }
              goto LABEL_136;
            }

            if (*(void *)(v8 + 96))
            {
LABEL_136:
              if (v75 > 0x3F || ((1LL << v75) & 0x8000000000000C0CLL) == 0)
              {
                uint64_t v86 = (char *)calloc(1uLL, 0x118uLL);
                if (!v86) {
                  goto LABEL_2255;
                }
                uint64_t v76 = (uint64_t)v86;
                ssize_t v87 = &all_requests;
                do
                {
                  __int32 v88 = v87;
                  uint64_t v89 = *v87;
                  ssize_t v87 = (uint64_t *)(*v87 + 16);
                }

                while (v89);
                *__int32 v88 = (uint64_t)v86;
                *((void *)v86 + 3) = v8;
                *((_DWORD *)v86 + 42) = *(_DWORD *)(v8 + 168);
                *((void *)v86 + 22) = *(void *)(v8 + 176);
                __int128 v90 = *(_OWORD *)(v8 + 200);
                *(_OWORD *)(v86 + 212) = *(_OWORD *)(v8 + 212);
                *(_OWORD *)(v86 + 200) = v90;
                *((_OWORD *)v86 + 4) = *(_OWORD *)(v8 + 64);
                *((void *)v86 + 10) = *(void *)(v8 + 80);
                do
                  unsigned int v91 = __ldaxr(&dnssd_server_get_new_request_id_s_next_id);
                while (__stlxr(v91 + 1, &dnssd_server_get_new_request_id_s_next_id));
                *((_DWORD *)v86 + 47) = 0;
                *((_DWORD *)v86 + 48) = 0;
                *((_DWORD *)v86 + 46) = v91;
                int v92 = *(void **)(v8 + 32);
                if (v92) {
                  os_retain(v92);
                }
                BOOL v93 = *(void **)(v76 + 32);
                if (v93) {
                  os_release(v93);
                }
                *(void *)(v76 + 32) = *(void *)(v8 + 32);
                if (*(_BYTE *)(v8 + 272))
                {
                  *(_BYTE *)(v76 + 272) = 1;
                  *(_OWORD *)(v76 + 256) = *(_OWORD *)(v8 + 256);
                }

                else
                {
                  int v97 = *(_DWORD *)(v8 + 172);
                  if (v97)
                  {
                    *(_DWORD *)(v76 + 172) = v97;
                    uint64_t v98 = 240LL;
                    unint64_t v99 = 16LL;
                    while (1)
                    {
                      int v100 = *(unsigned __int8 *)(v8 + v98);
                      *(_BYTE *)(v76 + v98) = v100;
                      if (!v100) {
                        break;
                      }
                      --v99;
                      ++v98;
                      if (v99 <= 1)
                      {
                        *(_BYTE *)(v76 + v98) = 0;
                        break;
                      }
                    }
                  }

                  else
                  {
                    set_peer_pid(v76);
                  }
                }

    int v65 = v63;
  }

  else
  {
    int v65 = 0;
  }

  goto LABEL_133;
}

                  int8x16_t v16 = (void *)a10;
                  uint64_t v23 = v858;
LABEL_135:
                  ++v57;
                  int v58 = Answers;
                  char v80 = v57 >= *((unsigned __int16 *)a2 + 2) || Answers == 0LL || (unint64_t)Answers >= a3;
                  if (!v80) {
                    continue;
                  }
                  LODWORD(v25) = IsDNSMulticast;
                  BOOL v53 = v882;
                  ssize_t v22 = v906;
                  if (!v871) {
                    goto LABEL_74;
                  }
                  int v81 = (os_log_s *)mDNSLogCategory_Default;
                  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
                  {
                    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
                      return;
                    }
                    uint64_t v83 = bswap32(*(unsigned __int16 *)a2) >> 16;
                    __int128 v84 = *((unsigned __int16 *)a2 + 3);
                    uint64_t v85 = "s,";
                    uint64_t v86 = *((unsigned __int16 *)a2 + 4);
                    ssize_t v87 = *((unsigned __int16 *)a2 + 5);
                    *(_DWORD *)unsigned __int16 v961 = 67110658;
                    if (v84 == 1) {
                      uint64_t v85 = ", ";
                    }
                    *(_DWORD *)&v961[4] = v83;
                    *(_WORD *)&v961[8] = 1024;
                    if (v86 == 1) {
                      __int32 v88 = "y,  ";
                    }
                    else {
                      __int32 v88 = "ies,";
                    }
                    *(_DWORD *)&v961[10] = v84;
                    uint64_t v89 = "s";
                    *(_WORD *)&v961[14] = 2082;
                    *(void *)&v961[16] = v85;
                    if (v87 == 1) {
                      uint64_t v89 = "";
                    }
                  }

                  else
                  {
                    int v81 = (os_log_s *)mDNSLogCategory_Default_redacted;
                    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
                      return;
                    }
                    uint64_t v391 = bswap32(*(unsigned __int16 *)a2) >> 16;
                    uint64_t v392 = *((unsigned __int16 *)a2 + 3);
                    char v393 = "s,";
                    uint64_t v86 = *((unsigned __int16 *)a2 + 4);
                    ssize_t v87 = *((unsigned __int16 *)a2 + 5);
                    *(_DWORD *)unsigned __int16 v961 = 67110658;
                    if (v392 == 1) {
                      char v393 = ", ";
                    }
                    *(_DWORD *)&v961[4] = v391;
                    *(_WORD *)&v961[8] = 1024;
                    if (v86 == 1) {
                      __int32 v88 = "y,  ";
                    }
                    else {
                      __int32 v88 = "ies,";
                    }
                    *(_DWORD *)&v961[10] = v392;
                    uint64_t v89 = "s";
                    *(_WORD *)&v961[14] = 2082;
                    *(void *)&v961[16] = v393;
                    if (v87 == 1) {
                      uint64_t v89 = "";
                    }
                  }

                  *(_WORD *)&v961[24] = 1024;
                  *(_DWORD *)&v961[26] = v86;
                  *(_WORD *)&v961[30] = 2082;
                  *(void *)&v961[32] = v88;
                  *(_WORD *)&v961[40] = 1024;
                  *(_DWORD *)&v961[42] = v87;
                  *(_WORD *)&v961[46] = 2082;
                  *(void *)&v961[48] = v89;
                  _os_log_impl( (void *)&_mh_execute_header,  v81,  OS_LOG_TYPE_DEFAULT,  "[Q%d] Ignoring %2d Answer%{public}s %2d Authorit%{public}s %2d Additional%{public}s",  v961,  0x38u);
                  return;
                }
              }

              else
              {
                uint64_t v871 = 1;
              }
            }

            break;
          }

          int8x16_t v16 = (void *)a10;
          goto LABEL_135;
        }

      uint64_t v56 = (os_log_s *)v60;
      int v57 = 12;
LABEL_133:
      _os_log_impl((void *)&_mh_execute_header, v56, OS_LOG_TYPE_DEFAULT, v21, (uint8_t *)&v82, v57);
LABEL_134:
      UpdateDebugState(v13, v14, v15, v16, v17, v18, v19, v20, v82);
      goto LABEL_145;
    default:
      if (v11 == 2)
      {
LABEL_12:
        uint64_t v23 = (os_log_s *)mDNSLogCategory_Default;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
        {
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
          {
            int v82 = 136446210;
            uint64_t v83 = "mDNSResponder mDNSResponder-2559.60.39.0.1 (Nov 10 2024 02:11:03)";
LABEL_62:
            _os_log_impl( (void *)&_mh_execute_header,  v23,  OS_LOG_TYPE_DEFAULT,  "%{public}s stopping",  (uint8_t *)&v82,  0xCu);
          }
        }

        else
        {
          uint64_t v23 = (os_log_s *)mDNSLogCategory_Default_redacted;
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
          {
            int v82 = 136446210;
            uint64_t v83 = "mDNSResponder mDNSResponder-2559.60.39.0.1 (Nov 10 2024 02:11:03)";
            goto LABEL_62;
          }
        }

        while (all_requests)
          AbortUnlinkAndFree((void *)all_requests);
        for (uint64_t i = (uint64_t *)LocalDomainEnumRecords; LocalDomainEnumRecords; uint64_t i = (uint64_t *)LocalDomainEnumRecords)
        {
          LocalDomainEnumRecords = *i;
          mDNS_Deregister((unsigned int *)mDNSStorage, (uint64_t)(i + 1));
        }

        if ((listenfd & 0x80000000) == 0)
        {
          close(listenfd);
          unlink("/var/run/mDNSResponder");
        }

        mDNS_StartExit();
        goto LABEL_145;
      }

      if (v11 != 1)
      {
LABEL_19:
        int v25 = mDNSLogCategory_Default;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
        {
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_145;
          }
          int v82 = 67109120;
          LODWORD(v83) = v11;
          os_log_type_t v27 = "SignalCallback: Unknown signal %d";
        }

        else
        {
          int v25 = mDNSLogCategory_Default_redacted;
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_145;
          }
          int v82 = 67109120;
          LODWORD(v83) = v11;
          os_log_type_t v27 = "SignalCallback: Unknown signal %d";
        }

        uint64_t v54 = (os_log_s *)v25;
        uint32_t v55 = 8;
        goto LABEL_127;
      }

      ssize_t v22 = (os_log_s *)mDNSLogCategory_Default;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_138;
        }
        LOWORD(v82) = 0;
      }

      else
      {
        ssize_t v22 = (os_log_s *)mDNSLogCategory_Default_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_138;
        }
        LOWORD(v82) = 0;
      }

      _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "SIGHUP: Purge cache", (uint8_t *)&v82, 2u);
LABEL_138:
      mDNS_Lock_((unsigned int *)mDNSStorage, (uint64_t)"SignalCallback", 638);
      for (int j = 0LL; j != 499; ++j)
      {
        for (uint64_t k = (void *)mDNSStorage[j + 35]; k; uint64_t k = (void *)*k)
        {
          for (uint64_t m = (void *)k[2]; m; uint64_t m = (void *)*m)
            mDNS_PurgeCacheResourceRecord((unsigned int *)mDNSStorage, (uint64_t)m);
        }
      }

      mDNSCoreRestartQueries((uint64_t)mDNSStorage);
      mDNS_Unlock_((uint64_t)mDNSStorage, (uint64_t)"SignalCallback", 645);
LABEL_145:
      KQueueUnlock((uint64_t)"Unix Signal", v47, v48, v49, v50, v51, v52, v53);
      return;
  }

LABEL_139:
                if ((*(_BYTE *)(v76 + 208) & 1) != 0) {
                  *(_BYTE *)(v76 + 276) = 1;
                }
                if (dword_100158C04)
                {
                  int v77 = *(_DWORD *)(v76 + 212);
                  if (v77 != 63 && v77 != 13)
                  {
                    int updated = -65563;
                    goto LABEL_1122;
                  }
                }

                if (*(void *)(v76 + 32)) {
                  goto LABEL_148;
                }
                int v81 = *(_DWORD *)(v76 + 168);
                memset(&v1489, 0, 32);
                __src[0] = 32;
                if (getsockopt(v81, 0, 6, &v1489, __src))
                {
                  if (*__error())
                  {
                    int v82 = *__error();
                    if (!v82) {
                      goto LABEL_156;
                    }
                  }

                  else
                  {
                    int v82 = -6700;
                  }

                  uint64_t v94 = (os_log_s *)mDNSLogCategory_Default;
                  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
                  {
                    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_ERROR)) {
                      goto LABEL_148;
                    }
                  }

                  else
                  {
                    uint64_t v94 = (os_log_s *)mDNSLogCategory_Default_redacted;
                    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_ERROR)) {
                      goto LABEL_148;
                    }
                  }

                  int v95 = *(_DWORD *)(v76 + 184);
                  uint64_t v96 = *(int *)(v76 + 172);
                  v1489.dev_t st_dev = 67109890;
                  *(_DWORD *)&v1489.st_mode = v95;
                  LOWORD(v1489.st_ino) = 2048;
                  *(__darwin_ino64_t *)((char *)&v1489.st_ino + 2) = v82;
                  HIWORD(v1489.st_uid) = 2048;
                  *(void *)&v1489.st_gid = v96;
                  *((_WORD *)&v1489.st_rdev + 2) = 2082;
                  *(void *)((char *)&v1489.st_rdev + 6) = v76 + 240;
                  _os_log_impl( (void *)&_mh_execute_header,  v94,  OS_LOG_TYPE_ERROR,  "[R%u] Failed to get peer audit token -- error: %ld, client pid: %lld (%{public}s)",  (uint8_t *)&v1489,  0x26u);
                  goto LABEL_148;
                }

  if (v21) {
    free(v21);
  }
LABEL_141:
  if (a3 == -65792) {
    goto LABEL_148;
  }
  reply = create_reply((char *)0x45, 12LL, (uint64_t)v12, a4, a5, a6, a7, a8);
  *((void *)reply + 4) = *(void *)(v11 + 40);
  *((_DWORD *)reply + 11) = 0;
  *((_DWORD *)reply + 12) = bswap32( mDNSPlatformInterfaceIndexfromInterfaceID( (uint64_t **)a1,  *(void *)(a2 + 32),  0LL,  v111,  v112,  v113,  v114,  v115));
  *((_DWORD *)reply + 13) = bswap32(a3);
  append_reply((uint64_t)v12, reply);
  if (!a3)
  {
    if (!*(_BYTE *)(v11 + 60)) {
      goto LABEL_180;
    }
    unint64_t v130 = (os_log_s *)mDNSLogCategory_mDNS;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_180;
      }
      uint64_t v135 = v12[46];
      *(_DWORD *)buf = 67109120;
      *(_DWORD *)uid_t v162 = v135;
    }

    else
    {
      unint64_t v130 = (os_log_s *)mDNSLogCategory_mDNS_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_180;
      }
      unsigned int v131 = v12[46];
      *(_DWORD *)buf = 67109120;
      *(_DWORD *)uid_t v162 = v131;
    }

    _os_log_impl( (void *)&_mh_execute_header,  v130,  OS_LOG_TYPE_DEFAULT,  "[R%u] regrecord_callback: external_advertise already set!",  buf,  8u);
LABEL_180:
    if (!callExternalHelpers( *(void *)(v11 + 32),  (_BYTE *)(a2 + 652),  v12[58],  v116,  v117,  v118,  v119,  v120)) {
      return;
    }
    uint64_t v136 = (os_log_s *)mDNSLogCategory_mDNS;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v138 = v12[46];
        *(_DWORD *)buf = 67109120;
        *(_DWORD *)uid_t v162 = v138;
        goto LABEL_187;
      }
    }

    else
    {
      uint64_t v136 = (os_log_s *)mDNSLogCategory_mDNS_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v137 = v12[46];
        *(_DWORD *)buf = 67109120;
        *(_DWORD *)uid_t v162 = v137;
LABEL_187:
        _os_log_impl( (void *)&_mh_execute_header,  v136,  OS_LOG_TYPE_DEFAULT,  "[R%u] regrecord_callback: calling external_start_advertising_service",  buf,  8u);
      }
    }

    internal_start_advertising_service(a2 + 8, v12[58], v12[43]);
    *(_BYTE *)(v11 + 60) = 1;
    return;
  }

  if (a3 == -65542)
  {
    uint64_t v121 = mDNSLogCategory_mDNS;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v134 = v12[46];
        *(_DWORD *)buf = 67109120;
        *(_DWORD *)uid_t v162 = v134;
        unint64_t v33 = "[R%u] regrecord_callback: Callback with error code mStatus_BadStateErr - not freeing the record.";
        goto LABEL_175;
      }
    }

    else
    {
      uint64_t v121 = mDNSLogCategory_mDNS_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
      {
        int v122 = v12[46];
        *(_DWORD *)buf = 67109120;
        *(_DWORD *)uid_t v162 = v122;
        unint64_t v33 = "[R%u] regrecord_callback: Callback with error code mStatus_BadStateErr - not freeing the record.";
LABEL_175:
        __int128 v34 = (os_log_s *)v121;
        uint64_t v35 = 8;
        goto LABEL_176;
      }
    }

    return;
  }

LABEL_156:
                v1504[0] = *(sockaddr *)&v1489.st_dev;
                v1504[1] = *(sockaddr *)&v1489.st_uid;
                uint64_t v83 = mdns_audit_token_create(v1504);
                *(void *)(v76 + 32) = v83;
                if (!v83)
                {
                  __int128 v84 = (os_log_s *)mDNSLogCategory_Default;
                  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
                  {
                    if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_FAULT))
                    {
LABEL_423:
                      int v284 = *(_DWORD *)(v76 + 184);
                      __darwin_ino64_t v285 = *(int *)(v76 + 172);
                      v1489.dev_t st_dev = 67109634;
                      *(_DWORD *)&v1489.st_mode = v284;
                      LOWORD(v1489.st_ino) = 2048;
                      *(__darwin_ino64_t *)((char *)&v1489.st_ino + 2) = v285;
                      HIWORD(v1489.st_uid) = 2082;
                      *(void *)&v1489.st_gid = v76 + 240;
                      _os_log_impl( (void *)&_mh_execute_header,  v84,  OS_LOG_TYPE_FAULT,  "[R%u] Failed to create peer audit token -- client pid: %lld (%{public}s)",  (uint8_t *)&v1489,  0x1Cu);
                    }
                  }

                  else
                  {
                    __int128 v84 = (os_log_s *)mDNSLogCategory_Default_redacted;
                    if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_FAULT)) {
                      goto LABEL_423;
                    }
                  }

                  int updated = -65539;
                  goto LABEL_1122;
                }

        *(_DWORD *)__tp = 134218755;
        *(void *)&__tp[4] = v9 - (void)v10;
        *(_WORD *)&__tp[12] = 2160;
        *(void *)&__tp[14] = 1752392040LL;
        unsigned int v75 = 1040;
        uint64_t v76 = v68;
        int v77 = 2101;
        uint64_t v78 = v66;
        _os_log_impl( (void *)&_mh_execute_header,  v64,  OS_LOG_TYPE_DEBUG,  "The mDNS message does not have enough space for the NSEC record, will add it to the next message (This is not an error message) -- remaining space: %ld, NSEC name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P",  __tp,  0x26u);
      }

      return 0LL;
    default:
      if (*(unsigned __int16 *)(a4 + 4) == 65323)
      {
        *(void *)__tp = 0LL;
        *(void *)&__tp[8] = 0LL;
        clock_gettime(_CLOCK_MONOTONIC_RAW, (timespec *)__tp);
        *(_DWORD *)int v10 = bswap32(*(_DWORD *)__tp - *(_DWORD *)v12);
        return v10 + 4;
      }

    __break(1u);
LABEL_157:
    if (_mdns_server_log_s_once != -1) {
      dispatch_once(&_mdns_server_log_s_once, &__block_literal_global_16);
    }
    unint64_t v143 = (os_log_s *)_mdns_server_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_server_log_s_log, OS_LOG_TYPE_ERROR))
    {
      unsigned int v144 = *(int *)(v6 + 76);
      *(_DWORD *)length = 134218498;
      *(void *)&length[4] = -65540LL;
      *(_WORD *)&length[12] = 2048;
      *(void *)&length[14] = v144;
      *(_WORD *)&length[22] = 2082;
      *(void *)&length[24] = v6 + 84;
      _os_log_error_impl( (void *)&_mh_execute_header,  v143,  OS_LOG_TYPE_ERROR,  "XPC session error -- error: %{mdns:err}ld, client pid: %lld (%{public}s)",  length,  0x20u);
    }

    goto LABEL_152;
  }

  int v4 = *(void *)(a1 + 32);
  if (object == &_xpc_error_connection_invalid)
  {
    __int32 v17 = &g_session_list;
    do
    {
      uid_t v18 = v17;
      socklen_t v19 = *v17;
      __int32 v17 = (uint64_t *)(*v17 + 16);
      if (v19) {
        unint64_t v20 = v19 == v4;
      }
      else {
        unint64_t v20 = 1;
      }
    }

    while (!v20);
    if (v19)
    {
      *uid_t v18 = *(void *)(v4 + 16);
      *(void *)(v4 + 16) = 0LL;
      _dx_release((char *)v4);
      int v4 = *(void *)(a1 + 32);
    }

    _dx_session_invalidate(v4);
    _dx_release(*(char **)(a1 + 32));
  }

  else
  {
    unint64_t v5 = *(void **)(v4 + 32);
    if (v5)
    {
      xpc_connection_cancel(*(xpc_connection_t *)(v4 + 32));
      xpc_release(v5);
      *(void *)(*(void *)(a1 + 32) + 32LL) = 0LL;
    }
  }

        int v40 = 141558531;
        int v41 = 1752392040LL;
        uint64_t v42 = 1040;
        int v43 = v36;
        uint64_t v44 = 2101;
        int v45 = a1;
        _os_log_impl( (void *)&_mh_execute_header,  v34,  OS_LOG_TYPE_DEFAULT,  "mDNS_RemoveDynDNSHostName removing v6 %{sensitive, mask.hash, mdnsresponder:domain_name}.*P",  (uint8_t *)&v40,  0x1Cu);
      }
    }

    mDNS_Deregister_internal((uint64_t)mDNSStorage, v33, 0);
    goto LABEL_101;
  }

  if (*((void *)v15 + 25))
  {
    mDNS_StopNATOperation_internal((uint64_t)mDNSStorage, (uint64_t)(v15 + 2));
    *((void *)v15 + 25) = 0LL;
  }

  free(v15);
LABEL_101:
  mDNS_VerifyLockState("Check Lock", 1, dword_100158BE8, dword_100158BEC, (uint64_t)"mDNS_RemoveDynDNSHostName", 2699);
  uint32_t v30 = dword_100158BF8;
  dword_10015BD4C = v30;
}

LABEL_839:
                    uint64_t v509 = v512;
                    int v318 = v511;
                    if (v511
                      && conflictWithCacheRecordsOrFlush( *((_DWORD *)rr_from_ipc_msg + 6),  (_BYTE *)rr_from_ipc_msg[5],  __src[0],  *(int *)buf))
                    {
                      v517 = (os_log_s *)mDNSLogCategory_mDNS;
                      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
                      {
                        if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
                        {
                          uint64_t v518 = rr_from_ipc_msg[5];
                          if (v518)
                          {
                            uint64_t v519 = (_BYTE *)rr_from_ipc_msg[5];
                            if (v518 == -256)
                            {
LABEL_1171:
                              while (v519)
                              {
                                uint64_t v705 = *v519;
                                if (!*v519)
                                {
                                  LOWORD(v519) = (_WORD)v519 - v518 + 1;
                                  goto LABEL_1729;
                                }

                                v519 += v705 + 1;
                                if (v518 != -256) {
                                  goto LABEL_1170;
                                }
                              }
                            }

                            else
                            {
LABEL_1170:
                            }

                            LOWORD(v519) = 257;
LABEL_1729:
                            LODWORD(v519) = (unsigned __int16)v519;
                          }

                          else
                          {
                            LODWORD(v519) = 0;
                          }

LABEL_1730:
                          uint64_t v991 = rr_from_ipc_msg[4];
                          v1489.dev_t st_dev = 141558787;
                          *(void *)&v1489.st_mode = 1752392040LL;
                          WORD2(v1489.st_ino) = 1040;
                          *(_DWORD *)((char *)&v1489.st_ino + 6) = (_DWORD)v519;
                          HIWORD(v1489.st_uid) = 2101;
                          *(void *)&v1489.st_gid = v518;
                          *((_WORD *)&v1489.st_rdev + 2) = 2048;
                          *(void *)((char *)&v1489.st_rdev + 6) = v991;
                          _os_log_impl( (void *)&_mh_execute_header,  v517,  OS_LOG_TYPE_DEFAULT,  "handle_regrecord_request: TSR Stale Data, record cache is newer %{sensitive, mask.hash, mdns responder:domain_name}.*P InterfaceID %p",  (uint8_t *)&v1489,  0x26u);
                        }
                      }

                      else
                      {
                        v517 = (os_log_s *)mDNSLogCategory_mDNS_redacted;
                        if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
                        {
                          uint64_t v518 = rr_from_ipc_msg[5];
                          if (v518)
                          {
                            uint64_t v519 = (_BYTE *)rr_from_ipc_msg[5];
                            if (v518 == -256)
                            {
LABEL_847:
                              while (v519)
                              {
                                uint64_t v520 = *v519;
                                if (!*v519)
                                {
                                  LOWORD(v519) = (_WORD)v519 - v518 + 1;
                                  goto LABEL_1727;
                                }

                                v519 += v520 + 1;
                                if (v518 != -256) {
                                  goto LABEL_846;
                                }
                              }
                            }

                            else
                            {
LABEL_846:
                            }

                            LOWORD(v519) = 257;
LABEL_1727:
                            LODWORD(v519) = (unsigned __int16)v519;
                          }

                          else
                          {
                            LODWORD(v519) = 0;
                          }

                          goto LABEL_1730;
                        }
                      }

                      free(rr_from_ipc_msg);
                      int updated = -65572;
                      goto LABEL_1122;
                    }

LABEL_852:
                    if (rr_from_ipc_msg[4] == -2LL
                      && !IsLocalDomain((_BYTE *)rr_from_ipc_msg[5])
                      && *((_WORD *)rr_from_ipc_msg + 7) == 1)
                    {
                      unsigned int v521 = *((unsigned __int16 *)rr_from_ipc_msg + 6);
                      if (v521 <= 0x1C && ((1 << v521) & 0x10000022) != 0)
                      {
                        free(rr_from_ipc_msg);
                        goto LABEL_1121;
                      }
                    }

                    v1392 = v509;
                    v522 = (__uint64_t *)calloc(1uLL, 0x40uLL);
                    if (!v522) {
                      goto LABEL_2255;
                    }
                    v523 = v522;
                    *((_DWORD *)v522 + 14) = *(_DWORD *)(v76 + 224);
                    v522[3] = (__uint64_t)rr_from_ipc_msg;
                    v522[5] = *(void *)(v76 + 216);
                    v522[2] = v76;
                    *((_BYTE *)v522 + 60) = 0;
                    rr_from_ipc_msg[13] = regrecord_callback;
                    rr_from_ipc_msg[14] = v522;
                    *((_BYTE *)rr_from_ipc_msg + 122) = (*(_DWORD *)(v76 + 232) & 0x400) != 0;
                    __uint64_t v524 = rr_from_ipc_msg[4];
                    v522[4] = v524;
                    if (v524 == -3LL) {
                      rr_from_ipc_msg[4] = 0LL;
                    }
                    if (!*((_DWORD *)rr_from_ipc_msg + 4)) {
                      *((_DWORD *)rr_from_ipc_msg + 4) = 4500;
                    }
                    BOOL shouldLogFullRequestInfo = _shouldLogFullRequestInfo((int *)(v76 + 188), (_DWORD *)(v76 + 192));
                    unsigned int v526 = (unsigned __int8 *)rr_from_ipc_msg[5];
                    char v527 = gSensitiveLoggingEnabled;
                    uint64_t v528 = mDNSLogCategory_mDNS;
                    if (mDNSLogCategory_mDNS == mDNSLogCategory_State) {
                      char v527 = 0;
                    }
                    if (shouldLogFullRequestInfo)
                    {
                      if (v526)
                      {
                        if ((v527 & 1) != 0)
                        {
                          uint64_t v529 = mDNSLogCategory_mDNS_redacted;
                          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
                            goto LABEL_1419;
                          }
                          uint64_t v530 = v526;
                          __uint64_t n = v529;
                          int v1359 = *(_DWORD *)(v76 + 184);
                          int v1348 = *((_DWORD *)v523 + 14);
                          if (v526 == (unsigned __int8 *)-256LL)
                          {
LABEL_871:
                            while (v530)
                            {
                              uint64_t v531 = *v530;
                              if (!*v530)
                              {
                                unsigned __int16 v733 = (_WORD)v530 - (_WORD)v526 + 1;
                                goto LABEL_1327;
                              }

                              v530 += v531 + 1;
                            }
                          }

                          else
                          {
LABEL_870:
                            if (v530 < v526 + 256) {
                              goto LABEL_871;
                            }
                          }

                          unsigned __int16 v733 = 257;
LABEL_1327:
                          dev_t v790 = v733;
                          int v791 = *((unsigned __int16 *)rr_from_ipc_msg + 6);
                          int v792 = *(_DWORD *)(v76 + 232);
                          int v1332 = *(_DWORD *)(v76 + 236);
                          int v1324 = *(_DWORD *)(v76 + 172);
                          int v793 = mDNS_DomainNameFNV1aHash(v526);
                          v1489.dev_t st_dev = 67111683;
                          *(_DWORD *)&v1489.st_mode = v1359;
                          LOWORD(v1489.st_ino) = 1024;
                          *(_DWORD *)((char *)&v1489.st_ino + 2) = v1348;
                          HIWORD(v1489.st_ino) = 2160;
                          *(void *)&v1489.st_uid = 1752392040LL;
                          LOWORD(v1489.st_rdev) = 1040;
                          *(dev_t *)((char *)&v1489.st_rdev + 2) = v790;
                          *((_WORD *)&v1489.st_rdev + 3) = 2101;
                          v1489.st_atimespec.tv_sec = (__darwin_time_t)v526;
                          LOWORD(v1489.st_atimespec.tv_nsec) = 1024;
                          *(_DWORD *)((char *)&v1489.st_atimespec.tv_nsec + 2) = v791;
                          HIWORD(v1489.st_atimespec.tv_nsec) = 1024;
                          LODWORD(v1489.st_mtimespec.tv_sec) = v792;
                          WORD2(v1489.st_mtimespec.tv_sec) = 1024;
                          *(_DWORD *)((char *)&v1489.st_mtimespec.tv_sec + 6) = v1332;
                          WORD1(v1489.st_mtimespec.tv_nsec) = 1024;
                          HIDWORD(v1489.st_mtimespec.tv_nsec) = v1324;
                          LOWORD(v1489.st_ctimespec.tv_sec) = 2082;
                          *(__darwin_time_t *)((char *)&v1489.st_ctimespec.tv_sec + 2) = v76 + 240;
                          WORD1(v1489.st_ctimespec.tv_nsec) = 1024;
                          HIDWORD(v1489.st_ctimespec.tv_nsec) = v793;
                          v619 = (os_log_s *)__n;
                          v620 = "[R%u->Rec%u] DNSServiceRegisterRecord START -- name: %{sensitive, mask.hash, mdnsrespon"
                                 "der:domain_name}.*P, type: %{mdns:rrtype}d, flags: 0x%X, interface index: %d, client pi"
                                 "d: %d (%{public}s), name hash: %x";
                        }

                        else
                        {
                          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
                            goto LABEL_1419;
                          }
                          unint64_t v624 = v526;
                          int __nb = *(_DWORD *)(v76 + 184);
                          int v1361 = *((_DWORD *)v523 + 14);
                          if (v526 == (unsigned __int8 *)-256LL)
                          {
LABEL_1041:
                            while (v624)
                            {
                              uint64_t v625 = *v624;
                              if (!*v624)
                              {
                                unsigned __int16 v734 = (_WORD)v624 - (_WORD)v526 + 1;
                                goto LABEL_1329;
                              }

                              v624 += v625 + 1;
                            }
                          }

                          else
                          {
LABEL_1040:
                            if (v624 < v526 + 256) {
                              goto LABEL_1041;
                            }
                          }

                          unsigned __int16 v734 = 257;
LABEL_1329:
                          dev_t v794 = v734;
                          int v795 = *((unsigned __int16 *)rr_from_ipc_msg + 6);
                          int v1325 = *(_DWORD *)(v76 + 232);
                          int v1340 = *(_DWORD *)(v76 + 236);
                          int v1333 = *(_DWORD *)(v76 + 172);
                          int v796 = mDNS_DomainNameFNV1aHash(v526);
                          v1489.dev_t st_dev = 67111683;
                          *(_DWORD *)&v1489.st_mode = __nb;
                          LOWORD(v1489.st_ino) = 1024;
                          *(_DWORD *)((char *)&v1489.st_ino + 2) = v1361;
                          HIWORD(v1489.st_ino) = 2160;
                          *(void *)&v1489.st_uid = 1752392040LL;
                          LOWORD(v1489.st_rdev) = 1040;
                          *(dev_t *)((char *)&v1489.st_rdev + 2) = v794;
                          *((_WORD *)&v1489.st_rdev + 3) = 2101;
                          v1489.st_atimespec.tv_sec = (__darwin_time_t)v526;
                          LOWORD(v1489.st_atimespec.tv_nsec) = 1024;
                          *(_DWORD *)((char *)&v1489.st_atimespec.tv_nsec + 2) = v795;
                          HIWORD(v1489.st_atimespec.tv_nsec) = 1024;
                          LODWORD(v1489.st_mtimespec.tv_sec) = v1325;
                          WORD2(v1489.st_mtimespec.tv_sec) = 1024;
                          *(_DWORD *)((char *)&v1489.st_mtimespec.tv_sec + 6) = v1340;
                          WORD1(v1489.st_mtimespec.tv_nsec) = 1024;
                          HIDWORD(v1489.st_mtimespec.tv_nsec) = v1333;
                          LOWORD(v1489.st_ctimespec.tv_sec) = 2082;
                          *(__darwin_time_t *)((char *)&v1489.st_ctimespec.tv_sec + 2) = v76 + 240;
                          WORD1(v1489.st_ctimespec.tv_nsec) = 1024;
                          HIDWORD(v1489.st_ctimespec.tv_nsec) = v796;
                          v619 = (os_log_s *)v528;
                          v620 = "[R%u->Rec%u] DNSServiceRegisterRecord START -- name: %{sensitive, mask.hash, mdnsrespon"
                                 "der:domain_name}.*P, type: %{mdns:rrtype}d, flags: 0x%X, interface index: %d, client pi"
                                 "d: %d (%{public}s), name hash: %x";
                        }

                        uint32_t v695 = 80;
                      }

                      else
                      {
                        if ((v527 & 1) != 0)
                        {
                          uint64_t v612 = mDNSLogCategory_mDNS_redacted;
                          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
                            goto LABEL_1419;
                          }
                          int v613 = *(_DWORD *)(v76 + 184);
                          int v614 = *((_DWORD *)v523 + 14);
                          int v615 = *((unsigned __int16 *)rr_from_ipc_msg + 6);
                          int v616 = *(_DWORD *)(v76 + 232);
                          int v617 = *(_DWORD *)(v76 + 236);
                          int v618 = *(_DWORD *)(v76 + 172);
                          v1489.dev_t st_dev = 67111427;
                          *(_DWORD *)&v1489.st_mode = v613;
                          LOWORD(v1489.st_ino) = 1024;
                          *(_DWORD *)((char *)&v1489.st_ino + 2) = v614;
                          HIWORD(v1489.st_ino) = 2160;
                          *(void *)&v1489.st_uid = 1752392040LL;
                          LOWORD(v1489.st_rdev) = 1040;
                          *(dev_t *)((char *)&v1489.st_rdev + 2) = 257;
                          *((_WORD *)&v1489.st_rdev + 3) = 2101;
                          v1489.st_atimespec.tv_sec = 0LL;
                          LOWORD(v1489.st_atimespec.tv_nsec) = 1024;
                          *(_DWORD *)((char *)&v1489.st_atimespec.tv_nsec + 2) = v615;
                          HIWORD(v1489.st_atimespec.tv_nsec) = 1024;
                          LODWORD(v1489.st_mtimespec.tv_sec) = v616;
                          WORD2(v1489.st_mtimespec.tv_sec) = 1024;
                          *(_DWORD *)((char *)&v1489.st_mtimespec.tv_sec + 6) = v617;
                          WORD1(v1489.st_mtimespec.tv_nsec) = 1024;
                          HIDWORD(v1489.st_mtimespec.tv_nsec) = v618;
                          LOWORD(v1489.st_ctimespec.tv_sec) = 2082;
                          *(__darwin_time_t *)((char *)&v1489.st_ctimespec.tv_sec + 2) = v76 + 240;
                          v619 = (os_log_s *)v612;
                          v620 = "[R%u->Rec%u] DNSServiceRegisterRecord START -- name: %{sensitive, mask.hash, mdnsrespon"
                                 "der:domain_name}.*P, type: %{mdns:rrtype}d, flags: 0x%X, interface index: %d, client pi"
                                 "d: %d (%{public}s), ";
                        }

                        else
                        {
                          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
                            goto LABEL_1419;
                          }
                          int v689 = *(_DWORD *)(v76 + 184);
                          int v690 = *((_DWORD *)v523 + 14);
                          int v691 = *((unsigned __int16 *)rr_from_ipc_msg + 6);
                          int v692 = *(_DWORD *)(v76 + 232);
                          int v693 = *(_DWORD *)(v76 + 236);
                          int v694 = *(_DWORD *)(v76 + 172);
                          v1489.dev_t st_dev = 67111427;
                          *(_DWORD *)&v1489.st_mode = v689;
                          LOWORD(v1489.st_ino) = 1024;
                          *(_DWORD *)((char *)&v1489.st_ino + 2) = v690;
                          HIWORD(v1489.st_ino) = 2160;
                          *(void *)&v1489.st_uid = 1752392040LL;
                          LOWORD(v1489.st_rdev) = 1040;
                          *(dev_t *)((char *)&v1489.st_rdev + 2) = 257;
                          *((_WORD *)&v1489.st_rdev + 3) = 2101;
                          v1489.st_atimespec.tv_sec = 0LL;
                          LOWORD(v1489.st_atimespec.tv_nsec) = 1024;
                          *(_DWORD *)((char *)&v1489.st_atimespec.tv_nsec + 2) = v691;
                          HIWORD(v1489.st_atimespec.tv_nsec) = 1024;
                          LODWORD(v1489.st_mtimespec.tv_sec) = v692;
                          WORD2(v1489.st_mtimespec.tv_sec) = 1024;
                          *(_DWORD *)((char *)&v1489.st_mtimespec.tv_sec + 6) = v693;
                          WORD1(v1489.st_mtimespec.tv_nsec) = 1024;
                          HIDWORD(v1489.st_mtimespec.tv_nsec) = v694;
                          LOWORD(v1489.st_ctimespec.tv_sec) = 2082;
                          *(__darwin_time_t *)((char *)&v1489.st_ctimespec.tv_sec + 2) = v76 + 240;
                          v619 = (os_log_s *)v528;
                          v620 = "[R%u->Rec%u] DNSServiceRegisterRecord START -- name: %{sensitive, mask.hash, mdnsrespon"
                                 "der:domain_name}.*P, type: %{mdns:rrtype}d, flags: 0x%X, interface index: %d, client pi"
                                 "d: %d (%{public}s), ";
                        }

                        uint32_t v695 = 74;
                      }
                    }

                    else if (v526)
                    {
                      if ((v527 & 1) != 0)
                      {
                        uint64_t v574 = mDNSLogCategory_mDNS_redacted;
                        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
                          goto LABEL_1419;
                        }
                        int v1360 = *(_DWORD *)(v76 + 184);
                        int v1349 = *((_DWORD *)v523 + 14);
                        int v575 = v526;
                        size_t __na = v574;
                        if (v526 == (unsigned __int8 *)-256LL)
                        {
LABEL_944:
                          while (v575)
                          {
                            uint64_t v576 = *v575;
                            if (!*v575)
                            {
                              unsigned __int16 v773 = (_WORD)v575 - (_WORD)v526 + 1;
                              goto LABEL_1414;
                            }

                            v575 += v576 + 1;
                          }
                        }

                        else
                        {
LABEL_943:
                          if (v575 < v526 + 256) {
                            goto LABEL_944;
                          }
                        }

                        unsigned __int16 v773 = 257;
LABEL_1414:
                        dev_t v829 = v773;
                        int v830 = *((unsigned __int16 *)rr_from_ipc_msg + 6);
                        int v831 = *(_DWORD *)(v76 + 232);
                        int v1341 = *(_DWORD *)(v76 + 236);
                        int v832 = mDNS_DomainNameFNV1aHash(v526);
                        v1489.dev_t st_dev = 67111171;
                        *(_DWORD *)&v1489.st_mode = v1360;
                        LOWORD(v1489.st_ino) = 1024;
                        *(_DWORD *)((char *)&v1489.st_ino + 2) = v1349;
                        HIWORD(v1489.st_ino) = 2160;
                        *(void *)&v1489.st_uid = 1752392040LL;
                        LOWORD(v1489.st_rdev) = 1040;
                        *(dev_t *)((char *)&v1489.st_rdev + 2) = v829;
                        *((_WORD *)&v1489.st_rdev + 3) = 2101;
                        v1489.st_atimespec.tv_sec = (__darwin_time_t)v526;
                        LOWORD(v1489.st_atimespec.tv_nsec) = 1024;
                        *(_DWORD *)((char *)&v1489.st_atimespec.tv_nsec + 2) = v830;
                        HIWORD(v1489.st_atimespec.tv_nsec) = 1024;
                        LODWORD(v1489.st_mtimespec.tv_sec) = v831;
                        WORD2(v1489.st_mtimespec.tv_sec) = 1024;
                        *(_DWORD *)((char *)&v1489.st_mtimespec.tv_sec + 6) = v1341;
                        WORD1(v1489.st_mtimespec.tv_nsec) = 1024;
                        HIDWORD(v1489.st_mtimespec.tv_nsec) = v832;
                        v619 = (os_log_s *)__na;
                        v620 = "[R%u->Rec%u] DNSServiceRegisterRecord START -- name: %{sensitive, mask.hash, mdnsresponde"
                               "r:domain_name}.*P, type: %{mdns:rrtype}d, flags: 0x%X, interface index: %d, name hash: %x";
                      }

                      else
                      {
                        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
                          goto LABEL_1419;
                        }
                        int __ne = *(_DWORD *)(v76 + 184);
                        int v1364 = *((_DWORD *)v523 + 14);
                        uint64_t v687 = v526;
                        if (v526 == (unsigned __int8 *)-256LL)
                        {
LABEL_1154:
                          while (v687)
                          {
                            uint64_t v688 = *v687;
                            if (!*v687)
                            {
                              unsigned __int16 v774 = (_WORD)v687 - (_WORD)v526 + 1;
                              goto LABEL_1416;
                            }

                            v687 += v688 + 1;
                          }
                        }

                        else
                        {
LABEL_1153:
                          if (v687 < v526 + 256) {
                            goto LABEL_1154;
                          }
                        }

                        unsigned __int16 v774 = 257;
LABEL_1416:
                        dev_t v833 = v774;
                        int v834 = *((unsigned __int16 *)rr_from_ipc_msg + 6);
                        int v1342 = *(_DWORD *)(v76 + 232);
                        int v1351 = *(_DWORD *)(v76 + 236);
                        int v835 = mDNS_DomainNameFNV1aHash(v526);
                        v1489.dev_t st_dev = 67111171;
                        *(_DWORD *)&v1489.st_mode = __ne;
                        LOWORD(v1489.st_ino) = 1024;
                        *(_DWORD *)((char *)&v1489.st_ino + 2) = v1364;
                        HIWORD(v1489.st_ino) = 2160;
                        *(void *)&v1489.st_uid = 1752392040LL;
                        LOWORD(v1489.st_rdev) = 1040;
                        *(dev_t *)((char *)&v1489.st_rdev + 2) = v833;
                        *((_WORD *)&v1489.st_rdev + 3) = 2101;
                        v1489.st_atimespec.tv_sec = (__darwin_time_t)v526;
                        LOWORD(v1489.st_atimespec.tv_nsec) = 1024;
                        *(_DWORD *)((char *)&v1489.st_atimespec.tv_nsec + 2) = v834;
                        HIWORD(v1489.st_atimespec.tv_nsec) = 1024;
                        LODWORD(v1489.st_mtimespec.tv_sec) = v1342;
                        WORD2(v1489.st_mtimespec.tv_sec) = 1024;
                        *(_DWORD *)((char *)&v1489.st_mtimespec.tv_sec + 6) = v1351;
                        WORD1(v1489.st_mtimespec.tv_nsec) = 1024;
                        HIDWORD(v1489.st_mtimespec.tv_nsec) = v835;
                        v619 = (os_log_s *)v528;
                        v620 = "[R%u->Rec%u] DNSServiceRegisterRecord START -- name: %{sensitive, mask.hash, mdnsresponde"
                               "r:domain_name}.*P, type: %{mdns:rrtype}d, flags: 0x%X, interface index: %d, name hash: %x";
                      }

                      uint32_t v695 = 64;
                    }

                    else
                    {
                      if ((v527 & 1) != 0)
                      {
                        uint64_t v662 = mDNSLogCategory_mDNS_redacted;
                        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
                          goto LABEL_1419;
                        }
                        int v663 = *(_DWORD *)(v76 + 184);
                        int v664 = *((_DWORD *)v523 + 14);
                        int v665 = *((unsigned __int16 *)rr_from_ipc_msg + 6);
                        int v666 = *(_DWORD *)(v76 + 232);
                        int v667 = *(_DWORD *)(v76 + 236);
                        v1489.dev_t st_dev = 67110915;
                        *(_DWORD *)&v1489.st_mode = v663;
                        LOWORD(v1489.st_ino) = 1024;
                        *(_DWORD *)((char *)&v1489.st_ino + 2) = v664;
                        HIWORD(v1489.st_ino) = 2160;
                        *(void *)&v1489.st_uid = 1752392040LL;
                        LOWORD(v1489.st_rdev) = 1040;
                        *(dev_t *)((char *)&v1489.st_rdev + 2) = 257;
                        *((_WORD *)&v1489.st_rdev + 3) = 2101;
                        v1489.st_atimespec.tv_sec = 0LL;
                        LOWORD(v1489.st_atimespec.tv_nsec) = 1024;
                        *(_DWORD *)((char *)&v1489.st_atimespec.tv_nsec + 2) = v665;
                        HIWORD(v1489.st_atimespec.tv_nsec) = 1024;
                        LODWORD(v1489.st_mtimespec.tv_sec) = v666;
                        WORD2(v1489.st_mtimespec.tv_sec) = 1024;
                        *(_DWORD *)((char *)&v1489.st_mtimespec.tv_sec + 6) = v667;
                        v619 = (os_log_s *)v662;
                        v620 = "[R%u->Rec%u] DNSServiceRegisterRecord START -- name: %{sensitive, mask.hash, mdnsresponde"
                               "r:domain_name}.*P, type: %{mdns:rrtype}d, flags: 0x%X, interface index: %d, ";
                      }

                      else
                      {
                        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
                          goto LABEL_1419;
                        }
                        int v712 = *(_DWORD *)(v76 + 184);
                        int v713 = *((_DWORD *)v523 + 14);
                        int v714 = *((unsigned __int16 *)rr_from_ipc_msg + 6);
                        int v715 = *(_DWORD *)(v76 + 232);
                        int v716 = *(_DWORD *)(v76 + 236);
                        v1489.dev_t st_dev = 67110915;
                        *(_DWORD *)&v1489.st_mode = v712;
                        LOWORD(v1489.st_ino) = 1024;
                        *(_DWORD *)((char *)&v1489.st_ino + 2) = v713;
                        HIWORD(v1489.st_ino) = 2160;
                        *(void *)&v1489.st_uid = 1752392040LL;
                        LOWORD(v1489.st_rdev) = 1040;
                        *(dev_t *)((char *)&v1489.st_rdev + 2) = 257;
                        *((_WORD *)&v1489.st_rdev + 3) = 2101;
                        v1489.st_atimespec.tv_sec = 0LL;
                        LOWORD(v1489.st_atimespec.tv_nsec) = 1024;
                        *(_DWORD *)((char *)&v1489.st_atimespec.tv_nsec + 2) = v714;
                        HIWORD(v1489.st_atimespec.tv_nsec) = 1024;
                        LODWORD(v1489.st_mtimespec.tv_sec) = v715;
                        WORD2(v1489.st_mtimespec.tv_sec) = 1024;
                        *(_DWORD *)((char *)&v1489.st_mtimespec.tv_sec + 6) = v716;
                        v619 = (os_log_s *)v528;
                        v620 = "[R%u->Rec%u] DNSServiceRegisterRecord START -- name: %{sensitive, mask.hash, mdnsresponde"
                               "r:domain_name}.*P, type: %{mdns:rrtype}d, flags: 0x%X, interface index: %d, ";
                      }

                      uint32_t v695 = 58;
                    }

                    _os_log_impl((void *)&_mh_execute_header, v619, OS_LOG_TYPE_DEFAULT, v620, (uint8_t *)&v1489, v695);
LABEL_1419:
                    _shouldLogFullRequestInfo((int *)v523 + 12, (_DWORD *)v523 + 13);
                    int v836 = mDNS_Register((unsigned int *)mDNSStorage, (uint64_t)rr_from_ipc_msg);
                    if (v836)
                    {
                      int updated = v836;
                      int v840 = mDNS_DomainNameFNV1aHash((unsigned __int8 *)rr_from_ipc_msg[5]);
                      uint64_t v841 = rr_from_ipc_msg[8];
                      if (v841)
                      {
                        validation_uint64_t result = dnssec_obj_resource_record_member_get_validation_result(v841);
                        size_t v843 = *((unsigned __int16 *)rr_from_ipc_msg + 10);
                        if (validation_result)
                        {
                          int v844 = validation_result;
                          if (v843 < 0x201)
                          {
                            if (*((_WORD *)rr_from_ipc_msg + 10))
                            {
                              int v1394 = validation_result;
                              v845 = 0LL;
                              LODWORD(v843) = 512;
                              int v846 = (char *)&unk_100164138;
                              goto LABEL_1440;
                            }

                            uint64_t v871 = mDNSLogCategory_mDNS;
                            if (gSensitiveLoggingEnabled == 1 && mDNSLogCategory_mDNS != mDNSLogCategory_State)
                            {
                              uint64_t v871 = mDNSLogCategory_mDNS_redacted;
                              if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_ERROR))
                              {
                                __darwin_time_t v872 = rr_from_ipc_msg[5];
                                if (v872)
                                {
                                  v873 = (_BYTE *)rr_from_ipc_msg[5];
                                  if (v872 == -256)
                                  {
LABEL_1483:
                                    while (v873)
                                    {
                                      uint64_t v874 = *v873;
                                      if (!*v873)
                                      {
                                        LOWORD(v873) = (_WORD)v873 - v872 + 1;
                                        goto LABEL_1966;
                                      }

                                      v873 += v874 + 1;
                                      if (v872 != -256) {
                                        goto LABEL_1482;
                                      }
                                    }
                                  }

                                  else
                                  {
LABEL_1482:
                                  }

                                  LOWORD(v873) = 257;
LABEL_1966:
                                  LODWORD(v873) = (unsigned __int16)v873;
                                }

                                else
                                {
                                  LODWORD(v873) = 0;
                                }

                                goto LABEL_1969;
                              }

LABEL_1857:
                              v1053 = v523;
LABEL_1858:
                              free(v1053);
LABEL_1859:
                              int v732 = rr_from_ipc_msg;
LABEL_1210:
                              free(v732);
                              goto LABEL_1122;
                            }

                            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_ERROR)) {
                              goto LABEL_1857;
                            }
                            __darwin_time_t v872 = rr_from_ipc_msg[5];
                            if (v872)
                            {
                              v873 = (_BYTE *)rr_from_ipc_msg[5];
                              if (v872 == -256)
                              {
LABEL_1603:
                                while (v873)
                                {
                                  uint64_t v927 = *v873;
                                  if (!*v873)
                                  {
                                    LOWORD(v873) = (_WORD)v873 - v872 + 1;
                                    goto LABEL_1968;
                                  }

                                  v873 += v927 + 1;
                                  if (v872 != -256) {
                                    goto LABEL_1602;
                                  }
                                }
                              }

                              else
                              {
LABEL_1602:
                              }

                              LOWORD(v873) = 257;
LABEL_1968:
                              LODWORD(v873) = (unsigned __int16)v873;
                            }

                            else
                            {
                              LODWORD(v873) = 0;
                            }

LABEL_1969:
                            int v1137 = *(_DWORD *)(v76 + 184);
                            int v1138 = *((_DWORD *)v523 + 14);
                            uid_t v1139 = *(_DWORD *)(v76 + 236);
                            int v1140 = *((unsigned __int16 *)rr_from_ipc_msg + 6);
                            v1489.dev_t st_dev = 67111171;
                            *(_DWORD *)&v1489.st_mode = v1137;
                            LOWORD(v1489.st_ino) = 1024;
                            *(_DWORD *)((char *)&v1489.st_ino + 2) = v1138;
                            HIWORD(v1489.st_ino) = 1024;
                            v1489.st_uid = v1139;
                            LOWORD(v1489.st_gid) = 2160;
                            *(void *)((char *)&v1489.st_gid + 2) = 1752392040LL;
                            *((_WORD *)&v1489.st_rdev + 3) = 1040;
                            LODWORD(v1489.st_atimespec.tv_sec) = (_DWORD)v873;
                            WORD2(v1489.st_atimespec.tv_sec) = 2101;
                            *(__darwin_time_t *)((char *)&v1489.st_atimespec.tv_sec + 6) = v872;
                            HIWORD(v1489.st_atimespec.tv_nsec) = 1024;
                            LODWORD(v1489.st_mtimespec.tv_sec) = v840;
                            WORD2(v1489.st_mtimespec.tv_sec) = 1026;
                            *(_DWORD *)((char *)&v1489.st_mtimespec.tv_sec + 6) = v844;
                            WORD1(v1489.st_mtimespec.tv_nsec) = 1024;
                            HIDWORD(v1489.st_mtimespec.tv_nsec) = v1140;
                            v1086 = (os_log_s *)v871;
                            v1087 = "[R%u->mDNS] DNSServiceRegisterRecord Result -- record %u, event: ERROR, ifindex: %d,"
                                    " name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P(%x), dnssec: %{public, "
                                    "mdns:dnssec_result}d, type: %{mdns:rrtype}d, rdata: <none>";
                            uint32_t v1088 = 64;
LABEL_1970:
                            _os_log_impl( (void *)&_mh_execute_header,  v1086,  OS_LOG_TYPE_ERROR,  v1087,  (uint8_t *)&v1489,  v1088);
                            goto LABEL_1857;
                          }

                          int v1394 = validation_result;
                          v845 = (char *)malloc(v843);
                          int v846 = v845;
                          if (!v845) {
                            goto LABEL_2255;
                          }
LABEL_1440:
                          *(_DWORD *)&v1504[0].sa_leuint64_t n = 0;
                          *(_WORD *)v1449 = 0;
                          uint64_t RDataBytesPointer = ResourceRecordGetRDataBytesPointer( (uint64_t)(rr_from_ipc_msg + 1),  v846,  v843,  v1449,  (int *)v1504,  v837,  v838,  v839);
                          if (*(_DWORD *)&v1504[0].sa_len) {
                            goto LABEL_1855;
                          }
                          v1352 = (const void *)RDataBytesPointer;
                          size_t v855 = *(unsigned __int16 *)v1449;
                          int v1416 = v840;
                          if (*(unsigned __int16 *)v1449 >= 0x1FFuLL)
                          {
                            unsigned int v856 = *(unsigned __int16 *)v1449 + 2;
                            int v857 = (__int16 *)malloc(*(unsigned __int16 *)v1449 + 2LL);
                            if (!v857) {
                              goto LABEL_2255;
                            }
                            size_t __nh = (size_t)v857;
                          }

                          else
                          {
                            size_t __nh = 0LL;
                            unsigned int v856 = 512;
                            int v857 = word_100164338;
                          }

                          v1371 = v857;
                          uint64_t v888 = mDNSLogCategory_mDNS;
                          if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
                          {
                            if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_ERROR))
                            {
                              __darwin_time_t v893 = rr_from_ipc_msg[5];
                              if (v893)
                              {
                                uint64_t v894 = (_BYTE *)rr_from_ipc_msg[5];
                                if (v893 == -256)
                                {
LABEL_1526:
                                  while (v894)
                                  {
                                    uint64_t v895 = *v894;
                                    if (!*v894)
                                    {
                                      unsigned __int16 v998 = (_WORD)v894 - v893 + 1;
                                      goto LABEL_1882;
                                    }

                                    v894 += v895 + 1;
                                    if (v893 != -256) {
                                      goto LABEL_1525;
                                    }
                                  }
                                }

                                else
                                {
LABEL_1525:
                                }

                                unsigned __int16 v998 = 257;
LABEL_1882:
                                int v1014 = v998;
                              }

                              else
                              {
                                int v1014 = 0;
                              }

                              int v1070 = *(_DWORD *)(v76 + 184);
                              int v1071 = *((_DWORD *)v523 + 14);
                              uid_t v1072 = *(_DWORD *)(v76 + 236);
                              unsigned int v1073 = *((unsigned __int16 *)rr_from_ipc_msg + 6);
                              int v1074 = v855 + 2;
                              if ((int)v855 + 2 <= v856)
                              {
                                int v1321 = *(_DWORD *)(v76 + 184);
                                int v1330 = v1014;
                                v1076 = v1352;
                                __int16 *v1371 = __rev16(v1073);
                                size_t v1077 = v855;
                                __darwin_time_t v1347 = v893;
                                int v1356 = v855 + 2;
                                unsigned int v1078 = v1073;
                                uid_t v1339 = v1072;
                                int v1079 = v1071;
                                memcpy(v1371 + 1, v1076, v1077);
                                int v1070 = v1321;
                                int v1014 = v1330;
                                int v1071 = v1079;
                                uid_t v1072 = v1339;
                                unsigned int v1073 = v1078;
                                int v1074 = v1356;
                                __darwin_time_t v893 = v1347;
                                __darwin_time_t v1075 = (__darwin_time_t)v1371;
                              }

                              else
                              {
                                __darwin_time_t v1075 = 0LL;
                              }

                              v1489.dev_t st_dev = 67111939;
                              *(_DWORD *)&v1489.st_mode = v1070;
                              LOWORD(v1489.st_ino) = 1024;
                              *(_DWORD *)((char *)&v1489.st_ino + 2) = v1071;
                              HIWORD(v1489.st_ino) = 1024;
                              v1489.st_uid = v1072;
                              LOWORD(v1489.st_gid) = 2160;
                              *(void *)((char *)&v1489.st_gid + 2) = 1752392040LL;
                              *((_WORD *)&v1489.st_rdev + 3) = 1040;
                              LODWORD(v1489.st_atimespec.tv_sec) = v1014;
                              WORD2(v1489.st_atimespec.tv_sec) = 2101;
                              *(__darwin_time_t *)((char *)&v1489.st_atimespec.tv_sec + 6) = v893;
                              HIWORD(v1489.st_atimespec.tv_nsec) = 1024;
                              LODWORD(v1489.st_mtimespec.tv_sec) = v1416;
                              WORD2(v1489.st_mtimespec.tv_sec) = 1026;
                              *(_DWORD *)((char *)&v1489.st_mtimespec.tv_sec + 6) = v1394;
                              WORD1(v1489.st_mtimespec.tv_nsec) = 1024;
                              HIDWORD(v1489.st_mtimespec.tv_nsec) = v1073;
                              LOWORD(v1489.st_ctimespec.tv_sec) = 2160;
                              *(__darwin_time_t *)((char *)&v1489.st_ctimespec.tv_sec + 2) = 1752392040LL;
                              WORD1(v1489.st_ctimespec.tv_nsec) = 1040;
                              HIDWORD(v1489.st_ctimespec.tv_nsec) = v1074;
                              LOWORD(v1489.st_birthtimespec.tv_sec) = 2101;
                              *(__darwin_time_t *)((char *)&v1489.st_birthtimespec.tv_sec + 2) = v1075;
                              v1069 = (os_log_s *)v888;
LABEL_1887:
                              _os_log_impl( (void *)&_mh_execute_header,  v1069,  OS_LOG_TYPE_ERROR,  "[R%u->mDNS] DNSServiceRegisterRecord Result -- record %u, event: ERROR, ifindex: %d, nam e: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P(%x), dnssec: %{public, mdns:dns sec_result}d, type: %{mdns:rrtype}d, rdata: %{sensitive, mask.hash, mdns:rdata}.*P",  (uint8_t *)&v1489,  0x5Au);
                            }
                          }

                          else
                          {
                            uint64_t v889 = mDNSLogCategory_mDNS_redacted;
                            if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_ERROR))
                            {
                              __darwin_time_t v890 = rr_from_ipc_msg[5];
                              v1343 = (os_log_s *)v889;
                              if (v890)
                              {
                                __int16 v891 = (_BYTE *)rr_from_ipc_msg[5];
                                if (v890 == -256)
                                {
LABEL_1517:
                                  while (v891)
                                  {
                                    uint64_t v892 = *v891;
                                    if (!*v891)
                                    {
                                      unsigned __int16 v997 = (_WORD)v891 - v890 + 1;
                                      goto LABEL_1876;
                                    }

                                    v891 += v892 + 1;
                                    if (v890 != -256) {
                                      goto LABEL_1516;
                                    }
                                  }
                                }

                                else
                                {
LABEL_1516:
                                }

                                unsigned __int16 v997 = 257;
LABEL_1876:
                                int v1013 = v997;
                              }

                              else
                              {
                                int v1013 = 0;
                              }

                              int v1059 = *(_DWORD *)(v76 + 184);
                              int v1060 = *((_DWORD *)v523 + 14);
                              uid_t v1061 = *(_DWORD *)(v76 + 236);
                              unsigned int v1062 = *((unsigned __int16 *)rr_from_ipc_msg + 6);
                              int v1063 = v855 + 2;
                              if ((int)v855 + 2 <= v856)
                              {
                                int v1320 = *(_DWORD *)(v76 + 184);
                                int v1329 = *((_DWORD *)v523 + 14);
                                v1065 = v1352;
                                __int16 *v1371 = __rev16(v1062);
                                size_t v1066 = v855;
                                __darwin_time_t v1338 = v890;
                                int v1067 = v1013;
                                unsigned int v1355 = v1062;
                                uid_t v1068 = v1061;
                                memcpy(v1371 + 1, v1065, v1066);
                                int v1059 = v1320;
                                int v1060 = v1329;
                                uid_t v1061 = v1068;
                                unsigned int v1062 = v1355;
                                int v1013 = v1067;
                                __darwin_time_t v890 = v1338;
                                __darwin_time_t v1064 = (__darwin_time_t)v1371;
                              }

                              else
                              {
                                __darwin_time_t v1064 = 0LL;
                              }

                              v1489.dev_t st_dev = 67111939;
                              *(_DWORD *)&v1489.st_mode = v1059;
                              LOWORD(v1489.st_ino) = 1024;
                              *(_DWORD *)((char *)&v1489.st_ino + 2) = v1060;
                              HIWORD(v1489.st_ino) = 1024;
                              v1489.st_uid = v1061;
                              LOWORD(v1489.st_gid) = 2160;
                              *(void *)((char *)&v1489.st_gid + 2) = 1752392040LL;
                              *((_WORD *)&v1489.st_rdev + 3) = 1040;
                              LODWORD(v1489.st_atimespec.tv_sec) = v1013;
                              WORD2(v1489.st_atimespec.tv_sec) = 2101;
                              *(__darwin_time_t *)((char *)&v1489.st_atimespec.tv_sec + 6) = v890;
                              HIWORD(v1489.st_atimespec.tv_nsec) = 1024;
                              LODWORD(v1489.st_mtimespec.tv_sec) = v1416;
                              WORD2(v1489.st_mtimespec.tv_sec) = 1026;
                              *(_DWORD *)((char *)&v1489.st_mtimespec.tv_sec + 6) = v1394;
                              WORD1(v1489.st_mtimespec.tv_nsec) = 1024;
                              HIDWORD(v1489.st_mtimespec.tv_nsec) = v1062;
                              LOWORD(v1489.st_ctimespec.tv_sec) = 2160;
                              *(__darwin_time_t *)((char *)&v1489.st_ctimespec.tv_sec + 2) = 1752392040LL;
                              WORD1(v1489.st_ctimespec.tv_nsec) = 1040;
                              HIDWORD(v1489.st_ctimespec.tv_nsec) = v1063;
                              LOWORD(v1489.st_birthtimespec.tv_sec) = 2101;
                              *(__darwin_time_t *)((char *)&v1489.st_birthtimespec.tv_sec + 2) = v1064;
                              v1069 = v1343;
                              goto LABEL_1887;
                            }
                          }

                          v1052 = (void *)__nh;
                          if (!__nh)
                          {
LABEL_1855:
                            if (v845) {
                              free(v845);
                            }
                            goto LABEL_1857;
                          }

LABEL_1854:
                          free(v1052);
                          goto LABEL_1855;
                        }
                      }

                      else
                      {
                        LODWORD(v843) = *((unsigned __int16 *)rr_from_ipc_msg + 10);
                      }

                      if (v843 >= 0x201)
                      {
                        v845 = (char *)malloc(v843);
                        unint64_t v849 = v845;
                        if (!v845) {
                          goto LABEL_2255;
                        }
                      }

                      else
                      {
                        if (!(_DWORD)v843)
                        {
                          uint64_t v858 = mDNSLogCategory_mDNS;
                          if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
                          {
                            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_ERROR)) {
                              goto LABEL_1857;
                            }
                            __darwin_time_t v859 = rr_from_ipc_msg[5];
                            if (v859)
                            {
                              unint64_t v860 = (_BYTE *)rr_from_ipc_msg[5];
                              if (v859 == -256)
                              {
LABEL_1535:
                                while (v860)
                                {
                                  uint64_t v896 = *v860;
                                  if (!*v860)
                                  {
                                    LOWORD(v860) = (_WORD)v860 - v859 + 1;
                                    goto LABEL_1897;
                                  }

                                  v860 += v896 + 1;
                                  if (v859 != -256) {
                                    goto LABEL_1534;
                                  }
                                }
                              }

                              else
                              {
LABEL_1534:
                              }

                              LOWORD(v860) = 257;
LABEL_1897:
                              LODWORD(v860) = (unsigned __int16)v860;
                            }

                            else
                            {
                              LODWORD(v860) = 0;
                            }
                          }

                          else
                          {
                            uint64_t v858 = mDNSLogCategory_mDNS_redacted;
                            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_ERROR)) {
                              goto LABEL_1857;
                            }
                            __darwin_time_t v859 = rr_from_ipc_msg[5];
                            if (v859)
                            {
                              unint64_t v860 = (_BYTE *)rr_from_ipc_msg[5];
                              if (v859 == -256)
                              {
LABEL_1449:
                                while (v860)
                                {
                                  uint64_t v861 = *v860;
                                  if (!*v860)
                                  {
                                    LOWORD(v860) = (_WORD)v860 - v859 + 1;
                                    goto LABEL_1895;
                                  }

                                  v860 += v861 + 1;
                                  if (v859 != -256) {
                                    goto LABEL_1448;
                                  }
                                }
                              }

                              else
                              {
LABEL_1448:
                              }

                              LOWORD(v860) = 257;
LABEL_1895:
                              LODWORD(v860) = (unsigned __int16)v860;
                            }

                            else
                            {
                              LODWORD(v860) = 0;
                            }
                          }

                          int v1082 = *(_DWORD *)(v76 + 184);
                          int v1083 = *((_DWORD *)v523 + 14);
                          uid_t v1084 = *(_DWORD *)(v76 + 236);
                          int v1085 = *((unsigned __int16 *)rr_from_ipc_msg + 6);
                          v1489.dev_t st_dev = 67110915;
                          *(_DWORD *)&v1489.st_mode = v1082;
                          LOWORD(v1489.st_ino) = 1024;
                          *(_DWORD *)((char *)&v1489.st_ino + 2) = v1083;
                          HIWORD(v1489.st_ino) = 1024;
                          v1489.st_uid = v1084;
                          LOWORD(v1489.st_gid) = 2160;
                          *(void *)((char *)&v1489.st_gid + 2) = 1752392040LL;
                          *((_WORD *)&v1489.st_rdev + 3) = 1040;
                          LODWORD(v1489.st_atimespec.tv_sec) = (_DWORD)v860;
                          WORD2(v1489.st_atimespec.tv_sec) = 2101;
                          *(__darwin_time_t *)((char *)&v1489.st_atimespec.tv_sec + 6) = v859;
                          HIWORD(v1489.st_atimespec.tv_nsec) = 1024;
                          LODWORD(v1489.st_mtimespec.tv_sec) = v840;
                          WORD2(v1489.st_mtimespec.tv_sec) = 1024;
                          *(_DWORD *)((char *)&v1489.st_mtimespec.tv_sec + 6) = v1085;
                          v1086 = (os_log_s *)v858;
                          v1087 = "[R%u->mDNS] DNSServiceRegisterRecord Result -- record %u, event: ERROR, ifindex: %d, n"
                                  "ame: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P(%x), type: %{mdns:rrtype}d, rdata: <none>";
                          uint32_t v1088 = 58;
                          goto LABEL_1970;
                        }

                        v845 = 0LL;
                        LODWORD(v843) = 512;
                        unint64_t v849 = (char *)&unk_100164138;
                      }

                      *(_DWORD *)&v1504[0].sa_leuint64_t n = 0;
                      *(_WORD *)v1449 = 0;
                      uint64_t v850 = ResourceRecordGetRDataBytesPointer( (uint64_t)(rr_from_ipc_msg + 1),  v849,  v843,  v1449,  (int *)v1504,  v837,  v838,  v839);
                      if (*(_DWORD *)&v1504[0].sa_len) {
                        goto LABEL_1855;
                      }
                      int v1415 = v840;
                      v1370 = (void *)v850;
                      size_t __ng = *(unsigned __int16 *)v1449;
                      if (*(unsigned __int16 *)v1449 >= 0x1FFuLL)
                      {
                        unsigned int v852 = *(unsigned __int16 *)v1449 + 2;
                        int v862 = (__int16 *)malloc(*(unsigned __int16 *)v1449 + 2LL);
                        if (!v862) {
                          goto LABEL_2255;
                        }
                        int v853 = v862;
                        unint64_t v851 = v862;
                      }

                      else
                      {
                        unint64_t v851 = 0LL;
                        unsigned int v852 = 512;
                        int v853 = word_100164338;
                      }

                      v1395 = v851;
                      uint64_t v863 = mDNSLogCategory_mDNS;
                      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
                      {
                        if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_ERROR))
                        {
                          __darwin_time_t v868 = rr_from_ipc_msg[5];
                          if (v868)
                          {
                            v869 = (_BYTE *)rr_from_ipc_msg[5];
                            if (v868 == -256)
                            {
LABEL_1471:
                              while (v869)
                              {
                                uint64_t v870 = *v869;
                                if (!*v869)
                                {
                                  unsigned __int16 v962 = (_WORD)v869 - v868 + 1;
                                  goto LABEL_1847;
                                }

                                v869 += v870 + 1;
                                if (v868 != -256) {
                                  goto LABEL_1470;
                                }
                              }
                            }

                            else
                            {
LABEL_1470:
                            }

                            unsigned __int16 v962 = 257;
LABEL_1847:
                            int v990 = v962;
                          }

                          else
                          {
                            int v990 = 0;
                          }

                          unsigned int v1044 = __ng;
                          int v1045 = *(_DWORD *)(v76 + 184);
                          int v1046 = *((_DWORD *)v523 + 14);
                          uid_t v1047 = *(_DWORD *)(v76 + 236);
                          unsigned int v1048 = *((unsigned __int16 *)rr_from_ipc_msg + 6);
                          int v1049 = __ng + 2;
                          if ((int)__ng + 2 <= v852)
                          {
                            int v1328 = *(_DWORD *)(v76 + 184);
                            *int v853 = __rev16(v1048);
                            v1050 = v1370;
                            __nuint64_t m = v868;
                            int v1051 = v990;
                            int v1373 = v1049;
                            unsigned int v1354 = v1048;
                            uid_t v1346 = v1047;
                            int v1337 = v1046;
                            memcpy(v853 + 1, v1050, v1044);
                            int v1045 = v1328;
                            int v1046 = v1337;
                            uid_t v1047 = v1346;
                            unsigned int v1048 = v1354;
                            int v1049 = v1373;
                            int v990 = v1051;
                            __darwin_time_t v868 = __nm;
                          }

                          else
                          {
                            int v853 = 0LL;
                          }

                          v1489.dev_t st_dev = 67111683;
                          *(_DWORD *)&v1489.st_mode = v1045;
                          LOWORD(v1489.st_ino) = 1024;
                          *(_DWORD *)((char *)&v1489.st_ino + 2) = v1046;
                          HIWORD(v1489.st_ino) = 1024;
                          v1489.st_uid = v1047;
                          LOWORD(v1489.st_gid) = 2160;
                          *(void *)((char *)&v1489.st_gid + 2) = 1752392040LL;
                          *((_WORD *)&v1489.st_rdev + 3) = 1040;
                          LODWORD(v1489.st_atimespec.tv_sec) = v990;
                          WORD2(v1489.st_atimespec.tv_sec) = 2101;
                          *(__darwin_time_t *)((char *)&v1489.st_atimespec.tv_sec + 6) = v868;
                          HIWORD(v1489.st_atimespec.tv_nsec) = 1024;
                          LODWORD(v1489.st_mtimespec.tv_sec) = v1415;
                          WORD2(v1489.st_mtimespec.tv_sec) = 1024;
                          *(_DWORD *)((char *)&v1489.st_mtimespec.tv_sec + 6) = v1048;
                          WORD1(v1489.st_mtimespec.tv_nsec) = 2160;
                          *(uint64_t *)((char *)&v1489.st_mtimespec.tv_nsec + 4) = 1752392040LL;
                          WORD2(v1489.st_ctimespec.tv_sec) = 1040;
                          *(_DWORD *)((char *)&v1489.st_ctimespec.tv_sec + 6) = v1049;
                          WORD1(v1489.st_ctimespec.tv_nsec) = 2101;
                          *(uint64_t *)((char *)&v1489.st_ctimespec.tv_nsec + 4) = (uint64_t)v853;
                          v1043 = (os_log_s *)v863;
LABEL_1852:
                          _os_log_impl( (void *)&_mh_execute_header,  v1043,  OS_LOG_TYPE_ERROR,  "[R%u->mDNS] DNSServiceRegisterRecord Result -- record %u, event: ERROR, ifindex: %d, name: % {sensitive, mask.hash, mdnsresponder:domain_name}.*P(%x), type: %{mdns:rrtype}d, rdata: %{se nsitive, mask.hash, mdns:rdata}.*P",  (uint8_t *)&v1489,  0x54u);
                        }
                      }

                      else
                      {
                        uint64_t v864 = mDNSLogCategory_mDNS_redacted;
                        if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_ERROR))
                        {
                          __darwin_time_t v865 = rr_from_ipc_msg[5];
                          v1353 = (os_log_s *)v864;
                          if (v865)
                          {
                            uint64_t v866 = (_BYTE *)rr_from_ipc_msg[5];
                            if (v865 == -256)
                            {
LABEL_1462:
                              while (v866)
                              {
                                uint64_t v867 = *v866;
                                if (!*v866)
                                {
                                  unsigned __int16 v961 = (_WORD)v866 - v865 + 1;
                                  goto LABEL_1841;
                                }

                                v866 += v867 + 1;
                                if (v865 != -256) {
                                  goto LABEL_1461;
                                }
                              }
                            }

                            else
                            {
LABEL_1461:
                            }

                            unsigned __int16 v961 = 257;
LABEL_1841:
                            int v989 = v961;
                          }

                          else
                          {
                            int v989 = 0;
                          }

                          size_t v1035 = __ng;
                          int v1036 = *(_DWORD *)(v76 + 184);
                          int v1037 = *((_DWORD *)v523 + 14);
                          uid_t v1038 = *(_DWORD *)(v76 + 236);
                          unsigned int v1039 = *((unsigned __int16 *)rr_from_ipc_msg + 6);
                          int v1040 = __ng + 2;
                          if ((int)__ng + 2 <= v852)
                          {
                            int v1327 = *(_DWORD *)(v76 + 184);
                            *int v853 = __rev16(v1039);
                            v1041 = v1370;
                            size_t __nl = v865;
                            int v1042 = v989;
                            unsigned int v1372 = v1039;
                            uid_t v1345 = v1038;
                            int v1336 = v1037;
                            memcpy(v853 + 1, v1041, v1035);
                            int v1036 = v1327;
                            int v1037 = v1336;
                            uid_t v1038 = v1345;
                            unsigned int v1039 = v1372;
                            int v989 = v1042;
                            __darwin_time_t v865 = __nl;
                          }

                          else
                          {
                            int v853 = 0LL;
                          }

                          v1489.dev_t st_dev = 67111683;
                          *(_DWORD *)&v1489.st_mode = v1036;
                          LOWORD(v1489.st_ino) = 1024;
                          *(_DWORD *)((char *)&v1489.st_ino + 2) = v1037;
                          HIWORD(v1489.st_ino) = 1024;
                          v1489.st_uid = v1038;
                          LOWORD(v1489.st_gid) = 2160;
                          *(void *)((char *)&v1489.st_gid + 2) = 1752392040LL;
                          *((_WORD *)&v1489.st_rdev + 3) = 1040;
                          LODWORD(v1489.st_atimespec.tv_sec) = v989;
                          WORD2(v1489.st_atimespec.tv_sec) = 2101;
                          *(__darwin_time_t *)((char *)&v1489.st_atimespec.tv_sec + 6) = v865;
                          HIWORD(v1489.st_atimespec.tv_nsec) = 1024;
                          LODWORD(v1489.st_mtimespec.tv_sec) = v1415;
                          WORD2(v1489.st_mtimespec.tv_sec) = 1024;
                          *(_DWORD *)((char *)&v1489.st_mtimespec.tv_sec + 6) = v1039;
                          WORD1(v1489.st_mtimespec.tv_nsec) = 2160;
                          *(uint64_t *)((char *)&v1489.st_mtimespec.tv_nsec + 4) = 1752392040LL;
                          WORD2(v1489.st_ctimespec.tv_sec) = 1040;
                          *(_DWORD *)((char *)&v1489.st_ctimespec.tv_sec + 6) = v1040;
                          WORD1(v1489.st_ctimespec.tv_nsec) = 2101;
                          *(uint64_t *)((char *)&v1489.st_ctimespec.tv_nsec + 4) = (uint64_t)v853;
                          v1043 = v1353;
                          goto LABEL_1852;
                        }
                      }

                      v1052 = v1395;
                      if (!v1395) {
                        goto LABEL_1855;
                      }
                      goto LABEL_1854;
                    }

                    if (rr_from_ipc_msg[4] != -2LL && IsLocalDomain((_BYTE *)rr_from_ipc_msg[5]))
                    {
                      uint64_t v847 = *(unsigned int *)(v76 + 236);
                      if ((_DWORD)v847)
                      {
                        if (AWDLInterfaceID && AWDLInterfaceID == v847)
                        {
                          int v848 = 1;
                        }

                        else
                        {
                          if (WiFiAwareInterfaceID) {
                            BOOL v875 = WiFiAwareInterfaceID == v847;
                          }
                          else {
                            BOOL v875 = 0;
                          }
                          int v848 = v875;
                        }
                      }

                      else
                      {
                        int v848 = (*(_DWORD *)(v76 + 232) >> 20) & 1;
                      }

                      __uint64_t *v523 = mdns_powerlog_register_record_start( (const char *)(v76 + 240),  (unsigned __int8 *)rr_from_ipc_msg[5],  v848);
                    }

                    if (mDNS_McastLoggingEnabled) {
                      LogMcastService((uint64_t)rr_from_ipc_msg, v76, 1, a4, a5, a6, a7, a8, v1313);
                    }
                    v876 = (void *)(v76 + 160);
                    v523[1] = *(void *)(v76 + 160);
                    *(void *)(v76 + 160) = v523;
                    if (!v318) {
                      goto LABEL_666;
                    }
                    int v877 = *(_DWORD *)buf;
                    if (!v1392)
                    {
                      v878 = calloc(1uLL, 0x5A4uLL);
                      if (!v878) {
                        goto LABEL_2255;
                      }
                      uint64_t v879 = (uint64_t)v878;
                      mDNS_SetupResourceRecord((uint64_t)v878, 0LL, rr_from_ipc_msg[4], 41, 0x1194u, 2, 0, 0LL, 0LL);
                      uint64_t v885 = (_BYTE *)rr_from_ipc_msg[5];
                      __int128 v886 = v885;
                      if (v885 == (_BYTE *)-256LL)
                      {
LABEL_1504:
                        while (v886)
                        {
                          uint64_t v887 = *v886;
                          if (!*v886)
                          {
                            unsigned __int16 v897 = (_WORD)v886 - (_WORD)v885 + 1;
                            if (v897 > 0x100u) {
                              break;
                            }
                            memcpy((void *)(v879 + 652), v885, v897);
                            goto LABEL_1543;
                          }

                          v886 += v887 + 1;
                          if (v885 != (_BYTE *)-256LL) {
                            goto LABEL_1503;
                          }
                        }
                      }

                      else
                      {
LABEL_1503:
                        if (v886 < v885 + 256) {
                          goto LABEL_1504;
                        }
                      }

                      *(_BYTE *)(v879 + 652) = 0;
LABEL_1543:
                      *(_WORD *)(v879 + 14) = 1440;
                      int v898 = *((_DWORD *)rr_from_ipc_msg + 6);
                      *(_DWORD *)(v879 + memset(v45, 0, 20) = 917518;
                      *(_DWORD *)(v879 + 24) = v898;
                      uint64_t v899 = *(void *)(v879 + 48);
                      *(_DWORD *)(v899 + 4) = 720362;
                      *(_DWORD *)(v899 + 8) = v1409;
                      *(_DWORD *)(v899 + 12) = v877;
                      *(_WORD *)(v899 + 16) = 0;
                      *(void *)(v879 + 104) = regrecord_callback;
                      SetNewRData(v879 + 8, 0LL, 0LL, v880, v881, v882, v883, v884);
                      int v900 = *(_DWORD *)(v76 + 232);
                      *(_BYTE *)(v879 + 122) = (v900 & 0x400) != 0;
                      __int128 v901 = (os_log_s *)mDNSLogCategory_mDNS;
                      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
                      {
                        if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
                          goto LABEL_1548;
                        }
                      }

                      else
                      {
                        __int128 v901 = (os_log_s *)mDNSLogCategory_mDNS_redacted;
                        if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
                        {
LABEL_1548:
                          int v902 = *(_DWORD *)(v76 + 184);
                          uid_t v1396 = *(_DWORD *)(v76 + 236);
                          GetRRDisplayString_rdb( (unsigned __int8 *)(v879 + 8),  (unsigned __int16 *)(*(void *)(v879 + 48) + 4LL),  word_100164338);
                          int v903 = *(_DWORD *)(v76 + 172);
                          v1489.dev_t st_dev = 67110659;
                          *(_DWORD *)&v1489.st_mode = v902;
                          LOWORD(v1489.st_ino) = 1024;
                          *(_DWORD *)((char *)&v1489.st_ino + 2) = v900;
                          HIWORD(v1489.st_ino) = 1024;
                          v1489.st_uid = v1396;
                          LOWORD(v1489.st_gid) = 2160;
                          *(void *)((char *)&v1489.st_gid + 2) = 1752392040LL;
                          *((_WORD *)&v1489.st_rdev + 3) = 2085;
                          v1489.st_atimespec.tv_sec = (__darwin_time_t)word_100164338;
                          LOWORD(v1489.st_atimespec.tv_nsec) = 1024;
                          *(_DWORD *)((char *)&v1489.st_atimespec.tv_nsec + 2) = v903;
                          HIWORD(v1489.st_atimespec.tv_nsec) = 2082;
                          v1489.st_mtimespec.tv_sec = v76 + 240;
                          _os_log_impl( (void *)&_mh_execute_header,  v901,  OS_LOG_TYPE_DEFAULT,  "[R%d] regRecordAddTSRRecord(0x%X, %d, %{sensitive, mask.hash}s) START PID[%d](%{public}s)",  (uint8_t *)&v1489,  0x38u);
                        }
                      }

                      int v904 = mDNS_Register((unsigned int *)mDNSStorage, v879);
                      if (!v904)
                      {
                        if (mDNS_McastLoggingEnabled) {
                          LogMcastService(v879, v76, 1, v905, v906, v907, v908, v909, v1313);
                        }
                        *(void *)(v879 + 96) = *(int *)(v76 + 168);
LABEL_1557:
                        v911 = (os_log_s *)mDNSLogCategory_mDNS;
                        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
                        {
                          int updated = 0;
                          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
                            goto LABEL_1122;
                          }
                        }

                        else
                        {
                          v911 = (os_log_s *)mDNSLogCategory_mDNS_redacted;
                          int updated = 0;
                          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
                            goto LABEL_1122;
                          }
                        }

                        v1489.dev_t st_dev = 67109632;
                        *(_DWORD *)&v1489.st_mode = v1409;
                        LOWORD(v1489.st_ino) = 1024;
                        *(_DWORD *)((char *)&v1489.st_ino + 2) = __src[0];
                        HIWORD(v1489.st_ino) = 1024;
                        v1489.st_uid = *(_DWORD *)buf;
                        _os_log_impl( (void *)&_mh_execute_header,  v911,  OS_LOG_TYPE_DEFAULT,  "handle_regrecord_request: TSR record added with timestampContinuous %d tsrTimestamp %d tsrHostkeyHash %x",  (uint8_t *)&v1489,  0x14u);
                        goto LABEL_666;
                      }

                      int updated = v904;
                      v910 = (os_log_s *)mDNSLogCategory_mDNS;
                      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
                      {
                        if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
                          goto LABEL_1564;
                        }
                      }

                      else
                      {
                        v910 = (os_log_s *)mDNSLogCategory_mDNS_redacted;
                        if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
                        {
LABEL_1564:
                          int v912 = *(_DWORD *)(v76 + 184);
                          int v1397 = *(_DWORD *)(v76 + 232);
                          uid_t v1417 = *(_DWORD *)(v76 + 236);
                          GetRRDisplayString_rdb( (unsigned __int8 *)(v879 + 8),  (unsigned __int16 *)(*(void *)(v879 + 48) + 4LL),  word_100164338);
                          v1489.dev_t st_dev = 67110403;
                          *(_DWORD *)&v1489.st_mode = v912;
                          LOWORD(v1489.st_ino) = 1024;
                          *(_DWORD *)((char *)&v1489.st_ino + 2) = v1397;
                          HIWORD(v1489.st_ino) = 1024;
                          v1489.st_uid = v1417;
                          LOWORD(v1489.st_gid) = 2160;
                          *(void *)((char *)&v1489.st_gid + 2) = 1752392040LL;
                          *((_WORD *)&v1489.st_rdev + 3) = 2085;
                          v1489.st_atimespec.tv_sec = (__darwin_time_t)word_100164338;
                          LOWORD(v1489.st_atimespec.tv_nsec) = 1024;
                          *(_DWORD *)((char *)&v1489.st_atimespec.tv_nsec + 2) = updated;
                          _os_log_impl( (void *)&_mh_execute_header,  v910,  OS_LOG_TYPE_DEFAULT,  "[R%d] regRecordAddTSRRecord(0x%X, %d,%{sensitive, mask.hash}s) ERROR (%d)",  (uint8_t *)&v1489,  0x2Eu);
                        }
                      }

                      free((void *)v879);
                      goto LABEL_1566;
                    }

                    int updated = updateTSRRecord(v76, (uint64_t)v1392, v1409, *(int *)buf);
                    if (!updated) {
                      goto LABEL_1557;
                    }
LABEL_1566:
                    __int128 v913 = (os_log_s *)mDNSLogCategory_mDNS;
                    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
                    {
                      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_ERROR)) {
                        goto LABEL_1572;
                      }
                    }

                    else
                    {
                      __int128 v913 = (os_log_s *)mDNSLogCategory_mDNS_redacted;
                      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_ERROR)) {
                        goto LABEL_1572;
                      }
                    }

                    v1489.dev_t st_dev = 67109120;
                    *(_DWORD *)&v1489.st_mode = updated;
                    _os_log_impl( (void *)&_mh_execute_header,  v913,  OS_LOG_TYPE_ERROR,  "handle_regrecord_request: Failed to add TSR record with error %d",  (uint8_t *)&v1489,  8u);
LABEL_1572:
                    __int128 v914 = (void *)rr_from_ipc_msg[14];
                    do
                    {
                      __int128 v915 = v876;
                      __int128 v916 = (void *)*v876;
                      v876 = (void *)(*v876 + 8LL);
                      if (v916) {
                        BOOL v917 = v916 == v914;
                      }
                      else {
                        BOOL v917 = 1;
                      }
                    }

                    while (!v917);
                    if (v916)
                    {
                      *__int128 v915 = *v876;
                      __int128 v918 = (os_log_s *)mDNSLogCategory_mDNS;
                      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
                      {
                        if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_ERROR)) {
                          goto LABEL_1594;
                        }
                      }

                      else
                      {
                        __int128 v918 = (os_log_s *)mDNSLogCategory_mDNS_redacted;
                        if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_ERROR))
                        {
LABEL_1594:
                          int v923 = *(_DWORD *)(v76 + 184);
                          GetRRDisplayString_rdb( (unsigned __int8 *)rr_from_ipc_msg + 8,  (unsigned __int16 *)(rr_from_ipc_msg[6] + 4LL),  word_100164338);
                          uint64_t v924 = rr_from_ipc_msg[4];
                          v1489.dev_t st_dev = 67110147;
                          *(_DWORD *)&v1489.st_mode = v923;
                          LOWORD(v1489.st_ino) = 2160;
                          *(__darwin_ino64_t *)((char *)&v1489.st_ino + 2) = 1752392040LL;
                          HIWORD(v1489.st_uid) = 2085;
                          *(void *)&v1489.st_gid = word_100164338;
                          *((_WORD *)&v1489.st_rdev + 2) = 2048;
                          *(void *)((char *)&v1489.st_rdev + 6) = rr_from_ipc_msg;
                          HIWORD(v1489.st_atimespec.tv_sec) = 2048;
                          v1489.st_atimespec.tv_nsec = v924;
                          _os_log_impl( (void *)&_mh_execute_header,  v918,  OS_LOG_TYPE_ERROR,  "[R%u] handle_regrecord_request: TSR fail, removing %{sensitive, mask.hash}s (%p), InterfaceID %p",  (uint8_t *)&v1489,  0x30u);
                        }
                      }

                      rr_from_ipc_msg[14] = 0LL;
                      mDNS_Deregister((unsigned int *)mDNSStorage, (uint64_t)rr_from_ipc_msg);
                      if (!v914) {
                        goto LABEL_1122;
                      }
                      int v732 = v914;
                      goto LABEL_1210;
                    }

                    uint64_t v920 = mDNSLogCategory_mDNS;
                    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
                    {
                      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_ERROR)) {
                        goto LABEL_1122;
                      }
                    }

                    else
                    {
                      uint64_t v920 = mDNSLogCategory_mDNS_redacted;
                      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_ERROR)) {
                        goto LABEL_1122;
                      }
                    }

                    int v926 = *(_DWORD *)(v76 + 184);
                    v1489.dev_t st_dev = 67109120;
                    *(_DWORD *)&v1489.st_mode = v926;
                    uint64_t v800 = (os_log_s *)v920;
                    os_log_type_t v801 = OS_LOG_TYPE_ERROR;
                    uint64_t v802 = "[R%u] handle_regrecord_request - record not in list!";
                    uint32_t v803 = 8;
LABEL_1839:
                    _os_log_impl((void *)&_mh_execute_header, v800, v801, v802, (uint8_t *)&v1489, v803);
LABEL_1122:
                    unsigned __int16 v675 = *(void **)(v76 + 64);
                    if (v675)
                    {
                      free(v675);
                      *(void *)(v76 + 64) = 0LL;
                    }

                    unsigned int v676 = *(_DWORD *)(v76 + 212);
                    BOOL v171 = v676 > 0x3F;
                    unint64_t v677 = (1LL << v676) & 0x8000000000022000LL;
                    if (!v171 && v677 != 0) {
                      goto LABEL_1128;
                    }
                    unsigned int v679 = bswap32(updated);
                    *(_DWORD *)&v1504[0].sa_leuint64_t n = v679;
                    if ((*(_BYTE *)(v76 + 208) & 4) == 0)
                    {
                      send_all(*(_DWORD *)(v76 + 176), v1504, 4uLL);
                      goto LABEL_1142;
                    }

                    uint64_t v680 = (os_log_s *)mDNSLogCategory_Default;
                    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
                    {
                      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
                        goto LABEL_1140;
                      }
                    }

                    else
                    {
                      uint64_t v680 = (os_log_s *)mDNSLogCategory_Default_redacted;
                      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
                        goto LABEL_1140;
                      }
                    }

                    int v681 = *(_DWORD *)(v76 + 184);
                    v1489.dev_t st_dev = 67109376;
                    *(_DWORD *)&v1489.st_mode = v681;
                    LOWORD(v1489.st_ino) = 1024;
                    *(_DWORD *)((char *)&v1489.st_ino + 2) = updated;
                    _os_log_impl( (void *)&_mh_execute_header,  v680,  OS_LOG_TYPE_DEFAULT,  "[R%u] returnAsyncErrorCode: error code(%d)",  (uint8_t *)&v1489,  0xEu);
LABEL_1140:
                    if (updated)
                    {
                      reply = create_reply((char *)0x49, 18LL, v76, a4, a5, a6, a7, a8);
                      *((_DWORD *)reply + 11) = 0;
                      *((_DWORD *)reply + 12) = 0;
                      *((_DWORD *)reply + 13) = v679;
                      *((_DWORD *)reply + 14) = 0;
                      *((_WORD *)reply + 30) = 0;
                      append_reply(v76, reply);
                    }

LABEL_1142:
                    int v683 = *(_DWORD *)(v76 + 176);
                    if (v683 != *(_DWORD *)(v76 + 168))
                    {
                      close(v683);
                      *(_DWORD *)(v76 + 176) = *(_DWORD *)(v76 + 168);
                      uint64_t v684 = *(void *)(v76 + 24);
                      if (v684) {
                        *(_DWORD *)(v684 + 176) = *(_DWORD *)(v684 + 168);
                      }
                    }

LABEL_1128:
                    if (*(void *)(v76 + 24)) {
                      uint64_t v8 = *(void *)(v76 + 24);
                    }
                    else {
                      uint64_t v8 = v76;
                    }
                    unsigned __int8 v9 = 1;
                    *(_BYTE *)(v8 + 275) = 1;
                    *(_DWORD *)(v8 + 196) = 0;
                    *(_OWORD *)(v8 + 56) = 0u;
                    *(_OWORD *)(v8 + 72) = 0u;
                    continue;
                  case 3:
                    uint64_t v102 = *(void *)(v76 + 72);
                    if (v102 && (unint64_t v103 = v102 + 4, v103 <= *(void *)(v76 + 80)))
                    {
                      *(void *)(v76 + 72) = v103;
                      if (v103)
                      {
                        unsigned __int16 v104 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, int))(v76 + 96);
                        uint64_t v105 = v76;
                        if ((char *)v104 != (char *)connection_termination
                          || (uint64_t SubordinateRequest = LocateSubordinateRequest(v76),
                              uint64_t v105 = SubordinateRequest,
                              unsigned __int16 v104 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, int))(SubordinateRequest + 96),
                              (char *)v104 != (char *)connection_termination))
                        {
                          if (v104 != regservice_termination_callback)
                          {
                            uint64_t v112 = mDNSLogCategory_mDNS;
                            if (gSensitiveLoggingEnabled == 1 && mDNSLogCategory_mDNS != mDNSLogCategory_State)
                            {
                              uint64_t v112 = mDNSLogCategory_mDNS_redacted;
                              int updated = -65540;
                              if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
                                goto LABEL_1122;
                              }
LABEL_203:
                              int v113 = *(_DWORD *)(v105 + 184);
                              v1489.dev_t st_dev = 67109120;
                              *(_DWORD *)&v1489.st_mode = v113;
                              uint64_t v114 = &v1489;
                              uint64_t v115 = (os_log_s *)v112;
                              os_log_type_t v116 = OS_LOG_TYPE_DEFAULT;
                              unsigned int v117 = "[R%d] DNSServiceRemoveRecord(not a registered service ref)";
                              goto LABEL_1119;
                            }

                            int updated = -65540;
                            if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
                              goto LABEL_203;
                            }
                            goto LABEL_1122;
                          }

                          uint64_t v419 = *(void *)(v105 + 112);
                          uint64_t v420 = *(uint64_t **)(v419 + 1624);
                          unsigned __int16 v421 = 0;
                          if (v420)
                          {
                            do
                            {
                              unint64_t v422 = v420 + 39;
                              unint64_t v423 = v420 + 39;
                              do
                              {
                                unint64_t v423 = (uint64_t *)*v423;
                                if (!v423) {
                                  goto LABEL_690;
                                }
                              }

                              while (*((_DWORD *)v423 + 2) != *(_DWORD *)(v105 + 224));
                              unsigned __int16 v421 = *((_WORD *)v423 + 14);
                              if (*((_BYTE *)v420 + 27)) {

                              }
                                internal_stop_advertising_service( (uint64_t)(v423 + 3),  *(_DWORD *)(v105 + 232),  *(_DWORD *)(v105 + 172));
                              mDNS_Lock_((unsigned int *)mDNSStorage, (uint64_t)"mDNS_RemoveRecordFromService", 17606);
                              do
                              {
                                uint64_t v424 = v422;
                                unint64_t v422 = (uint64_t *)*v422;
                                if (v422) {
                                  BOOL v425 = v422 == v423;
                                }
                                else {
                                  BOOL v425 = 1;
                                }
                              }

                              while (!v425);
                              if (!v422)
                              {
                                mDNS_Unlock_((uint64_t)mDNSStorage, (uint64_t)"mDNS_RemoveRecordFromService", 17622);
LABEL_690:
                                int updated = -65541;
                                goto LABEL_691;
                              }

                              v423[15] = (uint64_t)FreeExtraRR;
                              v423[16] = (uint64_t)v423;
                              uint64_t *v424 = *(void *)*v424;
                              int updated = mDNS_Deregister_internal((uint64_t)mDNSStorage, (uint64_t)(v423 + 2), 0);
                              mDNS_Unlock_((uint64_t)mDNSStorage, (uint64_t)"mDNS_RemoveRecordFromService", 17622);
                              if (!updated) {
                                goto LABEL_692;
                              }
LABEL_691:
                              if (*((_BYTE *)v420 + 26)) {
                                goto LABEL_955;
                              }
LABEL_692:
                              uint64_t v420 = (uint64_t *)*v420;
                            }

                            while (v420);
                            int updated = 0;
                          }

                          else
                          {
                            int updated = -65541;
                          }

LABEL_955:
                          uint64_t v581 = mDNSLogCategory_mDNS;
                          if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
                          {
                            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
                              goto LABEL_1122;
                            }
                            uint64_t v583 = *(void *)(v419 + 1624);
                            if (v583)
                            {
                              uint64_t v584 = *(void *)(v583 + 2736);
                              if (v584)
                              {
                                int v585 = *(_BYTE **)(v583 + 2736);
                                if (v584 == -256) {
                                  goto LABEL_967;
                                }
LABEL_964:
                                unsigned __int16 v586 = 257;
                                if ((unint64_t)v585 < v584 + 256 && v585)
                                {
                                  while (1)
                                  {
                                    uint64_t v587 = *v585;
                                    if (v587 > 0x3F)
                                    {
LABEL_1308:
                                      unsigned __int16 v586 = 257;
                                      goto LABEL_1333;
                                    }

                                    if (!*v585) {
                                      break;
                                    }
                                    v585 += v587 + 1;
                                    if (v584 != -256) {
                                      goto LABEL_964;
                                    }
LABEL_967:
                                    if (!v585) {
                                      goto LABEL_1308;
                                    }
                                  }

                                  unsigned __int16 v586 = (_WORD)v585 - v584 + 1;
                                }

LABEL_1333:
                                gid_t v709 = v586;
                              }

                              else
                              {
                                gid_t v709 = 0;
                              }
                            }

                            else
                            {
                              gid_t v709 = 0;
                              uint64_t v584 = 0LL;
                            }

                            int v797 = *(_DWORD *)(v105 + 184);
                            if (!v421)
                            {
                              uint64_t v798 = "<NONE>";
LABEL_1341:
                              int v799 = *(_DWORD *)(v105 + 172);
                              v1489.dev_t st_dev = 67110915;
                              *(_DWORD *)&v1489.st_mode = v797;
                              LOWORD(v1489.st_ino) = 2160;
                              *(__darwin_ino64_t *)((char *)&v1489.st_ino + 2) = 1752392040LL;
                              HIWORD(v1489.st_uid) = 1040;
                              v1489.st_gid = v709;
                              LOWORD(v1489.st_rdev) = 2101;
                              *(void *)((char *)&v1489.st_rdev + 2) = v584;
                              WORD1(v1489.st_atimespec.tv_sec) = 2082;
                              *(__darwin_time_t *)((char *)&v1489.st_atimespec.tv_sec + 4) = (__darwin_time_t)v798;
                              WORD2(v1489.st_atimespec.tv_nsec) = 1024;
                              *(_DWORD *)((char *)&v1489.st_atimespec.tv_nsec + 6) = v799;
                              WORD1(v1489.st_mtimespec.tv_sec) = 2082;
                              *(__darwin_time_t *)((char *)&v1489.st_mtimespec.tv_sec + 4) = v105 + 240;
                              WORD2(v1489.st_mtimespec.tv_nsec) = 1024;
                              *(_DWORD *)((char *)&v1489.st_mtimespec.tv_nsec + 6) = updated;
                              uint64_t v800 = (os_log_s *)v581;
                              os_log_type_t v801 = OS_LOG_TYPE_DEFAULT;
                              uint64_t v802 = "[R%d] DNSServiceRemoveRecord(%{sensitive, mask.hash, mdnsresponder:domain_name}.*P,"
                                     " %{public}s) PID[%d](%{public}s): %d";
                              uint32_t v803 = 66;
                              goto LABEL_1839;
                            }
                          }

                          else
                          {
                            uint64_t v581 = mDNSLogCategory_mDNS_redacted;
                            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
                              goto LABEL_1122;
                            }
                            uint64_t v589 = *(void *)(v419 + 1624);
                            if (v589)
                            {
                              uint64_t v584 = *(void *)(v589 + 2736);
                              if (v584)
                              {
                                v590 = *(_BYTE **)(v589 + 2736);
                                if (v584 == -256) {
                                  goto LABEL_979;
                                }
LABEL_976:
                                unsigned __int16 v591 = 257;
                                if ((unint64_t)v590 < v584 + 256 && v590)
                                {
                                  while (1)
                                  {
                                    uint64_t v592 = *v590;
                                    if (v592 > 0x3F)
                                    {
LABEL_1309:
                                      unsigned __int16 v591 = 257;
                                      goto LABEL_1337;
                                    }

                                    if (!*v590) {
                                      break;
                                    }
                                    v590 += v592 + 1;
                                    if (v584 != -256) {
                                      goto LABEL_976;
                                    }
LABEL_979:
                                    if (!v590) {
                                      goto LABEL_1309;
                                    }
                                  }

                                  unsigned __int16 v591 = (_WORD)v590 - v584 + 1;
                                }

LABEL_1337:
                                gid_t v709 = v591;
                              }

                              else
                              {
                                gid_t v709 = 0;
                              }
                            }

                            else
                            {
                              gid_t v709 = 0;
                              uint64_t v584 = 0LL;
                            }

                            int v797 = *(_DWORD *)(v105 + 184);
                            if (!v421)
                            {
                              uint64_t v798 = "<NONE>";
                              goto LABEL_1341;
                            }
                          }

                          uint64_t v798 = DNSTypeName(v421);
                          goto LABEL_1341;
                        }

                        uint64_t v558 = (void *)(SubordinateRequest + 160);
                        rr_from_ipc_msg = *(void **)(SubordinateRequest + 160);
                        int v559 = *(_DWORD *)(SubordinateRequest + 224);
                        if (!rr_from_ipc_msg) {
                          goto LABEL_1034;
                        }
                        if (*((_DWORD *)rr_from_ipc_msg + 14) != v559)
                        {
                          do
                          {
                            int v560 = rr_from_ipc_msg;
                            rr_from_ipc_msg = (void *)rr_from_ipc_msg[1];
                            if (!rr_from_ipc_msg)
                            {
LABEL_1034:
                              v1314 = (sockaddr *)*(unsigned int *)(SubordinateRequest + 224);
                              LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "%3d: DNSServiceRemoveRecord(%u) not found",  v107,  v108,  v109,  v110,  v111,  *(_DWORD *)(SubordinateRequest + 168));
                              int updated = -65541;
                              goto LABEL_1122;
                            }
                          }

                          while (*((_DWORD *)rr_from_ipc_msg + 14) != v559);
                          uint64_t v558 = v560 + 1;
                        }

                        *uint64_t v558 = rr_from_ipc_msg[1];
                        uint64_t v561 = rr_from_ipc_msg[3];
                        uid_t v562 = mDNSPlatformInterfaceIndexfromInterfaceID( (uint64_t **)mDNSStorage,  *(void *)(v561 + 32),  1LL,  v107,  v108,  v109,  v110,  v111);
                        uid_t v563 = mDNS_DomainNameFNV1aHash(*(unsigned __int8 **)(v561 + 40));
                        BOOL v564 = _shouldLogFullRequestInfo((int *)rr_from_ipc_msg + 12, (_DWORD *)rr_from_ipc_msg + 13);
                        v1489.st_ino = 0LL;
                        *(void *)&v1489.dev_t st_dev = 0LL;
                        clock_gettime(_CLOCK_MONOTONIC_RAW, (timespec *)&v1489);
                        int v568 = v1489.st_dev - *((_DWORD *)rr_from_ipc_msg + 12);
                        if (v564)
                        {
                          uid_t v1411 = v562;
                          unint64_t v569 = *(unsigned __int16 *)(v561 + 20);
                          if (v569 >= 0x201)
                          {
                            uint64_t v570 = (char *)malloc(*(unsigned __int16 *)(v561 + 20));
                            uint64_t v571 = v570;
                            if (!v570) {
                              goto LABEL_2255;
                            }
LABEL_1229:
                            *(_DWORD *)&v1504[0].sa_leuint64_t n = 0;
                            LOWORD(__src[0]) = 0;
                            uint64_t v738 = ResourceRecordGetRDataBytesPointer( v561 + 8,  v571,  v569,  __src,  (int *)v1504,  v565,  v566,  v567);
                            if (*(_DWORD *)&v1504[0].sa_len)
                            {
LABEL_2016:
                              if (v570) {
                                free(v570);
                              }
LABEL_2109:
                              uint64_t v1242 = rr_from_ipc_msg[3];
                              *(void *)(v1242 + 112) = 0LL;
                              if (*((_BYTE *)rr_from_ipc_msg + 60))
                              {
                                internal_stop_advertising_service( v1242 + 8,  *(_DWORD *)(v105 + 232),  *(_DWORD *)(v105 + 172));
                                *((_BYTE *)rr_from_ipc_msg + 60) = 0;
                                uint64_t v1242 = rr_from_ipc_msg[3];
                              }

                              if (mDNS_McastLoggingEnabled)
                              {
                                LogMcastService(v1242, v105, 0, v718, v719, v720, v721, v722, v1313);
                                uint64_t v1242 = rr_from_ipc_msg[3];
                              }

                              if (*rr_from_ipc_msg)
                              {
                                uint64_t v1243 = *(unsigned int *)(v105 + 236);
                                if ((_DWORD)v1243)
                                {
                                  if (AWDLInterfaceID && AWDLInterfaceID == v1243)
                                  {
                                    int v1244 = 1;
                                  }

                                  else
                                  {
                                    if (WiFiAwareInterfaceID) {
                                      BOOL v1245 = WiFiAwareInterfaceID == v1243;
                                    }
                                    else {
                                      BOOL v1245 = 0;
                                    }
                                    int v1244 = v1245;
                                  }
                                }

                                else
                                {
                                  int v1244 = (*(_DWORD *)(v105 + 232) >> 20) & 1;
                                }

                                mdns_powerlog_register_record_stop( (const char *)(v105 + 240),  *(unsigned __int8 **)(v1242 + 40),  *rr_from_ipc_msg,  v1244);
                                uint64_t v1242 = rr_from_ipc_msg[3];
                              }

                              int updated = mDNS_Deregister((unsigned int *)mDNSStorage, v1242);
                              if (updated)
                              {
                                LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "ERROR: remove_record, mDNS_Deregister: %d",  v1246,  v1247,  v1248,  v1249,  v1250,  updated);
                                v1053 = (__uint64_t *)rr_from_ipc_msg[3];
                                if (v1053) {
                                  goto LABEL_1858;
                                }
                              }

                              goto LABEL_1859;
                            }

                            v1350 = (const void *)v738;
                            int v1369 = v568;
                            size_t v739 = LOWORD(__src[0]);
                            uid_t __nf = v563;
                            if (LOWORD(__src[0]) >= 0x1FFuLL)
                            {
                              unsigned int v741 = LOWORD(__src[0]) + 2;
                              v742 = (__int16 *)malloc(LOWORD(__src[0]) + 2LL);
                              if (!v742) {
                                goto LABEL_2255;
                              }
                              v740 = v742;
                            }

                            else
                            {
                              v740 = 0LL;
                              unsigned int v741 = 512;
                              v742 = word_100164338;
                            }

                            v1344 = v742;
                            v1398 = v740;
                            uint64_t v931 = mDNSLogCategory_mDNS;
                            if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
                            {
                              if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
                                goto LABEL_2014;
                              }
                              v936 = *(_BYTE **)(v561 + 40);
                              if (v936)
                              {
                                v937 = v936 + 256;
                                uint64_t v1335 = *(void *)(v561 + 40);
                                if (v936 == (_BYTE *)-256LL)
                                {
LABEL_1645:
                                  while (v936)
                                  {
                                    uint64_t v938 = *v936;
                                    if (!*v936)
                                    {
                                      unsigned __int16 v1081 = (_WORD)v936 - v1335 + 1;
                                      goto LABEL_2008;
                                    }

                                    v936 += v938 + 1;
                                    if (v937) {
                                      goto LABEL_1644;
                                    }
                                  }
                                }

                                else
                                {
LABEL_1644:
                                  if (v936 < v937) {
                                    goto LABEL_1645;
                                  }
                                }

                                unsigned __int16 v1081 = 257;
LABEL_2008:
                                int v1096 = v1081;
                              }

                              else
                              {
                                uint64_t v1335 = 0LL;
                                int v1096 = 0;
                              }

                              int v1172 = *(_DWORD *)(v105 + 184);
                              int v1173 = *((_DWORD *)rr_from_ipc_msg + 14);
                              gid_t v1174 = *(_DWORD *)(v105 + 172);
                              unsigned int v1175 = *(unsigned __int16 *)(v561 + 12);
                              int v1176 = v739 + 2;
                              if ((int)v739 + 2 <= v741)
                              {
                                off_t v1177 = (off_t)v1344;
                                v1178 = v1350;
                                __int16 *v1344 = __rev16(v1175);
                                size_t v1179 = v739;
                                int v1323 = v1173;
                                int v1331 = v1096;
                                unsigned int v1319 = v1175;
                                int v1358 = v739 + 2;
                                gid_t v1180 = v1174;
                                int v1181 = v1172;
                                memcpy(v1344 + 1, v1178, v1179);
                                int v1172 = v1181;
                                unsigned int v1175 = v1319;
                                int v1173 = v1323;
                                gid_t v1174 = v1180;
                                int v1176 = v1358;
                                int v1096 = v1331;
                              }

                              else
                              {
                                off_t v1177 = 0LL;
                              }

                              v1489.dev_t st_dev = 67112451;
                              *(_DWORD *)&v1489.st_mode = v1172;
                              LOWORD(v1489.st_ino) = 1024;
                              *(_DWORD *)((char *)&v1489.st_ino + 2) = v1173;
                              HIWORD(v1489.st_ino) = 1024;
                              v1489.st_uid = v1411;
                              LOWORD(v1489.st_gid) = 1024;
                              *(gid_t *)((char *)&v1489.st_gid + 2) = v1174;
                              HIWORD(v1489.st_rdev) = 2082;
                              *(void *)(&v1489.st_rdev + 1) = v105 + 240;
                              WORD2(v1489.st_atimespec.tv_sec) = 1024;
                              *(_DWORD *)((char *)&v1489.st_atimespec.tv_sec + 6) = v1369;
                              WORD1(v1489.st_atimespec.tv_nsec) = 2160;
                              *(uint64_t *)((char *)&v1489.st_atimespec.tv_nsec + 4) = 1752392040LL;
                              WORD2(v1489.st_mtimespec.tv_sec) = 1040;
                              *(_DWORD *)((char *)&v1489.st_mtimespec.tv_sec + 6) = v1096;
                              WORD1(v1489.st_mtimespec.tv_nsec) = 2101;
                              *(uint64_t *)((char *)&v1489.st_mtimespec.tv_nsec + 4) = v1335;
                              WORD2(v1489.st_ctimespec.tv_sec) = 1024;
                              *(_DWORD *)((char *)&v1489.st_ctimespec.tv_sec + 6) = __nf;
                              WORD1(v1489.st_ctimespec.tv_nsec) = 1024;
                              HIDWORD(v1489.st_ctimespec.tv_nsec) = v1175;
                              LOWORD(v1489.st_birthtimespec.tv_sec) = 2160;
                              *(__darwin_time_t *)((char *)&v1489.st_birthtimespec.tv_sec + 2) = 1752392040LL;
                              WORD1(v1489.st_birthtimespec.tv_nsec) = 1040;
                              HIDWORD(v1489.st_birthtimespec.tv_nsec) = v1176;
                              LOWORD(v1489.st_size) = 2101;
                              *(off_t *)((char *)&v1489.st_size + 2) = v1177;
                              v1171 = (os_log_s *)v931;
                            }

                            else
                            {
                              uint64_t v932 = mDNSLogCategory_mDNS_redacted;
                              if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
                                goto LABEL_2014;
                              }
                              v1326 = (os_log_s *)v932;
                              v933 = *(_BYTE **)(v561 + 40);
                              if (v933)
                              {
                                v934 = v933 + 256;
                                uint64_t v1334 = *(void *)(v561 + 40);
                                if (v933 == (_BYTE *)-256LL)
                                {
LABEL_1636:
                                  while (v933)
                                  {
                                    uint64_t v935 = *v933;
                                    if (!*v933)
                                    {
                                      unsigned __int16 v1080 = (_WORD)v933 - v1334 + 1;
                                      goto LABEL_2002;
                                    }

                                    v933 += v935 + 1;
                                    if (v934) {
                                      goto LABEL_1635;
                                    }
                                  }
                                }

                                else
                                {
LABEL_1635:
                                  if (v933 < v934) {
                                    goto LABEL_1636;
                                  }
                                }

                                unsigned __int16 v1080 = 257;
LABEL_2002:
                                int v1095 = v1080;
                              }

                              else
                              {
                                uint64_t v1334 = 0LL;
                                int v1095 = 0;
                              }

                              int v1162 = *(_DWORD *)(v105 + 184);
                              int v1163 = *((_DWORD *)rr_from_ipc_msg + 14);
                              gid_t v1164 = *(_DWORD *)(v105 + 172);
                              unsigned int v1165 = *(unsigned __int16 *)(v561 + 12);
                              int v1166 = v739 + 2;
                              if ((int)v739 + 2 <= v741)
                              {
                                off_t v1167 = (off_t)v1344;
                                v1168 = v1350;
                                __int16 *v1344 = __rev16(v1165);
                                size_t v1169 = v739;
                                int v1318 = v1095;
                                int v1322 = v1163;
                                gid_t v1357 = v1164;
                                int v1170 = v1162;
                                memcpy(v1344 + 1, v1168, v1169);
                                int v1162 = v1170;
                                int v1095 = v1318;
                                int v1163 = v1322;
                                gid_t v1164 = v1357;
                              }

                              else
                              {
                                off_t v1167 = 0LL;
                              }

                              v1489.dev_t st_dev = 67112451;
                              *(_DWORD *)&v1489.st_mode = v1162;
                              LOWORD(v1489.st_ino) = 1024;
                              *(_DWORD *)((char *)&v1489.st_ino + 2) = v1163;
                              HIWORD(v1489.st_ino) = 1024;
                              v1489.st_uid = v1411;
                              LOWORD(v1489.st_gid) = 1024;
                              *(gid_t *)((char *)&v1489.st_gid + 2) = v1164;
                              HIWORD(v1489.st_rdev) = 2082;
                              *(void *)(&v1489.st_rdev + 1) = v105 + 240;
                              WORD2(v1489.st_atimespec.tv_sec) = 1024;
                              *(_DWORD *)((char *)&v1489.st_atimespec.tv_sec + 6) = v1369;
                              WORD1(v1489.st_atimespec.tv_nsec) = 2160;
                              *(uint64_t *)((char *)&v1489.st_atimespec.tv_nsec + 4) = 1752392040LL;
                              WORD2(v1489.st_mtimespec.tv_sec) = 1040;
                              *(_DWORD *)((char *)&v1489.st_mtimespec.tv_sec + 6) = v1095;
                              WORD1(v1489.st_mtimespec.tv_nsec) = 2101;
                              v1171 = v1326;
                              *(uint64_t *)((char *)&v1489.st_mtimespec.tv_nsec + 4) = v1334;
                              WORD2(v1489.st_ctimespec.tv_sec) = 1024;
                              *(_DWORD *)((char *)&v1489.st_ctimespec.tv_sec + 6) = __nf;
                              WORD1(v1489.st_ctimespec.tv_nsec) = 1024;
                              HIDWORD(v1489.st_ctimespec.tv_nsec) = v1165;
                              LOWORD(v1489.st_birthtimespec.tv_sec) = 2160;
                              *(__darwin_time_t *)((char *)&v1489.st_birthtimespec.tv_sec + 2) = 1752392040LL;
                              WORD1(v1489.st_birthtimespec.tv_nsec) = 1040;
                              HIDWORD(v1489.st_birthtimespec.tv_nsec) = v1166;
                              LOWORD(v1489.st_size) = 2101;
                              *(off_t *)((char *)&v1489.st_size + 2) = v1167;
                            }

                            _os_log_impl( (void *)&_mh_execute_header,  v1171,  OS_LOG_TYPE_DEFAULT,  "[R%u->Rec%u] DNSServiceRemoveRecord -- ifindex: %d, client pid: %d (%{public}s), duration: %{mdns:time_duration}u, name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P(%x), type: %{mdns:rrtype}d, rdata: %{sensitive, mask.hash, mdns:rdata}.*P",  (uint8_t *)&v1489,  0x6Au);
LABEL_2014:
                            if (v1398) {
                              free(v1398);
                            }
                            goto LABEL_2016;
                          }

                          if (*(_WORD *)(v561 + 20))
                          {
                            uint64_t v570 = 0LL;
                            LODWORD(v569) = 512;
                            uint64_t v571 = (char *)&unk_100164138;
                            goto LABEL_1229;
                          }

                          uint64_t v821 = mDNSLogCategory_mDNS;
                          if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
                          {
                            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
                              goto LABEL_2109;
                            }
                            uint64_t v822 = *(void *)(v561 + 40);
                            if (v822)
                            {
                              int v823 = *(_BYTE **)(v561 + 40);
                              if (v822 == -256)
                              {
LABEL_1736:
                                while (v823)
                                {
                                  uint64_t v992 = *v823;
                                  if (!*v823)
                                  {
                                    LOWORD(v823) = (_WORD)v823 - v822 + 1;
                                    goto LABEL_2106;
                                  }

                                  v823 += v992 + 1;
                                  if (v822 != -256) {
                                    goto LABEL_1735;
                                  }
                                }
                              }

                              else
                              {
LABEL_1735:
                              }

                              LOWORD(v823) = 257;
LABEL_2106:
                              LODWORD(v823) = (unsigned __int16)v823;
                            }

                            else
                            {
                              LODWORD(v823) = 0;
                            }
                          }

                          else
                          {
                            uint64_t v821 = mDNSLogCategory_mDNS_redacted;
                            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
                              goto LABEL_2109;
                            }
                            uint64_t v822 = *(void *)(v561 + 40);
                            if (v822)
                            {
                              int v823 = *(_BYTE **)(v561 + 40);
                              if (v822 == -256)
                              {
LABEL_1388:
                                while (v823)
                                {
                                  uint64_t v824 = *v823;
                                  if (!*v823)
                                  {
                                    LOWORD(v823) = (_WORD)v823 - v822 + 1;
                                    goto LABEL_2104;
                                  }

                                  v823 += v824 + 1;
                                  if (v822 != -256) {
                                    goto LABEL_1387;
                                  }
                                }
                              }

                              else
                              {
LABEL_1387:
                              }

                              LOWORD(v823) = 257;
LABEL_2104:
                              LODWORD(v823) = (unsigned __int16)v823;
                            }

                            else
                            {
                              LODWORD(v823) = 0;
                            }
                          }

                          int v1238 = *(_DWORD *)(v105 + 184);
                          int v1239 = *((_DWORD *)rr_from_ipc_msg + 14);
                          gid_t v1240 = *(_DWORD *)(v105 + 172);
                          int v1241 = *(unsigned __int16 *)(v561 + 12);
                          v1489.dev_t st_dev = 67111683;
                          *(_DWORD *)&v1489.st_mode = v1238;
                          LOWORD(v1489.st_ino) = 1024;
                          *(_DWORD *)((char *)&v1489.st_ino + 2) = v1239;
                          HIWORD(v1489.st_ino) = 1024;
                          v1489.st_uid = v1411;
                          LOWORD(v1489.st_gid) = 1024;
                          *(gid_t *)((char *)&v1489.st_gid + 2) = v1240;
                          HIWORD(v1489.st_rdev) = 2082;
                          *(void *)(&v1489.st_rdev + 1) = v105 + 240;
                          WORD2(v1489.st_atimespec.tv_sec) = 1024;
                          *(_DWORD *)((char *)&v1489.st_atimespec.tv_sec + 6) = v568;
                          WORD1(v1489.st_atimespec.tv_nsec) = 2160;
                          *(uint64_t *)((char *)&v1489.st_atimespec.tv_nsec + 4) = 1752392040LL;
                          WORD2(v1489.st_mtimespec.tv_sec) = 1040;
                          *(_DWORD *)((char *)&v1489.st_mtimespec.tv_sec + 6) = (_DWORD)v823;
                          WORD1(v1489.st_mtimespec.tv_nsec) = 2101;
                          *(uint64_t *)((char *)&v1489.st_mtimespec.tv_nsec + 4) = v822;
                          WORD2(v1489.st_ctimespec.tv_sec) = 1024;
                          *(_DWORD *)((char *)&v1489.st_ctimespec.tv_sec + 6) = v563;
                          WORD1(v1489.st_ctimespec.tv_nsec) = 1024;
                          HIDWORD(v1489.st_ctimespec.tv_nsec) = v1241;
                          uint64_t v787 = (os_log_s *)v821;
                          uint64_t v788 = "[R%u->Rec%u] DNSServiceRemoveRecord -- ifindex: %d, client pid: %d (%{public}s), durati"
                                 "on: %{mdns:time_duration}u, name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P"
                                 "(%x), type: %{mdns:rrtype}d, rdata: <none>";
                          uint32_t v789 = 80;
                        }

                        else
                        {
                          uint64_t v717 = mDNSLogCategory_mDNS;
                          if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
                          {
                            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
                              goto LABEL_2109;
                            }
                          }

                          else
                          {
                            uint64_t v717 = mDNSLogCategory_mDNS_redacted;
                            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
                              goto LABEL_2109;
                            }
                          }

                          int v785 = *(_DWORD *)(v105 + 184);
                          int v786 = *((_DWORD *)rr_from_ipc_msg + 14);
                          v1489.dev_t st_dev = 67109888;
                          *(_DWORD *)&v1489.st_mode = v785;
                          LOWORD(v1489.st_ino) = 1024;
                          *(_DWORD *)((char *)&v1489.st_ino + 2) = v786;
                          HIWORD(v1489.st_ino) = 1024;
                          v1489.st_uid = v563;
                          LOWORD(v1489.st_gid) = 1024;
                          *(gid_t *)((char *)&v1489.st_gid + 2) = v568;
                          uint64_t v787 = (os_log_s *)v717;
                          uint64_t v788 = "[R%u->Rec%u] DNSServiceRemoveRecord -- name hash: %x, duration: %{mdns:time_duration}u";
                          uint32_t v789 = 26;
                        }

                        _os_log_impl( (void *)&_mh_execute_header,  v787,  OS_LOG_TYPE_DEFAULT,  v788,  (uint8_t *)&v1489,  v789);
                        goto LABEL_2109;
                      }
                    }

                    else
                    {
                      *(void *)(v76 + 72) = 0LL;
                    }

                    uint64_t v288 = mDNSLogCategory_mDNS;
                    if (gSensitiveLoggingEnabled == 1 && mDNSLogCategory_mDNS != mDNSLogCategory_State)
                    {
                      uint64_t v288 = mDNSLogCategory_mDNS_redacted;
                      int updated = -65540;
                      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
                        goto LABEL_1122;
                      }
LABEL_434:
                      int v289 = *(_DWORD *)(v76 + 184);
                      v1489.dev_t st_dev = 67109120;
                      *(_DWORD *)&v1489.st_mode = v289;
                      uint64_t v114 = &v1489;
                      uint64_t v115 = (os_log_s *)v288;
                      os_log_type_t v116 = OS_LOG_TYPE_DEFAULT;
                      unsigned int v117 = "[R%d] DNSServiceRemoveRecord(unreadable parameters)";
                      goto LABEL_1119;
                    }

                    int updated = -65540;
                    if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
                      goto LABEL_434;
                    }
                    goto LABEL_1122;
                  case 4:
                    unsigned int v118 = 0LL;
                    uint64_t v119 = 0LL;
                    uint64_t v121 = *(unsigned int **)(v76 + 72);
                    unint64_t v120 = *(void *)(v76 + 80);
                    if (v121 && (unint64_t)(v121 + 1) <= v120)
                    {
                      unsigned int v118 = (sockaddr *)bswap32(*v121);
                      uint64_t v119 = v121 + 1;
                    }

                    int v122 = 0;
                    uint64_t v123 = 0LL;
                    *(void *)(v76 + 72) = v119;
                    else {
                      int v124 = 1;
                    }
                    if (v119 && (unint64_t)(v119 + 1) <= v120)
                    {
                      int v122 = bswap32(*v119);
                      uint64_t v123 = v119 + 1;
                    }

                    *(void *)(v76 + 72) = v123;
                    uint64_t v125 = mDNSPlatformInterfaceIDfromInterfaceIndex(v122, a2, a3, a4, a5, a6, a7, a8);
                    uint64_t v126 = v125;
                    if (v122)
                    {
                      int updated = -65540;
                      if (!v125) {
                        goto LABEL_1122;
                      }
                    }

                    if (!*(void *)(v76 + 72))
                    {
                      uint64_t v404 = mDNSLogCategory_Default;
                      if (gSensitiveLoggingEnabled == 1 && mDNSLogCategory_Default != mDNSLogCategory_State)
                      {
                        uint64_t v404 = mDNSLogCategory_Default_redacted;
                        int updated = -65540;
                        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_ERROR)) {
                          goto LABEL_1122;
                        }
LABEL_653:
                        int v405 = *(_DWORD *)(v76 + 184);
                        v1489.dev_t st_dev = 67109120;
                        *(_DWORD *)&v1489.st_mode = v405;
                        uint64_t v114 = &v1489;
                        uint64_t v115 = (os_log_s *)v404;
                        os_log_type_t v116 = OS_LOG_TYPE_ERROR;
                        unsigned int v117 = "[R%u] DNSServiceEnumerateDomains(unreadable parameters)";
                        goto LABEL_1119;
                      }

                      int updated = -65540;
                      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_ERROR)) {
                        goto LABEL_653;
                      }
                      goto LABEL_1122;
                    }

                    uint64_t v127 = *(void **)(v76 + 104);
                    if (!v127)
                    {
                      int v128 = calloc(1uLL, 0x7B8uLL);
                      if (!v128) {
                        goto LABEL_2255;
                      }
                      uint64_t v127 = v128;
                      *(void *)(v76 + 104) = v128;
                    }

                    *(_DWORD *)(v76 + 232) = (_DWORD)v118;
                    *(_DWORD *)(v76 + 236) = v122;
                    *(_DWORD *)uint64_t v127 = v118 & 0x80;
                    v127[23] = v76;
                    v127[105] = v76;
                    if (v126) {
                      uint64_t v129 = v126;
                    }
                    else {
                      uint64_t v129 = -2LL;
                    }
                    if (mDNS_LoggingEnabled == 1)
                    {
                      unint64_t v130 = "kDNSServiceFlagsRegistrationDomains";
                      v1314 = v118;
                      unint64_t v1315 = (unint64_t)v130;
                      LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "%3d: DNSServiceEnumerateDomains(%X=%s)",  a4,  a5,  a6,  a7,  a8,  *(_DWORD *)(v76 + 168));
                    }

                    int updated = mDNS_GetDomains( (uint64_t)(v127 + 1),  ((char)v118 >> 7) & 3,  0LL,  v129,  (uint64_t)enum_result_callback,  v76);
                    if (updated) {
                      goto LABEL_1122;
                    }
                    int Domains = mDNS_GetDomains((uint64_t)(v127 + 83), v124, 0LL, v129, (uint64_t)enum_result_callback, v76);
                    if (Domains)
                    {
                      int updated = Domains;
                      uint64_t v139 = (uint64_t)(v127 + 1);
                      goto LABEL_233;
                    }

                    if ((v118 & 0x80) != 0)
                    {
                      *(void *)(v76 + 96) = enum_termination_callback;
                      if (mDNS_LoggingEnabled == 1)
                      {
                        v1314 = (sockaddr *)*(unsigned int *)(v76 + 172);
                        unint64_t v1315 = v76 + 240;
                        LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "%3d: DNSServiceEnumerateDomains Start WAB Registration PID[%d](%s)",  v134,  v135,  v136,  v137,  v138,  *(_DWORD *)(v76 + 168));
                      }

                      char v623 = 4;
                    }

                    else
                    {
                      int v573 = mDNS_GetDomains((uint64_t)(v127 + 165), 2, 0LL, v129, (uint64_t)enum_result_callback, v76);
                      if (v573)
                      {
                        int updated = v573;
                        mDNS_StopQuery((unsigned int *)mDNSStorage, (uint64_t)(v127 + 1));
                        uint64_t v139 = (uint64_t)(v127 + 83);
                        goto LABEL_233;
                      }

                      *(void *)(v76 + 96) = enum_termination_callback;
                      if (mDNS_LoggingEnabled == 1)
                      {
                        v1314 = (sockaddr *)*(unsigned int *)(v76 + 172);
                        unint64_t v1315 = v76 + 240;
                        LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "%3d: DNSServiceEnumerateDomains Start WAB Browse PID[%d](%s)",  v134,  v135,  v136,  v137,  v138,  *(_DWORD *)(v76 + 168));
                      }

                      char v623 = 3;
                    }

                    uDNS_StartWABQueries(v623, v132, v133, v134, v135, v136, v137, v138);
                    goto LABEL_666;
                  case 5:
                    uint64_t v140 = 0LL;
                    unsigned int v141 = 0;
                    uint64_t v142 = *(unsigned int **)(v76 + 72);
                    if (v142)
                    {
                      unint64_t v143 = *(void *)(v76 + 80);
                      unsigned int v144 = 0;
                      if ((unint64_t)(v142 + 1) <= v143)
                      {
                        unsigned int v144 = 0;
                        uint64_t v140 = 0LL;
                        unsigned int v141 = bswap32(*v142);
                        *(void *)(v76 + 72) = v142 + 1;
                        if (v142 != (unsigned int *)-4LL && (unint64_t)(v142 + 2) <= v143)
                        {
                          unsigned int v144 = bswap32(v142[1]);
                          uint64_t v140 = v142 + 2;
                        }
                      }
                    }

                    else
                    {
                      unsigned int v144 = 0;
                    }

                    *(void *)(v76 + 72) = v140;
                    if (*(void *)(v76 + 112)) {
                      goto LABEL_496;
                    }
                    uint64_t v330 = calloc(1uLL, 0x660uLL);
                    if (!v330) {
                      goto LABEL_2255;
                    }
                    *(void *)(v76 + 112) = v330;
LABEL_496:
                    if (v144 == -3)
                    {
                      if (mDNS_LoggingEnabled == 1) {
                        LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "handle_regservice_request: mapping kDNSServiceInterfaceIndexP2P to kDNSServiceInterfaceIndexAn y + kDNSServiceFlagsIncludeP2P",  a4,  a5,  a6,  a7,  a8,  v1313);
                      }
                      unsigned int v144 = 0;
                      v141 |= 0x20000u;
                    }

                    uint64_t v331 = mDNSPlatformInterfaceIDfromInterfaceIndex(v144, a2, a3, a4, a5, a6, a7, a8);
                    uint64_t v332 = v331;
                    if (!v144 || v331) {
                      goto LABEL_696;
                    }
                    if (v144 == 0 || v144 >= 0xFFFFFFFC)
                    {
                      int updated = -65540;
                      if (mDNS_LoggingEnabled != 1) {
                        goto LABEL_1122;
                      }
                      LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "handle_regservice_request: bad interfaceIndex %d",  a4,  a5,  a6,  a7,  a8,  v144);
                      goto LABEL_1121;
                    }

                    uint64_t v332 = v144;
                    if (mDNS_LoggingEnabled == 1) {
                      LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "handle_regservice_request: registration pending for interface index %d",  a4,  a5,  a6,  a7,  a8,  v144);
                    }
LABEL_696:
                    __int128 v1488 = 0u;
                    __int128 v1487 = 0u;
                    __int128 v1486 = 0u;
                    __int128 v1485 = 0u;
                    __int128 v1484 = 0u;
                    __int128 v1483 = 0u;
                    __int128 v1482 = 0u;
                    __int128 v1481 = 0u;
                    __int128 v1480 = 0u;
                    __int128 v1479 = 0u;
                    __int128 v1478 = 0u;
                    __int128 v1477 = 0u;
                    __int128 v1476 = 0u;
                    memset(buf, 0, sizeof(buf));
                    bzero(&v1489, 0x3F1uLL);
                    bzero(v1504, 0x3F1uLL);
                    bzero(__src, 0x3F1uLL);
                    __int128 v1459 = 0u;
                    __int128 v1458 = 0u;
                    __int128 v1457 = 0u;
                    __int128 v1456 = 0u;
                    __int128 v1455 = 0u;
                    __int128 v1454 = 0u;
                    __int128 v1453 = 0u;
                    __int128 v1452 = 0u;
                    __int128 v1451 = 0u;
                    __int128 v1450 = 0u;
                    memset(v1449, 0, sizeof(v1449));
                    memset(v1448, 0, sizeof(v1448));
                    if (!*(void *)(v76 + 72)) {
                      goto LABEL_1088;
                    }
                    unint64_t v426 = *(void *)(v76 + 80);
                    int v427 = (sockaddr *)buf;
                    do
                    {
                      uint64_t v428 = *(unsigned __int8 **)(v76 + 72);
                      if ((unint64_t)v428 >= v426 || v427 >= (sockaddr *)&v1489)
                      {
                        BOOL v451 = v427 == (sockaddr *)&v1489;
                        goto LABEL_1084;
                      }

                      *(void *)(v76 + 72) = v428 + 1;
                      int v430 = *v428;
                      v427->sa_leuint64_t n = v430;
                      int v427 = (sockaddr *)((char *)v427 + 1);
                    }

                    while (v430);
                    if (*(void *)(v76 + 72))
                    {
                      unint64_t v431 = *(void *)(v76 + 80);
                      int v427 = (sockaddr *)__src;
                      do
                      {
                        unint64_t v432 = *(unsigned __int8 **)(v76 + 72);
                        if ((unint64_t)v432 >= v431 || v427 >= (sockaddr *)v1474)
                        {
                          v538 = (sockaddr *)v1474;
                          goto LABEL_898;
                        }

                        *(void *)(v76 + 72) = v432 + 1;
                        int v434 = *v432;
                        v427->sa_leuint64_t n = v434;
                        int v427 = (sockaddr *)((char *)v427 + 1);
                      }

                      while (v434);
                      if (*(void *)(v76 + 72))
                      {
                        unint64_t v435 = *(void *)(v76 + 80);
                        int v427 = (sockaddr *)&v1489;
                        do
                        {
                          uint64_t v436 = *(unsigned __int8 **)(v76 + 72);
                          if ((unint64_t)v436 >= v435 || v427 >= (sockaddr *)v1498)
                          {
                            BOOL v451 = v427 == (sockaddr *)v1498;
                            goto LABEL_1084;
                          }

                          *(void *)(v76 + 72) = v436 + 1;
                          int v438 = *v436;
                          v427->sa_leuint64_t n = v438;
                          int v427 = (sockaddr *)((char *)v427 + 1);
                        }

                        while (v438);
                        if (*(void *)(v76 + 72))
                        {
                          unint64_t v439 = *(void *)(v76 + 80);
                          int v427 = v1504;
                          while (1)
                          {
                            BOOL v440 = *(unsigned __int8 **)(v76 + 72);
                            *(void *)(v76 + 72) = v440 + 1;
                            int v442 = *v440;
                            v427->sa_leuint64_t n = v442;
                            int v427 = (sockaddr *)((char *)v427 + 1);
                            if (!v442)
                            {
                              uint64_t v443 = 0LL;
                              *(_DWORD *)(v76 + 232) = v141;
                              *(_DWORD *)(v76 + 236) = v144;
                              uint64_t v444 = *(void *)(v76 + 112);
                              *(void *)uint64_t v444 = v332;
                              *(void *)(v444 + 1624) = 0LL;
                              *(_WORD *)(v444 + 8) = 0;
                              *(void *)(v444 + 16) = 0LL;
                              unint64_t v445 = v444 + 90;
                              while (1)
                              {
                                int v446 = *((unsigned __int8 *)__src + v443);
                                *(_BYTE *)(v445 + v443) = v446;
                                if (!v446) {
                                  break;
                                }
                                if (++v443 == 1008)
                                {
                                  *(_BYTE *)(v444 + 1098) = 0;
                                  break;
                                }
                              }

                              uint64_t v448 = *(_BYTE **)(v76 + 72);
                              unint64_t v447 = *(void *)(v76 + 80);
                              if ((unint64_t)(v448 + 2) <= v447)
                              {
                                uint64_t v449 = 0LL;
                                *(void *)(v76 + 72) = v448 + 1;
                                *(_BYTE *)(v444 + 24) = *v448;
                                int v815 = *(_BYTE **)(v76 + 72);
                                *(void *)(v76 + 72) = v815 + 1;
                                *(_BYTE *)(v444 + 25) = *v815;
                                uint64_t v816 = *(unsigned __int16 **)(v76 + 72);
                                unint64_t v447 = *(void *)(v76 + 80);
                                if (v816 && (unint64_t)(v816 + 1) <= v447)
                                {
                                  size_t v450 = __rev16(*v816);
                                  uint64_t v449 = v816 + 1;
                                }

                                else
                                {
                                  size_t v450 = 0LL;
                                }
                              }

                              else
                              {
                                uint64_t v449 = 0LL;
                                size_t v450 = 0LL;
                                *(void *)(v76 + 72) = 0LL;
                              }

                              *(_WORD *)(v444 + 8) = v450;
                              if (v449) {
                                BOOL v963 = (unint64_t)v449 + v450 > v447;
                              }
                              else {
                                BOOL v963 = 1;
                              }
                              int v964 = v963;
                              BOOL v965 = v964 == 0;
                              if (v964) {
                                size_t v966 = 0LL;
                              }
                              else {
                                size_t v966 = (size_t)v449 + v450;
                              }
                              if (v965) {
                                v967 = v449;
                              }
                              else {
                                v967 = 0LL;
                              }
                              *(void *)(v76 + 72) = v966;
                              if (!v966)
                              {
                                LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "%3d: DNSServiceRegister(unreadable parameters)",  v250,  v251,  v252,  v253,  v254,  *(_DWORD *)(v76 + 168));
                                goto LABEL_1121;
                              }

                              if (v450)
                              {
                                v968 = malloc(v450);
                                if (!v968) {
LABEL_2255:
                                }
                                  __break(1u);
                                *(void *)(v444 + 16) = v968;
                                memcpy(v968, v967, v450);
                              }

                              int v969 = ChopSubTypes((unsigned __int8 *)(v444 + 90));
                              if (v969 < 0)
                              {
                                LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "ERROR: handle_regservice_request - ChopSubTypes failed %s",  v971,  v972,  v973,  v974,  v975,  v444 + 90);
                                goto LABEL_2144;
                              }

                              *(_DWORD *)(v444 + 1616) = v969;
                              if (!*(_BYTE *)(v444 + 90)
                                || (uint64_t v976 = v444 + 1099,
                                    *(_BYTE *)(v444 + 1099) = 0,
                                    !AppendDNSNameString( (_BYTE *)(v444 + 1099),  (unsigned __int8 *)(v444 + 90),  v970,  v971,  v972,  v973,  v974,  v975)))
                              {
                                LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "ERROR: handle_regservice_request - type_as_string bad %s",  v971,  v972,  v973,  v974,  v975,  v444 + 90);
                                goto LABEL_2144;
                              }

                              uint8_t v978 = buf[0];
                              if (buf[0])
                              {
                                if ((v141 & 8) != 0)
                                {
                                  v981 = (_BYTE *)(v444 + 26);
                                  v982 = (uint8_t *)(v444 + 27);
                                }

                                else
                                {
                                  v979 = buf;
                                  size_t v980 = strlen((const char *)buf);
                                  buf[TruncateUTF8ToLength((uint64_t)buf, v980, 0x3Fu)] = 0;
                                  uint8_t v978 = buf[0];
                                  v981 = (_BYTE *)(v444 + 26);
                                  v982 = (uint8_t *)(v444 + 27);
                                  if (!buf[0]) {
                                    goto LABEL_1978;
                                  }
                                }

                                v979 = buf;
                                do
                                {
                                  *v982++ = v978;
                                  int v1141 = *++v979;
                                  uint8_t v978 = v1141;
                                  if (v1141) {
                                    BOOL v1142 = (unint64_t)v982 >= v445;
                                  }
                                  else {
                                    BOOL v1142 = 1;
                                  }
                                }

                                while (!v1142);
LABEL_1978:
                                _BYTE *v981 = (_BYTE)v982 + ~(_BYTE)v981;
                                char v1134 = *v979;
                                if (*v979)
                                {
                                  LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "ERROR: handle_regservice_request - name bad %s",  v971,  v972,  v973,  v974,  v975,  (int)buf);
                                  goto LABEL_2144;
                                }
                              }

                              else
                              {
                                __int128 v1131 = xmmword_10015B3E8;
                                __int128 v1132 = unk_10015B3F8;
                                __int128 v1133 = xmmword_10015B408;
                                *(_OWORD *)(v444 + 74) = unk_10015B418;
                                *(_OWORD *)(v444 + 58) = v1133;
                                *(_OWORD *)(v444 + 42) = v1132;
                                *(_OWORD *)(v444 + 26) = v1131;
                                char v1134 = 1;
                              }

                              *(_BYTE *)(v444 + 1612) = v1134;
                              v1143 = (_BYTE *)(v444 + 1355);
                              if (LOBYTE(v1489.st_dev))
                              {
                                _BYTE *v1143 = 0;
                                v1449[0] = 0;
                                if (!AppendDNSNameString( v1449,  (unsigned __int8 *)&v1489,  v977,  v971,  v972,  v973,  v974,  v975))
                                {
                                  LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "ERROR: handle_regservice_request - domain bad %s",  v1144,  v1145,  v1146,  v1147,  v1148,  (int)&v1489);
                                  goto LABEL_2144;
                                }
                              }

                              else
                              {
                                _BYTE *v1143 = 1;
                                v1449[0] = 0;
                                AppendDNSNameString(v1449, "local.", v977, v971, v972, v973, v974, v975);
                              }

                              if (ConstructServiceName( v1448,  (const char *)(v444 + 26),  (unsigned __int8 *)(v444 + 1099),  v1449))
                              {
                                *(_BYTE *)(v444 + 1356) = 0;
                                if (AppendDNSNameString( (_BYTE *)(v444 + 1356),  &v1504[0].sa_len,  v1182,  v1183,  v1184,  v1185,  v1186,  v1187))
                                {
                                  *(_BYTE *)(v444 + 1613) = (v141 & 8) == 0;
                                  *(_BYTE *)(v444 + 1614) = (v141 & 0x200) != 0;
                                  if (*(_WORD *)(v444 + 24))
                                  {
                                    int v1193 = CountExistingRegistrations(v1448, *(_WORD *)(v444 + 24));
                                    if (v1193)
                                    {
                                      unint64_t v1315 = (v1193 + 1);
                                      v1316 = v1448;
                                      v1314 = (sockaddr *)(v76 + 240);
                                      uint64_t v1317 = bswap32(*(unsigned __int16 *)(v444 + 24)) >> 16;
                                      LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "Client application[%d](%s) registered %d identical instances of service %##s port %u.",  v1194,  v1195,  v1196,  v1197,  v1198,  *(_DWORD *)(v76 + 172));
                                    }
                                  }

                                  memset(v1447, 0, sizeof(v1447));
                                  ConstructServiceName( v1447,  (const char *)(v444 + 26),  (unsigned __int8 *)(v444 + 1099),  v1449);
                                  BOOL v1199 = _shouldLogFullRequestInfo((int *)(v76 + 188), (_DWORD *)(v76 + 192));
                                  char v1200 = gSensitiveLoggingEnabled;
                                  uint64_t v1201 = mDNSLogCategory_mDNS;
                                  if (mDNSLogCategory_mDNS == mDNSLogCategory_State) {
                                    char v1200 = 0;
                                  }
                                  if (v1199)
                                  {
                                    if ((v1200 & 1) != 0)
                                    {
                                      uint64_t v1419 = mDNSLogCategory_mDNS_redacted;
                                      if (os_log_type_enabled( (os_log_t)mDNSLogCategory_mDNS_redacted,  OS_LOG_TYPE_DEFAULT))
                                      {
                                        int v1401 = *(_DWORD *)(v76 + 184);
                                        v1202 = (_BYTE *)(v444 + 1099);
                                        if (v444 == -1355)
                                        {
                                          while (1)
                                          {
LABEL_2031:
                                            if (!v1202) {
                                              goto LABEL_2174;
                                            }
                                            uint64_t v1203 = *v1202;
                                            if (!*v1202) {
                                              break;
                                            }
                                            v1202 += v1203 + 1;
                                            if (v444 != -1355) {
                                              goto LABEL_2030;
                                            }
                                          }

                                          unsigned __int16 v1270 = (_WORD)v1202 - v976 + 1;
                                        }

                                        else
                                        {
LABEL_2030:
                                          if (v1202 < v1143) {
                                            goto LABEL_2031;
                                          }
LABEL_2174:
                                          unsigned __int16 v1270 = 257;
                                        }

                                        __nuint64_t i = v1270;
                                        for (uint64_t i = v1449; ; i += v1274 + 1)
                                        {
                                          LOWORD(v1273) = 257;
                                          uint64_t v1274 = *i;
                                          if (v1274 > 0x3F)
                                          {
                                            LOWORD(v1273) = 257;
                                            goto LABEL_2193;
                                          }

                                          if (!*i) {
                                            break;
                                          }
                                        }

                                        unsigned int v1273 = (_DWORD)i - v1449 + 1;
LABEL_2193:
                                        int v1278 = (unsigned __int16)v1273;
                                        unsigned int v1279 = bswap32(*(unsigned __int16 *)(v444 + 24)) >> 16;
                                        int v1281 = *(_DWORD *)(v76 + 232);
                                        int v1280 = *(_DWORD *)(v76 + 236);
                                        int v1282 = *(_DWORD *)(v76 + 172);
                                        int v1283 = mDNS_DomainNameFNV1aHash((unsigned __int8 *)v1447);
                                        *(_DWORD *)v1421 = 67112195;
                                        int v1422 = v1401;
                                        __int16 v1423 = 2160;
                                        uint64_t v1424 = 1752392040LL;
                                        __int16 v1425 = 1040;
                                        int v1426 = __ni;
                                        __int16 v1427 = 2101;
                                        uint64_t v1428 = v976;
                                        __int16 v1429 = 2160;
                                        uint64_t v1430 = 1752392040LL;
                                        __int16 v1431 = 1040;
                                        int v1432 = v1278;
                                        __int16 v1433 = 2101;
                                        v1434 = v1449;
                                        __int16 v1435 = 1024;
                                        unsigned int v1436 = v1279;
                                        __int16 v1437 = 1024;
                                        int v1438 = v1281;
                                        __int16 v1439 = 1024;
                                        int v1440 = v1280;
                                        __int16 v1441 = 1024;
                                        int v1442 = v1282;
                                        __int16 v1443 = 2082;
                                        uint64_t v1444 = v76 + 240;
                                        __int16 v1445 = 1024;
                                        int v1446 = v1283;
                                        v1267 = (os_log_s *)v1419;
                                        v1268 = "[R%u] DNSServiceRegister START -- service type: %{sensitive, mask.hash, "
                                                "mdnsresponder:domain_name}.*P, domain: %{sensitive, mask.hash, mdnsrespo"
                                                "nder:domain_name}.*P, port: %u, flags: 0x%X, interface index: %d, client"
                                                " pid: %d (%{public}s), name hash: %x";
                                        goto LABEL_2196;
                                      }

LABEL_2198:
                                      *(void *)(v76 + 96) = 0LL;
                                      int v772 = _handle_regservice_request_start(v76, v1449);
                                      goto LABEL_1998;
                                    }

                                    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
                                      goto LABEL_2198;
                                    }
                                    int v1420 = *(_DWORD *)(v76 + 184);
                                    v1262 = (_BYTE *)(v444 + 1099);
                                    if (v444 == -1355)
                                    {
                                      while (1)
                                      {
LABEL_2154:
                                        if (!v1262) {
                                          goto LABEL_2175;
                                        }
                                        uint64_t v1263 = *v1262;
                                        if (!*v1262) {
                                          break;
                                        }
                                        v1262 += v1263 + 1;
                                        if (v444 != -1355) {
                                          goto LABEL_2153;
                                        }
                                      }

                                      unsigned __int16 v1271 = (_WORD)v1262 - v976 + 1;
                                    }

                                    else
                                    {
LABEL_2153:
                                      if (v1262 < v1143) {
                                        goto LABEL_2154;
                                      }
LABEL_2175:
                                      unsigned __int16 v1271 = 257;
                                    }

                                    int v1402 = v1271;
                                    for (int j = v1449; ; j += v1277 + 1)
                                    {
                                      LOWORD(v1276) = 257;
                                      uint64_t v1277 = *j;
                                      if (v1277 > 0x3F)
                                      {
                                        LOWORD(v1276) = 257;
                                        goto LABEL_2195;
                                      }

                                      if (!*j) {
                                        break;
                                      }
                                    }

                                    unsigned int v1276 = (_DWORD)j - v1449 + 1;
LABEL_2195:
                                    int v1284 = (unsigned __int16)v1276;
                                    unsigned int v1285 = bswap32(*(unsigned __int16 *)(v444 + 24)) >> 16;
                                    int v1287 = *(_DWORD *)(v76 + 232);
                                    int v1286 = *(_DWORD *)(v76 + 236);
                                    int v1288 = *(_DWORD *)(v76 + 172);
                                    int v1289 = mDNS_DomainNameFNV1aHash((unsigned __int8 *)v1447);
                                    *(_DWORD *)v1421 = 67112195;
                                    int v1422 = v1420;
                                    __int16 v1423 = 2160;
                                    uint64_t v1424 = 1752392040LL;
                                    __int16 v1425 = 1040;
                                    int v1426 = v1402;
                                    __int16 v1427 = 2101;
                                    uint64_t v1428 = v976;
                                    __int16 v1429 = 2160;
                                    uint64_t v1430 = 1752392040LL;
                                    __int16 v1431 = 1040;
                                    int v1432 = v1284;
                                    __int16 v1433 = 2101;
                                    v1434 = v1449;
                                    __int16 v1435 = 1024;
                                    unsigned int v1436 = v1285;
                                    __int16 v1437 = 1024;
                                    int v1438 = v1287;
                                    __int16 v1439 = 1024;
                                    int v1440 = v1286;
                                    __int16 v1441 = 1024;
                                    int v1442 = v1288;
                                    __int16 v1443 = 2082;
                                    uint64_t v1444 = v76 + 240;
                                    __int16 v1445 = 1024;
                                    int v1446 = v1289;
                                    v1267 = (os_log_s *)v1201;
                                    v1268 = "[R%u] DNSServiceRegister START -- service type: %{sensitive, mask.hash, mdns"
                                            "responder:domain_name}.*P, domain: %{sensitive, mask.hash, mdnsresponder:dom"
                                            "ain_name}.*P, port: %u, flags: 0x%X, interface index: %d, client pid: %d (%{"
                                            "public}s), name hash: %x";
LABEL_2196:
                                    uint32_t v1269 = 100;
                                  }

                                  else
                                  {
                                    if ((v1200 & 1) != 0)
                                    {
                                      uint64_t v1201 = mDNSLogCategory_mDNS_redacted;
                                      if (!os_log_type_enabled( (os_log_t)mDNSLogCategory_mDNS_redacted,  OS_LOG_TYPE_DEFAULT)) {
                                        goto LABEL_2198;
                                      }
                                    }

                                    else if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
                                    {
                                      goto LABEL_2198;
                                    }

                                    int v1265 = *(_DWORD *)(v76 + 184);
                                    int v1266 = mDNS_DomainNameFNV1aHash((unsigned __int8 *)v1447);
                                    *(_DWORD *)v1421 = 67109376;
                                    int v1422 = v1265;
                                    __int16 v1423 = 1024;
                                    LODWORD(v1424) = v1266;
                                    v1267 = (os_log_s *)v1201;
                                    v1268 = "[R%u] DNSServiceRegister START -- name hash: %x";
                                    uint32_t v1269 = 14;
                                  }

                                  _os_log_impl( (void *)&_mh_execute_header,  v1267,  OS_LOG_TYPE_DEFAULT,  v1268,  v1421,  v1269);
                                  goto LABEL_2198;
                                }

                                LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "ERROR: handle_regservice_request - host bad %s",  v1188,  v1189,  v1190,  v1191,  v1192,  (int)v1504);
                              }

                              else
                              {
                                v1314 = (sockaddr *)(v444 + 1099);
                                unint64_t v1315 = (unint64_t)v1449;
                                LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "ERROR: handle_regservice_request - Couldn't ConstructServiceName from, “%#s” “%##s” “%##s”",  v1183,  v1184,  v1185,  v1186,  v1187,  v444 + 26);
                              }

LABEL_2144:
                              v1261 = *(void **)(v444 + 16);
                              if (v1261) {
                                free(v1261);
                              }
                              *(void *)(v444 + 16) = 0LL;
LABEL_1121:
                              int updated = -65540;
                              goto LABEL_1122;
                            }
                          }

                          v538 = (sockaddr *)v1519;
LABEL_898:
                          BOOL v451 = v427 == v538;
LABEL_1084:
                          uint64_t v657 = v451;
                          *(&v427->sa_len - v657) = 0;
                          *(void *)(v76 + 72) = 0LL;
                        }

                        else
                        {
                          v1504[0].sa_leuint64_t n = 0;
                        }
                      }

                      else
                      {
                        LOBYTE(v1489.st_dev) = 0;
                      }
                    }

                    else
                    {
                      LOBYTE(__src[0]) = 0;
                    }

LABEL_1088:
                    uint64_t v658 = (os_log_s *)mDNSLogCategory_Default;
                    uint64_t v659 = "ERROR: handle_regservice_request - Couldn't read name/regtype/domain";
LABEL_1111:
                    LogMsgWithLevel(v658, OS_LOG_TYPE_DEFAULT, v659, v250, v251, v252, v253, v254, v1313);
                    goto LABEL_1121;
                  case 6:
                    if (*(void *)(v76 + 136)) {
                      goto LABEL_242;
                    }
                    unsigned int v145 = calloc(1uLL, 0x118uLL);
                    if (!v145) {
                      goto LABEL_2255;
                    }
                    *(void *)(v76 + 136) = v145;
LABEL_242:
                    unsigned int v146 = 0LL;
                    unsigned int v147 = 0;
                    uint64_t v148 = *(unsigned int **)(v76 + 72);
                    if (v148)
                    {
                      unint64_t v149 = *(void *)(v76 + 80);
                      unsigned int v150 = 0;
                      if ((unint64_t)(v148 + 1) <= v149)
                      {
                        unsigned int v150 = 0;
                        unsigned int v146 = 0LL;
                        unsigned int v147 = bswap32(*v148);
                        *(void *)(v76 + 72) = v148 + 1;
                        if (v148 != (unsigned int *)-4LL && (unint64_t)(v148 + 2) <= v149)
                        {
                          unsigned int v150 = bswap32(v148[1]);
                          unsigned int v146 = v148 + 2;
                        }
                      }
                    }

                    else
                    {
                      unsigned int v150 = 0;
                    }

                    *(void *)(v76 + 72) = v146;
                    uint64_t v354 = mDNSPlatformInterfaceIDfromInterfaceIndex(v150, a2, a3, a4, a5, a6, a7, a8);
                    uint64_t v355 = v354;
                    if (!v150 || v354) {
                      goto LABEL_577;
                    }
                    if (v150 >= 0xFFFFFFFC)
                    {
                      int updated = -65540;
                      if (mDNS_LoggingEnabled != 1) {
                        goto LABEL_1122;
                      }
                      LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "handle_browse_request: bad interfaceIndex %d",  a4,  a5,  a6,  a7,  a8,  v150);
                      goto LABEL_1121;
                    }

                    uint64_t v355 = v150;
                    if (mDNS_LoggingEnabled == 1) {
                      LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "handle_browse_request: browse pending for interface index %d",  a4,  a5,  a6,  a7,  a8,  v150);
                    }
LABEL_577:
                    bzero(&v1489, 0x3F1uLL);
                    bzero(v1504, 0x3F1uLL);
                    __int128 v1472 = 0u;
                    __int128 v1471 = 0u;
                    __int128 v1470 = 0u;
                    __int128 v1469 = 0u;
                    __int128 v1468 = 0u;
                    __int128 v1467 = 0u;
                    __int128 v1466 = 0u;
                    __int128 v1465 = 0u;
                    __int128 v1464 = 0u;
                    __int128 v1463 = 0u;
                    __int128 v1462 = 0u;
                    memset(v1461, 0, sizeof(v1461));
                    memset(__src, 0, sizeof(__src));
                    __int128 v1488 = 0u;
                    __int128 v1487 = 0u;
                    __int128 v1486 = 0u;
                    __int128 v1485 = 0u;
                    __int128 v1484 = 0u;
                    __int128 v1483 = 0u;
                    __int128 v1482 = 0u;
                    __int128 v1481 = 0u;
                    __int128 v1480 = 0u;
                    __int128 v1479 = 0u;
                    __int128 v1478 = 0u;
                    __int128 v1477 = 0u;
                    memset(buf, 0, sizeof(buf));
                    __int128 v1476 = 0u;
                    int updated = -65540;
                    if (!*(void *)(v76 + 72)) {
                      goto LABEL_1122;
                    }
                    unint64_t v367 = *(void *)(v76 + 80);
                    uint64_t v368 = (sockaddr *)&v1489;
                    do
                    {
                      uint64_t v369 = *(unsigned __int8 **)(v76 + 72);
                      if ((unint64_t)v369 >= v367 || v368 >= (sockaddr *)v1498)
                      {
                        BOOL v385 = v368 == (sockaddr *)v1498;
                        goto LABEL_889;
                      }

                      *(void *)(v76 + 72) = v369 + 1;
                      int v371 = *v369;
                      v368->sa_leuint64_t n = v371;
                      uint64_t v368 = (sockaddr *)((char *)v368 + 1);
                    }

                    while (v371);
                    int updated = -65540;
                    if (!*(void *)(v76 + 72)) {
                      goto LABEL_1122;
                    }
                    unint64_t v372 = *(void *)(v76 + 80);
                    uint64_t v368 = v1504;
                    while (1)
                    {
                      uint64_t v373 = *(unsigned __int8 **)(v76 + 72);
                      *(void *)(v76 + 72) = v373 + 1;
                      int v375 = *v373;
                      v368->sa_leuint64_t n = v375;
                      uint64_t v368 = (sockaddr *)((char *)v368 + 1);
                      if (!v375)
                      {
                        if (!*(void *)(v76 + 72))
                        {
                          LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "%3d: DNSServiceBrowse(unreadable parameters)",  a4,  a5,  a6,  a7,  a8,  *(_DWORD *)(v76 + 168));
                          goto LABEL_1121;
                        }

                        _get_signed_data_tlvs(v76, 0LL);
                        *(_DWORD *)(v76 + 232) = v147;
                        *(_DWORD *)(v76 + 236) = v150;
                        LOBYTE(__src[0]) = 0;
                        unsigned int v376 = ChopSubTypes((unsigned __int8 *)&v1489);
                        int updated = -65540;
                        if (v376 > 1) {
                          goto LABEL_1122;
                        }
                        if (v376 == 1)
                        {
                          size_t v377 = strlen((const char *)&v1489);
                          int updated = -65540;
                          if (!AppendDNSNameString( __src,  (unsigned __int8 *)&v1489.st_dev + v377 + 1,  v378,  v379,  v380,  v381,  v382,  v383)) {
                            goto LABEL_1122;
                          }
                        }

                        int updated = -65540;
                        if (!LOBYTE(v1489.st_dev)) {
                          goto LABEL_1122;
                        }
                        int updated = -65540;
                        buf[0] = 0;
                        int updated = -65540;
                        if (buf[0] >= 0x10u && !v1504[0].sa_len)
                        {
                          for (uint64_t k = 0LL; ; ++k)
                          {
                            *(&v1504[0].sa_len + k) = aLocal[k];
                            if (k == 6) {
                              break;
                            }
                          }
                        }

                        uint64_t v760 = *(void *)(v76 + 136);
                        *(_BYTE *)(v760 + 9) = (v147 & 0x400) != 0;
                        *(void *)uint64_t v760 = v355;
                        for (uint64_t m = __src; ; uint64_t m = (socklen_t *)((char *)m + v762 + 1))
                        {
                          if (m >= (socklen_t *)v1473) {
                            goto LABEL_1652;
                          }
                          if (!m) {
                            goto LABEL_1652;
                          }
                          uint64_t v762 = *(unsigned __int8 *)m;
                          if (!*(_BYTE *)m) {
                            break;
                          }
                        }

                        unsigned int v939 = (_DWORD)m - __src + 1;
                        if ((unsigned __int16)v939 > 0x100u) {
LABEL_1652:
                        }
                          *(_BYTE *)(v760 + 10) = 0;
                        else {
                          memcpy((void *)(v760 + 10), __src, (unsigned __int16)v939);
                        }
                        *(_BYTE *)(v760 + 8) = v1504[0].sa_len == 0;
                        *(void *)(v760 + 272) = 0LL;
                        BOOL v940 = _shouldLogFullRequestInfo((int *)(v76 + 188), (_DWORD *)(v76 + 192));
                        char v941 = gSensitiveLoggingEnabled;
                        uint64_t v942 = mDNSLogCategory_mDNS;
                        if (mDNSLogCategory_mDNS == mDNSLogCategory_State) {
                          char v941 = 0;
                        }
                        if (v940)
                        {
                          if ((v941 & 1) != 0)
                          {
                            uint64_t v942 = mDNSLogCategory_mDNS_redacted;
                            if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
                            {
                              int v949 = *(_DWORD *)(v76 + 184);
                              v950 = (_BYTE *)(v760 + 10);
                              if (v760 == -266)
                              {
                                while (1)
                                {
LABEL_1660:
                                  if (!v950) {
                                    goto LABEL_1862;
                                  }
                                  uint64_t v951 = *v950;
                                  if (!*v950) {
                                    break;
                                  }
                                  v950 += v951 + 1;
                                  if (v760 != -266) {
                                    goto LABEL_1659;
                                  }
                                }

                                unsigned __int16 v1054 = (_WORD)v950 - (v760 + 10) + 1;
                              }

                              else
                              {
LABEL_1659:
LABEL_1862:
                                unsigned __int16 v1054 = 257;
                              }

                              goto LABEL_1987;
                            }

          __break(1u);
        }

        if (v27) {
          uint64_t v204 = (os_log_s *)mDNSLogCategory_Default;
        }
        else {
          uint64_t v204 = (os_log_s *)mDNSLogCategory_mDNS;
        }
        if (gSensitiveLoggingEnabled != 1 || v204 == (os_log_s *)mDNSLogCategory_State)
        {
          if (!os_log_type_enabled(v204, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_974;
          }
          uint64_t v205 = *(_DWORD *)(a7 + 184);
          int v206 = __rev16(v40);
          uint64_t v311 = (_BYTE *)(a2 + 356);
          if (a2 == -612)
          {
LABEL_681:
            while (v311)
            {
              uint64_t v312 = *v311;
              if (!*v311)
              {
                uint64_t v395 = (_WORD)v311 - v30 + 1;
                goto LABEL_943;
              }

              v311 += v312 + 1;
              if (a2 != -612) {
                goto LABEL_680;
              }
            }
          }

          else
          {
LABEL_680:
          }

          uint64_t v395 = 257;
        }

        else
        {
          if (v27) {
            uint64_t v204 = (os_log_s *)mDNSLogCategory_Default_redacted;
          }
          else {
            uint64_t v204 = (os_log_s *)mDNSLogCategory_mDNS;
          }
          if (!os_log_type_enabled(v204, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_974;
          }
          uint64_t v205 = *(_DWORD *)(a7 + 184);
          int v206 = __rev16(v40);
          int v207 = (_BYTE *)(a2 + 356);
          if (a2 == -612)
          {
LABEL_308:
            while (v207)
            {
              int v208 = *v207;
              if (!*v207)
              {
                uint64_t v395 = (_WORD)v207 - v30 + 1;
                goto LABEL_943;
              }

              v207 += v208 + 1;
              if (a2 != -612) {
                goto LABEL_307;
              }
            }
          }

          else
          {
LABEL_307:
          }

          uint64_t v395 = 257;
        }

LABEL_1989:
                            if (*(_BYTE *)(v760 + 8))
                            {
                              v1152 = (os_log_s *)mDNSLogCategory_mDNS;
                              if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
                              {
                                if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
                                  goto LABEL_1995;
                                }
                              }

                              else
                              {
                                v1152 = (os_log_s *)mDNSLogCategory_mDNS_redacted;
                                if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
                                {
LABEL_1995:
                                  int v1160 = *(_DWORD *)(v76 + 184);
                                  int v1161 = *(_DWORD *)(v76 + 172);
                                  *(_DWORD *)v1449 = 67109634;
                                  *(_DWORD *)&v1449[4] = v1160;
                                  *(_WORD *)&v1449[8] = 1024;
                                  *(_DWORD *)&v1449[10] = v1161;
                                  *(_WORD *)&v1449[14] = 2082;
                                  *(void *)&v1449[16] = v76 + 240;
                                  _os_log_impl( (void *)&_mh_execute_header,  v1152,  OS_LOG_TYPE_DEFAULT,  "[R%u] DNSServiceBrowse Start domain enumeration for WAB and mDNS PID[%d](%{public}s)",  v1449,  0x18u);
                                }
                              }

                              uDNS_StartWABQueries(2, v1153, v1154, v1155, v1156, v1157, v1158, v1159);
                              mDNS_StartDomainEnumeration();
                            }

                            *(void *)(v76 + 96) = 0LL;
                            int v772 = _handle_browse_request_start( v76,  &v1504[0].sa_len,  v943,  v944,  v945,  v946,  v947,  v948);
                            goto LABEL_1998;
                          }

                          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
                            goto LABEL_1989;
                          }
                          int v949 = *(_DWORD *)(v76 + 184);
                          v952 = (_BYTE *)(v760 + 10);
                          if (v760 == -266)
                          {
                            while (1)
                            {
LABEL_1672:
                              if (!v952) {
                                goto LABEL_1863;
                              }
                              uint64_t v953 = *v952;
                              if (!*v952) {
                                break;
                              }
                              v952 += v953 + 1;
                              if (v760 != -266) {
                                goto LABEL_1671;
                              }
                            }

                            unsigned __int16 v1054 = (_WORD)v952 - (v760 + 10) + 1;
                          }

                          else
                          {
LABEL_1671:
LABEL_1863:
                            unsigned __int16 v1054 = 257;
                          }

LABEL_1987:
                          int v1149 = *(_DWORD *)(v76 + 232);
                          int v1150 = *(_DWORD *)(v76 + 236);
                          int v1151 = *(_DWORD *)(v76 + 172);
                          *(_DWORD *)v1449 = 67111427;
                          *(_DWORD *)&v1449[4] = v949;
                          *(_WORD *)&v1449[8] = 2160;
                          *(void *)&v1449[10] = 1752392040LL;
                          *(_WORD *)&v1449[18] = 1040;
                          *(_DWORD *)&v1449[20] = v1054;
                          *(_WORD *)&v1449[24] = 2101;
                          *(void *)&v1449[26] = v760 + 10;
                          *(_WORD *)&v1449[34] = 2160;
                          *(void *)&v1449[36] = 1752392040LL;
                          *(_WORD *)&v1449[44] = 2085;
                          *(void *)&v1449[46] = v1504;
                          *(_WORD *)&v1449[54] = 1024;
                          *(_DWORD *)&v1449[56] = v1149;
                          *(_WORD *)&v1449[60] = 1024;
                          *(_DWORD *)&v1449[62] = v1150;
                          *(_WORD *)&v1449[66] = 1024;
                          *(_DWORD *)&v1449[68] = v1151;
                          *(_WORD *)&v1449[72] = 2082;
                          *(void *)&v1449[74] = v76 + 240;
                          v994 = (os_log_s *)v942;
                          v995 = "[R%u] DNSServiceBrowse START -- service type: %{sensitive, mask.hash, mdnsresponder:dom"
                                 "ain_name}.*P, domain: %{sensitive, mask.hash}s, flags: 0x%X, interface index: %d, clien"
                                 "t pid: %d (%{public}s), ";
                          uint32_t v996 = 82;
                        }

                        else
                        {
                          if ((v941 & 1) != 0)
                          {
                            uint64_t v942 = mDNSLogCategory_mDNS_redacted;
                            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
                              goto LABEL_1989;
                            }
                          }

                          else if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
                          {
                            goto LABEL_1989;
                          }

                          int v993 = *(_DWORD *)(v76 + 184);
                          *(_DWORD *)v1449 = 67109120;
                          *(_DWORD *)&v1449[4] = v993;
                          v994 = (os_log_s *)v942;
                          v995 = "[R%u] DNSServiceBrowse START -- ";
                          uint32_t v996 = 8;
                        }

                        _os_log_impl((void *)&_mh_execute_header, v994, OS_LOG_TYPE_DEFAULT, v995, v1449, v996);
                        goto LABEL_1989;
                      }
                    }

                    BOOL v385 = v368 == (sockaddr *)v1519;
LABEL_889:
                    uint64_t v537 = v385;
                    BOOL v418 = &v368->sa_len - v537;
                    goto LABEL_893;
                  case 7:
                    if (*(void *)(v76 + 120)) {
                      goto LABEL_250;
                    }
                    int v151 = calloc(1uLL, 0x540uLL);
                    if (!v151) {
                      goto LABEL_2255;
                    }
                    *(void *)(v76 + 1memset(v45, 0, 20) = v151;
LABEL_250:
                    unsigned int v152 = 0;
                    uint64_t v153 = *(unsigned int **)(v76 + 72);
                    if (!v153
                      || (unint64_t v154 = *(void *)(v76 + 80), (unint64_t)(v153 + 1) > v154)
                      || (uint64_t v155 = v153 + 2,
                          unsigned int v152 = bswap32(*v153),
                          *(void *)(v76 + 72) = v153 + 1,
                          v153 == (unsigned int *)-4LL)
                      || (unint64_t)v155 > v154)
                    {
                      unsigned int v156 = 0;
                      *(void *)(v76 + 72) = 0LL;
                    }

                    else
                    {
                      unsigned int v156 = bswap32(v153[1]);
                      *(void *)(v76 + 72) = v155;
                      if (v156 == -3)
                      {
                        if (mDNS_LoggingEnabled == 1) {
                          LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "handle_resolve_request: mapping kDNSServiceInterfaceIndexP2P to kDNSServiceInterfaceIndexAny + kDNSServiceFlagsIncludeP2P",  a4,  a5,  a6,  a7,  a8,  v1313);
                        }
                        unsigned int v156 = 0;
                        v152 |= 0x20000u;
                      }
                    }

                    uint64_t v356 = mDNSPlatformInterfaceIDfromInterfaceIndex(v156, a2, a3, a4, a5, a6, a7, a8);
                    uint64_t v1503 = v356;
                    if (!v156 || v356) {
                      goto LABEL_733;
                    }
                    if (v156 == 0 || v156 >= 0xFFFFFFFC)
                    {
                      int updated = -65540;
                      if (mDNS_LoggingEnabled != 1) {
                        goto LABEL_1122;
                      }
                      LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "handle_resolve_request: bad interfaceIndex %d",  a4,  a5,  a6,  a7,  a8,  v156);
                      goto LABEL_1121;
                    }

                    uint64_t v1503 = v156;
                    if (mDNS_LoggingEnabled == 1) {
                      LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "handle_resolve_request: resolve pending for interface index %d",  a4,  a5,  a6,  a7,  a8,  v156);
                    }
LABEL_733:
                    __int128 v1472 = 0u;
                    __int128 v1471 = 0u;
                    __int128 v1470 = 0u;
                    __int128 v1469 = 0u;
                    __int128 v1468 = 0u;
                    __int128 v1467 = 0u;
                    __int128 v1466 = 0u;
                    __int128 v1465 = 0u;
                    __int128 v1464 = 0u;
                    __int128 v1463 = 0u;
                    __int128 v1462 = 0u;
                    memset(v1461, 0, sizeof(v1461));
                    memset(__src, 0, sizeof(__src));
                    bzero(v1504, 0x3F1uLL);
                    bzero(&v1489, 0x4F8uLL);
                    if (!*(void *)(v76 + 72)) {
                      goto LABEL_1094;
                    }
                    unint64_t v452 = *(void *)(v76 + 80);
                    int v453 = (sockaddr *)__src;
                    do
                    {
                      uint64_t v454 = *(unsigned __int8 **)(v76 + 72);
                      if ((unint64_t)v454 >= v452 || v453 >= (sockaddr *)v1473)
                      {
                        BOOL v471 = v453 == (sockaddr *)v1473;
                        goto LABEL_1090;
                      }

                      *(void *)(v76 + 72) = v454 + 1;
                      int v456 = *v454;
                      v453->sa_leuint64_t n = v456;
                      int v453 = (sockaddr *)((char *)v453 + 1);
                    }

                    while (v456);
                    if (*(void *)(v76 + 72))
                    {
                      unint64_t v457 = *(void *)(v76 + 80);
                      int v453 = (sockaddr *)&v1489;
                      do
                      {
                        uint64_t v458 = *(unsigned __int8 **)(v76 + 72);
                        if ((unint64_t)v458 >= v457 || v453 >= (sockaddr *)v1498)
                        {
                          BOOL v471 = v453 == (sockaddr *)v1498;
                          goto LABEL_1090;
                        }

                        *(void *)(v76 + 72) = v458 + 1;
                        int v460 = *v458;
                        v453->sa_leuint64_t n = v460;
                        int v453 = (sockaddr *)((char *)v453 + 1);
                      }

                      while (v460);
                      if (*(void *)(v76 + 72))
                      {
                        unint64_t v461 = *(void *)(v76 + 80);
                        int v453 = v1504;
                        while (1)
                        {
                          v462 = *(unsigned __int8 **)(v76 + 72);
                          *(void *)(v76 + 72) = v462 + 1;
                          int v464 = *v462;
                          v453->sa_leuint64_t n = v464;
                          int v453 = (sockaddr *)((char *)v453 + 1);
                          if (!v464)
                          {
                            if (!*(void *)(v76 + 72))
                            {
                              LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "%3d: DNSServiceResolve(unreadable parameters)",  v250,  v251,  v252,  v253,  v254,  *(_DWORD *)(v76 + 168));
                              goto LABEL_1121;
                            }

                            int signed_browse_tlvs = get_signed_browse_tlvs(v76);
                            if (signed_browse_tlvs)
                            {
                              int updated = signed_browse_tlvs;
                              LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "%3d: handle_resolve_request err reading Validation TLVS",  v466,  v467,  v468,  v469,  v470,  *(_DWORD *)(v76 + 168));
                              goto LABEL_1122;
                            }

                            if ((build_domainname_from_strings( v1498,  __src,  (unsigned __int8 *)&v1489,  &v1504[0].sa_len,  v467,  v468,  v469,  v470) & 0x80000000) != 0)
                            {
                              unint64_t v1315 = (unint64_t)v1504;
                              v1314 = (sockaddr *)&v1489;
                              LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "ERROR: handle_resolve_request bad “%s” “%s” “%s”",  v777,  v778,  v779,  v780,  v781,  (int)__src);
                              goto LABEL_1121;
                            }

                            *(_DWORD *)(v76 + 232) = v152;
                            *(_DWORD *)(v76 + 236) = v156;
                            uint64_t v782 = *(void *)(v76 + 120);
                            *(void *)(v782 + 792) = v1503;
                            *(_DWORD *)(v782 + 960) = v152;
                            for (uint64_t n = v1498; ; n += v784 + 1)
                            {
                              if (n >= v1502) {
                                goto LABEL_1749;
                              }
                              if (!n) {
                                goto LABEL_1749;
                              }
                              uint64_t v784 = *n;
                              if (!*n) {
                                break;
                              }
                            }

                            unsigned __int16 v999 = (_WORD)n - (unsigned __int16)v1498 + 1;
                            if (v999 > 0x100u) {
LABEL_1749:
                            }
                              *(_BYTE *)(v782 + 1012) = 0;
                            else {
                              memcpy((void *)(v782 + 1012), v1498, v999);
                            }
                            *(_DWORD *)(v782 + 978) = 65569;
                            unint64_t v1418 = v782 + 1268;
                            *(_BYTE *)(v782 + 1268) = BYTE1(v152) & 1;
                            *(_BYTE *)(v782 + 1269) = 1;
                            *(_BYTE *)(v782 + 1270) = (v152 & 0x400) != 0;
                            *(_BYTE *)(v782 + 1271) = (v152 & 0x1000) != 0;
                            *(_WORD *)(v782 + 1272) = 0;
                            *(_BYTE *)(v782 + 1277) = 0;
                            *(_BYTE *)(v782 + 1275) = (v152 & 0x40000) != 0;
                            *(_BYTE *)(v782 + 1276) = (v152 & 0x80000) != 0;
                            *(_BYTE *)(v782 + 1288) = 0;
                            *(_DWORD *)(v782 + 900) = *(_DWORD *)(v76 + 172);
                            *(_DWORD *)(v782 + 904) = *(_DWORD *)(v76 + 180);
                            *(void *)(v782 + 808) = resolve_result_callback;
                            *(void *)(v782 + 832) = v76;
                            *(void *)(v782 + 136) = v1503;
                            *(_DWORD *)(v782 + 304) = v152;
                            for (iuint64_t i = v1498; ; ii += v1001 + 1)
                            {
                              if (ii >= v1502) {
                                goto LABEL_1758;
                              }
                              if (!ii) {
                                goto LABEL_1758;
                              }
                              uint64_t v1001 = *ii;
                              if (!*ii) {
                                break;
                              }
                            }

                            unsigned __int16 v1002 = (_WORD)ii - (unsigned __int16)v1498 + 1;
                            if (v1002 > 0x100u) {
LABEL_1758:
                            }
                              *(_BYTE *)(v782 + 356) = 0;
                            else {
                              memcpy((void *)(v782 + 356), v1498, v1002);
                            }
                            *(_DWORD *)(v782 + 322) = 65552;
                            *(_BYTE *)(v782 + 612) = BYTE1(v152) & 1;
                            *(_BYTE *)(v782 + 613) = 1;
                            *(_BYTE *)(v782 + 614) = (v152 & 0x400) != 0;
                            *(_BYTE *)(v782 + 615) = (v152 & 0x1000) != 0;
                            *(_WORD *)(v782 + 616) = 0;
                            *(_BYTE *)(v782 + 621) = 0;
                            *(_BYTE *)(v782 + 619) = 0;
                            *(_BYTE *)(v782 + 6memset(v45, 0, 20) = (v152 & 0x80000) != 0;
                            *(_BYTE *)(v782 + 632) = 0;
                            *(_DWORD *)(v782 + 244) = *(_DWORD *)(v76 + 172);
                            *(_DWORD *)(v782 + 248) = *(_DWORD *)(v76 + 180);
                            *(void *)(v782 + 152) = resolve_result_callback;
                            *(void *)(v782 + 176) = v76;
                            unsigned int v1003 = mDNS_TimeNow(mDNSStorage, v775, v776, v777, v778, v779, v780, v781) + 130000;
                            if (v1003 <= 1) {
                              unsigned int v1003 = 1;
                            }
                            *(_DWORD *)(v782 + 1332) = v1003;
                            *(_BYTE *)(v782 + 1336) = 0;
                            BOOL v1004 = _shouldLogFullRequestInfo((int *)(v76 + 188), (_DWORD *)(v76 + 192));
                            v1005 = (unsigned __int8 *)(v782 + 1012);
                            char v1006 = gSensitiveLoggingEnabled;
                            v1007 = (os_log_s *)mDNSLogCategory_mDNS;
                            if (mDNSLogCategory_mDNS == mDNSLogCategory_State) {
                              char v1006 = 0;
                            }
                            if (v1004)
                            {
                              if ((v1006 & 1) != 0)
                              {
                                uint64_t v1008 = mDNSLogCategory_mDNS_redacted;
                                if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
                                {
                                  int v1399 = *(_DWORD *)(v76 + 184);
                                  v1009 = (unsigned __int8 *)(v782 + 1012);
                                  while (1)
                                  {
                                    if ((unint64_t)v1005 >= v1418
                                      || !v1005
                                      || (uint64_t v1010 = *v1005, v1010 > 0x3F))
                                    {
                                      unsigned __int16 v1135 = 257;
                                      goto LABEL_2072;
                                    }

                                    if (!*v1005) {
                                      break;
                                    }
                                    v1005 += v1010 + 1;
                                  }

                                  unsigned __int16 v1135 = (_WORD)v1005 - (_WORD)v1009 + 1;
LABEL_2072:
                                  int v1218 = v1135;
                                  int v1219 = *(_DWORD *)(v76 + 232);
                                  int v1220 = *(_DWORD *)(v76 + 236);
                                  int v1221 = *(_DWORD *)(v76 + 172);
                                  v1005 = v1009;
                                  int v1222 = mDNS_DomainNameFNV1aHash(v1009);
                                  *(_DWORD *)buf = 67111171;
                                  *(_DWORD *)&uint8_t buf[4] = v1399;
                                  *(_WORD *)&buf[8] = 2160;
                                  *(void *)&buf[10] = 1752392040LL;
                                  *(_WORD *)&buf[18] = 1040;
                                  *(_DWORD *)&buf[20] = v1218;
                                  *(_WORD *)&buf[24] = 2101;
                                  *(void *)&buf[26] = v1005;
                                  *(_WORD *)&buf[34] = 1024;
                                  *(_DWORD *)&buf[36] = v1219;
                                  *(_WORD *)&buf[40] = 1024;
                                  *(_DWORD *)&buf[42] = v1220;
                                  *(_WORD *)&buf[46] = 1024;
                                  LODWORD(v1476) = v1221;
                                  WORD2(v1476) = 2082;
                                  *(void *)((char *)&v1476 + 6) = v76 + 240;
                                  HIWORD(v1476) = 1024;
                                  LODWORD(v1477) = v1222;
                                  v1223 = (os_log_s *)v1008;
                                  goto LABEL_2075;
                                }
                              }

                              else if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
                              {
                                int v1400 = *(_DWORD *)(v76 + 184);
                                v1011 = (unsigned __int8 *)(v782 + 1012);
                                while (1)
                                {
                                  if ((unint64_t)v1005 >= v1418
                                    || !v1005
                                    || (uint64_t v1012 = *v1005, v1012 > 0x3F))
                                  {
                                    unsigned __int16 v1136 = 257;
                                    goto LABEL_2074;
                                  }

                                  if (!*v1005) {
                                    break;
                                  }
                                  v1005 += v1012 + 1;
                                }

                                unsigned __int16 v1136 = (_WORD)v1005 - (_WORD)v1011 + 1;
LABEL_2074:
                                int v1224 = v1136;
                                int v1225 = *(_DWORD *)(v76 + 232);
                                int v1226 = *(_DWORD *)(v76 + 236);
                                int v1227 = *(_DWORD *)(v76 + 172);
                                v1005 = v1011;
                                int v1228 = mDNS_DomainNameFNV1aHash(v1011);
                                *(_DWORD *)buf = 67111171;
                                *(_DWORD *)&uint8_t buf[4] = v1400;
                                *(_WORD *)&buf[8] = 2160;
                                *(void *)&buf[10] = 1752392040LL;
                                *(_WORD *)&buf[18] = 1040;
                                *(_DWORD *)&buf[20] = v1224;
                                *(_WORD *)&buf[24] = 2101;
                                *(void *)&buf[26] = v1005;
                                *(_WORD *)&buf[34] = 1024;
                                *(_DWORD *)&buf[36] = v1225;
                                *(_WORD *)&buf[40] = 1024;
                                *(_DWORD *)&buf[42] = v1226;
                                *(_WORD *)&buf[46] = 1024;
                                LODWORD(v1476) = v1227;
                                WORD2(v1476) = 2082;
                                *(void *)((char *)&v1476 + 6) = v76 + 240;
                                HIWORD(v1476) = 1024;
                                LODWORD(v1477) = v1228;
                                v1223 = v1007;
LABEL_2075:
                                _os_log_impl( (void *)&_mh_execute_header,  v1223,  OS_LOG_TYPE_DEFAULT,  "[R%u] DNSServiceResolve START -- SRV name: %{sensitive, mask.hash, mdnsresponder:domai n_name}.*P, flags: 0x%X, interface index: %d, client pid: %d (%{public}s), name hash: %x",  buf,  0x44u);
                              }
                            }

                            else
                            {
                              if ((v1006 & 1) != 0)
                              {
                                v1007 = (os_log_s *)mDNSLogCategory_mDNS_redacted;
                                if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
                                  goto LABEL_2076;
                                }
                              }

                              else if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
                              {
                                goto LABEL_2076;
                              }

                              int v1055 = *(_DWORD *)(v76 + 184);
                              int v1056 = mDNS_DomainNameFNV1aHash(v1005);
                              *(_DWORD *)buf = 67109376;
                              *(_DWORD *)&uint8_t buf[4] = v1055;
                              *(_WORD *)&buf[8] = 1024;
                              *(_DWORD *)&buf[10] = v1056;
                              _os_log_impl( (void *)&_mh_execute_header,  v1007,  OS_LOG_TYPE_DEFAULT,  "[R%u] DNSServiceResolve START -- name hash: %x",  buf,  0xEu);
                            }

LABEL_2076:
                            *(void *)(v76 + 96) = 0LL;
                            uint64_t v1229 = *(void *)(v76 + 48);
                            if (!v1229) {
                              goto LABEL_2134;
                            }
                            if (*(_UNKNOWN ***)(v1229 + 16) == &_mdns_signed_browse_result_kind
                              && mdns_signed_browse_result_contains(v1229, v1498, v156))
                            {
                              v1230 = (os_log_s *)mDNSLogCategory_mDNS;
                              if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
                              {
                                if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEBUG)) {
                                  goto LABEL_2102;
                                }
                              }

                              else
                              {
                                v1230 = (os_log_s *)mDNSLogCategory_mDNS_redacted;
                                if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEBUG))
                                {
LABEL_2102:
                                  int v1237 = *(_DWORD *)(v76 + 184);
                                  *(_DWORD *)buf = 67109120;
                                  *(_DWORD *)&uint8_t buf[4] = v1237;
                                  _os_log_impl( (void *)&_mh_execute_header,  v1230,  OS_LOG_TYPE_DEBUG,  "[R%d] DNSServiceResolve: Allowing signed result",  buf,  8u);
                                }
                              }

LABEL_2134:
                              uint64_t v1252 = *(void *)(v76 + 120);
                              int updated = mDNS_StartQuery((unsigned int *)mDNSStorage, v1252 + 656);
                              if (updated) {
                                goto LABEL_1122;
                              }
                              int started = mDNS_StartQuery((unsigned int *)mDNSStorage, v1252);
                              if (started)
                              {
                                int updated = started;
                                uint64_t v139 = v1252 + 656;
LABEL_233:
                                mDNS_StopQuery((unsigned int *)mDNSStorage, v139);
                                goto LABEL_1122;
                              }

                              *(void *)(v76 + 96) = resolve_termination_callback;
                              if (*(_DWORD *)(v76 + 236) != -1 && IsLocalDomain(v1498))
                              {
                                uint64_t v1259 = *(unsigned int *)(v76 + 236);
                                if ((_DWORD)v1259)
                                {
                                  if (AWDLInterfaceID && AWDLInterfaceID == v1259)
                                  {
                                    int v1260 = 1;
                                  }

                                  else
                                  {
                                    if (WiFiAwareInterfaceID) {
                                      BOOL v1264 = WiFiAwareInterfaceID == v1259;
                                    }
                                    else {
                                      BOOL v1264 = 0;
                                    }
                                    int v1260 = v1264;
                                  }
                                }

                                else
                                {
                                  int v1260 = (*(_DWORD *)(v76 + 232) >> 20) & 1;
                                }

                                *(void *)(v76 + 8) = mdns_powerlog_resolve_start( (const char *)(v76 + 240),  v1498,  v1260);
                              }

                              if (mDNS_McastLoggingEnabled) {
                                LogMcastQuestion(v1252 + 656, v76, 1);
                              }
                              if (callExternalHelpers( v1503,  v1498,  *(unsigned int *)(v76 + 232),  v1254,  v1255,  v1256,  v1257,  v1258))
                              {
                                *(_BYTE *)(v1252 + 1336) = 1;
                                if (mDNS_LoggingEnabled == 1) {
                                  LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "handle_resolve_request: calling external_start_resolving_service()",  a4,  a5,  a6,  a7,  a8,  v1313);
                                }
                                external_start_resolving_service( v1503,  v1498,  *(_DWORD *)(v76 + 232),  *(_DWORD *)(v76 + 172));
                              }

LABEL_666:
                              int updated = 0;
                              goto LABEL_1122;
                            }

                            v1231 = (os_log_s *)mDNSLogCategory_mDNS;
                            if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
                            {
                              if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_ERROR))
                              {
                                int v1232 = *(_DWORD *)(v76 + 184);
                                v1233 = v1005;
                                while (1)
                                {
                                  if ((unint64_t)v1005 >= v1418
                                    || !v1005
                                    || (uint64_t v1235 = *v1005, v1235 > 0x3F))
                                  {
                                    unsigned __int16 v1236 = 257;
                                    goto LABEL_2131;
                                  }

                                  if (!*v1005) {
                                    break;
                                  }
                                  v1005 += v1235 + 1;
                                }

                                unsigned __int16 v1236 = (_WORD)v1005 - (_WORD)v1233 + 1;
LABEL_2131:
                                *(_DWORD *)buf = 67110147;
                                *(_DWORD *)&uint8_t buf[4] = v1232;
                                *(_WORD *)&buf[8] = 2160;
                                *(void *)&buf[10] = 1752392040LL;
                                *(_WORD *)&buf[18] = 1040;
                                *(_DWORD *)&buf[20] = v1236;
                                *(_WORD *)&buf[24] = 2101;
                                *(void *)&buf[26] = v1233;
                                *(_WORD *)&buf[34] = 1024;
                                *(_DWORD *)&buf[36] = v156;
                                _os_log_impl( (void *)&_mh_execute_header,  v1231,  OS_LOG_TYPE_ERROR,  "[R%d] DNSServiceResolve: Signed result does not cover service: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P, ifindex: %u.",  buf,  0x28u);
                              }
                            }

                            else
                            {
                              v1231 = (os_log_s *)mDNSLogCategory_mDNS_redacted;
                              if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_ERROR))
                              {
                                int v1232 = *(_DWORD *)(v76 + 184);
                                v1233 = v1005;
                                while (1)
                                {
                                  if ((unint64_t)v1005 >= v1418
                                    || !v1005
                                    || (uint64_t v1234 = *v1005, v1234 > 0x3F))
                                  {
                                    unsigned __int16 v1236 = 257;
                                    goto LABEL_2131;
                                  }

                                  if (!*v1005) {
                                    break;
                                  }
                                  v1005 += v1234 + 1;
                                }

                                unsigned __int16 v1236 = (_WORD)v1005 - (_WORD)v1233 + 1;
                                goto LABEL_2131;
                              }
                            }

                            *(_BYTE *)(v76 + 274) = 0;
                            v1251 = *(void **)(v76 + 48);
                            if (v1251)
                            {
                              os_release(v1251);
                              *(void *)(v76 + 48) = 0LL;
                            }

                            goto LABEL_2134;
                          }
                        }

                        BOOL v471 = v453 == (sockaddr *)v1519;
LABEL_1090:
                        uint64_t v660 = v471;
                        *(&v453->sa_len - v660) = 0;
                        *(void *)(v76 + 72) = 0LL;
                      }

                      else
                      {
                        v1504[0].sa_leuint64_t n = 0;
                      }
                    }

                    else
                    {
                      LOBYTE(v1489.st_dev) = 0;
                    }

LABEL_1094:
                    uint64_t v658 = (os_log_s *)mDNSLogCategory_Default;
                    uint64_t v659 = "ERROR: handle_resolve_request - Couldn't read name/regtype/domain";
                    goto LABEL_1111;
                  case 8:
                    if (*(void *)(v76 + 128)) {
                      goto LABEL_261;
                    }
                    unsigned int v157 = calloc(1uLL, 0x2F8uLL);
                    if (!v157) {
                      goto LABEL_2255;
                    }
                    *(void *)(v76 + 128) = v157;
LABEL_261:
                    bzero(&v1489, 0x468uLL);
                    v1489.st_ino = (__darwin_ino64_t)&v1489.st_size;
                    __int128 v158 = *(unsigned int **)(v76 + 72);
                    if (!v158
                      || (unint64_t v159 = *(void *)(v76 + 80), (unint64_t)(v158 + 1) > v159)
                      || (int v160 = v158 + 2,
                          gid_t v161 = bswap32(*v158),
                          *(void *)(v76 + 72) = v158 + 1,
                          v1489.st_gid = v161,
                          v158 == (unsigned int *)-4LL)
                      || (unint64_t)v160 > v159)
                    {
                      *(void *)(v76 + 72) = 0LL;
                      v1489.st_uid = 0;
                      goto LABEL_1121;
                    }

                    uid_t v162 = bswap32(v158[1]);
                    *(void *)(v76 + 72) = v160;
                    v1489.st_uid = v162;
                    int updated = -65540;
                    if (!v160) {
                      goto LABEL_1122;
                    }
                    p_st_size = &v1489.st_size;
                    uint64_t v164 = v1500;
                    do
                    {
                      uint64_t v165 = *(unsigned __int8 **)(v76 + 72);
                      *(void *)(v76 + 72) = v165 + 1;
                      int v167 = *v165;
                      *p_st_size++ = v167;
                    }

                    while (v167);
                    uint64_t v168 = *(unsigned __int16 **)(v76 + 72);
                    unint64_t v169 = *(void *)(v76 + 80);
                    uint64_t v170 = v168 + 1;
                    if (v168) {
                      BOOL v171 = (unint64_t)v170 > v169;
                    }
                    else {
                      BOOL v171 = 1;
                    }
                    if (v171)
                    {
                      int v172 = 0LL;
                      LOWORD(v173) = 0;
                      LOWORD(v1489.st_rdev) = 0;
                    }

                    else
                    {
                      LOWORD(v173) = 0;
                      int v172 = 0LL;
                      unsigned int v577 = bswap32(*v168);
                      *(void *)(v76 + 72) = v170;
                      LOWORD(v1489.st_rdev) = HIWORD(v577);
                      if (v168 != (unsigned __int16 *)-2LL && (unint64_t)(v168 + 2) <= v169)
                      {
                        unsigned int v173 = bswap32(v168[1]) >> 16;
                        int v172 = (unsigned __int8 *)(v168 + 2);
                      }
                    }

                    *(void *)(v76 + 72) = v172;
                    HIWORD(v1489.st_rdev) = v173;
                    dev_t v578 = *(_DWORD *)(v76 + 184);
                    v1489.dev_t st_dev = v578;
                    int v579 = *(unsigned __int8 *)(v76 + 272);
                    if (*(_BYTE *)(v76 + 272)) {
                      dev_t v580 = 0;
                    }
                    else {
                      dev_t v580 = *(_DWORD *)(v76 + 172);
                    }
                    *(&v1489.st_rdev + 1) = v580;
                    if (v579) {
                      __darwin_time_t v598 = v76 + 256;
                    }
                    else {
                      __darwin_time_t v598 = 0LL;
                    }
                    v1489.st_atimespec.tv_sec = v598;
                    LODWORD(v1489.st_atimespec.tv_nsec) = *(_DWORD *)(v76 + 180);
                    v1489.st_ctimespec.tv_nsec = *(void *)(v76 + 32);
                    if (!v172)
                    {
                      uint64_t v603 = mDNSLogCategory_Default;
                      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
                      {
                        int updated = -65540;
                        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_ERROR)) {
                          goto LABEL_1122;
                        }
                      }

                      else
                      {
                        uint64_t v603 = mDNSLogCategory_Default_redacted;
                        int updated = -65540;
                        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_ERROR)) {
                          goto LABEL_1122;
                        }
                      }

                      __src[0] = 67109120;
                      __src[1] = v578;
                      uint64_t v114 = (stat *)__src;
                      uint64_t v115 = (os_log_s *)v603;
                      os_log_type_t v116 = OS_LOG_TYPE_ERROR;
                      unsigned int v117 = "[R%d] DNSServiceQueryRecord(unreadable parameters)";
LABEL_1119:
                      uint32_t v674 = 8;
LABEL_1120:
                      _os_log_impl((void *)&_mh_execute_header, v115, v116, v117, (uint8_t *)v114, v674);
                      goto LABEL_1121;
                    }

                    *(int32x2_t *)(v76 + 232) = vrev64_s32(*(int32x2_t *)&v1489.st_uid);
                    if ((*(_BYTE *)(v76 + 208) & 2) != 0)
                    {
                      BYTE1(v1489.st_birthtimespec.tv_nsec) = get_tlv_uint32(v172, v169, 3, 0LL) == 1;
                      uint64_t v599 = v172;
                      while ((uint64_t)(v169 - (void)v599) >= 4)
                      {
                        v600 = v599 + 4;
                        int64_t v601 = __rev16(*((unsigned __int16 *)v599 + 1));
                        unsigned int v602 = __rev16(*(unsigned __int16 *)v599);
                        uint64_t v599 = (unsigned __int8 *)v600 + v601;
                        if (v602 == 10)
                        {
                          if (v601 == 16)
                          {
                            v1500[0] = *v600;
                            v1489.st_mtimespec.tv_sec = (__darwin_time_t)v1500;
                            BYTE4(v1489.st_ctimespec.tv_sec) = 1;
                            goto LABEL_1055;
                          }

                          break;
                        }
                      }

                      BYTE1(v1489.st_ctimespec.tv_sec) = get_tlv_uint32(v172, v169, 4, 0LL) == 1;
                      uint64_t v626 = v172;
                      while ((uint64_t)(v169 - (void)v626) >= 4)
                      {
                        uint64_t v627 = v626 + 4;
                        CFIndex v628 = __rev16(*((unsigned __int16 *)v626 + 1));
                        unsigned int v629 = __rev16(*(unsigned __int16 *)v626);
                        uint64_t v626 = (unsigned __int8 *)&v627[v628];
                        if (v629 == 1)
                        {
                          v1489.st_mtimespec.tv_nsec = Querier_RegisterCustomDNSServiceWithPListData(v627, v628);
                          *(void *)uint64_t v76 = v1489.st_mtimespec.tv_nsec;
                          break;
                        }
                      }

                      LOBYTE(v1489.st_ctimespec.tv_sec) = get_tlv_uint32(v172, v169, 2, 0LL) != 0;
                    }

LABEL_1055:
                    int v630 = get_signed_browse_tlvs(v76);
                    if (v630)
                    {
                      int updated = v630;
                      LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "%3d: handle_queryrecord_request err reading Validation TLVS",  v631,  v632,  v633,  v634,  v635,  *(_DWORD *)(v76 + 168));
                      goto LABEL_1122;
                    }

                    get_tracker_info_tlvs(v76);
                    int v637 = *(_DWORD *)(v76 + 232);
                    char v638 = _os_feature_enabled_impl("mDNSResponder", "dnssec");
                    memset(v1504, 0, sizeof(v1504));
                    __int128 v1505 = 0u;
                    __int128 v1506 = 0u;
                    __int128 v1507 = 0u;
                    memset(v1508, 0, sizeof(v1508));
                    __int128 v1509 = 0u;
                    __int128 v1510 = 0u;
                    __int128 v1511 = 0u;
                    __int128 v1512 = 0u;
                    __int128 v1513 = 0u;
                    __int128 v1514 = 0u;
                    __int128 v1515 = 0u;
                    __int128 v1516 = 0u;
                    __int128 v1517 = 0u;
                    int updated = -65540;
                    if (!AppendDNSNameString( v1504,  (unsigned __int8 *)&v1489.st_size,  v639,  v640,  v641,  v642,  v643,  v644)) {
                      goto LABEL_1122;
                    }
                    BOOL v645 = IsLocalDomain(v1504);
                    BOOL v646 = _shouldLogFullRequestInfo((int *)(v76 + 188), (_DWORD *)(v76 + 192));
                    char v647 = v638 ^ 1;
                    if ((v637 & 0x200000) == 0) {
                      char v647 = 1;
                    }
                    if ((v647 & 1) != 0)
                    {
                      if (v646)
                      {
                        if (!gSensitiveLoggingEnabled
                          || (v645 ? (uint64_t v745 = mDNSLogCategory_mDNS) : (uint64_t v745 = mDNSLogCategory_Default),
                              v745 == mDNSLogCategory_State))
                        {
                          if (v645) {
                            uint64_t v746 = (os_log_s *)mDNSLogCategory_mDNS;
                          }
                          else {
                            uint64_t v746 = (os_log_s *)mDNSLogCategory_Default;
                          }
                          if (!os_log_type_enabled(v746, OS_LOG_TYPE_DEFAULT)) {
                            goto LABEL_2044;
                          }
                          socklen_t v1414 = *(_DWORD *)(v76 + 184);
                          for (jint j = v1504; ; jint j = (sockaddr *)((char *)jj + sa_len + 1))
                          {
                            LOWORD(v748) = 257;
                            if (jj >= (sockaddr *)v1518 || !jj) {
                              goto LABEL_2041;
                            }
                            sa_leuint64_t n = jj->sa_len;
                            if (sa_len > 0x3F)
                            {
                              LOWORD(v748) = 257;
                              goto LABEL_2041;
                            }

                            if (!jj->sa_len) {
                              break;
                            }
                          }

                          unsigned int v748 = (_DWORD)jj - (v1501 + 32) + 1;
                        }

                        else
                        {
                          if (v645) {
                            uint64_t v746 = (os_log_s *)mDNSLogCategory_mDNS;
                          }
                          else {
                            uint64_t v746 = (os_log_s *)mDNSLogCategory_Default_redacted;
                          }
                          if (!os_log_type_enabled(v746, OS_LOG_TYPE_DEFAULT)) {
                            goto LABEL_2044;
                          }
                          socklen_t v1414 = *(_DWORD *)(v76 + 184);
                          for (kuint64_t k = v1504; ; kuint64_t k = (sockaddr *)((char *)kk + v749 + 1))
                          {
                            LOWORD(v748) = 257;
                            if (kk >= (sockaddr *)v1518 || !kk) {
                              goto LABEL_2041;
                            }
                            uint64_t v749 = kk->sa_len;
                            if (v749 > 0x3F)
                            {
                              LOWORD(v748) = 257;
                              goto LABEL_2041;
                            }

                            if (!kk->sa_len) {
                              break;
                            }
                          }

                          unsigned int v748 = (_DWORD)kk - (v1501 + 32) + 1;
                        }

LABEL_2041:
                        socklen_t v1204 = (unsigned __int16)v748;
                        socklen_t st_rdev_low = LOWORD(v1489.st_rdev);
                        socklen_t v1206 = *(_DWORD *)(v76 + 232);
                        int v1207 = *(_DWORD *)(v76 + 236);
                        int v1208 = *(_DWORD *)(v76 + 172);
                        int v1209 = mDNS_DomainNameFNV1aHash(&v1504[0].sa_len);
                        __src[0] = 67111427;
                        __src[1] = v1414;
                        LOWORD(__src[2]) = 2160;
                        *(void *)((char *)&__src[2] + 2) = 1752392040LL;
                        HIWORD(__src[4]) = 1040;
                        __src[5] = v1204;
                        LOWORD(__src[6]) = 2101;
                        *(void *)((char *)&__src[6] + 2) = v1504;
                        HIWORD(__src[8]) = 1024;
                        __src[9] = st_rdev_low;
                        LOWORD(__src[10]) = 1024;
                        *(socklen_t *)((char *)&__src[10] + 2) = v1206;
                        HIWORD(__src[11]) = 1024;
                        LODWORD(v1461[0]) = v1207;
                        WORD2(v1461[0]) = 1024;
                        *(_DWORD *)((char *)v1461 + 6) = v1208;
                        WORD5(v1461[0]) = 2082;
                        *(void *)((char *)v1461 + 12) = v76 + 240;
                        WORD2(v1461[1]) = 1024;
                        *(_DWORD *)((char *)&v1461[1] + 6) = v1209;
                        v958 = v746;
                        v959 = "[R%u] DNSServiceQueryRecord START -- qname: %{sensitive, mask.hash, mdnsresponder:domain_"
                               "name}.*P, qtype: %{mdns:rrtype}d, flags: 0x%X, interface index: %d, client pid: %d (%{pub"
                               "lic}s), name hash: %x";
                        goto LABEL_2042;
                      }

                      if (!gSensitiveLoggingEnabled
                        || (v645 ? (uint64_t v930 = mDNSLogCategory_mDNS) : (uint64_t v930 = mDNSLogCategory_Default),
                            v930 == mDNSLogCategory_State))
                      {
                        if (v645) {
                          v929 = (os_log_s *)mDNSLogCategory_mDNS;
                        }
                        else {
                          v929 = (os_log_s *)mDNSLogCategory_Default;
                        }
                        if (!os_log_type_enabled(v929, OS_LOG_TYPE_DEFAULT)) {
                          goto LABEL_2044;
                        }
                      }

                      else
                      {
                        if (v645) {
                          v929 = (os_log_s *)mDNSLogCategory_mDNS;
                        }
                        else {
                          v929 = (os_log_s *)mDNSLogCategory_Default_redacted;
                        }
                        if (!os_log_type_enabled(v929, OS_LOG_TYPE_DEFAULT)) {
                          goto LABEL_2044;
                        }
                      }
                    }

                    else
                    {
                      if (v646)
                      {
                        if (!gSensitiveLoggingEnabled
                          || (v645 ? (uint64_t v648 = mDNSLogCategory_mDNS) : (uint64_t v648 = mDNSLogCategory_Default),
                              v648 == mDNSLogCategory_State))
                        {
                          if (v645) {
                            uint64_t v649 = (os_log_s *)mDNSLogCategory_mDNS;
                          }
                          else {
                            uint64_t v649 = (os_log_s *)mDNSLogCategory_Default;
                          }
                          if (os_log_type_enabled(v649, OS_LOG_TYPE_DEFAULT))
                          {
                            socklen_t v1412 = *(_DWORD *)(v76 + 184);
                            for (muint64_t m = v1504; ; muint64_t m = (sockaddr *)((char *)mm + v818 + 1))
                            {
                              LOWORD(v655) = 257;
                              if (mm >= (sockaddr *)v1518 || !mm) {
                                break;
                              }
                              uint64_t v818 = mm->sa_len;
                              if (v818 > 0x3F)
                              {
                                LOWORD(v655) = 257;
                                break;
                              }

                              if (!mm->sa_len)
                              {
                                unsigned int v655 = (_DWORD)mm - (v1501 + 32) + 1;
                                break;
                              }
                            }

LABEL_1900:
                            socklen_t v1089 = (unsigned __int16)v655;
                            socklen_t v1090 = LOWORD(v1489.st_rdev);
                            socklen_t v1091 = *(_DWORD *)(v76 + 232);
                            int v1092 = *(_DWORD *)(v76 + 236);
                            int v1093 = *(_DWORD *)(v76 + 172);
                            int v1094 = mDNS_DomainNameFNV1aHash(&v1504[0].sa_len);
                            __src[0] = 67111427;
                            __src[1] = v1412;
                            LOWORD(__src[2]) = 2160;
                            *(void *)((char *)&__src[2] + 2) = 1752392040LL;
                            HIWORD(__src[4]) = 1040;
                            __src[5] = v1089;
                            LOWORD(__src[6]) = 2101;
                            *(void *)((char *)&__src[6] + 2) = v1504;
                            HIWORD(__src[8]) = 1024;
                            __src[9] = v1090;
                            LOWORD(__src[10]) = 1024;
                            *(socklen_t *)((char *)&__src[10] + 2) = v1091;
                            HIWORD(__src[11]) = 1024;
                            LODWORD(v1461[0]) = v1092;
                            WORD2(v1461[0]) = 1024;
                            *(_DWORD *)((char *)v1461 + 6) = v1093;
                            WORD5(v1461[0]) = 2082;
                            *(void *)((char *)v1461 + 12) = v76 + 240;
                            WORD2(v1461[1]) = 1024;
                            *(_DWORD *)((char *)&v1461[1] + 6) = v1094;
                            v958 = v649;
                            v959 = "[R%u] DNSServiceQueryRecord START -- qname: %{sensitive, mask.hash, mdnsresponder:dom"
                                   "ain_name}.*P, qtype: %{mdns:rrtype}d, DNSSEC enabled, flags: 0x%X, interface index: %"
                                   "d, client pid: %d (%{public}s), name hash: %x";
LABEL_2042:
                            uint32_t v960 = 74;
                            goto LABEL_2043;
                          }
                        }

                        else
                        {
                          if (v645) {
                            uint64_t v649 = (os_log_s *)mDNSLogCategory_mDNS;
                          }
                          else {
                            uint64_t v649 = (os_log_s *)mDNSLogCategory_Default_redacted;
                          }
                          if (os_log_type_enabled(v649, OS_LOG_TYPE_DEFAULT))
                          {
                            socklen_t v1412 = *(_DWORD *)(v76 + 184);
                            for (nuint64_t n = v1504; ; nuint64_t n = (sockaddr *)((char *)nn + v656 + 1))
                            {
                              LOWORD(v655) = 257;
                              if (nn >= (sockaddr *)v1518 || !nn) {
                                goto LABEL_1900;
                              }
                              uint64_t v656 = nn->sa_len;
                              if (v656 > 0x3F)
                              {
                                LOWORD(v655) = 257;
                                goto LABEL_1900;
                              }

                              if (!nn->sa_len) {
                                break;
                              }
                            }

                            unsigned int v655 = (_DWORD)nn - (v1501 + 32) + 1;
                            goto LABEL_1900;
                          }
                        }

LABEL_2044:
                        *(void *)(v76 + 96) = 0LL;
                        v1210 = *(_UNKNOWN ****)(v76 + 48);
                        if (v1210)
                        {
                          if (v1210[2] == &_mdns_signed_browse_result_kind
                            && mdns_signed_browse_result_contains( *(void *)(v76 + 48),  &v1504[0].sa_len,  *(_DWORD *)(v76 + 236)))
                          {
                            v1211 = (os_log_s *)mDNSLogCategory_Default;
                            if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
                            {
                              if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEBUG))
                              {
LABEL_2060:
                                socklen_t v1216 = *(_DWORD *)(v76 + 184);
                                __src[0] = 67109120;
                                __src[1] = v1216;
                                _os_log_impl( (void *)&_mh_execute_header,  v1211,  OS_LOG_TYPE_DEBUG,  "[R%d] DNSServiceQueryRecord: Allowing signed result",  (uint8_t *)__src,  8u);
                              }
                            }

                            else
                            {
                              v1211 = (os_log_s *)mDNSLogCategory_Default_redacted;
                              if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEBUG)) {
                                goto LABEL_2060;
                              }
                            }
                          }

                          else
                          {
                            *(_BYTE *)(v76 + 274) = 0;
                            os_release(v1210);
                            *(void *)(v76 + 48) = 0LL;
                          }
                        }

                        *(void *)(v76 + 96) = queryrecord_termination_callback;
                        uint64_t v1212 = *(void *)(v76 + 128);
                        int updated = QueryRecordClientRequestStart( v1212,  (uint64_t)&v1489,  (uint64_t)queryrecord_result_reply,  v76,  v650,  v651,  v652,  v653);
                        if (updated) {
                          goto LABEL_1122;
                        }
                        if (*(_DWORD *)(v76 + 236) == -1) {
                          goto LABEL_666;
                        }
                        v1213 = (unsigned __int8 *)(v1212 + 356);
                        if (!IsLocalDomain(v1213)) {
                          goto LABEL_666;
                        }
                        uint64_t v1214 = *(unsigned int *)(v76 + 236);
                        if ((_DWORD)v1214)
                        {
                          if (AWDLInterfaceID && AWDLInterfaceID == v1214)
                          {
                            int v1215 = 1;
                          }

                          else
                          {
                            if (WiFiAwareInterfaceID) {
                              BOOL v1217 = WiFiAwareInterfaceID == v1214;
                            }
                            else {
                              BOOL v1217 = 0;
                            }
                            int v1215 = v1217;
                          }
                        }

                        else
                        {
                          int v1215 = (*(_DWORD *)(v76 + 232) >> 20) & 1;
                        }

                        __uint64_t record_start = mdns_powerlog_query_record_start((const char *)(v76 + 240), v1213, v1215);
                        int updated = 0;
LABEL_2069:
                        *(void *)(v76 + 8) = record_start;
                        goto LABEL_1122;
                      }

                      if (!gSensitiveLoggingEnabled
                        || (v645 ? (uint64_t v928 = mDNSLogCategory_mDNS) : (uint64_t v928 = mDNSLogCategory_Default),
                            v928 == mDNSLogCategory_State))
                      {
                        if (v645) {
                          v929 = (os_log_s *)mDNSLogCategory_mDNS;
                        }
                        else {
                          v929 = (os_log_s *)mDNSLogCategory_Default;
                        }
                        if (!os_log_type_enabled(v929, OS_LOG_TYPE_DEFAULT)) {
                          goto LABEL_2044;
                        }
                      }

                      else
                      {
                        if (v645) {
                          v929 = (os_log_s *)mDNSLogCategory_mDNS;
                        }
                        else {
                          v929 = (os_log_s *)mDNSLogCategory_Default_redacted;
                        }
                        if (!os_log_type_enabled(v929, OS_LOG_TYPE_DEFAULT)) {
                          goto LABEL_2044;
                        }
                      }
                    }

                    socklen_t v956 = *(_DWORD *)(v76 + 184);
                    socklen_t v957 = mDNS_DomainNameFNV1aHash(&v1504[0].sa_len);
                    __src[0] = 67109376;
                    __src[1] = v956;
                    LOWORD(__src[2]) = 1024;
                    *(socklen_t *)((char *)&__src[2] + 2) = v957;
                    v958 = v929;
                    v959 = "[R%u] DNSServiceQueryRecord START -- name hash: %x";
                    uint32_t v960 = 14;
LABEL_2043:
                    _os_log_impl((void *)&_mh_execute_header, v958, OS_LOG_TYPE_DEFAULT, v959, (uint8_t *)__src, v960);
                    goto LABEL_2044;
                  case 9:
                    uint64_t v174 = (unsigned __int16 *)read_rr_from_ipc_msg(v76, 0, 0);
                    int updated = -65540;
                    if (!v174) {
                      goto LABEL_1122;
                    }
                    id v175 = v174;
                    uint64_t v176 = (uint64_t)(v174 + 4);
                    mDNS_Lock_((unsigned int *)mDNSStorage, (uint64_t)"mDNS_ReconfirmByValue", 15901);
                    uint64_t IdenticalRecordInCache = FindIdenticalRecordInCache((uint64_t)mDNSStorage, v176);
                    if (IdenticalRecordInCache)
                    {
                      mDNS_Reconfirm_internal((uint64_t)mDNSStorage, IdenticalRecordInCache, 0x1388u);
                      ReconfirmAntecedents( (uint64_t)mDNSStorage,  *(_BYTE **)(IdenticalRecordInCache + 40),  *(_DWORD *)(IdenticalRecordInCache + 24),  *(void *)(IdenticalRecordInCache + 32),  0);
                      int updated = 0;
                    }

                    else
                    {
                      int updated = -65541;
                    }

                    mDNS_Unlock_((uint64_t)mDNSStorage, (uint64_t)"mDNS_ReconfirmByValue", 15906);
                    BOOL v386 = _shouldLogFullRequestInfo((int *)(v76 + 188), (_DWORD *)(v76 + 192));
                    int v387 = (unsigned __int8 *)*((void *)v175 + 5);
                    char v388 = gSensitiveLoggingEnabled;
                    uint64_t v389 = mDNSLogCategory_mDNS;
                    if (mDNSLogCategory_mDNS == mDNSLogCategory_State) {
                      char v388 = 0;
                    }
                    if (IdenticalRecordInCache)
                    {
                      if (v386)
                      {
                        if (!v387)
                        {
                          if ((v388 & 1) != 0)
                          {
                            uint64_t v488 = mDNSLogCategory_mDNS_redacted;
                            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
                              goto LABEL_1209;
                            }
                            int v489 = *(_DWORD *)(v76 + 184);
                            int v490 = *(_DWORD *)(v76 + 172);
                            int v492 = *(_DWORD *)(v76 + 232);
                            int v491 = *(_DWORD *)(v76 + 236);
                            int v493 = v175[6];
                            v1489.dev_t st_dev = 67111171;
                            *(_DWORD *)&v1489.st_mode = v489;
                            LOWORD(v1489.st_ino) = 2160;
                            *(__darwin_ino64_t *)((char *)&v1489.st_ino + 2) = 1752392040LL;
                            HIWORD(v1489.st_uid) = 1040;
                            v1489.st_gid = 0;
                            LOWORD(v1489.st_rdev) = 2101;
                            *(void *)((char *)&v1489.st_rdev + 2) = 0LL;
                            WORD1(v1489.st_atimespec.tv_sec) = 1024;
                            HIDWORD(v1489.st_atimespec.tv_sec) = v493;
                            LOWORD(v1489.st_atimespec.tv_nsec) = 1024;
                            *(_DWORD *)((char *)&v1489.st_atimespec.tv_nsec + 2) = v492;
                            HIWORD(v1489.st_atimespec.tv_nsec) = 1024;
                            LODWORD(v1489.st_mtimespec.tv_sec) = v491;
                            WORD2(v1489.st_mtimespec.tv_sec) = 1024;
                            *(_DWORD *)((char *)&v1489.st_mtimespec.tv_sec + 6) = v490;
                            WORD1(v1489.st_mtimespec.tv_nsec) = 2082;
                            *(uint64_t *)((char *)&v1489.st_mtimespec.tv_nsec + 4) = v76 + 240;
                            unsigned int v416 = (os_log_s *)v488;
                            int v417 = "[R%u] DNSServiceReconfirmRecord START -- rr name: %{sensitive, mask.hash, mdnsrespond"
                                   "er:domain_name}.*P, rr type: %{mdns:rrtype}d, flags: 0x%X, interface index: %d, clien"
                                   "t pid: %d (%{public}s), ";
                          }

                          else
                          {
                            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
                              goto LABEL_1209;
                            }
                            int v552 = *(_DWORD *)(v76 + 184);
                            int v553 = *(_DWORD *)(v76 + 172);
                            int v555 = *(_DWORD *)(v76 + 232);
                            int v554 = *(_DWORD *)(v76 + 236);
                            int v556 = v175[6];
                            v1489.dev_t st_dev = 67111171;
                            *(_DWORD *)&v1489.st_mode = v552;
                            LOWORD(v1489.st_ino) = 2160;
                            *(__darwin_ino64_t *)((char *)&v1489.st_ino + 2) = 1752392040LL;
                            HIWORD(v1489.st_uid) = 1040;
                            v1489.st_gid = 0;
                            LOWORD(v1489.st_rdev) = 2101;
                            *(void *)((char *)&v1489.st_rdev + 2) = 0LL;
                            WORD1(v1489.st_atimespec.tv_sec) = 1024;
                            HIDWORD(v1489.st_atimespec.tv_sec) = v556;
                            LOWORD(v1489.st_atimespec.tv_nsec) = 1024;
                            *(_DWORD *)((char *)&v1489.st_atimespec.tv_nsec + 2) = v555;
                            HIWORD(v1489.st_atimespec.tv_nsec) = 1024;
                            LODWORD(v1489.st_mtimespec.tv_sec) = v554;
                            WORD2(v1489.st_mtimespec.tv_sec) = 1024;
                            *(_DWORD *)((char *)&v1489.st_mtimespec.tv_sec + 6) = v553;
                            WORD1(v1489.st_mtimespec.tv_nsec) = 2082;
                            *(uint64_t *)((char *)&v1489.st_mtimespec.tv_nsec + 4) = v76 + 240;
                            unsigned int v416 = (os_log_s *)v389;
                            int v417 = "[R%u] DNSServiceReconfirmRecord START -- rr name: %{sensitive, mask.hash, mdnsrespond"
                                   "er:domain_name}.*P, rr type: %{mdns:rrtype}d, flags: 0x%X, interface index: %d, clien"
                                   "t pid: %d (%{public}s), ";
                          }

                          uint32_t v557 = 68;
LABEL_1208:
                          _os_log_impl( (void *)&_mh_execute_header,  v416,  OS_LOG_TYPE_DEFAULT,  v417,  (uint8_t *)&v1489,  v557);
LABEL_1209:
                          int v732 = v175;
                          goto LABEL_1210;
                        }

                        if ((v388 & 1) != 0)
                        {
                          uint64_t v390 = mDNSLogCategory_mDNS_redacted;
                          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
                            goto LABEL_1209;
                          }
                          uint64_t v391 = v387;
                          v1405 = (os_log_s *)v390;
                          int v1388 = *(_DWORD *)(v76 + 184);
                          if (v387 == (unsigned __int8 *)-256LL)
                          {
                            while (1)
                            {
LABEL_614:
                              if (!v391) {
                                goto LABEL_1032;
                              }
                              uint64_t v392 = *v391;
                              if (!*v391) {
                                break;
                              }
                              v391 += v392 + 1;
                            }

                            unsigned __int16 v621 = (_WORD)v391 - (_WORD)v387 + 1;
                          }

                          else
                          {
LABEL_613:
                            if (v391 < v387 + 256) {
                              goto LABEL_614;
                            }
LABEL_1032:
                            unsigned __int16 v621 = 257;
                          }

                          gid_t v696 = v621;
                          int v697 = v175[6];
                          int v698 = *(_DWORD *)(v76 + 232);
                          int v1365 = *(_DWORD *)(v76 + 236);
                          int v699 = *(_DWORD *)(v76 + 172);
                          int v700 = mDNS_DomainNameFNV1aHash(v387);
                          v1489.dev_t st_dev = 67111427;
                          *(_DWORD *)&v1489.st_mode = v1388;
                          LOWORD(v1489.st_ino) = 2160;
                          *(__darwin_ino64_t *)((char *)&v1489.st_ino + 2) = 1752392040LL;
                          HIWORD(v1489.st_uid) = 1040;
                          v1489.st_gid = v696;
                          LOWORD(v1489.st_rdev) = 2101;
                          *(void *)((char *)&v1489.st_rdev + 2) = v387;
                          WORD1(v1489.st_atimespec.tv_sec) = 1024;
                          HIDWORD(v1489.st_atimespec.tv_sec) = v697;
                          LOWORD(v1489.st_atimespec.tv_nsec) = 1024;
                          *(_DWORD *)((char *)&v1489.st_atimespec.tv_nsec + 2) = v698;
                          HIWORD(v1489.st_atimespec.tv_nsec) = 1024;
                          LODWORD(v1489.st_mtimespec.tv_sec) = v1365;
                          WORD2(v1489.st_mtimespec.tv_sec) = 1024;
                          *(_DWORD *)((char *)&v1489.st_mtimespec.tv_sec + 6) = v699;
                          WORD1(v1489.st_mtimespec.tv_nsec) = 2082;
                          *(uint64_t *)((char *)&v1489.st_mtimespec.tv_nsec + 4) = v76 + 240;
                          WORD2(v1489.st_ctimespec.tv_sec) = 1024;
                          *(_DWORD *)((char *)&v1489.st_ctimespec.tv_sec + 6) = v700;
                          unsigned int v416 = v1405;
                          int v417 = "[R%u] DNSServiceReconfirmRecord START -- rr name: %{sensitive, mask.hash, mdnsresponder"
                                 ":domain_name}.*P, rr type: %{mdns:rrtype}d, flags: 0x%X, interface index: %d, client pi"
                                 "d: %d (%{public}s), name hash: %x";
                        }

                        else
                        {
                          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
                            goto LABEL_1209;
                          }
                          uint64_t v500 = v387;
                          int v1408 = *(_DWORD *)(v76 + 184);
                          if (v387 == (unsigned __int8 *)-256LL)
                          {
                            while (1)
                            {
LABEL_811:
                              if (!v500) {
                                goto LABEL_1033;
                              }
                              uint64_t v501 = *v500;
                              if (!*v500) {
                                break;
                              }
                              v500 += v501 + 1;
                            }

                            unsigned __int16 v622 = (_WORD)v500 - (_WORD)v387 + 1;
                          }

                          else
                          {
LABEL_810:
                            if (v500 < v387 + 256) {
                              goto LABEL_811;
                            }
LABEL_1033:
                            unsigned __int16 v622 = 257;
                          }

                          gid_t v701 = v622;
                          int v702 = v175[6];
                          int v703 = *(_DWORD *)(v76 + 232);
                          __nint j = *(_DWORD *)(v76 + 236);
                          int v1366 = *(_DWORD *)(v76 + 172);
                          int v704 = mDNS_DomainNameFNV1aHash(v387);
                          v1489.dev_t st_dev = 67111427;
                          *(_DWORD *)&v1489.st_mode = v1408;
                          LOWORD(v1489.st_ino) = 2160;
                          *(__darwin_ino64_t *)((char *)&v1489.st_ino + 2) = 1752392040LL;
                          HIWORD(v1489.st_uid) = 1040;
                          v1489.st_gid = v701;
                          LOWORD(v1489.st_rdev) = 2101;
                          *(void *)((char *)&v1489.st_rdev + 2) = v387;
                          WORD1(v1489.st_atimespec.tv_sec) = 1024;
                          HIDWORD(v1489.st_atimespec.tv_sec) = v702;
                          LOWORD(v1489.st_atimespec.tv_nsec) = 1024;
                          *(_DWORD *)((char *)&v1489.st_atimespec.tv_nsec + 2) = v703;
                          HIWORD(v1489.st_atimespec.tv_nsec) = 1024;
                          LODWORD(v1489.st_mtimespec.tv_sec) = __nj;
                          WORD2(v1489.st_mtimespec.tv_sec) = 1024;
                          *(_DWORD *)((char *)&v1489.st_mtimespec.tv_sec + 6) = v1366;
                          WORD1(v1489.st_mtimespec.tv_nsec) = 2082;
                          *(uint64_t *)((char *)&v1489.st_mtimespec.tv_nsec + 4) = v76 + 240;
                          WORD2(v1489.st_ctimespec.tv_sec) = 1024;
                          *(_DWORD *)((char *)&v1489.st_ctimespec.tv_sec + 6) = v704;
                          unsigned int v416 = (os_log_s *)v389;
                          int v417 = "[R%u] DNSServiceReconfirmRecord START -- rr name: %{sensitive, mask.hash, mdnsresponder"
                                 ":domain_name}.*P, rr type: %{mdns:rrtype}d, flags: 0x%X, interface index: %d, client pi"
                                 "d: %d (%{public}s), name hash: %x";
                        }

LABEL_1166:
                        uint32_t v557 = 74;
                        goto LABEL_1208;
                      }

                      if (v387)
                      {
                        if ((v388 & 1) != 0)
                        {
                          uint64_t v413 = mDNSLogCategory_mDNS_redacted;
                          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
                            goto LABEL_1209;
                          }
                          int v414 = *(_DWORD *)(v76 + 184);
                          int v415 = mDNS_DomainNameFNV1aHash(v387);
                          v1489.dev_t st_dev = 67109376;
                          *(_DWORD *)&v1489.st_mode = v414;
                          LOWORD(v1489.st_ino) = 1024;
                          *(_DWORD *)((char *)&v1489.st_ino + 2) = v415;
                          unsigned int v416 = (os_log_s *)v413;
                          int v417 = "[R%u] DNSServiceReconfirmRecord START -- name hash: %x";
                        }

                        else
                        {
                          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
                            goto LABEL_1209;
                          }
                          int v550 = *(_DWORD *)(v76 + 184);
                          int v551 = mDNS_DomainNameFNV1aHash(v387);
                          v1489.dev_t st_dev = 67109376;
                          *(_DWORD *)&v1489.st_mode = v550;
                          LOWORD(v1489.st_ino) = 1024;
                          *(_DWORD *)((char *)&v1489.st_ino + 2) = v551;
                          unsigned int v416 = (os_log_s *)v389;
                          int v417 = "[R%u] DNSServiceReconfirmRecord START -- name hash: %x";
                        }

LABEL_507:
                    uint64_t v333 = (unsigned int *)&v178[v183];
                    if (v178) {
                      BOOL v334 = (unint64_t)v333 > v180;
                    }
                    else {
                      BOOL v334 = 1;
                    }
                    if (v334)
                    {
                      uint64_t v333 = 0LL;
                      int v336 = 0LL;
                    }

                    else
                    {
                      int v336 = v178;
                    }

                    *(void *)(v76 + 72) = v333;
                    if (v333 && (uint64_t v337 = v333 + 1, (unint64_t)(v333 + 1) <= v180))
                    {
                      unsigned int v338 = bswap32(*v333);
                      *(void *)(v76 + 72) = v337;
                      if (v338)
                      {
                        goto LABEL_520;
                      }
                    }

                    else
                    {
                      uint64_t v337 = 0LL;
                      *(void *)(v76 + 72) = 0LL;
                    }

                    unsigned int v338 = 4500;
                    if (!v337)
                    {
LABEL_529:
                      uint64_t v343 = mDNSLogCategory_mDNS;
                      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
                      {
                        int updated = -65540;
                        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
                          goto LABEL_1122;
                        }
                      }

                      else
                      {
                        uint64_t v343 = mDNSLogCategory_mDNS_redacted;
                        int updated = -65540;
                        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
                          goto LABEL_1122;
                        }
                      }

                      int v344 = *(_DWORD *)(v76 + 184);
                      v1489.dev_t st_dev = 67109120;
                      *(_DWORD *)&v1489.st_mode = v344;
                      uint64_t v114 = &v1489;
                      uint64_t v115 = (os_log_s *)v343;
                      os_log_type_t v116 = OS_LOG_TYPE_DEFAULT;
                      unsigned int v117 = "[R%d] DNSServiceAddRecord(unreadable parameters)";
                      goto LABEL_1119;
                    }

LABEL_1294:
                          dev_t v710 = v399;
                        }

                        else
                        {
                          dev_t v710 = 0;
                        }

                        dev_t v1362 = v710;
                        __darwin_time_t __nc = v397;
                      }

                      else
                      {
                        dev_t v1362 = 0;
                        __darwin_time_t __nc = 0LL;
                      }

                      int v765 = *(_DWORD *)(v340 + 184);
                      uint64_t v766 = DNSTypeName(v179);
                      int v767 = *(_DWORD *)(v340 + 172);
                      v1489.dev_t st_dev = 67111171;
                      *(_DWORD *)&v1489.st_mode = v765;
                      LOWORD(v1489.st_ino) = 1024;
                      *(_DWORD *)((char *)&v1489.st_ino + 2) = v182;
                      HIWORD(v1489.st_ino) = 2160;
                      *(void *)&v1489.st_uid = 1752392040LL;
                      LOWORD(v1489.st_rdev) = 1040;
                      *(dev_t *)((char *)&v1489.st_rdev + 2) = v1362;
                      *((_WORD *)&v1489.st_rdev + 3) = 2101;
                      v768 = v1389;
                      v1489.st_atimespec.tv_sec = __nc;
                      LOWORD(v1489.st_atimespec.tv_nsec) = 2082;
                      *(uint64_t *)((char *)&v1489.st_atimespec.tv_nsec + 2) = (uint64_t)v766;
                      WORD1(v1489.st_mtimespec.tv_sec) = 1024;
                      HIDWORD(v1489.st_mtimespec.tv_sec) = v183;
                      LOWORD(v1489.st_mtimespec.tv_nsec) = 1024;
                      *(_DWORD *)((char *)&v1489.st_mtimespec.tv_nsec + 2) = v767;
                      HIWORD(v1489.st_mtimespec.tv_nsec) = 2082;
                      v1489.st_ctimespec.tv_sec = v340 + 240;
                      goto LABEL_1301;
                    }

                    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
                      goto LABEL_1302;
                    }
                    uint64_t v532 = *(void *)(v1406 + 1624);
                    if (!v532)
                    {
                      dev_t v1363 = 0;
                      __darwin_time_t __nd = 0LL;
                      goto LABEL_1300;
                    }

                    __darwin_time_t v533 = *(void *)(v532 + 2736);
                    if (!v533)
                    {
                      dev_t v711 = 0;
                      goto LABEL_1299;
                    }

                    uint64_t v534 = *(_BYTE **)(v532 + 2736);
                    if (v533 != -256) {
                      goto LABEL_880;
                    }
                    while (2)
                    {
                      if (!v534) {
                        goto LABEL_1225;
                      }
LABEL_884:
                      uint64_t v536 = *v534;
                      if (v536 > 0x3F)
                      {
LABEL_1225:
                        unsigned __int16 v535 = 257;
                      }

                      else
                      {
                        if (*v534)
                        {
                          v534 += v536 + 1;
                          if (v533 == -256) {
                            continue;
                          }
LABEL_880:
                          unsigned __int16 v535 = 257;
                          goto LABEL_884;
                        }

                        unsigned __int16 v535 = (_WORD)v534 - v533 + 1;
                      }

                      break;
                    }

                    dev_t v711 = v535;
LABEL_1299:
                    dev_t v1363 = v711;
                    __darwin_time_t __nd = v533;
LABEL_1300:
                    int v1393 = *(_DWORD *)(v340 + 184);
                    uint64_t v769 = DNSTypeName(v179);
                    int v770 = *(_DWORD *)(v340 + 172);
                    v1489.dev_t st_dev = 67111171;
                    *(_DWORD *)&v1489.st_mode = v1393;
                    LOWORD(v1489.st_ino) = 1024;
                    *(_DWORD *)((char *)&v1489.st_ino + 2) = v182;
                    HIWORD(v1489.st_ino) = 2160;
                    *(void *)&v1489.st_uid = 1752392040LL;
                    LOWORD(v1489.st_rdev) = 1040;
                    *(dev_t *)((char *)&v1489.st_rdev + 2) = v1363;
                    *((_WORD *)&v1489.st_rdev + 3) = 2101;
                    v1489.st_atimespec.tv_sec = __nd;
                    LOWORD(v1489.st_atimespec.tv_nsec) = 2082;
                    *(uint64_t *)((char *)&v1489.st_atimespec.tv_nsec + 2) = (uint64_t)v769;
                    WORD1(v1489.st_mtimespec.tv_sec) = 1024;
                    HIDWORD(v1489.st_mtimespec.tv_sec) = v183;
                    LOWORD(v1489.st_mtimespec.tv_nsec) = 1024;
                    *(_DWORD *)((char *)&v1489.st_mtimespec.tv_nsec + 2) = v770;
                    HIWORD(v1489.st_mtimespec.tv_nsec) = 2082;
                    v1489.st_ctimespec.tv_sec = v340 + 240;
                    v768 = (os_log_s *)v394;
LABEL_1301:
                    _os_log_impl( (void *)&_mh_execute_header,  v768,  OS_LOG_TYPE_DEFAULT,  "[R%d] DNSServiceAddRecord(%X, %{sensitive, mask.hash, mdnsresponder:domain_name}.*P, %{public}s, % d) PID[%d](%{public}s)",  (uint8_t *)&v1489,  0x48u);
LABEL_1302:
                    uint64_t v771 = *(void *)(v1406 + 1624);
                    if (!v771)
                    {
                      int updated = -65537;
                      goto LABEL_1122;
                    }

                    do
                    {
                      int v772 = add_record_to_service(v340, v771, v179, v183, v336, v338);
                      if (v772 && *(_BYTE *)(v771 + 26))
                      {
LABEL_1998:
                        int updated = v772;
                        goto LABEL_1122;
                      }

                      int updated = 0;
                      uint64_t v771 = *(void *)v771;
                    }

                    while (v771);
                    goto LABEL_1122;
                  case 11:
                    uint64_t v185 = 0LL;
                    uint64_t v186 = 0LL;
                    uint64_t v188 = *(void *)(v76 + 72);
                    unint64_t v187 = *(void *)(v76 + 80);
                    if (v188)
                    {
                      if (v188 + 4 <= v187)
                      {
                        uint64_t v185 = 0LL;
                        uint64_t v186 = 0LL;
                        *(void *)(v76 + 72) = v188 + 4;
                        if (v188 != -4 && v188 + 6 <= v187)
                        {
                          uint64_t v185 = bswap32(*(unsigned __int16 *)(v188 + 4)) >> 16;
                          uint64_t v186 = (unsigned __int8 *)(v188 + 6);
                        }
                      }
                    }

                    unsigned int v189 = (unsigned int *)&v186[v185];
                    if (v186) {
                      BOOL v190 = (unint64_t)v189 > v187;
                    }
                    else {
                      BOOL v190 = 1;
                    }
                    if (v190)
                    {
                      unsigned int v189 = 0LL;
                      BOOL v192 = 0LL;
                    }

                    else
                    {
                      BOOL v192 = v186;
                    }

                    *(void *)(v76 + 72) = v189;
                    if (v189 && (unint64_t)(v189 + 1) <= v187)
                    {
                      unsigned int v193 = *v189;
                      *(void *)(v76 + 72) = v189 + 1;
                      if (v189 != (unsigned int *)-4LL)
                      {
                        *(_DWORD *)&v1504[0].sa_leuint64_t n = 0;
                        __src[0] = 0;
                        int v1403 = get_service_attr_tsr_params(v76, (int *)v1504, __src);
                        if (!v1403) {
                          goto LABEL_760;
                        }
                        uint64_t v194 = (os_log_s *)mDNSLogCategory_mDNS;
                        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
                        {
                          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
                            goto LABEL_760;
                          }
                        }

                        else
                        {
                          uint64_t v194 = (os_log_s *)mDNSLogCategory_mDNS_redacted;
                          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
                            goto LABEL_760;
                          }
                        }

                        int v472 = *(_DWORD *)(v76 + 184);
                        v1489.dev_t st_dev = 67109632;
                        *(_DWORD *)&v1489.st_mode = v472;
                        LOWORD(v1489.st_ino) = 1024;
                        *(_DWORD *)((char *)&v1489.st_ino + 2) = *(_DWORD *)&v1504[0].sa_len;
                        HIWORD(v1489.st_ino) = 1024;
                        v1489.st_uid = __src[0];
                        _os_log_impl( (void *)&_mh_execute_header,  v194,  OS_LOG_TYPE_DEFAULT,  "[R%u] DNSServiceUpdateRecord foundTSRParams tsrTimestamp[%u] hostkeyHash[%x]",  (uint8_t *)&v1489,  0x14u);
LABEL_760:
                        int v473 = bswap32(v193);
                        uint64_t v475 = (void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, int))(v76 + 96);
                        int v474 = *(void (**)(uint64_t))(v76 + 96);
                        if (v474 == connection_termination)
                        {
                          uint64_t v477 = LocateSubordinateRequest(v76);
                          uint64_t v476 = v477;
                          uint64_t v475 = (void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, int))(v477 + 96);
                          int v474 = *(void (**)(uint64_t))(v477 + 96);
                          if (v474 == connection_termination)
                          {
                            v1391 = (_DWORD *)v477;
                            uint64_t v484 = *(void *)(v477 + 160);
                            int updated = -65541;
                            if (!v484) {
                              goto LABEL_1797;
                            }
                            while (*(_DWORD *)(v484 + 56) != *(_DWORD *)(v76 + 224))
                            {
                              uint64_t v484 = *(void *)(v484 + 8);
                              if (!v484) {
                                goto LABEL_1797;
                              }
                            }

                            uint64_t v685 = *(void *)(v484 + 24);
                            if (v1403) {
                              int v686 = handle_tsr_update_request(v477, v685, *(unsigned int *)&v1504[0].sa_len, __src[0]);
                            }
                            else {
                              int v686 = update_record(v685, v185, v192, v473, v484 + 60, *(_DWORD *)(v477 + 184));
                            }
                            int updated = v686;
                            __int16 v750 = (os_log_s *)mDNSLogCategory_mDNS;
                            if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
                            {
                              if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
                                goto LABEL_1796;
                              }
                              uint64_t v752 = *(void *)(v484 + 24);
                              uint64_t v753 = *(void *)(v752 + 40);
                              if (v753)
                              {
                                v754 = *(_BYTE **)(v752 + 40);
                                if (v753 == -256)
                                {
                                  while (1)
                                  {
LABEL_1269:
                                    if (!v754) {
                                      goto LABEL_1677;
                                    }
                                    uint64_t v755 = *v754;
                                    if (!*v754) {
                                      break;
                                    }
                                    v754 += v755 + 1;
                                    if (v753 != -256) {
                                      goto LABEL_1268;
                                    }
                                  }

                                  unsigned __int16 v954 = (_WORD)v754 - v753 + 1;
                                }

                                else
                                {
LABEL_1268:
LABEL_1677:
                                  unsigned __int16 v954 = 257;
                                }

                                gid_t v983 = v954;
                              }

                              else
                              {
                                gid_t v983 = 0;
                              }

                              v1015 = v1391;
                              int v1016 = v1391[46];
                              v1017 = DNSTypeName(*(unsigned __int16 *)(v752 + 12));
                              int v1018 = v1391[43];
                              v1019 = " & TSR";
                              if (!v1403) {
                                v1019 = "";
                              }
                            }

                            else
                            {
                              __int16 v750 = (os_log_s *)mDNSLogCategory_mDNS_redacted;
                              if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
                                goto LABEL_1796;
                              }
                              uint64_t v757 = *(void *)(v484 + 24);
                              uint64_t v753 = *(void *)(v757 + 40);
                              if (v753)
                              {
                                uint64_t v758 = *(_BYTE **)(v757 + 40);
                                if (v753 == -256)
                                {
                                  while (1)
                                  {
LABEL_1278:
                                    if (!v758) {
                                      goto LABEL_1678;
                                    }
                                    uint64_t v759 = *v758;
                                    if (!*v758) {
                                      break;
                                    }
                                    v758 += v759 + 1;
                                    if (v753 != -256) {
                                      goto LABEL_1277;
                                    }
                                  }

                                  unsigned __int16 v955 = (_WORD)v758 - v753 + 1;
                                }

                                else
                                {
LABEL_1277:
LABEL_1678:
                                  unsigned __int16 v955 = 257;
                                }

                                gid_t v983 = v955;
                              }

                              else
                              {
                                gid_t v983 = 0;
                              }

                              v1015 = v1391;
                              int v1016 = v1391[46];
                              v1017 = DNSTypeName(*(unsigned __int16 *)(v757 + 12));
                              int v1018 = v1391[43];
                              v1019 = " & TSR";
                              if (!v1403) {
                                v1019 = "";
                              }
                            }

                            v1489.dev_t st_dev = 67110915;
                            *(_DWORD *)&v1489.st_mode = v1016;
                            LOWORD(v1489.st_ino) = 2160;
                            *(__darwin_ino64_t *)((char *)&v1489.st_ino + 2) = 1752392040LL;
                            HIWORD(v1489.st_uid) = 1040;
                            v1489.st_gid = v983;
                            LOWORD(v1489.st_rdev) = 2101;
                            *(void *)((char *)&v1489.st_rdev + 2) = v753;
                            WORD1(v1489.st_atimespec.tv_sec) = 2082;
                            *(__darwin_time_t *)((char *)&v1489.st_atimespec.tv_sec + 4) = (__darwin_time_t)v1017;
                            WORD2(v1489.st_atimespec.tv_nsec) = 2082;
                            *(uint64_t *)((char *)&v1489.st_atimespec.tv_nsec + 6) = (uint64_t)v1019;
                            HIWORD(v1489.st_mtimespec.tv_sec) = 1024;
                            LODWORD(v1489.st_mtimespec.tv_nsec) = v1018;
                            WORD2(v1489.st_mtimespec.tv_nsec) = 2082;
                            *(uint64_t *)((char *)&v1489.st_mtimespec.tv_nsec + 6) = (uint64_t)(v1015 + 60);
                            _os_log_impl( (void *)&_mh_execute_header,  v750,  OS_LOG_TYPE_DEFAULT,  "[R%u] DNSServiceUpdateRecord(%{sensitive, mask.hash, mdnsresponder:domain_name}.*P, %{publ ic}s%{public}s) PID[%d](%{public}s)",  (uint8_t *)&v1489,  0x46u);
                            goto LABEL_1796;
                          }
                        }

                        else
                        {
                          uint64_t v476 = v76;
                        }

                        if ((char *)v474 != (char *)regservice_termination_callback)
                        {
                          uint64_t v478 = mDNSLogCategory_mDNS;
                          if (gSensitiveLoggingEnabled == 1 && mDNSLogCategory_mDNS != mDNSLogCategory_State)
                          {
                            uint64_t v478 = mDNSLogCategory_mDNS_redacted;
                            int updated = -65540;
                            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
                              goto LABEL_1122;
                            }
LABEL_767:
                            int v479 = *(_DWORD *)(v476 + 184);
                            v1489.dev_t st_dev = 67109120;
                            *(_DWORD *)&v1489.st_mode = v479;
                            uint64_t v114 = &v1489;
                            uint64_t v115 = (os_log_s *)v478;
                            os_log_type_t v116 = OS_LOG_TYPE_DEFAULT;
                            unsigned int v117 = "[R%d] DNSServiceUpdateRecord(not a registered service ref)";
                            goto LABEL_1119;
                          }

                          int updated = -65540;
                          if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
                            goto LABEL_767;
                          }
                          goto LABEL_1122;
                        }

                        uint64_t v480 = *(void *)(v476 + 112);
                        if (!*(_WORD *)(v480 + 24))
                        {
                          uint64_t v593 = mDNSLogCategory_mDNS;
                          if (gSensitiveLoggingEnabled == 1 && mDNSLogCategory_mDNS != mDNSLogCategory_State)
                          {
                            uint64_t v593 = mDNSLogCategory_mDNS_redacted;
                            int updated = -65540;
                            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
                              goto LABEL_1122;
                            }
LABEL_987:
                            int v594 = *(_DWORD *)(v476 + 184);
                            v1489.dev_t st_dev = 67109120;
                            *(_DWORD *)&v1489.st_mode = v594;
                            uint64_t v114 = &v1489;
                            uint64_t v115 = (os_log_s *)v593;
                            os_log_type_t v116 = OS_LOG_TYPE_DEFAULT;
                            unsigned int v117 = "[R%d] DNSServiceUpdateRecord: updating the record of a service registered with zero port";
                            goto LABEL_1119;
                          }

                          int updated = -65540;
                          if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
                            goto LABEL_987;
                          }
                          goto LABEL_1122;
                        }

                        if (!v1403 && *(_DWORD *)(v76 + 224) == -1)
                        {
                          v481 = *(void **)(v480 + 16);
                          if (v481)
                          {
                            free(v481);
                            *(void *)(v480 + 16) = 0LL;
                          }

                          if ((_DWORD)v185)
                          {
                            v482 = malloc(v185);
                            if (!v482) {
                              goto LABEL_2255;
                            }
                            *(void *)(v480 + 16) = v482;
                            memcpy(v482, v192, v185);
                          }

                          *(_WORD *)(v480 + 8) = v185;
                        }

                        v1391 = (_DWORD *)v476;
                        uint64_t v483 = *(uint64_t **)(v480 + 1624);
                        int updated = -65541;
                        if (v483)
                        {
                          uint64_t v484 = 0LL;
                          while (1)
                          {
                            int v485 = *(_DWORD *)(v76 + 224);
                            if (v485 == -1)
                            {
                              uint64_t v484 = (uint64_t)(v483 + 484);
                            }

                            else
                            {
                              v486 = v483 + 39;
                              while (1)
                              {
                                v486 = (uint64_t *)*v486;
                                if (!v486) {
                                  break;
                                }
                                if (*((_DWORD *)v486 + 2) == v485)
                                {
                                  uint64_t v484 = (uint64_t)(v486 + 2);
                                  goto LABEL_786;
                                }
                              }

                              if (!v484) {
                                goto LABEL_1797;
                              }
                            }

LABEL_786:
                            if (v1403) {
                              break;
                            }
                            int v487 = update_record(v484, v185, v192, v473, (uint64_t)v483 + 27, v1391[46]);
                            if (v487 && *((_BYTE *)v483 + 26)) {
                              goto LABEL_1150;
                            }
                            uint64_t v483 = (uint64_t *)*v483;
                            if (!v483)
                            {
                              int updated = 0;
                              goto LABEL_1797;
                            }
                          }

                          int v487 = handle_tsr_update_request( (uint64_t)v1391,  v484,  *(unsigned int *)&v1504[0].sa_len,  __src[0]);
LABEL_1150:
                          int updated = v487;
LABEL_1797:
                          if (*v475 != regservice_termination_callback) {
                            goto LABEL_1122;
                          }
                          uint64_t v1020 = *(void *)(*((void *)v1391 + 14) + 1624LL);
                          if (v1020)
                          {
                            v1021 = *(_BYTE **)(v1020 + 2736);
                            if (v1021)
                            {
                              int v1022 = mDNS_DomainNameFNV1aHash(*(unsigned __int8 **)(v1020 + 2736));
                              char v1023 = 0;
                              goto LABEL_1803;
                            }
                          }

                          else
                          {
                            v1021 = 0LL;
                          }

                          int v1022 = 0;
                          char v1023 = 1;
LABEL_1803:
                          if (v484) {
                            int v1024 = *(unsigned __int16 *)(v484 + 12);
                          }
                          else {
                            int v1024 = 0;
                          }
                          uint64_t v1025 = mDNSLogCategory_mDNS;
                          if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
                          {
                            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
                              goto LABEL_1122;
                            }
                            if ((v1023 & 1) != 0)
                            {
                              gid_t v1026 = 0;
                            }

                            else
                            {
                              v1030 = v1021;
                              if (v1021 == (_BYTE *)-256LL) {
                                goto LABEL_1827;
                              }
LABEL_1824:
                              unsigned __int16 v1031 = 257;
                              if (v1030 < v1021 + 256 && v1030)
                              {
                                while (1)
                                {
                                  uint64_t v1032 = *v1030;
                                  if (v1032 > 0x3F)
                                  {
LABEL_1833:
                                    unsigned __int16 v1031 = 257;
                                    goto LABEL_1837;
                                  }

                                  if (!*v1030) {
                                    break;
                                  }
                                  v1030 += v1032 + 1;
                                  if (v1021 != (_BYTE *)-256LL) {
                                    goto LABEL_1824;
                                  }
LABEL_1827:
                                  if (!v1030) {
                                    goto LABEL_1833;
                                  }
                                }

                                unsigned __int16 v1031 = (_WORD)v1030 - (_WORD)v1021 + 1;
                              }

LABEL_1837:
                              gid_t v1026 = v1031;
                            }
                          }

                          else
                          {
                            uint64_t v1025 = mDNSLogCategory_mDNS_redacted;
                            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
                              goto LABEL_1122;
                            }
                            if ((v1023 & 1) != 0)
                            {
                              gid_t v1026 = 0;
                            }

                            else
                            {
                              v1027 = v1021;
                              if (v1021 == (_BYTE *)-256LL) {
                                goto LABEL_1818;
                              }
LABEL_1815:
                              unsigned __int16 v1028 = 257;
                              if (v1027 < v1021 + 256 && v1027)
                              {
                                while (1)
                                {
                                  uint64_t v1029 = *v1027;
                                  if (v1029 > 0x3F)
                                  {
LABEL_1832:
                                    unsigned __int16 v1028 = 257;
                                    goto LABEL_1835;
                                  }

                                  if (!*v1027) {
                                    break;
                                  }
                                  v1027 += v1029 + 1;
                                  if (v1021 != (_BYTE *)-256LL) {
                                    goto LABEL_1815;
                                  }
LABEL_1818:
                                  if (!v1027) {
                                    goto LABEL_1832;
                                  }
                                }

                                unsigned __int16 v1028 = (_WORD)v1027 - (_WORD)v1021 + 1;
                              }

LABEL_1835:
                              gid_t v1026 = v1028;
                            }
                          }

                          int v1033 = v1391[46];
                          int v1034 = v1391[43];
                          v1489.dev_t st_dev = 67110915;
                          *(_DWORD *)&v1489.st_mode = v1033;
                          LOWORD(v1489.st_ino) = 2160;
                          *(__darwin_ino64_t *)((char *)&v1489.st_ino + 2) = 1752392040LL;
                          HIWORD(v1489.st_uid) = 1040;
                          v1489.st_gid = v1026;
                          LOWORD(v1489.st_rdev) = 2101;
                          *(void *)((char *)&v1489.st_rdev + 2) = v1021;
                          WORD1(v1489.st_atimespec.tv_sec) = 1024;
                          HIDWORD(v1489.st_atimespec.tv_sec) = v1022;
                          LOWORD(v1489.st_atimespec.tv_nsec) = 1024;
                          *(_DWORD *)((char *)&v1489.st_atimespec.tv_nsec + 2) = v1024;
                          HIWORD(v1489.st_atimespec.tv_nsec) = 1024;
                          LODWORD(v1489.st_mtimespec.tv_sec) = v1034;
                          WORD2(v1489.st_mtimespec.tv_sec) = 2080;
                          *(__darwin_time_t *)((char *)&v1489.st_mtimespec.tv_sec + 6) = (__darwin_time_t)(v1391 + 60);
                          uint64_t v800 = (os_log_s *)v1025;
                          os_log_type_t v801 = OS_LOG_TYPE_DEFAULT;
                          uint64_t v802 = "[R%u] DNSServiceUpdateRecord(%{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%x)"
                                 ", %{mdns:rrtype}d) UPDATE PID[%d](%s)";
                          uint32_t v803 = 62;
                          goto LABEL_1839;
                        }

LABEL_1796:
                        uint64_t v484 = 0LL;
                        goto LABEL_1797;
                      }
                    }

                    else
                    {
                      *(void *)(v76 + 72) = 0LL;
                    }

                    uint64_t v290 = mDNSLogCategory_mDNS;
                    if (gSensitiveLoggingEnabled == 1 && mDNSLogCategory_mDNS != mDNSLogCategory_State)
                    {
                      uint64_t v290 = mDNSLogCategory_mDNS_redacted;
                      int updated = -65540;
                      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
                        goto LABEL_1122;
                      }
LABEL_439:
                      int v291 = *(_DWORD *)(v76 + 184);
                      v1489.dev_t st_dev = 67109120;
                      *(_DWORD *)&v1489.st_mode = v291;
                      uint64_t v114 = &v1489;
                      uint64_t v115 = (os_log_s *)v290;
                      os_log_type_t v116 = OS_LOG_TYPE_DEFAULT;
                      unsigned int v117 = "[R%d] DNSServiceUpdateRecord(unreadable parameters)";
                      goto LABEL_1119;
                    }

                    int updated = -65540;
                    if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
                      goto LABEL_439;
                    }
                    goto LABEL_1122;
                  case 12:
                    bzero(&v1489, 0x3F1uLL);
                    __int128 v1517 = 0u;
                    __int128 v1516 = 0u;
                    __int128 v1515 = 0u;
                    __int128 v1514 = 0u;
                    __int128 v1513 = 0u;
                    __int128 v1512 = 0u;
                    __int128 v1511 = 0u;
                    __int128 v1510 = 0u;
                    __int128 v1509 = 0u;
                    memset(v1508, 0, sizeof(v1508));
                    __int128 v1507 = 0u;
                    __int128 v1506 = 0u;
                    __int128 v1505 = 0u;
                    memset(v1504, 0, sizeof(v1504));
                    uint64_t v196 = *(void *)(v76 + 72);
                    if (v196 && (unint64_t v197 = *(void *)(v76 + 80), v198 = v196 + 4, v198 <= v197))
                    {
                      *(void *)(v76 + 72) = v198;
                      if (!v198) {
                        goto LABEL_441;
                      }
                      unsigned int v199 = &v1489;
                      while (1)
                      {
                        int v200 = *(unsigned __int8 **)(v76 + 72);
                        *(void *)(v76 + 72) = v200 + 1;
                        int v202 = *v200;
                        LOBYTE(v199->st_dev) = v202;
                        unsigned int v199 = (stat *)((char *)v199 + 1);
                        if (!v202)
                        {
                          v1504[0].sa_leuint64_t n = 0;
                          if (mDNS_LoggingEnabled == 1)
                          {
                            v1314 = v1504;
                            LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "%3d: DNSServiceSetDefaultDomainForUser(%##s)",  a4,  a5,  a6,  a7,  a8,  *(_DWORD *)(v76 + 168));
                          }

                          goto LABEL_666;
                        }
                      }

                      *((_BYTE *)&v199->st_dev - (v199 == (stat *)v1498)) = 0;
                      *(void *)(v76 + 72) = 0LL;
                    }

                    else
                    {
                      *(void *)(v76 + 72) = 0LL;
LABEL_441:
                      LOBYTE(v1489.st_dev) = 0;
                    }

LABEL_1910:
                            socklen_t v1097 = (unsigned __int16)v248;
                            dev_t st_dev = v1489.st_dev;
                            socklen_t v1099 = *(_DWORD *)(v76 + 232);
                            int v1100 = *(_DWORD *)(v76 + 236);
                            int v1101 = *(_DWORD *)(v76 + 172);
                            int v1102 = mDNS_DomainNameFNV1aHash(&v1504[0].sa_len);
                            __src[0] = 67111427;
                            __src[1] = v1404;
                            LOWORD(__src[2]) = 2160;
                            *(void *)((char *)&__src[2] + 2) = 1752392040LL;
                            HIWORD(__src[4]) = 1040;
                            __src[5] = v1097;
                            LOWORD(__src[6]) = 2101;
                            *(void *)((char *)&__src[6] + 2) = v1504;
                            HIWORD(__src[8]) = 1024;
                            __src[9] = st_dev;
                            LOWORD(__src[10]) = 1024;
                            *(socklen_t *)((char *)&__src[10] + 2) = v1099;
                            HIWORD(__src[11]) = 1024;
                            LODWORD(v1461[0]) = v1100;
                            WORD2(v1461[0]) = 1024;
                            *(_DWORD *)((char *)v1461 + 6) = v1101;
                            WORD5(v1461[0]) = 2082;
                            *(void *)((char *)v1461 + 12) = v76 + 240;
                            WORD2(v1461[1]) = 1024;
                            *(_DWORD *)((char *)&v1461[1] + 6) = v1102;
                            v986 = (os_log_s *)v246;
                            v987 = "[R%u] DNSServiceGetAddrInfo START -- hostname: %{sensitive, mask.hash, mdnsresponder:"
                                   "domain_name}.*P, protocols: %u, DNSSEC enabled, flags: 0x%X, interface index: %d, cli"
                                   "ent pid: %d (%{public}s), name hash: %x";
LABEL_1917:
                            uint32_t v988 = 74;
                            goto LABEL_1918;
                          }

                          if ((v245 & 1) != 0)
                          {
                            uint64_t v246 = mDNSLogCategory_Default_redacted;
                            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
                              goto LABEL_1919;
                            }
                          }

                          else if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
                          {
                            goto LABEL_1919;
                          }
                        }

                        else
                        {
                          if (v244)
                          {
                            if ((v245 & 1) != 0)
                            {
                              uint64_t v246 = mDNSLogCategory_Default_redacted;
                              if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
                                goto LABEL_1919;
                              }
                              socklen_t v1413 = *(_DWORD *)(v76 + 184);
                              for (i3 = v1504; ; i3 = (sockaddr *)((char *)i3 + v737 + 1))
                              {
                                LOWORD(v736) = 257;
                                if (i3 >= (sockaddr *)v1518 || !i3) {
                                  goto LABEL_1916;
                                }
                                uint64_t v737 = i3->sa_len;
                                if (v737 > 0x3F)
                                {
                                  LOWORD(v736) = 257;
                                  goto LABEL_1916;
                                }

                                if (!i3->sa_len) {
                                  break;
                                }
                              }

                              unsigned int v736 = (_DWORD)i3 - (v1501 + 32) + 1;
                            }

                            else
                            {
                              if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
                                goto LABEL_1919;
                              }
                              socklen_t v1413 = *(_DWORD *)(v76 + 184);
                              for (uint64_t i4 = v1504; ; uint64_t i4 = (sockaddr *)((char *)i4 + v828 + 1))
                              {
                                LOWORD(v736) = 257;
                                if (i4 >= (sockaddr *)v1518 || !i4) {
                                  goto LABEL_1916;
                                }
                                uint64_t v828 = i4->sa_len;
                                if (v828 > 0x3F)
                                {
                                  LOWORD(v736) = 257;
                                  goto LABEL_1916;
                                }

                                if (!i4->sa_len) {
                                  break;
                                }
                              }

                              unsigned int v736 = (_DWORD)i4 - (v1501 + 32) + 1;
                            }

LABEL_1916:
                            socklen_t v1103 = (unsigned __int16)v736;
                            dev_t v1104 = v1489.st_dev;
                            socklen_t v1105 = *(_DWORD *)(v76 + 232);
                            int v1106 = *(_DWORD *)(v76 + 236);
                            int v1107 = *(_DWORD *)(v76 + 172);
                            int v1108 = mDNS_DomainNameFNV1aHash(&v1504[0].sa_len);
                            __src[0] = 67111427;
                            __src[1] = v1413;
                            LOWORD(__src[2]) = 2160;
                            *(void *)((char *)&__src[2] + 2) = 1752392040LL;
                            HIWORD(__src[4]) = 1040;
                            __src[5] = v1103;
                            LOWORD(__src[6]) = 2101;
                            *(void *)((char *)&__src[6] + 2) = v1504;
                            HIWORD(__src[8]) = 1024;
                            __src[9] = v1104;
                            LOWORD(__src[10]) = 1024;
                            *(socklen_t *)((char *)&__src[10] + 2) = v1105;
                            HIWORD(__src[11]) = 1024;
                            LODWORD(v1461[0]) = v1106;
                            WORD2(v1461[0]) = 1024;
                            *(_DWORD *)((char *)v1461 + 6) = v1107;
                            WORD5(v1461[0]) = 2082;
                            *(void *)((char *)v1461 + 12) = v76 + 240;
                            WORD2(v1461[1]) = 1024;
                            *(_DWORD *)((char *)&v1461[1] + 6) = v1108;
                            v986 = (os_log_s *)v246;
                            v987 = "[R%u] DNSServiceGetAddrInfo START -- hostname: %{sensitive, mask.hash, mdnsresponder:"
                                   "domain_name}.*P, protocols: %u, flags: 0x%X, interface index: %d, client pid: %d (%{p"
                                   "ublic}s), name hash: %x";
                            goto LABEL_1917;
                          }

                          if ((v245 & 1) != 0)
                          {
                            uint64_t v246 = mDNSLogCategory_Default_redacted;
                            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
                              goto LABEL_1919;
                            }
                          }

                          else if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
                          {
                            goto LABEL_1919;
                          }
                        }

                        socklen_t v984 = *(_DWORD *)(v76 + 184);
                        socklen_t v985 = mDNS_DomainNameFNV1aHash(&v1504[0].sa_len);
                        __src[0] = 67109376;
                        __src[1] = v984;
                        LOWORD(__src[2]) = 1024;
                        *(socklen_t *)((char *)&__src[2] + 2) = v985;
                        v986 = (os_log_s *)v246;
                        v987 = "[R%u] DNSServiceGetAddrInfo START -- name hash: %x";
                        uint32_t v988 = 14;
LABEL_1918:
                        _os_log_impl( (void *)&_mh_execute_header,  v986,  OS_LOG_TYPE_DEFAULT,  v987,  (uint8_t *)__src,  v988);
LABEL_1919:
                        *(void *)(v76 + 96) = 0LL;
                        uint64_t v1109 = *(void *)(v76 + 48);
                        if (!v1109) {
                          goto LABEL_1934;
                        }
                        if (*(_UNKNOWN ***)(v1109 + 16) == &_mdns_signed_resolve_result_kind
                          && mdns_signed_resolve_result_contains(*(void *)(v76 + 48), (char *)&v1489.st_mode, v225))
                        {
                          (*(void (**)(uint64_t))(*(void *)(v1109 + 16) + 56LL))(v1109);
                          v1110 = (os_log_s *)mDNSLogCategory_Default;
                          if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
                          {
                            if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEBUG))
                            {
LABEL_1953:
                              socklen_t v1128 = *(_DWORD *)(v76 + 184);
                              __src[0] = 67109120;
                              __src[1] = v1128;
                              _os_log_impl( (void *)&_mh_execute_header,  v1110,  OS_LOG_TYPE_DEBUG,  "[R%d] DNSServiceGetAddrInfo: Allowing signed result",  (uint8_t *)__src,  8u);
                            }
                          }

                          else
                          {
                            v1110 = (os_log_s *)mDNSLogCategory_Default_redacted;
                            if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEBUG)) {
                              goto LABEL_1953;
                            }
                          }

LABEL_1934:
                          *(void *)(v76 + 96) = addrinfo_termination_callback;
                          memset(__src, 0, sizeof(__src));
                          __int128 v1462 = 0u;
                          memset(v1461, 0, sizeof(v1461));
                          __src[0] = *(_DWORD *)(v76 + 184);
                          *(void *)&__src[2] = &v1489.st_mode;
                          *(int32x2_t *)&__src[4] = vrev64_s32(*(int32x2_t *)(v76 + 232));
                          __src[6] = v1489.st_dev;
                          int v1115 = *(unsigned __int8 *)(v76 + 272);
                          if (*(_BYTE *)(v76 + 272)) {
                            socklen_t v1116 = 0;
                          }
                          else {
                            socklen_t v1116 = *(_DWORD *)(v76 + 172);
                          }
                          __src[7] = v1116;
                          if (v1115) {
                            uint64_t v1117 = v76 + 256;
                          }
                          else {
                            uint64_t v1117 = 0LL;
                          }
                          *(void *)&__src[8] = v1117;
                          __src[10] = *(_DWORD *)(v76 + 180);
                          LOBYTE(v1461[1]) = v1499[0] != 0;
                          *((void *)&v1461[0] + 1) = *(void *)v76;
                          *((void *)&v1461[1] + 1) = *(void *)(v76 + 32);
                          get_tracker_info_tlvs(v76);
                          int updated = GetAddrInfoClientRequestStart( *(void *)(v76 + 152),  (int *)__src,  (uint64_t)queryrecord_result_reply,  v76,  v1118,  v1119,  v1120,  v1121);
                          if (updated || *(_DWORD *)(v76 + 236) == -1) {
                            goto LABEL_1122;
                          }
                          uint64_t v1122 = *(void *)(v76 + 152);
                          uint64_t v1123 = *(void *)(v1122 + 16);
                          if (v1123)
                          {
                            v1124 = (char *)(v1123 + 356);
                          }

                          else
                          {
                            uint64_t v1125 = *(void *)(v1122 + 24);
                            v1124 = v1125 ? (char *)(v1125 + 356) : "";
                          }

                          if (!IsLocalDomain(v1124)) {
                            goto LABEL_1122;
                          }
                          uint64_t v1126 = *(unsigned int *)(v76 + 236);
                          if ((_DWORD)v1126)
                          {
                            if (AWDLInterfaceID && AWDLInterfaceID == v1126)
                            {
                              int v1127 = 1;
                            }

                            else
                            {
                              if (WiFiAwareInterfaceID) {
                                BOOL v1129 = WiFiAwareInterfaceID == v1126;
                              }
                              else {
                                BOOL v1129 = 0;
                              }
                              int v1127 = v1129;
                            }
                          }

                          else
                          {
                            int v1127 = (*(_DWORD *)(v76 + 232) >> 20) & 1;
                          }

                          __uint64_t record_start = mdns_powerlog_getaddrinfo_start((const char *)(v76 + 240), v1127);
                          goto LABEL_2069;
                        }

                        v1111 = (os_log_s *)mDNSLogCategory_Default;
                        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
                        {
                          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_ERROR)) {
                            goto LABEL_1932;
                          }
                        }

                        else
                        {
                          v1111 = (os_log_s *)mDNSLogCategory_Default_redacted;
                          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_ERROR)) {
                            goto LABEL_1932;
                          }
                        }

                        socklen_t v1112 = *(_DWORD *)(v76 + 184);
                        socklen_t v1113 = *(_DWORD *)(v76 + 236);
                        __src[0] = 67109891;
                        __src[1] = v1112;
                        LOWORD(__src[2]) = 2160;
                        *(void *)((char *)&__src[2] + 2) = 1752392040LL;
                        HIWORD(__src[4]) = 2085;
                        *(void *)&__src[5] = &v1489.st_mode;
                        LOWORD(__src[7]) = 1024;
                        *(socklen_t *)((char *)&__src[7] + 2) = v1113;
                        _os_log_impl( (void *)&_mh_execute_header,  v1111,  OS_LOG_TYPE_ERROR,  "[R%d] DNSServiceGetAddrInfo: Signed result does not cover hostname: %{sensitive, mask.hash}s, ifindex: %u.",  (uint8_t *)__src,  0x22u);
LABEL_1932:
                        *(_BYTE *)(v76 + 274) = 0;
                        v1114 = *(void **)(v76 + 48);
                        if (v1114)
                        {
                          os_release(v1114);
                          *(void *)(v76 + 48) = 0LL;
                        }

                        goto LABEL_1934;
                      }

                      uint64_t v763 = *(int *)v1449;
                      uint64_t v764 = mDNSLogCategory_Default;
                      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
                      {
                        if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEBUG))
                        {
LABEL_1394:
                          __src[0] = 134218240;
                          *(void *)&__src[1] = *(void *)buf;
                          LOWORD(__src[3]) = 2048;
                          *(void *)((char *)&__src[3] + 2) = v763;
                          int v812 = (os_log_s *)v764;
                          v813 = "get_signed_resolve_tlvs len %ld data invalid %ld";
                          uint32_t v814 = 22;
                          goto LABEL_1395;
                        }
                      }

                      else
                      {
                        uint64_t v764 = mDNSLogCategory_Default_redacted;
                        if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEBUG)) {
                          goto LABEL_1394;
                        }
                      }

LABEL_1396:
                      LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "%3d: handle_addrinfo_request err reading Validation TLVS",  v807,  v808,  v809,  v810,  v811,  *(_DWORD *)(v76 + 168));
                      int updated = -65549;
                      goto LABEL_1122;
                    }

                    uint64_t v743 = mDNSLogCategory_Default;
                    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
                    {
                      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEBUG)) {
                        goto LABEL_1396;
                      }
                    }

                    else
                    {
                      uint64_t v743 = mDNSLogCategory_Default_redacted;
                      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEBUG)) {
                        goto LABEL_1396;
                      }
                    }

                    LOWORD(__src[0]) = 0;
                    int v812 = (os_log_s *)v743;
                    v813 = "get_signed_resolve_tlvs data invalid";
                    uint32_t v814 = 2;
LABEL_1395:
                    _os_log_impl((void *)&_mh_execute_header, v812, OS_LOG_TYPE_DEBUG, v813, (uint8_t *)__src, v814);
                    goto LABEL_1396;
                  case 16:
                  case 17:
                    goto LABEL_191;
                  case 18:
                    __int128 v1472 = 0u;
                    __int128 v1471 = 0u;
                    __int128 v1470 = 0u;
                    __int128 v1469 = 0u;
                    __int128 v1468 = 0u;
                    __int128 v1467 = 0u;
                    __int128 v1466 = 0u;
                    __int128 v1465 = 0u;
                    __int128 v1464 = 0u;
                    __int128 v1463 = 0u;
                    __int128 v1462 = 0u;
                    memset(v1461, 0, sizeof(v1461));
                    memset(__src, 0, sizeof(__src));
                    bzero(&v1489, 0x3F1uLL);
                    bzero(v1504, 0x3F1uLL);
                    __int128 v1488 = 0u;
                    __int128 v1487 = 0u;
                    __int128 v1486 = 0u;
                    __int128 v1485 = 0u;
                    __int128 v1484 = 0u;
                    __int128 v1483 = 0u;
                    __int128 v1482 = 0u;
                    __int128 v1481 = 0u;
                    __int128 v1480 = 0u;
                    __int128 v1479 = 0u;
                    __int128 v1478 = 0u;
                    __int128 v1477 = 0u;
                    __int128 v1476 = 0u;
                    memset(buf, 0, sizeof(buf));
                    uint64_t v255 = *(unsigned int **)(v76 + 72);
                    if (v255 && (unint64_t v256 = *(void *)(v76 + 80), v257 = v255 + 1, (unint64_t)(v255 + 1) <= v256))
                    {
                      unsigned int v258 = *v255;
                      *(void *)(v76 + 72) = v257;
                      if (!v257) {
                        goto LABEL_444;
                      }
                      unsigned int v259 = bswap32(v258);
                      uint64_t v260 = __src;
                      do
                      {
                        int v261 = *(unsigned __int8 **)(v76 + 72);
                        if ((unint64_t)v261 >= v256 || v260 >= (socklen_t *)v1473)
                        {
                          uint64_t v406 = (__uint8_t *)v260 - (v260 == (socklen_t *)v1473);
                          goto LABEL_1109;
                        }

                        *(void *)(v76 + 72) = v261 + 1;
                        int v263 = *v261;
                        *(_BYTE *)uint64_t v260 = v263;
                        uint64_t v260 = (socklen_t *)((char *)v260 + 1);
                      }

                      while (v263);
                      if (*(void *)(v76 + 72))
                      {
                        unint64_t v264 = *(void *)(v76 + 80);
                        unsigned int v265 = (sockaddr *)&v1489;
                        do
                        {
                          unsigned int v266 = *(unsigned __int8 **)(v76 + 72);
                          if ((unint64_t)v266 >= v264 || v265 >= (sockaddr *)v1498)
                          {
                            BOOL v547 = v265 == (sockaddr *)v1498;
                            goto LABEL_1105;
                          }

                          *(void *)(v76 + 72) = v266 + 1;
                          int v268 = *v266;
                          v265->sa_leuint64_t n = v268;
                          unsigned int v265 = (sockaddr *)((char *)v265 + 1);
                        }

                        while (v268);
                        if (*(void *)(v76 + 72))
                        {
                          unint64_t v269 = *(void *)(v76 + 80);
                          unsigned int v265 = v1504;
                          while (1)
                          {
                            uint64_t v270 = *(unsigned __int8 **)(v76 + 72);
                            *(void *)(v76 + 72) = v270 + 1;
                            int v272 = *v270;
                            v265->sa_leuint64_t n = v272;
                            unsigned int v265 = (sockaddr *)((char *)v265 + 1);
                            if (!v272)
                            {
                              if (!*(void *)(v76 + 72))
                              {
                                LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "%3d: PeerConnectionRelease(unreadable parameters)",  v250,  v251,  v252,  v253,  v254,  *(_DWORD *)(v76 + 168));
                                goto LABEL_1121;
                              }

                              if ((build_domainname_from_strings( buf,  __src,  (unsigned __int8 *)&v1489,  &v1504[0].sa_len,  v251,  v252,  v253,  v254) & 0x80000000) != 0)
                              {
                                unint64_t v1315 = (unint64_t)v1504;
                                v1314 = (sockaddr *)&v1489;
                                LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "ERROR: handle_release_request bad “%s” “%s” “%s”",  v273,  v274,  v275,  v276,  v277,  (int)__src);
                                goto LABEL_1121;
                              }

                              v278 = (os_log_s *)mDNSLogCategory_Default;
                              if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
                              {
                                if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
                                {
                                  int v279 = *(_DWORD *)(v76 + 184);
                                  for (uint64_t i5 = buf; ; i5 += v805 + 1)
                                  {
                                    LOWORD(v281) = 257;
                                    uint64_t v805 = *i5;
                                    if (v805 > 0x3F)
                                    {
                                      LOWORD(v281) = 257;
                                      goto LABEL_1873;
                                    }

                                    if (!*i5) {
                                      break;
                                    }
                                  }

                                  unsigned int v281 = (_DWORD)i5 - buf + 1;
LABEL_1873:
                                  int v1057 = (unsigned __int16)v281;
                                  int v1058 = *(_DWORD *)(v76 + 172);
                                  *(_DWORD *)v1449 = 67110659;
                                  *(_DWORD *)&v1449[4] = v279;
                                  *(_WORD *)&v1449[8] = 1024;
                                  *(_DWORD *)&v1449[10] = v259;
                                  *(_WORD *)&v1449[14] = 2160;
                                  *(void *)&v1449[16] = 1752392040LL;
                                  *(_WORD *)&v1449[24] = 1040;
                                  *(_DWORD *)&v1449[26] = v1057;
                                  *(_WORD *)&v1449[30] = 2101;
                                  *(void *)&v1449[32] = buf;
                                  *(_WORD *)&v1449[40] = 1024;
                                  *(_DWORD *)&v1449[42] = v1058;
                                  *(_WORD *)&v1449[46] = 2082;
                                  *(void *)&v1449[48] = v76 + 240;
                                  _os_log_impl( (void *)&_mh_execute_header,  v278,  OS_LOG_TYPE_DEFAULT,  "[R%d] PeerConnectionRelease(%X %{sensitive, mask.hash, mdnsresponder:domain_name}.*P) START PID[%d](%{public}s)",  v1449,  0x38u);
                                }
                              }

                              else
                              {
                                v278 = (os_log_s *)mDNSLogCategory_Default_redacted;
                                if (os_log_type_enabled( (os_log_t)mDNSLogCategory_Default_redacted,  OS_LOG_TYPE_DEFAULT))
                                {
                                  int v279 = *(_DWORD *)(v76 + 184);
                                  for (i6 = buf; ; i6 += v282 + 1)
                                  {
                                    LOWORD(v281) = 257;
                                    uint64_t v282 = *i6;
                                    if (v282 > 0x3F)
                                    {
                                      LOWORD(v281) = 257;
                                      goto LABEL_1873;
                                    }

                                    if (!*i6) {
                                      break;
                                    }
                                  }

                                  unsigned int v281 = (_DWORD)i6 - buf + 1;
                                  goto LABEL_1873;
                                }
                              }

                              external_connection_release(buf);
                              goto LABEL_666;
                            }
                          }

                          BOOL v547 = v265 == (sockaddr *)v1519;
LABEL_1105:
                          uint64_t v670 = v547;
                          uint64_t v406 = &v265->sa_len - v670;
LABEL_1109:
                          *uint64_t v406 = 0;
                          *(void *)(v76 + 72) = 0LL;
                        }

                        else
                        {
                          v1504[0].sa_leuint64_t n = 0;
                        }
                      }

                      else
                      {
                        LOBYTE(v1489.st_dev) = 0;
                      }
                    }

                    else
                    {
                      *(void *)(v76 + 72) = 0LL;
LABEL_444:
                      LOBYTE(__src[0]) = 0;
                    }

                    uint64_t v658 = (os_log_s *)mDNSLogCategory_Default;
                    uint64_t v659 = "ERROR: handle_release_request - Couldn't read name/regtype/domain";
                    goto LABEL_1111;
                  case 19:
                    uint64_t v283 = (os_log_s *)mDNSLogCategory_Default;
                    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
                    {
                      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
                        goto LABEL_447;
                      }
                    }

                    else
                    {
                      uint64_t v283 = (os_log_s *)mDNSLogCategory_Default_redacted;
                      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
                        goto LABEL_447;
                      }
                    }

                    int v292 = *(_DWORD *)(v76 + 184);
                    int v293 = *(_DWORD *)(v76 + 172);
                    v1489.dev_t st_dev = 67109634;
                    *(_DWORD *)&v1489.st_mode = v292;
                    LOWORD(v1489.st_ino) = 1024;
                    *(_DWORD *)((char *)&v1489.st_ino + 2) = v293;
                    HIWORD(v1489.st_ino) = 2082;
                    *(void *)&v1489.st_uid = v76 + 240;
                    _os_log_impl( (void *)&_mh_execute_header,  v283,  OS_LOG_TYPE_DEFAULT,  "[R%d] DNSServiceCreateDelegateConnection START PID[%d](%{public}s)",  (uint8_t *)&v1489,  0x18u);
LABEL_447:
                    *(void *)(v76 + 96) = connection_termination;
                    uint64_t v294 = (os_log_s *)mDNSLogCategory_Default;
                    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
                    {
                      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
                        goto LABEL_453;
                      }
                    }

                    else
                    {
                      uint64_t v294 = (os_log_s *)mDNSLogCategory_Default_redacted;
                      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
                        goto LABEL_453;
                      }
                    }

                    int v295 = *(_DWORD *)(v76 + 184);
                    int v296 = *(_DWORD *)(v76 + 172);
                    v1489.dev_t st_dev = 67109634;
                    *(_DWORD *)&v1489.st_mode = v295;
                    LOWORD(v1489.st_ino) = 1024;
                    *(_DWORD *)((char *)&v1489.st_ino + 2) = v296;
                    HIWORD(v1489.st_ino) = 2082;
                    *(void *)&v1489.st_uid = v76 + 240;
                    _os_log_impl( (void *)&_mh_execute_header,  v294,  OS_LOG_TYPE_DEFAULT,  "[R%d] DNSServiceCreateDelegateConnection START PID[%d](%{public}s)",  (uint8_t *)&v1489,  0x18u);
LABEL_453:
                    *(void *)(v76 + 96) = connection_termination;
                    uint64_t v297 = *(unsigned int **)(v76 + 72);
                    if (v297 && (uint64_t v298 = v297 + 1, (unint64_t)(v297 + 1) <= *(void *)(v76 + 80)))
                    {
                      unsigned int v299 = bswap32(*v297);
                      *(void *)(v76 + 72) = v298;
                      if (v299)
                      {
                        v1489.dev_t st_dev = 4;
                        if (getsockopt(*(_DWORD *)(v76 + 168), 0, 3, (void *)(v76 + 172), (socklen_t *)&v1489))
                        {
                          int v300 = (os_log_s *)mDNSLogCategory_Default;
                          int v301 = *__error();
                          uint64_t v302 = __error();
                          v1314 = (sockaddr *)strerror(*v302);
                          LogMsgWithLevel( v300,  OS_LOG_TYPE_DEFAULT,  "handle_connection_delegate_request: getsockopt for LOCAL_PEEREPID failed errno:%d / %s",  v303,  v304,  v305,  v306,  v307,  v301);
                        }

                        else
                        {
                          mdns_system_pid_to_name(*(_DWORD *)(v76 + 172), v76 + 240);
                        }

                        goto LABEL_666;
                      }
                    }

                    else
                    {
                      *(void *)(v76 + 72) = 0LL;
                    }

                    v1489.dev_t st_dev = 16;
                    if (getsockopt(*(_DWORD *)(v76 + 168), 0, 5, (void *)(v76 + 256), (socklen_t *)&v1489))
                    {
                      unsigned int v308 = (os_log_s *)mDNSLogCategory_Default;
                      int v309 = *__error();
                      int v310 = __error();
                      v1314 = (sockaddr *)strerror(*v310);
                      LogMsgWithLevel( v308,  OS_LOG_TYPE_DEFAULT,  "handle_connection_delegate_request: getsockopt for LOCAL_PEEREUUID failed errno:%d / %s",  v311,  v312,  v313,  v314,  v315,  v309);
                    }

                    else
                    {
                      *(_BYTE *)(v76 + 272) = 1;
                    }

                    goto LABEL_666;
                  default:
                    if (v79 != 63)
                    {
LABEL_191:
                      unint64_t v1315 = *(unsigned int *)(v76 + 172);
                      v1316 = (_OWORD *)(v76 + 240);
                      v1314 = (sockaddr *)*(unsigned int *)(v76 + 212);
                      LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "request_callback: %3d:ERROR: Unsupported UDS req:%d PID[%d][%s]",  a4,  a5,  a6,  a7,  a8,  *(_DWORD *)(v76 + 168));
                      goto LABEL_1121;
                    }

                    char v101 = (os_log_s *)mDNSLogCategory_Default;
                    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
                    {
                      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEBUG)) {
                        goto LABEL_477;
                      }
                    }

                    else
                    {
                      char v101 = (os_log_s *)mDNSLogCategory_Default_redacted;
                      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEBUG)) {
                        goto LABEL_477;
                      }
                    }

                    int v324 = *(_DWORD *)(v76 + 184);
                    uid_t v326 = *(_DWORD *)(v76 + 216);
                    int v325 = *(_DWORD *)(v76 + 220);
                    v1489.dev_t st_dev = 67109632;
                    *(_DWORD *)&v1489.st_mode = v324;
                    LOWORD(v1489.st_ino) = 1024;
                    *(_DWORD *)((char *)&v1489.st_ino + 2) = v325;
                    HIWORD(v1489.st_ino) = 1024;
                    v1489.st_uid = v326;
                    _os_log_impl( (void *)&_mh_execute_header,  v101,  OS_LOG_TYPE_DEBUG,  "[R%d] Cancel %08X %08X",  (uint8_t *)&v1489,  0x14u);
LABEL_477:
                    uint64_t v327 = all_requests;
                    if (!all_requests) {
                      goto LABEL_666;
                    }
                    uint64_t v328 = &all_requests;
                    do
                    {
                      if (*(void *)(v327 + 24) == v76
                        && *(_DWORD *)(v327 + 216) == *(_DWORD *)(v76 + 216)
                        && *(_DWORD *)(v327 + 220) == *(_DWORD *)(v76 + 220))
                      {
                        *(void *)&v1489.dev_t st_dev = 0LL;
                        uint64_t v329 = *v328;
                        *(void *)&v1489.dev_t st_dev = v329;
                        abort_request(v329);
                        *uint64_t v328 = *(void *)(v329 + 16);
                        request_state_forget(&v1489);
                      }

                      else
                      {
                        uint64_t v328 = (uint64_t *)(v327 + 16);
                      }

                      int updated = 0;
                      uint64_t v327 = *v328;
                    }

                    while (*v328);
                    goto LABEL_1122;
                }
              }

LABEL_2253:
  AbortUnlinkAndFree((void *)v8);
}

uint64_t mDNSPlatformInterfaceIDfromInterfaceIndex( int a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v9 = a1 + 4;
  uint64_t result = 0LL;
  ssize_t v11 = &mDNSInterface_LocalOnly;
  switch(v9)
  {
    case 0:
      ssize_t v11 = &mDNSInterface_BLE;
      return *v11;
    case 1:
      ssize_t v11 = &mDNSInterface_P2P;
      return *v11;
    case 3:
      return *v11;
    case 4:
      return result;
    default:
      uint64_t v12 = *(void *)mDNSStorage[0];
      if (!*(void *)mDNSStorage[0]) {
        goto LABEL_8;
      }
      break;
  }

  while (!*(void *)(v12 + 6480) || *(_DWORD *)(v12 + 6424) != a1)
  {
    uint64_t v12 = *(void *)(v12 + 6384);
    if (!v12)
    {
LABEL_8:
      if (mDNS_LoggingEnabled == 1) {
        LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "mDNSPlatformInterfaceIDfromInterfaceIndex: InterfaceID for interface index %d not found; Updating interface list",
      }
          a4,
          a5,
          a6,
          a7,
          a8,
          a1);
      mDNSMacOSXNetworkChanged(result, a2, a3, a4, a5, a6, a7, a8);
      uint64_t v12 = *(void *)mDNSStorage[0];
      if (!*(void *)mDNSStorage[0]) {
        return 0LL;
      }
      while (!*(void *)(v12 + 6480) || *(_DWORD *)(v12 + 6424) != a1)
      {
        uint64_t v12 = *(void *)(v12 + 6384);
        if (!v12) {
          return 0LL;
        }
      }

      break;
    }
  }

  ssize_t v11 = (uint64_t *)(v12 + 6256);
  return *v11;
}

uint64_t ChopSubTypes(unsigned __int8 *a1)
{
  while (1)
  {
    int v1 = *a1;
    if (v1 == 44)
    {
      int v1 = a1[1];
      if (a1[1])
      {
        uint64_t v3 = 0LL;
        goto LABEL_27;
      }

      goto LABEL_9;
    }

    if (v1 != 92) {
      break;
    }
    if (a1[1])
    {
      uint64_t v2 = 2LL;
      goto LABEL_10;
    }

uint64_t register_service_instance(uint64_t a1, _BYTE *a2)
{
  uint64_t v3 = a1;
  uint64_t v4 = *(void *)(a1 + 112);
  uint64_t v5 = *(unsigned __int16 *)(v4 + 8);
  int v6 = SameDomainNameBytes(a2, "\x05local");
  uint64_t v7 = *(void *)v4;
  uint64_t v109 = 0LL;
  int service_attr_tsr_params = get_service_attr_tsr_params(v3, (int *)&v109 + 1, &v109);
  if (!service_attr_tsr_params)
  {
    int v12 = 0;
    goto LABEL_21;
  }

  __int128 v127 = 0u;
  __int128 v128 = 0u;
  __int128 v125 = 0u;
  __int128 v126 = 0u;
  __int128 v123 = 0u;
  __int128 v124 = 0u;
  __int128 v121 = 0u;
  __int128 v122 = 0u;
  __int128 v119 = 0u;
  __int128 v120 = 0u;
  __int128 v118 = 0u;
  __int128 v116 = 0u;
  __int128 v117 = 0u;
  memset(buf, 0, sizeof(buf));
  int v9 = HIDWORD(v109);
  if (HIDWORD(v109) <= 0x93A80)
  {
    uint64_t v13 = v3;
    *(void *)__tp = 0LL;
    *(void *)&__tp[8] = 0LL;
    clock_gettime(_CLOCK_MONOTONIC_RAW, (timespec *)__tp);
    int v14 = *(_DWORD *)__tp;
    int v15 = HIDWORD(v109);
    ConstructServiceName(buf, (const char *)(v4 + 26), (unsigned __int8 *)(v4 + 1099), a2);
    unsigned int v16 = DomainNameHashValue((unint64_t)buf);
    if (conflictWithCacheRecordsOrFlush(v16, buf, v15, v109))
    {
      uint64_t v17 = mDNSLogCategory_mDNS;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
      {
        uint64_t v11 = 4294901724LL;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
          return v11;
        }
        for (uint64_t i = buf; ; i += v70 + 1)
        {
          if (i >= v129 || !i || (uint64_t v70 = *i, v70 > 0x3F))
          {
            int v73 = 257;
            goto LABEL_85;
          }

          if (!*i) {
            break;
          }
        }

        int v73 = (unsigned __int16)((_WORD)i - (unsigned __int16)buf + 1);
      }

      else
      {
        uint64_t v17 = mDNSLogCategory_mDNS_redacted;
        uint64_t v11 = 4294901724LL;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
          return v11;
        }
        for (int j = buf; ; j += v19 + 1)
        {
          if (j >= v129 || !j || (uint64_t v19 = *j, v19 > 0x3F))
          {
            int v73 = 257;
            goto LABEL_85;
          }

          if (!*j) {
            break;
          }
        }

        int v73 = (unsigned __int16)((_WORD)j - (unsigned __int16)buf + 1);
      }

LABEL_85:
      *(_DWORD *)__tp = 141558787;
      *(void *)&__tp[4] = 1752392040LL;
      *(_WORD *)&__tp[12] = 1040;
      *(_DWORD *)&__tp[14] = v73;
      __int16 v111 = 2101;
      uint64_t v112 = buf;
      __int16 v113 = 2048;
      uint64_t v114 = v7;
      unint64_t v20 = "register_service_instance: TSR Stale Data, record cache is newer %{sensitive, mask.hash, mdnsresponder:domai"
            "n_name}.*P InterfaceID %p";
      unint64_t v21 = (os_log_s *)v17;
      os_log_type_t v22 = OS_LOG_TYPE_DEFAULT;
      uint32_t v23 = 38;
      goto LABEL_86;
    }

    int v12 = v14 - v9;
    uint64_t v3 = v13;
LABEL_21:
    if (v6) {
      BOOL v24 = 1;
    }
    else {
      BOOL v24 = *(_BYTE *)(v4 + 1355) == 0;
    }
    if (v24) {
      uint64_t v25 = v7;
    }
    else {
      uint64_t v25 = 0LL;
    }
    uint64_t v26 = (uint64_t *)(v4 + 1624);
    os_log_type_t v27 = *(uint64_t **)(v4 + 1624);
    if (v27)
    {
      while (!SameDomainNameBytes((_BYTE *)v27 + 28, a2))
      {
        uint64_t v26 = (uint64_t *)*v26;
        os_log_type_t v27 = (uint64_t *)*v26;
        if (!*v26) {
          goto LABEL_30;
        }
      }

      LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "register_service_instance: domain %##s already registered for %#s.%##s",  v28,  v29,  v30,  v31,  v32,  (int)a2);
      return 4294901749LL;
    }

        uint64_t v46 = v40;
      }

      else
      {
        uint64_t v46 = 0;
      }
    }

    uint64_t v48 = bswap32(*(unsigned __int16 *)(a1 + 320));
    uint64_t v49 = *(unsigned __int16 *)(v24 + 12);
    uint64_t v50 = *(unsigned __int8 *)(a1 + 335);
    *(_DWORD *)buf = 67110403;
    uint64_t v56 = HIWORD(v48);
    uint64_t v57 = 2160;
    uint64_t v58 = 1752392040LL;
    uint64_t v59 = 1040;
    uint64_t v60 = v46;
    uint64_t v61 = 2101;
    uint64_t v62 = v28;
    uint64_t v63 = 1024;
    uint64_t v64 = v49;
    uint64_t v65 = 1024;
    uint64_t v66 = v50;
    _os_log_impl( (void *)&_mh_execute_header,  v26,  OS_LOG_TYPE_DEFAULT,  "[Q%u] CacheRecordRmvEventsForCurrentQuestion: Calling AnswerCurrentQuestionWithResourceRecord (RMV) for question - rr name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P, rr type: %{mdns:rrtype}d, local answers: %u",  buf,  0x2Eu);
    goto LABEL_87;
  }

  if (mDNS_LoggingEnabled == 1)
  {
    uint64_t v11 = (os_log_s *)mDNSLogCategory_Default;
    DNSTypeName(*(unsigned __int16 *)(a1 + 322));
    LogMsgWithLevel( v11,  OS_LOG_TYPE_DEFAULT,  "CacheRecordRmvEventsForQuestion: Question %p %##s (%s) is a new question",  v12,  v13,  v14,  v15,  v16,  a1);
  }

  return 1LL;
}

LABEL_30:
    int v106 = v12;
    else {
      size_t v33 = v5 + 4784;
    }
    __int128 v34 = calloc(1uLL, v33);
    if (!v34) {
      goto LABEL_150;
    }
    uint64_t v35 = (uint64_t)v34;
    void *v34 = 0LL;
    v34[1] = v3;
    *((_WORD *)v34 + 12) = 0;
    if (*(_BYTE *)(v4 + 1355)) {
      BOOL v36 = v6 == 0;
    }
    else {
      BOOL v36 = 1;
    }
    char v37 = !v36;
    *((_BYTE *)v34 + 26) = v37;
    *((_BYTE *)v34 + 27) = 0;
    uint64_t v38 = a2;
    uint64_t v107 = v25;
    if (a2 == (_BYTE *)-256LL)
    {
LABEL_42:
      while (v38)
      {
        uint64_t v39 = *v38;
        if (!*v38)
        {
          unsigned __int16 v40 = (_WORD)v38 - (_WORD)a2 + 1;
          if (v40 > 0x100u) {
            break;
          }
          memcpy((char *)v34 + 28, a2, v40);
          goto LABEL_51;
        }

        v38 += v39 + 1;
        if (a2 != (_BYTE *)-256LL) {
          goto LABEL_41;
        }
      }
    }

    else
    {
LABEL_41:
      if (v38 < a2 + 256) {
        goto LABEL_42;
      }
    }

    *((_BYTE *)v34 + 28) = 0;
LABEL_51:
    uint64_t v41 = *(unsigned int *)(v4 + 1616);
    if ((_DWORD)v41)
    {
      uint64_t v105 = v3;
      uint64_t v42 = (char *)calloc(1uLL, 1176LL * v41);
      if (v42)
      {
        int v43 = v42;
        uint64_t v44 = 0LL;
        int v45 = (unsigned __int8 *)(v4 + 90);
        while (1)
        {
          mDNS_SetupResourceRecord((uint64_t)&v43[1176 * v44], 0LL, 0LL, 255, 0x1194u, 0, 0, 0LL, 0LL);
          while (*v45++)
            ;
          BOOL v53 = &v43[1176 * v44 + 652];
          *BOOL v53 = 0;
          if (!AppendDNSNameString(v53, v45, v46, v47, v48, v49, v50, v51)) {
            break;
          }
          if (++v44 == v41)
          {
            unsigned int v54 = *(_DWORD *)(v4 + 1616);
            uint64_t v3 = v105;
            goto LABEL_60;
          }
        }

        uint64_t v11 = 4294901756LL;
        free(v43);
        int v68 = (void *)v35;
        goto LABEL_66;
      }

      int v12 = *(void *)v12;
      if (!v12)
      {
        uid_t v18 = v76;
        goto LABEL_33;
      }
    }
  }

  uid_t v18 = 0LL;
  uint64_t v13 = &v76;
LABEL_33:
  BOOL v75 = v13;
  uint64_t v71 = a3;
  uint64_t v19 = a3;
  unint64_t v20 = a1;
  AddAdditionalsToResponseList(a1, v18, &v75, v19, a5, a6, a7, a8);
  unint64_t v21 = v76;
  if (!v76) {
    return;
  }
  os_log_type_t v22 = a1 + 28916;
  uint32_t v23 = (__int16 *)(v10 + 6);
  int v73 = (__int16 *)(v10 + 10);
  do
  {
    BOOL v24 = 0;
    uint64_t v74 = 0LL;
    *(_DWORD *)uint64_t v10 = 8650752;
    uint64_t v25 = v22;
    *(void *)(v10 + 4) = 0LL;
    do
    {
      if (!*(void *)(v21 + 264)) {
        goto LABEL_63;
      }
      if ((*(_BYTE *)(v21 + 8) & 0x32) != 0) {
        *(_WORD *)(v21 + 14) |= 0x8000u;
      }
      uint64_t v28 = UnsafeBufferPointer(*(uint64_t **)(v20 + 12624), v21, (uint64_t **)&v74);
      if (v28) {
        uint64_t v29 = v24 + 1;
      }
      else {
        uint64_t v29 = v24;
      }
      if (*v23 || *(_WORD *)(v10 + 8) || *v73) {
        uint64_t v30 = 1440LL;
      }
      else {
        uint64_t v30 = 8940LL;
      }
      uint64_t v31 = v22 + v30;
      uint64_t v32 = v29;
      int v15 = v29 == 0;
      size_t v33 = -11LL;
      if (v15) {
        size_t v33 = 0LL;
      }
      __int128 v34 = PutResourceRecordTTLWithLimit( v10,  v25,  (_WORD *)(v10 + 6),  v21 + 8,  *(unsigned int *)(v21 + 16),  v31 + v33 - 14LL * v32,  v26,  v27);
      uint64_t v35 = v34;
      if (!v28)
      {
        *(_WORD *)(v21 + 14) &= ~0x8000u;
        if (v34) {
          goto LABEL_57;
        }
        goto LABEL_55;
      }

      if (!v34)
      {
        *(_WORD *)(v21 + 14) &= ~0x8000u;
LABEL_55:
        if (!*v23)
        {
          uint64_t v35 = v25;
          goto LABEL_57;
        }

        unint64_t v21 = v76;
        if (!v76)
        {
          unsigned __int16 v40 = (void **)v74;
          goto LABEL_91;
        }

        while (1)
        {
LABEL_63:
          if (*(void *)(v21 + 264))
          {
            uint64_t v35 = v25;
            goto LABEL_90;
          }

          if ((*(_BYTE *)(v21 + 8) & 0x32) != 0) {
            *(_WORD *)(v21 + 14) |= 0x8000u;
          }
          uint64_t v44 = UnsafeBufferPointer(*(uint64_t **)(v20 + 12624), v21, (uint64_t **)&v74);
          if (v44) {
            int v45 = v24 + 1;
          }
          else {
            int v45 = v24;
          }
          if (*v23 || *(_WORD *)(v10 + 8) || *v73) {
            uint64_t v41 = 1440LL;
          }
          else {
            uint64_t v41 = 8940LL;
          }
          uint64_t v46 = v22 + v41;
          uint64_t v47 = v45;
          int v15 = v45 == 0;
          uint64_t v48 = -11LL;
          if (v15) {
            uint64_t v48 = 0LL;
          }
          uint64_t v49 = PutResourceRecordTTLWithLimit( v10,  v25,  v73,  v21 + 8,  *(unsigned int *)(v21 + 16),  v46 + v48 - 14LL * v47,  v42,  v43);
          uint64_t v35 = v49;
          if (v44)
          {
            if (!v49)
            {
              *(_WORD *)(v21 + 14) &= ~0x8000u;
LABEL_84:
              if ((*(_BYTE *)(v21 + 8) & 0x32) != 0) {
                *(void *)(v21 + 208) = -1LL;
              }
              uint64_t v35 = v25;
              goto LABEL_87;
            }

            uint64_t v50 = *(void *)(v21 + 40);
            uint64_t v51 = *v23;
            int v52 = *v73;
            BOOL v53 = calloc(1uLL, 0x18uLL);
            if (!v53) {
              goto LABEL_120;
            }
            ++v24;
            *((_WORD *)v44 + 4) = v51 + v52 - 1;
            v53[1] = v44;
            v53[2] = v50;
            *BOOL v53 = v74;
            uint64_t v74 = v53;
            *(_WORD *)(v21 + 14) &= ~0x8000u;
            unint64_t v20 = a1;
            os_log_type_t v22 = a1 + 28916;
          }

          else
          {
            *(_WORD *)(v21 + 14) &= ~0x8000u;
            if (!v49) {
              goto LABEL_84;
            }
          }

          if (!*v23)
          {
            uint64_t v25 = v35;
            goto LABEL_84;
          }

          *(_BYTE *)(v21 + 192) = 1;
LABEL_87:
          uint64_t v76 = *(void *)(v21 + 256);
          unsigned int v54 = v76;
          *(void *)(v21 + 264) = 0LL;
          *(void *)(v21 + 272) = 0LL;
          *(void *)(v21 + 256) = 0LL;
          uint64_t v25 = v35;
          unint64_t v21 = v54;
          if (!v54) {
            goto LABEL_90;
          }
        }
      }

      BOOL v36 = *(void *)(v21 + 40);
      char v37 = *v23;
      uint64_t v38 = calloc(1uLL, 0x18uLL);
      if (!v38) {
LABEL_120:
      }
        __break(1u);
      ++v24;
      *((_WORD *)v28 + 4) = v37 - 1;
      v38[1] = v28;
      v38[2] = v36;
      _BYTE *v38 = v74;
      uint64_t v74 = v38;
      *(_WORD *)(v21 + 14) &= ~0x8000u;
LABEL_57:
      uint64_t v76 = *(void *)(v21 + 256);
      uint64_t v39 = v76;
      *(void *)(v21 + 264) = 0LL;
      *(void *)(v21 + 272) = 0LL;
      *(void *)(v21 + 256) = 0LL;
      *(_BYTE *)(v21 + 192) = 1;
      unint64_t v21 = v39;
      uint64_t v25 = v35;
    }

    while (v39);
LABEL_90:
    unsigned __int16 v40 = (void **)v74;
    uint64_t v25 = v35;
    if (*v23)
    {
LABEL_91:
      if (v40)
      {
        bzero(v87, 0x498uLL);
        v88[0] = 32;
        uint64_t v89 = 41;
        __int128 v123 = 264;
        int v93 = v122;
        uint64_t v94 = &v123;
        unsigned int v102 = 0;
        int v103 = 0;
        int v95 = 0u;
        int v96 = 0u;
        uint64_t v97 = 0u;
        uint64_t v98 = 0u;
        uint64_t v99 = 0u;
        uint64_t v100 = 0u;
        int v101 = 0LL;
        int v104 = v122;
        __int128 v118 = 0;
        __int128 v120 = 0LL;
        __int128 v121 = 0LL;
        __int128 v119 = 0LL;
        v122[0] = 0;
        uint64_t v105 = 0u;
        int v106 = 0u;
        uint64_t v107 = 0u;
        int v108 = 0u;
        uint64_t v109 = 0u;
        uint64_t v110 = 0u;
        __int16 v111 = 0u;
        uint64_t v112 = 0u;
        __int16 v113 = 0u;
        uint64_t v114 = 0u;
        uint64_t v115 = 0u;
        __int128 v116 = 0u;
        memset(v117, 0, sizeof(v117));
        uint64_t v90 = 1440;
        uint64_t v91 = 4500;
        uint64_t v92 = 1572888;
        uint32_t v55 = (int *)v40[1];
        __int128 v126 = v55[1];
        __int128 v127 = *((_WORD *)v55 + 4);
        __int128 v125 = *v55;
        __int128 v124 = 720362;
        uint64_t v74 = *v40;
        free(v40);
        if (*v23 || *(_WORD *)(v10 + 8) || *v73) {
          uint64_t v58 = 1440LL;
        }
        else {
          uint64_t v58 = 8940LL;
        }
        uint64_t v59 = (char *)PutResourceRecordTTLWithLimit(v10, v25, v73, (uint64_t)v88, v91, v22 + v58, v56, v57);
        if (v59 && v74)
        {
          if (*v23 || *(_WORD *)(v10 + 8) || *v73) {
            uint64_t v63 = 1440LL;
          }
          else {
            uint64_t v63 = 8940LL;
          }
          uint64_t v59 = AddTSRROptsToMessage(&v74, v10, (_WORD *)(v25 + 9), v59, v22 + v63, v60, v61, v62);
        }

        if (!v59)
        {
          uint64_t v64 = (os_log_s *)mDNSLogCategory_mDNS;
          if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
          {
            if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_ERROR)) {
              goto LABEL_109;
            }
          }

          else
          {
            uint64_t v64 = (os_log_s *)mDNSLogCategory_mDNS_redacted;
            if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_ERROR))
            {
LABEL_109:
              uint64_t v65 = *(unsigned __int16 *)(v10 + 4);
              uint64_t v66 = *(unsigned __int16 *)(v10 + 6);
              uint64_t v67 = *(unsigned __int16 *)(v10 + 8);
              int v68 = *(unsigned __int16 *)(v10 + 10);
              GetRRDisplayString_rdb(v88, (unsigned __int16 *)v94 + 2, (_BYTE *)(a1 + 46976));
              *(_DWORD *)buf = 67110146;
              uint64_t v78 = v65;
              int v79 = 1024;
              char v80 = v66;
              unint64_t v20 = a1;
              uint64_t v81 = 1024;
              uint64_t v82 = v67;
              uint64_t v83 = 1024;
              uint64_t v84 = v68;
              uint64_t v85 = 2080;
              uint64_t v86 = a1 + 46976;
              _os_log_impl( (void *)&_mh_execute_header,  v64,  OS_LOG_TYPE_ERROR,  "SendDelayedUnicastResponse: How did we fail to have space for OPT record (%d/%d/%d/%d) %s",  buf,  0x24u);
            }
          }

          uint64_t v59 = (char *)v25;
        }

        uint64_t v25 = (unint64_t)v59;
      }

      mDNSSendDNSMessage(v20, v10, v25, v71, 0LL, 0LL, a2, 0xE914u, 0LL, 0);
      unsigned __int16 v40 = (void **)v74;
    }

    if (v40)
    {
      do
      {
        int v69 = (void **)*v40;
        free(v40);
        unsigned __int16 v40 = v69;
      }

      while (v69);
    }

    unint64_t v21 = v76;
    os_log_type_t v22 = a1 + 28916;
  }

  while (v76);
}

    free(v18);
    goto LABEL_31;
  }

  return result;
}

  uid_t v18 = *(_DWORD *)(v8 + 4);
  unint64_t v20 = 141559043;
  unint64_t v21 = 1752392040LL;
  os_log_type_t v22 = 1040;
  uint32_t v23 = v17;
  BOOL v24 = 2101;
  uint64_t v25 = v11;
  uint64_t v26 = 1024;
  os_log_type_t v27 = a3;
  uint64_t v28 = 1024;
  uint64_t v29 = v18;
  _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEFAULT,  "TSR timestamp - name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P, new: %d  old: %d",  (uint8_t *)&v20,  0x28u);
LABEL_31:
  if (a3 - *(_DWORD *)(v8 + 8) < 1) {
    return 0LL;
  }
  unint64_t v20 = 167832317;
  LOBYTE(v21) = HIBYTE(a3);
  BYTE1(v21) = BYTE2(a3);
  BYTE2(v21) = BYTE1(a3);
  BYTE3(v21) = a3;
  BYTE4(v21) = HIBYTE(a4);
  BYTE5(v21) = BYTE2(a4);
  BYTE6(v21) = BYTE1(a4);
  HIBYTE(v21) = a4;
  os_log_type_t v22 = 0;
  return update_record(a2, 14LL, (unsigned __int8 *)&v20, 4500, 0LL, *(_DWORD *)(a1 + 184));
}

  os_release((void *)v4);
}

    uint64_t v5 = 4294960567LL;
    goto LABEL_31;
  }

  if (CFArrayGetCount(*(CFArrayRef *)(a1 + 152)) >= 1)
  {
    uint64_t v2 = nw_array_create();
    if (v2)
    {
      uint64_t v3 = v2;
      uint64_t v4 = *(const __CFArray **)(a1 + 152);
      BOOL v24 = _NSConcreteStackBlock;
      uint64_t v25 = 0x40000000LL;
      uint64_t v26 = ___mdns_dso_client_session_start_connection_with_server_addresses_block_invoke;
      os_log_type_t v27 = &__block_descriptor_tmp_10_5933;
      uint64_t v28 = v3;
      if (mdns_cfarray_enumerate(v4, (uint64_t)&v24) && nw_array_get_count(v3))
      {
        *(_BYTE *)(a1 + 214) = 3;
        uint64_t v5 = _mdns_dso_client_session_add_nw_endpoints(a1, v3);
        if (!(_DWORD)v5)
        {
          if (_mdns_dso_session_log_s_once != -1) {
            dispatch_once(&_mdns_dso_session_log_s_once, &__block_literal_global_5889);
          }
          int v6 = (os_log_s *)_mdns_dso_session_log_s_log;
          uint64_t v5 = 0LL;
          if (os_log_type_enabled((os_log_t)_mdns_dso_session_log_s_log, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v7 = *(void *)(a1 + 40);
            uint64_t v8 = *(void *)(a1 + 152);
            *(_DWORD *)buf = 134218242;
            *(void *)&uint8_t buf[4] = v7;
            *(_WORD *)&buf[12] = 2112;
            *(void *)&buf[14] = v8;
            _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "[DSO%llu] Start -> Start connection directly -- addresses: %@",  buf,  0x16u);
            uint64_t v5 = 0LL;
          }
        }
      }

      else
      {
        uint64_t v5 = 4294960539LL;
      }

      unsigned int v16 = (void *)v3;
      goto LABEL_33;
    }

    return 4294960567LL;
  }

  return 4294960578LL;
}

LABEL_150:
      __break(1u);
    }

    unsigned int v54 = 0;
    int v43 = 0LL;
LABEL_60:
    *(void *)(v35 + 16) = v43;
    if (*(_BYTE *)(v4 + 1356)) {
      uint32_t v55 = (_BYTE *)(v4 + 1356);
    }
    else {
      uint32_t v55 = 0LL;
    }
    uint64_t v11 = mDNS_RegisterService( (unsigned int *)mDNSStorage,  v35 + 288,  (const char *)(v4 + 26),  (unsigned __int8 *)(v4 + 1099),  a2,  v55,  *(_WORD *)(v4 + 24),  0LL,  *(unsigned __int16 **)(v4 + 16),  *(_WORD *)(v4 + 8),  (uint64_t)v43,  v54,  v107,  (uint64_t)regservice_callback,  v35,  *(_DWORD *)(v3 + 232));
    if ((_DWORD)v11)
    {
LABEL_64:
      LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "register_service_instance %#s.%##s%##s error %d",  v56,  v57,  v58,  v59,  v60,  v4 + 26);
      int v68 = (void *)v35;
LABEL_66:
      unlink_and_free_service_instance(v68, v61, v62, v63, v64, v65, v66, v67);
      return v11;
    }

    uint64_t v71 = *(unsigned int *)(v3 + 236);
    if ((_DWORD)v71 != -1 && v6)
    {
      if ((_DWORD)v71)
      {
        if (AWDLInterfaceID && AWDLInterfaceID == v71)
        {
          int v72 = 1;
        }

        else
        {
          if (WiFiAwareInterfaceID) {
            BOOL v75 = WiFiAwareInterfaceID == v71;
          }
          else {
            BOOL v75 = 0;
          }
          int v72 = v75;
        }
      }

      else
      {
        int v72 = (*(_DWORD *)(v3 + 232) >> 20) & 1;
      }

      int v108 = v72;
      __uint64_t monotonic_time_ns = _mdns_powerlog_get_monotonic_time_ns();
      bzero(buf, 0x3F1uLL);
      service_type_from_domain_name = _mdns_get_service_type_from_domain_name((unsigned __int8 *)(v4 + 1099), buf);
      _mdns_powerlog_bonjour_event( 0x10u,  v108,  (const char *)(v3 + 240),  (const char *)service_type_from_domain_name,  monotonic_time_ns);
      *(void *)(v3 + 8) = monotonic_time_ns;
    }

    if (service_attr_tsr_params)
    {
      uint64_t v78 = mDNSGetTSRForAuthRecordNamed((uint64_t *)xmmword_10015BD08, *(_BYTE **)(v35 + 2736), *(_DWORD *)(v35 + 2720));
      if (v78)
      {
        uint64_t updated = updateTSRRecord(v3, (uint64_t)v78, v106, v109);
      }

      else
      {
        *(_DWORD *)buf = 167832317;
        uint8_t buf[4] = HIBYTE(v106);
        buf[5] = BYTE2(v106);
        buf[6] = BYTE1(v106);
        buf[7] = v106;
        buf[8] = BYTE3(v109);
        buf[9] = BYTE2(v109);
        buf[10] = BYTE1(v109);
        buf[11] = v109;
        *(_WORD *)&buf[12] = 0;
        uint64_t updated = add_record_to_service(v3, v35, 41, 14LL, buf, 0x1194u);
      }

      uint64_t v11 = updated;
      char v80 = gSensitiveLoggingEnabled;
      uint64_t v81 = mDNSLogCategory_mDNS;
      if (mDNSLogCategory_mDNS == mDNSLogCategory_State) {
        char v80 = 0;
      }
      if ((_DWORD)updated)
      {
        if ((v80 & 1) != 0)
        {
          uint64_t v82 = mDNSLogCategory_mDNS_redacted;
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_ERROR)) {
            goto LABEL_64;
          }
          *(_DWORD *)buf = 67109376;
          *(_DWORD *)&uint8_t buf[4] = HIDWORD(v109);
          *(_WORD *)&buf[8] = 1024;
          *(_DWORD *)&buf[10] = v11;
          uint64_t v83 = (os_log_s *)v82;
        }

        else
        {
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_ERROR)) {
            goto LABEL_64;
          }
          *(_DWORD *)buf = 67109376;
          *(_DWORD *)&uint8_t buf[4] = HIDWORD(v109);
          *(_WORD *)&buf[8] = 1024;
          *(_DWORD *)&buf[10] = v11;
          uint64_t v83 = (os_log_s *)v81;
        }

        _os_log_impl( (void *)&_mh_execute_header,  v83,  OS_LOG_TYPE_ERROR,  "Failed to add TSR record with tsrTimestamp %u error %d",  buf,  0xEu);
        goto LABEL_64;
      }

      if ((v80 & 1) != 0)
      {
        uint64_t v84 = mDNSLogCategory_mDNS_redacted;
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 67109120;
          *(_DWORD *)&uint8_t buf[4] = v106;
          uint64_t v85 = (os_log_s *)v84;
LABEL_113:
          _os_log_impl( (void *)&_mh_execute_header,  v85,  OS_LOG_TYPE_DEFAULT,  "TSR record added with tsrTimestamp %d",  buf,  8u);
        }
      }

      else if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 67109120;
        *(_DWORD *)&uint8_t buf[4] = v106;
        uint64_t v85 = (os_log_s *)v81;
        goto LABEL_113;
      }
    }

    *uint64_t v26 = v35;
    uint64_t v86 = (os_log_s *)mDNSLogCategory_mDNS;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v92 = v3;
        int v93 = *(_DWORD *)(v3 + 184);
        uint64_t v94 = *(void *)(v35 + 2736);
        if (v94)
        {
          uint64_t v98 = *(_BYTE **)(v35 + 2736);
          int v96 = 257;
          if (v94 == -256) {
            goto LABEL_133;
          }
LABEL_130:
          if ((unint64_t)v98 < v94 + 256 && v98)
          {
            while (1)
            {
              uint64_t v99 = *v98;
              if (v99 > 0x3F)
              {
LABEL_141:
                uint64_t v100 = v35;
                int v96 = 257;
                goto LABEL_146;
              }

              if (!*v98) {
                break;
              }
              v98 += v99 + 1;
              if (v94 != -256) {
                goto LABEL_130;
              }
LABEL_133:
              if (!v98) {
                goto LABEL_141;
              }
            }

            uint64_t v100 = v35;
            int v96 = (unsigned __int16)((_WORD)v98 - v94 + 1);
          }

          else
          {
            uint64_t v100 = v35;
          }
        }

        else
        {
          uint64_t v100 = v35;
          int v96 = 0;
        }

        goto LABEL_146;
      }
    }

    else
    {
      uint64_t v86 = (os_log_s *)mDNSLogCategory_mDNS_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v92 = v3;
        int v93 = *(_DWORD *)(v3 + 184);
        uint64_t v94 = *(void *)(v35 + 2736);
        if (v94)
        {
          int v95 = *(_BYTE **)(v35 + 2736);
          int v96 = 257;
          if (v94 == -256) {
            goto LABEL_122;
          }
LABEL_119:
          if ((unint64_t)v95 < v94 + 256 && v95)
          {
            while (1)
            {
              uint64_t v97 = *v95;
              if (v97 > 0x3F)
              {
LABEL_140:
                uint64_t v100 = v35;
                int v96 = 257;
                goto LABEL_146;
              }

              if (!*v95) {
                break;
              }
              v95 += v97 + 1;
              if (v94 != -256) {
                goto LABEL_119;
              }
LABEL_122:
              if (!v95) {
                goto LABEL_140;
              }
            }

            uint64_t v100 = v35;
            int v96 = (unsigned __int16)((_WORD)v95 - v94 + 1);
          }

          else
          {
            uint64_t v100 = v35;
          }
        }

        else
        {
          uint64_t v100 = v35;
          int v96 = 0;
        }

  uint64_t v57 = 0LL;
  uint64_t v56 = 0;
LABEL_151:
  uint64_t v32 = 0LL;
  uint64_t v31 = 0LL;
LABEL_152:
  uint64_t v63 = 0;
LABEL_153:
  uint64_t v64 = *(void *)(a1 + 40);
  if (!v64) {
    goto LABEL_167;
  }
  uint64_t v65 = *(_DWORD *)(v64 + 40);
  if (v65 != 4 && v65 != 2) {
    goto LABEL_167;
  }
  uint64_t v66 = *(_DWORD *)(v64 + 44);
  if (!v66)
  {
    if (v54)
    {
      if (v53 != 1)
      {
        if (v53 == 2)
        {
          *(void *)(v64 + 44) = 2LL;
LABEL_233:
          int v108 = 0;
          uint64_t v67 = 2;
          goto LABEL_251;
        }

        int v95 = -6709;
        goto LABEL_242;
      }

      if (!v31)
      {
        uint64_t v31 = dnssec_obj_rrset_copy_dnskeys(*(void **)(a1 + 64), &v107, &v108);
        if (v108)
        {
          uint64_t v67 = 0;
          if (!v63) {
            goto LABEL_263;
          }
LABEL_251:
          int v96 = (os_log_s *)mDNSLogCategory_DNSSEC;
          if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_DNSSEC == mDNSLogCategory_State)
          {
            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC, OS_LOG_TYPE_INFO))
            {
LABEL_260:
              uint64_t v100 = dword_100158BF8;
              dword_100158C5C = v100;
LABEL_263:
              uint64_t v30 = v67;
              if (v67 != 3) {
                goto LABEL_84;
              }
LABEL_264:
              int v101 = (os_log_s *)mDNSLogCategory_DNSSEC;
              if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_DNSSEC == mDNSLogCategory_State)
              {
                if (!os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC, OS_LOG_TYPE_INFO))
                {
LABEL_273:
                  uint64_t v30 = 3;
                  goto LABEL_84;
                }
              }

              else
              {
                int v101 = (os_log_s *)mDNSLogCategory_DNSSEC_redacted;
                if (!os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC_redacted, OS_LOG_TYPE_INFO)) {
                  goto LABEL_273;
                }
              }

              int v104 = *(unsigned __int16 *)(a1 + 24);
              *(_DWORD *)buf = 67109376;
              *(_DWORD *)&uint8_t buf[4] = v104;
              *(_WORD *)&buf[8] = 1024;
              *(_DWORD *)&buf[10] = v108;
              _os_log_impl( (void *)&_mh_execute_header,  v101,  OS_LOG_TYPE_INFO,  "[Q%u] Bogus RRSet failed DNSSEC validation - error: %d",  buf,  0xEu);
              goto LABEL_273;
            }
          }

          else
          {
            int v96 = (os_log_s *)mDNSLogCategory_DNSSEC_redacted;
            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC_redacted, OS_LOG_TYPE_INFO)) {
              goto LABEL_260;
            }
          }

          uint64_t v99 = *(unsigned __int16 *)(a1 + 24);
          *(_DWORD *)buf = 67109376;
          *(_DWORD *)&uint8_t buf[4] = v99;
          *(_WORD *)&buf[8] = 1026;
          *(_DWORD *)&buf[10] = v67;
          _os_log_impl( (void *)&_mh_execute_header,  v96,  OS_LOG_TYPE_INFO,  "[Q%u] A new RRSet has been validated, scheduling cache update - result: %{public, mdns:dnssec_result}d",  buf,  0xEu);
          goto LABEL_260;
        }

        uint64_t v64 = *(void *)(a1 + 40);
        uint64_t v57 = v107;
      }

      uint64_t v66 = dnssec_obj_rrset_validate_with_dnskeys((uint64_t *)v64, (_DWORD **)v31, v57, (unsigned __int8 *)&v108);
      goto LABEL_158;
    }

LABEL_146:
        int v101 = mDNS_DomainNameFNV1aHash(*(unsigned __int8 **)(v35 + 2736));
        unsigned int v102 = bswap32(*(unsigned __int16 *)(v4 + 24)) >> 16;
        int v103 = mDNS_DomainNameFNV1aHash(*(unsigned __int8 **)(v100 + 1560));
        *(_DWORD *)buf = 67110659;
        *(_DWORD *)&uint8_t buf[4] = v93;
        *(_WORD *)&buf[8] = 2160;
        *(void *)&buf[10] = 1752392040LL;
        *(_WORD *)&buf[18] = 1040;
        *(_DWORD *)&buf[20] = v96;
        *(_WORD *)&buf[24] = 2101;
        *(void *)&buf[26] = v94;
        *(_WORD *)&buf[34] = 1024;
        *(_DWORD *)&buf[36] = v101;
        *(_WORD *)&buf[40] = 1024;
        *(_DWORD *)&buf[42] = v102;
        uint64_t v35 = v100;
        *(_WORD *)&buf[46] = 1024;
        LODWORD(v116) = v103;
        _os_log_impl( (void *)&_mh_execute_header,  v86,  OS_LOG_TYPE_DEFAULT,  "[R%u] DNSServiceRegister result -- event: ADDED, SRV name: %{sensitive, mask.hash, mdnsresponder:domain_name}. *P (%x), port: %u, PTR name hash: %x",  buf,  0x34u);
        uint64_t v3 = v92;
      }
    }

    if (mDNS_McastLoggingEnabled) {
      LogMcastService(v35 + 2696, v3, 1, v87, v88, v89, v90, v91, v104);
    }
    return 0LL;
  }

  uint64_t v10 = mDNSLogCategory_mDNS;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
  {
    uint64_t v11 = 4294901756LL;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_ERROR))
    {
LABEL_19:
      *(_DWORD *)__tp = 67109376;
      *(_DWORD *)&__tp[4] = v9;
      *(_WORD *)&__tp[8] = 1024;
      *(_DWORD *)&__tp[10] = 604800;
      unint64_t v20 = "tsrTimestamp[%u] out of range (%u) on TSR";
      unint64_t v21 = (os_log_s *)v10;
      os_log_type_t v22 = OS_LOG_TYPE_ERROR;
      uint32_t v23 = 14;
LABEL_86:
      _os_log_impl((void *)&_mh_execute_header, v21, v22, v20, __tp, v23);
    }
  }

  else
  {
    uint64_t v11 = 4294901756LL;
    uint64_t v10 = mDNSLogCategory_mDNS_redacted;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_ERROR)) {
      goto LABEL_19;
    }
  }

  return v11;
}

        BOOL v36 = -65540;
        goto LABEL_147;
      }
    }

  mDNS_StopQuery((unsigned int *)a1, v8);
  uint64_t v139 = &DNSProxyClients;
  do
  {
    uint64_t v140 = v139;
    uint64_t v139 = (uint64_t *)*v139;
    if (v139) {
      unsigned int v141 = v139 == (uint64_t *)v11;
    }
    else {
      unsigned int v141 = 1;
    }
  }

  while (!v141);
  if (v139)
  {
    *uint64_t v140 = *(void *)v11;
    mDNSPlatformDisposeProxyContext(*(_DWORD **)(v11 + 72));
    FreeDNSProxyClient((void *)v11);
  }

  else
  {
    uint64_t v142 = (os_log_s *)mDNSLogCategory_Default;
    DNSTypeName(*(unsigned __int16 *)(v8 + 322));
    LogMsgWithLevel( v142,  OS_LOG_TYPE_DEFAULT,  "ProxyClientCallback: question %##s (%s) not found",  v143,  v144,  v145,  v146,  v147,  v8 + 356);
  }

uint64_t mDNS_RegisterService( unsigned int *a1, uint64_t a2, const char *a3, unsigned __int8 *a4, _BYTE *a5, _BYTE *a6, __int16 a7, uint64_t a8, unsigned __int16 *a9, unsigned __int16 a10, uint64_t a11, unsigned int a12, uint64_t a13, uint64_t a14, uint64_t a15, int a16)
{
  if ((a16 & 0x800) != 0) {
    char v19 = 32;
  }
  else {
    char v19 = 2;
  }
  *(void *)a2 = a14;
  *(void *)(a2 + 8) = a15;
  *(_BYTE *)(a2 + 16) = 0;
  *(void *)(a2 + 24) = 0LL;
  *(_DWORD *)(a2 + 32) = a12;
  *(void *)(a2 + 40) = a11;
  *(_DWORD *)(a2 + 48) = a16;
  if (a13 == -2)
  {
    int v26 = 4;
  }

  else
  {
    BOOL v20 = (a16 & 0x100000) == 0;
    BOOL v21 = (a16 & 0x20000) != 0 && a13 == 0;
    int v22 = !v21;
    if (!v21) {
      BOOL v20 = 1;
    }
    if (v20) {
      int v23 = 1;
    }
    else {
      int v23 = 3;
    }
    if (a13) {
      BOOL v24 = 1;
    }
    else {
      BOOL v24 = (a16 & 0x100000) == 0;
    }
    if (v24) {
      int v25 = 0;
    }
    else {
      int v25 = 2;
    }
    if (v22 != 1) {
      int v25 = v23;
    }
    if (a13 == -3) {
      int v25 = 5;
    }
    if (a13 == -5) {
      int v26 = 5;
    }
    else {
      int v26 = v25;
    }
  }

  uint64_t v76 = a2 + 56;
  mDNS_SetupResourceRecord(a2 + 56, 0LL, a13, 12, 0x1194u, 4, v26, (uint64_t)ServiceCallback, a2);
  mDNS_SetupResourceRecord(a2 + 1232, 0LL, a13, 12, 0x1194u, 8, v26, (uint64_t)ServiceCallback, a2);
  if ((a16 & 0x1000000) != 0) {
    *(_BYTE *)(a2 + 1355) = 1;
  }
  unsigned int v79 = -65540;
  uint64_t v27 = a2 + 2408;
  mDNS_SetupResourceRecord(a2 + 2408, 0LL, a13, 33, 0x1194u, v19, v26, (uint64_t)ServiceCallback, a2);
  uint64_t v28 = a2 + 3584;
  mDNS_SetupResourceRecord(a2 + 3584, a8, a13, 16, 0x1194u, v19, v26, (uint64_t)ServiceCallback, a2);
  if (a7)
  {
    uint64_t v29 = *(unsigned __int16 **)(a2 + 3632);
    uint64_t v30 = a5;
    if (!ConstructServiceName((_BYTE *)(a2 + 708), "\t_services", "\a_dns-sd\x04_udp", a5)
      || !ConstructServiceName((_BYTE *)(a2 + 1884), 0LL, a4, a5)
      || !ConstructServiceName((_BYTE *)(a2 + 3060), a3, a4, a5))
    {
      return v79;
    }

    uint64_t v31 = *(_BYTE **)(a2 + 2448);
    uint64_t v32 = v31;
    if (v31 == (_BYTE *)-256LL)
    {
LABEL_40:
      while (v32)
      {
        uint64_t v33 = *v32;
        if (!*v32)
        {
          unsigned __int16 v42 = (_WORD)v32 - (_WORD)v31 + 1;
          if (v42 > 0x100u) {
            break;
          }
          memcpy((void *)(a2 + 4236), v31, v42);
          goto LABEL_74;
        }

        v32 += v33 + 1;
        if (v31 != (_BYTE *)-256LL) {
          goto LABEL_39;
        }
      }
    }

    else
    {
LABEL_39:
      if (v32 < v31 + 256) {
        goto LABEL_40;
      }
    }

    *(_BYTE *)(a2 + 4236) = 0;
LABEL_74:
    int v43 = *(_BYTE **)(a2 + 1272);
    uint64_t v44 = v43;
    if (v43 == (_BYTE *)-256LL)
    {
LABEL_76:
      while (v44)
      {
        uint64_t v45 = *v44;
        if (!*v44)
        {
          unsigned __int16 v46 = (_WORD)v44 - (_WORD)v43 + 1;
          if (v46 > 0x100u) {
            break;
          }
          memcpy((void *)(*(void *)(a2 + 104) + 4LL), v43, v46);
          goto LABEL_84;
        }

        v44 += v45 + 1;
        if (v43 != (_BYTE *)-256LL) {
          goto LABEL_75;
        }
      }
    }

    else
    {
LABEL_75:
      if (v44 < v43 + 256) {
        goto LABEL_76;
      }
    }

    *(_BYTE *)(*(void *)(a2 + 104) + 4LL) = 0;
LABEL_84:
    uint64_t v47 = *(_BYTE **)(a2 + 2448);
    uint64_t v48 = v47;
    if (v47 == (_BYTE *)-256LL)
    {
LABEL_86:
      while (v48)
      {
        uint64_t v49 = *v48;
        if (!*v48)
        {
          unsigned __int16 v50 = (_WORD)v48 - (_WORD)v47 + 1;
          if (v50 > 0x100u) {
            break;
          }
          memcpy((void *)(*(void *)(a2 + 1280) + 4LL), v47, v50);
          goto LABEL_94;
        }

        v48 += v49 + 1;
        if (v47 != (_BYTE *)-256LL) {
          goto LABEL_85;
        }
      }
    }

    else
    {
LABEL_85:
      if (v48 < v47 + 256) {
        goto LABEL_86;
      }
    }

    *(_BYTE *)(*(void *)(a2 + 1280) + 4LL) = 0;
LABEL_94:
    *(void *)(a2 + 1304) = v27;
    *(void *)(a2 + 1312) = v28;
    if (a12)
    {
      uint64_t v51 = 0LL;
      uint64_t v52 = *(void *)(a2 + 40);
      do
      {
        memset(__dst, 0, sizeof(__dst));
        unsigned int v54 = *(char **)(v52 + 1176 * v51 + 40);
        BOOL v53 = v54;
        if (v54 != (char *)-256LL)
        {
LABEL_97:
          uint64_t v55 = 0LL;
          if (v54 >= v53 + 256 || !v54) {
            goto LABEL_108;
          }
          goto LABEL_101;
        }

        while (1)
        {
          if (!v54) {
            goto LABEL_107;
          }
LABEL_101:
          uint64_t v56 = *v54;
          if (!*v54) {
            break;
          }
          v54 += v56 + 1;
        }

        unsigned __int16 v57 = (_WORD)v54 - (_WORD)v53 + 1;
        if (v57 > 0x100u)
        {
LABEL_107:
          uint64_t v55 = 0LL;
        }

        else
        {
          memcpy(__dst, v53, v57);
          uint64_t v55 = LOBYTE(__dst[0]);
        }

LABEL_108:
        *((_BYTE *)__dst + v55 + 1) = 0;
        AppendDomainName(__dst, a4);
        mDNS_SetupResourceRecord( *(void *)(a2 + 40) + 1176 * v51,  0LL,  a13,  12,  0x1194u,  8,  v26,  (uint64_t)ServiceCallback,  a2);
        uint64_t v30 = a5;
        if (!ConstructServiceName( (_BYTE *)(*(void *)(a2 + 40) + 1176 * v51 + 652),  0LL,  (unsigned __int8 *)__dst,  a5)) {
          return v79;
        }
        uint64_t v58 = (_BYTE *)(a2 + 3060);
        if (a2 == -3316)
        {
LABEL_111:
          while (v58)
          {
            uint64_t v59 = *v58;
            if (!*v58)
            {
              unsigned __int16 v60 = (_WORD)v58 - (a2 + 3060) + 1;
              if (v60 > 0x100u) {
                break;
              }
              memcpy( (void *)(*(void *)(*(void *)(a2 + 40) + 1176 * v51 + 48) + 4LL),  (const void *)(a2 + 3060),  v60);
              goto LABEL_119;
            }

            v58 += v59 + 1;
            if (a2 != -3316) {
              goto LABEL_110;
            }
          }
        }

        else
        {
LABEL_110:
        }

        *(_BYTE *)(*(void *)(*(void *)(a2 + 40) + 1176 * v51 + 48) + 4LL) = 0;
LABEL_119:
        uint64_t v52 = *(void *)(a2 + 40);
        uint64_t v61 = v52 + 1176 * v51;
        *(void *)(v61 + 72) = v27;
        *(void *)(v61 + 80) = v28;
        ++v51;
      }

      while (v51 != a12);
    }

    *(_WORD *)(*(void *)(a2 + 2456) + 4LL) = 0;
    *(_WORD *)(*(void *)(a2 + 2456) + 6LL) = 0;
    *(_WORD *)(*(void *)(a2 + 2456) + 8LL) = a7;
    if (a6 && *a6)
    {
      uint64_t v62 = a6;
      uint64_t v63 = a1;
      uint64_t v64 = a9;
      if (a6 == (_BYTE *)-256LL)
      {
LABEL_124:
        while (v62)
        {
          uint64_t v65 = *v62;
          if (!*v62)
          {
            unsigned __int16 v66 = (_WORD)v62 - (_WORD)a6 + 1;
            if (v66 > 0x100u) {
              break;
            }
            memcpy((void *)(*(void *)(a2 + 2456) + 10LL), a6, v66);
            goto LABEL_133;
          }

          v62 += v65 + 1;
          if (a6 != (_BYTE *)-256LL) {
            goto LABEL_123;
          }
        }
      }

      else
      {
LABEL_123:
        if (v62 < a6 + 256) {
          goto LABEL_124;
        }
      }

      *(_BYTE *)(*(void *)(a2 + 2456) + 10LL) = 0;
    }

    else
    {
      *(_BYTE *)(a2 + 2528) = 1;
      *(_BYTE *)(*(void *)(a2 + 2456) + 10LL) = 0;
      uint64_t v63 = a1;
      uint64_t v64 = a9;
    }

        mDNS_Deregister((unsigned int *)mDNSStorage, (uint64_t)(v49 + 3));
LABEL_109:
        if (!v48) {
          return;
        }
      }

      unsigned __int16 v50 = (os_log_s *)mDNSLogCategory_D2D_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D_redacted, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_108;
      }
      for (iuint64_t i = (uint8_t *)v60; ; ii += v57 + 1)
      {
        LOWORD(v53) = 257;
        if (ii >= buf || !ii) {
          break;
        }
        unsigned __int16 v57 = *ii;
        if (v57 > 0x3F)
        {
          LOWORD(v53) = 257;
          goto LABEL_107;
        }

        if (!*ii)
        {
          BOOL v53 = (_DWORD)ii - v60 + 1;
          goto LABEL_107;
        }
      }

      goto LABEL_107;
    }

    return;
  }

  char v19 = (os_log_s *)mDNSLogCategory_D2D;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_D2D == mDNSLogCategory_State)
  {
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D, OS_LOG_TYPE_DEBUG)) {
      return;
    }
    for (jint j = (uint8_t *)v60; ; jj += v25 + 1)
    {
      if (jj >= buf || !jj || (int v25 = *jj, v25 > 0x3F))
      {
        uint64_t v27 = 257;
        goto LABEL_113;
      }

      if (!*jj) {
        break;
      }
    }

    uint64_t v27 = (unsigned __int16)((_WORD)jj - (unsigned __int16)v60 + 1);
  }

  else
  {
    char v19 = (os_log_s *)mDNSLogCategory_D2D_redacted;
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D_redacted, OS_LOG_TYPE_DEBUG)) {
      return;
    }
    for (kuint64_t k = (uint8_t *)v60; ; kk += v21 + 1)
    {
      if (kk >= buf || !kk || (BOOL v21 = *kk, v21 > 0x3F))
      {
        uint64_t v27 = 257;
        goto LABEL_113;
      }

      if (!*kk) {
        break;
      }
    }

    uint64_t v27 = (unsigned __int16)((_WORD)kk - (unsigned __int16)v60 + 1);
  }

  if (*(_DWORD *)(v5 + 156)) {
    *(_DWORD *)(v5 + 184) = *(_DWORD *)(v5 + 64);
  }
}

        uint64_t v58 = *(const __CFArray **)(v2 + 80);
        if (v58)
        {
          int v93 = a1;
          int64_t Count = CFArrayGetCount(v58);
          if (Count >= 1)
          {
            unsigned __int16 v60 = 0LL;
            uint64_t v61 = 0LL;
            while (1)
            {
              ValueAtIndex = (char *)CFArrayGetValueAtIndex(*(CFArrayRef *)(v2 + 80), v60);
              uint64_t v63 = ValueAtIndex;
              if (*(_BYTE *)(v18 + 137)) {
                break;
              }
              *(_DWORD *)&buf[24] = 0;
              *(void *)&uint8_t buf[16] = 0LL;
              uint64_t v64 = ValueAtIndex + 24;
              uint64_t v65 = ValueAtIndex[25];
              if (v65 == 30)
              {
                *(_OWORD *)buf = *v64;
                *(_OWORD *)&buf[12] = *(_OWORD *)(ValueAtIndex + 36);
              }

              else
              {
                if (v65 != 2)
                {
                  unsigned int v68 = -6756;
LABEL_124:
                  if (_mdns_dns_service_log_s_once != -1) {
                    dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_62);
                  }
                  unsigned int v69 = (os_log_s *)_mdns_dns_service_log_s_log;
                  if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_ERROR))
                  {
                    uint64_t v70 = *(void *)(v2 + 24);
                    *(_DWORD *)buf = 134218498;
                    *(void *)&uint8_t buf[4] = v70;
                    *(_WORD *)&buf[12] = 2112;
                    *(void *)&buf[14] = v63;
                    *(_WORD *)&buf[22] = 2048;
                    *(void *)&buf[24] = v68;
                    _os_log_error_impl( (void *)&_mh_execute_header,  v69,  OS_LOG_TYPE_ERROR,  "Failed to add address to resolver -- service id: %llu, address: %@, error: %{mdns:err}ld",  buf,  0x20u);
                  }

                  goto LABEL_128;
                }

                *(_OWORD *)buf = *v64;
              }

              if (!*(_WORD *)&buf[2]) {
                *(_WORD *)&buf[2] = bswap32(*(unsigned __int16 *)(*(void *)(v18 + 16) + 156LL)) >> 16;
              }
              address = nw_endpoint_create_address((const sockaddr *)buf);
              if (!address)
              {
                unsigned int v68 = -6700;
                goto LABEL_124;
              }

              uint64_t v67 = address;
              if (*(void *)(v18 + 48)) {
                nw_endpoint_set_interface(address);
              }
              unsigned int v68 = _mdns_resolver_add_server_by_endpoint(v18, v67);
              nw_release(v67);
              if (v68) {
                goto LABEL_124;
              }
              ++v61;
LABEL_128:
              if (Count == ++v60) {
                goto LABEL_133;
              }
            }

            unsigned int v68 = -6719;
            goto LABEL_124;
          }

          uint64_t v61 = 0LL;
LABEL_133:
          a1 = v93;
          if (Count)
          {
            if (v61 < 1)
            {
              os_release((void *)v18);
              goto LABEL_167;
            }
          }
        }

        if (_mdns_dns_service_queue_s_once != -1) {
          dispatch_once(&_mdns_dns_service_queue_s_once, &__block_literal_global_237);
        }
        if (!*(_BYTE *)(v18 + 137))
        {
          uint64_t v71 = _mdns_dns_service_queue_s_queue;
          dispatch_retain((dispatch_object_t)_mdns_dns_service_queue_s_queue);
          uint64_t v72 = *(dispatch_object_s **)(v18 + 72);
          if (v72) {
            dispatch_release(v72);
          }
          *(void *)(v18 + 72) = v71;
        }

        os_retain((void *)a1);
        os_retain((void *)v18);
        uint64_t v73 = (dispatch_source_s *)os_retain((void *)v2);
        *(void *)&aBlocuint64_t k = _NSConcreteStackBlock;
        *((void *)&aBlock + 1) = 0x40000000LL;
        uint64_t v97 = ___mdns_dns_service_manager_prepare_resolver_block_invoke;
        uint64_t v98 = &__block_descriptor_tmp_193;
        uint64_t v99 = a1;
        uint64_t v100 = v2;
        int v101 = v18;
        if (!*(_BYTE *)(v18 + 137))
        {
          uint64_t v74 = _Block_copy(&aBlock);
          uint64_t v73 = *(dispatch_source_s **)(v18 + 80);
          if (v73) {
            _Block_release(v73);
          }
          *(void *)(v18 + 80) = v74;
        }

        *(void *)(v2 + 64) = v18;
        if (*(_BYTE *)(v2 + 283))
        {
          *(_BYTE *)(v2 + 283) = 0;
          uint64_t v73 = *(dispatch_source_s **)(a1 + 96);
          if (v73)
          {
            dispatch_source_merge_data(v73, 1uLL);
            uid_t v18 = *(void *)(v2 + 64);
          }
        }

        if (!*(_BYTE *)(v18 + 137))
        {
          *(_BYTE *)(v18 + 137) = 1;
          os_retain((void *)v18);
          if (_mdns_resolver_queue_s_once != -1) {
            dispatch_once(&_mdns_resolver_queue_s_once, &__block_literal_global_138);
          }
          *(void *)buf = _NSConcreteStackBlock;
          *(void *)&buf[8] = 0x40000000LL;
          *(void *)&uint8_t buf[16] = __mdns_resolver_activate_block_invoke;
          *(void *)&buf[24] = &__block_descriptor_tmp_4612;
          int v103 = v18;
          dispatch_async((dispatch_queue_t)_mdns_resolver_queue_s_queue, buf);
        }

        if (*(unsigned __int8 *)(v2 + 281) - 2 >= 4
          && nw_settings_get_ddr_enabled(v73)
          && !*(void *)(v2 + 200))
        {
          if (_mdns_dns_service_queue_s_once != -1) {
            dispatch_once(&_mdns_dns_service_queue_s_once, &__block_literal_global_237);
          }
          uint64_t v75 = dispatch_source_create( (dispatch_source_type_t)&_dispatch_source_type_timer,  0LL,  0LL,  (dispatch_queue_t)_mdns_dns_service_queue_s_queue);
          *(void *)(v2 + 200) = v75;
          if (v75)
          {
            if (_mdns_os_variant_has_internal_diagnostics_s_result && (uint64_t v76 = *(_DWORD *)(a1 + 124)) != 0)
            {
              if (v76 <= 0xA) {
                int v77 = 10;
              }
              else {
                int v77 = *(_DWORD *)(a1 + 124);
              }
            }

            else
            {
              int v77 = 1800;
            }

            uint64_t v78 = *(dispatch_source_s **)(v2 + 200);
            unsigned int v79 = dispatch_time(0x8000000000000000LL, 1000000000LL * v77);
            dispatch_source_set_timer(v78, v79, 1000000000LL * v77, 50000000LL * v77);
            char v80 = *(dispatch_source_s **)(v2 + 200);
            *(void *)buf = _NSConcreteStackBlock;
            *(void *)&buf[8] = 0x40000000LL;
            *(void *)&uint8_t buf[16] = ___mdns_dns_service_manager_schedule_ddr_probe_block_invoke;
            *(void *)&buf[24] = &__block_descriptor_tmp_202;
            int v103 = a1;
            int v104 = v2;
            dispatch_source_set_event_handler(v80, buf);
            dispatch_activate(*(dispatch_object_t *)(v2 + 200));
            _mdns_dns_service_forget_all_ddr_queriers(v2);
            _mdns_dns_service_manager_start_ddr_querier_ex((void *)a1, v2, 0LL);
            goto LABEL_167;
          }

          if (_mdns_dns_service_log_s_once != -1) {
            dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_62);
          }
          uint64_t v92 = _mdns_dns_service_log_s_log;
          if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)buf = 0;
            uint64_t v88 = "Failed to create DDR timer";
            uint64_t v89 = (os_log_s *)v92;
            uint64_t v90 = 2;
            goto LABEL_181;
          }
        }

        goto LABEL_167;
      }
    }

    os_release((void *)v18);
LABEL_177:
    if (_mdns_dns_service_log_s_once != -1) {
      dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_62);
    }
    uint64_t v86 = _mdns_dns_service_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_ERROR))
    {
      uint64_t v87 = *(void *)(v2 + 24);
      *(_DWORD *)buf = 134217984;
      *(void *)&uint8_t buf[4] = v87;
      uint64_t v88 = "Failed to create resolver for service -- service id: %llu";
      uint64_t v89 = (os_log_s *)v86;
      uint64_t v90 = 12;
LABEL_181:
      _os_log_error_impl((void *)&_mh_execute_header, v89, OS_LOG_TYPE_ERROR, v88, buf, v90);
    }

LABEL_133:
    if (v64)
    {
      uint64_t v67 = *(unsigned __int16 **)(a2 + 3632);
      if (v67 + 2 != v64)
      {
        *(_WORD *)(a2 + 3604) = a10;
        memcpy(v67 + 2, v64, a10);
      }
    }

    else
    {
      *(_WORD *)(a2 + 3604) = 0;
    }

    *(void *)(a2 + 3672) = v27;
    mDNS_Lock_(v63, (uint64_t)"mDNS_RegisterService", 17501);
    unsigned int v68 = mDNS_Register_internal(v63, a2 + 2408);
    if (v68)
    {
      unsigned int v79 = v68;
      mDNS_Unlock_((uint64_t)v63, (uint64_t)"mDNS_RegisterService", 17511);
    }

    else
    {
      unsigned int v69 = mDNS_Register_internal(v63, a2 + 3584);
      if (!v69) {
        unsigned int v69 = mDNS_Register_internal(v63, v76);
      }
      if (a12)
      {
        uint64_t v70 = 0LL;
        do
        {
          if (!v69) {
            unsigned int v69 = mDNS_Register_internal(v63, *(void *)(a2 + 40) + v70);
          }
          v70 += 1176LL;
        }

        while (1176LL * a12 != v70);
      }

      if (v69)
      {
        mDNS_Unlock_((uint64_t)v63, (uint64_t)"mDNS_RegisterService", 17524);
      }

      else
      {
        unsigned int v69 = mDNS_Register_internal(v63, a2 + 1232);
        mDNS_Unlock_((uint64_t)v63, (uint64_t)"mDNS_RegisterService", 17524);
        if (!v69)
        {
          if ((*(_DWORD *)(a2 + 1404) & 0xFFFFFFFE) != 4)
          {
          }

          return 0;
        }
      }

      unsigned int v79 = v69;
      mDNS_DeregisterService_drt(v63, a2, 0, v71, v72, v73, v74, v75);
    }
  }

  else
  {
    if (a13 == -2)
    {
      int v34 = 4;
    }

    else
    {
      int v34 = 5;
      if (a13 != -5 && a13 != -3)
      {
        BOOL v35 = (a16 & 0x100000) == 0;
        BOOL v36 = (a16 & 0x20000) != 0 && a13 == 0;
        int v37 = !v36;
        if (!v36) {
          BOOL v35 = 1;
        }
        if (v35) {
          int v38 = 1;
        }
        else {
          int v38 = 3;
        }
        if (a13) {
          BOOL v39 = 1;
        }
        else {
          BOOL v39 = (a16 & 0x100000) == 0;
        }
        if (v39) {
          int v40 = 0;
        }
        else {
          int v40 = 2;
        }
        if (v37 == 1) {
          int v34 = v40;
        }
        else {
          int v34 = v38;
        }
      }
    }

    mDNS_SetupResourceRecord(a2 + 2408, 0LL, a13, 33, 0x1194u, 2, v34, (uint64_t)NSSCallback, a2);
    if (ConstructServiceName((_BYTE *)(a2 + 3060), a3, a4, a5))
    {
      *(_WORD *)(*(void *)(a2 + 2456) + 4LL) = 0;
      *(_WORD *)(*(void *)(a2 + 2456) + 6LL) = 0;
      *(_WORD *)(*(void *)(a2 + 2456) + 8LL) = 0;
      *(_BYTE *)(a2 + 2528) = 1;
      return mDNS_Register(a1, a2 + 2408);
    }
  }

  return v79;
}

      unsigned __int16 v66 = *(unsigned __int16 *)(v54 + 12);
      *(_DWORD *)buf = 141559555;
      *(void *)&uint8_t buf[4] = 1752392040LL;
      *(_WORD *)&buf[12] = 1045;
      *(_DWORD *)&buf[14] = 20;
      __int128 v127 = 2101;
      *(void *)__int128 v128 = v125;
      *(_WORD *)&v128[8] = 2160;
      *(void *)&v128[10] = 1752392040LL;
      *(_WORD *)&v128[18] = 1040;
      *(_DWORD *)&v128[20] = v65;
      *(_WORD *)&v128[24] = 2101;
      *(void *)&v128[26] = v57;
      *(_WORD *)&v128[34] = 1024;
      *(_DWORD *)&v128[36] = v66;
      _os_log_impl( (void *)&_mh_execute_header,  v55,  OS_LOG_TYPE_INFO,  "Removing cached peer record -- peer address: %{sensitive, mask.hash, mdnsresponder:ip_addr}.20P, name: %{sensiti ve, mask.hash, mdnsresponder:domain_name}.*P, type: %{mdns:rrtype}d",  buf,  0x3Cu);
    }

        uint64_t v75 = *(dispatch_queue_s **)(a1 + 24);
        if (v75)
        {
          uint64_t v76 = *(void *)(a1 + 80);
          *(void *)(a1 + 80) = 0LL;
          os_retain((void *)a1);
          block[0] = _NSConcreteStackBlock;
          block[1] = 0x40000000LL;
          block[2] = ___mdns_querier_conclude_ex_block_invoke;
          block[3] = &unk_10013D280;
          unsigned int v79 = a2;
          block[4] = v76;
          block[5] = a1;
          dispatch_async(v75, block);
        }

        if (*(_BYTE *)(a1 + 254))
        {
          *(_BYTE *)(a1 + 254) = 0;
          os_release((void *)a1);
        }

        return;
      case 2:
        if (_mdns_resolver_log_s_once != -1) {
          dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_48);
        }
        BOOL v36 = (os_log_s *)_mdns_resolver_log_s_log;
        if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_INFO))
        {
          int v37 = *(const char **)(a1 + 128);
          if (!v37) {
            int v37 = "";
          }
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = v37;
          int v38 = "%{public}sQuerier concluded -- reason: timeout";
          goto LABEL_132;
        }

        goto LABEL_133;
      case 3:
        if (_mdns_resolver_log_s_once != -1) {
          dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_48);
        }
        BOOL v36 = (os_log_s *)_mdns_resolver_log_s_log;
        if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_INFO))
        {
          BOOL v39 = *(const char **)(a1 + 128);
          if (!v39) {
            BOOL v39 = "";
          }
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = v39;
          int v38 = "%{public}sQuerier concluded -- reason: invalidation";
          goto LABEL_132;
        }

        goto LABEL_133;
      case 4:
        if (_mdns_resolver_log_s_once != -1) {
          dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_48);
        }
        BOOL v36 = (os_log_s *)_mdns_resolver_log_s_log;
        if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_INFO))
        {
          int v40 = *(const char **)(a1 + 128);
          if (!v40) {
            int v40 = "";
          }
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = v40;
          int v38 = "%{public}sQuerier concluded -- reason: resolver invalidation";
          goto LABEL_132;
        }

        goto LABEL_133;
      case 5:
        *(_DWORD *)(a1 + 240) = a3;
        if (_mdns_resolver_log_s_once != -1) {
          dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_48);
        }
        uint64_t v41 = (os_log_s *)_mdns_resolver_log_s_log;
        if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_ERROR))
        {
          unsigned __int16 v42 = *(const char **)(a1 + 128);
          if (!v42) {
            unsigned __int16 v42 = "";
          }
          int v43 = *(int *)(a1 + 240);
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = v42;
          uint64_t v83 = 2048;
          *(void *)uint64_t v84 = v43;
          _os_log_error_impl( (void *)&_mh_execute_header,  v41,  OS_LOG_TYPE_ERROR,  "%{public}sQuerier concluded -- error: %{mdns:err}ld",  buf,  0x16u);
        }

        goto LABEL_133;
      case 6:
        if (_mdns_resolver_log_s_once != -1) {
          dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_48);
        }
        BOOL v36 = (os_log_s *)_mdns_resolver_log_s_log;
        if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_INFO))
        {
          uint64_t v44 = *(const char **)(a1 + 128);
          if (!v44) {
            uint64_t v44 = "";
          }
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = v44;
          int v38 = "%{public}sQuerier concluded -- reason: connection problem";
LABEL_132:
          _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_INFO, v38, buf, 0xCu);
        }

        goto LABEL_133;
      default:
        goto LABEL_133;
    }
  }

void ServiceCallback( unsigned int *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = a3;
  uint64_t v11 = *(void *)(a2 + 112);
  uint64_t v12 = v11 + 2408;
  if (!(_DWORD)a3 && v12 != a2) {
    return;
  }
  if ((_DWORD)a3 != -65792)
  {
    if ((_DWORD)a3 == -65548)
    {
      *(_BYTE *)(v11 + 16) = 1;
      mDNS_DeregisterService_drt(a1, v11, 0, a4, a5, a6, a7, a8);
      return;
    }

    int v16 = 1;
LABEL_31:
    uint64_t v17 = (os_log_s *)mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_65;
      }
      char v19 = "";
      if (!v16) {
        char v19 = "un";
      }
      uint64_t v20 = *(void *)(v11 + 1272);
      if (v20)
      {
        BOOL v21 = *(_BYTE **)(v11 + 1272);
        if (v20 == -256)
        {
LABEL_42:
          while (v21)
          {
            uint64_t v22 = *v21;
            if (!*v21)
            {
              int v26 = (unsigned __int16)((_WORD)v21 - v20 + 1);
              goto LABEL_64;
            }

            v21 += v22 + 1;
            if (v20 != -256) {
              goto LABEL_41;
            }
          }
        }

        else
        {
LABEL_41:
        }

        int v26 = 257;
      }

      else
      {
        int v26 = 0;
      }
    }

    else
    {
      uint64_t v17 = (os_log_s *)mDNSLogCategory_Default_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_65;
      }
      char v19 = "";
      if (!v16) {
        char v19 = "un";
      }
      uint64_t v20 = *(void *)(v11 + 1272);
      if (v20)
      {
        BOOL v24 = *(_BYTE **)(v11 + 1272);
        if (v20 == -256)
        {
LABEL_53:
          while (v24)
          {
            uint64_t v25 = *v24;
            if (!*v24)
            {
              int v26 = (unsigned __int16)((_WORD)v24 - v20 + 1);
              goto LABEL_64;
            }

            v24 += v25 + 1;
            if (v20 != -256) {
              goto LABEL_52;
            }
          }
        }

        else
        {
LABEL_52:
        }

        int v26 = 257;
      }

      else
      {
        int v26 = 0;
      }
    }

LABEL_64:
    int v27 = 136446979;
    uint64_t v28 = v19;
    __int16 v29 = 2160;
    uint64_t v30 = 1752392040LL;
    __int16 v31 = 1040;
    int v32 = v26;
    __int16 v33 = 2101;
    uint64_t v34 = v20;
    _os_log_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_DEFAULT,  "ServiceCallback: All records %{public}sregistered for %{sensitive, mask.hash, mdnsresponder:domain_name}.*P",  (uint8_t *)&v27,  0x26u);
LABEL_65:
    if (*(void *)v11) {
      (*(void (**)(unsigned int *, uint64_t, uint64_t))v11)(a1, v11, v8);
    }
    return;
  }

  if (*(_BYTE *)(v11 + 2416) || *(_BYTE *)(v11 + 3592) || *(_BYTE *)(v11 + 1240) || *(_BYTE *)(v11 + 64)) {
    return;
  }
  uint64_t v13 = *(uint64_t **)(v11 + 24);
  uint64_t v14 = *(unsigned int *)(v11 + 32);
  if ((_DWORD)v14)
  {
    int v15 = (_BYTE *)(*(void *)(v11 + 40) + 8LL);
    while (!*v15)
    {
      v15 += 1176;
      if (!--v14) {
        goto LABEL_15;
      }
    }
  }

  else
  {
LABEL_15:
    if (!v13)
    {
LABEL_18:
      if (*(_BYTE *)(v11 + 16)) {
        uint64_t v8 = 4294901748LL;
      }
      else {
        uint64_t v8 = 4294901504LL;
      }
      if (*(void *)(v11 + 2712)) {
        CompleteRDataUpdate((uint64_t)a1, v12, a3, a4, a5, a6, a7, a8);
      }
      if (*(void *)(v11 + 3888)) {
        CompleteRDataUpdate((uint64_t)a1, v11 + 3584, a3, a4, a5, a6, a7, a8);
      }
      if (*(void *)(v11 + 1536)) {
        CompleteRDataUpdate((uint64_t)a1, v11 + 1232, a3, a4, a5, a6, a7, a8);
      }
      if (*(void *)(v11 + 360)) {
        CompleteRDataUpdate((uint64_t)a1, v11 + 56, a3, a4, a5, a6, a7, a8);
      }
      int v16 = 0;
      goto LABEL_31;
    }

    while (!*((_BYTE *)v13 + 24))
    {
      uint64_t v13 = (uint64_t *)*v13;
      if (!v13) {
        goto LABEL_18;
      }
    }
  }

    _mdns_dso_session_handle_failure(v1, v19, 1LL, 0LL);
    return v19;
  }

  uint64_t v20 = arc4random() % (v8 + 1);
  if (v7) {
    BOOL v21 = arc4random() % v7 + 1;
  }
  else {
    BOOL v21 = 0;
  }
  uint64_t v22 = 0LL;
  int v23 = 0;
  if (v3 <= 1) {
    BOOL v24 = 1LL;
  }
  else {
    BOOL v24 = v3;
  }
  while (1)
  {
    uint64_t v25 = CFArrayGetValueAtIndex(*(CFArrayRef *)(v42 + 24), v22);
    if (!_mdns_dso_server_endpoint_is_usable_now((uint64_t)v25, 0LL, 0LL)
      || nw_endpoint_get_priority(v25[3]) != v10)
    {
      goto LABEL_43;
    }

    int v26 = nw_endpoint_get_weight(v25[3]);
    if (!v20) {
      break;
    }
    if (v26)
    {
      v23 += v26;
      if (v23 >= v20) {
        goto LABEL_66;
      }
    }

uint64_t GetServiceTarget(uint64_t a1, uint64_t a2)
{
  if (!*(_BYTE *)(a2 + 120)) {
    return *(void *)(a2 + 48) + 10LL;
  }
  uint64_t v3 = a1;
  uint64_t v4 = *(_BYTE **)(a2 + 40);
  int v5 = *v4;
  if (*v4)
  {
    int v6 = 0;
    do
    {
      ++v6;
      uint64_t v7 = &v4[v5];
      int v8 = v7[1];
      uint64_t v4 = v7 + 1;
      int v5 = v8;
    }

    while (v8);
  }

  else
  {
    int v6 = 0;
  }

  uint64_t v10 = *(uint64_t **)(a1 + 14608);
  if (v10)
  {
    int v11 = 0;
    uint64_t v12 = 0LL;
    do
    {
      int v13 = *((_DWORD *)v10 + 202);
      BOOL v14 = v13 == 2 || v13 == 5;
      if (v14 || ((int v15 = *((_DWORD *)v10 + 496), v15 != 5) ? (v16 = v15 == 2) : (v16 = 1), v16))
      {
        unsigned int v17 = *((unsigned __int8 *)v10 + 208);
        if (*((_BYTE *)v10 + 208))
        {
          int v18 = 0;
          char v19 = v10 + 26;
          do
          {
            ++v18;
            uint64_t v20 = (uint64_t)v19 + v17;
            unsigned int v21 = *(unsigned __int8 *)(v20 + 1);
            char v19 = (uint64_t *)(v20 + 1);
            unsigned int v17 = v21;
          }

          while (v21);
        }

        else
        {
          int v18 = 0;
        }

        int v22 = v18 >= v6 ? v6 : v18;
        if (v22 >= 1 && v22 > v11)
        {
          int v24 = v6 + 1 - v22;
          int v25 = v18 - v22 + 1;
          do
          {
            int v26 = *(unsigned __int8 **)(a2 + 40);
            if (v6 - v22 >= 1)
            {
              int v27 = v24;
              do
              {
                if (!*v26) {
                  break;
                }
                v26 += *v26 + 1;
                --v27;
              }

              while (v27 > 1);
            }

            uint64_t v28 = (unsigned __int8 *)(v10 + 26);
            if (v18 - v22 >= 1)
            {
              int v29 = v25;
              uint64_t v28 = (unsigned __int8 *)(v10 + 26);
              do
              {
                if (!*v28) {
                  break;
                }
                v28 += *v28 + 1;
                --v29;
              }

              while (v29 > 1);
            }

            if (SameDomainNameBytes(v26, v28))
            {
              uint64_t v12 = v10;
              int v11 = v22;
            }

            --v22;
            ++v24;
            ++v25;
          }

          while (v22 > v11);
        }
      }

      uint64_t v10 = (uint64_t *)*v10;
    }

    while (v10);
    uint64_t v3 = a1;
    if (v12) {
      return (uint64_t)(v12 + 26);
    }
  }

  uint64_t result = v3 + 14096;
  if (!*(_BYTE *)(v3 + 14096))
  {
    if (*(_DWORD *)(v3 + 12988) == -1 && *(_DWORD *)(v3 + 12728))
    {
      uint64_t v30 = (_DWORD *)(v3 + 13098);
      memset(v61, 0, 30);
      bzero((void *)(v3 + 12776), 0x290uLL);
      mDNS_snprintf(v61);
      *(_BYTE *)(v3 + 13132) = 0;
      if (AppendDNSNameString((_BYTE *)(v3 + 13132), (unsigned __int8 *)v61, v31, v32, v33, v34, v35, v36))
      {
        *(void *)(v3 + 12912) = 0LL;
        *(_DWORD *)(v3 + 13080) = 0;
        _DWORD *v30 = 65548;
        *(_DWORD *)(v3 + 13388) = 0x1000000;
        *(_WORD *)(v3 + 13392) = 0;
        *(_BYTE *)(v3 + 13397) = 0;
        *(_WORD *)(v3 + 13395) = 0;
        *(_BYTE *)(v3 + 13408) = 0;
        *(_DWORD *)(v3 + 130memset(v45, 0, 20) = getpid();
        *(_DWORD *)(v3 + 13024) = 0;
        *(void *)(v3 + 12928) = FoundStaticHostname;
        *(void *)(v3 + 12952) = 0LL;
        if (mDNS_LoggingEnabled == 1)
        {
          unsigned __int16 v42 = (os_log_s *)mDNSLogCategory_Default;
          DNSTypeName(*(unsigned __int16 *)v30);
          LogMsgWithLevel(v42, OS_LOG_TYPE_DEFAULT, "GetStaticHostname: %##s (%s)", v43, v44, v45, v46, v47, v3 + 13132);
        }

        int started = mDNS_StartQuery_internal(v3, v3 + 12776);
        if (started) {
          LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "Error: GetStaticHostname - StartQuery returned error %d",  v49,  v50,  v51,  v52,  v53,  started);
        }
      }

      else
      {
        LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "Error: GetStaticHostname - bad name %s",  v37,  v38,  v39,  v40,  v41,  (int)v61);
      }
    }

    if (mDNS_LoggingEnabled == 1)
    {
      unsigned int v54 = (os_log_s *)mDNSLogCategory_Default;
      GetRRDisplayString_rdb( (unsigned __int8 *)(a2 + 8),  (unsigned __int16 *)(*(void *)(a2 + 48) + 4LL),  (_BYTE *)(v3 + 46976));
      LogMsgWithLevel( v54,  OS_LOG_TYPE_DEFAULT,  "GetServiceTarget: Returning NULL for %s",  v55,  v56,  v57,  v58,  v59,  v3 + 46976);
    }

    return 0LL;
  }

  return result;
}

void NetworkChanged(uint64_t a1, const __CFArray *a2, unsigned int *a3)
{
  uint64_t v5 = pthread_mutex_lock((pthread_mutex_t *)(mDNSStorage[0] + 616));
  *(_DWORD *)(mDNSStorage[0] + 680) = mDNSPlatformRawTime(v5, v6, v7, v8, v9, v10, v11, v12);
  mDNS_Lock_(a3, (uint64_t)"NetworkChanged", 6611);
  uint64_t Count = CFArrayGetCount(a2);
  v102.locatiouint64_t n = 0LL;
  v102.length = Count;
  int v80 = CFArrayContainsValue(a2, v102, (const void *)NetworkChangedKey_Hostnames);
  v103.locatiouint64_t n = 0LL;
  v103.length = Count;
  int v79 = CFArrayContainsValue(a2, v103, (const void *)NetworkChangedKey_Computername);
  v104.locatiouint64_t n = 0LL;
  v104.length = Count;
  int v78 = CFArrayContainsValue(a2, v104, (const void *)NetworkChangedKey_DNS);
  v105.locatiouint64_t n = 0LL;
  v105.length = Count;
  int v14 = CFArrayContainsValue(a2, v105, @"Setup:/Network/DynamicDNS");
  CFIndex v15 = CFArrayGetCount(a2);
  if (v15 >= 1 && (CFIndex v16 = v15, (Mutable = CFArrayCreateMutable(0LL, 0LL, &kCFTypeArrayCallBacks)) != 0LL))
  {
    int v18 = Mutable;
    char v19 = kSCDynamicStoreDomainSetup;
    CFStringRef NetworkServiceEntity = SCDynamicStoreKeyCreateNetworkServiceEntity( 0LL,  kSCDynamicStoreDomainSetup,  kSCCompAnyRegex,  kSCEntNetInterface);
    if (!NetworkServiceEntity) {
      goto LABEL_38;
    }
    CFStringRef v21 = NetworkServiceEntity;
    CFArrayAppendValue(v18, NetworkServiceEntity);
    CFRelease(v21);
    CFStringRef v22 = SCDynamicStoreKeyCreateNetworkServiceEntity(0LL, kSCDynamicStoreDomainSetup, kSCCompAnyRegex, kSCEntNetIPv4);
    if (!v22) {
      goto LABEL_38;
    }
    CFStringRef v23 = v22;
    CFArrayAppendValue(v18, v22);
    CFRelease(v23);
    int v24 = SCDynamicStoreCopyMultiple(0LL, 0LL, v18);
    CFRelease(v18);
    if (v24)
    {
      CFIndex v25 = CFDictionaryGetCount(v24);
      if (v25 >= 1)
      {
        CFIndex v26 = v25;
        size_t v27 = (8 * v25);
        if (!(_DWORD)v27
          || (__int128 values = (void **)malloc((8 * v25))) == 0LL
          || (CFIndex v75 = v26, v83 = a3, (v28 = (const void **)malloc(v27)) == 0LL))
        {
          __break(1u);
        }

        int v29 = (CFStringRef *)v28;
        theDict = v24;
        CFDictionaryGetKeysAndValues(v24, v28, (const void **)values);
        int v81 = 0;
        CFIndex v30 = 0LL;
        uint64_t v73 = v29;
        CFIndex v74 = v16;
        while (1)
        {
          ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(a2, v30);
          __int128 v100 = 0u;
          __int128 v101 = 0u;
          __int128 v98 = 0u;
          __int128 v99 = 0u;
          __int128 v96 = 0u;
          __int128 v97 = 0u;
          __int128 v94 = 0u;
          __int128 v95 = 0u;
          __int128 v92 = 0u;
          __int128 v93 = 0u;
          __int128 v90 = 0u;
          __int128 v91 = 0u;
          __int128 v88 = 0u;
          __int128 v89 = 0u;
          memset(buffer, 0, sizeof(buffer));
          if (CFStringHasPrefix(ValueAtIndex, @"State:/Network/Interface/"))
          {
            if (CFStringHasSuffix(ValueAtIndex, kSCEntNetIPv4))
            {
              uint64_t v32 = (const __CFString *)CopyNameFromKey(ValueAtIndex);
              if (v32) {
                break;
              }
            }
          }

LABEL_76:
  SetNetworkChanged(25);
  if (v14)
  {
    int v63 = *(_DWORD *)(mDNSStorage[0] + 500);
    int v64 = dword_100158BF8 + 25;
    if (v63) {
      BOOL v65 = v63 - v64 < 1;
    }
    else {
      BOOL v65 = 0;
    }
    if (!v65)
    {
      *(_DWORD *)(mDNSStorage[0] + 500) = v64;
      if (mDNS_LoggingEnabled == 1) {
        LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "SetKeyChainTimer: %d",  v58,  v59,  v60,  v61,  v62,  25);
      }
    }
  }

  mDNS_Unlock_((uint64_t)a3, (uint64_t)"NetworkChanged", 6702);
  KQueueUnlock((uint64_t)"NetworkChanged", v66, v67, v68, v69, v70, v71, v72);
}

        char v19 = v107;
        goto LABEL_80;
      }

      goto LABEL_80;
    }

    if (v14) {
      uint64_t v31 = *(_DWORD *)(v14 + 6424);
    }
    else {
      uint64_t v31 = 0;
    }
    *(_DWORD *)buf = v31;
    uint64_t v38 = buf;
    uint64_t v39 = v28;
    uint64_t v40 = 0;
    CFStringRef v41 = 25;
    goto LABEL_79;
  }

  CFIndex v26 = mDNSLogCategory_NAT;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_NAT == mDNSLogCategory_State)
  {
    CFIndex v16 = 4294901756LL;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_NAT, OS_LOG_TYPE_FAULT))
    {
LABEL_31:
      size_t v27 = bswap32(*a2) >> 16;
      *(_DWORD *)buf = 67109120;
      *(_DWORD *)__int16 v111 = v27;
      int v18 = "[Q%u] mDNSPlatformSendUDP: dst is not an IPv4 or IPv6 address!";
      CFStringRef v22 = (os_log_s *)v26;
      CFStringRef v23 = OS_LOG_TYPE_FAULT;
      int v24 = 8;
      goto LABEL_32;
    }
  }

  else
  {
    CFIndex v16 = 4294901756LL;
    CFIndex v26 = mDNSLogCategory_NAT_redacted;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_NAT_redacted, OS_LOG_TYPE_FAULT)) {
      goto LABEL_31;
    }
  }

  return v16;
}

                mDNS_snprintf_add(&v131, (int)v177, "RDATA[%u]: %.*H", v73, v74, v75, v76, v77, v61);
                goto LABEL_77;
              }

              if ((_DWORD)v61 != 4) {
                goto LABEL_76;
              }
              mDNS_snprintf_add(&v131, (int)v177, "%.4a", v73, v74, v75, v76, v77, (int)v62);
            }

              uint64_t v58 = v39;
              uint64_t v59 = mDNS_DomainNameFNV1aHash(v17);
              uint64_t v60 = bswap32(*(unsigned __int16 *)(v11[343] + 8LL)) >> 16;
              uint64_t v61 = *(_DWORD *)(a1 + 232);
              uint64_t v62 = *(_DWORD *)(a1 + 236);
              __int128 v93 = *(_DWORD *)(a1 + 172);
              if (*v17) {
                int v63 = &v18[*v17];
              }
              else {
                int v63 = v17;
              }
              int v64 = mDNS_DomainNameFNV1aHash(v63);
              *(void *)__tp = 0LL;
              *(void *)&__tp[8] = 0LL;
              clock_gettime(_CLOCK_MONOTONIC_RAW, (timespec *)__tp);
              BOOL v65 = *(_DWORD *)__tp - *(_DWORD *)(a1 + 188);
              *(_DWORD *)__tp = 67111939;
              *(_DWORD *)&__tp[4] = v96;
              *(_WORD *)&__tp[8] = 2160;
              *(void *)&__tp[10] = 1752392040LL;
              *(_WORD *)&_BYTE __tp[18] = 1040;
              CFRange v103 = v58;
              CFRange v104 = 2101;
              CFRange v105 = v17;
              int v106 = 1024;
              uint64_t v107 = v59;
              uint64_t v10 = v99;
              int v14 = v100;
              int v108 = 1024;
              uint64_t v109 = v60;
              uint64_t v110 = 1024;
              __int16 v111 = v61;
              CFIndex v15 = (_BYTE *)&unk_100164000;
              uint64_t v112 = 1024;
              __int16 v113 = v62;
              int v13 = v97;
              uint64_t v12 = v98;
              uint64_t v114 = 1024;
              uint64_t v115 = v93;
              __int128 v116 = 2082;
              __int128 v117 = v100;
              __int128 v118 = 1024;
              __int128 v119 = v64;
              __int128 v120 = 1024;
              __int128 v121 = v65;
              CFTypeID v43 = (os_log_s *)v21;
              uint64_t v44 = "[R%u] DNSServiceRegister STOP -- SRV name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%x"
                    "), port: %u, flags: 0x%X, interface index: %d, client pid: %d (%{public}s), name hash: %x, duration:"
                    " %{mdns:time_duration}u";
              goto LABEL_80;
            }
          }

          else if ((v20 & 1) != 0)
          {
            CFStringRef v21 = mDNSLogCategory_mDNS_redacted;
            if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
            {
              __int128 v95 = *(_DWORD *)(a1 + 184);
              uint64_t v35 = v17;
LABEL_30:
              uint64_t v36 = 257;
              if (v35 < v17 + 256 && v35)
              {
                while (1)
                {
                  uint64_t v37 = *v35;
                  if (v37 > 0x3F)
                  {
LABEL_81:
                    uint64_t v36 = 257;
                    goto LABEL_86;
                  }

                  if (!*v35) {
                    break;
                  }
                  v35 += v37 + 1;
LABEL_33:
                  if (!v35) {
                    goto LABEL_81;
                  }
                }

                uint64_t v36 = (_WORD)v35 - (_WORD)v17 + 1;
              }

  if (v42)
  {
    uint64_t v44 = 0LL;
    int v77 = 512;
    int v78 = (char *)&unk_100164138;
  }

  else
  {
    int v78 = (char *)malloc(v41);
    uint64_t v44 = v78;
    int v77 = v41;
    if (!v78) {
      goto LABEL_1088;
    }
  }

  if ((_DWORD)v41)
  {
    unsigned __int16 v622 = 0;
    unsigned __int16 v621 = 0;
    uint64_t v148 = ResourceRecordGetRDataBytesPointer(a3, v78, v77, &v621, &v622, v33, v34, v35);
    if (v622) {
      goto LABEL_972;
    }
    unint64_t v149 = (const void *)v148;
    uint64_t v603 = v44;
    uint64_t v596 = v31;
    unsigned int v150 = v621;
    int v611 = v29;
    if (v621 >= 0x1FFuLL)
    {
      int v151 = v621 + 2;
      unsigned int v152 = (__int16 *)malloc(v621 + 2LL);
      if (!v152) {
        goto LABEL_1088;
      }
      unsigned int v131 = v152;
    }

    else
    {
      unsigned int v131 = 0LL;
      int v151 = 512;
      unsigned int v152 = word_100164338;
    }

    uint64_t v582 = v152;
    if (v27) {
      int v289 = (os_log_s *)mDNSLogCategory_Default;
    }
    else {
      int v289 = (os_log_s *)mDNSLogCategory_mDNS;
    }
    if (gSensitiveLoggingEnabled != 1 || v289 == (os_log_s *)mDNSLogCategory_State)
    {
      if (!os_log_type_enabled(v289, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_969;
      }
      uint64_t v290 = *(_DWORD *)(a7 + 184);
      uint64_t v305 = (_BYTE *)(a2 + 356);
      uint64_t v589 = a7;
      uint64_t v576 = v131;
      if (a2 == -612)
      {
LABEL_655:
        while (v305)
        {
          uint64_t v306 = *v305;
          if (!*v305)
          {
            char v393 = (_WORD)v305 - v30 + 1;
            goto LABEL_933;
          }

          v305 += v306 + 1;
          if (a2 != -612) {
            goto LABEL_654;
          }
        }
      }

      else
      {
LABEL_654:
      }

      char v393 = 257;
LABEL_933:
      uint64_t v476 = v393;
      uint64_t v477 = *(unsigned __int16 *)(a3 + 4);
      uint64_t v478 = v150 + 2;
      if ((int)v150 + 2 <= v151)
      {
        *uint64_t v582 = __rev16(v477);
        int v487 = v290;
        memcpy(v582 + 1, v149, v150);
        uint64_t v290 = v487;
        int v479 = v582;
      }

      else
      {
        int v479 = 0LL;
      }
    }

    else
    {
      if (v27) {
        int v289 = (os_log_s *)mDNSLogCategory_Default_redacted;
      }
      else {
        int v289 = (os_log_s *)mDNSLogCategory_mDNS;
      }
      if (!os_log_type_enabled(v289, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_969;
      }
      uint64_t v290 = *(_DWORD *)(a7 + 184);
      int v291 = (_BYTE *)(a2 + 356);
      uint64_t v589 = a7;
      uint64_t v576 = v131;
      if (a2 == -612)
      {
LABEL_603:
        while (v291)
        {
          int v292 = *v291;
          if (!*v291)
          {
            uint64_t v391 = (_WORD)v291 - v30 + 1;
            goto LABEL_924;
          }

          v291 += v292 + 1;
          if (a2 != -612) {
            goto LABEL_602;
          }
        }
      }

      else
      {
LABEL_602:
      }

      uint64_t v391 = 257;
LABEL_924:
      uint64_t v476 = v391;
      uint64_t v477 = *(unsigned __int16 *)(a3 + 4);
      uint64_t v478 = v150 + 2;
      if ((int)v150 + 2 <= v151)
      {
        *uint64_t v582 = __rev16(v477);
        uint64_t v480 = v290;
        memcpy(v582 + 1, v149, v150);
        uint64_t v290 = v480;
        int v479 = v582;
      }

      else
      {
        int v479 = 0LL;
      }
    }

    LODWORD(buf.tv_sec) = 67111939;
    HIDWORD(buf.tv_sec) = v290;
    LOWORD(buf.tv_nsec) = 1024;
    *(_DWORD *)((char *)&buf.tv_nsec + 2) = v620;
    HIWORD(buf.tv_nsec) = 1024;
    *(_DWORD *)uint64_t v625 = a4;
    *(_WORD *)&v625[4] = 1024;
    *(_DWORD *)&v625[6] = v611;
    strcpy((char *)&v626, "p\bhash");
    HIBYTE(v626) = 0;
    *(_WORD *)uint64_t v627 = 0;
    *(_WORD *)&v627[2] = 1040;
    *(_DWORD *)&v627[4] = v476;
    *(_WORD *)&v627[8] = 2101;
    *(void *)&v627[10] = a2 + 356;
    *(_WORD *)&v627[18] = 1024;
    *(_DWORD *)&v627[20] = v596;
    *(_WORD *)&v627[24] = 1024;
    *(_DWORD *)&v627[26] = v477;
    *(_WORD *)&v627[30] = 2160;
    *(void *)&v627[32] = 1752392040LL;
    *(_WORD *)&v627[40] = 1040;
    *(_DWORD *)&v627[42] = v478;
    *(_WORD *)&v627[46] = 2101;
    *(void *)&v627[48] = v479;
    v481 = "[R%u->mDNS] DNSServiceQueryRecord result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %d, nam"
           "e: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%x), type: %{mdns:rrtype}d, rdata: %{sensitive, mas"
           "k.hash, mdns:rdata}.*P";
    goto LABEL_941;
  }

  if (v27) {
    unint64_t v169 = (os_log_s *)mDNSLogCategory_Default;
  }
  else {
    unint64_t v169 = (os_log_s *)mDNSLogCategory_mDNS;
  }
  if (gSensitiveLoggingEnabled != 1 || v169 == (os_log_s *)mDNSLogCategory_State)
  {
    if (!os_log_type_enabled(v169, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_972;
    }
    uint64_t v170 = *(_DWORD *)(a7 + 184);
    char v245 = (_BYTE *)(a2 + 356);
    if (a2 == -612)
    {
LABEL_436:
      while (v245)
      {
        uint64_t v246 = *v245;
        if (!*v245)
        {
          uint64_t v343 = (_WORD)v245 - v30 + 1;
          goto LABEL_873;
        }

        v245 += v246 + 1;
        if (a2 != -612) {
          goto LABEL_435;
        }
      }
    }

    else
    {
LABEL_435:
    }

    uint64_t v343 = 257;
    goto LABEL_873;
  }

  if (v27) {
    unint64_t v169 = (os_log_s *)mDNSLogCategory_Default_redacted;
  }
  else {
    unint64_t v169 = (os_log_s *)mDNSLogCategory_mDNS;
  }
  if (os_log_type_enabled(v169, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v170 = *(_DWORD *)(a7 + 184);
    BOOL v171 = (_BYTE *)(a2 + 356);
    if (a2 == -612)
    {
LABEL_218:
      while (v171)
      {
        int v172 = *v171;
        if (!*v171)
        {
          uint64_t v343 = (_WORD)v171 - v30 + 1;
          goto LABEL_873;
        }

        v171 += v172 + 1;
        if (a2 != -612) {
          goto LABEL_217;
        }
      }
    }

    else
    {
LABEL_217:
    }

    uint64_t v343 = 257;
LABEL_873:
    unint64_t v435 = *(unsigned __int16 *)(a3 + 4);
    LODWORD(buf.tv_sec) = 67111171;
    HIDWORD(buf.tv_sec) = v170;
    LOWORD(buf.tv_nsec) = 1024;
    *(_DWORD *)((char *)&buf.tv_nsec + 2) = v620;
    HIWORD(buf.tv_nsec) = 1024;
    *(_DWORD *)uint64_t v625 = a4;
    *(_WORD *)&v625[4] = 1024;
    *(_DWORD *)&v625[6] = v29;
    strcpy((char *)&v626, "p\bhash");
    HIBYTE(v626) = 0;
    *(_WORD *)uint64_t v627 = 0;
    *(_WORD *)&v627[2] = 1040;
    *(_DWORD *)&v627[4] = v343;
    *(_WORD *)&v627[8] = 2101;
    *(void *)&v627[10] = a2 + 356;
    *(_WORD *)&v627[18] = 1024;
    *(_DWORD *)&v627[20] = v31;
    *(_WORD *)&v627[24] = 1024;
    *(_DWORD *)&v627[26] = v435;
    unsigned int v179 = "[R%u->mDNS] DNSServiceQueryRecord result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %d, nam"
           "e: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%x), type: %{mdns:rrtype}d, rdata: <none>";
LABEL_878:
    uint64_t v251 = v169;
    uint64_t v252 = 64;
    goto LABEL_879;
  }

      *(_DWORD *)(v34 + 24) = DomainNameHashValue(*(void *)(v34 + 40));
      SetNewRData(v34 + 8, 0LL, 0LL, v50, v51, v52, v53, v54);
      if (mDNS_LoggingEnabled == 1)
      {
        uint64_t v55 = (os_log_s *)mDNSLogCategory_Default;
        GetRRDisplayString_rdb( (unsigned __int8 *)(v34 + 8),  (unsigned __int16 *)(*(void *)(v34 + 48) + 4LL),  word_100164338);
        LogMsgWithLevel( v55,  OS_LOG_TYPE_DEFAULT,  "mDNSMacOSXCreateEtcHostsEntry: Adding resource record %s ID %d",  v56,  v57,  v58,  v59,  v60,  (int)word_100164338);
      }

      InsertAuthRecord(a5, v34);
      return 1LL;
    }

    else
    {
      __break(1u);
    }

    return result;
  }

  while (1)
  {
    if (v21 == 28) {
      break;
    }
    if (v21 == 5)
    {
      if (SameDomainNameBytes((_BYTE *)(*(void *)(v32 + 48) + 4LL), (_BYTE *)a3))
      {
        if (mDNS_LoggingEnabled == 1) {
          LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "mDNSMacOSXCreateEtcHostsEntry: Same cname %##s for name %##s",  v27,  v28,  v29,  v30,  v31,  a3);
        }
        return 0LL;
      }
    }

    else if (*(_DWORD *)(*(void *)(v32 + 48) + 4LL) == *(_DWORD *)(a2 + 4) && v20 == *(void *)(v32 + 32))
    {
      if (mDNS_LoggingEnabled == 1) {
        LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "mDNSMacOSXCreateEtcHostsEntry: Same IPv4 address and InterfaceID for name %##s ID %d",  v27,  v28,  v29,  v30,  v31,  (int)a1);
      }
      return 0LL;
    }

      _mdns_system_unlock_and_forget_prefs(&v56);
      uint64_t v49 = v57;
      CFRelease(v40);
      if (!v49) {
        return;
      }
      goto LABEL_77;
    }

    int v45 = CFStringCreateWithCString(kCFAllocatorDefault, (const char *)&v59, 0x8000100u);
    if (!v45)
    {
      int v52 = -6700;
LABEL_85:
      uint64_t v50 = (os_log_s *)mDNSLogCategory_Default;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_ERROR)) {
          return;
        }
      }

      else
      {
        uint64_t v50 = (os_log_s *)mDNSLogCategory_Default_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_ERROR)) {
          return;
        }
      }

      nameEncoding = 141558531;
      int v64 = 1752392040LL;
      BOOL v65 = 2085;
      uint64_t v66 = (uint64_t)&v59;
      uint64_t v67 = 2048;
      uint64_t v68 = v52;
      uint64_t v51 = "Failed to set local hostname -- name: %{sensitive, mask.hash}s, error: %ld";
      goto LABEL_93;
    }

    int v46 = v45;
    int v57 = 0;
    CFIndex v47 = _mdns_system_create_locked_prefs(&v57);
    uint64_t v56 = v47;
    if (!v57)
    {
      uint64_t v48 = v47;
      if (SCPreferencesSetLocalHostName(v47, v46))
      {
        int v57 = 0;
LABEL_83:
        int v57 = _mdns_system_commit_and_apply_prefs(v48);
        goto LABEL_84;
      }

      if (SCError())
      {
        int v57 = SCError();
        if (!v57) {
          goto LABEL_83;
        }
      }

      else
      {
        int v57 = -6700;
      }

      if (mdns_system_log_s_once != -1) {
        dispatch_once(&mdns_system_log_s_once, &__block_literal_global_6614);
      }
      unsigned int v54 = (os_log_s *)mdns_system_log_s_log;
      if (os_log_type_enabled((os_log_t)mdns_system_log_s_log, OS_LOG_TYPE_ERROR))
      {
        nameEncoding = 138412546;
        int v64 = (uint64_t)v46;
        BOOL v65 = 2048;
        uint64_t v66 = v57;
        _os_log_error_impl( (void *)&_mh_execute_header,  v54,  OS_LOG_TYPE_ERROR,  "SCPreferencesSetLocalHostName failed -- name: '%@', error: %{mdns:err}ld",  (uint8_t *)&nameEncoding,  0x16u);
      }
    }

unint64_t KQueueLock()
{
  uint64_t v0 = pthread_mutex_lock((pthread_mutex_t *)(mDNSStorage[0] + 616));
  unint64_t result = mDNSPlatformRawTime(v0, v1, v2, v3, v4, v5, v6, v7);
  *(_DWORD *)(mDNSStorage[0] + 680) = result;
  return result;
}

uint64_t mDNS_StartNATOperation_internal( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (mDNS_LoggingEnabled == 1) {
    LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "mDNS_StartNATOperation_internal %p Protocol %d IntPort %d RequestedPort %d NATLease %d",  a4,  a5,  a6,  a7,  a8,  a2);
  }
  uint64_t v10 = *(void *)(a1 + 14648);
  uint64_t v11 = (uint64_t *)(a1 + 14648);
  if (v10)
  {
    uint64_t v11 = (uint64_t *)(a1 + 14648);
    while (v10 != a2)
    {
      if (*(_BYTE *)(a2 + 172) && *(unsigned __int8 *)(a2 + 172) == *(unsigned __int8 *)(v10 + 172))
      {
        int v12 = *(unsigned __int16 *)(a2 + 174);
        if (v12 == *(unsigned __int16 *)(v10 + 174) && v12 != 5632)
        {
          LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "Warning: Created port mapping request %p Prot %d Int %d TTL %d duplicates existing port mapping request %p P rot %d Int %d TTL %d",  a4,  a5,  a6,  a7,  a8,  a2);
          uint64_t v10 = *v11;
        }
      }

      uint64_t v11 = (uint64_t *)v10;
      uint64_t v10 = *(void *)v10;
      if (!v10) {
        goto LABEL_14;
      }
    }

    LogFatalError( "Error! Tried to add a NAT traversal that's already in the active list: request %p Prot %d Int %d TTL %d",  a2,  a3,  a4,  a5,  a6,  a7,  a8,  a2);
    return 4294901749LL;
  }

  else
  {
LABEL_14:
    *(void *)a2 = 0LL;
    *(void *)(a2 + 8) = 0xFA00000000LL;
    *(_DWORD *)(a2 + 16) = *(_DWORD *)(a1 + 64);
    *(_BYTE *)(a2 + 28) = 0;
    *(void *)(a2 + memset(v45, 0, 20) = 0LL;
    *(void *)(a2 + 152) = 0xFFFFFFFFLL;
    *(_WORD *)(a2 + 160) = 0;
    *(_DWORD *)(a2 + 164) = 0;
    *(_DWORD *)(a2 + 168) = 0;
    if (!*(_DWORD *)(a2 + 180)) {
      *(_DWORD *)(a2 + 180) = 7200;
    }
    *(_OWORD *)(a2 + 112) = 0u;
    *(_OWORD *)(a2 + 128) = 0u;
    *(_OWORD *)(a2 + 80) = 0u;
    *(_OWORD *)(a2 + 96) = 0u;
    *(_OWORD *)(a2 + 48) = 0u;
    *(_OWORD *)(a2 + 64) = 0u;
    *(_OWORD *)(a2 + 32) = 0u;
    if (!*(void *)(a1 + 14648))
    {
      *(_DWORD *)(a1 + 14668) = *(_DWORD *)(a1 + 64);
      *(_DWORD *)(a1 + 14664) = 250;
    }

    if (!*(_BYTE *)(a2 + 172)) {
      *(_DWORD *)(a2 + 156) = *(_DWORD *)(a1 + 14672);
    }
    uint64_t result = 0LL;
    *(_DWORD *)(a1 + 104) = *(_DWORD *)(a1 + 64);
    *uint64_t v11 = a2;
  }

  return result;
}

void send_all(int a1, const void *a2, size_t a3)
{
  unint64_t v5 = send(a1, a2, a3, 0);
  if ((v5 & 0x8000000000000000LL) != 0 || v5 < a3)
  {
    uint64_t v6 = (os_log_s *)mDNSLogCategory_Default;
    __error();
    uint64_t v7 = __error();
    strerror(*v7);
    LogMsgWithLevel( v6,  OS_LOG_TYPE_DEFAULT,  "ERROR: send_all(%d) wrote %ld of %lu errno %d (%s)",  v8,  v9,  v10,  v11,  v12,  a1);
  }

void uDNS_SendNATMsg(uint64_t a1, uint64_t a2, int a3, int a4)
{
  if (!a2)
  {
    uint64_t v8 = mDNSLogCategory_NAT;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_NAT == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT, OS_LOG_TYPE_DEFAULT)) {
        return;
      }
      LOWORD(v30) = 0;
      uint64_t v10 = "uDNS_SendNATMsg called unexpectedly with NULL info";
    }

    else
    {
      uint64_t v8 = mDNSLogCategory_NAT_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT_redacted, OS_LOG_TYPE_DEFAULT)) {
        return;
      }
      LOWORD(v30) = 0;
      uint64_t v10 = "uDNS_SendNATMsg called unexpectedly with NULL info";
    }

    uint64_t v12 = &v30;
    int v13 = (os_log_s *)v8;
    uint32_t v14 = 2;
    goto LABEL_17;
  }

  int v7 = *(unsigned __int8 *)(a1 + 12708);
  if (v7 != 10)
  {
    if (v7 == 172)
    {
      if ((*(_BYTE *)(a1 + 12709) & 0xF0) != 0x10) {
        return;
      }
    }

    else if (v7 != 192 || *(unsigned __int8 *)(a1 + 12709) != 168)
    {
      return;
    }
  }

  CFIndex v15 = (int *)(a1 + 12704);
  if (a3)
  {
    int v30 = 258;
    int v16 = *(_DWORD *)(a2 + 180);
    char v31 = HIBYTE(v16);
    char v32 = BYTE2(v16);
    char v33 = BYTE1(v16);
    char v34 = v16;
    uint64_t v35 = 0LL;
    int v36 = -65536;
    int v37 = *(_DWORD *)(a1 + 12728);
    uint64_t v38 = *(void *)(a1 + 14676);
    int v39 = *(_DWORD *)(a1 + 14684);
    int v17 = *(unsigned __int8 *)(a2 + 172);
    if (v17 == 1) {
      char v18 = 17;
    }
    else {
      char v18 = 6;
    }
    char v40 = v18;
    __int16 v41 = 0;
    char v42 = 0;
    if (v17) {
      char v19 = (__int16 *)(a2 + 174);
    }
    else {
      char v19 = (__int16 *)&DiscardPort;
    }
    __int16 v43 = *v19;
    __int16 v44 = *(_WORD *)(a2 + 176);
    uint64_t v45 = 0LL;
    int v46 = -65536;
    int v47 = *(_DWORD *)(a2 + 156);
    mDNSPlatformSendUDP((void *)a1, (unsigned __int16 *)&v30, (uint64_t)&v48, 0LL, 0LL, v15, 0xE714u, 0);
    *(_BYTE *)(a2 + 28) = 0;
    if (!a4)
    {
      if (!*(_WORD *)(a1 + 14962) || !*(_WORD *)(a1 + 14964))
      {
        LNT_SendDiscoveryMsg(a1);
        return;
      }

      if (mDNS_LoggingEnabled == 1) {
        LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "LNT_MapPort",  v20,  v21,  v22,  v23,  v24,  v30);
      }
      if (!*(void *)(a2 + 56))
      {
        *(void *)(a2 + 48) = a2;
        *(_DWORD *)(a2 + 136) = 0;
        unsigned int v25 = SendPortMapRequest(a1, a2);
        if (v25)
        {
          unsigned int v26 = v25;
          uint64_t v27 = mDNSLogCategory_NAT;
          if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_NAT == mDNSLogCategory_State)
          {
            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT, OS_LOG_TYPE_DEFAULT)) {
              return;
            }
            int v49 = 67109120;
            unsigned int v50 = v26;
            uint64_t v10 = "uDNS_SendNATMsg: LNT_MapPort returned error %d";
          }

          else
          {
            uint64_t v27 = mDNSLogCategory_NAT_redacted;
            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT_redacted, OS_LOG_TYPE_DEFAULT)) {
              return;
            }
            int v49 = 67109120;
            unsigned int v50 = v26;
            uint64_t v10 = "uDNS_SendNATMsg: LNT_MapPort returned error %d";
          }

          uint64_t v12 = &v49;
          int v13 = (os_log_s *)v27;
          uint32_t v14 = 8;
LABEL_17:
          _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, v10, (uint8_t *)v12, v14);
        }
      }
    }
  }

  else if (!*(_BYTE *)(a2 + 28))
  {
    char v28 = *(_BYTE *)(a2 + 172);
    if (v28)
    {
      uDNS_SendNATMsg_NATPortReq = 0;
      byte_10014DC65 = v28;
      word_10014DC66 = 0;
      unsigned int v29 = bswap32(*(_DWORD *)(a2 + 180));
      dword_10014DC68 = *(_DWORD *)(a2 + 174);
      unk_10014DC6C = v29;
      mDNSPlatformSendUDP( (void *)a1,  (unsigned __int16 *)&uDNS_SendNATMsg_NATPortReq,  (uint64_t)&uDNS_RequestAddress_req,  0LL,  0LL,  v15,  0xE714u,  0);
    }

    *(_DWORD *)(a2 + 156) = *(_DWORD *)(a1 + 14672);
    *(_BYTE *)(a2 + 28) = 1;
  }

void KQueueUnlock( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v9 = mDNSPlatformRawTime(a1, a2, a3, a4, a5, a6, a7, a8) - *(_DWORD *)(mDNSStorage + 680);
  if (v9 < WatchDogReportingThreshold) {
    goto LABEL_11;
  }
  uint64_t v10 = (os_log_s *)mDNSLogCategory_Default;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
  {
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_11;
    }
  }

  else
  {
    uint64_t v10 = (os_log_s *)mDNSLogCategory_Default_redacted;
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_11;
    }
  }

  *(_DWORD *)buf = 136446466;
  uint64_t v22 = a1;
  __int16 v23 = 1024;
  int v24 = v9;
  _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "WARNING: %{public}s took %d ms to complete",  buf,  0x12u);
LABEL_11:
  pthread_mutex_unlock((pthread_mutex_t *)(mDNSStorage + 616));
  buf[0] = 1;
  if (send(*(_DWORD *)(mDNSStorage + 684), buf, 1uLL, 0) == -1)
  {
    int v13 = (os_log_s *)mDNSLogCategory_Default;
    int v14 = *__error();
    CFIndex v15 = __error();
    strerror(*v15);
    LogMsgWithLevel( v13,  OS_LOG_TYPE_DEFAULT,  "ERROR: KQueueWake: send failed with error code: %d (%s)",  v16,  v17,  v18,  v19,  v20,  v14);
  }

ssize_t KQWokenFlushBytes(int a1)
{
  int v4 = 0;
  memset(v3, 0, sizeof(v3));
  do
    ssize_t result = recv(a1, v3, 0x64uLL, 128);
  while (result > 0);
  return result;
}

uint64_t mDNS_NewMessageID(uint64_t a1)
{
  int v2 = 0;
  uint64_t v3 = (uint64_t **)(a1 + 12624);
  do
LABEL_2:
    uint32_t v4 = arc4random();
  while ((_WORD)v4 == 0xFFFF);
  uint64_t result = bswap32(v4 + 1) >> 16;
  uint64_t v6 = v3;
  while (1)
  {
    uint64_t v6 = (uint64_t **)*v6;
    if (!v6) {
      break;
    }
  }

  uint64_t v7 = *(void *)(a1 + 200);
  if (!v7) {
    return result;
  }
  while (*(unsigned __int16 *)(v7 + 320) != (_DWORD)result)
  {
    uint64_t v7 = *(void *)(v7 + 8);
    if (!v7) {
      return result;
    }
  }

LABEL_6:
  if (++v2 != 10) {
    goto LABEL_2;
  }
  return result;
}

  if (!*(_BYTE *)(a1 + 60)) {
    return 1LL;
  }
  unint64_t v5 = *(_DWORD *)(a1 + 52);
  cache_record = resource_record_get_cache_record(*((void *)v3 + 7));
  if (!cache_record)
  {
    uint64_t v11 = (os_log_s *)mDNSLogCategory_DNSSEC;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_DNSSEC == mDNSLogCategory_State)
    {
      uint64_t result = os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC, OS_LOG_TYPE_FAULT);
      if (!(_DWORD)result) {
        return result;
      }
    }

    else
    {
      uint64_t v11 = (os_log_s *)mDNSLogCategory_DNSSEC_redacted;
      uint64_t result = os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC_redacted, OS_LOG_TYPE_FAULT);
      if (!(_DWORD)result) {
        return result;
      }
    }

    int v14 = 136447234;
    CFIndex v15 = "cr != NULL";
    uint64_t v16 = 2082;
    uint64_t v17 = "";
    uint64_t v18 = 2082;
    uint64_t v19 = "/Library/Caches/com.apple.xbs/Sources/mDNSResponder/mDNSMacOSX/dnssec_v2/dnssec_objs/dnssec_obj_rrset.c";
    uint64_t v20 = 1024;
    uint64_t v21 = 488;
    uint64_t v22 = 2048;
    __int16 v23 = 0LL;
    goto LABEL_41;
  }

  uint64_t v7 = *(_DWORD *)(cache_record + 80) + 1000 * a2;
  if (v7 <= 1) {
    uint64_t v7 = 1;
  }
  return (int)(v7 - v5) > 999;
}

    uint64_t result = (uint64_t)xpc_string_create(string);
    *a1 = (xpc_object_t)result;
  }

  return result;
}

  return v9;
}

void ActivateUnicastQuery(uint64_t a1, uint64_t a2, int a3)
{
  if (!*(void *)(a2 + 40))
  {
    *(_BYTE *)(a2 + 333) = 0;
    uint64_t v6 = *(void **)(a2 + 104);
    if (v6)
    {
      CancelGetZoneData(a1, v6);
      *(void *)(a2 + 104) = 0LL;
    }

    if (*(_BYTE *)(a2 + 612))
    {
      *(_BYTE *)(a2 + 330) = 1;
      *(void *)(a2 + 308) = 0LL;
      *(_WORD *)(a2 + 316) = 0;
      uint64_t v7 = *(void *)(a2 + 112);
      if (v7)
      {
        DisposeTCPConn(v7);
        *(void *)(a2 + 112) = 0LL;
      }
    }

    if (a3)
    {
      uint64_t v8 = AuthGroupForName(a1 + 6272, *(_DWORD *)(a2 + 200), (_BYTE *)(a2 + 356));
      if (v8 && (uint64_t v15 = v8[2]) != 0)
      {
        while (1)
        {
          if (*(_DWORD *)(v15 + 172) == 4 && (*(_BYTE *)(v15 + 8) & 0x32) != 0)
          {
            unsigned int v16 = *(unsigned __int16 *)(v15 + 12);
            BOOL v17 = v16 > 0x1C;
            int v18 = (1 << v16) & 0x10001022;
            BOOL v19 = v17 || v18 == 0;
            if (!v19 && LocalOnlyRecordAnswersQuestion(v15, a2, v9, v10, v11, v12, v13, v14)) {
              break;
            }
          }

          uint64_t v15 = *(void *)v15;
          if (!v15) {
            goto LABEL_19;
          }
        }

        if (mDNS_LoggingEnabled == 1)
        {
          uint64_t v20 = (os_log_s *)mDNSLogCategory_Default;
          DNSTypeName(*(unsigned __int16 *)(a2 + 322));
          GetRRDisplayString_rdb( (unsigned __int8 *)(v15 + 8),  (unsigned __int16 *)(*(void *)(v15 + 48) + 4LL),  (_BYTE *)(a1 + 46976));
          LogMsgWithLevel( v20,  OS_LOG_TYPE_DEFAULT,  "QuestionHasLocalAnswers: Question %p %##s (%s) has local answer %s",  v21,  v22,  v23,  v24,  v25,  a2);
        }
      }

      else
      {
LABEL_19:
        *(_DWORD *)(a2 + 208) = *(_DWORD *)(a1 + 64) - 334;
        *(_DWORD *)(a2 + 212) = 334;
        SetNextQueryTime(a1, a2);
      }
    }
  }

uint64_t *CacheGroupForName(uint64_t a1, unsigned int a2, _BYTE *a3)
{
  for (CFIndex i = *(uint64_t **)(a1 + 8LL * (a2 % 0x1F3) + 280); i; CFIndex i = (uint64_t *)*i)
  {
  }

  return i;
}

void MakeNegativeCacheRecord( uint64_t a1, uint64_t a2, uint64_t a3, int a4, __int16 a5, __int16 a6, int a7, uint64_t a8, void *a9, __int16 a10)
{
  if (a1 + 37856 == a2)
  {
    int v18 = (unsigned __int8 *)(a1 + 37864);
    if (*(_BYTE *)(a1 + 37864))
    {
      GetRRDisplayString_rdb(v18, (unsigned __int16 *)(*(void *)(a1 + 37904) + 4LL), (_BYTE *)(a1 + 46976));
      LogFatalError( "MakeNegativeCacheRecord: m->rec appears to be already in use for %s",  v19,  v20,  v21,  v22,  v23,  v24,  v25,  a1 + 46976);
    }
  }

  *(_BYTE *)(a2 + 8) = -16;
  *(void *)(a2 + 32) = a8;
  unsigned int v26 = *(void **)(a2 + 56);
  if (v26)
  {
    os_release(v26);
    *(void *)(a2 + 56) = 0LL;
  }

  if (a9)
  {
    uint64_t v27 = mdns_cache_metadata_create();
    *(void *)(a2 + 56) = v27;
    mdns_dns_push_service_definition_set_srv_name(v27, a9);
  }

  *(_WORD *)(a2 + 152) = 0;
  uint64_t v28 = a2 + 152;
  *(_WORD *)(v28 - 140) = a5;
  *(_WORD *)(v28 - 138) = a6;
  *(_DWORD *)(v28 - 136) = a7;
  *(_DWORD *)(v28 - 132) = 0;
  *(_DWORD *)(v28 - 128) = a4;
  *(_DWORD *)(v28 - 124) = 0;
  *(void *)(v28 - 112) = a3;
  *(void *)(v28 - 104) = v28;
  *(void *)(v28 - 88) = 0LL;
  *(void *)(v28 - 80) = 0LL;
  int v29 = *(_DWORD *)(a1 + 64);
  *(_DWORD *)(v28 - 72) = v29;
  *(_DWORD *)(v28 - 68) = 0;
  *(_DWORD *)(v28 - 64) = v29;
  *(void *)(v28 - 56) = 0LL;
  *(_BYTE *)(v28 - 44) = 0;
  *(_DWORD *)(v28 - 48) = 0;
  *(void *)(v28 - 40) = 0LL;
  *(void *)(v28 - 32) = 0LL;
  *(_WORD *)(v28 - 42) = a10;
  *(_BYTE *)(v28 - 143) = HIBYTE(a10) & 0xF;
}

uint64_t GetCacheEntity( uint64_t a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!*(_BYTE *)(a1 + 56))
  {
    *(_BYTE *)(a1 + 56) = 1;
    uint64_t v8 = *(void *)(a1 + 272);
    if (v8) {
      goto LABEL_54;
    }
    if (!*(void *)(a1 + 32)) {
      goto LABEL_23;
    }
    unsigned int v12 = *(_DWORD *)(a1 + 248);
    unsigned int v11 = *(_DWORD *)(a1 + 252);
    if (v11 == v12)
    {
LABEL_16:
      if (v11 < 0x1389 || (unsigned int v16 = *(_DWORD *)(a1 + 260), v16 >= v11 >> 5))
      {
        unsigned int v18 = *(_DWORD *)(a1 + 48);
        unsigned int v19 = *(_DWORD *)(a1 + 52) + 1;
        *(_DWORD *)(a1 + 52) = v19;
        mDNS_VerifyLockState("Drop Lock", 0, v18, v19, (uint64_t)"GetCacheEntity", 6408);
        (*(void (**)(uint64_t, uint64_t))(a1 + 32))(a1, 4294901506LL);
        mDNS_VerifyLockState( "Reclaim Lock",  0,  *(_DWORD *)(a1 + 48),  *(_DWORD *)(a1 + 52),  (uint64_t)"GetCacheEntity",  6410);
        --*(_DWORD *)(a1 + 52);
        goto LABEL_23;
      }

      BOOL v17 = (os_log_s *)mDNSLogCategory_Default;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_23;
        }
      }

      else
      {
        BOOL v17 = (os_log_s *)mDNSLogCategory_Default_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_23;
        }
      }

      int v40 = 67109376;
      unsigned int v41 = v11;
      __int16 v42 = 1024;
      unsigned int v43 = v16;
      _os_log_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_DEFAULT,  "Possible denial-of-service attack in progress: m->rrcache_size %u; m->rrcache_active %u",
        (uint8_t *)&v40,
        0xEu);
LABEL_23:
      uint64_t v8 = *(void *)(a1 + 272);
      if (v8) {
        goto LABEL_54;
      }
      uint64_t v20 = 0LL;
      unsigned int v21 = *(_DWORD *)(a1 + 252);
      do
      {
        uint64_t v22 = a1 + 8 * v20;
        uint64_t v23 = *(void **)(v22 + 280);
        if (v23)
        {
          uint64_t v24 = (void **)(v22 + 280);
          do
          {
            unsigned int v26 = v23 + 2;
            uint64_t v25 = v23[2];
            if (v25)
            {
              do
              {
                if (*(void *)(v25 + 96) || *(void *)(v25 + 112) || *(_DWORD *)(v25 + 84) || *(_BYTE *)(v25 + 128))
                {
                  unsigned int v26 = (uint64_t *)v25;
                }

                else
                {
                  *unsigned int v26 = *(void *)v25;
                  ReleaseCacheRecord(a1, v25);
                }

                uint64_t v25 = *v26;
              }

              while (*v26);
              uint64_t v23 = *v24;
            }

            v23[3] = v26;
            uint64_t v27 = *v24;
            if (*v24 != a2 && (*v24)[2] == 0LL)
            {
              ReleaseCacheGroup(a1, v24);
              uint64_t v27 = v24;
            }

            uint64_t v23 = (void *)*v27;
            uint64_t v24 = (void **)v27;
          }

          while (*v27);
        }

        ++v20;
      }

      while (v20 != 499);
      int v29 = (os_log_s *)mDNSLogCategory_Default;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_53;
        }
      }

      else
      {
        int v29 = (os_log_s *)mDNSLogCategory_Default_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
        {
LABEL_53:
          uint64_t v8 = *(void *)(a1 + 272);
          if (!v8)
          {
LABEL_72:
            *(_BYTE *)(a1 + 56) = 0;
            return v8;
          }

LABEL_54:
          *(void *)(a1 + 272) = *(void *)v8;
          unsigned int v33 = *(_DWORD *)(a1 + 252) + 1;
          *(_DWORD *)(a1 + 252) = v33;
          if (v33 < *(_DWORD *)(a1 + 264))
          {
LABEL_71:
            *(_OWORD *)(v8 + 192) = 0u;
            *(_OWORD *)(v8 + 208) = 0u;
            *(_OWORD *)(v8 + 160) = 0u;
            *(_OWORD *)(v8 + 176) = 0u;
            *(_OWORD *)(v8 + 128) = 0u;
            *(_OWORD *)(v8 + 144) = 0u;
            *(_OWORD *)(v8 + 96) = 0u;
            *(_OWORD *)(v8 + 112) = 0u;
            *(_OWORD *)(v8 + 64) = 0u;
            *(_OWORD *)(v8 + 80) = 0u;
            *(_OWORD *)(v8 + 32) = 0u;
            *(_OWORD *)(v8 + 48) = 0u;
            *(_OWORD *)uint64_t v8 = 0u;
            *(_OWORD *)(v8 + 16) = 0u;
            goto LABEL_72;
          }

          char v34 = (os_log_s *)mDNSLogCategory_Default;
          if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
          {
            if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
            {
              int v40 = 67109120;
              unsigned int v41 = v33;
LABEL_64:
              _os_log_impl( (void *)&_mh_execute_header,  v34,  OS_LOG_TYPE_DEFAULT,  "RR Cache now using %u objects",  (uint8_t *)&v40,  8u);
            }
          }

          else
          {
            char v34 = (os_log_s *)mDNSLogCategory_Default_redacted;
            if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
            {
              int v40 = 67109120;
              unsigned int v41 = v33;
              goto LABEL_64;
            }
          }

          unsigned int v37 = *(_DWORD *)(a1 + 264);
          if (v37 >= 0x3E8) {
            int v38 = 1000;
          }
          else {
            int v38 = 100;
          }
          if (v37 < 0x64) {
            int v38 = 10;
          }
          *(_DWORD *)(a1 + 264) = v37 + v38;
          goto LABEL_71;
        }
      }

      int v32 = *(_DWORD *)(a1 + 252);
      int v40 = 67109632;
      unsigned int v41 = v21 - v32;
      __int16 v42 = 1024;
      unsigned int v43 = v21;
      __int16 v44 = 1024;
      int v45 = v32;
      _os_log_impl( (void *)&_mh_execute_header,  v29,  OS_LOG_TYPE_DEFAULT,  "GetCacheEntity recycled %d records to reduce cache from %d to %d",  (uint8_t *)&v40,  0x14u);
      goto LABEL_53;
    }

    uint64_t v13 = (os_log_s *)mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
      {
LABEL_15:
        unsigned int v11 = *(_DWORD *)(a1 + 248);
        goto LABEL_16;
      }
    }

    else
    {
      uint64_t v13 = (os_log_s *)mDNSLogCategory_Default_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_15;
      }
    }

    int v40 = 67109376;
    unsigned int v41 = v11;
    __int16 v42 = 1024;
    unsigned int v43 = v12;
    _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEFAULT,  "GetFreeCacheRR: count mismatch: m->rrcache_totalused %u != m->rrcache_size %u",  (uint8_t *)&v40,  0xEu);
    goto LABEL_15;
  }

  LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "GetFreeCacheRR ERROR! Cache already locked!",  a4,  a5,  a6,  a7,  a8,  v40);
  return 0LL;
}

BOOL SameNameRecordAnswersQuestion( unsigned __int8 *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = *((void *)a1 + 3);
  if ((unint64_t)(v9 + 5) <= 3 && v9 != -4)
  {
    LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "SameNameRecordAnswersQuestion: ERROR!! called with LocalOnly ResourceRecord %p, Question %p",  a4,  a5,  a6,  a7,  a8,  v9);
    return 0LL;
  }

  if (*(_BYTE *)(a3 + 334) && (!*(_BYTE *)(a3 + 625) || *((_WORD *)a1 + 2) != 5)) {
    return 0LL;
  }
  if (v9)
  {
    uint64_t v13 = *(void *)(a3 + 136);
    BOOL v14 = v13 == -2 || v13 == 0;
    if (!v14 && v9 != v13) {
      return 0LL;
    }
  }

  uint64_t v16 = *(void *)(a3 + 80);
  if (v16 && (*(_WORD *)(v16 + 276) & 0x4000) != 0)
  {
    uint64_t v19 = *((void *)a1 + 6);
    if (v19) {
      uint64_t v19 = *(void *)(v19 + 24);
    }
  }

  else
  {
    uint64_t v17 = *((void *)a1 + 6);
    BOOL v18 = (!v17 || !*(void *)(v17 + 24)) && v9 != 0;
    if (v18 | a2)
    {
      if (v18 && *(_WORD *)(a3 + 320)) {
        return 0LL;
      }
      goto LABEL_36;
    }

    if (!*(_WORD *)(a3 + 320)) {
      return 0LL;
    }
    if (v17) {
      uint64_t v19 = *(void *)(v17 + 24);
    }
    else {
      uint64_t v19 = 0LL;
    }
  }

  if (v19 != v16) {
    return 0LL;
  }
LABEL_36:
  if (*((_WORD *)a1 + 2) == 5 && *a1 == 240 && *(_WORD *)(a3 + 322) != 5) {
    return 0LL;
  }
  uint64_t v20 = *(void *)(a3 + 144);
  if (v20) {
    unsigned int v21 = *(unsigned __int8 *)(v20 + 24);
  }
  else {
    unsigned int v21 = 0;
  }
  if (v20) {
    uint64_t v22 = v21 | 2;
  }
  else {
    uint64_t v22 = v21;
  }
  BOOL result = RRTypeAnswersQuestionType((uint64_t)a1, *(unsigned __int16 *)(a3 + 322), v22, a4, a5, a6, a7, a8);
  if (result)
  {
    int v23 = *(unsigned __int16 *)(a3 + 324);
    if (*((unsigned __int16 *)a1 + 3) == v23 || v23 == 255)
    {
      uint64_t v24 = *((void *)a1 + 3);
      if (!v24 || v24 == *(void *)(a3 + 136) || v24 != AWDLInterfaceID && v24 != WiFiAwareInterfaceID) {
        return 1LL;
      }
      if ((*(_BYTE *)(a3 + 306) & 0x10) != 0) {
        return 1LL;
      }
    }

    return 0LL;
  }

  return result;
}

void CheckCacheExpiration( uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9)
{
  if (*(_BYTE *)(a1 + 56))
  {
    LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "CheckCacheExpiration ERROR! Cache already locked!",  a4,  a5,  a6,  a7,  a8,  a9);
    return;
  }

  unsigned int v12 = (uint64_t *)(a3 + 16);
  uint64_t v11 = *(void *)(a3 + 16);
  *(_BYTE *)(a1 + 56) = 1;
  if (v11)
  {
    uint64_t v13 = (int *)(a1 + 4LL * a2 + 4272);
    while (1)
    {
      if (*(_BYTE *)(v11 + 109)) {
        int v14 = dword_100158BF8 + 939524096;
      }
      else {
        int v14 = *(_DWORD *)(v11 + 80) + 1000 * *(_DWORD *)(v11 + 16);
      }
      int v15 = *(_DWORD *)(a1 + 64);
      if (v15 - v14 < 0)
      {
        int v17 = *(_DWORD *)(v11 + 84);
        if (v17 && v17 - v15 > 0)
        {
          int v14 = *(_DWORD *)(v11 + 84);
        }

        else
        {
          if (v17) {
            CacheRecordDeferredAdd((void *)a1, v11, a3, a4, a5, a6, a7, a8);
          }
          if (*(void *)(v11 + 96) && *(unsigned __int8 *)(v11 + 108) <= 3u)
          {
            int v18 = *(_DWORD *)(a1 + 64);
            int v19 = *(_DWORD *)(v11 + 88);
            if (v18 - v19 < 0)
            {
              uint64_t v52 = 1374389535000LL * *(_DWORD *)(v11 + 16);
              int v18 = (v52 >> 36) + ((unint64_t)v52 >> 63);
            }

            else
            {
              *(_DWORD *)(a1 + 92) = v18;
              int v19 = 939524096;
            }

            int v14 = v18 + v19;
          }
        }

        goto LABEL_83;
      }

      uint64_t v16 = *(void *)(v11 + 96);
      if (v16) {
        break;
      }
LABEL_68:
      int v50 = *(unsigned __int8 *)(v11 + 10);
      if (*(_BYTE *)(v11 + 10) && *(_DWORD *)(v11 + 16))
      {
        v14 += 604800000;
        if (v50 == 1)
        {
          *(_BYTE *)(v11 + 10) = 2;
          if (*(_DWORD *)(v11 + 84))
          {
            *(_DWORD *)(v11 + 84) = 0;
            uint64_t v51 = (os_log_s *)mDNSLogCategory_Default;
            if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
            {
              if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
                goto LABEL_80;
              }
            }

            else
            {
              uint64_t v51 = (os_log_s *)mDNSLogCategory_Default_redacted;
              if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
              {
LABEL_80:
                *(_WORD *)buf = 0;
                _os_log_impl( (void *)&_mh_execute_header,  v51,  OS_LOG_TYPE_DEFAULT,  "CheckCacheExpiration: Resetting DelayDelivery for new ghost",  buf,  2u);
              }
            }
          }

LABEL_83:
          if (*v13 - v14 >= 1) {
            *uint64_t v13 = v14;
          }
          unsigned int v12 = (uint64_t *)v11;
          goto LABEL_86;
        }

        if (v50 != 2 || *(_DWORD *)(a1 + 64) - v14 < 0) {
          goto LABEL_83;
        }
      }

      uint64_t *v12 = *(void *)v11;
      ReleaseCacheRecord(a1, v11);
LABEL_86:
      uint64_t v11 = *v12;
      if (!*v12) {
        goto LABEL_87;
      }
    }

    if (*(_WORD *)(v16 + 320))
    {
      if (!*(_BYTE *)(v16 + 612)) {
        goto LABEL_23;
      }
    }

    else if ((*(_BYTE *)(v11 + 8) & 0x10) != 0)
    {
LABEL_23:
      if (*(int *)(v16 + 212) >= 1 && !*(void *)(v16 + 40))
      {
        *(_DWORD *)(v16 + 208) = v15 - 334;
        *(_DWORD *)(v16 + 212) = 334;
        SetNextQueryTime(a1, v16);
      }
    }

    uint64_t v20 = *(void *)(a1 + 216);
    if (v20)
    {
      unsigned int v21 = (os_log_s *)mDNSLogCategory_Default;
      int v22 = v20 + 356;
      DNSTypeName(*(unsigned __int16 *)(v20 + 322));
      LogMsgWithLevel( v21,  OS_LOG_TYPE_DEFAULT,  "CacheRecordRmv ERROR m->CurrentQuestion already set: %##s (%s)",  v23,  v24,  v25,  v26,  v27,  v22);
    }

    uint64_t v28 = *(void *)(a1 + 200);
    *(void *)(a1 + 216) = v28;
    if (v28)
    {
      while (1)
      {
        if (v28 == *(void *)(a1 + 208)) {
          goto LABEL_67;
        }
        if (!*(_BYTE *)(v28 + 334) && RecordAnswersQuestion(v11 + 8, 0, v28, a4, a5, a6, a7, a8))
        {
          *(void *)(v28 + 16) = 0LL;
          *(void *)(v28 + 24) = 0LL;
          unsigned int v29 = *(_DWORD *)(v28 + 228);
          if (v29)
          {
            *(_DWORD *)(v28 + 228) = --v29;
            if ((*(_BYTE *)(v11 + 8) & 0x10) != 0) {
              --*(_DWORD *)(v28 + 236);
            }
          }

          if (!*(_WORD *)(v28 + 320))
          {
            if (*(_BYTE *)(v28 + 331))
            {
              if (v29 < *(unsigned __int8 *)(v28 + 331))
              {
                *(_DWORD *)(v28 + 212) = 334;
                *(_DWORD *)(v28 + 208) = *(_DWORD *)(a1 + 64) - 334;
                SetNextQueryTime(a1, v28);
                if (mDNS_LoggingEnabled == 1)
                {
                  unsigned int v37 = (os_log_s *)mDNSLogCategory_Default;
                  int v38 = DNSTypeName(*(unsigned __int16 *)(v28 + 322));
                  LogMsgWithLevel( v37,  OS_LOG_TYPE_DEFAULT,  "CacheRecordRmv: (%s) %##s dropped below threshold of %d answers",  v39,  v40,  v41,  v42,  v43,  v38);
                }
              }
            }
          }

          if (**(_WORD **)(v11 + 48)) {
            goto LABEL_39;
          }
          uint64_t v44 = *(void *)(v11 + 64);
          if (v44)
          {
            int v45 = *(_DWORD *)(v44 + 32);
          }
        }

        int v81 = *(void *)(a1 + 12648);
      }

      while (v81);
      if (v342 || !v343)
      {
        if (!v342) {
          goto LABEL_350;
        }
      }

      else
      {
        *(void *)(v343 + 200) = a8;
        *(_DWORD *)(a1 + 100) = *(_DWORD *)(a1 + 64);
      }

        int v46 = v30;
      }

      else
      {
        int v46 = 0;
      }
    }

    else
    {
      uint64_t v26 = (os_log_s *)mDNSLogCategory_Default_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
      {
LABEL_87:
        --*(_DWORD *)(a1 + 228);
        if ((*(_BYTE *)(v24 + 8) & 0x10) != 0) {
          --*(_DWORD *)(a1 + 236);
        }
        AnswerCurrentQuestionWithResourceRecord((uint64_t)&mDNSStorage, v24, 0LL);
        if (qword_100158C90 != a1) {
          goto LABEL_104;
        }
        goto LABEL_103;
      }

      uint64_t v28 = *(void *)(v24 + 40);
      if (v28)
      {
        uint64_t v39 = *(_BYTE **)(v24 + 40);
        if (v28 == -256) {
          goto LABEL_58;
        }
LABEL_55:
        uint64_t v40 = 257;
        if ((unint64_t)v39 < v28 + 256 && v39)
        {
          while (1)
          {
            uint64_t v41 = *v39;
            if (v41 > 0x3F)
            {
LABEL_77:
              uint64_t v40 = 257;
              goto LABEL_85;
            }

            if (!*v39) {
              break;
            }
            v39 += v41 + 1;
            if (v28 != -256) {
              goto LABEL_55;
            }
LABEL_58:
            if (!v39) {
              goto LABEL_77;
            }
          }

          uint64_t v40 = (_WORD)v39 - v28 + 1;
        }

        uint64_t v41 = *(void *)v41;
        if (!v41) {
          goto LABEL_87;
        }
      }
    }

    uint64_t v61 = 1;
    goto LABEL_84;
  }

  xarray = 0LL;
  uint64_t v61 = 0;
LABEL_84:
  uint64_t v62 = v3[3];
  if (v62)
  {
    v3[3] = 0LL;
    do
    {
      int v63 = *(void *)(v62 + 16);
      _dx_release((char *)v62);
      uint64_t v62 = v63;
    }

    while (v63);
  }

  if ((v61 & 1) == 0) {
    _dx_request_set_error(v1, v4);
  }
  _Block_object_dispose(&v71, 8);
  return xarray;
}

LABEL_39:
      if (!*(_DWORD *)(v28 + 228) && !*(_WORD *)(v28 + 320))
      {
        if (mDNS_LoggingEnabled == 1)
        {
          int v30 = (os_log_s *)mDNSLogCategory_Default;
          DNSTypeName(*(unsigned __int16 *)(v28 + 322));
          LogMsgWithLevel( v30,  OS_LOG_TYPE_DEFAULT,  "CacheRecordRmv: Last answer for %##s (%s) expired from cache; will reconfirm antecedents",
            v31,
            v32,
            v33,
            v34,
            v35,
            v28 + 356);
        }

        ReconfirmAntecedents(a1, (_BYTE *)(v28 + 356), *(_DWORD *)(v28 + 200), *(void *)(v11 + 32), 0);
      }

      AnswerCurrentQuestionWithResourceRecord(a1, v11, 0LL);
      goto LABEL_45;
    }

        while (1)
        {
          int v17 = *(void *)v17;
          if (!v17) {
            goto LABEL_21;
          }
          if (*(_BYTE *)(v17 + 16)) {
            goto LABEL_23;
          }
        }
      }

  if (!*(_BYTE *)(v13 + 6375)
    || *(_BYTE *)(v13 + 6377)
    || *(_BYTE *)(v13 + 6382)
    || mDNSPlatformInterfaceIsD2D(*(void *)(v13 + 6256), v6, v7, v8, v9, v10, v11, v12))
  {
    goto LABEL_64;
  }

  if (!*(_BYTE *)(v13 + 6376))
  {
    uint64_t v33 = v13 + 6310;
    mDNS_snprintf(v39);
    uint64_t v34 = mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_20;
      }
      *(_DWORD *)buf = 136446210;
      int v38 = v33;
      unint64_t v5 = "mDNS_UpdateAllowSleep: Sleep disabled because %{public}s does not support NetWake";
    }

    else
    {
      uint64_t v34 = mDNSLogCategory_Default_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_20;
      }
      *(_DWORD *)buf = 136446210;
      int v38 = v33;
      unint64_t v5 = "mDNS_UpdateAllowSleep: Sleep disabled because %{public}s does not support NetWake";
    }

    goto LABEL_85;
  }

  SPSInCache1 = FindSPSInCache1(a1, v13 + 24, 0LL, 0LL);
  if (!SPSInCache1)
  {
    uint64_t v35 = v13 + 6310;
    mDNS_snprintf(v39);
    uint64_t v34 = mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446210;
        int v38 = v35;
        unint64_t v5 = "mDNS_UpdateAllowSleep: Sleep disabled because %{public}s has no sleep proxy server";
        goto LABEL_85;
      }

      goto LABEL_20;
    }

    uint64_t v34 = mDNSLogCategory_Default_redacted;
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_20;
    }
    *(_DWORD *)buf = 136446210;
    int v38 = v35;
    unint64_t v5 = "mDNS_UpdateAllowSleep: Sleep disabled because %{public}s has no sleep proxy server";
LABEL_85:
    uint64_t v16 = (os_log_s *)v34;
    int v17 = 12;
LABEL_19:
    _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, v5, buf, v17);
    goto LABEL_20;
  }

  if (!*v2) {
    goto LABEL_64;
  }
  uint64_t v26 = 1000000;
  uint64_t v27 = *(unsigned __int8 **)(SPSInCache1 + 48);
  uint64_t v28 = v27[4];
  if (v28 >= 5)
  {
    unsigned int v29 = v27[5];
    if ((v29 - 48) <= 9)
    {
      int v30 = v27[6];
      if ((v30 - 48) <= 9)
      {
        uint64_t v31 = v27[8];
        if ((v31 - 48) <= 9)
        {
          uint64_t v32 = v27[9];
          if ((v32 - 48) <= 9
            && (v28 < 0xB
             || v32 != 57
             || v31 != 57
             || v27[7] != 45
             || v27[10] != 45
             || v27[11] != 57
             || v27[12] != 57
             || v27[13] != 45
             || v27[14] != 57
             || v27[15] != 57))
          {
            uint64_t v26 = 10000 * v30 + 100000 * v29 + 1000 * v31 + 100 * v32 + 10 * v27[11] + v27[12] - 5333328;
          }
        }
      }
    }
  }

  if (v26 < 10000 * *v2 + 100 * v2[1] + v2[2])
  {
LABEL_64:
    while (1)
    {
      uint64_t v13 = *(void *)v13;
      if (!v13) {
        goto LABEL_11;
      }
      if (*(_BYTE *)(v13 + 16)) {
        goto LABEL_39;
      }
    }
  }

  uint64_t v36 = v13 + 6310;
  mDNS_snprintf(v39);
  uint64_t v34 = mDNSLogCategory_Default;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
  {
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136446210;
      int v38 = v36;
      unint64_t v5 = "mDNS_UpdateAllowSleep: Sleep disabled because %{public}s has no sleep proxy server with a better metric";
      goto LABEL_85;
    }
  }

  else
  {
    uint64_t v34 = mDNSLogCategory_Default_redacted;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136446210;
      int v38 = v36;
      unint64_t v5 = "mDNS_UpdateAllowSleep: Sleep disabled because %{public}s has no sleep proxy server with a better metric";
      goto LABEL_85;
    }
  }

    if (++v14 >= v13) {
      goto LABEL_40;
    }
  }

  int v22 = (int *)(v17 + 24);
  uint64_t v23 = (uint8_t *)(v17 + 8);
  memset(v43, 0, sizeof(v43));
  int v45 = 0;
  uint64_t v44 = 0LL;
  if (*(unsigned __int8 *)(v17 + 8) == 254 && (*(_BYTE *)(v17 + 9) & 0xC0) == 0x80)
  {
    uint64_t v24 = *(_DWORD *)(v9 + 64);
    if (v24)
    {
      if (*v22 != v24)
      {
        *(_OWORD *)uint64_t v43 = *(_OWORD *)v17;
        uint64_t v44 = *(void *)(v17 + 16);
        int v45 = v24;
        if (_mdns_dns_service_log_s_once != -1) {
          dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_62);
        }
        uint64_t v25 = (os_log_s *)_mdns_dns_service_log_s_log;
        uint64_t v26 = os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_DEFAULT);
        uint64_t v23 = &v43[8];
        int v22 = &v45;
        if (v26)
        {
          uint64_t v27 = *(_DWORD *)(v17 + 24);
          *(_DWORD *)buf = 68158466;
          *(_DWORD *)&uint8_t buf[4] = 28;
          *(_WORD *)&buf[8] = 2096;
          *(void *)&buf[10] = v17;
          *(_WORD *)&buf[18] = 1024;
          *(_DWORD *)&buf[20] = v27;
          *(_WORD *)&buf[24] = 1024;
          *(_DWORD *)&buf[26] = v24;
          _os_log_impl( (void *)&_mh_execute_header,  v25,  OS_LOG_TYPE_DEFAULT,  "Corrected scope ID of link-local server address %{network:sockaddr}.*P from %u to %u",  buf,  0x1Eu);
          uint64_t v23 = &v43[8];
          int v22 = &v45;
        }
      }
    }
  }

  uint64_t v28 = *v22;
  unsigned int v29 = _mdns_address_new();
  if (v29)
  {
    unsigned int v21 = (void *)v29;
    *(_WORD *)(v29 + 24) = 7708;
    *(_WORD *)(v29 + 26) = v16;
    *(_OWORD *)(v29 + 32) = *(_OWORD *)v23;
    *(_DWORD *)(v29 + 48) = v28;
LABEL_37:
    appended = _mdns_dns_service_append_address(v11, v21);
    os_release(v21);
    BOOL result = appended;
    if (appended) {
      goto LABEL_68;
    }
    uint64_t v13 = *(_DWORD *)(v9 + 8);
    goto LABEL_39;
  }

    unsigned int v29 = *(unsigned __int16 *)(a3 + 4);
    if (v29 != 1)
    {
      if (v29 != 28) {
        return;
      }
LABEL_44:
      uint64_t v26 = 16;
      goto LABEL_45;
    }

                    uint64_t v33 = *(void *)v33;
                  }

                  while (v33);
                }
              }
            }

            if (*(unsigned __int16 *)(v28 + 22) != *(unsigned __int16 *)(v31 + 6304)
              || *(unsigned __int16 *)(v28 + 24) != *(unsigned __int16 *)(v31 + 6306)
              || *(unsigned __int16 *)(v28 + 26) != *(unsigned __int16 *)(v31 + 6308))
            {
              if (*(_DWORD *)(v28 + 28))
              {
                uint64_t v53 = *(void *)(v27 + 12624);
                if (v53)
                {
                  unsigned int v54 = v31 + 6310;
                  __int16 v55 = v28 + 38;
                  int v108 = (_BYTE *)(v27 + 46976);
                  while (1)
                  {
                    if (*(void *)(v53 + 32) != v29
                      || *(_BYTE *)(v53 + 8) == 1
                      || *(_DWORD *)(v53 + 144) != 4
                      || *(_DWORD *)(v53 + 148) != *(_DWORD *)(v28 + 28)
                      || *(unsigned __int8 *)(v53 + 189) > 0x13u)
                    {
                      goto LABEL_59;
                    }

                    if (!*(_WORD *)(v53 + 126) && !*(_WORD *)(v53 + 128) && !*(_WORD *)(v53 + 130)) {
                      break;
                    }
                    uint64_t v110 = v55;
                    RestartARPProbing((_DWORD *)v27, v53);
                    if (*(unsigned __int16 *)(v28 + 22) == *(unsigned __int16 *)(v53 + 132)
                      && *(unsigned __int16 *)(v28 + 24) == *(unsigned __int16 *)(v53 + 134)
                      && *(unsigned __int16 *)(v28 + 26) == *(unsigned __int16 *)(v53 + 136))
                    {
                      int v106 = (os_log_s *)mDNSLogCategory_Default;
                      GetRRDisplayString_rdb( (unsigned __int8 *)(v53 + 8),  (unsigned __int16 *)(*(void *)(v53 + 48) + 4LL),  v108);
                      int v56 = v110;
                      LogMsgWithLevel( v106,  OS_LOG_TYPE_DEFAULT,  "%-7s ARP %s from owner %.6a %.4a for %-15.4a -- re-starting probing for %s",  v57,  v58,  v59,  v60,  v61,  v54);
LABEL_62:
                      __int16 v55 = v56;
                      goto LABEL_59;
                    }

                    CFRange v105 = (os_log_s *)mDNSLogCategory_Default;
                    GetRRDisplayString_rdb( (unsigned __int8 *)(v53 + 8),  (unsigned __int16 *)(*(void *)(v53 + 48) + 4LL),  v108);
                    LogMsgWithLevel( v105,  OS_LOG_TYPE_DEFAULT,  "%-7s Conflicting ARP from %.6a %.4a for %.4a -- waking H-MAC %.6a I-MAC %.6a %s",  v62,  v63,  v64,  v65,  v66,  v54);
                    ScheduleWakeup( v27,  *(void *)(v53 + 32),  (unsigned __int16 *)(v53 + 126),  v67,  v68,  v69,  v70,  v71,  v102);
                    __int16 v55 = v110;
LABEL_59:
                    uint64_t v53 = *(void *)v53;
                    if (!v53) {
                      goto LABEL_93;
                    }
                  }

                  __int16 v111 = (os_log_s *)mDNSLogCategory_Default;
                  int v56 = v55;
                  GetRRDisplayString_rdb( (unsigned __int8 *)(v53 + 8),  (unsigned __int16 *)(*(void *)(v53 + 48) + 4LL),  v108);
                  LogMsgWithLevel( v111,  OS_LOG_TYPE_DEFAULT,  "%-7s ARP from %.6a %.4a for %.4a -- Invalid H-MAC %.6a I-MAC %.6a %s",  v72,  v73,  v74,  v75,  v76,  v54);
                  goto LABEL_62;
                }
              }
            }

  uint64_t v20 = v18;
  if (a2) {
LABEL_40:
  }
    *a2 = v20;
  return v9;
}

LABEL_67:
    *(void *)(a1 + 216) = 0LL;
    --*(_DWORD *)(a1 + 260);
    goto LABEL_68;
  }

  BOOL result = 4294960568LL;
  appended = -6728;
LABEL_68:
  if (v11)
  {
LABEL_69:
    os_release((void *)v11);
    return appended;
  }

  return result;
}

    uint64_t v66 = DNSTypeName(WORD2(v73[0]));
    *(_DWORD *)buf = 67110147;
    int v77 = a6;
    int v78 = 2160;
    int v79 = 1752392040LL;
    int v80 = 1040;
    int v81 = v65;
    uint64_t v82 = 2101;
    uint64_t v83 = v38;
    uint64_t v84 = 2082;
    uint64_t v85 = v66;
    _os_log_impl( (void *)&_mh_execute_header,  v37,  OS_LOG_TYPE_ERROR,  "[R%u] update_record: SetRData failed for %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%{public}s)",  buf,  0x2Cu);
    goto LABEL_68;
  }

  RDLength = GetRDLength((uint64_t)v73, 0, v19, v20, v21, v22, v23, v24);
  uint64_t v26 = RDLength;
  if (*(_WORD *)(a1 + 12) == 16 && !RDLength)
  {
    *((_BYTE *)v17 + 4) = 0;
    uint64_t v26 = 1;
  }

  if (a5) {
    *(void *)(a1 + 608) = a5;
  }
  if (!ValidateRData(*(unsigned __int16 *)(a1 + 12), v26, v17))
  {
    uint64_t v41 = (os_log_s *)mDNSLogCategory_Default;
    GetRRDisplayString_rdb((unsigned __int8 *)(a1 + 8), v17 + 2, word_100164338);
    LogMsgWithLevel( v41,  OS_LOG_TYPE_DEFAULT,  "Attempt to update record with invalid rdata: %s",  v42,  v43,  v44,  v45,  v46,  (int)word_100164338);
    uint64_t updated = 4294901747LL;
LABEL_38:
    uint64_t v47 = (os_log_s *)mDNSLogCategory_Default;
    GetRRDisplayString_rdb( (unsigned __int8 *)(a1 + 8),  (unsigned __int16 *)(*(void *)(a1 + 48) + 4LL),  word_100164338);
    LogMsgWithLevel(v47, OS_LOG_TYPE_DEFAULT, "update_record: Error %d for %s", v48, v49, v50, v51, v52, updated);
    goto LABEL_68;
  }

  mDNS_Lock_((unsigned int *)mDNSStorage, (uint64_t)"mDNS_Update", 16332);
  if (!a4) {
    a4 = *(_DWORD *)(a1 + 16);
  }
  uint64_t v32 = *(void *)(a1 + 304);
  if (v32)
  {
    *(void *)(a1 + 304) = 0LL;
    uint64_t v33 = *(void (**)(uint64_t *, uint64_t))(a1 + 320);
    if (v33) {
      v33(mDNSStorage, a1);
    }
  }

  *(void *)(a1 + 304) = v17;
  *(_WORD *)(a1 + 312) = v26;
  *(void *)(a1 + 3memset(v45, 0, 20) = update_callback;
  uint64_t v34 = *(_DWORD *)(a1 + 172) & 0xFFFFFFFE;
  if (v34 == 4) {
    goto LABEL_24;
  }
  if (!*(void *)(a1 + 32) && !*(_BYTE *)(a1 + 122))
  {
    if (IsLocalDomain(*(_BYTE **)(a1 + 40)))
    {
      uint64_t v34 = *(_DWORD *)(a1 + 172) & 0xFFFFFFFE;
      goto LABEL_22;
    }

    uint64_t updated = uDNS_UpdateRecord(a1, v35, v32, v27, v28, v29, v30, v31);
    if (!(_DWORD)updated)
    {
      mDNS_Unlock_((uint64_t)mDNSStorage, (uint64_t)"mDNS_Update", 16356);
      return updated;
    }

    *(void *)(a1 + 304) = 0LL;
    *(_WORD *)(a1 + 312) = 0;
    mDNS_Unlock_((uint64_t)mDNSStorage, (uint64_t)"mDNS_Update", 16356);
    goto LABEL_38;
  }

      uint64_t v47 = 958;
LABEL_68:
      mDNS_Unlock_((uint64_t)mDNSStorage, (uint64_t)"_Querier_HandleQuerierResponse", v47);
    }
  }

        *(_WORD *)(v34 + memset(v45, 0, 20) = v45;
        *(_BYTE *)(*(void *)(v34 + 48) + 4LL) = 0;
        uint64_t v47 = (char *)a3;
        if (a3 == -256LL)
        {
LABEL_69:
          while (v47)
          {
            unsigned int v48 = *v47;
            if (!*v47)
            {
              int v49 = (_BYTE *)(*(void *)(v34 + 48) + 4LL);
              memcpy(v49, (const void *)a3, (unsigned __int16)((_WORD)v47 - a3 + 1));
              goto LABEL_76;
            }

            v47 += v48 + 1;
            if (a3 != -256LL) {
              goto LABEL_68;
            }
          }
        }

        else
        {
LABEL_68:
          if (v47 < v43) {
            goto LABEL_69;
          }
        }

        int v49 = (_BYTE *)(*(void *)(v34 + 48) + 4LL);
LABEL_75:
        *int v49 = 0;
      }

  uint64_t v36 = 0LL;
  DomainName = -6762;
LABEL_66:
  a4 = v39;
LABEL_58:
  if (a4) {
    *(_DWORD *)a4 = DomainName;
  }
  if (v20) {
    free(v20);
  }
  return v36;
}

  QueryRecordOpStop(a1);
  return RecordOpStartQuestion;
}

LABEL_87:
  *(void *)(a3 + 24) = v12;
  *(_BYTE *)(a1 + 56) = 0;
}

void CacheRecordDeferredAdd( void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  *(_DWORD *)(a2 + 84) = 0;
  uint64_t v10 = a1[27];
  if (v10)
  {
    uint64_t v11 = (os_log_s *)mDNSLogCategory_Default;
    int v12 = v10 + 356;
    DNSTypeName(*(unsigned __int16 *)(v10 + 322));
    LogMsgWithLevel( v11,  OS_LOG_TYPE_DEFAULT,  "CacheRecordDeferredAdd ERROR m->CurrentQuestion already set: %##s (%s)",  v13,  v14,  v15,  v16,  v17,  v12);
  }

  uint64_t v18 = a1[25];
  a1[27] = v18;
  if (v18)
  {
    do
    {
      if (v18 == a1[26]) {
        break;
      }
      if (RecordAnswersQuestion(a2 + 8, 0, v18, a4, a5, a6, a7, a8)) {
        AnswerCurrentQuestionWithResourceRecord((uint64_t)a1, a2, 1LL);
      }
      uint64_t v19 = a1[27];
      if (v19 == v18)
      {
        uint64_t v19 = *(void *)(v18 + 8);
        a1[27] = v19;
      }

      uint64_t v18 = v19;
    }

    while (v19);
  }

  a1[27] = 0LL;
}

void AnswerCurrentQuestionWithResourceRecord(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(void *)(a1 + 216);
  uint64_t v7 = (unsigned __int8 *)(a2 + 8);
  BOOL v8 = FollowCNAME(v6, (unsigned __int8 *)(a2 + 8), a3);
  if (DNSQuestionNeedsSensitiveLogging(v6))
  {
    if (*(_BYTE *)(a2 + 129)) {
      goto LABEL_7;
    }
    char v15 = 1;
  }

  else
  {
    char v15 = 2;
  }

  *(_BYTE *)(a2 + 129) = v15;
  uint64_t v16 = *(void *)(a2 + 120);
  if (v16) {
    *(_BYTE *)(v16 + 129) = v15;
  }
LABEL_7:
  if (*(_BYTE *)(v6 + 335))
  {
    if (mDNS_LoggingEnabled == 1)
    {
      uint64_t v17 = (os_log_s *)mDNSLogCategory_Default;
      DNSTypeName(*(unsigned __int16 *)(v6 + 322));
      GetRRDisplayString_rdb(v7, (unsigned __int16 *)(*(void *)(a2 + 48) + 4LL), (_BYTE *)(a1 + 46976));
      LogMsgWithLevel( v17,  OS_LOG_TYPE_DEFAULT,  "AnswerCurrentQuestionWithResourceRecord: Question %p %##s (%s) not answering with record %s due to LOAddressAnswers %d",  v18,  v19,  v20,  v21,  v22,  v6);
    }

    return;
  }

  if ((_DWORD)a3 == 4
    || !*(_BYTE *)(v6 + 334)
    || (*(_BYTE *)(v6 + 625) ? (BOOL v23 = !v8) : (BOOL v23 = 1),
        !v23 || *(_BYTE *)(v6 + 617) && *v7 == 240 && *(_DWORD *)(a1 + 64) - *(_DWORD *)(v6 + 240) >= 0))
  {
    if ((_DWORD)a3 == 1 && *(_WORD *)(v6 + 320))
    {
      if (!*(_BYTE *)(a2 + 10)
        && *(unsigned __int8 *)(v6 + 626) - 1 <= 1
        && *v7 != 240
        && !*(void *)(v6 + 144)
        && !*(void *)(a2 + 64))
      {
        *(_BYTE *)(a2 + 10) = 1;
      }
    }

    else if ((_DWORD)a3 != 1)
    {
      if ((_DWORD)a3 != 2 || *(_BYTE *)(v6 + 332)) {
        goto LABEL_45;
      }
      goto LABEL_40;
    }

    if (!*(void *)(v6 + 40))
    {
      uint64_t v24 = *(void *)(a2 + 96);
      if (v24 != v6 && *(_BYTE *)(a2 + 10) != 2)
      {
        if (!v24)
        {
          ++*(_DWORD *)(a1 + 260);
          AdjustUnansweredQueries(a1, a2);
        }

        *(void *)(a2 + 96) = v6;
        SetNextCacheCheckTimeForRecord(a1, a2);
      }
    }

    if (!*(_BYTE *)(v6 + 613) && (*v7 & 0x10) == 0)
    {
LABEL_45:
      if (*(_DWORD *)(a2 + 84)) {
        return;
      }
      int v26 = *v7;
      if (v26 == 240)
      {
        __int128 v71 = 0u;
        __int128 v72 = 0u;
        __int128 v69 = 0u;
        __int128 v70 = 0u;
        __int128 v67 = 0u;
        __int128 v68 = 0u;
        __int128 v65 = 0u;
        __int128 v66 = 0u;
        __int128 v63 = 0u;
        __int128 v64 = 0u;
        __int128 v61 = 0u;
        __int128 v62 = 0u;
        __int128 v59 = 0u;
        __int128 v60 = 0u;
        __int128 __src = 0u;
        __int128 v58 = 0u;
        p_src = (uint64_t *)&__src;
        if (PerformNextPunycodeConversion(v6, (char *)&__src))
        {
          uint64_t v28 = *(void **)(v6 + 72);
          __int16 v29 = *(_WORD *)(v6 + 320);
          *(void *)(v6 + 72) = 0LL;
          mDNS_StopQuery_internal(a1, v6);
          while (p_src < &v73)
          {
            if (!p_src) {
              break;
            }
            uint64_t v30 = *(unsigned __int8 *)p_src;
            if (!*(_BYTE *)p_src)
            {
              if ((unsigned __int16)((_WORD)p_src - (unsigned __int16)&__src + 1) <= 0x100u)
              {
                memcpy((void *)(v6 + 356), &__src, (unsigned __int16)((_WORD)p_src - (unsigned __int16)&__src + 1));
                goto LABEL_90;
              }

              break;
            }

            p_src = (uint64_t *)((char *)p_src + v30 + 1);
          }

          *(_BYTE *)(v6 + 356) = 0;
LABEL_90:
          *(_DWORD *)(v6 + 200) = DomainNameHashValue(v6 + 356);
          mDNS_StartQuery_internal(a1, v6);
          if (v28)
          {
            if (*(void *)(v6 + 40))
            {
              CloseSocketSet((uint64_t)v28);
              free(v28);
            }

            else
            {
              *(void *)(v6 + 72) = v28;
              *(_WORD *)(v6 + 3memset(v45, 0, 20) = v29;
            }
          }

          return;
        }

        int v26 = *v7;
      }

      unsigned int v31 = *(unsigned __int16 *)(v6 + 322);
      BOOL v32 = v31 != 47
         && *(_WORD *)(a2 + 12) == 47
         && RRAssertsExistence((uint64_t)v7, v31, v9, v10, v11, v12, v13, v14) == 0;
      if (v26 == 240 || v32)
      {
        if ((a3 - 1) >= 2)
        {
          if (!(_DWORD)a3)
          {
            uint64_t v33 = *(void *)(v6 + 144);
            if (!v33 || !*(_BYTE *)(v33 + 24)) {
              return;
            }
            goto LABEL_73;
          }
        }

        else if (!*(_BYTE *)(v6 + 615))
        {
          return;
        }
      }

      else if (!(_DWORD)a3)
      {
LABEL_73:
        if (*(void *)(v6 + 152) && (!v8 || *(_BYTE *)(v6 + 615) || *(_BYTE *)(v6 + 626) == 1))
        {
          unsigned int v34 = *(_DWORD *)(a1 + 48);
          unsigned int v35 = *(_DWORD *)(a1 + 52) + 1;
          *(_DWORD *)(a1 + 52) = v35;
          mDNS_VerifyLockState("Drop Lock", 0, v34, v35, (uint64_t)"AnswerCurrentQuestionWithResourceRecord", 5471);
          unsigned int v42 = *(unsigned __int16 *)(v6 + 322);
          if (v42 == 47
            || *(_WORD *)(a2 + 12) != 47
            || RRAssertsExistence((uint64_t)v7, v42, v36, v37, v38, v39, v40, v41))
          {
            (*(void (**)(uint64_t, uint64_t, unsigned __int8 *, uint64_t))(v6 + 152))(a1, v6, v7, a3);
          }

          else if (!*(_WORD *)(v6 + 320))
          {
            __int128 v69 = 0u;
            __int128 v70 = 0u;
            __int128 v67 = 0u;
            __int128 v68 = 0u;
            __int128 v65 = 0u;
            __int128 v66 = 0u;
            __int128 v63 = 0u;
            __int128 v64 = 0u;
            __int128 v61 = 0u;
            __int128 v62 = 0u;
            __int128 v59 = 0u;
            __int128 v60 = 0u;
            __int128 __src = 0u;
            __int128 v58 = 0u;
            MakeNegativeCacheRecordForQuestion(a1, (uint64_t)&__src, v6, *(void *)(a2 + 32));
            (*(void (**)(uint64_t, uint64_t, char *, uint64_t))(v6 + 152))(a1, v6, (char *)&__src + 8, a3);
          }

          mDNS_VerifyLockState( "Reclaim Lock",  0,  *(_DWORD *)(a1 + 48),  *(_DWORD *)(a1 + 52),  (uint64_t)"AnswerCurrentQuestionWithResourceRecord",  5497);
          --*(_DWORD *)(a1 + 52);
        }

        if (*(void *)(a1 + 216) == v6 && v8) {
          AnswerQuestionByFollowingCNAME(a1, v6, (uint64_t)v7);
        }
        return;
      }

      if (!*(void *)(v6 + 40) && !*(_WORD *)(v6 + 320))
      {
        if (!*(_BYTE *)(v6 + 268)) {
          *(_BYTE *)(v6 + 268) = 1;
        }
        uint64_t v44 = *(uint64_t **)(a1 + 12664);
        if (v44)
        {
          while (!*((_BYTE *)v44 + 16))
          {
            uint64_t v44 = (uint64_t *)*v44;
            if (!v44) {
              goto LABEL_73;
            }
          }

LABEL_102:
          uint64_t v45 = v44[1];
          if (v45 && v44[782] == *(void *)(a2 + 32))
          {
            if (*(_BYTE *)(v6 + 337))
            {
              int v46 = *(_DWORD *)(v6 + 264);
              if (v46)
              {
                int v47 = *(_DWORD *)(a1 + 64) - v46;
                if (v47 >= 1)
                {
                  unsigned int v48 = 1000 * (v47 % 0x3E8u) / 0x3E8 + 1000 * (v47 / 0x3E8u);
                  unsigned int v49 = v48 >> 3;
                  uint64_t v50 = 15LL;
                  if (v48 >> 5 >= 0x271) {
                    uint64_t v50 = 16LL;
                  }
                  uint64_t v51 = (unsigned __int16)v48 / 0x3E8u;
                  if (v49 > 0x752) {
                    uint64_t v51 = v50;
                  }
                  uint64_t v52 = v45 + 2 * v51;
                  int v55 = *(unsigned __int16 *)(v52 + 28);
                  uint64_t v53 = (_WORD *)(v52 + 28);
                  __int16 v54 = v55;
                  if (v55 != 0xFFFF) {
                    *uint64_t v53 = v54 + 1;
                  }
                }
              }
            }

            else
            {
              int v56 = *(_DWORD *)(v45 + 24);
              if (v56 != -1) {
                *(_DWORD *)(v45 + 24) = v56 + 1;
              }
            }
          }

          else
          {
            while (1)
            {
              uint64_t v44 = (uint64_t *)*v44;
              if (!v44) {
                break;
              }
              if (*((_BYTE *)v44 + 16)) {
                goto LABEL_102;
              }
            }
          }
        }
      }

      goto LABEL_73;
    }

    unsigned int v42 = *(void *)v42;
  }

  while (v42);
  uint64_t v83 = *(void *)(v44 + 12624);
  if (!v83) {
    goto LABEL_208;
  }
  do
  {
    if (*(void *)(v83 + 32) && *(void *)(v83 + 208)
      || (uint64_t v84 = *(_DWORD *)(v83 + 280), v84 <= v43)
      && *(_BYTE *)(v83 + 191)
      && (v84 >= 0 ? (uint64_t v85 = *(_DWORD *)(v83 + 280)) : (uint64_t v85 = v84 + 1),
          *v12 + (v85 >> 1) - (v84 + *(_DWORD *)(v83 + 284)) >= 0
       && !*(_DWORD *)(v83 + 144)
       && ResourceRecordIsValidAnswer(v83)))
    {
      *(void *)(v83 + 208) = -1LL;
    }

    uint64_t v83 = *(void *)v83;
  }

  while (v83);
  uint64_t v86 = *(uint64_t **)(a1 + 12624);
  if (!v86) {
    goto LABEL_208;
  }
  while (2)
  {
    if (!v86[26]) {
      goto LABEL_154;
    }
    if (*((_WORD *)v86 + 6) != 33) {
      goto LABEL_146;
    }
    uint64_t v87 = *(void *)(a1 + 12624);
    if (!v87) {
      goto LABEL_146;
    }
    while (2)
    {
      __int128 v88 = *(unsigned __int16 *)(v87 + 12);
      __int128 v89 = v88 == 28 || v88 == 1;
      if (v89
        && ResourceRecordIsValidAnswer(v87)
        && *((_DWORD *)v86 + 72) - *(_DWORD *)(v87 + 288) >= 0
        && *((_DWORD *)v86 + 7) == *(_DWORD *)(v87 + 24)
        && SameDomainNameBytes((_BYTE *)(v86[6] + 10), *(_BYTE **)(v87 + 40)))
      {
        __int128 v90 = v86[26];
        __int128 v91 = *(void *)(v87 + 32);
        if (v90 == -1) {
          goto LABEL_143;
        }
        if (v90 == v91)
        {
          __int128 v91 = v86[26];
LABEL_143:
          *(void *)(v87 + 216) = v91;
        }
      }

      uint64_t v87 = *(void *)v87;
      if (v87) {
        continue;
      }
      break;
    }

    if (v86[26])
    {
LABEL_146:
      if (*((_BYTE *)v86 + 8) == 8
        && *((_WORD *)v86 + 6) == 12
        && ResourceRecordIsValidAnswer(a1 + 11448)
        && SameDomainLabelPointer(v86[6] + 4, *(void *)(a1 + 11488)))
      {
        if (*(void *)(a1 + 11656)) {
          __int128 v92 = -1LL;
        }
        else {
          __int128 v92 = v86[26];
        }
        *(void *)(a1 + 11656) = v92;
      }
    }

                      int v77 = v27[3];
                      int v78 = v27[30].u8[4];
                      if (src)
                      {
                        if (v78 == 1)
                        {
                          if (_mdns_server_log_s_once != -1) {
                            dispatch_once(&_mdns_server_log_s_once, &__block_literal_global_16);
                          }
                          int v79 = _mdns_server_log_s_log;
                          if (!os_log_type_enabled((os_log_t)_mdns_server_log_s_log, OS_LOG_TYPE_DEFAULT)) {
                            goto LABEL_138;
                          }
                          int v80 = v27[6].i32[0];
                          int v81 = v27[26].i32[0];
                          uint64_t v82 = v27[26].i32[1];
                          uint64_t v83 = v27[27].i32[0];
                          uint64_t v84 = v27[13];
                          uint64_t v85 = v27[30].u8[3];
                          uint64_t v86 = *(int *)(*(void *)&v77 + 76LL);
                          *(_DWORD *)length = 67111683;
                          *(_DWORD *)&length[4] = v80;
                          *(_WORD *)&length[8] = 1024;
                          *(_DWORD *)&length[10] = v81;
                          *(_WORD *)&length[14] = 1024;
                          *(_DWORD *)&length[16] = v82;
                          *(_WORD *)&length[20] = 1024;
                          *(_DWORD *)&length[22] = v83;
                          *(_WORD *)&length[26] = 2160;
                          *(void *)&length[28] = 1752392040LL;
                          *(_WORD *)&length[36] = 2085;
                          *(int32x2_t *)uint64_t v155 = v84;
                          *(_WORD *)&v155[8] = 1024;
                          *(_DWORD *)unsigned int v156 = v85;
                          *(_WORD *)&v156[4] = 2048;
                          *(void *)&v156[6] = v86;
                          unsigned int v157 = 2082;
                          __int128 v158 = *(void *)&v77 + 84LL;
                          unint64_t v159 = 1042;
                          LODWORD(v160[0]) = 16;
                          WORD2(v160[0]) = 2098;
                          *(void *)((char *)v160 + 6) = src;
                          uint64_t v87 = "[R%u] getaddrinfo start -- flags: 0x%X, ifindex: %d, protocols: %u, hostname: %{sensitiv"
                                "e,mask.hash}s, options: %{mdns:gaiopts}X, client pid: %lld (%{public}s), delegator uuid:"
                                " %{public,uuid_t}.16P";
                        }

                        else
                        {
                          if (_mdns_server_log_s_once != -1) {
                            dispatch_once(&_mdns_server_log_s_once, &__block_literal_global_16);
                          }
                          int v79 = _mdns_server_log_s_log;
                          if (!os_log_type_enabled((os_log_t)_mdns_server_log_s_log, OS_LOG_TYPE_DEFAULT)) {
                            goto LABEL_138;
                          }
                          __int128 v96 = v27[6].i32[0];
                          __int128 v97 = v27[26].i32[0];
                          __int128 v98 = v27[26].i32[1];
                          __int128 v99 = v27[27].i32[0];
                          __int128 v100 = v27[13];
                          __int128 v101 = v27[30].u8[3];
                          CFRange v102 = *(int *)(*(void *)&v77 + 76LL);
                          *(_DWORD *)length = 67111683;
                          *(_DWORD *)&length[4] = v96;
                          *(_WORD *)&length[8] = 1024;
                          *(_DWORD *)&length[10] = v97;
                          *(_WORD *)&length[14] = 1024;
                          *(_DWORD *)&length[16] = v98;
                          *(_WORD *)&length[20] = 1024;
                          *(_DWORD *)&length[22] = v99;
                          *(_WORD *)&length[26] = 2160;
                          *(void *)&length[28] = 1752392040LL;
                          *(_WORD *)&length[36] = 2081;
                          *(int32x2_t *)uint64_t v155 = v100;
                          *(_WORD *)&v155[8] = 1024;
                          *(_DWORD *)unsigned int v156 = v101;
                          *(_WORD *)&v156[4] = 2048;
                          *(void *)&v156[6] = v102;
                          unsigned int v157 = 2082;
                          __int128 v158 = *(void *)&v77 + 84LL;
                          unint64_t v159 = 1042;
                          LODWORD(v160[0]) = 16;
                          WORD2(v160[0]) = 2098;
                          *(void *)((char *)v160 + 6) = src;
                          uint64_t v87 = "[R%u] getaddrinfo start -- flags: 0x%X, ifindex: %d, protocols: %u, hostname: %{private,"
                                "mask.hash}s, options: %{mdns:gaiopts}X, client pid: %lld (%{public}s), delegator uuid: %"
                                "{public,uuid_t}.16P";
                        }

                        CFRange v103 = (os_log_s *)v79;
                        CFRange v104 = 88;
                      }

                      else if (int64_limited)
                      {
                        v161[0] = 0LL;
                        v161[1] = 0LL;
                        mdns_system_pid_to_name(int64_limited, (uint64_t)v161);
                        if (v78 == 1)
                        {
                          if (_mdns_server_log_s_once != -1) {
                            dispatch_once(&_mdns_server_log_s_once, &__block_literal_global_16);
                          }
                          __int128 v88 = _mdns_server_log_s_log;
                          if (!os_log_type_enabled((os_log_t)_mdns_server_log_s_log, OS_LOG_TYPE_DEFAULT)) {
                            goto LABEL_138;
                          }
                          __int128 v89 = v27[6].i32[0];
                          __int128 v90 = v27[26].i32[0];
                          __int128 v91 = v27[26].i32[1];
                          __int128 v92 = v27[27].i32[0];
                          __int128 v93 = v27[13];
                          __int128 v94 = v27[30].u8[3];
                          __int128 v95 = *(int *)(*(void *)&v77 + 76LL);
                          *(_DWORD *)length = 67111683;
                          *(_DWORD *)&length[4] = v89;
                          *(_WORD *)&length[8] = 1024;
                          *(_DWORD *)&length[10] = v90;
                          *(_WORD *)&length[14] = 1024;
                          *(_DWORD *)&length[16] = v91;
                          *(_WORD *)&length[20] = 1024;
                          *(_DWORD *)&length[22] = v92;
                          *(_WORD *)&length[26] = 2160;
                          *(void *)&length[28] = 1752392040LL;
                          *(_WORD *)&length[36] = 2085;
                          *(int32x2_t *)uint64_t v155 = v93;
                          *(_WORD *)&v155[8] = 1024;
                          *(_DWORD *)unsigned int v156 = v94;
                          *(_WORD *)&v156[4] = 2048;
                          *(void *)&v156[6] = v95;
                          unsigned int v157 = 2082;
                          __int128 v158 = *(void *)&v77 + 84LL;
                          unint64_t v159 = 2048;
                          v160[0] = int64_limited;
                          LOWORD(v160[1]) = 2082;
                          *(void *)((char *)&v160[1] + 2) = v161;
                          uint64_t v87 = "[R%u] getaddrinfo start -- flags: 0x%X, ifindex: %d, protocols: %u, hostname: %{sensitiv"
                                "e,mask.hash}s, options: %{mdns:gaiopts}X, client pid: %lld (%{public}s), delegator pid: "
                                "%lld (%{public}s)";
                        }

                        else
                        {
                          if (_mdns_server_log_s_once != -1) {
                            dispatch_once(&_mdns_server_log_s_once, &__block_literal_global_16);
                          }
                          __int128 v88 = _mdns_server_log_s_log;
                          if (!os_log_type_enabled((os_log_t)_mdns_server_log_s_log, OS_LOG_TYPE_DEFAULT)) {
                            goto LABEL_138;
                          }
                          __int16 v113 = v27[6].i32[0];
                          uint64_t v114 = v27[26].i32[0];
                          uint64_t v115 = v27[26].i32[1];
                          __int128 v116 = v27[27].i32[0];
                          __int128 v117 = v27[13];
                          __int128 v118 = v27[30].u8[3];
                          __int128 v119 = *(int *)(*(void *)&v77 + 76LL);
                          *(_DWORD *)length = 67111683;
                          *(_DWORD *)&length[4] = v113;
                          *(_WORD *)&length[8] = 1024;
                          *(_DWORD *)&length[10] = v114;
                          *(_WORD *)&length[14] = 1024;
                          *(_DWORD *)&length[16] = v115;
                          *(_WORD *)&length[20] = 1024;
                          *(_DWORD *)&length[22] = v116;
                          *(_WORD *)&length[26] = 2160;
                          *(void *)&length[28] = 1752392040LL;
                          *(_WORD *)&length[36] = 2081;
                          *(int32x2_t *)uint64_t v155 = v117;
                          *(_WORD *)&v155[8] = 1024;
                          *(_DWORD *)unsigned int v156 = v118;
                          *(_WORD *)&v156[4] = 2048;
                          *(void *)&v156[6] = v119;
                          unsigned int v157 = 2082;
                          __int128 v158 = *(void *)&v77 + 84LL;
                          unint64_t v159 = 2048;
                          v160[0] = int64_limited;
                          LOWORD(v160[1]) = 2082;
                          *(void *)((char *)&v160[1] + 2) = v161;
                          uint64_t v87 = "[R%u] getaddrinfo start -- flags: 0x%X, ifindex: %d, protocols: %u, hostname: %{private,"
                                "mask.hash}s, options: %{mdns:gaiopts}X, client pid: %lld (%{public}s), delegator pid: %lld (%{public}s)";
                        }

                        CFRange v103 = (os_log_s *)v88;
                        CFRange v104 = 92;
                      }

                      else
                      {
                        if (v78 == 1)
                        {
                          if (_mdns_server_log_s_once != -1) {
                            dispatch_once(&_mdns_server_log_s_once, &__block_literal_global_16);
                          }
                          CFRange v105 = _mdns_server_log_s_log;
                          if (!os_log_type_enabled((os_log_t)_mdns_server_log_s_log, OS_LOG_TYPE_DEFAULT)) {
                            goto LABEL_138;
                          }
                          int v106 = v27[6].i32[0];
                          uint64_t v107 = v27[26].i32[0];
                          int v108 = v27[26].i32[1];
                          uint64_t v109 = v27[27].i32[0];
                          uint64_t v110 = v27[13];
                          __int16 v111 = v27[30].u8[3];
                          uint64_t v112 = *(int *)(*(void *)&v77 + 76LL);
                          *(_DWORD *)length = 67111171;
                          *(_DWORD *)&length[4] = v106;
                          *(_WORD *)&length[8] = 1024;
                          *(_DWORD *)&length[10] = v107;
                          *(_WORD *)&length[14] = 1024;
                          *(_DWORD *)&length[16] = v108;
                          *(_WORD *)&length[20] = 1024;
                          *(_DWORD *)&length[22] = v109;
                          *(_WORD *)&length[26] = 2160;
                          *(void *)&length[28] = 1752392040LL;
                          *(_WORD *)&length[36] = 2085;
                          *(int32x2_t *)uint64_t v155 = v110;
                          *(_WORD *)&v155[8] = 1024;
                          *(_DWORD *)unsigned int v156 = v111;
                          *(_WORD *)&v156[4] = 2048;
                          *(void *)&v156[6] = v112;
                          unsigned int v157 = 2082;
                          __int128 v158 = *(void *)&v77 + 84LL;
                          uint64_t v87 = "[R%u] getaddrinfo start -- flags: 0x%X, ifindex: %d, protocols: %u, hostname: %{sensitiv"
                                "e,mask.hash}s, options: %{mdns:gaiopts}X, client pid: %lld (%{public}s)";
                        }

                        else
                        {
                          if (_mdns_server_log_s_once != -1) {
                            dispatch_once(&_mdns_server_log_s_once, &__block_literal_global_16);
                          }
                          CFRange v105 = _mdns_server_log_s_log;
                          if (!os_log_type_enabled((os_log_t)_mdns_server_log_s_log, OS_LOG_TYPE_DEFAULT)) {
                            goto LABEL_138;
                          }
                          __int128 v120 = v27[6].i32[0];
                          __int128 v121 = v27[26].i32[0];
                          __int128 v122 = v27[26].i32[1];
                          __int128 v123 = v27[27].i32[0];
                          __int128 v124 = v27[13];
                          __int128 v125 = v27[30].u8[3];
                          __int128 v126 = *(int *)(*(void *)&v77 + 76LL);
                          *(_DWORD *)length = 67111171;
                          *(_DWORD *)&length[4] = v120;
                          *(_WORD *)&length[8] = 1024;
                          *(_DWORD *)&length[10] = v121;
                          *(_WORD *)&length[14] = 1024;
                          *(_DWORD *)&length[16] = v122;
                          *(_WORD *)&length[20] = 1024;
                          *(_DWORD *)&length[22] = v123;
                          *(_WORD *)&length[26] = 2160;
                          *(void *)&length[28] = 1752392040LL;
                          *(_WORD *)&length[36] = 2081;
                          *(int32x2_t *)uint64_t v155 = v124;
                          *(_WORD *)&v155[8] = 1024;
                          *(_DWORD *)unsigned int v156 = v125;
                          *(_WORD *)&v156[4] = 2048;
                          *(void *)&v156[6] = v126;
                          unsigned int v157 = 2082;
                          __int128 v158 = *(void *)&v77 + 84LL;
                          uint64_t v87 = "[R%u] getaddrinfo start -- flags: 0x%X, ifindex: %d, protocols: %u, hostname: %{private,"
                                "mask.hash}s, options: %{mdns:gaiopts}X, client pid: %lld (%{public}s)";
                        }

                        CFRange v103 = (os_log_s *)v105;
                        CFRange v104 = 72;
                      }

                      _os_log_impl((void *)&_mh_execute_header, v103, OS_LOG_TYPE_DEFAULT, v87, length, v104);
LABEL_138:
                      if (v74) {
                        os_release(v74);
                      }
                      int started = _dx_gai_request_start_client_requests(v27, 1);
                      uint64_t v6 = v148;
                      if (!started)
                      {
                        __int128 v128 = (int32x2_t **)(v148 + 24);
                        do
                        {
                          uint64_t v129 = v128;
                          unint64_t v130 = *v128;
                          __int128 v128 = (int32x2_t **)&(*v128)[2];
                        }

                        while (v130);
                        v27[2] = 0LL;
                        *uint64_t v129 = v27;
                        do
                          unsigned int v131 = __ldaxr(v28);
                        while (__stlxr(v131 + 1, v28));
                        uint64_t v36 = 0;
LABEL_151:
                        _dx_release((char *)v27);
                        uint64_t v7 = v36;
LABEL_152:
                        _dx_session_reset_idle_timer(v6);
                        reply = xpc_dictionary_create_reply(object);
                        if (reply)
                        {
                          uint64_t v139 = reply;
                          xpc_dictionary_set_int64(reply, "error", v7);
                          _dx_session_send_message(v6, v139);
                          xpc_release(v139);
                        }

                        else
                        {
                          _dx_session_terminate(v6, 4);
                        }

                        return;
                      }

                      uint64_t v36 = started;
LABEL_147:
                      uint64_t v136 = v27[3];
                      uint64_t v6 = v148;
                      if (_mdns_server_log_s_once != -1) {
                        dispatch_once(&_mdns_server_log_s_once, &__block_literal_global_16);
                      }
                      uint64_t v137 = (os_log_s *)_mdns_server_log_s_log;
                      if (os_log_type_enabled((os_log_t)_mdns_server_log_s_log, OS_LOG_TYPE_ERROR))
                      {
                        uint64_t v140 = v27[6].i32[0];
                        unsigned int v141 = v27[13];
                        uint64_t v142 = *(int *)(*(void *)&v136 + 76LL);
                        *(_DWORD *)length = 67110403;
                        *(_DWORD *)&length[4] = v140;
                        *(_WORD *)&length[8] = 2160;
                        *(void *)&length[10] = 1752392040LL;
                        *(_WORD *)&length[18] = 2081;
                        *(int32x2_t *)&length[20] = v141;
                        *(_WORD *)&length[28] = 2048;
                        *(void *)&length[30] = v36;
                        *(_WORD *)uint64_t v155 = 2048;
                        *(void *)&v155[2] = v142;
                        *(_WORD *)unsigned int v156 = 2082;
                        *(void *)&v156[2] = *(void *)&v136 + 84LL;
                        _os_log_error_impl( (void *)&_mh_execute_header,  v137,  OS_LOG_TYPE_ERROR,  "[R%u] getaddrinfo error -- hostname: %{private,mask.hash}s, error: %{mdns:err}ld, client pid: %lld (%{public}s)",  length,  0x3Au);
                      }

                      goto LABEL_151;
                    }

                    (*(void (**)(void *))(v74[2] + 56LL))(v74);
                    if (_mdns_server_log_s_once != -1) {
                      dispatch_once(&_mdns_server_log_s_once, &__block_literal_global_16);
                    }
                    CFIndex v75 = (os_log_s *)_mdns_server_log_s_log;
                    if (os_log_type_enabled((os_log_t)_mdns_server_log_s_log, OS_LOG_TYPE_DEBUG))
                    {
                      uint64_t v132 = v27[6].i32[0];
                      *(_DWORD *)length = 67109120;
                      *(_DWORD *)&length[4] = v132;
                      _os_log_debug_impl( (void *)&_mh_execute_header,  v75,  OS_LOG_TYPE_DEBUG,  "[R%u] Allowing signed result",  length,  8u);
                    }

                    v27[23] = (int32x2_t)v74;
                  }

                  CFIndex v74 = 0LL;
                  goto LABEL_102;
                }

                __int128 v61 = v60;
                __int128 v62 = malloc(0x10uLL);
                if (v62)
                {
                  *__int128 v62 = *(_OWORD *)v61;
                  v27[18] = (int32x2_t)v62;
                  goto LABEL_68;
                }

                goto LABEL_156;
              }
            }

            unsigned int v42 = *(_OWORD *)(v40 + 40);
            *(_OWORD *)length = *(_OWORD *)(v40 + 24);
            *(_OWORD *)&length[16] = v42;
            int64_limited = audit_token_to_pid((audit_token_t *)length);
            goto LABEL_45;
          }
        }

          *(_DWORD *)__int128 v100 = 68158466;
          *(_DWORD *)&v100[4] = (unsigned __int16)v76;
          *(_WORD *)&v100[8] = 2098;
          *(void *)&v100[10] = buf;
          *(_WORD *)&v100[18] = 2048;
          *(void *)&v100[20] = 0LL;
          *(_WORD *)&v100[28] = 1024;
          *(_DWORD *)&v100[30] = v73;
          _os_log_impl( (void *)&_mh_execute_header,  v74,  OS_LOG_TYPE_DEBUG,  "mDNS_AddMcastResolver: Adding %{public, mdnsresponder:domain_name}.*P, InterfaceID %p, timeout %u",  v100,  0x22u);
        }
      }

      mDNS_VerifyLockState("Check Lock", 1, dword_100158BE8, dword_100158BEC, (uint64_t)"mDNS_AddMcastResolver", 14084);
      int v80 = qword_10015BD50;
      if (!qword_10015BD50)
      {
        uint64_t v82 = (uint64_t *)((char *)&dword_100158BE8 + &unk_100003168);
LABEL_115:
        __int128 v90 = calloc(1uLL, 0x118uLL);
        if (!v90) {
          __break(1u);
        }
        *uint64_t v82 = (uint64_t)v90;
        v90[1] = 0LL;
        __int128 v91 = (_DWORD *)*v82;
        v91[4] = 2;
        v91[69] = v73;
        for (uint64_t k = buf; k < (uint8_t *)&v129; k += v93 + 1)
        {
          if (!k) {
            break;
          }
          __int128 v93 = *k;
          if (!*k)
          {
            __int128 v94 = (_DWORD)k - buf + 1;
            if ((unsigned __int16)v94 <= 0x100u)
            {
              memcpy(v91 + 5, buf, (unsigned __int16)v94);
              goto LABEL_125;
            }

            break;
          }
        }

        *((_BYTE *)v91 + memset(v45, 0, 20) = 0;
LABEL_125:
        *(void *)*uint64_t v82 = 0LL;
        goto LABEL_77;
      }

      int v81 = 0LL;
      uint64_t v82 = &qword_10015BD50;
      do
      {
        if (*(void *)(v80 + 8) || (v83 = SameDomainNameBytes((_BYTE *)(v80 + 20), buf), int v80 = *v82, !v83))
        {
          uint64_t v82 = (uint64_t *)v80;
        }

        else
        {
          __int128 v89 = *(_DWORD *)(v80 + 16);
          if ((v89 & 1) == 0)
          {
            LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "Note: Mcast Resolver domain %##s (%p) registered more than once",  v84,  v85,  v86,  v87,  v88,  (int)buf);
            int v80 = *v82;
            __int128 v89 = *(_DWORD *)(*v82 + 16);
          }

          *(_DWORD *)(v80 + 16) = v89 & 0xFFFFFFFE;
          *uint64_t v82 = *(void *)v80;
          *(void *)int v80 = 0LL;
          int v81 = v80;
        }

        int v80 = *v82;
      }

      while (*v82);
      if (!v81) {
        goto LABEL_115;
      }
      *uint64_t v82 = v81;
LABEL_77:
      if (++v10 == v97) {
        return;
      }
    }

    int v26 = *(_DWORD *)(v23 + 24);
    if (v26 < 1) {
      goto LABEL_72;
    }
    uint64_t v27 = mDNSLogCategory_State;
    uint64_t v28 = os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT);
    if (v20)
    {
      if (!v28) {
        goto LABEL_52;
      }
      unsigned int v35 = &xmmword_10015BD30;
      while (1)
      {
        unsigned int v35 = *(__int128 **)v35;
        if (!v35) {
          break;
        }
        uint64_t v36 = v35;
        if (*((void *)v35 + 782) == v20) {
          goto LABEL_47;
        }
      }

      uint64_t v36 = 0LL;
LABEL_47:
      unsigned int v49 = (char *)v36 + 6310;
      *(_DWORD *)__int128 v100 = 67109890;
      if (v35) {
        uint64_t v50 = v49;
      }
      else {
        uint64_t v50 = 0LL;
      }
      *(_DWORD *)&v100[4] = v26;
      *(_WORD *)&v100[8] = 1026;
      *(_DWORD *)&v100[10] = v25;
      *(_WORD *)&v100[14] = 2048;
      *(void *)&v100[16] = v24;
      *(_WORD *)&v100[24] = 2082;
      *(void *)&v100[26] = v50;
      uint64_t v44 = (os_log_s *)v27;
      uint64_t v45 = "ConfigSearchDomains: configuring search domains -- count: %d, scope type: %{public, mdnsresponder:dns_scope_"
            "type}d, generation: %llu, ifname: %{public}s";
      int v46 = 34;
    }

    else
    {
      if (!v28) {
        goto LABEL_52;
      }
      *(_DWORD *)__int128 v100 = 67109632;
      *(_DWORD *)&v100[4] = v26;
      *(_WORD *)&v100[8] = 1026;
      *(_DWORD *)&v100[10] = v25;
      *(_WORD *)&v100[14] = 2048;
      *(void *)&v100[16] = v24;
      uint64_t v44 = (os_log_s *)v27;
      uint64_t v45 = "ConfigSearchDomains: configuring search domains -- count: %d, scope type: %{public, mdnsresponder:dns_scope_"
            "type}d, generation: %llu";
      int v46 = 24;
    }

    _os_log_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_DEFAULT, v45, v100, v46);
LABEL_52:
    if (*(int *)(v23 + 24) >= 1)
    {
      uint64_t v51 = 0LL;
      do
      {
        uint64_t v52 = *(unsigned __int8 **)(*(void *)(v23 + 28) + 8 * v51);
        buf[0] = 0;
        appended = AppendDNSNameString(buf, v52, v29, v30, v31, v32, v33, v34);
        __int16 v54 = (os_log_s *)mDNSLogCategory_State;
        if (appended)
        {
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT))
          {
            for (uint64_t m = buf; ; m += v57 + 1)
            {
              LOWORD(v56) = 257;
              __int16 v57 = *m;
              if (v57 > 0x3F)
              {
                LOWORD(v56) = 257;
                break;
              }

              if (!*m)
              {
                int v56 = (_DWORD)m - buf + 1;
                break;
              }
            }

            *(_DWORD *)__int128 v100 = 141558531;
            *(void *)&v100[4] = 1752392040LL;
            *(_WORD *)&v100[12] = 1040;
            *(_DWORD *)&v100[14] = (unsigned __int16)v56;
            *(_WORD *)&v100[18] = 2101;
            *(void *)&v100[20] = buf;
            _os_log_impl( (void *)&_mh_execute_header,  v54,  OS_LOG_TYPE_DEFAULT,  "ConfigSearchDomains -- search domain: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P",  v100,  0x1Cu);
          }

          UpdateSearchDomainHash(a5, *(const char **)(*(void *)(v23 + 28) + 8 * v51), v20);
          uint64_t v112 = 0u;
          __int16 v113 = 0u;
          uint64_t v110 = 0u;
          __int16 v111 = 0u;
          int v108 = 0u;
          uint64_t v109 = 0u;
          int v106 = 0u;
          uint64_t v107 = 0u;
          CFRange v104 = 0u;
          CFRange v105 = 0u;
          CFRange v102 = 0u;
          CFRange v103 = 0u;
          __int128 v101 = 0u;
          memset(v100, 0, sizeof(v100));
          __int128 v59 = *(unsigned __int8 **)(*(void *)(v23 + 28) + 8 * v51);
          if (v59 && AppendDNSNameString(v100, v59, v29, v30, v31, v32, v33, v34) && v100[0]) {
            mDNS_AddSearchDomain(v100, v20);
          }
        }

        else if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_ERROR))
        {
          __int128 v58 = *(_DWORD *)(v23 + 8);
          *(_DWORD *)__int128 v100 = 67109376;
          *(_DWORD *)&v100[4] = v51;
          *(_WORD *)&v100[8] = 1024;
          *(_DWORD *)&v100[10] = v58;
          _os_log_impl( (void *)&_mh_execute_header,  v54,  OS_LOG_TYPE_ERROR,  "ConfigSearchDomains: An invalid search domain was detected -- index: %d, name server count: %d",  v100,  0xEu);
        }

        ++v51;
      }

      while (v51 < *(int *)(v23 + 24));
    }

    goto LABEL_72;
  }

            *(_DWORD *)buf = 67110147;
            *(_DWORD *)uint64_t v73 = v50;
            *(_WORD *)&v73[4] = 1024;
            *(_DWORD *)&v73[6] = v51;
            *(_WORD *)&v73[10] = 2160;
            *(void *)&v73[12] = 1752392040LL;
            LOWORD(v74) = 1040;
            *(_DWORD *)((char *)&v74 + 2) = v52;
            WORD3(v74) = 2101;
            *((void *)&v74 + 1) = v53;
            _os_log_impl( (void *)&_mh_execute_header,  v49,  OS_LOG_TYPE_INFO,  "[Q%u->SubQ%u] Possible DS denial found, starting secure DS denial query - DS name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P",  buf,  0x28u);
          }
        }

        __int128 v60 = 0LL;
        __int128 v63 = (void *)v33;
        goto LABEL_104;
      }
    }

    __int128 v60 = 0LL;
    __int128 v70 = v47;
    __int128 v63 = (void *)v33;
LABEL_116:
    _dnssec_obj_validation_manager_fail_insecure_validation(v31, v47);
    if (!v33) {
      goto LABEL_106;
    }
    goto LABEL_105;
  }

  if (!dnssec_obj_domain_name_is_sub_domain_of(*(unsigned __int8 **)(v32 + 16), *(unsigned __int8 **)(v33 + 16)))
  {
LABEL_140:
    __int128 v60 = 0LL;
    __int128 v63 = 0LL;
    int v47 = -6736;
    goto LABEL_115;
  }

  uint64_t v39 = *(unsigned __int8 **)(v32 + 16);
  uint64_t v40 = *v39;
  if (*v39)
  {
    uint64_t v41 = 0LL;
    unsigned int v42 = *(void *)(v32 + 16);
    do
    {
      ++v41;
      uint64_t v43 = v42 + v40;
      uint64_t v44 = *(unsigned __int8 *)(v43 + 1);
      unsigned int v42 = v43 + 1;
      uint64_t v40 = v44;
    }

    while (v44);
  }

  else
  {
    uint64_t v41 = 0LL;
  }

  __int16 v54 = *(_BYTE **)(v33 + 16);
  int v55 = *v54;
  if (*v54)
  {
    int v56 = -1LL;
    do
    {
      __int16 v57 = &v54[v55];
      __int128 v58 = v57[1];
      __int16 v54 = v57 + 1;
      int v55 = v58;
      ++v56;
    }

    while (v58);
    __int128 v59 = -2 - v56;
  }

  else
  {
    __int128 v59 = -1LL;
  }

  __int128 v60 = dnssec_obj_domain_name_copy_parent_domain(v39, v41 + v59, &v70);
  int v47 = v70;
  if (v70) {
    goto LABEL_150;
  }
  _dnssec_obj_validation_manager_stop_negative_ds_query(v31);
  __int128 v61 = _dnssec_obj_validation_manager_start_negative_ds_query(v31, v60, v8);
  __int128 v70 = v61;
  if (v61)
  {
    int v47 = v61;
LABEL_150:
    __int128 v63 = 0LL;
    goto LABEL_116;
  }

  if (v60) {
    ++*(_DWORD *)v60;
  }
  __int128 v62 = *(void **)(v31 + 104);
  if (v62) {
    ref_count_obj_release(v62);
  }
  __int128 v63 = 0LL;
  *(void *)(v31 + 104) = v60;
LABEL_104:
  __int128 v70 = 0;
  if (v33) {
LABEL_105:
  }
    ref_count_obj_release((void *)v33);
LABEL_106:
  if (v60) {
    ref_count_obj_release(v60);
  }
  if (v63) {
    ref_count_obj_release(v63);
  }
}

LABEL_40:
    if (*(int *)(v6 + 212) >= 1 && !*(void *)(v6 + 40) && (!*(_WORD *)(v6 + 320) || !*(_BYTE *)(v6 + 612)))
    {
      int v25 = *(_DWORD *)(a1 + 64);
      *(_DWORD *)(v6 + 256) = v25;
      *(_DWORD *)(v6 + 224) = 0;
      *(_DWORD *)(v6 + 208) = v25;
      *(_DWORD *)(v6 + 212) = 3600000;
      *(_BYTE *)(v6 + 332) = 0;
      *(_BYTE *)(v6 + 628) = 0;
    }

    goto LABEL_45;
  }

  uint64_t v28 = D2DFindInBrowseList(__src, a3);
  if (!*v28)
  {
    __int16 v29 = calloc(1uLL, 0x110uLL);
    if (!v29) {
      __break(1u);
    }
    *uint64_t v28 = (uint64_t)v29;
    v29[132] = a3;
    for (uint64_t k = (uint8_t *)__src; k < buf; k += v31 + 1)
    {
      if (!k) {
        break;
      }
      unsigned int v31 = *k;
      if (!*k)
      {
        BOOL v32 = (_DWORD)k - __src + 1;
        if ((unsigned __int16)v32 <= 0x100u)
        {
          memcpy(v29 + 4, __src, (unsigned __int16)v32);
          goto LABEL_51;
        }

        break;
      }
    }

    *((_BYTE *)v29 + 8) = 0;
  }

    uint64_t v28 = *v16;
    *(_DWORD *)buf = 141559043;
    __int128 v62 = 1752392040LL;
    __int128 v63 = 1040;
    __int128 v64 = v26;
    __int128 v65 = 2101;
    __int128 v66 = v15;
    __int128 v67 = 1024;
    __int128 v68 = v28;
    __int128 v69 = 1024;
    LODWORD(v70) = v13;
    _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_DEBUG,  "D2DBrowseListRelease - name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P, type: %{mdns:rrtype}d, ref count: %u",  buf,  0x28u);
LABEL_41:
    __int16 v29 = (uint64_t *)*v12;
    if (!*(_DWORD *)(*v12 + 268))
    {
      uint64_t *v12 = *v29;
      free(v29);
    }

    uint64_t v30 = D2DFindInBrowseList(v60, a3);
    if (*v30 && *(_DWORD *)(*v30 + 268)) {
      return;
    }
    __int128 v59 = 0;
    unsigned int v31 = (os_log_s *)mDNSLogCategory_D2D;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_D2D == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_66;
      }
      for (uint64_t k = (uint8_t *)v60; ; k += v39 + 1)
      {
        if (k >= buf || !k || (uint64_t v39 = *k, v39 > 0x3F))
        {
          uint64_t v40 = 257;
          goto LABEL_65;
        }

        if (!*k) {
          break;
        }
      }

      uint64_t v40 = (unsigned __int16)((_WORD)k - (unsigned __int16)v60 + 1);
    }

    else
    {
      unsigned int v31 = (os_log_s *)mDNSLogCategory_D2D_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D_redacted, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_66;
      }
      for (uint64_t m = (uint8_t *)v60; ; m += v37 + 1)
      {
        if (m >= buf || !m || (uint64_t v37 = *m, v37 > 0x3F))
        {
          uint64_t v40 = 257;
          goto LABEL_65;
        }

        if (!*m) {
          break;
        }
      }

      uint64_t v40 = (unsigned __int16)((_WORD)m - (unsigned __int16)v60 + 1);
    }

        uint64_t v7 = (void *)*v7;
      }

      while (v7);
    }
  }

  uint64_t v21 = time(0LL);
  for (CFIndex i = *(void *)mDNSStorage[0]; i; CFIndex i = *(void *)(i + 6384))
  {
    if (*(_BYTE *)(i + 6400)) {
      *(_DWORD *)(i + 6408) = v21;
    }
    *(_BYTE *)(i + 6400) = 0;
  }

  ClearInactiveInterfaces(v21);
  CloseSocketSet(mDNSStorage[0] + 8);
  BOOL v23 = 0LL;
  uint64_t v24 = 0;
  do
  {
    int v25 = &mDNSStorage[v23];
    int v26 = (void *)v25[35];
    if (v26)
    {
      uint64_t v27 = (void **)(v25 + 35);
      do
      {
        __int16 v29 = v26 + 2;
        uint64_t v28 = (void *)v26[2];
        if (v28)
        {
          do
          {
            os_log_s *v29 = *v28;
            if (v28[12]) {
              ++v24;
            }
            ReleaseCacheRecord((uint64_t)mDNSStorage, (uint64_t)v28);
            uint64_t v28 = (void *)*v29;
          }

          while (*v29);
        }

        v26[3] = v29;
        ReleaseCacheGroup((uint64_t)mDNSStorage, v27);
        int v26 = *v27;
      }

      while (*v27);
    }

    ++v23;
  }

  while (v23 != 499);
  uint64_t v30 = qword_100158CBC;
  if (v24 != (_DWORD)qword_100158CBC)
  {
    unsigned int v31 = (os_log_s *)mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_63;
      }
      goto LABEL_62;
    }

    unsigned int v31 = (os_log_s *)mDNSLogCategory_Default_redacted;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
    {
LABEL_62:
      *(_DWORD *)buf = 67109632;
      *(_DWORD *)uint64_t v41 = v0;
      *(_WORD *)&v41[4] = 1024;
      *(_DWORD *)&v41[6] = v24;
      *(_WORD *)unsigned int v42 = 1024;
      *(_DWORD *)&v42[2] = v30;
      _os_log_impl( (void *)&_mh_execute_header,  v31,  OS_LOG_TYPE_DEFAULT,  "*** ERROR *** rrcache_totalused %u; rrcache_active %u != m->rrcache_active %u",
        buf,
        0x14u);
    }
  }

    __break(1u);
    goto LABEL_41;
  }

  uint64_t v18 = 0LL;
  uint64_t v19 = 0LL;
  do
  {
    uint64_t v20 = *(unsigned __int16 *)(*v17 + 4LL);
    if (v20 == 46)
    {
      ++v18;
    }

    else
    {
      if (v20 != 48) {
        goto LABEL_41;
      }
      ++v19;
    }

    uint64_t v17 = (void *)v17[1];
  }

  while (v17);
  if (v18 + v19 != *(void *)(a1 + 32)) {
    goto LABEL_41;
  }
  if (!v19) {
    goto LABEL_40;
  }
  if (v19 >> 61) {
    goto LABEL_40;
  }
  uint64_t v21 = (_DWORD **)calloc(v19, 8uLL);
  if (!v21) {
    goto LABEL_40;
  }
  if (!v18) {
    goto LABEL_40;
  }
  if (v18 >> 61) {
    goto LABEL_40;
  }
  uint64_t v22 = v21;
  BOOL v23 = (_DWORD **)calloc(v18, 8uLL);
  if (!v23) {
    goto LABEL_40;
  }
  uint64_t v24 = v23;
  uint64_t v37 = a4;
  uint64_t v38 = a2;
  uint64_t v39 = a6;
  uint64_t v40 = -6736;
  int v25 = *(void **)(a1 + 24);
  if (v25)
  {
    int v26 = 0LL;
    uint64_t v27 = 0LL;
    while (1)
    {
      uint64_t v28 = *v25;
      __int16 v29 = *(unsigned __int16 *)(*v25 + 4LL);
      if (v29 == 46)
      {
        v24[v27++] = (_DWORD *)dnssec_obj_rr_rrsig_create( *(unsigned __int8 **)(v28 + 32),  (const void *)(*(void *)(v28 + 40) + 4LL),  *(unsigned __int16 *)(v28 + 12),  0,  &v40);
      }

      else
      {
        if (v29 != 48)
        {
          uint64_t v7 = 0LL;
          uint64_t v40 = -6736;
LABEL_69:
          a6 = v39;
          if (!v39) {
            goto LABEL_50;
          }
LABEL_49:
          *a6 = v40;
          goto LABEL_50;
        }

        v22[v26++] = (_DWORD *)dnssec_obj_rr_dnskey_create( *(unsigned __int8 **)(v28 + 32),  *(_WORD *)(v28 + 6),  (_BYTE *)(*(void *)(v28 + 40) + 4LL),  *(unsigned __int16 *)(v28 + 12),  &v40);
      }

      if (v40) {
        goto LABEL_67;
      }
      int v25 = (void *)v25[1];
      if (!v25) {
        goto LABEL_45;
      }
    }
  }

  uint64_t v27 = 0LL;
  int v26 = 0LL;
LABEL_45:
  BOOL v32 = dnssec_obj_rr_validator_create(v22, v26, v24, v18, v22, v26, v38, a3, v37, a5, &v40);
  if (v40)
  {
LABEL_67:
    uint64_t v7 = 0LL;
    goto LABEL_69;
  }

  uint64_t v33 = v32;
  uint64_t v7 = dnssec_obj_rr_validator_validate_rrset((uint64_t)v32, &v40);
  ref_count_obj_release(v33);
  *(_DWORD *)(a1 + 44) = v7;
  a6 = v39;
  if ((_DWORD)v7) {
    *(_DWORD *)(a1 + 48) = v40;
  }
  if (v39) {
    goto LABEL_49;
  }
LABEL_50:
  if (v16) {
    ref_count_obj_release(v16);
  }
  if (v27)
  {
    unsigned int v34 = (void **)v24;
    do
    {
      if (*v34)
      {
        ref_count_obj_release(*v34);
        os_log_s *v34 = 0LL;
      }

      ++v34;
      --v27;
    }

    while (v27);
  }

  if (v26)
  {
    unsigned int v35 = (void **)v22;
    do
    {
      if (*v35)
      {
        ref_count_obj_release(*v35);
        *unsigned int v35 = 0LL;
      }

      ++v35;
      --v26;
    }

    while (v26);
  }

  if (v24) {
    free(v24);
  }
  if (v22) {
    free(v22);
  }
  return v7;
}

      __int16 v29 = (uint64_t *)calloc(1uLL, 0x18uLL);
      if (v29)
      {
        uint32_t v4 = v29;
        uint64_t v30 = mdns_interface_monitor_create(v28);
        if (!v30)
        {
          free(v4);
          goto LABEL_55;
        }

        char v15 = v30;
        goto LABEL_74;
      }

      uint64_t v28 = "mDNS_RemoveDomainDiscoveredForDomainEnumeration";
      __int16 v29 = a1;
      uint64_t v30 = 16282;
    }

    mDNS_Unlock_(v29, (uint64_t)v28, v30);
    unsigned int v31 = (void *)(a1 + 12664);
    while (1)
    {
      unsigned int v31 = (void *)*v31;
      if (!v31) {
        break;
      }
      BOOL v32 = v31;
      if (v31[782] == *((void *)a3 + 3)) {
        goto LABEL_46;
      }
    }

    BOOL v32 = 0LL;
LABEL_46:
    if (v31) {
      uint64_t v33 = (char *)v32 + 6310;
    }
    else {
      uint64_t v33 = 0LL;
    }
    unsigned int v34 = (os_log_s *)mDNSLogCategory_mDNS;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v36 = "removed";
        if (a4 == 1) {
          uint64_t v36 = "added";
        }
        uint64_t v37 = (_BYTE *)(v14 + 4);
        if (v14 == -260)
        {
LABEL_59:
          while (v37)
          {
            uint64_t v38 = *v37;
            if (!*v37)
            {
              unsigned int v42 = (unsigned __int16)((_WORD)v37 - v15 + 1);
              goto LABEL_78;
            }

            v37 += v38 + 1;
            if (v14 != -260) {
              goto LABEL_58;
            }
          }
        }

        else
        {
LABEL_58:
        }

        unsigned int v42 = 257;
        goto LABEL_78;
      }
    }

    else
    {
      unsigned int v34 = (os_log_s *)mDNSLogCategory_mDNS_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v36 = "removed";
        if (a4 == 1) {
          uint64_t v36 = "added";
        }
        uint64_t v40 = (_BYTE *)(v14 + 4);
        if (v14 == -260)
        {
LABEL_69:
          while (v40)
          {
            uint64_t v41 = *v40;
            if (!*v40)
            {
              unsigned int v42 = (unsigned __int16)((_WORD)v40 - v15 + 1);
              goto LABEL_78;
            }

            v40 += v41 + 1;
            if (v14 != -260) {
              goto LABEL_68;
            }
          }
        }

        else
        {
LABEL_68:
        }

        unsigned int v42 = 257;
LABEL_78:
        uint64_t v43 = 136447235;
        uint64_t v44 = v36;
        uint64_t v45 = 2082;
        int v46 = v33;
        int v47 = 2160;
        unsigned int v48 = 1752392040LL;
        unsigned int v49 = 1040;
        uint64_t v50 = v42;
        uint64_t v51 = 2101;
        uint64_t v52 = v14 + 4;
        _os_log_impl( (void *)&_mh_execute_header,  v34,  OS_LOG_TYPE_DEFAULT,  "Automatic browsing domain discovered via network - change: %{public}s, interface name: %{public}s, browsing do main: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P",  (uint8_t *)&v43,  0x30u);
      }
    }
  }

    uint32_t v4 = 0LL;
    unint64_t v5 = 0LL;
    uint64_t v6 = 0LL;
    goto LABEL_63;
  }

  uint64_t v20 = *(void **)(v15 + 64);
  if (!v20) {
    goto LABEL_40;
  }
  querier = mdns_resolver_create_querier(v20);
  if (!querier) {
    goto LABEL_40;
  }
  uint64_t v18 = querier;
  if (v9 && !*(_BYTE *)(querier + 49))
  {
    uint64_t v22 = *(void *)(querier + 88);
    if ((*(_BYTE *)(v22 + 70) & 0x20) != 0 || (*(_BYTE *)(v22 + 70) |= 4u, !*(_BYTE *)(querier + 49)))
    {
      BOOL v23 = *(void *)(querier + 88);
      if ((*(_BYTE *)(v23 + 70) & 0x20) == 0) {
        *(_BYTE *)(v23 + 70) |= 2u;
      }
    }
  }

  uint64_t v24 = *(void **)(a1 + 128);
  if (v24)
  {
LABEL_36:
    mdns_querier_set_delegator_audit_token(v18, v24);
    goto LABEL_37;
  }

  int v25 = *(_DWORD *)(a1 + 244);
  if (v25)
  {
    int v26 = *(void *)(a1 + 120);
    if (v26)
    {
      uint64_t v27 = *(_OWORD *)(v26 + 40);
      *(_OWORD *)atoken.val = *(_OWORD *)(v26 + 24);
      *(_OWORD *)&atoken.val[4] = v27;
      uint64_t v28 = audit_token_to_pid(&atoken);
      int v25 = *(_DWORD *)(a1 + 244);
    }

    else
    {
      uint64_t v28 = 0;
    }

    if (v28 != v25)
    {
      if (!*(_BYTE *)(v18 + 49))
      {
        _mdns_querier_clear_delegation(v18);
        *(_DWORD *)(v18 + 184) = 1;
        *(_DWORD *)(v18 + 168) = v25;
      }

      goto LABEL_37;
    }

    uint64_t v24 = *(void **)(a1 + 120);
    goto LABEL_36;
  }

  mdns_querier_set_delegator_uuid(querier, (const unsigned __int8 *)(a1 + 636));
LABEL_37:
  if (!DNSQuestionNeedsSensitiveLogging(a1) || *(_BYTE *)(v18 + 49))
  {
    unint64_t v5 = 0LL;
  }

  else
  {
    unint64_t v5 = 0LL;
    *(_BYTE *)(v18 + 255) = 1;
  }

  uint64_t v6 = v18;
LABEL_49:
  uint32_t v4 = mdns_domain_name_create_with_labels((_BYTE *)(a1 + 356), 0LL);
  if (v4)
  {
    if (!*(_BYTE *)(v18 + 49)) {
      (*(void (**)(uint64_t, void *, void, void))(*(void *)(v18 + 16) + 56LL))( v18,  v4,  *(unsigned __int16 *)(a1 + 322),  *(unsigned __int16 *)(a1 + 324));
    }
    os_retain(*(void **)(a1 + 80));
    if (!*(_BYTE *)(v18 + 49))
    {
      *(void *)(v18 + 32) = *(void *)(a1 + 80);
      *(void *)(v18 + 40) = mdns_object_context_finalizer;
    }

    if (_Querier_InternalQueue_sOnce != -1) {
      dispatch_once(&_Querier_InternalQueue_sOnce, &__block_literal_global_38);
    }
    mdns_client_set_queue(v18, (dispatch_object_t)_Querier_InternalQueue_sQueue);
    if (v6)
    {
      os_retain((void *)v6);
      aBlock[0] = _NSConcreteStackBlock;
      aBlock[1] = 0x40000000LL;
      aBlock[2] = __Querier_HandleUnicastQuestion_block_invoke_14;
      aBlock[3] = &__block_descriptor_tmp_16_3197;
      aBlock[4] = v6;
      mdns_querier_set_result_handler(v6, aBlock);
      mdns_querier_set_log_label( v6,  "Q%u",  v31,  v32,  v33,  v34,  v35,  v36,  bswap32(*(unsigned __int16 *)(a1 + 320)) >> 16);
      if (!*(_BYTE *)(v6 + 49)) {
        *(_DWORD *)(v6 + 232) = bswap32(*(unsigned __int16 *)(a1 + 320)) >> 16;
      }
    }

    if (v5)
    {
      os_retain(v5);
      v40[0] = _NSConcreteStackBlock;
      v40[1] = 0x40000000LL;
      v40[2] = __Querier_HandleUnicastQuestion_block_invoke_2;
      v40[3] = &__block_descriptor_tmp_20_3199;
      v40[4] = v5;
      mdns_subscriber_set_event_handler((uint64_t)v5, v40);
    }

    mdns_client_replace(v3, (void *)v18);
    mdns_client_activate((uint64_t)*v3);
    uint64_t v7 = 0;
    goto LABEL_62;
  }

            uint64_t v18 = v12;
          }

          else
          {
            uint64_t v18 = 0;
          }

  __int16 v29 = *(void *)(a2 + 8);
  uint64_t v30 = tcpConnectionCallback_LNTERRORcount;
  if (!tcpConnectionCallback_LNTERRORcount
    || (*(_DWORD *)(v29 + 64) - tcpConnectionCallback_lastErrorTime) >= 0x3E8)
  {
    tcpConnectionCallback_lastErrorTime = *(_DWORD *)(v29 + 64);
    tcpConnectionCallback_LNTERRORcount = 1;
    goto LABEL_48;
  }

  tcpConnectionCallback_lastErrorTime = *(_DWORD *)(v29 + 64);
  unsigned int v31 = ++tcpConnectionCallback_LNTERRORcount;
  HIDWORD(v32) = 652835029 * (v30 + 1);
  LODWORD(v32) = HIDWORD(v32);
  uint64_t v33 = (os_log_s *)mDNSLogCategory_NAT;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_NAT == mDNSLogCategory_State)
  {
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT, OS_LOG_TYPE_ERROR)) {
      goto LABEL_140;
    }
    *(_DWORD *)buf = 67109120;
    LODWORD(v77) = v31;
  }

  else
  {
    uint64_t v33 = (os_log_s *)mDNSLogCategory_NAT_redacted;
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT_redacted, OS_LOG_TYPE_ERROR)) {
      goto LABEL_140;
    }
    *(_DWORD *)buf = 67109120;
    LODWORD(v77) = v31;
  }

  _os_log_impl( (void *)&_mh_execute_header,  v33,  OS_LOG_TYPE_ERROR,  "ERROR: tcpconnectioncallback -> got error status %u times",  buf,  8u);
LABEL_140:
LABEL_48:
  unsigned int v34 = *(_DWORD *)(a2 + 32);
  switch(v34)
  {
    case 3:
      uint64_t v38 = *(void *)(a2 + 16);
      if (!v38) {
        goto LABEL_115;
      }
      uint64_t v39 = mDNSLogCategory_NAT;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_NAT == mDNSLogCategory_State)
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_115;
        }
        uint64_t v40 = "failure";
        uint64_t v41 = *(_DWORD *)(v38 + 168);
        if (!v41) {
          uint64_t v40 = "success";
        }
      }

      else
      {
        uint64_t v39 = mDNSLogCategory_NAT_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT_redacted, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_115;
        }
        uint64_t v40 = "failure";
        uint64_t v41 = *(_DWORD *)(v38 + 168);
        if (!v41) {
          uint64_t v40 = "success";
        }
      }

      *(_DWORD *)buf = 136446466;
      int v77 = (uint64_t)v40;
      int v78 = 1024;
      *(_DWORD *)int v79 = v41;
      uint64_t v44 = "tcpConnectionCallback: PortMapRequest %{public}s result %d";
      unsigned int v49 = (os_log_s *)v39;
      uint64_t v50 = 18;
      break;
    case 2:
      unsigned int v42 = mDNSLogCategory_NAT;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_NAT == mDNSLogCategory_State)
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_115;
        }
        if (*(_DWORD *)(v29 + 14672)) {
          uint64_t v51 = "success";
        }
        else {
          uint64_t v51 = "failure";
        }
        *(_DWORD *)buf = 136446210;
        int v77 = (uint64_t)v51;
        uint64_t v44 = "tcpConnectionCallback: AddressRequest %{public}s";
      }

      else
      {
        unsigned int v42 = mDNSLogCategory_NAT_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT_redacted, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_115;
        }
        if (*(_DWORD *)(v29 + 14672)) {
          uint64_t v43 = "success";
        }
        else {
          uint64_t v43 = "failure";
        }
        *(_DWORD *)buf = 136446210;
        int v77 = (uint64_t)v43;
        uint64_t v44 = "tcpConnectionCallback: AddressRequest %{public}s";
      }

      unsigned int v49 = (os_log_s *)v42;
      uint64_t v50 = 12;
      break;
    case 1:
      unsigned int v35 = mDNSLogCategory_NAT;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_NAT == mDNSLogCategory_State)
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_115;
        }
        uint64_t v36 = *(const char **)(v29 + 15000);
        uint64_t v37 = "NULL";
        if (!v36) {
          uint64_t v36 = "NULL";
        }
        if (*(void *)(v29 + 14984)) {
          uint64_t v37 = *(const char **)(v29 + 14984);
        }
      }

      else
      {
        unsigned int v35 = mDNSLogCategory_NAT_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT_redacted, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_115;
        }
        uint64_t v36 = *(const char **)(v29 + 15000);
        uint64_t v37 = "NULL";
        if (!v36) {
          uint64_t v36 = "NULL";
        }
        if (*(void *)(v29 + 14984)) {
          uint64_t v37 = *(const char **)(v29 + 14984);
        }
      }

      *(_DWORD *)buf = 141558787;
      int v77 = 1752392040LL;
      int v78 = 2085;
      *(void *)int v79 = v36;
      *(_WORD *)&v79[8] = 2160;
      *(void *)&v79[10] = 1752392040LL;
      *(_WORD *)&v79[18] = 2085;
      int v80 = v37;
      uint64_t v44 = "tcpConnectionCallback: DeviceDescription SOAP address %{sensitive, mask.hash}s SOAP path %{sensitive, mask.hash}s";
      unsigned int v49 = (os_log_s *)v35;
      uint64_t v50 = 42;
      break;
    default:
      goto LABEL_115;
  }

  _os_log_impl((void *)&_mh_execute_header, v49, OS_LOG_TYPE_DEFAULT, v44, buf, v50);
LABEL_115:
  mDNSPlatformTCPCloseConnection(a1);
  *(void *)(a2 + 24) = 0LL;
  int v55 = *(void **)(a2 + 64);
  if (v55)
  {
    free(v55);
    *(void *)(a2 + 64) = 0LL;
  }

  int v56 = *(void **)(a2 + 80);
  if (v56)
  {
    free(v56);
    *(void *)(a2 + 80) = 0LL;
    mDNS_Unlock_(*(void *)(a2 + 8), (uint64_t)"tcpConnectionCallback", 522);
    if ((v22 & 1) == 0) {
      return;
    }
  }

  else
  {
    mDNS_Unlock_(*(void *)(a2 + 8), (uint64_t)"tcpConnectionCallback", 522);
    if (!v22) {
      return;
    }
  }

  __int16 v57 = (void *)(*(void *)(a2 + 8) + 14936LL);
  do
  {
    __int128 v58 = v57;
    __int16 v57 = (void *)*v57;
    if (v57) {
      __int128 v59 = v57 == (void *)a2;
    }
    else {
      __int128 v59 = 1;
    }
  }

  while (!v59);
  if (v57)
  {
    *__int128 v58 = *v57;
    if (a2) {
      free((void *)a2);
    }
  }

char *create_reply( char *result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((a2 & 0xFFFFFFFC) > 0xBuLL)
  {
    int v8 = a2;
    size_t v9 = a2 + 44;
    if (v9 && (int v11 = (int)result, (result = (char *)calloc(1uLL, v9)) != 0LL))
    {
      *(void *)BOOL result = 0LL;
      *((_DWORD *)result + 2) = v8 + 28;
      *(void *)(result + 12) = &_mh_execute_header;
      *((_DWORD *)result + 5) = v8;
      *((_DWORD *)result + 6) = 0;
      *((_DWORD *)result + 7) = v11;
      *((void *)result + 4) = *(void *)(a3 + 216);
      *((_DWORD *)result + 10) = 0;
    }

    else
    {
      __break(1u);
    }
  }

  else
  {
    LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "ERROR: create_reply - data length less than length of required fields",  a4,  a5,  a6,  a7,  a8,  v12);
    return 0LL;
  }

  return result;
}

uint64_t mDNSPlatformInterfaceIndexfromInterfaceID( uint64_t **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = a2;
  uint64_t v10 = a2 + 5;
  uint64_t v11 = **a1;
  if (v11)
  {
    while (*(_DWORD *)(v11 + 6424) != (_DWORD)a2)
    {
      uint64_t v11 = *(void *)(v11 + 6384);
      if (!v11) {
        goto LABEL_6;
      }
    }
  }

  else
  {
LABEL_6:
    if (!(_DWORD)a3)
    {
      if (mDNS_LoggingEnabled == 1) {
        LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "Interface index for InterfaceID %p not found; Updating interface list",
      }
          a4,
          a5,
          a6,
          a7,
          a8,
          a2);
      mDNSMacOSXNetworkChanged((uint64_t)a1, a2, a3, a4, a5, a6, a7, a8);
      uint64_t v12 = **a1;
      if (v12)
      {
        while (*(_DWORD *)(v12 + 6424) != (_DWORD)v8)
        {
          uint64_t v12 = *(void *)(v12 + 6384);
          if (!v12) {
            return 0LL;
          }
        }
      }

      else
      {
        return 0LL;
      }
    }
  }

  return v8;
}

void abort_request(uint64_t a1)
{
  int v2 = *(void (**)(uint64_t))(a1 + 96);
  if (!v2)
  {
LABEL_11:
    if (*(void *)a1)
    {
      Querier_DeregisterCustomDNSService(*(void *)a1);
      *(void *)a1 = 0LL;
    }

    int v5 = *(_DWORD *)(a1 + 168);
    if (v5 < 0)
    {
      uint64_t v14 = mDNSLogCategory_Default;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
          return;
        }
      }

      else
      {
        uint64_t v14 = mDNSLogCategory_Default_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
          return;
        }
      }

      int v22 = *(_DWORD *)(a1 + 184);
      *(_DWORD *)buf = 67109632;
      int v34 = v22;
      __int16 v35 = 2048;
      *(void *)uint64_t v36 = a1;
      *(_WORD *)&v36[8] = 1024;
      LODWORD(v37) = v5;
      uint64_t v18 = "[R%d] abort_request: ERROR: Attempt to abort operation %p with invalid fd %d";
      uint64_t v19 = (os_log_s *)v14;
      uint32_t v20 = 24;
      goto LABEL_32;
    }

    if (*(void *)(a1 + 24))
    {
LABEL_50:
      *(_DWORD *)(a1 + 176) = -1;
      *(_DWORD *)(a1 + 168) = -1;
      *(void *)(a1 + 96) = -1LL;
      return;
    }

    int v6 = *(_DWORD *)(a1 + 176);
    char v7 = gSensitiveLoggingEnabled;
    uint64_t v8 = mDNSLogCategory_Default;
    if (mDNSLogCategory_Default == mDNSLogCategory_State) {
      char v7 = 0;
    }
    if (v6 == v5)
    {
      if ((v7 & 1) != 0)
      {
        uint64_t v8 = mDNSLogCategory_Default_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEBUG)) {
          goto LABEL_41;
        }
      }

      else if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEBUG))
      {
        goto LABEL_41;
      }

      int v23 = *(_DWORD *)(a1 + 184);
      *(_DWORD *)buf = 67109376;
      int v34 = v23;
      __int16 v35 = 1024;
      *(_DWORD *)uint64_t v36 = v5;
      uint64_t v24 = "[R%d] Removing FD %d";
      int v25 = (os_log_s *)v8;
      uint32_t v26 = 14;
    }

    else
    {
      if ((v7 & 1) != 0)
      {
        uint64_t v8 = mDNSLogCategory_Default_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEBUG)) {
          goto LABEL_41;
        }
      }

      else if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEBUG))
      {
        goto LABEL_41;
      }

      int v27 = *(_DWORD *)(a1 + 184);
      *(_DWORD *)buf = 67109632;
      int v34 = v27;
      __int16 v35 = 1024;
      *(_DWORD *)uint64_t v36 = v5;
      *(_WORD *)&v36[4] = 1024;
      *(_DWORD *)&v36[6] = v6;
      uint64_t v24 = "[R%d] Removing FD %d and closing errsd %d";
      int v25 = (os_log_s *)v8;
      uint32_t v26 = 20;
    }

    _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEBUG, v24, buf, v26);
LABEL_41:
    int v28 = *(_DWORD *)(a1 + 168);
    __int16 v29 = &gEventSources;
    while (1)
    {
      uint64_t v30 = v29;
      __int16 v29 = (uint64_t *)*v29;
      if (!v29) {
        break;
      }
      if (*((_DWORD *)v29 + 2) == v28)
      {
        uint64_t *v30 = *v29;
        close(v28);
        free(v29);
        goto LABEL_46;
      }
    }

    LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "udsSupportRemoveFDFromEventLoop: ERROR fd %d not found in EventLoop source list",  v9,  v10,  v11,  v12,  v13,  *(_DWORD *)(a1 + 168));
LABEL_46:
    int v31 = *(_DWORD *)(a1 + 176);
    if (v31 != *(_DWORD *)(a1 + 168))
    {
      close(v31);
      *(_DWORD *)(a1 + 176) = *(_DWORD *)(a1 + 168);
    }

    while (1)
    {
      BOOL v32 = *(void **)(a1 + 88);
      if (!v32) {
        break;
      }
      *(void *)(a1 + 88) = *v32;
      free(v32);
    }

    goto LABEL_50;
  }

  if (v2 != (void (*)(uint64_t))-1LL)
  {
    v2(a1);
    goto LABEL_11;
  }

  uint64_t v3 = mDNSLogCategory_Default;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
  {
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    goto LABEL_29;
  }

  uint64_t v3 = mDNSLogCategory_Default_redacted;
  if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
  {
LABEL_29:
    int v17 = *(_DWORD *)(a1 + 184);
    *(_DWORD *)buf = 67109632;
    int v34 = v17;
    __int16 v35 = 2048;
    *(void *)uint64_t v36 = a1;
    *(_WORD *)&v36[8] = 2048;
    uint64_t v37 = -1LL;
    uint64_t v18 = "[R%d] abort_request: ERROR: Attempt to abort operation %p with req->terminate %p";
    uint64_t v19 = (os_log_s *)v3;
    uint32_t v20 = 28;
LABEL_32:
    _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, v18, buf, v20);
  }

void queryrecord_termination_callback(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 128);
  uint64_t v3 = (unsigned __int8 *)(v2 + 356);
  BOOL v4 = IsLocalDomain((_BYTE *)(v2 + 356));
  int v5 = *(unsigned __int16 *)(*(void *)(a1 + 128) + 322LL);
  if (!_shouldLogFullRequestInfo((int *)(a1 + 188), (_DWORD *)(a1 + 192)))
  {
    if (!gSensitiveLoggingEnabled
      || (v4 ? (uint64_t v21 = mDNSLogCategory_mDNS) : (uint64_t v21 = mDNSLogCategory_Default), v21 == mDNSLogCategory_State))
    {
      if (v4) {
        int v22 = (os_log_s *)mDNSLogCategory_mDNS;
      }
      else {
        int v22 = (os_log_s *)mDNSLogCategory_Default;
      }
      if (!os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_52;
      }
    }

    else
    {
      if (v4) {
        int v22 = (os_log_s *)mDNSLogCategory_mDNS;
      }
      else {
        int v22 = (os_log_s *)mDNSLogCategory_Default_redacted;
      }
      if (!os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_52;
      }
    }

    int v23 = *(_DWORD *)(a1 + 184);
    int v24 = mDNS_DomainNameFNV1aHash((unsigned __int8 *)(v2 + 356));
    *(void *)__tp = 0LL;
    *(void *)&__tp[8] = 0LL;
    clock_gettime(_CLOCK_MONOTONIC_RAW, (timespec *)__tp);
    int v25 = *(_DWORD *)__tp - *(_DWORD *)(a1 + 188);
    *(_DWORD *)__tp = 67109632;
    *(_DWORD *)&__tp[4] = v23;
    *(_WORD *)&__tp[8] = 1024;
    *(_DWORD *)&__tp[10] = v24;
    *(_WORD *)&__tp[14] = 1024;
    *(_DWORD *)&__tp[16] = v25;
    uint32_t v26 = "[R%u] DNSServiceQueryRecord STOP -- name hash: %x, duration: %{mdns:time_duration}u";
    int v27 = v22;
    uint32_t v28 = 20;
LABEL_51:
    _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, v26, __tp, v28);
    goto LABEL_52;
  }

  if (!gSensitiveLoggingEnabled
    || (v4 ? (uint64_t v6 = mDNSLogCategory_mDNS) : (uint64_t v6 = mDNSLogCategory_Default), v6 == mDNSLogCategory_State))
  {
    if (v4) {
      char v7 = (os_log_s *)mDNSLogCategory_mDNS;
    }
    else {
      char v7 = (os_log_s *)mDNSLogCategory_Default;
    }
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      int v47 = v5;
      int v18 = *(_DWORD *)(a1 + 184);
      uint64_t v19 = (_BYTE *)(v2 + 356);
      if (v2 == -612)
      {
LABEL_24:
        while (v19)
        {
          uint64_t v20 = *v19;
          if (!*v19)
          {
            int v29 = (unsigned __int16)((_WORD)v19 - (_WORD)v3 + 1);
            goto LABEL_46;
          }

          v19 += v20 + 1;
          if (v2 != -612) {
            goto LABEL_23;
          }
        }
      }

      else
      {
LABEL_23:
      }

      int v29 = 257;
LABEL_46:
      int v30 = *(_DWORD *)(a1 + 232);
      int v31 = *(_DWORD *)(a1 + 236);
      int v32 = *(_DWORD *)(a1 + 172);
      int v33 = mDNS_DomainNameFNV1aHash((unsigned __int8 *)(v2 + 356));
      *(void *)__tp = 0LL;
      *(void *)&__tp[8] = 0LL;
      clock_gettime(_CLOCK_MONOTONIC_RAW, (timespec *)__tp);
      int v34 = *(_DWORD *)__tp - *(_DWORD *)(a1 + 188);
      *(_DWORD *)__tp = 67111683;
      *(_DWORD *)&__tp[4] = v18;
      *(_WORD *)&__tp[8] = 2160;
      *(void *)&__tp[10] = 1752392040LL;
      *(_WORD *)&_BYTE __tp[18] = 1040;
      int v49 = v29;
      __int16 v50 = 2101;
      uint64_t v51 = v3;
      __int16 v52 = 1024;
      int v53 = v47;
      __int16 v54 = 1024;
      int v55 = v30;
      __int16 v56 = 1024;
      int v57 = v31;
      __int16 v58 = 1024;
      int v59 = v32;
      __int16 v60 = 2082;
      uint64_t v61 = a1 + 240;
      __int16 v62 = 1024;
      int v63 = v33;
      __int16 v64 = 1024;
      int v65 = v34;
      uint32_t v26 = "[R%u] DNSServiceQueryRecord STOP -- qname: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P, qtype: %{m"
            "dns:rrtype}d, flags: 0x%X, interface index: %d, client pid: %d (%{public}s), name hash: %x, duration: %{mdns"
            ":time_duration}u";
      goto LABEL_50;
    }
  }

  else
  {
    if (v4) {
      char v7 = (os_log_s *)mDNSLogCategory_mDNS;
    }
    else {
      char v7 = (os_log_s *)mDNSLogCategory_Default_redacted;
    }
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      int v15 = *(_DWORD *)(a1 + 184);
      uint64_t v16 = (_BYTE *)(v2 + 356);
      if (v2 == -612)
      {
LABEL_13:
        while (v16)
        {
          uint64_t v17 = *v16;
          if (!*v16)
          {
            int v35 = (unsigned __int16)((_WORD)v16 - (_WORD)v3 + 1);
            goto LABEL_49;
          }

          v16 += v17 + 1;
          if (v2 != -612) {
            goto LABEL_12;
          }
        }
      }

      else
      {
LABEL_12:
      }

      int v35 = 257;
LABEL_49:
      int v36 = *(_DWORD *)(a1 + 232);
      int v37 = *(_DWORD *)(a1 + 236);
      int v38 = *(_DWORD *)(a1 + 172);
      int v39 = mDNS_DomainNameFNV1aHash((unsigned __int8 *)(v2 + 356));
      *(void *)__tp = 0LL;
      *(void *)&__tp[8] = 0LL;
      clock_gettime(_CLOCK_MONOTONIC_RAW, (timespec *)__tp);
      int v40 = *(_DWORD *)__tp - *(_DWORD *)(a1 + 188);
      *(_DWORD *)__tp = 67111683;
      *(_DWORD *)&__tp[4] = v15;
      *(_WORD *)&__tp[8] = 2160;
      *(void *)&__tp[10] = 1752392040LL;
      *(_WORD *)&_BYTE __tp[18] = 1040;
      int v49 = v35;
      __int16 v50 = 2101;
      uint64_t v51 = v3;
      __int16 v52 = 1024;
      int v53 = v5;
      __int16 v54 = 1024;
      int v55 = v36;
      __int16 v56 = 1024;
      int v57 = v37;
      __int16 v58 = 1024;
      int v59 = v38;
      __int16 v60 = 2082;
      uint64_t v61 = a1 + 240;
      __int16 v62 = 1024;
      int v63 = v39;
      __int16 v64 = 1024;
      int v65 = v40;
      uint32_t v26 = "[R%u] DNSServiceQueryRecord STOP -- qname: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P, qtype: %{m"
            "dns:rrtype}d, flags: 0x%X, interface index: %d, client pid: %d (%{public}s), name hash: %x, duration: %{mdns"
            ":time_duration}u";
LABEL_50:
      int v27 = v7;
      uint32_t v28 = 80;
      goto LABEL_51;
    }
  }

LABEL_52:
  QueryRecordClientRequestStop(*(void *)(a1 + 128), v8, v9, v10, v11, v12, v13, v14, v46);
  uint64_t v41 = *(void *)(a1 + 8);
  if (v41)
  {
    uint64_t v42 = *(unsigned int *)(a1 + 236);
    if ((_DWORD)v42)
    {
      if (AWDLInterfaceID && AWDLInterfaceID == v42)
      {
        int v43 = 1;
      }

      else
      {
        if (WiFiAwareInterfaceID) {
          BOOL v44 = WiFiAwareInterfaceID == v42;
        }
        else {
          BOOL v44 = 0;
        }
        int v43 = v44;
      }
    }

    else
    {
      int v43 = (*(unsigned __int8 *)(a1 + 234) >> 4) & 1;
    }

    bzero(__tp, 0x3F1uLL);
    service_type_from_domain_name = _mdns_get_service_type_from_domain_name(v3, __tp);
    _mdns_powerlog_bonjour_event(9u, v43, (const char *)(a1 + 240), (const char *)service_type_from_domain_name, v41);
    *(void *)(a1 + 8) = 0LL;
  }

  int v33 = (void *)(a2 + 24);
  do
  {
    int v34 = v33;
    int v33 = (void *)*v33;
  }

  while (v33);
  *(void *)(a3 + 104) = a2 + 2408;
  int v35 = mDNS_Register_internal(a1, a3 + 16);
  if (!(_DWORD)v35) {
    os_log_s *v34 = a3;
  }
  mDNS_Unlock_(a1, (uint64_t)"mDNS_AddRecordToService", 17596);
  return v35;
}

    __break(1u);
LABEL_53:
    dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_48);
LABEL_21:
    int v22 = (os_log_s *)_mdns_resolver_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_DEFAULT))
    {
      int v23 = *(const char **)(a4 + 128);
      if (!v23) {
        int v23 = "";
      }
      int v24 = *((_DWORD *)v13 + 2);
      int v25 = *((_DWORD *)v13 + 3);
      int v36 = 136447234;
      int v37 = v23;
      int v38 = 1024;
      *(_DWORD *)int v39 = v24;
      *(_WORD *)&v39[4] = 1024;
      *(_DWORD *)&v39[6] = v25;
      int v40 = 2112;
      uint64_t v41 = a2;
      uint64_t v42 = 1024;
      int v43 = v12;
      _os_log_impl( (void *)&_mh_execute_header,  v22,  OS_LOG_TYPE_DEFAULT,  "%{public}sNo response (%u/%u) from server %@ for qtype %{mdns:rrtype}d",  (uint8_t *)&v36,  0x28u);
    }

  if (setsockopt(v14, 0xFFFF, 0x10000, &v52, 4u))
  {
    if (*__error())
    {
      int v27 = *__error();
      if (!v27) {
        goto LABEL_61;
      }
    }

    else
    {
      int v27 = -6700;
    }

    if (_mdns_resolver_log_s_once != -1) {
      dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_48);
    }
    uint32_t v28 = (os_log_s *)_mdns_resolver_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_ERROR))
    {
      v53[0].val[0] = 67109120;
      v53[0].val[1] = v27;
      _os_log_error_impl( (void *)&_mh_execute_header,  v28,  OS_LOG_TYPE_ERROR,  "setsockopt() for SOL_SOCKET/SO_NOWAKEFROMSLEEP failed %{darwin.errno}d",  (uint8_t *)v53,  8u);
    }
  }

  *(_BYTE *)(v3 + 7memset(v45, 0, 20) = 0;
  int v27 = *(_BYTE **)(v3 + 656);
  uint32_t v28 = v27;
  if (v27 == (_BYTE *)-256LL)
  {
LABEL_54:
    while (v28)
    {
      int v29 = *v28;
      if (!*v28)
      {
        int v30 = (_WORD)v28 - (_WORD)v27 + 1;
        if (v30 > 0x100u) {
          break;
        }
        memcpy((void *)(v2 + 356), v27, v30);
        goto LABEL_62;
      }

      v28 += v29 + 1;
      if (v27 != (_BYTE *)-256LL) {
        goto LABEL_53;
      }
    }
  }

  else
  {
LABEL_53:
    if (v28 < v27 + 256) {
      goto LABEL_54;
    }
  }

  *(_BYTE *)(v2 + 356) = 0;
LABEL_62:
  *(_BYTE *)(v2 + 626) = 2;
  *(_OWORD *)(v2 + 340) = *(_OWORD *)(v3 + 728);
  if (*(_BYTE *)(v2 + 621) && *(int *)(v3 + 692) >= 1)
  {
    *(_DWORD *)(v3 + 692) = *(_DWORD *)(v3 + 696);
    SearchDomaiuint64_t n = NextSearchDomain(v3, (uint64_t)v27, v11, v12, v13, v14, v15, v16);
  }

  else
  {
    SearchDomaiuint64_t n = 0LL;
  }

  return QueryRecordOpRestartUnicastQuestion(v3, v2, SearchDomain);
}

void mDNS_StopQuery(unsigned int *a1, uint64_t a2)
{
}

uint64_t mDNS_StopQuery_internal(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 144);
  if (v4 && *(_BYTE *)(v4 + 24))
  {
    char v5 = gSensitiveLoggingEnabled;
    uint64_t v6 = (os_log_s *)mDNSLogCategory_DNSSEC;
    if (mDNSLogCategory_DNSSEC == mDNSLogCategory_State) {
      char v5 = 0;
    }
    if (!*(_BYTE *)(a2 + 635))
    {
      if ((v5 & 1) != 0)
      {
        uint64_t v6 = (os_log_s *)mDNSLogCategory_DNSSEC_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC_redacted, OS_LOG_TYPE_FAULT)) {
          goto LABEL_29;
        }
      }

      else if (!os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC, OS_LOG_TYPE_FAULT))
      {
        goto LABEL_29;
      }

      *(_DWORD *)buf = 136447234;
      *(void *)unint64_t v169 = "question->enableDNSSEC";
      *(_WORD *)&v169[8] = 2082;
      *(void *)&v169[10] = "";
      *(_WORD *)&v169[18] = 2082;
      *(void *)&v169[20] = "/Library/Caches/com.apple.xbs/Sources/mDNSResponder/mDNSMacOSX/dnssec_v2/dnssec.c";
      *(_WORD *)&v169[28] = 1024;
      *(_DWORD *)&v169[30] = 126;
      *(_WORD *)&v169[34] = 2048;
      *(void *)&v169[36] = 0LL;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_FAULT,  "AssertMacros: %{public}s, %{public}s file: %{public}s, line: %d, value: %ld",  buf,  0x30u);
      goto LABEL_29;
    }

    if ((v5 & 1) != 0)
    {
      uint64_t v6 = (os_log_s *)mDNSLogCategory_DNSSEC_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC_redacted, OS_LOG_TYPE_DEBUG))
      {
        unsigned int v7 = bswap32(*(unsigned __int16 *)(a2 + 320)) >> 16;
        uint64_t v8 = (_BYTE *)(a2 + 356);
        if (a2 == -612)
        {
LABEL_10:
          while (v8)
          {
            uint64_t v9 = *v8;
            if (!*v8)
            {
              unsigned __int16 v12 = (_WORD)v8 - (a2 + 356) + 1;
              goto LABEL_27;
            }

            v8 += v9 + 1;
            if (a2 != -612) {
              goto LABEL_9;
            }
          }
        }

        else
        {
LABEL_9:
        }

        unsigned __int16 v12 = 257;
LABEL_27:
        int v13 = v12;
        uint64_t v14 = DNSTypeName(*(unsigned __int16 *)(a2 + 322));
        *(_DWORD *)buf = 67110403;
        *(_DWORD *)unint64_t v169 = v7;
        *(_WORD *)&v169[4] = 2160;
        *(void *)&v169[6] = 1752392040LL;
        *(_WORD *)&v169[14] = 1040;
        *(_DWORD *)&v169[16] = v13;
        *(_WORD *)&v169[20] = 2101;
        *(void *)&v169[22] = a2 + 356;
        *(_WORD *)&v169[30] = 2160;
        *(void *)&v169[32] = 1752392040LL;
        *(_WORD *)&v169[40] = 2085;
        *(void *)&v169[42] = v14;
        _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEBUG,  "[Q%u] Stopping Primary DNSSEC question - qname: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P, qtype: %{sensitive, mask.hash}s",  buf,  0x36u);
      }
    }

    else if (os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC, OS_LOG_TYPE_DEBUG))
    {
      unsigned int v7 = bswap32(*(unsigned __int16 *)(a2 + 320)) >> 16;
      uint64_t v10 = (_BYTE *)(a2 + 356);
      if (a2 == -612)
      {
LABEL_18:
        while (v10)
        {
          uint64_t v11 = *v10;
          if (!*v10)
          {
            unsigned __int16 v12 = (_WORD)v10 - (a2 + 356) + 1;
            goto LABEL_27;
          }

          v10 += v11 + 1;
          if (a2 != -612) {
            goto LABEL_17;
          }
        }
      }

      else
      {
LABEL_17:
      }

      unsigned __int16 v12 = 257;
      goto LABEL_27;
    }

    uint64_t v15 = *(void *)(*(void *)(a2 + 144) + 16LL);
    *(void *)(a2 + 152) = *(void *)(v15 + 40);
    *(_BYTE *)(a2 + 615) = *(_BYTE *)(v15 + 36);
  }

LABEL_273:
    uint64_t v132 = DNSTypeName(*(unsigned __int16 *)(a2 + 322));
    *(_DWORD *)buf = 67110403;
    *(_DWORD *)unint64_t v169 = v24;
    *(_WORD *)&v169[4] = 1024;
    *(_DWORD *)&v169[6] = v37;
    *(_WORD *)&v169[10] = 2160;
    *(void *)&v169[12] = 1752392040LL;
    *(_WORD *)&v169[20] = 1040;
    *(_DWORD *)&v169[22] = v105;
    *(_WORD *)&v169[26] = 2101;
    *(void *)&v169[28] = a2 + 356;
    *(_WORD *)&v169[36] = 2082;
    *(void *)&v169[38] = v132;
    _os_log_impl( (void *)&_mh_execute_header,  v38,  OS_LOG_TYPE_FAULT,  "[R%u->Q%u] mDNS_StopQuery_internal: Question %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%{public}s) no t found in active list.",  buf,  0x32u);
    return v36;
  }

  void *v29 = *v28;
  unint64_t v32 = *(void *)(a2 + 136) + 5LL;
  BOOL v33 = v32 > 3 || v32 == 1;
  if (v33 && !*(_WORD *)(a2 + 320))
  {
    int v42 = *(_DWORD *)(a1 + 19852);
    if (v42 + *(_DWORD *)(a1 + 19848) == 1)
    {
      unsigned int v43 = *(_DWORD *)(a1 + 64) + 60000;
      if (v43 <= 1) {
        unsigned int v43 = 1;
      }
      *(_DWORD *)(a1 + 116) = v43;
    }

    *(_DWORD *)(a1 + 19852) = v42 - 1;
  }

  if (!v24)
  {
    int v34 = (os_log_s *)mDNSLogCategory_mDNS;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_80;
      }
      goto LABEL_79;
    }

    int v34 = (os_log_s *)mDNSLogCategory_mDNS_redacted;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
    {
LABEL_79:
      unsigned int v45 = bswap32(*(unsigned __int16 *)(a2 + 320)) >> 16;
      int v46 = mDNS_DomainNameFNV1aHash((unsigned __int8 *)(a2 + 356));
      *(_DWORD *)buf = 67109376;
      *(_DWORD *)unint64_t v169 = v45;
      *(_WORD *)&v169[4] = 1024;
      *(_DWORD *)&v169[6] = v46;
      _os_log_impl( (void *)&_mh_execute_header,  v34,  OS_LOG_TYPE_DEFAULT,  "[Q%u] mDNS_StopQuery_internal STOP -- name hash: %x",  buf,  0xEu);
    }
  }

LABEL_80:
  uint64_t v47 = *(void *)(a2 + 40);
  unsigned int v48 = &unk_100164000;
  if (!v47)
  {
    uint64_t v53 = *v23;
    if (!*v23) {
      goto LABEL_224;
    }
    uint64_t v54 = 0LL;
    uint64_t v55 = a2 + 284;
    __int16 v56 = (void *)(a2 + 308);
    while (1)
    {
      if (*(void *)(v53 + 40) != a2) {
        goto LABEL_180;
      }
      *(void *)(v53 + 40) = v54;
      if (v54) {
        goto LABEL_180;
      }
      *(_OWORD *)(v53 + 208) = *(_OWORD *)(a2 + 208);
      *(_DWORD *)(v53 + 224) = *(_DWORD *)(a2 + 224);
      *(_WORD *)(v53 + 332) = *(_WORD *)(a2 + 332);
      *(_DWORD *)(v53 + 256) = *(_DWORD *)(a2 + 256);
      *(void *)(v53 + 104) = *(void *)(a2 + 104);
      __int128 v57 = *(_OWORD *)v55;
      *(_DWORD *)(v53 + 300) = *(_DWORD *)(v55 + 16);
      *(_OWORD *)(v53 + 284) = v57;
      *(_WORD *)(v53 + 316) = *(_WORD *)(a2 + 316);
      __int16 v58 = *(void **)(a2 + 80);
      if (v58) {
        os_retain(v58);
      }
      int v59 = *(void **)(v53 + 80);
      if (v59) {
        os_release(v59);
      }
      *(void *)(v53 + 80) = *(void *)(a2 + 80);
      __int16 v60 = *(void **)(a2 + 80);
      if (v60)
      {
        os_release(v60);
        *(void *)(a2 + 80) = 0LL;
      }

      uint64_t v61 = *(void *)(v53 + 96);
      if (v61)
      {
        mdns_client_invalidate(v61);
        os_release(*(void **)(v53 + 96));
        *(void *)(v53 + 96) = 0LL;
      }

      __int16 v62 = *(void **)(a2 + 96);
      if (v62)
      {
        os_retain(v62);
        int v63 = *(void **)(v53 + 96);
        if (v63) {
          os_release(v63);
        }
      }

      *(void *)(v53 + 96) = *(void *)(a2 + 96);
      __int16 v64 = *(void **)(a2 + 96);
      if (v64)
      {
        os_release(v64);
        *(void *)(a2 + 96) = 0LL;
      }

      *(void *)(v53 + 192) = *(void *)(a2 + 192);
      *(void *)(a2 + 192) = 0LL;
      uint64_t v65 = *(void *)(a2 + 144);
      if (v65)
      {
        if (*(_BYTE *)(v65 + 24)) {
          break;
        }
      }

    dispatch_once(&_mdns_crypto_log_s_once, &__block_literal_global_115);
    goto LABEL_19;
  }

  uint64_t v14 = size;
  uint64_t v15 = (unsigned __int8 *)calloc(1uLL, size);
  if (!v15)
  {
LABEL_79:
    __break(1u);
    goto LABEL_80;
  }

  uint64_t v16 = v15;
  applier[0] = _NSConcreteStackBlock;
  applier[1] = 0x40000000LL;
  applier[2] = __mdns_decrypt_oblivious_response_block_invoke;
  applier[3] = &__block_descriptor_tmp_3;
  applier[4] = v15;
  uint64_t v17 = dispatch_data_apply(a1, applier);
  if (*v16 != 2)
  {
    if (_mdns_crypto_log_s_once != -1) {
      dispatch_once(&_mdns_crypto_log_s_once, &__block_literal_global_115);
    }
    BOOL v31 = _mdns_crypto_log_s_log;
    if (!os_log_type_enabled((os_log_t)_mdns_crypto_log_s_log, OS_LOG_TYPE_ERROR)) {
      goto LABEL_70;
    }
    unint64_t v32 = *v16;
    *(_DWORD *)buf = 67109120;
    LODWORD(v75) = v32;
    uint32_t v26 = "Invalid message type %u";
LABEL_30:
    BOOL v27 = (os_log_s *)v31;
    uint32_t v28 = 8;
LABEL_31:
    _os_log_error_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_ERROR, v26, buf, v28);
LABEL_70:
    uint64_t v54 = v16;
LABEL_71:
    free(v54);
    return 0LL;
  }

  __size = v12;
  uint64_t v18 = *(unsigned __int16 *)(v16 + 1);
  uint64_t v19 = __rev16(v18);
  if (v14 <= v19 + 5 + v11)
  {
    if (_mdns_crypto_log_s_once != -1) {
      dispatch_once(&_mdns_crypto_log_s_once, &__block_literal_global_115);
    }
    BOOL v31 = _mdns_crypto_log_s_log;
    if (!os_log_type_enabled((os_log_t)_mdns_crypto_log_s_log, OS_LOG_TYPE_ERROR)) {
      goto LABEL_70;
    }
    *(_DWORD *)buf = 67109120;
    LODWORD(v75) = v19;
    uint32_t v26 = "Invalid response nonce length %hu";
    goto LABEL_30;
  }

  __int128 v71 = v10;
  uint64_t v20 = &v16[v19 + 3];
  int v22 = *(unsigned __int16 *)v20;
  uint64_t v21 = (unsigned __int16 *)(v20 + 2);
  int v23 = bswap32(v22) >> 16;
  if (v14 != v19 + 5 + v23)
  {
    if (_mdns_crypto_log_s_once != -1) {
      dispatch_once(&_mdns_crypto_log_s_once, &__block_literal_global_115);
    }
    BOOL v33 = _mdns_crypto_log_s_log;
    if (!os_log_type_enabled((os_log_t)_mdns_crypto_log_s_log, OS_LOG_TYPE_ERROR)) {
      goto LABEL_70;
    }
    *(_DWORD *)buf = 134218752;
    uint64_t v75 = v14;
    uint64_t v76 = 2048;
    int v77 = v19 + 3;
    int v78 = 2048;
    *(void *)uint64_t v79 = 2LL;
    *(_WORD *)&v79[8] = 2048;
    *(void *)&v79[10] = v23;
    uint32_t v26 = "Invalid ciphertext length: %zu != %zu + %zu + %zu";
    BOOL v27 = (os_log_s *)v33;
    uint32_t v28 = 42;
    goto LABEL_31;
  }

  int v24 = v23 - v11;
  if (v24 <= 3)
  {
    if (_mdns_crypto_log_s_once != -1) {
      dispatch_once(&_mdns_crypto_log_s_once, &__block_literal_global_115);
    }
    uint64_t v25 = _mdns_crypto_log_s_log;
    if (!os_log_type_enabled((os_log_t)_mdns_crypto_log_s_log, OS_LOG_TYPE_ERROR)) {
      goto LABEL_70;
    }
    *(_DWORD *)buf = 134217984;
    uint64_t v75 = v24;
    uint32_t v26 = "Invalid plaintext length: %zu";
    BOOL v27 = (os_log_s *)v25;
    uint32_t v28 = 12;
    goto LABEL_31;
  }

  unsigned int v67 = v21;
  unsigned int v68 = v19 + 3;
  __int128 v70 = ccsha256_di(v17);
  if (a5 + v19 == -2LL) {
    goto LABEL_79;
  }
  uint64_t v69 = v24;
  int v34 = (char *)calloc(1uLL, a5 + v19 + 2);
  if (!v34) {
    goto LABEL_79;
  }
  int v35 = v34;
  memcpy(v34, a4, a5);
  *(_WORD *)&v35[a5] = v18;
  memcpy(&v35[a5 + 2], v16 + 3, v19);
  if (!__size) {
    goto LABEL_79;
  }
  uint64_t v36 = calloc(1uLL, __size);
  if (!v36) {
    goto LABEL_79;
  }
  unsigned int v37 = v36;
  if (cchpke_initiator_export(a2, 13LL, "odoh response", __size, v36))
  {
    if (_mdns_crypto_log_s_once != -1) {
      dispatch_once(&_mdns_crypto_log_s_once, &__block_literal_global_115);
    }
    int v38 = (os_log_s *)_mdns_crypto_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_crypto_log_s_log, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_ERROR, "cchpke_initiator_export failed", buf, 2u);
    }

    free(v37);
    int v39 = v35;
LABEL_69:
    free(v39);
    goto LABEL_70;
  }

  if (!v71) {
    goto LABEL_79;
  }
  int v40 = calloc(1uLL, v71);
  if (!v40) {
    goto LABEL_79;
  }
  uint64_t v41 = v40;
  int v42 = cchkdf_extract(v70, a5 + v19 + 2, v35, __size, v37, v40);
  free(v37);
  free(v35);
  if (v42)
  {
    if (_mdns_crypto_log_s_once != -1) {
      dispatch_once(&_mdns_crypto_log_s_once, &__block_literal_global_115);
    }
    unsigned int v43 = (os_log_s *)_mdns_crypto_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_crypto_log_s_log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 67109120;
      LODWORD(v75) = v42;
      _os_log_error_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_ERROR, "Secret extract error: %d", buf, 8u);
    }

    int v39 = v41;
    goto LABEL_69;
  }

  BOOL v44 = calloc(1uLL, __size);
  if (!v44) {
    goto LABEL_79;
  }
  unsigned int v45 = v44;
  int v46 = cchkdf_expand(v70, v71, v41, 8LL, "odoh key", __size, v44);
  if (v46)
  {
    uint64_t v47 = v46;
    if (_mdns_crypto_log_s_once != -1) {
      dispatch_once(&_mdns_crypto_log_s_once, &__block_literal_global_115);
    }
    unsigned int v48 = (os_log_s *)_mdns_crypto_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_crypto_log_s_log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 67109120;
      LODWORD(v75) = v47;
      _os_log_error_impl((void *)&_mh_execute_header, v48, OS_LOG_TYPE_ERROR, "Secret key expand error: %d", buf, 8u);
    }

    free(v41);
    int v39 = v45;
    goto LABEL_69;
  }

  int v49 = cchpke_params_sizeof_aead_nonce(v9);
  if (!v49) {
    goto LABEL_79;
  }
  __int16 v50 = v49;
  uint64_t v51 = calloc(1uLL, v49);
  if (!v51) {
    goto LABEL_79;
  }
  uint64_t v52 = cchkdf_expand(v70, v71, v41, 10LL, "odoh nonce", v50, v51);
  free(v41);
  if (v52)
  {
    if (_mdns_crypto_log_s_once != -1) {
      dispatch_once(&_mdns_crypto_log_s_once, &__block_literal_global_115);
    }
    uint64_t v53 = (os_log_s *)_mdns_crypto_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_crypto_log_s_log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 67109120;
      LODWORD(v75) = v52;
      _os_log_error_impl((void *)&_mh_execute_header, v53, OS_LOG_TYPE_ERROR, "Secret nonce expand error: %d", buf, 8u);
    }

    free(v45);
    int v39 = v51;
    goto LABEL_69;
  }

  __int16 v56 = (unsigned __int16 *)calloc(1uLL, v69);
  if (!v56) {
    goto LABEL_79;
  }
  __int128 v57 = v56;
  __int16 v58 = ccaes_gcm_decrypt_mode();
  int v59 = ccgcm_one_shot(v58, __size, v45, v50, v51, v68, v16, v69, v67, v57, v11, (char *)v67 + v69);
  free(v45);
  free(v51);
  free(v16);
  if (v59)
  {
    if (_mdns_crypto_log_s_once != -1) {
      dispatch_once(&_mdns_crypto_log_s_once, &__block_literal_global_115);
    }
    __int16 v60 = _mdns_crypto_log_s_log;
    if (!os_log_type_enabled((os_log_t)_mdns_crypto_log_s_log, OS_LOG_TYPE_ERROR)) {
      goto LABEL_87;
    }
    *(_WORD *)buf = 0;
    uint64_t v61 = "Decrypt error: decrypt_error";
    __int16 v62 = (os_log_s *)v60;
    int v63 = 2;
LABEL_86:
    _os_log_error_impl((void *)&_mh_execute_header, v62, OS_LOG_TYPE_ERROR, v61, buf, v63);
LABEL_87:
    uint64_t v54 = v57;
    goto LABEL_71;
  }

  __int16 v64 = bswap32(*v57) >> 16;
  if (v69 < v64 + 4)
  {
    if (_mdns_crypto_log_s_once != -1) {
      dispatch_once(&_mdns_crypto_log_s_once, &__block_literal_global_115);
    }
    uint64_t v65 = _mdns_crypto_log_s_log;
    if (!os_log_type_enabled((os_log_t)_mdns_crypto_log_s_log, OS_LOG_TYPE_ERROR)) {
      goto LABEL_87;
    }
    *(_DWORD *)buf = 134218752;
    uint64_t v75 = v69;
    uint64_t v76 = 2048;
    int v77 = 2LL;
    int v78 = 1024;
    *(_DWORD *)uint64_t v79 = v64;
    *(_WORD *)&v79[4] = 2048;
    *(void *)&v79[6] = 2LL;
    uint64_t v61 = "Invalid plaintext length: %zu < %zu + %hu + %zu";
    __int16 v62 = (os_log_s *)v65;
    int v63 = 38;
    goto LABEL_86;
  }

  __int128 v66 = dispatch_data_create(v57 + 1, v64, 0LL, 0LL);
  free(v57);
  return v66;
}

  if (dword_100158BC8) {
    DiscardDeregistrations((uint64_t)mDNSStorage);
  }
  mDNS_Unlock_((uint64_t)mDNSStorage, (uint64_t)"mDNS_StartExit", 19299);
  BOOL v31 = (os_log_s *)mDNSLogCategory_Default;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
  {
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    *(_WORD *)buf = 0;
  }

  else
  {
    BOOL v31 = (os_log_s *)mDNSLogCategory_Default_redacted;
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    *(_WORD *)buf = 0;
  }

  _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "mDNS_StartExit: done", buf, 2u);
}

LABEL_123:
      *(_WORD *)(v53 + 3memset(v45, 0, 20) = *(_WORD *)(a2 + 320);
      *(_BYTE *)(v53 + 330) = *(_BYTE *)(a2 + 330);
      *(void *)(v53 + 272) = *(void *)(a2 + 272);
      *(_WORD *)(v53 + 328) = *(_WORD *)(a2 + 328);
      *(void *)(v53 + 308) = *v56;
      *(void *)(a2 + 104) = 0LL;
      if (!*(void *)(a2 + 40) && !*(_WORD *)(a2 + 320))
      {
        uint64_t v75 = *(void *)(a2 + 260);
        *(_DWORD *)(v53 + 268) = *(_DWORD *)(a2 + 268);
        *(void *)(v53 + 260) = v75;
      }

      if (*(void *)(v53 + 104))
      {
        uint64_t v76 = (os_log_s *)*((void *)v48 + 170);
        if (gSensitiveLoggingEnabled != 1 || v76 == (os_log_s *)mDNSLogCategory_State)
        {
          if (os_log_type_enabled(*((os_log_t *)v48 + 170), OS_LOG_TYPE_DEFAULT))
          {
            int v77 = v48;
            int v80 = (_BYTE *)(v53 + 356);
            if (v53 == -612)
            {
LABEL_140:
              while (v80)
              {
                uint64_t v81 = *v80;
                if (!*v80)
                {
                  uint64_t v82 = v16;
                  uint64_t v83 = v22;
                  unsigned __int16 v84 = (_WORD)v80 - (v53 + 356) + 1;
                  goto LABEL_149;
                }

                v80 += v81 + 1;
                if (v53 != -612) {
                  goto LABEL_139;
                }
              }
            }

            else
            {
LABEL_139:
            }

            uint64_t v82 = v16;
            uint64_t v83 = v22;
            unsigned __int16 v84 = 257;
LABEL_149:
            int v85 = v84;
            uint64_t v86 = DNSTypeName(*(unsigned __int16 *)(v53 + 322));
            *(_DWORD *)buf = 141558787;
            *(void *)unint64_t v169 = 1752392040LL;
            *(_WORD *)&v169[8] = 1040;
            *(_DWORD *)&v169[10] = v85;
            *(_WORD *)&v169[14] = 2101;
            *(void *)&v169[16] = v53 + 356;
            *(_WORD *)&v169[24] = 2082;
            *(void *)&v169[26] = v86;
            _os_log_impl( (void *)&_mh_execute_header,  v76,  OS_LOG_TYPE_DEFAULT,  "UpdateQuestionDuplicates transferred nta pointer for %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%{public}s)",  buf,  0x26u);
            unsigned int v48 = v77;
            int v22 = v83;
            uint64_t v16 = v82;
            __int16 v56 = (void *)(a2 + 308);
            uint64_t v55 = a2 + 284;
          }
        }

        else
        {
          uint64_t v76 = (os_log_s *)mDNSLogCategory_Default_redacted;
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
          {
            int v77 = v48;
            int v78 = (_BYTE *)(v53 + 356);
            if (v53 == -612)
            {
LABEL_132:
              while (v78)
              {
                uint64_t v79 = *v78;
                if (!*v78)
                {
                  uint64_t v82 = v16;
                  uint64_t v83 = v22;
                  unsigned __int16 v84 = (_WORD)v78 - (v53 + 356) + 1;
                  goto LABEL_149;
                }

                v78 += v79 + 1;
                if (v53 != -612) {
                  goto LABEL_131;
                }
              }
            }

            else
            {
LABEL_131:
            }

            uint64_t v82 = v16;
            uint64_t v83 = v22;
            unsigned __int16 v84 = 257;
            goto LABEL_149;
          }
        }

        *(void *)(*(void *)(v53 + 104) + 824LL) = v53;
      }

      if (*(void *)(a2 + 112) && mDNS_LoggingEnabled) {
        LogMsgWithLevel( *((os_log_s **)v48 + 170),  OS_LOG_TYPE_DEFAULT,  "UpdateQuestionDuplicates did not transfer tcp pointer",  v17,  v18,  v19,  v20,  v21,  v159);
      }
      if (*(_BYTE *)(a2 + 330) != 22) {
        goto LABEL_179;
      }
      uint64_t v87 = (os_log_s *)*((void *)v48 + 170);
      if (gSensitiveLoggingEnabled != 1 || v87 == (os_log_s *)mDNSLogCategory_State)
      {
        if (os_log_type_enabled(*((os_log_t *)v48 + 170), OS_LOG_TYPE_DEFAULT))
        {
          __int128 v88 = v48;
          __int128 v91 = (_BYTE *)(v53 + 356);
          if (v53 == -612)
          {
LABEL_168:
            while (v91)
            {
              uint64_t v92 = *v91;
              if (!*v91)
              {
                __int128 v93 = v16;
                __int128 v94 = v22;
                unsigned __int16 v95 = (_WORD)v91 - (v53 + 356) + 1;
                goto LABEL_177;
              }

              v91 += v92 + 1;
              if (v53 != -612) {
                goto LABEL_167;
              }
            }
          }

          else
          {
LABEL_167:
          }

          __int128 v93 = v16;
          __int128 v94 = v22;
          unsigned __int16 v95 = 257;
          goto LABEL_177;
        }
      }

      else
      {
        uint64_t v87 = (os_log_s *)mDNSLogCategory_Default_redacted;
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
        {
          __int128 v88 = v48;
          __int128 v89 = (_BYTE *)(v53 + 356);
          if (v53 == -612)
          {
LABEL_160:
            while (v89)
            {
              uint64_t v90 = *v89;
              if (!*v89)
              {
                __int128 v93 = v16;
                __int128 v94 = v22;
                unsigned __int16 v95 = (_WORD)v89 - (v53 + 356) + 1;
                goto LABEL_177;
              }

              v89 += v90 + 1;
              if (v53 != -612) {
                goto LABEL_159;
              }
            }
          }

          else
          {
LABEL_159:
          }

          __int128 v93 = v16;
          __int128 v94 = v22;
          unsigned __int16 v95 = 257;
LABEL_177:
          int v96 = v95;
          __int128 v97 = DNSTypeName(*(unsigned __int16 *)(v53 + 322));
          *(_DWORD *)buf = 141558787;
          *(void *)unint64_t v169 = 1752392040LL;
          *(_WORD *)&v169[8] = 1040;
          *(_DWORD *)&v169[10] = v96;
          *(_WORD *)&v169[14] = 2101;
          *(void *)&v169[16] = v53 + 356;
          *(_WORD *)&v169[24] = 2082;
          *(void *)&v169[26] = v97;
          _os_log_impl( (void *)&_mh_execute_header,  v87,  OS_LOG_TYPE_DEFAULT,  "UpdateQuestionDuplicates transferred LLQ state for %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%{public}s)",  buf,  0x26u);
          unsigned int v48 = v88;
          int v22 = v94;
          uint64_t v16 = v93;
          __int16 v56 = (void *)(a2 + 308);
          uint64_t v55 = a2 + 284;
        }
      }

      *(_BYTE *)(a2 + 330) = 0;
LABEL_179:
      SetNextQueryTime(a1, v53);
      uint64_t v54 = v53;
LABEL_180:
      uint64_t v53 = *(void *)(v53 + 8);
      if (!v53) {
        goto LABEL_224;
      }
    }

    __int128 v66 = (os_log_s *)mDNSLogCategory_DNSSEC;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_DNSSEC == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC, OS_LOG_TYPE_INFO))
      {
LABEL_115:
        unsigned int v67 = bswap32(*(unsigned __int16 *)(v53 + 320));
        unsigned int v68 = bswap32(*(unsigned __int16 *)(a2 + 320));
        *(_DWORD *)buf = 67109376;
        *(_DWORD *)unint64_t v169 = HIWORD(v67);
        *(_WORD *)&v169[4] = 1024;
        *(_DWORD *)&v169[6] = HIWORD(v68);
        _os_log_impl( (void *)&_mh_execute_header,  v66,  OS_LOG_TYPE_INFO,  "[Q%u->Q%u] Non-primary DNSSEC question becomes primary due to primary question cancelation.",  buf,  0xEu);
      }
    }

    else
    {
      __int128 v66 = (os_log_s *)mDNSLogCategory_DNSSEC_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC_redacted, OS_LOG_TYPE_INFO)) {
        goto LABEL_115;
      }
    }

    uint64_t v69 = *(void *)(a2 + 144);
    if (v69) {
      ++*(_DWORD *)v69;
    }
    __int128 v70 = *(void **)(v53 + 144);
    if (v70)
    {
      ref_count_obj_release(v70);
      *(void *)(v53 + 144) = 0LL;
      uint64_t v69 = *(void *)(a2 + 144);
    }

    *(void *)(v53 + 144) = v69;
    __int128 v71 = *(void **)(a2 + 144);
    if (v71)
    {
      ref_count_obj_release(v71);
      *(void *)(a2 + 144) = 0LL;
      uint64_t v69 = *(void *)(v53 + 144);
    }

    uint64_t v72 = *(void *)(v69 + 16);
    uint64_t v73 = *(void *)(v53 + 152);
    BOOL v74 = *(_BYTE *)(v53 + 615) != 0;
    *(void *)(v72 + 24) = v53;
    *(void *)(v72 + 40) = v73;
    *(_BYTE *)(v72 + 36) = v74;
    *(void *)(v53 + 152) = dnssec_query_record_result_reply;
    *(_BYTE *)(v53 + 615) = 1;
    *(_DWORD *)(v53 + 228) = *(_DWORD *)(a2 + 228);
    goto LABEL_123;
  }

  int v49 = (os_log_s *)mDNSLogCategory_Default;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
  {
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEBUG))
    {
      __int128 v98 = (_BYTE *)(a2 + 356);
      unsigned int v167 = bswap32(*(unsigned __int16 *)(a2 + 320)) >> 16;
      unsigned int v165 = bswap32(*(unsigned __int16 *)(v47 + 320)) >> 16;
      int v163 = *(_DWORD *)(a2 + 252);
      if (a2 == -612)
      {
LABEL_185:
        while (v98)
        {
          uint64_t v99 = *v98;
          if (!*v98)
          {
            unsigned __int16 v104 = (_WORD)v98 - (_WORD)v16 + 1;
            goto LABEL_212;
          }

          v98 += v99 + 1;
          if (a2 != -612) {
            goto LABEL_184;
          }
        }
      }

      else
      {
LABEL_184:
      }

      unsigned __int16 v104 = 257;
LABEL_212:
      int v112 = v104;
      __int16 v113 = DNSTypeName(*(unsigned __int16 *)(a2 + 322));
      uint64_t v114 = *(void *)(a2 + 40);
      uint64_t v115 = (_BYTE *)(v114 + 356);
      int v160 = v22;
      if (v114 == -612)
      {
LABEL_214:
        while (v115)
        {
          uint64_t v116 = *v115;
          if (!*v115)
          {
            __int128 v117 = v113;
            unsigned __int16 v118 = (_WORD)v115 - (v114 + 356) + 1;
            goto LABEL_223;
          }

          v115 += v116 + 1;
          if (v114 != -612) {
            goto LABEL_213;
          }
        }
      }

      else
      {
LABEL_213:
      }

      __int128 v117 = v113;
      unsigned __int16 v118 = 257;
LABEL_223:
      int v121 = v118;
      __int128 v122 = DNSTypeName(*(unsigned __int16 *)(v114 + 322));
      *(_DWORD *)buf = 67112195;
      *(_DWORD *)unint64_t v169 = v163;
      *(_WORD *)&v169[4] = 1024;
      *(_DWORD *)&v169[6] = v167;
      *(_WORD *)&v169[10] = 1024;
      *(_DWORD *)&v169[12] = v165;
      *(_WORD *)&v169[16] = 2048;
      *(void *)&v169[18] = a2;
      *(_WORD *)&v169[26] = 2160;
      *(void *)&v169[28] = 1752392040LL;
      *(_WORD *)&v169[36] = 1040;
      *(_DWORD *)&v169[38] = v112;
      *(_WORD *)&v169[42] = 2101;
      *(void *)&v169[44] = a2 + 356;
      __int16 v170 = 2082;
      BOOL v171 = v117;
      __int16 v172 = 2048;
      uint64_t v173 = v114;
      __int16 v174 = 2160;
      uint64_t v175 = 1752392040LL;
      __int16 v176 = 1040;
      int v177 = v121;
      __int16 v178 = 2101;
      uint64_t v179 = v114 + 356;
      __int16 v180 = 2082;
      uint64_t v181 = v122;
      _os_log_impl( (void *)&_mh_execute_header,  v49,  OS_LOG_TYPE_DEBUG,  "[R%d->DupQ%d->Q%d] UpdateQuestionDuplicates: question %p %{sensitive, mask.hash, mdnsresponder:domain_name}.*P(%{public}s) duplicate of %p %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%{public}s)",  buf,  0x70u);
      unsigned int v48 = &unk_100164000;
      int v22 = v160;
    }
  }

  else
  {
    __int16 v50 = (os_log_s *)mDNSLogCategory_Default_redacted;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEBUG))
    {
      int v166 = *(_DWORD *)(a2 + 252);
      unsigned int v164 = bswap32(*(unsigned __int16 *)(a2 + 320)) >> 16;
      unsigned int v162 = bswap32(*(unsigned __int16 *)(v47 + 320)) >> 16;
      uint64_t v51 = (_BYTE *)(a2 + 356);
      if (a2 == -612)
      {
LABEL_86:
        while (v51)
        {
          uint64_t v52 = *v51;
          if (!*v51)
          {
            unsigned __int16 v103 = (_WORD)v51 - (_WORD)v16 + 1;
            goto LABEL_203;
          }

          v51 += v52 + 1;
          if (a2 != -612) {
            goto LABEL_85;
          }
        }
      }

      else
      {
LABEL_85:
      }

      unsigned __int16 v103 = 257;
LABEL_203:
      int v161 = v103;
      int v106 = DNSTypeName(*(unsigned __int16 *)(a2 + 322));
      uint64_t v107 = *(void *)(a2 + 40);
      int v108 = (_BYTE *)(v107 + 356);
      if (v107 == -612)
      {
LABEL_205:
        while (v108)
        {
          uint64_t v109 = *v108;
          if (!*v108)
          {
            uint64_t v110 = v22;
            unsigned __int16 v111 = (_WORD)v108 - (v107 + 356) + 1;
            goto LABEL_221;
          }

          v108 += v109 + 1;
          if (v107 != -612) {
            goto LABEL_204;
          }
        }
      }

      else
      {
LABEL_204:
      }

      uint64_t v110 = v22;
      unsigned __int16 v111 = 257;
LABEL_221:
      int v119 = v111;
      __int128 v120 = DNSTypeName(*(unsigned __int16 *)(v107 + 322));
      *(_DWORD *)buf = 67112195;
      *(_DWORD *)unint64_t v169 = v166;
      *(_WORD *)&v169[4] = 1024;
      *(_DWORD *)&v169[6] = v164;
      *(_WORD *)&v169[10] = 1024;
      *(_DWORD *)&v169[12] = v162;
      *(_WORD *)&v169[16] = 2048;
      *(void *)&v169[18] = a2;
      *(_WORD *)&v169[26] = 2160;
      *(void *)&v169[28] = 1752392040LL;
      *(_WORD *)&v169[36] = 1040;
      *(_DWORD *)&v169[38] = v161;
      *(_WORD *)&v169[42] = 2101;
      *(void *)&v169[44] = a2 + 356;
      __int16 v170 = 2082;
      BOOL v171 = v106;
      __int16 v172 = 2048;
      uint64_t v173 = v107;
      __int16 v174 = 2160;
      uint64_t v175 = 1752392040LL;
      __int16 v176 = 1040;
      int v177 = v119;
      __int16 v178 = 2101;
      uint64_t v179 = v107 + 356;
      __int16 v180 = 2082;
      uint64_t v181 = v120;
      _os_log_impl( (void *)&_mh_execute_header,  v50,  OS_LOG_TYPE_DEBUG,  "[R%d->DupQ%d->Q%d] UpdateQuestionDuplicates: question %p %{sensitive, mask.hash, mdnsresponder:domain_name}.*P(%{public}s) duplicate of %p %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%{public}s)",  buf,  0x70u);
      unsigned int v48 = &unk_100164000;
      int v22 = v110;
    }
  }

LABEL_224:
  *(_DWORD *)(a2 + 212) = -1;
  if (v22)
  {
    for (CFIndex i = (void *)v22[2]; i; CFIndex i = (void *)*i)
    {
      if (i[12] == a2)
      {
        uint64_t v124 = *v23;
        if (*v23)
        {
          uint64_t v125 = 0LL;
          do
          {
            if (v124 == *(void *)(a1 + 208)) {
              break;
            }
            if (!*(void *)(v124 + 40)
              && !*(_BYTE *)(v124 + 334)
              && RecordAnswersQuestion((uint64_t)(i + 1), 0, v124, v17, v18, v19, v20, v21))
            {
              if (*(int *)(v124 + 212) >= 1)
              {
                i[12] = v124;
                goto LABEL_241;
              }

              if (!v125) {
                uint64_t v125 = v124;
              }
            }

            uint64_t v124 = *(void *)(v124 + 8);
          }

          while (v124);
          i[12] = v125;
          if (v125) {
            continue;
          }
        }

        else
        {
          i[12] = 0LL;
        }

        --*(_DWORD *)(a1 + 260);
      }

LABEL_241:
      ;
    }
  }

  if (*(void *)(a1 + 216) == a2) {
    *(void *)(a1 + 216) = *(void *)(a2 + 8);
  }
  if (*(void *)(a1 + 208) == a2) {
    *(void *)(a1 + 208) = *(void *)(a2 + 8);
  }
  if (*(void *)(a1 + 232) == a2) {
    *(void *)(a1 + 232) = *(void *)(a2 + 8);
  }
  if (*(void *)(a1 + 240) == a2)
  {
    __int128 v126 = (os_log_s *)*((void *)v48 + 170);
    if (gSensitiveLoggingEnabled != 1 || v126 == (os_log_s *)mDNSLogCategory_State)
    {
      if (os_log_type_enabled(*((os_log_t *)v48 + 170), OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v129 = v16;
        if (a2 == -612)
        {
LABEL_264:
          while (v129)
          {
            uint64_t v130 = *v129;
            if (!*v129)
            {
              unsigned __int16 v131 = (_WORD)v129 - (_WORD)v16 + 1;
              goto LABEL_276;
            }

            v129 += v130 + 1;
            if (a2 != -612) {
              goto LABEL_263;
            }
          }
        }

        else
        {
LABEL_263:
        }

        unsigned __int16 v131 = 257;
        goto LABEL_276;
      }
    }

    else
    {
      __int128 v126 = (os_log_s *)mDNSLogCategory_Default_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
      {
        __int128 v127 = v16;
        if (a2 == -612)
        {
LABEL_256:
          while (v127)
          {
            uint64_t v128 = *v127;
            if (!*v127)
            {
              unsigned __int16 v131 = (_WORD)v127 - (_WORD)v16 + 1;
              goto LABEL_276;
            }

            v127 += v128 + 1;
            if (a2 != -612) {
              goto LABEL_255;
            }
          }
        }

        else
        {
LABEL_255:
        }

        unsigned __int16 v131 = 257;
LABEL_276:
        int v133 = v131;
        uint64_t v134 = DNSTypeName(*(unsigned __int16 *)(a2 + 322));
        *(_DWORD *)buf = 141558787;
        *(void *)unint64_t v169 = 1752392040LL;
        *(_WORD *)&v169[8] = 1040;
        *(_DWORD *)&v169[10] = v133;
        *(_WORD *)&v169[14] = 2101;
        *(void *)&v169[16] = v16;
        *(_WORD *)&v169[24] = 2082;
        *(void *)&v169[26] = v134;
        _os_log_impl( (void *)&_mh_execute_header,  v126,  OS_LOG_TYPE_DEFAULT,  "mDNS_StopQuery_internal: Just deleted the current restart question: %{sensitive, mask.hash, mdnsresponder:doma in_name}.*P (%{public}s)",  buf,  0x26u);
      }
    }

    *(void *)(a1 + 240) = *(void *)(a2 + 8);
  }

  *(void *)(a2 + 8) = 0LL;
  uint64_t v135 = *(void *)(a2 + 112);
  if (v135)
  {
    DisposeTCPConn(v135);
    *(void *)(a2 + 112) = 0LL;
  }

  uint64_t v136 = *(void **)(a2 + 72);
  if (v136)
  {
    CloseSocketSet(*(void *)(a2 + 72));
    free(v136);
    *(void *)(a2 + 72) = 0LL;
  }

  uint64_t v137 = *(void **)(a2 + 104);
  if (v137)
  {
    CancelGetZoneData(a1, v137);
    *(void *)(a2 + 104) = 0LL;
  }

  uint64_t v138 = *(void *)(a2 + 96);
  if (v138)
  {
    if (*(_UNKNOWN ***)(v138 + 16) != &_mdns_querier_kind
      || *(_BYTE *)(v138 + 248)
      || (*(_WORD *)(*(void *)(v138 + 32) + 276LL) & 1) != 0
      || (CFMutableArrayRef Mutable = (const __CFSet *)_Querier_GetOrphanedQuerierSet_sOrphanedQuerierSet) == 0LL
      && (CFMutableArrayRef Mutable = CFSetCreateMutable(kCFAllocatorDefault, 0LL, (const CFSetCallBacks *)&gMDNSObjectSetCallbacks),
          (_Querier_GetOrphanedQuerierSet_sOrphanedQuerierSet = (uint64_t)Mutable) == 0)
      || CFSetGetCount(Mutable) > 9)
    {
      uint64_t v142 = *(void *)(a2 + 96);
      if (!v142) {
        goto LABEL_298;
      }
      mdns_client_invalidate(v142);
      unint64_t v143 = *(void **)(a2 + 96);
      goto LABEL_297;
    }

    CFSetAddValue(Mutable, (const void *)v138);
    uint64_t v140 = (os_log_s *)*((void *)v48 + 170);
    if (gSensitiveLoggingEnabled != 1 || v140 == (os_log_s *)mDNSLogCategory_State)
    {
      if (!os_log_type_enabled(*((os_log_t *)v48 + 170), OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_330;
      }
      int v158 = *(_DWORD *)(v138 + 232);
      *(_DWORD *)buf = 67109120;
      *(_DWORD *)unint64_t v169 = v158;
    }

    else
    {
      uint64_t v140 = (os_log_s *)mDNSLogCategory_Default_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_330;
      }
      int v141 = *(_DWORD *)(v138 + 232);
      *(_DWORD *)buf = 67109120;
      *(_DWORD *)unint64_t v169 = v141;
    }

    _os_log_impl( (void *)&_mh_execute_header,  v140,  OS_LOG_TYPE_DEFAULT,  "[Q%u] Keeping orphaned querier for up to 5 seconds",  buf,  8u);
LABEL_330:
    mdns_querier_set_time_limit_ms((void *)v138, 5000);
    unint64_t v143 = *(void **)(a2 + 96);
    if (!v143) {
      goto LABEL_298;
    }
LABEL_297:
    os_release(v143);
    *(void *)(a2 + 96) = 0LL;
  }

        unsigned __int16 v95 = -6736;
LABEL_242:
        int v108 = v95;
        if ((v63 & 1) == 0) {
          goto LABEL_264;
        }
        unsigned int v67 = 3;
        goto LABEL_251;
      }

      if (v56 && v66) {
        goto LABEL_241;
      }
      goto LABEL_250;
    }

    if (!v70 || v70 == 2) {
      goto LABEL_241;
    }
    if (v70 != 5)
    {
      if (!v66) {
        goto LABEL_250;
      }
      if (v66 != 1) {
        goto LABEL_241;
      }
      goto LABEL_204;
    }

    unsigned int v67 = 0;
    uint64_t v30 = 0;
    int v108 = -6745;
    if ((v63 & 1) != 0) {
      goto LABEL_251;
    }
  }

LABEL_298:
  unsigned int v144 = *(void **)(a2 + 80);
  if (v144)
  {
    os_release(v144);
    *(void *)(a2 + 80) = 0LL;
  }

  if (DPCFeatureEnabled_sOnce != -1) {
    dispatch_once(&DPCFeatureEnabled_sOnce, &__block_literal_global_3237);
  }
  if (DPCFeatureEnabled_sEnabled)
  {
    unsigned int v145 = *(const __CFSet **)(a2 + 192);
    if (v145)
    {
      mdns_cfset_enumerate(v145, (uint64_t)&__block_literal_global_30_3255);
      CFSetRemoveAllValues(*(CFMutableSetRef *)(a2 + 192));
      unsigned int v146 = *(const void **)(a2 + 192);
      if (v146)
      {
        CFRelease(v146);
        *(void *)(a2 + 192) = 0LL;
      }
    }
  }

  *(_DWORD *)(a2 + 268) = 0;
  *(void *)(a2 + 260) = 0LL;
  if (!DNSQuestionNeedsSensitiveLogging(a2)) {
    goto LABEL_321;
  }
  int v147 = gNumOfSensitiveLoggingEnabledQuestions;
  char v148 = gSensitiveLoggingEnabled;
  unint64_t v149 = (os_log_s *)*((void *)v48 + 170);
  if (v149 == (os_log_s *)mDNSLogCategory_State) {
    char v148 = 0;
  }
  int v150 = --gNumOfSensitiveLoggingEnabledQuestions;
  if (v147 == 1)
  {
    if ((v148 & 1) != 0)
    {
      unint64_t v149 = (os_log_s *)mDNSLogCategory_Default_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_319;
      }
    }

    else if (os_log_type_enabled(v149, OS_LOG_TYPE_DEFAULT))
    {
LABEL_319:
      unsigned int v152 = bswap32(*(unsigned __int16 *)(a2 + 320)) >> 16;
      *(_DWORD *)buf = 67109120;
      *(_DWORD *)unint64_t v169 = v152;
      _os_log_impl( (void *)&_mh_execute_header,  v149,  OS_LOG_TYPE_DEFAULT,  "[Q%u] Last question that enables sensitive logging is stopped.",  buf,  8u);
    }

    gSensitiveLoggingEnabled = 0;
    goto LABEL_321;
  }

  if ((v148 & 1) != 0)
  {
    unint64_t v149 = (os_log_s *)mDNSLogCategory_Default_redacted;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEBUG)) {
      goto LABEL_317;
    }
  }

  else if (os_log_type_enabled(v149, OS_LOG_TYPE_DEBUG))
  {
LABEL_317:
    unsigned int v151 = bswap32(*(unsigned __int16 *)(a2 + 320));
    *(_DWORD *)buf = 67109376;
    *(_DWORD *)unint64_t v169 = HIWORD(v151);
    *(_WORD *)&v169[4] = 1024;
    *(_DWORD *)&v169[6] = v150;
    _os_log_impl( (void *)&_mh_execute_header,  v149,  OS_LOG_TYPE_DEBUG,  "[Q%u] number of sensitive logging enabled questions: %u.",  buf,  0xEu);
  }

                            uint64_t v16 = (void *)a10;
                            if (!a10) {
                              uint64_t v99 = 0;
                            }
LABEL_300:
                            a1 = v878;
                            goto LABEL_301;
                          }
                        }

                        else if (v864)
                        {
                          unint64_t v143 = *(_DWORD *)(v135 + 216);
                          if (v143)
                          {
                          }
                        }
                      }
                    }
                  }
                }

                uint64_t v135 = *(void *)(v135 + 8);
                if (!v135) {
                  goto LABEL_298;
                }
              }
            }

            uint64_t v129 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(v907 + 16) + 88LL))( v907,  v102,  v103,  v104);
            uint64_t v130 = (*(uint64_t (**)(uint64_t))(*(void *)(v907 + 16) + 80LL))(v907);
            if (!v130)
            {
              uint64_t v16 = (void *)a10;
              LOBYTE(v25) = v868;
              goto LABEL_301;
            }

            unsigned __int16 v131 = v130;
            uint64_t v132 = *((unsigned __int16 *)v23 + 3);
            if (v132 != (*(unsigned int (**)(uint64_t))(*(void *)(v907 + 16) + 96LL))(v907))
            {
              uint64_t v16 = (void *)a10;
              LOBYTE(v25) = v868;
              __int128 v98 = v904;
              goto LABEL_301;
            }

            __int128 v98 = v904;
            if (*(_UNKNOWN ***)(v907 + 16) == &_mdns_querier_kind
              && (int v133 = *(unsigned __int8 *)(*(void *)(v907 + 88) + 70LL), (v133 & 4) != 0))
            {
              uint64_t v134 = (v133 >> 1) & 1;
            }

            else
            {
              uint64_t v134 = 0LL;
            }

            LOBYTE(v25) = v868;
            if (!RRTypeAnswersQuestionType((uint64_t)v23, v129, v134, v104, v105, v106, v107, v108))
            {
              uint64_t v16 = (void *)a10;
              goto LABEL_301;
            }

            uint64_t v16 = (void *)a10;
            if (SameDomainNameBytes(*((_BYTE **)v23 + 4), *(_BYTE **)(v131 + 24))) {
LABEL_242:
            }
              uint64_t v99 = 1;
LABEL_301:
            if (v896 && *((_WORD *)v23 + 2) != 47)
            {
              unsigned int v152 = *(void *)(a1 + 12648);
              if (v152)
              {
                unsigned int v153 = (os_log_s *)mDNSLogCategory_Default;
                GetRRDisplayString_rdb( (unsigned __int8 *)(v152 + 8),  (unsigned __int16 *)(*(void *)(v152 + 48) + 4LL),  v855);
                LogMsgWithLevel( v153,  OS_LOG_TYPE_DEFAULT,  "mDNSCoreReceiveResponse ERROR m->CurrentRecord already set %s",  v154,  v155,  v156,  v157,  v158,  (int)v855);
              }

              int v159 = *(void *)(a1 + 12624);
              *(void *)(a1 + 12648) = v159;
              if (v159)
              {
                while (2)
                {
                  int v160 = *(void *)v159;
                  *(void *)(a1 + 12648) = *(void *)v159;
                  if (v99)
                  {
LABEL_307:
                    int v161 = (_BYTE *)*((void *)v858 + 4);
                    unsigned int v162 = &v910;
                    do
                    {
                      unsigned int v162 = (char **)*v162;
                      if (!v162) {
                        goto LABEL_329;
                      }
                    }

                    while (!SameDomainNameBytes((_BYTE *)v162 + 20, v161));
                    int v163 = CheckTSRForAuthRecord( *(uint64_t **)(a1 + 12624),  (int *)v162 + 2,  *(_DWORD *)(v159 + 24),  *(_BYTE **)(v159 + 40));
                    if (v163)
                    {
                      if (v163 != -1)
                      {
                        __int128 v98 = v904;
                        goto LABEL_445;
                      }

                      unsigned int v164 = (os_log_s *)mDNSLogCategory_mDNS;
                      __int128 v98 = v904;
                      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
                      {
                        if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
                        {
                          __int16 v172 = *(void *)(v159 + 40);
                          if (v172)
                          {
                            uint64_t v185 = *(_BYTE **)(v159 + 40);
                            if (v172 == -256) {
                              goto LABEL_375;
                            }
LABEL_372:
                            uint64_t v186 = 257;
                            if ((unint64_t)v185 < v172 + 256 && v185)
                            {
                              while (1)
                              {
                                unint64_t v187 = *v185;
                                if (v187 > 0x3F)
                                {
LABEL_438:
                                  uint64_t v186 = 257;
                                  goto LABEL_442;
                                }

                                if (!*v185) {
                                  break;
                                }
                                v185 += v187 + 1;
                                if (v172 != -256) {
                                  goto LABEL_372;
                                }
LABEL_375:
                                if (!v185) {
                                  goto LABEL_438;
                                }
                              }

                              uint64_t v186 = (_WORD)v185 - v172 + 1;
                            }

LABEL_321:
  unsigned int v153 = *(_DWORD *)(a1 + 48);
  unsigned int v154 = *(_DWORD *)(a1 + 52) + 1;
  *(_DWORD *)(a1 + 52) = v154;
  mDNS_VerifyLockState("Drop Lock", 0, v153, v154, (uint64_t)"mDNS_StopQuery_internal", 15784);
  uint64_t v155 = *(void **)(a2 + 144);
  if (v155)
  {
    ref_count_obj_release(v155);
    *(void *)(a2 + 144) = 0LL;
  }

  mDNS_VerifyLockState( "Reclaim Lock",  0,  *(_DWORD *)(a1 + 48),  *(_DWORD *)(a1 + 52),  (uint64_t)"mDNS_StopQuery_internal",  15786);
  --*(_DWORD *)(a1 + 52);
  unsigned int v156 = *(void **)(a2 + 56);
  if (!v156) {
    return 0LL;
  }
  free(v156);
  uint64_t v36 = 0LL;
  *(void *)(a2 + 56) = 0LL;
  return v36;
}

_BYTE *putQuestion( unint64_t a1, unint64_t a2, unint64_t a3, unsigned __int8 *a4, unint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  __int16 v8 = a6;
  __int16 v9 = a5;
  BOOL result = putDomainNameAsLabels(a1, a2, a3, a4, a5, a6, a7, a8);
  if (result)
  {
    int v13 = result;
    result += 4;
    if ((unint64_t)result >= a3)
    {
      return 0LL;
    }

    else
    {
      *int v13 = HIBYTE(v9);
      v13[1] = v9;
      v13[2] = HIBYTE(v8);
      v13[3] = v8;
      ++*(_WORD *)(a1 + 4);
    }
  }

  return result;
}

_BYTE *putDomainNameAsLabels( unint64_t a1, unint64_t a2, unint64_t a3, unsigned __int8 *a4, unint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a2)
  {
    unsigned int v8 = *a4;
    if (*a4)
    {
      uint64_t v10 = (_BYTE *)a2;
      uint64_t v11 = (char *)a4;
      while (1)
      {
        if (v8 >= 0x40)
        {
          LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "Malformed domain name %##s (label more than 63 bytes)",  (uint64_t)a4,  a5,  a6,  a7,  a8,  (int)a4);
          return 0LL;
        }

        if (a1 && v8)
        {
          unsigned __int16 v12 = (unsigned __int8 *)(a2 - v8);
LABEL_9:
          while ((unint64_t)(v12 - 1) >= a1)
          {
            int v13 = v12--;
            if (*(v13 - 1) == v8 && *v13 == v11[1] && (unint64_t)&v12[v8] < a2)
            {
              LODWORD(v15) = v8;
              uint64_t v16 = v12;
              uint64_t v17 = v11;
LABEL_16:
              uint64_t v18 = v15 + 1LL;
              a5 = (unint64_t)v16;
              a6 = (uint64_t)v17;
              a7 = v18;
              while (1)
              {
                unsigned int v19 = *(unsigned __int8 *)a5++;
                a8 = v19;
                int v20 = *(unsigned __int8 *)a6++;
                if ((_DWORD)a8 != v20) {
                  break;
                }
                if (!--a7)
                {
                  v16 += v18;
                  v17 += v18;
                  uint64_t v15 = *v17;
                  a5 = *v16;
                  if (!*v17)
                  {
                    if (*v16) {
                      goto LABEL_9;
                    }
                    if ((unint64_t)(v10 + 2) <= a3)
                    {
                      __int16 v23 = (_WORD)v12 - a1;
                      *uint64_t v10 = HIBYTE(v23) | 0xC0;
                      v10[1] = v23;
                      return v10 + 2;
                    }

                    return 0LL;
                  }

                  if (a5 < 0x40
                    || a5 >= 0xC0
                    && (a6 = (uint64_t)(v16 + 1), (unint64_t)(v16 + 1) < a2)
                    && (a6 = v16[1], a5 = a1 + ((a5 & 0x3F) << 8) + a6, (unint64_t)v16 >= a5)
                    && (a6 = *(unsigned __int8 *)a5, uint64_t v16 = (unsigned __int8 *)a5, a6 <= 0x3F))
                  {
                    a5 = (unint64_t)&v16[v15];
                  }

                  goto LABEL_9;
                }
              }
            }
          }
        }

        *v10++ = v8;
        ++v11;
        do
        {
          char v21 = *v11++;
          *v10++ = v21;
          --v8;
        }

        while (v8);
        unsigned int v8 = *v11;
        if (!*v11) {
          goto LABEL_36;
        }
      }

      LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "Malformed domain name %##s (more than 256 bytes)",  (uint64_t)a4,  a5,  a6,  a7,  a8,  (int)a4);
    }

    else
    {
      uint64_t v10 = (_BYTE *)a2;
      if (a2 < a3)
      {
LABEL_36:
        *uint64_t v10 = 0;
        return v10 + 1;
      }
    }
  }

  else
  {
    LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "putDomainNameAsLabels %##s ptr is null",  (uint64_t)a4,  a5,  a6,  a7,  a8,  (int)a4);
  }

  return 0LL;
}

unint64_t PutResourceRecordTTLWithLimit( unint64_t a1, unint64_t a2, _WORD *a3, uint64_t a4, unint64_t a5, unint64_t a6, uint64_t a7, uint64_t a8)
{
  int v9 = a5;
  unint64_t v12 = a2;
  if (*(_WORD *)a1 && (*(_BYTE *)(a1 + 2) & 0x78) == 0x28 && *(_WORD *)(a4 + 4) == 33) {
    unint64_t v13 = 0LL;
  }
  else {
    unint64_t v13 = a1;
  }
  if (*(_BYTE *)a4)
  {
    if (!a2)
    {
      uint64_t v32 = mDNSLogCategory_Default;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_ERROR)) {
          return 0LL;
        }
        uint64_t v34 = *(void *)(a4 + 32);
        if (v34)
        {
          int v35 = *(_BYTE **)(a4 + 32);
          int v36 = 257;
          if (v34 == -256) {
            goto LABEL_53;
          }
LABEL_50:
          if ((unint64_t)v35 < v34 + 256 && v35)
          {
            while (1)
            {
              uint64_t v37 = *v35;
              if (v37 > 0x3F)
              {
LABEL_143:
                int v36 = 257;
                goto LABEL_164;
              }

              if (!*v35) {
                break;
              }
              v35 += v37 + 1;
              if (v34 != -256) {
                goto LABEL_50;
              }
LABEL_53:
              if (!v35) {
                goto LABEL_143;
              }
            }

            int v36 = (unsigned __int16)((_WORD)v35 - v34 + 1);
          }
        }

        else
        {
          int v36 = 0;
        }
      }

      else
      {
        uint64_t v32 = mDNSLogCategory_Default_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_ERROR)) {
          return 0LL;
        }
        uint64_t v34 = *(void *)(a4 + 32);
        if (v34)
        {
          BOOL v44 = *(_BYTE **)(a4 + 32);
          int v36 = 257;
          if (v34 == -256) {
            goto LABEL_86;
          }
LABEL_83:
          if ((unint64_t)v44 < v34 + 256 && v44)
          {
            while (1)
            {
              uint64_t v45 = *v44;
              if (v45 > 0x3F)
              {
LABEL_144:
                int v36 = 257;
                goto LABEL_164;
              }

              if (!*v44) {
                break;
              }
              v44 += v45 + 1;
              if (v34 != -256) {
                goto LABEL_83;
              }
LABEL_86:
              if (!v44) {
                goto LABEL_144;
              }
            }

            int v36 = (unsigned __int16)((_WORD)v44 - v34 + 1);
          }
        }

        else
        {
          int v36 = 0;
        }
      }

LABEL_164:
      uint64_t v65 = DNSTypeName(*(unsigned __int16 *)(a4 + 4));
      int v69 = 141558787;
      uint64_t v70 = 1752392040LL;
      __int16 v71 = 1040;
      int v72 = v36;
      __int16 v73 = 2101;
      uint64_t v74 = v34;
      __int16 v75 = 2082;
      uint64_t v76 = v65;
      uint64_t v61 = "Pointer to message is NULL while filling resource record %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%{public}s)";
      __int16 v62 = (os_log_s *)v32;
      os_log_type_t v63 = OS_LOG_TYPE_ERROR;
      uint32_t v64 = 38;
      goto LABEL_165;
    }

    uint64_t v14 = putDomainNameAsLabels(a1, a2, a6, *(unsigned __int8 **)(a4 + 32), a5, a6, a7, a8);
    unsigned int v19 = v14;
    if (v14 && (unint64_t)(v14 + 10) < a6)
    {
      *uint64_t v14 = *(_BYTE *)(a4 + 5);
      v14[1] = *(_BYTE *)(a4 + 4);
      v14[2] = *(_BYTE *)(a4 + 7);
      v14[3] = *(_BYTE *)(a4 + 6);
      v14[4] = HIBYTE(v9);
      v14[5] = BYTE2(v9);
      v14[6] = BYTE1(v9);
      v14[7] = v9;
      int v20 = putRData(v13, v14 + 10, a6, a4, v15, v16, v17, v18);
      if (v20)
      {
        unint64_t v12 = (unint64_t)v20;
        *((_WORD *)v19 + 4) = bswap32((_DWORD)v20 - (_DWORD)v19 - 10) >> 16;
        if (a3)
        {
          ++*a3;
          return v12;
        }

        char v21 = (os_log_s *)mDNSLogCategory_Default;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
        {
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_ERROR)) {
            return v12;
          }
          uint64_t v50 = *(void *)(a4 + 32);
          if (v50)
          {
            __int16 v58 = *(_BYTE **)(a4 + 32);
            int v52 = 257;
            if (v50 == -256) {
              goto LABEL_151;
            }
LABEL_148:
            if ((unint64_t)v58 < v50 + 256 && v58)
            {
              while (1)
              {
                uint64_t v59 = *v58;
                if (v59 > 0x3F)
                {
LABEL_179:
                  int v52 = 257;
                  goto LABEL_181;
                }

                if (!*v58) {
                  break;
                }
                v58 += v59 + 1;
                if (v50 != -256) {
                  goto LABEL_148;
                }
LABEL_151:
                if (!v58) {
                  goto LABEL_179;
                }
              }

              int v52 = (unsigned __int16)((_WORD)v58 - v50 + 1);
            }
          }

          else
          {
            int v52 = 0;
          }
        }

        else
        {
          char v21 = (os_log_s *)mDNSLogCategory_Default_redacted;
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_ERROR)) {
            return v12;
          }
          uint64_t v50 = *(void *)(a4 + 32);
          if (v50)
          {
            uint64_t v51 = *(_BYTE **)(a4 + 32);
            int v52 = 257;
            if (v50 == -256) {
              goto LABEL_114;
            }
LABEL_111:
            if ((unint64_t)v51 < v50 + 256 && v51)
            {
              while (1)
              {
                uint64_t v53 = *v51;
                if (v53 > 0x3F)
                {
LABEL_178:
                  int v52 = 257;
                  goto LABEL_181;
                }

                if (!*v51) {
                  break;
                }
                v51 += v53 + 1;
                if (v50 != -256) {
                  goto LABEL_111;
                }
LABEL_114:
                if (!v51) {
                  goto LABEL_178;
                }
              }

              int v52 = (unsigned __int16)((_WORD)v51 - v50 + 1);
            }
          }

          else
          {
            int v52 = 0;
          }
        }

LABEL_181:
        unsigned int v68 = DNSTypeName(*(unsigned __int16 *)(a4 + 4));
        int v69 = 141558787;
        uint64_t v70 = 1752392040LL;
        __int16 v71 = 1040;
        int v72 = v52;
        __int16 v73 = 2101;
        uint64_t v74 = v50;
        __int16 v75 = 2082;
        uint64_t v76 = v68;
        __int128 v57 = "No target count to update for %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%{public}s)";
LABEL_142:
        _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, v57, (uint8_t *)&v69, 0x26u);
        return v12;
      }

      uint64_t v27 = mDNSLogCategory_Default;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
      {
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v46 = *(void *)(a4 + 32);
          if (v46)
          {
            uint64_t v54 = *(_BYTE **)(a4 + 32);
            int v48 = 257;
            if (v46 == -256) {
              goto LABEL_129;
            }
LABEL_126:
            if ((unint64_t)v54 < v46 + 256 && v54)
            {
              while (1)
              {
                uint64_t v55 = *v54;
                if (v55 > 0x3F)
                {
LABEL_171:
                  int v48 = 257;
                  goto LABEL_175;
                }

                if (!*v54) {
                  break;
                }
                v54 += v55 + 1;
                if (v46 != -256) {
                  goto LABEL_126;
                }
LABEL_129:
                if (!v54) {
                  goto LABEL_171;
                }
              }

              int v48 = (unsigned __int16)((_WORD)v54 - v46 + 1);
            }
          }

          else
          {
            int v48 = 0;
          }

          goto LABEL_175;
        }
      }

      else
      {
        uint64_t v27 = mDNSLogCategory_Default_redacted;
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v46 = *(void *)(a4 + 32);
          if (v46)
          {
            uint64_t v47 = *(_BYTE **)(a4 + 32);
            int v48 = 257;
            if (v46 == -256) {
              goto LABEL_99;
            }
LABEL_96:
            if ((unint64_t)v47 < v46 + 256 && v47)
            {
              while (1)
              {
                uint64_t v49 = *v47;
                if (v49 > 0x3F)
                {
LABEL_170:
                  int v48 = 257;
                  goto LABEL_175;
                }

                if (!*v47) {
                  break;
                }
                v47 += v49 + 1;
                if (v46 != -256) {
                  goto LABEL_96;
                }
LABEL_99:
                if (!v47) {
                  goto LABEL_170;
                }
              }

              int v48 = (unsigned __int16)((_WORD)v47 - v46 + 1);
            }
          }

          else
          {
            int v48 = 0;
          }

LABEL_175:
          unsigned int v67 = DNSTypeName(*(unsigned __int16 *)(a4 + 4));
          int v69 = 141559043;
          uint64_t v70 = 1752392040LL;
          __int16 v71 = 1040;
          int v72 = v48;
          __int16 v73 = 2101;
          uint64_t v74 = v46;
          __int16 v75 = 2082;
          uint64_t v76 = v67;
          __int16 v77 = 2048;
          uint64_t v78 = a6 - (void)v19 - 10;
          uint64_t v61 = "Can't put more rdata into current message, will possibly put it into the next message - name: %{sensitiv"
                "e, mask.hash, mdnsresponder:domain_name}.*P (%{public}s), remaining space: %ld";
          goto LABEL_160;
        }
      }

      return 0LL;
    }

    uint64_t v27 = mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEBUG)) {
        return 0LL;
      }
      uint64_t v28 = *(void *)(a4 + 32);
      if (v28)
      {
        uint64_t v41 = *(_BYTE **)(a4 + 32);
        int v30 = 257;
        if (v28 == -256) {
          goto LABEL_75;
        }
LABEL_72:
        if ((unint64_t)v41 < v28 + 256 && v41)
        {
          while (1)
          {
            uint64_t v42 = *v41;
            if (v42 > 0x3F)
            {
LABEL_137:
              int v30 = 257;
              goto LABEL_159;
            }

            if (!*v41) {
              break;
            }
            v41 += v42 + 1;
            if (v28 != -256) {
              goto LABEL_72;
            }
LABEL_75:
            if (!v41) {
              goto LABEL_137;
            }
          }

          int v30 = (unsigned __int16)((_WORD)v41 - v28 + 1);
        }
      }

      else
      {
        int v30 = 0;
      }
    }

    else
    {
      uint64_t v27 = mDNSLogCategory_Default_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEBUG)) {
        return 0LL;
      }
      uint64_t v28 = *(void *)(a4 + 32);
      if (v28)
      {
        int v29 = *(_BYTE **)(a4 + 32);
        int v30 = 257;
        if (v28 == -256) {
          goto LABEL_37;
        }
LABEL_34:
        if ((unint64_t)v29 < v28 + 256 && v29)
        {
          while (1)
          {
            uint64_t v31 = *v29;
            if (v31 > 0x3F)
            {
LABEL_136:
              int v30 = 257;
              goto LABEL_159;
            }

            if (!*v29) {
              break;
            }
            v29 += v31 + 1;
            if (v28 != -256) {
              goto LABEL_34;
            }
LABEL_37:
            if (!v29) {
              goto LABEL_136;
            }
          }

          int v30 = (unsigned __int16)((_WORD)v29 - v28 + 1);
        }
      }

      else
      {
        int v30 = 0;
      }
    }

LABEL_159:
    __int16 v60 = DNSTypeName(*(unsigned __int16 *)(a4 + 4));
    int v69 = 141559043;
    uint64_t v70 = 1752392040LL;
    __int16 v71 = 1040;
    int v72 = v30;
    __int16 v73 = 2101;
    uint64_t v74 = v28;
    __int16 v75 = 2082;
    uint64_t v76 = v60;
    __int16 v77 = 2048;
    uint64_t v78 = a6 - (void)v19;
    uint64_t v61 = "Can't put more names into current message, will possibly put it into the next message - name: %{sensitive, mas"
          "k.hash, mdnsresponder:domain_name}.*P (%{public}s), remaining space: %ld";
LABEL_160:
    __int16 v62 = (os_log_s *)v27;
    os_log_type_t v63 = OS_LOG_TYPE_DEBUG;
    uint32_t v64 = 48;
LABEL_165:
    _os_log_impl((void *)&_mh_execute_header, v62, v63, v61, (uint8_t *)&v69, v64);
    return 0LL;
  }

  char v21 = (os_log_s *)mDNSLogCategory_Default;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
  {
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_ERROR)) {
      return v12;
    }
    uint64_t v23 = *(void *)(a4 + 32);
    if (v23)
    {
      int v24 = *(_BYTE **)(a4 + 32);
      int v25 = 257;
      if (v23 == -256) {
        goto LABEL_24;
      }
LABEL_21:
      if ((unint64_t)v24 < v23 + 256 && v24)
      {
        while (1)
        {
          uint64_t v26 = *v24;
          if (v26 > 0x3F)
          {
LABEL_119:
            int v25 = 257;
            goto LABEL_141;
          }

          if (!*v24) {
            break;
          }
          v24 += v26 + 1;
          if (v23 != -256) {
            goto LABEL_21;
          }
LABEL_24:
          if (!v24) {
            goto LABEL_119;
          }
        }

        int v25 = (unsigned __int16)((_WORD)v24 - v23 + 1);
      }
    }

    else
    {
      int v25 = 0;
    }

    goto LABEL_141;
  }

  char v21 = (os_log_s *)mDNSLogCategory_Default_redacted;
  if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_ERROR))
  {
    uint64_t v23 = *(void *)(a4 + 32);
    if (v23)
    {
      int v39 = *(_BYTE **)(a4 + 32);
      int v25 = 257;
      if (v23 == -256) {
        goto LABEL_64;
      }
LABEL_61:
      if ((unint64_t)v39 < v23 + 256 && v39)
      {
        while (1)
        {
          uint64_t v40 = *v39;
          if (v40 > 0x3F)
          {
LABEL_120:
            int v25 = 257;
            goto LABEL_141;
          }

          if (!*v39) {
            break;
          }
          v39 += v40 + 1;
          if (v23 != -256) {
            goto LABEL_61;
          }
LABEL_64:
          if (!v39) {
            goto LABEL_120;
          }
        }

        int v25 = (unsigned __int16)((_WORD)v39 - v23 + 1);
      }
    }

    else
    {
      int v25 = 0;
    }

char *putRData( unint64_t a1, char *__dst, unint64_t a3, uint64_t a4, unint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v9 = a3;
  uint64_t v10 = __dst;
  uint64_t v11 = *(void *)(a4 + 40);
  unint64_t v12 = (_OWORD *)(v11 + 4);
  unint64_t v13 = a1;
  switch(*(_WORD *)(a4 + 4))
  {
    case 1:
      unint64_t v15 = 0LL;
      if ((unint64_t)(__dst + 4) <= a3 && *(_WORD *)(a4 + 12) == 4)
      {
        *__dst = *(_BYTE *)(v11 + 4);
        __dst[1] = *(_BYTE *)(v11 + 5);
        __dst[2] = *(_BYTE *)(v11 + 6);
        __dst[3] = *(_BYTE *)(v11 + 7);
        return __dst + 4;
      }

      return v15;
    case 2:
    case 5:
    case 0xC:
    case 0x27:
      uint64_t v16 = (unsigned __int8 *)(v11 + 4);
      return putDomainNameAsLabels(a1, (unint64_t)__dst, a3, v16, a5, a6, a7, a8);
    case 3:
    case 4:
    case 7:
    case 8:
    case 9:
    case 0xA:
    case 0xB:
    case 0xD:
    case 0xE:
    case 0x10:
    case 0x13:
    case 0x14:
    case 0x16:
    case 0x17:
    case 0x18:
    case 0x19:
    case 0x1B:
    case 0x1D:
    case 0x1E:
    case 0x1F:
    case 0x20:
    case 0x22:
    case 0x23:
    case 0x25:
    case 0x26:
    case 0x28:
    case 0x2A:
    case 0x2B:
    case 0x2C:
    case 0x2D:
    case 0x2E:
    case 0x30:
    case 0x31:
      goto LABEL_2;
    case 6:
      uint64_t v17 = putDomainNameAsLabels(a1, (unint64_t)__dst, a3, (unsigned __int8 *)(v11 + 4), a5, a6, a7, a8);
      if (!v17) {
        return 0LL;
      }
      int v22 = putDomainNameAsLabels(v13, (unint64_t)v17, v9, (unsigned __int8 *)(v11 + 260), v18, v19, v20, v21);
      unint64_t v15 = (char *)(v22 + 5);
      BOOL v23 = !v22 || (unint64_t)v15 > v9;
      if (v23) {
        return 0LL;
      }
      *int v22 = bswap32(*(_DWORD *)(v11 + 516));
      v22[1] = bswap32(*(_DWORD *)(v11 + 520));
      v22[2] = bswap32(*(_DWORD *)(v11 + 524));
      v22[3] = bswap32(*(_DWORD *)(v11 + 528));
      uint8_t v22[4] = bswap32(*(_DWORD *)(v11 + 532));
      return v15;
    case 0xF:
    case 0x12:
    case 0x15:
    case 0x24:
      *(_WORD *)__dst = bswap32(*(unsigned __int16 *)(v11 + 4)) >> 16;
      uint64_t v16 = (unsigned __int8 *)(v11 + 6);
      __dst += 2;
      goto LABEL_29;
    case 0x11:
      int v24 = putDomainNameAsLabels(a1, (unint64_t)__dst, a3, (unsigned __int8 *)(v11 + 4), a5, a6, a7, a8);
      if (!v24) {
        return 0LL;
      }
      __dst = v24;
      uint64_t v16 = (unsigned __int8 *)(v11 + 260);
      goto LABEL_28;
    case 0x1A:
      *(_WORD *)__dst = bswap32(*(unsigned __int16 *)(v11 + 4)) >> 16;
      int v25 = putDomainNameAsLabels(a1, (unint64_t)(__dst + 2), a3, (unsigned __int8 *)(v11 + 6), a5, a6, a7, a8);
      if (!v25) {
        return 0LL;
      }
      __dst = v25;
      uint64_t v16 = (unsigned __int8 *)(v11 + 262);
      goto LABEL_28;
    case 0x1C:
      if (*(_WORD *)(a4 + 12) != 16) {
        return 0LL;
      }
      unint64_t v15 = __dst + 16;
      *(_OWORD *)__dst = *v12;
      return v15;
    case 0x21:
      *__dst = *(_BYTE *)(v11 + 5);
      __dst[1] = *(_BYTE *)(v11 + 4);
      __dst[2] = *(_BYTE *)(v11 + 7);
      __dst[3] = *(_BYTE *)(v11 + 6);
      __dst[4] = *(_BYTE *)(v11 + 8);
      __dst[5] = *(_BYTE *)(v11 + 9);
      __dst += 6;
      uint64_t v16 = (unsigned __int8 *)(v11 + 10);
LABEL_28:
      a1 = v13;
LABEL_29:
      a3 = v9;
      return putDomainNameAsLabels(a1, (unint64_t)__dst, a3, v16, a5, a6, a7, a8);
    case 0x29:
      uint64_t v27 = *(unsigned __int16 *)(a4 + 12);
      uint64_t v28 = (unsigned __int16 *)((char *)v12 + v27);
      if (v12 >= (_OWORD *)((char *)v12 + v27))
      {
        unint64_t v15 = __dst;
        goto LABEL_95;
      }

      int v29 = 0;
      int v30 = (unsigned __int16 *)(v11 + 20);
      while (1)
      {
        unsigned int v31 = *(v30 - 8);
        if (v31 <= 3)
        {
          if (v31 == 1)
          {
            int v32 = 22;
          }

          else
          {
            if (v31 != 2) {
              goto LABEL_48;
            }
            int v32 = 8;
          }
        }

        else
        {
          switch(v31)
          {
            case 0xFDEAu:
              int v32 = 14;
              break;
            case 0xFDE9u:
              int v32 = 9;
              break;
            case 4u:
              if (*(v30 - 5) == *(v30 - 2) && *(v30 - 4) == *(v30 - 1))
              {
                if (*(v30 - 3) == *v30) {
                  int v32 = 12;
                }
                else {
                  int v32 = 18;
                }
              }

              else
              {
                int v32 = 18;
              }

              break;
            default:
LABEL_48:
              int v32 = 0x10000;
              break;
          }
        }

        v29 += v32;
        BOOL v33 = v30 + 4;
        v30 += 12;
        if (v33 >= v28)
        {
          if ((unint64_t)&__dst[v29] <= a3)
          {
            for (CFIndex i = (unsigned __int16 *)(v11 + 12); ; i += 12)
            {
              unsigned int v35 = *(i - 4);
              if (v35 <= 3)
              {
                if (v35 == 1)
                {
                  unsigned int v36 = 22;
                }

                else
                {
                  if (v35 != 2) {
                    goto LABEL_68;
                  }
                  unsigned int v36 = 8;
                }
              }

              else
              {
                switch(v35)
                {
                  case 0xFDEAu:
                    unsigned int v36 = 14;
                    break;
                  case 0xFDE9u:
                    unsigned int v36 = 9;
                    break;
                  case 4u:
                    if (*(i - 1) == i[2] && *i == i[3])
                    {
                      if (i[1] == i[4]) {
                        unsigned int v36 = 12;
                      }
                      else {
                        unsigned int v36 = 18;
                      }
                    }

                    else
                    {
                      unsigned int v36 = 18;
                    }

                    break;
                  default:
LABEL_68:
                    unsigned int v36 = 0x10000;
                    break;
                }
              }

              *uint64_t v10 = BYTE1(v35);
              v10[1] = v35;
              v10[2] = (unsigned __int16)(v36 - 4) >> 8;
              v10[3] = v36 - 4;
              unint64_t v15 = v10 + 4;
              unsigned int v37 = *(i - 4);
              if (v37 <= 3)
              {
                if (v37 == 1)
                {
                  *((_WORD *)v10 + 2) = bswap32(*(i - 2)) >> 16;
                  *((_WORD *)v10 + 3) = bswap32(*(i - 1)) >> 16;
                  *((_WORD *)v10 + 4) = bswap32(*i) >> 16;
                  *(void *)(v10 + 10) = *(void *)(i + 2);
                  *(_DWORD *)(v10 + 18) = bswap32(*((_DWORD *)i + 3));
                  unint64_t v15 = v10 + 22;
                }

                else if (v37 == 2)
                {
                  *((_DWORD *)v10 + 1) = bswap32(*((_DWORD *)i - 1));
                  unint64_t v15 = v10 + 8;
                }
              }

              else
              {
                switch(v37)
                {
                  case 4u:
                    v10[4] = *((_BYTE *)i - 4);
                    v10[5] = *((_BYTE *)i - 3);
                    int v38 = *(_DWORD *)(i - 1);
                    *((_WORD *)v10 + 5) = i[1];
                    *(_DWORD *)(v10 + 6) = v38;
                    unint64_t v15 = v10 + 12;
                    if (v36 >= 0x12)
                    {
                      int v39 = *((_DWORD *)i + 1);
                      *((_WORD *)v10 + 8) = i[4];
                      *(_DWORD *)unint64_t v15 = v39;
                      unint64_t v15 = v10 + 18;
                      uint64_t v40 = v36 - 18;
                      if (v36 != 18)
                      {
                        memcpy(v15, i + 5, v36 - 18);
                        v15 += v40;
                      }
                    }

                    break;
                  case 0xFDE9u:
                    v10[4] = *((_BYTE *)i - 4);
                    *(_DWORD *)(v10 + 5) = bswap32(*(_DWORD *)i);
                    unint64_t v15 = v10 + 9;
                    break;
                  case 0xFDEAu:
                    *(void *)__tp = 0LL;
                    *(void *)&__tp[8] = 0LL;
                    clock_gettime(_CLOCK_MONOTONIC_RAW, (timespec *)__tp);
                    *((_DWORD *)v10 + 1) = bswap32(*(_DWORD *)__tp - *((_DWORD *)i - 1));
                    *((_DWORD *)v10 + 2) = bswap32(*(_DWORD *)i);
                    *((_WORD *)v10 + 6) = bswap32(i[2]) >> 16;
                    unint64_t v15 = v10 + 14;
                    break;
                }
              }

              uint64_t v41 = i + 8;
              uint64_t v10 = v15;
              if (v41 >= v28) {
                return v15;
              }
            }
          }

LABEL_95:
          uint64_t v45 = (os_log_s *)mDNSLogCategory_Default;
          uint64_t v46 = "ERROR: putOptRData - out of space";
          goto LABEL_135;
        }
      }

    case 0x2F:
      uint64_t v42 = (_BYTE *)(v11 + 4);
      if (v11 != -260) {
        goto LABEL_86;
      }
      while (2)
      {
        if (!v42) {
          goto LABEL_96;
        }
LABEL_90:
        uint64_t v44 = *v42;
        if (v44 > 0x3F)
        {
LABEL_96:
          unsigned __int16 v43 = 257;
        }

        else
        {
          if (*v42)
          {
            v42 += v44 + 1;
            if (v11 == -260) {
              continue;
            }
LABEL_86:
            unsigned __int16 v43 = 257;
            goto LABEL_90;
          }

          unsigned __int16 v43 = (_WORD)v42 - (_WORD)v12 + 1;
        }

        break;
      }

      uint64_t v47 = (char *)v12 + v43;
      if (RRAssertsExistence(a4, 0x2Fu, a3, a4, a5, a6, a7, a8))
      {
        size_t v14 = *(unsigned __int16 *)(a4 + 12);
        int v48 = v14 - v43;
        if ((_DWORD)v14 == v43)
        {
LABEL_104:
          if ((unint64_t)&v10[v14] <= v9)
          {
LABEL_3:
            memcpy(v10, v12, v14);
            return &v10[*(unsigned __int16 *)(a4 + 12)];
          }

          uint64_t v51 = (os_log_s *)mDNSLogCategory_Default;
          uint64_t v52 = *(void *)(a4 + 32);
          DNSTypeName(*(unsigned __int16 *)(a4 + 4));
          LogMsgWithLevel( v51,  OS_LOG_TYPE_DEFAULT,  "putRData: NSEC rdlength beyond limit %##s (%s), ptr %p, rdlength %d, limit %p",  v53,  v54,  v55,  v56,  v57,  v52);
        }

        else
        {
          while (1)
          {
            unsigned int v49 = v48 - 2;
            if (v48 <= 2)
            {
              LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "putRData: invalid length %d",  a4,  a5,  a6,  a7,  a8,  v48);
              return 0LL;
            }

            uint64_t v50 = v47[1];
            v47 += v50 + 2;
            int v48 = v49 - v50;
            if (!v48) {
              goto LABEL_104;
            }
          }

          uint64_t v45 = (os_log_s *)mDNSLogCategory_Default;
          int v73 = v47[1];
          uint64_t v46 = "putRData: invalid window length %d";
LABEL_135:
          LogMsgWithLevel(v45, OS_LOG_TYPE_DEFAULT, v46, a4, a5, a6, a7, a8, v73);
        }

        return 0LL;
      }

      uint64_t v58 = v47[1];
      uint64_t v59 = v47 + 2;
      while (1)
      {
        unsigned int v60 = v58;
        BOOL v23 = v58-- < 1;
        if (v23) {
          break;
        }
      }

      unsigned int v60 = 0;
LABEL_111:
      uint64_t v61 = putDomainNameAsLabels(v13, (unint64_t)v10, v9, *(unsigned __int8 **)(a4 + 32), a5, a6, a7, a8);
      unint64_t v15 = v61;
      if (!v60 || !v61) {
        goto LABEL_116;
      }
      if ((unint64_t)&v61[v60 + 2] <= v9)
      {
        uint64_t v62 = v60;
        *uint64_t v61 = 0;
        v61[1] = v60;
        unint64_t v15 = v61 + 2;
        do
        {
          char v63 = *v59++;
          *v15++ = v63;
          --v62;
        }

        while (v62);
LABEL_116:
        if (v15) {
          return v15;
        }
      }

      uint32_t v64 = (os_log_s *)mDNSLogCategory_mDNS;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEBUG)) {
          return 0LL;
        }
        uint64_t v66 = *(void *)(a4 + 32);
        if (v66)
        {
          unsigned int v67 = *(_BYTE **)(a4 + 32);
          if (v66 == -256) {
            goto LABEL_128;
          }
LABEL_125:
          int v68 = 257;
          if ((unint64_t)v67 < v66 + 256 && v67)
          {
            while (1)
            {
              uint64_t v69 = *v67;
              if (v69 > 0x3F)
              {
LABEL_151:
                int v68 = 257;
                goto LABEL_156;
              }

              if (!*v67) {
                break;
              }
              v67 += v69 + 1;
              if (v66 != -256) {
                goto LABEL_125;
              }
LABEL_128:
              if (!v67) {
                goto LABEL_151;
              }
            }

            int v68 = (unsigned __int16)((_WORD)v67 - v66 + 1);
          }
        }

        else
        {
          int v68 = 0;
        }

        goto LABEL_156;
      }

      uint32_t v64 = (os_log_s *)mDNSLogCategory_mDNS_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v66 = *(void *)(a4 + 32);
        if (v66)
        {
          __int16 v71 = *(_BYTE **)(a4 + 32);
          if (v66 == -256) {
            goto LABEL_144;
          }
LABEL_141:
          int v68 = 257;
          if ((unint64_t)v71 < v66 + 256 && v71)
          {
            while (1)
            {
              uint64_t v72 = *v71;
              if (v72 > 0x3F)
              {
LABEL_152:
                int v68 = 257;
                goto LABEL_156;
              }

              if (!*v71) {
                break;
              }
              v71 += v72 + 1;
              if (v66 != -256) {
                goto LABEL_141;
              }
LABEL_144:
              if (!v71) {
                goto LABEL_152;
              }
            }

            int v68 = (unsigned __int16)((_WORD)v71 - v66 + 1);
          }
        }

        else
        {
          int v68 = 0;
        }

          uint64_t v47 = (uint64_t *)*v47;
          if (!v47) {
            goto LABEL_98;
          }
        }
      }

      uint64_t v183 = 0;
LABEL_98:
      uint64_t v41 = v177;
      uint64_t v42 = v175;
    }

    if (v42)
    {
      if (mDNS_LoggingEnabled == 1) {
        LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "BeginSleepProcessing: Did not register with an in-NIC proxy - invoking the callbacks for KA records",  (uint64_t)v18,  v19,  v20,  v21,  v22,  v172);
      }
      __int128 v88 = *(unsigned __int8 **)(a1 + 12624);
      *(void *)(a1 + 12648) = v88;
      if (v88)
      {
        do
        {
          if (*((_WORD *)v88 + 6) == 10)
          {
            __int128 v89 = (_BYTE *)*((void *)v88 + 5);
            uint64_t v90 = *v89 ? *v89 + 1LL : 0LL;
            if (SameDomainLabelPointer(&v89[v90], "\n_keepalive") && v88[8] != 1)
            {
              if (mDNS_LoggingEnabled == 1)
              {
                __int128 v91 = (os_log_s *)mDNSLogCategory_Default;
                GetRRDisplayString_rdb(v88 + 8, (unsigned __int16 *)(*((void *)v88 + 6) + 4LL), (_BYTE *)(a1 + 46976));
                LogMsgWithLevel( v91,  OS_LOG_TYPE_DEFAULT,  "DoKeepaliveCallbacks: Invoking the callback for %s",  v92,  v93,  v94,  v95,  v96,  a1 + 46976);
              }

              __int128 v97 = (void (*)(uint64_t, unsigned __int8 *, uint64_t))*((void *)v88 + 13);
              if (v97) {
                v97(a1, v88, 4294901754LL);
              }
            }
          }

          __int128 v98 = *(unsigned __int8 **)(a1 + 12648);
          if (v98 == v88)
          {
            __int128 v98 = *(unsigned __int8 **)v88;
            *(void *)(a1 + 12648) = *(void *)v88;
          }

          __int128 v88 = v98;
        }

        while (v98);
      }
    }

    if (v179)
    {
      if (mDNS_LoggingEnabled == 1) {
        LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "BeginSleepProcessing: Not registering with Sleep Proxy Server",  (uint64_t)v18,  v19,  v20,  v21,  v22,  v172);
      }
      uint64_t v99 = a1;
      __int128 v100 = 1LL;
      __int128 v101 = 1LL;
    }

    else
    {
      if (!v41)
      {
        if (v183)
        {
          if (mDNS_LoggingEnabled == 1) {
            LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "BeginSleepProcessing: Sending goodbyes for WakeOnlyService",  (uint64_t)v18,  v19,  v20,  v21,  v22,  v172);
          }
          SendResponses(a1, v16, v17, v18, v19, v20, v21, v22);
        }

        return;
      }

      if (mDNS_LoggingEnabled == 1) {
        LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "BeginSleepProcessing: Not registering with Sleep Proxy Server on all interfaces",  (uint64_t)v18,  v19,  v20,  v21,  v22,  v172);
      }
      uint64_t v99 = a1;
      __int128 v100 = 0LL;
      __int128 v101 = 0LL;
    }

    SendSleepGoodbyes(v99, v100, v101, v18, v19, v20, v21, v22);
    return;
  }

  unsigned __int16 v104 = *(void *)(v36 + 6256);
  int v105 = a1 + 12664;
  while (1)
  {
    int v105 = *(void *)v105;
    if (!v105) {
      break;
    }
    if (*(void *)(v105 + 6256) == v104)
    {
      do
      {
        if (*(void *)(v105 + 6256) == v104 && (_DWORD)v102 && *(_DWORD *)(v105 + 6264) == 4)
        {
          int v106 = 0LL;
          while (2)
          {
            uint64_t v107 = v193[v106];
            int v108 = a1 + 12664;
            while (1)
            {
              int v108 = *(void *)v108;
              if (!v108) {
                break;
              }
              if (*(void *)(v108 + 6256) == v107)
              {
                while (*(void *)(v108 + 6256) != v107
                     || *(_DWORD *)(v108 + 6264) != 4
                     || (*(_DWORD *)(v108 + 6288) & *(_DWORD *)(v108 + 6268)) != (*(_DWORD *)(v105 + 6288) & *(_DWORD *)(v105 + 6268)))
                {
                  int v108 = *(void *)v108;
                  if (!v108) {
                    goto LABEL_155;
                  }
                }

                if ((*(_BYTE *)(v35 + 2840) & 1) != 0)
                {
                  LogMsgWithLevel( *(os_log_s **)(v65 + 1360),  OS_LOG_TYPE_DEFAULT,  "%s : Already registered for the same subnet (IPv4) for interface %s",  (uint64_t)v18,  v19,  v20,  v21,  v22,  (int)"skipSameSubnetRegistration");
                  if (*(_BYTE *)(v35 + 2840) == 1) {
                    LogMsgWithLevel( *(os_log_s **)(v65 + 1360),  OS_LOG_TYPE_DEFAULT,  "%s : Skipping full sleep proxy registration on %s",  v110,  v111,  v112,  v113,  v114,  (int)"BeginSleepProcessing");
                  }
                }

                uint64_t v109 = 1;
                goto LABEL_165;
              }
            }

LABEL_2:
      size_t v14 = *(unsigned __int16 *)(a4 + 12);
      goto LABEL_3;
  }

  *(void *)v9[3] = a2;
  v9[3] = a2;
  return v9;
}

  uint64_t v4 = (_DWORD *)(a1 + 140);
  interface_flags_from_nw_path = _mdns_get_interface_flags_from_nw_path(a2, *(_DWORD *)(a1 + 140));
LABEL_3:
  uint64_t v6 = 0;
LABEL_18:
  v16[0] = _NSConcreteStackBlock;
  v16[1] = 0x40000000LL;
  v16[2] = ___mdns_interface_monitor_trigger_update_with_path_block_invoke;
  v16[3] = &unk_10013B918;
  uint64_t v17 = interface_flags_from_nw_path;
  unint64_t v18 = v6;
  v16[4] = &v19;
  v16[5] = a1;
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 148));
  ___mdns_interface_monitor_trigger_update_with_path_block_invoke((uint64_t)v16);
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 148));
  size_t v14 = *(dispatch_source_s **)(a1 + 56);
  if (v14) {
    dispatch_source_merge_data(v14, 1uLL);
  }
LABEL_20:
  unint64_t v15 = (void *)v20[3];
  if (v15)
  {
    nw_release(v15);
    v20[3] = 0LL;
  }

  _Block_object_dispose(&v19, 8);
}

uint64_t mDNSSendDNSMessage( uint64_t a1, unint64_t a2, unint64_t a3, uint64_t a4, unsigned __int16 *a5, unsigned __int16 *a6, int *a7, unsigned __int16 a8, _DWORD *a9, unsigned __int8 a10)
{
  unsigned __int16 v10 = a8;
  uint64_t v11 = a7;
  unint64_t v12 = a6;
  unint64_t v13 = a5;
  unint64_t v15 = a3;
  __int16 v78 = *(_WORD *)(a2 + 10);
  if (*(_WORD *)a2) {
    ++*(_DWORD *)(a1 + 172);
  }
  else {
    ++*(_DWORD *)(a1 + 176);
  }
  unint64_t v18 = a2 + 12;
  uint64_t v19 = a3 - (a2 + 12);
  if (a3 >= a2 + 12 && v19 < 8941)
  {
    *(_WORD *)(a2 + 4) = bswap32(*(unsigned __int16 *)(a2 + 4)) >> 16;
    *(_WORD *)(a2 + 6) = bswap32(*(unsigned __int16 *)(a2 + 6)) >> 16;
    *(_WORD *)(a2 + 8) = bswap32(*(unsigned __int16 *)(a2 + 8)) >> 16;
    __int16 v20 = *(unsigned __int8 *)(a2 + 10);
    __int16 v21 = *(unsigned __int8 *)(a2 + 11);
    *(_WORD *)(a2 + 10) = v21 | (v20 << 8);
    if (a9)
    {
      unsigned __int16 v80 = v20 | (v21 << 8);
      unsigned int v23 = a9[196] - 1;
      if (v23 > 4) {
        CCHmacAlgorithm v24 = 4;
      }
      else {
        CCHmacAlgorithm v24 = dword_1000FFD2C[v23];
      }
      bzero(buf, 0x498uLL);
      __int16 v83 = 0;
      int v82 = 0;
      memset(macOut, 0, sizeof(macOut));
      memset(&ctx, 0, sizeof(ctx));
      CCHmacInit(&ctx, v24, a9 + 198, a9[197]);
      CCHmacUpdate(&ctx, (const void *)a2, v15 - a2);
      BYTE4(v86) = 32;
      uint64_t v90 = 0LL;
      __int128 v91 = v125;
      *(void *)uint64_t v87 = 0x1194000100FALL;
      __int16 v126 = 264;
      uint64_t v93 = 0LL;
      uint64_t v92 = &v126;
      int v101 = 0;
      char v102 = 0;
      int v103 = 0;
      char v104 = 0;
      __int16 v105 = 0;
      __int128 v94 = 0u;
      __int128 v95 = 0u;
      __int128 v96 = 0u;
      __int128 v97 = 0u;
      __int128 v98 = 0u;
      __int128 v99 = 0u;
      uint64_t v100 = 0LL;
      int v106 = v125;
      int v121 = 0;
      __int16 v122 = 0;
      uint64_t v124 = 0LL;
      __int128 v123 = 0u;
      int v120 = 0;
      v125[0] = 0;
      unsigned int v31 = a9 + 67;
      int v32 = a9 + 131;
      __int128 v107 = 0u;
      __int128 v108 = 0u;
      __int128 v109 = 0u;
      __int128 v110 = 0u;
      __int128 v111 = 0u;
      __int128 v112 = 0u;
      __int128 v113 = 0u;
      __int128 v114 = 0u;
      __int128 v115 = 0u;
      __int128 v116 = 0u;
      __int128 v117 = 0u;
      __int128 v118 = 0u;
      memset(v119, 0, sizeof(v119));
      for (CFIndex i = a9 + 67; i < (_BYTE *)v32; i += v34 + 1)
      {
        if (!i) {
          break;
        }
        uint64_t v34 = *i;
        if (!*i)
        {
          unsigned __int16 v35 = (_WORD)i - (_WORD)v31 + 1;
          if (v35 <= 0x100u) {
            memcpy(v125, v31, v35);
          }
          break;
        }
      }

      unsigned __int16 v36 = 257;
      for (int j = a9 + 67; j < (_BYTE *)v32; j += v38 + 1)
      {
        if (!j) {
          break;
        }
        uint64_t v38 = *j;
        if (!*j)
        {
          unsigned __int16 v36 = (_WORD)j - (_WORD)v31 + 1;
          break;
        }
      }

      CCHmacUpdate(&ctx, v31, v36);
      *(_WORD *)&v87[2] = 255;
      __int16 data = -256;
      CCHmacUpdate(&ctx, &data, 2uLL);
      *(_DWORD *)&v87[4] = 0;
      CCHmacUpdate(&ctx, &v87[4], 4uLL);
      if (v23 > 5) {
        int v39 = "\fhmac-invalid";
      }
      else {
        int v39 = off_10013BCC8[v23];
      }
      uint64_t v40 = v39 + 256;
      uint64_t v41 = v39;
      if (v39 == (const char *)-256LL)
      {
LABEL_44:
        while (v41)
        {
          uint64_t v42 = *(unsigned __int8 *)v41;
          if (!*v41)
          {
            unsigned __int16 v43 = (_WORD)v41 - (_WORD)v39 + 1;
            if (v43 > 0x100u) {
              break;
            }
            memcpy(v92 + 2, v39, v43);
            goto LABEL_52;
          }

          v41 += v42 + 1;
        }
      }

      else
      {
LABEL_43:
        if (v41 < v40) {
          goto LABEL_44;
        }
      }

      *((_BYTE *)v92 + 4) = 0;
LABEL_52:
      size_t v44 = 257LL;
      uint64_t v45 = v39;
      if (v39 == (const char *)-256LL)
      {
LABEL_54:
        while (v45)
        {
          uint64_t v46 = *(unsigned __int8 *)v45;
          if (!*v45)
          {
            size_t v44 = (unsigned __int16)((_WORD)v45 - (_WORD)v39 + 1);
            break;
          }

          v45 += v46 + 1;
        }
      }

      else
      {
LABEL_53:
        if (v45 < v40) {
          goto LABEL_54;
        }
      }

      uint64_t v47 = (uint64_t)v92 + v44 + 4;
      CCHmacUpdate(&ctx, v39, v44);
      int v53 = time(0LL);
      if (v53 == -1) {
        LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "ERROR: DNSDigest_SignMessage - mDNSPlatformUTC returned bad time -1",  v48,  v49,  v50,  v51,  v52,  v74);
      }
      LOWORD(v82) = 0;
      BYTE2(v82) = HIBYTE(v53);
      HIBYTE(v82) = BYTE2(v53);
      LOBYTE(v83) = BYTE1(v53);
      HIBYTE(v83) = v53;
      int v54 = v82;
      *(_WORD *)(v47 + 4) = v83;
      *(_DWORD *)uint64_t v47 = v54;
      CCHmacUpdate(&ctx, &v82, 6uLL);
      *(_WORD *)(v47 + 6) = 11265;
      CCHmacUpdate(&ctx, (const void *)(v47 + 6), 2uLL);
      __int16 data = 0;
      CCHmacUpdate(&ctx, &data, 2uLL);
      __int16 data = 0;
      CCHmacUpdate(&ctx, &data, 2uLL);
      CCHmacFinal(&ctx, macOut);
      unsigned int v55 = 0;
      uint64_t v11 = a7;
      if (v23 <= 5) {
        unsigned int v55 = word_1000FFD20[v23];
      }
      *(_BYTE *)(v47 + 8) = 0;
      *(_BYTE *)(v47 + 9) = v55;
      memcpy((void *)(v47 + 10), macOut, v55);
      uint64_t v56 = v47 + 10 + v55;
      *(_BYTE *)uint64_t v56 = *(_BYTE *)a2;
      *(_BYTE *)(v56 + 1) = *(_BYTE *)(a2 + 1);
      *(_DWORD *)(v56 + 2) = 0;
      *(_WORD *)&v87[8] = v56 - (_WORD)v92 + 2;
      unint64_t v15 = PutResourceRecordTTLWithLimit(a2, v15, &v80, (uint64_t)&v86 + 4, 0LL, a2 + 8952, v57, v58);
      if (v15) {
        *(_WORD *)(a2 + 10) = bswap32(v80) >> 16;
      }
      else {
        LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "ERROR: DNSDigest_SignMessage - could not put TSIG",  v59,  v60,  v61,  v62,  v63,  v74);
      }
      unsigned __int16 v10 = a8;
      unint64_t v13 = a5;
      __int16 v29 = v78;
      unint64_t v12 = a6;
      if (v15)
      {
LABEL_68:
        if (!v13)
        {
          uint64_t v27 = mDNSPlatformSendUDP((void *)a1, (unsigned __int16 *)a2, v15, a4, (uint64_t)v12, v11, v10, a10);
          goto LABEL_85;
        }

        uint64_t v64 = (uint64_t)v13;
        int v65 = (unsigned __int16)(v15 - a2);
        uint64_t v66 = malloc((v65 + 2));
        if (!v66) {
          __break(1u);
        }
        unsigned int v67 = v66;
        *uint64_t v66 = bswap32(v15 - a2) >> 16;
        memcpy(v66 + 1, (const void *)a2, (unsigned __int16)(v15 - a2));
        ssize_t v68 = mDNSPlatformWriteTCP(v64, v67, (v65 + 2));
        if (v68 == v65 + 2)
        {
          uint64_t v27 = 0LL;
          uint64_t v11 = a7;
LABEL_84:
          free(v67);
          __int16 v29 = v78;
          unint64_t v13 = (unsigned __int16 *)v64;
          unint64_t v12 = a6;
LABEL_85:
          *(_WORD *)(a2 + 4) = bswap32(*(unsigned __int16 *)(a2 + 4)) >> 16;
          *(_WORD *)(a2 + 6) = bswap32(*(unsigned __int16 *)(a2 + 6)) >> 16;
          *(_WORD *)(a2 + 8) = bswap32(*(unsigned __int16 *)(a2 + 8)) >> 16;
          *(_WORD *)(a2 + 10) = bswap32(*(unsigned __int16 *)(a2 + 10)) >> 16;
          if (v12)
          {
            unsigned int v71 = *v12;
            if (v13)
            {
LABEL_87:
              if (*((_DWORD *)v13 + 1)) {
                uint64_t v72 = "TLS";
              }
              else {
                uint64_t v72 = "TCP";
              }
              unsigned int v71 = *v13;
              goto LABEL_93;
            }
          }

          else
          {
            unsigned int v71 = 59668;
            if (v13) {
              goto LABEL_87;
            }
          }

          uint64_t v72 = "UDP";
LABEL_93:
          DumpPacket(v27, 1, (uint64_t)v72, 0LL, v71, (__int128 *)v11, v10, (unsigned __int8 *)a2, v15, a4);
          *(_WORD *)(a2 + 10) = v29;
          return v27;
        }

        ssize_t v69 = v68;
        uint64_t v27 = 4294901508LL;
        uint64_t v70 = (os_log_s *)mDNSLogCategory_Default;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
        {
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
          {
LABEL_82:
            *(_DWORD *)buf = 134218240;
            unint64_t v86 = v69;
            *(_WORD *)uint64_t v87 = 1024;
            *(_DWORD *)&v87[2] = (unsigned __int16)(v15 - a2);
            _os_log_impl( (void *)&_mh_execute_header,  v70,  OS_LOG_TYPE_DEFAULT,  "mDNSSendDNSMessage: write message failed %ld/%d",  buf,  0x12u);
          }
        }

        else
        {
          uint64_t v70 = (os_log_s *)mDNSLogCategory_Default_redacted;
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_82;
          }
        }

        uint64_t v11 = a7;
        goto LABEL_84;
      }
    }

    else
    {
      __int16 v29 = v78;
      if (a3) {
        goto LABEL_68;
      }
    }

    int v30 = (os_log_s *)mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        goto LABEL_79;
      }
    }

    else
    {
      int v30 = (os_log_s *)mDNSLogCategory_Default_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
LABEL_79:
        _os_log_impl( (void *)&_mh_execute_header,  v30,  OS_LOG_TYPE_DEFAULT,  "mDNSSendDNSMessage: DNSDigest_SignMessage failed",  buf,  2u);
        uint64_t v27 = 4294901757LL;
        goto LABEL_85;
      }
    }

    uint64_t v27 = 4294901757LL;
    goto LABEL_85;
  }

  int v25 = (os_log_s *)mDNSLogCategory_Default;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
  {
    uint64_t v27 = 4294901756LL;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
    {
LABEL_17:
      *(_DWORD *)buf = 134218496;
      unint64_t v86 = v18;
      *(_WORD *)uint64_t v87 = 2048;
      *(void *)&v87[2] = v15;
      __int16 v88 = 2048;
      uint64_t v89 = v19;
      _os_log_impl( (void *)&_mh_execute_header,  v25,  OS_LOG_TYPE_DEFAULT,  "mDNSSendDNSMessage: invalid message %p %p %ld",  buf,  0x20u);
    }
  }

  else
  {
    int v25 = (os_log_s *)mDNSLogCategory_Default_redacted;
    BOOL v28 = os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT);
    uint64_t v27 = 4294901756LL;
    if (v28) {
      goto LABEL_17;
    }
  }

  return v27;
}

uint64_t mDNSPlatformSendUDP( void *a1, unsigned __int16 *a2, uint64_t a3, uint64_t a4, uint64_t a5, int *a6, unsigned int a7, int a8)
{
  if (a4)
  {
    uint64_t v14 = *(void *)mDNSStorage;
    if (!*(void *)mDNSStorage)
    {
LABEL_6:
      uint64_t v15 = mDNSLogCategory_NAT;
      uint64_t v16 = 4294901756LL;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_NAT == mDNSLogCategory_State)
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT, OS_LOG_TYPE_DEFAULT)) {
          return v16;
        }
        *(_DWORD *)buf = 134217984;
        *(void *)__int128 v111 = a4;
        unint64_t v18 = "mDNSPlatformSendUDP: Invalid interface index %p";
      }

      else
      {
        uint64_t v15 = mDNSLogCategory_NAT_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT_redacted, OS_LOG_TYPE_DEFAULT)) {
          return v16;
        }
        *(_DWORD *)buf = 134217984;
        *(void *)__int128 v111 = a4;
        unint64_t v18 = "mDNSPlatformSendUDP: Invalid interface index %p";
      }

      int v22 = (os_log_s *)v15;
      os_log_type_t v23 = OS_LOG_TYPE_DEFAULT;
      uint32_t v24 = 12;
LABEL_32:
      _os_log_impl((void *)&_mh_execute_header, v22, v23, v18, buf, v24);
      return v16;
    }

    while (!*(void *)(v14 + 6480) || *(_DWORD *)(v14 + 6424) != (_DWORD)a4)
    {
      uint64_t v14 = *(void *)(v14 + 6384);
      if (!v14) {
        goto LABEL_6;
      }
    }
  }

  else
  {
    uint64_t v14 = 0LL;
  }

  if (a4) {
    uint64_t v19 = (const char *)(v14 + 6310);
  }
  else {
    uint64_t v19 = "unicast";
  }
  if (*a6 == 6)
  {
    *(_WORD *)&v134[0].sa_leuint64_t n = 7708;
    *(_WORD *)v134[0].sa___int16 data = a7;
    *(sockaddr *)&v134[0].sa_data[6] = *(sockaddr *)(a6 + 1);
    if (v14) {
      int v25 = *(_DWORD *)(v14 + 6424);
    }
    else {
      int v25 = 0;
    }
    *(_DWORD *)&v134[1].sa_data[6] = v25;
    __int128 v109 = a1;
    if (a5) {
      int v30 = (int *)(a5 + 48);
    }
    else {
      int v30 = (int *)(*a1 + 56LL);
    }
    int v28 = *v30;
    if (!v14) {
      goto LABEL_80;
    }
    __int128 v107 = v19;
    if (!mDNSAddrIsDNSMulticast(a6)) {
      goto LABEL_75;
    }
    int v32 = (unsigned int *)(v14 + 6424);
    int v33 = setsockopt(v28, 41, 9, (const void *)(v14 + 6424), 4u);
    if ((v33 & 0x80000000) == 0) {
      goto LABEL_75;
    }
    int v34 = v33;
    __errunsigned int num = *__error();
    *(void *)uint64_t v132 = 0LL;
    uint64_t v133 = 0LL;
    unsigned __int16 v35 = if_indextoname(*v32, v132);
    char v36 = gSensitiveLoggingEnabled;
    if (mDNSLogCategory_NAT == mDNSLogCategory_State) {
      char v36 = 0;
    }
    if (v35)
    {
      if ((v36 & 1) != 0)
      {
        uint64_t v37 = mDNSLogCategory_NAT_redacted;
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_NAT_redacted, OS_LOG_TYPE_ERROR)) {
          goto LABEL_63;
        }
      }

      else
      {
        uint64_t v37 = mDNSLogCategory_NAT;
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_NAT, OS_LOG_TYPE_ERROR))
        {
LABEL_63:
          unsigned int v102 = bswap32(*a2) >> 16;
          *(_DWORD *)buf = 67109890;
          *(_DWORD *)__int128 v111 = v102;
          *(_WORD *)&v111[4] = 1024;
          *(_DWORD *)&v111[6] = v34;
          *(_WORD *)&v111[10] = 1024;
          *(_DWORD *)&v111[12] = __errnum;
          *(_WORD *)&v111[16] = 2082;
          *(void *)&v111[18] = strerror(__errnum);
          unsigned __int16 v43 = "[Q%u] setsockopt - IPV6_MULTICAST_IF error %d errno %d (%{public}s)";
          size_t v44 = (os_log_s *)v37;
          uint32_t v45 = 30;
LABEL_74:
          _os_log_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_ERROR, v43, buf, v45);
        }
      }

LABEL_75:
      if (mDNSAddrIsDNSMulticast(a6)) {
        goto LABEL_76;
      }
      uint64_t v19 = v107;
      if (!*(_DWORD *)(v14 + 6424))
      {
        unsigned __int16 v80 = (os_log_s *)mDNSLogCategory_NAT;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_NAT == mDNSLogCategory_State)
        {
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_80;
          }
        }

        else
        {
          unsigned __int16 v80 = (os_log_s *)mDNSLogCategory_NAT_redacted;
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT_redacted, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_80;
          }
        }

        unsigned int v83 = bswap32(*a2);
        *(_DWORD *)buf = 67109634;
        *(_DWORD *)__int128 v111 = HIWORD(v83);
        *(_WORD *)&v111[4] = 2048;
        *(void *)&v111[6] = v14;
        *(_WORD *)&v111[14] = 2082;
        *(void *)&v111[16] = v107;
        _os_log_impl( (void *)&_mh_execute_header,  v80,  OS_LOG_TYPE_DEFAULT,  "[Q%u] IPV6_BOUND_IF socket option not set -- info %p (%{public}s) scope_id is zero",  buf,  0x1Cu);
LABEL_80:
        if (v28 < 0) {
          return 4294901747LL;
        }
        if (a8)
        {
          *(_DWORD *)buf = 100;
          setsockopt(v28, 0xFFFF, 4230, buf, 4u);
        }

        ssize_t v55 = sendto(v28, a2, a3 - (void)a2, 0, v134, v134[0].sa_len);
        int v56 = 0;
        if (v55 < 0) {
          int v56 = *__error();
        }
        if (a8)
        {
          *(_DWORD *)buf = 900;
          setsockopt(v28, 0xFFFF, 4230, buf, 4u);
        }

        if ((v55 & 0x8000000000000000LL) == 0) {
          return 0LL;
        }
        __int128 v108 = v19;
        uint64_t v57 = (os_log_s *)mDNSLogCategory_NAT;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_NAT == mDNSLogCategory_State)
        {
          BOOL v58 = os_log_type_enabled((os_log_t)mDNSLogCategory_NAT, OS_LOG_TYPE_ERROR);
          if (!v58) {
            goto LABEL_97;
          }
          unsigned int v70 = bswap32(*a2) >> 16;
          int v71 = *a6;
          uint64_t v72 = strerror(v56);
          int v73 = *((_DWORD *)v109 + 16);
          *(_DWORD *)buf = 67112451;
          *(_DWORD *)__int128 v111 = v70;
          *(_WORD *)&v111[4] = 1024;
          *(_DWORD *)&v111[6] = v28;
          *(_WORD *)&v111[10] = 2048;
          *(void *)&v111[12] = a4;
          *(_WORD *)&v111[20] = 2082;
          *(void *)&v111[22] = v108;
          __int16 v112 = 1024;
          int v113 = v71;
          __int16 v114 = 2160;
          *(void *)__int128 v115 = 1752392040LL;
          *(_WORD *)&v115[8] = 1045;
          *(_DWORD *)&v115[10] = 20;
          __int16 v116 = 2101;
          __int128 v117 = a6;
          __int16 v118 = 1024;
          unsigned int v119 = bswap32(a7) >> 16;
          __int16 v120 = 1024;
          int v121 = v28;
          __int16 v122 = 2048;
          ssize_t v123 = v55;
          __int16 v124 = 1024;
          int v125 = v56;
          __int16 v126 = 2082;
          __int128 v127 = v72;
          __int16 v128 = 1024;
          int v129 = v73;
        }

        else
        {
          uint64_t v57 = (os_log_s *)mDNSLogCategory_NAT_redacted;
          BOOL v58 = os_log_type_enabled((os_log_t)mDNSLogCategory_NAT_redacted, OS_LOG_TYPE_ERROR);
          if (!v58) {
            goto LABEL_97;
          }
          unsigned int v66 = bswap32(*a2) >> 16;
          int v67 = *a6;
          ssize_t v68 = strerror(v56);
          int v69 = *((_DWORD *)v109 + 16);
          *(_DWORD *)buf = 67112451;
          *(_DWORD *)__int128 v111 = v66;
          *(_WORD *)&v111[4] = 1024;
          *(_DWORD *)&v111[6] = v28;
          *(_WORD *)&v111[10] = 2048;
          *(void *)&v111[12] = a4;
          *(_WORD *)&v111[20] = 2082;
          *(void *)&v111[22] = v108;
          __int16 v112 = 1024;
          int v113 = v67;
          __int16 v114 = 2160;
          *(void *)__int128 v115 = 1752392040LL;
          *(_WORD *)&v115[8] = 1045;
          *(_DWORD *)&v115[10] = 20;
          __int16 v116 = 2101;
          __int128 v117 = a6;
          __int16 v118 = 1024;
          unsigned int v119 = bswap32(a7) >> 16;
          __int16 v120 = 1024;
          int v121 = v28;
          __int16 v122 = 2048;
          ssize_t v123 = v55;
          __int16 v124 = 1024;
          int v125 = v56;
          __int16 v126 = 2082;
          __int128 v127 = v68;
          __int16 v128 = 1024;
          int v129 = v69;
        }

        _os_log_impl( (void *)&_mh_execute_header,  v57,  OS_LOG_TYPE_ERROR,  "[Q%u] mDNSPlatformSendUDP -> sendto(%d) failed to send packet on InterfaceID %p %{public}s/%d to %{sensitive, mask.hash, mdnsresponder:ip_addr}.20P:%d skt %d error %ld errno %d (%{public}s) %u",  buf,  0x6Eu);
LABEL_97:
        int v74 = *a6;
        if (*a6 == 6)
        {
          if (a6[1] != 767 || a6[2] || a6[3]) {
            goto LABEL_109;
          }
          int v75 = a6[4];
          int v76 = -83886080;
        }

        else
        {
          if (v74 != 4) {
            goto LABEL_109;
          }
          int v75 = a6[1];
          int v76 = -83885856;
        }

        if (v75 == v76)
        {
          if (v56 != 49)
          {
            if (v56 != 50)
            {
              if (v56 == 65)
              {
                return 4294901734LL;
              }

LABEL_128:
            uint64_t v81 = mDNSLogCategory_NAT;
            if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_NAT == mDNSLogCategory_State)
            {
              int v82 = v108;
              if (os_log_type_enabled((os_log_t)mDNSLogCategory_NAT, OS_LOG_TYPE_ERROR))
              {
LABEL_138:
                unsigned int v84 = bswap32(*a2) >> 16;
                int v85 = *a6;
                unint64_t v86 = strerror(v56);
                int v87 = *((_DWORD *)v109 + 16);
                *(_DWORD *)buf = 67112451;
                *(_DWORD *)__int128 v111 = v84;
                *(_WORD *)&v111[4] = 1024;
                *(_DWORD *)&v111[6] = v28;
                *(_WORD *)&v111[10] = 2048;
                *(void *)&v111[12] = a4;
                *(_WORD *)&v111[20] = 2082;
                *(void *)&v111[22] = v82;
                __int16 v112 = 1024;
                int v113 = v85;
                __int16 v114 = 2160;
                *(void *)__int128 v115 = 1752392040LL;
                *(_WORD *)&v115[8] = 1045;
                *(_DWORD *)&v115[10] = 20;
                __int16 v116 = 2101;
                __int128 v117 = a6;
                __int16 v118 = 1024;
                unsigned int v119 = bswap32(a7) >> 16;
                __int16 v120 = 1024;
                int v121 = v28;
                __int16 v122 = 2048;
                ssize_t v123 = v55;
                __int16 v124 = 1024;
                int v125 = v56;
                __int16 v126 = 2082;
                __int128 v127 = v86;
                __int16 v128 = 1024;
                int v129 = v87;
                __int16 v88 = "[Q%u] mDNSPlatformSendUDP sendto(%d) failed to send packet on InterfaceID %p %{public}s/%d to %{se"
                      "nsitive, mask.hash, mdnsresponder:ip_addr}.20P:%d skt %d error %ld errno %d (%{public}s) %u";
                uint64_t v89 = (os_log_s *)v81;
                os_log_type_t v90 = OS_LOG_TYPE_ERROR;
                uint32_t v91 = 110;
LABEL_144:
                _os_log_impl((void *)&_mh_execute_header, v89, v90, v88, buf, v91);
              }
            }

            else
            {
              uint64_t v81 = mDNSLogCategory_NAT_redacted;
              int v82 = v108;
              if (os_log_type_enabled((os_log_t)mDNSLogCategory_NAT_redacted, OS_LOG_TYPE_ERROR)) {
                goto LABEL_138;
              }
            }

            return 4294901759LL;
          }

    free(v38);
    return 0LL;
  }

  if (a2) {
    *((_DWORD *)v38 + 4) = v22;
  }
  *((_DWORD *)v38 + 6) = DomainNameHashValue(*((void *)v38 + 5));
  SetNewRData((uint64_t)v38 + 8, 0LL, 0LL, v62, v63, v64, v65, v66);
  return v38;
}

      if (v4 < 4
        || (*(_BYTE *)(v5 + 264) & 8) != 0
        || SameDomainNameBytes((_BYTE *)(v5 + 8), "\x05local")
        || *(void *)(v5 + 272))
      {
        goto LABEL_146;
      }

      unsigned __int16 v80 = mDNS_GetDomains(v5 + 2248, 3, (char *)(v5 + 8), 0LL, (uint64_t)FoundDomain, v5);
      uint64_t v81 = mDNSLogCategory_State;
      if (v80)
      {
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 67109376;
          *(_DWORD *)uint64_t v93 = v62;
          *(_WORD *)&v93[4] = 1024;
          *(_DWORD *)&v93[6] = v80;
          int v82 = (os_log_s *)v81;
          unsigned int v83 = OS_LOG_TYPE_ERROR;
          unsigned int v84 = "uDNS_SetupWABQueries: GetDomains(mDNS_DomainTypeRegistration) returned error -- name hash: %x, error: %d";
          int v85 = 14;
LABEL_137:
          _os_log_impl((void *)&_mh_execute_header, v82, v83, v84, buf, v85);
        }
      }

      else if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 67109120;
        *(_DWORD *)uint64_t v93 = v62;
        int v82 = (os_log_s *)v81;
        unsigned int v83 = OS_LOG_TYPE_DEFAULT;
        unsigned int v84 = "uDNS_SetupWABQueries: Starting Registration for domain -- name hash: %x";
        int v85 = 8;
        goto LABEL_137;
      }

      unint64_t v86 = mDNS_GetDomains(v5 + 2904, 4, (char *)(v5 + 8), *(void *)(v5 + 272), (uint64_t)FoundDomain, v5);
      int v87 = (os_log_s *)mDNSLogCategory_State;
      if (v86)
      {
        __int16 v88 = v86;
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 67109376;
          *(_DWORD *)uint64_t v93 = v62;
          *(_WORD *)&v93[4] = 1024;
          *(_DWORD *)&v93[6] = v88;
          _os_log_impl( (void *)&_mh_execute_header,  v87,  OS_LOG_TYPE_ERROR,  "uDNS_SetupWABQueries: GetDomains(mDNS_DomainTypeRegistrationDefault) returned error -- name hash: %x, error: %d",  buf,  0xEu);
        }

        if (v80) {
          goto LABEL_146;
        }
      }

      else if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 67109120;
        *(_DWORD *)uint64_t v93 = v62;
        _os_log_impl( (void *)&_mh_execute_header,  v87,  OS_LOG_TYPE_DEFAULT,  "uDNS_SetupWABQueries: Starting Default Registration for domain -- name hash: %x",  buf,  8u);
      }

      *(_DWORD *)(v5 + 264) |= 8u;
LABEL_146:
      uint64_t v6 = (uint64_t *)v5;
      char v5 = *(void *)v5;
    }

    while (v5);
  }

LABEL_126:
          if (*((_DWORD *)v109 + 2)) {
            return 4294901734LL;
          }
          goto LABEL_128;
        }

    free(bufferb);
    int v94 = v96;
LABEL_127:
    free(v94);
    goto LABEL_83;
  }

  if (v111 + v110 == -4LL || (int v101 = calloc(1uLL, __sizea)) == 0LL)
  {
LABEL_143:
    __break(1u);
    goto LABEL_144;
  }

  unsigned int v102 = v101;
  *int v101 = bswap32(v111) >> 16;
  *(_WORD *)((char *)v101 + v111 + 2) = bswap32(v110) >> 16;
  *(void *)&applier = _NSConcreteStackBlock;
  *((void *)&applier + 1) = 0x40000000LL;
  *(void *)&uint64_t v132 = __mdns_encrypt_oblivious_request_block_invoke;
  *((void *)&v132 + 1) = &__block_descriptor_tmp_124;
  *(void *)&uint64_t v133 = v101 + 1;
  dispatch_data_apply(a2, &applier);
  int v103 = cchpke_initiator_encrypt( v96,  p_applier,  bufferb,  __sizea,  v102,  &contexta[length],  v113,  &contexta[length + __sizea]);
  if (v103)
  {
    char v104 = v103;
    if (_mdns_crypto_log_s_once != -1) {
      dispatch_once(&_mdns_crypto_log_s_once, &__block_literal_global_115);
    }
    __int16 v105 = (os_log_s *)_mdns_crypto_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_crypto_log_s_log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 67109120;
      *(_DWORD *)&uint8_t buf[4] = v104;
      _os_log_error_impl((void *)&_mh_execute_header, v105, OS_LOG_TYPE_ERROR, "Encrypt error: %d", buf, 8u);
    }

    free(v102);
    goto LABEL_126;
  }

  *(void *)(a1 + 152) = v96;
  *(void *)(a1 + 160) = 96LL;
  *(void *)(a1 + 168) = v102;
  *(void *)(a1 + 176) = __sizea;
  int v106 = dispatch_data_create(bufferb, size, 0LL, _dispatch_data_destructor_free);
  int v74 = _mdns_resolver_log_s_once;
  if (!v106) {
    goto LABEL_84;
  }
  uint64_t v15 = v106;
  if (_mdns_resolver_log_s_once != -1) {
    dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_48);
  }
  __int128 v107 = (os_log_s *)_mdns_resolver_log_s_log;
  if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_DEBUG))
  {
    LOWORD(applier) = 0;
    _os_log_debug_impl( (void *)&_mh_execute_header,  v107,  OS_LOG_TYPE_DEBUG,  "Created oblivious request",  (uint8_t *)&applier,  2u);
  }

  options = 0LL;
  uint64_t v14 = 0;
  a2 = (dispatch_data_s *)v15;
LABEL_23:
  if (!*(void *)(v8 + 176))
  {
    __int16 v112 = options;
    __int16 v114 = v15;
    a3 = v123;
LABEL_47:
    os_retain((void *)a1);
    int v34 = *(void **)(*(void *)(a1 + 32) + 48LL);
    url = nw_endpoint_get_url(*(nw_endpoint_t *)(a1 + 112));
    __size = *(void *)(v8 + 192);
    v125[0] = _NSConcreteStackBlock;
    v125[1] = 0x40000000LL;
    v125[2] = ___mdns_url_session_send_block_invoke_104;
    v125[3] = &__block_descriptor_tmp_106;
    v125[4] = a1;
    __int16 v126 = v10;
    __int16 v124 = v34;
    buffer = a2;
    char v36 = v125;
    context = objc_autoreleasePoolPush();
    if (v10)
    {
      uint64_t v37 = objc_alloc(&OBJC_CLASS___NSMutableURLRequest);
      uint64_t v38 = objc_alloc(&OBJC_CLASS___NSURL);
      int v39 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", url));
      int v40 = -[NSURL initWithString:](v38, "initWithString:", v39);
      int v41 = -[NSMutableURLRequest initWithURL:](v37, "initWithURL:", v40);

      -[NSMutableURLRequest setHTTPMethod:](v41, "setHTTPMethod:", @"POST");
      -[NSMutableURLRequest setHTTPBody:](v41, "setHTTPBody:", buffer);
      uint64_t v42 = @"application/oblivious-dns-message";
    }

    else
    {
      unsigned __int16 v43 = (void *)[buffer base64EncodedStringWithOptions:0LL];
      size_t v44 = (void *)[v43 stringByReplacingOccurrencesOfString:@"/" withString:@"_"];

      uint32_t v45 = (void *)[v44 stringByReplacingOccurrencesOfString:@"+" withString:@"-"];
      int v46 = (void *)[v45 stringByReplacingOccurrencesOfString:@"=" withString:&stru_10013F428];

      uint64_t v47 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"%s?dns=%@",  url,  v46));
      uint64_t v48 = objc_alloc(&OBJC_CLASS___NSMutableURLRequest);
      uint64_t v49 = a3;
      int v50 = -[NSURL initWithString:](objc_alloc(&OBJC_CLASS___NSURL), "initWithString:", v47);
      int v41 = -[NSMutableURLRequest initWithURL:](v48, "initWithURL:", v50);

      a3 = v49;
      -[NSMutableURLRequest setHTTPMethod:](v41, "setHTTPMethod:", @"GET");

      uint64_t v42 = @"application/dns-message";
    }

    int v51 = v42;
    -[NSMutableURLRequest setValue:forHTTPHeaderField:](v41, "setValue:forHTTPHeaderField:", v51, @"accept");
    -[NSMutableURLRequest setValue:forHTTPHeaderField:](v41, "setValue:forHTTPHeaderField:", v51, @"content-type");
    uint64_t v52 = (nw_interface *)nw_endpoint_copy_interface(v124);
    unsigned int v53 = v52;
    if (v52)
    {
      unsigned int v54 = +[NSString stringWithUTF8String:]( &OBJC_CLASS___NSString,  "stringWithUTF8String:",  nw_interface_get_name(v52));
      ssize_t v55 = (void *)objc_claimAutoreleasedReturnValue(v54);
      -[NSMutableURLRequest setBoundInterfaceIdentifier:](v41, "setBoundInterfaceIdentifier:", v55);
    }

    *(void *)buf = 0LL;
    unint64_t v143 = buf;
    unsigned int v144 = 0x3032000000LL;
    unsigned int v145 = __Block_byref_object_copy_;
    unsigned int v146 = __Block_byref_object_dispose_;
    int v147 = 0LL;
    if (a3 == 28)
    {
      int v56 = 2LL;
    }

    else
    {
      if (a3 != 1)
      {
LABEL_58:
        *(void *)&applier = _NSConcreteStackBlock;
        *((void *)&applier + 1) = 3221225472LL;
        *(void *)&uint64_t v132 = __http_task_create_dns_query_block_invoke;
        *((void *)&v132 + 1) = &unk_100139CF0;
        *(void *)&uint64_t v134 = buf;
        uint64_t v59 = v41;
        *(void *)&uint64_t v133 = v59;
        uint64_t v60 = v36;
        *((void *)&v133 + 1) = v60;
        uint64_t v61 = _http_task_create_data_task(v59, &applier);
        uint64_t v62 = (void *)objc_claimAutoreleasedReturnValue(v61);
        [v62 set_hostOverride:v124];
        if (v62 && *((void *)v143 + 5)) {
          [v62 set_nw_activity:];
        }
        if (__size)
        {
          uint64_t v63 = (void *)[v62 _effectiveConfiguration];
          uint64_t v64 = -[NSURLSessionConfiguration _initWithConfiguration:]( objc_alloc(&OBJC_CLASS___NSURLSessionConfiguration),  "_initWithConfiguration:",  v63);
          uint64_t v139 = __size;
          uint64_t v140 = _kCFStreamPropertySSLClientCertificates;
          uint64_t v65 = (void *)objc_claimAutoreleasedReturnValue( +[NSArray arrayWithObjects:count:]( &OBJC_CLASS___NSArray,  "arrayWithObjects:count:",  &v139,  1LL));
          int v141 = v65;
          unsigned int v66 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v141,  &v140,  1LL));
          [v64 set_socketStreamProperties:v66];

          [v62 _adoptEffectiveConfiguration:v64];
        }

        _Block_object_dispose(buf, 8);
        objc_autoreleasePoolPop(context);

        *(void *)(a1 + 144) = v62;
        if (v62)
        {
          int v67 = objc_autoreleasePoolPush();
          [v62 resume];
          objc_autoreleasePoolPop(v67);
          options = v112;
          uint64_t v15 = v114;
          if (!v112) {
            goto LABEL_66;
          }
          goto LABEL_65;
        }

        os_release((void *)a1);
        if (_mdns_resolver_log_s_once != -1) {
          dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_48);
        }
        options = v112;
        uint64_t v15 = v114;
        __int128 v108 = (os_log_s *)_mdns_resolver_log_s_log;
        if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_ERROR))
        {
          LOWORD(applier) = 0;
          _os_log_error_impl( (void *)&_mh_execute_header,  v108,  OS_LOG_TYPE_ERROR,  "Failed to create HTTP task",  (uint8_t *)&applier,  2u);
        }

        goto LABEL_88;
      }

      int v56 = 1LL;
    }

    uint64_t v57 = nw_activity_create(33LL, v56);
    BOOL v58 = (void *)*((void *)v143 + 5);
    *((void *)v143 + 5) = v57;

    if (*((void *)v143 + 5)) {
      nw_activity_activate();
    }
    goto LABEL_58;
  }

  nw_parameters_clear_custom_proxy_configs(*(void *)(a1 + 120));
  nw_parameters_add_custom_proxy_config(*(void *)(a1 + 120), *(void *)(v8 + 176));
  if (options)
  {
    uint64_t v17 = nw_parameters_copy_default_protocol_stack(*(nw_parameters_t *)(a1 + 120));
    nw_protocol_stack_clear_application_protocols(v17);
    nw_protocol_stack_append_application_protocol(v17, options);
    if (v17) {
      nw_release(v17);
    }
  }

  unint64_t v18 = nw_connection_create(*(nw_endpoint_t *)(a1 + 112), *(nw_parameters_t *)(a1 + 120));
  *(void *)(a1 + 128) = v18;
  if (!v18)
  {
    int v76 = -6729;
LABEL_89:
    _mdns_common_session_terminate_async((void *)a1, v76);
    if (!options) {
      goto LABEL_66;
    }
LABEL_65:
    nw_release(options);
    goto LABEL_66;
  }

  os_retain((void *)a1);
  uint64_t v19 = *(nw_connection **)(a1 + 128);
  __int16 v20 = options;
  __int16 v21 = v15;
  if (_mdns_resolver_queue_s_once != -1) {
    dispatch_once(&_mdns_resolver_queue_s_once, &__block_literal_global_138);
  }
  nw_connection_set_queue(v19, (dispatch_queue_t)_mdns_resolver_queue_s_queue);
  int v22 = *(nw_connection **)(a1 + 128);
  handler[0] = _NSConcreteStackBlock;
  handler[1] = 0x40000000LL;
  handler[2] = ___mdns_url_session_send_block_invoke;
  handler[3] = &__block_descriptor_tmp_91;
  handler[4] = a1;
  nw_connection_set_state_changed_handler(v22, handler);
  os_log_type_t v23 = nw_http_fields_create();
  uint32_t v24 = (void *)v23;
  if (v9) {
    int v25 = "Oblivious Message";
  }
  else {
    int v25 = "HTTP Message";
  }
  if (((v9 != 0) & (v14 ^ 1)) != 0) {
    uint64_t v26 = "application/oblivious-dns-message";
  }
  else {
    uint64_t v26 = "application/dns-message";
  }
  nw_http_fields_set_value_by_name(v23, nw_http_field_name_accept, v26);
  nw_http_fields_set_value_by_name(v24, nw_http_field_name_content_type, v26);
  unsigned int v27 = dispatch_data_get_size(a2);
  uint64_t v137 = 0u;
  uint64_t v138 = 0u;
  uint64_t v135 = 0u;
  uint64_t v136 = 0u;
  uint64_t v133 = 0u;
  uint64_t v134 = 0u;
  applier = 0u;
  uint64_t v132 = 0u;
  snprintf((char *)&applier, 0x80uLL, "%zu", v27);
  nw_http_fields_set_value_by_name(v24, nw_http_field_name_content_length, &applier);
  int v28 = nw_http_request_method_post;
  __int16 v29 = nw_endpoint_get_url(*(nw_endpoint_t *)(a1 + 112));
  int v30 = (void *)nw_http_request_create_from_url(v28, v29);
  nw_http_request_set_header_fields(v30, v24);
  metadata_for_request = (nw_protocol_metadata *)nw_http_create_metadata_for_request(v30);
  if (v30) {
    nw_release(v30);
  }
  int v32 = nw_content_context_create(v25);
  nw_content_context_set_metadata_for_protocol(v32, metadata_for_request);
  if (metadata_for_request) {
    nw_release(metadata_for_request);
  }
  if (v24) {
    nw_release(v24);
  }
  nw_content_context_set_is_final(v32, 1);
  nw_connection_send(*(nw_connection_t *)(a1 + 128), a2, v32, 1, _nw_connection_send_idempotent_content);
  if (v32) {
    nw_release(v32);
  }
  nw_connection_start(*(nw_connection_t *)(a1 + 128));
  *(void *)(a1 + 136) = _mdns_create_and_start_connection_activity(*(void *)(a1 + 128), v123);
  int v33 = *(nw_connection **)(a1 + 128);
  completion[0] = _NSConcreteStackBlock;
  completion[1] = 0x40000000LL;
  completion[2] = ___mdns_url_session_send_block_invoke_96;
  completion[3] = &__block_descriptor_tmp_103;
  completion[4] = a1;
  __int16 v128 = v9 != 0;
  int v129 = v14;
  nw_connection_receive_message(v33, completion);
  uint64_t v15 = v21;
  options = v20;
  if (v20) {
    goto LABEL_65;
  }
LABEL_66:
  if (v15) {
    dispatch_release(v15);
  }
}

      unsigned int v54 = (os_log_s *)v38;
      ssize_t v55 = 2;
LABEL_127:
      _os_log_impl((void *)&_mh_execute_header, v54, OS_LOG_TYPE_DEFAULT, v27, (uint8_t *)&v82, v55);
      goto LABEL_145;
    case 31:
      mDNS_PacketLoggingEnabled = 1;
      uint64_t v42 = (os_log_s *)mDNSLogCategory_Default;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_111;
        }
        int v82 = 136446210;
        unsigned int v83 = "Enabled";
        goto LABEL_110;
      }

      uint64_t v42 = (os_log_s *)mDNSLogCategory_Default_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
      {
        int v82 = 136446210;
        unsigned int v83 = "Enabled";
LABEL_110:
        _os_log_impl( (void *)&_mh_execute_header,  v42,  OS_LOG_TYPE_DEFAULT,  "SIGUSR2: Packet Logging %{public}s on Apple Platforms",  (uint8_t *)&v82,  0xCu);
      }

    int v74 = DNSTypeName(*(unsigned __int16 *)(v47 + 322));
    v75[0] = 67110147;
    v75[1] = v67;
    int v76 = 2160;
    int v77 = 1752392040LL;
    char v78 = 1040;
    uint64_t v79 = v73;
    unsigned __int16 v80 = 2101;
    uint64_t v81 = v47 + 356;
    int v82 = 2082;
    unsigned int v83 = v74;
    _os_log_impl( (void *)&_mh_execute_header,  v65,  OS_LOG_TYPE_DEFAULT,  "[R%u] QueryRecordOpStart: starting parallel unicast query for %{sensitive, mask.hash, mdnsresponder:domain_name}.*P %{public}s",  (uint8_t *)v75,  0x2Cu);
    goto LABEL_127;
  }

BOOL mDNSAddrIsDNSMulticast(_DWORD *a1)
{
  if (*a1 == 6)
  {
    if (a1[1] == 767 && !a1[2] && !a1[3])
    {
      int v2 = -83886080;
      uint64_t v1 = a1 + 4;
      return *v1 == v2;
    }
  }

  else if (*a1 == 4)
  {
    uint64_t v1 = a1 + 1;
    int v2 = -83885856;
    return *v1 == v2;
  }

  return 0LL;
}

void myKQSocketCallBack( int a1, int a2, unsigned __int16 *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = a4;
  int v106 = (uint64_t **)*((void *)a3 + 1);
  int v109 = 0;
  if (a2 != -1)
  {
    uint64_t v99 = 0xFFFFFFFFLL;
    LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "myKQSocketCallBack: Why is filter %d not EVFILT_READ (%d)?",  a4,  a5,  a6,  a7,  a8,  a2);
  }

  if (*((_DWORD *)a3 + 4) != a1 && *((_DWORD *)a3 + 12) != a1)
  {
    LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "myKQSocketCallBack: native socket %d",  a4,  a5,  a6,  a7,  a8,  a1);
    uint64_t v99 = *((unsigned int *)a3 + 12);
    LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "myKQSocketCallBack: sktv4 %d sktv6 %d",  v11,  v12,  v13,  v14,  v15,  *((_DWORD *)a3 + 4));
  }

  if (!v8)
  {
    int v17 = 0;
    unint64_t v18 = v106 + 2494;
    int v103 = (unsigned __int8 *)(v106 + 2494);
    int v104 = a1;
    while (1)
    {
      memset(v108, 0, sizeof(v108));
      memset(v107, 0, 20);
      memset(v115, 0, sizeof(v115));
      *(void *)__s2 = 0LL;
      uint64_t v114 = 0LL;
      *(void *)__int128 v111 = v18;
      uint64_t v112 = 8952LL;
      memset(&v110.msg_namelen, 0, 24);
      bzero(&v116, 0x400uLL);
      v110.msg_name = v115;
      v110.msg_nameleuint64_t n = 128;
      v110.msg_iov = (iovec *)v111;
      v110.msg_iovleuint64_t n = 1;
      v110.msg_control = &v116;
      *(void *)&v110.msg_controlleuint64_t n = 1024LL;
      ssize_t v24 = recvmsg(a1, &v110, 0);
      if (v24 < 0)
      {
        if (*__error() == 35) {
          goto LABEL_99;
        }
        unsigned int v50 = myrecvfrom_numLogMessages++;
        if (v50 > 0x63) {
          goto LABEL_99;
        }
        uint64_t v51 = mDNSLogCategory_Default;
        uint64_t v99 = v24;
        uint64_t v100 = *__error();
        int v98 = a1;
        uint64_t v52 = "mDNSMacOSX.c: recvmsg(%d) returned error %d errno %d";
LABEL_95:
        unsigned int v54 = (os_log_s *)v51;
        goto LABEL_98;
      }

      msg_controlleuint64_t n = v110.msg_controllen;
      if (v110.msg_controllen <= 0xB)
      {
        unsigned int v53 = myrecvfrom_numLogMessages++;
        if (v53 > 0x63) {
          goto LABEL_99;
        }
        uint64_t v51 = mDNSLogCategory_Default;
        uint64_t v102 = *__error();
        uint64_t v100 = msg_controllen;
        uint64_t v101 = 12LL;
        int v98 = a1;
        uint64_t v99 = v24;
        uint64_t v52 = "mDNSMacOSX.c: recvmsg(%d) returned %d msg.msg_controllen %d < sizeof(struct cmsghdr) %lu, errno %d";
        goto LABEL_95;
      }

      if ((v110.msg_flags & 0x20) != 0)
      {
        unsigned int v55 = myrecvfrom_numLogMessages++;
        if (v55 <= 0x63)
        {
          unsigned int v54 = (os_log_s *)mDNSLogCategory_Default;
          int v98 = a1;
          uint64_t v52 = "mDNSMacOSX.c: recvmsg(%d) msg.msg_flags & MSG_CTRUNC";
LABEL_98:
          LogMsgWithLevel(v54, OS_LOG_TYPE_DEFAULT, v52, v19, v20, v21, v22, v23, v98);
        }

LABEL_99:
        int v61 = *__error();
        if (v61 == 57)
        {
          if (mDNS_LoggingEnabled == 1) {
            LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "myKQSocketCallBack: ENOTCONN, closing socket",  v56,  v57,  v58,  v59,  v60,  v97);
          }
          close(a1);
        }

        else if (v61 != 35 || !v17)
        {
          LODWORD(v110.msg_name) = -1;
          *(_DWORD *)__int128 v108 = -1;
          v107[0] = -1;
          *(void *)&v115[0].tv_usec = 0LL;
          memset(&v116, 0, sizeof(v116));
          if (__darwin_check_fd_set_overflow(a1, &v116, 0)) {
            *(__int32_t *)((char *)v116.fds_bits + (((unint64_t)a1 >> 3) & 0x1FFFFFFFFFFFFFFCLL)) |= 1 << a1;
          }
          v115[0].tv_sec = 0LL;
          select(a1 + 1, &v116, 0LL, 0LL, v115);
          v111[0] = 4;
          if (getsockopt(a1, 0xFFFF, 4103, &v110, v111) == -1)
          {
            uint64_t v62 = (os_log_s *)mDNSLogCategory_Default;
            uint64_t v63 = __error();
            LogMsgWithLevel( v62,  OS_LOG_TYPE_DEFAULT,  "myKQSocketCallBack getsockopt(SO_ERROR) error %d",  v64,  v65,  v66,  v67,  v68,  *v63);
          }

          v111[0] = 4;
          if (getsockopt(a1, 0xFFFF, 4128, v108, v111) == -1)
          {
            int v69 = (os_log_s *)mDNSLogCategory_Default;
            unsigned int v70 = __error();
            LogMsgWithLevel( v69,  OS_LOG_TYPE_DEFAULT,  "myKQSocketCallBack getsockopt(SO_NREAD) error %d",  v71,  v72,  v73,  v74,  v75,  *v70);
          }

          if (ioctl(a1, 0x4004667FuLL, v107, v99, v100, v101, v102) == -1)
          {
            int v82 = (os_log_s *)mDNSLogCategory_Default;
            unsigned int v83 = __error();
            LogMsgWithLevel( v82,  OS_LOG_TYPE_DEFAULT,  "myKQSocketCallBack ioctl(FIONREAD) error %d",  v84,  v85,  v86,  v87,  v88,  *v83);
          }

          unsigned int v89 = myKQSocketCallBack_numLogMessages;
          unsigned int v90 = ++myKQSocketCallBack_numLogMessages;
          if (v89 <= 0x63)
          {
            uint32_t v91 = (os_log_s *)mDNSLogCategory_Default;
            strerror(v61);
            __darwin_check_fd_set_overflow(a1, &v116, 0);
            LogMsgWithLevel( v91,  OS_LOG_TYPE_DEFAULT,  "myKQSocketCallBack recvfrom skt %d error %d errno %d (%s) select %d (%spackets waiting) so_error %d so_nre ad %d fionread %d count %d",  v92,  v93,  v94,  v95,  v96,  a1);
            unsigned int v90 = myKQSocketCallBack_numLogMessages;
          }

          if (v90 >= 6) {
            NotifyOfElusiveBug( (int)"Flaw in Kernel (select/recvfrom mismatch)",  (int)"Congratulations, you've reproduced an elusive bug.\rPlease send email to radar-3387020@group.apple.co m.)\rIf possible, please leave your machine undisturbed so that someone can come to investigate the problem.",  v76,  v77,  v78,  v79,  v80,  v81);
          }
          sleep(1u);
        }

        return;
      }

      msg_control = (unsigned int *)v110.msg_control;
      int v105 = v17;
      if (v110.msg_control)
      {
        do
        {
          unsigned int v27 = msg_control[1];
          if (v27)
          {
LABEL_15:
            if (v27 == 41 && msg_control[2] == 46)
            {
              v107[0] = 6;
              *(_OWORD *)&v107[1] = *(_OWORD *)(msg_control + 3);
              unsigned int v28 = msg_control[7];
              __int16 v29 = (void *)myGetIfAddrs_ifa;
              if (myGetIfAddrs_ifa
                || (getifaddrs((ifaddrs **)&myGetIfAddrs_ifa), (__int16 v29 = (void *)myGetIfAddrs_ifa) != 0LL))
              {
                while (1)
                {
                  uint64_t v30 = v29[3];
                  if (v30)
                  {
                  }

                  __int16 v29 = (void *)*v29;
                  if (!v29) {
                    goto LABEL_36;
                  }
                }

                uint64_t v33 = v29[1];
                if (!v33) {
                  __break(1u);
                }
                uint64_t v34 = 0LL;
                while (1)
                {
                  int v35 = *(unsigned __int8 *)(v33 + v34);
                  __s2[v34] = v35;
                  if (!v35) {
                    break;
                  }
                  if (++v34 == 15)
                  {
                    HIBYTE(v114) = 0;
                    goto LABEL_36;
                  }
                }
              }
            }

            goto LABEL_36;
          }

          unsigned int v31 = msg_control[2];
          if (v31 == 20)
          {
            unint64_t v32 = *((unsigned __int8 *)msg_control + 17);
            if (v32 > 0xF) {
              goto LABEL_36;
            }
            __memcpy_chk(__s2, msg_control + 5, v32, 16LL);
            __s2[*((unsigned __int8 *)msg_control + 17)] = 0;
          }

          else
          {
            if (v31 != 7) {
              goto LABEL_36;
            }
            v107[0] = 4;
            v107[1] = msg_control[3];
          }

          unsigned int v27 = msg_control[1];
          if (v27) {
            goto LABEL_15;
          }
LABEL_36:
          msg_control = (unsigned int *)((char *)msg_control + ((*msg_control + 3LL) & 0x1FFFFFFFCLL));
          if (msg_control) {
            BOOL v36 = (char *)(msg_control + 3) > (char *)v110.msg_control + v110.msg_controllen;
          }
          else {
            BOOL v36 = 1;
          }
        }

        while (!v36);
      }

      int v37 = v107[0];
      if (v107[0] == 4)
      {
        if ((v107[1] & 0xF0) == 0xE0) {
          goto LABEL_46;
        }
      }

      else if (v107[0] == 6 && LOBYTE(v107[1]) == 255)
      {
LABEL_46:
        ++*((_DWORD *)*v106 + 26);
      }

      if (BYTE1(v115[0].tv_sec) == 30)
      {
        *(_DWORD *)__int128 v108 = 6;
        *(timeval *)&v108[4] = *(timeval *)&v115[0].tv_usec;
      }

      else
      {
        if (BYTE1(v115[0].tv_sec) != 2)
        {
          LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "myKQSocketCallBack from is unknown address family %d",  v19,  v20,  v21,  v22,  v23,  BYTE1(v115[0].tv_sec));
          return;
        }

        *(_DWORD *)__int128 v108 = 4;
        *(_DWORD *)&v108[4] = HIDWORD(v115[0].tv_sec);
      }

      uint64_t v38 = WORD1(v115[0].tv_sec);
      int v39 = *v106;
      uint64_t v40 = **v106;
      if (v40)
      {
        while (!*(_BYTE *)(v40 + 6400) || strcmp((const char *)(v40 + 6310), __s2))
        {
          uint64_t v40 = *(void *)(v40 + 6384);
          if (!v40) {
            goto LABEL_55;
          }
        }

        uint64_t v46 = *(void *)(v40 + 6256);
        a1 = v104;
        if (v46) {
          goto LABEL_79;
        }
      }

      else
      {
LABEL_55:
        if (v37 == 4)
        {
          int v43 = -83885856;
          uint64_t v42 = &v107[1];
          a1 = v104;
        }

        else
        {
          int v41 = &mDNSInterface_Any;
          a1 = v104;
          if (v37 != 6) {
            goto LABEL_78;
          }
          if (*(void *)&v107[1] != 767LL || (v42 = &v107[4], int v43 = -83886080, v107[3]))
          {
LABEL_72:
            uint64_t v47 = (uint64_t *)xmmword_10015BD30;
            if ((void)xmmword_10015BD30)
            {
              while (*((_DWORD *)v47 + 1566) != 6
                   || !*((_BYTE *)v47 + 6375)
                   || *(_OWORD *)((char *)v47 + 6268) != *(_OWORD *)&v107[1])
              {
                uint64_t v47 = (uint64_t *)*v47;
                if (!v47) {
                  goto LABEL_77;
                }
              }

            uint64_t v100 = *(void *)(v28 + 640);
            if (!v100 || *(_DWORD *)(v28 + 344) != 2)
            {
              uint64_t v102 = !v80;
              int v103 = v68 ^ 1;
              if (v102) {
                int v103 = 1;
              }
              if ((v103 & 1) == 0 && *(void *)(v28 + 104))
              {
                if (mDNS_LoggingEnabled == 1) {
                  LogMsgWithLevel( v30[170],  OS_LOG_TYPE_DEFAULT,  "hndlRecordUpdateReply: Calling record callback on %##s",  v55,  v56,  v57,  v58,  v59,  *(void *)(v28 + 40));
                }
                int v104 = *(_DWORD *)(a1 + 48);
                int v105 = *(_DWORD *)(a1 + 52) + 1;
                *(_DWORD *)(a1 + 52) = v105;
                mDNS_VerifyLockState("Drop Lock", 0, v104, v105, (uint64_t)"hndlRecordUpdateReply", 3627);
                (*(void (**)(uint64_t, uint64_t, void))(v28 + 104))(a1, v28, 0LL);
                mDNS_VerifyLockState( "Reclaim Lock",  0,  *(_DWORD *)(a1 + 48),  *(_DWORD *)(a1 + 52),  (uint64_t)"hndlRecordUpdateReply",  3629);
                --*(_DWORD *)(a1 + 52);
              }

              goto LABEL_86;
            }

            *(_DWORD *)(v28 + 344) = 7;
            *(void *)(v28 + 632) = v100;
            *(_WORD *)(v28 + 618) = *(_WORD *)(v28 + 620);
            *(void *)(v28 + 624) = *(void *)(v28 + 48);
            *(_WORD *)(v28 + 616) = *(_WORD *)(v28 + 20);
            *(void *)(v28 + 640) = 0LL;
            goto LABEL_102;
          }
        }

        LOBYTE(v68) = v113;
        goto LABEL_99;
      default:
        LogMsgWithLevel( v30[170],  OS_LOG_TYPE_DEFAULT,  "Update %##s failed with rcode %d",  v32,  v33,  v34,  v35,  v36,  *(void *)(v28 + 40));
        goto LABEL_45;
    }
  }

                  int v104 = *(void *)(v18 + 40);
                  uint64_t v102 = v48;
                }

                else
                {
                  int v104 = 0LL;
                  uint64_t v102 = 0;
                }

                uint64_t v93 = *(_DWORD *)(a1 + 184);
                uint64_t v94 = *((_DWORD *)v15 + 14);
                uint64_t v96 = *(_DWORD *)(a1 + 236);
                int v98 = *(_DWORD *)(a1 + 172);
                __n_6.tv_sec = 0LL;
                __n_6.tv_nsec = 0LL;
                clock_gettime(_CLOCK_MONOTONIC_RAW, &__n_6);
                uint64_t v60 = 0LL;
                int v61 = __n_6.tv_sec;
                uint64_t v62 = *v20;
                uint64_t v63 = *(unsigned __int16 *)(v18 + 12);
                uint64_t v64 = __n;
                uint64_t v65 = __n + 2;
                if (v65 <= v31)
                {
                  *unint64_t v32 = __rev16(v63);
                  memcpy(v32 + 1, __src, v64);
                  uint64_t v60 = v32;
                }

                LODWORD(__n_6.tv_sec) = 67112451;
                HIDWORD(__n_6.tv_sec) = v93;
                LOWORD(__n_6.tv_nsec) = 1024;
                *(_DWORD *)((char *)&__n_6.tv_nsec + 2) = v94;
                HIWORD(__n_6.tv_nsec) = 2160;
                *(void *)__int128 v115 = 1752392040LL;
                *(_WORD *)&timeval v115[8] = 1040;
                fd_set v116 = v102;
                __int128 v117 = 2101;
                __int16 v118 = v104;
                unsigned int v119 = 1024;
                __int16 v120 = v19;
                int v121 = 1024;
                __int16 v122 = v96;
                ssize_t v123 = 2082;
                __int16 v124 = a1 + 240;
                int v125 = 1024;
                __int16 v126 = v98;
                __int128 v127 = 1024;
                __int16 v128 = v61 - v62;
                int v129 = 1024;
                __int16 v130 = v63;
                int v131 = 2160;
                uint64_t v132 = 1752392040LL;
                uint64_t v133 = 1040;
                uint64_t v134 = v65;
                uint64_t v135 = 2101;
                uint64_t v136 = v60;
                uint64_t v66 = v100;
                goto LABEL_108;
              }
            }

            int v17 = (const char *)(a1 + 240);
            if (v109) {
              free(v109);
            }
          }

          if (v25) {
            free(v25);
          }
          goto LABEL_113;
        }

        if (*(_WORD *)(v18 + 20))
        {
          int v25 = 0LL;
          LODWORD(v24) = 512;
          uint64_t v26 = (char *)&unk_100164138;
          goto LABEL_34;
        }

        int v37 = mDNSLogCategory_mDNS;
        if (v16[1384] == 1 && mDNSLogCategory_mDNS != mDNSLogCategory_State)
        {
          unsigned int v54 = mDNSLogCategory_mDNS_redacted;
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_113;
          }
          uint64_t v56 = *(void *)(v18 + 40);
          msghdr v110 = (os_log_s *)v54;
          if (v56)
          {
            uint64_t v57 = *(_BYTE **)(v18 + 40);
            if (v56 == -256) {
              goto LABEL_87;
            }
LABEL_84:
            uint64_t v58 = 257;
            if ((unint64_t)v57 < v56 + 256 && v57)
            {
              while (1)
              {
                uint64_t v59 = *v57;
                if (v59 > 0x3F)
                {
LABEL_133:
                  uint64_t v58 = 257;
                  goto LABEL_138;
                }

                if (!*v57) {
                  break;
                }
                v57 += v59 + 1;
                if (v56 != -256) {
                  goto LABEL_84;
                }
LABEL_87:
                if (!v57) {
                  goto LABEL_133;
                }
              }

              uint64_t v58 = (_WORD)v57 - v56 + 1;
            }

        *(_DWORD *)(v8 + 96) = 0;
        *(_WORD *)(v8 + 100) = bswap32(*(unsigned __int16 *)(a8 + 320)) >> 16;
        goto LABEL_47;
      }

      if (v21)
      {
        os_release(v21);
        *(void *)(a1 + 112) = 0LL;
      }
    }

    uint64_t v21 = mdns_domain_name_create_with_labels(v18, 0LL);
    *(void *)(a1 + 112) = v21;
    goto LABEL_9;
  }

                uint64_t v56 = 0;
                if (*(void *)(v1 + 64))
                {
                  unint64_t v9 = -6709;
                  goto LABEL_110;
                }

                int started = _dnssec_obj_validation_manager_start_sub_query( v6,  rr_class,  v12,  0x200000,  a1,  (uint64_t)_dnssec_query_key_record_result_reply,  &v56);
                *(void *)(v1 + 56) = started;
                unint64_t v9 = v56;
                if (v56)
                {
LABEL_110:
                  unsigned int v55 = v9;
                  goto LABEL_115;
                }

                int v44 = started;
                int v45 = (os_log_s *)mDNSLogCategory_DNSSEC;
                if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_DNSSEC == mDNSLogCategory_State)
                {
                  if (!os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC, OS_LOG_TYPE_INFO)) {
                    goto LABEL_114;
                  }
                  uint64_t v46 = *(unsigned __int16 *)(v1 + 24);
                  uint64_t v47 = bswap32(*((unsigned __int16 *)v44 + 160)) >> 16;
                  if (v6)
                  {
                    uint64_t v48 = *(_DWORD *)(v6 + 24);
                    uint64_t v49 = *(void *)(v6 + 16);
                  }

                  else
                  {
                    uint64_t v48 = 0;
                    uint64_t v49 = 0LL;
                  }
                }

                else
                {
                  int v45 = (os_log_s *)mDNSLogCategory_DNSSEC_redacted;
                  if (!os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC_redacted, OS_LOG_TYPE_INFO)) {
                    goto LABEL_114;
                  }
                  uint64_t v46 = *(unsigned __int16 *)(v1 + 24);
                  uint64_t v47 = bswap32(*((unsigned __int16 *)v44 + 160)) >> 16;
                  if (v6)
                  {
                    uint64_t v48 = *(_DWORD *)(v6 + 24);
                    uint64_t v49 = *(void *)(v6 + 16);
                  }

                  else
                  {
                    uint64_t v48 = 0;
                    uint64_t v49 = 0LL;
                  }
                }

                *(_DWORD *)buf = 67110403;
                uint64_t v58 = v46;
                uint64_t v59 = 1024;
                *(_DWORD *)uint64_t v60 = v47;
                *(_WORD *)&v60[4] = 2160;
                *(void *)&v60[6] = 1752392040LL;
                int v61 = 1040;
                *(_DWORD *)uint64_t v62 = v48;
                *(_WORD *)&v62[4] = 2101;
                *(void *)&v62[6] = v49;
                *(_WORD *)&v62[14] = 1024;
                *(_DWORD *)&v62[16] = v12;
                _os_log_impl( (void *)&_mh_execute_header,  v45,  OS_LOG_TYPE_INFO,  "[Q%u->SubQ%u] Start to query validated key records to validate the RRSet - qname: %{sensitive, mask.ha sh, mdnsresponder:domain_name}.*P, qtype: %{mdns:rrtype}d",  buf,  0x2Eu);
LABEL_114:
                unint64_t v9 = v56;
                unsigned int v55 = v56;
                if (!v56) {
                  goto LABEL_116;
                }
                goto LABEL_115;
              }

              goto LABEL_125;
            }
          }

          if (!v33) {
            goto LABEL_96;
          }
          goto LABEL_99;
        }
      }

      else
      {
        uint64_t v4 = 0LL;
      }

      int v8 = *(void *)(v1 + 40);
      if (v8 && *(_DWORD *)(v8 + 40) != 3 && *(void *)(v8 + 32))
      {
        unsigned int v7 = dnssec_obj_rrset_copy_signer_name(v8, (int *)buf);
        char v5 = *(_DWORD *)buf;
        if (*(_DWORD *)buf && *(_DWORD *)buf != -6727)
        {
          uint64_t v6 = 0LL;
          goto LABEL_27;
        }
      }

      else
      {
        unsigned int v7 = 0LL;
      }

      if (v4) {
        uint64_t v6 = (uint64_t)v4;
      }
      else {
        uint64_t v6 = (uint64_t)v7;
      }
      if (v6)
      {
        char v5 = 0;
        ++*(_DWORD *)v6;
        *(_DWORD *)buf = 0;
      }

      else
      {
        char v5 = -6745;
        *(_DWORD *)buf = -6745;
      }

      goto LABEL_27;
    }
  }

LABEL_86:
              int v41 = v47 + 782;
              goto LABEL_78;
            }

            goto LABEL_77;
          }
        }

        if (*v42 == v43)
        {
          int v44 = v109;
          int v45 = v105;
          unint64_t v18 = v106 + 2494;
          goto LABEL_84;
        }
      }

      if (v37 == 6) {
        goto LABEL_72;
      }
      int v41 = &mDNSInterface_Any;
      if (v37 == 4)
      {
        uint64_t v47 = (uint64_t *)xmmword_10015BD30;
        if ((void)xmmword_10015BD30)
        {
          while (*((_DWORD *)v47 + 1566) != 4 || !*((_BYTE *)v47 + 6375) || *((_DWORD *)v47 + 1567) != v107[1])
          {
            uint64_t v47 = (uint64_t *)*v47;
            if (!v47) {
              goto LABEL_77;
            }
          }

          goto LABEL_86;
        }

              uint64_t v66 = v36;
              uint64_t v67 = mDNS_DomainNameFNV1aHash(v17);
              uint64_t v68 = bswap32(*(unsigned __int16 *)(v11[343] + 8LL)) >> 16;
              int v69 = *(_DWORD *)(a1 + 232);
              unsigned int v70 = *(_DWORD *)(a1 + 236);
              uint64_t v71 = *(_DWORD *)(a1 + 172);
              *(void *)__tp = 0LL;
              *(void *)&__tp[8] = 0LL;
              clock_gettime(_CLOCK_MONOTONIC_RAW, (timespec *)__tp);
              uint64_t v72 = *(_DWORD *)__tp - *(_DWORD *)(a1 + 188);
              *(_DWORD *)__tp = 67111683;
              *(_DWORD *)&__tp[4] = v95;
              *(_WORD *)&__tp[8] = 2160;
              *(void *)&__tp[10] = 1752392040LL;
              *(_WORD *)&_BYTE __tp[18] = 1040;
              int v103 = v66;
              int v104 = 2101;
              int v105 = v17;
              int v106 = 1024;
              __int128 v107 = v67;
              unsigned __int16 v10 = v99;
              uint64_t v14 = v100;
              __int128 v108 = 1024;
              int v109 = v68;
              msghdr v110 = 1024;
              __int128 v111 = v69;
              uint64_t v13 = v97;
              uint64_t v12 = v98;
              uint64_t v112 = 1024;
              int v113 = v70;
              uint64_t v114 = 1024;
              __int128 v115 = v71;
              uint64_t v15 = (_BYTE *)&unk_100164000;
              fd_set v116 = 2082;
              __int128 v117 = v100;
              __int16 v118 = 1024;
              unsigned int v119 = v72;
              int v43 = (os_log_s *)v21;
              int v44 = "[R%u] DNSServiceRegister STOP -- SRV name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%x"
                    "), port: %u, flags: 0x%X, interface index: %d, client pid: %d (%{public}s), , duration: %{mdns:time_duration}u";
              int v45 = 80;
              goto LABEL_87;
            }
          }

          else if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v95 = *(_DWORD *)(a1 + 184);
            uint64_t v46 = v17;
LABEL_58:
            BOOL v36 = 257;
            if (v46 < v17 + 256 && v46)
            {
              while (1)
              {
                uint64_t v47 = *v46;
                if (v47 > 0x3F)
                {
LABEL_82:
                  BOOL v36 = 257;
                  goto LABEL_86;
                }

                if (!*v46) {
                  break;
                }
                v46 += v47 + 1;
LABEL_61:
                if (!v46) {
                  goto LABEL_82;
                }
              }

              BOOL v36 = (_WORD)v46 - (_WORD)v17 + 1;
            }

            goto LABEL_86;
          }
        }

        else if (v19)
        {
          if ((v20 & 1) != 0)
          {
            uint64_t v21 = mDNSLogCategory_mDNS_redacted;
            if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v33 = *(_DWORD *)(a1 + 184);
              if (*v17) {
                uint64_t v34 = &v18[*v17];
              }
              else {
                uint64_t v34 = v17;
              }
LABEL_55:
              int v41 = mDNS_DomainNameFNV1aHash(v34);
              *(void *)__tp = 0LL;
              *(void *)&__tp[8] = 0LL;
              clock_gettime(_CLOCK_MONOTONIC_RAW, (timespec *)__tp);
              uint64_t v42 = *(_DWORD *)__tp - *(_DWORD *)(a1 + 188);
              *(_DWORD *)__tp = 67109632;
              *(_DWORD *)&__tp[4] = v33;
              uint64_t v15 = (_BYTE *)&unk_100164000;
              *(_WORD *)&__tp[8] = 1024;
              *(_DWORD *)&__tp[10] = v41;
              uint64_t v14 = v100;
              *(_WORD *)&__tp[14] = 1024;
              *(_DWORD *)&__tp[16] = v42;
              int v43 = (os_log_s *)v21;
              int v44 = "[R%u] DNSServiceRegister STOP -- name hash: %x, duration: %{mdns:time_duration}u";
              int v45 = 20;
LABEL_87:
              _os_log_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_DEFAULT, v44, __tp, v45);
            }
          }

          else if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v33 = *(_DWORD *)(a1 + 184);
            if (*v17) {
              uint64_t v34 = &v18[*v17];
            }
            else {
              uint64_t v34 = v17;
            }
            goto LABEL_55;
          }
        }

        else if ((v20 & 1) != 0)
        {
          uint64_t v21 = mDNSLogCategory_mDNS_redacted;
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_67;
          }
        }

        else if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
        {
LABEL_67:
          uint64_t v48 = *(_DWORD *)(a1 + 184);
          *(void *)__tp = 0LL;
          *(void *)&__tp[8] = 0LL;
          clock_gettime(_CLOCK_MONOTONIC_RAW, (timespec *)__tp);
          uint64_t v49 = *(_DWORD *)__tp - *(_DWORD *)(a1 + 188);
          *(_DWORD *)__tp = v91;
          *(_DWORD *)&__tp[4] = v48;
          uint64_t v15 = (_BYTE *)&unk_100164000;
          *(_WORD *)&__tp[8] = 1024;
          *(_DWORD *)&__tp[10] = v49;
          int v43 = (os_log_s *)v21;
          int v44 = "[R%u] DNSServiceRegister STOP -- , duration: %{mdns:time_duration}u";
          int v45 = 14;
          goto LABEL_87;
        }

        external_stop_advertising_helper((uint64_t)v11, v23, v24, v25, v26, v27, v28, v29);
        v11[1] = 0LL;
        if (mDNS_McastLoggingEnabled) {
          LogMcastService((uint64_t)(v11 + 337), a1, 0, v73, v74, v75, v76, v77, v91);
        }
        if (mDNS_DeregisterService_drt( (unsigned int *)mDNSStorage,  (uint64_t)(v11 + 36),  0,  v73,  v74,  v75,  v76,  v77)) {
          unlink_and_free_service_instance(v11, v78, v79, v80, v81, v82, v83, v84);
        }
        uint64_t v85 = *(void *)(a1 + 8);
        if (v85)
        {
          uint64_t v86 = *(unsigned int *)(a1 + 236);
          if ((_DWORD)v86)
          {
            if (AWDLInterfaceID && AWDLInterfaceID == v86)
            {
              uint64_t v87 = 1;
            }

            else
            {
              if (WiFiAwareInterfaceID) {
                uint64_t v88 = WiFiAwareInterfaceID == v86;
              }
              else {
                uint64_t v88 = 0;
              }
              uint64_t v87 = v88;
            }
          }

          else
          {
            uint64_t v87 = (*(_DWORD *)(a1 + 232) >> 20) & 1;
          }

          bzero(__tp, 0x3F1uLL);
          service_type_from_domain_name = _mdns_get_service_type_from_domain_name(v101, __tp);
          _mdns_powerlog_bonjour_event(0x12u, v87, v14, (const char *)service_type_from_domain_name, v85);
          *(void *)(a1 + 8) = 0LL;
        }

        uint64_t v11 = *(void **)(v10 + 1624);
      }

      while (v11);
    }

    unsigned int v90 = *(void **)(v10 + 16);
    if (v90)
    {
      free(v90);
      *(void *)(v10 + 16) = 0LL;
    }

    if (*(_BYTE *)(v10 + 1612))
    {
      *(_BYTE *)(v10 + 1612) = 0;
      UpdateDeviceInfoRecord(mDNSStorage);
    }
  }

  else
  {
    LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "regservice_termination_callback context is NULL",  a4,  a5,  a6,  a7,  a8,  a9);
  }

LABEL_77:
        int v41 = &mDNSInterface_Any;
      }

            mDNS_snprintf_add(&v131, (int)v177, " (%lu)", v83, v84, v85, v86, v87, bswap32(v128));
            uint64_t v30 = &v62[v61];
            ++v52;
            uint64_t v48 = v53;
          }

          while (v126 != v52);
        }

        uint64_t v95 = mDNSLogCategory_Default;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
        {
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
            return;
          }
          uint64_t v99 = bswap32(*(unsigned __int16 *)a8);
          uint64_t v100 = a8[2];
          if ((v100 & 0x78u) >= 0x30)
          {
            uint64_t v101 = "?? ";
            if ((v100 & 0x78) == 0x30) {
              uint64_t v101 = "DSO ";
            }
          }

          else
          {
            uint64_t v101 = *(const char **)((char *)&off_10013B9B8 + (v100 & 0x78));
          }

          __int128 v111 = HIWORD(v99);
          if ((v100 & 0x80u) != 0) {
            uint64_t v112 = "Response";
          }
          else {
            uint64_t v112 = "Query";
          }
          __int128 v108 = a8[3];
          int v109 = v108 & 0xF;
          if ((v108 & 0xFu) >= 0xB)
          {
            msghdr v110 = "??";
            if ((v108 & 0xF) == 0xB) {
              msghdr v110 = "DSOTypeNI";
            }
          }

          else
          {
            msghdr v110 = off_10013B9E8[v109];
          }

          int v113 = *((unsigned __int16 *)a8 + 3);
          uint64_t v114 = " AA";
          __int128 v115 = *((unsigned __int16 *)a8 + 4);
          fd_set v116 = *((unsigned __int16 *)a8 + 5);
          if ((v100 & 4) == 0) {
            uint64_t v114 = "";
          }
          *(_DWORD *)uint64_t v134 = 67114243;
          uint64_t v135 = v111;
          if ((v100 & 2) != 0) {
            __int128 v117 = " TC";
          }
          else {
            __int128 v117 = "";
          }
          uint64_t v136 = 2082;
          uint64_t v137 = v101;
          if ((v100 & 1) != 0) {
            __int16 v118 = " RD";
          }
          else {
            __int16 v118 = "";
          }
          uint64_t v138 = 2082;
          uint64_t v139 = v112;
          uint64_t v140 = 2048;
          if ((v108 & 0x80u) != 0) {
            unsigned int v119 = " RA";
          }
          else {
            unsigned int v119 = "";
          }
          int v141 = a9 - (void)a8;
          __int16 v120 = " AD";
          uint64_t v142 = 1024;
          if ((v108 & 0x20) == 0) {
            __int16 v120 = "";
          }
          unint64_t v143 = v100;
          int v121 = " CD";
          unsigned int v144 = 1024;
          if ((v108 & 0x10) == 0) {
            int v121 = "";
          }
        }

        else
        {
          uint64_t v95 = mDNSLogCategory_Default_redacted;
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
            return;
          }
          uint64_t v96 = bswap32(*(unsigned __int16 *)a8);
          int v97 = a8[2];
          if ((v97 & 0x78u) >= 0x30)
          {
            int v98 = "?? ";
            if ((v97 & 0x78) == 0x30) {
              int v98 = "DSO ";
            }
          }

          else
          {
            int v98 = *(const char **)((char *)&off_10013B9B8 + (v97 & 0x78));
          }

          int v106 = HIWORD(v96);
          if ((v97 & 0x80u) != 0) {
            __int128 v107 = "Response";
          }
          else {
            __int128 v107 = "Query";
          }
          __int128 v108 = a8[3];
          int v109 = v108 & 0xF;
          if ((v108 & 0xFu) >= 0xB)
          {
            msghdr v110 = "??";
            if ((v108 & 0xF) == 0xB) {
              msghdr v110 = "DSOTypeNI";
            }
          }

          else
          {
            msghdr v110 = off_10013B9E8[v109];
          }

          int v113 = *((unsigned __int16 *)a8 + 3);
          uint64_t v114 = " AA";
          __int128 v115 = *((unsigned __int16 *)a8 + 4);
          fd_set v116 = *((unsigned __int16 *)a8 + 5);
          if ((v97 & 4) == 0) {
            uint64_t v114 = "";
          }
          *(_DWORD *)uint64_t v134 = 67114243;
          uint64_t v135 = v106;
          if ((v97 & 2) != 0) {
            __int128 v117 = " TC";
          }
          else {
            __int128 v117 = "";
          }
          uint64_t v136 = 2082;
          uint64_t v137 = v98;
          if ((v97 & 1) != 0) {
            __int16 v118 = " RD";
          }
          else {
            __int16 v118 = "";
          }
          uint64_t v138 = 2082;
          uint64_t v139 = v107;
          uint64_t v140 = 2048;
          if ((v108 & 0x80u) != 0) {
            unsigned int v119 = " RA";
          }
          else {
            unsigned int v119 = "";
          }
          int v141 = a9 - (void)a8;
          __int16 v120 = " AD";
          uint64_t v142 = 1024;
          if ((v108 & 0x20) == 0) {
            __int16 v120 = "";
          }
          unint64_t v143 = v97;
          int v121 = " CD";
          unsigned int v144 = 1024;
          if ((v108 & 0x10) == 0) {
            int v121 = "";
          }
        }

        unsigned int v145 = v108;
        unsigned int v146 = 2082;
        int v147 = v110;
        char v148 = 1024;
        unint64_t v149 = v109;
        int v150 = 2082;
        unsigned int v151 = v114;
        unsigned int v152 = 2082;
        unsigned int v153 = v117;
        unsigned int v154 = 2082;
        uint64_t v155 = v118;
        unsigned int v156 = 2082;
        unsigned int v157 = v119;
        int v158 = 2082;
        int v159 = v120;
        int v160 = 2082;
        int v161 = v121;
        unsigned int v162 = 2160;
        int v163 = 1752392040LL;
        unsigned int v164 = 2085;
        unsigned int v165 = v177;
        int v166 = 1024;
        unsigned int v167 = v113;
        uint64_t v168 = 1024;
        unint64_t v169 = v115;
        __int16 v170 = 1024;
        BOOL v171 = v116;
        __int16 v172 = 2160;
        uint64_t v173 = 1752392040LL;
        __int16 v174 = 2085;
        uint64_t v175 = v176;
        unsigned int v28 = "[Q%u] DNS %{public}s%{public}s (%lu) (flags %02X%02X) RCODE: %{public}s (%d)%{public}s%{public}s%{public}s"
              "%{public}s%{public}s%{public}s:%{sensitive, mask.hash}s %u/%u/%u %{sensitive, mask.hash}s";
        uint64_t v102 = v134;
        int v103 = (os_log_s *)v95;
        int v104 = OS_LOG_TYPE_DEFAULT;
        int v105 = 184;
        goto LABEL_149;
      }

      *(_DWORD *)buf = 67112451;
      uint64_t v23 = &v129;
      *(_DWORD *)&uint8_t buf[4] = __rev16(v20);
      if (a4) {
        ssize_t v24 = a4;
      }
      else {
        ssize_t v24 = &v129;
      }
      *(_WORD *)&buf[8] = 2082;
      *(void *)&buf[10] = v133;
      int v25 = bswap32(a5) >> 16;
      *(_WORD *)&buf[18] = 2082;
      if (a6) {
        uint64_t v23 = a6;
      }
    }

    else
    {
      uint64_t v21 = (os_log_s *)mDNSLogCategory_Default_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_38;
      }
      *(_DWORD *)buf = 67112451;
      uint64_t v23 = &v129;
      *(_DWORD *)&uint8_t buf[4] = __rev16(v20);
      if (a4) {
        ssize_t v24 = a4;
      }
      else {
        ssize_t v24 = &v129;
      }
      *(_WORD *)&buf[8] = 2082;
      *(void *)&buf[10] = v133;
      int v25 = bswap32(a5) >> 16;
      *(_WORD *)&buf[18] = 2082;
      if (a6) {
        uint64_t v23 = a6;
      }
    }

    *(void *)&buf[20] = a3;
    *(_WORD *)&buf[28] = 2048;
    *(void *)&buf[30] = a9 - (void)a8;
    *(_WORD *)&buf[38] = 2160;
    *(void *)&buf[40] = 1752392040LL;
    LOWORD(v179) = 1045;
    *(_DWORD *)((char *)&v179 + 2) = 20;
    WORD3(v179) = 2101;
    *((void *)&v179 + 1) = v24;
    LOWORD(v180) = 1024;
    *(_DWORD *)((char *)&v180 + 2) = v25;
    WORD3(v180) = 2160;
    *((void *)&v180 + 1) = 1752392040LL;
    LOWORD(v181) = 1045;
    *(_DWORD *)((char *)&v181 + 2) = 20;
    WORD3(v181) = 2101;
    *((void *)&v181 + 1) = v23;
    LOWORD(v182) = 1024;
    *(_DWORD *)((char *)&v182 + 2) = bswap32(a7) >> 16;
    WORD3(v182) = 2082;
    *((void *)&v182 + 1) = v19;
    LOWORD(v183) = 2048;
    *(void *)((char *)&v183 + 2) = a10;
    _os_log_impl( (void *)&_mh_execute_header,  v21,  OS_LOG_TYPE_DEFAULT,  "[Q%u] %{public}s %{public}s DNS Message %lu bytes from %{sensitive, mask.hash, mdnsresponder:ip_addr}.20P:%d to %{ sensitive, mask.hash, mdnsresponder:ip_addr}.20P:%d via %{public}s (%p)",  buf,  0x7Au);
    goto LABEL_38;
  }

  DumpMDNSPacket(a2, a8, a9, a4, a5, a6, a7, a10, v19);
  if (!a1) {
    return;
  }
  uint64_t v26 = gSensitiveLoggingEnabled;
  unsigned int v27 = mDNSLogCategory_mDNS;
  if (mDNSLogCategory_mDNS == mDNSLogCategory_State) {
    uint64_t v26 = 0;
  }
  if (a2)
  {
    if ((v26 & 1) != 0)
    {
      unsigned int v27 = mDNSLogCategory_mDNS_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_ERROR)) {
        return;
      }
      *(_DWORD *)buf = 67109120;
      *(_DWORD *)&uint8_t buf[4] = a1;
      unsigned int v28 = "Sending mDNS message failed - mStatus: %d";
    }

    else
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_ERROR)) {
        return;
      }
      *(_DWORD *)buf = 67109120;
      *(_DWORD *)&uint8_t buf[4] = a1;
      unsigned int v28 = "Sending mDNS message failed - mStatus: %d";
    }
  }

  else if ((v26 & 1) != 0)
  {
    unsigned int v27 = mDNSLogCategory_mDNS_redacted;
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_ERROR)) {
      return;
    }
    *(_DWORD *)buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = a1;
    unsigned int v28 = "Receiving mDNS message failed - mStatus: %d";
  }

  else
  {
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_ERROR)) {
      return;
    }
    *(_DWORD *)buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = a1;
    unsigned int v28 = "Receiving mDNS message failed - mStatus: %d";
  }

  uint64_t v102 = buf;
  int v103 = (os_log_s *)v27;
  int v104 = OS_LOG_TYPE_ERROR;
  int v105 = 8;
LABEL_149:
  _os_log_impl((void *)&_mh_execute_header, v103, v104, v28, v102, v105);
}

        BOOL result = 4294960554LL;
      }

      break;
    default:
      if (a7 >= a4) {
        unsigned __int16 v10 = a4;
      }
      uint64_t v23 = a6;
      uint64_t v22 = __src;
LABEL_9:
      memcpy(v23, v22, v10);
LABEL_72:
      if (a8) {
        *a8 = v10;
      }
      BOOL result = 0LL;
      if (a9) {
        *a9 = v12;
      }
      break;
  }

  return result;
}

            int v25 = *(unsigned __int16 *)(v8 + 4);
            *(_DWORD *)buf = 141558787;
            uint64_t v33 = 1752392040LL;
            uint64_t v34 = 1040;
            *(_DWORD *)int v35 = (_DWORD)v21;
            *(_WORD *)&v35[4] = 2101;
            *(void *)&v35[6] = v20;
            *(_WORD *)&v35[14] = 1024;
            *(_DWORD *)&v35[16] = v25;
            _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_FAULT,  "Invalid expiration time for the current DNSSEC validated record - name: %{sensitive, mask.hash, mdnsrespon der:domain_name}.*P, rr_type: %{mdns:rrtype}d",  buf,  0x22u);
          }

                        ref_count_obj_release(v21);
                        goto LABEL_78;
                      }

                      uint64_t v20 = dnssec_obj_rrset_create(v36, *(_DWORD *)(v18 + 136), buf);
                      if (*(_DWORD *)buf)
                      {
LABEL_76:
                        if (!v21) {
                          goto LABEL_78;
                        }
                        goto LABEL_77;
                      }
                    }

                    *(_DWORD *)buf = dnssec_obj_rrset_add_rr((uint64_t)v20, a3);
                    if (!*(_DWORD *)buf && !*(void *)(v18 + 64))
                    {
                      if (v20) {
                        ++*(_DWORD *)v20;
                      }
                      *(void *)(v18 + 64) = v20;
                    }

                    goto LABEL_76;
                  }

                  uint64_t v33 = (os_log_s *)mDNSLogCategory_DNSSEC;
                  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_DNSSEC == mDNSLogCategory_State)
                  {
                    if (os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC, OS_LOG_TYPE_FAULT)) {
                      goto LABEL_59;
                    }
                  }

                  else
                  {
                    uint64_t v33 = (os_log_s *)mDNSLogCategory_DNSSEC_redacted;
                    if (os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC_redacted, OS_LOG_TYPE_FAULT))
                    {
LABEL_59:
                      *(_DWORD *)buf = 136447234;
                      *(void *)uint64_t v46 = "validated_key->rrtype == kDNSRecordType_DNSKEY || validated_key->rrtype == kDNSRecordType_DS";
                      *(_WORD *)&v46[8] = 2082;
                      uint64_t v47 = "";
                      *(_WORD *)uint64_t v48 = 2082;
                      *(void *)&v48[2] = "/Library/Caches/com.apple.xbs/Sources/mDNSResponder/mDNSMacOSX/dnssec_v2/dnssec.c";
                      LOWORD(v49) = 1024;
                      *(_DWORD *)((char *)&v49 + 2) = 387;
                      WORD3(v49) = 2048;
                      *((void *)&v49 + 1) = 0LL;
LABEL_97:
                      _os_log_impl( (void *)&_mh_execute_header,  v33,  OS_LOG_TYPE_FAULT,  "AssertMacros: %{public}s, %{public}s file: %{public}s, line: %d, value: %ld",  buf,  0x30u);
                    }
                  }

LABEL_78:
      uint64_t v46 = *v41;
LABEL_79:
      *((void *)a3 + 10) = &v109;
      if (*((_BYTE *)a3 + 88))
      {
        uint64_t v48 = (void (*)(_DWORD *, unsigned __int8 *, unsigned __int8 *, _BYTE *, uint64_t, int *, void, uint64_t))v39[122];
        uint64_t v49 = v39 + 88;
        unint64_t v18 = v106 + 2494;
        int v97 = 0;
        v48(v49, v103, &v103[v24], v108, v38, v107, *a3, v46);
      }

      else
      {
        unint64_t v18 = v106 + 2494;
        mDNSCoreReceive((uint64_t)v106, v103, (unint64_t)&v103[v24], (int *)v108, v38, v107, *a3, v46);
      }

      int v44 = v109;
      int v45 = v105;
      if (v109) {
        return;
      }
      *((void *)a3 + 10) = 0LL;
LABEL_84:
      int v17 = v45 + 1;
      if (v44) {
        return;
      }
    }
  }

  LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "myKQSocketCallBack: socket %d is no longer readable (EOF)",  a4,  a5,  a6,  a7,  a8,  a1);
  if (*((_DWORD *)a3 + 4) == a1)
  {
    *((_BYTE *)a3 + 89) = 1;
    uint64_t v16 = a3 + 12;
LABEL_89:
    KQueueSet(a1, 2u, -1, v16);
    return;
  }

  if (*((_DWORD *)a3 + 12) == a1)
  {
    *((_BYTE *)a3 + 90) = 1;
    uint64_t v16 = a3 + 28;
    goto LABEL_89;
  }

            if ((_DWORD)appended) {
              goto LABEL_418;
            }
          }
        }

        if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
          dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
        }
        if (_GetCUSymAddr_DataBuffer_AppendF_sAddr)
        {
          appended = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v84, "}");
          a1 = v21;
          uint64_t v16 = ", ";
          if ((_DWORD)appended) {
            goto LABEL_418;
          }
          continue;
        }

        goto LABEL_424;
      }

    case '*':
    case ',':
    case '-':
    case '1':
      goto LABEL_419;
    case '+':
      if (a2 < 4) {
        goto LABEL_426;
      }
      if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
        dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
      }
      if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr) {
        goto LABEL_424;
      }
      appended = _GetCUSymAddr_DataBuffer_AppendF_sAddr( v84,  "%u %u %u",  __rev16(*a1),  *((unsigned __int8 *)a1 + 2),  *((unsigned __int8 *)a1 + 3));
      if ((_DWORD)appended) {
        goto LABEL_418;
      }
      if (a2 == 4) {
        goto LABEL_410;
      }
      if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
        dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
      }
      if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr) {
        goto LABEL_424;
      }
      appended = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v84, " %.4H", a1 + 2, a2 - 4, a2 - 4);
      if ((_DWORD)appended) {
        goto LABEL_418;
      }
      goto LABEL_410;
    case '.':
      LODWORD(v87) = 0;
      uint64_t v81 = 0LL;
      int v82 = 0LL;
      uint64_t v80 = 0;
      if (a2 < 0x13) {
        goto LABEL_426;
      }
      if (DNSRecordTypeValueToString(__rev16(*a1)))
      {
        if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
          dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
        }
        if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr) {
          goto LABEL_424;
        }
        appended = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v84, "%s");
      }

      else
      {
        if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
          dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
        }
        if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr) {
          goto LABEL_424;
        }
        appended = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v84, "TYPE%u");
      }

      if ((_DWORD)appended) {
        goto LABEL_418;
      }
      if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
        dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
      }
      if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr) {
        goto LABEL_424;
      }
      appended = _GetCUSymAddr_DataBuffer_AppendF_sAddr( v84,  " %u %u %u",  *((unsigned __int8 *)a1 + 2),  *((unsigned __int8 *)a1 + 3),  bswap32(*((_DWORD *)a1 + 1)));
      if ((_DWORD)appended) {
        goto LABEL_418;
      }
      LODWORD(v87) = 0;
      uint64_t v81 = 0LL;
      int v82 = 0LL;
      uint64_t v80 = 0;
      if (_GetCUSymAddr_SecondsToYMD_HMS_sOnce != -1) {
        dispatch_once(&_GetCUSymAddr_SecondsToYMD_HMS_sOnce, &__block_literal_global_241);
      }
      if (!_GetCUSymAddr_SecondsToYMD_HMS_sAddr) {
        goto LABEL_424;
      }
      _GetCUSymAddr_SecondsToYMD_HMS_sAddr( bswap32(*((_DWORD *)a1 + 2)) + 0xE77934880LL,  &v87,  (char *)&v82 + 4,  &v82,  (char *)&v81 + 4,  &v81,  &v80);
      if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
        dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
      }
      if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr) {
        goto LABEL_424;
      }
      appended = _GetCUSymAddr_DataBuffer_AppendF_sAddr( v84,  " %u%02u%02u%02u%02u%02u",  (_DWORD)v87,  HIDWORD(v82),  v82,  HIDWORD(v81),  v81,  v80);
      if ((_DWORD)appended) {
        goto LABEL_418;
      }
      if (_GetCUSymAddr_SecondsToYMD_HMS_sOnce != -1) {
        dispatch_once(&_GetCUSymAddr_SecondsToYMD_HMS_sOnce, &__block_literal_global_241);
      }
      if (!_GetCUSymAddr_SecondsToYMD_HMS_sAddr) {
        goto LABEL_424;
      }
      _GetCUSymAddr_SecondsToYMD_HMS_sAddr( bswap32(*((_DWORD *)a1 + 3)) + 0xE77934880LL,  &v87,  (char *)&v82 + 4,  &v82,  (char *)&v81 + 4,  &v81,  &v80);
      if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
        dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
      }
      if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr) {
        goto LABEL_424;
      }
      appended = _GetCUSymAddr_DataBuffer_AppendF_sAddr( v84,  " %u%02u%02u%02u%02u%02u",  (_DWORD)v87,  HIDWORD(v82),  v82,  HIDWORD(v81),  v81,  v80);
      if ((_DWORD)appended) {
        goto LABEL_418;
      }
      if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
        dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
      }
      if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr) {
        goto LABEL_424;
      }
      appended = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v84, " %u", __rev16(a1[8]));
      if ((_DWORD)appended) {
        goto LABEL_418;
      }
      uint64_t v86 = (unsigned __int8 *)(a1 + 9);
      appended = DomainNameToString((unsigned __int8 *)a1 + 18, v13, v88, &v86);
      if ((_DWORD)appended) {
        goto LABEL_418;
      }
      appended = _AppendDomainNameStringEx((uint64_t)v84, (uint64_t)" ", a6, (const char *)v88);
      if ((_DWORD)appended) {
        goto LABEL_418;
      }
      v90[0] = 0LL;
      if (_GetCUSymAddr_Base64EncodeCopyEx_sOnce != -1) {
        dispatch_once(&_GetCUSymAddr_Base64EncodeCopyEx_sOnce, &__block_literal_global_238);
      }
      if (!_GetCUSymAddr_Base64EncodeCopyEx_sAddr) {
        goto LABEL_424;
      }
      appended = _GetCUSymAddr_Base64EncodeCopyEx_sAddr(v86, v13 - (void)v86, 0LL, v90, 0LL);
      if ((_DWORD)appended) {
        goto LABEL_418;
      }
      if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
        dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
      }
      if (_GetCUSymAddr_DataBuffer_AppendF_sAddr) {
LABEL_376:
      }
        CUSymAddr_DataBuffer_Append_sAddr = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v84, " %s", (const char *)v90[0]);
      else {
LABEL_427:
      }
        CUSymAddr_DataBuffer_Append_sAddr = 4294960561LL;
      if (v90[0]) {
        free(v90[0]);
      }
      if (!(_DWORD)CUSymAddr_DataBuffer_Append_sAddr) {
        goto LABEL_410;
      }
      goto LABEL_419;
    case '/':
      if (a4)
      {
        appended = DNSMessageExtractDomainNameString(a4, a5, (char *)a1, v88, &v86);
        if ((_DWORD)appended) {
          goto LABEL_418;
        }
      }

      else
      {
        appended = DomainNameToString((unsigned __int8 *)a1, (unint64_t)a1 + a2, v88, &v86);
        if ((_DWORD)appended) {
          goto LABEL_418;
        }
      }

      appended = _AppendDomainNameStringEx((uint64_t)v84, 0LL, a6, (const char *)v88);
      if ((_DWORD)appended) {
        goto LABEL_418;
      }
      uint64_t v72 = v86;
LABEL_338:
      appended = _DNSRecordDataAppendTypeBitMap((uint64_t)v84, v72, v13);
      if ((_DWORD)appended) {
        goto LABEL_418;
      }
      goto LABEL_410;
    case '0':
LABEL_229:
      if (a2 < 5) {
        goto LABEL_426;
      }
      if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
        dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
      }
      if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr) {
        goto LABEL_424;
      }
      appended = _GetCUSymAddr_DataBuffer_AppendF_sAddr( v84,  "%u %u %u",  __rev16(*a1),  *((unsigned __int8 *)a1 + 2),  *((unsigned __int8 *)a1 + 3));
      if ((_DWORD)appended) {
        goto LABEL_418;
      }
      uint64_t v86 = (unsigned __int8 *)(a1 + 2);
      v90[0] = 0LL;
      if (_GetCUSymAddr_Base64EncodeCopyEx_sOnce != -1) {
        dispatch_once(&_GetCUSymAddr_Base64EncodeCopyEx_sOnce, &__block_literal_global_238);
      }
      if (!_GetCUSymAddr_Base64EncodeCopyEx_sAddr) {
        goto LABEL_424;
      }
      appended = _GetCUSymAddr_Base64EncodeCopyEx_sAddr(v86, v13 - (void)v86, 0LL, v90, 0LL);
      if ((_DWORD)appended) {
        goto LABEL_418;
      }
      if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
        dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
      }
      if (_GetCUSymAddr_DataBuffer_AppendF_sAddr) {
        goto LABEL_376;
      }
      goto LABEL_427;
    case '2':
      if (a2 < 5) {
        goto LABEL_426;
      }
      if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
        dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
      }
      if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr) {
        goto LABEL_424;
      }
      appended = _GetCUSymAddr_DataBuffer_AppendF_sAddr( v84,  "%u %u %u",  *(unsigned __int8 *)a1,  *((unsigned __int8 *)a1 + 1),  __rev16(a1[1]));
      if ((_DWORD)appended) {
        goto LABEL_418;
      }
      uint64_t v86 = (unsigned __int8 *)(a1 + 2);
      uint64_t v86 = (unsigned __int8 *)a1 + 5;
      uint64_t v52 = *((unsigned __int8 *)a1 + 4);
      if (a2 - 5 < v52) {
        goto LABEL_426;
      }
      if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
        dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
      }
      if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr) {
        goto LABEL_424;
      }
      appended = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v84, " %.4H", v86, v52, v52);
      if ((_DWORD)appended) {
        goto LABEL_418;
      }
      unsigned int v53 = &v86[v52];
      uint64_t v86 = v53;
      unsigned int v54 = v53 + 1;
      uint64_t v86 = v53 + 1;
      unsigned int v55 = *v53;
      if (!*v53) {
        goto LABEL_289;
      }
      if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
        dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
      }
      if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr) {
        goto LABEL_424;
      }
      appended = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v84, " ");
      if ((_DWORD)appended) {
        goto LABEL_418;
      }
      unsigned int v54 = v86;
LABEL_289:
      uint64_t v56 = &v54[v55];
      while (2)
      {
        uint64_t v57 = v56 - v86;
        if (v56 != v86)
        {
          v90[0] = 0LL;
          uint64_t v58 = 0LL;
          switch(v57)
          {
            case 1uLL:
              uint64_t v59 = 0LL;
              uint64_t v60 = (unint64_t)*v86++ << 32;
              goto LABEL_307;
            case 2uLL:
              uint64_t v65 = 0LL;
              uint64_t v63 = (unint64_t)v86[1] << 24;
              uint64_t v60 = v63 | ((unint64_t)*v86 << 32);
              v86 += 2;
              goto LABEL_304;
            case 3uLL:
              uint64_t v66 = v86[2];
              uint64_t v63 = ((unint64_t)v66 << 16) | ((unint64_t)v86[1] << 24);
              uint64_t v60 = v63 | ((unint64_t)*v86 << 32);
              v86 += 3;
              BYTE4(v90[0]) = DNSRecordDataToStringEx_kBase32ExtendedHex[2 * (v66 & 0xF)];
              uint64_t v65 = 5LL;
              goto LABEL_304;
            case 4uLL:
              goto LABEL_294;
            default:
              uint64_t v58 = v86[4];
LABEL_294:
              int v61 = v86[3];
              uint64_t v62 = v58 | (v61 << 8);
              uint64_t v63 = ((unint64_t)v86[1] << 24) | ((unint64_t)v86[2] << 16) | v62;
              uint64_t v60 = v63 | ((unint64_t)*v86 << 32);
              uint64_t v64 = 5LL;
              if (v57 < 5) {
                uint64_t v64 = v56 - v86;
              }
              v86 += v64;
              if (v57 == 1)
              {
                uint64_t v59 = 0LL;
              }

              else
              {
                if (v57 == 4)
                {
                  uint64_t v65 = 7LL;
                }

                else
                {
                  HIBYTE(v90[0]) = DNSRecordDataToStringEx_kBase32ExtendedHex[v58 & 0x1F];
                  uint64_t v65 = 8LL;
                }

                uint64_t v67 = DNSRecordDataToStringEx_kBase32ExtendedHex[(v61 >> 2) & 0x1F];
                BYTE6(v90[0]) = DNSRecordDataToStringEx_kBase32ExtendedHex[(v62 >> 5) & 0x1F];
                BYTE5(v90[0]) = v67;
                BYTE4(v90[0]) = DNSRecordDataToStringEx_kBase32ExtendedHex[(v63 >> 15) & 0x1F];
LABEL_304:
                BYTE3(v90[0]) = DNSRecordDataToStringEx_kBase32ExtendedHex[(v63 >> 20) & 0x1F];
                BYTE2(v90[0]) = DNSRecordDataToStringEx_kBase32ExtendedHex[(v63 >> 25) & 0x1F];
                if (v65) {
                  uint64_t v59 = v65;
                }
                else {
                  uint64_t v59 = 4LL;
                }
              }

      uint64_t v26 = *(void *)(a1 + 32);
      *(_BYTE *)(v26 + 60) = 0;
      *(_DWORD *)(v26 + 52) = 0;
      free(v5);
    }
  }

void mDNSCoreReceive( uint64_t a1, unsigned __int8 *a2, unint64_t a3, int *a4, unsigned __int16 a5, int *a6, unsigned __int16 a7, uint64_t a8)
{
  else {
    uint64_t v15 = (__int128 *)a6;
  }
  int v16 = a1 + 12704;
  if (mDNSSameAddress(a4, (_DWORD *)(a1 + 12704)))
  {
    uint64_t v22 = (_WORD *)(a1 + 14704);
    if (a5 == 27655 || (uint64_t v23 = *(unsigned __int16 **)(a1 + 14952)) != 0LL && *v23 == a7)
    {
      mDNS_Lock_((unsigned int *)a1, (uint64_t)"mDNSCoreReceive", 13757);
      if (*(_WORD *)(a1 + 14962) || !a2 || (_WORD)a3 == (_WORD)a2) {
        goto LABEL_9;
      }
      uint64_t v39 = 0LL;
      uint64_t v40 = (const char *)&a2[(unsigned __int16)(a3 - (_WORD)a2)];
      int v41 = (_WORD *)(a1 + 14962);
      uint64_t v42 = (unsigned __int16)(a3 - (_WORD)a2) - 1LL;
      while ((a2[v39] & 0xDF) != 0x57 || strncasecmp((const char *)&a2[v39], "WANIPConnection:1", 0x11uLL))
      {
        uint64_t v43 = v39 + 1;
        if (&a2[v39] != (unsigned __int8 *)-1LL)
        {
          BOOL v134 = v42 == v39++;
          if (!v134) {
            continue;
          }
        }

        int v44 = &a2[v43];
        goto LABEL_46;
      }

      int v44 = &a2[v39];
LABEL_46:
      else {
        uint64_t v60 = (const char *)v44;
      }
      if (v44 == (unsigned __int8 *)v40)
      {
        uint64_t v73 = (unsigned __int16)(a3 - (_WORD)a2) - 1LL;
        uint64_t v60 = (const char *)a2;
        do
        {
          if ((*v60 & 0xDF) == 0x57 && !strncasecmp(v60, "WANPPPConnection:1", 0x12uLL)) {
            break;
          }
          if (!++v60) {
            break;
          }
        }

        while (v73--);
      }

      if (!v60 || v60 == v40) {
        goto LABEL_9;
      }
      do
      {
        if (!++a2) {
          break;
        }
      }

      while (v42--);
      if (!a2 || a2 == (unsigned __int8 *)v40)
      {
        if (mDNS_LoggingEnabled == 1)
        {
          uint64_t v71 = (os_log_s *)mDNSLogCategory_Default;
          uint64_t v72 = "LNT_ConfigureRouterInfo: Location field not found";
          goto LABEL_84;
        }

LABEL_205:
          __int16 v130 = *(void **)(a1 + 14952);
          if (v130)
          {
            CloseSocketSet(*(void *)(a1 + 14952));
            free(v130);
            *(void *)(a1 + 14952) = 0LL;
          }

          goto LABEL_195;
        }

        if (v87 == 128)
        {
          if (mDNS_LoggingEnabled == 1)
          {
            uint64_t v112 = "failure";
            if (!*((_WORD *)a2 + 1)) {
              uint64_t v112 = "success";
            }
            LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "uDNS_ReceiveNATPMPPacket: AddressRequest %s error %d",  v30,  v31,  v32,  v33,  v34,  (int)v112);
          }

          if (v35 <= 0xB && !*((_WORD *)a2 + 1))
          {
            LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "NAT-PMP AddrResponse message too short (%d bytes)",  v30,  v31,  v32,  v33,  v34,  v75);
            goto LABEL_195;
          }

          natTraversalHandleAddressReply( a1,  *((unsigned __int16 *)a2 + 1),  *((_DWORD *)a2 + 2),  v30,  v31,  v32,  v33,  v34);
          goto LABEL_205;
        }

        uint64_t v58 = (os_log_s *)mDNSLogCategory_Default;
        int v136 = a2[1];
        uint64_t v59 = "Received NAT-PMP response with unknown opcode 0x%X";
      }

      LogMsgWithLevel(v58, OS_LOG_TYPE_DEFAULT, v59, v30, v31, v32, v33, v34, v136);
      goto LABEL_195;
    }
  }

  else
  {
    __int16 v29 = *(unsigned __int16 **)(a1 + 14952);
    if (v29 && *v29 == a7) {
      return;
    }
  }

  int v37 = a3 - (_DWORD)a2;
  if (((a3 - (unint64_t)a2) & 0xFFFFFFFC) <= 0xB)
  {
    LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "DNS Message from %#a:%d to %#a:%d length %d too short",  v17,  v18,  v19,  v20,  v21,  (int)a4);
    return;
  }

  unsigned __int8 v38 = a2[2];
  *((_WORD *)a2 + 2) = bswap32(*((unsigned __int16 *)a2 + 2)) >> 16;
  *((_WORD *)a2 + 3) = bswap32(*((unsigned __int16 *)a2 + 3)) >> 16;
  *((_WORD *)a2 + 4) = bswap32(*((unsigned __int16 *)a2 + 4)) >> 16;
  *((_WORD *)a2 + 5) = bswap32(*((unsigned __int16 *)a2 + 5)) >> 16;
  if (*a4 == 6)
  {
    int v45 = a4[1];
    int v46 = a4[2];
    int v47 = a4[3];
    int v48 = a4[4];
    if (v46 | v45 | v47 | v48 && (v46 & v45 & v47 & v48) != 0xFFFFFFFF)
    {
LABEL_36:
      int v49 = v38 & 0xF8;
      mDNS_Lock_((unsigned int *)a1, (uint64_t)"mDNSCoreReceive", 13795);
      ++*(_DWORD *)(a1 + 132);
      if (*(_WORD *)a2
        || (++*(_DWORD *)(a1 + 136), int IsLocalSubnet = mDNS_AddressIsLocalSubnet(a1, a8, a4), !v15)
        || IsLocalSubnet)
      {
        if (!v15)
        {
          uint64_t v77 = "TCP";
LABEL_128:
          uint64_t v57 = a8;
          if (*(_WORD *)a2)
          {
            if ((mDNS_PacketLoggingEnabled & 1) != 0)
            {
              else {
                unsigned int v90 = v77;
              }
              uint64_t v91 = a5;
              DumpPacket(0, 0, (uint64_t)v90, (__int128 *)a4, a5, v15, a7, a2, a3, a8);
            }

            else
            {
              uint64_t v91 = a5;
            }

            uDNS_ReceiveMsg(a1, (unsigned __int16 *)a2, a3, a4, v91, v52, v53, v57);
            uint64_t v57 = 0LL;
          }

      uint64_t v81 = (os_log_s *)mDNSLogCategory_D2D;
      if ((gSensitiveLoggingEnabled & 1) != 0)
      {
        unsigned int v82 = *(void *)v125;
        if (mDNSLogCategory_D2D != mDNSLogCategory_State)
        {
          uint64_t v81 = (os_log_s *)mDNSLogCategory_D2D_redacted;
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_D2D_redacted, OS_LOG_TYPE_ERROR))
          {
            unsigned int v83 = *(void *)(v82 + 64);
            if (v83)
            {
              int v84 = *(_BYTE **)(v82 + 64);
              if (v83 == -256)
              {
                while (1)
                {
LABEL_211:
                  if (!v84) {
                    goto LABEL_288;
                  }
                  int v85 = *v84;
                  if (!*v84) {
                    break;
                  }
                  v84 += v85 + 1;
                  if (v83 != -256) {
                    goto LABEL_210;
                  }
                }

                uint64_t v106 = (unsigned __int16)((_WORD)v84 - v83 + 1);
              }

              else
              {
LABEL_210:
LABEL_288:
                uint64_t v106 = 257;
              }
            }

            else
            {
              uint64_t v106 = 0;
            }

LABEL_136:
          if (v49 > 127)
          {
            if (v49 == 128)
            {
              mDNSCoreReceiveResponse(a1, a2, a3, (__int128 *)a4, a5, v15, a7, 0LL, 0LL, v57);
              goto LABEL_156;
            }

            if (v49 == 168)
            {
              mDNSCoreReceiveUpdateR(a1, (unint64_t)a2, a3, (uint64_t)a4, a8);
              goto LABEL_156;
            }
          }

          else
          {
            if (!v49)
            {
              mDNSCoreReceiveQuery(a1, (unint64_t)a2, a3, a4, a5, v15, a7, v57);
              goto LABEL_156;
            }

            if (v49 == 40)
            {
              mDNSCoreReceiveUpdate(a1, (unint64_t)a2, a3, (uint64_t)a4, a5, v15, a7, a8);
LABEL_156:
              mDNS_Unlock_(a1, (uint64_t)"mDNSCoreReceive", 13856);
              return;
            }
          }

          if (mDNS_LoggingEnabled == 1 && mDNSCoreReceive_msgCount <= 999)
          {
            ++mDNSCoreReceive_msgCount;
            LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "Unknown DNS packet type %02X%02X from %#-15a:%-5d to %#-15a:%-5d length %d on %p (ignored)",  v50,  v51,  v52,  v53,  v57,  a2[2]);
            if (v37 >= 1)
            {
              int v92 = 0;
              do
              {
                memset(v140, 0, sizeof(v140));
                int v98 = (char *)v140 + mDNS_snprintf(v140);
                do
                {
                  if (v92 < v37) {
                    v98 += mDNS_snprintf(v98);
                  }
                  ++v92;
                }

                while ((v92 & 0xF) != 0);
                if (mDNS_LoggingEnabled == 1) {
                  LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "%s",  v93,  v94,  v95,  v96,  v97,  (int)v140);
                }
              }

              while (v92 < v37);
            }
          }

          goto LABEL_156;
        }

        int v54 = *(_DWORD *)v15;
        goto LABEL_39;
      }

      int v54 = *(_DWORD *)v15;
      if (*(_DWORD *)v15 == 6)
      {
        if (*((_DWORD *)v15 + 1) != 767) {
          goto LABEL_126;
        }
        if (*((_DWORD *)v15 + 2) || *((_DWORD *)v15 + 3) || *((_DWORD *)v15 + 4) != -83886080) {
          goto LABEL_102;
        }
      }

      else
      {
        if (v54 != 4)
        {
LABEL_39:
          if (v54 != 6)
          {
            if (v54 != 4) {
              goto LABEL_126;
            }
            int v55 = *((_DWORD *)v15 + 1);
            int v56 = -83885856;
            goto LABEL_42;
          }

          if (*((_DWORD *)v15 + 1) != 767) {
            goto LABEL_126;
          }
LABEL_102:
          if (*((_DWORD *)v15 + 2) || *((_DWORD *)v15 + 3)) {
            goto LABEL_126;
          }
          int v55 = *((_DWORD *)v15 + 4);
          int v56 = -83886080;
LABEL_42:
          uint64_t v57 = a8;
          if (v55 == v56) {
            goto LABEL_136;
          }
LABEL_126:
          uint64_t v77 = "UDP";
          if (v49 != 168)
          {
            uint64_t v57 = a8;
            if (v49 != 128) {
              goto LABEL_136;
            }
          }

          goto LABEL_128;
        }

        if (*((_DWORD *)v15 + 1) != -83885856) {
          goto LABEL_126;
        }
      }

      ++*(_DWORD *)(a1 + 180);
      goto LABEL_39;
    }
  }

  else if (*a4 == 4 && (a4[1] + 1) >= 2)
  {
    goto LABEL_36;
  }

void mDNSCoreReceiveQuery( uint64_t a1, unint64_t a2, unint64_t a3, _DWORD *a4, uint64_t a5, __int128 *a6, uint64_t a7, uint64_t a8)
{
  unsigned __int16 v9 = a5;
  unsigned __int16 v10 = a4;
  unint64_t v11 = a2;
  if (!a4 || !a6)
  {
    if (!a6)
    {
LABEL_55:
      LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "Ignoring Query from %#-15a:%-5d to %#-15a:%-5d on 0x%p with %2d Question%s %2d Answer%s %2d Authorit%s %2d Addit ional%s %d bytes (%s)",  (uint64_t)a4,  a5,  (uint64_t)a6,  a7,  a8,  (int)v10);
      return;
    }

    uint64_t v319 = a7;
    BOOL v14 = 0;
    if (a8) {
      goto LABEL_12;
    }
    goto LABEL_10;
  }

  uint64_t v319 = a7;
  uint64_t v13 = a6;
  BOOL v14 = !mDNSAddrIsDNSMulticast(a6) && mDNS_AddressIsLocalSubnet(a1, a8, v10) != 0;
  a6 = v13;
  unint64_t v11 = a2;
  if (!a8)
  {
LABEL_10:
    uint64_t v15 = a6;
    BOOL IsDNSMulticast = mDNSAddrIsDNSMulticast(a6);
    a6 = v15;
    if (IsDNSMulticast)
    {
      LODWORD(v10) = (_DWORD)a4;
      a7 = v319;
      goto LABEL_55;
    }
  }

LABEL_46:
    unint64_t v56 = v36 + 20;
    v36 += 24LL;
  }

  while (v56 < v34);
  if (v345)
  {
    uint64_t v57 = (os_log_s *)mDNSLogCategory_mDNS;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEBUG)) {
        goto LABEL_57;
      }
    }

    else
    {
      uint64_t v57 = (os_log_s *)mDNSLogCategory_mDNS_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEBUG))
      {
LABEL_57:
        uint64_t v60 = *(void *)(v17 + 23);
        GetRRDisplayString_rdb( (unsigned __int8 *)(a1 + 37864),  (unsigned __int16 *)(*(void *)(v17 + 39) + 4LL),  (_BYTE *)(a1 + 46976));
        *(_DWORD *)buf = 67109634;
        int v374 = v35;
        uint64_t v18 = (_DWORD *)(a1 + 19868);
        __int16 v375 = 2048;
        uint64_t v376 = v60;
        __int16 v377 = 2082;
        *(void *)uint64_t v378 = a1 + 46976;
        uint64_t v17 = a1 + 37865;
        _os_log_impl( (void *)&_mh_execute_header,  v57,  OS_LOG_TYPE_DEBUG,  "ProcessQuery: Received TSR(%u) if %p %{public}s",  buf,  0x1Cu);
      }
    }
  }

        uint64_t v114 = v39;
        uint64_t v113 = v38;
        mDNS_VerifyLockState( "Check Lock",  1,  *(_DWORD *)(a1 + 48),  *(_DWORD *)(a1 + 52),  (uint64_t)"hndlRecordUpdateReply",  3501);
        if (mDNS_LoggingEnabled == 1)
        {
          uint64_t v111 = v30[170];
          GetRRDisplayString_rdb((unsigned __int8 *)(v28 + 8), (unsigned __int16 *)(*(void *)(v28 + 48) + 4LL), v29);
          LogMsgWithLevel( v111,  OS_LOG_TYPE_DEFAULT,  "hndlRecordUpdateReply: err %d ID %d state %d %s(%p)",  v50,  v51,  v52,  v53,  v54,  v114);
        }

        *(_DWORD *)(v28 + 604) = v114;
        SetRecordRetry(a1, v28, v20);
        *(_WORD *)(v28 + 358) = 0;
        uint64_t v60 = *(void *)(v28 + 376);
        if (v60)
        {
          if (*(_DWORD *)(v60 + 1044) != -1)
          {
            int v61 = v30[170];
            GetRRDisplayString_rdb((unsigned __int8 *)(v28 + 8), (unsigned __int16 *)(*(void *)(v28 + 48) + 4LL), v29);
            DNSTypeName(*(unsigned __int16 *)(*(void *)(v28 + 376) + 1154LL));
            LogMsgWithLevel( v61,  OS_LOG_TYPE_DEFAULT,  "hndlRecordUpdateReply: ResourceRecord %s, zone info question %##s (%s) interval %d not -1",  v62,  v63,  v64,  v65,  v66,  (int)v29);
            uint64_t v60 = *(void *)(v28 + 376);
          }

          uint64_t v67 = *(unsigned __int16 *)(v60 + 786);
          CancelGetZoneData(a1, (_DWORD *)v60);
          *(void *)(v28 + 376) = 0LL;
        }

        else
        {
          uint64_t v67 = 0;
        }

        uint64_t v68 = v113;
        if (*(_BYTE *)(v28 + 8) == 1 && *(_DWORD *)(v28 + 344) == 3)
        {
          if ((v113 & 1) == 0) {
            LogMsgWithLevel( v30[170],  OS_LOG_TYPE_DEFAULT,  "ERROR: Deregistration of record %##s type %d failed with error %d",  v55,  v56,  v57,  v58,  v59,  *(void *)(v28 + 40));
          }
          *(_DWORD *)(v28 + 344) = 4;
          CompleteDeregistration(a1, v28);
          goto LABEL_86;
        }

        if (*(_BYTE *)(a1 + 141))
        {
          if (*(_WORD *)(v28 + 12) == 33 && *(_DWORD *)(v28 + 344) == 3) {
            goto LABEL_84;
          }
          goto LABEL_86;
        }

        if (*(_DWORD *)(v28 + 344) == 7)
        {
          if ((v113 & 1) == 0) {
            LogMsgWithLevel( v30[170],  OS_LOG_TYPE_DEFAULT,  "Update record failed for %##s (err %d)",  v55,  v56,  v57,  v58,  v59,  *(void *)(v28 + 40));
          }
          *(_DWORD *)(v28 + 344) = 2;
          uint64_t v69 = *(void (**)(uint64_t, uint64_t, void, void))(v28 + 320);
          if (v69) {
            v69(a1, v28, *(void *)(v28 + 624), *(unsigned __int16 *)(v28 + 616));
          }
          SetNewRData(v28 + 8, *(void *)(v28 + 632), *(unsigned __int16 *)(v28 + 618), v55, v56, v57, v58, v59);
          *(_OWORD *)(v28 + 624) = 0u;
          uint64_t v68 = v113;
        }

        if (*(_BYTE *)(v28 + 592))
        {
          unsigned __int16 v70 = *(unsigned __int16 *)(v28 + 12);
          if (v70 != 33)
          {
            if (mDNS_LoggingEnabled == 1)
            {
              uint64_t v115 = v30[170];
              uint64_t v81 = v15;
              uint64_t v82 = v29;
              uint64_t v83 = *(void *)(v28 + 40);
              DNSTypeName(v70);
              uint64_t v110 = v83;
              unint64_t v29 = v82;
              uint64_t v15 = v81;
              LogMsgWithLevel( v115,  OS_LOG_TYPE_DEFAULT,  "hndlRecordUpdateReply: Deregistered %##s (%s), state %d",  v84,  v85,  v86,  v87,  v88,  v110);
            }

            *(_BYTE *)(v28 + 592) = 0;
            if (*(_DWORD *)(v28 + 344) != 3)
            {
              unint64_t v89 = v30;
              unsigned int v90 = v30[170];
              GetRRDisplayString_rdb( (unsigned __int8 *)(v28 + 8),  (unsigned __int16 *)(*(void *)(v28 + 48) + 4LL),  v29);
              uint64_t v91 = v90;
              uint64_t v30 = v89;
              LogMsgWithLevel( v91,  OS_LOG_TYPE_DEFAULT,  "hndlRecordUpdateReply: ResourceRecord %s not in DeregPending state %d",  v92,  v93,  v94,  v95,  v96,  (int)v29);
            }

          if (mDNS_LoggingEnabled == 1)
          {
            uint64_t v39 = (os_log_s *)mDNSLogCategory_D2D;
            if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_D2D == mDNSLogCategory_State)
            {
              if (os_log_type_enabled((os_log_t)mDNSLogCategory_D2D, OS_LOG_TYPE_DEBUG))
              {
                for (uint64_t i = buf; ; i += v43 + 1)
                {
                  if (i >= v74 || !i || (uint64_t v43 = *i, v43 > 0x3F))
                  {
                    int v44 = 257;
                    goto LABEL_67;
                  }

                  if (!*i) {
                    break;
                  }
                }

                int v44 = (unsigned __int16)((_WORD)i - (unsigned __int16)buf + 1);
LABEL_67:
                *(_DWORD *)int v46 = 141559299;
                int v47 = 1752392040LL;
                uint64_t v48 = 1040;
                BOOL v49 = v44;
                BOOL v50 = 2101;
                uint64_t v51 = buf;
                uint64_t v52 = 1024;
                int v53 = v23;
                int v54 = 1024;
                unsigned int v55 = a5;
                unint64_t v56 = 1024;
                uint64_t v57 = a4;
                _os_log_impl( (void *)&_mh_execute_header,  v39,  OS_LOG_TYPE_DEBUG,  "xD2DParseCompressedPacket: Our Bytes - name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P, ty pe: %{mdns:rrtype}d, TTL: %u, rdata length: %u",  v46,  0x2Eu);
              }
            }

            else
            {
              uint64_t v39 = (os_log_s *)mDNSLogCategory_D2D_redacted;
              if (os_log_type_enabled((os_log_t)mDNSLogCategory_D2D_redacted, OS_LOG_TYPE_DEBUG))
              {
                for (uint64_t j = buf; ; j += v41 + 1)
                {
                  if (j >= v74 || !j || (uint64_t v41 = *j, v41 > 0x3F))
                  {
                    int v44 = 257;
                    goto LABEL_67;
                  }

                  if (!*j) {
                    break;
                  }
                }

                int v44 = (unsigned __int16)((_WORD)j - (unsigned __int16)buf + 1);
                goto LABEL_67;
              }
            }
          }

          return 0LL;
        }
      }

      else if (LabelPairIsForService(v27))
      {
        goto LABEL_45;
      }

      unint64_t v29 = &v25[v24];
      uint64_t v30 = v29[1];
      unint64_t v27 = v29 + 1;
      uint64_t v24 = v30;
      if (!v30) {
        goto LABEL_46;
      }
    }
  }

  return v15;
}

  uint64_t v19 = dispatch_source_create( (dispatch_source_type_t)&_dispatch_source_type_data_or,  0LL,  0LL,  *(dispatch_queue_t *)(v2 + 32));
  *(void *)(v2 + 56) = v19;
  if (!v19)
  {
LABEL_82:
    _mdns_interface_monitor_terminate((void *)v2, -6729);
    goto LABEL_68;
  }

  os_retain((void *)v2);
  uint64_t v20 = *(dispatch_source_s **)(v2 + 56);
  *(void *)&buf = _NSConcreteStackBlock;
  *((void *)&buf + 1) = 0x40000000LL;
  int v47 = ___mdns_interface_monitor_activate_internal_block_invoke;
  uint64_t v48 = &__block_descriptor_tmp_22_1462;
  BOOL v49 = v2;
  dispatch_source_set_event_handler(v20, &buf);
  uint64_t v21 = *(dispatch_source_s **)(v2 + 56);
  values[0] = _NSConcreteStackBlock;
  values[1] = (void *)0x40000000;
  values[2] = ___mdns_interface_monitor_activate_internal_block_invoke_2;
  values[3] = &__block_descriptor_tmp_23_1463;
  values[4] = (void *)v2;
  dispatch_source_set_cancel_handler(v21, values);
  dispatch_activate(*(dispatch_object_t *)(v2 + 56));
  if (*(void *)(v2 + 40))
  {
    os_retain((void *)v2);
    uint64_t v22 = *(void *)(v2 + 40);
    v44[0] = _NSConcreteStackBlock;
    v44[1] = 0x40000000LL;
    v44[2] = ___mdns_interface_monitor_activate_internal_block_invoke_3;
    v44[3] = &__block_descriptor_tmp_25_1464;
    v44[4] = v2;
    nw_path_evaluator_set_update_handler(v22, _mdns_internal_queue_s_queue, v44);
    uint64_t v23 = *(void *)(v2 + 40);
    v43[0] = _NSConcreteStackBlock;
    v43[1] = 0x40000000LL;
    v43[2] = ___mdns_interface_monitor_activate_internal_block_invoke_4;
    v43[3] = &__block_descriptor_tmp_26_1465;
    v43[4] = v2;
    nw_path_evaluator_set_cancel_handler(v23, v43);
    nw_path_evaluator_start(*(void *)(v2 + 40));
    *(_BYTE *)(v2 + 157) = 1;
  }

  if (*(_DWORD *)(v2 + 136)) {
    goto LABEL_56;
  }
  uint64_t v24 = nw_path_monitor_create();
  *(void *)(v2 + 48) = v24;
  if (!v24)
  {
    if (_mdns_ifmon_log_s_once != -1) {
      dispatch_once(&_mdns_ifmon_log_s_once, &__block_literal_global_1442);
    }
    uint64_t v40 = (os_log_s *)_mdns_ifmon_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_ifmon_log_s_log, OS_LOG_TYPE_ERROR))
    {
      LOWORD(update_handler[0]) = 0;
      _os_log_error_impl( (void *)&_mh_execute_header,  v40,  OS_LOG_TYPE_ERROR,  "Failed to create path monitor",  (uint8_t *)update_handler,  2u);
    }

    goto LABEL_82;
  }

  uint64_t v25 = v24;
  nw_path_monitor_set_queue(v25, (dispatch_queue_t)_mdns_internal_queue_s_queue);
  os_retain((void *)v2);
  uint64_t v26 = *(nw_path_monitor **)(v2 + 48);
  update_handler[0] = _NSConcreteStackBlock;
  update_handler[1] = 0x40000000LL;
  update_handler[2] = ___mdns_interface_monitor_activate_internal_block_invoke_27;
  update_handler[3] = &__block_descriptor_tmp_28_1467;
  update_handler[4] = v2;
  nw_path_monitor_set_update_handler(v26, update_handler);
  unint64_t v27 = *(nw_path_monitor **)(v2 + 48);
  cancel_handler[0] = _NSConcreteStackBlock;
  cancel_handler[1] = 0x40000000LL;
  cancel_handler[2] = ___mdns_interface_monitor_activate_internal_block_invoke_2_29;
  cancel_handler[3] = &__block_descriptor_tmp_30;
  cancel_handler[4] = v2;
  nw_path_monitor_set_cancel_handler(v27, cancel_handler);
  nw_path_monitor_start(*(nw_path_monitor_t *)(v2 + 48));
  *(_BYTE *)(v2 + 157) = 1;
LABEL_56:
  uint64_t v28 = &g_monitor_list;
  do
  {
    unint64_t v29 = v28;
    uint64_t v30 = *v28;
    uint64_t v28 = (uint64_t *)(*v28 + 24);
  }

  while (v30);
  uint64_t v31 = os_retain((void *)v2);
  unsigned __int16 *v29 = v2;
  if (_mdns_start_nwi_state_monitoring_s_nwi_notify_token == -1)
  {
    notify_key = (const char *)nwi_state_get_notify_key(v31);
    uint64_t v33 = notify_register_dispatch( notify_key,  &_mdns_start_nwi_state_monitoring_s_nwi_notify_token,  (dispatch_queue_t)_mdns_internal_queue_s_queue,  &__block_literal_global_37);
    if (_mdns_start_nwi_state_monitoring_s_nwi_notify_token == -1)
    {
      unint64_t v34 = v33;
      if (_mdns_nwi_log_s_once != -1) {
        dispatch_once(&_mdns_nwi_log_s_once, &__block_literal_global_40);
      }
      unsigned __int8 v35 = (os_log_s *)_mdns_nwi_log_s_log;
      if (os_log_type_enabled((os_log_t)_mdns_nwi_log_s_log, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)BOOL v50 = 67109120;
        uint64_t v51 = v34;
        _os_log_error_impl( (void *)&_mh_execute_header,  v35,  OS_LOG_TYPE_ERROR,  "Failed to register for NWI state notifications (status %u)",  v50,  8u);
      }
    }

    else
    {
      _mdns_nwi_state_update();
    }
  }

  _mdns_interface_monitor_check_nwi_state_for_updates(v2);
LABEL_68:
  os_release(*(void **)(a1 + 32));
}

  if (a2 || !CustomPushService) {
    goto LABEL_62;
  }
  uint64_t v22 = *(unsigned __int16 *)(CustomPushService + 276);
  if ((v22 & 0x200) != 0) {
    goto LABEL_64;
  }
  if (!*(_BYTE *)(a1 + 627) || *(unsigned __int8 *)(CustomPushService + 281) - 2 <= 3)
  {
    if ((v22 & 0x800) == 0)
    {
LABEL_64:
      if ((~v22 & 0x1800) == 0)
      {
        if (*(_BYTE *)(a1 + 629)) {
          return 0LL;
        }
      }

      return CustomPushService;
    }

    goto LABEL_60;
  }

  uint64_t v23 = (os_log_s *)mDNSLogCategory_Default;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
  {
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
    {
LABEL_58:
      uint64_t v24 = *(_DWORD *)(a1 + 252);
      uint64_t v25 = bswap32(*(unsigned __int16 *)(a1 + 320)) >> 16;
      uint64_t v26 = *(uint64_t (**)(uint64_t))(CustomPushService + 24);
      LODWORD(block) = 67109632;
      HIDWORD(block) = v24;
      LOWORD(v37) = 1024;
      *(_DWORD *)((char *)&v37 + 2) = v25;
      HIWORD(v37) = 2048;
      unsigned int v38 = v26;
      _os_log_impl( (void *)&_mh_execute_header,  v23,  OS_LOG_TYPE_DEFAULT,  "[R%u->Q%u] DNS service %llu lacks required encryption",  (uint8_t *)&block,  0x18u);
    }
  }

  else
  {
    uint64_t v23 = (os_log_s *)mDNSLogCategory_Default_redacted;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_58;
    }
  }

  CustomPushService = 0LL;
LABEL_60:
  if (*(void *)a1) {
    CustomPushService = mdns_dns_service_manager_get_custom_service(v5, *(void *)a1);
  }
LABEL_62:
  if (CustomPushService)
  {
    uint64_t v22 = *(unsigned __int16 *)(CustomPushService + 276);
    goto LABEL_64;
  }

  return CustomPushService;
}

  mDNS_Unlock_((uint64_t)mDNSStorage, (uint64_t)"_Querier_HandleSubscriberInvalidation", 1742);
}

        uint64_t v24 = *(void *)(v10 + 6256);
        uint64_t v25 = 141559043;
        uint64_t v26 = 1752392040LL;
        unint64_t v27 = 1040;
        uint64_t v28 = v23;
        unint64_t v29 = 2101;
        uint64_t v30 = v18;
        uint64_t v31 = 2082;
        uint64_t v32 = v10 + 6310;
        uint64_t v33 = 1024;
        unint64_t v34 = v24;
        _os_log_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_DEBUG,  "mDNSPlatformValidRecordForInterface: Filtering privacy risk -- name: %{sensitive, mask.hash, mdnsresponder:dom ain_name}.*P, ifname: %{public}s, ifid: %d",  (uint8_t *)&v25,  0x2Cu);
        return 0LL;
      }
    }
  }

  else
  {
LABEL_6:
    if (*(void *)(a1 + 32) == a2 || !mDNSPlatformInterfaceIsD2D(a2, a2, a3, a4, a5, a6, a7, a8))
    {
      return 1LL;
    }

    else
    {
      unint64_t v11 = *(_DWORD *)(a1 + 172);
      uint64_t v12 = ((v11 - 1) & 0xFFFFFFFD) == 0;
      uint64_t v13 = (v11 & 0xFFFFFFFE) == 2;
      if (AWDLInterfaceID == a2 || WiFiAwareInterfaceID == a2) {
        return v13;
      }
      else {
        return v12;
      }
    }
  }

  return result;
}

  a4 = v53;
  if (!v30)
  {
    uint64_t v26 = dword_100158BF8;
LABEL_48:
    uint64_t v39 = (void **)calloc(1uLL, 0x18uLL);
    if (v39)
    {
      uint64_t v30 = v39;
      *((_DWORD *)v39 + 2) = a2;
      *((_DWORD *)v39 + 3) = v26;
      goto LABEL_50;
    }

LABEL_60:
  uint64_t v313 = (unsigned __int8 *)(v11 + 12);
  if (*(_WORD *)(v11 + 4))
  {
    int v62 = 0;
    int v331 = 0;
    BOOL v63 = v336 != 59668;
    if (!v318) {
      BOOL v63 = 1;
    }
    char v340 = v63;
    BOOL v334 = (_BYTE *)(a1 + 46976);
    int v324 = v318 || v14;
    uint64_t v344 = a1 + 37856;
    uint64_t v341 = (unsigned __int8 *)(a1 + 37864);
    if (IsLocalSubnet | v351) {
      BOOL v64 = 1;
    }
    else {
      BOOL v64 = !v318;
    }
    BOOL v330 = v64;
    int v65 = &v357;
    uint64_t v320 = &v356;
    uint64_t v66 = (os_log_s **)&unk_100164000;
    Questiouint64_t n = (unsigned __int8 *)(v11 + 12);
    uint64_t v67 = a4;
    while (1)
    {
      bzero(buf, 0x290uLL);
      Questiouint64_t n = getQuestion(v11, Question, v27, a8, buf);
      if (!Question) {
        goto LABEL_502;
      }
      unsigned __int16 v70 = v386;
      char v71 = v340;
      if ((v386 & 0x8000u) != 0) {
        char v71 = 1;
      }
      char v349 = v71;
      else {
        ++v18[4];
      }
      int v346 = v62;
      unsigned __int16 v386 = v70 & 0x7FFF;
      uint64_t v72 = *(void *)(a1 + 12648);
      if (v72)
      {
        uint64_t v73 = v65;
        uint64_t v74 = mDNSLogCategory_Default;
        GetRRDisplayString_rdb((unsigned __int8 *)(v72 + 8), (unsigned __int16 *)(*(void *)(v72 + 48) + 4LL), v334);
        int v75 = (os_log_s *)v74;
        int v65 = v73;
        uint64_t v66 = (os_log_s **)&unk_100164000;
        LogMsgWithLevel( v75,  OS_LOG_TYPE_DEFAULT,  "ProcessQuery ERROR m->CurrentRecord already set %s",  v76,  v77,  v78,  v79,  v80,  (int)v334);
      }

      uint64_t v81 = *(void *)(a1 + 12624);
      *(void *)(a1 + 12648) = v81;
      if (!v81)
      {
LABEL_350:
        int v331 = 1000;
        goto LABEL_351;
      }

      uint64_t v343 = 0LL;
      int v342 = 0;
      uint64_t v82 = (uint64_t)Question;
      if (v336 == 59668) {
        uint64_t v82 = -2LL;
      }
      uint64_t v329 = v82;
      do
      {
        *(void *)(a1 + 12648) = *(void *)v81;
        uint64_t v83 = *(void *)(v81 + 32);
        if (!v83) {
          goto LABEL_94;
        }
        if (v83 == -5)
        {
LABEL_82:
          LogMsgWithLevel( v66[170],  OS_LOG_TYPE_DEFAULT,  "AnyTypeRecordAnswersQuestion: ERROR!! called with LocalOnly ResourceRecord %p, Question %p",  v69,  v29,  v30,  v31,  v32,  *(void *)(v81 + 32));
          goto LABEL_83;
        }

        BOOL v84 = v382 == -2 || v382 == 0;
        if (v84 || v83 == v382)
        {
LABEL_94:
          if (v381 && (*(_WORD *)(v381 + 276) & 0x4000) != 0)
          {
            uint64_t v88 = *(void *)(v81 + 56);
            if (v88) {
              uint64_t v88 = *(void *)(v88 + 24);
            }
            if (v88 != v381) {
              goto LABEL_83;
            }
          }

          else
          {
            uint64_t v86 = *(void *)(v81 + 56);
            if (v86)
            {
              if (*(void *)(v86 + 24)) {
                BOOL v87 = 1;
              }
              else {
                BOOL v87 = v83 == 0;
              }
              if (!v87) {
                goto LABEL_110;
              }
              uint64_t v83 = *(void *)(v86 + 24);
LABEL_102:
              if (v83 != v381
                || !mDNSPlatformValidRecordForInterface(v81, v382, v68, v69, v29, v30, v31, v32))
              {
                goto LABEL_83;
              }
            }

            else
            {
              if (!v83) {
                goto LABEL_102;
              }
LABEL_110:
              if (v384) {
                goto LABEL_83;
              }
            }
          }

          if (*(unsigned __int16 *)(v81 + 14) != v386 && v386 != 255
            || *(_DWORD *)(v81 + 24) != v383
            || !SameDomainNameBytes(*(_BYTE **)(v81 + 40), v387)
            || !v324 && !*(_BYTE *)(v81 + 121))
          {
            goto LABEL_83;
          }

          unint64_t v89 = v27;
          ++v18[5];
          unsigned int v90 = (_BYTE *)(v81 + 8);
          if (!RRTypeAnswersQuestionType(v81 + 8, v385, 0LL, v69, v29, v30, v31, v32))
          {
            if ((*v90 & 0x30) != 0)
            {
              BOOL IsValidAnswer = ResourceRecordIsValidAnswer(v81);
              uint64_t v94 = v343;
              if (v343) {
                BOOL v95 = 1;
              }
              else {
                BOOL v95 = !IsValidAnswer;
              }
              if (!v95) {
                uint64_t v94 = v81;
              }
              uint64_t v343 = v94;
            }

            unint64_t v27 = v89;
            uint64_t v17 = a1 + 37865;
            goto LABEL_83;
          }

          uint64_t v323 = v65;
          uint64_t v91 = *(_BYTE **)(v81 + 40);
          int v92 = &v355;
          while (1)
          {
            int v92 = (void **)*v92;
            if (!v92) {
              break;
            }
            if (SameDomainNameBytes((_BYTE *)v92 + 20, v91))
            {
              int v325 = (int *)(v92 + 1);
              goto LABEL_131;
            }
          }

          int v325 = 0LL;
LABEL_131:
          int v96 = *v90;
          Authorities = LocateAuthorities(v11, v89);
          int v98 = Authorities;
          if (v96 == 2)
          {
            int v99 = (unsigned __int8 *)(a1 + 37864);
            if (*(_WORD *)(v11 + 8))
            {
              __darwin_time_t v321 = (unsigned __int8 *)(v81 + 8);
              int v100 = 0;
              int v101 = 0;
              unint64_t v27 = v89;
              uint64_t v17 = a1 + 37865;
              while (2)
              {
                LargeResourceRecord = GetLargeResourceRecord(a1, v11, v98, v27, v382, 160, v344);
                if (!LargeResourceRecord) {
                  goto LABEL_192;
                }
                int v98 = LargeResourceRecord;
                if (v325)
                {
                  unsigned int v103 = CheckTSRForAuthRecord( *(uint64_t **)(a1 + 12624),  v325,  *(_DWORD *)(v81 + 24),  *(_BYTE **)(v81 + 40));
                  if (v103)
                  {
                    uint64_t v67 = a4;
                    uint64_t v66 = (os_log_s **)&unk_100164000;
                    if (v103 != -1) {
                      goto LABEL_195;
                    }
                    unsigned int v162 = (os_log_s *)mDNSLogCategory_mDNS;
                    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
                    {
                      if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
                      {
                        uint64_t v163 = *(void *)(v81 + 40);
                        if (v163)
                        {
                          unsigned int v167 = *(_BYTE **)(v81 + 40);
                          if (v163 == -256)
                          {
LABEL_232:
                            while (v167)
                            {
                              uint64_t v168 = *v167;
                              if (!*v167)
                              {
                                unsigned __int16 v183 = (_WORD)v167 - v163 + 1;
                                goto LABEL_269;
                              }

                              v167 += v168 + 1;
                              if (v163 != -256) {
                                goto LABEL_231;
                              }
                            }
                          }

                          else
                          {
LABEL_231:
                          }

                          unsigned __int16 v183 = 257;
LABEL_269:
                          int v184 = v183;
                        }

                        else
                        {
                          int v184 = 0;
                        }

LABEL_270:
                        uint64_t v185 = DNSTypeName(*(unsigned __int16 *)(v81 + 12));
                        uint64_t v186 = *(void *)(v81 + 32);
                        *(_DWORD *)__dst = 141559043;
                        *(void *)&__dst[4] = 1752392040LL;
                        *(_WORD *)&__dst[12] = 1040;
                        *(_DWORD *)&__dst[14] = v184;
                        *(_WORD *)&__dst[18] = 2101;
                        *(void *)&__dst[20] = v163;
                        *(_WORD *)&__dst[28] = 2082;
                        *(void *)&__dst[30] = v185;
                        *(_WORD *)&__dst[38] = 2048;
                        *(void *)&__dst[40] = v186;
                        _os_log_impl( (void *)&_mh_execute_header,  v162,  OS_LOG_TYPE_DEFAULT,  "ResolveSimultaneousProbe - deregistering %{sensitive, mask.hash, mdnsresponder:domain_name}.*P type %{public}s on interface id: %p due to TSR conflict",  __dst,  0x30u);
                        unint64_t v11 = a2;
                      }
                    }

                    else
                    {
                      unsigned int v162 = (os_log_s *)mDNSLogCategory_mDNS_redacted;
                      if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
                      {
                        uint64_t v163 = *(void *)(v81 + 40);
                        if (v163)
                        {
                          unsigned int v164 = *(_BYTE **)(v81 + 40);
                          if (v163 == -256)
                          {
LABEL_220:
                            while (v164)
                            {
                              uint64_t v165 = *v164;
                              if (!*v164)
                              {
                                unsigned __int16 v182 = (_WORD)v164 - v163 + 1;
                                goto LABEL_267;
                              }

                              v164 += v165 + 1;
                              if (v163 != -256) {
                                goto LABEL_219;
                              }
                            }
                          }

                          else
                          {
LABEL_219:
                          }

                          unsigned __int16 v182 = 257;
LABEL_267:
                          int v184 = v182;
                        }

                        else
                        {
                          int v184 = 0;
                        }

                        goto LABEL_270;
                      }
                    }

                    mDNS_Deregister_internal(a1, v81, 4);
                    int v99 = (unsigned __int8 *)(a1 + 37864);
                    goto LABEL_195;
                  }
                }

                if (!PacketRRConflict(a1, v81, v344))
                {
                  int v100 = 1;
                  goto LABEL_167;
                }

                int v104 = *(unsigned __int16 *)(v81 + 14);
                int v105 = *(unsigned __int16 *)(v17 + 5);
                int v106 = v104 - v105;
                if (v104 == v105)
                {
                  int v106 = *(unsigned __int16 *)(v81 + 12) - *(unsigned __int16 *)(v17 + 3);
                  if (!v106) {
                    goto LABEL_146;
                  }
                }

                else
                {
                  if (v106) {
                    goto LABEL_142;
                  }
LABEL_146:
                  memset(__dst, 0, sizeof(__dst));
                  __int128 v362 = 0u;
                  __int128 v363 = 0u;
                  __int128 v364 = 0u;
                  __int128 v365 = 0u;
                  __int128 v366 = 0u;
                  __int128 v367 = 0u;
                  __int128 v368 = 0u;
                  __int128 v369 = 0u;
                  __int128 v370 = 0u;
                  __int128 v371 = 0u;
                  __int128 v372 = 0u;
                  memset(v360, 0, sizeof(v360));
                  uint64_t v121 = __dst;
                  uint64_t v122 = putRData(0LL, (char *)__dst, (unint64_t)buf, (uint64_t)v321, v29, v30, v31, v32);
                  uint64_t v123 = (uint64_t)v99;
                  int v124 = v122;
                  unsigned int v125 = (unsigned __int8 *)v360;
                  __int16 v130 = putRData(0LL, (char *)v360, (unint64_t)__dst, v123, v126, v127, v128, v129);
                  int v131 = v360 < (_OWORD *)v130;
                  BOOL v132 = __dst < (uint8_t *)v124;
                  if (__dst < (uint8_t *)v124 && v360 < (_OWORD *)v130)
                  {
                    uint64_t v121 = __dst;
                    unsigned int v125 = (unsigned __int8 *)v360;
                    while (1)
                    {
                      unsigned int v133 = *v121;
                      unsigned int v134 = *v125;
                      if (v133 != v134) {
                        break;
                      }
                      ++v121;
                      int v131 = ++v125 < (unsigned __int8 *)v130;
                      BOOL v132 = v121 < (uint8_t *)v124;
                    }

                    int v99 = (unsigned __int8 *)(a1 + 37864);
LABEL_159:
                    if (v134 <= v133)
                    {
                      if (v134 < v133)
                      {
                        int v106 = 1;
                        goto LABEL_165;
                      }

                      LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "CompareRData ERROR: Invalid state",  v69,  v29,  v30,  v31,  v32,  v312);
                    }

                    int v106 = -1;
                    goto LABEL_165;
                  }

LABEL_142:
                uint64_t v107 = (os_log_s *)mDNSLogCategory_Default;
                uint64_t v108 = v17;
                int v109 = v382;
                GetRRDisplayString_rdb(v99, (unsigned __int16 *)(*(void *)(v108 + 39) + 4LL), v334);
                LogMsgWithLevel( v107,  OS_LOG_TYPE_DEFAULT,  "ResolveSimultaneousProbe: %p Pkt Record:        %08lX %s",  v110,  v111,  v112,  v113,  v114,  v109);
                uint64_t v315 = (os_log_s *)mDNSLogCategory_Default;
                uint64_t v115 = *(void *)(v81 + 32);
                GetRRDisplayString_rdb(v321, (unsigned __int16 *)(*(void *)(v81 + 48) + 4LL), v334);
                LogMsgWithLevel( v315,  OS_LOG_TYPE_DEFAULT,  "ResolveSimultaneousProbe: %p Our Record %d %s %08lX %s",  v116,  v117,  v118,  v119,  v120,  v115);
                if (v106 < 0)
                {
                  unsigned int v166 = *(_DWORD *)(a1 + 64) + 1000;
                  if (v166 <= 1) {
                    unsigned int v166 = 1;
                  }
                  *(_DWORD *)(a1 + 12680) = v166;
                  *(_WORD *)(v81 + 190) = 1027;
                  InitializeLastAPTime((_DWORD *)a1, v81);
                  unint64_t v11 = a2;
                  uint64_t v67 = a4;
                  unint64_t v27 = a3;
                  uint64_t v17 = a1 + 37865;
                  int v99 = (unsigned __int8 *)(a1 + 37864);
                  uint64_t v66 = (os_log_s **)&unk_100164000;
                  goto LABEL_195;
                }

                int v100 = 1;
                unint64_t v11 = a2;
                unint64_t v27 = a3;
                uint64_t v17 = a1 + 37865;
                int v99 = (unsigned __int8 *)(a1 + 37864);
LABEL_167:
                unsigned __int8 *v99 = 0;
                *(_WORD *)(v17 + 101) = 0;
                *(_BYTE *)uint64_t v17 = 0;
                uint64_t v135 = *(void **)(v17 + 55);
                if (v135)
                {
                  ref_count_obj_release(v135);
                  *(void *)(v17 + 55) = 0LL;
                }

                continue;
              }
            }

            int v100 = 0;
            unint64_t v27 = v89;
            uint64_t v17 = a1 + 37865;
LABEL_192:
            uint64_t v67 = a4;
            uint64_t v66 = (os_log_s **)&unk_100164000;
            if (!v100 && mDNS_LoggingEnabled)
            {
              uint64_t v143 = mDNSLogCategory_Default;
              uint64_t v144 = *(void *)(v81 + 40);
              DNSTypeName(*(unsigned __int16 *)(v81 + 12));
              unsigned int v145 = (os_log_s *)v143;
              int v99 = (unsigned __int8 *)(a1 + 37864);
              LogMsgWithLevel( v145,  OS_LOG_TYPE_DEFAULT,  "ResolveSimultaneousProbe: %##s (%s): No Update Record found",  v146,  v147,  v148,  v149,  v150,  v144);
            }

LABEL_195:
            unsigned __int8 *v99 = 0;
            *(_WORD *)(v17 + 101) = 0;
            *(_BYTE *)uint64_t v17 = 0;
            unsigned int v151 = *(void **)(v17 + 55);
            if (v151)
            {
              ref_count_obj_release(v151);
              *(void *)(v17 + 55) = 0LL;
            }

        uint64_t v91 = v64;
      }

      else
      {
        uint64_t v91 = 0;
      }
    }

    else
    {
      int v45 = mDNSLogCategory_mDNS_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_141;
      }
      int v46 = v12[46];
      int v47 = *(_DWORD *)(v11 + 56);
      uint64_t v48 = *(void *)(a2 + 40);
      if (v48)
      {
        BOOL v49 = *(_BYTE **)(a2 + 40);
        if (v48 == -256) {
          goto LABEL_56;
        }
LABEL_53:
        BOOL v50 = 257;
        if ((unint64_t)v49 < v48 + 256 && v49)
        {
          while (1)
          {
            uint64_t v51 = *v49;
            if (v51 > 0x3F)
            {
LABEL_190:
              BOOL v50 = 257;
              goto LABEL_193;
            }

            if (!*v49) {
              break;
            }
            v49 += v51 + 1;
            if (v48 != -256) {
              goto LABEL_53;
            }
LABEL_56:
            if (!v49) {
              goto LABEL_190;
            }
          }

          BOOL v50 = (_WORD)v49 - v48 + 1;
        }

LABEL_344:
              int v214 = DNSTypeName(*(unsigned __int16 *)(v81 + 12));
              uint64_t v215 = *(void *)(v81 + 32);
              *(_DWORD *)__dst = 141559043;
              *(void *)&__dst[4] = 1752392040LL;
              *(_WORD *)&__dst[12] = 1040;
              *(_DWORD *)&__dst[14] = v213;
              *(_WORD *)&__dst[18] = 2101;
              *(void *)&__dst[20] = v206;
              *(_WORD *)&__dst[28] = 2082;
              *(void *)&__dst[30] = v214;
              *(_WORD *)&__dst[38] = 2048;
              *(void *)&__dst[40] = v215;
              _os_log_impl( (void *)&_mh_execute_header,  v205,  OS_LOG_TYPE_DEFAULT,  "ProcessQuery - deregistering %{sensitive, mask.hash, mdnsresponder:domain_name}.*P type %{public}s on in terface id: %p due to TSR conflict",  __dst,  0x30u);
              unint64_t v11 = a2;
            }
          }

          else
          {
            uint64_t v205 = (os_log_s *)mDNSLogCategory_mDNS_redacted;
            if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v206 = *(void *)(v81 + 40);
              if (v206)
              {
                int v207 = *(_BYTE **)(v81 + 40);
                if (v206 == -256) {
                  goto LABEL_320;
                }
LABEL_317:
                unsigned __int16 v208 = 257;
                if ((unint64_t)v207 < v206 + 256 && v207)
                {
                  while (1)
                  {
                    uint64_t v209 = *v207;
                    if (v209 > 0x3F)
                    {
LABEL_338:
                      unsigned __int16 v208 = 257;
                      goto LABEL_341;
                    }

                    if (!*v207) {
                      break;
                    }
                    v207 += v209 + 1;
                    if (v206 != -256) {
                      goto LABEL_317;
                    }
LABEL_320:
                    if (!v207) {
                      goto LABEL_338;
                    }
                  }

                  unsigned __int16 v208 = (_WORD)v207 - v206 + 1;
                }

LABEL_351:
      if ((*(_BYTE *)(v11 + 2) & 2) != 0) {
        ++v18[1];
      }
      if ((v349 & 1) == 0 && (*(_BYTE *)(v11 + 2) & 2) == 0)
      {
        if (!IsD2D)
        {
          int v219 = CacheGroupForName(a1, v383, v387);
          if (v219)
          {
            for (uint64_t i = v219[2]; i; uint64_t i = *(void *)i)
            {
              if (SameNameRecordAnswersQuestion((unsigned __int8 *)(i + 8), 0, (uint64_t)buf, v220, v29, v30, v31, v32)
                && *(unsigned __int16 *)(i + 20) <= 0x400u
                && !*(void *)(i + 72)
                && v65 != (uint64_t *)(i + 72))
              {
                *int v65 = i;
                int v65 = (uint64_t *)(i + 72);
              }
            }
          }
        }

        unsigned int v216 = v65;
        uint64_t v217 = *(void *)(a1 + 200);
        if (v217)
        {
          uint64_t v18 = (_DWORD *)(a1 + 19868);
          do
          {
            if (*(int *)(v217 + 212) >= 1
              && !*(void *)(v217 + 40)
              && *(_DWORD *)(a1 + 64) - *(_DWORD *)(v217 + 256) >= 251)
            {
              uint64_t v218 = *(void *)(v217 + 136);
              if (!v218 || v218 == a8)
              {
                if (!*(void *)(v217 + 48)
                  && v320 != (uint64_t *)(v217 + 48)
                  && *(unsigned __int16 *)(v217 + 322) == v385
                  && *(unsigned __int16 *)(v217 + 324) == v386
                  && *(_DWORD *)(v217 + 200) == v383
                  && SameDomainNameBytes((_BYTE *)(v217 + 356), v387))
                {
                  *uint64_t v320 = v217;
                  uint64_t v320 = (uint64_t *)(v217 + 48);
                }

                uint64_t v18 = (_DWORD *)(a1 + 19868);
              }
            }

            uint64_t v217 = *(void *)(v217 + 8);
          }

          while (v217);
        }

        else
        {
          uint64_t v18 = (_DWORD *)(a1 + 19868);
        }

        int v65 = v216;
        uint64_t v66 = (os_log_s **)&unk_100164000;
      }

      int v62 = v346 + 1;
      if (v346 + 1 >= *(unsigned __int16 *)(v11 + 4))
      {
        uint64_t v222 = v358;
        int v223 = v331;
        goto LABEL_387;
      }
    }
  }

  int v223 = 0;
  uint64_t v222 = (uint64_t *)&v359;
  Questiouint64_t n = (unsigned __int8 *)(v11 + 12);
  uint64_t v67 = a4;
LABEL_387:
  for (uint64_t j = *(void **)(a1 + 12624); j; uint64_t j = (void *)*j)
  {
    if (j[33])
    {
      if (!j[32] && v222 != j + 32)
      {
        *uint64_t v222 = (uint64_t)j;
        j[34] = 0LL;
        uint64_t v222 = j + 32;
      }
    }
  }

  unsigned int v332 = v223;
  int v358 = v222;
  AddAdditionalsToResponseList(a1, (uint64_t)v359, &v358, a8, v29, v30, v31, v32);
  if (*(_WORD *)(v11 + 6))
  {
    int v230 = 0;
    unsigned int v231 = (_BYTE *)(a1 + 37864);
    while (1)
    {
      Questiouint64_t n = GetLargeResourceRecord(a1, v11, Question, v27, a8, 192, a1 + 37856);
      if (!Question) {
        break;
      }
      if (*v231 != 240)
      {
        for (uint64_t k = v359; k; uint64_t k = (void *)k[32])
        {
          if ((k[33] || k[34]) && ShouldSuppressKnownAnswer(a1 + 37856, (uint64_t)k))
          {
            ++*v347;
            k[33] = 0LL;
            k[34] = 0LL;
          }
        }

        for (uint64_t m = *(void *)(a1 + 12624); m; uint64_t m = *(void *)m)
        {
          if (*(void *)(m + 208) == a8 && ShouldSuppressKnownAnswer(a1 + 37856, m))
          {
            if (*v67 == 6)
            {
              if (*(_DWORD *)(m + 236) == v67[1]
                && *(_DWORD *)(m + 240) == v67[2]
                && *(_DWORD *)(m + 244) == v67[3]
                && *(_DWORD *)(m + 248) == v67[4])
              {
                *(void *)(m + 236) = 0LL;
                *(void *)(m + 244) = 0LL;
              }
            }

            else if (*v67 == 4 && *(_DWORD *)(m + 232) == v67[1])
            {
              *(_DWORD *)(m + 232) = 0;
            }

            if (!*(_DWORD *)(m + 232)
              && !*(void *)&vorr_s8( *(int8x8_t *)(m + 236),  (int8x8_t)*(_OWORD *)&vextq_s8(*(int8x16_t *)(m + 236), *(int8x16_t *)(m + 236), 8uLL)))
            {
              ++*v347;
              *(void *)(m + 208) = 0LL;
              *(_BYTE *)(m + 195) = 0;
            }
          }
        }

        uint64_t IdenticalRecordInCache = FindIdenticalRecordInCache(a1, (uint64_t)v231);
        if (!IsD2D)
        {
          uint64_t v236 = v357;
          if (v357)
          {
            int v237 = &v357;
            do
            {
              if (*(void *)(v236 + 32) == a8
                && *(_DWORD *)(a1 + 37880) == *(_DWORD *)(v236 + 24)
                && resource_records_have_same_dnssec_rr_category( *(void *)(a1 + 37920),  *(void *)(v236 + 64))
                && *(unsigned __int16 *)(a1 + 37868) == *(unsigned __int16 *)(v236 + 12)
                && *(unsigned __int16 *)(a1 + 37870) == *(unsigned __int16 *)(v236 + 14)
                && *(unsigned __int16 *)(a1 + 37876) == *(unsigned __int16 *)(v236 + 20)
                && *(_DWORD *)(a1 + 37884) == *(_DWORD *)(v236 + 28)
                && SameRDataBody( (uint64_t)v231,  (unsigned __int16 *)(*(void *)(v236 + 48) + 4LL),  (uint64_t (*)(uint64_t, unsigned __int16 *))SameDomainName)
                && SameDomainNameBytes(*(_BYTE **)(a1 + 37896), *(_BYTE **)(v236 + 40)))
              {
                *int v237 = *(void *)(v236 + 72);
                *(void *)(v236 + 72) = 0LL;
              }

              else
              {
                int v237 = (uint64_t *)(v236 + 72);
              }

              uint64_t v236 = *v237;
            }

            while (*v237);
          }
        }

        uint64_t v67 = a4;
        if (!IdenticalRecordInCache)
        {
          uint64_t v238 = v356;
          if (v356)
          {
            uint64_t v239 = &v356;
            do
            {
              BOOL v240 = RecordAnswersQuestion((uint64_t)v231, 0, v238, v226, v227, v234, v228, v229);
              uint64_t v241 = (uint64_t *)(v238 + 48);
              if (v240)
              {
                uint64_t *v239 = *v241;
                uint64_t *v241 = 0LL;
              }

              else
              {
                uint64_t v239 = (uint64_t *)(v238 + 48);
              }

              uint64_t v238 = *v239;
            }

            while (*v239);
          }
        }
      }

      *unsigned int v231 = 0;
      uint64_t v17 = a1 + 37865;
      *(_WORD *)(a1 + 37966) = 0;
      *uint64_t v354 = 0;
      uint64_t v242 = *(void **)(a1 + 37920);
      if (v242)
      {
        ref_count_obj_release(v242);
        *(void *)(a1 + 379memset(v45, 0, 20) = 0LL;
      }
    }

LABEL_502:
    int v353 = 0;
    unint64_t v265 = 0LL;
    goto LABEL_566;
  }

  unsigned int v271 = *(void *)(v109 + 12648);
  if (v271)
  {
    uint64_t v272 = (os_log_s *)mDNSLogCategory_Default;
    GetRRDisplayString_rdb( (unsigned __int8 *)(v271 + 8),  (unsigned __int16 *)(*(void *)(v271 + 48) + 4LL),  (_BYTE *)(v109 + 46976));
    LogMsgWithLevel( v272,  OS_LOG_TYPE_DEFAULT,  "SendResponses ERROR m->CurrentRecord already set %s",  v273,  v274,  v275,  v276,  v277,  v109 + 46976);
  }

  v278 = *(void *)(v109 + 12624);
  *(void *)(v109 + 12648) = v278;
  if (v278)
  {
    uint64_t v279 = v109;
    while (2)
    {
      *(void *)(v279 + 12648) = *(void *)v278;
      unint64_t v280 = *(void *)(v278 + 224);
      if (!v280) {
        goto LABEL_518;
      }
      if ((*(_DWORD *)(v278 + 172) & 0xFFFFFFFE) != 4)
      {
        unsigned int v281 = (os_log_s *)mDNSLogCategory_Default;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
        {
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_INFO)) {
            goto LABEL_516;
          }
        }

        else
        {
          unsigned int v281 = (os_log_s *)mDNSLogCategory_Default_redacted;
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_INFO))
          {
LABEL_516:
            unsigned int v284 = *(unsigned __int8 *)(v278 + 8);
            unint64_t v285 = *(void *)(v278 + 32);
            GetRRDisplayString_rdb( (unsigned __int8 *)(v278 + 8),  (unsigned __int16 *)(*(void *)(v278 + 48) + 4LL),  (_BYTE *)(v109 + 46976));
            *(_DWORD *)uint64_t v322 = 67110147;
            *(_DWORD *)&v322[4] = v280;
            *(_WORD *)&v322[8] = 1024;
            *(_DWORD *)&v322[10] = v285;
            *(_WORD *)&v322[14] = 1024;
            uint64_t v323 = v284;
            strcpy(v324, "p\bhash");
            v324[7] = 0;
            *(_WORD *)&v324[8] = 0;
            int v325 = 2085;
            uint64_t v326 = v109 + 46976;
            _os_log_impl( (void *)&_mh_execute_header,  v281,  OS_LOG_TYPE_INFO,  "SendResponses: No active interface %d to send: %d %02X %{sensitive, mask.hash}s",  v322,  0x28u);
          }
        }
      }

      *(void *)(v278 + 224) = 0LL;
LABEL_518:
      if (*(void *)(v278 + 208) || *(_BYTE *)(v278 + 8) == 1)
      {
        if (*(void *)(v278 + 304)) {
          CompleteRDataUpdate(a1, v278, a3, (uint64_t)a4, a5, a6, a7, a8);
        }
        if (*(_BYTE *)(v278 + 8) == 1 && !*(_BYTE *)(v278 + 191))
        {
          if (*(void *)(v278 + 32) || *(_BYTE *)(v278 + 122) || IsLocalDomain(*(_BYTE **)(v278 + 40))) {
            CompleteDeregistration(a1, v278);
          }
        }

        else
        {
          *(void *)(v278 + 208) = 0LL;
          *(_BYTE *)(v278 + 195) = 0;
          *(void *)(v278 + 232) = 0LL;
          *(void *)(v278 + 240) = 0LL;
          *(_DWORD *)(v278 + 248) = 0;
        }
      }

      uint64_t v279 = a1;
      v278 = *(void *)(a1 + 12648);
      if (!v278) {
        return;
      }
      continue;
    }
  }

LABEL_447:
  uint64_t v243 = (uint64_t)v359;
  if (v359)
  {
    BOOL v244 = v359;
    uint64_t v226 = a1 + 19868;
    uint64_t v227 = v318;
    uint64_t v245 = v332;
    do
    {
      uint64_t v246 = v244[34];
      if (v246 && !*(void *)(v246 + 264) && !*(void *)(v246 + 272))
      {
        v244[33] = 0LL;
        v244[34] = 0LL;
      }

      BOOL v244 = (void *)v244[32];
    }

    while (v244);
    int v247 = 0;
    int v248 = 0;
    uint64_t v249 = v67 + 1;
    while (1)
    {
      uint64_t v250 = *(void *)(v243 + 264);
      if (!v250)
      {
        uint64_t v255 = *(void *)(v243 + 272);
        if (v255 && *(void *)(v255 + 264) == -1LL) {
          *(void *)(v243 + 216) = a8;
        }
        goto LABEL_498;
      }

      int v251 = *(_DWORD *)(a1 + 64);
      int v253 = v318 && v251 - *(_DWORD *)(v243 + 288) >= (1000 * *(_DWORD *)(v243 + 16)) >> 2;
      if (v250 == -2 && v253 != 0)
      {
        ++*(_DWORD *)(a1 + 19900);
        uint64_t v250 = -1LL;
        *(void *)(v243 + 264) = -1LL;
      }

      if (v250 == -2)
      {
        ++*(_DWORD *)(a1 + 19892);
        *(_DWORD *)(a1 + 100) = v251;
        unint64_t v256 = (uint64_t *)(v243 + 208);
        uint64_t v257 = *(void *)(v243 + 208);
        if (v257 && v257 != a8) {
          goto LABEL_491;
        }
        *(void *)(v243 + 208) = a8;
        *(_BYTE *)(v243 + 195) = 1;
      }

      else
      {
        if (v250 == -1)
        {
          ++*(_DWORD *)(a1 + 19896);
        }

        else
        {
          int v248 = 1;
          if (!v253) {
            goto LABEL_493;
          }
        }

        *(_DWORD *)(a1 + 100) = v251;
        unint64_t v256 = (uint64_t *)(v243 + 208);
        uint64_t v258 = *(void *)(v243 + 208);
        if (v258 && v258 != a8) {
          goto LABEL_491;
        }
        *unint64_t v256 = a8;
      }

      if (*v67 != 6)
      {
        if (*v67 == 4)
        {
          int v259 = *(_DWORD *)(v243 + 232);
          int v260 = *v249;
          if (v259)
          {
            if (v259 != v260) {
              *(_DWORD *)(v243 + 232) = -1;
            }
          }

          else
          {
            *(_DWORD *)(v243 + 232) = v260;
          }
        }

        goto LABEL_492;
      }

      int v261 = *(_DWORD *)(v243 + 236);
      int v262 = *(_DWORD *)(v243 + 240);
      unint64_t v256 = (uint64_t *)(v243 + 236);
      int v264 = *(_DWORD *)(v243 + 244);
      int v263 = *(_DWORD *)(v243 + 248);
      if (!(v262 | v261 | v264 | v263))
      {
        *(_OWORD *)unint64_t v256 = *(_OWORD *)v249;
        goto LABEL_492;
      }

      if (v261 == *v249 && v262 == v67[2] && v264 == v67[3] && v263 == v67[4]) {
        goto LABEL_492;
      }
      *(void *)(v243 + 244) = -1LL;
LABEL_491:
      *unint64_t v256 = -1LL;
LABEL_492:
      int v247 = 1;
LABEL_493:
      if ((*(_BYTE *)(v11 + 2) & 2) != 0)
      {
        uint64_t v245 = 20000LL;
      }

      else if (*(_BYTE *)(v243 + 8) == 8)
      {
        uint64_t v245 = 1000LL;
      }

      else
      {
        uint64_t v245 = v245;
      }

LABEL_498:
      uint64_t v243 = *(void *)(v243 + 256);
      if (!v243) {
        goto LABEL_504;
      }
    }
  }

  int v247 = 0;
  int v248 = 0;
  uint64_t v245 = v332;
LABEL_504:
  int v353 = v247;
  unsigned int v266 = v313;
  if ((_DWORD)v245 && !*(_DWORD *)(a1 + 76))
  {
    int v267 = *(_DWORD *)(a1 + 84);
    int v268 = *(_DWORD *)(a1 + 64);
    if (v267)
    {
      int v269 = v245 + 49;
    }

    else
    {
      int v269 = v245 + 49;
    }

    do
      uint32_t v270 = arc4random() & 0x1FFF;
    while (v270 > 0x1388);
    unsigned int v271 = (v270 + v269) / 0x32 + v268;
    if (v271 <= 1) {
      unsigned int v271 = 1;
    }
    *(_DWORD *)(a1 + 84) = v271;
  }

LABEL_514:
  if (!v248)
  {
    unint64_t v265 = 0LL;
    unint64_t v11 = a2;
    goto LABEL_566;
  }

  uint64_t v272 = (uint64_t)v359;
  uint64_t v273 = a1 + 28916;
  if (a8) {
    unsigned int v274 = 4500;
  }
  else {
    unsigned int v274 = 3600;
  }
  unint64_t v11 = a2;
  *int v339 = *(_WORD *)a2;
  *(_WORD *)(a1 + 28906) = 132;
  *(void *)(a1 + 28908) = 0LL;
  if (v336 == 59668)
  {
    unint64_t v265 = a1 + 28916;
  }

  else
  {
    if (!*(_WORD *)(a2 + 4)) {
      goto LABEL_563;
    }
    unsigned int v275 = 0;
    unint64_t v265 = a1 + 28916;
    do
    {
      bzero(buf, 0x290uLL);
      uint64_t v276 = getQuestion(a2, v266, a3, a8, buf);
      if (!v276) {
        goto LABEL_564;
      }
      unsigned int v266 = v276;
      if (v272)
      {
        uint64_t v277 = v272;
        while (*(unsigned __int8 **)(v277 + 264) != v276)
        {
          uint64_t v277 = *(void *)(v277 + 256);
          if (!v277) {
            goto LABEL_528;
          }
        }

        unint64_t v265 = (unint64_t)putQuestion((unint64_t)v339, v265, a1 + 37856, v387, v385, v386, v228, v229);
        if (!v265) {
          goto LABEL_564;
        }
      }

LABEL_528:
      ++v275;
    }

    while (v275 < *(unsigned __int16 *)(a2 + 4));
    if (!*(_WORD *)(a1 + 28908))
    {
LABEL_563:
      LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "GenerateUnicastResponse: ERROR! Why no questions?",  v226,  v227,  v245,  v228,  v229,  v312);
LABEL_564:
      unint64_t v265 = 0LL;
      goto LABEL_565;
    }

    unsigned int v274 = 10;
  }

  if (!v272) {
    goto LABEL_565;
  }
  v278 = (_WORD *)(a1 + 28910);
  uint64_t v350 = (_WORD *)(a1 + 28914);
  uint64_t v279 = v272;
  while (2)
  {
    unint64_t v280 = v265;
    if (*(void *)(v279 + 264))
    {
      unsigned int v281 = *(_DWORD *)(v279 + 16);
      if (v274 >= v281) {
        unint64_t v282 = v281;
      }
      else {
        unint64_t v282 = v274;
      }
      if (*v278 || *(_WORD *)(a1 + 28912) || *v350) {
        uint64_t v283 = 1440LL;
      }
      else {
        uint64_t v283 = 8940LL;
      }
      unint64_t v265 = PutResourceRecordTTLWithLimit((unint64_t)v339, v265, v278, v279 + 8, v282, v273 + v283, v228, v229);
      if (!v265)
      {
        *(_BYTE *)(a1 + 28906) |= 2u;
        goto LABEL_545;
      }
    }

    else
    {
LABEL_545:
      unint64_t v265 = v280;
    }

    uint64_t v279 = *(void *)(v279 + 256);
    if (v279) {
      continue;
    }
    break;
  }

  do
  {
    if (*(void *)(v272 + 272) && !*(void *)(v272 + 264))
    {
      unsigned int v284 = *(_DWORD *)(v272 + 16);
      unint64_t v285 = v274 >= v284 ? v284 : v274;
      uint64_t v286 = *v278 || *(_WORD *)(a1 + 28912) || *v350 ? 1440LL : 8940LL;
      unint64_t v287 = PutResourceRecordTTLWithLimit((unint64_t)v339, v265, v350, v272 + 8, v285, v273 + v286, v228, v229);
      if (v287) {
        unint64_t v265 = v287;
      }
    }

    uint64_t v272 = *(void *)(v272 + 256);
  }

  while (v272);
LABEL_565:
  uint64_t v17 = a1 + 37865;
LABEL_566:
  *(_BYTE *)(a1 + 37864) = 0;
  *(_WORD *)(v17 + 101) = 0;
  *(_BYTE *)uint64_t v17 = 0;
  uint64_t v288 = *(void **)(v17 + 55);
  if (v288)
  {
    ref_count_obj_release(v288);
    *(void *)(v17 + 55) = 0LL;
  }

  int v289 = v359;
  if (v359)
  {
    do
    {
      uint64_t v290 = (void *)v289[32];
      v289[33] = 0LL;
      v289[34] = 0LL;
      v289[32] = 0LL;
      int v289 = v290;
    }

    while (v290);
    int v359 = 0LL;
  }

  uint64_t v291 = v357;
  if (v357) {
    BOOL v292 = IsD2D == 0;
  }
  else {
    BOOL v292 = 0;
  }
  if (v292)
  {
    do
    {
      uint64_t v357 = *(void *)(v291 + 72);
      *(void *)(v291 + 72) = 0LL;
      if ((*(_BYTE *)(v11 + 2) & 2) == 0)
      {
        int v293 = *(_DWORD *)(a1 + 64);
        if (!*(_BYTE *)(v291 + 108) || v293 - *(_DWORD *)(v291 + 104) >= 750)
        {
          ++*(_BYTE *)(v291 + 108);
          *(_DWORD *)(v291 + 104) = v293;
          SetNextCacheCheckTimeForRecord(a1, v291);
        }
      }

      unsigned int v294 = *(unsigned __int8 *)(v291 + 108);
      if (v294 < 4) {
        goto LABEL_592;
      }
      if (*(_BYTE *)(v291 + 109))
      {
        if (dword_100158BF8 - *(_DWORD *)(a1 + 64) + 939524096 < 7667 || mDNS_LoggingEnabled == 0) {
          goto LABEL_591;
        }
      }

      else if (*(_DWORD *)(v291 + 80) + 1000 * *(_DWORD *)(v291 + 16) - *(_DWORD *)(a1 + 64) < 7667 {
             || (mDNS_LoggingEnabled & 1) == 0)
      }
      {
        goto LABEL_591;
      }

      int v296 = (os_log_s *)mDNSLogCategory_Default;
      GetRRDisplayString_rdb( (unsigned __int8 *)(v291 + 8),  (unsigned __int16 *)(*(void *)(v291 + 48) + 4LL),  (_BYTE *)(a1 + 46976));
      unint64_t v11 = a2;
      LogMsgWithLevel( v296,  OS_LOG_TYPE_DEFAULT,  "ProcessQuery: UnansweredQueries %lu interface %lu TTL %lu mDNS_Reconfirm() for %s",  v297,  v298,  v299,  v300,  v301,  v294);
LABEL_591:
      ++*(_DWORD *)(a1 + 19876);
      mDNS_Reconfirm_internal(a1, v291, 0x1388u);
LABEL_592:
      uint64_t v291 = v357;
    }

    while (v357);
  }

  for (uint64_t n = v356; v356; uint64_t n = v356)
  {
    uint64_t v303 = *(char **)(n + 56);
    uint64_t v356 = *(void *)(n + 48);
    *(void *)(n + 48) = 0LL;
    int v304 = *(_DWORD *)(a1 + 64);
    int v305 = *a4;
    if (v303)
    {
      uint64_t v306 = 0LL;
      uint64_t v307 = v303;
      while (*(void *)v307 != a8 || *((_DWORD *)v307 + 3) != v305)
      {
        ++v306;
        v307 += 16;
        if (v306 == 8) {
          goto LABEL_602;
        }
      }

      int v309 = &v303[16 * v306];
    }

    else
    {
      uint64_t v303 = (char *)calloc(1uLL, 0x80uLL);
      if (!v303) {
        __break(1u);
      }
      *(void *)(n + 56) = v303;
LABEL_602:
      uint64_t v308 = 0LL;
      int v309 = v303;
      while (*(void *)&v303[v308])
      {
        if (*(_DWORD *)&v303[v308 + 8] - *((_DWORD *)v309 + 2) < 0) {
          int v309 = &v303[v308];
        }
        v308 += 16LL;
        if (v308 == 128) {
          goto LABEL_610;
        }
      }

      int v309 = &v303[v308];
    }

LABEL_610:
    *(void *)int v309 = a8;
    *((_DWORD *)v309 + 2) = v304;
    *((_DWORD *)v309 + 3) = v305;
  }

  int v310 = v355;
  if (v355)
  {
    do
    {
      uint64_t v311 = (void *)*v310;
      free(v310);
      int v310 = v311;
    }

    while (v311);
  }

  if (v353) {
    DumpPacket(0, 0, (uint64_t)"N/A", (__int128 *)a4, v336, v314, (unsigned __int16)v319, (unsigned __int8 *)a2, a3, a8);
  }
  if (v265) {
    mDNSSendDNSMessage(a1, (unint64_t)v339, v265, a8, 0LL, 0LL, a4, v336, 0LL, 0);
  }
}

              int v358 = *(unsigned __int16 *)(a3 + 4);
              LODWORD(__tp.tv_sec) = 67111427;
              HIDWORD(__tp.tv_sec) = v143;
              LOWORD(__tp.tv_nsec) = 1024;
              *(_DWORD *)((char *)&__tp.tv_nsec + 2) = a4;
              HIWORD(__tp.tv_nsec) = 1024;
              *(_DWORD *)uint64_t v376 = 0;
              *(_WORD *)&v376[4] = 1024;
              *(_DWORD *)&v376[6] = v146;
              strcpy((char *)&v377, "p\bhash");
              HIBYTE(v377) = 0;
              *(_WORD *)uint64_t v378 = 0;
              *(_WORD *)&v378[2] = 1040;
              *(_DWORD *)&v378[4] = v258;
              *(_WORD *)&v378[8] = 2101;
              *(void *)&_BYTE v378[10] = v9;
              *(_WORD *)&v378[18] = 1024;
              *(_DWORD *)&v378[20] = v145;
              *(_WORD *)&v378[24] = 1026;
              *(_DWORD *)&v378[26] = v17;
              *(_WORD *)&v378[30] = 1024;
              *(_DWORD *)&v378[32] = v358;
              int v161 = "[R%u->mDNS] DNSServiceResolve result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %"
                     "d, name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%x), dnssec: %{public, mdns:dnssec_"
                     "result}d, type: %{mdns:rrtype}d, rdata: <none>";
              unsigned int v162 = v142;
              uint64_t v163 = 70;
              goto LABEL_611;
            }

            uint64_t v26 = 0LL;
            int v54 = (char *)&unk_100164138;
            LODWORD(a2) = 512;
          }

          __int128 v371 = 0;
          __int128 v370 = 0;
          uint64_t RDataBytesPointer = ResourceRecordGetRDataBytesPointer(a3, v54, a2, &v370, &v371, v18, v19, v20);
          if (v371) {
            goto LABEL_470;
          }
          unsigned __int16 v10 = (void *)RDataBytesPointer;
          uint64_t v94 = v370;
          uint64_t v360 = a4;
          if (v370 >= 0x1FFuLL)
          {
            __int128 v364 = v370 + 2LL;
            uint64_t v41 = (unsigned __int8 *)malloc(v364);
            if (!v41) {
              goto LABEL_612;
            }
            BOOL v95 = (__int16 *)v41;
            char v71 = v41;
          }

          else
          {
            char v71 = 0LL;
            __int128 v364 = 512LL;
            BOOL v95 = word_100164338;
          }

          if (v11) {
            unint64_t v169 = (os_log_s *)mDNSLogCategory_Default;
          }
          else {
            unint64_t v169 = (os_log_s *)mDNSLogCategory_mDNS;
          }
          if (gSensitiveLoggingEnabled != 1 || v169 == (os_log_s *)mDNSLogCategory_State)
          {
            if (!os_log_type_enabled(v169, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_467;
            }
            uint64_t v170 = *(_DWORD *)(v369 + 184);
            uint64_t v173 = v9;
            __int128 v363 = (size_t)v71;
            if (v368 == -612LL)
            {
LABEL_368:
              while (v173)
              {
                uint64_t v174 = *v173;
                if (!*v173)
                {
                  int v214 = v95;
                  unsigned int v216 = (_WORD)v173 - (_WORD)v9 + 1;
                  goto LABEL_462;
                }

                v173 += v174 + 1;
                if (v368 != -612LL) {
                  goto LABEL_367;
                }
              }
            }

            else
            {
LABEL_367:
            }

            int v214 = v95;
            unsigned int v216 = 257;
LABEL_462:
            int v267 = v216;
            int v268 = *(unsigned __int16 *)(a3 + 4);
            int v269 = v94 + 2;
            if ((int)v94 + 2 <= v364)
            {
              *int v214 = __rev16(v268);
              uint64_t v273 = v94;
              unsigned int v274 = v10;
              unsigned int v275 = v170;
              LODWORD(v10) = v216;
              memcpy(v214 + 1, v274, v273);
              int v267 = (int)v10;
              uint64_t v170 = v275;
            }

            else
            {
              int v214 = 0LL;
            }
          }

          else
          {
            if (v11) {
              unint64_t v169 = (os_log_s *)mDNSLogCategory_Default_redacted;
            }
            else {
              unint64_t v169 = (os_log_s *)mDNSLogCategory_mDNS;
            }
            if (!os_log_type_enabled(v169, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_467;
            }
            uint64_t v170 = *(_DWORD *)(v369 + 184);
            uint64_t v171 = v9;
            __int128 v363 = (size_t)v71;
            if (v368 == -612LL)
            {
LABEL_357:
              while (v171)
              {
                uint64_t v172 = *v171;
                if (!*v171)
                {
                  int v214 = v95;
                  uint64_t v215 = (_WORD)v171 - (_WORD)v9 + 1;
                  goto LABEL_458;
                }

                v171 += v172 + 1;
                if (v368 != -612LL) {
                  goto LABEL_356;
                }
              }
            }

            else
            {
LABEL_356:
            }

            int v214 = v95;
            uint64_t v215 = 257;
LABEL_458:
            int v267 = v215;
            int v268 = *(unsigned __int16 *)(a3 + 4);
            int v269 = v94 + 2;
            if ((int)v94 + 2 <= v364)
            {
              *int v214 = __rev16(v268);
              uint32_t v270 = v10;
              unsigned int v271 = v94;
              uint64_t v272 = v170;
              LODWORD(v10) = v215;
              memcpy(v214 + 1, v270, v271);
              int v267 = (int)v10;
              uint64_t v170 = v272;
            }

            else
            {
              int v214 = 0LL;
            }
          }

          LODWORD(__tp.tv_sec) = 67112195;
          HIDWORD(__tp.tv_sec) = v170;
          LOWORD(__tp.tv_nsec) = 1024;
          *(_DWORD *)((char *)&__tp.tv_nsec + 2) = v360;
          HIWORD(__tp.tv_nsec) = 1024;
          *(_DWORD *)uint64_t v376 = 0;
          *(_WORD *)&v376[4] = 1024;
          *(_DWORD *)&v376[6] = v366;
          strcpy((char *)&v377, "p\bhash");
          HIBYTE(v377) = 0;
          *(_WORD *)uint64_t v378 = 0;
          *(_WORD *)&v378[2] = 1040;
          *(_DWORD *)&v378[4] = v267;
          *(_WORD *)&v378[8] = 2101;
          *(void *)&_BYTE v378[10] = v9;
          *(_WORD *)&v378[18] = 1024;
          *(_DWORD *)&v378[20] = HIDWORD(v366);
          *(_WORD *)&v378[24] = 1026;
          *(_DWORD *)&v378[26] = v17;
          *(_WORD *)&v378[30] = 1024;
          *(_DWORD *)&v378[32] = v268;
          *(_WORD *)&v378[36] = 2160;
          *(void *)&v378[38] = 1752392040LL;
          *(_WORD *)&v378[46] = 1040;
          *(_DWORD *)&v378[48] = v269;
          *(_WORD *)&v378[52] = 2101;
          *(void *)&v378[54] = v214;
          uint64_t v243 = "[R%u->mDNS] DNSServiceResolve result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %d, n"
                 "ame: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%x), dnssec: %{public, mdns:dnssec_result}d"
                 ", type: %{mdns:rrtype}d, rdata: %{sensitive, mask.hash, mdns:rdata}.*P";
          BOOL v244 = v169;
          int v251 = 96;
          goto LABEL_466;
        }

        if (a2 >= 0x201)
        {
          uint64_t v41 = (unsigned __int8 *)malloc(*(unsigned __int16 *)(a3 + 12));
          uint64_t v26 = v41;
          uint64_t v32 = (char *)v41;
          if (!v41) {
            goto LABEL_612;
          }
        }

        else
        {
          if (!*(_WORD *)(a3 + 12))
          {
            if (v11) {
              int v104 = (os_log_s *)mDNSLogCategory_Default;
            }
            else {
              int v104 = (os_log_s *)mDNSLogCategory_mDNS;
            }
            if (gSensitiveLoggingEnabled != 1 || v104 == (os_log_s *)mDNSLogCategory_State)
            {
              if (!os_log_type_enabled(v104, OS_LOG_TYPE_DEFAULT)) {
                goto LABEL_472;
              }
              int v105 = *(_DWORD *)(v369 + 184);
              int v106 = __rev16(v30);
              unsigned int v164 = v9;
              int v109 = v366;
              uint64_t v108 = HIDWORD(v366);
              if (v368 == -612LL)
              {
LABEL_326:
                while (v164)
                {
                  uint64_t v165 = *v164;
                  if (!*v164)
                  {
                    int v213 = (_WORD)v164 - (_WORD)v9 + 1;
                    goto LABEL_456;
                  }

                  v164 += v165 + 1;
                  if (v368 != -612LL) {
                    goto LABEL_325;
                  }
                }
              }

              else
              {
LABEL_325:
              }

              int v213 = 257;
            }

            else
            {
              if (v11) {
                int v104 = (os_log_s *)mDNSLogCategory_Default_redacted;
              }
              else {
                int v104 = (os_log_s *)mDNSLogCategory_mDNS;
              }
              if (!os_log_type_enabled(v104, OS_LOG_TYPE_DEFAULT)) {
                goto LABEL_472;
              }
              int v105 = *(_DWORD *)(v369 + 184);
              int v106 = __rev16(v30);
              uint64_t v107 = v9;
              int v109 = v366;
              uint64_t v108 = HIDWORD(v366);
              if (v368 == -612LL)
              {
LABEL_152:
                while (v107)
                {
                  uint64_t v110 = *v107;
                  if (!*v107)
                  {
                    int v213 = (_WORD)v107 - (_WORD)v9 + 1;
                    goto LABEL_456;
                  }

                  v107 += v110 + 1;
                  if (v368 != -612LL) {
                    goto LABEL_151;
                  }
                }
              }

              else
              {
LABEL_151:
              }

              int v213 = 257;
            }

_BYTE *LocateOptRR(unint64_t a1, unint64_t a2, int a3)
{
  Additionals = LocateAdditionals(a1, a2);
  if (Additionals)
  {
    int v7 = *(unsigned __int16 *)(a1 + 10) + 1;
    while (--v7)
    {
      if ((unint64_t)&Additionals[a3 + 11] > a2
        || *Additionals
        || Additionals[1]
        || Additionals[2] != 41
        || (unsigned __int16)a3 > bswap32(*(unsigned __int16 *)(Additionals + 9)) >> 16)
      {
        Additionals = skipResourceRecord(a1, Additionals, a2);
        if (Additionals) {
          continue;
        }
      }

      return Additionals;
    }

    return 0LL;
  }

  return Additionals;
}

_BYTE *LocateAdditionals(unint64_t a1, unint64_t a2)
{
  Authorities = LocateAuthorities(a1, a2);
  int v5 = *(unsigned __int16 *)(a1 + 8);
  if (*(_WORD *)(a1 + 8))
  {
    do
    {
      Authorities = skipResourceRecord(a1, Authorities, a2);
      --v5;
    }

    while (v5);
  }

  return Authorities;
}

_BYTE *LocateAuthorities(unint64_t a1, unint64_t a2)
{
  Answers = LocateAnswers(a1, a2);
  int v5 = Answers;
  unsigned int v6 = *(unsigned __int16 *)(a1 + 6);
  if (*(_WORD *)(a1 + 6)) {
    BOOL v7 = Answers == 0LL;
  }
  else {
    BOOL v7 = 1;
  }
  if (!v7)
  {
    unsigned int v8 = 1;
    do
    {
      unsigned __int16 v9 = skipResourceRecord(a1, v5, a2);
      int v5 = v9;
      if (v8 >= v6) {
        break;
      }
      ++v8;
    }

    while (v9);
  }

  return v5;
}

_BYTE *LocateAnswers(unint64_t a1, unint64_t a2)
{
  uint64_t v3 = (_BYTE *)(a1 + 12);
  unsigned int v4 = *(unsigned __int16 *)(a1 + 4);
  if (!*(_WORD *)(a1 + 4)) {
    return (_BYTE *)(a1 + 12);
  }
  unsigned int v6 = 1;
  do
  {
    BOOL v7 = skipDomainName(a1, v3, a2);
    uint64_t v3 = v7 + 4;
    else {
      BOOL result = v7 + 4;
    }
    if (v6 >= v4) {
      break;
    }
    ++v6;
  }

  while (result);
  return result;
}

_BYTE *skipResourceRecord(unint64_t a1, _BYTE *a2, unint64_t a3)
{
  BOOL result = skipDomainName(a1, a2, a3);
  if (result)
  {
    if ((unint64_t)(result + 10) <= a3)
    {
      uint64_t v5 = __rev16(*((unsigned __int16 *)result + 4));
      else {
        return 0LL;
      }
    }

    else
    {
      return 0LL;
    }
  }

  return result;
}

unsigned __int8 *getQuestion( unint64_t a1, unsigned __int8 *a2, unint64_t a3, uint64_t a4, void *a5)
{
  *((void *)a5 + 17) = a4;
  if (!a4) {
    *((_WORD *)a5 + 160) = -1;
  }
  DomainName = getDomainName(a1, a2, a3, (_BYTE *)a5 + 356);
  if (!DomainName) {
    return 0LL;
  }
  unint64_t v11 = DomainName;
  uint64_t v12 = DomainName + 4;
  *((_DWORD *)a5 + 50) = DomainNameHashValue((unint64_t)a5 + 356);
  *((_WORD *)a5 + 161) = bswap32(*(unsigned __int16 *)v11) >> 16;
  *((_WORD *)a5 + 162) = bswap32(*((unsigned __int16 *)v11 + 1)) >> 16;
  return v12;
}

unsigned __int8 *getDomainName(unint64_t a1, unsigned __int8 *a2, unint64_t a3, _BYTE *a4)
{
  uint64_t v4 = 0LL;
  if ((unint64_t)a2 >= a1 && (unint64_t)a2 < a3)
  {
    *a4 = 0;
    uint64_t v5 = a2 + 1;
    unsigned int v6 = *a2;
    if (*a2)
    {
      BOOL v7 = 0LL;
      unint64_t v8 = (unint64_t)(a4 + 256);
      while (1)
      {
        if (v6 >> 6)
        {
          unint64_t v9 = *v5 | ((unint64_t)(v6 & 0x3F) << 8);
          uint64_t v5 = (unsigned __int8 *)(a1 + v9);
          if (!v7) {
            BOOL v7 = a2 + 2;
          }
          unsigned int v6 = *v5;
          if (v6 >= 0x40) {
            return 0LL;
          }
        }

        else
        {
          uint64_t v4 = 0LL;
          *a4++ = v6;
          do
          {
            char v11 = *v5++;
            *a4++ = v11;
            --v6;
          }

          while (v6);
          *a4 = 0;
          unsigned int v6 = *v5;
        }

        a2 = v5++;
        if (!v6) {
          goto LABEL_25;
        }
      }
    }

    BOOL v7 = 0LL;
LABEL_25:
    if (v7) {
      return v7;
    }
    else {
      return v5;
    }
  }

  return (unsigned __int8 *)v4;
}

unsigned __int8 *GetLargeResourceRecord( uint64_t a1, unint64_t a2, unsigned __int8 *a3, unint64_t a4, uint64_t a5, char a6, uint64_t a7)
{
  if (a5) {
    unsigned int v13 = 4500;
  }
  else {
    unsigned int v13 = 3600;
  }
  if (a1 + 37856 == a7)
  {
    uint64_t v18 = (unsigned __int8 *)(a1 + 37864);
    if (*(_BYTE *)(a1 + 37864))
    {
      GetRRDisplayString_rdb(v18, (unsigned __int16 *)(*(void *)(a1 + 37904) + 4LL), (_BYTE *)(a1 + 46976));
      LogFatalError( "GetLargeResourceRecord: m->rec appears to be already in use for %s",  v19,  v20,  v21,  v22,  v23,  v24,  v25,  a1 + 46976);
    }

    *(void *)a7 = 0LL;
    BOOL v14 = (_BYTE *)(a7 + 8348);
    uint64_t v15 = (_BYTE *)(a7 + 8);
    *(void *)(a7 + 40) = a7 + 8348;
    int v16 = (void *)(a7 + 40);
    *(void *)(a7 + 72) = 0LL;
  }

  else
  {
    *(void *)a7 = 0LL;
    BOOL v14 = (_BYTE *)(a7 + 8348);
    uint64_t v15 = (_BYTE *)(a7 + 8);
    *(void *)(a7 + 40) = a7 + 8348;
    int v16 = (void *)(a7 + 40);
    *(void *)(a7 + 72) = 0LL;
    if (!a1)
    {
      int v17 = 0;
      goto LABEL_11;
    }
  }

  int v17 = *(_DWORD *)(a1 + 64);
LABEL_11:
  *(_DWORD *)(a7 + 80) = v17;
  *(_DWORD *)(a7 + 84) = 0;
  *(_DWORD *)(a7 + 88) = v17;
  *(void *)(a7 + 96) = 0LL;
  *(_BYTE *)(a7 + 108) = 0;
  *(_DWORD *)(a7 + 104) = 0;
  *(void *)(a7 + 112) = 0LL;
  *(void *)(a7 + 32) = a5;
  uint64_t v26 = *(void **)(a7 + 56);
  if (v26)
  {
    os_release(v26);
    *(void *)(a7 + 56) = 0LL;
  }

  DomainName = getDomainName(a2, a3, a4, v14);
  if (DomainName)
  {
    uint64_t v28 = (unsigned __int16 *)DomainName;
    *(_DWORD *)(a7 + 24) = DomainNameHashValue(*(void *)(a7 + 40));
    unint64_t v34 = (unsigned __int8 *)(v28 + 5);
    if ((unint64_t)(v28 + 5) <= a4)
    {
      unsigned int v35 = bswap32(*v28);
      int v36 = HIWORD(v35);
      *(_WORD *)(a7 + 12) = HIWORD(v35);
      int v37 = *((unsigned __int8 *)v28 + 3) | ((v28[1] & 0x7F) << 8);
      *(_WORD *)(a7 + 14) = *((unsigned __int8 *)v28 + 3) | ((v28[1] & 0x7F) << 8);
      unsigned int v38 = bswap32(*((_DWORD *)v28 + 1));
      if (v38 != -1 && v38 > v13) {
        unsigned int v38 = v13;
      }
      *(_DWORD *)(a7 + 16) = v38;
      BOOL v40 = *((char *)v28 + 2) <= -1 || a5 == 0;
      uint64_t v41 = __rev16(v28[4]);
      char v42 = v40 ? a6 | 0x10 : a6;
      uint64_t v43 = &v34[v41];
      if ((unint64_t)&v34[v41] <= a4)
      {
        *(_WORD *)(a7 + 152) = 0x2000;
        *(void *)(a7 + 48) = a7 + 152;
        if (v41 > 0x2000)
        {
          if (mDNS_LoggingEnabled == 1)
          {
            int v45 = (os_log_s *)mDNSLogCategory_Default;
            int v46 = DNSTypeName(v36);
            LogMsgWithLevel( v45,  OS_LOG_TYPE_DEFAULT,  "GetLargeResourceRecord: %s rdata size (%d) exceeds storage (%d)",  v47,  v48,  v49,  v50,  v51,  v46);
          }

          goto LABEL_33;
        }

        if (!(_DWORD)v41 && v37 == 255)
        {
          *(_WORD *)(a7 + memset(v45, 0, 20) = 0;
LABEL_38:
          SetNewRData((uint64_t)v15, 0LL, 0LL, v29, v30, v31, v32, v33);
          *uint64_t v15 = v42;
          return v43;
        }

        uint64_t v52 = (os_log_s *)mDNSLogCategory_Default;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
        {
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_ERROR))
          {
            int v53 = (_BYTE *)*v16;
            if (*v16)
            {
              uint64_t v57 = (_BYTE *)*v16;
              int v55 = 257;
              if (v53 == (_BYTE *)-256LL) {
                goto LABEL_58;
              }
LABEL_55:
              if (v57 < v53 + 256 && v57)
              {
                while (1)
                {
                  uint64_t v58 = *v57;
                  if (v58 > 0x3F)
                  {
LABEL_66:
                    int v55 = 257;
                    goto LABEL_70;
                  }

                  if (!*v57) {
                    break;
                  }
                  v57 += v58 + 1;
                  if (v53 != (_BYTE *)-256LL) {
                    goto LABEL_55;
                  }
LABEL_58:
                  if (!v57) {
                    goto LABEL_66;
                  }
                }

                int v55 = (unsigned __int16)((_WORD)v57 - (_WORD)v53 + 1);
              }
            }

            else
            {
              int v55 = 0;
            }

            goto LABEL_70;
          }
        }

        else
        {
          uint64_t v52 = (os_log_s *)mDNSLogCategory_Default_redacted;
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_ERROR))
          {
            int v53 = (_BYTE *)*v16;
            if (*v16)
            {
              int v54 = (_BYTE *)*v16;
              int v55 = 257;
              if (v53 == (_BYTE *)-256LL) {
                goto LABEL_47;
              }
LABEL_44:
              if (v54 < v53 + 256 && v54)
              {
                while (1)
                {
                  uint64_t v56 = *v54;
                  if (v56 > 0x3F)
                  {
LABEL_65:
                    int v55 = 257;
                    goto LABEL_70;
                  }

                  if (!*v54) {
                    break;
                  }
                  v54 += v56 + 1;
                  if (v53 != (_BYTE *)-256LL) {
                    goto LABEL_44;
                  }
LABEL_47:
                  if (!v54) {
                    goto LABEL_65;
                  }
                }

                int v55 = (unsigned __int16)((_WORD)v54 - (_WORD)v53 + 1);
              }
            }

            else
            {
              int v55 = 0;
            }

LABEL_70:
            uint64_t v59 = DNSTypeName(*(unsigned __int16 *)(a7 + 12));
            *(_DWORD *)buf = 141558787;
            uint64_t v62 = 1752392040LL;
            __int16 v63 = 1040;
            int v64 = v55;
            __int16 v65 = 2101;
            uint64_t v66 = v53;
            __int16 v67 = 2082;
            uint64_t v68 = v59;
            _os_log_impl( (void *)&_mh_execute_header,  v52,  OS_LOG_TYPE_ERROR,  "GetLargeResourceRecord: SetRData failed for %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%{public}s)",  buf,  0x26u);
          }
        }

              int v45 = *v43;
              if (v45 <= 0x3F)
              {
                if (!*v43)
                {
                  int v44 = (_WORD)v43 - v34 + 1;
                  goto LABEL_99;
                }

                v43 += v45 + 1;
                if (v34 != -256) {
                  continue;
                }
                goto LABEL_69;
              }

              break;
            }
          }

          int v44 = 257;
          goto LABEL_99;
        }

        uint64_t v47 = 0;
LABEL_100:
        uint64_t v51 = *(void *)(v24 + 96);
        if (v51) {
          LODWORD(v51) = bswap32(*(unsigned __int16 *)(v51 + 320)) >> 16;
        }
LABEL_102:
        uint64_t v52 = bswap32(*(unsigned __int16 *)(a1 + 320));
        int v53 = *(unsigned __int16 *)(v24 + 12);
        int v54 = *(_DWORD *)(a1 + 228);
        *(_DWORD *)buf = 67110659;
        uint64_t v56 = HIWORD(v52);
        uint64_t v57 = 2160;
        uint64_t v58 = 1752392040LL;
        uint64_t v59 = 1040;
        uint64_t v60 = v47;
        int v61 = 2101;
        uint64_t v62 = v34;
        __int16 v63 = 1024;
        int v64 = v53;
        __int16 v65 = 1024;
        uint64_t v66 = v51;
        __int16 v67 = 1024;
        uint64_t v68 = v54;
        _os_log_impl( (void *)&_mh_execute_header,  v32,  OS_LOG_TYPE_DEFAULT,  "[Q%u] CacheRecordRmvEventsForCurrentQuestion: Suppressing RMV events for question - rr name: %{sensitive, mask .hash, mdnsresponder:domain_name}.*P, rr type: %{mdns:rrtype}d, current active question: Q%u, current answers: %u",  buf,  0x34u);
        goto LABEL_103;
      }

      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
      {
        unint64_t v34 = *(void *)(v24 + 40);
        if (!v34)
        {
          uint64_t v47 = 0;
          goto LABEL_95;
        }

        unsigned int v35 = *(_BYTE **)(v24 + 40);
        if (v34 == -256) {
          goto LABEL_47;
        }
        while (2)
        {
          int v36 = 257;
          if ((unint64_t)v35 >= v34 + 256 || !v35)
          {
LABEL_94:
            uint64_t v47 = v36;
LABEL_95:
            uint64_t v51 = *(void *)(v24 + 96);
            if (v51) {
              LODWORD(v51) = bswap32(*(unsigned __int16 *)(v51 + 320)) >> 16;
            }
            goto LABEL_102;
          }

        uint64_t v68 = (void *)v34;
        if (_mdns_server_log_s_once != -1) {
          dispatch_once(&_mdns_server_log_s_once, &__block_literal_global_16);
        }
        uint64_t v58 = (os_log_s *)_mdns_server_log_s_log;
        if (!os_log_type_enabled((os_log_t)_mdns_server_log_s_log, OS_LOG_TYPE_DEFAULT)) {
          break;
        }
        uint64_t v59 = *(unsigned __int16 *)(v4 + 100);
        uint64_t v60 = *(_DWORD *)(v4 + 92);
        *(_DWORD *)buf = 67110914;
        *(_DWORD *)&uint8_t buf[4] = v66;
        uint64_t v76 = 1024;
        uint64_t v77 = v59;
        uint64_t v78 = 1024;
        uint64_t v79 = v27 >> 1;
        uint64_t v80 = 1024;
        uint64_t v81 = v60;
        uint64_t v82 = 2112;
        uint64_t v83 = v29;
        BOOL v84 = 1024;
        int v85 = v67;
        uint64_t v86 = 2112;
        BOOL v87 = (void *)v28;
        uint64_t v88 = 1024;
        unint64_t v89 = v26 >> 31;
        _os_log_impl( (void *)&_mh_execute_header,  v58,  OS_LOG_TYPE_DEFAULT,  "[R%u->Q%u] getaddrinfo result -- event: %{mdns:addrmv}d, ifindex: %d, name: %@, type: %{mdns:rrtype}d, rdata: %@, expired: %{mdns:yesno}d",  buf,  0x3Au);
        uint64_t v1 = v65;
        if (v33) {
          goto LABEL_76;
        }
LABEL_77:
        if (v32) {
          goto LABEL_78;
        }
LABEL_80:
        v72[3] = *(void *)(v4 + 16);
        _dx_release((char *)v4);
        xpc_array_append_value(xarray, v7);
        xpc_release(v7);
        uint64_t v3 = v72;
        uint64_t v4 = v72[3];
        if (!v4) {
          goto LABEL_83;
        }
      }

      uint64_t v1 = v65;
      if (!v33) {
        goto LABEL_77;
      }
LABEL_76:
      free(v35);
      goto LABEL_77;
    }

    _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_DEFAULT, v34, buf, v36);
    return;
  }

  if (_mdns_push_notifications_log_s_once != -1) {
    dispatch_once(&_mdns_push_notifications_log_s_once, &__block_literal_global_6664);
  }
  uint64_t v30 = _mdns_push_notifications_log_s_log;
  if (os_log_type_enabled((os_log_t)_mdns_push_notifications_log_s_log, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v31 = *((void *)object + 15);
    uint64_t v32 = *(void *)(v45 + 120);
    uint64_t v33 = *(void *)(v2 + 40);
    if (v33) {
      uint64_t v33 = *(void *)(v33 + 40);
    }
    *(_DWORD *)buf = 134219010;
    uint64_t v47 = v31;
    uint64_t v48 = 2048;
    uint64_t v49 = v32;
    uint64_t v50 = 2048;
    uint64_t v51 = (_WORD *)v33;
    uint64_t v52 = 2112;
    int v53 = (_WORD *)v2;
    int v54 = 2112;
    int v55 = object;
    unint64_t v34 = "[DupSub%llu->Sub%llu->DSO%llu] Existing subscription in the session -- server: %@, subscriber: %@";
    unsigned int v35 = (os_log_s *)v30;
    int v36 = 52;
    goto LABEL_70;
  }

      nw_parameters_set_uid(v6, *(unsigned int *)(a1 + 248));
      if (*(_DWORD *)(a1 + 244))
      {
        nw_parameters_set_pid(v6);
        *(void *)buf = 0LL;
        *(void *)&uint64_t v94 = 0LL;
        if (mdns_system_pid_to_uuid(*(_DWORD *)(a1 + 244), buf))
        {
          uint64_t v31 = 0;
          goto LABEL_76;
        }

        uint64_t v32 = buf;
      }

      else
      {
        uint64_t v32 = (uint8_t *)(a1 + 636);
      }

      nw_parameters_set_e_proc_uuid(v6, v32);
      uint64_t v31 = 1;
LABEL_76:
      evaluator_for_endpoint = nw_path_create_evaluator_for_endpoint(v4, v6);
      if (evaluator_for_endpoint)
      {
        unint64_t v34 = (void *)evaluator_for_endpoint;
        nw_release(v4);
        nw_release(v6);
        unsigned int v35 = (nw_path *)nw_path_evaluator_copy_path(v34);
        if (v35)
        {
          int v36 = v35;
          if (nw_path_get_status(v35) == nw_path_status_satisfied)
          {
            flow_divert_unit = nw_path_get_flow_divert_unit(v36);
            if (!flow_divert_unit)
            {
              int v61 = (nw_interface *)nw_path_copy_scoped_interface(v36);
              if (!v61) {
                goto LABEL_176;
              }
              uint64_t v62 = v61;
              index = nw_interface_get_index(v61);
              *(void *)(a1 + 136) = index;
              nw_release(v62);
              if (index == (_DWORD)v13) {
                goto LABEL_176;
              }
              int v64 = mDNSLogCategory_Default;
              if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
              {
                if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
                  goto LABEL_176;
                }
              }

              else
              {
                int v64 = mDNSLogCategory_Default_redacted;
                if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
                  goto LABEL_176;
                }
              }

              uint64_t v83 = bswap32(*(unsigned __int16 *)(a1 + 320));
              *(_DWORD *)buf = 67109632;
              *(_DWORD *)&uint8_t buf[4] = HIWORD(v83);
              LOWORD(v94) = 1024;
              *(_DWORD *)((char *)&v94 + 2) = v13;
              WORD3(v94) = 1024;
              DWORD2(v94) = index;
              BOOL v84 = "[Q%u] mDNSPlatformGetDNSRoutePolicy: DNS Route Policy has changed the scoped ifindex from [%d] to [%d]";
              int v85 = (os_log_s *)v64;
              uint64_t v86 = 20;
LABEL_175:
              _os_log_impl((void *)&_mh_execute_header, v85, OS_LOG_TYPE_DEFAULT, v84, buf, v86);
              goto LABEL_176;
            }

            unsigned int v38 = flow_divert_unit;
            *(_DWORD *)(a1 + 280) = flow_divert_unit;
            uint64_t v39 = mDNSLogCategory_Default;
            if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
            {
              if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
              {
                BOOL v40 = bswap32(*(unsigned __int16 *)(a1 + 320)) >> 16;
                uint64_t v66 = (_BYTE *)(a1 + 356);
                if (a1 == -612)
                {
LABEL_146:
                  while (v66)
                  {
                    __int16 v67 = *v66;
                    if (!*v66)
                    {
                      uint64_t v78 = (unsigned __int16)((_WORD)v66 - v2 + 1);
                      goto LABEL_174;
                    }

                    v66 += v67 + 1;
                    if (a1 != -612) {
                      goto LABEL_145;
                    }
                  }
                }

                else
                {
LABEL_145:
                }

                uint64_t v78 = 257;
                goto LABEL_174;
              }
            }

            else
            {
              uint64_t v39 = mDNSLogCategory_Default_redacted;
              if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
              {
                BOOL v40 = bswap32(*(unsigned __int16 *)(a1 + 320)) >> 16;
                uint64_t v41 = (_BYTE *)(a1 + 356);
                if (a1 == -612)
                {
LABEL_85:
                  while (v41)
                  {
                    char v42 = *v41;
                    if (!*v41)
                    {
                      uint64_t v78 = (unsigned __int16)((_WORD)v41 - v2 + 1);
                      goto LABEL_174;
                    }

                    v41 += v42 + 1;
                    if (a1 != -612) {
                      goto LABEL_84;
                    }
                  }
                }

                else
                {
LABEL_84:
                }

                uint64_t v78 = 257;
LABEL_174:
                *(_DWORD *)buf = 67110147;
                *(_DWORD *)&uint8_t buf[4] = v40;
                LOWORD(v94) = 2160;
                *(void *)((char *)&v94 + 2) = 1752392040LL;
                WORD5(v94) = 1040;
                HIDWORD(v94) = v78;
                *(_WORD *)BOOL v95 = 2101;
                *(void *)&v95[2] = a1 + 356;
                int v96 = 1024;
                LODWORD(v97) = v38;
                BOOL v84 = "[Q%u] mDNSPlatformGetDNSRoutePolicy: Query for %{sensitive, mask.hash, mdnsresponder:domain_name}."
                      "*P service ID is set ->service_ID:[%d] ";
                int v85 = (os_log_s *)v39;
                uint64_t v86 = 40;
                goto LABEL_175;
              }
            }
          }

          else if (v31 {
                 && nw_path_get_status(v36) == nw_path_status_unsatisfied
          }
                 && nw_path_get_reason(v36) != 3)
          {
            uint64_t v51 = 1;
LABEL_182:
            nw_release(v36);
            goto LABEL_183;
          }

uint64_t PacketRRConflict(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if ((*(_BYTE *)(a2 + 8) & 0x32) == 0 || *(void *)(a2 + 88)) {
    return 0LL;
  }
  unsigned int v6 = (uint64_t **)(a1 + 12624);
  BOOL v7 = (void *)(a1 + 12624);
  while (1)
  {
    BOOL v7 = (void *)*v7;
    if (!v7) {
      break;
    }
  }

  unint64_t v8 = (void *)(a1 + 12632);
  while (1)
  {
    unint64_t v8 = (void *)*v8;
    if (!v8) {
      break;
    }
  }

  unint64_t v9 = *(void *)(a2 + 96) ? *(uint64_t **)(a2 + 96) : (uint64_t *)a2;
  unsigned __int16 v10 = *v6;
  if (v10)
  {
    while (*((_DWORD *)v10 + 6) != *(_DWORD *)(a3 + 24)
         || !resource_records_have_same_dnssec_rr_category(v10[8], *(void *)(a3 + 64))
         || *((unsigned __int16 *)v10 + 6) != *(unsigned __int16 *)(a3 + 12)
         || *((unsigned __int16 *)v10 + 7) != *(unsigned __int16 *)(a3 + 14)
         || *((unsigned __int16 *)v10 + 10) != *(unsigned __int16 *)(a3 + 20)
         || *((_DWORD *)v10 + 7) != *(_DWORD *)(a3 + 28)
         || !SameRDataBody( (uint64_t)(v10 + 1),  (unsigned __int16 *)(*(void *)(a3 + 48) + 4LL),  (uint64_t (*)(uint64_t, unsigned __int16 *))SameDomainName)
         || !SameDomainNameBytes((_BYTE *)v10[5], *(_BYTE **)(a3 + 40)))
    {
      unsigned __int16 v10 = (uint64_t *)*v10;
      if (!v10) {
        goto LABEL_24;
      }
    }

    char v11 = (uint64_t *)v10[12];
    if (!v11) {
      char v11 = v10;
    }
  }

  else
  {
LABEL_24:
    char v11 = 0LL;
  }

  if (v11 == v9) {
    return 0LL;
  }
  if (v11) {
    BOOL v13 = *(_DWORD *)(a2 + 126) == 0;
  }
  else {
    BOOL v13 = 1;
  }
  char v14 = v13;
  return v14 & 1;
}

uint64_t AddAdditionalsToResponseList( uint64_t result, uint64_t a2, uint64_t **a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a2)
  {
    uint64_t v10 = a2;
    char v11 = (void *)result;
    uint64_t v12 = result + 11448;
    BOOL v13 = (uint64_t *)(result + 11704);
    while (1)
    {
      uint64_t v14 = *(void *)(v10 + 72);
      if (v14 && ResourceRecordIsValidInterfaceAnswer(v14, a4, (uint64_t)a3, a4, a5, a6, a7, a8))
      {
        uint64_t v15 = *(void *)(v10 + 72);
        if (!*(void *)(v15 + 256) && *a3 != (uint64_t *)(v15 + 256))
        {
          **a3 = v15;
          uint64_t v16 = *(void *)(v10 + 272);
          if (!v16) {
            uint64_t v16 = v10;
          }
          *(void *)(v15 + 272) = v16;
          *a3 = (uint64_t *)(v15 + 256);
          uint64_t v15 = *(void *)(v10 + 72);
        }

        AddRRSetAdditionalsToResponseList((uint64_t)v11, a3, v10, v15, a4, a6, a7, a8);
      }

      BOOL result = *(void *)(v10 + 80);
      if (result)
      {
        BOOL result = ResourceRecordIsValidInterfaceAnswer(result, a4, (uint64_t)a3, a4, a5, a6, a7, a8);
        if ((_DWORD)result)
        {
          uint64_t v17 = *(void *)(v10 + 80);
          if (!*(void *)(v17 + 256) && *a3 != (uint64_t *)(v17 + 256))
          {
            **a3 = v17;
            uint64_t v18 = *(void *)(v10 + 272);
            if (!v18) {
              uint64_t v18 = v10;
            }
            *(void *)(v17 + 272) = v18;
            *a3 = (uint64_t *)(v17 + 256);
            uint64_t v17 = *(void *)(v10 + 80);
          }

          BOOL result = AddRRSetAdditionalsToResponseList((uint64_t)v11, a3, v10, v17, a4, a6, a7, a8);
        }
      }

      unsigned int v19 = *(unsigned __int16 *)(v10 + 12);
      if (v19 > 0x1B) {
        break;
      }
      if (v19 == 1) {
        goto LABEL_47;
      }
      if (v19 == 12)
      {
        BOOL result = ResourceRecordIsValidInterfaceAnswer(v12, a4, (uint64_t)a3, a4, a5, a6, a7, a8);
        if ((_DWORD)result)
        {
          BOOL result = SameDomainLabelPointer(*(void *)(v10 + 48) + 4LL, v11[1436]);
          if ((_DWORD)result)
          {
            if (!*v13 && *a3 != v13)
            {
              **a3 = v12;
              uint64_t v20 = *(void *)(v10 + 272);
              if (!v20) {
                uint64_t v20 = v10;
              }
              v11[1465] = v20;
              *a3 = v13;
            }
          }
        }
      }

void mDNS_HostNameCallback( uint64_t a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a3 != -65792)
  {
    if (a3 == -65548)
    {
      __int128 v10 = *(_OWORD *)(a1 + 10368);
      v18[0] = *(_OWORD *)(a1 + 10352);
      v18[1] = v10;
      __int128 v11 = *(_OWORD *)(a1 + 10400);
      v18[2] = *(_OWORD *)(a1 + 10384);
      v18[3] = v11;
      uint64_t v12 = *(void (**)(uint64_t, uint64_t))(a1 + 32);
      if (v12) {
        v12(a1, 4294901748LL);
      }
      mDNS_SetFQDN(a1);
      LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "Local Hostname %#s.local already in use; will try %#s.local instead",
        v13,
        v14,
        v15,
        v16,
        v17,
        (int)v18);
    }

    else if (a3)
    {
      LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "mDNS_HostNameCallback: Unknown error %d for registration of record %s",  a4,  a5,  a6,  a7,  a8,  a3);
    }

    else
    {
      unint64_t v9 = *(void (**)(uint64_t, void))(a1 + 32);
      if (v9) {
        v9(a1, 0LL);
      }
    }
  }

void regservice_callback( uint64_t a1, uint64_t a2, unsigned int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v92 = 0LL;
  if (!a2)
  {
    uint64_t v14 = mDNSLogCategory_mDNS;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
        return;
      }
      *(_DWORD *)buf = 67109120;
      unsigned int v94 = a3;
      uint64_t v16 = "regservice_callback: srs is NULL %d";
    }

    else
    {
      uint64_t v14 = mDNSLogCategory_mDNS_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
        return;
      }
      *(_DWORD *)buf = 67109120;
      unsigned int v94 = a3;
      uint64_t v16 = "regservice_callback: srs is NULL %d";
    }

LABEL_100:
    uint64_t v43 = (os_log_s *)v14;
    uint32_t v44 = 8;
LABEL_101:
    _os_log_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_DEFAULT, v16, buf, v44);
    return;
  }

  uint64_t v10 = *(void *)(a2 + 8);
  if (!v10)
  {
    uint64_t v14 = mDNSLogCategory_mDNS;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
        return;
      }
      *(_DWORD *)buf = 67109120;
      unsigned int v94 = a3;
      uint64_t v16 = "regservice_callback: srs->ServiceContext is NULL %d";
    }

    else
    {
      uint64_t v14 = mDNSLogCategory_mDNS_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
        return;
      }
      *(_DWORD *)buf = 67109120;
      unsigned int v94 = a3;
      uint64_t v16 = "regservice_callback: srs->ServiceContext is NULL %d";
    }

    goto LABEL_100;
  }

  uint64_t v12 = *(void *)(v10 + 8);
  BOOL v13 = !v12 || !*(_BYTE *)(*(void *)(v12 + 112) + 1355LL) || *(_BYTE *)(v10 + 26) != 0;
  if (mDNS_LoggingEnabled == 1)
  {
    memset(v107, 0, sizeof(v107));
    uint64_t v17 = *(void *)(v10 + 8);
    if (v17)
    {
      unsigned int v18 = *(_DWORD *)(v17 + 184);
      if (a3) {
        goto LABEL_17;
      }
    }

    else
    {
      unsigned int v18 = 0;
      if (a3)
      {
LABEL_17:
        if (a3 == -65548)
        {
          unsigned int v19 = "NAME CONFLICT";
        }

        else if (a3 == -65792)
        {
          unsigned int v19 = "DEREGISTERED";
        }

        else
        {
          uint64_t v23 = "suppressed error";
          if (v13) {
            uint64_t v23 = "CALLBACK";
          }
          int v91 = (int)v23;
          unsigned int v19 = (const char *)v107;
          mDNS_snprintf(v107);
        }

    BOOL v40 = 141558531;
    uint64_t v41 = 1752392040LL;
    uint64_t v42 = 1040;
    uint64_t v43 = v21;
    uint32_t v44 = 2101;
    int v45 = a1;
    _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_DEFAULT,  "mDNS_RemoveDynDNSHostName: no such domainname %{sensitive, mask.hash, mdnsresponder:domain_name}.*P",  (uint8_t *)&v40,  0x1Cu);
    goto LABEL_101;
  }

  uint64_t v16 = *((unsigned __int8 *)v15 + 472);
  if (*((_BYTE *)v15 + 472)) {
    uint64_t v16 = v15[202] != 4;
  }
  if (*((_BYTE *)v15 + 1648)) {
    uint64_t v17 = v15[496] != 4;
  }
  else {
    uint64_t v17 = 0;
  }
  *BOOL v13 = *(void **)v15;
  if ((v16 | v17) == 1)
  {
    if (!v16) {
      goto LABEL_124;
    }
    int v26 = (os_log_s *)mDNSLogCategory_uDNS;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_uDNS == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_uDNS, OS_LOG_TYPE_DEFAULT))
      {
        if (a1)
        {
          unsigned __int16 v31 = a1;
          if (a1 == (_BYTE *)-256LL) {
            goto LABEL_110;
          }
LABEL_107:
          unsigned __int16 v28 = 257;
          if (v31 < a1 + 256 && v31)
          {
            while (1)
            {
              uint64_t v32 = *v31;
              if (v32 > 0x3F)
              {
LABEL_118:
                unsigned __int16 v28 = 257;
                goto LABEL_122;
              }

              if (!*v31) {
                break;
              }
              v31 += v32 + 1;
              if (a1 != (_BYTE *)-256LL) {
                goto LABEL_107;
              }
LABEL_110:
              if (!v31) {
                goto LABEL_118;
              }
            }

            unsigned __int16 v28 = (unsigned __int16)((_WORD)v31 - (_WORD)a1 + 1);
          }
        }

        else
        {
          unsigned __int16 v28 = 0;
        }

        goto LABEL_122;
      }
    }

    else
    {
      int v26 = (os_log_s *)mDNSLogCategory_uDNS_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_uDNS_redacted, OS_LOG_TYPE_DEFAULT))
      {
        if (a1)
        {
          unint64_t v27 = a1;
          if (a1 == (_BYTE *)-256LL) {
            goto LABEL_87;
          }
LABEL_84:
          unsigned __int16 v28 = 257;
          if (v27 < a1 + 256 && v27)
          {
            while (1)
            {
              uint64_t v29 = *v27;
              if (v29 > 0x3F)
              {
LABEL_117:
                unsigned __int16 v28 = 257;
                goto LABEL_122;
              }

              if (!*v27) {
                break;
              }
              v27 += v29 + 1;
              if (a1 != (_BYTE *)-256LL) {
                goto LABEL_84;
              }
LABEL_87:
              if (!v27) {
                goto LABEL_117;
              }
            }

            unsigned __int16 v28 = (unsigned __int16)((_WORD)v27 - (_WORD)a1 + 1);
          }
        }

        else
        {
          unsigned __int16 v28 = 0;
        }

      uint64_t v62 = v7;
      if ((v4 & 1) == 0
        || (*(_BYTE *)(v5 + 264) & 2) != 0
        || SameDomainNameBytes((_BYTE *)(v5 + 8), "\x05local")
        || *(void *)(v5 + 272))
      {
        goto LABEL_114;
      }

      int Domains = mDNS_GetDomains(v5 + 280, 0, (char *)(v5 + 8), 0LL, (uint64_t)FoundDomain, v5);
      uint64_t v64 = mDNSLogCategory_State;
      if (Domains)
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_ERROR)) {
          goto LABEL_110;
        }
        *(_DWORD *)buf = 67109376;
        *(_DWORD *)uint64_t v93 = v62;
        *(_WORD *)&v93[4] = 1024;
        *(_DWORD *)&v93[6] = Domains;
        __int16 v65 = (os_log_s *)v64;
        uint64_t v66 = OS_LOG_TYPE_ERROR;
        __int16 v67 = "uDNS_SetupWABQueries: GetDomains(mDNS_DomainTypeBrowse) returned error -- name hash: %x, error: %d";
        uint64_t v68 = 14;
      }

      else
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_110;
        }
        *(_DWORD *)buf = 67109120;
        *(_DWORD *)uint64_t v93 = v62;
        __int16 v65 = (os_log_s *)v64;
        uint64_t v66 = OS_LOG_TYPE_DEFAULT;
        __int16 v67 = "uDNS_SetupWABQueries: Starting Browse for domain -- name hash: %x";
        uint64_t v68 = 8;
      }

      _os_log_impl((void *)&_mh_execute_header, v65, v66, v67, buf, v68);
LABEL_110:
      int v90 = Domains;
      unsigned int v69 = mDNS_GetDomains(v5 + 936, 1, (char *)(v5 + 8), *(void *)(v5 + 272), (uint64_t)FoundDomain, v5);
      int v70 = (os_log_s *)mDNSLogCategory_State;
      if (v69)
      {
        char v71 = v69;
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 67109376;
          *(_DWORD *)uint64_t v93 = v62;
          *(_WORD *)&v93[4] = 1024;
          *(_DWORD *)&v93[6] = v71;
          _os_log_impl( (void *)&_mh_execute_header,  v70,  OS_LOG_TYPE_ERROR,  "uDNS_SetupWABQueries: GetDomains(mDNS_DomainTypeBrowseDefault) returned error -- name hash: %x, error: %d",  buf,  0xEu);
        }

        if (v90)
        {
LABEL_114:
          if ((v4 & 2) == 0) {
            goto LABEL_128;
          }
          goto LABEL_115;
        }
      }

      else if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 67109120;
        *(_DWORD *)uint64_t v93 = v62;
        _os_log_impl( (void *)&_mh_execute_header,  v70,  OS_LOG_TYPE_DEFAULT,  "uDNS_SetupWABQueries: Starting Default Browse for domain -- name hash: %x",  buf,  8u);
      }

      *(_DWORD *)(v5 + 264) |= 2u;
      if ((v4 & 2) == 0) {
        goto LABEL_128;
      }
LABEL_115:
      if ((*(_BYTE *)(v5 + 264) & 4) == 0
        && !SameDomainNameBytes((_BYTE *)(v5 + 8), "\x05local")
        && !*(void *)(v5 + 272))
      {
        uint64_t v72 = mDNS_GetDomains(v5 + 1592, 2, (char *)(v5 + 8), 0LL, (uint64_t)FoundDomain, v5);
        if (v72)
        {
          int v73 = v72;
          uint64_t v74 = mDNSLogCategory_State;
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 67109376;
            *(_DWORD *)uint64_t v93 = v62;
            *(_WORD *)&v93[4] = 1024;
            *(_DWORD *)&v93[6] = v73;
            uint64_t v75 = (os_log_s *)v74;
            uint64_t v76 = OS_LOG_TYPE_ERROR;
            uint64_t v77 = "uDNS_SetupWABQueries: GetDomains(mDNS_DomainTypeBrowseAutomatic) returned error -- name hash: %x, error: %d";
            uint64_t v78 = 14;
LABEL_127:
            _os_log_impl((void *)&_mh_execute_header, v75, v76, v77, buf, v78);
          }
        }

        else
        {
          *(_DWORD *)(v5 + 264) |= 4u;
          uint64_t v79 = mDNSLogCategory_State;
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 67109120;
            *(_DWORD *)uint64_t v93 = v62;
            uint64_t v75 = (os_log_s *)v79;
            uint64_t v76 = OS_LOG_TYPE_DEFAULT;
            uint64_t v77 = "uDNS_SetupWABQueries: Starting Legacy Browse for domain -- name hash: %x";
            uint64_t v78 = 8;
            goto LABEL_127;
          }
        }
      }

LABEL_183:
    *(_DWORD *)buf = 67109891;
    unsigned int v94 = v39;
    __int16 v95 = 2160;
    uint64_t v96 = 1752392040LL;
    __int16 v97 = 1040;
    int v98 = v70;
    __int16 v99 = 2101;
    int v100 = v40;
    _os_log_impl( (void *)&_mh_execute_header,  v37,  OS_LOG_TYPE_DEFAULT,  "[R%u] regservice_callback: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P is not valid DNS-SD SRV name",  buf,  0x22u);
    goto LABEL_184;
  }

  uint64_t v48 = *(void *)(v12 + 112);
  if (!*(_BYTE *)(v48 + 1613))
  {
    if (v13)
    {
      if (GenerateNTDResponse( *(char **)(a2 + 2448),  *(void *)(a2 + 2440),  v12,  (char **)&v92,  (char *)0x41,  2u,  0xFFFEFFF4))
      {
        int v54 = (os_log_s *)mDNSLogCategory_Default;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
        {
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
          {
            unsigned int v55 = *(_DWORD *)(*(void *)(v10 + 8) + 184LL);
            uint64_t v56 = *(unsigned __int8 **)(a2 + 2448);
            if (v56)
            {
              char v71 = *(unsigned __int8 **)(a2 + 2448);
              if (v56 == (unsigned __int8 *)-256LL)
              {
LABEL_173:
                while (v71)
                {
                  uint64_t v72 = *v71;
                  if (!*v71)
                  {
                    int v90 = (unsigned __int16)((_WORD)v71 - (_WORD)v56 + 1);
                    goto LABEL_219;
                  }

                  v71 += v72 + 1;
                }
              }

              else
              {
LABEL_172:
                if (v71 < v56 + 256) {
                  goto LABEL_173;
                }
              }

              int v90 = 257;
            }

            else
            {
              int v90 = 0;
            }

            goto LABEL_219;
          }
        }

        else
        {
          int v54 = (os_log_s *)mDNSLogCategory_Default_redacted;
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
          {
            unsigned int v55 = *(_DWORD *)(*(void *)(v10 + 8) + 184LL);
            uint64_t v56 = *(unsigned __int8 **)(a2 + 2448);
            if (v56)
            {
              uint64_t v57 = *(unsigned __int8 **)(a2 + 2448);
              if (v56 == (unsigned __int8 *)-256LL)
              {
LABEL_138:
                while (v57)
                {
                  uint64_t v58 = *v57;
                  if (!*v57)
                  {
                    int v90 = (unsigned __int16)((_WORD)v57 - (_WORD)v56 + 1);
                    goto LABEL_219;
                  }

                  v57 += v58 + 1;
                }
              }

              else
              {
LABEL_137:
                if (v57 < v56 + 256) {
                  goto LABEL_138;
                }
              }

              int v90 = 257;
            }

            else
            {
              int v90 = 0;
            }

LABEL_219:
            *(_DWORD *)buf = 67109891;
            unsigned int v94 = v55;
            __int16 v95 = 2160;
            uint64_t v96 = 1752392040LL;
            __int16 v97 = 1040;
            int v98 = v90;
            __int16 v99 = 2101;
            int v100 = v56;
            _os_log_impl( (void *)&_mh_execute_header,  v54,  OS_LOG_TYPE_DEFAULT,  "[R%u] regservice_callback: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P is not valid DNS-SD SRV name",  buf,  0x22u);
          }
        }
      }

      else
      {
        append_reply(*(void *)(v10 + 8), v92);
        *(_BYTE *)(v10 + 25) = 1;
      }
    }

uint64_t GenerateNTDResponse( char *a1, uint64_t a2, uint64_t a3, char **a4, char *a5, unsigned int a6, unsigned int a7)
{
  *a4 = 0LL;
  if (a1)
  {
    memset(__s, 0, sizeof(__s));
    bzero(&__src, 0x3F1uLL);
    bzero(&v52, 0x3F1uLL);
    uint64_t v14 = v59[0];
    if (v59[0] <= 0x3FuLL)
    {
      uint64_t v15 = &v59[1];
      if (&v59[1] >= &v59[v59[0] + 1])
      {
        uint64_t v16 = __s;
      }

      else
      {
        uint64_t v16 = __s;
        do
        {
          char v17 = *v15++;
          *v16++ = v17;
          --v14;
        }

        while (v14);
      }

      *uint64_t v16 = 0;
    }

    unsigned int v50 = a7;
    ConvertDomainNameToCString_withescape(v58, (unsigned __int8 *)&__src);
    ConvertDomainNameToCString_withescape(v57, (unsigned __int8 *)&v52);
  }

  else
  {
    unsigned int v50 = a7;
    __s[3] = 0uLL;
    *(_OWORD *)((char *)&__s[2] + 1) = 0uLL;
    *(_OWORD *)((char *)&__s[1] + 1) = 0uLL;
    *(_OWORD *)((char *)__s + 1) = 0uLL;
    bzero(&v55, 0x3F0uLL);
    bzero(&v53, 0x3F0uLL);
    LOBYTE(__s[0]) = 0;
    char __src = 0;
    char v52 = 0;
  }

  unsigned int v24 = mDNSPlatformInterfaceIndexfromInterfaceID((uint64_t **)mDNSStorage, a2, 0LL, v18, v19, v20, v21, v22);
  size_t v25 = strlen((const char *)__s);
  size_t v26 = strlen(&__src);
  unsigned int v27 = 0;
  unsigned __int16 v28 = 0LL;
  unint64_t v34 = v25 + v26 + strlen(&v52) + 15;
  if (a1 && *(_BYTE *)(a3 + 274))
  {
    int v51 = 0;
    memset(out, 0, 16);
    uuid_generate_random((unsigned __int8 *)out);
    uint64_t v35 = _mdns_signed_browse_result_create_ex((const unsigned __int8 *)out, (unsigned __int8 *)a1, v24, 0LL, 0, &v51);
    unsigned __int16 v28 = (void *)v35;
    if (v35 && !v51)
    {
      *(void *)out = 0LL;
      __int16 data = mdns_signed_result_get_data(v35, out);
      unsigned __int16 v37 = out[0];
      uint64_t v38 = out[0] + 4LL;
      if (*(void *)out >= 0x10000uLL) {
        uint64_t v38 = 0LL;
      }
      v34 += v38;
      if (*(void *)out >= 0x10000uLL) {
        unsigned int v39 = 0LL;
      }
      else {
        unsigned int v39 = data;
      }
      if (*(void *)out >= 0x10000uLL) {
        unsigned __int16 v37 = 0;
      }
      unsigned int v27 = v37;
      goto LABEL_34;
    }

    uint64_t v40 = v51;
    uint64_t v41 = (os_log_s *)mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)out = 134217984;
        *(void *)&out[2] = v40;
        goto LABEL_32;
      }
    }

    else
    {
      uint64_t v41 = (os_log_s *)mDNSLogCategory_Default_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)out = 134217984;
        *(void *)&out[2] = v40;
LABEL_32:
        _os_log_impl( (void *)&_mh_execute_header,  v41,  OS_LOG_TYPE_ERROR,  "GenerateBrowseReply signed_browse failed %ld",  (uint8_t *)out,  0xCu);
      }
    }

    unsigned int v39 = 0LL;
    unsigned int v27 = 0;
    goto LABEL_34;
  }

  unsigned int v39 = 0LL;
LABEL_34:
  reply = create_reply(a5, v34, a3, v29, v30, v31, v32, v33);
  *a4 = reply;
  *((_DWORD *)reply + 11) = bswap32(a6);
  *((_DWORD *)reply + 12) = bswap32(v24);
  *((_DWORD *)reply + 13) = bswap32(v50);
  uint64_t v43 = reply + 56;
  memcpy(reply + 56, __s, v25 + 1);
  uint32_t v44 = &v43[v25 + 1];
  size_t v45 = strlen(&__src) + 1;
  memcpy(v44, &__src, v45);
  int v46 = &v44[v45];
  size_t v47 = strlen(&v52) + 1;
  memcpy(v46, &v52, v47);
  if (v39)
  {
    uint64_t v48 = *a4;
    uint64_t v49 = &v46[v47];
    if (&v46[v47])
    {
      if (v49 <= &v49[v34] && v34 >= (unint64_t)v27 + 4)
      {
        *(_WORD *)uint64_t v49 = 1792;
        v49[2] = BYTE1(v27);
        v49[3] = v27;
        if (v27) {
          memcpy(v49 + 4, v39, v27);
        }
      }
    }

    *((_DWORD *)v48 + 6) |= 2u;
  }

  if (v28) {
    os_release(v28);
  }
  return 0LL;
}

uint64_t DeconstructServiceName(char *a1, _BYTE *a2, uint64_t a3, _BYTE *a4)
{
  int v4 = *a1;
  unint64_t v5 = (unint64_t)(a1 + 256);
  int v6 = v4 + 1;
  do
  {
    char v7 = *a1++;
    *a2++ = v7;
    --v6;
  }

  while (v6);
  int v8 = *a1;
  if (a1[1] != 95) {
    return 0LL;
  }
  uint64_t v9 = 0LL;
  int v10 = v8 + 1;
  do
  {
    *(_BYTE *)(a3 + v9) = a1[v9];
    ++v9;
  }

  while (v10 != (_DWORD)v9);
  __int128 v11 = (unsigned __int8 *)&a1[v9];
  if (a1[v9] != 4 || v11[1] != 95) {
    return 0LL;
  }
  int v12 = v11[2] & 0xDF;
  if (v12 == 84)
  {
    if ((v11[3] & 0xDF) != 0x43) {
      return 0LL;
    }
  }

  else if (v12 != 85 || (v11[3] & 0xDF) != 0x44)
  {
    return 0LL;
  }

  if ((v11[4] & 0xDF) != 0x50) {
    return 0LL;
  }
  uint64_t v13 = 0LL;
  do
  {
    char v14 = *v11++;
    *(_BYTE *)(a3 + v13++ + v9) = v14;
  }

  while ((_DWORD)v13 != 5);
  *(_BYTE *)(a3 + v9 + v13) = 0;
  while (1)
  {
    unsigned int v15 = *v11;
    if (!*v11) {
      break;
    }
    uint64_t result = 0LL;
    unsigned int v17 = v15 + 1;
    do
    {
      char v18 = *v11++;
      *a4++ = v18;
      --v17;
    }

    while (v17);
  }

  *a4 = 0;
  return 1LL;
}

uint64_t CountPeerRegistrations(uint64_t a1)
{
  uint64_t v1 = (uint64_t *)xmmword_10015BD08;
  if (!(void)xmmword_10015BD08) {
    return 0LL;
  }
  uint64_t v3 = 0LL;
  do
  {
    if (*((_WORD *)v1 + 6) == 33 && SameDomainNameBytes((_BYTE *)v1[5], *(_BYTE **)(a1 + 2448)))
    {
      BOOL v4 = resource_records_have_same_dnssec_rr_category(v1[8], *(void *)(a1 + 2472))
        && *((unsigned __int16 *)v1 + 6) == *(unsigned __int16 *)(a1 + 2420)
        && *((unsigned __int16 *)v1 + 7) == *(unsigned __int16 *)(a1 + 2422)
        && *((unsigned __int16 *)v1 + 10) == *(unsigned __int16 *)(a1 + 2428)
        && *((_DWORD *)v1 + 7) == *(_DWORD *)(a1 + 2436)
        && SameRDataBody( (uint64_t)(v1 + 1),  (unsigned __int16 *)(*(void *)(a1 + 2456) + 4LL),  (uint64_t (*)(uint64_t, unsigned __int16 *))SameDomainName) != 0;
      uint64_t v3 = v3 + !v4;
    }

    uint64_t v1 = (uint64_t *)*v1;
  }

  while (v1);
  return v3;
}

void ClearProxyRecords(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(void *)(a1 + 12648);
  char v7 = &unk_100164000;
  if (v6)
  {
    int v8 = (os_log_s *)mDNSLogCategory_Default;
    GetRRDisplayString_rdb( (unsigned __int8 *)(v6 + 8),  (unsigned __int16 *)(*(void *)(v6 + 48) + 4LL),  (_BYTE *)(a1 + 46976));
    LogMsgWithLevel( v8,  OS_LOG_TYPE_DEFAULT,  "ClearProxyRecords ERROR m->CurrentRecord already set %s",  v9,  v10,  v11,  v12,  v13,  a1 + 46976);
  }

  *(void *)(a1 + 12648) = a3;
  if (a3)
  {
    uint64_t v14 = *(void *)(a1 + 37888);
    unsigned int v15 = &unk_100158000;
    do
    {
      if (v14 != *(void *)(a3 + 32)
        || *(unsigned __int16 *)(a2 + 2) != *(unsigned __int16 *)(a3 + 126)
        || *(unsigned __int16 *)(a2 + 4) != *(unsigned __int16 *)(a3 + 128)
        || *(unsigned __int16 *)(a2 + 6) != *(unsigned __int16 *)(a3 + 130)
        || *(unsigned __int8 *)(a2 + 1) == *(unsigned __int8 *)(a3 + 125)
        && *(_DWORD *)(a1 + 64) - *(_DWORD *)(a3 + 164) < 60001)
      {
        goto LABEL_20;
      }

      uint64_t v16 = (_BYTE *)(a3 + 8);
      if (v15[2840] == 1)
      {
        uint64_t v31 = (os_log_s *)*((void *)v7 + 170);
        int v17 = *(_DWORD *)(a1 + 19832);
        GetRRDisplayString_rdb( (unsigned __int8 *)(a3 + 8),  (unsigned __int16 *)(*(void *)(a3 + 48) + 4LL),  (_BYTE *)(a1 + 46976));
        char v7 = &unk_100164000;
        unsigned int v15 = (_BYTE *)&unk_100158000;
        LogMsgWithLevel( v31,  OS_LOG_TYPE_DEFAULT,  "ClearProxyRecords: Removing %3d AC %2d %02X H-MAC %.6a I-MAC %.6a %d %d %s",  v18,  v19,  v20,  v21,  v22,  v17);
      }

      if (*v16 == 1) {
        *uint64_t v16 = 8;
      }
      *(_WORD *)(a3 + 130) = 0;
      *(_DWORD *)(a3 + 126) = 0;
      *(_BYTE *)(a3 + 192) = 0;
      mDNS_Deregister_internal(a1, a3, 0);
      uint64_t v14 = *(void *)(a1 + 15040);
      if (v14)
      {
        if (v14 != *(void *)(a1 + 37888))
        {
          mDNSPlatformUpdateProxyList(v14, v23, v24, v25, v26, v27, v28, v29);
          uint64_t v14 = *(void *)(a1 + 37888);
        }
      }

      else
      {
        uint64_t v14 = *(void *)(a1 + 37888);
      }

      *(void *)(a1 + 15040) = v14;
      uint64_t v30 = *(void *)(a1 + 12648);
      if (v30 == a3)
      {
LABEL_20:
        uint64_t v30 = *(void *)a3;
        *(void *)(a1 + 12648) = *(void *)a3;
      }

      a3 = v30;
    }

    while (v30);
  }

void SendResponses( uint64_t a1, uint64_t a2, uint64_t a3, char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = a1;
  uint64_t v9 = *(uint64_t **)(a1 + 12664);
  if (v9)
  {
    uint64_t v10 = *(void *)(a1 + 12664);
    do
    {
      if (*(_BYTE *)(v10 + 16)) {
        break;
      }
      uint64_t v10 = *(void *)v10;
    }

    while (v10);
    uint64_t v12 = (_DWORD *)(a1 + 64);
    int v11 = *(_DWORD *)(a1 + 64);
    *(_DWORD *)(a1 + 100) = v11 + 939524096;
    unsigned int v294 = (unsigned __int8 *)(a1 + 141);
    uint64_t v298 = v10;
    if (*(_BYTE *)(a1 + 141) == 1)
    {
      uint64_t v13 = v9;
      while (!*((_BYTE *)v13 + 16))
      {
        uint64_t v13 = (uint64_t *)*v13;
        if (!v13) {
          goto LABEL_11;
        }
      }

      int v288 = v11 + 10000;
LABEL_543:
      if (*((_DWORD *)v13 + 679))
      {
        int v289 = *((_DWORD *)v13 + 680);
        if (v289 == v288) {
          *((_DWORD *)v13 + 680) = v289 + 1;
        }
      }

      while (1)
      {
        uint64_t v13 = (uint64_t *)*v13;
        if (!v13) {
          goto LABEL_11;
        }
        if (*((_BYTE *)v13 + 16)) {
          goto LABEL_543;
        }
      }
    }
  }

  else
  {
    uint64_t v298 = 0LL;
    uint64_t v12 = (_DWORD *)(a1 + 64);
    *(_DWORD *)(a1 + 100) = *(_DWORD *)(a1 + 64) + 939524096;
    unsigned int v294 = (unsigned __int8 *)(a1 + 141);
    if (*(_BYTE *)(a1 + 141) == 1)
    {
LABEL_11:
      uint64_t v14 = *(uint64_t **)(a1 + 12624);
      if (v14)
      {
        unsigned int v15 = &unk_100158000;
        uint64_t v16 = (_BYTE *)(a1 + 46976);
        while (1)
        {
          if (v14[4] || *((_BYTE *)v14 + 122) || IsLocalDomain((_BYTE *)v14[5]))
          {
            if (*((_WORD *)v14 + 179))
            {
              if (*v12 - (*((_DWORD *)v14 + 71) + *((_DWORD *)v14 + 70)) >= 0)
              {
                uint64_t v17 = *(void *)(v8 + 12664);
                if (v17) {
                  break;
                }
              }
            }
          }

LABEL_532:
        int v286 = *((_DWORD *)v9 + 679);
        if (v286)
        {
          if (v286 <= 7 && *((_DWORD *)v9 + 680) == *v12 + 10000) {
            *((_DWORD *)v9 + 679) = v286 + 1;
          }
        }

        while (1)
        {
          uint64_t v9 = (uint64_t *)*v9;
          if (!v9) {
            break;
          }
          if (*((_BYTE *)v9 + 16)) {
            goto LABEL_532;
          }
        }
      }
    }
  }

LABEL_154:
    unint64_t v86 = (uint64_t *)*v86;
    if (v86) {
      continue;
    }
    break;
  }

  uint64_t v93 = *(void *)(a1 + 12624);
  if (v93)
  {
    while (2)
    {
      if ((*(_BYTE *)(v93 + 8) & 0x32) == 0) {
        goto LABEL_190;
      }
      unsigned int v94 = (uint64_t *)(v93 + 208);
      if (*(void *)(v93 + 208))
      {
        for (uint64_t i = *(void *)(a1 + 12624); i; uint64_t i = *(void *)i)
        {
          if ((*(_BYTE *)(i + 8) & 0x32) != 0 && ResourceRecordIsValidAnswer(i))
          {
            uint64_t v96 = *(void *)(i + 208);
            if (v96 != -1
              && v96 != *v94
              && *(unsigned __int16 *)(i + 12) == *(unsigned __int16 *)(v93 + 12)
              && SameResourceRecordNameClassInterface(i, v93, a3, (uint64_t)a4, a5, a6, a7, a8))
            {
              uint64_t v97 = *v94;
              if (*v94 == -1) {
                goto LABEL_168;
              }
              uint64_t v98 = *(void *)(i + 32);
              if (v98)
              {
                if (v98 == v97) {
                  goto LABEL_168;
                }
              }

              else if (mDNSPlatformValidRecordForInterface(i, v97, a3, (uint64_t)a4, a5, a6, a7, a8))
              {
LABEL_168:
                if (*(void *)(i + 208)) {
                  __int16 v99 = &mDNSInterfaceMark;
                }
                else {
                  __int16 v99 = (void *)(v93 + 208);
                }
                *(void *)(i + 208) = *v99;
              }
            }
          }
        }

LABEL_190:
        uint64_t v93 = *(void *)v93;
        if (v93) {
          continue;
        }
        for (uint64_t j = *(void *)(a1 + 12624); j; uint64_t j = *(void *)j)
        {
          uint64_t v104 = *(void *)(j + 208);
          if (v104)
          {
            if (v104 == -1)
            {
              if (v298)
              {
                uint64_t v105 = *(void *)(j + 32);
                if (!v105) {
                  uint64_t v105 = *(void *)(v298 + 6256);
                }
              }

              else
              {
                uint64_t v105 = 0LL;
              }

              *(void *)(j + 216) = 0LL;
              *(void *)(j + 224) = v105;
              int v106 = *v12;
              *(_DWORD *)(j + 288) = *v12;
              *(void *)(j + 296) = -1LL;
              *(_BYTE *)(j + 189) = 0;
              if (*(_BYTE *)(j + 191))
              {
                int v107 = *(_DWORD *)(j + 280);
                int v108 = v107 >= 0 ? *(_DWORD *)(j + 280) : v107 + 1;
                if (v106 + (v108 >> 1) - (v107 + *(_DWORD *)(j + 284)) >= 0)
                {
                  --*(_BYTE *)(j + 191);
                  if (*(_BYTE *)(j + 8) != 1) {
                    *(_DWORD *)(j + 280) = 2 * v107;
                  }
                  *(_DWORD *)(j + 284) = v106;
                }
              }
            }

            else
            {
              *(void *)(j + 216) = 0LL;
              *(void *)(j + 224) = v104;
              *(_DWORD *)(j + 288) = *v12;
              *(void *)(j + 296) = v104;
            }
          }

          SetNextAnnounceProbeTime(a1, j);
        }

        goto LABEL_208;
      }

      break;
    }

    if (!*(void *)(v93 + 216)) {
      goto LABEL_190;
    }
    uint64_t v100 = *(void *)(a1 + 12624);
    if (!v100) {
      goto LABEL_190;
    }
    while (2)
    {
      if ((*(_BYTE *)(v100 + 8) & 0x32) != 0
        && ResourceRecordIsValidAnswer(v100)
        && *(void *)(v100 + 216) != *(void *)(v93 + 216)
        && *(unsigned __int16 *)(v100 + 12) == *(unsigned __int16 *)(v93 + 12)
        && SameResourceRecordNameClassInterface(v100, v93, a3, (uint64_t)a4, a5, a6, a7, a8))
      {
        uint64_t v101 = *(void *)(v93 + 216);
        uint64_t v102 = *(void *)(v100 + 32);
        if (v102)
        {
          if (v102 == v101) {
LABEL_188:
          }
            *(void *)(v100 + 216) = *(void *)(v93 + 216);
        }

        else if (mDNSPlatformValidRecordForInterface(v100, v101, a3, (uint64_t)a4, a5, a6, a7, a8))
        {
          goto LABEL_188;
        }
      }

      uint64_t v100 = *(void *)v100;
      if (!v100) {
        goto LABEL_190;
      }
      continue;
    }
  }

LABEL_294:
              uint64_t v158 = *(void *)v110;
              if (*(void *)v110)
              {
                while (!*(_BYTE *)(v158 + 16))
                {
                  uint64_t v158 = *(void *)v158;
                  if (!v158) {
                    goto LABEL_290;
                  }
                }

                uint64_t v158 = *(void *)(v158 + 6256);
              }

LABEL_292:
      uint64_t v113 = *(void *)v113;
      if (v113) {
        continue;
      }
      break;
    }

    uint64_t v159 = *(void *)(v109 + 12624);
    unint64_t v160 = v115;
    if (v159)
    {
      while (2)
      {
        if (*(void *)(v159 + 216) == *(void *)(v110 + 6256) && ResourceRecordIsValidAnswer(v159))
        {
          if (*v306) {
            goto LABEL_309;
          }
          if ((*(_BYTE *)(v159 + 8) & 0x32) != 0 && (uint64_t v177 = *(void *)(v109 + 12624)) != 0)
          {
            while (*(_DWORD *)(v177 + 288) != *v296
                 || *(void *)(v177 + 296) != *(void *)(v110 + 6256)
                 || *(unsigned __int16 *)(v177 + 12) != *(unsigned __int16 *)(v159 + 12)
                 || !SameResourceRecordNameClassInterface(v177, v159, a3, (uint64_t)a4, a5, a6, a7, a8))
            {
              uint64_t v177 = *(void *)v177;
              if (!v177) {
                goto LABEL_339;
              }
            }

LABEL_371:
            if (v179 || *(void *)(v178 + 200) == -1LL)
            {
              *(void *)(v178 + 200) = 0LL;
              unint64_t v197 = *(void **)v178;
              if (*(void *)v178)
              {
                do
                {
                  if (SameResourceRecordNameClassInterface((uint64_t)v197, v178, a3, (uint64_t)a4, a5, a6, a7, a8))
                  {
                    uint64_t v198 = v197[25];
                    if (v198 == -1 || v198 == *(void *)(v110 + 6256)) {
                      v197[25] = 0LL;
                    }
                  }

                  unint64_t v197 = (void *)*v197;
                }

                while (v197);
              }
            }
          }

          uint64_t v178 = *(void *)v178;
          if (!v178) {
            break;
          }
          continue;
        }
      }
    }

LABEL_423:
    if (!*v306 && !*v295)
    {
      do
        uint64_t v110 = *(void *)v110;
      while (v110 && !*(_BYTE *)(v110 + 16));
      int v300 = 0;
      goto LABEL_496;
    }

    int v237 = (void **)v307;
    if (!v291 && !v292 && !v307) {
      goto LABEL_486;
    }
    uint64_t v238 = (char *)v115;
    bzero(v322, 0x498uLL);
    v322[8] = 32;
    strcpy((char *)&v322[12], ")");
    unsigned int v323 = 4500;
    v357[0] = 264;
    uint64_t v327 = v356;
    uint64_t v328 = v357;
    char v336 = 0;
    char v337 = 0;
    __int128 v329 = 0u;
    __int128 v330 = 0u;
    __int128 v331 = 0u;
    __int128 v332 = 0u;
    __int128 v333 = 0u;
    __int128 v334 = 0u;
    uint64_t v335 = 0LL;
    unsigned int v338 = v356;
    __int16 v352 = 0;
    uint64_t v354 = 0LL;
    uint64_t v355 = 0LL;
    uint64_t v353 = 0LL;
    v356[0] = 0;
    __int128 v339 = 0u;
    __int128 v340 = 0u;
    __int128 v341 = 0u;
    __int128 v342 = 0u;
    __int128 v343 = 0u;
    __int128 v344 = 0u;
    __int128 v345 = 0u;
    __int128 v346 = 0u;
    __int128 v347 = 0u;
    __int128 v348 = 0u;
    __int128 v349 = 0u;
    __int128 v350 = 0u;
    memset(v351, 0, sizeof(v351));
    *(_WORD *)&v322[14] = 1440;
    *(_WORD *)&v324[2] = 0;
    if (v291)
    {
      *(_DWORD *)int v324 = 1572888;
      SetupOwnerOpt(v109, v110, (uint64_t)v358);
      unsigned int v241 = 1;
      if (v292) {
        goto LABEL_430;
      }
    }

    else
    {
      unsigned int v241 = 0;
      if (v292)
      {
LABEL_430:
        *(_WORD *)v324 += 24;
        *(_WORD *)&v324[2] += 24;
        uint64_t v242 = &v328[12 * v241++];
        *((_BYTE *)v242 + 8) = *(_BYTE *)(a1 + 12684);
        *((_DWORD *)v242 + 3) = -1735907257;
        *((_DWORD *)v242 + 1) = 392681;
      }
    }

    if (v237)
    {
      *(_WORD *)v324 += 24;
      *(_WORD *)&v324[2] += 24;
      uint64_t v243 = (int *)v237[1];
      BOOL v244 = &v328[12 * v241];
      *((_DWORD *)v244 + 3) = v243[1];
      v244[8] = *((_WORD *)v243 + 4);
      int v245 = *v243;
      *((_DWORD *)v244 + 1) = 720362;
      *((_DWORD *)v244 + 2) = v245;
      uint64_t v307 = *v237;
      free(v237);
    }

    if (*v306 || *(_WORD *)(a1 + 28912) || *v295) {
      uint64_t v246 = 1440LL;
    }
    else {
      uint64_t v246 = 8940LL;
    }
    a4 = (char *)PutResourceRecordTTLWithLimit( (unint64_t)v304,  v115,  v295,  (uint64_t)&v322[8],  v323,  v303 + v246,  v239,  v240);
    if (a4 && v307) {
      a4 = AddTSRROptsToMessage(&v307, (unint64_t)v304, (_WORD *)(v115 + 9), a4, a1 + 37856, a6, a7, a8);
    }
    if (a4) {
      goto LABEL_485;
    }
    int v247 = *(unsigned __int16 *)(a1 + 28910);
    int v248 = *(unsigned __int16 *)(a1 + 28912);
    int v249 = *(unsigned __int16 *)(a1 + 28914);
    char v250 = gSensitiveLoggingEnabled;
    uint64_t v251 = mDNSLogCategory_mDNS;
    if (mDNSLogCategory_mDNS == mDNSLogCategory_State) {
      char v250 = 0;
    }
    if (v248 + v247 + v249 != 1)
    {
      if ((v250 & 1) != 0)
      {
        uint64_t v258 = mDNSLogCategory_mDNS_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_ERROR)) {
          goto LABEL_484;
        }
        if (v291) {
          int v259 = "OWNER";
        }
        else {
          int v259 = "";
        }
        if (v292) {
          int v260 = "TRACER";
        }
        else {
          int v260 = "";
        }
        int v261 = *(unsigned __int16 *)(a1 + 28908);
        GetRRDisplayString_rdb(&v322[8], v328 + 2, v290);
        *(_DWORD *)buf = 136316930;
        *(void *)int v309 = v259;
        *(_WORD *)&v309[8] = 2080;
        *(void *)&v309[10] = v260;
        uint64_t v109 = a1;
        __int16 v310 = 1024;
        int v311 = (unsigned __int16)v305;
        __int16 v312 = 1024;
        int v313 = v261;
        __int16 v314 = 1024;
        int v315 = v247;
        __int16 v316 = 1024;
        int v317 = v248;
        __int16 v318 = 1024;
        int v319 = v249;
        __int16 v320 = 2080;
        uint64_t v321 = a1 + 46976;
        unint64_t v256 = (os_log_s *)v258;
        uint64_t v257 = "SendResponses: How did we fail to have space for %s %s TSR(%d) OPT record (%d/%d/%d/%d) %s";
      }

      else
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_ERROR)) {
          goto LABEL_484;
        }
        if (v291) {
          unint64_t v265 = "OWNER";
        }
        else {
          unint64_t v265 = "";
        }
        if (v292) {
          unsigned int v266 = "TRACER";
        }
        else {
          unsigned int v266 = "";
        }
        int v267 = *(unsigned __int16 *)(a1 + 28908);
        GetRRDisplayString_rdb(&v322[8], v328 + 2, v290);
        *(_DWORD *)buf = 136316930;
        *(void *)int v309 = v265;
        *(_WORD *)&v309[8] = 2080;
        *(void *)&v309[10] = v266;
        __int16 v310 = 1024;
        int v311 = (unsigned __int16)v305;
        uint64_t v109 = a1;
        __int16 v312 = 1024;
        int v313 = v267;
        __int16 v314 = 1024;
        int v315 = v247;
        __int16 v316 = 1024;
        int v317 = v248;
        __int16 v318 = 1024;
        int v319 = v249;
        __int16 v320 = 2080;
        uint64_t v321 = a1 + 46976;
        unint64_t v256 = (os_log_s *)v251;
        uint64_t v257 = "SendResponses: How did we fail to have space for %s %s TSR(%d) OPT record (%d/%d/%d/%d) %s";
      }

      goto LABEL_483;
    }

    if ((v250 & 1) == 0)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_ERROR)) {
        goto LABEL_484;
      }
      if (v291) {
        int v262 = "OWNER";
      }
      else {
        int v262 = "";
      }
      if (v292) {
        int v263 = "TRACER";
      }
      else {
        int v263 = "";
      }
      int v264 = *(unsigned __int16 *)(a1 + 28908);
      GetRRDisplayString_rdb(&v322[8], v328 + 2, v290);
      *(_DWORD *)buf = 136316930;
      *(void *)int v309 = v262;
      *(_WORD *)&v309[8] = 2080;
      *(void *)&v309[10] = v263;
      __int16 v310 = 1024;
      int v311 = (unsigned __int16)v305;
      uint64_t v109 = a1;
      __int16 v312 = 1024;
      int v313 = v264;
      __int16 v314 = 1024;
      int v315 = v247;
      __int16 v316 = 1024;
      int v317 = v248;
      __int16 v318 = 1024;
      int v319 = v249;
      __int16 v320 = 2080;
      uint64_t v321 = a1 + 46976;
      unint64_t v256 = (os_log_s *)v251;
      uint64_t v257 = "SendResponses: No space in packet for %s %s TSR(%d) OPT record (%d/%d/%d/%d) %s";
LABEL_483:
      _os_log_impl((void *)&_mh_execute_header, v256, OS_LOG_TYPE_ERROR, v257, buf, 0x3Eu);
      goto LABEL_484;
    }

    uint64_t v252 = mDNSLogCategory_mDNS_redacted;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_ERROR))
    {
      if (v291) {
        int v253 = "OWNER";
      }
      else {
        int v253 = "";
      }
      if (v292) {
        uint64_t v254 = "TRACER";
      }
      else {
        uint64_t v254 = "";
      }
      int v255 = *(unsigned __int16 *)(a1 + 28908);
      GetRRDisplayString_rdb(&v322[8], v328 + 2, v290);
      *(_DWORD *)buf = 136316930;
      *(void *)int v309 = v253;
      *(_WORD *)&v309[8] = 2080;
      *(void *)&v309[10] = v254;
      uint64_t v109 = a1;
      __int16 v310 = 1024;
      int v311 = (unsigned __int16)v305;
      __int16 v312 = 1024;
      int v313 = v255;
      __int16 v314 = 1024;
      int v315 = v247;
      __int16 v316 = 1024;
      int v317 = v248;
      __int16 v318 = 1024;
      int v319 = v249;
      __int16 v320 = 2080;
      uint64_t v321 = a1 + 46976;
      unint64_t v256 = (os_log_s *)v252;
      uint64_t v257 = "SendResponses: No space in packet for %s %s TSR(%d) OPT record (%d/%d/%d/%d) %s";
      goto LABEL_483;
    }

    a4 = v43;
    if (!v45) {
      goto LABEL_470;
    }
    __int16 v228 = v45;
    goto LABEL_469;
  }

  if (v11) {
    uint64_t v55 = (os_log_s *)mDNSLogCategory_Default;
  }
  else {
    uint64_t v55 = (os_log_s *)mDNSLogCategory_mDNS;
  }
  if (gSensitiveLoggingEnabled != 1 || v55 == (os_log_s *)mDNSLogCategory_State)
  {
    if (!os_log_type_enabled(v55, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_470;
    }
    goto LABEL_122;
  }

  if (v11) {
    uint64_t v55 = (os_log_s *)mDNSLogCategory_Default_redacted;
  }
  else {
    uint64_t v55 = (os_log_s *)mDNSLogCategory_mDNS;
  }
  if (os_log_type_enabled(v55, OS_LOG_TYPE_DEFAULT))
  {
LABEL_122:
    uint64_t v96 = *(_DWORD *)(v369 + 184);
    uint64_t v97 = *(unsigned __int16 *)(a3 + 4);
    LODWORD(__tp.tv_sec) = 67110656;
    HIDWORD(__tp.tv_sec) = v96;
    LOWORD(__tp.tv_nsec) = 1024;
    *(_DWORD *)((char *)&__tp.tv_nsec + 2) = __rev16(v23);
    HIWORD(__tp.tv_nsec) = 1024;
    *(_DWORD *)uint64_t v376 = a4;
    *(_WORD *)&v376[4] = 1024;
    *(_DWORD *)&v376[6] = 0;
    LOWORD(v377) = 1024;
    *(_DWORD *)((char *)&v377 + 2) = v366;
    HIWORD(v377) = 1024;
    *(_DWORD *)uint64_t v378 = HIDWORD(v366);
    *(_WORD *)&v378[4] = 1024;
    *(_DWORD *)&v378[6] = v97;
    uint64_t v98 = "[R%u->Q%u] DNSServiceResolve result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %d, name hash"
          ": %x, type: %{mdns:rrtype}d, rdata: <none>";
    __int16 v99 = v55;
    uint64_t v100 = 44;
LABEL_418:
    _os_log_impl((void *)&_mh_execute_header, v99, OS_LOG_TYPE_DEFAULT, v98, (uint8_t *)&__tp, v100);
  }

LABEL_484:
    a4 = v238;
    uint64_t v110 = v299;
LABEL_485:
    unint64_t v115 = (unint64_t)a4;
LABEL_486:
    if (*(_BYTE *)(v110 + 17)) {
      mDNSSendDNSMessage( v109,  (unint64_t)v304,  v115,  *(void *)(v110 + 6256),  0LL,  0LL,  AllDNSLinkGroup_v4,  0xE914u,  0LL,  0);
    }
    if (*(_BYTE *)(v110 + 18)) {
      mDNSSendDNSMessage( v109,  (unint64_t)v304,  v115,  *(void *)(v110 + 6256),  0LL,  0LL,  &AllDNSLinkGroup_v6,  0xE914u,  0LL,  0);
    }
    if (!*(_DWORD *)(v109 + 84) && !*(_DWORD *)(v109 + 76))
    {
      unsigned int v268 = *(_DWORD *)(v109 + 64) + 100;
      if (v268 <= 1) {
        unsigned int v268 = 1;
      }
      *(_DWORD *)(v109 + 84) = v268;
    }

    if (++v300 >= 1000)
    {
      LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "SendResponses exceeded loop limit %d: giving up",  (uint64_t)a4,  a5,  a6,  a7,  a8,  v300);
      break;
    }

LABEL_496:
    int v269 = v307;
    if (v307)
    {
      do
      {
        uint32_t v270 = (void *)*v269;
        free(v269);
        int v269 = v270;
      }

      while (v270);
    }

    if (v110) {
      continue;
    }
    break;
  }

void AnswerAllLocalQuestionsWithLocalAuthRecord( void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v11 = a1[27];
  if (v11)
  {
    uint64_t v12 = (os_log_s *)mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_28;
      }
      uint64_t v14 = (_BYTE *)(v11 + 356);
      if (v11 == -612)
      {
LABEL_10:
        while (v14)
        {
          uint64_t v15 = *v14;
          if (!*v14)
          {
            int v19 = (unsigned __int16)((_WORD)v14 - (v11 + 356) + 1);
            goto LABEL_27;
          }

          v14 += v15 + 1;
          if (v11 != -612) {
            goto LABEL_9;
          }
        }
      }

      else
      {
LABEL_9:
      }

      int v19 = 257;
      goto LABEL_27;
    }

    uint64_t v12 = (os_log_s *)mDNSLogCategory_Default_redacted;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v17 = (_BYTE *)(v11 + 356);
      if (v11 == -612)
      {
LABEL_18:
        while (v17)
        {
          uint64_t v18 = *v17;
          if (!*v17)
          {
            int v19 = (unsigned __int16)((_WORD)v17 - (v11 + 356) + 1);
            goto LABEL_27;
          }

          v17 += v18 + 1;
          if (v11 != -612) {
            goto LABEL_17;
          }
        }
      }

      else
      {
LABEL_17:
      }

      int v19 = 257;
LABEL_27:
      uint64_t v20 = DNSTypeName(*(unsigned __int16 *)(v11 + 322));
      int v25 = 141558787;
      uint64_t v26 = 1752392040LL;
      __int16 v27 = 1040;
      int v28 = v19;
      __int16 v29 = 2101;
      uint64_t v30 = v11 + 356;
      __int16 v31 = 2082;
      uint64_t v32 = v20;
      _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEFAULT,  "AnswerAllLocalQuestionsWithLocalAuthRecord ERROR m->CurrentQuestion already set: %{sensitive, mask.hash, mdnsres ponder:domain_name}.*P (%{public}s)",  (uint8_t *)&v25,  0x26u);
    }
  }

LABEL_28:
  uint64_t v21 = a1[28];
  a1[27] = v21;
  if (v21)
  {
    while (1)
    {
      if (v21 == a1[29]) {
        goto LABEL_38;
      }
      if (*(_DWORD *)(a2 + 172) <= 3u) {
        break;
      }
      if (LocalOnlyRecordAnswersQuestion(a2, v21, a3, a4, a5, a6, a7, a8)) {
        goto LABEL_34;
      }
LABEL_35:
      uint64_t v22 = a1[27];
      if (v22 == v21)
      {
        uint64_t v22 = *(void *)(v21 + 8);
        a1[27] = v22;
      }

      uint64_t v21 = v22;
      if (!v22) {
        goto LABEL_38;
      }
    }

    if (!RecordAnswersQuestion(a2 + 8, 1, v21, a4, a5, a6, a7, a8)) {
      goto LABEL_35;
    }
LABEL_34:
    AnswerLocalQuestionWithLocalAuthRecord((uint64_t)a1, a2, a3);
    goto LABEL_35;
  }

      uint64_t v11 = *(void *)v11;
      if (!v11) {
        goto LABEL_29;
      }
    }
  }

  return result;
}

                if (*a3 == 240
                  && (uint64_t v22 = *((void *)a3 + 7)) != 0
                  && *(_DWORD *)(v22 + 32) == 1
                  && dnssec_obj_resource_record_member_get_validation_result(v22) == 1)
                {
                  if (*((_WORD *)a3 + 2) == 43)
                  {
                    if (a4 != 1)
                    {
                      *(void *)(v18 + 48) = 0xFFFFE5C200000000LL;
                      _dnssec_obj_validation_manager_reset_validation_key_requestor(v18);
                      _dnssec_obj_validation_manager_reset_insecure_validation(v18);
                      goto LABEL_110;
                    }

                    if (resource_record_get_insecure_validation_usable(a3))
                    {
                      uint64_t v23 = (os_log_s *)mDNSLogCategory_DNSSEC;
                      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_DNSSEC == mDNSLogCategory_State)
                      {
                        if (os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC, OS_LOG_TYPE_INFO))
                        {
                          uint64_t v24 = *(unsigned __int16 *)(v18 + 24);
                          int v25 = bswap32(*(unsigned __int16 *)(*(void *)(v18 + 80) + 320LL)) >> 16;
                          uint64_t v26 = *((void *)a3 + 4);
                          if (v26)
                          {
                            unint64_t v34 = (_BYTE *)*((void *)a3 + 4);
                            if (v26 == -256)
                            {
LABEL_64:
                              while (v34)
                              {
                                int v35 = *v34;
                                if (!*v34)
                                {
                                  uint64_t v40 = (unsigned __int16)((_WORD)v34 - v26 + 1);
                                  goto LABEL_105;
                                }

                                v34 += v35 + 1;
                                if (v26 != -256) {
                                  goto LABEL_63;
                                }
                              }
                            }

                            else
                            {
LABEL_63:
                            }

                            uint64_t v40 = 257;
                          }

                          else
                          {
                            uint64_t v40 = 0;
                          }

                          goto LABEL_105;
                        }
                      }

                      else
                      {
                        uint64_t v23 = (os_log_s *)mDNSLogCategory_DNSSEC_redacted;
                        if (os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC_redacted, OS_LOG_TYPE_INFO))
                        {
                          uint64_t v24 = *(unsigned __int16 *)(v18 + 24);
                          int v25 = bswap32(*(unsigned __int16 *)(*(void *)(v18 + 80) + 320LL)) >> 16;
                          uint64_t v26 = *((void *)a3 + 4);
                          if (v26)
                          {
                            __int16 v27 = (_BYTE *)*((void *)a3 + 4);
                            if (v26 == -256)
                            {
LABEL_41:
                              while (v27)
                              {
                                int v28 = *v27;
                                if (!*v27)
                                {
                                  uint64_t v40 = (unsigned __int16)((_WORD)v27 - v26 + 1);
                                  goto LABEL_105;
                                }

                                v27 += v28 + 1;
                                if (v26 != -256) {
                                  goto LABEL_40;
                                }
                              }
                            }

                            else
                            {
LABEL_40:
                            }

                            uint64_t v40 = 257;
                          }

                          else
                          {
                            uint64_t v40 = 0;
                          }

void *read_rr_from_ipc_msg(uint64_t a1, int a2, int a3)
{
  uint64_t v6 = *(unsigned int **)(a1 + 72);
  unint64_t v7 = *(void *)(a1 + 80);
  uint64_t v8 = v6 + 1;
  if (v6) {
    BOOL v9 = (unint64_t)v8 > v7;
  }
  else {
    BOOL v9 = 1;
  }
  if (v9)
  {
    unsigned int v10 = 0;
LABEL_12:
    *(void *)(a1 + 72) = 0LL;
    bzero(&v89, 0x3F0uLL);
    LODWORD(v26) = 0;
LABEL_13:
    char v13 = 0;
    LOWORD(v14) = 0;
    unsigned int v15 = 0;
    uint64_t v16 = 0LL;
    uint64_t v17 = 0LL;
    unsigned __int8 v88 = 0;
    goto LABEL_14;
  }

  uint64_t v11 = (unsigned __int8 *)(v6 + 2);
  unsigned int v10 = bswap32(*v6);
  *(void *)(a1 + 72) = v8;
  LODWORD(v26) = bswap32(v6[1]);
  *(void *)(a1 + 72) = v11;
  __int16 v27 = &v88;
  bzero(&v88, 0x3F1uLL);
  if (!v11) {
    goto LABEL_13;
  }
  do
  {
    if ((unint64_t)v11 >= v7 || v27 >= v90)
    {
      char v13 = 0;
      LOWORD(v14) = 0;
      unsigned int v15 = 0;
      uint64_t v16 = 0LL;
      uint64_t v17 = 0LL;
      v27[-(v27 == v90)] = 0;
      *(void *)(a1 + 72) = 0LL;
      goto LABEL_14;
    }

    int v35 = (unsigned __int16 *)(v11 + 1);
    *(void *)(a1 + 72) = v11 + 1;
    int v36 = *v11;
    *v27++ = v36;
    ++v11;
  }

  while (v36);
  uint64_t v16 = 0LL;
  LOWORD(v14) = 0;
  char v13 = 1;
  if (!v35 || (unint64_t)(v35 + 1) > v7)
  {
    unsigned int v15 = 0;
LABEL_100:
    uint64_t v17 = 0LL;
    goto LABEL_14;
  }

  uint64_t v16 = 0LL;
  LOWORD(v14) = 0;
  uint64_t v37 = v35 + 2;
  unsigned int v15 = bswap32(*v35) >> 16;
  *(void *)(a1 + 72) = v35 + 1;
  char v13 = 1;
  uint64_t v17 = 0LL;
  uint64_t v16 = 0LL;
  unsigned int v14 = bswap32(v35[1]) >> 16;
  *(void *)(a1 + 72) = v37;
  char v13 = 1;
  if (v35 != (unsigned __int16 *)-4LL && (unint64_t)(v35 + 3) <= v7)
  {
    uint64_t v17 = bswap32(v35[2]) >> 16;
    char v13 = 1;
    uint64_t v16 = (unsigned __int8 *)(v35 + 3);
  }

LABEL_127:
        *(_DWORD *)buf = 67110147;
        int v79 = v68;
        __int16 v80 = 2160;
        uint64_t v81 = 1752392040LL;
        __int16 v82 = 1040;
        int v83 = v75;
        __int16 v84 = 2101;
        uint64_t v85 = v69;
        __int16 v86 = 2082;
        uint64_t v87 = DNSTypeName(v71);
        _os_log_impl( (void *)&_mh_execute_header,  v67,  OS_LOG_TYPE_ERROR,  "[R%u] read_rr_from_ipc_msg: SetRData failed for %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%{public}s)",  buf,  0x2Cu);
      }
    }

void regrecord_callback( uint64_t a1, uint64_t a2, unsigned int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v11 = *(void *)(a2 + 112);
  if (!v11)
  {
    if (a3 != -65792)
    {
      if (!a3)
      {
        uint64_t v23 = mDNSLogCategory_mDNS;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
        {
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
            return;
          }
        }

        else
        {
          uint64_t v23 = mDNSLogCategory_mDNS_redacted;
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
            return;
          }
        }

        GetRRDisplayString_rdb( (unsigned __int8 *)(a2 + 8),  (unsigned __int16 *)(*(void *)(a2 + 48) + 4LL),  (_BYTE *)(a1 + 46976));
        *(_DWORD *)buf = 141558275;
        *(void *)uint64_t v162 = 1752392040LL;
        *(_WORD *)&v162[8] = 2085;
        uint64_t v163 = a1 + 46976;
        uint64_t v33 = "Error: regrecord_callback: successful registration of orphaned record %{sensitive, mask.hash}s";
        uint64_t v34 = (os_log_s *)v23;
        uint32_t v35 = 22;
LABEL_176:
        _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, v33, buf, v35);
        return;
      }

      int v25 = (os_log_s *)mDNSLogCategory_mDNS;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
      {
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 67109120;
          *(_DWORD *)uint64_t v162 = a3;
LABEL_37:
          _os_log_impl( (void *)&_mh_execute_header,  v25,  OS_LOG_TYPE_DEFAULT,  "regrecord_callback: error %d received after parent termination",  buf,  8u);
        }
      }

      else
      {
        int v25 = (os_log_s *)mDNSLogCategory_mDNS_redacted;
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 67109120;
          *(_DWORD *)uint64_t v162 = a3;
          goto LABEL_37;
        }
      }
    }

    uint64_t v37 = *(void **)(a2 + 48);
    uint64_t v39 = (void *)a2;
    goto LABEL_158;
  }

  uint64_t v12 = *(_DWORD **)(v11 + 16);
  if (mDNS_LoggingEnabled != 1) {
    goto LABEL_141;
  }
  uint64_t v13 = *(void *)(a2 + 32);
  uint64_t v14 = v13 + 5;
  int v15 = mDNS_DomainNameFNV1aHash(*(unsigned __int8 **)(a2 + 40));
  BOOL shouldLogFullRequestInfo = _shouldLogFullRequestInfo((int *)(v11 + 48), (_DWORD *)(v11 + 52));
  size_t v20 = *(unsigned __int16 *)(a2 + 20);
  if (shouldLogFullRequestInfo)
  {
    if (v20 >= 0x201)
    {
      int v157 = v15;
      uint64_t v21 = (char *)malloc(v20);
      unsigned int v22 = v21;
      if (!v21) {
        goto LABEL_198;
      }
LABEL_30:
      int v160 = 0;
      unsigned __int16 v159 = 0;
      uint64_t RDataBytesPointer = ResourceRecordGetRDataBytesPointer(a2 + 8, v22, v20, &v159, &v160, v17, v18, v19);
      if (!v160)
      {
        uint64_t v29 = (const void *)RDataBytesPointer;
        size_t v30 = v159;
        if (v159 < 0x1FFuLL)
        {
          unsigned int v150 = 512;
          uint64_t v156 = 0LL;
          uint64_t v31 = word_100164338;
          goto LABEL_63;
        }

        uint64_t v31 = (__int16 *)malloc(v159 + 2LL);
        if (v31)
        {
          unsigned int v150 = v30 + 2;
          uint64_t v156 = v31;
LABEL_63:
          uint64_t v148 = v31;
          uint64_t v52 = mDNSLogCategory_mDNS;
          if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
          {
            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_137;
            }
            uint64_t v58 = *(void *)(a2 + 40);
            if (v58)
            {
              uint64_t v59 = *(_BYTE **)(a2 + 40);
              if (v58 == -256) {
                goto LABEL_82;
              }
LABEL_79:
              unsigned __int16 v60 = 257;
              if ((unint64_t)v59 < v58 + 256 && v59)
              {
                while (1)
                {
                  uint64_t v61 = *v59;
                  if (v61 > 0x3F)
                  {
LABEL_120:
                    unsigned __int16 v60 = 257;
                    goto LABEL_130;
                  }

                  if (!*v59) {
                    break;
                  }
                  v59 += v61 + 1;
                  if (v58 != -256) {
                    goto LABEL_79;
                  }
LABEL_82:
                  if (!v59) {
                    goto LABEL_120;
                  }
                }

                unsigned __int16 v60 = (_WORD)v59 - v58 + 1;
              }

LABEL_130:
              int v79 = v60;
            }

            else
            {
              int v79 = 0;
            }

            int v101 = v12[46];
            int v102 = *(_DWORD *)(v11 + 56);
            unsigned int v103 = *(unsigned __int16 *)(a2 + 12);
            int v104 = v30 + 2;
            if ((int)v30 + 2 <= v150)
            {
              *uint64_t v148 = __rev16(v103);
              size_t v106 = v30;
              int v107 = v29;
              uint64_t v147 = v58;
              int v141 = v79;
              int v155 = v30 + 2;
              unsigned int v108 = v103;
              int v143 = v102;
              int v109 = v101;
              memcpy(v148 + 1, v107, v106);
              int v101 = v109;
              int v102 = v143;
              unsigned int v103 = v108;
              int v104 = v155;
              int v79 = v141;
              uint64_t v58 = v147;
              uint64_t v105 = v148;
            }

            else
            {
              uint64_t v105 = 0LL;
            }

            *(_DWORD *)buf = 67111939;
            *(_DWORD *)uint64_t v162 = v101;
            *(_WORD *)&v162[4] = 1024;
            *(_DWORD *)&v162[6] = v102;
            LOWORD(v163) = 1026;
            *(_DWORD *)((char *)&v163 + 2) = a3;
            HIWORD(v163) = 1024;
            int v164 = v13;
            __int16 v165 = 2160;
            *(void *)uint64_t v166 = 1752392040LL;
            *(_WORD *)&v166[8] = 1040;
            LODWORD(v167) = v79;
            WORD2(v167) = 2101;
            *(void *)((char *)&v167 + 6) = v58;
            HIWORD(v167) = 1024;
            *(_DWORD *)int v168 = v157;
            *(_WORD *)&v168[4] = 1024;
            *(_DWORD *)&v168[6] = v103;
            __int16 v169 = 2160;
            uint64_t v170 = 1752392040LL;
            __int16 v171 = 1040;
            int v172 = v104;
            __int16 v173 = 2101;
            __int16 v174 = v105;
            unsigned __int8 v88 = "[R%u->Rec%u] DNSServiceRegisterRecord Result -- event: %{public, mdnsresponder:reg_result}d, ifindex: "
                  "%d, name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P(%x), type: %{mdns:rrtype}d, rdata: %{s"
                  "ensitive, mask.hash, mdns:rdata}.*P";
            uint64_t v89 = (os_log_s *)v52;
          }

          else
          {
            uint64_t v53 = mDNSLogCategory_mDNS_redacted;
            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_137;
            }
            uint64_t v54 = *(void *)(a2 + 40);
            uint64_t v144 = (os_log_s *)v53;
            if (v54)
            {
              uint64_t v55 = *(_BYTE **)(a2 + 40);
              if (v54 == -256) {
                goto LABEL_71;
              }
LABEL_68:
              unsigned __int16 v56 = 257;
              if ((unint64_t)v55 < v54 + 256 && v55)
              {
                while (1)
                {
                  uint64_t v57 = *v55;
                  if (v57 > 0x3F)
                  {
LABEL_119:
                    unsigned __int16 v56 = 257;
                    goto LABEL_124;
                  }

                  if (!*v55) {
                    break;
                  }
                  v55 += v57 + 1;
                  if (v54 != -256) {
                    goto LABEL_68;
                  }
LABEL_71:
                  if (!v55) {
                    goto LABEL_119;
                  }
                }

                unsigned __int16 v56 = (_WORD)v55 - v54 + 1;
              }

        uint64_t v65 = v59;
      }

      else
      {
        uint64_t v65 = 0;
      }

LABEL_124:
              int v78 = v56;
            }

            else
            {
              int v78 = 0;
            }

            int v92 = v12[46];
            int v93 = *(_DWORD *)(v11 + 56);
            unsigned int v94 = *(unsigned __int16 *)(a2 + 12);
            int v95 = v30 + 2;
            if ((int)v30 + 2 <= v150)
            {
              *uint64_t v148 = __rev16(v94);
              uint64_t v97 = v29;
              size_t v98 = v30;
              uint64_t v140 = v54;
              int v99 = v78;
              unsigned int v154 = v94;
              int v142 = v93;
              int v100 = v92;
              memcpy(v148 + 1, v97, v98);
              int v92 = v100;
              int v93 = v142;
              unsigned int v94 = v154;
              int v78 = v99;
              uint64_t v54 = v140;
              uint64_t v96 = v148;
            }

            else
            {
              uint64_t v96 = 0LL;
            }

            *(_DWORD *)buf = 67111939;
            *(_DWORD *)uint64_t v162 = v92;
            *(_WORD *)&v162[4] = 1024;
            *(_DWORD *)&v162[6] = v93;
            LOWORD(v163) = 1026;
            *(_DWORD *)((char *)&v163 + 2) = a3;
            HIWORD(v163) = 1024;
            int v164 = v13;
            __int16 v165 = 2160;
            *(void *)uint64_t v166 = 1752392040LL;
            *(_WORD *)&v166[8] = 1040;
            LODWORD(v167) = v78;
            WORD2(v167) = 2101;
            *(void *)((char *)&v167 + 6) = v54;
            HIWORD(v167) = 1024;
            *(_DWORD *)int v168 = v157;
            *(_WORD *)&v168[4] = 1024;
            *(_DWORD *)&v168[6] = v94;
            __int16 v169 = 2160;
            uint64_t v170 = 1752392040LL;
            __int16 v171 = 1040;
            int v172 = v95;
            __int16 v173 = 2101;
            __int16 v174 = v96;
            unsigned __int8 v88 = "[R%u->Rec%u] DNSServiceRegisterRecord Result -- event: %{public, mdnsresponder:reg_result}d, ifindex: "
                  "%d, name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P(%x), type: %{mdns:rrtype}d, rdata: %{s"
                  "ensitive, mask.hash, mdns:rdata}.*P";
            uint64_t v89 = v144;
          }

          uint32_t v90 = 90;
          goto LABEL_136;
        }

LABEL_193:
        int v91 = v50;
      }

      else
      {
        int v91 = 0;
      }
    }

    int v139 = *(unsigned __int16 *)(a2 + 12);
    *(_DWORD *)buf = 67111171;
    *(_DWORD *)uint64_t v162 = v46;
    *(_WORD *)&v162[4] = 1024;
    *(_DWORD *)&v162[6] = v47;
    LOWORD(v163) = 1026;
    *(_DWORD *)((char *)&v163 + 2) = a3;
    HIWORD(v163) = 1024;
    int v164 = v13;
    __int16 v165 = 2160;
    *(void *)uint64_t v166 = 1752392040LL;
    *(_WORD *)&v166[8] = 1040;
    LODWORD(v167) = v91;
    WORD2(v167) = 2101;
    *(void *)((char *)&v167 + 6) = v48;
    HIWORD(v167) = 1024;
    *(_DWORD *)int v168 = v15;
    *(_WORD *)&v168[4] = 1024;
    *(_DWORD *)&v168[6] = v139;
    int v75 = "[R%u->Rec%u] DNSServiceRegisterRecord Result -- event: %{public, mdnsresponder:reg_result}d, ifindex: %d, name"
          ": %{sensitive, mask.hash, mdnsresponder:domain_name}.*P(%x), type: %{mdns:rrtype}d, rdata: <none>";
    int v76 = (os_log_s *)v45;
    uint32_t v77 = 64;
LABEL_197:
    _os_log_impl((void *)&_mh_execute_header, v76, OS_LOG_TYPE_DEFAULT, v75, buf, v77);
    goto LABEL_141;
  }

  if (v20 >= 0x201)
  {
    uint64_t v21 = (char *)malloc(*(unsigned __int16 *)(a2 + 20));
    __int16 v27 = v21;
    if (!v21) {
      goto LABEL_198;
    }
  }

  else
  {
    if (!*(_WORD *)(a2 + 20))
    {
      uint64_t v62 = mDNSLogCategory_mDNS;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_141;
        }
      }

      else
      {
        uint64_t v62 = mDNSLogCategory_mDNS_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_141;
        }
      }

      int v72 = v12[46];
      int v73 = *(_DWORD *)(v11 + 56);
      int v74 = *(unsigned __int16 *)(a2 + 12);
      *(_DWORD *)buf = 67110400;
      *(_DWORD *)uint64_t v162 = v72;
      *(_WORD *)&v162[4] = 1024;
      *(_DWORD *)&v162[6] = v73;
      LOWORD(v163) = 1026;
      *(_DWORD *)((char *)&v163 + 2) = a3;
      HIWORD(v163) = 1024;
      int v164 = v13;
      __int16 v165 = 1024;
      *(_DWORD *)uint64_t v166 = v15;
      *(_WORD *)&v166[4] = 1024;
      *(_DWORD *)&v166[6] = v74;
      int v75 = "[R%u->Rec%u] DNSServiceRegisterRecord Result -- event: %{public, mdnsresponder:reg_result}d, ifindex: %d, na"
            "me hash: %x, type: %{mdns:rrtype}d, rdata: <none>";
      int v76 = (os_log_s *)v62;
      uint32_t v77 = 38;
      goto LABEL_197;
    }

    uint64_t v21 = 0LL;
    __int16 v27 = (char *)&unk_100164138;
    LODWORD(vmemset(v45, 0, 20) = 512;
  }

  int v160 = 0;
  unsigned __int16 v159 = 0;
  uint64_t v40 = ResourceRecordGetRDataBytesPointer(a2 + 8, v27, v20, &v159, &v160, v17, v18, v19);
  if (!v160)
  {
    BOOL v41 = (const void *)v40;
    int v158 = v15;
    size_t v42 = v159;
    if (v159 >= 0x1FFuLL)
    {
      int v44 = (__int16 *)malloc(v159 + 2LL);
      if (!v44) {
        goto LABEL_198;
      }
      unsigned int v151 = v42 + 2;
      int v43 = v44;
    }

    else
    {
      int v43 = 0LL;
      unsigned int v151 = 512;
      int v44 = word_100164338;
    }

    uint64_t v149 = v44;
    uint64_t v156 = v43;
    uint64_t v66 = mDNSLogCategory_mDNS;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_137;
      }
      int v67 = v12[46];
      int v68 = *(_DWORD *)(v11 + 56);
      unsigned int v69 = *(unsigned __int16 *)(a2 + 12);
      int v70 = v42 + 2;
      if ((int)v42 + 2 <= v151)
      {
        *uint64_t v149 = __rev16(v69);
        size_t v84 = v42;
        uint64_t v85 = v41;
        int v146 = v42 + 2;
        unsigned int v86 = v69;
        int v153 = v68;
        int v87 = v67;
        memcpy(v149 + 1, v85, v84);
        int v67 = v87;
        int v68 = v153;
        unsigned int v69 = v86;
        int v70 = v146;
        int v71 = v149;
      }

      else
      {
        int v71 = 0LL;
      }
    }

    else
    {
      uint64_t v66 = mDNSLogCategory_mDNS_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_137;
      }
      int v67 = v12[46];
      int v68 = *(_DWORD *)(v11 + 56);
      unsigned int v69 = *(unsigned __int16 *)(a2 + 12);
      int v70 = v42 + 2;
      if ((int)v42 + 2 <= v151)
      {
        *uint64_t v149 = __rev16(v69);
        __int16 v80 = v41;
        size_t v81 = v42;
        int v145 = v42 + 2;
        unsigned int v82 = v69;
        int v152 = v68;
        int v83 = v67;
        memcpy(v149 + 1, v80, v81);
        int v67 = v83;
        int v68 = v152;
        unsigned int v69 = v82;
        int v70 = v145;
        int v71 = v149;
      }

      else
      {
        int v71 = 0LL;
      }
    }

    *(_DWORD *)buf = 67111171;
    *(_DWORD *)uint64_t v162 = v67;
    *(_WORD *)&v162[4] = 1024;
    *(_DWORD *)&v162[6] = v68;
    LOWORD(v163) = 1026;
    *(_DWORD *)((char *)&v163 + 2) = a3;
    HIWORD(v163) = 1024;
    int v164 = v13;
    __int16 v165 = 1024;
    *(_DWORD *)uint64_t v166 = v158;
    *(_WORD *)&v166[4] = 1024;
    *(_DWORD *)&v166[6] = v69;
    LOWORD(v167) = 2160;
    *(void *)((char *)&v167 + 2) = 1752392040LL;
    WORD5(v167) = 1040;
    HIDWORD(v167) = v70;
    *(_WORD *)int v168 = 2101;
    *(void *)&v168[2] = v71;
    unsigned __int8 v88 = "[R%u->Rec%u] DNSServiceRegisterRecord Result -- event: %{public, mdnsresponder:reg_result}d, ifindex: %d, name"
          " hash: %x, type: %{mdns:rrtype}d, rdata: %{sensitive, mask.hash, mdns:rdata}.*P";
    uint64_t v89 = (os_log_s *)v66;
    uint32_t v90 = 64;
LABEL_136:
    _os_log_impl((void *)&_mh_execute_header, v89, OS_LOG_TYPE_DEFAULT, v88, buf, v90);
LABEL_137:
    if (v156) {
      free(v156);
    }
  }

        int v67 = buf;
        int v68 = (os_log_s *)v71;
        unsigned int v69 = OS_LOG_TYPE_ERROR;
        int v70 = 2;
        goto LABEL_152;
      }

      int v73 = xD2DParse(a5, (unsigned __int16)a6, a7, (unsigned __int16)a8, (char **)v125);
      if (v73)
      {
        int v74 = v73;
        int v75 = (os_log_s *)mDNSLogCategory_D2D;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_D2D == mDNSLogCategory_State)
        {
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D, OS_LOG_TYPE_ERROR)) {
            goto LABEL_235;
          }
          *(_DWORD *)buf = 67109120;
          *(_DWORD *)&uint8_t buf[4] = v74;
        }

        else
        {
          int v75 = (os_log_s *)mDNSLogCategory_D2D_redacted;
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D_redacted, OS_LOG_TYPE_ERROR)) {
            goto LABEL_235;
          }
          *(_DWORD *)buf = 67109120;
          *(_DWORD *)&uint8_t buf[4] = v74;
        }

        _os_log_impl( (void *)&_mh_execute_header,  v75,  OS_LOG_TYPE_ERROR,  "xD2DFindInList: xD2DParse failed - error: %d",  buf,  8u);
LABEL_235:
        PrintHelper((uint64_t)"xD2DFindInList", (uint64_t)a5, (unsigned __int16)a6, (uint64_t)a7, (unsigned __int16)a8);
        int v95 = *(void **)v125;
        if (!*(void *)v125) {
          goto LABEL_153;
        }
        goto LABEL_305;
      }

      if (v72)
      {
        int v79 = *(void *)v125;
        __int16 v80 = *(void *)v125 + 32LL;
        while (*(_DWORD *)(v79 + 48) != *(_DWORD *)(v72 + 48)
             || !resource_records_have_same_dnssec_rr_category( *(void *)(v79 + 88),  *(void *)(v72 + 88))
             || *(unsigned __int16 *)(v79 + 36) != *(unsigned __int16 *)(v72 + 36)
             || *(unsigned __int16 *)(v79 + 38) != *(unsigned __int16 *)(v72 + 38)
             || *(unsigned __int16 *)(v79 + 44) != *(unsigned __int16 *)(v72 + 44)
             || *(_DWORD *)(v79 + 52) != *(_DWORD *)(v72 + 52)
             || !SameRDataBody( v80,  (unsigned __int16 *)(*(void *)(v72 + 72) + 4LL),  (uint64_t (*)(uint64_t, unsigned __int16 *))SameDomainName)
             || !SameDomainNameBytes(*(_BYTE **)(v79 + 64), *(_BYTE **)(v72 + 64)))
        {
          int v72 = *(void *)v72;
          if (!v72) {
            goto LABEL_205;
          }
        }

        free((void *)v79);
        uint64_t v116 = (os_log_s *)mDNSLogCategory_D2D;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_D2D == mDNSLogCategory_State)
        {
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_D2D, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v117 = *(void *)(v72 + 64);
            if (v117)
            {
              uint64_t v120 = *(_BYTE **)(v72 + 64);
              if (v117 == -256)
              {
LABEL_325:
                while (v120)
                {
                  uint64_t v121 = *v120;
                  if (!*v120)
                  {
                    int v122 = (unsigned __int16)((_WORD)v120 - v117 + 1);
                    goto LABEL_336;
                  }

                  v120 += v121 + 1;
                  if (v117 != -256) {
                    goto LABEL_324;
                  }
                }
              }

              else
              {
LABEL_324:
              }

              int v122 = 257;
            }

            else
            {
              int v122 = 0;
            }

            goto LABEL_336;
          }
        }

        else
        {
          uint64_t v116 = (os_log_s *)mDNSLogCategory_D2D_redacted;
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_D2D_redacted, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v117 = *(void *)(v72 + 64);
            if (v117)
            {
              uint64_t v118 = *(_BYTE **)(v72 + 64);
              if (v117 == -256)
              {
LABEL_316:
                while (v118)
                {
                  uint64_t v119 = *v118;
                  if (!*v118)
                  {
                    int v122 = (unsigned __int16)((_WORD)v118 - v117 + 1);
                    goto LABEL_336;
                  }

                  v118 += v119 + 1;
                  if (v117 != -256) {
                    goto LABEL_315;
                  }
                }
              }

              else
              {
LABEL_315:
              }

              int v122 = 257;
            }

            else
            {
              int v122 = 0;
            }

      int v87 = DNSTypeName(*(unsigned __int16 *)(a2 + 322));
      uint32_t v90 = 67110147;
      int v91 = v45;
      int v92 = 2160;
      int v93 = 1752392040LL;
      unsigned int v94 = 1040;
      int v95 = v84;
      uint64_t v96 = 2101;
      uint64_t v97 = a2 + 356;
      size_t v98 = 2082;
      int v99 = v87;
      _os_log_impl( (void *)&_mh_execute_header,  v44,  OS_LOG_TYPE_DEFAULT,  "[R%u] QueryRecordOpCallback: Question %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%{public}s) answeri ng local with negative unicast response",  (uint8_t *)&v90,  0x2Cu);
LABEL_44:
      if ((_DWORD)a4 == 1)
      {
        uint64_t v33 = 0;
        *(_BYTE *)(v12 + 718) = 1;
        goto LABEL_144;
      }

      goto LABEL_123;
    }

    uint64_t v62 = (os_log_s *)mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v63 = *(_DWORD *)(v12 + 688);
        int v68 = (_BYTE *)(a2 + 356);
        if (a2 == -612)
        {
LABEL_127:
          while (v68)
          {
            unsigned int v69 = *v68;
            if (!*v68)
            {
              int v83 = (unsigned __int16)((_WORD)v68 - (a2 + 356) + 1);
              goto LABEL_189;
            }

            v68 += v69 + 1;
            if (a2 != -612) {
              goto LABEL_126;
            }
          }
        }

        else
        {
LABEL_126:
        }

        int v83 = 257;
        goto LABEL_189;
      }
    }

    else
    {
      uint64_t v62 = (os_log_s *)mDNSLogCategory_Default_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v63 = *(_DWORD *)(v12 + 688);
        unsigned __int16 v64 = (_BYTE *)(a2 + 356);
        if (a2 == -612)
        {
LABEL_113:
          while (v64)
          {
            uint64_t v65 = *v64;
            if (!*v64)
            {
              int v83 = (unsigned __int16)((_WORD)v64 - (a2 + 356) + 1);
              goto LABEL_189;
            }

            v64 += v65 + 1;
            if (a2 != -612) {
              goto LABEL_112;
            }
          }
        }

        else
        {
LABEL_112:
        }

        int v83 = 257;
LABEL_189:
        uint32_t v90 = 67110147;
        int v91 = v63;
        int v92 = 2160;
        int v93 = 1752392040LL;
        unsigned int v94 = 1040;
        int v95 = v83;
        uint64_t v96 = 2101;
        uint64_t v97 = a2 + 356;
        size_t v98 = 1024;
        LODWORD(v99) = v42;
        _os_log_impl( (void *)&_mh_execute_header,  v62,  OS_LOG_TYPE_DEBUG,  "[R%u] Restarting question for %{sensitive, mask.hash, mdnsresponder:domain_name}.*P AAAA record as question fo r A record (RCODE %d)",  (uint8_t *)&v90,  0x28u);
      }
    }

    resolved_cache_delete(a2);
    mDNS_StopQuery((unsigned int *)mDNSStorage, a2);
    *(void *)(a2 + 176) = 0LL;
    *(_WORD *)(a2 + 322) = 1;
    QueryRecordOpStartQuestion(v12, a2);
  }

_BYTE *StartGetZoneData(unsigned int *a1, _BYTE *a2, uint64_t a3)
{
  uint64_t result = calloc(1uLL, 0x5D0uLL);
  if (result)
  {
    uint64_t v7 = (uint64_t)result;
    uint64_t v8 = a2;
    if (a2 == (_BYTE *)-256LL)
    {
LABEL_4:
      while (v8)
      {
        uint64_t v9 = *v8;
        if (!*v8)
        {
          unsigned __int16 v10 = (_WORD)v8 - (_WORD)a2 + 1;
          if (v10 > 0x100u) {
            break;
          }
          memcpy(result, a2, v10);
          goto LABEL_12;
        }

        v8 += v9 + 1;
        if (a2 != (_BYTE *)-256LL) {
          goto LABEL_3;
        }
      }
    }

    else
    {
LABEL_3:
      if (v8 < a2 + 256) {
        goto LABEL_4;
      }
    }

    *uint64_t result = 0;
LABEL_12:
    *(_DWORD *)(v7 + 256) = 0;
    *(void *)(v7 + 264) = v7;
    *(_BYTE *)(v7 + 272) = 0;
    *(_WORD *)(v7 + 528) = 0;
    *(_BYTE *)(v7 + 530) = 0;
    *(_OWORD *)(v7 + 786) = 0u;
    *(void *)(v7 + 801) = 0LL;
    *(void *)(v7 + 816) = RecordRegistrationGotZoneData;
    *(void *)(v7 + 824) = a3;
    *(void *)(v7 + 1008) = v7;
    unsigned int v11 = a1[12];
    unsigned int v12 = a1[13] + 1;
    a1[13] = v12;
    mDNS_VerifyLockState("Drop Lock", 0, v11, v12, (uint64_t)"StartGetZoneData", 1995);
    uint64_t v13 = *(_BYTE **)(v7 + 264);
    uint64_t v14 = v13;
    if (v13 == (_BYTE *)-256LL)
    {
LABEL_14:
      while (v14)
      {
        uint64_t v15 = *v14;
        if (!*v14)
        {
          unsigned __int16 v16 = (_WORD)v14 - (_WORD)v13 + 1;
          if (v16 > 0x100u) {
            break;
          }
          memcpy((void *)(v7 + 1188), v13, v16);
          goto LABEL_22;
        }

        v14 += v15 + 1;
        if (v13 != (_BYTE *)-256LL) {
          goto LABEL_13;
        }
      }
    }

    else
    {
LABEL_13:
      if (v14 < v13 + 256) {
        goto LABEL_14;
      }
    }

    *(_BYTE *)(v7 + 1188) = 0;
LABEL_22:
    GetZoneData_StartQuery(a1, v7, 6);
    mDNS_VerifyLockState("Reclaim Lock", 0, a1[12], a1[13]--, (uint64_t)"StartGetZoneData", 1998);
    return (_BYTE *)v7;
  }

  else
  {
    __break(1u);
  }

  return result;
}

uint64_t GetZoneData_StartQuery(unsigned int *a1, uint64_t a2, int a3)
{
  __int16 v3 = a3;
  if (a3 != 33) {
    goto LABEL_23;
  }
  int v6 = *(_DWORD *)(a2 + 256);
  switch(v6)
  {
    case 2:
      int v7 = *(unsigned __int8 *)(a2 + 808);
      uint64_t v8 = "\f_dns-llq-tls\x04_tcp";
      uint64_t v9 = "\b_dns-llq\x04_udp";
      goto LABEL_8;
    case 1:
      int v7 = *(unsigned __int8 *)(a2 + 808);
      uint64_t v8 = "\x0E_dns-query-tls\x04_tcp";
      uint64_t v9 = "";
LABEL_8:
      if (v7) {
        unsigned __int16 v10 = v8;
      }
      else {
        unsigned __int16 v10 = v9;
      }
      goto LABEL_13;
    case 0:
      int v7 = *(unsigned __int8 *)(a2 + 808);
      uint64_t v8 = "\x0F_dns-update-tls\x04_tcp";
      uint64_t v9 = "\v_dns-update\x04_udp";
      goto LABEL_8;
  }

  unsigned __int16 v10 = "";
  if (v6 == 3) {
    unsigned __int16 v10 = "\r_dns-push-tls\x04_tcp";
  }
LABEL_13:
  unsigned int v11 = v10;
  if (v10 == (const char *)-256LL)
  {
    while (1)
    {
LABEL_15:
      if (!v11) {
        goto LABEL_20;
      }
      uint64_t v12 = *(unsigned __int8 *)v11;
      if (!*v11) {
        break;
      }
      v11 += v12 + 1;
    }

    unsigned __int16 v15 = (_WORD)v11 - (_WORD)v10 + 1;
    uint64_t v13 = (_BYTE *)(a2 + 1188);
    if (v15 > 0x100u) {
      goto LABEL_21;
    }
    if (v6 == 2)
    {
      int v16 = *(unsigned __int8 *)(a2 + 808);
      uint64_t v17 = "\f_dns-llq-tls\x04_tcp";
      uint64_t v18 = "\b_dns-llq\x04_udp";
    }

    else if (v6 == 1)
    {
      int v16 = *(unsigned __int8 *)(a2 + 808);
      uint64_t v17 = "\x0E_dns-query-tls\x04_tcp";
      uint64_t v18 = "";
    }

    else
    {
      if (v6)
      {
        uint64_t v17 = "";
        uint64_t v18 = "\r_dns-push-tls\x04_tcp";
        BOOL v19 = v6 == 3;
        goto LABEL_33;
      }

      int v16 = *(unsigned __int8 *)(a2 + 808);
      uint64_t v17 = "\x0F_dns-update-tls\x04_tcp";
      uint64_t v18 = "\v_dns-update\x04_udp";
    }

    BOOL v19 = v16 == 0;
LABEL_33:
    if (v19) {
      size_t v20 = v18;
    }
    else {
      size_t v20 = v17;
    }
    memcpy((void *)(a2 + 1188), v20, v15);
    goto LABEL_22;
  }

void SetRecordRetry(uint64_t a1, uint64_t a2, uint32_t a3)
{
  int v5 = *(_DWORD *)(a1 + 64);
  *(_DWORD *)(a2 + 284) = v5;
  int v6 = *(_DWORD *)(a2 + 352);
  if (v6 && (unsigned int v7 = *(unsigned __int8 *)(a2 + 600), v7 <= 4))
  {
    int v8 = v6 - v5;
    *(_BYTE *)(a2 + 600) = v7 + 1;
    if (v8 <= 300000)
    {
      *(_DWORD *)(a2 + 280) = 300000;
      if (mDNS_LoggingEnabled == 1)
      {
        uint64_t v28 = (os_log_s *)mDNSLogCategory_Default;
        GetRRDisplayString_rdb( (unsigned __int8 *)(a2 + 8),  (unsigned __int16 *)(*(void *)(a2 + 48) + 4LL),  (_BYTE *)(a1 + 46976));
        LogMsgWithLevel( v28,  OS_LOG_TYPE_DEFAULT,  "SetRecordRetry clamping to min refresh in %d of %d for %s",  v29,  v30,  v31,  v32,  v33,  300);
      }
    }

    else
    {
      unsigned int v9 = v8 / 0xAu;
      unsigned int v10 = 7 * (v8 / 0xAu);
      if (!a3)
      {
        unsigned int v11 = 1;
        do
          unsigned int v11 = (2 * v11) | 1;
        while (v11 < v9);
        do
          a3 = arc4random() & v11;
        while (a3 > v9);
      }

      unsigned int v12 = a3 + v10;
      *(_DWORD *)(a2 + 280) = v12;
      if (mDNS_LoggingEnabled == 1)
      {
        uint64_t v13 = (os_log_s *)mDNSLogCategory_Default;
        unsigned int v14 = v12 / 0x3E8;
        GetRRDisplayString_rdb( (unsigned __int8 *)(a2 + 8),  (unsigned __int16 *)(*(void *)(a2 + 48) + 4LL),  (_BYTE *)(a1 + 46976));
        LogMsgWithLevel( v13,  OS_LOG_TYPE_DEFAULT,  "SetRecordRetry refresh in %d of %d for %s",  v15,  v16,  v17,  v18,  v19,  v14);
      }
    }
  }

  else
  {
    *(_DWORD *)(a2 + 352) = 0;
    int v20 = 3 * *(_DWORD *)(a2 + 280);
    if (v20 <= 1000) {
      int v20 = 1000;
    }
    if (v20 >= 900000) {
      int v21 = 900000;
    }
    else {
      int v21 = v20;
    }
    *(_DWORD *)(a2 + 280) = v21;
    if (mDNS_LoggingEnabled == 1)
    {
      unsigned int v22 = (os_log_s *)mDNSLogCategory_Default;
      GetRRDisplayString_rdb( (unsigned __int8 *)(a2 + 8),  (unsigned __int16 *)(*(void *)(a2 + 48) + 4LL),  (_BYTE *)(a1 + 46976));
      LogMsgWithLevel(v22, OS_LOG_TYPE_DEFAULT, "SetRecordRetry retry in %d ms for %s", v23, v24, v25, v26, v27, v21);
    }
  }

unsigned int *GetZoneData_QuestionCallback(unsigned int *result, uint64_t a2, uint64_t a3, int a4)
{
  if (!a4) {
    return result;
  }
  int v6 = result;
  unsigned int v7 = *(_BYTE **)(a2 + 176);
  if ((a4 == 4 || a4 == 2) && !*(_WORD *)(a3 + 12)) {
    return result;
  }
  int v8 = *(unsigned __int16 *)(a3 + 4);
  if (v8 == 1)
  {
    mDNS_StopQuery(result, a2);
    if (*(_DWORD *)(a2 + 212) != -1)
    {
      uint64_t v23 = (os_log_s *)mDNSLogCategory_Default;
      DNSTypeName(*(unsigned __int16 *)(a2 + 322));
      LogMsgWithLevel( v23,  OS_LOG_TYPE_DEFAULT,  "GetZoneData_QuestionCallback: Question %##s (%s) ThisQInterval %d not -1",  v24,  v25,  v26,  v27,  v28,  a2 + 356);
    }

    *((_DWORD *)v7 + 197) = 4;
    if (*(_WORD *)(a3 + 12) == 4) {
      uint64_t v29 = (int *)(*(void *)(a3 + 40) + 4LL);
    }
    else {
      uint64_t v29 = &zerov4Addr;
    }
    *((_DWORD *)v7 + 198) = *v29;
    goto LABEL_53;
  }

  if (v8 != 33)
  {
    if (v8 != 6) {
      return result;
    }
    mDNS_StopQuery(result, a2);
    if (*(_DWORD *)(a2 + 212) != -1)
    {
      unsigned int v14 = (os_log_s *)mDNSLogCategory_Default;
      DNSTypeName(*(unsigned __int16 *)(a2 + 322));
      LogMsgWithLevel( v14,  OS_LOG_TYPE_DEFAULT,  "GetZoneData_QuestionCallback: Question %##s (%s) ThisQInterval %d not -1",  v15,  v16,  v17,  v18,  v19,  a2 + 356);
    }

    if (*(_WORD *)(a3 + 12))
    {
      int v20 = *(_BYTE **)(a3 + 32);
      int v21 = v20;
      if (v20 == (_BYTE *)-256LL)
      {
LABEL_14:
        while (v21)
        {
          uint64_t v22 = *v21;
          if (!*v21)
          {
            unsigned __int16 v50 = (_WORD)v21 - (_WORD)v20 + 1;
            if (v50 > 0x100u) {
              break;
            }
            memcpy(v7 + 272, v20, v50);
            goto LABEL_48;
          }

          v21 += v22 + 1;
          if (v20 != (_BYTE *)-256LL) {
            goto LABEL_13;
          }
        }
      }

      else
      {
LABEL_13:
        if (v21 < v20 + 256) {
          goto LABEL_14;
        }
      }

      v7[272] = 0;
LABEL_48:
      *((_WORD *)v7 + 264) = *(_WORD *)(a3 + 6);
      return (unsigned int *)GetZoneData_StartQuery(v6, (uint64_t)v7, 33);
    }

    BOOL v41 = (_BYTE *)*((void *)v7 + 33);
    if (*v41)
    {
      size_t v42 = &v41[*v41];
      int v43 = v42 + 1;
      *((void *)v7 + 33) = v42 + 1;
      unint64_t v44 = (unint64_t)(v42 + 257);
      uint64_t v45 = v42 + 1;
      if (v44)
      {
LABEL_38:
      }

      else
      {
LABEL_39:
        while (v45)
        {
          uint64_t v46 = *v45;
          if (!*v45)
          {
            unsigned __int16 v55 = (_WORD)v45 - (_WORD)v43 + 1;
            if (v55 > 0x100u) {
              break;
            }
            memcpy(v7 + 1188, v43, v55);
            return (unsigned int *)GetZoneData_StartQuery(v6, (uint64_t)v7, 6);
          }

          v45 += v46 + 1;
          if (v44) {
            goto LABEL_38;
          }
        }
      }

      v7[1188] = 0;
      return (unsigned int *)GetZoneData_StartQuery(v6, (uint64_t)v7, 6);
    }

    if (mDNS_LoggingEnabled == 1) {
      LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "GetZoneData recursed to root label of %##s without finding SOA",  v9,  v10,  v11,  v12,  v13,  (int)v7);
    }
    int v47 = (uint64_t (*)(unsigned int *, uint64_t, _BYTE *))*((void *)v7 + 102);
    uint64_t v49 = 4294901758LL;
    uint64_t v48 = v6;
    return (unsigned int *)v47(v48, v49, v7);
  }

  mDNS_StopQuery(result, a2);
  if (*(_DWORD *)(a2 + 212) != -1)
  {
    uint64_t v30 = (os_log_s *)mDNSLogCategory_Default;
    DNSTypeName(*(unsigned __int16 *)(a2 + 322));
    LogMsgWithLevel( v30,  OS_LOG_TYPE_DEFAULT,  "GetZoneData_QuestionCallback: Question %##s (%s) ThisQInterval %d not -1",  v31,  v32,  v33,  v34,  v35,  a2 + 356);
  }

  if (!*(_WORD *)(a3 + 12))
  {
    v7[530] = 0;
    *(_OWORD *)(v7 + 786) = 0u;
    *(void *)(v7 + 801) = 0LL;
    int v47 = (uint64_t (*)(unsigned int *, uint64_t, _BYTE *))*((void *)v7 + 102);
    uint64_t v48 = v6;
    uint64_t v49 = 4294901742LL;
    return (unsigned int *)v47(v48, v49, v7);
  }

  uint64_t v36 = *(void *)(a3 + 40);
  uint64_t v37 = (const void *)(v36 + 10);
  unint64_t v38 = v36 + 266;
  uint64_t v39 = (_BYTE *)(v36 + 10);
  if (v38)
  {
LABEL_28:
  }

  else
  {
LABEL_29:
    while (v39)
    {
      uint64_t v40 = *v39;
      if (!*v39)
      {
        unsigned __int16 v51 = (_WORD)v39 - (_WORD)v37 + 1;
        if (v51 > 0x100u) {
          break;
        }
        memcpy(v7 + 530, v37, v51);
        goto LABEL_52;
      }

      v39 += v40 + 1;
      if (v38) {
        goto LABEL_28;
      }
    }
  }

  v7[530] = 0;
LABEL_52:
  *((_WORD *)v7 + 393) = *(_WORD *)(*(void *)(a3 + 40) + 8LL);
  if (*((_DWORD *)v7 + 64) == 3)
  {
LABEL_53:
    int v47 = (uint64_t (*)(unsigned int *, uint64_t, _BYTE *))*((void *)v7 + 102);
    uint64_t v48 = v6;
    uint64_t v49 = 0LL;
    return (unsigned int *)v47(v48, v49, v7);
  }

  uint64_t v52 = v7 + 530;
  for (uint64_t i = v7 + 530; i < v7 + 786; i += v54 + 1)
  {
    if (!i) {
      break;
    }
    uint64_t v54 = *i;
    if (!*i)
    {
      if ((unsigned __int16)((_WORD)i - (_WORD)v52 + 1) <= 0x100u)
      {
        memcpy(v7 + 1188, v52, (unsigned __int16)((_WORD)i - (_WORD)v52 + 1));
        return (unsigned int *)GetZoneData_StartQuery(v6, (uint64_t)v7, 1);
      }

      break;
    }
  }

  v7[1188] = 0;
  return (unsigned int *)GetZoneData_StartQuery(v6, (uint64_t)v7, 1);
}

void RecordRegistrationGotZoneData( uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9)
{
  if (!a3)
  {
    LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "ERROR: RecordRegistrationGotZoneData invoked with NULL result and no error",  a4,  a5,  a6,  a7,  a8,  a9);
    return;
  }

  uint64_t v12 = (unsigned __int8 *)(a1 + 12728);
  uint64_t v13 = *(void *)(a3 + 824);
  uint64_t v14 = *(void *)(v13 + 376);
  if (v14 != a3)
  {
    uint64_t v15 = (os_log_s *)mDNSLogCategory_Default;
    DNSTypeName(*(unsigned __int16 *)(v13 + 12));
    LogMsgWithLevel( v15,  OS_LOG_TYPE_DEFAULT,  "RecordRegistrationGotZoneData: nta (%p) != zoneData (%p)  %##s (%s)",  v16,  v17,  v18,  v19,  v20,  v14);
  }

  mDNS_VerifyLockState( "Check Lock",  0,  *(_DWORD *)(a1 + 48),  *(_DWORD *)(a1 + 52),  (uint64_t)"RecordRegistrationGotZoneData",  4148);
  uint64_t v26 = (void *)(a1 + 12624);
  do
  {
    uint64_t v26 = (void *)*v26;
    if (v26) {
      BOOL v27 = v26 == (void *)v13;
    }
    else {
      BOOL v27 = 1;
    }
  }

  while (!v27);
  if (!v26)
  {
    uint64_t v35 = (os_log_s *)mDNSLogCategory_Default;
    uint64_t v36 = "RecordRegistrationGotZoneData - RR no longer in list.  Discarding.";
    goto LABEL_47;
  }

  if (a2 == -65538)
  {
LABEL_48:
    CancelGetZoneData(a1, *(_DWORD **)(v13 + 376));
    *(void *)(v13 + 376) = 0LL;
    return;
  }

  if (a2)
  {
    LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "RecordRegistrationGotZoneData: error %d",  v21,  v22,  v23,  v24,  v25,  a2);
    goto LABEL_48;
  }

  if (*(unsigned __int16 *)(v13 + 14) != *(unsigned __int16 *)(a3 + 528))
  {
    LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "ERROR: New resource record's class (%d) does not match zone class (%d)",  v21,  v22,  v23,  v24,  v25,  *(unsigned __int16 *)(v13 + 14));
    goto LABEL_48;
  }

  unsigned int v28 = *(unsigned __int8 *)(a3 + 272);
  if (!*(_BYTE *)(a3 + 272))
  {
    if (mDNS_LoggingEnabled == 1) {
      LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "RecordRegistrationGotZoneData: No name server found claiming responsibility for %##s!",  v21,  v22,  v23,  v24,  v25,  *(void *)(v13 + 40));
    }
    goto LABEL_48;
  }

  uint64_t v29 = *(unsigned __int8 **)(v13 + 40);
  unsigned int v30 = *v29;
  if (*v29)
  {
    int v31 = 0;
    uint64_t v32 = *(void *)(v13 + 40);
    do
    {
      ++v31;
      uint64_t v33 = v32 + v30;
      unsigned int v34 = *(unsigned __int8 *)(v33 + 1);
      uint64_t v32 = v33 + 1;
      unsigned int v30 = v34;
    }

    while (v34);
  }

  else
  {
    int v31 = 0;
  }

  int v37 = 0;
  uint64_t v38 = a3 + 272;
  do
  {
    ++v37;
    uint64_t v39 = v38 + v28;
    unsigned int v40 = *(unsigned __int8 *)(v39 + 1);
    uint64_t v38 = v39 + 1;
    unsigned int v28 = v40;
  }

  while (v40);
  int v41 = v31 - v37;
  if (v31 < v37)
  {
    LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "RecordRegistrationGotZoneData: Zone %##s is longer than %##s",  v21,  v22,  v23,  v24,  v25,  a3 + 272);
    goto LABEL_48;
  }

  if (v41 >= 1)
  {
    int v42 = v41 + 1;
    do
    {
      if (!*v29) {
        break;
      }
      v29 += *v29 + 1;
      --v42;
    }

    while (v42 > 1);
  }

  *(void *)(v13 + 368) = v29;
  if (!SameDomainNameBytes(v29, (_BYTE *)(a3 + 272)))
  {
    LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "RecordRegistrationGotZoneData: Zone %##s does not match %##s for %##s",  v21,  v22,  v23,  v24,  v25,  *(void *)(v13 + 368));
    goto LABEL_48;
  }

  if (!*(_WORD *)(a3 + 786)) {
    goto LABEL_45;
  }
  int v43 = *(_DWORD *)(a3 + 788);
  if (v43 == 6)
  {
    if (!(*(_DWORD *)(a3 + 796) | *(_DWORD *)(a3 + 792) | *(_DWORD *)(a3 + 800) | *(_DWORD *)(a3 + 804)))
    {
LABEL_45:
      if (mDNS_LoggingEnabled != 1) {
        goto LABEL_48;
      }
      uint64_t v35 = (os_log_s *)mDNSLogCategory_Default;
      uint64_t v78 = *(void *)(v13 + 40);
      uint64_t v36 = "RecordRegistrationGotZoneData: No _dns-update._udp service found for %##s!";
LABEL_47:
      LogMsgWithLevel(v35, OS_LOG_TYPE_DEFAULT, v36, v21, v22, v23, v24, v25, v78);
      goto LABEL_48;
    }
  }

  else if (v43 == 4 && !*(_DWORD *)(a3 + 792))
  {
    goto LABEL_45;
  }

  if (!*(_BYTE *)(a3 + 530)) {
    goto LABEL_45;
  }
  *(_BYTE *)(v13 + 356) = *(_BYTE *)(a3 + 808);
  if (*(_DWORD *)(v13 + 344) == 3)
  {
    mDNS_Lock_((unsigned int *)a1, (uint64_t)"RecordRegistrationGotZoneData", 4222);
    uDNS_DeregisterRecord(a1, v13);
    uint64_t v44 = a1;
    int v45 = 4224;
LABEL_96:
    mDNS_Unlock_(v44, (uint64_t)"RecordRegistrationGotZoneData", v45);
    return;
  }

  if (*(_WORD *)(v13 + 12) != 33) {
    goto LABEL_88;
  }
  mDNS_Lock_((unsigned int *)a1, (uint64_t)"RecordRegistrationGotZoneData", 4233);
  ServiceTarget = (_BYTE *)GetServiceTarget(a1, v13);
  mDNS_Unlock_(a1, (uint64_t)"RecordRegistrationGotZoneData", 4235);
  if (!ServiceTarget || !*ServiceTarget)
  {
    unsigned __int16 v55 = 0LL;
    unsigned int v56 = *(unsigned __int16 *)(v13 + 12);
    if (v56 > 0x20)
    {
      switch(v56)
      {
        case '!':
          unsigned __int16 v55 = (_BYTE *)(*(void *)(v13 + 48) + 10LL);
          break;
        case '$':
LABEL_65:
          unsigned __int16 v55 = (_BYTE *)(*(void *)(v13 + 48) + 6LL);
          break;
        case '\'':
LABEL_68:
          unsigned __int16 v55 = (_BYTE *)(*(void *)(v13 + 48) + 4LL);
          break;
      }
    }

    else
    {
      switch(*(_WORD *)(v13 + 12))
      {
        case 0xC:
          goto LABEL_68;
        case 0xD:
        case 0xE:
        case 0x10:
        case 0x11:
        case 0x13:
        case 0x14:
          break;
        case 0xF:
        case 0x12:
        case 0x15:
          goto LABEL_65;
        default:
          if (v56 == 2 || v56 == 5) {
            goto LABEL_68;
          }
          break;
      }
    }

    if (mDNS_LoggingEnabled == 1) {
      LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "RecordRegistrationGotZoneData - no target for %##s",  v48,  v49,  v50,  v51,  v52,  *(void *)(v13 + 40));
    }
    if (v55) {
      *unsigned __int16 v55 = 0;
    }
    *(_DWORD *)(v13 + memset(v45, 0, 20) = 0;
    *(_DWORD *)(v13 + 344) = 8;
    goto LABEL_48;
  }

  if (*(_WORD *)(v13 + 12) != 33 || (uint64_t v53 = *(void *)(v13 + 48), !*(_WORD *)(v53 + 8)))
  {
LABEL_88:
    mDNS_Lock_((unsigned int *)a1, (uint64_t)"RecordRegistrationGotZoneData", 4267);
    if (*(_DWORD *)(v13 + 604))
    {
      int v65 = *(_DWORD *)(a1 + 64);
    }

    else
    {
      *(_DWORD *)(v13 + 280) = 1000;
      int v65 = *(_DWORD *)(a1 + 64);
      *(_DWORD *)(v13 + 284) = v65 - 1000;
    }

    if (IsRecordMergeable(a1, v13, v65 + 1000))
    {
      if (mDNS_LoggingEnabled == 1)
      {
        uint64_t v66 = (os_log_s *)mDNSLogCategory_Default;
        GetRRDisplayString_rdb( (unsigned __int8 *)(v13 + 8),  (unsigned __int16 *)(*(void *)(v13 + 48) + 4LL),  (_BYTE *)(a1 + 46976));
        LogMsgWithLevel( v66,  OS_LOG_TYPE_DEFAULT,  "RecordRegistrationGotZoneData: Delayed registration for %s",  v67,  v68,  v69,  v70,  v71,  a1 + 46976);
      }

      *(_DWORD *)(v13 + 284) += 1000;
    }

    uint64_t v44 = a1;
    int v45 = 4285;
    goto LABEL_96;
  }

  int v54 = *v12;
  if (v54 != 10)
  {
    if (v54 == 172)
    {
      if ((v12[1] & 0xF0) != 0x10) {
        goto LABEL_88;
      }
    }

    else if (v54 != 192 || v12[1] != 168)
    {
      goto LABEL_88;
    }
  }

  uint64_t v57 = *(void *)(v13 + 376);
  if (!v57) {
    goto LABEL_88;
  }
  if (*(_DWORD *)(v57 + 788) == 4)
  {
    int v58 = *(unsigned __int8 *)(v57 + 792);
    if (v58 == 10) {
      goto LABEL_88;
    }
    if (v58 == 172)
    {
      if ((*(_BYTE *)(v57 + 793) & 0xF0) == 0x10) {
        goto LABEL_88;
      }
    }

    else if (v58 == 192 && *(unsigned __int8 *)(v57 + 793) == 168)
    {
      goto LABEL_88;
    }
  }

  if (*(_BYTE *)(v13 + 120) != 2) {
    goto LABEL_88;
  }
  if (*(void *)(v13 + 584))
  {
    if (mDNS_LoggingEnabled)
    {
      uint64_t v59 = (os_log_s *)mDNSLogCategory_Default;
      GetRRDisplayString_rdb((unsigned __int8 *)(v13 + 8), (unsigned __int16 *)(v53 + 4), (_BYTE *)(a1 + 46976));
      LogMsgWithLevel( v59,  OS_LOG_TYPE_DEFAULT,  "RecordRegistrationGotZoneData: StartRecordNatMap for %s, state %d, context %p",  v60,  v61,  v62,  v63,  v64,  a1 + 46976);
    }

    goto LABEL_88;
  }

  if (mDNS_LoggingEnabled)
  {
    int v72 = (os_log_s *)mDNSLogCategory_Default;
    GetRRDisplayString_rdb((unsigned __int8 *)(v13 + 8), (unsigned __int16 *)(v53 + 4), (_BYTE *)(a1 + 46976));
    LogMsgWithLevel( v72,  OS_LOG_TYPE_DEFAULT,  "RecordRegistrationGotZoneData StartRecordNatMap %s",  v73,  v74,  v75,  v76,  v77,  a1 + 46976);
  }

  *(_DWORD *)(v13 + 344) = 6;
  StartRecordNatMap(a1, v13, v47, v48, v49, v50, v51, v52);
}

uint64_t FindIdenticalRecordInCache(uint64_t a1, uint64_t a2)
{
  __int16 v3 = CacheGroupForName(a1, *(_DWORD *)(a2 + 16), *(_BYTE **)(a2 + 32));
  if (!v3) {
    return 0LL;
  }
  for (uint64_t i = v3[2]; i; uint64_t i = *(void *)i)
  {
    uint64_t v5 = *(void *)(a2 + 24);
    if (v5)
    {
      uint64_t v6 = *(void *)(i + 32);
    }

    else
    {
      uint64_t v5 = *(void *)(a2 + 48);
      if (v5) {
        uint64_t v5 = *(void *)(v5 + 24);
      }
      uint64_t v6 = *(void *)(i + 56);
      if (v6) {
        uint64_t v6 = *(void *)(v6 + 24);
      }
    }

    if (v5 == v6
      && resource_records_have_same_dnssec_rr_category(*(void *)(a2 + 56), *(void *)(i + 64))
      && *(unsigned __int16 *)(a2 + 4) == *(unsigned __int16 *)(i + 12)
      && *(unsigned __int16 *)(a2 + 6) == *(unsigned __int16 *)(i + 14)
      && *(unsigned __int16 *)(a2 + 12) == *(unsigned __int16 *)(i + 20)
      && *(_DWORD *)(a2 + 20) == *(_DWORD *)(i + 28)
      && SameRDataBody( a2,  (unsigned __int16 *)(*(void *)(i + 48) + 4LL),  (uint64_t (*)(uint64_t, unsigned __int16 *))SameDomainName))
    {
      break;
    }
  }

  return i;
}

uint64_t ShouldSuppressKnownAnswer(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a1 + 24) != *(_DWORD *)(a2 + 24)) {
    return 0LL;
  }
  uint64_t result = resource_records_have_same_dnssec_rr_category(*(void *)(a1 + 64), *(void *)(a2 + 64));
  if (!(_DWORD)result) {
    return result;
  }
  if (*(unsigned __int16 *)(a1 + 12) != *(unsigned __int16 *)(a2 + 12)
    || *(unsigned __int16 *)(a1 + 14) != *(unsigned __int16 *)(a2 + 14)
    || *(unsigned __int16 *)(a1 + 20) != *(unsigned __int16 *)(a2 + 20)
    || *(_DWORD *)(a1 + 28) != *(_DWORD *)(a2 + 28))
  {
    return 0LL;
  }

  uint64_t result = SameRDataBody( a1 + 8,  (unsigned __int16 *)(*(void *)(a2 + 48) + 4LL),  (uint64_t (*)(uint64_t, unsigned __int16 *))SameDomainName);
  if ((_DWORD)result)
  {
    uint64_t result = SameDomainNameBytes(*(_BYTE **)(a1 + 40), *(_BYTE **)(a2 + 40));
    if ((_DWORD)result) {
      return *(_DWORD *)(a1 + 16) >= *(_DWORD *)(a2 + 16) >> 1;
    }
  }

  return result;
}

void SysEventCallBack(int a1, uint64_t a2, unsigned int *a3)
{
  __int128 v25 = 0u;
  memset(v26, 0, sizeof(v26));
  __int128 v23 = 0u;
  __int128 v24 = 0u;
  __int128 v21 = 0u;
  __int128 v22 = 0u;
  __int128 v19 = 0u;
  __int128 v20 = 0u;
  __int128 v17 = 0u;
  __int128 v18 = 0u;
  __int128 v15 = 0u;
  __int128 v16 = 0u;
  __int128 v13 = 0u;
  __int128 v14 = 0u;
  __int128 v11 = 0u;
  __int128 v12 = 0u;
  __int128 v10 = 0u;
  ssize_t v5 = recv(a1, &v10, 0x11CuLL, 0);
  uint64_t v6 = (os_log_s *)mDNSLogCategory_State;
  if (v5 < 0)
  {
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_ERROR))
    {
      uint64_t v7 = *__error();
      int v8 = 134217984;
      uint64_t v9 = v7;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_ERROR,  "SysEventCallBack error -- error: %{mdns:err}ld",  (uint8_t *)&v8,  0xCu);
    }
  }

  else
  {
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT))
    {
      int v8 = 67240192;
      LODWORD(v9) = DWORD1(v11);
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "SysEventCallBack -- event: %{public, mdnsresponder:kev_dl_event}d",  (uint8_t *)&v8,  8u);
    }

    if (DWORD1(v11) == 17 || DWORD1(v11) == 13) {
      SetNetworkChanged(2000);
    }
  }

  mDNS_Unlock_((uint64_t)a3, (uint64_t)"SysEventCallBack", 6832);
}

uint64_t mDNS_PurgeCacheResourceRecord(unsigned int *a1, uint64_t a2)
{
  *(_DWORD *)(a2 + 80) = a1[16] - 60000;
  *(_WORD *)(a2 + 108) = 4;
  *(_DWORD *)(a2 + 16) = 0;
  return SetNextCacheCheckTimeForRecord((uint64_t)a1, a2);
}

void DeadvertiseInterface(uint64_t a1, uint64_t a2, char a3)
{
  uint64_t v6 = *(void *)(a2 + 6256);
  if (AWDLInterfaceID) {
    BOOL v7 = AWDLInterfaceID == v6;
  }
  else {
    BOOL v7 = 0;
  }
  if (v7)
  {
    int v9 = 1;
  }

  else
  {
    if (WiFiAwareInterfaceID) {
      BOOL v8 = WiFiAwareInterfaceID == v6;
    }
    else {
      BOOL v8 = 0;
    }
    int v9 = v8;
    if ((a3 & 1) != 0 && !v9) {
      goto LABEL_18;
    }
  }

  if ((a3 & 2) == 0 || !v9) {
    goto LABEL_50;
  }
  LOBYTE(v9) = 1;
LABEL_18:
  __int128 v10 = (os_log_s *)mDNSLogCategory_Default;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
  {
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEBUG))
    {
      __int128 v12 = "randomized";
      if ((a3 & 2) == 0) {
        __int128 v12 = "normal";
      }
      goto LABEL_30;
    }
  }

  else
  {
    __int128 v10 = (os_log_s *)mDNSLogCategory_Default_redacted;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEBUG))
    {
      __int128 v12 = "randomized";
      if ((a3 & 2) == 0) {
        __int128 v12 = "normal";
      }
LABEL_30:
      int v19 = 136446466;
      __int128 v20 = v12;
      __int16 v21 = 2082;
      uint64_t v22 = a2 + 6310;
      _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEBUG,  "DeadvertiseInterface: Deadvertising %{public}s hostname on interface %{public}s",  (uint8_t *)&v19,  0x16u);
    }
  }

  uint64_t v14 = *(void *)(a2 + 6256);
  if (v14 == AWDLInterfaceID || v14 == WiFiAwareInterfaceID)
  {
    if (!*(_BYTE *)(a2 + 2736) && !*(_BYTE *)(a2 + 3912)) {
      goto LABEL_42;
    }
    __int128 v15 = (os_log_s *)mDNSLogCategory_D2D;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_D2D == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_D2D, OS_LOG_TYPE_DEFAULT))
      {
        int v19 = 136446210;
        __int128 v20 = (const char *)(a2 + 6310);
        goto LABEL_41;
      }
    }

    else
    {
      __int128 v15 = (os_log_s *)mDNSLogCategory_D2D_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_D2D_redacted, OS_LOG_TYPE_DEFAULT))
      {
        int v19 = 136446210;
        __int128 v20 = (const char *)(a2 + 6310);
LABEL_41:
        _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_DEFAULT,  "D2D_stop_advertising_interface - ifname: %{public}s",  (uint8_t *)&v19,  0xCu);
      }
    }

void LNT_ClearState(uint64_t a1)
{
  int v2 = (_DWORD *)(a1 + 14962);
  __int16 v3 = *(_DWORD **)(a1 + 14736);
  if (v3)
  {
    mDNSPlatformTCPCloseConnection(v3);
    *(void *)(a1 + 14736) = 0LL;
  }

  BOOL v4 = *(_DWORD **)(a1 + 14848);
  if (v4)
  {
    mDNSPlatformTCPCloseConnection(v4);
    *(void *)(a1 + 14848) = 0LL;
  }

  _DWORD *v2 = 0;
}

void ReleaseCacheGroup(uint64_t a1, void **a2)
{
  BOOL v4 = *a2;
  if ((void *)(*a2)[3] == *a2 + 2) {
    goto LABEL_12;
  }
  ssize_t v5 = (os_log_s *)mDNSLogCategory_Default;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
  {
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_ERROR)) {
      goto LABEL_12;
    }
    __int16 v13 = 0;
    BOOL v7 = (uint8_t *)&v13;
  }

  else
  {
    ssize_t v5 = (os_log_s *)mDNSLogCategory_Default_redacted;
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_ERROR)) {
      goto LABEL_12;
    }
    __int16 v12 = 0;
    BOOL v7 = (uint8_t *)&v12;
  }

  _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_ERROR,  "ERROR: (*cp)->members == mDNSNULL but (*cp)->rrcache_tail != &(*cp)->members)",  v7,  2u);
LABEL_12:
  int v9 = *a2;
  __int128 v10 = (void *)(*a2)[4];
  if (v10 != *a2 + 5 && v10 != 0LL)
  {
    free(v10);
    int v9 = *a2;
  }

  v9[4] = 0LL;
  *a2 = (void *)**a2;
  *BOOL v4 = *(void *)(a1 + 272);
  *(void *)(a1 + 272) = v4;
  --*(_DWORD *)(a1 + 252);
}

uint64_t AdvertiseHostname(uint64_t result, uint64_t a2)
{
  uint64_t v3 = result;
  if (!*(_DWORD *)(result + 12728) || *(_BYTE *)(a2 + 472)) {
    goto LABEL_24;
  }
  BOOL v4 = (_DWORD *)(result + 12728);
  unint64_t v5 = a2 + 464;
  mDNS_SetupResourceRecord(a2 + 464, 0LL, 0LL, 1, 0x1194u, 0, 0, (uint64_t)HostnameCallback, a2);
  __int16 v12 = (const void *)(a2 + 208);
  __int16 v13 = (_BYTE *)(a2 + 208);
  if (a2 == -464)
  {
LABEL_5:
    while (v13)
    {
      uint64_t v14 = *v13;
      if (!*v13)
      {
        unsigned __int16 v15 = (_WORD)v13 - (_WORD)v12 + 1;
        if (v15 > 0x100u) {
          break;
        }
        memcpy((void *)(a2 + 1116), v12, v15);
        goto LABEL_13;
      }

      v13 += v14 + 1;
      if (a2 != -464) {
        goto LABEL_4;
      }
    }
  }

  else
  {
LABEL_4:
  }

  *(_BYTE *)(a2 + 1116) = 0;
LABEL_13:
  *(_DWORD *)(*(void *)(a2 + 512) + 4LL) = *v4;
  *(_DWORD *)(a2 + 808) = 4;
  int v16 = *(unsigned __int8 *)v4;
  if (v16 == 10) {
    goto LABEL_17;
  }
  if (v16 == 172)
  {
    if ((*(_BYTE *)(v3 + 12729) & 0xF0) == 0x10)
    {
LABEL_17:
      if (*(void *)(a2 + 200)) {
        mDNS_StopNATOperation_internal(v3, a2 + 8);
      }
      *(_BYTE *)(a2 + 180) = 0;
      *(_DWORD *)(a2 + 182) = 0;
      *(_DWORD *)(a2 + 188) = 0;
      *(void *)(a2 + 192) = hostnameGetPublicAddressCallback;
      *(void *)(a2 + 200) = a2;
      uint64_t result = mDNS_StartNATOperation_internal(v3, a2 + 8, v6, v7, v8, v9, v10, v11);
      goto LABEL_24;
    }
  }

  else if (v16 == 192 && *(unsigned __int8 *)(v3 + 12729) == 168)
  {
    goto LABEL_17;
  }

  if (mDNS_LoggingEnabled == 1) {
    LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "Advertising hostname %##s IPv4 %.4a",  v7,  v8,  v9,  v10,  v11,  *(void *)(a2 + 504));
  }
  *(_BYTE *)(a2 + 472) = 32;
  uint64_t result = mDNS_Register_internal(v3, a2 + 464);
LABEL_24:
  if (*(_DWORD *)(v3 + 12752) | *(_DWORD *)(v3 + 12748) | *(_DWORD *)(v3 + 12756) | *(_DWORD *)(v3 + 12760)
    && !*(_BYTE *)(a2 + 1648))
  {
    mDNS_SetupResourceRecord(a2 + 1640, 0LL, 0LL, 28, 0x1194u, 32, 0, (uint64_t)HostnameCallback, a2);
    uint64_t v22 = (const void *)(a2 + 208);
    __int128 v23 = (_BYTE *)(a2 + 208);
    if (a2 == -464)
    {
LABEL_29:
      while (v23)
      {
        uint64_t v24 = *v23;
        if (!*v23)
        {
          unsigned __int16 v25 = (_WORD)v23 - (_WORD)v22 + 1;
          if (v25 > 0x100u) {
            break;
          }
          memcpy((void *)(a2 + 2292), v22, v25);
          goto LABEL_37;
        }

        v23 += v24 + 1;
        if (a2 != -464) {
          goto LABEL_28;
        }
      }
    }

    else
    {
LABEL_28:
    }

    *(_BYTE *)(a2 + 2292) = 0;
LABEL_37:
    *(_OWORD *)(*(void *)(a2 + 1688) + 4LL) = *(_OWORD *)(v3 + 12748);
    *(_DWORD *)(a2 + 1984) = 4;
    if (mDNS_LoggingEnabled == 1) {
      LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "Advertising hostname %##s IPv6 %.16a",  v17,  v18,  v19,  v20,  v21,  *(void *)(a2 + 1680));
    }
    return mDNS_Register_internal(v3, a2 + 1640);
  }

  return result;
}

void CancelGetZoneData(uint64_t a1, _DWORD *a2)
{
  if (a2[261] != -1)
  {
    mDNS_StopQuery_internal(a1, (uint64_t)(a2 + 208));
    if (a2[261] != -1)
    {
      uint64_t v3 = (os_log_s *)mDNSLogCategory_Default;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
      {
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
        {
          unint64_t v5 = a2 + 297;
          if (a2 == (_DWORD *)-1444LL)
          {
LABEL_11:
            while (v5)
            {
              uint64_t v6 = *v5;
              if (!*v5)
              {
                int v10 = (unsigned __int16)((_WORD)v5 - ((_WORD)a2 + 1188) + 1);
                goto LABEL_28;
              }

              v5 += v6 + 1;
              if (a2 != (_DWORD *)-1444LL) {
                goto LABEL_10;
              }
            }
          }

          else
          {
LABEL_10:
            if (v5 < (_BYTE *)a2 + 1444) {
              goto LABEL_11;
            }
          }

          int v10 = 257;
          goto LABEL_28;
        }
      }

      else
      {
        uint64_t v3 = (os_log_s *)mDNSLogCategory_Default_redacted;
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v8 = a2 + 297;
          if (a2 == (_DWORD *)-1444LL)
          {
LABEL_19:
            while (v8)
            {
              uint64_t v9 = *v8;
              if (!*v8)
              {
                int v10 = (unsigned __int16)((_WORD)v8 - ((_WORD)a2 + 1188) + 1);
                goto LABEL_28;
              }

              v8 += v9 + 1;
              if (a2 != (_DWORD *)-1444LL) {
                goto LABEL_18;
              }
            }
          }

          else
          {
LABEL_18:
            if (v8 < (_BYTE *)a2 + 1444) {
              goto LABEL_19;
            }
          }

          int v10 = 257;
LABEL_28:
          uint64_t v11 = DNSTypeName(*((unsigned __int16 *)a2 + 577));
          int v12 = a2[261];
          int v13 = 141559043;
          uint64_t v14 = 1752392040LL;
          __int16 v15 = 1040;
          int v16 = v10;
          __int16 v17 = 2101;
          uint64_t v18 = (char *)(a2 + 297);
          __int16 v19 = 2082;
          uint64_t v20 = v11;
          __int16 v21 = 1024;
          int v22 = v12;
          _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEFAULT,  "CancelGetZoneData: Question %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%{public}s) ThisQInterval %d not -1",  (uint8_t *)&v13,  0x2Cu);
        }
      }
    }
  }

  free(a2);
}

int *mDNSPlatformUDPSocket(unsigned int a1)
{
  uint64_t result = (int *)calloc(1uLL, 0x60uLL);
  if (result)
  {
    uint64_t v3 = result;
    *(_WORD *)uint64_t result = 0;
    *((void *)result + 1) = &mDNSStorage;
    result[4] = -1;
    result[12] = -1;
    *((_BYTE *)result + 88) = 0;
    int v4 = -9999;
    LOWORD(v5) = a1;
    do
    {
      int v6 = v4;
      if (!(_WORD)a1) {
        unsigned int v5 = bswap32(arc4random() | 0xC000) >> 16;
      }
      int v7 = SetupSocket((int)v3, (unsigned __int16)v5, 2);
      if (!v7)
      {
        int v8 = SetupSocket((int)v3, (unsigned __int16)v5, 30);
        if (!v8) {
          return v3;
        }
        int v7 = v8;
        close(v3[4]);
        v3[4] = -1;
      }

      if (v7 != 48) {
        break;
      }
      if ((_WORD)a1) {
        break;
      }
      int v4 = v6 + 1;
    }

    while (v6);
    if ((unsigned __int16)a1 != 58900 || mDNS_LoggingEnabled)
    {
      uint64_t v9 = (os_log_s *)mDNSLogCategory_Default;
      __error();
      int v10 = __error();
      strerror(*v10);
      LogMsgWithLevel( v9,  OS_LOG_TYPE_DEFAULT,  "mDNSPlatformUDPSocket: SetupSocket %d failed error %d errno %d (%s)",  v11,  v12,  v13,  v14,  v15,  bswap32(a1) >> 16);
    }

    free(v3);
    return 0LL;
  }

  else
  {
    __break(1u);
  }

  return result;
}

void uDNS_ReceiveMsg( uint64_t a1, unsigned __int16 *a2, unint64_t a3, int *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v10 = a2[1] & 0xF8;
  if (v10 != 168)
  {
    if (v10 == 128)
    {
      uint64_t v11 = *(void *)(a1 + 200);
      if (v11)
      {
        uint64_t v13 = (unsigned __int16)a5;
        do
        {
          if ((a2[1] & 2) != 0
            && *(unsigned __int16 *)(v11 + 320) == *a2
            && *(_DWORD *)(a1 + 64) - *(_DWORD *)(v11 + 208) <= 59999)
          {
            if (a4)
            {
              uint64_t v14 = *(void *)(v11 + 112);
              if (v14)
              {
                DisposeTCPConn(v14);
                *(void *)(v11 + 112) = 0LL;
              }

              *(void *)(v11 + 112) = MakeTCPConn(a1, 0LL, 0LL, 0LL, a4, v13, 0LL, v11, 0LL);
            }

            else
            {
              LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "uDNS_ReceiveMsg: TCP DNS response had TC bit set: ignoring",  (uint64_t)a4,  a5,  a6,  a7,  a8,  v109);
            }
          }

          uint64_t v11 = *(void *)(v11 + 8);
        }

        while (v11);
      }
    }

    return;
  }

  unint64_t v15 = a3;
  char v16 = *((_BYTE *)a2 + 3);
  int v117 = 0;
  else {
    int v17 = 3600;
  }
  int v112 = 1000 * v17 + *(_DWORD *)(a1 + 64);
  unsigned int v18 = 1000 * v17 / 10;
  unsigned int v19 = 1;
  if (v18 >= 2)
  {
    do
      unsigned int v19 = (2 * v19) | 1;
    while (v19 < v18);
  }

  int v116 = v16 & 0xF;
  do
    uint32_t v20 = arc4random() & v19;
  while (v20 > v18);
  uint64_t v21 = *(void *)(a1 + 12648);
  if (v21)
  {
    int v22 = (os_log_s *)mDNSLogCategory_Default;
    GetRRDisplayString_rdb( (unsigned __int8 *)(v21 + 8),  (unsigned __int16 *)(*(void *)(v21 + 48) + 4LL),  (_BYTE *)(a1 + 46976));
    LogMsgWithLevel( v22,  OS_LOG_TYPE_DEFAULT,  "uDNS_ReceiveMsg ERROR m->CurrentRecord already set %s",  v23,  v24,  v25,  v26,  v27,  a1 + 46976);
  }

  uint64_t v28 = *(void *)(a1 + 12624);
  *(void *)(a1 + 12648) = v28;
  if (v28)
  {
    uint64_t v29 = (_BYTE *)(a1 + 46976);
    unsigned int v30 = (os_log_s **)&unk_100164000;
    while (1)
    {
      uint64_t v31 = *(void *)v28;
      *(void *)(a1 + 12648) = *(void *)v28;
      if (!*(void *)(v28 + 32)) {
        break;
      }
LABEL_87:
      uint64_t v28 = v31;
      if (!v31) {
        return;
      }
    }

    if (*(_BYTE *)(v28 + 122) || IsLocalDomain(*(_BYTE **)(v28 + 40)) || *(unsigned __int16 *)(v28 + 358) != *a2)
    {
LABEL_86:
      uint64_t v31 = *(void *)(a1 + 12648);
      goto LABEL_87;
    }

    uint64_t v37 = *(void *)(v28 + 40);
    int v38 = 0;
    int v39 = -65548;
    switch(v116)
    {
      case 0:
        int v39 = 0;
        int v38 = 1;
        if (v17 && *(_BYTE *)(v28 + 348))
        {
          if (*(_DWORD *)(v28 + 352) - v112 < 0 && *(_DWORD *)(v28 + 344) == 7)
          {
            int v39 = 0;
          }

          else
          {
            int v39 = 0;
            *(_DWORD *)(v28 + 352) = v112;
            *(_BYTE *)(v28 + 600) = 0;
          }
        }

        goto LABEL_46;
      case 1:
        int v39 = ParseTSIGError(a1, (unint64_t)a2, v15, *(void *)(v28 + 40));
        if (v39) {
          goto LABEL_42;
        }
        LogMsgWithLevel(v30[170], OS_LOG_TYPE_DEFAULT, "Format Error: %##s", v40, v41, v42, v43, v44, v37);
        goto LABEL_45;
      case 5:
        LogMsgWithLevel( v30[170],  OS_LOG_TYPE_DEFAULT,  "Update %##s refused",  v32,  v33,  v34,  v35,  v36,  *(void *)(v28 + 40));
        int v38 = 0;
        int v39 = -65553;
        goto LABEL_46;
      case 6:
        goto LABEL_46;
      case 8:
        LogMsgWithLevel( v30[170],  OS_LOG_TYPE_DEFAULT,  "Reregister refused (NXRRSET): %##s",  v32,  v33,  v34,  v35,  v36,  *(void *)(v28 + 40));
        int v38 = 0;
        int v39 = -65554;
        goto LABEL_46;
      case 9:
        int v39 = ParseTSIGError(a1, (unint64_t)a2, v15, *(void *)(v28 + 40));
        if (v39)
        {
LABEL_42:
          int v38 = 0;
        }

        else
        {
          LogMsgWithLevel( v30[170],  OS_LOG_TYPE_DEFAULT,  "Permission denied (NOAUTH): %##s",  v45,  v46,  v47,  v48,  v49,  v37);
LABEL_45:
          int v38 = 0;
          int v39 = -65537;
        }

LABEL_84:
            int v97 = 8;
LABEL_85:
            *(_DWORD *)(v28 + 344) = v97;
            goto LABEL_86;
          }

          ServiceTarget = (_BYTE *)GetServiceTarget(a1, v28);
          if (ServiceTarget)
          {
            int v77 = (int)ServiceTarget;
            if (*ServiceTarget)
            {
              int v78 = *(_DWORD *)(v28 + 344);
              if (v78 != 3)
              {
                if (v78 != 1)
                {
LABEL_117:
                  *(_BYTE *)(v28 + 592) = 0;
                  goto LABEL_86;
                }

                if (SameDomainNameBytes(ServiceTarget, (_BYTE *)(*(void *)(v28 + 48) + 10LL)))
                {
                  if (*(_DWORD *)(v28 + 344) == 1) {
                    *(_DWORD *)(v28 + 344) = 2;
                  }
                  goto LABEL_117;
                }
              }

              unsigned int v106 = *(unsigned __int16 *)(v28 + 12);
              if (v106 <= 0x20)
              {
                switch(*(_WORD *)(v28 + 12))
                {
                  case 0xC:
                    goto LABEL_139;
                  case 0xD:
                  case 0xE:
                  case 0x10:
                  case 0x11:
                  case 0x13:
                  case 0x14:
                    goto LABEL_145;
                  case 0xF:
                  case 0x12:
                  case 0x15:
                    goto LABEL_133;
                  default:
                    if (v106 == 2 || v106 == 5) {
                      goto LABEL_139;
                    }
                    break;
                }

                goto LABEL_145;
              }

              switch(v106)
              {
                case '!':
                  unsigned int v108 = (_BYTE *)(*(void *)(v28 + 48) + 10LL);
                  break;
                case '$':
LABEL_133:
                  unsigned int v108 = (_BYTE *)(*(void *)(v28 + 48) + 6LL);
                  break;
                case '\'':
LABEL_139:
                  unsigned int v108 = (_BYTE *)(*(void *)(v28 + 48) + 4LL);
                  break;
                default:
                  goto LABEL_145;
              }

              *unsigned int v108 = 0;
LABEL_145:
              *(_DWORD *)(v28 + 344) = 8;
              *(_DWORD *)(v28 + memset(v45, 0, 20) = 0;
              if (mDNS_LoggingEnabled == 1) {
                LogMsgWithLevel( v30[170],  OS_LOG_TYPE_DEFAULT,  "hndlSRVChanged: SRVChanged, Valid Target %##s, Registering all records for %##s, state %d",  v72,  v73,  v74,  v75,  v76,  v77);
              }
              *(_BYTE *)(v28 + 592) = 0;
              UpdateOneSRVRecord(a1, v28);
              goto LABEL_86;
            }
          }

          int v98 = *(_DWORD *)(v28 + 344);
          if (v98 == 1)
          {
            if (mDNS_LoggingEnabled == 1) {
              LogMsgWithLevel( v30[170],  OS_LOG_TYPE_DEFAULT,  "hndlSRVChanged: SRVChanged, No Target, Deregistering again %##s, state %d",  v72,  v73,  v74,  v75,  v76,  *(void *)(v28 + 40));
            }
            *(_DWORD *)(v28 + 280) = 1000;
            *(_DWORD *)(v28 + 284) = *(_DWORD *)(a1 + 64) - 1000;
            int v97 = 3;
            goto LABEL_85;
          }

          if (v98 != 3)
          {
            if (mDNS_LoggingEnabled == 1) {
              LogMsgWithLevel( v30[170],  OS_LOG_TYPE_DEFAULT,  "hndlSRVChanged: Not in DeregPending or RegPending state %##s, state %d",  v72,  v73,  v74,  v75,  v76,  *(void *)(v28 + 40));
            }
            goto LABEL_117;
          }

          if (mDNS_LoggingEnabled == 1) {
            LogMsgWithLevel( v30[170],  OS_LOG_TYPE_DEFAULT,  "hndlSRVChanged: SRVChanged, No Target, SRV Deregistered for %##s, state %d",  v72,  v73,  v74,  v75,  v76,  *(void *)(v28 + 40));
          }
          *(_BYTE *)(v28 + 592) = 0;
          unsigned int v99 = *(unsigned __int16 *)(v28 + 12);
          if (v99 <= 0x20)
          {
            switch(*(_WORD *)(v28 + 12))
            {
              case 0xC:
                goto LABEL_136;
              case 0xD:
              case 0xE:
              case 0x10:
              case 0x11:
              case 0x13:
              case 0x14:
                goto LABEL_142;
              case 0xF:
              case 0x12:
              case 0x15:
                goto LABEL_128;
              default:
                if (v99 == 2 || v99 == 5) {
                  goto LABEL_136;
                }
                break;
            }

            goto LABEL_142;
          }

          switch(v99)
          {
            case '!':
              int v107 = (_BYTE *)(*(void *)(v28 + 48) + 10LL);
              break;
            case '$':
LABEL_128:
              int v107 = (_BYTE *)(*(void *)(v28 + 48) + 6LL);
              break;
            case '\'':
LABEL_136:
              int v107 = (_BYTE *)(*(void *)(v28 + 48) + 4LL);
              break;
            default:
              goto LABEL_142;
          }

          *int v107 = 0;
LABEL_142:
          *(_DWORD *)(v28 + 344) = 8;
          *(_DWORD *)(v28 + memset(v45, 0, 20) = 0;
          goto LABEL_86;
        }

        int v79 = *(_DWORD *)(v28 + 344);
        if ((v79 | 4) != 5)
        {
          BOOL v80 = 1;
          goto LABEL_99;
        }

        if (v68)
        {
          BOOL v80 = v79 != 5;
          *(_DWORD *)(v28 + 344) = 2;
          goto LABEL_99;
        }

        LogMsgWithLevel( v30[170],  OS_LOG_TYPE_DEFAULT,  "hndlRecordUpdateReply: Registration of record %##s type %d failed with error %d",  v55,  v56,  v57,  v58,  v59,  *(void *)(v28 + 40));
        if (*(_BYTE *)(v28 + 356))
        {
          BOOL v80 = 1;
        }

        else
        {
          BOOL v80 = 1;
          if (v114 == -65537)
          {
            LOBYTE(v68) = v113;
            if (*(_BYTE *)(v28 + 348) && v67 == 13568)
            {
              LogMsgWithLevel( v30[170],  OS_LOG_TYPE_DEFAULT,  "hndlRecordUpdateReply: Will retry update of record %##s without lease option",  v55,  v56,  v57,  v58,  v59,  *(void *)(v28 + 40));
              *(_BYTE *)(v28 + 348) = 0;
LABEL_102:
              *(_DWORD *)(v28 + 280) = 1000;
              int v101 = *(_DWORD *)(a1 + 64);
              *(_DWORD *)(v28 + 284) = v101 - 1000;
              if (*(_DWORD *)(a1 + 12688) - v101 >= 0) {
                *(_DWORD *)(a1 + 12688) = v101;
              }
              goto LABEL_86;
            }

    _mdns_system_unlock_and_forget_prefs(&v56);
    uint64_t v52 = v57;
    CFRelease(v46);
    if (!v52) {
      return;
    }
    goto LABEL_85;
  }

  uint64_t v34 = v108;
  *(_DWORD *)(a1 + 48) = v30;
  *(_DWORD *)(a1 + 52) = v34;
  uint64_t v35 = v107;
  if (v107)
  {
    uint64_t v36 = 0LL;
    do
    {
      uint64_t v37 = (void *)v31[v36];
      if (v37)
      {
        ref_count_obj_release(v37);
        v31[v36] = 0LL;
      }

      ++v36;
    }

    while (v36 < v35);
    goto LABEL_109;
  }

  if (v31) {
LABEL_109:
  }
    free(v31);
  uint64_t v49 = v106;
  if (v106)
  {
    uint64_t v50 = 0LL;
    do
    {
      uint64_t v51 = v32[v50];
      if (v51)
      {
        ref_count_obj_release(v51);
        v32[v50] = 0LL;
      }

      ++v50;
    }

    while (v50 < v49);
  }

  else if (!v32)
  {
    return;
  }

  free(v32);
}

              CFRelease(v46);
              goto LABEL_85;
            }

            uint64_t v46 = v27;
          }

          else
          {
            uint64_t v46 = v26;
            uint64_t v26 = 0LL;
          }

          uint64_t v47 = v60;
          goto LABEL_84;
        }
      }

      goto LABEL_102;
    }

    int v8 = (unsigned __int16 *)*((void *)v3 + 4);
    uint64_t v9 = *((void *)v4 + 5);
    if (v8) {
      int v10 = v9 >= 0xC;
    }
    else {
      int v10 = 0;
    }
    uint64_t v11 = __rev16(*(unsigned __int16 *)_mdns_dso_message_get_header((uint64_t)v8, v9));
    if (!v11)
    {
      if (_mdns_push_notifications_log_s_once != -1) {
        dispatch_once(&_mdns_push_notifications_log_s_once, &__block_literal_global_6664);
      }
      uint64_t v59 = (os_log_s *)_mdns_push_notifications_log_s_log;
      if (os_log_type_enabled((os_log_t)_mdns_push_notifications_log_s_log, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)buf = 67109120;
        *(_DWORD *)&uint8_t buf[4] = 0;
        _os_log_fault_impl( (void *)&_mh_execute_header,  v59,  OS_LOG_TYPE_FAULT,  "Unexpected DSO response message ID: %u",  buf,  8u);
      }

      goto LABEL_102;
    }

    uint64_t v13 = v2 + 4;
    uint64_t v12 = v2[4];
    if (!v12) {
      goto LABEL_102;
    }
    if (*(unsigned __int16 *)(v12 + 132) != v11)
    {
      while (1)
      {
        uint64_t v14 = v12;
        uint64_t v12 = *(void *)(v12 + 64);
        if (!v12) {
          goto LABEL_102;
        }
        if (*(unsigned __int16 *)(v12 + 132) == v11)
        {
          uint64_t v13 = (void *)(v14 + 64);
          break;
        }
      }
    }

    if ((*(_BYTE *)(_mdns_dso_message_get_header(*((void *)v4 + 4), *((void *)v4 + 5)) + 3) & 0xF) != 0)
    {
LABEL_102:
      os_release(v4);
      return;
    }

    *uint64_t v13 = *(void *)(v12 + 64);
    *(void *)(v12 + 64) = 0LL;
    unint64_t v15 = v2 + 3;
    do
    {
      char v16 = v15;
      int v17 = *v15;
      unint64_t v15 = (void *)(*v15 + 64LL);
    }

    while (v17);
    *char v16 = v12;
    os_retain((void *)v12);
    unsigned int v18 = v2[5];
    unsigned int v19 = *(void *)(v12 + 120);
    if (v18)
    {
      if (_mdns_push_notifications_log_s_once != -1) {
        dispatch_once(&_mdns_push_notifications_log_s_once, &__block_literal_global_6664);
      }
      uint32_t v20 = _mdns_push_notifications_log_s_log;
      if (!os_log_type_enabled((os_log_t)_mdns_push_notifications_log_s_log, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_74;
      }
      uint64_t v21 = *(void *)(v18 + 40);
      *(_DWORD *)buf = 134218240;
      *(void *)&uint8_t buf[4] = v19;
      *(_WORD *)&buf[12] = 2048;
      *(void *)&buf[14] = v21;
      int v22 = "[Sub%llu->DSO%llu] Subscription is now active.";
      uint64_t v23 = (os_log_s *)v20;
      uint64_t v24 = 22;
    }

    else
    {
      if (_mdns_push_notifications_log_s_once != -1) {
        dispatch_once(&_mdns_push_notifications_log_s_once, &__block_literal_global_6664);
      }
      uint64_t v48 = _mdns_push_notifications_log_s_log;
      if (!os_log_type_enabled((os_log_t)_mdns_push_notifications_log_s_log, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_74;
      }
      *(_DWORD *)buf = 134217984;
      *(void *)&uint8_t buf[4] = v19;
      int v22 = "[Sub%llu] Subscription is now active.";
      uint64_t v23 = (os_log_s *)v48;
      uint64_t v24 = 12;
    }

    _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, v22, buf, v24);
LABEL_74:
    os_release((void *)v12);
    goto LABEL_102;
  }

uint64_t ExpectingUnicastResponseForQuestion( uint64_t result, unsigned __int16 a2, unsigned __int16 a3, uint64_t a4, int a5)
{
  if (result)
  {
    uint64_t v8 = result;
    int v9 = a2;
    int v10 = (_BYTE *)(a4 + 356);
    while (1)
    {
      if (a5)
      {
        uint64_t v11 = (unsigned __int16 *)(v8 + 318);
      }

      else
      {
        uint64_t v11 = *(unsigned __int16 **)(v8 + 72);
        if (!v11) {
          goto LABEL_11;
        }
      }

      if (*v11 == v9
        && *(unsigned __int16 *)(v8 + 322) == *(unsigned __int16 *)(a4 + 322)
        && *(unsigned __int16 *)(v8 + 324) == *(unsigned __int16 *)(a4 + 324)
        && *(_DWORD *)(v8 + 200) == *(_DWORD *)(a4 + 200)
        && SameDomainNameBytes((_BYTE *)(v8 + 356), v10))
      {
        else {
          return 0LL;
        }
      }

LABEL_11:
      uint64_t v8 = *(void *)(v8 + 8);
      if (!v8) {
        return 0LL;
      }
    }
  }

  return result;
}

  if (!a4) {
    return;
  }
  uint64_t v13 = (os_log_s *)mDNSLogCategory_D2D;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_D2D == mDNSLogCategory_State)
  {
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D, OS_LOG_TYPE_DEBUG)) {
      return;
    }
  }

  else
  {
    uint64_t v13 = (os_log_s *)mDNSLogCategory_D2D_redacted;
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D_redacted, OS_LOG_TYPE_DEBUG)) {
      return;
    }
  }

  uint64_t v14 = 136447235;
  unint64_t v15 = a1;
  char v16 = 1024;
  int v17 = a5;
  unsigned int v18 = 2160;
  unsigned int v19 = 1752392040LL;
  uint32_t v20 = 1040;
  uint64_t v21 = a5;
  int v22 = 2101;
  uint64_t v23 = a4;
  _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEBUG,  "%{public}s: RHS: (%d bytes) %{sensitive, mask.hash, mdnsresponder:hex_sequence}.*P",  (uint8_t *)&v14,  0x2Cu);
}

  uint32_t v20 = (unsigned __int8 *)(a2 + 8);
  if (*(_DWORD *)(a2 + 344) == 8)
  {
    if (mDNS_LoggingEnabled == 1)
    {
      uint64_t v21 = (os_log_s *)mDNSLogCategory_Default;
      int v22 = (_BYTE *)(a1 + 46976);
      GetRRDisplayString_rdb(v20, (unsigned __int16 *)(*(void *)(a2 + 48) + 4LL), v22);
      LogMsgWithLevel( v21,  OS_LOG_TYPE_DEFAULT,  "ActivateUnicastRegistration record %s in regState_NoTarget, not activating",  v23,  v24,  v25,  v26,  v27,  (int)v22);
    }
  }

  else
  {
    uint64_t v28 = *v20;
    if (v28 == 1) {
      uint64_t v29 = 3;
    }
    else {
      uint64_t v29 = 1;
    }
    if (mDNS_LoggingEnabled == 1)
    {
      if (v28 == 1) {
        unsigned int v30 = "ActivateUnicastRegistration: Resource record %s, current state %d, moving to DeregPending";
      }
      else {
        unsigned int v30 = "ActivateUnicastRegistration: Resource record %s, current state %d, moving to Pending";
      }
      uint64_t v31 = (os_log_s *)mDNSLogCategory_Default;
      GetRRDisplayString_rdb(v20, (unsigned __int16 *)(*(void *)(a2 + 48) + 4LL), (_BYTE *)(a1 + 46976));
      LogMsgWithLevel(v31, OS_LOG_TYPE_DEFAULT, v30, v32, v33, v34, v35, v36, a1 + 46976);
    }

    *(_DWORD *)(a2 + 344) = v29;
    *(_DWORD *)(a2 + 180) = 0;
    *(_DWORD *)(a2 + 184) = 0;
    *(_WORD *)(a2 + 189) = 0;
    *(_BYTE *)(a2 + 191) = 0;
    *(_DWORD *)(a2 + 280) = 1000;
    *(_DWORD *)(a2 + 284) = *(_DWORD *)(a1 + 64) - 1000;
    *(_DWORD *)(a2 + 352) = 0;
    *(_BYTE *)(a2 + 348) = 1;
    *(_WORD *)(a2 + 358) = 0;
    *(_BYTE *)(a2 + 592) = 0;
    *(_DWORD *)(a2 + 604) = 0;
    if (*(void *)(a2 + 584))
    {
      mDNS_StopNATOperation_internal(a1, a2 + 392);
      *(void *)(a2 + 584) = 0LL;
    }

    uint64_t v37 = *(_DWORD **)(a2 + 376);
    if (v37)
    {
      CancelGetZoneData(a1, v37);
      *(void *)(a2 + 376) = 0LL;
    }

    int v38 = *(void *)(a2 + 384);
    if (v38)
    {
      DisposeTCPConn(v38);
      *(void *)(a2 + 384) = 0LL;
    }

    int v39 = *(_DWORD *)(a2 + 280) + *(_DWORD *)(a2 + 284);
    if (*(_DWORD *)(a1 + 12688) - v39 >= 0) {
      *(_DWORD *)(a1 + 12688) = v39;
    }
  }

  int v6 = *(void *)(a1 + 12624);
  for (*(void *)(a1 + 12648) = v6; v6; *(void *)(a1 + 12648) = v6)
  {
    while ((*(void *)(v6 + 32) || *(_BYTE *)(v6 + 122) || IsLocalDomain(*(_BYTE **)(v6 + 40)))
         && *(_BYTE *)(v6 + 8) == 1)
    {
      CompleteDeregistration(a1, v6);
      int v6 = *(void *)(a1 + 12648);
      if (!v6) {
        return;
      }
    }

    int v6 = *(void *)v6;
  }

  uint64_t v3 = dword_100158BF8 + 5000;
  dword_100158C04 = v3;
  mDNSCoreBeSleepProxyServer_internal((uint64_t)mDNSStorage, 0, 0, 0, 0, 0);
  for (uint64_t i = xmmword_10015C4C8; (void)xmmword_10015C4C8; uint64_t i = xmmword_10015C4C8)
    mDNS_RemoveDynDNSHostName((_BYTE *)(i + 208));
  int v10 = (void *)SearchList;
  if (SearchList)
  {
    do
    {
      while (1)
      {
        uint64_t v11 = (void *)v10[446];
        if (!v11) {
          break;
        }
        v10[446] = *v11;
        mDNS_Deregister_internal((uint64_t)mDNSStorage, (uint64_t)(v11 + 1), 0);
      }

      int v10 = (void *)*v10;
    }

    while (v10);
  }

  for (uint64_t j = qword_10015C2C0; j; uint64_t j = *(void *)(j + 296))
  {
    uint64_t v13 = 0LL;
    do
    {
      mDNS_DeregisterDomainsDiscoveredForDomainEnumeration((unsigned int *)mDNSStorage, j, v13, v4, v5, v6, v7, v8);
      uint64_t v13 = (v13 + 1);
    }

    while ((_DWORD)v13 != 5);
  }

  DeadvertiseAllInterfaceRecords((uint64_t)mDNSStorage, 3);
  while (1)
  {
    uint64_t v14 = xmmword_10015C4F0;
    if (!(void)xmmword_10015C4F0) {
      break;
    }
    mDNS_StopNATOperation_internal((uint64_t)mDNSStorage, xmmword_10015C4F0);
    *(void *)(v14 + 152) = 0LL;
    *(_WORD *)(v14 + 160) = 0;
    *(_WORD *)(v14 + 176) = 0;
    *(void *)(v14 + 164) = 0LL;
  }

  unint64_t v15 = *((void *)&xmmword_10015BD18 + 1);
  if (*((void *)&xmmword_10015BD18 + 1))
  {
    char v16 = (os_log_s *)mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_36;
      }
    }

    else
    {
      char v16 = (os_log_s *)mDNSLogCategory_Default_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_36;
      }
    }

    GetRRDisplayString_rdb( (unsigned __int8 *)(v15 + 8),  (unsigned __int16 *)(*(void *)(v15 + 48) + 4LL),  word_100164338);
    *(_DWORD *)buf = 141558275;
    *(void *)uint64_t v33 = 1752392040LL;
    *(_WORD *)&v33[8] = 2085;
    *(void *)&v33[10] = word_100164338;
    _os_log_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_DEFAULT,  "mDNS_StartExit: ERROR m->CurrentRecord already set %{sensitive, mask.hash}s",  buf,  0x16u);
  }

  int v4 = mDNSStorage[0];
  if (*(_DWORD *)(mDNSStorage[0] + 568))
  {
    Maiuint64_t n = CFRunLoopGetMain();
    RunLoopSource = IONotificationPortGetRunLoopSource(*(IONotificationPortRef *)(mDNSStorage[0] + 560));
    CFRunLoopRemoveSource(Main, RunLoopSource, kCFRunLoopDefaultMode);
    IODeregisterForSystemPower((io_object_t *)(mDNSStorage[0] + 572));
    IOServiceClose(*(_DWORD *)(mDNSStorage[0] + 568));
    IONotificationPortDestroy(*(IONotificationPortRef *)(mDNSStorage[0] + 560));
    int v4 = mDNSStorage[0];
    *(_DWORD *)(mDNSStorage[0] + 568) = 0;
  }

  if (*(void *)(v4 + 504))
  {
    int v7 = CFRunLoopGetMain();
    CFRunLoopRemoveSource(v7, *(CFRunLoopSourceRef *)(mDNSStorage[0] + 512), kCFRunLoopDefaultMode);
    CFRunLoopSourceInvalidate(*(CFRunLoopSourceRef *)(mDNSStorage[0] + 512));
    int v4 = mDNSStorage[0];
    uint64_t v8 = *(const void **)(mDNSStorage[0] + 512);
    if (v8)
    {
      CFRelease(v8);
      int v4 = mDNSStorage[0];
      *(void *)(mDNSStorage[0] + 512) = 0LL;
    }

    int v9 = *(const void **)(v4 + 504);
    if (v9)
    {
      CFRelease(v9);
      int v4 = mDNSStorage[0];
      *(void *)(mDNSStorage[0] + 504) = 0LL;
    }
  }

  if (*(void *)(v4 + 520))
  {
    int v10 = CFRunLoopGetMain();
    CFRunLoopRemoveSource(v10, *(CFRunLoopSourceRef *)(mDNSStorage[0] + 520), kCFRunLoopDefaultMode);
    CFRunLoopSourceInvalidate(*(CFRunLoopSourceRef *)(mDNSStorage[0] + 520));
    int v4 = mDNSStorage[0];
    uint64_t v11 = *(const void **)(mDNSStorage[0] + 520);
    if (v11)
    {
      CFRelease(v11);
      int v4 = mDNSStorage[0];
      *(void *)(mDNSStorage[0] + 5memset(v45, 0, 20) = 0LL;
    }
  }

  uint64_t v12 = *(_DWORD *)(v4 + 528);
  if ((v12 & 0x80000000) == 0)
  {
    close(v12);
    *(_DWORD *)(mDNSStorage[0] + 528) = -1;
  }

  if (&_D2DTerminate)
  {
    uint64_t v13 = D2DTerminate();
    uint64_t v14 = gSensitiveLoggingEnabled;
    unint64_t v15 = mDNSLogCategory_D2D;
    if (mDNSLogCategory_D2D == mDNSLogCategory_State) {
      uint64_t v14 = 0;
    }
    if (v13)
    {
      char v16 = v13;
      if ((v14 & 1) != 0)
      {
        unint64_t v15 = mDNSLogCategory_D2D_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D_redacted, OS_LOG_TYPE_ERROR)) {
          goto LABEL_40;
        }
        *(_DWORD *)buf = 67109120;
        *(_DWORD *)uint64_t v41 = v16;
        int v17 = "D2DTerminate failed: %d";
      }

      else
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D, OS_LOG_TYPE_ERROR)) {
          goto LABEL_40;
        }
        *(_DWORD *)buf = 67109120;
        *(_DWORD *)uint64_t v41 = v16;
        int v17 = "D2DTerminate failed: %d";
      }

      unsigned int v18 = (os_log_s *)v15;
      unsigned int v19 = OS_LOG_TYPE_ERROR;
      uint32_t v20 = 8;
    }

    else
    {
      if ((v14 & 1) != 0)
      {
        unint64_t v15 = mDNSLogCategory_D2D_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D_redacted, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_40;
        }
        *(_WORD *)buf = 0;
        int v17 = "D2DTerminate succeeded";
      }

      else
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_40;
        }
        *(_WORD *)buf = 0;
        int v17 = "D2DTerminate succeeded";
      }

      unsigned int v18 = (os_log_s *)v15;
      unsigned int v19 = OS_LOG_TYPE_DEFAULT;
      uint32_t v20 = 2;
    }

    _os_log_impl((void *)&_mh_execute_header, v18, v19, v17, buf, v20);
  }

  if (a4)
  {
    mDNS_StopQuery(a1, (uint64_t)v8);
    if (!v8) {
      goto LABEL_16;
    }
    goto LABEL_15;
  }

  mDNS_StopQuery_internal(a1, v8);
  if (v8) {
LABEL_15:
  }
    free(v8);
LABEL_16:
  *a2 = 0LL;
  *(void *)(a3 + 48) = 0LL;
}

    dispatch_release(v4);
  }

  mDNS_StopQuery((unsigned int *)&mDNSStorage, *(void *)(a1 + 56));
  uint64_t v8 = *(void **)(a1 + 56);
  if (v8)
  {
    free(v8);
    *(void *)(a1 + 56) = 0LL;
  }

  mDNS_StopQuery((unsigned int *)&mDNSStorage, *(void *)(a1 + 80));
  int v10 = *(void **)(a1 + 80);
  if (v10)
  {
    free(v10);
    *(void *)(a1 + 80) = 0LL;
  }

void UpdateSPSStatus( unsigned int *a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9)
{
  uint64_t v12 = *(void *)(a2 + 176);
  mDNS_Lock_(a1, (uint64_t)"UpdateSPSStatus", 5816);
  mDNS_UpdateAllowSleep((uint64_t)a1);
  mDNS_Unlock_((uint64_t)a1, (uint64_t)"UpdateSPSStatus", 5818);
  if (!a3
    || (uint64_t v13 = *(unsigned __int8 **)(a3 + 40), v14 = v13[4], v14 >= 5)
    && (int v15 = v13[5], (v15 - 48) <= 9)
    && (int v16 = v13[6], (v16 - 48) <= 9)
    && (int v17 = v13[8], (v17 - 48) <= 9)
    && (int v18 = v13[9], (v18 - 48) <= 9)
    && (v14 < 0xB
     || v18 != 57
     || v17 != 57
     || v13[7] != 45
     || v13[10] != 45
     || v13[11] != 57
     || v13[12] != 57
     || v13[13] != 45
     || v13[14] != 57
     || v13[15] != 57)
    && 100000 * v15 + 10000 * v16 + 1000 * v17 + 100 * v18 + 10 * v13[11] + v13[12] <= 0x60A38F)
  {
    if (spsStatusDict
      || (spsStatusDict = (uint64_t)CFDictionaryCreateMutable( 0LL,  0LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks)) != 0)
    {
      uint64_t v24 = (const char *)(v12 + 6310);
      CFStringRef v25 = CFStringCreateWithCString(0LL, v24, 0x8000100u);
      if (v25)
      {
        CFStringRef v26 = v25;
        value = 0LL;
        if (CFDictionaryGetValueIfPresent((CFDictionaryRef)spsStatusDict, v25, (const void **)&value))
        {
          if (!value)
          {
            LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "UpdateSPSStatus: Could not get CFMutableArray for %s",  v27,  v28,  v29,  v30,  v31,  (int)v24);
LABEL_82:
            CFRelease(v26);
            return;
          }
        }

        else
        {
          CFMutableArrayRef Mutable = CFArrayCreateMutable(0LL, 0LL, &kCFTypeArrayCallBacks);
          value = Mutable;
          if (!Mutable)
          {
            uint64_t v62 = (os_log_s *)mDNSLogCategory_Default;
            uint64_t v63 = "UpdateSPSStatus: Could not create CFMutableArray";
            goto LABEL_57;
          }

          CFDictionarySetValue((CFMutableDictionaryRef)spsStatusDict, v26, Mutable);
          if (value) {
            CFRelease(value);
          }
        }

        if (!a3)
        {
          CFArrayRemoveAllValues((CFMutableArrayRef)value);
LABEL_80:
          if (!a1[19]) {
            mDNSDynamicStoreSetConfig(5, v24, value, v57, v58, v59, v60, v61, v95);
          }
          goto LABEL_82;
        }

        uint64_t v40 = *(_BYTE **)(a3 + 40);
        CFMutableDictionaryRef v41 = CFDictionaryCreateMutable(0LL, 0LL, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
        if (v41)
        {
          uint64_t v42 = v41;
          uint64_t v43 = v40 + 4;
          bzero(cStr, 0x400uLL);
          int v95 = (_DWORD)v40 + 4;
          cStr[mDNS_snprintf(cStr) - 1] = 0;
          CFStringRef v44 = CFStringCreateWithCString(0LL, cStr, 0x8000100u);
          if (v44)
          {
            CFStringRef v50 = v44;
            CFDictionarySetValue(v42, @"FullName", v44);
            CFRelease(v50);
            if (*v43 < 2u || (SPSStatusPutNumber(v42, v40[5], v40[6], @"Type"), v40[4] < 5u))
            {
              int v52 = 1000000;
            }

            else
            {
              SPSStatusPutNumber(v42, v40[8], v40[9], @"Portability");
              unsigned int v51 = v40[4];
              if (v51 > 7)
              {
                SPSStatusPutNumber(v42, v40[11], v40[12], @"MarginalPower");
                unsigned int v51 = v40[4];
                if (v51 >= 0xB)
                {
                  SPSStatusPutNumber(v42, v40[14], v40[15], @"TotalPower");
                  unsigned int v51 = v40[4];
                }
              }

              int v52 = 1000000;
              if (v51 >= 5)
              {
                int v53 = v40[5];
                if ((v53 - 48) <= 9)
                {
                  int v54 = v40[6];
                  if ((v54 - 48) <= 9)
                  {
                    int v55 = v40[8];
                    if ((v55 - 48) <= 9)
                    {
                      int v56 = v40[9];
                      if ((v56 - 48) <= 9
                        && (v51 < 0xB
                         || v56 != 57
                         || v55 != 57
                         || v40[7] != 45
                         || v40[10] != 45
                         || v40[11] != 57
                         || v40[12] != 57
                         || v40[13] != 45
                         || v40[14] != 57
                         || v40[15] != 57))
                      {
                        int v52 = 10000 * v54
                            + 100000 * v53
                            + 1000 * v55
                            + 100 * v56
                            + 10 * v40[11]
                            + v40[12]
                            - 5333328;
                      }
                    }
                  }
                }
              }
            }

            int valuePtr = v52;
            CFNumberRef v64 = CFNumberCreate(0LL, kCFNumberSInt32Type, &valuePtr);
            if (v64)
            {
              CFNumberRef v70 = v64;
              CFDictionarySetValue(v42, @"Metric", v64);
              CFRelease(v70);
            }

            else
            {
              LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "SPSCreateDict: Could not create CFNumber",  v65,  v66,  v67,  v68,  v69,  v95);
            }

            unint64_t v73 = *v43;
            if (v73 <= 0xB) {
              goto LABEL_67;
            }
            __memcpy_chk(cStr, v40 + 17, (v73 - 12), 1024LL);
            cStr[v73 - 12] = 0;
            CFStringRef v74 = CFStringCreateWithCString(0LL, cStr, 0x8000100u);
            if (v74)
            {
              CFStringRef v75 = v74;
              CFDictionarySetValue(v42, @"PrettyName", v74);
              CFRelease(v75);
LABEL_67:
              uint64_t v76 = (const __CFArray *)value;
              v77.length = CFArrayGetCount((CFArrayRef)value);
              v77.locatiouint64_t n = 0LL;
              if (a4)
              {
                if (CFArrayContainsValue(v76, v77, v42))
                {
                  LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "UpdateSPSStatus: %s array already contains %##s",  v78,  v79,  v80,  v81,  v82,  (int)v24);
                }

                else
                {
                  int v89 = 0;
                  do
                  {
                    CFIndex v90 = v89;
                    if (CFArrayGetCount((CFArrayRef)value) <= v89) {
                      break;
                    }
                    ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex((CFArrayRef)value, v89);
                    uint64_t v92 = (const __CFNumber *)CFDictionaryGetValue(ValueAtIndex, @"Metric");
                    uint64_t v93 = (const __CFNumber *)CFDictionaryGetValue(v42, @"Metric");
                    CFComparisonResult v94 = CFNumberCompare(v92, v93, 0LL);
                    int v89 = v90 + 1;
                  }

                  while (v94 == kCFCompareLessThan);
                  CFArrayInsertValueAtIndex((CFMutableArrayRef)value, v90, v42);
                }
              }

              else
              {
                CFIndex FirstIndexOfValue = CFArrayGetFirstIndexOfValue(v76, v77, v42);
                if (FirstIndexOfValue == -1) {
                  LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "UpdateSPSStatus: %s array does not contain %##s",  v84,  v85,  v86,  v87,  v88,  (int)v24);
                }
                else {
                  CFArrayRemoveValueAtIndex((CFMutableArrayRef)value, FirstIndexOfValue);
                }
              }

              CFRelease(v42);
              goto LABEL_80;
            }

            uint64_t v71 = (os_log_s *)mDNSLogCategory_Default;
            uint64_t v72 = "SPSCreateDict: Could not create CFString spsname";
          }

          else
          {
            uint64_t v71 = (os_log_s *)mDNSLogCategory_Default;
            uint64_t v72 = "SPSCreateDict: Could not create CFString spsname full";
          }

          LogMsgWithLevel(v71, OS_LOG_TYPE_DEFAULT, v72, v45, v46, v47, v48, v49, v95);
          CFRelease(v42);
          goto LABEL_82;
        }

        uint64_t v62 = (os_log_s *)mDNSLogCategory_Default;
        uint64_t v63 = "SPSCreateDict: Could not create CFDictionary dict";
LABEL_57:
        LogMsgWithLevel(v62, OS_LOG_TYPE_DEFAULT, v63, v35, v36, v37, v38, v39, v95);
        goto LABEL_82;
      }

      uint64_t v32 = (os_log_s *)mDNSLogCategory_Default;
      uint64_t v33 = "UpdateSPSStatus: Could not create CFString ifname";
    }

    else
    {
      uint64_t v32 = (os_log_s *)mDNSLogCategory_Default;
      uint64_t v33 = "UpdateSPSStatus: Could not create CFDictionary spsStatusDict";
    }

    LogMsgWithLevel(v32, OS_LOG_TYPE_DEFAULT, v33, v19, v20, v21, v22, v23, a9);
  }

void SPSStatusPutNumber(__CFDictionary *a1, char a2, char a3, const void *a4)
{
  char valuePtr = a3 + 10 * a2 - 16;
  CFNumberRef v6 = CFNumberCreate(0LL, kCFNumberSInt8Type, &valuePtr);
  if (v6)
  {
    CFNumberRef v12 = v6;
    CFDictionarySetValue(a1, a4, v6);
    CFRelease(v12);
  }

  else
  {
    LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "SPSStatusPutNumber: Could not create CFNumber",  v7,  v8,  v9,  v10,  v11,  v13);
  }

uint64_t CloseSocketSet(uint64_t a1)
{
  int v2 = *(_DWORD *)(a1 + 16);
  if (v2 != -1)
  {
    close(v2);
    *(_DWORD *)(a1 + 16) = -1;
  }

  uint64_t result = *(unsigned int *)(a1 + 48);
  if ((_DWORD)result != -1)
  {
    uint64_t result = close(result);
    *(_DWORD *)(a1 + 48) = -1;
  }

  int v4 = *(_DWORD **)(a1 + 80);
  if (v4) {
    *int v4 = 1;
  }
  return result;
}

void SendRecordRegistration(uint64_t a1, uint64_t a2)
{
  int v4 = (unsigned __int8 *)(a2 + 8);
  AuthInfoForName_internal = GetAuthInfoForName_internal(a1, *(_BYTE **)(a2 + 40));
  if (AuthInfoForName_internal)
  {
    CFNumberRef v6 = (char *)AuthInfoForName_internal + 268;
    uint64_t v7 = -360LL;
LABEL_3:
    if (v6 < (_BYTE *)AuthInfoForName_internal + 524 && v6)
    {
      while (1)
      {
        uint64_t v8 = *v6;
        if (v8 > 0x3F)
        {
LABEL_12:
          uint64_t v7 = -360LL;
          goto LABEL_14;
        }

        if (!*v6) {
          break;
        }
        v6 += v8 + 1;
LABEL_6:
        if (!v6) {
          goto LABEL_12;
        }
      }

      uint64_t v7 = -103LL - (unsigned __int16)((_WORD)v6 - ((_WORD)AuthInfoForName_internal + 268) + 1);
    }
  }

  else
  {
    uint64_t v7 = -35LL;
  }

_WORD *putZone( unint64_t a1, unint64_t a2, unint64_t a3, unsigned __int8 *a4, unint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  __int16 v8 = a5;
  __int16 v11 = putDomainNameAsLabels(a1, a2, a3, a4, a5, a6, a7, a8);
  uint64_t v12 = 0LL;
  if (v11 && (unint64_t)(v11 + 2) <= a3)
  {
    *__int16 v11 = 1536;
    v11[1] = v8;
    ++*(_WORD *)(a1 + 4);
    return v11 + 2;
  }

  return (_WORD *)v12;
}

void *MakeTCPConn( uint64_t a1, const void *a2, unint64_t a3, uint64_t a4, int *a5, uint64_t a6, _BYTE *a7, uint64_t a8, uint64_t a9)
{
  __int16 v11 = a6;
  int v13 = a4;
  __int16 v68 = 0;
  if (a8)
  {
    int v17 = *(unsigned __int8 *)(a8 + 620);
    if ((a4 & 1) == 0) {
      goto LABEL_7;
    }
  }

  else
  {
    int v17 = 0;
    if ((a4 & 1) == 0) {
      goto LABEL_7;
    }
  }

  if (!a7 || !*a7)
  {
    LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "MakeTCPConn: TLS connection being setup with NULL hostname",  a4,  (uint64_t)a5,  a6,  (uint64_t)a7,  a8,  v65);
    return 0LL;
  }

LABEL_7:
  uint64_t v18 = calloc(1uLL, 0x2358uLL);
  if (!v18) {
    __break(1u);
  }
  uint64_t v19 = v18;
  if (a2)
  {
    uint64_t v20 = a3 - (void)a2;
    if (a3 < (unint64_t)a2 || v20 >= 8953)
    {
      unint64_t v21 = (os_log_s *)mDNSLogCategory_Default;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
      {
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_ERROR))
        {
LABEL_17:
          *(_DWORD *)buf = 134218240;
          uint64_t v71 = a2;
          __int16 v72 = 2048;
          unint64_t v73 = a3;
          _os_log_impl( (void *)&_mh_execute_header,  v21,  OS_LOG_TYPE_ERROR,  "MakeTCPConn: invalid DNS message pointers -- msg: %p, end: %p",  buf,  0x16u);
        }
      }

      else
      {
        unint64_t v21 = (os_log_s *)mDNSLogCategory_Default_redacted;
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_ERROR)) {
          goto LABEL_17;
        }
      }

    uint64_t v27 = 0;
    uint64_t v7 = domain_name_labels_create(a1, &v27);
    a2 = v27;
    if (!v27)
    {
      unint64_t v10 = *v7;
      __int16 v11 = v7;
      if (*v7)
      {
        __int16 v11 = v7;
        do
        {
          uint64_t v12 = &v11[v10];
          int v13 = v12[1];
          __int16 v11 = v12 + 1;
          unint64_t v10 = v13;
        }

        while (v13);
      }

      uint64_t v14 = v11 - v7;
      *((void *)v3 + 2) = v7;
      int v15 = 1;
      goto LABEL_12;
    }
  }

  else
  {
    __break(1u);
  }

  if (v7) {
    free(v7);
  }
  unint64_t v16 = 0LL;
  if (a3) {
LABEL_13:
  }
    *a3 = a2;
LABEL_14:
  if (v3) {
    ref_count_obj_release(v3);
  }
  return v16;
}

  if (a6) {
    *a6 = v22;
  }
  return v21;
}

  os_release(v7);
  return v9;
}

  uint64_t result = (v2 + 1);
  *(_DWORD *)(a1 + 264) = result;
  return result;
}

  v8[0] = _NSConcreteStackBlock;
  v8[1] = 0x40000000LL;
  v8[2] = ___mdns_dns_service_manager_probe_discovered_service_block_invoke_2;
  v8[3] = &unk_10013B0A0;
  uint64_t v7 = *(_OWORD *)(a1 + 48);
  uint64_t v9 = *(_OWORD *)(a1 + 32);
  unint64_t v10 = v7;
  if (_mdns_dns_service_queue_s_once != -1) {
    dispatch_once(&_mdns_dns_service_queue_s_once, &__block_literal_global_237);
  }
  sec_protocol_options_set_verify_block(v4, v8, (dispatch_queue_t)_mdns_dns_service_queue_s_queue);
  sec_release(v4);
}

  *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = result;
  return result;
}

  _Block_object_dispose(&v11, 8);
  _Block_object_dispose(&v15, 8);
  return v6;
}

  __int16 v8 = mach_continuous_time() - *(void *)(a1 + 40);
  if (v8 >= 0)
  {
    uint64_t v9 = 0;
    LODWORD(v6) = 0;
    *(void *)(a1 + 32) = 0LL;
    *(void *)(a1 + 40) = 0LL;
    uint64_t result = 1LL;
    if (!a2) {
      goto LABEL_17;
    }
LABEL_16:
    *a2 = v6;
    goto LABEL_17;
  }

  __int16 v11 = mdns_ticks_to_milliseconds(-v8);
  uint64_t result = 0LL;
  uint64_t v9 = -1;
  if (v11 < 0xFFFFFFFF) {
    uint64_t v9 = v11;
  }
  if (HIDWORD(v11)) {
    LODWORD(v6) = -6737;
  }
  else {
    LODWORD(v6) = -6760;
  }
  if (a2) {
    goto LABEL_16;
  }
LABEL_17:
  if (a3) {
    *a3 = v9;
  }
  return result;
}

void *mDNSPlatformTCPSocket(int a1, int a2, _WORD *a3, _BYTE *a4, int a5)
{
  int v43 = 0x4000;
  if (a4) {
    size_t v10 = 344LL;
  }
  else {
    size_t v10 = 88LL;
  }
  __int16 v11 = (char *)calloc(1uLL, v10);
  if (!v11) {
    __break(1u);
  }
  uint64_t v12 = v11;
  if (a4)
  {
    int v13 = v11 + 88;
    v12[6] = v12 + 11;
    uint64_t v14 = a4;
    if (a4 == (_BYTE *)-256LL)
    {
LABEL_8:
      while (v14)
      {
        uint64_t v15 = *v14;
        if (!*v14)
        {
          unsigned __int16 v16 = (_WORD)v14 - (_WORD)a4 + 1;
          if (v16 > 0x100u) {
            break;
          }
          memcpy(v13, a4, v16);
          goto LABEL_16;
        }

        v14 += v15 + 1;
        if (a4 != (_BYTE *)-256LL) {
          goto LABEL_7;
        }
      }
    }

    else
    {
LABEL_7:
      if (v14 < a4 + 256) {
        goto LABEL_8;
      }
    }

    *int v13 = 0;
  }

LABEL_16:
  if (a2 == 4) {
    int v17 = 2;
  }
  else {
    int v17 = 30;
  }
  int v45 = 15384;
  int v18 = socket(v17, 1, 6);
  int v19 = v18;
  if (v18 <= 2)
  {
    if (*__error() != 47)
    {
      uint64_t v20 = (os_log_s *)mDNSLogCategory_Default;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
      {
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
        {
LABEL_43:
          int v27 = *__error();
          int v28 = __error();
          uint64_t v29 = strerror(*v28);
          *(_DWORD *)&v48[0].sa_leuint64_t n = 67109634;
          *(_DWORD *)&v48[0].sa_data[2] = v19;
          *(_WORD *)&v48[0].sa_data[6] = 1024;
          *(_DWORD *)&v48[0].sa_data[8] = v27;
          *(_WORD *)&v48[0].sa_data[12] = 2082;
          *(void *)&v48[1].sa_leuint64_t n = v29;
          _os_log_impl( (void *)&_mh_execute_header,  v20,  OS_LOG_TYPE_DEFAULT,  "mDNSPosixTCPSocketSetup: socket error %d errno %d (%{public}s)",  &v48[0].sa_len,  0x18u);
        }
      }

      else
      {
        uint64_t v20 = (os_log_s *)mDNSLogCategory_Default_redacted;
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_43;
        }
      }
    }

    int v19 = -1;
    goto LABEL_45;
  }

  memset(v48, 0, 28);
  if (a3)
  {
    int v21 = a2 == 4 ? 16 : 28;
    *(_OWORD *)&v48[0].sa_data[10] = 0uLL;
    *(void *)&v48[0].sa_data[2] = 0LL;
    v48[0].sa_family = v17;
    v48[0].sa_leuint64_t n = v21;
    *(_WORD *)v48[0].sa___int16 data = *a3;
    if (bind(v18, v48, v21) < 0)
    {
      uint64_t v23 = (os_log_s *)mDNSLogCategory_Default;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_68;
        }
      }

      else
      {
        uint64_t v23 = (os_log_s *)mDNSLogCategory_Default_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_68;
        }
      }

      uint64_t v33 = __error();
      uint64_t v34 = strerror(*v33);
      *(_DWORD *)buf = 136446210;
      uint64_t v47 = v34;
      uint64_t v26 = "mDNSPosixTCPSocketSetup getsockname: %{public}s";
      goto LABEL_67;
    }
  }

  socklen_t v44 = 28;
  if (getsockname(v19, v48, &v44) < 0)
  {
    uint64_t v23 = (os_log_s *)mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_68;
      }
    }

    else
    {
      uint64_t v23 = (os_log_s *)mDNSLogCategory_Default_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_68;
      }
    }

    uint64_t v24 = __error();
    uint64_t v25 = strerror(*v24);
    *(_DWORD *)buf = 136446210;
    uint64_t v47 = v25;
    uint64_t v26 = "mDNSPosixTCPSocketSetup getsockname: %{public}s";
LABEL_67:
    _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, v26, buf, 0xCu);
    goto LABEL_68;
  }

  __int16 v22 = *(_WORD *)v48[0].sa_data;
  *(_WORD *)uint64_t v12 = *(_WORD *)v48[0].sa_data;
  if (a3) {
    *a3 = v22;
  }
  if (setsockopt(v19, 6, 513, &v45, 4u) < 0)
  {
    uint64_t v23 = (os_log_s *)mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
      {
LABEL_66:
        uint64_t v35 = __error();
        uint64_t v36 = strerror(*v35);
        *(_DWORD *)buf = 136446210;
        uint64_t v47 = v36;
        uint64_t v26 = "mDNSPosixTCPSocketSetup: TCP_NOTSENT_LOWAT failed: %{public}s";
        goto LABEL_67;
      }
    }

    else
    {
      uint64_t v23 = (os_log_s *)mDNSLogCategory_Default_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_66;
      }
    }

  uDNS_StopWABQueries(2, v16, v17, v18, v19, v20, v21, v22);
  mDNS_Lock_((unsigned int *)mDNSStorage, (uint64_t)"mDNS_StopDomainEnumeration", 16165);
  uint64_t v33 = qword_10015C2C0;
  if (qword_10015C2C0)
  {
    while (!SameDomainNameBytes((_BYTE *)v33, "\x05local"))
    {
      uint64_t v33 = *(void *)(v33 + 296);
      if (!v33) {
        goto LABEL_23;
      }
    }

    uint64_t v34 = *(void *)(v33 + 272);
    if (v34)
    {
      uint64_t v35 = *(_DWORD *)(v34 + 668);
      if (v35)
      {
        *(_DWORD *)(v34 + 668) = v35 - 1;
        mDNS_SetUpDomainEnumeration((unsigned int *)mDNSStorage, v33, 2);
      }
    }
  }

    mDNS_Unlock_((uint64_t)mDNSStorage, (uint64_t)"conflictWithCacheRecordsOrFlush", 2068);
    return 0LL;
  }

  return result;
}

  __int16 v8 = (os_log_s *)mDNSLogCategory_Default;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
  {
    size_t v10 = os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT);
    uint64_t result = 0LL;
    if (!v10) {
      return result;
    }
    uint64_t v15 = 0;
    __int16 v11 = (uint8_t *)&v15;
    goto LABEL_25;
  }

  __int16 v8 = (os_log_s *)mDNSLogCategory_Default_redacted;
  uint64_t v12 = os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT);
  int v13 = v12;
  uint64_t result = 0LL;
  if (v13)
  {
    uint64_t v14 = 0;
    __int16 v11 = (uint8_t *)&v14;
LABEL_25:
    _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "IsEntitled: Client is missing Entitlement!",  v11,  2u);
    return 0LL;
  }

  return result;
}

        ref_count_obj_release(v15);
        goto LABEL_17;
      }
    }

    int v17 = 0;
    *(_DWORD *)buf = 0;
    goto LABEL_15;
  }

  return v1;
}

  uint64_t v52 = 1;
  if (sa_family == 2)
  {
    if (!setsockopt(v14, 0xFFFF, 4226, &v52, 4u)) {
      goto LABEL_43;
    }
    if (*__error())
    {
      uint64_t v15 = *__error();
      if (!v15) {
        goto LABEL_43;
      }
    }

    else
    {
      uint64_t v15 = -6700;
    }

    if (_mdns_resolver_log_s_once != -1) {
      dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_48);
    }
    uint64_t v34 = (os_log_s *)_mdns_resolver_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_ERROR))
    {
      v53[0].val[0] = 67109120;
      v53[0].val[1] = v15;
      _os_log_error_impl( (void *)&_mh_execute_header,  v34,  OS_LOG_TYPE_ERROR,  "setsockopt() for SOL_SOCKET/SO_RANDOMPORT failed %{darwin.errno}d",  (uint8_t *)v53,  8u);
    }
  }

  else
  {
    uint64_t v50 = a4;
    uint64_t v51 = v12;
    int v17 = a5;
    int v18 = 0;
    *(void *)&v53[0].val[2] = 0LL;
    *(void *)&v53[0].val[4] = 0LL;
    v53[0].val[6] = 0;
    *(void *)v53[0].val = 7708LL;
    *(in6_addr *)&v53[0].val[2] = in6addr_any;
    while (1)
    {
      int v19 = arc4random() | 0xFFFFC000;
      HIWORD(v53[0].val[0]) = bswap32(v19) >> 16;
      if (!bind(v14, (const sockaddr *)v53, 0x1Cu))
      {
        uint64_t v20 = 0;
        goto LABEL_32;
      }

      if (!*__error()) {
        break;
      }
      uint64_t v20 = *__error();
      int v21 = v18 + 1;
      if (v20 != 48 || v18++ >= 0x270F) {
        goto LABEL_33;
      }
    }

    uint64_t v20 = -6700;
LABEL_32:
    int v21 = v18 + 1;
LABEL_33:
    if (v20)
    {
      if (_mdns_resolver_log_s_once != -1) {
        dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_48);
      }
      uint64_t v23 = (os_log_s *)_mdns_resolver_log_s_log;
      if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 134218240;
        *(void *)uint64_t v56 = v20;
        *(_WORD *)&v56[8] = 1024;
        uint64_t v57 = v21;
        _os_log_error_impl( (void *)&_mh_execute_header,  v23,  OS_LOG_TYPE_ERROR,  "Binding IPv6 socket to random port failed -- error: %{mdns:err}ld, tries: %d",  buf,  0x12u);
      }
    }

    else
    {
      if (_mdns_resolver_log_s_once != -1) {
        dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_48);
      }
      uint64_t v24 = (os_log_s *)_mdns_resolver_log_s_log;
      if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 67109376;
        *(_DWORD *)uint64_t v56 = (unsigned __int16)v19;
        *(_WORD *)&v56[4] = 1024;
        *(_DWORD *)&v56[6] = v21;
        _os_log_debug_impl( (void *)&_mh_execute_header,  v24,  OS_LOG_TYPE_DEBUG,  "Binding IPv6 socket to random port succeeded -- port: %u, tries: %d",  buf,  0xEu);
      }
    }

    a5 = v17;
    a4 = v50;
    uint64_t v12 = v51;
  }

  mDNS_StopQuery((unsigned int *)&mDNSStorage, *(void *)(a1 + 96));
  size_t v10 = *(void **)(a1 + 96);
  if (v10)
  {
    free(v10);
    *(void *)(a1 + 96) = 0LL;
  }

  mDNSPlatformTriggerDNSRetry(v12, v11, a3, a4, a5, a6, a7, a8, v15);
  int v13 = *(void **)(a1 + 16);
  if (v13)
  {
    free(v13);
    *(void *)(a1 + 16) = 0LL;
  }

  uint64_t v14 = *(void **)(a1 + 24);
  if (v14)
  {
    free(v14);
    *(void *)(a1 + 24) = 0LL;
  }

uint64_t mDNSPlatformTCPConnect(uint64_t a1, _DWORD *a2, __int16 a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  *(void *)(a1 + 8) = a5;
  *(void *)(a1 + 56) = a6;
  *(_WORD *)(a1 + 64) = 0;
  *(_DWORD *)(a1 + 68) = 0;
  *(_DWORD *)(a1 + 80) = 0;
  uint64_t v9 = a2 + 1;
  if (*a2 == 4)
  {
    v49[0].sa_family = 2;
    *(_WORD *)v49[0].sa___int16 data = a3;
    *(_DWORD *)&v49[0].sa_data[2] = *v9;
    socklen_t v10 = 16;
  }

  else
  {
    memset(&v49[0].sa_data[6], 0, 20);
    *(void *)&v49[0].sa_leuint64_t n = 7680LL;
    *(_WORD *)v49[0].sa___int16 data = a3;
    *(sockaddr *)&v49[0].sa_data[6] = *(sockaddr *)v9;
    socklen_t v10 = 28;
  }

  v49[0].sa_leuint64_t n = v10;
  if (KQueueSet(*(_DWORD *)(a1 + 16), 1u, -2, (void *)(a1 + 24)))
  {
    __int16 v11 = (os_log_s *)mDNSLogCategory_NAT;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_NAT == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_NAT, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        goto LABEL_20;
      }
    }

    else
    {
      __int16 v11 = (os_log_s *)mDNSLogCategory_NAT_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_NAT_redacted, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
LABEL_20:
        _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "ERROR: mDNSPlatformTCPConnect - KQueueSet failed",  buf,  2u);
      }
    }

    return *__error();
  }

  int v12 = *(_DWORD *)(a1 + 16);
  int v13 = fcntl(v12, 3, 0LL);
  if (fcntl(v12, 4, v13 | 4u) < 0)
  {
    int v21 = (os_log_s *)mDNSLogCategory_NAT;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_NAT == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_NAT, OS_LOG_TYPE_DEFAULT))
      {
LABEL_36:
        uint64_t v23 = __error();
        uint64_t v24 = strerror(*v23);
        *(_DWORD *)buf = 136446210;
        *(void *)socklen_t v44 = v24;
        _os_log_impl( (void *)&_mh_execute_header,  v21,  OS_LOG_TYPE_DEFAULT,  "ERROR: setsockopt O_NONBLOCK - %{public}s",  buf,  0xCu);
      }
    }

    else
    {
      int v21 = (os_log_s *)mDNSLogCategory_NAT_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_NAT_redacted, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_36;
      }
    }

    return 4294901759LL;
  }

  if (!a4)
  {
LABEL_30:
    if ((connect(*(_DWORD *)(a1 + 16), v49, v10) & 0x80000000) == 0)
    {
      __int16 v22 = (os_log_s *)mDNSLogCategory_NAT;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_NAT == mDNSLogCategory_State)
      {
        uint64_t v19 = 0LL;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT, OS_LOG_TYPE_DEFAULT)) {
          return v19;
        }
        *(_WORD *)buf = 0;
      }

      else
      {
        __int16 v22 = (os_log_s *)mDNSLogCategory_NAT_redacted;
        uint64_t v19 = 0LL;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT_redacted, OS_LOG_TYPE_DEFAULT)) {
          return v19;
        }
        *(_WORD *)buf = 0;
      }

      _os_log_impl( (void *)&_mh_execute_header,  v22,  OS_LOG_TYPE_DEFAULT,  "NOTE: mDNSPlatformTCPConnect completed synchronously",  buf,  2u);
      return 0LL;
    }

    uint64_t v19 = 4294901508LL;
    if (*__error() == 36) {
      return 4294901509LL;
    }
    if (*__error() == 65 || *__error() == 49 || *__error() == 50)
    {
      uint64_t v25 = mDNSLogCategory_NAT;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_NAT == mDNSLogCategory_State)
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT, OS_LOG_TYPE_DEFAULT)) {
          return v19;
        }
      }

      else
      {
        uint64_t v25 = mDNSLogCategory_NAT_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT_redacted, OS_LOG_TYPE_DEFAULT)) {
          return v19;
        }
      }

      int v30 = *(_DWORD *)(a1 + 16);
      int v31 = *__error();
      int v32 = __error();
      uint64_t v33 = strerror(*v32);
      *(_DWORD *)buf = 67109634;
      *(_DWORD *)socklen_t v44 = v30;
      *(_WORD *)&v44[4] = 1024;
      *(_DWORD *)&v44[6] = v31;
      __int16 v45 = 2082;
      uint64_t v46 = v33;
      int v28 = "ERROR: mDNSPlatformTCPConnect - connect failed: socket %d: Error %d (%{public}s)";
      uint64_t v34 = (os_log_s *)v25;
      uint32_t v35 = 24;
    }

    else
    {
      uint64_t v38 = mDNSLogCategory_NAT;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_NAT == mDNSLogCategory_State)
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT, OS_LOG_TYPE_DEFAULT)) {
          return v19;
        }
      }

      else
      {
        uint64_t v38 = mDNSLogCategory_NAT_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT_redacted, OS_LOG_TYPE_DEFAULT)) {
          return v19;
        }
      }

      int v39 = *(_DWORD *)(a1 + 16);
      int v40 = *__error();
      uint64_t v41 = __error();
      uint64_t v42 = strerror(*v41);
      *(_DWORD *)buf = 67109890;
      *(_DWORD *)socklen_t v44 = v39;
      *(_WORD *)&v44[4] = 1024;
      *(_DWORD *)&v44[6] = v40;
      __int16 v45 = 2082;
      uint64_t v46 = v42;
      __int16 v47 = 1024;
      sa_leuint64_t n = v49[0].sa_len;
      int v28 = "ERROR: mDNSPlatformTCPConnect - connect failed: socket %d: Error %d (%{public}s) length %d";
      uint64_t v34 = (os_log_s *)v38;
      uint32_t v35 = 30;
    }

uint64_t tcpKQSocketCallback( int a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  *(_DWORD *)(a3 + 80) = 0;
  if (a2 != -2) {
    goto LABEL_18;
  }
  if (*(_BYTE *)(a3 + 65))
  {
    if (mDNS_LoggingEnabled == 1)
    {
      uint64_t v9 = (os_log_s *)mDNSLogCategory_Default;
      socklen_t v10 = "ERROR: TCPConnectCallback called with write event when socket is connected.";
LABEL_11:
      LogMsgWithLevel(v9, OS_LOG_TYPE_DEFAULT, v10, a4, a5, a6, a7, a8, v31);
    }
  }

  else
  {
    socklen_t v32 = 4;
    __errunsigned int num = 0;
    if (getsockopt(a1, 0xFFFF, 4103, &__errnum, &v32) < 0)
    {
      if (mDNS_LoggingEnabled == 1)
      {
        uint64_t v14 = (os_log_s *)mDNSLogCategory_Default;
        int v15 = *(_DWORD *)(a3 + 16);
        __error();
        unsigned __int16 v16 = __error();
        strerror(*v16);
        LogMsgWithLevel( v14,  OS_LOG_TYPE_DEFAULT,  "ERROR: TCPConnectCallback - unable to get connect error: socket %d: Error %d (%s)",  v17,  v18,  v19,  v20,  v21,  v15);
      }

      *(_DWORD *)(a3 + 80) = -65788;
      goto LABEL_15;
    }

    int v11 = __errnum;
    if (__errnum)
    {
      *(_DWORD *)(a3 + 80) = -65788;
      if ((v11 - 49) > 0x10 || ((1 << (v11 - 49)) & 0x10003) == 0 || mDNS_LoggingEnabled == 1)
      {
        uint64_t v12 = mDNSLogCategory_Default;
        int v13 = *(_DWORD *)(a3 + 16);
        strerror(v11);
        int v31 = v13;
        socklen_t v10 = "ERROR: TCPConnectCallback - connect failed: socket %d: Error %d (%s)";
        uint64_t v9 = (os_log_s *)v12;
        goto LABEL_11;
      }
    }
  }

LABEL_15:
  KQueueSet(*(_DWORD *)(a3 + 16), 2u, -2, (void *)(a3 + 24));
  if (!*(_DWORD *)(a3 + 80) && KQueueSet(*(_DWORD *)(a3 + 16), 1u, -1, (void *)(a3 + 24)))
  {
    LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "ERROR: tcpKQSocketCallback - KQueueSet failed",  v22,  v23,  v24,  v25,  v26,  v31);
    *(_DWORD *)(a3 + 80) = -65562;
  }

      *((_DWORD *)v5 + 12) = v12;
      uint64_t v14 = v5[4];
      if (v14)
      {
        if (*v10 - 65 >= 0x1A)
        {
          unsigned __int16 v16 = 1LL;
          while (v14 != v16)
          {
            uint64_t v17 = v10[v16++] - 65;
            if (v17 <= 0x19)
            {
              uint64_t v18 = v16 - 1;
              goto LABEL_24;
            }
          }

          uint64_t v18 = v5[4];
LABEL_24:
          int v15 = v18 >= v14;
        }

        else
        {
          int v15 = 0;
        }
      }

      else
      {
        int v15 = 1;
      }

      int v4 = 0LL;
      uint64_t v19 = 0;
      *((_BYTE *)v5 + 61) = v15;
    }
  }

  else
  {
    uint64_t v19 = -6728;
  }

  if (a2) {
    *a2 = v19;
  }
  if (v4) {
    os_release(v4);
  }
  return v5;
}

  int v15 = DomainNameToString(v6, 0LL, a2, 0LL);
  uint64_t result = 0LL;
  if (!v15)
  {
    unsigned __int16 v16 = strlen((const char *)a2);
    if (v16)
    {
      if (a2[v16 - 1] == 46) {
        a2[v16 - 1] = 0;
      }
    }

    return a2;
  }

  return result;
}

  if (a5) {
    *a5 = v12;
  }
  if (v5) {
    ref_count_obj_release((void *)v5);
  }
  return v19;
}

  if (*(_BYTE *)(a1 + 72))
  {
    uint64_t v12 = 0LL;
    while (!ref_count_obj_compare(*(void *)(a1 + 48 + 8 * v12), *(void *)(a2 + 48 + 8 * v12), 1LL))
    {
      ++v12;
      int v13 = *(unsigned __int8 *)(a1 + 72);
      if (v12 >= v13)
      {
        if (!*(_BYTE *)(a1 + 72)) {
          return 0LL;
        }
        uint64_t v14 = 0LL;
        while (!*(_BYTE *)(a1 + v14 + 104))
        {
LABEL_26:
          uint64_t result = 0LL;
        }

        int v15 = 0LL;
        while (!ref_count_obj_compare( *(void *)(*(void *)(a1 + 8 * v14 + 80) + 8 * v15),  *(void *)(*(void *)(a2 + 8 * v14 + 80) + 8 * v15),  1LL))
        {
          if (++v15 >= (unint64_t)*(unsigned __int8 *)(a1 + v14 + 104))
          {
            LODWORD(v13) = *(unsigned __int8 *)(a1 + 72);
            goto LABEL_26;
          }
        }

        return 2LL;
      }
    }

    return 2LL;
  }

  return 0LL;
}

  (*(void (**)(uint64_t, void))(a4 + 16))(a4, 0LL);
  if (v6) {
LABEL_6:
  }
    CFRelease(v6);
}

    v12[0] = 67110147;
    v12[1] = v5;
    int v13 = 1024;
    uint64_t v14 = v6;
    int v15 = 2160;
    unsigned __int16 v16 = 1752392040LL;
    uint64_t v17 = 1040;
    uint64_t v18 = v8;
    uint64_t v19 = 2101;
    uint64_t v20 = v7;
    _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEBUG,  "[Q%u->SubQ%u] Stop DS denial look up question - DS denial lookup name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P",  (uint8_t *)v12,  0x28u);
  }

  if (*(_WORD *)(a1 + 132))
  {
    if (!v29)
    {
      uint64_t v18 = *(void *)(v2 + 40);
      if (v18)
      {
        if (*(_BYTE *)(v2 + 102))
        {
          uint64_t v19 = *(void *)(a1 + 120);
          if (_mdns_push_notifications_log_s_once != -1) {
            dispatch_once(&_mdns_push_notifications_log_s_once, &__block_literal_global_6664);
          }
          uint64_t v20 = (os_log_s *)_mdns_push_notifications_log_s_log;
          if (os_log_type_enabled((os_log_t)_mdns_push_notifications_log_s_log, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v21 = *(void *)(v18 + 40);
            *(_DWORD *)buf = 134218754;
            *(void *)&uint8_t buf[4] = v19;
            *(_WORD *)&buf[12] = 2048;
            *(void *)&buf[14] = v21;
            *(_WORD *)&buf[22] = 2112;
            int v31 = (void *)v2;
            *(_WORD *)socklen_t v32 = 2112;
            *(void *)&v32[2] = a1;
            _os_log_impl( (void *)&_mh_execute_header,  v20,  OS_LOG_TYPE_DEFAULT,  "[Sub%llu->DSO%llu] Subscriber removed and unsubscribing from the session -- server: %@, subscriber: %@",  buf,  0x2Au);
          }

          uint64_t v22 = _os_object_alloc(&OBJC_CLASS___OS_mdns_dso_unsubscribe_message_builder, 40LL);
          uint64_t v23 = (_WORD *)v22;
          if (v22)
          {
            uint64_t v24 = &_mdns_dso_unsubscribe_message_builder_kind;
            *(void *)(v22 + 16) = &_mdns_dso_unsubscribe_message_builder_kind;
            do
            {
              uint64_t v25 = (void (*)(_WORD *))v24[2];
              if (v25) {
                v25(v23);
              }
              uint64_t v24 = (_UNKNOWN **)*v24;
            }

            while (v24);
          }

          v23[14] = 0;
          v23[16] = *(_WORD *)(a1 + 132);
          message = (dispatch_object_s **)mdns_dso_message_builder_create_message((uint64_t)v23);
          mdns_dso_session_send(*(void **)(v2 + 40), message[3]);
          os_release(message);
          os_release(v23);
          uint64_t v27 = *(void **)(v2 + 40);
          if ((*(unsigned int (**)(void *))(v27[2] + 104LL))(v27))
          {
            os_retain(v27);
            if (_mdns_dso_session_queue_s_once != -1) {
              dispatch_once(&_mdns_dso_session_queue_s_once, &__block_literal_global_66);
            }
            *(void *)buf = _NSConcreteStackBlock;
            *(void *)&buf[8] = 0x40000000LL;
            *(void *)&uint8_t buf[16] = __mdns_dso_session_remove_activity_block_invoke;
            int v31 = &__block_descriptor_tmp_4_5950;
            *(void *)socklen_t v32 = v27;
            dispatch_async((dispatch_queue_t)_mdns_dso_session_queue_s_queue, buf);
          }
        }
      }
    }

    *(_WORD *)(a1 + 132) = 0;
  }

  int v15 = *(dispatch_object_s **)(a1 + 88);
  if (v15)
  {
    dispatch_source_cancel(*(dispatch_source_t *)(a1 + 88));
    dispatch_release(v15);
    *(void *)(a1 + 88) = 0LL;
  }

  unsigned __int16 v16 = *(const void **)(a1 + 104);
  *(void *)(a1 + 104) = 0LL;
  if (v16)
  {
    uint64_t v17 = *(dispatch_queue_s **)(a1 + 24);
    if (v17)
    {
      v28[0] = _NSConcreteStackBlock;
      v28[1] = 0x40000000LL;
      v28[2] = ___mdns_subscriber_invalidate_block_invoke;
      v28[3] = &unk_10013E9D8;
      v28[4] = v16;
      dispatch_async(v17, v28);
    }

    _Block_release(v16);
  }

LABEL_18:
  if ((*(_BYTE *)(a3 + 4) & 1) != 0)
  {
    uint64_t v27 = 4294901752LL;
    *(_DWORD *)(a3 + 80) = -65544;
    BOOL v28 = *(_BYTE *)(a3 + 65) == 0;
  }

  else
  {
    uint64_t v27 = *(unsigned int *)(a3 + 80);
    BOOL v28 = *(_BYTE *)(a3 + 65) == 0;
    if (*(_BYTE *)(a3 + 65)) {
      BOOL v29 = 0;
    }
    else {
      BOOL v29 = (_DWORD)v27 == 0;
    }
    if (v29)
    {
      uint64_t v27 = 0LL;
      BOOL v28 = 1LL;
      *(_BYTE *)(a3 + 65) = 1;
    }
  }

  return (*(uint64_t (**)(uint64_t, void, BOOL, uint64_t))(a3 + 8))(a3, *(void *)(a3 + 56), v28, v27);
}

  [v7 statusCode];
  uint64_t v19 = [v20 _createDispatchData];
  (*(void (**)(void))(*(void *)(a1 + 40) + 16LL))();
}

      LogMsgWithLevel(v29, OS_LOG_TYPE_DEFAULT, v36, v31, v32, v33, v34, v35, v40);
      return;
    }

    if (mDNSSendDNSMessage( a1,  (unint64_t)v7,  updated,  0LL,  0LL,  0LL,  (int *)(*(void *)(a2 + 376) + 788LL),  *(_WORD *)(*(void *)(a2 + 376) + 786LL),  a4,  0))
    {
      if (!mDNS_LoggingEnabled) {
        return;
      }
      BOOL v29 = (os_log_s *)mDNSLogCategory_Default;
      int v30 = (_BYTE *)(a1 + 46976);
      GetRRDisplayString_rdb((unsigned __int8 *)(a2 + 8), (unsigned __int16 *)(*(void *)(a2 + 48) + 4LL), v30);
      int v40 = (int)v30;
      BOOL v36 = "SendGroupRRMessage: Cannot send UDP message for %s";
      goto LABEL_18;
    }

    if (mDNS_LoggingEnabled) {
      LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "SendGroupRRMessage: Sent a group UDP update ID: %d start %p, end %p, limit %p",  v24,  v25,  v26,  v27,  v28,  bswap32(*v7) >> 16);
    }
  }

  else
  {
    LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "SendGroupRRMessage: ERROR: Could not put lease option, failing the group registration",  v9,  v10,  v11,  v12,  v13,  v39);
    for (uint64_t i = *(void *)(a1 + 12624); i; uint64_t i = *(void *)i)
    {
      *(_DWORD *)(i + 596) = 1;
      *(void *)(i + 224) = 0LL;
      ActivateUnicastRegistration(a1, i);
    }
  }

  if (!(_DWORD)info)
  {
    uint64_t v24 = DWORD2(v30);
    uint64_t v25 = HIDWORD(v29);
    uint64_t v26 = HIDWORD(v30);
    *(_DWORD *)(a5 + 8) = DWORD1(v30) - 1;
    *(_DWORD *)(a5 + 12) = v24;
    *(_WORD *)(a5 + 16) = v25 >> SBYTE3(v28[0]);
    *(void *)a5 = mDNSPlatformInterfaceIDfromInterfaceIndex(v26, v11, v12, v13, v14, v15, v16, v17);
  }

  return info;
}

      v11[0] = 68158466;
      v11[1] = v8;
      uint64_t v12 = 2098;
      int v13 = v5;
      uint64_t v14 = 1024;
      int v15 = a2;
      unsigned __int16 v16 = 1024;
      uint64_t v17 = a3;
      _os_log_debug_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEBUG,  "unicast assist auth_add %{public, mdnsresponder:domain_name}.*P qhash %x ifid %2.2d",  (uint8_t *)v11,  0x1Eu);
    }

    return [(id)s_presense addQhash:a2 forInterface:a3];
  }

  return result;
}

  int v11 = *(void **)(a1 + 104);
  if (v11)
  {
    ref_count_obj_release(v11);
    *(void *)(a1 + 104) = 0LL;
  }

        *(_DWORD *)buf = 67110147;
        uint64_t v20 = v12;
        uint64_t v21 = 1024;
        uint64_t v22 = v13;
        uint64_t v23 = 2160;
        uint64_t v24 = 1752392040LL;
        uint64_t v25 = 1040;
        uint64_t v26 = v14;
        uint64_t v27 = 2101;
        BOOL v28 = v15;
        _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_INFO,  "[Q%u->SubQ%u] Searching for DS denial - q_name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P",  buf,  0x28u);
      }
    }
  }

  return v18;
}

  if ((v2 & 8) != 0)
  {
LABEL_25:
    uint64_t v26 = (v19 + 131) & 0xFFFFFFFFFFFFFF80LL;
    uint64_t v20 = 4294960553LL;
    if (v26 <= v19) {
      return v20;
    }
    if (v26 > 0x200) {
      return v20;
    }
    uint64_t v20 = 4294960554LL;
    if (v19 <= v15 || v19 - v15 < 0xB) {
      return v20;
    }
    uint64_t v27 = (char *)v32 + v19;
    BOOL v28 = (char *)((char *)v32 + v26 - v27);
    bzero(v27, (size_t)v28);
    *(_WORD *)(v13 + 13) = bswap32(v32 + v26 - v13 - 15) >> 16;
    *(_WORD *)uint64_t v27 = 3072;
    v27[2] = (unsigned __int16)((_WORD)v28 - 4) >> 8;
    v27[3] = (_BYTE)v28 - 4;
    uint64_t v19 = v26;
  }

void tcpCallback(uint64_t a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = a4;
  char v106 = 0;
  uint64_t v12 = *(void *)a2;
  uint64_t v13 = *(void *)(a2 + 8976);
  if (v13)
  {
    uint64_t v14 = (void *)(v13 + 112);
  }

  else
  {
    uint64_t v15 = *(void *)(a2 + 8984);
    if (!v15)
    {
      uint64_t v14 = 0LL;
      char v16 = 1;
      if ((_DWORD)a4) {
        goto LABEL_8;
      }
      goto LABEL_24;
    }

    uint64_t v14 = (void *)(v15 + 384);
  }

  if (*v14 != a2) {
    LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "tcpCallback: %d backpointer %p incorrect tcpInfo %p question %p rr %p",  a4,  a5,  a6,  a7,  a8,  *(_DWORD *)(*(void *)(a2 + 8) + 16LL));
  }
  char v16 = 0;
  if (v8)
  {
LABEL_8:
    if ((v16 & 1) == 0) {
      *uint64_t v14 = 0LL;
    }
    mDNS_Lock_((unsigned int *)v12, (uint64_t)"tcpCallback", 1541);
    if (!v13) {
      goto LABEL_144;
    }
    int v18 = *(_DWORD *)(v13 + 212);
    if (v18)
    {
      int v19 = *(_DWORD *)(v13 + 208) + v18;
      int v20 = *(_DWORD *)(v12 + 64);
      int v21 = v19 - v20;
      if (*(_BYTE *)(v13 + 612)) {
        int v22 = 900000;
      }
      else {
        int v22 = 3600000;
      }
      if (v21 > v22)
      {
        *(_DWORD *)(v13 + 208) = v20;
        *(_DWORD *)(v13 + 212) = v22;
        SetNextQueryTime(v12, v13);
        uint64_t v23 = (os_log_s *)mDNSLogCategory_Default;
        DNSTypeName(*(unsigned __int16 *)(v13 + 322));
        LogMsgWithLevel( v23,  OS_LOG_TYPE_DEFAULT,  "tcpCallback: stream connection for %##s (%s) failed, retrying in %d ms",  v24,  v25,  v26,  v27,  v28,  v13 + 356);
      }
    }

    else
    {
      *(_DWORD *)(v13 + 208) = *(_DWORD *)(v12 + 64);
      if (*(_BYTE *)(v13 + 612))
      {
        __int32 v29 = *(__int16 *)(v13 + 328);
        *(_DWORD *)(v13 + 212) = 334;
        if (v29 == -1) {
          goto LABEL_40;
        }
        v17.i32[0] = v29;
        int32x4_t v30 = (int32x4_t)xmmword_1001007E0;
        unsigned int v31 = (v29 & 0xFFFFFFFC) + 4;
        v32.i64[0] = 0x300000003LL;
        v32.i64[1] = 0x300000003LL;
        do
        {
          int8x16_t v33 = (int8x16_t)v30;
          int32x4_t v30 = vmulq_s32(v30, v32);
          v31 -= 4;
        }

        while (v31);
        int8x16_t v34 = vbslq_s8( (int8x16_t)vcgtq_u32( (uint32x4_t)vorrq_s8( (int8x16_t)vdupq_n_s32(v29 & 0xFFFFFFFC),  (int8x16_t)xmmword_1001007F0),  (uint32x4_t)vdupq_lane_s32(v17, 0)),  v33,  (int8x16_t)v30);
        *(int32x2_t *)v34.i8 = vmul_s32(*(int32x2_t *)v34.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v34, v34, 8uLL));
        *(_DWORD *)(v13 + 212) = v34.i32[0] * v34.i32[1];
        if (v34.i32[0] * v34.i32[1] <= 900000) {
LABEL_40:
        }
          *(_WORD *)(v13 + 328) = v29 + 1;
        else {
          *(_DWORD *)(v13 + 212) = 900000;
        }
        uint64_t v50 = (os_log_s *)mDNSLogCategory_Default;
        DNSTypeName(*(unsigned __int16 *)(v13 + 322));
        LogMsgWithLevel( v50,  OS_LOG_TYPE_DEFAULT,  "tcpCallback: stream connection for LLQ %##s (%s) failed %d times, retrying in %d ms",  v51,  v52,  v53,  v54,  v55,  v13 + 356);
      }

      else
      {
        *(_DWORD *)(v13 + 212) = 3600000;
        uint64_t v58 = (os_log_s *)mDNSLogCategory_Default;
        DNSTypeName(*(unsigned __int16 *)(v13 + 322));
        LogMsgWithLevel( v58,  OS_LOG_TYPE_DEFAULT,  "tcpCallback: stream connection for %##s (%s) failed, retrying in %d ms",  v59,  v60,  v61,  v62,  v63,  v13 + 356);
      }

      SetNextQueryTime(v12, v13);
    }

    if (!*(_BYTE *)(v13 + 612)) {
      goto LABEL_144;
    }
    int v64 = *(unsigned __int8 *)(v13 + 330);
    if (v64 == 21)
    {
      *(_BYTE *)(v13 + 330) = 20;
      if (v8 == -65788) {
        goto LABEL_144;
      }
    }

    else if (v8 == -65788 || v64 == 30)
    {
      goto LABEL_144;
    }

    unint64_t v65 = v13 + 612;
    int v104 = *(_DWORD *)(v13 + 252);
    unsigned int v105 = bswap32(*(unsigned __int16 *)(v13 + 320)) >> 16;
    char v66 = gSensitiveLoggingEnabled;
    int v67 = (os_log_s *)mDNSLogCategory_Default;
    if (mDNSLogCategory_Default == mDNSLogCategory_State) {
      char v66 = 0;
    }
    if (*(_DWORD *)(v13 + 212) != -1)
    {
      if ((v66 & 1) != 0)
      {
        int v67 = (os_log_s *)mDNSLogCategory_Default_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_115;
        }
        for (uint64_t i = (_BYTE *)(v13 + 356); ; i += v69 + 1)
        {
          if ((unint64_t)i >= v65 || !i || (uint64_t v69 = *i, v69 > 0x3F))
          {
            int v88 = 257;
            goto LABEL_114;
          }

          if (!*i) {
            break;
          }
        }

        int v88 = (unsigned __int16)((_WORD)i - (v13 + 356) + 1);
      }

      else
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_115;
        }
        for (uint64_t j = (_BYTE *)(v13 + 356); ; j += v74 + 1)
        {
          if ((unint64_t)j >= v65 || !j || (uint64_t v74 = *j, v74 > 0x3F))
          {
            int v88 = 257;
            goto LABEL_114;
          }

          if (!*j) {
            break;
          }
        }

        int v88 = (unsigned __int16)((_WORD)j - (v13 + 356) + 1);
      }

LABEL_24:
  uint32_t v35 = (unsigned __int16 *)(a2 + 9012);
  if (a3)
  {
    uint64_t v36 = *(int *)(a2 + 8968);
    uint64_t v37 = *(void *)(a2 + 8984);
    if (v37)
    {
      uint64_t v38 = *(_BYTE **)(v37 + 40);
      if (v38 == (_BYTE *)(v37 + 652))
      {
LABEL_29:
        if (v38 != (_BYTE *)(v37 + 652)) {
          return;
        }
        mDNS_Lock_((unsigned int *)v12, (uint64_t)"GetAuthInfoForName", 434);
        AuthInfoForName_internal = GetAuthInfoForName_internal(v12, v38);
        mDNS_Unlock_(v12, (uint64_t)"GetAuthInfoForName", 436);
        goto LABEL_38;
      }

      LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "tcpCallback: ERROR: tcpInfo->rr->resrec.name %p != &tcpInfo->rr->namestorage %p",  a4,  a5,  a6,  a7,  a8,  (int)v38);
      uint64_t v37 = *(void *)(a2 + 8984);
      if (v37)
      {
        uint64_t v38 = *(_BYTE **)(v37 + 40);
        goto LABEL_29;
      }
    }

    AuthInfoForName_internal = 0LL;
LABEL_38:
    if (v13)
    {
      *(_WORD *)(a2 + 16) = *(_WORD *)(v13 + 320);
      *(_WORD *)(a2 + 18) = 1;
      *(void *)(a2 + memset(v45, 0, 20) = 0LL;
      uint64_t v49 = putQuestion( a2 + 16,  a2 + 28,  a2 + 8968,  (unsigned __int8 *)(v13 + 356),  *(unsigned __int16 *)(v13 + 322),  *(unsigned __int16 *)(v13 + 324),  a7,  a8);
      AuthInfoForName_internal = *(uint64_t **)(v13 + 32);
    }

    else
    {
      uint64_t v49 = (_BYTE *)(a2 + 16 + v36);
    }

    int v70 = mDNSSendDNSMessage( v12,  a2 + 16,  (unint64_t)v49,  0LL,  (unsigned __int16 *)a1,  0LL,  (int *)(a2 + 8992),  *v35,  AuthInfoForName_internal,  0);
    if (v13 && !v70)
    {
      mDNS_Lock_((unsigned int *)v12, (uint64_t)"tcpCallback", 1406);
      *(_DWORD *)(v13 + 208) = *(_DWORD *)(v12 + 64);
      SetNextQueryTime(v12, v13);
      mDNS_Unlock_(v12, (uint64_t)"tcpCallback", 1411);
      return;
    }

    if (!v70) {
      return;
    }
LABEL_75:
    int v8 = -65537;
    goto LABEL_8;
  }

  unint64_t v40 = *(void *)(a2 + 9032);
  if (v40 >= 2)
  {
    uint64_t v56 = *(char **)(a2 + 9016);
    size_t v48 = *(unsigned __int16 *)(a2 + 9024);
    unint64_t v47 = *(void *)(a2 + 9032);
  }

  else
  {
    ssize_t v41 = mDNSPlatformReadTCP(a1, (char *)v35 + v40 + 12, 2 - v40, &v106);
    if (v41 < 0)
    {
      int v8 = -65788;
      uint64_t v75 = mDNSLogCategory_Default;
      LODWORD(v103) = v41;
      uint64_t v76 = "ERROR: tcpCallback - attempt to read message length failed (%d)";
LABEL_101:
      uint64_t v79 = (os_log_s *)v75;
      goto LABEL_103;
    }

    if (v106)
    {
LABEL_45:
      if (*(_DWORD *)(a2 + 9040))
      {
        if ((v16 & 1) == 0) {
          *uint64_t v14 = 0LL;
        }
        DisposeTCPConn(a2);
        return;
      }

      int v8 = -65788;
      uint64_t v79 = (os_log_s *)mDNSLogCategory_Default;
      uint64_t v103 = *(void *)(a2 + 9032);
      uint64_t v76 = "ERROR: socket closed prematurely tcpInfo->nread = %d";
LABEL_103:
      LogMsgWithLevel(v79, OS_LOG_TYPE_DEFAULT, v76, v42, v43, v44, v45, v46, v103);
      goto LABEL_8;
    }

    unint64_t v47 = *(void *)(a2 + 9032) + v41;
    *(void *)(a2 + 9032) = v47;
    if (v47 < 2) {
      return;
    }
    size_t v48 = __rev16(*(unsigned __int16 *)(a2 + 9024));
    *(_WORD *)(a2 + 9024) = v48;
    if (v48 <= 0xB)
    {
      LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "ERROR: tcpCallback - length too short (%d bytes)",  v42,  v43,  v44,  v45,  v46,  v48);
      goto LABEL_75;
    }

    uint64_t v56 = (char *)malloc(v48);
    if (!v56) {
      __break(1u);
    }
    *(void *)(a2 + 9016) = v56;
  }

  ssize_t v57 = mDNSPlatformReadTCP(a1, &v56[v47 - 2], v48 - (v47 - 2), &v106);
  if (v57 < 0)
  {
    if (v40 < 2) {
      return;
    }
    int v8 = -65788;
    uint64_t v75 = mDNSLogCategory_Default;
    LODWORD(v103) = v57;
    uint64_t v76 = "ERROR: tcpCallback - read returned %d";
    goto LABEL_101;
  }

  if (v106) {
    goto LABEL_45;
  }
  ssize_t v80 = *(void *)(a2 + 9032) + v57;
  *(void *)(a2 + 9032) = v80;
  ssize_t v81 = v80 - 2;
  uint64_t v82 = *(char **)(a2 + 9016);
  uint64_t v83 = &v82[v81];
  *(_OWORD *)buf = *(_OWORD *)(a2 + 8992);
  *(_DWORD *)unsigned int v108 = *(_DWORD *)(a2 + 9008);
  uint64_t v84 = *v35;
  ++*(_DWORD *)(a2 + 9040);
  *(void *)(a2 + 9016) = 0LL;
  *(void *)(a2 + 9032) = 0LL;
  *(_WORD *)(a2 + 9024) = 0;
  int v85 = *(_DWORD *)(a1 + 4);
  if (v13)
  {
    uint64_t v86 = *(void *)(v13 + 112);
    if (v86)
    {
      unsigned int v87 = *(unsigned __int16 *)(v86 + 9014);
      *(_WORD *)(v13 + 318) = v87;
    }

    else
    {
      unsigned int v87 = 0;
    }

    if ((v16 & 1) == 0 && (!*(_BYTE *)(v13 + 612) || *(_BYTE *)(v12 + 141))) {
      goto LABEL_154;
    }
  }

  else
  {
    unsigned int v87 = 0;
    if ((v16 & 1) == 0)
    {
LABEL_154:
      *uint64_t v14 = 0LL;
      DisposeTCPConn(a2);
    }
  }

  mDNSCoreReceive(v12, v82, v83, buf, v84, v85 & 1, v87, 0LL);
  if (v82) {
    free(v82);
  }
}

    ;
  }

  if (*(void *)(a1 + 14656) == a2) {
    *(void *)(a1 + 14656) = *(void *)a2;
  }
  int32x2_t v17 = *v4;
  if (v17)
  {
    int v18 = 1;
    while (1)
    {
      int v19 = *(unsigned __int8 *)(a2 + 172);
      int v20 = *((unsigned __int8 *)v17 + 172);
      if (*(_BYTE *)(a2 + 172))
      {
        if (v19 != v20
          || (int v21 = *(unsigned __int8 *)(a2 + 172), *(unsigned __int16 *)(a2 + 174) != *((unsigned __int16 *)v17 + 87)))
        {
          int v22 = v19 == 2 && v20 == 0;
          if (!v22 || *(_WORD *)(a2 + 174) != 2304) {
            goto LABEL_51;
          }
          int v21 = 0;
        }
      }

      else
      {
        int v21 = *((unsigned __int8 *)v17 + 172);
        if (*((_BYTE *)v17 + 172))
        {
          if (v20 != 2 || *((_WORD *)v17 + 87) != 2304) {
            goto LABEL_51;
          }
          int v21 = 2;
        }
      }

      uint64_t v23 = (os_log_s *)mDNSLogCategory_NAT;
      if (gSensitiveLoggingEnabled == 1 && mDNSLogCategory_NAT != mDNSLogCategory_State) {
        break;
      }
      int v18 = 0;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_NAT, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_50;
      }
LABEL_51:
      int32x2_t v17 = (uint64_t *)*v17;
      if (!v17) {
        goto LABEL_54;
      }
    }

    uint64_t v23 = (os_log_s *)mDNSLogCategory_NAT_redacted;
    uint64_t v25 = os_log_type_enabled((os_log_t)mDNSLogCategory_NAT_redacted, OS_LOG_TYPE_DEFAULT);
    int v18 = 0;
    if (!v25) {
      goto LABEL_51;
    }
LABEL_50:
    uint64_t v26 = bswap32(*(unsigned __int16 *)(a2 + 174)) >> 16;
    uint64_t v27 = *(_DWORD *)(a2 + 180);
    uint64_t v28 = bswap32(*((unsigned __int16 *)v17 + 87));
    __int32 v29 = *((_DWORD *)v17 + 45);
    *(_DWORD *)buf = 134219776;
    *(void *)&uint8_t buf[4] = a2;
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = v19;
    *(_WORD *)&buf[18] = 1024;
    *(_DWORD *)&buf[20] = v26;
    LOWORD(v53) = 1024;
    *(_DWORD *)((char *)&v53 + 2) = v27;
    HIWORD(v53) = 2048;
    uint64_t v54 = (const char *)v17;
    LOWORD(v55) = 1024;
    *(_DWORD *)((char *)&v55 + 2) = v21;
    HIWORD(v55) = 1024;
    LODWORD(v56) = HIWORD(v28);
    WORD2(v56) = 1024;
    *(_DWORD *)((char *)&v56 + 6) = v29;
    _os_log_impl( (void *)&_mh_execute_header,  v23,  OS_LOG_TYPE_DEFAULT,  "Warning: Removed port mapping request %p Prot %d Int %d TTL %d duplicates existing port mapping request %p Prot %d Int %d TTL %d",  buf,  0x3Au);
    int v18 = 0;
    goto LABEL_51;
  }

  int v18 = 1;
LABEL_54:
  if (!*(_WORD *)(a1 + 14964) || !*(void *)(a1 + 14984) || !*(void *)(a1 + 15000)) {
    goto LABEL_98;
  }
  uint64_t v59 = 0;
  uint64_t v58 = 0LL;
  mDNS_snprintf(&v58);
  *(void *)buf = "NewRemoteHost";
  *(void *)&buf[8] = "string";
  *(void *)&uint8_t buf[16] = "";
  uint64_t v53 = "NewExternalPort";
  uint64_t v54 = "ui2";
  uint64_t v55 = &v58;
  *(void *)&uint64_t v56 = "NewProtocol";
  *((void *)&v56 + 1) = "string";
  int32x4_t v30 = "TCP";
  if (*(_BYTE *)(a2 + 172) == 1) {
    int32x4_t v30 = "UDP";
  }
  ssize_t v57 = v30;
  *(void *)(a2 + 48) = a2;
  if (*(void *)(a2 + 56))
  {
    unsigned int v31 = (os_log_s *)mDNSLogCategory_NAT;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_NAT == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_70;
      }
      *(_WORD *)uint64_t v51 = 0;
    }

    else
    {
      unsigned int v31 = (os_log_s *)mDNSLogCategory_NAT_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT_redacted, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_70;
      }
      *(_WORD *)uint64_t v51 = 0;
    }

    _os_log_impl( (void *)&_mh_execute_header,  v31,  OS_LOG_TYPE_DEFAULT,  "LNT_UnmapPort: closing previous open connection",  v51,  2u);
LABEL_70:
    int8x16_t v33 = *(_DWORD **)(a2 + 56);
    if (v33)
    {
      mDNSPlatformTCPCloseConnection(v33);
      *(void *)(a2 + 56) = 0LL;
    }
  }

  int8x16_t v34 = *(void **)(a2 + 96);
  if (v34)
  {
    free(v34);
    *(void *)(a2 + 96) = 0LL;
  }

  uint32_t v35 = *(void **)(a2 + 112);
  if (v35)
  {
    free(v35);
    *(void *)(a2 + 112) = 0LL;
  }

  uint64_t v36 = malloc(0x70uLL);
  if (!v36) {
    __break(1u);
  }
  uint64_t v37 = v36;
  uint64_t v38 = (void *)(a1 + 14936);
  int v39 = *(_OWORD *)(a2 + 112);
  v36[4] = *(_OWORD *)(a2 + 96);
  v36[5] = v39;
  v36[6] = *(_OWORD *)(a2 + 128);
  unint64_t v40 = *(_OWORD *)(a2 + 48);
  char *v36 = *(_OWORD *)(a2 + 32);
  v36[1] = v40;
  ssize_t v41 = *(_OWORD *)(a2 + 80);
  uint64_t v42 = (void *)(a1 + 14936);
  v36[2] = *(_OWORD *)(a2 + 64);
  v36[3] = v41;
  do
  {
    uint64_t v43 = v42;
    uint64_t v42 = (void *)*v42;
  }

  while (v42);
  *uint64_t v43 = v36;
  uint64_t v44 = SendSOAPMsgControlAction(a1, (uint64_t)v36, (uint64_t)"DeletePortMapping", 3, (uint64_t)buf, 4);
  if (!v44) {
    goto LABEL_98;
  }
  uint64_t v45 = v44;
  do
  {
    uint64_t v46 = v38;
    uint64_t v38 = (void *)*v38;
    if (v38) {
      unint64_t v47 = v38 == v37;
    }
    else {
      unint64_t v47 = 1;
    }
  }

  while (!v47);
  if (v38)
  {
    *uint64_t v46 = *v38;
    free(v37);
  }

  size_t v48 = (os_log_s *)mDNSLogCategory_NAT;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_NAT == mDNSLogCategory_State)
  {
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_98;
    }
    *(_DWORD *)buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v45;
    goto LABEL_97;
  }

  size_t v48 = (os_log_s *)mDNSLogCategory_NAT_redacted;
  if (os_log_type_enabled((os_log_t)mDNSLogCategory_NAT_redacted, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v45;
LABEL_97:
    _os_log_impl( (void *)&_mh_execute_header,  v48,  OS_LOG_TYPE_DEFAULT,  "Legacy NAT Traversal - unmap request failed with error %d",  buf,  8u);
  }

  CompleteRDataUpdate((uint64_t)mDNSStorage, a1, v32, v27, v28, v29, v30, v31);
LABEL_25:
  mDNS_Unlock_((uint64_t)mDNSStorage, (uint64_t)"mDNS_Update", 16385);
  return 0LL;
}

  reply = xpc_dictionary_create_reply(object);
  if (!reply)
  {
    int v19 = (os_log_s *)mDNSLogCategory_XPC;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_XPC == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_XPC, OS_LOG_TYPE_ERROR)) {
        return;
      }
      buf[0].dev_t st_dev = 134217984;
      *(void *)&buf[0].st_mode = remote_connection;
    }

    else
    {
      int v19 = (os_log_s *)mDNSLogCategory_XPC_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_XPC_redacted, OS_LOG_TYPE_ERROR)) {
        return;
      }
      buf[0].dev_t st_dev = 134217984;
      *(void *)&buf[0].st_mode = remote_connection;
    }

    _os_log_impl( (void *)&_mh_execute_header,  v19,  OS_LOG_TYPE_ERROR,  "C%p {error='cannot create reply response dictionary'}",  (uint8_t *)buf,  0xCu);
    return;
  }

  uint64_t v15 = reply;
  euid = xpc_connection_get_euid(remote_connection);
  pid = xpc_connection_get_pid(remote_connection);
  if (euid)
  {
    int v18 = (os_log_s *)mDNSLogCategory_XPC;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_XPC == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_XPC, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_43;
      }
    }

    else
    {
      int v18 = (os_log_s *)mDNSLogCategory_XPC_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_XPC_redacted, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_43;
      }
    }

    buf[0].dev_t st_dev = 134218240;
    *(void *)&buf[0].st_mode = remote_connection;
    WORD2(buf[0].st_ino) = 1024;
    *(_DWORD *)((char *)&buf[0].st_ino + 6) = pid;
    _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_DEFAULT,  "C%p {client_pid=%d,error='not running as root'}",  (uint8_t *)buf,  0x12u);
LABEL_43:
    if (IsEntitled((uint64_t)remote_connection))
    {
      int32x4_t v30 = "Client must be running as root";
LABEL_55:
      xpc_dictionary_set_string(v15, "ErrorDescription", v30);
      int32x4_t v32 = 3LL;
      goto LABEL_56;
    }

int MD5_Update(_MD5_CTX *c, const void *data, size_t len)
{
  if (!len) {
    return (int)c;
  }
  size_t v3 = len;
  int v4 = (unsigned __int8 *)data;
  unsigned int v5 = c;
  CFNumberRef v6 = (char *)data + len;
  unint64_t Nl = c->Nl;
  unsigned int v8 = Nl + 8 * len;
  if (Nl <= v8) {
    unsigned int Nh = c->Nh;
  }
  else {
    unsigned int Nh = c->Nh + 1;
  }
  c->unint64_t Nl = v8;
  c->unsigned int Nh = Nh + (len >> 29);
  unint64_t num = c->num;
  size_t v11 = len;
  uint64_t v12 = (unsigned __int8 *)data;
  if ((_DWORD)num)
  {
    uint64_t v13 = c->data;
    unsigned int v14 = num >> 2;
    uint64_t v15 = num & 3;
    unsigned int v16 = num + len;
    if (num + len >= 0x40) {
      __asm { BR              X13 }
    }

    c->unint64_t num = v16;
    if (v15 + len <= 3)
    {
      unsigned int v177 = v13[v14];
      if ((_DWORD)v15 == 2
        || ((_DWORD)v15 == 1 || (num & 3) == 0 && (v178 = *v4, ++v4, v177 = v178, size_t v3 = len - 1, len != 1))
        && (int v179 = *v4, ++v4, v177 |= v179 << 8, v3 != 1))
      {
        v177 |= *v4 << 16;
      }

      v13[v14] = v177;
      return (int)c;
    }

    unint64_t v180 = v16 >> 2;
    int v181 = v16 & 3;
    if ((num & 3) != 0)
    {
      unsigned int v182 = v13[v14];
      uint64_t v183 = v14;
      uint64_t v184 = v4;
      if ((_DWORD)v15 != 1)
      {
        if ((_DWORD)v15 != 2)
        {
LABEL_42:
          int v187 = (unsigned int *)(v184 + 1);
          v13[v183] = v182 | (*v184 << 24);
          unsigned int v188 = v14 + 1;
          if (v188 < v180 && v6 - (char *)v187 >= 4)
          {
            unint64_t v189 = num >> 2;
            int64_t v190 = &v4[len] - v184 - 5;
            do
            {
              unsigned int v191 = *v187++;
              c->data[v189 + 1] = v191;
              unsigned int v188 = v189 + 2;
              if (v189 + 2 >= v180) {
                break;
              }
              ++v189;
              BOOL v172 = v190 <= 3;
              v190 -= 4LL;
            }

            while (!v172);
          }

          if ((v16 & 3) != 0)
          {
            int v192 = 0;
            unsigned int v193 = (char *)v187 + (v16 & 3);
            if (v181 != 1)
            {
              if (v181 != 2)
              {
                int v194 = *--v193;
                int v192 = v194 << 16;
              }

              int v195 = *--v193;
              v192 |= v195 << 8;
            }

            v13[v188] = v192 | *(v193 - 1);
          }

          return (int)c;
        }

_DWORD *md5_block_host_order(_DWORD *result, int *a2)
{
  int v3 = result[2];
  int v2 = result[3];
  int v4 = result[1];
  int v5 = *a2;
  int v6 = a2[1];
  unsigned int v7 = *result + *a2 - 680876936 + (v3 & v4 | v2 & ~v4);
  int v8 = v4 + (v7 << 7) + (v7 >> 25);
  unsigned int v9 = v2 + v6 - 389564586 + (v4 & v8 | v3 & ~v8);
  int v10 = v8 + (v9 << 12) + (v9 >> 20);
  int v11 = a2[2];
  int v12 = a2[3];
  unsigned int v13 = v3 + v11 + 606105819 + (v8 & v10 | v4 & ~v10);
  int v14 = v10 + (v13 << 17) + (v13 >> 15);
  unsigned int v15 = v4 + v12 - 1044525330 + (v10 & v14 | v8 & ~v14);
  int v16 = v14 + (v15 << 22) + (v15 >> 10);
  int v18 = a2[4];
  int v17 = a2[5];
  unsigned int v19 = v18 + v8 - 176418897 + (v14 & v16 | v10 & ~v16);
  int v20 = v16 + (v19 << 7) + (v19 >> 25);
  unsigned int v21 = v17 + v10 + 1200080426 + (v16 & v20 | v14 & ~v20);
  int v22 = v20 + (v21 << 12) + (v21 >> 20);
  int v23 = a2[6];
  int v24 = a2[7];
  unsigned int v25 = v23 + v14 - 1473231341 + (v20 & v22 | v16 & ~v22);
  int v26 = v22 + (v25 << 17) + (v25 >> 15);
  unsigned int v27 = v24 + v16 - 45705983 + (v22 & v26 | v20 & ~v26);
  int v28 = v26 + (v27 << 22) + (v27 >> 10);
  int v29 = a2[8];
  int v30 = a2[9];
  unsigned int v31 = v29 + v20 + 1770035416 + (v26 & v28 | v22 & ~v28);
  int v32 = v28 + (v31 << 7) + (v31 >> 25);
  unsigned int v33 = v30 + v22 - 1958414417 + (v28 & v32 | v26 & ~v32);
  int v34 = v32 + (v33 << 12) + (v33 >> 20);
  int v36 = a2[10];
  int v35 = a2[11];
  unsigned int v37 = v36 + v26 - 42063 + (v32 & v34 | v28 & ~v34);
  int v38 = v34 + (v37 << 17) + (v37 >> 15);
  unsigned int v39 = v35 + v28 - 1990404162 + (v34 & v38 | v32 & ~v38);
  int v40 = v38 + (v39 << 22) + (v39 >> 10);
  int v42 = a2[12];
  int v41 = a2[13];
  unsigned int v43 = v42 + v32 + 1804603682 + (v38 & v40 | v34 & ~v40);
  int v44 = v40 + (v43 << 7) + (v43 >> 25);
  unsigned int v45 = v41 + v34 - 40341101 + (v40 & v44 | v38 & ~v44);
  int v46 = v44 + (v45 << 12) + (v45 >> 20);
  int v48 = a2[14];
  int v47 = a2[15];
  unsigned int v49 = v48 + v38 - 1502002290 + (v44 & v46 | v40 & ~v46);
  int v50 = v46 + (v49 << 17) + (v49 >> 15);
  unsigned int v51 = v47 + v40 + 1236535329 + (v46 & v50 | v44 & ~v50);
  int v52 = v50 + (v51 << 22) + (v51 >> 10);
  unsigned int v53 = v6 + v44 - 165796510 + (v52 & v46 | v50 & ~v46);
  int v54 = v52 + 32 * v53 + (v53 >> 27);
  unsigned int v55 = v23 + v46 - 1069501632 + (v54 & v50 | v52 & ~v50);
  int v56 = v54 + (v55 << 9) + (v55 >> 23);
  unsigned int v57 = v35 + v50 + 643717713 + (v56 & v52 | v54 & ~v52);
  int v58 = v56 + (v57 << 14) + (v57 >> 18);
  unsigned int v59 = v5 + v52 - 373897302 + (v58 & v54 | v56 & ~v54);
  int v60 = v58 + (v59 << 20) + (v59 >> 12);
  unsigned int v61 = v17 + v54 - 701558691 + (v60 & v56 | v58 & ~v56);
  int v62 = v60 + 32 * v61 + (v61 >> 27);
  unsigned int v63 = v36 + v56 + 38016083 + (v62 & v58 | v60 & ~v58);
  int v64 = v62 + (v63 << 9) + (v63 >> 23);
  unsigned int v65 = v47 + v58 - 660478335 + (v64 & v60 | v62 & ~v60);
  int v66 = v64 + (v65 << 14) + (v65 >> 18);
  unsigned int v67 = v18 + v60 - 405537848 + (v66 & v62 | v64 & ~v62);
  int v68 = v66 + (v67 << 20) + (v67 >> 12);
  unsigned int v69 = v30 + v62 + 568446438 + (v68 & v64 | v66 & ~v64);
  int v70 = v68 + 32 * v69 + (v69 >> 27);
  unsigned int v71 = v48 + v64 - 1019803690 + (v70 & v66 | v68 & ~v66);
  int v72 = v70 + (v71 << 9) + (v71 >> 23);
  unsigned int v73 = v12 + v66 - 187363961 + (v72 & v68 | v70 & ~v68);
  int v74 = v72 + (v73 << 14) + (v73 >> 18);
  unsigned int v75 = v29 + v68 + 1163531501 + (v74 & v70 | v72 & ~v70);
  int v76 = v74 + (v75 << 20) + (v75 >> 12);
  unsigned int v77 = v41 + v70 - 1444681467 + (v76 & v72 | v74 & ~v72);
  int v78 = v76 + 32 * v77 + (v77 >> 27);
  unsigned int v79 = v11 + v72 - 51403784 + (v78 & v74 | v76 & ~v74);
  int v80 = v78 + (v79 << 9) + (v79 >> 23);
  unsigned int v81 = v24 + v74 + 1735328473 + (v80 & v76 | v78 & ~v76);
  int v82 = v80 + (v81 << 14) + (v81 >> 18);
  unsigned int v83 = v42 + v76 - 1926607734 + ((v82 ^ v80) & v78 ^ v80);
  int v84 = v82 + (v83 << 20) + (v83 >> 12);
  unsigned int v85 = v17 + v78 - 378558 + (v82 ^ v80 ^ v84);
  int v86 = v84 + 16 * v85 + (v85 >> 28);
  unsigned int v87 = v29 + v80 - 2022574463 + (v84 ^ v82 ^ v86);
  int v88 = v86 + (v87 << 11) + (v87 >> 21);
  unsigned int v89 = v35 + v82 + 1839030562 + (v86 ^ v84 ^ v88);
  int v90 = v88 + (v89 << 16) + HIWORD(v89);
  unsigned int v91 = v48 + v84 - 35309556 + (v88 ^ v86 ^ v90);
  int v92 = v90 + (v91 << 23) + (v91 >> 9);
  unsigned int v93 = v6 + v86 - 1530992060 + (v90 ^ v88 ^ v92);
  int v94 = v92 + 16 * v93 + (v93 >> 28);
  unsigned int v95 = v18 + v88 + 1272893353 + (v92 ^ v90 ^ v94);
  int v96 = v94 + (v95 << 11) + (v95 >> 21);
  unsigned int v97 = v24 + v90 - 155497632 + (v94 ^ v92 ^ v96);
  int v98 = v96 + (v97 << 16) + HIWORD(v97);
  unsigned int v99 = v36 + v92 - 1094730640 + (v96 ^ v94 ^ v98);
  int v100 = v98 + (v99 << 23) + (v99 >> 9);
  unsigned int v101 = v41 + v94 + 681279174 + (v98 ^ v96 ^ v100);
  int v102 = v100 + 16 * v101 + (v101 >> 28);
  unsigned int v103 = v5 + v96 - 358537222 + (v100 ^ v98 ^ v102);
  int v104 = v102 + (v103 << 11) + (v103 >> 21);
  unsigned int v105 = v12 + v98 - 722521979 + (v102 ^ v100 ^ v104);
  int v106 = v104 + (v105 << 16) + HIWORD(v105);
  unsigned int v107 = v23 + v100 + 76029189 + (v104 ^ v102 ^ v106);
  int v108 = v106 + (v107 << 23) + (v107 >> 9);
  unsigned int v109 = v30 + v102 - 640364487 + (v106 ^ v104 ^ v108);
  int v110 = v108 + 16 * v109 + (v109 >> 28);
  unsigned int v111 = v42 + v104 - 421815835 + (v108 ^ v106 ^ v110);
  int v112 = v110 + (v111 << 11) + (v111 >> 21);
  unsigned int v113 = v47 + v106 + 530742520 + (v110 ^ v108 ^ v112);
  int v114 = v112 + (v113 << 16) + HIWORD(v113);
  unsigned int v115 = v11 + v108 - 995338651 + (v112 ^ v110 ^ v114);
  int v116 = v114 + (v115 << 23) + (v115 >> 9);
  unsigned int v117 = v5 + v110 - 198630844 + ((v116 | ~v112) ^ v114);
  int v118 = v116 + (v117 << 6) + (v117 >> 26);
  unsigned int v119 = v24 + v112 + 1126891415 + ((v118 | ~v114) ^ v116);
  int v120 = v118 + (v119 << 10) + (v119 >> 22);
  unsigned int v121 = v48 + v114 - 1416354905 + ((v120 | ~v116) ^ v118);
  int v122 = v120 + (v121 << 15) + (v121 >> 17);
  unsigned int v123 = v17 + v116 - 57434055 + ((v122 | ~v118) ^ v120);
  int v124 = v122 + (v123 << 21) + (v123 >> 11);
  unsigned int v125 = v42 + v118 + 1700485571 + ((v124 | ~v120) ^ v122);
  int v126 = v124 + (v125 << 6) + (v125 >> 26);
  unsigned int v127 = v12 + v120 - 1894986606 + ((v126 | ~v122) ^ v124);
  int v128 = v126 + (v127 << 10) + (v127 >> 22);
  unsigned int v129 = v36 + v122 - 1051523 + ((v128 | ~v124) ^ v126);
  int v130 = v128 + (v129 << 15) + (v129 >> 17);
  unsigned int v131 = v6 + v124 - 2054922799 + ((v130 | ~v126) ^ v128);
  int v132 = v130 + (v131 << 21) + (v131 >> 11);
  unsigned int v133 = v29 + v126 + 1873313359 + ((v132 | ~v128) ^ v130);
  int v134 = v132 + (v133 << 6) + (v133 >> 26);
  unsigned int v135 = v47 + v128 - 30611744 + ((v134 | ~v130) ^ v132);
  int v136 = v134 + (v135 << 10) + (v135 >> 22);
  unsigned int v137 = v23 + v130 - 1560198380 + ((v136 | ~v132) ^ v134);
  int v138 = v136 + (v137 << 15) + (v137 >> 17);
  unsigned int v139 = v41 + v132 + 1309151649 + ((v138 | ~v134) ^ v136);
  int v140 = v138 + (v139 << 21) + (v139 >> 11);
  unsigned int v141 = v18 + v134 - 145523070 + ((v140 | ~v136) ^ v138);
  int v142 = v140 + (v141 << 6) + (v141 >> 26);
  unsigned int v143 = v35 + v136 - 1120210379 + ((v142 | ~v138) ^ v140);
  int v144 = v142 + (v143 << 10) + (v143 >> 22);
  unsigned int v145 = v11 + v138 + 718787259 + ((v144 | ~v140) ^ v142);
  int v146 = v144 + (v145 << 15) + (v145 >> 17);
  unsigned int v147 = v30 + v140 - 343485551 + ((v146 | ~v142) ^ v144);
  *result += v142;
  result[1] = v4 + v146 + (v147 << 21) + (v147 >> 11);
  result[2] = v3 + v146;
  result[3] = v2 + v144;
  return result;
}

ssize_t mDNSPlatformWriteTCP(uint64_t a1, const void *a2, size_t a3)
{
  if (!*(_BYTE *)(a1 + 65)) {
    return -65569LL;
  }
  if ((*(_BYTE *)(a1 + 4) & 1) == 0)
  {
    ssize_t result = write(*(_DWORD *)(a1 + 16), a2, a3);
    if ((result & 0x8000000000000000LL) == 0) {
      return result;
    }
    if (*__error() == 35) {
      return 0LL;
    }
    int v4 = (os_log_s *)mDNSLogCategory_Default;
    int v5 = __error();
    int v6 = strerror(*v5);
    LogMsgWithLevel(v4, OS_LOG_TYPE_DEFAULT, "ERROR: mDNSPosixWriteTCP - send %s", v7, v8, v9, v10, v11, v6);
  }

  return -1LL;
}

ssize_t mDNSPlatformReadTCP(uint64_t a1, void *a2, size_t a3, _BYTE *a4)
{
  *a4 = 0;
  if (!*(_BYTE *)(a1 + 65)) {
    return -65569LL;
  }
  if ((*(_BYTE *)(a1 + 4) & 1) != 0)
  {
    *a4 = 1;
    return -1LL;
  }

  int v5 = *(_DWORD *)(a1 + 16);
  ssize_t result = recv(v5, a2, a3, 0);
  if (result >= 1)
  {
    mDNSPosixReadTCP_CLOSEDcount = 0;
    mDNSPosixReadTCP_EAGAINcount = 0;
    return result;
  }

  if (!result)
  {
    *a4 = 1;
    ++mDNSPosixReadTCP_CLOSEDcount;
    HIDWORD(v12) = -858993459 * mDNSPosixReadTCP_CLOSEDcount + 429496728;
    LODWORD(v12) = HIDWORD(v12);
    if ((v12 >> 2) <= 0xCCCCCCC)
    {
      LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "ERROR: mDNSPosixReadFromSocket - recv %d got CLOSED %d times",  v7,  v8,  v9,  v10,  v11,  v5);
      if (mDNSPosixReadTCP_CLOSEDcount >= 1000) {
        __assert_rtn("mDNSPosixReadTCP", "PlatformCommon.c", 694, "CLOSEDcount < 1000");
      }
    }

    return 0LL;
  }

  if (*__error() == 54)
  {
    ssize_t result = 0LL;
    *a4 = 1;
    return result;
  }

  if (*__error() != 35)
  {
    unsigned int v19 = (os_log_s *)mDNSLogCategory_Default;
    int v20 = *__error();
    unsigned int v21 = __error();
    strerror(*v21);
    LogMsgWithLevel( v19,  OS_LOG_TYPE_DEFAULT,  "ERROR: mDNSPosixReadFromSocket - recv: %d (%s)",  v22,  v23,  v24,  v25,  v26,  v20);
    return -1LL;
  }

  ++mDNSPosixReadTCP_EAGAINcount;
  HIDWORD(v18) = 652835029 * mDNSPosixReadTCP_EAGAINcount + 17179864;
  LODWORD(v18) = HIDWORD(v18);
  if ((v18 >> 3) <= 0x418936)
  {
    LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "ERROR: mDNSPosixReadFromSocket - recv %d got EAGAIN %d times",  v13,  v14,  v15,  v16,  v17,  v5);
    sleep(1u);
  }

  return 0LL;
}

void DisposeTCPConn(uint64_t a1)
{
  int v2 = *(void **)(a1 + 9016);
  if (v2) {
    free(v2);
  }
  free((void *)a1);
}

void mDNSPlatformTCPCloseConnection(_DWORD *a1)
{
  if (a1)
  {
    int v2 = a1[4];
    if (v2 != -1)
    {
      shutdown(v2, 2);
      close(a1[4]);
    }

    free(a1);
  }

uint64_t GetPktLease(uint64_t a1, unint64_t a2, unint64_t a3, _DWORD *a4)
{
  OptRR = LocateOptRR(a2, a3, 8);
  if (!OptRR) {
    return 0LL;
  }
  uint64_t v9 = (_WORD *)(a1 + 37864);
  if (GetLargeResourceRecord(a1, a2, OptRR, a3, 0LL, 128, a1 + 37856)
    && *(unsigned __int8 *)v9 != 240
    && *(_WORD *)(a1 + 37868) == 41)
  {
    unint64_t v10 = *(void *)(a1 + 37904) + 4LL;
    unint64_t v11 = v10 + *(unsigned __int16 *)(a1 + 37876);
    while (v10 < v11)
    {
      if (*(_WORD *)v10 == 2)
      {
        *a4 = *(_DWORD *)(v10 + 4);
        *uint64_t v9 = 0;
        *(_WORD *)(a1 + 37966) = 0;
        uint64_t v14 = (void *)(a1 + 37920);
        uint64_t v13 = *(void **)(a1 + 37920);
        uint64_t v12 = 1LL;
        if (v13) {
          goto LABEL_10;
        }
        return v12;
      }

      v10 += 24LL;
    }
  }

  uint64_t v12 = 0LL;
  *uint64_t v9 = 0;
  *(_WORD *)(a1 + 37966) = 0;
  uint64_t v14 = (void *)(a1 + 37920);
  uint64_t v13 = *(void **)(a1 + 37920);
  if (v13)
  {
LABEL_10:
    ref_count_obj_release(v13);
    *uint64_t v14 = 0LL;
  }

  return v12;
}

void HostnameCallback( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9)
{
  uint64_t v11 = *(void *)(a2 + 112);
  if (!(_DWORD)a3)
  {
    mDNS_Lock_((unsigned int *)a1, (uint64_t)"HostnameCallback", 2537);
    unsigned int v21 = *(_DWORD *)(a1 + 64);
    if (v21 <= 1) {
      unsigned int v21 = 1;
    }
    *(_DWORD *)(a1 + 12692) = v21;
    mDNS_Unlock_(a1, (uint64_t)"HostnameCallback", 2539);
    if (!v11)
    {
      LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "HostnameCallback invoked with orphaned address record",  v22,  v23,  v24,  v25,  v26,  a9);
      return;
    }

    if (mDNS_LoggingEnabled == 1)
    {
      if (*(_WORD *)(a2 + 12) == 1) {
        unsigned int v27 = "Registered hostname %##s IP %.4a";
      }
      else {
        unsigned int v27 = "Registered hostname %##s IP %.16a";
      }
      LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  v27,  v22,  v23,  v24,  v25,  v26,  *(void *)(a2 + 40));
    }

    *(void *)(a2 + 112) = *(void *)(v11 + 2824);
    int v28 = *(void (**)(uint64_t, uint64_t, uint64_t))(v11 + 2816);
    if (v28)
    {
      uint64_t v29 = a1;
      uint64_t v30 = a2;
      uint64_t v31 = 0LL;
LABEL_24:
      v28(v29, v30, v31);
    }

void AbortUnlinkAndFree(void *a1)
{
  uint64_t v9 = a1;
  abort_request((uint64_t)a1);
  int v2 = &all_requests;
  do
  {
    int v3 = v2;
    int v4 = (void *)*v2;
    int v2 = (uint64_t *)(*v2 + 16);
    if (v4) {
      BOOL v5 = v4 == a1;
    }
    else {
      BOOL v5 = 1;
    }
  }

  while (!v5);
  if (v4)
  {
    *int v3 = a1[2];
    request_state_forget(&v9);
    return;
  }

  int v6 = (os_log_s *)mDNSLogCategory_Default;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
  {
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    *(_DWORD *)buf = 134217984;
    uint64_t v11 = a1;
    goto LABEL_18;
  }

  int v6 = (os_log_s *)mDNSLogCategory_Default_redacted;
  if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 134217984;
    uint64_t v11 = a1;
LABEL_18:
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "AbortUnlinkAndFree: ERROR: Attempt to abort operation %p not in list",  buf,  0xCu);
  }

uint64_t add_domain_to_browser(uint64_t a1, _BYTE *a2)
{
  uint64_t v4 = *(void *)(a1 + 136);
  BOOL v5 = (uint64_t *)(v4 + 272);
  while (1)
  {
    BOOL v5 = (uint64_t *)*v5;
    if (!v5) {
      break;
    }
  }

  uint64_t v7 = calloc(1uLL, 0x398uLL);
  if (!v7) {
    __break(1u);
  }
  uint64_t v8 = v7;
  uint64_t v9 = a2;
  if (a2 == (_BYTE *)-256LL)
  {
LABEL_8:
    while (v9)
    {
      uint64_t v10 = *v9;
      if (!*v9)
      {
        unsigned __int16 v11 = (_WORD)v9 - (_WORD)a2 + 1;
        if (v11 > 0x100u) {
          break;
        }
        memcpy(v7 + 1, a2, v11);
        goto LABEL_16;
      }

      v9 += v10 + 1;
      if (a2 != (_BYTE *)-256LL) {
        goto LABEL_7;
      }
    }
  }

  else
  {
LABEL_7:
    if (v9 < a2 + 256) {
      goto LABEL_8;
    }
  }

  *((_BYTE *)v7 + 8) = 0;
LABEL_16:
  *((_DWORD *)v8 + 128) = *(_DWORD *)(a1 + 180);
  uint64_t v34 = (void *)(v4 + 272);
  if (*(_BYTE *)(a1 + 272))
  {
    int v12 = 0;
    *(_OWORD *)((char *)v8 + 900) = *(_OWORD *)(a1 + 256);
  }

  else
  {
    int v12 = *(_DWORD *)(a1 + 172);
  }

  *((_DWORD *)v8 + 127) = v12;
  *((_DWORD *)v8 + 129) = *(_DWORD *)(a1 + 184);
  uint64_t v13 = *(void *)v4;
  int v14 = *(_DWORD *)(a1 + 232);
  char v15 = *(_BYTE *)(v4 + 9);
  mDNS_Lock_((unsigned int *)mDNSStorage, (uint64_t)"mDNS_StartBrowse", 15955);
  uint64_t started = mDNS_StartBrowse_internal( (uint64_t)(v8 + 33),  (unsigned __int8 *)(v4 + 10),  a2,  v13,  v14,  v15,  (v14 & 0x80000) != 0,  (uint64_t)FoundInstance,  a1);
  mDNS_Unlock_((uint64_t)mDNSStorage, (uint64_t)"mDNS_StartBrowse", 15957);
  if ((_DWORD)started)
  {
    LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "mDNS_StartBrowse returned %d for type %##s domain %##s",  v16,  v17,  v18,  v19,  v20,  started);
    free(v8);
  }

  else
  {
    *uint64_t v8 = *v34;
    void *v34 = v8;
    if (*(_DWORD *)(a1 + 236) != -1 && SameDomainNameBytes(a2, "\x05local"))
    {
      uint64_t v21 = *(unsigned int *)(a1 + 236);
      if ((_DWORD)v21)
      {
        if (AWDLInterfaceID && AWDLInterfaceID == v21)
        {
          int v22 = 1;
        }

        else
        {
          if (WiFiAwareInterfaceID) {
            BOOL v23 = WiFiAwareInterfaceID == v21;
          }
          else {
            BOOL v23 = 0;
          }
          int v22 = v23;
        }
      }

      else
      {
        int v22 = (*(unsigned __int8 *)(a1 + 234) >> 4) & 1;
      }

      __uint64_t monotonic_time_ns = _mdns_powerlog_get_monotonic_time_ns();
      bzero(v35, 0x3F1uLL);
      service_type_from_domain_name = _mdns_get_service_type_from_domain_name( (unsigned __int8 *)(v4 + 10),  (unsigned __int8 *)v35);
      _mdns_powerlog_bonjour_event( 1u,  v22,  (const char *)(a1 + 240),  (const char *)service_type_from_domain_name,  monotonic_time_ns);
      *(void *)(a1 + 8) = monotonic_time_ns;
    }

    if (mDNS_McastLoggingEnabled) {
      LogMcastQuestion((uint64_t)(v8 + 33), a1, 1);
    }
    uint64_t v26 = v8 + 1;
    if (callExternalHelpers(*(void *)v4, v26, *(unsigned int *)(a1 + 232), v16, v17, v18, v19, v20))
    {
      memset(v35, 0, 256);
      ConstructServiceName(v35, 0LL, (unsigned __int8 *)(v4 + 10), v26);
      if (mDNS_LoggingEnabled == 1) {
        LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEBUG,  "add_domain_to_browser: calling external_start_browsing_for_service()",  v27,  v28,  v29,  v30,  v31,  v33);
      }
      external_start_browsing_for_service( *(void *)v4,  (unsigned __int8 *)v35,  12,  *(_DWORD *)(a1 + 232),  *(_DWORD *)(a1 + 172));
    }

    return 0LL;
  }

  return started;
}

uint64_t ReconfirmAntecedents(uint64_t result, _BYTE *a2, int a3, uint64_t a4, int a5)
{
  if (a4)
  {
    uint64_t v8 = result;
    uint64_t v9 = 0LL;
    uint64_t v19 = (_BYTE *)(result + 46976);
    unsigned int v18 = a5 + 1;
    while (1)
    {
      uint64_t v17 = v9;
      uint64_t v10 = *(void **)(v8 + 8 * v9 + 280);
      if (v10) {
        break;
      }
LABEL_30:
      uint64_t v9 = v17 + 1;
      if (v17 == 498) {
        return result;
      }
    }

    while (1)
    {
      uint64_t v11 = v10[2];
      if (v11) {
        break;
      }
LABEL_29:
      uint64_t v10 = (void *)*v10;
      if (!v10) {
        goto LABEL_30;
      }
    }

    while (1)
    {
      if (*(_BYTE *)(v11 + 109) || *(void *)(v11 + 32) != a4 || *(_DWORD *)(v11 + 28) != a3) {
        goto LABEL_28;
      }
      unsigned int v12 = *(unsigned __int16 *)(v11 + 12);
      if (v12 <= 0x20)
      {
        switch(*(_WORD *)(v11 + 12))
        {
          case 0xC:
            goto LABEL_17;
          case 0xD:
          case 0xE:
          case 0x10:
          case 0x11:
          case 0x13:
          case 0x14:
            goto LABEL_28;
          case 0xF:
          case 0x12:
          case 0x15:
            goto LABEL_14;
          default:
            if (v12 == 2 || v12 == 5) {
              goto LABEL_17;
            }
            break;
        }

        goto LABEL_28;
      }

      switch(v12)
      {
        case '!':
          uint64_t v13 = (unsigned __int8 *)(*(void *)(v11 + 48) + 10LL);
          break;
        case '$':
LABEL_14:
          uint64_t v13 = (unsigned __int8 *)(*(void *)(v11 + 48) + 6LL);
          break;
        case '\'':
LABEL_17:
          uint64_t v13 = (unsigned __int8 *)(*(void *)(v11 + 48) + 4LL);
          break;
        default:
          goto LABEL_28;
      }

      ssize_t result = SameDomainNameBytes(v13, a2);
      if ((_DWORD)result)
      {
        int v14 = mDNS_DomainNameFNV1aHash(*(unsigned __int8 **)(v11 + 40));
        int v15 = mDNS_DomainNameFNV1aHash(v13);
        uint64_t v16 = (os_log_s *)mDNSLogCategory_mDNS;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
        {
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_25;
          }
        }

        else
        {
          uint64_t v16 = (os_log_s *)mDNSLogCategory_mDNS_redacted;
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
          {
LABEL_25:
            GetRRDisplayString_rdb((unsigned __int8 *)(v11 + 8), (unsigned __int16 *)(*(void *)(v11 + 48) + 4LL), v19);
            *(_DWORD *)buf = 67110403;
            int v22 = a5;
            __int16 v23 = 2048;
            uint64_t v24 = a4;
            __int16 v25 = 1024;
            int v26 = v14;
            __int16 v27 = 1024;
            int v28 = v15;
            __int16 v29 = 2160;
            uint64_t v30 = 1752392040LL;
            __int16 v31 = 2085;
            int v32 = v19;
            _os_log_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_DEFAULT,  "ReconfirmAntecedents: Reconfirming (depth=%d, InterfaceID=%p, name_hash=%x, target_name_hash=%x) %{sensitive, mask.hash}s",  buf,  0x32u);
          }
        }

        ssize_t result = mDNS_Reconfirm_internal(v8, v11, 0x1388u);
        if (a5 <= 4) {
          ssize_t result = ReconfirmAntecedents(v8, *(void *)(v11 + 40), *(unsigned int *)(v11 + 24), a4, v18);
        }
      }

void FoundInstance( uint64_t **a1, uint64_t a2, unsigned __int8 *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *(void *)(a2 + 176);
  if (*((_WORD *)a3 + 2) != 12)
  {
    LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "%3d: FoundInstance: Should not be called with rrtype %d (not a PTR record)",  a4,  a5,  a6,  a7,  a8,  *(_DWORD *)(v8 + 168));
    return;
  }

  int v9 = a4;
  unsigned int v13 = 2 * ((_DWORD)a4 != 0);
  int v14 = *(unsigned __int16 *)(a2 + 320);
  if (!*(_WORD *)(a2 + 320)
    && *(_BYTE *)(a2 + 331)
    && *(_DWORD *)(a2 + 228) >= *(unsigned __int8 *)(a2 + 331))
  {
    v13 |= 0x2000000u;
  }

  __int16 v312 = 0LL;
  if (*a3 == 240)
  {
    int v15 = (unsigned __int8 *)(a2 + 356);
    uint64_t v16 = *((void *)a3 + 3);
    uint64_t v17 = v8;
    unsigned int v18 = v13;
    unsigned int v19 = -65554;
LABEL_12:
    GenerateBrowseReply(v15, v16, v17, (char **)&v312, v18, v19);
    goto LABEL_13;
  }

  if (GenerateNTDResponse( (char *)(*((void *)a3 + 5) + 4LL),  *((void *)a3 + 3),  v8,  (char **)&v312,  (char *)0x42,  v13,  0))
  {
    if (!SameDomainNameBytes((_BYTE *)(*(void *)(v8 + 136) + 10LL), "\t_services\a_dns-sd\x04_udp"))
    {
      LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "%3d: FoundInstance: %##s PTR %##s received from network is not valid DNS-SD service pointer",  v25,  v26,  v27,  v28,  v29,  *(_DWORD *)(v8 + 168));
      return;
    }

    int v15 = (unsigned __int8 *)(*((void *)a3 + 5) + 4LL);
    uint64_t v16 = *((void *)a3 + 3);
    uint64_t v17 = v8;
    unsigned int v18 = v13;
    unsigned int v19 = 0;
    goto LABEL_12;
  }

LABEL_464:
              int v275 = *((unsigned __int16 *)a3 + 2);
              LODWORD(__tp.tv_sec) = 67111683;
              HIDWORD(__tp.tv_sec) = v122;
              LOWORD(__tp.tv_nsec) = 1024;
              *(_DWORD *)((char *)&__tp.tv_nsec + 2) = v123;
              HIWORD(__tp.tv_nsec) = 1024;
              int v314 = v9;
              __int16 v315 = 1024;
              int v316 = 0;
              __int16 v317 = 1024;
              *(_DWORD *)__int16 v318 = v30;
              *(_WORD *)&v318[4] = 2160;
              *(void *)&v318[6] = 1752392040LL;
              *(_WORD *)&v318[14] = 1040;
              *(_DWORD *)&v318[16] = v229;
              *(_WORD *)&v318[20] = 2101;
              *(void *)&v318[22] = a2 + 356;
              *(_WORD *)&v318[30] = 1024;
              *(_DWORD *)&v318[32] = v125;
              *(_WORD *)&v318[36] = 1026;
              *(_DWORD *)&v318[38] = v50;
              *(_WORD *)&v318[42] = 1024;
              *(_DWORD *)&v318[44] = v275;
              int v186 = "[R%u->Q%u] DNSServiceBrowse result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %d,"
                     " name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%x), dnssec: %{public, mdns:dnssec_re"
                     "sult}d, type: %{mdns:rrtype}d, rdata: <none>";
              int v187 = v121;
              uint32_t v188 = 76;
              goto LABEL_486;
            }

            unsigned int v43 = 0LL;
            unsigned int v51 = (char *)&unk_100164138;
            LODWORD(v48) = 512;
          }

          int v311 = 0;
          unsigned __int16 v310 = 0;
          uint64_t RDataBytesPointer = ResourceRecordGetRDataBytesPointer((uint64_t)a3, v51, v48, &v310, &v311, v34, v35, v36);
          if (!v311)
          {
            size_t v85 = v310;
            unint64_t v287 = (const void *)RDataBytesPointer;
            if (v310 >= 0x1FFuLL)
            {
              unsigned int v295 = v310 + 2;
              int v86 = (__int16 *)malloc(v310 + 2LL);
              if (!v86) {
                goto LABEL_487;
              }
              uint64_t v303 = v86;
            }

            else
            {
              unsigned int v295 = 512;
              uint64_t v303 = 0LL;
              int v86 = word_100164338;
            }

            int v292 = v86;
            if (v14) {
              int v154 = (os_log_s *)mDNSLogCategory_Default;
            }
            else {
              int v154 = (os_log_s *)mDNSLogCategory_mDNS;
            }
            if (gSensitiveLoggingEnabled != 1 || v154 == (os_log_s *)mDNSLogCategory_State)
            {
              if (!os_log_type_enabled(v154, OS_LOG_TYPE_DEFAULT)) {
                goto LABEL_478;
              }
              int v160 = *(_DWORD *)(v8 + 184);
              unsigned int v161 = bswap32(*(unsigned __int16 *)(a2 + 320)) >> 16;
              int v162 = (_BYTE *)(a2 + 356);
              if (a2 == -612)
              {
LABEL_259:
                while (v162)
                {
                  uint64_t v163 = *v162;
                  if (!*v162)
                  {
                    int v210 = (unsigned __int16)((_WORD)v162 - v31 + 1);
                    goto LABEL_440;
                  }

                  v162 += v163 + 1;
                  if (a2 != -612) {
                    goto LABEL_258;
                  }
                }
              }

              else
              {
LABEL_258:
              }

              int v210 = 257;
LABEL_440:
              unsigned int v257 = *((unsigned __int16 *)a3 + 2);
              int v258 = v85 + 2;
              if ((int)v85 + 2 <= v295)
              {
                *int v292 = __rev16(v257);
                size_t v260 = v85;
                int v261 = v160;
                int v302 = v258;
                memcpy(v292 + 1, v287, v260);
                int v258 = v302;
                int v160 = v261;
                int v259 = v292;
              }

              else
              {
                int v259 = 0LL;
              }

              LODWORD(__tp.tv_sec) = 67112451;
              HIDWORD(__tp.tv_sec) = v160;
              LOWORD(__tp.tv_nsec) = 1024;
              *(_DWORD *)((char *)&__tp.tv_nsec + 2) = v161;
              HIWORD(__tp.tv_nsec) = 1024;
              int v314 = v9;
              __int16 v315 = 1024;
              int v316 = 0;
              __int16 v317 = 1024;
              *(_DWORD *)__int16 v318 = v309;
              *(_WORD *)&v318[4] = 2160;
              *(void *)&v318[6] = 1752392040LL;
              *(_WORD *)&v318[14] = 1040;
              *(_DWORD *)&v318[16] = v210;
              *(_WORD *)&v318[20] = 2101;
              *(void *)&v318[22] = v31;
              *(_WORD *)&v318[30] = 1024;
              *(_DWORD *)&v318[32] = v304;
              *(_WORD *)&v318[36] = 1026;
              *(_DWORD *)&v318[38] = v50;
              *(_WORD *)&v318[42] = 1024;
              *(_DWORD *)&v318[44] = v257;
              *(_WORD *)&v318[48] = 2160;
              *(void *)&v318[50] = 1752392040LL;
              *(_WORD *)&v318[58] = 1040;
              *(_DWORD *)&v318[60] = v258;
              *(_WORD *)&v318[64] = 2101;
              *(void *)&v318[66] = v259;
              uint64_t v214 = "[R%u->Q%u] DNSServiceBrowse result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %d,"
                     " name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%x), dnssec: %{public, mdns:dnssec_re"
                     "sult}d, type: %{mdns:rrtype}d, rdata: %{sensitive, mask.hash, mdns:rdata}.*P";
              int v225 = v154;
            }

            else
            {
              if (v14) {
                unsigned int v155 = (os_log_s *)mDNSLogCategory_Default_redacted;
              }
              else {
                unsigned int v155 = (os_log_s *)mDNSLogCategory_mDNS;
              }
              if (!os_log_type_enabled(v155, OS_LOG_TYPE_DEFAULT)) {
                goto LABEL_478;
              }
              int v156 = *(_DWORD *)(v8 + 184);
              unsigned int v157 = bswap32(*(unsigned __int16 *)(a2 + 320)) >> 16;
              int v158 = (_BYTE *)(a2 + 356);
              if (a2 == -612)
              {
LABEL_248:
                while (v158)
                {
                  uint64_t v159 = *v158;
                  if (!*v158)
                  {
                    int v209 = (unsigned __int16)((_WORD)v158 - v31 + 1);
                    goto LABEL_435;
                  }

                  v158 += v159 + 1;
                  if (a2 != -612) {
                    goto LABEL_247;
                  }
                }
              }

              else
              {
LABEL_247:
              }

              int v209 = 257;
LABEL_435:
              unsigned int v251 = *((unsigned __int16 *)a3 + 2);
              int v252 = v85 + 2;
              if ((int)v85 + 2 <= v295)
              {
                *int v292 = __rev16(v251);
                size_t v254 = v85;
                int v255 = v156;
                BOOL v301 = v155;
                unsigned int v256 = v251;
                memcpy(v292 + 1, v287, v254);
                unsigned int v251 = v256;
                int v253 = v292;
                unsigned int v155 = v301;
                int v156 = v255;
              }

              else
              {
                int v253 = 0LL;
              }

              LODWORD(__tp.tv_sec) = 67112451;
              HIDWORD(__tp.tv_sec) = v156;
              LOWORD(__tp.tv_nsec) = 1024;
              *(_DWORD *)((char *)&__tp.tv_nsec + 2) = v157;
              HIWORD(__tp.tv_nsec) = 1024;
              int v314 = v9;
              __int16 v315 = 1024;
              int v316 = 0;
              __int16 v317 = 1024;
              *(_DWORD *)__int16 v318 = v309;
              *(_WORD *)&v318[4] = 2160;
              *(void *)&v318[6] = 1752392040LL;
              *(_WORD *)&v318[14] = 1040;
              *(_DWORD *)&v318[16] = v209;
              *(_WORD *)&v318[20] = 2101;
              *(void *)&v318[22] = v31;
              *(_WORD *)&v318[30] = 1024;
              *(_DWORD *)&v318[32] = v304;
              *(_WORD *)&v318[36] = 1026;
              *(_DWORD *)&v318[38] = v50;
              *(_WORD *)&v318[42] = 1024;
              *(_DWORD *)&v318[44] = v251;
              *(_WORD *)&v318[48] = 2160;
              *(void *)&v318[50] = 1752392040LL;
              *(_WORD *)&v318[58] = 1040;
              *(_DWORD *)&v318[60] = v252;
              *(_WORD *)&v318[64] = 2101;
              *(void *)&v318[66] = v253;
              uint64_t v214 = "[R%u->Q%u] DNSServiceBrowse result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %d,"
                     " name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%x), dnssec: %{public, mdns:dnssec_re"
                     "sult}d, type: %{mdns:rrtype}d, rdata: %{sensitive, mask.hash, mdns:rdata}.*P";
              int v225 = v155;
            }

            uint32_t v226 = 102;
            goto LABEL_477;
          }

          goto LABEL_480;
        }

        if (v48 >= 0x201)
        {
          unsigned int v43 = (char *)malloc(*((unsigned __int16 *)a3 + 6));
          unsigned int v73 = v43;
          if (!v43) {
            goto LABEL_487;
          }
        }

        else
        {
          if (!*((_WORD *)a3 + 6))
          {
            if (v14) {
              unsigned int v165 = (os_log_s *)mDNSLogCategory_Default;
            }
            else {
              unsigned int v165 = (os_log_s *)mDNSLogCategory_mDNS;
            }
            if (gSensitiveLoggingEnabled != 1 || v165 == (os_log_s *)mDNSLogCategory_State)
            {
              if (!os_log_type_enabled(v165, OS_LOG_TYPE_DEFAULT)) {
                goto LABEL_482;
              }
              int v166 = *(_DWORD *)(v8 + 184);
              int v207 = (_BYTE *)(a2 + 356);
              int v168 = v304;
              if (a2 == -612)
              {
LABEL_395:
                while (v207)
                {
                  uint64_t v208 = *v207;
                  if (!*v207)
                  {
                    int v266 = (unsigned __int16)((_WORD)v207 - v31 + 1);
                    goto LABEL_485;
                  }

                  v207 += v208 + 1;
                  if (a2 != -612) {
                    goto LABEL_394;
                  }
                }
              }

              else
              {
LABEL_394:
              }

              int v266 = 257;
            }

            else
            {
              if (v14) {
                unsigned int v165 = (os_log_s *)mDNSLogCategory_Default_redacted;
              }
              else {
                unsigned int v165 = (os_log_s *)mDNSLogCategory_mDNS;
              }
              if (!os_log_type_enabled(v165, OS_LOG_TYPE_DEFAULT)) {
                goto LABEL_482;
              }
              int v166 = *(_DWORD *)(v8 + 184);
              int v167 = (_BYTE *)(a2 + 356);
              int v168 = v304;
              if (a2 == -612)
              {
LABEL_285:
                while (v167)
                {
                  uint64_t v169 = *v167;
                  if (!*v167)
                  {
                    int v266 = (unsigned __int16)((_WORD)v167 - v31 + 1);
                    goto LABEL_485;
                  }

                  v167 += v169 + 1;
                  if (a2 != -612) {
                    goto LABEL_284;
                  }
                }
              }

              else
              {
LABEL_284:
              }

              int v266 = 257;
            }