LABEL_485:
            v286 = *((unsigned __int16 *)a3 + 2);
            LODWORD(__tp.tv_sec) = 67111427;
            HIDWORD(__tp.tv_sec) = v166;
            LOWORD(__tp.tv_nsec) = 1024;
            *(_DWORD *)((char *)&__tp.tv_nsec + 2) = v9;
            HIWORD(__tp.tv_nsec) = 1024;
            v314 = 0;
            v315 = 1024;
            v316 = v30;
            v317 = 2160;
            *(void *)v318 = 1752392040LL;
            *(_WORD *)&v318[8] = 1040;
            *(_DWORD *)&v318[10] = v266;
            *(_WORD *)&v318[14] = 2101;
            *(void *)&v318[16] = a2 + 356;
            *(_WORD *)&v318[24] = 1024;
            *(_DWORD *)&v318[26] = v168;
            *(_WORD *)&v318[30] = 1026;
            *(_DWORD *)&v318[32] = v50;
            *(_WORD *)&v318[36] = 1024;
            *(_DWORD *)&v318[38] = v286;
            v186 = "[R%u->mDNS] DNSServiceBrowse result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %d, "
                   "name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%x), dnssec: %{public, mdns:dnssec_resul"
                   "t}d, type: %{mdns:rrtype}d, rdata: <none>";
            v187 = v165;
            v188 = 70;
            goto LABEL_486;
          }

          v43 = 0LL;
          v73 = (char *)&unk_100164138;
          LODWORD(v48) = 512;
        }

        v311 = 0;
        v310 = 0;
        v109 = ResourceRecordGetRDataBytesPointer((uint64_t)a3, v73, v48, &v310, &v311, v34, v35, v36);
        if (v311) {
          goto LABEL_480;
        }
        v110 = v310;
        v288 = (const void *)v109;
        if (v310 >= 0x1FFuLL)
        {
          v296 = v310 + 2;
          v112 = (__int16 *)malloc(v310 + 2LL);
          if (!v112) {
            goto LABEL_487;
          }
          v111 = v112;
        }

        else
        {
          v111 = 0LL;
          v296 = 512;
          v112 = word_100164338;
        }

        v293 = v112;
        v303 = v111;
        if (v14) {
          v195 = (os_log_s *)mDNSLogCategory_Default;
        }
        else {
          v195 = (os_log_s *)mDNSLogCategory_mDNS;
        }
        if (gSensitiveLoggingEnabled != 1 || v195 == (os_log_s *)mDNSLogCategory_State)
        {
          if (!os_log_type_enabled(v195, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_478;
          }
          v199 = *(_DWORD *)(v8 + 184);
          v200 = (_BYTE *)(a2 + 356);
          if (a2 == -612)
          {
LABEL_381:
            while (v200)
            {
              v201 = *v200;
              if (!*v200)
              {
                v231 = (unsigned __int16)((_WORD)v200 - v31 + 1);
                goto LABEL_472;
              }

              v200 += v201 + 1;
              if (a2 != -612) {
                goto LABEL_380;
              }
            }
          }

          else
          {
LABEL_380:
          }

          v231 = 257;
LABEL_472:
          v281 = *((unsigned __int16 *)a3 + 2);
          v282 = v110 + 2;
          if ((int)v110 + 2 <= v296)
          {
            *v293 = __rev16(v281);
            v284 = v110;
            v285 = v199;
            memcpy(v293 + 1, v288, v284);
            v199 = v285;
            v283 = v293;
          }

          else
          {
            v283 = 0LL;
          }

          LODWORD(__tp.tv_sec) = 67112195;
          HIDWORD(__tp.tv_sec) = v199;
          LOWORD(__tp.tv_nsec) = 1024;
          *(_DWORD *)((char *)&__tp.tv_nsec + 2) = v9;
          HIWORD(__tp.tv_nsec) = 1024;
          v314 = 0;
          v315 = 1024;
          v316 = v309;
          v317 = 2160;
          *(void *)v318 = 1752392040LL;
          *(_WORD *)&v318[8] = 1040;
          *(_DWORD *)&v318[10] = v231;
          *(_WORD *)&v318[14] = 2101;
          *(void *)&v318[16] = v31;
          *(_WORD *)&v318[24] = 1024;
          *(_DWORD *)&v318[26] = v304;
          *(_WORD *)&v318[30] = 1026;
          *(_DWORD *)&v318[32] = v50;
          *(_WORD *)&v318[36] = 1024;
          *(_DWORD *)&v318[38] = v281;
          *(_WORD *)&v318[42] = 2160;
          *(void *)&v318[44] = 1752392040LL;
          *(_WORD *)&v318[52] = 1040;
          *(_DWORD *)&v318[54] = v282;
          *(_WORD *)&v318[58] = 2101;
          *(void *)&v318[60] = v283;
          v214 = "[R%u->mDNS] DNSServiceBrowse result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %d, na"
                 "me: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%x), dnssec: %{public, mdns:dnssec_result}d,"
                 " type: %{mdns:rrtype}d, rdata: %{sensitive, mask.hash, mdns:rdata}.*P";
          v225 = v195;
          goto LABEL_476;
        }

        if (v14) {
          v134 = (os_log_s *)mDNSLogCategory_Default_redacted;
        }
        else {
          v134 = (os_log_s *)mDNSLogCategory_mDNS;
        }
        if (!os_log_type_enabled(v134, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_478;
        }
        v196 = *(_DWORD *)(v8 + 184);
        v197 = (_BYTE *)(a2 + 356);
        if (a2 == -612)
        {
LABEL_370:
          while (v197)
          {
            v198 = *v197;
            if (!*v197)
            {
              v230 = (unsigned __int16)((_WORD)v197 - v31 + 1);
              goto LABEL_466;
            }

            v197 += v198 + 1;
            if (a2 != -612) {
              goto LABEL_369;
            }
          }
        }

        else
        {
LABEL_369:
        }

        v230 = 257;
LABEL_466:
        v276 = *((unsigned __int16 *)a3 + 2);
        v277 = v110 + 2;
        if ((int)v110 + 2 <= v296)
        {
          *v293 = __rev16(v276);
          v279 = v110;
          v280 = v196;
          memcpy(v293 + 1, v288, v279);
          v196 = v280;
          v278 = v293;
        }

        else
        {
          v278 = 0LL;
        }

        LODWORD(__tp.tv_sec) = 67112195;
        HIDWORD(__tp.tv_sec) = v196;
        LOWORD(__tp.tv_nsec) = 1024;
        *(_DWORD *)((char *)&__tp.tv_nsec + 2) = v9;
        HIWORD(__tp.tv_nsec) = 1024;
        v314 = 0;
        v315 = 1024;
        v316 = v309;
        v317 = 2160;
        *(void *)v318 = 1752392040LL;
        *(_WORD *)&v318[8] = 1040;
        *(_DWORD *)&v318[10] = v230;
        *(_WORD *)&v318[14] = 2101;
        *(void *)&v318[16] = v31;
        *(_WORD *)&v318[24] = 1024;
        *(_DWORD *)&v318[26] = v304;
        *(_WORD *)&v318[30] = 1026;
        *(_DWORD *)&v318[32] = v50;
        *(_WORD *)&v318[36] = 1024;
        *(_DWORD *)&v318[38] = v276;
        *(_WORD *)&v318[42] = 2160;
        *(void *)&v318[44] = 1752392040LL;
        *(_WORD *)&v318[52] = 1040;
        *(_DWORD *)&v318[54] = v277;
        *(_WORD *)&v318[58] = 2101;
        *(void *)&v318[60] = v278;
        v214 = "[R%u->mDNS] DNSServiceBrowse result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %d, name"
               ": %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%x), dnssec: %{public, mdns:dnssec_result}d, typ"
               "e: %{mdns:rrtype}d, rdata: %{sensitive, mask.hash, mdns:rdata}.*P";
        goto LABEL_470;
      }
    }

    else
    {
      v47 = *(unsigned __int16 *)(a2 + 320);
      LODWORD(v48) = *((unsigned __int16 *)a3 + 6);
      v49 = v48 < 0x201;
    }

    if (!v47)
    {
      if (v49)
      {
        v43 = 0LL;
        v58 = 512;
        v59 = (char *)&unk_100164138;
        v60 = v304;
      }

      else
      {
        v59 = (char *)malloc(v48);
        v43 = v59;
        v58 = v48;
        v60 = v304;
        if (!v59) {
          goto LABEL_487;
        }
      }

      if ((_DWORD)v48)
      {
        v311 = 0;
        v310 = 0;
        v93 = ResourceRecordGetRDataBytesPointer((uint64_t)a3, v59, v58, &v310, &v311, v34, v35, v36);
        if (!v311)
        {
          v94 = (const void *)v93;
          v95 = v310;
          if (v310 >= 0x1FFuLL)
          {
            v97 = (__int16 *)malloc(v310 + 2LL);
            if (!v97) {
              goto LABEL_487;
            }
            v291 = v95 + 2;
            v96 = v97;
          }

          else
          {
            v96 = 0LL;
            v291 = 512;
            v97 = word_100164338;
          }

          v299 = v97;
          v303 = v96;
          if (v14) {
            v175 = (os_log_s *)mDNSLogCategory_Default;
          }
          else {
            v175 = (os_log_s *)mDNSLogCategory_mDNS;
          }
          if (gSensitiveLoggingEnabled != 1 || v175 == (os_log_s *)mDNSLogCategory_State)
          {
            if (!os_log_type_enabled(v175, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_478;
            }
            v180 = *(_DWORD *)(v8 + 184);
            v181 = (_BYTE *)(a2 + 356);
            if (a2 == -612)
            {
LABEL_327:
              while (v181)
              {
                v182 = *v181;
                if (!*v181)
                {
                  v228 = (unsigned __int16)((_WORD)v181 - v31 + 1);
                  goto LABEL_457;
                }

                v181 += v182 + 1;
                if (a2 != -612) {
                  goto LABEL_326;
                }
              }
            }

            else
            {
LABEL_326:
            }

            v228 = 257;
LABEL_457:
            v271 = *((unsigned __int16 *)a3 + 2);
            if ((int)v95 + 2 <= v291)
            {
              *v299 = __rev16(v271);
              v273 = v94;
              v274 = v180;
              memcpy(v299 + 1, v273, v95);
              v180 = v274;
              v272 = v299;
            }

            else
            {
              v272 = 0LL;
            }

            LODWORD(__tp.tv_sec) = 67111939;
            HIDWORD(__tp.tv_sec) = v180;
            LOWORD(__tp.tv_nsec) = 1024;
            *(_DWORD *)((char *)&__tp.tv_nsec + 2) = v9;
            HIWORD(__tp.tv_nsec) = 1024;
            v314 = 0;
            v315 = 1024;
            v316 = v309;
            v317 = 2160;
            *(void *)v318 = 1752392040LL;
            *(_WORD *)&v318[8] = 1040;
            *(_DWORD *)&v318[10] = v228;
            *(_WORD *)&v318[14] = 2101;
            *(void *)&v318[16] = v31;
            *(_WORD *)&v318[24] = 1024;
            *(_DWORD *)&v318[26] = v304;
            *(_WORD *)&v318[30] = 1024;
            *(_DWORD *)&v318[32] = v271;
            *(_WORD *)&v318[36] = 2160;
            *(void *)&v318[38] = 1752392040LL;
            *(_WORD *)&v318[46] = 1040;
            *(_DWORD *)&v318[48] = v95 + 2;
            *(_WORD *)&v318[52] = 2101;
            *(void *)&v318[54] = v272;
            v214 = "[R%u->mDNS] DNSServiceBrowse result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %d, "
                   "name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%x), type: %{mdns:rrtype}d, rdata: %{sen"
                   "sitive, mask.hash, mdns:rdata}.*P";
            v225 = v175;
          }

          else
          {
            if (v14) {
              v176 = (os_log_s *)mDNSLogCategory_Default_redacted;
            }
            else {
              v176 = (os_log_s *)mDNSLogCategory_mDNS;
            }
            if (!os_log_type_enabled(v176, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_478;
            }
            v177 = *(_DWORD *)(v8 + 184);
            v178 = (_BYTE *)(a2 + 356);
            if (a2 == -612)
            {
LABEL_316:
              while (v178)
              {
                v179 = *v178;
                if (!*v178)
                {
                  v227 = (unsigned __int16)((_WORD)v178 - v31 + 1);
                  goto LABEL_452;
                }

                v178 += v179 + 1;
                if (a2 != -612) {
                  goto LABEL_315;
                }
              }
            }

            else
            {
LABEL_315:
            }

            v227 = 257;
LABEL_452:
            v267 = *((unsigned __int16 *)a3 + 2);
            if ((int)v95 + 2 <= v291)
            {
              *v299 = __rev16(v267);
              v269 = v94;
              v270 = v177;
              memcpy(v299 + 1, v269, v95);
              v177 = v270;
              v268 = v299;
            }

            else
            {
              v268 = 0LL;
            }

            LODWORD(__tp.tv_sec) = 67111939;
            HIDWORD(__tp.tv_sec) = v177;
            LOWORD(__tp.tv_nsec) = 1024;
            *(_DWORD *)((char *)&__tp.tv_nsec + 2) = v9;
            HIWORD(__tp.tv_nsec) = 1024;
            v314 = 0;
            v315 = 1024;
            v316 = v309;
            v317 = 2160;
            *(void *)v318 = 1752392040LL;
            *(_WORD *)&v318[8] = 1040;
            *(_DWORD *)&v318[10] = v227;
            *(_WORD *)&v318[14] = 2101;
            *(void *)&v318[16] = v31;
            *(_WORD *)&v318[24] = 1024;
            *(_DWORD *)&v318[26] = v304;
            *(_WORD *)&v318[30] = 1024;
            *(_DWORD *)&v318[32] = v267;
            *(_WORD *)&v318[36] = 2160;
            *(void *)&v318[38] = 1752392040LL;
            *(_WORD *)&v318[46] = 1040;
            *(_DWORD *)&v318[48] = v95 + 2;
            *(_WORD *)&v318[52] = 2101;
            *(void *)&v318[54] = v268;
            v214 = "[R%u->mDNS] DNSServiceBrowse result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %d, "
                   "name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%x), type: %{mdns:rrtype}d, rdata: %{sen"
                   "sitive, mask.hash, mdns:rdata}.*P";
            v225 = v176;
          }

          v226 = 90;
          goto LABEL_477;
        }

        goto LABEL_480;
      }

      if (v14) {
        v99 = (os_log_s *)mDNSLogCategory_Default;
      }
      else {
        v99 = (os_log_s *)mDNSLogCategory_mDNS;
      }
      if (gSensitiveLoggingEnabled != 1 || v99 == (os_log_s *)mDNSLogCategory_State)
      {
        if (!os_log_type_enabled(v99, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_480;
        }
        v100 = *(_DWORD *)(v8 + 184);
        v145 = (_BYTE *)(a2 + 356);
        if (a2 == -612)
        {
LABEL_217:
          while (v145)
          {
            v146 = *v145;
            if (!*v145)
            {
              v204 = (unsigned __int16)((_WORD)v145 - v31 + 1);
              goto LABEL_429;
            }

            v145 += v146 + 1;
            if (a2 != -612) {
              goto LABEL_216;
            }
          }
        }

        else
        {
LABEL_216:
        }

        v204 = 257;
      }

      else
      {
        if (v14) {
          v99 = (os_log_s *)mDNSLogCategory_Default_redacted;
        }
        else {
          v99 = (os_log_s *)mDNSLogCategory_mDNS;
        }
        if (!os_log_type_enabled(v99, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_480;
        }
        v100 = *(_DWORD *)(v8 + 184);
        v101 = (_BYTE *)(a2 + 356);
        if (a2 == -612)
        {
LABEL_121:
          while (v101)
          {
            v102 = *v101;
            if (!*v101)
            {
              v204 = (unsigned __int16)((_WORD)v101 - v31 + 1);
              goto LABEL_429;
            }

            v101 += v102 + 1;
            if (a2 != -612) {
              goto LABEL_120;
            }
          }
        }

        else
        {
LABEL_120:
        }

        v204 = 257;
      }

LABEL_429:
      v246 = *((unsigned __int16 *)a3 + 2);
      LODWORD(__tp.tv_sec) = 67111171;
      HIDWORD(__tp.tv_sec) = v100;
      LOWORD(__tp.tv_nsec) = 1024;
      *(_DWORD *)((char *)&__tp.tv_nsec + 2) = v9;
      HIWORD(__tp.tv_nsec) = 1024;
      v314 = 0;
      v315 = 1024;
      v316 = v309;
      v317 = 2160;
      *(void *)v318 = 1752392040LL;
      *(_WORD *)&v318[8] = 1040;
      *(_DWORD *)&v318[10] = v204;
      *(_WORD *)&v318[14] = 2101;
      *(void *)&v318[16] = a2 + 356;
      *(_WORD *)&v318[24] = 1024;
      *(_DWORD *)&v318[26] = v60;
      *(_WORD *)&v318[30] = 1024;
      *(_DWORD *)&v318[32] = v246;
      v115 = "[R%u->mDNS] DNSServiceBrowse result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %d, name: "
             "%{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%x), type: %{mdns:rrtype}d, rdata: <none>";
      v116 = v99;
      v117 = 64;
      goto LABEL_430;
    }

    if (v49)
    {
      v43 = 0LL;
      v54 = 512;
      v55 = (char *)&unk_100164138;
    }

    else
    {
      v55 = (char *)malloc(v48);
      v43 = v55;
      v54 = v48;
      if (!v55) {
        goto LABEL_487;
      }
    }

    if (!(_DWORD)v48)
    {
      if (v14) {
        v75 = (os_log_s *)mDNSLogCategory_Default;
      }
      else {
        v75 = (os_log_s *)mDNSLogCategory_mDNS;
      }
      if (gSensitiveLoggingEnabled != 1 || v75 == (os_log_s *)mDNSLogCategory_State)
      {
        if (!os_log_type_enabled(v75, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_480;
        }
        v76 = *(_DWORD *)(v8 + 184);
        v77 = __rev16(v47);
        v118 = (_BYTE *)(a2 + 356);
        v79 = v304;
        if (a2 == -612)
        {
LABEL_139:
          while (v118)
          {
            v119 = *v118;
            if (!*v118)
            {
              v183 = (unsigned __int16)((_WORD)v118 - v31 + 1);
              goto LABEL_404;
            }

            v118 += v119 + 1;
            if (a2 != -612) {
              goto LABEL_138;
            }
          }
        }

        else
        {
LABEL_138:
        }

        v183 = 257;
      }

      else
      {
        if (v14) {
          v75 = (os_log_s *)mDNSLogCategory_Default_redacted;
        }
        else {
          v75 = (os_log_s *)mDNSLogCategory_mDNS;
        }
        if (!os_log_type_enabled(v75, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_480;
        }
        v76 = *(_DWORD *)(v8 + 184);
        v77 = __rev16(v47);
        v78 = (_BYTE *)(a2 + 356);
        v79 = v304;
        if (a2 == -612)
        {
LABEL_77:
          while (v78)
          {
            v80 = *v78;
            if (!*v78)
            {
              v183 = (unsigned __int16)((_WORD)v78 - v31 + 1);
              goto LABEL_404;
            }

            v78 += v80 + 1;
            if (a2 != -612) {
              goto LABEL_76;
            }
          }
        }

        else
        {
LABEL_76:
        }

        v183 = 257;
      }

LABEL_404:
      v211 = *((unsigned __int16 *)a3 + 2);
      LODWORD(__tp.tv_sec) = 67111427;
      HIDWORD(__tp.tv_sec) = v76;
      LOWORD(__tp.tv_nsec) = 1024;
      *(_DWORD *)((char *)&__tp.tv_nsec + 2) = v77;
      HIWORD(__tp.tv_nsec) = 1024;
      v314 = v9;
      v315 = 1024;
      v316 = 0;
      v317 = 1024;
      *(_DWORD *)v318 = v309;
      *(_WORD *)&v318[4] = 2160;
      *(void *)&v318[6] = 1752392040LL;
      *(_WORD *)&v318[14] = 1040;
      *(_DWORD *)&v318[16] = v183;
      *(_WORD *)&v318[20] = 2101;
      *(void *)&v318[22] = a2 + 356;
      *(_WORD *)&v318[30] = 1024;
      *(_DWORD *)&v318[32] = v79;
      *(_WORD *)&v318[36] = 1024;
      *(_DWORD *)&v318[38] = v211;
      v115 = "[R%u->Q%u] DNSServiceBrowse result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %d, name: %"
             "{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%x), type: %{mdns:rrtype}d, rdata: <none>";
      v116 = v75;
      v117 = 70;
      goto LABEL_430;
    }

    v311 = 0;
    v310 = 0;
    v67 = ResourceRecordGetRDataBytesPointer((uint64_t)a3, v55, v54, &v310, &v311, v34, v35, v36);
    if (v311) {
      goto LABEL_480;
    }
    v68 = (const void *)v67;
    v69 = v310;
    if (v310 >= 0x1FFuLL)
    {
      v71 = (__int16 *)malloc(v310 + 2LL);
      if (!v71) {
        goto LABEL_487;
      }
      v289 = v69 + 2;
      v70 = v71;
    }

    else
    {
      v70 = 0LL;
      v289 = 512;
      v71 = word_100164338;
    }

    v298 = v71;
    v303 = v70;
    if (v14) {
      v133 = (os_log_s *)mDNSLogCategory_Default;
    }
    else {
      v133 = (os_log_s *)mDNSLogCategory_mDNS;
    }
    if (gSensitiveLoggingEnabled != 1 || v133 == (os_log_s *)mDNSLogCategory_State)
    {
      if (!os_log_type_enabled(v133, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_478;
      }
      v139 = *(_DWORD *)(v8 + 184);
      v140 = bswap32(*(unsigned __int16 *)(a2 + 320)) >> 16;
      v141 = (_BYTE *)(a2 + 356);
      if (a2 == -612)
      {
LABEL_207:
        while (v141)
        {
          v142 = *v141;
          if (!*v141)
          {
            v203 = (unsigned __int16)((_WORD)v141 - v31 + 1);
            goto LABEL_423;
          }

          v141 += v142 + 1;
          if (a2 != -612) {
            goto LABEL_206;
          }
        }
      }

      else
      {
LABEL_206:
      }

      v203 = 257;
LABEL_423:
      v239 = *((unsigned __int16 *)a3 + 2);
      v240 = v69 + 2;
      if ((int)v69 + 2 <= v289)
      {
        *v298 = __rev16(v239);
        v242 = v69;
        v243 = v68;
        v244 = v139;
        v245 = v140;
        memcpy(v298 + 1, v243, v242);
        v140 = v245;
        v139 = v244;
        v241 = v298;
      }

      else
      {
        v241 = 0LL;
      }

      LODWORD(__tp.tv_sec) = 67112195;
      HIDWORD(__tp.tv_sec) = v139;
      LOWORD(__tp.tv_nsec) = 1024;
      *(_DWORD *)((char *)&__tp.tv_nsec + 2) = v140;
      HIWORD(__tp.tv_nsec) = 1024;
      v314 = v9;
      v315 = 1024;
      v316 = 0;
      v317 = 1024;
      *(_DWORD *)v318 = v309;
      *(_WORD *)&v318[4] = 2160;
      *(void *)&v318[6] = 1752392040LL;
      *(_WORD *)&v318[14] = 1040;
      *(_DWORD *)&v318[16] = v203;
      *(_WORD *)&v318[20] = 2101;
      *(void *)&v318[22] = v31;
      *(_WORD *)&v318[30] = 1024;
      *(_DWORD *)&v318[32] = v304;
      *(_WORD *)&v318[36] = 1024;
      *(_DWORD *)&v318[38] = v239;
      *(_WORD *)&v318[42] = 2160;
      *(void *)&v318[44] = 1752392040LL;
      *(_WORD *)&v318[52] = 1040;
      *(_DWORD *)&v318[54] = v240;
      *(_WORD *)&v318[58] = 2101;
      *(void *)&v318[60] = v241;
      v214 = "[R%u->Q%u] DNSServiceBrowse result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %d, name: %"
             "{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%x), type: %{mdns:rrtype}d, rdata: %{sensitive, mask."
             "hash, mdns:rdata}.*P";
      v225 = v133;
      goto LABEL_476;
    }

    if (v14) {
      v134 = (os_log_s *)mDNSLogCategory_Default_redacted;
    }
    else {
      v134 = (os_log_s *)mDNSLogCategory_mDNS;
    }
    if (!os_log_type_enabled(v134, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_478;
    }
    v135 = *(_DWORD *)(v8 + 184);
    v136 = bswap32(*(unsigned __int16 *)(a2 + 320)) >> 16;
    v137 = (_BYTE *)(a2 + 356);
    if (a2 == -612)
    {
LABEL_196:
      while (v137)
      {
        v138 = *v137;
        if (!*v137)
        {
          v202 = (unsigned __int16)((_WORD)v137 - v31 + 1);
          goto LABEL_418;
        }

        v137 += v138 + 1;
        if (a2 != -612) {
          goto LABEL_195;
        }
      }
    }

    else
    {
LABEL_195:
    }

    v202 = 257;
LABEL_418:
    v232 = *((unsigned __int16 *)a3 + 2);
    v233 = v69 + 2;
    if ((int)v69 + 2 <= v289)
    {
      *v298 = __rev16(v232);
      v235 = v68;
      v236 = v69;
      v237 = v135;
      v238 = v136;
      memcpy(v298 + 1, v235, v236);
      v136 = v238;
      v135 = v237;
      v234 = v298;
    }

    else
    {
      v234 = 0LL;
    }

    LODWORD(__tp.tv_sec) = 67112195;
    HIDWORD(__tp.tv_sec) = v135;
    LOWORD(__tp.tv_nsec) = 1024;
    *(_DWORD *)((char *)&__tp.tv_nsec + 2) = v136;
    HIWORD(__tp.tv_nsec) = 1024;
    v314 = v9;
    v315 = 1024;
    v316 = 0;
    v317 = 1024;
    *(_DWORD *)v318 = v309;
    *(_WORD *)&v318[4] = 2160;
    *(void *)&v318[6] = 1752392040LL;
    *(_WORD *)&v318[14] = 1040;
    *(_DWORD *)&v318[16] = v202;
    *(_WORD *)&v318[20] = 2101;
    *(void *)&v318[22] = v31;
    *(_WORD *)&v318[30] = 1024;
    *(_DWORD *)&v318[32] = v304;
    *(_WORD *)&v318[36] = 1024;
    *(_DWORD *)&v318[38] = v232;
    *(_WORD *)&v318[42] = 2160;
    *(void *)&v318[44] = 1752392040LL;
    *(_WORD *)&v318[52] = 1040;
    *(_DWORD *)&v318[54] = v233;
    *(_WORD *)&v318[58] = 2101;
    *(void *)&v318[60] = v234;
    v214 = "[R%u->Q%u] DNSServiceBrowse result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %d, name: %{s"
           "ensitive, mask.hash, mdnsresponder:domain_name}.*P (%x), type: %{mdns:rrtype}d, rdata: %{sensitive, mask.hash"
           ", mdns:rdata}.*P";
LABEL_470:
    v225 = v134;
LABEL_476:
    v226 = 96;
    goto LABEL_477;
  }

  v37 = *((void *)a3 + 7);
  if (!v37)
  {
    v39 = *(unsigned __int16 *)(a2 + 320);
    LODWORD(v40) = *((unsigned __int16 *)a3 + 6);
    v41 = v40 < 0x201;
LABEL_28:
    if (v39)
    {
      if (v41)
      {
        v43 = 0LL;
        v52 = 512;
        v53 = (char *)&unk_100164138;
      }

      else
      {
        v53 = (char *)malloc(v40);
        v43 = v53;
        v52 = v40;
        if (!v53) {
          goto LABEL_487;
        }
      }

      if ((_DWORD)v40)
      {
        v311 = 0;
        v310 = 0;
        v61 = ResourceRecordGetRDataBytesPointer((uint64_t)a3, v53, v52, &v310, &v311, v34, v35, v36);
        if (v311) {
          goto LABEL_480;
        }
        v62 = (const void *)v61;
        v63 = v310;
        v305 = v32;
        if (v310 >= 0x1FFuLL)
        {
          v65 = v310 + 2;
          v66 = (__int16 *)malloc(v310 + 2LL);
          if (!v66) {
            goto LABEL_487;
          }
          v64 = v66;
        }

        else
        {
          v64 = 0LL;
          v65 = 512;
          v66 = word_100164338;
        }

        v297 = v66;
        v303 = v64;
        if (v14) {
          v127 = (os_log_s *)mDNSLogCategory_Default;
        }
        else {
          v127 = (os_log_s *)mDNSLogCategory_mDNS;
        }
        if (gSensitiveLoggingEnabled != 1 || v127 == (os_log_s *)mDNSLogCategory_State)
        {
          if (!os_log_type_enabled(v127, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_478;
          }
          v128 = *(_DWORD *)(v8 + 184);
          v129 = bswap32(*(unsigned __int16 *)(a2 + 320)) >> 16;
          v130 = *((unsigned __int16 *)a3 + 2);
          v131 = v63 + 2;
          if ((int)v63 + 2 <= v65)
          {
            v132 = v297;
            *v297 = __rev16(v130);
            v215 = v62;
            v216 = v128;
            memcpy(v297 + 1, v215, v63);
            v128 = v216;
          }

          else
          {
            v132 = 0LL;
          }
        }

        else
        {
          if (v14) {
            v127 = (os_log_s *)mDNSLogCategory_Default_redacted;
          }
          else {
            v127 = (os_log_s *)mDNSLogCategory_mDNS;
          }
          if (!os_log_type_enabled(v127, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_478;
          }
          v128 = *(_DWORD *)(v8 + 184);
          v129 = bswap32(*(unsigned __int16 *)(a2 + 320)) >> 16;
          v130 = *((unsigned __int16 *)a3 + 2);
          v131 = v63 + 2;
          if ((int)v63 + 2 <= v65)
          {
            v132 = v297;
            *v297 = __rev16(v130);
            v212 = v62;
            v213 = v128;
            memcpy(v297 + 1, v212, v63);
            v128 = v213;
          }

          else
          {
            v132 = 0LL;
          }
        }

        LODWORD(__tp.tv_sec) = 67111427;
        HIDWORD(__tp.tv_sec) = v128;
        LOWORD(__tp.tv_nsec) = 1024;
        *(_DWORD *)((char *)&__tp.tv_nsec + 2) = v129;
        HIWORD(__tp.tv_nsec) = 1024;
        v314 = v9;
        v315 = 1024;
        v316 = 0;
        v317 = 1024;
        *(_DWORD *)v318 = v309;
        *(_WORD *)&v318[4] = 1024;
        *(_DWORD *)&v318[6] = v305;
        *(_WORD *)&v318[10] = 1024;
        *(_DWORD *)&v318[12] = v130;
        *(_WORD *)&v318[16] = 2160;
        *(void *)&v318[18] = 1752392040LL;
        *(_WORD *)&v318[26] = 1040;
        *(_DWORD *)&v318[28] = v131;
        *(_WORD *)&v318[32] = 2101;
        *(void *)&v318[34] = v132;
        v214 = "[R%u->Q%u] DNSServiceBrowse result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %d, name "
               "hash: %x, type: %{mdns:rrtype}d, rdata: %{sensitive, mask.hash, mdns:rdata}.*P";
LABEL_448:
        v225 = v127;
        v226 = 70;
LABEL_477:
        _os_log_impl((void *)&_mh_execute_header, v225, OS_LOG_TYPE_DEFAULT, v214, (uint8_t *)&__tp, v226);
LABEL_478:
        if (v303) {
          free(v303);
        }
        goto LABEL_480;
      }

      if (v14) {
        v74 = (os_log_s *)mDNSLogCategory_Default;
      }
      else {
        v74 = (os_log_s *)mDNSLogCategory_mDNS;
      }
      if (gSensitiveLoggingEnabled != 1 || v74 == (os_log_s *)mDNSLogCategory_State)
      {
        if (!os_log_type_enabled(v74, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_480;
        }
      }

      else
      {
        if (v14) {
          v74 = (os_log_s *)mDNSLogCategory_Default_redacted;
        }
        else {
          v74 = (os_log_s *)mDNSLogCategory_mDNS;
        }
        if (!os_log_type_enabled(v74, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_480;
        }
      }

      v113 = *(_DWORD *)(v8 + 184);
      v114 = *((unsigned __int16 *)a3 + 2);
      LODWORD(__tp.tv_sec) = 67110656;
      HIDWORD(__tp.tv_sec) = v113;
      LOWORD(__tp.tv_nsec) = 1024;
      *(_DWORD *)((char *)&__tp.tv_nsec + 2) = __rev16(v39);
      HIWORD(__tp.tv_nsec) = 1024;
      v314 = v9;
      v315 = 1024;
      v316 = 0;
      v317 = 1024;
      *(_DWORD *)v318 = v309;
      *(_WORD *)&v318[4] = 1024;
      *(_DWORD *)&v318[6] = v32;
      *(_WORD *)&v318[10] = 1024;
      *(_DWORD *)&v318[12] = v114;
      v115 = "[R%u->Q%u] DNSServiceBrowse result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %d, name ha"
             "sh: %x, type: %{mdns:rrtype}d, rdata: <none>";
      v116 = v74;
      v117 = 44;
    }

    else
    {
      if (v41)
      {
        v43 = 0LL;
        v56 = 512;
        v57 = (char *)&unk_100164138;
      }

      else
      {
        v57 = (char *)malloc(v40);
        v43 = v57;
        v56 = v40;
        if (!v57) {
          goto LABEL_487;
        }
      }

      if ((_DWORD)v40)
      {
        v311 = 0;
        v310 = 0;
        v87 = ResourceRecordGetRDataBytesPointer((uint64_t)a3, v57, v56, &v310, &v311, v34, v35, v36);
        if (!v311)
        {
          v88 = (const void *)v87;
          v307 = v32;
          v89 = v310;
          if (v310 >= 0x1FFuLL)
          {
            v91 = v310 + 2;
            v170 = (__int16 *)malloc(v310 + 2LL);
            if (!v170) {
              goto LABEL_487;
            }
            v92 = v170;
            v90 = v170;
          }

          else
          {
            v90 = 0LL;
            v91 = 512;
            v92 = word_100164338;
          }

          v303 = v90;
          if (v14) {
            v171 = (os_log_s *)mDNSLogCategory_Default;
          }
          else {
            v171 = (os_log_s *)mDNSLogCategory_mDNS;
          }
          if (gSensitiveLoggingEnabled != 1 || v171 == (os_log_s *)mDNSLogCategory_State)
          {
            if (!os_log_type_enabled(v171, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_478;
            }
            v172 = *(_DWORD *)(v8 + 184);
            v173 = *((unsigned __int16 *)a3 + 2);
            v174 = v89 + 2;
            if ((int)v89 + 2 <= v91)
            {
              *v92 = __rev16(v173);
              v249 = v88;
              v250 = v172;
              memcpy(v92 + 1, v249, v89);
              v172 = v250;
            }

            else
            {
              v92 = 0LL;
            }
          }

          else
          {
            if (v14) {
              v171 = (os_log_s *)mDNSLogCategory_Default_redacted;
            }
            else {
              v171 = (os_log_s *)mDNSLogCategory_mDNS;
            }
            if (!os_log_type_enabled(v171, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_478;
            }
            v172 = *(_DWORD *)(v8 + 184);
            v173 = *((unsigned __int16 *)a3 + 2);
            v174 = v89 + 2;
            if ((int)v89 + 2 <= v91)
            {
              *v92 = __rev16(v173);
              v247 = v88;
              v248 = v172;
              memcpy(v92 + 1, v247, v89);
              v172 = v248;
            }

            else
            {
              v92 = 0LL;
            }
          }

          LODWORD(__tp.tv_sec) = 67111171;
          HIDWORD(__tp.tv_sec) = v172;
          LOWORD(__tp.tv_nsec) = 1024;
          *(_DWORD *)((char *)&__tp.tv_nsec + 2) = v9;
          HIWORD(__tp.tv_nsec) = 1024;
          v314 = 0;
          v315 = 1024;
          v316 = v309;
          v317 = 1024;
          *(_DWORD *)v318 = v307;
          *(_WORD *)&v318[4] = 1024;
          *(_DWORD *)&v318[6] = v173;
          *(_WORD *)&v318[10] = 2160;
          *(void *)&v318[12] = 1752392040LL;
          *(_WORD *)&v318[20] = 1040;
          *(_DWORD *)&v318[22] = v174;
          *(_WORD *)&v318[26] = 2101;
          *(void *)&v318[28] = v92;
          v214 = "[R%u->mDNS] DNSServiceBrowse result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %d, na"
                 "me hash: %x, type: %{mdns:rrtype}d, rdata: %{sensitive, mask.hash, mdns:rdata}.*P";
          v225 = v171;
          v226 = 64;
          goto LABEL_477;
        }

        goto LABEL_480;
      }

      if (v14) {
        v98 = (os_log_s *)mDNSLogCategory_Default;
      }
      else {
        v98 = (os_log_s *)mDNSLogCategory_mDNS;
      }
      if (gSensitiveLoggingEnabled != 1 || v98 == (os_log_s *)mDNSLogCategory_State)
      {
        if (!os_log_type_enabled(v98, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_480;
        }
      }

      else
      {
        if (v14) {
          v98 = (os_log_s *)mDNSLogCategory_Default_redacted;
        }
        else {
          v98 = (os_log_s *)mDNSLogCategory_mDNS;
        }
        if (!os_log_type_enabled(v98, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_480;
        }
      }

      v143 = *(_DWORD *)(v8 + 184);
      v144 = *((unsigned __int16 *)a3 + 2);
      LODWORD(__tp.tv_sec) = 67110400;
      HIDWORD(__tp.tv_sec) = v143;
      LOWORD(__tp.tv_nsec) = 1024;
      *(_DWORD *)((char *)&__tp.tv_nsec + 2) = v9;
      HIWORD(__tp.tv_nsec) = 1024;
      v314 = 0;
      v315 = 1024;
      v316 = v309;
      v317 = 1024;
      *(_DWORD *)v318 = v32;
      *(_WORD *)&v318[4] = 1024;
      *(_DWORD *)&v318[6] = v144;
      v115 = "[R%u->mDNS] DNSServiceBrowse result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %d, name h"
             "ash: %x, type: %{mdns:rrtype}d, rdata: <none>";
      v116 = v98;
      v117 = 38;
    }

LABEL_430:
    _os_log_impl((void *)&_mh_execute_header, v116, OS_LOG_TYPE_DEFAULT, v115, (uint8_t *)&__tp, v117);
    goto LABEL_480;
  }

  v38 = dnssec_obj_resource_record_member_get_validation_result(v37);
  v39 = *(unsigned __int16 *)(a2 + 320);
  v40 = *((unsigned __int16 *)a3 + 6);
  v41 = v40 < 0x201;
  if (!v38) {
    goto LABEL_28;
  }
  v42 = v38;
  if (!*(_WORD *)(a2 + 320))
  {
    if (v40 >= 0x201)
    {
      v43 = (char *)malloc(*((unsigned __int16 *)a3 + 6));
      v72 = v43;
      if (!v43) {
        goto LABEL_487;
      }
    }

    else
    {
      if (!*((_WORD *)a3 + 6))
      {
        if (v14) {
          v164 = (os_log_s *)mDNSLogCategory_Default;
        }
        else {
          v164 = (os_log_s *)mDNSLogCategory_mDNS;
        }
        if (gSensitiveLoggingEnabled != 1 || v164 == (os_log_s *)mDNSLogCategory_State)
        {
          if (!os_log_type_enabled(v164, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_482;
          }
        }

        else
        {
          if (v14) {
            v164 = (os_log_s *)mDNSLogCategory_Default_redacted;
          }
          else {
            v164 = (os_log_s *)mDNSLogCategory_mDNS;
          }
          if (!os_log_type_enabled(v164, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_482;
          }
        }

        v205 = *(_DWORD *)(v8 + 184);
        v206 = *((unsigned __int16 *)a3 + 2);
        LODWORD(__tp.tv_sec) = 67110656;
        HIDWORD(__tp.tv_sec) = v205;
        LOWORD(__tp.tv_nsec) = 1024;
        *(_DWORD *)((char *)&__tp.tv_nsec + 2) = v9;
        HIWORD(__tp.tv_nsec) = 1024;
        v314 = 0;
        v315 = 1024;
        v316 = v30;
        v317 = 1024;
        *(_DWORD *)v318 = v32;
        *(_WORD *)&v318[4] = 1026;
        *(_DWORD *)&v318[6] = v42;
        *(_WORD *)&v318[10] = 1024;
        *(_DWORD *)&v318[12] = v206;
        v186 = "[R%u->mDNS] DNSServiceBrowse result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %d, name"
               " hash: %x, dnssec: %{public, mdns:dnssec_result}d, type: %{mdns:rrtype}d, rdata: <none>";
        v187 = v164;
        v188 = 44;
        goto LABEL_486;
      }

      v43 = 0LL;
      v72 = (char *)&unk_100164138;
      LODWORD(v40) = 512;
    }

    v311 = 0;
    v310 = 0;
    v103 = ResourceRecordGetRDataBytesPointer((uint64_t)a3, v72, v40, &v310, &v311, v34, v35, v36);
    if (v311) {
      goto LABEL_480;
    }
    v104 = (const void *)v103;
    v105 = v310;
    v308 = v32;
    if (v310 >= 0x1FFuLL)
    {
      v107 = v310 + 2;
      v108 = (__int16 *)malloc(v310 + 2LL);
      if (!v108) {
        goto LABEL_487;
      }
      v106 = v108;
    }

    else
    {
      v106 = 0LL;
      v107 = 512;
      v108 = word_100164338;
    }

    v300 = v108;
    v303 = v106;
    if (v14) {
      v127 = (os_log_s *)mDNSLogCategory_Default;
    }
    else {
      v127 = (os_log_s *)mDNSLogCategory_mDNS;
    }
    if (gSensitiveLoggingEnabled != 1 || v127 == (os_log_s *)mDNSLogCategory_State)
    {
      if (!os_log_type_enabled(v127, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_478;
      }
      v191 = *(_DWORD *)(v8 + 184);
      v192 = *((unsigned __int16 *)a3 + 2);
      v193 = v105 + 2;
      if ((int)v105 + 2 <= v107)
      {
        v194 = v300;
        *v300 = __rev16(v192);
        v264 = v104;
        v265 = v191;
        memcpy(v300 + 1, v264, v105);
        v191 = v265;
      }

      else
      {
        v194 = 0LL;
      }
    }

    else
    {
      if (v14) {
        v127 = (os_log_s *)mDNSLogCategory_Default_redacted;
      }
      else {
        v127 = (os_log_s *)mDNSLogCategory_mDNS;
      }
      if (!os_log_type_enabled(v127, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_478;
      }
      v191 = *(_DWORD *)(v8 + 184);
      v192 = *((unsigned __int16 *)a3 + 2);
      v193 = v105 + 2;
      if ((int)v105 + 2 <= v107)
      {
        v194 = v300;
        *v300 = __rev16(v192);
        v262 = v104;
        v263 = v191;
        memcpy(v300 + 1, v262, v105);
        v191 = v263;
      }

      else
      {
        v194 = 0LL;
      }
    }

    LODWORD(__tp.tv_sec) = 67111427;
    HIDWORD(__tp.tv_sec) = v191;
    LOWORD(__tp.tv_nsec) = 1024;
    *(_DWORD *)((char *)&__tp.tv_nsec + 2) = v9;
    HIWORD(__tp.tv_nsec) = 1024;
    v314 = 0;
    v315 = 1024;
    v316 = v309;
    v317 = 1024;
    *(_DWORD *)v318 = v308;
    *(_WORD *)&v318[4] = 1026;
    *(_DWORD *)&v318[6] = v42;
    *(_WORD *)&v318[10] = 1024;
    *(_DWORD *)&v318[12] = v192;
    *(_WORD *)&v318[16] = 2160;
    *(void *)&v318[18] = 1752392040LL;
    *(_WORD *)&v318[26] = 1040;
    *(_DWORD *)&v318[28] = v193;
    *(_WORD *)&v318[32] = 2101;
    *(void *)&v318[34] = v194;
    v214 = "[R%u->mDNS] DNSServiceBrowse result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %d, name has"
           "h: %x, dnssec: %{public, mdns:dnssec_result}d, type: %{mdns:rrtype}d, rdata: %{sensitive, mask.hash, mdns:rdata}.*P";
    goto LABEL_448;
  }

  if (v40 >= 0x201)
  {
    v43 = (char *)malloc(*((unsigned __int16 *)a3 + 6));
    v44 = v43;
    if (!v43) {
      goto LABEL_487;
    }
LABEL_83:
    v311 = 0;
    v310 = 0;
    v81 = ResourceRecordGetRDataBytesPointer((uint64_t)a3, v44, v40, &v310, &v311, v34, v35, v36);
    if (!v311)
    {
      v82 = (const void *)v81;
      v306 = v32;
      v83 = v310;
      if (v310 < 0x1FFuLL)
      {
        v294 = 512;
        v303 = 0LL;
        v290 = word_100164338;
LABEL_224:
        if (v14) {
          v148 = (os_log_s *)mDNSLogCategory_Default;
        }
        else {
          v148 = (os_log_s *)mDNSLogCategory_mDNS;
        }
        if (gSensitiveLoggingEnabled != 1 || v148 == (os_log_s *)mDNSLogCategory_State)
        {
          if (!os_log_type_enabled(v148, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_478;
          }
          v149 = *(_DWORD *)(v8 + 184);
          v150 = bswap32(*(unsigned __int16 *)(a2 + 320)) >> 16;
          v151 = *((unsigned __int16 *)a3 + 2);
          v152 = v83 + 2;
          if ((int)v83 + 2 <= v294)
          {
            v153 = v290;
            *v290 = __rev16(v151);
            v221 = v83;
            v222 = v82;
            v223 = v149;
            v224 = v150;
            memcpy(v290 + 1, v222, v221);
            v150 = v224;
            v149 = v223;
          }

          else
          {
            v153 = 0LL;
          }
        }

        else
        {
          if (v14) {
            v148 = (os_log_s *)mDNSLogCategory_Default_redacted;
          }
          else {
            v148 = (os_log_s *)mDNSLogCategory_mDNS;
          }
          if (!os_log_type_enabled(v148, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_478;
          }
          v149 = *(_DWORD *)(v8 + 184);
          v150 = bswap32(*(unsigned __int16 *)(a2 + 320)) >> 16;
          v151 = *((unsigned __int16 *)a3 + 2);
          v152 = v83 + 2;
          if ((int)v83 + 2 <= v294)
          {
            v153 = v290;
            *v290 = __rev16(v151);
            v217 = v82;
            v218 = v83;
            v219 = v149;
            v220 = v150;
            memcpy(v290 + 1, v217, v218);
            v150 = v220;
            v149 = v219;
          }

          else
          {
            v153 = 0LL;
          }
        }

        LODWORD(__tp.tv_sec) = 67111683;
        HIDWORD(__tp.tv_sec) = v149;
        LOWORD(__tp.tv_nsec) = 1024;
        *(_DWORD *)((char *)&__tp.tv_nsec + 2) = v150;
        HIWORD(__tp.tv_nsec) = 1024;
        v314 = v9;
        v315 = 1024;
        v316 = 0;
        v317 = 1024;
        *(_DWORD *)v318 = v309;
        *(_WORD *)&v318[4] = 1024;
        *(_DWORD *)&v318[6] = v306;
        *(_WORD *)&v318[10] = 1026;
        *(_DWORD *)&v318[12] = v42;
        *(_WORD *)&v318[16] = 1024;
        *(_DWORD *)&v318[18] = v151;
        *(_WORD *)&v318[22] = 2160;
        *(void *)&v318[24] = 1752392040LL;
        *(_WORD *)&v318[32] = 1040;
        *(_DWORD *)&v318[34] = v152;
        *(_WORD *)&v318[38] = 2101;
        *(void *)&v318[40] = v153;
        v214 = "[R%u->Q%u] DNSServiceBrowse result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %d, name "
               "hash: %x, dnssec: %{public, mdns:dnssec_result}d, type: %{mdns:rrtype}d, rdata: %{sensitive, mask.hash, mdns:rdata}.*P";
        v225 = v148;
        v226 = 76;
        goto LABEL_477;
      }

      v147 = (__int16 *)malloc(v310 + 2LL);
      if (v147)
      {
        v290 = v147;
        v294 = v83 + 2;
        v303 = v147;
        goto LABEL_224;
      }

LABEL_487:
      __break(1u);
    }

LABEL_480:
    if (v43) {
      free(v43);
    }
    goto LABEL_482;
  }

  if (*((_WORD *)a3 + 6))
  {
    v43 = 0LL;
    v44 = (char *)&unk_100164138;
    LODWORD(v40) = 512;
    goto LABEL_83;
  }

  if (v14) {
    v120 = (os_log_s *)mDNSLogCategory_Default;
  }
  else {
    v120 = (os_log_s *)mDNSLogCategory_mDNS;
  }
  if (gSensitiveLoggingEnabled == 1 && v120 != (os_log_s *)mDNSLogCategory_State)
  {
    if (v14) {
      v120 = (os_log_s *)mDNSLogCategory_Default_redacted;
    }
    else {
      v120 = (os_log_s *)mDNSLogCategory_mDNS;
    }
    if (!os_log_type_enabled(v120, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_482;
    }
    goto LABEL_335;
  }

  if (os_log_type_enabled(v120, OS_LOG_TYPE_DEFAULT))
  {
LABEL_335:
    v184 = *(_DWORD *)(v8 + 184);
    v185 = *((unsigned __int16 *)a3 + 2);
    LODWORD(__tp.tv_sec) = 67110912;
    HIDWORD(__tp.tv_sec) = v184;
    LOWORD(__tp.tv_nsec) = 1024;
    *(_DWORD *)((char *)&__tp.tv_nsec + 2) = __rev16(v39);
    HIWORD(__tp.tv_nsec) = 1024;
    v314 = v9;
    v315 = 1024;
    v316 = 0;
    v317 = 1024;
    *(_DWORD *)v318 = v30;
    *(_WORD *)&v318[4] = 1024;
    *(_DWORD *)&v318[6] = v32;
    *(_WORD *)&v318[10] = 1026;
    *(_DWORD *)&v318[12] = v42;
    *(_WORD *)&v318[16] = 1024;
    *(_DWORD *)&v318[18] = v185;
    v186 = "[R%u->Q%u] DNSServiceBrowse result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %d, name hash"
           ": %x, dnssec: %{public, mdns:dnssec_result}d, type: %{mdns:rrtype}d, rdata: <none>";
    v187 = v120;
    v188 = 50;
LABEL_486:
    _os_log_impl((void *)&_mh_execute_header, v187, OS_LOG_TYPE_DEFAULT, v186, (uint8_t *)&__tp, v188);
  }

LABEL_482:
  append_reply(v8, v312);
}

void connection_termination(uint64_t a1)
{
  v2 = (os_log_s *)mDNSLogCategory_Default;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
  {
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_10;
    }
    goto LABEL_9;
  }

  v2 = (os_log_s *)mDNSLogCategory_Default_redacted;
  if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
  {
LABEL_9:
    int v10 = *(_DWORD *)(a1 + 184);
    int v11 = *(_DWORD *)(a1 + 172);
    LODWORD(__n_6.tv_sec) = 67109634;
    HIDWORD(__n_6.tv_sec) = v10;
    LOWORD(__n_6.tv_nsec) = 1024;
    *(_DWORD *)((char *)&__n_6.tv_nsec + 2) = v11;
    HIWORD(__n_6.tv_nsec) = 2082;
    *(void *)v115 = a1 + 240;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "[R%d] DNSServiceCreateConnection STOP PID[%d](%{public}s)",  (uint8_t *)&__n_6,  0x18u);
  }

LABEL_10:
  uint64_t v12 = all_requests;
  if (all_requests)
  {
    v13 = &all_requests;
    do
    {
      if (*(void *)(v12 + 24) == a1)
      {
        __n_6.int tv_sec = 0LL;
        v14 = (void *)*v13;
        __n_6.int tv_sec = (__darwin_time_t)v14;
        if ((void *)v14[3] == v14) {
          LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "connection_termination ERROR (*req)->primary == *req for %p %d",  v5,  v6,  v7,  v8,  v9,  (int)v14);
        }
        if (v14[11]) {
          LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "connection_termination ERROR How can subordinate req %p %d have replies queued?",  v5,  v6,  v7,  v8,  v9,  (int)v14);
        }
        abort_request((uint64_t)v14);
        uint64_t *v13 = v14[2];
        request_state_forget(&__n_6);
      }

      else
      {
        v13 = (uint64_t *)(v12 + 16);
      }

      uint64_t v12 = *v13;
    }

    while (*v13);
  }

  v15 = *(char **)(a1 + 160);
  v16 = &unk_100164000;
  if (v15)
  {
    v17 = (const char *)(a1 + 240);
    do
    {
      uint64_t v18 = *((void *)v15 + 3);
      int v19 = mDNS_DomainNameFNV1aHash(*(unsigned __int8 **)(v18 + 40));
      v20 = (int *)(v15 + 48);
      if (_shouldLogFullRequestInfo((int *)v15 + 12, (_DWORD *)v15 + 13))
      {
        unint64_t v24 = *(unsigned __int16 *)(v18 + 20);
        if (v24 >= 0x201)
        {
          v25 = (char *)malloc(*(unsigned __int16 *)(v18 + 20));
          v26 = v25;
          if (!v25) {
            goto LABEL_142;
          }
LABEL_34:
          int __n_2 = 0;
          unsigned __int16 __n = 0;
          uint64_t RDataBytesPointer = ResourceRecordGetRDataBytesPointer(v18 + 8, v26, v24, &__n, &__n_2, v21, v22, v23);
          if (!__n_2)
          {
            __src = (void *)RDataBytesPointer;
            if (__n >= 0x1FFuLL)
            {
              unsigned int v31 = __n + 2;
              v43 = (__int16 *)malloc(__n + 2LL);
              if (!v43) {
LABEL_142:
              }
                __break(1u);
              v32 = v43;
              v30 = v43;
            }

            else
            {
              v30 = 0LL;
              unsigned int v31 = 512;
              v32 = word_100164338;
            }

            v109 = v30;
            uint64_t v44 = mDNSLogCategory_mDNS;
            if (v16[1384] != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
            {
              if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
              {
                uint64_t v50 = *(void *)(v18 + 40);
                if (v50)
                {
                  v51 = *(_BYTE **)(v18 + 40);
                  if (v50 == -256) {
                    goto LABEL_76;
                  }
LABEL_73:
                  unsigned __int16 v52 = 257;
                  if ((unint64_t)v51 < v50 + 256 && v51)
                  {
                    while (1)
                    {
                      uint64_t v53 = *v51;
                      if (v53 > 0x3F)
                      {
LABEL_95:
                        unsigned __int16 v52 = 257;
                        goto LABEL_104;
                      }

                      if (!*v51) {
                        break;
                      }
                      v51 += v53 + 1;
                      if (v50 != -256) {
                        goto LABEL_73;
                      }
LABEL_76:
                      if (!v51) {
                        goto LABEL_95;
                      }
                    }

                    unsigned __int16 v52 = (_WORD)v51 - v50 + 1;
                  }

  *(_BYTE *)(a2 + 8) = 8;
  *(_BYTE *)(a2 + 192) = 0;
  *(_DWORD *)(a2 + 126) = 0;
  *(_WORD *)(a2 + 130) = 0;
  if (*(_BYTE *)(a2 + 193))
  {
    AnswerAllLocalQuestionsWithLocalAuthRecord((void *)a1, a2, 0LL, v7, v8, v9, v10, v11);
    *(_BYTE *)(a2 + 193) = 0;
  }

  return mDNS_Deregister_internal(a1, a2, 0LL);
}

    uint64_t v9 = v5[1];
    int v10 = *(unsigned int *)(v9 + 48);
    int v11 = __OFSUB__(v7, (_DWORD)v10);
    uint64_t v12 = v7 - v10;
    if (v12 < 0 == v11)
    {
      if (!(_DWORD)v10) {
        break;
      }
      v13 = a2;
      if (v12 >= 1)
      {
        v13 = a2;
        do
        {
          if (!*v13) {
            break;
          }
          v13 += *v13 + 1;
          --v12;
        }

        while (v12);
      }
    }
  }

  if (a3) {
    *a3 = *((_DWORD *)v5 + 4);
  }
  return v10;
}

  int v19 = 0LL;
LABEL_11:
  *(_WORD *)uint64_t v8 = 0;
  *((_WORD *)v8 + 51) = 0;
  v20 = (void *)*((void *)v8 + 7);
  if (v20)
  {
    ref_count_obj_release(v20);
    *((void *)v8 + 7) = 0LL;
  }

  return v19;
}

  if (a4) {
    *a4 = v6;
  }
  return result;
}

  if (sa_family == 2) {
    v13 = 2;
  }
  else {
    v13 = 30;
  }
  v14 = socket(v13, 2, 17);
  if ((v14 & 0x80000000) != 0)
  {
    if (*__error())
    {
      v16 = *__error();
      if (!(_DWORD)v16) {
        goto LABEL_16;
      }
    }

    else
    {
      v16 = 4294960596LL;
    }

    if (_mdns_resolver_log_s_once != -1) {
      dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_48);
    }
    v33 = (os_log_s *)_mdns_resolver_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_ERROR))
    {
      v53[0].val[0] = 134217984;
      *(void *)&v53[0].val[1] = (int)v16;
      _os_log_error_impl( (void *)&_mh_execute_header,  v33,  OS_LOG_TYPE_ERROR,  "Failed to create UDP socket: %{darwin.errno}ld",  (uint8_t *)v53,  0xCu);
    }

    return v16;
  }

  KQueueUnlock((uint64_t)"DNSProxyGetStateHandler", v8, v9, v10, v11, v12, v13, v14);
  return v17;
}

LABEL_104:
                  uint64_t v105 = *(void *)(v18 + 40);
                  int v103 = v52;
                }

                else
                {
                  uint64_t v105 = 0LL;
                  int v103 = 0;
                }

                int v95 = *(_DWORD *)(a1 + 184);
                int v97 = *((_DWORD *)v15 + 14);
                int v99 = *(_DWORD *)(a1 + 236);
                int v101 = *(_DWORD *)(a1 + 172);
                __n_6.int tv_sec = 0LL;
                __n_6.tv_nsec = 0LL;
                clock_gettime(_CLOCK_MONOTONIC_RAW, &__n_6);
                v67 = 0LL;
                int tv_sec = __n_6.tv_sec;
                int v69 = *v20;
                unsigned int v70 = *(unsigned __int16 *)(v18 + 12);
                size_t v71 = __n;
                unsigned int v72 = __n + 2;
                if (v72 <= v31)
                {
                  __int16 *v32 = __rev16(v70);
                  unsigned int v73 = v70;
                  memcpy(v32 + 1, __src, v71);
                  unsigned int v70 = v73;
                  v67 = v32;
                }

                LODWORD(__n_6.tv_sec) = 67112451;
                HIDWORD(__n_6.tv_sec) = v95;
                LOWORD(__n_6.tv_nsec) = 1024;
                *(_DWORD *)((char *)&__n_6.tv_nsec + 2) = v97;
                HIWORD(__n_6.tv_nsec) = 2160;
                *(void *)v115 = 1752392040LL;
                *(_WORD *)&v115[8] = 1040;
                int v116 = v103;
                __int16 v117 = 2101;
                uint64_t v118 = v105;
                __int16 v119 = 1024;
                int v120 = v19;
                __int16 v121 = 1024;
                int v122 = v99;
                __int16 v123 = 2082;
                uint64_t v124 = a1 + 240;
                __int16 v125 = 1024;
                int v126 = v101;
                __int16 v127 = 1024;
                int v128 = tv_sec - v69;
                __int16 v129 = 1024;
                unsigned int v130 = v70;
                __int16 v131 = 2160;
                uint64_t v132 = 1752392040LL;
                __int16 v133 = 1040;
                unsigned int v134 = v72;
                __int16 v135 = 2101;
                v136 = v67;
                v66 = (os_log_s *)v44;
LABEL_108:
                _os_log_impl( (void *)&_mh_execute_header,  v66,  OS_LOG_TYPE_DEFAULT,  "[R%u->Rec%u] DNSServiceRegisterRecord STOP -- name: %{sensitive, mask.hash, mdnsresponder:domain_name} .*P(%x), index: %d, client: %{public}s(pid: %d), duration: %{mdns:time_duration}utype: %{mdns:rrtype}d , rdata: %{sensitive, mask.hash, mdns:rdata}.*P",  (uint8_t *)&__n_6,  0x6Au);
                v16 = (_BYTE *)&unk_100164000;
              }
            }

            else
            {
              uint64_t v45 = mDNSLogCategory_mDNS_redacted;
              if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
              {
                uint64_t v46 = *(void *)(v18 + 40);
                v100 = (os_log_s *)v45;
                if (v46)
                {
                  v47 = *(_BYTE **)(v18 + 40);
                  if (v46 == -256) {
                    goto LABEL_65;
                  }
LABEL_62:
                  unsigned __int16 v48 = 257;
                  if ((unint64_t)v47 < v46 + 256 && v47)
                  {
                    while (1)
                    {
                      uint64_t v49 = *v47;
                      if (v49 > 0x3F)
                      {
LABEL_94:
                        unsigned __int16 v48 = 257;
                        goto LABEL_99;
                      }

                      if (!*v47) {
                        break;
                      }
                      v47 += v49 + 1;
                      if (v46 != -256) {
                        goto LABEL_62;
                      }
LABEL_65:
                      if (!v47) {
                        goto LABEL_94;
                      }
                    }

                    unsigned __int16 v48 = (_WORD)v47 - v46 + 1;
                  }

  char *v25 = v9;
  if (AuthGroupForName(a1, *(_DWORD *)(a2 + 24), *(_BYTE **)(a2 + 40)) != v9)
  {
    uint64_t v45 = (os_log_s *)mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v46 = *(void *)(a2 + 40);
        if (v46)
        {
          uint64_t v49 = *(_BYTE **)(a2 + 40);
          if (v46 == -256)
          {
LABEL_120:
            while (v49)
            {
              uint64_t v50 = *v49;
              if (!*v49)
              {
                v51 = (unsigned __int16)((_WORD)v49 - v46 + 1);
                goto LABEL_131;
              }

              v49 += v50 + 1;
              if (v46 != -256) {
                goto LABEL_119;
              }
            }
          }

          else
          {
LABEL_119:
          }

          v51 = 257;
        }

        else
        {
          v51 = 0;
        }

        goto LABEL_131;
      }
    }

    else
    {
      uint64_t v45 = (os_log_s *)mDNSLogCategory_Default_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v46 = *(void *)(a2 + 40);
        if (v46)
        {
          v47 = *(_BYTE **)(a2 + 40);
          if (v46 == -256)
          {
LABEL_111:
            while (v47)
            {
              unsigned __int16 v48 = *v47;
              if (!*v47)
              {
                v51 = (unsigned __int16)((_WORD)v47 - v46 + 1);
                goto LABEL_131;
              }

              v47 += v48 + 1;
              if (v46 != -256) {
                goto LABEL_110;
              }
            }
          }

          else
          {
LABEL_110:
          }

          v51 = 257;
        }

        else
        {
          v51 = 0;
        }

LABEL_135:
            int v111 = v41;
          }

          else
          {
            int v111 = 0;
          }

          int v81 = *(_DWORD *)(a1 + 184);
          int v82 = *((_DWORD *)v15 + 14);
          int v83 = *(_DWORD *)(a1 + 236);
          int __srcb = *(_DWORD *)(a1 + 172);
          __n_6.int tv_sec = 0LL;
          __n_6.tv_nsec = 0LL;
          clock_gettime(_CLOCK_MONOTONIC_RAW, &__n_6);
          int v84 = LODWORD(__n_6.tv_sec) - *v20;
          unsigned int v85 = *(unsigned __int16 *)(v18 + 12);
          LODWORD(__n_6.tv_sec) = 67111683;
          HIDWORD(__n_6.tv_sec) = v81;
          LOWORD(__n_6.tv_nsec) = 1024;
          *(_DWORD *)((char *)&__n_6.tv_nsec + 2) = v82;
          HIWORD(__n_6.tv_nsec) = 2160;
          *(void *)v115 = 1752392040LL;
          *(_WORD *)&v115[8] = 1040;
          int v116 = v111;
          __int16 v117 = 2101;
          uint64_t v118 = v39;
          __int16 v119 = 1024;
          int v120 = v19;
          __int16 v121 = 1024;
          int v122 = v83;
          __int16 v123 = 2082;
          v17 = (const char *)(a1 + 240);
          uint64_t v124 = a1 + 240;
          __int16 v125 = 1024;
          int v126 = __srcb;
          __int16 v127 = 1024;
          int v128 = v84;
          __int16 v129 = 1024;
          unsigned int v130 = v85;
          v86 = (os_log_s *)v37;
LABEL_140:
          _os_log_impl( (void *)&_mh_execute_header,  v86,  OS_LOG_TYPE_DEFAULT,  "[R%u->Rec%u] DNSServiceRegisterRecord STOP -- name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P(%x), index: %d, client: %{public}s(pid: %d), duration: %{mdns:time_duration}utype: %{mdns:rrtype}d, rdata: <none>",  (uint8_t *)&__n_6,  0x50u);
          v16 = (_BYTE *)&unk_100164000;
        }
      }

      else
      {
        v27 = (os_log_s *)mDNSLogCategory_mDNS;
        if (v16[1384] == 1 && mDNSLogCategory_mDNS != mDNSLogCategory_State)
        {
          v27 = (os_log_s *)mDNSLogCategory_mDNS_redacted;
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_113;
          }
LABEL_38:
          unsigned int v34 = *(_DWORD *)(a1 + 184);
          int v35 = *((_DWORD *)v15 + 14);
          __n_6.int tv_sec = 0LL;
          __n_6.tv_nsec = 0LL;
          clock_gettime(_CLOCK_MONOTONIC_RAW, &__n_6);
          int v36 = LODWORD(__n_6.tv_sec) - *((_DWORD *)v15 + 12);
          __n_6.int tv_sec = __PAIR64__(v34, 67109888);
          LOWORD(__n_6.tv_nsec) = 1024;
          *(_DWORD *)((char *)&__n_6.tv_nsec + 2) = v35;
          HIWORD(__n_6.tv_nsec) = 1024;
          *(_DWORD *)v115 = v19;
          *(_WORD *)&v115[4] = 1024;
          *(_DWORD *)&v115[6] = v36;
          _os_log_impl( (void *)&_mh_execute_header,  v27,  OS_LOG_TYPE_DEFAULT,  "[R%u->Rec%u] DNSServiceRegisterRecord STOP -- name hash: %x, duration: %{mdns:time_duration}u",  (uint8_t *)&__n_6,  0x1Au);
          goto LABEL_113;
        }

        if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_38;
        }
      }

LABEL_113:
      *(void *)(a1 + 160) = *(void *)(*(void *)(a1 + 160) + 8LL);
      uint64_t v74 = *((void *)v15 + 3);
      *(void *)(v74 + 112) = 0LL;
      if (v15[60])
      {
        v15[60] = 0;
        internal_stop_advertising_service(v74 + 8, *(_DWORD *)(a1 + 232), *(_DWORD *)(a1 + 172));
        uint64_t v74 = *((void *)v15 + 3);
      }

      if (mDNS_McastLoggingEnabled)
      {
        LogMcastService(v74, a1, 0LL);
        uint64_t v74 = *((void *)v15 + 3);
      }

      uint64_t v75 = *(void *)v15;
      if (*(void *)v15)
      {
        uint64_t v76 = *(unsigned int *)(a1 + 236);
        if ((_DWORD)v76)
        {
          if (AWDLInterfaceID && AWDLInterfaceID == v76)
          {
            int v77 = 1;
          }

          else
          {
            if (WiFiAwareInterfaceID) {
              BOOL v78 = WiFiAwareInterfaceID == v76;
            }
            else {
              BOOL v78 = 0;
            }
            int v77 = v78;
          }
        }

        else
        {
          int v77 = (*(_DWORD *)(a1 + 232) >> 20) & 1;
        }

        v79 = *(unsigned __int8 **)(v74 + 40);
        bzero(&__n_6, 0x3F1uLL);
        service_type_from_domain_name = _mdns_get_service_type_from_domain_name(v79, (unsigned __int8 *)&__n_6);
        _mdns_powerlog_bonjour_event(0xCu, v77, v17, (const char *)service_type_from_domain_name, v75);
        uint64_t v74 = *((void *)v15 + 3);
      }

      mDNS_Deregister((unsigned int *)mDNSStorage, v74);
      free(v15);
      v15 = *(char **)(a1 + 160);
    }

    while (v15);
  }

  *(_DWORD *)buf = 141558787;
  int v62 = 1752392040LL;
  unsigned int v63 = 1040;
  size_t v64 = v27;
  unsigned int v65 = 2101;
  v66 = v60;
  v67 = 1024;
  v68 = a3;
  _os_log_impl( (void *)&_mh_execute_header,  v19,  OS_LOG_TYPE_DEBUG,  "D2DBrowseListRelease item not found in the list - name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P, type: %{mdns:rrtype}d",  buf,  0x22u);
}

          *(_DWORD *)buf = 67109891;
          *(_DWORD *)unsigned int v73 = v36;
          *(_WORD *)&v73[4] = 2160;
          *(void *)&v73[6] = 1752392040LL;
          *(_WORD *)&v73[14] = 1040;
          *(_DWORD *)&v73[16] = v37;
          LOWORD(v74) = 2101;
          *(void *)((char *)&v74 + 2) = v38;
          _os_log_impl( (void *)&_mh_execute_header,  v35,  OS_LOG_TYPE_ERROR,  "[Q%u] The discovered possible denial of existence for DS record points back to the current question itself, insecure delegation validation fails due to possible missing RRSIG of the original response - qname: %{sensi tive, mask.hash, mdnsresponder:domain_name}.*P",  buf,  0x22u);
        }
      }

      v60 = 0LL;
      unsigned int v63 = 0LL;
      v47 = -90020;
LABEL_115:
      unsigned int v70 = v47;
      goto LABEL_116;
    }

    uint64_t v45 = *(_WORD *)(*(void *)(v31 + 96) + 324LL);
    if (v33) {
      ++*(_DWORD *)v33;
    }
    _dnssec_obj_validation_manager_stop_negative_ds_query(v31);
    *(_DWORD *)(v31 + 112) = 2;
    if (*(void *)(v31 + 80))
    {
      v47 = -6709;
    }

    else
    {
      size_t v71 = 0;
      started = _dnssec_obj_validation_manager_start_sub_query( v33,  v45,  43,  2101248,  v8,  (uint64_t)_dnssec_query_key_record_result_reply,  &v71);
      *(void *)(v31 + 80) = started;
      v47 = v71;
      if (!v71)
      {
        unsigned __int16 v48 = started;
        uint64_t v49 = (os_log_s *)mDNSLogCategory_DNSSEC;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_DNSSEC == mDNSLogCategory_State)
        {
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC, OS_LOG_TYPE_INFO))
          {
            uint64_t v50 = *(unsigned __int16 *)(v31 + 24);
            v51 = bswap32(*((unsigned __int16 *)v48 + 160)) >> 16;
            if (v33)
            {
              unsigned __int16 v52 = *(_DWORD *)(v33 + 24);
              uint64_t v53 = *(void *)(v33 + 16);
            }

            else
            {
              unsigned __int16 v52 = 0;
              uint64_t v53 = 0LL;
            }

            goto LABEL_102;
          }
        }

        else
        {
          uint64_t v49 = (os_log_s *)mDNSLogCategory_DNSSEC_redacted;
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC_redacted, OS_LOG_TYPE_INFO))
          {
            uint64_t v50 = *(unsigned __int16 *)(v31 + 24);
            v51 = bswap32(*((unsigned __int16 *)v48 + 160)) >> 16;
            if (v33)
            {
              unsigned __int16 v52 = *(_DWORD *)(v33 + 24);
              uint64_t v53 = *(void *)(v33 + 16);
            }

            else
            {
              unsigned __int16 v52 = 0;
              uint64_t v53 = 0LL;
            }

              if (v9) {
                ref_count_obj_release(v9);
              }
            }
          }
        }
      }
    }
  }

void mDNS_AddSearchDomain(_BYTE *a1, uint64_t a2)
{
  v4 = &SearchList;
  while (1)
  {
    uint64_t v5 = *v4;
    if (!*v4) {
      break;
    }
    if (*(void *)(v5 + 272) == a2)
    {
      if (SameDomainNameBytes((_BYTE *)(v5 + 8), a1))
      {
        uint64_t v6 = (os_log_s *)mDNSLogCategory_State;
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v7 = a1;
          if (a1 == (_BYTE *)-256LL)
          {
LABEL_10:
            while (v7)
            {
              uint64_t v8 = *v7;
              if (!*v7)
              {
                int v9 = (unsigned __int16)((_WORD)v7 - (_WORD)a1 + 1);
                goto LABEL_17;
              }

              v7 += v8 + 1;
              if (a1 != (_BYTE *)-256LL) {
                goto LABEL_9;
              }
            }
          }

          else
          {
LABEL_9:
            if (v7 < a1 + 256) {
              goto LABEL_10;
            }
          }

          int v9 = 257;
LABEL_17:
          int v21 = 141558531;
          uint64_t v22 = 1752392040LL;
          __int16 v23 = 1040;
          int v24 = v9;
          __int16 v25 = 2101;
          v26 = a1;
          _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "mDNS_AddSearchDomain: domain already in list -- search domain: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P",  (uint8_t *)&v21,  0x1Cu);
        }

        uint64_t v5 = *v4;
        int v10 = *(_DWORD *)(*v4 + 264);
        if ((v10 & 1) != 0) {
          *(_DWORD *)(v5 + 264) = v10 & 0xFFFFFFFE;
        }
        uint64_t *v4 = *(void *)v5;
        *(void *)uint64_t v5 = 0LL;
        goto LABEL_21;
      }

      v4 = (uint64_t *)*v4;
    }

    else
    {
      v4 = (uint64_t *)*v4;
    }
  }

  do
  {
LABEL_21:
    int v11 = v4;
    v4 = (uint64_t *)*v4;
  }

  while (v4);
  if (v5)
  {
    *int v11 = v5;
  }

  else
  {
    uint64_t v12 = (char *)calloc(1uLL, 0xDF8uLL);
    if (!v12) {
      __break(1u);
    }
    *int v11 = (uint64_t)v12;
    v13 = a1 + 256;
    v14 = a1;
    if (a1 == (_BYTE *)-256LL)
    {
LABEL_27:
      while (v14)
      {
        uint64_t v15 = *v14;
        if (!*v14)
        {
          unsigned __int16 v16 = (_WORD)v14 - (_WORD)a1 + 1;
          if (v16 > 0x100u) {
            break;
          }
          memcpy(v12 + 8, a1, v16);
          goto LABEL_35;
        }

        v14 += v15 + 1;
        if (a1 != (_BYTE *)-256LL) {
          goto LABEL_26;
        }
      }
    }

    else
    {
LABEL_26:
      if (v14 < v13) {
        goto LABEL_27;
      }
    }

    v12[8] = 0;
LABEL_35:
    *(void *)*int v11 = 0LL;
    *(void *)(*v11 + 272) = a2;
    v17 = (os_log_s *)mDNSLogCategory_State;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v18 = a1;
      if (a1 == (_BYTE *)-256LL)
      {
LABEL_38:
        while (v18)
        {
          uint64_t v19 = *v18;
          if (!*v18)
          {
            int v20 = (unsigned __int16)((_WORD)v18 - (_WORD)a1 + 1);
            goto LABEL_45;
          }

          v18 += v19 + 1;
          if (a1 != (_BYTE *)-256LL) {
            goto LABEL_37;
          }
        }
      }

      else
      {
LABEL_37:
        if (v18 < v13) {
          goto LABEL_38;
        }
      }

      int v20 = 257;
LABEL_45:
      int v21 = 141558787;
      uint64_t v22 = 1752392040LL;
      __int16 v23 = 1040;
      int v24 = v20;
      __int16 v25 = 2101;
      v26 = a1;
      __int16 v27 = 2048;
      uint64_t v28 = a2;
      _os_log_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_DEFAULT,  "mDNS_AddSearchDomain: new search domain added -- search domain: %{sensitive, mask.hash, mdnsresponder:domain_nam e}.*P, InterfaceID %p",  (uint8_t *)&v21,  0x26u);
    }
  }

void AnswerLocalQuestionWithLocalAuthRecord(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a1 + 216);
  if (!v5)
  {
    uint64_t v16 = mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
        return;
      }
    }

    else
    {
      uint64_t v16 = mDNSLogCategory_Default_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
        return;
      }
    }

    uint64_t v22 = (char *)(a1 + 46976);
    GetRRDisplayString_rdb((unsigned __int8 *)(a2 + 8), (unsigned __int16 *)(*(void *)(a2 + 48) + 4LL), v22);
    int v28 = 136446210;
    v29 = v22;
    __int16 v23 = "AnswerLocalQuestionWithLocalAuthRecord: ERROR!! CurrentQuestion NULL while answering with %{public}s";
    int v24 = (os_log_s *)v16;
    uint32_t v25 = 12;
LABEL_44:
    _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, v23, (uint8_t *)&v28, v25);
    return;
  }

  uint64_t v7 = (_BYTE *)(a2 + 8);
  BOOL v8 = FollowCNAME(*(void *)(a1 + 216), (unsigned __int8 *)(a2 + 8), a3);
  int v9 = *(unsigned __int8 *)(a2 + 8);
  if ((v9 & 0x3C) == 0)
  {
    uint64_t v18 = mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
        return;
      }
      if ((_DWORD)a3) {
        int v20 = "Add";
      }
      else {
        int v20 = "Rmv";
      }
    }

    else
    {
      uint64_t v18 = mDNSLogCategory_Default_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
        return;
      }
      if ((_DWORD)a3) {
        int v20 = "Add";
      }
      else {
        int v20 = "Rmv";
      }
    }

    __int16 v27 = (_BYTE *)(a1 + 46976);
    GetRRDisplayString_rdb((unsigned __int8 *)(a2 + 8), (unsigned __int16 *)(*(void *)(a2 + 48) + 4LL), v27);
    int v28 = 136446979;
    v29 = v20;
    __int16 v30 = 1024;
    int v31 = v9;
    __int16 v32 = 2160;
    uint64_t v33 = 1752392040LL;
    __int16 v34 = 2085;
    int v35 = v27;
    __int16 v23 = "AnswerLocalQuestionWithLocalAuthRecord: *NOT* delivering %{public}s event for local record type %X %{sensitive, mask.hash}s";
    int v24 = (os_log_s *)v18;
    uint32_t v25 = 38;
    goto LABEL_44;
  }

  BOOL v10 = v8;
  if ((_DWORD)a3) {
    *(_BYTE *)(a2 + 193) = 1;
  }
  unsigned int v11 = *(_DWORD *)(a1 + 48);
  unsigned int v12 = *(_DWORD *)(a1 + 52) + 1;
  *(_DWORD *)(a1 + 52) = v12;
  mDNS_VerifyLockState("Drop Lock", 0, v11, v12, (uint64_t)"AnswerLocalQuestionWithLocalAuthRecord", 906);
  v13 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v5 + 152);
  if (!v13) {
    goto LABEL_38;
  }
  if ((_DWORD)a3) {
    int v14 = 1;
  }
  else {
    int v14 = -1;
  }
  *(_DWORD *)(v5 + 228) += v14;
  if (*(_DWORD *)(a2 + 172) != 4
    || (*v7 & 0x32) == 0
    || (unsigned int v15 = *(unsigned __int16 *)(a2 + 12), v15 > 0x1C)
    || ((1 << v15) & 0x10001022) == 0)
  {
    v13(a1, v5, a2 + 8, a3);
LABEL_38:
    mDNS_VerifyLockState( "Reclaim Lock",  0,  *(_DWORD *)(a1 + 48),  *(_DWORD *)(a1 + 52),  (uint64_t)"AnswerLocalQuestionWithLocalAuthRecord",  931);
    --*(_DWORD *)(a1 + 52);
    return;
  }

  if (!v10 || *(_BYTE *)(v5 + 615))
  {
    *(_DWORD *)(v5 + 212) = 0;
    *(_BYTE *)(v5 + 335) += v14;
    v13(a1, v5, a2 + 8, a3);
  }

  mDNS_VerifyLockState( "Reclaim Lock",  0,  *(_DWORD *)(a1 + 48),  *(_DWORD *)(a1 + 52),  (uint64_t)"AnswerLocalQuestionWithLocalAuthRecord",  919);
  --*(_DWORD *)(a1 + 52);
  if (v10 && *(void *)(a1 + 216) == v5) {
    AnswerQuestionByFollowingCNAME(a1, v5, a2 + 8);
  }
}

void enum_result_callback(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  if (*(_WORD *)(a3 + 4) == 12)
  {
    uint64_t v7 = *(void *)(a2 + 176);
    bzero(__s, 0x3F1uLL);
    uint64_t v8 = *(void *)(v7 + 104) + 664LL;
    if (a4 || v8 != a2)
    {
      ConvertDomainNameToCString_withescape((unsigned __int8 *)(*(void *)(a3 + 40) + 4LL), (unsigned __int8 *)__s);
      size_t v9 = strlen(__s);
      reply = create_reply((char *)0x40, v9 + 13, v7, v10, v11, v12, v13, v14);
      uint64_t v16 = reply;
      if (v8 == a2) {
        int v17 = 100663296;
      }
      else {
        int v17 = 0x2000000;
      }
      *((void *)reply + 6) = 0LL;
      if (!a4) {
        int v17 = 0;
      }
      *((_DWORD *)reply + 11) = v17;
      uint64_t v18 = reply + 56;
      size_t v19 = strlen(__s);
      memcpy(v18, __s, v19 + 1);
      int v20 = (os_log_s *)mDNSLogCategory_mDNS;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
      {
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
        {
LABEL_14:
          int v21 = *(_DWORD *)(v7 + 184);
          unsigned int v22 = bswap32(*(unsigned __int16 *)(a2 + 320));
          int v23 = *(unsigned __int8 *)(a2 + 356) + 1;
          v24[0] = 67110915;
          v24[1] = v21;
          __int16 v25 = 1024;
          unsigned int v26 = HIWORD(v22);
          __int16 v27 = 2160;
          uint64_t v28 = 1752392040LL;
          __int16 v29 = 1040;
          int v30 = v23;
          __int16 v31 = 2101;
          uint64_t v32 = a2 + 356;
          __int16 v33 = 1024;
          int v34 = a4;
          __int16 v35 = 2160;
          uint64_t v36 = 1752392040LL;
          __int16 v37 = 2085;
          v38 = __s;
          _os_log_impl( (void *)&_mh_execute_header,  v20,  OS_LOG_TYPE_DEFAULT,  "[R%d->Q%d] DNSServiceEnumerateDomains(%{sensitive, mask.hash, mdnsresponder:domain_label}.*P) RESULT %{mdns: addrmv_upper}d: %{sensitive, mask.hash}s",  (uint8_t *)v24,  0x42u);
        }
      }

      else
      {
        int v20 = (os_log_s *)mDNSLogCategory_mDNS_redacted;
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_14;
        }
      }

      append_reply(v7, v16);
    }
  }

void SendDelayedUnicastResponse( uint64_t a1, int *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v10 = a1 + 28904;
  uint64_t v76 = 0LL;
  uint64_t v11 = (void *)(a1 + 12664);
  do
    uint64_t v11 = (void *)*v11;
  while (v11 && v11[782] != a3);
  uint64_t v12 = *(void *)(a1 + 12624);
  if (v12)
  {
    uint64_t v13 = &v76;
    while (1)
    {
      uint64_t v14 = *(void *)(v12 + 208);
      if (v14 == -1
        || *(_DWORD *)(v12 + 232) == -1
        || *(_DWORD *)(v12 + 236) == -1
        && *(_DWORD *)(v12 + 240) == -1
        && *(_DWORD *)(v12 + 244) == -1
        && *(_DWORD *)(v12 + 248) == -1)
      {
        *(_BYTE *)(v12 + 195) = 0;
      }

      BOOL v15 = v14 != a3 || *(_BYTE *)(v12 + 195) == 0;
      if (v15) {
        goto LABEL_30;
      }
      if (*a2 == 6)
      {
        if (*(_DWORD *)(v12 + 236) == a2[1] && *(_DWORD *)(v12 + 240) == a2[2] && *(_DWORD *)(v12 + 244) == a2[3])
        {
          int v16 = *(_DWORD *)(v12 + 248);
          int v17 = a2[4];
LABEL_20:
          if (v16 == v17)
          {
            *(void *)(v12 + 208) = 0LL;
            *(_BYTE *)(v12 + 195) = 0;
            *(void *)(v12 + 232) = 0LL;
            *(void *)(v12 + 240) = 0LL;
            *(_DWORD *)(v12 + 248) = 0;
            if ((!v11 || mDNSPlatformValidRecordForInterface(v12, v11[782], a3, a4, a5, a6, a7, a8))
              && !*(void *)(v12 + 256)
              && v13 != (uint64_t *)(v12 + 256))
            {
              *(void *)(v12 + 264) = -1LL;
              uint64_t *v13 = v12;
              uint64_t v13 = (uint64_t *)(v12 + 256);
            }
          }
        }
      }

      else if (*a2 == 4)
      {
        int v16 = *(_DWORD *)(v12 + 232);
        int v17 = a2[1];
        goto LABEL_20;
      }

uint64_t mDNS_Reconfirm_internal(uint64_t result, uint64_t a2, unsigned int a3)
{
  uint64_t v4 = result;
  if (a3 <= 0x1388) {
    unsigned int v5 = 5000;
  }
  else {
    unsigned int v5 = a3;
  }
  if (v5 >= 0x10000000) {
    unsigned int v6 = 0x10000000;
  }
  else {
    unsigned int v6 = v5;
  }
  if (*(_BYTE *)(a2 + 109)) {
    int v7 = dword_100158BF8 + 939524096;
  }
  else {
    int v7 = *(_DWORD *)(a2 + 80) + 1000 * *(_DWORD *)(a2 + 16);
  }
  int v8 = *(_DWORD *)(result + 64);
  if (v7 - v8 > (int)(4 * v6 / 3))
  {
    uint32_t v9 = *(_DWORD *)(result + 128);
    if (!v9)
    {
      do
        uint32_t v10 = arc4random() & 0x3FFFFFFF;
      while (v10 > 0x38000000);
      uint32_t v9 = v10 + 1;
      *(_DWORD *)(v4 + 128) = v10 + 1;
      int v8 = *(_DWORD *)(v4 + 64);
    }

    unsigned int v11 = v9 % (v6 / 3 + 1) + v6;
    *(_DWORD *)(a2 + 80) = -3 * v11 + v8;
    *(_DWORD *)(a2 + 16) = (4 * v11 + 999) / 0x3E8;
    return SetNextCacheCheckTimeForRecord(v4, a2);
  }

  return result;
}

void *_mdns_audit_token_copy_description(uint64_t a1, int a2)
{
  uint64_t v4 = (void *)mdns_string_builder_create();
  if (!v4) {
    return 0LL;
  }
  unsigned int v5 = v4;
  if (a2
    && mdns_string_builder_append_formatted( v4,  "<%s: %p>: ",  *(const char **)(*(void *)(a1 + 16) + 8LL),  (const void *)a1))
  {
    goto LABEL_5;
  }

  __int128 v6 = *(_OWORD *)(a1 + 40);
  *(_OWORD *)atoken.val = *(_OWORD *)(a1 + 24);
  *(_OWORD *)&atoken.val[4] = v6;
  uid_t v7 = audit_token_to_auid(&atoken);
  __int128 v8 = *(_OWORD *)(a1 + 40);
  *(_OWORD *)atoken.val = *(_OWORD *)(a1 + 24);
  *(_OWORD *)&atoken.val[4] = v8;
  uid_t v9 = audit_token_to_euid(&atoken);
  __int128 v10 = *(_OWORD *)(a1 + 40);
  *(_OWORD *)atoken.val = *(_OWORD *)(a1 + 24);
  *(_OWORD *)&atoken.val[4] = v10;
  gid_t v11 = audit_token_to_egid(&atoken);
  __int128 v12 = *(_OWORD *)(a1 + 40);
  *(_OWORD *)atoken.val = *(_OWORD *)(a1 + 24);
  *(_OWORD *)&atoken.val[4] = v12;
  uid_t v13 = audit_token_to_ruid(&atoken);
  __int128 v14 = *(_OWORD *)(a1 + 40);
  *(_OWORD *)atoken.val = *(_OWORD *)(a1 + 24);
  *(_OWORD *)&atoken.val[4] = v14;
  gid_t v15 = audit_token_to_rgid(&atoken);
  __int128 v16 = *(_OWORD *)(a1 + 40);
  *(_OWORD *)atoken.val = *(_OWORD *)(a1 + 24);
  *(_OWORD *)&atoken.val[4] = v16;
  pid_t v17 = audit_token_to_pid(&atoken);
  __int128 v18 = *(_OWORD *)(a1 + 40);
  *(_OWORD *)atoken.val = *(_OWORD *)(a1 + 24);
  *(_OWORD *)&atoken.val[4] = v18;
  int v19 = audit_token_to_pidversion(&atoken);
  __int128 v20 = *(_OWORD *)(a1 + 40);
  *(_OWORD *)atoken.val = *(_OWORD *)(a1 + 24);
  *(_OWORD *)&atoken.val[4] = v20;
  au_asid_t v21 = audit_token_to_asid(&atoken);
  if (mdns_string_builder_append_formatted( v5,  "audit user id: %u, effective user id: %u, effective group id: %u, real user id: %u, real group id : %u, pid: %d, pid version: %d, audit session id: %d",  v7,  v9,  v11,  v13,  v15,  v17,  v19,  v21)) {
LABEL_5:
  }
    unint64_t v22 = 0LL;
  else {
    unint64_t v22 = mdns_string_builder_copy_string((uint64_t)v5);
  }
  os_release(v5);
  return v22;
}

uint64_t mdns_audit_token_create(_OWORD *a1)
{
  uint64_t v2 = _os_object_alloc(&OBJC_CLASS___OS_mdns_audit_token, 56LL);
  uint64_t v3 = v2;
  if (v2)
  {
    uint64_t v4 = &_mdns_audit_token_kind;
    *(void *)(v2 + 16) = &_mdns_audit_token_kind;
    do
    {
      unsigned int v5 = (void (*)(uint64_t))v4[2];
      if (v5) {
        v5(v3);
      }
      uint64_t v4 = (_UNKNOWN **)*v4;
    }

    while (v4);
    __int128 v6 = a1[1];
    *(_OWORD *)(v3 + 24) = *a1;
    *(_OWORD *)(v3 + 40) = v6;
  }

  return v3;
}

void *_mdns_message_builder_copy_description(void *a1, int a2)
{
  uint64_t v4 = (void *)mdns_string_builder_create();
  if (!v4) {
    return 0LL;
  }
  unsigned int v5 = v4;
  else {
    __int128 v6 = mdns_string_builder_copy_string((uint64_t)v5);
  }
  os_release(v5);
  return v6;
}

void _mdns_message_builder_forget_resources(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2)
  {
    os_release(v2);
    a1[3] = 0LL;
  }

  uint64_t v3 = (const void *)a1[4];
  if (v3)
  {
    CFRelease(v3);
    a1[4] = 0LL;
  }

  uint64_t v4 = (const void *)a1[5];
  if (v4)
  {
    CFRelease(v4);
    a1[5] = 0LL;
  }

  unsigned int v5 = (const void *)a1[6];
  if (v5)
  {
    CFRelease(v5);
    a1[6] = 0LL;
  }

uint64_t __mdns_message_builder_write_message_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 24);
  unsigned int v5 = *(void **)(*(void *)(a1 + 32) + 8LL);
  unint64_t v6 = *(void *)(v4 + 32);
  uint64_t v7 = v5[5];
  if (v5[4] - v7 >= v6) {
    size_t v8 = *(void *)(v4 + 32);
  }
  else {
    size_t v8 = v5[4] - v7;
  }
  if (v8)
  {
    memcpy((void *)(v5[3] + v7), *(const void **)(v4 + 24), v8);
    v5[5] += v8;
  }

  uint64_t v9 = v5[6];
  BOOL v10 = __CFADD__(v9, v6);
  uint64_t v11 = v9 + v6;
  if (v10) {
    uint64_t v11 = -1LL;
  }
  v5[6] = v11;
  __src[0] = bswap32(*(unsigned __int16 *)(a2 + 52)) >> 16;
  __src[1] = bswap32(*(unsigned __int16 *)(a2 + 54)) >> 16;
  unsigned int v25 = bswap32(*(_DWORD *)(a2 + 40));
  size_t v12 = *(unsigned __int16 *)(a2 + 56);
  __int16 v26 = __rev16(v12);
  uid_t v13 = *(void **)(*(void *)(a1 + 32) + 8LL);
  uint64_t v14 = v13[5];
  else {
    size_t v15 = v13[4] - v14;
  }
  if (v15)
  {
    memcpy((void *)(v13[3] + v14), __src, v15);
    v13[5] += v15;
  }

  uint64_t v16 = v13[6];
  BOOL v10 = __CFADD__(v16, 10LL);
  uint64_t v17 = v16 + 10;
  if (v10) {
    uint64_t v17 = -1LL;
  }
  v13[6] = v17;
  __int128 v18 = *(void **)(*(void *)(a1 + 32) + 8LL);
  uint64_t v19 = v18[5];
  if (v18[4] - v19 >= v12) {
    size_t v20 = v12;
  }
  else {
    size_t v20 = v18[4] - v19;
  }
  if (v20)
  {
    memcpy((void *)(v18[3] + v19), *(const void **)(a2 + 32), v20);
    v18[5] += v20;
  }

  uint64_t v21 = v18[6];
  BOOL v10 = __CFADD__(v21, v12);
  uint64_t v22 = v21 + v12;
  if (v10) {
    uint64_t v22 = -1LL;
  }
  v18[6] = v22;
  return 1LL;
}

uint64_t _dnssec_obj_context_compare(uint64_t a1, uint64_t a2)
{
  return 2 * (a1 != a2);
}

void _dnssec_obj_context_finalize(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 56);
  if (v2)
  {
    ref_count_obj_release(v2);
    *(void *)(a1 + 56) = 0LL;
  }

  uint64_t v3 = *(void **)(a1 + 64);
  if (v3)
  {
    ref_count_obj_release(v3);
    *(void *)(a1 + 64) = 0LL;
  }

void *_mdns_domain_name_copy_description(void *a1, int a2, int a3)
{
  unint64_t v6 = (void *)mdns_string_builder_create();
  if (!v6) {
    return 0LL;
  }
  uint64_t v7 = v6;
  memset(v11, 0, sizeof(v11));
  size_t v8 = (const char *)a1[5];
  if (a3)
  {
    else {
      size_t v8 = (const char *)v11;
    }
  }

  if (mdns_string_builder_append_formatted(v7, "%s", v8)) {
LABEL_9:
  }
    uint64_t v9 = 0LL;
  else {
    uint64_t v9 = mdns_string_builder_copy_string((uint64_t)v7);
  }
  os_release(v7);
  return v9;
}

uint64_t _mdns_domain_name_equal(uint64_t a1, uint64_t a2)
{
  if (a1 == a2) {
    return 1LL;
  }
  size_t v2 = *(void *)(a1 + 32);
  if (v2 != *(void *)(a2 + 32)) {
    return 0LL;
  }
  if (*(_BYTE *)(a1 + 61) && *(_BYTE *)(a2 + 61)) {
    return memcmp(*(const void **)(a1 + 24), *(const void **)(a2 + 24), v2) == 0;
  }
  return DomainNameEqual(*(unsigned __int8 **)(a1 + 24), *(unsigned __int8 **)(a2 + 24)) != 0;
}

void _mdns_domain_name_finalize(uint64_t a1)
{
  size_t v2 = *(void **)(a1 + 24);
  if (v2)
  {
    free(v2);
    *(void *)(a1 + 24) = 0LL;
  }

  uint64_t v3 = *(void **)(a1 + 40);
  if (v3)
  {
    free(v3);
    *(void *)(a1 + 40) = 0LL;
  }

uint64_t _mdns_domain_name_cf_callback_equal(uint64_t a1, uint64_t a2)
{
  return _mdns_domain_name_equal(a1, a2);
}

uint64_t _mdns_domain_name_cf_callback_hash(uint64_t a1)
{
  size_t v2 = (os_unfair_lock_s *)(a1 + 52);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 52));
  if (!*(_BYTE *)(a1 + 60))
  {
    int v3 = -2128831035;
    uint64_t v4 = *(void *)(a1 + 32);
    if (v4)
    {
      unsigned int v5 = *(unsigned __int8 **)(a1 + 24);
      do
      {
        int v7 = *v5++;
        unsigned __int8 v6 = v7;
        unsigned __int8 v8 = v7 + 32;
        int v3 = 16777619 * (v6 ^ v3);
        --v4;
      }

      while (v4);
    }

    *(_DWORD *)(a1 + 56) = v3;
    *(_BYTE *)(a1 + 60) = 1;
  }

  os_unfair_lock_unlock(v2);
  return *(unsigned int *)(a1 + 56);
}

void *mdns_domain_name_create(char *a1, _DWORD *a2)
{
  int v4 = DomainNameFromString(v5, a1);
  if (v4)
  {
    result = 0LL;
    if (!a2) {
      return result;
    }
  }

  else
  {
    result = mdns_domain_name_create_with_labels(v5, &v4);
    if (!a2) {
      return result;
    }
  }

  *a2 = v4;
  return result;
}

void *mdns_domain_name_create_with_labels(_BYTE *a1, int *a2)
{
  int v8 = 0;
  if (!*a1)
  {
    if (_mdns_domain_name_get_root_s_once != -1) {
      dispatch_once(&_mdns_domain_name_get_root_s_once, &__block_literal_global);
    }
    int v4 = (void *)_mdns_domain_name_get_root_s_root;
    if (_mdns_domain_name_get_root_s_root) {
      goto LABEL_7;
    }
  }

  int v4 = _mdns_domain_name_create(a1, &v8);
  int v5 = v8;
  if (v8)
  {
    unsigned __int8 v6 = 0LL;
  }

  else
  {
LABEL_7:
    int v5 = 0;
    unsigned __int8 v6 = v4;
    int v8 = 0;
    int v4 = 0LL;
  }

  if (a2) {
    *a2 = v5;
  }
  if (v4) {
    os_release(v4);
  }
  return v6;
}

void *_mdns_domain_name_create(_BYTE *a1, int *a2)
{
  int v4 = (void *)_os_object_alloc(&OBJC_CLASS___OS_mdns_domain_name, 64LL);
  int v5 = v4;
  if (v4)
  {
    unsigned __int8 v6 = &_mdns_domain_name_kind;
    v4[2] = &_mdns_domain_name_kind;
    do
    {
      int v7 = (void (*)(void *))v6[2];
      if (v7) {
        v7(v5);
      }
      unsigned __int8 v6 = (_UNKNOWN **)*v6;
    }

    while (v6);
    DomainNameDupEx(a1, v5 + 3, v5 + 4);
    bzero(__s1, 0x3F1uLL);
    int v8 = DomainNameToString((unsigned __int8 *)v5[3], 0LL, (unsigned __int8 *)__s1, 0LL);
    if (v8)
    {
      int v19 = v8;
      int v4 = v5;
      int v5 = 0LL;
    }

    else
    {
      uint64_t v9 = strdup(__s1);
      if (!v9) {
        __break(1u);
      }
      v5[5] = v9;
      *((_DWORD *)v5 + 13) = 0;
      BOOL v10 = (_BYTE *)v5[3];
      unsigned int v11 = *v10;
      if (*v10)
      {
        int v12 = 0;
        uid_t v13 = (_BYTE *)v5[3];
        while (v11 <= 0x3F)
        {
          v13 += v11 + 1;
          if (v13 - v10 > 255) {
            break;
          }
          ++v12;
          unsigned int v11 = *v13;
          if (!*v13) {
            goto LABEL_15;
          }
        }

        int v12 = -1;
      }

      else
      {
        int v12 = 0;
      }

void ___mdns_domain_name_get_root_block_invoke(id a1)
{
  char v2 = 0;
  v1 = _mdns_domain_name_create(&v2, 0LL);
  *((_DWORD *)v1 + 2) = 0x7FFFFFFF;
  *((_DWORD *)v1 + 3) = 0x7FFFFFFF;
  _mdns_domain_name_get_root_s_root = (uint64_t)v1;
}

void mdns_system_remove_network_policy(void *a1)
{
  char v2 = objc_autoreleasePoolPush();
  if (objc_opt_class(&OBJC_CLASS___NEPolicySession))
  {
    [a1 removeAllPolicies];
    [a1 apply];
  }

  objc_autoreleasePoolPop(v2);
}

uint64_t internal_start_advertising_service(uint64_t a1, int a2, unsigned int a3)
{
  unsigned __int8 v6 = (os_log_s *)mDNSLogCategory_D2D;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_D2D == mDNSLogCategory_State)
  {
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_28;
    }
    uint64_t v11 = *(void *)(a1 + 32);
    if (v11)
    {
      unint64_t v14 = *(_BYTE **)(a1 + 32);
      if (v11 == -256)
      {
LABEL_16:
        while (v14)
        {
          uint64_t v15 = *v14;
          if (!*v14)
          {
            int v16 = (unsigned __int16)((_WORD)v14 - v11 + 1);
            goto LABEL_27;
          }

          v14 += v15 + 1;
          if (v11 != -256) {
            goto LABEL_15;
          }
        }
      }

      else
      {
LABEL_15:
      }

      int v16 = 257;
    }

    else
    {
      int v16 = 0;
    }
  }

  else
  {
    unsigned __int8 v6 = (os_log_s *)mDNSLogCategory_D2D_redacted;
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D_redacted, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_28;
    }
    uint64_t v11 = *(void *)(a1 + 32);
    if (v11)
    {
      int v12 = *(_BYTE **)(a1 + 32);
      if (v11 == -256)
      {
LABEL_7:
        while (v12)
        {
          uint64_t v13 = *v12;
          if (!*v12)
          {
            int v16 = (unsigned __int16)((_WORD)v12 - v11 + 1);
            goto LABEL_27;
          }

          v12 += v13 + 1;
          if (v11 != -256) {
            goto LABEL_6;
          }
        }
      }

      else
      {
LABEL_6:
      }

      int v16 = 257;
    }

    else
    {
      int v16 = 0;
    }
  }

_BYTE *DomainnameToLower(_BYTE *result, uint64_t a2)
{
  int v2 = *result;
  if (*result)
  {
    int v3 = result;
    do
    {
      *(_BYTE *)(a2 + v3 - result) = v2;
      int v4 = &(v3++)[a2 - (void)result + 1];
      do
      {
        int v6 = *v3++;
        char v5 = v6;
        char v7 = v6 + 32;
        *v4++ = v5;
        --v2;
      }

      while ((_BYTE)v2);
      int v2 = *v3;
    }

    while (*v3);
  }

  else
  {
    int v3 = result;
  }

  *(_BYTE *)(a2 + v3 - result) = 0;
  return result;
}

void PrintHelper(uint64_t a1, uint64_t a2, int a3, uint64_t a4, int a5)
{
  if (mDNS_LoggingEnabled != 1) {
    return;
  }
  uint64_t v10 = (os_log_s *)mDNSLogCategory_D2D;
  if (gSensitiveLoggingEnabled == 1 && mDNSLogCategory_D2D != mDNSLogCategory_State)
  {
    uint64_t v10 = (os_log_s *)mDNSLogCategory_D2D_redacted;
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D_redacted, OS_LOG_TYPE_DEBUG)) {
      goto LABEL_11;
    }
    goto LABEL_10;
  }

  if (os_log_type_enabled((os_log_t)mDNSLogCategory_D2D, OS_LOG_TYPE_DEBUG))
  {
LABEL_10:
    int v14 = 136447235;
    uint64_t v15 = a1;
    __int16 v16 = 1024;
    int v17 = a3;
    __int16 v18 = 2160;
    uint64_t v19 = 1752392040LL;
    __int16 v20 = 1040;
    int v21 = a3;
    __int16 v22 = 2101;
    uint64_t v23 = a2;
    _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEBUG,  "%{public}s: LHS: (%d bytes) %{sensitive, mask.hash, mdnsresponder:hex_sequence}.*P",  (uint8_t *)&v14,  0x2Cu);
  }

uint64_t xD2DMapToTransportType(uint64_t a1, int a2, _DWORD *a3)
{
  *a3 = 1;
  if ((~a2 & 0x120000) == 0)
  {
    int v3 = (os_log_s *)mDNSLogCategory_D2D;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_D2D == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D, OS_LOG_TYPE_DEFAULT)) {
        return 4LL;
      }
      LOWORD(v25) = 0;
    }

    else
    {
      int v3 = (os_log_s *)mDNSLogCategory_D2D_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D_redacted, OS_LOG_TYPE_DEFAULT)) {
        return 4LL;
      }
      LOWORD(v25) = 0;
    }

    _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEFAULT,  "xD2DMapToTransportType: call all active plugins since both kDNSServiceFlagsIncludeP2P and kDNSServiceFlagsIncludeAWDL are set",  (uint8_t *)&v25,  2u);
    return 4LL;
  }

  if ((a2 & 0x20000) != 0)
  {
    uint64_t v8 = (os_log_s *)mDNSLogCategory_D2D;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_D2D == mDNSLogCategory_State)
    {
      BOOL v10 = os_log_type_enabled((os_log_t)mDNSLogCategory_D2D, OS_LOG_TYPE_DEFAULT);
      uint64_t result = 0LL;
      if (!v10) {
        return result;
      }
      LOWORD(v25) = 0;
      int v12 = "xD2DMapToTransportType: returning D2DBluetoothTransport since only kDNSServiceFlagsIncludeP2P is set";
    }

    else
    {
      uint64_t v8 = (os_log_s *)mDNSLogCategory_D2D_redacted;
      BOOL v16 = os_log_type_enabled((os_log_t)mDNSLogCategory_D2D_redacted, OS_LOG_TYPE_DEFAULT);
      BOOL v17 = v16;
      uint64_t result = 0LL;
      if (!v17) {
        return result;
      }
      LOWORD(v25) = 0;
      int v12 = "xD2DMapToTransportType: returning D2DBluetoothTransport since only kDNSServiceFlagsIncludeP2P is set";
    }

void internal_stop_advertising_service(uint64_t a1, int a2, unsigned int a3)
{
  int v6 = (os_log_s *)mDNSLogCategory_D2D;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_D2D == mDNSLogCategory_State)
  {
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_7;
    }
  }

  else
  {
    int v6 = (os_log_s *)mDNSLogCategory_D2D_redacted;
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D_redacted, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_7;
    }
  }

  GetRRDisplayString_rdb((unsigned __int8 *)a1, (unsigned __int16 *)(*(void *)(a1 + 40) + 4LL), word_100164338);
  int v24 = 141558275;
  uint64_t v25 = 1752392040LL;
  __int16 v26 = 2085;
  uint64_t v27 = word_100164338;
  _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "internal_stop_advertising_service: %{sensitive, mask.hash}s",  (uint8_t *)&v24,  0x16u);
LABEL_7:
  __int16 v11 = *(_WORD *)(a1 + 4);
  int v12 = putDomainNameAsLabels( (unint64_t)&compression_base_msg,  (unint64_t)&unk_100149887,  (unint64_t)&compression_base_msg + &unk_1000022F8,  (unsigned __int8 *)v28,  v7,  v8,  v9,  v10);
  if (v12)
  {
    *int v12 = HIBYTE(v11);
    v12[1] = v11;
    v12[2] = 1;
    BOOL v17 = v12 + 3;
  }

  else
  {
    BOOL v17 = 0LL;
  }

  int v24 = 0;
  __int16 v18 = putRData( (unint64_t)&compression_base_msg,  v17,  (unint64_t)&compression_base_msg + &unk_1000022F8,  a1,  v13,  v14,  v15,  v16);
  int64_t v19 = v18 - v17;
  PrintHelper( (uint64_t)"internal_stop_advertising_service",  (uint64_t)&unk_100149887,  (unsigned __int16)((_WORD)v17 - (unsigned __int16)&unk_100149887),  (uint64_t)v17,  (unsigned __int16)((_WORD)v18 - (_WORD)v17));
  uint64_t v20 = xD2DMapToTransportType(*(void *)(a1 + 24), a2, &v24);
  if ((_DWORD)v20 == 4)
  {
    uint64_t v21 = 0LL;
    int v22 = v24;
    do
    {
      if (v22 != (_DWORD)v21 && &_D2DStopAdvertisingPairOnTransport)
      {
        D2DStopAdvertisingPairOnTransport(&unk_100149887, v17 - (char *)&unk_100149887, v17, v19, v21);
        if ((v21 & 0x7FFFFFFE) == 2) {
          _mdns_powerlog_awdl_event( (uint64_t)@"stopAWDLAdvertise",  (unsigned __int8 *)v28,  *(unsigned __int16 *)(a1 + 4),  a3);
        }
      }

      uint64_t v21 = (v21 + 1);
    }

    while ((_DWORD)v21 != 4);
  }

  else if (&_D2DStopAdvertisingPairOnTransport)
  {
    char v23 = v20;
    D2DStopAdvertisingPairOnTransport(&unk_100149887, v17 - (char *)&unk_100149887, v17, v19, v20);
    if ((v23 & 6) == 2) {
      _mdns_powerlog_awdl_event( (uint64_t)@"stopAWDLAdvertise",  (unsigned __int8 *)v28,  *(unsigned __int16 *)(a1 + 4),  a3);
    }
  }

void D2D_stop_advertising_record( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v9 = *(_DWORD *)(a1 + 172);
  if ((v9 & 0xFFFFFFFD) == 1) {
    uint64_t v10 = 0x20000LL;
  }
  else {
    uint64_t v10 = (v9 == 2) << 20;
  }
  if (callExternalHelpers(*(void *)(a1 + 32), *(_BYTE **)(a1 + 40), v10, a4, a5, a6, a7, a8)) {

  }
    internal_stop_advertising_service(a1 + 8, v10, 0);
}

BOOL callExternalHelpers( uint64_t a1, _BYTE *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  BOOL v9 = (a3 & 0x120001) != 0 && a1 == 0;
}

uint64_t D2D_start_advertising_record( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v9 = *(_DWORD *)(a1 + 172);
  if ((v9 & 0xFFFFFFFD) == 1) {
    uint64_t v10 = 0x20000LL;
  }
  else {
    uint64_t v10 = (v9 == 2) << 20;
  }
  uint64_t result = callExternalHelpers(*(void *)(a1 + 32), *(_BYTE **)(a1 + 40), v10, a4, a5, a6, a7, a8);
  if ((_DWORD)result) {
    return internal_start_advertising_service(a1 + 8, v10, 0);
  }
  return result;
}

void external_connection_release(_BYTE *a1)
{
  for (uint64_t i = D2DRecords; i; uint64_t i = *(void *)i)
  {
    int v3 = (os_log_s *)mDNSLogCategory_D2D;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_D2D == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_13;
      }
    }

    else
    {
      int v3 = (os_log_s *)mDNSLogCategory_D2D_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D_redacted, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_13;
      }
    }

    uint64_t v6 = *(void *)(i + 8);
    int v7 = *(_DWORD *)(i + 16);
    *(_DWORD *)buf = 134218240;
    uint64_t v9 = v6;
    __int16 v10 = 1024;
    int v11 = v7;
    _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEFAULT,  "external_connection_release: Calling D2DRelease - instanceHandle: %p, transportType: %d",  buf,  0x12u);
LABEL_13:
    if (&_D2DRelease) {
      D2DRelease(*(void *)(i + 8), *(unsigned int *)(i + 16));
    }
  }

uint64_t xD2DParseCompressedPacket( _BYTE *a1, unsigned int a2, const void *a3, unsigned int a4, int a5, void *a6)
{
  unint64_t v12 = (unint64_t)&a1[a2];
  unint64_t v13 = skipDomainName((unint64_t)a1, a1, v12);
  if (v13) {
    BOOL v14 = v13 + 3 == (_BYTE *)v12;
  }
  else {
    BOOL v14 = 0;
  }
  if (!v14)
  {
    uint64_t v15 = 4294901745LL;
    uint64_t v16 = mDNSLogCategory_D2D;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_D2D == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D, OS_LOG_TYPE_ERROR)) {
        return v15;
      }
      *(_WORD *)buf = 0;
      __int16 v18 = "xD2DParseCompressedPacket: Could not parse DNS name in key";
    }

    else
    {
      uint64_t v16 = mDNSLogCategory_D2D_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D_redacted, OS_LOG_TYPE_ERROR)) {
        return v15;
      }
      *(_WORD *)buf = 0;
      __int16 v18 = "xD2DParseCompressedPacket: Could not parse DNS name in key";
    }

    uint64_t v32 = (os_log_s *)v16;
    uint32_t v33 = 2;
    goto LABEL_41;
  }

  int v19 = v13[2];
  if (v19 != 1)
  {
    uint64_t v34 = mDNSLogCategory_D2D;
    uint64_t v15 = 4294901745LL;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_D2D == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D, OS_LOG_TYPE_ERROR)) {
        return v15;
      }
      *(_DWORD *)buf = 67109120;
      *(_DWORD *)&uint8_t buf[4] = v19;
      __int16 v18 = "xD2DParseCompressedPacket: Invalid D2D packet version - version: %d";
    }

    else
    {
      uint64_t v34 = mDNSLogCategory_D2D_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D_redacted, OS_LOG_TYPE_ERROR)) {
        return v15;
      }
      *(_DWORD *)buf = 67109120;
      *(_DWORD *)&uint8_t buf[4] = v19;
      __int16 v18 = "xD2DParseCompressedPacket: Invalid D2D packet version - version: %d";
    }

    uint64_t v32 = (os_log_s *)v34;
    uint32_t v33 = 8;
LABEL_41:
    _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_ERROR, v18, buf, v33);
    return v15;
  }

  size_t v20 = a2;
  uint64_t v15 = 4294901745LL;
  unsigned __int16 v45 = (char *)&compression_base_msg + v20 + 39;
  unsigned int v21 = *(unsigned __int16 *)v13;
  memcpy(byte_100149887, a1, v20);
  int v22 = (char *)&byte_100149887[v20 - 1];
  if (*v22 == 1)
  {
    unsigned int v23 = __rev16(v21);
    *(_DWORD *)int v22 = 384;
    v22[4] = BYTE1(a5);
    v22[5] = a5;
    v22[6] = BYTE1(a4);
    v22[7] = a4;
    memcpy(v22 + 8, a3, a4);
    *a6 = &v22[a4 + 8];
    __int128 v72 = 0u;
    __int128 v73 = 0u;
    __int128 v70 = 0u;
    __int128 v71 = 0u;
    __int128 v68 = 0u;
    __int128 v69 = 0u;
    __int128 v66 = 0u;
    __int128 v67 = 0u;
    __int128 v64 = 0u;
    __int128 v65 = 0u;
    __int128 v62 = 0u;
    __int128 v63 = 0u;
    __int128 v60 = 0u;
    __int128 v61 = 0u;
    *(_OWORD *)buf = 0u;
    __int128 v59 = 0u;
    if (!getDomainName( (unint64_t)&compression_base_msg,  byte_100149887,  (unint64_t)&compression_base_msg + &unk_1000022F8,  buf)) {
      buf[0] = 0;
    }
    if (v23 != 12) {
      goto LABEL_46;
    }
    int v24 = buf[0];
    if (!buf[0]) {
      goto LABEL_46;
    }
    uint64_t v25 = 0LL;
    __int16 v26 = 0LL;
    uint64_t v27 = buf;
    while (1)
    {
      uint64_t v28 = v26;
      __int16 v26 = v25;
      uint64_t v25 = v27;
      if ((unint64_t)v26 | (unint64_t)v28)
      {
        if (v26 && v28)
        {
          int v38 = SameDomainLabelPointer(v26, "\x04_sub");
          if (v38 && LabelPairIsForService(v25))
          {
LABEL_45:
            *int v22 = 0;
            *unsigned __int16 v45 = 1;
          }

void xD2DReceiveResponse(unint64_t a1, int a2)
{
  int v4 = &AWDLInterfaceID;
  if (a2 != 2) {
    int v4 = &WiFiAwareInterfaceID;
  }
  mDNSCoreReceiveResponse( (uint64_t)mDNSStorage,  compression_base_msg,  a1,  0LL,  0xE914u,  (__int128 *)&AllDNSLinkGroup_v6,  0xE914u,  0LL,  0LL,  *v4);
  mDNS_Unlock_((uint64_t)mDNSStorage, (uint64_t)"xD2DReceiveResponse", 489);
}

uint64_t xD2DParse(_BYTE *a1, unsigned int a2, const void *a3, unsigned int a4, char **a5)
{
  unint64_t v33 = 0LL;
  uint64_t v6 = xD2DParseCompressedPacket(a1, a2, a3, a4, 120, &v33);
  if ((_DWORD)v6) {
    return v6;
  }
  LargeResourceRecord = GetLargeResourceRecord( (uint64_t)mDNSStorage,  (unint64_t)compression_base_msg,  byte_100149887,  v33,  0LL,  192,  (uint64_t)mDNSStorage + &loc_1000093E0);
  char v8 = gSensitiveLoggingEnabled;
  uint64_t v9 = (os_log_s *)mDNSLogCategory_D2D;
  if (mDNSLogCategory_D2D == mDNSLogCategory_State) {
    char v8 = 0;
  }
  if (LargeResourceRecord && *((unsigned __int8 *)&dword_100158BC0 + &loc_1000093E0) != 240)
  {
    if ((v8 & 1) != 0)
    {
      uint64_t v9 = (os_log_s *)mDNSLogCategory_D2D_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D_redacted, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_39;
      }
      uint64_t v10 = qword_100161FC0;
      if (qword_100161FC0)
      {
        int v11 = (_BYTE *)qword_100161FC0;
        if (qword_100161FC0 == -256)
        {
LABEL_11:
          while (v11)
          {
            uint64_t v12 = *v11;
            if (!*v11)
            {
              int v17 = (unsigned __int16)((_WORD)v11 - qword_100161FC0 + 1);
              goto LABEL_38;
            }

            v11 += v12 + 1;
            if (qword_100161FC0 != -256) {
              goto LABEL_10;
            }
          }
        }

        else
        {
LABEL_10:
        }

        int v17 = 257;
      }

      else
      {
        int v17 = 0;
      }
    }

    else
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_39;
      }
      uint64_t v10 = qword_100161FC0;
      if (qword_100161FC0)
      {
        uint64_t v15 = (_BYTE *)qword_100161FC0;
        if (qword_100161FC0 == -256)
        {
LABEL_23:
          while (v15)
          {
            uint64_t v16 = *v15;
            if (!*v15)
            {
              int v17 = (unsigned __int16)((_WORD)v15 - qword_100161FC0 + 1);
              goto LABEL_38;
            }

            v15 += v16 + 1;
            if (qword_100161FC0 != -256) {
              goto LABEL_22;
            }
          }
        }

        else
        {
LABEL_22:
        }

        int v17 = 257;
      }

      else
      {
        int v17 = 0;
      }
    }

void FreeD2DARElemCallback(uint64_t a1, uint64_t a2, int a3)
{
  if (a3 == -65792)
  {
    char v5 = &D2DRecords;
    do
    {
      uint64_t v6 = v5;
      char v5 = (uint64_t *)*v5;
      if (v5) {
        BOOL v7 = v5 + 3 == (uint64_t *)a2;
      }
      else {
        BOOL v7 = 1;
      }
    }

    while (!v7);
    char v8 = gSensitiveLoggingEnabled;
    uint64_t v9 = (os_log_s *)mDNSLogCategory_D2D;
    if (mDNSLogCategory_D2D == mDNSLogCategory_State) {
      char v8 = 0;
    }
    if (v5)
    {
      if ((v8 & 1) != 0)
      {
        uint64_t v9 = (os_log_s *)mDNSLogCategory_D2D_redacted;
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_D2D_redacted, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_18;
        }
      }

      else if (os_log_type_enabled((os_log_t)mDNSLogCategory_D2D, OS_LOG_TYPE_DEFAULT))
      {
LABEL_18:
        uint64_t v10 = (_BYTE *)(a1 + 46976);
        GetRRDisplayString_rdb((unsigned __int8 *)(a2 + 8), (unsigned __int16 *)(*(void *)(a2 + 48) + 4LL), v10);
        int v13 = 141558275;
        uint64_t v14 = 1752392040LL;
        __int16 v15 = 2085;
        uint64_t v16 = v10;
        _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEFAULT,  "FreeD2DARElemCallback: Found in D2DRecords: %{sensitive, mask.hash}s",  (uint8_t *)&v13,  0x16u);
      }

      int v11 = (void *)*v6;
      *uint64_t v6 = *(void *)*v6;
      free(v11);
      return;
    }

    if ((v8 & 1) != 0)
    {
      uint64_t v9 = (os_log_s *)mDNSLogCategory_D2D_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D_redacted, OS_LOG_TYPE_DEFAULT)) {
        return;
      }
    }

    else if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D, OS_LOG_TYPE_DEFAULT))
    {
      return;
    }

    uint64_t v12 = (_BYTE *)(a1 + 46976);
    GetRRDisplayString_rdb((unsigned __int8 *)(a2 + 8), (unsigned __int16 *)(*(void *)(a2 + 48) + 4LL), v12);
    int v13 = 141558275;
    uint64_t v14 = 1752392040LL;
    __int16 v15 = 2085;
    uint64_t v16 = v12;
    _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEFAULT,  "FreeD2DARElemCallback: Could not find in D2DRecords: %{sensitive, mask.hash}s",  (uint8_t *)&v13,  0x16u);
  }

BOOL LabelPairIsForService(unsigned __int8 *a1)
{
  uint64_t v1 = *a1;
  if (!*a1) {
    return 0LL;
  }
  int v3 = a1[1];
  int v2 = a1 + 1;
  if (v3 != 95) {
    return 0LL;
  }
  int v4 = &v2[v1];
}

void external_start_browsing_for_service(uint64_t a1, unsigned __int8 *a2, int a3, int a4, unsigned int a5)
{
  uint64_t v10 = D2DFindInBrowseList(__src, a3);
  if (*v10 && *(_DWORD *)(*v10 + 268)) {
    goto LABEL_40;
  }
  int v46 = 0;
  int v11 = (os_log_s *)mDNSLogCategory_D2D;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_D2D == mDNSLogCategory_State)
  {
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_24;
    }
    for (uint64_t i = (uint8_t *)__src; ; i += v19 + 1)
    {
      if (i >= buf || !i || (uint64_t v19 = *i, v19 > 0x3F))
      {
        LOWORD(v20) = 257;
        goto LABEL_23;
      }

      if (!*i) {
        break;
      }
    }

    unsigned int v20 = (_DWORD)i - __src + 1;
  }

  else
  {
    int v11 = (os_log_s *)mDNSLogCategory_D2D_redacted;
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D_redacted, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_24;
    }
    for (j = (uint8_t *)__src; ; j += v17 + 1)
    {
      if (j >= buf || !j || (uint64_t v17 = *j, v17 > 0x3F))
      {
        LOWORD(v20) = 257;
        goto LABEL_23;
      }

      if (!*j) {
        break;
      }
    }

    unsigned int v20 = (_DWORD)j - __src + 1;
  }

LABEL_51:
  uint64_t v33 = *v28;
  int v34 = *(_DWORD *)(*v28 + 268) + 1;
  *(_DWORD *)(v33 + 268) = v34;
  uint64_t v35 = (os_log_s *)mDNSLogCategory_D2D;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_D2D == mDNSLogCategory_State)
  {
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D, OS_LOG_TYPE_DEBUG)) {
      return;
    }
    int v37 = (_OWORD *)(v33 + 8);
    __int16 v38 = (unsigned __int16 *)(v33 + 264);
    uint64_t v39 = (unsigned __int16 *)(v33 + 8);
    if (v33 == -264)
    {
LABEL_59:
      while (v39)
      {
        uint64_t v40 = *(unsigned __int8 *)v39;
        if (!*(_BYTE *)v39)
        {
          int v44 = (unsigned __int16)((_WORD)v39 - (_WORD)v37 + 1);
          goto LABEL_76;
        }

        uint64_t v39 = (unsigned __int16 *)((char *)v39 + v40 + 1);
        if (v33 != -264) {
          goto LABEL_58;
        }
      }
    }

    else
    {
LABEL_58:
      if (v39 < v38) {
        goto LABEL_59;
      }
    }

    int v44 = 257;
    goto LABEL_76;
  }

  uint64_t v35 = (os_log_s *)mDNSLogCategory_D2D_redacted;
  if (os_log_type_enabled((os_log_t)mDNSLogCategory_D2D_redacted, OS_LOG_TYPE_DEBUG))
  {
    int v37 = (_OWORD *)(v33 + 8);
    __int16 v38 = (unsigned __int16 *)(v33 + 264);
    __int16 v42 = (unsigned __int16 *)(v33 + 8);
    if (v33 == -264)
    {
LABEL_67:
      while (v42)
      {
        uint64_t v43 = *(unsigned __int8 *)v42;
        if (!*(_BYTE *)v42)
        {
          int v44 = (unsigned __int16)((_WORD)v42 - (_WORD)v37 + 1);
          goto LABEL_76;
        }

        __int16 v42 = (unsigned __int16 *)((char *)v42 + v43 + 1);
        if (v33 != -264) {
          goto LABEL_66;
        }
      }
    }

    else
    {
LABEL_66:
      if (v42 < v38) {
        goto LABEL_67;
      }
    }

    int v44 = 257;
LABEL_76:
    int v45 = *v38;
    *(_DWORD *)buf = 141559043;
    uint64_t v49 = 1752392040LL;
    __int16 v50 = 1040;
    int v51 = v44;
    __int16 v52 = 2101;
    unsigned int v53 = v37;
    __int16 v54 = 1024;
    int v55 = v45;
    __int16 v56 = 1024;
    int v57 = v34;
    _os_log_impl( (void *)&_mh_execute_header,  v35,  OS_LOG_TYPE_DEBUG,  "D2DBrowseListRetain - name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P, type: %{mdns:rrtype}d, ref count: %u",  buf,  0x28u);
  }

        v49[0] = 67110147;
        v49[1] = v34;
        __int16 v50 = 2160;
        int v51 = 1752392040LL;
        __int16 v52 = 1040;
        unsigned int v53 = v38;
        __int16 v54 = 2101;
        int v55 = v36;
        __int16 v56 = 2082;
        int v57 = DNSTypeName(a3);
        _os_log_impl( (void *)&_mh_execute_header,  v33,  OS_LOG_TYPE_ERROR,  "[R%u] read_rr_from_ipc_msg: SetRData failed for %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%{public}s)",  (uint8_t *)v49,  0x2Cu);
      }
    }

    free((void *)v17);
    return 4294901756LL;
  }

  SetNewRData(v18, 0LL, 0LL, v21, v22, v23, v24, v25);
  *(void *)(v17 + 48) = *v20;
  int v26 = mDNS_AddRecordToService((uint64_t)mDNSStorage, a2 + 288, v17, v19, a6, *(_DWORD *)(a1 + 232));
  if ((_DWORD)v26)
  {
    unsigned int v32 = v26;
    free((void *)v17);
  }

  else
  {
    if (mDNS_McastLoggingEnabled) {
      LogMcastService(a2 + 1520, a1, 1, v27, v28, v29, v30, v31, v49[0]);
    }
    *(_DWORD *)(v17 + 8) = *(_DWORD *)(a1 + 224);
    if (*(_BYTE *)(a2 + 27)
      && callExternalHelpers(*v20, (_BYTE *)(a2 + 28), *(unsigned int *)(a1 + 232), v27, v28, v29, v30, v31))
    {
      if (mDNS_LoggingEnabled == 1) {
        LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "add_record_to_service: calling external_start_advertising_service",  v40,  v41,  v42,  v43,  v44,  v49[0]);
      }
      internal_start_advertising_service(v18, *(_DWORD *)(a1 + 232), *(_DWORD *)(a1 + 172));
    }

    return 0LL;
  }

  return v32;
}

    int v26 = *(unsigned __int16 *)(v2 + 322);
    v32[0] = 67111171;
    v32[1] = v6;
    uint64_t v33 = 1024;
    int v34 = v7;
    uint64_t v35 = 2160;
    __int16 v36 = 1752392040LL;
    int v37 = 1040;
    __int16 v38 = v19;
    uint64_t v39 = 2101;
    uint64_t v40 = v2 + 356;
    int v41 = 2160;
    __int16 v42 = 1752392040LL;
    uint64_t v43 = 1040;
    int v44 = v23;
    int v45 = 2101;
    int v46 = v20;
    uint64_t v47 = 1024;
    __int16 v48 = v26;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_INFO,  "[R%u->Q%u] Restarting question that got expired CNAMEs -- current name: %{sensitive, mask.hash, mdnsresponder:doma in_name}.*P, original name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P, type: %{mdns:rrtype}d",  (uint8_t *)v32,  0x48u);
  }

uint64_t *D2DFindInBrowseList(_BYTE *a1, int a2)
{
  int v2 = &D2DBrowseList;
  for (uint64_t i = D2DBrowseList; i; uint64_t i = *(void *)i)
  {
    if (*(unsigned __int16 *)(i + 264) == a2)
    {
      uint64_t i = *v2;
    }

    int v2 = (uint64_t *)i;
  }

  return v2;
}

void external_stop_browsing_for_service(uint64_t a1, unsigned __int8 *a2, int a3, int a4, unsigned int a5)
{
  uint64_t v10 = D2DFindInBrowseList(v60, a3);
  uint64_t v11 = *v10;
  if (*v10)
  {
    unint64_t v12 = v10;
    int v13 = *(_DWORD *)(v11 + 268) - 1;
    *(_DWORD *)(v11 + 268) = v13;
    uint64_t v14 = (os_log_s *)mDNSLogCategory_D2D;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_D2D == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D, OS_LOG_TYPE_DEBUG)) {
        goto LABEL_41;
      }
      uint64_t v15 = (_OWORD *)(v11 + 8);
      uint64_t v16 = (unsigned __int16 *)(v11 + 264);
      for (uint64_t i = (unsigned __int16 *)(v11 + 8); ; uint64_t i = (unsigned __int16 *)((char *)i + v23 + 1))
      {
        if (i >= v16 || !i || (uint64_t v23 = *(unsigned __int8 *)i, v23 > 0x3F))
        {
          int v26 = 257;
          goto LABEL_40;
        }

        if (!*(_BYTE *)i) {
          break;
        }
      }

      int v26 = (unsigned __int16)((_WORD)i - (_WORD)v15 + 1);
    }

    else
    {
      uint64_t v14 = (os_log_s *)mDNSLogCategory_D2D_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D_redacted, OS_LOG_TYPE_DEBUG)) {
        goto LABEL_41;
      }
      uint64_t v15 = (_OWORD *)(v11 + 8);
      uint64_t v16 = (unsigned __int16 *)(v11 + 264);
      for (j = (unsigned __int16 *)(v11 + 8); ; j = (unsigned __int16 *)((char *)j + v18 + 1))
      {
        if (j >= v16 || !j || (uint64_t v18 = *(unsigned __int8 *)j, v18 > 0x3F))
        {
          int v26 = 257;
          goto LABEL_40;
        }

        if (!*(_BYTE *)j) {
          break;
        }
      }

      int v26 = (unsigned __int16)((_WORD)j - (_WORD)v15 + 1);
    }

LABEL_107:
          int v58 = (unsigned __int16)v53;
          GetRRDisplayString_rdb((unsigned __int8 *)v49 + 32, (unsigned __int16 *)(v49[9] + 4LL), word_100164338);
          *(_DWORD *)buf = 141559299;
          uint64_t v62 = 1752392040LL;
          __int16 v63 = 1040;
          int v64 = v58;
          __int16 v65 = 2101;
          __int128 v66 = v60;
          __int16 v67 = 1024;
          int v68 = a3;
          __int16 v69 = 2160;
          uint64_t v70 = 1752392040LL;
          __int16 v71 = 2085;
          __int128 v72 = word_100164338;
          _os_log_impl( (void *)&_mh_execute_header,  v50,  OS_LOG_TYPE_DEFAULT,  "xD2DClearCache: Clearing and deregistering cache record - name: %{sensitive, mask.hash, mdnsresponder:domain _name}.*P, rrtype: %{mdns:rrtype}d, auth record: %{sensitive, mask.hash}s",  buf,  0x36u);
        }

uint64_t external_start_resolving_service(uint64_t a1, unsigned __int8 *a2, int a3, unsigned int a4)
{
  uint64_t v8 = *a2;
  memset(v38, 0, 32);
  if ((_DWORD)v8) {
    uint64_t v9 = &a2[v8 + 1];
  }
  else {
    uint64_t v9 = a2;
  }
  memset(&v38[2], 0, 224);
  DomainnameToLower(v9, (uint64_t)v38);
  uint64_t v10 = (os_log_s *)mDNSLogCategory_Default;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
  {
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_32;
    }
    uint64_t v18 = a2;
LABEL_18:
    int v16 = 257;
    if (v18 < a2 + 256 && v18)
    {
      while (1)
      {
        uint64_t v19 = *v18;
        if (v19 > 0x3F)
        {
LABEL_27:
          int v16 = 257;
          goto LABEL_31;
        }

        if (!*v18) {
          break;
        }
        v18 += v19 + 1;
LABEL_21:
        if (!v18) {
          goto LABEL_27;
        }
      }

      int v16 = (unsigned __int16)((_WORD)v18 - (_WORD)a2 + 1);
    }
  }

  else
  {
    uint64_t v10 = (os_log_s *)mDNSLogCategory_Default_redacted;
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_32;
    }
    uint64_t v15 = a2;
LABEL_8:
    int v16 = 257;
    if (v15 < a2 + 256 && v15)
    {
      while (1)
      {
        uint64_t v17 = *v15;
        if (v17 > 0x3F)
        {
LABEL_26:
          int v16 = 257;
          goto LABEL_31;
        }

        if (!*v15) {
          break;
        }
        v15 += v17 + 1;
LABEL_11:
        if (!v15) {
          goto LABEL_26;
        }
      }

      int v16 = (unsigned __int16)((_WORD)v15 - (_WORD)a2 + 1);
    }
  }

void initializeD2DPlugins()
{
  if (&_D2DInitialize)
  {
    CFRunLoopRef Main = CFRunLoopGetMain();
    int v1 = D2DInitialize(Main, xD2DServiceCallback, mDNSStorage);
    char v2 = gSensitiveLoggingEnabled;
    uint64_t v3 = mDNSLogCategory_D2D;
    if (mDNSLogCategory_D2D == mDNSLogCategory_State) {
      char v2 = 0;
    }
    if (v1)
    {
      int v4 = v1;
      if ((v2 & 1) != 0)
      {
        uint64_t v3 = mDNSLogCategory_D2D_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D_redacted, OS_LOG_TYPE_ERROR)) {
          return;
        }
        int v9 = 67109120;
        int v10 = v4;
        char v5 = "D2DInitialiize failed: %d";
      }

      else
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D, OS_LOG_TYPE_ERROR)) {
          return;
        }
        int v9 = 67109120;
        int v10 = v4;
        char v5 = "D2DInitialiize failed: %d";
      }

      uint64_t v6 = (os_log_s *)v3;
      os_log_type_t v7 = OS_LOG_TYPE_ERROR;
      uint32_t v8 = 8;
    }

    else
    {
      if ((v2 & 1) != 0)
      {
        uint64_t v3 = mDNSLogCategory_D2D_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D_redacted, OS_LOG_TYPE_DEFAULT)) {
          return;
        }
        LOWORD(v9) = 0;
        char v5 = "D2DInitialize succeeded";
      }

      else
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D, OS_LOG_TYPE_DEFAULT)) {
          return;
        }
        LOWORD(v9) = 0;
        char v5 = "D2DInitialize succeeded";
      }

      uint64_t v6 = (os_log_s *)v3;
      os_log_type_t v7 = OS_LOG_TYPE_DEFAULT;
      uint32_t v8 = 2;
    }

    _os_log_impl((void *)&_mh_execute_header, v6, v7, v5, (uint8_t *)&v9, v8);
  }

void xD2DServiceCallback( int a1, int a2, uint64_t a3, uint64_t a4, _BYTE *a5, unint64_t a6, _OWORD *a7, unint64_t a8)
{
  uint64_t v16 = pthread_mutex_lock((pthread_mutex_t *)(mDNSStorage[0] + 616));
  *(_DWORD *)(mDNSStorage[0] + 680) = mDNSPlatformRawTime(v16, v17, v18, v19, v20, v21, v22, v23);
  if (a6 >= 0x10000)
  {
    uint64_t v24 = (os_log_s *)mDNSLogCategory_D2D;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_D2D == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D, OS_LOG_TYPE_ERROR)) {
        goto LABEL_12;
      }
      *(_DWORD *)buf = 134217984;
      *(void *)&uint8_t buf[4] = a6;
      goto LABEL_11;
    }

    uint64_t v24 = (os_log_s *)mDNSLogCategory_D2D_redacted;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_D2D_redacted, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 134217984;
      *(void *)&uint8_t buf[4] = a6;
LABEL_11:
      _os_log_impl( (void *)&_mh_execute_header,  v24,  OS_LOG_TYPE_ERROR,  "xD2DServiceCallback: keySize too large - key size: %zu",  buf,  0xCu);
    }
  }

LABEL_308:
            int v114 = *(unsigned __int16 *)(v86 + 36);
            uint64_t v115 = *(void *)(v86 + 56);
            GetRRDisplayString_rdb( (unsigned __int8 *)(v86 + 32),  (unsigned __int16 *)(*(void *)(v86 + 72) + 4LL),  word_100164338);
            *(_DWORD *)buf = 141559555;
            *(void *)&uint8_t buf[4] = 1752392040LL;
            *(_WORD *)&buf[12] = 1040;
            *(_DWORD *)&buf[14] = v109;
            __int16 v127 = 2101;
            *(void *)int v128 = v98;
            *(_WORD *)&v128[8] = 1024;
            *(_DWORD *)&v128[10] = v114;
            *(_WORD *)&v128[14] = 2048;
            *(void *)&v128[16] = v115;
            *(_WORD *)&v128[24] = 2160;
            *(void *)&v128[26] = 1752392040LL;
            *(_WORD *)&v128[34] = 2085;
            *(void *)&v128[36] = word_100164338;
            _os_log_impl( (void *)&_mh_execute_header,  v89,  OS_LOG_TYPE_DEFAULT,  "xD2DAddToCache: mDNS_Register succeeded - name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P, typ e: %{mdns:rrtype}d, Interface ID: %p, auth record: %{sensitive, mask.hash}s",  buf,  0x40u);
          }
        }

        else if (os_log_type_enabled((os_log_t)mDNSLogCategory_D2D, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v98 = *(void *)(v86 + 64);
          if (v98)
          {
            uint64_t v104 = *(_BYTE **)(v86 + 64);
            if (v98 == -256)
            {
LABEL_278:
              while (v104)
              {
                uint64_t v105 = *v104;
                if (!*v104)
                {
                  int v109 = (unsigned __int16)((_WORD)v104 - v98 + 1);
                  goto LABEL_308;
                }

                v104 += v105 + 1;
                if (v98 != -256) {
                  goto LABEL_277;
                }
              }
            }

            else
            {
LABEL_277:
            }

            int v109 = 257;
          }

          else
          {
            int v109 = 0;
          }

          goto LABEL_308;
        }

        *(_DWORD *)(v86 + 16) = a4;
        *(void *)uint64_t v86 = D2DRecords;
        *(void *)(v86 + 8) = a3;
        D2DRecords = v86;
        goto LABEL_153;
      }

      *(void *)buf = 0LL;
      int v47 = xD2DParseCompressedPacket(a5, (unsigned __int16)a6, a7, (unsigned __int16)a8, 4500, buf);
      if (!v47) {
        goto LABEL_177;
      }
      int v48 = v47;
      uint64_t v40 = mDNSLogCategory_D2D;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_D2D == mDNSLogCategory_State)
      {
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_D2D, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)int v125 = 67109120;
          *(_DWORD *)&v125[4] = v48;
          int v41 = "xD2DAddToCache: xD2DParseCompressedPacket failed - error: %d";
          goto LABEL_231;
        }
      }

      else
      {
        uint64_t v40 = mDNSLogCategory_D2D_redacted;
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_D2D_redacted, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)int v125 = 67109120;
          *(_DWORD *)&v125[4] = v48;
          int v41 = "xD2DAddToCache: xD2DParseCompressedPacket failed - error: %d";
          goto LABEL_231;
        }
      }

LABEL_153:
      KQueueUnlock((uint64_t)"xD2DServiceCallback", v33, v34, v35, v36, v37, v38, v39);
      return;
    case 1:
      if (a2)
      {
        uint64_t v40 = mDNSLogCategory_D2D;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_D2D == mDNSLogCategory_State)
        {
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D, OS_LOG_TYPE_ERROR)) {
            goto LABEL_153;
          }
          *(_DWORD *)buf = 67109120;
          *(_DWORD *)&uint8_t buf[4] = a2;
          int v41 = "xD2DRemoveFromCache: Unexpected result - result: %d";
        }

        else
        {
          uint64_t v40 = mDNSLogCategory_D2D_redacted;
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D_redacted, OS_LOG_TYPE_ERROR)) {
            goto LABEL_153;
          }
          *(_DWORD *)buf = 67109120;
          *(_DWORD *)&uint8_t buf[4] = a2;
          int v41 = "xD2DRemoveFromCache: Unexpected result - result: %d";
        }

  if (mDNS_LoggingEnabled == 1)
  {
    uint64_t v101 = "Received";
    if (!v41) {
      uint64_t v101 = "Ignoring";
    }
    LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "%s %d-byte UDP from %#a:%d to %#a:%d",  (uint64_t)a4,  a5,  a6,  (uint64_t)a7,  a8,  (int)v101);
  }

LABEL_149:
        __int16 v67 = buf;
LABEL_150:
        int v68 = (os_log_s *)v40;
LABEL_151:
        os_log_type_t v69 = OS_LOG_TYPE_ERROR;
        uint32_t v70 = 8;
LABEL_152:
        _os_log_impl((void *)&_mh_execute_header, v68, v69, v41, v67, v70);
        goto LABEL_153;
      }

      if ((a4 & 0xFFFFFFFE) == 2)
      {
        *(void *)buf = 0LL;
        int v49 = xD2DParseCompressedPacket(a5, (unsigned __int16)a6, a7, (unsigned __int16)a8, 0, buf);
        if (!v49)
        {
LABEL_177:
          xD2DReceiveResponse(*(unint64_t *)buf, a4);
          goto LABEL_153;
        }

        int v50 = v49;
        uint64_t v40 = mDNSLogCategory_D2D;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_D2D == mDNSLogCategory_State)
        {
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D, OS_LOG_TYPE_ERROR)) {
            goto LABEL_153;
          }
          *(_DWORD *)int v125 = 67109120;
          *(_DWORD *)&v125[4] = v50;
          int v41 = "xD2DRemoveFromCache: xD2DParseCompressedPacket failed - error: %d";
        }

        else
        {
          uint64_t v40 = mDNSLogCategory_D2D_redacted;
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D_redacted, OS_LOG_TYPE_ERROR)) {
            goto LABEL_153;
          }
          *(_DWORD *)int v125 = 67109120;
          *(_DWORD *)&v125[4] = v50;
          int v41 = "xD2DRemoveFromCache: xD2DParseCompressedPacket failed - error: %d";
        }

LABEL_231:
        __int16 v67 = v125;
        goto LABEL_150;
      }

      uint64_t v72 = D2DRecords;
      *(void *)int v125 = 0LL;
      if (!a8 || !a6 || !a5 || !a7)
      {
        uint64_t v71 = mDNSLogCategory_D2D;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_D2D == mDNSLogCategory_State)
        {
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D, OS_LOG_TYPE_ERROR)) {
            goto LABEL_153;
          }
          *(_WORD *)buf = 0;
          int v41 = "xD2DFindInList: NULL Byte * passed in or length == 0";
        }

        else
        {
          uint64_t v71 = mDNSLogCategory_D2D_redacted;
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D_redacted, OS_LOG_TYPE_ERROR)) {
            goto LABEL_153;
          }
          *(_WORD *)buf = 0;
          int v41 = "xD2DFindInList: NULL Byte * passed in or length == 0";
        }

              archive_write_close(v64);
              goto LABEL_232;
            }

            __int16 v89 = mDNSLogCategory_XPC;
            if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_XPC == mDNSLogCategory_State)
            {
              if (os_log_type_enabled((os_log_t)mDNSLogCategory_XPC, OS_LOG_TYPE_DEBUG))
              {
LABEL_221:
                __int128 v111 = archive_error_string(v64);
                *(_DWORD *)v136 = 136446210;
                *(void *)&v136[4] = v111;
                int v108 = "archive_write_open_filename fails: %{public}s";
                int v109 = (os_log_s *)v89;
                int v110 = 12;
                goto LABEL_222;
              }
            }

            else
            {
              __int16 v89 = mDNSLogCategory_XPC_redacted;
              if (os_log_type_enabled((os_log_t)mDNSLogCategory_XPC_redacted, OS_LOG_TYPE_DEBUG)) {
                goto LABEL_221;
              }
            }

LABEL_303:
            int v113 = *(unsigned __int16 *)(v82 + 36);
            GetRRDisplayString_rdb( (unsigned __int8 *)(v82 + 32),  (unsigned __int16 *)(*(void *)(v82 + 72) + 4LL),  word_100164338);
            *(_DWORD *)buf = 141559299;
            *(void *)&uint8_t buf[4] = 1752392040LL;
            *(_WORD *)&buf[12] = 1040;
            *(_DWORD *)&buf[14] = v106;
            __int16 v127 = 2101;
            *(void *)int v128 = v83;
            *(_WORD *)&v128[8] = 1024;
            *(_DWORD *)&v128[10] = v113;
            *(_WORD *)&v128[14] = 2160;
            *(void *)&v128[16] = 1752392040LL;
            *(_WORD *)&v128[24] = 2085;
            *(void *)&v128[26] = word_100164338;
            _os_log_impl( (void *)&_mh_execute_header,  v81,  OS_LOG_TYPE_ERROR,  "xD2DFindInList: Could not find in D2DRecords - name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P , type: %{mdns:rrtype}d, auth record: %{sensitive, mask.hash}s",  buf,  0x36u);
LABEL_304:
            __int128 v95 = (void *)v82;
LABEL_305:
            free(v95);
            goto LABEL_153;
          }

          goto LABEL_253;
        }
      }

      else
      {
        uint64_t v82 = *(void *)v125;
      }

      if (os_log_type_enabled((os_log_t)mDNSLogCategory_D2D, OS_LOG_TYPE_ERROR))
      {
        uint64_t v83 = *(void *)(v82 + 64);
        if (v83)
        {
          __int128 v96 = *(_BYTE **)(v82 + 64);
          if (v83 == -256)
          {
            while (1)
            {
LABEL_248:
              if (!v96) {
                goto LABEL_283;
              }
              uint64_t v97 = *v96;
              if (!*v96) {
                break;
              }
              v96 += v97 + 1;
              if (v83 != -256) {
                goto LABEL_247;
              }
            }

            int v106 = (unsigned __int16)((_WORD)v96 - v83 + 1);
          }

          else
          {
LABEL_247:
LABEL_283:
            int v106 = 257;
          }
        }

        else
        {
          int v106 = 0;
        }

        goto LABEL_303;
      }

      uint64_t v18 = &v11[v19];
      return v18 == (unsigned __int8 *)v10;
    case 0x23:
      v146 = 0u;
      v147 = 0u;
      v144 = 0u;
      v145 = 0u;
      v142 = 0u;
      v143 = 0u;
      v140 = 0u;
      v141 = 0u;
      v138 = 0u;
      v139 = 0u;
      v136 = 0u;
      v137 = 0u;
      unsigned int v134 = 0u;
      __int16 v135 = 0u;
      *(_OWORD *)buf = 0u;
      __int16 v133 = 0u;
      uint64_t v38 = &__src[__src[4] + 5];
      if ((unint64_t)v38 >= a3)
      {
        if (mDNS_LoggingEnabled != 1) {
          return 0LL;
        }
        uint64_t v64 = (os_log_s *)mDNSLogCategory_Default;
        int v65 = "SetRData: Malformed NAPTR flags";
        goto LABEL_330;
      }

      uint64_t v39 = &v38[*v38 + 1];
      if ((unint64_t)v39 >= a3)
      {
        if (mDNS_LoggingEnabled != 1) {
          return 0LL;
        }
        uint64_t v64 = (os_log_s *)mDNSLogCategory_Default;
        int v65 = "SetRData: Malformed NAPTR service";
        goto LABEL_330;
      }

      uint64_t v40 = &v39[*v39];
      int v41 = (char *)(v40 + 1);
      if ((unint64_t)(v40 + 1) >= a3)
      {
        if (mDNS_LoggingEnabled != 1) {
          return 0LL;
        }
        uint64_t v64 = (os_log_s *)mDNSLogCategory_Default;
        int v65 = "SetRData: Malformed NAPTR regexp";
        goto LABEL_330;
      }

      if (!a1)
      {
        for (uint64_t i = v40 + 1; ; i += v125 + 1)
        {
          if (!i) {
            return 0LL;
          }
          int v125 = *i;
          if (!*i) {
            break;
          }
        }

        __int16 v127 = (_WORD)i - (_WORD)v41;
        if ((v127 & 0xFF00) != 0) {
          return 0LL;
        }
        int v128 = buf;
        memcpy(buf, v41, (unsigned __int16)(v127 + 1));
        do
        {
          __int16 v129 = *v128;
          if (!*v128)
          {
            int v46 = (_DWORD)v128 - buf + 1;
            goto LABEL_343;
          }

          v128 += v129 + 1;
        }

        while (v128 < v148 && v128 != 0LL);
        LOWORD(v46) = 257;
LABEL_343:
        uint64_t v43 = (unsigned __int8 *)&v41[(unsigned __int16)v46];
        goto LABEL_324;
      }

      char v42 = buf;
      uint64_t v43 = getDomainName(a1, v40 + 1, a3, buf);
      while (1)
      {
        char v44 = *v42;
        if (v44 > 0x3F)
        {
LABEL_76:
          LOWORD(v46) = 257;
          goto LABEL_324;
        }

        if (!*v42) {
          break;
        }
        v42 += v44 + 1;
        if (v42 >= v148 || v42 == 0LL) {
          goto LABEL_76;
        }
      }

      int v46 = (_DWORD)v42 - buf + 1;
LABEL_324:
      if (v43 == (unsigned __int8 *)v10)
      {
        *(_WORD *)(a4 + 12) = v46 + (_WORD)v41 - (_WORD)v11;
        if ((unsigned __int16)(v46 + (_WORD)v41 - (_WORD)v11) <= 0x2000u)
        {
          memcpy(v14, v11, ((_DWORD)v41 - (_DWORD)v11));
          uint64_t v33 = (char *)v14 + (int)v41 - (int)v11;
          int v32 = (unsigned __int16)v46;
          uint64_t v34 = buf;
          goto LABEL_45;
        }

        if (mDNS_LoggingEnabled != 1) {
          return 0LL;
        }
        uint64_t v64 = (os_log_s *)mDNSLogCategory_Default;
        __int16 v131 = v8;
        int v65 = "SetRData: Malformed NAPTR rdlength %d, rr->rdlength %d, bmaplen %d, name %##s";
      }

      else
      {
        if (mDNS_LoggingEnabled != 1) {
          return 0LL;
        }
        uint64_t v64 = (os_log_s *)mDNSLogCategory_Default;
        int v65 = "SetRData: Malformed NAPTR RDATA name";
      }

      goto LABEL_330;
    case 0x29:
      int v47 = *v13;
      *(_WORD *)(a4 + 12) = 0;
      int v48 = (char *)v14 + v47;
      while (1)
      {
        int v49 = v11 + 4;
        if ((unint64_t)(v11 + 4) > v10)
        {
          if (mDNS_LoggingEnabled != 1) {
            return 0LL;
          }
          uint64_t v64 = (os_log_s *)mDNSLogCategory_Default;
          int v65 = "SetRData: OPT RDATA ptr + 4 > end";
          goto LABEL_330;
        }

        int v50 = v11;
        uint64_t v51 = __rev16(*(unsigned __int16 *)v11);
        *(_WORD *)uint64_t v14 = v51;
        uint64_t v52 = v11[3];
        unsigned int v53 = v52 | ((unint64_t)v11[2] << 8);
        *((_WORD *)v14 + 1) = v53;
        unint64_t v11 = &v49[v53];
        if ((unint64_t)&v49[v53] > v10)
        {
          if (mDNS_LoggingEnabled != 1) {
            return 0LL;
          }
          uint64_t v64 = (os_log_s *)mDNSLogCategory_Default;
          int v65 = "SetRData: ptr + opt->optlen > end";
          goto LABEL_330;
        }

        if (v51 <= 3)
        {
          if (v51 != 1)
          {
            if (v51 != 2 || (_DWORD)v53 != 4) {
              goto LABEL_112;
            }
            int v55 = bswap32(*((_DWORD *)v50 + 1));
            if (v55 >= 0x1CAC08) {
              int v55 = 1879048;
            }
            *((_DWORD *)v14 + 1) = v55;
            goto LABEL_111;
          }

          if ((_DWORD)v53 == 18)
          {
            *((_WORD *)v14 + 2) = bswap32(*((unsigned __int16 *)v50 + 2)) >> 16;
            *((_WORD *)v14 + 3) = bswap32(*((unsigned __int16 *)v50 + 3)) >> 16;
            *((_WORD *)v14 + 4) = bswap32(*((unsigned __int16 *)v50 + 4)) >> 16;
            *(void *)((char *)v14 + 12) = *(void *)(v50 + 10);
            uint64_t v62 = bswap32(*(_DWORD *)(v50 + 18));
            if (v62 >= 0x1CAC08) {
              uint64_t v62 = 1879048;
            }
            *((_DWORD *)v14 + 5) = v62;
            goto LABEL_111;
          }
        }

        else
        {
          if (v51 == 4)
          {
            HIDWORD(v56) = v52;
            LODWORD(v56) = ((_DWORD)v53 << 16) - 0x80000;
            uint64_t v57 = (1 << (v56 >> 17)) & 0x69;
            *((_BYTE *)v14 + 4) = v50[4];
            *((_BYTE *)v14 + 5) = v50[5];
            unsigned __int16 v59 = *(_DWORD *)(v50 + 6);
            *((_WORD *)v14 + 5) = *((_WORD *)v50 + 5);
            *(_DWORD *)((char *)v14 + 6) = v59;
            uint64_t v60 = *((_WORD *)v50 + 5);
            *((_DWORD *)v14 + 3) = *(_DWORD *)(v50 + 6);
            *((_WORD *)v14 + 8) = v60;
            *(_DWORD *)((char *)v14 + 18) = 0;
            *((_WORD *)v14 + 11) = 0;
            if (v53 >= 0xE)
            {
              __int128 v61 = *((_DWORD *)v50 + 3);
              *((_WORD *)v14 + 8) = *((_WORD *)v50 + 8);
              *((_DWORD *)v14 + 3) = v61;
              if ((_DWORD)v53 != 14) {
                memcpy((char *)v14 + 18, v50 + 18, (v53 - 14));
              }
            }

            goto LABEL_111;
          }

          if (v51 == 65001)
          {
            if ((_DWORD)v53 == 5)
            {
              *((_BYTE *)v14 + 4) = v50[4];
              *((_DWORD *)v14 + 2) = bswap32(*(_DWORD *)(v50 + 5));
            }

            else
            {
              *((_BYTE *)v14 + 4) = -1;
              *((_DWORD *)v14 + 2) = -1;
            }

            goto LABEL_111;
          }

          if (v51 == 65002 && (_DWORD)v53 == 10)
          {
            *((_DWORD *)v14 + 1) = bswap32(*((_DWORD *)v50 + 1));
            *((_DWORD *)v14 + 2) = bswap32(*((_DWORD *)v50 + 2));
            *((_WORD *)v14 + 6) = bswap32(*((unsigned __int16 *)v50 + 6)) >> 16;
LABEL_111:
            uint64_t v14 = (_OWORD *)((char *)v14 + 24);
          }
        }

LABEL_253:
      if (!v82) {
        goto LABEL_153;
      }
      goto LABEL_304;
    case 2:
      char v42 = gSensitiveLoggingEnabled;
      uint64_t v43 = (os_log_s *)mDNSLogCategory_D2D;
      if (mDNSLogCategory_D2D == mDNSLogCategory_State) {
        char v42 = 0;
      }
      if (a2)
      {
        if ((v42 & 1) == 0)
        {
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D, OS_LOG_TYPE_ERROR)) {
            goto LABEL_153;
          }
          *(_DWORD *)buf = 67109120;
          *(_DWORD *)&uint8_t buf[4] = a2;
          int v41 = "xD2DServiceResolved: Unexpected result - result: %d";
          __int16 v67 = buf;
          int v68 = v43;
          goto LABEL_151;
        }

        uint64_t v40 = mDNSLogCategory_D2D_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D_redacted, OS_LOG_TYPE_ERROR)) {
          goto LABEL_153;
        }
        *(_DWORD *)buf = 67109120;
        *(_DWORD *)&uint8_t buf[4] = a2;
        int v41 = "xD2DServiceResolved: Unexpected result - result: %d";
        goto LABEL_149;
      }

      if ((v42 & 1) != 0)
      {
        uint64_t v43 = (os_log_s *)mDNSLogCategory_D2D_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D_redacted, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_170;
        }
        *(_DWORD *)buf = 134217984;
        *(void *)&uint8_t buf[4] = a3;
      }

      else
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_170;
        }
        *(_DWORD *)buf = 134217984;
        *(void *)&uint8_t buf[4] = a3;
      }

      _os_log_impl( (void *)&_mh_execute_header,  v43,  OS_LOG_TYPE_DEFAULT,  "xD2DServiceResolved: Starting up PAN connection - instanceHandle: %p",  buf,  0xCu);
LABEL_170:
      if (&_D2DRetain) {
        D2DRetain(a3, a4);
      }
      goto LABEL_153;
    case 3:
      char v44 = gSensitiveLoggingEnabled;
      uint64_t v40 = mDNSLogCategory_D2D;
      if (mDNSLogCategory_D2D == mDNSLogCategory_State) {
        char v44 = 0;
      }
      if (a2)
      {
        if ((v44 & 1) != 0)
        {
          uint64_t v40 = mDNSLogCategory_D2D_redacted;
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D_redacted, OS_LOG_TYPE_ERROR)) {
            goto LABEL_153;
          }
          *(_DWORD *)buf = 67109120;
          *(_DWORD *)&uint8_t buf[4] = a2;
          int v41 = "xD2DRetainHappened: Unexpected result - result: %d";
        }

        else
        {
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D, OS_LOG_TYPE_ERROR)) {
            goto LABEL_153;
          }
          *(_DWORD *)buf = 67109120;
          *(_DWORD *)&uint8_t buf[4] = a2;
          int v41 = "xD2DRetainHappened: Unexpected result - result: %d";
        }

        goto LABEL_149;
      }

      if ((v44 & 1) != 0)
      {
        uint64_t v40 = mDNSLogCategory_D2D_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D_redacted, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_153;
        }
        *(_DWORD *)buf = 134217984;
        *(void *)&uint8_t buf[4] = a3;
        int v41 = "xD2DRetainHappened: Opening up PAN connection - instanceHandle: %p";
      }

      else
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_153;
        }
        *(_DWORD *)buf = 134217984;
        *(void *)&uint8_t buf[4] = a3;
        int v41 = "xD2DRetainHappened: Opening up PAN connection - instanceHandle: %p";
      }

      goto LABEL_176;
    case 4:
      char v45 = gSensitiveLoggingEnabled;
      uint64_t v40 = mDNSLogCategory_D2D;
      if (mDNSLogCategory_D2D == mDNSLogCategory_State) {
        char v45 = 0;
      }
      if (a2)
      {
        if ((v45 & 1) != 0)
        {
          uint64_t v40 = mDNSLogCategory_D2D_redacted;
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D_redacted, OS_LOG_TYPE_ERROR)) {
            goto LABEL_153;
          }
          *(_DWORD *)buf = 67109120;
          *(_DWORD *)&uint8_t buf[4] = a2;
          int v41 = "xD2DReleaseHappened: Unexpected result - result: %d";
        }

        else
        {
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D, OS_LOG_TYPE_ERROR)) {
            goto LABEL_153;
          }
          *(_DWORD *)buf = 67109120;
          *(_DWORD *)&uint8_t buf[4] = a2;
          int v41 = "xD2DReleaseHappened: Unexpected result - result: %d";
        }

        goto LABEL_149;
      }

      if ((v45 & 1) != 0)
      {
        uint64_t v40 = mDNSLogCategory_D2D_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D_redacted, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_153;
        }
        *(_DWORD *)buf = 134217984;
        *(void *)&uint8_t buf[4] = a3;
        int v41 = "xD2DReleaseHappened: Closing PAN connection - instanceHandle: %p";
      }

      else
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_153;
        }
        *(_DWORD *)buf = 134217984;
        *(void *)&uint8_t buf[4] = a3;
        int v41 = "xD2DReleaseHappened: Closing PAN connection - instanceHandle: %p";
      }

LABEL_134:
    mDNS_PurgeCacheResourceRecord((unsigned int *)mDNSStorage, v54);
LABEL_135:
    uint64_t v54 = *(void *)v54;
    if (!v54) {
      goto LABEL_136;
    }
  }

  int v55 = (os_log_s *)mDNSLogCategory_D2D_redacted;
  if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D_redacted, OS_LOG_TYPE_INFO)) {
    goto LABEL_134;
  }
  uint64_t v57 = *(void *)(v54 + 40);
  if (v57)
  {
    uint64_t v62 = *(_BYTE **)(v54 + 40);
    if (v57 == -256) {
      goto LABEL_120;
    }
LABEL_117:
    unsigned __int16 v63 = 257;
    if ((unint64_t)v62 < v57 + 256 && v62)
    {
      while (1)
      {
        uint64_t v64 = *v62;
        if (v64 > 0x3F)
        {
LABEL_128:
          unsigned __int16 v63 = 257;
          goto LABEL_132;
        }

        if (!*v62) {
          break;
        }
        v62 += v64 + 1;
        if (v57 != -256) {
          goto LABEL_117;
        }
LABEL_120:
        if (!v62) {
          goto LABEL_128;
        }
      }

      unsigned __int16 v63 = (_WORD)v62 - v57 + 1;
    }

xpc_object_t mrc_xpc_create_reply(void *a1, int a2, void *a3)
{
  xpc_object_t reply = xpc_dictionary_create_reply(a1);
  if (reply)
  {
    uint64_t uint64 = xpc_dictionary_get_uint64(a1, "id");
    xpc_dictionary_set_uint64(reply, "id", uint64);
    xpc_dictionary_set_int64(reply, "error", a2);
    if (a3) {
      xpc_dictionary_set_value(reply, "result", a3);
    }
  }

  return reply;
}

void *mrc_xpc_dns_proxy_params_get_output_interface(void *a1, BOOL *a2)
{
  BOOL v9 = 0;
  xpc_object_t value = xpc_dictionary_get_value(a1, "output_interface");
  uint64_limited = _mdns_xpc_object_get_uint64_limited(value, 0xFFFFFFFFuLL, &v9);
  if (a2)
  {
    if (v9)
    {
      BOOL v6 = 1;
    }

    else
    {
      xpc_object_t v7 = xpc_dictionary_get_value(a1, "output_interface");
      BOOL v6 = v9;
      if (!v7) {
        BOOL v6 = 1;
      }
    }

    *a2 = v6;
  }

  return uint64_limited;
}

const char *mrc_xpc_dns_proxy_params_get_nat64_prefix(void *a1, void *a2)
{
  BOOL v8 = 0;
  xpc_object_t value = xpc_dictionary_get_value(a1, "nat64_prefix.bit_len");
  uint64_limited = _mdns_xpc_object_get_uint64_limited(value, 0xFFFFFFFFFFFFFFFFLL, &v8);
  uint64_t result = 0LL;
  if (!uint64_limited)
  {
    uint64_t result = "";
    if (!a2) {
      return result;
    }
    goto LABEL_9;
  }

  size_t v7 = 0LL;
  uint64_t result = (const char *)xpc_dictionary_get_data(a1, "nat64_prefix.bits", &v7);
  if (a2) {
LABEL_9:
  }
    *a2 = uint64_limited;
  return result;
}

BOOL mrc_xpc_dns_proxy_params_get_force_aaaa_synthesis(void *a1, BOOL *a2)
{
  xpc_object_t object = _mdns_xpc_dictionary_get_object(a1, "force_aaaa_synth", (const _xpc_type_s *)&_xpc_type_BOOL);
  char v5 = object;
  if (a2)
  {
    if (object) {
      BOOL v6 = 1;
    }
    else {
      BOOL v6 = xpc_dictionary_get_value(a1, "force_aaaa_synth") == 0LL;
    }
    *a2 = v6;
  }

  return v5 == &_xpc_BOOL_true;
}

uint64_t mrc_xpc_dns_service_registration_params_get_definition_type(void *a1, BOOL *a2)
{
  BOOL v7 = 0;
  xpc_object_t value = xpc_dictionary_get_value(a1, "definition_type");
  uint64_t result = _mdns_xpc_object_get_uint64_limited(value, 0xFFuLL, &v7);
  if (a2)
  {
    BOOL v6 = v7 && (result - 1) < 2;
    *a2 = v6;
  }

  return result;
}

void *mrc_xpc_discovery_proxy_params_get_interface(void *a1, BOOL *a2)
{
  xpc_object_t value = xpc_dictionary_get_value(a1, "interface");
  return _mdns_xpc_object_get_uint64_limited(value, 0xFFFFFFFFuLL, a2);
}

uint64_t mrc_xpc_record_cache_flush_params_get_key_tag(void *a1, BOOL *a2)
{
  xpc_object_t value = xpc_dictionary_get_value(a1, "key_tag");
  return (unsigned __int16)_mdns_xpc_object_get_uint64_limited(value, 0xFFFFuLL, a2);
}

void *_mdns_dns_push_service_definition_copy_description(uint64_t a1, int a2, int a3)
{
  uint64_t v19 = 0LL;
  uint64_t v20 = &v19;
  uint64_t v21 = 0x2000000000LL;
  uint64_t v22 = 0LL;
  BOOL v6 = (void *)mdns_string_builder_create();
  if (!v6)
  {
    BOOL v8 = 0LL;
    goto LABEL_28;
  }

  BOOL v7 = v6;
  if (a2
    && mdns_string_builder_append_formatted( v6,  "<%s: %p>: ",  *(const char **)(*(void *)(a1 + 16) + 8LL),  (const void *)a1))
  {
    goto LABEL_4;
  }

  BOOL v9 = *(const char **)(a1 + 64);
  if (!v9) {
    BOOL v9 = "";
  }
  if (mdns_string_builder_append_formatted(v7, "interface: %s/%u", v9, *(_DWORD *)(a1 + 72))
    || mdns_string_builder_append_formatted(v7, ", hostname: "))
  {
LABEL_4:
    BOOL v8 = 0LL;
  }

  else
  {
    uint64_t v10 = *(void *)(a1 + 32);
    if (v10)
    {
      if (a3)
      {
        unint64_t v11 = (void *)(v10 + 16);
        while (1)
        {
          unint64_t v11 = (void *)*v11;
          if (!v11) {
            break;
          }
          uint64_t v12 = (uint64_t (*)(void))v11[3];
          if (v12)
          {
            uint64_t v13 = (char *)v12();
            goto LABEL_18;
          }
        }

        uint64_t v13 = 0LL;
LABEL_18:
        uint64_t v14 = "«REDACTED»";
        if (v13) {
          uint64_t v14 = v13;
        }
      }

      else
      {
        uint64_t v13 = 0LL;
        uint64_t v14 = *(const char **)(v10 + 40);
      }
    }

    else
    {
      uint64_t v13 = 0LL;
      uint64_t v14 = "«NO HOSTNAME»";
    }

    v20[3] = (uint64_t)"";
    uint64_t v15 = *(const __CFSet **)(a1 + 48);
    v17[0] = _NSConcreteStackBlock;
    v17[1] = 0x40000000LL;
    v17[2] = ___mdns_dns_push_service_definition_copy_description_block_invoke;
    v17[3] = &unk_100139AD0;
    char v18 = a3;
    v17[4] = &v19;
    v17[5] = v7;
    if (!mdns_cfset_enumerate(v15, (uint64_t)v17) || mdns_string_builder_append_formatted(v7, "}"))
    {
LABEL_29:
      BOOL v8 = 0LL;
      if (!v13) {
        goto LABEL_27;
      }
      goto LABEL_26;
    }

    BOOL v8 = mdns_string_builder_copy_string((uint64_t)v7);
    if (v13) {
LABEL_26:
    }
      free(v13);
  }

void _mdns_dns_push_service_definition_finalize(void *a1)
{
  char v2 = (void *)a1[3];
  if (v2)
  {
    os_release(v2);
    a1[3] = 0LL;
  }

  uint64_t v3 = (void *)a1[4];
  if (v3)
  {
    os_release(v3);
    a1[4] = 0LL;
  }

  int v4 = (const void *)a1[5];
  if (v4)
  {
    CFRelease(v4);
    a1[5] = 0LL;
  }

  char v5 = (const void *)a1[6];
  if (v5)
  {
    CFRelease(v5);
    a1[6] = 0LL;
  }

  BOOL v6 = (const void *)a1[7];
  if (v6)
  {
    CFRelease(v6);
    a1[7] = 0LL;
  }

  BOOL v7 = (void *)a1[8];
  if (v7)
  {
    free(v7);
    a1[8] = 0LL;
  }

BOOL ___mdns_dns_push_service_definition_copy_description_block_invoke(uint64_t a1, uint64_t a2)
{
  if (*(_BYTE *)(a1 + 48))
  {
    uint64_t v3 = (void *)(a2 + 16);
    while (1)
    {
      uint64_t v3 = (void *)*v3;
      if (!v3) {
        break;
      }
      int v4 = (uint64_t (*)(uint64_t, void, uint64_t))v3[3];
      if (v4)
      {
        char v5 = (char *)v4(a2, 0LL, 1LL);
        goto LABEL_8;
      }
    }

    char v5 = 0LL;
LABEL_8:
    BOOL v6 = "«REDACTED»";
    if (v5) {
      BOOL v6 = v5;
    }
  }

  else
  {
    char v5 = 0LL;
    BOOL v6 = *(const char **)(a2 + 40);
  }

  int appended = mdns_string_builder_append_formatted( *(void **)(a1 + 40),  "%s%s",  *(const char **)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL),  v6);
  if (v5) {
    free(v5);
  }
  BOOL result = appended == 0;
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = ", ";
  return result;
}

void *mdns_dns_push_service_definition_create()
{
  uint64_t v0 = _os_object_alloc(&OBJC_CLASS___OS_mdns_dns_push_service_definition, 88LL);
  int v1 = (void *)v0;
  if (v0)
  {
    char v2 = &_mdns_dns_push_service_definition_kind;
    *(void *)(v0 + 16) = &_mdns_dns_push_service_definition_kind;
    do
    {
      uint64_t v3 = (void (*)(void *))v2[2];
      if (v3) {
        v3(v1);
      }
      char v2 = (_UNKNOWN **)*v2;
    }

    while (v2);
    CFMutableArrayRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0LL, (const CFArrayCallBacks *)&mdns_cfarray_callbacks);
    v1[5] = Mutable;
    if (!Mutable
      || (CFMutableSetRef v5 = CFSetCreateMutable(kCFAllocatorDefault, 0LL, (const CFSetCallBacks *)&mdns_domain_name_cf_set_callbacks),
          (v1[6] = v5) == 0LL)
      || (CFMutableArrayRef v6 = CFArrayCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeArrayCallBacks), (v1[7] = v6) == 0LL))
    {
      os_release(v1);
      return 0LL;
    }
  }

  return v1;
}

uint64_t mdns_dns_push_service_definition_create_from_xpc_dictionary(void *a1, int *a2)
{
  int v49 = 0;
  int v4 = mdns_dns_push_service_definition_create();
  uint64_t v5 = (uint64_t)v4;
  if (!v4)
  {
    int v8 = -6729;
    int v49 = -6729;
    if (!a2) {
      goto LABEL_45;
    }
LABEL_44:
    *a2 = v8;
    goto LABEL_45;
  }

  string = (char *)xpc_dictionary_get_string(a1, "srv_name");
  if (string)
  {
    BOOL v7 = mdns_domain_name_create(string, &v49);
    int v8 = v49;
    if (v49) {
      goto LABEL_43;
    }
    BOOL v9 = v7;
    mdns_dns_push_service_definition_set_srv_name(v5, v7);
    if (v9) {
      os_release(v9);
    }
  }

  xpc_object_t optional_array = mdns_xpc_dictionary_get_optional_array(a1, "addresses");
  if (optional_array)
  {
    unint64_t v11 = optional_array;
    size_t count = xpc_array_get_count(optional_array);
    if (count)
    {
      size_t v13 = count;
      size_t v14 = 0LL;
      do
      {
        uint64_t v15 = (char *)xpc_array_get_string(v11, v14);
        if (!v15) {
          goto LABEL_41;
        }
        uint64_t v16 = (void *)mdns_address_create_from_ip_address_string(v15);
        if (!v16) {
          goto LABEL_41;
        }
        uint64_t v17 = v16;
        CFArrayAppendValue(*(CFMutableArrayRef *)(v5 + 40), v16);
        os_release(v17);
      }

      while (v13 != ++v14);
    }
  }

  xpc_object_t v18 = mdns_xpc_dictionary_get_optional_array(a1, "domains");
  if (v18)
  {
    uint64_t v19 = v18;
    size_t v20 = xpc_array_get_count(v18);
    if (v20)
    {
      size_t v21 = v20;
      size_t v22 = 0LL;
      do
      {
        uint64_t v23 = (char *)xpc_array_get_string(v19, v22);
        if (!v23) {
          goto LABEL_41;
        }
        uint64_t v24 = mdns_domain_name_create(v23, &v49);
        int v8 = v49;
        if (v49) {
          goto LABEL_43;
        }
        unint64_t v25 = v24;
        CFSetAddValue(*(CFMutableSetRef *)(v5 + 48), v24);
        if (v25) {
          os_release(v25);
        }
      }

      while (v21 != ++v22);
    }
  }

  xpc_object_t v26 = mdns_xpc_dictionary_get_optional_array(a1, "certificates");
  if (v26)
  {
    int v27 = v26;
    size_t v28 = xpc_array_get_count(v26);
    if (v28)
    {
      size_t v29 = v28;
      size_t v30 = 0LL;
      do
      {
        size_t length = 0LL;
        data = (const UInt8 *)xpc_array_get_data(v27, v30, &length);
        if (!data) {
          goto LABEL_41;
        }
        CFDataRef v32 = CFDataCreate(kCFAllocatorDefault, data, length);
        if (!v32)
        {
          int v8 = -6729;
          goto LABEL_42;
        }

        CFDataRef v33 = v32;
        CFArrayAppendValue(*(CFMutableArrayRef *)(v5 + 56), v32);
        CFRelease(v33);
      }

      while (v29 != ++v30);
    }
  }

  BOOL v47 = 0;
  xpc_object_t value = xpc_dictionary_get_value(a1, "ifindex");
  unsigned int uint64_limited = _mdns_xpc_object_get_uint64_limited(value, 0xFFFFFFFFuLL, &v47);
  if (!v47) {
    goto LABEL_41;
  }
  unsigned int v36 = uint64_limited;
  BOOL v47 = 0;
  BOOL v50 = 0;
  xpc_object_t v37 = xpc_dictionary_get_value(a1, "interface_scope");
  unsigned int v38 = _mdns_xpc_object_get_uint64_limited(v37, 0xFFuLL, &v50);
  BOOL v39 = !v50 || v38 >= 3;
  BOOL v40 = !v39;
  BOOL v47 = v40;
  if (v39) {
    goto LABEL_41;
  }
  mdns_dns_push_service_definition_set_interface_index(v5, v36, v38);
  BOOL v47 = 0;
  xpc_object_t v41 = xpc_dictionary_get_value(a1, "port");
  unsigned __int16 v42 = (unsigned __int16)_mdns_xpc_object_get_uint64_limited(v41, 0xFFFFuLL, &v47);
  if (!v47) {
    goto LABEL_41;
  }
  *(_WORD *)(v5 + 76) = v42;
  BOOL v47 = 0;
  xpc_object_t object = _mdns_xpc_dictionary_get_object(a1, "local_purview", (const _xpc_type_s *)&_xpc_type_BOOL);
  BOOL v47 = object != 0LL;
  if (!object
    || (*(_BYTE *)(v5 + 79) = object == &_xpc_BOOL_true,
        BOOL v47 = 0,
        xpc_object_t v44 = _mdns_xpc_dictionary_get_object(a1, "mdns_alternative", (const _xpc_type_s *)&_xpc_type_BOOL),
        BOOL v47 = v44 != 0LL,
        !v44))
  {
LABEL_41:
    int v8 = -6705;
LABEL_42:
    int v49 = v8;
LABEL_43:
    int v4 = (void *)v5;
    uint64_t v5 = 0LL;
    if (!a2) {
      goto LABEL_45;
    }
    goto LABEL_44;
  }

  char v45 = v44;
  int v8 = 0;
  int v4 = 0LL;
  *(_BYTE *)(v5 + 80) = v45 == &_xpc_BOOL_true;
  int v49 = 0;
  if (a2) {
    goto LABEL_44;
  }
LABEL_45:
  if (v4) {
    os_release(v4);
  }
  return v5;
}

void mdns_dns_push_service_definition_set_srv_name(uint64_t a1, void *object)
{
  if (object) {
    os_retain(object);
  }
  int v4 = *(void **)(a1 + 24);
  if (v4) {
    os_release(v4);
  }
  *(void *)(a1 + 24) = object;
}

void mdns_dns_push_service_definition_set_interface_index(uint64_t a1, unsigned int a2, char a3)
{
  *(_BYTE *)(a1 + 78) = a3;
  if (*(_DWORD *)(a1 + 72) != a2)
  {
    *(_DWORD *)(a1 + 72) = a2;
    int v4 = *(void **)(a1 + 64);
    if (v4)
    {
      free(v4);
      *(void *)(a1 + 64) = 0LL;
      a2 = *(_DWORD *)(a1 + 72);
    }
  }

  if (a2)
  {
    if (!*(void *)(a1 + 64)) {
      *(void *)(a1 + 64) = mdns_system_interface_index_to_name(a2);
    }
  }

  else
  {
    *(_BYTE *)(a1 + 78) = 0;
  }

void *_dnssec_obj_rr_ds_copy_rdata_rfc_description(uint64_t a1, int *a2)
{
  int v4 = (void *)snprintf( 0LL,  0LL,  "%u %u %u ",  __rev16(**(unsigned __int16 **)(a1 + 24)),  *(unsigned __int8 *)(*(void *)(a1 + 24) + 2LL),  *(unsigned __int8 *)(*(void *)(a1 + 24) + 3LL));
  uint64_t v5 = (char *)v4 + 2 * rdata_parser_ds_get_digest_length(*(unsigned __int16 *)(a1 + 36));
  size_t v6 = (size_t)(v5 + 1);
  if (v5 == (char *)-1LL || (BOOL v7 = (char *)calloc(1uLL, (size_t)(v5 + 1))) == 0LL)
  {
    __break(1u);
  }

  else
  {
    int v4 = v7;
    int v8 = snprintf( v7,  v6,  "%u %u %u ",  __rev16(**(unsigned __int16 **)(a1 + 24)),  *(unsigned __int8 *)(*(void *)(a1 + 24) + 2LL),  *(unsigned __int8 *)(*(void *)(a1 + 24) + 3LL));
    if (v8 >= 1)
    {
      BOOL v9 = (char *)v4 + v6;
      uint64_t v10 = (char *)v4 + v8;
      unint64_t v11 = (unsigned __int8 *)(*(void *)(a1 + 24) + 4LL);
      digest_size_t length = rdata_parser_ds_get_digest_length(*(unsigned __int16 *)(a1 + 36));
      size_t v13 = put_hex_from_bytes(v11, digest_length, v10, v9 - v10);
      BOOL v14 = v13 == v10;
      if (v13 == v10) {
        int v15 = -6751;
      }
      else {
        int v15 = 0;
      }
      if (!a2) {
        goto LABEL_9;
      }
      goto LABEL_8;
    }
  }

  int v15 = -6700;
  BOOL v14 = 1;
  if (a2) {
LABEL_8:
  }
    *a2 = v15;
LABEL_9:
  if (v14)
  {
    free(v4);
    return 0LL;
  }

  return v4;
}

void *dnssec_obj_rr_ds_create( unsigned __int8 *a1, __int16 a2, const void *a3, unsigned int a4, int a5, int *a6)
{
  int v19 = 0;
  if (a4 <= 4)
  {
    size_t v6 = 0LL;
    uint64_t v17 = 0LL;
    int v14 = -6705;
    int v19 = -6705;
  }

  else
  {
    size_t v13 = calloc(1uLL, 0x50uLL);
    if (v13)
    {
      size_t v6 = v13;
      int v15 = &_dnssec_obj_rr_ds_kind;
      v13[1] = &_dnssec_obj_rr_ds_kind;
      do
      {
        uint64_t v16 = (void (*)(void *))v15[2];
        if (v16) {
          v16(v6);
        }
        int v15 = (_UNKNOWN **)*v15;
      }

      while (v15);
      ++*(_DWORD *)v6;
      dnssec_obj_rr_init_fields( (uint64_t)v6,  a1,  43,  a2,  a3,  a4,  a5,  (uint64_t)_dnssec_obj_rr_ds_copy_rdata_rfc_description,  &v19);
      int v14 = v19;
      if (!v19)
      {
        ++*(_DWORD *)v6;
        int v19 = 0;
        uint64_t v17 = v6;
        goto LABEL_9;
      }
    }

    else
    {
      __break(1u);
    }

    uint64_t v17 = 0LL;
  }

uint64_t dnssec_obj_rr_ds_validates_dnskey(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  int v4 = *(unsigned __int16 **)(a1 + 24);
  if (*(unsigned __int16 *)(a2 + 80) != bswap32(*v4) >> 16)
  {
    uint64_t result = 0LL;
    int v6 = -88989;
    goto LABEL_33;
  }

  int v5 = *((unsigned __int8 *)v4 + 2);
  int v6 = -88890;
  if ((v5 - 5) > 0xB || ((0xD2uLL >> (v5 - 5)) & 1) != 0)
  {
LABEL_32:
    uint64_t result = 0LL;
LABEL_33:
    int v23 = v6;
    goto LABEL_34;
  }

  unsigned int v7 = *((unsigned __int8 *)v4 + 3);
  BOOL v8 = v7 > 4;
  int v9 = (1 << v7) & 0x16;
  if (v8 || v9 == 0)
  {
    int v6 = -88988;
    goto LABEL_32;
  }

  int v23 = 0;
  size_t v13 = *(_BYTE **)(a2 + 24);
  uint64_t result = dnssec_obj_rr_dnskey_is_valid_for_dnssec(v13, &v23);
  if (!(_DWORD)result) {
    goto LABEL_34;
  }
  if (v5 != v13[3])
  {
    uint64_t result = 0LL;
    int v6 = -88990;
    goto LABEL_33;
  }

  if (ref_count_obj_compare(*(void *)(a1 + 16), *(void *)(a2 + 16), 1LL))
  {
    uint64_t result = 0LL;
    int v6 = -88991;
    goto LABEL_33;
  }

  memset(__s2, 0, sizeof(__s2));
  int v15 = -88988;
  if (*(unsigned __int8 *)(*(void *)(a1 + 24) + 3LL) - 1 > 3
    || *(_BYTE *)(*(void *)(a1 + 24) + 3LL) == 3
    || (int v16 = dword_100100890[(unsigned __int16)(*(unsigned __int8 *)(*(void *)(a1 + 24) + 3LL) - 1)],
        bzero(v25, 0x408uLL),
        uint64_t v17 = dword_1001008B0[v16 - 1],
        int v15 = -6700,
        CCDigestInit(v17, v25)))
  {
    uint64_t result = 0LL;
    int v23 = v15;
    goto LABEL_34;
  }

  int v18 = CCDigestUpdate(v25, *(void *)(*(void *)(a2 + 16) + 16LL), *(void *)(*(void *)(a2 + 16) + 24LL));
  if (v18) {
    int v19 = -6700;
  }
  else {
    int v19 = 0;
  }
  if (v18
    || ((int v20 = CCDigestUpdate(v25, *(void *)(a2 + 24), *(unsigned __int16 *)(a2 + 36))) != 0
      ? (int v19 = -6700)
      : (int v19 = 0),
        v20 || ((v21 = CCDigestFinal(v25, __s2)) != 0 ? (int v19 = -6700) : (int v19 = 0), v21)))
  {
    int v23 = v19;
    if (v19)
    {
      uint64_t result = 0LL;
      goto LABEL_34;
    }

    size_t OutputSize = 0LL;
  }

  else
  {
    size_t OutputSize = CCDigestGetOutputSize(v17);
    int v23 = 0;
  }

  if (OutputSize == rdata_parser_ds_get_digest_length(*(unsigned __int16 *)(a1 + 36))
    && !memcmp((const void *)(*(void *)(a1 + 24) + 4LL), __s2, OutputSize))
  {
    int v23 = 0;
    uint64_t result = 1LL;
  }

  else
  {
    uint64_t result = 0LL;
    int v23 = -88992;
  }

LABEL_34:
  if (a3) {
    *a3 = v23;
  }
  return result;
}

void *mdns_cf_callback_retain(int a1, void *object)
{
  return object;
}

void mdns_cf_callback_release(int a1, void *object)
{
}

const char *mdns_cf_callback_copy_description(uint64_t a1)
{
  return _mdns_obj_copy_description_as_cfstring(a1);
}

uint64_t mdns_cf_callback_equal(uint64_t a1, uint64_t a2)
{
  if (a1 == a2) {
    return 1LL;
  }
  uint64_t v2 = *(void *)(a1 + 16);
  else {
    return 0LL;
  }
}

BOOL mdns_cfarray_enumerate(const __CFArray *a1, uint64_t a2)
{
  CFIndex Count = CFArrayGetCount(a1);
  if (Count < 1)
  {
    return 1;
  }

  else
  {
    CFIndex v5 = Count;
    BOOL v6 = 0;
    for (i = 0LL; i != v5; BOOL v6 = i >= v5)
    {
      ValueAtIndex = CFArrayGetValueAtIndex(a1, i);
      ++i;
    }
  }

  return v6;
}

BOOL mdns_cfset_enumerate(const __CFSet *a1, uint64_t a2)
{
  CFIndex Count = CFSetGetCount(a1);
  if (Count < 1) {
    return 1LL;
  }
  CFIndex v5 = Count;
  __int128 v41 = 0u;
  __int128 v42 = 0u;
  __int128 v39 = 0u;
  __int128 v40 = 0u;
  __int128 v37 = 0u;
  __int128 v38 = 0u;
  __int128 v35 = 0u;
  __int128 v36 = 0u;
  __int128 v33 = 0u;
  __int128 v34 = 0u;
  __int128 v31 = 0u;
  __int128 v32 = 0u;
  __int128 v29 = 0u;
  __int128 v30 = 0u;
  __int128 v27 = 0u;
  __int128 v28 = 0u;
  __int128 v25 = 0u;
  __int128 v26 = 0u;
  __int128 v23 = 0u;
  __int128 v24 = 0u;
  __int128 v21 = 0u;
  __int128 v22 = 0u;
  __int128 v19 = 0u;
  __int128 v20 = 0u;
  __int128 v17 = 0u;
  __int128 v18 = 0u;
  __int128 v15 = 0u;
  __int128 v16 = 0u;
  __int128 v13 = 0u;
  __int128 v14 = 0u;
  *(_OWORD *)values = 0u;
  __int128 v12 = 0u;
  if ((unint64_t)Count <= 0x40)
  {
    BOOL v6 = values;
    CFSetGetValues(a1, (const void **)values);
    while (((*(uint64_t (**)(uint64_t, void *))(a2 + 16))(a2, *v6) & 1) != 0)
    {
      ++v6;
      if (!--v5) {
        return 1LL;
      }
    }

    return 0LL;
  }

  uint64_t v8 = a2;
  char v9 = 1;
  memset(v10, 0, sizeof(v10));
  CFSetApplyFunction(a1, (CFSetApplierFunction)_mdns_cf_applier_function, &v8);
  return v9 != 0;
}

void _mdns_cf_applier_function(uint64_t a1, _BYTE *a2)
{
  if (a2[8]) {
    a2[8] = (*(uint64_t (**)(void))(*(void *)a2 + 16LL))();
  }
}

void mdns_cfbag_enumerate(const __CFBag *a1, uint64_t a2)
{
  CFIndex Count = CFBagGetCount(a1);
  if (Count >= 1)
  {
    CFIndex v5 = Count;
    __int128 v40 = 0u;
    __int128 v41 = 0u;
    __int128 v38 = 0u;
    __int128 v39 = 0u;
    __int128 v36 = 0u;
    __int128 v37 = 0u;
    __int128 v34 = 0u;
    __int128 v35 = 0u;
    __int128 v32 = 0u;
    __int128 v33 = 0u;
    __int128 v30 = 0u;
    __int128 v31 = 0u;
    __int128 v28 = 0u;
    __int128 v29 = 0u;
    __int128 v26 = 0u;
    __int128 v27 = 0u;
    __int128 v24 = 0u;
    __int128 v25 = 0u;
    __int128 v22 = 0u;
    __int128 v23 = 0u;
    __int128 v20 = 0u;
    __int128 v21 = 0u;
    __int128 v18 = 0u;
    __int128 v19 = 0u;
    __int128 v16 = 0u;
    __int128 v17 = 0u;
    __int128 v14 = 0u;
    __int128 v15 = 0u;
    __int128 v12 = 0u;
    __int128 v13 = 0u;
    *(_OWORD *)values = 0u;
    __int128 v11 = 0u;
    if ((unint64_t)Count > 0x40)
    {
      uint64_t v7 = a2;
      char v8 = 1;
      memset(v9, 0, sizeof(v9));
      CFBagApplyFunction(a1, (CFBagApplierFunction)_mdns_cf_applier_function, &v7);
    }

    else
    {
      BOOL v6 = values;
      CFBagGetValues(a1, (const void **)values);
      do
      {
        ++v6;
        --v5;
      }

      while (v5);
    }
  }

void mdns_cfdictionary_apply(const __CFDictionary *a1, uint64_t a2)
{
  CFIndex Count = CFDictionaryGetCount(a1);
  if (Count >= 1)
  {
    CFIndex v5 = Count;
    __int128 v73 = 0u;
    __int128 v74 = 0u;
    __int128 v71 = 0u;
    __int128 v72 = 0u;
    __int128 v69 = 0u;
    __int128 v70 = 0u;
    __int128 v67 = 0u;
    __int128 v68 = 0u;
    __int128 v65 = 0u;
    __int128 v66 = 0u;
    __int128 v63 = 0u;
    __int128 v64 = 0u;
    __int128 v61 = 0u;
    __int128 v62 = 0u;
    __int128 v59 = 0u;
    __int128 v60 = 0u;
    __int128 v57 = 0u;
    __int128 v58 = 0u;
    __int128 v55 = 0u;
    __int128 v56 = 0u;
    __int128 v53 = 0u;
    __int128 v54 = 0u;
    __int128 v51 = 0u;
    __int128 v52 = 0u;
    __int128 v49 = 0u;
    __int128 v50 = 0u;
    __int128 v47 = 0u;
    __int128 v48 = 0u;
    __int128 v45 = 0u;
    __int128 v46 = 0u;
    *(_OWORD *)keys = 0u;
    __int128 v44 = 0u;
    __int128 v41 = 0u;
    __int128 v42 = 0u;
    __int128 v39 = 0u;
    __int128 v40 = 0u;
    __int128 v37 = 0u;
    __int128 v38 = 0u;
    __int128 v35 = 0u;
    __int128 v36 = 0u;
    __int128 v33 = 0u;
    __int128 v34 = 0u;
    __int128 v31 = 0u;
    __int128 v32 = 0u;
    __int128 v29 = 0u;
    __int128 v30 = 0u;
    __int128 v27 = 0u;
    __int128 v28 = 0u;
    __int128 v25 = 0u;
    __int128 v26 = 0u;
    __int128 v23 = 0u;
    __int128 v24 = 0u;
    __int128 v21 = 0u;
    __int128 v22 = 0u;
    __int128 v19 = 0u;
    __int128 v20 = 0u;
    __int128 v17 = 0u;
    __int128 v18 = 0u;
    __int128 v15 = 0u;
    __int128 v16 = 0u;
    __int128 v13 = 0u;
    __int128 v14 = 0u;
    *(_OWORD *)values = 0u;
    __int128 v12 = 0u;
    if ((unint64_t)Count > 0x40)
    {
      uint64_t v8 = a2;
      char v9 = 1;
      memset(v10, 0, sizeof(v10));
      CFDictionaryApplyFunction(a1, (CFDictionaryApplierFunction)_mdns_cfdictionary_applier_function, &v8);
    }

    else
    {
      BOOL v6 = keys;
      uint64_t v7 = values;
      CFDictionaryGetKeysAndValues(a1, (const void **)keys, (const void **)values);
      do
      {
        ++v7;
        ++v6;
        --v5;
      }

      while (v5);
    }
  }

void _mdns_cfdictionary_applier_function(uint64_t a1, uint64_t a2, _BYTE *a3)
{
  if (a3[8]) {
    a3[8] = (*(uint64_t (**)(void))(*(void *)a3 + 16LL))();
  }
}

BOOL mdns_odoh_config_is_valid_inner(unsigned __int16 *a1, unint64_t a2)
{
  if (a1)
  {
    if (a2 > 0xB)
    {
      int v10 = *a1;
      if (v10 == 256 || v10 == 1791)
      {
        uint64_t v11 = bswap32(a1[1]) >> 16;
        if (v11 + 4 > a2)
        {
          if (_mdns_crypto_log_s_once != -1) {
            dispatch_once(&_mdns_crypto_log_s_once, &__block_literal_global_115);
          }
          uint64_t v12 = _mdns_crypto_log_s_log;
          BOOL result = os_log_type_enabled((os_log_t)_mdns_crypto_log_s_log, OS_LOG_TYPE_ERROR);
          if (result)
          {
            int v17 = 67109120;
            LODWORD(v18[0]) = v11;
            CFIndex v5 = "Config length field is too large: %hu";
            BOOL v6 = (os_log_s *)v12;
            uint32_t v7 = 8;
            goto LABEL_31;
          }

          return result;
        }

        if ((bswap32(a1[5]) >> 16) + 8LL != v11)
        {
          if (_mdns_crypto_log_s_once != -1) {
            dispatch_once(&_mdns_crypto_log_s_once, &__block_literal_global_115);
          }
          uint64_t v15 = _mdns_crypto_log_s_log;
          BOOL result = os_log_type_enabled((os_log_t)_mdns_crypto_log_s_log, OS_LOG_TYPE_ERROR);
          if (result)
          {
            uint64_t v16 = (bswap32(a1[5]) >> 16) + 8LL;
            int v17 = 67109376;
            LODWORD(v18[0]) = v11;
            WORD2(v18[0]) = 2048;
            *(void *)((char *)v18 + 6) = v16;
            CFIndex v5 = "Config length does not match: %hu != %zu";
            BOOL v6 = (os_log_s *)v15;
            uint32_t v7 = 18;
            goto LABEL_31;
          }

          return result;
        }

        if (a1[2] == 0x2000 && a1[3] == 256 && a1[4] == 256) {
          return 1LL;
        }
        if (_mdns_crypto_log_s_once != -1) {
          dispatch_once(&_mdns_crypto_log_s_once, &__block_literal_global_115);
        }
        __int128 v13 = (os_log_s *)_mdns_crypto_log_s_log;
        BOOL result = os_log_type_enabled((os_log_t)_mdns_crypto_log_s_log, OS_LOG_TYPE_INFO);
        if (!result) {
          return result;
        }
        LOWORD(v17) = 0;
        __int128 v14 = "Config details are not supported";
      }

      else
      {
        if (_mdns_crypto_log_s_once != -1) {
          dispatch_once(&_mdns_crypto_log_s_once, &__block_literal_global_115);
        }
        __int128 v13 = (os_log_s *)_mdns_crypto_log_s_log;
        BOOL result = os_log_type_enabled((os_log_t)_mdns_crypto_log_s_log, OS_LOG_TYPE_INFO);
        if (!result) {
          return result;
        }
        LOWORD(v17) = 0;
        __int128 v14 = "Config version is not supported";
      }

      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_INFO, v14, (uint8_t *)&v17, 2u);
      return 0LL;
    }

    if (_mdns_crypto_log_s_once != -1) {
      dispatch_once(&_mdns_crypto_log_s_once, &__block_literal_global_115);
    }
    uint64_t v3 = _mdns_crypto_log_s_log;
    BOOL result = os_log_type_enabled((os_log_t)_mdns_crypto_log_s_log, OS_LOG_TYPE_ERROR);
    if (result)
    {
      int v17 = 134217984;
      v18[0] = a2;
      CFIndex v5 = "Config length is too short: %zu";
      BOOL v6 = (os_log_s *)v3;
      uint32_t v7 = 12;
LABEL_31:
      _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, v5, (uint8_t *)&v17, v7);
      return 0LL;
    }
  }

  else
  {
    if (_mdns_crypto_log_s_once != -1) {
      dispatch_once(&_mdns_crypto_log_s_once, &__block_literal_global_115);
    }
    uint64_t v8 = _mdns_crypto_log_s_log;
    BOOL result = os_log_type_enabled((os_log_t)_mdns_crypto_log_s_log, OS_LOG_TYPE_ERROR);
    if (result)
    {
      LOWORD(v17) = 0;
      CFIndex v5 = "Config is NULL";
      BOOL v6 = (os_log_s *)v8;
      uint32_t v7 = 2;
      goto LABEL_31;
    }
  }

  return result;
}

uint64_t __mdns_encrypt_oblivious_request_block_invoke( uint64_t a1, int a2, uint64_t a3, void *__src, size_t __n)
{
  return 1LL;
}

void ___mdns_crypto_log_block_invoke(id a1)
{
  _mdns_crypto_log_s_log = (uint64_t)os_log_create("com.apple.mdns", "crypto");
}

dispatch_data_t mdns_decrypt_oblivious_response( dispatch_data_s *a1, uint64_t a2, uint64_t a3, const void *a4, size_t a5)
{
  if (!a2 || !a3 || !a4)
  {
    if (_mdns_crypto_log_s_once != -1) {
      dispatch_once(&_mdns_crypto_log_s_once, &__block_literal_global_115);
    }
    __int128 v29 = (os_log_s *)_mdns_crypto_log_s_log;
    if (!os_log_type_enabled((os_log_t)_mdns_crypto_log_s_log, OS_LOG_TYPE_ERROR)) {
      return 0LL;
    }
    *(_WORD *)buf = 0;
    __int128 v30 = "Parameters are invalid";
    goto LABEL_21;
  }

  uint64_t v9 = cchpke_params_x25519_AESGCM128_HKDF_SHA256();
  uint64_t v10 = cchpke_params_sizeof_kdf_hash();
  uint64_t v11 = cchpke_params_sizeof_aead_tag(v9);
  uint64_t v12 = cchpke_params_sizeof_aead_key(v9);
  unint64_t size = dispatch_data_get_size(a1);
  if (size <= v11 + 5)
  {
    if (_mdns_crypto_log_s_once == -1)
    {
LABEL_19:
      __int128 v29 = (os_log_s *)_mdns_crypto_log_s_log;
      if (!os_log_type_enabled((os_log_t)_mdns_crypto_log_s_log, OS_LOG_TYPE_ERROR)) {
        return 0LL;
      }
      *(_WORD *)buf = 0;
      __int128 v30 = "Invalid encrypted response length";
LABEL_21:
      _os_log_error_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_ERROR, v30, buf, 2u);
      return 0LL;
    }

uint64_t __mdns_decrypt_oblivious_response_block_invoke( uint64_t a1, int a2, uint64_t a3, void *__src, size_t __n)
{
  return 1LL;
}

void mdns_power_cancel_all_events(const void *a1)
{
  uint64_t v2 = IOPMCopyScheduledPowerEvents();
  if (v2)
  {
    uint64_t v3 = v2;
    CFIndex Count = CFArrayGetCount(v2);
    if (Count >= 1)
    {
      CFIndex v5 = Count;
      for (CFIndex i = 0LL; i != v5; ++i)
      {
        ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v3, i);
        Value = (const __CFString *)CFDictionaryGetValue(ValueAtIndex, @"scheduledby");
        if (Value)
        {
          uint64_t v9 = Value;
          if (CFEqual(Value, a1))
          {
            uint64_t v10 = (const __CFDate *)CFDictionaryGetValue(ValueAtIndex, @"time");
            uint64_t v11 = (const __CFString *)CFDictionaryGetValue(ValueAtIndex, @"eventtype");
            IOReturn v12 = IOPMCancelScheduledPowerEvent(v10, v9, v11);
            if (_mdns_power_log_s_once != -1) {
              dispatch_once(&_mdns_power_log_s_once, &__block_literal_global_151);
            }
            __int128 v13 = (os_log_s *)_mdns_power_log_s_log;
            if (v12) {
              os_log_type_t v14 = OS_LOG_TYPE_ERROR;
            }
            else {
              os_log_type_t v14 = OS_LOG_TYPE_INFO;
            }
            if (os_log_type_enabled((os_log_t)_mdns_power_log_s_log, v14))
            {
              *(_DWORD *)buf = 134218754;
              uint64_t v16 = v12;
              __int16 v17 = 2112;
              unsigned int v18 = v9;
              __int16 v19 = 2112;
              __int128 v20 = v11;
              __int16 v21 = 2112;
              unsigned int v22 = v10;
              _os_log_impl( (void *)&_mh_execute_header,  v13,  v14,  "IOPMCancelScheduledPowerEvent -- error: %{mdns:err}ld, id: %@, type: %@, time: %@",  buf,  0x2Au);
            }
          }
        }
      }
    }

    CFRelease(v3);
  }

void ___mdns_power_log_block_invoke(id a1)
{
  _mdns_power_log_s_log = (uint64_t)os_log_create("com.apple.mdns", "power");
}

uint64_t mdns_power_schedule_wake(int a1)
{
  int valuePtr = 0;
  CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
  CFDateRef v3 = CFDateCreate(kCFAllocatorDefault, Current + (double)a1);
  if (!v3) {
    return 4294960567LL;
  }
  CFDateRef v4 = v3;
  CFNumberRef v5 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &valuePtr);
  if (v5)
  {
    CFNumberRef v6 = v5;
    *(_OWORD *)keys = *(_OWORD *)&off_100139BB0;
    __int128 v20 = @"leeway";
    values[0] = @"com.apple.mDNSResponder";
    values[1] = v4;
    values[2] = v5;
    CFDictionaryRef v7 = CFDictionaryCreate( kCFAllocatorDefault,  (const void **)keys,  (const void **)values,  3LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
    if (v7)
    {
      CFDictionaryRef v8 = v7;
      uint64_t v9 = IOPMRequestSysWake();
      if (_mdns_power_log_s_once != -1) {
        dispatch_once(&_mdns_power_log_s_once, &__block_literal_global_151);
      }
      uint64_t v10 = (os_log_s *)_mdns_power_log_s_log;
      if ((_DWORD)v9) {
        os_log_type_t v11 = OS_LOG_TYPE_ERROR;
      }
      else {
        os_log_type_t v11 = OS_LOG_TYPE_INFO;
      }
      if (os_log_type_enabled((os_log_t)_mdns_power_log_s_log, v11))
      {
        *(_DWORD *)buf = 134218242;
        uint64_t v15 = (int)v9;
        __int16 v16 = 2112;
        CFDictionaryRef v17 = v8;
        _os_log_impl( (void *)&_mh_execute_header,  v10,  v11,  "IOPMRequestSysWake -- error: %{mdns:err}ld, request: %@",  buf,  0x16u);
      }

      CFRelease(v8);
    }

    else
    {
      uint64_t v9 = 4294960567LL;
    }

    CFRelease(v4);
  }

  else
  {
    uint64_t v9 = 4294960567LL;
    CFNumberRef v6 = v4;
  }

  CFRelease(v6);
  return v9;
}

char *_mdns_resource_record_copy_description( uint64_t a1, int a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  __int128 v48 = 0u;
  __int128 v49 = 0u;
  __int128 v46 = 0u;
  __int128 v47 = 0u;
  __int128 v44 = 0u;
  __int128 v45 = 0u;
  __int128 v42 = 0u;
  __int128 v43 = 0u;
  __int128 v40 = 0u;
  __int128 v41 = 0u;
  __int128 v38 = 0u;
  __int128 v39 = 0u;
  __int128 v36 = 0u;
  __int128 v37 = 0u;
  __int128 v34 = 0u;
  __int128 v35 = 0u;
  __int128 v32 = 0u;
  __int128 v33 = 0u;
  __int128 v30 = 0u;
  __int128 v31 = 0u;
  __int128 v28 = 0u;
  __int128 v29 = 0u;
  __int128 v26 = 0u;
  __int128 v27 = 0u;
  __int128 v24 = 0u;
  __int128 v25 = 0u;
  __int128 v22 = 0u;
  __int128 v23 = 0u;
  __int128 v20 = 0u;
  __int128 v21 = 0u;
  *(_OWORD *)__s1 = 0u;
  __int128 v19 = 0u;
  unint64_t v16 = 0LL;
  uint64_t v17 = 0LL;
  if (v16 > 0x1FF)
  {
    uint64_t v12 = v16 + 1;
    if (v16 == -1LL) {
      goto LABEL_9;
    }
    __int128 v13 = (char *)malloc(v16 + 1);
    if (!v13) {
      goto LABEL_9;
    }
    CFDictionaryRef v8 = v13;
    if (_mdns_resource_record_copy_description_bytes(a1, a2, a3, (uint64_t)v13, v12, 0LL, 0LL, v14))
    {
LABEL_10:
      free(v8);
      return 0LL;
    }
  }

  else
  {
    CFDictionaryRef v8 = strdup(__s1);
    if (!v8)
    {
LABEL_9:
      __break(1u);
      goto LABEL_10;
    }
  }

  return v8;
}

void _mdns_resource_record_finalize(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 24);
  if (v2)
  {
    os_release(v2);
    *(void *)(a1 + 24) = 0LL;
  }

  CFDateRef v3 = *(void **)(a1 + 32);
  if (v3)
  {
    free(v3);
    *(void *)(a1 + 32) = 0LL;
  }

uint64_t _mdns_resource_record_copy_description_bytes( uint64_t a1, int a2, int a3, uint64_t a4, uint64_t a5, void *a6, void *a7, uint64_t a8)
{
  uint64_t v13 = 0LL;
  __int128 v22 = 0LL;
  __int128 v23 = (char *)a4;
  uint64_t v14 = a4 + a5;
  if (a2)
  {
    unsigned int v15 = mdns_snprintf_add( &v23,  a4 + a5,  "<%s: %p>: ",  a4,  a5,  (uint64_t)a6,  (uint64_t)a7,  a8,  *(void *)(*(void *)(a1 + 16) + 8LL));
    if ((v15 & 0x80000000) != 0) {
      goto LABEL_15;
    }
    uint64_t v13 = v15;
  }

  unint64_t v16 = *(unsigned __int16 **)(a1 + 32);
  if (v16)
  {
    uint64_t v17 = DNSRecordDataToStringEx( v16,  *(unsigned __int16 *)(a1 + 56),  *(unsigned __int16 *)(a1 + 52),  0LL,  0LL,  a3,  (uint64_t)&v22);
    if ((_DWORD)v17)
    {
      uint64_t v20 = v17;
      goto LABEL_16;
    }

    unsigned int v18 = (const char *)v22;
  }

  else
  {
    unsigned int v18 = 0LL;
  }

  if (!v18) {
    unsigned int v18 = "<NO RDATA>";
  }
  unsigned int v19 = mdns_snprintf_add(&v23, v14, "%s", a4, a5, (uint64_t)a6, (uint64_t)a7, a8, (char)v18);
  if ((v19 & 0x80000000) != 0)
  {
LABEL_15:
    uint64_t v20 = 4294960596LL;
    goto LABEL_16;
  }

  if (a6) {
    *a6 = &v23[-a4];
  }
  uint64_t v20 = 0LL;
  if (a7) {
    *a7 = v13 + v19;
  }
LABEL_16:
  if (v22) {
    free(v22);
  }
  return v20;
}

void *mdns_resource_record_create(void *a1, __int16 a2, __int16 a3, int a4, const void *a5, unsigned int a6)
{
  uint64_t v12 = _os_object_alloc(&OBJC_CLASS___OS_mdns_resource_record, 64LL);
  uint64_t v13 = v12;
  if (!v12) {
    return (void *)v13;
  }
  uint64_t v14 = &_mdns_resource_record_kind;
  *(void *)(v12 + 16) = &_mdns_resource_record_kind;
  do
  {
    unsigned int v15 = (void (*)(uint64_t))v14[2];
    if (v15) {
      v15(v13);
    }
    uint64_t v14 = (_UNKNOWN **)*v14;
  }

  while (v14);
  *(void *)(v13 + 24) = a1;
  os_retain(a1);
  *(_DWORD *)(v13 + 40) = a4;
  *(_DWORD *)(v13 + 44) = 0;
  *(_WORD *)(v13 + 52) = a2;
  *(_WORD *)(v13 + 54) = a3;
  *(_WORD *)(v13 + 56) = a6;
  if (!a6) {
    return (void *)v13;
  }
  BOOL result = malloc(a6);
  if (result)
  {
    uint64_t v17 = result;
    memcpy(result, a5, a6);
    *(void *)(v13 + 32) = v17;
    return (void *)v13;
  }

  __break(1u);
  return result;
}

void *_mdns_string_builder_copy_description(void *a1, int a2)
{
  CFDateRef v4 = (void *)mdns_string_builder_create();
  if (!v4) {
    return 0LL;
  }
  CFNumberRef v5 = v4;
  if (a2 && mdns_string_builder_append_formatted(v4, "<%s: %p>: ", *(const char **)(a1[2] + 8LL), a1)
    || mdns_string_builder_append_formatted(v5, "capacity: %zu, string length: %zu", a1[4], a1[5]))
  {
    goto LABEL_4;
  }

  CFDictionaryRef v7 = (const char *)v5[3];
  if (v7)
  {
    uint64_t v8 = v5[5];
    size_t v9 = v8 + 1;
    if (v8 == -1)
    {
LABEL_4:
      CFNumberRef v6 = 0LL;
LABEL_12:
      os_release(v5);
      return v6;
    }
  }

  else
  {
    CFDictionaryRef v7 = "";
    size_t v9 = 1LL;
  }

  BOOL result = malloc(v9);
  if (result)
  {
    CFNumberRef v6 = result;
    memcpy(result, v7, v9);
    goto LABEL_12;
  }

  __break(1u);
  return result;
}

void _mdns_string_builder_finalize(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 24);
  if (v2)
  {
    free(v2);
    *(void *)(a1 + 24) = 0LL;
  }

uint64_t mdns_string_builder_create()
{
  uint64_t v0 = _os_object_alloc(&OBJC_CLASS___OS_mdns_string_builder, 48LL);
  uint64_t v1 = v0;
  if (v0)
  {
    uint64_t v2 = &_mdns_string_builder_kind;
    *(void *)(v0 + 16) = &_mdns_string_builder_kind;
    do
    {
      CFDateRef v3 = (void (*)(uint64_t))v2[2];
      if (v3) {
        v3(v1);
      }
      uint64_t v2 = (_UNKNOWN **)*v2;
    }

    while (v2);
    *(void *)(v1 + 32) = 0LL;
  }

  return v1;
}

uint64_t mdns_string_builder_append_formatted(void *a1, char *__format, ...)
{
  if (a1[3] || (uint64_t result = _mdns_string_builder_grow_buffer(a1, a1[4]), !(_DWORD)result))
  {
    for (char i = 1; ; char i = 0)
    {
      size_t v6 = a1[4] - a1[5];
      unsigned int v7 = vsnprintf((char *)(a1[3] + a1[5]), v6, __format, va);
      if ((v7 & 0x80000000) != 0)
      {
        *(_BYTE *)(a1[3] + a1[5]) = 0;
        return 4294960596LL;
      }

      uint64_t v8 = v7;
      if (v6 > v7)
      {
        uint64_t result = 0LL;
        a1[5] += v8;
        return result;
      }

      if ((i & 1) == 0) {
        break;
      }
      uint64_t v9 = a1[5];
      uint64_t v10 = v7 + 1LL;
      BOOL v11 = __CFADD__(v9, v10);
      unint64_t v12 = v9 + v10;
      if (v11) {
        return 4294960567LL;
      }
      uint64_t v13 = a1[4];
      if (v13 < 0) {
        return 4294960567LL;
      }
      if (v12 <= 2 * v13) {
        unint64_t v14 = 2 * v13;
      }
      else {
        unint64_t v14 = v12;
      }
      uint64_t result = _mdns_string_builder_grow_buffer(a1, v14);
      if ((_DWORD)result) {
        return result;
      }
    }

    return 4294960534LL;
  }

  return result;
}

uint64_t _mdns_string_builder_grow_buffer(void *a1, unint64_t a2)
{
  if (a1[3] && a1[4] >= a2) {
    return 0LL;
  }
  if (a2 <= 0x40) {
    size_t v3 = 64LL;
  }
  else {
    size_t v3 = a2;
  }
  size_t v4 = malloc_good_size(v3);
  if (v4 < v3) {
    return 4294960534LL;
  }
  size_t v5 = v4;
  size_t v6 = calloc(v4, 1uLL);
  if (!v6)
  {
    __break(1u);
    return 0LL;
  }

  unsigned int v7 = v6;
  uint64_t v8 = (const void *)a1[3];
  if (v8)
  {
    memcpy(v6, v8, a1[5] + 1LL);
    uint64_t v9 = (void *)a1[3];
    if (v9) {
      free(v9);
    }
  }

  uint64_t result = 0LL;
  a1[3] = v7;
  a1[4] = v5;
  return result;
}

uint64_t mdns_string_builder_append_description(void *a1, uint64_t a2, char a3)
{
  size_t v4 = (void *)(a2 + 16);
  while (1)
  {
    size_t v4 = (void *)*v4;
    if (!v4) {
      break;
    }
    size_t v5 = (uint64_t (*)(uint64_t, void, void))v4[3];
    if (v5)
    {
      size_t v6 = (const char *)v5(a2, 0LL, a3 & 1);
      if (v6)
      {
        unsigned int v7 = (char *)v6;
        uint64_t appended = mdns_string_builder_append_formatted(a1, "%s", v6);
        free(v7);
        return appended;
      }

      return 4294960567LL;
    }
  }

  return 4294960567LL;
}

uint64_t mdns_string_builder_append_description_with_prefix(void *a1, const char *a2, uint64_t a3, char a4)
{
  if (!a2) {
    return mdns_string_builder_append_description(a1, a3, a4);
  }
  uint64_t result = mdns_string_builder_append_formatted(a1, "%s", a2);
  if (!(_DWORD)result) {
    return mdns_string_builder_append_description(a1, a3, a4);
  }
  return result;
}

uint64_t mdns_string_builder_append_sockaddr_description(void *a1, uint64_t a2, char a3)
{
  int v6 = *(unsigned __int8 *)(a2 + 1);
  if (v6 != 30)
  {
    if (v6 != 2) {
      return mdns_string_builder_append_formatted(a1, "«UNHANDLED ADDRESS FAMILY: %d»");
    }
    unsigned int v7 = (int *)(a2 + 4);
    if ((a3 & 1) == 0)
    {
      memset(v18, 0, sizeof(v18));
      if (inet_ntop(2, v7, v18, 0x10u))
      {
LABEL_5:
        uint64_t result = mdns_string_builder_append_formatted(a1, "%s");
LABEL_22:
        if ((_DWORD)result) {
          return result;
        }
        if ((a3 & 2) == 0 && *(_WORD *)(a2 + 2)) {
          return mdns_string_builder_append_formatted(a1, ":%d");
        }
        return 0LL;
      }

      if (*__error())
      {
        uint64_t result = *__error();
        if ((_DWORD)result) {
          return result;
        }
        goto LABEL_5;
      }

      return 4294960596LL;
    }

    __int128 v20 = 0u;
    *(_OWORD *)unsigned int v18 = 0u;
    memset(v19, 0, sizeof(v19));
    unsigned int v10 = bswap32(*v7);
    int v16 = *v7;
    unsigned int v17 = v10;
    if (v10) {
      BOOL v11 = v10 == 2130706433;
    }
    else {
      BOOL v11 = 1;
    }
    if (v11)
    {
      if (_GetCUSymAddr_SNPrintF_sAddr
        && (_GetCUSymAddr_SNPrintF_sAddr(v18, 64LL, "%#.4a", COERCE_DOUBLE(&v17)) & 0x80000000) == 0)
      {
        goto LABEL_21;
      }
    }

    else
    {
      int v15 = _DNSMessagePrintObfuscatedIPAddress((uint64_t)v18, (uint64_t)&v16, 4LL);
      if ((v15 & 0x80000000) == 0) {
        goto LABEL_21;
      }
    }

    v18[0] = 0;
LABEL_21:
    uint64_t result = mdns_string_builder_append_formatted(a1, "<IPv4:%s>");
    goto LABEL_22;
  }

  if ((a3 & 2) != 0 || !*(_WORD *)(a2 + 2))
  {
    char v9 = 1;
  }

  else
  {
    uint64_t result = mdns_string_builder_append_formatted(a1, "[");
    if ((_DWORD)result) {
      return result;
    }
    char v9 = 0;
  }

  unint64_t v12 = (const void *)(a2 + 8);
  if ((a3 & 1) != 0)
  {
    __int128 v20 = 0uLL;
    *(_OWORD *)unsigned int v18 = 0uLL;
    memset(v19, 0, sizeof(v19));
    if (*(void *)(a2 + 8) | *(void *)(a2 + 15)) {
      BOOL v13 = 1;
    }
    else {
      BOOL v13 = *(unsigned __int8 *)(a2 + 23) >= 2u;
    }
    if (v13)
    {
      if ((_DNSMessagePrintObfuscatedIPAddress((uint64_t)v18, (uint64_t)v12, 16LL) & 0x80000000) == 0)
      {
LABEL_42:
        uint64_t result = mdns_string_builder_append_formatted(a1, "<IPv6:%s>");
        goto LABEL_43;
      }
    }

    else
    {
      if (_GetCUSymAddr_SNPrintF_sOnce != -1)
      {
        dispatch_once(&_GetCUSymAddr_SNPrintF_sOnce, &__block_literal_global_244);
        unint64_t v12 = (const void *)(a2 + 8);
      }

      if (_GetCUSymAddr_SNPrintF_sAddr
        && (_GetCUSymAddr_SNPrintF_sAddr(v18, 64LL, "%.16a", *(double *)&v12) & 0x80000000) == 0)
      {
        goto LABEL_42;
      }
    }

    v18[0] = 0;
    goto LABEL_42;
  }

  *(_OWORD *)unsigned int v18 = 0uLL;
  memset(v19, 0, 30);
  if (!inet_ntop(30, v12, v18, 0x2Eu))
  {
    if (!*__error()) {
      return 4294960596LL;
    }
    uint64_t result = *__error();
    if ((_DWORD)result) {
      return result;
    }
  }

  uint64_t result = mdns_string_builder_append_formatted(a1, "%s");
LABEL_43:
  if (!(_DWORD)result)
  {
    unsigned int v14 = *(_DWORD *)(a2 + 24);
    if (!v14
      || ((memset(v18, 0, sizeof(v18)), LOBYTE(v19[0]) = 0, !if_indextoname(v14, v18))
        ? (uint64_t result = mdns_string_builder_append_formatted(a1, "%%%u"))
        : (uint64_t result = mdns_string_builder_append_formatted(a1, "%%%s")),
          !(_DWORD)result))
    {
      if ((v9 & 1) == 0) {
        return mdns_string_builder_append_formatted(a1, "]:%d");
      }
      return 0LL;
    }
  }

  return result;
}

void *mdns_string_builder_copy_string(uint64_t a1)
{
  uint64_t v1 = *(const char **)(a1 + 24);
  if (v1)
  {
    uint64_t v2 = *(void *)(a1 + 40);
    size_t v3 = v2 + 1;
    if (v2 == -1) {
      return 0LL;
    }
  }

  else
  {
    uint64_t v1 = "";
    size_t v3 = 1LL;
  }

  uint64_t result = malloc(v3);
  if (result)
  {
    size_t v4 = result;
    memcpy(result, v1, v3);
    return v4;
  }

  __break(1u);
  return result;
}

uint64_t resource_record_as_rrsig_get_covered_type(uint64_t a1)
{
  if (*(_WORD *)(a1 + 4) != 46) {
    return 0LL;
  }
  uint64_t result = rdata_parser_rrsig_check_validity(*(void *)(a1 + 40) + 4LL, *(unsigned __int16 *)(a1 + 12));
  if ((_DWORD)result) {
    return bswap32(*(unsigned __int16 *)(*(void *)(a1 + 40) + 4LL)) >> 16;
  }
  return result;
}

uint64_t resource_record_as_ds_refers_to_supported_key_algorithm(uint64_t a1)
{
  if (*(_WORD *)(a1 + 4) == 43)
  {
    unsigned int v1 = *(unsigned __int8 *)(*(void *)(a1 + 40) + 6LL) - 5;
    BOOL v2 = v1 > 0xB;
    unint64_t v3 = (0xF2DuLL >> v1) & 1;
    if (v2) {
      return 0LL;
    }
    else {
      return v3;
    }
  }

  size_t v5 = (os_log_s *)mDNSLogCategory_DNSSEC;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_DNSSEC == mDNSLogCategory_State)
  {
    uint64_t result = os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC, OS_LOG_TYPE_FAULT);
    if (!(_DWORD)result) {
      return result;
    }
LABEL_14:
    int v7 = 136447234;
    uint64_t v8 = "me->rrtype == kDNSRecordType_DS";
    __int16 v9 = 2082;
    unsigned int v10 = "";
    __int16 v11 = 2082;
    unint64_t v12 = "/Library/Caches/com.apple.xbs/Sources/mDNSResponder/mDNSMacOSX/dnssec_v2/dnssec_mdns_core.c";
    __int16 v13 = 1024;
    int v14 = 183;
    __int16 v15 = 2048;
    uint64_t v16 = 0LL;
    _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_FAULT,  "AssertMacros: %{public}s, %{public}s file: %{public}s, line: %d, value: %ld",  (uint8_t *)&v7,  0x30u);
    return 0LL;
  }

  size_t v5 = (os_log_s *)mDNSLogCategory_DNSSEC_redacted;
  uint64_t result = os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC_redacted, OS_LOG_TYPE_FAULT);
  if ((_DWORD)result) {
    goto LABEL_14;
  }
  return result;
}

BOOL resource_record_as_rrsig_covers_wildcard_rr(uint64_t a1)
{
  if (*(_WORD *)(a1 + 4) != 46) {
    return 0LL;
  }
  BOOL result = rdata_parser_rrsig_check_validity(*(void *)(a1 + 40) + 4LL, *(unsigned __int16 *)(a1 + 12));
  if (result)
  {
    unint64_t v3 = *(_BYTE **)(a1 + 32);
    int v4 = *v3;
    if (*v3)
    {
      unint64_t v5 = 0LL;
      do
      {
        ++v5;
        int v6 = &v3[v4];
        int v7 = v6[1];
        unint64_t v3 = v6 + 1;
        int v4 = v7;
      }

      while (v7);
    }

    else
    {
      unint64_t v5 = 0LL;
    }

    return v5 > *(unsigned __int8 *)(*(void *)(a1 + 40) + 7LL);
  }

  return result;
}

BOOL resource_record_as_denial_of_existence_proves_wildcard_answer(unsigned __int8 *a1)
{
  uint64_t v1 = *((void *)a1 + 7);
  return v1
      && *a1 == 240
      && !*(_DWORD *)(v1 + 32)
      && !*(_BYTE *)(v1 + 40)
      && (uint64_t v3 = *(void *)(v1 + 48)) != 0
      && *(_DWORD *)(v3 + 16) == 5;
}

BOOL resource_record_get_insecure_validation_usable(unsigned __int8 *a1)
{
  if (*a1 != 240) {
    return 0LL;
  }
  uint64_t v1 = *((void *)a1 + 7);
  if (!v1)
  {
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_DNSSEC == mDNSLogCategory_State)
    {
      unint64_t v5 = (os_log_s *)mDNSLogCategory_DNSSEC;
      BOOL result = os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC, OS_LOG_TYPE_FAULT);
      if (!result) {
        return result;
      }
    }

    else
    {
      unint64_t v5 = (os_log_s *)mDNSLogCategory_DNSSEC_redacted;
      BOOL result = os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC_redacted, OS_LOG_TYPE_FAULT);
      if (!result) {
        return result;
      }
    }

    int v6 = 136447234;
    int v7 = "me->dnssec != NULL";
    __int16 v8 = 2082;
    __int16 v9 = "";
    __int16 v10 = 2082;
    __int16 v11 = "/Library/Caches/com.apple.xbs/Sources/mDNSResponder/mDNSMacOSX/dnssec_v2/dnssec_mdns_core.c";
    __int16 v12 = 1024;
    int v13 = 354;
    __int16 v14 = 2048;
    uint64_t v15 = 0LL;
LABEL_23:
    _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_FAULT,  "AssertMacros: %{public}s, %{public}s file: %{public}s, line: %d, value: %ld",  (uint8_t *)&v6,  0x30u);
    return 0LL;
  }

  if (*(_DWORD *)(v1 + 32) == 1) {
    return *(_BYTE *)(v1 + 44) != 0;
  }
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_DNSSEC == mDNSLogCategory_State)
  {
    unint64_t v5 = (os_log_s *)mDNSLogCategory_DNSSEC;
    BOOL result = os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC, OS_LOG_TYPE_FAULT);
    if (!result) {
      return result;
    }
    goto LABEL_22;
  }

  unint64_t v5 = (os_log_s *)mDNSLogCategory_DNSSEC_redacted;
  BOOL result = os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC_redacted, OS_LOG_TYPE_FAULT);
  if (result)
  {
LABEL_22:
    int v6 = 136447234;
    int v7 = "me->aware_type == dnssec_aware_rr_validated";
    __int16 v8 = 2082;
    __int16 v9 = "";
    __int16 v10 = 2082;
    __int16 v11 = "/Library/Caches/com.apple.xbs/Sources/mDNSResponder/mDNSMacOSX/dnssec_v2/dnssec_objs/dnssec_obj_resource_record_member.c";
    __int16 v12 = 1024;
    int v13 = 226;
    __int16 v14 = 2048;
    uint64_t v15 = 0LL;
    goto LABEL_23;
  }

  return result;
}

uint64_t resource_record_get_cache_record(uint64_t a1)
{
  if (a1) {
    return *(void *)(a1 + 16);
  }
  BOOL v2 = (os_log_s *)mDNSLogCategory_DNSSEC;
  if (gSensitiveLoggingEnabled == 1 && mDNSLogCategory_DNSSEC != mDNSLogCategory_State)
  {
    BOOL v2 = (os_log_s *)mDNSLogCategory_DNSSEC_redacted;
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC_redacted, OS_LOG_TYPE_FAULT)) {
      return 0LL;
    }
    goto LABEL_11;
  }

  if (os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC, OS_LOG_TYPE_FAULT))
  {
LABEL_11:
    int v5 = 136447234;
    int v6 = "me->dnssec != NULL";
    __int16 v7 = 2082;
    __int16 v8 = "";
    __int16 v9 = 2082;
    __int16 v10 = "/Library/Caches/com.apple.xbs/Sources/mDNSResponder/mDNSMacOSX/dnssec_v2/dnssec_mdns_core.c";
    __int16 v11 = 1024;
    int v12 = 324;
    __int16 v13 = 2048;
    uint64_t v14 = 0LL;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_FAULT,  "AssertMacros: %{public}s, %{public}s file: %{public}s, line: %d, value: %ld",  (uint8_t *)&v5,  0x30u);
  }

  return 0LL;
}

uint64_t resource_record_get_expiration_time(uint64_t a1)
{
  if (!a1)
  {
    int v4 = (os_log_s *)mDNSLogCategory_DNSSEC;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_DNSSEC == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC, OS_LOG_TYPE_FAULT)) {
        return 0LL;
      }
    }

    else
    {
      int v4 = (os_log_s *)mDNSLogCategory_DNSSEC_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC_redacted, OS_LOG_TYPE_FAULT)) {
        return 0LL;
      }
    }

    int v9 = 136447234;
    __int16 v10 = "me->dnssec != NULL";
    __int16 v11 = 2082;
    int v12 = "";
    __int16 v13 = 2082;
    uint64_t v14 = "/Library/Caches/com.apple.xbs/Sources/mDNSResponder/mDNSMacOSX/dnssec_v2/dnssec_mdns_core.c";
    __int16 v15 = 1024;
    int v16 = 364;
    __int16 v17 = 2048;
    uint64_t v18 = 0LL;
LABEL_27:
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_FAULT,  "AssertMacros: %{public}s, %{public}s file: %{public}s, line: %d, value: %ld",  (uint8_t *)&v9,  0x30u);
    return 0LL;
  }

  uint64_t v1 = *(void *)(a1 + 16);
  if (!v1)
  {
    int v4 = (os_log_s *)mDNSLogCategory_DNSSEC;
    if (gSensitiveLoggingEnabled == 1 && mDNSLogCategory_DNSSEC != mDNSLogCategory_State)
    {
      int v4 = (os_log_s *)mDNSLogCategory_DNSSEC_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC_redacted, OS_LOG_TYPE_FAULT)) {
        return 0LL;
      }
      goto LABEL_26;
    }

    if (os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC, OS_LOG_TYPE_FAULT))
    {
LABEL_26:
      int v9 = 136447234;
      __int16 v10 = "cr != NULL";
      __int16 v11 = 2082;
      int v12 = "";
      __int16 v13 = 2082;
      uint64_t v14 = "/Library/Caches/com.apple.xbs/Sources/mDNSResponder/mDNSMacOSX/dnssec_v2/dnssec_mdns_core.c";
      __int16 v15 = 1024;
      int v16 = 367;
      __int16 v17 = 2048;
      uint64_t v18 = 0LL;
      goto LABEL_27;
    }

    return 0LL;
  }

  if (*(_BYTE *)(v1 + 109)) {
    unsigned int v2 = dword_100158BF8 + 939524096;
  }
  else {
    unsigned int v2 = *(_DWORD *)(v1 + 80) + 1000 * *(_DWORD *)(v1 + 16);
  }
  if (v2 <= 1) {
    return 1LL;
  }
  else {
    return v2;
  }
}

uint64_t resource_record_get_actual_ttl(uint64_t a1, uint64_t a2)
{
  if (!*(_DWORD *)(a2 + 8)) {
    return 0LL;
  }
  int expiration_time = resource_record_get_expiration_time(*(void *)(a2 + 56));
  if (expiration_time)
  {
    if (expiration_time - *(_DWORD *)(a1 + 64) >= 0) {
      return (expiration_time - *(_DWORD *)(a1 + 64)) / 0x3E8u;
    }
    else {
      return 0LL;
    }
  }

  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_DNSSEC == mDNSLogCategory_State)
  {
    int v6 = (os_log_s *)mDNSLogCategory_DNSSEC;
    uint64_t result = os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC, OS_LOG_TYPE_FAULT);
    if (!(_DWORD)result) {
      return result;
    }
    goto LABEL_14;
  }

  int v6 = (os_log_s *)mDNSLogCategory_DNSSEC_redacted;
  uint64_t result = os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC_redacted, OS_LOG_TYPE_FAULT);
  if ((_DWORD)result)
  {
LABEL_14:
    int v7 = 136447234;
    __int16 v8 = "expiration_time != 0";
    __int16 v9 = 2082;
    __int16 v10 = "";
    __int16 v11 = 2082;
    int v12 = "/Library/Caches/com.apple.xbs/Sources/mDNSResponder/mDNSMacOSX/dnssec_v2/dnssec_mdns_core.c";
    __int16 v13 = 1024;
    int v14 = 394;
    __int16 v15 = 2048;
    uint64_t v16 = 0LL;
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_FAULT,  "AssertMacros: %{public}s, %{public}s file: %{public}s, line: %d, value: %ld",  (uint8_t *)&v7,  0x30u);
    return 0LL;
  }

  return result;
}

uint64_t resource_records_have_same_dnssec_rr_category(uint64_t a1, uint64_t a2)
{
  if ((a1 != 0) != (a2 != 0)) {
    return 0LL;
  }
  if (a1)
  {
    int v3 = *(_DWORD *)(a1 + 32);
    if (a2)
    {
      int v4 = *(_DWORD *)(a2 + 32);
      if ((v3 == 0) == (v4 == 0))
      {
        BOOL v5 = v3 == 1;
LABEL_10:
        BOOL v6 = v4 == 1;
        return v5 ^ v6 ^ 1u;
      }
    }

    else if (v3)
    {
      BOOL v6 = 0;
      BOOL v5 = v3 == 1;
      return v5 ^ v6 ^ 1u;
    }

    return 0LL;
  }

  BOOL v5 = 0;
  if (!a2)
  {
    BOOL v6 = 0;
    return v5 ^ v6 ^ 1u;
  }

  uint64_t result = 0LL;
  int v4 = *(_DWORD *)(a2 + 32);
  if (v4) {
    goto LABEL_10;
  }
  return result;
}

BOOL identical_dnssec_validated_same_name_resource_record(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 56);
  if (!v2) {
    return 0LL;
  }
  if (*(_DWORD *)(v2 + 32)) {
    return 0LL;
  }
  uint64_t v4 = *(void *)(a2 + 56);
  if (!v4
    || *(_DWORD *)(v4 + 32) != 1
    || *(unsigned __int16 *)(a1 + 4) != *(unsigned __int16 *)(a2 + 4)
    || *(unsigned __int16 *)(a1 + 6) != *(unsigned __int16 *)(a2 + 6)
    || *(unsigned __int16 *)(a1 + 12) != *(unsigned __int16 *)(a2 + 12)
    || *(_DWORD *)(a1 + 20) != *(_DWORD *)(a2 + 20))
  {
    return 0LL;
  }

  if (*(_WORD *)(a1 + 12)) {
    return SameRDataBody( a1,  (unsigned __int16 *)(*(void *)(a2 + 40) + 4LL),  (uint64_t (*)(uint64_t, unsigned __int16 *))SameDomainName) != 0;
  }
  return 1LL;
}

uint64_t _mdns_symptoms_report_dns_server_symptom(uint64_t a1, uint64_t a2)
{
  if (_mdns_symptoms_get_reporter_s_once != -1) {
    dispatch_once(&_mdns_symptoms_get_reporter_s_once, &__block_literal_global_354);
  }
  uint64_t result = _mdns_symptoms_get_reporter_s_reporter;
  if (_mdns_symptoms_get_reporter_s_reporter)
  {
    int v4 = *(unsigned __int8 *)(a2 + 1);
    if (v4 == 2)
    {
      uint64_t v5 = 16LL;
      goto LABEL_9;
    }

    if (v4 == 30)
    {
      uint64_t v5 = 28LL;
LABEL_9:
      uint64_t v6 = symptom_new();
      symptom_set_additional_qualifier(v6, 1LL, v5, a2);
      return symptom_send(v6);
    }
  }

  return result;
}

void ___mdns_symptoms_get_reporter_block_invoke(id a1)
{
  if (&_symptom_framework_init) {
    _mdns_symptoms_get_reporter_s_reporter = symptom_framework_init(101LL, "com.apple.mDNSResponder");
  }
}

void _mdns_symptoms_report_resolved( CFArrayRef theArray, const __CFArray *a2, _OWORD *a3, int a4, unsigned int a5, int a6, const unsigned __int8 *a7, _OWORD *a8)
{
  if (_mdns_symptoms_get_reporter_s_once != -1) {
    dispatch_once(&_mdns_symptoms_get_reporter_s_once, &__block_literal_global_354);
  }
  uint64_t v15 = _mdns_symptoms_get_reporter_s_reporter;
  if (_mdns_symptoms_get_reporter_s_reporter)
  {
    CFIndex Count = CFArrayGetCount(theArray);
    CFIndex v34 = Count - 1;
    if (Count >= 1)
    {
      CFIndex v17 = CFArrayGetCount(a2);
      if (v17 >= 1)
      {
        CFIndex v18 = v17;
        CFDataRef deep_copy_data = _mdns_symptoms_create_deep_copy_data(theArray);
        if (deep_copy_data)
        {
          __int128 v20 = deep_copy_data;
          CFDataRef v21 = _mdns_symptoms_create_deep_copy_data(a2);
          if (v21)
          {
            __int128 v22 = v21;
            uint64_t v23 = symptom_new(v15, 413699LL);
            symptom_set_qualifier(v23, a5, 4LL);
            symptom_set_additional_qualifier(v23, 2LL, 32LL, a3);
            if (a4) {
              symptom_set_qualifier(v23, 1LL, 2LL);
            }
            __int128 v45 = 0u;
            __int128 v46 = 0u;
            *(_OWORD *)__str = 0u;
            __int128 v44 = 0u;
            if (a8)
            {
              symptom_set_additional_qualifier(v23, 3LL, 32LL, a8);
              __int128 v24 = a8[1];
              *(_OWORD *)audit_token_t atoken = *a8;
              *(_OWORD *)&atoken[16] = v24;
              audit_token_to_pid((audit_token_t *)atoken);
              snprintf(__str, 0x40uLL, " delegated token: %lld");
            }

            else if (a7)
            {
              symptom_set_additional_qualifier(v23, 4LL, 16LL, a7);
              memset(atoken, 0, 37);
              uuid_unparse_lower(a7, atoken);
              snprintf(__str, 0x40uLL, " delegated uuid: %s");
            }

            else if (a6)
            {
              symptom_set_qualifier(v23, a6, 1LL);
              snprintf(__str, 0x40uLL, " delegated pid: %lld");
            }

            CFIndex Length = CFDataGetLength(v22);
            BytePtr = CFDataGetBytePtr(v22);
            symptom_set_additional_qualifier(v23, 5LL, Length, BytePtr);
            CFIndex v27 = CFDataGetLength(v20);
            __int128 v28 = CFDataGetBytePtr(v20);
            symptom_set_additional_qualifier(v23, 6LL, v27, v28);
            symptom_send(v23);
            if (_mdns_symptoms_log_s_once != -1) {
              dispatch_once(&_mdns_symptoms_log_s_once, &__block_literal_global_8);
            }
            __int128 v29 = (os_log_s *)_mdns_symptoms_log_s_log;
            if (os_log_type_enabled((os_log_t)_mdns_symptoms_log_s_log, OS_LOG_TYPE_DEBUG))
            {
              __int128 v30 = a3[1];
              *(_OWORD *)audit_token_t atoken = *a3;
              *(_OWORD *)&atoken[16] = v30;
              uint64_t v31 = audit_token_to_pid((audit_token_t *)atoken);
              ValueAtIndex = CFArrayGetValueAtIndex(theArray, 0LL);
              *(_DWORD *)audit_token_t atoken = 67110658;
              __int128 v33 = "";
              *(_DWORD *)&atoken[4] = a5;
              *(_WORD *)&atoken[8] = 2048;
              if (a4) {
                __int128 v33 = " (browse)";
              }
              *(void *)&atoken[10] = v31;
              *(_WORD *)&atoken[18] = 2112;
              *(void *)&atoken[20] = ValueAtIndex;
              *(_WORD *)&atoken[28] = 2082;
              *(void *)&atoken[30] = v33;
              __int16 v37 = 2048;
              CFIndex v38 = v34;
              __int16 v39 = 2048;
              CFIndex v40 = v18;
              __int16 v41 = 2082;
              __int128 v42 = __str;
              _os_log_debug_impl( (void *)&_mh_execute_header,  v29,  OS_LOG_TYPE_DEBUG,  "[R%u] Report pid: %lld %@%{public}s (cnames %ld) (addrs %ld)%{public}s",  atoken,  0x44u);
            }

            CFRelease(v20);
            CFRelease(v22);
          }

          else
          {
            CFRelease(v20);
          }
        }
      }
    }
  }

CFDataRef _mdns_symptoms_create_deep_copy_data(CFPropertyListRef propertyList)
{
  CFDataRef result = (CFDataRef)CFPropertyListCreateDeepCopy(kCFAllocatorDefault, propertyList, 0LL);
  if (result)
  {
    CFDataRef v2 = result;
    CFDataRef Data = CFPropertyListCreateData(kCFAllocatorDefault, result, kCFPropertyListBinaryFormat_v1_0, 0LL, 0LL);
    CFRelease(v2);
    return Data;
  }

  return result;
}

void ___mdns_symptoms_log_block_invoke(id a1)
{
  _mdns_symptoms_log_s_log = (uint64_t)os_log_create("com.apple.mdns", "symptoms");
}

uint64_t __Block_byref_object_copy_(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0LL;
  return result;
}

void __Block_byref_object_dispose_(uint64_t a1)
{
}

void __http_task_create_dns_query_block_invoke(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v20 = a2;
  id v7 = a3;
  id v8 = a4;
  uint64_t v9 = *(void *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 40LL);
  if (v9)
  {
    if (v8)
    {
      nw_activity_complete_with_reason(v9, 3LL);
      goto LABEL_5;
    }

    nw_activity_complete_with_reason(v9, 2LL);
LABEL_10:
    id HeuristicsQueue = getHeuristicsQueue();
    __int16 v13 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue(HeuristicsQueue);
    dispatch_async(v13, &__block_literal_global_6363);
LABEL_17:

    goto LABEL_18;
  }

  if (!v8) {
    goto LABEL_10;
  }
LABEL_5:
  __int16 v10 = (void *)objc_claimAutoreleasedReturnValue([v8 domain]);
  else {
    BOOL v11 = 0;
  }

  int v14 = (void *)objc_claimAutoreleasedReturnValue([v8 domain]);
  else {
    BOOL v15 = 0;
  }

  if (!v11)
  {
    id v16 = (id)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) URL]);
    id v17 = getHeuristicsQueue();
    CFIndex v18 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue(v17);
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472LL;
    block[2] = __dns_heuristics_report_resolution_failure_block_invoke;
    block[3] = &unk_10013E568;
    id v22 = v16;
    BOOL v23 = v15;
    __int16 v13 = (dispatch_queue_s *)v16;
    dispatch_async(v18, block);

    goto LABEL_17;
  }

id _http_task_create_data_task(void *a1, void *a2)
{
  id v3 = a1;
  id v4 = a2;
  uint64_t v8 = 0LL;
  uint64_t v9 = &v8;
  uint64_t v10 = 0x3032000000LL;
  BOOL v11 = __Block_byref_object_copy_;
  int v12 = __Block_byref_object_dispose_;
  id v13 = 0LL;
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 3221225472LL;
  v7[2] = ___http_task_create_data_task_block_invoke;
  v7[3] = &unk_10013BAD0;
  v7[5] = v4;
  v7[6] = &v8;
  v7[4] = v3;
  _http_task_shared_session_critical_region(v7);
  id v5 = (id)v9[5];
  _Block_object_dispose(&v8, 8);

  return v5;
}

void sub_100059630( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

void ___http_task_create_data_task_block_invoke(void *a1)
{
  CFDataRef v2 = (void *)g_shared_session;
  if (!g_shared_session)
  {
    if (_http_task_create_shared_session_s_once != -1) {
      dispatch_once(&_http_task_create_shared_session_s_once, &__block_literal_global_126);
    }
    id v3 = (void *)objc_claimAutoreleasedReturnValue( +[NSURLSessionConfiguration ephemeralSessionConfiguration]( &OBJC_CLASS___NSURLSessionConfiguration,  "ephemeralSessionConfiguration"));
    [v3 setHTTPCookieStorage:0];
    [v3 setURLCache:0];
    [v3 setURLCredentialStorage:0];
    id v4 = (void *)objc_claimAutoreleasedReturnValue( +[NSSet setWithObjects:]( &OBJC_CLASS___NSSet,  "setWithObjects:",  @"User-Agent",  @"Accept-Language",  0LL));
    objc_msgSend(v3, "set_suppressedAutoAddedHTTPHeaders:", v4);

    objc_msgSend(v3, "set_allowsTLSSessionTickets:", 1);
    objc_msgSend(v3, "set_allowsTCPFastOpen:", 1);
    objc_msgSend(v3, "set_disableAPWakeOnIdleConnections:", 1);
    id v5 = objc_alloc_init(&OBJC_CLASS___NSOperationQueue);
    if (_mdns_resolver_queue_s_once != -1) {
      dispatch_once(&_mdns_resolver_queue_s_once, &__block_literal_global_138);
    }
    id v6 = (id)_mdns_resolver_queue_s_queue;
    -[NSOperationQueue setUnderlyingQueue:](v5, "setUnderlyingQueue:", v6);

    uint64_t v7 = objc_claimAutoreleasedReturnValue( +[NSURLSession sessionWithConfiguration:delegate:delegateQueue:]( &OBJC_CLASS___NSURLSession,  "sessionWithConfiguration:delegate:delegateQueue:",  v3,  _http_task_create_shared_session_delegate,  v5));
    uint64_t v8 = (void *)g_shared_session;
    g_shared_session = v7;

    CFDataRef v2 = (void *)g_shared_session;
  }

  uint64_t v9 = objc_claimAutoreleasedReturnValue([v2 dataTaskWithRequest:a1[4] completionHandler:a1[5]]);
  uint64_t v10 = *(void *)(a1[6] + 8LL);
  BOOL v11 = *(void **)(v10 + 40);
  *(void *)(v10 + 40) = v9;
}

void _http_task_shared_session_critical_region(void *a1)
{
  uint64_t v1 = a1;
  os_unfair_lock_lock((os_unfair_lock_t)&_http_task_shared_session_critical_region_s_lock);
  v1[2](v1);

  os_unfair_lock_unlock((os_unfair_lock_t)&_http_task_shared_session_critical_region_s_lock);
}

void ___http_task_create_shared_session_block_invoke(id a1)
{
  uint64_t v1 = objc_alloc_init(&OBJC_CLASS___MDNSHTTPSessionDelegate);
  CFDataRef v2 = (void *)_http_task_create_shared_session_delegate;
  _http_task_create_shared_session_delegate = (uint64_t)v1;
}

void *http_task_create_pvd_query(void *a1, uint64_t a2, uint64_t a3, void *a4)
{
  id v7 = a1;
  id v8 = a4;
  uint64_t v9 = objc_autoreleasePoolPush();
  uint64_t v10 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"https://%s/.well-known/pvd%s",  a2,  a3));
  BOOL v11 = objc_alloc(&OBJC_CLASS___NSMutableURLRequest);
  int v12 = -[NSURL initWithString:](objc_alloc(&OBJC_CLASS___NSURL), "initWithString:", v10);
  id v13 = -[NSMutableURLRequest initWithURL:](v11, "initWithURL:", v12);

  -[NSMutableURLRequest setHTTPMethod:](v13, "setHTTPMethod:", @"GET");
  -[NSMutableURLRequest setValue:forHTTPHeaderField:]( v13,  "setValue:forHTTPHeaderField:",  @"application/pvd+json",  @"accept");
  -[NSMutableURLRequest setValue:forHTTPHeaderField:]( v13,  "setValue:forHTTPHeaderField:",  @"application/pvd+json",  @"content-type");
  uint64_t v24 = 0LL;
  __int128 v25 = &v24;
  uint64_t v26 = 0x3032000000LL;
  CFIndex v27 = __Block_byref_object_copy_;
  __int128 v28 = __Block_byref_object_dispose_;
  id v29 = 0LL;
  id v29 = (id)nw_activity_create(33LL, 3LL);
  if (v25[5]) {
    nw_activity_activate();
  }
  v20[0] = _NSConcreteStackBlock;
  v20[1] = 3221225472LL;
  v20[2] = __http_task_create_pvd_query_block_invoke;
  v20[3] = &unk_100139CF0;
  id v14 = v7;
  id v21 = v14;
  BOOL v23 = &v24;
  id v15 = v8;
  id v22 = v15;
  id data_task = _http_task_create_data_task(v13, v20);
  id v17 = (void *)objc_claimAutoreleasedReturnValue(data_task);
  if (v17 && v25[5])
  {
    CFIndex v18 = (void *)nw_activity_create(33LL, 3LL);
    objc_msgSend(v17, "set_nw_activity:", v18);
  }

  _Block_object_dispose(&v24, 8);
  objc_autoreleasePoolPop(v9);

  return v17;
}

void sub_100059A88( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
}

void __http_task_create_pvd_query_block_invoke(uint64_t a1, void *a2)
{
  id v3 = *(dispatch_queue_s **)(a1 + 32);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472LL;
  block[2] = __http_task_create_pvd_query_block_invoke_2;
  block[3] = &unk_10013BAD0;
  void block[4] = a2;
  __int128 v6 = *(_OWORD *)(a1 + 40);
  id v4 = (id)v6;
  __int128 v8 = v6;
  id v5 = a2;
  dispatch_async(v3, block);
}

void __http_task_create_pvd_query_block_invoke_2(void *a1)
{
  uint64_t v2 = a1[4];
  if (v2)
  {
    id v13 = (id)objc_claimAutoreleasedReturnValue( +[NSJSONSerialization JSONObjectWithData:options:error:]( &OBJC_CLASS___NSJSONSerialization,  "JSONObjectWithData:options:error:",  v2,  0LL,  0LL));
    uint64_t v3 = objc_opt_class(&OBJC_CLASS___NSDictionary);
    if ((objc_opt_isKindOfClass(v13, v3) & 1) != 0)
    {
      id v4 = (void *)_CFXPCCreateXPCObjectFromCFObject(v13);
      id v5 = (void *)objc_claimAutoreleasedReturnValue([v13 objectForKeyedSubscript:@"expires"]);
      __int128 v6 = (void *)objc_claimAutoreleasedReturnValue([v13 objectForKeyedSubscript:@"seconds-remaining"]);
      if (v4)
      {
        uint64_t v7 = objc_opt_class(&OBJC_CLASS___NSString);
        if ((objc_opt_isKindOfClass(v5, v7) & 1) == 0 || v6)
        {
          if (v6) {
            xpc_dictionary_set_uint64(v4, "seconds-remaining", (uint64_t)[v6 unsignedLongLongValue]);
          }
        }

        else
        {
          __int128 v8 = objc_alloc_init(&OBJC_CLASS___NSDateFormatter);
          uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue( +[NSTimeZone timeZoneForSecondsFromGMT:]( &OBJC_CLASS___NSTimeZone,  "timeZoneForSecondsFromGMT:",  0LL));
          -[NSDateFormatter setTimeZone:](v8, "setTimeZone:", v9);

          uint64_t v10 = (void *)objc_claimAutoreleasedReturnValue( +[NSLocale localeWithLocaleIdentifier:]( &OBJC_CLASS___NSLocale,  "localeWithLocaleIdentifier:",  @"en_US_POSIX"));
          -[NSDateFormatter setLocale:](v8, "setLocale:", v10);

          -[NSDateFormatter setDateFormat:](v8, "setDateFormat:", @"yyyy-MM-dd'T'HH:mm:ss'Z'");
          -[NSDateFormatter setFormatterBehavior:](v8, "setFormatterBehavior:", 0LL);
          BOOL v11 = (void *)objc_claimAutoreleasedReturnValue(-[NSDateFormatter dateFromString:](v8, "dateFromString:", v5));
          [v11 timeIntervalSinceNow];
          xpc_dictionary_set_uint64(v4, "seconds-remaining", (unint64_t)v12);
        }
      }

      nw_activity_complete_with_reason(*(void *)(*(void *)(a1[6] + 8LL) + 40LL), 2LL);
      (*(void (**)(void))(a1[5] + 16LL))();
    }

    else
    {
      nw_activity_complete_with_reason(*(void *)(*(void *)(a1[6] + 8LL) + 40LL), 3LL);
      (*(void (**)(void))(a1[5] + 16LL))();
    }
  }

  else
  {
    nw_activity_complete_with_reason(*(void *)(*(void *)(a1[6] + 8LL) + 40LL), 3LL);
    (*(void (**)(void))(a1[5] + 16LL))();
  }

void http_task_cancel(void *a1)
{
  uint64_t v2 = objc_autoreleasePoolPush();
  [a1 cancel];

  objc_autoreleasePoolPop(v2);
}

void __http_task_prepare_for_system_sleep_block_invoke(id a1)
{
  if (g_shared_session)
  {
    [(id)g_shared_session invalidateAndCancel];
    uint64_t v1 = (void *)g_shared_session;
    g_shared_session = 0LL;
  }

uint64_t _dnssec_obj_domain_name_compare(uint64_t a1, uint64_t a2, int a3)
{
  if (a1 == a2) {
    return 0LL;
  }
  __int128 v6 = *(unsigned __int8 **)(a1 + 16);
  uint64_t v7 = *(unsigned __int8 **)(a2 + 16);
  if (*(void *)(a1 + 24) == *(void *)(a2 + 24))
  {
    if (!*(_BYTE *)(a1 + 36))
    {
      *(_DWORD *)(a1 + 32) = domain_name_labels_compute_hash(*(_BYTE **)(a1 + 16));
      *(_BYTE *)(a1 + 36) = 1;
    }

    if (*(_BYTE *)(a2 + 36))
    {
      int v8 = *(_DWORD *)(a2 + 32);
    }

    else
    {
      int v8 = domain_name_labels_compute_hash(v7);
      *(_DWORD *)(a2 + 32) = v8;
      *(_BYTE *)(a2 + 36) = 1;
    }

    if (*(_DWORD *)(a1 + 32) == v8) {
      return domain_name_labels_canonical_compare(v6, v7, a3);
    }
  }

  if ((a3 & 1) == 0) {
    return domain_name_labels_canonical_compare(v6, v7, a3);
  }
  else {
    return 2LL;
  }
}

void _dnssec_obj_domain_name_finalize(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 37))
  {
    uint64_t v2 = *(void **)(a1 + 16);
    if (v2)
    {
      free(v2);
      *(void *)(a1 + 16) = 0LL;
    }
  }

  uint64_t v3 = *(void **)(a1 + 40);
  if (v3)
  {
    ref_count_obj_release(v3);
    *(void *)(a1 + 40) = 0LL;
  }

unsigned __int8 *dnssec_obj_domain_name_create_with_labels(unsigned __int8 *a1, int a2, int *a3)
{
  uint64_t v7 = (unsigned __int8 *)calloc(1uLL, 0x30uLL);
  if (v7)
  {
    uint64_t v3 = v7;
    int v8 = &_dnssec_obj_domain_name_kind;
    *((void *)v7 + 1) = &_dnssec_obj_domain_name_kind;
    do
    {
      uint64_t v9 = (void (*)(unsigned __int8 *))v8[2];
      if (v9) {
        v9(v3);
      }
      int v8 = (_UNKNOWN **)*v8;
    }

    while (v8);
    ++*(_DWORD *)v3;
    if ((a2 & 1) == 0)
    {
      int v18 = *a1;
      if (*a1)
      {
        id v19 = a1;
        do
        {
          id v20 = v19 + 1;
          v19 += v18 + 1;
          while (1)
          {
            BOOL v21 = __OFSUB__(v18--, 1);
            if (v18 < 0 != v21) {
              break;
            }
            int v22 = *v20++;
          }

          int v18 = *v19;
        }

        while (*v19);
      }

      *((void *)v3 + 2) = a1;
      int v23 = *a1;
      uint64_t v24 = a1;
      if (*a1)
      {
        uint64_t v24 = a1;
        do
        {
          __int128 v25 = &v24[v23];
          int v26 = v25[1];
          uint64_t v24 = v25 + 1;
          int v23 = v26;
        }

        while (v26);
      }

      char v15 = 0;
      uint64_t v14 = v24 - a1;
LABEL_12:
      a2 = 0;
      v3[37] = v15;
      *((void *)v3 + 3) = v14 + 1;
      *((_DWORD *)v3 + _Block_object_dispose(va, 8) = 0;
      v3[36] = 0;
      id v16 = v3;
      *((void *)v3 + 5) = 0LL;
      uint64_t v3 = 0LL;
      if (!a3) {
        goto LABEL_14;
      }
      goto LABEL_13;
    }

unsigned __int8 *dnssec_obj_domain_name_create_concatenation_with_subdomain( _BYTE *a1, _BYTE *a2, _DWORD *a3)
{
  int v5 = 0;
  memset(__dst, 0, sizeof(__dst));
  domain_name_labels_concatenate(a1, a2, (char *)__dst, &v5);
  if (v5)
  {
    CFDataRef result = 0LL;
    if (!a3) {
      return result;
    }
  }

  else
  {
    CFDataRef result = dnssec_obj_domain_name_create_with_labels((unsigned __int8 *)__dst, 1, &v5);
    if (!a3) {
      return result;
    }
  }

  *a3 = v5;
  return result;
}

unsigned __int8 *dnssec_obj_domain_name_copy_parent_domain(_BYTE *a1, unint64_t a2, int *a3)
{
  CFDataRef result = domain_name_labels_get_parent(a1, a2);
  if (result)
  {
    int v6 = 0;
    CFDataRef result = dnssec_obj_domain_name_create_with_labels(result, 1, &v6);
    int v5 = v6;
    if (!a3) {
      return result;
    }
  }

  else
  {
    int v5 = -6710;
    if (!a3) {
      return result;
    }
  }

  *a3 = v5;
  return result;
}

BOOL dnssec_obj_domain_name_is_sub_domain_of(unsigned __int8 *a1, unsigned __int8 *a2)
{
  int v3 = *a1;
  if (*a1)
  {
    unint64_t v4 = 0LL;
    int v5 = a1;
    do
    {
      ++v4;
      int v6 = &v5[v3];
      int v7 = v6[1];
      int v5 = v6 + 1;
      int v3 = v7;
    }

    while (v7);
  }

  else
  {
    unint64_t v4 = 0LL;
  }

  int v8 = *a2;
  if (*a2)
  {
    unint64_t v9 = 0LL;
    int v10 = a2;
    do
    {
      ++v9;
      BOOL v11 = &v10[v8];
      int v12 = v11[1];
      int v10 = v11 + 1;
      int v8 = v12;
    }

    while (v12);
  }

  else
  {
    unint64_t v9 = 0LL;
  }

  unint64_t v13 = v4 - v9;
  if (v4 <= v9) {
    return 0LL;
  }
  if (v13 < 0x100)
  {
    parent = domain_name_labels_get_parent(a1, v13);
    if (parent) {
      return domain_name_labels_canonical_compare(parent, a2, 1) == 0;
    }
    id v16 = (os_log_s *)mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      BOOL result = os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_FAULT);
      if (!result) {
        return result;
      }
    }

    else
    {
      id v16 = (os_log_s *)mDNSLogCategory_Default_redacted;
      BOOL result = os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_FAULT);
      if (!result) {
        return result;
      }
    }

    int v18 = 136447234;
    id v19 = "parent_labels != NULL";
    __int16 v20 = 2082;
    BOOL v21 = "";
    __int16 v22 = 2082;
    int v23 = "/Library/Caches/com.apple.xbs/Sources/mDNSResponder/mDNSShared/dns_objects/utilities/domain_name_labels.c";
    __int16 v24 = 1024;
    int v25 = 163;
    __int16 v26 = 2048;
    uint64_t v27 = 0LL;
    goto LABEL_30;
  }

  id v16 = (os_log_s *)mDNSLogCategory_Default;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
  {
    BOOL result = os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_FAULT);
    if (!result) {
      return result;
    }
    goto LABEL_21;
  }

  id v16 = (os_log_s *)mDNSLogCategory_Default_redacted;
  BOOL result = os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_FAULT);
  if (result)
  {
LABEL_21:
    int v18 = 136447234;
    id v19 = "sub_labels_label_count - labels_label_count <= UINT8_MAX";
    __int16 v20 = 2082;
    BOOL v21 = "";
    __int16 v22 = 2082;
    int v23 = "/Library/Caches/com.apple.xbs/Sources/mDNSResponder/mDNSShared/dns_objects/utilities/domain_name_labels.c";
    __int16 v24 = 1024;
    int v25 = 159;
    __int16 v26 = 2048;
    uint64_t v27 = 0LL;
LABEL_30:
    _os_log_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_FAULT,  "AssertMacros: %{public}s, %{public}s file: %{public}s, line: %d, value: %ld",  (uint8_t *)&v18,  0x30u);
    return 0LL;
  }

  return result;
}

unsigned __int8 *dnssec_obj_domain_name_copy_closest_common_ancestor( unsigned __int8 *a1, unsigned __int8 *a2, _DWORD *a3)
{
  if (a1 == a2)
  {
    int v12 = a1;
  }

  else
  {
    int v6 = *a1;
    if (*a1)
    {
      unint64_t v7 = 0LL;
      int v8 = *a1;
      unint64_t v9 = a1;
      do
      {
        ++v7;
        int v10 = &v9[v8];
        int v11 = v10[1];
        unint64_t v9 = v10 + 1;
        int v8 = v11;
      }

      while (v11);
    }

    else
    {
      unint64_t v7 = 0LL;
    }

    int v13 = *a2;
    if (*a2)
    {
      unint64_t v14 = 0LL;
      char v15 = a2;
      do
      {
        ++v14;
        id v16 = &v15[v13];
        int v17 = v16[1];
        char v15 = v16 + 1;
        int v13 = v17;
      }

      while (v17);
    }

    else
    {
      unint64_t v14 = 0LL;
    }

    int v12 = a1;
    if (*a1)
    {
      int v12 = a1;
      do
      {
        int v18 = &v12[v6];
        int v19 = v18[1];
        int v12 = v18 + 1;
        int v6 = v19;
      }

      while (v19);
    }

    if (v7 >= v14) {
      unint64_t v20 = v14;
    }
    else {
      unint64_t v20 = v7;
    }
    if (v20)
    {
      unint64_t v21 = v14 - 1;
      unint64_t v22 = v7 - 1;
      unint64_t v23 = 1LL;
      do
      {
        parent = domain_name_labels_get_parent(a1, v22);
        int v25 = domain_name_labels_get_parent(a2, v21);
        ++v23;
        --v21;
        --v22;
        int v12 = parent;
      }

      while (v23 <= v20);
    }
  }

  int v27 = 0;
  BOOL result = dnssec_obj_domain_name_create_with_labels(v12, 1, &v27);
  if (a3) {
    *a3 = v27;
  }
  return result;
}

uint64_t dnssec_obj_domain_name_get_nsec3_hashed_name(uint64_t a1, uint64_t a2)
{
  uint64_t result = *(void *)(a1 + 40);
  if (a2 && !result)
  {
    unint64_t v4 = *(unsigned __int8 **)(*(void *)(a2 + 16) + 16LL);
    unsigned int v5 = *v4;
    if (!*v4) {
      goto LABEL_33;
    }
    uint64_t v6 = 0LL;
    unint64_t v7 = *(unsigned __int8 **)(a2 + 24);
    int v8 = *v7;
    unint64_t v9 = (unint64_t)v7[2] << 8;
    uint64_t v10 = v7[3];
    uint64_t v35 = v7[4];
    int v11 = v7 + 5;
    uint64_t v12 = *(void *)(*(void *)(a2 + 16) + 16LL);
    do
    {
      ++v6;
      uint64_t v13 = v12 + v5;
      unsigned int v14 = *(unsigned __int8 *)(v13 + 1);
      uint64_t v12 = v13 + 1;
      unsigned int v5 = v14;
    }

    while (v14);
    if (!v6)
    {
LABEL_33:
      uint64_t v33 = -6742LL;
      goto LABEL_34;
    }

    parent = domain_name_labels_get_parent(v4, 1uLL);
    if (v8 == 1) {
      int v16 = 0;
    }
    else {
      int v16 = -6735;
    }
    int v36 = v16;
    if (v8 != 1)
    {
      uint64_t v33 = -6735LL;
      goto LABEL_34;
    }

    CFIndex v34 = parent;
    int v17 = domain_name_labels_create(*(_BYTE **)(a1 + 16), &v36);
    int v18 = v17;
    LODWORD(v33) = v36;
    if (!v36)
    {
      int v19 = *v17;
      unint64_t v20 = v17;
      if (*v17)
      {
        unint64_t v20 = v17;
        do
        {
          unint64_t v21 = &v20[v19];
          int v22 = v21[1];
          unint64_t v20 = v21 + 1;
          int v19 = v22;
        }

        while (v22);
      }

      memset(__dst, 0, 511);
      memset(__src, 0, 511);
      bzero(buf, 0x408uLL);
      if (!CCDigestInit(8LL, buf))
      {
        size_t v23 = v20 - v18 + 1;
        __memcpy_chk(__src, v18, v23, 511LL);
        uint64_t v24 = v9 + v10 + 1;
        while (!CCDigestUpdate(buf, __src, v23)
             && !CCDigestUpdate(buf, v11, v35)
             && !CCDigestFinal(buf, __src))
        {
          uint64_t OutputSize = CCDigestGetOutputSize(8LL);
          if (!OutputSize)
          {
            int v26 = -6735;
            goto LABEL_25;
          }

          size_t v23 = OutputSize;
          CCDigestReset(buf);
          if (!--v24)
          {
            memcpy(__dst, __src, v23);
            int v26 = 0;
            goto LABEL_25;
          }
        }
      }

      int v26 = -6700;
LABEL_25:
      int v36 = v26;
      uint64_t v27 = CCDigestGetOutputSize(8LL);
      memset(v39, 0, sizeof(v39));
      uint64_t v40 = 0LL;
      encoded_string_size_t length = base_x_get_encoded_string_length(2, v27);
      if (encoded_string_length > 0x3F)
      {
        LODWORD(v33) = -6751;
        if (!v18) {
          goto LABEL_31;
        }
        goto LABEL_30;
      }

      char v38 = encoded_string_length;
      v39[encoded_string_length] = 0;
      base_32_hex_encode(__dst, v27, 1, v39);
      memset(v37, 0, sizeof(v37));
      domain_name_labels_concatenate(&v38, v34, (char *)v37, &v36);
      LODWORD(v33) = v36;
      if (!v36)
      {
        id v29 = dnssec_obj_domain_name_create_with_labels((unsigned __int8 *)v37, 1, &v36);
        LODWORD(v33) = v36;
        if (!v36) {
          *(void *)(a1 + 40) = v29;
        }
      }
    }

    if (!v18)
    {
LABEL_31:
      if (!(_DWORD)v33) {
        return *(void *)(a1 + 40);
      }
      uint64_t v33 = (int)v33;
LABEL_34:
      __int128 v30 = (os_log_s *)mDNSLogCategory_DNSSEC;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_DNSSEC == mDNSLogCategory_State)
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC, OS_LOG_TYPE_FAULT)) {
          return 0LL;
        }
      }

      else
      {
        __int128 v30 = (os_log_s *)mDNSLogCategory_DNSSEC_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC_redacted, OS_LOG_TYPE_FAULT)) {
          return 0LL;
        }
      }

      *(_DWORD *)buf = 136447234;
      __int128 v43 = "err == 0";
      __int16 v44 = 2082;
      __int128 v45 = "";
      __int16 v46 = 2082;
      __int128 v47 = "/Library/Caches/com.apple.xbs/Sources/mDNSResponder/mDNSMacOSX/dnssec_v2/dnssec_objs/dnssec_obj_domain_name.c";
      __int16 v48 = 1024;
      int v49 = 413;
      __int16 v50 = 2048;
      uint64_t v51 = v33;
      _os_log_impl( (void *)&_mh_execute_header,  v30,  OS_LOG_TYPE_FAULT,  "AssertMacros: %{public}s, %{public}s file: %{public}s, line: %d, value: %ld",  buf,  0x30u);
      return 0LL;
    }

uint64_t *AuthGroupForName(uint64_t a1, unsigned int a2, _BYTE *a3)
{
  for (char i = *(uint64_t **)(a1 + 8LL * (a2 % 0x1F3) + 24); i; char i = (uint64_t *)*i)
  {
  }

  return i;
}

uint64_t *InsertAuthRecord(uint64_t a1, uint64_t a2)
{
  unint64_t v9 = AuthGroupForName(a1, *(_DWORD *)(a2 + 24), *(_BYTE **)(a2 + 40));
  if (v9) {
    goto LABEL_2;
  }
  uint64_t v10 = *(_BYTE **)(a2 + 40);
  int v11 = v10;
  if (v10 == (_BYTE *)-256LL) {
    goto LABEL_7;
  }
LABEL_4:
  unsigned __int16 v12 = 257;
  if (v11 < v10 + 256 && v11)
  {
    while (1)
    {
      uint64_t v13 = *v11;
      if (v13 > 0x3F)
      {
LABEL_12:
        unsigned __int16 v12 = 257;
        goto LABEL_14;
      }

      if (!*v11) {
        break;
      }
      v11 += v13 + 1;
      if (v10 != (_BYTE *)-256LL) {
        goto LABEL_4;
      }
LABEL_7:
      if (!v11) {
        goto LABEL_12;
      }
    }

    unsigned __int16 v12 = (_WORD)v11 - (_WORD)v10 + 1;
  }

LABEL_94:
      *(_DWORD *)buf = 141558531;
      uint64_t v54 = 1752392040LL;
      __int16 v55 = 1040;
      int v56 = v42;
      __int16 v57 = 2101;
      uint64_t v58 = v16;
      _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_DEFAULT,  "GetAuthGroup: Failed to allocate memory for %{sensitive, mask.hash, mdnsresponder:domain_name}.*P",  buf,  0x1Cu);
      return 0LL;
    }

    return 0LL;
  }

  *(_BYTE *)(a1 + 12) = 1;
  unint64_t v9 = *(uint64_t **)(a1 + 16);
  if (!v9)
  {
    int v19 = (uint64_t *)calloc(1uLL, 0xB0uLL);
    if (!v19)
    {
LABEL_43:
      __break(1u);
      goto LABEL_44;
    }

    unint64_t v9 = v19;
    *int v19 = 0LL;
    *(void *)(a1 + 16) = v19;
  }

  *(void *)(a1 + 16) = *v9;
  unsigned int v20 = *(_DWORD *)(a1 + 8);
  unsigned int v21 = *(_DWORD *)(a1 + 4) + 1;
  *(_DWORD *)(a1 + 4) = v21;
  if (v21 >= v20)
  {
    if (mDNS_LoggingEnabled == 1)
    {
      LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "RR Auth now using %ld objects",  v4,  v5,  v6,  v7,  v8,  v21);
      unsigned int v20 = *(_DWORD *)(a1 + 8);
    }

    if (v20 >= 0x3E8) {
      int v22 = 1000;
    }
    else {
      int v22 = 100;
    }
    if (v20 < 0x64) {
      int v22 = 10;
    }
    *(_DWORD *)(a1 + _Block_object_dispose(va, 8) = v22 + v20;
  }

  *((_OWORD *)v9 + 9) = 0u;
  *((_OWORD *)v9 + 10) = 0u;
  *((_OWORD *)v9 + 7) = 0u;
  *((_OWORD *)v9 + _Block_object_dispose(va, 8) = 0u;
  *((_OWORD *)v9 + 5) = 0u;
  *((_OWORD *)v9 + 6) = 0u;
  *((_OWORD *)v9 + 3) = 0u;
  *((_OWORD *)v9 + 4) = 0u;
  *((_OWORD *)v9 + 2) = 0u;
  *((_OWORD *)v9 + 1) = 0u;
  *(_OWORD *)unint64_t v9 = 0u;
  *(_BYTE *)(a1 + 12) = 0;
  unsigned int v23 = *(_DWORD *)(a2 + 24);
  uint64_t v24 = a1 + 8LL * (v23 % 0x1F3);
  uint64_t v26 = *(void *)(v24 + 24);
  int v25 = (uint64_t **)(v24 + 24);
  *unint64_t v9 = v26;
  *((_DWORD *)v9 + 2) = v23;
  v9[2] = 0LL;
  v9[3] = (uint64_t)(v9 + 2);
  v9[5] = 0LL;
  if (v12 <= 0x80u)
  {
    uint64_t v27 = v9 + 6;
  }

  else
  {
    uint64_t v27 = malloc(v12);
    if (!v27) {
      goto LABEL_43;
    }
  }

  v9[4] = (uint64_t)v27;
  __int128 v30 = *(_BYTE **)(a2 + 40);
  uint64_t v31 = v30;
  if (v30 == (_BYTE *)-256LL)
  {
LABEL_56:
    while (v31)
    {
      uint64_t v32 = *v31;
      if (!*v31)
      {
        unsigned __int16 v33 = (_WORD)v31 - (_WORD)v30 + 1;
        if (v33 > 0x100u) {
          break;
        }
        memcpy(v27, v30, v33);
        goto LABEL_64;
      }

      v31 += v32 + 1;
      if (v30 != (_BYTE *)-256LL) {
        goto LABEL_55;
      }
    }
  }

  else
  {
LABEL_55:
    if (v31 < v30 + 256) {
      goto LABEL_56;
    }
  }

  _BYTE *v27 = 0;
LABEL_64:
  if (AuthGroupForName(a1, *(_DWORD *)(a2 + 24), *(_BYTE **)(a2 + 40)))
  {
    CFIndex v34 = (os_log_s *)mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_104;
      }
      uint64_t v36 = *(void *)(a2 + 40);
      if (v36)
      {
        __int16 v37 = *(_BYTE **)(a2 + 40);
        if (v36 == -256)
        {
LABEL_74:
          while (v37)
          {
            uint64_t v38 = *v37;
            if (!*v37)
            {
              int v44 = (unsigned __int16)((_WORD)v37 - v36 + 1);
              goto LABEL_103;
            }

            v37 += v38 + 1;
            if (v36 != -256) {
              goto LABEL_73;
            }
          }
        }

        else
        {
LABEL_73:
        }

        int v44 = 257;
      }

      else
      {
        int v44 = 0;
      }

      goto LABEL_103;
    }

    CFIndex v34 = (os_log_s *)mDNSLogCategory_Default_redacted;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v36 = *(void *)(a2 + 40);
      if (v36)
      {
        uint64_t v40 = *(_BYTE **)(a2 + 40);
        if (v36 == -256)
        {
LABEL_83:
          while (v40)
          {
            uint64_t v41 = *v40;
            if (!*v40)
            {
              int v44 = (unsigned __int16)((_WORD)v40 - v36 + 1);
              goto LABEL_103;
            }

            v40 += v41 + 1;
            if (v36 != -256) {
              goto LABEL_82;
            }
          }
        }

        else
        {
LABEL_82:
        }

        int v44 = 257;
      }

      else
      {
        int v44 = 0;
      }

LABEL_103:
      *(_DWORD *)buf = 141558531;
      uint64_t v54 = 1752392040LL;
      __int16 v55 = 1040;
      int v56 = v44;
      __int16 v57 = 2101;
      uint64_t v58 = v36;
      _os_log_impl( (void *)&_mh_execute_header,  v34,  OS_LOG_TYPE_DEFAULT,  "GetAuthGroup: Already have AuthGroup for %{sensitive, mask.hash, mdnsresponder:domain_name}.*P",  buf,  0x1Cu);
    }
  }

      uint64_t v24 = *(void *)v24;
      if (!v24) {
        goto LABEL_104;
      }
    }

    uint64_t v26 = (os_log_s *)mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_87;
      }
      __int128 v28 = *(void *)(v24 + 40);
      if (v28)
      {
        uint64_t v29 = *(_BYTE **)(v24 + 40);
        if (v28 == -256) {
          goto LABEL_31;
        }
LABEL_28:
        __int128 v30 = 257;
        if ((unint64_t)v29 < v28 + 256 && v29)
        {
          while (1)
          {
            uint64_t v31 = *v29;
            if (v31 > 0x3F)
            {
LABEL_76:
              __int128 v30 = 257;
              goto LABEL_83;
            }

            if (!*v29) {
              break;
            }
            v29 += v31 + 1;
            if (v28 != -256) {
              goto LABEL_28;
            }
LABEL_31:
            if (!v29) {
              goto LABEL_76;
            }
          }

          __int128 v30 = (_WORD)v29 - v28 + 1;
        }

  if (v57)
  {
    while (1)
    {
      int v59 = *(unsigned __int8 *)v57;
      if (!*(_BYTE *)v57)
      {
        uint64_t v58 = (_WORD)v57 - (_WORD)a2 + 1;
        goto LABEL_130;
      }

      __int16 v57 = (unsigned __int16 *)((char *)v57 + v59 + 1);
LABEL_100:
      uint64_t v58 = 257;
      if (v57 >= a2 + 128 || !v57) {
        goto LABEL_130;
      }
    }
  }

  uint64_t v58 = 257;
LABEL_130:
  size_t v64 = v13 - v58;
  if (v64 >= 1)
  {
    uint64_t v70 = (unsigned __int8 *)a2 + v58;
    while (1)
    {
      size_t v71 = v64 - 2;
      if (v64 <= 2)
      {
        LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "PrintTypeBitmap: malformed bitmap, bitmaplen %d short",  v65,  v66,  v67,  v68,  v69,  v64);
        return v80;
      }

      __int128 v72 = v70[1];
      uint64_t v79 = v71 - v72;
      __int128 v73 = 0;
      __int128 v74 = v70 + 2;
      unint64_t v75 = *v70 << 8;
      else {
        __int16 v76 = 8 * v72;
      }
      do
      {
        if (((v74[(unint64_t)v73 >> 3] << (v73 & 7)) & 0x80) != 0)
        {
          DNSTypeName((unsigned __int16)(v75 + v73));
          v12 += mDNS_snprintf(&v80[v12]);
        }

        ++v73;
      }

      while (v76 != v73);
      uint64_t v70 = &v74[v72];
      size_t v64 = v79;
      if (v79 <= 0) {
        return v80;
      }
    }

    if (mDNS_LoggingEnabled == 1) {
      LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "PrintTypeBitmap: malformed nsec, bitmaplen %d wlen %d",  v65,  v66,  v67,  v68,  v69,  v64 - 2);
    }
  }

  return v80;
}

uint64_t *RemoveAuthRecord(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = (unsigned __int8 *)(a3 + 8);
  uint64_t v6 = AuthGroupForName(a2, *(_DWORD *)(a3 + 24), *(_BYTE **)(a3 + 40));
  uint64_t v7 = v6;
  if (!v6)
  {
    char v15 = (os_log_s *)mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
        return v7;
      }
    }

    else
    {
      char v15 = (os_log_s *)mDNSLogCategory_Default_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
        return v7;
      }
    }

    GetRRDisplayString_rdb(v5, (unsigned __int16 *)(*(void *)(a3 + 48) + 4LL), (_BYTE *)(a1 + 46976));
    *(_DWORD *)buf = 141558275;
    uint64_t v20 = 1752392040LL;
    __int16 v21 = 2085;
    int v22 = (_BYTE *)(a1 + 46976);
    _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_DEFAULT,  "RemoveAuthRecord: ERROR!! AuthGroup not found for %{sensitive, mask.hash}s",  buf,  0x16u);
    return v7;
  }

  unint64_t v9 = (void **)(v6 + 2);
  uint64_t v8 = (void *)v6[2];
  if (v8)
  {
    uint64_t v10 = (_BYTE *)(a1 + 46976);
    while (v8 != (void *)a3)
    {
      int v11 = (void *)*v8;
      unint64_t v9 = (void **)v8;
LABEL_16:
      uint64_t v8 = v11;
      if (!v11) {
        goto LABEL_17;
      }
    }

    unsigned __int16 v12 = (os_log_s *)mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
      {
LABEL_15:
        int v11 = (void *)**v9;
        *unint64_t v9 = v11;
        goto LABEL_16;
      }
    }

    else
    {
      unsigned __int16 v12 = (os_log_s *)mDNSLogCategory_Default_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_15;
      }
    }

    GetRRDisplayString_rdb(v5, (unsigned __int16 *)(*(void *)(a3 + 48) + 4LL), v10);
    *(_DWORD *)buf = 141558275;
    uint64_t v20 = 1752392040LL;
    __int16 v21 = 2085;
    int v22 = v10;
    _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEFAULT,  "RemoveAuthRecord: removing auth record %{sensitive, mask.hash}s from table",  buf,  0x16u);
    goto LABEL_15;
  }

uint64_t mDNS_AddressIsLocalSubnet(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  if (*a3 == 6)
  {
    uint64_t v4 = *(uint64_t **)(a1 + 12664);
    if (v4)
    {
      while (*((_DWORD *)v4 + 1566) != 6
           || v4[782] != a2
           || !*((_BYTE *)v4 + 6375)
           || ((a3[1] ^ *((_DWORD *)v4 + 1567)) & (_DWORD)v4[786]) != 0
           || ((a3[2] ^ *((_DWORD *)v4 + 1568)) & *((_DWORD *)v4 + 1573)) != 0
           || ((a3[3] ^ *((_DWORD *)v4 + 1569)) & (_DWORD)v4[787]) != 0
           || ((a3[4] ^ *((_DWORD *)v4 + 1570)) & *((_DWORD *)v4 + 1575)) != 0)
      {
        uint64_t v4 = (uint64_t *)*v4;
        if (!v4) {
          return 0LL;
        }
      }

      return 1LL;
    }
  }

  else if (*a3 == 4)
  {
    int v3 = *(uint64_t **)(a1 + 12664);
    if (v3)
    {
      while (*((_DWORD *)v3 + 1566) != 4
           || v3[782] != a2
           || !*((_BYTE *)v3 + 6375)
           || ((a3[1] ^ *((_DWORD *)v3 + 1567)) & (_DWORD)v3[786]) != 0)
      {
        int v3 = (uint64_t *)*v3;
        if (!v3) {
          return 0LL;
        }
      }

      return 1LL;
    }
  }

  return 0LL;
}

void AnswerQuestionByFollowingCNAME(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(void *)(a3 + 40);
  __int16 v7 = v6 + 4;
  uint64_t v8 = (_BYTE *)(a2 + 356);
  int v9 = SameDomainNameBytes((_BYTE *)(a2 + 356), (_BYTE *)(v6 + 4));
  unsigned int v10 = *(unsigned __int8 *)(a2 + 333);
  if (v10 <= 9 && v9 == 0)
  {
    uint64_t v18 = *(void **)(a2 + 72);
    unsigned int v54 = *(unsigned __int16 *)(a2 + 320);
    *(void *)(a2 + 72) = 0LL;
    int v19 = (os_log_s *)mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_57;
      }
      unsigned int v21 = __rev16(v54);
      int v22 = (_BYTE *)(v6 + 4);
      if (v6 == -260)
      {
LABEL_26:
        while (v22)
        {
          uint64_t v23 = *v22;
          if (!*v22)
          {
            unsigned __int16 v31 = (_WORD)v22 - v7 + 1;
            goto LABEL_56;
          }

          v22 += v23 + 1;
          if (v6 != -260) {
            goto LABEL_25;
          }
        }
      }

      else
      {
LABEL_25:
      }

      unsigned __int16 v31 = 257;
    }

    else
    {
      int v19 = (os_log_s *)mDNSLogCategory_Default_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
      {
LABEL_57:
        int v32 = *(unsigned __int16 *)(a2 + 320);
        if (*(_WORD *)(a2 + 320))
        {
          uint64_t v33 = *(void *)(a2 + 80);
          if (v33) {
            uint64_t v34 = *(void *)(v33 + 24);
          }
          else {
            uint64_t v34 = -1LL;
          }
          uint64_t v35 = *(void **)(a2 + 96);
          *(void *)(a2 + 8_Block_object_dispose(va, 8) = v34;
          *(void *)(a2 + 96) = 0LL;
        }

        else
        {
          uint64_t v35 = 0LL;
        }

        mDNS_StopQuery_internal(a1, a2);
        uint64_t v36 = *(void *)(a3 + 40);
        __int16 v37 = (const void *)(v36 + 4);
        unint64_t v38 = v36 + 260;
        __int16 v39 = (_BYTE *)(v36 + 4);
        if (v38)
        {
LABEL_64:
        }

        else
        {
LABEL_65:
          while (v39)
          {
            uint64_t v40 = *v39;
            if (!*v39)
            {
              unsigned __int16 v41 = (_WORD)v39 - (_WORD)v37 + 1;
              if (v41 > 0x100u) {
                break;
              }
              memcpy(v8, v37, v41);
              goto LABEL_73;
            }

            v39 += v40 + 1;
            if (v38) {
              goto LABEL_64;
            }
          }
        }

        *uint64_t v8 = 0;
LABEL_73:
        *(_DWORD *)(a2 + 200) = DomainNameHashValue((unint64_t)v8);
        if (!*(_WORD *)(a2 + 320) || !IsLocalDomain(v8))
        {
LABEL_99:
          char v49 = *(_BYTE *)(a2 + 333) + 1;
          *(_BYTE *)(a2 + 333) = v49;
          mDNS_StartQuery_internal(a1, a2);
          *(_BYTE *)(a2 + 333) = v49;
          if (v32)
          {
            if (!v35) {
              goto LABEL_106;
            }
            if (*(void *)(a2 + 40)) {
              goto LABEL_103;
            }
            if (*(void *)(a2 + 96)) {
              goto LABEL_103;
            }
            uint64_t v50 = *(void *)(a2 + 80);
            if (!v50) {
              goto LABEL_103;
            }
            uint64_t v51 = v35[4];
            uint64_t v52 = *(void *)(v50 + 24);
            if (v51) {
              uint64_t v51 = *(void *)(v51 + 24);
            }
            if (v52 != v51)
            {
LABEL_103:
              mdns_client_invalidate((uint64_t)v35);
            }

            else
            {
              os_retain(v35);
              __int128 v53 = *(void **)(a2 + 96);
              if (v53) {
                os_release(v53);
              }
              *(void *)(a2 + 96) = v35;
            }
          }

          else if (!v35)
          {
            goto LABEL_106;
          }

          os_release(v35);
LABEL_106:
          if (v18)
          {
            if (*(void *)(a2 + 40))
            {
              CloseSocketSet((uint64_t)v18);
              free(v18);
            }

            else
            {
              *(void *)(a2 + 72) = v18;
              *(_WORD *)(a2 + 320) = v54;
            }
          }

          return;
        }

        int v42 = (os_log_s *)mDNSLogCategory_Default;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
        {
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
          {
            unsigned int v43 = bswap32(*(unsigned __int16 *)(a2 + 320)) >> 16;
            uint64_t v46 = (_BYTE *)(v6 + 4);
            if (v6 == -260)
            {
LABEL_88:
              while (v46)
              {
                uint64_t v47 = *v46;
                if (!*v46)
                {
                  int v48 = (unsigned __int16)((_WORD)v46 - v7 + 1);
                  goto LABEL_97;
                }

                v46 += v47 + 1;
                if (v6 != -260) {
                  goto LABEL_87;
                }
              }
            }

            else
            {
LABEL_87:
            }

            int v48 = 257;
            goto LABEL_97;
          }
        }

        else
        {
          int v42 = (os_log_s *)mDNSLogCategory_Default_redacted;
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
          {
            unsigned int v43 = bswap32(*(unsigned __int16 *)(a2 + 320)) >> 16;
            int v44 = (_BYTE *)(v6 + 4);
            if (v6 == -260)
            {
LABEL_80:
              while (v44)
              {
                uint64_t v45 = *v44;
                if (!*v44)
                {
                  int v48 = (unsigned __int16)((_WORD)v44 - v7 + 1);
                  goto LABEL_97;
                }

                v44 += v45 + 1;
                if (v6 != -260) {
                  goto LABEL_79;
                }
              }
            }

            else
            {
LABEL_79:
            }

            int v48 = 257;
LABEL_97:
            *(_DWORD *)buf = 67109891;
            unsigned int v56 = v43;
            __int16 v57 = 2160;
            uint64_t v58 = 1752392040LL;
            __int16 v59 = 1040;
            int v60 = v48;
            __int16 v61 = 2101;
            uint64_t v62 = v6 + 4;
            _os_log_impl( (void *)&_mh_execute_header,  v42,  OS_LOG_TYPE_DEFAULT,  "[Q%d] AnswerQuestionByFollowingCNAME: Resolving a .local CNAME -- CNAME: %{sensitive, mask.hash, mdnsrespo nder:domain_name}.*P",  buf,  0x22u);
          }
        }

        *(_BYTE *)(a2 + 61_Block_object_dispose(va, 8) = 1;
        goto LABEL_99;
      }

      unsigned int v21 = __rev16(v54);
      __int128 v28 = (_BYTE *)(v6 + 4);
      if (v6 == -260)
      {
LABEL_42:
        while (v28)
        {
          uint64_t v29 = *v28;
          if (!*v28)
          {
            unsigned __int16 v31 = (_WORD)v28 - v7 + 1;
            goto LABEL_56;
          }

          v28 += v29 + 1;
          if (v6 != -260) {
            goto LABEL_41;
          }
        }
      }

      else
      {
LABEL_41:
      }

      unsigned __int16 v31 = 257;
    }

LABEL_56:
    *(_DWORD *)buf = 67110147;
    unsigned int v56 = v21;
    __int16 v57 = 2160;
    uint64_t v58 = 1752392040LL;
    __int16 v59 = 1040;
    int v60 = v31;
    __int16 v61 = 2101;
    uint64_t v62 = v6 + 4;
    __int16 v63 = 1024;
    unsigned int v64 = v10;
    _os_log_impl( (void *)&_mh_execute_header,  v19,  OS_LOG_TYPE_DEFAULT,  "[Q%u] AnswerQuestionByFollowingCNAME: following CNAME referral -- CNAME: %{sensitive, mask.hash, mdnsresponder:dom ain_name}.*P, referral count: %u",  buf,  0x28u);
    goto LABEL_57;
  }

  int v12 = v9;
  uint64_t v13 = (os_log_s *)mDNSLogCategory_Default;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
  {
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
    {
      unsigned int v15 = bswap32(*(unsigned __int16 *)(a2 + 320)) >> 16;
      uint64_t v16 = (_BYTE *)(v6 + 4);
      if (v6 == -260)
      {
LABEL_13:
        while (v16)
        {
          uint64_t v17 = *v16;
          if (!*v16)
          {
            int v30 = (unsigned __int16)((_WORD)v16 - v7 + 1);
            goto LABEL_54;
          }

          v16 += v17 + 1;
          if (v6 != -260) {
            goto LABEL_12;
          }
        }
      }

      else
      {
LABEL_12:
      }

      int v30 = 257;
      goto LABEL_54;
    }
  }

  else
  {
    uint64_t v13 = (os_log_s *)mDNSLogCategory_Default_redacted;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
    {
      unsigned int v15 = bswap32(*(unsigned __int16 *)(a2 + 320)) >> 16;
      int v25 = (_BYTE *)(v6 + 4);
      if (v6 == -260)
      {
LABEL_34:
        while (v25)
        {
          uint64_t v26 = *v25;
          if (!*v25)
          {
            int v30 = (unsigned __int16)((_WORD)v25 - v7 + 1);
            goto LABEL_54;
          }

          v25 += v26 + 1;
          if (v6 != -260) {
            goto LABEL_33;
          }
        }
      }

      else
      {
LABEL_33:
      }

      int v30 = 257;
LABEL_54:
      *(_DWORD *)buf = 67110403;
      unsigned int v56 = v15;
      __int16 v57 = 2160;
      uint64_t v58 = 1752392040LL;
      __int16 v59 = 1040;
      int v60 = v30;
      __int16 v61 = 2101;
      uint64_t v62 = v6 + 4;
      __int16 v63 = 1024;
      unsigned int v64 = v10;
      __int16 v65 = 1024;
      int v66 = v12;
      _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEFAULT,  "[Q%u] AnswerQuestionByFollowingCNAME: Not following CNAME referral -- CNAME: %{sensitive, mask.hash, mdnsrespond er:domain_name}.*P, referral count: %u, self referential: %{mdns:yesno}d",  buf,  0x2Eu);
    }
  }

  __int16 v37 = time(0LL);
  unint64_t v38 = 0LL;
  __int16 v39 = v37 - *(_DWORD *)(a1 + 160);
  do
  {
    size_t v69 = v38;
    uint64_t v40 = *(void **)(a1 + 8 * v38 + 280);
    if (v40)
    {
      while (1)
      {
        unsigned __int16 v41 = v40[2];
        if (v41) {
          break;
        }
LABEL_87:
        uint64_t v40 = (void *)*v40;
        if (!v40) {
          goto LABEL_88;
        }
      }

      while (1)
      {
        if (*(void *)(v41 + 32))
        {
          mDNS_Reconfirm_internal(a1, v41, 0x1388u);
        }

        else if (v39 >= 1)
        {
          int v42 = (4 * *(_DWORD *)(v41 + 16) - 8) / 5u;
          unsigned int v43 = *(_DWORD *)(a1 + 64);
          int v44 = *(_DWORD *)(v41 + 80);
          uint64_t v45 = (v43 - v44) / -1000 + v42;
          if (v39 > 0x2A300 || v39 >= v45)
          {
            uint64_t v50 = mDNSLogCategory_Default;
            if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
            {
              if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEBUG)) {
                goto LABEL_82;
              }
            }

            else
            {
              uint64_t v50 = mDNSLogCategory_Default_redacted;
              if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEBUG)) {
                goto LABEL_82;
              }
            }

            GetRRDisplayString_rdb( (unsigned __int8 *)(v41 + 8),  (unsigned __int16 *)(*(void *)(v41 + 48) + 4LL),  (_BYTE *)(a1 + 46976));
            *(_DWORD *)buf = 141558787;
            *(void *)&uint8_t buf[4] = 1752392040LL;
            *(_WORD *)&buf[12] = 2085;
            *(void *)&buf[14] = a1 + 46976;
            *(_WORD *)&buf[22] = 1024;
            LODWORD(v71) = v39;
            WORD2(v71) = 1024;
            *(_DWORD *)((char *)&v71 + 6) = v45;
            uint64_t v51 = (os_log_s *)v50;
            uint64_t v52 = "mDNSCoreMachineSleep: %{sensitive, mask.hash}s: Purging cache entry SleptTime %d, Remaining TTL %d";
            goto LABEL_81;
          }

          uint64_t v46 = -1000 * v39 + v44;
          *(_DWORD *)(v41 + 80) = v46;
          uint64_t v47 = v43 - (v46 + 1000 * v42);
          int v48 = gSensitiveLoggingEnabled;
          char v49 = (os_log_s *)mDNSLogCategory_Default;
          if (mDNSLogCategory_Default == mDNSLogCategory_State) {
            int v48 = 0;
          }
          if ((v47 & 0x80000000) == 0)
          {
            if ((v48 & 1) != 0)
            {
              char v49 = (os_log_s *)mDNSLogCategory_Default_redacted;
              if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEBUG))
              {
LABEL_80:
                GetRRDisplayString_rdb( (unsigned __int8 *)(v41 + 8),  (unsigned __int16 *)(*(void *)(v41 + 48) + 4LL),  (_BYTE *)(a1 + 46976));
                *(_DWORD *)buf = 141558787;
                *(void *)&uint8_t buf[4] = 1752392040LL;
                *(_WORD *)&buf[12] = 2085;
                *(void *)&buf[14] = a1 + 46976;
                *(_WORD *)&buf[22] = 1024;
                LODWORD(v71) = v45;
                WORD2(v71) = 1024;
                *(_DWORD *)((char *)&v71 + 6) = v39;
                uint64_t v51 = v49;
                uint64_t v52 = "mDNSCoreMachineSleep: %{sensitive, mask.hash}s: Purging after adjusting the remaining TTL %d by %d seconds";
LABEL_81:
                _os_log_impl((void *)&_mh_execute_header, v51, OS_LOG_TYPE_DEBUG, v52, buf, 0x22u);
              }
            }

            else if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEBUG))
            {
              goto LABEL_80;
            }

    if (v25)
    {
      if (v25 >= 0xA)
      {
        do
          __int128 v28 = arc4random() & 0x7F;
        while (v28 > 0x63);
        uint64_t v8 = v25 + v28 + 1;
      }

      else
      {
        uint64_t v8 = v25 + 1;
      }

      goto LABEL_62;
    }

    *(_DWORD *)int v30 = 67110147;
    *(_DWORD *)&v30[4] = a3;
    *(_WORD *)&v30[8] = 1024;
    *(_DWORD *)&v30[10] = 604800;
    *(_WORD *)&v30[14] = 2160;
    *(void *)&v30[16] = 1752392040LL;
    *(_WORD *)&v30[24] = 1040;
    *(_DWORD *)&v30[26] = v27;
    unsigned __int16 v31 = 2101;
    int v32 = v11;
    _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_ERROR,  "tsrTimestamp[%u] out of range (%u) on TSR for %{sensitive, mask.hash, mdnsresponder:domain_name}.*P",  v30,  0x28u);
    return 4294901756LL;
  }

  unsigned int v14 = (uint64_t)v8;
  *(void *)int v30 = 0LL;
  *(void *)&v30[8] = 0LL;
  clock_gettime(_CLOCK_MONOTONIC_RAW, (timespec *)v30);
  if (v14) {
    return updateTSRRecord(a1, v14, *(_DWORD *)v30 - a3, a4);
  }
  unsigned int v15 = 4294901755LL;
  int v19 = (os_log_s *)mDNSLogCategory_mDNS;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
  {
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_ERROR)) {
      return v15;
    }
    unsigned int v21 = *(void *)(a2 + 40);
    if (v21)
    {
      int v22 = *(_BYTE **)(a2 + 40);
      if (v21 == -256)
      {
LABEL_36:
        while (v22)
        {
          uint64_t v23 = *v22;
          if (!*v22)
          {
            uint64_t v29 = (unsigned __int16)((_WORD)v22 - v21 + 1);
            goto LABEL_65;
          }

          v22 += v23 + 1;
          if (v21 != -256) {
            goto LABEL_35;
          }
        }
      }

      else
      {
LABEL_35:
      }

      uint64_t v29 = 257;
    }

    else
    {
      uint64_t v29 = 0;
    }

uint64_t PerformNextPunycodeConversion(uint64_t a1, char *a2)
{
  unsigned int v2 = *(unsigned __int8 *)(a1 + 356);
  if (!*(_BYTE *)(a1 + 356)) {
    return 0LL;
  }
  uint64_t v4 = 0LL;
  uint64_t v5 = (_BYTE *)(a1 + 356);
  unint64_t v6 = a1 + 612;
  __int16 v7 = (const char *)(a1 + 356);
  while (1)
  {
    uint64_t result = 0LL;
    if (v2 > 0x3F) {
      return result;
    }
    int v9 = (unsigned __int8 *)&v7[v2 + 1];
    uint64_t v10 = 0LL;
    while ((v7[v10 + 1] & 0x80000000) == 0)
    {
      if (v2 == ++v10) {
        goto LABEL_10;
      }
    }

    uint64_t v4 = v7;
LABEL_10:
    unsigned int v2 = *v9;
    __int16 v7 = (const char *)v9;
    if (!*v9)
    {
      if (v4)
      {
        int v11 = &a2[v4 - v5];
        int v12 = a2 + 256;
        UErrorCode pErrorCode = U_ZERO_ERROR;
        UIDNAInfo v20 = (UIDNAInfo)xmmword_1001008A0;
        uint64_t v13 = uidna_openUTS46(0x22u, &pErrorCode);
        int32_t v14 = uidna_nameToASCII_UTF8( v13,  v4 + 1,  *(unsigned __int8 *)v4,  v11 + 1,  (_DWORD)v12 - ((_DWORD)v11 + 1),  &v20,  &pErrorCode);
        uidna_close(v13);
        if (pErrorCode == U_ZERO_ERROR && !v20.errors && v14 < 64)
        {
          *int v11 = v14;
          unsigned int v15 = &v11[v14 + 1];
          if (v15)
          {
            uint64_t v16 = (unsigned __int8 *)&v4[*(unsigned __int8 *)v4 + 1];
            size_t v17 = 257LL;
            uint64_t v18 = v16;
            if (v16 == (unsigned __int8 *)-256LL)
            {
LABEL_18:
              while (v18)
              {
                uint64_t v19 = *v18;
                if (!*v18)
                {
                  size_t v17 = (unsigned __int16)((_WORD)v18 - (_WORD)v16 + 1);
                  break;
                }

                v18 += v19 + 1;
              }
            }

            else
            {
LABEL_17:
              if (v18 < v16 + 256) {
                goto LABEL_18;
              }
            }

            if (&v15[v17] <= v12)
            {
              memcpy(a2, v5, ((_DWORD)v4 - (_DWORD)v5));
              memcpy(v15, v16, v17);
              return 1LL;
            }
          }
        }
      }

      return 0LL;
    }
  }

uint64_t CheckForSoonToExpireRecordsEx(uint64_t a1, _BYTE *a2, unsigned int a3, int a4, int a5)
{
  int v7 = *(_DWORD *)(a1 + 64);
  uint64_t v8 = CacheGroupForName(a1, a3, a2);
  if (v8)
  {
    uint64_t v9 = v8[2];
    if (v9)
    {
      BOOL v11 = a4 < 0 || a4 == 255;
      unsigned int v12 = v7 - 0x10000000;
      while (1)
      {
        if (v11)
        {
          BOOL v13 = 1;
          if (a5 < 0) {
            goto LABEL_14;
          }
        }

        else
        {
          BOOL v13 = *(unsigned __int16 *)(v9 + 12) == a4;
          if (a5 < 0)
          {
LABEL_14:
            BOOL v14 = 1;
            goto LABEL_15;
          }
        }

        BOOL v14 = *(unsigned __int16 *)(v9 + 14) == a5;
LABEL_15:
        if (v13 && v14)
        {
          int v15 = dword_100158BF8 + 939524096;
          if (!*(_BYTE *)(v9 + 109)) {
            int v15 = *(_DWORD *)(v9 + 80) + 1000 * *(_DWORD *)(v9 + 16);
          }
        }

        uint64_t v9 = *(void *)v9;
        if (!v9) {
          goto LABEL_26;
        }
      }
    }
  }

  unsigned int v12 = v7 - 0x10000000;
LABEL_26:
  if (v12 <= 1) {
    unsigned int v17 = 1;
  }
  else {
    unsigned int v17 = v12;
  }
  else {
    return v17;
  }
}

uint64_t DetermineUnicastQuerySuppression(uint64_t a1, uint64_t a2)
{
  if (*(_BYTE *)(a1 + 634))
  {
    int v3 = " (blocked by policy)";
    uint64_t v4 = 1LL;
    goto LABEL_3;
  }

  if (!a2)
  {
    if (!*(_BYTE *)(a1 + 618))
    {
      int v3 = " (no DNS service)";
      uint64_t v4 = 2LL;
      goto LABEL_3;
    }

    return 0LL;
  }

  int v13 = *(_DWORD *)(a1 + 304);
  if ((v13 & 0x8000000) != 0 && (*(_WORD *)(a2 + 276) & 8) != 0)
  {
    int v3 = " (interface is cellular)";
    uint64_t v4 = 3LL;
    goto LABEL_3;
  }

  if ((v13 & 0x20000000) != 0 && (*(_WORD *)(a2 + 276) & 0x40) != 0)
  {
    int v3 = " (interface is expensive)";
    uint64_t v4 = 4LL;
    goto LABEL_3;
  }

  if ((v13 & 0x2000) != 0 && (*(_WORD *)(a2 + 276) & 0x80) != 0)
  {
    int v3 = " (interface is constrained)";
    uint64_t v4 = 5LL;
    goto LABEL_3;
  }

  if (!*(_BYTE *)(a1 + 616)) {
    return 0LL;
  }
  int v14 = *(unsigned __int16 *)(a1 + 322);
  if (v14 == 28)
  {
    if ((*(_WORD *)(a2 + 276) & 4) == 0)
    {
      int v3 = " (AAAA records are unusable)";
      goto LABEL_50;
    }

    return 0LL;
  }

  if (v14 != 1 || (*(_WORD *)(a2 + 276) & 2) != 0) {
    return 0LL;
  }
  int v3 = " (A records are unusable)";
LABEL_50:
  uint64_t v4 = 6LL;
LABEL_3:
  uint64_t v5 = (os_log_s *)mDNSLogCategory_Default;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
  {
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
    {
      unsigned int v7 = bswap32(*(unsigned __int16 *)(a1 + 320)) >> 16;
      uint64_t v8 = (_BYTE *)(a1 + 356);
      if (a1 == -612)
      {
LABEL_11:
        while (v8)
        {
          uint64_t v9 = *v8;
          if (!*v8)
          {
            int v15 = (unsigned __int16)((_WORD)v8 - (a1 + 356) + 1);
            goto LABEL_42;
          }

          v8 += v9 + 1;
          if (a1 != -612) {
            goto LABEL_10;
          }
        }
      }

      else
      {
LABEL_10:
      }

      int v15 = 257;
      goto LABEL_42;
    }
  }

  else
  {
    uint64_t v5 = (os_log_s *)mDNSLogCategory_Default_redacted;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
    {
      unsigned int v7 = bswap32(*(unsigned __int16 *)(a1 + 320)) >> 16;
      BOOL v11 = (_BYTE *)(a1 + 356);
      if (a1 == -612)
      {
LABEL_19:
        while (v11)
        {
          uint64_t v12 = *v11;
          if (!*v11)
          {
            int v15 = (unsigned __int16)((_WORD)v11 - (a1 + 356) + 1);
            goto LABEL_42;
          }

          v11 += v12 + 1;
          if (a1 != -612) {
            goto LABEL_18;
          }
        }
      }

      else
      {
LABEL_18:
      }

      int v15 = 257;
LABEL_42:
      uint64_t v16 = DNSTypeName(*(unsigned __int16 *)(a1 + 322));
      v18[0] = 67110403;
      v18[1] = v7;
      __int16 v19 = 2160;
      uint64_t v20 = 1752392040LL;
      __int16 v21 = 1040;
      int v22 = v15;
      __int16 v23 = 2101;
      uint64_t v24 = a1 + 356;
      __int16 v25 = 2082;
      uint64_t v26 = v16;
      __int16 v27 = 2082;
      __int128 v28 = v3;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "[Q%u] DetermineUnicastQuerySuppression: Query suppressed for %{sensitive, mask.hash, mdnsresponder:domain_name}. *P %{public}s%{public}s",  (uint8_t *)v18,  0x36u);
    }
  }

  return v4;
}

uint64_t mDNS_PurgeBeforeResolve(uint64_t a1, uint64_t a2)
{
  uint64_t result = (uint64_t)CacheGroupForName(a1, *(_DWORD *)(a2 + 200), (_BYTE *)(a2 + 356));
  if (result)
  {
    uint64_t v10 = *(void *)(result + 16);
    if (v10)
    {
      while (1)
      {
        uint64_t result = SameNameRecordAnswersQuestion((unsigned __int8 *)(v10 + 8), 0, a2, v5, v6, v7, v8, v9);
        if ((_DWORD)result) {
          break;
        }
LABEL_14:
        uint64_t v10 = *(void *)v10;
        if (!v10) {
          return result;
        }
      }

      BOOL v11 = (os_log_s *)mDNSLogCategory_Default;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
        {
LABEL_13:
          uint64_t result = mDNS_PurgeCacheResourceRecord((unsigned int *)a1, v10);
          goto LABEL_14;
        }
      }

      else
      {
        BOOL v11 = (os_log_s *)mDNSLogCategory_Default_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_13;
        }
      }

      GetRRDisplayString_rdb( (unsigned __int8 *)(v10 + 8),  (unsigned __int16 *)(*(void *)(v10 + 48) + 4LL),  (_BYTE *)(a1 + 46976));
      *(_DWORD *)buf = 141558275;
      uint64_t v15 = 1752392040LL;
      __int16 v16 = 2085;
      uint64_t v17 = a1 + 46976;
      _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "mDNS_PurgeBeforeResolve: Flushing %{sensitive, mask.hash}s",  buf,  0x16u);
      goto LABEL_13;
    }
  }

  return result;
}

uint64_t SetNextCacheCheckTimeForRecord(uint64_t result, uint64_t a2)
{
  uint64_t v3 = result;
  if (*(_BYTE *)(a2 + 109)) {
    int v4 = dword_100158BF8 + 939524096;
  }
  else {
    int v4 = *(_DWORD *)(a2 + 80) + 1000 * *(_DWORD *)(a2 + 16);
  }
  *(_DWORD *)(a2 + 8_Block_object_dispose(va, 8) = v4;
  uint64_t v5 = *(void *)(a2 + 64);
  if (v5 && *(_DWORD *)(v5 + 32) == 1 && *(_BYTE *)(a2 + 108) != 4) {
    *(_BYTE *)(a2 + 10_Block_object_dispose(va, 8) = 4;
  }
  uint64_t v6 = *(void *)(a2 + 96);
  if (!v6)
  {
    unsigned int v12 = *(_DWORD *)(a2 + 24);
    goto LABEL_20;
  }

  unsigned int v7 = *(unsigned __int8 *)(a2 + 108);
  if (v7 < 4)
  {
    if (*(_BYTE *)(a2 + 108) || *(_BYTE *)(a2 + 130))
    {
      int v8 = -4;
    }

    else if (*(_WORD *)(v6 + 320))
    {
      int v8 = -4;
    }

    else
    {
      int v8 = -5;
    }

    unsigned int v9 = 1000 * *(_DWORD *)(a2 + 16);
    *(_DWORD *)(a2 + 8_Block_object_dispose(va, 8) = v4 + (int)v9 / 20 * (v8 + v7);
    unsigned int v10 = v9 / 0x32;
    unsigned int v11 = 1;
    if (v9 >= 0x64)
    {
      do
        unsigned int v11 = (2 * v11) | 1;
      while (v11 < v10);
    }

    do
      uint64_t result = arc4random();
    while ((result & v11) > v10);
    int v4 = *(_DWORD *)(a2 + 88) + (result & v11);
    *(_DWORD *)(a2 + 8_Block_object_dispose(va, 8) = v4;
    unsigned int v12 = *(_DWORD *)(a2 + 24);
    if (*(void *)(a2 + 96))
    {
      unsigned int v13 = *(_DWORD *)(a2 + 16);
      if (*(unsigned __int8 *)(a2 + 108) <= 3u)
      {
        int v14 = (int)(1000 * v13) / 50;
        goto LABEL_28;
      }

      goto LABEL_22;
    }

LABEL_20:
    int v14 = 60000;
    goto LABEL_28;
  }

  unsigned int v12 = *(_DWORD *)(a2 + 24);
  unsigned int v13 = *(_DWORD *)(a2 + 16);
LABEL_22:
  if (v13) {
    int v15 = 100;
  }
  else {
    int v15 = 0;
  }
  if (v13 <= 0xA) {
    int v14 = v15;
  }
  else {
    int v14 = 1000;
  }
LABEL_28:
  int v16 = v14 + v4;
  uint64_t v17 = v3 + 4LL * (v12 % 0x1F3);
  if (*(_DWORD *)(v17 + 4272) - v16 >= 1) {
    *(_DWORD *)(v17 + 4272) = v16;
  }
  if (*(_DWORD *)(v3 + 88) - v16 >= 1) {
    *(_DWORD *)(v3 + 8_Block_object_dispose(va, 8) = v16;
  }
  return result;
}

  uint64_t v18 = *(_DWORD *)(mDNSStorage[0] + 584);
  if (v18)
  {
    IOPMAssertionRelease(v18);
    *(_DWORD *)(mDNSStorage[0] + 584) = 0;
  }

  __int16 v19 = getprogname();
  uint64_t v20 = getpid();
  __int16 v21 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"%s.%d %s", v19, v20, v39);
  int v22 = v21;
  if (v21) {
    __int16 v23 = v21;
  }
  else {
    __int16 v23 = @"mDNSResponder";
  }
  IOPMAssertionCreateWithName(@"NoIdleSleepAssertion", 0xFFu, v23, (IOPMAssertionID *)(mDNSStorage[0] + 584));
  if (v22) {
    CFRelease(v22);
  }
  uint64_t v24 = (os_log_s *)mDNSLogCategory_SPS;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_SPS == mDNSLogCategory_State)
  {
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_SPS, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      goto LABEL_33;
    }
  }

  else
  {
    uint64_t v24 = (os_log_s *)mDNSLogCategory_SPS_redacted;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_SPS_redacted, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
LABEL_33:
      _os_log_impl( (void *)&_mh_execute_header,  v24,  OS_LOG_TYPE_DEFAULT,  "mDNSPlatformSetAllowSleep Creating NoIdleSleep power assertion",  buf,  2u);
    }
  }

    if (domain_name_labels_canonical_compare( *(unsigned __int8 **)(*(void *)(a1 + 16) + 16LL),  *((unsigned __int8 **)a2 + 4),  1)) {
      return 4294960548LL;
    }
    unsigned int v9 = calloc(1uLL, 0x10uLL);
    if (!v9)
    {
      __break(1u);
      return 4294960587LL;
    }

    *unsigned int v9 = a2;
    v9[1] = *(void *)(a1 + 24);
    *(_DWORD *)(a1 + 40) = 1;
    unsigned int v10 = *(void *)(a1 + 32) + 1LL;
    *(void *)(a1 + 24) = v9;
    *(void *)(a1 + 32) = v10;
    if (*a2 == 240 || v10 == v6) {
      *(_DWORD *)(a1 + 40) = 2;
    }
    unsigned int v11 = *((void *)a2 + 7);
    if (v11)
    {
      unsigned int v12 = *(_DWORD *)(v11 + 32);
      if (v12 == 1)
      {
        validation_uint64_t result = dnssec_obj_resource_record_member_get_validation_result(v11);
        uint64_t result = 0LL;
        *(void *)(a1 + 44) = validation_result;
        return result;
      }

      if (!v12)
      {
        uint64_t result = 0LL;
        *(void *)(a1 + 44) = 0xFFFFE5C200000000LL;
        return result;
      }
    }

    unsigned int v13 = (os_log_s *)mDNSLogCategory_DNSSEC;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_DNSSEC == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC, OS_LOG_TYPE_FAULT))
      {
        int v15 = *(_DWORD *)(v11 + 32);
        uint64_t v17 = 67109120;
        uint64_t v18 = v15;
        goto LABEL_35;
      }
    }

    else
    {
      unsigned int v13 = (os_log_s *)mDNSLogCategory_DNSSEC_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC_redacted, OS_LOG_TYPE_FAULT))
      {
        int v14 = *(_DWORD *)(v11 + 32);
        uint64_t v17 = 67109120;
        uint64_t v18 = v14;
LABEL_35:
        _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_FAULT,  "DNSSEC aware RR is neither to-be-validated or validated - aware type: %u.",  (uint8_t *)&v17,  8u);
      }
    }

    return 4294960540LL;
  }

  uint64_t v6 = *(void *)(v2 + 24);
  int v8 = *(unsigned __int8 ***)(a1 + 24);
  if (!v8)
  {
LABEL_19:
    if (*(void *)(a1 + 32) < v6) {
      goto LABEL_20;
    }
    return 4294960591LL;
  }

  while (*v8 != a2)
  {
    int v8 = (unsigned __int8 **)v8[1];
    if (!v8) {
      goto LABEL_19;
    }
  }

  return 4294960566LL;
}

    nw_release(*(void **)(a1 + 40));
    if (!a4) {
      return;
    }
    goto LABEL_21;
  }

  if (!a2)
  {
    if (_mdns_dns_service_log_s_once != -1) {
      dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_62);
    }
    int v15 = _mdns_dns_service_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)buf = 0;
      unsigned int v12 = "Failed to validate discovered service, ignoring";
      unsigned int v13 = (os_log_s *)v15;
      int v14 = 2;
      goto LABEL_19;
    }

    goto LABEL_20;
  }

  uint64_t v17 = 0;
  unsigned int v7 = _mdns_dns_service_create_discovered_alt( v6,  *(void **)(a1 + 40),  *(unsigned __int16 *)(a1 + 56),  a3,  (uint64_t)a4,  &v17);
  if (!v7)
  {
    if (_mdns_dns_service_log_s_once != -1) {
      dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_62);
    }
    int v16 = (os_log_s *)_mdns_dns_service_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 134217984;
      __int16 v19 = (char *)v17;
      _os_log_error_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_ERROR,  "Failed to create discovered DNS service -- error: %{mdns:err}ld",  buf,  0xCu);
    }

    goto LABEL_20;
  }

  int v8 = v7;
  uint64_t v17 = _mdns_dns_service_manager_add_pending_alt(*(CFArrayRef **)(a1 + 48), *(void *)(a1 + 32), v7);
  if (!v17)
  {
    if (_mdns_dns_service_log_s_once != -1) {
      dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_62);
    }
    unsigned int v9 = (os_log_s *)_mdns_dns_service_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 138412290;
      __int16 v19 = v8;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_INFO, "Registered discovered service -- %@", buf, 0xCu);
    }
  }

  nw_release(*(void **)(a1 + 40));
  os_release(v8);
  if (a4) {
LABEL_21:
  }
    free(a4);
}

          BYTE1(v22) = b32_hex_table[(v12 >> 30) & 0x1F];
          LOBYTE(v22) = b32_hex_table[v12 >> 35];
          if (!v10)
          {
            unsigned int v10 = 2LL;
            if ((a3 & 1) != 0) {
              goto LABEL_27;
            }
LABEL_25:
            memset((char *)&v22 + v10, 61, 8 - v10);
            goto LABEL_26;
          }

          if ((a3 & 1) != 0) {
            goto LABEL_27;
          }
          if (v10 <= 7) {
            goto LABEL_25;
          }
LABEL_26:
          unsigned int v10 = 8LL;
LABEL_27:
          uint64_t result = (unsigned __int8 *)memcpy(__dst, &v22, v10);
          __dst += v10;
          if (v7 >= v4) {
            return result;
          }
          continue;
      }
    }
  }

  return result;
}

      *((_DWORD *)v13 + 2) = v17;
      if (_mdns_resolver_log_s_once == -1) {
        goto LABEL_21;
      }
      goto LABEL_53;
    }

    uint64_t v18 = (uint64_t *)calloc(1uLL, 0x10uLL);
    if (v18)
    {
      __int16 v19 = v18;
      DomainNameDupEx(v16, v18 + 1, 0LL);
      *__int16 v19 = *v13;
      UIDNA *v13 = (uint64_t)v19;
      uint64_t v17 = *((_DWORD *)v13 + 2) + 1;
      goto LABEL_20;
    }

        if (_mdns_resolver_log_s_once != -1) {
          dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_48);
        }
        unsigned int v13 = (os_log_s *)_mdns_resolver_log_s_log;
        if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_ERROR))
        {
          int v15 = 138412290;
          int v16 = a4;
          _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "Got error %@", (uint8_t *)&v15, 0xCu);
        }

        Code = CFErrorGetCode((CFErrorRef)a4);
        if (Code) {
          a4 = Code;
        }
        else {
          a4 = 4294960596LL;
        }
        goto LABEL_27;
      }
    }

    else if (a2)
    {
      goto LABEL_6;
    }

    unsigned int v11 = 0LL;
    if (!a4) {
      goto LABEL_27;
    }
    goto LABEL_20;
  }

  mDNS_Lock_(*(unsigned int **)(a2 + 8), (uint64_t)"tcpConnectionCallback", 408);
  if (!a4)
  {
    if (a3)
    {
      uint64_t v24 = (os_log_s *)mDNSLogCategory_NAT;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_NAT == mDNSLogCategory_State)
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_83;
        }
        *(_WORD *)buf = 0;
      }

      else
      {
        uint64_t v24 = (os_log_s *)mDNSLogCategory_NAT_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT_redacted, OS_LOG_TYPE_DEFAULT))
        {
LABEL_83:
          if (mDNSPlatformWriteTCP((uint64_t)a1, *(const void **)(a2 + 64), *(int *)(a2 + 72)) == *(_DWORD *)(a2 + 72))
          {
LABEL_84:
            tcpConnectionCallback_LNTERRORsize_t count = 0;
            mDNS_Unlock_(*(void *)(a2 + 8), (uint64_t)"tcpConnectionCallback", 522);
            return;
          }

          uint64_t v20 = mDNSLogCategory_NAT;
          if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_NAT == mDNSLogCategory_State)
          {
            int v22 = 0;
            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_40;
            }
            *(_WORD *)buf = 0;
            __int16 v23 = "tcpConnectionCallback: error writing";
          }

          else
          {
            uint64_t v20 = mDNSLogCategory_NAT_redacted;
            int v22 = 0;
            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT_redacted, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_40;
            }
            *(_WORD *)buf = 0;
            __int16 v23 = "tcpConnectionCallback: error writing";
          }

          goto LABEL_38;
        }

        *(_WORD *)buf = 0;
      }

      _os_log_impl( (void *)&_mh_execute_header,  v24,  OS_LOG_TYPE_DEFAULT,  "tcpConnectionCallback: connection established, sending message",  buf,  2u);
      goto LABEL_83;
    }

    uint64_t v45 = mDNSPlatformReadTCP( (uint64_t)a1,  (void *)(*(void *)(a2 + 80) + *(void *)(a2 + 96)),  *(int *)(a2 + 88) - *(void *)(a2 + 96),  &v75);
    uint64_t v46 = (os_log_s *)mDNSLogCategory_NAT;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_NAT == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_104;
      }
      *(_DWORD *)buf = 134217984;
      uint64_t v77 = v45;
    }

    else
    {
      uint64_t v46 = (os_log_s *)mDNSLogCategory_NAT_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT_redacted, OS_LOG_TYPE_DEFAULT))
      {
LABEL_104:
        if (v45 < 0)
        {
          int v60 = mDNSLogCategory_NAT;
          if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_NAT == mDNSLogCategory_State)
          {
            int v22 = 0;
            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_40;
            }
            *(_DWORD *)buf = 134217984;
            uint64_t v77 = v45;
            __int16 v23 = "tcpConnectionCallback - read returned %ld";
          }

          else
          {
            int v60 = mDNSLogCategory_NAT_redacted;
            int v22 = 0;
            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT_redacted, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_40;
            }
            *(_DWORD *)buf = 134217984;
            uint64_t v77 = v45;
            __int16 v23 = "tcpConnectionCallback - read returned %ld";
          }

          __int16 v27 = (os_log_s *)v60;
LABEL_152:
          __int128 v28 = 12;
          goto LABEL_39;
        }

        if (v75)
        {
          __int128 v53 = mDNSLogCategory_NAT;
          if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_NAT == mDNSLogCategory_State)
          {
            int v22 = 0;
            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_40;
            }
            uint64_t v70 = *(void *)(a2 + 96);
            *(_DWORD *)buf = 134217984;
            uint64_t v77 = v70;
            __int16 v23 = "tcpConnectionCallback: socket closed by remote end %lu";
          }

          else
          {
            __int128 v53 = mDNSLogCategory_NAT_redacted;
            int v22 = 0;
            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT_redacted, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_40;
            }
            unsigned int v54 = *(void *)(a2 + 96);
            *(_DWORD *)buf = 134217984;
            uint64_t v77 = v54;
            __int16 v23 = "tcpConnectionCallback: socket closed by remote end %lu";
          }

          __int16 v27 = (os_log_s *)v53;
          goto LABEL_152;
        }

        __int16 v61 = *(void *)(a2 + 96) + v45;
        *(void *)(a2 + 96) = v61;
        uint64_t v62 = (os_log_s *)mDNSLogCategory_NAT;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_NAT == mDNSLogCategory_State)
        {
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_156;
          }
          *(_DWORD *)buf = 134217984;
          uint64_t v77 = v61;
        }

        else
        {
          uint64_t v62 = (os_log_s *)mDNSLogCategory_NAT_redacted;
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT_redacted, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_156;
          }
          *(_DWORD *)buf = 134217984;
          uint64_t v77 = v61;
        }

        _os_log_impl( (void *)&_mh_execute_header,  v62,  OS_LOG_TYPE_DEFAULT,  "tcpConnectionCallback tcpInfo->nread %lu",  buf,  0xCu);
LABEL_156:
        if (*(void *)(a2 + 96) <= 0x2000uLL) {
          goto LABEL_165;
        }
        size_t v71 = (os_log_s *)mDNSLogCategory_NAT;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_NAT == mDNSLogCategory_State)
        {
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_NAT, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)buf = 0;
            goto LABEL_163;
          }
        }

        else
        {
          size_t v71 = (os_log_s *)mDNSLogCategory_NAT_redacted;
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_NAT_redacted, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)buf = 0;
LABEL_163:
            _os_log_impl((void *)&_mh_execute_header, v71, OS_LOG_TYPE_DEFAULT, "result truncated...", buf, 2u);
          }
        }

        *(void *)(a2 + 96) = 0x2000LL;
LABEL_165:
        __int128 v72 = *(_DWORD *)(a2 + 32);
        int v22 = 1;
        switch(v72)
        {
          case 1:
            handleLNTDeviceDescriptionResponse((void *)a2, v63, v64, v65, v66, v67, v68, v69, v74);
            goto LABEL_84;
          case 2:
            handleLNTGetExternalAddressResponse((void *)a2);
            goto LABEL_84;
          case 3:
            handleLNTPortMappingResponse(a2, v63, v64, v65, v66, v67, v68, v69, v74);
            goto LABEL_84;
          case 4:
            goto LABEL_40;
          default:
            __int128 v73 = mDNSLogCategory_NAT;
            if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_NAT == mDNSLogCategory_State)
            {
              int v22 = 0;
              if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT, OS_LOG_TYPE_DEFAULT)) {
                goto LABEL_40;
              }
              *(_DWORD *)buf = 67109120;
              LODWORD(v77) = v72;
              __int16 v23 = "tcpConnectionCallback: bad tcp operation! %d";
            }

            else
            {
              __int128 v73 = mDNSLogCategory_NAT_redacted;
              int v22 = 0;
              if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT_redacted, OS_LOG_TYPE_DEFAULT)) {
                goto LABEL_40;
              }
              *(_DWORD *)buf = 67109120;
              LODWORD(v77) = v72;
              __int16 v23 = "tcpConnectionCallback: bad tcp operation! %d";
            }

            __int16 v27 = (os_log_s *)v73;
            __int128 v28 = 8;
            break;
        }

        goto LABEL_39;
      }

      *(_DWORD *)buf = 134217984;
      uint64_t v77 = v45;
    }

    _os_log_impl( (void *)&_mh_execute_header,  v46,  OS_LOG_TYPE_DEFAULT,  "tcpConnectionCallback: mDNSPlatformReadTCP read %ld bytes",  buf,  0xCu);
    goto LABEL_104;
  }

  uint64_t v20 = mDNSLogCategory_NAT;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_NAT == mDNSLogCategory_State)
  {
    int v22 = 0;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_NAT, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      __int16 v23 = "tcpConnectionCallback: received error";
LABEL_38:
      __int16 v27 = (os_log_s *)v20;
      __int128 v28 = 2;
LABEL_39:
      _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, v23, buf, v28);
      int v22 = 0;
    }
  }

  else
  {
    uint64_t v20 = mDNSLogCategory_NAT_redacted;
    uint64_t v26 = os_log_type_enabled((os_log_t)mDNSLogCategory_NAT_redacted, OS_LOG_TYPE_DEFAULT);
    int v22 = 0;
    if (v26)
    {
      *(_WORD *)buf = 0;
      __int16 v23 = "tcpConnectionCallback: received error";
      goto LABEL_38;
    }
  }

  if (*(_DWORD *)(v2 + 44)) {
    goto LABEL_21;
  }
  if (!dnssec_obj_rrset_is_dnskey(v2))
  {
    __int16 v19 = *(void *)(a1 + 56);
    if (!v19) {
      goto LABEL_21;
    }
    if (*(_WORD *)(v19 + 322) != 48) {
      goto LABEL_21;
    }
    uint64_t v20 = *(void **)(a1 + 64);
    if (!v20 || !v20[4]) {
      goto LABEL_21;
    }
    unsigned int v9 = dnssec_obj_rrset_copy_dnskeys(v20, &v107, (int *)&v106);
    if ((_DWORD)v106) {
      goto LABEL_22;
    }
    int v15 = v107;
    unsigned int v10 = 0LL;
LABEL_35:
    int v16 = *v6;
    if (*v6)
    {
      uint64_t v17 = *(void *)(a1 + 56);
      if (!v17) {
        goto LABEL_23;
      }
      if (*(_WORD *)(v17 + 322) != 48) {
        goto LABEL_23;
      }
      if (*(_DWORD *)(v16 + 44)) {
        goto LABEL_23;
      }
      uint64_t v18 = *(void *)(a1 + 64);
      if (!v18 || !*(void *)(v18 + 32)) {
        goto LABEL_23;
      }
      if (!v9)
      {
        unsigned int v9 = dnssec_obj_rrset_copy_dnskeys(*(void **)(a1 + 64), &v107, (int *)&v106);
        if ((_DWORD)v106) {
          goto LABEL_23;
        }
        int v16 = *v6;
        int v15 = v107;
      }
    }

    unsigned int v11 = 1;
LABEL_24:
    unsigned int v12 = *(void *)buf;
    if (*(void *)buf) {
      goto LABEL_25;
    }
LABEL_70:
    if (!v10) {
      goto LABEL_72;
    }
    goto LABEL_71;
  }

  if (*(void *)(a1 + 128))
  {
    if (*(_DWORD *)(a1 + 140) || *(_BYTE *)(a1 + 144)) {
      goto LABEL_21;
    }
    goto LABEL_34;
  }

  __int16 v21 = *(void *)(a1 + 56);
  if (!v21) {
    goto LABEL_21;
  }
  if (*(_WORD *)(v21 + 322) != 43) {
    goto LABEL_21;
  }
  int v22 = *(void *)(a1 + 64);
  if (!v22 || !*(void *)(v22 + 32)) {
    goto LABEL_21;
  }
  __int16 v23 = dnssec_obj_rrset_copy_dses_with_supported_algorithm(v22, (size_t *)buf, (int *)&v106);
  unsigned int v10 = (void *)v23;
  if ((_DWORD)v106 == -6727)
  {
LABEL_68:
    int v15 = 0LL;
    unsigned int v9 = 0LL;
    goto LABEL_35;
  }

  if ((_DWORD)v106)
  {
LABEL_59:
    unsigned int v9 = 0LL;
    goto LABEL_23;
  }

  unsigned int v12 = *(void *)buf;
  uint64_t v24 = *(void **)(*(void *)(a1 + 32) + 24LL);
  if (v24)
  {
    while (*(_WORD *)(*v24 + 4LL) != 46 || !*(void *)buf)
    {
LABEL_66:
      uint64_t v24 = (void *)v24[1];
      if (!v24) {
        goto LABEL_59;
      }
    }

    __int16 v25 = 0LL;
    uint64_t v26 = __rev16(*(unsigned __int16 *)(*(void *)(*v24 + 40LL) + 20LL));
    while (v26 != bswap32(**(unsigned __int16 **)(*(void *)(v23 + 8 * v25) + 24LL)) >> 16)
    {
      if (*(void *)buf == ++v25) {
        goto LABEL_66;
      }
    }

    goto LABEL_68;
  }

  unsigned int v9 = 0LL;
  unsigned int v11 = 0;
  if (!*(void *)buf) {
    goto LABEL_70;
  }
LABEL_25:
  unsigned int v13 = 0LL;
  do
  {
    int v14 = (void *)v10[v13];
    if (v14)
    {
      ref_count_obj_release(v14);
      v10[v13] = 0LL;
    }

    ++v13;
  }

  while (v13 < v12);
LABEL_71:
  free(v10);
LABEL_72:
  __int16 v27 = v107;
  if (v107)
  {
    __int128 v28 = 0LL;
    do
    {
      uint64_t v29 = (void *)v9[v28];
      if (v29)
      {
        ref_count_obj_release(v29);
        v9[v28] = 0LL;
      }

      ++v28;
    }

    while (v28 < v27);
  }

  else if (!v9)
  {
    goto LABEL_80;
  }

  free(v9);
LABEL_80:
  if (!v11) {
    return;
  }
  int v106 = 0LL;
  int v107 = 0LL;
  int v30 = *(_DWORD *)(a1 + 48);
  if (v30)
  {
    unsigned __int16 v31 = 0LL;
    int v32 = 0LL;
    uint64_t v33 = *(_DWORD *)(a1 + 52);
LABEL_83:
    int v108 = v33;
    goto LABEL_84;
  }

  unint64_t v38 = *(void *)(a1 + 32);
  if (v38)
  {
    __int16 v39 = *(_DWORD *)(v38 + 40);
    if (v39 != 2 && v39 != 4)
    {
      unsigned __int16 v31 = 0LL;
      int v32 = 0LL;
      int v30 = 0;
      uint64_t v33 = -6745;
      goto LABEL_83;
    }
  }

  int v108 = -6745;
  unsigned __int16 v41 = *(_DWORD *)(a1 + 112);
  if (v41)
  {
    int v42 = *(unsigned __int8 **)(a1 + 88);
    if (!v42)
    {
      if (v41 != 3)
      {
        unsigned __int16 v31 = 0LL;
        int v32 = 0LL;
        int v30 = 0;
        int v108 = 0;
        goto LABEL_84;
      }

      goto LABEL_106;
    }

    if (*v42 != 240
      || (unsigned int v43 = *((void *)v42 + 7)) == 0
      || *(_DWORD *)(v43 + 32) != 1
      || (int v44 = *(void *)(a1 + 16), dnssec_obj_resource_record_member_get_validation_result(v43) != 1)
      || !resource_record_get_insecure_validation_usable(v42))
    {
LABEL_106:
      unsigned __int16 v31 = 0LL;
      int v32 = 0LL;
      int v48 = -6700;
LABEL_107:
      int v108 = v48;
      goto LABEL_264;
    }

    *(_DWORD *)buf = 0;
    uint64_t v45 = dnssec_obj_domain_name_create_with_labels(*((unsigned __int8 **)v42 + 4), 0, (int *)buf);
    uint64_t v46 = v45;
    if (*(_DWORD *)buf)
    {
      if (v45) {
        ref_count_obj_release(v45);
      }
      goto LABEL_106;
    }

    if (ref_count_obj_compare(v44, (uint64_t)v45, 1LL))
    {
      is_sub_domain_of = dnssec_obj_domain_name_is_sub_domain_of( *(unsigned __int8 **)(v44 + 16),  *((unsigned __int8 **)v46 + 2));
      ref_count_obj_release(v46);
      if (!is_sub_domain_of) {
        goto LABEL_106;
      }
    }

    else if (v46)
    {
      ref_count_obj_release(v46);
    }

    int v93 = *(void *)(a1 + 32);
    if (v93) {
      *(void *)(v93 + 44) = 2LL;
    }
    uint64_t v94 = *(void *)(a1 + 40);
    if (v94) {
      *(void *)(v94 + 44) = 2LL;
    }
    int v32 = 0LL;
    unsigned __int16 v31 = 0LL;
    goto LABEL_233;
  }

  uint64_t v52 = *(void *)(a1 + 64);
  if (v52)
  {
    __int128 v53 = *(_DWORD *)(v52 + 44);
    if (v53 == 3) {
      goto LABEL_274;
    }
    unsigned int v54 = *(void *)(v52 + 32);
  }

  else
  {
    __int128 v53 = 0;
    unsigned int v54 = 0LL;
  }

  if (!v38) {
    goto LABEL_150;
  }
  __int16 v55 = *(_DWORD *)(v38 + 40);
  if (v55 != 4 && v55 != 2) {
    goto LABEL_150;
  }
  unsigned int v56 = *(_DWORD *)(v38 + 44);
  if (v56)
  {
    __int16 v57 = 0LL;
    unsigned __int16 v31 = 0LL;
    int v32 = 0LL;
    int v108 = *(_DWORD *)(v38 + 48);
    goto LABEL_130;
  }

  if (*(void *)(v38 + 32))
  {
    uint64_t v58 = *(unsigned __int8 ***)(v38 + 24);
    if (v58)
    {
      __int16 v59 = *v58;
      if (*v59 != 240)
      {
        int v60 = *((unsigned __int16 *)v59 + 2);
        if (v60 != 48 && (v60 != 46 || __rev16(*(unsigned __int16 *)(*((void *)v59 + 5) + 4LL)) != 48))
        {
          if (v54)
          {
            if (v53 == 1)
            {
              unsigned __int16 v31 = dnssec_obj_rrset_copy_dnskeys((void *)v52, &v107, &v108);
              if (!v108)
              {
                __int16 v57 = v107;
                unsigned int v56 = dnssec_obj_rrset_validate_with_dnskeys( *(uint64_t **)(a1 + 32),  (_DWORD **)v31,  v107,  (unsigned __int8 *)&v108);
                int v32 = 0LL;
LABEL_130:
                if (v56 == 3) {
                  goto LABEL_264;
                }
                goto LABEL_152;
              }

              int v32 = 0LL;
LABEL_291:
              int v30 = 0;
              goto LABEL_84;
            }

            if (v53 == 2)
            {
              int v32 = 0LL;
              goto LABEL_238;
            }

            goto LABEL_274;
          }

          goto LABEL_150;
        }
      }

      goto LABEL_138;
    }
  }

  uint64_t v105 = (os_log_s *)mDNSLogCategory_DNSSEC;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_DNSSEC == mDNSLogCategory_State)
  {
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC, OS_LOG_TYPE_FAULT)) {
      goto LABEL_138;
    }
  }

  else
  {
    uint64_t v105 = (os_log_s *)mDNSLogCategory_DNSSEC_redacted;
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC_redacted, OS_LOG_TYPE_FAULT)) {
      goto LABEL_138;
    }
  }

  *(_DWORD *)buf = 136447234;
  *(void *)&uint8_t buf[4] = "me->rr_count > 0 && me->rrs != NULL";
  *(_WORD *)&buf[12] = 2082;
  int v110 = "";
  __int128 v111 = 2082;
  int v112 = "/Library/Caches/com.apple.xbs/Sources/mDNSResponder/mDNSMacOSX/dnssec_v2/dnssec_objs/dnssec_obj_rrset.c";
  int v113 = 1024;
  int v114 = 267;
  uint64_t v115 = 2048;
  __int128 v116 = 0LL;
  _os_log_impl( (void *)&_mh_execute_header,  v105,  OS_LOG_TYPE_FAULT,  "AssertMacros: %{public}s, %{public}s file: %{public}s, line: %d, value: %ld",  buf,  0x30u);
LABEL_138:
  __int16 v61 = *(void *)(a1 + 128);
  if (v61)
  {
    uint64_t v62 = *(_DWORD ***)(a1 + 120);
    if (v62)
    {
      if (!*(_BYTE *)(a1 + 144))
      {
        uint64_t v86 = *(void *)(a1 + 32);
        int v87 = dnssec_obj_rrset_validate_with_dses_or_trust_anchors(v86, 0LL, 0LL, v62, v61, &v108);
        if (v87 == 3)
        {
          if (!*(_DWORD *)(v86 + 56)) {
            *(_DWORD *)(v86 + 44) = 0;
          }
          unsigned __int16 v31 = 0LL;
          int v32 = 0LL;
          *(_BYTE *)(a1 + 144) = 1;
          goto LABEL_264;
        }

        unsigned int v56 = v87;
        __int16 v57 = 0LL;
        goto LABEL_151;
      }
    }
  }

  if (v54)
  {
    if (v53 == 1)
    {
      int v32 = (_DWORD **)dnssec_obj_rrset_copy_dses_with_supported_algorithm(*(void *)(a1 + 64), &v106, &v108);
      if (v108 != -6727)
      {
        if (!v108)
        {
          unsigned int v56 = dnssec_obj_rrset_validate_with_dses_or_trust_anchors(*(void *)(a1 + 32), v32, v106, 0LL, 0LL, &v108);
          __int16 v57 = 0LL;
          unsigned __int16 v31 = 0LL;
          goto LABEL_130;
        }

        unsigned __int16 v31 = 0LL;
        goto LABEL_291;
      }

      goto LABEL_209;
    }

    if (v53 == 2)
    {
      int v32 = 0LL;
LABEL_209:
      unint64_t v38 = *(void *)(a1 + 32);
LABEL_238:
      __int16 v57 = 0LL;
      unsigned __int16 v31 = 0LL;
      unsigned int v56 = 2;
      *(void *)(v38 + 44) = 2LL;
      __int16 v63 = 1;
      goto LABEL_153;
    }

BOOL SameResourceRecordNameClassInterface( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a2)
  {
    uint64_t v8 = *(void *)(a1 + 32);
    if (!v8 || ((uint64_t v9 = *(void *)(a2 + 32)) != 0 ? (v10 = v8 == v9) : (v10 = 1), v10))
    {
      if (*(unsigned __int16 *)(a1 + 14) == *(unsigned __int16 *)(a2 + 14)
        && *(_DWORD *)(a1 + 24) == *(_DWORD *)(a2 + 24))
      {
        return SameDomainNameBytes(*(_BYTE **)(a1 + 40), *(_BYTE **)(a2 + 40)) != 0;
      }
    }
  }

  else
  {
    LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "SameResourceRecordSignature ERROR: r2 is NULL",  a4,  a5,  a6,  a7,  a8,  vars0);
  }

  return 0LL;
}

void ActivateUnicastRegistration(uint64_t a1, uint64_t a2)
{
  int v4 = *(unsigned __int16 *)(a2 + 12);
  if (v4 == 16)
  {
    uint64_t v5 = (uint64_t *)(a2 + 88);
  }

  else
  {
    if (v4 != 12) {
      goto LABEL_11;
    }
    uint64_t v5 = (uint64_t *)(a2 + 72);
  }

  uint64_t v6 = *v5;
  if (*v5)
  {
    unsigned int v7 = (unsigned __int8 *)(v6 + 8);
    if (*(_WORD *)(v6 + 12) == 33)
    {
      if (mDNS_LoggingEnabled == 1)
      {
        uint64_t v8 = (os_log_s *)mDNSLogCategory_Default;
        GetRRDisplayString_rdb(v7, (unsigned __int16 *)(*(void *)(v6 + 48) + 4LL), (_BYTE *)(a1 + 46976));
        DNSTypeName(*(unsigned __int16 *)(a2 + 12));
        LogMsgWithLevel( v8,  OS_LOG_TYPE_DEFAULT,  "ActivateUnicastRegistration: Found Service Record %s in state %d for %##s (%s)",  v9,  v10,  v11,  v12,  v13,  a1 + 46976);
      }

      *(_DWORD *)(a2 + 344) = *(_DWORD *)(v6 + 344);
    }

    else
    {
      int v14 = (os_log_s *)mDNSLogCategory_Default;
      GetRRDisplayString_rdb(v7, (unsigned __int16 *)(*(void *)(v6 + 48) + 4LL), (_BYTE *)(a1 + 46976));
      LogMsgWithLevel( v14,  OS_LOG_TYPE_DEFAULT,  "ActivateUnicastRegistration: ERROR!! Resource record %s wrong, expecting SRV type",  v15,  v16,  v17,  v18,  v19,  a1 + 46976);
    }
  }

uint64_t *CheckAuthRecordConflict(uint64_t a1, uint64_t a2)
{
  uint64_t result = AuthGroupForName(a1, *(_DWORD *)(a2 + 24), *(_BYTE **)(a2 + 40));
  if (result)
  {
    uint64_t v10 = result[2];
    if (v10)
    {
      while (1)
      {
        uint64_t v11 = *(void *)(a2 + 96);
        if (!v11) {
          uint64_t v11 = a2;
        }
        uint64_t v12 = *(void *)(v10 + 96);
        if (!v12) {
          uint64_t v12 = v10;
        }
        if (v11 != v12
          && *(unsigned __int16 *)(v10 + 12) == *(unsigned __int16 *)(a2 + 12)
          && SameResourceRecordNameClassInterface(v10, a2, v4, v5, v6, v7, v8, v9)
          && (!resource_records_have_same_dnssec_rr_category(*(void *)(v10 + 64), *(void *)(a2 + 64))
           || *(unsigned __int16 *)(v10 + 12) != *(unsigned __int16 *)(a2 + 12)
           || *(unsigned __int16 *)(v10 + 14) != *(unsigned __int16 *)(a2 + 14)
           || *(unsigned __int16 *)(v10 + 20) != *(unsigned __int16 *)(a2 + 20)
           || *(_DWORD *)(v10 + 28) != *(_DWORD *)(a2 + 28)
           || !SameRDataBody( v10 + 8,  (unsigned __int16 *)(*(void *)(a2 + 48) + 4LL),  (uint64_t (*)(uint64_t, unsigned __int16 *))SameDomainName)))
        {
          break;
        }

        uint64_t v10 = *(void *)v10;
        if (!v10) {
          return 0LL;
        }
      }

      return (uint64_t *)1;
    }

    else
    {
      return 0LL;
    }
  }

  return result;
}

uint64_t IdenticalResourceRecord(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a1 + 16) != *(_DWORD *)(a2 + 16)) {
    return 0LL;
  }
  uint64_t result = resource_records_have_same_dnssec_rr_category(*(void *)(a1 + 56), *(void *)(a2 + 56));
  if (!(_DWORD)result) {
    return result;
  }
  if (*(unsigned __int16 *)(a1 + 4) != *(unsigned __int16 *)(a2 + 4)
    || *(unsigned __int16 *)(a1 + 6) != *(unsigned __int16 *)(a2 + 6)
    || *(unsigned __int16 *)(a1 + 12) != *(unsigned __int16 *)(a2 + 12)
    || *(_DWORD *)(a1 + 20) != *(_DWORD *)(a2 + 20))
  {
    return 0LL;
  }

  uint64_t result = SameRDataBody( a1,  (unsigned __int16 *)(*(void *)(a2 + 40) + 4LL),  (uint64_t (*)(uint64_t, unsigned __int16 *))SameDomainName);
  if ((_DWORD)result) {
    return SameDomainNameBytes(*(_BYTE **)(a1 + 32), *(_BYTE **)(a2 + 32)) != 0;
  }
  return result;
}

uint64_t CheckAuthIdenticalRecord(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = AuthGroupForName(a1, *(_DWORD *)(a2 + 24), *(_BYTE **)(a2 + 40));
  if (!v3) {
    return 0LL;
  }
  for (uint64_t i = v3[2]; i; uint64_t i = *(void *)i)
  {
    if (*(void *)(i + 32) == *(void *)(a2 + 32))
    {
      int v5 = *(unsigned __int8 *)(i + 8);
      int v6 = *(unsigned __int8 *)(a2 + 8);
      BOOL v7 = v6 == 1 || v5 == 1;
      BOOL v8 = v7 || v5 == v6;
      BOOL v9 = v8 || (v6 | v5) == 18;
      if (v9
        && *(_DWORD *)(i + 24) == *(_DWORD *)(a2 + 24)
        && resource_records_have_same_dnssec_rr_category(*(void *)(i + 64), *(void *)(a2 + 64))
        && *(unsigned __int16 *)(i + 12) == *(unsigned __int16 *)(a2 + 12)
        && *(unsigned __int16 *)(i + 14) == *(unsigned __int16 *)(a2 + 14)
        && *(unsigned __int16 *)(i + 20) == *(unsigned __int16 *)(a2 + 20)
        && *(_DWORD *)(i + 28) == *(_DWORD *)(a2 + 28)
        && SameRDataBody( i + 8,  (unsigned __int16 *)(*(void *)(a2 + 48) + 4LL),  (uint64_t (*)(uint64_t, unsigned __int16 *))SameDomainName)
        && SameDomainNameBytes(*(_BYTE **)(i + 40), *(_BYTE **)(a2 + 40)))
      {
        if (*(_BYTE *)(i + 8) != 1) {
          return i;
        }
        *(_BYTE *)(i + 191) = 0;
      }
    }
  }

  return i;
}

void IncrementAutoTargetServices(uint64_t a1, uint64_t a2)
{
  if ((*(_DWORD *)(a2 + 172) & 0xFFFFFFFE) == 4)
  {
    uint64_t v4 = (os_log_s *)mDNSLogCategory_State;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEBUG))
    {
      int v5 = (_BYTE *)(a1 + 46976);
      GetRRDisplayString_rdb((unsigned __int8 *)(a2 + 8), (unsigned __int16 *)(*(void *)(a2 + 48) + 4LL), v5);
      int v18 = 141558275;
      *(void *)uint64_t v19 = 1752392040LL;
      *(_WORD *)&v19[8] = 2085;
      *(void *)&v19[10] = v5;
      _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEBUG,  "IncrementAutoTargetServices: called for RRLocalOnly() record: %{sensitive, mask.hash}s",  (uint8_t *)&v18,  0x16u);
    }

    return;
  }

  int v6 = (int *)(a1 + 19844);
  if (!*(void *)(a2 + 32) && !*(_BYTE *)(a2 + 122) && !IsLocalDomain(*(_BYTE **)(a2 + 40))) {
    goto LABEL_12;
  }
  int v7 = *(_DWORD *)(a1 + 19848) + 1;
  *(_DWORD *)(a1 + 1984_Block_object_dispose(va, 8) = v7;
  BOOL v8 = (os_log_s *)mDNSLogCategory_State;
  if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEBUG))
  {
    int v9 = *(_DWORD *)(a1 + 19852);
    GetRRDisplayString_rdb( (unsigned __int8 *)(a2 + 8),  (unsigned __int16 *)(*(void *)(a2 + 48) + 4LL),  (_BYTE *)(a1 + 46976));
    int v18 = 67109891;
    *(_DWORD *)uint64_t v19 = v7;
    *(_WORD *)&v19[4] = 1024;
    *(_DWORD *)&v19[6] = v9;
    *(_WORD *)&v19[10] = 2160;
    *(void *)&v19[12] = 1752392040LL;
    *(_WORD *)&v19[20] = 2085;
    *(void *)&v19[22] = a1 + 46976;
    _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEBUG,  "IncrementAutoTargetServices: NumAllInterfaceRecords %u NumAllInterfaceQuestions %u %{sensitive, mask.hash}s",  (uint8_t *)&v18,  0x22u);
    int v7 = *(_DWORD *)(a1 + 19848);
  }

  if (*(_DWORD *)(a1 + 19852) + v7 == 1)
  {
    *(_DWORD *)(a1 + 116) = 0;
    int v10 = 1;
    if (!*(_BYTE *)(a1 + 120))
    {
      *(_BYTE *)(a1 + 120) = 1;
      *(_DWORD *)(a1 + _Block_object_dispose(va, 8) = *(_DWORD *)(a1 + 64);
      int v10 = 0;
    }
  }

  else
  {
LABEL_12:
    int v10 = 1;
  }

  if ((*(void *)(a2 + 32) || *(_BYTE *)(a2 + 122) || IsLocalDomain(*(_BYTE **)(a2 + 40)))
    && *(_WORD *)(a2 + 12) == 33
    && *(_BYTE *)(a2 + 120) == 1)
  {
    if ((*(_DWORD *)(a2 + 172) & 0xFFFFFFFE) == 2)
    {
      int v11 = *(_DWORD *)(a1 + 10928) + 1;
      *(_DWORD *)(a1 + 1092_Block_object_dispose(va, 8) = v11;
      uint64_t v12 = (os_log_s *)mDNSLogCategory_State;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEBUG))
      {
        GetRRDisplayString_rdb( (unsigned __int8 *)(a2 + 8),  (unsigned __int16 *)(*(void *)(a2 + 48) + 4LL),  (_BYTE *)(a1 + 46976));
        int v18 = 67109635;
        *(_DWORD *)uint64_t v19 = v11;
        *(_WORD *)&v19[4] = 2160;
        *(void *)&v19[6] = 1752392040LL;
        *(_WORD *)&v19[14] = 2085;
        *(void *)&v19[16] = a1 + 46976;
        uint64_t v13 = "IncrementAutoTargetServices: AutoTargetAWDLIncludedCount %u Record %{sensitive, mask.hash}s";
LABEL_30:
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEBUG, v13, (uint8_t *)&v18, 0x1Cu);
      }
    }

    else
    {
      uint64_t v14 = *(void *)(a2 + 32);
      if (AWDLInterfaceID && AWDLInterfaceID == v14)
      {
        uint64_t v12 = (os_log_s *)mDNSLogCategory_State;
      }

      else
      {
        uint64_t v12 = (os_log_s *)mDNSLogCategory_State;
        if (!WiFiAwareInterfaceID || WiFiAwareInterfaceID != v14)
        {
          int v16 = *v6 + 1;
          *int v6 = v16;
          if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
          {
            GetRRDisplayString_rdb( (unsigned __int8 *)(a2 + 8),  (unsigned __int16 *)(*(void *)(a2 + 48) + 4LL),  (_BYTE *)(a1 + 46976));
            int v18 = 67109635;
            *(_DWORD *)uint64_t v19 = v16;
            *(_WORD *)&v19[4] = 2160;
            *(void *)&v19[6] = 1752392040LL;
            *(_WORD *)&v19[14] = 2085;
            *(void *)&v19[16] = a1 + 46976;
            uint64_t v13 = "IncrementAutoTargetServices: AutoTargetServices %u Record %{sensitive, mask.hash}s";
            goto LABEL_30;
          }

          goto LABEL_31;
        }
      }

      int v15 = *(_DWORD *)(a1 + 10932) + 1;
      *(_DWORD *)(a1 + 10932) = v15;
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
      {
        GetRRDisplayString_rdb( (unsigned __int8 *)(a2 + 8),  (unsigned __int16 *)(*(void *)(a2 + 48) + 4LL),  (_BYTE *)(a1 + 46976));
        int v18 = 67109635;
        *(_DWORD *)uint64_t v19 = v15;
        *(_WORD *)&v19[4] = 2160;
        *(void *)&v19[6] = 1752392040LL;
        *(_WORD *)&v19[14] = 2085;
        *(void *)&v19[16] = a1 + 46976;
        uint64_t v13 = "IncrementAutoTargetServices: AutoTargetAWDLOnlyCount %u Record %{sensitive, mask.hash}s";
        goto LABEL_30;
      }
    }

void mDNS_UpdateAllowSleep(uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 145)) {
    goto LABEL_11;
  }
  unsigned int v2 = (unsigned __int8 *)(a1 + 15032);
  if (*(_DWORD *)(a1 + 19832))
  {
    mDNS_snprintf(v39);
    uint64_t v3 = mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_20;
      }
      int v15 = *((_DWORD *)v2 + 1200);
      *(_DWORD *)buf = 67109120;
      LODWORD(v3_Block_object_dispose(va, 8) = v15;
      int v5 = "mDNS_UpdateAllowSleep: Sleep disabled because we are proxying %d records";
    }

    else
    {
      uint64_t v3 = mDNSLogCategory_Default_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_20;
      }
      int v4 = *((_DWORD *)v2 + 1200);
      *(_DWORD *)buf = 67109120;
      LODWORD(v3_Block_object_dispose(va, 8) = v4;
      int v5 = "mDNS_UpdateAllowSleep: Sleep disabled because we are proxying %d records";
    }

    int v16 = (os_log_s *)v3;
    uint32_t v17 = 8;
    goto LABEL_19;
  }

  if (!mDNSCoreHaveAdvertisedMulticastServices(*(void *)(a1 + 12624))
    || (uint64_t v13 = *(void *)(a1 + 12664)) == 0)
  {
LABEL_11:
    if (!*(_DWORD *)(mDNSStorage[0] + 584)) {
      return;
    }
    uint64_t v14 = (os_log_s *)mDNSLogCategory_SPS;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_SPS == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_SPS, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        goto LABEL_36;
      }
    }

    else
    {
      uint64_t v14 = (os_log_s *)mDNSLogCategory_SPS_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_SPS_redacted, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
LABEL_36:
        _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_DEFAULT,  "mDNSPlatformSetAllowSleep Destroying NoIdleSleep power assertion",  buf,  2u);
      }
    }

    IOPMAssertionRelease(*(_DWORD *)(mDNSStorage[0] + 584));
    *(_DWORD *)(mDNSStorage[0] + 584) = 0;
    return;
  }

  while (!*(_BYTE *)(v13 + 16))
  {
    uint64_t v13 = *(void *)v13;
    if (!v13) {
      goto LABEL_11;
    }
  }

void getKeepaliveRaddr(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v23 = 0LL;
  uint64_t v24 = 0LL;
  int v25 = 0;
  __int16 v21 = 0;
  __int16 v20 = 0;
  unsigned int v19 = 0;
  if (*(_WORD *)(a2 + 12) == 10)
  {
    uint64_t v6 = *(_BYTE **)(a2 + 40);
    uint64_t v7 = *v6 ? *v6 + 1LL : 0LL;
    if (SameDomainLabelPointer(&v6[v7], "\n_keepalive"))
    {
      mDNS_ExtractKeepaliveInfo(a2, &v19, &v23, (_DWORD *)a3, (uint64_t)v22, &v18, &v17, &v21, &v20, &v16);
      if (*(_DWORD *)a3 == 6)
      {
        if (vorr_s8( *(int8x8_t *)(a3 + 4),  (int8x8_t)*(_OWORD *)&vextq_s8(*(int8x16_t *)(a3 + 4), *(int8x16_t *)(a3 + 4), 8uLL)))
        {
          BOOL v15 = v21 == 0;
        }

        else
        {
          BOOL v15 = 1;
        }

        if (v15) {
          goto LABEL_8;
        }
      }

      else if (*(_DWORD *)a3 == 4 && !*(_DWORD *)(a3 + 4) || !v21)
      {
        goto LABEL_8;
      }

      if (!v20)
      {
LABEL_8:
        uint64_t v8 = (os_log_s *)mDNSLogCategory_Default;
        uint64_t v9 = (_BYTE *)(a1 + 46976);
        GetRRDisplayString_rdb((unsigned __int8 *)(a2 + 8), (unsigned __int16 *)(*(void *)(a2 + 48) + 4LL), v9);
        LogMsgWithLevel( v8,  OS_LOG_TYPE_DEFAULT,  "getKeepaliveRaddr: not a valid record %s for keepalive %#a:%d %#a:%d",  v10,  v11,  v12,  v13,  v14,  (int)v9);
      }
    }
  }

void mDNS_ExtractKeepaliveInfo( uint64_t a1, unsigned int *a2, _DWORD *a3, _DWORD *a4, uint64_t a5, unsigned int *a6, unsigned int *a7, _WORD *a8, _WORD *a9, _WORD *a10)
{
  if (*(_WORD *)(a1 + 12) != 10) {
    return;
  }
  BOOL v15 = *(_BYTE **)(a1 + 40);
  uint64_t v16 = *v15 ? *v15 + 1LL : 0LL;
  CFStringRef v22 = (unsigned __int8 *)(*(void *)(a1 + 48) + 5LL);
  uint64_t v23 = &v22[*(unsigned __int16 *)(a1 + 20)];
  unint64_t v24 = (unint64_t)(v23 - 1);
  if (v22 >= v23 - 1) {
    return;
  }
  unsigned int v25 = 0;
  uint64_t v45 = v23 - 2;
  while (1)
  {
    int v28 = *v22;
    ValueForIPv6Addr = v22 + 2;
    int v27 = v28;
    if (v28 <= 99)
    {
      if (v27 == 68)
      {
        *a4 = 6;
        unint64_t v31 = v24;
        int v32 = a4 + 1;
      }

      else
      {
        if (v27 != 72) {
          goto LABEL_21;
        }
        *a3 = 6;
        unint64_t v31 = v24;
        int v32 = a3 + 1;
      }

      ValueForIPv6Addr = GetValueForIPv6Addr((unint64_t)ValueForIPv6Addr, v31, v32, v17, v18, v19, v20, v21);
      goto LABEL_30;
    }

    switch(v27)
    {
      case 'd':
        *a4 = 4;
        int v29 = (_BYTE *)v24;
        uint64_t v30 = (uint64_t)(a4 + 1);
        goto LABEL_17;
      case 'm':
        ValueForIPv6Addr = (unsigned __int8 *)GetValueForMACAddr( (unint64_t)ValueForIPv6Addr,  v24,  a5,  v17,  v18,  v19,  v20,  v21);
        goto LABEL_30;
      case 'h':
        *a3 = 4;
        int v29 = (_BYTE *)v24;
        uint64_t v30 = (uint64_t)(a3 + 1);
LABEL_17:
        ValueForIPv6Addr = GetValueForIPv4Addr(ValueForIPv6Addr, v29, v30, v17, v18, v19, v20, v21);
        goto LABEL_30;
    }

_BYTE *GetValueForIPv4Addr( _BYTE *result, _BYTE *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (result >= a2)
  {
    int v8 = 0;
LABEL_15:
    LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "GetValueForIPv4Addr: Address malformed dots %d",  a4,  a5,  a6,  a7,  a8,  v8);
    return 0LL;
  }

  else
  {
    int v8 = 0;
    unsigned int v9 = 0;
    uint64_t v10 = a2 - result;
    do
    {
      int v11 = *result;
      if (v11 == 32) {
        goto LABEL_12;
      }
      if ((v11 - 48) > 9)
      {
        if (v11 != 46)
        {
          if (!*result && result == a2 - 1 && v8 == 3)
          {
            *(_BYTE *)(a3 + 3) = v9;
            return ++result;
          }

          uint64_t v12 = (os_log_s *)mDNSLogCategory_Default;
          goto LABEL_22;
        }

        if (v9 > 0xFF || v8 >= 3)
        {
          uint64_t v12 = (os_log_s *)mDNSLogCategory_Default;
LABEL_22:
          LogMsgWithLevel( v12,  OS_LOG_TYPE_DEFAULT,  "GetValueForIPv4Addr: something wrong ptr(%p) %c, limit %p, dots %d",  a4,  a5,  a6,  a7,  a8,  (int)result);
          return 0LL;
        }

        *(_BYTE *)(a3 + v8++) = v9;
        unsigned int v9 = 0;
      }

      else
      {
        unsigned int v9 = v11 + 10 * v9 - 48;
      }

      ++result;
      --v10;
    }

    while (v10);
    uint64_t result = a2;
LABEL_12:
    if (v8 != 3) {
      goto LABEL_15;
    }
    *(_BYTE *)(a3 + 3) = v9;
  }

  return result;
}

_BYTE *GetValueForIPv6Addr( unint64_t a1, unint64_t a2, void *__dst, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 >= a2)
  {
    int v12 = 0;
LABEL_25:
    uint64_t v20 = (os_log_s *)mDNSLogCategory_Default;
    int v26 = v12;
    uint64_t v21 = "GetValueForIPv6Addr: no trailing bytes after colon, numBytes is %d";
LABEL_26:
    LogMsgWithLevel(v20, OS_LOG_TYPE_DEFAULT, v21, a4, a5, a6, a7, a8, v26);
    return 0LL;
  }

  int v9 = 0;
  int v10 = 0;
  int v11 = 0;
  int v12 = 0;
  unsigned int v13 = 0;
  __int128 __src = 0uLL;
  unint64_t v14 = a2 - a1;
  BOOL v15 = (_BYTE *)(a1 + 1);
  while (1)
  {
    int v16 = *(v15 - 1);
    if (v16 == 32) {
      break;
    }
    if ((v16 - 48) >= 0xA)
    {
      if ((v16 - 65) >= 6)
      {
        int v17 = -87;
      }

      else
      {
        int v17 = -55;
      }
    }

    else
    {
      int v17 = -48;
    }

    int v18 = v17 + v16;
    if (v18 == -1)
    {
LABEL_12:
      if (v16 == 58)
      {
        if (v11)
        {
          if ((unint64_t)v15 < a2 && *v15 == 32)
          {
            uint64_t v20 = (os_log_s *)mDNSLogCategory_Default;
            uint64_t v21 = "GetValueForIPv6Addr: Trailing colon";
            goto LABEL_26;
          }

          if (v12 >= 14)
          {
            LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "GetValueForIPv6Addr:1: numBytes is %d",  a4,  a5,  a6,  a7,  a8,  v12);
            return 0LL;
          }

          *(_WORD *)((char *)&__src + v12) = bswap32(v13) >> 16;
          if (v12 == 13)
          {
            LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "GetValueForIPv6Addr:2: numBytes is %d",  a4,  a5,  a6,  a7,  a8,  15);
            return 0LL;
          }

          unsigned int v13 = 0;
          int v11 = 0;
          v12 += 2;
        }

        else
        {
          if (v9)
          {
            if (!v12)
            {
              uint64_t v19 = v15;
              if ((unint64_t)v15 < a2 && *v15 == 32)
              {
                *__dst = 0LL;
                __dst[1] = 0LL;
                return v19;
              }
            }

            LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "GetValueForIPv6Addr: zeroFillStart non-zero %d",  a4,  a5,  a6,  a7,  a8,  v10);
            return 0LL;
          }

          int v11 = 0;
          int v9 = 1;
          int v10 = v12;
        }
      }

      goto LABEL_21;
    }

    unsigned int v13 = v18 | (16 * v13);
    int v11 = 1;
LABEL_21:
    ++v15;
    if (!--v14)
    {
      uint64_t v19 = (_BYTE *)a2;
      if (!v11) {
        goto LABEL_25;
      }
      goto LABEL_30;
    }
  }

  uint64_t v19 = v15 - 1;
  if (!v11) {
    goto LABEL_25;
  }
LABEL_30:
  if (v12 >= 15)
  {
    LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "GetValueForIPv6Addr:3: numBytes is %d",  a4,  a5,  a6,  a7,  a8,  v12);
    return 0LL;
  }

  *(_WORD *)((char *)&__src + v12) = bswap32(v13) >> 16;
  if (v10)
  {
    if (v10 < 1) {
      int v10 = 0;
    }
    else {
      memcpy(__dst, &__src, v10);
    }
    LODWORD(v23) = v10;
    if (14 - v12 >= 1)
    {
      int v24 = v12 - 14;
      LODWORD(v23) = v10;
      do
      {
        *((_BYTE *)__dst + (int)v23) = 0;
        LODWORD(v23) = v23 + 1;
      }

      while (!__CFADD__(v24++, 1));
    }

    if ((int)v23 <= 15)
    {
      uint64_t v23 = (int)v23;
      do
        *((_BYTE *)__dst + v23++) = *((_BYTE *)&__src + v10++);
      while ((_DWORD)v23 != 16);
    }

    return v19;
  }

  if (v12 == 14)
  {
    *(_OWORD *)__dst = __src;
    return v19;
  }

  LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "GetValueForIPv6addr: Not enough bytes for IPv6 address, numBytes is %d",  a4,  a5,  a6,  a7,  a8,  v12 + 2);
  return 0LL;
}

unint64_t GetValueForMACAddr( unint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 >= a2)
  {
    int v10 = 0;
LABEL_22:
    LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "GetValueForMACAddr: Address malformed colons %d",  a4,  a5,  a6,  a7,  a8,  v10);
    return 0LL;
  }

  uint64_t v8 = 0LL;
  char v9 = 0;
  int v10 = 0;
  while (1)
  {
    int v11 = *(unsigned __int8 *)(a1 + v8);
    char v13 = v11 - 48;
    if ((v11 - 48) >= 0xA)
    {
      if ((v11 - 65) > 5)
      {
        if ((v11 - 97) > 5)
        {
          if (v11 == 58)
          {
            if (v10 >= 5)
            {
              LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "GetValueForMACAddr: Address malformed colons %d val %d",  a4,  a5,  a6,  a7,  a8,  v10);
              return 0LL;
            }

            *(_BYTE *)(a3 + v10) = v9;
            char v9 = 0;
            ++v10;
          }

          goto LABEL_13;
        }

        char v13 = v11 - 87;
      }

      else
      {
        char v13 = v11 - 55;
      }
    }

    char v9 = v13 | (16 * v9);
LABEL_13:
    if (a2 - a1 == ++v8) {
      goto LABEL_20;
    }
  }

  a2 = a1 + v8;
LABEL_20:
  if (v10 != 5) {
    goto LABEL_22;
  }
  *(_BYTE *)(a3 + 5) = v9;
  return a2;
}

uint64_t mDNSCoreHaveAdvertisedMulticastServices(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    while (1)
    {
      int v2 = *(unsigned __int16 *)(v1 + 12);
      if (v2 == 10)
      {
        uint64_t v3 = *(_BYTE **)(v1 + 40);
        if (*v3) {
          uint64_t v4 = *v3 + 1LL;
        }
        else {
          uint64_t v4 = 0LL;
        }
        int v2 = *(unsigned __int16 *)(v1 + 12);
      }

      if (v2 == 33
        && (*(void *)(v1 + 32) || *(_BYTE *)(v1 + 122) || IsLocalDomain(*(_BYTE **)(v1 + 40)))
        && *(_WORD *)(*(void *)(v1 + 48) + 8LL) != 2304)
      {
        return 1LL;
      }

      uint64_t v1 = *(void *)v1;
      if (!v1) {
        return 0LL;
      }
    }
  }

  return result;
}

uint64_t FindSPSInCache1(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8 = CacheGroupForName(a1, *(_DWORD *)(a2 + 200), (_BYTE *)(a2 + 356));
  if (!v8) {
    return 0LL;
  }
  uint64_t v14 = v8[2];
  if (!v14) {
    return 0LL;
  }
  uint64_t v15 = 0LL;
  unsigned int v16 = 1000000;
  do
  {
    if (*(_WORD *)(v14 + 12) == 12
      && v14 != a4
      && v14 != a3
      && *(unsigned __int16 *)(v14 + 20) >= 6u
      && SameNameRecordAnswersQuestion((unsigned __int8 *)(v14 + 8), 0, a2, v9, v10, v11, v12, v13)
      && (!resource_records_have_same_dnssec_rr_category(*(void *)(v14 + 64), *(void *)(a1 + 16352))
       || *(unsigned __int16 *)(v14 + 12) != *(unsigned __int16 *)(a1 + 16300)
       || *(unsigned __int16 *)(v14 + 14) != *(unsigned __int16 *)(a1 + 16302)
       || *(unsigned __int16 *)(v14 + 20) != *(unsigned __int16 *)(a1 + 16308)
       || *(_DWORD *)(v14 + 28) != *(_DWORD *)(a1 + 16316)
       || !SameRDataBody( v14 + 8,  (unsigned __int16 *)(*(void *)(a1 + 16336) + 4LL),  (uint64_t (*)(uint64_t, unsigned __int16 *))SameDomainName)))
    {
      int v17 = *(unsigned __int8 **)(v14 + 48);
      unsigned int v18 = v17[4];
      unsigned int v19 = 1000000;
      if (v18 >= 5)
      {
        int v20 = v17[5];
        if ((v20 - 48) <= 9)
        {
          int v21 = v17[6];
          if ((v21 - 48) <= 9)
          {
            int v22 = v17[8];
            if ((v22 - 48) <= 9)
            {
              int v23 = v17[9];
              if ((v23 - 48) <= 9
                && (v18 < 0xB
                 || v23 != 57
                 || v22 != 57
                 || v17[7] != 45
                 || v17[10] != 45
                 || v17[11] != 57
                 || v17[12] != 57
                 || v17[13] != 45
                 || v17[14] != 57
                 || v17[15] != 57))
              {
                unsigned int v19 = 10000 * v21 + 100000 * v20 + 1000 * v22 + 100 * v23 + 10 * v17[11] + v17[12] - 5333328;
              }
            }
          }
        }
      }

      if (v16 > v19) {
        uint64_t v15 = v14;
      }
      if (v16 >= v19) {
        unsigned int v16 = v19;
      }
    }

    uint64_t v14 = *(void *)v14;
  }

  while (v14);
  return v15;
}

void AdvertiseInterfaceIfNeeded(_DWORD *a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 6256);
  if (AWDLInterfaceID) {
    BOOL v5 = AWDLInterfaceID == v4;
  }
  else {
    BOOL v5 = 0;
  }
  if (v5 || (WiFiAwareInterfaceID ? (BOOL v6 = WiFiAwareInterfaceID == v4) : (BOOL v6 = 0), v6))
  {
    if (a1[2732] || a1[2733])
    {
      int v7 = 0;
      goto LABEL_16;
    }
  }

  else
  {
    if (a1[4961]) {
      AdvertiseInterface((uint64_t)a1, a2, 0);
    }
    if (a1[2732])
    {
      int v7 = 1;
LABEL_16:
      AdvertiseInterface((uint64_t)a1, a2, v7);
    }
  }

void mDNS_RandomizedHostNameCallback(uint64_t a1, uint64_t a2, int a3)
{
  if (a3 == -65548)
  {
    memset(v33, 0, sizeof(v33));
    GetRandomUUIDLabel(v33);
    mDNS_Lock_((unsigned int *)a1, (uint64_t)"mDNS_RandomizedHostNameCallback", 16719);
    *(_BYTE *)(a1 + 10672) = 0;
    AppendDomainLabel((_BYTE *)(a1 + 10672), (unsigned __int8 *)v33);
    AppendLiteralLabelString((_BYTE *)(a1 + 10672), "local");
    DeadvertiseAllInterfaceRecords(a1, 2);
    AdvertiseNecessaryInterfaceRecords(a1);
    for (uint64_t i = *(void *)(a1 + 12624); i; uint64_t i = *(void *)i)
    {
      if (*(_BYTE *)(i + 120))
      {
        if ((*(_DWORD *)(i + 172) & 0xFFFFFFFE) == 2
          || ((uint64_t v12 = *(void *)(i + 32), AWDLInterfaceID) ? (v13 = AWDLInterfaceID == v12) : (v13 = 0),
              v13 || (WiFiAwareInterfaceID ? (BOOL v14 = WiFiAwareInterfaceID == v12) : (BOOL v14 = 0), v14)))
        {
          D2D_stop_advertising_record(i, v4, v5, v6, v7, v8, v9, v10);
          SetTargetToHostName(a1, i);
          D2D_start_advertising_record(i, v15, v16, v17, v18, v19, v20, v21);
        }
      }
    }

    for (uint64_t j = *(void *)(a1 + 12632); j; uint64_t j = *(void *)j)
    {
      if (*(_BYTE *)(j + 120))
      {
        if ((*(_DWORD *)(j + 172) & 0xFFFFFFFE) == 2
          || ((uint64_t v23 = *(void *)(j + 32), AWDLInterfaceID) ? (v24 = AWDLInterfaceID == v23) : (v24 = 0),
              v24 || (WiFiAwareInterfaceID ? (BOOL v25 = WiFiAwareInterfaceID == v23) : (BOOL v25 = 0), v25)))
        {
          D2D_stop_advertising_record(j, v4, v5, v6, v7, v8, v9, v10);
          SetTargetToHostName(a1, j);
          D2D_start_advertising_record(j, v26, v27, v28, v29, v30, v31, v32);
        }
      }
    }

    mDNS_Unlock_(a1, (uint64_t)"mDNS_RandomizedHostNameCallback", 16736);
  }

uint64_t *GetFirstAddressRecordEx(uint64_t *result, int a2)
{
  if (result)
  {
    while (1)
    {
      if (*((_BYTE *)result + 6374))
      {
        uint64_t v2 = result[782];
        BOOL v3 = WiFiAwareInterfaceID && WiFiAwareInterfaceID == v2;
        BOOL v4 = v3;
        BOOL v5 = AWDLInterfaceID != v2 || AWDLInterfaceID == 0;
        if (v5 && !v4) {
          break;
        }
      }

      uint64_t result = (uint64_t *)*result;
      if (!result) {
        return result;
      }
    }

    if (a2) {
      result += 635;
    }
    else {
      result += 341;
    }
  }

  return result;
}

void DeadvertiseAllInterfaceRecords(uint64_t a1, char a2)
{
  for (uint64_t i = *(void *)(a1 + 12664); i; uint64_t i = *(void *)i)
  {
    if (*(_BYTE *)(i + 6374)) {
      DeadvertiseInterface(a1, i, a2);
    }
  }

uint64_t AdvertiseNecessaryInterfaceRecords(uint64_t result)
{
  uint64_t v1 = *(uint64_t **)(result + 12664);
  if (v1)
  {
    uint64_t v2 = result;
    do
    {
      if (*((_BYTE *)v1 + 6374)) {
        uint64_t result = AdvertiseInterfaceIfNeeded(v2, v1);
      }
      uint64_t v1 = (uint64_t *)*v1;
    }

    while (v1);
  }

  return result;
}

unint64_t CompleteRDataUpdate( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10 = *(void *)(a2 + 48);
  uint64_t v11 = *(unsigned __int16 *)(a2 + 20);
  unint64_t result = SetNewRData(a2 + 8, *(void *)(a2 + 304), *(unsigned __int16 *)(a2 + 312), a4, a5, a6, a7, a8);
  *(void *)(a2 + 304) = 0LL;
  BOOL v13 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(a2 + 320);
  if (v13) {
    return v13(a1, a2, v10, v11);
  }
  return result;
}

void RecordProbeFailure(_DWORD *a1, uint64_t a2)
{
  int v2 = a1[16];
  a1[3168] = v2;
  unsigned int v3 = a1[3169] + 1;
  a1[3169] = v3;
  if (v3 >= 0xF)
  {
    unsigned int v5 = v2 + 5000;
    if (v5 <= 1) {
      unsigned int v5 = 1;
    }
    a1[3170] = v5;
    uint64_t v6 = (os_log_s *)mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
        return;
      }
      uint64_t v8 = *(void *)(a2 + 40);
      if (v8)
      {
        uint64_t v9 = *(_BYTE **)(a2 + 40);
        if (v8 == -256)
        {
LABEL_13:
          while (v9)
          {
            uint64_t v10 = *v9;
            if (!*v9)
            {
              int v14 = (unsigned __int16)((_WORD)v9 - v8 + 1);
              goto LABEL_33;
            }

            v9 += v10 + 1;
            if (v8 != -256) {
              goto LABEL_12;
            }
          }
        }

        else
        {
LABEL_12:
        }

        int v14 = 257;
      }

      else
      {
        int v14 = 0;
      }

      goto LABEL_33;
    }

    uint64_t v6 = (os_log_s *)mDNSLogCategory_Default_redacted;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v8 = *(void *)(a2 + 40);
      if (v8)
      {
        uint64_t v12 = *(_BYTE **)(a2 + 40);
        if (v8 == -256)
        {
LABEL_22:
          while (v12)
          {
            uint64_t v13 = *v12;
            if (!*v12)
            {
              int v14 = (unsigned __int16)((_WORD)v12 - v8 + 1);
              goto LABEL_33;
            }

            v12 += v13 + 1;
            if (v8 != -256) {
              goto LABEL_21;
            }
          }
        }

        else
        {
LABEL_21:
        }

        int v14 = 257;
      }

      else
      {
        int v14 = 0;
      }

uint64_t *mDNSGetTSRForAuthRecordNamed(uint64_t *a1, _BYTE *a2, int a3)
{
  unsigned int v3 = a1;
  if (a1)
  {
    while (*((_WORD *)v3 + 6) != 41
         || *((_DWORD *)v3 + 6) != a3
         || !SameDomainNameBytes((_BYTE *)v3[5], a2))
    {
      unsigned int v3 = (uint64_t *)*v3;
      if (!v3) {
        return v3;
      }
    }

    int v7 = *(unsigned __int16 *)(v3[6] + 4);
    if (v7 != 65002)
    {
      uint64_t v8 = (os_log_s *)mDNSLogCategory_Default;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
      {
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_ERROR))
        {
          int v9 = 67109120;
          int v10 = v7;
          goto LABEL_14;
        }
      }

      else
      {
        uint64_t v8 = (os_log_s *)mDNSLogCategory_Default_redacted;
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_ERROR))
        {
          int v9 = 67109120;
          int v10 = v7;
LABEL_14:
          _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_ERROR,  "mDNSGetTSRForAuthRecordNamed: Found OPT that is not kDNSOpt_TSR (%d)",  (uint8_t *)&v9,  8u);
        }
      }

      return 0LL;
    }
  }

  return v3;
}

uint64_t *mDNSGetTSRForCacheGroup(uint64_t a1)
{
  unint64_t result = *(uint64_t **)(a1 + 16);
  if (result)
  {
    while (*((_WORD *)result + 6) != 41)
    {
      unint64_t result = (uint64_t *)*result;
      if (!result) {
        return result;
      }
    }

    int v2 = *(unsigned __int16 *)(result[6] + 4);
    if (v2 != 65002)
    {
      unsigned int v3 = (os_log_s *)mDNSLogCategory_Default;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_ERROR)) {
          return 0LL;
        }
        int v6 = 67109120;
        int v7 = v2;
      }

      else
      {
        unsigned int v3 = (os_log_s *)mDNSLogCategory_Default_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_ERROR)) {
          return 0LL;
        }
        int v6 = 67109120;
        int v7 = v2;
      }

      _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_ERROR,  "mDNSGetTSRForCacheGroup: Found OPT that is not kDNSOpt_TSR (%d)",  (uint8_t *)&v6,  8u);
      return 0LL;
    }
  }

  return result;
}

BOOL ResourceRecordIsValidAnswer(uint64_t a1)
{
  BOOL result = 0;
  if ((*(_BYTE *)(a1 + 8) & 0x3C) != 0 && *(_WORD *)(a1 + 12) != 41)
  {
    uint64_t v2 = *(void *)(a1 + 72);
    if (!v2 || (*(_BYTE *)(v2 + 8) & 0x3C) != 0)
    {
      uint64_t v3 = *(void *)(a1 + 80);
      if (!v3 || (*(_BYTE *)(v3 + 8) & 0x3C) != 0)
      {
        uint64_t v4 = *(void *)(a1 + 88);
        if (!v4 || (*(_BYTE *)(v4 + 8) & 0x3C) != 0) {
          return 1;
        }
      }
    }
  }

  return result;
}

uint64_t CompleteDeregistration(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (os_log_s *)mDNSLogCategory_Default;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
  {
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_10;
    }
    goto LABEL_9;
  }

  uint64_t v4 = (os_log_s *)mDNSLogCategory_Default_redacted;
  if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
  {
LABEL_9:
    GetRRDisplayString_rdb( (unsigned __int8 *)(a2 + 8),  (unsigned __int16 *)(*(void *)(a2 + 48) + 4LL),  (_BYTE *)(a1 + 46976));
    int v13 = 141558275;
    uint64_t v14 = 1752392040LL;
    __int16 v15 = 2085;
    uint64_t v16 = a1 + 46976;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "CompleteDeregistration: called for Resource record %{sensitive, mask.hash}s",  (uint8_t *)&v13,  0x16u);
  }

BOOL FollowCNAME(uint64_t a1, unsigned __int8 *a2, int a3)
{
  if (!a3 || *(_WORD *)(a1 + 322) == 5 || *((_WORD *)a2 + 2) != 5 || *a2 == 240) {
    return 0LL;
  }
  if (!*(void *)(a1 + 144)) {
    return 1LL;
  }
  uint64_t v4 = *((void *)a2 + 7);
  if (!v4) {
    return 0LL;
  }
  return *(_DWORD *)(v4 + 32) == 1;
}

uint64_t *FindSPSInCache(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t SPSInCache1 = FindSPSInCache1(a1, a2, 0LL, 0LL);
  *a3 = SPSInCache1;
  if (SPSInCache1)
  {
    uint64_t SPSInCache1 = FindSPSInCache1(a1, a2, SPSInCache1, 0LL);
    a3[1] = SPSInCache1;
    uint64_t v7 = a3 + 1;
    if (SPSInCache1) {
      uint64_t SPSInCache1 = FindSPSInCache1(a1, a2, *a3, SPSInCache1);
    }
  }

  else
  {
    a3[1] = 0LL;
    uint64_t v7 = a3 + 1;
  }

  a3[2] = SPSInCache1;
  CheckAndSwapSPS(a3, v7);
  CheckAndSwapSPS(a3, a3 + 2);
  return CheckAndSwapSPS(v7, a3 + 2);
}

uint64_t *CheckAndSwapSPS(uint64_t *result, uint64_t *a2)
{
  uint64_t v2 = *result;
  if (*result)
  {
    uint64_t v3 = *a2;
    if (*a2)
    {
      unsigned int v4 = 1000000;
      unsigned int v5 = *(unsigned __int8 **)(v2 + 48);
      unsigned int v6 = v5[4];
      unsigned int v7 = 1000000;
      if (v6 >= 5)
      {
        int v8 = v5[5];
        if ((v8 - 48) <= 9)
        {
          int v9 = v5[6];
          if ((v9 - 48) <= 9)
          {
            int v10 = v5[8];
            if ((v10 - 48) <= 9)
            {
              int v11 = v5[9];
              if ((v11 - 48) <= 9)
              {
                if (v6 < 0xB
                  || v11 != 57
                  || v10 != 57
                  || v5[7] != 45
                  || v5[10] != 45
                  || v5[11] != 57
                  || v5[12] != 57
                  || v5[13] != 45
                  || v5[14] != 57
                  || (unsigned int v7 = 1000000, v5[15] != 57))
                {
                  unsigned int v7 = 10000 * v9 + 100000 * v8 + 1000 * v10 + 100 * v11 + 10 * v5[11] + v5[12] - 5333328;
                }
              }
            }
          }
        }
      }

      uint64_t v12 = *(unsigned __int8 **)(v3 + 48);
      unsigned int v13 = v12[4];
      if (v13 >= 5)
      {
        int v14 = v12[5];
        if ((v14 - 48) <= 9)
        {
          int v15 = v12[6];
          if ((v15 - 48) <= 9)
          {
            int v16 = v12[8];
            if ((v16 - 48) <= 9)
            {
              int v17 = v12[9];
              if ((v17 - 48) <= 9
                && (v13 < 0xB
                 || v17 != 57
                 || v16 != 57
                 || v12[7] != 45
                 || v12[10] != 45
                 || v12[11] != 57
                 || v12[12] != 57
                 || v12[13] != 45
                 || v12[14] != 57
                 || v12[15] != 57))
              {
                unsigned int v4 = 10000 * v15 + 100000 * v14 + 1000 * v16 + 100 * v17 + 10 * v12[11] + v12[12] - 5333328;
              }
            }
          }
        }
      }

      if (v6 >= 0xD && v5[16] == 46)
      {
        if (v13 < 0xD || v5[17] != 48) {
          return result;
        }
      }

      else if (v13 < 0xD)
      {
        return result;
      }

      if (v12[16] == 46 && v12[17] != 48 && v4 >= v7)
      {
        uint64_t *result = v3;
        *a2 = v2;
      }
    }
  }

  return result;
}

void AdjustUnansweredQueries(uint64_t a1, uint64_t a2)
{
  int v2 = 1000 * *(_DWORD *)(a2 + 16);
  if (*(_BYTE *)(a2 + 109))
  {
    int v3 = dword_100158BF8;
    int v4 = 939524096;
  }

  else
  {
    int v4 = *(_DWORD *)(a2 + 80);
    int v3 = 1000 * *(_DWORD *)(a2 + 16);
  }

  int v5 = v3 + v4;
  int v6 = *(_DWORD *)(a1 + 64);
  if (v6 - v5 < 0)
  {
    unsigned int v7 = *(unsigned __int8 *)(a2 + 108);
    if (v7 <= 3)
    {
      if ((v2 + 19) > 0x26)
      {
        unsigned int v14 = (v5 - v6) / (v2 / 20);
        if (v14 >= 4) {
          unsigned int v14 = 4;
        }
        if (4 - v7 > v14)
        {
          if (v14 <= 1) {
            LOBYTE(v14) = 1;
          }
          *(_BYTE *)(a2 + 10_Block_object_dispose(va, 8) = 4 - v14;
        }
      }

      else if (mDNS_LoggingEnabled == 1)
      {
        int v8 = (os_log_s *)mDNSLogCategory_Default;
        GetRRDisplayString_rdb( (unsigned __int8 *)(a2 + 8),  (unsigned __int16 *)(*(void *)(a2 + 48) + 4LL),  (_BYTE *)(a1 + 46976));
        LogMsgWithLevel( v8,  OS_LOG_TYPE_DEFAULT,  "AdjustUnansweredQueries: WARNING: unusually small TTL (%d ticks) for %s",  v9,  v10,  v11,  v12,  v13,  v2);
      }
    }
  }

void MakeNegativeCacheRecordForQuestion(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
}

void ReleaseCacheRecord(uint64_t a1, uint64_t a2)
{
  int v4 = *(void **)(a2 + 48);
  if (v4) {
    BOOL v5 = v4 == (void *)(a2 + 152);
  }
  else {
    BOOL v5 = 1;
  }
  if (!v5) {
    free(v4);
  }
  *(void *)(a2 + 4_Block_object_dispose(va, 8) = 0LL;
  int v6 = *(void **)(a2 + 56);
  if (v6)
  {
    os_release(v6);
    *(void *)(a2 + 56) = 0LL;
  }

  unsigned int v7 = CacheGroupForName(a1, *(_DWORD *)(a2 + 24), *(_BYTE **)(a2 + 40));
  if (!v7)
  {
    uint64_t v10 = (os_log_s *)mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_42;
      }
      uint64_t v12 = *(void *)(a2 + 40);
      if (v12)
      {
        uint64_t v13 = *(_BYTE **)(a2 + 40);
        if (v12 == -256)
        {
LABEL_21:
          while (v13)
          {
            uint64_t v14 = *v13;
            if (!*v13)
            {
              int v18 = (unsigned __int16)((_WORD)v13 - v12 + 1);
              goto LABEL_41;
            }

            v13 += v14 + 1;
            if (v12 != -256) {
              goto LABEL_20;
            }
          }
        }

        else
        {
LABEL_20:
        }

        int v18 = 257;
      }

      else
      {
        int v18 = 0;
      }
    }

    else
    {
      uint64_t v10 = (os_log_s *)mDNSLogCategory_Default_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_42;
      }
      uint64_t v12 = *(void *)(a2 + 40);
      if (v12)
      {
        int v16 = *(_BYTE **)(a2 + 40);
        if (v12 == -256)
        {
LABEL_30:
          while (v16)
          {
            uint64_t v17 = *v16;
            if (!*v16)
            {
              int v18 = (unsigned __int16)((_WORD)v16 - v12 + 1);
              goto LABEL_41;
            }

            v16 += v17 + 1;
            if (v12 != -256) {
              goto LABEL_29;
            }
          }
        }

        else
        {
LABEL_29:
        }

        int v18 = 257;
      }

      else
      {
        int v18 = 0;
      }
    }

uint64_t CheckProxyRecords( uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  *(void *)(result + 1264_Block_object_dispose(va, 8) = a2;
  if (a2)
  {
    uint64_t v8 = a2;
    uint64_t v9 = result;
    uint64_t v10 = (int *)(result + 19832);
    uint64_t v11 = (_BYTE *)(result + 46976);
    do
    {
      BOOL result = v8 + 8;
      if (*(_BYTE *)(v8 + 8) != 1 && *(_DWORD *)(v8 + 126))
      {
        if (*(void *)(v9 + 15048) && (int v12 = *(_DWORD *)(v8 + 168), *(_DWORD *)(v9 + 64) - v12 < 0))
        {
          if (*(_DWORD *)(v9 + 108) - v12 >= 1) {
            *(_DWORD *)(v9 + 10_Block_object_dispose(va, 8) = v12;
          }
        }

        else
        {
          if (mDNS_LoggingEnabled == 1)
          {
            uint64_t v13 = (os_log_s *)mDNSLogCategory_Default;
            int v14 = *v10;
            GetRRDisplayString_rdb((unsigned __int8 *)result, (unsigned __int16 *)(*(void *)(v8 + 48) + 4LL), v11);
            LogMsgWithLevel( v13,  OS_LOG_TYPE_DEFAULT,  "CheckProxyRecords: Removing %d H-MAC %.6a I-MAC %.6a %d %s",  v15,  v16,  v17,  v18,  v19,  v14);
          }

          uint64_t v20 = *(void *)(v9 + 15040);
          if (v20)
          {
            if (v20 != *(void *)(v8 + 32)) {
              mDNSPlatformUpdateProxyList(v20, a2, a3, a4, a5, a6, a7, a8);
            }
          }

          *(void *)(v9 + 15040) = *(void *)(v8 + 32);
          BOOL result = mDNS_Deregister_internal(v9, v8, 0);
          uint64_t v21 = *(void *)(v9 + 12648);
          if (v21 != v8) {
            goto LABEL_17;
          }
        }
      }

      uint64_t v21 = *(void *)v8;
      *(void *)(v9 + 1264_Block_object_dispose(va, 8) = *(void *)v8;
LABEL_17:
      uint64_t v8 = v21;
    }

    while (v21);
  }

  return result;
}

void mDNS_SendKeepalives(uint64_t a1)
{
  for (uint64_t i = *(void *)(a1 + 12624); i; uint64_t i = *(void *)i)
  {
    uint64_t v24 = 0LL;
    unsigned int v25 = 0;
    unsigned __int16 v23 = 0;
    uint64_t v17 = 0LL;
    uint64_t v18 = 0LL;
    int v19 = 0;
    uint64_t v20 = 0LL;
    uint64_t v21 = 0LL;
    int v22 = 0;
    unsigned __int16 v14 = 0;
    unsigned __int16 v15 = 0;
    if (*(_DWORD *)(i + 126))
    {
      mDNS_ExtractKeepaliveInfo( i,  &v25,  &v20,  &v17,  (uint64_t)v16,  (unsigned int *)&v24 + 1,  (unsigned int *)&v24,  &v15,  &v14,  &v23);
      unsigned int v8 = v25;
      if (v25)
      {
        if (v20 != 4
          && ((_DWORD)v20 != 6 || v21 | HIDWORD(v21) | v22 | HIDWORD(v20))
          && v17 != 4
          && ((_DWORD)v17 != 6 || v18 | HIDWORD(v18) | v19 | HIDWORD(v17)))
        {
          uint64_t v9 = HIDWORD(v24);
          if (HIDWORD(v24))
          {
            uint64_t v10 = v24;
            if ((_DWORD)v24)
            {
              if (v15)
              {
                if (v14)
                {
                  uint64_t v11 = v23;
                  if (v23)
                  {
                    LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "mDNS_SendKeepalives: laddr %#a raddr %#a lport %d rport %d",  v3,  v4,  v5,  v6,  v7,  (int)&v20);
                    unsigned int v13 = *(_DWORD *)(i + 176);
                    if (!v13 || (int)(*(_DWORD *)(a1 + 64) - v13) >= 0)
                    {
                      mDNSPlatformSendKeepalive((uint64_t)&v20, (uint64_t)&v17, &v15, &v14, v9, v10, v11, v12);
                      unsigned int v13 = *(_DWORD *)(a1 + 64) + 1000 * v8;
                      if (v13 <= 1) {
                        unsigned int v13 = 1;
                      }
                      *(_DWORD *)(i + 176) = v13;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }

uint64_t mDNS_SetUpDomainEnumeration(unsigned int *a1, uint64_t a2, int a3)
{
  if (a3 != 2) {
    return 4294901752LL;
  }
  uint64_t v4 = *(_DWORD **)(a2 + 272);
  if (!v4) {
    return 0LL;
  }
  int v6 = v4[166];
  if (v6 == 2)
  {
    int v11 = v4[167];
    if (v11 != 1)
    {
      uint64_t v12 = (os_log_s *)mDNSLogCategory_mDNS;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEBUG)) {
          goto LABEL_116;
        }
        __int16 v29 = (_BYTE *)a2;
        if (a2 == -256)
        {
LABEL_84:
          while (v29)
          {
            uint64_t v30 = *v29;
            if (!*v29)
            {
              int v34 = (unsigned __int16)((_WORD)v29 - a2 + 1);
              goto LABEL_115;
            }

            v29 += v30 + 1;
            if (a2 != -256) {
              goto LABEL_83;
            }
          }
        }

        else
        {
LABEL_83:
        }

        int v34 = 257;
      }

      else
      {
        uint64_t v12 = (os_log_s *)mDNSLogCategory_mDNS_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEBUG)) {
          goto LABEL_116;
        }
        unsigned int v13 = (_BYTE *)a2;
        if (a2 == -256)
        {
LABEL_26:
          while (v13)
          {
            uint64_t v14 = *v13;
            if (!*v13)
            {
              int v34 = (unsigned __int16)((_WORD)v13 - a2 + 1);
              goto LABEL_115;
            }

            v13 += v14 + 1;
            if (a2 != -256) {
              goto LABEL_25;
            }
          }
        }

        else
        {
LABEL_25:
        }

        int v34 = 257;
      }

void BeginSleepProcessing(uint64_t a1)
{
  kern_return_t v171;
  int v172;
  uint64_t v173;
  void *v174;
  int v175;
  _BYTE *v176;
  int v177;
  mach_port_t mainPort[2];
  int v179;
  os_log_s *v180;
  char v181;
  unsigned int v182;
  int v183;
  unint64_t v184;
  size_t outputStructCnt;
  __int16 outputStruct;
  __int128 inputStruct;
  void *v188[2];
  void *v189[2];
  io_connect_t connect;
  io_object_t object;
  CFTypeRef cf;
  void v193[128];
  uint64_t v194[3];
  io_name_t v195;
  io_name_t className;
  memset(v194, 0, sizeof(v194));
  v184 = 0LL;
  bzero(v193, 0x400uLL);
  *(_DWORD *)(a1 + 184) = *(_DWORD *)(a1 + 64);
  int v2 = SCDynamicStoreCreate(0LL, @"mDNSResponder:SPSAddresses", 0LL, 0LL);
  uint64_t v3 = SCDynamicStoreCreate(0LL, @"mDNSResponder:SPSOPTRecord", 0LL, 0LL);
  NetworkInterfaceEntity = SCDynamicStoreKeyCreateNetworkInterfaceEntity( kCFAllocatorDefault,  kSCDynamicStoreDomainState,  kSCCompAnyRegex,  @"BonjourSleepProxyAddress");
  if (NetworkInterfaceEntity)
  {
    uint64_t v5 = SCDynamicStoreCopyKeyList(v2, NetworkInterfaceEntity);
    if (v5)
    {
      int v6 = v5;
      if (SCDynamicStoreSetMultiple(v2, 0LL, v5, 0LL)) {
        BOOL v7 = 1;
      }
      else {
        BOOL v7 = mDNS_LoggingEnabled == 0;
      }
      if (!v7)
      {
        unsigned int v8 = (os_log_s *)mDNSLogCategory_Default;
        int CStringPtr = CFStringGetCStringPtr(NetworkInterfaceEntity, 0x600u);
        int v10 = SCError();
        SCErrorString(v10);
        LogMsgWithLevel( v8,  OS_LOG_TYPE_DEFAULT,  "mDNSPlatformClearSPSData: Unable to remove %s : error %s",  v11,  v12,  v13,  v14,  v15,  CStringPtr);
      }

      CFRelease(v6);
    }
  }

  uint64_t v23 = SCDynamicStoreKeyCreateNetworkInterfaceEntity( kCFAllocatorDefault,  kSCDynamicStoreDomainState,  kSCCompAnyRegex,  @"BonjourSleepProxyOPTRecord");
  if (v23)
  {
    uint64_t v24 = SCDynamicStoreCopyKeyList(v2, v23);
    if (v24)
    {
      uint64_t v25 = v24;
      if (SCDynamicStoreSetMultiple(v3, 0LL, v24, 0LL)) {
        BOOL v26 = 1;
      }
      else {
        BOOL v26 = mDNS_LoggingEnabled == 0;
      }
      if (!v26)
      {
        int v27 = (os_log_s *)mDNSLogCategory_Default;
        int v28 = CFStringGetCStringPtr(v23, 0x600u);
        int v29 = SCError();
        SCErrorString(v29);
        LogMsgWithLevel( v27,  OS_LOG_TYPE_DEFAULT,  "mDNSPlatformClearSPSData: Unable to remove %s : error %s",  v30,  v31,  v32,  v33,  v34,  v28);
      }

      CFRelease(v25);
    }
  }

  if (v2) {
    CFRelease(v2);
  }
  if (v3) {
    CFRelease(v3);
  }
  if (NetworkInterfaceEntity) {
    CFRelease(NetworkInterfaceEntity);
  }
  if (v23) {
    CFRelease(v23);
  }
  if (!*(_BYTE *)(a1 + 143))
  {
    uint64_t v35 = (uint64_t)&unk_100158000;
    if (mDNS_LoggingEnabled != 1) {
      goto LABEL_36;
    }
    uint64_t v37 = (os_log_s *)mDNSLogCategory_Default;
    uint64_t v38 = "BeginSleepProcessing: m->SystemWakeOnLANEnabled is false";
LABEL_35:
    LogMsgWithLevel(v37, OS_LOG_TYPE_DEFAULT, v38, (uint64_t)v18, v19, v20, v21, v22, v172);
    goto LABEL_36;
  }

  uint64_t v35 = (uint64_t)&unk_100158000;
  if (!mDNSCoreHaveAdvertisedMulticastServices(*(void *)(a1 + 12624)))
  {
    if (mDNS_LoggingEnabled != 1) {
      goto LABEL_36;
    }
    uint64_t v37 = (os_log_s *)mDNSLogCategory_Default;
    uint64_t v38 = "BeginSleepProcessing: No advertised services";
    goto LABEL_35;
  }

  uint64_t v36 = *(void *)(a1 + 12664);
  if (!v36)
  {
LABEL_36:
    int v39 = 0;
    int v40 = 0;
    v183 = 0;
    int v41 = 0;
    int v42 = 1;
    v179 = 1;
    goto LABEL_37;
  }

  while (!*(_BYTE *)(v36 + 16))
  {
    uint64_t v36 = *(void *)v36;
    if (!v36) {
      goto LABEL_36;
    }
  }

  int v41 = 0;
  uint64_t v102 = 0LL;
  v183 = 0;
  uint64_t v103 = (_BYTE *)(a1 + 46976);
  uint64_t v65 = (uint64_t)&unk_100164000;
  v179 = 1;
  int v42 = 1;
LABEL_131:
  *(_BYTE *)(v36 + 6379) = 0;
  if (!*(_BYTE *)(v36 + 6375)
    || mDNSPlatformInterfaceIsD2D(*(void *)(v36 + 6256), v16, v17, (uint64_t)v18, v19, v20, v21, v22))
  {
    if (*(_BYTE *)(v35 + 2840) == 1) {
      LogMsgWithLevel( *(os_log_s **)(v65 + 1360),  OS_LOG_TYPE_DEFAULT,  "BeginSleepProcessing: %-6s Ignoring for registrations",  (uint64_t)v18,  v19,  v20,  v21,  v22,  v36 + 6310);
    }
    goto LABEL_135;
  }

  if (!*(_BYTE *)(v36 + 6376))
  {
    if (*(_BYTE *)(v35 + 2840) == 1) {
      LogMsgWithLevel( *(os_log_s **)(v65 + 1360),  OS_LOG_TYPE_DEFAULT,  "BeginSleepProcessing: %-6s not capable of magic packet wakeup",  (uint64_t)v18,  v19,  v20,  v21,  v22,  v36 + 6310);
    }
    *(_BYTE *)(v36 + 6379) = 1;
    ++v41;
LABEL_135:
    while (1)
    {
      uint64_t v36 = *(void *)v36;
      if (!v36) {
        break;
      }
      if (*(_BYTE *)(v36 + 16)) {
        goto LABEL_131;
      }
    }

    int v40 = v184;
    int v39 = HIDWORD(v184);
LABEL_37:
    if (v39 | v40)
    {
      v177 = v41;
      unint64_t v43 = v184;
      *(void *)className = v184;
      *(void *)mainPort = HIDWORD(v184);
      if ((*(_BYTE *)(v35 + 2840) & 1) != 0)
      {
        LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "SPSInitRecordsBeforeUpdate: UpdateIntID 0x%x 0x%x",  (uint64_t)v18,  v19,  v20,  v21,  v22,  SHIDWORD(v184));
        int v44 = (void *)(a1 + 15024);
        __int16 v45 = *(void **)(a1 + 15024);
        if (*(_BYTE *)(v35 + 2840) == 1) {
          LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "%s : Freeing stored sleep proxy A/AAAA records",  (uint64_t)v18,  v19,  v20,  v21,  v22,  (int)"mDNSCoreFreeProxyRR");
        }
      }

      else
      {
        int v44 = (void *)(a1 + 15024);
        __int16 v45 = *(void **)(a1 + 15024);
      }

      v175 = v42;
      if (v45)
      {
        do
        {
          uint64_t v46 = (void *)*v45;
          free(v45);
          __int16 v45 = v46;
        }

        while (v46);
      }

      *(void *)(a1 + 15024) = 0LL;
      uint64_t v47 = *(uint64_t **)(a1 + 12624);
      if (v47)
      {
        v183 = 0;
        while (1)
        {
          v47[45] = 0LL;
          *((_WORD *)v47 + 179) = 0;
          if (v47[4] || *((_BYTE *)v47 + 122) || IsLocalDomain((_BYTE *)v47[5]))
          {
            if ((*((_BYTE *)v47 + 123) & 1) == 0 || *((_BYTE *)v47 + 8) != 8 || !*((_BYTE *)v47 + 192))
            {
              int v48 = (unint64_t *)(v47 + 45);
              uint64_t v49 = v47[4];
              LODWORD(v50) = -1;
              switch(v49)
              {
                case -5LL:
                  LODWORD(v50) = -4;
                  goto LABEL_60;
                case -3LL:
                  LODWORD(v50) = -3;
                  goto LABEL_60;
                case -2LL:
                  goto LABEL_60;
                case 0LL:
                  if (*(_BYTE *)(v35 + 2840) == 1)
                  {
                    uint64_t v58 = (os_log_s *)mDNSLogCategory_Default;
                    GetRRDisplayString_rdb( (unsigned __int8 *)v47 + 8,  (unsigned __int16 *)(v47[6] + 4),  (_BYTE *)(a1 + 46976));
                    LogMsgWithLevel( v58,  OS_LOG_TYPE_DEFAULT,  "Setting scopeid (ALL) 0x%x 0x%x for %s",  v59,  v60,  v61,  v62,  v63,  mainPort[0]);
                  }

                  *int v48 = v43;
                  goto LABEL_65;
                default:
                  uint64_t v50 = v47[4];
                  if (v49 <= 0x3F
                    && (uint64_t v51 = v49 >> 5, (*(_DWORD *)&className[4 * v51] & (1 << v50)) != 0))
                  {
                    *((_DWORD *)v48 + v51) |= 1 << v50;
                    if (*(_BYTE *)(v35 + 2840) == 1)
                    {
                      uint64_t v52 = (os_log_s *)mDNSLogCategory_Default;
                      GetRRDisplayString_rdb( (unsigned __int8 *)v47 + 8,  (unsigned __int16 *)(v47[6] + 4),  (_BYTE *)(a1 + 46976));
                      uint64_t v35 = 0x100158000LL;
                      LogMsgWithLevel( v52,  OS_LOG_TYPE_DEFAULT,  "SPSInitRecordsBeforeUpdate: Setting scopeid(%d) 0x%x 0x%x for %s",  v53,  v54,  v55,  v56,  v57,  v50);
                    }
                  }

                  else
                  {
LABEL_60:
                    if (*(_BYTE *)(v35 + 2840) == 1) {
                      LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "SPSInitRecordsBeforeUpdate: scopeid %d beyond range or not valid for SPS registration",  (uint64_t)v18,  v19,  v20,  v21,  v22,  v50);
                    }
                  }

LABEL_155:
            break;
          }
        }

        uint64_t v105 = *(void *)v105;
      }

      while (v105);
      break;
    }
  }

  char v109 = 0;
LABEL_165:
  if (!SupportsInNICProxy(v36))
  {
    if ((v109 & 1) != 0) {
      goto LABEL_135;
    }
    if (*(_BYTE *)(a1 + 143) != 2)
    {
      FindSPSInCache(a1, v36 + 24, v194);
      if (!v194[0])
      {
        if (*(_BYTE *)(v35 + 2840) == 1) {
          LogMsgWithLevel( *(os_log_s **)(v65 + 1360),  OS_LOG_TYPE_DEFAULT,  "BeginSleepProcessing: %-6s %#a No Sleep Proxy Server found (Next Browse Q in %d, interval %d)",  (uint64_t)v18,  v19,  v20,  v21,  v22,  v36 + 6310);
        }
        goto LABEL_135;
      }

      v176 = v103;
      v182 = v102;
      *(_DWORD *)(v36 + 2716) = 0;
      *(_DWORD *)(v36 + 2720) = *(_DWORD *)(a1 + 64) + 1000;
      uint64_t v125 = *(void *)(v36 + 6256);
      if ((unint64_t)(v125 + 3) >= 2 && v125 != -5)
      {
        LODWORD(v126) = 0;
      }

      uint64_t v127 = 0LL;
      uint64_t v128 = 0LL;
      for (uint64_t i = 2648LL; i != 2708; i += 20LL)
      {
        *(_DWORD *)(v36 + i) = 0;
        if ((*(_DWORD *)(v36 + v127 + 892) & 0x80000000) == 0) {
          mDNS_StopQuery((unsigned int *)a1, v36 + v127 + 680);
        }
        *(_DWORD *)(v36 + v127 + 892) = -1;
        uint64_t v130 = v194[v128];
        if (v130)
        {
          if (mDNS_LoggingEnabled == 1)
          {
            v180 = (os_log_s *)mDNSLogCategory_Default;
            GetRRDisplayString_rdb( (unsigned __int8 *)(v130 + 8),  (unsigned __int16 *)(*(void *)(v130 + 48) + 4LL),  v103);
            LogMsgWithLevel( v180,  OS_LOG_TYPE_DEFAULT,  "BeginSleepProcessing: %-6s Found Sleep Proxy Server %d TTL %d %s",  v131,  v132,  v133,  v134,  v135,  v36 + 6310);
            uint64_t v130 = v194[v128];
          }

          mDNS_SetupQuestion( v36 + v127 + 680,  *(void *)(v36 + 6256),  (_BYTE *)(*(void *)(v130 + 48) + 4LL),  33,  (uint64_t)NetWakeResolve,  v36);
          *(_BYTE *)(v36 + v127 + 1295) = 1;
          mDNS_StartQuery_internal(a1, v36 + v127 + 680);
          v193[v182++] = *(void *)(v36 + 6256);
        }

        ++v128;
        v127 += 656LL;
      }

      v179 = 0;
      uint64_t v35 = 0x100158000LL;
      uint64_t v102 = v182;
LABEL_187:
      uint64_t v103 = v176;
      uint64_t v65 = 0x100164000LL;
      goto LABEL_135;
    }

    goto LABEL_257;
  }

  v181 = v109;
  v176 = v103;
  uint64_t v115 = v102;
  __int128 v116 = IOBSDNameMatching(kIOMainPortDefault, 0, (const char *)(v36 + 6310));
  io_service_t MatchingService = IOServiceGetMatchingService(kIOMainPortDefault, v116);
  if (!MatchingService)
  {
    LogMsgWithLevel( *(os_log_s **)(v65 + 1360),  OS_LOG_TYPE_DEFAULT,  "ActivateLocalProxy: No service for interface %s",  v118,  v119,  v120,  v121,  v122,  v36 + 6310);
    goto LABEL_135;
  }

  io_object_t v123 = MatchingService;
  memset(className, 0, sizeof(className));
  memset(v195, 0, sizeof(v195));
  IOObjectGetClass(MatchingService, className);
  cf = 0LL;
  xpc_object_t object = 0;
  int v124 = RegistryEntrySearchCFPropertyAndIOObject(v123, @"mDNS_KEY", &cf, &object);
  IOObjectRelease(v123);
  if (v124)
  {
    uint64_t v102 = v115;
    if (*(_BYTE *)(v35 + 2840) == 1) {
      LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "ActivateLocalProxy: No mDNS_IOREG_KEY for interface %s/%s kr %d",  (uint64_t)v18,  v19,  v20,  v21,  v22,  v36 + 6310);
    }
    goto LABEL_187;
  }

  IOObjectGetClass(object, v195);
  if (*(_BYTE *)(v35 + 2840) == 1) {
    LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "ActivateLocalProxy: Interface %s service %s parent %s",  v136,  v137,  v138,  v139,  v140,  v36 + 6310);
  }
  CFTypeID v141 = CFGetTypeID(cf);
  uint64_t v102 = v115;
  if (v141 != CFStringGetTypeID() || !CFEqual(cf, @"2009-07-30"))
  {
    v152 = (os_log_s *)mDNSLogCategory_Default;
    CFStringGetCStringPtr((CFStringRef)cf, 0);
    LogMsgWithLevel( v152,  OS_LOG_TYPE_DEFAULT,  "ActivateLocalProxy: mDNS_IOREG_KEY for interface %s/%s/%s value %s != %s",  v153,  v154,  v155,  v156,  v157,  v36 + 6310);
    goto LABEL_197;
  }

  if (!UseInternalSleepProxy)
  {
    char v159 = v181;
    if (*(_BYTE *)(v35 + 2840) == 1) {
      LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "ActivateLocalProxy: Not using internal (NIC) sleep proxy for interface %s",  v142,  v143,  v144,  v145,  v146,  v36 + 6310);
    }
    int v158 = -65537;
    goto LABEL_198;
  }

  connect = 0;
  if (IOServiceOpen(object, mach_task_self_, 0x6D444E53u, &connect))
  {
    LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "ActivateLocalProxy: IOServiceOpen for %s/%s/%s failed %d",  v147,  v148,  v149,  v150,  v151,  v36 + 6310);
LABEL_197:
    int v158 = -65537;
    char v159 = v181;
LABEL_198:
    if (cf)
    {
      CFRelease(cf);
      cf = 0LL;
    }

    IOObjectRelease(object);
    if (v158) {
      char v160 = 1;
    }
    else {
      char v160 = v159;
    }
    uint64_t v65 = (uint64_t)&unk_100164000;
    if ((v160 & 1) != 0)
    {
      uint64_t v35 = 0x100158000LL;
    }

    else
    {
      v161 = *(uint64_t **)(a1 + 12624);
      uint64_t v35 = (uint64_t)&unk_100158000;
      if (v161)
      {
        v183 = 0;
        do
        {
          if ((*((_BYTE *)v161 + 123) & 1) != 0 && *((_BYTE *)v161 + 8) == 8 && *((_BYTE *)v161 + 192))
          {
            v161[26] = -1LL;
            v183 = 1;
          }

          v161 = (uint64_t *)*v161;
        }

        while (v161);
      }

      else
      {
        v183 = 0;
      }

      if (mDNS_LoggingEnabled == 1) {
        LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "BeginSleepProcessing: %-6s using local proxy",  (uint64_t)v18,  v19,  v20,  v21,  v22,  v36 + 6310);
      }
      int v42 = 0;
      v179 = 0;
      v193[v102] = *(void *)(v36 + 6256);
      uint64_t v102 = (v102 + 1);
    }

    goto LABEL_135;
  }

  *(_OWORD *)v188 = 0u;
  *(_OWORD *)v189 = 0u;
  inputStruct = 0u;
  LODWORD(inputStruct) = 21;
  DWORD2(inputStruct) = GetPortArray(1, 0LL);
  HIDWORD(inputStruct) = GetPortArray(2, 0LL);
  uint64_t v65 = CountProxyRecords((_DWORD *)&inputStruct + 1);
  v188[0] = (void *)(v65 | 0xC00000000LL);
  uint64_t v35 = DWORD1(inputStruct);
  v174 = calloc(1uLL, DWORD1(inputStruct) + 12LL);
  if (v174)
  {
    if ((_DWORD)v65)
    {
      v162 = calloc(1uLL, 8LL * v65);
      if (!v162) {
        goto LABEL_256;
      }
    }

    else
    {
      v162 = 0LL;
    }

    v188[1] = v162;
    v173 = (uint64_t)v162;
    if (DWORD2(inputStruct))
    {
      v163 = calloc(1uLL, 2LL * DWORD2(inputStruct));
      if (!v163) {
        goto LABEL_256;
      }
    }

    else
    {
      v163 = 0LL;
    }

    v189[0] = v163;
    uint64_t v65 = HIDWORD(inputStruct);
    if (HIDWORD(inputStruct))
    {
      uint64_t v35 = (uint64_t)v163;
      v164 = calloc(1uLL, 2LL * HIDWORD(inputStruct));
      v163 = (void *)v35;
      if (!v164) {
        goto LABEL_256;
      }
    }

    else
    {
      v164 = 0LL;
    }

    v189[1] = v164;
    if (mDNS_LoggingEnabled == 1)
    {
      v165 = v163;
      LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "ActivateLocalProxy: msg %p %u RR %p %u, UDP %p %u, TCP %p %u",  (uint64_t)v18,  v19,  v20,  v21,  v22,  (int)v174);
      v163 = v165;
    }

    if (v173)
    {
      GetProxyRecords( (unint64_t)v174,  (_DWORD *)&inputStruct + 1,  v173,  (unsigned int *)v188,  v19,  v20,  v21,  v22);
      v163 = v189[0];
    }

    if (v163) {
      DWORD2(inputStruct) = GetPortArray(1, (unsigned __int16 *)v163);
    }
    if (v189[1]) {
      HIDWORD(inputStruct) = GetPortArray(2, (unsigned __int16 *)v189[1]);
    }
    outputStruct = 0;
    outputStructCnt = 2LL;
    v171 = IOConnectCallStructMethod(connect, 0, &inputStruct, 0x30uLL, &outputStruct, &outputStructCnt);
    if (mDNS_LoggingEnabled == 1) {
      LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "ActivateLocalProxy: IOConnectCallStructMethod for %s/%s/%s %d",  v166,  v167,  v168,  v169,  v170,  v36 + 6310);
    }
    if (v171) {
      int v158 = -65537;
    }
    else {
      int v158 = 0;
    }
    if (v189[1])
    {
      free(v189[1]);
      v189[1] = 0LL;
    }

    uint64_t v102 = v115;
    if (v189[0])
    {
      free(v189[0]);
      v189[0] = 0LL;
    }

    char v159 = v181;
    if (v188[1])
    {
      free(v188[1]);
      v188[1] = 0LL;
    }

    free(v174);
    IOServiceClose(connect);
    goto LABEL_198;
  }

LABEL_256:
  __break(1u);
LABEL_257:
  if (*(_BYTE *)(v35 + 2840) == 1) {
    LogMsgWithLevel( *(os_log_s **)(v65 + 1360),  OS_LOG_TYPE_DEFAULT,  "BegingSleepProcessing: Not connected to AC power - Not registering with an external sleep proxy.",  (uint64_t)v18,  v19,  v20,  v21,  v22,  v172);
  }
}

void *__mDNSPostResponseDelayMetrics_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  xpc_object_t empty = xpc_dictionary_create_empty();
  uint64_t v3 = empty;
  if (empty)
  {
    unsigned int v4 = 0;
    uint64_t v5 = *(unsigned int *)(v1 + 24);
    for (uint64_t i = 28LL; i != 62; i += 2LL)
      v4 += *(unsigned __int16 *)(v1 + i);
    uint64_t v7 = v5 + v4;
    xpc_dictionary_set_uint64(empty, "answer_count_cache_hit", v5);
    xpc_dictionary_set_uint64(v3, "answer_count_total", v7);
    xpc_dictionary_set_uint64(v3, "delay_1s", *(unsigned __int16 *)(v1 + 28));
    xpc_dictionary_set_uint64(v3, "delay_2s", *(unsigned __int16 *)(v1 + 30));
    xpc_dictionary_set_uint64(v3, "delay_3s", *(unsigned __int16 *)(v1 + 32));
    xpc_dictionary_set_uint64(v3, "delay_4s", *(unsigned __int16 *)(v1 + 34));
    xpc_dictionary_set_uint64(v3, "delay_5s", *(unsigned __int16 *)(v1 + 36));
    xpc_dictionary_set_uint64(v3, "delay_6s", *(unsigned __int16 *)(v1 + 38));
    xpc_dictionary_set_uint64(v3, "delay_7s", *(unsigned __int16 *)(v1 + 40));
    xpc_dictionary_set_uint64(v3, "delay_8s", *(unsigned __int16 *)(v1 + 42));
    xpc_dictionary_set_uint64(v3, "delay_9s", *(unsigned __int16 *)(v1 + 44));
    xpc_dictionary_set_uint64(v3, "delay_10s", *(unsigned __int16 *)(v1 + 46));
    xpc_dictionary_set_uint64(v3, "delay_11s", *(unsigned __int16 *)(v1 + 48));
    xpc_dictionary_set_uint64(v3, "delay_12s", *(unsigned __int16 *)(v1 + 50));
    xpc_dictionary_set_uint64(v3, "delay_13s", *(unsigned __int16 *)(v1 + 52));
    xpc_dictionary_set_uint64(v3, "delay_14s", *(unsigned __int16 *)(v1 + 54));
    xpc_dictionary_set_uint64(v3, "delay_15s", *(unsigned __int16 *)(v1 + 56));
    xpc_dictionary_set_uint64(v3, "delay_20s", *(unsigned __int16 *)(v1 + 58));
    xpc_dictionary_set_uint64(v3, "delay_infinity", *(unsigned __int16 *)(v1 + 60));
  }

  return v3;
}

void GenerateNegativeResponseEx( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9)
{
  uint64_t v9 = *(void *)(a1 + 216);
  if (!v9)
  {
    LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "GenerateNegativeResponse: ERROR!! CurrentQuestion not set",  a4,  a5,  a6,  a7,  a8,  a9);
    return;
  }

  __int16 v10 = a4;
  uint64_t v14 = a1 + 37864;
  uint64_t v15 = (os_log_s *)mDNSLogCategory_Default;
  if (gSensitiveLoggingEnabled == 1 && mDNSLogCategory_Default != mDNSLogCategory_State)
  {
    uint64_t v15 = (os_log_s *)mDNSLogCategory_Default_redacted;
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_12;
    }
    goto LABEL_11;
  }

  if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
  {
LABEL_11:
    unsigned int v18 = bswap32(*(unsigned __int16 *)(v9 + 320)) >> 16;
    *(_DWORD *)buf = 67109120;
    unsigned int v21 = v18;
    _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_DEFAULT,  "[Q%d] GenerateNegativeResponse: Generating negative response for question",  buf,  8u);
  }

void CheckRmvEventsForLocalRecords( void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = a1[1581];
  if (v8)
  {
    while (*(_BYTE *)(v8 + 193) && *(_BYTE *)(v8 + 8) == 1)
    {
      *(_BYTE *)(v8 + _Block_object_dispose(va, 8) = 8;
      AnswerAllLocalQuestionsWithLocalAuthRecord(a1, v8, 0LL, a4, a5, a6, a7, a8);
      uint64_t v10 = a1[1581];
      if (v10 == v8)
      {
        *(_BYTE *)(v8 + _Block_object_dispose(va, 8) = 1;
        *(_BYTE *)(v8 + 193) = 0;
        if ((*(_DWORD *)(v8 + 172) & 0xFFFFFFFE) != 4) {
          break;
        }
        CompleteDeregistration((uint64_t)a1, v8);
        uint64_t v10 = a1[1581];
      }

      if (v10 == v8) {
        break;
      }
LABEL_9:
      uint64_t v8 = v10;
      if (!v10) {
        return;
      }
    }

    uint64_t v10 = *(void *)v8;
    a1[1581] = *(void *)v8;
    goto LABEL_9;
  }

void DiscardDeregistrations(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 12648);
  if (v2)
  {
    uint64_t v3 = (os_log_s *)mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_11;
      }
      goto LABEL_10;
    }

    uint64_t v3 = (os_log_s *)mDNSLogCategory_Default_redacted;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
    {
LABEL_10:
      GetRRDisplayString_rdb( (unsigned __int8 *)(v2 + 8),  (unsigned __int16 *)(*(void *)(v2 + 48) + 4LL),  (_BYTE *)(a1 + 46976));
      int v7 = 141558275;
      uint64_t v8 = 1752392040LL;
      __int16 v9 = 2085;
      uint64_t v10 = a1 + 46976;
      _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEFAULT,  "DiscardDeregistrations ERROR m->CurrentRecord already set %{sensitive, mask.hash}s",  (uint8_t *)&v7,  0x16u);
    }
  }

BOOL __SendQueries_block_invoke(void *a1, int *a2, uint64_t a3, char a4)
{
  uint64_t v7 = *(void *)(*(void *)(a1[4] + 8LL) + 24LL);
  uint64_t v8 = a1[6];
  int v9 = *(unsigned __int16 *)(v8 + 322);
  if (!v7 || (uint64_t v10 = *(uint64_t **)(v7 + 16)) == 0LL)
  {
LABEL_11:
    uint64_t v14 = (os_log_s *)mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_INFO))
      {
        unsigned int v16 = bswap32(*(unsigned __int16 *)(v8 + 320)) >> 16;
        uint64_t v17 = (_BYTE *)(v8 + 356);
        if (v8 == -612)
        {
LABEL_19:
          while (v17)
          {
            uint64_t v18 = *v17;
            if (!*v17)
            {
              int v24 = (unsigned __int16)((_WORD)v17 - (v8 + 356) + 1);
              goto LABEL_36;
            }

            v17 += v18 + 1;
            if (v8 != -612) {
              goto LABEL_18;
            }
          }
        }

        else
        {
LABEL_18:
        }

        int v24 = 257;
        goto LABEL_36;
      }
    }

    else
    {
      uint64_t v14 = (os_log_s *)mDNSLogCategory_Default_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_INFO))
      {
        unsigned int v16 = bswap32(*(unsigned __int16 *)(v8 + 320)) >> 16;
        uint64_t v22 = (_BYTE *)(v8 + 356);
        if (v8 == -612)
        {
LABEL_27:
          while (v22)
          {
            uint64_t v23 = *v22;
            if (!*v22)
            {
              int v24 = (unsigned __int16)((_WORD)v22 - (v8 + 356) + 1);
              goto LABEL_36;
            }

            v22 += v23 + 1;
            if (v8 != -612) {
              goto LABEL_26;
            }
          }
        }

        else
        {
LABEL_26:
        }

        int v24 = 257;
LABEL_36:
        int v25 = *(_DWORD *)(v8 + 200);
        *(_DWORD *)buf = 67111427;
        *(_DWORD *)unint64_t v43 = v16;
        *(_WORD *)&v43[4] = 2160;
        *(void *)&v43[6] = 1752392040LL;
        __int16 v44 = 1045;
        *(_DWORD *)__int16 v45 = 20;
        *(_WORD *)&v45[4] = 2101;
        *(void *)&v45[6] = a2;
        __int16 v46 = 1024;
        *(_DWORD *)uint64_t v47 = a3;
        *(_WORD *)&v47[4] = 2160;
        *(void *)&v47[6] = 1752392040LL;
        __int16 v48 = 1040;
        *(_DWORD *)uint64_t v49 = v24;
        *(_WORD *)&v49[4] = 2101;
        *(void *)&v49[6] = v8 + 356;
        *(_WORD *)&v49[14] = 1024;
        *(_DWORD *)&v49[16] = v9;
        LOWORD(v50[0]) = 1024;
        *(_DWORD *)((char *)v50 + 2) = v25;
        _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_INFO,  "[Q%u] Sending unicast assist query - %{sensitive, mask.hash, mdnsresponder:ip_addr}.20P %d %{sensitive, mask.h ash, mdnsresponder:domain_name}.*P %{mdns:rrtype}d qhash %x",  buf,  0x4Eu);
      }
    }

    uint64_t v26 = a1[7] + 28904LL;
    *(_WORD *)uint64_t v26 = *(_WORD *)(a1[6] + 320LL);
    *(_WORD *)(v26 + 2) = 0;
    *(void *)(v26 + 4) = 0LL;
    int v27 = putQuestion( a1[7] + 28904LL,  a1[7] + 28916LL,  a1[7] + 37856LL,  (unsigned __int8 *)(a1[6] + 356LL),  *(unsigned __int16 *)(a1[6] + 322LL),  *(unsigned __int16 *)(a1[6] + 324LL) | 0x8000u,  v20,  v21);
    mDNSSendDNSMessage( a1[7],  a1[7] + 28904LL,  (unint64_t)v27,  a3,  0LL,  0LL,  a2,  0xE914u,  0LL,  *(_BYTE *)(a1[6] + 620LL));
    uint64_t v28 = a1[6];
    int v29 = *(_DWORD *)(a1[7] + 64LL);
    *(_DWORD *)(v28 + 20_Block_object_dispose(va, 8) = v29;
    *(_DWORD *)(v28 + 256) = v29;
    *(_DWORD *)(v28 + 224) = 0;
    *(void *)(v28 + 64) = 0LL;
    unsigned int v30 = *(_DWORD *)(a1[7] + 64LL);
    if (v30 <= 1) {
      unsigned int v30 = 1;
    }
    *(_DWORD *)(a1[6] + 216LL) = v30;
    *(_BYTE *)(*(void *)(a1[5] + 8LL) + 24LL) = a4;
    return 1LL;
  }

  int v11 = dword_100158BF8;
  int v12 = dword_100158BF8 + 939524096;
  while (1)
  {
    if (*((unsigned __int16 *)v10 + 6) == v9 && v10[4] == a3)
    {
      int v13 = v12;
      if (!*((_BYTE *)v10 + 109)) {
        int v13 = *((_DWORD *)v10 + 20) + 1000 * *((_DWORD *)v10 + 4);
      }
    }

    uint64_t v10 = (uint64_t *)*v10;
    if (!v10) {
      goto LABEL_11;
    }
  }

  uint64_t v32 = (os_log_s *)mDNSLogCategory_Default;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
  {
    BOOL result = os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_INFO);
    if (result)
    {
      uint64_t v33 = v8 + 356;
      uint64_t v36 = (_BYTE *)(v8 + 356);
      if (v8 == -612)
      {
LABEL_54:
        while (v36)
        {
          uint64_t v37 = *v36;
          if (!*v36)
          {
            int v38 = (unsigned __int16)((_WORD)v36 - v33 + 1);
            goto LABEL_63;
          }

          v36 += v37 + 1;
          if (v8 != -612) {
            goto LABEL_53;
          }
        }
      }

      else
      {
LABEL_53:
      }

      int v38 = 257;
      goto LABEL_63;
    }
  }

  else
  {
    uint64_t v32 = (os_log_s *)mDNSLogCategory_Default_redacted;
    BOOL result = os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_INFO);
    if (result)
    {
      uint64_t v33 = v8 + 356;
      uint64_t v34 = (_BYTE *)(v8 + 356);
      if (v8 == -612)
      {
LABEL_46:
        while (v34)
        {
          uint64_t v35 = *v34;
          if (!*v34)
          {
            int v38 = (unsigned __int16)((_WORD)v34 - v33 + 1);
            goto LABEL_63;
          }

          v34 += v35 + 1;
          if (v8 != -612) {
            goto LABEL_45;
          }
        }
      }

      else
      {
LABEL_45:
      }

      int v38 = 257;
LABEL_63:
      int v39 = DNSTypeName(v9);
      int v40 = *(_DWORD *)(a1[6] + 200LL);
      *(_DWORD *)buf = 141560067;
      *(void *)unint64_t v43 = 1752392040LL;
      *(_WORD *)&v43[8] = 1045;
      *(_DWORD *)&v43[10] = 20;
      __int16 v44 = 2101;
      *(void *)__int16 v45 = a2;
      *(_WORD *)&v45[8] = 1024;
      *(_DWORD *)&v45[10] = a3;
      __int16 v46 = 2160;
      *(void *)uint64_t v47 = 1752392040LL;
      *(_WORD *)&v47[8] = 1040;
      *(_DWORD *)&v47[10] = v38;
      __int16 v48 = 2101;
      *(void *)uint64_t v49 = v33;
      *(_WORD *)&v49[8] = 2082;
      *(void *)&v49[10] = v39;
      *(_WORD *)&v49[18] = 1024;
      v50[0] = v40;
      _os_log_impl( (void *)&_mh_execute_header,  v32,  OS_LOG_TYPE_INFO,  "SKIPPED unicast assist query - %{sensitive, mask.hash, mdnsresponder:ip_addr}.20P %d %{sensitive, mask.hash, mdn sresponder:domain_name}.*P %{public}s qhash %x",  buf,  0x4Cu);
      return 0LL;
    }
  }

  return result;
}

uint64_t *CacheHasAddressTypeForName(uint64_t a1, _BYTE *a2, unsigned int a3)
{
  BOOL result = CacheGroupForName(a1, a3, a2);
  if (result)
  {
    for (BOOL result = (uint64_t *)result[2]; result; BOOL result = (uint64_t *)*result)
    {
      int v4 = *((unsigned __int16 *)result + 6);
      if (v4 == 1 || v4 == 28) {
        break;
      }
    }
  }

  return result;
}

void SendARP(uint64_t a1, char a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  int v9 = (char *)(a1 + 28916);
  uint64_t v10 = *(void *)(a3 + 32);
  int v11 = (void *)(a1 + 12664);
  do
  {
    int v11 = (void *)*v11;
    if (!v11)
    {
      uint64_t v22 = (os_log_s *)mDNSLogCategory_Default;
      GetRRDisplayString_rdb( (unsigned __int8 *)(a3 + 8),  (unsigned __int16 *)(*(void *)(a3 + 48) + 4LL),  (_BYTE *)(a1 + 46976));
      LogMsgWithLevel( v22,  OS_LOG_TYPE_DEFAULT,  "SendARP: No interface with InterfaceID %p found %s",  v23,  v24,  v25,  v26,  v27,  v10);
      return;
    }
  }

  while (v11[782] != v10);
  for (uint64_t i = 0LL; i != 6; ++i)
    v9[i] = *(_BYTE *)(a7 + i);
  int v13 = v9 + 6;
  uint64_t v14 = v11 + 788;
  int v15 = 6;
  do
  {
    unsigned int v16 = v13;
    *v13++ = *v14;
    --v15;
  }

  while (v15);
  uint64_t v17 = 0LL;
  *(void *)int v13 = 0x406000801000608LL;
  v13[8] = 0;
  uint64_t v18 = v16 + 11;
  v13[9] = a2;
  do
    *v18++ = v14[v17++];
  while (v17 != 6);
  for (uint64_t j = 0LL; j != 4; ++j)
    *v18++ = *(_BYTE *)(a4 + j);
  for (uint64_t k = 0LL; k != 6; ++k)
    *v18++ = *(_BYTE *)(a5 + k);
  for (uint64_t m = 0LL; m != 4; ++m)
    *v18++ = *(_BYTE *)(a6 + m);
  mDNSPlatformSendRawPacket(v9, (uint64_t)v18, *(void *)(a3 + 32));
}

void SendNDP(uint64_t a1, int a2, char a3, uint64_t a4, int8x8_t *a5, int *a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10 = (void *)(a1 + 28916);
  __int16 v45 = 767;
  uint64_t v46 = 0LL;
  char v47 = 0;
  __int16 v48 = -255;
  char v49 = *(_BYTE *)(a7 + 13);
  __int16 v50 = *(_WORD *)(a7 + 14);
  if (a2 == 135) {
    int v11 = &v45;
  }
  else {
    int v11 = (__int16 *)a7;
  }
  uint64_t v12 = *(void *)(a4 + 32);
  int v13 = (void *)(a1 + 12664);
  do
  {
    int v13 = (void *)*v13;
    if (!v13)
    {
      int v29 = (os_log_s *)mDNSLogCategory_Default;
      GetRRDisplayString_rdb( (unsigned __int8 *)(a4 + 8),  (unsigned __int16 *)(*(void *)(a4 + 48) + 4LL),  (_BYTE *)(a1 + 46976));
      LogMsgWithLevel( v29,  OS_LOG_TYPE_DEFAULT,  "SendNDP: No interface with InterfaceID %p found %s",  v30,  v31,  v32,  v33,  v34,  v12);
      return;
    }
  }

  while (v13[782] != v12);
  uint64_t v14 = 0LL;
  int v15 = (_BYTE *)(a1 + 28916);
  do
    *v15++ = *(_BYTE *)(a8 + v14++);
  while (v14 != 6);
  uint64_t v16 = 0LL;
  uint64_t v17 = v13 + 788;
  do
  {
    if (a6)
    {
      int v43 = *a6;
      __int16 v18 = *((_WORD *)a6 + 2);
    }

    else
    {
      int v43 = *(_DWORD *)v17;
      __int16 v18 = *((_WORD *)v17 + 2);
    }

    __int16 v44 = v18;
    v15[v16] = *((_BYTE *)&v43 + v16);
    ++v16;
  }

  while (v16 != 6);
  uint64_t v19 = 0LL;
  uint64_t v20 = v15 + 6;
  *((_WORD *)v15 + 3) = -8826;
  v15[8] = 96;
  *(_DWORD *)(v15 + 9) = 0;
  *(_WORD *)(v15 + 13) = 14880;
  uint64_t v21 = v15 + 16;
  v20[9] = -1;
  do
    *v21++ = a5->i8[v19++];
  while (v19 != 16);
  for (uint64_t i = 0LL; i != 16; ++i)
  {
    uint64_t v23 = v21;
    *v21++ = *((_BYTE *)v11 + i);
  }

  *uint64_t v21 = a2;
  *(_WORD *)(v21 + 1) = 0;
  v21[3] = 0;
  v21[4] = a3;
  *(_WORD *)(v21 + 5) = 0;
  uint64_t v24 = v23 + 9;
  v21[7] = 0;
  if (a2 == 135)
  {
    for (uint64_t j = 0LL; j != 16; ++j)
    {
      uint64_t v26 = v24;
      *v24++ = *(_BYTE *)(a7 + j);
    }

    if (vorr_s8(*a5, (int8x8_t)*(_OWORD *)&vextq_s8(*(int8x16_t *)a5->i8, *(int8x16_t *)a5->i8, 8uLL)))
    {
      uint64_t v27 = 0LL;
      *(_WORD *)uint64_t v24 = 257;
      uint64_t v24 = v26 + 3;
      do
      {
        if (a6)
        {
          int v41 = *a6;
          __int16 v28 = *((_WORD *)a6 + 2);
        }

        else
        {
          int v41 = *(_DWORD *)v17;
          __int16 v28 = *((_WORD *)v17 + 2);
        }

        __int16 v42 = v28;
        *v24++ = *((_BYTE *)&v41 + v27++);
      }

      while (v27 != 6);
    }
  }

  else
  {
    for (uint64_t k = 0LL; k != 16; ++k)
    {
      uint64_t v36 = v24;
      *v24++ = a5->i8[k];
    }

    uint64_t v37 = 0LL;
    *(_WORD *)uint64_t v24 = 258;
    uint64_t v24 = v36 + 3;
    do
    {
      if (a6)
      {
        int v39 = *a6;
        __int16 v38 = *((_WORD *)a6 + 2);
      }

      else
      {
        int v39 = *(_DWORD *)v17;
        __int16 v38 = *((_WORD *)v17 + 2);
      }

      __int16 v40 = v38;
      *v24++ = *((_BYTE *)&v39 + v37++);
    }

    while (v37 != 6);
  }

  *(_BYTE *)(a1 + 28935) = (_BYTE)v24 - (a1 + 42);
  *(_WORD *)(a1 + 28972) = ~(unsigned __int16)IPv6CheckSum( (uint64_t)a5,  (uint64_t)v11,  (unsigned __int16 *)(a1 + 28970),  ((_BYTE)v24 - (a1 + 42)));
  mDNSPlatformSendRawPacket(v10, (uint64_t)v24, *(void *)(a4 + 32));
}

uint64_t DetermineOwnerRecordSpace(uint64_t a1)
{
  uint64_t v1 = dword_100158C4C;
  if (dword_100158C4C)
  {
    unsigned int v2 = *(_DWORD *)(a1 + 6304);
    if (v2)
    {
      uint64_t v1 = 29LL;
      if ((unsigned __int16)dword_100158BD0 == (unsigned __int16)v2 && HIWORD(dword_100158BD0) == HIWORD(v2))
      {
        if (word_100158BD4 == *(_WORD *)(a1 + 6308)) {
          return 23LL;
        }
        else {
          return 29LL;
        }
      }
    }

    else
    {
      return 0LL;
    }
  }

  return v1;
}

uint64_t BuildQuestion( uint64_t a1, uint64_t a2, unint64_t a3, unint64_t *a4, uint64_t a5, uint64_t **a6, unsigned int *a7, uint64_t a8)
{
  if ((*(_DWORD *)(a5 + 232) || *(_BYTE *)(a5 + 332)) && *(_BYTE *)(a1 + 12))
  {
    unint64_t v14 = a3 + 1452;
    unint64_t v15 = a3 + 1452 - *a7;
    BOOL v16 = *(_BYTE *)(a2 + 6381) != 0;
    if (*(_BYTE *)(a2 + 6381)) {
      unsigned __int16 v17 = 0x8000;
    }
    else {
      unsigned __int16 v17 = 0;
    }
  }

  else
  {
    BOOL v16 = 0;
    unsigned __int16 v17 = 0;
    unint64_t v14 = a3 + 1452;
    unint64_t v15 = a3 + 1452 - *a7;
  }

  uint64_t result = (uint64_t)putQuestion( a3,  *a4,  v15,  (unsigned __int8 *)(a5 + 356),  *(unsigned __int16 *)(a5 + 322),  *(unsigned __int16 *)(a5 + 324) | v17,  (uint64_t)a7,  a8);
  if (result)
  {
    uint64_t v19 = result;
    unint64_t v38 = v14;
    unsigned int v41 = *a7;
    uint64_t v20 = CacheGroupForName(a1, *(_DWORD *)(a5 + 200), (_BYTE *)(a5 + 356));
    uint64_t v26 = v20;
    uint64_t v27 = *a6;
    __int16 v40 = a4;
    BOOL v39 = v16;
    if (v20)
    {
      uint64_t v28 = v20[2];
      if (v28)
      {
        while (1)
        {
          if (*(void *)(v28 + 32) != *(void *)(a5 + 64)
            || (*(_BYTE *)(v28 + 8) & 0x32) != 0
            || ((v29 = (uint64_t *)(v28 + 72), !*(void *)(v28 + 72)) ? (BOOL v30 = v27 == v29) : (BOOL v30 = 1),
                v30
             || *(unsigned __int16 *)(v28 + 20) > 0x400u
             || !SameNameRecordAnswersQuestion((unsigned __int8 *)(v28 + 8), 0, a5, v21, v22, v23, v24, v25)
             || *(_DWORD *)(v28 + 80) - *(_DWORD *)(a1 + 64) + ((1000 * *(_DWORD *)(v28 + 16)) >> 1) < 1001))
          {
            int v29 = v27;
          }

          else
          {
            uint64_t *v27 = v28;
            uint64_t v31 = v41 + *(unsigned __int16 *)(v28 + 22) + 12;
            unsigned int v32 = *(unsigned __int16 *)(a3 + 4);
            v41 += *(unsigned __int16 *)(v28 + 22) + 12;
            if (v32 >= 2 && v19 + v31 >= v38)
            {
              *(_WORD *)(a3 + 4) = v32 - 1;
              uint64_t v36 = *a6;
              uint64_t v37 = **a6;
              if (!v37) {
                return 0LL;
              }
              uint64_t result = 0LL;
              do
              {
                *uint64_t v36 = 0LL;
                uint64_t v36 = (uint64_t *)(v37 + 72);
                uint64_t v37 = *(void *)(v37 + 72);
              }

              while (v37);
              return result;
            }
          }

          uint64_t v28 = *(void *)v28;
          uint64_t v27 = v29;
          if (!v28) {
            goto LABEL_27;
          }
        }
      }
    }

    int v29 = *a6;
LABEL_27:
    unint64_t *v40 = v19;
    *a7 = v41;
    *a6 = v29;
    if (v39)
    {
      unsigned int v33 = *(_DWORD *)(a1 + 64);
      if (v33 <= 1) {
        unsigned int v33 = 1;
      }
      *(_DWORD *)(a5 + 216) = v33;
    }

    if (v26)
    {
      for (uint64_t i = v26[2]; i; uint64_t i = *(void *)i)
      {
        if (*(void *)(i + 32) == *(void *)(a5 + 64))
        {
          if (*(void *)(i + 72)) {
            BOOL v35 = 1;
          }
          else {
            BOOL v35 = v29 == (uint64_t *)(i + 72);
          }
          if (!v35 && SameNameRecordAnswersQuestion((unsigned __int8 *)(i + 8), 0, a5, v21, v22, v23, v24, v25))
          {
            ++*(_BYTE *)(i + 108);
            *(_DWORD *)(i + 104) = *(_DWORD *)(a1 + 64);
            SetNextCacheCheckTimeForRecord(a1, i);
          }
        }
      }
    }

    return 1LL;
  }

  return result;
}

uint64_t *UnsafeBufferPointer(uint64_t *a1, uint64_t a2, uint64_t **a3)
{
  uint64_t result = mDNSGetTSRForAuthRecordNamed(a1, *(_BYTE **)(a2 + 40), *(_DWORD *)(a2 + 24));
  if (result)
  {
    uint64_t v6 = result;
    uint64_t v7 = *(_BYTE **)(a2 + 40);
    while (1)
    {
      a3 = (uint64_t **)*a3;
      if (!a3) {
        break;
      }
      if (SameDomainNameBytes(a3[2], v7))
      {
        if (a3[1]) {
          return 0LL;
        }
        return (uint64_t *)(v6[6] + 8);
      }
    }

    return (uint64_t *)(v6[6] + 8);
  }

  return result;
}

BOOL AddRecordInProbe(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (*(_BYTE *)(a3 + 194)) {
    return 0LL;
  }
  if (*(_WORD *)(a3 + 12) == 41) {
    return 0LL;
  }
  uint64_t v7 = mDNSGetTSRForAuthRecordNamed(*(uint64_t **)(a1 + 12624), *(_BYTE **)(a2 + 40), *(_DWORD *)(a2 + 24));
  unint64_t v14 = v7;
  if (*(void *)(a3 + 88))
  {
    if (!v7) {
      return 0LL;
    }
  }

  uint64_t v15 = *(void *)(a3 + 32);
  if (v15)
  {
    if (v15 != a4) {
      return 0LL;
    }
  }

  else if (!mDNSPlatformValidRecordForInterface(a3, a4, v8, v9, v10, v11, v12, v13))
  {
    return 0LL;
  }

  if (v14)
  {
    uint64_t v16 = *(void *)(a2 + 96);
    if (!v16) {
      uint64_t v16 = a2;
    }
    uint64_t v17 = *(void *)(a3 + 96);
    if (!v17) {
      uint64_t v17 = a3;
    }
    if (v16 == v17) {
      return SameResourceRecordNameClassInterface(a2, a3, v8, v9, v10, v11, v12, v13);
    }
  }

  if (*(_BYTE *)(a3 + 8) == 2 || *(void *)(a3 + 88)) {
    return SameResourceRecordNameClassInterface(a2, a3, v8, v9, v10, v11, v12, v13);
  }
  return 0LL;
}

uint64_t SetupOwnerOpt(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_BYTE *)(a3 + 4) = 0;
  *(_BYTE *)(a3 + 5) = *(_BYTE *)(result + 142);
  int v3 = *(_DWORD *)(result + 24);
  *(_WORD *)(a3 + 10) = *(_WORD *)(result + 28);
  *(_DWORD *)(a3 + 6) = v3;
  int v4 = *(_DWORD *)(a2 + 6304);
  *(_WORD *)(a3 + 16) = *(_WORD *)(a2 + 6308);
  *(_DWORD *)(a3 + 12) = v4;
  *(_DWORD *)(a3 + 1_Block_object_dispose(va, 8) = 0;
  *(_WORD *)(a3 + 22) = 0;
  *(_WORD *)a3 = 4;
  if (*(unsigned __int16 *)(result + 24) == *(unsigned __int16 *)(a2 + 6304))
  {
    __int16 v5 = 14;
    if (*(unsigned __int16 *)(result + 26) == *(unsigned __int16 *)(a2 + 6306))
    {
      else {
        __int16 v5 = 14;
      }
    }
  }

  else
  {
    __int16 v5 = 14;
  }

  *(_WORD *)(a3 + 2) = v5;
  return result;
}

char *AddTSRROptsToMessage( void *a1, unint64_t a2, _WORD *a3, char *__dst, unint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  __int128 v52 = 0u;
  memset(v53, 0, sizeof(v53));
  __int128 v50 = 0u;
  __int128 v51 = 0u;
  __int128 v48 = 0u;
  __int128 v49 = 0u;
  __int128 v46 = 0u;
  __int128 v47 = 0u;
  __int128 v44 = 0u;
  __int128 v45 = 0u;
  __int128 v42 = 0u;
  __int128 v43 = 0u;
  __int128 v40 = 0u;
  __int128 v41 = 0u;
  __int128 v38 = 0u;
  __int128 v39 = 0u;
  __int128 v28 = 0u;
  __int128 v29 = 0u;
  unsigned int v13 = __rev16((unsigned __int16)*a3);
  LOWORD(v3_Block_object_dispose(va, 8) = 264;
  memset(v27, 0, sizeof(v27));
  WORD2(v27[0]) = 41;
  *((void *)&v28 + 1) = &v38;
  WORD6(v27[0]) = 24;
  unint64_t v14 = __dst;
  while (1)
  {
    a1 = (void *)*a1;
    if (!a1) {
      break;
    }
    uint64_t v15 = a1[1];
    HIDWORD(v3_Block_object_dispose(va, 8) = *(_DWORD *)(v15 + 4);
    LOWORD(v39) = *(_WORD *)(v15 + 8);
    LODWORD(v15) = *(_DWORD *)v15;
    DWORD1(v3_Block_object_dispose(va, 8) = 720362;
    DWORD2(v3_Block_object_dispose(va, 8) = v15;
    unint64_t v14 = putRData(a2, v14, a5, (uint64_t)v27, a5, a6, a7, a8);
    if (!v14)
    {
      uint64_t v16 = (os_log_s *)mDNSLogCategory_mDNS;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
      {
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_ERROR))
        {
          uint64_t v18 = a1[2];
          if (v18)
          {
            uint64_t v19 = (_BYTE *)a1[2];
            if (v18 == -256)
            {
LABEL_13:
              while (v19)
              {
                uint64_t v20 = *v19;
                if (!*v19)
                {
                  int v24 = (unsigned __int16)((_WORD)v19 - v18 + 1);
                  goto LABEL_36;
                }

                v19 += v20 + 1;
                if (v18 != -256) {
                  goto LABEL_12;
                }
              }
            }

            else
            {
LABEL_12:
            }

            int v24 = 257;
          }

          else
          {
            int v24 = 0;
          }

void TimeoutQuestions_internal( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v11 = *(void *)(a1 + 216);
  if (v11)
  {
    uint64_t v12 = (os_log_s *)mDNSLogCategory_Default;
    int v13 = v11 + 356;
    DNSTypeName(*(unsigned __int16 *)(v11 + 322));
    LogMsgWithLevel( v12,  OS_LOG_TYPE_DEFAULT,  "TimeoutQuestions ERROR m->CurrentQuestion already set: %##s (%s)",  v14,  v15,  v16,  v17,  v18,  v13);
  }

  *(void *)(a1 + 216) = a2;
  if (a2)
  {
    do
    {
      int v19 = *(_DWORD *)(a2 + 240);
      if (v19)
      {
        if (!*(_BYTE *)(a2 + 617))
        {
          uint64_t v20 = (os_log_s *)mDNSLogCategory_Default;
          DNSTypeName(*(unsigned __int16 *)(a2 + 322));
          LogMsgWithLevel( v20,  OS_LOG_TYPE_DEFAULT,  "TimeoutQuestions: ERROR!! TimeoutQuestion not set, but StopTime set for %##s (%s)",  v21,  v22,  v23,  v24,  v25,  a2 + 356);
          int v19 = *(_DWORD *)(a2 + 240);
        }

        if (*(_DWORD *)(a1 + 64) - v19 < 0)
        {
          if (*(_DWORD *)(a1 + 188) - v19 >= 1) {
            *(_DWORD *)(a1 + 18_Block_object_dispose(va, 8) = v19;
          }
        }

        else
        {
          if (mDNS_LoggingEnabled == 1) {
            LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "TimeoutQuestions: question %p %##s timed out, time %d",  a4,  a5,  a6,  a7,  a8,  a2);
          }
          *(_BYTE *)(a2 + 335) = 0;
          GenerateNegativeResponseEx(a1, a3, 3LL, 0LL, a5, a6, a7, a8, v27);
          if (*(void *)(a1 + 216) == a2) {
            *(_DWORD *)(a2 + 240) = 0;
          }
        }
      }

      uint64_t v26 = *(void *)(a1 + 216);
      if (v26 == a2)
      {
        uint64_t v26 = *(void *)(a2 + 8);
        *(void *)(a1 + 216) = v26;
      }

      a2 = v26;
    }

    while (v26);
  }

  *(void *)(a1 + 216) = 0LL;
}

void SendSPSRegistration( uint64_t a1, uint64_t a2, __int16 a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  __int128 v23 = 0uLL;
  int v24 = 0;
  SendSPSRegistrationForOwner(a1, a2, a3, (uint64_t)&v23, a5, a6, a7, a8);
  for (uint64_t i = *(uint64_t **)(a1 + 12624); i; uint64_t i = (uint64_t *)*i)
  {
    uint64_t v16 = (uint64_t *)((char *)i + 124);
    if ((void)v23 != *(uint64_t *)((char *)i + 124)
      || *((void *)&v23 + 1) != *(uint64_t *)((char *)i + 132)
      || v24 != (unint64_t)*((unsigned int *)i + 35))
    {
      uint64_t v19 = a1 + 12624;
      while (1)
      {
        uint64_t v19 = *(void *)v19;
        if (!v19 || v19 == (void)i) {
          break;
        }
        if (*v16 == *(void *)(v19 + 124)
          && *(uint64_t *)((char *)i + 132) == *(void *)(v19 + 132)
          && *((_DWORD *)i + 35) == (unint64_t)*(unsigned int *)(v19 + 140))
        {
          goto LABEL_24;
        }
      }

      __int128 v23 = *(_OWORD *)v16;
      int v24 = *((_DWORD *)i + 35);
      SendSPSRegistrationForOwner(a1, a2, a3, (uint64_t)&v23, v11, v12, v13, v14);
    }

void SendWakeup(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  uint64_t v7 = (_BYTE *)(a1 + 28916);
  uint64_t v8 = (void *)(a1 + 12664);
  do
  {
    uint64_t v8 = (void *)*v8;
    if (!v8)
    {
      uint64_t v19 = (os_log_s *)mDNSLogCategory_Default;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
          return;
        }
        int v22 = 134217984;
        uint64_t v23 = a2;
      }

      else
      {
        uint64_t v19 = (os_log_s *)mDNSLogCategory_Default_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
          return;
        }
        int v22 = 134217984;
        uint64_t v23 = a2;
      }

      _os_log_impl( (void *)&_mh_execute_header,  v19,  OS_LOG_TYPE_DEFAULT,  "SendARP: No interface with InterfaceID %p found",  (uint8_t *)&v22,  0xCu);
      return;
    }
  }

  while (v8[782] != a2);
  for (uint64_t i = 0LL; i != 6; ++i)
    v7[i] = *(_BYTE *)(a3 + i);
  uint64_t v10 = (_WORD *)(a1 + 28922);
  uint64_t v11 = v8 + 788;
  int v12 = 6;
  do
  {
    uint64_t v13 = v10;
    *(_BYTE *)uint64_t v10 = *v11;
    uint64_t v10 = (_WORD *)((char *)v10 + 1);
    --v12;
  }

  while (v12);
  *uint64_t v10 = 16904;
  *(_DWORD *)((char *)v13 + 3) = -1;
  *(_WORD *)((char *)v13 + 7) = -1;
  uint64_t v14 = a1 + 28936;
  do
  {
    uint64_t v15 = 0LL;
    uint64_t v16 = v14;
    do
    {
      *(_BYTE *)(v14 + v15) = *(_BYTE *)(a3 + v15);
      ++v15;
    }

    while (v15 != 6);
    v14 += 6LL;
    ++v12;
  }

  while (v12 != 16);
  for (uint64_t j = 0LL; j != 6; ++j)
    *(_BYTE *)(v16 + j + 6) = *(_BYTE *)(a4 + j);
  uint64_t v18 = v16 + 12;
  mDNSPlatformSendRawPacket((void *)(a1 + 28916), v16 + 12, a2);
  if (!a5)
  {
    *((_WORD *)v7 + 2) = -1;
    *(_DWORD *)uint64_t v7 = -1;
    mDNSPlatformSendRawPacket(v7, v18, a2);
  }

uint64_t ResourceRecordIsValidInterfaceAnswer( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = *(void *)(a1 + 32);
  if (v9)
  {
    uint64_t result = v9 == a2;
    if (v9 != a2) {
      return result;
    }
  }

  else
  {
    uint64_t result = mDNSPlatformValidRecordForInterface(a1, a2, a3, a4, a5, a6, a7, a8);
    if (!(_DWORD)result) {
      return result;
    }
  }

  return ResourceRecordIsValidAnswer(a1);
}

uint64_t AddRRSetAdditionalsToResponseList( uint64_t result, uint64_t **a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((*(_BYTE *)(a4 + 8) & 0x32) != 0)
  {
    for (uint64_t i = *(void *)(result + 12624); i; uint64_t i = *(void *)i)
    {
      if (*(_DWORD *)(i + 24) == *(_DWORD *)(a4 + 24)
        && i != a4
        && *(unsigned __int16 *)(i + 12) == *(unsigned __int16 *)(a4 + 12)
        && (*(_BYTE *)(i + 8) & 0x32) != 0
        && *(unsigned __int16 *)(i + 14) == *(unsigned __int16 *)(a4 + 14))
      {
        uint64_t result = ResourceRecordIsValidInterfaceAnswer(i, a5, a3, a4, a5, a6, a7, a8);
        if ((_DWORD)result)
        {
          uint64_t result = SameDomainNameBytes(*(_BYTE **)(i + 40), *(_BYTE **)(a4 + 40));
          if ((_DWORD)result)
          {
            if (!*(void *)(i + 256) && *a2 != (uint64_t *)(i + 256))
            {
              **a2 = i;
              uint64_t v13 = *(void *)(a3 + 272);
              if (!v13) {
                uint64_t v13 = a3;
              }
              *(void *)(i + 272) = v13;
              *a2 = (uint64_t *)(i + 256);
            }
          }
        }
      }
    }
  }

  return result;
}

void SendSPSRegistrationForOwner( uint64_t a1, uint64_t a2, __int16 a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  __int16 v9 = a3;
  if (*(unsigned __int16 *)(a1 + 24) == *(unsigned __int16 *)(a2 + 6304))
  {
    uint64_t v11 = -37LL;
    if (*(unsigned __int16 *)(a1 + 26) == *(unsigned __int16 *)(a2 + 6306)
      && *(unsigned __int16 *)(a1 + 28) == *(unsigned __int16 *)(a2 + 6308))
    {
      uint64_t v11 = -31LL;
    }
  }

  else
  {
    uint64_t v11 = -37LL;
  }

  int v87 = *(_DWORD *)(a2 + 2716) / 3;
  uint64_t v92 = *(void *)(a2 + 6256);
  uint64_t v12 = v92 + 5;
  uint64_t v13 = a2 + 20LL * v87;
  uint64_t v14 = &unk_100158000;
  if (*(_DWORD *)(v13 + 2648))
  {
    unint64_t v96 = a1 + 28904;
    __int16 v89 = (int *)(v13 + 2648);
    LOWORD(v15) = a3;
    uint64_t v16 = a1;
    if (a3)
    {
LABEL_12:
      uint64_t v90 = v92 >> 5;
      uint64_t v17 = (unsigned __int16 *)(v96 + 8);
      uint64_t v95 = a1 + 28916 + v11;
      int v93 = a2 + 6310;
      uint64_t v94 = (_BYTE *)(a1 + 46976);
      __int16 v88 = v15;
      while (1)
      {
        while (1)
        {
          *(_WORD *)unint64_t v96 = v15;
          *(_WORD *)(v96 + 2) = 40;
          *(void *)(v96 + 4) = 0LL;
          uint64_t v18 = *(void *)(v16 + 12624);
          if (!v18) {
            goto LABEL_87;
          }
          unint64_t v19 = a1 + 28916;
          do
          {
            if (*(void *)(v18 + 224)
              || (*(void *)(v18 + 32) || *(_BYTE *)(v18 + 122) || IsLocalDomain(*(_BYTE **)(v18 + 40)))
              && (*(_BYTE *)(v18 + 123) & 1) == 0
              && *(_WORD *)(v18 + 358)
              && *(_DWORD *)(v16 + 64) - (*(_DWORD *)(v18 + 284) + *(_DWORD *)(v18 + 280)) >= 0
              && (v92 > 0x3F || (*(_DWORD *)(v18 + 4 * v90 + 360) & (1 << v92)) != 0)
              && ((uint64_t v25 = *(void *)(v18 + 32)) == 0 || v25 == *(void *)(a2 + 6256)))
            {
              BOOL v20 = *(void *)a4 == *(void *)(v18 + 124) && *(void *)(a4 + 8) == *(void *)(v18 + 132);
              if (v20 && *(_DWORD *)(a4 + 16) == (unint64_t)*(unsigned int *)(v18 + 140))
              {
                if (*v17) {
                  uint64_t v22 = 1440LL;
                }
                else {
                  uint64_t v22 = 8940LL;
                }
                if (*(_WORD *)(v18 + 12) == 10
                  && ((uint64_t v23 = *(_BYTE **)(v18 + 40), *v23) ? (v24 = *v23 + 1LL) : (v24 = 0LL),
                      SameDomainLabelPointer(&v23[v24], "\n_keepalive")
                   && UpdateKeepaliveRData(v16, v18, a2, 0)))
                {
                  *(void *)(v18 + 224) = 0LL;
                }

                else
                {
                  if ((*(_BYTE *)(v18 + 8) & 0x32) != 0) {
                    *(_WORD *)(v18 + 14) |= 0x8000u;
                  }
                  unint64_t v26 = PutResourceRecordTTLWithLimit( v96,  v19,  v17,  v18 + 8,  *(unsigned int *)(v18 + 16),  v95 + v22,  a7,  a8);
                  *(_WORD *)(v18 + 14) &= ~0x8000u;
                  if (v26)
                  {
                    unint64_t v27 = v26;
                    if (v14[2840])
                    {
                      __int128 v28 = (os_log_s *)mDNSLogCategory_Default;
                      GetRRDisplayString_rdb( (unsigned __int8 *)(v18 + 8),  (unsigned __int16 *)(*(void *)(v18 + 48) + 4LL),  v94);
                      uint64_t v17 = (unsigned __int16 *)(v96 + 8);
                      uint64_t v14 = (_BYTE *)&unk_100158000;
                      uint64_t v16 = a1;
                      LogMsgWithLevel( v28,  OS_LOG_TYPE_DEFAULT,  "SendSPSRegistration put %s 0x%x 0x%x (updateid %d)  %s",  v29,  v30,  v31,  v32,  v33,  v93);
                    }

                    *(void *)(v18 + 224) = 0LL;
                    int v34 = 1000;
                    *(_DWORD *)(v18 + 280) = 1000;
                    int v35 = *(_DWORD *)(v16 + 64);
                    *(_DWORD *)(v18 + 284) = v35;
                    if (!*(_WORD *)(v18 + 358))
                    {
                      __int16 v36 = (os_log_s *)mDNSLogCategory_Default;
                      GetRRDisplayString_rdb( (unsigned __int8 *)(v18 + 8),  (unsigned __int16 *)(*(void *)(v18 + 48) + 4LL),  v94);
                      uint64_t v17 = (unsigned __int16 *)(v96 + 8);
                      LogMsgWithLevel( v36,  OS_LOG_TYPE_DEFAULT,  "SendSPSRegistration: ERROR!! rr %s updateid is zero",  v37,  v38,  v39,  v40,  v41,  (int)v94);
                      int v35 = *(_DWORD *)(v18 + 284);
                      int v34 = *(_DWORD *)(v18 + 280);
                    }

                    int v42 = v34 + v35;
                    if (*(_DWORD *)(v16 + 100) - v42 >= 0) {
                      *(_DWORD *)(v16 + 100) = v42;
                    }
                    unint64_t v19 = v27;
                  }

                  else if (v14[2840])
                  {
                    __int128 v43 = (os_log_s *)mDNSLogCategory_Default;
                    GetRRDisplayString_rdb( (unsigned __int8 *)(v18 + 8),  (unsigned __int16 *)(*(void *)(v18 + 48) + 4LL),  v94);
                    uint64_t v14 = &unk_100158000;
                    LogMsgWithLevel( v43,  OS_LOG_TYPE_DEFAULT,  "SendSPSRegistration put %s FAILED %d/%d %s",  v44,  v45,  v46,  v47,  v48,  v93);
                  }
                }
              }
            }

            uint64_t v18 = *(void *)v18;
          }

          while (v18);
          if (!*v17)
          {
LABEL_87:
            *(_DWORD *)(a2 + 2720) = *(_DWORD *)(v16 + 64) + 10000;
            __int16 v9 = a3;
            goto LABEL_92;
          }

          bzero(v98, 0x498uLL);
          v99[0] = 32;
          __int16 v100 = 41;
          __int16 v134 = 264;
          uint64_t v104 = v133;
          uint64_t v105 = &v134;
          char v113 = 0;
          char v114 = 0;
          __int128 v106 = 0u;
          __int128 v107 = 0u;
          __int128 v108 = 0u;
          __int128 v109 = 0u;
          __int128 v110 = 0u;
          __int128 v111 = 0u;
          uint64_t v112 = 0LL;
          uint64_t v115 = v133;
          __int16 v129 = 0;
          uint64_t v131 = 0LL;
          uint64_t v132 = 0LL;
          uint64_t v130 = 0LL;
          v133[0] = 0;
          __int128 v116 = 0u;
          __int128 v117 = 0u;
          __int128 v118 = 0u;
          __int128 v119 = 0u;
          __int128 v120 = 0u;
          __int128 v121 = 0u;
          __int128 v122 = 0u;
          __int128 v123 = 0u;
          __int128 v124 = 0u;
          __int128 v125 = 0u;
          __int128 v126 = 0u;
          __int128 v127 = 0u;
          memset(v128, 0, sizeof(v128));
          __int16 v101 = 1440;
          unsigned int v102 = 4500;
          int v103 = 3145776;
          uint64_t v135 = 0x1C2000040002LL;
          unsigned int v51 = *(_DWORD *)(a4 + 2);
          if (v51)
          {
            __int128 v137 = *(_OWORD *)a4;
            int v138 = *(_DWORD *)(a4 + 16);
            v136[0] = 4;
            if (*(unsigned __int16 *)(a4 + 8) == (unsigned __int16)v51 && *(unsigned __int16 *)(a4 + 10) == HIWORD(v51))
            {
              else {
                __int16 v52 = 14;
              }
            }

            else
            {
              __int16 v52 = 14;
            }

            v136[1] = v52;
          }

          else
          {
            SetupOwnerOpt(v16, a2, (uint64_t)v136);
          }

          if (v14[2840] == 1)
          {
            uint64_t v53 = (os_log_s *)mDNSLogCategory_Default;
            GetRRDisplayString_rdb(v99, (unsigned __int16 *)v105 + 2, v94);
            LogMsgWithLevel(v53, OS_LOG_TYPE_DEFAULT, "SendSPSRegistration put %s %s", v54, v55, v56, v57, v58, v93);
          }

          unint64_t v59 = PutResourceRecordTTLWithLimit(v96, v19, (_WORD *)(a1 + 28914), (uint64_t)v99, v102, a1 + 37856, v49, v50);
          if (v59) {
            break;
          }
          uint64_t v70 = (os_log_s *)mDNSLogCategory_Default;
          int v71 = *v17;
          GetRRDisplayString_rdb(v99, (unsigned __int16 *)v105 + 2, v94);
          LogMsgWithLevel( v70,  OS_LOG_TYPE_DEFAULT,  "SendSPSRegistration: Failed to put OPT record (%d updates) %s",  v72,  v73,  v74,  v75,  v76,  v71);
          LOWORD(v15) = v88;
        }

        unint64_t v64 = v59;
        uint64_t v65 = *(int **)(v16 + 19824);
        LOWORD(v15) = v88;
        if (!v65)
        {
          uint64_t v65 = mDNSPlatformUDPSocket(0);
          *(void *)(v16 + 19824) = v65;
          if (!v65)
          {
            uint64_t v85 = (os_log_s *)mDNSLogCategory_SPS;
            if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_SPS == mDNSLogCategory_State)
            {
              __int16 v9 = a3;
              if (!os_log_type_enabled((os_log_t)mDNSLogCategory_SPS, OS_LOG_TYPE_ERROR)) {
                goto LABEL_92;
              }
              *(_WORD *)buf = 0;
            }

            else
            {
              uint64_t v85 = (os_log_s *)mDNSLogCategory_SPS_redacted;
              __int16 v9 = a3;
              if (!os_log_type_enabled((os_log_t)mDNSLogCategory_SPS_redacted, OS_LOG_TYPE_ERROR)) {
                goto LABEL_92;
              }
              *(_WORD *)buf = 0;
            }

            _os_log_impl( (void *)&_mh_execute_header,  v85,  OS_LOG_TYPE_ERROR,  "SendSPSRegistration: Failed to allocate SPClientSocket",  buf,  2u);
            goto LABEL_92;
          }
        }

        *(_BYTE *)(v16 + 144) = 1;
        if (v14[2840] == 1)
        {
          LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "SendSPSRegistration: Sending Update %s %d (%d) id %5d with %d records %d bytes to %#a:%d",  v60,  v61,  (uint64_t)v65,  v62,  v63,  v93);
          uint64_t v65 = *(int **)(v16 + 19824);
        }

        int v66 = mDNSSendDNSMessage( v16,  v96,  v64,  *(void *)(a2 + 6256),  0LL,  (unsigned __int16 *)v65,  v89,  *(_WORD *)(a2 + 2LL * v87 + 2708),  0LL,  0);
        if (v66)
        {
          if (v14[2840]) {
            break;
          }
        }

        if (v66)
        {
LABEL_82:
          if (*v89 == 4 && *(_DWORD *)(a2 + 656LL * v87 + 892) == -1)
          {
            if (v14[2840] == 1) {
              LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "SendSPSRegistration %d %##s failed to send to IPv4 address; will try IPv6 instead",
            }
                v67,
                v68,
                v69,
                a7,
                a8,
                v87);
            *(_WORD *)(a2 + 656LL * v87 + 1002) = 28;
            mDNS_StartQuery_internal(v16, a2 + 656LL * v87 + 680);
            return;
          }
        }
      }

      LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "SendSPSRegistration: mDNSSendDNSMessage err %d",  v67,  v68,  v69,  a7,  a8,  v66);
      goto LABEL_82;
    }

    uint64_t v79 = mDNS_NewMessageID(a1);
    uint64_t v80 = v79;
    int v81 = *(uint64_t **)(a1 + 12624);
    if (!v81)
    {
      LOWORD(v15) = v79;
      goto LABEL_12;
    }

    while (1)
    {
      if ((*((_BYTE *)v81 + 123) & 1) == 0 && *((unsigned __int8 *)v81 + 8) >= 2u)
      {
        uint64_t v82 = v81[4];
        if (v82 == *(void *)(a2 + 6256) || !v82 && (*((_BYTE *)v81 + 122) || IsLocalDomain((_BYTE *)v81[5])))
        {
          if (v83 && *(_DWORD *)(a4 + 16) == (unint64_t)*((unsigned int *)v81 + 35))
          {
            v81[28] = -1LL;
            uint64_t v15 = *((unsigned __int16 *)v81 + 179);
            if (*((_WORD *)v81 + 179)) {
              goto LABEL_111;
            }
            *((_WORD *)v81 + 179) = v80;
          }
        }
      }

      uint64_t v15 = v80;
LABEL_111:
      int v81 = (uint64_t *)*v81;
      uint64_t v80 = v15;
      if (!v81) {
        goto LABEL_12;
      }
    }
  }

  int v77 = *(_DWORD *)(a1 + 64) + 1000;
  *(_DWORD *)(a2 + 2720) = v77;
  if (*(_DWORD *)(a1 + 184) - v77 >= 1) {
    *(_DWORD *)(a1 + 184) = v77;
  }
  if (mDNS_LoggingEnabled == 1) {
    LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "SendSPSRegistration: %s SPS %d (%d) %##s not yet resolved",  a4,  a5,  a6,  a7,  a8,  a2 + 6310);
  }
LABEL_92:
  if (!v9)
  {
    int v78 = *(_DWORD *)(a2 + 2716);
    if (v78 <= 7) {
      *(_DWORD *)(a2 + 2716) = v78 + 1;
    }
  }

uint64_t UpdateKeepaliveRData(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v65 = 0LL;
  uint64_t v66 = 0LL;
  int v67 = 0;
  uint64_t v62 = 0LL;
  uint64_t v63 = 0LL;
  int v64 = 0;
  __int16 v61 = 0;
  int v59 = 0;
  int v60 = 0;
  unsigned int v58 = 0;
  memset(__src, 0, sizeof(__src));
  mDNS_ExtractKeepaliveInfo(a2, &v58, &v65, &v62, (uint64_t)&v60, &v57, &v56, (_WORD *)&v59 + 1, &v59, &v55);
  if (v58
    && v65 != 4
    && ((_DWORD)v65 != 6 || v66 | HIDWORD(v66) | v67 | HIDWORD(v65))
    && v62 != 4
    && ((_DWORD)v62 != 6 || v63 | HIDWORD(v63) | v64 | HIDWORD(v62))
    && HIWORD(v59)
    && (_WORD)v59)
  {
    if (a4) {
      goto LABEL_16;
    }
    memset(v54, 0, sizeof(v54));
    uint64_t TCPInfo = mDNSPlatformRetrieveTCPInfo((uint64_t)&v65, SHIWORD(v59), (uint64_t)&v62, v59, (uint64_t)v54);
    if ((_DWORD)TCPInfo)
    {
      uint64_t v15 = TCPInfo;
      LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "mDNSPlatformRetrieveTCPInfo: mDNSPlatformRetrieveTCPInfo failed %d",  v18,  v19,  v20,  v21,  v22,  TCPInfo);
      return v15;
    }

    if (!a3 || v54[0] == *(void *)(a3 + 6256))
    {
LABEL_16:
      __int16 v23 = mDNS_snprintf((char *)__src + 1);
      if (v23 == 255)
      {
        uint64_t v24 = (os_log_s *)mDNSLogCategory_Default;
        uint64_t v25 = (_BYTE *)(a1 + 46976);
        GetRRDisplayString_rdb((unsigned __int8 *)(a2 + 8), (unsigned __int16 *)(*(void *)(a2 + 48) + 4LL), v25);
        LogMsgWithLevel( v24,  OS_LOG_TYPE_DEFAULT,  "UpdateKeepaliveRData: could not allocate memory %s",  v26,  v27,  v28,  v29,  v30,  (int)v25);
        return 4294901757LL;
      }

      else
      {
        LOBYTE(__src[0]) = v23 + 1;
        unsigned __int16 v31 = v23 + 2;
        else {
          uint64_t v32 = (unsigned __int16)(v23 + 2);
        }
        uint64_t v33 = malloc(v32 + 4);
        if (!v33) {
          __break(1u);
        }
        uint64_t v34 = (uint64_t)v33;
        *uint64_t v33 = v32;
        memcpy(v33 + 2, __src, v31);
        uint64_t v40 = *(unsigned __int16 **)(a2 + 48);
        if (v40 != (unsigned __int16 *)(a2 + 908))
        {
          if (mDNS_LoggingEnabled == 1)
          {
            uint64_t v41 = (os_log_s *)mDNSLogCategory_Default;
            GetRRDisplayString_rdb((unsigned __int8 *)(a2 + 8), v40 + 2, (_BYTE *)(a1 + 46976));
            LogMsgWithLevel( v41,  OS_LOG_TYPE_DEFAULT,  "UpdateKeepaliveRData: Freed allocated memory for keep alive packet: %s ",  v42,  v43,  v44,  v45,  v46,  a1 + 46976);
            uint64_t v40 = *(unsigned __int16 **)(a2 + 48);
          }

          if (v40) {
            free(v40);
          }
        }

        SetNewRData(a2 + 8, v34, v31, v35, v36, v37, v38, v39);
        if (mDNS_LoggingEnabled == 1)
        {
          uint64_t v47 = (os_log_s *)mDNSLogCategory_Default;
          uint64_t v48 = (_BYTE *)(a1 + 46976);
          GetRRDisplayString_rdb((unsigned __int8 *)(a2 + 8), (unsigned __int16 *)(*(void *)(a2 + 48) + 4LL), v48);
          LogMsgWithLevel( v47,  OS_LOG_TYPE_DEFAULT,  "UpdateKeepaliveRData: successfully updated the record %s",  v49,  v50,  v51,  v52,  v53,  (int)v48);
        }

        return 0LL;
      }
    }

    else
    {
      uint64_t v15 = 4294901756LL;
      if (mDNS_LoggingEnabled == 1) {
        LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "mDNSPlatformRetrieveTCPInfo: InterfaceID mismatch mti.IntfId = %p InterfaceID = %p",  v18,  v19,  v20,  v21,  v22,  v54[0]);
      }
    }
  }

  else
  {
    uint64_t v8 = (os_log_s *)mDNSLogCategory_Default;
    __int16 v9 = (_BYTE *)(a1 + 46976);
    GetRRDisplayString_rdb((unsigned __int8 *)(a2 + 8), (unsigned __int16 *)(*(void *)(a2 + 48) + 4LL), v9);
    LogMsgWithLevel( v8,  OS_LOG_TYPE_DEFAULT,  "UpdateKeepaliveRData: not a valid record %s for keepalive %#a:%d %#a:%d",  v10,  v11,  v12,  v13,  v14,  (int)v9);
    return 4294901759LL;
  }

  return v15;
}

uint64_t IPv6CheckSum(uint64_t a1, uint64_t a2, unsigned __int16 *a3, int a4)
{
  __int16 v14 = 0;
  char v15 = BYTE1(a4);
  char v16 = a4;
  int v17 = 973078528;
  if (a4 < 1)
  {
    unsigned int v4 = 0;
  }

  else
  {
    unsigned int v4 = 0;
    unsigned int v5 = a4 + 2;
    do
    {
      int v6 = *a3++;
      v4 += v6;
      v5 -= 2;
    }

    while (v5 > 2);
  }

  unsigned int v7 = ((HIWORD(v4) + (unsigned __int16)v4) >> 16) + (unsigned __int16)(HIWORD(v4) + v4);
  if (v7 == 0xFFFF) {
    unsigned int v7 = 0;
  }
  else {
    unsigned int v7 = (unsigned __int16)v7;
  }
  uint64_t v8 = (unsigned __int16 *)&v13;
  for (unsigned int i = 42; i > 2; i -= 2)
  {
    int v10 = *v8++;
    v7 += v10;
  }

  unsigned int v11 = ((HIWORD(v7) + (unsigned __int16)v7) >> 16) + (unsigned __int16)(HIWORD(v7) + v7);
  if (v11 == 0xFFFF) {
    LOWORD(v11) = 0;
  }
  return (unsigned __int16)v11;
}

void NetWakeResolve(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v8 = *(void *)(a2 + 176);
  unint64_t v9 = 0x8F9C18F9C18F9C19LL * ((a2 - v8 - 680) >> 4);
  if (mDNS_LoggingEnabled == 1)
  {
    int v10 = (os_log_s *)mDNSLogCategory_Default;
    GetRRDisplayString_rdb( (unsigned __int8 *)a3,  (unsigned __int16 *)(*(void *)(a3 + 40) + 4LL),  (_BYTE *)(a1 + 46976));
    LogMsgWithLevel(v10, OS_LOG_TYPE_DEFAULT, "NetWakeResolve: SPS: %d Add: %d %s", v11, v12, v13, v14, v15, v9);
  }

  if (!a4) {
    return;
  }
  int v16 = *(unsigned __int16 *)(a3 + 4);
  if (v16 != 1)
  {
    if (v16 != 28)
    {
      if (v16 == 33)
      {
        mDNS_StopQuery((unsigned int *)a1, a2);
        *(_WORD *)(v8 + 2LL * (int)v9 + 270_Block_object_dispose(va, 8) = *(_WORD *)(*(void *)(a3 + 40) + 8LL);
        uint64_t v17 = *(void *)(a3 + 40);
        uint64_t v18 = (const void *)(v17 + 10);
        unint64_t v19 = v17 + 266;
        uint64_t v20 = (_BYTE *)(v17 + 10);
        if (v19)
        {
LABEL_9:
        }

        else
        {
LABEL_10:
          while (v20)
          {
            uint64_t v21 = *v20;
            if (!*v20)
            {
              unsigned __int16 v43 = (_WORD)v20 - (_WORD)v18 + 1;
              if (v43 > 0x100u) {
                break;
              }
              memcpy((void *)(a2 + 356), v18, v43);
              goto LABEL_34;
            }

            v20 += v21 + 1;
            if (v19) {
              goto LABEL_9;
            }
          }
        }

        *(_BYTE *)(a2 + 356) = 0;
LABEL_34:
        __int16 v42 = 1;
        goto LABEL_35;
      }

      return;
    }

    if (*(_WORD *)(a3 + 12) != 16) {
      return;
    }
    uint64_t v30 = *(void *)(a3 + 40);
    mDNS_StopQuery((unsigned int *)a1, a2);
    *(_DWORD *)(a2 + 212) = -1;
    uint64_t v31 = v8 + 20LL * (int)v9 + 2648;
    *(_DWORD *)uint64_t v31 = 6;
    *(_OWORD *)(v31 + 4) = *(_OWORD *)(*(void *)(a3 + 40) + 4LL);
    mDNS_Lock_((unsigned int *)a1, (uint64_t)"NetWakeResolve", 7902);
    if (*(_DWORD *)(v8 + 2716) / 3 == (_DWORD)v9) {
      SendSPSRegistration(a1, v8, 0, v32, v33, v34, v35, v36);
    }
    uint64_t v28 = a1;
    int v29 = 7904;
LABEL_26:
    mDNS_Unlock_(v28, (uint64_t)"NetWakeResolve", v29);
    return;
  }

  if (!*(_WORD *)(a3 + 12))
  {
    mDNS_StopQuery((unsigned int *)a1, a2);
    if (mDNS_LoggingEnabled == 1) {
      LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "NetWakeResolve: SPS %d %##s has no IPv4 address, will try IPv6 instead",  v37,  v38,  v39,  v40,  v41,  v9);
    }
    __int16 v42 = 28;
LABEL_35:
    *(_WORD *)(a2 + 322) = v42;
    mDNS_StartQuery((unsigned int *)a1, a2);
    return;
  }

  if (*(_WORD *)(a3 + 12) == 4)
  {
    mDNS_StopQuery((unsigned int *)a1, a2);
    *(_DWORD *)(a2 + 212) = -1;
    uint64_t v22 = v8 + 20LL * (int)v9;
    *(_DWORD *)(v22 + 264_Block_object_dispose(va, 8) = 4;
    *(_DWORD *)(v22 + 2652) = *(_DWORD *)(*(void *)(a3 + 40) + 4LL);
    mDNS_Lock_((unsigned int *)a1, (uint64_t)"NetWakeResolve", 7883);
    if (*(_DWORD *)(v8 + 2716) / 3 == (_DWORD)v9) {
      SendSPSRegistration(a1, v8, 0, v23, v24, v25, v26, v27);
    }
    uint64_t v28 = a1;
    int v29 = 7885;
    goto LABEL_26;
  }

void SendSleepGoodbyes( uint64_t a1, uint64_t a2, uint64_t a3, char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  *(_BYTE *)(a1 + 141) = 2;
  if ((_DWORD)a2)
  {
    unint64_t v9 = *(uint64_t **)(a1 + 12664);
    if (v9)
    {
      while (!*((_BYTE *)v9 + 16))
      {
        unint64_t v9 = (uint64_t *)*v9;
        if (!v9) {
          goto LABEL_5;
        }
      }

LABEL_5:
  if ((_DWORD)a3)
  {
    for (uint64_t i = *(void *)(a1 + 12624); i; uint64_t i = *(void *)i)
    {
      if (!*(void *)(i + 32) && !*(_BYTE *)(i + 122) && !IsLocalDomain(*(_BYTE **)(i + 40)))
      {
        uint64_t v11 = *(_DWORD **)(i + 376);
        if (v11)
        {
          *(_WORD *)(i + 35_Block_object_dispose(va, 8) = 0;
          CancelGetZoneData(a1, v11);
          *(void *)(i + 376) = 0LL;
        }

        if (*(void *)(i + 584))
        {
          mDNS_StopNATOperation_internal(a1, i + 392);
          *(void *)(i + 584) = 0LL;
        }

        if (*(_DWORD *)(i + 344) == 7)
        {
          *(_DWORD *)(i + 344) = 2;
          uint64_t v12 = *(void (**)(uint64_t, uint64_t, void, void))(i + 320);
          if (v12) {
            v12(a1, i, *(void *)(i + 624), *(unsigned __int16 *)(i + 616));
          }
          SetNewRData(i + 8, *(void *)(i + 632), *(unsigned __int16 *)(i + 618), (uint64_t)a4, a5, a6, a7, a8);
          *(_OWORD *)(i + 624) = 0u;
        }

        uDNS_DeregisterRecord(a1, i);
      }
    }
  }

  for (uint64_t j = *(uint64_t **)(a1 + 12624); j; uint64_t j = (uint64_t *)*j)
  {
    if (*((_BYTE *)j + 8) == 8 && *((_BYTE *)j + 192)) {
      j[26] = -1LL;
    }
  }

  SendResponses(a1, a2, a3, a4, a5, a6, a7, a8);
}

  unsigned int v4 = (char *)v16;
  while (2)
  {
    else {
      unsigned int v5 = v4 + 64;
    }
    int v6 = v4 + 1;
    unsigned int v7 = v4 + 1;
    uint64_t v8 = (unsigned __int8 *)a1;
    do
    {
      a1 = (char *)(v8 + 1);
      if (v3 == 92)
      {
        int v3 = *a1;
        if (!*a1)
        {
          uint64_t v14 = -6750;
          goto LABEL_28;
        }

        a1 = (char *)(v8 + 2);
        if (v3 - 48 <= 9)
        {
          unint64_t v9 = *a1;
          if ((v9 - 48) <= 9)
          {
            int v10 = v8[3];
            if ((v10 - 48) <= 9)
            {
              uint64_t v11 = 100 * v3 + 10 * (char)v9 + (char)v10;
              uint64_t v12 = (char *)(v8 + 4);
              if (v11 < 5584)
              {
                a1 = v12;
                LOBYTE(v3) = v11 + 48;
              }
            }
          }
        }
      }

      else if (v3 == 46)
      {
        break;
      }

      if (v7 >= v5)
      {
        uint64_t v14 = -6751;
        goto LABEL_28;
      }

      *v7++ = v3;
      int v3 = *a1;
      uint64_t v8 = (unsigned __int8 *)a1;
    }

    while (*a1);
    if (v7 != v6)
    {
      _DWORD *v4 = (_BYTE)v7 - (_BYTE)v6;
      *unsigned int v7 = 0;
      int v3 = *a1;
      unsigned int v4 = v7;
      if (*a1) {
        continue;
      }
      goto LABEL_23;
    }

    break;
  }

  uint64_t v14 = -6742;
LABEL_28:
  uint64_t result = 0LL;
  uint64_t v15 = v14;
  if (a2) {
    goto LABEL_24;
  }
  return result;
}

  unint64_t v9 = mdns_interface_monitor_create(v4);
  if (v9)
  {
    int v10 = v9;
    if (_mdns_dns_service_queue_s_once != -1) {
      dispatch_once(&_mdns_dns_service_queue_s_once, &__block_literal_global_237);
    }
    mdns_interface_monitor_set_queue(v10, (dispatch_object_t)_mdns_dns_service_queue_s_queue);
    os_retain(a1);
    *(void *)buf = _NSConcreteStackBlock;
    *(void *)&uint8_t buf[8] = 0x40000000LL;
    *(void *)&uint8_t buf[16] = ___mdns_dns_service_manager_get_interface_monitor_block_invoke;
    unint64_t v19 = &__block_descriptor_tmp_55;
    uint64_t v20 = a1;
    uint64_t v21 = v10;
    mdns_interface_monitor_set_update_handler(v10, buf);
    v17[0] = _NSConcreteStackBlock;
    v17[1] = 0x40000000LL;
    v17[2] = ___mdns_dns_service_manager_get_interface_monitor_block_invoke_2;
    v17[3] = &__block_descriptor_tmp_57;
    v17[4] = v10;
    v17[5] = a1;
    mdns_interface_monitor_set_event_handler(v10, v17);
    if (!*(_BYTE *)(v10 + 154))
    {
      if (*(void *)(v10 + 32)) {
        _mdns_interface_monitor_activate_async((void *)v10);
      }
      *(_BYTE *)(v10 + 154) = 1;
    }

    CFArrayAppendValue(a1[10], (const void *)v10);
LABEL_14:
    uint64_t v11 = *(_WORD *)(a2 + 276) & 0xF80F;
    *(_WORD *)(a2 + 276) = v11;
    uint64_t v12 = *(_DWORD *)(v10 + 144);
    uint64_t v13 = v11 & 0xFF0F | (16 * (v12 & 0xF));
    if ((v12 & 0xF) != 0) {
      *(_WORD *)(a2 + 276) = v13;
    }
    if (*(_BYTE *)(a2 + 282) == 2 && *(_DWORD *)(a2 + 256) && (v12 & 0x10) != 0)
    {
      v13 |= 0x100u;
      *(_WORD *)(a2 + 276) = v13;
    }

    if ((v12 & 0x60) != 0) {
      *(_WORD *)(a2 + 276) = (16 * v12) & 0x600 | v13;
    }
    return;
  }

  if (_mdns_dns_service_log_s_once != -1) {
    dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_62);
  }
  uint64_t v14 = (os_log_s *)_mdns_dns_service_log_s_log;
  if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_ERROR))
  {
    uint64_t v15 = *(const char **)(a2 + 104);
    if (!v15) {
      uint64_t v15 = "";
    }
    int v16 = *(_DWORD *)(a2 + 256);
    *(_DWORD *)buf = 136446466;
    *(void *)&uint8_t buf[4] = v15;
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = v16;
    _os_log_error_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_ERROR,  "Failed to get interface monitor for interface %{public}s/%u",  buf,  0x12u);
  }

    uint64_t result = 0LL;
    if (!a3) {
      return result;
    }
    goto LABEL_6;
  }

  int v10 = a2[9];
  if (v10)
  {
    *int v6 = v10;
    *(void *)(v10 + 64) = a2[8];
    goto LABEL_18;
  }

  LOBYTE(v4) = 0;
  *int v6 = a2[8];
LABEL_19:
  a2[8] = 0LL;
  a2[9] = 0LL;
  os_release(a2);
  uint64_t result = 1LL;
  if (a3) {
LABEL_6:
  }
    *a3 = v4;
  return result;
}

  uint64_t v8 = 0LL;
  unint64_t v9 = 0LL;
  int v10 = 0LL;
  uint64_t v11 = 0LL;
  if ((a3 & 1) != 0) {
    goto LABEL_12;
  }
  if (a4) {
LABEL_7:
  }
    *a4 = v10;
  return v11;
}

uint64_t mDNS_GetDomains_Internal( uint64_t a1, uint64_t a2, int a3, char *a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  *(void *)(a2 + 136) = a5;
  *(_DWORD *)(a2 + 304) = 0;
  *(_DWORD *)(a2 + 322) = 65548;
  *(_BYTE *)(a2 + 621) = 0;
  *(_WORD *)(a2 + 619) = 0;
  *(_BYTE *)(a2 + 632) = 0;
  *(_DWORD *)(a2 + 612) = 0;
  *(_WORD *)(a2 + 616) = 0;
  *(_DWORD *)(a2 + 244) = getpid();
  *(_DWORD *)(a2 + 24_Block_object_dispose(va, 8) = 0;
  *(void *)(a2 + 152) = a6;
  *(void *)(a2 + 176) = a7;
  uint64_t v13 = (unsigned __int8 *)mDNS_DomainTypeNames[a3];
  *(_BYTE *)(a2 + 356) = 0;
  if (AppendDNSNameString((_BYTE *)(a2 + 356), v13, v14, v15, v16, v17, v18, v19)
    && (a4 ? (uint64_t v20 = a4) : (uint64_t v20 = "\x05local"), AppendDomainName((_BYTE *)(a2 + 356), v20)))
  {
    return mDNS_StartQuery_internal(a1, a2);
  }

  else
  {
    return 4294901756LL;
  }

void mDNS_DeregisterDomainsDiscoveredForDomainEnumeration( unsigned int *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = a2 + 8LL * a3;
  unint64_t v9 = *(uint64_t **)(v8 + 256);
  if (v9)
  {
    uint64_t v10 = *v9;
    if (*v9)
    {
      uint64_t v13 = (uint64_t **)(v8 + 256);
      do
      {
        uint64_t v14 = *(void *)(v10 + 256);
        DeregisterLocalOnlyDomainEnumPTR_Internal(a1, (_BYTE *)v10, a3, 1LL, a5, a6, a7, a8);
        free((void *)v10);
        uint64_t v10 = v14;
      }

      while (v14);
      unint64_t v9 = *v13;
    }

    *unint64_t v9 = 0LL;
  }

void mDNSCoreRestartAddressQueries( int a1, void (*a2)(uint64_t *), void (*a3)(uint64_t *, uint64_t), uint64_t a4)
{
  if (a2) {
    a2(mDNSStorage);
  }
  if (qword_100158CA8)
  {
    unsigned int v5 = (os_log_s *)mDNSLogCategory_Default;
    int v6 = qword_100158CA8 + 356;
    DNSTypeName(*(unsigned __int16 *)(qword_100158CA8 + 322));
    LogMsgWithLevel( v5,  OS_LOG_TYPE_DEFAULT,  "mDNSCoreRestartAddressQueries: ERROR!! m->RestartQuestion already set: %##s (%s)",  v7,  v8,  v9,  v10,  v11,  v6);
  }

  uint64_t v12 = qword_100158C80;
  qword_100158CA8 = qword_100158C80;
  for (i = 0LL; qword_100158CA8; uint64_t v12 = qword_100158CA8)
  {
    uint64_t v14 = *(void *)(v12 + 8);
    qword_100158CA8 = v14;
    if (*(unsigned int *(**)(unsigned int *, uint64_t, uint64_t, int))(v12 + 152) == GetZoneData_QuestionCallback)
    {
      if (mDNS_LoggingEnabled == 1)
      {
        uint64_t v31 = (os_log_s *)mDNSLogCategory_Default;
        DNSTypeName(*(unsigned __int16 *)(v12 + 322));
        LogMsgWithLevel( v31,  OS_LOG_TYPE_DEFAULT,  "mDNSCoreRestartAddressQueries: Skipping GetZoneDataQuestion %p %##s (%s)",  v32,  v33,  v34,  v35,  v36,  v12);
      }

      if (v14)
      {
        int v37 = mDNS_LoggingEnabled;
        do
        {
          if (v12 == *(void *)(v14 + 104) + 832LL && v37 != 0)
          {
            uint64_t v39 = (os_log_s *)mDNSLogCategory_Default;
            DNSTypeName(*(unsigned __int16 *)(v14 + 322));
            LogMsgWithLevel( v39,  OS_LOG_TYPE_DEFAULT,  "mDNSCoreRestartAddressQueries: Question %p %##s (%s) referring to GetZoneDataQuestion %p, not stopping",  v40,  v41,  v42,  v43,  v44,  v14);
            int v37 = mDNS_LoggingEnabled;
          }

          uint64_t v14 = *(void *)(v14 + 8);
        }

        while (v14);
      }

      goto LABEL_36;
    }

    unsigned int v15 = *(unsigned __int16 *)(v12 + 322);
    BOOL v16 = v15 > 0x1C;
    int v17 = (1 << v15) & 0x10000022;
    BOOL v18 = v16 || v17 == 0;
    if (!v18 && (!a1 || *(_BYTE *)(v12 + 621)))
    {
      if (CacheRecordRmvEventsForQuestion(v12))
      {
        if (LocalRecordRmvEventsForQuestion(v12))
        {
          if (mDNS_LoggingEnabled)
          {
            uint64_t v24 = (os_log_s *)mDNSLogCategory_Default;
            DNSTypeName(*(unsigned __int16 *)(v12 + 322));
            LogMsgWithLevel( v24,  OS_LOG_TYPE_DEFAULT,  "mDNSCoreRestartAddressQueries: Stop question %p %##s (%s), AppendSearchDomains %d",  v25,  v26,  v27,  v28,  v29,  v12);
          }

          mDNS_StopQuery_internal((uint64_t)mDNSStorage, v12);
          uint64_t v30 = *(void (**)(uint64_t))(v12 + 160);
          if (v30) {
            v30(v12);
          }
          *(void *)(v12 + _Block_object_dispose(va, 8) = i;
          goto LABEL_37;
        }

        if (mDNS_LoggingEnabled)
        {
          uint64_t v45 = (os_log_s *)mDNSLogCategory_Default;
          uint64_t v46 = "mDNSCoreRestartAddressQueries: Question deleted while delivering Local Record RMV events";
          goto LABEL_35;
        }
      }

      else if (mDNS_LoggingEnabled == 1)
      {
        uint64_t v45 = (os_log_s *)mDNSLogCategory_Default;
        uint64_t v46 = "mDNSCoreRestartAddressQueries: Question deleted while delivering Cache Record RMV events";
LABEL_35:
        LogMsgWithLevel(v45, OS_LOG_TYPE_DEFAULT, v46, v19, v20, v21, v22, v23, v54);
      }
    }

BOOL CacheRecordRmvEventsForQuestion(uint64_t a1)
{
  if (qword_100158C90)
  {
    unsigned int v2 = (os_log_s *)mDNSLogCategory_Default;
    int v3 = qword_100158C90 + 356;
    DNSTypeName(*(unsigned __int16 *)(qword_100158C90 + 322));
    LogMsgWithLevel( v2,  OS_LOG_TYPE_DEFAULT,  "CacheRecordRmvEventsForQuestion: ERROR m->CurrentQuestion already set: %##s (%s)",  v4,  v5,  v6,  v7,  v8,  v3);
  }

  for (uint64_t i = qword_100158C88; i != a1 && i != 0; uint64_t i = *(void *)(i + 8))
    ;
  if (!i && !*(_BYTE *)(a1 + 335))
  {
    qword_100158C90 = a1;
    BOOL v18 = CacheGroupForName((uint64_t)&mDNSStorage, *(_DWORD *)(a1 + 200), (_BYTE *)(a1 + 356));
    if (!v18 || (uint64_t v24 = v18[2]) == 0)
    {
LABEL_104:
      BOOL result = qword_100158C90 == a1;
      qword_100158C90 = 0LL;
      return result;
    }

    while (*(unsigned __int8 *)(v24 + 8) == 240)
    {
      uint64_t v25 = *(void *)(a1 + 144);
      if (v25)
      {
        if (*(_BYTE *)(v25 + 24)) {
          break;
        }
      }

      uint64_t v32 = (os_log_s *)mDNSLogCategory_Default;
      if (gSensitiveLoggingEnabled == 1 && mDNSLogCategory_Default != mDNSLogCategory_State)
      {
        uint64_t v32 = (os_log_s *)mDNSLogCategory_Default_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_103;
        }
        uint64_t v34 = *(void *)(v24 + 40);
        if (v34)
        {
          uint64_t v43 = *(_BYTE **)(v24 + 40);
          if (v34 == -256)
          {
LABEL_69:
            if (v43) {
              goto LABEL_70;
            }
          }

          else
          {
            while (2)
            {
              unsigned __int16 v44 = 257;
              if ((unint64_t)v43 >= v34 + 256 || !v43)
              {
LABEL_99:
                int v47 = v44;
                goto LABEL_100;
              }

LABEL_48:
          uint64_t v37 = *v35;
          if (v37 <= 0x3F)
          {
            if (!*v35)
            {
              unsigned __int16 v36 = (_WORD)v35 - v34 + 1;
              goto LABEL_94;
            }

            v35 += v37 + 1;
            if (v34 != -256) {
              continue;
            }
LABEL_47:
            if (v35) {
              goto LABEL_48;
            }
          }

          break;
        }

        unsigned __int16 v36 = 257;
        goto LABEL_94;
      }

    uint64_t v21 = DNSTypeName(*(unsigned __int16 *)(a2 + 12));
    *(_DWORD *)buf = 67110147;
    *(_DWORD *)uint64_t v37 = v8;
    *(_WORD *)&v37[4] = 2160;
    *(void *)&v37[6] = 1752392040LL;
    *(_WORD *)&v37[14] = 1040;
    *(_DWORD *)&_OWORD v37[16] = v20;
    *(_WORD *)uint64_t v38 = 2101;
    *(void *)&v38[2] = v11;
    uint64_t v39 = 2082;
    unsigned __int16 v40 = v21;
    _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "uDNS_DeregisterRecord: State %d for %{sensitive, mask.hash, mdnsresponder:domain_name}.*P type %{public}s",  buf,  0x2Cu);
LABEL_49:
    if (*(_BYTE *)(a2 + 8) == 1) {
      CompleteDeregistration(a1, a2);
    }
    return;
  }

  uint64_t v16 = *(void *)(a2 + 632);
  if (v16 && *(void *)(a2 + 320))
  {
    int v17 = *(void *)(a2 + 48);
    BOOL v18 = gSensitiveLoggingEnabled;
    uint64_t v19 = (os_log_s *)mDNSLogCategory_uDNS;
    if (mDNSLogCategory_uDNS == mDNSLogCategory_State) {
      BOOL v18 = 0;
    }
    if (v16 != v17)
    {
      if ((v18 & 1) != 0)
      {
        uint64_t v19 = (os_log_s *)mDNSLogCategory_uDNS_redacted;
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_uDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_55;
        }
      }

      else if (os_log_type_enabled((os_log_t)mDNSLogCategory_uDNS, OS_LOG_TYPE_DEFAULT))
      {
LABEL_55:
        GetRRDisplayString_rdb((unsigned __int8 *)(a2 + 8), (unsigned __int16 *)(v17 + 4), (_BYTE *)(a1 + 46976));
        *(_DWORD *)buf = 141558275;
        *(void *)uint64_t v37 = 1752392040LL;
        *(_WORD *)&v37[8] = 2085;
        *(void *)&v37[10] = a1 + 46976;
        _os_log_impl( (void *)&_mh_execute_header,  v19,  OS_LOG_TYPE_DEFAULT,  "uDNS_DeregisterRecord: Freeing InFlightRData for %{sensitive, mask.hash}s",  buf,  0x16u);
      }

      (*(void (**)(uint64_t, uint64_t, void, void))(a2 + 320))( a1,  a2,  *(void *)(a2 + 632),  *(unsigned __int16 *)(a2 + 618));
      *(void *)(a2 + 632) = 0LL;
      goto LABEL_59;
    }

    if ((v18 & 1) == 0)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_uDNS, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_59;
      }
LABEL_58:
      GetRRDisplayString_rdb((unsigned __int8 *)(a2 + 8), (unsigned __int16 *)(v16 + 4), (_BYTE *)(a1 + 46976));
      *(_DWORD *)buf = 141558275;
      *(void *)uint64_t v37 = 1752392040LL;
      *(_WORD *)&v37[8] = 2085;
      *(void *)&v37[10] = a1 + 46976;
      _os_log_impl( (void *)&_mh_execute_header,  v19,  OS_LOG_TYPE_DEFAULT,  "uDNS_DeregisterRecord: InFlightRData same as rdata for %{sensitive, mask.hash}s",  buf,  0x16u);
      goto LABEL_59;
    }

    uint64_t v19 = (os_log_s *)mDNSLogCategory_uDNS_redacted;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_uDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_58;
    }
  }

  uint64_t v32 = (os_log_s *)mDNSLogCategory_Default;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
  {
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_FAULT))
    {
LABEL_53:
      uint64_t v34 = *(void *)(v11 + 16);
      uint64_t v33 = *(void *)(v11 + 24);
      *(_DWORD *)buf = 67110402;
      int v50 = v7;
      uint64_t v51 = 2048;
      *(void *)unsigned int v52 = 0LL;
      *(_WORD *)&v52[8] = 1040;
      *(_DWORD *)&v52[10] = v33;
      int v53 = 2098;
      int v54 = v34;
      __int16 v55 = 1024;
      unsigned int v56 = v13;
      __int16 v57 = 2048;
      uint64_t v58 = v21;
      _os_log_impl( (void *)&_mh_execute_header,  v32,  OS_LOG_TYPE_FAULT,  "[Q%u] Failed to register push service -- id: %lluauthoritative zone: %{public, mdnsresponder:domain_name}.*P, in terface index: %u, error: %{mdns:err}ld",  buf,  0x32u);
    }
  }

  else
  {
    uint64_t v32 = (os_log_s *)mDNSLogCategory_Default_redacted;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_FAULT)) {
      goto LABEL_53;
    }
  }

  _mdns_resolver_start_pending_queriers(*(void *)(a1 + 64));
}

uint64_t LocalRecordRmvEventsForQuestion(uint64_t a1)
{
  if (qword_100158C90)
  {
    unsigned int v2 = (os_log_s *)mDNSLogCategory_Default;
    int v3 = qword_100158C90 + 356;
    DNSTypeName(*(unsigned __int16 *)(qword_100158C90 + 322));
    LogMsgWithLevel( v2,  OS_LOG_TYPE_DEFAULT,  "LocalRecordRmvEventsForQuestion: ERROR m->CurrentQuestion already set: %##s (%s)",  v4,  v5,  v6,  v7,  v8,  v3);
  }

  for (uint64_t i = qword_100158C88; i != a1 && i != 0; uint64_t i = *(void *)(i + 8))
    ;
  if (i)
  {
    if (mDNS_LoggingEnabled == 1)
    {
      uint64_t v11 = (os_log_s *)mDNSLogCategory_Default;
      DNSTypeName(*(unsigned __int16 *)(a1 + 322));
      LogMsgWithLevel( v11,  OS_LOG_TYPE_DEFAULT,  "LocalRecordRmvEventsForQuestion: New Question %##s (%s)",  v12,  v13,  v14,  v15,  v16,  a1 + 356);
    }
  }

  else
  {
    qword_100158C90 = a1;
    int v17 = AuthGroupForName( (uint64_t)&qword_100158C90 + &unk_1000017A8,  *(_DWORD *)(a1 + 200),  (_BYTE *)(a1 + 356));
    if (v17)
    {
      uint64_t v24 = v17[2];
      if (v24)
      {
        uint64_t v25 = &unk_100158000;
        do
        {
          if (*(_DWORD *)(v24 + 172) == 4 && (*(_BYTE *)(v24 + 8) & 0x32) != 0)
          {
            unsigned int v26 = *(unsigned __int16 *)(v24 + 12);
            BOOL v27 = v26 > 0x1C;
            int v28 = (1 << v26) & 0x10001022;
            BOOL v29 = v27 || v28 == 0;
            if (!v29 && LocalOnlyRecordAnswersQuestion(v24, a1, v18, v19, v20, v21, v22, v23))
            {
              if (v25[2840] == 1)
              {
                unsigned __int16 v30 = v25;
                uint64_t v31 = mDNSLogCategory_Default;
                GetRRDisplayString_rdb( (unsigned __int8 *)(v24 + 8),  (unsigned __int16 *)(*(void *)(v24 + 48) + 4LL),  word_100164338);
                uint64_t v32 = (os_log_s *)v31;
                uint64_t v25 = v30;
                LogMsgWithLevel( v32,  OS_LOG_TYPE_DEFAULT,  "LocalRecordRmvEventsForQuestion: Delivering possible Rmv events with record %s",  v33,  v34,  v35,  v36,  v37,  (int)word_100164338);
              }

              if (*(_DWORD *)(a1 + 228) && *(_BYTE *)(a1 + 335))
              {
                AnswerLocalQuestionWithLocalAuthRecord((uint64_t)&mDNSStorage, v24, 0LL);
                if (qword_100158C90 != a1)
                {
                  uint64_t result = 0LL;
                  qword_100158C90 = 0LL;
                  return result;
                }
              }

              else
              {
                uint64_t v38 = (os_log_s *)mDNSLogCategory_Default;
                DNSTypeName(*(unsigned __int16 *)(a1 + 322));
                LogMsgWithLevel( v38,  OS_LOG_TYPE_DEFAULT,  "LocalRecordRmvEventsForQuestion: ERROR!! CurrentAnswers or LOAddressAnswers is zero %p %##s (%s) Curre ntAnswers %d, LOAddressAnswers %d",  v39,  v40,  v41,  v42,  v43,  a1);
              }
            }
          }

          uint64_t v24 = *(void *)v24;
        }

        while (v24);
      }
    }

    qword_100158C90 = 0LL;
  }

  return 1LL;
}

void mDNSCoreRestartQueries(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 216);
  if (v2)
  {
    int v3 = (os_log_s *)mDNSLogCategory_Default;
    int v4 = v2 + 356;
    DNSTypeName(*(unsigned __int16 *)(v2 + 322));
    LogMsgWithLevel( v3,  OS_LOG_TYPE_DEFAULT,  "mDNSCoreRestartQueries: ERROR m->CurrentQuestion already set: %##s (%s)",  v5,  v6,  v7,  v8,  v9,  v4);
  }

  uint64_t v10 = *(void *)(a1 + 200);
  *(void *)(a1 + 216) = v10;
  if (v10)
  {
    do
    {
      uint64_t v11 = *(void *)(v10 + 8);
      *(void *)(a1 + 216) = v11;
      if (*(_WORD *)(v10 + 320) && *(int *)(v10 + 212) >= 1 && !*(void *)(v10 + 40))
      {
        uint64_t v12 = *(void *)(v10 + 96);
        if (v12)
        {
          mdns_client_invalidate(v12);
          os_release(*(void **)(v10 + 96));
          *(void *)(v10 + 96) = 0LL;
        }

        ActivateUnicastQuery(a1, v10, 1);
        uint64_t v11 = *(void *)(a1 + 216);
      }

      uint64_t v10 = v11;
    }

    while (v11);
    for (uint64_t i = *(void *)(a1 + 200); i; uint64_t i = *(void *)(i + 8))
    {
      if (!*(_WORD *)(i + 320) && *(int *)(i + 212) >= 1 && !*(void *)(i + 40))
      {
        *(_BYTE *)(i + 332) = 2;
        int v14 = *(_DWORD *)(a1 + 64);
        *(_DWORD *)(i + 20_Block_object_dispose(va, 8) = v14 - 334;
        *(_DWORD *)(i + 212) = 334;
        *(_DWORD *)(i + 224) = 0;
        uint64_t v15 = *(void *)(i + 56);
        if (v15)
        {
          for (uint64_t j = 0LL; j != 128; j += 16LL)
          {
            if (*(_DWORD *)(v15 + j + 8) - v14 < 0) {
              *(void *)(v15 + j) = 0LL;
            }
          }
        }

        *(_DWORD *)(a1 + 92) = v14;
      }
    }
  }

void mDNSCoreRestartRegistration(_DWORD *a1, uint64_t a2, int a3)
{
  if (!*(void *)(a2 + 32) && !*(_BYTE *)(a2 + 122) && !IsLocalDomain(*(_BYTE **)(a2 + 40))) {
    return;
  }
  int v6 = *(unsigned __int8 *)(a2 + 8);
  if (v6 != 2)
  {
    if (v6 != 16 || *(void *)(a2 + 88))
    {
      char v7 = 0;
      goto LABEL_10;
    }

    *(_BYTE *)(a2 + _Block_object_dispose(va, 8) = 2;
  }

  char v7 = 3;
LABEL_10:
  *(_BYTE *)(a2 + 190) = v7;
  if (*(_WORD *)(a2 + 12) == 10
    && ((uint64_t v8 = *(_BYTE **)(a2 + 40), *v8) ? (v9 = *v8 + 1LL) : (v9 = 0LL),
        SameDomainLabelPointer(&v8[v9], "\n_keepalive")))
  {
    *(_BYTE *)(a2 + 191) = 0;
  }

  else
  {
    if (a3 >= 0) {
      unsigned __int8 v10 = a3;
    }
    else {
      unsigned __int8 v10 = 4;
    }
  }

  *(void *)(a2 + 200) = 0LL;
  InitializeLastAPTime(a1, a2);
}

void mDNSCoreMachineSleep(uint64_t a1, int a2)
{
  int v4 = (unsigned __int8 *)(a1 + 15032);
  uint64_t v5 = (os_log_s *)mDNSLogCategory_SPS;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_SPS == mDNSLogCategory_State)
  {
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_SPS, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_14;
    }
    char v7 = "Sleeping";
    int v8 = *(unsigned __int8 *)(a1 + 141);
    int v9 = *(_DWORD *)(a1 + 64);
    if (!a2) {
      char v7 = "Waking";
    }
    goto LABEL_13;
  }

  uint64_t v5 = (os_log_s *)mDNSLogCategory_SPS_redacted;
  if (os_log_type_enabled((os_log_t)mDNSLogCategory_SPS_redacted, OS_LOG_TYPE_DEFAULT))
  {
    char v7 = "Sleeping";
    int v8 = *(unsigned __int8 *)(a1 + 141);
    int v9 = *(_DWORD *)(a1 + 64);
    if (!a2) {
      char v7 = "Waking";
    }
LABEL_13:
    *(_DWORD *)buf = 136446722;
    *(void *)&uint8_t buf[4] = v7;
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = v8;
    *(_WORD *)&_BYTE buf[18] = 1024;
    *(_DWORD *)&buf[20] = v9;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "%{public}s (old state %d) at %d", buf, 0x18u);
  }

LABEL_82:
            mDNS_PurgeCacheResourceRecord((unsigned int *)a1, v41);
            goto LABEL_83;
          }

          if ((v48 & 1) != 0)
          {
            int v49 = (os_log_s *)mDNSLogCategory_Default_redacted;
            if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEBUG)) {
              goto LABEL_86;
            }
          }

          else if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEBUG))
          {
LABEL_86:
            GetRRDisplayString_rdb( (unsigned __int8 *)(v41 + 8),  (unsigned __int16 *)(*(void *)(v41 + 48) + 4LL),  (_BYTE *)(a1 + 46976));
            *(_DWORD *)buf = 141558787;
            *(void *)&uint8_t buf[4] = 1752392040LL;
            *(_WORD *)&buf[12] = 2085;
            *(void *)&buf[14] = a1 + 46976;
            *(_WORD *)&buf[22] = 1024;
            LODWORD(v71) = v45;
            WORD2(v71) = 1024;
            *(_DWORD *)((char *)&v71 + 6) = v39;
            _os_log_impl( (void *)&_mh_execute_header,  v49,  OS_LOG_TYPE_DEBUG,  "mDNSCoreMachineSleep: %{sensitive, mask.hash}s: Adjusted the remain ttl %u by %d seconds",  buf,  0x22u);
          }
        }

uint64_t mDNS_DeregisterService_drt( unsigned int *a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = a2 + 2408;
  if (!*(_WORD *)(*(void *)(a2 + 2456) + 8LL)) {
    return mDNS_Deregister(a1, a2 + 2408);
  }
  if (!*(_BYTE *)(a2 + 1240)) {
    return 4294901755LL;
  }
  if (*(_BYTE *)(a2 + 1240) == 1)
  {
    if (mDNS_LoggingEnabled == 1) {
      LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "Service set for %##s already in the process of deregistering",  a4,  a5,  a6,  a7,  a8,  *(void *)(a2 + 2448));
    }
    uint64_t result = 0LL;
    *(_BYTE *)(a2 + 16) = 0;
  }

  else
  {
    mDNS_Lock_(a1, (uint64_t)"mDNS_DeregisterService_drt", 17706);
    unsigned int v13 = *(void **)(a2 + 24);
    mDNS_Deregister_internal((uint64_t)a1, v9, 3);
    mDNS_Deregister_internal((uint64_t)a1, a2 + 3584, 3);
    mDNS_Deregister_internal((uint64_t)a1, a2 + 56, a3);
    for (; v13; unsigned int v13 = (void *)*v13)
      mDNS_Deregister_internal((uint64_t)a1, (uint64_t)(v13 + 2), 3);
    uint64_t v14 = a2 + 1232;
    if (*(_DWORD *)(a2 + 32))
    {
      uint64_t v15 = 0LL;
      unint64_t v16 = 0LL;
      do
      {
        mDNS_Deregister_internal((uint64_t)a1, *(void *)(a2 + 40) + v15, a3);
        ++v16;
        v15 += 1176LL;
      }

      while (v16 < *(unsigned int *)(a2 + 32));
    }

    if ((*(_DWORD *)(a2 + 1404) & 0xFFFFFFFE) != 4 && IsLocalDomain(*(_BYTE **)(a2 + 1272)) && s_presense)
    {
      uint64_t v17 = *(_BYTE **)(a2 + 1272);
      uint64_t v18 = *(unsigned int *)(a2 + 1256);
      uint64_t v19 = *(void *)(a2 + 1264);
      id v20 = _unicast_assist_cache_log();
      uint64_t v21 = (os_log_s *)objc_claimAutoreleasedReturnValue(v20);
      if (os_log_type_enabled(v21, OS_LOG_TYPE_DEBUG))
      {
        if (v17)
        {
          uint64_t v24 = v17;
          if (v17 == (_BYTE *)-256LL) {
            goto LABEL_26;
          }
LABEL_23:
          int v23 = 257;
          if (v24 < v17 + 256 && v24)
          {
            while (1)
            {
              uint64_t v25 = *v24;
              if (v25 > 0x3F)
              {
LABEL_31:
                int v23 = 257;
                goto LABEL_33;
              }

              if (!*v24) {
                break;
              }
              v24 += v25 + 1;
              if (v17 != (_BYTE *)-256LL) {
                goto LABEL_23;
              }
LABEL_26:
              if (!v24) {
                goto LABEL_31;
              }
            }

            int v23 = (unsigned __int16)((_WORD)v24 - (_WORD)v17 + 1);
          }
        }

        else
        {
          int v23 = 0;
        }

void mDNSCoreBeSleepProxyServer_internal( uint64_t a1, int a2, unsigned __int8 a3, unsigned __int8 a4, unsigned __int8 a5, unsigned __int8 a6)
{
  unsigned int v12 = (unsigned __int8 *)(a1 + 15032);
  unsigned int v13 = *(_DWORD *)(a1 + 48);
  unsigned int v14 = *(_DWORD *)(a1 + 52) + 1;
  *(_DWORD *)(a1 + 52) = v14;
  mDNS_VerifyLockState("Drop Lock", 0, v13, v14, (uint64_t)"mDNSCoreBeSleepProxyServer_internal", 18314);
  if (!a2)
  {
    id v20 = *(void **)(a1 + 15048);
    if (v20)
    {
      CloseSocketSet(*(void *)(a1 + 15048));
      free(v20);
      *(void *)(a1 + 1504_Block_object_dispose(va, 8) = 0LL;
    }
  }

  if (v12[5] == 1 && *v12 != a2)
  {
    v12[5] = 2;
    mDNS_DeregisterService_drt((unsigned int *)a1, a1 + 15056, a2 != 0, v15, v16, v17, v18, v19);
  }

  *unsigned int v12 = a2;
  v12[1] = a3;
  v12[2] = a4;
  v12[3] = a5;
  v12[4] = a6;
  if (a2)
  {
    if (*(void *)(a1 + 15048) || (uint64_t v21 = mDNSPlatformUDPSocket(0), (*(void *)(a1 + 15048) = v21) != 0LL))
    {
      if (!v12[5]) {
        SleepProxyServerCallback(a1, a1 + 15056, -65792, v15, v16, v17, v18, v19);
      }
    }

    else
    {
      LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "mDNSCoreBeSleepProxyServer: Failed to allocate SPSSocket",  v15,  v16,  v17,  v18,  v19,  v22);
    }
  }

  else if (v12[5])
  {
    if (mDNS_LoggingEnabled == 1) {
      LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "mDNSCoreBeSleepProxyServer turning off from state %d; will wake clients",
    }
        v15,
        v16,
        v17,
        v18,
        v19,
        v12[5]);
    *(_DWORD *)(a1 + 10_Block_object_dispose(va, 8) = *(_DWORD *)(a1 + 64);
  }

  mDNS_VerifyLockState( "Reclaim Lock",  0,  *(_DWORD *)(a1 + 48),  *(_DWORD *)(a1 + 52),  (uint64_t)"mDNSCoreBeSleepProxyServer_internal",  18350);
  --*(_DWORD *)(a1 + 52);
}

void SleepProxyServerCallback( uint64_t a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a3 == -65792)
  {
    if (*(_BYTE *)(a1 + 141))
    {
      *(_BYTE *)(a1 + 15037) = 3;
    }

    else
    {
      uint64_t v10 = *(void *)(a1 + 15048);
      *(_BYTE *)(a1 + 15037) = v10 != 0;
      if (v10)
      {
        memset(v11, 0, sizeof(v11));
        LOBYTE(v11[0]) = mDNS_snprintf((char *)v11 + 1);
        mDNS_RegisterService( (unsigned int *)a1,  a2,  (const char *)v11,  "\f_sleep-proxy\x04_udp",  "\x05local",  0LL,  **(_WORD **)(a1 + 15048),  0LL,  (unsigned __int16 *)"",  1u,  0LL,  0,  0LL,  (uint64_t)SleepProxyServerCallback,  0LL,  0);
      }

      if (mDNS_LoggingEnabled == 1) {
        LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "Sleep Proxy Server %#s %s",  a4,  a5,  a6,  a7,  a8,  *(void *)(a2 + 2448));
      }
    }
  }

  else if (a3 == -65548)
  {
    mDNS_RenameAndReregisterService((unsigned int *)a1, a2, 0LL);
  }

uint64_t mDNS_RenameAndReregisterService(unsigned int *a1, uint64_t a2, const char *a3)
{
  if (*(_BYTE *)(a2 + 2528)) {
    int v6 = 0LL;
  }
  else {
    int v6 = (_BYTE *)(*(void *)(a2 + 2456) + 10LL);
  }
  __int128 v27 = 0u;
  __int128 v28 = 0u;
  __int128 v25 = 0u;
  __int128 v26 = 0u;
  __int128 v21 = 0u;
  __int128 v22 = 0u;
  __int128 v23 = 0u;
  __int128 v24 = 0u;
  memset(v20, 0, sizeof(v20));
  memset(v19, 0, sizeof(v19));
  uint64_t v7 = *(void *)(a2 + 24);
  DeconstructServiceName(*(char **)(a2 + 2448), &v25, (uint64_t)v20, v19);
  if (!a3)
  {
    __int128 v21 = v25;
    __int128 v22 = v26;
    __int128 v23 = v27;
    __int128 v24 = v28;
    a3 = (const char *)&v21;
    IncrementLabelSuffix((unsigned __int8 *)&v21, 1);
  }

  SameDomainNameBytes(v19, "\x05local");
  if (*(void *)(a2 + 3888)) {
    CompleteRDataUpdate((uint64_t)a1, a2 + 3584, v8, v9, v10, v11, v12, v13);
  }
  uint64_t v14 = *(void *)(a2 + 3632);
  if (v14 == a2 + 4492) {
    uint64_t v15 = 0LL;
  }
  else {
    uint64_t v15 = *(void *)(a2 + 3632);
  }
  uint64_t result = mDNS_RegisterService( a1,  a2,  a3,  (unsigned __int8 *)v20,  v19,  v6,  *(_WORD *)(*(void *)(a2 + 2456) + 8LL),  v15,  (unsigned __int16 *)(v14 + 4),  *(_WORD *)(a2 + 3604),  *(void *)(a2 + 40),  *(_DWORD *)(a2 + 32),  *(void *)(a2 + 1264),  *(void *)a2,  *(void *)(a2 + 8),  *(_DWORD *)(a2 + 48));
  if (!(_DWORD)result && v7)
  {
    do
    {
      uint64_t v17 = *(void *)v7;
      uint64_t result = mDNS_AddRecordToService((uint64_t)a1, a2, v7, *(void *)(v7 + 64), *(_DWORD *)(v7 + 32), 0);
      if ((_DWORD)result) {
        BOOL v18 = 1;
      }
      else {
        BOOL v18 = v17 == 0;
      }
      uint64_t v7 = v17;
    }

    while (!v18);
  }

  return result;
}

uint64_t NSSCallback(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(uint64_t (***)(void))(a2 + 112);
  if (*v2) {
    return (*v2)();
  }
  return result;
}

uint64_t mDNS_AddRecordToService(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int a5, int a6)
{
  uint64_t v9 = *(void *)(a2 + 1264);
  BOOL v10 = (a6 & 0x100000) == 0;
  BOOL v11 = (a6 & 0x20000) != 0 && v9 == 0;
  int v12 = !v11;
  if (!v11) {
    BOOL v10 = 1;
  }
  if (v10) {
    int v13 = 1;
  }
  else {
    int v13 = 3;
  }
  if (v9) {
    BOOL v14 = 1;
  }
  else {
    BOOL v14 = (a6 & 0x100000) == 0;
  }
  if (v14) {
    int v15 = 0;
  }
  else {
    int v15 = 2;
  }
  if (v12 == 1) {
    int v13 = v15;
  }
  if (v9 == -5 || v9 == -3) {
    int v17 = 5;
  }
  else {
    int v17 = v13;
  }
  if (v9 == -2) {
    int v18 = 4;
  }
  else {
    int v18 = v17;
  }
  *(void *)a3 = 0LL;
  mDNS_SetupResourceRecord(a3 + 16, a4, v9, *(_WORD *)(a3 + 28), a5, 2, v18, (uint64_t)ServiceCallback, a2);
  uint64_t v19 = a2 + 2416;
  id v20 = *(_BYTE **)(a2 + 2448);
  __int128 v21 = v20;
  if (v20 == (_BYTE *)-256LL)
  {
LABEL_31:
    while (v21)
    {
      uint64_t v22 = *v21;
      if (!*v21)
      {
        unsigned __int16 v23 = (_WORD)v21 - (_WORD)v20 + 1;
        if (v23 > 0x100u) {
          break;
        }
        memcpy((void *)(a3 + 668), v20, v23);
        goto LABEL_39;
      }

      v21 += v22 + 1;
      if (v20 != (_BYTE *)-256LL) {
        goto LABEL_30;
      }
    }
  }

  else
  {
LABEL_30:
    if (v21 < v20 + 256) {
      goto LABEL_31;
    }
  }

  *(_BYTE *)(a3 + 66_Block_object_dispose(va, 8) = 0;
LABEL_39:
  mDNS_Lock_((unsigned int *)a1, (uint64_t)"mDNS_AddRecordToService", 17553);
  int v24 = *(unsigned __int16 *)(a3 + 28);
  if (v24 == 33)
  {
    if ((*(_BYTE *)v19 & 0x32) != 0) {
      goto LABEL_50;
    }
  }

  else if (v24 == 16 && (*(_BYTE *)(a2 + 3592) & 0x32) != 0)
  {
    uint64_t v19 = a2 + 3592;
    goto LABEL_50;
  }

  __int128 v25 = *(uint64_t ***)(a2 + 24);
  if (!v25) {
    goto LABEL_52;
  }
  while (*((unsigned __int16 *)v25 + 14) != v24 || ((_BYTE)v25[3] & 0x32) == 0)
  {
    __int128 v25 = (uint64_t **)*v25;
    if (!v25) {
      goto LABEL_52;
    }
  }

  uint64_t v19 = (uint64_t)(v25 + 3);
LABEL_50:
  int v26 = *(_DWORD *)(a3 + 32);
  if (v26 != *(_DWORD *)(v19 + 8))
  {
    __int128 v27 = (os_log_s *)mDNSLogCategory_Default;
    GetRRDisplayString_rdb( (unsigned __int8 *)(a3 + 24),  (unsigned __int16 *)(*(void *)(a3 + 64) + 4LL),  (_BYTE *)(a1 + 46976));
    LogMsgWithLevel( v27,  OS_LOG_TYPE_DEFAULT,  "mDNS_AddRecordToService: Correcting TTL from %4d to %4d for %s",  v28,  v29,  v30,  v31,  v32,  v26);
    *(_DWORD *)(a3 + 32) = *(_DWORD *)(v19 + 8);
  }

void mDNS_DeactivateNetWake_internal(__int128 *a1)
{
  uint64_t v2 = &xmmword_10015BD30;
  do
  {
    uint64_t v2 = *(__int128 **)v2;
    if (v2) {
      BOOL v3 = v2 == a1;
    }
    else {
      BOOL v3 = 1;
    }
  }

  while (!v3);
  if (!v2)
  {
    int v6 = (os_log_s *)mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
        return;
      }
      int v13 = 134217984;
      BOOL v14 = a1;
    }

    else
    {
      int v6 = (os_log_s *)mDNSLogCategory_Default_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
        return;
      }
      int v13 = 134217984;
      BOOL v14 = a1;
    }

    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "mDNS_DeactivateNetWake_internal: NetworkInterfaceInfo %p not found in active list",  (uint8_t *)&v13,  0xCu);
    return;
  }

  if ((*((_DWORD *)a1 + 59) & 0x80000000) != 0) {
    return;
  }
  int v4 = (os_log_s *)mDNSLogCategory_SPS;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_SPS == mDNSLogCategory_State)
  {
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_SPS, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_25;
    }
    goto LABEL_24;
  }

  int v4 = (os_log_s *)mDNSLogCategory_SPS_redacted;
  if (os_log_type_enabled((os_log_t)mDNSLogCategory_SPS_redacted, OS_LOG_TYPE_DEFAULT))
  {
LABEL_24:
    int v13 = 136446979;
    BOOL v14 = (__int128 *)((char *)a1 + 6310);
    __int16 v15 = 2160;
    uint64_t v16 = 1752392040LL;
    __int16 v17 = 1045;
    int v18 = 20;
    __int16 v19 = 2101;
    id v20 = (_DWORD *)a1 + 1566;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "DeactivateNetWake for %{public}s (%{sensitive, mask.hash, mdnsresponder:ip_addr}.20P)",  (uint8_t *)&v13,  0x26u);
  }

uint64_t CheckTSRForResourceRecord(int *a1, uint64_t a2)
{
  uint64_t v2 = 0LL;
  if (!a1 || !a2) {
    return v2;
  }
  uint64_t v4 = *(void *)(a2 + 40);
  if (*(_DWORD *)(v4 + 12) != a1[1]) {
    return 0LL;
  }
  int v5 = 604800;
  int v6 = *(_DWORD *)(v4 + 8);
  int v7 = *a1;
  if (*a1 <= 0x93A80)
  {
    int v5 = *a1;
    goto LABEL_17;
  }

  uint64_t v8 = (os_log_s *)mDNSLogCategory_mDNS;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
  {
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_17;
    }
    LODWORD(v18.tv_sec) = 67109120;
    HIDWORD(v18.tv_sec) = v7;
    goto LABEL_16;
  }

  uint64_t v8 = (os_log_s *)mDNSLogCategory_mDNS_redacted;
  if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(v18.tv_sec) = 67109120;
    HIDWORD(v18.tv_sec) = v7;
LABEL_16:
    _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "CheckTSR - Out of range pktTimeSinceReceived %d in Pkt record",  (uint8_t *)&v18,  8u);
  }

uint64_t CreateNewCacheEntryEx( uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char v8 = a7;
  int v9 = a5;
  uint64_t v10 = (uint64_t *)a3;
  uint64_t v13 = a1 + 37868;
  int v14 = *(unsigned __int16 *)(a1 + 37868);
  switch(v14)
  {
    case 6:
      unsigned int v15 = 532;
      break;
    case 26:
      unsigned int v15 = 514;
      break;
    case 17:
      unsigned int v15 = 512;
      break;
    default:
      unsigned int v15 = *(unsigned __int16 *)(a1 + 37876);
      break;
  }

  char v16 = a7;
  if ((a7 & 0xC) != 0)
  {
    int v17 = (a7 & 8) >> 2;
    if ((a7 & 4) != 0) {
      int v17 = 1;
    }
    if ((a7 & 2) != 0) {
      return 0LL;
    }
    BOOL v131 = (a7 & 4) == 0;
    int v132 = a7 & 0xC;
    int v129 = v17;
    int v133 = a4;
    uint64_t v134 = a6;
    int v18 = ((a7 & 8) == 0) | ((a7 & 4) >> 2);
  }

  else
  {
    int v132 = 0;
    int v133 = a4;
    uint64_t v134 = a6;
    int v129 = 0;
    int v18 = 1;
    BOOL v131 = 1;
  }

  int v130 = v18;
  if (!a3)
  {
    uint64_t v41 = *(_BYTE **)(a1 + 37896);
    unsigned int v42 = v41;
    if (v41 == (_BYTE *)-256LL) {
      goto LABEL_29;
    }
LABEL_26:
    unsigned __int16 v43 = 257;
    if (v42 < v41 + 256 && v42)
    {
      while (1)
      {
        uint64_t v44 = *v42;
        if (v44 > 0x3F)
        {
LABEL_35:
          unsigned __int16 v43 = 257;
          goto LABEL_37;
        }

        if (!*v42) {
          break;
        }
        v42 += v44 + 1;
        if (v41 != (_BYTE *)-256LL) {
          goto LABEL_26;
        }
LABEL_29:
        if (!v42) {
          goto LABEL_35;
        }
      }

      unsigned __int16 v43 = (_WORD)v42 - (_WORD)v41 + 1;
    }

void *AddCacheRecordToCacheGroup(uint64_t a1, void *a2)
{
  uint64_t v2 = a2[8];
  if (!v2 || *(_DWORD *)(v2 + 32))
  {
    uint64_t v4 = *(void **)(a1 + 24);
    uint64_t result = (void *)(a1 + 24);
    void *v4 = a2;
LABEL_4:
    void *result = a2;
    return result;
  }

  int v5 = (void *)(a1 + 16);
  int v6 = *(void **)(a1 + 16);
  if (v6)
  {
    while (1)
    {
      int v7 = v5;
      int v5 = v6;
      if (*((_WORD *)v6 + 6) == 5)
      {
        uint64_t v8 = v6[8];
        if (v8)
        {
          if (!*(_DWORD *)(v8 + 32)) {
            break;
          }
        }
      }

      int v6 = (void *)*v5;
      if (!*v5) {
        goto LABEL_13;
      }
    }

    int v6 = v5;
    int v5 = v7;
  }

uint64_t RefreshCacheRecord(uint64_t a1, int8x8_t *a2, __int32 a3)
{
  int8x8_t v6 = a2[12];
  if (!*(void *)&v6 || *(_WORD *)(*(void *)&v6 + 320LL)) {
    goto LABEL_66;
  }
  __int32 v7 = a2[16].i32[1];
  if (v7 == 6)
  {
    int8x8_t v9 = vorr_s8(a2[17], (int8x8_t)*(_OWORD *)&vextq_s8(*(int8x16_t *)a2[17].i8, *(int8x16_t *)a2[17].i8, 8uLL));
    __int32 v8 = v9.i32[0] | v9.i32[1];
  }

  else
  {
    if (v7 != 4)
    {
      BOOL v10 = 0;
      goto LABEL_9;
    }

    __int32 v8 = a2[17].i32[0];
  }

  BOOL v10 = v8 != 0;
LABEL_9:
  BOOL IsDNSMulticast = mDNSAddrIsDNSMulticast((_DWORD *)&a2[16] + 1);
  BOOL v12 = IsDNSMulticast;
  if (a2[13].i32[0] && v10)
  {
    int v13 = a2[16].u8[2];
    int v14 = a2[13].u8[4] | IsDNSMulticast;
    BOOL v15 = v14 == 0;
    if (v14) {
      char v16 = &sUnicastAssist_MulticastCount;
    }
    else {
      char v16 = &sUnicastAssist_UnicastCount;
    }
    int v17 = &sNonUnicastAssist_MulticastCount;
    int v18 = v15;
    if (v15) {
      int v17 = &sNonUnicastAssist_UnicastCount;
    }
    if (!a2[16].i8[2]) {
      char v16 = v17;
    }
    ++*v16;
    uint64_t v19 = (os_log_s *)mDNSLogCategory_Analytics;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Analytics == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Analytics, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v25 = "*";
        if (v18) {
          uint64_t v21 = "*";
        }
        else {
          uint64_t v21 = "";
        }
        int v38 = 136316930;
        if (v18) {
          uint64_t v25 = "";
        }
        if (v13) {
          int v26 = v21;
        }
        else {
          int v26 = "";
        }
        int v39 = v26;
        __int16 v40 = 2048;
        if (v13) {
          uint64_t v23 = v25;
        }
        else {
          uint64_t v23 = "";
        }
        if (v13) {
          uint64_t v21 = "";
        }
        uint64_t v41 = sUnicastAssist_UnicastCount;
        if (v13) {
          uint64_t v24 = "";
        }
        else {
          uint64_t v24 = v25;
        }
        goto LABEL_57;
      }
    }

    else
    {
      uint64_t v19 = (os_log_s *)mDNSLogCategory_Analytics_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Analytics_redacted, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v20 = "*";
        if (v18) {
          uint64_t v21 = "*";
        }
        else {
          uint64_t v21 = "";
        }
        int v38 = 136316930;
        if (v18) {
          uint64_t v20 = "";
        }
        if (v13) {
          uint64_t v22 = v21;
        }
        else {
          uint64_t v22 = "";
        }
        int v39 = v22;
        __int16 v40 = 2048;
        if (v13) {
          uint64_t v23 = v20;
        }
        else {
          uint64_t v23 = "";
        }
        if (v13) {
          uint64_t v21 = "";
        }
        uint64_t v41 = sUnicastAssist_UnicastCount;
        if (v13) {
          uint64_t v24 = "";
        }
        else {
          uint64_t v24 = v20;
        }
LABEL_57:
        __int16 v42 = 2080;
        unsigned __int16 v43 = v23;
        __int16 v44 = 2048;
        uint64_t v45 = sUnicastAssist_MulticastCount;
        __int16 v46 = 2080;
        int v47 = v21;
        __int16 v48 = 2048;
        uint64_t v49 = sNonUnicastAssist_UnicastCount;
        __int16 v50 = 2080;
        uint64_t v51 = v24;
        __int16 v52 = 2048;
        uint64_t v53 = sNonUnicastAssist_MulticastCount;
        _os_log_impl( (void *)&_mh_execute_header,  v19,  OS_LOG_TYPE_DEBUG,  "dnssd_analytics_update_unicast_assist Assist(unicast %s%lld, multicast %s%lld) NonAssist(unicast %s%lld, multicast %s%lld)",  (uint8_t *)&v38,  0x52u);
      }
    }
  }

  if (!v12 && v10)
  {
    uint64_t v28 = (uint64_t)a2[4];
    if (mDNS_AddressIsLocalSubnet(a1, v28, (_DWORD *)&a2[16] + 1))
    {
      __int128 v29 = (_BYTE *)a2[5];
      int v30 = a2[3].i32[0];
      int v31 = a2[1].u16[2];
      int v32 = a2[1].u8[0];
    }
  }

  a2[16].i8[2] = 0;
LABEL_66:
  a2[10].i32[0] = *(_DWORD *)(a1 + 64);
  a2[2].i32[0] = a3;
  a2[13].i8[4] = 0;
  if (a2[1].i8[2]) {
    a2[1].i8[2] = 1;
  }
  uint64_t v33 = *(void *)(a1 + 37912);
  if (v33)
  {
    uint64_t v34 = *(void *)(v33 + 24);
    if (v34)
    {
      int8x8_t v35 = a2[7];
      if (v35)
      {
        if (*(_BYTE *)(v34 + 281) == 5 && v34 == *(void *)(*(void *)&v35 + 24LL))
        {
          *(void *)(*(void *)&v35 + 40LL) = *(void *)(v33 + 40);
          a2[13].i8[5] = 1;
        }
      }
    }
  }

  return SetNextCacheCheckTimeForRecord(a1, (uint64_t)a2);
}

void mDNSCoreReceiveForQuerier(unint64_t a1, uint64_t a2, void *a3, uint64_t a4)
{
  __int32 v8 = (char *)mDNSStorage + &loc_100004DF0;
  *((_WORD *)v8 + 2) = bswap32(*(unsigned __int16 *)((char *)mDNSStorage + &loc_100004DF0 + 4)) >> 16;
  *((_WORD *)v8 + 3) = bswap32(*(unsigned __int16 *)((char *)mDNSStorage + &loc_100004DF0 + 6)) >> 16;
  *((_WORD *)v8 + 4) = bswap32(*(unsigned __int16 *)((char *)&dword_100158BC0 + &loc_100004DF0)) >> 16;
  *((_WORD *)v8 + 5) = bswap32(*(unsigned __int16 *)((char *)&dword_100158BC0 + &loc_100004DF0 + 2)) >> 16;
  mDNS_Lock_((unsigned int *)mDNSStorage, (uint64_t)"mDNSCoreReceiveForQuerier", 13730);
  mDNSCoreReceiveResponse((uint64_t)mDNSStorage, (unsigned __int8 *)v8, a1, 0LL, 0, 0LL, 0, a2, a3, a4);
  mDNS_Unlock_((uint64_t)mDNSStorage, (uint64_t)"mDNSCoreReceiveForQuerier", 13732);
}

void mDNSCoreReceiveResponse( uint64_t a1, unsigned __int8 *a2, unint64_t a3, __int128 *a4, unsigned int a5, __int128 *a6, unsigned __int16 a7, uint64_t a8, void *a9, uint64_t a10)
{
  char v16 = (void *)a10;
  if (!a6)
  {
    BOOL IsDNSMulticast = 0;
    if (a4) {
      goto LABEL_3;
    }
LABEL_5:
    BOOL v17 = 1;
    goto LABEL_6;
  }

  BOOL IsDNSMulticast = mDNSAddrIsDNSMulticast(a6);
  if (!a4) {
    goto LABEL_5;
  }
LABEL_3:
  BOOL v17 = mDNS_AddressIsLocalSubnet(a1, a10, a4) != 0;
LABEL_6:
  BOOL v864 = v17;
  uint64_t v911 = 1LL;
  if (a10 && (int v18 = *(uint64_t **)(a1 + 12664)) != 0LL)
  {
    while (v18[782] != a10
         || *((_DWORD *)v18 + 1566) != 4
         || *((unsigned __int8 *)v18 + 6268) != 169
         || *((unsigned __int8 *)v18 + 6269) != 254)
    {
      int v18 = (uint64_t *)*v18;
      if (!v18) {
        goto LABEL_13;
      }
    }

    v850 = v18;
  }

  else
  {
LABEL_13:
    v850 = 0LL;
  }

  unsigned int v892 = *((unsigned __int16 *)a2 + 3);
  int v19 = *((unsigned __int16 *)a2 + 4);
  int v20 = *((unsigned __int16 *)a2 + 5);
  uint64_t v907 = a8;
  if (!a8)
  {
    uint64_t v22 = 0LL;
LABEL_21:
    a8 = 0LL;
    goto LABEL_22;
  }

  uint64_t v21 = *(_UNKNOWN ***)(a8 + 16);
  if (v21 == &_mdns_querier_kind) {
    uint64_t v22 = a8;
  }
  else {
    uint64_t v22 = 0LL;
  }
  if (v21 != &_mdns_subscriber_kind) {
    goto LABEL_21;
  }
LABEL_22:
  int v896 = IsResponseMDNSEquivalent(v907, (uint64_t)a9);
  v910 = 0LL;
  if (a10 || v907 || (a2[2] & 2) == 0 || v892 && v19 | v20)
  {
    v848 = a4;
    __int128 __src = a6;
    unsigned int v890 = v19 + v892;
    uint64_t v23 = (unsigned __int8 *)(a1 + 37864);
    OptRR = LocateOptRR((unint64_t)a2, a3, 14);
    uint64_t v878 = a1;
    unint64_t v870 = a3;
    uint64_t v906 = v22;
    v858 = (unsigned __int8 *)(a1 + 37864);
    uint64_t v901 = a8;
    if (!OptRR)
    {
      __int128 v29 = 0LL;
      LODWORD(v25) = IsDNSMulticast;
      goto LABEL_72;
    }

    LODWORD(v25) = IsDNSMulticast;
    if (!GetLargeResourceRecord(a1, (unint64_t)a2, OptRR, a3, a10, 128, a1 + 37856)
      || *v23 == 240
      || *(_WORD *)(a1 + 37868) != 41)
    {
      __int128 v29 = 0LL;
      goto LABEL_64;
    }

    uint64_t v26 = *(void *)(a1 + 37904);
    unint64_t v27 = v26 + 4 + *(unsigned __int16 *)(a1 + 37876);
    if (v26 + 4 >= v27)
    {
      __int128 v29 = 0LL;
      v910 = 0LL;
      a3 = v870;
      goto LABEL_64;
    }

    unsigned __int8 v28 = 0;
    __int128 v29 = 0LL;
    int v30 = (unsigned __int16 *)(v26 + 16);
    while (1)
    {
      if ((__int16)*(v30 - 6) == -534)
      {
        ++v28;
        unsigned int v31 = *v30;
        int v32 = DomainNamePtrAtTSRIndex((unsigned __int16 *)a2, v870, v31);
        if (v32)
        {
          uint64_t v33 = UnsafeBufferPointer((unint64_t)a2, v32, v870, (uint64_t)(v30 - 6));
          if (!v33)
          {
            uint64_t v41 = mDNSLogCategory_mDNS;
            BOOL v42 = gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State;
            char v16 = (void *)a10;
            uint64_t v23 = v858;
            if (v42)
            {
              if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_ERROR))
              {
LABEL_51:
                uint64_t v45 = *((void *)v858 + 3);
                int v46 = *((_DWORD *)v30 - 2);
                int v47 = *((_DWORD *)v30 - 1);
                int v48 = *v30;
                *(_DWORD *)v961 = 67110144;
                *(_DWORD *)&v961[4] = v28;
                *(_WORD *)&v961[8] = 2048;
                *(void *)&v961[10] = v45;
                *(_WORD *)&v961[18] = 1024;
                *(_DWORD *)&v961[20] = v46;
                *(_WORD *)&v961[24] = 1024;
                *(_DWORD *)&v961[26] = v47;
                *(_WORD *)&v961[30] = 1024;
                *(_DWORD *)&v961[32] = v48;
                int v39 = (os_log_s *)v41;
                __int16 v40 = "mDNSCoreReceiveResponse: Create TSR(%u) failed - if %p tsrTime %d tsrHost %x recIndex %d";
LABEL_52:
                _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_ERROR, v40, v961, 0x24u);
              }
            }

            else
            {
              uint64_t v41 = mDNSLogCategory_mDNS_redacted;
              if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_ERROR)) {
                goto LABEL_51;
              }
            }

            a1 = v878;
            goto LABEL_54;
          }

          *(void *)uint64_t v33 = v29;
          __int128 v29 = v33;
          a1 = v878;
          char v16 = (void *)a10;
        }

        else
        {
          uint64_t v34 = mDNSLogCategory_mDNS;
          BOOL v35 = gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State;
          if (v35)
          {
            char v16 = (void *)a10;
            if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_ERROR)) {
              goto LABEL_39;
            }
          }

          else
          {
            uint64_t v34 = mDNSLogCategory_mDNS_redacted;
            BOOL v43 = os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_ERROR);
            char v16 = (void *)a10;
            if (v43)
            {
LABEL_39:
              uint64_t v36 = *((void *)v858 + 3);
              int v37 = *((_DWORD *)v30 - 2);
              int v38 = *((_DWORD *)v30 - 1);
              *(_DWORD *)v961 = 67110144;
              *(_DWORD *)&v961[4] = v28;
              *(_WORD *)&v961[8] = 2048;
              *(void *)&v961[10] = v36;
              *(_WORD *)&v961[18] = 1024;
              *(_DWORD *)&v961[20] = v37;
              *(_WORD *)&v961[24] = 1024;
              *(_DWORD *)&v961[26] = v38;
              *(_WORD *)&v961[30] = 1024;
              *(_DWORD *)&v961[32] = v31;
              int v39 = (os_log_s *)v34;
              uint64_t v23 = v858;
              __int16 v40 = "mDNSCoreReceiveResponse: No Domain Name for TSR(%u) if %p tsrTime %d tsrHost %x recIndex %d";
              goto LABEL_52;
            }
          }

          a1 = v878;
        }
      }

      uint64_t v23 = v858;
LABEL_54:
      uint64_t v49 = v30 + 6;
      v30 += 12;
      if ((unint64_t)v49 >= v27)
      {
        v910 = v29;
        a3 = v870;
        LODWORD(v25) = IsDNSMulticast;
        if (v29)
        {
          __int16 v50 = (os_log_s *)mDNSLogCategory_mDNS;
          if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
          {
            if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEBUG)) {
              goto LABEL_1997;
            }
          }

          else
          {
            __int16 v50 = (os_log_s *)mDNSLogCategory_mDNS_redacted;
            if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEBUG))
            {
LABEL_1997:
              uint64_t v819 = *((void *)v23 + 3);
              GetRRDisplayString_rdb(v23, (unsigned __int16 *)(*((void *)v23 + 5) + 4LL), (_BYTE *)(v878 + 46976));
              *(_DWORD *)v961 = 67109634;
              *(_DWORD *)&v961[4] = v28;
              char v16 = (void *)a10;
              *(_WORD *)&v961[8] = 2048;
              *(void *)&v961[10] = v819;
              a1 = v878;
              *(_WORD *)&v961[18] = 2082;
              *(void *)&v961[20] = v878 + 46976;
              LODWORD(v25) = IsDNSMulticast;
              _os_log_impl( (void *)&_mh_execute_header,  v50,  OS_LOG_TYPE_DEBUG,  "mDNSCoreReceiveResponse: Received TSR(%u) if %p %{public}s",  v961,  0x1Cu);
            }
          }
        }

        uint64_t v22 = v906;
        a8 = v901;
LABEL_64:
        *(_WORD *)uint64_t v23 = 0;
        *((_WORD *)v23 + 51) = 0;
        __int16 v52 = (void *)*((void *)v23 + 7);
        if (v52)
        {
          ref_count_obj_release(v52);
          *((void *)v23 + 7) = 0LL;
        }

LABEL_72:
        int v53 = v890 + v20;
        v900 = a2;
        if ((_DWORD)v25)
        {
          Answers = LocateAnswers((unint64_t)a2, a3);
          goto LABEL_74;
        }

        unsigned int v55 = ((a2[3] & 0xFu) < 0xA) & (0x209u >> (a2[3] & 0xF));
        if (v22) {
          unsigned int v56 = ((a2[3] & 0xFu) < 0xA) & (0x209u >> (a2[3] & 0xF));
        }
        else {
          unsigned int v56 = 1;
        }
        if (!v56) {
          int v53 = 0;
        }
        Answers = a2 + 12;
        if (*((_WORD *)a2 + 2) && (unint64_t)(a2 + 12) < a3)
        {
          int v882 = v53;
          unsigned int v57 = 0;
          int v871 = 0;
          if (v22) {
            unsigned int v55 = 1;
          }
          unsigned int v888 = v55;
          v879 = (_BYTE *)(a1 + 46976);
          uint64_t v58 = a2 + 12;
          while (2)
          {
            bzero(v961, 0x290uLL);
            Answers = getQuestion((unint64_t)a2, v58, a3, (uint64_t)v16, v961);
            if (!Answers || a8) {
              goto LABEL_135;
            }
            if (v907)
            {
              uint64_t v59 = 0LL;
              goto LABEL_93;
            }

            uint64_t v59 = ExpectingUnicastResponseForQuestion( *(void *)(a1 + 200),  a7,  *(_WORD *)a2,  (uint64_t)v961,  __src == 0LL);
            if (v59)
            {
LABEL_93:
              if (v888)
              {
                int v60 = CacheGroupForName(a1, *(unsigned int *)((char *)&v966 + 7), v970);
                if (v60)
                {
                  uint64_t v66 = v60[2];
                  if (v66)
                  {
                    while (1)
                    {
                      if (v907)
                      {
                        uint64_t v67 = *(void **)(v66 + 56);
                        if (v67) {
                          uint64_t v67 = (void *)v67[3];
                        }
                        if (v67 != a9 || !Client_SameNameCacheRecordIsAnswer(v66, v907)) {
                          goto LABEL_131;
                        }
                      }

                      else if (!SameNameRecordAnswersQuestion( (unsigned __int8 *)(v66 + 8),  0,  v59,  v61,  v62,  v63,  v64,  v65))
                      {
                        goto LABEL_131;
                      }

                      if (!*(_BYTE *)(v66 + 109)) {
                        break;
                      }
LABEL_131:
                      uint64_t v66 = *(void *)v66;
                      if (!v66) {
                        goto LABEL_132;
                      }
                    }

                    uint64_t v68 = (os_log_s *)mDNSLogCategory_Default;
                    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
                    {
                      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEBUG))
                      {
                        uint64_t v874 = *(void *)((char *)&v962 + 7);
                        for (uint64_t i = v970; ; i += v72 + 1)
                        {
                          unsigned __int16 v71 = 257;
                          if (i >= v972 || !i) {
                            break;
                          }
                          uint64_t v72 = *i;
                          if (v72 > 0x3F)
                          {
                            unsigned __int16 v71 = 257;
                            break;
                          }

                          if (!*i)
                          {
                            unsigned __int16 v71 = (_WORD)i - (unsigned __int16)v970 + 1;
                            break;
                          }
                        }

          CFRelease(v49);
          goto LABEL_73;
        }

        uint64_t v130 = 0;
        unsigned int v129 = 0;
        RemoteMacinternal = GetRemoteMacinternal(v48, &v166, (uint64_t)&v129);
        if (RemoteMacinternal)
        {
          uint64_t v62 = RemoteMacinternal;
          LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "StoreSPSMACAddressinternal: Failed to determine the MAC address",  v57,  v58,  v59,  v60,  v61,  v113);
          uint64_t v63 = 0LL;
          uint64_t v64 = 0LL;
          uint64_t v65 = 0LL;
          uint64_t v66 = 0LL;
          uint64_t v67 = 0LL;
          goto LABEL_72;
        }

        uint64_t v116 = "State:/Network/Interface/";
        uint64_t v67 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"%s%s%s");
        uint64_t v66 = CFDictionaryCreateMutable(0LL, 0LL, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
        if (v66)
        {
          uint64_t v78 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"%02x:%02x:%02x:%02x:%02x:%02x",  v129,  BYTE1(v129),  BYTE2(v129),  HIBYTE(v129),  v130,  HIBYTE(v130));
          CFDictionarySetValue(v66, @"MACAddress", v78);
          if (v78) {
            CFRelease(v78);
          }
          if (inet_ntop(v48, &v166, v134, 0x2Eu))
          {
            uint64_t v79 = CFStringCreateWithCString(0LL, v134, 0x8000100u);
            CFDictionarySetValue(v66, @"IPAddress", v79);
            if (v79) {
              CFRelease(v79);
            }
            uint64_t v65 = CFStringCreateWithFormat(0LL, 0LL, @"State:/Network/Interface/%s/IPv6", v124);
            if (v65)
            {
              BOOL v80 = (const __CFDictionary *)SCDynamicStoreCopyValue(storea, v65);
              uint64_t v64 = v80;
              if (v80)
              {
                Value = CFDictionaryGetValue(v80, @"Addresses");
                if (Value)
                {
                  uint64_t v63 = CFRetain(Value);
                  CFDictionarySetValue(v66, @"RegisteredAddresses", v63);
LABEL_71:
                  SCDynamicStoreSetValue(v49, v67, v66);
                  uint64_t v62 = 0;
                  goto LABEL_72;
                }
              }
            }

            else
            {
              uint64_t v64 = 0LL;
            }

            uint64_t v63 = 0LL;
            goto LABEL_71;
          }

          int v84 = mDNSLogCategory_Default;
          uint64_t v85 = __error();
          LODWORD(v116) = strerror(*v85);
          unsigned int v83 = "StoreSPSMACAddressinternal: inet_ntop failed: %s";
          int v82 = (os_log_s *)v84;
        }

        else
        {
          int v82 = (os_log_s *)mDNSLogCategory_Default;
          unsigned int v83 = "StoreSPSMACAddressinternal: SPSCreateDict() Could not create CFDictionary dict";
        }

        LogMsgWithLevel(v82, OS_LOG_TYPE_DEFAULT, v83, v73, v74, v75, v76, v77, (int)v116);
        uint64_t v63 = 0LL;
        uint64_t v64 = 0LL;
        uint64_t v65 = 0LL;
        uint64_t v62 = -1;
        goto LABEL_72;
      }
    }
  }

                      *unsigned __int8 v28 = 0;
                      if (v28 == (_BYTE *)-1LL) {
                        goto LABEL_157;
                      }
                      __s = v26;
                      bzero(&block, 0x3F1uLL);
                      is_xpc_object_t empty = dnssd_svcb_service_name_is_empty((uint64_t)v90, v89);
                      int v37 = __s;
                      p_blocuint64_t k = __s;
                      if (is_empty)
                      {
                        if (!v81) {
                          goto LABEL_156;
                        }
                        p_blocuint64_t k = (const char *)&block;
                        int v39 = DomainNameToString(v81, 0LL, (unsigned __int8 *)&block, 0LL);
                        int v37 = __s;
                        if (v39) {
                          goto LABEL_156;
                        }
                      }

                      __int16 v40 = strlen(p_block);
                      if (v40 && p_block[v40 - 1] == 46) {
                        p_block[v40 - 1] = 0;
                      }
                      parameters = (nw_parameters_t)p_block;
                      *(void *)out = 0LL;
                      *(void *)&out[8] = out;
                      uint64_t v137 = 0x2000000000LL;
                      LOWORD(v13_Block_object_dispose(va, 8) = 0;
                      *(void *)buf = _NSConcreteStackBlock;
                      *(void *)&uint8_t buf[8] = 0x40000000LL;
                      *(void *)&uint8_t buf[16] = __dnssd_svcb_get_port_block_invoke;
                      *(void *)&uint64_t v122 = &unk_10013E2E0;
                      *((void *)&v122 + 1) = out;
                      _dnssd_svcb_extract_values(v90, v89, 3, (uint64_t)buf);
                      __int128 v73 = *(unsigned __int16 *)(*(void *)&out[8] + 24LL);
                      _Block_object_dispose(out, 8);
                      *(void *)out = 0LL;
                      *(void *)&out[8] = out;
                      uint64_t v137 = 0x2000000000LL;
                      uint64_t v138 = 0LL;
                      *(void *)buf = _NSConcreteStackBlock;
                      *(void *)&uint8_t buf[8] = 0x40000000LL;
                      *(void *)&uint8_t buf[16] = __dnssd_svcb_copy_doh_path_block_invoke;
                      *(void *)&uint64_t v122 = &unk_10013E330;
                      *((void *)&v122 + 1) = out;
                      _dnssd_svcb_extract_values(v90, v89, 7, (uint64_t)buf);
                      uint64_t v41 = *(char **)(*(void *)&out[8] + 24LL);
                      _Block_object_dispose(out, 8);
                      if (v41)
                      {
                        BOOL v42 = strchr(v41, 123);
                        if (v42) {
                          *BOOL v42 = 0;
                        }
                      }

                      unsigned int v83 = 0LL;
                      *(void *)out = 0LL;
                      *(void *)&out[8] = out;
                      uint64_t v137 = 0x2000000000LL;
                      uint64_t v138 = 0LL;
                      *(void *)buf = _NSConcreteStackBlock;
                      *(void *)&uint8_t buf[8] = 0x40000000LL;
                      *(void *)&uint8_t buf[16] = __dnssd_svcb_copy_odoh_config_block_invoke;
                      *(void *)&uint64_t v122 = &unk_10013E358;
                      *((void *)&v122 + 1) = out;
                      __int128 v123 = &v83;
                      _dnssd_svcb_extract_values(v90, v89, 32769, (uint64_t)buf);
                      BOOL v43 = *(void **)(*(void *)&out[8] + 24LL);
                      _Block_object_dispose(out, 8);
                      __int16 v44 = *((unsigned __int8 *)v86 + 24);
                      uint64_t v45 = v83;
                      if (v44 == 3 && v43 && v83)
                      {
                        __int16 v44 = 4;
                        *((_BYTE *)v86 + 24) = 4;
                      }

                      endpoint = v45;
                      uint64_t v79 = v43;
                      *(void *)out = 0LL;
                      *(void *)&out[8] = out;
                      uint64_t v137 = 0x2000000000LL;
                      uint64_t v138 = 0LL;
                      *(void *)buf = _NSConcreteStackBlock;
                      *(void *)&uint8_t buf[8] = 0x40000000LL;
                      *(void *)&uint8_t buf[16] = ___mdns_dns_service_get_discovered_alt_block_invoke;
                      *(void *)&uint64_t v122 = &unk_10013B050;
                      int v76 = v44;
                      LOBYTE(v124) = v44;
                      __int128 v123 = parameters;
                      *((void *)&v122 + 1) = out;
                      int v46 = *(const __CFArray **)(v10 + 144);
                      if (v46)
                      {
                        mdns_cfarray_enumerate(v46, (uint64_t)buf);
                        int v47 = *(const void **)(*(void *)&out[8] + 24LL);
                        _Block_object_dispose(out, 8);
                        if (v47)
                        {
                          _mdns_dns_service_manager_add_pending_alt(v11, v10, v47);
                          if (!v41) {
                            goto LABEL_153;
                          }
LABEL_152:
                          free(v41);
                          goto LABEL_153;
                        }
                      }

                      else
                      {
                        _Block_object_dispose(out, 8);
                      }

                      uint64_t v72 = v41;
                      int v48 = nw_resolver_config_create();
                      uint64_t v49 = (void *)v48;
                      else {
                        __int16 v50 = 2LL;
                      }
                      nw_resolver_config_set_class(v48, v50);
                      nw_resolver_config_set_protocol(v49, (v76 - 2) + 1);
                      nw_resolver_config_set_provider_name(v49, parameters);
                      if (v72) {
                        nw_resolver_config_set_provider_path(v49, v72);
                      }
                      obuint64_t j = v49;
                      memset(buf, 0, 17);
                      if (*(void *)(v10 + 104) || (uint64_t v62 = *(_DWORD *)(v10 + 256)) != 0 && if_indextoname(v62, buf)) {
                        nw_resolver_config_set_interface_name(v49);
                      }
                      memset(out, 0, sizeof(out));
                      uuid_generate(out);
                      nw_resolver_config_set_identifier(v49, out);
                      uint64_t v41 = v72;
                      if (obj)
                      {
                        if (nw_resolver_config_get_class(obj) == 4)
                        {
                          *(_DWORD *)out = 0;
                          discovered_alt = _mdns_dns_service_create_discovered_alt(v10, obj, v73, 0, 0LL, out);
                          if (discovered_alt)
                          {
                            __int16 v52 = discovered_alt;
                            *(_DWORD *)out = _mdns_dns_service_manager_add_pending_alt(v11, v10, discovered_alt);
                            nw_release(obj);
                            os_release(v52);
                          }

                          else
                          {
                            if (_mdns_dns_service_log_s_once != -1) {
                              dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_62);
                            }
                            uint64_t v68 = (os_log_s *)_mdns_dns_service_log_s_log;
                            if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_ERROR))
                            {
                              *(_DWORD *)buf = 134217984;
                              *(void *)&uint8_t buf[4] = *(int *)out;
                              _os_log_error_impl( (void *)&_mh_execute_header,  v68,  OS_LOG_TYPE_ERROR,  "Failed to create discovered oblivious DNS service -- error: %{mdns:err}ld",  buf,  0xCu);
                            }

                            nw_release(obj);
                          }

                          uint64_t v41 = v72;
                          if (v72) {
                            goto LABEL_152;
                          }
LABEL_153:
                          if (v79) {
                            free(v79);
                          }
                          int v37 = __s;
LABEL_156:
                          uint64_t v26 = v37;
                          goto LABEL_157;
                        }

                        if (_mdns_dns_service_log_s_once != -1) {
                          dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_62);
                        }
                        unsigned int v55 = (os_log_s *)_mdns_dns_service_log_s_log;
                        if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_INFO))
                        {
                          *(_DWORD *)buf = 67109891;
                          unsigned int v56 = "";
                          if (v72) {
                            unsigned int v56 = v72;
                          }
                          *(_DWORD *)&uint8_t buf[4] = v76;
                          *(_WORD *)&uint8_t buf[8] = 2081;
                          *(void *)&buf[10] = parameters;
                          *(_WORD *)&_BYTE buf[18] = 1024;
                          *(_DWORD *)&buf[20] = v73;
                          LOWORD(v122) = 2081;
                          *(void *)((char *)&v122 + 2) = v56;
                          _os_log_impl( (void *)&_mh_execute_header,  v55,  OS_LOG_TYPE_INFO,  "Verifying discovered service -- type: %{mdns:dns_service_type}d, provider name: %{private}s, port: %d, path: %{private}s",  buf,  0x22u);
                        }

                        aBlock[0] = _NSConcreteStackBlock;
                        aBlock[1] = 0x40000000LL;
                        aBlock[2] = ___mdns_dns_service_manager_register_discovered_service_block_invoke;
                        aBlock[3] = &__block_descriptor_tmp_212;
                        aBlock[4] = v10;
                        aBlock[5] = obj;
                        uint64_t v96 = v73;
                        aBlock[6] = v11;
                        v111[0] = 0LL;
                        v111[1] = v111;
                        v111[2] = 0x2000000000LL;
                        v111[3] = 0LL;
                        v110[0] = 0LL;
                        v110[1] = v110;
                        v110[2] = 0x2000000000LL;
                        v110[3] = 0LL;
                        if (v76 == 2) {
                          unsigned int v57 = 853;
                        }
                        else {
                          unsigned int v57 = 443;
                        }
                        if (v73) {
                          uint64_t v58 = v73;
                        }
                        else {
                          uint64_t v58 = v57;
                        }
                        v108[0] = 0LL;
                        v108[1] = v108;
                        v108[2] = 0x2000000000LL;
                        uint64_t v109 = 0;
                        endpointa = (nw_endpoint *)nw_endpoint_create_host_with_numeric_port(parameters, v58);
                        *(void *)out = _NSConcreteStackBlock;
                        *(void *)&out[8] = 0x40000000LL;
                        uint64_t v137 = (uint64_t)___mdns_dns_service_manager_probe_discovered_service_block_invoke;
                        uint64_t v138 = &unk_10013B0C8;
                        int v143 = v76;
                        uint64_t v139 = v108;
                        uint64_t v140 = v111;
                        BOOL v141 = v110;
                        int v142 = parameters;
                        parametersa = nw_parameters_create_secure_tcp( out,  _nw_parameters_configure_protocol_default_configuration);
                        *(void *)unsigned int v133 = 0LL;
                        uint64_t v134 = 0LL;
                        uint64_t v135 = 0;
                        uint64_t v59 = *(char **)(v10 + 104);
                        if (v59 || (v63 = *(_DWORD *)(v10 + 256)) != 0 && (uint64_t v59 = if_indextoname(v63, v133)) != 0LL)
                        {
                          if (_mdns_dns_service_log_s_once != -1) {
                            dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_62);
                          }
                          int v60 = (os_log_s *)_mdns_dns_service_log_s_log;
                          if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_INFO))
                          {
                            *(_DWORD *)buf = 136446210;
                            *(void *)&uint8_t buf[4] = v59;
                            _os_log_impl( (void *)&_mh_execute_header,  v60,  OS_LOG_TYPE_INFO,  "Scoping discovered service to %{public}s",  buf,  0xCu);
                          }

                          uint64_t v61 = (nw_interface *)nw_interface_create_with_name(v59);
                          nw_parameters_require_interface(parametersa, v61);
                          if (v61) {
                            nw_release(v61);
                          }
                        }

                        uint64_t v104 = 0LL;
                        uint64_t v105 = &v104;
                        uint64_t v106 = 0x2000000000LL;
                        uint64_t v107 = 0LL;
                        uint64_t v107 = nw_connection_create(endpointa, parametersa);
                        if (parametersa) {
                          nw_release(parametersa);
                        }
                        uint64_t v64 = (nw_connection *)v105[3];
                        if (_mdns_dns_service_queue_s_once != -1) {
                          dispatch_once(&_mdns_dns_service_queue_s_once, &__block_literal_global_237);
                        }
                        nw_connection_set_queue(v64, (dispatch_queue_t)_mdns_dns_service_queue_s_queue);
                        os_retain((void *)v10);
                        dispatch_group_enter(group);
                        v102[0] = 0LL;
                        v102[1] = v102;
                        v102[2] = 0x2000000000LL;
                        uint64_t v103 = 0;
                        v100[0] = 0LL;
                        v100[1] = v100;
                        v100[2] = 0x2000000000LL;
                        int v101 = 0;
                        v99[0] = 0LL;
                        v99[1] = v99;
                        v99[2] = 0x2000000000LL;
                        v99[3] = 0LL;
                        v97[0] = 0LL;
                        v97[1] = v97;
                        v97[2] = 0x3002000000LL;
                        v97[3] = __Block_byref_object_copy__850;
                        v97[4] = __Block_byref_object_dispose__851;
                        uint32_t v98 = 0LL;
                        uint32_t v98 = _Block_copy(aBlock);
                        uint64_t v65 = v105[3];
                        *(void *)buf = _NSConcreteStackBlock;
                        *(void *)&uint8_t buf[8] = 0x40000000LL;
                        *(void *)&uint8_t buf[16] = ___mdns_dns_service_manager_probe_discovered_service_block_invoke_220;
                        *(void *)&uint64_t v122 = &unk_10013B118;
                        *((void *)&v122 + 1) = &v104;
                        __int128 v123 = v102;
                        int v132 = v76;
                        uint64_t v124 = v111;
                        uint64_t v125 = v110;
                        uint64_t v126 = v100;
                        uint64_t v127 = v99;
                        uint64_t v130 = v10;
                        uint64_t v131 = group;
                        uint64_t v128 = v97;
                        unsigned int v129 = v108;
                        nw_connection_set_event_handler(v65, buf);
                        nw_connection_start((nw_connection_t)v105[3]);
                        uint64_t v66 = v105[3];
                        uint64_t v67 = *(void *)(v10 + 208);
                        if (v67 || (uint64_t v67 = nw_array_create(), (*(void *)(v10 + 208) = v67) != 0LL))
                        {
                          nw_array_append(v67, v66);
                        }

                        else
                        {
                          if (_mdns_dns_service_log_s_once != -1) {
                            dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_62);
                          }
                          uint64_t v69 = (os_log_s *)_mdns_dns_service_log_s_log;
                          if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_ERROR))
                          {
                            uint64_t v70 = *(void *)(v10 + 24);
                            *(_DWORD *)unint64_t v119 = 134217984;
                            unsigned int v120 = v70;
                            _os_log_error_impl( (void *)&_mh_execute_header,  v69,  OS_LOG_TYPE_ERROR,  "Cancelling service's DDR verification connection because of lack of resources -- service id: %llu",  v119,  0xCu);
                          }

                          nw_connection_cancel((nw_connection_t)v105[3]);
                        }

                        uint64_t v41 = v72;
                        _Block_object_dispose(v97, 8);
                        _Block_object_dispose(v99, 8);
                        _Block_object_dispose(v100, 8);
                        _Block_object_dispose(v102, 8);
                        _Block_object_dispose(&v104, 8);
                        _Block_object_dispose(v108, 8);
                        _Block_object_dispose(v110, 8);
                        _Block_object_dispose(v111, 8);
                      }

                      else
                      {
LABEL_110:
                        if (_mdns_dns_service_log_s_once != -1) {
                          dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_62);
                        }
                        int v53 = (os_log_s *)_mdns_dns_service_log_s_log;
                        if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_ERROR))
                        {
                          *(_DWORD *)buf = 67109891;
                          unsigned int v54 = "";
                          if (v41) {
                            unsigned int v54 = v41;
                          }
                          *(_DWORD *)&uint8_t buf[4] = v76;
                          *(_WORD *)&uint8_t buf[8] = 2081;
                          *(void *)&buf[10] = parameters;
                          *(_WORD *)&_BYTE buf[18] = 1024;
                          *(_DWORD *)&buf[20] = v73;
                          LOWORD(v122) = 2081;
                          *(void *)((char *)&v122 + 2) = v54;
                          _os_log_error_impl( (void *)&_mh_execute_header,  v53,  OS_LOG_TYPE_ERROR,  "Failed to create discovered DNS config -- type: %{mdns:dns_service_type}d, provider name: %{ private}s, port: %d, path: %{private}s",  buf,  0x22u);
                          if (v41) {
                            goto LABEL_152;
                          }
                          goto LABEL_153;
                        }
                      }

                      if (!v41) {
                        goto LABEL_153;
                      }
                      goto LABEL_152;
                    }
                  }

                  else if ((dnssd_svcb_service_name_is_empty((uint64_t)v90, v89) & 1) == 0)
                  {
                    goto LABEL_29;
                  }
                }
              }

LABEL_74:
        bzero(v917, 0x320uLL);
        bzero(v916, 0x960uLL);
        int v887 = 0;
        if (!v896 && v22)
        {
          unsigned int v54 = *(unsigned __int8 *)(*(void *)(v22 + 88) + 70LL);
          if ((v54 & 4) != 0) {
            int v887 = (v54 >> 1) & 1;
          }
          else {
            int v887 = 0;
          }
        }

        v836 = 0LL;
        char v90 = 0;
        if (v53 < 1 || !Answers)
        {
          unsigned int v862 = 0;
          unsigned int v91 = 0;
          goto LABEL_908;
        }

        unsigned int v862 = 0;
        unsigned int v91 = 0;
        uint64_t v92 = a8;
        unsigned int v93 = 0;
        int v880 = 0;
        uint64_t v94 = 0LL;
        unsigned int v875 = 0;
        unsigned int v862 = 0;
        int v859 = 0;
        v827 = (_DWORD *)(a1 + 19856);
        else {
          int v95 = 1;
        }
        int v876 = v95;
        uint64_t v898 = a1 + 37856;
        BOOL v872 = (v22 | v92) != 0;
        v855 = (_BYTE *)(a1 + 46976);
        unsigned int v830 = bswap32(a5) >> 16;
        uint64_t v96 = "uni";
        if ((_DWORD)v25) {
          uint64_t v96 = "multi";
        }
        v824 = v96;
        if (v887) {
          int v97 = 2;
        }
        else {
          int v97 = 0;
        }
        unsigned int v831 = v97 | (v92 != 0);
        uint64_t v826 = a1 + 12664;
        v833 = (int8x8_t *)&v911;
        uint32_t v98 = Answers;
        int v883 = v53;
        char v868 = (char)v25;
LABEL_171:
        if (v880) {
          int v99 = 1;
        }
        else {
          int v99 = v876;
        }
        if (v93 >= v890) {
          char v100 = 0x80;
        }
        else {
          char v100 = -96;
        }
        if (v93 < v892) {
          char v100 = -64;
        }
        LargeResourceRecord = GetLargeResourceRecord(a1, (unint64_t)a2, v98, a3, (uint64_t)v16, v100 & 0xE0, v898);
        if (!LargeResourceRecord)
        {
          uint64_t v386 = v906;
          goto LABEL_981;
        }

        uint32_t v98 = LargeResourceRecord;
        if (DPCFeatureEnabled_sOnce != -1) {
          dispatch_once(&DPCFeatureEnabled_sOnce, &__block_literal_global_3237);
        }
        if (DPCFeatureEnabled_sEnabled)
        {
          if (v896)
          {
            if (!v901)
            {
              uint64_t v102 = *((void *)v23 + 4);
              uint64_t v103 = *((unsigned __int16 *)v23 + 2);
              uint64_t v104 = *((unsigned __int16 *)v23 + 3);
              if (DPCFeatureEnabled_sEnabled)
              {
                if (_DPCGetRegisteredSubscriber(v16, v102, v103, v104)) {
                  goto LABEL_203;
                }
              }
            }
          }
        }

        if (v872)
        {
          if (v94) {
            goto LABEL_198;
          }
          uint64_t v109 = mdns_cache_metadata_create();
          uint64_t v94 = (void *)v109;
          if (v906)
          {
            int v110 = *(_DWORD *)(*(void *)(*(void *)(v906 + 64) + 16LL) + 144LL);
            if (v110 == 1)
            {
              if (*(_BYTE *)(v906 + 250)) {
                int v110 = 2;
              }
              else {
                int v110 = 1;
              }
            }

            *(_DWORD *)(v109 + 4_Block_object_dispose(va, 8) = v110;
            mdns_cache_metadata_set_extended_dns_error(v109, *(void **)(v906 + 160));
          }

          if (v901)
          {
            v94[5] = *(void *)(v901 + 120);
            mdns_dns_push_service_definition_set_srv_name((uint64_t)v94, a9);
            goto LABEL_198;
          }

          mdns_dns_push_service_definition_set_srv_name((uint64_t)v94, a9);
          if (v94) {
LABEL_198:
          }
            os_retain(v94);
          __int128 v111 = (void *)*((void *)v23 + 6);
          if (v111) {
            os_release(v111);
          }
          *((void *)v23 + 6) = v94;
        }

        if (*v23 == 240) {
          goto LABEL_203;
        }
        v837 = v94;
        if (v887)
        {
          uint64_t v114 = _dnssec_obj_resource_record_member_new();
          v114[8] = 0;
          *((void *)v114 + 2) = v898;
          *((_BYTE *)v114 + 40) = 1;
          ++*v114;
          ref_count_obj_release(v114);
          *((void *)v23 + 7) = v114;
          uint64_t v94 = v837;
        }

        int v115 = *((unsigned __int16 *)v23 + 2);
        switch(v115)
        {
          case 5:
            if (mDNS_LoggingEnabled == 1) {
              LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "mDNSCoreReceiveResponse: CNAME loop domain name %##s",  v104,  v105,  v106,  v107,  v108,  *((void *)v23 + 4));
            }
LABEL_203:
            *(_WORD *)uint64_t v23 = 0;
            *((_WORD *)v23 + 51) = 0;
            uint64_t v112 = (void *)*((void *)v23 + 7);
            break;
          case 41:
            uint64_t v116 = *((void *)v23 + 5);
            unint64_t v117 = v116 + 4 + *((unsigned __int16 *)v23 + 6);
            if (v116 + 4 < v117)
            {
              uint64_t v118 = v116 + 8;
              do
              {
                if (*(_WORD *)(v118 - 4) == 4 && !*(_BYTE *)v118 && *(_DWORD *)(v118 + 2))
                {
                  ClearProxyRecords(a1, v118, *(void *)(a1 + 12632));
                  ClearProxyRecords(a1, v118, *(void *)(a1 + 12624));
                }

                unint64_t v119 = v118 + 20;
                v118 += 24LL;
              }

              while (v119 < v117);
            }

            *(_WORD *)uint64_t v23 = 0;
            *((_WORD *)v23 + 51) = 0;
            uint64_t v112 = (void *)*((void *)v23 + 7);
            uint64_t v94 = v837;
            break;
          case 250:
            goto LABEL_203;
          default:
LABEL_226:
            if (!v896)
            {
              unsigned int v120 = *((_DWORD *)v23 + 2);
              if (v120 >= 0x189374) {
                unsigned int v120 = 1610612;
              }
              unsigned int v121 = v120 + (v120 >> 2) + 2;
              if (v121 <= 0xF) {
                unsigned int v121 = 15;
              }
              *((_DWORD *)v23 + 2) = v121;
            }

            v904 = v98;
            if ((v25 & 1) != 0)
            {
              if (!v850 || !*((_BYTE *)v850 + 6378) || *((_WORD *)v23 + 2) != 1 || v23[148] != 169 || v23[149] != 254) {
                goto LABEL_301;
              }
              if (mDNS_LoggingEnabled == 1)
              {
                uint64_t v122 = mDNSLogCategory_Default;
                GetRRDisplayString_rdb(v23, (unsigned __int16 *)(*((void *)v23 + 5) + 4LL), v855);
                __int128 v123 = (os_log_s *)v122;
                uint64_t v94 = v837;
                LogMsgWithLevel( v123,  OS_LOG_TYPE_DEFAULT,  "mDNSResponder: Dropping LinkLocal packet %s",  v124,  v125,  v126,  v127,  v128,  (int)v855);
              }

              goto LABEL_203;
            }

            if (__src && (v99 & 1) != 0) {
              goto LABEL_242;
            }
            if (!v907)
            {
              uint64_t v135 = *(void *)(a1 + 200);
              LOBYTE(v25) = v868;
              if (!v135) {
                goto LABEL_298;
              }
              int v136 = *(unsigned __int16 *)a2;
              while (1)
              {
                if (!*(void *)(v135 + 40) && !*(_BYTE *)(v135 + 334))
                {
                  uint64_t v137 = *((void *)v23 + 3);
                  if ((!v137 || (uint64_t v138 = *(void *)(v135 + 136)) == 0 || v137 == v138)
                    && ((uint64_t v139 = *((void *)v23 + 6)) != 0 && *(void *)(v139 + 24) || !v137 || !*(_WORD *)(v135 + 320)))
                  {
                    uint64_t v140 = *(void *)(v135 + 144);
                    BOOL v141 = v140 && *(_BYTE *)(v140 + 24) != 0;
                    if (RRTypeAnswersQuestionType( (uint64_t)v23,  *(unsigned __int16 *)(v135 + 322),  v141,  v104,  v105,  v106,  v107,  v108))
                    {
                      int v142 = *(unsigned __int16 *)(v135 + 324);
                      if ((*((unsigned __int16 *)v23 + 3) == v142 || v142 == 255)
                        && *((_DWORD *)v23 + 4) == *(_DWORD *)(v135 + 200)
                        && SameDomainNameBytes(*((_BYTE **)v23 + 4), (_BYTE *)(v135 + 356)))
                      {
                        if (*(_WORD *)(v135 + 320))
                        {
                          if (*(unsigned __int16 *)(v135 + 320) == v136)
                          {
                            if (__src)
                            {
                              uint64_t v144 = *(__int16 **)(v135 + 72);
                              if (!v144) {
                                uint64_t v144 = &zeroIPPort;
                              }
                            }

                            else
                            {
                              uint64_t v144 = (__int16 *)(v135 + 318);
                            }

                            if ((unsigned __int16)*v144 == a7)
                            {
LABEL_291:
                              char v16 = (void *)a10;
                              int v145 = v859;
                              if (a10) {
                                int v145 = 1;
                              }
                              int v859 = v145;
                              int v146 = v880;
                              if (a10) {
                                int v146 = 1;
                              }
                              int v880 = v146;
                              int v99 = 1;
                              goto LABEL_300;
                            }

                            if (mDNS_LoggingEnabled == 1)
                            {
                              v844 = (os_log_s *)mDNSLogCategory_Default;
                              DNSTypeName(*(unsigned __int16 *)(v135 + 322));
                              GetRRDisplayString_rdb(v23, (unsigned __int16 *)(*((void *)v23 + 5) + 4LL), v855);
                              LogMsgWithLevel( v844,  OS_LOG_TYPE_DEFAULT,  "WARNING: Ignoring suspect uDNS response for %##s (%s) from %#a:%d %s",  v147,  v148,  v149,  v150,  v151,  v135 + 356);
                            }

  if (qword_10015D9A0)
  {
    ref_count_obj_release((void *)qword_10015D9A0);
    qword_10015D9A0 = 0LL;
  }

  int v39 = (os_log_s *)mDNSLogCategory_Default;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
  {
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    *(_WORD *)buf = 0;
  }

  else
  {
    int v39 = (os_log_s *)mDNSLogCategory_Default_redacted;
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    *(_WORD *)buf = 0;
  }

  _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_DEFAULT, "mDNS_FinalExit: done", buf, 2u);
}

    __break(1u);
  }

LABEL_443:
                          v211 = DNSTypeName(*(unsigned __int16 *)(v159 + 12));
                          *(_DWORD *)v961 = 141559043;
                          *(void *)&v961[4] = 1752392040LL;
                          *(_WORD *)&v961[12] = 1040;
                          *(_DWORD *)&v961[14] = v210;
                          *(_WORD *)&v961[18] = 2101;
                          *(void *)&v961[20] = v172;
                          *(_WORD *)&v961[28] = 2082;
                          *(void *)&v961[30] = v211;
                          *(_WORD *)&v961[38] = 1024;
                          char v16 = (void *)a10;
                          *(_DWORD *)&v961[40] = a10;
                          _os_log_impl( (void *)&_mh_execute_header,  v164,  OS_LOG_TYPE_DEFAULT,  "mDNSCoreReceiveResponse - deregistering %{sensitive, mask.hash, mdnsresponder:domain_name}.* P type %{public}s on interface %d due to TSR conflict",  v961,  0x2Cu);
                          uint32_t v98 = v904;
                        }
                      }

                      else
                      {
                        v164 = (os_log_s *)mDNSLogCategory_mDNS_redacted;
                        if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
                        {
                          uint64_t v172 = *(void *)(v159 + 40);
                          if (v172)
                          {
                            v173 = *(_BYTE **)(v159 + 40);
                            if (v172 == -256) {
                              goto LABEL_321;
                            }
LABEL_318:
                            unsigned __int16 v174 = 257;
                            if ((unint64_t)v173 < v172 + 256 && v173)
                            {
                              while (1)
                              {
                                uint64_t v175 = *v173;
                                if (v175 > 0x3F)
                                {
LABEL_437:
                                  unsigned __int16 v174 = 257;
                                  goto LABEL_440;
                                }

                                if (!*v173) {
                                  break;
                                }
                                v173 += v175 + 1;
                                if (v172 != -256) {
                                  goto LABEL_318;
                                }
LABEL_321:
                                if (!v173) {
                                  goto LABEL_437;
                                }
                              }

                              unsigned __int16 v174 = (_WORD)v173 - v172 + 1;
                            }

LABEL_440:
                            int v210 = v174;
                          }

                          else
                          {
                            int v210 = 0;
                          }

                          goto LABEL_443;
                        }
                      }

                      D2D_stop_advertising_record(v159, v165, v166, v167, v168, v169, v170, v171);
                      mDNS_Deregister_internal(a1, v159, 4);
                      goto LABEL_445;
                    }

          if (v364) {
            free((void *)v364);
          }
          goto LABEL_442;
        }

        goto LABEL_442;
      }

      if (*(_WORD *)(a3 + 12))
      {
        uint64_t v25 = a4;
        uint64_t v26 = 0LL;
        unint64_t v27 = (char *)&unk_100164138;
        LODWORD(a2) = 512;
        goto LABEL_70;
      }

      if (v11) {
        uint64_t v103 = (os_log_s *)mDNSLogCategory_Default;
      }
      else {
        uint64_t v103 = (os_log_s *)mDNSLogCategory_mDNS;
      }
      if (gSensitiveLoggingEnabled != 1 || v103 == (os_log_s *)mDNSLogCategory_State)
      {
        if (!os_log_type_enabled(v103, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_472;
        }
      }

      else
      {
        if (v11) {
          uint64_t v103 = (os_log_s *)mDNSLogCategory_Default_redacted;
        }
        else {
          uint64_t v103 = (os_log_s *)mDNSLogCategory_mDNS;
        }
        if (!os_log_type_enabled(v103, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_472;
        }
      }

      uint64_t v159 = *(_DWORD *)(v369 + 184);
      uint64_t v160 = *(unsigned __int16 *)(a3 + 4);
      LODWORD(__tp.tv_sec) = 67110912;
      HIDWORD(__tp.tv_sec) = v159;
      LOWORD(__tp.tv_nsec) = 1024;
      *(_DWORD *)((char *)&__tp.tv_nsec + 2) = __rev16(v23);
      HIWORD(__tp.tv_nsec) = 1024;
      *(_DWORD *)v376 = a4;
      *(_WORD *)&v376[4] = 1024;
      *(_DWORD *)&v376[6] = 0;
      LOWORD(v377) = 1024;
      *(_DWORD *)((char *)&v377 + 2) = v366;
      HIWORD(v377) = 1024;
      *(_DWORD *)uint64_t v378 = HIDWORD(v366);
      *(_WORD *)&v378[4] = 1026;
      *(_DWORD *)&v378[6] = v17;
      *(_WORD *)&v378[10] = 1024;
      *(_DWORD *)&v378[12] = v160;
      v161 = "[R%u->Q%u] DNSServiceResolve result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %d, name h"
             "ash: %x, dnssec: %{public, mdns:dnssec_result}d, type: %{mdns:rrtype}d, rdata: <none>";
      v162 = v103;
      unsigned int v163 = 50;
LABEL_611:
      _os_log_impl((void *)&_mh_execute_header, v162, OS_LOG_TYPE_DEFAULT, v161, (uint8_t *)&__tp, v163);
      goto LABEL_472;
    }
  }

  else
  {
    uint64_t v23 = *(unsigned __int16 *)(a2 + 320);
    LODWORD(a2) = *(unsigned __int16 *)(a3 + 12);
    uint64_t v24 = a2 < 0x201;
  }

  if (!v23)
  {
    if (v24)
    {
      uint64_t v26 = 0LL;
      int v37 = 512;
      int v38 = (char *)&unk_100164138;
    }

    else
    {
      uint64_t v41 = (unsigned __int8 *)malloc(a2);
      int v38 = (char *)v41;
      uint64_t v26 = v41;
      int v37 = a2;
      if (!v41) {
        goto LABEL_612;
      }
    }

    if ((_DWORD)a2)
    {
      uint64_t v371 = 0;
      int8x8_t v370 = 0;
      __int128 v73 = ResourceRecordGetRDataBytesPointer(a3, v38, v37, &v370, &v371, v18, v19, v20);
      if (v371) {
        goto LABEL_470;
      }
      BOOL v10 = (void *)v73;
      BOOL v43 = a4;
      uint64_t v74 = v370;
      if (v370 >= 0x1FFuLL)
      {
        uint64_t v75 = v370 + 2;
        uint64_t v41 = (unsigned __int8 *)malloc(v370 + 2LL);
        if (!v41) {
          goto LABEL_612;
        }
        int v76 = (__int16 *)v41;
        uint64_t v45 = v41;
      }

      else
      {
        uint64_t v45 = 0LL;
        uint64_t v75 = 512;
        int v76 = word_100164338;
      }

      if (v11) {
        uint64_t v148 = (os_log_s *)mDNSLogCategory_Default;
      }
      else {
        uint64_t v148 = (os_log_s *)mDNSLogCategory_mDNS;
      }
      if (gSensitiveLoggingEnabled != 1 || v148 == (os_log_s *)mDNSLogCategory_State)
      {
        if (!os_log_type_enabled(v148, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_423;
        }
        uint64_t v149 = *(_DWORD *)(v369 + 184);
        uint64_t v150 = *(unsigned __int16 *)(a3 + 4);
        uint64_t v151 = v74 + 2;
        if ((int)v74 + 2 <= v75)
        {
          *int v76 = __rev16(v150);
          uint64_t v233 = v74;
          uint64_t v234 = v10;
          LODWORD(v10) = v150;
          uint64_t v235 = v149;
          memcpy(v76 + 1, v234, v233);
          uint64_t v149 = v235;
          uint64_t v150 = v10;
        }

        else
        {
          int v76 = 0LL;
        }
      }

      else
      {
        if (v11) {
          uint64_t v148 = (os_log_s *)mDNSLogCategory_Default_redacted;
        }
        else {
          uint64_t v148 = (os_log_s *)mDNSLogCategory_mDNS;
        }
        if (!os_log_type_enabled(v148, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_423;
        }
        uint64_t v149 = *(_DWORD *)(v369 + 184);
        uint64_t v150 = *(unsigned __int16 *)(a3 + 4);
        uint64_t v151 = v74 + 2;
        if ((int)v74 + 2 <= v75)
        {
          *int v76 = __rev16(v150);
          v230 = v10;
          int v231 = v74;
          LODWORD(v10) = v150;
          v232 = v149;
          memcpy(v76 + 1, v230, v231);
          uint64_t v149 = v232;
          uint64_t v150 = v10;
        }

        else
        {
          int v76 = 0LL;
        }
      }

      LODWORD(__tp.tv_sec) = 67111171;
      HIDWORD(__tp.tv_sec) = v149;
      LOWORD(__tp.tv_nsec) = 1024;
      *(_DWORD *)((char *)&__tp.tv_nsec + 2) = v43;
      HIWORD(__tp.tv_nsec) = 1024;
      *(_DWORD *)v376 = 0;
      *(_WORD *)&v376[4] = 1024;
      *(_DWORD *)&v376[6] = v366;
      LOWORD(v377) = 1024;
      *(_DWORD *)((char *)&v377 + 2) = HIDWORD(v366);
      HIWORD(v377) = 1024;
      *(_DWORD *)uint64_t v378 = v150;
      *(_WORD *)&v378[4] = 2160;
      *(void *)&v378[6] = 1752392040LL;
      *(_WORD *)&v378[14] = 1040;
      *(_DWORD *)&v378[16] = v151;
      *(_WORD *)&v378[20] = 2101;
      *(void *)&v378[22] = v76;
      v193 = "[R%u->mDNS] DNSServiceResolve result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %d, name "
             "hash: %x, type: %{mdns:rrtype}d, rdata: %{sensitive, mask.hash, mdns:rdata}.*P";
      char v194 = v148;
      v195 = 64;
      goto LABEL_422;
    }

    if (v11) {
      unsigned int v81 = (os_log_s *)mDNSLogCategory_Default;
    }
    else {
      unsigned int v81 = (os_log_s *)mDNSLogCategory_mDNS;
    }
    if (gSensitiveLoggingEnabled != 1 || v81 == (os_log_s *)mDNSLogCategory_State)
    {
      if (!os_log_type_enabled(v81, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_470;
      }
    }

    else
    {
      if (v11) {
        unsigned int v81 = (os_log_s *)mDNSLogCategory_Default_redacted;
      }
      else {
        unsigned int v81 = (os_log_s *)mDNSLogCategory_mDNS;
      }
      if (!os_log_type_enabled(v81, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_470;
      }
    }

    __int128 v123 = *(_DWORD *)(v369 + 184);
    uint64_t v124 = *(unsigned __int16 *)(a3 + 4);
    LODWORD(__tp.tv_sec) = 67110400;
    HIDWORD(__tp.tv_sec) = v123;
    LOWORD(__tp.tv_nsec) = 1024;
    *(_DWORD *)((char *)&__tp.tv_nsec + 2) = a4;
    HIWORD(__tp.tv_nsec) = 1024;
    *(_DWORD *)v376 = 0;
    *(_WORD *)&v376[4] = 1024;
    *(_DWORD *)&v376[6] = v366;
    LOWORD(v377) = 1024;
    *(_DWORD *)((char *)&v377 + 2) = HIDWORD(v366);
    HIWORD(v377) = 1024;
    *(_DWORD *)uint64_t v378 = v124;
    uint32_t v98 = "[R%u->mDNS] DNSServiceResolve result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %d, name has"
          "h: %x, type: %{mdns:rrtype}d, rdata: <none>";
    int v99 = v81;
    char v100 = 38;
    goto LABEL_418;
  }

  if (v24)
  {
    uint64_t v26 = 0LL;
    uint64_t v33 = 512;
    uint64_t v34 = (char *)&unk_100164138;
  }

  else
  {
    uint64_t v41 = (unsigned __int8 *)malloc(a2);
    uint64_t v34 = (char *)v41;
    uint64_t v26 = v41;
    uint64_t v33 = a2;
    if (!v41) {
      goto LABEL_612;
    }
  }

  if ((_DWORD)a2)
  {
    uint64_t v371 = 0;
    int8x8_t v370 = 0;
    BOOL v42 = ResourceRecordGetRDataBytesPointer(a3, v34, v33, &v370, &v371, v18, v19, v20);
    if (v371) {
      goto LABEL_470;
    }
    BOOL v10 = (void *)v42;
    BOOL v43 = a4;
    __int16 v44 = v370;
    if (v370 >= 0x1FFuLL)
    {
      int v46 = v370 + 2;
      uint64_t v41 = (unsigned __int8 *)malloc(v370 + 2LL);
      if (!v41) {
        goto LABEL_612;
      }
      int v47 = (__int16 *)v41;
      uint64_t v45 = v41;
    }

    else
    {
      uint64_t v45 = 0LL;
      int v46 = 512;
      int v47 = word_100164338;
    }

    if (v11) {
      __int128 v111 = (os_log_s *)mDNSLogCategory_Default;
    }
    else {
      __int128 v111 = (os_log_s *)mDNSLogCategory_mDNS;
    }
    if (gSensitiveLoggingEnabled == 1 && v111 != (os_log_s *)mDNSLogCategory_State)
    {
      if (v11) {
        __int128 v111 = (os_log_s *)mDNSLogCategory_Default_redacted;
      }
      else {
        __int128 v111 = (os_log_s *)mDNSLogCategory_mDNS;
      }
      if (!os_log_type_enabled(v111, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_423;
      }
      uint64_t v112 = *(_DWORD *)(v369 + 184);
      unsigned int v113 = bswap32(*(unsigned __int16 *)(v368 + 320)) >> 16;
      uint64_t v114 = *(unsigned __int16 *)(a3 + 4);
      int v115 = v44 + 2;
      if ((int)v44 + 2 <= v46)
      {
        const char *v47 = __rev16(v114);
        v185 = v10;
        unsigned __int16 v186 = v44;
        uint64_t v187 = v114;
        LODWORD(v10) = v112;
        BOOL v188 = v113;
        memcpy(v47 + 1, v185, v186);
        unsigned int v113 = v188;
        uint64_t v112 = (int)v10;
        uint64_t v114 = v187;
      }

      else
      {
        int v47 = 0LL;
      }

      goto LABEL_394;
    }

    if (os_log_type_enabled(v111, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v112 = *(_DWORD *)(v369 + 184);
      unsigned int v113 = bswap32(*(unsigned __int16 *)(v368 + 320)) >> 16;
      uint64_t v114 = *(unsigned __int16 *)(a3 + 4);
      int v115 = v44 + 2;
      if ((int)v44 + 2 <= v46)
      {
        const char *v47 = __rev16(v114);
        int v189 = v44;
        unsigned int v190 = v10;
        uint64_t v191 = v114;
        LODWORD(v10) = v112;
        v192 = v113;
        memcpy(v47 + 1, v190, v189);
        unsigned int v113 = v192;
        uint64_t v112 = (int)v10;
        uint64_t v114 = v191;
      }

      else
      {
        int v47 = 0LL;
      }

LABEL_329:
                    if (!resource_records_have_same_dnssec_rr_category( *((void *)v858 + 7),  *(void *)(v159 + 64))
                      || *((unsigned __int16 *)v858 + 2) != *(unsigned __int16 *)(v159 + 12)
                      || *((unsigned __int16 *)v858 + 3) != *(unsigned __int16 *)(v159 + 14)
                      || *((unsigned __int16 *)v858 + 6) != *(unsigned __int16 *)(v159 + 20)
                      || *((_DWORD *)v858 + 5) != *(_DWORD *)(v159 + 28)
                      || !SameRDataBody( (uint64_t)v858,  (unsigned __int16 *)(*(void *)(v159 + 48) + 4LL),  (uint64_t (*)(uint64_t, unsigned __int16 *))SameDomainName))
                    {
                      uint32_t v98 = v904;
                      if (!*((_DWORD *)v858 + 2) || !PacketRRConflict(a1, v159, v898))
                      {
                        if (*((unsigned __int16 *)v858 + 2) == *(unsigned __int16 *)(v159 + 12) && (*v858 & 0x10) != 0)
                        {
                          int v177 = *(_DWORD *)(a1 + 64);
                          if ((v177 - *(_DWORD *)(v159 + 288)) >= 0x1F5
                            && ResourceRecordIsValidAnswer(v159))
                          {
                            *(void *)(v159 + 20_Block_object_dispose(va, 8) = -1LL;
                            *(_DWORD *)(a1 + 100) = v177;
                          }
                        }

                        goto LABEL_445;
                      }

                      v176 = (os_log_s *)mDNSLogCategory_mDNS;
                      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
                      {
                        if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
                          goto LABEL_352;
                        }
                      }

                      else
                      {
                        v176 = (os_log_s *)mDNSLogCategory_mDNS_redacted;
                        if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
                        {
LABEL_352:
                          int v178 = *((_DWORD *)v858 + 5);
                          GetRRDisplayString_rdb(v858, (unsigned __int16 *)(*((void *)v858 + 5) + 4LL), v855);
                          *(_DWORD *)v961 = 67109891;
                          *(_DWORD *)&v961[4] = v178;
                          uint32_t v98 = v904;
                          *(_WORD *)&v961[8] = 2160;
                          *(void *)&v961[10] = 1752392040LL;
                          *(_WORD *)&v961[18] = 2085;
                          *(void *)&v961[20] = v855;
                          LOBYTE(v25) = v868;
                          *(_WORD *)&v961[28] = 1024;
                          *(_DWORD *)&v961[30] = (_DWORD)v16;
                          _os_log_impl( (void *)&_mh_execute_header,  v176,  OS_LOG_TYPE_DEFAULT,  "mDNSCoreReceiveResponse: Pkt Record: %08X %{sensitive, mask.hash}s (interface %d)",  v961,  0x22u);
                        }
                      }

                      v179 = (os_log_s *)mDNSLogCategory_mDNS;
                      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
                      {
                        if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
                          goto LABEL_358;
                        }
                      }

                      else
                      {
                        v179 = (os_log_s *)mDNSLogCategory_mDNS_redacted;
                        if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
                        {
LABEL_358:
                          int v180 = *(_DWORD *)(v159 + 28);
                          GetRRDisplayString_rdb( (unsigned __int8 *)(v159 + 8),  (unsigned __int16 *)(*(void *)(v159 + 48) + 4LL),  v855);
                          *(_DWORD *)v961 = 67109635;
                          *(_DWORD *)&v961[4] = v180;
                          uint32_t v98 = v904;
                          *(_WORD *)&v961[8] = 2160;
                          *(void *)&v961[10] = 1752392040LL;
                          *(_WORD *)&v961[18] = 2085;
                          *(void *)&v961[20] = v855;
                          _os_log_impl( (void *)&_mh_execute_header,  v179,  OS_LOG_TYPE_DEFAULT,  "mDNSCoreReceiveResponse: Our Record: %08X %{sensitive, mask.hash}s",  v961,  0x1Cu);
                        }
                      }

                      if (*(void *)(v159 + 88))
                      {
                        do
                        {
                          uint64_t v181 = v159;
                          uint64_t v159 = *(void *)(v159 + 88);
                        }

                        while (v159);
                        v182 = (os_log_s *)mDNSLogCategory_mDNS;
                        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
                        {
                          v184 = v858;
                          if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
                            goto LABEL_381;
                          }
                        }

                        else
                        {
                          v182 = (os_log_s *)mDNSLogCategory_mDNS_redacted;
                          BOOL v188 = os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT);
                          v184 = v858;
                          if (v188)
                          {
LABEL_381:
                            int v189 = *(_DWORD *)(v181 + 28);
                            GetRRDisplayString_rdb( (unsigned __int8 *)(v181 + 8),  (unsigned __int16 *)(*(void *)(v181 + 48) + 4LL),  v855);
                            *(_DWORD *)v961 = 67109635;
                            *(_DWORD *)&v961[4] = v189;
                            uint32_t v98 = v904;
                            *(_WORD *)&v961[8] = 2160;
                            *(void *)&v961[10] = 1752392040LL;
                            *(_WORD *)&v961[18] = 2085;
                            *(void *)&v961[20] = v855;
                            LOBYTE(v25) = v868;
                            _os_log_impl( (void *)&_mh_execute_header,  v182,  OS_LOG_TYPE_DEFAULT,  "mDNSCoreReceiveResponse: Dep Record: %08X %{sensitive, mask.hash}s",  v961,  0x1Cu);
                          }
                        }
                      }

                      else
                      {
                        uint64_t v181 = v159;
                        v184 = v858;
                      }

                      unsigned int v190 = *(unsigned __int8 *)(v181 + 190);
                      if (v190 >= 4)
                      {
                        uint64_t v191 = mDNSLogCategory_mDNS;
                        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
                        {
                          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
                            goto LABEL_401;
                          }
                        }

                        else
                        {
                          uint64_t v191 = mDNSLogCategory_mDNS_redacted;
                          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
                            goto LABEL_401;
                          }
                        }

                        GetRRDisplayString_rdb( (unsigned __int8 *)(v181 + 8),  (unsigned __int16 *)(*(void *)(v181 + 48) + 4LL),  v855);
                        *(_DWORD *)v961 = 141558275;
                        *(void *)&v961[4] = 1752392040LL;
                        *(_WORD *)&v961[12] = 2085;
                        *(void *)&v961[14] = v855;
                        v192 = (os_log_s *)v191;
                        v193 = "mDNSCoreReceiveResponse: Already reset to Probing: %{sensitive, mask.hash}s";
LABEL_400:
                        _os_log_impl((void *)&_mh_execute_header, v192, OS_LOG_TYPE_DEFAULT, v193, v961, 0x16u);
                        goto LABEL_401;
                      }

                      char v194 = gSensitiveLoggingEnabled;
                      v195 = (os_log_s *)mDNSLogCategory_mDNS;
                      if (mDNSLogCategory_mDNS == mDNSLogCategory_State) {
                        char v194 = 0;
                      }
                      if (v190 == 3)
                      {
                        if ((v194 & 1) != 0)
                        {
                          v195 = (os_log_s *)mDNSLogCategory_mDNS_redacted;
                          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
                            goto LABEL_401;
                          }
                        }

                        else if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
                        {
                          goto LABEL_401;
                        }

                        GetRRDisplayString_rdb( (unsigned __int8 *)(v181 + 8),  (unsigned __int16 *)(*(void *)(v181 + 48) + 4LL),  v855);
                        *(_DWORD *)v961 = 141558275;
                        *(void *)&v961[4] = 1752392040LL;
                        *(_WORD *)&v961[12] = 2085;
                        *(void *)&v961[14] = v855;
                        v192 = v195;
                        v193 = "mDNSCoreReceiveResponse: Ignoring response received before we even began probing: %{sensi"
                               "tive, mask.hash}s";
                        goto LABEL_400;
                      }

                      if ((v194 & 1) != 0)
                      {
                        v195 = (os_log_s *)mDNSLogCategory_mDNS_redacted;
                        if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
                        {
LABEL_404:
                          GetRRDisplayString_rdb(v184, (unsigned __int16 *)(*((void *)v184 + 5) + 4LL), v855);
                          *(_DWORD *)v961 = 141559299;
                          *(void *)&v961[4] = 1752392040LL;
                          *(_WORD *)&v961[12] = 1045;
                          *(_DWORD *)&v961[14] = 20;
                          *(_WORD *)&v961[18] = 2101;
                          *(void *)&v961[20] = v848;
                          *(_WORD *)&v961[28] = 1024;
                          *(_DWORD *)&v961[30] = v830;
                          *(_WORD *)&v961[34] = 2160;
                          *(void *)&v961[36] = 1752392040LL;
                          *(_WORD *)&v961[44] = 2085;
                          *(void *)&v961[46] = v855;
                          LOBYTE(v25) = v868;
                          _os_log_impl( (void *)&_mh_execute_header,  v195,  OS_LOG_TYPE_DEFAULT,  "mDNSCoreReceiveResponse: Received from %{sensitive, mask.hash, mdnsresponder:ip_addr}.20P:%d %{sensitive, mask.hash}s",  v961,  0x36u);
                        }
                      }

                      else if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
                      {
                        goto LABEL_404;
                      }

                      int v196 = *(unsigned __int8 *)(v181 + 8);
                      if (v196 != 2)
                      {
                        if (v196 != 32)
                        {
                          if (v196 == 16)
                          {
                            v197 = (os_log_s *)mDNSLogCategory_mDNS;
                            if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
                            {
                              a1 = v878;
                              if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
                                goto LABEL_449;
                              }
                            }

                            else
                            {
                              v197 = (os_log_s *)mDNSLogCategory_mDNS_redacted;
                              a1 = v878;
                              if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
                              {
LABEL_449:
                                GetRRDisplayString_rdb( (unsigned __int8 *)(v181 + 8),  (unsigned __int16 *)(*(void *)(v181 + 48) + 4LL),  v855);
                                *(_DWORD *)v961 = 141558275;
                                *(void *)&v961[4] = 1752392040LL;
                                *(_WORD *)&v961[12] = 2085;
                                *(void *)&v961[14] = v855;
                                LOBYTE(v25) = v868;
                                _os_log_impl( (void *)&_mh_execute_header,  v197,  OS_LOG_TYPE_DEFAULT,  "mDNSCoreReceiveResponse: Resetting to Probing: %{sensitive, mask.hash}s",  v961,  0x16u);
                              }
                            }

                            *(_BYTE *)(v181 + _Block_object_dispose(va, 8) = 2;
                            *(_WORD *)(v181 + 190) = 1028;
                            InitializeLastAPTime((_DWORD *)a1, v181);
                            RecordProbeFailure((_DWORD *)a1, v181);
                            goto LABEL_401;
                          }

                          v209 = (os_log_s *)mDNSLogCategory_mDNS;
                          if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
                          {
                            if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_ERROR)) {
                              goto LABEL_455;
                            }
                          }

                          else
                          {
                            v209 = (os_log_s *)mDNSLogCategory_mDNS_redacted;
                            if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_ERROR))
                            {
LABEL_455:
                              GetRRDisplayString_rdb( (unsigned __int8 *)(v181 + 8),  (unsigned __int16 *)(*(void *)(v181 + 48) + 4LL),  v855);
                              *(_DWORD *)v961 = 67109635;
                              *(_DWORD *)&v961[4] = v196;
                              *(_WORD *)&v961[8] = 2160;
                              *(void *)&v961[10] = 1752392040LL;
                              *(_WORD *)&v961[18] = 2085;
                              *(void *)&v961[20] = v855;
                              _os_log_impl( (void *)&_mh_execute_header,  v209,  OS_LOG_TYPE_ERROR,  "mDNSCoreReceiveResponse: Unexpected record type %X %{sensitive, mask.hash}s",  v961,  0x1Cu);
                            }
                          }

                          int v859 = 1;
                          a1 = v878;
                          goto LABEL_402;
                        }

                        v201 = (os_log_s *)mDNSLogCategory_mDNS;
                        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
                        {
                          a1 = v878;
                          if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_ERROR)) {
                            goto LABEL_452;
                          }
                        }

                        else
                        {
                          v201 = (os_log_s *)mDNSLogCategory_mDNS_redacted;
                          a1 = v878;
                          if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_ERROR))
                          {
LABEL_452:
                            GetRRDisplayString_rdb( (unsigned __int8 *)(v181 + 8),  (unsigned __int16 *)(*(void *)(v181 + 48) + 4LL),  v855);
                            *(_DWORD *)v961 = 141558275;
                            *(void *)&v961[4] = 1752392040LL;
                            *(_WORD *)&v961[12] = 2085;
                            *(void *)&v961[14] = v855;
                            LOBYTE(v25) = v868;
                            _os_log_impl( (void *)&_mh_execute_header,  v201,  OS_LOG_TYPE_ERROR,  "mDNSCoreReceiveResponse: Unexpected conflict discarding %{sensitive, mask.hash}s",  v961,  0x16u);
                          }
                        }

                        ++v827[1];
LABEL_493:
                        D2D_stop_advertising_record(v181, v202, v203, v204, v205, v206, v207, v208);
                        mDNS_Deregister_internal(a1, v181, 2);
                        goto LABEL_401;
                      }

                      v198 = *(uint64_t **)(v878 + 15024);
                      if (v198)
                      {
                        a1 = v878;
                        do
                        {
                          if (*((_DWORD *)v198 + 6) == *(_DWORD *)(v181 + 24)
                            && resource_records_have_same_dnssec_rr_category( v198[8],  *(void *)(v181 + 64))
                            && *((unsigned __int16 *)v198 + 6) == *(unsigned __int16 *)(v181 + 12)
                            && *((unsigned __int16 *)v198 + 7) == *(unsigned __int16 *)(v181 + 14)
                            && *((unsigned __int16 *)v198 + 10) == *(unsigned __int16 *)(v181 + 20)
                            && *((_DWORD *)v198 + 7) == *(_DWORD *)(v181 + 28)
                            && SameRDataBody( (uint64_t)(v198 + 1),  (unsigned __int16 *)(*(void *)(v181 + 48) + 4LL),  (uint64_t (*)(uint64_t, unsigned __int16 *))SameDomainName)
                            && SameDomainNameBytes((_BYTE *)v198[5], *(_BYTE **)(v181 + 40)))
                          {
                            if (mDNS_LoggingEnabled == 1)
                            {
                              v232 = (os_log_s *)mDNSLogCategory_Default;
                              GetRRDisplayString_rdb( (unsigned __int8 *)(v181 + 8),  (unsigned __int16 *)(*(void *)(v181 + 48) + 4LL),  v855);
                              LogMsgWithLevel( v232,  OS_LOG_TYPE_DEFAULT,  "mDNSCoreRegisteredProxyRecord: Ignoring packet registered with sleep proxy : %s ",  v233,  v234,  v235,  v236,  v237,  (int)v855);
                            }

                            goto LABEL_401;
                          }

                          v198 = (uint64_t *)*v198;
                        }

                        while (v198);
                        v199 = *(unsigned __int8 **)(v878 + 15024);
                        if (v199)
                        {
                          if (mDNS_LoggingEnabled != 1)
                          {
                            int v200 = 0;
                            goto LABEL_458;
                          }

                          LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "Stored Proxy records :",  v104,  v105,  v106,  v107,  v108,  v820);
                          v199 = *(unsigned __int8 **)(v878 + 15024);
                          if (v199)
                          {
                            int v200 = mDNS_LoggingEnabled;
                            do
                            {
LABEL_458:
                              if (v200)
                              {
                                v212 = (os_log_s *)mDNSLogCategory_Default;
                                GetRRDisplayString_rdb( v199 + 8,  (unsigned __int16 *)(*((void *)v199 + 6) + 4LL),  v855);
                                LOBYTE(v25) = v868;
                                LogMsgWithLevel( v212,  OS_LOG_TYPE_DEFAULT,  "%s",  v213,  v214,  v215,  v216,  v217,  (int)v855);
                                int v200 = mDNS_LoggingEnabled;
                              }

                              v199 = *(unsigned __int8 **)v199;
                            }

                            while (v199);
                          }
                        }
                      }

                      int v218 = *(_DWORD *)(v181 + 180);
                      a1 = v878;
                      if (v218 && *(_DWORD *)(v878 + 136) == *(_DWORD *)(v181 + 184)) {
                        goto LABEL_401;
                      }
                      v219 = (uint64_t *)v826;
                      while (1)
                      {
                        v219 = (uint64_t *)*v219;
                        if (!v219) {
                          break;
                        }
                        if (v219[782] == a10)
                        {
                          int v220 = v218 + 1;
                          *(_DWORD *)(v181 + 180) = v218 + 1;
                          *(_DWORD *)(v181 + 184) = *(_DWORD *)(v878 + 136);
                          if (!*((_BYTE *)v219 + 6381) || v220 > 1) {
                            goto LABEL_483;
                          }
LABEL_472:
                          v222 = (os_log_s *)mDNSLogCategory_mDNS;
                          if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
                          {
                            if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
                              goto LABEL_498;
                            }
                          }

                          else
                          {
                            v222 = (os_log_s *)mDNSLogCategory_mDNS_redacted;
                            if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
                            {
LABEL_498:
                              int v231 = *(unsigned __int8 *)(v181 + 190);
                              GetRRDisplayString_rdb( (unsigned __int8 *)(v181 + 8),  (unsigned __int16 *)(*(void *)(v181 + 48) + 4LL),  v855);
                              *(_DWORD *)v961 = 67110659;
                              *(_DWORD *)&v961[4] = v231;
                              uint32_t v98 = v904;
                              *(_WORD *)&v961[8] = 1024;
                              *(_DWORD *)&v961[10] = 1000;
                              *(_WORD *)&v961[14] = 1024;
                              *(_DWORD *)&v961[16] = v220;
                              *(_WORD *)&v961[20] = 1024;
                              *(_DWORD *)&v961[22] = 1;
                              *(_WORD *)&v961[26] = 1024;
                              *(_DWORD *)&v961[28] = a10;
                              *(_WORD *)&v961[32] = 2160;
                              *(void *)&v961[34] = 1752392040LL;
                              *(_WORD *)&v961[42] = 2085;
                              *(void *)&v961[44] = v855;
                              LOBYTE(v25) = v868;
                              _os_log_impl( (void *)&_mh_execute_header,  v222,  OS_LOG_TYPE_DEFAULT,  "mDNSCoreReceiveResponse: ProbeCount %u; restarting probing after %u-tick pause due to po"
                                "ssibly spurious multicast conflict (%d/%u) via interface %d for %{sensitive, mask.hash}s",
                                v961,
                                0x34u);
                            }
                          }

                          *(_BYTE *)(v181 + 190) = 3;
                          a1 = v878;
                          *(_DWORD *)(v181 + 284) = *(_DWORD *)(v878 + 64) - *(_DWORD *)(v181 + 280) + 1000;
                          SetNextAnnounceProbeTime(v878, v181);
LABEL_401:
                          int v859 = 1;
LABEL_402:
                          char v16 = (void *)a10;
                          goto LABEL_445;
                        }
                      }

                      int v220 = v218 + 1;
                      *(_DWORD *)(v181 + 180) = v218 + 1;
                      *(_DWORD *)(v181 + 184) = *(_DWORD *)(v878 + 136);
                      if (v218 + 1 < 2) {
                        char v224 = (char)v25;
                      }
                      else {
                        char v224 = 0;
                      }
                      if ((v224 & 1) != 0) {
                        goto LABEL_472;
                      }
LABEL_483:
                      v225 = (os_log_s *)mDNSLogCategory_mDNS;
                      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
                      {
                        a1 = v878;
                        if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
                          goto LABEL_491;
                        }
                      }

                      else
                      {
                        v225 = (os_log_s *)mDNSLogCategory_mDNS_redacted;
                        BOOL v227 = os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT);
                        a1 = v878;
                        if (v227)
                        {
LABEL_491:
                          int v228 = *(unsigned __int8 *)(v181 + 190);
                          GetRRDisplayString_rdb( (unsigned __int8 *)(v181 + 8),  (unsigned __int16 *)(*(void *)(v181 + 48) + 4LL),  v855);
                          *(_DWORD *)v961 = 67110147;
                          *(_DWORD *)&v961[4] = v228;
                          uint32_t v98 = v904;
                          *(_WORD *)&v961[8] = 2160;
                          *(void *)&v961[10] = 1752392040LL;
                          *(_WORD *)&v961[18] = 2085;
                          *(void *)&v961[20] = v855;
                          LOBYTE(v25) = v868;
                          *(_WORD *)&v961[28] = 2082;
                          *(void *)&v961[30] = v824;
                          *(_WORD *)&v961[38] = 1024;
                          *(_DWORD *)&v961[40] = a10;
                          _os_log_impl( (void *)&_mh_execute_header,  v225,  OS_LOG_TYPE_DEFAULT,  "mDNSCoreReceiveResponse: ProbeCount %u; will deregister %{sensitive, mask.hash}s due to %{pu"
                            "blic}scast conflict via interface %d",
                            v961,
                            0x2Cu);
                        }
                      }

                      ++*v827;
                      goto LABEL_493;
                    }

                    uint32_t v98 = v904;
                    if (*((_DWORD *)v858 + 2) >= *(_DWORD *)(v159 + 16) >> 1 || *(_BYTE *)(a1 + 141))
                    {
                      if (*(void **)(v159 + 208) == v16)
                      {
                        *(void *)(v159 + 20_Block_object_dispose(va, 8) = 0LL;
                        *(_BYTE *)(v159 + 195) = 0;
                      }
                    }

                    else
                    {
                      v229 = *(void **)(v159 + 208);
                      if (v229)
                      {
                        if (v229 == v16) {
                          goto LABEL_445;
                        }
                        *(void *)(v159 + 20_Block_object_dispose(va, 8) = -1LL;
                      }

                      else
                      {
                        *(void *)(v159 + 20_Block_object_dispose(va, 8) = v16;
                      }

                      *(_DWORD *)(a1 + 100) = *(_DWORD *)(a1 + 64);
                    }

LABEL_445:
                    uint64_t v160 = *(void *)(a1 + 12648);
                  }

                  else if (v864)
                  {
                    if (*(_BYTE *)(v159 + 8) != 2) {
                      goto LABEL_445;
                    }
                    goto LABEL_307;
                  }

                  uint64_t v159 = v160;
                  if (!v160) {
                    break;
                  }
                  continue;
                }
              }
            }

            uint64_t v23 = v858;
            if (v99) {
              goto LABEL_505;
            }
            uint64_t v291 = v911;
            if (v911 == 1)
            {
              char v16 = (void *)a10;
            }

            else
            {
              char v16 = (void *)a10;
              uint64_t v94 = v837;
              while (1)
              {
                unsigned int v292 = *(unsigned __int16 *)(v291 + 12);
                if (v292 <= 0x20)
                {
                  switch(*(_WORD *)(v291 + 12))
                  {
                    case 0xC:
                      goto LABEL_654;
                    case 0xD:
                    case 0xE:
                    case 0x10:
                    case 0x11:
                    case 0x13:
                    case 0x14:
                      goto LABEL_658;
                    case 0xF:
                    case 0x12:
                    case 0x15:
                      goto LABEL_648;
                    default:
                      if (v292 != 2 && v292 != 5) {
                        goto LABEL_658;
                      }
                      goto LABEL_654;
                  }
                }

                if (v292 == 33)
                {
                  v293 = (_BYTE *)(*(void *)(v291 + 48) + 10LL);
                  goto LABEL_656;
                }

                if (v292 == 36) {
                  break;
                }
                if (v292 == 39)
                {
LABEL_654:
                  v293 = (_BYTE *)(*(void *)(v291 + 48) + 4LL);
                  goto LABEL_656;
                }

LABEL_658:
                uint64_t v291 = *(void *)(v291 + 112);
                if (v291 == 1) {
                  goto LABEL_700;
                }
              }

LABEL_648:
              v293 = (_BYTE *)(*(void *)(v291 + 48) + 6LL);
LABEL_656:
              if (*(_DWORD *)(v291 + 28) != *((_DWORD *)v858 + 4)
                || !SameDomainNameBytes(v293, *((_BYTE **)v858 + 4)))
              {
                goto LABEL_658;
              }

              v301 = (os_log_s *)mDNSLogCategory_Default;
              if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
              {
                if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEBUG))
                {
                  v302 = DNSTypeName(*((unsigned __int16 *)v858 + 2));
                  uint64_t v303 = *((void *)v858 + 4);
                  if (v303)
                  {
                    v310 = (_BYTE *)*((void *)v858 + 4);
                    if (v303 == -256)
                    {
LABEL_707:
                      while (v310)
                      {
                        uint64_t v311 = *v310;
                        if (!*v310)
                        {
                          unsigned __int16 v316 = (_WORD)v310 - v303 + 1;
                          goto LABEL_732;
                        }

                        v310 += v311 + 1;
                        if (v303 != -256) {
                          goto LABEL_706;
                        }
                      }
                    }

                    else
                    {
LABEL_706:
                    }

                    unsigned __int16 v316 = 257;
LABEL_732:
                    int v317 = v316;
                  }

                  else
                  {
                    int v317 = 0;
                  }

LABEL_733:
                  GetRRDisplayString_rdb( (unsigned __int8 *)(v291 + 8),  (unsigned __int16 *)(*(void *)(v291 + 48) + 4LL),  v855);
                  *(_DWORD *)v961 = 141559555;
                  *(void *)&v961[4] = 1752392040LL;
                  *(_WORD *)&v961[12] = 2085;
                  *(void *)&v961[14] = v302;
                  *(_WORD *)&v961[22] = 2160;
                  *(void *)&v961[24] = 1752392040LL;
                  *(_WORD *)&v961[32] = 1040;
                  *(_DWORD *)&v961[34] = v317;
                  *(_WORD *)&v961[38] = 2101;
                  *(void *)&v961[40] = v303;
                  *(_WORD *)&v961[48] = 2160;
                  *(void *)&v961[50] = 1752392040LL;
                  *(_WORD *)&v961[58] = 2085;
                  *(void *)&v961[60] = v855;
                  _os_log_impl( (void *)&_mh_execute_header,  v301,  OS_LOG_TYPE_DEBUG,  "Found a matching entry in the CacheFlushRecords - new rrtype: %{sensitive, mask.hash}s, matched name : %{sensitive, mask.hash, mdnsresponder:domain_name}.*P, description: %{sensitive, mask.hash}s",  v961,  0x44u);
                  a1 = v878;
                  uint64_t v23 = v858;
                  uint32_t v98 = v904;
                }
              }

              else
              {
                v301 = (os_log_s *)mDNSLogCategory_Default_redacted;
                if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEBUG))
                {
                  v302 = DNSTypeName(*((unsigned __int16 *)v858 + 2));
                  uint64_t v303 = *((void *)v858 + 4);
                  if (v303)
                  {
                    v304 = (_BYTE *)*((void *)v858 + 4);
                    if (v303 == -256)
                    {
LABEL_681:
                      while (v304)
                      {
                        uint64_t v305 = *v304;
                        if (!*v304)
                        {
                          unsigned __int16 v315 = (_WORD)v304 - v303 + 1;
                          goto LABEL_730;
                        }

                        v304 += v305 + 1;
                        if (v303 != -256) {
                          goto LABEL_680;
                        }
                      }
                    }

                    else
                    {
LABEL_680:
                    }

                    unsigned __int16 v315 = 257;
LABEL_730:
                    int v317 = v315;
                  }

                  else
                  {
                    int v317 = 0;
                  }

                  goto LABEL_733;
                }
              }

LABEL_505:
              v238 = (_BYTE *)*((void *)v23 + 4);
              v239 = &v910;
              do
              {
                v239 = (char **)*v239;
                if (!v239) {
                  goto LABEL_525;
                }
              }

              while (!SameDomainNameBytes((_BYTE *)v239 + 20, v238));
              v240 = CacheGroupForName(a1, *((_DWORD *)v23 + 4), *((_BYTE **)v23 + 4));
              if (!v240)
              {
LABEL_525:
                uint64_t v845 = 0LL;
                char v16 = (void *)a10;
                goto LABEL_526;
              }

              uint64_t v845 = (uint64_t)v240;
              v241 = mDNSGetTSRForCacheGroup((uint64_t)v240);
              v242 = v241;
              if (!v241) {
                goto LABEL_753;
              }
              int v243 = CheckTSRForResourceRecord((int *)v239 + 2, (uint64_t)(v241 + 1));
              if (v243 != 2)
              {
                if (v243 == -1)
                {
                  v244 = (os_log_s *)mDNSLogCategory_mDNS;
                  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
                  {
                    if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
                    {
                      uint64_t v245 = *((void *)v858 + 4);
                      if (!v245)
                      {
                        int v318 = 0;
                        goto LABEL_740;
                      }

                      v312 = (_BYTE *)*((void *)v858 + 4);
                      if (v245 == -256) {
                        goto LABEL_718;
                      }
LABEL_715:
                      unsigned __int16 v313 = 257;
                      if ((unint64_t)v312 < v245 + 256 && v312)
                      {
                        do
                        {
                          uint64_t v314 = *v312;
                          if (!*v312)
                          {
                            unsigned __int16 v313 = (_WORD)v312 - v245 + 1;
                            goto LABEL_739;
                          }

                          v312 += v314 + 1;
                          if (v245 != -256) {
                            goto LABEL_715;
                          }
LABEL_718:
                          ;
                        }

                        while (v312);
                        unsigned __int16 v313 = 257;
                      }

LABEL_739:
                      int v318 = v313;
                      goto LABEL_740;
                    }
                  }

                  else
                  {
                    v244 = (os_log_s *)mDNSLogCategory_mDNS_redacted;
                    if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
                    {
                      uint64_t v245 = *((void *)v858 + 4);
                      if (v245)
                      {
                        v246 = (_BYTE *)*((void *)v858 + 4);
                        if (v245 == -256) {
                          goto LABEL_520;
                        }
LABEL_517:
                        unsigned __int16 v247 = 257;
                        if ((unint64_t)v246 < v245 + 256 && v246)
                        {
                          while (1)
                          {
                            uint64_t v248 = *v246;
                            if (v248 > 0x3F)
                            {
LABEL_734:
                              unsigned __int16 v247 = 257;
                              break;
                            }

                            if (!*v246)
                            {
                              unsigned __int16 v247 = (_WORD)v246 - v245 + 1;
                              break;
                            }

                            v246 += v248 + 1;
                            if (v245 != -256) {
                              goto LABEL_517;
                            }
LABEL_520:
                            if (!v246) {
                              goto LABEL_734;
                            }
                          }
                        }

                        int v318 = v247;
                      }

                      else
                      {
                        int v318 = 0;
                      }

LABEL_740:
                      v319 = DNSTypeName(*((unsigned __int16 *)v858 + 2));
                      *(_DWORD *)v961 = 141559043;
                      *(void *)&v961[4] = 1752392040LL;
                      *(_WORD *)&v961[12] = 1040;
                      *(_DWORD *)&v961[14] = v318;
                      *(_WORD *)&v961[18] = 2101;
                      *(void *)&v961[20] = v245;
                      *(_WORD *)&v961[28] = 2082;
                      *(void *)&v961[30] = v319;
                      *(_WORD *)&v961[38] = 1024;
                      *(_DWORD *)&v961[40] = a10;
                      _os_log_impl( (void *)&_mh_execute_header,  v244,  OS_LOG_TYPE_DEFAULT,  "mDNSCoreReceiveResponse - flushing cache group %{sensitive, mask.hash, mdnsresponder:domain_name }.*P type %{public}s on interface %d due to TSR conflict",  v961,  0x2Cu);
                      uint32_t v98 = v904;
                    }
                  }

                  uint64_t v320 = *(void *)(v845 + 16);
                  if (v320)
                  {
                    while (2)
                    {
                      if (*(_WORD *)(v320 + 12) != 41)
                      {
                        mDNS_PurgeCacheResourceRecord((unsigned int *)v878, v320);
                        v321 = (os_log_s *)mDNSLogCategory_mDNS;
                        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
                        {
                          if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
                            goto LABEL_751;
                          }
                        }

                        else
                        {
                          v321 = (os_log_s *)mDNSLogCategory_mDNS_redacted;
                          if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
                          {
LABEL_751:
                            uint64_t v324 = *(void *)(v320 + 32);
                            GetRRDisplayString_rdb( (unsigned __int8 *)(v320 + 8),  (unsigned __int16 *)(*(void *)(v320 + 48) + 4LL),  v855);
                            *(_DWORD *)v961 = 67109635;
                            *(_DWORD *)&v961[4] = v324;
                            uint32_t v98 = v904;
                            *(_WORD *)&v961[8] = 2160;
                            *(void *)&v961[10] = 1752392040LL;
                            *(_WORD *)&v961[18] = 2085;
                            *(void *)&v961[20] = v855;
                            LOBYTE(v25) = v868;
                            _os_log_impl( (void *)&_mh_execute_header,  v321,  OS_LOG_TYPE_DEFAULT,  "mDNSCoreReceiveResponse - flushed interface %d %{sensitive, mask.hash}s",  v961,  0x1Cu);
                          }
                        }
                      }

                      uint64_t v320 = *(void *)v320;
                      if (!v320) {
                        break;
                      }
                      continue;
                    }
                  }
                }

LABEL_753:
                unsigned int v325 = *((_DWORD *)v239 + 2);
                if (v325 < 0x93A81)
                {
                  unsigned int v326 = *((_DWORD *)v858 + 2);
                  *(void *)&v961[8] = 0LL;
                  *(void *)v961 = 0LL;
                  clock_gettime(_CLOCK_MONOTONIC_RAW, (timespec *)v961);
                  int v332 = *(_DWORD *)v961;
                  uint64_t v333 = (uint64_t)v242;
                  if (v242) {
                    goto LABEL_757;
                  }
                  uint64_t CacheEntity = GetCacheEntity(v878, (void *)v845, v327, v328, v329, v330, v331, v108);
                  if (CacheEntity)
                  {
                    uint64_t v333 = CacheEntity;
                    *(void *)(CacheEntity + 4_Block_object_dispose(va, 8) = CacheEntity + 152;
                    *(_DWORD *)(CacheEntity + 12) = 94371881;
                    *(void *)(CacheEntity + 40) = *(void *)(v845 + 32);
                    int v335 = *(_DWORD *)(v845 + 8);
                    *(_DWORD *)(CacheEntity + 20) = 917518;
                    *(_DWORD *)(CacheEntity + 24) = v335;
                    AddCacheRecordToCacheGroup(v845, (void *)CacheEntity);
LABEL_757:
                    int v336 = v332 - v325;
                    a1 = v878;
                    *(_DWORD *)(v333 + 80) = *(_DWORD *)(v878 + 64);
                    unsigned int v337 = *(_DWORD *)(v333 + 16);
                    if (v337 <= v326) {
                      unsigned int v337 = v326;
                    }
                    *(_DWORD *)(v333 + 16) = v337;
                    uint64_t v338 = *(void *)(v333 + 48);
                    a3 = v870;
                    if (v242 && v336 - *(_DWORD *)(v338 + 8) < 1)
                    {
                      char v16 = (void *)a10;
                      uint64_t v23 = v858;
                      unsigned int v113 = v883;
                      uint32_t v98 = v904;
                    }

                    else
                    {
                      *(_DWORD *)(v338 + 4) = 720362;
                      *(_DWORD *)(v338 + _Block_object_dispose(va, 8) = v336;
                      *(_DWORD *)(v338 + 12) = *((_DWORD *)v239 + 3);
                      *(_WORD *)(v338 + 16) = 0;
                      v339 = (os_log_s *)mDNSLogCategory_Default;
                      uint32_t v98 = v904;
                      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
                      {
                        if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEBUG))
                        {
                          if (v242) {
                            v340 = "Updated";
                          }
                          else {
                            v340 = "Added";
                          }
LABEL_794:
                          GetRRDisplayString_rdb( (unsigned __int8 *)(v333 + 8),  (unsigned __int16 *)(*(void *)(v333 + 48) + 4LL),  v855);
                          *(_DWORD *)v961 = 136315651;
                          *(void *)&v961[4] = v340;
                          *(_WORD *)&v961[12] = 2160;
                          *(void *)&v961[14] = 1752392040LL;
                          *(_WORD *)&v961[22] = 2085;
                          *(void *)&v961[24] = v855;
                          _os_log_impl( (void *)&_mh_execute_header,  v339,  OS_LOG_TYPE_DEBUG,  "AddOrUpdateTSRForCacheGroup: %s TSR %{sensitive, mask.hash}s",  v961,  0x20u);
                        }
                      }

                      else
                      {
                        v339 = (os_log_s *)mDNSLogCategory_Default_redacted;
                        if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEBUG))
                        {
                          if (v242) {
                            v340 = "Updated";
                          }
                          else {
                            v340 = "Added";
                          }
                          goto LABEL_794;
                        }
                      }

                      a1 = v878;
                      char v16 = (void *)a10;
                      uint64_t v23 = v858;
LABEL_526:
                      unsigned int v113 = v883;
                    }
                  }

                  else
                  {
                    v348 = (os_log_s *)mDNSLogCategory_Default;
                    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
                    {
                      a1 = v878;
                      a3 = v870;
                      char v16 = (void *)a10;
                      uint64_t v23 = v858;
                      unsigned int v113 = v883;
                      uint32_t v98 = v904;
                      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_ERROR)) {
                        goto LABEL_527;
                      }
                      uint64_t v349 = *(void *)(v845 + 32);
                      if (v349)
                      {
                        v350 = *(_BYTE **)(v845 + 32);
                        if (v349 == -256)
                        {
LABEL_816:
                          while (v350)
                          {
                            uint64_t v352 = *v350;
                            if (!*v350)
                            {
                              LOWORD(v350) = (_WORD)v350 - v349 + 1;
                              goto LABEL_852;
                            }

                            v350 += v352 + 1;
                            if (v349 != -256) {
                              goto LABEL_815;
                            }
                          }
                        }

                        else
                        {
LABEL_815:
                        }

                        LOWORD(v350) = 257;
LABEL_852:
                        LODWORD(v350) = (unsigned __int16)v350;
                      }

                      else
                      {
                        LODWORD(v350) = 0;
                      }
                    }

                    else
                    {
                      v348 = (os_log_s *)mDNSLogCategory_Default_redacted;
                      a1 = v878;
                      a3 = v870;
                      char v16 = (void *)a10;
                      uint64_t v23 = v858;
                      unsigned int v113 = v883;
                      uint32_t v98 = v904;
                      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_ERROR)) {
                        goto LABEL_527;
                      }
                      uint64_t v349 = *(void *)(v845 + 32);
                      if (v349)
                      {
                        v350 = *(_BYTE **)(v845 + 32);
                        if (v349 == -256)
                        {
LABEL_803:
                          while (v350)
                          {
                            uint64_t v351 = *v350;
                            if (!*v350)
                            {
                              LOWORD(v350) = (_WORD)v350 - v349 + 1;
                              goto LABEL_850;
                            }

                            v350 += v351 + 1;
                            if (v349 != -256) {
                              goto LABEL_802;
                            }
                          }
                        }

                        else
                        {
LABEL_802:
                        }

                        LOWORD(v350) = 257;
LABEL_850:
                        LODWORD(v350) = (unsigned __int16)v350;
                      }

                      else
                      {
                        LODWORD(v350) = 0;
                      }
                    }

                    *(_DWORD *)v961 = 141558531;
                    *(void *)&v961[4] = 1752392040LL;
                    *(_WORD *)&v961[12] = 1040;
                    *(_DWORD *)&v961[14] = (_DWORD)v350;
                    *(_WORD *)&v961[18] = 2101;
                    *(void *)&v961[20] = v349;
                    _os_log_impl( (void *)&_mh_execute_header,  v348,  OS_LOG_TYPE_ERROR,  "AddOrUpdateTSRForCacheGroup: No cache record for new TSR %{sensitive, mask.hash, mdnsresponder:domain_name}.*P",  v961,  0x1Cu);
                  }

LABEL_527:
                  uint64_t v94 = v837;
                  if (!*(_DWORD *)(a1 + 248)) {
                    goto LABEL_701;
                  }
                  unsigned int v249 = *((_DWORD *)v23 + 4);
                  unsigned int v842 = v249 % 0x1F3;
                  v250 = (uint64_t *)v845;
                  if (v845 || (v250 = CacheGroupForName(a1, v249, *((_BYTE **)v23 + 4))) != 0LL)
                  {
                    uint64_t v846 = (uint64_t)v250;
                    v251 = (int8x8_t *)(v250 + 2);
                    v252 = (int8x8_t *)v250[2];
                    if (v252)
                    {
                      v253 = (_DWORD *)(a1 + 4LL * v842 + 4272);
                      while (1)
                      {
                        uint64_t v254 = *((void *)v858 + 6);
                        if (!v16
                          || v254 && (uint64_t v255 = *(void *)(v254 + 24)) != 0 && (*(_WORD *)(v255 + 276) & 0x6000) == 0x2000)
                        {
                          int8x8_t v256 = v252[7];
                          if (v256) {
                            int8x8_t v256 = *(int8x8_t *)(*(void *)&v256 + 24LL);
                          }
                          if (v254) {
                            uint64_t v254 = *(void *)(v254 + 24);
                          }
                          if (*(void *)&v256 != v254) {
                            goto LABEL_634;
                          }
                        }

                        else if ((void *)v252[4] != v16)
                        {
                          goto LABEL_634;
                        }

                        v257 = v252 + 1;
                        uint64_t v258 = *((void *)v858 + 7);
                        uint64_t v259 = (uint64_t)v252[8];
                        if (resource_records_have_same_dnssec_rr_category(v258, v259)
                          && *((unsigned __int16 *)v858 + 2) == v252[1].u16[2]
                          && *((unsigned __int16 *)v858 + 3) == v252[1].u16[3]
                          && *((unsigned __int16 *)v858 + 6) == v252[2].u16[2]
                          && *((_DWORD *)v858 + 5) == v252[3].i32[1])
                        {
                          if (SameRDataBody( (uint64_t)v858,  (unsigned __int16 *)(*(void *)&v252[6] + 4LL),  (uint64_t (*)(uint64_t, unsigned __int16 *))SameDomainName))
                          {
                            v822 = v253;
                            unsigned __int8 v265 = *v858;
                            if ((*v858 & 0x10) != 0)
                            {
                              a1 = v878;
                              uint32_t v98 = v904;
                              v266 = v833;
                              if (!*(void *)&v252[14] && v833 != &v252[14])
                              {
                                int8x8_t *v833 = (int8x8_t)v252;
                                v252[14] = (int8x8_t)1LL;
                                v266 = v252 + 14;
                              }

                              if ((v257->i8[0] & 0x10) == 0)
                              {
                                uint64_t v275 = *(void *)(v878 + 200);
                                if (v275)
                                {
                                  do
                                  {
                                    uint64_t v275 = *(void *)(v275 + 8);
                                  }

                                  while (v275);
                                  unsigned __int8 v265 = *v858;
                                }

                                v257->i8[0] = v265;
                              }
                            }

                            else
                            {
                              a1 = v878;
                              uint32_t v98 = v904;
                              v266 = v833;
                            }

                            v833 = v266;
                            if (!SameRDataBody( (uint64_t)v858,  (unsigned __int16 *)(*(void *)&v252[6] + 4LL),  (uint64_t (*)(uint64_t, unsigned __int16 *))SameDomainNameCS))
                            {
                              v252[2].i32[0] = 0;
                              v252[10].i32[0] = *(_DWORD *)(a1 + 64);
                              v252[13].i8[4] = 4;
                              SetNextCacheCheckTimeForRecord(a1, (uint64_t)v252);
                              v276 = (os_log_s *)mDNSLogCategory_Default;
                              if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
                              {
                                v253 = v822;
                                if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
                                  goto LABEL_591;
                                }
                              }

                              else
                              {
                                v276 = (os_log_s *)mDNSLogCategory_Default_redacted;
                                v253 = v822;
                                if (os_log_type_enabled( (os_log_t)mDNSLogCategory_Default_redacted,  OS_LOG_TYPE_DEFAULT))
                                {
LABEL_591:
                                  GetRRDisplayString_rdb( (unsigned __int8 *)&v252[1],  (unsigned __int16 *)(*(void *)&v252[6] + 4LL),  v855);
                                  *(_DWORD *)v961 = 141558275;
                                  *(void *)&v961[4] = 1752392040LL;
                                  *(_WORD *)&v961[12] = 2085;
                                  *(void *)&v961[14] = v855;
                                  _os_log_impl( (void *)&_mh_execute_header,  v276,  OS_LOG_TYPE_DEFAULT,  "mDNSCoreReceiveCacheCheck: Discarding due to domainname case change old: %{sensitive, mask.hash}s",  v961,  0x16u);
                                }
                              }

                              v277 = (os_log_s *)mDNSLogCategory_Default;
                              if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
                              {
                                char v16 = (void *)a10;
                                if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
                                  goto LABEL_597;
                                }
                              }

                              else
                              {
                                v277 = (os_log_s *)mDNSLogCategory_Default_redacted;
                                char v16 = (void *)a10;
                                if (os_log_type_enabled( (os_log_t)mDNSLogCategory_Default_redacted,  OS_LOG_TYPE_DEFAULT))
                                {
LABEL_597:
                                  GetRRDisplayString_rdb(v858, (unsigned __int16 *)(*((void *)v858 + 5) + 4LL), v855);
                                  *(_DWORD *)v961 = 141558275;
                                  *(void *)&v961[4] = 1752392040LL;
                                  *(_WORD *)&v961[12] = 2085;
                                  *(void *)&v961[14] = v855;
                                  LOBYTE(v25) = v868;
                                  _os_log_impl( (void *)&_mh_execute_header,  v277,  OS_LOG_TYPE_DEFAULT,  "mDNSCoreReceiveCacheCheck: Discarding due to domainname case change new: %{sensitive, mask.hash}s",  v961,  0x16u);
                                }
                              }

                              v278 = (os_log_s *)mDNSLogCategory_Default;
                              if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
                              {
                                if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
                                  goto LABEL_633;
                                }
                                if (v252[12])
                                {
                                  unsigned int v281 = v252[2].u32[0];
                                  if (v252[13].u8[4] > 3u)
                                  {
                                    if (v281 <= 0xA)
                                    {
                                      if (v281) {
                                        int v280 = 100;
                                      }
                                      else {
                                        int v280 = 0;
                                      }
                                    }

                                    else
                                    {
                                      int v280 = 1000;
                                    }
                                  }

                                  else
                                  {
                                    int v280 = (int)(1000 * v281) / 50;
                                  }
                                }

                                else
                                {
                                  int v280 = 60000;
                                }
                              }

                              else
                              {
                                v278 = (os_log_s *)mDNSLogCategory_Default_redacted;
                                if (!os_log_type_enabled( (os_log_t)mDNSLogCategory_Default_redacted,  OS_LOG_TYPE_DEFAULT)) {
                                  goto LABEL_633;
                                }
                                if (v252[12])
                                {
                                  unsigned int v279 = v252[2].u32[0];
                                  if (v252[13].u8[4] > 3u)
                                  {
                                    if (v279 <= 0xA)
                                    {
                                      if (v279) {
                                        int v280 = 100;
                                      }
                                      else {
                                        int v280 = 0;
                                      }
                                    }

                                    else
                                    {
                                      int v280 = 1000;
                                    }
                                  }

                                  else
                                  {
                                    int v280 = (int)(1000 * v279) / 50;
                                  }
                                }

                                else
                                {
                                  int v280 = 60000;
                                }
                              }

                              int v285 = *(_DWORD *)(a1 + 64);
                              int v286 = v280 + v252[11].i32[0] - v285;
                              int v287 = *v253 - v285;
                              int v288 = *(_DWORD *)(a1 + 88) - v285;
                              *(_DWORD *)v961 = 67109888;
                              *(_DWORD *)&v961[4] = v286;
                              *(_WORD *)&v961[8] = 1024;
                              *(_DWORD *)&v961[10] = v842;
                              *(_WORD *)&v961[14] = 1024;
                              *(_DWORD *)&v961[16] = v287;
                              *(_WORD *)&v961[20] = 1024;
                              *(_DWORD *)&v961[22] = v288;
                              _os_log_impl( (void *)&_mh_execute_header,  v278,  OS_LOG_TYPE_DEFAULT,  "mDNSCoreReceiveCacheCheck: Discarding due to domainname case change in %d slot %3d in %d %d",  v961,  0x1Au);
                              goto LABEL_633;
                            }

                            __int32 v353 = *((_DWORD *)v858 + 2);
                            if (v353)
                            {
                              ++v827[19];
                              a3 = v870;
                              if (v252[1].i8[2] == 2 && !v252[10].i32[1])
                              {
                                unsigned int v354 = *(_DWORD *)(a1 + 64);
                                if (v354 <= 1) {
                                  unsigned int v354 = 1;
                                }
                                v252[10].i32[1] = v354;
                              }

                              if (v353 == 4500 && v252[2].i32[0] == 4500)
                              {
                                if ((int8x8_t v355 = v252[4], AWDLInterfaceID) && AWDLInterfaceID == *(void *)&v355
                                  || WiFiAwareInterfaceID && WiFiAwareInterfaceID == *(void *)&v355)
                                {
                                  int v356 = v252[1].u16[2];
                                  if (v356 == 33 || v356 == 28)
                                  {
                                    v357 = (os_log_s *)mDNSLogCategory_Default;
                                    if (gSensitiveLoggingEnabled != 1
                                      || mDNSLogCategory_Default == mDNSLogCategory_State)
                                    {
                                      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
                                        goto LABEL_870;
                                      }
                                    }

                                    else
                                    {
                                      v357 = (os_log_s *)mDNSLogCategory_Default_redacted;
                                      if (os_log_type_enabled( (os_log_t)mDNSLogCategory_Default_redacted,  OS_LOG_TYPE_DEFAULT))
                                      {
LABEL_870:
                                        GetRRDisplayString_rdb( (unsigned __int8 *)&v252[1],  (unsigned __int16 *)(*(void *)&v252[6] + 4LL),  v855);
                                        int8x8_t v370 = v252[4];
                                        *(_DWORD *)v961 = 141558531;
                                        *(void *)&v961[4] = 1752392040LL;
                                        *(_WORD *)&v961[12] = 2085;
                                        *(void *)&v961[14] = v855;
                                        LOBYTE(v25) = v868;
                                        *(_WORD *)&v961[22] = 2048;
                                        *(int8x8_t *)&v961[24] = v370;
                                        _os_log_impl( (void *)&_mh_execute_header,  v357,  OS_LOG_TYPE_DEFAULT,  "mDNSCoreReceiveCacheCheck: Keeping Standard TTL for %{sensitive, mask.hash}s %p",  v961,  0x20u);
                                      }
                                    }
                                  }
                                }
                              }

                              a1 = v878;
                              RefreshCacheRecord(v878, v252, v353);
                              char v16 = (void *)a10;
                              if (*(int8x8_t **)(v846 + 24) != v252)
                              {
                                while (1)
                                {
                                  v376 = v251;
                                  v251 = (int8x8_t *)*v251;
                                  if (!v251) {
                                    break;
                                  }
                                  if (v251 == v252)
                                  {
                                    int8x8_t *v376 = *v252;
                                    break;
                                  }
                                }

                                int8x8_t *v252 = 0LL;
                                AddCacheRecordToCacheGroup(v846, v252);
                              }

                              __int16 v377 = *((_WORD *)a2 + 1);
                              v252[13].i16[3] = v377;
                              v252[1].i8[1] = HIBYTE(v377) & 0xF;
                              if (a10)
                              {
LABEL_877:
                                if ((v257->i8[0] & 0x10) == 0)
                                {
                                  char v300 = 0;
                                  goto LABEL_895;
                                }

                                uint64_t v378 = *(void *)(v878 + 200);
                                if (v378)
                                {
                                  while (*(void *)(v378 + 40)
                                       || *(_BYTE *)(v378 + 612)
                                       || *(int *)(v378 + 212) < 1
                                       || !RecordAnswersQuestion( (uint64_t)&v252[1],  0,  v378,  v371,  v372,  v373,  v374,  v375))
                                  {
                                    uint64_t v378 = *(void *)(v378 + 8);
                                    if (!v378) {
                                      goto LABEL_885;
                                    }
                                  }

                                  int v385 = *(_DWORD *)(v878 + 64);
                                  *(_DWORD *)(v378 + 256) = v385;
                                  *(_DWORD *)(v378 + 224) = 0;
                                  *(_DWORD *)(v378 + 20_Block_object_dispose(va, 8) = v385;
                                  *(_DWORD *)(v378 + 212) = 3600000;
                                  *(_BYTE *)(v378 + 332) = 0;
                                  *(_BYTE *)(v378 + 62_Block_object_dispose(va, 8) = 0;
LABEL_885:
                                  uint64_t v94 = v837;
                                  char v300 = 0;
                                  char v16 = (void *)a10;
                                  goto LABEL_673;
                                }

                                char v300 = 0;
LABEL_894:
                                char v16 = (void *)a10;
LABEL_895:
                                uint64_t v94 = v837;
LABEL_673:
                                if (v896 || !v252[2].i32[0] || v862 == 100 || v875 == 100) {
                                  goto LABEL_674;
                                }
                                v252[16].i8[0] = 1;
                                v917[v862] = v252;
                                if (v875)
                                {
                                  v306 = v916;
                                  uint64_t v307 = v875;
                                  while (!RecordInTheRRSet((uint64_t)&v252[1], (uint64_t)v306))
                                  {
                                    v306 += 3;
                                    if (!--v307) {
                                      goto LABEL_693;
                                    }
                                  }
                                }

                                else
                                {
LABEL_693:
                                  v306 = &v916[3 * v875];
                                  void *v306 = v252[5];
                                  *((_DWORD *)v306 + 2) = v252[3].i32[0];
                                  int v308 = v252[1].u16[2];
                                  if (v308 == 46) {
                                    LOWORD(v30_Block_object_dispose(va, 8) = resource_record_as_rrsig_get_covered_type((uint64_t)&v252[1]);
                                  }
                                  v309 = &v916[3 * v875];
                                  *((_WORD *)v309 + _Block_object_dispose(va, 8) = v308;
                                  ++v875;
                                  *((_DWORD *)v309 + 3) = 0;
                                  *((_BYTE *)v309 + 1_Block_object_dispose(va, 8) = 0;
                                }

                                a1 = v878;
                                uint64_t v23 = v858;
                                ++v862;
                                ++*((_DWORD *)v306 + 3);
                                *((_BYTE *)v306 + 1_Block_object_dispose(va, 8) = v300;
                                char v16 = (void *)a10;
                                uint64_t v94 = v837;
                                unsigned int v113 = v883;
                                uint32_t v98 = v904;
LABEL_701:
                                *(_WORD *)uint64_t v23 = 0;
                                *((_WORD *)v23 + 51) = 0;
                                uint64_t v112 = (void *)*((void *)v23 + 7);
                                if (v112) {
                                  goto LABEL_205;
                                }
LABEL_206:
                                v836 = v94;
                                __int128 v29 = v910;
                                unsigned int v91 = v875;
                                char v90 = v859;
LABEL_908:
                                char v860 = v90;
                                unsigned int v875 = v91;
                                if (v29)
                                {
                                  do
                                  {
                                    v387 = *(char **)v29;
                                    free(v29);
                                    __int128 v29 = v387;
                                  }

                                  while (v387);
                                  v910 = 0LL;
                                }

                                if (!v896)
                                {
                                  if (v862 == 100 || v875 == 100)
                                  {
                                    v388 = (os_log_s *)mDNSLogCategory_Default;
                                    if (gSensitiveLoggingEnabled != 1
                                      || mDNSLogCategory_Default == mDNSLogCategory_State)
                                    {
                                      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_FAULT)) {
                                        goto LABEL_931;
                                      }
                                    }

                                    else
                                    {
                                      v388 = (os_log_s *)mDNSLogCategory_Default_redacted;
                                      if (os_log_type_enabled( (os_log_t)mDNSLogCategory_Default_redacted,  OS_LOG_TYPE_FAULT))
                                      {
LABEL_931:
                                        *(_DWORD *)v961 = 67109376;
                                        *(_DWORD *)&v961[4] = v862;
                                        *(_WORD *)&v961[8] = 1024;
                                        *(_DWORD *)&v961[10] = v875;
                                        _os_log_impl( (void *)&_mh_execute_header,  v388,  OS_LOG_TYPE_FAULT,  "Too many records contained in a single response - cached records: %u, record set: %u",  v961,  0xEu);
                                      }
                                    }
                                  }

                                  if (v862)
                                  {
                                    for (uint64_t k = 0LL; k != v862; ++k)
                                    {
                                      uint64_t v396 = v917[k];
                                      if (v875)
                                      {
                                        uint64_t v397 = 0LL;
                                        v398 = v916;
                                        while (!RecordInTheRRSet(v396 + 8, (uint64_t)v398))
                                        {
                                          ++v397;
                                          v398 += 3;
                                          if (v875 == v397) {
                                            goto LABEL_938;
                                          }
                                        }

                                        uint64_t v409 = *(void *)(v396 + 64);
                                        if (v409)
                                        {
                                          v410 = &v916[3 * v397];
                                          *(void *)(v409 + 24) = *((unsigned int *)v410 + 3);
                                          *(_BYTE *)(v409 + 36) = *((_BYTE *)v410 + 18) != 0;
                                        }
                                      }

                                      else
                                      {
LABEL_938:
                                        v399 = (os_log_s *)mDNSLogCategory_Default;
                                        if (gSensitiveLoggingEnabled == 1
                                          && mDNSLogCategory_Default != mDNSLogCategory_State)
                                        {
                                          v399 = (os_log_s *)mDNSLogCategory_Default_redacted;
                                          if (!os_log_type_enabled( (os_log_t)mDNSLogCategory_Default_redacted,  OS_LOG_TYPE_FAULT)) {
                                            continue;
                                          }
                                          uint64_t v401 = *(void *)(v396 + 40);
                                          if (v401)
                                          {
                                            v406 = *(_BYTE **)(v396 + 40);
                                            if (v401 == -256) {
                                              goto LABEL_960;
                                            }
LABEL_957:
                                            unsigned __int16 v407 = 257;
                                            if ((unint64_t)v406 < v401 + 256 && v406)
                                            {
                                              while (1)
                                              {
                                                uint64_t v408 = *v406;
                                                if (v408 > 0x3F)
                                                {
LABEL_970:
                                                  unsigned __int16 v407 = 257;
                                                  goto LABEL_974;
                                                }

                                                if (!*v406) {
                                                  break;
                                                }
                                                v406 += v408 + 1;
                                                if (v401 != -256) {
                                                  goto LABEL_957;
                                                }
LABEL_960:
                                                if (!v406) {
                                                  goto LABEL_970;
                                                }
                                              }

                                              unsigned __int16 v407 = (_WORD)v406 - v401 + 1;
                                            }

LABEL_974:
                                            int v411 = v407;
                                          }

                                          else
                                          {
                                            int v411 = 0;
                                          }

                                          goto LABEL_975;
                                        }

                                        if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_FAULT))
                                        {
                                          uint64_t v401 = *(void *)(v396 + 40);
                                          if (v401)
                                          {
                                            v402 = *(_BYTE **)(v396 + 40);
                                            if (v401 == -256) {
                                              goto LABEL_949;
                                            }
LABEL_946:
                                            unsigned __int16 v403 = 257;
                                            if ((unint64_t)v402 < v401 + 256 && v402)
                                            {
                                              while (1)
                                              {
                                                uint64_t v404 = *v402;
                                                if (v404 > 0x3F)
                                                {
LABEL_969:
                                                  unsigned __int16 v403 = 257;
                                                  goto LABEL_972;
                                                }

                                                if (!*v402) {
                                                  break;
                                                }
                                                v402 += v404 + 1;
                                                if (v401 != -256) {
                                                  goto LABEL_946;
                                                }
LABEL_949:
                                                if (!v402) {
                                                  goto LABEL_969;
                                                }
                                              }

                                              unsigned __int16 v403 = (_WORD)v402 - v401 + 1;
                                            }

LABEL_972:
                                            int v411 = v403;
                                          }

                                          else
                                          {
                                            int v411 = 0;
                                          }

  if (v44) {
    free(v44);
  }
LABEL_974:
  unsigned __int16 v503 = *(void *)(a3 + 24);
  v504 = v503 + 5;
  v505 = strlen(__s);
  uint64_t v510 = *(unsigned __int16 *)(a3 + 12);
  v511 = v505 + v510 + 23;
  if (!*(_BYTE *)(a7 + 274))
  {
    uint64_t v513 = 0LL;
LABEL_1016:
    uint64_t v520 = 0LL;
    int v512 = 0;
    goto LABEL_1017;
  }

  int v512 = 0;
  uint64_t v513 = 0LL;
  if (!v620
    || (int v514 = *(void *)(a7 + 48)) == 0
    || (int v512 = 0, v513 = 0LL, v515 = *(unsigned __int16 *)(a3 + 4), v515 > 0x1C)
    || ((1 << v515) & 0x10010002) == 0)
  {
    uint64_t v520 = 0LL;
    goto LABEL_1017;
  }

  unint64_t v622 = 0;
  if (v515 != 28)
  {
    if (v515 == 16)
    {
      if (*(_UNKNOWN ***)(v514 + 16) != &_mdns_signed_browse_result_kind)
      {
        int v516 = (os_log_s *)mDNSLogCategory_Default;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
        {
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_ERROR)) {
            goto LABEL_1009;
          }
        }

        else
        {
          int v516 = (os_log_s *)mDNSLogCategory_Default_redacted;
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_ERROR)) {
            goto LABEL_1009;
          }
        }

        uint64_t v522 = *(_DWORD *)(a7 + 184);
        unsigned __int16 v523 = bswap32(*(unsigned __int16 *)(a2 + 320)) >> 16;
        LODWORD(buf.tv_sec) = 67109376;
        HIDWORD(buf.tv_sec) = v522;
        LOWORD(buf.tv_nsec) = 1024;
        *(_DWORD *)((char *)&buf.tv_nsec + 2) = v523;
        v519 = "[R%u->Q%u] queryrecord_result_reply mdns_signed_browse_result_downcast failed";
        goto LABEL_1004;
      }

      unsigned __int16 v521 = _mdns_signed_browse_result_create_ex( (const unsigned __int8 *)(*(void *)(v514 + 32) + 32LL),  *(unsigned __int8 **)(v514 + 24),  v503,  (unsigned __int8 *)(*(void *)(a3 + 40) + 4LL),  v510,  &v622);
      goto LABEL_1006;
    }

    if (v515 != 1) {
      goto LABEL_1009;
    }
  }

  if (*(_UNKNOWN ***)(v514 + 16) != &_mdns_signed_resolve_result_kind)
  {
    int v516 = (os_log_s *)mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_ERROR)) {
        goto LABEL_989;
      }
    }

    else
    {
      int v516 = (os_log_s *)mDNSLogCategory_Default_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_ERROR))
      {
LABEL_989:
        uint64_t v517 = *(_DWORD *)(a7 + 184);
        v518 = bswap32(*(unsigned __int16 *)(a2 + 320)) >> 16;
        LODWORD(buf.tv_sec) = 67109376;
        HIDWORD(buf.tv_sec) = v517;
        LOWORD(buf.tv_nsec) = 1024;
        *(_DWORD *)((char *)&buf.tv_nsec + 2) = v518;
        v519 = "[R%u->Q%u] queryrecord_result_reply mdns_signed_resolve_result_downcast failed";
LABEL_1004:
        _os_log_impl((void *)&_mh_execute_header, v516, OS_LOG_TYPE_ERROR, v519, (uint8_t *)&buf, 0xEu);
      }
    }

LABEL_975:
                                          v412 = DNSTypeName(*(unsigned __int16 *)(v396 + 12));
                                          *(_DWORD *)v961 = 141559043;
                                          *(void *)&v961[4] = 1752392040LL;
                                          *(_WORD *)&v961[12] = 1040;
                                          *(_DWORD *)&v961[14] = v411;
                                          *(_WORD *)&v961[18] = 2101;
                                          *(void *)&v961[20] = v401;
                                          *(_WORD *)&v961[28] = 2160;
                                          *(void *)&v961[30] = 1752392040LL;
                                          *(_WORD *)&v961[38] = 2085;
                                          *(void *)&v961[40] = v412;
                                          _os_log_impl( (void *)&_mh_execute_header,  v399,  OS_LOG_TYPE_FAULT,  "Answer set counter not found for the cached record - name: %{sensitive, mask .hash, mdnsresponder:domain_name}.*P, rrtype: %{sensitive, mask.hash}s.",  v961,  0x30u);
                                        }
                                      }
                                    }
                                  }
                                }

                                if (v860)
                                {
                                  char v16 = (void *)a10;
                                  a3 = v870;
                                  a2 = v900;
                                  DumpPacket( 0,  0,  (uint64_t)"N/A",  v848,  (unsigned __int16)a5,  __src,  a7,  v900,  v870,  a10);
                                  a1 = v878;
                                }

                                else
                                {
                                  a1 = v878;
                                  a2 = v900;
                                  a3 = v870;
                                  char v16 = (void *)a10;
                                }

                                uint64_t v386 = v906;
                                uint64_t v23 = v858;
                                uint64_t v94 = v836;
LABEL_981:
                                *(_WORD *)uint64_t v23 = 0;
                                *((_WORD *)v23 + 51) = 0;
                                v413 = (void *)*((void *)v23 + 7);
                                if (v413)
                                {
                                  ref_count_obj_release(v413);
                                  *((void *)v23 + 7) = 0LL;
                                }

                                uint64_t v414 = v911;
                                v838 = v94;
                                if (v911 != 1)
                                {
                                  v908 = (_BYTE *)(a1 + 46976);
                                  unsigned int v893 = bswap32(a5) >> 16;
                                  while (1)
                                  {
                                    unsigned int v415 = *(_DWORD *)(v414 + 24);
                                    v416 = CacheGroupForName(a1, v415, *(_BYTE **)(v414 + 40));
                                    uint64_t v911 = *(void *)(v911 + 112);
                                    *(void *)(v414 + 112) = 0LL;
                                    if (v416)
                                    {
                                      uint64_t v423 = v416[2];
                                      if (v423 && v901 == 0) {
                                        break;
                                      }
                                    }

                                    int v425 = 0;
LABEL_991:
                                    uint64_t v386 = v906;
                                    if (!*(_DWORD *)(v414 + 84)) {
                                      goto LABEL_1110;
                                    }
                                    if (*(void *)(v414 + 32))
                                    {
                                      int v426 = CheckForSoonToExpireRecordsEx( a1,  *(_BYTE **)(v414 + 40),  *(_DWORD *)(v414 + 24),  -1,  -1);
                                      *(_DWORD *)(v414 + 84) = v426;
                                      if (v426) {
                                        goto LABEL_1104;
                                      }
                                    }

                                    else
                                    {
                                      char v462 = v887;
                                      if (v425) {
                                        char v462 = 1;
                                      }
                                      if ((v462 & 1) != 0)
                                      {
                                        if (*(_DWORD *)(a1 + 64) <= 1u) {
                                          int v426 = 1;
                                        }
                                        else {
                                          int v426 = *(_DWORD *)(a1 + 64);
                                        }
                                        *(_DWORD *)(v414 + 84) = v426;
LABEL_1104:
                                        uint64_t v463 = a1 + 4LL * (v415 % 0x1F3);
                                        if (*(_DWORD *)(v463 + 4272) - v426 >= 1) {
                                          *(_DWORD *)(v463 + 4272) = v426;
                                        }
                                        if (*(_DWORD *)(a1 + 88) - v426 >= 1) {
                                          *(_DWORD *)(a1 + 8_Block_object_dispose(va, 8) = v426;
                                        }
                                        goto LABEL_1110;
                                      }

                                      *(_DWORD *)(v414 + 84) = 0;
                                    }

                                    CacheRecordDeferredAdd((void *)a1, v414, v417, v418, v419, v420, v421, v422);
LABEL_1110:
                                    uint64_t v414 = v911;
                                    a3 = v870;
                                    if (v911 == 1) {
                                      goto LABEL_1111;
                                    }
                                  }

                                  int v425 = 0;
                                  while (2)
                                  {
                                    if (*(_BYTE *)(v423 + 109)) {
                                      goto LABEL_998;
                                    }
                                    uint64_t v427 = *(void *)(v414 + 32);
                                    if (v427 != *(void *)(v423 + 32)) {
                                      goto LABEL_998;
                                    }
                                    if (!v427)
                                    {
                                      uint64_t v434 = *(void *)(v414 + 56);
                                      if (v434) {
                                        uint64_t v434 = *(void *)(v434 + 24);
                                      }
                                      uint64_t v435 = *(void *)(v423 + 56);
                                      if (v435) {
                                        uint64_t v435 = *(void *)(v435 + 24);
                                      }
                                      if (v434 != v435) {
                                        goto LABEL_998;
                                      }
                                    }

                                    int v428 = *(unsigned __int16 *)(v414 + 12);
                                    if (v428 != *(unsigned __int16 *)(v423 + 12)
                                      || *(unsigned __int16 *)(v414 + 14) != *(unsigned __int16 *)(v423 + 14)
                                      || !resource_records_have_same_dnssec_rr_category( *(void *)(v414 + 64),  *(void *)(v423 + 64)))
                                    {
                                      goto LABEL_998;
                                    }

                                    if (v428 == 46)
                                    {
                                      int covered_type = resource_record_as_rrsig_get_covered_type(v414 + 8);
                                      BOOL v35 = covered_type == resource_record_as_rrsig_get_covered_type(v423 + 8);
                                      a1 = v878;
                                      if (!v35)
                                      {
LABEL_1096:
                                        char v16 = (void *)a10;
                                        goto LABEL_998;
                                      }
                                    }

                                    if (!*(_BYTE *)(v414 + 10) && *(_BYTE *)(v423 + 10)) {
                                      *(_BYTE *)(v414 + 10) = 1;
                                    }
                                    unsigned int v430 = *(_DWORD *)(a1 + 64);
                                    int v431 = *(_DWORD *)(v423 + 80);
                                    int v432 = v430 - v431;
                                    if ((int)(v430 - v431) <= 999)
                                    {
                                      int v433 = *(_BYTE *)(v423 + 109)
                                           ? dword_100158BF8 + 939524096
                                           : v431 + 1000 * *(_DWORD *)(v423 + 16);
                                      if ((int)(v433 - v430) >= 1001)
                                      {
                                        int v436 = *(_DWORD *)(v423 + 16);
                                        unsigned int v437 = *(_DWORD *)(v414 + 16);
                                        uint64_t v94 = v838;
                                        if (v436 != v437 && v437 >= 2)
                                        {
                                          if (v436 == 240 && v437 == 60)
                                          {
                                            if (*(_WORD *)(v423 + 12) == 16) {
                                              goto LABEL_1086;
                                            }
LABEL_1061:
                                            if (!v896) {
                                              goto LABEL_1086;
                                            }
                                            goto LABEL_1062;
                                          }

                                          if (v436 != 120 || v437 != 4500) {
                                            goto LABEL_1061;
                                          }
                                          if (v896 && *(_WORD *)(v423 + 12) != 33)
                                          {
LABEL_1062:
                                            if (mDNSCoreReceiveResponse_lastLogWindowStartTime
                                              && v430 - mDNSCoreReceiveResponse_lastLogWindowStartTime < 0x36EE80)
                                            {
                                              unsigned int v453 = mDNSCoreReceiveResponse_count;
                                            }

                                            else
                                            {
                                              unsigned int v453 = 0;
                                              if (v430 <= 1) {
                                                int v454 = 1;
                                              }
                                              else {
                                                int v454 = v430;
                                              }
                                              mDNSCoreReceiveResponse_lastLogWindowStartTime = v454;
                                            }

                                            mDNSCoreReceiveResponse_size_t count = v453 + 1;
                                            uint64_t v455 = mDNSLogCategory_Default;
                                            if (gSensitiveLoggingEnabled != 1
                                              || mDNSLogCategory_Default == mDNSLogCategory_State)
                                            {
                                              if (v453 <= 0x63) {
                                                os_log_type_t v459 = OS_LOG_TYPE_INFO;
                                              }
                                              else {
                                                os_log_type_t v459 = OS_LOG_TYPE_DEBUG;
                                              }
                                              os_log_type_t v885 = v459;
                                              if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, v459)) {
                                                goto LABEL_1086;
                                              }
                                              GetRRDisplayString_rdb( (unsigned __int8 *)(v423 + 8),  (unsigned __int16 *)(*(void *)(v423 + 48) + 4LL),  v908);
                                              *(_DWORD *)v961 = 67110915;
                                              *(_DWORD *)&v961[4] = v436;
                                              *(_WORD *)&v961[8] = 1024;
                                              *(_DWORD *)&v961[10] = v437;
                                              *(_WORD *)&v961[14] = 2160;
                                              *(void *)&v961[16] = 1752392040LL;
                                              *(_WORD *)&v961[24] = 1045;
                                              *(_DWORD *)&v961[26] = 20;
                                              *(_WORD *)&v961[30] = 2101;
                                              *(void *)&v961[32] = v848;
                                              *(_WORD *)&v961[40] = 1024;
                                              *(_DWORD *)&v961[42] = v893;
                                              *(_WORD *)&v961[46] = 2160;
                                              *(void *)&v961[48] = 1752392040LL;
                                              *(_WORD *)&v961[56] = 2085;
                                              *(void *)&v961[58] = v908;
                                              os_log_type_t v457 = v885;
                                              v458 = (os_log_s *)v455;
                                            }

                                            else
                                            {
                                              if (v453 <= 0x63) {
                                                os_log_type_t v456 = OS_LOG_TYPE_INFO;
                                              }
                                              else {
                                                os_log_type_t v456 = OS_LOG_TYPE_DEBUG;
                                              }
                                              v884 = (os_log_s *)mDNSLogCategory_Default_redacted;
                                              if (!os_log_type_enabled( (os_log_t)mDNSLogCategory_Default_redacted,  v456)) {
                                                goto LABEL_1086;
                                              }
                                              GetRRDisplayString_rdb( (unsigned __int8 *)(v423 + 8),  (unsigned __int16 *)(*(void *)(v423 + 48) + 4LL),  v908);
                                              *(_DWORD *)v961 = 67110915;
                                              *(_DWORD *)&v961[4] = v436;
                                              *(_WORD *)&v961[8] = 1024;
                                              *(_DWORD *)&v961[10] = v437;
                                              *(_WORD *)&v961[14] = 2160;
                                              *(void *)&v961[16] = 1752392040LL;
                                              *(_WORD *)&v961[24] = 1045;
                                              *(_DWORD *)&v961[26] = 20;
                                              *(_WORD *)&v961[30] = 2101;
                                              *(void *)&v961[32] = v848;
                                              *(_WORD *)&v961[40] = 1024;
                                              *(_DWORD *)&v961[42] = v893;
                                              *(_WORD *)&v961[46] = 2160;
                                              *(void *)&v961[48] = 1752392040LL;
                                              *(_WORD *)&v961[56] = 2085;
                                              *(void *)&v961[58] = v908;
                                              os_log_type_t v457 = v456;
                                              v458 = v884;
                                            }

                                            _os_log_impl( (void *)&_mh_execute_header,  v458,  v457,  "Correcting TTL from %4u to %4u from %{sensitive, mask.hash, mdnsresponder: ip_addr}.20P:%u for records %{sensitive, mask.hash}s",  v961,  0x42u);
                                          }

LABEL_1086:
                                          *(_DWORD *)(v423 + 16) = *(_DWORD *)(v414 + 16);
                                          unsigned int v430 = *(_DWORD *)(v878 + 64);
                                        }

                                        *(_DWORD *)(v423 + 80) = v430;
                                        a1 = v878;
                                        SetNextCacheCheckTimeForRecord(v878, v423);
                                        a2 = v900;
                                        goto LABEL_1096;
                                      }
                                    }

                                    uint64_t v438 = *(void *)(v423 + 32);
                                    if (v438)
                                    {
                                      if (AWDLInterfaceID && AWDLInterfaceID == v438
                                        || WiFiAwareInterfaceID && WiFiAwareInterfaceID == v438)
                                      {
                                        v439 = (os_log_s *)mDNSLogCategory_Default;
                                        if (gSensitiveLoggingEnabled != 1
                                          || mDNSLogCategory_Default == mDNSLogCategory_State)
                                        {
                                          if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEBUG))
                                          {
                                            if (*(_BYTE *)(v423 + 109)) {
                                              int v440 = dword_100158BF8 + 939524096;
                                            }
                                            else {
                                              int v440 = v431 + 1000 * *(_DWORD *)(v423 + 16);
                                            }
LABEL_1090:
                                            unsigned int v460 = v440 - v430;
                                            GetRRDisplayString_rdb( (unsigned __int8 *)(v423 + 8),  (unsigned __int16 *)(*(void *)(v423 + 48) + 4LL),  v908);
                                            *(_DWORD *)v961 = 67109891;
                                            *(_DWORD *)&v961[4] = v432;
                                            *(_WORD *)&v961[8] = 1024;
                                            *(_DWORD *)&v961[10] = v460;
                                            *(_WORD *)&v961[14] = 2160;
                                            *(void *)&v961[16] = 1752392040LL;
                                            *(_WORD *)&v961[24] = 2085;
                                            *(void *)&v961[26] = v908;
                                            _os_log_impl( (void *)&_mh_execute_header,  v439,  OS_LOG_TYPE_DEBUG,  "Fast flushing AWDL cache record -- age: %d ticks, expire: %d ticks, record : %{sensitive, mask.hash}s",  v961,  0x22u);
                                          }
                                        }

                                        else
                                        {
                                          v439 = (os_log_s *)mDNSLogCategory_Default_redacted;
                                          if (os_log_type_enabled( (os_log_t)mDNSLogCategory_Default_redacted,  OS_LOG_TYPE_DEBUG))
                                          {
                                            if (*(_BYTE *)(v423 + 109)) {
                                              int v440 = dword_100158BF8 + 939524096;
                                            }
                                            else {
                                              int v440 = v431 + 1000 * *(_DWORD *)(v423 + 16);
                                            }
                                            goto LABEL_1090;
                                          }
                                        }

                                        a1 = v878;
                                        mDNS_PurgeCacheResourceRecord((unsigned int *)v878, v423);
                                        a2 = v900;
                                        char v16 = (void *)a10;
                                        uint64_t v94 = v838;
                                        goto LABEL_998;
                                      }

                                      if (v430 == v431 && *(_DWORD *)(v423 + 16) == 1 && *(_BYTE *)(v423 + 108) == 4)
                                      {
                                        if (mDNS_LoggingEnabled == 1)
                                        {
                                          uint64_t v445 = mDNSLogCategory_Default;
                                          GetRRDisplayString_rdb( (unsigned __int8 *)(v423 + 8),  (unsigned __int16 *)(*(void *)(v423 + 48) + 4LL),  v908);
                                          v446 = (os_log_s *)v445;
                                          a1 = v878;
                                          LogMsgWithLevel( v446,  OS_LOG_TYPE_DEFAULT,  "Cache flush for DE record %s",  v447,  v448,  v449,  v450,  v451,  (int)v908);
                                        }

                                        *(_DWORD *)(v423 + 16) = 0;
                                        char v16 = (void *)a10;
                                        uint64_t v94 = v838;
                                      }

                                      else
                                      {
                                        if (*(_BYTE *)(v423 + 109)) {
                                          int v452 = dword_100158BF8 + 939524096;
                                        }
                                        else {
                                          int v452 = v431 + 1000 * *(_DWORD *)(v423 + 16);
                                        }
                                        char v16 = (void *)a10;
                                        uint64_t v94 = v838;
                                        if ((int)(v452 - v430) >= 1001)
                                        {
                                          *(_DWORD *)(v423 + 16) = 1;
                                          *(_BYTE *)(v423 + 10_Block_object_dispose(va, 8) = 4;
                                          *(_DWORD *)(v423 + 80) = v430 - 1;
                                        }
                                      }

                                      SetNextCacheCheckTimeForRecord(a1, v423);
                                      a2 = v900;
LABEL_998:
                                      uint64_t v423 = *(void *)v423;
                                      if (!v423) {
                                        goto LABEL_991;
                                      }
                                      continue;
                                    }

                                    break;
                                  }

                                  a2 = v900;
                                  uint64_t v94 = v838;
                                  if (!v896 && *(unsigned __int8 *)(v423 + 8) != 240)
                                  {
                                    if (v875)
                                    {
                                      uint64_t v441 = 0LL;
                                      v442 = v916;
                                      while (!RecordInTheRRSet(v423 + 8, (uint64_t)v442))
                                      {
                                        ++v441;
                                        v442 += 3;
                                        if (v875 == v441) {
                                          goto LABEL_1043;
                                        }
                                      }

                                      uint64_t v443 = *(void *)(v423 + 64);
                                      a1 = v878;
                                      if (v443)
                                      {
                                        v461 = &v916[3 * v441];
                                        *(void *)(v443 + 24) = *((unsigned int *)v461 + 3);
                                        BOOL v444 = *((_BYTE *)v461 + 18) != 0;
LABEL_1094:
                                        *(_BYTE *)(v443 + 36) = v444;
                                      }
                                    }

                                    else
                                    {
LABEL_1043:
                                      uint64_t v443 = *(void *)(v423 + 64);
                                      a1 = v878;
                                      if (v443)
                                      {
                                        *(void *)(v443 + 24) = 0LL;
                                        BOOL v444 = 1;
                                        goto LABEL_1094;
                                      }
                                    }
                                  }

                                  mDNS_PurgeCacheResourceRecord((unsigned int *)a1, v423);
                                  int v425 = 1;
                                  goto LABEL_1096;
                                }

LABEL_1111:
                                if (!v896 && v862)
                                {
                                  uint64_t v464 = v862;
                                  v465 = v917;
                                  do
                                  {
                                    uint64_t v466 = *v465++;
                                    *(_BYTE *)(v466 + 12_Block_object_dispose(va, 8) = 0;
                                    --v464;
                                  }

                                  while (v464);
                                }

                                if (!v901)
                                {
                                  __int16 v912 = 0;
                                  int v467 = IsResponseMDNSEquivalent(v386, (uint64_t)a9);
                                  int v468 = 0;
                                  int v869 = v467;
                                  if (v386 && !v467)
                                  {
                                    unsigned int v469 = *(unsigned __int8 *)(*(void *)(v386 + 88) + 70LL);
                                    if ((v469 & 4) != 0) {
                                      int v468 = (v469 >> 1) & 1;
                                    }
                                    else {
                                      int v468 = 0;
                                    }
                                  }

                                  memset(v960, 0, sizeof(v960));
                                  memset(v959, 0, sizeof(v959));
                                  memset(v958, 0, sizeof(v958));
                                  memset(v957, 0, sizeof(v957));
                                  if (*((_WORD *)a2 + 2))
                                  {
                                    Question = a2 + 12;
                                    if ((unint64_t)(a2 + 12) < a3)
                                    {
                                      int v471 = 0;
                                      uint64_t NewCacheEntry = 0LL;
                                      uint64_t v886 = 0LL;
                                      unint64_t v472 = a3;
                                      int v894 = 0;
                                      LOBYTE(v863) = 0;
                                      LOBYTE(v865) = 0;
                                      v877 = 0LL;
                                      unsigned __int16 v825 = a7;
                                      v861 = (_BYTE *)(a1 + 46976);
                                      int v909 = v468;
                                      int v849 = v468 ^ 1;
                                      uint64_t v473 = a1 + 37856;
                                      v889 = (uint64_t *)(a1 + 37912);
                                      uint64_t v847 = a1 + 37856;
                                      while (1)
                                      {
                                        bzero(v949, 0x290uLL);
                                        Question = getQuestion((unint64_t)a2, Question, v472, (uint64_t)v16, v949);
                                        if (Question)
                                        {
                                          if (v386)
                                          {
                                            uint64_t DNSQuestion = Querier_GetDNSQuestion(v386, 0LL);
                                            BOOL v851 = DNSQuestion == 0;
                                            int v475 = v909;
                                            int v828 = v471;
                                            uint64_t v902 = DNSQuestion;
                                            if (DNSQuestion) {
                                              unsigned int v829 = bswap32(*(unsigned __int16 *)(DNSQuestion + 320)) >> 16;
                                            }
                                            else {
                                              unsigned int v829 = 0;
                                            }
                                            unsigned int v477 = v950;
                                            int v832 = (*(uint64_t (**)(uint64_t))(*(void *)(v386 + 16) + 96LL))(v386);
                                            unsigned int v839 = (*(uint64_t (**)(uint64_t))(*(void *)(v386 + 16) + 88LL))(v386);
LABEL_1132:
                                            bzero(v934, 0xB00uLL);
                                            v843 = Question;
                                            if (v475)
                                            {
                                              for (uint64_t m = v955; ; m += v479 + 1)
                                              {
                                                if (m >= v956) {
                                                  goto LABEL_1142;
                                                }
                                                if (!m) {
                                                  goto LABEL_1142;
                                                }
                                                uint64_t v479 = *m;
                                                if (!*m) {
                                                  break;
                                                }
                                              }

                                              unsigned __int16 v481 = (_WORD)m - (unsigned __int16)v955 + 1;
                                              if (v481 <= 0x100u) {
                                                memcpy(v934, v955, v481);
                                              }
LABEL_1142:
                                              int v482 = *((unsigned __int16 *)a2 + 3);
                                              if (*((_WORD *)a2 + 3))
                                              {
                                                v483 = LocateAnswers((unint64_t)a2, v870);
                                                if (v483)
                                                {
                                                  v484 = v483;
                                                  bzero(v961, 0x2C00uLL);
                                                  int v485 = 0;
                                                  unint64_t v486 = 0LL;
                                                  while ((unint64_t)v484 < v870 && v486 < 0x16)
                                                  {
                                                    v484 = GetLargeResourceRecord( (uint64_t)mDNSStorage,  (unint64_t)a2,  v484,  v870,  a10,  160,  (uint64_t)mDNSStorage + &loc_1000093E0);
                                                    BOOL v487 = *((unsigned __int8 *)&dword_100158BC0
                                                           + &loc_1000093E0) != 240
                                                        && *(_WORD *)&byte_100158BC4[&loc_1000093E0] == 5;
                                                    if (!v487
                                                      || !*(_BYTE *)qword_100161FC0
                                                      || SameDomainNameBytes( (_BYTE *)qword_100161FC0,  (_BYTE *)(qword_100161FC8 + 4)))
                                                    {
                                                      goto LABEL_1175;
                                                    }

                                                    v488 = (_BYTE *)qword_100161FC0;
                                                    if (qword_100161FC0 == -256)
                                                    {
                                                      while (1)
                                                      {
LABEL_1156:
                                                        if (!v488) {
                                                          goto LABEL_1163;
                                                        }
                                                        uint64_t v489 = *v488;
                                                        if (!*v488) {
                                                          break;
                                                        }
                                                        v488 += v489 + 1;
                                                        if (qword_100161FC0 != -256) {
                                                          goto LABEL_1155;
                                                        }
                                                      }

                                                      unsigned __int16 v490 = (_WORD)v488 - qword_100161FC0 + 1;
                                                      if (v490 <= 0x100u)
                                                      {
                                                        memcpy(&v961[512 * v486], (const void *)qword_100161FC0, v490);
                                                        goto LABEL_1164;
                                                      }
                                                    }

                                                    else
                                                    {
LABEL_1155:
                                                    }

LABEL_1163:
                                                    v961[512 * v486] = 0;
LABEL_1164:
                                                    v491 = (const void *)(qword_100161FC8 + 4);
                                                    v492 = (_BYTE *)(qword_100161FC8 + 4);
                                                    if (qword_100161FC8 != -260)
                                                    {
LABEL_1165:
LABEL_1173:
                                                      v968[512 * v486 + 31] = 0;
                                                      goto LABEL_1174;
                                                    }

                                                    while (1)
                                                    {
LABEL_1166:
                                                      if (!v492) {
                                                        goto LABEL_1173;
                                                      }
                                                      uint64_t v493 = *v492;
                                                      if (!*v492) {
                                                        break;
                                                      }
                                                      v492 += v493 + 1;
                                                      if (qword_100161FC8 != -260) {
                                                        goto LABEL_1165;
                                                      }
                                                    }

                                                    unsigned __int16 v494 = (_WORD)v492 - (_WORD)v491 + 1;
                                                    if (v494 > 0x100u) {
                                                      goto LABEL_1173;
                                                    }
                                                    memcpy(&v968[512 * v486 + 31], v491, v494);
LABEL_1174:
                                                    ++v486;
LABEL_1175:
                                                    WORD4(xmmword_100161F9_Block_object_dispose(va, 8) = 0;
                                                    HIWORD(xmmword_100161FF_Block_object_dispose(va, 8) = 0;
                                                    if ((void)xmmword_100161FD8)
                                                    {
                                                      ref_count_obj_release((void *)xmmword_100161FD8);
                                                      *(void *)&xmmword_100161FD8 = 0LL;
                                                    }

                                                    if (++v485 == v482) {
                                                      break;
                                                    }
                                                  }

                                                  unint64_t v495 = 1LL;
                                                  v496 = v955;
                                                  char v16 = (void *)a10;
                                                  while (2)
                                                  {
                                                    if (!v486 || v495 > v486) {
                                                      goto LABEL_1198;
                                                    }
                                                    uint64_t v497 = 0LL;
                                                    v498 = v961;
                                                    while (!*v498 || !SameDomainNameBytes(v496, v498))
                                                    {
                                                      ++v497;
                                                      v498 += 512;
                                                      if (v486 == v497) {
                                                        goto LABEL_1198;
                                                      }
                                                    }

                                                    v499 = &v961[512 * v497];
                                                    _BYTE *v498 = 0;
                                                    v496 = v499 + 256;
                                                    if (v499 == (_BYTE *)-256LL)
                                                    {
LABEL_1198:
                                                      int v475 = v909;
                                                      goto LABEL_1200;
                                                    }

                                                    v500 = v499 + 512;
                                                    v501 = v499 + 256;
                                                    if (v496 != (_BYTE *)-256LL)
                                                    {
LABEL_1188:
                                                      if (v501 < v500) {
                                                        goto LABEL_1189;
                                                      }
                                                      goto LABEL_1196;
                                                    }

                                                    while (1)
                                                    {
LABEL_1189:
                                                      if (!v501) {
                                                        goto LABEL_1196;
                                                      }
                                                      uint64_t v502 = *v501;
                                                      if (!*v501) {
                                                        break;
                                                      }
                                                      v501 += v502 + 1;
                                                      if (v496 != (_BYTE *)-256LL) {
                                                        goto LABEL_1188;
                                                      }
                                                    }

                                                    unsigned __int16 v503 = (_WORD)v501 - (_WORD)v496 + 1;
                                                    if (v503 > 0x100u) {
LABEL_1196:
                                                    }
                                                      v934[256 * v495] = 0;
                                                    else {
                                                      memcpy(&v934[256 * v495], v496, v503);
                                                    }
                                                    if (++v495 == 11) {
                                                      goto LABEL_1198;
                                                    }
                                                    continue;
                                                  }
                                                }
                                              }

                                              LODWORD(v495) = 1;
LABEL_1200:
                                              unsigned int v856 = v495;
                                              v480 = v934;
                                              unsigned int v477 = DomainNameHashValue((unint64_t)v934);
                                            }

                                            else
                                            {
                                              unsigned int v856 = 1;
                                              v480 = v955;
                                            }

                                            v504 = 0LL;
                                            int v881 = 0;
                                            while (2)
                                            {
                                              v505 = CacheGroupForName(a1, v477, v480);
                                              v511 = v505;
                                              if (v475)
                                              {
                                                int v512 = *((unsigned __int16 *)a2 + 3);
                                                __int128 v933 = 0u;
                                                __int128 v932 = 0u;
                                                __int128 v931 = 0u;
                                                __int128 v930 = 0u;
                                                __int128 v929 = 0u;
                                                __int128 v928 = 0u;
                                                __int128 v927 = 0u;
                                                __int128 v926 = 0u;
                                                __int128 v925 = 0u;
                                                __int128 v924 = 0u;
                                                __int128 v923 = 0u;
                                                __int128 v922 = 0u;
                                                __int128 v921 = 0u;
                                                __int128 v920 = 0u;
                                                __int128 v919 = 0u;
                                                __int128 __dst = 0u;
                                                if (v512)
                                                {
                                                  if (!v505) {
                                                    goto LABEL_1272;
                                                  }
                                                  uint64_t v513 = v505[2];
                                                  if (!v513) {
                                                    goto LABEL_1272;
                                                  }
                                                  unsigned __int16 v899 = 0;
                                                  int v514 = 0;
                                                  int v897 = 3601;
                                                  while (2)
                                                  {
                                                    if (v906)
                                                    {
                                                      v515 = *(void **)(v513 + 56);
                                                      if (v515) {
                                                        v515 = (void *)v515[3];
                                                      }
                                                      if (v515 == a9 && Client_SameNameCacheRecordIsAnswer(v513, v906))
                                                      {
LABEL_1215:
                                                        if (*(unsigned __int8 *)(v513 + 8) != 240)
                                                        {
                                                          int v897 = *(_DWORD *)(v513 + 16);
                                                          int v516 = *(unsigned __int16 *)(v513 + 12);
                                                          if (v516 == 46)
                                                          {
                                                            if (!resource_record_as_rrsig_covers_wildcard_rr(v513 + 8)) {
                                                              goto LABEL_1272;
                                                            }
                                                            uint64_t v517 = v513 + 8;
                                                            if (v899)
                                                            {
                                                              v518 = *(_BYTE **)(v513 + 40);
                                                              v519 = v518;
                                                              if (v518 == (_BYTE *)-256LL)
                                                              {
LABEL_1222:
                                                                while (v519)
                                                                {
                                                                  uint64_t v520 = *v519;
                                                                  if (!*v519) {
                                                                    goto LABEL_1238;
                                                                  }
                                                                  v519 += v520 + 1;
                                                                  if (v518 != (_BYTE *)-256LL) {
                                                                    goto LABEL_1221;
                                                                  }
                                                                }
                                                              }

                                                              else
                                                              {
LABEL_1221:
                                                                if (v519 < v518 + 256) {
                                                                  goto LABEL_1222;
                                                                }
                                                              }

                                                              goto LABEL_1240;
                                                            }

                                                            unsigned __int16 v521 = resource_record_as_rrsig_get_covered_type(v517);
                                                            v518 = *(_BYTE **)(v513 + 40);
                                                            v519 = v518;
                                                            unsigned __int16 v899 = v521;
                                                            if (v518 != (_BYTE *)-256LL)
                                                            {
LABEL_1232:
                                                              if (v519 < v518 + 256) {
                                                                goto LABEL_1233;
                                                              }
                                                              goto LABEL_1240;
                                                            }

                                                            while (1)
                                                            {
LABEL_1233:
                                                              if (!v519) {
                                                                goto LABEL_1240;
                                                              }
                                                              uint64_t v522 = *v519;
                                                              if (!*v519) {
                                                                break;
                                                              }
                                                              v519 += v522 + 1;
                                                              if (v518 != (_BYTE *)-256LL) {
                                                                goto LABEL_1232;
                                                              }
                                                            }

LABEL_1238:
                                                            unsigned __int16 v523 = (_WORD)v519 - (_WORD)v518 + 1;
                                                            if (v523 > 0x100u) {
LABEL_1240:
                                                            }
                                                              LOBYTE(__dst) = 0;
                                                            else {
                                                              memcpy(&__dst, v518, v523);
                                                            }
                                                            int v514 = 1;
                                                          }

                                                          else if (v899)
                                                          {
                                                            if (v516 != v899) {
                                                              goto LABEL_1272;
                                                            }
                                                          }

                                                          else
                                                          {
                                                            unsigned __int16 v899 = *(_WORD *)(v513 + 12);
                                                          }
                                                        }
                                                      }
                                                    }

                                                    else if (SameNameRecordAnswersQuestion( (unsigned __int8 *)(v513 + 8),  0,  v902,  v506,  v507,  v508,  v509,  v510))
                                                    {
                                                      goto LABEL_1215;
                                                    }

                                                    uint64_t v513 = *(void *)v513;
                                                    if (v513) {
                                                      continue;
                                                    }
                                                    break;
                                                  }

                                                  if (v514)
                                                  {
                                                    int v873 = 0;
                                                    int v475 = 1;
                                                    goto LABEL_1273;
                                                  }

LABEL_1272:
                                                  int v475 = 0;
                                                  unsigned __int16 v899 = 0;
                                                  int v897 = 0;
                                                  int v873 = 1;
LABEL_1273:
                                                  char v16 = (void *)a10;
                                                  if (!v511)
                                                  {
LABEL_1274:
                                                    int v529 = 1;
LABEL_1276:
                                                    uint64_t v386 = v906;
                                                    if (!v16) {
                                                      goto LABEL_1282;
                                                    }
LABEL_1286:
                                                    if (!v529) {
                                                      goto LABEL_1867;
                                                    }
                                                    BOOL v532 = v953 == 6 && SameDomainNameBytes(v955, "\x05local") != 0;
                                                    if ((v532 & v849) != 0) {
                                                      unsigned int v544 = 86400;
                                                    }
                                                    else {
                                                      unsigned int v544 = 60;
                                                    }
                                                    if (*((_WORD *)a2 + 4))
                                                    {
                                                      Authorities = LocateAuthorities((unint64_t)a2, v870);
                                                      if (Authorities)
                                                      {
                                                        v843 = GetLargeResourceRecord( a1,  (unint64_t)a2,  Authorities,  v870,  (uint64_t)v16,  160,  v473);
                                                        if (!v843 || *v858 == 240 || *((_WORD *)v858 + 2) != 6) {
                                                          goto LABEL_1377;
                                                        }
                                                        v546 = CacheGroupForName( a1,  *((_DWORD *)v858 + 4),  *((_BYTE **)v858 + 4));
                                                        unsigned int v548 = *(_DWORD *)(*((void *)v858 + 5) + 532LL);
                                                        if (v548 > *((_DWORD *)v858 + 2) && **((_BYTE **)v858 + 4)) {
                                                          unsigned int v548 = *((_DWORD *)v858 + 2);
                                                        }
                                                        if (v544 <= v548) {
                                                          unsigned int v544 = v548;
                                                        }
                                                        uint64_t NewCacheEntry = CreateNewCacheEntryEx( a1,  *((_DWORD *)v858 + 4) % 0x1F3u,  (uint64_t)v546,  1LL,  0LL,  0LL,  0LL,  v547);
                                                        if (!v851)
                                                        {
                                                          if (*(_BYTE *)(v902 + 632)) {
                                                            goto LABEL_1377;
                                                          }
                                                        }

                                                        char v549 = v909;
                                                        if (v953 != 6) {
                                                          char v549 = 1;
                                                        }
                                                        if ((v549 & 1) != 0) {
                                                          goto LABEL_1377;
                                                        }
                                                        int v550 = v955[0];
                                                        if (v955[0])
                                                        {
                                                          int v551 = 0;
                                                          v552 = v955;
                                                          do
                                                          {
                                                            ++v551;
                                                            v553 = &v552[v550];
                                                            int v554 = v553[1];
                                                            v552 = v553 + 1;
                                                            int v550 = v554;
                                                          }

                                                          while (v554);
                                                        }

                                                        else
                                                        {
                                                          int v551 = 0;
                                                        }

                                                        v570 = (unsigned __int8 *)*((void *)v858 + 4);
                                                        unsigned int v571 = *v570;
                                                        if (*v570)
                                                        {
                                                          int v572 = 0;
                                                          uint64_t v573 = *((void *)v858 + 4);
                                                          do
                                                          {
                                                            ++v572;
                                                            uint64_t v574 = v573 + v571;
                                                            unsigned int v575 = *(unsigned __int8 *)(v574 + 1);
                                                            uint64_t v573 = v574 + 1;
                                                            unsigned int v571 = v575;
                                                          }

                                                          while (v575);
                                                        }

                                                        else
                                                        {
                                                          int v572 = 0;
                                                        }

                                                        int v555 = v551 - 1 - v572;
                                                        if (v551 - 1 <= v572)
                                                        {
LABEL_1377:
                                                          int v555 = 0;
                                                        }

                                                        else
                                                        {
                                                          int v576 = v551 - v572;
                                                          v577 = v955;
                                                          if (v576 >= 1)
                                                          {
                                                            int v578 = v576 + 1;
                                                            v577 = v955;
                                                            do
                                                            {
                                                              if (!*v577) {
                                                                break;
                                                              }
                                                              v577 += *v577 + 1;
                                                              --v578;
                                                            }

                                                            while (v578 > 1);
                                                          }
                                                        }

                                                        *(_WORD *)v858 = 0;
                                                        *((_WORD *)v858 + 51) = 0;
                                                        v579 = (void *)*((void *)v858 + 7);
                                                        if (v579)
                                                        {
                                                          ref_count_obj_release(v579);
                                                          *((void *)v858 + 7) = 0LL;
                                                        }
                                                      }

                                                      else
                                                      {
                                                        int v555 = 0;
                                                        v843 = 0LL;
                                                      }
                                                    }

                                                    else
                                                    {
                                                      int v555 = 0;
                                                    }

                                                    if (v504)
                                                    {
                                                      if (v544 <= 2 * v504[2].i32[0]) {
                                                        unsigned int v580 = 2 * v504[2].i32[0];
                                                      }
                                                      else {
                                                        unsigned int v580 = v544;
                                                      }
                                                      if (v580 >= 0xE10) {
                                                        unsigned int v544 = 3600;
                                                      }
                                                      else {
                                                        unsigned int v544 = v580;
                                                      }
                                                    }

                                                    if (v544 >= 0x189374) {
                                                      unsigned int v581 = 1610612;
                                                    }
                                                    else {
                                                      unsigned int v581 = v544;
                                                    }
                                                    unsigned int v582 = v581 + (v581 >> 2) + 2;
                                                    if (v582 <= 0xF) {
                                                      int v583 = 15;
                                                    }
                                                    else {
                                                      int v583 = v582;
                                                    }
                                                    int v584 = v909;
                                                    if (v894) {
                                                      int v584 = 0;
                                                    }
                                                    if (v584 == 1)
                                                    {
                                                      int v853 = v583;
                                                      __int16 v912 = 0;
                                                      unsigned int v891 = *((unsigned __int16 *)a2 + 4);
                                                      if (*((_WORD *)a2 + 4))
                                                      {
                                                        unint64_t v585 = v870;
                                                        v586 = LocateAuthorities((unint64_t)a2, v870);
                                                        v877 = 0LL;
                                                        unsigned int v895 = 3601;
                                                        LOBYTE(v865) = 0;
                                                        if (v586)
                                                        {
                                                          v587 = v586;
                                                          LOBYTE(v863) = 0;
                                                          if ((unint64_t)v586 < v870)
                                                          {
                                                            v877 = 0LL;
                                                            int v863 = 0;
                                                            int v865 = 0;
                                                            unsigned int v588 = 0;
                                                            int v913 = 0;
                                                            unsigned int v895 = 3601;
                                                            do
                                                            {
                                                              v589 = GetLargeResourceRecord( (uint64_t)mDNSStorage,  (unint64_t)v900,  v587,  v585,  (uint64_t)v16,  160,  (uint64_t)mDNSStorage + &loc_1000093E0);
                                                              v587 = v589;
                                                              if (*((unsigned __int8 *)&dword_100158BC0
                                                                   + &loc_1000093E0) != 240)
                                                              {
                                                                unsigned int v590 = xmmword_100161FA8;
                                                                if ((_DWORD)xmmword_100161FA8 == 3601) {
                                                                  int v591 = 3600;
                                                                }
                                                                else {
                                                                  int v591 = xmmword_100161FA8;
                                                                }
                                                                if (v895 == 3601) {
                                                                  unsigned int v590 = v591;
                                                                }
                                                                unsigned int v895 = v590;
                                                                if (WORD6(xmmword_100161F98) > 0x2Eu)
                                                                {
                                                                  if (WORD6(xmmword_100161F98) == 47)
                                                                  {
                                                                    if (v865 != 10)
                                                                    {
                                                                      v841 = v589;
                                                                      v627 = (unsigned __int8 *)qword_100161FC0;
                                                                      unsigned int v628 = WORD2(xmmword_100161FA8);
                                                                      LODWORD(v973[0]) = 0;
                                                                      if (WORD2(xmmword_100161FA8) <= 3uLL)
                                                                      {
                                                                        uint64_t v677 = mDNSLogCategory_Default;
                                                                        if (gSensitiveLoggingEnabled != 1
                                                                          || mDNSLogCategory_Default == mDNSLogCategory_State)
                                                                        {
                                                                          v587 = v589;
                                                                          if (!os_log_type_enabled( (os_log_t)mDNSLogCategory_Default,  OS_LOG_TYPE_FAULT)) {
                                                                            goto LABEL_1524;
                                                                          }
                                                                        }

                                                                        else
                                                                        {
                                                                          uint64_t v677 = mDNSLogCategory_Default_redacted;
                                                                          v587 = v589;
                                                                          if (!os_log_type_enabled( (os_log_t)mDNSLogCategory_Default_redacted,  OS_LOG_TYPE_FAULT)) {
                                                                            goto LABEL_1524;
                                                                          }
                                                                        }

                                                                        *(_DWORD *)v961 = 136447234;
                                                                        *(void *)&v961[4] = "rdata_len >= min_rdata_len_nsec";
                                                                        *(_WORD *)&v961[12] = 2082;
                                                                        *(void *)&v961[14] = "";
                                                                        *(_WORD *)&v961[22] = 2082;
                                                                        *(void *)&v961[24] = "/Library/Caches/com.apple"
                                                                                               ".xbs/Sources/mDNSResponde"
                                                                                               "r/mDNSShared/dns_objects/"
                                                                                               "utilities/rdata_parser.c";
                                                                        *(_WORD *)&v961[32] = 1024;
                                                                        *(_DWORD *)&v961[34] = 233;
                                                                        *(_WORD *)&v961[38] = 2048;
                                                                        *(void *)&v961[40] = 0LL;
                                                                        v673 = (os_log_s *)v677;
                                                                      }

                                                                      else
                                                                      {
                                                                        v629 = (const void *)(qword_100161FC8 + 4);
                                                                        unsigned int v630 = *(unsigned __int8 *)(qword_100161FC8 + 4);
                                                                        uint64_t v631 = qword_100161FC8 + 4;
                                                                        if (*(_BYTE *)(qword_100161FC8 + 4))
                                                                        {
                                                                          unint64_t v632 = (unint64_t)v629
                                                                               + WORD2(xmmword_100161FA8);
                                                                          unsigned int v633 = *(unsigned __int8 *)(qword_100161FC8 + 4);
                                                                          uint64_t v631 = qword_100161FC8 + 4;
                                                                          while (!v632
                                                                               || v631 + (unint64_t)v633 + 1 <= v632)
                                                                          {
                                                                            uint64_t v634 = v633 + v631;
                                                                            unsigned int v635 = *(unsigned __int8 *)(v634 + 1);
                                                                            uint64_t v631 = v634 + 1;
                                                                            unsigned int v633 = v635;
                                                                            if (!v635) {
                                                                              goto LABEL_1459;
                                                                            }
                                                                          }

LABEL_1481:
                                                                          uint64_t v653 = mDNSLogCategory_Default;
                                                                          if (gSensitiveLoggingEnabled != 1
                                                                            || mDNSLogCategory_Default == mDNSLogCategory_State)
                                                                          {
                                                                            unint64_t v585 = v870;
                                                                            v587 = v589;
                                                                            if (os_log_type_enabled( (os_log_t)mDNSLogCategory_Default,  OS_LOG_TYPE_FAULT))
                                                                            {
                                                                              goto LABEL_1522;
                                                                            }
                                                                          }

                                                                          else
                                                                          {
                                                                            uint64_t v653 = mDNSLogCategory_Default_redacted;
                                                                            BOOL v672 = os_log_type_enabled( (os_log_t)mDNSLogCategory_Default_redacted,  OS_LOG_TYPE_FAULT);
                                                                            unint64_t v585 = v870;
                                                                            v587 = v841;
                                                                            if (v672)
                                                                            {
LABEL_1522:
                                                                              *(_DWORD *)v961 = 136447234;
                                                                              *(void *)&v961[4] = "next_domain_name_len >= 1";
                                                                              *(_WORD *)&v961[12] = 2082;
                                                                              *(void *)&v961[14] = "";
                                                                              *(_WORD *)&v961[22] = 2082;
                                                                              *(void *)&v961[24] = "/Library/Caches/com.apple.xbs/Sources/mDNSResponder/mDNSShared/dns_objects/utilities/rdata_parser.c";
                                                                              *(_WORD *)&v961[32] = 1024;
                                                                              *(_DWORD *)&v961[34] = 238;
                                                                              *(_WORD *)&v961[38] = 2048;
                                                                              *(void *)&v961[40] = 0LL;
                                                                              v673 = (os_log_s *)v653;
                                                                              goto LABEL_1523;
                                                                            }
                                                                          }

LABEL_1524:
                                                                          uint64_t v642 = 0LL;
                                                                          int v648 = -6705;
LABEL_1525:
                                                                          int v913 = v648;
                                                                          goto LABEL_1526;
                                                                        }

LABEL_1459:
                                                                        uint64_t v636 = v631 - (void)v629;
                                                                        BOOL v80 = __CFADD__(v636, 1LL);
                                                                        unint64_t v637 = v636 + 1;
                                                                        if (v80) {
                                                                          goto LABEL_1481;
                                                                        }
                                                                        if (v637 >= WORD2(xmmword_100161FA8))
                                                                        {
                                                                          uint64_t v679 = mDNSLogCategory_Default;
                                                                          if (gSensitiveLoggingEnabled != 1
                                                                            || mDNSLogCategory_Default == mDNSLogCategory_State)
                                                                          {
                                                                            unint64_t v585 = v870;
                                                                            v587 = v589;
                                                                            if (!os_log_type_enabled( (os_log_t)mDNSLogCategory_Default,  OS_LOG_TYPE_FAULT)) {
                                                                              goto LABEL_1524;
                                                                            }
                                                                          }

                                                                          else
                                                                          {
                                                                            uint64_t v679 = mDNSLogCategory_Default_redacted;
                                                                            unint64_t v585 = v870;
                                                                            v587 = v589;
                                                                            if (!os_log_type_enabled( (os_log_t)mDNSLogCategory_Default_redacted,  OS_LOG_TYPE_FAULT)) {
                                                                              goto LABEL_1524;
                                                                            }
                                                                          }

                                                                          *(_DWORD *)v961 = 136447234;
                                                                          *(void *)&v961[4] = "next_domain_name_len < rdata_len";
                                                                          *(_WORD *)&v961[12] = 2082;
                                                                          *(void *)&v961[14] = "";
                                                                          *(_WORD *)&v961[22] = 2082;
                                                                          *(void *)&v961[24] = "/Library/Caches/com.app"
                                                                                                 "le.xbs/Sources/mDNSResp"
                                                                                                 "onder/mDNSShared/dns_ob"
                                                                                                 "jects/utilities/rdata_parser.c";
                                                                          *(_WORD *)&v961[32] = 1024;
                                                                          *(_DWORD *)&v961[34] = 240;
                                                                          *(_WORD *)&v961[38] = 2048;
                                                                          *(void *)&v961[40] = 0LL;
                                                                          v673 = (os_log_s *)v679;
                                                                        }

                                                                        else
                                                                        {
                                                                          uint64_t v638 = qword_100161FC8 + 4;
                                                                          if (*(_BYTE *)(qword_100161FC8 + 4))
                                                                          {
                                                                            do
                                                                            {
                                                                              uint64_t v639 = v638 + v630;
                                                                              unsigned int v640 = *(unsigned __int8 *)(v639 + 1);
                                                                              uint64_t v638 = v639 + 1;
                                                                              unsigned int v630 = v640;
                                                                            }

                                                                            while (v640);
                                                                          }

                                                                          if (type_bit_maps_check_length( v638 + 1,  (unsigned __int16)(~(v638 - (_WORD)v629)
                                                                                                  + WORD2(xmmword_100161FA8))))
                                                                          {
                                                                            v641 = calloc(1uLL, 0x60uLL);
                                                                            if (!v641) {
                                                                              goto LABEL_1999;
                                                                            }
                                                                            uint64_t v642 = (uint64_t)v641;
                                                                            v643 = &_dnssec_obj_rr_nsec_kind;
                                                                            v641[1] = &_dnssec_obj_rr_nsec_kind;
                                                                            do
                                                                            {
                                                                              v644 = (void (*)(uint64_t))v643[2];
                                                                              if (v644) {
                                                                                v644(v642);
                                                                              }
                                                                              v643 = (_UNKNOWN **)*v643;
                                                                            }

                                                                            while (v643);
                                                                            ++*(_DWORD *)v642;
                                                                            dnssec_obj_rr_init_fields( v642,  v627,  47,  1,  v629,  v628,  1,  0LL,  (int *)v973);
                                                                            int v645 = v973[0];
                                                                            if (LODWORD(v973[0]))
                                                                            {
                                                                              a1 = v878;
                                                                              unint64_t v585 = v870;
                                                                              v587 = v841;
                                                                            }

                                                                            else
                                                                            {
                                                                              v646 = dnssec_obj_domain_name_create_with_labels( *(unsigned __int8 **)(v642 + 24),  0,  (int *)v973);
                                                                              *(void *)(v642 + 80) = v646;
                                                                              int v645 = v973[0];
                                                                              a1 = v878;
                                                                              unint64_t v585 = v870;
                                                                              v587 = v841;
                                                                              if (!LODWORD(v973[0]))
                                                                              {
                                                                                unsigned int v647 = ref_count_obj_compare( *(void *)(v642 + 16),  (uint64_t)v646,  0LL);
                                                                                int v648 = 0;
                                                                                *(_BYTE *)(v642 + 8_Block_object_dispose(va, 8) = v647 < 2;
                                                                                goto LABEL_1525;
                                                                              }
                                                                            }

                                                                            int v913 = v645;
                                                                            ref_count_obj_release((void *)v642);
                                                                            uint64_t v642 = 0LL;
                                                                            int v648 = v913;
LABEL_1526:
                                                                            *((void *)v959 + v865) = v642;
                                                                            if (v648) {
                                                                              int v674 = v865;
                                                                            }
                                                                            else {
                                                                              int v674 = v865 + 1;
                                                                            }
                                                                            int v865 = v674;
                                                                            goto LABEL_1613;
                                                                          }

                                                                          uint64_t v680 = mDNSLogCategory_Default;
                                                                          if (gSensitiveLoggingEnabled != 1
                                                                            || mDNSLogCategory_Default == mDNSLogCategory_State)
                                                                          {
                                                                            unint64_t v585 = v870;
                                                                            v587 = v841;
                                                                            if (!os_log_type_enabled( (os_log_t)mDNSLogCategory_Default,  OS_LOG_TYPE_FAULT)) {
                                                                              goto LABEL_1524;
                                                                            }
                                                                          }

                                                                          else
                                                                          {
                                                                            uint64_t v680 = mDNSLogCategory_Default_redacted;
                                                                            BOOL v690 = os_log_type_enabled( (os_log_t)mDNSLogCategory_Default_redacted,  OS_LOG_TYPE_FAULT);
                                                                            unint64_t v585 = v870;
                                                                            v587 = v841;
                                                                            if (!v690) {
                                                                              goto LABEL_1524;
                                                                            }
                                                                          }

                                                                          *(_DWORD *)v961 = 136447234;
                                                                          *(void *)&v961[4] = "type_bit_maps_is_valid";
                                                                          *(_WORD *)&v961[12] = 2082;
                                                                          *(void *)&v961[14] = "";
                                                                          *(_WORD *)&v961[22] = 2082;
                                                                          *(void *)&v961[24] = "/Library/Caches/com.app"
                                                                                                 "le.xbs/Sources/mDNSResp"
                                                                                                 "onder/mDNSShared/dns_ob"
                                                                                                 "jects/utilities/rdata_parser.c";
                                                                          *(_WORD *)&v961[32] = 1024;
                                                                          *(_DWORD *)&v961[34] = 246;
                                                                          *(_WORD *)&v961[38] = 2048;
                                                                          *(void *)&v961[40] = 0LL;
                                                                          v673 = (os_log_s *)v680;
                                                                        }
                                                                      }

LABEL_1523:
                                                                      _os_log_impl( (void *)&_mh_execute_header,  v673,  OS_LOG_TYPE_FAULT,  "AssertMacros: %{public}s, %{public}s file: %{pub lic}s, line: %d, value: %ld",  v961,  0x30u);
                                                                      goto LABEL_1524;
                                                                    }

                                                                    int v865 = 10;
                                                                  }

                                                                  else if (WORD6(xmmword_100161F98) == 50)
                                                                  {
                                                                    if (v863 != 10)
                                                                    {
                                                                      uint64_t v604 = qword_100161FC0;
                                                                      uint64_t v605 = qword_100161FC8;
                                                                      int v914 = 0;
                                                                      unsigned int v606 = *(unsigned __int8 *)qword_100161FC0;
                                                                      if (!*(_BYTE *)qword_100161FC0) {
                                                                        goto LABEL_1607;
                                                                      }
                                                                      unint64_t v607 = 0LL;
                                                                      uint64_t v608 = qword_100161FC8 + 4;
                                                                      uint64_t v609 = qword_100161FC0;
                                                                      do
                                                                      {
                                                                        ++v607;
                                                                        uint64_t v610 = v609 + v606;
                                                                        unsigned int v611 = *(unsigned __int8 *)(v610 + 1);
                                                                        uint64_t v609 = v610 + 1;
                                                                        unsigned int v606 = v611;
                                                                      }

                                                                      while (v611);
                                                                      if (v607 >= 2)
                                                                      {
                                                                        if (WORD2(xmmword_100161FA8) <= 6u)
                                                                        {
                                                                          uint64_t v682 = mDNSLogCategory_Default;
                                                                          if (gSensitiveLoggingEnabled != 1
                                                                            || mDNSLogCategory_Default == mDNSLogCategory_State)
                                                                          {
                                                                            a1 = v878;
                                                                            if (!os_log_type_enabled( (os_log_t)mDNSLogCategory_Default,  OS_LOG_TYPE_FAULT)) {
                                                                              goto LABEL_1607;
                                                                            }
                                                                          }

                                                                          else
                                                                          {
                                                                            uint64_t v682 = mDNSLogCategory_Default_redacted;
                                                                            BOOL v691 = os_log_type_enabled( (os_log_t)mDNSLogCategory_Default_redacted,  OS_LOG_TYPE_FAULT);
                                                                            a1 = v878;
                                                                            if (!v691) {
                                                                              goto LABEL_1607;
                                                                            }
                                                                          }

                                                                          *(_DWORD *)v961 = 136447234;
                                                                          *(void *)&v961[4] = "rdata_len >= min_rdata_len_nsec3";
                                                                          *(_WORD *)&v961[12] = 2082;
                                                                          *(void *)&v961[14] = "";
                                                                          *(_WORD *)&v961[22] = 2082;
                                                                          *(void *)&v961[24] = "/Library/Caches/com.app"
                                                                                                 "le.xbs/Sources/mDNSResp"
                                                                                                 "onder/mDNSShared/dns_ob"
                                                                                                 "jects/utilities/rdata_parser.c";
                                                                          *(_WORD *)&v961[32] = 1024;
                                                                          *(_DWORD *)&v961[34] = 652;
                                                                          *(_WORD *)&v961[38] = 2048;
                                                                          *(void *)&v961[40] = 0LL;
                                                                          v684 = (os_log_s *)v682;
                                                                        }

                                                                        else
                                                                        {
                                                                          unint64_t v612 = v608 + WORD2(xmmword_100161FA8);
                                                                          uint64_t v613 = *(unsigned __int8 *)(qword_100161FC8 + 8);
                                                                          unint64_t v614 = qword_100161FC8 + 9 + v613;
                                                                          if (v614 >= v612)
                                                                          {
                                                                            uint64_t v685 = mDNSLogCategory_Default;
                                                                            if (gSensitiveLoggingEnabled != 1
                                                                              || mDNSLogCategory_Default == mDNSLogCategory_State)
                                                                            {
                                                                              a1 = v878;
                                                                              if (!os_log_type_enabled( (os_log_t)mDNSLogCategory_Default,  OS_LOG_TYPE_FAULT)) {
                                                                                goto LABEL_1607;
                                                                              }
                                                                            }

                                                                            else
                                                                            {
                                                                              uint64_t v685 = mDNSLogCategory_Default_redacted;
                                                                              a1 = v878;
                                                                              if (!os_log_type_enabled( (os_log_t)mDNSLogCategory_Default_redacted,  OS_LOG_TYPE_FAULT)) {
                                                                                goto LABEL_1607;
                                                                              }
                                                                            }

                                                                            *(_DWORD *)v961 = 136447234;
                                                                            *(void *)&v961[4] = "salt + salt_len < limit";
                                                                            *(_WORD *)&v961[12] = 2082;
                                                                            *(void *)&v961[14] = "";
                                                                            *(_WORD *)&v961[22] = 2082;
                                                                            *(void *)&v961[24] = "/Library/Caches/com.a"
                                                                                                   "pple.xbs/Sources/mDNS"
                                                                                                   "Responder/mDNSShared/"
                                                                                                   "dns_objects/utilities/rdata_parser.c";
                                                                            *(_WORD *)&v961[32] = 1024;
                                                                            *(_DWORD *)&v961[34] = 659;
                                                                            *(_WORD *)&v961[38] = 2048;
                                                                            *(void *)&v961[40] = 0LL;
                                                                            v684 = (os_log_s *)v685;
                                                                          }

                                                                          else
                                                                          {
                                                                            unint64_t v615 = v614
                                                                            if (v615 > v612)
                                                                            {
                                                                              uint64_t v686 = mDNSLogCategory_Default;
                                                                              if (gSensitiveLoggingEnabled != 1
                                                                                || mDNSLogCategory_Default == mDNSLogCategory_State)
                                                                              {
                                                                                a1 = v878;
                                                                                if (!os_log_type_enabled( (os_log_t)mDNSLogCategory_Default,  OS_LOG_TYPE_FAULT)) {
                                                                                  goto LABEL_1607;
                                                                                }
                                                                              }

                                                                              else
                                                                              {
                                                                                uint64_t v686 = mDNSLogCategory_Default_redacted;
                                                                                a1 = v878;
                                                                                if (!os_log_type_enabled( (os_log_t)mDNSLogCategory_Default_redacted,  OS_LOG_TYPE_FAULT)) {
                                                                                  goto LABEL_1607;
                                                                                }
                                                                              }

                                                                              *(_DWORD *)v961 = 136447234;
                                                                              *(void *)&v961[4] = "next_hashed_owner_name + hash_len <= limit";
                                                                              *(_WORD *)&v961[12] = 2082;
                                                                              *(void *)&v961[14] = "";
                                                                              *(_WORD *)&v961[22] = 2082;
                                                                              *(void *)&v961[24] = "/Library/Caches/com.apple.xbs/Sources/mDNSResponder/mDNSShared/dns_objects/utilities/rdata_parser.c";
                                                                              *(_WORD *)&v961[32] = 1024;
                                                                              *(_DWORD *)&v961[34] = 664;
                                                                              *(_WORD *)&v961[38] = 2048;
                                                                              *(void *)&v961[40] = 0LL;
                                                                              v684 = (os_log_s *)v686;
                                                                            }

                                                                            else
                                                                            {
                                                                              uint64_t v834 = qword_100161FC8 + 9;
                                                                              unsigned int v835 = WORD2(xmmword_100161FA8);
                                                                              if (type_bit_maps_check_length( v615,  (unsigned __int16)(v612 - v615)))
                                                                              {
                                                                                v840 = (unsigned __int8 *)v604;
                                                                                v616 = calloc(1uLL, 0x60uLL);
                                                                                if (!v616) {
                                                                                  goto LABEL_1999;
                                                                                }
                                                                                uint64_t v617 = (uint64_t)v616;
                                                                                v618 = &_dnssec_obj_rr_nsec3_kind;
                                                                                v616[1] = &_dnssec_obj_rr_nsec3_kind;
                                                                                do
                                                                                {
                                                                                  v619 = (void (*)(uint64_t))v618[2];
                                                                                  if (v619) {
                                                                                    v619(v617);
                                                                                  }
                                                                                  v618 = (_UNKNOWN **)*v618;
                                                                                }

                                                                                while (v618);
                                                                                ++*(_DWORD *)v617;
                                                                                dnssec_obj_rr_init_fields( v617,  v840,  50,  1,  (const void *)(v605 + 4),  v835,  1,  0LL,  &v914);
                                                                                int v620 = v914;
                                                                                if (v914)
                                                                                {
                                                                                  a1 = v878;
                                                                                  unint64_t v585 = v870;
                                                                                  goto LABEL_1582;
                                                                                }

                                                                                uint64_t v621 = *(unsigned __int8 *)(v605 + 8);
                                                                                unint64_t v622 = *(unsigned __int8 *)(v621 + v608 + 5);
                                                                                encoded_string_size_t length = base_x_get_encoded_string_length(2, v622);
                                                                                unint64_t v585 = v870;
                                                                                if (encoded_string_length > 0x3F)
                                                                                {
                                                                                  int v620 = -6705;
                                                                                }

                                                                                else
                                                                                {
                                                                                  int v915 = 0;
                                                                                  memset(&v961[1], 0, 128);
                                                                                  __int128 v962 = 0u;
                                                                                  __int128 v963 = 0u;
                                                                                  __int128 v964 = 0u;
                                                                                  __int128 v965 = 0u;
                                                                                  __int128 v966 = 0u;
                                                                                  __int128 v967 = 0u;
                                                                                  memset(v968, 0, 31);
                                                                                  memset(v973, 0, sizeof(v973));
                                                                                  __int128 v974 = 0u;
                                                                                  __int128 v975 = 0u;
                                                                                  __int128 v976 = 0u;
                                                                                  __int128 v977 = 0u;
                                                                                  __int128 v978 = 0u;
                                                                                  __int128 v979 = 0u;
                                                                                  __int128 v980 = 0u;
                                                                                  __int128 v981 = 0u;
                                                                                  __int128 v982 = 0u;
                                                                                  __int128 v983 = 0u;
                                                                                  __int128 v984 = 0u;
                                                                                  __int128 v985 = 0u;
                                                                                  __int128 v986 = 0u;
                                                                                  __int128 v987 = 0u;
                                                                                  v961[0] = encoded_string_length;
                                                                                  v961[encoded_string_length + 1] = 0;
                                                                                  base_32_hex_encode( (unsigned __int8 *)(v834 + v621 + 1),  v622,  1,  &v961[1]);
                                                                                  parent = domain_name_labels_get_parent( v840,  1uLL);
                                                                                  if (parent)
                                                                                  {
                                                                                    domain_name_labels_concatenate( v961,  parent,  (char *)v973,  &v915);
                                                                                    int v620 = v915;
                                                                                    a1 = v878;
                                                                                    if (!v915)
                                                                                    {
                                                                                      v625 = dnssec_obj_domain_name_create_with_labels( (unsigned __int8 *)v973,  1,  &v915);
                                                                                      *(void *)(v617 + 80) = v625;
                                                                                      int v620 = v915;
                                                                                      if (!v915)
                                                                                      {
                                                                                        *(_BYTE *)(v617 + 8_Block_object_dispose(va, 8) = ref_count_obj_compare(*(void *)(v617 + 16), (uint64_t)v625, 0LL) < 2;
                                                                                        int v620 = v915;
                                                                                        int v914 = v915;
                                                                                        if (!v915)
                                                                                        {
                                                                                          int v626 = 0;
                                                                                          goto LABEL_1608;
                                                                                        }

LABEL_1582:
                                                                                        int v913 = v620;
                                                                                        ref_count_obj_release((void *)v617);
                                                                                        uint64_t v617 = 0LL;
                                                                                        int v626 = v913;
LABEL_1609:
                                                                                        *((void *)v958
                                                                                        + v863) = v617;
                                                                                        if (v626) {
                                                                                          int v692 = v863;
                                                                                        }
                                                                                        else {
                                                                                          int v692 = v863 + 1;
                                                                                        }
                                                                                        int v863 = v692;
                                                                                        goto LABEL_1613;
                                                                                      }
                                                                                    }

LABEL_1581:
                                                                                    int v914 = v620;
                                                                                    goto LABEL_1582;
                                                                                  }

                                                                                  int v620 = -6736;
                                                                                }

                                                                                a1 = v878;
                                                                                goto LABEL_1581;
                                                                              }

                                                                              uint64_t v687 = mDNSLogCategory_Default;
                                                                              if (gSensitiveLoggingEnabled == 1
                                                                                && mDNSLogCategory_Default != mDNSLogCategory_State)
                                                                              {
                                                                                uint64_t v687 = mDNSLogCategory_Default_redacted;
                                                                                a1 = v878;
                                                                                if (os_log_type_enabled( (os_log_t)mDNSLogCategory_Default_redacted,  OS_LOG_TYPE_FAULT))
                                                                                {
                                                                                  goto LABEL_1576;
                                                                                }

LABEL_1607:
                                                                                uint64_t v617 = 0LL;
                                                                                int v626 = -6705;
LABEL_1608:
                                                                                int v913 = v626;
                                                                                goto LABEL_1609;
                                                                              }

                                                                              a1 = v878;
                                                                              if (!os_log_type_enabled( (os_log_t)mDNSLogCategory_Default,  OS_LOG_TYPE_FAULT)) {
                                                                                goto LABEL_1607;
                                                                              }
LABEL_1576:
                                                                              *(_DWORD *)v961 = 136447234;
                                                                              *(void *)&v961[4] = "type_bit_maps_is_valid";
                                                                              *(_WORD *)&v961[12] = 2082;
                                                                              *(void *)&v961[14] = "";
                                                                              *(_WORD *)&v961[22] = 2082;
                                                                              *(void *)&v961[24] = "/Library/Caches/com.apple.xbs/Sources/mDNSResponder/mDNSShared/dns_objects/utilities/rdata_parser.c";
                                                                              *(_WORD *)&v961[32] = 1024;
                                                                              *(_DWORD *)&v961[34] = 670;
                                                                              *(_WORD *)&v961[38] = 2048;
                                                                              *(void *)&v961[40] = 0LL;
                                                                              v684 = (os_log_s *)v687;
                                                                            }
                                                                          }
                                                                        }

                                                                        _os_log_impl( (void *)&_mh_execute_header,  v684,  OS_LOG_TYPE_FAULT,  "AssertMacros: %{public}s, %{public}s file: %{p ublic}s, line: %d, value: %ld",  v961,  0x30u);
                                                                        goto LABEL_1607;
                                                                      }

                                                                      uint64_t v617 = 0LL;
                                                                      int v626 = -6705;
                                                                      a1 = v878;
                                                                      goto LABEL_1608;
                                                                    }

                                                                    int v863 = 10;
                                                                  }
                                                                }

                                                                else if (WORD6(xmmword_100161F98) == 6)
                                                                {
                                                                  if (!v877)
                                                                  {
                                                                    bzero(v961, 0x214uLL);
                                                                    putRData( 0LL,  v961,  (unint64_t)&v971,  (uint64_t)&xmmword_100161F98 + 8,  v593,  v594,  v595,  v596);
                                                                    v597 = (unsigned __int8 *)qword_100161FC0;
                                                                    unsigned int v598 = WORD2(xmmword_100161FA8);
                                                                    int v915 = 0;
                                                                    if (WORD2(xmmword_100161FA8) <= 0x15uLL)
                                                                    {
                                                                      uint64_t v678 = mDNSLogCategory_Default;
                                                                      if (gSensitiveLoggingEnabled != 1
                                                                        || mDNSLogCategory_Default == mDNSLogCategory_State)
                                                                      {
                                                                        char v16 = (void *)a10;
                                                                        if (!os_log_type_enabled( (os_log_t)mDNSLogCategory_Default,  OS_LOG_TYPE_FAULT)) {
                                                                          goto LABEL_1535;
                                                                        }
                                                                      }

                                                                      else
                                                                      {
                                                                        uint64_t v678 = mDNSLogCategory_Default_redacted;
                                                                        char v16 = (void *)a10;
                                                                        if (!os_log_type_enabled( (os_log_t)mDNSLogCategory_Default_redacted,  OS_LOG_TYPE_FAULT)) {
                                                                          goto LABEL_1535;
                                                                        }
                                                                      }

                                                                      LODWORD(v973[0]) = 136447234;
                                                                      *(void *)((char *)v973 + 4) = "rdata_len >= min_rdata_len_soa";
                                                                      WORD6(v973[0]) = 2082;
                                                                      *(void *)((char *)v973 + 14) = "";
                                                                      WORD3(v973[1]) = 2082;
                                                                      LOWORD(v974) = 1024;
                                                                      *(_DWORD *)((char *)&v974 + 2) = 117;
                                                                      WORD3(v974) = 2048;
                                                                      *((void *)&v973[1] + 1) = "/Library/Caches/com.ap"
                                                                                                  "ple.xbs/Sources/mDNSRe"
                                                                                                  "sponder/mDNSShared/dns"
                                                                                                  "_objects/utilities/rdata_parser.c";
                                                                      *((void *)&v974 + 1) = 0LL;
                                                                      v665 = (os_log_s *)v678;
                                                                    }

                                                                    else
                                                                    {
                                                                      v599 = &v961[WORD2(xmmword_100161FA8)];
                                                                      int v600 = v961[0];
                                                                      if (v961[0])
                                                                      {
                                                                        v601 = v961;
                                                                        while (!v599 || &v601[v600 + 1] <= v599)
                                                                        {
                                                                          v602 = &v601[v600];
                                                                          int v603 = v602[1];
                                                                          v601 = v602 + 1;
                                                                          int v600 = v603;
                                                                          if (!v603) {
                                                                            goto LABEL_1489;
                                                                          }
                                                                        }

                                                                        goto LABEL_1497;
                                                                      }

                                                                      v601 = v961;
LABEL_1489:
                                                                      uint64_t v655 = v601 - v961;
                                                                      uint64_t v656 = v655 + 1;
                                                                      if (v655 == -1)
                                                                      {
LABEL_1497:
                                                                        uint64_t v663 = mDNSLogCategory_Default;
                                                                        if (gSensitiveLoggingEnabled != 1
                                                                          || mDNSLogCategory_Default == mDNSLogCategory_State)
                                                                        {
                                                                          char v16 = (void *)a10;
                                                                          if (!os_log_type_enabled( (os_log_t)mDNSLogCategory_Default,  OS_LOG_TYPE_FAULT)) {
                                                                            goto LABEL_1535;
                                                                          }
                                                                        }

                                                                        else
                                                                        {
                                                                          uint64_t v663 = mDNSLogCategory_Default_redacted;
                                                                          BOOL v675 = os_log_type_enabled( (os_log_t)mDNSLogCategory_Default_redacted,  OS_LOG_TYPE_FAULT);
                                                                          char v16 = (void *)a10;
                                                                          if (!v675) {
                                                                            goto LABEL_1535;
                                                                          }
                                                                        }

                                                                        LODWORD(v973[0]) = 136447234;
                                                                        *(void *)((char *)v973 + 4) = "primary_name_server_len >= 1";
                                                                        WORD6(v973[0]) = 2082;
                                                                        *(void *)((char *)v973 + 14) = "";
                                                                        WORD3(v973[1]) = 2082;
                                                                        LOWORD(v974) = 1024;
                                                                        *(_DWORD *)((char *)&v974 + 2) = 122;
                                                                        WORD3(v974) = 2048;
                                                                        *((void *)&v973[1] + 1) = "/Library/Caches/com.apple.xbs/Sources/mDNSResponder/mDNSShared/dns_objects/utilities/rdata_parser.c";
                                                                        *((void *)&v974 + 1) = 0LL;
                                                                        v665 = (os_log_s *)v663;
                                                                      }

                                                                      else
                                                                      {
                                                                        unint64_t v657 = v655 + 21;
                                                                        if (v657 >= WORD2(xmmword_100161FA8))
                                                                        {
                                                                          uint64_t v688 = mDNSLogCategory_Default;
                                                                          if (gSensitiveLoggingEnabled != 1
                                                                            || mDNSLogCategory_Default == mDNSLogCategory_State)
                                                                          {
                                                                            char v16 = (void *)a10;
                                                                            if (!os_log_type_enabled( (os_log_t)mDNSLogCategory_Default,  OS_LOG_TYPE_FAULT)) {
                                                                              goto LABEL_1535;
                                                                            }
                                                                          }

                                                                          else
                                                                          {
                                                                            uint64_t v688 = mDNSLogCategory_Default_redacted;
                                                                            char v16 = (void *)a10;
                                                                            if (!os_log_type_enabled( (os_log_t)mDNSLogCategory_Default_redacted,  OS_LOG_TYPE_FAULT)) {
                                                                              goto LABEL_1535;
                                                                            }
                                                                          }

                                                                          LODWORD(v973[0]) = 136447234;
                                                                          *(void *)((char *)v973 + 4) = "primary_name_server_len + sizeof(rdata_soa_t) < rdata_len";
                                                                          WORD6(v973[0]) = 2082;
                                                                          *(void *)((char *)v973 + 14) = "";
                                                                          WORD3(v973[1]) = 2082;
                                                                          LOWORD(v974) = 1024;
                                                                          *(_DWORD *)((char *)&v974 + 2) = 123;
                                                                          WORD3(v974) = 2048;
                                                                          *((void *)&v973[1] + 1) = "/Library/Caches/com.apple.xbs/Sources/mDNSResponder/mDNSShared/dns_objects/utilities/rdata_parser.c";
                                                                          *((void *)&v974 + 1) = 0LL;
                                                                          v665 = (os_log_s *)v688;
                                                                        }

                                                                        else
                                                                        {
                                                                          v658 = &v961[v656];
                                                                          int v659 = *v658;
                                                                          if (*v658)
                                                                          {
                                                                            v660 = v658;
                                                                            while (!v599 || &v660[v659 + 1] <= v599)
                                                                            {
                                                                              v661 = &v660[v659];
                                                                              int v662 = v661[1];
                                                                              v660 = v661 + 1;
                                                                              int v659 = v662;
                                                                              if (!v662) {
                                                                                goto LABEL_1505;
                                                                              }
                                                                            }

                                                                            goto LABEL_1514;
                                                                          }

                                                                          v660 = v658;
LABEL_1505:
                                                                          if (v660 - v658 == -1)
                                                                          {
LABEL_1514:
                                                                            uint64_t v670 = mDNSLogCategory_Default;
                                                                            if (gSensitiveLoggingEnabled != 1
                                                                              || mDNSLogCategory_Default == mDNSLogCategory_State)
                                                                            {
                                                                              char v16 = (void *)a10;
                                                                              if (!os_log_type_enabled( (os_log_t)mDNSLogCategory_Default,  OS_LOG_TYPE_FAULT)) {
                                                                                goto LABEL_1535;
                                                                              }
                                                                            }

                                                                            else
                                                                            {
                                                                              uint64_t v670 = mDNSLogCategory_Default_redacted;
                                                                              BOOL v676 = os_log_type_enabled( (os_log_t)mDNSLogCategory_Default_redacted,  OS_LOG_TYPE_FAULT);
                                                                              char v16 = (void *)a10;
                                                                              if (!v676) {
                                                                                goto LABEL_1535;
                                                                              }
                                                                            }

                                                                            LODWORD(v973[0]) = 136447234;
                                                                            *(void *)((char *)v973 + 4) = "mailbox_name_len >= 1";
                                                                            WORD6(v973[0]) = 2082;
                                                                            *(void *)((char *)v973 + 14) = "";
                                                                            WORD3(v973[1]) = 2082;
                                                                            LOWORD(v974) = 1024;
                                                                            *(_DWORD *)((char *)&v974 + 2) = 127;
                                                                            WORD3(v974) = 2048;
                                                                            *((void *)&v973[1] + 1) = "/Library/Caches/com.apple.xbs/Sources/mDNSResponder/mDNSShared/dns_objects/utilities/rdata_parser.c";
                                                                            *((void *)&v974 + 1) = 0LL;
                                                                            v665 = (os_log_s *)v670;
                                                                          }

                                                                          else
                                                                          {
                                                                            if (v657 + v660 - v658 + 1 == WORD2(xmmword_100161FA8))
                                                                            {
                                                                              v666 = calloc(1uLL, 0x50uLL);
                                                                              if (!v666) {
LABEL_1999:
                                                                              }
                                                                                __break(1u);
                                                                              v667 = &_dnssec_obj_rr_soa_kind;
                                                                              v877 = v666;
                                                                              v666[1] = &_dnssec_obj_rr_soa_kind;
                                                                              do
                                                                              {
                                                                                v668 = (void (*)(void *))v667[2];
                                                                                if (v668) {
                                                                                  v668(v877);
                                                                                }
                                                                                v667 = (_UNKNOWN **)*v667;
                                                                              }

                                                                              while (v667);
                                                                              ++*(_DWORD *)v877;
                                                                              dnssec_obj_rr_init_fields( (uint64_t)v877,  v597,  6,  1,  v961,  v598,  1,  0LL,  &v915);
                                                                              int v669 = v915;
                                                                              if (v915)
                                                                              {
                                                                                int v913 = v915;
                                                                                ref_count_obj_release(v877);
                                                                                v877 = 0LL;
                                                                                a1 = v878;
LABEL_1613:
                                                                                char v16 = (void *)a10;
                                                                                goto LABEL_1401;
                                                                              }

                                                                              a1 = v878;
                                                                              char v16 = (void *)a10;
                                                                              goto LABEL_1536;
                                                                            }

                                                                            uint64_t v689 = mDNSLogCategory_Default;
                                                                            if (gSensitiveLoggingEnabled == 1
                                                                              && mDNSLogCategory_Default != mDNSLogCategory_State)
                                                                            {
                                                                              uint64_t v689 = mDNSLogCategory_Default_redacted;
                                                                              char v16 = (void *)a10;
                                                                              if (os_log_type_enabled( (os_log_t)mDNSLogCategory_Default_redacted,  OS_LOG_TYPE_FAULT))
                                                                              {
                                                                                goto LABEL_1594;
                                                                              }

LABEL_1535:
                                                                              v877 = 0LL;
                                                                              int v669 = -6705;
LABEL_1536:
                                                                              int v913 = v669;
                                                                              goto LABEL_1401;
                                                                            }

                                                                            char v16 = (void *)a10;
                                                                            if (!os_log_type_enabled( (os_log_t)mDNSLogCategory_Default,  OS_LOG_TYPE_FAULT)) {
                                                                              goto LABEL_1535;
                                                                            }
LABEL_1594:
                                                                            LODWORD(v973[0]) = 136447234;
                                                                            *(void *)((char *)v973 + 4) = "primary_name_server_len + mailbox_name_len + sizeof(rdata_soa_t) == rdata_len";
                                                                            WORD6(v973[0]) = 2082;
                                                                            *(void *)((char *)v973 + 14) = "";
                                                                            WORD3(v973[1]) = 2082;
                                                                            LOWORD(v974) = 1024;
                                                                            *(_DWORD *)((char *)&v974 + 2) = 129;
                                                                            WORD3(v974) = 2048;
                                                                            *((void *)&v973[1] + 1) = "/Library/Caches/com.apple.xbs/Sources/mDNSResponder/mDNSShared/dns_objects/utilities/rdata_parser.c";
                                                                            *((void *)&v974 + 1) = 0LL;
                                                                            v665 = (os_log_s *)v689;
                                                                          }
                                                                        }
                                                                      }
                                                                    }

                                                                    _os_log_impl( (void *)&_mh_execute_header,  v665,  OS_LOG_TYPE_FAULT,  "AssertMacros: %{public}s, %{public}s file: %{publi c}s, line: %d, value: %ld",  (uint8_t *)v973,  0x30u);
                                                                    goto LABEL_1535;
                                                                  }
                                                                }

                                                                else if (WORD6(xmmword_100161F98) == 46)
                                                                {
                                                                  uint64_t v592 = dnssec_obj_rr_rrsig_create( (unsigned __int8 *)qword_100161FC0,  (const void *)(qword_100161FC8 + 4),  WORD2(xmmword_100161FA8),  1,  &v913);
                                                                  if (v913)
                                                                  {
                                                                    if (!v592) {
                                                                      goto LABEL_1401;
                                                                    }
                                                                    goto LABEL_1480;
                                                                  }

                                                                  unsigned int v649 = __rev16(**(unsigned __int16 **)(v592 + 24));
                                                                  if (v649 == 50 || v649 == 47)
                                                                  {
                                                                    unsigned int v650 = v912;
                                                                    if (v912 != 30)
                                                                    {
                                                                      v651 = &v912;
                                                                      v652 = v957;
LABEL_1479:
                                                                      *((void *)v652 + v650) = v592;
                                                                      ++*(_DWORD *)v592;
                                                                      *(_BYTE *)v651 = v650 + 1;
                                                                    }
                                                                  }

                                                                  else if (v649 == 6)
                                                                  {
                                                                    unsigned int v650 = HIBYTE(v912);
                                                                    if (HIBYTE(v912) != 30)
                                                                    {
                                                                      v651 = (__int16 *)((char *)&v912 + 1);
                                                                      v652 = v960;
                                                                      goto LABEL_1479;
                                                                    }
                                                                  }

LABEL_1401:
                                                              WORD4(xmmword_100161F9_Block_object_dispose(va, 8) = 0;
                                                              HIWORD(xmmword_100161FF_Block_object_dispose(va, 8) = 0;
                                                              if ((void)xmmword_100161FD8)
                                                              {
                                                                ref_count_obj_release((void *)xmmword_100161FD8);
                                                                *(void *)&xmmword_100161FD8 = 0LL;
                                                              }

                                                              ++v588;
                                                            }

                                                            while (v588 < v891 && (unint64_t)v587 < v585);
                                                          }
                                                        }

                                                        else
                                                        {
                                                          LOBYTE(v863) = 0;
                                                        }
                                                      }

                                                      else
                                                      {
                                                        v877 = 0LL;
                                                        LOBYTE(v863) = 0;
                                                        LOBYTE(v865) = 0;
                                                        unsigned int v895 = 3601;
                                                      }

                                                      int v693 = v897;
                                                      if (v897 == 3601) {
                                                        int v693 = v895;
                                                      }
                                                      int v894 = 1;
                                                      a2 = v900;
                                                      uint64_t v473 = v847;
                                                      int v583 = v853;
                                                    }

                                                    else
                                                    {
                                                      int v693 = v897;
                                                    }

                                                    char v694 = v909 ^ 1;
                                                    if (!v504) {
                                                      char v694 = 1;
                                                    }
                                                    if ((v694 & 1) != 0)
                                                    {
                                                      if (!v504) {
                                                        goto LABEL_1755;
                                                      }
                                                      uint64_t v703 = 0LL;
                                                    }

                                                    else
                                                    {
                                                      int8x8_t v695 = v504[8];
                                                      if (*(void *)&v695 && !*(_DWORD *)(*(void *)&v695 + 32LL))
                                                      {
                                                        int v854 = v583;
                                                        if (!v886 && v865 | v863)
                                                        {
                                                          LODWORD(v973[0]) = 0;
                                                          if (v873) {
                                                            p_dst = 0LL;
                                                          }
                                                          else {
                                                            p_dst = (unsigned __int8 *)&__dst;
                                                          }
                                                          v697 = dnssec_obj_denial_of_existence_create( v480,  v832,  v839,  p_dst,  (unsigned __int8 *)v899,  v877,  (unsigned __int8 *)v960,  HIBYTE(v912),  (uint64_t)v959,  v865,  (uint64_t *)v958,  v863,  (uint64_t)v957,  v912,  (int *)v973);
                                                          char v698 = gSensitiveLoggingEnabled;
                                                          uint64_t v699 = mDNSLogCategory_DNSSEC;
                                                          if (mDNSLogCategory_DNSSEC == mDNSLogCategory_State) {
                                                            char v698 = 0;
                                                          }
                                                          uint64_t v886 = (uint64_t)v697;
                                                          if (v697)
                                                          {
                                                            if ((v698 & 1) != 0)
                                                            {
                                                              uint64_t v700 = mDNSLogCategory_DNSSEC_redacted;
                                                              if (os_log_type_enabled( (os_log_t)mDNSLogCategory_DNSSEC_redacted,  OS_LOG_TYPE_DEFAULT))
                                                              {
                                                                v701 = v480;
                                                                if (v480 == (unsigned __int8 *)-256LL)
                                                                {
                                                                  while (1)
                                                                  {
LABEL_1644:
                                                                    if (!v701) {
                                                                      goto LABEL_1684;
                                                                    }
                                                                    uint64_t v702 = *v701;
                                                                    if (!*v701) {
                                                                      break;
                                                                    }
                                                                    v701 += v702 + 1;
                                                                  }

                                                                  unsigned __int16 v713 = (_WORD)v701 - (_WORD)v480 + 1;
                                                                }

                                                                else
                                                                {
LABEL_1643:
                                                                  if (v701 < v480 + 256) {
                                                                    goto LABEL_1644;
                                                                  }
LABEL_1684:
                                                                  unsigned __int16 v713 = 257;
                                                                }

                                                                v717 = DNSTypeName(v839);
                                                                uint64_t v718 = *(unsigned int *)(v886 + 16);
                                                                v719 = "<fatal: this should never be returned>";
                                                                *(_DWORD *)v961 = 67110659;
                                                                *(_DWORD *)&v961[4] = v829;
                                                                *(_WORD *)&v961[8] = 2160;
                                                                *(void *)&v961[10] = 1752392040LL;
                                                                *(_WORD *)&v961[18] = 1040;
                                                                *(_DWORD *)&v961[20] = v713;
                                                                *(_WORD *)&v961[24] = 2101;
                                                                *(void *)&v961[26] = v480;
                                                                *(_WORD *)&v961[34] = 2160;
                                                                *(void *)&v961[36] = 1752392040LL;
                                                                *(_WORD *)&v961[44] = 2085;
                                                                *(void *)&v961[46] = v717;
                                                                *(_WORD *)&v961[54] = 2082;
                                                                *(void *)&v961[56] = v719;
                                                                v720 = (os_log_s *)v700;
                                                                goto LABEL_1696;
                                                              }
                                                            }

                                                            else if (os_log_type_enabled( (os_log_t)mDNSLogCategory_DNSSEC,  OS_LOG_TYPE_DEFAULT))
                                                            {
                                                              v708 = v480;
                                                              if (v480 == (unsigned __int8 *)-256LL)
                                                              {
                                                                while (1)
                                                                {
LABEL_1668:
                                                                  if (!v708) {
                                                                    goto LABEL_1685;
                                                                  }
                                                                  uint64_t v709 = *v708;
                                                                  if (!*v708) {
                                                                    break;
                                                                  }
                                                                  v708 += v709 + 1;
                                                                }

                                                                unsigned __int16 v714 = (_WORD)v708 - (_WORD)v480 + 1;
                                                              }

                                                              else
                                                              {
LABEL_1667:
                                                                if (v708 < v480 + 256) {
                                                                  goto LABEL_1668;
                                                                }
LABEL_1685:
                                                                unsigned __int16 v714 = 257;
                                                              }

                                                              v721 = DNSTypeName(v839);
                                                              uint64_t v722 = *(unsigned int *)(v886 + 16);
                                                              v723 = "<fatal: this should never be returned>";
                                                              *(_DWORD *)v961 = 67110659;
                                                              *(_DWORD *)&v961[4] = v829;
                                                              *(_WORD *)&v961[8] = 2160;
                                                              *(void *)&v961[10] = 1752392040LL;
                                                              *(_WORD *)&v961[18] = 1040;
                                                              *(_DWORD *)&v961[20] = v714;
                                                              *(_WORD *)&v961[24] = 2101;
                                                              *(void *)&v961[26] = v480;
                                                              *(_WORD *)&v961[34] = 2160;
                                                              *(void *)&v961[36] = 1752392040LL;
                                                              *(_WORD *)&v961[44] = 2085;
                                                              *(void *)&v961[46] = v721;
                                                              *(_WORD *)&v961[54] = 2082;
                                                              *(void *)&v961[56] = v723;
                                                              v720 = (os_log_s *)v699;
LABEL_1696:
                                                              _os_log_impl( (void *)&_mh_execute_header,  v720,  OS_LOG_TYPE_DEFAULT,  "[Q%u] Create the denial of existence record set - qname: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P, qtype: %{sensitive, mask.hash}s, denial type: %{public}s",  v961,  0x40u);
                                                            }
                                                          }

                                                          else
                                                          {
                                                            if ((v698 & 1) != 0)
                                                            {
                                                              uint64_t v704 = mDNSLogCategory_DNSSEC_redacted;
                                                              if (!os_log_type_enabled( (os_log_t)mDNSLogCategory_DNSSEC_redacted,  OS_LOG_TYPE_FAULT)) {
                                                                goto LABEL_1702;
                                                              }
                                                              v705 = LODWORD(v973[0])
                                                                   ? "Unknown DNSSEC error."
                                                                   : "No error.";
                                                              v706 = v480;
                                                              if (v480 == (unsigned __int8 *)-256LL)
                                                              {
                                                                while (1)
                                                                {
LABEL_1660:
                                                                  if (!v706) {
                                                                    goto LABEL_1686;
                                                                  }
                                                                  uint64_t v707 = *v706;
                                                                  if (!*v706) {
                                                                    break;
                                                                  }
                                                                  v706 += v707 + 1;
                                                                }

                                                                unsigned __int16 v715 = (_WORD)v706 - (_WORD)v480 + 1;
                                                              }

                                                              else
                                                              {
LABEL_1659:
                                                                if (v706 < v480 + 256) {
                                                                  goto LABEL_1660;
                                                                }
LABEL_1686:
                                                                unsigned __int16 v715 = 257;
                                                              }

                                                              int v724 = v715;
                                                              v725 = DNSTypeName(v839);
                                                              *(_DWORD *)v961 = 67111683;
                                                              *(_DWORD *)&v961[4] = v829;
                                                              *(_WORD *)&v961[8] = 2082;
                                                              *(void *)&v961[10] = v705;
                                                              *(_WORD *)&v961[18] = 2160;
                                                              *(void *)&v961[20] = 1752392040LL;
                                                              *(_WORD *)&v961[28] = 1040;
                                                              *(_DWORD *)&v961[30] = v724;
                                                              *(_WORD *)&v961[34] = 2101;
                                                              *(void *)&v961[36] = v480;
                                                              *(_WORD *)&v961[44] = 2160;
                                                              *(void *)&v961[46] = 1752392040LL;
                                                              *(_WORD *)&v961[54] = 2085;
                                                              *(void *)&v961[56] = v725;
                                                              *(_WORD *)&v961[64] = 1024;
                                                              *(_DWORD *)&v961[66] = HIBYTE(v912);
                                                              *(_WORD *)&v961[70] = 1024;
                                                              *(_DWORD *)&v961[72] = v865;
                                                              *(_WORD *)&v961[76] = 1024;
                                                              *(_DWORD *)&v961[78] = v863;
                                                              *(_WORD *)&v961[82] = 1024;
                                                              *(_DWORD *)&v961[84] = v912;
                                                              v726 = (os_log_s *)v704;
                                                            }

                                                            else
                                                            {
                                                              if (!os_log_type_enabled( (os_log_t)mDNSLogCategory_DNSSEC,  OS_LOG_TYPE_FAULT)) {
                                                                goto LABEL_1702;
                                                              }
                                                              v710 = LODWORD(v973[0])
                                                                   ? "Unknown DNSSEC error."
                                                                   : "No error.";
                                                              v711 = v480;
                                                              if (v480 == (unsigned __int8 *)-256LL)
                                                              {
                                                                while (1)
                                                                {
LABEL_1679:
                                                                  if (!v711) {
                                                                    goto LABEL_1687;
                                                                  }
                                                                  uint64_t v712 = *v711;
                                                                  if (!*v711) {
                                                                    break;
                                                                  }
                                                                  v711 += v712 + 1;
                                                                }

                                                                unsigned __int16 v716 = (_WORD)v711 - (_WORD)v480 + 1;
                                                              }

                                                              else
                                                              {
LABEL_1678:
                                                                if (v711 < v480 + 256) {
                                                                  goto LABEL_1679;
                                                                }
LABEL_1687:
                                                                unsigned __int16 v716 = 257;
                                                              }

                                                              int v727 = v716;
                                                              v728 = DNSTypeName(v839);
                                                              *(_DWORD *)v961 = 67111683;
                                                              *(_DWORD *)&v961[4] = v829;
                                                              *(_WORD *)&v961[8] = 2082;
                                                              *(void *)&v961[10] = v710;
                                                              *(_WORD *)&v961[18] = 2160;
                                                              *(void *)&v961[20] = 1752392040LL;
                                                              *(_WORD *)&v961[28] = 1040;
                                                              *(_DWORD *)&v961[30] = v727;
                                                              *(_WORD *)&v961[34] = 2101;
                                                              *(void *)&v961[36] = v480;
                                                              *(_WORD *)&v961[44] = 2160;
                                                              *(void *)&v961[46] = 1752392040LL;
                                                              *(_WORD *)&v961[54] = 2085;
                                                              *(void *)&v961[56] = v728;
                                                              *(_WORD *)&v961[64] = 1024;
                                                              *(_DWORD *)&v961[66] = HIBYTE(v912);
                                                              *(_WORD *)&v961[70] = 1024;
                                                              *(_DWORD *)&v961[72] = v865;
                                                              *(_WORD *)&v961[76] = 1024;
                                                              *(_DWORD *)&v961[78] = v863;
                                                              *(_WORD *)&v961[82] = 1024;
                                                              *(_DWORD *)&v961[84] = v912;
                                                              v726 = (os_log_s *)v699;
                                                            }

                                                            _os_log_impl( (void *)&_mh_execute_header,  v726,  OS_LOG_TYPE_FAULT,  "[Q%u] Unable to create the denial of existence record set - error: %{public}s, qname: %{sensitive, mask.hash, mdnsre sponder:domain_name}.*P, qtype: %{sensitive, mask.hash}s, soaRRSIGCount: %u, nsecCount: %u, nsec3Count: %u, rrsigCount: %u.",  v961,  0x58u);
                                                            a2 = v900;
                                                          }

LABEL_1702:
                                                          int8x8_t v695 = v504[8];
                                                          if (!*(void *)&v695) {
                                                            goto LABEL_1705;
                                                          }
                                                        }

                                                        if (*(_DWORD *)(*(void *)&v695 + 32LL)
                                                          || *(_BYTE *)(*(void *)&v695 + 40LL))
                                                        {
LABEL_1705:
                                                          uint64_t v729 = 0LL;
LABEL_1706:
                                                          if (v729 | v886) {
                                                            goto LABEL_1728;
                                                          }
                                                        }

                                                        else
                                                        {
                                                          uint64_t v729 = *(void *)(*(void *)&v695 + 48LL);
                                                          if (!v729 || !v886) {
                                                            goto LABEL_1706;
                                                          }
                                                          if (ref_count_obj_compare(v729, v886, 1LL))
                                                          {
LABEL_1728:
                                                            v735 = (os_log_s *)mDNSLogCategory_DNSSEC;
                                                            if (gSensitiveLoggingEnabled == 1
                                                              && mDNSLogCategory_DNSSEC != mDNSLogCategory_State)
                                                            {
                                                              v735 = (os_log_s *)mDNSLogCategory_DNSSEC_redacted;
                                                              if (os_log_type_enabled( (os_log_t)mDNSLogCategory_DNSSEC_redacted,  OS_LOG_TYPE_DEBUG))
                                                              {
                                                                v736 = v480;
                                                                while (1)
                                                                {
                                                                  if (!v736
                                                                    || (uint64_t v737 = *v736, v737 > 0x3F))
                                                                  {
LABEL_1747:
                                                                    unsigned __int16 v740 = 257;
                                                                    goto LABEL_1752;
                                                                  }

                                                                  if (!*v736) {
                                                                    break;
                                                                  }
                                                                  v736 += v737 + 1;
LABEL_1732:
                                                                  if (v736 >= v480 + 256) {
                                                                    goto LABEL_1747;
                                                                  }
                                                                }

                                                                unsigned __int16 v740 = (_WORD)v736 - (_WORD)v480 + 1;
LABEL_1752:
                                                                int v742 = v740;
                                                                v743 = DNSTypeName(v839);
                                                                *(_DWORD *)v961 = 141558787;
                                                                *(void *)&v961[4] = 1752392040LL;
                                                                *(_WORD *)&v961[12] = 1040;
                                                                *(_DWORD *)&v961[14] = v742;
                                                                *(_WORD *)&v961[18] = 2101;
                                                                *(void *)&v961[20] = v480;
                                                                *(_WORD *)&v961[28] = 2082;
                                                                *(void *)&v961[30] = v743;
                                                                _os_log_impl( (void *)&_mh_execute_header,  v735,  OS_LOG_TYPE_DEBUG,  "Denial of existence record changes, purging the old ne gative record - name: %{sensitive, mask.hash, mdnsresp onder:domain_name}.*P, type: %{public}s",  v961,  0x26u);
                                                              }

LABEL_1753:
                                                              mDNS_PurgeCacheResourceRecord( (unsigned int *)a1,  (uint64_t)v504);
                                                              if (v693 == 3601) {
                                                                int v693 = v854;
                                                              }
LABEL_1755:
                                                              uint64_t v703 = 0LL;
                                                              while (2)
                                                              {
                                                                MakeNegativeCacheRecord( a1,  v473,  (uint64_t)v480,  v477,  v953,  v954,  v693,  0LL,  a9,  *((_WORD *)a2 + 1));
                                                                if (v906 && *v889) {
                                                                  mdns_cache_metadata_set_extended_dns_error( *v889,  *(void **)(v906 + 160));
                                                                }
                                                                v744 = CacheGroupForName(a1, v477, v480);
                                                                if (v909)
                                                                {
                                                                  unsigned int v746 = *(_DWORD *)(a1 + 64);
                                                                  if (v746 <= 1) {
                                                                    uint64_t v747 = 1LL;
                                                                  }
                                                                  else {
                                                                    uint64_t v747 = v746;
                                                                  }
                                                                  uint64_t v748 = 2LL;
                                                                }

                                                                else
                                                                {
                                                                  uint64_t v748 = 0LL;
                                                                  uint64_t v747 = 1LL;
                                                                }

                                                                unsigned int v749 = v477 % 0x1F3;
                                                                uint64_t v750 = CreateNewCacheEntryEx( a1,  v749,  (uint64_t)v744,  v747,  1LL,  0LL,  v748,  v745);
                                                                uint64_t v757 = v750;
                                                                int v758 = v909;
                                                                if (v703) {
                                                                  int v758 = 0;
                                                                }
                                                                if (v758 == 1)
                                                                {
                                                                  if ((unint64_t)(v750 + 1) < 2)
                                                                  {
                                                                    uint64_t v703 = -1LL;
                                                                    goto LABEL_1770;
                                                                  }

                                                                  *(_BYTE *)(v750 + 12_Block_object_dispose(va, 8) = 1;
                                                                  uint64_t v703 = v750;
LABEL_1773:
                                                                  if (NewCacheEntry)
                                                                  {
                                                                    uint64_t v759 = *(void *)(v750 + 120);
                                                                    if (v759) {
                                                                      ReleaseCacheRecord(a1, v759);
                                                                    }
                                                                    *(void *)(v757 + 120) = NewCacheEntry;
                                                                  }

                                                                  if ((v909 & 1) != 0)
                                                                  {
                                                                    int v760 = *(_DWORD *)(v757 + 84);
                                                                    uint64_t v761 = a1 + 4LL * v749;
                                                                    if (*(_DWORD *)(v761 + 4272) - v760 >= 1) {
                                                                      *(_DWORD *)(v761 + 4272) = v760;
                                                                    }
                                                                    if (*(_DWORD *)(a1 + 88) - v760 >= 1)
                                                                    {
                                                                      uint64_t NewCacheEntry = 0LL;
                                                                      *(_DWORD *)(a1 + 8_Block_object_dispose(va, 8) = v760;
                                                                      goto LABEL_1784;
                                                                    }
                                                                  }

                                                                  else
                                                                  {
                                                                    *(_DWORD *)(v757 + 84) = 0;
                                                                    CacheRecordDeferredAdd( (void *)a1,  v757,  v751,  v752,  v753,  v754,  v755,  v756);
                                                                  }

                                                                  uint64_t NewCacheEntry = 0LL;
                                                                  goto LABEL_1784;
                                                                }

LABEL_1770:
                                                                if (v750) {
                                                                  goto LABEL_1773;
                                                                }
LABEL_1784:
                                                                *(_WORD *)v858 = 0;
                                                                *((_WORD *)v858 + 51) = 0;
                                                                v762 = (void *)*((void *)v858 + 7);
                                                                if (v762)
                                                                {
                                                                  ref_count_obj_release(v762);
                                                                  *((void *)v858 + 7) = 0LL;
                                                                }

                                                                if (!v555)
                                                                {
                                                                  v504 = 0LL;
                                                                  uint64_t v386 = v906;
                                                                  int v475 = v909;
                                                                  goto LABEL_1811;
                                                                }

                                                                --v555;
                                                                if (*v480) {
                                                                  v480 += *v480 + 1;
                                                                }
                                                                unsigned int v477 = DomainNameHashValue((unint64_t)v480);
                                                                continue;
                                                              }
                                                            }

                                                            if (!os_log_type_enabled( (os_log_t)mDNSLogCategory_DNSSEC,  OS_LOG_TYPE_DEBUG)) {
                                                              goto LABEL_1753;
                                                            }
                                                            v738 = v480;
LABEL_1740:
                                                            if (v738 < v480 + 256)
                                                            {
LABEL_1741:
                                                              while (v738)
                                                              {
                                                                uint64_t v739 = *v738;
                                                                if (!*v738)
                                                                {
                                                                  unsigned __int16 v740 = (_WORD)v738 - (_WORD)v480 + 1;
                                                                  goto LABEL_1752;
                                                                }

                                                                v738 += v739 + 1;
                                                              }
                                                            }

                                                            unsigned __int16 v740 = 257;
                                                            goto LABEL_1752;
                                                          }
                                                        }

                                                        v730 = (os_log_s *)mDNSLogCategory_DNSSEC;
                                                        if (gSensitiveLoggingEnabled != 1
                                                          || mDNSLogCategory_DNSSEC == mDNSLogCategory_State)
                                                        {
                                                          if (os_log_type_enabled( (os_log_t)mDNSLogCategory_DNSSEC,  OS_LOG_TYPE_DEBUG))
                                                          {
                                                            v733 = v480;
                                                            if (v480 == (unsigned __int8 *)-256LL)
                                                            {
                                                              while (1)
                                                              {
LABEL_1720:
                                                                if (!v733) {
                                                                  goto LABEL_1749;
                                                                }
                                                                uint64_t v734 = *v733;
                                                                if (!*v733) {
                                                                  break;
                                                                }
                                                                v733 += v734 + 1;
                                                              }

                                                              unsigned __int16 v741 = (_WORD)v733 - (_WORD)v480 + 1;
                                                            }

                                                            else
                                                            {
LABEL_1719:
                                                              if (v733 < v480 + 256) {
                                                                goto LABEL_1720;
                                                              }
LABEL_1749:
                                                              unsigned __int16 v741 = 257;
                                                            }

LABEL_1793:
                                                            int v763 = v741;
                                                            v764 = DNSTypeName(v839);
                                                            *(_DWORD *)v961 = 141558787;
                                                            *(void *)&v961[4] = 1752392040LL;
                                                            *(_WORD *)&v961[12] = 1040;
                                                            *(_DWORD *)&v961[14] = v763;
                                                            *(_WORD *)&v961[18] = 2101;
                                                            *(void *)&v961[20] = v480;
                                                            *(_WORD *)&v961[28] = 2082;
                                                            *(void *)&v961[30] = v764;
                                                            _os_log_impl( (void *)&_mh_execute_header,  v730,  OS_LOG_TYPE_DEBUG,  "Denial of existence record does not change, rescuing the o ld negative record - name: %{sensitive, mask.hash, mdnsres ponder:domain_name}.*P, type: %{public}s",  v961,  0x26u);
                                                          }
                                                        }

                                                        else
                                                        {
                                                          v730 = (os_log_s *)mDNSLogCategory_DNSSEC_redacted;
                                                          if (os_log_type_enabled( (os_log_t)mDNSLogCategory_DNSSEC_redacted,  OS_LOG_TYPE_DEBUG))
                                                          {
                                                            v731 = v480;
                                                            if (v480 == (unsigned __int8 *)-256LL)
                                                            {
                                                              while (1)
                                                              {
LABEL_1712:
                                                                if (!v731) {
                                                                  goto LABEL_1748;
                                                                }
                                                                uint64_t v732 = *v731;
                                                                if (!*v731) {
                                                                  break;
                                                                }
                                                                v731 += v732 + 1;
                                                              }

                                                              unsigned __int16 v741 = (_WORD)v731 - (_WORD)v480 + 1;
                                                            }

                                                            else
                                                            {
LABEL_1711:
                                                              if (v731 < v480 + 256) {
                                                                goto LABEL_1712;
                                                              }
LABEL_1748:
                                                              unsigned __int16 v741 = 257;
                                                            }

                                                            goto LABEL_1793;
                                                          }
                                                        }

                                                        int v583 = v854;
                                                      }

                                                      v504[16].i8[0] = 1;
                                                      if (v693 == 3601) {
                                                        int v693 = v583;
                                                      }
                                                      uint64_t v703 = (uint64_t)v504;
                                                    }

                                                    v765 = (os_log_s *)mDNSLogCategory_Default;
                                                    if (gSensitiveLoggingEnabled != 1
                                                      || mDNSLogCategory_Default == mDNSLogCategory_State)
                                                    {
                                                      if (os_log_type_enabled( (os_log_t)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT))
                                                      {
                                                        goto LABEL_1803;
                                                      }
                                                    }

                                                    else
                                                    {
                                                      v765 = (os_log_s *)mDNSLogCategory_Default_redacted;
                                                      if (os_log_type_enabled( (os_log_t)mDNSLogCategory_Default_redacted,  OS_LOG_TYPE_DEFAULT))
                                                      {
LABEL_1803:
                                                        int v766 = v951;
                                                        unsigned int v767 = bswap32(v952) >> 16;
                                                        __int32 v768 = v504[2].i32[0];
                                                        GetRRDisplayString_rdb( (unsigned __int8 *)&v504[1],  (unsigned __int16 *)(*(void *)&v504[6] + 4LL),  v861);
                                                        *(_DWORD *)v961 = 67110403;
                                                        *(_DWORD *)&v961[4] = v766;
                                                        *(_WORD *)&v961[8] = 1024;
                                                        *(_DWORD *)&v961[10] = v767;
                                                        *(_WORD *)&v961[14] = 1024;
                                                        *(_DWORD *)&v961[16] = v768;
                                                        a2 = v900;
                                                        *(_WORD *)&v961[20] = 1024;
                                                        *(_DWORD *)&v961[22] = v693;
                                                        *(_WORD *)&v961[26] = 2160;
                                                        *(void *)&v961[28] = 1752392040LL;
                                                        *(_WORD *)&v961[36] = 2085;
                                                        *(void *)&v961[38] = v861;
                                                        uint64_t v473 = v847;
                                                        _os_log_impl( (void *)&_mh_execute_header,  v765,  OS_LOG_TYPE_DEFAULT,  "[R%u->Q%u] mDNSCoreReceiveNoUnicastAnswers: Renewing negative TTL from %d to %d %{sensitive, mask.hash}s",  v961,  0x2Eu);
                                                      }
                                                    }

                                                    RefreshCacheRecord(a1, v504, v693);
                                                    int v475 = v909;
                                                    if (!v851)
                                                    {
                                                      int v769 = *(_DWORD *)(a1 + 64);
                                                      *(_DWORD *)(v902 + 256) = v769;
                                                      *(_DWORD *)(v902 + 224) = 0;
                                                      *(_DWORD *)(v902 + 20_Block_object_dispose(va, 8) = v769;
                                                      *(_DWORD *)(v902 + 212) = 3600000;
                                                      *(_BYTE *)(v902 + 332) = 0;
                                                      *(_BYTE *)(v902 + 62_Block_object_dispose(va, 8) = 0;
                                                    }

                                                    uint64_t v386 = v906;
                                                    if (NewCacheEntry)
                                                    {
                                                      uint64_t v770 = (uint64_t)v504[15];
                                                      if (v770) {
                                                        ReleaseCacheRecord(a1, v770);
                                                      }
                                                      v504[15] = (int8x8_t)NewCacheEntry;
                                                    }

                                                    uint64_t NewCacheEntry = 0LL;
LABEL_1811:
                                                    if (v703 == -1) {
                                                      int v771 = 0;
                                                    }
                                                    else {
                                                      int v771 = v475;
                                                    }
                                                    if (v771 != 1)
                                                    {
                                                      char v16 = (void *)a10;
                                                      goto LABEL_1868;
                                                    }

                                                    uint64_t v772 = *(void *)(v703 + 64);
                                                    if (!v772 {
                                                      || (*(_BYTE *)(v703 + 12_Block_object_dispose(va, 8) = 0, !*(_DWORD *)(v772 + 32))
                                                    }
                                                      && !*(_BYTE *)(v772 + 40)
                                                      && *(void *)(v772 + 48))
                                                    {
                                                      char v16 = (void *)a10;
                                                      goto LABEL_1867;
                                                    }

                                                    if (!v886 && v865 | v863)
                                                    {
                                                      LODWORD(v973[0]) = 0;
                                                      if (v873) {
                                                        v773 = 0LL;
                                                      }
                                                      else {
                                                        v773 = (unsigned __int8 *)&__dst;
                                                      }
                                                      v774 = dnssec_obj_denial_of_existence_create( v480,  v832,  v839,  v773,  (unsigned __int8 *)v899,  v877,  (unsigned __int8 *)v960,  HIBYTE(v912),  (uint64_t)v959,  v865,  (uint64_t *)v958,  v863,  (uint64_t)v957,  v912,  (int *)v973);
                                                      char v775 = gSensitiveLoggingEnabled;
                                                      v776 = (os_log_s *)mDNSLogCategory_DNSSEC;
                                                      if (mDNSLogCategory_DNSSEC == mDNSLogCategory_State) {
                                                        char v775 = 0;
                                                      }
                                                      if (!v774)
                                                      {
                                                        if ((v775 & 1) != 0)
                                                        {
                                                          v776 = (os_log_s *)mDNSLogCategory_DNSSEC_redacted;
                                                          char v16 = (void *)a10;
                                                          if (os_log_type_enabled( (os_log_t)mDNSLogCategory_DNSSEC_redacted,  OS_LOG_TYPE_FAULT))
                                                          {
                                                            if (LODWORD(v973[0])) {
                                                              v780 = "Unknown DNSSEC error.";
                                                            }
                                                            else {
                                                              v780 = "No error.";
                                                            }
                                                            if (!v480)
                                                            {
                                                              int v791 = 0;
                                                              goto LABEL_1923;
                                                            }

                                                            v781 = v480;
                                                            while (2)
                                                            {
                                                              unsigned __int16 v782 = 257;
                                                              if (v781 >= v480 + 256 || !v781)
                                                              {
LABEL_1920:
                                                                int v791 = v782;
                                                                goto LABEL_1923;
                                                              }

LABEL_1850:
                                                              uint64_t v783 = *v781;
                                                              if (v783 <= 0x3F)
                                                              {
                                                                if (!*v781)
                                                                {
                                                                  unsigned __int16 v782 = (_WORD)v781 - (_WORD)v480 + 1;
                                                                  goto LABEL_1920;
                                                                }

                                                                v781 += v783 + 1;
LABEL_1849:
                                                                if (v781) {
                                                                  goto LABEL_1850;
                                                                }
                                                              }

                                                              break;
                                                            }

                                                            unsigned __int16 v782 = 257;
                                                            goto LABEL_1920;
                                                          }

LABEL_1924:
                                                          uint64_t v886 = 0LL;
                                                          goto LABEL_1867;
                                                        }

                                                        char v16 = (void *)a10;
                                                        if (!os_log_type_enabled( (os_log_t)mDNSLogCategory_DNSSEC,  OS_LOG_TYPE_FAULT)) {
                                                          goto LABEL_1924;
                                                        }
                                                        if (LODWORD(v973[0])) {
                                                          v780 = "Unknown DNSSEC error.";
                                                        }
                                                        else {
                                                          v780 = "No error.";
                                                        }
                                                        if (!v480)
                                                        {
                                                          int v791 = 0;
                                                          goto LABEL_1923;
                                                        }

                                                        v787 = v480;
                                                        if (v480 == (unsigned __int8 *)-256LL)
                                                        {
LABEL_1878:
                                                          if (v787) {
                                                            goto LABEL_1879;
                                                          }
                                                        }

                                                        else
                                                        {
                                                          while (2)
                                                          {
                                                            unsigned __int16 v788 = 257;
                                                            if (v787 >= v480 + 256 || !v787)
                                                            {
LABEL_1922:
                                                              int v791 = v788;
LABEL_1923:
                                                              v798 = DNSTypeName(v839);
                                                              *(_DWORD *)v961 = 67111683;
                                                              *(_DWORD *)&v961[4] = v829;
                                                              *(_WORD *)&v961[8] = 2082;
                                                              *(void *)&v961[10] = v780;
                                                              *(_WORD *)&v961[18] = 2160;
                                                              *(void *)&v961[20] = 1752392040LL;
                                                              *(_WORD *)&v961[28] = 1040;
                                                              *(_DWORD *)&v961[30] = v791;
                                                              *(_WORD *)&v961[34] = 2101;
                                                              *(void *)&v961[36] = v480;
                                                              *(_WORD *)&v961[44] = 2160;
                                                              *(void *)&v961[46] = 1752392040LL;
                                                              *(_WORD *)&v961[54] = 2085;
                                                              *(void *)&v961[56] = v798;
                                                              *(_WORD *)&v961[64] = 1024;
                                                              *(_DWORD *)&v961[66] = HIBYTE(v912);
                                                              *(_WORD *)&v961[70] = 1024;
                                                              *(_DWORD *)&v961[72] = v865;
                                                              *(_WORD *)&v961[76] = 1024;
                                                              *(_DWORD *)&v961[78] = v863;
                                                              *(_WORD *)&v961[82] = 1024;
                                                              *(_DWORD *)&v961[84] = v912;
                                                              _os_log_impl( (void *)&_mh_execute_header,  v776,  OS_LOG_TYPE_FAULT,  "[Q%u] Unable to create the denial of existence record se t - error: %{public}s, qname: %{sensitive, mask.hash, md nsresponder:domain_name}.*P, qtype: %{sensitive, mask.ha sh}s, soaRRSIGCount: %u, nsecCount: %u, nsec3Count: %u, rrsigCount: %u.",  v961,  0x58u);
                                                              goto LABEL_1924;
                                                            }

LABEL_1879:
                                                            uint64_t v789 = *v787;
                                                            if (v789 <= 0x3F)
                                                            {
                                                              if (!*v787)
                                                              {
                                                                unsigned __int16 v788 = (_WORD)v787 - (_WORD)v480 + 1;
                                                                goto LABEL_1922;
                                                              }

                                                              v787 += v789 + 1;
                                                              goto LABEL_1878;
                                                            }

                                                            break;
                                                          }
                                                        }

                                                        unsigned __int16 v788 = 257;
                                                        goto LABEL_1922;
                                                      }

                                                      uint64_t v886 = (uint64_t)v774;
                                                      if ((v775 & 1) != 0)
                                                      {
                                                        v776 = (os_log_s *)mDNSLogCategory_DNSSEC_redacted;
                                                        if (os_log_type_enabled( (os_log_t)mDNSLogCategory_DNSSEC_redacted,  OS_LOG_TYPE_DEFAULT))
                                                        {
                                                          if (v480)
                                                          {
                                                            v777 = v480;
LABEL_1830:
                                                            unsigned __int16 v778 = 257;
                                                            if (v777 < v480 + 256 && v777)
                                                            {
                                                              while (1)
                                                              {
                                                                uint64_t v779 = *v777;
                                                                if (v779 > 0x3F)
                                                                {
LABEL_1885:
                                                                  unsigned __int16 v778 = 257;
                                                                  goto LABEL_1890;
                                                                }

                                                                if (!*v777) {
                                                                  break;
                                                                }
                                                                v777 += v779 + 1;
LABEL_1833:
                                                                if (!v777) {
                                                                  goto LABEL_1885;
                                                                }
                                                              }

                                                              unsigned __int16 v778 = (_WORD)v777 - (_WORD)v480 + 1;
                                                            }

LABEL_1890:
                                                            int v790 = v778;
                                                          }

                                                          else
                                                          {
                                                            int v790 = 0;
                                                          }

                                                          v792 = DNSTypeName(v839);
                                                          uint64_t v793 = *(unsigned int *)(v886 + 16);
                                                          v794 = "<fatal: this should never be returned>";
                                                          goto LABEL_1898;
                                                        }
                                                      }

                                                      else if (os_log_type_enabled( (os_log_t)mDNSLogCategory_DNSSEC,  OS_LOG_TYPE_DEFAULT))
                                                      {
                                                        if (v480)
                                                        {
                                                          v784 = v480;
LABEL_1857:
                                                          unsigned __int16 v785 = 257;
                                                          if (v784 < v480 + 256 && v784)
                                                          {
                                                            while (1)
                                                            {
                                                              uint64_t v786 = *v784;
                                                              if (v786 > 0x3F)
                                                              {
LABEL_1886:
                                                                unsigned __int16 v785 = 257;
                                                                goto LABEL_1895;
                                                              }

                                                              if (!*v784) {
                                                                break;
                                                              }
                                                              v784 += v786 + 1;
LABEL_1860:
                                                              if (!v784) {
                                                                goto LABEL_1886;
                                                              }
                                                            }

                                                            unsigned __int16 v785 = (_WORD)v784 - (_WORD)v480 + 1;
                                                          }

LABEL_1895:
                                                          int v790 = v785;
                                                        }

                                                        else
                                                        {
                                                          int v790 = 0;
                                                        }

                                                        v792 = DNSTypeName(v839);
                                                        uint64_t v795 = *(unsigned int *)(v886 + 16);
                                                        v794 = "<fatal: this should never be returned>";
LABEL_1898:
                                                        *(_DWORD *)v961 = 67110659;
                                                        *(_DWORD *)&v961[4] = v829;
                                                        *(_WORD *)&v961[8] = 2160;
                                                        *(void *)&v961[10] = 1752392040LL;
                                                        *(_WORD *)&v961[18] = 1040;
                                                        *(_DWORD *)&v961[20] = v790;
                                                        *(_WORD *)&v961[24] = 2101;
                                                        *(void *)&v961[26] = v480;
                                                        *(_WORD *)&v961[34] = 2160;
                                                        *(void *)&v961[36] = 1752392040LL;
                                                        *(_WORD *)&v961[44] = 2085;
                                                        *(void *)&v961[46] = v792;
                                                        *(_WORD *)&v961[54] = 2082;
                                                        *(void *)&v961[56] = v794;
                                                        _os_log_impl( (void *)&_mh_execute_header,  v776,  OS_LOG_TYPE_DEFAULT,  "[Q%u] Create the denial of existence record set - qname: %{sen sitive, mask.hash, mdnsresponder:domain_name}.*P, qtype: %{sen sitive, mask.hash}s, denial type: %{public}s",  v961,  0x40u);
                                                      }

                                                      uint64_t v772 = *(void *)(v703 + 64);
                                                      if (!v772)
                                                      {
                                                        uint64_t v799 = mDNSLogCategory_DNSSEC;
                                                        if (gSensitiveLoggingEnabled != 1
                                                          || mDNSLogCategory_DNSSEC == mDNSLogCategory_State)
                                                        {
                                                          char v16 = (void *)a10;
                                                          int v475 = v909;
                                                          int v533 = v881;
                                                          if (os_log_type_enabled( (os_log_t)mDNSLogCategory_DNSSEC,  OS_LOG_TYPE_FAULT))
                                                          {
LABEL_1928:
                                                            *(_DWORD *)v961 = 136447234;
                                                            *(void *)&v961[4] = "me->dnssec != NULL";
                                                            *(_WORD *)&v961[12] = 2082;
                                                            *(void *)&v961[14] = "";
                                                            *(_WORD *)&v961[22] = 2082;
                                                            *(void *)&v961[24] = "/Library/Caches/com.apple.xbs/Sources"
                                                                                   "/mDNSResponder/mDNSMacOSX/dnssec_v2/d"
                                                                                   "nssec_mdns_core.c";
                                                            *(_WORD *)&v961[32] = 1024;
                                                            *(_DWORD *)&v961[34] = 333;
                                                            *(_WORD *)&v961[38] = 2048;
                                                            *(void *)&v961[40] = 0LL;
                                                            v800 = (os_log_s *)v799;
LABEL_1943:
                                                            _os_log_impl( (void *)&_mh_execute_header,  v800,  OS_LOG_TYPE_FAULT,  "AssertMacros: %{public}s, %{public}s file: %{public}s, lin e: %d, value: %ld",  v961,  0x30u);
                                                            goto LABEL_1908;
                                                          }
                                                        }

                                                        else
                                                        {
                                                          uint64_t v799 = mDNSLogCategory_DNSSEC_redacted;
                                                          char v16 = (void *)a10;
                                                          int v475 = v909;
                                                          int v533 = v881;
                                                          if (os_log_type_enabled( (os_log_t)mDNSLogCategory_DNSSEC_redacted,  OS_LOG_TYPE_FAULT))
                                                          {
                                                            goto LABEL_1928;
                                                          }
                                                        }

                                                        goto LABEL_1908;
                                                      }
                                                    }

                                                    if (*(_DWORD *)(v772 + 32))
                                                    {
                                                      uint64_t v801 = mDNSLogCategory_DNSSEC;
                                                      char v16 = (void *)a10;
                                                      int v533 = v881;
                                                      if (gSensitiveLoggingEnabled != 1
                                                        || mDNSLogCategory_DNSSEC == mDNSLogCategory_State)
                                                      {
                                                        int v475 = v909;
                                                        if (os_log_type_enabled( (os_log_t)mDNSLogCategory_DNSSEC,  OS_LOG_TYPE_FAULT))
                                                        {
LABEL_1932:
                                                          *(_DWORD *)v961 = 136447234;
                                                          *(void *)&v961[4] = "me->aware_type == dnssec_aware_rr_to_validate";
                                                          *(_WORD *)&v961[12] = 2082;
                                                          *(void *)&v961[14] = "";
                                                          *(_WORD *)&v961[22] = 2082;
                                                          *(void *)&v961[24] = "/Library/Caches/com.apple.xbs/Sources/m"
                                                                                 "DNSResponder/mDNSMacOSX/dnssec_v2/dnsse"
                                                                                 "c_objs/dnssec_obj_resource_record_member.c";
                                                          *(_WORD *)&v961[32] = 1024;
                                                          *(_DWORD *)&v961[34] = 159;
                                                          *(_WORD *)&v961[38] = 2048;
                                                          *(void *)&v961[40] = 0LL;
                                                          v800 = (os_log_s *)v801;
                                                          goto LABEL_1943;
                                                        }
                                                      }

                                                      else
                                                      {
                                                        uint64_t v801 = mDNSLogCategory_DNSSEC_redacted;
                                                        int v475 = v909;
                                                        if (os_log_type_enabled( (os_log_t)mDNSLogCategory_DNSSEC_redacted,  OS_LOG_TYPE_FAULT))
                                                        {
                                                          goto LABEL_1932;
                                                        }
                                                      }
                                                    }

                                                    else
                                                    {
                                                      char v16 = (void *)a10;
                                                      int v533 = v881;
                                                      if (!*(_BYTE *)(v772 + 40))
                                                      {
                                                        if (v886) {
                                                          ++*(_DWORD *)v886;
                                                        }
                                                        v796 = *(void **)(v772 + 48);
                                                        if (v796) {
                                                          ref_count_obj_release(v796);
                                                        }
                                                        *(void *)(v772 + 4_Block_object_dispose(va, 8) = v886;
LABEL_1907:
                                                        int v475 = v909;
                                                        goto LABEL_1908;
                                                      }

                                                      uint64_t v802 = mDNSLogCategory_DNSSEC;
                                                      if (gSensitiveLoggingEnabled != 1
                                                        || mDNSLogCategory_DNSSEC == mDNSLogCategory_State)
                                                      {
                                                        int v475 = v909;
                                                        if (os_log_type_enabled( (os_log_t)mDNSLogCategory_DNSSEC,  OS_LOG_TYPE_FAULT))
                                                        {
LABEL_1942:
                                                          *(_DWORD *)v961 = 136447234;
                                                          *(void *)&v961[4] = "!me->u.rr_to_validate.positive";
                                                          *(_WORD *)&v961[12] = 2082;
                                                          *(void *)&v961[14] = "";
                                                          *(_WORD *)&v961[22] = 2082;
                                                          *(void *)&v961[24] = "/Library/Caches/com.apple.xbs/Sources/m"
                                                                                 "DNSResponder/mDNSMacOSX/dnssec_v2/dnsse"
                                                                                 "c_objs/dnssec_obj_resource_record_member.c";
                                                          *(_WORD *)&v961[32] = 1024;
                                                          *(_DWORD *)&v961[34] = 160;
                                                          *(_WORD *)&v961[38] = 2048;
                                                          *(void *)&v961[40] = 0LL;
                                                          v800 = (os_log_s *)v802;
                                                          goto LABEL_1943;
                                                        }
                                                      }

                                                      else
                                                      {
                                                        uint64_t v802 = mDNSLogCategory_DNSSEC_redacted;
                                                        int v475 = v909;
                                                        if (os_log_type_enabled( (os_log_t)mDNSLogCategory_DNSSEC_redacted,  OS_LOG_TYPE_FAULT))
                                                        {
                                                          goto LABEL_1942;
                                                        }
                                                      }
                                                    }

                                                    goto LABEL_1908;
                                                  }
                                                }

                                                else
                                                {
                                                  int v475 = 0;
                                                  unsigned __int16 v899 = 0;
                                                  int v897 = 3601;
                                                  int v873 = 1;
                                                  if (!v505) {
                                                    goto LABEL_1274;
                                                  }
                                                }
                                              }

                                              else
                                              {
                                                unsigned __int16 v899 = 0;
                                                __int128 v933 = 0u;
                                                __int128 v932 = 0u;
                                                __int128 v931 = 0u;
                                                __int128 v930 = 0u;
                                                __int128 v929 = 0u;
                                                __int128 v928 = 0u;
                                                __int128 v927 = 0u;
                                                __int128 v926 = 0u;
                                                __int128 v925 = 0u;
                                                __int128 v924 = 0u;
                                                __int128 v923 = 0u;
                                                __int128 v922 = 0u;
                                                __int128 v921 = 0u;
                                                __int128 v920 = 0u;
                                                int v897 = 3601;
                                                int v873 = 1;
                                                __int128 v919 = 0u;
                                                __int128 __dst = 0u;
                                                if (!v505) {
                                                  goto LABEL_1274;
                                                }
                                              }

                                              uint64_t v524 = v511[2];
                                              if (!v524)
                                              {
                                                int v529 = 1;
                                                char v16 = (void *)a10;
                                                goto LABEL_1276;
                                              }

                                              uint64_t v386 = v906;
LABEL_1248:
                                              v525 = v504;
                                              if (v906)
                                              {
                                                v526 = *(void **)(v524 + 56);
                                                if (v526) {
                                                  v526 = (void *)v526[3];
                                                }
                                                if (v526 != a9 || !Client_SameNameCacheRecordIsAnswer(v524, v906)) {
                                                  goto LABEL_1269;
                                                }
LABEL_1256:
                                                if (*(_BYTE *)(v524 + 109)) {
                                                  int v527 = dword_100158BF8 + 939524096;
                                                }
                                                else {
                                                  int v527 = *(_DWORD *)(v524 + 80) + 1000 * *(_DWORD *)(v524 + 16);
                                                }
                                                if (((v527 - *(_DWORD *)(a1 + 64) > 0) & ~v475) != 0)
                                                {
                                                  int v529 = 0;
LABEL_1281:
                                                  a2 = v900;
                                                  char v16 = (void *)a10;
                                                  if (a10) {
                                                    goto LABEL_1286;
                                                  }
LABEL_1282:
                                                  if (v953 == 6) {
                                                    goto LABEL_1286;
                                                  }
                                                  BOOL v530 = IsLocalDomain(v955);
                                                  char v531 = v909;
                                                  if (!v530) {
                                                    char v531 = 1;
                                                  }
                                                  if ((v531 & 1) != 0) {
                                                    goto LABEL_1286;
                                                  }
                                                  if (!v529)
                                                  {
                                                    v556 = (os_log_s *)mDNSLogCategory_Default;
                                                    int v533 = v881;
                                                    if (gSensitiveLoggingEnabled != 1
                                                      || mDNSLogCategory_Default == mDNSLogCategory_State)
                                                    {
                                                      if (!os_log_type_enabled( (os_log_t)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT)) {
                                                        goto LABEL_1907;
                                                      }
                                                      int v557 = v951;
                                                      unsigned int v558 = bswap32(v952) >> 16;
                                                      for (n = v955; ; n += v563 + 1)
                                                      {
                                                        unsigned __int16 v560 = 257;
                                                        if (n >= v956 || !n) {
                                                          goto LABEL_1353;
                                                        }
                                                        uint64_t v563 = *n;
                                                        if (v563 > 0x3F)
                                                        {
                                                          unsigned __int16 v560 = 257;
                                                          goto LABEL_1353;
                                                        }

                                                        if (!*n) {
                                                          break;
                                                        }
                                                      }

                                                      unsigned __int16 v560 = (_WORD)n - (unsigned __int16)v955 + 1;
                                                    }

                                                    else
                                                    {
                                                      v556 = (os_log_s *)mDNSLogCategory_Default_redacted;
                                                      if (!os_log_type_enabled( (os_log_t)mDNSLogCategory_Default_redacted,  OS_LOG_TYPE_DEFAULT)) {
                                                        goto LABEL_1907;
                                                      }
                                                      int v557 = v951;
                                                      unsigned int v558 = bswap32(v952) >> 16;
                                                      for (iuint64_t i = v955; ; ii += v561 + 1)
                                                      {
                                                        unsigned __int16 v560 = 257;
                                                        if (ii >= v956 || !ii) {
                                                          goto LABEL_1353;
                                                        }
                                                        uint64_t v561 = *ii;
                                                        if (v561 > 0x3F)
                                                        {
                                                          unsigned __int16 v560 = 257;
                                                          goto LABEL_1353;
                                                        }

                                                        if (!*ii) {
                                                          break;
                                                        }
                                                      }

                                                      unsigned __int16 v560 = (_WORD)ii - (unsigned __int16)v955 + 1;
                                                    }

LABEL_1353:
                                                    int v566 = v560;
                                                    v567 = DNSTypeName(v953);
                                                    *(_DWORD *)v961 = 67110403;
                                                    *(_DWORD *)&v961[4] = v557;
                                                    *(_WORD *)&v961[8] = 1024;
                                                    *(_DWORD *)&v961[10] = v558;
                                                    *(_WORD *)&v961[14] = 2160;
                                                    *(void *)&v961[16] = 1752392040LL;
                                                    *(_WORD *)&v961[24] = 1040;
                                                    *(_DWORD *)&v961[26] = v566;
                                                    *(_WORD *)&v961[30] = 2101;
                                                    *(void *)&v961[32] = v955;
                                                    *(_WORD *)&v961[40] = 2082;
                                                    *(void *)&v961[42] = v567;
                                                    _os_log_impl( (void *)&_mh_execute_header,  v556,  OS_LOG_TYPE_DEFAULT,  "[R%u->Q%u] mDNSCoreReceiveNoUnicastAnswers: Skipping check and not creating a negative cache entry for %{sensitive, mask.hash, mdnsr esponder:domain_name}.*P (%{public}s)",  v961,  0x32u);
LABEL_1867:
                                                    int v475 = v909;
LABEL_1868:
                                                    int v533 = v881;
                                                    goto LABEL_1908;
                                                  }

                                                  int v533 = v881;
                                                  if (v851) {
                                                    goto LABEL_1907;
                                                  }
                                                  v534 = (os_log_s *)mDNSLogCategory_Default;
                                                  int v475 = v909;
                                                  if (gSensitiveLoggingEnabled != 1
                                                    || mDNSLogCategory_Default == mDNSLogCategory_State)
                                                  {
                                                    if (os_log_type_enabled( (os_log_t)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT))
                                                    {
                                                      int v539 = v951;
                                                      unsigned int v540 = bswap32(v952) >> 16;
                                                      for (juint64_t j = v955; ; jj += v565 + 1)
                                                      {
                                                        unsigned __int16 v542 = 257;
                                                        if (jj >= v956 || !jj) {
                                                          goto LABEL_1359;
                                                        }
                                                        uint64_t v565 = *jj;
                                                        if (v565 > 0x3F)
                                                        {
                                                          unsigned __int16 v542 = 257;
                                                          goto LABEL_1359;
                                                        }

                                                        if (!*jj) {
                                                          break;
                                                        }
                                                      }

                                                      unsigned __int16 v542 = (_WORD)jj - (unsigned __int16)v955 + 1;
LABEL_1359:
                                                      int v568 = v542;
                                                      v569 = DNSTypeName(v953);
                                                      *(_DWORD *)v961 = 67110403;
                                                      *(_DWORD *)&v961[4] = v539;
                                                      *(_WORD *)&v961[8] = 1024;
                                                      *(_DWORD *)&v961[10] = v540;
                                                      *(_WORD *)&v961[14] = 2160;
                                                      *(void *)&v961[16] = 1752392040LL;
                                                      *(_WORD *)&v961[24] = 1040;
                                                      *(_DWORD *)&v961[26] = v568;
                                                      *(_WORD *)&v961[30] = 2101;
                                                      *(void *)&v961[32] = v955;
                                                      *(_WORD *)&v961[40] = 2082;
                                                      *(void *)&v961[42] = v569;
                                                      _os_log_impl( (void *)&_mh_execute_header,  v534,  OS_LOG_TYPE_DEFAULT,  "[R%u->Q%u] mDNSCoreReceiveNoUnicastAnswers: Generate negative re sponse for %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%{public}s)",  v961,  0x32u);
                                                      int v475 = v909;
                                                      int v533 = v881;
                                                    }
                                                  }

                                                  else
                                                  {
                                                    v534 = (os_log_s *)mDNSLogCategory_Default_redacted;
                                                    if (os_log_type_enabled( (os_log_t)mDNSLogCategory_Default_redacted,  OS_LOG_TYPE_DEFAULT))
                                                    {
                                                      int v539 = v951;
                                                      unsigned int v540 = bswap32(v952) >> 16;
                                                      for (kuint64_t k = v955; ; kk += v543 + 1)
                                                      {
                                                        unsigned __int16 v542 = 257;
                                                        if (kk >= v956 || !kk) {
                                                          goto LABEL_1359;
                                                        }
                                                        uint64_t v543 = *kk;
                                                        if (v543 > 0x3F)
                                                        {
                                                          unsigned __int16 v542 = 257;
                                                          goto LABEL_1359;
                                                        }

                                                        if (!*kk) {
                                                          break;
                                                        }
                                                      }

                                                      unsigned __int16 v542 = (_WORD)kk - (unsigned __int16)v955 + 1;
                                                      goto LABEL_1359;
                                                    }
                                                  }

                                                  *(void *)(a1 + 216) = v902;
                                                  if (*(_BYTE *)(v902 + 632)) {
                                                    *(_WORD *)(v902 + 326) = *((_WORD *)a2 + 1);
                                                  }
                                                  GenerateNegativeResponseEx( a1,  0LL,  3LL,  *((unsigned __int16 *)a2 + 1),  v535,  v536,  v537,  v538,  v820);
                                                  *(void *)(a1 + 216) = 0LL;
LABEL_1908:
                                                  if (v475
                                                    && (uint64_t v797 = (v533 + 1),
                                                        int v881 = v797,
                                                        v797 < v856))
                                                  {
                                                    v480 = &v934[256 * v797];
                                                    unsigned int v477 = DomainNameHashValue((unint64_t)v480);
                                                  }

                                                  else
                                                  {
                                                    unsigned int v477 = 0;
                                                    v480 = 0LL;
                                                  }

                                                  if (!v869 && v886)
                                                  {
                                                    ref_count_obj_release((void *)v886);
                                                    uint64_t v886 = 0LL;
                                                  }

                                                  if (!v480)
                                                  {
                                                    int v471 = v828;
                                                    Question = v843;
                                                    goto LABEL_1944;
                                                  }

                                                  continue;
                                                }

                                                v504 = (int8x8_t *)v524;
                                                if (*(unsigned __int8 *)(v524 + 8) != 240)
                                                {
                                                  if (*(_BYTE *)(v524 + 10) == 2)
                                                  {
                                                    v528 = (os_log_s *)mDNSLogCategory_Default;
                                                    if (gSensitiveLoggingEnabled != 1
                                                      || mDNSLogCategory_Default == mDNSLogCategory_State)
                                                    {
                                                      if (os_log_type_enabled( (os_log_t)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT))
                                                      {
                                                        goto LABEL_1267;
                                                      }
                                                    }

                                                    else
                                                    {
                                                      v528 = (os_log_s *)mDNSLogCategory_Default_redacted;
                                                      if (os_log_type_enabled( (os_log_t)mDNSLogCategory_Default_redacted,  OS_LOG_TYPE_DEFAULT))
                                                      {
LABEL_1267:
                                                        GetRRDisplayString_rdb( (unsigned __int8 *)(v524 + 8),  (unsigned __int16 *)(*(void *)(v524 + 48) + 4LL),  v861);
                                                        *(_DWORD *)v961 = 141558275;
                                                        *(void *)&v961[4] = 1752392040LL;
                                                        *(_WORD *)&v961[12] = 2085;
                                                        *(void *)&v961[14] = v861;
                                                        _os_log_impl( (void *)&_mh_execute_header,  v528,  OS_LOG_TYPE_DEFAULT,  "mDNSCoreReceiveNoUnicastAnswers: Removing expired record%{sens itive, mask.hash}s",  v961,  0x16u);
                                                      }
                                                    }

                                                    a1 = v878;
                                                    mDNS_PurgeCacheResourceRecord((unsigned int *)v878, v524);
                                                  }

LABEL_1269:
                                                  v504 = v525;
                                                }

                                                uint64_t v524 = *(void *)v524;
                                                if (!v524)
                                                {
                                                  int v529 = 1;
                                                  goto LABEL_1281;
                                                }

                                                goto LABEL_1248;
                                              }

                                              break;
                                            }

                                            if (SameNameRecordAnswersQuestion( (unsigned __int8 *)(v524 + 8),  0,  v902,  v506,  v507,  v508,  v509,  v510))
                                            {
                                              goto LABEL_1256;
                                            }

                                            goto LABEL_1269;
                                          }

                                          uint64_t v476 = ExpectingUnicastResponseForQuestion( *(void *)(a1 + 200),  v825,  *(_WORD *)a2,  (uint64_t)v949,  __src == 0LL);
                                          int v475 = v909;
                                          if (v476)
                                          {
                                            int v828 = v471;
                                            int v832 = 0;
                                            BOOL v851 = 0;
                                            unsigned int v839 = 0;
                                            unsigned int v477 = v950;
                                            uint64_t v902 = v476;
                                            unsigned int v829 = bswap32(*(unsigned __int16 *)(v476 + 320)) >> 16;
                                            goto LABEL_1132;
                                          }
                                        }

LABEL_1944:
                                        BOOL v803 = ++v471 >= *((unsigned __int16 *)a2 + 2) || Question == 0LL;
                                        unint64_t v472 = v870;
                                        if (v803 || (unint64_t)Question >= v870)
                                        {
                                          unsigned __int8 v805 = v865;
                                          if (NewCacheEntry)
                                          {
                                            v806 = (os_log_s *)mDNSLogCategory_Default;
                                            if (gSensitiveLoggingEnabled != 1
                                              || mDNSLogCategory_Default == mDNSLogCategory_State)
                                            {
                                              if (os_log_type_enabled( (os_log_t)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT))
                                              {
                                                *(_WORD *)v961 = 0;
                                                goto LABEL_1965;
                                              }
                                            }

                                            else
                                            {
                                              v806 = (os_log_s *)mDNSLogCategory_Default_redacted;
                                              if (os_log_type_enabled( (os_log_t)mDNSLogCategory_Default_redacted,  OS_LOG_TYPE_DEFAULT))
                                              {
                                                *(_WORD *)v961 = 0;
LABEL_1965:
                                                _os_log_impl( (void *)&_mh_execute_header,  v806,  OS_LOG_TYPE_DEFAULT,  "mDNSCoreReceiveNoUnicastAnswers: SOARecord not used",  v961,  2u);
                                              }
                                            }

                                            ReleaseCacheRecord(a1, NewCacheEntry);
                                          }

                                          if (!v869)
                                          {
                                            if (v877) {
                                              ref_count_obj_release(v877);
                                            }
                                            unsigned __int8 v808 = v863;
LABEL_1971:
                                            uint64_t v810 = HIBYTE(v912);
                                            if (HIBYTE(v912))
                                            {
                                              v811 = (void **)v960;
                                              do
                                              {
                                                if (*v811)
                                                {
                                                  ref_count_obj_release(*v811);
                                                  *v811 = 0LL;
                                                }

                                                ++v811;
                                                --v810;
                                              }

                                              while (v810);
                                            }

                                            if (v805)
                                            {
                                              uint64_t v812 = v805;
                                              v813 = (void **)v959;
                                              do
                                              {
                                                if (*v813)
                                                {
                                                  ref_count_obj_release(*v813);
                                                  *v813 = 0LL;
                                                }

                                                ++v813;
                                                --v812;
                                              }

                                              while (v812);
                                            }

                                            if (v808)
                                            {
                                              uint64_t v814 = v808;
                                              v815 = (void **)v958;
                                              do
                                              {
                                                if (*v815)
                                                {
                                                  ref_count_obj_release(*v815);
                                                  *v815 = 0LL;
                                                }

                                                ++v815;
                                                --v814;
                                              }

                                              while (v814);
                                            }

                                            uint64_t v816 = v912;
                                            if ((_BYTE)v912)
                                            {
                                              v817 = (void **)v957;
                                              do
                                              {
                                                if (*v817)
                                                {
                                                  ref_count_obj_release(*v817);
                                                  *v817 = 0LL;
                                                }

                                                ++v817;
                                                --v816;
                                              }

                                              while (v816);
                                            }
                                          }

                                          goto LABEL_1991;
                                        }
                                      }
                                    }
                                  }

                                  if (!v467)
                                  {
                                    unsigned __int8 v808 = 0;
                                    unsigned __int8 v805 = 0;
                                    goto LABEL_1971;
                                  }

LABEL_1991:
                                  uint64_t v94 = v838;
                                }

                                if (v94) {
                                  os_release(v94);
                                }
                                return;
                              }

                              v379 = (os_log_s *)mDNSLogCategory_Default;
                              if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
                              {
                                if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
                                  goto LABEL_897;
                                }
                              }

                              else
                              {
                                v379 = (os_log_s *)mDNSLogCategory_Default_redacted;
                                if (os_log_type_enabled( (os_log_t)mDNSLogCategory_Default_redacted,  OS_LOG_TYPE_DEFAULT))
                                {
LABEL_897:
                                  __int32 v382 = v252[2].i32[0];
                                  GetRRDisplayString_rdb( (unsigned __int8 *)&v252[1],  (unsigned __int16 *)(*(void *)&v252[6] + 4LL),  v855);
                                  *(_DWORD *)v961 = 67109635;
                                  *(_DWORD *)&v961[4] = v382;
                                  *(_WORD *)&v961[8] = 2160;
                                  *(void *)&v961[10] = 1752392040LL;
                                  *(_WORD *)&v961[18] = 2085;
                                  *(void *)&v961[20] = v855;
                                  LOBYTE(v25) = v868;
                                  _os_log_impl( (void *)&_mh_execute_header,  v379,  OS_LOG_TYPE_DEFAULT,  "mDNSCoreReceiveCacheCheck: rescuing RR with new TTL %u: %{sensitive, mask.hash}s",  v961,  0x1Cu);
                                }
                              }

                              int8x8_t v383 = v252[8];
                              char v16 = (void *)a10;
                              if (*(void *)&v383 && !*(_DWORD *)(*(void *)&v383 + 32LL) && *(void *)&v252[12])
                              {
                                unsigned int v384 = *(_DWORD *)(v878 + 64);
                                if (v384 <= 1) {
                                  unsigned int v384 = 1;
                                }
                                *(_DWORD *)(v878 + 164) = v384;
                              }

                              goto LABEL_877;
                            }

                            a3 = v870;
                            if (v252[13].i8[5]) {
                              int v358 = dword_100158BF8 + 939524096;
                            }
                            else {
                              int v358 = v252[10].i32[0] + 1000 * v252[2].i32[0];
                            }
                            char v16 = (void *)a10;
                            uint64_t v94 = v837;
                            if (v358 - *(_DWORD *)(a1 + 64) < 1001)
                            {
                              char v300 = 0;
                              goto LABEL_673;
                            }

                            if (v252[1].i16[2] == 12)
                            {
                              v359 = (unsigned __int8 *)(*(void *)&v252[6] + 4LL);
                              int v360 = mDNS_DomainNameFNV1aHash(*(unsigned __int8 **)&v252[5]);
                              int v361 = mDNS_DomainNameFNV1aHash(v359);
                            }

                            else
                            {
                              int v360 = mDNS_DomainNameFNV1aHash(*(unsigned __int8 **)&v252[5]);
                              int v361 = 0;
                            }

                            *(void *)&v934[8] = 0LL;
                            *(void *)v934 = 0LL;
                            gettimeofday((timeval *)v934, 0LL);
                            int v367 = mDNSPlatformInterfaceIndexfromInterfaceID( (uint64_t **)a1,  a10,  1LL,  v362,  v363,  v364,  v365,  v366);
                            v368 = (os_log_s *)mDNSLogCategory_Default;
                            if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
                            {
                              if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
                                goto LABEL_867;
                              }
                            }

                            else
                            {
                              v368 = (os_log_s *)mDNSLogCategory_Default_redacted;
                              if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
                              {
LABEL_867:
                                int v369 = v252[1].u16[2];
                                *(_DWORD *)v961 = 67111171;
                                *(_DWORD *)&v961[4] = v360;
                                *(_WORD *)&v961[8] = 1024;
                                *(_DWORD *)&v961[10] = v369;
                                *(_WORD *)&v961[14] = 1040;
                                *(_DWORD *)&v961[16] = 16;
                                *(_WORD *)&v961[20] = 2098;
                                *(void *)&v961[22] = v934;
                                *(_WORD *)&v961[30] = 1024;
                                *(_DWORD *)&v961[32] = v367;
                                *(_WORD *)&v961[36] = 2160;
                                *(void *)&v961[38] = 1752392040LL;
                                *(_WORD *)&v961[46] = 1045;
                                *(_DWORD *)&v961[48] = 20;
                                *(_WORD *)&v961[52] = 2101;
                                *(void *)&v961[54] = (char *)v252 + 132;
                                *(_WORD *)&v961[62] = 1024;
                                *(_DWORD *)&v961[64] = v361;
                                _os_log_impl( (void *)&_mh_execute_header,  v368,  OS_LOG_TYPE_DEFAULT,  "Received Goodbye packet for cached record -- name hash: %x, type: %{mdns:rrtype}d, las t time received: %{public, timeval}.*P, interface index: %d, source address: %{sensiti ve, mask.hash, mdnsresponder:ip_addr}.20P, name hash if PTR: %x",  v961,  0x44u);
                              }
                            }

                            v252[2].i32[0] = 1;
                            a1 = v878;
                            v252[10].i32[0] = *(_DWORD *)(v878 + 64);
                            v252[13].i8[4] = 4;
                            SetNextCacheCheckTimeForRecord(v878, (uint64_t)v252);
                            char v300 = 0;
                            a3 = v870;
                            goto LABEL_894;
                          }

                          uint64_t v258 = *((void *)v858 + 7);
                          uint64_t v259 = (uint64_t)v252[8];
                        }

                        if (resource_records_have_same_dnssec_rr_category(v258, v259))
                        {
                          int v267 = *((unsigned __int16 *)v858 + 2);
                          a1 = v878;
                          char v16 = (void *)a10;
                          uint32_t v98 = v904;
                          if ((v267 == 5 || v252[1].i16[2] == 5)
                            && v252[2].i32[0]
                            && v267 != v252[1].u16[2]
                            && resource_record_as_rrsig_get_covered_type((uint64_t)v858) != 5
                            && resource_record_as_rrsig_get_covered_type((uint64_t)&v252[1]) != 5
                            && !resource_record_as_denial_of_existence_proves_wildcard_answer(v858)
                            && !resource_record_as_denial_of_existence_proves_wildcard_answer((unsigned __int8 *)&v252[1]))
                          {
                            v268 = (os_log_s *)mDNSLogCategory_Default;
                            if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
                            {
                              if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
                              {
                                int v282 = v252[1].u8[2];
                                v283 = "ghost";
                                if (v282 == 1) {
                                  v283 = "immortal";
                                }
                                BOOL v35 = v282 == 0;
                                v284 = "mortal";
                                if (!v35) {
                                  v284 = v283;
                                }
                                v823 = v284;
                                uint64_t v25 = v855;
                                GetRRDisplayString_rdb( (unsigned __int8 *)&v252[1],  (unsigned __int16 *)(*(void *)&v252[6] + 4LL),  v855);
                                v821 = DNSTypeName(v252[1].u16[2]);
                                if (v252[1].u8[0] == 240) {
                                  v272 = ", Negative";
                                }
                                else {
                                  v272 = "";
                                }
                                v273 = DNSTypeName(*((unsigned __int16 *)v858 + 2));
                                uint32_t v98 = v904;
                                v274 = "";
                                if (*v858 == 240) {
                                  v274 = ", Negative";
                                }
LABEL_618:
                                *(_DWORD *)v961 = 136447747;
                                *(void *)&v961[4] = v823;
                                *(_WORD *)&v961[12] = 2160;
                                *(void *)&v961[14] = 1752392040LL;
                                *(_WORD *)&v961[22] = 2085;
                                *(void *)&v961[24] = v25;
                                LOBYTE(v25) = v868;
                                *(_WORD *)&v961[32] = 2082;
                                *(void *)&v961[34] = v821;
                                *(_WORD *)&v961[42] = 2082;
                                *(void *)&v961[44] = v272;
                                a2 = v900;
                                *(_WORD *)&v961[52] = 2082;
                                *(void *)&v961[54] = v273;
                                *(_WORD *)&v961[62] = 2082;
                                *(void *)&v961[64] = v274;
                                _os_log_impl( (void *)&_mh_execute_header,  v268,  OS_LOG_TYPE_DEFAULT,  "mDNSCoreReceiveCacheCheck: Discarding (%{public}s) %{sensitive, mask.hash}s rrtype cha nge from (%{public}s%{public}s) to (%{public}s%{public}s)",  v961,  0x48u);
                              }
                            }

                            else
                            {
                              v268 = (os_log_s *)mDNSLogCategory_Default_redacted;
                              if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
                              {
                                int v269 = v252[1].u8[2];
                                v270 = "ghost";
                                if (v269 == 1) {
                                  v270 = "immortal";
                                }
                                BOOL v35 = v269 == 0;
                                v271 = "mortal";
                                if (!v35) {
                                  v271 = v270;
                                }
                                v823 = v271;
                                uint64_t v25 = v855;
                                GetRRDisplayString_rdb( (unsigned __int8 *)&v252[1],  (unsigned __int16 *)(*(void *)&v252[6] + 4LL),  v855);
                                v821 = DNSTypeName(v252[1].u16[2]);
                                if (v252[1].u8[0] == 240) {
                                  v272 = ", Negative";
                                }
                                else {
                                  v272 = "";
                                }
                                v273 = DNSTypeName(*((unsigned __int16 *)v858 + 2));
                                uint32_t v98 = v904;
                                v274 = "";
                                if (*v858 == 240) {
                                  v274 = ", Negative";
                                }
                                goto LABEL_618;
                              }
                            }

                            mDNS_PurgeCacheResourceRecord((unsigned int *)v878, (uint64_t)v252);
                            char v16 = (void *)a10;
                          }

LABEL_633:
                          uint64_t v94 = v837;
                          goto LABEL_634;
                        }

                        a1 = v878;
                        char v16 = (void *)a10;
                        uint64_t v94 = v837;
                        uint32_t v98 = v904;
LABEL_634:
                        v252 = (int8x8_t *)*v252;
                        if (!v252)
                        {
                          a3 = v870;
                          break;
                        }
                      }
                    }

                    uint64_t v23 = v858;
                    unsigned int v113 = v883;
                  }

                  else
                  {
                    uint64_t v846 = 0LL;
                  }

                  if (!*((_DWORD *)v23 + 2)) {
                    goto LABEL_701;
                  }
                  unsigned __int8 v289 = *v23;
                  if ((*v23 & 0x10) != 0)
                  {
                    unsigned int v295 = *(_DWORD *)(a1 + 64) + 1000;
                    if (v295 <= 1) {
                      uint64_t v290 = 1LL;
                    }
                    else {
                      uint64_t v290 = v295;
                    }
                  }

                  else
                  {
                    uint64_t v290 = CheckForSoonToExpireRecordsEx(a1, *((_BYTE **)v23 + 4), *((_DWORD *)v23 + 4), -1, -1);
                  }

                  uint64_t v296 = CreateNewCacheEntryEx(a1, v842, v846, v290, 1LL, (uint64_t)v848, v831, v108);
                  if (v296)
                  {
                    v252 = (int8x8_t *)v296;
                    unsigned __int16 v297 = *((_WORD *)a2 + 1);
                    *(_WORD *)(v296 + 110) = v297;
                    *(_BYTE *)(v296 + 9) = HIBYTE(v297) & 0xF;
                    if ((v289 & 0x10) != 0)
                    {
                      int8x8_t *v833 = (int8x8_t)v296;
                      char v300 = 1;
                      *(void *)(v296 + 112) = 1LL;
                      v833 = (int8x8_t *)(v296 + 112);
                    }

                    else
                    {
                      int v298 = *(_DWORD *)(v296 + 84);
                      if (v298)
                      {
                        uint64_t v299 = a1 + 4LL * v842;
                        if (*(_DWORD *)(v299 + 4272) - v298 >= 1) {
                          *(_DWORD *)(v299 + 4272) = v298;
                        }
                        if (*(_DWORD *)(a1 + 88) - v298 >= 1) {
                          *(_DWORD *)(a1 + 8_Block_object_dispose(va, 8) = v298;
                        }
                      }

                      char v300 = 1;
                    }

                    goto LABEL_673;
                  }

LABEL_674:
                  uint64_t v23 = v858;
LABEL_700:
                  unsigned int v113 = v883;
                  goto LABEL_701;
                }

                v341 = (os_log_s *)mDNSLogCategory_mDNS;
                BOOL v342 = gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State;
                uint64_t v23 = v858;
                if (v342)
                {
                  a3 = v870;
                  char v16 = (void *)a10;
                  unsigned int v113 = v883;
                  if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_ERROR))
                  {
                    uint64_t v343 = *(void *)(v845 + 32);
                    if (v343)
                    {
                      v344 = *(_BYTE **)(v845 + 32);
                      if (v343 == -256)
                      {
LABEL_776:
                        while (v344)
                        {
                          uint64_t v345 = *v344;
                          if (!*v344)
                          {
                            LOWORD(v344) = (_WORD)v344 - v343 + 1;
                            goto LABEL_822;
                          }

                          v344 += v345 + 1;
                          if (v343 != -256) {
                            goto LABEL_775;
                          }
                        }
                      }

                      else
                      {
LABEL_775:
                      }

                      LOWORD(v344) = 257;
LABEL_822:
                      LODWORD(v344) = (unsigned __int16)v344;
                    }

                    else
                    {
                      LODWORD(v344) = 0;
                    }

LABEL_825:
                    *(_DWORD *)v961 = 67110147;
                    *(_DWORD *)&v961[4] = v325;
                    *(_WORD *)&v961[8] = 1024;
                    *(_DWORD *)&v961[10] = 604800;
                    *(_WORD *)&v961[14] = 2160;
                    *(void *)&v961[16] = 1752392040LL;
                    *(_WORD *)&v961[24] = 1040;
                    *(_DWORD *)&v961[26] = (_DWORD)v344;
                    *(_WORD *)&v961[30] = 2101;
                    *(void *)&v961[32] = v343;
                    _os_log_impl( (void *)&_mh_execute_header,  v341,  OS_LOG_TYPE_ERROR,  "AddOrUpdateTSRForCacheGroup: tsrTimestamp[%u] out of range (%u) on TSR for %{sensitive, mask.hash, mdnsresponder:domain_name}.*P",  v961,  0x28u);
                  }
                }

                else
                {
                  v341 = (os_log_s *)mDNSLogCategory_mDNS_redacted;
                  BOOL v346 = os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_ERROR);
                  a3 = v870;
                  char v16 = (void *)a10;
                  unsigned int v113 = v883;
                  if (v346)
                  {
                    uint64_t v343 = *(void *)(v845 + 32);
                    if (v343)
                    {
                      v344 = *(_BYTE **)(v845 + 32);
                      if (v343 == -256)
                      {
LABEL_785:
                        while (v344)
                        {
                          uint64_t v347 = *v344;
                          if (!*v344)
                          {
                            LOWORD(v344) = (_WORD)v344 - v343 + 1;
                            goto LABEL_824;
                          }

                          v344 += v347 + 1;
                          if (v343 != -256) {
                            goto LABEL_784;
                          }
                        }
                      }

                      else
                      {
LABEL_784:
                      }

                      LOWORD(v344) = 257;
LABEL_824:
                      LODWORD(v344) = (unsigned __int16)v344;
                    }

                    else
                    {
                      LODWORD(v344) = 0;
                    }

                    goto LABEL_825;
                  }
                }

                a1 = v878;
                goto LABEL_527;
              }

              a1 = v878;
              a3 = v870;
              char v16 = (void *)a10;
              uint64_t v23 = v858;
            }

            uint64_t v94 = v837;
            goto LABEL_700;
        }

        unsigned int v113 = v883;
        if (!v112) {
          goto LABEL_206;
        }
LABEL_205:
        ref_count_obj_release(v112);
        *((void *)v23 + 7) = 0LL;
        goto LABEL_206;
      }
    }
  }

uint64_t IsResponseMDNSEquivalent(uint64_t a1, uint64_t a2)
{
  if (!a1) {
    return 1LL;
  }
  uint64_t v2 = *(_UNKNOWN ***)(a1 + 16);
  if (v2 != &_mdns_querier_kind)
  {
    if (v2 == &_mdns_subscriber_kind && a2 != 0) {
      return (*(unsigned __int16 *)(a2 + 276) >> 14) & 1;
    }
    return 1LL;
  }

  return 0LL;
}

_BYTE *DomainNamePtrAtTSRIndex(unsigned __int16 *a1, unint64_t a2, unsigned int a3)
{
  unsigned int v6 = a1[3];
  if (v6 >= a3)
  {
    Answers = LocateAnswers((unint64_t)a1, a2);
    LOWORD(v6) = 0;
    if (!Answers) {
      goto LABEL_13;
    }
    goto LABEL_10;
  }

  int v7 = a1[4];
  if (v7 + v6 >= a3)
  {
    Answers = LocateAuthorities((unint64_t)a1, a2);
    if (!Answers) {
      goto LABEL_13;
    }
    goto LABEL_10;
  }

  if (v7 + v6 + a1[5] < a3)
  {
    Answers = 0LL;
    goto LABEL_13;
  }

  Answers = LocateAdditionals((unint64_t)a1, a2);
  LOWORD(v6) = v7 + v6;
  if (Answers)
  {
LABEL_10:
    while (a3 > (unsigned __int16)v6)
    {
      Answers = skipResourceRecord((unint64_t)a1, Answers, a2);
      if (!Answers) {
        break;
      }
      LOWORD(v6) = v6 + 1;
    }
  }

char *UnsafeBufferPointer(unint64_t a1, unsigned __int8 *a2, unint64_t a3, uint64_t a4)
{
  if (!getDomainName(a1, a2, a3, __src))
  {
    int8x8_t v9 = (os_log_s *)mDNSLogCategory_mDNS;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_ERROR))
      {
LABEL_18:
        int v12 = *(_DWORD *)(a4 + 4);
        int v13 = *(_DWORD *)(a4 + 8);
        int v14 = *(unsigned __int16 *)(a4 + 12);
        v16[0] = 67109632;
        v16[1] = v12;
        __int16 v17 = 1024;
        int v18 = v13;
        __int16 v19 = 1024;
        int v20 = v14;
        _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_ERROR,  "TSRDataRecCreate: Bad RR domain name for TSR - tsrTime %d tsrHost %x recIndex %u",  (uint8_t *)v16,  0x14u);
      }
    }

    else
    {
      int8x8_t v9 = (os_log_s *)mDNSLogCategory_mDNS_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_ERROR)) {
        goto LABEL_18;
      }
    }

    return 0LL;
  }

  int v5 = (char *)calloc(1uLL, 0x118uLL);
  if (!v5) {
    __break(1u);
  }
  unsigned int v6 = v5;
  for (uint64_t i = (uint64_t *)__src; i < &v22; uint64_t i = (uint64_t *)((char *)i + v8 + 1))
  {
    if (!i) {
      break;
    }
    uint64_t v8 = *(unsigned __int8 *)i;
    if (!*(_BYTE *)i)
    {
      unsigned int v10 = (_DWORD)i - __src + 1;
      if ((unsigned __int16)v10 <= 0x100u)
      {
        memcpy(v5 + 20, __src, (unsigned __int16)v10);
        goto LABEL_16;
      }

      break;
    }
  }

  v5[20] = 0;
LABEL_16:
  uint64_t v11 = *(void *)(a4 + 4);
  *((_DWORD *)v6 + 4) = *(_DWORD *)(a4 + 12);
  *((void *)v6 + 1) = v11;
  return v6;
}

uint64_t PacketRRMatchesSignature( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
  {
    LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "PacketRRMatchesSignature ERROR: pktrr is NULL",  a4,  a5,  a6,  a7,  a8,  v14);
    return 0LL;
  }

  uint64_t v10 = *(void *)(a1 + 32);
  if (v10)
  {
    uint64_t v11 = *(void *)(a2 + 32);
    if (v11 && v10 != v11) {
      return 0LL;
    }
  }

  if (((*(_BYTE *)(a2 + 8) & 0x32) == 0 || *(_DWORD *)(a2 + 126))
    && *(unsigned __int16 *)(a1 + 12) != *(unsigned __int16 *)(a2 + 12))
  {
    return 0LL;
  }

  if (*(void *)(a2 + 32)
    || (uint64_t result = mDNSPlatformValidRecordForInterface(a2, v10, a3, a4, a5, a6, a7, a8), (_DWORD)result))
  {
    if (*(unsigned __int16 *)(a1 + 14) == *(unsigned __int16 *)(a2 + 14)
      && *(_DWORD *)(a1 + 24) == *(_DWORD *)(a2 + 24))
    {
      return SameDomainNameBytes(*(_BYTE **)(a1 + 40), *(_BYTE **)(a2 + 40)) != 0;
    }

    return 0LL;
  }

  return result;
}

uint64_t *CheckTSRForAuthRecord(uint64_t *a1, int *a2, int a3, _BYTE *a4)
{
  uint64_t result = mDNSGetTSRForAuthRecordNamed(a1, a4, a3);
  if (result) {
    return (uint64_t *)CheckTSRForResourceRecord(a2, (uint64_t)(result + 1));
  }
  return result;
}

uint64_t RecordInTheRRSet(uint64_t a1, uint64_t a2)
{
  int v4 = *(unsigned __int16 *)(a2 + 16);
  int v5 = *(unsigned __int16 *)(a1 + 4);
  int covered_type = resource_record_as_rrsig_get_covered_type(a1);
  BOOL v7 = v4 == v5 || covered_type == v4;
  if (v7 && *(_DWORD *)(a2 + 8) == *(_DWORD *)(a1 + 16)) {
    return SameDomainNameBytes(*(_BYTE **)a2, *(_BYTE **)(a1 + 32));
  }
  else {
    return 0LL;
  }
}

BOOL PacketRecordMatches(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_DWORD *)(a1 + 24) != *(_DWORD *)(a2 + 24)) {
    return 0LL;
  }
  uint64_t v5 = a1;
  if (!resource_records_have_same_dnssec_rr_category(*(void *)(a1 + 64), *(void *)(a2 + 64))
    || *(unsigned __int16 *)(v5 + 12) != *(unsigned __int16 *)(a2 + 12)
    || *(unsigned __int16 *)(v5 + 14) != *(unsigned __int16 *)(a2 + 14)
    || *(unsigned __int16 *)(v5 + 20) != *(unsigned __int16 *)(a2 + 20)
    || *(_DWORD *)(v5 + 28) != *(_DWORD *)(a2 + 28)
    || !SameRDataBody( v5 + 8,  (unsigned __int16 *)(*(void *)(a2 + 48) + 4LL),  (uint64_t (*)(uint64_t, unsigned __int16 *))SameDomainName)
    || !SameDomainNameBytes(*(_BYTE **)(v5 + 40), *(_BYTE **)(a2 + 40)))
  {
    return 0LL;
  }

  do
  {
    uint64_t v6 = v5;
    uint64_t v5 = *(void *)(v5 + 88);
  }

  while (v5);
  return v6 == a3;
}

void mDNSCoreReceiveUpdate( uint64_t a1, unint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, __int128 *a6, uint64_t a7, uint64_t a8)
{
  unsigned __int16 v9 = a7;
  unsigned __int16 v11 = a5;
  int v12 = (__int128 *)a4;
  __int128 v152 = 0uLL;
  int v153 = 0;
  if (mDNS_LoggingEnabled == 1) {
    LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "Received Update from %#-15a:%-5d to %#-15a:%-5d on 0x%p with %2d Question%s %2d Answer%s %2d Authorit%s %2d Additional%s %d bytes",  a4,  a5,  (uint64_t)a6,  a7,  a8,  a4);
  }
  if (a8)
  {
    char v16 = *(unsigned __int16 **)(a1 + 15048);
    if (v16)
    {
      bzero(v154, 0x498uLL);
      if (*v16 == v9)
      {
        __int16 v17 = (_BYTE *)(a1 + 37865);
        if (mDNS_PacketLoggingEnabled == 1) {
          DumpPacket(0, 0, (uint64_t)"UDP", v12, v11, a6, v9, (unsigned __int8 *)a2, a3, a8);
        }
        unint64_t v18 = a1 + 28916;
        OptRR = LocateOptRR(a2, a3, 20);
        if (OptRR)
        {
          unint64_t v25 = a1 + 28904;
          if (GetLargeResourceRecord(a1, a2, OptRR, a3, 0LL, 128, a1 + 37856)
            && *(unsigned __int8 *)(a1 + 37864) != 240
            && *(_WORD *)(a1 + 37868) == 41
            && (uint64_t v26 = (unsigned __int16 *)(*(void *)(a1 + 37904) + 4LL),
                unint64_t v27 = (unsigned __int16 *)((char *)v26 + *(unsigned __int16 *)(a1 + 37876)),
                v26 < v27))
          {
            unsigned int v28 = 0;
            do
            {
              int v29 = *v26;
              if (v29 == 4)
              {
                if (!*((_BYTE *)v26 + 4))
                {
                  __int128 v30 = *(_OWORD *)(v26 + 2);
                  int v153 = *((_DWORD *)v26 + 5);
                  __int128 v152 = v30;
                }
              }

              else if (v29 == 2)
              {
                unsigned int v28 = *((_DWORD *)v26 + 1);
              }

              v26 += 12;
            }

            while (v26 < v27);
          }

          else
          {
            unsigned int v28 = 0;
          }

          *(_BYTE *)(a1 + 37864) = 0;
          *(_WORD *)(a1 + 37966) = 0;
          _BYTE *v17 = 0;
          unsigned int v31 = *(void **)(a1 + 37920);
          if (v31)
          {
            ref_count_obj_release(v31);
            *(void *)(a1 + 37920) = 0LL;
          }
        }

        else
        {
          unsigned int v28 = 0;
          unint64_t v25 = a1 + 28904;
        }

        *(_WORD *)unint64_t v25 = *(_WORD *)a2;
        *(_WORD *)(v25 + 2) = 168;
        *(void *)(v25 + 4) = 0LL;
        if (v28 && *(_DWORD *)((char *)&v152 + 2))
        {
          uint64_t v150 = (int *)(a1 + 19832);
          if (*(_DWORD *)(a1 + 19832) + *(unsigned __int16 *)(a2 + 8) < 10001)
          {
            unsigned __int16 v146 = v11;
            uint64_t v147 = v12;
            if (mDNS_LoggingEnabled == 1) {
              LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "Received Update for H-MAC %.6a I-MAC %.6a Password %.6a seq %d",  v20,  v21,  v22,  v23,  v24,  (int)&v152 + 2);
            }
            if (v28 >= 0x15180) {
              int v34 = 86400;
            }
            else {
              int v34 = v28;
            }
            int v145 = v34;
            Authorities = LocateAuthorities(a2, a3);
            ClearKeepaliveProxyRecords(a1, (unsigned __int16 *)&v152, *(void *)(a1 + 12632), a8);
            ClearKeepaliveProxyRecords(a1, (unsigned __int16 *)&v152, *(void *)(a1 + 12624), a8);
            if (*(_WORD *)(a2 + 8) && Authorities && (unint64_t)Authorities < a3)
            {
              int v41 = 0;
              uint64_t v42 = a1 + 37856;
              BOOL v43 = (_BYTE *)(a1 + 37864);
              int v149 = 1000 * v145;
              do
              {
                Authorities = GetLargeResourceRecord(a1, a2, Authorities, a3, a8, 160, v42);
                if (Authorities && *v43 != 240)
                {
                  int v44 = *(unsigned __int16 *)(a1 + 37868);
                  switch(v44)
                  {
                    case 6:
                      size_t v45 = 532LL;
                      break;
                    case 26:
                      size_t v45 = 514LL;
                      break;
                    case 17:
                      size_t v45 = 512LL;
                      break;
                    default:
                      size_t v45 = *(unsigned __int16 *)(a1 + 37876);
                      break;
                  }

                  int v46 = calloc(1uLL, v45 + 912);
                  if (!v46) {
                    __break(1u);
                  }
                  uint64_t v47 = (uint64_t)v46;
                  if ((*v43 & 0x10) != 0) {
                    char v48 = 2;
                  }
                  else {
                    char v48 = 8;
                  }
                  char v151 = v48;
                  *(_WORD *)(a1 + 37870) &= ~0x8000u;
                  if (*(_WORD *)(a1 + 37868) != 10
                    || ((uint64_t v49 = *(_BYTE **)(a1 + 37896), *v49) ? (v50 = *v49 + 1LL) : (v50 = 0LL),
                        !SameDomainLabelPointer(&v49[v50], "\n_keepalive")))
                  {
                    ClearIdenticalProxyRecords(a1, (unsigned __int16 *)&v152, *(void *)(a1 + 12632));
                    ClearIdenticalProxyRecords(a1, (unsigned __int16 *)&v152, *(void *)(a1 + 12624));
                  }

                  mDNS_SetupResourceRecord( v47,  0LL,  a8,  *(_WORD *)(a1 + 37868),  *(_DWORD *)(a1 + 37872),  v151,  0,  (uint64_t)SPSRecordCallback,  v47);
                  unsigned int v57 = *(_BYTE **)(a1 + 37896);
                  uint64_t v58 = v57;
                  if (v57 == (_BYTE *)-256LL)
                  {
LABEL_63:
                    while (v58)
                    {
                      uint64_t v59 = *v58;
                      if (!*v58)
                      {
                        unsigned __int16 v60 = (_WORD)v58 - (_WORD)v57 + 1;
                        if (v60 > 0x100u) {
                          break;
                        }
                        memcpy((void *)(v47 + 652), v57, v60);
                        goto LABEL_71;
                      }

                      v58 += v59 + 1;
                      if (v57 != (_BYTE *)-256LL) {
                        goto LABEL_62;
                      }
                    }
                  }

                  else
                  {
LABEL_62:
                    if (v58 < v57 + 256) {
                      goto LABEL_63;
                    }
                  }

                  *(_BYTE *)(v47 + 652) = 0;
LABEL_71:
                  *(_WORD *)(v47 + 20) = GetRDLength((uint64_t)v43, 0, v51, v52, v53, v54, v55, v56);
                  uint64_t v61 = *(_WORD **)(v47 + 48);
                  *uint64_t v61 = v45;
                  memcpy(v61 + 2, (const void *)(*(void *)(a1 + 37904) + 4LL), v45);
                  *(_BYTE *)(v47 + 122) = 1;
                  *(_DWORD *)(v47 + 140) = v153;
                  *(_OWORD *)(v47 + 124) = v152;
                  if (*(_WORD *)(a1 + 37868) == 12)
                  {
                    uint64_t v69 = *(unsigned __int8 **)(a1 + 37896);
                    unsigned int v70 = *v69;
                    if (*v69)
                    {
                      int v71 = 0;
                      int v72 = -1;
                      uint64_t v73 = *(void *)(a1 + 37896);
                      do
                      {
                        int v74 = v71;
                        uint64_t v75 = v73 + v70;
                        unsigned int v76 = *(unsigned __int8 *)(v75 + 1);
                        uint64_t v73 = v75 + 1;
                        unsigned int v70 = v76;
                        ++v72;
                        ++v71;
                      }

                      while (v76);
                      if (v72 - 1 >= 0)
                      {
                        if (v72 != 1)
                        {
                          do
                          {
                            if (!*v69) {
                              break;
                            }
                            v69 += *v69 + 1;
                            --v74;
                          }

                          while (v74 > 1);
                        }

                        if (SameDomainNameBytes(v69, "\ain-addr\x04arpa"))
                        {
                          uint64_t v77 = *(_BYTE **)(a1 + 37896);
                          LODWORD(v7_Block_object_dispose(va, 8) = *v77;
                          if (!*v77) {
                            goto LABEL_121;
                          }
                          int v79 = -1;
                          int v80 = -2;
                          int v81 = -3;
                          LODWORD(v62) = -4;
                          unsigned int v82 = *v77;
                          uint64_t v83 = *(void *)(a1 + 37896);
                          do
                          {
                            int v84 = v79;
                            int v85 = v80;
                            int v86 = v81;
                            int v87 = v62;
                            uint64_t v88 = v83 + v82;
                            unsigned int v89 = *(unsigned __int8 *)(v88 + 1);
                            uint64_t v83 = v88 + 1;
                            unsigned int v82 = v89;
                            ++v79;
                            ++v80;
                            ++v81;
                            uint64_t v62 = (v62 + 1);
                          }

                          while (v89);
                          int v90 = v79 - 5;
                          if (v79 - 5 >= 0)
                          {
                            unsigned int v91 = *(_BYTE **)(a1 + 37896);
                            if (v79 - 2 < 1)
                            {
LABEL_89:
                              if ((v78 - 4) >= 0xFFFFFFFD)
                              {
                                int v92 = 0;
                                uint64_t v78 = v78;
                                unsigned int v93 = v91 + 1;
                                while (1)
                                {
                                  int v95 = *v93++;
                                  int v94 = v95;
                                  int v92 = v94 + 10 * v92 - 48;
                                  if (!--v78)
                                  {
                                    if (v92 <= 255)
                                    {
                                      *(_BYTE *)(v47 + 14_Block_object_dispose(va, 8) = v92;
                                      uint64_t v96 = v77;
                                      if (v79 - 3 >= 1)
                                      {
                                        uint64_t v96 = v77;
                                        do
                                        {
                                          if (!*v96) {
                                            break;
                                          }
                                          v96 += *v96 + 1;
                                          --v85;
                                        }

                                        while (v85 > 1);
                                      }

                                      uint64_t v97 = *v96;
                                      if ((v97 - 4) >= 0xFFFFFFFD)
                                      {
                                        int v98 = 0;
                                        int v99 = v96 + 1;
                                        while (1)
                                        {
                                          int v101 = *v99++;
                                          int v100 = v101;
                                          int v98 = v100 + 10 * v98 - 48;
                                          if (!--v97)
                                          {
                                            if (v98 <= 255)
                                            {
                                              *(_BYTE *)(v47 + 149) = v98;
                                              uint64_t v102 = v77;
                                              if (v79 - 4 >= 1)
                                              {
                                                uint64_t v102 = v77;
                                                do
                                                {
                                                  if (!*v102) {
                                                    break;
                                                  }
                                                  v102 += *v102 + 1;
                                                  --v86;
                                                }

                                                while (v86 > 1);
                                              }

                                              uint64_t v103 = *v102;
                                              if ((v103 - 4) >= 0xFFFFFFFD)
                                              {
                                                int v104 = 0;
                                                uint64_t v105 = v102 + 1;
                                                while (1)
                                                {
                                                  int v107 = *v105++;
                                                  int v106 = v107;
                                                  int v104 = v106 + 10 * v104 - 48;
                                                  if (!--v103)
                                                  {
                                                    if (v104 <= 255)
                                                    {
                                                      *(_BYTE *)(v47 + 150) = v104;
                                                      if (v90 >= 1)
                                                      {
                                                        do
                                                        {
                                                          if (!*v77) {
                                                            break;
                                                          }
                                                          v77 += *v77 + 1;
                                                          --v87;
                                                        }

                                                        while (v87 > 1);
                                                      }

                                                      uint64_t v108 = *v77;
                                                      if ((v108 - 4) >= 0xFFFFFFFD)
                                                      {
                                                        int v109 = 0;
                                                        int v110 = v77 + 1;
                                                        while (1)
                                                        {
                                                          int v112 = *v110++;
                                                          int v111 = v112;
                                                          int v109 = v111 + 10 * v109 - 48;
                                                          if (!--v108)
                                                          {
                                                            if (v109 > 255) {
                                                              goto LABEL_152;
                                                            }
                                                            *(_BYTE *)(v47 + 151) = v109;
                                                            int v113 = 4;
                                                            goto LABEL_150;
                                                          }
                                                        }
                                                      }
                                                    }

                                                    goto LABEL_152;
                                                  }
                                                }
                                              }
                                            }

                                            goto LABEL_152;
                                          }
                                        }
                                      }
                                    }

                                    break;
                                  }
                                }
                              }
                            }

                            else
                            {
                              unsigned int v91 = *(_BYTE **)(a1 + 37896);
                              while (*v91)
                              {
                                v91 += *v91 + 1;
                                if (--v84 <= 1)
                                {
                                  LODWORD(v7_Block_object_dispose(va, 8) = *v91;
                                  goto LABEL_89;
                                }
                              }
                            }
                          }

                          else
                          {
LABEL_121:
                            LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "GetIPFromName: Need six labels in IPv4 reverse mapping name %##s",  v64,  v65,  v66,  v67,  v68,  *(void *)(a1 + 37896));
                          }
                        }

                        else if (SameDomainNameBytes(v69, "\x03ip6\x04arpa"))
                        {
                          uint64_t v114 = *(unsigned __int8 **)(a1 + 37896);
                          unsigned int v115 = *v114;
                          if (!*v114) {
                            goto LABEL_151;
                          }
                          int v116 = -1;
                          int v117 = -32;
                          uint64_t v118 = *(void *)(a1 + 37896);
                          do
                          {
                            int v119 = v117;
                            uint64_t v120 = v118 + v115;
                            unsigned int v121 = *(unsigned __int8 *)(v120 + 1);
                            uint64_t v118 = v120 + 1;
                            unsigned int v115 = v121;
                            ++v116;
                            ++v117;
                          }

                          while (v121);
                          if (v116 - 33 >= 0)
                          {
                            if (v116 != 33)
                            {
                              do
                              {
                                if (!*v114) {
                                  break;
                                }
                                v114 += *v114 + 1;
                                --v119;
                              }

                              while (v119 > 1);
                            }

                            uint64_t v122 = 0LL;
                            while (*v114 == 1)
                            {
                              int v123 = v114[1];
                              unsigned int v124 = v123 - 48;
                              unsigned int v125 = v123 - 65;
                              else {
                                int v126 = v123 - 87;
                              }
                              unsigned int v127 = v123 - 55;
                              if (v125 > 5) {
                                unsigned int v127 = v126;
                              }
                              if (v124 <= 9) {
                                unsigned int v127 = v124;
                              }
                              if (v114[2] != 1) {
                                break;
                              }
                              int v128 = v114[3];
                              if ((v128 - 48) >= 0xA)
                              {
                                if ((v128 - 65) >= 6)
                                {
                                  int v129 = -87;
                                }

                                else
                                {
                                  int v129 = -55;
                                }
                              }

                              else
                              {
                                int v129 = -48;
                              }

                              if ((v127 & 0x80000000) != 0) {
                                break;
                              }
                              int v130 = v129 + v128;
                              if (v130 < 0) {
                                break;
                              }
                              *(_BYTE *)(v47 + 163 + v122--) = v127 | (16 * v130);
                              v114 += 4;
                              if (v122 == -16)
                              {
                                int v113 = 6;
LABEL_150:
                                *(_DWORD *)(v47 + 144) = v113;
                                break;
                              }
                            }
                          }

                          else
                          {
LABEL_151:
                            LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "GetIPFromName: Need 34 labels in IPv6 reverse mapping name %##s",  v64,  v65,  v66,  v67,  v68,  *(void *)(a1 + 37896));
                          }
                        }
                      }
                    }

void mDNSCoreReceiveUpdateR(uint64_t a1, unint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5 = a1;
  if (a5)
  {
    uint64_t v6 = a5;
    BOOL v7 = (unsigned __int16 *)a2;
    int v128 = 0;
    int PktLease = GetPktLease(a1, a2, a3, &v128);
    if (PktLease) {
      int v14 = v128;
    }
    else {
      int v14 = 3600;
    }
    int v123 = v14;
    BOOL v15 = &unk_100158000;
    if (PktLease && mDNS_LoggingEnabled) {
      LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "DNS Update response contains lease option granting %4d seconds, updateid %d, InterfaceID %p",  v9,  v10,  v11,  v12,  v13,  v14);
    }
    uint64_t v16 = *(void *)(v5 + 12648);
    if (v16)
    {
      __int16 v17 = (os_log_s *)mDNSLogCategory_Default;
      GetRRDisplayString_rdb( (unsigned __int8 *)(v16 + 8),  (unsigned __int16 *)(*(void *)(v16 + 48) + 4LL),  (_BYTE *)(v5 + 46976));
      LogMsgWithLevel( v17,  OS_LOG_TYPE_DEFAULT,  "mDNSCoreReceiveUpdateR ERROR m->CurrentRecord already set %s",  v18,  v19,  v20,  v21,  v22,  v5 + 46976);
    }

    uint64_t v23 = *(void *)(v5 + 12624);
    *(void *)(v5 + 1264_Block_object_dispose(va, 8) = v23;
    if (v23)
    {
      int v24 = 0;
      unsigned int v121 = v7;
      uint64_t v122 = (_BYTE *)(v5 + 46976);
      unint64_t v25 = (_BYTE *)(v5 + 46976);
      int v118 = ~(1 << v6);
      uint64_t v117 = v6 >> 5;
      uint64_t v120 = v6;
      do
      {
        uint64_t v26 = *(void *)(v23 + 32);
        if ((v26 == v6 || !v26 && (*(_BYTE *)(v23 + 122) || IsLocalDomain(*(_BYTE **)(v23 + 40))))
          && *(unsigned __int16 *)(v23 + 358) == *v7)
        {
          if (!*(void *)(v23 + 360)) {
            *(_WORD *)(v23 + 35_Block_object_dispose(va, 8) = 0;
          }
          unsigned int v27 = 1000 * v123 + *(_DWORD *)(v5 + 64);
          if (v27 <= 1) {
            unsigned int v27 = 1;
          }
          *(_DWORD *)(v23 + 352) = v27;
          ++v24;
          if (v15[2840] == 1)
          {
            store = (os_log_s *)mDNSLogCategory_Default;
            uint64_t v28 = v5;
            int v29 = v15;
            if (*(_DWORD *)(v23 + 126)) {
              __int128 v30 = "transferred";
            }
            else {
              __int128 v30 = "registered";
            }
            GetRRDisplayString_rdb((unsigned __int8 *)(v23 + 8), (unsigned __int16 *)(*(void *)(v23 + 48) + 4LL), v25);
            int v114 = (int)v30;
            BOOL v15 = v29;
            uint64_t v5 = v28;
            uint64_t v6 = v120;
            BOOL v7 = v121;
            LogMsgWithLevel( store,  OS_LOG_TYPE_DEFAULT,  "Sleep Proxy %s record %2d %5d 0x%x 0x%x (%d) %s",  v31,  v32,  v33,  v34,  v35,  v114);
          }

          if (*(_DWORD *)(v23 + 126))
          {
            *(_WORD *)(v23 + 130) = 0;
            *(_DWORD *)(v23 + 126) = 0;
            *(_BYTE *)(v23 + 192) = 0;
            mDNS_Deregister_internal(v5, v23, 0);
          }
        }

        uint64_t v36 = *(void *)(v5 + 12648);
        if (v36 == v23)
        {
          uint64_t v36 = *(void *)v23;
          *(void *)(v5 + 1264_Block_object_dispose(va, 8) = *(void *)v23;
        }

        uint64_t v23 = v36;
      }

      while (v36);
      if (v24)
      {
        memset(v127, 0, sizeof(v127));
        bzero(bytes, 0x22F8uLL);
        uint64_t v42 = (void *)(v5 + 12664);
        BOOL v43 = (void *)(v5 + 12664);
        while (1)
        {
          BOOL v43 = (void *)*v43;
          if (!v43) {
            break;
          }
          int v44 = v43;
          if (v43[782] == v6) {
            goto LABEL_42;
          }
        }

        int v44 = 0LL;
LABEL_42:
        size_t v45 = (char *)v44 + 6310;
        if (v43) {
          int v46 = v45;
        }
        else {
          int v46 = 0LL;
        }
        *(_OWORD *)unsigned int v127 = *(_OWORD *)a4;
        *(_DWORD *)&v127[16] = *(_DWORD *)(a4 + 16);
        int v47 = *(_DWORD *)v127;
        if (v15[2840] == 1) {
          LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "mDNSPlatformStoreSPSMACAddr : Storing %#a on interface %s",  v37,  v38,  v39,  v40,  v41,  (int)v127);
        }
        unsigned int v124 = v46;
        if (v47 == 4) {
          int v48 = 2;
        }
        else {
          int v48 = 30;
        }
        __int128 v166 = *(_OWORD *)&v127[4];
        __int16 v130 = 0;
        int v129 = 0;
        memset(v134, 0, 46);
        SCDynamicStoreRef v49 = SCDynamicStoreCreate(0LL, @"mDNSResponder:StoreSPSMACAddress", 0LL, 0LL);
        SCDynamicStoreRef v50 = SCDynamicStoreCreate(0LL, @"mDNSResponder:GetIPv6Addresses", 0LL, 0LL);
        SCDynamicStoreRef storea = v50;
        if (!v49 || !v50)
        {
          LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "StoreSPSMACAddressinternal: Unable to accesss SC Dynamic Store",  v51,  v52,  v53,  v54,  v55,  v113);
          CFTypeRef v63 = 0LL;
          uint64_t v64 = 0LL;
          CFStringRef v65 = 0LL;
          CFMutableDictionaryRef v66 = 0LL;
          CFStringRef v67 = 0LL;
          int v62 = -1;
          if (!v49)
          {
LABEL_73:
            if (storea) {
              CFRelease(storea);
            }
            if (v67) {
              CFRelease(v67);
            }
            if (v66) {
              CFRelease(v66);
            }
            if (v64) {
              CFRelease(v64);
            }
            if (v65) {
              CFRelease(v65);
            }
            if (v63) {
              CFRelease(v63);
            }
            if (v62) {
              LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "mDNSStoreSPSMACAddress : failed",  v68,  v69,  v70,  v71,  v72,  v115);
            }
            *(_DWORD *)bytes = 8650752;
            uint64_t v132 = 0LL;
            bzero(v134, 0x498uLL);
            v134[8] = 32;
            *(_DWORD *)&v134[12] = 94371881;
            __int16 v164 = 264;
            *(void *)&v134[40] = v163;
            uint64_t v135 = &v164;
            char v143 = 0;
            char v144 = 0;
            __int128 v136 = 0u;
            __int128 v137 = 0u;
            __int128 v138 = 0u;
            __int128 v139 = 0u;
            __int128 v140 = 0u;
            __int128 v141 = 0u;
            uint64_t v142 = 0LL;
            int v145 = v163;
            __int16 v159 = 0;
            uint64_t v160 = 0LL;
            uint64_t v162 = 0LL;
            uint64_t v161 = 0LL;
            v163[0] = 0;
            __int128 v157 = 0u;
            memset(v158, 0, sizeof(v158));
            __int128 v155 = 0u;
            __int128 v156 = 0u;
            __int128 v153 = 0u;
            __int128 v154 = 0u;
            __int128 v151 = 0u;
            __int128 v152 = 0u;
            __int128 v149 = 0u;
            __int128 v150 = 0u;
            __int128 v147 = 0u;
            __int128 v148 = 0u;
            __int128 v146 = 0u;
            *(void *)&v134[16] = 0x18001800001194LL;
            do
              uint64_t v42 = (void *)*v42;
            while (v42 && v42[782] != v6);
            SetupOwnerOpt(v5, (uint64_t)v42, (uint64_t)&v165);
            if (mDNS_LoggingEnabled == 1)
            {
              uint64_t v88 = (os_log_s *)mDNSLogCategory_Default;
              GetRRDisplayString_rdb(&v134[8], (unsigned __int16 *)v135 + 2, v122);
              LogMsgWithLevel(v88, OS_LOG_TYPE_DEFAULT, "Generated OPT record : %s", v89, v90, v91, v92, v93, (int)v122);
            }

            unint64_t v94 = PutResourceRecordTTLWithLimit( (unint64_t)bytes,  (unint64_t)v133,  (_WORD *)&v132 + 3,  (uint64_t)&v134[8],  *(unsigned int *)&v134[16],  (unint64_t)v134,  v86,  v87);
            if (v94)
            {
              LOWORD(v132) = bswap32((unsigned __int16)v132) >> 16;
              WORD1(v132) = bswap32(WORD1(v132)) >> 16;
              WORD2(v132) = bswap32(WORD2(v132)) >> 16;
              HIWORD(v132) = bswap32(HIWORD(v132)) >> 16;
              unint64_t v100 = v94 - (void)v133;
              SCDynamicStoreRef v101 = SCDynamicStoreCreate(0LL, @"mDNSResponder:StoreOwnerOPTRecord", 0LL, 0LL);
              if (v101)
              {
                uint64_t v102 = v101;
                uint64_t v103 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"%s%s%s");
                CFMutableArrayRef Mutable = CFDictionaryCreateMutable( 0LL,  0LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
                if (Mutable)
                {
                  CFDataRef v110 = CFDataCreate(0LL, bytes, (int)v100 + 12);
                  CFDictionarySetValue(Mutable, @"OwnerOPTRecord", v110);
                  if (v110) {
                    CFRelease(v110);
                  }
                  SCDynamicStoreSetValue(v102, v103, Mutable);
                }

                else
                {
                  LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "mDNSPlatformStoreOwnerOptRecord: Could not create CFDictionary dictionary to store OPT Record",  v104,  v105,  v106,  v107,  v108,  (int)"State:/Network/Interface/");
                }

                CFRelease(v102);
                if (v103) {
                  CFRelease(v103);
                }
                if (Mutable) {
                  CFRelease(Mutable);
                }
                goto LABEL_108;
              }

              int v111 = (os_log_s *)mDNSLogCategory_Default;
              int v112 = "mDNSPlatformStoreOwnerOptRecord: Unable to accesss SC Dynamic Store";
            }

            else
            {
              if (mDNS_LoggingEnabled != 1) {
                goto LABEL_108;
              }
              int v111 = (os_log_s *)mDNSLogCategory_Default;
              int v112 = "mDNSGenerateOwnerOptForInterface: Failed to generate owner OPT record";
            }

            LogMsgWithLevel(v111, OS_LOG_TYPE_DEFAULT, v112, v95, v96, v97, v98, v99, v115);
            goto LABEL_108;
          }

void ClearKeepaliveProxyRecords(uint64_t a1, unsigned __int16 *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8 = *(void *)(a1 + 12648);
  uint64_t v9 = &unk_100164000;
  if (v8)
  {
    uint64_t v10 = (os_log_s *)mDNSLogCategory_Default;
    GetRRDisplayString_rdb( (unsigned __int8 *)(v8 + 8),  (unsigned __int16 *)(*(void *)(v8 + 48) + 4LL),  (_BYTE *)(a1 + 46976));
    LogMsgWithLevel( v10,  OS_LOG_TYPE_DEFAULT,  "ClearKeepaliveProxyRecords ERROR m->CurrentRecord already set %s",  v11,  v12,  v13,  v14,  v15,  a1 + 46976);
  }

  *(void *)(a1 + 1264_Block_object_dispose(va, 8) = a3;
  if (a3)
  {
    uint64_t v16 = (unsigned int (**)(void, const char *))&unk_10014C000;
    do
    {
      if (*(void *)(a3 + 32) == a4
        && a2[1] == *(unsigned __int16 *)(a3 + 126)
        && a2[2] == *(unsigned __int16 *)(a3 + 128)
        && a2[3] == *(unsigned __int16 *)(a3 + 130)
        && *(_WORD *)(a1 + 37868) == 10)
      {
        __int16 v17 = *(_BYTE **)(a1 + 37896);
        uint64_t v18 = *v17 ? *v17 + 1LL : 0LL;
        if (((unsigned int (**)(_BYTE *, const char *))v16)[159](&v17[v18], "\n_keepalive"))
        {
          if (mDNS_LoggingEnabled == 1)
          {
            unsigned int v27 = (os_log_s *)*((void *)v9 + 170);
            int v19 = *(_DWORD *)(a1 + 19832);
            GetRRDisplayString_rdb( (unsigned __int8 *)(a3 + 8),  (unsigned __int16 *)(*(void *)(a3 + 48) + 4LL),  (_BYTE *)(a1 + 46976));
            uint64_t v9 = &unk_100164000;
            int v26 = v19;
            uint64_t v16 = (unsigned int (**)(void, const char *))&unk_10014C000;
            LogMsgWithLevel( v27,  OS_LOG_TYPE_DEFAULT,  "ClearKeepaliveProxyRecords: Removing %3d H-MAC %.6a I-MAC %.6a %d %d %s",  v20,  v21,  v22,  v23,  v24,  v26);
          }

          DeregisterProxyRecord(a1, a3);
        }
      }

      uint64_t v25 = *(void *)(a1 + 12648);
      if (v25 == a3)
      {
        uint64_t v25 = *(void *)a3;
        *(void *)(a1 + 1264_Block_object_dispose(va, 8) = *(void *)a3;
      }

      a3 = v25;
    }

    while (v25);
  }

void ClearIdenticalProxyRecords(uint64_t a1, unsigned __int16 *a2, uint64_t a3)
{
  uint64_t v6 = *(void *)(a1 + 12648);
  if (v6)
  {
    BOOL v7 = (os_log_s *)mDNSLogCategory_Default;
    GetRRDisplayString_rdb( (unsigned __int8 *)(v6 + 8),  (unsigned __int16 *)(*(void *)(v6 + 48) + 4LL),  (_BYTE *)(a1 + 46976));
    LogMsgWithLevel( v7,  OS_LOG_TYPE_DEFAULT,  "ClearIdenticalProxyRecords ERROR m->CurrentRecord already set %s",  v8,  v9,  v10,  v11,  v12,  a1 + 46976);
  }

  *(void *)(a1 + 1264_Block_object_dispose(va, 8) = a3;
  if (a3)
  {
    do
    {
      if (*(void *)(a1 + 37888) == *(void *)(a3 + 32)
        && a2[1] == *(unsigned __int16 *)(a3 + 126)
        && a2[2] == *(unsigned __int16 *)(a3 + 128)
        && a2[3] == *(unsigned __int16 *)(a3 + 130)
        && *(_DWORD *)(a3 + 24) == *(_DWORD *)(a1 + 37880)
        && resource_records_have_same_dnssec_rr_category(*(void *)(a3 + 64), *(void *)(a1 + 37920))
        && *(unsigned __int16 *)(a3 + 12) == *(unsigned __int16 *)(a1 + 37868)
        && *(unsigned __int16 *)(a3 + 14) == *(unsigned __int16 *)(a1 + 37870)
        && *(unsigned __int16 *)(a3 + 20) == *(unsigned __int16 *)(a1 + 37876)
        && *(_DWORD *)(a3 + 28) == *(_DWORD *)(a1 + 37884)
        && SameRDataBody( a3 + 8,  (unsigned __int16 *)(*(void *)(a1 + 37904) + 4LL),  (uint64_t (*)(uint64_t, unsigned __int16 *))SameDomainName)
        && SameDomainNameBytes(*(_BYTE **)(a3 + 40), *(_BYTE **)(a1 + 37896)))
      {
        if (mDNS_LoggingEnabled == 1)
        {
          uint64_t v20 = (os_log_s *)mDNSLogCategory_Default;
          int v19 = *(_DWORD *)(a1 + 19832);
          GetRRDisplayString_rdb( (unsigned __int8 *)(a3 + 8),  (unsigned __int16 *)(*(void *)(a3 + 48) + 4LL),  (_BYTE *)(a1 + 46976));
          LogMsgWithLevel( v20,  OS_LOG_TYPE_DEFAULT,  "ClearIdenticalProxyRecords: Removing %3d H-MAC %.6a I-MAC %.6a %d %d %s",  v13,  v14,  v15,  v16,  v17,  v19);
        }

        DeregisterProxyRecord(a1, a3);
      }

      uint64_t v18 = *(void *)(a1 + 12648);
      if (v18 == a3)
      {
        uint64_t v18 = *(void *)a3;
        *(void *)(a1 + 1264_Block_object_dispose(va, 8) = *(void *)a3;
      }

      a3 = v18;
    }

    while (v18);
  }

void SPSRecordCallback(uint64_t a1, char *a2, int a3)
{
  if (a3 == -65792)
  {
    --*(_DWORD *)(a1 + 19832);
    if (!a2) {
      goto LABEL_40;
    }
    goto LABEL_39;
  }

  if (!a3) {
    return;
  }
  uint64_t v6 = (os_log_s *)mDNSLogCategory_SPS;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_SPS == mDNSLogCategory_State)
  {
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_SPS, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_12;
    }
    goto LABEL_11;
  }

  uint64_t v6 = (os_log_s *)mDNSLogCategory_SPS_redacted;
  if (os_log_type_enabled((os_log_t)mDNSLogCategory_SPS_redacted, OS_LOG_TYPE_DEFAULT))
  {
LABEL_11:
    GetRRDisplayString_rdb( (unsigned __int8 *)a2 + 8,  (unsigned __int16 *)(*((void *)a2 + 6) + 4LL),  (_BYTE *)(a1 + 46976));
    int v21 = 67109635;
    *(_DWORD *)uint64_t v22 = a3;
    *(_WORD *)&v22[4] = 2160;
    *(void *)&_BYTE v22[6] = 1752392040LL;
    *(_WORD *)&v22[14] = 2085;
    *(void *)&v22[16] = a1 + 46976;
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "SPS Callback %d %{sensitive, mask.hash}s",  (uint8_t *)&v21,  0x1Cu);
  }

void ScheduleWakeup( uint64_t a1, uint64_t a2, unsigned __int16 *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9)
{
  if (*(_DWORD *)a3)
  {
    ScheduleWakeupForList(a1, a2, a3, *(void *)(a1 + 12632), a5, a6, a7, a8, v20);
    ScheduleWakeupForList(a1, a2, a3, *(void *)(a1 + 12624), v12, v13, v14, v15, a9);
    return;
  }

  uint64_t v16 = (os_log_s *)mDNSLogCategory_Default;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
  {
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    __int16 v21 = 0;
    uint64_t v18 = (uint8_t *)&v21;
    goto LABEL_12;
  }

  uint64_t v16 = (os_log_s *)mDNSLogCategory_Default_redacted;
  if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v20) = 0;
    uint64_t v18 = (uint8_t *)&v20;
LABEL_12:
    _os_log_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_DEFAULT,  "ScheduleWakeup ERROR: Target HMAC is zero",  v18,  2u);
  }

void ScheduleWakeupForList( uint64_t a1, uint64_t a2, unsigned __int16 *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9)
{
  if (*(_DWORD *)a3)
  {
    uint64_t v9 = a4;
    *(void *)(a1 + 1264_Block_object_dispose(va, 8) = a4;
    if (a4)
    {
      do
      {
        if (*(void *)(v9 + 32) != a2
          || *(_BYTE *)(v9 + 8) == 1
          || *(unsigned __int16 *)(v9 + 126) != *a3
          || *(unsigned __int16 *)(v9 + 128) != a3[1]
          || *(unsigned __int16 *)(v9 + 130) != a3[2])
        {
          goto LABEL_11;
        }

        if (mDNS_LoggingEnabled == 1)
        {
          uint64_t v13 = (os_log_s *)mDNSLogCategory_Default;
          GetRRDisplayString_rdb( (unsigned __int8 *)(v9 + 8),  (unsigned __int16 *)(*(void *)(v9 + 48) + 4LL),  (_BYTE *)(a1 + 46976));
          LogMsgWithLevel( v13,  OS_LOG_TYPE_DEFAULT,  "ScheduleWakeupForList: Scheduling wakeup packets for %s",  v14,  v15,  v16,  v17,  v18,  a1 + 46976);
        }

        mDNS_Deregister_internal(a1, v9, 0);
        uint64_t v19 = *(void *)(a1 + 12648);
        if (v19 == v9)
        {
LABEL_11:
          uint64_t v19 = *(void *)v9;
          *(void *)(a1 + 1264_Block_object_dispose(va, 8) = *(void *)v9;
        }

        uint64_t v9 = v19;
      }

      while (v19);
    }
  }

  else
  {
    LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "ScheduleWakeupForList ERROR: Target HMAC is zero",  a4,  a5,  a6,  a7,  a8,  a9);
  }

void DeregisterProxyRecord(uint64_t a1, uint64_t a2)
{
  *(_WORD *)(a2 + 130) = 0;
  *(_DWORD *)(a2 + 126) = 0;
  *(_BYTE *)(a2 + 192) = 0;
  mDNS_Deregister_internal(a1, a2, 0);
  uint64_t v10 = *(void *)(a1 + 15040);
  if (v10 && v10 != *(void *)(a1 + 37888)) {
    mDNSPlatformUpdateProxyList(v10, v3, v4, v5, v6, v7, v8, v9);
  }
  *(void *)(a1 + 15040) = *(void *)(a1 + 37888);
}

void mDNS_StartDomainEnumeration()
{
  uint64_t v0 = qword_10015C2C0;
  if (!qword_10015C2C0) {
    goto LABEL_9;
  }
  while (!SameDomainNameBytes((_BYTE *)v0, "\x05local"))
  {
    uint64_t v0 = *(void *)(v0 + 296);
    if (!v0) {
      goto LABEL_9;
    }
  }

  uint64_t v1 = *(_DWORD **)(v0 + 272);
  if (v1)
  {
LABEL_8:
    ++v1[167];
    mDNS_SetUpDomainEnumeration((unsigned int *)mDNSStorage, v0, 2);
LABEL_9:
    mDNS_Unlock_((uint64_t)mDNSStorage, (uint64_t)"mDNS_StartDomainEnumeration", 16158);
    return;
  }

  uint64_t v1 = calloc(1uLL, 0x2A8uLL);
  if (v1)
  {
    *(void *)(v0 + 272) = v1;
    goto LABEL_8;
  }

  __break(1u);
}

void mDNS_ActivateNetWake_internal(uint64_t a1)
{
  uint64_t v2 = &xmmword_10015BD30;
  do
  {
    uint64_t v2 = *(__int128 **)v2;
    if (v2) {
      BOOL v3 = v2 == (__int128 *)a1;
    }
    else {
      BOOL v3 = 1;
    }
  }

  while (!v3);
  if (v2)
  {
    if (!*(_BYTE *)(a1 + 16)) {
      return;
    }
    uint64_t v4 = (os_log_s *)mDNSLogCategory_SPS;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_SPS == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_SPS, OS_LOG_TYPE_DEFAULT))
      {
LABEL_25:
        mDNS_StartBrowse_internal( a1 + 24,  "\f_sleep-proxy\x04_udp",  "\x05local",  *(void *)(a1 + 6256),  0,  0,  0,  (uint64_t)off_10015D920,  a1);
        return;
      }
    }

    else
    {
      uint64_t v4 = (os_log_s *)mDNSLogCategory_SPS_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_SPS_redacted, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_25;
      }
    }

    *(_DWORD *)buf = 136446979;
    uint64_t v11 = a1 + 6310;
    __int16 v12 = 2160;
    uint64_t v13 = 1752392040LL;
    __int16 v14 = 1045;
    int v15 = 20;
    __int16 v16 = 2101;
    uint64_t v17 = a1 + 6264;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "ActivateNetWake for %{public}s (%{sensitive, mask.hash, mdnsresponder:ip_addr}.20P)",  buf,  0x26u);
    goto LABEL_25;
  }

  uint64_t v6 = (os_log_s *)mDNSLogCategory_Default;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
  {
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    *(_DWORD *)buf = 134217984;
    uint64_t v11 = a1;
    goto LABEL_28;
  }

  uint64_t v6 = (os_log_s *)mDNSLogCategory_Default_redacted;
  if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 134217984;
    uint64_t v11 = a1;
LABEL_28:
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "mDNS_ActivateNetWake_internal: NetworkInterfaceInfo %p not found in active list",  buf,  0xCu);
  }

uint64_t UpdateInterfaceProtocols(uint64_t result)
{
  *(_WORD *)(result + 17) = 0;
  uint64_t v1 = (uint64_t *)xmmword_10015BD30;
  if ((void)xmmword_10015BD30)
  {
    uint64_t v2 = *(void *)(result + 6256);
    do
    {
      if (v1[782] == v2)
      {
        int v3 = *((_DWORD *)v1 + 1566);
        if (v3 == 6)
        {
          if (*((_BYTE *)v1 + 6375)) {
            *(_BYTE *)(result + 1_Block_object_dispose(va, 8) = 1;
          }
        }

        else if (v3 == 4)
        {
          if (*((_BYTE *)v1 + 6375)) {
            *(_BYTE *)(result + 17) = 1;
          }
        }
      }

      uint64_t v1 = (uint64_t *)*v1;
    }

    while (v1);
  }

  return result;
}

void AdjustAddressRecordSetsEx(uint64_t a1, int a2)
{
  uint64_t v2 = *(void *)(a1 + 6256);
  if (AWDLInterfaceID) {
    BOOL v3 = AWDLInterfaceID == v2;
  }
  else {
    BOOL v3 = 0;
  }
  if (!v3 && (!WiFiAwareInterfaceID || WiFiAwareInterfaceID != v2))
  {
    uint64_t v7 = (void *)xmmword_10015BD30;
    FirstAddressRecord = GetFirstAddressRecordEx((uint64_t *)xmmword_10015BD30, a2);
    if (v7)
    {
      uint64_t v9 = FirstAddressRecord;
      if (a2) {
        uint64_t v10 = a1 + 5080;
      }
      else {
        uint64_t v10 = a1 + 2728;
      }
      do
      {
        uint64_t v11 = v7[782];
        if (AWDLInterfaceID) {
          BOOL v12 = AWDLInterfaceID == v11;
        }
        else {
          BOOL v12 = 0;
        }
        if (v12) {
          goto LABEL_40;
        }
        if (WiFiAwareInterfaceID && WiFiAwareInterfaceID == v11) {
          goto LABEL_40;
        }
        uint64_t v14 = (uint64_t)(a2 ? v7 + 635 : v7 + 341);
        if (*(void *)(v14 + 96) != v10) {
          goto LABEL_40;
        }
        if (v9) {
          uint64_t v15 = (uint64_t)v9;
        }
        else {
          uint64_t v15 = v14;
        }
        *(void *)(v14 + 96) = v15;
        __int16 v16 = (os_log_s *)mDNSLogCategory_Default;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
        {
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEBUG))
          {
LABEL_33:
            GetRRDisplayString_rdb( (unsigned __int8 *)(v14 + 8),  (unsigned __int16 *)(*(void *)(v14 + 48) + 4LL),  word_100164338);
            *(_DWORD *)buf = 141558275;
            uint64_t v20 = 1752392040LL;
            __int16 v21 = 2085;
            uint64_t v22 = word_100164338;
            _os_log_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_DEBUG,  "Changed RRSet for %{sensitive, mask.hash}s",  buf,  0x16u);
          }
        }

        else
        {
          __int16 v16 = (os_log_s *)mDNSLogCategory_Default_redacted;
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEBUG)) {
            goto LABEL_33;
          }
        }

        uint64_t v17 = (os_log_s *)mDNSLogCategory_Default;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
        {
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEBUG))
          {
LABEL_39:
            uint64_t v18 = *(void *)(v14 + 96);
            *(_DWORD *)buf = 134217984;
            uint64_t v20 = v18;
            _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEBUG, "New RRSet:        %lx", buf, 0xCu);
          }
        }

        else
        {
          uint64_t v17 = (os_log_s *)mDNSLogCategory_Default_redacted;
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEBUG)) {
            goto LABEL_39;
          }
        }

void RestartARPProbing(_DWORD *a1, uint64_t a2)
{
  *(_BYTE *)(a2 + _Block_object_dispose(va, 8) = 2;
  *(_BYTE *)(a2 + 190) = 3;
  ++*(_BYTE *)(a2 + 189);
  int v2 = a1[16];
  if (*(_BYTE *)(a2 + 191) == 4 && v2 - *(_DWORD *)(a2 + 284) >= 0)
  {
    InitializeLastAPTime(a1, a2);
  }

  else
  {
    *(_BYTE *)(a2 + 191) = 4;
    *(_DWORD *)(a2 + 280) = 1000;
    *(_DWORD *)(a2 + 284) = v2 + 9000;
    SetNextAnnounceProbeTime((uint64_t)a1, a2);
  }

void mDNSCoreReceiveRawTransportPacket( uint64_t a1, unsigned __int16 *a2, _DWORD *a3, _DWORD *a4, uint64_t a5, uint64_t a6, int8x8_t *a7, unint64_t a8, uint64_t a9, unsigned __int16 a10)
{
  int v11 = a5;
  BOOL v12 = a4;
  uint64_t v13 = a1;
  BOOL v14 = (_DWORD)a5 == 17 || (_DWORD)a5 == 6;
  uint64_t v15 = (__int16 *)a7 + 1;
  if (!v14) {
    uint64_t v15 = &zeroIPPort;
  }
  int v16 = (unsigned __int16)*v15;
  if ((int)a5 <= 16)
  {
    if ((_DWORD)a5 == 1)
    {
      if (mDNS_LoggingEnabled == 1) {
        LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "Ignoring %d-byte ICMP from %#a to %#a",  (uint64_t)a4,  a5,  a6,  (uint64_t)a7,  a8,  a8 - a6);
      }
      return;
    }

    if ((_DWORD)a5 == 6)
    {
      int v155 = (unsigned __int16)*v15;
      uint64_t v17 = *(void *)(a1 + 12624);
      if (v17)
      {
        int v142 = a7->u16[0];
        while (1)
        {
          uint64_t v159 = 0LL;
          unsigned int v160 = 0;
          __int16 v158 = 0;
          uint64_t v163 = 0LL;
          uint64_t v164 = 0LL;
          int v165 = 0;
          uint64_t v166 = 0LL;
          uint64_t v167 = 0LL;
          int v168 = 0;
          int v161 = 0;
          if (*(_DWORD *)(v17 + 126))
          {
            mDNS_ExtractKeepaliveInfo( v17,  &v160,  &v166,  &v163,  (uint64_t)v162,  (unsigned int *)&v159 + 1,  (unsigned int *)&v159,  (_WORD *)&v161 + 1,  &v161,  &v158);
            if (v160)
            {
              if (v166 != 4
                && ((_DWORD)v166 != 6 || v167 | HIDWORD(v167) | v168 | HIDWORD(v166))
                && v163 != 4
                && ((_DWORD)v163 != 6 || v164 | HIDWORD(v164) | v165 | HIDWORD(v163)))
              {
                unsigned int v18 = HIDWORD(v159);
                if (HIDWORD(v159))
                {
                  unsigned int v19 = v159;
                  if ((_DWORD)v159)
                  {
                    int v20 = HIWORD(v161);
                    if (HIWORD(v161))
                    {
                      int v21 = (unsigned __int16)v161;
                      if ((_WORD)v161)
                      {
                        if (v158
                          && mDNSSameAddress((int *)&v166, a4)
                          && mDNSSameAddress((int *)&v163, a3)
                          && v20 == v155
                          && v21 == v142)
                        {
                          break;
                        }
                      }
                    }
                  }
                }
              }
            }
          }

          uint64_t v17 = *(void *)v17;
          if (!v17) {
            goto LABEL_29;
          }
        }

        int v16 = v155;
        if (mDNS_LoggingEnabled == 1) {
          LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "mDNSCoreReceiveRawTransportPacket: Found a Keepalive record from %#a:%d  to %#a:%d",  (uint64_t)a4,  a5,  a6,  (uint64_t)a7,  a8,  (int)a3);
        }
        __int8 v133 = a7[1].i8[5];
        uint64_t v13 = a1;
        if ((v133 & 5) != 0)
        {
          if (mDNS_LoggingEnabled == 1) {
            LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "mDNSCoreReceiveRawTransportPacket: waking because of RST or FIN th_flags %d",  (uint64_t)a4,  a5,  a6,  (uint64_t)a7,  a8,  a7[1].u8[5]);
          }
          BOOL v27 = 1;
          BOOL v12 = a4;
        }

        else
        {
          unsigned int v134 = bswap32(v18);
          unsigned int v135 = bswap32(v19);
          unsigned int v136 = bswap32(a7->u32[1]);
          int64_t v137 = a8 - (void)a7 - (((unint64_t)a7[1].u8[4] >> 2) & 0x3C);
          BOOL v27 = (int)(bswap32(a7[1].u32[0]) - v134) >= 1 && (int)(v136 - v135) >= 0 && v137 > 0;
          if ((v133 & 0x10) != 0 && v137 <= 0 && v135 - v136 == 1) {
            mDNS_SendKeepaliveACK(a1, v17);
          }
          if (mDNS_LoggingEnabled == 1) {
            LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "mDNSCoreReceiveRawTransportPacket: End %p, hlen %d, Datalen %d, pack %u, seq %u, pseq %u, ack %u, wake %d",  (uint64_t)a4,  a5,  a6,  (uint64_t)a7,  a8,  a8);
          }
          uint64_t v13 = a1;
          BOOL v12 = a4;
          int v16 = v155;
          if (!v27) {
            return;
          }
        }
      }

      else
      {
LABEL_29:
        unsigned int v22 = a7[1].u8[5];
        BOOL v24 = (v22 & 4) == 0 && (v22 & 3) != 1;
        int v16 = v155;
        if (v155 == 5632) {
          int v25 = v24;
        }
        else {
          int v25 = v24 & (v22 >> 1);
        }
        if (mDNS_LoggingEnabled == 1)
        {
          uint64_t v26 = "Received";
          if (!v25) {
            uint64_t v26 = "Ignoring";
          }
          BOOL v12 = a4;
          LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "%s %d-byte TCP from %#a:%d to %#a:%d%s%s%s",  (uint64_t)a4,  a5,  a6,  (uint64_t)a7,  a8,  (int)v26);
          BOOL v27 = 0;
          uint64_t v13 = a1;
          if (!v25) {
            return;
          }
        }

        else
        {
          BOOL v27 = 0;
          uint64_t v13 = a1;
          BOOL v12 = a4;
          if (!v25) {
            return;
          }
        }
      }

      goto LABEL_158;
    }

LABEL_157:
  BOOL v27 = 0;
  if (!v41) {
    return;
  }
LABEL_158:
  mDNS_Lock_((unsigned int *)v13, (uint64_t)"mDNSCoreReceiveRawTransportPacket", 18199);
  uint64_t v102 = *(uint64_t **)(v13 + 12624);
  if (v102)
  {
    if (v11 == 6) {
      uint64_t v103 = "\x04_tcp";
    }
    else {
      uint64_t v103 = "\x04_udp";
    }
    __int128 v147 = v103;
    int v157 = v16;
    do
    {
      if (v102[4] == a9
        && *((_BYTE *)v102 + 8) != 1
        && *((_DWORD *)v102 + 36)
        && mDNSSameAddress((int *)v102 + 36, v12))
      {
        int v109 = *(uint64_t **)(v13 + 12624);
        if (v109)
        {
          while (1)
          {
            if (v109[4] == a9
              && *((unsigned __int16 *)v109 + 63) == *((unsigned __int16 *)v102 + 63)
              && *((unsigned __int16 *)v109 + 64) == *((unsigned __int16 *)v102 + 64)
              && *((unsigned __int16 *)v109 + 65) == *((unsigned __int16 *)v102 + 65)
              && *((_BYTE *)v109 + 8) != 1
              && *((_WORD *)v109 + 6) == 33
              && *(unsigned __int16 *)(v109[6] + 8) == v16)
            {
              CFDataRef v110 = (_BYTE *)v109[5];
              uint64_t v111 = *v110 ? *v110 + 1LL : 0LL;
              int v112 = &v110[v111];
              uint64_t v113 = *v112 ? *v112 + 1LL : 0LL;
            }

            int v109 = (uint64_t *)*v109;
            if (!v109) {
              goto LABEL_183;
            }
          }
        }

        else
        {
LABEL_183:
          if (v16 == 37905) {
            int v109 = v102;
          }
          else {
            int v109 = 0LL;
          }
        }

        if (v109) {
          BOOL v114 = 1;
        }
        else {
          BOOL v114 = !v27;
        }
        if (v114) {
          int v115 = (unsigned __int8 *)v109;
        }
        else {
          int v115 = (unsigned __int8 *)v102;
        }
        if (v115)
        {
          int v116 = (os_log_s *)mDNSLogCategory_Default;
          uint64_t v117 = (void *)(v13 + 12664);
          while (1)
          {
            uint64_t v117 = (void *)*v117;
            if (!v117) {
              break;
            }
            int v118 = (int)v117;
            if (v117[782] == v102[4]) {
              goto LABEL_203;
            }
          }

          int v118 = 0;
LABEL_203:
          if (v117) {
            int v121 = v118 + 6310;
          }
          else {
            int v121 = 0;
          }
          GetRRDisplayString_rdb(v115 + 8, (unsigned __int16 *)(*((void *)v115 + 6) + 4LL), (_BYTE *)(v13 + 46976));
          LogMsgWithLevel( v116,  OS_LOG_TYPE_DEFAULT,  "Waking host at %s %#a H-MAC %.6a I-MAC %.6a for %s",  v122,  v123,  v124,  v125,  v126,  v121);
          ScheduleWakeup(v13, v102[4], (unsigned __int16 *)v102 + 63, v127, v128, v129, v130, v131, v141);
          int v16 = v157;
        }

        else if (mDNS_LoggingEnabled == 1)
        {
          int v119 = (void *)(v13 + 12664);
          while (1)
          {
            int v119 = (void *)*v119;
            if (!v119) {
              break;
            }
            int v120 = (int)v119;
            if (v119[782] == v102[4]) {
              goto LABEL_208;
            }
          }

          int v120 = 0;
LABEL_208:
          if (v119) {
            int v132 = v120 + 6310;
          }
          else {
            int v132 = 0;
          }
          LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "Sleeping host at %s %#a %.6a has no service on %#s %d",  v104,  v105,  v106,  v107,  v108,  v132);
        }
      }

      uint64_t v102 = (uint64_t *)*v102;
    }

    while (v102);
  }

  mDNS_Unlock_(v13, (uint64_t)"mDNSCoreReceiveRawTransportPacket", 18224);
}

                        free(v26);
LABEL_32:
                        _Block_object_dispose(&v85, 8);
                        goto LABEL_33;
                      }

void mDNS_SendKeepaliveACK(uint64_t a1, uint64_t a2)
{
  uint64_t v29 = 0LL;
  unsigned int v30 = 0;
  unsigned __int16 v28 = 0;
  uint64_t v22 = 0LL;
  uint64_t v23 = 0LL;
  int v24 = 0;
  uint64_t v25 = 0LL;
  uint64_t v26 = 0LL;
  int v27 = 0;
  unsigned __int16 v19 = 0;
  unsigned __int16 v20 = 0;
  mDNS_ExtractKeepaliveInfo( a2,  &v30,  &v25,  &v22,  (uint64_t)v21,  (unsigned int *)&v29 + 1,  (unsigned int *)&v29,  &v20,  &v19,  &v28);
  if (v30
    && v25 != 4
    && ((_DWORD)v25 != 6 || v26 | HIDWORD(v26) | v27 | HIDWORD(v25))
    && v22 != 4
    && ((_DWORD)v22 != 6 || v23 | HIDWORD(v23) | v24 | HIDWORD(v22))
    && HIDWORD(v29)
    && (uint64_t v9 = v29, (_DWORD)v29)
    && v20
    && v19
    && (uint64_t v10 = v28) != 0)
  {
    HIDWORD(v29) = bswap32(bswap32(HIDWORD(v29)) + 1);
    LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "mDNS_SendKeepaliveACK: laddr %#a raddr %#a lport %d rport %d",  v4,  v5,  v6,  v7,  v8,  (int)&v25);
    mDNSPlatformSendKeepalive((uint64_t)&v25, (uint64_t)&v22, &v20, &v19, HIDWORD(v29), v9, v10, v11);
  }

  else if (mDNS_LoggingEnabled == 1)
  {
    BOOL v12 = (os_log_s *)mDNSLogCategory_Default;
    uint64_t v13 = (_BYTE *)(a1 + 46976);
    GetRRDisplayString_rdb((unsigned __int8 *)(a2 + 8), (unsigned __int16 *)(*(void *)(a2 + 48) + 4LL), v13);
    LogMsgWithLevel( v12,  OS_LOG_TYPE_DEFAULT,  "mDNS_SendKeepaliveACK: not a valid record %s for keepalive",  v14,  v15,  v16,  v17,  v18,  (int)v13);
  }

void SetDynDNSHostNameIfChanged(_BYTE *a1)
{
  if (!SameDomainNameBytes(a1, byte_10015C3C8))
  {
    if (byte_10015C3C8[0]) {
      mDNS_RemoveDynDNSHostName(byte_10015C3C8);
    }
    int v2 = a1;
    if (a1 == (_BYTE *)-256LL)
    {
LABEL_6:
      while (v2)
      {
        uint64_t v3 = *v2;
        if (!*v2)
        {
          unsigned __int16 v4 = (_WORD)v2 - (_WORD)a1 + 1;
          if (v4 >= 0x101u) {
            break;
          }
          memcpy(byte_10015C3C8, a1, v4);
          if (byte_10015C3C8[0])
          {
            mDNSPlatformDynDNSHostNameStatusChanged((unsigned __int8 *)byte_10015C3C8, 1, v5, v6, v7, v8, v9, v10);
            if (mDNS_LoggingEnabled == 1) {
              LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "mDNS_AddDynDNSHostName %##s",  v11,  v12,  v13,  v14,  v15,  (int)byte_10015C3C8);
            }
            uint64_t v16 = xmmword_10015C4C8;
            if ((void)xmmword_10015C4C8)
            {
              uint64_t v17 = (uint64_t *)&xmmword_10015C4C8;
              while (1)
              {
                int v18 = SameDomainNameBytes(byte_10015C3C8, (_BYTE *)(v16 + 208));
                int v24 = (uint64_t *)*v17;
                if (v18) {
                  break;
                }
                uint64_t v16 = *v24;
                uint64_t v17 = (uint64_t *)*v17;
                if (!*v24) {
                  goto LABEL_25;
                }
              }

              if (v24)
              {
                LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "DynDNSHostName %##s already in list",  v19,  v20,  v21,  v22,  v23,  (int)byte_10015C3C8);
                return;
              }
            }

            else
            {
              uint64_t v17 = (uint64_t *)&xmmword_10015C4C8;
            }

void DynDNSHostNameCallback( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void mDNS_StartExit()
{
  uint64_t v0 = (os_log_s *)mDNSLogCategory_Default;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
  {
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_11;
    }
    *(_WORD *)buf = 0;
    goto LABEL_10;
  }

  uint64_t v0 = (os_log_s *)mDNSLogCategory_Default_redacted;
  if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
LABEL_10:
    _os_log_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEFAULT, "mDNS_StartExit", buf, 2u);
  }

void DeregLoop(uint64_t a1)
{
  *((void *)&xmmword_10015BD18 + 1) = a1;
  if (a1)
  {
    uint64_t v1 = a1;
    while (1)
    {
      int v2 = (os_log_s *)mDNSLogCategory_Default;
      if (gSensitiveLoggingEnabled == 1 && mDNSLogCategory_Default != mDNSLogCategory_State) {
        break;
      }
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v4 = (unsigned __int8 *)(v1 + 8);
        int v5 = *(unsigned __int8 *)(v1 + 8);
        if (v5 == 1) {
          uint64_t v6 = "Accelerating";
        }
        else {
          uint64_t v6 = "Initiating  ";
        }
LABEL_16:
        GetRRDisplayString_rdb(v4, (unsigned __int16 *)(*(void *)(v1 + 48) + 4LL), word_100164338);
        *(_DWORD *)buf = 136447235;
        uint64_t v10 = v6;
        __int16 v11 = 2048;
        uint64_t v12 = v1;
        __int16 v13 = 1024;
        int v14 = v5;
        __int16 v15 = 2160;
        uint64_t v16 = 1752392040LL;
        __int16 v17 = 2085;
        int v18 = word_100164338;
        _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "DeregLoop: %{public}s deregistration for %p %02X %{sensitive, mask.hash}s",  buf,  0x30u);
      }

void mDNS_FinalExit()
{
  int v0 = dword_100158CB4;
  uint64_t v1 = (os_log_s *)mDNSLogCategory_Default;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
  {
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_11;
    }
    *(_WORD *)buf = 0;
    goto LABEL_10;
  }

  uint64_t v1 = (os_log_s *)mDNSLogCategory_Default_redacted;
  if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
LABEL_10:
    _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "mDNS_FinalExit: mDNSPlatformClose", buf, 2u);
  }

LABEL_63:
  uint64_t v34 = (unsigned __int8 *)xmmword_10015BD08;
  if ((void)xmmword_10015BD08)
  {
    while (1)
    {
      uint64_t v35 = (os_log_s *)mDNSLogCategory_Default;
      if (gSensitiveLoggingEnabled == 1 && mDNSLogCategory_Default != mDNSLogCategory_State) {
        break;
      }
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_72;
      }
LABEL_73:
      uint64_t v34 = *(unsigned __int8 **)v34;
      if (!v34) {
        goto LABEL_74;
      }
    }

    uint64_t v35 = (os_log_s *)mDNSLogCategory_Default_redacted;
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_73;
    }
LABEL_72:
    int v38 = v34[8];
    GetRRDisplayString_rdb(v34 + 8, (unsigned __int16 *)(*((void *)v34 + 6) + 4LL), word_100164338);
    *(_DWORD *)buf = 134218755;
    *(void *)BOOL v41 = v34;
    *(_WORD *)&v41[8] = 1024;
    *(_DWORD *)int v42 = v38;
    *(_WORD *)&v42[4] = 2160;
    uint64_t v43 = 1752392040LL;
    __int16 v44 = 2085;
    uint64_t v45 = word_100164338;
    _os_log_impl( (void *)&_mh_execute_header,  v35,  OS_LOG_TYPE_DEFAULT,  "mDNS_FinalExit failed to send goodbye for: %p %02X %{sensitive, mask.hash}s",  buf,  0x26u);
    goto LABEL_73;
  }

  unsigned __int16 v37 = *(void *)(a1 + 184);
  if (!v37 || (int v38 = *(void *)(v37 + 16)) == 0 || !*(_BYTE *)(v38 + 68))
  {
    unsigned int v39 = 939524096;
    if (*(void *)(a1 + 80))
    {
      if (*v3) {
        unsigned int v39 = 939524096;
      }
      else {
        unsigned int v39 = 1000;
      }
    }

    *(_DWORD *)(a1 + 212) = v39;
  }

  *(_DWORD *)(a1 + 20_Block_object_dispose(va, 8) = dword_100158BF8;
  SetNextQueryTime((uint64_t)mDNSStorage, a1);
  if (v6) {
    os_release((void *)v6);
  }
  if (v5) {
    os_release(v5);
  }
  if (v4) {
    os_release(v4);
  }
}

    unsigned int v36 = 0LL;
LABEL_57:
    uint32_t v20 = 0LL;
    goto LABEL_58;
  }

  uint64_t v43 = -1;
LABEL_25:
  unsigned int v39 = a4;
  uint64_t v46 = 0LL;
  os_log_type_t v19 = 0LL;
  uint32_t v20 = 0LL;
  __unint64_t size = v13 + 17;
  int v21 = 1;
  a4 = &v53;
  while (1)
  {
    int v42 = v21;
    uint64_t v53 = v41;
    if (v14) {
      break;
    }
    uint64_t v45 = 0;
    if (v20) {
      goto LABEL_52;
    }
LABEL_45:
    if (!__size || (unsigned int v29 = (char *)calloc(1uLL, __size)) == 0LL)
    {
      __break(1u);
      goto LABEL_69;
    }

    uint32_t v20 = v29;
    if (__size < 0xC) {
      goto LABEL_67;
    }
    int v30 = *(_DWORD *)a1;
    *((_WORD *)v29 + 2) = *(_WORD *)(a1 + 4);
    *(_DWORD *)unsigned int v29 = v30;
    *(_DWORD *)(v29 + 6) = 0;
    *((_WORD *)v29 + 5) = 0;
    if (__size - 12 < __n) {
      goto LABEL_67;
    }
    uint64_t v31 = &v29[__size];
    uint64_t v32 = v29 + 12;
    memcpy(v29 + 12, __src, __n);
    uint64_t v33 = &v32[__n];
    uint64_t v46 = v31;
    int v21 = 0;
    uint64_t v34 = BYTE2(v52);
    uint64_t v35 = v52;
    *uint64_t v33 = HIBYTE(v52);
    v33[1] = v34;
    v33[2] = HIBYTE(v35);
    v33[3] = v35;
    os_log_type_t v19 = v33 + 4;
    *((_WORD *)v20 + 2) = 256;
    if ((v42 & 1) == 0) {
      goto LABEL_54;
    }
  }

  uint64_t v45 = 0;
  uint64_t v22 = v14;
  do
  {
    uint64_t v51 = 0LL;
    uint64_t v49 = 0LL;
    uint64_t v48 = 0;
    uint64_t v50 = 0;
    uint64_t v47 = 0;
    uint64_t v68 = 0u;
    uint64_t v69 = 0u;
    CFMutableDictionaryRef v66 = 0u;
    CFStringRef v67 = 0u;
    uint64_t v64 = 0u;
    CFStringRef v65 = 0u;
    uint64_t v62 = 0u;
    uint64_t v63 = 0u;
    uint64_t v60 = 0u;
    uint64_t v61 = 0u;
    int v58 = 0u;
    uint64_t v59 = 0u;
    uint64_t v56 = 0u;
    uint64_t v57 = 0u;
    uint64_t v54 = 0u;
    uint64_t v55 = 0u;
    uint64_t v23 = v53;
    DomainName = _DNSMessageExtractRecordEx( a1,  a2,  v53,  (char *)&v54,  &v50,  &v47,  &v48,  0LL,  0LL,  0LL,  0LL,  0LL,  &v49,  &v53);
    if (DomainName) {
      goto LABEL_65;
    }
    if (v50 == HIWORD(v52)
      && v47 == (unsigned __int16)v52
      && DomainNameEqual((unsigned __int8 *)&v54, (unsigned __int8 *)__dst))
    {
      if (v20)
      {
        if (v46 - v19 < 2) {
          goto LABEL_64;
        }
        *(_WORD *)os_log_type_t v19 = 3264;
        int v24 = v48;
        if (v48 >= v43) {
          int v24 = v43;
        }
        uint64_t v48 = v24;
        uint64_t v25 = v50;
        uint64_t v26 = v47;
        int v27 = v49;
        _OWORD v19[2] = HIBYTE(v50);
        v19[3] = v25;
        v19[4] = HIBYTE(v26);
        v19[5] = v26;
        v19[6] = HIBYTE(v24);
        v19[7] = BYTE2(v24);
        v19[8] = BYTE1(v24);
        v19[9] = v24;
        v19[10] = HIBYTE(v27);
        v19[11] = v27;
        uint64_t v28 = v19 + 12;
        if (v46 - v28 < v49)
        {
LABEL_64:
          DomainName = -6762;
LABEL_65:
          unsigned int v36 = 0LL;
          goto LABEL_66;
        }

        DomainName = _DNSMessageExtractRecordEx(a1, a2, v23, 0LL, 0LL, 0LL, 0LL, 0LL, 0LL, v28, v49, &v51, 0LL, 0LL);
        if (DomainName) {
          goto LABEL_65;
        }
        os_log_type_t v19 = &v51[(void)v28];
        ++v45;
      }

      else
      {
        __size += v49 + 12;
      }
    }

    --v22;
  }

  while (v22);
  if (!v20) {
    goto LABEL_45;
  }
LABEL_52:
  if (__size >= 0xC)
  {
    *((_WORD *)v20 + 3) = bswap32(v45) >> 16;
LABEL_54:
    a4 = v39;
    DomainName = 0;
    if (v38) {
      os_log_s *v38 = v19 - v20;
    }
    unsigned int v36 = v20;
    goto LABEL_57;
  }

uint64_t _dns_obj_domain_name_compare(uint64_t a1, uint64_t a2, int a3)
{
  if (a1 == a2) {
    return 0LL;
  }
  uint64_t v6 = *(unsigned __int8 **)(a1 + 16);
  uint64_t v7 = *(unsigned __int8 **)(a2 + 16);
  if (*(void *)(a1 + 24) == *(void *)(a2 + 24))
  {
    if (!*(_BYTE *)(a1 + 36))
    {
      *(_DWORD *)(a1 + 32) = domain_name_labels_compute_hash(*(_BYTE **)(a1 + 16));
      *(_BYTE *)(a1 + 36) = 1;
    }

    if (*(_BYTE *)(a2 + 36))
    {
      int v8 = *(_DWORD *)(a2 + 32);
    }

    else
    {
      int v8 = domain_name_labels_compute_hash(v7);
      *(_DWORD *)(a2 + 32) = v8;
      *(_BYTE *)(a2 + 36) = 1;
    }

    if (*(_DWORD *)(a1 + 32) == v8) {
      return domain_name_labels_canonical_compare(v6, v7, a3);
    }
  }

  if ((a3 & 1) == 0) {
    return domain_name_labels_canonical_compare(v6, v7, a3);
  }
  else {
    return 2LL;
  }
}

void _dns_obj_domain_name_finalize(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 37))
  {
    int v2 = *(void **)(a1 + 16);
    if (v2)
    {
      free(v2);
      *(void *)(a1 + 16) = 0LL;
    }
  }

  int v3 = *(void **)(a1 + 40);
  if (v3)
  {
    ref_count_obj_release(v3);
    *(void *)(a1 + 40) = 0LL;
  }

_BYTE *dns_obj_domain_name_create_with_labels(_BYTE *a1, int *a2)
{
  uint64_t v6 = calloc(1uLL, 0x30uLL);
  if (!v6)
  {
    __break(1u);
    goto LABEL_16;
  }

  int v2 = v6;
  uint64_t v7 = &_dns_obj_domain_name_kind;
  *((void *)v6 + 1) = &_dns_obj_domain_name_kind;
  do
  {
    int v8 = (void (*)(_BYTE *))v7[2];
    if (v8) {
      v8(v2);
    }
    uint64_t v7 = (_UNKNOWN **)*v7;
  }

  while (v7);
  ++*(_DWORD *)v2;
  int v15 = 0;
  uint64_t v6 = domain_name_labels_create(a1, &v15);
  int v3 = v15;
  if (v15)
  {
LABEL_16:
    if (v6) {
      free(v6);
    }
    int v13 = 0LL;
    if (a2) {
      goto LABEL_11;
    }
    goto LABEL_12;
  }

  int v9 = *v6;
  uint64_t v10 = v6;
  if (*v6)
  {
    uint64_t v10 = v6;
    do
    {
      __int16 v11 = &v10[v9];
      int v12 = v11[1];
      uint64_t v10 = v11 + 1;
      int v9 = v12;
    }

    while (v12);
  }

  int v3 = 0;
  *((void *)v2 + 2) = v6;
  *((void *)v2 + 3) = v10 - v6 + 1;
  *((_DWORD *)v2 + _Block_object_dispose(va, 8) = 0;
  *((_WORD *)v2 + 1_Block_object_dispose(va, 8) = 256;
  *((void *)v2 + 5) = 0LL;
  int v13 = v2;
  int v2 = 0LL;
  if (a2) {
LABEL_11:
  }
    *a2 = v3;
LABEL_12:
  if (v2) {
    ref_count_obj_release(v2);
  }
  return v13;
}

_BYTE *dns_obj_domain_name_create_concatenation(_BYTE *a1, _BYTE *a2, _DWORD *a3)
{
  int v5 = 0;
  memset(__dst, 0, sizeof(__dst));
  domain_name_labels_concatenate(a1, a2, (char *)__dst, &v5);
  if (v5)
  {
    uint64_t result = 0LL;
    if (!a3) {
      return result;
    }
  }

  else
  {
    uint64_t result = dns_obj_domain_name_create_with_labels(__dst, &v5);
    if (!a3) {
      return result;
    }
  }

  *a3 = v5;
  return result;
}

_BYTE *dns_obj_domain_name_create_with_cstring(char *a1, _DWORD *a2)
{
  __int128 v17 = 0u;
  memset(v16, 0, sizeof(v16));
  int v3 = *a1;
  if (!*a1) {
    goto LABEL_23;
  }
  if (v3 == 46)
  {
    if (a1[1])
    {
      int v3 = 46;
      goto LABEL_5;
    }

void *_mdns_cache_metadata_copy_description(void *a1, int a2)
{
  uint64_t v4 = (void *)mdns_string_builder_create();
  if (!v4) {
    return 0LL;
  }
  int v5 = v4;
  else {
    uint64_t v6 = mdns_string_builder_copy_string((uint64_t)v5);
  }
  os_release(v5);
  return v6;
}

void _mdns_cache_metadata_finalize(uint64_t a1)
{
  int v2 = *(void **)(a1 + 24);
  if (v2)
  {
    os_release(v2);
    *(void *)(a1 + 24) = 0LL;
  }

  int v3 = *(void **)(a1 + 32);
  if (v3)
  {
    os_release(v3);
    *(void *)(a1 + 32) = 0LL;
  }

uint64_t mdns_cache_metadata_create()
{
  uint64_t v0 = _os_object_alloc(&OBJC_CLASS___OS_mdns_cache_metadata, 56LL);
  uint64_t v1 = v0;
  if (v0)
  {
    int v2 = &_mdns_cache_metadata_kind;
    *(void *)(v0 + 16) = &_mdns_cache_metadata_kind;
    do
    {
      int v3 = (void (*)(uint64_t))v2[2];
      if (v3) {
        v3(v1);
      }
      int v2 = (_UNKNOWN **)*v2;
    }

    while (v2);
    *(void *)(v1 + 40) = 0LL;
  }

  return v1;
}

void mdns_cache_metadata_set_extended_dns_error(uint64_t a1, void *object)
{
  if (object) {
    os_retain(object);
  }
  uint64_t v4 = *(void **)(a1 + 32);
  if (v4) {
    os_release(v4);
  }
  *(void *)(a1 + 32) = object;
}

dispatch_source_s *_mdns_dispatch_create_monotonic_timer( unsigned int a1, uint64_t a2, unsigned int a3, dispatch_queue_s *a4)
{
  uint64_t v7 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_timer, 0LL, 0LL, a4);
  if (v7)
  {
    if (a3 >= 0x64) {
      int v8 = 100;
    }
    else {
      int v8 = a3;
    }
    uint64_t v9 = (10000 * v8) * (unint64_t)a1;
    dispatch_time_t v10 = dispatch_time(0x8000000000000000LL, 1000000LL * a1);
    dispatch_source_set_timer(v7, v10, a2, v9);
  }

  return v7;
}

char *_mdns_multicast_delay_histogram_copy_description(uint64_t a1)
{
  unsigned int v2 = 0;
  v9[0] = 0LL;
  for (uint64_t i = 28LL; i != 62; i += 2LL)
    v2 += *(unsigned __int16 *)(a1 + i);
  if (v2)
  {
    uint64_t v8 = *(unsigned __int16 *)(a1 + 28);
    uint64_t v7 = *(unsigned __int16 *)(a1 + 32) + *(unsigned __int16 *)(a1 + 30) + *(unsigned __int16 *)(a1 + 34);
    uint64_t v6 = *(unsigned __int16 *)(a1 + 38) + *(unsigned __int16 *)(a1 + 36) + *(unsigned __int16 *)(a1 + 40);
    uint64_t v4 = vaddlvq_u16(*(uint16x8_t *)(a1 + 42));
    _mdns_multicast_delay_histogram_calculate_percentile_rank(a1, 50);
    _mdns_multicast_delay_histogram_calculate_percentile_rank(a1, 75);
    _mdns_multicast_delay_histogram_calculate_percentile_rank(a1, 90);
    _mdns_multicast_delay_histogram_calculate_percentile_rank(a1, 95);
    _mdns_multicast_delay_histogram_calculate_percentile_rank(a1, 99);
    asprintf( v9,  "delay distribution: [0] %u(%u%%) [1] %u(%u%%) [4] %u(%u%%) [7] %u(%u%%) [15] %u(%u%%) [20] %u(%u%%) [INF], cache h it rate: %u%%(hit: %u, miss:%u), percentile rank: P50(%us), P75(%us), P90(%us), P95(%us), P99(%us)",  v8,  100 * (int)v8 / v2,  v7,  100 * (int)v7 / v2,  v6,  100 * (int)v6 / v2,  v4);
  }

  else
  {
    asprintf(v9, "<< No Data Available >>");
  }

  return v9[0];
}

uint64_t _mdns_multicast_delay_histogram_calculate_percentile_rank(uint64_t a1, int a2)
{
  int v2 = 0;
  for (uint64_t i = 28LL; i != 62; i += 2LL)
    v2 += *(unsigned __int16 *)(a1 + i);
  if (!v2) {
    return 0LL;
  }
  unint64_t v4 = 0LL;
  unsigned int v5 = 0;
  unsigned int v6 = (v2 * a2 + 99) / 0x64u;
  while (1)
  {
    v5 += *(unsigned __int16 *)(a1 + 28 + 2 * v4);
    if (v5 >= v6) {
      break;
    }
    if (++v4 == 17) {
      return 0LL;
    }
  }

  if (v4 == 15) {
    unsigned int v8 = 18;
  }
  else {
    unsigned int v8 = 0;
  }
  if (v4 <= 0xE) {
    return (v4 + 1);
  }
  else {
    return v8;
  }
}

uint64_t mdns_multicast_delay_histogram_create()
{
  uint64_t v0 = _os_object_alloc(&OBJC_CLASS___OS_mdns_multicast_delay_histogram, 64LL);
  uint64_t v1 = v0;
  if (v0)
  {
    int v2 = &_mdns_multicast_delay_histogram_kind;
    *(void *)(v0 + 16) = &_mdns_multicast_delay_histogram_kind;
    do
    {
      int v3 = (void (*)(uint64_t))v2[2];
      if (v3) {
        v3(v1);
      }
      int v2 = (_UNKNOWN **)*v2;
    }

    while (v2);
  }

  return v1;
}

const char *mdns_signed_result_get_data(uint64_t a1, void *a2)
{
  uint64_t v7 = 0LL;
  uint64_t v3 = *(void *)(a1 + 16);
  uint64_t result = (const char *)(*(uint64_t (**)(void))(v3 + 48))();
  if (!result)
  {
    if (_mdns_signed_result_log_s_once != -1) {
      dispatch_once(&_mdns_signed_result_log_s_once, &__block_literal_global_630);
    }
    unsigned int v5 = (os_log_s *)_mdns_signed_result_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_signed_result_log_s_log, OS_LOG_TYPE_FAULT))
    {
      uint64_t v6 = *(void *)(v3 + 8);
      *(_DWORD *)buf = 136446210;
      uint64_t v9 = v6;
      _os_log_fault_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_FAULT,  "mdns_signed_result_get_data() failed for %{public}s",  buf,  0xCu);
    }

    uint64_t v7 = 0LL;
    uint64_t result = "";
  }

  if (a2) {
    *a2 = v7;
  }
  return result;
}

void ___mdns_signed_result_log_block_invoke(id a1)
{
  _mdns_signed_result_log_s_log = (uint64_t)os_log_create("com.apple.mdns", "signed_result");
}

uint64_t _mdns_signed_browse_result_create_ex( const unsigned __int8 *a1, unsigned __int8 *a2, unsigned int a3, unsigned __int8 *a4, unsigned __int16 a5, int *a6)
{
  int v12 = DomainNameToString(a2, 0LL, (unsigned __int8 *)__s, 0LL);
  if (v12)
  {
    int v22 = v12;
    uint64_t v21 = 0LL;
  }

  else
  {
    size_t v13 = strlen(__s);
    if (v13 >> 16)
    {
      uint64_t v21 = 0LL;
      int v22 = -6743;
    }

    else
    {
      size_t v14 = v13;
      unint64_t v15 = v13 + 58;
      int v16 = (unsigned __int8 *)calloc(1uLL, v13 + 58);
      if (!v16) {
        __break(1u);
      }
      uint64_t v17 = (uint64_t)v16;
      uint64_t v18 = (uint64_t)(v16 + 32);
      uuid_copy(v16 + 32, a1);
      int v19 = _mdns_signed_result_compute_metadata_hash(v18, a3, a4, a5);
      *(_DWORD *)(v17 + 4_Block_object_dispose(va, 8) = 5;
      *(_DWORD *)(v17 + 52) = v19;
      *(_WORD *)(v17 + 56) = v14;
      memcpy((void *)(v17 + 58), __s, v14);
      int v20 = _mdns_necp_sign_result(v17, v15);
      if (v20 || (v20 = _mdns_necp_validate_result(v17, v15), (int v24 = v20) != 0))
      {
        int v22 = v20;
        uint64_t v21 = 0LL;
      }

      else
      {
        uint64_t v21 = _mdns_signed_browse_result_create_no_copy(a2, v17, v15, &v24);
        int v22 = v24;
        if (!v24) {
          goto LABEL_7;
        }
      }

      free((void *)v17);
    }
  }

uint64_t _mdns_signed_result_compute_metadata_hash( uint64_t a1, unsigned int a2, unsigned __int8 *a3, unsigned int a4)
{
  uint64_t v4 = 0LL;
  int v5 = -2128831035;
  do
    int v5 = 16777619 * (v5 ^ *(unsigned __int8 *)(a1 + v4++));
  while (v4 != 16);
  uint64_t v6 = 0LL;
  unsigned int v12 = bswap32(a2);
  unsigned int v7 = v5;
  do
    unsigned int v7 = 16777619 * (v7 ^ *((unsigned __int8 *)&v12 + v6++));
  while (v6 != 4);
  unsigned int v8 = 16777619 * ((16777619 * (v5 ^ (a4 >> 8))) ^ a4);
  if (a4)
  {
    uint64_t v9 = a4;
    do
    {
      int v10 = *a3++;
      unsigned int v8 = 16777619 * (v8 ^ v10);
      --v9;
    }

    while (v9);
  }

  return v8 & 0xFFFFFF ^ HIBYTE(v8) | ((v7 ^ (v7 >> 8)) << 24);
}

uint64_t _mdns_necp_sign_result(uint64_t a1, unint64_t a2)
{
  unint64_t v2 = a2 - 32;
  if (a2 < 0x20) {
    return 4294960546LL;
  }
  unsigned int v8 = 0;
  uint64_t shared_fd = _mdns_necp_get_shared_fd((int *)&v8);
  uint64_t result = v8;
  if (!v8)
  {
    uint64_t result = necp_client_action(shared_fd, 20LL, a1 + 32, v2, a1, 32LL);
    unsigned int v8 = result;
    if ((_DWORD)result)
    {
      if (*__error())
      {
        unsigned int v8 = *__error();
        if (!v8) {
          return 0LL;
        }
      }

      else
      {
        unsigned int v8 = -6700;
      }

      if (_mdns_signed_result_log_s_once != -1) {
        dispatch_once(&_mdns_signed_result_log_s_once, &__block_literal_global_630);
      }
      uint64_t v6 = (os_log_s *)_mdns_signed_result_log_s_log;
      BOOL v7 = os_log_type_enabled((os_log_t)_mdns_signed_result_log_s_log, OS_LOG_TYPE_ERROR);
      uint64_t result = v8;
      if (v7)
      {
        *(_DWORD *)buf = 134217984;
        uint64_t v10 = (int)v8;
        _os_log_error_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_ERROR,  "Failed to sign data: %{mdns:err}ld",  buf,  0xCu);
        return v8;
      }
    }
  }

  return result;
}

uint64_t _mdns_necp_validate_result(uint64_t a1, uint64_t a2)
{
  unsigned int v8 = 0;
  uint64_t shared_fd = _mdns_necp_get_shared_fd((int *)&v8);
  uint64_t result = v8;
  if (!v8)
  {
    uint64_t result = necp_client_action(shared_fd, 23LL, a1, a2, 0LL, 0LL);
    unsigned int v8 = result;
    if ((_DWORD)result)
    {
      if (*__error())
      {
        unsigned int v8 = *__error();
        if (!v8) {
          return 0LL;
        }
      }

      else
      {
        unsigned int v8 = -6700;
      }

      if (_mdns_signed_result_log_s_once != -1) {
        dispatch_once(&_mdns_signed_result_log_s_once, &__block_literal_global_630);
      }
      uint64_t v6 = (os_log_s *)_mdns_signed_result_log_s_log;
      BOOL v7 = os_log_type_enabled((os_log_t)_mdns_signed_result_log_s_log, OS_LOG_TYPE_ERROR);
      uint64_t result = v8;
      if (v7)
      {
        *(_DWORD *)buf = 134217984;
        uint64_t v10 = (int)v8;
        _os_log_error_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_ERROR,  "Failed to validate data: %{mdns:err}ld",  buf,  0xCu);
        return v8;
      }
    }
  }

  return result;
}

uint64_t _mdns_signed_browse_result_create_no_copy(_BYTE *a1, uint64_t a2, uint64_t a3, int *a4)
{
  uint64_t v8 = _os_object_alloc(&OBJC_CLASS___OS_mdns_signed_browse_result, 56LL);
  uint64_t v9 = v8;
  if (!v8)
  {
    int v14 = -6728;
    if (!a4) {
      return v9;
    }
    goto LABEL_9;
  }

  uint64_t v10 = &_mdns_signed_browse_result_kind;
  *(void *)(v8 + 16) = &_mdns_signed_browse_result_kind;
  do
  {
    int v11 = (void (*)(uint64_t))v10[2];
    if (v11) {
      v11(v9);
    }
    uint64_t v10 = (_UNKNOWN **)*v10;
  }

  while (v10);
  DomainNameDupEx(a1, (void *)(v9 + 24), 0LL);
  int v12 = -2128831035;
  for (uint64_t i = 32LL; i != 48; ++i)
    int v12 = 16777619 * (v12 ^ *(unsigned __int8 *)(a2 + i));
  int v14 = 0;
  *(_DWORD *)(v9 + 4_Block_object_dispose(va, 8) = v12;
  *(void *)(v9 + 32) = a2;
  *(void *)(v9 + 40) = a3;
  if (a4) {
LABEL_9:
  }
    *a4 = v14;
  return v9;
}

void *_mdns_signed_browse_result_copy_description(void *a1, int a2, int a3)
{
  uint64_t v6 = (void *)mdns_string_builder_create();
  if (!v6) {
    return 0LL;
  }
  BOOL v7 = v6;
  if (a2 && mdns_string_builder_append_formatted(v6, "<%s: %p>: ", *(const char **)(a1[2] + 8LL), a1))
  {
LABEL_6:
    uint64_t v9 = 0LL;
    goto LABEL_7;
  }

  uint64_t v8 = a1[4];
  memset(out, 0, 37);
  uuid_unparse((const unsigned __int8 *)(v8 + 32), out);
  uint64_t v9 = 0LL;
  if (!mdns_string_builder_append_formatted(v7, "client ID: %s, service instance: ", out))
  {
    if (!_mdns_string_builder_append_domain_name_string(v7, v8 + 58, *(unsigned __int16 *)(v8 + 56), a3))
    {
      uint64_t v9 = mdns_string_builder_copy_string((uint64_t)v7);
      goto LABEL_7;
    }

    goto LABEL_6;
  }

void _mdns_signed_browse_result_finalize(void *a1)
{
  unint64_t v2 = (void *)a1[3];
  if (v2)
  {
    free(v2);
    a1[3] = 0LL;
  }

  uint64_t v3 = (void *)a1[4];
  if (v3)
  {
    free(v3);
    a1[4] = 0LL;
  }

  a1[5] = 0LL;
}

uint64_t _mdns_signed_browse_result_get_data(uint64_t a1, void *a2)
{
  if (a2) {
    *a2 = *(void *)(a1 + 40);
  }
  return *(void *)(a1 + 32);
}

uint64_t _mdns_signed_browse_result_get_uuid(uint64_t a1)
{
  return *(void *)(a1 + 32) + 32LL;
}

uint64_t _mdns_string_builder_append_domain_name_string(void *a1, uint64_t a2, unint64_t a3, int a4)
{
  if (a3 > 0x3F0) {
    return mdns_string_builder_append_formatted(a1, "«TOO LONG: %zu chars»");
  }
  if (!a4) {
    return mdns_string_builder_append_formatted(a1, "%.*s");
  }
  memset(v9, 0, 64);
  bzero(v8, 0x3F1uLL);
  __memcpy_chk(v8, a2, a3, 1009LL);
  v8[a3] = 0;
  DNSMessagePrintObfuscatedString((uint64_t)v9, v8);
  return mdns_string_builder_append_formatted(a1, "%s");
}

uint64_t _mdns_necp_get_shared_fd(int *a1)
{
  if ((_mdns_necp_get_shared_fd_s_fd & 0x80000000) == 0
    || (_mdns_necp_get_shared_fd_s_fd = necp_open(0LL), (_mdns_necp_get_shared_fd_s_fd & 0x80000000) == 0))
  {
    os_unfair_lock_unlock((os_unfair_lock_t)&_mdns_necp_get_shared_fd_s_lock);
    int v2 = 0;
    goto LABEL_4;
  }

  if (*__error())
  {
    int v2 = *__error();
    os_unfair_lock_unlock((os_unfair_lock_t)&_mdns_necp_get_shared_fd_s_lock);
    if (!v2) {
      goto LABEL_4;
    }
  }

  else
  {
    os_unfair_lock_unlock((os_unfair_lock_t)&_mdns_necp_get_shared_fd_s_lock);
    int v2 = -6700;
  }

  if (_mdns_signed_result_log_s_once != -1) {
    dispatch_once(&_mdns_signed_result_log_s_once, &__block_literal_global_630);
  }
  uint64_t v4 = (os_log_s *)_mdns_signed_result_log_s_log;
  if (os_log_type_enabled((os_log_t)_mdns_signed_result_log_s_log, OS_LOG_TYPE_ERROR))
  {
    int v5 = 134217984;
    uint64_t v6 = v2;
    _os_log_error_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_ERROR,  "Failed to create NECP file descriptor: %{mdns:err}ld",  (uint8_t *)&v5,  0xCu);
  }

LABEL_4:
  if (a1) {
    *a1 = v2;
  }
  return _mdns_necp_get_shared_fd_s_fd;
}

  for (uint64_t i = g_monitor_list; i; uint64_t i = *(void *)(i + 24))
  {
    int v2 = *(_DWORD *)(i + 136);
    if (v2)
    {
      uint64_t v3 = *(_DWORD *)(i + 140);
      uint64_t v4 = v9;
      if (v9)
      {
        while (1)
        {
          ifa_addr = v4->ifa_addr;
          if (ifa_addr)
          {
          }

          uint64_t v4 = v4->ifa_next;
          if (!v4) {
            goto LABEL_11;
          }
        }

        BOOL v7 = v3 & 0xFFFFFFBF;
        uint64_t v6 = (v3 >> 6) & 1;
      }

      else
      {
LABEL_11:
        uint64_t v6 = (*(_DWORD *)(i + 140) & 0x40) == 0;
        BOOL v7 = v3 | 0x40;
      }

      _mdns_interface_monitor_trigger_update(i, v7, v6);
    }
  }

  int v22 = 0LL;
LABEL_8:
  KQueueUnlock((uint64_t)"DNS service registration start handler", v14, v15, v16, v17, v18, v19, v20);
  return v22;
}

  _Block_object_dispose(&v18, 8);
}

  if (*(_BYTE *)(a1 + 105) == 2)
  {
    if (*(_DWORD *)(a1 + 108) != *(_DWORD *)&v10.sa_data[2]) {
      return;
    }
    uint64_t v4 = *(unsigned __int16 *)(a1 + 106);
    int v5 = *(unsigned __int16 *)v10.sa_data;
    goto LABEL_7;
  }

  uint64_t v6 = *(void *)(a1 + 112) == *(void *)&v10.sa_data[6] && *(void *)(a1 + 120) == v11;
  if (*(unsigned __int8 *)(a1 + 112) == 254 && (*(_BYTE *)(a1 + 113) & 0xC0) == 0x80)
  {
    uint64_t v4 = *(_DWORD *)(a1 + 128);
    if (v4)
    {
      int v5 = v12;
LABEL_7:
      if (v4 != v5) {
        return;
      }
    }
  }

  if (_mdns_resolver_queue_s_once != -1) {
    dispatch_once(&_mdns_resolver_queue_s_once, &__block_literal_global_138);
  }
  BOOL v7 = dispatch_data_create(buffer, v2, (dispatch_queue_t)_mdns_resolver_queue_s_queue, 0LL);
  if (v7)
  {
    uint64_t v8 = v7;
    _mdns_common_session_invoke_receive(a1, (uint64_t)v7);
    dispatch_release(v8);
  }

  if (SCPreferencesLock(v2, 0))
  {
    uint64_t v4 = 0LL;
    int v5 = 0;
    if (!a1) {
      goto LABEL_25;
    }
LABEL_24:
    *a1 = v5;
    goto LABEL_25;
  }

  if (!SCError())
  {
    int v5 = -6700;
    goto LABEL_18;
  }

  int v5 = SCError();
  if (v5)
  {
LABEL_18:
    if (mdns_system_log_s_once != -1) {
      dispatch_once(&mdns_system_log_s_once, &__block_literal_global_6614);
    }
    BOOL v7 = (os_log_s *)mdns_system_log_s_log;
    if (os_log_type_enabled((os_log_t)mdns_system_log_s_log, OS_LOG_TYPE_ERROR))
    {
      uint64_t v9 = 134217984;
      uint64_t v10 = v5;
      _os_log_error_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_ERROR,  "SCPreferencesLock failed: %{mdns:err}ld",  (uint8_t *)&v9,  0xCu);
    }

    uint64_t v4 = v2;
    goto LABEL_23;
  }

  uint64_t v4 = 0LL;
  if (a1) {
    goto LABEL_24;
  }
LABEL_25:
  if (v4) {
    CFRelease(v4);
  }
  return v2;
}

  if (SCPreferencesApplyChanges(a1)) {
    return 0LL;
  }
  if (SCError())
  {
    uint64_t v3 = SCError();
    if (!(_DWORD)v3) {
      return v3;
    }
  }

  else
  {
    uint64_t v3 = 4294960596LL;
  }

  if (mdns_system_log_s_once != -1) {
    dispatch_once(&mdns_system_log_s_once, &__block_literal_global_6614);
  }
  uint64_t v4 = (os_log_s *)mdns_system_log_s_log;
  if (os_log_type_enabled((os_log_t)mdns_system_log_s_log, OS_LOG_TYPE_ERROR))
  {
    BOOL v7 = 134217984;
    uint64_t v8 = (int)v3;
    int v5 = "SCPreferencesApplyChanges failed: %{mdns:err}ld";
    goto LABEL_20;
  }

  return v3;
}

BOOL mdns_signed_browse_result_contains(uint64_t a1, unsigned __int8 *a2, unsigned int a3)
{
  if (!a3) {
    return DomainNameEqual(*(unsigned __int8 **)(a1 + 24), a2) != 0;
  }
  uint64_t v3 = 0LL;
  unsigned int v4 = *(_DWORD *)(*(void *)(a1 + 32) + 52LL);
  int v5 = *(_DWORD *)(a1 + 48);
  unsigned int v7 = bswap32(a3);
  do
    LOWORD(v5) = 403 * (v5 ^ *((unsigned __int8 *)&v7 + v3++));
  while (v3 != 4);
}

uint64_t _mdns_signed_resolve_result_create_no_copy(_BYTE *a1, uint64_t a2, uint64_t a3, int *a4)
{
  uint64_t v8 = _os_object_alloc(&OBJC_CLASS___OS_mdns_signed_resolve_result, 56LL);
  uint64_t v9 = v8;
  if (!v8)
  {
    int v14 = -6728;
    if (!a4) {
      return v9;
    }
    goto LABEL_9;
  }

  uint64_t v10 = &_mdns_signed_resolve_result_kind;
  *(void *)(v8 + 16) = &_mdns_signed_resolve_result_kind;
  do
  {
    int v11 = (void (*)(uint64_t))v10[2];
    if (v11) {
      v11(v9);
    }
    uint64_t v10 = (_UNKNOWN **)*v10;
  }

  while (v10);
  DomainNameDupEx(a1, (void *)(v9 + 24), 0LL);
  int v12 = -2128831035;
  for (uint64_t i = 32LL; i != 48; ++i)
    int v12 = 16777619 * (v12 ^ *(unsigned __int8 *)(a2 + i));
  int v14 = 0;
  *(_DWORD *)(v9 + 4_Block_object_dispose(va, 8) = v12;
  *(void *)(v9 + 32) = a2;
  *(void *)(v9 + 40) = a3;
  if (a4) {
LABEL_9:
  }
    *a4 = v14;
  return v9;
}

void *_mdns_signed_resolve_result_copy_description(void *a1, int a2, int a3)
{
  uint64_t v6 = (void *)mdns_string_builder_create();
  if (!v6) {
    return 0LL;
  }
  unsigned int v7 = v6;
  if (!a2 || !mdns_string_builder_append_formatted(v6, "<%s: %p>: ", *(const char **)(a1[2] + 8LL), a1))
  {
    uint64_t v9 = a1[4];
    memset(out, 0, 37);
    uuid_unparse((const unsigned __int8 *)(v9 + 32), out);
    uint64_t v8 = 0LL;
    uint64_t v11 = 0LL;
    v14[0] = "service instance";
    v14[1] = v9 + 62;
    unsigned __int16 v15 = *(_WORD *)(v9 + 56);
    int v16 = 0;
    __int16 v17 = 0;
    uint64_t v18 = "hostname";
    uint64_t v19 = v9 + 62 + v15;
    __int16 v20 = *(_WORD *)(v9 + 60);
    char v12 = 1;
    while (1)
    {
      char v13 = v12;
      if (mdns_string_builder_append_formatted(v7, ", %s: ", (const char *)v14[3 * v11])
        || _mdns_string_builder_append_domain_name_string( v7,  v14[3 * v11 + 1],  LOWORD(v14[3 * v11 + 2]),  a3))
      {
        break;
      }

      char v12 = 0;
      uint64_t v11 = 1LL;
      if ((v13 & 1) == 0)
      {
        if (mdns_string_builder_append_formatted( v7,  ", port: %u",  bswap32(*(unsigned __int16 *)(v9 + 58)) >> 16)) {
          break;
        }
        uint64_t v8 = mdns_string_builder_copy_string((uint64_t)v7);
        goto LABEL_6;
      }
    }
  }

  uint64_t v8 = 0LL;
LABEL_6:
  os_release(v7);
  return v8;
}

void _mdns_signed_resolve_result_finalize(void *a1)
{
  int v2 = (void *)a1[3];
  if (v2)
  {
    free(v2);
    a1[3] = 0LL;
  }

  uint64_t v3 = (void *)a1[4];
  if (v3)
  {
    free(v3);
    a1[4] = 0LL;
  }

  a1[5] = 0LL;
}

uint64_t _mdns_signed_resolve_result_get_data(uint64_t a1, void *a2)
{
  if (a2) {
    *a2 = *(void *)(a1 + 40);
  }
  return *(void *)(a1 + 32);
}

uint64_t _mdns_signed_resolve_result_get_uuid(uint64_t a1)
{
  return *(void *)(a1 + 32) + 32LL;
}

uint64_t mdns_signed_resolve_result_create_from_data(uint64_t a1, size_t a2, int *a3)
{
  size_t v4 = a2 - 62;
  if (a2 < 0x3E)
  {
    uint64_t result = 0LL;
    int v14 = -6743;
  }

  else if (*(_DWORD *)(a1 + 48) == 6)
  {
    size_t v6 = *(unsigned __int16 *)(a1 + 56);
    BOOL v7 = v4 >= v6;
    unint64_t v8 = v4 - v6;
    if (v7 && (unint64_t v9 = *(unsigned __int16 *)(a1 + 60), v8 >= v9))
    {
      if (v9 > 0x3F0)
      {
        uint64_t result = 0LL;
        int v14 = -6744;
      }

      else
      {
        bzero(v17, 0x3F1uLL);
        __memcpy_chk(v17, a1 + v6 + 62, v9, 1009LL);
        v17[v9] = 0;
        memset(v16, 0, sizeof(v16));
        int v11 = DomainNameFromString(v16, v17);
        if (!v11)
        {
          int v11 = _mdns_necp_validate_result(a1, a2);
          if (!v11)
          {
            int v15 = 0;
            char v12 = malloc(a2);
            if (v12)
            {
              unint64_t v9 = (unint64_t)v12;
              memcpy(v12, (const void *)a1, a2);
              uint64_t result = _mdns_signed_resolve_result_create_no_copy(v16, v9, a2, &v15);
              if (result)
              {
LABEL_11:
                int v14 = v15;
                goto LABEL_12;
              }
            }

            else
            {
              __break(1u);
            }

            free((void *)v9);
            uint64_t result = 0LL;
            goto LABEL_11;
          }
        }

        int v14 = v11;
        uint64_t result = 0LL;
      }
    }

    else
    {
      uint64_t result = 0LL;
      int v14 = -6750;
    }
  }

  else
  {
    uint64_t result = 0LL;
    int v14 = -6756;
  }

BOOL mdns_signed_resolve_result_contains(uint64_t a1, char *a2, unsigned int a3)
{
  uint64_t v4 = 0LL;
  unsigned int v5 = *(_DWORD *)(*(void *)(a1 + 32) + 52LL);
  int v6 = *(_DWORD *)(a1 + 48);
  unsigned int v8 = bswap32(a3);
  do
    LOWORD(v6) = 403 * (v6 ^ *((unsigned __int8 *)&v8 + v4++));
  while (v4 != 4);
  memset(v9, 0, sizeof(v9));
}

unsigned __int8 *mdns_signed_hostname_result_create_ipv4(uint64_t a1, _DWORD *a2, int *a3)
{
  uint64_t v5 = 0LL;
  *((void *)&v4 + 1) = 0LL;
  int v6 = 0;
  LOWORD(v4) = 528;
  WORD1(v4) = *(_WORD *)(*(void *)(a1 + 32) + 58LL);
  DWORD1(v4) = *a2;
  return _mdns_signed_hostname_result_create(a1, &v4, a3);
}

unsigned __int8 *_mdns_signed_hostname_result_create(uint64_t a1, __int128 *a2, int *a3)
{
  uint64_t v6 = _os_object_alloc(&OBJC_CLASS___OS_mdns_signed_hostname_result, 40LL);
  uint64_t v7 = v6;
  if (v6)
  {
    unsigned int v8 = &_mdns_signed_hostname_result_kind;
    *(void *)(v6 + 16) = &_mdns_signed_hostname_result_kind;
    do
    {
      unint64_t v9 = (void (*)(uint64_t))v8[2];
      if (v9) {
        v9(v7);
      }
      unsigned int v8 = (_UNKNOWN **)*v8;
    }

    while (v8);
    uint64_t v10 = *(void *)(a1 + 32);
    size_t v11 = *(unsigned __int16 *)(v10 + 60) + 88LL;
    *(void *)(v7 + 32) = v11;
    uint64_t result = (unsigned __int8 *)calloc(1uLL, v11);
    if (!result)
    {
      __break(1u);
      return result;
    }

    char v13 = result;
    *(void *)(v7 + 24) = result;
    uuid_copy(result + 32, (const unsigned __int8 *)(v10 + 32));
    *((void *)v13 + 6) = 4LL;
    __int128 v14 = *a2;
    *(_OWORD *)(v13 + 6_Block_object_dispose(va, 8) = *(__int128 *)((char *)a2 + 12);
    *(_OWORD *)(v13 + 56) = v14;
    size_t v15 = *(unsigned __int16 *)(v10 + 60);
    *((_DWORD *)v13 + 21) = v15;
    memcpy(v13 + 88, (const void *)(v10 + *(unsigned __int16 *)(v10 + 56) + 62), v15);
    int v16 = _mdns_necp_sign_result(*(void *)(v7 + 24), *(void *)(v7 + 32));
    if (v16 || (int v16 = _mdns_necp_validate_result(*(void *)(v7 + 24), *(void *)(v7 + 32))) != 0)
    {
      __int16 v17 = (void *)v7;
      uint64_t v7 = 0LL;
    }

    else
    {
      __int16 v17 = 0LL;
    }
  }

  else
  {
    __int16 v17 = 0LL;
    int v16 = -6728;
  }

  if (a3) {
    *a3 = v16;
  }
  if (v17) {
    os_release(v17);
  }
  return (unsigned __int8 *)v7;
}

void *_mdns_signed_hostname_result_copy_description(void *a1, int a2, int a3)
{
  uint64_t v6 = (void *)mdns_string_builder_create();
  if (!v6) {
    return 0LL;
  }
  uint64_t v7 = v6;
  if (a2 && mdns_string_builder_append_formatted(v6, "<%s: %p>: ", *(const char **)(a1[2] + 8LL), a1))
  {
LABEL_8:
    unint64_t v9 = 0LL;
    goto LABEL_9;
  }

  uint64_t v8 = a1[3];
  memset(out, 0, 37);
  uuid_unparse((const unsigned __int8 *)(v8 + 32), out);
  unint64_t v9 = 0LL;
  if (!mdns_string_builder_append_formatted(v7, "client ID: %s, hostname: ", out))
  {
    if (!_mdns_string_builder_append_domain_name_string(v7, v8 + 88, *(unsigned int *)(v8 + 84), a3)
      && !mdns_string_builder_append_formatted(v7, ", address: "))
    {
      v11[0] = *(_OWORD *)(v8 + 56);
      *(_OWORD *)((char *)v11 + 12) = *(_OWORD *)(v8 + 68);
      if (!mdns_string_builder_append_sockaddr_description(v7, (uint64_t)v11, a3))
      {
        unint64_t v9 = mdns_string_builder_copy_string((uint64_t)v7);
        goto LABEL_9;
      }
    }

    goto LABEL_8;
  }

void _mdns_signed_hostname_result_finalize(uint64_t a1)
{
  int v2 = *(void **)(a1 + 24);
  if (v2)
  {
    free(v2);
    *(void *)(a1 + 24) = 0LL;
  }

  *(void *)(a1 + 32) = 0LL;
}

uint64_t _mdns_signed_hostname_result_get_data(uint64_t a1, void *a2)
{
  if (a2) {
    *a2 = *(void *)(a1 + 32);
  }
  return *(void *)(a1 + 24);
}

uint64_t _mdns_signed_hostname_result_get_uuid(uint64_t a1)
{
  return *(void *)(a1 + 24) + 32LL;
}

unsigned __int8 *mdns_signed_hostname_result_create_ipv6(uint64_t a1, _OWORD *a2, int a3, int *a4)
{
  LOWORD(v5[0]) = 7708;
  HIWORD(v5[0]) = *(_WORD *)(*(void *)(a1 + 32) + 58LL);
  *(_OWORD *)&v5[2] = *a2;
  if (LOBYTE(v5[2]) == 254 && (BYTE1(v5[2]) & 0xC0) == 0x80) {
    v5[6] = a3;
  }
  return _mdns_signed_hostname_result_create(a1, (__int128 *)v5, a4);
}

uint64_t _dnssec_obj_rrset_compare()
{
  return 2LL;
}

void *_dnssec_obj_rrset_finalize(uint64_t a1)
{
  int v2 = *(void **)(a1 + 16);
  if (v2)
  {
    ref_count_obj_release(v2);
    *(void *)(a1 + 16) = 0LL;
  }

  uint64_t result = *(void **)(a1 + 24);
  if (result)
  {
    do
    {
      __int128 v4 = (void *)result[1];
      free(result);
      uint64_t result = v4;
    }

    while (v4);
  }

  return result;
}

void *dnssec_obj_rrset_create(_DWORD *a1, int a2, _DWORD *a3)
{
  uint64_t result = calloc(1uLL, 0x40uLL);
  if (result)
  {
    uint64_t v7 = result;
    uint64_t v8 = &_dnssec_obj_rrset_kind;
    result[1] = &_dnssec_obj_rrset_kind;
    do
    {
      unint64_t v9 = (void (*)(void *))v8[2];
      if (v9) {
        v9(v7);
      }
      uint64_t v8 = (_UNKNOWN **)*v8;
    }

    while (v8);
    ++*(_DWORD *)v7;
    v7[2] = a1;
    ++*a1;
    v7[4] = 0LL;
    v7[5] = 0LL;
    *((_DWORD *)v7 + 12) = -6718;
    *((_BYTE *)v7 + 60) = 0;
    *((_DWORD *)v7 + 14) = a2;
    ++*(_DWORD *)v7;
    if (a3) {
      *a3 = 0;
    }
    ref_count_obj_release(v7);
    return v7;
  }

  else
  {
    __break(1u);
  }

  return result;
}

uint64_t dnssec_obj_rrset_get_rr_type(uint64_t a1)
{
  if (*(void *)(a1 + 32))
  {
    uint64_t v1 = **(void **)(a1 + 24);
    uint64_t result = *(unsigned __int16 *)(v1 + 4);
    if ((_DWORD)result == 46) {
      return __rev16(*(unsigned __int16 *)(*(void *)(v1 + 40) + 4LL));
    }
    return result;
  }

  uint64_t v3 = (os_log_s *)mDNSLogCategory_DNSSEC;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_DNSSEC == mDNSLogCategory_State)
  {
    uint64_t result = os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC, OS_LOG_TYPE_FAULT);
    if (!(_DWORD)result) {
      return result;
    }
LABEL_13:
    int v5 = 136447234;
    uint64_t v6 = "rrset->rr_count > 0";
    __int16 v7 = 2082;
    uint64_t v8 = "";
    __int16 v9 = 2082;
    uint64_t v10 = "/Library/Caches/com.apple.xbs/Sources/mDNSResponder/mDNSMacOSX/dnssec_v2/dnssec_objs/dnssec_obj_rrset.c";
    __int16 v11 = 1024;
    int v12 = 123;
    __int16 v13 = 2048;
    uint64_t v14 = 0LL;
    _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_FAULT,  "AssertMacros: %{public}s, %{public}s file: %{public}s, line: %d, value: %ld",  (uint8_t *)&v5,  0x30u);
    return 0LL;
  }

  uint64_t v3 = (os_log_s *)mDNSLogCategory_DNSSEC_redacted;
  uint64_t result = os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC_redacted, OS_LOG_TYPE_FAULT);
  if ((_DWORD)result) {
    goto LABEL_13;
  }
  return result;
}

uint64_t dnssec_obj_rrset_get_rr_class(uint64_t a1)
{
  if (*(void *)(a1 + 32)) {
    return *(unsigned __int16 *)(**(void **)(a1 + 24) + 6LL);
  }
  int v2 = (os_log_s *)mDNSLogCategory_DNSSEC;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_DNSSEC == mDNSLogCategory_State)
  {
    uint64_t result = os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC, OS_LOG_TYPE_FAULT);
    if ((_DWORD)result)
    {
LABEL_12:
      int v4 = 136447234;
      int v5 = "me->rr_count > 0";
      __int16 v6 = 2082;
      __int16 v7 = "";
      __int16 v8 = 2082;
      __int16 v9 = "/Library/Caches/com.apple.xbs/Sources/mDNSResponder/mDNSMacOSX/dnssec_v2/dnssec_objs/dnssec_obj_rrset.c";
      __int16 v10 = 1024;
      int v11 = 138;
      __int16 v12 = 2048;
      uint64_t v13 = 0LL;
      _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_FAULT,  "AssertMacros: %{public}s, %{public}s file: %{public}s, line: %d, value: %ld",  (uint8_t *)&v4,  0x30u);
      return 0LL;
    }
  }

  else
  {
    int v2 = (os_log_s *)mDNSLogCategory_DNSSEC_redacted;
    uint64_t result = os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC_redacted, OS_LOG_TYPE_FAULT);
    if ((_DWORD)result) {
      goto LABEL_12;
    }
  }

  return result;
}

uint64_t dnssec_obj_rrset_get_time_received(uint64_t a1)
{
  if (!*(void *)(a1 + 32))
  {
    int v4 = (os_log_s *)mDNSLogCategory_DNSSEC;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_DNSSEC == mDNSLogCategory_State)
    {
      uint64_t result = os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC, OS_LOG_TYPE_FAULT);
      if (!(_DWORD)result) {
        return result;
      }
    }

    else
    {
      int v4 = (os_log_s *)mDNSLogCategory_DNSSEC_redacted;
      uint64_t result = os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC_redacted, OS_LOG_TYPE_FAULT);
      if (!(_DWORD)result) {
        return result;
      }
    }

    int v8 = 136447234;
    __int16 v9 = "me->rr_count > 0";
    __int16 v10 = 2082;
    int v11 = "";
    __int16 v12 = 2082;
    uint64_t v13 = "/Library/Caches/com.apple.xbs/Sources/mDNSResponder/mDNSMacOSX/dnssec_v2/dnssec_objs/dnssec_obj_rrset.c";
    __int16 v14 = 1024;
    int v15 = 147;
    __int16 v16 = 2048;
    uint64_t v17 = 0LL;
LABEL_33:
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_FAULT,  "AssertMacros: %{public}s, %{public}s file: %{public}s, line: %d, value: %ld",  (uint8_t *)&v8,  0x30u);
    return 0LL;
  }

  uint64_t v1 = *(void *)(**(void **)(a1 + 24) + 56LL);
  if (!v1)
  {
    int v4 = (os_log_s *)mDNSLogCategory_DNSSEC;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_DNSSEC == mDNSLogCategory_State)
    {
      uint64_t result = os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC, OS_LOG_TYPE_FAULT);
      if (!(_DWORD)result) {
        return result;
      }
    }

    else
    {
      int v4 = (os_log_s *)mDNSLogCategory_DNSSEC_redacted;
      uint64_t result = os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC_redacted, OS_LOG_TYPE_FAULT);
      if (!(_DWORD)result) {
        return result;
      }
    }

    int v8 = 136447234;
    __int16 v9 = "rr->dnssec != NULL";
    __int16 v10 = 2082;
    int v11 = "";
    __int16 v12 = 2082;
    uint64_t v13 = "/Library/Caches/com.apple.xbs/Sources/mDNSResponder/mDNSMacOSX/dnssec_v2/dnssec_objs/dnssec_obj_rrset.c";
    __int16 v14 = 1024;
    int v15 = 149;
    __int16 v16 = 2048;
    uint64_t v17 = 0LL;
    goto LABEL_33;
  }

  uint64_t v2 = *(void *)(v1 + 16);
  if (v2) {
    return *(unsigned int *)(v2 + 80);
  }
  int v4 = (os_log_s *)mDNSLogCategory_DNSSEC;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_DNSSEC == mDNSLogCategory_State)
  {
    uint64_t result = os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC, OS_LOG_TYPE_FAULT);
    if ((_DWORD)result)
    {
LABEL_32:
      int v8 = 136447234;
      __int16 v9 = "cr != NULL";
      __int16 v10 = 2082;
      int v11 = "";
      __int16 v12 = 2082;
      uint64_t v13 = "/Library/Caches/com.apple.xbs/Sources/mDNSResponder/mDNSMacOSX/dnssec_v2/dnssec_objs/dnssec_obj_rrset.c";
      __int16 v14 = 1024;
      int v15 = 152;
      __int16 v16 = 2048;
      uint64_t v17 = 0LL;
      goto LABEL_33;
    }
  }

  else
  {
    int v4 = (os_log_s *)mDNSLogCategory_DNSSEC_redacted;
    uint64_t result = os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC_redacted, OS_LOG_TYPE_FAULT);
    if ((_DWORD)result) {
      goto LABEL_32;
    }
  }

  return result;
}

uint64_t dnssec_obj_rrset_get_rr_expire_time(uint64_t a1)
{
  if (*(void *)(a1 + 32)) {
    return resource_record_get_expiration_time(*(void *)(**(void **)(a1 + 24) + 56LL));
  }
  uint64_t v2 = (os_log_s *)mDNSLogCategory_DNSSEC;
  if (gSensitiveLoggingEnabled == 1 && mDNSLogCategory_DNSSEC != mDNSLogCategory_State)
  {
    uint64_t v2 = (os_log_s *)mDNSLogCategory_DNSSEC_redacted;
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC_redacted, OS_LOG_TYPE_FAULT)) {
      return 0LL;
    }
    goto LABEL_11;
  }

  if (os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC, OS_LOG_TYPE_FAULT))
  {
LABEL_11:
    int v5 = 136447234;
    __int16 v6 = "me->rr_count > 0";
    __int16 v7 = 2082;
    int v8 = "";
    __int16 v9 = 2082;
    __int16 v10 = "/Library/Caches/com.apple.xbs/Sources/mDNSResponder/mDNSMacOSX/dnssec_v2/dnssec_objs/dnssec_obj_rrset.c";
    __int16 v11 = 1024;
    int v12 = 185;
    __int16 v13 = 2048;
    uint64_t v14 = 0LL;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_FAULT,  "AssertMacros: %{public}s, %{public}s file: %{public}s, line: %d, value: %ld",  (uint8_t *)&v5,  0x30u);
  }

  return 0LL;
}

unsigned __int8 *dnssec_obj_rrset_copy_signer_name(uint64_t a1, int *a2)
{
  int v3 = -6727;
  if (!*(void *)(a1 + 32) || (int v15 = -6727, (v4 = *(unsigned __int8 **)(a1 + 24)) == 0LL))
  {
    uint64_t result = 0LL;
    goto LABEL_27;
  }

  while (1)
  {
    uint64_t v5 = *(void *)v4;
    if (**(unsigned __int8 **)v4 != 240)
    {
      if (*(_WORD *)(v5 + 4) == 46)
      {
        uint64_t result = dnssec_obj_domain_name_create_with_labels((unsigned __int8 *)(*(void *)(v5 + 40) + 22LL), 1, &v15);
        int v3 = v15;
        if (v15) {
          goto LABEL_27;
        }
      }

      else
      {
        uint64_t result = 0LL;
      }

      goto LABEL_20;
    }

    uint64_t v6 = *(void *)(v5 + 56);
    if (!v6)
    {
      uint64_t result = 0LL;
      int v3 = -6700;
      goto LABEL_27;
    }

    if (*(_DWORD *)(v6 + 32) || *(_BYTE *)(v6 + 40) || (uint64_t v7 = *(void *)(v6 + 48)) == 0)
    {
      uint64_t result = 0LL;
      int v3 = -6709;
      goto LABEL_27;
    }

    uint64_t v8 = *(unsigned __int8 *)(v7 + 72);
    if (!*(_BYTE *)(v7 + 72))
    {
LABEL_30:
      uint64_t result = 0LL;
      int v3 = -6727;
      goto LABEL_27;
    }

    uint64_t v9 = 0LL;
    uint64_t v10 = v7 + 104;
    while (1)
    {
      if (*(_BYTE *)(v10 + v9))
      {
        uint64_t v11 = **(void **)(v10 + 8 * v9 - 24);
        if (v11) {
          break;
        }
      }

      if (v8 == ++v9) {
        goto LABEL_30;
      }
    }

    uint64_t v13 = *(void *)(v11 + 80);
    int v15 = 0;
    uint64_t result = dnssec_obj_domain_name_create_with_labels(*(unsigned __int8 **)(v13 + 16), 1, &v15);
    if (v15) {
      break;
    }
    int v3 = 0;
LABEL_20:
    int v4 = (unsigned __int8 *)*((void *)v4 + 1);
    if (v4) {
      BOOL v14 = result == 0LL;
    }
    else {
      BOOL v14 = 0;
    }
    if (!v14) {
      goto LABEL_27;
    }
  }

  int v3 = v15;
LABEL_27:
  if (a2) {
    *a2 = v3;
  }
  return result;
}

BOOL dnssec_obj_rrset_is_dnskey(uint64_t a1)
{
  if (!*(void *)(a1 + 32) || (uint64_t v1 = *(unsigned __int8 ***)(a1 + 24)) == 0LL)
  {
    uint64_t v6 = (os_log_s *)mDNSLogCategory_DNSSEC;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_DNSSEC == mDNSLogCategory_State)
    {
      BOOL result = os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC, OS_LOG_TYPE_FAULT);
      if (!result) {
        return result;
      }
    }

    else
    {
      uint64_t v6 = (os_log_s *)mDNSLogCategory_DNSSEC_redacted;
      BOOL result = os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC_redacted, OS_LOG_TYPE_FAULT);
      if (!result) {
        return result;
      }
    }

    int v8 = 136447234;
    uint64_t v9 = "rrset->rr_count > 0 && rrset->rrs != NULL";
    __int16 v10 = 2082;
    uint64_t v11 = "";
    __int16 v12 = 2082;
    uint64_t v13 = "/Library/Caches/com.apple.xbs/Sources/mDNSResponder/mDNSMacOSX/dnssec_v2/dnssec_objs/dnssec_obj_rrset.c";
    __int16 v14 = 1024;
    int v15 = 284;
    __int16 v16 = 2048;
    uint64_t v17 = 0LL;
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_FAULT,  "AssertMacros: %{public}s, %{public}s file: %{public}s, line: %d, value: %ld",  (uint8_t *)&v8,  0x30u);
    return 0LL;
  }

  uint64_t v2 = *v1;
  if (*v2 == 240) {
    return 0LL;
  }
  int v4 = *((unsigned __int16 *)v2 + 2);
  if (v4 == 46) {
    return __rev16(*(unsigned __int16 *)(*((void *)v2 + 5) + 4LL)) == 48;
  }
  else {
    return v4 == 48;
  }
}

uint64_t dnssec_obj_rrset_get_denial_of_existence(uint64_t a1, int *a2)
{
  if (*(void *)(a1 + 32) != 1LL) {
    goto LABEL_14;
  }
  uint64_t v2 = **(unsigned __int8 ***)(a1 + 24);
  if (*v2 != 240)
  {
    uint64_t result = 0LL;
    int v5 = -6727;
    goto LABEL_10;
  }

  uint64_t v3 = *((void *)v2 + 7);
  if (!v3)
  {
LABEL_14:
    uint64_t result = 0LL;
    int v5 = -6709;
    goto LABEL_10;
  }

  if (*(_DWORD *)(v3 + 32) || *(_BYTE *)(v3 + 40)) {
    uint64_t result = 0LL;
  }
  else {
    uint64_t result = *(void *)(v3 + 48);
  }
  if (result) {
    int v5 = 0;
  }
  else {
    int v5 = -6727;
  }
LABEL_10:
  if (a2) {
    *a2 = v5;
  }
  return result;
}

uint64_t dnssec_obj_rrset_needs_to_update_cache(uint64_t a1, int a2)
{
  if (!*(void *)(a1 + 32))
  {
    uint64_t v11 = (os_log_s *)mDNSLogCategory_DNSSEC;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_DNSSEC == mDNSLogCategory_State)
    {
      uint64_t result = os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC, OS_LOG_TYPE_FAULT);
      if (!(_DWORD)result) {
        return result;
      }
    }

    else
    {
      uint64_t v11 = (os_log_s *)mDNSLogCategory_DNSSEC_redacted;
      uint64_t result = os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC_redacted, OS_LOG_TYPE_FAULT);
      if (!(_DWORD)result) {
        return result;
      }
    }

    int v14 = 136447234;
    int v15 = "me->rr_count > 0";
    __int16 v16 = 2082;
    uint64_t v17 = "";
    __int16 v18 = 2082;
    uint64_t v19 = "/Library/Caches/com.apple.xbs/Sources/mDNSResponder/mDNSMacOSX/dnssec_v2/dnssec_objs/dnssec_obj_rrset.c";
    __int16 v20 = 1024;
    int v21 = 455;
    __int16 v22 = 2048;
    uint64_t v23 = 0LL;
LABEL_41:
    _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_FAULT,  "AssertMacros: %{public}s, %{public}s file: %{public}s, line: %d, value: %ld",  (uint8_t *)&v14,  0x30u);
    return 0LL;
  }

  uint64_t v3 = **(unsigned __int8 ***)(a1 + 24);
  if (*v3 != 240) {
    goto LABEL_6;
  }
  uint64_t v4 = *((void *)v3 + 7);
  if (!v4)
  {
    uint64_t v11 = (os_log_s *)mDNSLogCategory_DNSSEC;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_DNSSEC == mDNSLogCategory_State)
    {
      uint64_t result = os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC, OS_LOG_TYPE_FAULT);
      if (!(_DWORD)result) {
        return result;
      }
    }

    else
    {
      uint64_t v11 = (os_log_s *)mDNSLogCategory_DNSSEC_redacted;
      uint64_t result = os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC_redacted, OS_LOG_TYPE_FAULT);
      if (!(_DWORD)result) {
        return result;
      }
    }

    int v14 = 136447234;
    int v15 = "me->rrs->rr->dnssec != NULL";
    __int16 v16 = 2082;
    uint64_t v17 = "";
    __int16 v18 = 2082;
    uint64_t v19 = "/Library/Caches/com.apple.xbs/Sources/mDNSResponder/mDNSMacOSX/dnssec_v2/dnssec_objs/dnssec_obj_rrset.c";
    __int16 v20 = 1024;
    int v21 = 457;
    __int16 v22 = 2048;
    uint64_t v23 = 0LL;
    goto LABEL_41;
  }

  if (!*(_DWORD *)(v4 + 32) && !*(_BYTE *)(v4 + 40))
  {
    uint64_t v9 = *(void *)(v4 + 48);
    if (v9)
    {
      unsigned int v10 = *(_DWORD *)(v9 + 16);
      if (v10 < 6 && ((0x27u >> v10) & 1) != 0) {
        return 0LL;
      }
    }
  }

void *dnssec_obj_rrset_copy_rrs(void *result, size_t *a2, _DWORD *a3)
{
  uint64_t v3 = (uint64_t *)result[3];
  if (!v3) {
    goto LABEL_17;
  }
  uint64_t v6 = result;
  size_t v7 = 0LL;
  do
  {
    uint64_t v8 = *v3;
    uint64_t v3 = (uint64_t *)v3[1];
    if (*(_WORD *)(v8 + 4) != 46) {
      ++v7;
    }
  }

  while (v3);
  if (v7 && !(v7 >> 61) && (uint64_t result = calloc(v7, 8uLL)) != 0LL)
  {
    uint64_t v9 = (void *)v6[3];
    if (v9)
    {
      uint64_t v10 = 0LL;
      do
      {
        if (*(_WORD *)(*v9 + 4LL) != 46) {
          result[v10++] = *v9;
        }
        uint64_t v9 = (void *)v9[1];
      }

      while (v9);
    }

    *a2 = v7;
    if (a3) {
      *a3 = 0;
    }
  }

  else
  {
LABEL_17:
    __break(1u);
  }

  return result;
}

uint64_t dnssec_obj_rrset_copy_dses_with_supported_algorithm(uint64_t a1, size_t *a2, int *a3)
{
  int v18 = 0;
  int v5 = *(uint64_t **)(a1 + 24);
  if (!v5) {
    goto LABEL_18;
  }
  size_t v7 = 0LL;
  do
  {
    uint64_t result = *v5;
    if (*(_WORD *)(*v5 + 4) == 43)
    {
      uint64_t result = resource_record_as_ds_refers_to_supported_key_algorithm(result);
      v7 += result;
    }

    int v5 = (uint64_t *)v5[1];
  }

  while (v5);
  if (!v7)
  {
LABEL_18:
    int v15 = *(_DWORD *)(a1 + 40);
    uint64_t v9 = 0LL;
    uint64_t v13 = 0LL;
    if (v15 == 4 || v15 == 2) {
      int v14 = -6727;
    }
    else {
      int v14 = -6745;
    }
    int v18 = v14;
LABEL_25:
    if (!a3) {
      goto LABEL_27;
    }
    goto LABEL_26;
  }

  if (!(v7 >> 61))
  {
    uint64_t result = (uint64_t)calloc(v7, 8uLL);
    if (result)
    {
      uint64_t v9 = (void *)result;
      uint64_t v10 = *(uint64_t **)(a1 + 24);
      if (v10)
      {
        uint64_t v11 = 0LL;
        while (1)
        {
          uint64_t v12 = *v10;
          if (*(_WORD *)(*v10 + 4) == 43) {
            goto LABEL_14;
          }
          if ((resource_record_as_ds_refers_to_supported_key_algorithm(v12) & 1) == 0) {
            break;
          }
LABEL_16:
          uint64_t v10 = (uint64_t *)v10[1];
          if (!v10) {
            goto LABEL_38;
          }
        }

        uint64_t v12 = *v10;
LABEL_14:
        uint64_t v13 = v11 + 1;
        v9[v11] = dnssec_obj_rr_ds_create( *(unsigned __int8 **)(v12 + 32),  *(_WORD *)(v12 + 6),  (const void *)(*(void *)(v12 + 40) + 4LL),  *(unsigned __int16 *)(v12 + 12),  0,  &v18);
        int v14 = v18;
        if (v18) {
          goto LABEL_25;
        }
        ++v11;
        goto LABEL_16;
      }

      uint64_t v11 = 0LL;
LABEL_38:
      int v14 = 0;
      *a2 = v7;
      int v18 = 0;
      uint64_t v13 = v11;
      if (!a3)
      {
LABEL_27:
        if (v14)
        {
          if (v13)
          {
            uint64_t v17 = (void **)v9;
            do
            {
              if (*v17)
              {
                ref_count_obj_release(*v17);
                const char *v17 = 0LL;
              }

              ++v17;
              --v13;
            }

            while (v13);
            goto LABEL_35;
          }

          if (v9)
          {
LABEL_35:
            free(v9);
            return 0LL;
          }
        }

        return (uint64_t)v9;
      }

void *dnssec_obj_rrset_copy_dnskeys(void *result, size_t *a2, int *a3)
{
  uint64_t v3 = (uint64_t *)result[3];
  if (!v3) {
    goto LABEL_28;
  }
  uint64_t v6 = result;
  size_t v7 = 0LL;
  do
  {
    uint64_t v8 = *v3;
    uint64_t v3 = (uint64_t *)v3[1];
    if (*(_WORD *)(v8 + 4) == 48) {
      ++v7;
    }
  }

  while (v3);
  if (v7 && !(v7 >> 61) && (uint64_t result = calloc(v7, 8uLL)) != 0LL)
  {
    uint64_t v9 = result;
    int v15 = 0;
    uint64_t v10 = (void *)v6[3];
    if (v10)
    {
      uint64_t v11 = 0LL;
      do
      {
        if (*(_WORD *)(*v10 + 4LL) == 48)
        {
          uint64_t v12 = v11 + 1;
          v9[v11] = dnssec_obj_rr_dnskey_create( *(unsigned __int8 **)(*v10 + 32LL),  *(_WORD *)(*v10 + 6LL),  (_BYTE *)(*(void *)(*v10 + 40LL) + 4LL),  *(unsigned __int16 *)(*v10 + 12LL),  &v15);
          int v13 = v15;
          if (v15) {
            goto LABEL_18;
          }
          ++v11;
        }

        uint64_t v10 = (void *)v10[1];
      }

      while (v10);
    }

    else
    {
      uint64_t v11 = 0LL;
    }

    int v13 = 0;
    *a2 = v7;
    int v15 = 0;
    uint64_t v12 = v11;
LABEL_18:
    if (a3) {
      *a3 = v13;
    }
    if (v13)
    {
      if (v12)
      {
        int v14 = (void **)v9;
        do
        {
          if (*v14)
          {
            ref_count_obj_release(*v14);
            void *v14 = 0LL;
          }

          ++v14;
          --v12;
        }

        while (v12);
      }

      free(v9);
      return 0LL;
    }

    return v9;
  }

  else
  {
LABEL_28:
    __break(1u);
  }

  return result;
}

uint64_t dnssec_obj_rrset_add_rr(uint64_t a1, unsigned __int8 *a2)
{
  uint64_t v2 = *((void *)a2 + 7);
  if (!v2) {
    return 4294960591LL;
  }
  int v5 = *(_DWORD *)(a1 + 40);
  if (v5 == 2)
  {
    if (!*(void *)(a1 + 32)) {
      return 4294960591LL;
    }
  }

  else if (v5 == 1)
  {
    if (!*(void *)(a1 + 32)) {
      return 4294960587LL;
    }
  }

  else if (!v5 && *(void *)(a1 + 32))
  {
    return 4294960587LL;
  }

  if (*a2 == 240)
  {
    unint64_t v6 = *(void *)(a1 + 32);
    if (v6)
    {
      if (v6 == 1)
      {
        else {
          return 4294960587LL;
        }
      }

      return 4294960587LL;
    }

uint64_t dnssec_obj_rrset_remove_rr(uint64_t a1, unsigned __int8 *a2)
{
  if (!*((void *)a2 + 7)) {
    return 4294960591LL;
  }
  uint64_t v4 = (void *)(a1 + 24);
  uint64_t v3 = *(unsigned __int8 ***)(a1 + 24);
  if (!v3) {
    goto LABEL_3;
  }
  int v9 = *a2;
  if (*v3 != a2)
  {
    while (1)
    {
      uint64_t v10 = v3;
      uint64_t v3 = (unsigned __int8 **)v3[1];
      if (!v3) {
        break;
      }
      if (*v3 == a2)
      {
        uint64_t v4 = v10 + 1;
        goto LABEL_14;
      }
    }

LABEL_3:
    int v5 = (os_log_s *)mDNSLogCategory_DNSSEC;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_DNSSEC == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC, OS_LOG_TYPE_FAULT)) {
        return 4294960569LL;
      }
      __int16 v17 = 0;
      size_t v7 = (uint8_t *)&v17;
    }

    else
    {
      int v5 = (os_log_s *)mDNSLogCategory_DNSSEC_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC_redacted, OS_LOG_TYPE_FAULT)) {
        return 4294960569LL;
      }
      __int16 v16 = 0;
      size_t v7 = (uint8_t *)&v16;
    }

    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_FAULT, "Record to be removed is not found.", v7, 2u);
    return 4294960569LL;
  }

  if (!*(_BYTE *)(a2 + 356))
  {
LABEL_60:
    _dns_push_discovery_stop((unsigned int *)a1, &v37, v8, 1);
    return;
  }

  int v9 = dns_obj_domain_name_create_with_labels((_BYTE *)(*(unsigned __int8 *)(a2 + 356) + a2 + 356 + 1), &v36);
  uint64_t v10 = v9;
  if (v36)
  {
    if (v9) {
      ref_count_obj_release(v9);
    }
    goto LABEL_60;
  }

  *(void *)(a1 + 240) = a2;
  mDNS_StopQuery((unsigned int *)a1, a2);
  *(void *)(a1 + 240) = 0LL;
  uint64_t v23 = *((void *)v10 + 3);
  if (v23 >= 0x100)
  {
    fprintf( __stderrp,  "AssertMacros: %s, %s file: %s, line: %d, value: %lld\n",  "labels_length < sizeof(question->qname.c)",  "",  "/Library/Caches/com.apple.xbs/Sources/mDNSResponder/mDNSMacOSX/dns_push/dns_push_discovery.c",  385,  0LL);
  }

  else
  {
    memcpy((void *)(a2 + 356), *((const void **)v10 + 2), v23);
    *(_DWORD *)(a2 + 200) = DomainNameHashValue(a2 + 356);
    mDNS_StartQuery((unsigned int *)a1, a2);
  }

  ref_count_obj_release(v10);
}

  handle = dispatch_source_get_handle(v0);
  size_t v7 = &unk_100158000;
  if (handle == -1)
  {
    if (!mDNS_LoggingEnabled) {
      goto LABEL_104;
    }
    goto LABEL_102;
  }

  if (mDNS_LoggingEnabled) {
    LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "mDNSMacOSXUpdateEtcHosts: Parsing /etc/hosts fd %d",  v2,  v3,  v4,  v5,  v6,  handle);
  }
  uint64_t v8 = fopen("/etc/hosts", "r");
  if (!v8)
  {
    if (mDNS_LoggingEnabled != 1) {
      goto LABEL_104;
    }
    CFStringRef v78 = (os_log_s *)mDNSLogCategory_Default;
    uint64_t v79 = "mDNSMacOSXParseEtcHosts: fp is NULL";
    goto LABEL_103;
  }

  int v9 = v8;
  bzero(v101, 0x400uLL);
  while (fgets((char *)v101, 1024, v9))
  {
    if (LOBYTE(v101[0]) > 0x23u || ((1LL << SLOBYTE(v101[0])) & 0x800002400LL) == 0)
    {
      uint64_t v11 = strlen((const char *)v101);
      if (!v11) {
        break;
      }
      __int16 v17 = v11 - 1;
      int v18 = *((unsigned __int8 *)v101 + v11 - 1);
      if (v18 == 13 || v18 == 10)
      {
        *((_BYTE *)v101 + v17) = 0;
        if (v11 == 1) {
          goto LABEL_28;
        }
        __int16 v20 = v11 - 2;
        int v18 = *((unsigned __int8 *)v101 + v11 - 2);
      }

      else
      {
        __int16 v20 = v11 - 1;
        LODWORD(v17) = v11;
      }

      int v21 = v18 == 13 || v18 == 10;
      if (!v21 || (*((_BYTE *)v101 + v20) = 0, LODWORD(v17) = v20, v20))
      {
        for (uint64_t i = (const char *)v101; ; ++i)
        {
          uint64_t v23 = *(unsigned __int8 *)i;
          if (v23 != 9 && v23 != 32) {
            break;
          }
          LODWORD(v17) = v17 - 1;
        }

        if ((int)v17 < 1)
        {
          LODWORD(vmemset(&v5[1], 0, 24) = 0;
          int v27 = 0;
        }

        else
        {
          int v24 = 0LL;
          while (1)
          {
            uint64_t v25 = i[v24];
            if (v25 <= 0x2C && ((1LL << v25) & 0x102100000200LL) != 0) {
              break;
            }
            if (v17 == ++v24)
            {
              int v27 = 0;
              LODWORD(vmemset(&v5[1], 0, 24) = v17;
              goto LABEL_47;
            }
          }

          if (v25 == 37) {
            int v27 = v24 + 1;
          }
          else {
            int v27 = 0;
          }
          i[v24] = 0;
        }

uint64_t dnssec_obj_rrset_matches_dnskey_key_tag(uint64_t a1, uint64_t a2, unint64_t a3)
{
  if (!*(void *)(a1 + 32))
  {
    int v18 = (os_log_s *)mDNSLogCategory_DNSSEC;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_DNSSEC == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC, OS_LOG_TYPE_FAULT)) {
        return 0LL;
      }
    }

    else
    {
      int v18 = (os_log_s *)mDNSLogCategory_DNSSEC_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC_redacted, OS_LOG_TYPE_FAULT)) {
        return 0LL;
      }
    }

    *(_DWORD *)buf = 136447234;
    uint64_t v28 = "me->rr_count > 0";
    __int16 v29 = 2082;
    int v30 = "";
    __int16 v31 = 2082;
    uint64_t v32 = "/Library/Caches/com.apple.xbs/Sources/mDNSResponder/mDNSMacOSX/dnssec_v2/dnssec_objs/dnssec_obj_rrset.c";
    __int16 v33 = 1024;
    int v34 = 847;
    __int16 v35 = 2048;
    uint64_t v36 = 0LL;
    goto LABEL_64;
  }

  unint64_t v5 = *(void *)(a1 + 24);
  if (**(unsigned __int8 **)v5 == 240)
  {
    int v26 = 0;
    uint64_t denial_of_existence = dnssec_obj_rrset_get_denial_of_existence(a1, &v26);
    uint64_t v7 = v26;
    if (v26)
    {
      int v18 = (os_log_s *)mDNSLogCategory_DNSSEC;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_DNSSEC == mDNSLogCategory_State)
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC, OS_LOG_TYPE_FAULT)) {
          return 0LL;
        }
      }

      else
      {
        int v18 = (os_log_s *)mDNSLogCategory_DNSSEC_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC_redacted, OS_LOG_TYPE_FAULT)) {
          return 0LL;
        }
      }

      *(_DWORD *)buf = 136447234;
      uint64_t v28 = "err == 0";
      __int16 v29 = 2082;
      int v30 = "";
      __int16 v31 = 2082;
      uint64_t v32 = "/Library/Caches/com.apple.xbs/Sources/mDNSResponder/mDNSMacOSX/dnssec_v2/dnssec_objs/dnssec_obj_rrset.c";
      __int16 v33 = 1024;
      int v34 = 867;
      __int16 v35 = 2048;
      uint64_t v36 = v7;
      goto LABEL_64;
    }

    if (!*(_BYTE *)(denial_of_existence + 72))
    {
      int v18 = (os_log_s *)mDNSLogCategory_DNSSEC;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_DNSSEC == mDNSLogCategory_State)
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC, OS_LOG_TYPE_FAULT)) {
          return 0LL;
        }
      }

      else
      {
        int v18 = (os_log_s *)mDNSLogCategory_DNSSEC_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC_redacted, OS_LOG_TYPE_FAULT)) {
          return 0LL;
        }
      }

      *(_DWORD *)buf = 136447234;
      uint64_t v28 = "me->nsec_count > 0";
      __int16 v29 = 2082;
      int v30 = "";
      __int16 v31 = 2082;
      uint64_t v32 = "/Library/Caches/com.apple.xbs/Sources/mDNSResponder/mDNSMacOSX/dnssec_v2/dnssec_objs/dnssec_obj_denial_of_existence.c";
      __int16 v33 = 1024;
      int v34 = 227;
      __int16 v35 = 2048;
      uint64_t v36 = 0LL;
      goto LABEL_64;
    }

    uint64_t v8 = 0LL;
    while (1)
    {
      unint64_t v9 = *(unsigned __int8 *)(denial_of_existence + v8 + 104);
      if (!*(_BYTE *)(denial_of_existence + v8 + 104)) {
        break;
      }
      unint64_t v10 = 0LL;
      do
      {
        while (!a3)
        {
          if (++v10 >= v9) {
            return 0LL;
          }
        }

        unint64_t v11 = 0LL;
        unsigned int v12 = __rev16(*(unsigned __int16 *)(*(void *)(*(void *)(*(void *)(denial_of_existence + 8 * v8 + 80)
                                                                  + 8 * v10)
                                                      + 24LL)
                                          + 16LL));
        do
        {
          int v13 = *(unsigned __int16 *)(*(void *)(a2 + 8 * v11) + 80LL);
          unint64_t v5 = v13 == v12;
          ++v11;
        }

        while (v11 < a3 && v13 != v12);
        ++v10;
      }

      while (v10 < v9 && v13 != v12);
      ++v8;
    }

    int v18 = (os_log_s *)mDNSLogCategory_DNSSEC;
    if (gSensitiveLoggingEnabled == 1 && mDNSLogCategory_DNSSEC != mDNSLogCategory_State)
    {
      int v18 = (os_log_s *)mDNSLogCategory_DNSSEC_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC_redacted, OS_LOG_TYPE_FAULT)) {
        return 0LL;
      }
      goto LABEL_37;
    }

    if (os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC, OS_LOG_TYPE_FAULT))
    {
LABEL_37:
      *(_DWORD *)buf = 136447234;
      uint64_t v28 = "me->nsec_rrsig_count[i] > 0";
      __int16 v29 = 2082;
      int v30 = "";
      __int16 v31 = 2082;
      uint64_t v32 = "/Library/Caches/com.apple.xbs/Sources/mDNSResponder/mDNSMacOSX/dnssec_v2/dnssec_objs/dnssec_obj_denial_of_existence.c";
      __int16 v33 = 1024;
      int v34 = 230;
      __int16 v35 = 2048;
      uint64_t v36 = 0LL;
LABEL_64:
      _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_FAULT,  "AssertMacros: %{public}s, %{public}s file: %{public}s, line: %d, value: %ld",  buf,  0x30u);
    }

    return 0LL;
  }

  while (*(_WORD *)(*(void *)v5 + 4LL) != 46 || !a3)
  {
LABEL_28:
    unint64_t v5 = *(void *)(v5 + 8);
    if (!v5) {
      return v5;
    }
  }

  unsigned int v15 = __rev16(*(unsigned __int16 *)(*(void *)(*(void *)v5 + 40LL) + 20LL));
  unint64_t v16 = a3;
  uint64_t v17 = a2;
  while (*(unsigned __int16 *)(*(void *)v17 + 80LL) != v15)
  {
    v17 += 8LL;
    if (!--v16) {
      goto LABEL_28;
    }
  }

  return 1LL;
}

uint64_t dnssec_obj_rrset_validate_with_dnskeys(uint64_t *a1, _DWORD **a2, size_t a3, unsigned __int8 *a4)
{
  uint64_t v4 = a4;
  uint64_t v5 = *((unsigned int *)a1 + 11);
  if ((_DWORD)v5)
  {
    size_t v14 = 0LL;
    unsigned int v15 = 0LL;
    size_t v16 = 0LL;
    uint64_t v17 = 0LL;
    int v19 = -6719;
LABEL_16:
    int v61 = v19;
    if (!a4) {
      goto LABEL_54;
    }
LABEL_53:
    *(_DWORD *)uint64_t v4 = v61;
    goto LABEL_54;
  }

  unint64_t v6 = a1;
  int v7 = *((_DWORD *)a1 + 10);
  BOOL v8 = v7 == 2 || v7 == 4;
  if (!v8 || (uint64_t v9 = a1[4]) == 0)
  {
    size_t v14 = 0LL;
    uint64_t v5 = 0LL;
    unsigned int v15 = 0LL;
    size_t v16 = 0LL;
    uint64_t v17 = 0LL;
    int v19 = -6745;
    goto LABEL_16;
  }

  unsigned int v12 = (unsigned __int8 *)a1[3];
  if (**(unsigned __int8 **)v12 != 240)
  {
    size_t v20 = 0LL;
    size_t v21 = 0LL;
    do
    {
      __int16 v22 = *(void **)v12;
      unsigned int v12 = (unsigned __int8 *)*((void *)v12 + 1);
      if (*((_WORD *)v22 + 2) == 46) {
        ++v20;
      }
      else {
        ++v21;
      }
    }

    while (v12);
    if (v20 + v21 == v9)
    {
      if (!v21
        || v21 >> 61
        || (uint64_t v23 = (_DWORD **)calloc(v21, 8uLL)) == 0LL
        || !v20
        || v20 >> 61
        || (v17 = v23, (int v24 = (_DWORD **)calloc(v20, 8uLL)) == 0LL))
      {
LABEL_99:
        __break(1u);
LABEL_100:
        uint64_t v5 = 3LL;
        int v53 = -6750;
        goto LABEL_98;
      }

      unsigned int v15 = v24;
      uint64_t v54 = v6;
      uint64_t v56 = v4;
      int v61 = -6736;
      unint64_t v6 = (uint64_t *)v6[3];
      if (!v6)
      {
        size_t v14 = 0LL;
        size_t v16 = 0LL;
LABEL_47:
        __int16 v33 = dnssec_obj_rr_validator_create(v17, v16, v15, v14, a2, a3, 0LL, 0LL, 0LL, 0LL, &v61);
        uint64_t v5 = dnssec_obj_rr_validator_validate_rrset((uint64_t)v33, &v61);
        ref_count_obj_release(v33);
        unint64_t v6 = v54;
        uint64_t v4 = v56;
        goto LABEL_48;
      }

      size_t v16 = 0LL;
      size_t v14 = 0LL;
      uint64_t v57 = v24;
      int v58 = v17;
      while (1)
      {
        uint64_t v25 = *v6;
        int v26 = *(unsigned __int16 *)(*v6 + 4);
        uint64_t v4 = *(unsigned __int8 **)(*v6 + 32);
        if (v26 == 46)
        {
          v15[v14++] = (_DWORD *)dnssec_obj_rr_rrsig_create( *(unsigned __int8 **)(*v6 + 32),  (const void *)(*(void *)(v25 + 40) + 4LL),  *(unsigned __int16 *)(v25 + 12),  0,  &v61);
        }

        else
        {
          __int16 v60 = *(_WORD *)(v25 + 6);
          uint64_t v27 = *(void *)(v25 + 40);
          unsigned int v28 = *(unsigned __int16 *)(v25 + 12);
          v62[0] = 0;
          __int16 v29 = calloc(1uLL, 0x50uLL);
          if (!v29) {
            goto LABEL_99;
          }
          int v30 = v29;
          uint64_t v59 = (const void *)(v27 + 4);
          __int16 v31 = &_dnssec_obj_rr_kind;
          v29[1] = &_dnssec_obj_rr_kind;
          do
          {
            uint64_t v32 = (void (*)(void *))v31[2];
            if (v32) {
              v32(v30);
            }
            __int16 v31 = (_UNKNOWN **)*v31;
          }

          while (v31);
          ++*(_DWORD *)v30;
          dnssec_obj_rr_init_fields((uint64_t)v30, v4, v26, v60, v59, v28, 0, 0LL, v62);
          if (v62[0])
          {
            int v61 = v62[0];
            ref_count_obj_release(v30);
            int v30 = 0LL;
          }

          else
          {
            int v61 = 0;
          }

          uint64_t v17 = v58;
          v58[v16++] = v30;
          unsigned int v15 = v57;
        }

        if (v61) {
          break;
        }
        unint64_t v6 = (uint64_t *)v6[1];
        if (!v6) {
          goto LABEL_47;
        }
      }

      uint64_t v5 = 0LL;
      uint64_t v4 = v56;
LABEL_52:
      if (!v4) {
        goto LABEL_54;
      }
      goto LABEL_53;
    }

    goto LABEL_12;
  }

  uint64_t v13 = *(void *)(*(void *)v12 + 56LL);
  if (!v13)
  {
    size_t v14 = 0LL;
    unsigned int v15 = 0LL;
    size_t v16 = 0LL;
    uint64_t v17 = 0LL;
    int v18 = -6736;
LABEL_13:
    int v61 = v18;
    uint64_t v5 = 3LL;
    if (!a4) {
      goto LABEL_54;
    }
    goto LABEL_53;
  }

  if (*(_DWORD *)(v13 + 32) || *(_BYTE *)(v13 + 40) || (uint64_t v37 = *(void *)(v13 + 48)) == 0)
  {
LABEL_12:
    size_t v14 = 0LL;
    unsigned int v15 = 0LL;
    size_t v16 = 0LL;
    uint64_t v17 = 0LL;
    int v18 = -6709;
    goto LABEL_13;
  }

  if (!*(_DWORD *)(v37 + 16))
  {
    uint64_t v5 = 3LL;
    int v53 = -6720;
    goto LABEL_98;
  }

  if (!*(_BYTE *)(v37 + 72))
  {
    uint64_t v5 = 3LL;
    int v53 = -6736;
    goto LABEL_98;
  }

  uint64_t v38 = 0LL;
  do
  {
    unint64_t v39 = *(unsigned __int8 *)(v37 + v38 + 104);
    if (!*(_BYTE *)(v37 + v38 + 104)) {
      goto LABEL_97;
    }
    unint64_t v40 = 0LL;
    do
    {
      while (1)
      {
        uint64_t v41 = *(void *)(*(void *)(v37 + 8 * v38 + 80) + 8 * v40);
        if (!v41) {
          goto LABEL_100;
        }
        if (a3) {
          break;
        }
        if (++v40 >= v39) {
          goto LABEL_97;
        }
      }

      size_t v42 = 0LL;
      unsigned int v43 = __rev16(*(unsigned __int16 *)(*(void *)(v41 + 24) + 16LL));
      do
        int v44 = *((unsigned __int16 *)a2[v42++] + 40);
      while (v42 < a3 && v43 != v44);
      ++v40;
    }

    while (v40 < v39 && v43 != v44);
    if (v43 != v44)
    {
LABEL_97:
      uint64_t v5 = 0LL;
      int v53 = -6745;
      goto LABEL_98;
    }

    ++v38;
  }

  while (v38 != *(unsigned __int8 *)(v37 + 72));
  uint64_t v5 = 0LL;
  uint64_t v46 = 0LL;
  int v63 = -6736;
  uint64_t v47 = v37 + 104;
  while (1)
  {
    uint64_t v48 = v47 + 8 * v46;
    uint64_t v49 = *(_DWORD ***)(v48 - 24);
    size_t v50 = *(unsigned __int8 *)(v47 + v46);
    int v51 = *(_DWORD *)(v37 + 44);
    if (v51 == 2) {
      goto LABEL_94;
    }
    if (v51 != 1) {
      break;
    }
    uint64_t v48 = v47 + 8 * v46;
LABEL_94:
    *(void *)uint64_t v62 = *(void *)(v48 - 56);
    uint64_t v52 = dnssec_obj_rr_validator_create((_DWORD **)v62, 1uLL, v49, v50, a2, a3, 0LL, 0LL, 0LL, 0LL, &v63);
    uint64_t v5 = dnssec_obj_rr_validator_validate_rrset((uint64_t)v52, &v63);
    ref_count_obj_release(v52);
    int v53 = v63;
    goto LABEL_103;
  }

  int v53 = -6736;
LABEL_103:
  unint64_t v6 = a1;
LABEL_98:
  size_t v14 = 0LL;
  unsigned int v15 = 0LL;
  size_t v16 = 0LL;
  uint64_t v17 = 0LL;
  int v61 = v53;
LABEL_48:
  *((_DWORD *)v6 + 11) = v5;
  if (!(_DWORD)v5) {
    goto LABEL_52;
  }
  *((_DWORD *)v6 + 12) = v61;
  if (v4) {
    goto LABEL_53;
  }
LABEL_54:
  if (v14)
  {
    int v34 = (void **)v15;
    do
    {
      if (*v34)
      {
        ref_count_obj_release(*v34);
        *int v34 = 0LL;
      }

      ++v34;
      --v14;
    }

    while (v14);
  }

  if (v16)
  {
    __int16 v35 = (void **)v17;
    do
    {
      if (*v35)
      {
        ref_count_obj_release(*v35);
        *__int16 v35 = 0LL;
      }

      ++v35;
      --v16;
    }

    while (v16);
  }

  if (v15) {
    free(v15);
  }
  if (v17) {
    free(v17);
  }
  return v5;
}

uint64_t dnssec_obj_rrset_validate_with_dses_or_trust_anchors( uint64_t a1, _DWORD **a2, size_t a3, _DWORD **a4, size_t a5, _DWORD *a6)
{
  int v40 = 0;
  uint64_t v7 = *(unsigned int *)(a1 + 44);
  if ((_DWORD)v7)
  {
    uint64_t v27 = 0LL;
    int v24 = 0LL;
    size_t v26 = 0LL;
    __int16 v22 = 0LL;
    size_t v16 = 0LL;
    int v30 = -6719;
    goto LABEL_37;
  }

  int v9 = *(_DWORD *)(a1 + 40);
  BOOL v10 = v9 == 2 || v9 == 4;
  if (!v10 || !*(void *)(a1 + 32)) {
    goto LABEL_36;
  }
  if (***(unsigned __int8 ***)(a1 + 24) == 240)
  {
    uint64_t v27 = 0LL;
    int v24 = 0LL;
    size_t v26 = 0LL;
    __int16 v22 = 0LL;
    size_t v16 = 0LL;
    int v31 = -6736;
    goto LABEL_42;
  }

  if (!dnssec_obj_rrset_is_dnskey(a1))
  {
    uint64_t v27 = 0LL;
    int v24 = 0LL;
    size_t v26 = 0LL;
    __int16 v22 = 0LL;
    size_t v16 = 0LL;
    int v31 = -6705;
    goto LABEL_42;
  }

  if (!(a5 | a3))
  {
LABEL_36:
    uint64_t v7 = 0LL;
    uint64_t v27 = 0LL;
    int v24 = 0LL;
    size_t v26 = 0LL;
    __int16 v22 = 0LL;
    size_t v16 = 0LL;
    int v30 = -6745;
    goto LABEL_37;
  }

  uint64_t v15 = *(void *)(a1 + 16);
  size_t v16 = dnssec_obj_rrset_copy_signer_name(a1, &v40);
  if (v40)
  {
    uint64_t v7 = 0LL;
    uint64_t v27 = 0LL;
    int v24 = 0LL;
    size_t v26 = 0LL;
    __int16 v22 = 0LL;
    int v30 = -6728;
LABEL_37:
    int v40 = v30;
    if (!a6) {
      goto LABEL_50;
    }
    goto LABEL_49;
  }

  if (ref_count_obj_compare(v15, (uint64_t)v16, 1LL))
  {
    uint64_t v27 = 0LL;
    int v24 = 0LL;
    size_t v26 = 0LL;
    __int16 v22 = 0LL;
    int v31 = -90005;
LABEL_42:
    int v40 = v31;
    uint64_t v7 = 3LL;
    if (!a6) {
      goto LABEL_50;
    }
    goto LABEL_49;
  }

  uint64_t v17 = *(void **)(a1 + 24);
  if (!v17)
  {
    if (*(void *)(a1 + 32))
    {
LABEL_41:
      uint64_t v27 = 0LL;
      int v24 = 0LL;
      size_t v26 = 0LL;
      __int16 v22 = 0LL;
      int v31 = -6709;
      goto LABEL_42;
    }

void *_mdns_dns_service_manager_copy_description(void *a1, int a2, char a3)
{
  uint64_t v19 = 0LL;
  int v20 = &v19;
  uint64_t v21 = 0x2000000000LL;
  int v22 = 0;
  uint64_t v15 = 0LL;
  size_t v16 = &v15;
  uint64_t v17 = 0x2000000000LL;
  uint64_t v18 = 0LL;
  unint64_t v6 = (void *)mdns_string_builder_create();
  if (v6)
  {
    uint64_t v7 = v6;
    if (a2)
    {
      int appended = mdns_string_builder_append_formatted(v6, "<%s: %p>: ", *(const char **)(a1[2] + 8LL), a1);
      *((_DWORD *)v20 + 6) = appended;
      if (appended) {
        goto LABEL_7;
      }
    }

    int v9 = mdns_string_builder_append_formatted(v7, "{");
    *((_DWORD *)v20 + 6) = v9;
    if (v9) {
      goto LABEL_7;
    }
    v16[3] = (uint64_t)"\n\t";
    v13[0] = _NSConcreteStackBlock;
    v13[1] = 0x40000000LL;
    v13[2] = ___mdns_dns_service_manager_copy_description_block_invoke;
    v13[3] = &unk_10013AAA8;
    v13[4] = &v19;
    v13[5] = &v15;
    v13[6] = v7;
    char v14 = a3;
    v23[0] = _NSConcreteStackBlock;
    v23[1] = 0x40000000LL;
    v23[2] = ___mdns_dns_service_manager_enumerate_all_services_block_invoke;
    v23[3] = &unk_10013B1D8;
    v23[4] = v13;
    v24[0] = _NSConcreteStackBlock;
    v24[1] = 0x40000000LL;
    _DWORD v24[2] = ___mdns_dns_service_manager_enumerate_all_service_arrays_block_invoke;
    v24[3] = &unk_10013B1B0;
    v24[4] = v23;
    _mdns_dns_service_manager_enumerate_all_service_array_pointers((uint64_t)a1, (uint64_t)v24);
    if (*((_DWORD *)v20 + 6)
      || (int v10 = mdns_string_builder_append_formatted(v7, "\n}"), (*((_DWORD *)v20 + 6) = v10) != 0))
    {
LABEL_7:
      unint64_t v11 = 0LL;
    }

    else
    {
      unint64_t v11 = mdns_string_builder_copy_string((uint64_t)v7);
    }

    os_release(v7);
  }

  else
  {
    unint64_t v11 = 0LL;
  }

  _Block_object_dispose(&v15, 8);
  _Block_object_dispose(&v19, 8);
  return v11;
}

void _mdns_dns_service_manager_finalize(void *a1)
{
  uint64_t v2 = (const void *)a1[10];
  if (v2)
  {
    CFRelease(v2);
    a1[10] = 0LL;
  }

  uint64_t v3 = (dispatch_object_s *)a1[11];
  if (v3)
  {
    dispatch_release(v3);
    a1[11] = 0LL;
  }

  uint64_t v4 = (const void *)a1[13];
  if (v4)
  {
    _Block_release(v4);
    a1[13] = 0LL;
  }

uint64_t _mdns_dns_service_manager_enumerate_all_service_array_pointers(uint64_t a1, uint64_t a2)
{
  v7[0] = a1 + 24;
  v7[1] = a1 + 32;
  v7[2] = a1 + 40;
  v7[3] = a1 + 48;
  v7[4] = a1 + 56;
  v7[5] = a1 + 64;
  v7[6] = a1 + 72;
  uint64_t result = (*(uint64_t (**)(uint64_t))(a2 + 16))(a2);
  if ((_DWORD)result)
  {
    uint64_t v4 = 1LL;
    unint64_t v5 = 6LL;
    while (v4 != 7)
    {
      char v6 = (*(uint64_t (**)(uint64_t, void))(a2 + 16))(a2, v7[v4++]);
      if ((v6 & 1) == 0)
      {
        unint64_t v5 = v4 - 2;
        return v5 > 5;
      }
    }

    return v5 > 5;
  }

  return result;
}

BOOL ___mdns_dns_service_manager_finalize_block_invoke(id a1, __CFArray **a2)
{
  if (*a2)
  {
    CFRelease(*a2);
    *a2 = 0LL;
  }

  return 1;
}

BOOL ___mdns_dns_service_manager_copy_description_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = mdns_string_builder_append_description_with_prefix( *(void **)(a1 + 48),  *(const char **)(*(void *)(*(void *)(a1 + 40) + 8LL)
                                                                                 + 24LL),
                                                                  a2,
                                                                  *(_BYTE *)(a1 + 56));
  *(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = ",\n\t";
  return *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) == 0;
}

BOOL ___mdns_dns_service_manager_enumerate_all_services_block_invoke(uint64_t a1, const __CFArray *a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000LL;
  v4[2] = ___mdns_dns_service_enumerate_array_including_variants_and_discovered_alts_block_invoke;
  v4[3] = &unk_10013B200;
  v4[4] = v2;
  return mdns_cfarray_enumerate(a2, (uint64_t)v4);
}

uint64_t ___mdns_dns_service_manager_enumerate_all_service_arrays_block_invoke(uint64_t a1, void *a2)
{
  if (*a2) {
    return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL))();
  }
  else {
    return 1LL;
  }
}

uint64_t ___mdns_dns_service_enumerate_array_including_variants_and_discovered_alts_block_invoke( uint64_t a1, uint64_t a2)
{
  uint64_t result = (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL))();
  if ((_DWORD)result)
  {
    unint64_t v5 = *(const __CFArray **)(a2 + 128);
    if (!v5 || (uint64_t result = mdns_cfarray_enumerate(v5, *(void *)(a1 + 32)), (_DWORD)result))
    {
      char v6 = *(const __CFArray **)(a2 + 144);
      return !v6 || mdns_cfarray_enumerate(v6, *(void *)(a1 + 32));
    }
  }

  return result;
}

void *_mdns_dns_service_copy_description(uint64_t a1, int a2, int a3)
{
  uint64_t v66 = 0LL;
  CFStringRef v67 = &v66;
  uint64_t v68 = 0x2000000000LL;
  int v69 = 0;
  uint64_t v62 = 0LL;
  int v63 = &v62;
  uint64_t v64 = 0x2000000000LL;
  uint64_t v65 = 0LL;
  char v6 = (void *)mdns_string_builder_create();
  if (v6)
  {
    uint64_t v7 = v6;
    if (!a2
      || (int v8 = mdns_string_builder_append_formatted( v6,  "<%s: %p>: ",  *(const char **)(*(void *)(a1 + 16) + 8LL),  (const void *)a1),  (*((_DWORD *)v67 + 6) = v8) == 0))
    {
      int appended = mdns_string_builder_append_formatted(v7, "id: %llu", *(void *)(a1 + 24));
      *((_DWORD *)v67 + 6) = appended;
      if (!appended)
      {
        int v10 = mdns_string_builder_append_formatted(v7, ", type: ");
        *((_DWORD *)v67 + 6) = v10;
        if (!v10)
        {
          int v11 = *(unsigned __int8 *)(a1 + 281) > 5uLL
              ? mdns_string_builder_append_formatted(v7, "«INVALID %u»")
              : mdns_string_builder_append_formatted(v7, "%s");
          *((_DWORD *)v67 + 6) = v11;
          if (!v11)
          {
            int v13 = mdns_string_builder_append_formatted(v7, ", source: ");
            *((_DWORD *)v67 + 6) = v13;
            if (!v13)
            {
              int v14 = (*(char *)(a1 + 282) - 1) > 4
                  ? mdns_string_builder_append_formatted(v7, "«INVALID %u»")
                  : mdns_string_builder_append_formatted(v7, "%s");
              *((_DWORD *)v67 + 6) = v14;
              if (!v14)
              {
                int v15 = mdns_string_builder_append_formatted(v7, ", scope: ");
                *((_DWORD *)v67 + 6) = v15;
                if (!v15)
                {
                  switch(*(_BYTE *)(a1 + 280))
                  {
                    case 1:
                      int v16 = mdns_string_builder_append_formatted(v7, "none", v59);
                      goto LABEL_27;
                    case 2:
                      int v16 = mdns_string_builder_append_formatted(v7, "interface", v59);
                      goto LABEL_27;
                    case 3:
                      int v16 = mdns_string_builder_append_formatted(v7, "service (%u)");
                      goto LABEL_27;
                    case 4:
                      int v17 = mdns_string_builder_append_formatted(v7, "uuid");
                      *((_DWORD *)v67 + 6) = v17;
                      if (v17) {
                        goto LABEL_32;
                      }
                      if ((a3 & 1) != 0) {
                        goto LABEL_28;
                      }
                      *(void *)uu = 0LL;
                      uint64_t v73 = 0LL;
                      nw_resolver_config_get_identifier(*(void *)(a1 + 96), uu);
                      memset(out, 0, 37);
                      uuid_unparse(uu, out);
                      int v18 = mdns_string_builder_append_formatted(v7, " (%s)", out);
                      unsigned int v12 = 0LL;
                      *((_DWORD *)v67 + 6) = v18;
                      if (!v18) {
                        goto LABEL_28;
                      }
                      goto LABEL_33;
                    case 5:
                      int v16 = mdns_string_builder_append_formatted(v7, "none+interface");
                      goto LABEL_27;
                    default:
                      int v16 = mdns_string_builder_append_formatted(v7, "«INVALID %d»");
LABEL_27:
                      *((_DWORD *)v67 + 6) = v16;
                      if (v16) {
                        goto LABEL_32;
                      }
LABEL_28:
                      uint64_t v19 = *(const char **)(a1 + 104);
                      if (!v19) {
                        uint64_t v19 = "";
                      }
                      int v20 = mdns_string_builder_append_formatted(v7, ", interface: %s/%u", v19, *(_DWORD *)(a1 + 256));
                      *((_DWORD *)v67 + 6) = v20;
                      if (v20) {
                        goto LABEL_32;
                      }
                      int v21 = mdns_string_builder_append_formatted(v7, ", servers: {");
                      *((_DWORD *)v67 + 6) = v21;
                      if (v21) {
                        goto LABEL_32;
                      }
                      v63[3] = 0LL;
                      uint64_t v23 = *(const __CFArray **)(a1 + 80);
                      if (v23)
                      {
                        v60[0] = _NSConcreteStackBlock;
                        v60[1] = 0x40000000LL;
                        v60[2] = ___mdns_dns_service_copy_description_block_invoke;
                        v60[3] = &unk_10013AE70;
                        v60[4] = &v66;
                        v60[5] = &v62;
                        v60[6] = v7;
                        char v61 = a3;
                        mdns_cfarray_enumerate(v23, (uint64_t)v60);
                        if (*((_DWORD *)v67 + 6)) {
                          goto LABEL_32;
                        }
                      }

                      int v24 = mdns_string_builder_append_formatted(v7, "}");
                      *((_DWORD *)v67 + 6) = v24;
                      if (v24) {
                        goto LABEL_32;
                      }
                      int v25 = mdns_string_builder_append_formatted(v7, ", domains: {");
                      *((_DWORD *)v67 + 6) = v25;
                      if (v25) {
                        goto LABEL_32;
                      }
                      v63[3] = 0LL;
                      uint64_t v26 = *(void *)(a1 + 136);
                      if (!v26) {
                        uint64_t v26 = a1;
                      }
                      uint64_t v27 = *(void **)(v26 + 88);
                      if (!v27) {
                        goto LABEL_45;
                      }
                      uint64_t v28 = 0LL;
                      break;
                  }

                  while (1)
                  {
                    int v29 = mdns_string_builder_append_description_with_prefix(v7, v28, v27[1], a3);
                    *((_DWORD *)v67 + 6) = v29;
                    if (v29) {
                      break;
                    }
                    v63[3] = (uint64_t)", ";
                    uint64_t v27 = (void *)*v27;
                    uint64_t v28 = ", ";
                    if (!v27)
                    {
LABEL_45:
                      int v30 = mdns_string_builder_append_formatted(v7, "}");
                      *((_DWORD *)v67 + 6) = v30;
                      if (!v30)
                      {
                        int v31 = mdns_string_builder_append_formatted(v7, ", attributes: {");
                        *((_DWORD *)v67 + 6) = v31;
                        if (!v31)
                        {
                          uint64_t v32 = 0LL;
                          __int16 v33 = v63;
                          v63[3] = (uint64_t)"";
                          do
                          {
                            if (((uint64_t)(&off_10013AE90)[v32 + 1] & *(_WORD *)(a1 + 276)) != 0)
                            {
                              int v34 = mdns_string_builder_append_formatted( v7,  "%s%s",  (const char *)v33[3],  (&off_10013AE90)[v32]);
                              *((_DWORD *)v67 + 6) = v34;
                              if (v34) {
                                goto LABEL_32;
                              }
                              __int16 v33 = v63;
                              v63[3] = (uint64_t)", ";
                            }

                            v32 += 2LL;
                          }

                          while (v32 != 14);
                          uint64_t v35 = *(void *)(a1 + 96);
                          if (v35 && nw_resolver_config_get_allow_failover(v35))
                          {
                            int v36 = mdns_string_builder_append_formatted(v7, "%sallows-failover", (const char *)v63[3]);
                            *((_DWORD *)v67 + 6) = v36;
                            if (v36) {
                              break;
                            }
                            v63[3] = (uint64_t)", ";
                          }

                          if (!*(void *)(a1 + 240)
                            || !*(void *)(a1 + 248)
                            || (int v37 = mdns_string_builder_append_formatted( v7,  "%sreports-push-connection-error",  (const char *)v63[3]),  (*((_DWORD *)v67 + 6) = v37) == 0))
                          {
                            int v38 = mdns_string_builder_append_formatted(v7, "}");
                            *((_DWORD *)v67 + 6) = v38;
                            if (!v38)
                            {
                              int v39 = mdns_string_builder_append_formatted(v7, ", interface properties: {");
                              *((_DWORD *)v67 + 6) = v39;
                              if (!v39)
                              {
                                uint64_t v40 = 0LL;
                                uint64_t v41 = v63;
                                v63[3] = (uint64_t)"";
                                do
                                {
                                  if (((uint64_t)(&off_10013AF00)[v40 + 1] & *(_WORD *)(a1 + 276)) != 0)
                                  {
                                    int v42 = mdns_string_builder_append_formatted( v7,  "%s%s",  (const char *)v41[3],  (&off_10013AF00)[v40]);
                                    *((_DWORD *)v67 + 6) = v42;
                                    if (v42) {
                                      goto LABEL_32;
                                    }
                                    uint64_t v41 = v63;
                                    v63[3] = (uint64_t)", ";
                                  }

                                  v40 += 2LL;
                                }

                                while (v40 != 16);
                                int v43 = mdns_string_builder_append_formatted(v7, "}");
                                *((_DWORD *)v67 + 6) = v43;
                                if (!v43)
                                {
                                  if (!*(void *)(a1 + 96)) {
                                    goto LABEL_100;
                                  }
                                  int v44 = mdns_string_builder_append_formatted(v7, ", resolver config: {");
                                  *((_DWORD *)v67 + 6) = v44;
                                  if (!v44)
                                  {
                                    int v45 = mdns_string_builder_append_formatted(v7, "provider name: ");
                                    *((_DWORD *)v67 + 6) = v45;
                                    if (!v45)
                                    {
                                      provider_name_cstr = _mdns_dns_service_get_provider_name_cstr(a1);
                                      if (!provider_name_cstr) {
                                        goto LABEL_102;
                                      }
                                      uint64_t v47 = provider_name_cstr;
                                      __int128 v71 = 0u;
                                      memset(out, 0, sizeof(out));
                                      if (a3)
                                      {
                                        else {
                                          uint64_t v47 = out;
                                        }
                                      }

                                      int v48 = mdns_string_builder_append_formatted(v7, "%s", v47);
                                      *((_DWORD *)v67 + 6) = v48;
                                      if (!v48)
                                      {
LABEL_102:
                                        int v49 = mdns_string_builder_append_formatted(v7, ", provider path: ");
                                        *((_DWORD *)v67 + 6) = v49;
                                        if (!v49)
                                        {
                                          uint64_t v50 = *(void *)(a1 + 136);
                                          if (!v50 || !*(void *)(v50 + 96)) {
                                            uint64_t v50 = a1;
                                          }
                                          int v51 = *(const char **)(v50 + 168);
                                          if (!v51) {
                                            goto LABEL_101;
                                          }
                                          __int128 v71 = 0u;
                                          memset(out, 0, sizeof(out));
                                          if (a3)
                                          {
                                            else {
                                              int v51 = out;
                                            }
                                          }

                                          int v52 = mdns_string_builder_append_formatted(v7, "%s", v51);
                                          *((_DWORD *)v67 + 6) = v52;
                                          if (!v52)
                                          {
LABEL_101:
                                            int v53 = mdns_string_builder_append_formatted(v7, "}");
                                            *((_DWORD *)v67 + 6) = v53;
                                            if (!v53)
                                            {
LABEL_100:
                                              if (!*(void *)(a1 + 176)
                                                || (int v54 = mdns_string_builder_append_formatted( v7,  ", connection hostname: %s",  *(const char **)(a1 + 176)),  (*((_DWORD *)v67 + 6) = v54) == 0))
                                              {
                                                if (!*(_WORD *)(a1 + 278)
                                                  || (int v55 = mdns_string_builder_append_formatted( v7,  ", port: %d",  *(unsigned __int16 *)(a1 + 278)),  (*((_DWORD *)v67 + 6) = v55) == 0))
                                                {
                                                  uint64_t v56 = *(void *)(a1 + 216);
                                                  if (!v56
                                                    || (int v57 = mdns_string_builder_append_formatted( v7,  ", SRV name: %s",  *(const char **)(v56 + 40)),  (*((_DWORD *)v67 + 6) = v57) == 0))
                                                  {
                                                    int v58 = *(void *)(a1 + 136)
                                                        ? mdns_string_builder_append_formatted(v7, ", parent: %llu")
                                                        : mdns_string_builder_append_formatted(v7, ", use count: %d");
                                                    *((_DWORD *)v67 + 6) = v58;
                                                    if (!v58)
                                                    {
                                                      unsigned int v12 = mdns_string_builder_copy_string((uint64_t)v7);
                                                      goto LABEL_33;
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }

                      break;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

LABEL_32:
    unsigned int v12 = 0LL;
LABEL_33:
    os_release(v7);
  }

  else
  {
    unsigned int v12 = 0LL;
  }

  _Block_object_dispose(&v62, 8);
  _Block_object_dispose(&v66, 8);
  return v12;
}

    mDNS_snprintf(v35);
    return v80;
  }

  switch(*((_WORD *)a1 + 2))
  {
    case ')':
      goto LABEL_9;
    case '*':
    case ',':
    case '-':
      goto LABEL_116;
    case '+':
      uint64_t v83 = 0;
      int v15 = dnssec_obj_rr_ds_create( *((unsigned __int8 **)a1 + 4),  *((_WORD *)a1 + 3),  (const void *)(*((void *)a1 + 5) + 4LL),  v13,  0,  &v83);
      int v16 = v15;
      if (v83) {
        goto LABEL_109;
      }
      int v17 = dnssec_obj_rr_copy_rdata_rfc_description((uint64_t)v15, &v83);
      if (!v83) {
        goto LABEL_128;
      }
      goto LABEL_110;
    case '.':
      uint64_t v82 = 0;
      uint64_t v56 = dnssec_obj_rr_rrsig_create( *((unsigned __int8 **)a1 + 4),  (const void *)(*((void *)a1 + 5) + 4LL),  v13,  0,  &v82);
      int v16 = (void *)v56;
      if (v82) {
        goto LABEL_109;
      }
      int v17 = dnssec_obj_rr_copy_rdata_rfc_description(v56, &v82);
      if (!v82) {
        goto LABEL_128;
      }
      goto LABEL_110;
    case '/':
      int v57 = a2;
      break;
    case '0':
      uint64_t v81 = 0;
      __int16 v60 = dnssec_obj_rr_dnskey_create( *((unsigned __int8 **)a1 + 4),  *((_WORD *)a1 + 3),  (_BYTE *)(*((void *)a1 + 5) + 4LL),  v13,  &v81);
      int v16 = (void *)v60;
      if (v81)
      {
LABEL_109:
        int v17 = 0LL;
      }

      else
      {
        int v17 = dnssec_obj_rr_copy_rdata_rfc_description(v60, &v81);
        if (!v81) {
LABEL_128:
        }
          mDNS_snprintf(&v80[v12]);
      }

  int v63 = *(const void **)(a1 + 32);
  if (v63) {
    CFRelease(v63);
  }
  if (v16)
  {
    CFWriteStreamClose(v16);
    CFRelease(v16);
  }

  if (v22) {
    CFRelease(v22);
  }
  uint64_t v64 = *(void **)(a1 + 40);
  if (v64) {
    free(v64);
  }
  KQueueUnlock((uint64_t)"mDNSDynamicStoreSetConfig", v38, v39, v40, v41, v42, v43, v44);
}

            int v54 = DNSProxyClients;
            if (DNSProxyClients)
            {
              int v55 = *(unsigned __int16 *)a2;
              while (!mDNSSameAddress((int *)(v54 + 8), a4)
                   || *(unsigned __int16 *)(v54 + 28) != v11
                   || *(unsigned __int16 *)(v54 + 30) != v55
                   || *(unsigned __int16 *)(v54 + 992) != v98
                   || *(unsigned __int16 *)(v54 + 660) != v99
                   || !SameDomainNameBytes((_BYTE *)(v54 + 80), v100))
              {
                int v54 = *(void *)v54;
                if (!v54) {
                  goto LABEL_41;
                }
              }

              if ((mDNS_LoggingEnabled & 1) != 0)
              {
                LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "IsDuplicateClient: Found a duplicate client in the list",  v56,  v57,  v58,  v59,  v60,  v89);
                if (mDNS_LoggingEnabled == 1) {
                  LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "ProxyCallbackCommon: Found a duplicate for pkt from %#a:%d, ignoring this",  v84,  v85,  v86,  v87,  v88,  (int)a4);
                }
              }

              return;
            }

uint64_t _mdns_dns_service_equal(uint64_t a1, uint64_t a2)
{
  return _mdns_dns_service_equal_ex(a1, a2, 0);
}

void _mdns_dns_service_finalize(void *a1)
{
  if (a1[14])
  {
    uint64_t v2 = (void (*)(void))a1[15];
    if (v2) {
      v2();
    }
    a1[14] = 0LL;
  }

  uint64_t v3 = (const void *)a1[10];
  if (v3)
  {
    CFRelease(v3);
    a1[10] = 0LL;
  }

  while (1)
  {
    uint64_t v4 = (void *)a1[11];
    if (!v4) {
      break;
    }
    a1[11] = *v4;
    _domain_item_free(v4);
  }

  unint64_t v5 = (void *)a1[6];
  if (v5)
  {
    nw_release(v5);
    a1[6] = 0LL;
  }

  char v6 = (void *)a1[12];
  if (v6)
  {
    nw_release(v6);
    a1[12] = 0LL;
  }

  uint64_t v7 = (void *)a1[13];
  if (v7)
  {
    free(v7);
    a1[13] = 0LL;
  }

  int v8 = (const void *)a1[16];
  if (v8)
  {
    CFRelease(v8);
    a1[16] = 0LL;
  }

  int v9 = (void *)a1[17];
  if (v9)
  {
    os_release(v9);
    a1[17] = 0LL;
  }

  int v10 = (const void *)a1[18];
  if (v10)
  {
    CFRelease(v10);
    a1[18] = 0LL;
  }

  int v11 = (const void *)a1[19];
  if (v11)
  {
    CFRelease(v11);
    a1[19] = 0LL;
  }

  unsigned int v12 = (void *)a1[20];
  if (v12)
  {
    xpc_release(v12);
    a1[20] = 0LL;
  }

  int v13 = (void *)a1[21];
  if (v13)
  {
    free(v13);
    a1[21] = 0LL;
  }

  int v14 = (void *)a1[22];
  if (v14)
  {
    free(v14);
    a1[22] = 0LL;
  }

  int v15 = (const void *)a1[24];
  if (v15)
  {
    CFRelease(v15);
    a1[24] = 0LL;
  }

  int v16 = (void *)a1[26];
  if (v16)
  {
    nw_release(v16);
    a1[26] = 0LL;
  }

  int v17 = (void *)a1[27];
  if (v17)
  {
    os_release(v17);
    a1[27] = 0LL;
  }

  int v18 = (const void *)a1[29];
  if (v18)
  {
    CFRelease(v18);
    a1[29] = 0LL;
  }

void _domain_item_free(void *a1)
{
  uint64_t v2 = (void *)a1[1];
  if (v2) {
    os_release(v2);
  }
  free(a1);
}

uint64_t _mdns_dns_service_equal_ex(uint64_t a1, uint64_t a2, char a3)
{
  if (a1 == a2) {
    return 1LL;
  }
  int v5 = *(unsigned __int8 *)(a1 + 280);
  if (v5 != *(unsigned __int8 *)(a2 + 280)
    || *(_DWORD *)(a1 + 256) != *(_DWORD *)(a2 + 256)
    || v5 == 3 && *(_DWORD *)(a1 + 260) != *(_DWORD *)(a2 + 260))
  {
    return 0LL;
  }

  uint64_t v7 = *(const void **)(a1 + 80);
  int v8 = *(const void **)(a2 + 80);
  if (v7 == v8 || (uint64_t result = 0LL, v7) && v8 && (uint64_t result = CFEqual(*(CFTypeRef *)(a1 + 80), v8), (_DWORD)result))
  {
    if ((a3 & 1) != 0) {
      return 1LL;
    }
    uint64_t v10 = a1 + 88;
    uint64_t v11 = a2 + 88;
    while (1)
    {
      uint64_t v11 = *(void *)v11;
      uint64_t v10 = *(void *)v10;
      if (!v10 || v11 == 0) {
        break;
      }
      int v13 = _domain_item_compare(v10, v11, 0);
      uint64_t result = 0LL;
      if (v13) {
        return result;
      }
    }

    return !(v10 | v11);
  }

  return result;
}

uint64_t _domain_item_compare(uint64_t a1, uint64_t a2, char a3)
{
  uint64_t v3 = *(void *)(a1 + 8);
  int v4 = *(_DWORD *)(v3 + 48);
  uint64_t v5 = *(void *)(a2 + 8);
  int v6 = v4 - *(_DWORD *)(v5 + 48);
  if (v6)
  {
    if (v6 < 1) {
      return 1LL;
    }
    else {
      return 0xFFFFFFFFLL;
    }
  }

  else
  {
    if (v3 != v5 && v4 >= 1)
    {
      unsigned int v12 = *(_BYTE **)(v3 + 24);
      int v13 = *(_BYTE **)(v5 + 24);
      while (1)
      {
        int v14 = v4 - 1;
        if (v4 < 1) {
          return (a3 & 1) == 0 && *(_DWORD *)(a1 + 16) < *(_DWORD *)(a2 + 16);
        }
        int v15 = v12;
        int v16 = v13;
        if (v4 != 1)
        {
          int v17 = 1;
          int v15 = v12;
          do
          {
            if (!*v15) {
              break;
            }
            v15 += *v15 + 1;
            ++v17;
          }

          while (v4 != v17);
          int v18 = 1;
          int v16 = v13;
          do
          {
            if (!*v16) {
              break;
            }
            v16 += *v16 + 1;
            ++v18;
          }

          while (v4 != v18);
        }

        unsigned int v21 = *v15;
        uint64_t v19 = v15 + 1;
        unsigned int v20 = v21;
        unsigned int v24 = *v16;
        int v22 = v16 + 1;
        unsigned int v23 = v24;
        if (v20 >= v24) {
          uint64_t v25 = v23;
        }
        else {
          uint64_t v25 = v20;
        }
        int v26 = mdns_memcmp_us_ascii_case_insensitive(v19, v22, v25, v4);
        if (v26) {
          return (char)v26;
        }
        if (v20 < v23) {
          break;
        }
        int v4 = v14;
        if (v20 > v23)
        {
          LOBYTE(v26) = 1;
          return (char)v26;
        }
      }

      LOBYTE(v26) = -1;
      return (char)v26;
    }

    return (a3 & 1) == 0 && *(_DWORD *)(a1 + 16) < *(_DWORD *)(a2 + 16);
  }

BOOL ___mdns_dns_service_copy_description_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = mdns_string_builder_append_description_with_prefix( *(void **)(a1 + 48),  *(const char **)(*(void *)(*(void *)(a1 + 40) + 8LL)
                                                                                 + 24LL),
                                                                  a2,
                                                                  *(_BYTE *)(a1 + 56));
  *(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = ", ";
  return *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) == 0;
}

char *_mdns_dns_service_get_provider_name_cstr(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 136);
  if (!v1 || !*(void *)(v1 + 96)) {
    uint64_t v1 = a1;
  }
  uint64_t result = *(char **)(v1 + 160);
  if (result) {
    return (char *)xpc_string_get_string_ptr(result);
  }
  return result;
}

BOOL __mdns_dns_service_manager_create_block_invoke(id a1, __CFArray **a2)
{
  CFMutableArrayRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0LL, (const CFArrayCallBacks *)&mdns_cfarray_callbacks);
  *a2 = Mutable;
  return Mutable != 0LL;
}

void ___mdns_os_variant_has_internal_diagnostics_block_invoke(id a1)
{
  _mdns_os_variant_has_internal_diagnostics_s_uint64_t result = os_variant_has_internal_diagnostics("com.apple.mdns");
}

void __mdns_dns_service_manager_activate_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (!*(_BYTE *)(v1 + 131) && !*(void *)(v1 + 96))
  {
    dispatch_source_t v2 = dispatch_source_create( (dispatch_source_type_t)&_dispatch_source_type_data_or,  0LL,  0LL,  *(dispatch_queue_t *)(v1 + 88));
    *(void *)(v1 + 96) = v2;
    if (v2)
    {
      os_retain((void *)v1);
      uint64_t v3 = *(dispatch_source_s **)(v1 + 96);
      handler[0] = _NSConcreteStackBlock;
      handler[1] = 0x40000000LL;
      handler[2] = ___mdns_dns_service_manager_activate_internal_block_invoke;
      handler[3] = &__block_descriptor_tmp_5;
      handler[4] = v1;
      dispatch_source_set_event_handler(v3, handler);
      int v4 = *(dispatch_source_s **)(v1 + 96);
      v5[0] = _NSConcreteStackBlock;
      v5[1] = 0x40000000LL;
      v5[2] = ___mdns_dns_service_manager_activate_internal_block_invoke_2;
      v5[3] = &__block_descriptor_tmp_6;
      v5[4] = v1;
      dispatch_source_set_cancel_handler(v4, v5);
      dispatch_activate(*(dispatch_object_t *)(v1 + 96));
    }

    else
    {
      _mdns_dns_service_manager_terminate(v1, -6729);
    }
  }

uint64_t ___mdns_dns_service_manager_activate_internal_block_invoke(uint64_t a1)
{
  uint64_t result = *(void *)(*(void *)(a1 + 32) + 104LL);
  if (result) {
    return (*(uint64_t (**)(uint64_t, uint64_t, void))(result + 16))(result, 3LL, 0LL);
  }
  return result;
}

void ___mdns_dns_service_manager_activate_internal_block_invoke_2(uint64_t a1)
{
}

void _mdns_dns_service_manager_terminate(uint64_t a1, int a2)
{
  if (!*(_BYTE *)(a1 + 130))
  {
    *(_BYTE *)(a1 + 131) = 1;
    int v4 = *(dispatch_object_s **)(a1 + 96);
    if (v4)
    {
      dispatch_source_cancel(*(dispatch_source_t *)(a1 + 96));
      dispatch_release(v4);
      *(void *)(a1 + 96) = 0LL;
    }

    CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 80));
    if (Count >= 1)
    {
      CFIndex v6 = Count;
      for (CFIndex i = 0LL; i != v6; ++i)
      {
        ValueAtIndex = (void *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 80), i);
        mdns_interface_monitor_invalidate(ValueAtIndex);
      }
    }

    CFArrayRemoveAllValues(*(CFMutableArrayRef *)(a1 + 80));
    v13[0] = _NSConcreteStackBlock;
    v13[1] = 0x40000000LL;
    v13[2] = ___mdns_dns_service_manager_terminate_block_invoke;
    v13[3] = &__block_descriptor_tmp_110;
    v13[4] = a1;
    v14[0] = _NSConcreteStackBlock;
    v14[1] = 0x40000000LL;
    void v14[2] = ___mdns_dns_service_manager_enumerate_all_service_arrays_block_invoke;
    v14[3] = &unk_10013B1B0;
    v14[4] = v13;
    _mdns_dns_service_manager_enumerate_all_service_array_pointers(a1, (uint64_t)v14);
    int v9 = *(void **)(a1 + 112);
    if (v9)
    {
      mdns_system_remove_network_policy(v9);
      *(void *)(a1 + 112) = 0LL;
    }

    os_retain((void *)a1);
    uint64_t v10 = *(dispatch_queue_s **)(a1 + 88);
    v11[0] = _NSConcreteStackBlock;
    v11[1] = 0x40000000LL;
    _OWORD v11[2] = ___mdns_dns_service_manager_terminate_block_invoke_2;
    v11[3] = &__block_descriptor_tmp_111;
    _OWORD v11[4] = a1;
    int v12 = a2;
    dispatch_async(v10, v11);
  }

uint64_t ___mdns_dns_service_manager_terminate_block_invoke(uint64_t a1, const __CFArray *a2)
{
  uint64_t v3 = *(void *)(a1 + 32);
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000LL;
  v5[2] = ___mdns_dns_service_manager_terminate_services_block_invoke;
  v5[3] = &__block_descriptor_tmp_112;
  v5[4] = v3;
  mdns_cfarray_enumerate(a2, (uint64_t)v5);
  CFArrayRemoveAllValues(a2);
  return 1LL;
}

void ___mdns_dns_service_manager_terminate_block_invoke_2(uint64_t a1)
{
  dispatch_source_t v2 = *(void **)(a1 + 32);
  uint64_t v3 = v2[13];
  if (v3)
  {
    if (*(_DWORD *)(a1 + 40)) {
      uint64_t v4 = 1LL;
    }
    else {
      uint64_t v4 = 2LL;
    }
    (*(void (**)(void, uint64_t))(v3 + 16))(v2[13], v4);
    dispatch_source_t v2 = *(void **)(a1 + 32);
  }

  os_release(v2);
}

uint64_t ___mdns_dns_service_manager_terminate_services_block_invoke(uint64_t a1, uint64_t a2)
{
  return 1LL;
}

void _mdns_dns_service_manager_terminate_service(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 96);
  if (v4 && *(_BYTE *)(a2 + 284))
  {
    *(_BYTE *)(a2 + 284) = 0;
    _mdns_dns_service_manager_cancel_resolver_config_updates(a1, v4);
  }

  v11[0] = _NSConcreteStackBlock;
  v11[1] = 0x40000000LL;
  _OWORD v11[2] = ___mdns_dns_service_manager_terminate_service_block_invoke;
  v11[3] = &__block_descriptor_tmp_122;
  _OWORD v11[4] = a1;
  uint64_t v5 = *(const __CFArray **)(a2 + 128);
  if (v5)
  {
    mdns_cfarray_enumerate(v5, (uint64_t)v11);
    CFIndex v6 = *(const void **)(a2 + 128);
    if (v6)
    {
      CFRelease(v6);
      *(void *)(a2 + 12_Block_object_dispose(va, 8) = 0LL;
    }
  }

  uint64_t v7 = *(const __CFArray **)(a2 + 144);
  if (v7)
  {
    mdns_cfarray_enumerate(v7, (uint64_t)v11);
    int v8 = *(const void **)(a2 + 144);
    if (v8)
    {
      CFRelease(v8);
      *(void *)(a2 + 144) = 0LL;
    }
  }

  int v9 = *(const __CFArray **)(a2 + 152);
  if (v9)
  {
    mdns_cfarray_enumerate(v9, (uint64_t)v11);
    uint64_t v10 = *(const void **)(a2 + 152);
    if (v10)
    {
      CFRelease(v10);
      *(void *)(a2 + 152) = 0LL;
    }
  }

void _mdns_dns_service_clear_use_count(uint64_t a1)
{
  dispatch_source_t v2 = *(dispatch_object_s **)(a1 + 224);
  if (v2)
  {
    dispatch_source_cancel(*(dispatch_source_t *)(a1 + 224));
    dispatch_release(v2);
    *(void *)(a1 + 2memset(&v5[1], 0, 24) = 0LL;
  }

  *(_DWORD *)(a1 + 264) = 0;
}

void _mdns_dns_service_make_defunct(uint64_t a1)
{
  *(_WORD *)(a1 + 276) |= 1u;
  dispatch_source_t v2 = *(dispatch_object_s **)(a1 + 200);
  if (v2)
  {
    dispatch_source_cancel(*(dispatch_source_t *)(a1 + 200));
    dispatch_release(v2);
    *(void *)(a1 + 200) = 0LL;
  }

  _mdns_dns_service_forget_all_ddr_queriers(a1);
  uint64_t v3 = *(void *)(a1 + 208);
  if (v3)
  {
    nw_array_apply(v3, &__block_literal_global_128);
    uint64_t v4 = *(void **)(a1 + 208);
    if (v4)
    {
      nw_release(v4);
      *(void *)(a1 + 20_Block_object_dispose(va, 8) = 0LL;
    }
  }

  uint64_t v5 = *(void **)(a1 + 64);
  if (v5)
  {
    mdns_resolver_invalidate(v5);
    os_release(*(void **)(a1 + 64));
    *(void *)(a1 + 64) = 0LL;
  }

  CFIndex v6 = *(_BYTE **)(a1 + 72);
  if (v6)
  {
    mdns_push_server_invalidate(v6);
    os_release(*(void **)(a1 + 72));
    *(void *)(a1 + 72) = 0LL;
  }

  uint64_t v7 = *(dispatch_object_s **)(a1 + 240);
  if (v7)
  {
    dispatch_release(v7);
    *(void *)(a1 + 240) = 0LL;
  }

  int v8 = *(const void **)(a1 + 248);
  if (v8)
  {
    _Block_release(v8);
    *(void *)(a1 + 24_Block_object_dispose(va, 8) = 0LL;
  }

uint64_t _mdns_dns_service_manager_cancel_resolver_config_updates(uint64_t a1, uint64_t a2)
{
  if (_mdns_dns_service_queue_s_once != -1) {
    dispatch_once(&_mdns_dns_service_queue_s_once, &__block_literal_global_237);
  }
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000LL;
  v5[2] = ___mdns_dns_service_manager_cancel_resolver_config_updates_block_invoke;
  v5[3] = &__block_descriptor_tmp_77;
  v5[4] = a1;
  void v5[5] = a2;
  return nw_resolver_config_cancel_updates(a2, _mdns_dns_service_queue_s_queue, v5);
}

uint64_t ___mdns_dns_service_manager_terminate_service_block_invoke(uint64_t a1)
{
  return 1LL;
}

void ___mdns_dns_service_manager_cancel_resolver_config_updates_block_invoke(uint64_t a1)
{
}

void _mdns_dns_service_forget_all_ddr_queriers(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 184);
  if (v2)
  {
    mdns_client_invalidate(v2);
    os_release(*(void **)(a1 + 184));
    *(void *)(a1 + 184) = 0LL;
  }

  uint64_t v3 = *(const __CFArray **)(a1 + 192);
  if (v3)
  {
    mdns_cfarray_enumerate(v3, (uint64_t)&__block_literal_global_125);
    CFArrayRemoveAllValues(*(CFMutableArrayRef *)(a1 + 192));
  }

BOOL ___mdns_dns_service_forget_all_ddr_connections_block_invoke( id a1, unint64_t a2, const nw_object *a3)
{
  return 1;
}

BOOL ___mdns_dns_service_forget_all_ddr_queriers_block_invoke(id a1, const mdns_querier_s *a2)
{
  return 1;
}

void ___mdns_dns_service_queue_block_invoke(id a1)
{
  _mdns_dns_service_queue_s_queue = (uint64_t)dispatch_queue_create("com.apple.mdns.dns-service-queue", 0LL);
}

void __mdns_dns_service_manager_register_native_service_block_invoke(void *a1)
{
  uint64_t v2 = a1[6];
  if (*(_BYTE *)(v2 + 131))
  {
    *(void *)(*(void *)(a1[4] + 8LL) + 24LL) = 0LL;
    *(_DWORD *)(*(void *)(a1[5] + 8LL) + 24LL) = -6752;
    return;
  }

  uint64_t v3 = *(__CFArray **)(v2 + 24);
  uint64_t v4 = a1[7];
  uint64_t v5 = *(void *)(a1[5] + 8LL);
  uint64_t v22 = 0LL;
  unsigned int v23 = &v22;
  uint64_t v24 = 0x2000000000LL;
  int v25 = 0;
  unsigned int v6 = *(_DWORD *)(v4 + 48);
  unsigned int v7 = *(unsigned __int8 *)(v4 + 52);
  if (*(_BYTE *)(v4 + 52)) {
    BOOL v8 = v6 == 0;
  }
  else {
    BOOL v8 = 0;
  }
  if (v8 || v7 > 2)
  {
    uint64_t v10 = 0LL;
    int v11 = -6705;
LABEL_25:
    *((_DWORD *)v23 + 6) = v11;
    goto LABEL_26;
  }

  uint64_t v12 = _mdns_dns_service_create(1, 1, (0x50201u >> (8 * v7)) & 7, &v25);
  uint64_t v10 = v12;
  if (v12)
  {
    *(void *)&__int128 buf = _NSConcreteStackBlock;
    *((void *)&buf + 1) = 0x40000000LL;
    uint64_t v27 = ___mdns_dns_service_create_native_source_service_from_definition_block_invoke;
    uint64_t v28 = &unk_10013A660;
    int v29 = &v22;
    uint64_t v30 = v12;
    mdns_cfarray_enumerate(*(const __CFArray **)(v4 + 24), (uint64_t)&buf);
    int v13 = *((_DWORD *)v23 + 6);
    if (v13) {
      goto LABEL_40;
    }
    v21[0] = _NSConcreteStackBlock;
    v21[1] = 0x40000000LL;
    v21[2] = ___mdns_dns_service_create_native_source_service_from_definition_block_invoke_2;
    v21[3] = &unk_10013A688;
    v21[4] = &v22;
    v21[5] = v10;
    mdns_cfset_enumerate(*(const __CFSet **)(v4 + 32), (uint64_t)v21);
    int v13 = *((_DWORD *)v23 + 6);
    if (v13)
    {
LABEL_40:
      os_release((void *)v10);
      _Block_object_dispose(&v22, 8);
      uint64_t v18 = 0LL;
      *(_DWORD *)(v5 + memset(&v5[1], 0, 24) = v13;
      goto LABEL_35;
    }

    *(_DWORD *)(v10 + 256) = v6;
    if (v6) {
      *(void *)(v10 + 104) = mdns_system_interface_index_to_name(v6);
    }
    *(_WORD *)(v10 + 276) = 6;
    int v14 = *(unsigned __int8 *)(v4 + 53);
    if (*(_BYTE *)(v4 + 53)) {
      __int16 v15 = 8198;
    }
    else {
      __int16 v15 = 6;
    }
    *(_WORD *)(v10 + 276) = v15;
    if (*(_BYTE *)(v4 + 54))
    {
      int v11 = 0;
      if (v14) {
        __int16 v16 = 24582;
      }
      else {
        __int16 v16 = 16390;
      }
      *(_WORD *)(v10 + 276) = v16;
    }

    else
    {
      int v11 = 0;
    }

    goto LABEL_25;
  }

  int v11 = *((_DWORD *)v23 + 6);
LABEL_26:
  _Block_object_dispose(&v22, 8);
  if (!v11)
  {
    _mdns_dns_service_increment_use_count(v10);
    CFArrayAppendValue(v3, (const void *)v10);
    _mdns_dns_service_manager_update_interface_properties_for_service((CFArrayRef *)v2, v10);
    if (_mdns_dns_service_log_s_once != -1) {
      dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_62);
    }
    uint64_t v19 = (os_log_s *)_mdns_dns_service_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(buf) = 138412290;
      *(void *)((char *)&buf + 4) = v10;
      _os_log_impl( (void *)&_mh_execute_header,  v19,  OS_LOG_TYPE_DEFAULT,  "Registered native service -- %@",  (uint8_t *)&buf,  0xCu);
    }

    uint64_t v17 = *(void *)(v10 + 24);
    *(_DWORD *)(v5 + memset(&v5[1], 0, 24) = 0;
    goto LABEL_34;
  }

  uint64_t v17 = 0LL;
  uint64_t v18 = 0LL;
  *(_DWORD *)(v5 + memset(&v5[1], 0, 24) = v11;
  if (v10)
  {
LABEL_34:
    os_release((void *)v10);
    uint64_t v18 = v17;
  }

uint64_t _mdns_dns_service_create(char a1, char a2, char a3, int *a4)
{
  uint64_t v8 = _os_object_alloc(&OBJC_CLASS___OS_mdns_dns_service, 288LL);
  uint64_t v9 = v8;
  if (!v8)
  {
    int v13 = -6728;
    if (!a4) {
      return v9;
    }
    goto LABEL_8;
  }

  uint64_t v10 = &_mdns_dns_service_kind;
  *(void *)(v8 + 16) = &_mdns_dns_service_kind;
  do
  {
    int v11 = (void (*)(uint64_t))v10[2];
    if (v11) {
      v11(v9);
    }
    uint64_t v10 = (_UNKNOWN **)*v10;
  }

  while (v10);
  do
    unint64_t v12 = __ldxr(&_mdns_get_next_dns_service_id_s_next_id);
  while (__stxr(v12 + 1, &_mdns_get_next_dns_service_id_s_next_id));
  int v13 = 0;
  *(void *)(v9 + memset(&v5[1], 0, 24) = v12;
  *(_BYTE *)(v9 + 281) = a1;
  *(_BYTE *)(v9 + 282) = a2;
  *(_BYTE *)(v9 + 280) = a3;
  if (a4) {
LABEL_8:
  }
    *a4 = v13;
  return v9;
}

BOOL ___mdns_dns_service_create_native_source_service_from_definition_block_invoke(uint64_t a1, void *a2)
{
  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = _mdns_dns_service_append_address( *(void *)(a1 + 40),  a2);
  return *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) == 0;
}

BOOL ___mdns_dns_service_create_native_source_service_from_definition_block_invoke_2(uint64_t a1, void *a2)
{
  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 0;
  return *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) == 0;
}

uint64_t _mdns_dns_service_increment_use_count(uint64_t a1)
{
  int v2 = *(_DWORD *)(a1 + 264);
  uint64_t v3 = *(dispatch_source_s **)(a1 + 224);
  if (v2 == 1)
  {
    if (!v3)
    {
      int v2 = 1;
      goto LABEL_7;
    }

    *(_DWORD *)(a1 + 264) = 0;
    goto LABEL_5;
  }

  if (v3)
  {
LABEL_5:
    dispatch_source_cancel(v3);
    dispatch_release(v3);
    *(void *)(a1 + 2memset(&v5[1], 0, 24) = 0LL;
    int v2 = *(_DWORD *)(a1 + 264);
  }

void _mdns_dns_service_manager_update_interface_properties_for_service(CFArrayRef *a1, uint64_t a2)
{
  unsigned int v4 = *(_DWORD *)(a2 + 256);
  CFIndex Count = CFArrayGetCount(a1[10]);
  if (Count >= 1)
  {
    CFIndex v6 = Count;
    CFIndex v7 = 0LL;
    while (1)
    {
      ValueAtIndex = CFArrayGetValueAtIndex(a1[10], v7);
      if (ValueAtIndex[34] == v4) {
        break;
      }
      if (v6 == ++v7) {
        goto LABEL_5;
      }
    }

    uint64_t v10 = (uint64_t)ValueAtIndex;
    goto LABEL_14;
  }

void ___mdns_dns_service_log_block_invoke(id a1)
{
  _mdns_dns_service_log_s_log = (uint64_t)os_log_create("com.apple.mdns", "dns_service");
}

void ___mdns_dns_service_manager_get_interface_monitor_block_invoke(uint64_t a1, char a2)
{
  if (a2)
  {
    uint64_t v4 = *(void *)(a1 + 32);
    uint64_t v3 = *(_DWORD **)(a1 + 40);
    v18.size_t length = CFArrayGetCount(*(CFArrayRef *)(v4 + 80));
    v18.location = 0LL;
    if (CFArrayContainsValue(*(CFArrayRef *)(v4 + 80), v18, v3))
    {
      if (a2 < 0)
      {
        int v5 = v3[34];
        if (_mdns_dns_service_log_s_once != -1) {
          dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_62);
        }
        CFIndex v6 = (os_log_s *)_mdns_dns_service_log_s_log;
        if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_INFO))
        {
          *(_DWORD *)__int128 buf = 67109120;
          *(_DWORD *)&uint8_t buf[4] = v5;
          _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_INFO,  "Network change event for interface index %u",  buf,  8u);
        }

        v11[0] = _NSConcreteStackBlock;
        v11[1] = 0x40000000LL;
        _OWORD v11[2] = ___mdns_dns_service_manager_handle_network_change_event_block_invoke;
        v11[3] = &__block_descriptor_tmp_58;
        int v12 = v5;
        CFIndex v7 = *(const __CFArray **)(v4 + 40);
        *(void *)__int128 buf = _NSConcreteStackBlock;
        uint64_t v14 = 0x40000000LL;
        __int16 v15 = ___mdns_dns_service_manager_enumerate_service_array_including_variants_block_invoke;
        int v16 = &unk_10013A730;
        uint64_t v17 = v11;
        mdns_cfarray_enumerate(v7, (uint64_t)buf);
        uint64_t v8 = *(const __CFArray **)(v4 + 56);
        *(void *)__int128 buf = _NSConcreteStackBlock;
        uint64_t v14 = 0x40000000LL;
        __int16 v15 = ___mdns_dns_service_manager_enumerate_service_array_including_variants_block_invoke;
        int v16 = &unk_10013A730;
        uint64_t v17 = v11;
        mdns_cfarray_enumerate(v8, (uint64_t)buf);
        uint64_t v9 = *(const __CFArray **)(v4 + 48);
        *(void *)__int128 buf = _NSConcreteStackBlock;
        uint64_t v14 = 0x40000000LL;
        __int16 v15 = ___mdns_dns_service_manager_handle_network_change_event_block_invoke_2;
        int v16 = &__block_descriptor_tmp_59;
        LODWORD(v17) = v5;
        mdns_cfarray_enumerate(v9, (uint64_t)buf);
      }

      uint64_t v10 = *(dispatch_source_s **)(v4 + 96);
      if (v10) {
        dispatch_source_merge_data(v10, 1uLL);
      }
    }
  }

void ___mdns_dns_service_manager_get_interface_monitor_block_invoke_2(uint64_t a1, int a2)
{
  if (a2 == 1)
  {
    v4.size_t length = CFArrayGetCount(*(CFArrayRef *)(*(void *)(a1 + 40) + 80LL));
    v4.location = 0LL;
    CFIndex FirstIndexOfValue = CFArrayGetFirstIndexOfValue( *(CFArrayRef *)(*(void *)(a1 + 40) + 80LL),  v4,  *(const void **)(a1 + 32));
    if ((FirstIndexOfValue & 0x8000000000000000LL) == 0) {
      CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(*(void *)(a1 + 40) + 80LL), FirstIndexOfValue);
    }
    mdns_interface_monitor_invalidate(*(void **)(a1 + 32));
  }

  else if (a2 == 2)
  {
    os_release(*(void **)(a1 + 32));
    os_release(*(void **)(a1 + 40));
  }

uint64_t ___mdns_dns_service_manager_handle_network_change_event_block_invoke(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 256) == *(_DWORD *)(a1 + 32)) {
    *(_BYTE *)(a2 + 286) = 1;
  }
  return 1LL;
}

uint64_t ___mdns_dns_service_manager_enumerate_service_array_including_variants_block_invoke( uint64_t a1, uint64_t a2)
{
  uint64_t result = (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL))();
  if ((_DWORD)result)
  {
    int v5 = *(const __CFArray **)(a2 + 128);
    return !v5 || mdns_cfarray_enumerate(v5, *(void *)(a1 + 32));
  }

  return result;
}

uint64_t ___mdns_dns_service_manager_handle_network_change_event_block_invoke_2(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 256) == *(_DWORD *)(a1 + 32)) {
    *(_DWORD *)(a2 + 264) = 0;
  }
  return 1LL;
}

void _mdns_dns_service_add_domain(uint64_t a1, void *a2, unsigned int a3)
{
  CFIndex v6 = calloc(1uLL, 0x18uLL);
  if (v6)
  {
    uint64_t v7 = (uint64_t)v6;
    v6[1] = a2;
    os_retain(a2);
    *(_DWORD *)(v7 + 16) = a3;
    uint64_t v8 = a1 + 88;
    do
    {
      uint64_t v9 = (void *)v8;
      uint64_t v8 = *(void *)v8;
      if (!v8) {
        goto LABEL_6;
      }
      int v10 = _domain_item_compare(v7, v8, 1);
    }

    while (v10 > 0);
    if (v10)
    {
LABEL_6:
      *(void *)uint64_t v7 = v8;
      *uint64_t v9 = v7;
      return;
    }

    if (*(_DWORD *)(v8 + 16) > a3) {
      *(_DWORD *)(v8 + 16) = a3;
    }
    _domain_item_free((void *)v7);
  }

  else
  {
    __break(1u);
  }

uint64_t _mdns_dns_service_append_address(uint64_t a1, void *value)
{
  CFMutableArrayRef Mutable = *(__CFArray **)(a1 + 80);
  if (!Mutable)
  {
    CFMutableArrayRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0LL, (const CFArrayCallBacks *)&mdns_cfarray_callbacks);
    *(void *)(a1 + 80) = Mutable;
    if (!Mutable) {
      return 4294960567LL;
    }
  }

  CFArrayAppendValue(Mutable, value);
  return 0LL;
}

void mdns_dns_service_manager_deregister_native_service(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    if (_mdns_dns_service_queue_s_once != -1) {
      dispatch_once(&_mdns_dns_service_queue_s_once, &__block_literal_global_237);
    }
    v4[0] = _NSConcreteStackBlock;
    v4[1] = 0x40000000LL;
    v4[2] = __mdns_dns_service_manager_deregister_native_service_block_invoke;
    v4[3] = &__block_descriptor_tmp_8_787;
    v4[4] = a1;
    void v4[5] = a2;
    dispatch_sync((dispatch_queue_t)_mdns_dns_service_queue_s_queue, v4);
  }

void __mdns_dns_service_manager_deregister_native_service_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (!*(_BYTE *)(v1 + 131))
  {
    uint64_t service_by_id = _mdns_dns_service_manager_get_service_by_id(*(const __CFArray **)(v1 + 24), *(void *)(a1 + 40));
    if (service_by_id) {
      _mdns_dns_service_manager_deregister_service(v1, service_by_id);
    }
  }

uint64_t _mdns_dns_service_manager_get_service_by_id(const __CFArray *a1, uint64_t a2)
{
  uint64_t v5 = 0LL;
  CFIndex v6 = &v5;
  uint64_t v7 = 0x2000000000LL;
  uint64_t v8 = 0LL;
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000LL;
  v4[2] = ___mdns_dns_service_manager_get_service_by_id_block_invoke;
  v4[3] = &unk_10013AB80;
  v4[4] = &v5;
  void v4[5] = a2;
  mdns_cfarray_enumerate(a1, (uint64_t)v4);
  uint64_t v2 = v6[3];
  _Block_object_dispose(&v5, 8);
  return v2;
}

void _mdns_dns_service_manager_deregister_service(uint64_t a1, uint64_t a2)
{
  int v2 = *(_DWORD *)(a2 + 264) - 1;
  *(_DWORD *)(a2 + 264) = v2;
  if (!v2)
  {
    unsigned int v5 = *(_DWORD *)(a2 + 272);
    if (!v5) {
      goto LABEL_13;
    }
    if (_mdns_dns_service_queue_s_once != -1) {
      dispatch_once(&_mdns_dns_service_queue_s_once, &__block_literal_global_237);
    }
    monotonic_timer = _mdns_dispatch_create_monotonic_timer( v5,  0xFFFFFFFFFFFFFFFFLL,  5u,  (dispatch_queue_s *)_mdns_dns_service_queue_s_queue);
    *(void *)(a2 + 2memset(&v5[1], 0, 24) = monotonic_timer;
    int v7 = *(_DWORD *)(a2 + 264);
    if (monotonic_timer)
    {
      *(_DWORD *)(a2 + 264) = v7 + 1;
      v14[0] = _NSConcreteStackBlock;
      v14[1] = 0x40000000LL;
      void v14[2] = ___mdns_dns_service_decrement_use_count_block_invoke;
      v14[3] = &__block_descriptor_tmp_72;
      v14[4] = a2;
      void v14[5] = a1;
      dispatch_source_set_event_handler(monotonic_timer, v14);
      if (_mdns_dns_service_log_s_once != -1) {
        dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_62);
      }
      uint64_t v8 = (os_log_s *)_mdns_dns_service_log_s_log;
      if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_INFO))
      {
        uint64_t v9 = *(void *)(a2 + 24);
        int v10 = *(_DWORD *)(a2 + 272);
        *(_DWORD *)__int128 buf = 134218240;
        uint64_t v16 = v9;
        __int16 v17 = 1024;
        int v18 = v10;
        _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_INFO,  "Keeping orphaned DNS service %llu for up to %u milliseconds",  buf,  0x12u);
      }

      dispatch_activate(*(dispatch_object_t *)(a2 + 224));
      int v7 = *(_DWORD *)(a2 + 264);
    }

    if (!v7)
    {
LABEL_13:
      if (_mdns_dns_service_log_s_once != -1) {
        dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_62);
      }
      __int16 v11 = (os_log_s *)_mdns_dns_service_log_s_log;
      if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_INFO))
      {
        uint64_t v12 = *(void *)(a2 + 24);
        *(_DWORD *)__int128 buf = 134217984;
        uint64_t v16 = v12;
        _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_INFO,  "Deregistered DNS service -- service id: %llu",  buf,  0xCu);
      }

      __int16 v13 = *(dispatch_source_s **)(a1 + 96);
      if (v13) {
        dispatch_source_merge_data(v13, 1uLL);
      }
    }
  }

void ___mdns_dns_service_decrement_use_count_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (*(void *)(v2 + 224))
  {
    _mdns_dns_service_clear_use_count(v2);
    if (_mdns_dns_service_log_s_once != -1) {
      dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_62);
    }
    uint64_t v3 = (os_log_s *)_mdns_dns_service_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_INFO))
    {
      uint64_t v4 = *(void *)(*(void *)(a1 + 32) + 24LL);
      int v6 = 134217984;
      uint64_t v7 = v4;
      _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_INFO,  "Deregistered orphaned DNS service due to timeout -- service id: %llu",  (uint8_t *)&v6,  0xCu);
    }

    unsigned int v5 = *(dispatch_source_s **)(*(void *)(a1 + 40) + 96LL);
    if (v5) {
      dispatch_source_merge_data(v5, 1uLL);
    }
  }

BOOL ___mdns_dns_service_manager_get_service_by_id_block_invoke(uint64_t a1, uint64_t a2)
{
  if (*(void *)(a2 + 24) == *(void *)(a1 + 40)) {
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = a2;
  }
  return *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) == 0LL;
}

void mdns_dns_service_manager_deregister_discovered_push_service(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    if (_mdns_dns_service_queue_s_once != -1) {
      dispatch_once(&_mdns_dns_service_queue_s_once, &__block_literal_global_237);
    }
    v4[0] = _NSConcreteStackBlock;
    v4[1] = 0x40000000LL;
    v4[2] = __mdns_dns_service_manager_deregister_discovered_push_service_block_invoke;
    v4[3] = &__block_descriptor_tmp_9;
    v4[4] = a1;
    void v4[5] = a2;
    dispatch_sync((dispatch_queue_t)_mdns_dns_service_queue_s_queue, v4);
  }

void __mdns_dns_service_manager_deregister_discovered_push_service_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (!*(_BYTE *)(v1 + 131))
  {
    uint64_t service_by_id = _mdns_dns_service_manager_get_service_by_id(*(const __CFArray **)(v1 + 64), *(void *)(a1 + 40));
    if (service_by_id) {
      _mdns_dns_service_manager_deregister_service(v1, service_by_id);
    }
  }

void __mdns_dns_service_manager_register_custom_push_service_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 56);
  if (*(_BYTE *)(v2 + 131))
  {
    *(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = 0LL;
    *(_DWORD *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL) = -6752;
  }

  else
  {
    *(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = _mdns_dns_service_manager_register_push_service_internal_from_definition( (CFArrayRef *)v2,  *(__CFArray **)(v2 + 72),  *(void *)(a1 + 64),  *(_DWORD *)(a1 + 80),  *(dispatch_object_s **)(a1 + 72),  *(const void **)(a1 + 32),  (int *)(*(void *)(*(void *)(a1 + 48) + 8LL)
                                                                          + 24LL));
    if (*(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL))
    {
      uint64_t v3 = *(dispatch_source_s **)(*(void *)(a1 + 56) + 96LL);
      if (v3) {
        dispatch_source_merge_data(v3, 1uLL);
      }
    }
  }

uint64_t _mdns_dns_service_manager_register_push_service_internal_from_definition( CFArrayRef *a1, __CFArray *a2, uint64_t a3, int a4, dispatch_object_s *a5, const void *a6, int *a7)
{
  uint64_t v34 = 0LL;
  uint64_t v35 = &v34;
  uint64_t v36 = 0x2000000000LL;
  int v37 = 0;
  unsigned int v13 = *(_DWORD *)(a3 + 72);
  unsigned int v14 = *(unsigned __int8 *)(a3 + 78);
  if (*(_BYTE *)(a3 + 78)) {
    BOOL v15 = v13 == 0;
  }
  else {
    BOOL v15 = 0;
  }
  if (v15 || v14 > 2)
  {
    uint64_t v17 = 0LL;
    uint64_t v18 = 0LL;
    int v19 = -6705;
    goto LABEL_10;
  }

  uint64_t v22 = _mdns_dns_service_create(5, 1, (0x50201u >> (8 * v14)) & 7, &v37);
  uint64_t v18 = v22;
  int v19 = *((_DWORD *)v35 + 6);
  if (!v19)
  {
    *(_DWORD *)(v22 + 256) = v13;
    if (v13) {
      *(void *)(v22 + 104) = mdns_system_interface_index_to_name(v13);
    }
    *(_WORD *)(v18 + 276) = 6;
    int v23 = *(unsigned __int8 *)(a3 + 79);
    if (*(_BYTE *)(a3 + 79)) {
      __int16 v24 = 8198;
    }
    else {
      __int16 v24 = 6;
    }
    *(_WORD *)(v18 + 276) = v24;
    if (*(_BYTE *)(a3 + 80))
    {
      if (v23) {
        __int16 v25 = 24582;
      }
      else {
        __int16 v25 = 16390;
      }
      *(_WORD *)(v18 + 276) = v25;
    }

    *(void *)&__int128 buf = _NSConcreteStackBlock;
    *((void *)&buf + 1) = 0x40000000LL;
    int v39 = ___mdns_dns_service_create_push_service_from_definition_block_invoke;
    uint64_t v40 = &unk_10013ADF8;
    uint64_t v41 = &v34;
    uint64_t v42 = v18;
    mdns_cfset_enumerate(*(const __CFSet **)(a3 + 48), (uint64_t)&buf);
    int v19 = *((_DWORD *)v35 + 6);
    if (v19) {
      goto LABEL_26;
    }
    uint64_t v29 = *(void *)(a3 + 24);
    if (v29)
    {
      os_retain(*(void **)(a3 + 24));
      uint64_t v30 = *(void **)(v18 + 216);
      if (v30) {
        os_release(v30);
      }
      *(void *)(v18 + 216) = v29;
    }

    else
    {
      if (CFArrayGetCount(*(CFArrayRef *)(a3 + 40)) < 1 || !CFArrayGetValueAtIndex(*(CFArrayRef *)(a3 + 40), 0LL))
      {
        int v19 = -6705;
        goto LABEL_56;
      }

      v33[0] = _NSConcreteStackBlock;
      v33[1] = 0x40000000LL;
      v33[2] = ___mdns_dns_service_create_push_service_from_definition_block_invoke_2;
      v33[3] = &unk_10013AE20;
      _OWORD v33[4] = &v34;
      v33[5] = v18;
      mdns_cfarray_enumerate(*(const __CFArray **)(a3 + 40), (uint64_t)v33);
      int v19 = *((_DWORD *)v35 + 6);
      if (v19)
      {
LABEL_26:
        uint64_t v20 = 0LL;
        goto LABEL_27;
      }
    }

    int v31 = *(const __CFArray **)(a3 + 56);
    if (!v31 || (CFArrayRef Copy = CFArrayCreateCopy(kCFAllocatorDefault, v31), (*(void *)(v18 + 232) = Copy) != 0LL))
    {
      int v19 = 0;
      uint64_t v17 = 0LL;
      goto LABEL_10;
    }

    int v19 = -6729;
LABEL_56:
    uint64_t v17 = v18;
    uint64_t v18 = 0LL;
LABEL_10:
    uint64_t v20 = v18;
    *((_DWORD *)v35 + 6) = v19;
    uint64_t v18 = v17;
    if (!v17) {
      goto LABEL_28;
    }
LABEL_27:
    os_release((void *)v18);
    goto LABEL_28;
  }

  uint64_t v20 = 0LL;
  if (v22) {
    goto LABEL_27;
  }
LABEL_28:
  _Block_object_dispose(&v34, 8);
  if (v19)
  {
    uint64_t v26 = 0LL;
    if (!a7) {
      goto LABEL_31;
    }
    goto LABEL_30;
  }

  *(_DWORD *)(v20 + 272) = a4;
  if (a5 && a6)
  {
    *(void *)(v20 + 240) = a5;
    dispatch_retain(a5);
    *(void *)(v20 + 24_Block_object_dispose(va, 8) = _Block_copy(a6);
  }

  _mdns_dns_service_increment_use_count(v20);
  CFArrayAppendValue(a2, (const void *)v20);
  _mdns_dns_service_manager_update_interface_properties_for_service(a1, v20);
  if (_mdns_dns_service_log_s_once != -1) {
    dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_62);
  }
  uint64_t v28 = (os_log_s *)_mdns_dns_service_log_s_log;
  if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(buf) = 138412290;
    *(void *)((char *)&buf + 4) = v20;
    _os_log_impl( (void *)&_mh_execute_header,  v28,  OS_LOG_TYPE_DEFAULT,  "Registered push service -- %@",  (uint8_t *)&buf,  0xCu);
  }

  uint64_t v26 = *(void *)(v20 + 24);
  if (a7) {
LABEL_30:
  }
    *a7 = v19;
LABEL_31:
  if (v20) {
    os_release((void *)v20);
  }
  return v26;
}

BOOL ___mdns_dns_service_create_push_service_from_definition_block_invoke(uint64_t a1, void *a2)
{
  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 0;
  return *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) == 0;
}

BOOL ___mdns_dns_service_create_push_service_from_definition_block_invoke_2(uint64_t a1, void *a2)
{
  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = _mdns_dns_service_append_address( *(void *)(a1 + 40),  a2);
  return *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) == 0;
}

void mdns_dns_service_manager_deregister_custom_push_service(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    if (_mdns_dns_service_queue_s_once != -1) {
      dispatch_once(&_mdns_dns_service_queue_s_once, &__block_literal_global_237);
    }
    v4[0] = _NSConcreteStackBlock;
    v4[1] = 0x40000000LL;
    v4[2] = __mdns_dns_service_manager_deregister_custom_push_service_block_invoke;
    v4[3] = &__block_descriptor_tmp_11_792;
    v4[4] = a1;
    void v4[5] = a2;
    dispatch_sync((dispatch_queue_t)_mdns_dns_service_queue_s_queue, v4);
  }

void __mdns_dns_service_manager_deregister_custom_push_service_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (!*(_BYTE *)(v1 + 131))
  {
    uint64_t service_by_id = _mdns_dns_service_manager_get_service_by_id(*(const __CFArray **)(v1 + 72), *(void *)(a1 + 40));
    if (service_by_id) {
      _mdns_dns_service_manager_deregister_service(v1, service_by_id);
    }
  }

void __mdns_dns_service_manager_apply_dns_config_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (*(_BYTE *)(v1 + 131)) {
    return;
  }
  uint64_t v2 = *(unsigned int **)(a1 + 40);
  CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(v1 + 48));
  if (Count > 3)
  {
    CFIndex v5 = Count;
    if (_mdns_dns_service_log_s_once != -1) {
      dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_62);
    }
    int v6 = (os_log_s *)_mdns_dns_service_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 67109120;
      *(_DWORD *)&uint8_t buf[4] = v5;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "Purging %u discovered services down to 4",  buf,  8u);
    }

    uint64_t v4 = kCFAllocatorDefault;
    CFMutableArrayRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0LL, (const CFArrayCallBacks *)&mdns_cfarray_callbacks);
    MutableCFArrayRef Copy = CFArrayCreateMutableCopy(kCFAllocatorDefault, 0LL, *(CFArrayRef *)(v1 + 48));
    v32.location = 0LL;
    v32.size_t length = v5;
    CFArraySortValues(MutableCopy, v32, (CFComparatorFunction)_mdns_dns_service_compare_time, 0LL);
    for (unint64_t i = 0LL; i != v5; ++i)
    {
      ValueAtIndex = CFArrayGetValueAtIndex(MutableCopy, i);
      if (i < 4) {
        CFArrayAppendValue(Mutable, ValueAtIndex);
      }
      else {
        _mdns_dns_service_manager_terminate_service(v1, (uint64_t)ValueAtIndex);
      }
    }

    if (MutableCopy) {
      CFRelease(MutableCopy);
    }
    __int16 v11 = *(const void **)(v1 + 48);
    if (v11) {
      CFRelease(v11);
    }
    *(void *)(v1 + 4_Block_object_dispose(va, 8) = Mutable;
  }

  else
  {
    uint64_t v4 = kCFAllocatorDefault;
  }

  uint64_t v12 = CFArrayCreateMutable(v4, 0LL, (const CFArrayCallBacks *)&mdns_cfarray_callbacks);
  if (!v12)
  {
    int v24 = -6729;
    goto LABEL_36;
  }

  unsigned int v13 = v12;
  int appended = _mdns_append_dns_service_from_config_by_scope(v12, v2, 1);
  if (appended
    || (int appended = _mdns_append_dns_service_from_config_by_scope(v13, v2, 2)) != 0
    || (int appended = _mdns_append_dns_service_from_config_by_scope(v13, v2, 3)) != 0)
  {
    int v24 = appended;
    CFRelease(v13);
LABEL_36:
    _mdns_dns_service_manager_terminate(v1, v24);
    return;
  }

  CFIndex v15 = CFArrayGetCount(v13);
  CFIndex v16 = CFArrayGetCount(*(CFArrayRef *)(v1 + 32));
  if (v16 - 1 >= 0)
  {
    uint64_t v17 = v16;
    do
    {
      uint64_t v18 = (const __CFArray **)CFArrayGetValueAtIndex(*(CFArrayRef *)(v1 + 32), --v17);
      v33.location = 0LL;
      v33.size_t length = v15;
      CFIndex FirstIndexOfValue = CFArrayGetFirstIndexOfValue(v13, v33, v18);
      if (FirstIndexOfValue < 0)
      {
        _mdns_dns_service_manager_terminate_service(v1, (uint64_t)v18);
      }

      else
      {
        CFIndex v20 = FirstIndexOfValue;
        __int16 v21 = *((_WORD *)CFArrayGetValueAtIndex(v13, FirstIndexOfValue) + 138) & 0xE;
        *((_WORD *)v18 + 13_Block_object_dispose(va, 8) = *((_WORD *)v18 + 138) & 0xFFF1 | v21;
        v25[0] = _NSConcreteStackBlock;
        v25[1] = 0x40000000LL;
        v25[2] = ___mdns_dns_service_manager_apply_dns_config_internal_block_invoke;
        v25[3] = &__block_descriptor_tmp_65;
        __int16 v26 = v21;
        uint64_t v22 = v18[18];
        if (v22) {
          mdns_cfarray_enumerate(v22, (uint64_t)v25);
        }
        CFArraySetValueAtIndex(v13, v20, v18);
      }
    }

    while (v17 > 0);
  }

  int v23 = *(const void **)(v1 + 32);
  if (v23) {
    CFRelease(v23);
  }
  *(void *)(v1 + 32) = v13;
  *(void *)__int128 buf = _NSConcreteStackBlock;
  uint64_t v28 = 0x40000000LL;
  uint64_t v29 = ___mdns_dns_service_manager_apply_dns_config_internal_block_invoke_2;
  uint64_t v30 = &__block_descriptor_tmp_66;
  uint64_t v31 = v1;
  mdns_cfarray_enumerate(v13, (uint64_t)buf);
  _mdns_dns_service_manager_remove_unneeded_interface_monitors(v1);
}

uint64_t _mdns_dns_service_compare_time(uint64_t a1, uint64_t a2)
{
  unint64_t v2 = *(void *)(a1 + 32);
  unint64_t v3 = *(void *)(a2 + 32);
  BOOL v4 = v2 > v3;
  BOOL v5 = v2 < v3;
  if (v4) {
    return -1LL;
  }
  else {
    return v5;
  }
}

uint64_t _mdns_append_dns_service_from_config_by_scope(const __CFArray *a1, unsigned int *a2, int a3)
{
  char v3 = a3;
  switch(a3)
  {
    case 3:
      BOOL v5 = (uint64_t *)(a2 + 9);
      a2 += 8;
      break;
    case 2:
      BOOL v5 = (uint64_t *)(a2 + 4);
      a2 += 3;
      break;
    case 1:
      BOOL v5 = (uint64_t *)(a2 + 1);
      break;
    default:
      return 0LL;
  }

  uint64_t v6 = *a2;
  uint64_t v7 = 0LL;
  uint64_t v8 = *v5;
  unsigned int appended = 0;
  uint64_t v41 = v8;
  uint64_t v39 = v6;
  while (1)
  {
    uint64_t v9 = *(void *)(v8 + 8 * v7);
    if (*(_WORD *)(v9 + 20) == 5353 || !*(_DWORD *)(v9 + 8)) {
      goto LABEL_64;
    }
    if (*(void *)v9)
    {
      __int128 v59 = 0u;
      __int128 v60 = 0u;
      __int128 v57 = 0u;
      __int128 v58 = 0u;
      __int128 v55 = 0u;
      __int128 v56 = 0u;
      __int128 v53 = 0u;
      __int128 v54 = 0u;
      __int128 v51 = 0u;
      __int128 v52 = 0u;
      __int128 v49 = 0u;
      __int128 v50 = 0u;
      __int128 v47 = 0u;
      __int128 v48 = 0u;
      memset(buf, 0, sizeof(buf));
      if (DomainNameFromString(buf, *(char **)v9))
      {
        if (_mdns_dns_service_log_s_once != -1) {
          dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_62);
        }
        int v10 = (os_log_s *)_mdns_dns_service_log_s_log;
        if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_ERROR))
        {
          int v38 = *(char **)v9;
          *(_DWORD *)int v43 = 136315138;
          *(void *)&v43[4] = v38;
          _os_log_error_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_ERROR,  "Encountered invalid dns_config_t resolver domain name: %s",  v43,  0xCu);
        }

        uint64_t v8 = v41;
        goto LABEL_64;
      }
    }

    uint64_t v11 = _mdns_dns_service_create(1, 2, v3, (int *)&appended);
    uint64_t result = appended;
    if (appended) {
      goto LABEL_68;
    }
    int v13 = *(_DWORD *)(v9 + 8);
    if (v13 >= 1) {
      break;
    }
LABEL_40:
    *(_DWORD *)(v11 + 256) = *(_DWORD *)(v9 + 64);
    char v3 = a3;
    if (a3 == 3) {
      int v30 = *(_DWORD *)(v9 + 76);
    }
    else {
      int v30 = 0;
    }
    uint64_t v6 = v39;
    uint64_t v8 = v41;
    *(_DWORD *)(v11 + 260) = v30;
    *(_WORD *)(v11 + 276) = 0;
    if (*(void *)v9) {
      uint64_t v31 = *(char **)v9;
    }
    else {
      uint64_t v31 = ".";
    }
    CFIndex Count = CFArrayGetCount(a1);
    if (Count < 1)
    {
LABEL_51:
      int v36 = *(_DWORD *)(v9 + 68);
      if ((v36 & 2) != 0) {
        *(_WORD *)(v11 + 276) |= 2u;
      }
      if ((v36 & 4) != 0) {
        *(_WORD *)(v11 + 276) |= 4u;
      }
      if ((*(_BYTE *)(v9 + 74) & 4) != 0) {
        *(_WORD *)(v11 + 276) |= 8u;
      }
      unsigned int v37 = *(_DWORD *)(v11 + 256);
      if (v37) {
        *(void *)(v11 + 104) = mdns_system_interface_index_to_name(v37);
      }
      unsigned int appended = _mdns_dns_service_add_domain_by_string(v11, v31, *(_DWORD *)(v9 + 60));
      if (appended) {
        goto LABEL_69;
      }
      CFArrayAppendValue(a1, (const void *)v11);
    }

    else
    {
      CFIndex v33 = Count;
      CFIndex v34 = 0LL;
      while (1)
      {
        ValueAtIndex = CFArrayGetValueAtIndex(a1, v34);
        if (v33 == ++v34)
        {
          char v3 = a3;
          uint64_t v6 = v39;
          uint64_t v8 = v41;
          if (!v11) {
            goto LABEL_64;
          }
          goto LABEL_51;
        }
      }

      uint64_t result = _mdns_dns_service_add_domain_by_string((uint64_t)ValueAtIndex, v31, *(_DWORD *)(v9 + 60));
      unsigned int appended = result;
      if ((_DWORD)result) {
        goto LABEL_68;
      }
      char v3 = a3;
      uint64_t v6 = v39;
      uint64_t v8 = v41;
      if (!v11) {
        goto LABEL_64;
      }
    }

    os_release((void *)v11);
LABEL_64:
    if (++v7 == v6) {
      return 0LL;
    }
  }

  uint64_t v14 = 0LL;
  unsigned int v15 = *(unsigned __int16 *)(v9 + 20);
  if (!*(_WORD *)(v9 + 20)) {
    unsigned int v15 = 53;
  }
  __int16 v16 = __rev16(v15);
  while (1)
  {
    uint64_t v17 = *(void *)(*(void *)(v9 + 12) + 8 * v14);
    int v18 = *(unsigned __int8 *)(v17 + 1);
    if (v18 == 30) {
      break;
    }
    if (v18 == 2)
    {
      int v19 = *(_DWORD *)(v17 + 4);
      uint64_t v20 = _mdns_address_new();
      if (!v20) {
        goto LABEL_67;
      }
      __int16 v21 = (void *)v20;
      *(_WORD *)(v20 + memset(&v5[1], 0, 24) = 528;
      *(_WORD *)(v20 + 26) = v16;
      *(_DWORD *)(v20 + 2_Block_object_dispose(va, 8) = v19;
      goto LABEL_37;
    }

uint64_t ___mdns_dns_service_manager_apply_dns_config_internal_block_invoke(uint64_t a1, uint64_t a2)
{
  __int16 v2 = *(_WORD *)(a2 + 276) & 0xFFF1;
  *(_WORD *)(a2 + 276) = v2;
  *(_WORD *)(a2 + 276) = *(_WORD *)(a1 + 32) | v2;
  return 1LL;
}

uint64_t ___mdns_dns_service_manager_apply_dns_config_internal_block_invoke_2(uint64_t a1, uint64_t a2)
{
  if (!*(_DWORD *)(a2 + 264))
  {
    _mdns_dns_service_increment_use_count(a2);
    _mdns_dns_service_manager_update_interface_properties_for_service(*(CFArrayRef **)(a1 + 32), a2);
  }

  return 1LL;
}

void _mdns_dns_service_manager_remove_unneeded_interface_monitors(uint64_t a1)
{
  CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 80));
  if (Count - 1 >= 0)
  {
    CFIndex v3 = Count;
    do
    {
      ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 80), --v3);
      int v5 = ValueAtIndex[34];
      v6[0] = _NSConcreteStackBlock;
      v6[1] = 0x40000000LL;
      v6[2] = ___mdns_dns_service_manager_uses_interface_block_invoke;
      v6[3] = &__block_descriptor_tmp_118;
      int v7 = v5;
      v8[0] = _NSConcreteStackBlock;
      v8[1] = 0x40000000LL;
      v8[2] = ___mdns_dns_service_manager_enumerate_all_services_block_invoke;
      v8[3] = &unk_10013B1D8;
      v8[4] = v6;
      v9[0] = _NSConcreteStackBlock;
      v9[1] = 0x40000000LL;
      v9[2] = ___mdns_dns_service_manager_enumerate_all_service_arrays_block_invoke;
      v9[3] = &unk_10013B1B0;
      v9[4] = v8;
      if (_mdns_dns_service_manager_enumerate_all_service_array_pointers(a1, (uint64_t)v9))
      {
        mdns_interface_monitor_invalidate(ValueAtIndex);
        CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(a1 + 80), v3);
      }
    }

    while (v3 > 0);
  }

BOOL ___mdns_dns_service_manager_uses_interface_block_invoke(uint64_t a1, uint64_t a2)
{
  return *(_DWORD *)(a2 + 256) != *(_DWORD *)(a1 + 32);
}

uint64_t _mdns_dns_service_add_domain_by_string(uint64_t a1, char *a2, unsigned int a3)
{
  unsigned int v8 = 0;
  int v5 = mdns_domain_name_create(a2, &v8);
  if (v5)
  {
    uint64_t v6 = v5;
    _mdns_dns_service_add_domain(a1, v5, a3);
    unsigned int v8 = 0;
    os_release(v6);
  }

  return v8;
}

void __mdns_dns_service_manager_register_path_resolver_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (!*(_BYTE *)(v1 + 131))
  {
    __int16 v2 = *(const unsigned __int8 **)(a1 + 40);
    uint64_t service_by_uuid = _mdns_dns_service_manager_get_service_by_uuid(*(const __CFArray **)(v1 + 40), v2);
    if (service_by_uuid)
    {
      uint64_t v10 = service_by_uuid;
      if (_mdns_dns_service_log_s_once != -1) {
        dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_62);
      }
      uint64_t v11 = (os_log_s *)_mdns_dns_service_log_s_log;
      if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v12 = *(void *)(v10 + 24);
        *(_DWORD *)uint64_t v20 = 134218498;
        *(void *)&void v20[4] = v12;
        *(_WORD *)&v20[12] = 1040;
        *(_DWORD *)&v20[14] = 16;
        *(_WORD *)&v20[18] = 2096;
        *(void *)&v20[20] = v2;
        _os_log_debug_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEBUG,  "Already registered service -- service id: %llu, uuid: %{uuid_t}.16P",  v20,  0x1Cu);
      }
    }

    else
    {
      BOOL v4 = (void *)nw_resolver_config_create();
      nw_resolver_config_set_identifier(v4, v2);
      os_retain((void *)v1);
      nw_retain(v4);
      if (_mdns_dns_service_queue_s_once != -1) {
        dispatch_once(&_mdns_dns_service_queue_s_once, &__block_literal_global_237);
      }
      *(void *)uint64_t v20 = _NSConcreteStackBlock;
      *(void *)&v20[8] = 0x40000000LL;
      *(void *)&_OWORD v20[16] = ___mdns_dns_service_manager_register_path_resolver_internal_block_invoke;
      *(void *)&v20[24] = &__block_descriptor_tmp_69;
      uint64_t v21 = v1;
      uint64_t v22 = v4;
      nw_resolver_config_watch_updates(v4, _mdns_dns_service_queue_s_queue, v20);
      int v13 = 0;
      int v5 = _mdns_dns_service_create_from_resolver_config(v4, 3, 4, &v13);
      if (v5)
      {
        uint64_t v6 = v5;
        v5[284] = 1;
        int v7 = *(__CFArray **)(v1 + 40);
        _mdns_dns_service_increment_use_count((uint64_t)v5);
        CFArrayAppendValue(v7, v6);
        _mdns_dns_service_manager_update_interface_properties_for_service((CFArrayRef *)v1, (uint64_t)v6);
        if (_mdns_dns_service_log_s_once != -1) {
          dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_62);
        }
        unsigned int v8 = (os_log_s *)_mdns_dns_service_log_s_log;
        if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)__int128 buf = 138412290;
          *(void *)unsigned int v15 = v6;
          _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Registered service -- %@", buf, 0xCu);
        }

        os_release(v6);
      }

      else
      {
        _mdns_dns_service_manager_cancel_resolver_config_updates(v1, (uint64_t)v4);
        if (_mdns_dns_service_log_s_once != -1) {
          dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_62);
        }
        uint64_t v9 = (os_log_s *)_mdns_dns_service_log_s_log;
        if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)__int128 buf = 68158466;
          *(_DWORD *)unsigned int v15 = 16;
          *(_WORD *)&v15[4] = 2096;
          *(void *)&v15[6] = v2;
          __int16 v16 = 2112;
          uint64_t v17 = v4;
          __int16 v18 = 2048;
          uint64_t v19 = v13;
          _os_log_error_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_ERROR,  "Failed to register service -- uuid: %{uuid_t}.16P, config: %@, error: %{mdns:err}ld",  buf,  0x26u);
        }
      }

      nw_release(v4);
    }
  }

uint64_t _mdns_dns_service_manager_get_service_by_uuid(const __CFArray *a1, const unsigned __int8 *a2)
{
  uint64_t v5 = 0LL;
  uint64_t v6 = &v5;
  uint64_t v7 = 0x2000000000LL;
  uint64_t v8 = 0LL;
  int v13 = 3;
  memset(dst, 0, sizeof(dst));
  uuid_copy(dst, a2);
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 0x40000000LL;
  v9[2] = ___mdns_dns_service_manager_get_service_by_uuid_block_invoke;
  v9[3] = &unk_10013A7F8;
  __int128 v10 = *(_OWORD *)dst;
  int v11 = v13;
  v9[4] = &v5;
  mdns_cfarray_enumerate(a1, (uint64_t)v9);
  uint64_t v3 = v6[3];
  _Block_object_dispose(&v5, 8);
  return v3;
}

void ___mdns_dns_service_manager_register_path_resolver_internal_block_invoke(uint64_t a1, int a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = *(void *)(a1 + 40);
  if (a2)
  {
    uint64_t path_service_by_config = _mdns_dns_service_manager_get_path_service_by_config(*(const __CFArray **)(v2 + 40), v3);
    if (path_service_by_config)
    {
      uint64_t v5 = path_service_by_config;
      _mdns_dns_service_manager_deregister_service(v2, path_service_by_config);
      if (_mdns_dns_service_log_s_once != -1) {
        dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_62);
      }
      uint64_t v6 = (os_log_s *)_mdns_dns_service_log_s_log;
      if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(buf) = 138412290;
        *(void *)((char *)&buf + 4) = v5;
        _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "Deregistered service -- %@",  (uint8_t *)&buf,  0xCu);
      }
    }

    return;
  }

  if (v3)
  {
    if (nw_resolver_config_get_protocol(*(void *)(a1 + 40)) == 3)
    {
      uint64_t v7 = _mdns_dns_service_manager_get_path_service_by_config(*(const __CFArray **)(v2 + 40), v3);
      if (v7)
      {
        uint64_t v8 = v7;
        uint64_t provider_name = nw_resolver_config_get_provider_name(*(void *)(v7 + 96));
        uint64_t provider_path = nw_resolver_config_get_provider_path(*(void *)(v8 + 96));
        uint64_t v24 = 0LL;
        uint64_t odoh_config = nw_resolver_config_get_odoh_config(*(void *)(v8 + 96), &v24);
        uint64_t v12 = nw_resolver_config_copy_proxy_config(*(void *)(v8 + 96));
        int v13 = (void *)v12;
        if (v12) {
          nw_proxy_config_set_prohibit_direct(v12, 1LL);
        }
        uint64_t v14 = *(void *)(v8 + 64);
        if (v14)
        {
          unsigned int v15 = *(void (**)(void))(*(void *)(v14 + 16) + 96LL);
          if (v15) {
            v15();
          }
          if (_mdns_dns_service_log_s_once != -1) {
            dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_62);
          }
          __int16 v16 = (os_log_s *)_mdns_dns_service_log_s_log;
          if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_DEFAULT))
          {
            LODWORD(buf) = 138412290;
            *(void *)((char *)&buf + 4) = v8;
            _os_log_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_DEFAULT,  "Updated ODoH config -- %@",  (uint8_t *)&buf,  0xCu);
          }
        }

        *(void *)&__int128 buf = _NSConcreteStackBlock;
        *((void *)&buf + 1) = 0x40000000LL;
        BOOL v26 = ___mdns_dns_service_manager_handle_resolver_config_update_block_invoke;
        int v27 = &__block_descriptor_tmp_73;
        uint64_t v28 = provider_name;
        uint64_t v29 = provider_path;
        uint64_t v30 = odoh_config;
        uint64_t v31 = v24;
        CFRange v32 = v13;
        uint64_t v17 = *(const __CFArray **)(v8 + 128);
        if (v17) {
          mdns_cfarray_enumerate(v17, (uint64_t)&buf);
        }
        if (v13) {
          nw_release(v13);
        }
        uint64_t v18 = *(void *)(v8 + 96);
        if (v18)
        {
          if (!*(void *)(v8 + 136))
          {
            if (*(void *)(v8 + 160))
            {
              string_ptr = xpc_string_get_string_ptr(*(xpc_object_t *)(v8 + 160));
              uint64_t v20 = (const char *)nw_resolver_config_get_provider_name(*(void *)(v8 + 96));
              if (string_ptr)
              {
                if (v20 && !strcmp(string_ptr, v20))
                {
LABEL_33:
                  uint64_t v21 = *(const char **)(v8 + 168);
                  uint64_t v22 = (const char *)nw_resolver_config_get_provider_path(*(void *)(v8 + 96));
                  if (v21)
                  {
                    if (v22 && !strcmp(v21, v22)) {
                      return;
                    }
                  }

                  else if (!v22)
                  {
                    return;
                  }
                }
              }

              else if (!v20)
              {
                goto LABEL_33;
              }
            }

            else if (!nw_resolver_config_get_provider_name(v18))
            {
              goto LABEL_33;
            }

            int v23 = *(dispatch_source_s **)(v2 + 96);
            if (v23) {
              dispatch_source_merge_data(v23, 1uLL);
            }
          }
        }
      }
    }
  }

char *_mdns_dns_service_create_from_resolver_config(void *a1, char a2, char a3, int *a4)
{
  uint64_t v18 = 0LL;
  uint64_t v19 = (int *)&v18;
  uint64_t v20 = 0x2000000000LL;
  int v21 = 0;
  unsigned int protocol = nw_resolver_config_get_protocol();
  if (protocol < 4) {
    char v9 = protocol + 1;
  }
  else {
    char v9 = 0;
  }
  uint64_t v10 = _mdns_dns_service_create(v9, a2, a3, v19 + 6);
  uint64_t v11 = v10;
  int v12 = v19[6];
  if (!v12)
  {
    v17[0] = _NSConcreteStackBlock;
    v17[1] = 0x40000000LL;
    v17[2] = ___mdns_dns_service_create_from_resolver_config_block_invoke;
    v17[3] = &unk_10013A888;
    v17[4] = &v18;
    v17[5] = v10;
    nw_resolver_config_enumerate_name_servers(a1, v17);
    int v12 = v19[6];
    if (!v12)
    {
      v16[0] = _NSConcreteStackBlock;
      v16[1] = 0x40000000LL;
      _DWORD v16[2] = ___mdns_dns_service_create_from_resolver_config_block_invoke_2;
      v16[3] = &__block_descriptor_tmp_76;
      v16[4] = v11;
      nw_resolver_config_enumerate_match_domains(a1, v16);
      *(void *)(v11 + 96) = a1;
      nw_retain(a1);
      interface_name = (const char *)nw_resolver_config_get_interface_name(a1);
      if (interface_name)
      {
        uint64_t v14 = interface_name;
        uint64_t result = strdup(interface_name);
        if (!result)
        {
          __break(1u);
          return result;
        }

        *(void *)(v11 + 104) = result;
        *(_DWORD *)(v11 + 256) = if_nametoindex(v14);
      }

      *(_WORD *)(v11 + 276) = 6;
      _mdns_dns_service_update_nw_config_data(v11);
      int v12 = 0;
      v19[6] = 0;
    }
  }

  if (a4) {
    *a4 = v12;
  }
  _Block_object_dispose(&v18, 8);
  return (char *)v11;
}

BOOL ___mdns_dns_service_create_from_resolver_config_block_invoke(uint64_t a1, char *a2)
{
  uint64_t v3 = (void *)mdns_address_create_from_ip_address_string(a2);
  BOOL result = 1;
  if (v3)
  {
    BOOL v4 = v3;
    *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = _mdns_dns_service_append_address( *(void *)(a1 + 40),  v3);
    os_release(v4);
    if (*(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL)) {
      return 0;
    }
  }

  return result;
}

uint64_t ___mdns_dns_service_create_from_resolver_config_block_invoke_2(uint64_t a1, char *a2)
{
  return 1LL;
}

const char *_mdns_dns_service_update_nw_config_data(uint64_t a1)
{
  BOOL result = *(const char **)(a1 + 96);
  if (result && !*(void *)(a1 + 136))
  {
    uint64_t provider_name = (const char *)nw_resolver_config_get_provider_name();
    BOOL v4 = *(void **)(a1 + 160);
    if (v4)
    {
      string_ptr = xpc_string_get_string_ptr(v4);
      if (string_ptr)
      {
        if (!provider_name)
        {
          uint64_t v10 = *(void **)(a1 + 160);
          if (!v10) {
            goto LABEL_15;
          }
          xpc_release(v10);
          xpc_object_t v7 = 0LL;
LABEL_14:
          *(void *)(a1 + 160) = v7;
          goto LABEL_15;
        }

        if (!strcmp(string_ptr, provider_name)) {
          goto LABEL_15;
        }
      }

      else if (!provider_name)
      {
        goto LABEL_15;
      }

      uint64_t v6 = *(void **)(a1 + 160);
      if (v6)
      {
        xpc_release(v6);
        *(void *)(a1 + 160) = 0LL;
      }
    }

    else if (!provider_name)
    {
LABEL_15:
      BOOL result = (const char *)nw_resolver_config_get_provider_path(*(void *)(a1 + 96));
      uint64_t v8 = result;
      char v9 = *(void **)(a1 + 168);
      if (v9)
      {
        if (!result) {
          goto LABEL_22;
        }
        BOOL result = (const char *)strcmp(*(const char **)(a1 + 168), result);
        if (!(_DWORD)result) {
          return result;
        }
        free(v9);
        *(void *)(a1 + 16_Block_object_dispose(va, 8) = 0LL;
      }

      else if (!result)
      {
        return result;
      }

      BOOL result = strdup(v8);
      if (result)
      {
LABEL_23:
        *(void *)(a1 + 16_Block_object_dispose(va, 8) = result;
        return result;
      }

      __break(1u);
LABEL_22:
      free(v9);
      BOOL result = 0LL;
      goto LABEL_23;
    }

    xpc_object_t v7 = xpc_string_create(provider_name);
    goto LABEL_14;
  }

  return result;
}

uint64_t _mdns_dns_service_manager_get_path_service_by_config(const __CFArray *a1, uint64_t a2)
{
  uint64_t v5 = 0LL;
  uint64_t v6 = &v5;
  uint64_t v7 = 0x2000000000LL;
  uint64_t v8 = 0LL;
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000LL;
  v4[2] = ___mdns_dns_service_manager_get_path_service_by_config_block_invoke;
  v4[3] = &unk_10013A820;
  v4[4] = &v5;
  void v4[5] = a2;
  mdns_cfarray_enumerate(a1, (uint64_t)v4);
  uint64_t v2 = v6[3];
  _Block_object_dispose(&v5, 8);
  return v2;
}

uint64_t ___mdns_dns_service_manager_handle_resolver_config_update_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 64);
  if (v2)
  {
    uint64_t v3 = *(void (**)(void))(*(void *)(v2 + 16) + 96LL);
    if (v3) {
      v3();
    }
  }

  return 1LL;
}

BOOL ___mdns_dns_service_manager_get_path_service_by_config_block_invoke(uint64_t a1, uint64_t a2)
{
  if (*(void *)(a2 + 96) == *(void *)(a1 + 40)) {
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = a2;
  }
  return *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) == 0LL;
}

BOOL ___mdns_dns_service_manager_get_service_by_uuid_block_invoke(uint64_t a1, uint64_t a2)
{
  return *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) == 0LL;
}

uint64_t _mdns_dns_service_scope_id_match(uint64_t a1, uint64_t a2)
{
  switch(*(_BYTE *)(a1 + 280))
  {
    case 1:
      return !*(_BYTE *)(a2 + 16);
    case 2:
      int v3 = *(unsigned __int8 *)(a2 + 16);
      goto LABEL_12;
    case 3:
      if (*(_BYTE *)(a2 + 16) != 2) {
        return 0LL;
      }
      int v4 = *(_DWORD *)(a1 + 260);
      return v4 == *(_DWORD *)a2;
    case 4:
      if (*(_BYTE *)(a2 + 16) == 3)
      {
        uint64_t v5 = *(void *)(a1 + 96);
        if (v5)
        {
          *(void *)uu1 = 0LL;
          uint64_t v8 = 0LL;
          nw_resolver_config_get_identifier(v5, uu1);
        }
      }

      return 0LL;
    case 5:
      int v3 = *(unsigned __int8 *)(a2 + 16);
      if (!*(_BYTE *)(a2 + 16)) {
        return 1LL;
      }
      if (v3 != 1) {
        return 0LL;
      }
LABEL_12:
      int v4 = *(_DWORD *)(a1 + 256);
      return v4 == *(_DWORD *)a2;
    default:
      return 0LL;
  }

uint64_t mdns_dns_service_manager_register_custom_service(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = 0LL;
  uint64_t v8 = &v7;
  uint64_t v9 = 0x2000000000LL;
  uint64_t v10 = 0LL;
  if (_mdns_dns_service_queue_s_once != -1) {
    dispatch_once(&_mdns_dns_service_queue_s_once, &__block_literal_global_237);
  }
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000LL;
  block[2] = __mdns_dns_service_manager_register_custom_service_block_invoke;
  block[3] = &unk_10013A198;
  void block[4] = &v7;
  void block[5] = a1;
  block[6] = a2;
  dispatch_sync((dispatch_queue_t)_mdns_dns_service_queue_s_queue, block);
  uint64_t v4 = v8[3];
  _Block_object_dispose(&v7, 8);
  return v4;
}

void __mdns_dns_service_manager_register_custom_service_block_invoke(void *a1)
{
  uint64_t v2 = a1[5];
  if (*(_BYTE *)(v2 + 131)) {
    goto LABEL_21;
  }
  int v3 = (void *)a1[6];
  uint64_t v4 = nw_resolver_config_create_with_dictionary(v3);
  if (!v4)
  {
    __int16 v16 = xpc_copy_description(v3);
    if (_mdns_dns_service_log_s_once != -1) {
      dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_62);
    }
    uint64_t v17 = (os_log_s *)_mdns_dns_service_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_ERROR))
    {
      uint64_t v18 = "<NO DESC.>";
      if (v16) {
        uint64_t v18 = v16;
      }
      *(_DWORD *)__int128 buf = 136315138;
      *(void *)int v21 = v18;
      _os_log_error_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_ERROR,  "Failed to create nw_resolver_config for dictionary: %s",  buf,  0xCu);
      if (!v16) {
        goto LABEL_21;
      }
    }

    else if (!v16)
    {
      goto LABEL_21;
    }

    free(v16);
    goto LABEL_21;
  }

  uint64_t v5 = (void *)v4;
  v26[0] = 0LL;
  v26[1] = 0LL;
  nw_resolver_config_get_identifier(v4, v26);
  uint64_t service_by_uuid = _mdns_dns_service_manager_get_service_by_uuid( *(const __CFArray **)(v2 + 56),  (const unsigned __int8 *)v26);
  if (!service_by_uuid)
  {
    int v19 = 0;
    uint64_t v11 = _mdns_dns_service_create_from_resolver_config(v5, 5, 4, &v19);
    if (v11)
    {
      uint64_t v7 = v11;
      int v12 = *(__CFArray **)(v2 + 56);
      _mdns_dns_service_increment_use_count((uint64_t)v11);
      CFArrayAppendValue(v12, v7);
      _mdns_dns_service_manager_update_interface_properties_for_service((CFArrayRef *)v2, (uint64_t)v7);
      if (_mdns_dns_service_log_s_once != -1) {
        dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_62);
      }
      int v13 = (os_log_s *)_mdns_dns_service_log_s_log;
      if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)__int128 buf = 138412290;
        *(void *)int v21 = v7;
        _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEFAULT,  "Registered custom service -- %@",  buf,  0xCu);
      }

      os_release(v7);
      goto LABEL_14;
    }

    if (_mdns_dns_service_log_s_once != -1) {
      dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_62);
    }
    unsigned int v15 = (os_log_s *)_mdns_dns_service_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)__int128 buf = 68158466;
      *(_DWORD *)int v21 = 16;
      *(_WORD *)&v21[4] = 2096;
      *(void *)&void v21[6] = v26;
      __int16 v22 = 2112;
      int v23 = v5;
      __int16 v24 = 2048;
      uint64_t v25 = v19;
      _os_log_error_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_ERROR,  "Failed to register custom service -- uuid: %{uuid_t}.16P, config: %@, error: %{mdns:err}ld",  buf,  0x26u);
    }

    nw_release(v5);
LABEL_21:
    uint64_t v14 = 0LL;
    goto LABEL_15;
  }

  uint64_t v7 = (void *)service_by_uuid;
  int v8 = _mdns_dns_service_increment_use_count(service_by_uuid);
  if (_mdns_dns_service_log_s_once != -1) {
    dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_62);
  }
  uint64_t v9 = (os_log_s *)_mdns_dns_service_log_s_log;
  if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_INFO))
  {
    uint64_t v10 = v7[3];
    *(_DWORD *)__int128 buf = 134218240;
    *(void *)int v21 = v10;
    *(_WORD *)&v21[8] = 1024;
    *(_DWORD *)&v21[10] = v8;
    _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_INFO,  "Registered existing custom service -- service id: %llu, use count: %d",  buf,  0x12u);
  }

void __mdns_dns_service_manager_deregister_custom_service_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (!*(_BYTE *)(v1 + 131))
  {
    uint64_t service_by_id = _mdns_dns_service_manager_get_service_by_id(*(const __CFArray **)(v1 + 56), *(void *)(a1 + 40));
    if (service_by_id) {
      _mdns_dns_service_manager_deregister_service(v1, service_by_id);
    }
  }

void __mdns_dns_service_manager_register_doh_uri_block_invoke(void *a1)
{
  uint64_t v2 = a1[4];
  if (!*(_BYTE *)(v2 + 131))
  {
    int v3 = (const char *)a1[5];
    if (v3 && (uint64_t v25 = (char *)a1[6], (v4 = strdup(v3)) != 0LL))
    {
      uint64_t v1 = v4;
      uint64_t v5 = strchr(v4, 123);
      if (v5) {
        *uint64_t v5 = 0;
      }
      nw_endpoint_t url = nw_endpoint_create_url(v1);
      if (url)
      {
        uint64_t v7 = url;
        url_scheme = (const char *)nw_endpoint_get_url_scheme();
        if (url_scheme && !strcasecmp("https", url_scheme))
        {
          hostname = nw_endpoint_get_hostname(v7);
          uint64_t url_path = nw_endpoint_get_url_path(v7);
          if (hostname
            && (uint64_t v11 = (const char *)url_path) != 0LL
            && (CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(v2 + 48)), Count >= 1))
          {
            CFIndex v13 = Count;
            CFIndex v14 = 0LL;
            while (1)
            {
              uint64_t ValueAtIndex = (uint64_t)CFArrayGetValueAtIndex(*(CFArrayRef *)(v2 + 48), v14);
              uint64_t v16 = *(void *)(ValueAtIndex + 96);
              if (v16)
              {
                if (nw_resolver_config_get_protocol(v16) == 2)
                {
                  uint64_t provider_name = (const char *)nw_resolver_config_get_provider_name(*(void *)(ValueAtIndex + 96));
                  uint64_t provider_path = (const char *)nw_resolver_config_get_provider_path(*(void *)(ValueAtIndex + 96));
                  if (!strcasecmp(hostname, provider_name) && !strcasecmp(v11, provider_path)) {
                    break;
                  }
                }
              }

              if (v13 == ++v14) {
                goto LABEL_18;
              }
            }
          }

          else
          {
LABEL_18:
            if (_mdns_dns_service_log_s_once != -1) {
              dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_62);
            }
            int v19 = (os_log_s *)_mdns_dns_service_log_s_log;
            if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)__int128 buf = 136315138;
              *(void *)&uint8_t buf[4] = v1;
              _os_log_impl( (void *)&_mh_execute_header,  v19,  OS_LOG_TYPE_DEFAULT,  "Registering discovered DoH resolver at %s",  buf,  0xCu);
            }

            uint64_t v20 = (void *)nw_resolver_config_create();
            nw_resolver_config_set_class(v20, 3LL);
            nw_resolver_config_set_protocol(v20, 2LL);
            int v21 = nw_endpoint_get_hostname(v7);
            nw_resolver_config_set_provider_name(v20, v21);
            uint64_t v22 = nw_endpoint_get_url_path(v7);
            nw_resolver_config_set_provider_path(v20, v22);
            *(void *)__int128 buf = 0LL;
            *(void *)&uint8_t buf[8] = 0LL;
            uuid_generate(buf);
            nw_resolver_config_set_identifier(v20, buf);
            int v26 = 0;
            uint64_t ValueAtIndex = _mdns_dns_service_create(3, 4, 4, &v26);
            if (v26)
            {
              if (v20) {
                nw_release(v20);
              }
              if (!ValueAtIndex) {
                goto LABEL_31;
              }
            }

            else
            {
              *(void *)(ValueAtIndex + 4_Block_object_dispose(va, 8) = nw_retain(v7);
              *(_BYTE *)(ValueAtIndex + 56) = 1;
              *(void *)(ValueAtIndex + 96) = v20;
              *(_WORD *)(ValueAtIndex + 276) = 6;
              _mdns_dns_service_update_nw_config_data(ValueAtIndex);
            }

            int v23 = *(__CFArray **)(v2 + 48);
            _mdns_dns_service_increment_use_count(ValueAtIndex);
            CFArrayAppendValue(v23, (const void *)ValueAtIndex);
            _mdns_dns_service_manager_update_interface_properties_for_service((CFArrayRef *)v2, ValueAtIndex);
            os_release((void *)ValueAtIndex);
            _mdns_dns_service_manager_fetch_doh_pvd((void *)ValueAtIndex);
          }

          if (v25)
          {
            if (_mdns_dns_service_log_s_once != -1) {
              dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_62);
            }
            __int16 v24 = (os_log_s *)_mdns_dns_service_log_s_log;
            if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)__int128 buf = 136315394;
              *(void *)&uint8_t buf[4] = v25;
              *(_WORD *)&buf[12] = 2080;
              *(void *)&buf[14] = v1;
              _os_log_impl( (void *)&_mh_execute_header,  v24,  OS_LOG_TYPE_DEFAULT,  "Adding domain %s to DoH resolver at %s",  buf,  0x16u);
            }

            _mdns_dns_service_add_domain_by_string(ValueAtIndex, v25, 0);
          }
        }

void _mdns_dns_service_manager_fetch_doh_pvd(void *a1)
{
  uint64_t v9 = 0LL;
  uint64_t v10 = &v9;
  uint64_t v11 = 0x2000000000LL;
  uint64_t v12 = 0LL;
  os_retain(a1);
  uint64_t v2 = (void *)a1[6];
  nw_retain(v2);
  if (_mdns_dns_service_queue_s_once != -1) {
    dispatch_once(&_mdns_dns_service_queue_s_once, &__block_literal_global_237);
  }
  int v3 = (void *)_mdns_dns_service_queue_s_queue;
  hostname = nw_endpoint_get_hostname((nw_endpoint_t)v2);
  uint64_t url_path = nw_endpoint_get_url_path(v2);
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 0x40000000LL;
  v8[2] = ___mdns_dns_service_manager_fetch_doh_pvd_block_invoke;
  v8[3] = &unk_10013A910;
  void v8[5] = v2;
  v8[6] = a1;
  v8[4] = &v9;
  pvd_query = http_task_create_pvd_query(v3, (uint64_t)hostname, url_path, v8);
  v10[3] = (uint64_t)pvd_query;
  uint64_t v7 = objc_autoreleasePoolPush();
  [pvd_query resume];
  objc_autoreleasePoolPop(v7);
  _Block_object_dispose(&v9, 8);
}

void ___mdns_dns_service_manager_fetch_doh_pvd_block_invoke(uint64_t a1, xpc_object_t xdict)
{
  if (xdict)
  {
    string = xpc_dictionary_get_string(xdict, "dohTemplate");
    if (string)
    {
      uint64_t v5 = string;
      size_t v6 = strlen(string);
      uint64_t v7 = strchr(v5, 123);
      if (v7) {
        size_t v6 = v7 - v5;
      }
      nw_endpoint_t url = nw_endpoint_get_url(*(nw_endpoint_t *)(a1 + 40));
      if (url && (uint64_t v9 = url, strlen(url) == v6) && !strncasecmp(v5, v9, v6))
      {
        uint64_t uint64 = xpc_dictionary_get_uint64(xdict, "secondsRemaining");
        if (uint64 || (uint64_t uint64 = xpc_dictionary_get_uint64(xdict, "seconds-remaining")) != 0)
        {
          if (_mdns_dns_service_log_s_once != -1) {
            dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_62);
          }
          uint64_t v17 = (os_log_s *)_mdns_dns_service_log_s_log;
          if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_INFO))
          {
            uint64_t v18 = *(void *)(a1 + 40);
            *(_DWORD *)__int128 buf = 138412546;
            uint64_t v31 = v18;
            __int16 v32 = 2048;
            uint64_t v33 = uint64;
            _os_log_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_INFO,  "DoH resolver for %@ will expire in %llu seconds",  buf,  0x16u);
          }

          if (_mdns_get_future_continuous_time_onceToken != -1) {
            dispatch_once(&_mdns_get_future_continuous_time_onceToken, &__block_literal_global_91);
          }
          unint64_t v19 = 1000000000
              * uint64
              * *(unsigned int *)algn_10014DBE4
              / _mdns_get_future_continuous_time_time_base;
          uint64_t v20 = mach_continuous_time() + v19;
        }

        else
        {
          if (_mdns_dns_service_log_s_once != -1) {
            dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_62);
          }
          uint64_t v25 = (os_log_s *)_mdns_dns_service_log_s_log;
          if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_INFO))
          {
            uint64_t v26 = *(void *)(a1 + 40);
            *(_DWORD *)__int128 buf = 138412290;
            uint64_t v31 = v26;
            _os_log_impl( (void *)&_mh_execute_header,  v25,  OS_LOG_TYPE_INFO,  "DoH resolver for %@ does not specify an expiration",  buf,  0xCu);
          }

          uint64_t v20 = 0LL;
        }

        *(void *)(*(void *)(a1 + 48) + 40LL) = v20;
        xpc_object_t value = xpc_dictionary_get_value(xdict, "dnsZones");
        xpc_object_t v22 = xpc_dictionary_get_value(xdict, "trustedNames");
        if (v22)
        {
          int v23 = v22;
          if (xpc_get_type(v22) == (xpc_type_t)&_xpc_type_array)
          {
            applier[0] = _NSConcreteStackBlock;
            applier[1] = 0x40000000LL;
            applier[2] = ___mdns_dns_service_manager_fetch_doh_pvd_block_invoke_85;
            applier[3] = &__block_descriptor_tmp_87;
            __int128 v28 = *(_OWORD *)(a1 + 40);
            xpc_object_t v29 = value;
            xpc_array_apply(v23, applier);
          }
        }
      }

      else
      {
        if (_mdns_dns_service_log_s_once != -1) {
          dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_62);
        }
        uint64_t v10 = _mdns_dns_service_log_s_log;
        if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_ERROR))
        {
          uint64_t v11 = *(void *)(a1 + 40);
          *(_DWORD *)__int128 buf = 138412546;
          uint64_t v31 = v11;
          __int16 v32 = 2080;
          uint64_t v33 = (uint64_t)v5;
          uint64_t v12 = "DoH resolver for %@ does not match DoH template %s";
          CFIndex v13 = (os_log_s *)v10;
          uint32_t v14 = 22;
LABEL_29:
          _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, v12, buf, v14);
        }
      }
    }

    else
    {
      if (_mdns_dns_service_log_s_once != -1) {
        dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_62);
      }
      uint64_t v15 = _mdns_dns_service_log_s_log;
      if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_ERROR))
      {
        uint64_t v24 = *(void *)(a1 + 40);
        *(_DWORD *)__int128 buf = 138412290;
        uint64_t v31 = v24;
        uint64_t v12 = "DoH resolver for %@ missing DoH template";
        CFIndex v13 = (os_log_s *)v15;
        uint32_t v14 = 12;
        goto LABEL_29;
      }
    }
  }

  http_task_cancel(*(void **)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL));
  os_release(*(void **)(a1 + 48));
  nw_release(*(void **)(a1 + 40));
}

uint64_t ___mdns_dns_service_manager_fetch_doh_pvd_block_invoke_85(void *a1, int a2, xpc_object_t object)
{
  if (xpc_get_type(object) == (xpc_type_t)&_xpc_type_string)
  {
    string_ptr = xpc_string_get_string_ptr(object);
    if (_mdns_dns_service_log_s_once != -1) {
      dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_62);
    }
    uint64_t v7 = (os_log_s *)_mdns_dns_service_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v8 = a1[4];
      *(_DWORD *)__int128 buf = 136315394;
      *(void *)&uint8_t buf[4] = string_ptr;
      *(_WORD *)&buf[12] = 2112;
      *(void *)&buf[14] = v8;
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "Query trusted name %s for DoH resolver for %@",  buf,  0x16u);
    }

    uint64_t v9 = (void *)a1[6];
    if (v9)
    {
      if (string_ptr)
      {
        uint64_t v10 = (void *)a1[4];
        if (v10)
        {
          uint64_t v11 = (void *)a1[5];
          if (xpc_get_type(v9) == (xpc_type_t)&_xpc_type_array)
          {
            int v21 = 0LL;
            asprintf(&v21, ".%s", string_ptr);
            xpc_object_t v12 = xpc_array_create(0LL, 0LL);
            applier[0] = _NSConcreteStackBlock;
            applier[1] = 0x40000000LL;
            applier[2] = ___mdns_dns_service_manager_fetch_trusted_name_pvd_block_invoke;
            applier[3] = &__block_descriptor_tmp_93;
            void applier[4] = string_ptr;
            void applier[5] = v12;
            applier[6] = v21;
            xpc_array_apply(v9, applier);
            if (v21)
            {
              free(v21);
              int v21 = 0LL;
            }

            if (xpc_array_get_count(v12))
            {
              uint64_t v16 = 0LL;
              uint64_t v17 = &v16;
              uint64_t v18 = 0x2000000000LL;
              uint64_t v19 = 0LL;
              nw_retain(v10);
              os_retain(v11);
              nw_endpoint_t host = nw_endpoint_create_host(string_ptr, "443");
              if (_mdns_dns_service_queue_s_once != -1) {
                dispatch_once(&_mdns_dns_service_queue_s_once, &__block_literal_global_237);
              }
              *(void *)__int128 buf = _NSConcreteStackBlock;
              *(void *)&uint8_t buf[8] = 0x40000000LL;
              *(void *)&uint8_t buf[16] = ___mdns_dns_service_manager_fetch_trusted_name_pvd_block_invoke_2;
              int v23 = &unk_10013A9B8;
              uint64_t v26 = v10;
              xpc_object_t v27 = v12;
              __int128 v28 = v11;
              uint64_t v24 = &v16;
              nw_endpoint_t v25 = host;
              pvd_query = http_task_create_pvd_query( (void *)_mdns_dns_service_queue_s_queue,  (uint64_t)string_ptr,  (uint64_t)"",  buf);
              v17[3] = (uint64_t)pvd_query;
              uint64_t v15 = objc_autoreleasePoolPush();
              [pvd_query resume];
              objc_autoreleasePoolPop(v15);
              _Block_object_dispose(&v16, 8);
            }

            else if (v12)
            {
              xpc_release(v12);
            }
          }
        }
      }
    }
  }

  return 1LL;
}

uint64_t ___mdns_dns_service_manager_fetch_trusted_name_pvd_block_invoke( uint64_t a1, int a2, xpc_object_t object)
{
  if (xpc_get_type(object) == (xpc_type_t)&_xpc_type_string)
  {
    string_ptr = xpc_string_get_string_ptr(object);
    if (!strcasecmp(*(const char **)(a1 + 32), string_ptr)
      || (size_t v6 = strlen(*(const char **)(a1 + 48)), v7 = strlen(string_ptr), v7 >= v6)
      && !strcasecmp(*(const char **)(a1 + 48), &string_ptr[v7 - v6]))
    {
      xpc_array_append_value(*(xpc_object_t *)(a1 + 40), object);
    }
  }

  return 1LL;
}

void ___mdns_dns_service_manager_fetch_trusted_name_pvd_block_invoke_2(uint64_t a1, xpc_object_t xdict)
{
  if (xdict)
  {
    string = xpc_dictionary_get_string(xdict, "dohTemplate");
    if (string)
    {
      uint64_t v4 = string;
      nw_endpoint_t url = nw_endpoint_get_url(*(nw_endpoint_t *)(a1 + 48));
      if (url && !strcasecmp(v4, url))
      {
        if (_mdns_dns_service_log_s_once != -1) {
          dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_62);
        }
        uint64_t v17 = (os_log_s *)_mdns_dns_service_log_s_log;
        if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v19 = *(const char **)(a1 + 40);
          uint64_t v18 = *(void *)(a1 + 48);
          *(_DWORD *)__int128 buf = 138412546;
          uint64_t v25 = v18;
          __int16 v26 = 2112;
          xpc_object_t v27 = v19;
          _os_log_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_DEFAULT,  "DoH resolver at %@ is trusted for %@",  buf,  0x16u);
        }

        v23[0] = _NSConcreteStackBlock;
        v23[1] = 0x40000000LL;
        v23[2] = ___mdns_dns_service_manager_fetch_trusted_name_pvd_block_invoke_95;
        v23[3] = &__block_descriptor_tmp_96;
        uint64_t v20 = *(void **)(a1 + 56);
        uint64_t v21 = *(void *)(a1 + 64);
        v23[4] = *(void *)(a1 + 48);
        void v23[5] = v21;
        xpc_array_apply(v20, v23);
      }

      else
      {
        if (_mdns_dns_service_log_s_once != -1) {
          dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_62);
        }
        uint64_t v6 = _mdns_dns_service_log_s_log;
        if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_ERROR))
        {
          uint64_t v8 = *(void *)(a1 + 40);
          uint64_t v7 = *(void *)(a1 + 48);
          *(_DWORD *)__int128 buf = 138412802;
          uint64_t v25 = v7;
          __int16 v26 = 2080;
          xpc_object_t v27 = v4;
          __int16 v28 = 2112;
          uint64_t v29 = v8;
          uint64_t v9 = "DoH resolver for %@ does not match trusted DoH template %s for %@";
          uint64_t v10 = (os_log_s *)v6;
          uint32_t v11 = 32;
LABEL_17:
          _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, v9, buf, v11);
        }
      }
    }

    else
    {
      if (_mdns_dns_service_log_s_once != -1) {
        dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_62);
      }
      uint64_t v15 = _mdns_dns_service_log_s_log;
      if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_ERROR))
      {
        uint64_t v16 = *(void *)(a1 + 40);
        *(_DWORD *)__int128 buf = 138412290;
        uint64_t v25 = v16;
        uint64_t v9 = "Trusted name %@ missing DoH template";
        uint64_t v10 = (os_log_s *)v15;
        uint32_t v11 = 12;
        goto LABEL_17;
      }
    }
  }

  else
  {
    if (_mdns_dns_service_log_s_once != -1) {
      dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_62);
    }
    uint64_t v12 = _mdns_dns_service_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_ERROR))
    {
      uint64_t v13 = *(void *)(a1 + 40);
      uint32_t v14 = *(const char **)(a1 + 48);
      *(_DWORD *)__int128 buf = 138412546;
      uint64_t v25 = v13;
      __int16 v26 = 2112;
      xpc_object_t v27 = v14;
      uint64_t v9 = "No PvD file found at %@ for DoH server %@";
      uint64_t v10 = (os_log_s *)v12;
      uint32_t v11 = 22;
      goto LABEL_17;
    }
  }

  http_task_cancel(*(void **)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL));
  nw_release(*(void **)(a1 + 40));
  nw_release(*(void **)(a1 + 48));
  xpc_object_t v22 = *(void **)(a1 + 56);
  if (v22) {
    xpc_release(v22);
  }
  os_release(*(void **)(a1 + 64));
}

uint64_t ___mdns_dns_service_manager_fetch_trusted_name_pvd_block_invoke_95( uint64_t a1, int a2, xpc_object_t xstring)
{
  string_ptr = (char *)xpc_string_get_string_ptr(xstring);
  if (_mdns_dns_service_log_s_once != -1) {
    dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_62);
  }
  uint64_t v5 = (os_log_s *)_mdns_dns_service_log_s_log;
  if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v6 = *(void *)(a1 + 32);
    int v8 = 136315394;
    uint64_t v9 = string_ptr;
    __int16 v10 = 2112;
    uint64_t v11 = v6;
    _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "Adding domain %s to discovered DoH resolver for %@",  (uint8_t *)&v8,  0x16u);
  }

  _mdns_dns_service_add_domain_by_string(*(void *)(a1 + 40), string_ptr, 0);
  return 1LL;
}

void ___mdns_get_future_continuous_time_block_invoke(id a1)
{
}

uint64_t mdns_dns_service_manager_register_discovered_push_service( uint64_t a1, uint64_t a2, int a3, uint64_t a4, _DWORD *a5)
{
  uint64_t v20 = 0LL;
  uint64_t v21 = &v20;
  uint64_t v22 = 0x2000000000LL;
  int v23 = 0;
  uint64_t v16 = 0LL;
  uint64_t v17 = &v16;
  uint64_t v18 = 0x2000000000LL;
  uint64_t v19 = 0LL;
  if (_mdns_dns_service_queue_s_once != -1) {
    dispatch_once(&_mdns_dns_service_queue_s_once, &__block_literal_global_237);
  }
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000LL;
  block[2] = __mdns_dns_service_manager_register_discovered_push_service_block_invoke;
  block[3] = &unk_10013A200;
  void block[4] = &v16;
  void block[5] = &v20;
  block[6] = a1;
  void block[7] = a2;
  char v15 = 2;
  int v13 = a3;
  int v14 = 30000;
  block[8] = a4;
  dispatch_sync((dispatch_queue_t)_mdns_dns_service_queue_s_queue, block);
  if (a5) {
    *a5 = *((_DWORD *)v21 + 6);
  }
  uint64_t v10 = v17[3];
  _Block_object_dispose(&v16, 8);
  _Block_object_dispose(&v20, 8);
  return v10;
}

void __mdns_dns_service_manager_register_discovered_push_service_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 48);
  if (*(_BYTE *)(v2 + 131))
  {
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 0LL;
    *(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = -6752;
    return;
  }

  int v3 = *(void **)(a1 + 56);
  char v4 = *(_BYTE *)(a1 + 80);
  unsigned int v6 = *(_DWORD *)(a1 + 72);
  int v5 = *(_DWORD *)(a1 + 76);
  uint64_t v7 = *(void *)(*(void *)(a1 + 40) + 8LL);
  int v18 = 0;
  uint64_t discovered_push_service = _mdns_dns_service_manager_get_discovered_push_service( *(const __CFArray **)(v2 + 64),  (uint64_t)v3,  v6);
  uint64_t v9 = discovered_push_service;
  if (discovered_push_service)
  {
    _mdns_dns_service_increment_use_count(discovered_push_service);
    uint64_t v10 = *(void *)(v9 + 24);
    if (_mdns_dns_service_log_s_once != -1) {
      dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_62);
    }
    uint64_t v11 = (os_log_s *)_mdns_dns_service_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 134217984;
      uint64_t v20 = v10;
      _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "Re-registered discovered push service -- id: %llu",  buf,  0xCu);
    }

    int v12 = 0;
    goto LABEL_9;
  }

  int v14 = mdns_dns_push_service_definition_create();
  if (!v14)
  {
    uint64_t v10 = 0LL;
    int v12 = -6729;
LABEL_9:
    BOOL v13 = v9 != 0;
    *(_DWORD *)(v7 + memset(&v5[1], 0, 24) = v12;
    goto LABEL_12;
  }

  uint64_t v15 = (uint64_t)v14;
  mdns_dns_push_service_definition_set_srv_name((uint64_t)v14, v3);
  mdns_dns_push_service_definition_set_interface_index(v15, v6, v4);
  *(_WORD *)(v15 + 79) = 1;
  uint64_t v10 = _mdns_dns_service_manager_register_push_service_internal_from_definition( (CFArrayRef *)v2,  *(__CFArray **)(v2 + 64),  v15,  v5,  0LL,  0LL,  &v18);
  *(_DWORD *)(v7 + memset(&v5[1], 0, 24) = v18;
  os_release((void *)v15);
  BOOL v13 = 0;
LABEL_12:
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = v10;
  if (!v13)
  {
    if (*(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL))
    {
      uint64_t v16 = *(dispatch_source_s **)(*(void *)(a1 + 48) + 96LL);
      if (v16) {
        dispatch_source_merge_data(v16, 1uLL);
      }
    }
  }

  uint64_t v17 = *(_BYTE **)(a1 + 64);
  if (v17) {
    _BYTE *v17 = v13;
  }
}

uint64_t _mdns_dns_service_manager_get_discovered_push_service(const __CFArray *a1, uint64_t a2, int a3)
{
  uint64_t v5 = 0LL;
  unsigned int v6 = &v5;
  uint64_t v7 = 0x2000000000LL;
  uint64_t v8 = 0LL;
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 0x40000000LL;
  v9[2] = ___mdns_dns_service_manager_get_discovered_push_service_block_invoke;
  v9[3] = &unk_10013AE48;
  int v10 = a3;
  uint64_t v11 = 0LL;
  int v12 = 0;
  BOOL v13 = a3 != 0;
  __int16 v14 = 0;
  char v15 = 0;
  v9[4] = &v5;
  void v9[5] = a2;
  mdns_cfarray_enumerate(a1, (uint64_t)v9);
  uint64_t v3 = v6[3];
  _Block_object_dispose(&v5, 8);
  return v3;
}

BOOL ___mdns_dns_service_manager_get_discovered_push_service_block_invoke(uint64_t a1, uint64_t a2)
{
  if (_mdns_dns_service_scope_id_match(a2, a1 + 48)
    && _mdns_domain_name_equal(*(void *)(a2 + 216), *(void *)(a1 + 40)))
  {
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = a2;
  }

  return *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) == 0LL;
}

void __mdns_dns_service_manager_terminate_discovered_push_service_block_invoke(void *a1)
{
  uint64_t v2 = a1[5];
  if (*(_BYTE *)(v2 + 131))
  {
    int v3 = -6752;
  }

  else
  {
    CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(v2 + 64));
    if (Count < 1)
    {
LABEL_7:
      int v3 = -6727;
    }

    else
    {
      CFIndex v5 = Count;
      CFIndex v6 = 0LL;
      while (1)
      {
        uint64_t ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1[5] + 64LL), v6);
        if (ValueAtIndex[3] == a1[6]) {
          break;
        }
        if (v5 == ++v6) {
          goto LABEL_7;
        }
      }

      _mdns_dns_service_manager_terminate_service(a1[5], (uint64_t)ValueAtIndex);
      CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(a1[5] + 64LL), v6);
      uint64_t v8 = *(dispatch_source_s **)(a1[5] + 96LL);
      if (v8) {
        dispatch_source_merge_data(v8, 1uLL);
      }
      int v3 = 0;
    }
  }

  *(_DWORD *)(*(void *)(a1[4] + 8LL) + 24LL) = v3;
}

void __mdns_dns_service_manager_invalidate_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (!*(_BYTE *)(v2 + 130))
  {
    _mdns_dns_service_manager_terminate(v2, 0);
    *(_BYTE *)(*(void *)(a1 + 32) + 130LL) = 1;
  }

uint64_t __mdns_dns_service_manager_get_unscoped_custom_push_service_block_invoke(void *a1)
{
  uint64_t v2 = a1[5];
  if (*(_BYTE *)(v2 + 131))
  {
    uint64_t result = 0LL;
  }

  else
  {
    int v3 = *(const __CFArray **)(v2 + 72);
    uint64_t v4 = a1[6];
    v7[0] = 0LL;
    v7[1] = 0LL;
    int v8 = 0;
    uint64_t service = _mdns_dns_service_manager_get_service(v3, v4, (uint64_t)v7, 0, 0LL);
    uint64_t result = _mdns_dns_service_manager_prepare_service(a1[5], service);
  }

  *(void *)(*(void *)(a1[4] + 8LL) + 24LL) = result;
  return result;
}

uint64_t _mdns_dns_service_manager_get_service( const __CFArray *a1, uint64_t a2, uint64_t a3, char a4, uint64_t a5)
{
  uint64_t v16 = 0LL;
  uint64_t v17 = &v16;
  uint64_t v18 = 0x2000000000LL;
  uint64_t v19 = 0LL;
  v14[0] = 0LL;
  v14[1] = v14;
  void v14[2] = 0x2000000000LL;
  int v15 = -1;
  v12[0] = 0LL;
  v12[1] = v12;
  v12[2] = 0x2000000000LL;
  int v13 = 0;
  v11[0] = _NSConcreteStackBlock;
  v11[1] = 0x40000000LL;
  _OWORD v11[2] = ___mdns_dns_service_manager_get_service_block_invoke;
  v11[3] = &unk_10013AB30;
  v11[8] = a3;
  v11[9] = a2;
  void v11[4] = a5;
  void v11[5] = v14;
  v11[6] = v12;
  v11[7] = &v16;
  mdns_cfarray_enumerate(a1, (uint64_t)v11);
  CFIndex v6 = v17;
  if ((a4 & 1) != 0)
  {
    uint64_t v7 = v17[3];
    if (v7)
    {
      uint64_t preferred_encrypted_alt = _mdns_dns_service_get_preferred_encrypted_alt(v7, (a4 & 2) != 0);
      CFIndex v6 = v17;
      if (preferred_encrypted_alt) {
        v17[3] = preferred_encrypted_alt;
      }
    }
  }

  uint64_t v9 = v6[3];
  _Block_object_dispose(v12, 8);
  _Block_object_dispose(v14, 8);
  _Block_object_dispose(&v16, 8);
  return v9;
}

uint64_t _mdns_dns_service_manager_prepare_service(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a2;
  if (!a2) {
    return v2;
  }
  int v3 = *(unsigned __int8 *)(a2 + 281);
  if (v3 != 5)
  {
    if (*(void *)(a2 + 64)) {
      return v2;
    }
    if ((v3 - 3) < 2)
    {
      uint64_t v16 = *(unsigned int *)(a2 + 256);
      uint64_t v21 = _os_object_alloc(&OBJC_CLASS___OS_mdns_resolver, 232LL);
      if (!v21) {
        goto LABEL_177;
      }
      uint64_t v18 = v21;
      uint64_t v22 = &_mdns_https_resolver_kind;
      *(void *)(v21 + 16) = &_mdns_https_resolver_kind;
      do
      {
        int v23 = (void (*)(uint64_t))v22[2];
        if (v23) {
          v23(v18);
        }
        uint64_t v22 = (_UNKNOWN **)*v22;
      }

      while (v22);
    }

    else
    {
      if (v3 == 1)
      {
        uint64_t v16 = *(unsigned int *)(a2 + 256);
        uint64_t v33 = _os_object_alloc(&OBJC_CLASS___OS_mdns_resolver, 160LL);
        if (!v33) {
          goto LABEL_177;
        }
        uint64_t v18 = v33;
        CFIndex v34 = &_mdns_normal_resolver_kind;
        *(void *)(v33 + 16) = &_mdns_normal_resolver_kind;
        do
        {
          uint64_t v35 = (void (*)(uint64_t))v34[2];
          if (v35) {
            v35(v18);
          }
          CFIndex v34 = (_UNKNOWN **)*v34;
        }

        while (v34);
        int v24 = 0;
        goto LABEL_53;
      }

      if (v3 != 2)
      {
LABEL_168:
        if (_mdns_dns_service_log_s_once != -1) {
          dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_62);
        }
        uint64_t v81 = (os_log_s *)_mdns_dns_service_log_s_log;
        if (!os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_ERROR)) {
          return 0LL;
        }
        uint64_t v83 = *(void *)(v2 + 24);
        LODWORD(aBlock) = 134217984;
        *(void *)((char *)&aBlock + 4) = v83;
        uint64_t v84 = "Failed to prepare resolver -- service id: %llu";
        goto LABEL_175;
      }

      uint64_t v16 = *(unsigned int *)(a2 + 256);
      uint64_t v17 = _os_object_alloc(&OBJC_CLASS___OS_mdns_resolver, 184LL);
      if (!v17) {
        goto LABEL_177;
      }
      uint64_t v18 = v17;
      uint64_t v19 = &_mdns_tls_resolver_kind;
      *(void *)(v17 + 16) = &_mdns_tls_resolver_kind;
      do
      {
        uint64_t v20 = (void (*)(uint64_t))v19[2];
        if (v20) {
          v20(v18);
        }
        uint64_t v19 = (_UNKNOWN **)*v19;
      }

      while (v19);
    }

    int v24 = 1;
LABEL_53:
    CFMutableArrayRef Mutable = CFArrayCreateMutable(0LL, 0LL, (const CFArrayCallBacks *)&mdns_cfarray_callbacks);
    *(void *)(v18 + 56) = Mutable;
    if (Mutable)
    {
      if (!(_DWORD)v16 || (uint64_t v37 = nw_interface_create_with_index(v16), (*(void *)(v18 + 48) = v37) != 0LL))
      {
        uint64_t v38 = *(void *)(v2 + 96);
        if (v38)
        {
          uint64_t provider_name = nw_resolver_config_get_provider_name(v38);
          uint64_t provider_path = nw_resolver_config_get_provider_path(*(void *)(v2 + 96));
          if (!*(_BYTE *)(v18 + 137))
          {
            uint64_t v41 = *(void (**)(uint64_t, uint64_t))(*(void *)(v18 + 16) + 56LL);
            if (!v41 || (v41(v18, provider_name), !*(_BYTE *)(v18 + 137)))
            {
              uint64_t v42 = *(void (**)(uint64_t, uint64_t))(*(void *)(v18 + 16) + 80LL);
              if (v42) {
                v42(v18, provider_path);
              }
            }
          }

          uint64_t v95 = 0LL;
          uint64_t identity_reference = nw_resolver_config_get_identity_reference(*(void *)(v2 + 96), &v95);
          if (identity_reference)
          {
            if (*(_BYTE *)(v18 + 137)
              || (uint64_t v44 = *(unsigned int (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v18 + 16) + 88LL)) != 0LL
              && v44(v18, identity_reference, v95))
            {
              if (_mdns_dns_service_log_s_once != -1) {
                dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_62);
              }
              int v45 = (os_log_s *)_mdns_dns_service_log_s_log;
              if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_ERROR))
              {
                uint64_t v85 = *(void *)(v2 + 24);
                *(_DWORD *)__int128 buf = 134217984;
                *(void *)&uint8_t buf[4] = v85;
                _os_log_error_impl( (void *)&_mh_execute_header,  v45,  OS_LOG_TYPE_ERROR,  "Failed to set identity reference for service -- service id: %llu",  buf,  0xCu);
              }
            }
          }

          if (nw_resolver_config_get_protocol(*(void *)(v2 + 96)) == 3)
          {
            uint64_t v94 = 0LL;
            uint64_t odoh_config = nw_resolver_config_get_odoh_config(*(void *)(v2 + 96), &v94);
            uint64_t v47 = nw_resolver_config_copy_proxy_config(*(void *)(v2 + 96));
            __int128 v48 = (void *)v47;
            if (v47) {
              nw_proxy_config_set_prohibit_direct(v47, 1LL);
            }
            if (_mdns_dns_service_log_s_once != -1) {
              dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_62);
            }
            __int128 v49 = (os_log_s *)_mdns_dns_service_log_s_log;
            if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)__int128 buf = 138412290;
              *(void *)&uint8_t buf[4] = v48;
              _os_log_impl( (void *)&_mh_execute_header,  v49,  OS_LOG_TYPE_DEFAULT,  "Resolver proxy config: %@",  buf,  0xCu);
            }

            if (v50) {
              v50(v18, provider_name, provider_path, odoh_config, v94, v48);
            }
            if (v48) {
              nw_release(v48);
            }
            if (*(_BYTE *)(a1 + 129))
            {
              if (*(_BYTE *)(v2 + 282) != 4)
              {
                *(_WORD *)(v2 + 276) |= 0x1000u;
                if (!*(_BYTE *)(v18 + 137)) {
                  *(_BYTE *)(v18 + 140) = 1;
                }
              }
            }
          }
        }

        if (*(void *)(v2 + 176))
        {
          if (!*(_BYTE *)(v18 + 137))
          {
            __int128 v51 = *(void (**)(uint64_t))(*(void *)(v18 + 16) + 64LL);
            if (v51) {
              v51(v18);
            }
          }
        }

        if (*(_WORD *)(v2 + 278))
        {
          if (!*(_BYTE *)(v18 + 137))
          {
            __int128 v52 = *(void (**)(uint64_t))(*(void *)(v18 + 16) + 72LL);
            if (v52) {
              v52(v18);
            }
          }
        }

        if (!*(_BYTE *)(v2 + 56) || *(_BYTE *)(v18 + 137))
        {
          BOOL v53 = *(unsigned __int8 *)(v18 + 137) != 0;
          if (*(_BYTE *)(v18 + 137)) {
            goto LABEL_108;
          }
        }

        else
        {
          BOOL v53 = 0;
          *(_BYTE *)(v18 + 133) = 1;
        }

        if ((*(_WORD *)(v2 + 276) & 8) != 0) {
          int v54 = 2000;
        }
        else {
          int v54 = 1000;
        }
        *(_DWORD *)(v18 + 1memset(&v5[1], 0, 24) = v54;
        *(_BYTE *)(v18 + 132) = *(_BYTE *)(a1 + 128);
        if (((v24 | v53) & 1) == 0)
        {
          *(_BYTE *)(v18 + 13_Block_object_dispose(va, 8) = 1;
          int v55 = *(_DWORD *)(a1 + 120);
          else {
            int v56 = *(_DWORD *)(a1 + 120);
          }
          if (v55 <= 0) {
            int v57 = 0;
          }
          else {
            int v57 = v56;
          }
          *(_DWORD *)(v18 + 12_Block_object_dispose(va, 8) = v57;
        }

LABEL_167:
    if (*(void *)(v2 + 64)) {
      return v2;
    }
    goto LABEL_168;
  }

  if (*(void *)(a2 + 72)) {
    return v2;
  }
  uint64_t v4 = mdns_push_server_create();
  *(void *)(v2 + 72) = v4;
  if (!v4) {
    goto LABEL_182;
  }
  CFIndex v5 = *(const __CFArray **)(v2 + 232);
  if (v5)
  {
    CFIndex v6 = CFArrayGetCount(v5);
    if (v6 >= 1)
    {
      CFIndex v7 = v6;
      for (CFIndex i = 0LL; i != v7; ++i)
      {
        uint64_t v9 = CFArrayGetValueAtIndex(*(CFArrayRef *)(v2 + 232), i);
        uint64_t v10 = *(void *)(v2 + 72);
        if (!*(_BYTE *)(v10 + 103)) {
          CFArrayAppendValue(*(CFMutableArrayRef *)(v10 + 72), v9);
        }
      }
    }
  }

  uint64_t v11 = *(void *)(v2 + 72);
  if (!*(_BYTE *)(v11 + 103))
  {
    unsigned int v12 = *(_DWORD *)(v2 + 256);
    if (*(_DWORD *)(v11 + 96) != v12)
    {
      *(_DWORD *)(v11 + 96) = v12;
      if (*(void *)(v11 + 56))
      {
        free(*(void **)(v11 + 56));
        *(void *)(v11 + 56) = 0LL;
        unsigned int v12 = *(_DWORD *)(v11 + 96);
      }
    }

    if (v12 && !*(void *)(v11 + 56)) {
      *(void *)(v11 + 56) = mdns_system_interface_index_to_name(v12);
    }
  }

  int v13 = *(const __CFArray **)(v2 + 80);
  if (v13 && CFArrayGetCount(v13) >= 1)
  {
    __int16 v14 = *(const __CFArray **)(v2 + 80);
    *(void *)&aBlocuint64_t k = _NSConcreteStackBlock;
    *((void *)&aBlock + 1) = 0x40000000LL;
    uint64_t v97 = ___mdns_dns_service_manager_prepare_push_service_block_invoke;
    uint64_t v98 = &__block_descriptor_tmp_232;
    uint64_t v99 = v2;
    mdns_cfarray_enumerate(v14, (uint64_t)&aBlock);
    goto LABEL_39;
  }

  uint64_t v25 = *(void **)(v2 + 216);
  uint64_t v26 = *(void *)(v2 + 72);
  if (!v25)
  {
    if (v26) {
      return v2;
    }
LABEL_182:
    if (_mdns_dns_service_log_s_once != -1) {
      dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_62);
    }
    uint64_t v81 = (os_log_s *)_mdns_dns_service_log_s_log;
    if (!os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_ERROR)) {
      return 0LL;
    }
    uint64_t v91 = *(void *)(v2 + 24);
    LODWORD(aBlock) = 134217984;
    *(void *)((char *)&aBlock + 4) = v91;
    uint64_t v84 = "Failed to prepare push server -- service id: %llu";
LABEL_175:
    _os_log_error_impl((void *)&_mh_execute_header, v81, OS_LOG_TYPE_ERROR, v84, (uint8_t *)&aBlock, 0xCu);
    return 0LL;
  }

  mdns_push_server_set_srv_name(v26, v25);
LABEL_39:
  uint64_t v27 = *(void *)(v2 + 240);
  if (v27)
  {
    __int16 v28 = *(const void **)(v2 + 248);
    if (v28)
    {
      uint64_t v29 = *(void *)(v2 + 72);
      dispatch_retain(*(dispatch_object_t *)(v2 + 240));
      uint64_t v30 = _Block_copy(v28);
      uint64_t v31 = *(dispatch_object_s **)(v29 + 80);
      if (v31) {
        dispatch_release(v31);
      }
      *(void *)(v29 + 80) = v27;
      __int16 v32 = *(const void **)(v29 + 88);
      if (v32) {
        _Block_release(v32);
      }
      *(void *)(v29 + 8_Block_object_dispose(va, 8) = v30;
    }
  }

  *(_BYTE *)(*(void *)(v2 + 72) + 103LL) = 1;
  return v2;
}

    uint64_t v66 = 0;
    goto LABEL_168;
  }

  uint64_t v108 = *(_DWORD *)(v64 + 48);
LABEL_158:
  if (v66 == 3) {
    goto LABEL_159;
  }
LABEL_168:
  uint64_t v108 = 0;
  if (v56 == 2 || v66 == 2)
  {
    nw_endpoint_t v67 = 2;
    uint64_t v30 = 2;
    if ((v63 & 1) != 0) {
      goto LABEL_251;
    }
  }

  else
  {
    int v68 = *(void *)(a1 + 40);
    if (!v68)
    {
      dispatch_source_t v75 = *(void *)(a1 + 32);
      if (!v75) {
        goto LABEL_241;
      }
      unsigned int v76 = *(_DWORD *)(v75 + 40);
      if (v76 != 2 && v76 != 4)
      {
        uint64_t v84 = (os_log_s *)mDNSLogCategory_DNSSEC;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_DNSSEC == mDNSLogCategory_State)
        {
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC, OS_LOG_TYPE_FAULT)) {
            goto LABEL_250;
          }
        }

        else
        {
          uint64_t v84 = (os_log_s *)mDNSLogCategory_DNSSEC_redacted;
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC_redacted, OS_LOG_TYPE_FAULT)) {
            goto LABEL_250;
          }
        }

        *(_DWORD *)__int128 buf = 136447234;
        *(void *)&uint8_t buf[4] = "dnssec_obj_rrset_is_completed(me)";
        *(_WORD *)&buf[12] = 2082;
        CFDataRef v110 = "";
        uint64_t v111 = 2082;
        int v112 = "/Library/Caches/com.apple.xbs/Sources/mDNSResponder/mDNSMacOSX/dnssec_v2/dnssec_objs/dnssec_obj_rrset.c";
        uint64_t v113 = 1024;
        BOOL v114 = 416;
        int v115 = 2048;
        int v116 = 0LL;
        _os_log_impl( (void *)&_mh_execute_header,  v84,  OS_LOG_TYPE_FAULT,  "AssertMacros: %{public}s, %{public}s file: %{public}s, line: %d, value: %ld",  buf,  0x30u);
LABEL_250:
        uint64_t v108 = -6745;
        nw_endpoint_t v67 = 0;
        uint64_t v30 = 0;
        if ((v63 & 1) == 0) {
          goto LABEL_84;
        }
        goto LABEL_251;
      }

      unsigned int v77 = *(void **)(v75 + 24);
      if (!v77) {
        goto LABEL_250;
      }
      while (1)
      {
        CFStringRef v78 = *v77;
        if (*(_WORD *)(*v77 + 4LL) == 46) {
          break;
        }
        unsigned int v77 = (void *)v77[1];
        if (!v77) {
          goto LABEL_250;
        }
      }

      uint64_t v88 = *(_BYTE **)(v78 + 32);
      uint64_t v89 = *v88;
      if (*v88)
      {
        uint32_t v90 = 0LL;
        do
        {
          ++v90;
          uint64_t v91 = &v88[v89];
          uint64_t v92 = v91[1];
          uint64_t v88 = v91 + 1;
          uint64_t v89 = v92;
        }

        while (v92);
      }

      else
      {
        uint32_t v90 = 0LL;
      }

      if (v56 != 1) {
        goto LABEL_241;
      }
LABEL_204:
      uint64_t v108 = 0;
      nw_endpoint_t v67 = 1;
      goto LABEL_251;
    }

    *(_DWORD *)__int128 buf = 0;
    uint64_t denial_of_existence = dnssec_obj_rrset_get_denial_of_existence(v68, (int *)buf);
    if (*(_DWORD *)buf)
    {
      uint64_t v108 = *(_DWORD *)buf;
LABEL_159:
      nw_endpoint_t v67 = 3;
      if (!v63) {
        goto LABEL_263;
      }
      goto LABEL_251;
    }

    uint64_t v70 = *(_DWORD *)(denial_of_existence + 16);
    uint64_t v108 = 0;
    uint64_t v71 = *(void *)(a1 + 32);
    if (v71)
    {
      if (v56 == 1 && v66 == 1)
      {
        uint64_t v72 = *(_DWORD *)(v71 + 40);
        if (v72 == 2 || v72 == 4)
        {
          uint64_t v73 = *(void **)(v71 + 24);
          if (v73)
          {
            while (1)
            {
              uint64_t v74 = *v73;
              if (*(_WORD *)(*v73 + 4LL) == 46) {
                break;
              }
              uint64_t v73 = (void *)v73[1];
              if (!v73) {
                goto LABEL_241;
              }
            }

            dispatch_time_t v79 = *(_BYTE **)(v74 + 32);
            int v80 = *v79;
            if (*v79)
            {
              uint64_t v81 = 0LL;
              do
              {
                ++v81;
                uint64_t v82 = &v79[v80];
                uint64_t v83 = v82[1];
                dispatch_time_t v79 = v82 + 1;
                int v80 = v83;
              }

              while (v83);
            }
          }

          goto LABEL_241;
        }

        uint64_t v85 = (os_log_s *)mDNSLogCategory_DNSSEC;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_DNSSEC == mDNSLogCategory_State)
        {
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC, OS_LOG_TYPE_FAULT))
          {
LABEL_240:
            *(_DWORD *)__int128 buf = 136447234;
            *(void *)&uint8_t buf[4] = "dnssec_obj_rrset_is_completed(me)";
            *(_WORD *)&buf[12] = 2082;
            CFDataRef v110 = "";
            uint64_t v111 = 2082;
            int v112 = "/Library/Caches/com.apple.xbs/Sources/mDNSResponder/mDNSMacOSX/dnssec_v2/dnssec_objs/dnssec_obj_rrset.c";
            uint64_t v113 = 1024;
            BOOL v114 = 396;
            int v115 = 2048;
            int v116 = 0LL;
            _os_log_impl( (void *)&_mh_execute_header,  v85,  OS_LOG_TYPE_FAULT,  "AssertMacros: %{public}s, %{public}s file: %{public}s, line: %d, value: %ld",  buf,  0x30u);
          }
        }

        else
        {
          uint64_t v85 = (os_log_s *)mDNSLogCategory_DNSSEC_redacted;
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC_redacted, OS_LOG_TYPE_FAULT)) {
            goto LABEL_240;
          }
        }

void ___mdns_dns_service_manager_prepare_resolver_block_invoke(void *a1, int a2, xpc_object_t xdict)
{
  uint64_t v4 = (void *)a1[4];
  uint64_t v3 = a1[5];
  CFIndex v5 = (char *)a1[6];
  switch(a2)
  {
    case 1:
      if (_mdns_dns_service_log_s_once != -1) {
        dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_62);
      }
      unsigned int v12 = (os_log_s *)_mdns_dns_service_log_s_log;
      if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_INFO))
      {
        int v13 = *(const char **)(v3 + 24);
        int v31 = 134218242;
        __int16 v32 = v13;
        __int16 v33 = 2112;
        CFIndex v34 = v5;
        _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_INFO,  "Resolver has been invalidated -- service id: %llu, resolver: %@",  (uint8_t *)&v31,  0x16u);
      }

      os_release(v5);
      os_release((void *)v3);
      os_release(v4);
      break;
    case 3:
      int int64 = xpc_dictionary_get_int64(xdict, "error_code");
      if (*(_BYTE *)(v3 + 282) == 4)
      {
        if (int64 == -6736)
        {
          if (_mdns_dns_service_log_s_once != -1) {
            dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_62);
          }
          int v15 = (os_log_s *)_mdns_dns_service_log_s_log;
          if (!os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_ERROR)) {
            return;
          }
          int v24 = *(const char **)(v3 + 24);
          int v31 = 134217984;
          __int16 v32 = v24;
          uint64_t v17 = "Received unexpected error for discovered service id: %llu";
        }

        else
        {
          if (_mdns_dns_service_log_s_once != -1) {
            dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_62);
          }
          int v15 = (os_log_s *)_mdns_dns_service_log_s_log;
          if (!os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_ERROR)) {
            return;
          }
          uint64_t v16 = *(const char **)(v3 + 24);
          int v31 = 134217984;
          __int16 v32 = v16;
          uint64_t v17 = "Received authentication error for discovered service id: %llu";
        }

        _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, v17, (uint8_t *)&v31, 0xCu);
        return;
      }

      if (!*(void *)(v3 + 96)) {
        return;
      }
      if (int64)
      {
        if (int64 == -6736)
        {
          if (_mdns_dns_service_log_s_once != -1) {
            dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_62);
          }
          uint64_t v27 = (os_log_s *)_mdns_dns_service_log_s_log;
          if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_ERROR))
          {
            uint64_t v30 = *(const char **)(v3 + 24);
            int v31 = 134217984;
            __int16 v32 = v30;
            _os_log_error_impl( (void *)&_mh_execute_header,  v27,  OS_LOG_TYPE_ERROR,  "Reporting EBADMSG error for service id: %llu",  (uint8_t *)&v31,  0xCu);
          }

          uint64_t v21 = *(void *)(v3 + 96);
          uint64_t v22 = 94LL;
        }

        else
        {
          if (_mdns_dns_service_log_s_once != -1) {
            dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_62);
          }
          uint64_t v20 = (os_log_s *)_mdns_dns_service_log_s_log;
          if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_ERROR))
          {
            uint64_t v29 = *(const char **)(v3 + 24);
            int v31 = 134217984;
            __int16 v32 = v29;
            _os_log_error_impl( (void *)&_mh_execute_header,  v20,  OS_LOG_TYPE_ERROR,  "Reporting EAUTH error for service id: %llu",  (uint8_t *)&v31,  0xCu);
          }

          uint64_t v21 = *(void *)(v3 + 96);
          uint64_t v22 = 80LL;
        }
      }

      else
      {
        if (_mdns_dns_service_log_s_once != -1) {
          dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_62);
        }
        uint64_t v25 = (os_log_s *)_mdns_dns_service_log_s_log;
        if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_INFO))
        {
          uint64_t v26 = *(const char **)(v3 + 24);
          int v31 = 134217984;
          __int16 v32 = v26;
          _os_log_impl( (void *)&_mh_execute_header,  v25,  OS_LOG_TYPE_INFO,  "Reporting success for service id: %llu",  (uint8_t *)&v31,  0xCu);
        }

        uint64_t v21 = *(void *)(v3 + 96);
        uint64_t v22 = 0LL;
      }

      nw_resolver_config_report_error(v21, v22);
      break;
    case 2:
      if (xdict && *(char **)(v3 + 64) == v5)
      {
        BOOL v8 = xpc_dictionary_get_BOOL(xdict, "cannot_connect");
        if (_mdns_dns_service_log_s_once != -1) {
          dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_62);
        }
        uint64_t v9 = (os_log_s *)_mdns_dns_service_log_s_log;
        if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v10 = "";
          uint64_t v11 = *(const char **)(v3 + 24);
          int v31 = 136446722;
          if (v8) {
            uint64_t v10 = "not";
          }
          __int16 v32 = v10;
          __int16 v33 = 2048;
          CFIndex v34 = v11;
          __int16 v35 = 2112;
          int v36 = v5;
          _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEFAULT,  "Resolver can%{public}s connect -- service id: %llu, resolver: %@",  (uint8_t *)&v31,  0x20u);
        }

        if (v8)
        {
          if (*(_BYTE *)(v3 + 283)) {
            return;
          }
          *(_BYTE *)(v3 + 283) = 1;
        }

        else
        {
          if (!*(_BYTE *)(v3 + 283)) {
            return;
          }
          *(_BYTE *)(v3 + 283) = 0;
        }

        uint64_t v19 = (dispatch_source_s *)v4[12];
        if (v19) {
          dispatch_source_merge_data(v19, 1uLL);
        }
      }

      break;
    default:
      if (_mdns_dns_service_log_s_once != -1) {
        dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_62);
      }
      if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_DEBUG))
      {
        if (xdict)
        {
          uint64_t v18 = xpc_copy_description(xdict);
          if (_mdns_dns_service_log_s_once != -1) {
            dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_62);
          }
        }

        else
        {
          uint64_t v18 = 0LL;
        }

        int v23 = (os_log_s *)_mdns_dns_service_log_s_log;
        if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_DEBUG))
        {
          __int16 v28 = "<invalid event value>";
          int v31 = 138412802;
          __int16 v32 = (const char *)v3;
          if (!a2) {
            __int16 v28 = "null";
          }
          __int16 v33 = 2080;
          CFIndex v34 = v28;
          __int16 v35 = 2082;
          int v36 = v18;
          _os_log_debug_impl( (void *)&_mh_execute_header,  v23,  OS_LOG_TYPE_DEBUG,  "DNS service (%@) got unhandled event: %s info: %{public}s",  (uint8_t *)&v31,  0x20u);
          if (!v18) {
            return;
          }
        }

        else if (!v18)
        {
          return;
        }

        free(v18);
      }

      break;
  }

void ___mdns_dns_service_manager_schedule_ddr_probe_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 32);
  uint64_t v2 = *(void *)(a1 + 40);
  _mdns_dns_service_forget_all_ddr_queriers(v2);
  _mdns_dns_service_manager_start_ddr_querier_ex(v1, v2, 0LL);
}

void _mdns_dns_service_manager_start_ddr_querier_ex(void *a1, uint64_t a2, char *a3)
{
  uint64_t v4 = *(void **)(a2 + 64);
  if (v4)
  {
    if (a3 && !*(void *)(a2 + 192))
    {
      CFMutableArrayRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0LL, (const CFArrayCallBacks *)&mdns_cfarray_callbacks);
      *(void *)(a2 + 192) = Mutable;
      if (!Mutable) {
        return;
      }
      uint64_t v4 = *(void **)(a2 + 64);
    }

    uint64_t querier = mdns_resolver_create_querier(v4);
    if (querier)
    {
      uint64_t v15 = querier;
      ++*(_DWORD *)(a2 + 268);
      mdns_querier_set_log_label(querier, "S%llu.DDR%u", v9, v10, v11, v12, v13, v14, *(void *)(a2 + 24));
      if (_mdns_dns_service_queue_s_once != -1) {
        dispatch_once(&_mdns_dns_service_queue_s_once, &__block_literal_global_237);
      }
      mdns_client_set_queue(v15, (dispatch_object_t)_mdns_dns_service_queue_s_queue);
      if (a3) {
        uint64_t v16 = a3;
      }
      else {
        uint64_t v16 = "\x04_dns\bresolver\x04arpa";
      }
      mdns_querier_set_query(v15, v16, 64LL);
      if (!*(_BYTE *)(v15 + 49)) {
        *(_DWORD *)(v15 + 236) = -1;
      }
      if (a3)
      {
        CFArrayAppendValue(*(CFMutableArrayRef *)(a2 + 192), (const void *)v15);
      }

      else
      {
        uint64_t v17 = *(void *)(a2 + 184);
        if (v17)
        {
          mdns_client_invalidate(v17);
          os_release(*(void **)(a2 + 184));
        }

        *(void *)(a2 + 184) = v15;
        os_retain((void *)v15);
      }

      os_retain(a1);
      os_retain((void *)a2);
      aBlock[0] = _NSConcreteStackBlock;
      aBlock[1] = 0x40000000LL;
      aBlock[2] = ___mdns_dns_service_manager_start_ddr_querier_ex_block_invoke;
      aBlock[3] = &__block_descriptor_tmp_206;
      aBlock[4] = a2;
      aBlock[5] = v15;
      aBlock[6] = a1;
      aBlock[7] = a3;
      mdns_querier_set_result_handler(v15, aBlock);
      mdns_querier_set_time_limit_ms((void *)v15, 15000);
      mdns_client_activate(v15);
    }

    else
    {
      if (_mdns_dns_service_log_s_once != -1) {
        dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_62);
      }
      uint64_t v18 = (os_log_s *)_mdns_dns_service_log_s_log;
      if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_ERROR))
      {
        uint64_t v19 = "alias ";
        if (!a3) {
          uint64_t v19 = "";
        }
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v22 = v19;
        _os_log_error_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_ERROR,  "Failed to create DDR %{public}squerier",  buf,  0xCu);
      }
    }
  }

uint64_t ___mdns_dns_service_manager_prepare_push_service_block_invoke(uint64_t a1, const void *a2)
{
  uint64_t v2 = *(void *)(*(void *)(a1 + 32) + 72LL);
  if (!*(_BYTE *)(v2 + 103)) {
    CFArrayAppendValue(*(CFMutableArrayRef *)(v2 + 64), a2);
  }
  return 1LL;
}

void ___mdns_dns_service_manager_start_ddr_querier_ex_block_invoke(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 32);
  uint64_t v2 = *(const void **)(a1 + 40);
  if (*(const void **)(v3 + 184) == v2)
  {
    if (v2)
    {
      os_release(*(void **)(a1 + 40));
      *(void *)(v3 + 184) = 0LL;
    }
  }

  else
  {
    uint64_t v4 = *(const __CFArray **)(v3 + 192);
    if (!v4) {
      goto LABEL_173;
    }
    v144.size_t length = CFArrayGetCount(v4);
    v144.location = 0LL;
    CFIndex FirstIndexOfValue = CFArrayGetFirstIndexOfValue(*(CFArrayRef *)(v3 + 192), v144, v2);
    if (FirstIndexOfValue < 0) {
      goto LABEL_173;
    }
    CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(v3 + 192), FirstIndexOfValue);
  }

  uint64_t v6 = *(void *)(a1 + 40);
  if (*(_BYTE *)(v6 + 248) == 1)
  {
    uint64_t v7 = *(void *)(v6 + 136);
    if (v7)
    {
      unint64_t v8 = *(void *)(v7 + 32);
      unint64_t v9 = *(unsigned int *)(v7 + 40);
    }

    else
    {
      unint64_t v8 = 0LL;
      unint64_t v9 = 0LL;
    }

    if (*(void *)(a1 + 56)) {
      uint64_t v81 = *(unsigned __int8 **)(*(void *)(*(void *)(v6 + 88) + 56LL) + 24LL);
    }
    else {
      uint64_t v81 = 0LL;
    }
    uint64_t v10 = *(void *)(a1 + 32);
    uint64_t v11 = *(CFArrayRef **)(a1 + 48);
    int AnswerSection = 0;
    *(void *)uint64_t v93 = 0LL;
    uint64_t v12 = (unsigned __int16 *)DNSMessageCollapse(v8, v9, v93, (char **)&AnswerSection);
    if (!AnswerSection)
    {
      uint64_t v13 = *(const void **)(v10 + 152);
      if (v13)
      {
        CFRelease(v13);
        *(void *)(v10 + 152) = 0LL;
      }

      *(_BYTE *)(v10 + 287) = 0;
      if (*(void *)v93 >= 0xCuLL)
      {
        unsigned int v14 = __rev16(v12[3]);
        if (v14)
        {
          uint64_t v92 = 0LL;
          int AnswerSection = DNSMessageGetAnswerSection((unint64_t)v12, *(unint64_t *)v93, &v92);
          if (!AnswerSection)
          {
            group = dispatch_group_create();
            int v15 = 0;
            uint64_t v91 = v92;
            while (1)
            {
              unint64_t v89 = 0LL;
              uint32_t v90 = 0LL;
              int AnswerSection = _DNSMessageExtractRecordEx( (unint64_t)v12,  *(uint64_t *)v93,  v91,  0LL,  0LL,  0LL,  0LL,  &v90,  &v89,  0LL,  0LL,  0LL,  0LL,  &v91);
              if (AnswerSection) {
                goto LABEL_171;
              }
              uint64_t v16 = v90;
              if (v90)
              {
                unint64_t v17 = v89;
                if (v89 >= 2)
                {
                  if (*v90)
                  {
                    *(void *)__int128 buf = 0LL;
                    *(void *)&uint8_t buf[8] = buf;
                    *(void *)&uint8_t buf[16] = 0x2000000000LL;
                    LOBYTE(v122) = 0;
                    blocuint64_t k = _NSConcreteStackBlock;
                    uint64_t v113 = 0x40000000LL;
                    BOOL v114 = __dnssd_svcb_is_valid_block_invoke;
                    int v115 = &unk_10013E2B8;
                    int v116 = buf;
                    _dnssd_svcb_extract_values(v90, v89, 0, (uint64_t)&block);
                    int v18 = *(unsigned __int8 *)(*(void *)&buf[8] + 24LL);
                    _Block_object_dispose(buf, 8);
                    if (!v18)
                    {
                      unint64_t v17 = v89;
                      uint64_t v16 = v90;
                      if (v89 >= 2)
                      {
LABEL_29:
                        if (!*v16)
                        {
                          if (!v81)
                          {
                            uint64_t v19 = v16 + 1;
                            if (v16 != (unsigned __int16 *)-2LL && (unsigned __int16 *)((char *)v16 + v17) > v19)
                            {
                              uint64_t v20 = v16 + 1;
                              while (*v20)
                              {
                                v20 += *v20 + 1;
                                if (v20) {
                                  BOOL v21 = v20 >= (_BYTE *)v16 + v17;
                                }
                                else {
                                  BOOL v21 = 1;
                                }
                                if (v21) {
                                  goto LABEL_33;
                                }
                              }
                            }
                          }

                          goto LABEL_33;
                        }
                      }

                      uint64_t v85 = 0LL;
                      uint64_t v86 = &v85;
                      uint64_t v87 = 0x2000000000LL;
                      char v88 = 0;
                      v84[0] = _NSConcreteStackBlock;
                      v84[1] = 0x40000000LL;
                      v84[2] = ___mdns_dns_service_manager_process_ddr_response_block_invoke;
                      v84[3] = &unk_10013AFE8;
                      v84[4] = &v85;
                      blocuint64_t k = _NSConcreteStackBlock;
                      uint64_t v113 = 0x40000000LL;
                      BOOL v114 = __dnssd_svcb_access_alpn_values_block_invoke;
                      int v115 = &unk_10013E380;
                      int v116 = v84;
                      _dnssd_svcb_extract_values(v16, v17, 1, (uint64_t)&block);
                      if (!*((_BYTE *)v86 + 24)) {
                        goto LABEL_32;
                      }
                      if (v89 < 2) {
                        goto LABEL_32;
                      }
                      uint64_t v22 = v90;
                      int v23 = v90 + 1;
                      int v24 = v90 + 1;
                      while (*(_BYTE *)v24)
                      {
                        int v24 = (unsigned __int16 *)((char *)v24 + *(unsigned __int8 *)v24 + 1);
                        if (v24) {
                          BOOL v25 = v24 >= (unsigned __int16 *)((char *)v90 + v89);
                        }
                        else {
                          BOOL v25 = 1;
                        }
                        if (v25) {
                          goto LABEL_32;
                        }
                      }

                      uint64_t v26 = calloc(1uLL, 0x3F1uLL);
                      if (!v26) {
                        __break(1u);
                      }
                      LODWORD(v27) = *((unsigned __int8 *)v22 + 2);
                      __int16 v28 = v26;
                      if (*((_BYTE *)v22 + 2)
                        || (_BYTE *v26 = 46, v28 = v26 + 1, LODWORD(v27) = *(unsigned __int8 *)v23, *(_BYTE *)v23))
                      {
                        while (v27 <= 0x3F)
                        {
                          uint64_t v29 = (unsigned __int8 *)v23 + 1;
                          unint64_t v30 = (unint64_t)v23 + v27 + 1;
                          if ((unint64_t)v29 < v30)
                          {
                            uint64_t v27 = v27;
                            do
                            {
                              unsigned int v32 = *v29++;
                              unsigned int v31 = v32;
                              if (v32 == 92 || v31 == 46)
                              {
                                *v28++ = 92;
                              }

                              else if (v31 <= 0x20)
                              {
                                *(_WORD *)__int16 v28 = 12380;
                                unsigned int v33 = (205 * v31) >> 11;
                                v28[2] = v33 | 0x30;
                                v28 += 3;
                                LOBYTE(v31) = (v31 - 10 * v33) | 0x30;
                              }

                              *v28++ = v31;
                              --v27;
                            }

                            while (v27);
                          }

                          *__int16 v28 = 0;
                          CFIndex v34 = (char *)v23 + *(unsigned __int8 *)v23;
                          *v28++ = 46;
                          int v35 = v34[1];
                          int v23 = (unsigned __int16 *)(v34 + 1);
                          LODWORD(v27) = v35;
                          if (!v35) {
                            goto LABEL_72;
                          }
                        }

LABEL_171:
    if (v12) {
LABEL_172:
    }
      free(v12);
  }

LABEL_173:
  os_release(*(void **)(a1 + 48));
  os_release(*(void **)(a1 + 32));
  os_release(*(void **)(a1 + 40));
}

uint64_t ___mdns_dns_service_manager_process_ddr_response_block_invoke(uint64_t a1, char *__s1)
{
  if (!strcmp(__s1, "dot"))
  {
    char v4 = 2;
    goto LABEL_5;
  }

  if (!strcmp(__s1, "h2"))
  {
    char v4 = 3;
LABEL_5:
    *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = v4;
  }

  return 1LL;
}

BOOL ___mdns_dns_service_get_discovered_alt_block_invoke(uint64_t a1, uint64_t a2)
{
  if (*(void *)(a2 + 96))
  {
    if (*(unsigned __int8 *)(a2 + 281) == *(unsigned __int8 *)(a1 + 48))
    {
      uint64_t provider_name = (const char *)nw_resolver_config_get_provider_name();
    }
  }

  return *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) == 0LL;
}

uint64_t _mdns_dns_service_manager_add_pending_alt(CFArrayRef *a1, uint64_t a2, const void *a3)
{
  CFMutableArrayRef Mutable = *(const __CFArray **)(a2 + 152);
  if (!Mutable)
  {
    CFMutableArrayRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0LL, (const CFArrayCallBacks *)&mdns_cfarray_callbacks);
    *(void *)(a2 + 152) = Mutable;
    if (!Mutable) {
      return 4294960567LL;
    }
  }

  v9[0] = _NSConcreteStackBlock;
  v9[1] = 0x40000000LL;
  v9[2] = ___mdns_dns_service_array_contains_service_block_invoke;
  v9[3] = &__block_descriptor_tmp_135;
  v9[4] = a3;
  uint64_t result = mdns_cfarray_enumerate(Mutable, (uint64_t)v9);
  if ((_DWORD)result)
  {
    unint64_t v8 = *(__CFArray **)(a2 + 152);
    _mdns_dns_service_increment_use_count((uint64_t)a3);
    CFArrayAppendValue(v8, a3);
    _mdns_dns_service_manager_update_interface_properties_for_service(a1, (uint64_t)a3);
    return 0LL;
  }

  return result;
}

char *_mdns_dns_service_create_discovered_alt( uint64_t a1, void *a2, unsigned int a3, int a4, uint64_t a5, _DWORD *a6)
{
  uint64_t result = (char *)nw_resolver_config_get_provider_name(a2);
  if (a5)
  {
    if (!result || (uint64_t result = strdup(result)) == 0LL)
    {
      __break(1u);
      return result;
    }

    uint64_t v13 = result;
    nw_resolver_config_set_provider_name(a2, a5);
  }

  else
  {
    uint64_t v13 = 0LL;
  }

  int v30 = 0;
  unsigned int v14 = _mdns_dns_service_create_from_resolver_config(a2, 4, *(_BYTE *)(a1 + 280), &v30);
  uint64_t v15 = (uint64_t)v14;
  if (!v30)
  {
    *((void *)v14 + 17) = a1;
    os_retain((void *)a1);
    *(_WORD *)(v15 + 276) = *(_WORD *)(a1 + 276) & 0xE;
    *(_WORD *)(v15 + 27_Block_object_dispose(va, 8) = a3;
    if (v13) {
      *(void *)(v15 + 176) = v13;
    }
    if (a4)
    {
      uint64_t v16 = *(const void **)(v15 + 80);
      if (v16)
      {
        CFRelease(v16);
        *(void *)(v15 + 80) = 0LL;
      }

      unint64_t v17 = *(const __CFArray **)(a1 + 80);
      if (v17)
      {
        CFIndex Count = CFArrayGetCount(v17);
        if (Count >= 1)
        {
          CFIndex v19 = Count;
          CFIndex v20 = 0LL;
          __int16 v21 = __rev16(a3);
          while (1)
          {
            uint64_t ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 80), v20);
            int v23 = ValueAtIndex;
            int v24 = *((unsigned __int8 *)ValueAtIndex + 25);
            if (v24 == 30) {
              break;
            }
            if (v24 == 2)
            {
              int v25 = ValueAtIndex[7];
              uint64_t v26 = _mdns_address_new();
              if (!v26) {
                goto LABEL_24;
              }
              uint64_t v27 = (void *)v26;
              *(_WORD *)(v26 + memset(&v5[1], 0, 24) = 528;
              *(_WORD *)(v26 + 26) = v21;
              *(_DWORD *)(v26 + 2_Block_object_dispose(va, 8) = v25;
LABEL_21:
              _mdns_dns_service_append_address(v15, v27);
              os_release(v27);
            }

void ___mdns_dns_service_manager_register_discovered_service_block_invoke( uint64_t a1, int a2, int a3, void *a4)
{
  uint64_t v6 = *(void *)(a1 + 32);
  if ((*(_WORD *)(v6 + 276) & 1) != 0)
  {
    if (_mdns_dns_service_log_s_once != -1) {
      dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_62);
    }
    uint64_t v10 = _mdns_dns_service_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_INFO))
    {
      uint64_t v11 = *(char **)(*(void *)(a1 + 32) + 24LL);
      *(_DWORD *)__int128 buf = 134217984;
      CFIndex v19 = v11;
      uint64_t v12 = "Service became defunct before discovered child service could be validated -- service id: %llu";
      uint64_t v13 = (os_log_s *)v10;
      uint32_t v14 = 12;
LABEL_19:
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_INFO, v12, buf, v14);
    }

void ___mdns_dns_service_manager_probe_discovered_service_block_invoke( uint64_t a1, nw_protocol_options_t options)
{
  uint64_t v3 = nw_tls_copy_sec_protocol_options(options);
  if (!v3) {
    return;
  }
  char v4 = v3;
  sec_protocol_options_set_tls_server_name(v3, *(const char **)(a1 + 56));
  sec_protocol_options_set_peer_authentication_required(v4, 1);
  int v5 = *(unsigned __int8 *)(a1 + 64);
  if (v5 == 2)
  {
    uint64_t v6 = "dot";
LABEL_6:
    sec_protocol_options_add_tls_application_protocol(v4, v6);
    goto LABEL_7;
  }

  if ((v5 - 3) <= 1)
  {
    uint64_t v6 = "h2";
    goto LABEL_6;
  }

void __Block_byref_object_copy__850(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_dispose__851(uint64_t a1)
{
}

void ___mdns_dns_service_manager_probe_discovered_service_block_invoke_220(uint64_t a1, int a2)
{
  uint64_t v4 = *(void *)(*(void *)(a1 + 96) + 208LL);
  if (v4 && nw_array_contains_object(v4, *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL)))
  {
    switch(a2)
    {
      case 1:
      case 4:
        _mdns_dns_service_forget_ddr_connection( *(void *)(*(void *)(a1 + 96) + 208LL),  *(nw_connection **)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL));
        break;
      case 3:
        __int128 v9 = *(nw_connection **)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
        if (_mdns_dns_service_queue_s_once != -1)
        {
          uint64_t v11 = *(nw_connection **)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
          dispatch_once(&_mdns_dns_service_queue_s_once, &__block_literal_global_237);
          __int128 v9 = v11;
        }

        v12[0] = _NSConcreteStackBlock;
        v12[1] = 0x40000000LL;
        v12[2] = ___mdns_dns_service_manager_probe_discovered_service_block_invoke_2_221;
        void v12[3] = &unk_10013B0F0;
        uint64_t v16 = *(void *)(a1 + 96);
        char v17 = *(_BYTE *)(a1 + 112);
        __int128 v10 = *(_OWORD *)(a1 + 48);
        __int128 v13 = *(_OWORD *)(a1 + 32);
        __int128 v14 = v10;
        __int128 v15 = *(_OWORD *)(a1 + 64);
        nw_connection_access_establishment_report(v9, (dispatch_queue_t)_mdns_dns_service_queue_s_queue, v12);
        break;
      case 5:
        goto LABEL_6;
      default:
        return;
    }
  }

  else if (a2 == 5)
  {
LABEL_6:
    (*(void (**)(void))(*(void *)(*(void *)(*(void *)(a1 + 80) + 8LL) + 40LL) + 16LL))();
    int v5 = *(const void **)(*(void *)(*(void *)(a1 + 80) + 8LL) + 40LL);
    if (v5)
    {
      _Block_release(v5);
      *(void *)(*(void *)(*(void *)(a1 + 80) + 8LL) + 40LL) = 0LL;
    }

    dispatch_group_leave(*(dispatch_group_t *)(a1 + 104));
    uint64_t v6 = *(void **)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
    if (v6)
    {
      nw_release(v6);
      *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 0LL;
    }

    os_release(*(void **)(a1 + 96));
    __int128 v7 = *(const void **)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL);
    if (v7)
    {
      CFRelease(v7);
      *(void *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL) = 0LL;
    }

    unint64_t v8 = *(const void **)(*(void *)(*(void *)(a1 + 56) + 8LL) + 24LL);
    if (v8)
    {
      CFRelease(v8);
      *(void *)(*(void *)(*(void *)(a1 + 56) + 8LL) + 24LL) = 0LL;
    }

    *(_BYTE *)(*(void *)(*(void *)(a1 + 88) + 8LL) + 24LL) = 1;
  }

void ___mdns_dns_service_manager_process_ddr_response_block_invoke_2(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (*(void *)(v2 + 152))
  {
    CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(v2 + 152));
    uint64_t v2 = *(void *)(a1 + 32);
    if (Count >= 1)
    {
      *(_BYTE *)(v2 + 287) = 1;
      if (*(void *)(*(void *)(a1 + 40) + 96LL))
      {
        dispatch_source_merge_data(*(dispatch_source_t *)(*(void *)(a1 + 40) + 96LL), 1uLL);
        uint64_t v2 = *(void *)(a1 + 32);
      }
    }
  }

  os_release((void *)v2);
  os_release(*(void **)(a1 + 40));
  uint64_t v4 = *(dispatch_object_s **)(a1 + 48);
  if (v4) {
    dispatch_release(v4);
  }
}

void ___mdns_dns_service_manager_probe_discovered_service_block_invoke_2_221( CFIndex a1, nw_establishment_report *a2)
{
  CFIndex v3 = a1;
  uint64_t v4 = *(void *)(*(void *)(a1 + 80) + 208LL);
  if (v4 && nw_array_contains_object(v4, *(void *)(*(void *)(*(void *)(v3 + 32) + 8LL) + 24LL)))
  {
    uint64_t v42 = *(void *)(v3 + 80);
    uint64_t v6 = *(void *)(v42 + 136);
    if (!v6 || !*(void *)(v6 + 96)) {
      uint64_t v6 = *(void *)(v3 + 80);
    }
    uint64_t v7 = *(void *)(*(void *)(v3 + 64) + 8LL);
    size_t v40 = (char **)(*(void *)(*(void *)(v3 + 72) + 8LL) + 24LL);
    int v8 = *(unsigned __int8 *)(v3 + 88);
    __int128 v9 = *(const __CFArray **)(*(void *)(*(void *)(v3 + 48) + 8LL) + 24LL);
    __int128 v10 = *(void **)(v6 + 160);
    if (!v10
      || ((uint64_t v11 = *(const __CFArray **)(*(void *)(*(void *)(v3 + 56) + 8LL) + 24LL),
           string_ptr = xpc_string_get_string_ptr(v10),
           v11)
        ? (BOOL v13 = string_ptr == 0LL)
        : (BOOL v13 = 1),
          v13))
    {
      BOOL v16 = 0;
    }

    else
    {
      CFStringRef v14 = CFStringCreateWithCString(kCFAllocatorDefault, string_ptr, 0x8000100u);
      v58.size_t length = CFArrayGetCount(v11);
      v58.location = 0LL;
      int v15 = CFArrayContainsValue(v11, v58, v14);
      BOOL v16 = v15 != 0;
      if (v15)
      {
        if (_mdns_dns_service_log_s_once != -1) {
          dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_62);
        }
        uint64_t MaximumSizeForEncoding = _mdns_dns_service_log_s_log;
        if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_INFO))
        {
          LODWORD(buf) = 138543362;
          *(void *)((char *)&buf + 4) = v14;
          _os_log_impl( (void *)&_mh_execute_header,  (os_log_t)MaximumSizeForEncoding,  OS_LOG_TYPE_INFO,  "Discovered service verified, name %{public}@ in certificate",  (uint8_t *)&buf,  0xCu);
        }
      }

      if (v14) {
        CFRelease(v14);
      }
    }

    char v17 = *(const __CFArray **)(v42 + 80);
    if (v17)
    {
      CFIndex Count = CFArrayGetCount(v17);
      if (Count >= 1)
      {
        BOOL v39 = v16;
        uint64_t v36 = v7;
        CFIndex v37 = v3;
        CFIndex v3 = 0LL;
        unsigned int v38 = v8 - 3;
        while (1)
        {
          uint64_t ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(v42 + 80), v3);
          if (v9)
          {
            CFIndex v19 = ValueAtIndex;
            CFIndex v20 = CFArrayGetCount(v9);
            if (v20 >= 1) {
              break;
            }
          }

          uint64_t MaximumSizeForEncoding = 0LL;
LABEL_64:
          if (++v3 >= Count || (MaximumSizeForEncoding & 1) != 0)
          {
            CFIndex v3 = v37;
            uint64_t v7 = v36;
            BOOL v16 = v39;
            goto LABEL_69;
          }
        }

        CFIndex v21 = v20;
        uint64_t v22 = 1LL;
        while (1)
        {
          int v23 = (const __CFString *)CFArrayGetValueAtIndex(v9, v22 - 1);
          int CStringPtr = CFStringGetCStringPtr(v23, 0x8000100u);
          if (CStringPtr) {
            break;
          }
          CFIndex Length = CFStringGetLength(v23);
          uint64_t MaximumSizeForEncoding = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u);
          if (MaximumSizeForEncoding == -1 || (uint64_t v27 = (UInt8 *)malloc(MaximumSizeForEncoding + 1)) == 0LL)
          {
LABEL_81:
            __break(1u);
            goto LABEL_82;
          }

          int v25 = (char *)v27;
          *(void *)&__int128 buf = 0LL;
          v59.location = 0LL;
          v59.size_t length = Length;
          if (CFStringGetBytes(v23, v59, 0x8000100u, 0, 0, v27, MaximumSizeForEncoding, (CFIndex *)&buf) == Length)
          {
            v25[buf] = 0;
            goto LABEL_33;
          }

          free(v25);
          uint64_t MaximumSizeForEncoding = 0LL;
LABEL_57:
          if (v22++ >= v21) {
            goto LABEL_64;
          }
        }

        int v25 = strdup(CStringPtr);
        if (!v25) {
          goto LABEL_81;
        }
LABEL_33:
        nw_endpoint_t host = nw_endpoint_create_host(v25, "0");
        if (!host)
        {
          uint64_t MaximumSizeForEncoding = 0LL;
          goto LABEL_56;
        }

        uint64_t v29 = host;
        if (nw_endpoint_get_type(host) == nw_endpoint_type_address)
        {
          nw_endpoint_t address = nw_endpoint_get_address(v29);
          int sa_family = address->sa_family;
          if (sa_family == *((unsigned __int8 *)v19 + 25) && address->sa_len == *((unsigned __int8 *)v19 + 24))
          {
            if (sa_family == 30)
            {
              if (*(void *)&address->sa_data[6] == v19[4] && *(void *)&address[1].sa_len == v19[5]) {
                goto LABEL_40;
              }
            }

            else if (sa_family == 2 && *(_DWORD *)&address->sa_data[2] == *((_DWORD *)v19 + 7))
            {
LABEL_40:
              if (_mdns_dns_service_log_s_once != -1) {
                dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_62);
              }
              uint64_t MaximumSizeForEncoding = _mdns_dns_service_log_s_log;
              if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_INFO))
              {
                LODWORD(buf) = 138543362;
                *(void *)((char *)&buf + 4) = v29;
                _os_log_impl( (void *)&_mh_execute_header,  (os_log_t)MaximumSizeForEncoding,  OS_LOG_TYPE_INFO,  "Discovered service verified, address %{public}@ in certificate",  (uint8_t *)&buf,  0xCu);
              }

              if (!v39 && !*v40)
              {
                if (v38 <= 1 && sa_family == 30)
                {
                  asprintf(v40, "[%s]", v25);
                }

                else
                {
                  CFIndex v34 = strdup(v25);
                  if (!v34) {
                    goto LABEL_81;
                  }
                  void *v40 = v34;
                }
              }

              uint64_t MaximumSizeForEncoding = 1LL;
              goto LABEL_55;
            }
          }
        }

        uint64_t MaximumSizeForEncoding = 0LL;
LABEL_55:
        nw_release(v29);
LABEL_56:
        free(v25);
        if ((MaximumSizeForEncoding & 1) != 0) {
          goto LABEL_64;
        }
        goto LABEL_57;
      }
    }

    else
    {
      CFIndex Count = 0LL;
    }

    LODWORD(MaximumSizeForEncoding) = 0;
LABEL_69:
    uint64_t v43 = 0LL;
    int v44 = &v43;
    uint64_t v45 = 0x2000000000LL;
    char v46 = 0;
    if (a2)
    {
      *(void *)&__int128 buf = _NSConcreteStackBlock;
      *((void *)&buf + 1) = 0x40000000LL;
      uint64_t v50 = ___mdns_dns_server_validate_discovered_service_connection_block_invoke;
      __int128 v51 = &unk_10013B168;
      __int128 v52 = &v43;
      BOOL v56 = v16;
      char v57 = MaximumSizeForEncoding;
      CFIndex v53 = Count;
      uint64_t v54 = v42;
      int v55 = v40;
      nw_establishment_report_enumerate_resolution_reports(a2, &buf);
    }

    if (((v16 | MaximumSizeForEncoding) & 1) != 0)
    {
      char v35 = 1;
    }

    else if (*((_BYTE *)v44 + 24))
    {
      char v35 = 1;
      *(_BYTE *)(v7 + memset(&v5[1], 0, 24) = 1;
    }

    else
    {
      if (_mdns_dns_service_log_s_once != -1) {
        dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_62);
      }
      uint64_t MaximumSizeForEncoding = _mdns_dns_service_log_s_log;
      if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_ERROR))
      {
LABEL_82:
        *(_DWORD *)uint64_t v47 = 138412290;
        uint64_t v48 = v42;
        _os_log_error_impl( (void *)&_mh_execute_header,  (os_log_t)MaximumSizeForEncoding,  OS_LOG_TYPE_ERROR,  "Discovered service could not be verified for %@",  v47,  0xCu);
      }

      char v35 = 0;
    }

    _Block_object_dispose(&v43, 8);
    *(_BYTE *)(*(void *)(*(void *)(v3 + 40) + 8LL) + 24LL) = v35;
    _mdns_dns_service_forget_ddr_connection( *(void *)(*(void *)(v3 + 80) + 208LL),  *(nw_connection **)(*(void *)(*(void *)(v3 + 32) + 8LL) + 24LL));
  }

void _mdns_dns_service_forget_ddr_connection(uint64_t a1, nw_connection *a2)
{
  if (a1)
  {
  }

BOOL ___mdns_dns_server_validate_discovered_service_connection_block_invoke(uint64_t a1, uint64_t a2)
{
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000LL;
  v5[2] = ___mdns_dns_server_validate_discovered_service_connection_block_invoke_2;
  v5[3] = &unk_10013B140;
  uint64_t v3 = *(void *)(a1 + 40);
  v5[4] = *(void *)(a1 + 32);
  void v5[5] = v3;
  __int16 v7 = *(_WORD *)(a1 + 64);
  __int128 v6 = *(_OWORD *)(a1 + 48);
  nw_resolution_report_enumerate_endpoints(a2, v5);
  return *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) == 0;
}

BOOL ___mdns_dns_server_validate_discovered_service_connection_block_invoke_2( uint64_t a1, nw_endpoint_t endpoint)
{
  if (nw_endpoint_get_type(endpoint) == nw_endpoint_type_address)
  {
    nw_endpoint_t address = nw_endpoint_get_address(endpoint);
    int v5 = *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
    if (!*(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL))
    {
      if (*(uint64_t *)(a1 + 40) < 1)
      {
        int v5 = 0;
      }

      else
      {
        __int128 v6 = address;
        CFIndex v7 = 0LL;
        do
        {
          uint64_t ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(*(void *)(a1 + 48) + 80LL), v7);
          int sa_family = v6->sa_family;
          if (sa_family == *((unsigned __int8 *)ValueAtIndex + 25)
            && sa_family == 2
            && v6->sa_len == *((unsigned __int8 *)ValueAtIndex + 24))
          {
            unsigned int v11 = *(_DWORD *)&v6->sa_data[2];
            if (v11 == ValueAtIndex[7]
              && (vmaxv_u16((uint16x4_t)vmovn_s32( vceqq_s32( (int32x4_t)vandq_s8( (int8x16_t)vdupq_n_s32(bswap32(v11)),  (int8x16_t)xmmword_1001007C0),  (int32x4_t)xmmword_1001007D0))) & 1) != 0)
            {
              *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 1;
              if (_mdns_dns_service_log_s_once != -1) {
                dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_62);
              }
              uint64_t v12 = (os_log_s *)_mdns_dns_service_log_s_log;
              if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_INFO))
              {
                *(_DWORD *)__int128 buf = 138543362;
                nw_endpoint_t v18 = endpoint;
                _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_INFO,  "Discovered service verified, private address %{public}@ used",  buf,  0xCu);
              }
            }
          }

          if (!*(_BYTE *)(a1 + 64) && !*(_BYTE *)(a1 + 65))
          {
            if (*(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL))
            {
              BOOL v13 = *(void **)(a1 + 56);
              if (v13)
              {
                if (!*v13)
                {
                  hostname = nw_endpoint_get_hostname(endpoint);
                  if (hostname)
                  {
                    int v15 = strdup(hostname);
                    if (!v15) {
                      __break(1u);
                    }
                    **(void **)(a1 + 56) = v15;
                  }
                }
              }
            }
          }

          int v5 = *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
          if (*(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL)) {
            break;
          }
          ++v7;
        }

        while (v7 < *(void *)(a1 + 40));
      }
    }
  }

  else
  {
    int v5 = *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
  }

  return v5 == 0;
}

void ___mdns_dns_service_manager_probe_discovered_service_block_invoke_2( uint64_t a1, int a2, sec_trust_t trust, void (**a4)(void, void))
{
  __int128 v6 = sec_trust_copy_ref(trust);
  CFIndex v7 = _Block_copy(a4);
  if (_mdns_dns_service_queue_s_once != -1) {
    dispatch_once(&_mdns_dns_service_queue_s_once, &__block_literal_global_237);
  }
  v11[0] = _NSConcreteStackBlock;
  v11[1] = 0x40000000LL;
  _OWORD v11[2] = ___mdns_dns_service_manager_probe_discovered_service_block_invoke_3;
  v11[3] = &unk_10013B078;
  __int128 v12 = *(_OWORD *)(a1 + 32);
  uint64_t v13 = *(void *)(a1 + 48);
  void v11[4] = v7;
  OSStatus v8 = SecTrustEvaluateAsyncWithError(v6, (dispatch_queue_t)_mdns_dns_service_queue_s_queue, v11);
  if (v6) {
    CFRelease(v6);
  }
  if (v8)
  {
    if (_mdns_dns_service_log_s_once != -1) {
      dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_62);
    }
    __int128 v9 = (os_log_s *)_mdns_dns_service_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_ERROR))
    {
      uint64_t v10 = *(void *)(a1 + 56);
      *(_DWORD *)__int128 buf = 136315394;
      uint64_t v15 = v10;
      __int16 v16 = 2048;
      uint64_t v17 = v8;
      _os_log_error_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_ERROR,  "Failed to start aynchronous trust evaluation -- provider name: %s, error: %{mdns:err}ld",  buf,  0x16u);
    }

    a4[2](a4, 0LL);
    if (v7) {
      _Block_release(v7);
    }
  }

void ___mdns_dns_service_manager_probe_discovered_service_block_invoke_3( void *a1, SecTrustRef trust, int a3, uint64_t a4)
{
  if (!*(_BYTE *)(*(void *)(a1[5] + 8LL) + 24LL))
  {
    if (a3)
    {
      int v5 = SecTrustCopyCertificateChain(trust);
      if (v5)
      {
        __int128 v6 = v5;
        if (CFArrayGetCount(v5) >= 1)
        {
          uint64_t ValueAtIndex = CFArrayGetValueAtIndex(v6, 0LL);
          OSStatus v8 = *(const void **)(*(void *)(a1[6] + 8LL) + 24LL);
          if (v8)
          {
            CFRelease(v8);
            *(void *)(*(void *)(a1[6] + 8LL) + 24LL) = 0LL;
          }

          __int128 v9 = *(const void **)(*(void *)(a1[7] + 8LL) + 24LL);
          if (v9)
          {
            CFRelease(v9);
            *(void *)(*(void *)(a1[7] + 8LL) + 24LL) = 0LL;
          }

          *(void *)(*(void *)(a1[6] + 8LL) + 24LL) = SecCertificateCopyIPAddresses(ValueAtIndex);
          *(void *)(*(void *)(a1[7] + 8LL) + 24LL) = SecCertificateCopyDNSNames(ValueAtIndex);
        }

        CFRelease(v6);
      }
    }

    else
    {
      if (_mdns_dns_service_log_s_once != -1) {
        dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_62);
      }
      unsigned int v11 = (os_log_s *)_mdns_dns_service_log_s_log;
      if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_ERROR))
      {
        int v13 = 138412290;
        uint64_t v14 = a4;
        _os_log_error_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_ERROR,  "Aynchronous trust evaluation failed: %@",  (uint8_t *)&v13,  0xCu);
      }
    }
  }

  (*(void (**)(void))(a1[4] + 16LL))();
  __int128 v12 = (const void *)a1[4];
  if (v12) {
    _Block_release(v12);
  }
}

BOOL ___mdns_dns_service_array_contains_service_block_invoke(uint64_t a1, uint64_t a2)
{
  return *(void *)(a1 + 32) != a2;
}

uint64_t ___mdns_dns_service_manager_get_service_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 32);
  if (!v4 || ((*(uint64_t (**)(uint64_t, uint64_t))(v4 + 16))(v4, a2) & 1) == 0)
  {
    if (_mdns_dns_service_scope_id_match(a2, *(void *)(a1 + 64)))
    {
      unsigned int v9 = 0;
      int v5 = _mdns_dns_service_handles_domain_name(a2, *(_BYTE **)(a1 + 72), &v9);
      if ((v5 & 0x80000000) == 0)
      {
        int v6 = *(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL);
        if (v5 > v6)
        {
          unsigned int v7 = v9;
LABEL_7:
          *(void *)(*(void *)(*(void *)(a1 + 56) + 8LL) + 24LL) = a2;
          *(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = v5;
          *(_DWORD *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL) = v7;
          return 1LL;
        }

        if (v5 == v6)
        {
          unsigned int v7 = v9;
          if (v9 < *(_DWORD *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL)) {
            goto LABEL_7;
          }
        }
      }
    }
  }

  return 1LL;
}

uint64_t _mdns_dns_service_get_preferred_encrypted_alt(uint64_t a1, char a2)
{
  uint64_t v10 = 0LL;
  unsigned int v11 = &v10;
  uint64_t v12 = 0x2000000000LL;
  uint64_t v13 = 0LL;
  v8[0] = 0LL;
  v8[1] = v8;
  v8[2] = 0x2000000000LL;
  char v9 = 0;
  uint64_t v3 = *(const __CFArray **)(a1 + 144);
  if (v3 && *(unsigned __int8 *)(a1 + 281) - 2 >= 4)
  {
    v6[0] = _NSConcreteStackBlock;
    v6[1] = 0x40000000LL;
    v6[2] = ___mdns_dns_service_get_preferred_encrypted_alt_block_invoke;
    v6[3] = &unk_10013AB58;
    char v7 = a2;
    void v6[4] = v8;
    v6[5] = &v10;
    mdns_cfarray_enumerate(v3, (uint64_t)v6);
    uint64_t v4 = v11[3];
  }

  else
  {
    uint64_t v4 = 0LL;
  }

  _Block_object_dispose(v8, 8);
  _Block_object_dispose(&v10, 8);
  return v4;
}

BOOL ___mdns_dns_service_get_preferred_encrypted_alt_block_invoke(uint64_t a1, uint64_t a2)
{
  if ((*(_WORD *)(a2 + 276) & 0x801) != 0) {
    return 1LL;
  }
  int v4 = *(void *)(a2 + 96) && nw_resolver_config_get_class() == 4;
  int v5 = *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
  if ((v5 - 3) >= 2)
  {
    int v6 = *(unsigned __int8 *)(a2 + 281);
    if ((v6 - 3) < 2 || v6 == 2 && (v7 = v5 == 2, int v5 = 2, !v7))
    {
      *(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = a2;
      *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = v6;
      int v5 = *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
    }
  }

  return (v5 - 5) < 0xFFFFFFFE;
}

uint64_t _mdns_dns_service_handles_domain_name(uint64_t a1, _BYTE *a2, _DWORD *a3)
{
  int v5 = (uint64_t *)(a1 + 88);
  while (1)
  {
    int v5 = (uint64_t *)*v5;
    if (!v5) {
      return 0xFFFFFFFFLL;
    }
    unsigned int v6 = *a2;
    if (*a2)
    {
      int v7 = 0;
      OSStatus v8 = a2;
      while (v6 <= 0x3F)
      {
        v8 += v6 + 1;
        if (v8 - a2 > 255) {
          break;
        }
        ++v7;
        unsigned int v6 = *v8;
        if (!*v8) {
          goto LABEL_10;
        }
      }

      int v7 = -1;
    }

    else
    {
      int v7 = 0;
    }

uint64_t __mdns_dns_service_manager_get_interface_scoped_custom_push_service_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  if (*(_BYTE *)(v2 + 131))
  {
    uint64_t result = 0LL;
  }

  else
  {
    uint64_t v3 = *(const __CFArray **)(v2 + 72);
    uint64_t v4 = *(void *)(a1 + 48);
    int v5 = *(_DWORD *)(a1 + 56);
    uint64_t v9 = 0LL;
    uint64_t v10 = 0x100000000LL;
    int v8 = v5;
    uint64_t service = _mdns_dns_service_manager_get_service(v3, v4, (uint64_t)&v8, 0, 0LL);
    uint64_t result = _mdns_dns_service_manager_prepare_service(*(void *)(a1 + 40), service);
  }

  *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = result;
  return result;
}

uint64_t mdns_dns_service_manager_get_unscoped_native_service(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = 0LL;
  int v8 = &v7;
  uint64_t v9 = 0x2000000000LL;
  uint64_t v10 = 0LL;
  if (_mdns_dns_service_queue_s_once != -1) {
    dispatch_once(&_mdns_dns_service_queue_s_once, &__block_literal_global_237);
  }
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000LL;
  block[2] = __mdns_dns_service_manager_get_unscoped_native_service_block_invoke;
  block[3] = &unk_10013A2C0;
  void block[4] = &v7;
  void block[5] = a1;
  block[6] = a2;
  dispatch_sync((dispatch_queue_t)_mdns_dns_service_queue_s_queue, block);
  uint64_t v4 = v8[3];
  _Block_object_dispose(&v7, 8);
  return v4;
}

uint64_t __mdns_dns_service_manager_get_unscoped_native_service_block_invoke(void *a1)
{
  uint64_t v2 = a1[5];
  if (*(_BYTE *)(v2 + 131))
  {
    uint64_t result = 0LL;
  }

  else
  {
    uint64_t v3 = *(const __CFArray **)(v2 + 24);
    uint64_t v4 = a1[6];
    v7[0] = 0LL;
    v7[1] = 0LL;
    int v8 = 0;
    uint64_t service = _mdns_dns_service_manager_get_service(v3, v4, (uint64_t)v7, 0, 0LL);
    uint64_t result = _mdns_dns_service_manager_prepare_service(a1[5], service);
  }

  *(void *)(*(void *)(a1[4] + 8LL) + 24LL) = result;
  return result;
}

uint64_t __mdns_dns_service_manager_get_interface_scoped_native_service_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  if (*(_BYTE *)(v2 + 131))
  {
    uint64_t result = 0LL;
  }

  else
  {
    uint64_t v3 = *(const __CFArray **)(v2 + 24);
    uint64_t v4 = *(void *)(a1 + 48);
    int v5 = *(_DWORD *)(a1 + 56);
    uint64_t v9 = 0LL;
    uint64_t v10 = 0x100000000LL;
    int v8 = v5;
    uint64_t service = _mdns_dns_service_manager_get_service(v3, v4, (uint64_t)&v8, 0, 0LL);
    uint64_t result = _mdns_dns_service_manager_prepare_service(*(void *)(a1 + 40), service);
  }

  *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = result;
  return result;
}

uint64_t mdns_dns_service_manager_get_unscoped_system_service_with_options(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v10 = 0LL;
  BOOL v11 = &v10;
  uint64_t v12 = 0x2000000000LL;
  uint64_t v13 = 0LL;
  if (_mdns_dns_service_queue_s_once != -1) {
    dispatch_once(&_mdns_dns_service_queue_s_once, &__block_literal_global_237);
  }
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 0x40000000LL;
  v8[2] = __mdns_dns_service_manager_get_unscoped_system_service_with_options_block_invoke;
  void v8[3] = &unk_10013A310;
  void v8[4] = &v10;
  void v8[5] = a1;
  v8[6] = a2;
  int v9 = a3;
  dispatch_sync((dispatch_queue_t)_mdns_dns_service_queue_s_queue, v8);
  uint64_t v6 = v11[3];
  _Block_object_dispose(&v10, 8);
  return v6;
}

uint64_t __mdns_dns_service_manager_get_unscoped_system_service_with_options_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  if (*(_BYTE *)(v2 + 131))
  {
    uint64_t result = 0LL;
  }

  else
  {
    uint64_t v3 = *(const __CFArray **)(v2 + 32);
    uint64_t v4 = *(void *)(a1 + 48);
    int v5 = *(_DWORD *)(a1 + 56);
    v8[0] = 0LL;
    v8[1] = 0LL;
    int v9 = 0;
    uint64_t service = _mdns_dns_service_manager_get_service(v3, v4, (uint64_t)v8, v5, 0LL);
    uint64_t result = _mdns_dns_service_manager_prepare_service(*(void *)(a1 + 40), service);
  }

  *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = result;
  return result;
}

uint64_t mdns_dns_service_manager_get_interface_scoped_system_service_with_options( uint64_t a1, uint64_t a2, int a3, int a4)
{
  uint64_t v13 = 0LL;
  uint64_t v14 = &v13;
  uint64_t v15 = 0x2000000000LL;
  uint64_t v16 = 0LL;
  if (_mdns_dns_service_queue_s_once != -1) {
    dispatch_once(&_mdns_dns_service_queue_s_once, &__block_literal_global_237);
  }
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 0x40000000LL;
  v10[2] = __mdns_dns_service_manager_get_interface_scoped_system_service_with_options_block_invoke;
  v10[3] = &unk_10013A338;
  v10[4] = &v13;
  v10[5] = a1;
  v10[6] = a2;
  int v11 = a3;
  int v12 = a4;
  dispatch_sync((dispatch_queue_t)_mdns_dns_service_queue_s_queue, v10);
  uint64_t v8 = v14[3];
  _Block_object_dispose(&v13, 8);
  return v8;
}

uint64_t __mdns_dns_service_manager_get_interface_scoped_system_service_with_options_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  if (*(_BYTE *)(v2 + 131))
  {
    uint64_t result = 0LL;
  }

  else
  {
    uint64_t v3 = *(const __CFArray **)(v2 + 32);
    uint64_t v4 = *(void *)(a1 + 48);
    int v6 = *(_DWORD *)(a1 + 56);
    int v5 = *(_DWORD *)(a1 + 60);
    uint64_t v10 = 0LL;
    uint64_t v11 = 0x100000000LL;
    int v9 = v6;
    uint64_t service = _mdns_dns_service_manager_get_service(v3, v4, (uint64_t)&v9, v5, 0LL);
    uint64_t result = _mdns_dns_service_manager_prepare_service(*(void *)(a1 + 40), service);
  }

  *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = result;
  return result;
}

uint64_t mdns_dns_service_manager_get_service_scoped_system_service(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v10 = 0LL;
  uint64_t v11 = &v10;
  uint64_t v12 = 0x2000000000LL;
  uint64_t v13 = 0LL;
  if (_mdns_dns_service_queue_s_once != -1) {
    dispatch_once(&_mdns_dns_service_queue_s_once, &__block_literal_global_237);
  }
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 0x40000000LL;
  void v8[2] = __mdns_dns_service_manager_get_service_scoped_system_service_block_invoke;
  void v8[3] = &unk_10013A360;
  void v8[4] = &v10;
  void v8[5] = a1;
  v8[6] = a2;
  int v9 = a3;
  dispatch_sync((dispatch_queue_t)_mdns_dns_service_queue_s_queue, v8);
  uint64_t v6 = v11[3];
  _Block_object_dispose(&v10, 8);
  return v6;
}

uint64_t __mdns_dns_service_manager_get_service_scoped_system_service_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  if (*(_BYTE *)(v2 + 131))
  {
    uint64_t result = 0LL;
  }

  else
  {
    uint64_t v3 = *(const __CFArray **)(v2 + 32);
    uint64_t v4 = *(void *)(a1 + 48);
    int v5 = *(_DWORD *)(a1 + 56);
    uint64_t v9 = 0LL;
    uint64_t v10 = 0x200000000LL;
    int v8 = v5;
    uint64_t service = _mdns_dns_service_manager_get_service(v3, v4, (uint64_t)&v8, 0, 0LL);
    uint64_t result = _mdns_dns_service_manager_prepare_service(*(void *)(a1 + 40), service);
  }

  *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = result;
  return result;
}

uint64_t mdns_dns_service_manager_get_custom_service(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = 0LL;
  int v8 = &v7;
  uint64_t v9 = 0x2000000000LL;
  uint64_t v10 = 0LL;
  if (_mdns_dns_service_queue_s_once != -1) {
    dispatch_once(&_mdns_dns_service_queue_s_once, &__block_literal_global_237);
  }
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000LL;
  block[2] = __mdns_dns_service_manager_get_custom_service_block_invoke;
  block[3] = &unk_10013A388;
  void block[4] = &v7;
  void block[5] = a1;
  block[6] = a2;
  dispatch_sync((dispatch_queue_t)_mdns_dns_service_queue_s_queue, block);
  uint64_t v4 = v8[3];
  _Block_object_dispose(&v7, 8);
  return v4;
}

uint64_t __mdns_dns_service_manager_get_custom_service_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  if (*(_BYTE *)(v2 + 131))
  {
    uint64_t result = 0LL;
  }

  else
  {
    uint64_t service_by_id = _mdns_dns_service_manager_get_service_by_id(*(const __CFArray **)(v2 + 56), *(void *)(a1 + 48));
    if (service_by_id) {
      uint64_t service_by_id = (uint64_t)_mdns_dns_service_manager_get_usable_service_instance( *(CFArrayRef **)(a1 + 40),  service_by_id,  0);
    }
    uint64_t result = _mdns_dns_service_manager_prepare_service(*(void *)(a1 + 40), service_by_id);
  }

  *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = result;
  return result;
}

__CFArray *_mdns_dns_service_manager_get_usable_service_instance(CFArrayRef *a1, uint64_t a2, int a3)
{
  int v5 = *(_DWORD *)(a2 + 256);
  if (a3) {
    BOOL v6 = v5 == a3;
  }
  else {
    BOOL v6 = 1;
  }
  char v7 = !v6;
  if (v5 && (v7 & 1) != 0) {
    return 0LL;
  }
  if ((v7 & 1) == 0 && (*(_WORD *)(a2 + 276) & 1) == 0) {
    return (__CFArray *)a2;
  }
  if (v5) {
    int v9 = *(_DWORD *)(a2 + 256);
  }
  else {
    int v9 = a3;
  }
  uint64_t v19 = 0LL;
  CFIndex v20 = &v19;
  uint64_t v21 = 0x2000000000LL;
  uint64_t v22 = 0LL;
  v17[0] = _NSConcreteStackBlock;
  v17[1] = 0x40000000LL;
  v17[2] = ___mdns_dns_service_get_variant_for_interface_block_invoke;
  v17[3] = &unk_10013AC50;
  int v18 = v9;
  v17[4] = &v19;
  uint64_t v10 = *(const __CFArray **)(a2 + 128);
  if (v10)
  {
    mdns_cfarray_enumerate(v10, (uint64_t)v17);
    CFMutableArrayRef Mutable = (__CFArray *)v20[3];
    _Block_object_dispose(&v19, 8);
    if (Mutable) {
      return Mutable;
    }
  }

  else
  {
    _Block_object_dispose(&v19, 8);
  }

  LODWORD(v17[0]) = 0;
  uint64_t v11 = _mdns_dns_service_create(*(_BYTE *)(a2 + 281), *(_BYTE *)(a2 + 282), *(_BYTE *)(a2 + 280), (int *)v17);
  uint64_t v12 = v11;
  if (!LODWORD(v17[0]))
  {
    *(void *)(v11 + 136) = a2;
    os_retain((void *)a2);
    *(_DWORD *)(v12 + 256) = v9;
    *(_WORD *)(v12 + 276) = *(_WORD *)(a2 + 276) & 6;
    uint64_t v13 = *(const void **)(a2 + 80);
    *(void *)(v12 + 80) = v13;
    if (v13) {
      CFRetain(v13);
    }
    uint64_t v14 = *(void **)(a2 + 96);
    *(void *)(v12 + 96) = v14;
    if (v14) {
      nw_retain(v14);
    }
    unsigned int v15 = *(_DWORD *)(v12 + 256);
    if (v15) {
      *(void *)(v12 + 104) = mdns_system_interface_index_to_name(v15);
    }
    goto LABEL_26;
  }

  if (!v11) {
    return 0LL;
  }
LABEL_26:
  CFMutableArrayRef Mutable = *(__CFArray **)(a2 + 128);
  if (Mutable {
    || (CFMutableArrayRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0LL, (const CFArrayCallBacks *)&mdns_cfarray_callbacks),
  }
        (*(void *)(a2 + 12_Block_object_dispose(va, 8) = Mutable) != 0LL))
  {
    _mdns_dns_service_increment_use_count(v12);
    CFArrayAppendValue(Mutable, (const void *)v12);
    _mdns_dns_service_manager_update_interface_properties_for_service(a1, v12);
    CFMutableArrayRef Mutable = (__CFArray *)v12;
  }

  os_release((void *)v12);
  return Mutable;
}

BOOL ___mdns_dns_service_get_variant_for_interface_block_invoke(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 256) == *(_DWORD *)(a1 + 40)) {
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = a2;
  }
  return *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) == 0LL;
}

uint64_t __mdns_dns_service_manager_get_interface_scoped_mdns_alternative_service_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  if (*(_BYTE *)(v2 + 131))
  {
    uint64_t result = 0LL;
  }

  else
  {
    uint64_t v3 = *(const __CFArray **)(v2 + 72);
    uint64_t v4 = *(void *)(a1 + 48);
    int v5 = *(_DWORD *)(a1 + 56);
    uint64_t v9 = 0LL;
    uint64_t v10 = 0x100000000LL;
    int v8 = v5;
    uint64_t service = _mdns_dns_service_manager_get_service(v3, v4, (uint64_t)&v8, 0, (uint64_t)&__block_literal_global_30);
    uint64_t result = _mdns_dns_service_manager_prepare_service(*(void *)(a1 + 40), service);
  }

  *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = result;
  return result;
}

BOOL __mdns_dns_service_manager_get_interface_scoped_mdns_alternative_service_block_invoke_2( id a1, const mdns_dns_service_s *a2)
{
  return (a2->var32 & 0x4000) == 0;
}

uint64_t __mdns_dns_service_manager_get_unscoped_mdns_alternative_service_block_invoke(void *a1)
{
  uint64_t v2 = a1[5];
  if (*(_BYTE *)(v2 + 131))
  {
    uint64_t result = 0LL;
  }

  else
  {
    uint64_t v3 = *(const __CFArray **)(v2 + 72);
    uint64_t v4 = a1[6];
    v7[0] = 0LL;
    v7[1] = 0LL;
    int v8 = 0;
    uint64_t service = _mdns_dns_service_manager_get_service(v3, v4, (uint64_t)v7, 0, (uint64_t)&__block_literal_global_33);
    uint64_t result = _mdns_dns_service_manager_prepare_service(a1[5], service);
  }

  *(void *)(*(void *)(a1[4] + 8LL) + 24LL) = result;
  return result;
}

BOOL __mdns_dns_service_manager_get_unscoped_mdns_alternative_service_block_invoke_2( id a1, const mdns_dns_service_s *a2)
{
  return (a2->var32 & 0x4000) == 0;
}

uint64_t mdns_dns_service_manager_get_uuid_scoped_service(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v10 = 0LL;
  uint64_t v11 = &v10;
  uint64_t v12 = 0x2000000000LL;
  uint64_t v13 = 0LL;
  if (_mdns_dns_service_queue_s_once != -1) {
    dispatch_once(&_mdns_dns_service_queue_s_once, &__block_literal_global_237);
  }
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 0x40000000LL;
  void v8[2] = __mdns_dns_service_manager_get_uuid_scoped_service_block_invoke;
  void v8[3] = &unk_10013A480;
  void v8[4] = &v10;
  void v8[5] = a1;
  v8[6] = a2;
  int v9 = a3;
  dispatch_sync((dispatch_queue_t)_mdns_dns_service_queue_s_queue, v8);
  uint64_t v6 = v11[3];
  _Block_object_dispose(&v10, 8);
  return v6;
}

uint64_t __mdns_dns_service_manager_get_uuid_scoped_service_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  if (*(_BYTE *)(v2 + 131))
  {
    uint64_t result = 0LL;
  }

  else
  {
    uint64_t v3 = *(const unsigned __int8 **)(a1 + 48);
    uint64_t service_by_uuid = _mdns_dns_service_manager_get_service_by_uuid(*(const __CFArray **)(v2 + 48), v3);
    if (service_by_uuid
      || (uint64_t service_by_uuid = _mdns_dns_service_manager_get_service_by_uuid(*(const __CFArray **)(v2 + 40), v3)) != 0)
    {
      uint64_t service_by_uuid = (uint64_t)_mdns_dns_service_manager_get_usable_service_instance( *(CFArrayRef **)(a1 + 40),  service_by_uuid,  *(_DWORD *)(a1 + 56));
    }

    uint64_t result = _mdns_dns_service_manager_prepare_service(*(void *)(a1 + 40), service_by_uuid);
  }

  *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = result;
  return result;
}

uint64_t mdns_dns_service_manager_get_discovered_service(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = 0LL;
  int v8 = &v7;
  uint64_t v9 = 0x2000000000LL;
  uint64_t v10 = 0LL;
  if (_mdns_dns_service_queue_s_once != -1) {
    dispatch_once(&_mdns_dns_service_queue_s_once, &__block_literal_global_237);
  }
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000LL;
  block[2] = __mdns_dns_service_manager_get_discovered_service_block_invoke;
  block[3] = &unk_10013A4A8;
  void block[4] = &v7;
  void block[5] = a1;
  block[6] = a2;
  dispatch_sync((dispatch_queue_t)_mdns_dns_service_queue_s_queue, block);
  uint64_t v4 = v8[3];
  _Block_object_dispose(&v7, 8);
  return v4;
}

uint64_t __mdns_dns_service_manager_get_discovered_service_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  if (*(_BYTE *)(v2 + 131))
  {
    uint64_t result = 0LL;
  }

  else
  {
    uint64_t v3 = *(void *)(a1 + 48);
    uint64_t v12 = 0LL;
    uint64_t v13 = &v12;
    uint64_t v14 = 0x2000000000LL;
    uint64_t v15 = 0LL;
    v10[0] = 0LL;
    v10[1] = v10;
    v10[2] = 0x2000000000LL;
    int v11 = -1;
    uint64_t v4 = *(const __CFArray **)(v2 + 48);
    v9[0] = _NSConcreteStackBlock;
    v9[1] = 0x40000000LL;
    v9[2] = ___mdns_dns_service_manager_get_discovered_service_block_invoke;
    v9[3] = &unk_10013A9E0;
    void v9[5] = &v12;
    void v9[6] = v3;
    v9[4] = v10;
    mdns_cfarray_enumerate(v4, (uint64_t)v9);
    if (v13[3])
    {
      uint64_t v5 = mach_continuous_approximate_time();
      uint64_t v6 = v13[3];
      *(void *)(v6 + 32) = v5;
    }

    else
    {
      uint64_t v6 = 0LL;
    }

    _Block_object_dispose(v10, 8);
    _Block_object_dispose(&v12, 8);
    if (v6) {
      usable_service_instance = _mdns_dns_service_manager_get_usable_service_instance(*(CFArrayRef **)(a1 + 40), v6, 0);
    }
    else {
      usable_service_instance = 0LL;
    }
    uint64_t result = _mdns_dns_service_manager_prepare_service(*(void *)(a1 + 40), (uint64_t)usable_service_instance);
  }

  *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = result;
  return result;
}

uint64_t ___mdns_dns_service_manager_get_discovered_service_block_invoke(uint64_t a1, void *a2)
{
  int v4 = _mdns_dns_service_handles_domain_name((uint64_t)a2, *(_BYTE **)(a1 + 48), 0LL);
  if (a2[12] && v4 > *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL))
  {
    *(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = a2;
    *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = v4;
  }

  uint64_t v5 = a2[5];
  if (v5 && v5 < mach_continuous_time())
  {
    if (_mdns_dns_service_log_s_once != -1) {
      dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_62);
    }
    uint64_t v6 = (os_log_s *)_mdns_dns_service_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_INFO))
    {
      uint64_t v7 = a2[6];
      int v10 = 138412290;
      uint64_t v11 = v7;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_INFO,  "DoH resolver for %@ has passed expiration",  (uint8_t *)&v10,  0xCu);
    }

    a2[5] = 0LL;
    while (1)
    {
      int v8 = (void *)a2[11];
      if (!v8) {
        break;
      }
      a2[11] = *v8;
      _domain_item_free(v8);
    }

    _mdns_dns_service_manager_fetch_doh_pvd(a2);
  }

  return 1LL;
}

uint64_t mdns_dns_service_manager_get_discovered_oblivious_service(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = *(void *)(a2 + 96);
  if (!v4) {
    return 0LL;
  }
  uint64_t proxy_agent = nw_resolver_config_get_proxy_agent(*(void *)(a2 + 96));
  if (!proxy_agent) {
    return 0LL;
  }
  uint64_t v8 = proxy_agent;
  uint64_t v12 = 0LL;
  uint64_t v13 = &v12;
  uint64_t v14 = 0x2000000000LL;
  uint64_t v15 = 0LL;
  if (_mdns_dns_service_queue_s_once != -1) {
    dispatch_once(&_mdns_dns_service_queue_s_once, &__block_literal_global_237);
  }
  v11[0] = _NSConcreteStackBlock;
  v11[1] = 0x40000000LL;
  _OWORD v11[2] = __mdns_dns_service_manager_get_discovered_oblivious_service_block_invoke;
  v11[3] = &unk_10013A4D0;
  void v11[4] = &v12;
  void v11[5] = a1;
  v11[6] = a3;
  v11[7] = v8;
  dispatch_sync((dispatch_queue_t)_mdns_dns_service_queue_s_queue, v11);
  uint64_t v9 = v13[3];
  _Block_object_dispose(&v12, 8);
  return v9;
}

uint64_t __mdns_dns_service_manager_get_discovered_oblivious_service_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  if (*(_BYTE *)(v2 + 131)) {
    goto LABEL_8;
  }
  uint64_t v3 = *(const __CFArray **)(v2 + 32);
  uint64_t v4 = *(void *)(a1 + 48);
  v8[0] = 0LL;
  v8[1] = 0LL;
  int v9 = 0;
  uint64_t result = _mdns_dns_service_manager_get_service(v3, v4, (uint64_t)v8, 3, 0LL);
  if (!result) {
    goto LABEL_7;
  }
  uint64_t v6 = result;
  uint64_t result = *(void *)(result + 96);
  if (!result) {
    goto LABEL_7;
  }
  if (nw_resolver_config_get_class(result) != 4)
  {
LABEL_8:
    uint64_t result = 0LL;
    goto LABEL_7;
  }

  uint64_t result = (uint64_t)_mdns_dns_service_manager_get_usable_service_instance(*(CFArrayRef **)(a1 + 40), v6, 0);
  if (result)
  {
    uint64_t v7 = result;
    nw_resolver_config_set_proxy_agent(*(void *)(result + 96), *(void *)(a1 + 56));
    uint64_t result = _mdns_dns_service_manager_prepare_service(*(void *)(a1 + 40), v7);
  }

uint64_t __mdns_dns_service_manager_get_discovered_push_service_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  if (*(_BYTE *)(v2 + 131))
  {
    uint64_t result = 0LL;
  }

  else
  {
    uint64_t discovered_push_service = _mdns_dns_service_manager_get_discovered_push_service( *(const __CFArray **)(v2 + 64),  *(void *)(a1 + 48),  *(_DWORD *)(a1 + 56));
    uint64_t result = _mdns_dns_service_manager_prepare_service(*(void *)(a1 + 40), discovered_push_service);
  }

  *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = result;
  return result;
}

void __mdns_dns_service_manager_apply_pending_updates_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (!*(_BYTE *)(v2 + 131))
  {
    int v28 = _NSConcreteStackBlock;
    uint64_t v29 = 0x40000000LL;
    int v30 = ___mdns_dns_service_manager_remove_unused_services_block_invoke;
    unsigned int v31 = &__block_descriptor_tmp_99;
    unsigned int v32 = (Block_layout *)v2;
    unsigned int v33 = _NSConcreteStackBlock;
    uint64_t v34 = 0x40000000LL;
    char v35 = ___mdns_dns_service_manager_enumerate_all_service_arrays_block_invoke;
    uint64_t v36 = &unk_10013B1B0;
    CFIndex v37 = &v28;
    _mdns_dns_service_manager_enumerate_all_service_array_pointers(v2, (uint64_t)&v33);
    uint64_t v3 = *(void *)(a1 + 32);
    unsigned int v33 = _NSConcreteStackBlock;
    uint64_t v34 = 0x40000000LL;
    char v35 = ___mdns_dns_service_manager_enumerate_all_service_arrays_block_invoke;
    uint64_t v36 = &unk_10013B1B0;
    CFIndex v37 = (void ***)&__block_literal_global_130;
    _mdns_dns_service_manager_enumerate_all_service_array_pointers(v3, (uint64_t)&v33);
    uint64_t v4 = *(void *)(a1 + 32);
    uint64_t v19 = _NSConcreteStackBlock;
    uint64_t v20 = 0x40000000LL;
    uint64_t v21 = ___mdns_dns_service_manager_handle_pending_alts_block_invoke;
    uint64_t v22 = &__block_descriptor_tmp_134;
    int v23 = (uint64_t *)v4;
    int v28 = _NSConcreteStackBlock;
    uint64_t v29 = 0x40000000LL;
    int v30 = ___mdns_dns_service_manager_enumerate_all_services_block_invoke;
    unsigned int v31 = &unk_10013B1D8;
    unsigned int v32 = (Block_layout *)&v19;
    unsigned int v33 = _NSConcreteStackBlock;
    uint64_t v34 = 0x40000000LL;
    char v35 = ___mdns_dns_service_manager_enumerate_all_service_arrays_block_invoke;
    uint64_t v36 = &unk_10013B1B0;
    CFIndex v37 = &v28;
    _mdns_dns_service_manager_enumerate_all_service_array_pointers(v4, (uint64_t)&v33);
    uint64_t v5 = *(void *)(a1 + 32);
    int v28 = _NSConcreteStackBlock;
    uint64_t v29 = 0x40000000LL;
    int v30 = ___mdns_dns_service_manager_enumerate_all_services_block_invoke;
    unsigned int v31 = &unk_10013B1D8;
    unsigned int v32 = &__block_literal_global_101;
    unsigned int v33 = _NSConcreteStackBlock;
    uint64_t v34 = 0x40000000LL;
    char v35 = ___mdns_dns_service_manager_enumerate_all_service_arrays_block_invoke;
    uint64_t v36 = &unk_10013B1B0;
    CFIndex v37 = &v28;
    _mdns_dns_service_manager_enumerate_all_service_array_pointers(v5, (uint64_t)&v33);
    uint64_t v6 = *(void *)(a1 + 32);
    int v28 = _NSConcreteStackBlock;
    uint64_t v29 = 0x40000000LL;
    int v30 = ___mdns_dns_service_manager_enumerate_all_services_block_invoke;
    unsigned int v31 = &unk_10013B1D8;
    unsigned int v32 = &__block_literal_global_120;
    unsigned int v33 = _NSConcreteStackBlock;
    uint64_t v34 = 0x40000000LL;
    char v35 = ___mdns_dns_service_manager_enumerate_all_service_arrays_block_invoke;
    uint64_t v36 = &unk_10013B1B0;
    CFIndex v37 = &v28;
    _mdns_dns_service_manager_enumerate_all_service_array_pointers(v6, (uint64_t)&v33);
    _mdns_dns_service_manager_remove_unneeded_interface_monitors(*(void *)(a1 + 32));
    uint64_t v7 = *(void *)(a1 + 32);
    uint64_t v19 = _NSConcreteStackBlock;
    uint64_t v20 = 0x40000000LL;
    uint64_t v21 = ___mdns_dns_service_manager_update_interface_properties_block_invoke;
    uint64_t v22 = &__block_descriptor_tmp_117;
    int v23 = (uint64_t *)v7;
    int v28 = _NSConcreteStackBlock;
    uint64_t v29 = 0x40000000LL;
    int v30 = ___mdns_dns_service_manager_enumerate_all_services_block_invoke;
    unsigned int v31 = &unk_10013B1D8;
    unsigned int v32 = (Block_layout *)&v19;
    unsigned int v33 = _NSConcreteStackBlock;
    uint64_t v34 = 0x40000000LL;
    char v35 = ___mdns_dns_service_manager_enumerate_all_service_arrays_block_invoke;
    uint64_t v36 = &unk_10013B1B0;
    CFIndex v37 = &v28;
    _mdns_dns_service_manager_enumerate_all_service_array_pointers(v7, (uint64_t)&v33);
    uint64_t v8 = *(void *)(a1 + 32);
    uint64_t v24 = 0LL;
    int v25 = &v24;
    uint64_t v26 = 0x2000000000LL;
    char v27 = 0;
    uint64_t v19 = _NSConcreteStackBlock;
    uint64_t v20 = 0x40000000LL;
    uint64_t v21 = ___mdns_dns_service_manager_update_policies_block_invoke;
    uint64_t v22 = &unk_10013ABA8;
    int v23 = &v24;
    int v28 = _NSConcreteStackBlock;
    uint64_t v29 = 0x40000000LL;
    int v30 = ___mdns_dns_service_manager_enumerate_all_services_block_invoke;
    unsigned int v31 = &unk_10013B1D8;
    unsigned int v32 = (Block_layout *)&v19;
    unsigned int v33 = _NSConcreteStackBlock;
    uint64_t v34 = 0x40000000LL;
    char v35 = ___mdns_dns_service_manager_enumerate_all_service_arrays_block_invoke;
    uint64_t v36 = &unk_10013B1B0;
    CFIndex v37 = &v28;
    _mdns_dns_service_manager_enumerate_all_service_array_pointers(v8, (uint64_t)&v33);
    int v9 = *(void **)(v8 + 112);
    if (*((_BYTE *)v25 + 24))
    {
      if (!v9)
      {
        int v10 = objc_autoreleasePoolPush();
        if (objc_opt_class(&OBJC_CLASS___NEPolicySession))
        {
          id v11 = [[NEPolicySession alloc] initFromPrivilegedProcess];
          [v11 setPriority:500];
          uint64_t v12 = -[NSUUID initWithUUIDBytes:]( objc_alloc(&OBJC_CLASS___NSUUID),  "initWithUUIDBytes:",  &ne_privacy_proxy_netagent_id);
          uint64_t v13 = (void *)objc_claimAutoreleasedReturnValue( +[NEPolicyResult removeNetworkAgentUUID:]( &OBJC_CLASS___NEPolicyResult,  "removeNetworkAgentUUID:",  v12));
          id v14 = objc_alloc(&OBJC_CLASS___NEPolicy);
          uint64_t v15 = (void **)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition allInterfaces](&OBJC_CLASS___NEPolicyCondition, "allInterfaces"));
          unsigned int v33 = v15;
          uint64_t v16 = (void *)objc_claimAutoreleasedReturnValue( +[NEPolicyCondition flowRemoteAddressEmpty]( &OBJC_CLASS___NEPolicyCondition,  "flowRemoteAddressEmpty"));
          uint64_t v34 = (uint64_t)v16;
          uint64_t v17 = (void *)objc_claimAutoreleasedReturnValue( +[NSArray arrayWithObjects:count:]( &OBJC_CLASS___NSArray,  "arrayWithObjects:count:",  &v33,  2LL));
          id v18 = [v14 initWithOrder:0 result:v13 conditions:v17];
          [v11 addPolicy:v18];

          [v11 apply];
        }

        else
        {
          id v11 = 0LL;
        }

        objc_autoreleasePoolPop(v10);
        goto LABEL_9;
      }
    }

    else if (v9)
    {
      mdns_system_remove_network_policy(v9);
      id v11 = 0LL;
LABEL_9:
      *(void *)(v8 + 112) = v11;
    }

    _Block_object_dispose(&v24, 8);
  }

uint64_t ___mdns_dns_service_manager_remove_unused_services_block_invoke(uint64_t a1, CFArrayRef theArray)
{
  CFIndex Count = CFArrayGetCount(theArray);
  if (Count - 1 >= 0)
  {
    CFIndex v5 = Count;
    do
    {
      uint64_t ValueAtIndex = CFArrayGetValueAtIndex(theArray, --v5);
      if (!ValueAtIndex[66])
      {
        _mdns_dns_service_manager_terminate_service(*(void *)(a1 + 32), (uint64_t)ValueAtIndex);
        CFArrayRemoveValueAtIndex(theArray, v5);
      }
    }

    while (v5 > 0);
  }

  return 1LL;
}

uint64_t ___mdns_dns_service_manager_handle_pending_alts_block_invoke(uint64_t a1, uint64_t a2)
{
  if (*(_BYTE *)(a2 + 287))
  {
    *(_BYTE *)(a2 + 287) = 0;
    uint64_t v4 = *(const __CFArray **)(a2 + 152);
    if (v4)
    {
      if (CFArrayGetCount(v4) >= 1)
      {
        v9[0] = _NSConcreteStackBlock;
        v9[1] = 0x40000000LL;
        v9[2] = ___mdns_dns_service_manager_handle_pending_alts_block_invoke_2;
        v9[3] = &__block_descriptor_tmp_133;
        uint64_t v5 = *(void *)(a1 + 32);
        v9[4] = a2;
        void v9[5] = v5;
        uint64_t v6 = *(const __CFArray **)(a2 + 144);
        if (v6)
        {
          mdns_cfarray_enumerate(v6, (uint64_t)v9);
          uint64_t v7 = *(const void **)(a2 + 144);
          if (v7) {
            CFRelease(v7);
          }
        }

        *(void *)(a2 + 144) = *(void *)(a2 + 152);
        *(void *)(a2 + 152) = 0LL;
      }
    }
  }

  return 1LL;
}

uint64_t ___mdns_dns_service_manager_update_interface_properties_block_invoke(uint64_t a1, uint64_t a2)
{
  return 1LL;
}

BOOL ___mdns_dns_service_manager_update_policies_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t preferred_encrypted_alt = _mdns_dns_service_get_preferred_encrypted_alt(a2, 1);
  if (preferred_encrypted_alt) {
    *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 1;
  }
  return preferred_encrypted_alt == 0;
}

BOOL ___mdns_dns_service_manager_update_nw_config_data_block_invoke(id a1, const mdns_dns_service_s *a2)
{
  return 1;
}

BOOL ___mdns_dns_service_manager_update_service_usability_block_invoke(id a1, const mdns_dns_service_s *a2)
{
  unsigned __int16 var32 = a2->var32;
  if (a2->var37)
  {
    if ((a2->var32 & 0x800) == 0)
    {
      unsigned __int16 v3 = var32 | 0x800;
LABEL_6:
      a2->unsigned __int16 var32 = v3;
    }
  }

  else if ((a2->var32 & 0x800) != 0)
  {
    unsigned __int16 v3 = var32 & 0xF7FF;
    goto LABEL_6;
  }

  return 1;
}

uint64_t ___mdns_dns_service_manager_handle_pending_alts_block_invoke_2(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(const __CFArray **)(*(void *)(a1 + 32) + 152LL);
  *(void *)&__int128 v8 = _NSConcreteStackBlock;
  *((void *)&v8 + 1) = 0x40000000LL;
  int v9 = ___mdns_dns_service_array_contains_service_block_invoke;
  int v10 = &__block_descriptor_tmp_135;
  uint64_t v11 = a2;
  if (mdns_cfarray_enumerate(v4, (uint64_t)&v8))
  {
    _mdns_dns_service_manager_terminate_service(*(void *)(a1 + 40), a2);
    if (_mdns_dns_service_log_s_once != -1) {
      dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_62);
    }
    uint64_t v5 = (os_log_s *)_mdns_dns_service_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_INFO))
    {
      uint64_t v6 = *(void *)(a2 + 24);
      LODWORD(v_Block_object_dispose(va, 8) = 134217984;
      *(void *)((char *)&v8 + 4) = v6;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_INFO,  "Deregistered discovered service -- id: %llu",  (uint8_t *)&v8,  0xCu);
    }
  }

  return 1LL;
}

BOOL ___mdns_dns_service_manager_handle_network_changes_block_invoke(id a1, const __CFArray *a2)
{
  return 1;
}

BOOL ___mdns_dns_service_manager_handle_network_changes_block_invoke_2(id a1, const mdns_dns_service_s *a2)
{
  if (a2->var40)
  {
    a2->var40 = 0;
    _mdns_dns_service_make_defunct((uint64_t)a2);
  }

  var11 = a2->var11;
  if (var11)
  {
    CFIndex Count = CFArrayGetCount(var11);
    if (Count - 1 >= 0)
    {
      CFIndex v5 = Count;
      do
      {
        uint64_t ValueAtIndex = CFArrayGetValueAtIndex(a2->var11, --v5);
        if (ValueAtIndex[286])
        {
          ValueAtIndex[286] = 0;
          _mdns_dns_service_make_defunct((uint64_t)ValueAtIndex);
          CFArrayRemoveValueAtIndex(a2->var11, v5);
        }
      }

      while (v5 > 0);
    }
  }

  return 1;
}

uint64_t __mdns_dns_service_manager_apply_pending_connection_problem_updates_block_invoke(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 32);
  if (!*(_BYTE *)(result + 131))
  {
    v2[0] = _NSConcreteStackBlock;
    v2[2] = ___mdns_dns_service_manager_enumerate_all_services_block_invoke;
    v2[3] = &unk_10013B1D8;
    v2[1] = 0x40000000LL;
    v2[4] = &__block_literal_global_101;
    v3[0] = _NSConcreteStackBlock;
    v3[1] = 0x40000000LL;
    v3[2] = ___mdns_dns_service_manager_enumerate_all_service_arrays_block_invoke;
    v3[3] = &unk_10013B1B0;
    v3[4] = v2;
    return _mdns_dns_service_manager_enumerate_all_service_array_pointers(result, (uint64_t)v3);
  }

  return result;
}

void mdns_dns_service_manager_enumerate(uint64_t a1, uint64_t a2)
{
  v5[0] = 0LL;
  v5[1] = v5;
  v5[2] = 0x2000000000LL;
  char v6 = 0;
  if (_mdns_dns_service_queue_s_once != -1) {
    dispatch_once(&_mdns_dns_service_queue_s_once, &__block_literal_global_237);
  }
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000LL;
  block[2] = __mdns_dns_service_manager_enumerate_block_invoke;
  block[3] = &unk_10013A560;
  void block[5] = v5;
  block[6] = a1;
  void block[4] = a2;
  dispatch_sync((dispatch_queue_t)_mdns_dns_service_queue_s_queue, block);
  _Block_object_dispose(v5, 8);
}

uint64_t __mdns_dns_service_manager_enumerate_block_invoke(void *a1)
{
  uint64_t result = a1[6];
  if (*(_BYTE *)(result + 131))
  {
    *(_BYTE *)(*(void *)(a1[5] + 8LL) + 24LL) = 1;
  }

  else
  {
    uint64_t v3 = a1[4];
    v4[0] = _NSConcreteStackBlock;
    v4[1] = 0x40000000LL;
    v4[2] = ___mdns_dns_service_manager_enumerate_all_services_block_invoke;
    v4[3] = &unk_10013B1D8;
    v4[4] = v3;
    v5[0] = _NSConcreteStackBlock;
    v5[1] = 0x40000000LL;
    v5[2] = ___mdns_dns_service_manager_enumerate_all_service_arrays_block_invoke;
    void v5[3] = &unk_10013B1B0;
    v5[4] = v4;
    uint64_t result = _mdns_dns_service_manager_enumerate_all_service_array_pointers(result, (uint64_t)v5);
    *(_BYTE *)(*(void *)(a1[5] + 8LL) + 24LL) = result;
  }

  return result;
}

uint64_t __mdns_dns_service_manager_get_count_block_invoke(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 40);
  if (!*(_BYTE *)(result + 131))
  {
    v3[0] = _NSConcreteStackBlock;
    v3[1] = 0x40000000LL;
    v3[2] = __mdns_dns_service_manager_get_count_block_invoke_2;
    v3[3] = &unk_10013A5B0;
    v3[4] = *(void *)(a1 + 32);
    v4[0] = _NSConcreteStackBlock;
    v4[1] = 0x40000000LL;
    v4[2] = ___mdns_dns_service_manager_enumerate_all_service_arrays_block_invoke;
    v4[3] = &unk_10013B1B0;
    v4[4] = v3;
    return _mdns_dns_service_manager_enumerate_all_service_array_pointers(result, (uint64_t)v4);
  }

  return result;
}

uint64_t __mdns_dns_service_manager_get_count_block_invoke_2(uint64_t a1, const __CFArray *a2)
{
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 0x40000000LL;
  v3[2] = __mdns_dns_service_manager_get_count_block_invoke_3;
  v3[3] = &unk_10013A588;
  v3[4] = *(void *)(a1 + 32);
  mdns_cfarray_enumerate(a2, (uint64_t)v3);
  return 1LL;
}

uint64_t __mdns_dns_service_manager_get_count_block_invoke_3(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(const __CFArray **)(a2 + 128);
  if (v4)
  {
    CFIndex Count = CFArrayGetCount(v4);
    if (Count >= 1) {
      *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) += Count;
    }
  }

  char v6 = *(const __CFArray **)(a2 + 144);
  if (v6)
  {
    CFIndex v7 = CFArrayGetCount(v6);
    if (v7 >= 1) {
      *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) += v7;
    }
  }

  return 1LL;
}

BOOL __mdns_dns_service_manager_handle_sleep_block_invoke(id a1, const mdns_dns_service_s *a2)
{
  if (a2->var35 - 2 <= 2)
  {
    var3 = a2->var3;
    if (var3)
    {
      mdns_resolver_invalidate(var3);
      os_release(a2->var3);
      a2->var3 = 0LL;
      a2->var39 = 1;
    }
  }

  return 1;
}

uint64_t __mdns_dns_service_manager_handle_wake_block_invoke(uint64_t a1, uint64_t a2)
{
  if (*(_BYTE *)(a2 + 285))
  {
    _mdns_dns_service_manager_prepare_service(*(void *)(a1 + 32), a2);
    *(_BYTE *)(a2 + 285) = 0;
  }

  return 1LL;
}

void __dnssd_server_init_block_invoke(id a1)
{
  if (_dx_server_queue_once != -1) {
    dispatch_once(&_dx_server_queue_once, &__block_literal_global_20);
  }
  dnssd_server_init_s_listener = (uint64_t)xpc_connection_create_mach_service( "com.apple.dnssd.service",  (dispatch_queue_t)_dx_server_queue_queue,  1uLL);
  xpc_connection_set_event_handler((xpc_connection_t)dnssd_server_init_s_listener, &__block_literal_global_4);
  xpc_connection_activate((xpc_connection_t)dnssd_server_init_s_listener);
  if (_dx_server_queue_once != -1) {
    dispatch_once(&_dx_server_queue_once, &__block_literal_global_20);
  }
  monotonic_timer = _mdns_dispatch_create_monotonic_timer( 0x1B7740u,  0x1A3185C5000uLL,  5u,  (dispatch_queue_s *)_dx_server_queue_queue);
  dnssd_server_init_s_powerlog_progress_timer = (uint64_t)monotonic_timer;
  if (monotonic_timer)
  {
    dispatch_source_set_event_handler(monotonic_timer, &__block_literal_global_6);
    dispatch_activate((dispatch_object_t)dnssd_server_init_s_powerlog_progress_timer);
  }

  else
  {
    if (_mdns_server_log_s_once != -1) {
      dispatch_once(&_mdns_server_log_s_once, &__block_literal_global_16);
    }
    uint64_t v2 = (os_log_s *)_mdns_server_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_server_log_s_log, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)uint64_t v3 = 0;
      _os_log_fault_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_FAULT,  "Failed to create periodic powerlog report timer",  v3,  2u);
    }
  }

void ___mdns_server_log_block_invoke(id a1)
{
  _mdns_server_log_s_log = (uint64_t)os_log_create("com.apple.mdns", "dnssd_server");
}

void __dnssd_server_init_block_invoke_3(id a1)
{
  if (_mdns_server_log_s_once != -1) {
    dispatch_once(&_mdns_server_log_s_once, &__block_literal_global_16);
  }
  uint64_t v1 = (os_log_s *)_mdns_server_log_s_log;
  if (os_log_type_enabled((os_log_t)_mdns_server_log_s_log, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_debug_impl( (void *)&_mh_execute_header,  v1,  OS_LOG_TYPE_DEBUG,  "periodic powerlog report timer fired",  buf,  2u);
  }

  uint64_t v2 = pthread_mutex_lock((pthread_mutex_t *)(mDNSStorage[0] + 616));
  *(_DWORD *)(mDNSStorage[0] + 680) = mDNSPlatformRawTime(v2, v3, v4, v5, v6, v7, v8, v9);
  CFMutableArrayRef Mutable = CFDictionaryCreateMutable(0LL, 0LL, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (!Mutable)
  {
    if (_mdns_powerlog_log_s_once != -1) {
      dispatch_once(&_mdns_powerlog_log_s_once, &__block_literal_global_1361);
    }
    uint64_t v11 = (os_log_s *)_mdns_powerlog_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_powerlog_log_s_log, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_fault_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_FAULT,  "Failed to create top-level client summary dictionary",  buf,  2u);
    }
  }

  __uint64_t monotonic_time_ns = _mdns_powerlog_get_monotonic_time_ns();
  uint64_t v20 = g_client_info_list;
  __int128 v52 = (void *)g_client_info_list;
  if (g_client_info_list)
  {
    __uint64_t v21 = monotonic_time_ns;
    uint64_t v22 = &g_client_info_list;
    do
    {
      if (*(_DWORD *)(v20 + 24))
      {
        uint64_t v23 = *(void *)(v20 + 8);
        __uint64_t v24 = v21 - *(void *)v20;
        BOOL v25 = __CFADD__(v23, v24);
        uint64_t v26 = v23 + v24;
        if (v25) {
          uint64_t v26 = -1LL;
        }
        *(void *)(v20 + _Block_object_dispose(va, 8) = v26;
      }

      *(void *)uint64_t v20 = v21;
      if (*(_DWORD *)(v20 + 56))
      {
        uint64_t v27 = *(void *)(v20 + 40);
        __uint64_t v28 = v21 - *(void *)(v20 + 32);
        BOOL v25 = __CFADD__(v27, v28);
        uint64_t v29 = v27 + v28;
        if (v25) {
          uint64_t v29 = -1LL;
        }
        *(void *)(v20 + 40) = v29;
      }

      *(void *)(v20 + 32) = v21;
      if (!Mutable) {
        goto LABEL_51;
      }
      int v30 = *(__CFDictionary **)(v20 + 72);
      if (v30)
      {
        CFStringRef v31 = CFStringCreateWithFormat(0LL, 0LL, @"%s/%s", v20 + 80, v30);
        if (v31)
        {
          CFStringRef v32 = v31;
          unsigned int v33 = CFDictionaryCreateMutable(0LL, 0LL, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
          if (v33) {
            goto LABEL_32;
          }
          if (_mdns_powerlog_log_s_once != -1) {
            dispatch_once(&_mdns_powerlog_log_s_once, &__block_literal_global_1361);
          }
          uint64_t v34 = _mdns_powerlog_log_s_log;
          if (!os_log_type_enabled((os_log_t)_mdns_powerlog_log_s_log, OS_LOG_TYPE_FAULT)) {
            goto LABEL_49;
          }
          *(_DWORD *)__int128 buf = 136446467;
          CFStringRef v54 = (CFStringRef)(v20 + 80);
          __int16 v55 = 2081;
          BOOL v56 = v30;
          char v35 = (os_log_s *)v34;
          uint64_t v36 = "Failed to create powerlog client dictionary -- client name: %{public}s, service type: %{private}s";
          uint32_t v37 = 22;
          goto LABEL_57;
        }

        if (_mdns_powerlog_log_s_once != -1) {
          dispatch_once(&_mdns_powerlog_log_s_once, &__block_literal_global_1361);
        }
        uint64_t v42 = _mdns_powerlog_log_s_log;
        if (!os_log_type_enabled((os_log_t)_mdns_powerlog_log_s_log, OS_LOG_TYPE_FAULT)) {
          goto LABEL_51;
        }
        *(_DWORD *)__int128 buf = 136446467;
        CFStringRef v54 = (CFStringRef)(v20 + 80);
        __int16 v55 = 2081;
        BOOL v56 = v30;
        uint64_t v43 = (os_log_s *)v42;
        int v44 = "Failed to create powerlog client name/service type string for client dictionary -- client name: %{public}s"
              ", service type: %{private}s";
        uint32_t v45 = 22;
      }

      else
      {
        CFStringRef v38 = CFStringCreateWithCString(0LL, (const char *)(v20 + 80), 0x8000100u);
        if (v38)
        {
          CFStringRef v32 = v38;
          unsigned int v33 = CFDictionaryCreateMutable(0LL, 0LL, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
          if (v33)
          {
LABEL_32:
            BOOL v39 = v33;
            _mdns_powerlog_set_client_stats( v33,  v20,  @"durationInfra",  @"startCountInfra",  @"stopCountInfra",  @"carryoverCountInfra");
            _mdns_powerlog_set_client_stats( v39,  v20 + 32,  @"durationAWDL",  @"startCountAWDL",  @"stopCountAWDL",  @"carryoverCountAWDL");
            CFDictionarySetValue(Mutable, v32, v39);
            if (_mdns_powerlog_log_s_once != -1) {
              dispatch_once(&_mdns_powerlog_log_s_once, &__block_literal_global_1361);
            }
            size_t v40 = (os_log_s *)_mdns_powerlog_log_s_log;
            if (os_log_type_enabled((os_log_t)_mdns_powerlog_log_s_log, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)__int128 buf = 138412546;
              CFStringRef v54 = v32;
              __int16 v55 = 2112;
              BOOL v56 = v39;
              _os_log_debug_impl( (void *)&_mh_execute_header,  v40,  OS_LOG_TYPE_DEBUG,  "Will submit client dictionary -- client name: %@, dictionary: %@",  buf,  0x16u);
            }

            CFRelease(v32);
            uint64_t v41 = v39;
            goto LABEL_50;
          }

          if (_mdns_powerlog_log_s_once != -1) {
            dispatch_once(&_mdns_powerlog_log_s_once, &__block_literal_global_1361);
          }
          uint64_t v47 = _mdns_powerlog_log_s_log;
          if (!os_log_type_enabled((os_log_t)_mdns_powerlog_log_s_log, OS_LOG_TYPE_FAULT))
          {
LABEL_49:
            uint64_t v41 = (__CFDictionary *)v32;
LABEL_50:
            CFRelease(v41);
            goto LABEL_51;
          }

          *(_DWORD *)__int128 buf = 136446210;
          CFStringRef v54 = (CFStringRef)(v20 + 80);
          char v35 = (os_log_s *)v47;
          uint64_t v36 = "Failed to create powerlog client dictionary -- client name: %{public}s";
          uint32_t v37 = 12;
LABEL_57:
          _os_log_fault_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_FAULT, v36, buf, v37);
          goto LABEL_49;
        }

        if (_mdns_powerlog_log_s_once != -1) {
          dispatch_once(&_mdns_powerlog_log_s_once, &__block_literal_global_1361);
        }
        uint64_t v46 = _mdns_powerlog_log_s_log;
        if (!os_log_type_enabled((os_log_t)_mdns_powerlog_log_s_log, OS_LOG_TYPE_FAULT)) {
          goto LABEL_51;
        }
        *(_DWORD *)__int128 buf = 136446210;
        CFStringRef v54 = (CFStringRef)(v20 + 80);
        uint64_t v43 = (os_log_s *)v46;
        int v44 = "Failed to create powerlog client name string for client dictionary -- client name: %{public}s";
        uint32_t v45 = 12;
      }

      _os_log_fault_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_FAULT, v44, buf, v45);
LABEL_51:
      int v48 = *(_DWORD *)(v20 + 24);
      int v49 = *(_DWORD *)(v20 + 56);
      if (v48 | v49)
      {
        *(void *)(v20 + _Block_object_dispose(va, 8) = 0LL;
        *(void *)(v20 + 16) = 0LL;
        *(_DWORD *)(v20 + 2_Block_object_dispose(va, 8) = v48;
        *(void *)(v20 + 40) = 0LL;
        *(void *)(v20 + 4_Block_object_dispose(va, 8) = 0LL;
        *(_DWORD *)(v20 + 60) = v49;
        uint64_t v22 = v52 + 8;
      }

      else
      {
        *uint64_t v22 = *(void *)(v20 + 64);
        v52[8] = 0LL;
        _mdns_powerlog_client_info_forget(&v52);
      }

      uint64_t v20 = *v22;
      __int128 v52 = (void *)v20;
    }

    while (v20);
  }

  if (Mutable)
  {
    if (_mdns_powerlog_log_s_once != -1) {
      dispatch_once(&_mdns_powerlog_log_s_once, &__block_literal_global_1361);
    }
    uint64_t v50 = (os_log_s *)_mdns_powerlog_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_powerlog_log_s_log, OS_LOG_TYPE_DEBUG))
    {
      CFIndex Count = CFDictionaryGetCount(Mutable);
      *(_DWORD *)__int128 buf = 134218242;
      CFStringRef v54 = (CFStringRef)Count;
      __int16 v55 = 2112;
      BOOL v56 = Mutable;
      _os_log_debug_impl( (void *)&_mh_execute_header,  v50,  OS_LOG_TYPE_DEBUG,  "Submitting client summary dictionary with %lld entries: %@",  buf,  0x16u);
    }

    if (&_PLLogRegisteredEvent) {
      PLLogRegisteredEvent(98LL, @"clientSummary", Mutable, 0LL);
    }
    CFRelease(Mutable);
  }

  KQueueUnlock((uint64_t)"dnssd_server: submitting client summary to powerlog", v13, v14, v15, v16, v17, v18, v19);
}

void __dnssd_server_init_block_invoke_2(id a1, void *a2)
{
  if (xpc_get_type(a2) != (xpc_type_t)&_xpc_type_connection) {
    return;
  }
  uint64_t v4 = calloc(1uLL, 0x68uLL);
  if (v4)
  {
    uint64_t v2 = (uint64_t)v4;
    *(void *)uint64_t v4 = &_dx_session_kind;
    v4[2] = 1;
    _dx_recursive_init((uint64_t)v4, &_dx_session_kind);
    *(void *)(v2 + 32) = a2;
    xpc_retain(a2);
    memset(handler, 0, sizeof(handler));
    xpc_connection_get_audit_token(*(void *)(v2 + 32), handler);
    uint64_t v5 = mdns_audit_token_create(handler);
    *(void *)(v2 + 64) = v5;
    if (v5)
    {
      uint64_t v6 = (unsigned int *)(v2 + 8);
      *(_DWORD *)(v2 + 76) = xpc_connection_get_pid(*(xpc_connection_t *)(v2 + 32));
      *(_DWORD *)(v2 + 72) = xpc_connection_get_euid(*(xpc_connection_t *)(v2 + 32));
      mdns_system_pid_to_name(*(_DWORD *)(v2 + 76), v2 + 84);
      do
        unsigned int v7 = __ldaxr(v6);
      while (__stlxr(v7 + 1, v6));
      uint64_t v8 = *(_xpc_connection_s **)(v2 + 32);
      if (_dx_server_queue_once != -1) {
        dispatch_once(&_dx_server_queue_once, &__block_literal_global_20);
      }
      xpc_connection_set_target_queue(v8, (dispatch_queue_t)_dx_server_queue_queue);
      uint64_t v9 = *(_xpc_connection_s **)(v2 + 32);
      *(void *)&handler[0] = _NSConcreteStackBlock;
      *((void *)&handler[0] + 1) = 0x40000000LL;
      *(void *)&handler[1] = ___dx_session_activate_block_invoke;
      *((void *)&handler[1] + 1) = &__block_descriptor_tmp_27_922;
      uint64_t v18 = v2;
      xpc_connection_set_event_handler(v9, handler);
      xpc_connection_activate(*(xpc_connection_t *)(v2 + 32));
      _dx_session_reset_idle_timer(v2);
      int v10 = &g_session_list;
      do
      {
        uint64_t v11 = v10;
        uint64_t v12 = *v10;
        int v10 = (uint64_t *)(*v10 + 16);
      }

      while (v12);
      *(void *)(v2 + 16) = 0LL;
      *uint64_t v11 = v2;
      do
        unsigned int v13 = __ldaxr(v6);
      while (__stlxr(v13 + 1, v6));
      _dx_release((char *)v2);
      return;
    }
  }

  else
  {
    __break(1u);
  }

  _dx_release((char *)v2);
  pid_t pid = xpc_connection_get_pid((xpc_connection_t)a2);
  v16[0] = 0LL;
  v16[1] = 0LL;
  mdns_system_pid_to_name(pid, (uint64_t)v16);
  if (_mdns_server_log_s_once != -1) {
    dispatch_once(&_mdns_server_log_s_once, &__block_literal_global_16);
  }
  uint64_t v15 = (os_log_s *)_mdns_server_log_s_log;
  if (os_log_type_enabled((os_log_t)_mdns_server_log_s_log, OS_LOG_TYPE_FAULT))
  {
    LODWORD(handler[0]) = 67109378;
    DWORD1(handler[0]) = pid;
    WORD4(handler[0]) = 2082;
    *(void *)((char *)handler + 10) = v16;
    _os_log_fault_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_FAULT,  "Failed to create session for connection -- client pid: %d (%{public}s)",  (uint8_t *)handler,  0x12u);
  }

  xpc_connection_cancel((xpc_connection_t)a2);
}

uint64_t _dx_recursive_init(uint64_t result, void *a2)
{
  uint64_t v3 = result;
  if (*a2) {
    uint64_t result = _dx_recursive_init(result);
  }
  uint64_t v4 = (uint64_t (*)(uint64_t))a2[1];
  if (v4) {
    return v4(v3);
  }
  return result;
}

void ___dx_session_activate_block_invoke(uint64_t a1, xpc_object_t object)
{
  if (xpc_get_type(object) == (xpc_type_t)&_xpc_type_dictionary)
  {
    uint64_t v6 = *(void *)(a1 + 32);
    if (!*(void *)(v6 + 32)) {
      return;
    }
    int v7 = -65540;
    string = xpc_dictionary_get_string(object, "command");
    if (!string) {
      goto LABEL_152;
    }
    uint64_t v9 = string;
    if (strcmp(string, "getaddrinfo"))
    {
      if (!strcmp(v9, "stop"))
      {
        length[0] = 0;
        xpc_object_t value = xpc_dictionary_get_value(object, "id");
        unsigned int uint64_limited = _mdns_xpc_object_get_uint64_limited(value, 0xFFFFFFFFFFFFFFFFLL, length);
        if (length[0])
        {
          uint64_t v12 = (void *)(v6 + 24);
          uint64_t v13 = *(void *)(v6 + 24);
          int v7 = -65541;
          if (v13)
          {
            if (*(void **)(v13 + 40) == uint64_limited)
            {
LABEL_15:
              *uint64_t v12 = *(void *)(v13 + 16);
              *(void *)(v13 + 16) = 0LL;
              uint64_t v15 = (void *)v13;
              while (1)
              {
                uint64_t v15 = (void *)*v15;
                if (!v15) {
                  break;
                }
                uint64_t v16 = (void (*)(uint64_t))v15[2];
                if (v16)
                {
                  v16(v13);
                  break;
                }
              }

              _dx_release((char *)v13);
              int v7 = 0;
            }

            else
            {
              while (1)
              {
                uint64_t v14 = v13;
                uint64_t v13 = *(void *)(v13 + 16);
                if (!v13) {
                  break;
                }
                if (*(void **)(v13 + 40) == uint64_limited)
                {
                  uint64_t v12 = (void *)(v14 + 16);
                  goto LABEL_15;
                }
              }
            }
          }
        }
      }

      goto LABEL_152;
    }

    BOOL v149 = 0;
    xpc_object_t v21 = xpc_dictionary_get_value(object, "id");
    uint64_t v22 = _mdns_xpc_object_get_uint64_limited(v21, 0xFFFFFFFFFFFFFFFFLL, &v149);
    if (!v149) {
      goto LABEL_157;
    }
    int32x2_t v23 = (int32x2_t)v22;
    xpc_object_t dictionary = xpc_dictionary_get_dictionary(object, "params");
    if (!dictionary) {
      goto LABEL_157;
    }
    BOOL v25 = dictionary;
    uint64_t v26 = (int32x2_t *)calloc(1uLL, 0xF8uLL);
    if (v26)
    {
      uint64_t v27 = v26;
      int32x2_t *v26 = (int32x2_t)&_dx_gai_request_kind;
      __uint64_t v28 = (unsigned int *)&v26[1];
      v26[1].i32[0] = 1;
      _dx_recursive_init((uint64_t)v26, &_dx_gai_request_kind);
      v27[5] = v23;
      v27[3] = (int32x2_t)v6;
      uint64_t v29 = (unsigned int *)(v6 + 8);
      do
        unsigned int v30 = __ldaxr(v29);
      while (__stlxr(v30 + 1, v29));
      CFStringRef v31 = xpc_dictionary_get_string(v25, "hostname");
      uint64_t v148 = v6;
      if (!v31) {
        goto LABEL_146;
      }
      CFStringRef v32 = strdup(v31);
      if (v32)
      {
        v27[13] = (int32x2_t)v32;
        BOOL v153 = 0;
        xpc_object_t v33 = xpc_dictionary_get_value(v25, "flags");
        v27[26].i32[0] = _mdns_xpc_object_get_uint64_limited(v33, 0xFFFFFFFFuLL, &v153);
        if (v153)
        {
          xpc_object_t v34 = xpc_dictionary_get_value(v25, "interface_index");
          v27[26].i32[1] = _mdns_xpc_object_get_uint64_limited(v34, 0xFFFFFFFFuLL, &v153);
          if (v153)
          {
            xpc_object_t v35 = xpc_dictionary_get_value(v25, "protocols");
            v27[27].i32[0] = _mdns_xpc_object_get_uint64_limited(v35, 0xFFFFFFFFuLL, &v153);
            int v36 = -65540;
            if (!v153) {
              goto LABEL_147;
            }
            int32x2_t v37 = v27[3];
            __int128 v151 = 0u;
            __int128 v152 = 0u;
            *(void *)size_t length = 0LL;
            data = (__int128 *)xpc_dictionary_get_data(v25, "delegate_id", (size_t *)length);
            if (data && *(void *)length == 32LL)
            {
              __int128 v39 = data[1];
              __int128 v151 = *data;
              __int128 v152 = v39;
              uint64_t v40 = mdns_audit_token_create(&v151);
              v27[21] = (int32x2_t)v40;
              uint64_t v41 = v27 + 21;
              if (!v40) {
                goto LABEL_161;
              }
            }

            else
            {
              uint64_t v41 = v27 + 21;
              uint64_t v40 = (uint64_t)v27[21];
              if (!v40)
              {
                uuid = xpc_dictionary_get_uuid(v25, "delegate_id");
                if (uuid)
                {
                  int v44 = (unsigned __int8 *)uuid;
                  BOOL v47 = 0;
                  pid_t int64_limited = 0;
                  int v45 = 1;
                  goto LABEL_55;
                }

                pid_t int64_limited = _mdns_xpc_dictionary_get_int64_limited( v25,  "delegate_id",  0x8000000000000000LL,  0x7FFFFFFFFFFFFFFFLL,  0LL);
LABEL_45:
                int v44 = 0LL;
                int v45 = 0;
                int32x2_t v46 = *v41;
                BOOL v47 = int64_limited != 0;
                if (!*(void *)&v46 && !int64_limited)
                {
                  uuid_clear((unsigned __int8 *)&v27[28] + 2);
                  src = 0LL;
                  goto LABEL_48;
                }

LABEL_55:
                uint64_t v6 = (uint64_t)v37;
                uint64_t v55 = *(void *)(*(void *)&v37 + 32LL);
                int v36 = -65555;
                if (!v55) {
                  goto LABEL_147;
                }
                src = v44;
                BOOL v56 = (unsigned __int8 *)&v27[28] + 2;
                if (v45)
                {
                  uuid_copy(v56, src);
                  pid_t v48 = 0;
                  int32x2_t v37 = (int32x2_t)v6;
                  goto LABEL_49;
                }

                uuid_clear(v56);
                pid_t v48 = int64_limited;
                int32x2_t v37 = (int32x2_t)v6;
                if (v47) {
                  goto LABEL_49;
                }
LABEL_48:
                pid_t v48 = *(_DWORD *)(*(void *)&v37 + 76LL);
LABEL_49:
                int32x2_t v49 = v37;
                v27[27].i32[1] = v48;
                uint64_t v50 = xpc_dictionary_get_string(v25, "service_scheme");
                if (v50)
                {
                  __int128 v51 = v50;
                  if (!strcasecmp(v50, "_443._https"))
                  {
                    int32x2_t v52 = v27[13];
                    __int16 v53 = 65;
                  }

                  else
                  {
                    asprintf((char **)&v27[24], "%s.%s", v51, *(void *)&v27[13]);
                    int32x2_t v52 = v27[24];
                    if (!*(void *)&v52)
                    {
LABEL_161:
                      int v36 = -65539;
                      goto LABEL_147;
                    }

                    __int16 v53 = 64;
                  }

                  v27[17] = v52;
                  v27[28].i16[0] = v53;
                }

                xpc_object_t v57 = xpc_dictionary_get_value(v25, "fallback_config");
                v27[22] = (int32x2_t)v57;
                if (v57) {
                  xpc_retain(v57);
                }
                xpc_object_t v58 = xpc_dictionary_get_value(v25, "resolver_uuids");
                if (!v58 || (CFRange v59 = v58, !xpc_array_get_count(v58)) || (v60 = xpc_array_get_uuid(v59, 0LL)) == 0LL)
                {
LABEL_68:
                  if (xpc_dictionary_get_BOOL(v25, "need_encryption")) {
                    v27[30].i8[3] |= 2u;
                  }
                  unsigned int v63 = xpc_dictionary_get_string(v25, "account_id");
                  if (v63 && !strcmp(v63, "com.apple.WebKit.InAppBrowser")) {
                    v27[30].i8[3] |= 4u;
                  }
                  BOOL v64 = xpc_dictionary_get_BOOL(v25, "use_failover");
                  __int8 v65 = v27[30].i8[3];
                  if (v64)
                  {
                    v65 |= 8u;
                    v27[30].i8[3] = v65;
                  }

                  if ((v65 & 8) != 0)
                  {
                    int v66 = v27[27].i32[0] & 3;
                    __int8 v67 = v27[30].i8[2];
                    if (v66 == 2 || (v67 |= 1u, v27[30].i8[2] = v67, v66 != 1)) {
                      v27[30].i8[2] = v67 | 2;
                    }
                  }

                  length[0] = 0;
                  unsigned __int8 v68 = _mdns_xpc_dictionary_get_int64_limited( v25,  "log_privacy_level",  -128LL,  127LL,  length);
                  if (v68 >= 2u || length[0] == 0) {
                    unsigned __int8 v70 = 0;
                  }
                  else {
                    unsigned __int8 v70 = v68;
                  }
                  v27[30].i8[4] = v70;
                  if (xpc_dictionary_get_BOOL(v25, "prohibit_encrypted_dns"))
                  {
                    uint64_t v71 = *(void *)(*(void *)&v49 + 32LL);
                    int v36 = -65555;
                    if (!v71
                      || !mdns_xpc_connection_is_entitled( v71,  (uint64_t)"com.apple.private.dnssd.prohibit-encrypted-dns"))
                    {
                      goto LABEL_147;
                    }

                    v27[30].i8[3] |= 0x10u;
                  }

                  size_t v150 = 0LL;
                  uint64_t v72 = xpc_dictionary_get_data(v25, "validation_data", &v150);
                  if (v72)
                  {
                    LODWORD(v161[0]) = 0;
                    uint64_t v73 = mdns_signed_resolve_result_create_from_data((uint64_t)v72, v150, (int *)v161);
                    if (!v73)
                    {
                      if (_mdns_server_log_s_once != -1) {
                        dispatch_once(&_mdns_server_log_s_once, &__block_literal_global_16);
                      }
                      int v145 = (os_log_s *)_mdns_server_log_s_log;
                      if (os_log_type_enabled((os_log_t)_mdns_server_log_s_log, OS_LOG_TYPE_ERROR))
                      {
                        __int32 v146 = v27[6].i32[0];
                        *(_DWORD *)size_t length = 67109376;
                        *(_DWORD *)&length[4] = v146;
                        *(_WORD *)&length[8] = 2048;
                        *(void *)&length[10] = SLODWORD(v161[0]);
                        _os_log_error_impl( (void *)&_mh_execute_header,  v145,  OS_LOG_TYPE_ERROR,  "[R%u] Failed to create signed resolve result from data: %{mdns:err}ld",  length,  0x12u);
                      }

                      int v36 = -65549;
                      goto LABEL_147;
                    }

                    uint64_t v74 = (void *)v73;
                    if (!mdns_signed_resolve_result_contains(v73, *(char **)&v27[13], v27[26].u32[1]))
                    {
                      if (_mdns_server_log_s_once != -1) {
                        dispatch_once(&_mdns_server_log_s_once, &__block_literal_global_16);
                      }
                      int v76 = (os_log_s *)_mdns_server_log_s_log;
                      if (os_log_type_enabled((os_log_t)_mdns_server_log_s_log, OS_LOG_TYPE_ERROR))
                      {
                        __int32 v133 = v27[6].i32[0];
                        int32x2_t v134 = v27[13];
                        __int32 v135 = v27[26].i32[1];
                        *(_DWORD *)size_t length = 67109891;
                        *(_DWORD *)&length[4] = v133;
                        *(_WORD *)&length[8] = 2160;
                        *(void *)&length[10] = 1752392040LL;
                        *(_WORD *)&length[18] = 2081;
                        *(int32x2_t *)&length[20] = v134;
                        *(_WORD *)&length[28] = 1024;
                        *(_DWORD *)&length[30] = v135;
                        _os_log_error_impl( (void *)&_mh_execute_header,  v76,  OS_LOG_TYPE_ERROR,  "[R%u] Signed resolve result does not cover request -- hostname: %{private,mask.hash}s, ifindex: %u",  length,  0x22u);
                      }

      free((void *)v5);
LABEL_56:
      int v36 = -6729;
      goto LABEL_57;
    }

    if (!*(void *)(v8 + 16)) {
      goto LABEL_55;
    }
    LODWORD(aBlock[0]) = 0;
    __uint64_t v24 = dns_obj_domain_name_create_with_cstring("_dns-push-tls._tcp", aBlock);
    uint64_t v15 = (uint64_t)v24;
    if (LODWORD(aBlock[0]))
    {
      BOOL v25 = v24;
      if (!v24) {
        goto LABEL_31;
      }
    }

    else
    {
      concatenation = dns_obj_domain_name_create_concatenation( *((_BYTE **)v24 + 2),  *(_BYTE **)(*(void *)(v8 + 16) + 16LL),  aBlock);
      BOOL v25 = concatenation;
      if (!LODWORD(aBlock[0]))
      {
        if (concatenation) {
          ++*(_DWORD *)concatenation;
        }
        xpc_object_t v35 = *(void **)(v8 + 24);
        if (v35) {
          ref_count_obj_release(v35);
        }
        *(void *)(v8 + memset(&v5[1], 0, 24) = v25;
      }

      ref_count_obj_release((void *)v15);
      if (!v25)
      {
LABEL_31:
        uint64_t v19 = *(void *)(v8 + 24);
        if (!v19) {
          goto LABEL_55;
        }
        goto LABEL_17;
      }
    }

    ref_count_obj_release(v25);
    goto LABEL_31;
  }

        uint64_t v72 = v24;
      }

      else
      {
        uint64_t v72 = 0;
      }

      int32x2_t v77 = *a3 != 240;
      int v36 = *((void *)a3 + 7);
      if (v36)
      {
        if (*(_DWORD *)(v36 + 32) || *(_BYTE *)(v36 + 40)) {
          int32x2_t v37 = 0LL;
        }
        else {
          int32x2_t v37 = *(void *)(v36 + 48);
        }
        dispatch_source_t v75 = v37 != 0;
      }

      else
      {
        dispatch_source_t v75 = 0;
      }

      CFStringRef v38 = bswap32(*(unsigned __int16 *)(a2 + 320));
      __int128 v39 = *((void *)a3 + 3);
      uint64_t v40 = v39 + 5;
      __int32 v82 = v13;
      uint64_t v41 = HIWORD(v38);
      __int128 v42 = *(unsigned __int16 *)(a2 + 322);
      uint64_t v43 = *((unsigned __int16 *)a3 + 2);
      uint64_t v79 = a3[2];
      loga = *((_DWORD *)a3 + 2);
      actual_ttl = resource_record_get_actual_ttl(v82, (uint64_t)a3);
      int v45 = *((void *)a3 + 7);
      if (v45) {
        LODWORD(v45) = *(_DWORD *)(v45 + 32) == 1;
      }
      *(_DWORD *)__int128 buf = 67112451;
      *(_DWORD *)uint64_t v86 = v41;
      *(_WORD *)&v86[4] = 2160;
      *(void *)&v86[6] = 1752392040LL;
      *(_WORD *)&v86[14] = 1040;
      *(_DWORD *)&v86[16] = v72;
      *(_WORD *)uint64_t v87 = 2101;
      *(void *)&v87[2] = v22;
      *(_WORD *)uint64_t v88 = 1024;
      *(_DWORD *)&v88[2] = v42;
      LOWORD(v89) = 1024;
      *(_DWORD *)((char *)&v89 + 2) = v43;
      HIWORD(v89) = 1024;
      __int32 v90 = v77;
      __int32 v91 = 1024;
      __int32 v92 = v75;
      int32x2_t v93 = 1024;
      int v94 = a4;
      uint64_t v95 = 1024;
      __int32 v96 = v39;
      __int32 v97 = 1024;
      __int32 v98 = v79;
      __int32 v99 = 1024;
      int32x2_t v100 = loga;
      int v101 = 1024;
      uint64_t v102 = actual_ttl;
      char v103 = 1024;
      uint32_t v104 = v45;
      _os_log_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_INFO,  "[Q%u] DNSSEC record changes - qname: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P, qtype: %{mdns:rrtype }d, rrtype: %{mdns:rrtype}d, %{mdns:pos/neg}d, contains denial: %{mdns:yesno}d, %{mdns:addrmv}d, interface index : %d, motality: %{mdns:mortality}d, original ttl: %u, actual ttl: %u, validated: %{mdns:yesno}d.",  buf,  0x5Eu);
      uint64_t v9 = &unk_100164000;
      uint64_t v8 = &unk_100158000;
      int v7 = &unk_100164000;
      uint64_t v13 = v82;
    }
  }

  else
  {
    uint64_t v17 = mDNSLogCategory_DNSSEC_redacted;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC_redacted, OS_LOG_TYPE_INFO))
    {
      uint64_t v18 = *((void *)a3 + 4);
      if (v18)
      {
        uint64_t v19 = (_BYTE *)*((void *)a3 + 4);
        if (v18 == -256) {
          goto LABEL_20;
        }
LABEL_17:
        BOOL v20 = 257;
        if ((unint64_t)v19 < v18 + 256 && v19)
        {
          while (1)
          {
            xpc_object_t v21 = *v19;
            if (v21 > 0x3F)
            {
LABEL_38:
              BOOL v20 = 257;
              goto LABEL_41;
            }

            if (!*v19) {
              break;
            }
            v19 += v21 + 1;
            if (v18 != -256) {
              goto LABEL_17;
            }
LABEL_20:
            if (!v19) {
              goto LABEL_38;
            }
          }

          BOOL v20 = (_WORD)v19 - v18 + 1;
        }

void _dx_session_reset_idle_timer(uint64_t a1)
{
  if (*(void *)(a1 + 48))
  {
    fprintf( __stderrp,  "AssertMacros: %s, %s file: %s, line: %d, value: %lld\n",  "!me->keepalive_reply_timer",  "",  "/Library/Caches/com.apple.xbs/Sources/mDNSResponder/mDNSMacOSX/dnssd_server.c",  1188,  0LL);
  }

  else
  {
    uint64_t v2 = *(dispatch_object_s **)(a1 + 40);
    if (v2)
    {
      dispatch_source_cancel(*(dispatch_source_t *)(a1 + 40));
      dispatch_release(v2);
      *(void *)(a1 + 40) = 0LL;
    }

    if (*(void *)(a1 + 24)) {
      unsigned int v3 = 60000;
    }
    else {
      unsigned int v3 = 300000;
    }
    oneshot_timer = _dx_create_oneshot_timer(v3);
    *(void *)(a1 + 40) = oneshot_timer;
    if (oneshot_timer)
    {
      handler[0] = _NSConcreteStackBlock;
      handler[1] = 0x40000000LL;
      _OWORD handler[2] = ___dx_session_reset_idle_timer_block_invoke;
      handler[3] = &__block_descriptor_tmp_51;
      handler[4] = a1;
      dispatch_source_set_event_handler(oneshot_timer, handler);
      dispatch_activate(*(dispatch_object_t *)(a1 + 40));
    }

    else
    {
      fprintf( __stderrp,  "AssertMacros: %s, %s file: %s, line: %d, value: %lld\n",  "me->idle_timer",  "",  "/Library/Caches/com.apple.xbs/Sources/mDNSResponder/mDNSMacOSX/dnssd_server.c",  1198,  0LL);
    }
  }

void _dx_release(char *a1)
{
  uint64_t v2 = (unsigned int *)(a1 + 8);
  do
  {
    unsigned int v3 = __ldaxr(v2);
    unsigned int v4 = v3 - 1;
  }

  while (__stlxr(v4, v2));
  if (!v4)
  {
    uint64_t v5 = *(void **)a1;
    if (*(void *)a1)
    {
      do
      {
        uint64_t v6 = (void (*)(char *))v5[3];
        if (v6) {
          v6(a1);
        }
        uint64_t v5 = (void *)*v5;
      }

      while (v5);
    }

    free(a1);
  }

dispatch_source_s *_dx_create_oneshot_timer(unsigned int a1)
{
  if (_dx_server_queue_once != -1) {
    dispatch_once(&_dx_server_queue_once, &__block_literal_global_20);
  }
  uint64_t v2 = dispatch_source_create( (dispatch_source_type_t)&_dispatch_source_type_timer,  0LL,  0LL,  (dispatch_queue_t)_dx_server_queue_queue);
  if (v2)
  {
    dispatch_time_t v3 = dispatch_time(0LL, 1000000LL * a1);
    dispatch_source_set_timer(v2, v3, 0xFFFFFFFFFFFFFFFFLL, 50000LL * a1);
  }

  return v2;
}

void ___dx_session_reset_idle_timer_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t v2 = *(dispatch_object_s **)(v1 + 40);
  if (v2)
  {
    dispatch_source_cancel(*(dispatch_source_t *)(v1 + 40));
    dispatch_release(v2);
    *(void *)(*(void *)(a1 + 32) + 40LL) = 0LL;
    uint64_t v1 = *(void *)(a1 + 32);
  }

  if (!*(void *)(v1 + 24))
  {
    _dx_session_terminate(v1, 1);
    return;
  }

  if (!*(void *)(v1 + 32) || *(void *)(v1 + 48))
  {
    fprintf( __stderrp,  "AssertMacros: %s, %s file: %s, line: %d, value: %lld\n",  "me->connection && !me->keepalive_reply_timer",  "",  "/Library/Caches/com.apple.xbs/Sources/mDNSResponder/mDNSMacOSX/dnssd_server.c",  1150,  0LL);
    return;
  }

  if (!_dx_session_send_keepalive_message_s_keepalive_msg)
  {
    xpc_object_t empty = xpc_dictionary_create_empty();
    _dx_session_send_keepalive_message_s_keepalive_msg = (uint64_t)empty;
    if (!empty)
    {
      fprintf( __stderrp,  "AssertMacros: %s, %s file: %s, line: %d, value: %lld\n",  "s_keepalive_msg",  "",  "/Library/Caches/com.apple.xbs/Sources/mDNSResponder/mDNSMacOSX/dnssd_server.c",  1155,  0LL);
      return;
    }

    xpc_dictionary_set_string(empty, "command", "keepalive");
  }

  oneshot_timer = _dx_create_oneshot_timer(0x1388u);
  *(void *)(v1 + 4_Block_object_dispose(va, 8) = oneshot_timer;
  if (oneshot_timer)
  {
    uint64_t v6 = (unsigned int *)(v1 + 8);
    do
      unsigned int v7 = __ldaxr(v6);
    while (__stlxr(v7 + 1, v6));
    uint64_t v8 = *(_xpc_connection_s **)(v1 + 32);
    uint64_t v9 = (void *)_dx_session_send_keepalive_message_s_keepalive_msg;
    if (_dx_server_queue_once != -1) {
      dispatch_once(&_dx_server_queue_once, &__block_literal_global_20);
    }
    handler[0] = _NSConcreteStackBlock;
    handler[1] = 0x40000000LL;
    _OWORD handler[2] = ___dx_session_send_keepalive_message_block_invoke;
    handler[3] = &__block_descriptor_tmp_56;
    handler[4] = v1;
    xpc_connection_send_message_with_reply(v8, v9, (dispatch_queue_t)_dx_server_queue_queue, handler);
    int v10 = *(dispatch_source_s **)(v1 + 48);
    v11[0] = _NSConcreteStackBlock;
    v11[1] = 0x40000000LL;
    _OWORD v11[2] = ___dx_session_send_keepalive_message_block_invoke_2;
    v11[3] = &__block_descriptor_tmp_57_933;
    void v11[4] = v1;
    dispatch_source_set_event_handler(v10, v11);
    dispatch_activate(*(dispatch_object_t *)(v1 + 48));
  }

  else
  {
    fprintf( __stderrp,  "AssertMacros: %s, %s file: %s, line: %d, value: %lld\n",  "me->keepalive_reply_timer",  "",  "/Library/Caches/com.apple.xbs/Sources/mDNSResponder/mDNSMacOSX/dnssd_server.c",  1160,  0LL);
  }

void ___dx_session_send_keepalive_message_block_invoke(uint64_t a1, xpc_object_t object)
{
  uint64_t v3 = *(void *)(a1 + 32);
  if (*(void *)(v3 + 32))
  {
    xpc_type_t type = xpc_get_type(object);
    uint64_t v3 = *(void *)(a1 + 32);
    if (type == (xpc_type_t)&_xpc_type_dictionary)
    {
      uint64_t v5 = *(dispatch_object_s **)(v3 + 48);
      if (v5)
      {
        dispatch_source_cancel(*(dispatch_source_t *)(v3 + 48));
        dispatch_release(v5);
        *(void *)(*(void *)(a1 + 32) + 48LL) = 0LL;
        uint64_t v3 = *(void *)(a1 + 32);
      }

      _dx_session_reset_idle_timer(v3);
      uint64_t v3 = *(void *)(a1 + 32);
    }
  }

  _dx_release((char *)v3);
}

void ___dx_session_send_keepalive_message_block_invoke_2(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = *(dispatch_object_s **)(v2 + 48);
  if (v3)
  {
    dispatch_source_cancel(*(dispatch_source_t *)(v2 + 48));
    dispatch_release(v3);
    *(void *)(*(void *)(a1 + 32) + 48LL) = 0LL;
    uint64_t v2 = *(void *)(a1 + 32);
  }

  _dx_session_terminate(v2, 3);
}

void _dx_session_terminate(uint64_t a1, int a2)
{
  if (!*(_BYTE *)(a1 + 100))
  {
    if (_mdns_server_log_s_once != -1) {
      dispatch_once(&_mdns_server_log_s_once, &__block_literal_global_16);
    }
    unsigned int v4 = (os_log_s *)_mdns_server_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_server_log_s_log, (os_log_type_t)(a2 == 1)))
    {
      int v5 = *(_DWORD *)(a1 + 80);
      uint64_t v6 = *(int *)(a1 + 76);
      v8[0] = 67109890;
      v8[1] = a2;
      __int16 v9 = 1024;
      int v10 = v5;
      __int16 v11 = 2048;
      uint64_t v12 = v6;
      __int16 v13 = 2082;
      uint64_t v14 = a1 + 84;
      _os_log_impl( (void *)&_mh_execute_header,  v4,  (os_log_type_t)(a2 == 1),  "Session terminated -- reason: %{mdns:termination_reason}d, pending send count: %u, client pid: %lld (%{public}s)",  (uint8_t *)v8,  0x22u);
    }

    unsigned int v7 = *(void **)(a1 + 32);
    if (v7)
    {
      xpc_connection_cancel(*(xpc_connection_t *)(a1 + 32));
      xpc_release(v7);
      *(void *)(a1 + 32) = 0LL;
    }

    *(_BYTE *)(a1 + 100) = 1;
  }

uint64_t _dx_gai_request_start_client_requests(int32x2_t *a1, int a2)
{
  int32x2_t v4 = a1[3];
  __int128 v31 = 0u;
  __int128 v32 = 0u;
  __int128 v29 = 0u;
  __int128 v30 = 0u;
  int32x2_t v5 = a1[13];
  int32x4_t v6 = *(int32x4_t *)a1[26].i8;
  *(void *)&__int128 v7 = vrev64q_s32(v6).u64[0];
  *((int32x2_t *)&v7 + 1) = a1[27];
  v27[0] = 0LL;
  __int128 v28 = v7;
  v27[1] = v5;
  LODWORD(v27[0]) = a1[6].i32[0];
  uint64_t v8 = (char *)&a1[28] + 2;
  *(void *)&__int128 v29 = (char *)a1 + 226;
  DWORD2(v29) = *(_DWORD *)(*(void *)&v4 + 72LL);
  __int8 v9 = a1[30].i8[3];
  LOBYTE(v31) = (v9 & 2) != 0;
  __int8 v10 = a1[30].i8[2];
  BYTE2(v31) = (v10 & 8) != 0;
  BYTE3(v31) = (v9 & 0x10) != 0;
  int32x2_t v11 = a1[21];
  *((void *)&v31 + 1) = *(void *)(*(void *)&v4 + 64LL);
  *(int32x2_t *)&__int128 v32 = v11;
  BYTE8(v32) = (v9 & 4) != 0;
  BYTE9(v32) = a1[30].i8[4];
  int v12 = v6.i8[8] & 3;
  BOOL v13 = v12 == 3 || (v6.i8[8] & 3) == 0;
  if (v12 != 3 && (v6.i8[8] & 3) != 0) {
    __int8 v14 = v10 & 0xEF;
  }
  else {
    __int8 v14 = v10 | 0x10;
  }
  a1[30].i8[2] = v14;
  uint64_t v15 = (char *)a1[25];
  if (v15)
  {
    _dx_release(v15);
    a1[25] = 0LL;
  }

  BYTE10(v32) = v13;
  __int128 v25 = 0u;
  __int128 v26 = 0u;
  __int128 v23 = 0u;
  __int128 v24 = 0u;
  __int128 v21 = 0u;
  __int128 v22 = 0u;
  uint64_t v16 = (__int128 *)a1[17];
  if (v16)
  {
    __int128 v21 = 0uLL;
    __int128 v22 = 0uLL;
    __int128 v25 = 0uLL;
    __int128 v26 = 0uLL;
    __int128 v23 = 0uLL;
    __int128 v24 = 0uLL;
    LODWORD(v21) = a1[6].i32[0];
    *((void *)&v21 + 1) = v16;
    *(int32x2_t *)&__int128 v22 = vrev64_s32(a1[26]);
    WORD4(v22) = a1[28].i16[0];
    WORD5(v22) = 1;
    HIDWORD(v22) = a1[27].i32[1];
    *(void *)&__int128 v23 = v8;
    DWORD2(v23) = *(_DWORD *)(*(void *)&v4 + 72LL);
    __int8 v17 = a1[30].i8[3];
    LOBYTE(v25) = (v17 & 2) != 0;
    BYTE2(v25) = (a1[30].i8[2] & 8) != 0;
    BYTE3(v25) = (v17 & 0x10) != 0;
    int32x2_t v18 = a1[21];
    *((void *)&v25 + 1) = *(void *)(*(void *)&v4 + 64LL);
    *(int32x2_t *)&__int128 v26 = v18;
    BYTE8(v26) = (v17 & 4) != 0;
    uint64_t v16 = &v21;
    BYTE10(v26) = a1[30].i8[4];
  }

  uint64_t v34 = 0LL;
  xpc_object_t v35 = &v34;
  uint64_t v36 = 0x2000000000LL;
  int v37 = 0;
  v33[0] = _NSConcreteStackBlock;
  v33[1] = 0x40000000LL;
  v33[2] = ___dx_gai_request_start_client_requests_internal_block_invoke;
  v33[3] = &unk_10013B560;
  void v33[6] = v27;
  v33[7] = v16;
  _OWORD v33[4] = &v34;
  v33[5] = a1;
  _dx_kqueue_locked((uint64_t)"dx_gai_request: starting client requests", a2, (uint64_t)v33);
  if (*((_DWORD *)v35 + 6))
  {
    v38[0] = _NSConcreteStackBlock;
    v38[1] = 0x40000000LL;
    v38[2] = ___dx_gai_request_stop_client_requests_block_invoke;
    v38[3] = &__block_descriptor_tmp_31_961;
    v38[4] = a1;
    _dx_kqueue_locked((uint64_t)"dx_gai_request: stopping client requests", a2, (uint64_t)v38);
    uint64_t v19 = *((unsigned int *)v35 + 6);
  }

  else
  {
    uint64_t v19 = 0LL;
  }

  _Block_object_dispose(&v34, 8);
  return v19;
}

void _dx_session_send_message(uint64_t a1, void *a2)
{
  uint64_t v3 = *(_xpc_connection_s **)(a1 + 32);
  if (v3)
  {
    xpc_connection_send_message(v3, a2);
    int v4 = *(_DWORD *)(a1 + 80);
    *(_DWORD *)(a1 + 80) = v4 + 1;
    if (v4)
    {
      if (v4 == 1) {
        *(_BYTE *)(a1 + 101) = 1;
      }
      if (_mdns_server_log_s_once != -1) {
        dispatch_once(&_mdns_server_log_s_once, &__block_literal_global_16);
      }
      int32x2_t v5 = (os_log_s *)_mdns_server_log_s_log;
      if (os_log_type_enabled((os_log_t)_mdns_server_log_s_log, OS_LOG_TYPE_DEBUG))
      {
        int v6 = *(_DWORD *)(a1 + 80);
        uint64_t v7 = *(int *)(a1 + 76);
        *(_DWORD *)__int128 buf = 134218498;
        uint64_t v13 = v7;
        __int16 v14 = 2082;
        uint64_t v15 = a1 + 84;
        __int16 v16 = 1024;
        int v17 = v6;
        _os_log_debug_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEBUG,  "XPC session to client with pid %lld (%{public}s) pending send count increased to %d",  buf,  0x1Cu);
      }
    }

    else
    {
      *(void *)(a1 + 56) = mach_absolute_time();
    }

    uint64_t v8 = (unsigned int *)(a1 + 8);
    do
      unsigned int v9 = __ldaxr(v8);
    while (__stlxr(v9 + 1, v8));
    __int8 v10 = *(_xpc_connection_s **)(a1 + 32);
    barrier[0] = _NSConcreteStackBlock;
    barrier[1] = 0x40000000LL;
    barrier[2] = ___dx_session_send_message_block_invoke;
    barrier[3] = &__block_descriptor_tmp_48_957;
    barrier[4] = a1;
    xpc_connection_send_barrier(v10, barrier);
  }

  else
  {
    fprintf( __stderrp,  "AssertMacros: %s, %s file: %s, line: %d, value: %lld\n",  "me->connection",  "",  "/Library/Caches/com.apple.xbs/Sources/mDNSResponder/mDNSMacOSX/dnssd_server.c",  1089,  0LL);
  }

void _dx_session_invalidate(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 32);
  if (v2)
  {
    xpc_connection_cancel(*(xpc_connection_t *)(a1 + 32));
    xpc_release(v2);
    *(void *)(a1 + 32) = 0LL;
  }

  uint64_t v3 = *(dispatch_object_s **)(a1 + 40);
  if (v3)
  {
    dispatch_source_cancel(*(dispatch_source_t *)(a1 + 40));
    dispatch_release(v3);
    *(void *)(a1 + 40) = 0LL;
  }

  int v4 = *(dispatch_object_s **)(a1 + 48);
  if (v4)
  {
    dispatch_source_cancel(*(dispatch_source_t *)(a1 + 48));
    dispatch_release(v4);
    *(void *)(a1 + 4_Block_object_dispose(va, 8) = 0LL;
  }

  while (1)
  {
    uint64_t v7 = *(void **)(a1 + 24);
    if (!v7) {
      break;
    }
    *(void *)(a1 + memset(&v5[1], 0, 24) = v7[2];
    int32x2_t v5 = v7;
    while (1)
    {
      int32x2_t v5 = (void *)*v5;
      if (!v5) {
        break;
      }
      int v6 = (void (*)(void *))v5[2];
      if (v6)
      {
        v6(v7);
        break;
      }
    }

    _dx_release((char *)v7);
  }

void ___dx_session_send_message_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  --*(_DWORD *)(v2 + 80);
  if (*(_BYTE *)(v2 + 101))
  {
    if (_mdns_server_log_s_once != -1) {
      dispatch_once(&_mdns_server_log_s_once, &__block_literal_global_16);
    }
    uint64_t v3 = (os_log_s *)_mdns_server_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_server_log_s_log, OS_LOG_TYPE_DEBUG))
    {
      int v5 = *(_DWORD *)(v2 + 80);
      uint64_t v6 = *(int *)(v2 + 76);
      int v7 = 134218498;
      uint64_t v8 = v6;
      __int16 v9 = 2082;
      uint64_t v10 = v2 + 84;
      __int16 v11 = 1024;
      int v12 = v5;
      _os_log_debug_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEBUG,  "XPC session to client with pid %lld (%{public}s) pending send count decreased to %d",  (uint8_t *)&v7,  0x1Cu);
    }
  }

  uint64_t v4 = *(void *)(a1 + 32);
  if (!*(_DWORD *)(v4 + 80)) {
    *(_BYTE *)(v4 + 101) = 0;
  }
  _dx_release((char *)v4);
}

void ___dx_gai_request_start_client_requests_internal_block_invoke(void *a1)
{
  uint64_t v2 = (void *)a1[5];
  uint64_t v3 = (const unsigned __int8 *)v2[18];
  if (v3)
  {
    int is_null = uuid_is_null(v3);
    uint64_t v2 = (void *)a1[5];
    if (!is_null)
    {
      Querier_RegisterPathResolver(v2[18]);
      uint64_t v2 = (void *)a1[5];
    }
  }

  if (!v2[8])
  {
    uint64_t v5 = v2[22];
    if (v5)
    {
      uint64_t DNSServiceManager = Querier_GetDNSServiceManager();
      if (DNSServiceManager) {
        uint64_t DNSServiceManager = mdns_dns_service_manager_register_custom_service(DNSServiceManager, v5);
      }
      uint64_t v2 = (void *)a1[5];
      v2[8] = DNSServiceManager;
    }
  }

  uint64_t v7 = a1[6];
  if (v7)
  {
    *(void *)(v7 + 4_Block_object_dispose(va, 8) = v2[18];
    uint64_t v2 = (void *)a1[5];
    *(void *)(a1[6] + 56LL) = v2[8];
  }

  uint64_t v8 = a1[7];
  if (v8)
  {
    *(void *)(v8 + 4_Block_object_dispose(va, 8) = v2[18];
    uint64_t v9 = a1[5];
    uint64_t v10 = a1[7];
    *(void *)(v10 + 56) = *(void *)(v9 + 64);
    if (!*(void *)(v9 + 88))
    {
      uint64_t v11 = *(void *)(a1[4] + 8LL);
      int v12 = calloc(1uLL, 0x2F8uLL);
      if (!v12)
      {
LABEL_44:
        __break(1u);
LABEL_45:
        fprintf( __stderrp,  "AssertMacros: %s, %s file: %s, line: %d, value: %lld\n",  "err == 0",  "",  "/Library/Caches/com.apple.xbs/Sources/mDNSResponder/mDNSMacOSX/dnssd_server.c",  1780,  v17);
        return;
      }

      int32x2_t v18 = v12;
      int RecordClientRequestStart = QueryRecordClientRequestStart( (uint64_t)v12,  v10,  (uint64_t)_dx_gai_request_query_result_handler,  v9,  v13,  v14,  v15,  v16);
      if (RecordClientRequestStart)
      {
        free(v18);
        int32x2_t v18 = 0LL;
      }

      *(_DWORD *)(v11 + memset(&v5[1], 0, 24) = RecordClientRequestStart;
      *(void *)(a1[5] + 88LL) = v18;
      uint64_t v17 = *(int *)(*(void *)(a1[4] + 8LL) + 24LL);
      if ((_DWORD)v17) {
        goto LABEL_45;
      }
    }
  }

  BOOL v20 = (int *)a1[6];
  if (!v20) {
    return;
  }
  uint64_t v21 = a1[5];
  if (*(void *)(v21 + 80)) {
    return;
  }
  uint64_t v22 = *(void *)(a1[4] + 8LL);
  __int128 v23 = calloc(1uLL, 0x20uLL);
  if (!v23) {
    goto LABEL_44;
  }
  __int128 v28 = v23;
  int AddrInfoClientRequestStart = GetAddrInfoClientRequestStart( (uint64_t)v23,  v20,  (uint64_t)_dx_gai_request_gai_result_handler,  v21,  v24,  v25,  v26,  v27);
  if (AddrInfoClientRequestStart)
  {
    free(v28);
    __int128 v28 = 0LL;
  }

  *(_DWORD *)(v22 + memset(&v5[1], 0, 24) = AddrInfoClientRequestStart;
  *(void *)(a1[5] + 80LL) = v28;
  if (*(_DWORD *)(*(void *)(a1[4] + 8LL) + 24LL))
  {
    fprintf( __stderrp,  "AssertMacros: %s, %s file: %s, line: %d, value: %lld\n",  "err == 0",  "",  "/Library/Caches/com.apple.xbs/Sources/mDNSResponder/mDNSMacOSX/dnssd_server.c",  1785,  *(int *)(*(void *)(a1[4] + 8LL) + 24LL));
  }

  else
  {
    uint64_t v30 = a1[5];
    uint64_t v31 = *(void *)(v30 + 80);
    if (v31 && *(_DWORD *)(v30 + 212) != -1)
    {
      uint64_t v32 = *(void *)(v31 + 16);
      if (v32)
      {
        xpc_object_t v33 = (char *)(v32 + 356);
      }

      else
      {
        uint64_t v34 = *(void *)(v31 + 24);
        xpc_object_t v33 = v34 ? (char *)(v34 + 356) : "";
      }

      if (IsLocalDomain(v33))
      {
        uint64_t v35 = a1[5];
        uint64_t v36 = (const char *)(*(void *)(v35 + 24) + 84LL);
        uint64_t v37 = *(unsigned int *)(v35 + 212);
        if ((_DWORD)v37)
        {
          if (AWDLInterfaceID && AWDLInterfaceID == v37)
          {
            int v38 = 1;
          }

          else
          {
            if (WiFiAwareInterfaceID) {
              BOOL v39 = WiFiAwareInterfaceID == v37;
            }
            else {
              BOOL v39 = 0;
            }
            int v38 = v39;
          }
        }

        else
        {
          int v38 = (*(unsigned __int8 *)(v35 + 210) >> 4) & 1;
        }

        __uint64_t monotonic_time_ns = _mdns_powerlog_get_monotonic_time_ns();
        _mdns_powerlog_bonjour_event(4u, v38, v36, 0LL, monotonic_time_ns);
        *(void *)(a1[5] + 72LL) = monotonic_time_ns;
      }
    }
  }

void _dx_kqueue_locked(uint64_t a1, int a2, uint64_t a3)
{
  if (a2)
  {
    uint64_t v5 = pthread_mutex_lock((pthread_mutex_t *)(mDNSStorage[0] + 616));
    *(_DWORD *)(mDNSStorage[0] + 680) = mDNSPlatformRawTime(v5, v6, v7, v8, v9, v10, v11, v12);
    (*(void (**)(uint64_t))(a3 + 16))(a3);
    KQueueUnlock(a1, v13, v14, v15, v16, v17, v18, v19);
  }

  else
  {
    (*(void (**)(uint64_t))(a3 + 16))(a3);
  }

void ___dx_gai_request_stop_client_requests_block_invoke( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = *(void *)(a1 + 32);
  uint64_t v10 = *(void *)(v9 + 80);
  if (v10)
  {
    GetAddrInfoClientRequestStop(v10, a2, a3, a4, a5, a6, a7, a8);
    uint64_t v11 = *(void **)(v9 + 80);
    if (v11)
    {
      free(v11);
      *(void *)(v9 + 80) = 0LL;
    }
  }

  uint64_t v12 = *(void *)(a1 + 32);
  uint64_t v13 = *(void *)(v12 + 72);
  if (v13)
  {
    uint64_t v14 = *(unsigned int *)(v12 + 212);
    if ((_DWORD)v14)
    {
      if (AWDLInterfaceID) {
        BOOL v15 = AWDLInterfaceID == v14;
      }
      else {
        BOOL v15 = 0;
      }
      if (v15)
      {
        int v17 = 1;
      }

      else
      {
        if (WiFiAwareInterfaceID) {
          BOOL v16 = WiFiAwareInterfaceID == v14;
        }
        else {
          BOOL v16 = 0;
        }
        int v17 = v16;
      }
    }

    else
    {
      int v17 = (*(unsigned __int8 *)(v12 + 210) >> 4) & 1;
    }

    _mdns_powerlog_bonjour_event(6u, v17, (const char *)(*(void *)(v12 + 24) + 84LL), 0LL, v13);
    uint64_t v12 = *(void *)(a1 + 32);
    *(void *)(v12 + 72) = 0LL;
  }

  uint64_t v18 = *(void *)(v12 + 88);
  if (v18)
  {
    QueryRecordClientRequestStop(v18, a2, a3, a4, v13, a6, a7, a8, v20);
    uint64_t v19 = *(void **)(v12 + 88);
    if (v19)
    {
      free(v19);
      *(void *)(v12 + 8_Block_object_dispose(va, 8) = 0LL;
    }
  }

void _dx_gai_request_query_result_handler( uint64_t a1, uint64_t a2, uint64_t a3, int a4, int a5, uint32_t a6, os_unfair_lock_s *a7)
{
  if (a6 && a6 != -65554)
  {
    _dx_request_set_error(a7, a6);
  }

  else if (*(unsigned __int16 *)(a3 + 4) - 66 >= 0xFFFFFFFE)
  {
    if (a6)
    {
      uint64_t v13 = 0LL;
      LODWORD(v14) = 0;
    }

    else
    {
      uint64_t v13 = (_WORD *)(*(void *)(a3 + 40) + 4LL);
      unint64_t v14 = *(unsigned __int16 *)(a3 + 12);
      blocuint64_t k = 0LL;
      p_blocuint64_t k = (uint64_t)&block;
      uint64_t v29 = 0x2000000000LL;
      uint64_t v30 = 0LL;
      v34[0] = _NSConcreteStackBlock;
      v34[1] = 0x40000000LL;
      v34[2] = __dnssd_svcb_copy_doh_uri_block_invoke;
      v34[3] = &unk_10013E308;
      v34[4] = &block;
      _dnssd_svcb_extract_values(v13, v14, 0x8000, (uint64_t)v34);
      BOOL v15 = *(void **)(p_block + 24);
      _Block_object_dispose(&block, 8);
      if (v15)
      {
        bzero(v34, 0x3F1uLL);
        uint64_t v16 = *(void *)(a3 + 56);
        if (v16 && dnssec_obj_resource_record_member_get_validation_result(v16) == 1)
        {
          int v17 = v34;
        }

        else
        {
          int v17 = 0LL;
        }

        uint64_t DNSServiceManager = Querier_GetDNSServiceManager();
        if (DNSServiceManager)
        {
          if (_mdns_dns_service_queue_s_once != -1)
          {
            uint64_t v26 = DNSServiceManager;
            dispatch_once(&_mdns_dns_service_queue_s_once, &__block_literal_global_237);
            uint64_t DNSServiceManager = v26;
          }

          blocuint64_t k = _NSConcreteStackBlock;
          p_blocuint64_t k = 0x40000000LL;
          uint64_t v29 = (uint64_t)__mdns_dns_service_manager_register_doh_uri_block_invoke;
          uint64_t v30 = &__block_descriptor_tmp_16;
          uint64_t v31 = DNSServiceManager;
          uint64_t v32 = v15;
          xpc_object_t v33 = v17;
          dispatch_sync((dispatch_queue_t)_mdns_dns_service_queue_s_queue, &block);
        }

        free(v15);
      }
    }

    else {
      _dx_gai_request_enqueue_result((uint64_t)a7, a5, a3, a4 != 0, v13, v14, a6, a2);
    }
  }

void _dx_gai_request_gai_result_handler( uint64_t a1, uint64_t a2, uint64_t a3, int a4, int a5, uint32_t a6, uint64_t a7)
{
  if (a6 && a6 != -65554)
  {
    _dx_request_set_error((os_unfair_lock_s *)a7, a6);
    return;
  }

  if ((*(_BYTE *)(a7 + 242) & 3) != 0 && (*(_BYTE *)(a7 + 242) & 4) == 0)
  {
    uint64_t v14 = *(void *)(a3 + 48);
    if (v14)
    {
      uint64_t v15 = *(void *)(v14 + 24);
      if (v15)
      {
        uint64_t v16 = *(void *)(v15 + 96);
        if (v16)
        {
        }
      }
    }
  }

  if (!*(_BYTE *)(a2 + 333))
  {
    int v17 = *(unsigned __int16 *)(a2 + 322);
    if (v17 == 28)
    {
      uint64_t v18 = (xpc_object_t *)(a7 + 160);
      uint64_t v19 = (_BYTE *)(a7 + 246);
    }

    else
    {
      if (v17 != 1) {
        goto LABEL_22;
      }
      uint64_t v18 = (xpc_object_t *)(a7 + 152);
      uint64_t v19 = (_BYTE *)(a7 + 245);
    }

    if (*v18)
    {
      xpc_release(*v18);
      *uint64_t v18 = 0LL;
    }

    *uint64_t v18 = xpc_array_create_empty();
    *uint64_t v19 = 1;
  }

void ___dx_gai_request_append_cname_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(const char **)(a1 + 32);
  if (v1)
  {
    xpc_object_t v3 = **(xpc_object_t **)(a1 + 40);
    if (!v3)
    {
      xpc_object_t v3 = xpc_array_create(0LL, 0LL);
      **(void **)(a1 + 40) = v3;
      if (!v3) {
        return;
      }
      uint64_t v1 = *(const char **)(a1 + 32);
    }

    xpc_array_set_string(v3, 0xFFFFFFFFFFFFFFFFLL, v1);
    **(_BYTE **)(a1 + 4_Block_object_dispose(va, 8) = 1;
  }

uint64_t _dx_gai_request_check_for_failover_restart(uint64_t a1, uint64_t a2, char a3, char a4)
{
  uint64_t v15 = 0LL;
  uint64_t v16 = &v15;
  uint64_t v17 = 0x2000000000LL;
  char v18 = 0;
  uint64_t v11 = 0LL;
  uint64_t v12 = &v11;
  uint64_t v13 = 0x2000000000LL;
  uint64_t v14 = 0LL;
  if ((*(_BYTE *)(a1 + 242) & 3) != 0 && (a3 & 1) == 0)
  {
    v9[0] = _NSConcreteStackBlock;
    v9[1] = 0x40000000LL;
    v9[2] = ___dx_gai_request_check_for_failover_restart_block_invoke;
    v9[3] = &unk_10013B588;
    char v10 = a4;
    void v9[6] = a2;
    void v9[7] = a1;
    v9[4] = &v15;
    void v9[5] = &v11;
    uint64_t v4 = (os_unfair_lock_s *)(a1 + 56);
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 56));
    ___dx_gai_request_check_for_failover_restart_block_invoke((uint64_t)v9);
    os_unfair_lock_unlock(v4);
    uint64_t v5 = v12[3];
    if (v5)
    {
      void v12[3] = 0LL;
      do
      {
        uint64_t v6 = *(void *)(v5 + 16);
        _dx_release((char *)v5);
        uint64_t v5 = v6;
      }

      while (v6);
    }
  }

  uint64_t v7 = *((unsigned __int8 *)v16 + 24);
  _Block_object_dispose(&v11, 8);
  _Block_object_dispose(&v15, 8);
  return v7;
}

void _dx_gai_request_enqueue_result( uint64_t a1, int a2, uint64_t a3, unsigned int a4, _DWORD *a5, unsigned int a6, int a7, uint64_t a8)
{
  unsigned int v12 = a6;
  if (a6 || (a4 & 1) == 0)
  {
    uint64_t v17 = calloc(1uLL, 0x68uLL);
    if (!v17)
    {
      __break(1u);
      goto LABEL_99;
    }

    uint64_t v8 = (uint64_t)v17;
    *(void *)uint64_t v17 = &_dx_gai_result_kind;
    uint64_t v9 = v17 + 2;
    v17[2] = 1;
    _dx_recursive_init((uint64_t)v17, &_dx_gai_result_kind);
    char v18 = *(_BYTE **)(a3 + 32);
    uint64_t v19 = *(void *)(a1 + 112);
    if (v19)
    {
      int v20 = SameDomainNameBytes(*(_BYTE **)(v19 + 24), *(_BYTE **)(a3 + 32));
      int v21 = *(void **)(a1 + 112);
      if (v20)
      {
LABEL_9:
        if (!v21) {
          goto LABEL_97;
        }
        uint64_t v22 = mdns_resource_record_create(v21, *(_WORD *)(a3 + 4), *(_WORD *)(a3 + 6), 0, a5, v12);
        *(void *)(v8 + memset(&v5[1], 0, 24) = v22;
        if (!v22) {
          goto LABEL_97;
        }
        if (a2)
        {
          if (*(_BYTE *)(a8 + 337)) {
            int v23 = 2;
          }
          else {
            int v23 = 1073741826;
          }
          uint64_t v24 = *(void *)(a3 + 48);
          if (!v12)
          {
            if (v24 && *(void *)(v24 + 24))
            {
              if (a2 == 4)
              {
                int v25 = 3;
              }

              else
              {
                if (*(_BYTE *)(a3 + 1) == 3) {
                  int v26 = 2;
                }
                else {
                  int v26 = 5;
                }
                if (*(_BYTE *)(a3 + 1)) {
                  int v25 = v26;
                }
                else {
                  int v25 = 1;
                }
              }
            }

            else if (*(void *)(a3 + 24))
            {
              int v25 = 1;
            }

            else
            {
              int v25 = 4;
            }

            *(_DWORD *)(v8 + 84) = v25;
          }

          unsigned int v12 = a4;
          if (v24)
          {
            uint64_t v27 = *(void **)(v24 + 32);
            *(void *)(v8 + 72) = v27;
            if (v27) {
              os_retain(v27);
            }
          }

          else
          {
            *(void *)(v8 + 72) = 0LL;
          }
        }

        else
        {
          int v23 = 0;
          unsigned int v12 = a4;
        }

        unsigned int v28 = v23 | 0x80000000;
        if (!v12) {
          unsigned int v28 = v23;
        }
        *(_DWORD *)(v8 + 80) = v28;
        *(_DWORD *)(v8 + 8_Block_object_dispose(va, 8) = a7;
        uint64_t v29 = *(void *)(a3 + 24);
        uint64_t v30 = v29 + 5;
        *(_DWORD *)(v8 + 92) = v29;
        uint64_t v31 = *(void *)(a3 + 48);
        if (v31)
        {
          *(_DWORD *)(v8 + 96) = *(_DWORD *)(v31 + 48);
          *(_WORD *)(v8 + 100) = bswap32(*(unsigned __int16 *)(a8 + 320)) >> 16;
          uint64_t v32 = *(void *)(v31 + 24);
          if (v32)
          {
            uint64_t v33 = *(void *)(v32 + 136);
            if (!v33 || !*(void *)(v33 + 96)) {
              uint64_t v33 = v32;
            }
            xpc_object_t v34 = *(xpc_object_t *)(v33 + 160);
            if (v34) {
              xpc_object_t v34 = xpc_retain(v34);
            }
            *(void *)(v8 + 32) = v34;
          }

void _dx_request_set_error(os_unfair_lock_s *a1, uint32_t a2)
{
  uint64_t v5 = 0LL;
  uint64_t v6 = &v5;
  uint64_t v7 = 0x2000000000LL;
  char v8 = 0;
  uint64_t v4 = a1 + 14;
  os_unfair_lock_lock(a1 + 14);
  if (!a1[13]._os_unfair_lock_opaque)
  {
    a1[13]._os_unfair_lock_opaque = a2;
    *((_BYTE *)v6 + memset(&v5[1], 0, 24) = 1;
  }

  os_unfair_lock_unlock(v4);
  _Block_object_dispose(&v5, 8);
}

uint64_t _dx_gai_request_restart_client_requests_in_failover_mode( uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((*(_BYTE *)(result + 242) & 8) == 0)
  {
    uint64_t v8 = result;
    v11[0] = _NSConcreteStackBlock;
    v11[1] = 0x40000000LL;
    _OWORD v11[2] = ___dx_gai_request_stop_client_requests_block_invoke;
    v11[3] = &__block_descriptor_tmp_31_961;
    void v11[4] = result;
    ___dx_gai_request_stop_client_requests_block_invoke((uint64_t)v11, a2, a3, a4, a5, a6, a7, a8);
    if (_mdns_server_log_s_once != -1) {
      dispatch_once(&_mdns_server_log_s_once, &__block_literal_global_16);
    }
    uint64_t v9 = (os_log_s *)_mdns_server_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_server_log_s_log, OS_LOG_TYPE_DEFAULT))
    {
      int v10 = *(_DWORD *)(v8 + 48);
      LODWORD(v11[0]) = 67109120;
      HIDWORD(v11[0]) = v10;
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEFAULT,  "[R%u] getaddrinfo failover restart",  (uint8_t *)v11,  8u);
    }

    *(_BYTE *)(v8 + 242) |= 8u;
    return _dx_gai_request_start_client_requests(v8, 0LL);
  }

  return result;
}

void _dx_gai_request_append_result(os_unfair_lock_s *a1, uint64_t a2)
{
  int v4 = *(unsigned __int16 *)(*(void *)(a2 + 24) + 52LL);
  uint64_t v14 = 0LL;
  uint64_t v15 = &v14;
  uint64_t v16 = 0x2000000000LL;
  uint64_t v17 = 0LL;
  if (v4 == 28)
  {
    uint64_t v6 = (xpc_object_t *)&a1[40];
    uint64_t v7 = (char *)&a1[61]._os_unfair_lock_opaque + 2;
  }

  else
  {
    uint64_t v5 = 0LL;
    if (v4 != 1) {
      goto LABEL_10;
    }
    uint64_t v6 = (xpc_object_t *)&a1[38];
    uint64_t v7 = (char *)&a1[61]._os_unfair_lock_opaque + 1;
  }

  os_unfair_lock_lock(a1 + 14);
  if (*v7)
  {
    if (*v6)
    {
      xpc_object_t v8 = xpc_copy(*v6);
      v15[3] = (uint64_t)v8;
    }

    *uint64_t v7 = 0;
  }

  os_unfair_lock_unlock(a1 + 14);
  uint64_t v5 = v15[3];
LABEL_10:
  _Block_object_dispose(&v14, 8);
  *(void *)(a2 + 40) = v5;
  os_unfair_lock_lock(a1 + 14);
  uint64_t v9 = a1 + 24;
  do
  {
    int v10 = v9;
    uint64_t v11 = *(void *)&v9->_os_unfair_lock_opaque;
    uint64_t v9 = (os_unfair_lock_s *)(*(void *)&v9->_os_unfair_lock_opaque + 16LL);
  }

  while (v11);
  *(void *)&v10->_os_unfair_lock_opaque = a2;
  unsigned int v12 = (unsigned int *)(a2 + 8);
  do
    unsigned int v13 = __ldaxr(v12);
  while (__stlxr(v13 + 1, v12));
  os_unfair_lock_unlock(a1 + 14);
}

void _dx_gai_result_finalize(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2)
  {
    os_release(v2);
    a1[3] = 0LL;
  }

  xpc_object_t v3 = (void *)a1[4];
  if (v3)
  {
    xpc_release(v3);
    a1[4] = 0LL;
  }

  int v4 = (void *)a1[5];
  if (v4)
  {
    xpc_release(v4);
    a1[5] = 0LL;
  }

  uint64_t v5 = (void *)a1[6];
  if (v5)
  {
    xpc_release(v5);
    a1[6] = 0LL;
  }

  uint64_t v6 = (void *)a1[7];
  if (v6)
  {
    xpc_release(v6);
    a1[7] = 0LL;
  }

  uint64_t v7 = (void *)a1[8];
  if (v7)
  {
    os_release(v7);
    a1[8] = 0LL;
  }

  xpc_object_t v8 = (void *)a1[9];
  if (v8)
  {
    os_release(v8);
    a1[9] = 0LL;
  }

uint64_t ___dx_gai_request_check_for_failover_restart_block_invoke(uint64_t result)
{
  int v1 = *(unsigned __int16 *)(*(void *)(result + 48) + 4LL);
  if (*(_BYTE *)(result + 64))
  {
    if (v1 == 1 || (v1 != 65 ? (BOOL v2 = v1 == 28) : (BOOL v2 = 1), v2)) {
      *(_BYTE *)(*(void *)(result + 56) + 242LL) &= 0xFCu;
    }
    return result;
  }

  if (v1 == 1)
  {
    uint64_t v3 = *(void *)(result + 56);
    char v4 = *(_BYTE *)(v3 + 242) & 0xFE;
    goto LABEL_13;
  }

  if (v1 == 28)
  {
    uint64_t v3 = *(void *)(result + 56);
    char v4 = *(_BYTE *)(v3 + 242) & 0xFD;
LABEL_13:
    *(_BYTE *)(v3 + 242) = v4;
    goto LABEL_15;
  }

  uint64_t v3 = *(void *)(result + 56);
  char v4 = *(_BYTE *)(v3 + 242);
LABEL_15:
  if ((v4 & 7) == 4)
  {
    *(_BYTE *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = 1;
    *(void *)(*(void *)(*(void *)(result + 40) + 8LL) + 24LL) = *(void *)(v3 + 96);
    *(void *)(*(void *)(result + 56) + 96LL) = 0LL;
  }

  return result;
}

void _dx_gai_request_invalidate(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 24);
  int v3 = *(unsigned __int8 *)(a1 + 244);
  if (*(_BYTE *)(v2 + 100))
  {
    if (v3 == 1)
    {
      if (_mdns_server_log_s_once != -1) {
        dispatch_once(&_mdns_server_log_s_once, &__block_literal_global_16);
      }
      char v4 = (os_log_s *)_mdns_server_log_s_log;
      if (os_log_type_enabled((os_log_t)_mdns_server_log_s_log, OS_LOG_TYPE_DEFAULT))
      {
        int v5 = *(_DWORD *)(a1 + 48);
        uint64_t v6 = *(void *)(a1 + 104);
        uint64_t v7 = *(int *)(v2 + 76);
        LODWORD(v45) = 67110147;
        HIDWORD(v45) = v5;
        strcpy((char *)&v46, "p\bhash");
        HIBYTE(v46) = 0;
        *(_WORD *)BOOL v47 = 0;
        *(_WORD *)&v47[2] = 2085;
        *(void *)&uint8_t v47[4] = v6;
        *(_WORD *)&v47[12] = 2048;
        *(void *)&_BYTE v47[14] = v7;
        *(_WORD *)&v47[22] = 2082;
        uint64_t v48 = v2 + 84;
        xpc_object_t v8 = "[R%u] getaddrinfo stop (forced) -- hostname: %{sensitive,mask.hash}s, client pid: %lld (%{public}s)";
LABEL_20:
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, v8, (uint8_t *)&v45, 0x30u);
      }
    }

    else
    {
      if (_mdns_server_log_s_once != -1) {
        dispatch_once(&_mdns_server_log_s_once, &__block_literal_global_16);
      }
      char v4 = (os_log_s *)_mdns_server_log_s_log;
      if (os_log_type_enabled((os_log_t)_mdns_server_log_s_log, OS_LOG_TYPE_DEFAULT))
      {
        int v12 = *(_DWORD *)(a1 + 48);
        uint64_t v13 = *(void *)(a1 + 104);
        uint64_t v14 = *(int *)(v2 + 76);
        LODWORD(v45) = 67110147;
        HIDWORD(v45) = v12;
        strcpy((char *)&v46, "p\bhash");
        HIBYTE(v46) = 0;
        *(_WORD *)BOOL v47 = 0;
        *(_WORD *)&v47[2] = 2081;
        *(void *)&uint8_t v47[4] = v13;
        *(_WORD *)&v47[12] = 2048;
        *(void *)&_BYTE v47[14] = v14;
        *(_WORD *)&v47[22] = 2082;
        uint64_t v48 = v2 + 84;
        xpc_object_t v8 = "[R%u] getaddrinfo stop (forced) -- hostname: %{private,mask.hash}s, client pid: %lld (%{public}s)";
        goto LABEL_20;
      }
    }
  }

  else if (v3 == 1)
  {
    if (_mdns_server_log_s_once != -1) {
      dispatch_once(&_mdns_server_log_s_once, &__block_literal_global_16);
    }
    char v4 = (os_log_s *)_mdns_server_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_server_log_s_log, OS_LOG_TYPE_DEFAULT))
    {
      int v9 = *(_DWORD *)(a1 + 48);
      uint64_t v10 = *(void *)(a1 + 104);
      uint64_t v11 = *(int *)(v2 + 76);
      LODWORD(v45) = 67110147;
      HIDWORD(v45) = v9;
      strcpy((char *)&v46, "p\bhash");
      HIBYTE(v46) = 0;
      *(_WORD *)BOOL v47 = 0;
      *(_WORD *)&v47[2] = 2085;
      *(void *)&uint8_t v47[4] = v10;
      *(_WORD *)&v47[12] = 2048;
      *(void *)&_BYTE v47[14] = v11;
      *(_WORD *)&v47[22] = 2082;
      uint64_t v48 = v2 + 84;
      xpc_object_t v8 = "[R%u] getaddrinfo stop -- hostname: %{sensitive,mask.hash}s, client pid: %lld (%{public}s)";
      goto LABEL_20;
    }
  }

  else
  {
    if (_mdns_server_log_s_once != -1) {
      dispatch_once(&_mdns_server_log_s_once, &__block_literal_global_16);
    }
    char v4 = (os_log_s *)_mdns_server_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_server_log_s_log, OS_LOG_TYPE_DEFAULT))
    {
      int v15 = *(_DWORD *)(a1 + 48);
      uint64_t v16 = *(void *)(a1 + 104);
      uint64_t v17 = *(int *)(v2 + 76);
      LODWORD(v45) = 67110147;
      HIDWORD(v45) = v15;
      strcpy((char *)&v46, "p\bhash");
      HIBYTE(v46) = 0;
      *(_WORD *)BOOL v47 = 0;
      *(_WORD *)&v47[2] = 2081;
      *(void *)&uint8_t v47[4] = v16;
      *(_WORD *)&v47[12] = 2048;
      *(void *)&_BYTE v47[14] = v17;
      *(_WORD *)&v47[22] = 2082;
      uint64_t v48 = v2 + 84;
      xpc_object_t v8 = "[R%u] getaddrinfo stop -- hostname: %{private,mask.hash}s, client pid: %lld (%{public}s)";
      goto LABEL_20;
    }
  }

  uint64_t v45 = _NSConcreteStackBlock;
  uint64_t v46 = 0x40000000LL;
  *(void *)BOOL v47 = ___dx_gai_request_stop_client_requests_block_invoke;
  *(void *)&v47[8] = &__block_descriptor_tmp_31_961;
  *(void *)&v47[16] = a1;
  uint64_t v18 = pthread_mutex_lock((pthread_mutex_t *)(mDNSStorage[0] + 616));
  *(_DWORD *)(mDNSStorage[0] + 680) = mDNSPlatformRawTime(v18, v19, v20, v21, v22, v23, v24, v25);
  ___dx_gai_request_stop_client_requests_block_invoke((uint64_t)&v45, v26, v27, v28, v29, v30, v31, v32);
  KQueueUnlock((uint64_t)"dx_gai_request: stopping client requests", v33, v34, v35, v36, v37, v38, v39);
  uint64_t v40 = *(void *)(a1 + 64);
  if (v40)
  {
    Querier_DeregisterCustomDNSService(v40);
    *(void *)(a1 + 64) = 0LL;
  }

  uint64_t v41 = *(void **)(a1 + 184);
  if (v41)
  {
    os_release(v41);
    *(void *)(a1 + 184) = 0LL;
  }

  char v42 = *(void **)(a1 + 112);
  if (v42)
  {
    os_release(v42);
    *(void *)(a1 + 112) = 0LL;
  }

  unsigned int v43 = *(void **)(a1 + 120);
  if (v43)
  {
    xpc_release(v43);
    *(void *)(a1 + 120) = 0LL;
  }

  int v44 = *(void **)(a1 + 128);
  if (v44)
  {
    xpc_release(v44);
    *(void *)(a1 + 12_Block_object_dispose(va, 8) = 0LL;
  }

void _dx_gai_request_finalize(void *a1)
{
  uint64_t v2 = a1[12];
  if (v2)
  {
    a1[12] = 0LL;
    do
    {
      uint64_t v3 = *(void *)(v2 + 16);
      _dx_release((char *)v2);
      uint64_t v2 = v3;
    }

    while (v3);
  }

  char v4 = (void *)a1[13];
  if (v4)
  {
    free(v4);
    a1[13] = 0LL;
  }

  int v5 = (void *)a1[24];
  if (v5)
  {
    free(v5);
    a1[24] = 0LL;
  }

  uint64_t v6 = (void *)a1[19];
  if (v6)
  {
    xpc_release(v6);
    a1[19] = 0LL;
  }

  uint64_t v7 = (void *)a1[20];
  if (v7)
  {
    xpc_release(v7);
    a1[20] = 0LL;
  }

  xpc_object_t v8 = (void *)a1[21];
  if (v8)
  {
    os_release(v8);
    a1[21] = 0LL;
  }

  int v9 = (void *)a1[22];
  if (v9)
  {
    xpc_release(v9);
    a1[22] = 0LL;
  }

  uint64_t v10 = (void *)a1[18];
  if (v10)
  {
    free(v10);
    a1[18] = 0LL;
  }

  uint64_t v11 = (char *)a1[25];
  if (v11)
  {
    _dx_release(v11);
    a1[25] = 0LL;
  }

xpc_object_t _dx_gai_request_take_results(os_unfair_lock_s *a1)
{
  int v1 = a1;
  uint64_t v71 = 0LL;
  uint64_t v72 = &v71;
  uint64_t v73 = 0x2000000000LL;
  uint64_t v74 = 0LL;
  v70[0] = _NSConcreteStackBlock;
  v70[1] = 0x40000000LL;
  v70[2] = ___dx_gai_request_take_results_block_invoke;
  v70[3] = &unk_10013B538;
  uint64_t v2 = a1 + 14;
  v70[4] = &v71;
  v70[5] = a1;
  os_unfair_lock_lock(a1 + 14);
  ___dx_gai_request_take_results_block_invoke((uint64_t)v70);
  os_unfair_lock_unlock(v2);
  uint64_t v3 = v72;
  if (!v72[3])
  {
    xpc_object_t xarray = 0LL;
    LODWORD(v4) = 0;
    goto LABEL_83;
  }

  LODWORD(v4) = -65539;
  xpc_object_t v5 = xpc_array_create(0LL, 0LL);
  uint64_t v3 = v72;
  xpc_object_t xarray = v5;
  if (v5)
  {
    uint64_t v4 = v72[3];
    if (v4)
    {
      __int8 v65 = v1;
      while (1)
      {
        xpc_object_t v6 = xpc_dictionary_create(0LL, 0LL, 0LL);
        if (!v6)
        {
          fprintf( __stderrp,  "AssertMacros: %s, %s file: %s, line: %d, value: %lld\n",  "result",  "",  "/Library/Caches/com.apple.xbs/Sources/mDNSResponder/mDNSMacOSX/dnssd_server.c",  2548,  0LL);
          char v61 = 0;
          uint64_t v3 = v72;
          LODWORD(v4) = -65539;
          goto LABEL_84;
        }

        uint64_t v7 = v6;
        xpc_dictionary_set_int64(v6, "error", *(int *)(v4 + 88));
        xpc_dictionary_set_uint64(v7, "flags", *(unsigned int *)(v4 + 80));
        xpc_dictionary_set_uint64(v7, "interface_index", *(unsigned int *)(v4 + 92));
        xpc_dictionary_set_string(v7, "rname", *(const char **)(*(void *)(*(void *)(v4 + 24) + 24LL) + 40LL));
        xpc_dictionary_set_uint64(v7, "rtype", *(unsigned __int16 *)(*(void *)(v4 + 24) + 52LL));
        xpc_dictionary_set_uint64(v7, "rprotocol", *(unsigned __int16 *)(v4 + 96));
        xpc_dictionary_set_uint64(v7, "rclass", *(unsigned __int16 *)(*(void *)(v4 + 24) + 54LL));
        uint64_t v8 = *(void *)(v4 + 24);
        uint64_t v9 = *(void *)(v8 + 32);
        size_t v10 = *(unsigned __int16 *)(v8 + 56);
        if (v9) {
          BOOL v11 = 1;
        }
        else {
          BOOL v11 = (_DWORD)v10 == 0;
        }
        if (v11)
        {
          if (v9) {
            int v12 = *(const char **)(v8 + 32);
          }
          else {
            int v12 = "";
          }
          xpc_dictionary_set_data(v7, "rdata", v12, v10);
        }

        int64_t v13 = *(int *)(v4 + 84);
        if ((_DWORD)v13) {
          xpc_dictionary_set_int64(v7, "negative_reason", v13);
        }
        uint64_t v14 = *(void **)(v4 + 32);
        if (v14) {
          xpc_dictionary_set_value(v7, "provider_name", v14);
        }
        int v15 = *(void **)(v4 + 40);
        if (v15) {
          xpc_dictionary_set_value(v7, "cname_update", v15);
        }
        uint64_t v16 = *(void **)(v4 + 48);
        if (v16)
        {
          xpc_dictionary_set_value(v7, "tracker_hostname", v16);
          uint64_t v17 = *(void **)(v4 + 56);
          if (v17) {
            xpc_dictionary_set_value(v7, "tracker_owner", v17);
          }
          xpc_dictionary_set_BOOL(v7, "tracker_approved", *(_BYTE *)(v4 + 102) & 1);
          xpc_dictionary_set_BOOL(v7, "tracker_can_block_request", (*(_BYTE *)(v4 + 102) & 4) != 0);
        }

        uint64_t v18 = *(void *)(v4 + 64);
        if (v18)
        {
          *(void *)__int128 buf = 0LL;
          data = mdns_signed_result_get_data(v18, buf);
          if (data) {
            xpc_dictionary_set_data(v7, "validation_data", data, *(size_t *)buf);
          }
        }

        uint64_t v20 = *(void *)(v4 + 72);
        if (v20)
        {
          uint64_t v21 = *(unsigned __int16 *)(v20 + 32);
          uint64_t v22 = *(void **)(v20 + 24);
          xpc_object_t empty = xpc_dictionary_create_empty();
          if (empty)
          {
            uint64_t v24 = empty;
            xpc_dictionary_set_uint64(empty, "code", v21);
            if (v22 && xpc_string_get_length(v22)) {
              xpc_dictionary_set_value(v24, "text", v22);
            }
            xpc_dictionary_set_value(v7, "extended_dns_error", v24);
            xpc_release(v24);
          }

          else
          {
            xpc_dictionary_set_value(v7, "extended_dns_error", 0LL);
          }
        }

        uint32_t os_unfair_lock_opaque = v1[12]._os_unfair_lock_opaque;
        unsigned int v26 = *(_DWORD *)(v4 + 80);
        unsigned int v27 = v26 & 2;
        uint64_t v28 = *(void *)(v4 + 24);
        if (!v28)
        {
          uint64_t v29 = 0LL;
          int v30 = 0;
          char v31 = *(_BYTE *)(v4 + 102);
LABEL_40:
          if ((v31 & 2) != 0)
          {
            uint64_t v40 = v29 + 2;
            while (1)
            {
              uint64_t v40 = (void *)*v40;
              if (!v40) {
                break;
              }
              uint64_t v41 = (uint64_t (*)(void *, void, uint64_t))v40[3];
              if (v41)
              {
                uint64_t v42 = v41(v29, 0LL, 1LL);
                if (!v42) {
                  break;
                }
                unsigned int v43 = (void *)v42;
                if (_mdns_server_log_s_once != -1) {
                  dispatch_once(&_mdns_server_log_s_once, &__block_literal_global_16);
                }
                int v44 = (os_log_s *)_mdns_server_log_s_log;
                if (os_log_type_enabled((os_log_t)_mdns_server_log_s_log, OS_LOG_TYPE_DEFAULT))
                {
                  int v45 = *(unsigned __int16 *)(v4 + 100);
                  int v46 = *(_DWORD *)(v4 + 92);
                  int v47 = *(_DWORD *)(v4 + 84);
                  *(_DWORD *)__int128 buf = 67110658;
                  *(_DWORD *)&uint8_t buf[4] = os_unfair_lock_opaque;
                  __int16 v76 = 1024;
                  int v77 = v45;
                  __int16 v78 = 1024;
                  unsigned int v79 = v27 >> 1;
                  __int16 v80 = 1024;
                  int v81 = v46;
                  __int16 v82 = 2082;
                  __int32 v83 = v43;
                  __int16 v84 = 1024;
                  int v85 = v30;
                  __int16 v86 = 1024;
                  LODWORD(v87) = v47;
                  _os_log_impl( (void *)&_mh_execute_header,  v44,  OS_LOG_TYPE_DEFAULT,  "[R%u->Q%u] getaddrinfo result -- event: %{mdns:addrmv}d, ifindex: %d, name: %{public}s, type: %{mdns :rrtype}d, rdata: <none>, reason: %{mdns:nreason}d",  buf,  0x30u);
                }

                uint64_t v48 = v43;
                goto LABEL_79;
              }
            }
          }

          if (_mdns_server_log_s_once != -1) {
            dispatch_once(&_mdns_server_log_s_once, &__block_literal_global_16);
          }
          uint64_t v36 = (os_log_s *)_mdns_server_log_s_log;
          if (os_log_type_enabled((os_log_t)_mdns_server_log_s_log, OS_LOG_TYPE_DEFAULT))
          {
            int v37 = *(unsigned __int16 *)(v4 + 100);
            int v38 = *(_DWORD *)(v4 + 92);
            int v39 = *(_DWORD *)(v4 + 84);
            *(_DWORD *)__int128 buf = 67110658;
            *(_DWORD *)&uint8_t buf[4] = os_unfair_lock_opaque;
            __int16 v76 = 1024;
            int v77 = v37;
            __int16 v78 = 1024;
            unsigned int v79 = v27 >> 1;
            __int16 v80 = 1024;
            int v81 = v38;
            __int16 v82 = 2112;
            __int32 v83 = v29;
            __int16 v84 = 1024;
            int v85 = v30;
            __int16 v86 = 1024;
            LODWORD(v87) = v39;
            _os_log_impl( (void *)&_mh_execute_header,  v36,  OS_LOG_TYPE_DEFAULT,  "[R%u->Q%u] getaddrinfo result -- event: %{mdns:addrmv}d, ifindex: %d, name: %@, type: %{mdns:rrtype}d, rda ta: <none>, reason: %{mdns:nreason}d",  buf,  0x30u);
          }

          goto LABEL_80;
        }

        uint64_t v29 = *(void **)(v28 + 24);
        int v30 = *(unsigned __int16 *)(v28 + 52);
        char v31 = *(_BYTE *)(v4 + 102);
        if (!*(_WORD *)(v28 + 56)) {
          goto LABEL_40;
        }
        uint32_t v66 = v1[12]._os_unfair_lock_opaque;
        int v67 = *(unsigned __int16 *)(v28 + 52);
        if ((*(_BYTE *)(v4 + 102) & 2) != 0)
        {
          int v49 = v29 + 2;
          while (1)
          {
            int v49 = (void *)*v49;
            if (!v49) {
              break;
            }
            uint64_t v50 = (uint64_t (*)(void *, void, uint64_t))v49[3];
            if (v50)
            {
              uint64_t v51 = v50(v29, 0LL, 1LL);
              uint64_t v28 = *(void *)(v4 + 24);
              goto LABEL_59;
            }
          }

          uint64_t v51 = 0LL;
LABEL_59:
          int32x2_t v52 = (void *)(v28 + 16);
          do
          {
            int32x2_t v52 = (void *)*v52;
            if (!v52)
            {
              BOOL v32 = 0;
              uint64_t v34 = 0LL;
              uint64_t v35 = (void *)v51;
              BOOL v33 = v51 != 0;
              goto LABEL_70;
            }

            __int16 v53 = (uint64_t (*)(uint64_t, void, uint64_t))v52[3];
          }

          while (!v53);
          uint64_t v34 = v53(v28, 0LL, 1LL);
          __int16 v54 = (void *)v51;
          BOOL v33 = v51 != 0;
          BOOL v32 = v34 != 0;
          uint64_t v35 = v54;
          if (v54 && v34)
          {
            unsigned __int8 v68 = (void *)v34;
            if (_mdns_server_log_s_once != -1) {
              dispatch_once(&_mdns_server_log_s_once, &__block_literal_global_16);
            }
            int v55 = (os_log_s *)_mdns_server_log_s_log;
            if (os_log_type_enabled((os_log_t)_mdns_server_log_s_log, OS_LOG_TYPE_DEFAULT))
            {
              int v56 = *(unsigned __int16 *)(v4 + 100);
              int v57 = *(_DWORD *)(v4 + 92);
              *(_DWORD *)__int128 buf = 67110914;
              *(_DWORD *)&uint8_t buf[4] = v66;
              __int16 v76 = 1024;
              int v77 = v56;
              __int16 v78 = 1024;
              unsigned int v79 = v27 >> 1;
              __int16 v80 = 1024;
              int v81 = v57;
              __int16 v82 = 2082;
              __int32 v83 = v35;
              __int16 v84 = 1024;
              int v85 = v67;
              __int16 v86 = 2082;
              uint64_t v87 = v68;
              __int16 v88 = 1024;
              unsigned int v89 = v26 >> 31;
              _os_log_impl( (void *)&_mh_execute_header,  v55,  OS_LOG_TYPE_DEFAULT,  "[R%u->Q%u] getaddrinfo result -- event: %{mdns:addrmv}d, ifindex: %d, name: %{public}s, type: %{mdns:rrt ype}d, rdata: %{public}s, expired: %{mdns:yesno}d",  buf,  0x3Au);
            }

            free(v35);
LABEL_78:
            uint64_t v48 = v68;
LABEL_79:
            free(v48);
            goto LABEL_80;
          }
        }

        else
        {
          BOOL v32 = 0;
          BOOL v33 = 0;
          uint64_t v34 = 0LL;
          uint64_t v35 = 0LL;
        }

uint64_t ___dx_gai_request_take_results_block_invoke(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 40);
  if ((*(_BYTE *)(v1 + 242) & 3) != 0)
  {
    uint64_t v7 = 0LL;
    uint64_t v4 = *(void *)(v1 + 96);
    uint64_t v2 = (uint64_t *)(v1 + 96);
    uint64_t v3 = v4;
    if (v4)
    {
      xpc_object_t v5 = &v7;
      do
      {
        if ((*(_DWORD *)(v3 + 80) & 0x80000000) != 0)
        {
          uint64_t *v2 = *(void *)(v3 + 16);
          *(void *)(v3 + 16) = 0LL;
          *xpc_object_t v5 = v3;
          xpc_object_t v5 = (uint64_t *)(v3 + 16);
        }

        else
        {
          uint64_t v2 = (uint64_t *)(v3 + 16);
        }

        uint64_t v3 = *v2;
      }

      while (*v2);
      uint64_t v6 = v7;
    }

    else
    {
      uint64_t v6 = 0LL;
    }

    *(void *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = v6;
  }

  else
  {
    *(void *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = *(void *)(v1 + 96);
    *(void *)(*(void *)(result + 40) + 96LL) = 0LL;
  }

  return result;
}

uint64_t _dx_request_init(uint64_t result)
{
  do
    unsigned int v1 = __ldaxr(&dnssd_server_get_new_request_id_s_next_id);
  while (__stlxr(v1 + 1, &dnssd_server_get_new_request_id_s_next_id));
  *(_DWORD *)(result + 4_Block_object_dispose(va, 8) = v1;
  *(_DWORD *)(result + 56) = 0;
  return result;
}

void _dx_request_finalize(uint64_t a1)
{
  uint64_t v2 = *(char **)(a1 + 24);
  if (v2)
  {
    _dx_release(v2);
    *(void *)(a1 + memset(&v5[1], 0, 24) = 0LL;
  }

  uint64_t v3 = *(void **)(a1 + 32);
  if (v3)
  {
    xpc_release(v3);
    *(void *)(a1 + 32) = 0LL;
  }

void _dx_session_finalize(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 32);
  if (v2)
  {
    xpc_release(v2);
    *(void *)(a1 + 32) = 0LL;
  }

  uint64_t v3 = *(void **)(a1 + 64);
  if (v3)
  {
    os_release(v3);
    *(void *)(a1 + 64) = 0LL;
  }

void ___dx_server_queue_block_invoke(id a1)
{
  unsigned int v1 = dispatch_queue_attr_make_with_qos_class(0LL, QOS_CLASS_USER_INITIATED, 0);
  _dx_server_queue_queue = (uint64_t)dispatch_queue_create("com.apple.dnssd.server", v1);
}

void __dnssd_server_idle_block_invoke(id a1)
{
  if (_dx_server_queue_once != -1) {
    dispatch_once(&_dx_server_queue_once, &__block_literal_global_20);
  }
  dnssd_server_idle_s_source = (uint64_t)dispatch_source_create( (dispatch_source_type_t)&_dispatch_source_type_data_or,  0LL,  0LL,  (dispatch_queue_t)_dx_server_queue_queue);
  dispatch_source_set_event_handler((dispatch_source_t)dnssd_server_idle_s_source, &__block_literal_global_14);
  dispatch_activate((dispatch_object_t)dnssd_server_idle_s_source);
}

void __dnssd_server_idle_block_invoke_2(id a1)
{
  if (g_session_list)
  {
    uint64_t v1 = mach_absolute_time();
    uint64_t v2 = g_session_list;
    if (g_session_list)
    {
      uint64_t v3 = v1;
      do
      {
        if (!*(void *)(v2 + 32))
        {
          fprintf( __stderrp,  "AssertMacros: %s, %s file: %s, line: %d, value: %lld\n",  "me->connection",  "",  "/Library/Caches/com.apple.xbs/Sources/mDNSResponder/mDNSMacOSX/dnssd_server.c",  1050,  0LL);
          goto LABEL_21;
        }

        if (*(_DWORD *)(v2 + 80))
        {
          uint64_t v4 = *(void *)(v2 + 56);
          if (mdns_mach_ticks_per_second_s_once != -1) {
            dispatch_once(&mdns_mach_ticks_per_second_s_once, &__block_literal_global_3412);
          }
          if ((v3 - v4) / mdns_mach_ticks_per_second_s_ticks_per_second > 4)
          {
            uint64_t v5 = v2;
            int v6 = 2;
            goto LABEL_10;
          }
        }

        for (uint64_t i = *(void *)(v2 + 24); i; uint64_t i = *(void *)(i + 16))
        {
          uint64_t v8 = *(uint64_t (**)(uint64_t))(*(void *)i + 32LL);
          if (v8)
          {
            uint64_t v9 = v8(i);
            if (v9)
            {
              size_t v10 = (void *)v9;
              xpc_object_t v11 = xpc_dictionary_create(0LL, 0LL, 0LL);
              if (!v11)
              {
                _dx_session_terminate(v2, 5);
                xpc_release(v10);
                break;
              }

              int v12 = v11;
              xpc_dictionary_set_uint64(v11, "id", *(void *)(i + 40));
              xpc_dictionary_set_int64(v12, "error", 0LL);
              xpc_dictionary_set_value(v12, "results", v10);
              xpc_release(v10);
              _dx_session_send_message(v2, v12);
              xpc_release(v12);
            }
          }

          uint64_t v16 = 0LL;
          uint64_t v17 = &v16;
          uint64_t v18 = 0x2000000000LL;
          int v19 = 0;
          os_unfair_lock_lock((os_unfair_lock_t)(i + 56));
          *((_DWORD *)v17 + 6) = *(_DWORD *)(i + 52);
          os_unfair_lock_unlock((os_unfair_lock_t)(i + 56));
          int64_t v13 = *((int *)v17 + 6);
          _Block_object_dispose(&v16, 8);
          if ((_DWORD)v13 && !*(_BYTE *)(i + 60))
          {
            xpc_object_t v14 = xpc_dictionary_create(0LL, 0LL, 0LL);
            if (!v14)
            {
              uint64_t v5 = v2;
              int v6 = 5;
LABEL_10:
              _dx_session_terminate(v5, v6);
              break;
            }

            int v15 = v14;
            xpc_dictionary_set_uint64(v14, "id", *(void *)(i + 40));
            xpc_dictionary_set_int64(v15, "error", v13);
            _dx_session_send_message(*(void *)(i + 24), v15);
            xpc_release(v15);
            *(_BYTE *)(i + 60) = 1;
          }
        }

uint64_t *GetAuthInfoForName_direct(uint64_t a1, _BYTE *a2)
{
  if (*a2)
  {
    uint64_t v2 = a2;
    uint64_t v3 = (uint64_t *)(a1 + 12768);
    do
    {
      uint64_t v4 = v3;
      while (1)
      {
        uint64_t v4 = (uint64_t *)*v4;
        if (!v4) {
          break;
        }
      }

      uint64_t v5 = &v2[*v2];
      int v6 = v5[1];
      uint64_t v2 = v5 + 1;
    }

    while (v6);
  }

  return 0LL;
}

void RecreateNATMappings(uint64_t a1, int a2)
{
  else {
    int v3 = *(_DWORD *)(a1 + 64) + a2;
  }
  for (uint64_t i = *(uint64_t **)(a1 + 14648); i; uint64_t i = (uint64_t *)*i)
  {
    i[1] = 0xFA00000000LL;
    *((_DWORD *)i + 4) = v3;
    *((_DWORD *)i + 6) = 0;
    if (!*((_BYTE *)i + 172)) {
      *((_DWORD *)i + 5) = 0;
    }
    uint64_t v5 = (_DWORD *)i[7];
    if (v5)
    {
      mDNSPlatformTCPCloseConnection(v5);
      i[7] = 0LL;
    }
  }

  *(_DWORD *)(a1 + 14676) = arc4random();
  *(_DWORD *)(a1 + 14680) = arc4random();
  *(_DWORD *)(a1 + 14684) = arc4random();
  *(_DWORD *)(a1 + 14664) = 0;
  *(_DWORD *)(a1 + 1466_Block_object_dispose(va, 8) = v3;
  LNT_ClearState(a1);
  *(_DWORD *)(a1 + 104) = *(_DWORD *)(a1 + 64);
}

void natTraversalHandleAddressReply( uint64_t a1, int a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v16 = a3;
  if (a2)
  {
    __int16 v9 = a2;
    if ((unsigned __int16)natTraversalHandleAddressReply_last_err != a2) {
      LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "Error getting external address %d",  a4,  a5,  a6,  a7,  a8,  a2);
    }
    int v16 = 0;
    goto LABEL_5;
  }

  if (mDNS_LoggingEnabled == 1)
  {
    LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "Received external IP address %.4a from NAT",  a4,  a5,  a6,  a7,  a8,  (int)&v16);
    LOBYTE(a3) = v16;
  }

  if (a3 != 10)
  {
    if (a3 == 172)
    {
      if ((BYTE1(v16) & 0xF0) != 0x10) {
        goto LABEL_14;
      }
    }

    else if (a3 != 192 || BYTE1(v16) != 168)
    {
      goto LABEL_14;
    }
  }

  LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "Double NAT (external NAT gateway address %.4a is also a private RFC 1918 address)",  a4,  a5,  a6,  a7,  a8,  (int)&v16);
LABEL_14:
  if (v16)
  {
    __int16 v9 = 0;
    int v10 = 900000;
    *(_DWORD *)(a1 + 14672) = v16;
    goto LABEL_17;
  }

  __int16 v9 = 3;
LABEL_5:
  *(_DWORD *)(a1 + 14672) = 0;
  if (natTraversalHandleAddressReply_last_err)
  {
    int v10 = *(_DWORD *)(a1 + 14664);
    goto LABEL_18;
  }

  int v10 = 250;
LABEL_17:
  *(_DWORD *)(a1 + 14664) = v10;
LABEL_18:
  int v11 = v10 + *(_DWORD *)(a1 + 64);
  *(_DWORD *)(a1 + 1466_Block_object_dispose(va, 8) = v11;
  if (*(_DWORD *)(a1 + 104) - v11 >= 1) {
    *(_DWORD *)(a1 + 104) = v11;
  }
  natTraversalHandleAddressReply_last_err = v9;
  for (uint64_t i = *(uint64_t **)(a1 + 14648); i; uint64_t i = (uint64_t *)*i)
  {
    if (*((_DWORD *)i + 39) != v16)
    {
      int v13 = *((_DWORD *)i + 6);
      if (*((_BYTE *)i + 172))
      {
      }

      else if (v13 != 3)
      {
LABEL_26:
        *((_DWORD *)i + 39) = v16;
        i[1] = 0xFA00000000LL;
        int v14 = *(_DWORD *)(a1 + 64);
        *((_DWORD *)i + 4) = v14;
        int v15 = (_DWORD *)i[7];
        if (v15)
        {
          mDNSPlatformTCPCloseConnection(v15);
          i[7] = 0LL;
          int v14 = *(_DWORD *)(a1 + 64);
        }

        *(_DWORD *)(a1 + 104) = v14;
      }
    }
  }

void natTraversalHandlePortMapReplyWithAddress( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  __int16 v8 = a6;
  int v9 = a4;
  int v22 = a5;
  int v12 = *(unsigned __int8 *)(a2 + 172);
  *(_DWORD *)(a2 + 20) = a4;
  if (!(_DWORD)a4 && (_DWORD)a7 && (_WORD)a6)
  {
    int v13 = a8;
    else {
      int v15 = a7;
    }
    else {
      int v16 = *(_DWORD *)(a1 + 64) + 1000 * v15;
    }
    int v17 = *(_DWORD *)(a2 + 156);
    *(_DWORD *)(a2 + _Block_object_dispose(va, 8) = v16;
    if (v17 == (_DWORD)a5)
    {
    }

    else if (mDNS_LoggingEnabled != 1)
    {
LABEL_23:
      *(void *)(a2 + 144) = a3;
      *(_DWORD *)(a2 + 156) = a5;
      if (v12) {
        *(_WORD *)(a2 + 176) = v8;
      }
      *(_DWORD *)(a2 + memset(&v5[1], 0, 24) = v13;
      int v20 = (*(_DWORD *)(a2 + 8) - *(_DWORD *)(a1 + 64)) / 2;
      if (v20 <= 2000) {
        int v20 = 2000;
      }
      *(_DWORD *)(a2 + 12) = v20;
      int v21 = *(_DWORD *)(a1 + 64);
      *(_DWORD *)(a2 + 16) = v21 + v20;
      *(_DWORD *)(a1 + 104) = v21;
      return;
    }

    LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "natTraversalHandlePortMapReplyWithAddress: %p %s Response %s Port %5d External %.4a:%d changed to %.4a:%d lease %d",  a4,  a5,  a6,  a7,  a8,  a2);
    LODWORD(a5) = v22;
    int v12 = *(unsigned __int8 *)(a2 + 172);
    goto LABEL_23;
  }

  if (mDNS_LoggingEnabled == 1) {
    LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "natTraversalHandlePortMapReplyWithAddress: %p Response %s Port %5d External %.4a:%d lease %d error %d",  a4,  a5,  a6,  a7,  a8,  a2);
  }
  int v18 = *(_DWORD *)(a1 + 64) + 900000;
  *(_DWORD *)(a2 + 12) = 900000;
  *(_DWORD *)(a2 + 16) = v18;
  if (v9 == 2)
  {
    int v19 = -65565;
  }

  else
  {
    int v19 = -65564;
  }

  *(_DWORD *)(a2 + 20) = v19;
}

void mDNS_StopNATOperation_internal(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (uint64_t **)(a1 + 14648);
  uint64_t v5 = (void *)(a1 + 14648);
  do
  {
    int v6 = v5;
    uint64_t v5 = (void *)*v5;
    if (v5) {
      BOOL v7 = v5 == (void *)a2;
    }
    else {
      BOOL v7 = 1;
    }
  }

  while (!v7);
  if (!v5)
  {
    int v10 = (os_log_s *)mDNSLogCategory_NAT;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_NAT == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT, OS_LOG_TYPE_DEFAULT)) {
        return;
      }
      *(_DWORD *)__int128 buf = 134217984;
      *(void *)&uint8_t buf[4] = a2;
    }

    else
    {
      int v10 = (os_log_s *)mDNSLogCategory_NAT_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT_redacted, OS_LOG_TYPE_DEFAULT)) {
        return;
      }
      *(_DWORD *)__int128 buf = 134217984;
      *(void *)&uint8_t buf[4] = a2;
    }

    _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "mDNS_StopNATOperation_internal: NATTraversalInfo %p not found in list",  buf,  0xCu);
    return;
  }

  *int v6 = *v5;
  __int16 v8 = (os_log_s *)mDNSLogCategory_NAT;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_NAT == mDNSLogCategory_State)
  {
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_24;
    }
    goto LABEL_23;
  }

  __int16 v8 = (os_log_s *)mDNSLogCategory_NAT_redacted;
  if (os_log_type_enabled((os_log_t)mDNSLogCategory_NAT_redacted, OS_LOG_TYPE_DEFAULT))
  {
LABEL_23:
    int v13 = *(unsigned __int8 *)(a2 + 172);
    unsigned int v14 = bswap32(*(unsigned __int16 *)(a2 + 174)) >> 16;
    unsigned int v15 = bswap32(*(unsigned __int16 *)(a2 + 176)) >> 16;
    int v16 = *(_DWORD *)(a2 + 180);
    *(_DWORD *)__int128 buf = 134219008;
    *(void *)&uint8_t buf[4] = a2;
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = v13;
    *(_WORD *)&_BYTE buf[18] = 1024;
    *(_DWORD *)&buf[20] = v14;
    LOWORD(v53) = 1024;
    *(_DWORD *)((char *)&v53 + 2) = v15;
    HIWORD(v53) = 1024;
    LODWORD(v54) = v16;
    _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "mDNS_StopNATOperation_internal %p %d %d %d %d",  buf,  0x24u);
  }

LABEL_98:
  if (*(_DWORD *)(a2 + 8))
  {
    if (v18)
    {
      *(_DWORD *)(a2 + 180) = 0;
      *(_DWORD *)(a2 + 12) = 0;
      *(_BYTE *)(a2 + 2_Block_object_dispose(va, 8) = 0;
      *(_WORD *)(a2 + 176) = 0;
      *(_DWORD *)(a2 + 156) = 0;
      uDNS_SendNATMsg(a1, a2, *(_DWORD *)(a2 + 24) != 1, 1);
    }
  }

                  unsigned int v44 = -6756;
                  goto LABEL_113;
                }

                      uint64_t v58 = p_src[3];
                      if (v58)
                      {
                        CFRelease(v58);
                        p_src[3] = 0LL;
                      }

                      _Block_object_dispose(&__src, 8);
                      int v49 = *(void *)(v49 + 64);
                      if (!v49) {
                        goto LABEL_101;
                      }
                    }

                    os_retain((void *)v49);
                    __int16 v54 = *(dispatch_source_s **)(v49 + 88);
                    __size[0] = (size_t)_NSConcreteStackBlock;
                    __size[1] = 0x40000000LL;
                    __size[2] = (size_t)___mdns_subscriber_process_change_notifications_block_invoke_2;
                    __size[3] = (size_t)&__block_descriptor_tmp_28_6682;
                    __size[4] = v49;
                    dispatch_source_set_event_handler(v54, __size);
                    int v55 = *(dispatch_source_s **)(v49 + 88);
                    handler[0] = _NSConcreteStackBlock;
                    handler[1] = 0x40000000LL;
                    _OWORD handler[2] = ___mdns_subscriber_process_change_notifications_block_invoke_3;
                    handler[3] = &__block_descriptor_tmp_29_6683;
                    handler[4] = v49;
                    dispatch_source_set_cancel_handler(v55, handler);
                    dispatch_activate(*(dispatch_object_t *)(v49 + 88));
                    uint64_t v50 = p_src;
                    uint64_t v51 = (unint64_t)p_src[3];
LABEL_93:
                    __int128 v56 = (unint64_t *)(v49 + 96);
                    do
                      int v57 = (const void *)__ldxr(v56);
                    while (__stxr(v51, v56));
                    if (v57)
                    {
                      CFRelease(v57);
                      uint64_t v50 = p_src;
                    }

                    v50[3] = 0LL;
                    dispatch_source_merge_data(*(dispatch_source_t *)(v49 + 88), 1uLL);
                    goto LABEL_98;
                  }

uint64_t mDNS_StartNATOperation(uint64_t a1)
{
  uint64_t started = mDNS_StartNATOperation_internal((uint64_t)mDNSStorage, a1, v2, v3, v4, v5, v6, v7);
  mDNS_Unlock_((uint64_t)mDNSStorage, (uint64_t)"mDNS_StartNATOperation", 1005);
  return started;
}

void FoundStaticHostname( uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = a4;
  uint64_t v11 = *(void *)(a3 + 40);
  int v12 = (_BYTE *)(a1 + 14096);
  int v13 = *(uint64_t **)(a1 + 14608);
  if (*(_WORD *)(a3 + 12))
  {
    if (mDNS_LoggingEnabled) {
      LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "FoundStaticHostname: question %##s -> answer %##s (%s)",  a4,  a5,  a6,  a7,  a8,  a2 + 356);
    }
  }

  else if (mDNS_LoggingEnabled)
  {
    LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "FoundStaticHostname: question %##s -> answer NULL (%s)",  a4,  a5,  a6,  a7,  a8,  a2 + 356);
  }

  if (!v8)
  {
    mDNS_Lock_((unsigned int *)a1, (uint64_t)"FoundStaticHostname", 2587);
    *int v12 = 0;
    unsigned int v16 = *(_DWORD *)(a1 + 64);
    if (v16 <= 1) {
      unsigned int v16 = 1;
    }
    *(_DWORD *)(a1 + 12692) = v16;
    uint64_t v17 = a1;
    int v18 = 2590;
    goto LABEL_33;
  }

  unsigned int v14 = (_BYTE *)(v11 + 4);
  if (v11 == -260)
  {
LABEL_11:
    while (v14)
    {
      uint64_t v15 = *v14;
      if (!*v14)
      {
        unsigned __int16 v19 = (_WORD)v14 - (v11 + 4) + 1;
        if (v19 > 0x100u) {
          break;
        }
        memcpy(v12, (const void *)(v11 + 4), v19);
        goto LABEL_23;
      }

      v14 += v15 + 1;
      if (v11 != -260) {
        goto LABEL_10;
      }
    }
  }

  else
  {
LABEL_10:
  }

  *int v12 = 0;
LABEL_23:
  if (!v13)
  {
LABEL_30:
    mDNS_Lock_((unsigned int *)a1, (uint64_t)"FoundStaticHostname", 2581);
    unsigned int v22 = *(_DWORD *)(a1 + 64);
    if (v22 <= 1) {
      unsigned int v22 = 1;
    }
    *(_DWORD *)(a1 + 12692) = v22;
    uint64_t v17 = a1;
    int v18 = 2583;
LABEL_33:
    mDNS_Unlock_(v17, (uint64_t)"FoundStaticHostname", v18);
    return;
  }

  while (1)
  {
    int v20 = *((_DWORD *)v13 + 202);
    BOOL v21 = v20 == 1 || v20 == 6;
    if (v21 || *((_DWORD *)v13 + 496) == 1) {
      break;
    }
    int v13 = (uint64_t *)*v13;
    if (!v13) {
      goto LABEL_30;
    }
  }

  unsigned int v23 = *(_DWORD *)(a1 + 64) + 5000;
  if (v23 <= 1) {
    unsigned int v23 = 1;
  }
  *(_DWORD *)(a1 + 12692) = v23;
}

void UpdateOneSRVRecord(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 48);
  uint64_t ServiceTarget = GetServiceTarget(a1, a2);
  if (ServiceTarget) {
    uint64_t v6 = (char *)ServiceTarget;
  }
  else {
    uint64_t v6 = "";
  }
  int v7 = *v6 && *(_DWORD *)(a2 + 344) == 8 || SameDomainNameBytes((_BYTE *)(v4 + 10), v6) == 0;
  uint64_t v8 = *(void *)(a2 + 48);
  int v9 = *(unsigned __int16 *)(v8 + 8);
  if (*(_BYTE *)(a2 + 120) != 2 || v9 == 0) {
    goto LABEL_13;
  }
  int v13 = *(unsigned __int8 *)(a1 + 12728);
  if (v13 == 10) {
    goto LABEL_41;
  }
  if (v13 == 172)
  {
    if ((*(_BYTE *)(a1 + 12729) & 0xF0) == 0x10) {
      goto LABEL_41;
    }
LABEL_13:
    LODWORD(v11) = 0;
    goto LABEL_14;
  }

void UpdateAllServiceRecords(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v5 = (unsigned __int8 *)(a2 + 8);
  if (*(_WORD *)(a2 + 12) != 33)
  {
    int v7 = "UpdateAllServiceRecords:ERROR!! ResourceRecord not a service record %s";
    goto LABEL_6;
  }

  if (a3 && *(_DWORD *)(a2 + 344) == 8)
  {
    int v7 = "UpdateAllServiceRecords:ERROR!! SRV record %s in noTarget state during registration";
LABEL_6:
    uint64_t v8 = (os_log_s *)mDNSLogCategory_Default;
    int v9 = (_BYTE *)(a1 + 46976);
    GetRRDisplayString_rdb(v5, (unsigned __int16 *)(*(void *)(a2 + 48) + 4LL), v9);
    LogMsgWithLevel(v8, OS_LOG_TYPE_DEFAULT, v7, v10, v11, v12, v13, v14, (int)v9);
    return;
  }

  if (mDNS_LoggingEnabled == 1)
  {
    uint64_t v15 = (os_log_s *)mDNSLogCategory_Default;
    GetRRDisplayString_rdb(v5, (unsigned __int16 *)(*(void *)(a2 + 48) + 4LL), (_BYTE *)(a1 + 46976));
    LogMsgWithLevel( v15,  OS_LOG_TYPE_DEFAULT,  "UpdateAllServiceRecords: ResourceRecord %s",  v16,  v17,  v18,  v19,  v20,  a1 + 46976);
  }

  uint64_t v21 = *(void *)(a1 + 12624);
  if (v21)
  {
    while (*(void *)(v21 + 32) || *(_BYTE *)(v21 + 122) || IsLocalDomain(*(_BYTE **)(v21 + 40)))
    {
LABEL_23:
      uint64_t v21 = *(void *)v21;
      if (!v21) {
        return;
      }
    }

    int v22 = *(unsigned __int16 *)(v21 + 12);
    if (v22 == 16)
    {
      uint64_t v23 = (uint64_t *)(v21 + 88);
    }

    else
    {
      if (v22 != 12)
      {
        uint64_t v24 = 0LL;
LABEL_22:
        if (v24 == a2)
        {
          uint64_t v31 = (unsigned __int8 *)(v21 + 8);
          if (a3)
          {
            *(_BYTE *)(v21 + 592) = 0;
            int v32 = *(_DWORD *)(v21 + 344);
            if (v32 == 2 || v32 == 1 && (uint64_t v33 = *(void *)(v21 + 376)) != 0 && *(_DWORD *)(v33 + 792))
            {
              if (mDNS_LoggingEnabled == 1)
              {
                uint64_t v34 = (os_log_s *)mDNSLogCategory_Default;
                GetRRDisplayString_rdb(v31, (unsigned __int16 *)(*(void *)(v21 + 48) + 4LL), (_BYTE *)(a1 + 46976));
                LogMsgWithLevel( v34,  OS_LOG_TYPE_DEFAULT,  "UpdateAllServiceRecords: not registering %s, state %d",  v35,  v36,  v37,  v38,  v39,  a1 + 46976);
              }
            }

            else
            {
              if (mDNS_LoggingEnabled == 1)
              {
                int v46 = (os_log_s *)mDNSLogCategory_Default;
                GetRRDisplayString_rdb(v31, (unsigned __int16 *)(*(void *)(v21 + 48) + 4LL), (_BYTE *)(a1 + 46976));
                LogMsgWithLevel( v46,  OS_LOG_TYPE_DEFAULT,  "UpdateAllServiceRecords: registering %s, state %d",  v47,  v48,  v49,  v50,  v51,  a1 + 46976);
              }

              ActivateUnicastRegistration(a1, v21);
            }
          }

          else
          {
            if (mDNS_LoggingEnabled == 1)
            {
              uint64_t v40 = (os_log_s *)mDNSLogCategory_Default;
              GetRRDisplayString_rdb(v31, (unsigned __int16 *)(*(void *)(v21 + 48) + 4LL), (_BYTE *)(a1 + 46976));
              LogMsgWithLevel( v40,  OS_LOG_TYPE_DEFAULT,  "UpdateAllServiceRecords: deregistering %s",  v41,  v42,  v43,  v44,  v45,  a1 + 46976);
            }

            *(_BYTE *)(v21 + 592) = 1;
            *(_DWORD *)(v21 + 280) = 1000;
            *(_DWORD *)(v21 + 284) = *(_DWORD *)(a1 + 64) - 1000;
            *(_DWORD *)(v21 + 344) = 3;
          }
        }

        goto LABEL_23;
      }

      uint64_t v23 = (uint64_t *)(v21 + 72);
    }

    uint64_t v24 = *v23;
    if (*v23 && *(_WORD *)(v24 + 12) != 33)
    {
      uint64_t v25 = (os_log_s *)mDNSLogCategory_Default;
      GetRRDisplayString_rdb( (unsigned __int8 *)(v24 + 8),  (unsigned __int16 *)(*(void *)(v24 + 48) + 4LL),  (_BYTE *)(a1 + 46976));
      LogMsgWithLevel( v25,  OS_LOG_TYPE_DEFAULT,  "UpdateAllServiceRecords: ERROR!! Resource record %s wrong, expecting SRV type",  v26,  v27,  v28,  v29,  v30,  a1 + 46976);
    }

    goto LABEL_22;
  }

void hostnameGetPublicAddressCallback( unsigned int *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9)
{
  uint64_t v9 = *(void *)(a2 + 192);
  if (!v9)
  {
    LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "RegisterHostnameRecord: registration cancelled",  a4,  a5,  a6,  a7,  a8,  a9);
    return;
  }

  if (!*(_DWORD *)(a2 + 168))
  {
    uint64_t v11 = (_DWORD *)(a2 + 152);
    int v10 = *(_DWORD *)(a2 + 152);
    if (v10 && v10 != 10)
    {
      if (v10 == 172)
      {
        if ((BYTE1(v10) & 0xF0) == 0x10) {
          return;
        }
      }

      else if (v10 == 192 && BYTE1(v10) == 168)
      {
        return;
      }

      if (*(_BYTE *)(v9 + 472))
      {
        if (*(_DWORD *)(*(void *)(v9 + 512) + 4LL) != v10)
        {
          if (mDNS_LoggingEnabled == 1) {
            LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "Updating hostname %p %##s IPv4 from %.4a to %.4a (NAT gateway's external address)",  a4,  a5,  a6,  a7,  a8,  a2);
          }
          mDNS_Deregister(a1, v9 + 464);
        }
      }

      else
      {
        if (mDNS_LoggingEnabled == 1) {
          LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "Advertising hostname %##s IPv4 %.4a (NAT gateway's external address)",  a4,  a5,  a6,  a7,  a8,  *(void *)(v9 + 504));
        }
        *(_BYTE *)(v9 + 472) = 32;
        *(_DWORD *)(*(void *)(v9 + 512) + 4LL) = *v11;
        mDNS_Register(a1, v9 + 464);
      }
    }
  }

void mDNS_RemoveDynDNSHostName(_BYTE *a1)
{
  uint64_t v2 = (os_log_s *)mDNSLogCategory_uDNS;
  if (gSensitiveLoggingEnabled == 1 && mDNSLogCategory_uDNS != mDNSLogCategory_State)
  {
    uint64_t v2 = (os_log_s *)mDNSLogCategory_uDNS_redacted;
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_uDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_37;
    }
    if (a1)
    {
      uint64_t v8 = a1;
      if (a1 == (_BYTE *)-256LL) {
        goto LABEL_23;
      }
LABEL_20:
      unsigned __int16 v9 = 257;
      if (v8 < a1 + 256 && v8)
      {
        while (1)
        {
          uint64_t v10 = *v8;
          if (v10 > 0x3F)
          {
LABEL_31:
            unsigned __int16 v9 = 257;
            goto LABEL_35;
          }

          if (!*v8) {
            break;
          }
          v8 += v10 + 1;
          if (a1 != (_BYTE *)-256LL) {
            goto LABEL_20;
          }
LABEL_23:
          if (!v8) {
            goto LABEL_31;
          }
        }

        unsigned __int16 v9 = (_WORD)v8 - (_WORD)a1 + 1;
      }

LABEL_122:
        int v40 = 141558531;
        uint64_t v41 = 1752392040LL;
        __int16 v42 = 1040;
        int v43 = v28;
        __int16 v44 = 2101;
        uint64_t v45 = a1;
        _os_log_impl( (void *)&_mh_execute_header,  v26,  OS_LOG_TYPE_DEFAULT,  "mDNS_RemoveDynDNSHostName removing v4 %{sensitive, mask.hash, mdnsresponder:domain_name}.*P",  (uint8_t *)&v40,  0x1Cu);
      }
    }

    mDNS_Deregister_internal((uint64_t)mDNSStorage, (uint64_t)(v15 + 116), 0);
LABEL_124:
    if (!v17) {
      goto LABEL_101;
    }
    uint64_t v33 = (uint64_t)(v15 + 410);
    uint64_t v34 = (os_log_s *)mDNSLogCategory_uDNS;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_uDNS == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_uDNS, OS_LOG_TYPE_DEFAULT))
      {
        if (a1)
        {
          uint64_t v38 = a1;
          if (a1 == (_BYTE *)-256LL) {
            goto LABEL_144;
          }
LABEL_141:
          int v36 = 257;
          if (v38 < a1 + 256 && v38)
          {
            while (1)
            {
              uint64_t v39 = *v38;
              if (v39 > 0x3F)
              {
LABEL_152:
                int v36 = 257;
                goto LABEL_156;
              }

              if (!*v38) {
                break;
              }
              v38 += v39 + 1;
              if (a1 != (_BYTE *)-256LL) {
                goto LABEL_141;
              }
LABEL_144:
              if (!v38) {
                goto LABEL_152;
              }
            }

            int v36 = (unsigned __int16)((_WORD)v38 - (_WORD)a1 + 1);
          }
        }

        else
        {
          int v36 = 0;
        }

        goto LABEL_156;
      }
    }

    else
    {
      uint64_t v34 = (os_log_s *)mDNSLogCategory_uDNS_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_uDNS_redacted, OS_LOG_TYPE_DEFAULT))
      {
        if (a1)
        {
          uint64_t v35 = a1;
          if (a1 == (_BYTE *)-256LL) {
            goto LABEL_133;
          }
LABEL_130:
          int v36 = 257;
          if (v35 < a1 + 256 && v35)
          {
            while (1)
            {
              uint64_t v37 = *v35;
              if (v37 > 0x3F)
              {
LABEL_151:
                int v36 = 257;
                goto LABEL_156;
              }

              if (!*v35) {
                break;
              }
              v35 += v37 + 1;
              if (a1 != (_BYTE *)-256LL) {
                goto LABEL_130;
              }
LABEL_133:
              if (!v35) {
                goto LABEL_151;
              }
            }

            int v36 = (unsigned __int16)((_WORD)v35 - (_WORD)a1 + 1);
          }
        }

        else
        {
          int v36 = 0;
        }

    int v67 = DNSTypeName(*(unsigned __int16 *)(a2 + 322));
    __int32 v90 = 67110147;
    __int32 v91 = v25;
    __int32 v92 = 2160;
    int32x2_t v93 = 1752392040LL;
    int v94 = 1040;
    uint64_t v95 = v40;
    __int32 v96 = 2101;
    __int32 v97 = a2 + 356;
    __int32 v98 = 2082;
    __int32 v99 = v67;
    _os_log_impl( (void *)&_mh_execute_header,  v22,  OS_LOG_TYPE_DEBUG,  "[R%u] QueryRecordOpCallback: Suppressed question %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%{public}s)",  (uint8_t *)&v90,  0x2Cu);
    goto LABEL_123;
  }

  if (*((_WORD *)a3 + 2) != 5) {
    goto LABEL_30;
  }
  if (a3[2] == 2) {
    *(_BYTE *)(v12 + 720) = 1;
  }
  if (*(_BYTE *)(a2 + 615) || *(_WORD *)(a2 + 322) == 5)
  {
LABEL_30:
    if (*a3 != 240)
    {
      uint64_t v23 = 0LL;
      goto LABEL_44;
    }

    if (*(_BYTE *)(a2 + 617))
    {
      mDNS_Lock_((unsigned int *)a1, (uint64_t)"GetTimeNow", 723);
      int v28 = *(_DWORD *)(a1 + 64);
      mDNS_Unlock_(a1, (uint64_t)"GetTimeNow", 725);
      if (v28 - *(_DWORD *)(a2 + 240) >= 0)
      {
        uint64_t v29 = (os_log_s *)mDNSLogCategory_Default;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
        {
          uint64_t v23 = 4294901728LL;
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
          {
            int v30 = *(_DWORD *)(v12 + 688);
            uint64_t v38 = (_BYTE *)(a2 + 356);
            if (a2 == -612)
            {
LABEL_62:
              while (v38)
              {
                uint64_t v39 = *v38;
                if (!*v38)
                {
                  uint32_t v66 = (unsigned __int16)((_WORD)v38 - (a2 + 356) + 1);
                  goto LABEL_142;
                }

                v38 += v39 + 1;
                if (a2 != -612) {
                  goto LABEL_61;
                }
              }
            }

            else
            {
LABEL_61:
            }

            uint32_t v66 = 257;
            goto LABEL_142;
          }
        }

        else
        {
          uint64_t v29 = (os_log_s *)mDNSLogCategory_Default_redacted;
          uint64_t v23 = 4294901728LL;
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
          {
            int v30 = *(_DWORD *)(v12 + 688);
            uint64_t v31 = (_BYTE *)(a2 + 356);
            if (a2 == -612)
            {
LABEL_38:
              while (v31)
              {
                uint64_t v32 = *v31;
                if (!*v31)
                {
                  uint32_t v66 = (unsigned __int16)((_WORD)v31 - (a2 + 356) + 1);
                  goto LABEL_142;
                }

                v31 += v32 + 1;
                if (a2 != -612) {
                  goto LABEL_37;
                }
              }
            }

            else
            {
LABEL_37:
            }

            uint32_t v66 = 257;
LABEL_142:
            uint64_t v72 = DNSTypeName(*(unsigned __int16 *)(a2 + 322));
            uint64_t v73 = *(void *)(a2 + 136);
            __int32 v90 = 67110403;
            __int32 v91 = v30;
            __int32 v92 = 2160;
            int32x2_t v93 = 1752392040LL;
            int v94 = 1040;
            uint64_t v95 = v66;
            __int32 v96 = 2101;
            __int32 v97 = a2 + 356;
            __int32 v98 = 2082;
            __int32 v99 = v72;
            int32x2_t v100 = 2048;
            int v101 = v73;
            _os_log_impl( (void *)&_mh_execute_header,  v29,  OS_LOG_TYPE_DEFAULT,  "[R%u] QueryRecordOpCallback: Question %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%{public}s) t iming out, InterfaceID %p",  (uint8_t *)&v90,  0x36u);
          }
        }

        uint64_t v33 = 1;
LABEL_144:
        if (&_NEHelperTrackerGetAppInfo)
        {
          uint64_t v74 = 1;
          if (!(_DWORD)a4) {
            goto LABEL_152;
          }
        }

        else
        {
          uint64_t v74 = _os_feature_enabled_impl("symptomsd", "networking_transparency");
          if (!(_DWORD)a4)
          {
LABEL_152:
            dispatch_source_t v75 = *(void (**)(uint64_t, uint64_t, unsigned __int8 *, BOOL, uint64_t, uint64_t, void))(v12 + 672);
            if (v75)
            {
              if ((_DWORD)a4 == 1)
              {
                if (*(_BYTE *)(v12 + 720)) {
                  __int16 v76 = 1LL;
                }
                else {
                  __int16 v76 = a3[2] == 2;
                }
              }

              else
              {
                __int16 v76 = 0LL;
              }

              v75(a1, a2, a3, v76, a4, v23, *(void *)(v12 + 680));
            }

            int v77 = v33 ^ 1;
            if (*(void *)(a1 + 216) != a2) {
              int v77 = 1;
            }
            if ((v77 & 1) == 0)
            {
              resolved_cache_delete(a2);
              mDNS_StopQuery((unsigned int *)mDNSStorage, a2);
              *(void *)(a2 + 176) = 0LL;
            }

            return;
          }
        }

        if (v74
          && *(_WORD *)(a2 + 320)
          && ((unint64_t)(*((void *)a3 + 3) + 5LL) > 3 || *((void *)a3 + 3) == -4LL)
          && *a3 != 240)
        {
          __int16 v78 = *((unsigned __int16 *)a3 + 2);
          if (v78 == 28 || v78 == 1)
          {
            unsigned int v79 = &s_head_0;
            while (1)
            {
              unsigned int v79 = (uint64_t *)*v79;
              if (!v79) {
                break;
              }
              if (v79[1] == a2)
              {
                if (v78 == 1) {
                  __int16 v80 = 4LL;
                }
                else {
                  __int16 v80 = 16LL;
                }
                int v81 = CFDataCreate(kCFAllocatorDefault, (const UInt8 *)(*((void *)a3 + 5) + 4LL), v80);
                if (v81)
                {
                  __int16 v82 = v81;
                  CFArrayAppendValue((CFMutableArrayRef)v79[6], v81);
                  CFRelease(v82);
                }

                goto LABEL_152;
              }
            }
          }
        }

        goto LABEL_152;
      }
    }

    if (*(_BYTE *)(a2 + 621))
    {
      if ((_DWORD)a4)
      {
        if ((*(_DWORD *)(v12 + 692) & 0x80000000) == 0)
        {
          uint64_t v34 = NextSearchDomain(v12, a2, (uint64_t)a3, a4, a5, a6, a7, a8);
          if (v34 || (uint64_t v41 = *(_BYTE **)(v12 + 656), *v41) && !v41[*v41 + 1])
          {
            resolved_cache_delete(a2);
            mDNS_StopQuery((unsigned int *)mDNSStorage, a2);
            *(void *)(a2 + 176) = 0LL;
            QueryRecordOpRestartUnicastQuestion(v12, a2, v34);
            return;
          }
        }
      }
    }

    if (!*(_BYTE *)(v12 + 719) || *(_WORD *)(a2 + 322) != 28 || (__int16 v42 = a3[1], v42 == 3))
    {
      if (*(_BYTE *)(v12 + 724))
      {
        if (!*(_BYTE *)(a2 + 623))
        {
          uint64_t v48 = *(void *)(a2 + 80);
          if (v48)
          {
            uint64_t v49 = *(void *)(v48 + 96);
            if (v49)
            {
              if (nw_resolver_config_get_allow_failover(v49))
              {
                QueryRecordOpStopQuestion(a2);
                uint64_t v50 = *(unsigned __int16 *)(v12 + 722);
                *(_WORD *)(a2 + 322) = v50;
                *(_BYTE *)(a2 + 623) = 1;
                if (!*(void *)(a2 + 136)) {
                  *(_BYTE *)(a2 + 622) = 1;
                }
                uint64_t v51 = (os_log_s *)mDNSLogCategory_Default;
                if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
                {
                  if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEBUG))
                  {
                    __int16 v59 = *(_DWORD *)(v12 + 688);
                    int v85 = (_BYTE *)(a2 + 356);
                    if (a2 == -612)
                    {
LABEL_182:
                      while (v85)
                      {
                        __int16 v86 = *v85;
                        if (!*v85)
                        {
                          __int16 v88 = (unsigned __int16)((_WORD)v85 - (a2 + 356) + 1);
                          goto LABEL_198;
                        }

                        v85 += v86 + 1;
                        if (a2 != -612) {
                          goto LABEL_181;
                        }
                      }
                    }

                    else
                    {
LABEL_181:
                    }

                    __int16 v88 = 257;
                    goto LABEL_198;
                  }
                }

                else
                {
                  uint64_t v51 = (os_log_s *)mDNSLogCategory_Default_redacted;
                  if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEBUG))
                  {
                    __int16 v59 = *(_DWORD *)(v12 + 688);
                    int v60 = (_BYTE *)(a2 + 356);
                    if (a2 == -612)
                    {
LABEL_103:
                      while (v60)
                      {
                        char v61 = *v60;
                        if (!*v60)
                        {
                          __int16 v88 = (unsigned __int16)((_WORD)v60 - (a2 + 356) + 1);
                          goto LABEL_198;
                        }

                        v60 += v61 + 1;
                        if (a2 != -612) {
                          goto LABEL_102;
                        }
                      }
                    }

                    else
                    {
LABEL_102:
                    }

                    __int16 v88 = 257;
LABEL_198:
                    __int32 v90 = 67110147;
                    __int32 v91 = v59;
                    __int32 v92 = 2160;
                    int32x2_t v93 = 1752392040LL;
                    int v94 = 1040;
                    uint64_t v95 = v88;
                    __int32 v96 = 2101;
                    __int32 v97 = a2 + 356;
                    __int32 v98 = 2082;
                    __int32 v99 = DNSTypeName(v50);
                    _os_log_impl( (void *)&_mh_execute_header,  v51,  OS_LOG_TYPE_DEBUG,  "[R%u] Restarting question for %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%{public}s) d ue to DNS service failover",  (uint8_t *)&v90,  0x2Cu);
                  }
                }

                if (*(_BYTE *)(a2 + 621))
                {
                  *(void *)(v12 + 692) = 0LL;
                  unsigned int v89 = NextSearchDomain(v12, v52, v53, v54, v55, v56, v57, v58);
                }

                else
                {
                  unsigned int v89 = 0LL;
                }

                QueryRecordOpRestartUnicastQuestion(v12, a2, v89);
                return;
              }
            }
          }
        }
      }

      uint64_t v23 = 4294901742LL;
      if (*((void *)a3 + 3) || !IsLocalDomain(*((_BYTE **)a3 + 4))) {
        goto LABEL_44;
      }
      int v43 = *(unsigned __int16 *)(a2 + 322);
      __int16 v44 = (os_log_s *)mDNSLogCategory_Default;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_44;
        }
        uint64_t v45 = *(_DWORD *)(v12 + 688);
        unsigned __int8 v70 = (_BYTE *)(a2 + 356);
        if (a2 == -612)
        {
LABEL_135:
          while (v70)
          {
            uint64_t v71 = *v70;
            if (!*v70)
            {
              __int16 v84 = (unsigned __int16)((_WORD)v70 - (a2 + 356) + 1);
              goto LABEL_193;
            }

            v70 += v71 + 1;
            if (a2 != -612) {
              goto LABEL_134;
            }
          }
        }

        else
        {
LABEL_134:
        }

        __int16 v84 = 257;
      }

      else
      {
        __int16 v44 = (os_log_s *)mDNSLogCategory_Default_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_44;
        }
        uint64_t v45 = *(_DWORD *)(v12 + 688);
        int v46 = (_BYTE *)(a2 + 356);
        if (a2 == -612)
        {
LABEL_88:
          while (v46)
          {
            uint64_t v47 = *v46;
            if (!*v46)
            {
              __int16 v84 = (unsigned __int16)((_WORD)v46 - (a2 + 356) + 1);
              goto LABEL_193;
            }

            v46 += v47 + 1;
            if (a2 != -612) {
              goto LABEL_87;
            }
          }
        }

        else
        {
LABEL_87:
        }

        __int16 v84 = 257;
      }

uint64_t ParseTSIGError(uint64_t a1, unint64_t a2, unint64_t a3, int a4)
{
  uint64_t v8 = (unsigned __int8 *)(a1 + 37864);
  Additionals = LocateAdditionals(a2, a3);
  if (Additionals && *(_WORD *)(a2 + 10))
  {
    uint64_t v10 = Additionals;
    for (unsigned int i = 0; i < *(unsigned __int16 *)(a2 + 10); ++i)
    {
      LargeResourceRecord = GetLargeResourceRecord(a1, a2, v10, a3, 0LL, 128, a1 + 37856);
      if (!LargeResourceRecord) {
        break;
      }
      uint64_t v10 = LargeResourceRecord;
      if (*v8 != 240 && *((_WORD *)v8 + 2) == 250)
      {
        uint64_t v22 = *((void *)v8 + 5) + 4LL;
        unint64_t v23 = v22 + *((unsigned __int16 *)v8 + 6);
        uint64_t v24 = (_BYTE *)v22;
        if (!v23) {
          goto LABEL_18;
        }
LABEL_15:
        uint64_t v19 = 0LL;
        while (1)
        {
          uint64_t v25 = *v24;
          if (!*v24)
          {
            unsigned __int16 v26 = (_WORD)v24 - v22 + 1;
            if (v26 > 0x100u) {
              goto LABEL_10;
            }
            uint64_t v27 = v22 + v26;
            if (v27 + 6 > v23) {
              goto LABEL_10;
            }
            int v28 = (unsigned __int16 *)(v27 + 8);
            if (v27 + 8 > v23) {
              goto LABEL_10;
            }
            unint64_t v29 = v27 + 10;
            if (v29 > v23) {
              goto LABEL_10;
            }
            unint64_t v30 = v29 + (bswap32(*v28) >> 16);
            if (v30 > v23) {
              goto LABEL_10;
            }
            uint64_t v31 = (unsigned __int16 *)(v30 + 2);
            unint64_t v32 = v30 + 4;
            unsigned int v34 = bswap32(*v31);
            uint64_t v19 = HIWORD(v34);
            if (HIWORD(v34) > 0x10u)
            {
              if ((_DWORD)v19 == 17)
              {
                uint64_t v19 = 4294901735LL;
                LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "%##s: bad key",  v13,  v14,  v15,  v16,  v17,  a4);
                goto LABEL_11;
              }

              if ((_DWORD)v19 == 18)
              {
                LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "%##s: bad time",  v13,  v14,  v15,  v16,  v17,  a4);
                uint64_t v19 = 4294901737LL;
                goto LABEL_11;
              }
            }

            else
            {
              if (!(_DWORD)v19) {
                goto LABEL_11;
              }
              if ((_DWORD)v19 == 16)
              {
                LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "%##s: bad signature",  v13,  v14,  v15,  v16,  v17,  a4);
                uint64_t v19 = 4294901736LL;
                goto LABEL_11;
              }
            }

            LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "%##s: unknown tsig error %d",  v13,  v14,  v15,  v16,  v17,  a4);
            uint64_t v19 = 4294901759LL;
            goto LABEL_11;
          }

          v24 += v25 + 1;
          if (v23) {
            goto LABEL_15;
          }
LABEL_18:
          if (!v24) {
            goto LABEL_10;
          }
        }
      }

      *(_WORD *)uint64_t v8 = 0;
      *((_WORD *)v8 + 51) = 0;
      uint64_t v18 = (void *)*((void *)v8 + 7);
      if (v18)
      {
        ref_count_obj_release(v18);
        *((void *)v8 + 7) = 0LL;
      }
    }
  }

const char *LLQStateToString(int a1)
{
  if (a1 <= 9)
  {
    if (!a1) {
      return "LLQ_Invalid";
    }
    if (a1 == 1) {
      return "LLQ_Init";
    }
LABEL_9:
    uint64_t v3 = (os_log_s *)mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_FAULT)) {
        return "<INVALID LLQ_State>";
      }
      int v6 = 67109120;
      int v7 = a1;
    }

    else
    {
      uint64_t v3 = (os_log_s *)mDNSLogCategory_Default_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_FAULT)) {
        return "<INVALID LLQ_State>";
      }
      int v6 = 67109120;
      int v7 = a1;
    }

    _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_FAULT,  "Invalid LLQ_State - state: %u",  (uint8_t *)&v6,  8u);
    return "<INVALID LLQ_State>";
  }

  switch(a1)
  {
    case 10:
      uint64_t result = "LLQ_DNSPush_ServerDiscovery";
      break;
    case 11:
      uint64_t result = "LLQ_DNSPush_Connecting";
      break;
    case 12:
      uint64_t result = "LLQ_DNSPush_Established";
      break;
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
      goto LABEL_9;
    case 20:
      uint64_t result = "LLQ_InitialRequest";
      break;
    case 21:
      uint64_t result = "LLQ_SecondaryRequest";
      break;
    case 22:
      uint64_t result = "LLQ_Established";
      break;
    default:
      if (a1 != 30) {
        goto LABEL_9;
      }
      uint64_t result = "LLQ_Poll";
      break;
  }

  return result;
}

void uDNS_DeregisterRecord(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (os_log_s *)mDNSLogCategory_uDNS;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_uDNS == mDNSLogCategory_State)
  {
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_uDNS, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_10;
    }
  }

  else
  {
    uint64_t v4 = (os_log_s *)mDNSLogCategory_uDNS_redacted;
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_uDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_10;
    }
  }

  GetRRDisplayString_rdb( (unsigned __int8 *)(a2 + 8),  (unsigned __int16 *)(*(void *)(a2 + 48) + 4LL),  (_BYTE *)(a1 + 46976));
  int v7 = *(_DWORD *)(a2 + 344);
  *(_DWORD *)__int128 buf = 141558531;
  *(void *)uint64_t v37 = 1752392040LL;
  *(_WORD *)&v37[8] = 2085;
  *(void *)&v37[10] = a1 + 46976;
  *(_WORD *)&v37[18] = 1024;
  *(_DWORD *)uint64_t v38 = v7;
  _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "uDNS_DeregisterRecord: Resource Record %{sensitive, mask.hash}s, state %d",  buf,  0x1Cu);
LABEL_10:
  unsigned int v8 = *(_DWORD *)(a2 + 344);
  if (v8 <= 9 && ((1 << v8) & 0x351) != 0)
  {
    uint64_t v10 = (os_log_s *)mDNSLogCategory_uDNS;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_uDNS == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_uDNS, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_49;
      }
      uint64_t v11 = *(void *)(a2 + 40);
      if (v11)
      {
        uint64_t v14 = *(_BYTE **)(a2 + 40);
        if (v11 == -256)
        {
LABEL_29:
          while (v14)
          {
            uint64_t v15 = *v14;
            if (!*v14)
            {
              int v20 = (unsigned __int16)((_WORD)v14 - v11 + 1);
              goto LABEL_48;
            }

            v14 += v15 + 1;
            if (v11 != -256) {
              goto LABEL_28;
            }
          }
        }

        else
        {
LABEL_28:
        }

        int v20 = 257;
      }

      else
      {
        int v20 = 0;
      }
    }

    else
    {
      uint64_t v10 = (os_log_s *)mDNSLogCategory_uDNS_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_uDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_49;
      }
      uint64_t v11 = *(void *)(a2 + 40);
      if (v11)
      {
        uint64_t v12 = *(_BYTE **)(a2 + 40);
        if (v11 == -256)
        {
LABEL_20:
          while (v12)
          {
            uint64_t v13 = *v12;
            if (!*v12)
            {
              int v20 = (unsigned __int16)((_WORD)v12 - v11 + 1);
              goto LABEL_48;
            }

            v12 += v13 + 1;
            if (v11 != -256) {
              goto LABEL_19;
            }
          }
        }

        else
        {
LABEL_19:
        }

        int v20 = 257;
      }

      else
      {
        int v20 = 0;
      }
    }

LABEL_59:
  uint64_t v22 = *(void *)(a2 + 640);
  if (!v22 || !*(void *)(a2 + 320)) {
    goto LABEL_75;
  }
  uint64_t v23 = *(void *)(a2 + 48);
  char v24 = gSensitiveLoggingEnabled;
  uint64_t v25 = (os_log_s *)mDNSLogCategory_uDNS;
  if (mDNSLogCategory_uDNS == mDNSLogCategory_State) {
    char v24 = 0;
  }
  if (v22 != v23)
  {
    if ((v24 & 1) != 0)
    {
      uint64_t v25 = (os_log_s *)mDNSLogCategory_uDNS_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_uDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_71;
      }
    }

    else if (os_log_type_enabled((os_log_t)mDNSLogCategory_uDNS, OS_LOG_TYPE_DEFAULT))
    {
LABEL_71:
      GetRRDisplayString_rdb((unsigned __int8 *)(a2 + 8), (unsigned __int16 *)(v23 + 4), (_BYTE *)(a1 + 46976));
      *(_DWORD *)__int128 buf = 141558275;
      *(void *)uint64_t v37 = 1752392040LL;
      *(_WORD *)&v37[8] = 2085;
      *(void *)&v37[10] = a1 + 46976;
      _os_log_impl( (void *)&_mh_execute_header,  v25,  OS_LOG_TYPE_DEFAULT,  "uDNS_DeregisterRecord: Freeing QueuedRData for %{sensitive, mask.hash}s",  buf,  0x16u);
    }

    (*(void (**)(uint64_t, uint64_t, void, void))(a2 + 320))( a1,  a2,  *(void *)(a2 + 640),  *(unsigned __int16 *)(a2 + 620));
    *(void *)(a2 + 640) = 0LL;
    goto LABEL_75;
  }

  if ((v24 & 1) == 0)
  {
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_uDNS, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_75;
    }
LABEL_74:
    GetRRDisplayString_rdb((unsigned __int8 *)(a2 + 8), (unsigned __int16 *)(v22 + 4), (_BYTE *)(a1 + 46976));
    *(_DWORD *)__int128 buf = 141558275;
    *(void *)uint64_t v37 = 1752392040LL;
    *(_WORD *)&v37[8] = 2085;
    *(void *)&v37[10] = a1 + 46976;
    _os_log_impl( (void *)&_mh_execute_header,  v25,  OS_LOG_TYPE_DEFAULT,  "uDNS_DeregisterRecord: ERROR!! QueuedRData same as rdata for %{sensitive, mask.hash}s",  buf,  0x16u);
    goto LABEL_75;
  }

  uint64_t v25 = (os_log_s *)mDNSLogCategory_uDNS_redacted;
  if (os_log_type_enabled((os_log_t)mDNSLogCategory_uDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
    goto LABEL_74;
  }
LABEL_75:
  if (!*(_WORD *)(a2 + 358)) {
    goto LABEL_110;
  }
  unsigned __int16 v26 = *(unsigned __int8 **)(a1 + 12624);
  if (!v26) {
    goto LABEL_101;
  }
  char v27 = 1;
  do
  {
    while (!*(void *)(a2 + 32)
         && !*(_BYTE *)(a2 + 122)
         && !IsLocalDomain(*(_BYTE **)(a2 + 40))
         && *((unsigned __int16 *)v26 + 179) == *(unsigned __int16 *)(a2 + 358)
         && *((void *)v26 + 48))
    {
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_uDNS == mDNSLogCategory_State)
      {
        log = (os_log_s *)mDNSLogCategory_uDNS;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_uDNS, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_91;
        }
      }

      else
      {
        log = (os_log_s *)mDNSLogCategory_uDNS_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_uDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_91;
        }
      }

      GetRRDisplayString_rdb(v26 + 8, (unsigned __int16 *)(*((void *)v26 + 6) + 4LL), (_BYTE *)(a1 + 46976));
      *(_DWORD *)__int128 buf = 141558275;
      *(void *)uint64_t v37 = 1752392040LL;
      *(_WORD *)&v37[8] = 2085;
      *(void *)&v37[10] = a1 + 46976;
      _os_log_impl( (void *)&_mh_execute_header,  log,  OS_LOG_TYPE_DEFAULT,  "uDNS_DeregisterRecord: Found Anchor RR %{sensitive, mask.hash}s terminated",  buf,  0x16u);
LABEL_91:
      if ((v27 & 1) == 0)
      {
        int v28 = (os_log_s *)mDNSLogCategory_uDNS;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_uDNS == mDNSLogCategory_State)
        {
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_uDNS, OS_LOG_TYPE_DEFAULT))
          {
LABEL_97:
            GetRRDisplayString_rdb(v26 + 8, (unsigned __int16 *)(*((void *)v26 + 6) + 4LL), (_BYTE *)(a1 + 46976));
            *(_DWORD *)__int128 buf = 141558275;
            *(void *)uint64_t v37 = 1752392040LL;
            *(_WORD *)&v37[8] = 2085;
            *(void *)&v37[10] = a1 + 46976;
            _os_log_impl( (void *)&_mh_execute_header,  v28,  OS_LOG_TYPE_DEFAULT,  "uDNS_DeregisterRecord: ERROR: Another anchorRR %{sensitive, mask.hash}s found",  buf,  0x16u);
          }
        }

        else
        {
          int v28 = (os_log_s *)mDNSLogCategory_uDNS_redacted;
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_uDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_97;
          }
        }
      }

      DisposeTCPConn(*((void *)v26 + 48));
      char v27 = 0;
      *((void *)v26 + 4_Block_object_dispose(va, 8) = 0LL;
      unsigned __int16 v26 = *(unsigned __int8 **)v26;
      if (!v26) {
        goto LABEL_110;
      }
    }

    unsigned __int16 v26 = *(unsigned __int8 **)v26;
  }

  while (v26);
  if ((v27 & 1) != 0)
  {
LABEL_101:
    unint64_t v29 = (os_log_s *)mDNSLogCategory_uDNS;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_uDNS == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_uDNS, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_109;
      }
    }

    else
    {
      unint64_t v29 = (os_log_s *)mDNSLogCategory_uDNS_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_uDNS_redacted, OS_LOG_TYPE_DEFAULT))
      {
LABEL_109:
        GetRRDisplayString_rdb( (unsigned __int8 *)(a2 + 8),  (unsigned __int16 *)(*(void *)(a2 + 48) + 4LL),  (_BYTE *)(a1 + 46976));
        *(_DWORD *)__int128 buf = 141558275;
        *(void *)uint64_t v37 = 1752392040LL;
        *(_WORD *)&v37[8] = 2085;
        *(void *)&v37[10] = a1 + 46976;
        _os_log_impl( (void *)&_mh_execute_header,  v29,  OS_LOG_TYPE_DEFAULT,  "uDNSDeregisterRecord: Cannot find the anchor Resource Record for %{sensitive, mask.hash}s, not an error",  buf,  0x16u);
      }
    }
  }

void StartRecordNatMap( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(_WORD *)(a2 + 12) == 33)
  {
    uint64_t v10 = *(_BYTE **)(a2 + 40);
    if (*v10) {
      uint64_t v11 = *v10 + 1LL;
    }
    else {
      uint64_t v11 = 0LL;
    }
    uint64_t v12 = &v10[v11];
    if (*v12) {
      uint64_t v13 = *v12 + 1LL;
    }
    else {
      uint64_t v13 = 0LL;
    }
    uint64_t v14 = &v12[v13];
    if (SameDomainLabelPointer(&v12[v13], "\x04_tcp"))
    {
      char v21 = 2;
    }

    else
    {
      if (!SameDomainLabelPointer(v14, "\x04_udp"))
      {
        LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "StartRecordNatMap: could not determine transport protocol of service %##s",  v16,  v17,  v18,  v19,  v20,  *(void *)(a2 + 40));
        return;
      }

      char v21 = 1;
    }

    if (*(void *)(a2 + 584)) {
      mDNS_StopNATOperation_internal(a1, a2 + 392);
    }
    *(_BYTE *)(a2 + 564) = v21;
    uint64_t v22 = *(void *)(a2 + 48);
    *(_WORD *)(a2 + 566) = *(_WORD *)(v22 + 8);
    *(_WORD *)(a2 + 56_Block_object_dispose(va, 8) = *(_WORD *)(v22 + 8);
    *(_DWORD *)(a2 + 572) = 0;
    *(void *)(a2 + 576) = CompleteRecordNatMap;
    *(void *)(a2 + 584) = a2;
    mDNS_StartNATOperation_internal(a1, a2 + 392, v15, v16, v17, v18, v19, v20);
  }

  else if (mDNS_LoggingEnabled == 1)
  {
    LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "StartRecordNatMap: Resource Record %##s type %d, not supported",  a4,  a5,  a6,  a7,  a8,  *(void *)(a2 + 40));
  }

BOOL IsRecordMergeable(uint64_t a1, uint64_t a2, int a3)
{
  if (*(void *)(a2 + 32)) {
    return 0LL;
  }
  if (*(_BYTE *)(a2 + 122)) {
    return 0LL;
  }
  if (IsLocalDomain(*(_BYTE **)(a2 + 40))) {
    return 0LL;
  }
  if (*(_DWORD *)(a2 + 284) - a3 + *(_DWORD *)(a2 + 280) > 0) {
    return 0LL;
  }
  int v7 = *(_BYTE **)(a2 + 368);
  if (!v7) {
    return 0LL;
  }
  AuthInfoForName_internal = GetAuthInfoForName_internal(a1, v7);
  if (AuthInfoForName_internal)
  {
    int v9 = *((_DWORD *)AuthInfoForName_internal + 2);
    if (v9)
    {
      if (*(_DWORD *)(a1 + 64) - v9 >= 0) {
        return 0LL;
      }
    }
  }

  BOOL result = 0LL;
  unsigned int v10 = *(_DWORD *)(a2 + 344);
  if (v10 <= 7 && ((1 << v10) & 0xAE) != 0)
  {
    uint64_t v11 = *(void *)(a2 + 376);
    if (v11 && *(_DWORD *)(v11 + 792) && *(_BYTE *)(a2 + 348)) {
      return *(_DWORD *)(a2 + 596) != 1;
    }
    return 0LL;
  }

  return result;
}

void CompleteRecordNatMap( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9)
{
  uint64_t v9 = *(void *)(a2 + 192);
  if (!v9)
  {
    LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "CompleteRecordNatMap called with unknown AuthRecord object",  a4,  a5,  a6,  a7,  a8,  a9);
    return;
  }

  if (!*(_DWORD *)(a2 + 180))
  {
    uint64_t v19 = (os_log_s *)mDNSLogCategory_Default;
    int v20 = a1 + 46976;
    GetRRDisplayString_rdb( (unsigned __int8 *)(v9 + 8),  (unsigned __int16 *)(*(void *)(v9 + 48) + 4LL),  (_BYTE *)(a1 + 46976));
    LogMsgWithLevel(v19, OS_LOG_TYPE_DEFAULT, "CompleteRecordNatMap No NATLease for %s", v21, v22, v23, v24, v25, v20);
    return;
  }

  if (*(_WORD *)(v9 + 12) != 33)
  {
    unsigned __int16 v26 = (os_log_s *)mDNSLogCategory_Default;
    int v27 = a1 + 46976;
    GetRRDisplayString_rdb( (unsigned __int8 *)(v9 + 8),  (unsigned __int16 *)(*(void *)(v9 + 48) + 4LL),  (_BYTE *)(a1 + 46976));
    LogMsgWithLevel( v26,  OS_LOG_TYPE_DEFAULT,  "CompleteRecordNatMap: Not a service record %s",  v28,  v29,  v30,  v31,  v32,  v27);
    return;
  }

  if (*(_BYTE *)(v9 + 8) == 1)
  {
    if (mDNS_LoggingEnabled == 1)
    {
      uint64_t v12 = (os_log_s *)mDNSLogCategory_Default;
      int v13 = a1 + 46976;
      GetRRDisplayString_rdb( (unsigned __int8 *)(v9 + 8),  (unsigned __int16 *)(*(void *)(v9 + 48) + 4LL),  (_BYTE *)(a1 + 46976));
      LogMsgWithLevel( v12,  OS_LOG_TYPE_DEFAULT,  "CompleteRecordNatMap called for %s, Service deregistering",  v14,  v15,  v16,  v17,  v18,  v13);
    }

    return;
  }

  if (*(_DWORD *)(v9 + 344) == 3)
  {
    if (mDNS_LoggingEnabled == 1)
    {
      int v33 = (os_log_s *)mDNSLogCategory_Default;
      int v34 = a1 + 46976;
      GetRRDisplayString_rdb( (unsigned __int8 *)(v9 + 8),  (unsigned __int16 *)(*(void *)(v9 + 48) + 4LL),  (_BYTE *)(a1 + 46976));
      LogMsgWithLevel( v33,  OS_LOG_TYPE_DEFAULT,  "CompleteRecordNatMap called for %s, record in DeregPending",  v35,  v36,  v37,  v38,  v39,  v34);
    }

    return;
  }

  uint64_t v40 = *(void *)(v9 + 376);
  if (!v40 || !*(_DWORD *)(v40 + 792))
  {
    if (mDNS_LoggingEnabled == 1)
    {
      uint64_t v50 = (os_log_s *)mDNSLogCategory_Default;
      GetRRDisplayString_rdb( (unsigned __int8 *)(v9 + 8),  (unsigned __int16 *)(*(void *)(v9 + 48) + 4LL),  (_BYTE *)(a1 + 46976));
      LogMsgWithLevel( v50,  OS_LOG_TYPE_DEFAULT,  "CompleteRecordNatMap called for %s but no zone information!",  v51,  v52,  v53,  v54,  v55,  a1 + 46976);
    }

    if (*(void *)(v9 + 584))
    {
      mDNS_StopNATOperation_internal(a1, v9 + 392);
      *(void *)(v9 + 584) = 0LL;
    }

    *(_DWORD *)(v9 + 344) = 1;
    *(_DWORD *)(v9 + 280) = 1000;
    *(_DWORD *)(v9 + 284) = *(_DWORD *)(a1 + 64) - 1000;
    return;
  }

  mDNS_Lock_((unsigned int *)a1, (uint64_t)"CompleteRecordNatMap", 2122);
  uint64_t ServiceTarget = (_BYTE *)GetServiceTarget(a1, v9);
  uint64_t v47 = ServiceTarget;
  uint64_t v48 = 0LL;
  unsigned int v49 = *(unsigned __int16 *)(v9 + 12);
  if (v49 > 0x20)
  {
    switch(v49)
    {
      case '!':
        uint64_t v48 = (_BYTE *)(*(void *)(v9 + 48) + 10LL);
        break;
      case '$':
LABEL_28:
        uint64_t v48 = (_BYTE *)(*(void *)(v9 + 48) + 6LL);
        break;
      case '\'':
LABEL_31:
        uint64_t v48 = (_BYTE *)(*(void *)(v9 + 48) + 4LL);
        break;
    }
  }

  else
  {
    switch(*(_WORD *)(v9 + 12))
    {
      case 0xC:
        goto LABEL_31;
      case 0xD:
      case 0xE:
      case 0x10:
      case 0x11:
      case 0x13:
      case 0x14:
        break;
      case 0xF:
      case 0x12:
      case 0x15:
        goto LABEL_28;
      default:
        if (v49 == 2 || v49 == 5) {
          goto LABEL_31;
        }
        break;
    }
  }

  if (!ServiceTarget || !*ServiceTarget)
  {
    if (mDNS_LoggingEnabled == 1) {
      LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "CompleteRecordNatMap - no target for %##s, ExternalPort %d",  v42,  v43,  v44,  v45,  v46,  *(void *)(v9 + 40));
    }
    goto LABEL_49;
  }

  if (!*(_WORD *)(a2 + 160))
  {
    if (mDNS_LoggingEnabled) {
      LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "CompleteRecordNatMap - Target %##s for ResourceRecord %##s, ExternalPort %d",  v42,  v43,  v44,  v45,  v46,  (int)ServiceTarget);
    }
LABEL_49:
    if (v48) {
      *uint64_t v48 = 0;
    }
    *(_DWORD *)(v9 + 344) = 8;
    *(_DWORD *)(v9 + 20) = 0;
    mDNS_Unlock_(a1, (uint64_t)"CompleteRecordNatMap", 2136);
    UpdateAllServiceRecords(a1, v9, 0);
    return;
  }

  if (mDNS_LoggingEnabled) {
    LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "CompleteRecordNatMap - Target %##s for ResourceRecord %##s, ExternalPort %d",  v42,  v43,  v44,  v45,  v46,  (int)ServiceTarget);
  }
  if (v48 && !SameDomainNameBytes(v48, v47))
  {
    char v61 = v47;
    if (v47 == (_BYTE *)-256LL)
    {
LABEL_42:
      while (v61)
      {
        uint64_t v62 = *v61;
        if (!*v61)
        {
          unsigned __int16 v63 = (_WORD)v61 - (_WORD)v47 + 1;
          if (v63 > 0x100u) {
            break;
          }
          memcpy(v48, v47, v63);
          goto LABEL_57;
        }

        v61 += v62 + 1;
        if (v47 != (_BYTE *)-256LL) {
          goto LABEL_41;
        }
      }
    }

    else
    {
LABEL_41:
      if (v61 < v47 + 256) {
        goto LABEL_42;
      }
    }

    *uint64_t v48 = 0;
LABEL_57:
    SetNewRData(v9 + 8, 0LL, 0LL, v56, v57, v58, v59, v60);
  }

  *(_BYTE *)(v9 + 592) = 0;
  *(_DWORD *)(v9 + 344) = 1;
  *(_DWORD *)(v9 + 280) = 1000;
  int v64 = *(_DWORD *)(a1 + 64);
  *(_DWORD *)(v9 + 284) = v64 - 1000;
  if (IsRecordMergeable(a1, v9, v64 + 1000)) {
    *(_DWORD *)(v9 + 284) += 1000;
  }
  mDNS_Unlock_(a1, (uint64_t)"CompleteRecordNatMap", 2174);
  UpdateAllServiceRecords(a1, v9, 1);
}

uint64_t uDNS_UpdateRecord( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (mDNS_LoggingEnabled == 1) {
    LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "uDNS_UpdateRecord: Resource Record %##s, state %d",  a4,  a5,  a6,  a7,  a8,  *(void *)(a1 + 40));
  }
  switch(*(_DWORD *)(a1 + 344))
  {
    case 0:
    case 9:
      LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "ERROR: uDNS_UpdateRecord called for record %##s with bad state regState_NATError",  a4,  a5,  a6,  a7,  a8,  *(void *)(a1 + 40));
      return 4294901759LL;
    case 1:
    case 5:
    case 7:
      if (*(void *)(a1 + 640))
      {
        uint64_t v9 = *(void (**)(uint64_t *, uint64_t))(a1 + 320);
        if (v9) {
          v9(mDNSStorage, a1);
        }
      }

      uint64_t result = 0LL;
      *(void *)(a1 + 640) = *(void *)(a1 + 304);
      *(_WORD *)(a1 + 620) = *(_WORD *)(a1 + 312);
      goto LABEL_12;
    case 2:
      *(void *)(a1 + 6memset(&v5[1], 0, 24) = *(void *)(a1 + 48);
      *(_WORD *)(a1 + 616) = *(_WORD *)(a1 + 20);
      *(void *)(a1 + 632) = *(void *)(a1 + 304);
      *(_WORD *)(a1 + 61_Block_object_dispose(va, 8) = *(_WORD *)(a1 + 312);
      *(void *)(a1 + 304) = 0LL;
      *(_DWORD *)(a1 + 344) = 7;
      *(_DWORD *)(a1 + 280) = 1000;
      int v12 = dword_100158BF8;
      *(_DWORD *)(a1 + 284) = dword_100158BF8 - 1000;
      uint64_t result = 0LL;
      if (dword_10015BD48 - v12 >= 0) {
        dword_10015BD48 = v12;
      }
      return result;
    case 3:
    case 4:
      goto LABEL_14;
    case 6:
    case 8:
      uint64_t v11 = *(void (**)(uint64_t *, uint64_t, void, void))(a1 + 320);
      if (v11) {
        v11(mDNSStorage, a1, *(void *)(a1 + 48), *(unsigned __int16 *)(a1 + 20));
      }
      SetNewRData(a1 + 8, *(void *)(a1 + 304), *(unsigned __int16 *)(a1 + 312), a4, a5, a6, a7, a8);
      uint64_t result = 0LL;
LABEL_12:
      *(void *)(a1 + 304) = 0LL;
      return result;
    default:
      LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "uDNS_UpdateRecord: Unknown state %d for %##s",  a4,  a5,  a6,  a7,  a8,  *(_DWORD *)(a1 + 344));
LABEL_14:
      LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "uDNS_UpdateRecord: Requested update of record %##s type %d, in erroneous state %d",  a4,  a5,  a6,  a7,  a8,  *(void *)(a1 + 40));
      return 4294901747LL;
  }

uint64_t AreRecordsMergeable(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t result = IsRecordMergeable(a1, a3, a4);
  if ((_DWORD)result)
  {
    uint64_t result = SameDomainNameBytes(*(_BYTE **)(a2 + 368), *(_BYTE **)(a3 + 368));
    if ((_DWORD)result)
    {
      uint64_t v7 = *(void *)(a2 + 376);
      uint64_t v8 = *(void *)(a3 + 376);
      return *(_DWORD *)(v7 + 792) == *(_DWORD *)(v8 + 792)
          && *(unsigned __int16 *)(v7 + 786) == *(unsigned __int16 *)(v8 + 786);
    }
  }

  return result;
}

void SendGroupRRMessage(uint64_t a1, uint64_t a2, unint64_t a3, _DWORD *a4)
{
  uint64_t v7 = (unsigned __int16 *)(a1 + 28904);
  unint64_t updated = putUpdateLeaseWithLimit(a1 + 28904, a3, a1 + 30356);
  if (updated)
  {
    unint64_t v14 = updated;
    if (*(_BYTE *)(a2 + 356))
    {
      uint64_t v15 = *(void *)(a2 + 384);
      if (v15)
      {
        DisposeTCPConn(v15);
        *(void *)(a2 + 384) = 0LL;
      }

      uint64_t v16 = *(void *)(a2 + 376);
      if (v16)
      {
        TCPConn = MakeTCPConn( a1,  v7,  v14,  1LL,  (int *)(v16 + 788),  *(unsigned __int16 *)(v16 + 786),  (_BYTE *)(v16 + 530),  0LL,  a2);
        *(void *)(a2 + 384) = TCPConn;
        if (TCPConn)
        {
          if (mDNS_LoggingEnabled) {
            LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "SendGroupRRMessage: Sent a group update ID: %d start %p, end %p, limit %p",  v18,  v19,  v20,  v21,  v22,  bswap32(*v7) >> 16);
          }
          return;
        }

        if (!mDNS_LoggingEnabled) {
          return;
        }
        uint64_t v29 = (os_log_s *)mDNSLogCategory_Default;
        uint64_t v38 = (_BYTE *)(a1 + 46976);
        GetRRDisplayString_rdb((unsigned __int8 *)(a2 + 8), (unsigned __int16 *)(*(void *)(a2 + 48) + 4LL), v38);
        int v40 = (int)v38;
        uint64_t v36 = "SendGroupRRMessage: Cannot establish TCP connection for %s";
      }

      else
      {
        uint64_t v29 = (os_log_s *)mDNSLogCategory_Default;
        uint64_t v37 = (_BYTE *)(a1 + 46976);
        GetRRDisplayString_rdb((unsigned __int8 *)(a2 + 8), (unsigned __int16 *)(*(void *)(a2 + 48) + 4LL), v37);
        int v40 = (int)v37;
        uint64_t v36 = "SendGroupRRMessage:ERROR!! nta is NULL for %s";
      }

unint64_t BuildUpdateMessage( uint64_t a1, unint64_t a2, uint64_t a3, unint64_t a4, unint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v10 = a2;
  int v12 = *(_DWORD *)(a3 + 344);
  int v13 = 5;
  switch(v12)
  {
    case 2:
      goto LABEL_5;
    case 3:
      *(_DWORD *)(a3 + 352) = 0;
      __int16 v14 = *(_WORD *)(a3 + 14);
      *(_WORD *)(a3 + 14) = 254;
      unint64_t result = PutResourceRecordTTLWithLimit(a1 + 28904, a2, (_WORD *)(a1 + 28912), a3 + 8, 0LL, a4, a7, a8);
      *(_WORD *)(a3 + 14) = v14;
      if (!result) {
        goto LABEL_25;
      }
      return result;
    case 5:
    case 7:
      goto LABEL_6;
    default:
      int v13 = 1;
LABEL_5:
      *(_DWORD *)(a3 + 344) = v13;
      int v12 = v13;
LABEL_6:
      if (*(_BYTE *)(a3 + 8) != 4) {
        *(_BYTE *)(a3 + 192) = 1;
      }
      if (*(_WORD *)(a3 + 12) == 33 && *(_BYTE *)(a3 + 120) == 2 && *(_WORD *)(a3 + 552))
      {
        *(_WORD *)(*(void *)(a3 + 48) + 8LL) = *(_WORD *)(a3 + 552);
        int v12 = *(_DWORD *)(a3 + 344);
      }

      if (v12 == 7)
      {
        SetNewRData(a3 + 8, *(void *)(a3 + 624), *(unsigned __int16 *)(a3 + 616), a4, a5, a6, a7, a8);
        __int16 v16 = *(_WORD *)(a3 + 14);
        *(_WORD *)(a3 + 14) = 254;
        unint64_t v19 = PutResourceRecordTTLWithLimit(a1 + 28904, v10, (_WORD *)(a1 + 28912), a3 + 8, 0LL, a4, v17, v18);
        *(_WORD *)(a3 + 14) = v16;
        if (!v19) {
          goto LABEL_25;
        }
        unint64_t v25 = v19;
        SetNewRData(a3 + 8, *(void *)(a3 + 632), *(unsigned __int16 *)(a3 + 618), v20, v21, v22, v23, v24);
        unint64_t v26 = *(unsigned int *)(a3 + 16);
        unint64_t v27 = a1 + 28904;
        unint64_t v28 = v25;
        uint64_t v29 = (_WORD *)(a1 + 28912);
      }

      else
      {
        int v30 = *(unsigned __int8 *)(a3 + 8);
        if (v30 == 32 || v30 == 16)
        {
          __int16 v31 = *(_WORD *)(a3 + 12);
          uint64_t v32 = putDomainNameAsLabels(a1 + 28904, a2, a4, *(unsigned __int8 **)(a3 + 40), a5, a6, a7, a8);
          if (!v32) {
            goto LABEL_25;
          }
          unint64_t v10 = (unint64_t)(v32 + 10);
          _BYTE *v32 = HIBYTE(v31);
          v32[1] = v31;
          *((_WORD *)v32 + 1) = -256;
          *((_DWORD *)v32 + 1) = 0;
          *((_WORD *)v32 + 4) = 0;
          ++*(_WORD *)(a1 + 28912);
          if (v32 == (_BYTE *)-10LL) {
            goto LABEL_25;
          }
        }

        else if (!a2 && v30 != 8)
        {
          goto LABEL_25;
        }

        unint64_t v27 = a1 + 28904;
        uint64_t v29 = (_WORD *)(a1 + 28912);
        unint64_t v26 = *(unsigned int *)(a3 + 16);
        unint64_t v28 = v10;
      }

      unint64_t result = PutResourceRecordTTLWithLimit(v27, v28, v29, a3 + 8, v26, a4, a7, a8);
      if (result) {
        return result;
      }
LABEL_25:
      uint64_t v33 = (os_log_s *)mDNSLogCategory_Default;
      uint64_t v34 = (_BYTE *)(a1 + 46976);
      GetRRDisplayString_rdb((unsigned __int8 *)(a3 + 8), (unsigned __int16 *)(*(void *)(a3 + 48) + 4LL), v34);
      LogMsgWithLevel( v33,  OS_LOG_TYPE_DEFAULT,  "BuildUpdateMessage: Error formatting message for %s",  v35,  v36,  v37,  v38,  v39,  (int)v34);
      return 0LL;
  }

void uDNS_SetupWABQueries()
{
  for (uint64_t i = SearchList; i; uint64_t i = *(void *)i)
    *(_DWORD *)(i + 264) |= 1u;
  mDNS_Lock_((unsigned int *)mDNSStorage, (uint64_t)"uDNS_SetupWABQueries", 5489);
  if (!mDNSPlatformSetDNSConfig(0, 1, 0LL, 0LL, 0LL, 0))
  {
    for (uint64_t j = SearchList; j; uint64_t j = *(void *)j)
      *(_DWORD *)(j + 264) &= ~1u;
    uint64_t v2 = (os_log_s *)mDNSLogCategory_State;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "uDNS_SetupWABQueries: No config change",  buf,  2u);
    }
  }

  mDNS_Unlock_((uint64_t)mDNSStorage, (uint64_t)"uDNS_SetupWABQueries", 5499);
  unsigned int v3 = DWORD2(xmmword_10015C4C8) != 0;
  if (HIDWORD(xmmword_10015C4C8)) {
    v3 |= 2u;
  }
  if (dword_10015C4D8) {
    unsigned int v4 = v3 | 4;
  }
  else {
    unsigned int v4 = v3;
  }
  uint64_t v5 = SearchList;
  if (SearchList)
  {
    int v6 = &SearchList;
    unsigned int v91 = v4;
    do
    {
      int v7 = mDNS_DomainNameFNV1aHash((unsigned __int8 *)(v5 + 8));
      uint64_t v8 = (os_log_s *)mDNSLogCategory_State;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT))
      {
        int v9 = *(_DWORD *)(v5 + 264);
        uint64_t v10 = *(void *)(v5 + 272);
        for (uint64_t k = (_BYTE *)(v5 + 8); ; k += v12 + 1)
        {
          if ((unint64_t)k >= v5 + 264 || !k || (uint64_t v12 = *k, v12 > 0x3F))
          {
            unsigned __int16 v13 = 257;
            goto LABEL_24;
          }

          if (!*k) {
            break;
          }
        }

        unsigned __int16 v13 = (_WORD)k - (v5 + 8) + 1;
LABEL_24:
        *(_DWORD *)__int128 buf = 67110402;
        *(_DWORD *)int32x2_t v93 = v4;
        *(_WORD *)&v93[4] = 1024;
        *(_DWORD *)&v93[6] = v9;
        LOWORD(v94) = 2048;
        *(void *)((char *)&v94 + 2) = v10;
        WORD5(v94) = 1040;
        HIDWORD(v94) = v13;
        *(_WORD *)uint64_t v95 = 2098;
        *(void *)&v95[2] = v5 + 8;
        *(_WORD *)__int32 v96 = 1024;
        *(_DWORD *)&v96[2] = v7;
        _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "uDNS_SetupWABQueries -- action: 0x%x, flags: 0x%x, ifid: %p, domain: %{public, mdnsresponder:domain_name}.*P (%x)",  buf,  0x2Eu);
      }

      int v14 = *(_DWORD *)(v5 + 264);
      if ((v14 & 1) != 0)
      {
        uint64_t v23 = *(void **)(v5 + 3568);
        *(void *)(v5 + 356_Block_object_dispose(va, 8) = 0LL;
        *int v6 = *(void *)v5;
        if ((v14 & 2) != 0
          && !SameDomainNameBytes((_BYTE *)(v5 + 8), "\x05local")
          && !*(void *)(v5 + 272))
        {
          int v24 = v7;
          unint64_t v25 = (os_log_s *)mDNSLogCategory_State;
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)__int128 buf = 67109120;
            *(_DWORD *)int32x2_t v93 = v24;
            _os_log_impl( (void *)&_mh_execute_header,  v25,  OS_LOG_TYPE_DEFAULT,  "uDNS_SetupWABQueries: DELETE Browse for domain -- name hash: %x",  buf,  8u);
          }

          mDNS_StopQuery((unsigned int *)mDNSStorage, v5 + 280);
          mDNS_StopQuery((unsigned int *)mDNSStorage, v5 + 936);
          int v7 = v24;
        }

        if ((*(_BYTE *)(v5 + 264) & 4) != 0
          && !SameDomainNameBytes((_BYTE *)(v5 + 8), "\x05local")
          && !*(void *)(v5 + 272))
        {
          int v26 = v7;
          unint64_t v27 = (os_log_s *)mDNSLogCategory_State;
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)__int128 buf = 67109120;
            *(_DWORD *)int32x2_t v93 = v26;
            _os_log_impl( (void *)&_mh_execute_header,  v27,  OS_LOG_TYPE_DEFAULT,  "uDNS_SetupWABQueries: DELETE Legacy Browse for domain -- name hash: %x",  buf,  8u);
          }

          mDNS_StopQuery((unsigned int *)mDNSStorage, v5 + 1592);
          int v7 = v26;
        }

        if ((*(_BYTE *)(v5 + 264) & 8) != 0
          && !SameDomainNameBytes((_BYTE *)(v5 + 8), "\x05local")
          && !*(void *)(v5 + 272))
        {
          int v28 = v7;
          uint64_t v29 = (os_log_s *)mDNSLogCategory_State;
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)__int128 buf = 67109120;
            *(_DWORD *)int32x2_t v93 = v28;
            _os_log_impl( (void *)&_mh_execute_header,  v29,  OS_LOG_TYPE_DEFAULT,  "uDNS_SetupWABQueries: DELETE Registration for domain -- name hash: %x",  buf,  8u);
          }

          mDNS_StopQuery((unsigned int *)mDNSStorage, v5 + 2248);
          mDNS_StopQuery((unsigned int *)mDNSStorage, v5 + 2904);
        }

        free((void *)v5);
        if (!v23)
        {
LABEL_81:
          uint64_t v5 = (uint64_t)v6;
          unsigned int v4 = v91;
          goto LABEL_146;
        }

        while (2)
        {
          int v30 = v23;
          uint64_t v23 = (void *)*v23;
          __int16 v31 = (os_log_s *)mDNSLogCategory_State;
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v32 = v30[6];
            if (v32)
            {
              uint64_t v33 = (_BYTE *)v30[6];
              if (v32 == -256) {
                goto LABEL_58;
              }
LABEL_55:
              unsigned __int16 v34 = 257;
              if ((unint64_t)v33 < v32 + 256 && v33)
              {
                while (1)
                {
                  uint64_t v35 = *v33;
                  if (v35 > 0x3F)
                  {
LABEL_64:
                    unsigned __int16 v34 = 257;
                    goto LABEL_66;
                  }

                  if (!*v33) {
                    break;
                  }
                  v33 += v35 + 1;
                  if (v32 != -256) {
                    goto LABEL_55;
                  }
LABEL_58:
                  if (!v33) {
                    goto LABEL_64;
                  }
                }

                unsigned __int16 v34 = (_WORD)v33 - v32 + 1;
              }

void uDNS_DeleteWABQueries( uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9)
{
  switch(a2)
  {
    case 4:
      mDNS_StopQuery((unsigned int *)mDNSStorage, a1 + 2248);
      char v10 = 0;
      uint64_t v11 = a1 + 2904;
      uint64_t v12 = "dr._dns-sd._udp.";
      unsigned __int16 v13 = off_10013BDB8;
      break;
    case 2:
      uint64_t v12 = 0LL;
      uint64_t v11 = a1 + 1592;
      char v10 = 1;
      unsigned __int16 v13 = off_10013BDB0;
      break;
    case 1:
      mDNS_StopQuery((unsigned int *)mDNSStorage, a1 + 280);
      char v10 = 0;
      uint64_t v11 = a1 + 936;
      uint64_t v12 = "db._dns-sd._udp.";
      unsigned __int16 v13 = mDNS_DomainTypeNames;
      break;
    default:
      LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "uDNS_DeleteWABQueries: ERROR!! returning from default",  a4,  a5,  a6,  a7,  a8,  a9);
      return;
  }

  mDNS_StopQuery((unsigned int *)mDNSStorage, v11);
  memset(v37, 0, sizeof(v37));
  memset(v36, 0, sizeof(v36));
  uint64_t v20 = (unsigned __int8 *)*v13;
  if (v20)
  {
    AppendDNSNameString(v37, v20, v14, v15, v16, v17, v18, v19);
    AppendDNSNameString(v37, "local", v21, v22, v23, v24, v25, v26);
  }

  unint64_t v27 = (void *)(a1 + 3568);
  if ((v10 & 1) == 0)
  {
    LOBYTE(v36[0]) = 0;
    AppendDNSNameString(v36, (unsigned __int8 *)v12, v14, v15, v16, v17, v18, v19);
    AppendDNSNameString(v36, "local", v28, v29, v30, v31, v32, v33);
  }

  for (uint64_t i = (void *)*v27; *v27; uint64_t i = (void *)*v27)
  {
    if (v20 && SameDomainNameBytes((_BYTE *)i + 660, v37)
      || (v10 & 1) == 0 && SameDomainNameBytes((_BYTE *)i + 660, v36))
    {
      if (mDNS_LoggingEnabled == 1) {
        LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "uDNS_DeleteWABQueries: Deregistering PTR %##s -> %##s",  v15,  v16,  v17,  v18,  v19,  i[6]);
      }
      void *v27 = *i;
      int v35 = mDNS_Deregister((unsigned int *)mDNSStorage, (uint64_t)(i + 1));
      if (v35) {
        LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "uDNS_DeleteWABQueries:: ERROR!! mDNS_Deregister returned %d",  v15,  v16,  v17,  v18,  v19,  v35);
      }
    }

    else
    {
      if (mDNS_LoggingEnabled == 1) {
        LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "uDNS_DeleteWABQueries: Skipping PTR %##s -> %##s",  v15,  v16,  v17,  v18,  v19,  i[6]);
      }
      unint64_t v27 = (void *)*v27;
    }
  }

void FoundDomain( uint64_t a1, uint64_t a2, unsigned __int8 *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9)
{
  if (*((_WORD *)a3 + 2) == 12 && *a3 != 240)
  {
    uint64_t v10 = *((void *)a3 + 3);
    if (v10 != -2)
    {
      int v11 = a4;
      uint64_t v13 = *(void *)(a2 + 176);
      if (v13 + 280 == a2)
      {
        uint64_t v14 = mDNS_DomainTypeNames;
      }

      else if (v13 + 936 == a2)
      {
        uint64_t v14 = off_10013BDA8;
      }

      else if (v13 + 1592 == a2)
      {
        uint64_t v14 = off_10013BDB0;
      }

      else if (v13 + 2248 == a2)
      {
        uint64_t v14 = off_10013BDB8;
      }

      else
      {
        if (v13 + 2904 != a2)
        {
          LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "FoundDomain - unknown question",  a4,  a5,  a6,  a7,  a8,  a9);
          return;
        }

        uint64_t v14 = off_10013BDC0;
      }

      uint64_t v15 = (unsigned __int8 *)*v14;
      if (mDNS_LoggingEnabled == 1)
      {
        uint64_t v16 = (os_log_s *)mDNSLogCategory_Default;
        GetRRDisplayString_rdb(a3, (unsigned __int16 *)(*((void *)a3 + 5) + 4LL), (_BYTE *)(a1 + 46976));
        LogMsgWithLevel(v16, OS_LOG_TYPE_DEFAULT, "FoundDomain: %p %s %s Q %##s A %s", v17, v18, v19, v20, v21, v10);
      }

      if (v11)
      {
        uint64_t v22 = calloc(1uLL, 0x4A0uLL);
        if (v22)
        {
          uint64_t v23 = v22;
          uint64_t v24 = (uint64_t)(v22 + 1);
          mDNS_SetupResourceRecord( (uint64_t)(v22 + 1),  0LL,  -2LL,  12,  0x1C20u,  8,  4,  (uint64_t)FreeARElemCallback,  (uint64_t)v22);
          *((_BYTE *)v23 + 660) = 0;
          AppendDNSNameString((_BYTE *)v23 + 660, v15, v25, v26, v27, v28, v29, v30);
          AppendDNSNameString((_BYTE *)v23 + 660, "local", v31, v32, v33, v34, v35, v36);
          uint64_t v37 = *((void *)a3 + 5);
          uint64_t v38 = (const void *)(v37 + 4);
          unint64_t v39 = v37 + 260;
          int v40 = (_BYTE *)(v37 + 4);
          if (v39)
          {
LABEL_20:
          }

          else
          {
LABEL_21:
            while (v40)
            {
              uint64_t v41 = *v40;
              if (!*v40)
              {
                unsigned __int16 v58 = (_WORD)v40 - (_WORD)v38 + 1;
                if (v58 > 0x100u) {
                  break;
                }
                memcpy((void *)(v23[7] + 4LL), v38, v58);
                goto LABEL_39;
              }

              v40 += v41 + 1;
              if (v39) {
                goto LABEL_20;
              }
            }
          }

          *(_BYTE *)(v23[7] + 4LL) = 0;
LABEL_39:
          if (mDNS_LoggingEnabled == 1)
          {
            uint64_t v59 = (os_log_s *)mDNSLogCategory_Default;
            GetRRDisplayString_rdb( (unsigned __int8 *)v23 + 16,  (unsigned __int16 *)(v23[7] + 4LL),  (_BYTE *)(a1 + 46976));
            LogMsgWithLevel( v59,  OS_LOG_TYPE_DEFAULT,  "FoundDomain: Registering %s",  v60,  v61,  v62,  v63,  v64,  a1 + 46976);
          }

          int v65 = mDNS_Register((unsigned int *)a1, v24);
          if (v65)
          {
            LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "ERROR: FoundDomain - mDNS_Register returned %d",  v66,  v67,  v68,  v69,  v70,  v65);
            free(v23);
          }

          else
          {
            *uint64_t v23 = *(void *)(v13 + 3568);
            *(void *)(v13 + 356_Block_object_dispose(va, 8) = v23;
          }
        }

        else
        {
          __break(1u);
        }
      }

      else
      {
        unsigned __int16 v42 = *(unsigned __int8 **)(v13 + 3568);
        if (v42)
        {
          int v43 = (unsigned __int8 *)(v13 + 3568);
          do
          {
            int v44 = SameDomainNameBytes((_BYTE *)(*((void *)v42 + 7) + 4LL), (_BYTE *)(*((void *)a3 + 5) + 4LL));
            uint64_t v45 = *(unsigned __int8 **)v43;
            if (v44)
            {
              *(void *)int v43 = *(void *)v45;
              if (mDNS_LoggingEnabled == 1)
              {
                int v46 = (os_log_s *)mDNSLogCategory_Default;
                GetRRDisplayString_rdb( v45 + 16,  (unsigned __int16 *)(*((void *)v45 + 7) + 4LL),  (_BYTE *)(a1 + 46976));
                LogMsgWithLevel( v46,  OS_LOG_TYPE_DEFAULT,  "FoundDomain: Deregistering %s",  v47,  v48,  v49,  v50,  v51,  a1 + 46976);
              }

              int v52 = mDNS_Deregister((unsigned int *)a1, (uint64_t)(v45 + 8));
              if (v52) {
                LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "ERROR: FoundDomain - mDNS_Deregister returned %d",  v53,  v54,  v55,  v56,  v57,  v52);
              }
            }

            else
            {
              int v43 = *(unsigned __int8 **)v43;
            }

            unsigned __int16 v42 = *(unsigned __int8 **)v43;
          }

          while (*(void *)v43);
        }
      }
    }
  }

void FreeARElemCallback(uint64_t a1, uint64_t a2, int a3)
{
  if (a3 == -65792)
  {
    unsigned int v3 = *(void **)(a2 + 112);
    if (v3) {
      free(v3);
    }
  }

void uDNS_StartWABQueries( char a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((a1 & 1) != 0)
  {
    int v9 = ++DWORD2(xmmword_10015C4C8);
    if (mDNS_LoggingEnabled == 1) {
      LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "uDNS_StartWABQueries: Browse query count %d",  a4,  a5,  a6,  a7,  a8,  v9);
    }
  }

  if ((a1 & 2) != 0)
  {
    int v10 = ++HIDWORD(xmmword_10015C4C8);
    if (mDNS_LoggingEnabled == 1) {
      LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "uDNS_StartWABQueries: Legacy Browse query count %d",  a4,  a5,  a6,  a7,  a8,  v10);
    }
  }

  if ((a1 & 4) != 0)
  {
    int v11 = ++dword_10015C4D8;
    if (mDNS_LoggingEnabled == 1) {
      LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "uDNS_StartWABQueries: Reg query count %d",  a4,  a5,  a6,  a7,  a8,  v11);
    }
  }

  uDNS_SetupWABQueries();
}

void uDNS_StopWABQueries( char a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((a1 & 1) != 0)
  {
    int v9 = --DWORD2(xmmword_10015C4C8);
    if (mDNS_LoggingEnabled == 1) {
      LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "uDNS_StopWABQueries: Browse query count %d",  a4,  a5,  a6,  a7,  a8,  v9);
    }
  }

  if ((a1 & 2) != 0)
  {
    int v10 = --HIDWORD(xmmword_10015C4C8);
    if (mDNS_LoggingEnabled == 1) {
      LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "uDNS_StopWABQueries: Legacy Browse query count %d",  a4,  a5,  a6,  a7,  a8,  v10);
    }
  }

  if ((a1 & 4) != 0)
  {
    int v11 = --dword_10015C4D8;
    if (mDNS_LoggingEnabled == 1) {
      LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "uDNS_StopWABQueries: Reg query count %d",  a4,  a5,  a6,  a7,  a8,  v11);
    }
  }

  uDNS_SetupWABQueries();
}

uint64_t FlushAddressCacheRecords( uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = (unsigned int *)result;
  uint64_t v9 = 0LL;
  int v10 = (_BYTE *)(result + 46976);
  do
  {
    uint64_t v21 = v9;
    int v11 = *(void **)&v8[2 * v9 + 70];
    if (v11)
    {
      while (1)
      {
        uint64_t v12 = v11[2];
        if (v12) {
          break;
        }
LABEL_18:
        int v11 = (void *)*v11;
        if (!v11) {
          goto LABEL_19;
        }
      }

      while (1)
      {
        if (*(void *)(v12 + 32)) {
          goto LABEL_17;
        }
        if (!RRTypeAnswersQuestionType(v12 + 8, 1u, 3LL, a4, a5, a6, a7, a8))
        {
          unint64_t result = RRTypeAnswersQuestionType(v12 + 8, 0x1Cu, 3LL, v13, v14, v15, v16, v17);
          if (!(_DWORD)result) {
            goto LABEL_17;
          }
        }

        uint64_t v18 = (os_log_s *)mDNSLogCategory_Default;
        if (gSensitiveLoggingEnabled == 1 && mDNSLogCategory_Default != mDNSLogCategory_State) {
          break;
        }
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_15;
        }
LABEL_16:
        unint64_t result = mDNS_PurgeCacheResourceRecord(v8, v12);
LABEL_17:
        uint64_t v12 = *(void *)v12;
        if (!v12) {
          goto LABEL_18;
        }
      }

      uint64_t v18 = (os_log_s *)mDNSLogCategory_Default_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_16;
      }
LABEL_15:
      GetRRDisplayString_rdb((unsigned __int8 *)(v12 + 8), (unsigned __int16 *)(*(void *)(v12 + 48) + 4LL), v10);
      *(_DWORD *)__int128 buf = 141558275;
      uint64_t v23 = 1752392040LL;
      __int16 v24 = 2085;
      uint64_t v25 = v10;
      _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_DEFAULT,  "FlushAddressCacheRecords: Purging Resourcerecord - record description: %{sensitive, mask.hash}s.",  buf,  0x16u);
      goto LABEL_16;
    }

LABEL_19:
    uint64_t v9 = v21 + 1;
  }

  while (v21 != 498);
  return result;
}

        uint64_t v14 = 1;
      }
    }

    else
    {
      uint64_t v14 = 0;
    }
  }

  else
  {
    uint64_t v14 = 0;
    v623 = 0LL;
  }

  ConvertDomainNameToCString_withescape(*(unsigned __int8 **)(a3 + 32), (unsigned __int8 *)__s);
  int v620 = a5;
  if (*(void *)(a2 + 144) && (uint64_t v23 = *(void *)(a3 + 56)) != 0)
  {
    validation_unint64_t result = dnssec_obj_resource_record_member_get_validation_result(v23);
    if (validation_result == 2) {
      uint64_t v25 = 2097184;
    }
    else {
      uint64_t v25 = 0;
    }
    if (validation_result == 1) {
      uint64_t v26 = 2097168;
    }
    else {
      uint64_t v26 = v25;
    }
    unint64_t v615 = v26;
  }

  else
  {
    unint64_t v615 = 0;
  }

  uint64_t v27 = *(unsigned __int16 *)(a2 + 320);
  uint64_t v28 = *(_DWORD *)(a7 + 212);
  uint64_t v29 = mDNSPlatformInterfaceIndexfromInterfaceID(a1, *(void *)(a3 + 24), 0LL, v18, v19, v20, v21, v22);
  uint64_t v30 = a2 + 356;
  uint64_t v31 = mDNS_DomainNameFNV1aHash((unsigned __int8 *)(a2 + 356));
  uint64_t v32 = *(_DWORD *)(a7 + 192);
  buf.int tv_sec = 0LL;
  buf.tv_nsec = 0LL;
  clock_gettime(_CLOCK_MONOTONIC_RAW, &buf);
  if (v32) {
    uint64_t v36 = LODWORD(buf.tv_sec) - v32 <= 299;
  }
  else {
    uint64_t v36 = 0;
  }
  uint64_t v37 = !v36;
  v619 = a2;
  uint64_t v617 = v14;
  if (v28 != 8)
  {
    if (v37)
    {
      *(_DWORD *)(a7 + 192) = buf.tv_sec;
      int v46 = *(void *)(a3 + 56);
      if (v46)
      {
        unsigned int v606 = v29;
        uint64_t v47 = dnssec_obj_resource_record_member_get_validation_result(v46);
        uint64_t v48 = *(unsigned __int16 *)(a2 + 320);
        uint64_t v49 = *(unsigned __int16 *)(a3 + 12);
        uint64_t v50 = v49 < 0x201;
        if (v47)
        {
          uint64_t v51 = v47;
          if (*(_WORD *)(a2 + 320))
          {
            if (v49 >= 0x201)
            {
              int v44 = (char *)malloc(*(unsigned __int16 *)(a3 + 12));
              int v52 = v44;
              if (!v44) {
                goto LABEL_1088;
              }
            }

            else
            {
              if (!*(_WORD *)(a3 + 12))
              {
                if (v27) {
                  uint64_t v204 = (os_log_s *)mDNSLogCategory_Default;
                }
                else {
                  uint64_t v204 = (os_log_s *)mDNSLogCategory_mDNS;
                }
                if (gSensitiveLoggingEnabled != 1 || v204 == (os_log_s *)mDNSLogCategory_State)
                {
                  if (!os_log_type_enabled(v204, OS_LOG_TYPE_DEFAULT)) {
                    goto LABEL_974;
                  }
                  v209 = *(_DWORD *)(a7 + 184);
                  int v210 = __rev16(v48);
                  unsigned __int16 v313 = (_BYTE *)(a2 + 356);
                  if (a2 == -612)
                  {
LABEL_689:
                    while (v313)
                    {
                      uint64_t v314 = *v313;
                      if (!*v313)
                      {
                        uint64_t v396 = (_WORD)v313 - v30 + 1;
                        goto LABEL_947;
                      }

                      v313 += v314 + 1;
                      if (a2 != -612) {
                        goto LABEL_688;
                      }
                    }
                  }

                  else
                  {
LABEL_688:
                  }

                  uint64_t v396 = 257;
                }

                else
                {
                  if (v27) {
                    uint64_t v204 = (os_log_s *)mDNSLogCategory_Default_redacted;
                  }
                  else {
                    uint64_t v204 = (os_log_s *)mDNSLogCategory_mDNS;
                  }
                  if (!os_log_type_enabled(v204, OS_LOG_TYPE_DEFAULT)) {
                    goto LABEL_974;
                  }
                  v209 = *(_DWORD *)(a7 + 184);
                  int v210 = __rev16(v48);
                  v211 = (_BYTE *)(a2 + 356);
                  if (a2 == -612)
                  {
LABEL_324:
                    while (v211)
                    {
                      v212 = *v211;
                      if (!*v211)
                      {
                        uint64_t v396 = (_WORD)v211 - v30 + 1;
                        goto LABEL_947;
                      }

                      v211 += v212 + 1;
                      if (a2 != -612) {
                        goto LABEL_323;
                      }
                    }
                  }

                  else
                  {
LABEL_323:
                  }

                  uint64_t v396 = 257;
                }

    *a1 += *((unsigned __int16 *)v1 + 11) + v6 + 10;
    if (mDNS_LoggingEnabled == 1)
    {
      uint64_t v8 = (os_log_s *)mDNSLogCategory_Default;
      GetRRDisplayString_rdb((unsigned __int8 *)v1 + 8, (unsigned __int16 *)(v1[6] + 4), word_100164338);
      LogMsgWithLevel( v8,  OS_LOG_TYPE_DEFAULT,  "CountProxyRecords: %3u size %5u total %5u %s",  v9,  v10,  v11,  v12,  v13,  v3);
    }

    unsigned int v3 = (v3 + 1);
    goto LABEL_22;
  }

  return 0LL;
}

  int v11 = (unsigned __int8 *)(v8 + 8);
  if (!a2)
  {
    RemoveAuthRecord((uint64_t)mDNSStorage, a1, v8);
    if (v7) {
      uint64_t v18 = v7;
    }
    else {
      uint64_t v18 = v8;
    }
    *(void *)(v8 + 96) = v18;
    *(void *)uint64_t v8 = 0LL;
    if (mDNS_LoggingEnabled == 1)
    {
      uint64_t v19 = (os_log_s *)mDNSLogCategory_Default;
      GetRRDisplayString_rdb( (unsigned __int8 *)(v8 + 8),  (unsigned __int16 *)(*(void *)(v8 + 48) + 4LL),  word_100164338);
      LogMsgWithLevel( v19,  OS_LOG_TYPE_DEFAULT,  "EtcHostsAddNewEntries: Adding %s ID %d",  v20,  v21,  v22,  v23,  v24,  (int)word_100164338);
    }

    uint64_t v25 = "EtcHostsAddNewEntries: mDNS_Register failed for %s";
    goto LABEL_26;
  }

  if (mDNS_LoggingEnabled == 1)
  {
    uint64_t v33 = (os_log_s *)mDNSLogCategory_Default;
    GetRRDisplayString_rdb( (unsigned __int8 *)(v8 + 8),  (unsigned __int16 *)(*(void *)(v8 + 48) + 4LL),  word_100164338);
    LogMsgWithLevel( v33,  OS_LOG_TYPE_DEFAULT,  "EtcHostsAddNewEntries: Entry %s not registered with core yet",  v34,  v35,  v36,  v37,  v38,  (int)word_100164338);
  }

  return 1LL;
}

    uint64_t v9 = v21 + 1;
  }

  while (v21 != 498);
  return result;
}

              if (!*(void *)(a1 + 144))
              {
                uint64_t v13 = *(void *)(a1 + 88);
                uint64_t v14 = *(void *)(v13 + 40);
                if (v14 < 0xD)
                {
                  unint64_t v39 = -6762;
                }

                else
                {
                  uint64_t v15 = malloc(*(void *)(v13 + 40));
                  if (v15)
                  {
                    uint64_t v8 = v15;
                    memcpy(v15, *(const void **)(v13 + 32), v14);
                    v8[1] = -31615;
                    uint64_t v16 = dispatch_data_create(v8, v14, 0LL, _dispatch_data_destructor_free);
                    if (!v16) {
                      goto LABEL_90;
                    }
                    uint64_t v17 = v16;
                    uint64_t v18 = mdns_message_create_with_dispatch_data(v16, 1);
                    dispatch_release(v17);
                    *(void *)(a1 + 144) = v18;
                    if (!v18)
                    {
                      unint64_t v39 = -6729;
LABEL_92:
                      int v40 = (void *)a1;
LABEL_93:
                      _mdns_querier_conclude_with_error_async(v40, v39);
                      return;
                    }

                    *(_WORD *)(a1 + 244) = -4;
                    unsigned int v4 = &unk_100150000;
                    goto LABEL_25;
                  }

                  __break(1u);
LABEL_90:
                  free(v8);
                  unint64_t v39 = -6729;
                }

                *(void *)(a1 + 144) = 0LL;
                goto LABEL_92;
              }

          if (!v8 || v8 == a2 || *(_BYTE *)(v8 + 109))
          {
LABEL_22:
            *(_DWORD *)(i + 212) &= ~v5;
            if (_mdns_resolver_log_s_once != -1) {
              dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_48);
            }
            int v10 = (os_log_s *)_mdns_resolver_log_s_log;
            if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_INFO))
            {
              int v11 = *(const char **)(i + 128);
              if (!v11) {
                int v11 = "";
              }
              *(_DWORD *)__int128 buf = 136446210;
              uint64_t v15 = v11;
              _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_INFO,  "%{public}sRestarting querier",  buf,  0xCu);
            }

            *(void *)(i + 72) = 0LL;
            *(_BYTE *)(i + 247) = 0;
            if (*(_BYTE *)(i + 251)) {
              uint64_t v12 = 2000;
            }
            else {
              uint64_t v12 = *(_DWORD *)(*(void *)(i + 64) + 124LL);
            }
            *(_DWORD *)(i + 204) = v12;
            _mdns_querier_initiate_send(i);
          }
        }
      }
    }
  }

void _mdns_powerlog_awdl_event(uint64_t a1, unsigned __int8 *a2, int a3, unsigned int a4)
{
  if (a4) {
    goto LABEL_5;
  }
  if (_mdns_powerlog_log_s_once != -1) {
    dispatch_once(&_mdns_powerlog_log_s_once, &__block_literal_global_1361);
  }
  if (os_log_type_enabled((os_log_t)_mdns_powerlog_log_s_log, OS_LOG_TYPE_DEBUG))
  {
LABEL_5:
    CFMutableArrayRef Mutable = CFDictionaryCreateMutable(0LL, 0LL, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    if (Mutable)
    {
      if (a2)
      {
        bzero(cStr, 0x3F1uLL);
        if (_mdns_get_service_type_from_domain_name(a2, (unsigned __int8 *)cStr))
        {
          CFStringRef v9 = CFStringCreateWithCString(0LL, cStr, 0x8000100u);
          if (v9)
          {
            CFStringRef v10 = v9;
            CFDictionarySetValue(Mutable, @"service", v9);
            CFRelease(v10);
          }
        }
      }

      memset(cStr, 0, 32);
      int v11 = DNSRecordTypeValueToString(a3);
      if (!v11)
      {
        int v11 = cStr;
        snprintf(cStr, 0x20uLL, "TYPE%d", a3);
      }

      CFStringRef v12 = CFStringCreateWithCString(0LL, v11, 0x8000100u);
      if (v12)
      {
        CFStringRef v13 = v12;
        CFDictionarySetValue(Mutable, @"recordType", v12);
        CFRelease(v13);
      }

      if ((a4 & 0x80000000) == 0)
      {
        *(void *)cStr = a4;
        CFNumberRef v14 = CFNumberCreate(0LL, kCFNumberLongLongType, cStr);
        if (v14)
        {
          CFNumberRef v15 = v14;
          CFDictionarySetValue(Mutable, @"clientPID", v14);
          CFRelease(v15);
        }

        *(void *)cStr = 0LL;
        *(void *)&cStr[8] = 0LL;
        if (a4)
        {
          if (mdns_system_pid_to_name(a4, (uint64_t)cStr))
          {
            CFStringRef v16 = CFStringCreateWithCString(0LL, cStr, 0x8000100u);
            if (v16)
            {
              CFStringRef v17 = v16;
              CFDictionarySetValue(Mutable, @"clientName", v16);
              CFRelease(v17);
            }
          }
        }
      }
    }

    if (_mdns_powerlog_log_s_once != -1) {
      dispatch_once(&_mdns_powerlog_log_s_once, &__block_literal_global_1361);
    }
    uint64_t v18 = (os_log_s *)_mdns_powerlog_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_powerlog_log_s_log, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)cStr = 138412802;
      *(void *)&cStr[4] = a1;
      *(_WORD *)&cStr[12] = 1024;
      *(_DWORD *)&cStr[14] = a4 == 0;
      *(_WORD *)&cStr[18] = 2112;
      *(void *)&cStr[20] = Mutable;
      _os_log_debug_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_DEBUG,  "PowerLog event -- name: %@, exclude: %{mdns:yesno}d, dictionary: %@",  (uint8_t *)cStr,  0x1Cu);
      if (a4)
      {
LABEL_25:
        if (&_PLLogRegisteredEvent) {
          PLLogRegisteredEvent(98LL, a1, Mutable, 0LL);
        }
      }
    }

    else if (a4)
    {
      goto LABEL_25;
    }

    if (Mutable) {
      CFRelease(Mutable);
    }
  }

unsigned __int8 *_mdns_get_service_type_from_domain_name(unsigned __int8 *a1, unsigned __int8 *a2)
{
  int v2 = *a1;
  if (!*a1) {
    return 0LL;
  }
  unsigned int v4 = 0LL;
  uint64_t v5 = 0LL;
  do
  {
    int v6 = v5;
    int v7 = v4;
    uint64_t v5 = a1;
    uint64_t v8 = &a1[v2];
    int v9 = v8[1];
    a1 = v8 + 1;
    int v2 = v9;
    unsigned int v4 = v6;
  }

  while (v9);
  memset(v17, 0, sizeof(v17));
  if (v7)
  {
    unint64_t result = 0LL;
    if (!v6 || v7[1] != 95) {
      return result;
    }
    if (_mdns_label_is_protocol_label((const char *)v6))
    {
      if (DomainNameEqual(v5, "\x05local"))
      {
        uint64_t v11 = *v7;
        __memcpy_chk(v17, v7, v11 + 1, 256LL);
        unint64_t v12 = *v6;
        if ((v11 ^ 0xFFuLL) > v12)
        {
          unint64_t v13 = v12 + 1;
          memcpy((char *)v17 + v11 + 1, v6, v12 + 1);
          CFNumberRef v14 = (char *)v17 + v11 + v13 + 1;
          if ((char *)v17 - v14 + 256 >= 1)
          {
            _BYTE *v14 = 0;
            int v6 = (unsigned __int8 *)v17;
            goto LABEL_15;
          }
        }
      }
    }

    return 0LL;
  }

BOOL _mdns_label_is_protocol_label(const char *a1)
{
  if (a1 == "\x04_tcp") {
    return 1LL;
  }
  if (*a1 != 4) {
    return a1 == "\x04_udp";
  }
  else {
    BOOL v2 = 1;
  }
  BOOL result = v2;
  if (!v2) {
    return mdns_memcmp_us_ascii_case_insensitive( (unsigned __int8 *)a1 + 1,  (unsigned __int8 *)"_udp",  4LL,  (char)"\x04_udp") == 0;
  }
  return result;
}

void ___mdns_powerlog_log_block_invoke(id a1)
{
  _mdns_powerlog_log_s_log = (uint64_t)os_log_create("com.apple.mdns", "powerlog");
}

__uint64_t _mdns_powerlog_get_monotonic_time_ns()
{
  __uint64_t result = clock_gettime_nsec_np(_CLOCK_MONOTONIC_RAW);
  if (!result)
  {
    if (*__error())
    {
      int v1 = *__error();
      if (!v1) {
        return 0LL;
      }
    }

    else
    {
      int v1 = -6700;
    }

    if (_mdns_powerlog_log_s_once != -1) {
      dispatch_once(&_mdns_powerlog_log_s_once, &__block_literal_global_1361);
    }
    BOOL v2 = (os_log_s *)_mdns_powerlog_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_powerlog_log_s_log, OS_LOG_TYPE_FAULT))
    {
      v3[0] = 67109120;
      v3[1] = v1;
      _os_log_fault_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_FAULT,  "clock_gettime_nsec_np() returned 0: %{mdns:err}d",  (uint8_t *)v3,  8u);
    }

    return 1LL;
  }

  return result;
}

void _mdns_powerlog_bonjour_event(unsigned int a1, int a2, const char *a3, const char *a4, uint64_t a5)
{
  if (a1 > 0x12) {
    return;
  }
  LODWORD(v_Block_object_dispose(va, 8) = a1;
  if (((1 << a1) & 0x12493) != 0)
  {
    CFStringRef v10 = &g_client_info_list;
    uint64_t v11 = g_client_info_list;
    if (g_client_info_list)
    {
      while (1)
      {
        uint64_t v8 = (void *)v11;
        if (_mdns_powerlog_client_info_match(v11, a3, a4)) {
          goto LABEL_17;
        }
        uint64_t v11 = v8[8];
        if (!v11)
        {
          CFStringRef v10 = v8 + 8;
          break;
        }
      }
    }

    unint64_t v12 = (char *)calloc(1uLL, 0x60uLL);
    if (v12 && a3)
    {
      uint64_t v8 = v12;
      uint64_t v13 = 0LL;
      CFNumberRef v14 = v12 + 80;
      unint64_t v15 = 16LL;
      while (1)
      {
        int v16 = a3[v13];
        v14[v13] = v16;
        if (!v16) {
          break;
        }
        --v15;
        ++v13;
        if (v15 <= 1)
        {
          v14[v13] = 0;
          break;
        }
      }

      if (!a4) {
        goto LABEL_16;
      }
      CFStringRef v17 = strdup(a4);
      if (v17)
      {
        v8[9] = v17;
LABEL_16:
        uint64_t v37 = 0LL;
        _mdns_powerlog_client_info_forget(&v37);
        *CFStringRef v10 = (uint64_t)v8;
LABEL_17:
        uint64_t v18 = (char *)(v8 + 4);
        if (!a2) {
          uint64_t v18 = (char *)v8;
        }
        int v19 = *((_DWORD *)v18 + 4);
        if (v19 != -1) {
          *((_DWORD *)v18 + 4) = v19 + 1;
        }
        int v20 = *((_DWORD *)v18 + 6);
        *((_DWORD *)v18 + 6) = v20 + 1;
        if (!v20) {
          *(void *)uint64_t v18 = a5;
        }
        return;
      }
    }

    __break(1u);
    goto LABEL_49;
  }

  if (((1 << a1) & 0x49248) == 0) {
    return;
  }
  __uint64_t monotonic_time_ns = _mdns_powerlog_get_monotonic_time_ns();
  uint64_t v22 = g_client_info_list;
  if (g_client_info_list)
  {
    __uint64_t v23 = monotonic_time_ns;
    while (!_mdns_powerlog_client_info_match(v22, a3, a4))
    {
      uint64_t v22 = *(void *)(v22 + 64);
      if (!v22) {
        goto LABEL_28;
      }
    }

    uint64_t v28 = v22 + 32;
    if (!a2) {
      uint64_t v28 = v22;
    }
    int v29 = *(_DWORD *)(v28 + 20);
    if (v29 != -1) {
      *(_DWORD *)(v28 + 20) = v29 + 1;
    }
    int v30 = *(_DWORD *)(v28 + 24);
    if (v30)
    {
      int v31 = v30 - 1;
      *(_DWORD *)(v28 + memset(&v5[1], 0, 24) = v31;
      if (!v31)
      {
        uint64_t v32 = *(void *)(v28 + 8);
        __uint64_t v33 = v23 - *(void *)v28;
        BOOL v34 = __CFADD__(v32, v33);
        uint64_t v35 = v32 + v33;
        if (v34) {
          uint64_t v35 = -1LL;
        }
        *(void *)(v28 + _Block_object_dispose(va, 8) = v35;
      }
    }
  }

  else
  {
LABEL_28:
    if (a4)
    {
      if (_mdns_powerlog_log_s_once == -1)
      {
LABEL_30:
        uint64_t v24 = _mdns_powerlog_log_s_log;
        if (!os_log_type_enabled((os_log_t)_mdns_powerlog_log_s_log, OS_LOG_TYPE_FAULT)) {
          return;
        }
        LODWORD(v37) = 67109635;
        HIDWORD(v37) = (_DWORD)v8;
        __int16 v38 = 2082;
        unint64_t v39 = a3;
        __int16 v40 = 2081;
        uint64_t v41 = a4;
        uint64_t v25 = "No powerlog client info found for %{mdns:powerlog_event_subtype}u event -- client name: %{public}s, servic"
              "e type: %{private}s";
        uint64_t v26 = (os_log_s *)v24;
        uint32_t v27 = 28;
LABEL_47:
        _os_log_fault_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_FAULT, v25, (uint8_t *)&v37, v27);
        return;
      }

BOOL _mdns_powerlog_client_info_match(uint64_t a1, const char *a2, const char *a3)
{
  int v6 = *(const char **)(a1 + 72);
  if (v6) {
    return a3 && !strcasecmp(v6, a3);
  }
  return !a3;
}

void _mdns_powerlog_client_info_forget(void **a1)
{
  int v1 = *a1;
  if (*a1)
  {
    unsigned int v3 = (void *)v1[9];
    if (!v3 || (free(v3), v1[9] = 0LL, (int v1 = *a1) != 0LL))
    {
      free(v1);
      *a1 = 0LL;
    }
  }

__uint64_t mdns_powerlog_getaddrinfo_start(const char *a1, int a2)
{
  __uint64_t monotonic_time_ns = _mdns_powerlog_get_monotonic_time_ns();
  _mdns_powerlog_bonjour_event(4u, a2, a1, 0LL, monotonic_time_ns);
  return monotonic_time_ns;
}

__uint64_t mdns_powerlog_query_record_start(const char *a1, unsigned __int8 *a2, int a3)
{
  __uint64_t monotonic_time_ns = _mdns_powerlog_get_monotonic_time_ns();
  bzero(v9, 0x3F1uLL);
  service_type_from_domain_name = _mdns_get_service_type_from_domain_name(a2, v9);
  _mdns_powerlog_bonjour_event(7u, a3, a1, (const char *)service_type_from_domain_name, monotonic_time_ns);
  return monotonic_time_ns;
}

__uint64_t mdns_powerlog_register_record_start(const char *a1, unsigned __int8 *a2, int a3)
{
  __uint64_t monotonic_time_ns = _mdns_powerlog_get_monotonic_time_ns();
  bzero(v9, 0x3F1uLL);
  service_type_from_domain_name = _mdns_get_service_type_from_domain_name(a2, v9);
  _mdns_powerlog_bonjour_event(0xAu, a3, a1, (const char *)service_type_from_domain_name, monotonic_time_ns);
  return monotonic_time_ns;
}

void mdns_powerlog_register_record_stop(const char *a1, unsigned __int8 *a2, uint64_t a3, int a4)
{
  service_type_from_domain_name = _mdns_get_service_type_from_domain_name(a2, v9);
  _mdns_powerlog_bonjour_event(0xCu, a4, a1, (const char *)service_type_from_domain_name, a3);
}

__uint64_t mdns_powerlog_resolve_start(const char *a1, unsigned __int8 *a2, int a3)
{
  __uint64_t monotonic_time_ns = _mdns_powerlog_get_monotonic_time_ns();
  bzero(v9, 0x3F1uLL);
  service_type_from_domain_name = _mdns_get_service_type_from_domain_name(a2, v9);
  _mdns_powerlog_bonjour_event(0xDu, a3, a1, (const char *)service_type_from_domain_name, monotonic_time_ns);
  return monotonic_time_ns;
}

void _mdns_powerlog_set_client_stats( __CFDictionary *a1, uint64_t a2, const void *a3, const void *a4, const void *a5, const void *a6)
{
  unint64_t v12 = *(void *)(a2 + 8);
  if (v12 % 0x3B9ACA00) {
    unint64_t v13 = v12 / 0x3B9ACA00 + 1;
  }
  else {
    unint64_t v13 = v12 / 0x3B9ACA00;
  }
  _mdns_powerlog_event_dictionary_set_int64(a1, a3, v13);
  _mdns_powerlog_event_dictionary_set_int64(a1, a4, *(unsigned int *)(a2 + 16));
  _mdns_powerlog_event_dictionary_set_int64(a1, a5, *(unsigned int *)(a2 + 20));
  _mdns_powerlog_event_dictionary_set_int64(a1, a6, *(unsigned int *)(a2 + 28));
}

void _mdns_powerlog_event_dictionary_set_int64(__CFDictionary *a1, const void *a2, uint64_t a3)
{
  uint64_t valuePtr = a3;
  CFNumberRef v5 = CFNumberCreate(0LL, kCFNumberSInt64Type, &valuePtr);
  if (v5)
  {
    CFNumberRef v6 = v5;
    CFDictionarySetValue(a1, a2, v5);
    CFRelease(v6);
  }

char *_mdns_interface_monitor_copy_description( uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  __int128 v27 = 0u;
  __int128 v26 = 0u;
  __int128 v25 = 0u;
  __int128 v24 = 0u;
  __int128 v23 = 0u;
  __int128 v22 = 0u;
  p_s1 = &__s1;
  char __s1 = 0;
  if (!a2
    || (mdns_snprintf_add( &p_s1,  (uint64_t)&v29,  "<%s: %p>: ",  a4,  a5,  a6,  a7,  a8,  *(void *)(*(void *)(a1 + 16) + 8LL)) & 0x80000000) == 0)
  {
    if (*(_DWORD *)(a1 + 136))
    {
      name = *(nw_interface **)(a1 + 80);
    }

    else
    {
      name = *(nw_interface **)(a1 + 128);
      if (name) {
        name = (nw_interface *)nw_interface_get_name(name);
      }
    }

    CFStringRef v10 = "";
    if (name) {
      LOBYTE(v10) = (_BYTE)name;
    }
    if ((mdns_snprintf_add(&p_s1, (uint64_t)&v29, "interface %s/%u: ", a4, a5, a6, a7, a8, (char)v10) & 0x80000000) == 0)
    {
      uint64_t v16 = 0LL;
      CFStringRef v17 = "";
      while (1)
      {
        if (((uint64_t)(&off_10013B798)[v16 + 1] & *(_DWORD *)(a1 + 144)) != 0)
        {
          int v18 = mdns_snprintf_add(&p_s1, (uint64_t)&v29, "%s%s", v11, v12, v13, v14, v15, (char)v17);
          CFStringRef v17 = ", ";
          if (v18 < 0) {
            break;
          }
        }

        v16 += 2LL;
        if (v16 == 14)
        {
          __uint64_t result = strdup(&__s1);
          if (!result) {
            __break(1u);
          }
          return result;
        }
      }
    }
  }

  return 0LL;
}

void _mdns_interface_monitor_finalize(void *a1)
{
  BOOL v2 = (dispatch_object_s *)a1[4];
  if (v2)
  {
    dispatch_release(v2);
    a1[4] = 0LL;
  }

  unsigned int v3 = (void *)a1[5];
  if (v3)
  {
    nw_release(v3);
    a1[5] = 0LL;
  }

  unsigned int v4 = (const void *)a1[8];
  if (v4)
  {
    _Block_release(v4);
    a1[8] = 0LL;
  }

  CFNumberRef v5 = (const void *)a1[9];
  if (v5)
  {
    _Block_release(v5);
    a1[9] = 0LL;
  }

  CFNumberRef v6 = (void *)a1[10];
  if (v6)
  {
    free(v6);
    a1[10] = 0LL;
  }

  int v7 = (void *)a1[15];
  if (v7)
  {
    nw_release(v7);
    a1[15] = 0LL;
  }

  uint64_t v8 = (void *)a1[16];
  if (v8)
  {
    nw_release(v8);
    a1[16] = 0LL;
  }

  _mdns_interface_monitor_forget_signatures((uint64_t)a1);
}

void _mdns_interface_monitor_forget_signatures(uint64_t a1)
{
  BOOL v2 = *(void **)(a1 + 88);
  if (v2)
  {
    free(v2);
    *(void *)(a1 + 8_Block_object_dispose(va, 8) = 0LL;
  }

  *(void *)(a1 + 96) = 0LL;
  unsigned int v3 = *(void **)(a1 + 104);
  if (v3)
  {
    free(v3);
    *(void *)(a1 + 104) = 0LL;
  }

  *(void *)(a1 + 112) = 0LL;
  *(_WORD *)(a1 + 152) = 0;
}

uint64_t mdns_interface_monitor_create(unsigned int a1)
{
  uint64_t v2 = _os_object_alloc(&OBJC_CLASS___OS_mdns_interface_monitor, 160LL);
  uint64_t v3 = v2;
  if (!v2) {
    return v3;
  }
  unsigned int v4 = &_mdns_interface_monitor_kind;
  *(void *)(v2 + 16) = &_mdns_interface_monitor_kind;
  do
  {
    CFNumberRef v5 = (void (*)(uint64_t))v4[2];
    if (v5) {
      v5(v3);
    }
    unsigned int v4 = (_UNKNOWN **)*v4;
  }

  while (v4);
  *(_DWORD *)(v3 + 14_Block_object_dispose(va, 8) = 0;
  *(_DWORD *)(v3 + 136) = a1;
  if (a1)
  {
    CFNumberRef v6 = mdns_system_interface_index_to_name(a1);
    *(void *)(v3 + 80) = v6;
    if (v6)
    {
      uint64_t v7 = nw_interface_create_with_index(*(unsigned int *)(v3 + 136));
      if (v7)
      {
        uint64_t v8 = (nw_interface *)v7;
        int v9 = nw_parameters_create();
        if (v9)
        {
          CFStringRef v10 = v9;
          nw_parameters_require_interface(v9, v8);
          evaluator_for_nw_endpoint_t endpoint = nw_path_create_evaluator_for_endpoint(0LL, v10);
          *(void *)(v3 + 40) = evaluator_for_endpoint;
          if (evaluator_for_endpoint)
          {
            uint64_t v12 = nw_path_evaluator_copy_path(evaluator_for_endpoint);
            if (v12)
            {
              uint64_t v13 = (nw_path *)v12;
LABEL_13:
              *(_DWORD *)(v3 + 140) = _mdns_get_interface_flags_from_nw_path(v13, 0);
              goto LABEL_21;
            }

            if (_mdns_ifmon_log_s_once != -1) {
              dispatch_once(&_mdns_ifmon_log_s_once, &__block_literal_global_1442);
            }
            int v20 = (os_log_s *)_mdns_ifmon_log_s_log;
            if (!os_log_type_enabled((os_log_t)_mdns_ifmon_log_s_log, OS_LOG_TYPE_ERROR))
            {
LABEL_46:
              os_release((void *)v3);
              uint64_t v3 = 0LL;
              uint64_t v13 = 0LL;
              if (!v8) {
                goto LABEL_23;
              }
              goto LABEL_22;
            }

            *(_WORD *)__int128 buf = 0;
            uint64_t v21 = "Failed to copy path from path evaluator";
          }

          else
          {
            if (_mdns_ifmon_log_s_once != -1) {
              dispatch_once(&_mdns_ifmon_log_s_once, &__block_literal_global_1442);
            }
            int v20 = (os_log_s *)_mdns_ifmon_log_s_log;
            if (!os_log_type_enabled((os_log_t)_mdns_ifmon_log_s_log, OS_LOG_TYPE_ERROR)) {
              goto LABEL_46;
            }
            *(_WORD *)__int128 buf = 0;
            uint64_t v21 = "Failed to create path evaluator";
          }

          _os_log_error_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, v21, buf, 2u);
          goto LABEL_46;
        }

        if (_mdns_ifmon_log_s_once != -1) {
          dispatch_once(&_mdns_ifmon_log_s_once, &__block_literal_global_1442);
        }
        int v19 = (os_log_s *)_mdns_ifmon_log_s_log;
        if (os_log_type_enabled((os_log_t)_mdns_ifmon_log_s_log, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)__int128 buf = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Failed to create params", buf, 2u);
        }

        CFStringRef v10 = 0LL;
        goto LABEL_46;
      }

      if (_mdns_ifmon_log_s_once != -1) {
        dispatch_once(&_mdns_ifmon_log_s_once, &__block_literal_global_1442);
      }
      int v18 = (os_log_s *)_mdns_ifmon_log_s_log;
      if (os_log_type_enabled((os_log_t)_mdns_ifmon_log_s_log, OS_LOG_TYPE_ERROR))
      {
        int v22 = *(_DWORD *)(v3 + 136);
        *(_DWORD *)__int128 buf = 67109120;
        int v25 = v22;
        _os_log_error_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_ERROR,  "Failed to create interface for index %u",  buf,  8u);
      }
    }

    CFStringRef v10 = 0LL;
    uint64_t v8 = 0LL;
    goto LABEL_46;
  }

  uint64_t v14 = nw_path_create_evaluator_for_endpoint(0LL, 0LL);
  uint64_t v8 = (nw_interface *)v14;
  if (v14)
  {
    uint64_t v13 = (nw_path *)nw_path_evaluator_copy_path(v14);
    nw_release(v8);
    if (v13)
    {
      uint64_t v15 = (nw_interface *)nw_path_copy_interface(v13);
      uint64_t v8 = v15;
      if (v15)
      {
        *(void *)(v3 + 120) = v15;
        nw_retain(v15);
        uint64_t v16 = *(void **)(v3 + 120);
        *(void *)(v3 + 12_Block_object_dispose(va, 8) = v16;
        nw_retain(v16);
        nw_release(v8);
        CFStringRef v10 = 0LL;
        uint64_t v8 = 0LL;
      }

      else
      {
        CFStringRef v10 = 0LL;
      }

      goto LABEL_13;
    }

    uint64_t v8 = 0LL;
  }

  else
  {
    uint64_t v13 = 0LL;
  }

  CFStringRef v10 = 0LL;
LABEL_21:
  v23[0] = _NSConcreteStackBlock;
  v23[1] = 0x40000000LL;
  v23[2] = __mdns_interface_monitor_create_block_invoke;
  v23[3] = &__block_descriptor_tmp_1447;
  v23[4] = v3;
  os_unfair_lock_lock(&_mdns_nwi_locked_s_lock);
  __mdns_interface_monitor_create_block_invoke((uint64_t)v23);
  os_unfair_lock_unlock(&_mdns_nwi_locked_s_lock);
  *(_DWORD *)(v3 + 144) = *(_DWORD *)(v3 + 140);
  if (v8) {
LABEL_22:
  }
    nw_release(v8);
LABEL_23:
  if (v10) {
    nw_release(v10);
  }
  if (v13) {
    nw_release(v13);
  }
  return v3;
}

uint64_t _mdns_get_interface_flags_from_nw_path(nw_path *a1, int a2)
{
  unsigned int v3 = a2 & 0xFFFFFFF0 | nw_path_has_ipv4(a1);
  if (nw_path_has_ipv6(a1)) {
    v3 |= 2u;
  }
  if (nw_path_is_expensive(a1)) {
    v3 |= 4u;
  }
  if (nw_path_is_constrained(a1)) {
    return v3 | 8;
  }
  else {
    return v3;
  }
}

uint64_t __mdns_interface_monitor_create_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (*(_DWORD *)(v2 + 136))
  {
    name = *(const char **)(v2 + 80);
  }

  else
  {
    unsigned int v4 = *(nw_interface **)(v2 + 120);
    if (!v4)
    {
LABEL_10:
      uint64_t ifstate = 0LL;
      goto LABEL_11;
    }

    name = nw_interface_get_name(v4);
  }

  if (name) {
    BOOL v5 = g_nwi_state == 0;
  }
  else {
    BOOL v5 = 1;
  }
  if (v5) {
    goto LABEL_10;
  }
  uint64_t ifstate = nwi_state_get_ifstate(g_nwi_state, name);
LABEL_11:
  _mdns_interface_monitor_update_signatures_from_nwi_state(*(void *)(a1 + 32), ifstate);
  uint64_t result = _mdns_get_interface_flags_from_nwi_state(ifstate, *(_DWORD *)(*(void *)(a1 + 32) + 140LL));
  *(_DWORD *)(*(void *)(a1 + 32) + 140LL) = result;
  return result;
}

uint64_t _mdns_interface_monitor_update_signatures_from_nwi_state(uint64_t a1, uint64_t a2)
{
  int v20 = 0;
  if (a2)
  {
    signature = (void *)nwi_ifstate_get_signature(a2, 2LL, &v20);
    int v5 = v20;
  }

  else
  {
    int v5 = 0;
    signature = 0LL;
  }

  int updated = _mdns_interface_monitor_update_signature( (const void **)(a1 + 88),  (void *)(a1 + 96),  (char *)(a1 + 152),  signature,  v5 & ~(v5 >> 31));
  int v20 = 0;
  if (a2)
  {
    uint64_t v7 = (void *)nwi_ifstate_get_signature(a2, 30LL, &v20);
    int v8 = v20;
  }

  else
  {
    int v8 = 0;
    uint64_t v7 = 0LL;
  }

  int v9 = (_BYTE *)(a1 + 153);
  unsigned int v10 = _mdns_interface_monitor_update_signature( (const void **)(a1 + 104),  (void *)(a1 + 112),  (char *)(a1 + 153),  v7,  v8 & ~(v8 >> 31));
  if ((updated & v10 & 1) != 0)
  {
    uint64_t v11 = 1LL;
  }

  else if ((updated & 1) != 0)
  {
    uint64_t v11 = (v10 & 1) == 0 && *v9 == 0;
  }

  else if (*(_BYTE *)(a1 + 152))
  {
    uint64_t v11 = 0LL;
  }

  else
  {
    uint64_t v11 = v10;
  }

  if (_mdns_ifmon_log_s_once != -1) {
    dispatch_once(&_mdns_ifmon_log_s_once, &__block_literal_global_1442);
  }
  uint64_t v12 = (os_log_s *)_mdns_ifmon_log_s_log;
  if (os_log_type_enabled((os_log_t)_mdns_ifmon_log_s_log, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v14 = *(const char **)(a1 + 80);
    if (!v14) {
      uint64_t v14 = "";
    }
    int v15 = *(unsigned __int8 *)(a1 + 152);
    if (*(_BYTE *)(a1 + 152)) {
      int v15 = *(_DWORD *)(a1 + 96);
    }
    int v16 = *(_DWORD *)(a1 + 136);
    uint64_t v17 = *(void *)(a1 + 88);
    int v18 = *v9;
    if (*v9) {
      int v18 = *(_DWORD *)(a1 + 112);
    }
    uint64_t v19 = *(void *)(a1 + 104);
    int v20 = 136447746;
    uint64_t v21 = v14;
    __int16 v22 = 1024;
    int v23 = v16;
    __int16 v24 = 1040;
    int v25 = v15;
    __int16 v26 = 2096;
    uint64_t v27 = v17;
    __int16 v28 = 1040;
    int v29 = v18;
    __int16 v30 = 2096;
    uint64_t v31 = v19;
    __int16 v32 = 1024;
    int v33 = v11;
    _os_log_debug_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEBUG,  "Signature update -- interface: %{public}s/%u, IPv4: %{mdns:base64}.*P, IPv6: %{mdns:base64}.*P, network changed: %{mdns:yesno}d",  (uint8_t *)&v20,  0x38u);
  }

  return v11;
}

uint64_t _mdns_get_interface_flags_from_nwi_state(uint64_t a1, int a2)
{
  uint64_t v2 = a2 & 0xFFFFFFCF;
  if (a1)
  {
    LODWORD(v2) = (nwi_ifstate_get_flags() >> 2) & 0x10 | v2;
    if (nwi_ifstate_get_vpn_server(a1)) {
      return v2 | 0x20;
    }
    else {
      return v2;
    }
  }

  return v2;
}

uint64_t _mdns_interface_monitor_update_signature( const void **a1, void *a2, char *a3, void *__s2, size_t __n)
{
  if (!__n)
  {
    char v13 = 0;
    if (*a3) {
      goto LABEL_10;
    }
    return 0LL;
  }

  unsigned int v10 = (void *)*a1;
  if (*a2 == __n && !memcmp(*a1, __s2, __n))
  {
    if (!*a3) {
      goto LABEL_8;
    }
    return 0LL;
  }

  if (v10)
  {
    free(v10);
    *a1 = 0LL;
  }

  *a2 = 0LL;
  uint64_t result = (uint64_t)malloc(__n);
  if (result)
  {
    uint64_t v12 = result;
    memcpy((void *)result, __s2, __n);
    *a1 = (const void *)v12;
    *a2 = __n;
LABEL_8:
    char v13 = 1;
LABEL_10:
    *a3 = v13;
    return 1LL;
  }

  __break(1u);
  return result;
}

void ___mdns_ifmon_log_block_invoke(id a1)
{
  _mdns_ifmon_log_s_log = (uint64_t)os_log_create("com.apple.mdns", "interface_monitor");
}

void _mdns_interface_monitor_activate_async(void *a1)
{
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000LL;
  block[2] = ___mdns_interface_monitor_activate_async_block_invoke;
  block[3] = &__block_descriptor_tmp_21_1455;
  void block[4] = a1;
  dispatch_async((dispatch_queue_t)_mdns_internal_queue_s_queue, block);
}

void ___mdns_interface_monitor_activate_async_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (*(_BYTE *)(v2 + 155) || *(_BYTE *)(v2 + 156)) {
    goto LABEL_68;
  }
  *(_BYTE *)(v2 + 155) = 1;
  if (!_mdns_start_interface_availability_monitoring_s_store)
  {
    SCDynamicStoreRef v3 = SCDynamicStoreCreate( 0LL,  @"com.apple.mdns.interface-monitor",  (SCDynamicStoreCallBack)_mdns_store_changed,  0LL);
    if (v3) {
      goto LABEL_7;
    }
    if (SCError())
    {
      int v4 = SCError();
      if (!v4)
      {
LABEL_7:
        CFStringRef NetworkInterface = SCDynamicStoreKeyCreateNetworkInterface(0LL, kSCDynamicStoreDomainState);
        if (NetworkInterface) {
          goto LABEL_10;
        }
        if (SCError())
        {
          int v6 = SCError();
          if (!v6)
          {
LABEL_10:
            values[0] = (void *)NetworkInterface;
            uint64_t v7 = CFArrayCreate(0LL, (const void **)values, 1LL, &kCFTypeArrayCallBacks);
            if (v7)
            {
              int v8 = v7;
              if (!SCDynamicStoreSetNotificationKeys(v3, v7, 0LL))
              {
                if (SCError())
                {
                  int v9 = SCError();
                  if (!v9) {
                    goto LABEL_14;
                  }
                  int v15 = v9;
                }

                else
                {
                  int v15 = -6700;
                }

                if (_mdns_ifmon_log_s_once != -1) {
                  dispatch_once(&_mdns_ifmon_log_s_once, &__block_literal_global_1442);
                }
                int v16 = (os_log_s *)_mdns_ifmon_log_s_log;
                if (!os_log_type_enabled((os_log_t)_mdns_ifmon_log_s_log, OS_LOG_TYPE_ERROR))
                {
LABEL_40:
                  if (!v3) {
                    goto LABEL_42;
                  }
LABEL_41:
                  CFRelease(v3);
                  goto LABEL_42;
                }

                LODWORD(buf) = 134217984;
                *(void *)((char *)&buf + 4) = v15;
                uint64_t v17 = "Failed to set notification keys for interface availability monitoring: %{mdns:err}ld";
LABEL_72:
                _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, v17, (uint8_t *)&buf, 0xCu);
                if (!v3) {
                  goto LABEL_42;
                }
                goto LABEL_41;
              }

void _mdns_store_changed()
{
  int v9 = 0LL;
  if (getifaddrs(&v9))
  {
    if (*__error())
    {
      int v0 = *__error();
      if (!v0) {
        goto LABEL_4;
      }
    }

    else
    {
      int v0 = -6700;
    }

    if (_mdns_ifmon_log_s_once != -1) {
      dispatch_once(&_mdns_ifmon_log_s_once, &__block_literal_global_1442);
    }
    int v8 = (os_log_s *)_mdns_ifmon_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_ifmon_log_s_log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)__int128 buf = 134217984;
      uint64_t v11 = v0;
      _os_log_error_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_ERROR,  "getifaddrs() failed: %{mdns:err}ld",  buf,  0xCu);
    }

    goto LABEL_21;
  }

void ___mdns_interface_monitor_activate_internal_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v20 = 0LL;
  uint64_t v21 = &v20;
  uint64_t v22 = 0x2000000000LL;
  int v23 = 0;
  uint64_t v16 = 0LL;
  uint64_t v17 = &v16;
  uint64_t v18 = 0x2000000000LL;
  char v19 = 0;
  uint64_t v12 = 0LL;
  int v13 = &v12;
  uint64_t v14 = 0x2000000000LL;
  uint64_t v15 = 0LL;
  v11[0] = _NSConcreteStackBlock;
  v11[1] = 0x40000000LL;
  _OWORD v11[2] = ___mdns_interface_monitor_update_block_invoke;
  v11[3] = &unk_10013B8F0;
  void v11[4] = &v20;
  void v11[5] = &v16;
  v11[6] = &v12;
  v11[7] = v2;
  os_unfair_lock_lock((os_unfair_lock_t)(v2 + 148));
  ___mdns_interface_monitor_update_block_invoke(v11);
  os_unfair_lock_unlock((os_unfair_lock_t)(v2 + 148));
  unsigned int v3 = *(_DWORD *)(v2 + 144);
  int v4 = *((_DWORD *)v21 + 6);
  *(_DWORD *)(v2 + 144) = v4;
  int v5 = *((unsigned __int8 *)v17 + 24);
  if (*(_DWORD *)(v2 + 136))
  {
    int v6 = (void *)v13[3];
    if (!v6) {
      goto LABEL_8;
    }
    nw_release(v6);
    int v7 = v13 + 3;
  }

  else
  {
    int v8 = *(void **)(v2 + 128);
    if (v8)
    {
      nw_release(v8);
      *(void *)(v2 + 12_Block_object_dispose(va, 8) = 0LL;
    }

    int v7 = v13 + 3;
    *(void *)(v2 + 12_Block_object_dispose(va, 8) = v13[3];
  }

  *int v7 = 0LL;
LABEL_8:
  if (v5) {
    uint64_t v9 = v4 ^ v3 | 0x80;
  }
  else {
    uint64_t v9 = v4 ^ v3;
  }
  _Block_object_dispose(&v12, 8);
  _Block_object_dispose(&v16, 8);
  _Block_object_dispose(&v20, 8);
  if ((_DWORD)v9)
  {
    uint64_t v10 = *(void *)(*(void *)(a1 + 32) + 64LL);
    if (v10) {
      (*(void (**)(uint64_t, uint64_t))(v10 + 16))(v10, v9);
    }
  }

void ___mdns_interface_monitor_activate_internal_block_invoke_2(uint64_t a1)
{
}

void ___mdns_interface_monitor_activate_internal_block_invoke_3(uint64_t a1, nw_path *a2)
{
}

void ___mdns_interface_monitor_activate_internal_block_invoke_4(uint64_t a1)
{
}

void ___mdns_interface_monitor_activate_internal_block_invoke_27(uint64_t a1, nw_path *a2)
{
}

void ___mdns_interface_monitor_activate_internal_block_invoke_2_29(uint64_t a1)
{
}

void _mdns_nwi_state_update()
{
  uint64_t v0 = nwi_state_copy();
  if (!v0)
  {
    if (_mdns_nwi_log_s_once != -1) {
      dispatch_once(&_mdns_nwi_log_s_once, &__block_literal_global_40);
    }
    int v1 = (os_log_s *)_mdns_nwi_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_nwi_log_s_log, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v3) = 0;
      _os_log_error_impl( (void *)&_mh_execute_header,  v1,  OS_LOG_TYPE_ERROR,  "Failed to copy NWI state",  (uint8_t *)&v3,  2u);
    }
  }

  uint64_t v3 = 0LL;
  int v4 = &v3;
  uint64_t v5 = 0x2000000000LL;
  uint64_t v6 = 0LL;
  os_unfair_lock_lock(&_mdns_nwi_locked_s_lock);
  v4[3] = g_nwi_state;
  g_nwi_state = v0;
  os_unfair_lock_unlock(&_mdns_nwi_locked_s_lock);
  if (v4[3]) {
    nwi_state_release();
  }
  for (uint64_t i = g_monitor_list; i; uint64_t i = *(void *)(i + 24))
    _mdns_interface_monitor_check_nwi_state_for_updates(i);
  _Block_object_dispose(&v3, 8);
}

void _mdns_interface_monitor_check_nwi_state_for_updates(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 136))
  {
    name = *(const char **)(a1 + 80);
  }

  else
  {
    uint64_t v3 = *(nw_interface **)(a1 + 120);
    if (!v3)
    {
LABEL_10:
      uint64_t ifstate = 0LL;
      goto LABEL_11;
    }

    name = nw_interface_get_name(v3);
  }

  if (name) {
    BOOL v4 = g_nwi_state == 0;
  }
  else {
    BOOL v4 = 1;
  }
  if (v4) {
    goto LABEL_10;
  }
  uint64_t ifstate = nwi_state_get_ifstate(g_nwi_state, name);
LABEL_11:
  int interface_flags_from_nwi_state = _mdns_get_interface_flags_from_nwi_state(ifstate, *(_DWORD *)(a1 + 140));
  int updated = _mdns_interface_monitor_update_signatures_from_nwi_state(a1, ifstate);
  _mdns_interface_monitor_trigger_update(a1, interface_flags_from_nwi_state, updated);
}

void _mdns_interface_monitor_terminate(void *object, int a2)
{
  BOOL v4 = (dispatch_object_s *)object[7];
  if (v4)
  {
    dispatch_source_cancel((dispatch_source_t)object[7]);
    dispatch_release(v4);
    object[7] = 0LL;
  }

  uint64_t v5 = (void *)object[5];
  if (v5)
  {
    if (!*((_BYTE *)object + 157) || (nw_path_evaluator_cancel(), (uint64_t v5 = (void *)object[5]) != 0LL))
    {
      nw_release(v5);
      object[5] = 0LL;
    }
  }

  uint64_t v6 = (nw_path_monitor *)object[6];
  if (v6)
  {
    nw_path_monitor_cancel(v6);
    int v7 = (void *)object[6];
    if (v7)
    {
      nw_release(v7);
      object[6] = 0LL;
    }
  }

  int v8 = (void *)g_monitor_list;
  if (g_monitor_list)
  {
    if ((void *)g_monitor_list == object)
    {
      uint64_t v10 = &g_monitor_list;
LABEL_16:
      *uint64_t v10 = object[3];
      object[3] = 0LL;
      os_release(object);
    }

    else
    {
      while (1)
      {
        uint64_t v9 = v8;
        int v8 = (void *)v8[3];
        if (!v8) {
          break;
        }
        if (v8 == object)
        {
          uint64_t v10 = v9 + 3;
          goto LABEL_16;
        }
      }
    }
  }

  os_retain(object);
  uint64_t v11 = (dispatch_queue_s *)object[4];
  v12[0] = _NSConcreteStackBlock;
  v12[1] = 0x40000000LL;
  v12[2] = ___mdns_interface_monitor_terminate_block_invoke;
  void v12[3] = &__block_descriptor_tmp_42_1469;
  int v13 = a2;
  void v12[4] = object;
  dispatch_async(v11, v12);
}

void ___mdns_interface_monitor_terminate_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(unsigned int *)(a1 + 40);
  uint64_t v3 = *(const void ***)(a1 + 32);
  BOOL v4 = (void (**)(const void *, uint64_t, void))v3[9];
  if (v4)
  {
    if ((_DWORD)v2) {
      uint64_t v5 = 1LL;
    }
    else {
      uint64_t v5 = 2LL;
    }
    v4[2](v3[9], v5, v2);
    uint64_t v3 = *(const void ***)(a1 + 32);
  }

  if (!(_DWORD)v2 && v3[9])
  {
    _Block_release(v3[9]);
    uint64_t v3 = *(const void ***)(a1 + 32);
    v3[9] = 0LL;
  }

  os_release(v3);
}

void _mdns_interface_monitor_trigger_update(uint64_t a1, int a2, int a3)
{
  if (*(_DWORD *)(a1 + 140) != a2 || a3 != 0)
  {
    int v7 = (os_unfair_lock_s *)(a1 + 148);
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 148));
    *(_DWORD *)(a1 + 140) = a2;
    if (a3) {
      *(_BYTE *)(a1 + 15_Block_object_dispose(va, 8) = 1;
    }
    os_unfair_lock_unlock(v7);
    int v8 = *(dispatch_source_s **)(a1 + 56);
    if (v8) {
      dispatch_source_merge_data(v8, 1uLL);
    }
  }

void ___mdns_nwi_log_block_invoke(id a1)
{
  _mdns_nwi_log_s_log = (uint64_t)os_log_create("com.apple.mdns", "NWI");
}

void _mdns_interface_monitor_trigger_update_with_path(uint64_t a1, nw_path *a2)
{
  uint64_t v19 = 0LL;
  uint64_t v20 = &v19;
  uint64_t v21 = 0x2000000000LL;
  uint64_t v22 = 0LL;
  if (*(_DWORD *)(a1 + 136)) {
    goto LABEL_2;
  }
  uint64_t v7 = nw_path_copy_interface(a2);
  v20[3] = v7;
  uint64_t v8 = *(void *)(a1 + 120);
  if (!v7)
  {
    BOOL v4 = (_DWORD *)(a1 + 140);
    int interface_flags_from_nw_path = _mdns_get_interface_flags_from_nw_path(a2, *(_DWORD *)(a1 + 140));
    if (!v8) {
      goto LABEL_3;
    }
LABEL_10:
    _mdns_interface_monitor_forget_signatures(a1);
    uint64_t v10 = (nw_interface *)v20[3];
    else {
      uint64_t ifstate = nwi_state_get_ifstate(g_nwi_state, name);
    }
    _mdns_interface_monitor_update_signatures_from_nwi_state(a1, ifstate);
    int interface_flags_from_nw_path = _mdns_get_interface_flags_from_nwi_state(ifstate, interface_flags_from_nw_path);
    char v6 = 1;
    goto LABEL_18;
  }

  if (!v8
    || (uint32_t index = nw_interface_get_index(*(nw_interface_t *)(a1 + 120)),
        index != nw_interface_get_index((nw_interface_t)v20[3])))
  {
    int interface_flags_from_nw_path = _mdns_get_interface_flags_from_nw_path(a2, *(_DWORD *)(a1 + 140));
    goto LABEL_10;
  }

void ___mdns_interface_monitor_trigger_update_with_path_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 40);
  *(_DWORD *)(v1 + 140) = *(_DWORD *)(a1 + 48);
  if (*(_BYTE *)(a1 + 52))
  {
    *(_BYTE *)(v1 + 15_Block_object_dispose(va, 8) = 1;
    uint64_t v3 = *(void **)(v1 + 120);
    if (v3)
    {
      nw_release(v3);
      *(void *)(*(void *)(a1 + 40) + 120LL) = 0LL;
      uint64_t v1 = *(void *)(a1 + 40);
    }

    *(void *)(v1 + 120) = *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 0LL;
  }

void *___mdns_interface_monitor_update_block_invoke(void *a1)
{
  *(_DWORD *)(*(void *)(a1[4] + 8LL) + 24LL) = *(_DWORD *)(a1[7] + 140LL);
  uint64_t v1 = a1[7];
  *(_BYTE *)(*(void *)(a1[5] + 8LL) + 24LL) = *(_BYTE *)(v1 + 158);
  *(_BYTE *)(v1 + 15_Block_object_dispose(va, 8) = 0;
  *(void *)(*(void *)(a1[6] + 8LL) + 24LL) = *(void *)(v1 + 120);
  uint64_t result = *(void **)(*(void *)(a1[6] + 8LL) + 24LL);
  if (result) {
    return nw_retain(result);
  }
  return result;
}

void ___mdns_internal_queue_block_invoke(id a1)
{
  _mdns_internal_queue_s_queue = (uint64_t)dispatch_queue_create("com.apple.mdns.interface-monitor", 0LL);
}

void mdns_interface_monitor_invalidate(void *a1)
{
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000LL;
  block[2] = __mdns_interface_monitor_invalidate_block_invoke;
  block[3] = &__block_descriptor_tmp_2;
  void block[4] = a1;
  dispatch_async((dispatch_queue_t)_mdns_internal_queue_s_queue, block);
}

void __mdns_interface_monitor_invalidate_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (!*(_BYTE *)(v2 + 156))
  {
    _mdns_interface_monitor_terminate((void *)v2, 0);
    uint64_t v2 = *(void *)(a1 + 32);
    *(_BYTE *)(v2 + 156) = 1;
  }

  os_release((void *)v2);
}

void mdns_interface_monitor_set_queue(uint64_t a1, dispatch_object_t object)
{
  if (*(_BYTE *)(a1 + 154))
  {
    if (!*(void *)(a1 + 32))
    {
      *(void *)(a1 + 32) = object;
      dispatch_retain(object);
      _mdns_interface_monitor_activate_async((void *)a1);
    }
  }

  else
  {
    dispatch_retain(object);
    BOOL v4 = *(dispatch_object_s **)(a1 + 32);
    if (v4) {
      dispatch_release(v4);
    }
    *(void *)(a1 + 32) = object;
  }

void mdns_interface_monitor_set_event_handler(uint64_t a1, void *aBlock)
{
  if (aBlock) {
    uint64_t v3 = _Block_copy(aBlock);
  }
  else {
    uint64_t v3 = 0LL;
  }
  BOOL v4 = *(const void **)(a1 + 72);
  if (v4) {
    _Block_release(v4);
  }
  *(void *)(a1 + 72) = v3;
}

void mdns_interface_monitor_set_update_handler(uint64_t a1, void *aBlock)
{
  if (aBlock) {
    uint64_t v3 = _Block_copy(aBlock);
  }
  else {
    uint64_t v3 = 0LL;
  }
  BOOL v4 = *(const void **)(a1 + 64);
  if (v4) {
    _Block_release(v4);
  }
  *(void *)(a1 + 64) = v3;
}

const char *DNSTypeName(int a1)
{
  if (a1 <= 32)
  {
    uint64_t v1 = "Addr";
    switch(a1)
    {
      case 1:
        return v1;
      case 2:
        uint64_t v1 = "NS";
        break;
      case 3:
      case 4:
      case 7:
      case 8:
      case 9:
      case 11:
      case 14:
      case 15:
        goto LABEL_33;
      case 5:
        uint64_t v1 = "CNAME";
        break;
      case 6:
        uint64_t v1 = "SOA";
        break;
      case 10:
        uint64_t v1 = "NULL";
        break;
      case 12:
        uint64_t v1 = "PTR";
        break;
      case 13:
        uint64_t v1 = "HINFO";
        break;
      case 16:
        uint64_t v1 = "TXT";
        break;
      default:
        if (a1 != 28) {
          goto LABEL_33;
        }
        uint64_t v1 = "AAAA";
        break;
    }
  }

  else
  {
    if (a1 > 63)
    {
      if (a1 <= 249)
      {
        if (a1 == 64) {
          return "SVCB";
        }
        if (a1 == 65) {
          return "HTTPS";
        }
      }

      else
      {
        switch(a1)
        {
          case 250:
            return "TSIG";
          case 255:
            return "ANY";
          case 65323:
            return "TSR";
        }
      }

_BYTE *GetRRDisplayString_rdb(unsigned __int8 *a1, unsigned __int16 *a2, _BYTE *a3)
{
  int v80 = a3;
  int v6 = mDNS_snprintf(a3);
  if (*a1 == 240) {
    return v80;
  }
  int v12 = v6;
  uint64_t v13 = *((unsigned __int16 *)a1 + 6);
  int v14 = *((unsigned __int16 *)a1 + 2);
  if (!*((_WORD *)a1 + 6))
  {
    if (v14 != 41)
    {
      uint64_t v35 = &v80[v6];
      goto LABEL_32;
    }

LABEL_53:
              v49 += v52;
              if (v49 >= v48) {
                goto LABEL_81;
              }
            }
          }

          break;
        }

        if (v45 >= 2)
        {
          int v46 = mDNS_snprintf(v44);
          goto LABEL_45;
        }

        int v46 = 0;
LABEL_150:
        v39 += v46;
        uint64_t v37 = v78;
LABEL_151:
        uint64_t v35 = &v37[v39];
        break;
      default:
        if (v14 == 28)
        {
          uint64_t v35 = &v80[v6];
          break;
        }

          uint64_t v29 = 0;
          goto LABEL_54;
        }

        uint64_t v29 = 0;
        uint64_t v33 = v30;
LABEL_54:
        if (!(v27 | v29))
        {
          uint64_t v34 = 0LL;
LABEL_61:
          memset(v40, 0, sizeof(v40));
          uint64_t v41 = 0;
          uint64_t v30 = v33;
          goto LABEL_62;
        }

        uint64_t v31 = 1;
        uint64_t v30 = v33;
LABEL_56:
        uint64_t v28 = (uint64_t *)*v28;
      }

      while (v28);
      if (!v31) {
        goto LABEL_70;
      }
      uint64_t v34 = 0LL;
      memset(v40, 0, sizeof(v40));
      uint64_t v41 = 0;
      if (!v30) {
        goto LABEL_68;
      }
LABEL_62:
      if (*v30 == 6)
      {
        memset((char *)v40 + 4, 0, 20);
        LODWORD(v40[0]) = 7708;
        uint64_t v41 = 0;
        *(_OWORD *)&v40[1] = *(_OWORD *)(v30 + 1);
        if (v34)
        {
LABEL_66:
          int v39 = *(unsigned __int16 *)(v34 + 12);
          uint64_t v34 = *(void *)(v34 + 40) + 4LL;
          goto LABEL_69;
        }
      }

      else
      {
        if (*v30 == 4)
        {
          int v38 = v30[1];
          v40[1] = 0LL;
          LODWORD(v40[0]) = 528;
          HIDWORD(v40[0]) = v38;
        }

        if (v34) {
          goto LABEL_66;
        }
      }

uint64_t RRAssertsExistence( uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(_WORD *)(a1 + 4) != 47) {
    return 0LL;
  }
  uint64_t v8 = *(void *)(a1 + 40);
  uint64_t v9 = v8 + 4;
  unint64_t v10 = v8 + 260;
  uint64_t v11 = (_BYTE *)(v8 + 4);
  if (!v10) {
    goto LABEL_6;
  }
LABEL_3:
  unsigned __int16 v12 = 257;
  if ((unint64_t)v11 < v10 && v11)
  {
    while (1)
    {
      uint64_t v13 = *v11;
      if (v13 > 0x3F)
      {
LABEL_11:
        unsigned __int16 v12 = 257;
        goto LABEL_13;
      }

      if (!*v11) {
        break;
      }
      v11 += v13 + 1;
      if (v10) {
        goto LABEL_3;
      }
LABEL_6:
      if (!v11) {
        goto LABEL_11;
      }
    }

    unsigned __int16 v12 = (_WORD)v11 - v9 + 1;
  }

uint64_t mDNS_DomainNameFNV1aHash(unsigned __int8 *a1)
{
  uint64_t result = 2166136261LL;
  uint64_t v3 = a1;
LABEL_2:
  unsigned int v4 = 257;
  if (v3 >= a1 + 256 || !v3) {
    goto LABEL_12;
  }
  while (1)
  {
    uint64_t v5 = *v3;
    if (v5 > 0x3F)
    {
LABEL_10:
      unsigned int v4 = 257;
      goto LABEL_12;
    }

    if (!*v3) {
      break;
    }
    v3 += v5 + 1;
LABEL_5:
    if (!v3) {
      goto LABEL_10;
    }
  }

  unsigned int v4 = (unsigned __int16)((_WORD)v3 - (_WORD)a1 + 1);
  if ((_WORD)v3 - (_WORD)a1 != 0xFFFF)
  {
LABEL_12:
    uint64_t v6 = v4;
    do
    {
      int v8 = *a1++;
      int v7 = v8;
      int v9 = v8 + 32;
      uint64_t result = 16777619 * (v7 ^ result);
      --v6;
    }

    while (v6);
  }

  return result;
}

uint64_t SameDomainNameBytes(_BYTE *a1, _BYTE *a2)
{
  uint64_t v3 = a1;
  unint64_t v4 = (unint64_t)(a1 + 256);
  while (*v3 || *a2)
  {
    uint64_t result = SameDomainLabelPointer(v3, a2);
    if (!(_DWORD)result) {
      return result;
    }
    v3 += *v3 + 1;
    a2 += *a2 + 1;
  }

  return 1LL;
}

uint64_t IsSubdomain(unsigned __int8 *a1, unsigned __int8 *a2)
{
  int v2 = *a1;
  if (*a1)
  {
    int v3 = 0;
    unint64_t v4 = a1;
    do
    {
      ++v3;
      uint64_t v5 = &v4[v2];
      int v6 = v5[1];
      unint64_t v4 = v5 + 1;
      int v2 = v6;
    }

    while (v6);
  }

  else
  {
    int v3 = 0;
  }

  int v7 = *a2;
  if (*a2)
  {
    int v8 = 0;
    int v9 = a2;
    do
    {
      ++v8;
      unint64_t v10 = &v9[v7];
      int v11 = v10[1];
      int v9 = v10 + 1;
      int v7 = v11;
    }

    while (v11);
  }

  else
  {
    int v8 = 0;
  }

  BOOL v12 = __OFSUB__(v3, v8);
  int v13 = v3 - v8;
  if (v13 < 0 != v12) {
    return 0LL;
  }
  if (v13 >= 1)
  {
    int v15 = v13 + 1;
    do
    {
      if (!*a1) {
        break;
      }
      a1 += *a1 + 1;
      --v15;
    }

    while (v15 > 1);
  }

  return SameDomainNameBytes(a1, a2);
}

uint64_t TruncateUTF8ToLength(uint64_t a1, uint64_t a2, unsigned int a3)
{
  unsigned int v3 = a3;
  uint64_t v4 = a3 + 1LL;
  if (v4 < a2)
  {
    char v5 = *(_BYTE *)(a1 + v4);
    if (!a3) {
      goto LABEL_16;
    }
LABEL_6:
    int v6 = *(unsigned __int8 *)(a1 + a3);
    int v7 = (unsigned __int8 *)(a1 + a3 - 1);
    while (1)
    {
      int v8 = v5 & 0xF0;
      char v5 = v6;
      int v9 = v6 & 0xC0;
      BOOL v10 = v6 == 237 && v8 == 176;
      BOOL v11 = v10;
      if (v9 != 128 && !v11) {
        goto LABEL_17;
      }
      int v12 = *v7--;
      int v6 = v12;
      --v3;
      if (!--a3) {
        goto LABEL_16;
      }
    }
  }

  char v5 = -80;
  if (a3) {
    goto LABEL_6;
  }
LABEL_16:
  unsigned int v3 = 0;
LABEL_17:
  uint64_t v13 = v3;
  do
  {
    a2 = v13;
    if (!v13) {
      break;
    }
    --v13;
  }

  while (*(unsigned __int8 *)(a1 - 1 + a2) < 0x21u);
  return a2;
}

uint64_t IncrementLabelSuffix(unsigned __int8 *a1, int a2)
{
  uint64_t v4 = *a1;
  if (!a2)
  {
    if (v4 >= 2)
    {
      int v7 = a1[v4];
      int v9 = 2;
      if ((v7 - 48) <= 9)
      {
        if ((((_WORD)v4 - 1) & 0xFFFE) != 0) {
          unsigned int v11 = 2;
        }
        else {
          unsigned int v11 = (unsigned __int16)(v4 - 1);
        }
        unsigned __int16 v12 = v4 - 1;
        while (v12 > 2u)
        {
          int v13 = a1[v12--];
        }

        int v13 = a1[v11];
LABEL_39:
        if (v13 != 45) {
          goto LABEL_61;
        }
        goto LABEL_40;
      }

      char v10 = 1;
    }

    else
    {
      char v10 = 1;
      int v9 = 2;
    }

    unsigned int v8 = 2;
    goto LABEL_27;
  }

  if (v4 >= 4 && a1[v4] == 41 && a1[(unsigned __int16)(v4 - 1)] - 48 <= 9)
  {
    int v5 = v4 - 2;
    uint64_t v6 = (unsigned __int16)(v4 - 2);
    if ((v4 - 2) >= 3)
    {
      do
      {
        uint64_t v6 = (unsigned __int16)--v5;
      }

      while ((unsigned __int16)v5 >= 3u);
    }

    if (a1[v6] != 40 || a1[v6 - 1] != 32) {
      goto LABEL_61;
    }
    int v7 = 41;
LABEL_40:
    if (a2 && v7 == 41)
    {
      LOBYTE(v4) = v4 - 1;
      *a1 = v4;
    }

    int v23 = v4;
    int v24 = a1[v4];
    if ((v24 - 48) > 9)
    {
      unsigned int v25 = 0;
      if (a2) {
        goto LABEL_47;
      }
    }

    else
    {
      unsigned int v25 = 0;
      int v26 = 1;
      do
      {
        v25 += (v24 - 48) * v26;
        v26 *= 10;
        LOBYTE(v4) = v4 - 1;
        *a1 = v4;
        int v23 = v4;
        int v24 = a1[v4];
      }

      while ((v24 - 48) < 0xA);
      if (a2)
      {
LABEL_47:
        if (v4 >= 2u && v24 == 40 && a1[v23 - 1] == 32)
        {
          char v27 = -2;
LABEL_55:
          *a1 = v4 + v27;
          goto LABEL_56;
        }

        goto LABEL_56;
      }
    }

    if ((_BYTE)v4 && v24 == 45)
    {
      char v27 = -1;
      goto LABEL_55;
    }

LABEL_61:
    unsigned int v8 = 2;
LABEL_62:
    if (a2) {
      int v9 = 4;
    }
    else {
      int v9 = 2;
    }
    if (!a2)
    {
      char v10 = 1;
      goto LABEL_27;
    }

    LODWORD(v4) = *a1;
    goto LABEL_12;
  }

  unsigned int v8 = 2;
  int v9 = 4;
LABEL_12:
  while (a1[v4] == 32)
  {
    LODWORD(v4) = v4 - 1;
    *a1 = v4;
  }

  char v10 = 0;
LABEL_27:
  int v14 = v9 - 1;
  unsigned int v15 = 1;
  do
  {
    unsigned int v16 = v15;
    ++v14;
    if (v15 > 0x19999998) {
      break;
    }
    v15 *= 10;
  }

  while (v15 <= v8);
  uint64_t result = TruncateUTF8ToLength((uint64_t)(a1 + 1), *a1, 63 - v14);
  *a1 = result + 1;
  uint64_t v18 = (result + 1);
  if ((v10 & 1) != 0)
  {
    char v19 = 45;
  }

  else
  {
    a1[v18] = 32;
    LOBYTE(v1_Block_object_dispose(va, 8) = *a1 + 1;
    *a1 = v18;
    uint64_t v18 = v18;
    char v19 = 40;
  }

  a1[v18] = v19;
  if (v16)
  {
    do
    {
      unsigned __int8 v20 = *a1 + 1;
      *a1 = v20;
      a1[v20] = v8 / v16 + 48;
      v8 %= v16;
      BOOL v21 = v16 > 9;
      v16 /= 0xAu;
    }

    while (v21);
  }

  if ((v10 & 1) == 0)
  {
    unsigned __int8 v22 = *a1 + 1;
    *a1 = v22;
    a1[v22] = 41;
  }

  return result;
}

    *(_DWORD *)__int128 buf = 141558531;
    int v63 = 1752392040LL;
    int v64 = 1040;
    uint64_t v65 = v43;
    uint64_t v66 = 2101;
    uint64_t v67 = v2 + 1012;
    _os_log_impl( (void *)&_mh_execute_header,  v34,  OS_LOG_TYPE_DEFAULT,  "external_stop_resolving_service - fqdn: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P",  buf,  0x1Cu);
LABEL_62:
    int v44 = putDomainNameAsLabels( (unint64_t)&compression_base_msg,  (unint64_t)&unk_100149887,  (unint64_t)&compression_base_msg + &unk_1000022F8,  __tp,  v35,  v36,  v37,  v38);
    if (v44)
    {
      *(_WORD *)int v44 = 3072;
      v44[2] = 1;
      uint64_t v49 = (unint64_t)(v44 + 3);
    }

    else
    {
      uint64_t v49 = 0LL;
    }

    *(_DWORD *)__int128 buf = 0;
    unsigned int v50 = putDomainNameAsLabels( (unint64_t)&compression_base_msg,  v49,  (unint64_t)&compression_base_msg + &unk_1000022F8,  (unsigned __int8 *)(v2 + 1012),  v45,  v46,  v47,  v48);
    int v51 = &v50[-v49];
    PrintHelper( (uint64_t)"external_stop_resolving_service",  (uint64_t)&unk_100149887,  (unsigned __int16)(v49 - (unsigned __int16)&unk_100149887),  v49,  (unsigned __int16)((_WORD)v50 - v49));
    uint64_t v52 = xD2DMapToTransportType(v30, v32, buf);
    if ((_DWORD)v52 == 4)
    {
      int v53 = 0LL;
      int v54 = *(_DWORD *)buf;
      do
      {
        if (v54 != (_DWORD)v53)
        {
          if (&_D2DStopResolvingPairOnTransport)
          {
            D2DStopResolvingPairOnTransport(&unk_100149887, v49 - (void)&unk_100149887, v49, v51, v53);
            if ((v53 & 0x7FFFFFFE) == 2) {
              _mdns_powerlog_awdl_event((uint64_t)@"stopAWDLResolve", __tp, 12, v61);
            }
          }
        }

        int v53 = (v53 + 1);
      }

      while ((_DWORD)v53 != 4);
    }

    else if (&_D2DStopResolvingPairOnTransport)
    {
      unsigned int v55 = v52;
      D2DStopResolvingPairOnTransport(&unk_100149887, v49 - (void)&unk_100149887, v49, v51, v52);
      if ((v55 & 6) == 2) {
        _mdns_powerlog_awdl_event((uint64_t)@"stopAWDLResolve", __tp, 12, v61);
      }
    }
  }

  uint64_t v56 = *(void *)(a1 + 8);
  if (v56)
  {
    uint64_t v57 = *(unsigned int *)(a1 + 236);
    if ((_DWORD)v57)
    {
      if (AWDLInterfaceID && AWDLInterfaceID == v57)
      {
        unsigned __int16 v58 = 1;
      }

      else
      {
        if (WiFiAwareInterfaceID) {
          uint64_t v59 = WiFiAwareInterfaceID == v57;
        }
        else {
          uint64_t v59 = 0;
        }
        unsigned __int16 v58 = v59;
      }
    }

    else
    {
      unsigned __int16 v58 = (*(unsigned __int8 *)(a1 + 234) >> 4) & 1;
    }

    bzero(__tp, 0x3F1uLL);
    service_type_from_domain_name = _mdns_get_service_type_from_domain_name((unsigned __int8 *)(v2 + 1012), __tp);
    _mdns_powerlog_bonjour_event(0xFu, v58, (const char *)(a1 + 240), (const char *)service_type_from_domain_name, v56);
    *(void *)(a1 + _Block_object_dispose(va, 8) = 0LL;
  }

  uint64_t v29 = fcntl(v14, 3, 0LL);
  if (fcntl(v14, 4, v29 | 4u) == -1 && *__error()) {
    __error();
  }
  uint64_t v30 = *(nw_interface **)(a2 + 48);
  if (v30)
  {
    *(_DWORD *)__int128 buf = 0;
    *(_DWORD *)__int128 buf = nw_interface_get_index(v30);
    if (sa_family == 2)
    {
      if (!setsockopt(v14, 0, 25, buf, 4u)) {
        goto LABEL_96;
      }
      if (*__error())
      {
        uint64_t v31 = *__error();
        if (!v31) {
          goto LABEL_96;
        }
      }

      else
      {
        uint64_t v31 = -6700;
      }

      if (_mdns_resolver_log_s_once != -1) {
        dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_48);
      }
      uint64_t v37 = (os_log_s *)_mdns_resolver_log_s_log;
      if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_ERROR))
      {
        v53[0].val[0] = 67109120;
        v53[0].val[1] = v31;
        int v38 = "setsockopt() for IPPROTO_IP/IP_BOUND_IF failed %{darwin.errno}d";
        goto LABEL_141;
      }
    }

    else
    {
      if (!setsockopt(v14, 41, 125, buf, 4u)) {
        goto LABEL_96;
      }
      if (*__error())
      {
        uint64_t v32 = *__error();
        if (!v32) {
          goto LABEL_96;
        }
      }

      else
      {
        uint64_t v32 = -6700;
      }

      if (_mdns_resolver_log_s_once != -1) {
        dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_48);
      }
      uint64_t v37 = (os_log_s *)_mdns_resolver_log_s_log;
      if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_ERROR))
      {
        v53[0].val[0] = 67109120;
        v53[0].val[1] = v32;
        int v38 = "setsockopt() for IPPROTO_IPV6/IPV6_BOUND_IF failed %{darwin.errno}d";
LABEL_141:
        _os_log_error_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_ERROR, v38, (uint8_t *)v53, 8u);
        if (!a4) {
          goto LABEL_126;
        }
        goto LABEL_97;
      }
    }
  }

uint64_t mDNS_SetupQuestion(uint64_t a1, uint64_t a2, _BYTE *__src, int a4, uint64_t a5, uint64_t a6)
{
  *(void *)(a1 + 136) = a2;
  *(_DWORD *)(a1 + 304) = 0;
  char v10 = __src;
  if (__src == (_BYTE *)-256LL)
  {
LABEL_3:
    while (v10)
    {
      uint64_t v11 = *v10;
      if (!*v10)
      {
        unsigned __int16 v12 = (_WORD)v10 - (_WORD)__src + 1;
        if (v12 > 0x100u) {
          break;
        }
        memcpy((void *)(a1 + 356), __src, v12);
        goto LABEL_11;
      }

      v10 += v11 + 1;
      if (__src != (_BYTE *)-256LL) {
        goto LABEL_2;
      }
    }
  }

  else
  {
LABEL_2:
    if (v10 < __src + 256) {
      goto LABEL_3;
    }
  }

  *(_BYTE *)(a1 + 356) = 0;
LABEL_11:
  *(_WORD *)(a1 + 322) = a4;
  *(_WORD *)(a1 + 3memset(&v5[1], 0, 24) = 1;
  *(_BYTE *)(a1 + 612) = 0;
  *(_BYTE *)(a1 + 613) = a4 != 12;
  *(_BYTE *)(a1 + 621) = 0;
  *(_WORD *)(a1 + 619) = 0;
  *(_BYTE *)(a1 + 632) = 0;
  *(_DWORD *)(a1 + 614) = 0;
  uint64_t result = getpid();
  *(void *)(a1 + 244) = result;
  *(_BYTE *)(a1 + 634) = 0;
  *(_DWORD *)(a1 + 280) = -1;
  *(void *)(a1 + 152) = a5;
  *(void *)(a1 + 176) = a6;
  return result;
}

BOOL RRTypeAnswersQuestionType( uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v10 = a3 & 3;
  if (v10 == 1)
  {
    uint64_t v11 = *(void *)(a1 + 56);
    if (!v11) {
      return 0LL;
    }
    int v12 = 0;
  }

  else
  {
    if (v10 == 3)
    {
      uint64_t v11 = *(void *)(a1 + 56);
      if (!v11) {
        return 0LL;
      }
      if (!*(_DWORD *)(v11 + 32)) {
        goto LABEL_15;
      }
    }

    else
    {
      uint64_t v11 = *(void *)(a1 + 56);
      if (v10 != 2 || !v11)
      {
        BOOL result = 0LL;
        if (v10 == 2 || v11) {
          return result;
        }
        goto LABEL_15;
      }
    }

    int v12 = 1;
  }

  if (*(_DWORD *)(v11 + 32) != v12) {
    return 0LL;
  }
LABEL_15:
  int v14 = *(unsigned __int16 *)(a1 + 4);
  if (v14 == 41) {
    return 0LL;
  }
  if (v14 == 5) {
    return 1LL;
  }
  BOOL result = 1LL;
  if (a2 != 255 && v14 != a2)
  {
    if (v14 == 47)
    {
      int v15 = RRAssertsExistence(a1, 0x2Fu, a3, a4, a5, a6, a7, a8);
      int v14 = *(unsigned __int16 *)(a1 + 4);
      if (!v15 && v14 == 47)
      {
        int v14 = *(unsigned __int16 *)(a1 + 4);
      }
    }

    if (v14 == 46)
    {
      return resource_record_as_rrsig_get_covered_type(a1) == 5;
    }

    return 0LL;
  }

  return result;
}

BOOL RecordAnswersQuestion( uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  BOOL result = SameNameRecordAnswersQuestion((unsigned __int8 *)a1, a2, a3, a4, a5, a6, a7, a8);
  if (result) {
    return *(_DWORD *)(a1 + 16) == *(_DWORD *)(a3 + 200)
  }
        && SameDomainNameBytes(*(_BYTE **)(a1 + 32), (_BYTE *)(a3 + 356)) != 0;
  return result;
}

BOOL LocalOnlyRecordAnswersQuestion( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v9 = *(_DWORD *)(a1 + 172);
  if (v9 <= 3)
  {
    LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "LocalOnlyRecordAnswersQuestion: ERROR!! called with regular AuthRecordAny %##s",  a4,  a5,  a6,  a7,  a8,  *(void *)(a1 + 40));
    return 0LL;
  }

  uint64_t v11 = *(void *)(a1 + 32);
  if (v11)
  {
    uint64_t v12 = *(void *)(a2 + 136);
    if (v12 != -2)
    {
      if (v12)
      {
        if (v11 != v12) {
          return 0LL;
        }
      }

      else
      {
        unint64_t v13 = v11 + 5;
        if (v13 > 3 || v13 == 1) {
          return 0LL;
        }
      }
    }

    if (v9 != 4 && *(_WORD *)(a2 + 320)) {
      return 0LL;
    }
  }

  if (*(void *)(a2 + 144)) {
    return 0LL;
  }
  BOOL result = RRTypeAnswersQuestionType(a1 + 8, *(unsigned __int16 *)(a2 + 322), 0LL, a4, a5, a6, a7, a8);
  if (result)
  {
    int v16 = *(unsigned __int16 *)(a2 + 324);
    return 0LL;
  }

  return result;
}

uint64_t ResourceRecordGetRDataBytesPointer( uint64_t a1, char *a2, int a3, _WORD *a4, int *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v11 = *(unsigned __int16 *)(a1 + 4);
  if ((v11 > 0x2F || ((1LL << v11) & 0x821204268040LL) == 0) && v11 != 65323)
  {
    int v18 = 0;
    uint64_t result = *(void *)(a1 + 40) + 4LL;
    __int16 v16 = *(_WORD *)(a1 + 12);
    if (!a4) {
      goto LABEL_19;
    }
LABEL_18:
    *a4 = v16;
    goto LABEL_19;
  }

  int v15 = putRData(0LL, a2, (unint64_t)&a2[a3], a1, (unint64_t)a5, a6, a7, a8);
  __int16 v16 = (_WORD)v15 - (_WORD)a2;
  BOOL v17 = v15 > a2;
  if (v15 > a2) {
    int v18 = 0;
  }
  else {
    int v18 = -65540;
  }
  if (v15 > a2) {
    uint64_t result = (uint64_t)a2;
  }
  else {
    uint64_t result = 0LL;
  }
  if (!v17) {
    __int16 v16 = 0;
  }
  if (a4) {
    goto LABEL_18;
  }
LABEL_19:
  if (a5) {
    *a5 = v18;
  }
  return result;
}

unint64_t putUpdateLeaseWithLimit(unint64_t a1, unint64_t a2, unint64_t a3)
{
  v16[0] = 32;
  __int16 v17 = 41;
  v51[0] = 264;
  uint64_t v21 = v50;
  unsigned __int8 v22 = v51;
  char v30 = 0;
  char v31 = 0;
  __int128 v23 = 0u;
  __int128 v24 = 0u;
  __int128 v25 = 0u;
  __int128 v26 = 0u;
  __int128 v27 = 0u;
  __int128 v28 = 0u;
  uint64_t v29 = 0LL;
  uint64_t v32 = v50;
  __int16 v46 = 0;
  uint64_t v47 = 0LL;
  uint64_t v49 = 0LL;
  uint64_t v48 = 0LL;
  v50[0] = 0;
  __int128 v44 = 0u;
  memset(v45, 0, sizeof(v45));
  __int128 v42 = 0u;
  __int128 v43 = 0u;
  __int128 v40 = 0u;
  __int128 v41 = 0u;
  __int128 v38 = 0u;
  __int128 v39 = 0u;
  __int128 v36 = 0u;
  __int128 v37 = 0u;
  __int128 v34 = 0u;
  __int128 v35 = 0u;
  __int128 v33 = 0u;
  __int16 v18 = 1440;
  int v19 = 4500;
  int v20 = 1572888;
  v51[2] = 2;
  int v52 = 7200;
  unint64_t v13 = PutResourceRecordTTLWithLimit(a1, a2, (_WORD *)(a1 + 10), (uint64_t)v16, 0LL, a3, v6, v7);
  if (!v13) {
    LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "ERROR: putUpdateLeaseWithLimit - PutResourceRecordTTLWithLimit",  v8,  v9,  v10,  v11,  v12,  v15);
  }
  return v13;
}

_BYTE *skipDomainName(unint64_t a1, _BYTE *a2, unint64_t a3)
{
  uint64_t result = 0LL;
  if ((unint64_t)a2 >= a1 && (unint64_t)a2 < a3)
  {
    uint64_t result = a2 + 1;
    unsigned int v5 = *a2;
    if (*a2)
    {
      unsigned __int16 v6 = 0;
      while (!(v5 >> 6))
      {
        a2 += v5 + 1;
        v6 += v5 + 1;
        unsigned int v5 = *a2;
        if (!*a2) {
          return a2 + 1;
        }
      }

      uint64_t v7 = a2 + 2;
      if ((v5 >> 6) - 1 >= 2) {
        return v7;
      }
      else {
        return 0LL;
      }
    }
  }

  return result;
}

BOOL SetRData( unint64_t a1, unsigned __int8 *__src, unint64_t a3, uint64_t a4, uint64_t __n, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = __n;
  unint64_t v10 = a3;
  uint64_t v11 = __src;
  unint64_t v12 = a1;
  unint64_t v13 = *(unsigned __int16 **)(a4 + 40);
  int v14 = v13 + 2;
  int v15 = *(unsigned __int16 *)(a4 + 4);
  switch(*(_WORD *)(a4 + 4))
  {
    case 1:
      if ((_DWORD)__n != 4) {
        return 0LL;
      }
      *((_BYTE *)v13 + 4) = *__src;
      *((_BYTE *)v13 + 5) = __src[1];
      *((_BYTE *)v13 + 6) = __src[2];
      *((_BYTE *)v13 + 7) = __src[3];
      return 1LL;
    case 2:
    case 3:
    case 4:
    case 5:
    case 7:
    case 8:
    case 9:
    case 0xC:
    case 0x17:
    case 0x27:
      if (a1) {
        goto LABEL_3;
      }
      uint64_t v19 = 257LL;
      int v20 = v13 + 2;
      while (2)
      {
        if (!v20) {
          goto LABEL_303;
        }
        uint64_t v22 = *v20;
        if (*v20)
        {
          v20 += v22 + 1;
          if (v13 != (unsigned __int16 *)-260LL)
          {
LABEL_17:
            if (v20 >= (_BYTE *)v13 + 260) {
              goto LABEL_303;
            }
          }

          continue;
        }

        goto LABEL_301;
      }

    case 6:
      if (!a1)
      {
        uint32_t v78 = v13 + 130;
        uint64_t v79 = 257LL;
        int v80 = v13 + 2;
        if (v13 == (unsigned __int16 *)-260LL)
        {
          while (1)
          {
LABEL_151:
            if (!v80) {
              goto LABEL_260;
            }
            uint64_t v81 = *(unsigned __int8 *)v80;
            if (!*(_BYTE *)v80) {
              break;
            }
            int v80 = (unsigned __int16 *)((char *)v80 + v81 + 1);
          }

          uint64_t v79 = (unsigned __int16)((_WORD)v80 - (_WORD)v14 + 1);
        }

        else
        {
LABEL_150:
          if (v80 < v78) {
            goto LABEL_151;
          }
        }

LABEL_260:
        __int32 v113 = &v11[v79];
        uint64_t v114 = 257LL;
        __int32 v115 = v13 + 130;
        if (v13 == (unsigned __int16 *)-516LL)
        {
          while (1)
          {
LABEL_264:
            if (!v115) {
              goto LABEL_311;
            }
            uint64_t v116 = *v115;
            if (!*v115) {
              break;
            }
            v115 += v116 + 1;
          }

          uint64_t v114 = (unsigned __int16)((_WORD)v115 - (_WORD)v78 + 1);
        }

        else
        {
LABEL_263:
          if (v115 < (_BYTE *)v13 + 516) {
            goto LABEL_264;
          }
        }

LABEL_301:
            __int16 v117 = (_WORD)v20 - (_WORD)v14;
LABEL_302:
            uint64_t v19 = (unsigned __int16)(v117 + 1);
          }
        }

        break;
      }

uint64_t AssignDomainNameWithLimit(_BYTE *a1, _BYTE *a2, unint64_t a3)
{
  unsigned int v3 = a2;
  if (a3)
  {
LABEL_2:
  }

  else
  {
LABEL_3:
    while (v3)
    {
      uint64_t v4 = *v3;
      if (!*v3)
      {
        __int16 v5 = (_WORD)v3 - (_WORD)a2;
        if ((v5 & 0xFF00) != 0) {
          break;
        }
        memcpy(a1, a2, (unsigned __int16)(v5 + 1));
        return 1LL;
      }

      v3 += v4 + 1;
      if (a3) {
        goto LABEL_2;
      }
    }
  }

  uint64_t v6 = 0LL;
  *a1 = 0;
  return v6;
}

unint64_t SanityCheckBitMap( unint64_t result, unint64_t a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (result < a2)
  {
    while (1)
    {
      unsigned int v8 = a3 - 2;
      if (a3 <= 2) {
        break;
      }
      uint64_t v9 = *(unsigned __int8 *)(result + 1);
      a3 = v8 - v9;
      if (v8 < v9 || (v9 - 33) <= 0xFFFFFFDF)
      {
        if (mDNS_LoggingEnabled == 1) {
          LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "SanityCheckBitMap: invalid window length %d",  a4,  a5,  a6,  a7,  a8,  v9);
        }
        return 0LL;
      }

      result += v9 + 2;
      if (result >= a2) {
        return result;
      }
    }

    if (mDNS_LoggingEnabled == 1) {
      LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "SanityCheckBitMap: invalid length %d",  a4,  a5,  a6,  a7,  a8,  a3);
    }
    return 0LL;
  }

  return result;
}

char **mDNS_snprintf_add( char **result, int a2, char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9)
{
  uint64_t v9 = *result;
  int v10 = a2 - *result;
  if (v10)
  {
    uint64_t v11 = result;
    uint64_t result = (char **)mDNS_vsnprintf(v9, v10, a3, &a9);
    *uint64_t v11 = &v9[result];
  }

  return result;
}

void DumpPacket( int a1, int a2, uint64_t a3, __int128 *a4, unsigned int a5, __int128 *a6, unsigned int a7, unsigned __int8 *a8, unint64_t a9, uint64_t a10)
{
  __int128 v129 = xmmword_1000FFD08;
  int v130 = 0;
  memset(v133, 0, sizeof(v133));
  if (a1) {
    int v122 = a1;
  }
  mDNS_snprintf(v133);
  __int16 v16 = &xmmword_10015BD30;
  while (1)
  {
    __int16 v16 = *(__int128 **)v16;
    if (!v16) {
      break;
    }
    __int16 v17 = v16;
    if (*((void *)v16 + 782) == a10) {
      goto LABEL_8;
    }
  }

  __int16 v17 = 0LL;
LABEL_8:
  uint64_t v18 = (uint64_t)v17 + 6310;
  if (v16) {
    uint64_t v19 = v18;
  }
  else {
    uint64_t v19 = 0LL;
  }
  unsigned int v20 = *(unsigned __int16 *)a8;
  if (*(_WORD *)a8)
  {
    uint64_t v21 = (os_log_s *)mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
      {
LABEL_38:
        char v30 = a8 + 12;
        __int128 v31 = 0uLL;
        memset(v192, 0, sizeof(v192));
        __int128 v191 = 0u;
        __int128 v190 = 0u;
        __int128 v189 = 0u;
        __int128 v188 = 0u;
        __int128 v187 = 0u;
        __int128 v186 = 0u;
        __int128 v185 = 0u;
        __int128 v184 = 0u;
        __int128 v183 = 0u;
        __int128 v182 = 0u;
        __int128 v181 = 0u;
        __int128 v180 = 0u;
        __int128 v179 = 0u;
        memset(buf, 0, sizeof(buf));
        memset(v177, 0, sizeof(v177));
        __int32 v132 = (char *)v177;
        if (*((_WORD *)a8 + 2))
        {
          unsigned int v32 = 0;
          do
          {
            DomainName = getDomainName((unint64_t)a8, v30, a9, buf);
            if (!DomainName) {
              return;
            }
            __int128 v39 = DomainName;
            unsigned int v40 = bswap32(*(unsigned __int16 *)DomainName) >> 16;
            unsigned int v41 = *((unsigned __int16 *)DomainName + 1);
            if (v40 != 1) {
              DNSTypeName(v40);
            }
            int v42 = __rev16(v41);
            mDNS_snprintf_add(&v132, (int)buf, " %##s %s", v34, v35, v36, v37, v38, (int)buf);
            if (v42 != 1) {
              mDNS_snprintf_add(&v132, (int)buf, "/%u", v43, v44, v45, v46, v47, v42);
            }
            char v30 = v39 + 4;
            mDNS_snprintf_add(&v132, (int)buf, "?", v43, v44, v45, v46, v47, v123);
            ++v32;
          }

          while (v32 < *((unsigned __int16 *)a8 + 2));
          uint64_t v48 = buf;
          __int128 v31 = 0uLL;
        }

        else
        {
          uint64_t v48 = 0LL;
        }

        v176[30] = v31;
        v176[31] = v31;
        v176[28] = v31;
        v176[29] = v31;
        v176[26] = v31;
        v176[27] = v31;
        v176[24] = v31;
        v176[25] = v31;
        v176[22] = v31;
        v176[23] = v31;
        v176[20] = v31;
        v176[21] = v31;
        v176[18] = v31;
        v176[19] = v31;
        v176[16] = v31;
        v176[17] = v31;
        v176[14] = v31;
        v176[15] = v31;
        v176[12] = v31;
        v176[13] = v31;
        v176[10] = v31;
        v176[11] = v31;
        v176[8] = v31;
        v176[9] = v31;
        v176[6] = v31;
        v176[7] = v31;
        v176[4] = v31;
        v176[5] = v31;
        v176[2] = v31;
        v176[3] = v31;
        v176[0] = v31;
        v176[1] = v31;
        int v131 = (char *)v176;
        int v49 = *((unsigned __int16 *)a8 + 3);
        int v50 = *((unsigned __int16 *)a8 + 4);
        int v51 = *((unsigned __int16 *)a8 + 5);
        if (v50 + v49 + v51)
        {
          int v52 = 0;
          int v126 = v50 + v51 + v49;
          do
          {
            unint64_t v53 = &buf[256 * (unint64_t)(v48 == buf)];
            int v54 = getDomainName((unint64_t)a8, v30, a9, v53);
            if (v54) {
              BOOL v60 = (uint64_t)(a9 - (void)v54) < 10;
            }
            else {
              BOOL v60 = 1;
            }
            if (v60) {
              return;
            }
            int64_t v61 = __rev16(*((unsigned __int16 *)v54 + 4));
            unsigned int v62 = v54 + 10;
            unsigned int v63 = *(unsigned __int16 *)v54;
            unsigned int v64 = *((unsigned __int16 *)v54 + 1);
            unsigned int v128 = *((_DWORD *)v54 + 1);
            if (v52) {
              mDNS_snprintf_add(&v131, (int)v177, ",", v55, v56, v57, v58, v59, v122);
            }
            int v65 = __rev16(v63);
            uint64_t v66 = "A";
            if (v65 != 1) {
              LODWORD(v66) = DNSTypeName(v65);
            }
            int v67 = __rev16(v64);
            mDNS_snprintf_add(&v131, (int)v177, " %s", v55, v56, v57, v58, v59, (int)v66);
            if (v67 != 1) {
              mDNS_snprintf_add(&v131, (int)v177, "/%u", v68, v69, v70, v71, v72, v67);
            }
            mDNS_snprintf_add(&v131, (int)v177, " ", v68, v69, v70, v71, v72, v124);
            if (v65 > 5)
            {
              if (v65 == 6)
              {
                uint32_t v88 = getDomainName((unint64_t)a8, v62, a9, buf);
                if (!v88) {
                  return;
                }
                uint64_t v89 = getDomainName((unint64_t)a8, v88, a9, v192);
                mDNS_snprintf_add(&v131, (int)v177, "%##s %##s %lu %lu %lu %lu %lu", v90, v91, v92, v93, v94, (int)buf);
                unint64_t v53 = 0LL;
              }

              else
              {
                if (v65 != 28 || (_DWORD)v61 != 16) {
                  goto LABEL_76;
                }
                mDNS_snprintf_add(&v131, (int)v177, "%.16a", v73, v74, v75, v76, v77, (int)v62);
              }
            }

            else
            {
              if (v65 != 1)
              {
                if (v65 == 5)
                {
                  mDNS_snprintf_add(&v131, (int)v177, "%##s", v78, v79, v80, v81, v82, (int)v53);
                  goto LABEL_77;
                }

void DumpMDNSPacket( int a1, unsigned __int8 *a2, unint64_t a3, _DWORD *a4, __int16 a5, _DWORD *a6, unsigned __int16 a7, unsigned int a8, uint64_t a9)
{
  int v15 = a2 + 12;
  uint64_t v16 = (a3 - (_DWORD)a2);
  int v97 = a2[2];
  if (a6)
  {
    BOOL IsDNSMulticast = mDNSAddrIsDNSMulticast(a6);
    BOOL v18 = a7 == 59668LL;
    if (IsDNSMulticast) {
      BOOL v18 = 0;
    }
    BOOL v94 = v18;
  }

  else
  {
    BOOL v94 = 0;
  }

  int v19 = -2128831035;
  if ((_DWORD)v16)
  {
    unsigned int v20 = a2;
    uint64_t v21 = v16;
    do
    {
      int v22 = *v20++;
      int v19 = 16777619 * (v19 ^ v22);
      --v21;
    }

    while (v21);
    uint64_t v23 = a2;
    uint64_t v24 = v16;
    do
    {
      int v25 = *v23++;
      LODWORD(v21) = v25 + 65599 * v21;
      --v24;
    }

    while (v24);
  }

  else
  {
    LODWORD(v21) = 0;
  }

  int v26 = v21;
  int v27 = v19;
  if (a4)
  {
    uint64_t v28 = 0LL;
    uint64_t v29 = a4 + 1;
    int v30 = v19;
    do
      int v30 = 16777619 * (v30 ^ *((unsigned __int8 *)v29 + v28++));
    while (v28 != 4);
    uint64_t v31 = 0LL;
    int v32 = v30 ^ a5;
    int v33 = v21;
    do
      int v33 = *((unsigned __int8 *)v29 + v31++) + 65599 * v33;
    while (v31 != 4);
    int v26 = HIBYTE(a5) + 65599 * (a5 + 65599 * v33);
    int v27 = 16777619 * ((16777619 * v32) ^ HIBYTE(a5));
  }

  int v93 = v16;
  if (a6)
  {
    uint64_t v34 = 0LL;
    uint64_t v35 = a6 + 1;
    do
      int v27 = 16777619 * (v27 ^ *((unsigned __int8 *)v35 + v34++));
    while (v34 != 4);
    for (uint64_t i = 0LL; i != 4; ++i)
      int v26 = *((unsigned __int8 *)v35 + i) + 65599 * v26;
    int v26 = HIBYTE(a7) + 65599 * (a7 + 65599 * v26);
    int v27 = 16777619 * ((16777619 * (v27 ^ a7)) ^ HIBYTE(a7));
  }

  uint64_t v37 = 0LL;
  uint64_t v38 = a9;
  *(_DWORD *)__int128 buf = bswap32(a8);
  do
    int v27 = 16777619 * (v27 ^ buf[v37++]);
  while (v37 != 4);
  for (uint64_t j = 0LL; j != 4; ++j)
    int v26 = buf[j] + 65599 * v26;
  unsigned int v40 = DumpMDNSPacket_CalculateAndCheckIfMsgAppearsBefore_nextMsgHashUninitializedSlot;
  else {
    uint64_t v41 = DumpMDNSPacket_CalculateAndCheckIfMsgAppearsBefore_nextMsgHashUninitializedSlot;
  }
  if ((_DWORD)v41)
  {
    int v42 = DumpMDNSPacket_CalculateAndCheckIfMsgAppearsBefore_previousMsg2ndHashes;
    uint64_t v43 = DumpMDNSPacket_CalculateAndCheckIfMsgAppearsBefore_previousMsgHashes;
    while (1)
    {
      int v44 = *v43++;
      if (v44 == v19 && *v42 == (_DWORD)v21) {
        break;
      }
      ++v42;
      if (!--v41) {
        goto LABEL_37;
      }
    }

    int v46 = 0;
  }

  else
  {
LABEL_37:
    uint64_t v45 = DumpMDNSPacket_CalculateAndCheckIfMsgAppearsBefore_nextMsgHashSlot;
    DumpMDNSPacket_CalculateAndCheckIfMsgAppearsBefore_previousMsgHashes[DumpMDNSPacket_CalculateAndCheckIfMsgAppearsBefore_nextMsgHashSlot] = v19;
    DumpMDNSPacket_CalculateAndCheckIfMsgAppearsBefore_previousMsg2ndHashes[v45] = v21;
    DumpMDNSPacket_CalculateAndCheckIfMsgAppearsBefore_nextMsgHashSlot = ((int)v45 + 1) % 0x14u;
    if (v40 <= 0x13) {
      DumpMDNSPacket_CalculateAndCheckIfMsgAppearsBefore_nextMsgHashUninitializedSlot = v40 + 1;
    }
    int v46 = 1;
  }

  unsigned int v47 = DumpMDNSPacket_CalculateAndCheckIfMsgAppearsBefore_nextCompleteHashUninitializedSlot;
  else {
    uint64_t v48 = DumpMDNSPacket_CalculateAndCheckIfMsgAppearsBefore_nextCompleteHashUninitializedSlot;
  }
  if ((_DWORD)v48)
  {
    int v49 = DumpMDNSPacket_CalculateAndCheckIfMsgAppearsBefore_previousComplete2ndHashes;
    int v50 = DumpMDNSPacket_CalculateAndCheckIfMsgAppearsBefore_previousCompleteHashes;
    while (1)
    {
      int v51 = *v50++;
      if (v51 == v27 && *v49 == v26) {
        break;
      }
      ++v49;
      if (!--v48) {
        goto LABEL_49;
      }
    }

    char v53 = 0;
  }

  else
  {
LABEL_49:
    uint64_t v52 = DumpMDNSPacket_CalculateAndCheckIfMsgAppearsBefore_nextCompleteHashSlot;
    DumpMDNSPacket_CalculateAndCheckIfMsgAppearsBefore_previousCompleteHashes[DumpMDNSPacket_CalculateAndCheckIfMsgAppearsBefore_nextCompleteHashSlot] = v27;
    DumpMDNSPacket_CalculateAndCheckIfMsgAppearsBefore_previousComplete2ndHashes[v52] = v26;
    DumpMDNSPacket_CalculateAndCheckIfMsgAppearsBefore_nextCompleteHashSlot = ((int)v52 + 1) % 0x14u;
    if (v47 <= 0x13) {
      DumpMDNSPacket_CalculateAndCheckIfMsgAppearsBefore_nextCompleteHashUninitializedSlot = v47 + 1;
    }
    char v53 = 1;
  }

  int v56 = *((unsigned __int16 *)a2 + 2);
  int v57 = *((unsigned __int16 *)a2 + 3);
  if (!a4)
  {
    if (!a6)
    {
      BOOL v58 = 1;
      goto LABEL_60;
    }

unsigned __int8 *DumpMDNSPacket_GetNameHashTypeClass( unint64_t a1, unsigned __int8 *a2, unint64_t a3, _DWORD *a4, _WORD *a5)
{
  uint64_t result = getDomainName(a1, a2, a3, v12);
  if (result)
  {
    uint64_t v9 = (unsigned __int16 *)result;
    int v10 = mDNS_DomainNameFNV1aHash((unsigned __int8 *)v12);
    if ((unint64_t)(v9 + 2) <= a3)
    {
      unsigned int v11 = *v9;
      if (a4) {
        *a4 = v10;
      }
      if (a5) {
        *a5 = bswap32(v11) >> 16;
      }
      return (unsigned __int8 *)1;
    }

    else
    {
      return 0LL;
    }
  }

  return result;
}

BOOL DNSQuestionNeedsSensitiveLogging(uint64_t a1)
{
  return is_apple_internal_build_is_internal && *(_BYTE *)(a1 + 653) == 1;
}

BOOL DNSQuestionIsEligibleForMDNSAlternativeService(uint64_t a1)
{
  if (*(_WORD *)(a1 + 320)) {
    return 0LL;
  }
  uint64_t v2 = *(void *)(a1 + 136);
  if (v2)
  {
    if (AWDLInterfaceID) {
      BOOL v3 = AWDLInterfaceID == v2;
    }
    else {
      BOOL v3 = 0;
    }
    if (v3)
    {
      int v5 = 1;
    }

    else
    {
      if (WiFiAwareInterfaceID) {
        BOOL v4 = WiFiAwareInterfaceID == v2;
      }
      else {
        BOOL v4 = 0;
      }
      int v5 = v4;
    }
  }

  else
  {
    int v5 = (*(_DWORD *)(a1 + 304) >> 20) & 1;
  }

  return v5 == 0;
}

void mDNS_VerifyLockState(char *a1, int a2, unsigned int a3, unsigned int a4, uint64_t a5, int a6)
{
  if (!a2)
  {
    if (a3 != a4)
    {
      char v16 = gSensitiveLoggingEnabled;
      uint64_t v17 = mDNSLogCategory_Default;
      if (mDNSLogCategory_Default == mDNSLogCategory_State) {
        char v16 = 0;
      }
      if (a3 <= a4)
      {
        if ((v16 & 1) != 0)
        {
          uint64_t v17 = mDNSLogCategory_Default_redacted;
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_FAULT)) {
            return;
          }
        }

        else if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_FAULT))
        {
          return;
        }

        int v23 = 136447746;
        uint64_t v24 = a1;
        __int16 v25 = 2082;
        *(void *)int v26 = a5;
        *(_WORD *)&v26[8] = 1024;
        *(_DWORD *)&v26[10] = a6;
        __int16 v27 = 2082;
        *(void *)uint64_t v28 = mDNS_VerifyLockState_lastLockOperator;
        *(_WORD *)&v28[8] = 1024;
        *(_DWORD *)uint64_t v29 = mDNS_VerifyLockState_lineNumberlastLockOperator;
        *(_WORD *)&v29[4] = 1024;
        unsigned int v30 = a3;
        __int16 v31 = 1024;
        unsigned int v32 = a4;
        unint64_t v12 = "Lock failure: %{public}s, last lock dropper dropped the lock before grabbing it - caller: %{public}s at li"
              "ne %u, last lock dropper: %{public}s at line %u, mDNS_busy (%u) != mDNS_reentrancy (%u).";
      }

      else
      {
        if ((v16 & 1) != 0)
        {
          uint64_t v17 = mDNSLogCategory_Default_redacted;
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_FAULT)) {
            return;
          }
        }

        else if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_FAULT))
        {
          return;
        }

        int v23 = 136447746;
        uint64_t v24 = a1;
        __int16 v25 = 2082;
        *(void *)int v26 = a5;
        *(_WORD *)&v26[8] = 1024;
        *(_DWORD *)&v26[10] = a6;
        __int16 v27 = 2082;
        *(void *)uint64_t v28 = mDNS_VerifyLockState_lastLockOperator;
        *(_WORD *)&v28[8] = 1024;
        *(_DWORD *)uint64_t v29 = mDNS_VerifyLockState_lineNumberlastLockOperator;
        *(_WORD *)&v29[4] = 1024;
        unsigned int v30 = a3;
        __int16 v31 = 1024;
        unsigned int v32 = a4;
        unint64_t v12 = "Lock failure: %{public}s, last lock holder still holds the lock - caller: %{public}s at line %u, last succ"
              "essful lock holder: %{public}s at line %u, mDNS_busy (%u) != mDNS_reentrancy (%u).";
      }

      uint64_t v21 = (os_log_s *)v17;
      uint32_t v22 = 56;
      goto LABEL_51;
    }

    int v14 = *a1;
    if (v14 <= 75)
    {
      if (v14 == 67) {
        return;
      }
      if (v14 == 68) {
        goto LABEL_15;
      }
    }

    else
    {
      if (v14 == 85 || v14 == 82)
      {
        os_unfair_lock_lock(&mDNS_VerifyLockState_logLock);
        mDNS_VerifyLockState_lastLockOperator = 0LL;
        mDNS_VerifyLockState_lineNumberlastLockOperator = 0;
        goto LABEL_45;
      }

      if (v14 == 76)
      {
LABEL_15:
        os_unfair_lock_lock(&mDNS_VerifyLockState_logLock);
        mDNS_VerifyLockState_lastLockOperator = a5;
        mDNS_VerifyLockState_lineNumberlastLockOperator = a6;
LABEL_45:
        os_unfair_lock_unlock(&mDNS_VerifyLockState_logLock);
        return;
      }
    }

    uint64_t v19 = mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_FAULT)) {
        return;
      }
      int v23 = 136446210;
      uint64_t v24 = a1;
      unint64_t v12 = "Invalid lock operation - %{public}s";
    }

    else
    {
      uint64_t v19 = mDNSLogCategory_Default_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_FAULT)) {
        return;
      }
      int v23 = 136446210;
      uint64_t v24 = a1;
      unint64_t v12 = "Invalid lock operation - %{public}s";
    }

    uint64_t v21 = (os_log_s *)v19;
    uint32_t v22 = 12;
    goto LABEL_51;
  }

  if (a4 + 1 >= a3)
  {
    if (a4 + 1 <= a3) {
      return;
    }
    uint64_t v10 = mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_FAULT)) {
        return;
      }
    }

    else
    {
      uint64_t v10 = mDNSLogCategory_Default_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_FAULT)) {
        return;
      }
    }

    int v23 = 136447490;
    uint64_t v24 = (char *)a5;
    __int16 v25 = 1024;
    *(_DWORD *)int v26 = a6;
    *(_WORD *)&v26[4] = 2082;
    *(void *)&v26[6] = mDNS_VerifyLockState_lastLockOperator;
    __int16 v27 = 1024;
    *(_DWORD *)uint64_t v28 = mDNS_VerifyLockState_lineNumberlastLockOperator;
    *(_WORD *)&v28[4] = 1024;
    *(_DWORD *)&v28[6] = a3;
    *(_WORD *)uint64_t v29 = 1024;
    *(_DWORD *)&v29[2] = a4;
    unint64_t v12 = "Lock failure: Check Lock, last lock dropper dropped the lock before grabbing it - caller: %{public}s at line %"
          "u, last lock dropper: %{public}s at line %u, mDNS_busy (%u) != mDNS_reentrancy (%u).";
    goto LABEL_43;
  }

  uint64_t v10 = mDNSLogCategory_Default;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
  {
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_FAULT)) {
      return;
    }
    goto LABEL_9;
  }

  uint64_t v10 = mDNSLogCategory_Default_redacted;
  if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_FAULT))
  {
LABEL_9:
    int v23 = 136447490;
    uint64_t v24 = (char *)a5;
    __int16 v25 = 1024;
    *(_DWORD *)int v26 = a6;
    *(_WORD *)&v26[4] = 2082;
    *(void *)&v26[6] = mDNS_VerifyLockState_lastLockOperator;
    __int16 v27 = 1024;
    *(_DWORD *)uint64_t v28 = mDNS_VerifyLockState_lineNumberlastLockOperator;
    *(_WORD *)&v28[4] = 1024;
    *(_DWORD *)&v28[6] = a3;
    *(_WORD *)uint64_t v29 = 1024;
    *(_DWORD *)&v29[2] = a4;
    unint64_t v12 = "Lock failure: Check Lock, lock was grabbed by multiple callers - caller: %{public}s at line %u, last successfu"
          "l lock holder: %{public}s at line %u, mDNS_busy (%u) != mDNS_reentrancy (%u).";
LABEL_43:
    uint64_t v21 = (os_log_s *)v10;
    uint32_t v22 = 46;
LABEL_51:
    _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_FAULT, v12, (uint8_t *)&v23, v22);
  }

uint64_t GetReverseIPv6Addr(_BYTE *a1, _OWORD *a2)
{
  unsigned int v3 = 0;
  __int128 v10 = 0uLL;
  do
  {
    if (*a1 != 1) {
      return 0LL;
    }
    BOOL v4 = a1;
    int v5 = a1[1];
    if ((v5 - 48) >= 0xA)
    {
      if ((v5 - 97) >= 6)
      {
        char v6 = -55;
      }

      else
      {
        char v6 = -87;
      }
    }

    else
    {
      char v6 = -48;
    }

    uint64_t v7 = 15LL - (v3 >> 1);
    char v8 = v6 + v5;
    if ((v3 & 1) != 0) {
      char v8 = *((_BYTE *)&v10 + v7) | (16 * v8);
    }
    *((_BYTE *)&v10 + v7) = v8;
    ++v3;
    a1 += 2;
  }

  while (v3 != 32);
  uint64_t result = SameDomainNameBytes(v4 + 2, "\x03ip6\x04arpa");
  if ((_DWORD)result)
  {
    if (a2) {
      *a2 = v10;
    }
    return 1LL;
  }

  return result;
}

id _mdns_ne_dns_proxy_state_watch_log()
{
  if (_mdns_ne_dns_proxy_state_watch_log_s_once != -1) {
    dispatch_once(&_mdns_ne_dns_proxy_state_watch_log_s_once, &__block_literal_global_10);
  }
  return (id)_mdns_ne_dns_proxy_state_watch_log_s_log;
}

id _mdns_ne_dns_proxy_state_watch_queue()
{
  if (_mdns_ne_dns_proxy_state_watch_queue_s_once != -1) {
    dispatch_once(&_mdns_ne_dns_proxy_state_watch_queue_s_once, &__block_literal_global_5);
  }
  return (id)_mdns_ne_dns_proxy_state_watch_queue_s_queue;
}

void _mdns_ne_dns_proxy_state_watch_fetch_manager_status(void *a1)
{
  id v1 = a1;
  id v2 = [(id)g_managers indexOfObjectIdenticalTo:v1];
  id v3 = [(id)g_managers count];
  id v4 = _mdns_ne_dns_proxy_state_watch_log();
  int v5 = (os_log_s *)objc_claimAutoreleasedReturnValue(v4);
  BOOL v6 = os_log_type_enabled(v5, OS_LOG_TYPE_INFO);
  if (v2 >= v3)
  {
    if (v6)
    {
      *(_DWORD *)__int128 buf = 134217984;
      id v9 = v1;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_INFO,  "Not fetching status for stale manager -- address: %p",  buf,  0xCu);
    }
  }

  else
  {
    if (v6)
    {
      *(_DWORD *)__int128 buf = 134217984;
      id v9 = v1;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_INFO,  "Fetching status for manager -- address: %p",  buf,  0xCu);
    }

    v7[0] = _NSConcreteStackBlock;
    v7[1] = 3221225472LL;
    void v7[2] = ___mdns_ne_dns_proxy_state_watch_fetch_manager_status_block_invoke;
    v7[3] = &unk_10013BBC0;
    v7[4] = v1;
    [v1 fetchStatusWithCompletionHandler:v7];
  }
}

void ___mdns_ne_dns_proxy_state_watch_fetch_manager_status_block_invoke(uint64_t a1, unint64_t a2)
{
  id v4 = _mdns_ne_dns_proxy_state_watch_log();
  int v5 = (os_log_s *)objc_claimAutoreleasedReturnValue(v4);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v6 = *(void *)(a1 + 32);
    if (a2 > 4) {
      uint64_t v7 = "«UNKNOWN STATUS»";
    }
    else {
      uint64_t v7 = off_10013BBF8[a2];
    }
    *(_DWORD *)__int128 buf = 134218498;
    uint64_t v12 = v6;
    __int16 v13 = 2082;
    int v14 = v7;
    __int16 v15 = 2048;
    unint64_t v16 = a2;
    _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "Fetched status for manager -- address: %p, status: %{public}s (%lld)",  buf,  0x20u);
  }

  id v8 = _mdns_ne_dns_proxy_state_watch_queue();
  id v9 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue(v8);
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 3221225472LL;
  v10[2] = ___mdns_ne_dns_proxy_state_watch_fetch_manager_status_block_invoke_23;
  void v10[3] = &unk_10013BB98;
  v10[4] = *(void *)(a1 + 32);
  v10[5] = a2;
  dispatch_async(v9, v10);
}

void ___mdns_ne_dns_proxy_state_watch_fetch_manager_status_block_invoke_23(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 40);
  id v2 = *(id *)(a1 + 32);
  id v3 = [(id)g_managers indexOfObjectIdenticalTo:v2];
  if (v3 >= [(id)g_managers count])
  {
    id v6 = _mdns_ne_dns_proxy_state_watch_log();
    uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue(v6);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      int v8 = 134217984;
      id v9 = v2;
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "Not handling status update for stale manager -- address: %p",  (uint8_t *)&v8,  0xCu);
    }
  }

  else
  {
    if (v1 == 3) {
      uint64_t v4 = 2LL;
    }
    else {
      uint64_t v4 = 1LL;
    }
    int v5 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:", v4));
    [(id)g_states setObject:v5 atIndexedSubscript:v3];

    _mdns_ne_dns_proxy_state_watch_check_for_collective_state_change();
  }
}

void _mdns_ne_dns_proxy_state_watch_check_for_collective_state_change()
{
  uint64_t v0 = g_current_state;
  __int128 v13 = 0u;
  __int128 v14 = 0u;
  __int128 v15 = 0u;
  __int128 v16 = 0u;
  id v1 = (id)g_states;
  id v2 = [v1 countByEnumeratingWithState:&v13 objects:buf count:16];
  if (v2)
  {
    id v3 = v2;
    char v4 = 0;
    uint64_t v5 = *(void *)v14;
    do
    {
      for (uint64_t i = 0LL; i != v3; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v14 != v5) {
          objc_enumerationMutation(v1);
        }
        unsigned int v7 = objc_msgSend( *(id *)(*((void *)&v13 + 1) + 8 * (void)i),  "unsignedIntValue",  (void)v13);
        if (v7)
        {
          if (v7 == 2)
          {

            int v8 = 2;
            goto LABEL_15;
          }
        }

        else
        {
          char v4 = 1;
        }
      }

      id v3 = [v1 countByEnumeratingWithState:&v13 objects:buf count:16];
    }

    while (v3);
  }

  else
  {
    char v4 = 0;
  }

  int v8 = (v4 & 1) == 0;
LABEL_15:
  if (v8 != (_DWORD)v0)
  {
    g_current_state = v8;
    id v9 = off_10013BBE0[v0];
    __int128 v10 = off_10013BBE0[v8];
    id v11 = _mdns_ne_dns_proxy_state_watch_log();
    uint64_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue(v11);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 136446466;
      BOOL v18 = v9;
      __int16 v19 = 2082;
      unsigned int v20 = v10;
      _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEFAULT,  "State change: %{public}s -> %{public}s",  buf,  0x16u);
    }

    if ((g_current_state - 1) <= 1)
    {
      if (g_user_updater) {
        dispatch_source_merge_data((dispatch_source_t)g_user_updater, g_current_state);
      }
    }
  }

void ___mdns_ne_dns_proxy_state_watch_queue_block_invoke(id a1)
{
  dispatch_queue_t v1 = dispatch_queue_create("com.apple.mdns.ne-dns-proxy-state-watch", 0LL);
  id v2 = (void *)_mdns_ne_dns_proxy_state_watch_queue_s_queue;
  _mdns_ne_dns_proxy_state_watch_queue_s_queue = (uint64_t)v1;
}

void ___mdns_ne_dns_proxy_state_watch_log_block_invoke(id a1)
{
  os_log_t v1 = os_log_create("com.apple.mdns", "ne_dns_proxy_state_watch");
  id v2 = (void *)_mdns_ne_dns_proxy_state_watch_log_s_log;
  _mdns_ne_dns_proxy_state_watch_log_s_log = (uint64_t)v1;
}

id _mdns_ne_dns_proxy_state_watch_load_managers()
{
  id v0 = _mdns_ne_dns_proxy_state_watch_log();
  os_log_t v1 = (os_log_s *)objc_claimAutoreleasedReturnValue(v0);
  if (os_log_type_enabled(v1, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)id v3 = 0;
    _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_INFO, "Loading new manager array", v3, 2u);
  }

  return +[NEDNSProxyManager loadAllFromPreferencesWithCompletionHandler:]( &OBJC_CLASS___NEDNSProxyManager,  "loadAllFromPreferencesWithCompletionHandler:",  &__block_literal_global_14_2139);
}

void ___mdns_ne_dns_proxy_state_watch_load_managers_block_invoke(id a1, NSArray *a2)
{
  id v2 = a2;
  id v3 = _mdns_ne_dns_proxy_state_watch_queue();
  char v4 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue(v3);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472LL;
  block[2] = ___mdns_ne_dns_proxy_state_watch_load_managers_block_invoke_2;
  block[3] = &unk_10013CBA0;
  void block[4] = v2;
  dispatch_async(v4, block);
}

void ___mdns_ne_dns_proxy_state_watch_load_managers_block_invoke_2(uint64_t a1)
{
  id v1 = *(id *)(a1 + 32);
  id v2 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
  id v3 = (void *)g_managers;
  g_managers = (uint64_t)v2;

  char v4 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
  uint64_t v5 = (void *)g_states;
  g_states = (uint64_t)v4;

  __int128 v17 = 0u;
  __int128 v18 = 0u;
  __int128 v15 = 0u;
  __int128 v16 = 0u;
  id v6 = v1;
  id v7 = [v6 countByEnumeratingWithState:&v15 objects:v23 count:16];
  if (v7)
  {
    id v8 = v7;
    uint64_t v9 = *(void *)v16;
    do
    {
      for (uint64_t i = 0LL; i != v8; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v16 != v9) {
          objc_enumerationMutation(v6);
        }
        uint64_t v11 = *(void *)(*((void *)&v15 + 1) + 8LL * (void)i);
        if (objc_msgSend((id)g_managers, "indexOfObjectIdenticalTo:", v11, (void)v15) == (id)0x7FFFFFFFFFFFFFFFLL)
        {
          [(id)g_managers addObject:v11];
          [(id)g_states addObject:&off_1001407D0];
        }
      }

      id v8 = [v6 countByEnumeratingWithState:&v15 objects:v23 count:16];
    }

    while (v8);
  }

  _mdns_ne_dns_proxy_state_watch_check_for_collective_state_change();
  id v12 = [(id)g_managers count];
  id v13 = _mdns_ne_dns_proxy_state_watch_log();
  __int128 v14 = (os_log_s *)objc_claimAutoreleasedReturnValue(v13);
  if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(buf) = 134217984;
    *(void *)((char *)&buf + 4) = v12;
    _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_DEFAULT,  "Updated DNS proxy managers -- count: %llu",  (uint8_t *)&buf,  0xCu);
  }

  *(void *)&__int128 buf = _NSConcreteStackBlock;
  *((void *)&buf + 1) = 3221225472LL;
  unsigned int v20 = ___mdns_ne_dns_proxy_state_watch_handle_new_managers_block_invoke;
  uint64_t v21 = &__block_descriptor_40_e34_v32__0__NEDNSProxyManager_8Q16_B24l;
  id v22 = v12;
  [(id)g_managers enumerateObjectsUsingBlock:&buf];
}

void ___mdns_ne_dns_proxy_state_watch_handle_new_managers_block_invoke(uint64_t a1, void *a2, uint64_t a3)
{
  id v5 = a2;
  id v6 = _mdns_ne_dns_proxy_state_watch_log();
  id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue(v6);
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v8 = *(void *)(a1 + 32);
    int v9 = 134218754;
    uint64_t v10 = a3 + 1;
    __int16 v11 = 2048;
    uint64_t v12 = v8;
    __int16 v13 = 2048;
    id v14 = v5;
    __int16 v15 = 2112;
    id v16 = v5;
    _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "DNS proxy manager (%llu/%llu) -- address: %p, description: %@",  (uint8_t *)&v9,  0x2Au);
  }

  [v5 setDelegate:g_watcher];
  _mdns_ne_dns_proxy_state_watch_fetch_manager_status(v5);
}

void __mdns_ne_dns_proxy_state_watch_start_block_invoke(uint64_t a1)
{
  id v1 = *(void **)(a1 + 40);
  id v2 = (dispatch_queue_s *)*(id *)(a1 + 32);
  id v3 = v1;
  if (_mdns_ne_dns_proxy_state_watch_init_s_once != -1) {
    dispatch_once(&_mdns_ne_dns_proxy_state_watch_init_s_once, &__block_literal_global_7_2149);
  }
  if (g_user_updater)
  {
    char v4 = (dispatch_source_s *)(id)g_user_updater;
    dispatch_source_cancel(v4);
    id v5 = (void *)g_user_updater;
    g_user_updater = 0LL;
  }

  v8[0] = 0LL;
  v8[1] = v8;
  _DWORD v8[2] = 0x2020000000LL;
  int v9 = 0;
  id v6 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_data_replace, 0LL, 0LL, v2);
  handler[0] = _NSConcreteStackBlock;
  handler[1] = 3221225472LL;
  _OWORD handler[2] = ___mdns_ne_dns_proxy_state_watch_start_block_invoke;
  handler[3] = &unk_10013BAD0;
  void handler[5] = v3;
  handler[6] = v8;
  handler[4] = v6;
  dispatch_source_set_event_handler(v6, handler);
  dispatch_activate(v6);
  objc_storeStrong((id *)&g_user_updater, v6);

  _Block_object_dispose(v8, 8);
}

unint64_t ___mdns_ne_dns_proxy_state_watch_start_block_invoke(uint64_t a1)
{
  unint64_t result = dispatch_source_get_data(*(dispatch_source_t *)(a1 + 32));
  int v3 = result;
  if ((result - 1) <= 1 && *(_DWORD *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL) != (_DWORD)result)
  {
    id v4 = _mdns_ne_dns_proxy_state_watch_log();
    id v5 = (os_log_s *)objc_claimAutoreleasedReturnValue(v4);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
    {
      v6[0] = 67109120;
      v6[1] = v3 == 2;
      _os_log_debug_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEBUG,  "Calling user's update handler -- running: %{BOOL}d",  (uint8_t *)v6,  8u);
    }

    unint64_t result = (*(uint64_t (**)(void))(*(void *)(a1 + 40) + 16LL))();
    *(_DWORD *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL) = v3;
  }

  return result;
}

void ___mdns_ne_dns_proxy_state_watch_init_block_invoke(id a1)
{
  id v1 = objc_alloc_init(&OBJC_CLASS___MDNSNEDNSProxyWatcher);
  id v2 = (void *)g_watcher;
  g_watcher = (uint64_t)v1;

  int v3 = (void *)objc_claimAutoreleasedReturnValue(+[NSNotificationCenter defaultCenter](&OBJC_CLASS___NSNotificationCenter, "defaultCenter"));
  [v3 addObserver:g_watcher selector:"configurationChanged:" name:NEDNSProxyConfigurationDidChangeNotification object:0];

  _mdns_ne_dns_proxy_state_watch_load_managers();
}

uint64_t _dnssec_obj_dns_question_member_compare()
{
  return 2LL;
}

void _dnssec_obj_dns_question_member_finalize(uint64_t a1)
{
  id v2 = *(void **)(a1 + 16);
  if (v2)
  {
    ref_count_obj_release(v2);
    *(void *)(a1 + 16) = 0LL;
  }

uint64_t resolver_discovery_get_next_scheduled_event()
{
  if (!g_discover_resolvers) {
    return 0LL;
  }
  id v0 = *(void **)g_discover_resolvers;
  if (!*(void *)g_discover_resolvers) {
    return 0LL;
  }
  unsigned int v1 = 0;
  id v2 = *(void **)g_discover_resolvers;
  do
  {
    uint64_t v3 = v2[1];
    if (v3)
    {
      uint64_t v4 = *(void *)(v3 + 272);
      if (v4)
      {
        uint64_t v5 = *(void *)(v4 + 656);
        if (v5)
        {
          unsigned int v6 = *(_DWORD *)(v5 + 1584);
          if (v6)
          {
          }
        }
      }
    }

    id v2 = (void *)*v2;
  }

  while (v2);
  do
  {
    uint64_t v8 = v0[1];
    if (!*(_DWORD *)(v8 + 264))
    {
      int v9 = *(_DWORD *)(v8 + 256);
      if (v9)
      {
      }
    }

    id v0 = (void *)*v0;
  }

  while (v0);
  else {
    unsigned int v12 = v1;
  }
  if ((_DWORD)v2) {
    return v12;
  }
  else {
    return v1;
  }
}

uint64_t dns_push_handle_question_start(uint64_t a1, uint64_t a2)
{
  if (*(_BYTE *)(a2 + 635))
  {
    uint64_t v5 = 4294960591LL;
    goto LABEL_42;
  }

  uint64_t v8 = calloc(1uLL, 0x18uLL);
  if (!v8) {
    goto LABEL_45;
  }
  id v2 = v8;
  int v9 = &_dns_push_obj_dns_question_member_kind;
  v8[1] = &_dns_push_obj_dns_question_member_kind;
  do
  {
    uint64_t v10 = (void (*)(void *))v9[2];
    if (v10) {
      v10(v2);
    }
    int v9 = (_UNKNOWN **)*v9;
  }

  while (v9);
  int v11 = (*(_DWORD *)v2)++;
  v2[2] = 0LL;
  unsigned int v12 = *(void **)(a2 + 184);
  if (v12 != v2)
  {
    *(_DWORD *)id v2 = v11 + 2;
    if (v12) {
      ref_count_obj_release(v12);
    }
    *(void *)(a2 + 184) = v2;
  }

  *(_BYTE *)(a2 + 612) = 0;
  unsigned int v27 = 0;
  uint64_t v3 = (_BYTE *)(a2 + 356);
  __int16 v13 = dns_obj_domain_name_create_with_labels((_BYTE *)(a2 + 356), (int *)&v27);
  uint64_t v4 = v13;
  uint64_t v5 = v27;
  if (v27) {
    goto LABEL_46;
  }
  uint64_t v5 = *((void *)v13 + 2);
  uint64_t v14 = *(unsigned __int8 *)v5 + 2LL;
  if (v14 == *((void *)v13 + 3))
  {
    int v24 = *(unsigned __int16 *)(a2 + 322);
    __int16 v25 = (os_log_s *)mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_ERROR))
      {
LABEL_53:
        unsigned int v26 = bswap32(*(unsigned __int16 *)(a2 + 320));
        *(_DWORD *)__int128 buf = 67110147;
        unsigned int v29 = HIWORD(v26);
        __int16 v30 = 2160;
        uint64_t v31 = 1752392040LL;
        __int16 v32 = 1040;
        int v33 = v14;
        __int16 v34 = 2101;
        uint64_t v35 = v5;
        __int16 v36 = 1024;
        int v37 = v24;
        _os_log_impl( (void *)&_mh_execute_header,  v25,  OS_LOG_TYPE_ERROR,  "[Q%u] Unable to start DNS push server discovery for the single-label name (TLD) -- qname: %{sensitive, mask.ha sh, mdnsresponder:domain_name}.*P, qtype: %{mdns:rrtype}d",  buf,  0x28u);
      }
    }

    else
    {
      __int16 v25 = (os_log_s *)mDNSLogCategory_Default_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_ERROR)) {
        goto LABEL_53;
      }
    }

    id v16 = 0LL;
    uint64_t v5 = 4294960591LL;
    unsigned int v27 = -6705;
LABEL_20:
    ref_count_obj_release(v4);
    goto LABEL_21;
  }

  __int16 v15 = calloc(1uLL, 0x48uLL);
  if (!v15) {
    goto LABEL_45;
  }
  id v16 = v15;
  uint64_t v5 = (uint64_t)&_dns_push_obj_context_kind;
  v15[1] = &_dns_push_obj_context_kind;
  do
  {
    __int128 v17 = *(void (**)(void *))(v5 + 16);
    if (v17) {
      v17(v16);
    }
    uint64_t v5 = *(void *)v5;
  }

  while (v5);
  ++*(_DWORD *)v16;
  void v16[5] = a2;
  unsigned int v27 = 0;
  if (v4) {
    goto LABEL_20;
  }
LABEL_21:
  while (!(_DWORD)v5)
  {
    __int128 v18 = (void *)v2[2];
    if (v18 != v16)
    {
      if (v16) {
        ++*(_DWORD *)v16;
      }
      if (v18) {
        ref_count_obj_release(v18);
      }
      v2[2] = v16;
    }

    __int16 v19 = calloc(1uLL, 0x290uLL);
    if (v19)
    {
      unsigned int v20 = v19;
      v19[17] = *(void *)(a2 + 136);
      for (uint64_t i = v3; (unint64_t)i < a2 + 612; i += v22 + 1)
      {
        if (!i) {
          break;
        }
        uint64_t v22 = *i;
        if (!*i)
        {
          if ((unsigned __int16)((_WORD)i - (_WORD)v3 + 1) <= 0x100u)
          {
            memcpy((char *)v19 + 356, v3, (unsigned __int16)((_WORD)i - (_WORD)v3 + 1));
            goto LABEL_38;
          }

          break;
        }
      }

      *((_BYTE *)v19 + 356) = 0;
LABEL_38:
      v20[161] = 6;
      v20[162] = *(_WORD *)(a2 + 324);
      *((_DWORD *)v20 + 61) = getpid();
      *((void *)v20 + 19) = _dns_push_discovery_soa_result_reply;
      *((void *)v20 + 22) = v16;
      *((_BYTE *)v20 + 615) = 1;
      *((_BYTE *)v20 + 612) = 0;
      if (!mDNS_StartQuery_internal(a1, v20))
      {
        void v16[6] = v20;
        ref_count_obj_release(v2);
        ref_count_obj_release(v16);
        return 0LL;
      }

      free(v20);
      uint64_t v5 = 4294960567LL;
      break;
    }

void _dns_push_discovery_soa_result_reply(uint64_t a1, uint64_t a2, unsigned __int8 *a3, int a4)
{
  int v37 = (unsigned __int16 *)a2;
  if (a4 != 1) {
    return;
  }
  uint64_t v5 = (uint64_t)a3;
  uint64_t v8 = *(void *)(a2 + 176);
  int v36 = 0;
  if (*a3 != 240)
  {
    if (*((_WORD *)a3 + 2) != 6) {
      goto LABEL_60;
    }
    int v11 = dns_obj_domain_name_create_with_labels(*((_BYTE **)a3 + 4), &v36);
    unsigned int v12 = v11;
    int v13 = v36;
    if (v36)
    {
LABEL_57:
      if (!v12) {
        goto LABEL_59;
      }
      goto LABEL_58;
    }

    if (!v11) {
      goto LABEL_3;
    }
    ++*(_DWORD *)v11;
    uint64_t v14 = *(void **)(v8 + 16);
    if (v14) {
      ref_count_obj_release(v14);
    }
    *(void *)(v8 + 16) = v12;
    _dns_push_discovery_stop((unsigned int *)a1, &v37, v8, 1);
    mDNS_Lock_((unsigned int *)a1, (uint64_t)"_dns_push_discovery_soa_result_reply", 256);
    uint64_t v15 = *(void *)(v5 + 24);
    uint64_t v16 = v15 + 5;
    mDNS_Unlock_(a1, (uint64_t)"_dns_push_discovery_soa_result_reply", 258);
    *(_DWORD *)(v8 + 64) = v15;
    uint64_t v17 = *(void *)(v5 + 24);
    __int128 v18 = calloc(1uLL, 0x290uLL);
    if (!v18) {
      goto LABEL_73;
    }
    uint64_t v5 = (uint64_t)v18;
    uint64_t v19 = *(void *)(v8 + 24);
    if (v19)
    {
LABEL_17:
      uint64_t v21 = *(char **)(v19 + 16);
      unsigned int v20 = v21;
      if (v21 == (char *)-256LL)
      {
LABEL_19:
        while (v21)
        {
          uint64_t v22 = *v21;
          if (!*v21)
          {
            unsigned __int16 v26 = (_WORD)v21 - (_WORD)v20 + 1;
            if (v26 > 0x100u) {
              break;
            }
            memcpy((void *)(v5 + 356), v20, v26);
            goto LABEL_36;
          }

          v21 += v22 + 1;
        }
      }

      else
      {
LABEL_18:
        if (v21 < v20 + 256) {
          goto LABEL_19;
        }
      }

      *(_BYTE *)(v5 + 356) = 0;
LABEL_36:
      uint64_t v27 = *(void *)(v8 + 40);
      if (!v27) {
        goto LABEL_55;
      }
      *(_WORD *)(v5 + 322) = 33;
      *(_WORD *)(v5 + 3memset(&v5[1], 0, 24) = *(_WORD *)(v27 + 324);
      *(void *)(v5 + 136) = v17;
      *(_DWORD *)(v5 + 244) = getpid();
      *(void *)(v5 + 152) = _dns_push_discovery_srv_result_reply;
      *(void *)(v5 + 176) = v8;
      *(_BYTE *)(v5 + 615) = 1;
      *(_BYTE *)(v5 + 612) = 0;
      unsigned int v28 = *(_DWORD *)(v8 + 64);
      uint64_t v4 = (uint64_t *)g_interface_monitors;
      if (g_interface_monitors)
      {
        while (1)
        {
          uint64_t v15 = *v4;
          if (*(_DWORD *)(*v4 + 136) == v28) {
            break;
          }
          uint64_t v4 = (uint64_t *)v4[2];
          if (!v4) {
            goto LABEL_40;
          }
        }

        os_retain((void *)*v4);
        ++v4[1];
        goto LABEL_52;
      }

void dns_push_handle_question_stop(unsigned int *a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 184);
  if (v2)
  {
    uint64_t v3 = *(void **)(v2 + 16);
    if (v3)
    {
      int v13 = (unsigned __int16 *)v3[6];
      if (v13)
      {
        _dns_push_discovery_stop(a1, &v13, (uint64_t)v3, 0);
        v3[6] = 0LL;
      }

      uint64_t v5 = v3[4];
      if (v5)
      {
        uint64_t DNSServiceManager = Querier_GetDNSServiceManager();
        if (DNSServiceManager)
        {
          mdns_dns_service_manager_deregister_discovered_push_service(DNSServiceManager, v5);
          v3[4] = 0LL;
        }
      }

      id v7 = (void *)v3[7];
      if (v7)
      {
        uint64_t v8 = g_interface_monitors;
        if (*(void **)g_interface_monitors == v7)
        {
          uint64_t v10 = &g_interface_monitors;
LABEL_15:
          uint64_t v11 = *(void *)(v8 + 8) - 1LL;
          *(void *)(v8 + _Block_object_dispose(va, 8) = v11;
          if (!v11)
          {
            *uint64_t v10 = *(void *)(v8 + 16);
            if (*(void *)v8)
            {
              mdns_interface_monitor_invalidate(*(void **)v8);
              os_release(*(void **)v8);
            }

            free((void *)v8);
            id v7 = (void *)v3[7];
          }
        }

        else
        {
          while (1)
          {
            uint64_t v9 = v8;
            uint64_t v8 = *(void *)(v8 + 16);
            if (!v8) {
              break;
            }
            if (*(void **)v8 == v7)
            {
              uint64_t v10 = (uint64_t *)(v9 + 16);
              goto LABEL_15;
            }
          }
        }

        if (v7) {
LABEL_20:
        }
          os_release(v7);
        v3[7] = 0LL;
      }

      unsigned int v12 = *(void **)(a2 + 184);
      if (v12)
      {
        ref_count_obj_release(v12);
        *(void *)(a2 + 184) = 0LL;
      }

      *(_BYTE *)(a2 + 612) = 1;
    }
  }

void _dns_push_discovery_stop(unsigned int *a1, unsigned __int16 **a2, uint64_t a3, int a4)
{
  uint64_t v8 = *a2;
  if (*a2 != *(unsigned __int16 **)(a3 + 48))
  {
    uint64_t v9 = (os_log_s *)mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_FAULT)) {
        goto LABEL_11;
      }
      goto LABEL_10;
    }

    uint64_t v9 = (os_log_s *)mDNSLogCategory_Default_redacted;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_FAULT))
    {
LABEL_10:
      unsigned int v12 = bswap32(v8[160]) >> 16;
      v13[0] = 67109120;
      v13[1] = v12;
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_FAULT,  "[Q%u] Question being stopped is not the currently active discovery question",  (uint8_t *)v13,  8u);
    }
  }

void _dns_push_discovery_srv_result_reply(unsigned int *a1, uint64_t a2, unsigned __int8 *a3, int a4)
{
  int v46 = (unsigned __int16 *)a2;
  if (a4 != 1) {
    return;
  }
  uint64_t v6 = *(void *)(a2 + 176);
  unsigned int v7 = bswap32(*(unsigned __int16 *)(*(void *)(v6 + 40) + 320LL)) >> 16;
  if (*a3 == 240)
  {
    uint64_t v8 = (os_log_s *)mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v10 = *(void *)(a2 + 80);
        if (v10) {
          uint64_t v10 = *(void *)(v10 + 24);
        }
        goto LABEL_24;
      }
    }

    else
    {
      uint64_t v8 = (os_log_s *)mDNSLogCategory_Default_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v10 = *(void *)(a2 + 80);
        if (v10) {
          uint64_t v10 = *(void *)(v10 + 24);
        }
LABEL_24:
        *(_DWORD *)__int128 buf = 67109376;
        unsigned int v50 = v7;
        __int16 v51 = 2048;
        *(void *)uint64_t v52 = v10;
        _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "[Q%u] Current network does not support DNS push, falling back to DNS polling -- service ID: %llu",  buf,  0x12u);
      }
    }

    uint64_t v23 = *(void *)(v6 + 40);
    unsigned int v24 = *(_DWORD *)(v23 + 252);
    unsigned int v25 = bswap32(*(unsigned __int16 *)(v23 + 320)) >> 16;
    unsigned __int16 v26 = (os_log_s *)mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
      {
LABEL_30:
        *(_DWORD *)__int128 buf = 67109376;
        unsigned int v50 = v24;
        __int16 v51 = 1024;
        *(_DWORD *)uint64_t v52 = v25;
        _os_log_impl( (void *)&_mh_execute_header,  v26,  OS_LOG_TYPE_DEFAULT,  "[R%u->Q%u] Starting long-lived DNS polling -- polling interval: 15 min",  buf,  0xEu);
      }
    }

    else
    {
      unsigned __int16 v26 = (os_log_s *)mDNSLogCategory_Default_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_30;
      }
    }

    *(_BYTE *)(v6 + 6_Block_object_dispose(va, 8) = 1;
LABEL_32:
    Querier_ProcessDNSServiceChangesAsync();
    return;
  }

  uint64_t v11 = *(void *)(v6 + 16);
  if (!v11) {
    return;
  }
  mDNS_Lock_(a1, (uint64_t)"_dns_push_discovery_srv_result_reply", 311);
  uint64_t v13 = *((void *)a3 + 3);
  uint64_t v14 = v13 + 5;
  mDNS_Unlock_((uint64_t)a1, (uint64_t)"_dns_push_discovery_srv_result_reply", 313);
  *(_DWORD *)__int128 buf = 0;
  unsigned __int8 v48 = 0;
  uint64_t DNSServiceManager = Querier_GetDNSServiceManager(v15);
  if (!DNSServiceManager)
  {
    int v21 = -6729;
    goto LABEL_48;
  }

  uint64_t v17 = DNSServiceManager;
  __int128 v18 = (_BYTE *)_dns_push_discovery_register_push_service_dns_push_service_type;
  if (!_dns_push_discovery_register_push_service_dns_push_service_type)
  {
    __int128 v18 = dns_obj_domain_name_create_with_cstring("_dns-push-tls._tcp", buf);
    _dns_push_discovery_register_push_service_dns_push_service_xpc_type_t type = (uint64_t)v18;
    int v21 = *(_DWORD *)buf;
    if (*(_DWORD *)buf) {
      goto LABEL_36;
    }
  }

  concatenation = dns_obj_domain_name_create_concatenation(*((_BYTE **)v18 + 2), *(_BYTE **)(v11 + 16), buf);
  unsigned int v20 = concatenation;
  int v21 = *(_DWORD *)buf;
  if (*(_DWORD *)buf)
  {
    if (concatenation) {
      ref_count_obj_release(concatenation);
    }
LABEL_36:
    uint64_t v27 = 0LL;
    int v28 = 0;
    goto LABEL_46;
  }

  unsigned int v29 = mdns_domain_name_create_with_labels(*((_BYTE **)concatenation + 2), 0LL);
  if (v29)
  {
    int v47 = 0;
    uint64_t v30 = mdns_dns_service_manager_register_discovered_push_service(v17, (uint64_t)v29, v13, (uint64_t)&v48, &v47);
    uint64_t v27 = v30;
    if (v30)
    {
      *(void *)(v6 + 32) = v30;
      if (v48) {
        Querier_ProcessDNSServiceChangesAsync();
      }
      goto LABEL_44;
    }

    int v31 = v47;
  }

  else
  {
    uint64_t v27 = 0LL;
    int v31 = -6729;
  }

  *(_DWORD *)__int128 buf = v31;
LABEL_44:
  int v28 = v48;
  int v21 = *(_DWORD *)buf;
  ref_count_obj_release(v20);
  if (v29) {
    os_release(v29);
  }
LABEL_46:
  if (v27 || !v21)
  {
    char v35 = gSensitiveLoggingEnabled;
    uint64_t v36 = mDNSLogCategory_Default;
    if (mDNSLogCategory_Default == mDNSLogCategory_State) {
      char v35 = 0;
    }
    if (v28)
    {
      if ((v35 & 1) != 0)
      {
        uint64_t v36 = mDNSLogCategory_Default_redacted;
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_64;
        }
      }

      else if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
      {
LABEL_64:
        *(_DWORD *)__int128 buf = 67109632;
        unsigned int v50 = v7;
        __int16 v51 = 2048;
        *(void *)uint64_t v52 = v27;
        *(_WORD *)&v52[8] = 1024;
        *(_DWORD *)&v52[10] = 1;
        int v37 = "[Q%u] DNS push discovery finished -- service id: %llu, re registered: %{mdns:yesno}d";
        uint64_t v38 = (os_log_s *)v36;
        uint32_t v39 = 24;
LABEL_67:
        _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_DEFAULT, v37, buf, v39);
      }

void ___dns_push_discovery_start_mdns_interface_monitor_block_invoke(uint64_t a1, int a2)
{
  if (a2 == 1)
  {
    _dns_push_discovery_process_interface_changes(*(void *)(a1 + 32));
  }

  else if (a2 == 2)
  {
    os_release(*(void **)(a1 + 32));
  }

void ___dns_push_discovery_start_mdns_interface_monitor_block_invoke_2(uint64_t a1, char a2)
{
  if (a2 < 0) {
    _dns_push_discovery_process_interface_changes(*(void *)(a1 + 32));
  }
}

void _dns_push_discovery_process_interface_changes(uint64_t a1)
{
  int v33 = *(_DWORD *)(a1 + 136);
  uint64_t v2 = pthread_mutex_lock((pthread_mutex_t *)(mDNSStorage + 616));
  *(_DWORD *)(mDNSStorage + 680) = mDNSPlatformRawTime(v2, v3, v4, v5, v6, v7, v8, v9);
  mDNS_Lock_((unsigned int *)&mDNSStorage, (uint64_t)"_dns_push_discovery_process_interface_changes", 487);
  uint64_t DNSServiceManager = Querier_GetDNSServiceManager(v10);
  uint64_t v12 = qword_100158C80;
  if (!qword_100158C80) {
    goto LABEL_20;
  }
  uint64_t v13 = DNSServiceManager;
  uint64_t v14 = 0LL;
  uint64_t v15 = qword_100158C80;
  do
  {
    ++v14;
    uint64_t v15 = *(void *)(v15 + 8);
  }

  while (v15);
  qword_100158CA8 = qword_100158C80;
  if (v14)
  {
    uint64_t v16 = 0LL;
    do
    {
      if (!v12) {
        break;
      }
      uint64_t v17 = *(void *)(v12 + 184);
      if (!v17) {
        goto LABEL_17;
      }
      uint64_t v18 = *(void *)(v17 + 16);
      if (!v18) {
        goto LABEL_17;
      }
      uint64_t v19 = *(void *)(v18 + 56);
      if (!v19 || v19 != a1) {
        goto LABEL_17;
      }
      uint64_t v21 = *(void *)(v18 + 32);
      v34[0] = 0LL;
      v34[1] = v34;
      v34[2] = 0x2000000000LL;
      int v35 = 0;
      if (_mdns_dns_service_queue_s_once != -1) {
        dispatch_once(&_mdns_dns_service_queue_s_once, &__block_literal_global_237);
      }
      ++v16;
      blocuint64_t k = _NSConcreteStackBlock;
      *(void *)&__int128 v37 = 0x40000000LL;
      *((void *)&v37 + 1) = __mdns_dns_service_manager_terminate_discovered_push_service_block_invoke;
      uint64_t v38 = &unk_10013A228;
      uint32_t v39 = v34;
      uint64_t v40 = v13;
      uint64_t v41 = v21;
      dispatch_sync((dispatch_queue_t)_mdns_dns_service_queue_s_queue, &block);
      _Block_object_dispose(v34, 8);
      dns_push_handle_question_stop(&mDNSStorage, v12);
      dns_push_handle_question_start(&mDNSStorage, v12);
      uint64_t v22 = qword_100158CA8;
      if (qword_100158CA8 == v12)
      {
LABEL_17:
        uint64_t v22 = *(void *)(v12 + 8);
        qword_100158CA8 = v22;
      }

      uint64_t v12 = v22;
      --v14;
    }

    while (v14);
  }

  else
  {
LABEL_20:
    uint64_t v16 = 0LL;
  }

  qword_100158CA8 = 0LL;
  uint64_t v23 = (os_log_s *)mDNSLogCategory_Default;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
  {
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
    {
LABEL_29:
      LODWORD(block) = 67109376;
      HIDWORD(block) = v33;
      LOWORD(v37) = 2048;
      *(void *)((char *)&v37 + 2) = v16;
      _os_log_impl( (void *)&_mh_execute_header,  v23,  OS_LOG_TYPE_DEFAULT,  "Network changes, restarting all push questions that are related to the changed interface -- if_index: %u, restarted count: %zu",  (uint8_t *)&block,  0x12u);
    }
  }

  else
  {
    uint64_t v23 = (os_log_s *)mDNSLogCategory_Default_redacted;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_29;
    }
  }

  mDNS_Unlock_((uint64_t)&mDNSStorage, (uint64_t)"_dns_push_discovery_process_interface_changes", 529);
  KQueueUnlock((uint64_t)"DNS push interface monitor", v26, v27, v28, v29, v30, v31, v32);
}

void ___dns_push_discovery_interface_monitor_queue_block_invoke(id a1)
{
  _dns_push_discovery_interface_monitor_queue_s_queue = (uint64_t)dispatch_queue_create( "com.apple.dns-push.interface-monitor",  0LL);
}

uint64_t LogToFD( int a1, char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9)
{
  return dprintf(a1, "%s\n", __b);
}

void mdns_free_context_finalizer(void *a1)
{
  if (a1) {
    free(a1);
  }
}

uint64_t _dnssec_obj_rr_nsec_compare(uint64_t a1, uint64_t a2, char a3)
{
  if ((a3 & 1) != 0) {
    return 3LL;
  }
  else {
    return domain_name_label_canonical_compare( *(unsigned __int8 **)(*(void *)(a1 + 16) + 16LL),  *(unsigned __int8 **)(*(void *)(a2 + 16) + 16LL),  0);
  }
}

void _dnssec_obj_rr_nsec_finalize(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 80);
  if (v2)
  {
    ref_count_obj_release(v2);
    *(void *)(a1 + 80) = 0LL;
  }

uint64_t dnssec_obj_rr_nsec_covers_dns_type(_BYTE *a1, __int16 a2, unsigned int a3)
{
  int v3 = *a1;
  uint64_t v4 = a1;
  if (*a1)
  {
    uint64_t v4 = a1;
    do
    {
      uint64_t v5 = &v4[v3];
      int v6 = v5[1];
      uint64_t v4 = v5 + 1;
      int v3 = v6;
    }

    while (v6);
  }

  return rdata_parser_type_bit_maps_cover_dns_type(v4 + 1, (unsigned __int16)(~((_WORD)v4 - (_WORD)a1) + a2), a3);
}

BOOL dnssec_obj_rr_nsec_asserts_name_exists_data_does_not_exist( uint64_t a1, uint64_t a2, int a3, unsigned int a4)
{
  int v6 = *(_BYTE **)(a1 + 24);
  __int16 v7 = *(_WORD *)(a1 + 36);
  return (dnssec_obj_rr_nsec_covers_dns_type(v6, v7, a4) & 1) == 0
      && (dnssec_obj_rr_nsec_covers_dns_type(v6, v7, 5u) & 1) == 0
      && ref_count_obj_compare(*(void *)(a1 + 16), a2, 1LL) == 0;
}

uint64_t dnssec_obj_rr_nsec_asserts_name_does_not_exist(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v4 = *(void *)(a1 + 80);
  int v5 = *(unsigned __int8 *)(a1 + 88);
  int v6 = ref_count_obj_compare(*(void *)(a1 + 16), a2, 0LL);
  if (v5)
  {
    if (v6 == -1) {
      return 1LL;
    }
    return ref_count_obj_compare(a2, v4, 0LL) == -1;
  }

  if (v6 != -1) {
    return 0LL;
  }
  return ref_count_obj_compare(a2, v4, 0LL) == -1;
}

uint64_t _discovery_proxy_start_handler( unsigned int a1, const __CFArray *a2, const __CFArray *a3, const __CFArray *a4)
{
  uint64_t v8 = pthread_mutex_lock((pthread_mutex_t *)(mDNSStorage[0] + 616));
  *(_DWORD *)(mDNSStorage[0] + 680) = mDNSPlatformRawTime(v8, v9, v10, v11, v12, v13, v14, v15);
  _discovery_proxy_stop_internal();
  uint64_t v16 = mdns_dns_push_service_definition_create();
  if (v16)
  {
    uint64_t v24 = (uint64_t)v16;
    if (a1)
    {
      mdns_dns_push_service_definition_set_interface_index((uint64_t)v16, a1, 2);
      *(_WORD *)(v24 + 79) = 257;
      CFIndex Count = CFArrayGetCount(a2);
      if (Count >= 1)
      {
        CFIndex v26 = Count;
        for (CFIndex i = 0LL; i != v26; ++i)
        {
          uint64_t ValueAtIndex = CFArrayGetValueAtIndex(a2, i);
          CFArrayAppendValue(*(CFMutableArrayRef *)(v24 + 40), ValueAtIndex);
        }
      }

      CFIndex v29 = CFArrayGetCount(a3);
      if (v29 >= 1)
      {
        CFIndex v30 = v29;
        for (CFIndex j = 0LL; j != v30; ++j)
        {
          uint64_t v32 = CFArrayGetValueAtIndex(a3, j);
          CFSetAddValue(*(CFMutableSetRef *)(v24 + 48), v32);
        }
      }

      CFIndex v33 = CFArrayGetCount(a4);
      if (v33 >= 1)
      {
        CFIndex v34 = v33;
        for (CFIndex k = 0LL; k != v34; ++k)
        {
          uint64_t v36 = CFArrayGetValueAtIndex(a4, k);
          CFArrayAppendValue(*(CFMutableArrayRef *)(v24 + 56), v36);
        }
      }

      uint64_t v37 = Querier_RegisterCustomPushDNSServiceWithConnectionErrorHandler(v24, 0LL, 0LL);
      g_discovery_proxy_service_id = v37;
      if (v37)
      {
        uint64_t v38 = v37;
        uint32_t v39 = (os_log_s *)mDNSLogCategory_uDNS;
        if (gSensitiveLoggingEnabled == 1 && mDNSLogCategory_uDNS != mDNSLogCategory_State)
        {
          uint32_t v39 = (os_log_s *)mDNSLogCategory_uDNS_redacted;
          BOOL v42 = os_log_type_enabled((os_log_t)mDNSLogCategory_uDNS_redacted, OS_LOG_TYPE_DEFAULT);
          uint64_t v41 = 0LL;
          if (!v42) {
            goto LABEL_26;
          }
          int v44 = 134217984;
          uint64_t v45 = v38;
          goto LABEL_25;
        }

        uint64_t v41 = 0LL;
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_uDNS, OS_LOG_TYPE_DEFAULT))
        {
          int v44 = 134217984;
          uint64_t v45 = v38;
LABEL_25:
          _os_log_impl( (void *)&_mh_execute_header,  v39,  OS_LOG_TYPE_DEFAULT,  "Discovery proxy service registered -- id: %llu",  (uint8_t *)&v44,  0xCu);
          uint64_t v41 = 0LL;
        }
      }

      else
      {
        uint64_t v41 = 4294960582LL;
      }

uint64_t _discovery_proxy_stop_handler()
{
  uint64_t v0 = pthread_mutex_lock((pthread_mutex_t *)(mDNSStorage[0] + 616));
  *(_DWORD *)(mDNSStorage[0] + 680) = mDNSPlatformRawTime(v0, v1, v2, v3, v4, v5, v6, v7);
  _discovery_proxy_stop_internal();
  KQueueUnlock((uint64_t)"discovery_proxy_stop_handler", v8, v9, v10, v11, v12, v13, v14);
  return 0LL;
}

void _discovery_proxy_stop_internal()
{
  uint64_t v0 = g_discovery_proxy_service_id;
  if (g_discovery_proxy_service_id)
  {
    uint64_t DNSServiceManager = Querier_GetDNSServiceManager();
    if (DNSServiceManager) {
      mdns_dns_service_manager_deregister_custom_push_service(DNSServiceManager, v0);
    }
    uint64_t v2 = (os_log_s *)mDNSLogCategory_uDNS;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_uDNS == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_uDNS, OS_LOG_TYPE_DEFAULT))
      {
LABEL_14:
        g_discovery_proxy_service_id = 0LL;
        return;
      }

      int v5 = 134217984;
      uint64_t v6 = g_discovery_proxy_service_id;
    }

    else
    {
      uint64_t v2 = (os_log_s *)mDNSLogCategory_uDNS_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_uDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_14;
      }
      int v5 = 134217984;
      uint64_t v6 = g_discovery_proxy_service_id;
    }

    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "Discovery proxy service deregistered -- id: %llu",  (uint8_t *)&v5,  0xCu);
    goto LABEL_14;
  }

void ___mdns_managed_defaults_log_block_invoke(id a1)
{
  _mdns_managed_defaults_log_s_log = (uint64_t)os_log_create("com.apple.mdns", "managed_defaults");
}

uint64_t _dnssec_obj_trust_anchor_manager_compare()
{
  return 2LL;
}

void _dnssec_obj_trust_anchor_manager_finalize(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 16);
  while (v1)
  {
    uint64_t v2 = v1;
    uint64_t v1 = (void *)*v1;
    do
    {
      uint64_t v4 = (void *)v2[1];
      uint64_t v3 = (void *)v2[2];
      if (v3) {
        ref_count_obj_release(v3);
      }
      free(v2);
      uint64_t v2 = v4;
    }

    while (v4);
  }

uint64_t dnssec_obj_trust_anchor_manager_add_anchor(uint64_t a1, uint64_t a2)
{
  uint64_t result = (uint64_t)calloc(1uLL, 0x18uLL);
  if (result)
  {
    int v5 = (void *)result;
    uint64_t v6 = *(void *)(*(void *)(a2 + 16) + 16LL);
    uint64_t v7 = (void *)(a1 + 16);
    uint64_t v8 = v7;
    while (1)
    {
      uint64_t v9 = v8;
      uint64_t v8 = (void *)*v8;
      if (!v8) {
        break;
      }
      if (!ref_count_obj_compare(*(void *)(*(void *)(v8[2] + 16LL) + 16LL), v6, 1LL))
      {
        uint64_t v10 = v8;
        while (ref_count_obj_compare(v10[2], a2, 1LL))
        {
          uint64_t v10 = (void *)v10[1];
          if (!v10)
          {
            *uint64_t v9 = v5;
            *int v5 = *v8;
            *uint64_t v8 = 0LL;
            v5[1] = v8;
            goto LABEL_12;
          }
        }

        free(v5);
        return 4294960566LL;
      }
    }

    do
    {
      uint64_t v11 = v7;
      uint64_t v7 = (void *)*v7;
    }

    while (v7 && ref_count_obj_compare(*(void *)(*(void *)(v7[2] + 16LL) + 16LL), v6, 0LL) != 1);
    *uint64_t v11 = v5;
    *int v5 = v7;
LABEL_12:
    uint64_t result = 0LL;
    v5[2] = a2;
    ++*(_DWORD *)a2;
  }

  else
  {
    __break(1u);
  }

  return result;
}

void LogMcastStateInfo( int a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9)
{
  if ((_DWORD)a3)
  {
    i_msize_t count = 0;
    if ((_DWORD)a2) {
      msize_t count = 0;
    }
    if (mDNS_McastLoggingEnabled) {
      LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "--- START MCAST STATE LOG ---",  a4,  a5,  a6,  a7,  a8,  v21);
    }
    uint64_t v10 = all_requests;
    if (all_requests)
    {
      do
      {
        uint64_t v11 = *(void *)(v10 + 24);
        if (v11)
        {
          for (uint64_t i = all_requests; i && i != v10; uint64_t i = *(void *)(i + 16))
          {
            if (i == v11) {
              goto LABEL_18;
            }
          }

          if (mDNS_McastLoggingEnabled) {
            LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "%3d: Orphan operation; parent not found in request list",
          }
              a4,
              a5,
              a6,
              a7,
              a8,
              *(_DWORD *)(v10 + 168));
        }

        LogMcastClientInfo((void *)v10, a2, a3, a4, a5, a6, a7, a8, v21);
LABEL_18:
        uint64_t v10 = *(void *)(v10 + 16);
      }

      while (v10);
      if (mcount || (msize_t count = i_mcount) != 0)
      {
LABEL_43:
        int v20 = mDNS_McastLoggingEnabled;
        if (a1)
        {
          if (mDNS_McastLoggingEnabled)
          {
            LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "--- MCOUNT[%d]: CMPKTNUM[%d] - IMPKTNUM[%d] = [%d]PKTS ---",  a4,  a5,  a6,  a7,  a8,  mcount);
            int v20 = mDNS_McastLoggingEnabled;
          }
        }

        if (v20)
        {
          uint64_t v18 = (os_log_s *)mDNSLogCategory_Default;
          uint64_t v19 = "--- END MCAST STATE LOG ---";
LABEL_48:
          LogMsgWithLevel(v18, OS_LOG_TYPE_DEFAULT, v19, a4, a5, a6, a7, a8, a9);
          return;
        }

        return;
      }
    }

    else
    {
      msize_t count = 0;
      if (!mDNS_McastLoggingEnabled)
      {
        LogMcastStateInfo_i_mpktnuuint64_t m = dword_100158C40;
        goto LABEL_43;
      }

      LogMsgWithLevel((os_log_s *)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "<None>", a4, a5, a6, a7, a8, v21);
      if (mcount) {
        goto LABEL_43;
      }
    }

    LogMcastStateInfo_i_mpktnuuint64_t m = dword_100158C40;
    if (mDNS_McastLoggingEnabled) {
      LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "--- MCOUNT[%d]: IMPKTNUM[%d] ---",  a4,  a5,  a6,  a7,  a8,  0);
    }
    goto LABEL_43;
  }

  uint64_t v14 = all_requests;
  if (!all_requests)
  {
    if (!mDNS_McastLoggingEnabled) {
      return;
    }
    uint64_t v18 = (os_log_s *)mDNSLogCategory_Default;
    uint64_t v19 = "<None>";
    goto LABEL_48;
  }

  do
  {
    uint64_t v15 = *(void *)(v14 + 24);
    if (v15)
    {
      for (uint64_t j = all_requests; j && j != v14; uint64_t j = *(void *)(j + 16))
      {
        if (j == v15) {
          goto LABEL_32;
        }
      }
    }

    GetMcastClients(v14);
LABEL_32:
    uint64_t v14 = *(void *)(v14 + 16);
  }

  while (v14);
  if (mDNS_McastLoggingEnabled) {
    LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "--- MCAST RECORDS COUNT[%d] MCAST QUESTIONS COUNT[%d] ---",  a4,  a5,  a6,  a7,  a8,  n_mrecords);
  }
  n_mquests = 0;
  n_mrecords = 0;
}

uint64_t GetMcastClients(uint64_t result)
{
  uint64_t v1 = result;
  uint64_t v2 = *(void (**)(uint64_t))(result + 96);
  if (v2 == connection_termination)
  {
    for (uint64_t i = *(void *)(result + 160); i; uint64_t i = *(void *)(i + 8))
    {
      uint64_t v4 = *(void *)(i + 24);
      if (!*(void *)(v4 + 32) && !*(_BYTE *)(v4 + 122))
      {
        uint64_t result = IsLocalDomain(*(_BYTE **)(v4 + 40));
        if (!(_DWORD)result) {
          continue;
        }
      }

      ++n_mrecords;
    }

    for (uint64_t j = *(void *)(v1 + 16); j; uint64_t j = *(void *)(j + 16))
    {
      if (*(void *)(j + 24) == v1) {
        uint64_t result = GetMcastClients(j);
      }
    }
  }

  else if ((char *)v2 == (char *)regservice_termination_callback)
  {
    for (CFIndex k = *(uint64_t **)(*(void *)(result + 112) + 1624LL); k; CFIndex k = (uint64_t *)*k)
    {
      if (!k[341] && !*((_BYTE *)k + 2818))
      {
        uint64_t result = IsLocalDomain((_BYTE *)k[342]);
        if (!(_DWORD)result) {
          continue;
        }
      }

      ++n_mrecords;
    }
  }

  else if ((char *)v2 == (char *)browse_termination_callback)
  {
    uint64_t v7 = *(uint64_t **)(*(void *)(result + 136) + 272LL);
    if (v7)
    {
      int v8 = n_mquests;
      do
      {
        if (!*((_WORD *)v7 + 292)) {
          n_mquests = ++v8;
        }
        uint64_t v7 = (uint64_t *)*v7;
      }

      while (v7);
    }
  }

  else if (v2 == resolve_termination_callback)
  {
    uint64_t v9 = *(void *)(result + 120);
  }

  else
  {
    if (v2 != queryrecord_termination_callback)
    {
      if (v2 != addrinfo_termination_callback) {
        return result;
      }
      uint64_t result = GetAddrInfoClientRequestIsMulticast(*(void *)(result + 152));
      if (!(_DWORD)result) {
        return result;
      }
LABEL_38:
      ++n_mquests;
      return result;
    }

    uint64_t v10 = *(void *)(result + 128);
  }

  return result;
}

void LogMcastClientInfo( void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9)
{
  uint64_t v9 = (void (*)(uint64_t))a1[12];
  if (v9)
  {
    if (v9 != connection_termination)
    {
      if ((char *)v9 != (char *)regservice_termination_callback)
      {
        if ((char *)v9 == (char *)browse_termination_callback)
        {
          uint64_t v32 = *(uint64_t **)(a1[17] + 272LL);
          if (v32)
          {
            int v33 = mDNS_McastLoggingEnabled;
            do
            {
              if (*((_WORD *)v32 + 292)) {
                BOOL v34 = 1;
              }
              else {
                BOOL v34 = v33 == 0;
              }
              if (!v34)
              {
                int v35 = (os_log_s *)mDNSLogCategory_Default;
                DNSTypeName(*((unsigned __int16 *)v32 + 293));
                ++i_mcount;
                LogMsgWithLevel( v35,  OS_LOG_TYPE_DEFAULT,  "Q: DNSServiceBrowse  %##s %s PID[%d](%s)",  v36,  v37,  v38,  v39,  v40,  (_DWORD)v32 + 620);
                int v33 = mDNS_McastLoggingEnabled;
              }

              uint64_t v32 = (uint64_t *)*v32;
            }

            while (v32);
          }
        }

        else if (v9 == resolve_termination_callback)
        {
          uint64_t v41 = a1[15];
          if (!*(_WORD *)(v41 + 976) && *(int *)(v41 + 868) >= 1 && mDNS_McastLoggingEnabled != 0)
          {
            unsigned int v43 = (os_log_s *)mDNSLogCategory_Default;
            int v44 = v41 + 1012;
            DNSTypeName(*(unsigned __int16 *)(v41 + 978));
            ++i_mcount;
            LogMsgWithLevel( v43,  OS_LOG_TYPE_DEFAULT,  "Q: DNSServiceResolve  %##s %s PID[%d](%s)",  v45,  v46,  v47,  v48,  v49,  v44);
          }
        }

        else if (v9 == queryrecord_termination_callback)
        {
          uint64_t v50 = a1[16];
          if (!*(_WORD *)(v50 + 320) && *(int *)(v50 + 212) >= 1 && mDNS_McastLoggingEnabled != 0)
          {
            uint64_t v52 = (os_log_s *)mDNSLogCategory_Default;
            int v53 = v50 + 356;
            DNSTypeName(*(unsigned __int16 *)(v50 + 322));
            ++i_mcount;
            LogMsgWithLevel( v52,  OS_LOG_TYPE_DEFAULT,  "Q: DNSServiceQueryRecord  %##s %s PID[%d](%s)",  v54,  v55,  v56,  v57,  v58,  v53);
          }
        }

        else if (v9 == addrinfo_termination_callback)
        {
          uint64_t v11 = a1[19];
          if (GetAddrInfoClientRequestIsMulticast(v11))
          {
            if (mDNS_McastLoggingEnabled)
            {
              uint64_t v17 = "v4";
              if ((*(_DWORD *)(v11 + 8) & 1) == 0) {
                uint64_t v17 = "  ";
              }
              ++i_mcount;
              LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "Q: DNSServiceGetAddrInfo  %s%s %##s PID[%d](%s)",  v12,  v13,  v14,  v15,  v16,  (int)v17);
            }
          }
        }

        return;
      }

      CFIndex v29 = *(uint64_t **)(a1[14] + 1624LL);
      if (!v29) {
        return;
      }
      while (v29[341] || *((_BYTE *)v29 + 2818))
      {
        if (mDNS_McastLoggingEnabled) {
          goto LABEL_36;
        }
LABEL_37:
        CFIndex v29 = (uint64_t *)*v29;
        if (!v29) {
          return;
        }
      }

      if (!IsLocalDomain((_BYTE *)v29[342]) || mDNS_McastLoggingEnabled == 0) {
        goto LABEL_37;
      }
LABEL_36:
      uint64_t v30 = v29[342];
      ++i_mcount;
      LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "R: DNSServiceRegister:  %##s %u/%u PID[%d](%s)",  a4,  a5,  a6,  a7,  a8,  v30);
      goto LABEL_37;
    }

    uint64_t v18 = a1[20];
    if (v18)
    {
      while (1)
      {
        uint64_t v19 = *(void *)(v18 + 24);
        if (!*(void *)(v19 + 32) && !*(_BYTE *)(v19 + 122)) {
          break;
        }
        if (mDNS_McastLoggingEnabled) {
          goto LABEL_19;
        }
LABEL_20:
        uint64_t v18 = *(void *)(v18 + 8);
        if (!v18) {
          goto LABEL_27;
        }
      }

      if (!IsLocalDomain(*(_BYTE **)(v19 + 40)) || mDNS_McastLoggingEnabled == 0) {
        goto LABEL_20;
      }
      uint64_t v19 = *(void *)(v18 + 24);
LABEL_19:
      int v20 = (os_log_s *)mDNSLogCategory_Default;
      uint64_t v21 = *(void *)(v19 + 40);
      DNSTypeName(*(unsigned __int16 *)(v19 + 12));
      ++i_mcount;
      LogMsgWithLevel( v20,  OS_LOG_TYPE_DEFAULT,  "R: ->  DNSServiceRegisterRecord:  %##s %s PID[%d](%s)",  v22,  v23,  v24,  v25,  v26,  v21);
      goto LABEL_20;
    }

void regservice_termination_callback( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9)
{
  if (a1)
  {
    uint64_t v10 = *(void *)(a1 + 112);
    uint64_t v11 = *(void **)(v10 + 1624);
    if (v11)
    {
      uint64_t v12 = (int *)(a1 + 188);
      uint64_t v13 = (_DWORD *)(a1 + 192);
      uint64_t v14 = (const char *)(a1 + 240);
      __int16 v101 = (unsigned __int8 *)(v10 + 1099);
      uint64_t v15 = &unk_100164000;
      int v91 = 67109376;
      unsigned __int16 v98 = (int *)(a1 + 188);
      uint64_t v99 = *(void *)(a1 + 112);
      int v97 = (_DWORD *)(a1 + 192);
      int v100 = (const char *)(a1 + 240);
      do
      {
        *(void *)(v10 + 16memset(&v5[1], 0, 24) = *v11;
        BOOL shouldLogFullRequestInfo = _shouldLogFullRequestInfo(v12, v13);
        uint64_t v17 = (unsigned __int8 *)v11[342];
        uint64_t v18 = v17 + 1;
        uint64_t v19 = (uint64_t)&v17[*v17 + 1];
        if (!*v17) {
          uint64_t v19 = v11[342];
        }
        char v20 = v15[1384];
        uint64_t v21 = mDNSLogCategory_mDNS;
        if (mDNSLogCategory_mDNS == mDNSLogCategory_State) {
          char v20 = 0;
        }
        if (shouldLogFullRequestInfo)
        {
          if (v19)
          {
            if ((v20 & 1) != 0)
            {
              uint64_t v22 = mDNSLogCategory_mDNS_redacted;
              if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
              {
                int v94 = *(_DWORD *)(a1 + 184);
                uint64_t v30 = v17;
LABEL_13:
                unsigned __int16 v31 = 257;
                if (v30 < v17 + 256 && v30)
                {
                  while (1)
                  {
                    uint64_t v32 = *v30;
                    if (v32 > 0x3F)
                    {
LABEL_68:
                      unsigned __int16 v31 = 257;
                      goto LABEL_71;
                    }

                    if (!*v30) {
                      break;
                    }
                    v30 += v32 + 1;
LABEL_16:
                    if (!v30) {
                      goto LABEL_68;
                    }
                  }

                  unsigned __int16 v31 = (_WORD)v30 - (_WORD)v17 + 1;
                }

void browse_termination_callback( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = *(void *)(a1 + 136);
  uint64_t v10 = &unk_100164000;
  uint64_t v11 = &unk_100150000;
  uint64_t v12 = (os_log_s **)&unk_100164000;
  if (!*(_BYTE *)(v9 + 8)) {
    goto LABEL_24;
  }
  BOOL shouldLogFullRequestInfo = _shouldLogFullRequestInfo((int *)(a1 + 188), (_DWORD *)(a1 + 192));
  char v14 = gSensitiveLoggingEnabled;
  uint64_t v15 = mDNSLogCategory_mDNS;
  if (mDNSLogCategory_mDNS == mDNSLogCategory_State) {
    char v14 = 0;
  }
  if (!shouldLogFullRequestInfo)
  {
    if ((v14 & 1) != 0)
    {
      uint64_t v15 = mDNSLogCategory_mDNS_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_16;
      }
    }

    else if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
    {
      goto LABEL_16;
    }

    int v31 = *(_DWORD *)(a1 + 184);
    __tp[0].int tv_sec = 0LL;
    __tp[0].tv_nsec = 0LL;
    clock_gettime(_CLOCK_MONOTONIC_RAW, __tp);
    int v32 = LODWORD(__tp[0].tv_sec) - *(_DWORD *)(a1 + 188);
    LODWORD(__tp[0].tv_sec) = 67109376;
    HIDWORD(__tp[0].tv_sec) = v31;
    LOWORD(__tp[0].tv_nsec) = 1024;
    *(_DWORD *)((char *)&__tp[0].tv_nsec + 2) = v32;
    uint64_t v28 = "[R%u] DNSServiceBrowse Cancel domain enumeration for WAB and mDNS -- , duration: %{mdns:time_duration}u";
    uint64_t v29 = (os_log_s *)v15;
    uint32_t v30 = 14;
    goto LABEL_15;
  }

  if ((v14 & 1) != 0)
  {
    uint64_t v15 = mDNSLogCategory_mDNS_redacted;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_12;
    }
  }

  else if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
  {
LABEL_12:
    int v23 = *(_DWORD *)(a1 + 184);
    int v24 = *(_DWORD *)(a1 + 232);
    int v25 = *(_DWORD *)(a1 + 236);
    int v26 = *(_DWORD *)(a1 + 172);
    __tp[0].int tv_sec = 0LL;
    __tp[0].tv_nsec = 0LL;
    clock_gettime(_CLOCK_MONOTONIC_RAW, __tp);
    int v27 = LODWORD(__tp[0].tv_sec) - *(_DWORD *)(a1 + 188);
    LODWORD(__tp[0].tv_sec) = 67110402;
    HIDWORD(__tp[0].tv_sec) = v23;
    LOWORD(__tp[0].tv_nsec) = 1024;
    *(_DWORD *)((char *)&__tp[0].tv_nsec + 2) = v24;
    uint64_t v11 = &unk_100150000;
    HIWORD(__tp[0].tv_nsec) = 1024;
    LODWORD(__tp[1].tv_sec) = v25;
    uint64_t v12 = (os_log_s **)&unk_100164000;
    WORD2(__tp[1].tv_sec) = 1024;
    *(_DWORD *)((char *)&__tp[1].tv_sec + 6) = v26;
    WORD1(__tp[1].tv_nsec) = 2082;
    *(uint64_t *)((char *)&__tp[1].tv_nsec + 4) = a1 + 240;
    WORD2(__tp[2].tv_sec) = 1024;
    *(_DWORD *)((char *)&__tp[2].tv_sec + 6) = v27;
    uint64_t v28 = "[R%u] DNSServiceBrowse Cancel domain enumeration for WAB and mDNS -- , flags: 0x%X, interface index: %d, clien"
          "t pid: %d (%{public}s), , duration: %{mdns:time_duration}u";
    uint64_t v29 = (os_log_s *)v15;
    uint32_t v30 = 42;
LABEL_15:
    _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, v28, (uint8_t *)__tp, v30);
  }

void resolve_termination_callback(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 120);
  BOOL shouldLogFullRequestInfo = _shouldLogFullRequestInfo((int *)(a1 + 188), (_DWORD *)(a1 + 192));
  __int16 v4 = v2 + 356;
  char v5 = gSensitiveLoggingEnabled;
  uint64_t v6 = (os_log_s *)mDNSLogCategory_mDNS;
  if (mDNSLogCategory_mDNS == mDNSLogCategory_State) {
    char v5 = 0;
  }
  if (shouldLogFullRequestInfo)
  {
    if ((v5 & 1) != 0)
    {
      uint64_t v6 = (os_log_s *)mDNSLogCategory_mDNS_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_33;
      }
      int v7 = *(_DWORD *)(a1 + 184);
      int v8 = (_BYTE *)(v2 + 356);
      if (v2 == -612)
      {
LABEL_8:
        while (v8)
        {
          uint64_t v9 = *v8;
          if (!*v8)
          {
            unsigned __int16 v16 = (_WORD)v8 - v4 + 1;
            goto LABEL_29;
          }

          v8 += v9 + 1;
          if (v2 != -612) {
            goto LABEL_7;
          }
        }
      }

      else
      {
LABEL_7:
      }

      unsigned __int16 v16 = 257;
LABEL_29:
      int v18 = v16;
      int v19 = *(_DWORD *)(a1 + 232);
      int v20 = *(_DWORD *)(a1 + 236);
      int v21 = *(_DWORD *)(a1 + 172);
      int v22 = mDNS_DomainNameFNV1aHash((unsigned __int8 *)(v2 + 356));
      *(void *)__tp = 0LL;
      *(void *)&__tp[8] = 0LL;
      clock_gettime(_CLOCK_MONOTONIC_RAW, (timespec *)__tp);
      int v23 = *(_DWORD *)__tp - *(_DWORD *)(a1 + 188);
      *(_DWORD *)__tp = 67111427;
      *(_DWORD *)&__tp[4] = v7;
      *(_WORD *)&__tp[8] = 2160;
      *(void *)&__tp[10] = 1752392040LL;
      *(_WORD *)&__tp[18] = 1040;
      *(_DWORD *)&_BYTE __tp[20] = v18;
      *(_WORD *)&__tp[24] = 2101;
      *(void *)&__tp[26] = v2 + 356;
      *(_WORD *)&__tp[34] = 1024;
      *(_DWORD *)&__tp[36] = v19;
      *(_WORD *)&__tp[40] = 1024;
      *(_DWORD *)&__tp[42] = v20;
      *(_WORD *)&__tp[46] = 1024;
      LODWORD(v69) = v21;
      WORD2(v69) = 2082;
      *(void *)((char *)&v69 + 6) = a1 + 240;
      HIWORD(v69) = 1024;
      LODWORD(v70) = v22;
      WORD2(v70) = 1024;
      *(_DWORD *)((char *)&v70 + 6) = v23;
    }

    else
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_33;
      }
      int v10 = *(_DWORD *)(a1 + 184);
      uint64_t v11 = (_BYTE *)(v2 + 356);
      if (v2 == -612)
      {
LABEL_19:
        while (v11)
        {
          uint64_t v12 = *v11;
          if (!*v11)
          {
            unsigned __int16 v17 = (_WORD)v11 - v4 + 1;
            goto LABEL_31;
          }

          v11 += v12 + 1;
          if (v2 != -612) {
            goto LABEL_18;
          }
        }
      }

      else
      {
LABEL_18:
      }

      unsigned __int16 v17 = 257;
LABEL_31:
      int v24 = v17;
      int v26 = *(_DWORD *)(a1 + 232);
      int v25 = *(_DWORD *)(a1 + 236);
      int v27 = *(_DWORD *)(a1 + 172);
      int v28 = mDNS_DomainNameFNV1aHash((unsigned __int8 *)(v2 + 356));
      *(void *)__tp = 0LL;
      *(void *)&__tp[8] = 0LL;
      clock_gettime(_CLOCK_MONOTONIC_RAW, (timespec *)__tp);
      int v29 = *(_DWORD *)__tp - *(_DWORD *)(a1 + 188);
      *(_DWORD *)__tp = 67111427;
      *(_DWORD *)&__tp[4] = v10;
      *(_WORD *)&__tp[8] = 2160;
      *(void *)&__tp[10] = 1752392040LL;
      *(_WORD *)&__tp[18] = 1040;
      *(_DWORD *)&_BYTE __tp[20] = v24;
      *(_WORD *)&__tp[24] = 2101;
      *(void *)&__tp[26] = v2 + 356;
      *(_WORD *)&__tp[34] = 1024;
      *(_DWORD *)&__tp[36] = v26;
      *(_WORD *)&__tp[40] = 1024;
      *(_DWORD *)&__tp[42] = v25;
      *(_WORD *)&__tp[46] = 1024;
      LODWORD(v69) = v27;
      WORD2(v69) = 2082;
      *(void *)((char *)&v69 + 6) = a1 + 240;
      HIWORD(v69) = 1024;
      LODWORD(v70) = v28;
      WORD2(v70) = 1024;
      *(_DWORD *)((char *)&v70 + 6) = v29;
    }

    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "[R%u] DNSServiceResolve STOP -- SRV name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P, flags: 0x%X, inte rface index: %d, client pid: %d (%{public}s), name hash: %x, duration: %{mdns:time_duration}u",  __tp,  0x4Au);
  }

  else
  {
    if ((v5 & 1) != 0)
    {
      uint64_t v6 = (os_log_s *)mDNSLogCategory_mDNS_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_33;
      }
    }

    else if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
    {
      goto LABEL_33;
    }

    int v13 = *(_DWORD *)(a1 + 184);
    int v14 = mDNS_DomainNameFNV1aHash((unsigned __int8 *)(v2 + 356));
    *(void *)__tp = 0LL;
    *(void *)&__tp[8] = 0LL;
    clock_gettime(_CLOCK_MONOTONIC_RAW, (timespec *)__tp);
    int v15 = *(_DWORD *)__tp - *(_DWORD *)(a1 + 188);
    *(_DWORD *)__tp = 67109632;
    *(_DWORD *)&__tp[4] = v13;
    *(_WORD *)&__tp[8] = 1024;
    *(_DWORD *)&__tp[10] = v14;
    *(_WORD *)&__tp[14] = 1024;
    *(_DWORD *)&__tp[16] = v15;
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "[R%u] DNSServiceResolve STOP -- name hash: %x, duration: %{mdns:time_duration}u",  __tp,  0x14u);
  }

void addrinfo_termination_callback(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 152);
  uint64_t v3 = (_DWORD *)(a1 + 188);
  BOOL shouldLogFullRequestInfo = _shouldLogFullRequestInfo((int *)(a1 + 188), (_DWORD *)(a1 + 192));
  char v5 = gSensitiveLoggingEnabled;
  uint64_t v6 = mDNSLogCategory_Default;
  if (mDNSLogCategory_Default == mDNSLogCategory_State) {
    char v5 = 0;
  }
  if (shouldLogFullRequestInfo)
  {
    if ((v5 & 1) != 0)
    {
      uint64_t v6 = mDNSLogCategory_Default_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_67;
      }
      uint64_t v14 = *(void *)(v2 + 16);
      if (v14)
      {
        int v15 = (const char *)(v14 + 356);
      }

      else
      {
        uint64_t v22 = *(void *)(v2 + 24);
        if (v22) {
          int v15 = (const char *)(v22 + 356);
        }
        else {
          int v15 = "";
        }
      }

      int v49 = *(_DWORD *)(a1 + 184);
      int v23 = v15;
      int v24 = 257;
LABEL_22:
      if (v23 < v15 + 256 && v23)
      {
        while (1)
        {
          uint64_t v25 = *(unsigned __int8 *)v23;
          if (v25 > 0x3F)
          {
LABEL_30:
            int v24 = 257;
            goto LABEL_31;
          }

          if (!*v23) {
            break;
          }
          v23 += v25 + 1;
LABEL_25:
          if (!v23) {
            goto LABEL_30;
          }
        }

        int v24 = (unsigned __int16)((_WORD)v23 - (_WORD)v15 + 1);
        if (v14) {
          goto LABEL_32;
        }
      }

      else
      {
LABEL_31:
        if (v14)
        {
LABEL_32:
          int v26 = (unsigned __int8 *)(v14 + 356);
          int v27 = *(_DWORD *)(a1 + 236);
          int v48 = *(_DWORD *)(a1 + 232);
          uint64_t v28 = a1 + 240;
          int v29 = *(_DWORD *)(a1 + 172);
LABEL_58:
          int v35 = mDNS_DomainNameFNV1aHash(v26);
          *(void *)__tp = 0LL;
          *(void *)&__tp[8] = 0LL;
          clock_gettime(_CLOCK_MONOTONIC_RAW, (timespec *)__tp);
          int v36 = *(_DWORD *)__tp - *v3;
          *(_DWORD *)__tp = 67111427;
          *(_DWORD *)&__tp[4] = v49;
          *(_WORD *)&__tp[8] = 2160;
          *(void *)&__tp[10] = 1752392040LL;
          *(_WORD *)&__tp[18] = 1040;
          int v51 = v24;
          __int16 v52 = 2101;
          uint64_t v53 = v26;
          __int16 v54 = 1024;
          int v55 = v48;
          __int16 v56 = 1024;
          int v57 = v27;
          __int16 v58 = 1024;
          int v59 = v29;
          __int16 v60 = 2082;
          uint64_t v61 = v28;
          __int16 v62 = 1024;
          int v63 = v35;
          __int16 v64 = 1024;
          int v65 = v36;
          uint64_t v37 = "[R%u] DNSServiceGetAddrInfo STOP -- hostname: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P, fla"
                "gs: 0x%X, interface index: %d, client pid: %d (%{public}s), name hash: %x, duration: %{mdns:time_duration}u";
          uint64_t v38 = (os_log_s *)v6;
          uint32_t v39 = 74;
          goto LABEL_66;
        }
      }

      uint64_t v33 = *(void *)(v2 + 24);
      if (v33) {
        int v26 = (unsigned __int8 *)(v33 + 356);
      }
      else {
        int v26 = "";
      }
      int v27 = *(_DWORD *)(a1 + 236);
      int v48 = *(_DWORD *)(a1 + 232);
      int v29 = *(_DWORD *)(a1 + 172);
      uint64_t v28 = a1 + 240;
      goto LABEL_58;
    }

    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_67;
    }
    uint64_t v19 = *(void *)(v2 + 16);
    if (v19)
    {
      int v20 = (const char *)(v19 + 356);
    }

    else
    {
      uint64_t v30 = *(void *)(v2 + 24);
      if (v30) {
        int v20 = (const char *)(v30 + 356);
      }
      else {
        int v20 = "";
      }
    }

    int v49 = *(_DWORD *)(a1 + 184);
    __int16 v31 = v20;
    int v24 = 257;
LABEL_37:
    if (v31 < v20 + 256 && v31)
    {
      while (1)
      {
        uint64_t v32 = *(unsigned __int8 *)v31;
        if (v32 > 0x3F)
        {
LABEL_45:
          int v24 = 257;
          goto LABEL_46;
        }

        if (!*v31) {
          break;
        }
        v31 += v32 + 1;
LABEL_40:
        if (!v31) {
          goto LABEL_45;
        }
      }

      int v24 = (unsigned __int16)((_WORD)v31 - (_WORD)v20 + 1);
      if (v19) {
        goto LABEL_47;
      }
    }

    else
    {
LABEL_46:
      if (v19)
      {
LABEL_47:
        int v26 = (unsigned __int8 *)(v19 + 356);
        int v27 = *(_DWORD *)(a1 + 236);
        int v48 = *(_DWORD *)(a1 + 232);
        uint64_t v28 = a1 + 240;
        int v29 = *(_DWORD *)(a1 + 172);
        goto LABEL_58;
      }
    }

    uint64_t v34 = *(void *)(v2 + 24);
    if (v34) {
      int v26 = (unsigned __int8 *)(v34 + 356);
    }
    else {
      int v26 = "";
    }
    int v27 = *(_DWORD *)(a1 + 236);
    int v48 = *(_DWORD *)(a1 + 232);
    int v29 = *(_DWORD *)(a1 + 172);
    uint64_t v28 = a1 + 240;
    goto LABEL_58;
  }

  if ((v5 & 1) != 0)
  {
    uint64_t v6 = mDNSLogCategory_Default_redacted;
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_67;
    }
    int v16 = *(_DWORD *)(a1 + 184);
    uint64_t v17 = *(void *)(v2 + 16);
    if (v17)
    {
      int v18 = (unsigned __int8 *)(v17 + 356);
    }

    else
    {
      uint64_t v40 = *(void *)(v2 + 24);
      if (v40) {
        int v18 = (unsigned __int8 *)(v40 + 356);
      }
      else {
        int v18 = "";
      }
    }
  }

  else
  {
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_67;
    }
    int v16 = *(_DWORD *)(a1 + 184);
    uint64_t v21 = *(void *)(v2 + 16);
    if (v21)
    {
      int v18 = (unsigned __int8 *)(v21 + 356);
    }

    else
    {
      uint64_t v41 = *(void *)(v2 + 24);
      if (v41) {
        int v18 = (unsigned __int8 *)(v41 + 356);
      }
      else {
        int v18 = "";
      }
    }
  }

  int v42 = mDNS_DomainNameFNV1aHash(v18);
  *(void *)__tp = 0LL;
  *(void *)&__tp[8] = 0LL;
  clock_gettime(_CLOCK_MONOTONIC_RAW, (timespec *)__tp);
  int v43 = *(_DWORD *)__tp - *v3;
  *(_DWORD *)__tp = 67109632;
  *(_DWORD *)&__tp[4] = v16;
  *(_WORD *)&__tp[8] = 1024;
  *(_DWORD *)&__tp[10] = v42;
  *(_WORD *)&__tp[14] = 1024;
  *(_DWORD *)&__tp[16] = v43;
  uint64_t v37 = "[R%u] DNSServiceGetAddrInfo STOP -- name hash: %x, duration: %{mdns:time_duration}u";
  uint64_t v38 = (os_log_s *)v6;
  uint32_t v39 = 20;
LABEL_66:
  _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_DEFAULT, v37, __tp, v39);
LABEL_67:
  GetAddrInfoClientRequestStop(v2, v7, v8, v9, v10, v11, v12, v13);
  uint64_t v44 = *(void *)(a1 + 8);
  if (v44)
  {
    uint64_t v45 = *(unsigned int *)(a1 + 236);
    if ((_DWORD)v45)
    {
      if (AWDLInterfaceID && AWDLInterfaceID == v45)
      {
        int v46 = 1;
      }

      else
      {
        if (WiFiAwareInterfaceID) {
          BOOL v47 = WiFiAwareInterfaceID == v45;
        }
        else {
          BOOL v47 = 0;
        }
        int v46 = v47;
      }
    }

    else
    {
      int v46 = (*(unsigned __int8 *)(a1 + 234) >> 4) & 1;
    }

    _mdns_powerlog_bonjour_event(6u, v46, (const char *)(a1 + 240), 0LL, v44);
    *(void *)(a1 + _Block_object_dispose(va, 8) = 0LL;
  }

BOOL _shouldLogFullRequestInfo(int *a1, _DWORD *a2)
{
  int v4 = *a1;
  v7.int tv_sec = 0LL;
  v7.tv_nsec = 0LL;
  clock_gettime(_CLOCK_MONOTONIC_RAW, &v7);
  int tv_sec = v7.tv_sec;
  if (v4)
  {
    BOOL result = LODWORD(v7.tv_sec) - v4 > 299;
    if (!a2) {
      return result;
    }
  }

  else
  {
    v7.int tv_sec = 0LL;
    v7.tv_nsec = 0LL;
    clock_gettime(_CLOCK_MONOTONIC_RAW, &v7);
    *a1 = v7.tv_sec;
    BOOL result = 1LL;
    if (!a2) {
      return result;
    }
  }

  if (result) {
    *a2 = tv_sec;
  }
  return result;
}

uint64_t LogMcastQuestion(uint64_t result, uint64_t a2, int a3)
{
  if (!*(_WORD *)(result + 320))
  {
    if (a3 == 1) {
      int v3 = 1;
    }
    else {
      int v3 = -1;
    }
    if (mcount) {
      BOOL v4 = 0LL;
    }
    else {
      BOOL v4 = a3 == 1;
    }
    mcount += v3;
    if (mDNS_McastLoggingEnabled)
    {
      uint64_t v5 = result;
      uint64_t v6 = (os_log_s *)mDNSLogCategory_Default;
      if (a3) {
        timespec v7 = "+Question";
      }
      else {
        timespec v7 = "-Question";
      }
      DNSTypeName(*(unsigned __int16 *)(result + 322));
      uint64_t v13 = *(void *)(v5 + 136);
      if ((unint64_t)(v13 + 5) >= 6 || ((0x2Du >> (v13 + 5)) & 1) == 0)
      {
        uint64_t v14 = &xmmword_10015BD30;
        do
          uint64_t v14 = *(__int128 **)v14;
        while (v14 && *((void *)v14 + 782) != v13);
      }

      LogMsgWithLevel(v6, OS_LOG_TYPE_DEFAULT, "%s: %##s  (%s) (%s)  Client(%d)[%s]", v8, v9, v10, v11, v12, (int)v7);
    }

    return LogMcastStateInfo(v4, 0LL, 0LL);
  }

  return result;
}

void external_stop_advertising_helper( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(_BYTE *)(a1 + 27))
  {
    uint64_t v9 = *(void *)(a1 + 16);
    if (mDNS_LoggingEnabled == 1) {
      LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "external_stop_advertising_helper: calling external_stop_advertising_service",  a4,  a5,  a6,  a7,  a8,  v15);
    }
    uint64_t v10 = *(void *)(a1 + 8);
    if (v10)
    {
      unsigned int v11 = *(_DWORD *)(v10 + 172);
      if (*(_DWORD *)(*(void *)(v10 + 112) + 1616LL))
      {
        unint64_t v12 = 0LL;
        uint64_t v13 = v9 + 8;
        do
        {
          internal_stop_advertising_service(v13, *(_DWORD *)(v10 + 232), v11);
          ++v12;
          uint64_t v10 = *(void *)(a1 + 8);
          v13 += 1176LL;
        }

        while (v12 < *(unsigned int *)(*(void *)(v10 + 112) + 1616LL));
      }

      internal_stop_advertising_service(a1 + 1528, *(_DWORD *)(v10 + 232), v11);
      internal_stop_advertising_service(a1 + 2704, *(_DWORD *)(*(void *)(a1 + 8) + 232LL), v11);
      internal_stop_advertising_service(a1 + 3880, *(_DWORD *)(*(void *)(a1 + 8) + 232LL), v11);
      for (uint64_t i = *(void **)(a1 + 312); i; uint64_t i = (void *)*i)

        internal_stop_advertising_service((uint64_t)(i + 3), *(_DWORD *)(*(void *)(a1 + 8) + 232LL), v11);
    }

    *(_BYTE *)(a1 + 27) = 0;
  }

void LogMcastService( uint64_t a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9)
{
  if (*(void *)(a1 + 32) || *(_BYTE *)(a1 + 122) || IsLocalDomain(*(_BYTE **)(a1 + 40)))
  {
    if (a3 == 1) {
      int v11 = 1;
    }
    else {
      int v11 = -1;
    }
    if (mcount) {
      BOOL v12 = 0;
    }
    else {
      BOOL v12 = a3 == 1;
    }
    mcount += v11;
    if (mDNS_McastLoggingEnabled)
    {
      uint64_t v13 = (os_log_s *)mDNSLogCategory_Default;
      if (a3) {
        uint64_t v14 = "+Service";
      }
      else {
        uint64_t v14 = "-Service";
      }
      DNSTypeName(*(unsigned __int16 *)(a1 + 12));
      uint64_t v20 = *(void *)(a1 + 32);
      if ((unint64_t)(v20 + 5) >= 6 || ((0x2Du >> (v20 + 5)) & 1) == 0)
      {
        uint64_t v21 = &xmmword_10015BD30;
        do
          uint64_t v21 = *(__int128 **)v21;
        while (v21 && *((void *)v21 + 782) != v20);
      }

      LogMsgWithLevel( v13,  OS_LOG_TYPE_DEFAULT,  "%s: %##s  (%s)  (%s)  Client(%d)[%s]",  v15,  v16,  v17,  v18,  v19,  (int)v14);
    }

    LogMcastStateInfo(v12, 0LL, 0LL, a4, a5, a6, a7, a8, a9);
  }

void unlink_and_free_service_instance( void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = (void *)a1[39];
  external_stop_advertising_helper((uint64_t)a1, a2, a3, a4, a5, a6, a7, a8);
  uint64_t v15 = a1[1];
  if (v15)
  {
    uint64_t v16 = (void *)(*(void *)(v15 + 112) + 1624LL);
    while (1)
    {
      uint64_t v17 = v16;
      uint64_t v16 = (void *)*v16;
      if (!v16) {
        break;
      }
      if (v16 == a1)
      {
        void *v17 = *a1;
        break;
      }
    }
  }

  while (v9)
  {
    uint64_t v18 = (uint64_t)(v9 + 2);
    _OWORD v9[16] = v9;
    uint64_t v9 = (void *)*v9;
    FreeExtraRR((uint64_t)mDNSStorage, v18, -65792, v10, v11, v12, v13, v14);
  }

  uint64_t v19 = (char *)a1[490];
  if (v19 != (char *)a1 + 4780 && v19 != 0LL)
  {
    free(v19);
    a1[490] = 0LL;
  }

  uint64_t v21 = (void *)a1[2];
  if (v21) {
    free(v21);
  }
  free(a1);
}

void FreeExtraRR(uint64_t a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a3 == -65792)
  {
    uint64_t v9 = *(void **)(a2 + 112);
    if (mDNS_LoggingEnabled == 1)
    {
      uint64_t v10 = (os_log_s *)mDNSLogCategory_Default;
      int v11 = a1 + 46976;
      GetRRDisplayString_rdb( (unsigned __int8 *)(a2 + 8),  (unsigned __int16 *)(*(void *)(a2 + 48) + 4LL),  (_BYTE *)(a1 + 46976));
      LogMsgWithLevel(v10, OS_LOG_TYPE_DEFAULT, "     FreeExtraRR %s", v12, v13, v14, v15, v16, v11);
    }

    uint64_t v17 = *(void **)(a2 + 48);
    if (v17 != (void *)(a2 + 908) && v17 != 0LL)
    {
      free(v17);
      *(void *)(a2 + 4_Block_object_dispose(va, 8) = 0LL;
    }

    if (v9) {
      free(v9);
    }
  }

  else
  {
    LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "Error: FreeExtraRR invoked with unexpected error %d",  a4,  a5,  a6,  a7,  a8,  a3);
  }

void request_state_forget(void **a1)
{
  uint64_t v1 = *a1;
  if (*a1)
  {
    int v3 = (void *)v1[13];
    if (v3)
    {
      free(v3);
      v1[13] = 0LL;
    }

    BOOL v4 = (void *)v1[14];
    if (v4)
    {
      free(v4);
      v1[14] = 0LL;
    }

    uint64_t v5 = (void *)v1[15];
    if (v5)
    {
      uint64_t v6 = (void *)v5[164];
      if (v6)
      {
        free(v6);
        v5[164] = 0LL;
      }

      timespec v7 = (void *)v5[165];
      if (v7) {
        free(v7);
      }
      free(v5);
      v1[15] = 0LL;
    }

    uint64_t v8 = (void *)v1[16];
    if (v8)
    {
      free(v8);
      v1[16] = 0LL;
    }

    uint64_t v9 = (void *)v1[17];
    if (v9)
    {
      free(v9);
      v1[17] = 0LL;
    }

    uint64_t v10 = (void *)v1[18];
    if (v10)
    {
      free(v10);
      v1[18] = 0LL;
    }

    int v11 = (void *)v1[19];
    if (v11)
    {
      free(v11);
      v1[19] = 0LL;
    }

    uint64_t v12 = (void *)v1[4];
    if (v12)
    {
      os_release(v12);
      v1[4] = 0LL;
    }

    uint64_t v13 = (void *)v1[6];
    if (v13) {
      os_release(v13);
    }
    free(v1);
    *a1 = 0LL;
  }

uint64_t CountExistingRegistrations(_BYTE *a1, unsigned __int16 a2)
{
  uint64_t v2 = (uint64_t *)xmmword_10015BD08;
  if (!(void)xmmword_10015BD08) {
    return 0LL;
  }
  uint64_t v4 = 0LL;
  int v5 = a2;
  do
  {
    uint64_t v2 = (uint64_t *)*v2;
  }

  while (v2);
  return v4;
}

uint64_t DeregisterLocalOnlyDomainEnumPTR_Internal( unsigned int *a1, _BYTE *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = a4;
  memset(v37, 0, sizeof(v37));
  __int128 v36 = 0u;
  __int128 v35 = 0u;
  __int128 v34 = 0u;
  __int128 v33 = 0u;
  __int128 v32 = 0u;
  __int128 v31 = 0u;
  __int128 v30 = 0u;
  __int128 v29 = 0u;
  __int128 v28 = 0u;
  __int128 v27 = 0u;
  __int128 v26 = 0u;
  __int128 v25 = 0u;
  __int128 v24 = 0u;
  __int128 v23 = 0u;
  int v11 = (unsigned __int8 *)mDNS_DomainTypeNames[(int)a3];
  char v22 = 0;
  AppendDNSNameString(&v22, v11, a3, a4, a5, a6, a7, a8);
  uint64_t result = (uint64_t)AppendDNSNameString(&v22, "local", v12, v13, v14, v15, v16, v17);
  uint64_t v19 = LocalDomainEnumRecords;
  if (LocalDomainEnumRecords)
  {
    uint64_t v20 = &LocalDomainEnumRecords;
    while (1)
    {
      uint64_t result = SameDomainNameBytes((_BYTE *)(*(void *)(v19 + 56) + 4LL), a2);
      if ((_DWORD)result)
      {
        uint64_t result = SameDomainNameBytes(*(_BYTE **)(*v20 + 48), &v22);
        if ((_DWORD)result) {
          break;
        }
      }

      uint64_t v20 = (uint64_t *)*v20;
      uint64_t v19 = *v20;
      if (!*v20) {
        return result;
      }
    }

    uint64_t v21 = *v20 + 8;
    uint64_t *v20 = *(void *)*v20;
    if (v8) {
      return mDNS_Deregister_internal((uint64_t)a1, v21, 0);
    }
    else {
      return mDNS_Deregister(a1, v21);
    }
  }

  return result;
}

void SendServiceRemovalNotification(uint64_t a1)
{
  timespec v7 = 0LL;
  uint64_t v1 = *(void *)(a1 + 8);
  if (GenerateNTDResponse( *(char **)(a1 + 2448),  *(void *)(a1 + 2440),  *(void *)(v1 + 8),  (char **)&v7,  (char *)0x41,  0,  0))
  {
    LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "%3d: SendServiceRemovalNotification: %##s is not valid DNS-SD SRV name",  v2,  v3,  v4,  v5,  v6,  *(_DWORD *)(*(void *)(v1 + 8) + 168LL));
  }

  else
  {
    append_reply(*(void *)(v1 + 8), v7);
    *(_BYTE *)(v1 + 25) = 0;
  }

uint64_t get_service_attr_tsr_params(uint64_t a1, int *a2, _DWORD *a3)
{
  uint64_t v3 = *(unsigned __int8 **)(a1 + 72);
  if (!v3) {
    return 0LL;
  }
  uint64_t result = 0LL;
  if (a3)
  {
    if (a2)
    {
      if ((*(_DWORD *)(a1 + 208) & 2) != 0)
      {
        int v14 = 0;
        uint64_t v8 = *(void *)(a1 + 80);
        int tlv_uint32 = get_tlv_uint32(v3, v8, 5, &v14);
        uint64_t result = 0LL;
        *a2 = tlv_uint32;
        if (!v14)
        {
          int v10 = get_tlv_uint32(v3, v8, 11, &v14);
          *a3 = v10;
          if (v14) {
            return 0LL;
          }
          int v11 = v10;
          uint64_t v12 = (os_log_s *)mDNSLogCategory_Default;
          if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
          {
            if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEBUG))
            {
LABEL_14:
              int v13 = *a2;
              *(_DWORD *)__int128 buf = 67109376;
              int v16 = v13;
              __int16 v17 = 1024;
              int v18 = v11;
              _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEBUG,  "get_service_attr_tsr_params timestamp %u hostkeyHash %u",  buf,  0xEu);
            }
          }

          else
          {
            uint64_t v12 = (os_log_s *)mDNSLogCategory_Default_redacted;
            if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEBUG)) {
              goto LABEL_14;
            }
          }

          return 1LL;
        }
      }
    }
  }

  return result;
}

uint64_t conflictWithCacheRecordsOrFlush(unsigned int a1, _BYTE *a2, int a3, int a4)
{
  uint64_t result = (uint64_t)CacheGroupForName((uint64_t)mDNSStorage, a1, a2);
  if (result)
  {
    uint64_t v7 = result;
    uint64_t v8 = mDNSGetTSRForCacheGroup(result);
    if (v8)
    {
      int v15 = a4;
      *(_DWORD *)int v16 = 0;
      *(_DWORD *)__int128 buf = a3;
    }

    mDNS_Lock_((unsigned int *)mDNSStorage, (uint64_t)"conflictWithCacheRecordsOrFlush", 2059);
    uint64_t v9 = *(void *)(v7 + 16);
    if (v9)
    {
      while (1)
      {
        mDNS_PurgeCacheResourceRecord((unsigned int *)mDNSStorage, v9);
        int v10 = (os_log_s *)mDNSLogCategory_mDNS;
        if (gSensitiveLoggingEnabled == 1 && mDNSLogCategory_mDNS != mDNSLogCategory_State) {
          break;
        }
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEBUG)) {
          goto LABEL_14;
        }
LABEL_15:
        uint64_t v9 = *(void *)v9;
        if (!v9) {
          goto LABEL_16;
        }
      }

      int v10 = (os_log_s *)mDNSLogCategory_mDNS_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEBUG)) {
        goto LABEL_15;
      }
LABEL_14:
      uint64_t v13 = *(void *)(v9 + 32);
      GetRRDisplayString_rdb( (unsigned __int8 *)(v9 + 8),  (unsigned __int16 *)(*(void *)(v9 + 48) + 4LL),  word_100164338);
      *(_DWORD *)__int128 buf = 67109635;
      int v15 = v13;
      strcpy(v16, "p\bhash");
      v16[7] = 0;
      *(_WORD *)&v16[8] = 0;
      __int16 v17 = 2085;
      int v18 = word_100164338;
      _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEBUG,  "conflictWithCacheRecordsOrFlush - new TSR, flushing interface %d %{sensitive, mask.hash}s",  buf,  0x1Cu);
      goto LABEL_15;
    }

uint64_t updateTSRRecord(uint64_t a1, uint64_t a2, int a3, int a4)
{
  uint64_t v8 = *(void *)(a2 + 48);
  uint64_t v9 = (os_log_s *)mDNSLogCategory_mDNS;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
  {
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_31;
    }
    uint64_t v11 = *(void *)(a2 + 40);
    if (v11)
    {
      uint64_t v12 = *(_BYTE **)(a2 + 40);
      if (v11 == -256)
      {
LABEL_10:
        while (v12)
        {
          uint64_t v13 = *v12;
          if (!*v12)
          {
            int v17 = (unsigned __int16)((_WORD)v12 - v11 + 1);
            goto LABEL_30;
          }

          v12 += v13 + 1;
          if (v11 != -256) {
            goto LABEL_9;
          }
        }
      }

      else
      {
LABEL_9:
      }

      int v17 = 257;
    }

    else
    {
      int v17 = 0;
    }
  }

  else
  {
    uint64_t v9 = (os_log_s *)mDNSLogCategory_mDNS_redacted;
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_31;
    }
    uint64_t v11 = *(void *)(a2 + 40);
    if (v11)
    {
      int v15 = *(_BYTE **)(a2 + 40);
      if (v11 == -256)
      {
LABEL_19:
        while (v15)
        {
          uint64_t v16 = *v15;
          if (!*v15)
          {
            int v17 = (unsigned __int16)((_WORD)v15 - v11 + 1);
            goto LABEL_30;
          }

          v15 += v16 + 1;
          if (v11 != -256) {
            goto LABEL_18;
          }
        }
      }

      else
      {
LABEL_18:
      }

      int v17 = 257;
    }

    else
    {
      int v17 = 0;
    }
  }

uint64_t add_record_to_service( uint64_t a1, uint64_t a2, int a3, uint64_t a4, unsigned __int8 *a5, unsigned int a6)
{
  else {
    uint64_t v12 = a4;
  }
  uint64_t v13 = calloc(1uLL, v12 + 928);
  if (!v13) {
    __break(1u);
  }
  uint64_t v17 = (uint64_t)v13;
  uint64_t v18 = (uint64_t)(v13 + 12);
  v13[14] = a3;
  uint64_t v19 = (uint64_t)(v13 + 462);
  *((void *)v13 + _Block_object_dispose(va, 8) = v13 + 462;
  v13[462] = v12;
  v13[18] = a4;
  int v20 = *(uint64_t **)(a1 + 112);
  if (!SetRData(0LL, a5, (unint64_t)&a5[a4], (uint64_t)(v13 + 12), a4, v14, v15, v16))
  {
    __int128 v33 = (os_log_s *)mDNSLogCategory_mDNS;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_ERROR))
      {
        int v34 = *(_DWORD *)(a1 + 184);
        uint64_t v45 = v20[203];
        if (v45)
        {
          uint64_t v36 = *(void *)(v45 + 2736);
          if (v36)
          {
            int v46 = *(_BYTE **)(v45 + 2736);
            int v38 = 257;
            if (v36 == -256) {
              goto LABEL_37;
            }
LABEL_34:
            if ((unint64_t)v46 < v36 + 256 && v46)
            {
              while (1)
              {
                uint64_t v47 = *v46;
                if (v47 > 0x3F)
                {
LABEL_47:
                  int v38 = 257;
                  goto LABEL_51;
                }

                if (!*v46) {
                  break;
                }
                v46 += v47 + 1;
                if (v36 != -256) {
                  goto LABEL_34;
                }
LABEL_37:
                if (!v46) {
                  goto LABEL_47;
                }
              }

              int v38 = (unsigned __int16)((_WORD)v46 - v36 + 1);
            }
          }

          else
          {
            int v38 = 0;
          }
        }

        else
        {
          int v38 = 0;
          uint64_t v36 = 0LL;
        }

        goto LABEL_51;
      }
    }

    else
    {
      __int128 v33 = (os_log_s *)mDNSLogCategory_mDNS_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_ERROR))
      {
        int v34 = *(_DWORD *)(a1 + 184);
        uint64_t v35 = v20[203];
        if (v35)
        {
          uint64_t v36 = *(void *)(v35 + 2736);
          if (v36)
          {
            uint64_t v37 = *(_BYTE **)(v35 + 2736);
            int v38 = 257;
            if (v36 == -256) {
              goto LABEL_17;
            }
LABEL_14:
            if ((unint64_t)v37 < v36 + 256 && v37)
            {
              while (1)
              {
                uint64_t v39 = *v37;
                if (v39 > 0x3F)
                {
LABEL_46:
                  int v38 = 257;
                  goto LABEL_51;
                }

                if (!*v37) {
                  break;
                }
                v37 += v39 + 1;
                if (v36 != -256) {
                  goto LABEL_14;
                }
LABEL_17:
                if (!v37) {
                  goto LABEL_46;
                }
              }

              int v38 = (unsigned __int16)((_WORD)v37 - v36 + 1);
            }
          }

          else
          {
            int v38 = 0;
          }
        }

        else
        {
          int v38 = 0;
          uint64_t v36 = 0LL;
        }

uint64_t update_record(uint64_t a1, uint64_t a2, unsigned __int8 *a3, int a4, uint64_t a5, int a6)
{
  else {
    uint64_t v12 = a2;
  }
  uint64_t v13 = (unsigned __int16 *)calloc(1uLL, v12 + 4);
  if (!v13) {
    __break(1u);
  }
  uint64_t v17 = v13;
  __int128 v74 = 0u;
  __int128 v75 = 0u;
  memset(v73, 0, sizeof(v73));
  uint64_t v18 = *(void *)(a1 + 40);
  DWORD1(v73[0]) = *(_DWORD *)(a1 + 12);
  *(void *)&__int128 v74 = v18;
  *((void *)&v74 + 1) = v13;
  unsigned __int16 *v13 = v12;
  WORD6(v73[0]) = a2;
  if (!SetRData(0LL, a3, (unint64_t)&a3[a2], (uint64_t)v73, a2, v14, v15, v16))
  {
    uint64_t updated = 4294901756LL;
    uint64_t v37 = (os_log_s *)mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_ERROR)) {
        goto LABEL_68;
      }
      uint64_t v38 = v74;
      if ((void)v74)
      {
        int v53 = (_BYTE *)v74;
        if ((void)v74 == -256LL)
        {
LABEL_43:
          while (v53)
          {
            uint64_t v54 = *v53;
            if (!*v53)
            {
              int v65 = (unsigned __int16)((_WORD)v53 - v74 + 1);
              goto LABEL_67;
            }

            v53 += v54 + 1;
            if ((void)v74 != -256LL) {
              goto LABEL_42;
            }
          }
        }

        else
        {
LABEL_42:
        }

        int v65 = 257;
      }

      else
      {
        int v65 = 0;
      }
    }

    else
    {
      uint64_t v37 = (os_log_s *)mDNSLogCategory_Default_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_ERROR))
      {
LABEL_68:
        free(v17);
        return updated;
      }

      uint64_t v38 = v74;
      if ((void)v74)
      {
        uint64_t v39 = (_BYTE *)v74;
        if ((void)v74 == -256LL)
        {
LABEL_32:
          while (v39)
          {
            uint64_t v40 = *v39;
            if (!*v39)
            {
              int v65 = (unsigned __int16)((_WORD)v39 - v74 + 1);
              goto LABEL_67;
            }

            v39 += v40 + 1;
            if ((void)v74 != -256LL) {
              goto LABEL_31;
            }
          }
        }

        else
        {
LABEL_31:
        }

        int v65 = 257;
      }

      else
      {
        int v65 = 0;
      }
    }

void update_callback( int a1, uint64_t a2, char *a3, uint64_t __n, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v10 = *(_BYTE **)(a2 + 608);
  if (!v10 || !*v10) {
    goto LABEL_16;
  }
  __int128 v12 = *(_OWORD *)(a2 + 24);
  v18[0] = *(_OWORD *)(a2 + 8);
  v18[1] = v12;
  __int128 v13 = *(_OWORD *)(a2 + 56);
  __int128 v19 = *(_OWORD *)(a2 + 40);
  __int128 v20 = v13;
  int v14 = *(_DWORD *)(a2 + 172);
  int v15 = (v14 & 0xFFFFFFFD) == 1 ? 0x20000 : (v14 == 2) << 20;
  SetNewRData((uint64_t)v18, (uint64_t)a3, __n, __n, a5, a6, a7, a8);
  internal_stop_advertising_service((uint64_t)v18, v15, 0);
  uint64_t v16 = (os_log_s *)mDNSLogCategory_D2D;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_D2D == mDNSLogCategory_State)
  {
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_D2D, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v17 = 0;
      goto LABEL_14;
    }
  }

  else
  {
    uint64_t v16 = (os_log_s *)mDNSLogCategory_D2D_redacted;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_D2D_redacted, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v17 = 0;
LABEL_14:
      _os_log_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_DEFAULT,  "update_callback: calling external_start_advertising_service",  v17,  2u);
    }
  }

  internal_start_advertising_service(a2 + 8, v15, 0);
LABEL_16:
  if ((char *)(a2 + 908) != a3)
  {
    if (a3) {
      free(a3);
    }
  }

void FreeARElemCallback_2533(uint64_t a1, uint64_t a2, int a3)
{
  if (a3 == -65792)
  {
    uint64_t v5 = &LocalDomainEnumRecords;
    do
    {
      uint64_t v6 = v5;
      uint64_t v5 = (uint64_t *)*v5;
      if (v5) {
        BOOL v7 = v5 + 1 == (uint64_t *)a2;
      }
      else {
        BOOL v7 = 1;
      }
    }

    while (!v7);
    if (!v5) {
      goto LABEL_18;
    }
    *uint64_t v6 = *v5;
    uint64_t v8 = (os_log_s *)mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_18;
      }
    }

    else
    {
      uint64_t v8 = (os_log_s *)mDNSLogCategory_Default_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_18;
      }
    }

    uint64_t v11 = (_BYTE *)(a1 + 46976);
    GetRRDisplayString_rdb((unsigned __int8 *)(a2 + 8), (unsigned __int16 *)(*(void *)(a2 + 48) + 4LL), v11);
    int v13 = 141558275;
    uint64_t v14 = 1752392040LL;
    __int16 v15 = 2085;
    uint64_t v16 = v11;
    _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "FreeARElemCallback: Have to cut %{sensitive, mask.hash}s",  (uint8_t *)&v13,  0x16u);
LABEL_18:
    __int128 v12 = *(void **)(a2 + 112);
    if (v12) {
      free(v12);
    }
  }

void *GenerateBrowseReply( unsigned __int8 *a1, uint64_t a2, uint64_t a3, char **a4, unsigned int a5, unsigned int a6)
{
  *a4 = 0LL;
  if (a1)
  {
    int v13 = (char *)(a1 + 1);
    uint64_t v12 = *a1;
    if (v12 <= 0x3F)
    {
      if (v13 >= &v13[v12])
      {
        uint64_t v14 = __s;
      }

      else
      {
        uint64_t v14 = __s;
        uint64_t v15 = *a1;
        do
        {
          char v16 = *v13++;
          *v14++ = v16;
          --v15;
        }

        while (v15);
      }

      _BYTE *v14 = 0;
    }

    mDNS_snprintf(__src);
  }

  else
  {
    LOBYTE(__s[0]) = 0;
  }

  size_t v17 = strlen((const char *)__s);
  size_t v18 = strlen(__src);
  xpc_object_t reply = create_reply((char *)0x42, v17 + v18 + 16, a3, v19, v20, v21, v22, v23);
  *a4 = reply;
  *((_DWORD *)reply + 11) = bswap32(a5);
  unsigned int v30 = mDNSPlatformInterfaceIndexfromInterfaceID((uint64_t **)mDNSStorage, a2, 0LL, v25, v26, v27, v28, v29);
  uint64_t v31 = *a4;
  *((_DWORD *)v31 + 12) = bswap32(v30);
  *((_DWORD *)v31 + 13) = bswap32(a6);
  uint64_t v32 = v31 + 56;
  memcpy(v31 + 56, __s, v17 + 1);
  __int128 v33 = (char *)v32 + v17 + 1;
  size_t v34 = strlen(__src) + 1;
  uint64_t result = memcpy(v33, __src, v34);
  *(_WORD *)&v33[v34] = 46;
  return result;
}

void append_reply(uint64_t a1, void *a2)
{
  if (*(_BYTE *)(a1 + 276))
  {
    if (a2) {
      free(a2);
    }
  }

  else
  {
    uint64_t v2 = *(void *)(a1 + 24);
    if (!v2) {
      uint64_t v2 = a1;
    }
    uint64_t v3 = (void *)(v2 + 88);
    do
    {
      uint64_t v4 = v3;
      uint64_t v3 = (void *)*v3;
    }

    while (v3);
    void *v4 = a2;
    *a2 = 0LL;
  }

void FoundNonLocalOnlyAutomaticBrowseDomain( uint64_t a1, uint64_t a2, unsigned __int8 *a3, unsigned int a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v8 = *((void *)a3 + 3) + 5LL;
  BOOL v10 = v8 <= 3 && v8 != 1 || a4 > 1;
  if (!v10 && *a3 != 240)
  {
    uint64_t v14 = *((void *)a3 + 5);
    __int16 v15 = v14 + 4;
    char v16 = (_BYTE *)(v14 + 4);
    if (a4)
    {
      RegisterLocalOnlyDomainEnumPTR((unsigned int *)a1, v16, 2);
      mDNS_Lock_((unsigned int *)a1, (uint64_t)"mDNS_AddDomainDiscoveredForDomainEnumeration", 16202);
      uint64_t v17 = *(void *)(a1 + 14088);
      if (v17)
      {
        while (!SameDomainNameBytes((_BYTE *)v17, "\x05local"))
        {
          uint64_t v17 = *(void *)(v17 + 296);
          if (!v17) {
            goto LABEL_38;
          }
        }

        if (*(void *)(v17 + 272))
        {
          uint64_t v19 = calloc(1uLL, 0x108uLL);
          if (!v19) {
            __break(1u);
          }
          uint64_t v20 = v19;
          uint64_t v21 = (_BYTE *)(v14 + 4);
          if (v14 == -260)
          {
LABEL_24:
            while (v21)
            {
              uint64_t v22 = *v21;
              if (!*v21)
              {
                unsigned __int16 v27 = (_WORD)v21 - v15 + 1;
                if (v27 > 0x100u) {
                  break;
                }
                memcpy(v19, (const void *)(v14 + 4), v27);
                goto LABEL_37;
              }

              v21 += v22 + 1;
              if (v14 != -260) {
                goto LABEL_23;
              }
            }
          }

          else
          {
LABEL_23:
          }

          *uint64_t v19 = 0;
LABEL_37:
          *((void *)v20 + 32) = **(void **)(v17 + 272);
          **(void **)(v17 + 272) = v20;
        }
      }

uint64_t uds_socket_setup(int a1)
{
  uint64_t v10 = 0x100000001LL;
  if (setsockopt(a1, 0xFFFF, 4227, &v10, 8u) < 0) {
    my_perror((int)"WARNING: could not set sockopt - SO_NP_EXTENSIONS");
  }
  int v2 = fcntl(a1, 3, 0LL);
  if (fcntl(a1, 4, v2 | 4u))
  {
    uint64_t v3 = "ERROR: could not set listen socket to non-blocking mode";
LABEL_9:
    my_perror((int)v3);
    return 0LL;
  }

  if (listen(a1, 100))
  {
    uint64_t v3 = "ERROR: could not listen on listen socket";
    goto LABEL_9;
  }

  if (udsSupportAddFDToEventLoop(a1, (uint64_t)connect_callback, 0LL))
  {
    uint64_t v3 = "ERROR: could not add listen socket to event loop";
    goto LABEL_9;
  }

  if (mDNS_LoggingEnabled == 1) {
    LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "%3d: Listening for incoming Unix Domain Socket client requests",  v4,  v5,  v6,  v7,  v8,  a1);
  }
  dword_10015D938 = a1;
  return 1LL;
}

void my_perror(int a1)
{
  int v2 = (os_log_s *)mDNSLogCategory_Default;
  __error();
  uint64_t v3 = __error();
  strerror(*v3);
  LogMsgWithLevel(v2, OS_LOG_TYPE_DEFAULT, "%s: %d (%s)", v4, v5, v6, v7, v8, a1);
}

void AutomaticBrowseDomainChange(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v6 = *(void *)(a3 + 24);
  uint64_t v7 = (os_log_s *)mDNSLogCategory_mDNS;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
  {
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_36;
    }
    uint64_t v9 = *(void *)(a3 + 40);
    uint64_t v10 = v9 + 4;
    unint64_t v11 = v9 + 260;
    uint64_t v12 = (_BYTE *)(v9 + 4);
    if (v11)
    {
LABEL_8:
    }

    else
    {
LABEL_9:
      while (v12)
      {
        uint64_t v13 = *v12;
        if (!*v12)
        {
          int v26 = (unsigned __int16)((_WORD)v12 - v10 + 1);
          goto LABEL_25;
        }

        v12 += v13 + 1;
        if (v11) {
          goto LABEL_8;
        }
      }
    }

    int v26 = 257;
LABEL_25:
    uint64_t v28 = "removing";
    int v31 = 141559299;
    uint64_t v32 = 1752392040LL;
    __int16 v33 = 1040;
    if (a4 == 1) {
      uint64_t v28 = "adding";
    }
    int v34 = v26;
    __int16 v35 = 2101;
    uint64_t v36 = v10;
    uint64_t v29 = ", ignored.";
    __int16 v37 = 2082;
    if (v6) {
      uint64_t v29 = ".";
    }
    goto LABEL_35;
  }

  uint64_t v7 = (os_log_s *)mDNSLogCategory_mDNS_redacted;
  if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v21 = *(void *)(a3 + 40);
    uint64_t v22 = v21 + 4;
    unint64_t v23 = v21 + 260;
    uint64_t v24 = (_BYTE *)(v21 + 4);
    if (v23)
    {
LABEL_16:
    }

    else
    {
LABEL_17:
      while (v24)
      {
        uint64_t v25 = *v24;
        if (!*v24)
        {
          int v27 = (unsigned __int16)((_WORD)v24 - v22 + 1);
          goto LABEL_31;
        }

        v24 += v25 + 1;
        if (v23) {
          goto LABEL_16;
        }
      }
    }

    int v27 = 257;
LABEL_31:
    uint64_t v28 = "removing";
    int v31 = 141559299;
    uint64_t v32 = 1752392040LL;
    __int16 v33 = 1040;
    if (a4 == 1) {
      uint64_t v28 = "adding";
    }
    int v34 = v27;
    __int16 v35 = 2101;
    uint64_t v36 = v22;
    uint64_t v29 = ", ignored.";
    __int16 v37 = 2082;
    if (v6) {
      uint64_t v29 = ".";
    }
LABEL_35:
    uint64_t v38 = v28;
    __int16 v39 = 2048;
    uint64_t v40 = v6;
    __int16 v41 = 2082;
    int v42 = v29;
    _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "Automatic browsing domain changes - name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P, event: %{public}s , interface ID: %p%{public}s",  (uint8_t *)&v31,  0x3Au);
  }

uint64_t set_peer_pid(uint64_t a1)
{
  *(_BYTE *)(a1 + 240) = 0;
  uint64_t v2 = a1 + 240;
  *(_DWORD *)(a1 + 172) = -1;
  socklen_t v4 = 4;
  int v5 = -1;
  uint64_t result = *(unsigned int *)(a1 + 168);
  if ((result & 0x80000000) == 0)
  {
    uint64_t result = getsockopt(result, 0, 3, &v5, &v4);
    if (!(_DWORD)result)
    {
      uint64_t result = mdns_system_pid_to_name(v5, v2);
      if (result) {
        *(_DWORD *)(a1 + 172) = v5;
      }
    }
  }

  return result;
}

uint64_t get_signed_browse_tlvs(uint64_t a1)
{
  unint64_t v21 = 0LL;
  signed_data_tlvs = _get_signed_data_tlvs(a1, (uint64_t *)&v21);
  if (!*(_BYTE *)(a1 + 274)) {
    return 0LL;
  }
  uint64_t v3 = signed_data_tlvs;
  if (!signed_data_tlvs)
  {
    uint64_t v10 = 4294901747LL;
    uint64_t v13 = mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEBUG)) {
        return v10;
      }
      *(_WORD *)__int128 buf = 0;
      uint64_t v15 = "get_signed_browse_tlvs data invalid";
    }

    else
    {
      uint64_t v13 = mDNSLogCategory_Default_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEBUG)) {
        return v10;
      }
      *(_WORD *)__int128 buf = 0;
      uint64_t v15 = "get_signed_browse_tlvs data invalid";
    }

    uint64_t v17 = (os_log_s *)v13;
    uint32_t v18 = 2;
    goto LABEL_33;
  }

  uint64_t v4 = v21;
  if (v21 < 0x3A)
  {
    int v9 = -6743;
  }

  else if (*((_DWORD *)signed_data_tlvs + 12) == 5)
  {
    unint64_t v5 = signed_data_tlvs[28];
    if (v21 - 58 < v5)
    {
      int v9 = -6750;
    }

    else if (v5 > 0x3F0)
    {
      int v9 = -6744;
    }

    else
    {
      bzero(buf, 0x3F1uLL);
      __memcpy_chk(buf, v3 + 29, v5, 1009LL);
      buf[v5] = 0;
      memset(v23, 0, sizeof(v23));
      int v6 = DomainNameFromString(v23, (char *)buf);
      if (v6 || (int v6 = _mdns_necp_validate_result((uint64_t)v3, v4)) != 0)
      {
        int v9 = v6;
      }

      else
      {
        int v22 = 0;
        uint64_t v7 = malloc(v4);
        if (v7)
        {
          unint64_t v5 = (unint64_t)v7;
          memcpy(v7, v3, v4);
          uint64_t v8 = _mdns_signed_browse_result_create_no_copy(v23, v5, v4, &v22);
          if (v8)
          {
            int v9 = v22;
            if (!v22)
            {
              uint64_t v10 = 0LL;
              *(void *)(a1 + 4_Block_object_dispose(va, 8) = v8;
              return v10;
            }

            goto LABEL_12;
          }
        }

        else
        {
          __break(1u);
        }

        free((void *)v5);
        int v9 = -6728;
      }
    }
  }

  else
  {
    int v9 = -6756;
  }

uint64_t build_domainname_from_strings( _BYTE *a1, _BYTE *a2, unsigned __int8 *a3, unsigned __int8 *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  LOBYTE(v10) = *a2;
  if (*a2)
  {
    uint64_t v11 = 0LL;
    do
    {
      v53[v11 + 1] = v10;
      uint64_t v12 = &v53[v11 + 2];
      int v10 = a2[++v11];
      if (v10) {
        BOOL v13 = v12 >= (char *)&v54;
      }
      else {
        BOOL v13 = 1;
      }
    }

    while (!v13);
    v53[0] = v53 + v11 + 1 + ~(&vars0 - 104);
    if (v10) {
      return 0xFFFFFFFFLL;
    }
  }

  else
  {
    v53[0] = v53 + 1 + ~(&vars0 - 104);
  }

  __int128 v51 = 0u;
  memset(v52, 0, sizeof(v52));
  __int128 v49 = 0u;
  __int128 v50 = 0u;
  __int128 v47 = 0u;
  __int128 v48 = 0u;
  __int128 v45 = 0u;
  __int128 v46 = 0u;
  __int128 v43 = 0u;
  __int128 v44 = 0u;
  __int128 v41 = 0u;
  __int128 v42 = 0u;
  __int128 v39 = 0u;
  __int128 v40 = 0u;
  __int128 v38 = 0u;
  __int128 v22 = 0u;
  __int128 v23 = 0u;
  __int128 v24 = 0u;
  __int128 v25 = 0u;
  __int128 v26 = 0u;
  __int128 v27 = 0u;
  __int128 v28 = 0u;
  __int128 v29 = 0u;
  __int128 v30 = 0u;
  __int128 v31 = 0u;
  __int128 v32 = 0u;
  __int128 v33 = 0u;
  __int128 v34 = 0u;
  __int128 v35 = 0u;
  memset(v36, 0, sizeof(v36));
  unsigned __int8 v21 = 0;
  char v37 = 0;
  if (!AppendDNSNameString(&v37, a4, v14, v15, v16, v17, v18, v19)) {
    return 0xFFFFFFFFLL;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

void resolve_result_callback(uint64_t **a1, unint64_t a2, uint64_t a3, int a4)
{
  char __src = 48;
  uint64_t v8 = *(void *)(a2 + 176);
  int v9 = (_BYTE *)(a2 + 356);
  LODWORD(v10) = mDNS_DomainNameFNV1aHash((unsigned __int8 *)(a2 + 356));
  int v11 = *(unsigned __int16 *)(a2 + 320);
  LODWORD(v366) = mDNSPlatformInterfaceIndexfromInterfaceID(a1, *(void *)(a3 + 24), 0LL, v12, v13, v14, v15, v16);
  HIDWORD(v366) = mDNS_DomainNameFNV1aHash((unsigned __int8 *)(a2 + 356));
  size_t v17 = *(unsigned int *)(v8 + 192);
  __tp.unsigned __int16 tv_sec = 0LL;
  __tp.tv_nsec = 0LL;
  clock_gettime(_CLOCK_MONOTONIC_RAW, &__tp);
  unint64_t v368 = a2;
  uint64_t v369 = v8;
  int v365 = (int)v10;
  int v367 = a1;
  if (!(_DWORD)v17 || LODWORD(__tp.tv_sec) - (int)v17 >= 300)
  {
    *(_DWORD *)(v8 + 192) = __tp.tv_sec;
    uint64_t v28 = *(void *)(a3 + 56);
    if (v28)
    {
      validation_uint64_t result = dnssec_obj_resource_record_member_get_validation_result(v28);
      unsigned int v30 = *(unsigned __int16 *)(a2 + 320);
      a2 = *(unsigned __int16 *)(a3 + 12);
      BOOL v31 = a2 < 0x201;
      if ((_DWORD)validation_result)
      {
        size_t v17 = validation_result;
        if (!v30)
        {
          if (a2 >= 0x201)
          {
            __int128 v41 = (unsigned __int8 *)malloc(*(unsigned __int16 *)(a3 + 12));
            __int128 v26 = v41;
            uint64_t v54 = (char *)v41;
            if (!v41) {
              goto LABEL_612;
            }
          }

          else
          {
            if (!*(_WORD *)(a3 + 12))
            {
              if (v11) {
                __int16 v142 = (os_log_s *)mDNSLogCategory_Default;
              }
              else {
                __int16 v142 = (os_log_s *)mDNSLogCategory_mDNS;
              }
              if (gSensitiveLoggingEnabled != 1 || v142 == (os_log_s *)mDNSLogCategory_State)
              {
                if (!os_log_type_enabled(v142, OS_LOG_TYPE_DEFAULT)) {
                  goto LABEL_472;
                }
                int v143 = *(_DWORD *)(v369 + 184);
                __int128 v180 = v9;
                int v146 = v366;
                int v145 = HIDWORD(v366);
                if (v368 == -612LL)
                {
LABEL_382:
                  while (v180)
                  {
                    uint64_t v181 = *v180;
                    if (!*v180)
                    {
                      unsigned __int16 v258 = (_WORD)v180 - (_WORD)v9 + 1;
                      goto LABEL_610;
                    }

                    v180 += v181 + 1;
                    if (v368 != -612LL) {
                      goto LABEL_381;
                    }
                  }
                }

                else
                {
LABEL_381:
                }

                unsigned __int16 v258 = 257;
              }

              else
              {
                if (v11) {
                  __int16 v142 = (os_log_s *)mDNSLogCategory_Default_redacted;
                }
                else {
                  __int16 v142 = (os_log_s *)mDNSLogCategory_mDNS;
                }
                if (!os_log_type_enabled(v142, OS_LOG_TYPE_DEFAULT)) {
                  goto LABEL_472;
                }
                int v143 = *(_DWORD *)(v369 + 184);
                __int16 v144 = v9;
                int v146 = v366;
                int v145 = HIDWORD(v366);
                if (v368 == -612LL)
                {
LABEL_272:
                  while (v144)
                  {
                    uint64_t v147 = *v144;
                    if (!*v144)
                    {
                      unsigned __int16 v258 = (_WORD)v144 - (_WORD)v9 + 1;
                      goto LABEL_610;
                    }

                    v144 += v147 + 1;
                    if (v368 != -612LL) {
                      goto LABEL_271;
                    }
                  }
                }

                else
                {
LABEL_271:
                }

                unsigned __int16 v258 = 257;
              }

LABEL_456:
            int v266 = *(unsigned __int16 *)(a3 + 4);
            LODWORD(__tp.tv_sec) = 67111683;
            HIDWORD(__tp.tv_sec) = v105;
            LOWORD(__tp.tv_nsec) = 1024;
            *(_DWORD *)((char *)&__tp.tv_nsec + 2) = v106;
            HIWORD(__tp.tv_nsec) = 1024;
            *(_DWORD *)v376 = a4;
            *(_WORD *)&v376[4] = 1024;
            *(_DWORD *)&v376[6] = 0;
            LOWORD(v377) = 1024;
            *(_DWORD *)((char *)&v377 + 2) = v109;
            HIWORD(v377) = 2160;
            *(void *)uint64_t v378 = 1752392040LL;
            *(_WORD *)&v378[8] = 1040;
            *(_DWORD *)&v378[10] = v213;
            *(_WORD *)&v378[14] = 2101;
            *(void *)&v378[16] = v9;
            *(_WORD *)&v378[24] = 1024;
            *(_DWORD *)&v378[26] = v108;
            *(_WORD *)&v378[30] = 1026;
            *(_DWORD *)&v378[32] = v17;
            *(_WORD *)&v378[36] = 1024;
            *(_DWORD *)&v378[38] = v266;
            int v161 = "[R%u->Q%u] DNSServiceResolve result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %d, "
                   "name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%x), dnssec: %{public, mdns:dnssec_resul"
                   "t}d, type: %{mdns:rrtype}d, rdata: <none>";
            __int16 v162 = v104;
            uint32_t v163 = 76;
            goto LABEL_611;
          }

          __int128 v26 = 0LL;
          __int128 v32 = (char *)&unk_100164138;
          LODWORD(a2) = 512;
        }

        int v371 = 0;
        unsigned __int16 v370 = 0;
        uint64_t v69 = ResourceRecordGetRDataBytesPointer(a3, v32, a2, &v370, &v371, v18, v19, v20);
        if (v371) {
          goto LABEL_470;
        }
        int v10 = (void *)v69;
        int v360 = a4;
        size_t v70 = v370;
        if (v370 >= 0x1FFuLL)
        {
          __int128 v41 = (unsigned __int8 *)malloc(v370 + 2LL);
          if (!v41) {
            goto LABEL_612;
          }
          int v72 = (__int16 *)v41;
          size_t v364 = v70 + 2;
          unsigned int v71 = v41;
        }

        else
        {
          unsigned int v71 = 0LL;
          size_t v364 = 512LL;
          int v72 = word_100164338;
        }

        if (v11) {
          int v131 = (os_log_s *)mDNSLogCategory_Default;
        }
        else {
          int v131 = (os_log_s *)mDNSLogCategory_mDNS;
        }
        if (gSensitiveLoggingEnabled == 1 && v131 != (os_log_s *)mDNSLogCategory_State)
        {
          if (v11) {
            __int32 v132 = (os_log_s *)mDNSLogCategory_Default_redacted;
          }
          else {
            __int32 v132 = (os_log_s *)mDNSLogCategory_mDNS;
          }
          if (!os_log_type_enabled(v132, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_467;
          }
          int v133 = *(_DWORD *)(v369 + 184);
          unsigned int v134 = bswap32(*(unsigned __int16 *)(v368 + 320)) >> 16;
          unsigned int v135 = v9;
          size_t v363 = (size_t)v71;
          if (v368 == -612LL)
          {
LABEL_235:
            while (v135)
            {
              uint64_t v136 = *v135;
              if (!*v135)
              {
                unsigned __int16 v182 = (_WORD)v135 - (_WORD)v9 + 1;
                goto LABEL_426;
              }

              v135 += v136 + 1;
              if (v368 != -612LL) {
                goto LABEL_234;
              }
            }
          }

          else
          {
LABEL_234:
          }

          unsigned __int16 v182 = 257;
LABEL_426:
          int v236 = v182;
          unsigned int v237 = *(unsigned __int16 *)(a3 + 4);
          int v238 = v70 + 2;
          if ((int)v70 + 2 <= v364)
          {
            *int v72 = __rev16(v237);
            v239 = v10;
            size_t v240 = v70;
            LODWORD(v10) = v133;
            unsigned int v241 = v134;
            size_t v364 = (size_t)v132;
            int v242 = v182;
            memcpy(v72 + 1, v239, v240);
            int v236 = v242;
            __int32 v132 = (os_log_s *)v364;
            unsigned int v134 = v241;
            int v133 = (int)v10;
          }

          else
          {
            int v72 = 0LL;
          }

          LODWORD(__tp.tv_sec) = 67112451;
          HIDWORD(__tp.tv_sec) = v133;
          LOWORD(__tp.tv_nsec) = 1024;
          *(_DWORD *)((char *)&__tp.tv_nsec + 2) = v134;
          HIWORD(__tp.tv_nsec) = 1024;
          *(_DWORD *)v376 = v360;
          *(_WORD *)&v376[4] = 1024;
          *(_DWORD *)&v376[6] = 0;
          LOWORD(v377) = 1024;
          *(_DWORD *)((char *)&v377 + 2) = v366;
          HIWORD(v377) = 2160;
          *(void *)uint64_t v378 = 1752392040LL;
          *(_WORD *)&v378[8] = 1040;
          *(_DWORD *)&v378[10] = v236;
          *(_WORD *)&v378[14] = 2101;
          *(void *)&v378[16] = v9;
          *(_WORD *)&v378[24] = 1024;
          *(_DWORD *)&v378[26] = HIDWORD(v366);
          *(_WORD *)&v378[30] = 1026;
          *(_DWORD *)&v378[32] = v17;
          *(_WORD *)&v378[36] = 1024;
          *(_DWORD *)&v378[38] = v237;
          *(_WORD *)&v378[42] = 2160;
          *(void *)&v378[44] = 1752392040LL;
          *(_WORD *)&v378[52] = 1040;
          *(_DWORD *)&v378[54] = v238;
          *(_WORD *)&v378[58] = 2101;
          *(void *)&v378[60] = v72;
          int v243 = "[R%u->Q%u] DNSServiceResolve result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %d, na"
                 "me: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%x), dnssec: %{public, mdns:dnssec_result}d,"
                 " type: %{mdns:rrtype}d, rdata: %{sensitive, mask.hash, mdns:rdata}.*P";
          v244 = v132;
          goto LABEL_435;
        }

        if (os_log_type_enabled(v131, OS_LOG_TYPE_DEFAULT))
        {
          int v137 = *(_DWORD *)(v369 + 184);
          unsigned int v138 = bswap32(*(unsigned __int16 *)(v368 + 320)) >> 16;
          __int128 v139 = v9;
          size_t v363 = (size_t)v71;
          if (v368 == -612LL)
          {
LABEL_246:
            while (v139)
            {
              uint64_t v140 = *v139;
              if (!*v139)
              {
                unsigned __int16 v183 = (_WORD)v139 - (_WORD)v9 + 1;
                goto LABEL_431;
              }

              v139 += v140 + 1;
              if (v368 != -612LL) {
                goto LABEL_245;
              }
            }
          }

          else
          {
LABEL_245:
          }

          unsigned __int16 v183 = 257;
LABEL_431:
          int v245 = v183;
          unsigned int v246 = *(unsigned __int16 *)(a3 + 4);
          int v247 = v70 + 2;
          if ((int)v70 + 2 <= v364)
          {
            *int v72 = __rev16(v246);
            size_t v248 = v70;
            unsigned int v249 = v10;
            LODWORD(v10) = v137;
            unsigned int v250 = v138;
            LODWORD(v364) = v247;
            memcpy(v72 + 1, v249, v248);
            int v247 = v364;
            unsigned int v138 = v250;
            int v137 = (int)v10;
          }

          else
          {
            int v72 = 0LL;
          }

          LODWORD(__tp.tv_sec) = 67112451;
          HIDWORD(__tp.tv_sec) = v137;
          LOWORD(__tp.tv_nsec) = 1024;
          *(_DWORD *)((char *)&__tp.tv_nsec + 2) = v138;
          HIWORD(__tp.tv_nsec) = 1024;
          *(_DWORD *)v376 = v360;
          *(_WORD *)&v376[4] = 1024;
          *(_DWORD *)&v376[6] = 0;
          LOWORD(v377) = 1024;
          *(_DWORD *)((char *)&v377 + 2) = v366;
          HIWORD(v377) = 2160;
          *(void *)uint64_t v378 = 1752392040LL;
          *(_WORD *)&v378[8] = 1040;
          *(_DWORD *)&v378[10] = v245;
          *(_WORD *)&v378[14] = 2101;
          *(void *)&v378[16] = v9;
          *(_WORD *)&v378[24] = 1024;
          *(_DWORD *)&v378[26] = HIDWORD(v366);
          *(_WORD *)&v378[30] = 1026;
          *(_DWORD *)&v378[32] = v17;
          *(_WORD *)&v378[36] = 1024;
          *(_DWORD *)&v378[38] = v246;
          *(_WORD *)&v378[42] = 2160;
          *(void *)&v378[44] = 1752392040LL;
          *(_WORD *)&v378[52] = 1040;
          *(_DWORD *)&v378[54] = v247;
          *(_WORD *)&v378[58] = 2101;
          *(void *)&v378[60] = v72;
          int v243 = "[R%u->Q%u] DNSServiceResolve result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %d, na"
                 "me: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%x), dnssec: %{public, mdns:dnssec_result}d,"
                 " type: %{mdns:rrtype}d, rdata: %{sensitive, mask.hash, mdns:rdata}.*P";
          v244 = v131;
LABEL_435:
          uint32_t v251 = 102;
LABEL_466:
          _os_log_impl((void *)&_mh_execute_header, v244, OS_LOG_TYPE_DEFAULT, v243, (uint8_t *)&__tp, v251);
          unsigned int v71 = (unsigned __int8 *)v363;
        }

LABEL_467:
        a4 = v360;
        if (!v71) {
          goto LABEL_470;
        }
        int v228 = v71;
        goto LABEL_469;
      }
    }

    else
    {
      unsigned int v30 = *(unsigned __int16 *)(a2 + 320);
      LODWORD(a2) = *(unsigned __int16 *)(a3 + 12);
      BOOL v31 = a2 < 0x201;
    }

    if (!v30)
    {
      if (v31)
      {
        __int128 v26 = 0LL;
        int v39 = 512;
        __int128 v40 = (char *)&unk_100164138;
      }

      else
      {
        __int128 v41 = (unsigned __int8 *)malloc(a2);
        __int128 v40 = (char *)v41;
        __int128 v26 = v41;
        int v39 = a2;
        if (!v41) {
          goto LABEL_612;
        }
      }

      if (!(_DWORD)a2)
      {
        if (v11) {
          __int16 v82 = (os_log_s *)mDNSLogCategory_Default;
        }
        else {
          __int16 v82 = (os_log_s *)mDNSLogCategory_mDNS;
        }
        if (gSensitiveLoggingEnabled != 1 || v82 == (os_log_s *)mDNSLogCategory_State)
        {
          if (!os_log_type_enabled(v82, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_470;
          }
          int v83 = *(_DWORD *)(v369 + 184);
          uint64_t v125 = v9;
          int v86 = v366;
          int v85 = HIDWORD(v366);
          if (v368 == -612LL)
          {
LABEL_204:
            while (v125)
            {
              uint64_t v126 = *v125;
              if (!*v125)
              {
                unsigned __int16 v177 = (_WORD)v125 - (_WORD)v9 + 1;
                goto LABEL_417;
              }

              v125 += v126 + 1;
              if (v368 != -612LL) {
                goto LABEL_203;
              }
            }
          }

          else
          {
LABEL_203:
          }

          unsigned __int16 v177 = 257;
        }

        else
        {
          if (v11) {
            __int16 v82 = (os_log_s *)mDNSLogCategory_Default_redacted;
          }
          else {
            __int16 v82 = (os_log_s *)mDNSLogCategory_mDNS;
          }
          if (!os_log_type_enabled(v82, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_470;
          }
          int v83 = *(_DWORD *)(v369 + 184);
          __int16 v84 = v9;
          int v86 = v366;
          int v85 = HIDWORD(v366);
          if (v368 == -612LL)
          {
LABEL_108:
            while (v84)
            {
              uint64_t v87 = *v84;
              if (!*v84)
              {
                unsigned __int16 v177 = (_WORD)v84 - (_WORD)v9 + 1;
                goto LABEL_417;
              }

              v84 += v87 + 1;
              if (v368 != -612LL) {
                goto LABEL_107;
              }
            }
          }

          else
          {
LABEL_107:
          }

          unsigned __int16 v177 = 257;
        }

LABEL_417:
        int v229 = *(unsigned __int16 *)(a3 + 4);
        LODWORD(__tp.tv_sec) = 67111171;
        HIDWORD(__tp.tv_sec) = v83;
        LOWORD(__tp.tv_nsec) = 1024;
        *(_DWORD *)((char *)&__tp.tv_nsec + 2) = a4;
        HIWORD(__tp.tv_nsec) = 1024;
        *(_DWORD *)v376 = 0;
        *(_WORD *)&v376[4] = 1024;
        *(_DWORD *)&v376[6] = v86;
        strcpy((char *)&v377, "p\bhash");
        HIBYTE(v377) = 0;
        *(_WORD *)uint64_t v378 = 0;
        *(_WORD *)&v378[2] = 1040;
        *(_DWORD *)&v378[4] = v177;
        *(_WORD *)&v378[8] = 2101;
        *(void *)&v378[10] = v9;
        *(_WORD *)&v378[18] = 1024;
        *(_DWORD *)&v378[20] = v85;
        *(_WORD *)&v378[24] = 1024;
        *(_DWORD *)&v378[26] = v229;
        unsigned __int16 v98 = "[R%u->mDNS] DNSServiceResolve result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %d, name"
              ": %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%x), type: %{mdns:rrtype}d, rdata: <none>";
        uint64_t v99 = v82;
        uint32_t v100 = 64;
        goto LABEL_418;
      }

      int v371 = 0;
      unsigned __int16 v370 = 0;
      uint64_t v77 = ResourceRecordGetRDataBytesPointer(a3, v40, v39, &v370, &v371, v18, v19, v20);
      if (v371) {
        goto LABEL_470;
      }
      int v10 = (void *)v77;
      size_t v78 = v370;
      int v360 = a4;
      if (v370 >= 0x1FFuLL)
      {
        int v79 = v370 + 2;
        __int128 v41 = (unsigned __int8 *)malloc(v370 + 2LL);
        if (!v41) {
          goto LABEL_612;
        }
        __int16 v80 = (__int16 *)v41;
        unsigned int v71 = v41;
      }

      else
      {
        unsigned int v71 = 0LL;
        int v79 = 512;
        __int16 v80 = word_100164338;
      }

      if (v11) {
        __int16 v152 = (os_log_s *)mDNSLogCategory_Default;
      }
      else {
        __int16 v152 = (os_log_s *)mDNSLogCategory_mDNS;
      }
      if (gSensitiveLoggingEnabled != 1 || v152 == (os_log_s *)mDNSLogCategory_State)
      {
        if (!os_log_type_enabled(v152, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_467;
        }
        int v153 = *(_DWORD *)(v369 + 184);
        __int16 v156 = v9;
        size_t v364 = (size_t)v71;
        if (v368 == -612LL)
        {
LABEL_314:
          while (v156)
          {
            uint64_t v157 = *v156;
            if (!*v156)
            {
              unsigned int v211 = v79;
              unsigned __int16 v212 = (_WORD)v156 - (_WORD)v9 + 1;
              goto LABEL_450;
            }

            v156 += v157 + 1;
            if (v368 != -612LL) {
              goto LABEL_313;
            }
          }
        }

        else
        {
LABEL_313:
        }

        unsigned int v211 = v79;
        unsigned __int16 v212 = 257;
LABEL_450:
        int v259 = v212;
        unsigned int v260 = *(unsigned __int16 *)(a3 + 4);
        int v261 = v78 + 2;
        if ((int)v78 + 2 <= v211)
        {
          *__int16 v80 = __rev16(v260);
          size_t v264 = v78;
          int v265 = v153;
          memcpy(v80 + 1, v10, v264);
          int v153 = v265;
        }

        else
        {
          __int16 v80 = 0LL;
        }
      }

      else
      {
        if (v11) {
          __int16 v152 = (os_log_s *)mDNSLogCategory_Default_redacted;
        }
        else {
          __int16 v152 = (os_log_s *)mDNSLogCategory_mDNS;
        }
        if (!os_log_type_enabled(v152, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_467;
        }
        int v153 = *(_DWORD *)(v369 + 184);
        __int16 v154 = v9;
        size_t v364 = (size_t)v71;
        if (v368 == -612LL)
        {
LABEL_303:
          while (v154)
          {
            uint64_t v155 = *v154;
            if (!*v154)
            {
              unsigned int v209 = v79;
              unsigned __int16 v210 = (_WORD)v154 - (_WORD)v9 + 1;
              goto LABEL_446;
            }

            v154 += v155 + 1;
            if (v368 != -612LL) {
              goto LABEL_302;
            }
          }
        }

        else
        {
LABEL_302:
        }

        unsigned int v209 = v79;
        unsigned __int16 v210 = 257;
LABEL_446:
        int v259 = v210;
        unsigned int v260 = *(unsigned __int16 *)(a3 + 4);
        int v261 = v78 + 2;
        if ((int)v78 + 2 <= v209)
        {
          *__int16 v80 = __rev16(v260);
          size_t v262 = v78;
          int v263 = v153;
          memcpy(v80 + 1, v10, v262);
          int v153 = v263;
        }

        else
        {
          __int16 v80 = 0LL;
        }
      }

      LODWORD(__tp.tv_sec) = 67111939;
      HIDWORD(__tp.tv_sec) = v153;
      LOWORD(__tp.tv_nsec) = 1024;
      *(_DWORD *)((char *)&__tp.tv_nsec + 2) = v360;
      HIWORD(__tp.tv_nsec) = 1024;
      *(_DWORD *)v376 = 0;
      *(_WORD *)&v376[4] = 1024;
      *(_DWORD *)&v376[6] = v366;
      strcpy((char *)&v377, "p\bhash");
      HIBYTE(v377) = 0;
      *(_WORD *)uint64_t v378 = 0;
      *(_WORD *)&v378[2] = 1040;
      *(_DWORD *)&v378[4] = v259;
      *(_WORD *)&v378[8] = 2101;
      *(void *)&v378[10] = v9;
      *(_WORD *)&v378[18] = 1024;
      *(_DWORD *)&v378[20] = HIDWORD(v366);
      *(_WORD *)&v378[24] = 1024;
      *(_DWORD *)&v378[26] = v260;
      *(_WORD *)&v378[30] = 2160;
      *(void *)&v378[32] = 1752392040LL;
      *(_WORD *)&v378[40] = 1040;
      *(_DWORD *)&v378[42] = v261;
      *(_WORD *)&v378[46] = 2101;
      *(void *)&v378[48] = v80;
      _os_log_impl( (void *)&_mh_execute_header,  v152,  OS_LOG_TYPE_DEFAULT,  "[R%u->mDNS] DNSServiceResolve result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %d, name: %{se nsitive, mask.hash, mdnsresponder:domain_name}.*P (%x), type: %{mdns:rrtype}d, rdata: %{sensitive, mask.hash, mdns:rdata}.*P",  (uint8_t *)&__tp,  0x5Au);
      unsigned int v71 = (unsigned __int8 *)v364;
      goto LABEL_467;
    }

    if (v31)
    {
      __int128 v26 = 0LL;
      int v35 = 512;
      uint64_t v36 = (char *)&unk_100164138;
    }

    else
    {
      __int128 v41 = (unsigned __int8 *)malloc(a2);
      uint64_t v36 = (char *)v41;
      __int128 v26 = v41;
      int v35 = a2;
      if (!v41) {
        goto LABEL_612;
      }
    }

    if (!(_DWORD)a2)
    {
      if (v11) {
        uint64_t v56 = (os_log_s *)mDNSLogCategory_Default;
      }
      else {
        uint64_t v56 = (os_log_s *)mDNSLogCategory_mDNS;
      }
      if (gSensitiveLoggingEnabled != 1 || v56 == (os_log_s *)mDNSLogCategory_State)
      {
        if (!os_log_type_enabled(v56, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_470;
        }
        int v57 = *(_DWORD *)(v369 + 184);
        unsigned int v58 = __rev16(v30);
        __int16 v101 = v9;
        int v61 = v366;
        int v60 = HIDWORD(v366);
        if (v368 == -612LL)
        {
LABEL_126:
          while (v101)
          {
            uint64_t v102 = *v101;
            if (!*v101)
            {
              unsigned __int16 v158 = (_WORD)v101 - (_WORD)v9 + 1;
              goto LABEL_391;
            }

            v101 += v102 + 1;
            if (v368 != -612LL) {
              goto LABEL_125;
            }
          }
        }

        else
        {
LABEL_125:
        }

        unsigned __int16 v158 = 257;
      }

      else
      {
        if (v11) {
          uint64_t v56 = (os_log_s *)mDNSLogCategory_Default_redacted;
        }
        else {
          uint64_t v56 = (os_log_s *)mDNSLogCategory_mDNS;
        }
        if (!os_log_type_enabled(v56, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_470;
        }
        int v57 = *(_DWORD *)(v369 + 184);
        unsigned int v58 = __rev16(v30);
        uint64_t v59 = v9;
        int v61 = v366;
        int v60 = HIDWORD(v366);
        if (v368 == -612LL)
        {
LABEL_64:
          while (v59)
          {
            uint64_t v62 = *v59;
            if (!*v59)
            {
              unsigned __int16 v158 = (_WORD)v59 - (_WORD)v9 + 1;
              goto LABEL_391;
            }

            v59 += v62 + 1;
            if (v368 != -612LL) {
              goto LABEL_63;
            }
          }
        }

        else
        {
LABEL_63:
        }

        unsigned __int16 v158 = 257;
      }

LABEL_391:
      int v184 = *(unsigned __int16 *)(a3 + 4);
      LODWORD(__tp.tv_sec) = 67111427;
      HIDWORD(__tp.tv_sec) = v57;
      LOWORD(__tp.tv_nsec) = 1024;
      *(_DWORD *)((char *)&__tp.tv_nsec + 2) = v58;
      HIWORD(__tp.tv_nsec) = 1024;
      *(_DWORD *)v376 = a4;
      *(_WORD *)&v376[4] = 1024;
      *(_DWORD *)&v376[6] = 0;
      LOWORD(v377) = 1024;
      *(_DWORD *)((char *)&v377 + 2) = v61;
      HIWORD(v377) = 2160;
      *(void *)uint64_t v378 = 1752392040LL;
      *(_WORD *)&v378[8] = 1040;
      *(_DWORD *)&v378[10] = v158;
      *(_WORD *)&v378[14] = 2101;
      *(void *)&v378[16] = v9;
      *(_WORD *)&v378[24] = 1024;
      *(_DWORD *)&v378[26] = v60;
      *(_WORD *)&v378[30] = 1024;
      *(_DWORD *)&v378[32] = v184;
      unsigned __int16 v98 = "[R%u->Q%u] DNSServiceResolve result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %d, name: %"
            "{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%x), type: %{mdns:rrtype}d, rdata: <none>";
      uint64_t v99 = v56;
      uint32_t v100 = 70;
      goto LABEL_418;
    }

    int v371 = 0;
    unsigned __int16 v370 = 0;
    uint64_t v48 = ResourceRecordGetRDataBytesPointer(a3, v36, v35, &v370, &v371, v18, v19, v20);
    if (v371) {
      goto LABEL_470;
    }
    int v10 = (void *)v48;
    int v359 = a4;
    size_t v49 = v370;
    if (v370 >= 0x1FFuLL)
    {
      unsigned int v51 = v370 + 2;
      __int128 v41 = (unsigned __int8 *)malloc(v370 + 2LL);
      if (!v41) {
        goto LABEL_612;
      }
      uint64_t v52 = (__int16 *)v41;
      __int128 v50 = v41;
    }

    else
    {
      __int128 v50 = 0LL;
      unsigned int v51 = 512;
      uint64_t v52 = word_100164338;
    }

    if (v11) {
      __int16 v116 = (os_log_s *)mDNSLogCategory_Default;
    }
    else {
      __int16 v116 = (os_log_s *)mDNSLogCategory_mDNS;
    }
    if (gSensitiveLoggingEnabled != 1 || v116 == (os_log_s *)mDNSLogCategory_State)
    {
      if (!os_log_type_enabled(v116, OS_LOG_TYPE_DEFAULT))
      {
LABEL_413:
        a4 = v359;
        if (!v50) {
          goto LABEL_470;
        }
        int v228 = v50;
LABEL_469:
        free(v228);
        goto LABEL_470;
      }

      int v117 = *(_DWORD *)(v369 + 184);
      unsigned int v118 = bswap32(*(unsigned __int16 *)(v368 + 320)) >> 16;
      int v121 = v9;
      size_t v364 = (size_t)v50;
      if (v368 == -612LL)
      {
LABEL_194:
        while (v121)
        {
          uint64_t v122 = *v121;
          if (!*v121)
          {
            unsigned __int16 v176 = (_WORD)v121 - (_WORD)v9 + 1;
            goto LABEL_409;
          }

          v121 += v122 + 1;
          if (v368 != -612LL) {
            goto LABEL_193;
          }
        }
      }

      else
      {
LABEL_193:
      }

      unsigned __int16 v176 = 257;
LABEL_409:
      int v217 = v176;
      unsigned int v218 = *(unsigned __int16 *)(a3 + 4);
      int v219 = v49 + 2;
      if ((int)v49 + 2 <= v51)
      {
        *uint64_t v52 = __rev16(v218);
        size_t v224 = v49;
        v225 = v10;
        int v226 = v117;
        LODWORD(v10) = v118;
        int v227 = v176;
        memcpy(v52 + 1, v225, v224);
        int v217 = v227;
        unsigned int v118 = v10;
        int v117 = v226;
      }

      else
      {
        uint64_t v52 = 0LL;
      }
    }

    else
    {
      if (v11) {
        __int16 v116 = (os_log_s *)mDNSLogCategory_Default_redacted;
      }
      else {
        __int16 v116 = (os_log_s *)mDNSLogCategory_mDNS;
      }
      if (!os_log_type_enabled(v116, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_413;
      }
      int v117 = *(_DWORD *)(v369 + 184);
      unsigned int v118 = bswap32(*(unsigned __int16 *)(v368 + 320)) >> 16;
      int v119 = v9;
      size_t v364 = (size_t)v50;
      if (v368 == -612LL)
      {
LABEL_183:
        while (v119)
        {
          uint64_t v120 = *v119;
          if (!*v119)
          {
            unsigned __int16 v175 = (_WORD)v119 - (_WORD)v9 + 1;
            goto LABEL_405;
          }

          v119 += v120 + 1;
          if (v368 != -612LL) {
            goto LABEL_182;
          }
        }
      }

      else
      {
LABEL_182:
      }

      unsigned __int16 v175 = 257;
LABEL_405:
      int v217 = v175;
      unsigned int v218 = *(unsigned __int16 *)(a3 + 4);
      int v219 = v49 + 2;
      if ((int)v49 + 2 <= v51)
      {
        *uint64_t v52 = __rev16(v218);
        int v220 = v10;
        size_t v221 = v49;
        int v222 = v117;
        LODWORD(v10) = v118;
        int v223 = v175;
        memcpy(v52 + 1, v220, v221);
        int v217 = v223;
        unsigned int v118 = v10;
        int v117 = v222;
      }

      else
      {
        uint64_t v52 = 0LL;
      }
    }

    LODWORD(__tp.tv_sec) = 67112195;
    HIDWORD(__tp.tv_sec) = v117;
    LOWORD(__tp.tv_nsec) = 1024;
    *(_DWORD *)((char *)&__tp.tv_nsec + 2) = v118;
    HIWORD(__tp.tv_nsec) = 1024;
    *(_DWORD *)v376 = v359;
    *(_WORD *)&v376[4] = 1024;
    *(_DWORD *)&v376[6] = 0;
    LOWORD(v377) = 1024;
    *(_DWORD *)((char *)&v377 + 2) = v366;
    HIWORD(v377) = 2160;
    *(void *)uint64_t v378 = 1752392040LL;
    *(_WORD *)&v378[8] = 1040;
    *(_DWORD *)&v378[10] = v217;
    *(_WORD *)&v378[14] = 2101;
    *(void *)&v378[16] = v9;
    *(_WORD *)&v378[24] = 1024;
    *(_DWORD *)&v378[26] = HIDWORD(v366);
    *(_WORD *)&v378[30] = 1024;
    *(_DWORD *)&v378[32] = v218;
    *(_WORD *)&v378[36] = 2160;
    *(void *)&v378[38] = 1752392040LL;
    *(_WORD *)&v378[46] = 1040;
    *(_DWORD *)&v378[48] = v219;
    *(_WORD *)&v378[52] = 2101;
    *(void *)&v378[54] = v52;
    _os_log_impl( (void *)&_mh_execute_header,  v116,  OS_LOG_TYPE_DEFAULT,  "[R%u->Q%u] DNSServiceResolve result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %d, name: %{sensi tive, mask.hash, mdnsresponder:domain_name}.*P (%x), type: %{mdns:rrtype}d, rdata: %{sensitive, mask.hash, mdns:rdata}.*P",  (uint8_t *)&__tp,  0x60u);
    __int128 v50 = (unsigned __int8 *)v364;
    goto LABEL_413;
  }

  uint64_t v21 = *(void *)(a3 + 56);
  if (v21)
  {
    uint64_t v22 = dnssec_obj_resource_record_member_get_validation_result(v21);
    unsigned int v23 = *(unsigned __int16 *)(a2 + 320);
    a2 = *(unsigned __int16 *)(a3 + 12);
    BOOL v24 = a2 < 0x201;
    if ((_DWORD)v22)
    {
      size_t v17 = v22;
      if (!v23)
      {
        if (a2 >= 0x201)
        {
          int v25 = a4;
          __int128 v41 = (unsigned __int8 *)malloc(*(unsigned __int16 *)(a3 + 12));
          __int128 v26 = v41;
          int v53 = (char *)v41;
          if (!v41) {
            goto LABEL_612;
          }
        }

        else
        {
          if (!*(_WORD *)(a3 + 12))
          {
            if (v11) {
              unint64_t v141 = (os_log_s *)mDNSLogCategory_Default;
            }
            else {
              unint64_t v141 = (os_log_s *)mDNSLogCategory_mDNS;
            }
            if (gSensitiveLoggingEnabled != 1 || v141 == (os_log_s *)mDNSLogCategory_State)
            {
              if (!os_log_type_enabled(v141, OS_LOG_TYPE_DEFAULT)) {
                goto LABEL_472;
              }
            }

            else
            {
              if (v11) {
                unint64_t v141 = (os_log_s *)mDNSLogCategory_Default_redacted;
              }
              else {
                unint64_t v141 = (os_log_s *)mDNSLogCategory_mDNS;
              }
              if (!os_log_type_enabled(v141, OS_LOG_TYPE_DEFAULT)) {
                goto LABEL_472;
              }
            }

            int v178 = *(_DWORD *)(v369 + 184);
            int v179 = *(unsigned __int16 *)(a3 + 4);
            LODWORD(__tp.tv_sec) = 67110656;
            HIDWORD(__tp.tv_sec) = v178;
            LOWORD(__tp.tv_nsec) = 1024;
            *(_DWORD *)((char *)&__tp.tv_nsec + 2) = a4;
            HIWORD(__tp.tv_nsec) = 1024;
            *(_DWORD *)v376 = 0;
            *(_WORD *)&v376[4] = 1024;
            *(_DWORD *)&v376[6] = v366;
            LOWORD(v377) = 1024;
            *(_DWORD *)((char *)&v377 + 2) = HIDWORD(v366);
            HIWORD(v377) = 1026;
            *(_DWORD *)uint64_t v378 = v17;
            *(_WORD *)&v378[4] = 1024;
            *(_DWORD *)&v378[6] = v179;
            int v161 = "[R%u->mDNS] DNSServiceResolve result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %d,"
                   " name hash: %x, dnssec: %{public, mdns:dnssec_result}d, type: %{mdns:rrtype}d, rdata: <none>";
            __int16 v162 = v141;
            uint32_t v163 = 44;
            goto LABEL_611;
          }

          int v25 = a4;
          __int128 v26 = 0LL;
          int v53 = (char *)&unk_100164138;
          LODWORD(a2) = 512;
        }

        int v371 = 0;
        unsigned __int16 v370 = 0;
        uint64_t v88 = ResourceRecordGetRDataBytesPointer(a3, v53, a2, &v370, &v371, v18, v19, v20);
        if (!v371)
        {
          char v89 = (const void *)v88;
          size_t v90 = v370;
          if (v370 >= 0x1FFuLL)
          {
            unsigned int v91 = v370 + 2;
            __int128 v41 = (unsigned __int8 *)malloc(v370 + 2LL);
            if (!v41) {
              goto LABEL_612;
            }
            int v92 = (__int16 *)v41;
            size_t v364 = (size_t)v41;
          }

          else
          {
            size_t v364 = 0LL;
            unsigned int v91 = 512;
            int v92 = word_100164338;
          }

          if (v11) {
            int v10 = (void *)mDNSLogCategory_Default;
          }
          else {
            int v10 = (void *)mDNSLogCategory_mDNS;
          }
          if (gSensitiveLoggingEnabled != 1 || v10 == (void *)mDNSLogCategory_State)
          {
            if (!os_log_type_enabled((os_log_t)v10, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_440;
            }
            int v166 = *(_DWORD *)(v369 + 184);
            unsigned int v167 = *(unsigned __int16 *)(a3 + 4);
            int v168 = v90 + 2;
            if ((int)v90 + 2 <= v91)
            {
              *int v92 = __rev16(v167);
              uint64_t v255 = v89;
              unsigned int v256 = v167;
              int v257 = v166;
              memcpy(v92 + 1, v255, v90);
              int v166 = v257;
              unsigned int v167 = v256;
            }

            else
            {
              int v92 = 0LL;
            }
          }

          else
          {
            if (v11) {
              int v10 = (void *)mDNSLogCategory_Default_redacted;
            }
            else {
              int v10 = (void *)mDNSLogCategory_mDNS;
            }
            if (!os_log_type_enabled((os_log_t)v10, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_440;
            }
            int v166 = *(_DWORD *)(v369 + 184);
            unsigned int v167 = *(unsigned __int16 *)(a3 + 4);
            int v168 = v90 + 2;
            if ((int)v90 + 2 <= v91)
            {
              *int v92 = __rev16(v167);
              v252 = v89;
              unsigned int v253 = v167;
              int v254 = v166;
              memcpy(v92 + 1, v252, v90);
              int v166 = v254;
              unsigned int v167 = v253;
            }

            else
            {
              int v92 = 0LL;
            }
          }

          LODWORD(__tp.tv_sec) = 67111427;
          HIDWORD(__tp.tv_sec) = v166;
          LOWORD(__tp.tv_nsec) = 1024;
          *(_DWORD *)((char *)&__tp.tv_nsec + 2) = v25;
          HIWORD(__tp.tv_nsec) = 1024;
          *(_DWORD *)v376 = 0;
          *(_WORD *)&v376[4] = 1024;
          *(_DWORD *)&v376[6] = v366;
          LOWORD(v377) = 1024;
          *(_DWORD *)((char *)&v377 + 2) = HIDWORD(v366);
          HIWORD(v377) = 1026;
          *(_DWORD *)uint64_t v378 = v17;
          *(_WORD *)&v378[4] = 1024;
          *(_DWORD *)&v378[6] = v167;
          *(_WORD *)&v378[10] = 2160;
          *(void *)&v378[12] = 1752392040LL;
          *(_WORD *)&v378[20] = 1040;
          *(_DWORD *)&v378[22] = v168;
          *(_WORD *)&v378[26] = 2101;
          *(void *)&v378[28] = v92;
          uint64_t v206 = "[R%u->mDNS] DNSServiceResolve result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %d, n"
                 "ame hash: %x, dnssec: %{public, mdns:dnssec_result}d, type: %{mdns:rrtype}d, rdata: %{sensitive, mask.h"
                 "ash, mdns:rdata}.*P";
          uint64_t v207 = (os_log_s *)v10;
          uint32_t v208 = 70;
          goto LABEL_439;
        }

LABEL_397:
            LODWORD(__tp.tv_sec) = 67111683;
            HIDWORD(__tp.tv_sec) = v127;
            LOWORD(__tp.tv_nsec) = 1024;
            *(_DWORD *)((char *)&__tp.tv_nsec + 2) = v128;
            HIWORD(__tp.tv_nsec) = 1024;
            *(_DWORD *)v376 = v25;
            *(_WORD *)&v376[4] = 1024;
            *(_DWORD *)&v376[6] = 0;
            LOWORD(v377) = 1024;
            *(_DWORD *)((char *)&v377 + 2) = v366;
            HIWORD(v377) = 1024;
            *(_DWORD *)uint64_t v378 = HIDWORD(v366);
            *(_WORD *)&v378[4] = 1026;
            *(_DWORD *)&v378[6] = v17;
            *(_WORD *)&v378[10] = 1024;
            *(_DWORD *)&v378[12] = v129;
            *(_WORD *)&v378[16] = 2160;
            *(void *)&v378[18] = 1752392040LL;
            *(_WORD *)&v378[26] = 1040;
            *(_DWORD *)&v378[28] = v130;
            *(_WORD *)&v378[32] = 2101;
            *(void *)&v378[34] = v68;
            uint64_t v206 = "[R%u->Q%u] DNSServiceResolve result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %d, "
                   "name hash: %x, dnssec: %{public, mdns:dnssec_result}d, type: %{mdns:rrtype}d, rdata: %{sensitive, mas"
                   "k.hash, mdns:rdata}.*P";
            uint64_t v207 = (os_log_s *)v10;
            uint32_t v208 = 76;
LABEL_439:
            _os_log_impl((void *)&_mh_execute_header, v207, OS_LOG_TYPE_DEFAULT, v206, (uint8_t *)&__tp, v208);
          }

LABEL_394:
      LODWORD(__tp.tv_sec) = 67111427;
      HIDWORD(__tp.tv_sec) = v112;
      LOWORD(__tp.tv_nsec) = 1024;
      *(_DWORD *)((char *)&__tp.tv_nsec + 2) = v113;
      HIWORD(__tp.tv_nsec) = 1024;
      *(_DWORD *)v376 = v43;
      *(_WORD *)&v376[4] = 1024;
      *(_DWORD *)&v376[6] = 0;
      LOWORD(v377) = 1024;
      *(_DWORD *)((char *)&v377 + 2) = v366;
      HIWORD(v377) = 1024;
      *(_DWORD *)uint64_t v378 = HIDWORD(v366);
      *(_WORD *)&v378[4] = 1024;
      *(_DWORD *)&v378[6] = v114;
      *(_WORD *)&v378[10] = 2160;
      *(void *)&v378[12] = 1752392040LL;
      *(_WORD *)&v378[20] = 1040;
      *(_DWORD *)&v378[22] = v115;
      *(_WORD *)&v378[26] = 2101;
      *(void *)&v378[28] = v47;
      __int128 v193 = "[R%u->Q%u] DNSServiceResolve result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %d, name h"
             "ash: %x, type: %{mdns:rrtype}d, rdata: %{sensitive, mask.hash, mdns:rdata}.*P";
      uint64_t v194 = v111;
      uint32_t v195 = 70;
LABEL_422:
      _os_log_impl((void *)&_mh_execute_header, v194, OS_LOG_TYPE_DEFAULT, v193, (uint8_t *)&__tp, v195);
    }

LABEL_470:
  if (v26) {
    free(v26);
  }
LABEL_472:
  int v276 = *(unsigned __int16 *)(a3 + 4);
  uint64_t v277 = v369;
  if (v276 != 33 && v276 != 16) {
    return;
  }
  uint64_t v278 = *(void *)(v369 + 120);
  if (!a4)
  {
    if (v276 == 33)
    {
      unsigned int v281 = *(void **)(v278 + 1312);
      if (v281)
      {
        free(v281);
        *(void *)(v278 + 1312) = 0LL;
      }

      *(_WORD *)(v278 + 132_Block_object_dispose(va, 8) = 0;
LABEL_520:
      *(_BYTE *)(v278 + 1337) = 0;
      goto LABEL_521;
    }

    v283 = *(void **)(v278 + 1320);
    if (v283)
    {
      free(v283);
      *(void *)(v278 + 1320) = 0LL;
    }

    *(_WORD *)(v278 + 1330) = 0;
LABEL_505:
    *(_BYTE *)(v278 + 133_Block_object_dispose(va, 8) = 0;
    goto LABEL_521;
  }

  int v279 = *(unsigned __int8 *)a3;
  if (v276 != 33)
  {
    int v282 = *(void **)(v278 + 1320);
    if (v282)
    {
      free(v282);
      *(void *)(v278 + 1320) = 0LL;
    }

    if (v279 == 240)
    {
      *(_WORD *)(v278 + 1330) = 0;
      *(_BYTE *)(v278 + 133_Block_object_dispose(va, 8) = 1;
      goto LABEL_521;
    }

    uint64_t v289 = *(void *)(a3 + 40);
    size_t v17 = *(unsigned __int16 *)(a3 + 12);
    else {
      size_t v290 = *(unsigned __int16 *)(a3 + 12);
    }
    __int128 v41 = (unsigned __int8 *)calloc(1uLL, v290);
    if (!v41) {
      goto LABEL_612;
    }
    *(void *)(v278 + 1320) = v41;
    memcpy(v41, (const void *)(v289 + 4), v17);
    *(_WORD *)(v278 + 1330) = v17;
    goto LABEL_505;
  }

  int v280 = *(void **)(v278 + 1312);
  if (v280)
  {
    free(v280);
    *(void *)(v278 + 1312) = 0LL;
  }

  if (v279 == 240)
  {
    *(_WORD *)(v278 + 132_Block_object_dispose(va, 8) = 0;
    *(_BYTE *)(v278 + 1337) = 1;
    goto LABEL_521;
  }

  uint64_t v284 = *(void *)(a3 + 40);
  size_t v17 = v284 + 10;
  unint64_t v285 = v284 + 266;
  int v286 = (_BYTE *)(v284 + 10);
  if (!v285) {
    goto LABEL_495;
  }
LABEL_492:
  LOWORD(v287) = 257;
  while (1)
  {
    uint64_t v288 = *v286;
    if (v288 > 0x3F)
    {
LABEL_506:
      LOWORD(v287) = 257;
      goto LABEL_508;
    }

    if (!*v286) {
      break;
    }
    v286 += v288 + 1;
    if (v285) {
      goto LABEL_492;
    }
LABEL_495:
    if (!v286) {
      goto LABEL_506;
    }
  }

  int v287 = (unsigned __int16)((_WORD)v286 - v17) + 1;
  if ((v287 & 0x10000) == 0)
  {
LABEL_508:
    __int128 v41 = (unsigned __int8 *)calloc(1uLL, (unsigned __int16)v287);
    if (!v41) {
      goto LABEL_612;
    }
    *(void *)(v278 + 1312) = v41;
    uint64_t v291 = (_BYTE *)v17;
    if (v285)
    {
LABEL_510:
    }

    else
    {
LABEL_511:
      while (v291)
      {
        uint64_t v292 = *v291;
        if (!*v291)
        {
          unsigned __int16 v293 = (_WORD)v291 - v17 + 1;
          if (v293 > 0x100u) {
            break;
          }
          memcpy(v41, (const void *)v17, v293);
          goto LABEL_519;
        }

        v291 += v292 + 1;
        if (v285) {
          goto LABEL_510;
        }
      }
    }

    *__int128 v41 = 0;
LABEL_519:
    *(_WORD *)(v278 + 132_Block_object_dispose(va, 8) = *(_WORD *)(*(void *)(a3 + 40) + 8LL);
    goto LABEL_520;
  }

LABEL_521:
  LODWORD(v10) = *(unsigned __int8 *)(v278 + 1337);
  if (*(_BYTE *)(v278 + 1337)) {
    BOOL v294 = 1;
  }
  else {
    BOOL v294 = *(void *)(v278 + 1312) != 0LL;
  }
  if (*(_BYTE *)(v278 + 1338))
  {
    BOOL v295 = 1;
    if (!v294) {
      return;
    }
  }

  else
  {
    BOOL v295 = *(void *)(v278 + 1320) != 0LL;
    if (!v294) {
      return;
    }
  }

  if (v295)
  {
    int v296 = -65549;
    if (*(_BYTE *)(v278 + 1337)) {
      int v297 = -65554;
    }
    else {
      int v297 = 0;
    }
    unsigned int v362 = v297;
    ConvertDomainNameToCString_withescape(*(unsigned __int8 **)(a3 + 32), (unsigned __int8 *)__s);
    if (*(_BYTE *)(v278 + 1337))
    {
      int v361 = 0;
      uint64_t v366 = 0LL;
      LOBYTE(v370) = 0;
    }

    else
    {
      uint64_t v303 = *(unsigned __int8 **)(v278 + 1312);
      ConvertDomainNameToCString_withescape(v303, (unsigned __int8 *)&__src);
      int v361 = mDNS_DomainNameFNV1aHash(v303);
      int v304 = *(unsigned __int8 *)(v278 + 1337);
      LOBYTE(v370) = 0;
      if (!v304)
      {
        uint64_t v305 = *(unsigned __int8 **)(v278 + 1312);
        LODWORD(v366) = *(unsigned __int8 *)(v278 + 1328);
        HIDWORD(v366) = *(unsigned __int8 *)(v278 + 1329);
LABEL_537:
        if (*(_BYTE *)(v278 + 1338))
        {
          unsigned int v306 = 0;
          size_t v364 = (size_t)&v370;
        }

        else
        {
          size_t v364 = *(void *)(v278 + 1320);
          unsigned int v306 = *(unsigned __int16 *)(v278 + 1330);
        }

        LODWORD(v367) = mDNSPlatformInterfaceIndexfromInterfaceID( v367,  *(void *)(a3 + 24),  0LL,  v298,  v299,  v300,  v301,  v302);
        size_t v17 = strlen(__s);
        a3 = v306;
        size_t v363 = v17 + v306 + strlen(&__src) + 18;
        if (*(_BYTE *)(v369 + 274))
        {
          unsigned int v312 = 0;
          unsigned __int16 v313 = 0LL;
          if (a4)
          {
            uint64_t v314 = *(void *)(v369 + 48);
            if (v314)
            {
              if (*(_UNKNOWN ***)(v314 + 16) != &_mdns_signed_browse_result_kind)
              {
                unsigned __int16 v315 = (os_log_s *)mDNSLogCategory_mDNS;
                if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
                {
                  unsigned int v316 = v362;
                  if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_ERROR))
                  {
LABEL_569:
                    int v331 = *(_DWORD *)(v369 + 184);
                    unsigned int v332 = bswap32(*(unsigned __int16 *)(v368 + 320));
                    LODWORD(__tp.tv_sec) = 67109376;
                    HIDWORD(__tp.tv_sec) = v331;
                    LOWORD(__tp.tv_nsec) = 1024;
                    *(_DWORD *)((char *)&__tp.tv_nsec + 2) = HIWORD(v332);
                    _os_log_impl( (void *)&_mh_execute_header,  v315,  OS_LOG_TYPE_ERROR,  "[R%u->Q%u] resolve_result_callback mdns_signed_resolve_result_downcast failed",  (uint8_t *)&__tp,  0xEu);
                  }
                }

                else
                {
                  unsigned __int16 v315 = (os_log_s *)mDNSLogCategory_mDNS_redacted;
                  unsigned int v316 = v362;
                  if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_ERROR)) {
                    goto LABEL_569;
                  }
                }

                unsigned __int16 v313 = 0LL;
LABEL_571:
                uint64_t v333 = (os_log_s *)mDNSLogCategory_mDNS;
                if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
                {
                  if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_ERROR))
                  {
LABEL_576:
                    int v334 = *(_DWORD *)(v277 + 184);
                    unsigned int v335 = bswap32(*(unsigned __int16 *)(v368 + 320));
                    LODWORD(__tp.tv_sec) = 67109632;
                    HIDWORD(__tp.tv_sec) = v334;
                    LOWORD(__tp.tv_nsec) = 1024;
                    *(_DWORD *)((char *)&__tp.tv_nsec + 2) = HIWORD(v335);
                    HIWORD(__tp.tv_nsec) = 2048;
                    *(void *)v376 = v296;
                    _os_log_impl( (void *)&_mh_execute_header,  v333,  OS_LOG_TYPE_ERROR,  "[R%u->Q%u] resolve_result_callback signed_resolve failed %ld",  (uint8_t *)&__tp,  0x18u);
                  }
                }

                else
                {
                  uint64_t v333 = (os_log_s *)mDNSLogCategory_mDNS_redacted;
                  if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_ERROR)) {
                    goto LABEL_576;
                  }
                }

                int v317 = 0LL;
                unsigned int v312 = 0;
                goto LABEL_578;
              }

              bzero(&__tp, 0x3F1uLL);
              int v318 = DomainNameToString(v305, 0LL, (unsigned __int8 *)&__tp, 0LL);
              if (v318)
              {
                int v296 = v318;
                unsigned __int16 v313 = 0LL;
                goto LABEL_617;
              }

              uint64_t v319 = *(void *)(v314 + 32);
              size_t v320 = strlen((const char *)&__tp);
              if (v320 >> 16)
              {
                unsigned __int16 v313 = 0LL;
                int v296 = -6743;
                goto LABEL_617;
              }

              size_t v321 = v320;
              uint64_t v322 = v320 + *(unsigned __int16 *)(v319 + 56) + 62;
              __int128 v41 = (unsigned __int8 *)calloc(1uLL, v322);
              if (v41)
              {
                size_t v17 = (size_t)v41;
                uint64_t v323 = (uint64_t)(v41 + 32);
                uuid_copy(v41 + 32, (const unsigned __int8 *)(v319 + 32));
                int v324 = _mdns_signed_result_compute_metadata_hash(v323, v367, (unsigned __int8 *)v364, a3);
                *(_DWORD *)(v17 + 4_Block_object_dispose(va, 8) = 6;
                *(_DWORD *)(v17 + 52) = v324;
                size_t v325 = *(unsigned __int16 *)(v319 + 56);
                *(_WORD *)(v17 + 56) = v325;
                *(_WORD *)(v17 + 5_Block_object_dispose(va, 8) = v366 | (WORD2(v366) << 8);
                *(_WORD *)(v17 + 60) = v321;
                memcpy((void *)(v17 + 62), (const void *)(v319 + 58), v325);
                memcpy((void *)(v17 + 62 + v325), &__tp, v321);
                LODWORD(v41) = _mdns_necp_sign_result(v17, v322);
                if (!(_DWORD)v41)
                {
                  LODWORD(v41) = _mdns_necp_validate_result(v17, v322);
                  int v371 = (int)v41;
                  uint64_t v277 = v369;
                  if (!(_DWORD)v41)
                  {
                    uint64_t v326 = _mdns_signed_resolve_result_create_no_copy(v305, v17, v322, &v371);
                    unsigned __int16 v313 = (void *)v326;
                    int v296 = v371;
                    if (!v371)
                    {
                      if (v326)
                      {
                        __tp.unsigned __int16 tv_sec = 0LL;
                        data = mdns_signed_result_get_data(v326, &__tp);
                        unsigned __int16 tv_sec = __tp.tv_sec;
                        if (__tp.tv_sec >= 0x10000uLL) {
                          unsigned __int16 tv_sec = 0;
                        }
                        unsigned int v312 = tv_sec;
                        if (__tp.tv_sec >= 0x10000uLL) {
                          uint64_t v329 = 0LL;
                        }
                        else {
                          uint64_t v329 = LOWORD(__tp.tv_sec) + 4LL;
                        }
                        unint64_t v330 = v363 + v329;
                        if (__tp.tv_sec >= 0x10000uLL) {
                          int v317 = 0LL;
                        }
                        else {
                          int v317 = data;
                        }
                        unsigned int v316 = v362;
LABEL_579:
                        xpc_object_t reply = create_reply((char *)0x43, v330, v277, v307, v308, v309, v310, v311);
                        *((_DWORD *)reply + 11) = 0;
                        *((_DWORD *)reply + 12) = bswap32(v367);
                        *((_DWORD *)reply + 13) = bswap32(v316);
                        size_t v337 = strlen(__s) + 1;
                        memcpy(reply + 56, __s, v337);
                        uint64_t v338 = &reply[v337 + 56];
                        size_t v339 = strlen(&__src) + 1;
                        memcpy(v338, &__src, v339);
                        v340 = &v338[v339];
                        char *v340 = v366;
                        v340[1] = BYTE4(v366);
                        v340[2] = BYTE1(a3);
                        uint64_t v341 = (uint64_t)&v338[v339 + 4];
                        v340[3] = a3;
                        memcpy(v340 + 4, (const void *)v364, a3);
                        if (v317)
                        {
                          unint64_t v342 = v341 + a3;
                          if (v341 + a3)
                          {
                            if (v342 <= v342 + v330 && v330 >= (unint64_t)v312 + 4)
                            {
                              *(_WORD *)unint64_t v342 = 1792;
                              *(_BYTE *)(v342 + 2) = BYTE1(v312);
                              *(_BYTE *)(v342 + 3) = v312;
                              if (v312) {
                                memcpy((void *)(v342 + 4), v317, v312);
                              }
                            }
                          }

                          *((_DWORD *)reply + 6) |= 2u;
                        }

                        if (v313) {
                          os_release(v313);
                        }
                        char v343 = gSensitiveLoggingEnabled;
                        uint64_t v344 = mDNSLogCategory_mDNS;
                        if (mDNSLogCategory_mDNS == mDNSLogCategory_State) {
                          char v343 = 0;
                        }
                        if ((_DWORD)v10)
                        {
                          if ((v343 & 1) != 0)
                          {
                            uint64_t v345 = mDNSLogCategory_mDNS_redacted;
                            if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
                            {
                              int v346 = *(_DWORD *)(v277 + 184);
                              unsigned int v347 = bswap32(*(unsigned __int16 *)(v368 + 320));
                              LODWORD(__tp.tv_sec) = 67110147;
                              HIDWORD(__tp.tv_sec) = v346;
                              LOWORD(__tp.tv_nsec) = 1024;
                              *(_DWORD *)((char *)&__tp.tv_nsec + 2) = HIWORD(v347);
                              HIWORD(__tp.tv_nsec) = 2160;
                              *(void *)v376 = 1752392040LL;
                              *(_WORD *)&v376[8] = 2085;
                              __int16 v377 = __s;
                              *(_WORD *)uint64_t v378 = 1024;
                              *(_DWORD *)&v378[2] = v365;
                              v348 = "[R%d->Q%d] DNSServiceResolve(%{sensitive, mask.hash}s (%x)) NoSuchRecord";
                              uint64_t v349 = (os_log_s *)v345;
LABEL_599:
                              uint32_t v355 = 40;
LABEL_603:
                              _os_log_impl( (void *)&_mh_execute_header,  v349,  OS_LOG_TYPE_DEFAULT,  v348,  (uint8_t *)&__tp,  v355);
                            }
                          }

                          else if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
                          {
                            int v353 = *(_DWORD *)(v277 + 184);
                            unsigned int v354 = bswap32(*(unsigned __int16 *)(v368 + 320));
                            LODWORD(__tp.tv_sec) = 67110147;
                            HIDWORD(__tp.tv_sec) = v353;
                            LOWORD(__tp.tv_nsec) = 1024;
                            *(_DWORD *)((char *)&__tp.tv_nsec + 2) = HIWORD(v354);
                            HIWORD(__tp.tv_nsec) = 2160;
                            *(void *)v376 = 1752392040LL;
                            *(_WORD *)&v376[8] = 2085;
                            __int16 v377 = __s;
                            *(_WORD *)uint64_t v378 = 1024;
                            *(_DWORD *)&v378[2] = v365;
                            v348 = "[R%d->Q%d] DNSServiceResolve(%{sensitive, mask.hash}s (%x)) NoSuchRecord";
                            uint64_t v349 = (os_log_s *)v344;
                            goto LABEL_599;
                          }

LABEL_604:
                          append_reply(v277, reply);
                          return;
                        }

                        if ((v343 & 1) != 0)
                        {
                          uint64_t v350 = mDNSLogCategory_mDNS_redacted;
                          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
                            goto LABEL_604;
                          }
                          int v351 = *(_DWORD *)(v277 + 184);
                          unsigned int v352 = bswap32(*(unsigned __int16 *)(v368 + 320));
                          LODWORD(__tp.tv_sec) = 67111171;
                          HIDWORD(__tp.tv_sec) = v351;
                          LOWORD(__tp.tv_nsec) = 1024;
                          *(_DWORD *)((char *)&__tp.tv_nsec + 2) = HIWORD(v352);
                          HIWORD(__tp.tv_nsec) = 2160;
                          *(void *)v376 = 1752392040LL;
                          *(_WORD *)&v376[8] = 2085;
                          __int16 v377 = __s;
                          *(_WORD *)uint64_t v378 = 1024;
                          *(_DWORD *)&v378[2] = v365;
                          *(_WORD *)&v378[6] = 2160;
                          *(void *)&v378[8] = 1752392040LL;
                          *(_WORD *)&v378[16] = 2085;
                          *(void *)&v378[18] = &__src;
                          *(_WORD *)&v378[26] = 1024;
                          *(_DWORD *)&v378[28] = v361;
                          *(_WORD *)&v378[32] = 1024;
                          *(_DWORD *)&v378[34] = __rev16(v366 | (HIDWORD(v366) << 8));
                          v348 = "[R%d->Q%d] DNSServiceResolve(%{sensitive, mask.hash}s (%x)) RESULT   %{sensitive, mask.hash}s (%x):%d";
                          uint64_t v349 = (os_log_s *)v350;
                        }

                        else
                        {
                          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
                            goto LABEL_604;
                          }
                          int v356 = *(_DWORD *)(v277 + 184);
                          unsigned int v357 = bswap32(*(unsigned __int16 *)(v368 + 320));
                          LODWORD(__tp.tv_sec) = 67111171;
                          HIDWORD(__tp.tv_sec) = v356;
                          LOWORD(__tp.tv_nsec) = 1024;
                          *(_DWORD *)((char *)&__tp.tv_nsec + 2) = HIWORD(v357);
                          HIWORD(__tp.tv_nsec) = 2160;
                          *(void *)v376 = 1752392040LL;
                          *(_WORD *)&v376[8] = 2085;
                          __int16 v377 = __s;
                          *(_WORD *)uint64_t v378 = 1024;
                          *(_DWORD *)&v378[2] = v365;
                          *(_WORD *)&v378[6] = 2160;
                          *(void *)&v378[8] = 1752392040LL;
                          *(_WORD *)&v378[16] = 2085;
                          *(void *)&v378[18] = &__src;
                          *(_WORD *)&v378[26] = 1024;
                          *(_DWORD *)&v378[28] = v361;
                          *(_WORD *)&v378[32] = 1024;
                          *(_DWORD *)&v378[34] = __rev16(v366 | (HIDWORD(v366) << 8));
                          v348 = "[R%d->Q%d] DNSServiceResolve(%{sensitive, mask.hash}s (%x)) RESULT   %{sensitive, mask.hash}s (%x):%d";
                          uint64_t v349 = (os_log_s *)v344;
                        }

                        uint32_t v355 = 72;
                        goto LABEL_603;
                      }

                      int v296 = 0;
                      goto LABEL_607;
                    }

                    goto LABEL_614;
                  }
                }

LABEL_613:
                int v296 = (int)v41;
                unsigned __int16 v313 = 0LL;
LABEL_614:
                free((void *)v17);
LABEL_617:
                uint64_t v277 = v369;
LABEL_607:
                unsigned int v316 = v362;
                goto LABEL_571;
              }

LABEL_612:
              __break(1u);
              goto LABEL_613;
            }
          }

          int v317 = 0LL;
        }

        else
        {
          unsigned __int16 v313 = 0LL;
          int v317 = 0LL;
          unsigned int v312 = 0;
        }

        unsigned int v316 = v362;
LABEL_578:
        unint64_t v330 = v363;
        goto LABEL_579;
      }

      uint64_t v366 = 0LL;
    }

    uint64_t v305 = (unsigned __int8 *)&v370;
    goto LABEL_537;
  }

                    if (v70) {
                      goto LABEL_566;
                    }
                  }

                  goto LABEL_613;
                default:
                  if (v109)
                  {
                    if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
                      dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
                    }
                    if (_GetCUSymAddr_DataBuffer_AppendF_sAddr)
                    {
                      int v95 = v63;
                      size_t v70 = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v115, "[%u B]");
                      goto LABEL_566;
                    }
                  }

                  else
                  {
                    if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
                      dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
                    }
                    if (_GetCUSymAddr_DataBuffer_AppendF_sAddr)
                    {
                      int v97 = v63;
                      uint64_t v99 = v63;
                      int v95 = (unint64_t)(v60 + 4);
                      size_t v70 = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v115, "'%H'");
                      goto LABEL_566;
                    }
                  }

                  goto LABEL_619;
              }

              break;
            default:
              switch((int)v67)
              {
                case '@':
                  int v68 = "SUBSCRIBE";
                  goto LABEL_437;
                case 'A':
                  int v68 = "PUSH";
                  goto LABEL_437;
                case 'B':
                  int v68 = "UNSUBSCRIBE";
                  goto LABEL_437;
                case 'C':
                  int v68 = "RECONFIRM";
                  goto LABEL_437;
                default:
                  if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
                    dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
                  }
                  if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr) {
                    goto LABEL_636;
                  }
                  int v95 = v67;
                  uint64_t v69 = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v115, "DSO-TYPE%u: ");
                  break;
              }

              goto LABEL_441;
          }

          while (1)
          {
            int v119 = 0LL;
            uint64_t v120 = 0LL;
            int v117 = 0;
            unsigned int v118 = 0;
            memset(v127, 0, sizeof(v127));
            size_t v70 = _DNSMessageExtractRecordEx( (unint64_t)a1,  a2,  v64,  (char *)v127,  (_WORD *)&v117 + 1,  &v117,  &v118,  &v120,  &v119,  0LL,  0LL,  0LL,  0LL,  &v122);
            if (v70)
            {
LABEL_566:
              __int16 v84 = v70;
              goto LABEL_614;
            }

            size_t v70 = DomainNameToString((unsigned __int8 *)v127, 0LL, (unsigned __int8 *)__src, 0LL);
            if (v70) {
              goto LABEL_566;
            }
            if (v109 && _NameIsPrivate((const char *)__src))
            {
              if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
                dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
              }
              if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr) {
                goto LABEL_619;
              }
              int v95 = (unint64_t)__src;
              size_t v70 = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v115, "%~s");
            }

            else
            {
              if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
                dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
              }
              if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr) {
                goto LABEL_619;
              }
              int v95 = (unint64_t)__src;
              size_t v70 = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v115, "%s");
            }

            if (v70) {
              goto LABEL_566;
            }
            if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
              dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
            }
            if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr)
            {
LABEL_619:
              __int16 v84 = -6735;
              goto LABEL_614;
            }

            size_t v70 = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v115, " 0x%08X", v118);
            if (v70) {
              goto LABEL_566;
            }
            int v72 = "ANY";
            else {
              uint64_t v73 = v72;
            }
            if (v73)
            {
              if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
                dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
              }
              if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr) {
                goto LABEL_619;
              }
              int v95 = (unint64_t)v73;
              size_t v70 = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v115, " %s");
            }

            else
            {
              if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
                dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
              }
              if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr) {
                goto LABEL_619;
              }
              int v95 = (unsigned __int16)v117;
              size_t v70 = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v115, " CLASS%u");
            }

            if (v70) {
              goto LABEL_566;
            }
            size_t v74 = DNSRecordTypeValueToString(HIWORD(v117));
            if (v74)
            {
              unsigned int v75 = v74;
              if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
                dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
              }
              if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr) {
                goto LABEL_619;
              }
              int v95 = (unint64_t)v75;
              size_t v70 = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v115, " %s");
            }

            else
            {
              if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
                dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
              }
              if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr) {
                goto LABEL_619;
              }
              int v95 = HIWORD(v117);
              size_t v70 = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v115, " TYPE%u");
            }

            if (v70) {
              goto LABEL_566;
            }
            DNSRecordDataToStringEx(v120, v119, HIWORD(v117), (unint64_t)a1, a2, v109, (uint64_t)&v121);
            if (v121)
            {
              if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
                dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
              }
              if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr) {
                goto LABEL_619;
              }
              size_t v70 = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v115, " %s", (const char *)v121);
              if (v70) {
                goto LABEL_566;
              }
              if (v121)
              {
                free(v121);
                int v121 = 0LL;
              }
            }

            else
            {
              if (v109)
              {
                if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
                  dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
                }
                if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr) {
                  goto LABEL_619;
                }
                int v95 = v119;
                size_t v70 = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v115, " [%zu B]");
              }

              else
              {
                if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
                  dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
                }
                if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr) {
                  goto LABEL_619;
                }
                int v97 = v119;
                uint64_t v99 = v119;
                int v95 = (unint64_t)v120;
                size_t v70 = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v115, " %#H");
              }

              if (v70) {
                goto LABEL_566;
              }
            }

            int v64 = (char *)v122;
            if ((unint64_t)v122 >= v66)
            {
LABEL_613:
              __int16 v84 = 0;
              goto LABEL_614;
            }
          }

          __int16 v84 = -6750;
LABEL_614:
          if (v121) {
            free(v121);
          }
          if (v84) {
            break;
          }
          int v60 = v114;
          int v61 = v106;
          uint64_t v59 = a1;
        }

        goto LABEL_636;
      }

unsigned __int8 *get_tracker_info_tlvs(uint64_t a1)
{
  uint64_t result = *(unsigned __int8 **)(a1 + 72);
  if (result)
  {
    if ((*(_BYTE *)(a1 + 208) & 2) != 0)
    {
      uint64_t result = (unsigned __int8 *)get_tlv_uint32(result, *(void *)(a1 + 80), 8, 0LL);
      *(_BYTE *)(a1 + 273) = (_DWORD)result != 0;
    }
  }

  return result;
}

void queryrecord_result_reply( uint64_t **a1, uint64_t a2, uint64_t a3, int a4, unsigned int a5, unsigned int a6, uint64_t a7)
{
  if (&_NEHelperTrackerGetAppInfo) {
    char v12 = 1;
  }
  else {
    char v12 = _os_feature_enabled_impl("symptomsd", "networking_transparency");
  }
  bzero(__s, 0x3F1uLL);
  if (a5 && (v12 & 1) != 0)
  {
    int v13 = *(unsigned __int16 *)(a3 + 4);
    v623 = 0LL;
    if (v13 == 28 || v13 == 1)
    {
      if (!*(_BYTE *)(a7 + 273)) {
        goto LABEL_19;
      }
      int v14 = 1;
      if (resolved_cache_get_tracker_state(a2, &v623, 0LL, 0LL, 0LL) == 2 && !v623)
      {
        uint64_t v15 = (os_log_s *)mDNSLogCategory_Default;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
        {
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_ERROR))
          {
LABEL_18:
            int v16 = *(_DWORD *)(a7 + 184);
            unsigned int v17 = bswap32(*(unsigned __int16 *)(a2 + 320)) >> 16;
            LODWORD(buf.tv_sec) = 67109376;
            HIDWORD(buf.tv_sec) = v16;
            LOWORD(buf.tv_nsec) = 1024;
            *(_DWORD *)((char *)&buf.tv_nsec + 2) = v17;
            _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_ERROR,  "[R%u->Q%u] queryrecord_result_reply NULL tracker hostname",  (uint8_t *)&buf,  0xEu);
          }
        }

        else
        {
          uint64_t v15 = (os_log_s *)mDNSLogCategory_Default_redacted;
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_ERROR)) {
            goto LABEL_18;
          }
        }

LABEL_947:
                int v490 = *(unsigned __int16 *)(a3 + 4);
                LODWORD(buf.tv_sec) = 67111683;
                HIDWORD(buf.tv_sec) = v209;
                LOWORD(buf.tv_nsec) = 1024;
                *(_DWORD *)((char *)&buf.tv_nsec + 2) = v210;
                HIWORD(buf.tv_nsec) = 1024;
                *(_DWORD *)v625 = v620;
                *(_WORD *)&v625[4] = 1024;
                *(_DWORD *)&v625[6] = a4;
                LOWORD(v626) = 1024;
                *(_DWORD *)((char *)&v626 + 2) = v606;
                HIWORD(v626) = 2160;
                *(void *)v627 = 1752392040LL;
                *(_WORD *)&v627[8] = 1040;
                *(_DWORD *)&v627[10] = v396;
                *(_WORD *)&v627[14] = 2101;
                *(void *)&v627[16] = a2 + 356;
                *(_WORD *)&v627[24] = 1024;
                *(_DWORD *)&v627[26] = v31;
                *(_WORD *)&v627[30] = 1026;
                *(_DWORD *)&v627[32] = v51;
                *(_WORD *)&v627[36] = 1024;
                *(_DWORD *)&v627[38] = v490;
                unsigned __int16 v216 = "[R%u->Q%u] DNSServiceGetAddrInfo result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifind"
                       "ex: %d, name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%x), dnssec: %{public, mdns:"
                       "dnssec_result}d, type: %{mdns:rrtype}d, rdata: <none>";
LABEL_948:
                int v317 = v204;
                uint32_t v318 = 76;
                goto LABEL_1087;
              }

              size_t v44 = 0LL;
              uint64_t v52 = (char *)&unk_100164138;
              LODWORD(v49) = 512;
            }

            int v622 = 0;
            unsigned __int16 v621 = 0;
            uint64_t RDataBytesPointer = ResourceRecordGetRDataBytesPointer(a3, v52, v49, &v621, &v622, v33, v34, v35);
            if (v622) {
              goto LABEL_972;
            }
            size_t v135 = v621;
            int v593 = v31;
            int v603 = v44;
            unsigned int v571 = (const void *)RDataBytesPointer;
            if (v621 >= 0x1FFuLL)
            {
              unsigned int v136 = v621 + 2;
              int v137 = (__int16 *)malloc(v621 + 2LL);
              if (!v137) {
                goto LABEL_1088;
              }
              int v131 = v137;
            }

            else
            {
              int v131 = 0LL;
              unsigned int v136 = 512;
              int v137 = word_100164338;
            }

            unsigned int v581 = v137;
            if (v27) {
              unsigned int v253 = (os_log_s *)mDNSLogCategory_Default;
            }
            else {
              unsigned int v253 = (os_log_s *)mDNSLogCategory_mDNS;
            }
            if (gSensitiveLoggingEnabled != 1 || v253 == (os_log_s *)mDNSLogCategory_State)
            {
              if (!os_log_type_enabled(v253, OS_LOG_TYPE_DEFAULT)) {
                goto LABEL_969;
              }
              int v258 = *(_DWORD *)(a7 + 184);
              unsigned int v259 = bswap32(*(unsigned __int16 *)(a2 + 320)) >> 16;
              uint64_t v277 = (_BYTE *)(a2 + 356);
              uint64_t v588 = a7;
              v569 = v131;
              if (a2 == -612)
              {
LABEL_527:
                while (v277)
                {
                  uint64_t v278 = *v277;
                  if (!*v277)
                  {
                    unsigned __int16 v354 = (_WORD)v277 - v30 + 1;
                    goto LABEL_903;
                  }

                  v277 += v278 + 1;
                  if (a2 != -612) {
                    goto LABEL_526;
                  }
                }
              }

              else
              {
LABEL_526:
              }

              unsigned __int16 v354 = 257;
LABEL_903:
              int v451 = v354;
              unsigned int v452 = *(unsigned __int16 *)(a3 + 4);
              int v453 = v135 + 2;
              if ((int)v135 + 2 <= v136)
              {
                *unsigned int v581 = __rev16(v452);
                size_t v461 = v135;
                int v462 = v258;
                unsigned int v463 = v259;
                memcpy(v581 + 1, v571, v461);
                unsigned int v259 = v463;
                int v258 = v462;
                int v454 = v581;
              }

              else
              {
                int v454 = 0LL;
              }
            }

            else
            {
              if (v27) {
                unsigned int v253 = (os_log_s *)mDNSLogCategory_Default_redacted;
              }
              else {
                unsigned int v253 = (os_log_s *)mDNSLogCategory_mDNS;
              }
              if (!os_log_type_enabled(v253, OS_LOG_TYPE_DEFAULT)) {
                goto LABEL_969;
              }
              int v258 = *(_DWORD *)(a7 + 184);
              unsigned int v259 = bswap32(*(unsigned __int16 *)(a2 + 320)) >> 16;
              unsigned int v260 = (_BYTE *)(a2 + 356);
              uint64_t v588 = a7;
              v569 = v131;
              if (a2 == -612)
              {
LABEL_485:
                while (v260)
                {
                  uint64_t v261 = *v260;
                  if (!*v260)
                  {
                    unsigned __int16 v352 = (_WORD)v260 - v30 + 1;
                    goto LABEL_895;
                  }

                  v260 += v261 + 1;
                  if (a2 != -612) {
                    goto LABEL_484;
                  }
                }
              }

              else
              {
LABEL_484:
              }

              unsigned __int16 v352 = 257;
LABEL_895:
              int v451 = v352;
              unsigned int v452 = *(unsigned __int16 *)(a3 + 4);
              int v453 = v135 + 2;
              if ((int)v135 + 2 <= v136)
              {
                *unsigned int v581 = __rev16(v452);
                size_t v455 = v135;
                int v456 = v258;
                unsigned int v457 = v259;
                memcpy(v581 + 1, v571, v455);
                unsigned int v259 = v457;
                int v258 = v456;
                int v454 = v581;
              }

              else
              {
                int v454 = 0LL;
              }
            }

            LODWORD(buf.tv_sec) = 67112451;
            HIDWORD(buf.tv_sec) = v258;
            LOWORD(buf.tv_nsec) = 1024;
            *(_DWORD *)((char *)&buf.tv_nsec + 2) = v259;
            HIWORD(buf.tv_nsec) = 1024;
            *(_DWORD *)v625 = v620;
            *(_WORD *)&v625[4] = 1024;
            *(_DWORD *)&v625[6] = a4;
            LOWORD(v626) = 1024;
            *(_DWORD *)((char *)&v626 + 2) = v606;
            HIWORD(v626) = 2160;
            *(void *)v627 = 1752392040LL;
            *(_WORD *)&v627[8] = 1040;
            *(_DWORD *)&v627[10] = v451;
            *(_WORD *)&v627[14] = 2101;
            *(void *)&v627[16] = a2 + 356;
            *(_WORD *)&v627[24] = 1024;
            *(_DWORD *)&v627[26] = v593;
            *(_WORD *)&v627[30] = 1026;
            *(_DWORD *)&v627[32] = v51;
            *(_WORD *)&v627[36] = 1024;
            *(_DWORD *)&v627[38] = v452;
            *(_WORD *)&v627[42] = 2160;
            *(void *)&v627[44] = 1752392040LL;
            *(_WORD *)&v627[52] = 1040;
            *(_DWORD *)&v627[54] = v453;
            *(_WORD *)&v627[58] = 2101;
            *(void *)&v627[60] = v454;
            uint64_t v450 = "[R%u->Q%u] DNSServiceGetAddrInfo result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: "
                   "%d, name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%x), dnssec: %{public, mdns:dnssec_r"
                   "esult}d, type: %{mdns:rrtype}d, rdata: %{sensitive, mask.hash, mdns:rdata}.*P";
            goto LABEL_907;
          }

          if (v49 >= 0x201)
          {
            size_t v44 = (char *)malloc(*(unsigned __int16 *)(a3 + 12));
            uint64_t v110 = v44;
            if (!v44) {
              goto LABEL_1088;
            }
          }

          else
          {
            if (!*(_WORD *)(a3 + 12))
            {
              if (v27) {
                int v279 = (os_log_s *)mDNSLogCategory_Default;
              }
              else {
                int v279 = (os_log_s *)mDNSLogCategory_mDNS;
              }
              if (gSensitiveLoggingEnabled != 1 || v279 == (os_log_s *)mDNSLogCategory_State)
              {
                if (!os_log_type_enabled(v279, OS_LOG_TYPE_DEFAULT)) {
                  goto LABEL_974;
                }
                int v283 = *(_DWORD *)(a7 + 184);
                unsigned int v347 = (_BYTE *)(a2 + 356);
                if (a2 == -612)
                {
LABEL_802:
                  while (v347)
                  {
                    uint64_t v348 = *v347;
                    if (!*v347)
                    {
                      unsigned __int16 v475 = (_WORD)v347 - v30 + 1;
                      goto LABEL_1085;
                    }

                    v347 += v348 + 1;
                    if (a2 != -612) {
                      goto LABEL_801;
                    }
                  }
                }

                else
                {
LABEL_801:
                }

                unsigned __int16 v475 = 257;
              }

              else
              {
                if (v27) {
                  int v279 = (os_log_s *)mDNSLogCategory_Default_redacted;
                }
                else {
                  int v279 = (os_log_s *)mDNSLogCategory_mDNS;
                }
                if (!os_log_type_enabled(v279, OS_LOG_TYPE_DEFAULT)) {
                  goto LABEL_974;
                }
                int v283 = *(_DWORD *)(a7 + 184);
                uint64_t v284 = (_BYTE *)(a2 + 356);
                if (a2 == -612)
                {
LABEL_565:
                  while (v284)
                  {
                    uint64_t v285 = *v284;
                    if (!*v284)
                    {
                      unsigned __int16 v475 = (_WORD)v284 - v30 + 1;
                      goto LABEL_1085;
                    }

                    v284 += v285 + 1;
                    if (a2 != -612) {
                      goto LABEL_564;
                    }
                  }
                }

                else
                {
LABEL_564:
                }

                unsigned __int16 v475 = 257;
              }

LABEL_1085:
              int v568 = *(unsigned __int16 *)(a3 + 4);
              LODWORD(buf.tv_sec) = 67111427;
              HIDWORD(buf.tv_sec) = v283;
              LOWORD(buf.tv_nsec) = 1024;
              *(_DWORD *)((char *)&buf.tv_nsec + 2) = v620;
              HIWORD(buf.tv_nsec) = 1024;
              *(_DWORD *)v625 = a4;
              *(_WORD *)&v625[4] = 1024;
              *(_DWORD *)&v625[6] = v606;
              strcpy((char *)&v626, "p\bhash");
              HIBYTE(v626) = 0;
              *(_WORD *)v627 = 0;
              *(_WORD *)&v627[2] = 1040;
              *(_DWORD *)&v627[4] = v475;
              *(_WORD *)&v627[8] = 2101;
              *(void *)&v627[10] = a2 + 356;
              *(_WORD *)&v627[18] = 1024;
              *(_DWORD *)&v627[20] = v31;
              *(_WORD *)&v627[24] = 1026;
              *(_DWORD *)&v627[26] = v51;
              *(_WORD *)&v627[30] = 1024;
              *(_DWORD *)&v627[32] = v568;
              unsigned __int16 v216 = "[R%u->mDNS] DNSServiceGetAddrInfo result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifinde"
                     "x: %d, name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%x), dnssec: %{public, mdns:dns"
                     "sec_result}d, type: %{mdns:rrtype}d, rdata: <none>";
              goto LABEL_1086;
            }

            size_t v44 = 0LL;
            uint64_t v110 = (char *)&unk_100164138;
            LODWORD(v49) = 512;
          }

          int v622 = 0;
          unsigned __int16 v621 = 0;
          uint64_t v184 = ResourceRecordGetRDataBytesPointer(a3, v110, v49, &v621, &v622, v33, v34, v35);
          if (v622) {
            goto LABEL_972;
          }
          int v603 = v44;
          int v599 = v31;
          size_t v185 = v621;
          uint64_t v573 = (const void *)v184;
          if (v621 >= 0x1FFuLL)
          {
            unsigned int v186 = v621 + 2;
            unsigned int v187 = (__int16 *)malloc(v621 + 2LL);
            if (!v187) {
              goto LABEL_1088;
            }
            int v131 = v187;
          }

          else
          {
            int v131 = 0LL;
            unsigned int v186 = 512;
            unsigned int v187 = word_100164338;
          }

          unint64_t v585 = v187;
          if (v27) {
            uint64_t v319 = (os_log_s *)mDNSLogCategory_Default;
          }
          else {
            uint64_t v319 = (os_log_s *)mDNSLogCategory_mDNS;
          }
          if (gSensitiveLoggingEnabled != 1 || v319 == (os_log_s *)mDNSLogCategory_State)
          {
            if (!os_log_type_enabled(v319, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_969;
            }
            int v323 = *(_DWORD *)(a7 + 184);
            size_t v337 = (_BYTE *)(a2 + 356);
            uint64_t v588 = a7;
            v569 = v131;
            if (a2 == -612)
            {
LABEL_772:
              while (v337)
              {
                uint64_t v338 = *v337;
                if (!*v337)
                {
                  unsigned __int16 v400 = (_WORD)v337 - v30 + 1;
                  goto LABEL_963;
                }

                v337 += v338 + 1;
                if (a2 != -612) {
                  goto LABEL_771;
                }
              }
            }

            else
            {
LABEL_771:
            }

            unsigned __int16 v400 = 257;
LABEL_963:
            int v496 = v400;
            unsigned int v497 = *(unsigned __int16 *)(a3 + 4);
            int v498 = v185 + 2;
            if ((int)v185 + 2 <= v186)
            {
              *unint64_t v585 = __rev16(v497);
              int v502 = v323;
              memcpy(v585 + 1, v573, v185);
              int v323 = v502;
              v499 = v585;
            }

            else
            {
              v499 = 0LL;
            }
          }

          else
          {
            if (v27) {
              uint64_t v319 = (os_log_s *)mDNSLogCategory_Default_redacted;
            }
            else {
              uint64_t v319 = (os_log_s *)mDNSLogCategory_mDNS;
            }
            if (!os_log_type_enabled(v319, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_969;
            }
            int v323 = *(_DWORD *)(a7 + 184);
            int v324 = (_BYTE *)(a2 + 356);
            uint64_t v588 = a7;
            v569 = v131;
            if (a2 == -612)
            {
LABEL_730:
              while (v324)
              {
                uint64_t v325 = *v324;
                if (!*v324)
                {
                  unsigned __int16 v398 = (_WORD)v324 - v30 + 1;
                  goto LABEL_955;
                }

                v324 += v325 + 1;
                if (a2 != -612) {
                  goto LABEL_729;
                }
              }
            }

            else
            {
LABEL_729:
            }

            unsigned __int16 v398 = 257;
LABEL_955:
            int v496 = v398;
            unsigned int v497 = *(unsigned __int16 *)(a3 + 4);
            int v498 = v185 + 2;
            if ((int)v185 + 2 <= v186)
            {
              *unint64_t v585 = __rev16(v497);
              int v500 = v323;
              memcpy(v585 + 1, v573, v185);
              int v323 = v500;
              v499 = v585;
            }

            else
            {
              v499 = 0LL;
            }
          }

          LODWORD(buf.tv_sec) = 67112195;
          HIDWORD(buf.tv_sec) = v323;
          LOWORD(buf.tv_nsec) = 1024;
          *(_DWORD *)((char *)&buf.tv_nsec + 2) = v620;
          HIWORD(buf.tv_nsec) = 1024;
          *(_DWORD *)v625 = a4;
          *(_WORD *)&v625[4] = 1024;
          *(_DWORD *)&v625[6] = v606;
          strcpy((char *)&v626, "p\bhash");
          HIBYTE(v626) = 0;
          *(_WORD *)v627 = 0;
          *(_WORD *)&v627[2] = 1040;
          *(_DWORD *)&v627[4] = v496;
          *(_WORD *)&v627[8] = 2101;
          *(void *)&v627[10] = a2 + 356;
          *(_WORD *)&v627[18] = 1024;
          *(_DWORD *)&v627[20] = v599;
          *(_WORD *)&v627[24] = 1026;
          *(_DWORD *)&v627[26] = v51;
          *(_WORD *)&v627[30] = 1024;
          *(_DWORD *)&v627[32] = v497;
          *(_WORD *)&v627[36] = 2160;
          *(void *)&v627[38] = 1752392040LL;
          *(_WORD *)&v627[46] = 1040;
          *(_DWORD *)&v627[48] = v498;
          *(_WORD *)&v627[52] = 2101;
          *(void *)&v627[54] = v499;
          uint64_t v450 = "[R%u->mDNS] DNSServiceGetAddrInfo result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %"
                 "d, name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%x), dnssec: %{public, mdns:dnssec_resu"
                 "lt}d, type: %{mdns:rrtype}d, rdata: %{sensitive, mask.hash, mdns:rdata}.*P";
LABEL_967:
          uint64_t v464 = v319;
          uint32_t v465 = 96;
          goto LABEL_968;
        }

        if (!*(_WORD *)(a2 + 320))
        {
LABEL_79:
          if (v50)
          {
            size_t v44 = 0LL;
            int v79 = 512;
            __int16 v80 = (char *)&unk_100164138;
          }

          else
          {
            __int16 v80 = (char *)malloc(v49);
            size_t v44 = v80;
            int v79 = v49;
            if (!v80) {
              goto LABEL_1088;
            }
          }

          if ((_DWORD)v49)
          {
            int v622 = 0;
            unsigned __int16 v621 = 0;
            uint64_t v153 = ResourceRecordGetRDataBytesPointer(a3, v80, v79, &v621, &v622, v33, v34, v35);
            if (v622) {
              goto LABEL_972;
            }
            __int16 v154 = (const void *)v153;
            int v603 = v44;
            int v597 = v31;
            size_t v155 = v621;
            int v612 = v29;
            if (v621 >= 0x1FFuLL)
            {
              unsigned int v156 = v621 + 2;
              uint64_t v157 = (__int16 *)malloc(v621 + 2LL);
              if (!v157) {
                goto LABEL_1088;
              }
              int v131 = v157;
            }

            else
            {
              int v131 = 0LL;
              unsigned int v156 = 512;
              uint64_t v157 = word_100164338;
            }

            int v583 = v157;
            if (v27) {
              uint64_t v289 = (os_log_s *)mDNSLogCategory_Default;
            }
            else {
              uint64_t v289 = (os_log_s *)mDNSLogCategory_mDNS;
            }
            if (gSensitiveLoggingEnabled != 1 || v289 == (os_log_s *)mDNSLogCategory_State)
            {
              if (!os_log_type_enabled(v289, OS_LOG_TYPE_DEFAULT)) {
                goto LABEL_969;
              }
              int v293 = *(_DWORD *)(a7 + 184);
              uint64_t v307 = (_BYTE *)(a2 + 356);
              uint64_t v589 = a7;
              int v576 = v131;
              if (a2 == -612)
              {
LABEL_663:
                while (v307)
                {
                  uint64_t v308 = *v307;
                  if (!*v307)
                  {
                    unsigned __int16 v394 = (_WORD)v307 - v30 + 1;
                    goto LABEL_937;
                  }

                  v307 += v308 + 1;
                  if (a2 != -612) {
                    goto LABEL_662;
                  }
                }
              }

              else
              {
LABEL_662:
              }

              unsigned __int16 v394 = 257;
LABEL_937:
              int v482 = v394;
              unsigned int v483 = *(unsigned __int16 *)(a3 + 4);
              int v484 = v155 + 2;
              if ((int)v155 + 2 <= v156)
              {
                *int v583 = __rev16(v483);
                int v488 = v293;
                memcpy(v583 + 1, v154, v155);
                int v293 = v488;
                int v485 = v583;
              }

              else
              {
                int v485 = 0LL;
              }
            }

            else
            {
              if (v27) {
                uint64_t v289 = (os_log_s *)mDNSLogCategory_Default_redacted;
              }
              else {
                uint64_t v289 = (os_log_s *)mDNSLogCategory_mDNS;
              }
              if (!os_log_type_enabled(v289, OS_LOG_TYPE_DEFAULT)) {
                goto LABEL_969;
              }
              int v293 = *(_DWORD *)(a7 + 184);
              BOOL v294 = (_BYTE *)(a2 + 356);
              uint64_t v589 = a7;
              int v576 = v131;
              if (a2 == -612)
              {
LABEL_621:
                while (v294)
                {
                  uint64_t v295 = *v294;
                  if (!*v294)
                  {
                    unsigned __int16 v392 = (_WORD)v294 - v30 + 1;
                    goto LABEL_929;
                  }

                  v294 += v295 + 1;
                  if (a2 != -612) {
                    goto LABEL_620;
                  }
                }
              }

              else
              {
LABEL_620:
              }

              unsigned __int16 v392 = 257;
LABEL_929:
              int v482 = v392;
              unsigned int v483 = *(unsigned __int16 *)(a3 + 4);
              int v484 = v155 + 2;
              if ((int)v155 + 2 <= v156)
              {
                *int v583 = __rev16(v483);
                int v486 = v293;
                memcpy(v583 + 1, v154, v155);
                int v293 = v486;
                int v485 = v583;
              }

              else
              {
                int v485 = 0LL;
              }
            }

            LODWORD(buf.tv_sec) = 67111939;
            HIDWORD(buf.tv_sec) = v293;
            LOWORD(buf.tv_nsec) = 1024;
            *(_DWORD *)((char *)&buf.tv_nsec + 2) = v620;
            HIWORD(buf.tv_nsec) = 1024;
            *(_DWORD *)v625 = a4;
            *(_WORD *)&v625[4] = 1024;
            *(_DWORD *)&v625[6] = v612;
            strcpy((char *)&v626, "p\bhash");
            HIBYTE(v626) = 0;
            *(_WORD *)v627 = 0;
            *(_WORD *)&v627[2] = 1040;
            *(_DWORD *)&v627[4] = v482;
            *(_WORD *)&v627[8] = 2101;
            *(void *)&v627[10] = a2 + 356;
            *(_WORD *)&v627[18] = 1024;
            *(_DWORD *)&v627[20] = v597;
            *(_WORD *)&v627[24] = 1024;
            *(_DWORD *)&v627[26] = v483;
            *(_WORD *)&v627[30] = 2160;
            *(void *)&v627[32] = 1752392040LL;
            *(_WORD *)&v627[40] = 1040;
            *(_DWORD *)&v627[42] = v484;
            *(_WORD *)&v627[46] = 2101;
            *(void *)&v627[48] = v485;
            unsigned __int16 v481 = "[R%u->mDNS] DNSServiceGetAddrInfo result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex:"
                   " %d, name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%x), type: %{mdns:rrtype}d, rdata: "
                   "%{sensitive, mask.hash, mdns:rdata}.*P";
LABEL_941:
            _os_log_impl((void *)&_mh_execute_header, v289, OS_LOG_TYPE_DEFAULT, v481, (uint8_t *)&buf, 0x5Au);
            a7 = v589;
            int v131 = v576;
            goto LABEL_969;
          }

          if (v27) {
            int v169 = (os_log_s *)mDNSLogCategory_Default;
          }
          else {
            int v169 = (os_log_s *)mDNSLogCategory_mDNS;
          }
          if (gSensitiveLoggingEnabled != 1 || v169 == (os_log_s *)mDNSLogCategory_State)
          {
            if (!os_log_type_enabled(v169, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_972;
            }
            int v173 = *(_DWORD *)(a7 + 184);
            int v247 = (_BYTE *)(a2 + 356);
            if (a2 == -612)
            {
LABEL_444:
              while (v247)
              {
                uint64_t v248 = *v247;
                if (!*v247)
                {
                  unsigned __int16 v344 = (_WORD)v247 - v30 + 1;
                  goto LABEL_877;
                }

                v247 += v248 + 1;
                if (a2 != -612) {
                  goto LABEL_443;
                }
              }
            }

            else
            {
LABEL_443:
            }

            unsigned __int16 v344 = 257;
          }

          else
          {
            if (v27) {
              int v169 = (os_log_s *)mDNSLogCategory_Default_redacted;
            }
            else {
              int v169 = (os_log_s *)mDNSLogCategory_mDNS;
            }
            if (!os_log_type_enabled(v169, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_972;
            }
            int v173 = *(_DWORD *)(a7 + 184);
            uint64_t v174 = (_BYTE *)(a2 + 356);
            if (a2 == -612)
            {
LABEL_234:
              while (v174)
              {
                uint64_t v175 = *v174;
                if (!*v174)
                {
                  unsigned __int16 v344 = (_WORD)v174 - v30 + 1;
                  goto LABEL_877;
                }

                v174 += v175 + 1;
                if (a2 != -612) {
                  goto LABEL_233;
                }
              }
            }

            else
            {
LABEL_233:
            }

            unsigned __int16 v344 = 257;
          }

LABEL_877:
          int v436 = *(unsigned __int16 *)(a3 + 4);
          LODWORD(buf.tv_sec) = 67111171;
          HIDWORD(buf.tv_sec) = v173;
          LOWORD(buf.tv_nsec) = 1024;
          *(_DWORD *)((char *)&buf.tv_nsec + 2) = v620;
          HIWORD(buf.tv_nsec) = 1024;
          *(_DWORD *)v625 = a4;
          *(_WORD *)&v625[4] = 1024;
          *(_DWORD *)&v625[6] = v29;
          strcpy((char *)&v626, "p\bhash");
          HIBYTE(v626) = 0;
          *(_WORD *)v627 = 0;
          *(_WORD *)&v627[2] = 1040;
          *(_DWORD *)&v627[4] = v344;
          *(_WORD *)&v627[8] = 2101;
          *(void *)&v627[10] = a2 + 356;
          *(_WORD *)&v627[18] = 1024;
          *(_DWORD *)&v627[20] = v31;
          *(_WORD *)&v627[24] = 1024;
          *(_DWORD *)&v627[26] = v436;
          int v179 = "[R%u->mDNS] DNSServiceGetAddrInfo result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %"
                 "d, name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%x), type: %{mdns:rrtype}d, rdata: <none>";
          goto LABEL_878;
        }
      }

      else
      {
        unsigned int v48 = *(unsigned __int16 *)(a2 + 320);
        LODWORD(v49) = *(unsigned __int16 *)(a3 + 12);
        BOOL v50 = v49 < 0x201;
        if (!*(_WORD *)(a2 + 320)) {
          goto LABEL_79;
        }
      }

      if (v50)
      {
        size_t v44 = 0LL;
        int v71 = 512;
        int v72 = (char *)&unk_100164138;
      }

      else
      {
        int v72 = (char *)malloc(v49);
        size_t v44 = v72;
        int v71 = v49;
        if (!v72) {
          goto LABEL_1088;
        }
      }

      if ((_DWORD)v49)
      {
        int v591 = v31;
        int v622 = 0;
        unsigned __int16 v621 = 0;
        uint64_t v90 = ResourceRecordGetRDataBytesPointer(a3, v72, v71, &v621, &v622, v33, v34, v35);
        if (v622) {
          goto LABEL_972;
        }
        unsigned int v91 = (const void *)v90;
        size_t v92 = v621;
        int v608 = v29;
        if (v621 >= 0x1FFuLL)
        {
          unsigned int v578 = v621 + 2;
          size_t v94 = (__int16 *)malloc(v621 + 2LL);
          if (!v94) {
            goto LABEL_1088;
          }
          int v93 = v94;
        }

        else
        {
          int v93 = 0LL;
          unsigned int v578 = 512;
          size_t v94 = word_100164338;
        }

        unsigned int v575 = v94;
        uint64_t v604 = v93;
        if (v27) {
          int v217 = (os_log_s *)mDNSLogCategory_Default;
        }
        else {
          int v217 = (os_log_s *)mDNSLogCategory_mDNS;
        }
        if (gSensitiveLoggingEnabled != 1 || v217 == (os_log_s *)mDNSLogCategory_State)
        {
          if (!os_log_type_enabled(v217, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_870;
          }
          int v241 = *(_DWORD *)(a7 + 184);
          unsigned int v242 = bswap32(*(unsigned __int16 *)(a2 + 320)) >> 16;
          int v243 = (_BYTE *)(a2 + 356);
          uint64_t v587 = a7;
          if (a2 == -612)
          {
LABEL_422:
            while (v243)
            {
              uint64_t v244 = *v243;
              if (!*v243)
              {
                unsigned __int16 v342 = (_WORD)v243 - v30 + 1;
                goto LABEL_865;
              }

              v243 += v244 + 1;
              if (a2 != -612) {
                goto LABEL_421;
              }
            }
          }

          else
          {
LABEL_421:
          }

          unsigned __int16 v342 = 257;
LABEL_865:
          int v426 = v342;
          unsigned int v427 = *(unsigned __int16 *)(a3 + 4);
          int v428 = v92 + 2;
          if ((int)v92 + 2 <= v578)
          {
            *unsigned int v575 = __rev16(v427);
            size_t v430 = v92;
            int v431 = v91;
            int v432 = v241;
            unsigned int v433 = v242;
            memcpy(v575 + 1, v431, v430);
            unsigned int v242 = v433;
            int v241 = v432;
            v429 = v575;
          }

          else
          {
            v429 = 0LL;
          }

          LODWORD(buf.tv_sec) = 67112195;
          HIDWORD(buf.tv_sec) = v241;
          LOWORD(buf.tv_nsec) = 1024;
          *(_DWORD *)((char *)&buf.tv_nsec + 2) = v242;
          HIWORD(buf.tv_nsec) = 1024;
          *(_DWORD *)v625 = v620;
          *(_WORD *)&v625[4] = 1024;
          *(_DWORD *)&v625[6] = a4;
          LOWORD(v626) = 1024;
          *(_DWORD *)((char *)&v626 + 2) = v608;
          HIWORD(v626) = 2160;
          *(void *)v627 = 1752392040LL;
          *(_WORD *)&v627[8] = 1040;
          *(_DWORD *)&v627[10] = v426;
          *(_WORD *)&v627[14] = 2101;
          *(void *)&v627[16] = a2 + 356;
          *(_WORD *)&v627[24] = 1024;
          *(_DWORD *)&v627[26] = v591;
          *(_WORD *)&v627[30] = 1024;
          *(_DWORD *)&v627[32] = v427;
          *(_WORD *)&v627[36] = 2160;
          *(void *)&v627[38] = 1752392040LL;
          *(_WORD *)&v627[46] = 1040;
          *(_DWORD *)&v627[48] = v428;
          *(_WORD *)&v627[52] = 2101;
          *(void *)&v627[54] = v429;
          uint64_t v409 = "[R%u->Q%u] DNSServiceGetAddrInfo result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %d"
                 ", name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%x), type: %{mdns:rrtype}d, rdata: %{sen"
                 "sitive, mask.hash, mdns:rdata}.*P";
          goto LABEL_869;
        }

        if (v27) {
          int v217 = (os_log_s *)mDNSLogCategory_Default_redacted;
        }
        else {
          int v217 = (os_log_s *)mDNSLogCategory_mDNS;
        }
        if (os_log_type_enabled(v217, OS_LOG_TYPE_DEFAULT))
        {
          int v222 = *(_DWORD *)(a7 + 184);
          unsigned int v223 = bswap32(*(unsigned __int16 *)(a2 + 320)) >> 16;
          size_t v224 = (_BYTE *)(a2 + 356);
          uint64_t v587 = a7;
          if (a2 == -612)
          {
LABEL_380:
            while (v224)
            {
              uint64_t v225 = *v224;
              if (!*v224)
              {
                unsigned __int16 v340 = (_WORD)v224 - v30 + 1;
                goto LABEL_855;
              }

              v224 += v225 + 1;
              if (a2 != -612) {
                goto LABEL_379;
              }
            }
          }

          else
          {
LABEL_379:
          }

          unsigned __int16 v340 = 257;
LABEL_855:
          int v410 = v340;
          unsigned int v411 = *(unsigned __int16 *)(a3 + 4);
          int v412 = v92 + 2;
          if ((int)v92 + 2 <= v578)
          {
            *unsigned int v575 = __rev16(v411);
            uint64_t v414 = v91;
            size_t v415 = v92;
            int v416 = v222;
            unsigned int v417 = v223;
            memcpy(v575 + 1, v414, v415);
            unsigned int v223 = v417;
            int v222 = v416;
            v413 = v575;
          }

          else
          {
            v413 = 0LL;
          }

          LODWORD(buf.tv_sec) = 67112195;
          HIDWORD(buf.tv_sec) = v222;
          LOWORD(buf.tv_nsec) = 1024;
          *(_DWORD *)((char *)&buf.tv_nsec + 2) = v223;
          HIWORD(buf.tv_nsec) = 1024;
          *(_DWORD *)v625 = v620;
          *(_WORD *)&v625[4] = 1024;
          *(_DWORD *)&v625[6] = a4;
          LOWORD(v626) = 1024;
          *(_DWORD *)((char *)&v626 + 2) = v608;
          HIWORD(v626) = 2160;
          *(void *)v627 = 1752392040LL;
          *(_WORD *)&v627[8] = 1040;
          *(_DWORD *)&v627[10] = v410;
          *(_WORD *)&v627[14] = 2101;
          *(void *)&v627[16] = a2 + 356;
          *(_WORD *)&v627[24] = 1024;
          *(_DWORD *)&v627[26] = v591;
          *(_WORD *)&v627[30] = 1024;
          *(_DWORD *)&v627[32] = v411;
          *(_WORD *)&v627[36] = 2160;
          *(void *)&v627[38] = 1752392040LL;
          *(_WORD *)&v627[46] = 1040;
          *(_DWORD *)&v627[48] = v412;
          *(_WORD *)&v627[52] = 2101;
          *(void *)&v627[54] = v413;
          uint64_t v409 = "[R%u->Q%u] DNSServiceGetAddrInfo result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %d"
                 ", name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%x), type: %{mdns:rrtype}d, rdata: %{sen"
                 "sitive, mask.hash, mdns:rdata}.*P";
          goto LABEL_869;
        }

LABEL_870:
        uint64_t v434 = v604;
        if (!v604) {
          goto LABEL_972;
        }
        goto LABEL_971;
      }

      if (v27) {
        unsigned int v113 = (os_log_s *)mDNSLogCategory_Default;
      }
      else {
        unsigned int v113 = (os_log_s *)mDNSLogCategory_mDNS;
      }
      if (gSensitiveLoggingEnabled != 1 || v113 == (os_log_s *)mDNSLogCategory_State)
      {
        if (!os_log_type_enabled(v113, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_972;
        }
        int v118 = *(_DWORD *)(a7 + 184);
        unsigned int v119 = __rev16(v48);
        unsigned int v200 = (_BYTE *)(a2 + 356);
        if (a2 == -612)
        {
LABEL_286:
          while (v200)
          {
            uint64_t v201 = *v200;
            if (!*v200)
            {
              unsigned __int16 v310 = (_WORD)v200 - v30 + 1;
              goto LABEL_821;
            }

            v200 += v201 + 1;
            if (a2 != -612) {
              goto LABEL_285;
            }
          }
        }

        else
        {
LABEL_285:
        }

        unsigned __int16 v310 = 257;
      }

      else
      {
        if (v27) {
          unsigned int v113 = (os_log_s *)mDNSLogCategory_Default_redacted;
        }
        else {
          unsigned int v113 = (os_log_s *)mDNSLogCategory_mDNS;
        }
        if (!os_log_type_enabled(v113, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_972;
        }
        int v118 = *(_DWORD *)(a7 + 184);
        unsigned int v119 = __rev16(v48);
        uint64_t v120 = (_BYTE *)(a2 + 356);
        if (a2 == -612)
        {
LABEL_146:
          while (v120)
          {
            uint64_t v121 = *v120;
            if (!*v120)
            {
              unsigned __int16 v310 = (_WORD)v120 - v30 + 1;
              goto LABEL_821;
            }

            v120 += v121 + 1;
            if (a2 != -612) {
              goto LABEL_145;
            }
          }
        }

        else
        {
LABEL_145:
        }

        unsigned __int16 v310 = 257;
      }

LABEL_821:
      int v356 = *(unsigned __int16 *)(a3 + 4);
      LODWORD(buf.tv_sec) = 67111427;
      HIDWORD(buf.tv_sec) = v118;
      LOWORD(buf.tv_nsec) = 1024;
      *(_DWORD *)((char *)&buf.tv_nsec + 2) = v119;
      HIWORD(buf.tv_nsec) = 1024;
      *(_DWORD *)v625 = v620;
      *(_WORD *)&v625[4] = 1024;
      *(_DWORD *)&v625[6] = a4;
      LOWORD(v626) = 1024;
      *(_DWORD *)((char *)&v626 + 2) = v29;
      HIWORD(v626) = 2160;
      *(void *)v627 = 1752392040LL;
      *(_WORD *)&v627[8] = 1040;
      *(_DWORD *)&v627[10] = v310;
      *(_WORD *)&v627[14] = 2101;
      *(void *)&v627[16] = a2 + 356;
      *(_WORD *)&v627[24] = 1024;
      *(_DWORD *)&v627[26] = v31;
      *(_WORD *)&v627[30] = 1024;
      *(_DWORD *)&v627[32] = v356;
      int v179 = "[R%u->Q%u] DNSServiceGetAddrInfo result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %d, na"
             "me: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%x), type: %{mdns:rrtype}d, rdata: <none>";
      goto LABEL_822;
    }

    uint64_t v61 = *(void *)(a3 + 56);
    if (v61)
    {
      int v62 = v29;
      int v63 = dnssec_obj_resource_record_member_get_validation_result(v61);
      unsigned int v64 = *(unsigned __int16 *)(a2 + 320);
      unint64_t v65 = *(unsigned __int16 *)(a3 + 12);
      BOOL v66 = v65 < 0x201;
      if (v63)
      {
        int v67 = v63;
        if (*(_WORD *)(a2 + 320))
        {
          if (v65 >= 0x201)
          {
            size_t v44 = (char *)malloc(*(unsigned __int16 *)(a3 + 12));
            int v68 = v44;
            if (!v44) {
              goto LABEL_1088;
            }
          }

          else
          {
            if (!*(_WORD *)(a3 + 12))
            {
              if (v27) {
                unsigned __int16 v213 = (os_log_s *)mDNSLogCategory_Default;
              }
              else {
                unsigned __int16 v213 = (os_log_s *)mDNSLogCategory_mDNS;
              }
              if (gSensitiveLoggingEnabled != 1 || v213 == (os_log_s *)mDNSLogCategory_State)
              {
                if (!os_log_type_enabled(v213, OS_LOG_TYPE_DEFAULT)) {
                  goto LABEL_974;
                }
              }

              else
              {
                if (v27) {
                  unsigned __int16 v213 = (os_log_s *)mDNSLogCategory_Default_redacted;
                }
                else {
                  unsigned __int16 v213 = (os_log_s *)mDNSLogCategory_mDNS;
                }
                if (!os_log_type_enabled(v213, OS_LOG_TYPE_DEFAULT)) {
                  goto LABEL_974;
                }
              }

              int v315 = *(_DWORD *)(a7 + 184);
              int v316 = *(unsigned __int16 *)(a3 + 4);
              LODWORD(buf.tv_sec) = 67110912;
              HIDWORD(buf.tv_sec) = v315;
              LOWORD(buf.tv_nsec) = 1024;
              *(_DWORD *)((char *)&buf.tv_nsec + 2) = __rev16(v64);
              HIWORD(buf.tv_nsec) = 1024;
              *(_DWORD *)v625 = v620;
              *(_WORD *)&v625[4] = 1024;
              *(_DWORD *)&v625[6] = a4;
              LOWORD(v626) = 1024;
              *(_DWORD *)((char *)&v626 + 2) = v62;
              HIWORD(v626) = 1024;
              *(_DWORD *)v627 = v31;
              *(_WORD *)&v627[4] = 1026;
              *(_DWORD *)&v627[6] = v67;
              *(_WORD *)&v627[10] = 1024;
              *(_DWORD *)&v627[12] = v316;
              unsigned __int16 v216 = "[R%u->Q%u] DNSServiceGetAddrInfo result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex"
                     ": %d, name hash: %x, dnssec: %{public, mdns:dnssec_result}d, type: %{mdns:rrtype}d, rdata: <none>";
LABEL_698:
              int v317 = v213;
              uint32_t v318 = 50;
LABEL_1087:
              _os_log_impl((void *)&_mh_execute_header, v317, OS_LOG_TYPE_DEFAULT, v216, (uint8_t *)&buf, v318);
              goto LABEL_974;
            }

            size_t v44 = 0LL;
            int v68 = (char *)&unk_100164138;
            LODWORD(v65) = 512;
          }

          int v622 = 0;
          unsigned __int16 v621 = 0;
          uint64_t v143 = ResourceRecordGetRDataBytesPointer(a3, v68, v65, &v621, &v622, v33, v34, v35);
          if (v622) {
            goto LABEL_972;
          }
          __int16 v144 = (const void *)v143;
          int v595 = v31;
          size_t v145 = v621;
          uint64_t v586 = a7;
          v602 = v44;
          if (v621 >= 0x1FFuLL)
          {
            unsigned int v146 = v621 + 2;
            int v269 = (__int16 *)malloc(v621 + 2LL);
            if (!v269) {
              goto LABEL_1088;
            }
            uint64_t v147 = v269;
            v579 = v269;
          }

          else
          {
            v579 = 0LL;
            unsigned int v146 = 512;
            uint64_t v147 = word_100164338;
          }

          if (v27) {
            int v263 = (os_log_s *)mDNSLogCategory_Default;
          }
          else {
            int v263 = (os_log_s *)mDNSLogCategory_mDNS;
          }
          if (gSensitiveLoggingEnabled != 1 || v263 == (os_log_s *)mDNSLogCategory_State)
          {
            if (!os_log_type_enabled(v263, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_916;
            }
            int v270 = *(_DWORD *)(v586 + 184);
            unsigned int v271 = bswap32(*(unsigned __int16 *)(a2 + 320)) >> 16;
            unsigned int v272 = *(unsigned __int16 *)(a3 + 4);
            int v273 = v145 + 2;
            if ((int)v145 + 2 <= v146)
            {
              v274 = v147;
              *uint64_t v147 = __rev16(v272);
              int v385 = v147 + 1;
              uint64_t v386 = v144;
              int v387 = v270;
              unsigned int v388 = v271;
              memcpy(v385, v386, v145);
              unsigned int v271 = v388;
              int v270 = v387;
            }

            else
            {
              v274 = 0LL;
            }
          }

          else
          {
            if (v27) {
              int v263 = (os_log_s *)mDNSLogCategory_Default_redacted;
            }
            else {
              int v263 = (os_log_s *)mDNSLogCategory_mDNS;
            }
            if (!os_log_type_enabled(v263, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_916;
            }
            int v270 = *(_DWORD *)(v586 + 184);
            unsigned int v271 = bswap32(*(unsigned __int16 *)(a2 + 320)) >> 16;
            unsigned int v272 = *(unsigned __int16 *)(a3 + 4);
            int v273 = v145 + 2;
            if ((int)v145 + 2 <= v146)
            {
              v274 = v147;
              *uint64_t v147 = __rev16(v272);
              __int16 v377 = v147 + 1;
              uint64_t v378 = v144;
              int v379 = v270;
              unsigned int v380 = v271;
              memcpy(v377, v378, v145);
              unsigned int v271 = v380;
              int v270 = v379;
            }

            else
            {
              v274 = 0LL;
            }
          }

          LODWORD(buf.tv_sec) = 67111683;
          HIDWORD(buf.tv_sec) = v270;
          LOWORD(buf.tv_nsec) = 1024;
          *(_DWORD *)((char *)&buf.tv_nsec + 2) = v271;
          HIWORD(buf.tv_nsec) = 1024;
          *(_DWORD *)v625 = v620;
          *(_WORD *)&v625[4] = 1024;
          *(_DWORD *)&v625[6] = a4;
          LOWORD(v626) = 1024;
          *(_DWORD *)((char *)&v626 + 2) = v62;
          HIWORD(v626) = 1024;
          *(_DWORD *)v627 = v595;
          *(_WORD *)&v627[4] = 1026;
          *(_DWORD *)&v627[6] = v67;
          *(_WORD *)&v627[10] = 1024;
          *(_DWORD *)&v627[12] = v272;
          *(_WORD *)&v627[16] = 2160;
          *(void *)&v627[18] = 1752392040LL;
          *(_WORD *)&v627[26] = 1040;
          *(_DWORD *)&v627[28] = v273;
          *(_WORD *)&v627[32] = 2101;
          *(void *)&v627[34] = v274;
          v376 = "[R%u->Q%u] DNSServiceGetAddrInfo result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %d"
                 ", name hash: %x, dnssec: %{public, mdns:dnssec_result}d, type: %{mdns:rrtype}d, rdata: %{sensitive, mas"
                 "k.hash, mdns:rdata}.*P";
          goto LABEL_836;
        }

        if (v65 >= 0x201)
        {
          size_t v44 = (char *)malloc(*(unsigned __int16 *)(a3 + 12));
          int v112 = v44;
          if (!v44) {
            goto LABEL_1088;
          }
        }

        else
        {
          if (!*(_WORD *)(a3 + 12))
          {
            if (v27) {
              int v286 = (os_log_s *)mDNSLogCategory_Default;
            }
            else {
              int v286 = (os_log_s *)mDNSLogCategory_mDNS;
            }
            if (gSensitiveLoggingEnabled != 1 || v286 == (os_log_s *)mDNSLogCategory_State)
            {
              if (!os_log_type_enabled(v286, OS_LOG_TYPE_DEFAULT)) {
                goto LABEL_974;
              }
            }

            else
            {
              if (v27) {
                int v286 = (os_log_s *)mDNSLogCategory_Default_redacted;
              }
              else {
                int v286 = (os_log_s *)mDNSLogCategory_mDNS;
              }
              if (!os_log_type_enabled(v286, OS_LOG_TYPE_DEFAULT)) {
                goto LABEL_974;
              }
            }

            int v349 = *(_DWORD *)(a7 + 184);
            int v350 = *(unsigned __int16 *)(a3 + 4);
            LODWORD(buf.tv_sec) = 67110656;
            HIDWORD(buf.tv_sec) = v349;
            LOWORD(buf.tv_nsec) = 1024;
            *(_DWORD *)((char *)&buf.tv_nsec + 2) = v620;
            HIWORD(buf.tv_nsec) = 1024;
            *(_DWORD *)v625 = a4;
            *(_WORD *)&v625[4] = 1024;
            *(_DWORD *)&v625[6] = v62;
            LOWORD(v626) = 1024;
            *(_DWORD *)((char *)&v626 + 2) = v31;
            HIWORD(v626) = 1026;
            *(_DWORD *)v627 = v67;
            *(_WORD *)&v627[4] = 1024;
            *(_DWORD *)&v627[6] = v350;
            unsigned __int16 v216 = "[R%u->mDNS] DNSServiceGetAddrInfo result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex:"
                   " %d, name hash: %x, dnssec: %{public, mdns:dnssec_result}d, type: %{mdns:rrtype}d, rdata: <none>";
            goto LABEL_811;
          }

          size_t v44 = 0LL;
          int v112 = (char *)&unk_100164138;
          LODWORD(v65) = 512;
        }

        int v622 = 0;
        unsigned __int16 v621 = 0;
        uint64_t v193 = ResourceRecordGetRDataBytesPointer(a3, v112, v65, &v621, &v622, v33, v34, v35);
        if (v622) {
          goto LABEL_972;
        }
        uint64_t v194 = (const void *)v193;
        int v601 = v31;
        size_t v195 = v621;
        uint64_t v586 = a7;
        v602 = v44;
        if (v621 >= 0x1FFuLL)
        {
          unsigned int v196 = v621 + 2;
          int v331 = (__int16 *)malloc(v621 + 2LL);
          if (!v331) {
            goto LABEL_1088;
          }
          size_t v197 = v331;
          v579 = v331;
        }

        else
        {
          v579 = 0LL;
          unsigned int v196 = 512;
          size_t v197 = word_100164338;
        }

        if (v27) {
          uint64_t v327 = (os_log_s *)mDNSLogCategory_Default;
        }
        else {
          uint64_t v327 = (os_log_s *)mDNSLogCategory_mDNS;
        }
        if (gSensitiveLoggingEnabled != 1 || v327 == (os_log_s *)mDNSLogCategory_State)
        {
          if (!os_log_type_enabled(v327, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_916;
          }
          int v332 = *(_DWORD *)(v586 + 184);
          unsigned int v333 = *(unsigned __int16 *)(a3 + 4);
          int v334 = v195 + 2;
          if ((int)v195 + 2 <= v196)
          {
            __int16 *v197 = __rev16(v333);
            unint64_t v472 = v194;
            int v473 = v332;
            memcpy(v197 + 1, v472, v195);
            int v332 = v473;
          }

          else
          {
            size_t v197 = 0LL;
          }
        }

        else
        {
          if (v27) {
            uint64_t v327 = (os_log_s *)mDNSLogCategory_Default_redacted;
          }
          else {
            uint64_t v327 = (os_log_s *)mDNSLogCategory_mDNS;
          }
          if (!os_log_type_enabled(v327, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_916;
          }
          int v332 = *(_DWORD *)(v586 + 184);
          unsigned int v333 = *(unsigned __int16 *)(a3 + 4);
          int v334 = v195 + 2;
          if ((int)v195 + 2 <= v196)
          {
            __int16 *v197 = __rev16(v333);
            int v468 = v194;
            int v469 = v332;
            memcpy(v197 + 1, v468, v195);
            int v332 = v469;
          }

          else
          {
            size_t v197 = 0LL;
          }
        }

        LODWORD(buf.tv_sec) = 67111427;
        HIDWORD(buf.tv_sec) = v332;
        LOWORD(buf.tv_nsec) = 1024;
        *(_DWORD *)((char *)&buf.tv_nsec + 2) = v620;
        HIWORD(buf.tv_nsec) = 1024;
        *(_DWORD *)v625 = a4;
        *(_WORD *)&v625[4] = 1024;
        *(_DWORD *)&v625[6] = v62;
        LOWORD(v626) = 1024;
        *(_DWORD *)((char *)&v626 + 2) = v601;
        HIWORD(v626) = 1026;
        *(_DWORD *)v627 = v67;
        *(_WORD *)&v627[4] = 1024;
        *(_DWORD *)&v627[6] = v333;
        *(_WORD *)&v627[10] = 2160;
        *(void *)&v627[12] = 1752392040LL;
        *(_WORD *)&v627[20] = 1040;
        *(_DWORD *)&v627[22] = v334;
        *(_WORD *)&v627[26] = 2101;
        *(void *)&v627[28] = v197;
        v376 = "[R%u->mDNS] DNSServiceGetAddrInfo result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %d,"
               " name hash: %x, dnssec: %{public, mdns:dnssec_result}d, type: %{mdns:rrtype}d, rdata: %{sensitive, mask.h"
               "ash, mdns:rdata}.*P";
        goto LABEL_914;
      }

      if (!*(_WORD *)(a2 + 320)) {
        goto LABEL_85;
      }
    }

    else
    {
      unsigned int v64 = *(unsigned __int16 *)(a2 + 320);
      LODWORD(v65) = *(unsigned __int16 *)(a3 + 12);
      BOOL v66 = v65 < 0x201;
      if (!*(_WORD *)(a2 + 320))
      {
LABEL_85:
        if (v66)
        {
          size_t v44 = 0LL;
          int v83 = 512;
          __int16 v84 = (char *)&unk_100164138;
        }

        else
        {
          __int16 v84 = (char *)malloc(v65);
          size_t v44 = v84;
          int v83 = v65;
          if (!v84) {
            goto LABEL_1088;
          }
        }

        if ((_DWORD)v65)
        {
          int v163 = v31;
          int v622 = 0;
          unsigned __int16 v621 = 0;
          uint64_t v164 = ResourceRecordGetRDataBytesPointer(a3, v84, v83, &v621, &v622, v33, v34, v35);
          if (v622) {
            goto LABEL_972;
          }
          uint64_t v165 = (const void *)v164;
          int v614 = v29;
          size_t v166 = v621;
          v602 = v44;
          if (v621 >= 0x1FFuLL)
          {
            unsigned int v167 = v621 + 2;
            uint64_t v301 = (__int16 *)malloc(v621 + 2LL);
            if (!v301) {
              goto LABEL_1088;
            }
            int v168 = v301;
            uint64_t v98 = a7;
            v579 = v301;
          }

          else
          {
            uint64_t v98 = a7;
            v579 = 0LL;
            unsigned int v167 = 512;
            int v168 = word_100164338;
          }

          if (v27) {
            int v297 = (os_log_s *)mDNSLogCategory_Default;
          }
          else {
            int v297 = (os_log_s *)mDNSLogCategory_mDNS;
          }
          if (gSensitiveLoggingEnabled != 1 || v297 == (os_log_s *)mDNSLogCategory_State)
          {
            if (!os_log_type_enabled(v297, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_888;
            }
            int v302 = *(_DWORD *)(v98 + 184);
            unsigned int v303 = *(unsigned __int16 *)(a3 + 4);
            int v304 = v166 + 2;
            if ((int)v166 + 2 <= v167)
            {
              *int v168 = __rev16(v303);
              int v442 = v302;
              memcpy(v168 + 1, v165, v166);
              int v302 = v442;
            }

            else
            {
              int v168 = 0LL;
            }
          }

          else
          {
            if (v27) {
              int v297 = (os_log_s *)mDNSLogCategory_Default_redacted;
            }
            else {
              int v297 = (os_log_s *)mDNSLogCategory_mDNS;
            }
            if (!os_log_type_enabled(v297, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_888;
            }
            int v302 = *(_DWORD *)(v98 + 184);
            unsigned int v303 = *(unsigned __int16 *)(a3 + 4);
            int v304 = v166 + 2;
            if ((int)v166 + 2 <= v167)
            {
              *int v168 = __rev16(v303);
              int v439 = v302;
              memcpy(v168 + 1, v165, v166);
              int v302 = v439;
            }

            else
            {
              int v168 = 0LL;
            }
          }

          LODWORD(buf.tv_sec) = 67111171;
          HIDWORD(buf.tv_sec) = v302;
          LOWORD(buf.tv_nsec) = 1024;
          *(_DWORD *)((char *)&buf.tv_nsec + 2) = v620;
          HIWORD(buf.tv_nsec) = 1024;
          *(_DWORD *)v625 = a4;
          *(_WORD *)&v625[4] = 1024;
          *(_DWORD *)&v625[6] = v614;
          LOWORD(v626) = 1024;
          *(_DWORD *)((char *)&v626 + 2) = v163;
          HIWORD(v626) = 1024;
          *(_DWORD *)v627 = v303;
          *(_WORD *)&v627[4] = 2160;
          *(void *)&v627[6] = 1752392040LL;
          *(_WORD *)&v627[14] = 1040;
          *(_DWORD *)&v627[16] = v304;
          *(_WORD *)&v627[20] = 2101;
          *(void *)&v627[22] = v168;
          int v360 = "[R%u->mDNS] DNSServiceGetAddrInfo result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %"
                 "d, name hash: %x, type: %{mdns:rrtype}d, rdata: %{sensitive, mask.hash, mdns:rdata}.*P";
          goto LABEL_886;
        }

        if (v27) {
          unsigned __int16 v176 = (os_log_s *)mDNSLogCategory_Default;
        }
        else {
          unsigned __int16 v176 = (os_log_s *)mDNSLogCategory_mDNS;
        }
        if (gSensitiveLoggingEnabled != 1 || v176 == (os_log_s *)mDNSLogCategory_State)
        {
          if (!os_log_type_enabled(v176, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_972;
          }
        }

        else
        {
          if (v27) {
            unsigned __int16 v176 = (os_log_s *)mDNSLogCategory_Default_redacted;
          }
          else {
            unsigned __int16 v176 = (os_log_s *)mDNSLogCategory_mDNS;
          }
          if (!os_log_type_enabled(v176, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_972;
          }
        }

        int v249 = *(_DWORD *)(a7 + 184);
        int v250 = *(unsigned __int16 *)(a3 + 4);
        LODWORD(buf.tv_sec) = 67110400;
        HIDWORD(buf.tv_sec) = v249;
        LOWORD(buf.tv_nsec) = 1024;
        *(_DWORD *)((char *)&buf.tv_nsec + 2) = v620;
        HIWORD(buf.tv_nsec) = 1024;
        *(_DWORD *)v625 = a4;
        *(_WORD *)&v625[4] = 1024;
        *(_DWORD *)&v625[6] = v29;
        LOWORD(v626) = 1024;
        *(_DWORD *)((char *)&v626 + 2) = v31;
        HIWORD(v626) = 1024;
        *(_DWORD *)v627 = v250;
        int v179 = "[R%u->mDNS] DNSServiceGetAddrInfo result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %d,"
               " name hash: %x, type: %{mdns:rrtype}d, rdata: <none>";
        goto LABEL_453;
      }
    }

    if (v66)
    {
      size_t v44 = 0LL;
      int v75 = 512;
      __int128 v76 = (char *)&unk_100164138;
    }

    else
    {
      __int128 v76 = (char *)malloc(v65);
      size_t v44 = v76;
      int v75 = v65;
      if (!v76) {
        goto LABEL_1088;
      }
    }

    if ((_DWORD)v65)
    {
      int v102 = v31;
      int v622 = 0;
      unsigned __int16 v621 = 0;
      uint64_t v103 = ResourceRecordGetRDataBytesPointer(a3, v76, v75, &v621, &v622, v33, v34, v35);
      if (v622) {
        goto LABEL_972;
      }
      __int16 v104 = (const void *)v103;
      int v610 = v29;
      size_t v105 = v621;
      v602 = v44;
      if (v621 >= 0x1FFuLL)
      {
        unsigned int v107 = v621 + 2;
        int v232 = (__int16 *)malloc(v621 + 2LL);
        if (!v232) {
          goto LABEL_1088;
        }
        int v108 = v232;
        uint64_t v98 = a7;
        unsigned int v106 = v232;
      }

      else
      {
        uint64_t v98 = a7;
        unsigned int v106 = 0LL;
        unsigned int v107 = 512;
        int v108 = word_100164338;
      }

      v579 = v106;
      if (v27) {
        int v227 = (os_log_s *)mDNSLogCategory_Default;
      }
      else {
        int v227 = (os_log_s *)mDNSLogCategory_mDNS;
      }
      if (gSensitiveLoggingEnabled != 1 || v227 == (os_log_s *)mDNSLogCategory_State)
      {
        if (!os_log_type_enabled(v227, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_888;
        }
        int v233 = *(_DWORD *)(v98 + 184);
        unsigned int v234 = bswap32(*(unsigned __int16 *)(a2 + 320)) >> 16;
        unsigned int v235 = *(unsigned __int16 *)(a3 + 4);
        int v236 = v105 + 2;
        if ((int)v105 + 2 <= v107)
        {
          *int v108 = __rev16(v235);
          int v367 = v104;
          int v368 = v233;
          unsigned int v369 = v234;
          memcpy(v108 + 1, v367, v105);
          unsigned int v234 = v369;
          int v233 = v368;
        }

        else
        {
          int v108 = 0LL;
        }
      }

      else
      {
        if (v27) {
          int v227 = (os_log_s *)mDNSLogCategory_Default_redacted;
        }
        else {
          int v227 = (os_log_s *)mDNSLogCategory_mDNS;
        }
        if (!os_log_type_enabled(v227, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_888;
        }
        int v233 = *(_DWORD *)(v98 + 184);
        unsigned int v234 = bswap32(*(unsigned __int16 *)(a2 + 320)) >> 16;
        unsigned int v235 = *(unsigned __int16 *)(a3 + 4);
        int v236 = v105 + 2;
        if ((int)v105 + 2 <= v107)
        {
          *int v108 = __rev16(v235);
          int v361 = v104;
          int v362 = v233;
          unsigned int v363 = v234;
          memcpy(v108 + 1, v361, v105);
          unsigned int v234 = v363;
          int v233 = v362;
        }

        else
        {
          int v108 = 0LL;
        }
      }

      LODWORD(buf.tv_sec) = 67111427;
      HIDWORD(buf.tv_sec) = v233;
      LOWORD(buf.tv_nsec) = 1024;
      *(_DWORD *)((char *)&buf.tv_nsec + 2) = v234;
      HIWORD(buf.tv_nsec) = 1024;
      *(_DWORD *)v625 = v620;
      *(_WORD *)&v625[4] = 1024;
      *(_DWORD *)&v625[6] = a4;
      LOWORD(v626) = 1024;
      *(_DWORD *)((char *)&v626 + 2) = v610;
      HIWORD(v626) = 1024;
      *(_DWORD *)v627 = v102;
      *(_WORD *)&v627[4] = 1024;
      *(_DWORD *)&v627[6] = v235;
      *(_WORD *)&v627[10] = 2160;
      *(void *)&v627[12] = 1752392040LL;
      *(_WORD *)&v627[20] = 1040;
      *(_DWORD *)&v627[22] = v236;
      *(_WORD *)&v627[26] = 2101;
      *(void *)&v627[28] = v108;
      int v360 = "[R%u->Q%u] DNSServiceGetAddrInfo result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %d, na"
             "me hash: %x, type: %{mdns:rrtype}d, rdata: %{sensitive, mask.hash, mdns:rdata}.*P";
      goto LABEL_829;
    }

    int v128 = v29;
    int v123 = v44;
    if (v27) {
      int v124 = (os_log_s *)mDNSLogCategory_Default;
    }
    else {
      int v124 = (os_log_s *)mDNSLogCategory_mDNS;
    }
    if (gSensitiveLoggingEnabled != 1 || v124 == (os_log_s *)mDNSLogCategory_State)
    {
      if (!os_log_type_enabled(v124, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_296;
      }
    }

    else
    {
      if (v27) {
        int v124 = (os_log_s *)mDNSLogCategory_Default_redacted;
      }
      else {
        int v124 = (os_log_s *)mDNSLogCategory_mDNS;
      }
      if (!os_log_type_enabled(v124, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_296;
      }
    }

    int v202 = *(_DWORD *)(a7 + 184);
    int v203 = *(unsigned __int16 *)(a3 + 4);
    LODWORD(buf.tv_sec) = 67110656;
    HIDWORD(buf.tv_sec) = v202;
    LOWORD(buf.tv_nsec) = 1024;
    *(_DWORD *)((char *)&buf.tv_nsec + 2) = __rev16(v64);
    HIWORD(buf.tv_nsec) = 1024;
    *(_DWORD *)v625 = v620;
    *(_WORD *)&v625[4] = 1024;
    *(_DWORD *)&v625[6] = a4;
    LOWORD(v626) = 1024;
    *(_DWORD *)((char *)&v626 + 2) = v128;
    HIWORD(v626) = 1024;
    *(_DWORD *)v627 = v31;
    *(_WORD *)&v627[4] = 1024;
    *(_DWORD *)&v627[6] = v203;
    int v127 = "[R%u->Q%u] DNSServiceGetAddrInfo result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %d, name"
           " hash: %x, type: %{mdns:rrtype}d, rdata: <none>";
    goto LABEL_295;
  }

  if (!v37)
  {
    uint64_t v53 = *(void *)(a3 + 56);
    if (v53)
    {
      int v54 = v29;
      int v55 = dnssec_obj_resource_record_member_get_validation_result(v53);
      unsigned int v56 = *(unsigned __int16 *)(a2 + 320);
      unint64_t v57 = *(unsigned __int16 *)(a3 + 12);
      BOOL v58 = v57 < 0x201;
      if (v55)
      {
        int v59 = v55;
        if (*(_WORD *)(a2 + 320))
        {
          if (v57 >= 0x201)
          {
            size_t v44 = (char *)malloc(*(unsigned __int16 *)(a3 + 12));
            int v60 = v44;
            if (!v44) {
              goto LABEL_1088;
            }
            goto LABEL_180;
          }

          if (*(_WORD *)(a3 + 12))
          {
            size_t v44 = 0LL;
            int v60 = (char *)&unk_100164138;
            LODWORD(v57) = 512;
LABEL_180:
            int v622 = 0;
            unsigned __int16 v621 = 0;
            uint64_t v138 = ResourceRecordGetRDataBytesPointer(a3, v60, v57, &v621, &v622, v33, v34, v35);
            if (v622) {
              goto LABEL_972;
            }
            __int128 v139 = (const void *)v138;
            int v594 = v31;
            size_t v140 = v621;
            uint64_t v586 = a7;
            v602 = v44;
            if (v621 >= 0x1FFuLL)
            {
              unsigned int v141 = v621 + 2;
              size_t v262 = (__int16 *)malloc(v621 + 2LL);
              if (!v262) {
                goto LABEL_1088;
              }
              __int16 v142 = v262;
              v579 = v262;
            }

            else
            {
              v579 = 0LL;
              unsigned int v141 = 512;
              __int16 v142 = word_100164338;
            }

            if (v27) {
              int v263 = (os_log_s *)mDNSLogCategory_Default;
            }
            else {
              int v263 = (os_log_s *)mDNSLogCategory_mDNS;
            }
            if (gSensitiveLoggingEnabled == 1 && v263 != (os_log_s *)mDNSLogCategory_State)
            {
              if (v27) {
                int v263 = (os_log_s *)mDNSLogCategory_Default_redacted;
              }
              else {
                int v263 = (os_log_s *)mDNSLogCategory_mDNS;
              }
              if (!os_log_type_enabled(v263, OS_LOG_TYPE_DEFAULT)) {
                goto LABEL_916;
              }
              int v264 = *(_DWORD *)(v586 + 184);
              unsigned int v265 = bswap32(*(unsigned __int16 *)(a2 + 320)) >> 16;
              unsigned int v266 = *(unsigned __int16 *)(a3 + 4);
              int v267 = v140 + 2;
              if ((int)v140 + 2 <= v141)
              {
                unsigned int v268 = v142;
                *__int16 v142 = __rev16(v266);
                uint64_t v372 = v142 + 1;
                char v373 = v139;
                int v374 = v264;
                unsigned int v375 = v265;
                memcpy(v372, v373, v140);
                unsigned int v265 = v375;
                int v264 = v374;
              }

              else
              {
                unsigned int v268 = 0LL;
              }

              goto LABEL_831;
            }

            if (os_log_type_enabled(v263, OS_LOG_TYPE_DEFAULT))
            {
              int v264 = *(_DWORD *)(v586 + 184);
              unsigned int v265 = bswap32(*(unsigned __int16 *)(a2 + 320)) >> 16;
              unsigned int v266 = *(unsigned __int16 *)(a3 + 4);
              int v267 = v140 + 2;
              if ((int)v140 + 2 <= v141)
              {
                unsigned int v268 = v142;
                *__int16 v142 = __rev16(v266);
                v381 = v142 + 1;
                __int32 v382 = v139;
                int v383 = v264;
                unsigned int v384 = v265;
                memcpy(v381, v382, v140);
                unsigned int v265 = v384;
                int v264 = v383;
              }

              else
              {
                unsigned int v268 = 0LL;
              }

LABEL_831:
              LODWORD(buf.tv_sec) = 67111683;
              HIDWORD(buf.tv_sec) = v264;
              LOWORD(buf.tv_nsec) = 1024;
              *(_DWORD *)((char *)&buf.tv_nsec + 2) = v265;
              HIWORD(buf.tv_nsec) = 1024;
              *(_DWORD *)v625 = v620;
              *(_WORD *)&v625[4] = 1024;
              *(_DWORD *)&v625[6] = a4;
              LOWORD(v626) = 1024;
              *(_DWORD *)((char *)&v626 + 2) = v54;
              HIWORD(v626) = 1024;
              *(_DWORD *)v627 = v594;
              *(_WORD *)&v627[4] = 1026;
              *(_DWORD *)&v627[6] = v59;
              *(_WORD *)&v627[10] = 1024;
              *(_DWORD *)&v627[12] = v266;
              *(_WORD *)&v627[16] = 2160;
              *(void *)&v627[18] = 1752392040LL;
              *(_WORD *)&v627[26] = 1040;
              *(_DWORD *)&v627[28] = v267;
              *(_WORD *)&v627[32] = 2101;
              *(void *)&v627[34] = v268;
              v376 = "[R%u->Q%u] DNSServiceQueryRecord result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex"
                     ": %d, name hash: %x, dnssec: %{public, mdns:dnssec_result}d, type: %{mdns:rrtype}d, rdata: %{sensit"
                     "ive, mask.hash, mdns:rdata}.*P";
LABEL_836:
              v389 = v263;
              uint32_t v390 = 76;
LABEL_915:
              _os_log_impl((void *)&_mh_execute_header, v389, OS_LOG_TYPE_DEFAULT, v376, (uint8_t *)&buf, v390);
              a2 = v619;
            }

LABEL_916:
            a7 = v586;
LABEL_917:
            size_t v44 = v602;
            uint64_t v434 = v579;
            if (!v579) {
              goto LABEL_972;
            }
LABEL_971:
            free(v434);
            goto LABEL_972;
          }

          if (v27) {
            unsigned __int16 v213 = (os_log_s *)mDNSLogCategory_Default;
          }
          else {
            unsigned __int16 v213 = (os_log_s *)mDNSLogCategory_mDNS;
          }
          if (gSensitiveLoggingEnabled != 1 || v213 == (os_log_s *)mDNSLogCategory_State)
          {
            if (!os_log_type_enabled(v213, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_974;
            }
          }

          else
          {
            if (v27) {
              unsigned __int16 v213 = (os_log_s *)mDNSLogCategory_Default_redacted;
            }
            else {
              unsigned __int16 v213 = (os_log_s *)mDNSLogCategory_mDNS;
            }
            if (!os_log_type_enabled(v213, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_974;
            }
          }

          int v214 = *(_DWORD *)(a7 + 184);
          int v215 = *(unsigned __int16 *)(a3 + 4);
          LODWORD(buf.tv_sec) = 67110912;
          HIDWORD(buf.tv_sec) = v214;
          LOWORD(buf.tv_nsec) = 1024;
          *(_DWORD *)((char *)&buf.tv_nsec + 2) = __rev16(v56);
          HIWORD(buf.tv_nsec) = 1024;
          *(_DWORD *)v625 = v620;
          *(_WORD *)&v625[4] = 1024;
          *(_DWORD *)&v625[6] = a4;
          LOWORD(v626) = 1024;
          *(_DWORD *)((char *)&v626 + 2) = v54;
          HIWORD(v626) = 1024;
          *(_DWORD *)v627 = v31;
          *(_WORD *)&v627[4] = 1026;
          *(_DWORD *)&v627[6] = v59;
          *(_WORD *)&v627[10] = 1024;
          *(_DWORD *)&v627[12] = v215;
          unsigned __int16 v216 = "[R%u->Q%u] DNSServiceQueryRecord result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %d"
                 ", name hash: %x, dnssec: %{public, mdns:dnssec_result}d, type: %{mdns:rrtype}d, rdata: <none>";
          goto LABEL_698;
        }

        if (v57 >= 0x201)
        {
          size_t v44 = (char *)malloc(*(unsigned __int16 *)(a3 + 12));
          int v111 = v44;
          if (!v44) {
            goto LABEL_1088;
          }
          goto LABEL_268;
        }

        if (*(_WORD *)(a3 + 12))
        {
          size_t v44 = 0LL;
          int v111 = (char *)&unk_100164138;
          LODWORD(v57) = 512;
LABEL_268:
          int v622 = 0;
          unsigned __int16 v621 = 0;
          uint64_t v188 = ResourceRecordGetRDataBytesPointer(a3, v111, v57, &v621, &v622, v33, v34, v35);
          if (v622) {
            goto LABEL_972;
          }
          size_t v189 = (const void *)v188;
          int v600 = v31;
          size_t v190 = v621;
          uint64_t v586 = a7;
          v602 = v44;
          if (v621 >= 0x1FFuLL)
          {
            unsigned int v191 = v621 + 2;
            uint64_t v326 = (__int16 *)malloc(v621 + 2LL);
            if (!v326) {
              goto LABEL_1088;
            }
            unsigned int v192 = v326;
            v579 = v326;
          }

          else
          {
            v579 = 0LL;
            unsigned int v191 = 512;
            unsigned int v192 = word_100164338;
          }

          if (v27) {
            uint64_t v327 = (os_log_s *)mDNSLogCategory_Default;
          }
          else {
            uint64_t v327 = (os_log_s *)mDNSLogCategory_mDNS;
          }
          if (gSensitiveLoggingEnabled != 1 || v327 == (os_log_s *)mDNSLogCategory_State)
          {
            if (!os_log_type_enabled(v327, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_916;
            }
            int v328 = *(_DWORD *)(v586 + 184);
            unsigned int v329 = *(unsigned __int16 *)(a3 + 4);
            int v330 = v190 + 2;
            if ((int)v190 + 2 <= v191)
            {
              __int16 *v192 = __rev16(v329);
              v470 = v189;
              int v471 = v328;
              memcpy(v192 + 1, v470, v190);
              int v328 = v471;
            }

            else
            {
              unsigned int v192 = 0LL;
            }
          }

          else
          {
            if (v27) {
              uint64_t v327 = (os_log_s *)mDNSLogCategory_Default_redacted;
            }
            else {
              uint64_t v327 = (os_log_s *)mDNSLogCategory_mDNS;
            }
            if (!os_log_type_enabled(v327, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_916;
            }
            int v328 = *(_DWORD *)(v586 + 184);
            unsigned int v329 = *(unsigned __int16 *)(a3 + 4);
            int v330 = v190 + 2;
            if ((int)v190 + 2 <= v191)
            {
              __int16 *v192 = __rev16(v329);
              uint64_t v466 = v189;
              int v467 = v328;
              memcpy(v192 + 1, v466, v190);
              int v328 = v467;
            }

            else
            {
              unsigned int v192 = 0LL;
            }
          }

          LODWORD(buf.tv_sec) = 67111427;
          HIDWORD(buf.tv_sec) = v328;
          LOWORD(buf.tv_nsec) = 1024;
          *(_DWORD *)((char *)&buf.tv_nsec + 2) = v620;
          HIWORD(buf.tv_nsec) = 1024;
          *(_DWORD *)v625 = a4;
          *(_WORD *)&v625[4] = 1024;
          *(_DWORD *)&v625[6] = v54;
          LOWORD(v626) = 1024;
          *(_DWORD *)((char *)&v626 + 2) = v600;
          HIWORD(v626) = 1026;
          *(_DWORD *)v627 = v59;
          *(_WORD *)&v627[4] = 1024;
          *(_DWORD *)&v627[6] = v329;
          *(_WORD *)&v627[10] = 2160;
          *(void *)&v627[12] = 1752392040LL;
          *(_WORD *)&v627[20] = 1040;
          *(_DWORD *)&v627[22] = v330;
          *(_WORD *)&v627[26] = 2101;
          *(void *)&v627[28] = v192;
          v376 = "[R%u->mDNS] DNSServiceQueryRecord result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %"
                 "d, name hash: %x, dnssec: %{public, mdns:dnssec_result}d, type: %{mdns:rrtype}d, rdata: %{sensitive, ma"
                 "sk.hash, mdns:rdata}.*P";
LABEL_914:
          v389 = v327;
          uint32_t v390 = 70;
          goto LABEL_915;
        }

        if (v27) {
          int v286 = (os_log_s *)mDNSLogCategory_Default;
        }
        else {
          int v286 = (os_log_s *)mDNSLogCategory_mDNS;
        }
        if (gSensitiveLoggingEnabled != 1 || v286 == (os_log_s *)mDNSLogCategory_State)
        {
          if (!os_log_type_enabled(v286, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_974;
          }
        }

        else
        {
          if (v27) {
            int v286 = (os_log_s *)mDNSLogCategory_Default_redacted;
          }
          else {
            int v286 = (os_log_s *)mDNSLogCategory_mDNS;
          }
          if (!os_log_type_enabled(v286, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_974;
          }
        }

        int v287 = *(_DWORD *)(a7 + 184);
        int v288 = *(unsigned __int16 *)(a3 + 4);
        LODWORD(buf.tv_sec) = 67110656;
        HIDWORD(buf.tv_sec) = v287;
        LOWORD(buf.tv_nsec) = 1024;
        *(_DWORD *)((char *)&buf.tv_nsec + 2) = v620;
        HIWORD(buf.tv_nsec) = 1024;
        *(_DWORD *)v625 = a4;
        *(_WORD *)&v625[4] = 1024;
        *(_DWORD *)&v625[6] = v54;
        LOWORD(v626) = 1024;
        *(_DWORD *)((char *)&v626 + 2) = v31;
        HIWORD(v626) = 1026;
        *(_DWORD *)v627 = v59;
        *(_WORD *)&v627[4] = 1024;
        *(_DWORD *)&v627[6] = v288;
        unsigned __int16 v216 = "[R%u->mDNS] DNSServiceQueryRecord result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %d,"
               " name hash: %x, dnssec: %{public, mdns:dnssec_result}d, type: %{mdns:rrtype}d, rdata: <none>";
LABEL_811:
        int v317 = v286;
        uint32_t v318 = 44;
        goto LABEL_1087;
      }

      if (!*(_WORD *)(a2 + 320)) {
        goto LABEL_82;
      }
    }

    else
    {
      unsigned int v56 = *(unsigned __int16 *)(a2 + 320);
      LODWORD(v57) = *(unsigned __int16 *)(a3 + 12);
      BOOL v58 = v57 < 0x201;
      if (!*(_WORD *)(a2 + 320))
      {
LABEL_82:
        if (v58)
        {
          size_t v44 = 0LL;
          int v81 = 512;
          __int16 v82 = (char *)&unk_100164138;
        }

        else
        {
          __int16 v82 = (char *)malloc(v57);
          size_t v44 = v82;
          int v81 = v57;
          if (!v82) {
            goto LABEL_1088;
          }
        }

        if ((_DWORD)v57)
        {
          int v622 = 0;
          unsigned __int16 v621 = 0;
          uint64_t v158 = ResourceRecordGetRDataBytesPointer(a3, v82, v81, &v621, &v622, v33, v34, v35);
          if (v622) {
            goto LABEL_972;
          }
          int v159 = (const void *)v158;
          int v613 = v29;
          size_t v160 = v621;
          v602 = v44;
          if (v621 >= 0x1FFuLL)
          {
            unsigned int v161 = v621 + 2;
            int v296 = (__int16 *)malloc(v621 + 2LL);
            if (!v296) {
              goto LABEL_1088;
            }
            __int16 v162 = v296;
            uint64_t v98 = a7;
            v579 = v296;
          }

          else
          {
            uint64_t v98 = a7;
            v579 = 0LL;
            unsigned int v161 = 512;
            __int16 v162 = word_100164338;
          }

          if (v27) {
            int v297 = (os_log_s *)mDNSLogCategory_Default;
          }
          else {
            int v297 = (os_log_s *)mDNSLogCategory_mDNS;
          }
          if (gSensitiveLoggingEnabled == 1 && v297 != (os_log_s *)mDNSLogCategory_State)
          {
            if (v27) {
              int v297 = (os_log_s *)mDNSLogCategory_Default_redacted;
            }
            else {
              int v297 = (os_log_s *)mDNSLogCategory_mDNS;
            }
            if (!os_log_type_enabled(v297, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_888;
            }
            int v298 = *(_DWORD *)(v98 + 184);
            unsigned int v299 = *(unsigned __int16 *)(a3 + 4);
            int v300 = v160 + 2;
            if ((int)v160 + 2 <= v161)
            {
              __int16 *v162 = __rev16(v299);
              unsigned int v437 = v159;
              int v438 = v298;
              memcpy(v162 + 1, v437, v160);
              int v298 = v438;
            }

            else
            {
              __int16 v162 = 0LL;
            }

            goto LABEL_881;
          }

          if (os_log_type_enabled(v297, OS_LOG_TYPE_DEFAULT))
          {
            int v298 = *(_DWORD *)(v98 + 184);
            unsigned int v299 = *(unsigned __int16 *)(a3 + 4);
            int v300 = v160 + 2;
            if ((int)v160 + 2 <= v161)
            {
              __int16 *v162 = __rev16(v299);
              int v440 = v159;
              int v441 = v298;
              memcpy(v162 + 1, v440, v160);
              int v298 = v441;
            }

            else
            {
              __int16 v162 = 0LL;
            }

LABEL_881:
            LODWORD(buf.tv_sec) = 67111171;
            HIDWORD(buf.tv_sec) = v298;
            LOWORD(buf.tv_nsec) = 1024;
            *(_DWORD *)((char *)&buf.tv_nsec + 2) = v620;
            HIWORD(buf.tv_nsec) = 1024;
            *(_DWORD *)v625 = a4;
            *(_WORD *)&v625[4] = 1024;
            *(_DWORD *)&v625[6] = v613;
            LOWORD(v626) = 1024;
            *(_DWORD *)((char *)&v626 + 2) = v31;
            HIWORD(v626) = 1024;
            *(_DWORD *)v627 = v299;
            *(_WORD *)&v627[4] = 2160;
            *(void *)&v627[6] = 1752392040LL;
            *(_WORD *)&v627[14] = 1040;
            *(_DWORD *)&v627[16] = v300;
            *(_WORD *)&v627[20] = 2101;
            *(void *)&v627[22] = v162;
            int v360 = "[R%u->mDNS] DNSServiceQueryRecord result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex:"
                   " %d, name hash: %x, type: %{mdns:rrtype}d, rdata: %{sensitive, mask.hash, mdns:rdata}.*P";
LABEL_886:
            unsigned __int16 v370 = v297;
            uint32_t v371 = 64;
            goto LABEL_887;
          }

LABEL_888:
          a7 = v98;
          goto LABEL_917;
        }

        if (v27) {
          unsigned __int16 v176 = (os_log_s *)mDNSLogCategory_Default;
        }
        else {
          unsigned __int16 v176 = (os_log_s *)mDNSLogCategory_mDNS;
        }
        if (gSensitiveLoggingEnabled != 1 || v176 == (os_log_s *)mDNSLogCategory_State)
        {
          if (!os_log_type_enabled(v176, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_972;
          }
        }

        else
        {
          if (v27) {
            unsigned __int16 v176 = (os_log_s *)mDNSLogCategory_Default_redacted;
          }
          else {
            unsigned __int16 v176 = (os_log_s *)mDNSLogCategory_mDNS;
          }
          if (!os_log_type_enabled(v176, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_972;
          }
        }

        int v177 = *(_DWORD *)(a7 + 184);
        int v178 = *(unsigned __int16 *)(a3 + 4);
        LODWORD(buf.tv_sec) = 67110400;
        HIDWORD(buf.tv_sec) = v177;
        LOWORD(buf.tv_nsec) = 1024;
        *(_DWORD *)((char *)&buf.tv_nsec + 2) = v620;
        HIWORD(buf.tv_nsec) = 1024;
        *(_DWORD *)v625 = a4;
        *(_WORD *)&v625[4] = 1024;
        *(_DWORD *)&v625[6] = v29;
        LOWORD(v626) = 1024;
        *(_DWORD *)((char *)&v626 + 2) = v31;
        HIWORD(v626) = 1024;
        *(_DWORD *)v627 = v178;
        int v179 = "[R%u->mDNS] DNSServiceQueryRecord result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %d,"
               " name hash: %x, type: %{mdns:rrtype}d, rdata: <none>";
LABEL_453:
        uint32_t v251 = v176;
        uint32_t v252 = 38;
LABEL_879:
        _os_log_impl((void *)&_mh_execute_header, v251, OS_LOG_TYPE_DEFAULT, v179, (uint8_t *)&buf, v252);
        goto LABEL_972;
      }
    }

    if (v58)
    {
      size_t v44 = 0LL;
      int v73 = 512;
      size_t v74 = (char *)&unk_100164138;
    }

    else
    {
      size_t v74 = (char *)malloc(v57);
      size_t v44 = v74;
      int v73 = v57;
      if (!v74) {
        goto LABEL_1088;
      }
    }

    if ((_DWORD)v57)
    {
      int v622 = 0;
      unsigned __int16 v621 = 0;
      uint64_t v95 = ResourceRecordGetRDataBytesPointer(a3, v74, v73, &v621, &v622, v33, v34, v35);
      if (v622) {
        goto LABEL_972;
      }
      int v96 = (const void *)v95;
      int v609 = v29;
      size_t v97 = v621;
      v602 = v44;
      if (v621 >= 0x1FFuLL)
      {
        unsigned int v100 = v621 + 2;
        int v226 = (__int16 *)malloc(v621 + 2LL);
        if (!v226) {
          goto LABEL_1088;
        }
        __int16 v101 = v226;
        uint64_t v98 = a7;
        uint64_t v99 = v226;
      }

      else
      {
        uint64_t v98 = a7;
        uint64_t v99 = 0LL;
        unsigned int v100 = 512;
        __int16 v101 = word_100164338;
      }

      v579 = v99;
      if (v27) {
        int v227 = (os_log_s *)mDNSLogCategory_Default;
      }
      else {
        int v227 = (os_log_s *)mDNSLogCategory_mDNS;
      }
      if (gSensitiveLoggingEnabled != 1 || v227 == (os_log_s *)mDNSLogCategory_State)
      {
        if (!os_log_type_enabled(v227, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_888;
        }
        int v228 = *(_DWORD *)(v98 + 184);
        unsigned int v229 = bswap32(*(unsigned __int16 *)(a2 + 320)) >> 16;
        unsigned int v230 = *(unsigned __int16 *)(a3 + 4);
        int v231 = v97 + 2;
        if ((int)v97 + 2 <= v100)
        {
          *__int16 v101 = __rev16(v230);
          size_t v364 = v96;
          int v365 = v228;
          unsigned int v366 = v229;
          memcpy(v101 + 1, v364, v97);
          unsigned int v229 = v366;
          int v228 = v365;
        }

        else
        {
          __int16 v101 = 0LL;
        }
      }

      else
      {
        if (v27) {
          int v227 = (os_log_s *)mDNSLogCategory_Default_redacted;
        }
        else {
          int v227 = (os_log_s *)mDNSLogCategory_mDNS;
        }
        if (!os_log_type_enabled(v227, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_888;
        }
        int v228 = *(_DWORD *)(v98 + 184);
        unsigned int v229 = bswap32(*(unsigned __int16 *)(a2 + 320)) >> 16;
        unsigned int v230 = *(unsigned __int16 *)(a3 + 4);
        int v231 = v97 + 2;
        if ((int)v97 + 2 <= v100)
        {
          *__int16 v101 = __rev16(v230);
          unsigned int v357 = v96;
          int v358 = v228;
          unsigned int v359 = v229;
          memcpy(v101 + 1, v357, v97);
          unsigned int v229 = v359;
          int v228 = v358;
        }

        else
        {
          __int16 v101 = 0LL;
        }
      }

      LODWORD(buf.tv_sec) = 67111427;
      HIDWORD(buf.tv_sec) = v228;
      LOWORD(buf.tv_nsec) = 1024;
      *(_DWORD *)((char *)&buf.tv_nsec + 2) = v229;
      HIWORD(buf.tv_nsec) = 1024;
      *(_DWORD *)v625 = v620;
      *(_WORD *)&v625[4] = 1024;
      *(_DWORD *)&v625[6] = a4;
      LOWORD(v626) = 1024;
      *(_DWORD *)((char *)&v626 + 2) = v609;
      HIWORD(v626) = 1024;
      *(_DWORD *)v627 = v31;
      *(_WORD *)&v627[4] = 1024;
      *(_DWORD *)&v627[6] = v230;
      *(_WORD *)&v627[10] = 2160;
      *(void *)&v627[12] = 1752392040LL;
      *(_WORD *)&v627[20] = 1040;
      *(_DWORD *)&v627[22] = v231;
      *(_WORD *)&v627[26] = 2101;
      *(void *)&v627[28] = v101;
      int v360 = "[R%u->Q%u] DNSServiceQueryRecord result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %d, na"
             "me hash: %x, type: %{mdns:rrtype}d, rdata: %{sensitive, mask.hash, mdns:rdata}.*P";
LABEL_829:
      unsigned __int16 v370 = v227;
      uint32_t v371 = 70;
LABEL_887:
      _os_log_impl((void *)&_mh_execute_header, v370, OS_LOG_TYPE_DEFAULT, v360, (uint8_t *)&buf, v371);
      a2 = v619;
      goto LABEL_888;
    }

    int v122 = v29;
    int v123 = v44;
    if (v27) {
      int v124 = (os_log_s *)mDNSLogCategory_Default;
    }
    else {
      int v124 = (os_log_s *)mDNSLogCategory_mDNS;
    }
    if (gSensitiveLoggingEnabled == 1 && v124 != (os_log_s *)mDNSLogCategory_State)
    {
      if (v27) {
        int v124 = (os_log_s *)mDNSLogCategory_Default_redacted;
      }
      else {
        int v124 = (os_log_s *)mDNSLogCategory_mDNS;
      }
      if (!os_log_type_enabled(v124, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_296;
      }
      goto LABEL_160;
    }

    if (os_log_type_enabled(v124, OS_LOG_TYPE_DEFAULT))
    {
LABEL_160:
      int v125 = *(_DWORD *)(a7 + 184);
      int v126 = *(unsigned __int16 *)(a3 + 4);
      LODWORD(buf.tv_sec) = 67110656;
      HIDWORD(buf.tv_sec) = v125;
      LOWORD(buf.tv_nsec) = 1024;
      *(_DWORD *)((char *)&buf.tv_nsec + 2) = __rev16(v56);
      HIWORD(buf.tv_nsec) = 1024;
      *(_DWORD *)v625 = v620;
      *(_WORD *)&v625[4] = 1024;
      *(_DWORD *)&v625[6] = a4;
      LOWORD(v626) = 1024;
      *(_DWORD *)((char *)&v626 + 2) = v122;
      HIWORD(v626) = 1024;
      *(_DWORD *)v627 = v31;
      *(_WORD *)&v627[4] = 1024;
      *(_DWORD *)&v627[6] = v126;
      int v127 = "[R%u->Q%u] DNSServiceQueryRecord result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %d, na"
             "me hash: %x, type: %{mdns:rrtype}d, rdata: <none>";
LABEL_295:
      _os_log_impl((void *)&_mh_execute_header, v124, OS_LOG_TYPE_DEFAULT, v127, (uint8_t *)&buf, 0x2Cu);
    }

LABEL_296:
    size_t v44 = v123;
    goto LABEL_972;
  }

  *(_DWORD *)(a7 + 192) = buf.tv_sec;
  uint64_t v38 = *(void *)(a3 + 56);
  if (v38)
  {
    int v605 = v29;
    int v39 = dnssec_obj_resource_record_member_get_validation_result(v38);
    unsigned int v40 = *(unsigned __int16 *)(a2 + 320);
    unint64_t v41 = *(unsigned __int16 *)(a3 + 12);
    BOOL v42 = v41 < 0x201;
    if (v39)
    {
      int v43 = v39;
      if (*(_WORD *)(a2 + 320))
      {
        if (v41 >= 0x201)
        {
          size_t v44 = (char *)malloc(*(unsigned __int16 *)(a3 + 12));
          __int128 v45 = v44;
          if (!v44) {
            goto LABEL_1088;
          }
          goto LABEL_172;
        }

        if (*(_WORD *)(a3 + 12))
        {
          size_t v44 = 0LL;
          __int128 v45 = (char *)&unk_100164138;
          LODWORD(v41) = 512;
LABEL_172:
          int v622 = 0;
          unsigned __int16 v621 = 0;
          uint64_t v129 = ResourceRecordGetRDataBytesPointer(a3, v45, v41, &v621, &v622, v33, v34, v35);
          if (v622) {
            goto LABEL_972;
          }
          size_t v130 = v621;
          int v592 = v31;
          int v603 = v44;
          v570 = (const void *)v129;
          if (v621 < 0x1FFuLL)
          {
            int v131 = 0LL;
            unsigned int v132 = 512;
            int v133 = word_100164338;
LABEL_456:
            unsigned int v580 = v133;
            if (v27) {
              unsigned int v253 = (os_log_s *)mDNSLogCategory_Default;
            }
            else {
              unsigned int v253 = (os_log_s *)mDNSLogCategory_mDNS;
            }
            if (gSensitiveLoggingEnabled == 1 && v253 != (os_log_s *)mDNSLogCategory_State)
            {
              if (v27) {
                unsigned int v253 = (os_log_s *)mDNSLogCategory_Default_redacted;
              }
              else {
                unsigned int v253 = (os_log_s *)mDNSLogCategory_mDNS;
              }
              if (!os_log_type_enabled(v253, OS_LOG_TYPE_DEFAULT)) {
                goto LABEL_969;
              }
              int v254 = *(_DWORD *)(a7 + 184);
              unsigned int v255 = bswap32(*(unsigned __int16 *)(a2 + 320)) >> 16;
              unsigned int v256 = (_BYTE *)(a2 + 356);
              uint64_t v588 = a7;
              v569 = v131;
              if (a2 == -612)
              {
LABEL_467:
                while (v256)
                {
                  uint64_t v257 = *v256;
                  if (!*v256)
                  {
                    unsigned __int16 v351 = (_WORD)v256 - v30 + 1;
                    goto LABEL_890;
                  }

                  v256 += v257 + 1;
                  if (a2 != -612) {
                    goto LABEL_466;
                  }
                }
              }

              else
              {
LABEL_466:
              }

              unsigned __int16 v351 = 257;
LABEL_890:
              int v443 = v351;
              unsigned int v444 = *(unsigned __int16 *)(a3 + 4);
              int v445 = v130 + 2;
              if ((int)v130 + 2 <= v132)
              {
                *unsigned int v580 = __rev16(v444);
                size_t v447 = v130;
                int v448 = v254;
                unsigned int v449 = v255;
                memcpy(v580 + 1, v570, v447);
                unsigned int v255 = v449;
                int v254 = v448;
                v446 = v580;
              }

              else
              {
                v446 = 0LL;
              }

              goto LABEL_893;
            }

            if (os_log_type_enabled(v253, OS_LOG_TYPE_DEFAULT))
            {
              int v254 = *(_DWORD *)(a7 + 184);
              unsigned int v255 = bswap32(*(unsigned __int16 *)(a2 + 320)) >> 16;
              int v275 = (_BYTE *)(a2 + 356);
              uint64_t v588 = a7;
              v569 = v131;
              if (a2 == -612)
              {
LABEL_519:
                while (v275)
                {
                  uint64_t v276 = *v275;
                  if (!*v275)
                  {
                    unsigned __int16 v353 = (_WORD)v275 - v30 + 1;
                    goto LABEL_899;
                  }

                  v275 += v276 + 1;
                  if (a2 != -612) {
                    goto LABEL_518;
                  }
                }
              }

              else
              {
LABEL_518:
              }

              unsigned __int16 v353 = 257;
LABEL_899:
              int v443 = v353;
              unsigned int v444 = *(unsigned __int16 *)(a3 + 4);
              int v445 = v130 + 2;
              if ((int)v130 + 2 <= v132)
              {
                *unsigned int v580 = __rev16(v444);
                size_t v458 = v130;
                int v459 = v254;
                unsigned int v460 = v255;
                memcpy(v580 + 1, v570, v458);
                unsigned int v255 = v460;
                int v254 = v459;
                v446 = v580;
              }

              else
              {
                v446 = 0LL;
              }

LABEL_969:
            size_t v44 = v603;
            if (!v131) {
              goto LABEL_972;
            }
            uint64_t v434 = v131;
            goto LABEL_971;
          }

          unsigned int v132 = v621 + 2;
          int v133 = (__int16 *)malloc(v621 + 2LL);
          if (v133)
          {
            int v131 = v133;
            goto LABEL_456;
          }

LABEL_943:
        int v489 = *(unsigned __int16 *)(a3 + 4);
        LODWORD(buf.tv_sec) = 67111683;
        HIDWORD(buf.tv_sec) = v205;
        LOWORD(buf.tv_nsec) = 1024;
        *(_DWORD *)((char *)&buf.tv_nsec + 2) = v206;
        HIWORD(buf.tv_nsec) = 1024;
        *(_DWORD *)v625 = v620;
        *(_WORD *)&v625[4] = 1024;
        *(_DWORD *)&v625[6] = a4;
        LOWORD(v626) = 1024;
        *(_DWORD *)((char *)&v626 + 2) = v605;
        HIWORD(v626) = 2160;
        *(void *)v627 = 1752392040LL;
        *(_WORD *)&v627[8] = 1040;
        *(_DWORD *)&v627[10] = v395;
        *(_WORD *)&v627[14] = 2101;
        *(void *)&v627[16] = a2 + 356;
        *(_WORD *)&v627[24] = 1024;
        *(_DWORD *)&v627[26] = v31;
        *(_WORD *)&v627[30] = 1026;
        *(_DWORD *)&v627[32] = v43;
        *(_WORD *)&v627[36] = 1024;
        *(_DWORD *)&v627[38] = v489;
        unsigned __int16 v216 = "[R%u->Q%u] DNSServiceQueryRecord result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %d, "
               "name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%x), dnssec: %{public, mdns:dnssec_result}d,"
               " type: %{mdns:rrtype}d, rdata: <none>";
        goto LABEL_948;
      }

      if (v41 >= 0x201)
      {
        size_t v44 = (char *)malloc(*(unsigned __int16 *)(a3 + 12));
        int v109 = v44;
        if (!v44) {
          goto LABEL_1088;
        }
        goto LABEL_260;
      }

      if (*(_WORD *)(a3 + 12))
      {
        size_t v44 = 0LL;
        int v109 = (char *)&unk_100164138;
        LODWORD(v41) = 512;
LABEL_260:
        int v622 = 0;
        unsigned __int16 v621 = 0;
        uint64_t v180 = ResourceRecordGetRDataBytesPointer(a3, v109, v41, &v621, &v622, v33, v34, v35);
        if (v622) {
          goto LABEL_972;
        }
        int v603 = v44;
        int v598 = v31;
        size_t v181 = v621;
        int v572 = (const void *)v180;
        if (v621 >= 0x1FFuLL)
        {
          unsigned int v182 = v621 + 2;
          unsigned __int16 v183 = (__int16 *)malloc(v621 + 2LL);
          if (!v183) {
            goto LABEL_1088;
          }
          int v131 = v183;
        }

        else
        {
          int v131 = 0LL;
          unsigned int v182 = 512;
          unsigned __int16 v183 = word_100164338;
        }

        int v584 = v183;
        if (v27) {
          uint64_t v319 = (os_log_s *)mDNSLogCategory_Default;
        }
        else {
          uint64_t v319 = (os_log_s *)mDNSLogCategory_mDNS;
        }
        if (gSensitiveLoggingEnabled != 1 || v319 == (os_log_s *)mDNSLogCategory_State)
        {
          if (!os_log_type_enabled(v319, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_969;
          }
          int v320 = *(_DWORD *)(a7 + 184);
          unsigned int v335 = (_BYTE *)(a2 + 356);
          uint64_t v588 = a7;
          v569 = v131;
          if (a2 == -612)
          {
LABEL_764:
            while (v335)
            {
              uint64_t v336 = *v335;
              if (!*v335)
              {
                unsigned __int16 v399 = (_WORD)v335 - v30 + 1;
                goto LABEL_959;
              }

              v335 += v336 + 1;
              if (a2 != -612) {
                goto LABEL_763;
              }
            }
          }

          else
          {
LABEL_763:
          }

          unsigned __int16 v399 = 257;
LABEL_959:
          int v491 = v399;
          unsigned int v492 = *(unsigned __int16 *)(a3 + 4);
          int v493 = v181 + 2;
          if ((int)v181 + 2 <= v182)
          {
            *int v584 = __rev16(v492);
            int v501 = v320;
            memcpy(v584 + 1, v572, v181);
            int v320 = v501;
            unsigned __int16 v494 = v584;
          }

          else
          {
            unsigned __int16 v494 = 0LL;
          }
        }

        else
        {
          if (v27) {
            uint64_t v319 = (os_log_s *)mDNSLogCategory_Default_redacted;
          }
          else {
            uint64_t v319 = (os_log_s *)mDNSLogCategory_mDNS;
          }
          if (!os_log_type_enabled(v319, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_969;
          }
          int v320 = *(_DWORD *)(a7 + 184);
          size_t v321 = (_BYTE *)(a2 + 356);
          uint64_t v588 = a7;
          v569 = v131;
          if (a2 == -612)
          {
LABEL_712:
            while (v321)
            {
              uint64_t v322 = *v321;
              if (!*v321)
              {
                unsigned __int16 v397 = (_WORD)v321 - v30 + 1;
                goto LABEL_950;
              }

              v321 += v322 + 1;
              if (a2 != -612) {
                goto LABEL_711;
              }
            }
          }

          else
          {
LABEL_711:
          }

          unsigned __int16 v397 = 257;
LABEL_950:
          int v491 = v397;
          unsigned int v492 = *(unsigned __int16 *)(a3 + 4);
          int v493 = v181 + 2;
          if ((int)v181 + 2 <= v182)
          {
            *int v584 = __rev16(v492);
            int v495 = v320;
            memcpy(v584 + 1, v572, v181);
            int v320 = v495;
            unsigned __int16 v494 = v584;
          }

          else
          {
            unsigned __int16 v494 = 0LL;
          }
        }

        LODWORD(buf.tv_sec) = 67112195;
        HIDWORD(buf.tv_sec) = v320;
        LOWORD(buf.tv_nsec) = 1024;
        *(_DWORD *)((char *)&buf.tv_nsec + 2) = v620;
        HIWORD(buf.tv_nsec) = 1024;
        *(_DWORD *)v625 = a4;
        *(_WORD *)&v625[4] = 1024;
        *(_DWORD *)&v625[6] = v605;
        strcpy((char *)&v626, "p\bhash");
        HIBYTE(v626) = 0;
        *(_WORD *)v627 = 0;
        *(_WORD *)&v627[2] = 1040;
        *(_DWORD *)&v627[4] = v491;
        *(_WORD *)&v627[8] = 2101;
        *(void *)&v627[10] = a2 + 356;
        *(_WORD *)&v627[18] = 1024;
        *(_DWORD *)&v627[20] = v598;
        *(_WORD *)&v627[24] = 1026;
        *(_DWORD *)&v627[26] = v43;
        *(_WORD *)&v627[30] = 1024;
        *(_DWORD *)&v627[32] = v492;
        *(_WORD *)&v627[36] = 2160;
        *(void *)&v627[38] = 1752392040LL;
        *(_WORD *)&v627[46] = 1040;
        *(_DWORD *)&v627[48] = v493;
        *(_WORD *)&v627[52] = 2101;
        *(void *)&v627[54] = v494;
        uint64_t v450 = "[R%u->mDNS] DNSServiceQueryRecord result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %d,"
               " name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%x), dnssec: %{public, mdns:dnssec_result}d"
               ", type: %{mdns:rrtype}d, rdata: %{sensitive, mask.hash, mdns:rdata}.*P";
        goto LABEL_967;
      }

      if (v27) {
        int v279 = (os_log_s *)mDNSLogCategory_Default;
      }
      else {
        int v279 = (os_log_s *)mDNSLogCategory_mDNS;
      }
      if (gSensitiveLoggingEnabled != 1 || v279 == (os_log_s *)mDNSLogCategory_State)
      {
        if (!os_log_type_enabled(v279, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_974;
        }
        int v280 = *(_DWORD *)(a7 + 184);
        uint64_t v345 = (_BYTE *)(a2 + 356);
        if (a2 == -612)
        {
LABEL_794:
          while (v345)
          {
            uint64_t v346 = *v345;
            if (!*v345)
            {
              unsigned __int16 v474 = (_WORD)v345 - v30 + 1;
              goto LABEL_1081;
            }

            v345 += v346 + 1;
            if (a2 != -612) {
              goto LABEL_793;
            }
          }
        }

        else
        {
LABEL_793:
        }

        unsigned __int16 v474 = 257;
      }

      else
      {
        if (v27) {
          int v279 = (os_log_s *)mDNSLogCategory_Default_redacted;
        }
        else {
          int v279 = (os_log_s *)mDNSLogCategory_mDNS;
        }
        if (!os_log_type_enabled(v279, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_974;
        }
        int v280 = *(_DWORD *)(a7 + 184);
        unsigned int v281 = (_BYTE *)(a2 + 356);
        if (a2 == -612)
        {
LABEL_549:
          while (v281)
          {
            uint64_t v282 = *v281;
            if (!*v281)
            {
              unsigned __int16 v474 = (_WORD)v281 - v30 + 1;
              goto LABEL_1081;
            }

            v281 += v282 + 1;
            if (a2 != -612) {
              goto LABEL_548;
            }
          }
        }

        else
        {
LABEL_548:
        }

        unsigned __int16 v474 = 257;
      }

LABEL_1081:
      int v567 = *(unsigned __int16 *)(a3 + 4);
      LODWORD(buf.tv_sec) = 67111427;
      HIDWORD(buf.tv_sec) = v280;
      LOWORD(buf.tv_nsec) = 1024;
      *(_DWORD *)((char *)&buf.tv_nsec + 2) = v620;
      HIWORD(buf.tv_nsec) = 1024;
      *(_DWORD *)v625 = a4;
      *(_WORD *)&v625[4] = 1024;
      *(_DWORD *)&v625[6] = v605;
      strcpy((char *)&v626, "p\bhash");
      HIBYTE(v626) = 0;
      *(_WORD *)v627 = 0;
      *(_WORD *)&v627[2] = 1040;
      *(_DWORD *)&v627[4] = v474;
      *(_WORD *)&v627[8] = 2101;
      *(void *)&v627[10] = a2 + 356;
      *(_WORD *)&v627[18] = 1024;
      *(_DWORD *)&v627[20] = v31;
      *(_WORD *)&v627[24] = 1026;
      *(_DWORD *)&v627[26] = v43;
      *(_WORD *)&v627[30] = 1024;
      *(_DWORD *)&v627[32] = v567;
      unsigned __int16 v216 = "[R%u->mDNS] DNSServiceQueryRecord result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %d, n"
             "ame: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%x), dnssec: %{public, mdns:dnssec_result}d, ty"
             "pe: %{mdns:rrtype}d, rdata: <none>";
LABEL_1086:
      int v317 = v279;
      uint32_t v318 = 70;
      goto LABEL_1087;
    }

    if (!*(_WORD *)(a2 + 320)) {
      goto LABEL_76;
    }
    goto LABEL_64;
  }

  unsigned int v40 = *(unsigned __int16 *)(a2 + 320);
  LODWORD(v41) = *(unsigned __int16 *)(a3 + 12);
  BOOL v42 = v41 < 0x201;
  if (*(_WORD *)(a2 + 320))
  {
LABEL_64:
    if (v42)
    {
      size_t v44 = 0LL;
      int v69 = 512;
      size_t v70 = (char *)&unk_100164138;
    }

    else
    {
      size_t v70 = (char *)malloc(v41);
      size_t v44 = v70;
      int v69 = v41;
      if (!v70) {
        goto LABEL_1088;
      }
    }

    if ((_DWORD)v41)
    {
      int v590 = v31;
      int v622 = 0;
      unsigned __int16 v621 = 0;
      uint64_t v85 = ResourceRecordGetRDataBytesPointer(a3, v70, v69, &v621, &v622, v33, v34, v35);
      if (v622) {
        goto LABEL_972;
      }
      int v86 = (const void *)v85;
      size_t v87 = v621;
      int v607 = v29;
      if (v621 >= 0x1FFuLL)
      {
        unsigned int v577 = v621 + 2;
        char v89 = (__int16 *)malloc(v621 + 2LL);
        if (!v89) {
          goto LABEL_1088;
        }
        uint64_t v88 = v89;
      }

      else
      {
        uint64_t v88 = 0LL;
        unsigned int v577 = 512;
        char v89 = word_100164338;
      }

      uint64_t v574 = v89;
      uint64_t v604 = v88;
      if (v27) {
        int v217 = (os_log_s *)mDNSLogCategory_Default;
      }
      else {
        int v217 = (os_log_s *)mDNSLogCategory_mDNS;
      }
      if (gSensitiveLoggingEnabled != 1 || v217 == (os_log_s *)mDNSLogCategory_State)
      {
        if (!os_log_type_enabled(v217, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_870;
        }
        int v237 = *(_DWORD *)(a7 + 184);
        unsigned int v238 = bswap32(*(unsigned __int16 *)(a2 + 320)) >> 16;
        v239 = (_BYTE *)(a2 + 356);
        uint64_t v587 = a7;
        if (a2 == -612)
        {
LABEL_414:
          while (v239)
          {
            uint64_t v240 = *v239;
            if (!*v239)
            {
              unsigned __int16 v341 = (_WORD)v239 - v30 + 1;
              goto LABEL_860;
            }

            v239 += v240 + 1;
            if (a2 != -612) {
              goto LABEL_413;
            }
          }
        }

        else
        {
LABEL_413:
        }

        unsigned __int16 v341 = 257;
LABEL_860:
        int v418 = v341;
        unsigned int v419 = *(unsigned __int16 *)(a3 + 4);
        int v420 = v87 + 2;
        if ((int)v87 + 2 <= v577)
        {
          *uint64_t v574 = __rev16(v419);
          size_t v422 = v87;
          uint64_t v423 = v86;
          int v424 = v237;
          unsigned int v425 = v238;
          memcpy(v574 + 1, v423, v422);
          unsigned int v238 = v425;
          int v237 = v424;
          uint64_t v421 = v574;
        }

        else
        {
          uint64_t v421 = 0LL;
        }

        LODWORD(buf.tv_sec) = 67112195;
        HIDWORD(buf.tv_sec) = v237;
        LOWORD(buf.tv_nsec) = 1024;
        *(_DWORD *)((char *)&buf.tv_nsec + 2) = v238;
        HIWORD(buf.tv_nsec) = 1024;
        *(_DWORD *)v625 = v620;
        *(_WORD *)&v625[4] = 1024;
        *(_DWORD *)&v625[6] = a4;
        LOWORD(v626) = 1024;
        *(_DWORD *)((char *)&v626 + 2) = v607;
        HIWORD(v626) = 2160;
        *(void *)v627 = 1752392040LL;
        *(_WORD *)&v627[8] = 1040;
        *(_DWORD *)&v627[10] = v418;
        *(_WORD *)&v627[14] = 2101;
        *(void *)&v627[16] = a2 + 356;
        *(_WORD *)&v627[24] = 1024;
        *(_DWORD *)&v627[26] = v590;
        *(_WORD *)&v627[30] = 1024;
        *(_DWORD *)&v627[32] = v419;
        *(_WORD *)&v627[36] = 2160;
        *(void *)&v627[38] = 1752392040LL;
        *(_WORD *)&v627[46] = 1040;
        *(_DWORD *)&v627[48] = v420;
        *(_WORD *)&v627[52] = 2101;
        *(void *)&v627[54] = v421;
        uint64_t v409 = "[R%u->Q%u] DNSServiceQueryRecord result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %d, "
               "name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%x), type: %{mdns:rrtype}d, rdata: %{sensiti"
               "ve, mask.hash, mdns:rdata}.*P";
        goto LABEL_869;
      }

      if (v27) {
        int v217 = (os_log_s *)mDNSLogCategory_Default_redacted;
      }
      else {
        int v217 = (os_log_s *)mDNSLogCategory_mDNS;
      }
      if (os_log_type_enabled(v217, OS_LOG_TYPE_DEFAULT))
      {
        int v218 = *(_DWORD *)(a7 + 184);
        unsigned int v219 = bswap32(*(unsigned __int16 *)(a2 + 320)) >> 16;
        int v220 = (_BYTE *)(a2 + 356);
        uint64_t v587 = a7;
        if (a2 == -612)
        {
LABEL_362:
          while (v220)
          {
            uint64_t v221 = *v220;
            if (!*v220)
            {
              unsigned __int16 v339 = (_WORD)v220 - v30 + 1;
              goto LABEL_850;
            }

            v220 += v221 + 1;
            if (a2 != -612) {
              goto LABEL_361;
            }
          }
        }

        else
        {
LABEL_361:
        }

        unsigned __int16 v339 = 257;
LABEL_850:
        int v401 = v339;
        unsigned int v402 = *(unsigned __int16 *)(a3 + 4);
        int v403 = v87 + 2;
        if ((int)v87 + 2 <= v577)
        {
          *uint64_t v574 = __rev16(v402);
          v405 = v86;
          size_t v406 = v87;
          int v407 = v218;
          unsigned int v408 = v219;
          memcpy(v574 + 1, v405, v406);
          unsigned int v219 = v408;
          int v218 = v407;
          uint64_t v404 = v574;
        }

        else
        {
          uint64_t v404 = 0LL;
        }

        LODWORD(buf.tv_sec) = 67112195;
        HIDWORD(buf.tv_sec) = v218;
        LOWORD(buf.tv_nsec) = 1024;
        *(_DWORD *)((char *)&buf.tv_nsec + 2) = v219;
        HIWORD(buf.tv_nsec) = 1024;
        *(_DWORD *)v625 = v620;
        *(_WORD *)&v625[4] = 1024;
        *(_DWORD *)&v625[6] = a4;
        LOWORD(v626) = 1024;
        *(_DWORD *)((char *)&v626 + 2) = v607;
        HIWORD(v626) = 2160;
        *(void *)v627 = 1752392040LL;
        *(_WORD *)&v627[8] = 1040;
        *(_DWORD *)&v627[10] = v401;
        *(_WORD *)&v627[14] = 2101;
        *(void *)&v627[16] = a2 + 356;
        *(_WORD *)&v627[24] = 1024;
        *(_DWORD *)&v627[26] = v590;
        *(_WORD *)&v627[30] = 1024;
        *(_DWORD *)&v627[32] = v402;
        *(_WORD *)&v627[36] = 2160;
        *(void *)&v627[38] = 1752392040LL;
        *(_WORD *)&v627[46] = 1040;
        *(_DWORD *)&v627[48] = v403;
        *(_WORD *)&v627[52] = 2101;
        *(void *)&v627[54] = v404;
        uint64_t v409 = "[R%u->Q%u] DNSServiceQueryRecord result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %d, "
               "name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%x), type: %{mdns:rrtype}d, rdata: %{sensiti"
               "ve, mask.hash, mdns:rdata}.*P";
LABEL_869:
        _os_log_impl((void *)&_mh_execute_header, v217, OS_LOG_TYPE_DEFAULT, v409, (uint8_t *)&buf, 0x60u);
        a7 = v587;
        goto LABEL_870;
      }

      goto LABEL_870;
    }

    if (v27) {
      unsigned int v113 = (os_log_s *)mDNSLogCategory_Default;
    }
    else {
      unsigned int v113 = (os_log_s *)mDNSLogCategory_mDNS;
    }
    if (gSensitiveLoggingEnabled != 1 || v113 == (os_log_s *)mDNSLogCategory_State)
    {
      if (!os_log_type_enabled(v113, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_972;
      }
      int v114 = *(_DWORD *)(a7 + 184);
      unsigned int v115 = __rev16(v40);
      unsigned int v198 = (_BYTE *)(a2 + 356);
      if (a2 == -612)
      {
LABEL_278:
        while (v198)
        {
          uint64_t v199 = *v198;
          if (!*v198)
          {
            unsigned __int16 v309 = (_WORD)v198 - v30 + 1;
            goto LABEL_817;
          }

          v198 += v199 + 1;
          if (a2 != -612) {
            goto LABEL_277;
          }
        }
      }

      else
      {
LABEL_277:
      }

      unsigned __int16 v309 = 257;
    }

    else
    {
      if (v27) {
        unsigned int v113 = (os_log_s *)mDNSLogCategory_Default_redacted;
      }
      else {
        unsigned int v113 = (os_log_s *)mDNSLogCategory_mDNS;
      }
      if (!os_log_type_enabled(v113, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_972;
      }
      int v114 = *(_DWORD *)(a7 + 184);
      unsigned int v115 = __rev16(v40);
      __int16 v116 = (_BYTE *)(a2 + 356);
      if (a2 == -612)
      {
LABEL_130:
        while (v116)
        {
          uint64_t v117 = *v116;
          if (!*v116)
          {
            unsigned __int16 v309 = (_WORD)v116 - v30 + 1;
            goto LABEL_817;
          }

          v116 += v117 + 1;
          if (a2 != -612) {
            goto LABEL_129;
          }
        }
      }

      else
      {
LABEL_129:
      }

      unsigned __int16 v309 = 257;
    }

LABEL_817:
    int v355 = *(unsigned __int16 *)(a3 + 4);
    LODWORD(buf.tv_sec) = 67111427;
    HIDWORD(buf.tv_sec) = v114;
    LOWORD(buf.tv_nsec) = 1024;
    *(_DWORD *)((char *)&buf.tv_nsec + 2) = v115;
    HIWORD(buf.tv_nsec) = 1024;
    *(_DWORD *)v625 = v620;
    *(_WORD *)&v625[4] = 1024;
    *(_DWORD *)&v625[6] = a4;
    LOWORD(v626) = 1024;
    *(_DWORD *)((char *)&v626 + 2) = v29;
    HIWORD(v626) = 2160;
    *(void *)v627 = 1752392040LL;
    *(_WORD *)&v627[8] = 1040;
    *(_DWORD *)&v627[10] = v309;
    *(_WORD *)&v627[14] = 2101;
    *(void *)&v627[16] = a2 + 356;
    *(_WORD *)&v627[24] = 1024;
    *(_DWORD *)&v627[26] = v31;
    *(_WORD *)&v627[30] = 1024;
    *(_DWORD *)&v627[32] = v355;
    int v179 = "[R%u->Q%u] DNSServiceQueryRecord result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %d, name"
           ": %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%x), type: %{mdns:rrtype}d, rdata: <none>";
LABEL_822:
    uint32_t v251 = v113;
    uint32_t v252 = 70;
    goto LABEL_879;
  }

LABEL_1009:
    uint64_t v525 = a7;
    uint64_t v513 = 0LL;
    int v524 = v622;
    goto LABEL_1010;
  }

  if (v515 == 1) {
    uint64_t v521 = (uint64_t)mdns_signed_hostname_result_create_ipv4(v514, (_DWORD *)(*(void *)(a3 + 40) + 4LL), &v622);
  }
  else {
    uint64_t v521 = (uint64_t)mdns_signed_hostname_result_create_ipv6(v514, (_OWORD *)(*(void *)(a3 + 40) + 4LL), v503, &v622);
  }
LABEL_1006:
  uint64_t v513 = (void *)v521;
  if (!v521) {
    goto LABEL_1009;
  }
  int v524 = v622;
  if (!v622)
  {
    buf.unsigned __int16 tv_sec = 0LL;
    data = mdns_signed_result_get_data(v521, &buf);
    unsigned __int16 tv_sec = buf.tv_sec;
    if (buf.tv_sec >= 0x10000uLL) {
      uint64_t v520 = 0LL;
    }
    else {
      uint64_t v520 = data;
    }
    if (buf.tv_sec >= 0x10000uLL) {
      unsigned __int16 tv_sec = 0;
    }
    unsigned int v512 = tv_sec;
    if (buf.tv_sec >= 0x10000uLL) {
      uint64_t v566 = 0LL;
    }
    else {
      uint64_t v566 = LOWORD(buf.tv_sec) + 4LL;
    }
    v511 += v566;
    goto LABEL_1017;
  }

  uint64_t v525 = a7;
LABEL_1010:
  uint64_t v526 = mDNSLogCategory_Default;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
  {
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_ERROR))
    {
LABEL_1015:
      int v527 = *(_DWORD *)(v525 + 184);
      unsigned int v528 = bswap32(*(unsigned __int16 *)(v619 + 320)) >> 16;
      LODWORD(buf.tv_sec) = 67109632;
      HIDWORD(buf.tv_sec) = v527;
      LOWORD(buf.tv_nsec) = 1024;
      *(_DWORD *)((char *)&buf.tv_nsec + 2) = v528;
      HIWORD(buf.tv_nsec) = 2048;
      *(void *)v625 = v524;
      int v529 = (os_log_s *)v526;
      a7 = v525;
      _os_log_impl( (void *)&_mh_execute_header,  v529,  OS_LOG_TYPE_ERROR,  "[R%u->Q%u] queryrecord_result_reply signed_result failed %ld",  (uint8_t *)&buf,  0x18u);
      goto LABEL_1016;
    }
  }

  else
  {
    uint64_t v526 = mDNSLogCategory_Default_redacted;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_ERROR)) {
      goto LABEL_1015;
    }
  }

  uint64_t v520 = 0LL;
  unsigned int v512 = 0;
  a7 = v525;
LABEL_1017:
  if (v623) {
    v511 += strlen(v623) + 5;
  }
  if (*(_DWORD *)(a7 + 212) == 8) {
    uint64_t v530 = 68LL;
  }
  else {
    uint64_t v530 = 72LL;
  }
  uint64_t v531 = a7;
  xpc_object_t reply = create_reply((char *)v530, v511, a7, v506, v510, v507, v508, v509);
  int v533 = reply;
  unsigned int v534 = v615 | 2;
  if (!v620) {
    unsigned int v534 = v615;
  }
  if (a4) {
    v534 |= 0x80000000;
  }
  if (!*(_BYTE *)(v619 + 337)) {
    v534 |= 0x40000000u;
  }
  *((_DWORD *)reply + 11) = bswap32(v534);
  uint64_t v535 = reply + 44;
  *((_DWORD *)reply + 12) = bswap32(v503);
  *((_DWORD *)reply + 13) = bswap32(a6);
  uint64_t v536 = reply + 56;
  size_t v537 = strlen(__s) + 1;
  memcpy(v536, __s, v537);
  unsigned __int16 v542 = &v536[v537];
  *(_WORD *)unsigned __int16 v542 = bswap32(*(unsigned __int16 *)(a3 + 4)) >> 16;
  *((_WORD *)v542 + 1) = bswap32(*(unsigned __int16 *)(a3 + 6)) >> 16;
  uint64_t v543 = &v536[v537 + 6];
  *((_WORD *)v542 + 2) = bswap32(*(unsigned __int16 *)(a3 + 12)) >> 16;
  if (*(_WORD *)(a3 + 12) && !putRData(0LL, v543, (unint64_t)&v535[v511], a3, v538, v539, v540, v541)) {
    LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "queryrecord_result_reply putRData failed %d",  v544,  v545,  v546,  v547,  v548,  (_DWORD)v535 + v511 - (_DWORD)v543);
  }
  char v549 = &v543[*(unsigned __int16 *)(a3 + 12)];
  unsigned int v550 = v620;
  if (v620) {
    unsigned int v550 = *(_DWORD *)(a3 + 8);
  }
  uint64_t v551 = v531;
  *(_DWORD *)char v549 = bswap32(v550);
  v552 = v549 + 4;
  if (v520)
  {
    if (v549 != (char *)-4LL && v552 <= &v552[v511] && v511 >= (unint64_t)v512 + 4)
    {
      *((_WORD *)v549 + 2) = 1792;
      v549[6] = BYTE1(v512);
      v552 = v549 + 8;
      v549[7] = v512;
      if (v512)
      {
        memcpy(v549 + 8, v520, v512);
        v552 += v512;
      }
    }

    *((_DWORD *)v533 + 6) |= 2u;
  }

  if (v513) {
    os_release(v513);
  }
  v553 = v623;
  if (v623)
  {
    size_t v554 = strlen(v623) + 1;
    if (!(v554 >> 16))
    {
      if (v552)
      {
        if (v552 <= &v552[v511] && v511 >= (unint64_t)(unsigned __int16)v554 + 4)
        {
          *(_WORD *)v552 = 2304;
          v552[2] = BYTE1(v554);
          v552[3] = v554;
          if ((_WORD)v554) {
            memcpy(v552 + 4, v553, (unsigned __int16)v554);
          }
        }
      }
    }

    *((_DWORD *)v533 + 6) |= 2u;
    int v555 = (os_log_s *)mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEBUG))
      {
LABEL_1054:
        int v556 = *(_DWORD *)(v551 + 184);
        unsigned int v557 = bswap32(*(unsigned __int16 *)(v619 + 320)) >> 16;
        LODWORD(buf.tv_sec) = 67109891;
        HIDWORD(buf.tv_sec) = v556;
        LOWORD(buf.tv_nsec) = 1024;
        *(_DWORD *)((char *)&buf.tv_nsec + 2) = v557;
        HIWORD(buf.tv_nsec) = 2160;
        *(void *)v625 = 1752392040LL;
        *(_WORD *)&v625[8] = 2085;
        int v626 = v623;
        _os_log_impl( (void *)&_mh_execute_header,  v555,  OS_LOG_TYPE_DEBUG,  "[R%u->Q%u] queryrecord_result_reply add tracker %{sensitive, mask.hash}s",  (uint8_t *)&buf,  0x22u);
      }
    }

    else
    {
      int v555 = (os_log_s *)mDNSLogCategory_Default_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEBUG)) {
        goto LABEL_1054;
      }
    }
  }

  if (v617 && &_NEHelperTrackerGetAppInfo)
  {
    unsigned int v558 = &s_head_0;
    while (1)
    {
      unsigned int v558 = (uint64_t *)*v558;
      if (!v558) {
        break;
      }
      if (v558[1] == v619)
      {
        int tracker_state = _cache_item_get_tracker_state((uint64_t)v558);
        CFIndex Count = CFArrayGetCount((CFArrayRef)v558[6]);
        if (Count < 1) {
          break;
        }
        uint64_t ValueAtIndex = (const __CFData *)CFArrayGetValueAtIndex((CFArrayRef)v558[6], Count - 1);
        if (CFDataGetLength(ValueAtIndex) == 4) {
          uint64_t v562 = 2LL;
        }
        else {
          uint64_t v562 = 30LL;
        }
        buf.unsigned __int16 tv_sec = (__darwin_time_t)CFDataGetBytePtr(ValueAtIndex);
        if (tracker_state == 1)
        {
          if (!CFArrayGetCount((CFArrayRef)v558[5])) {
            break;
          }
          uint64_t v563 = CFArrayGetValueAtIndex((CFArrayRef)v558[5], 0LL);
        }

        else
        {
          uint64_t v563 = 0LL;
        }

        NEHelperTrackerAddIPForAllFlowsRedactLogs( *((unsigned int *)v558 + 8),  v562,  &buf,  1LL,  v558[2],  v558[3],  v563,  gSensitiveLoggingEnabled);
        break;
      }
    }
  }

  append_reply(v551, v533);
}

unsigned __int16 *_get_signed_data_tlvs(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = *(unsigned __int16 **)(a1 + 72);
  if (!v2 || (*(_BYTE *)(a1 + 208) & 2) == 0) {
    return 0LL;
  }
  uint64_t v6 = *(void *)(a1 + 80);
  int tlv_uint32 = get_tlv_uint32(*(unsigned __int8 **)(a1 + 72), v6, 6, 0LL);
  uint64_t result = 0LL;
  if (tlv_uint32 == 1)
  {
    *(_BYTE *)(a1 + 274) = 1;
    while (v6 - (uint64_t)v2 >= 4)
    {
      uint64_t v8 = 0LL;
      int v9 = v2 + 2;
      if (v2 == (unsigned __int16 *)-4LL)
      {
        uint64_t result = 0LL;
        if (!a2) {
          return result;
        }
LABEL_15:
        *a2 = v8;
        return result;
      }

      uint64_t v10 = __rev16(v2[1]);
      uint64_t result = 0LL;
      unsigned int v11 = __rev16(*v2);
      uint64_t v2 = (unsigned __int16 *)((char *)v9 + v10);
      if (v11 == 7)
      {
        uint64_t v8 = v10;
        uint64_t result = v9;
        if (!a2) {
          return result;
        }
        goto LABEL_15;
      }
    }

    uint64_t v8 = 0LL;
    uint64_t result = 0LL;
LABEL_14:
    if (!a2) {
      return result;
    }
    goto LABEL_15;
  }

  return result;
}

uint64_t _handle_browse_request_start( uint64_t a1, unsigned __int8 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  __int128 v30 = 0u;
  __int128 v29 = 0u;
  __int128 v28 = 0u;
  __int128 v27 = 0u;
  __int128 v26 = 0u;
  __int128 v25 = 0u;
  __int128 v24 = 0u;
  __int128 v23 = 0u;
  __int128 v22 = 0u;
  __int128 v21 = 0u;
  __int128 v20 = 0u;
  __int128 v19 = 0u;
  __int128 v18 = 0u;
  __int128 v17 = 0u;
  *(void *)(a1 + 96) = browse_termination_callback;
  if (*a2)
  {
    char v16 = 0;
    if (AppendDNSNameString(&v16, a2, a3, a4, a5, a6, a7, a8)) {
      return add_domain_to_browser(a1, &v16);
    }
    else {
      return 4294901756LL;
    }
  }

  else
  {
    uint64_t v10 = AutoBrowseDomains;
    if (AutoBrowseDomains)
    {
      while (1)
      {
        int v11 = *(_DWORD *)(v10 + 8);
        if (!v11 || ((unsigned int v12 = *(_DWORD *)(a1 + 180), v12 >= 0x1F5) ? (v13 = v12 == v11) : (v13 = 1), v13))
        {
          uint64_t v14 = add_domain_to_browser(a1, (_BYTE *)(v10 + 12));
          if ((_DWORD)v14)
          {
            uint64_t v9 = v14;
          }
        }

        uint64_t v10 = *(void *)v10;
        if (!v10) {
          return 0LL;
        }
      }
    }

    else
    {
      return 0LL;
    }
  }

  return v9;
}

uint64_t _handle_regservice_request_start(uint64_t a1, _BYTE *a2)
{
  *(void *)(a1 + 96) = regservice_termination_callback;
  uint64_t v3 = register_service_instance(a1, a2);
  if (!(_DWORD)v3)
  {
    uint64_t v5 = *(void *)(a1 + 112);
    if (*(_BYTE *)(v5 + 1612)) {
      UpdateDeviceInfoRecord((uint64_t)mDNSStorage);
    }
    if (*(_BYTE *)(v5 + 1355))
    {
      for (uint64_t i = AutoRegistrationDomains; i; uint64_t i = *(void *)i)
      {
        int v7 = *(_DWORD *)(i + 8);
        if (v7)
        {
          unsigned int v8 = *(_DWORD *)(a1 + 180);
          if (v8 >= 0x1F5 && v8 != v7) {
            continue;
          }
        }

        register_service_instance(a1, (_BYTE *)(i + 12));
      }
    }
  }

  return v3;
}

void enum_termination_callback( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8 = *(_BYTE **)(a1 + 104);
  if ((*v8 & 0x80) != 0)
  {
    if (mDNS_LoggingEnabled) {
      LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "%3d: DNSServiceEnumeration Cancel WAB Registration PID[%d](%s)",  a4,  a5,  a6,  a7,  a8,  *(_DWORD *)(a1 + 168));
    }
    uDNS_StopWABQueries(4, a2, a3, a4, a5, a6, a7, a8);
  }

  else
  {
    if (mDNS_LoggingEnabled) {
      LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "%3d: DNSServiceEnumeration Cancel WAB Browse PID[%d](%s)",  a4,  a5,  a6,  a7,  a8,  *(_DWORD *)(a1 + 168));
    }
    uDNS_StopWABQueries(3, a2, a3, a4, a5, a6, a7, a8);
    mDNS_StopQuery((unsigned int *)mDNSStorage, (uint64_t)(v8 + 1320));
  }

  mDNS_StopQuery((unsigned int *)mDNSStorage, (uint64_t)(v8 + 8));
  mDNS_StopQuery((unsigned int *)mDNSStorage, (uint64_t)(v8 + 664));
}

void port_mapping_create_request_callback( uint64_t **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9)
{
  uint64_t v9 = *(void *)(a2 + 192);
  if (!v9)
  {
    LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "port_mapping_create_request_callback called with unknown request_state object",  a4,  a5,  a6,  a7,  a8,  a9);
    return;
  }

  xpc_object_t reply = create_reply((char *)0x47, 25LL, v9, a4, a5, a6, a7, a8);
  *((_DWORD *)reply + 11) = 0;
  *((_DWORD *)reply + 12) = bswap32( mDNSPlatformInterfaceIndexfromInterfaceID( a1,  *(void *)(a2 + 144),  0LL,  v13,  v14,  v15,  v16,  v17));
  *((_DWORD *)reply + 13) = bswap32(*(_DWORD *)(a2 + 168));
  __int128 v18 = *(unsigned __int16 **)(v9 + 144);
  reply[56] = *((_BYTE *)v18 + 160);
  reply[57] = *((_BYTE *)v18 + 161);
  reply[58] = *((_BYTE *)v18 + 162);
  reply[59] = *((_BYTE *)v18 + 163);
  if (*((_BYTE *)v18 + 180) == 1) {
    char v19 = 16;
  }
  else {
    char v19 = 32;
  }
  if (*((_BYTE *)v18 + 180)) {
    char v20 = v19;
  }
  else {
    char v20 = 0;
  }
  reply[60] = v20;
  reply[61] = *((_BYTE *)v18 + 182);
  reply[62] = *((_BYTE *)v18 + 183);
  reply[63] = *((_BYTE *)v18 + 168);
  reply[64] = *((_BYTE *)v18 + 169);
  *(_DWORD *)(reply + 65) = bswap32(*((_DWORD *)v18 + 43));
  __int128 v21 = (os_log_s *)mDNSLogCategory_NAT;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_NAT == mDNSLogCategory_State)
  {
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_NAT, OS_LOG_TYPE_DEFAULT))
    {
      int v22 = *(_DWORD *)(v9 + 184);
      int v27 = *((unsigned __int8 *)v18 + 180);
      if (v27 == 1) {
        int v24 = 16;
      }
      else {
        int v24 = 32;
      }
      BOOL v25 = v27 == 0;
      unsigned int v26 = v18[91];
      if (v25) {
        int v24 = 0;
      }
      goto LABEL_24;
    }
  }

  else
  {
    __int128 v21 = (os_log_s *)mDNSLogCategory_NAT_redacted;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_NAT_redacted, OS_LOG_TYPE_DEFAULT))
    {
      int v22 = *(_DWORD *)(v9 + 184);
      int v23 = *((unsigned __int8 *)v18 + 180);
      if (v23 == 1) {
        int v24 = 16;
      }
      else {
        int v24 = 32;
      }
      BOOL v25 = v23 == 0;
      unsigned int v26 = v18[91];
      if (v25) {
        int v24 = 0;
      }
LABEL_24:
      int v28 = *((_DWORD *)v18 + 47);
      unsigned int v29 = bswap32(*v18) >> 16;
      unsigned int v30 = bswap32(v18[84]) >> 16;
      int v31 = *((_DWORD *)v18 + 43);
      v32[0] = 67111427;
      v32[1] = v22;
      __int16 v33 = 1024;
      int v34 = v24;
      __int16 v35 = 1024;
      unsigned int v36 = bswap32(v26) >> 16;
      __int16 v37 = 1024;
      unsigned int v38 = v29;
      __int16 v39 = 1024;
      int v40 = v28;
      __int16 v41 = 2160;
      uint64_t v42 = 1752392040LL;
      __int16 v43 = 1045;
      int v44 = 4;
      __int16 v45 = 2101;
      uint64_t v46 = v18 + 80;
      __int16 v47 = 1024;
      unsigned int v48 = v30;
      __int16 v49 = 1024;
      int v50 = v31;
      _os_log_impl( (void *)&_mh_execute_header,  v21,  OS_LOG_TYPE_DEFAULT,  "[R%d] DNSServiceNATPortMappingCreate(%X, %u, %u, %d) RESULT %{sensitive, mask.hash, network:in_addr}.4P:%u TTL %u",  (uint8_t *)v32,  0x46u);
    }
  }

  append_reply(v9, reply);
}

void port_mapping_termination_callback(uint64_t a1)
{
  uint64_t v2 = *(unsigned __int16 **)(a1 + 144);
  uint64_t v3 = (os_log_s *)mDNSLogCategory_NAT;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_NAT == mDNSLogCategory_State)
  {
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_NAT, OS_LOG_TYPE_DEFAULT))
    {
      int v5 = *(_DWORD *)(a1 + 184);
      if (*((_BYTE *)v2 + 180) == 1) {
        int v6 = 16;
      }
      else {
        int v6 = 32;
      }
      if (*((_BYTE *)v2 + 180)) {
        int v7 = v6;
      }
      else {
        int v7 = 0;
      }
      goto LABEL_20;
    }
  }

  else
  {
    uint64_t v3 = (os_log_s *)mDNSLogCategory_NAT_redacted;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_NAT_redacted, OS_LOG_TYPE_DEFAULT))
    {
      int v5 = *(_DWORD *)(a1 + 184);
      if (*((_BYTE *)v2 + 180) == 1) {
        int v9 = 16;
      }
      else {
        int v9 = 32;
      }
      if (*((_BYTE *)v2 + 180)) {
        int v7 = v9;
      }
      else {
        int v7 = 0;
      }
LABEL_20:
      unsigned int v10 = bswap32(v2[91]) >> 16;
      unsigned int v11 = bswap32(*v2) >> 16;
      int v12 = *((_DWORD *)v2 + 47);
      int v13 = *(_DWORD *)(a1 + 172);
      v15.unsigned __int16 tv_sec = 0LL;
      v15.tv_nsec = 0LL;
      clock_gettime(_CLOCK_MONOTONIC_RAW, &v15);
      int v14 = LODWORD(v15.tv_sec) - *(_DWORD *)(a1 + 188);
      LODWORD(v15.tv_sec) = 67110914;
      HIDWORD(v15.tv_sec) = v5;
      LOWORD(v15.tv_nsec) = 1024;
      *(_DWORD *)((char *)&v15.tv_nsec + 2) = v7;
      HIWORD(v15.tv_nsec) = 1024;
      unsigned int v16 = v10;
      __int16 v17 = 1024;
      unsigned int v18 = v11;
      __int16 v19 = 1024;
      int v20 = v12;
      __int16 v21 = 1024;
      int v22 = v13;
      __int16 v23 = 2082;
      uint64_t v24 = a1 + 240;
      __int16 v25 = 1024;
      int v26 = v14;
      _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEFAULT,  "[R%d] DNSServiceNATPortMappingCreate(%X, %u, %u, %d) STOP PID[%d](%{public}s) -- duration: %{mdns:time_duration}u",  (uint8_t *)&v15,  0x36u);
    }
  }

  mDNS_Lock_((unsigned int *)mDNSStorage, (uint64_t)"mDNS_StopNATOperation", 1012);
  mDNS_StopNATOperation_internal((uint64_t)mDNSStorage, (uint64_t)(v2 + 4));
  mDNS_Unlock_((uint64_t)mDNSStorage, (uint64_t)"mDNS_StopNATOperation", 1014);
}

uint64_t LocateSubordinateRequest(uint64_t result)
{
  uint64_t v1 = all_requests;
  if (all_requests)
  {
    while (*(void *)(v1 + 24) != result
         || *(_DWORD *)(v1 + 216) != *(_DWORD *)(result + 216)
         || *(_DWORD *)(v1 + 220) != *(_DWORD *)(result + 220))
    {
      uint64_t v1 = *(void *)(v1 + 16);
      if (!v1) {
        return result;
      }
    }

    return v1;
  }

  return result;
}

uint64_t handle_tsr_update_request(uint64_t a1, uint64_t a2, unsigned int a3, int a4)
{
  unsigned int v8 = mDNSGetTSRForAuthRecordNamed((uint64_t *)xmmword_10015BD08, *(_BYTE **)(a2 + 40), *(_DWORD *)(a2 + 24));
  if (a3 > 0x93A80)
  {
    int v9 = (os_log_s *)mDNSLogCategory_mDNS;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_ERROR)) {
        return 4294901756LL;
      }
      uint64_t v11 = *(void *)(a2 + 40);
      if (v11)
      {
        int v12 = *(_BYTE **)(a2 + 40);
        if (v11 == -256)
        {
LABEL_11:
          while (v12)
          {
            uint64_t v13 = *v12;
            if (!*v12)
            {
              int v27 = (unsigned __int16)((_WORD)v12 - v11 + 1);
              goto LABEL_56;
            }

            v12 += v13 + 1;
            if (v11 != -256) {
              goto LABEL_10;
            }
          }
        }

        else
        {
LABEL_10:
        }

        int v27 = 257;
      }

      else
      {
        int v27 = 0;
      }
    }

    else
    {
      int v9 = (os_log_s *)mDNSLogCategory_mDNS_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_ERROR)) {
        return 4294901756LL;
      }
      uint64_t v11 = *(void *)(a2 + 40);
      if (v11)
      {
        __int16 v17 = *(_BYTE **)(a2 + 40);
        if (v11 == -256)
        {
LABEL_22:
          while (v17)
          {
            uint64_t v18 = *v17;
            if (!*v17)
            {
              int v27 = (unsigned __int16)((_WORD)v17 - v11 + 1);
              goto LABEL_56;
            }

            v17 += v18 + 1;
            if (v11 != -256) {
              goto LABEL_21;
            }
          }
        }

        else
        {
LABEL_21:
        }

        int v27 = 257;
      }

      else
      {
        int v27 = 0;
      }
    }

void PrintOneCacheRecordToFD(int a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, _DWORD *a6)
{
  uint64_t v21 = (unsigned __int8 *)(a2 + 8);
  uint64_t v7 = *(void *)(a2 + 64);
  for (size_t i = 64LL; ; size_t i = v13 + 1)
  {
    int v9 = (char *)calloc(1uLL, i);
    if (!v9)
    {
      __break(1u);
      return;
    }

    unsigned int v10 = v9;
    if (!v7)
    {
LABEL_13:
      *unsigned int v10 = 0;
      goto LABEL_15;
    }

    int v11 = *(_DWORD *)(v7 + 32);
    if (v11 == 1)
    {
      unsigned int v12 = snprintf(v9, i, "  validated, %s%s");
      goto LABEL_10;
    }

    if (v11) {
      break;
    }
    if (*(_BYTE *)(v7 + 40)) {
      unsigned int v12 = snprintf(v9, i, "to validate, positive, %-4zu%s");
    }
    else {
      unsigned int v12 = snprintf(v9, i, "to validate, negative, 1   %s");
    }
LABEL_10:
    if ((v12 & 0x80000000) != 0) {
      goto LABEL_13;
    }
    if (i > v12) {
      goto LABEL_15;
    }
    uint64_t v13 = v12;
    free(v10);
  }

  free(v9);
  unsigned int v10 = 0LL;
LABEL_15:
  int v14 = *(unsigned __int8 *)(a2 + 129);
  DNSTypeName(*(unsigned __int16 *)(a2 + 12));
  if (v14 != 1) {
    GetRRDisplayString_rdb(v21, (unsigned __int16 *)(*(void *)(a2 + 48) + 4LL), word_100164338);
  }
  LogToFD(a1, "%3d %s%8d %-7s%s %-6s   %-40s%s", v15, v16, v17, v18, v19, v20, a3);
  ++*a6;
  if (v10) {
    free(v10);
  }
}

uint64_t LogAuthRecordsToFD( uint64_t result, int a2, uint64_t a3, _DWORD *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = result;
  memset(v31, 0, 20);
  if (!a3) {
    return LogToFD(v8, "<None>", a3, (uint64_t)a4, a5, a6, a7, a8, v29);
  }
  uint64_t v10 = a3;
  int v11 = 1;
  do
  {
    unsigned int v12 = &xmmword_10015BD30;
    do
      unsigned int v12 = *(__int128 **)v12;
    while (v12 && *((void *)v12 + 782) != *(void *)(v10 + 32));
    if ((a4 != 0LL) != (*(_DWORD *)(v10 + 126) == 0))
    {
      if (v11) {
        LogToFD( v8,  "Time Registered                  Int    Next  Expire if     State",  a3,  (uint64_t)a4,  a5,  a6,  a7,  a8,  v29);
      }
      if (a4) {
        ++*a4;
      }
      if (*(void *)&v31[0] != *(void *)(v10 + 124)
        || *((void *)&v31[0] + 1) != *(void *)(v10 + 132)
        || LODWORD(v31[1]) != (unint64_t)*(unsigned int *)(v10 + 140))
      {
        v31[0] = *(_OWORD *)(v10 + 124);
        LODWORD(v31[1]) = *(_DWORD *)(v10 + 140);
        if (*(_DWORD *)((char *)v31 + 14))
        {
          LogToFD( v8,  "Proxying for H-MAC %.6a I-MAC %.6a Password %.6a seq %d",  a3,  (uint64_t)a4,  a5,  a6,  a7,  a8,  (int)v31 + 2);
        }

        else if (WORD1(v31[0]) == WORD4(v31[0]) && WORD2(v31[0]) == WORD5(v31[0]) && WORD3(v31[0]) == WORD6(v31[0]))
        {
          LogToFD(v8, "Proxying for %.6a seq %d", a3, (uint64_t)a4, a5, a6, a7, a8, (int)v31 + 2);
        }

        else
        {
          LogToFD(v8, "Proxying for H-MAC %.6a I-MAC %.6a seq %d", a3, (uint64_t)a4, a5, a6, a7, a8, (int)v31 + 2);
        }
      }

      if (!*(void *)(v10 + 32) && !*(_BYTE *)(v10 + 122) && !IsLocalDomain(*(_BYTE **)(v10 + 40))) {
        goto LABEL_31;
      }
      int v15 = *(_DWORD *)(v10 + 172);
      if (v15 == 5)
      {
        uint64_t v22 = *(void *)(v10 + 32);
        GetRRDisplayString_rdb( (unsigned __int8 *)(v10 + 8),  (unsigned __int16 *)(*(void *)(v10 + 48) + 4LL),  word_100164338);
        if (v22 == -5) {
          uint64_t result = LogToFD(v8, "                             BLE %s", v23, v24, v25, v26, v27, v28, (int)word_100164338);
        }
        else {
          uint64_t result = LogToFD(v8, "                             PP %s", v23, v24, v25, v26, v27, v28, (int)word_100164338);
        }
        goto LABEL_35;
      }

      if (v15 == 4)
      {
        GetRRDisplayString_rdb( (unsigned __int8 *)(v10 + 8),  (unsigned __int16 *)(*(void *)(v10 + 48) + 4LL),  word_100164338);
        uint64_t result = LogToFD(v8, "                             LO %s", v16, v17, v18, v19, v20, v21, (int)word_100164338);
      }

      else
      {
LABEL_31:
        uint64_t result = LogOneAuthRecordToFD(v8, v10, a2);
      }

const char *RecordTypeName(int a1)
{
  uint64_t result = "Unregistered ";
  switch(a1)
  {
    case 0:
      return result;
    case 1:
      uint64_t result = "Deregistering";
      break;
    case 2:
      uint64_t result = "Unique       ";
      break;
    case 3:
    case 5:
    case 6:
    case 7:
      goto LABEL_6;
    case 4:
      uint64_t result = "Advisory     ";
      break;
    case 8:
      uint64_t result = "Shared       ";
      break;
    default:
      if (a1 == 16)
      {
        uint64_t result = "Verified     ";
      }

      else if (a1 == 32)
      {
        uint64_t result = "KnownUnique  ";
      }

      else
      {
LABEL_6:
        uint64_t result = "Unknown";
      }

      break;
  }

  return result;
}

uint64_t LogClientInfoToFD(uint64_t a1, uint64_t a2)
{
  *(void *)((char *)v40 + 6) = 0LL;
  v40[0] = 0LL;
  v38[0] = 0LL;
  v38[1] = 0LL;
  __int16 v39 = 0;
  mDNS_snprintf(v40);
  uint64_t result = mDNS_snprintf(v38);
  int v11 = *(void (**)(uint64_t))(a2 + 96);
  if (!v11) {
    return LogToFD(a1, "%s No operation yet on this socket", v5, v6, v7, v8, v9, v10, (int)v38);
  }
  if (v11 == connection_termination)
  {
    uint64_t v12 = *(void *)(a2 + 160);
    if (v12)
    {
      int v13 = 0;
      do
      {
        ++v13;
        uint64_t v12 = *(void *)(v12 + 8);
      }

      while (v12);
    }

    uint64_t v20 = *(void *)(a2 + 16);
    if (v20)
    {
      int v21 = 0;
      do
      {
        uint64_t v22 = v20 + 16;
        uint64_t v20 = *(void *)(v20 + 16);
        if (*(void *)(v22 + 8) == a2) {
          ++v21;
        }
      }

      while (v20);
    }

    uint64_t result = LogToFD( a1,  "%s DNSServiceCreateConnection: %d registered record%s, %d kDNSServiceFlagsShareConnection operation%s PID[%d](%s)",  v5,  v6,  v7,  v8,  v9,  v10,  (int)v38);
    for (uint64_t i = *(void *)(a2 + 160); i; uint64_t i = *(void *)(i + 8))
    {
      int v24 = *(_DWORD *)(a2 + 232);
      GetRRDisplayString_rdb( (unsigned __int8 *)(*(void *)(i + 24) + 8LL),  (unsigned __int16 *)(*(void *)(*(void *)(i + 24) + 48LL) + 4LL),  word_100164338);
      uint64_t result = LogToFD( a1,  " ->  DNSServiceRegisterRecord   0x%08X %2d %3d %s PID[%d](%s)",  v25,  v26,  v27,  v28,  v29,  v30,  v24);
    }

    for (uint64_t j = *(void *)(a2 + 16); j; uint64_t j = *(void *)(j + 16))
    {
      if (*(void *)(j + 24) == a2) {
        uint64_t result = LogClientInfoToFD(a1, j);
      }
    }
  }

  else if ((char *)v11 == (char *)regservice_termination_callback)
  {
    uint64_t v14 = *(void *)(a2 + 112);
    for (CFIndex k = *(void **)(v14 + 1624); k; CFIndex k = (void *)*k)
    {
      if (k == *(void **)(v14 + 1624)) {
        uint64_t v16 = (const char *)v38;
      }
      else {
        uint64_t v16 = "";
      }
      uint64_t result = LogToFD( a1,  "%-9s DNSServiceRegister         0x%08X %2d %##s %u/%u PID[%d](%s)",  v5,  v6,  v7,  v8,  v9,  v10,  (int)v16);
    }
  }

  else if ((char *)v11 == (char *)browse_termination_callback)
  {
    uint64_t v17 = *(void *)(a2 + 136);
    for (uint64_t m = *(void **)(v17 + 272); m; uint64_t m = (void *)*m)
    {
      if (m == *(void **)(v17 + 272)) {
        uint64_t v19 = (const char *)v38;
      }
      else {
        uint64_t v19 = "";
      }
      uint64_t result = LogToFD( a1,  "%-9s DNSServiceBrowse           0x%08X %2d %##s PID[%d](%s)",  v5,  v6,  v7,  v8,  v9,  v10,  (int)v19);
    }
  }

  else if (v11 == resolve_termination_callback)
  {
    return LogToFD(a1, "%s DNSServiceResolve          0x%08X %2d %##s PID[%d](%s)", v5, v6, v7, v8, v9, v10, (int)v38);
  }

  else if (v11 == queryrecord_termination_callback)
  {
    DNSTypeName(*(unsigned __int16 *)(*(void *)(a2 + 128) + 322LL));
    return LogToFD( a1,  "%s DNSServiceQueryRecord      0x%08X %2d %##s (%s) PID[%d](%s)",  v32,  v33,  v34,  v35,  v36,  v37,  (int)v38);
  }

  else if ((char *)v11 == (char *)enum_termination_callback)
  {
    return LogToFD(a1, "%s DNSServiceEnumerateDomains 0x%08X %2d %##s PID[%d](%s)", v5, v6, v7, v8, v9, v10, (int)v38);
  }

  else if (v11 == port_mapping_termination_callback)
  {
    return LogToFD( a1,  "%s DNSServiceNATPortMapping   0x%08X %2d %s%s Int %5d Req %5d Ext %.4a:%5d Req TTL %5d Granted TTL %5d PID[%d](%s)",  v5,  v6,  v7,  v8,  v9,  v10,  (int)v38);
  }

  else if (v11 == addrinfo_termination_callback)
  {
    return LogToFD( a1,  "%s DNSServiceGetAddrInfo      0x%08X %2d %s%s %##s PID[%d](%s)",  v5,  v6,  v7,  v8,  v9,  v10,  (int)v38);
  }

  else
  {
    return LogToFD(a1, "%s Unrecognized operation %p", v5, v6, v7, v8, v9, v10, (int)v38);
  }

  return result;
}

uint64_t LogOneAuthRecordToFD(int a1, uint64_t a2, int a3)
{
  int v6 = *(_DWORD *)(a2 + 648);
  unint64_t v25 = 0LL;
  uint64_t v26 = 0LL;
  v27.unsigned __int16 tv_sec = 0LL;
  *(void *)&v27.tv_usec = 0LL;
  gettimeofday(&v27, 0LL);
  unsigned int v7 = v6 - a3;
  if (v6 - a3 < 1)
  {
    uint64_t v11 = 274877907000000LL * ((a3 - v6) % 1000);
    LODWORD(v11) = (v11 >> 38) + ((unint64_t)v11 >> 63);
    int v13 = v27.tv_usec - v11;
    BOOL v12 = v27.tv_usec < (int)v11;
    BOOL v14 = v27.tv_usec < (int)v11;
    if (v12) {
      int v15 = 1000000;
    }
    else {
      int v15 = 0;
    }
    unint64_t v9 = v27.tv_sec - (a3 - v6) / 1000 - v14;
    int v10 = v13 + v15;
  }

  else
  {
    int v8 = v27.tv_usec + (int)(1000000 * (v7 % 0x3E8)) / 1000;
    unint64_t v9 = v27.tv_sec + v7 / 0x3E8uLL + v8 / 1000000;
    int v10 = v8 % 1000000;
  }

  unint64_t v25 = v9;
  LODWORD(v26) = v10;
  getLocalTimestampFromTimeval((uint64_t)&v25, (char *)v28);
  uint64_t v16 = (unsigned __int8 *)(a2 + 8);
  if (*(void *)(a2 + 32) || *(_BYTE *)(a2 + 122) || IsLocalDomain(*(_BYTE **)(a2 + 40)))
  {
    GetRRDisplayString_rdb(v16, (unsigned __int16 *)(*(void *)(a2 + 48) + 4LL), word_100164338);
    uint64_t v23 = "%s %7d %7d %7d %-7s 0x%02X %s %s";
  }

  else
  {
    GetRRDisplayString_rdb(v16, (unsigned __int16 *)(*(void *)(a2 + 48) + 4LL), word_100164338);
    uint64_t v23 = "%s %7d %7d %7d %-7s %4d %s %s";
  }

  return LogToFD(a1, v23, v17, v18, v19, v20, v21, v22, (int)v28);
}

void LogClientInfo(uint64_t a1)
{
  *(void *)((char *)v36 + 6) = 0LL;
  v36[0] = 0LL;
  v34[0] = 0LL;
  v34[1] = 0LL;
  __int16 v35 = 0;
  mDNS_snprintf(v36);
  mDNS_snprintf(v34);
  unsigned int v7 = *(void (**)(uint64_t))(a1 + 96);
  if (v7)
  {
    if (v7 == connection_termination)
    {
      uint64_t v8 = *(void *)(a1 + 160);
      if (v8)
      {
        int v9 = 0;
        do
        {
          ++v9;
          uint64_t v8 = *(void *)(v8 + 8);
        }

        while (v8);
      }

      uint64_t v16 = *(void *)(a1 + 16);
      if (v16)
      {
        int v17 = 0;
        do
        {
          uint64_t v18 = v16 + 16;
          uint64_t v16 = *(void *)(v16 + 16);
          if (*(void *)(v18 + 8) == a1) {
            ++v17;
          }
        }

        while (v16);
      }

      LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "%s DNSServiceCreateConnection: %d registered record%s, %d kDNSServiceFlagsShareConnection operation%s PID[%d](%s)",  v2,  v3,  v4,  v5,  v6,  (int)v34);
      for (uint64_t i = *(void *)(a1 + 160); i; uint64_t i = *(void *)(i + 8))
      {
        uint64_t v20 = (os_log_s *)mDNSLogCategory_Default;
        int v21 = *(_DWORD *)(a1 + 232);
        GetRRDisplayString_rdb( (unsigned __int8 *)(*(void *)(i + 24) + 8LL),  (unsigned __int16 *)(*(void *)(*(void *)(i + 24) + 48LL) + 4LL),  word_100164338);
        LogMsgWithLevel( v20,  OS_LOG_TYPE_DEFAULT,  " ->  DNSServiceRegisterRecord   0x%08X %2d %3d %s PID[%d](%s)",  v22,  v23,  v24,  v25,  v26,  v21);
      }

      for (uint64_t j = *(void *)(a1 + 16); j; uint64_t j = *(void *)(j + 16))
      {
        if (*(void *)(j + 24) == a1) {
          LogClientInfo(j);
        }
      }
    }

    else if ((char *)v7 == (char *)regservice_termination_callback)
    {
      uint64_t v10 = *(void *)(a1 + 112);
      for (CFIndex k = *(void **)(v10 + 1624); k; CFIndex k = (void *)*k)
      {
        if (k == *(void **)(v10 + 1624)) {
          BOOL v12 = (const char *)v34;
        }
        else {
          BOOL v12 = "";
        }
        LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "%-9s DNSServiceRegister         0x%08X %2d %##s %u/%u PID[%d](%s)",  v2,  v3,  v4,  v5,  v6,  (int)v12);
      }
    }

    else if ((char *)v7 == (char *)browse_termination_callback)
    {
      uint64_t v13 = *(void *)(a1 + 136);
      for (uint64_t m = *(void **)(v13 + 272); m; uint64_t m = (void *)*m)
      {
        if (m == *(void **)(v13 + 272)) {
          int v15 = (const char *)v34;
        }
        else {
          int v15 = "";
        }
        LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "%-9s DNSServiceBrowse           0x%08X %2d %##s PID[%d](%s)",  v2,  v3,  v4,  v5,  v6,  (int)v15);
      }
    }

    else if (v7 == resolve_termination_callback)
    {
      LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "%s DNSServiceResolve          0x%08X %2d %##s PID[%d](%s)",  v2,  v3,  v4,  v5,  v6,  (int)v34);
    }

    else if (v7 == queryrecord_termination_callback)
    {
      uint64_t v28 = (os_log_s *)mDNSLogCategory_Default;
      DNSTypeName(*(unsigned __int16 *)(*(void *)(a1 + 128) + 322LL));
      LogMsgWithLevel( v28,  OS_LOG_TYPE_DEFAULT,  "%s DNSServiceQueryRecord      0x%08X %2d %##s (%s) PID[%d](%s)",  v29,  v30,  v31,  v32,  v33,  (int)v34);
    }

    else if ((char *)v7 == (char *)enum_termination_callback)
    {
      LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "%s DNSServiceEnumerateDomains 0x%08X %2d %##s PID[%d](%s)",  v2,  v3,  v4,  v5,  v6,  (int)v34);
    }

    else if (v7 == port_mapping_termination_callback)
    {
      LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "%s DNSServiceNATPortMapping   0x%08X %2d %s%s Int %5d Req %5d Ext %.4a:%5d Req TTL %5d Granted TTL %5d PID[%d](%s)",  v2,  v3,  v4,  v5,  v6,  (int)v34);
    }

    else if (v7 == addrinfo_termination_callback)
    {
      LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "%s DNSServiceGetAddrInfo      0x%08X %2d %s%s %##s PID[%d](%s)",  v2,  v3,  v4,  v5,  v6,  (int)v34);
    }

    else
    {
      LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "%s Unrecognized operation %p",  v2,  v3,  v4,  v5,  v6,  (int)v34);
    }
  }

  else
  {
    LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "%s No operation yet on this socket",  v2,  v3,  v4,  v5,  v6,  (int)v34);
  }

uint64_t _Querier_DNSServiceRegistrationStartHandler(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = pthread_mutex_lock((pthread_mutex_t *)(mDNSStorage[0] + 616));
  *(_DWORD *)(mDNSStorage[0] + 680) = mDNSPlatformRawTime(v6, v7, v8, v9, v10, v11, v12, v13);
  if (!a1) {
    goto LABEL_4;
  }
  int v21 = *(_UNKNOWN ***)(a1 + 16);
  if (v21 == &_mdns_dns_service_definition_kind)
  {
    uint64_t v23 = Querier_RegisterNativeDNSService(a1);
LABEL_7:
    uint64_t v22 = v23;
    goto LABEL_8;
  }

  if (v21 == &_mdns_dns_push_service_definition_kind)
  {
    uint64_t v23 = Querier_RegisterCustomPushDNSServiceWithConnectionErrorHandler(a1, a2, a3);
    goto LABEL_7;
  }

void _Querier_DNSServiceRegistrationStopHandler(uint64_t a1)
{
  uint64_t v2 = pthread_mutex_lock((pthread_mutex_t *)(mDNSStorage[0] + 616));
  *(_DWORD *)(mDNSStorage[0] + 680) = mDNSPlatformRawTime(v2, v3, v4, v5, v6, v7, v8, v9);
  uint64_t DNSServiceManager = Querier_GetDNSServiceManager();
  if (DNSServiceManager) {
    mdns_dns_service_manager_deregister_native_service(DNSServiceManager, a1);
  }
  uint64_t v11 = Querier_GetDNSServiceManager();
  if (v11) {
    mdns_dns_service_manager_deregister_custom_push_service(v11, a1);
  }
  KQueueUnlock((uint64_t)"DNS service registration stop handler", v12, v13, v14, v15, v16, v17, v18);
}

uint64_t Querier_GetDNSServiceManager()
{
  if (_Querier_EnsureNEDNSProxyStateWatchHasStarted_sOnce != -1) {
    dispatch_once(&_Querier_EnsureNEDNSProxyStateWatchHasStarted_sOnce, &__block_literal_global_32);
  }
  uint64_t v0 = Querier_GetDNSServiceManager_sDNSServiceManager;
  if (!Querier_GetDNSServiceManager_sDNSServiceManager)
  {
    if (_Querier_InternalQueue_sOnce != -1) {
      dispatch_once(&_Querier_InternalQueue_sOnce, &__block_literal_global_38);
    }
    uint64_t v1 = (dispatch_object_s *)_Querier_InternalQueue_sQueue;
    uint64_t v2 = _os_object_alloc(&OBJC_CLASS___OS_mdns_dns_service_manager, 136LL);
    uint64_t v0 = v2;
    if (v2)
    {
      uint64_t v3 = &_mdns_dns_service_manager_kind;
      *(void *)(v2 + 16) = &_mdns_dns_service_manager_kind;
      do
      {
        uint64_t v4 = (void (*)(uint64_t))v3[2];
        if (v4) {
          v4(v0);
        }
        uint64_t v3 = (_UNKNOWN **)*v3;
      }

      while (v3);
      if (_mdns_dns_service_manager_enumerate_all_service_array_pointers( v0,  (uint64_t)&__block_literal_global_772)
        && (CFMutableArrayRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0LL, (const CFArrayCallBacks *)&mdns_cfarray_callbacks),
            (*(void *)(v0 + 80) = Mutable) != 0LL))
      {
        *(void *)(v0 + 8_Block_object_dispose(va, 8) = v1;
        dispatch_retain(v1);
        if (!*(_BYTE *)(v0 + 132))
        {
          *(_WORD *)(v0 + 12_Block_object_dispose(va, 8) = 257;
          *(_DWORD *)(v0 + 120) = PQWorkaroundThreshold;
        }

        if (os_variant_has_internal_diagnostics("com.apple.mDNSResponder"))
        {
          uint64_t v6 = (const __CFNumber *)CFPreferencesCopyAppValue( @"DDRRetryIntervalSecs",  @"com.apple.mDNSResponder");
          if (v6)
          {
            uint64_t v7 = v6;
            CFTypeID v8 = CFGetTypeID(v6);
            if (v8 == CFNumberGetTypeID())
            {
              if (CFNumberIsFloatType(v7)
                || (valuePtr[0] = 0LL, !CFNumberGetValue(v7, kCFNumberLongLongType, valuePtr)))
              {
                uint64_t v10 = 0LL;
                char v9 = 1;
              }

              else
              {
                char v9 = 0;
                uint64_t v10 = valuePtr[0];
              }

              CFRelease(v7);
              uint64_t v11 = 0xFFFFFFFFLL;
              if (v10 < 0xFFFFFFFFLL) {
                uint64_t v11 = v10;
              }
              if ((v9 & 1) == 0)
              {
                int v12 = v11 & ~(v11 >> 63);
                if (v12)
                {
                  if (!*(_BYTE *)(v0 + 132))
                  {
                  }
                }
              }
            }

            else
            {
              CFRelease(v7);
            }
          }
        }

        v16[0] = _NSConcreteStackBlock;
        v16[1] = 0x40000000LL;
        void v16[2] = __Querier_GetDNSServiceManager_block_invoke;
        v16[3] = &__block_descriptor_tmp_3119;
        char v16[4] = v0;
        if (!*(_BYTE *)(v0 + 132))
        {
          uint64_t v13 = _Block_copy(v16);
          uint64_t v14 = *(const void **)(v0 + 104);
          if (v14) {
            _Block_release(v14);
          }
          *(void *)(v0 + 104) = v13;
        }

        Querier_GetDNSServiceManager_suint64_t DNSServiceManager = v0;
        os_retain((void *)v0);
        uint64_t v0 = Querier_GetDNSServiceManager_sDNSServiceManager;
        if (!*(_BYTE *)(Querier_GetDNSServiceManager_sDNSServiceManager + 132))
        {
          *(_BYTE *)(Querier_GetDNSServiceManager_sDNSServiceManager + 132) = 1;
          if (_mdns_dns_service_queue_s_once != -1) {
            dispatch_once(&_mdns_dns_service_queue_s_once, &__block_literal_global_237);
          }
          valuePtr[0] = _NSConcreteStackBlock;
          valuePtr[1] = 0x40000000LL;
          valuePtr[2] = __mdns_dns_service_manager_activate_block_invoke;
          valuePtr[3] = &__block_descriptor_tmp_4;
          valuePtr[4] = v0;
          dispatch_sync((dispatch_queue_t)_mdns_dns_service_queue_s_queue, valuePtr);
          return Querier_GetDNSServiceManager_sDNSServiceManager;
        }
      }

      else
      {
        os_release((void *)v0);
        return 0LL;
      }
    }
  }

  return v0;
}

uint64_t Querier_ProcessDNSServiceChanges(uint64_t result)
{
  int v1 = result;
  uint64_t v2 = qword_100158C80;
  if (qword_100158C80)
  {
    unsigned int v3 = 0;
    uint64_t v4 = qword_100158C80;
    do
    {
      ++v3;
      uint64_t v4 = *(void *)(v4 + 8);
    }

    while (v4);
    qword_100158CA8 = qword_100158C80;
    if (v3)
    {
      unsigned int v5 = 1;
      while (1)
      {
        __int16 v6 = *(_WORD *)(v2 + 320);
        if (v6)
        {
          if (!v1 || *(void *)(v2 + 184)) {
            goto LABEL_13;
          }
        }

        else
        {
          uint64_t result = DNSQuestionIsEligibleForMDNSAlternativeService(v2);
          if ((_DWORD)result)
          {
            uint64_t result = Querier_IsMDNSAlternativeServiceAvailableForQuestion(v2);
            if ((_DWORD)result)
            {
              *(_WORD *)(v2 + 320) = mDNS_NewMessageID((uint64_t)mDNSStorage);
LABEL_13:
              BOOL v7 = _Querier_ExcludeEncryptedDNSServices(v2);
              uint64_t result = _Querier_GetDNSService(v2, v7);
              uint64_t v8 = result;
              uint64_t v9 = *(void *)(v2 + 80);
              if (v9 == result)
              {
                if (result && *(_BYTE *)(result + 280) == 4)
                {
                  mDNSPlatformGetDNSRoutePolicy(v2);
                  uint64_t result = _Querier_GetDNSService(v2, v7);
                  uint64_t v8 = result;
                  BOOL v10 = 0;
                  uint64_t v9 = *(void *)(v2 + 80);
                  goto LABEL_16;
                }

                BOOL v10 = 0;
              }

              else
              {
                BOOL v10 = !*(void *)(v2 + 136)
                   && (!result
                    || *(_BYTE *)(result + 280) == 1
                    && *(unsigned __int8 *)(result + 281) - 2 >= 4
                    && (*(_WORD *)(result + 276) & 0x200) == 0);
LABEL_16:
                if (v9 != v8)
                {
                  int v11 = *(unsigned __int8 *)(v2 + 334);
LABEL_25:
                  *(_WORD *)(v2 + 320) = v6;
                  if (!v11)
                  {
                    uint64_t result = CacheRecordRmvEventsForQuestion(v2);
                    if (qword_100158CA8 == v2) {
                      uint64_t result = LocalRecordRmvEventsForQuestion(v2);
                    }
                  }

                  if (qword_100158CA8 == v2)
                  {
                    mDNS_StopQuery_internal(mDNSStorage, v2);
                    *(_BYTE *)(v2 + 622) = v10;
                    *(void *)(v2 + _Block_object_dispose(va, 8) = 0LL;
                    uint64_t result = mDNS_StartQuery_internal((uint64_t)mDNSStorage, v2);
                  }

                  goto LABEL_30;
                }

                uint64_t v8 = v9;
              }

              uint64_t result = DetermineUnicastQuerySuppression(v2, v8);
              int v11 = *(unsigned __int8 *)(v2 + 334);
              if (((_DWORD)result == 0) == (*(_BYTE *)(v2 + 334) != 0)) {
                goto LABEL_25;
              }
              *(_WORD *)(v2 + 320) = v6;
LABEL_30:
              uint64_t v12 = qword_100158CA8;
              if (qword_100158CA8 != v2) {
                goto LABEL_32;
              }
            }
          }
        }

        uint64_t v12 = *(void *)(v2 + 8);
        qword_100158CA8 = v12;
LABEL_32:
        if (v5 < v3)
        {
          ++v5;
          uint64_t v2 = v12;
          if (v12) {
            continue;
          }
        }

        break;
      }
    }
  }

  qword_100158CA8 = 0LL;
  if (!v1)
  {
    uint64_t v13 = 0LL;
    while (1)
    {
      uint64_t v14 = (void *)mDNSStorage[v13 + 35];
      if (v14) {
        break;
      }
LABEL_52:
      if (++v13 == 499) {
        return result;
      }
    }

    while (1)
    {
      uint64_t v15 = (void *)v14[2];
      if (v15) {
        break;
      }
LABEL_51:
      uint64_t v14 = (void *)*v14;
      if (!v14) {
        goto LABEL_52;
      }
    }

    while (1)
    {
      if (!v15[4])
      {
        uint64_t result = v15[7];
        if (result)
        {
          uint64_t v16 = *(void *)(result + 24);
          if (v16 && (*(_WORD *)(v16 + 276) & 1) == 0) {
            goto LABEL_50;
          }
          os_release((void *)result);
          v15[7] = 0LL;
        }

        uint64_t result = mDNS_PurgeCacheResourceRecord((unsigned int *)mDNSStorage, (uint64_t)v15);
      }

void _Querier_LogDNSServices(uint64_t a1)
{
  v6[0] = 0LL;
  v6[1] = v6;
  _DWORD v6[2] = 0x2000000000LL;
  int v7 = 0;
  uint64_t v8 = 0LL;
  uint64_t v9 = &v8;
  uint64_t v10 = 0x2000000000LL;
  uint64_t v11 = 0LL;
  if (_mdns_dns_service_queue_s_once != -1) {
    dispatch_once(&_mdns_dns_service_queue_s_once, &__block_literal_global_237);
  }
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000LL;
  block[2] = __mdns_dns_service_manager_get_count_block_invoke;
  block[3] = &unk_10013A5D8;
  void block[4] = &v8;
  void block[5] = a1;
  dispatch_sync((dispatch_queue_t)_mdns_dns_service_queue_s_queue, block);
  int v2 = *((_DWORD *)v9 + 6);
  _Block_object_dispose(&v8, 8);
  unsigned int v3 = (os_log_s *)mDNSLogCategory_Default;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
  {
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(block[0]) = 67109120;
      HIDWORD(block[0]) = v2;
      goto LABEL_9;
    }
  }

  else
  {
    unsigned int v3 = (os_log_s *)mDNSLogCategory_Default_redacted;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(block[0]) = 67109120;
      HIDWORD(block[0]) = v2;
LABEL_9:
      _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEFAULT,  "Updated DNS services (%u)",  (uint8_t *)block,  8u);
    }
  }

  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000LL;
  v4[2] = ___Querier_LogDNSServices_block_invoke;
  v4[3] = &unk_10013BFF0;
  v4[4] = v6;
  int v5 = v2;
  mdns_dns_service_manager_enumerate(a1, (uint64_t)v4);
  _Block_object_dispose(v6, 8);
}

uint64_t Querier_IsMDNSAlternativeServiceAvailableForQuestion(uint64_t a1)
{
  uint64_t result = Querier_GetDNSServiceManager(a1);
  if (result) {
    return _Querier_GetMDNSAlternativeService(result, a1) != 0;
  }
  return result;
}

BOOL _Querier_ExcludeEncryptedDNSServices(uint64_t a1)
{
  return Querier_QuestionBelongsToSelf(a1) || *(_BYTE *)(a1 + 630) || IsLocalDomain((_BYTE *)(a1 + 356));
}

uint64_t _Querier_GetDNSService(uint64_t a1, int a2)
{
  uint64_t DNSServiceManager = Querier_GetDNSServiceManager(a1);
  if (!DNSServiceManager) {
    return 0LL;
  }
  uint64_t v5 = DNSServiceManager;
  if (*(_BYTE *)(a1 + 631)) {
    return mdns_dns_service_manager_get_uuid_scoped_service(DNSServiceManager, a1 + 340, *(_DWORD *)(a1 + 136));
  }
  if (*(_WORD *)(a1 + 320)
    && !*(_BYTE *)(a1 + 618)
    && !*(_BYTE *)(a1 + 632)
    && ((unint64_t)(*(void *)(a1 + 136) + 5LL) <= 3 && *(void *)(a1 + 136) != -4LL
     || *(_BYTE *)(a1 + 614)
     || IsLocalDomain((_BYTE *)(a1 + 356)))
    && !Querier_QuestionBelongsToSelf(a1))
  {
    return _Querier_GetMDNSAlternativeService(v5, a1);
  }

  uint64_t v7 = *(void *)(a1 + 184);
  if (v7)
  {
    uint64_t v8 = *(void *)(v7 + 16);
    if (!v8) {
      return 0LL;
    }
    if (!*(_BYTE *)(v8 + 68))
    {
      uint64_t v11 = *(void *)(v7 + 16);
      if (v11)
      {
        if (*(void *)(v11 + 32))
        {
          uint64_t v12 = *(void *)(v11 + 16);
          if (v12) {
            return _Querier_GetDiscoveredPushDNSService(v5, *(_BYTE **)(v12 + 16), *(_DWORD *)(a1 + 136));
          }
        }
      }

      return 0LL;
    }
  }

  uint64_t CustomPushService = _Querier_GetCustomPushService(v5, a1);
  if (CustomPushService) {
    return CustomPushService;
  }
  uint64_t v10 = *(void *)(a1 + 136);
  if (v10)
  {
    uint64_t v32 = 0LL;
    uint64_t v33 = &v32;
    uint64_t v34 = 0x2000000000LL;
    uint64_t v35 = 0LL;
    if (_mdns_dns_service_queue_s_once != -1) {
      dispatch_once(&_mdns_dns_service_queue_s_once, &__block_literal_global_237);
    }
    blocCFIndex k = _NSConcreteStackBlock;
    uint64_t v37 = 0x40000000LL;
    unsigned int v38 = __mdns_dns_service_manager_get_interface_scoped_native_service_block_invoke;
    __int16 v39 = &unk_10013A2E8;
    int v40 = &v32;
    uint64_t v41 = v5;
    uint64_t v42 = a1 + 356;
    int v43 = v10;
    dispatch_sync((dispatch_queue_t)_mdns_dns_service_queue_s_queue, &block);
    uint64_t CustomPushService = v33[3];
    _Block_object_dispose(&v32, 8);
    if (CustomPushService) {
      return CustomPushService;
    }
  }

  else
  {
    uint64_t CustomPushService = mdns_dns_service_manager_get_unscoped_native_service(v5, a1 + 356);
    if (CustomPushService) {
      return CustomPushService;
    }
  }

  uint64_t v13 = *(void *)(a1 + 136);
  uint64_t v14 = v13;
  if (a2) {
    goto LABEL_27;
  }
  if (uuid_is_null((const unsigned __int8 *)(a1 + 340)))
  {
    uint64_t v14 = *(void *)(a1 + 136);
LABEL_27:
    if (v14)
    {
      uint64_t interface_scoped_system_service_with_options = mdns_dns_service_manager_get_interface_scoped_system_service_with_options( v5,  a1 + 356,  v13,  (a2 | gNEDNSProxyIsRunning) == 0);
LABEL_45:
      uint64_t CustomPushService = interface_scoped_system_service_with_options;
      goto LABEL_46;
    }

    int v16 = *(_DWORD *)(a1 + 280);
    if ((v16 & 0x80000000) == 0)
    {
      uint64_t interface_scoped_system_service_with_options = mdns_dns_service_manager_get_service_scoped_system_service( v5,  a1 + 356,  v16);
      goto LABEL_45;
    }

    int v20 = a2 | gNEDNSProxyIsRunning;
    BOOL v21 = v20 == 0;
    if (v20 || (uint64_t CustomPushService = mdns_dns_service_manager_get_discovered_service(v5, a1 + 356)) == 0)
    {
      uint64_t interface_scoped_system_service_with_options = mdns_dns_service_manager_get_unscoped_system_service_with_options( v5,  a1 + 356,  v21);
      goto LABEL_45;
    }

    goto LABEL_46;
  }

  uuid_scoped_uint64_t service = mdns_dns_service_manager_get_uuid_scoped_service(v5, a1 + 340, v13);
  if (!uuid_scoped_service) {
    return 0LL;
  }
  uint64_t v18 = uuid_scoped_service;
  uint64_t v19 = *(void *)(uuid_scoped_service + 96);
  discovered_uint64_t service = mdns_dns_service_manager_get_discovered_service(v5, a1 + 356);
  if (discovered_service)
  {
    uint64_t CustomPushService = discovered_service;
    uint64_t v28 = *(void *)(discovered_service + 96);
    if (v28)
    {
    }
  }

  discovered_oblivious_uint64_t service = mdns_dns_service_manager_get_discovered_oblivious_service(v5, v18, a1 + 356);
  if (!discovered_oblivious_service)
  {
LABEL_39:
    uint64_t CustomPushService = v18;
    goto LABEL_46;
  }

  uint64_t v30 = discovered_oblivious_service;
  uint64_t v31 = *(void *)(discovered_oblivious_service + 96);
  uint64_t CustomPushService = v18;
  if (v31)
  {
    else {
      uint64_t CustomPushService = v18;
    }
  }

BOOL Querier_QuestionBelongsToSelf(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 632)) {
    return 0LL;
  }
  int v2 = *(_DWORD *)(a1 + 244);
  if (v2)
  {
    if (_Querier_GetMyPID_sOnce != -1)
    {
      int v5 = *(_DWORD *)(a1 + 244);
      dispatch_once(&_Querier_GetMyPID_sOnce, &__block_literal_global_45);
      int v2 = v5;
    }

    return v2 == _Querier_GetMyPID_sPID;
  }

  else
  {
    uint64_t v4 = (const unsigned __int8 *)(a1 + 636);
    if (_Querier_GetMyUUID_sOnce != -1)
    {
      __int16 v6 = v4;
      dispatch_once(&_Querier_GetMyUUID_sOnce, &__block_literal_global_47_3135);
      uint64_t v4 = v6;
    }

    return uuid_compare(v4, _Querier_GetMyUUID_sUUID) == 0;
  }

uint64_t _Querier_GetMDNSAlternativeService(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 136);
  if (v3)
  {
    uint64_t v4 = a2 + 356;
    uint64_t v17 = 0LL;
    uint64_t v18 = &v17;
    uint64_t v19 = 0x2000000000LL;
    uint64_t v20 = 0LL;
    if (_mdns_dns_service_queue_s_once != -1) {
      dispatch_once(&_mdns_dns_service_queue_s_once, &__block_literal_global_237);
    }
    int v5 = (dispatch_queue_s *)_mdns_dns_service_queue_s_queue;
    uint64_t v9 = _NSConcreteStackBlock;
    uint64_t v10 = 0x40000000LL;
    uint64_t v11 = __mdns_dns_service_manager_get_interface_scoped_mdns_alternative_service_block_invoke;
    uint64_t v12 = &unk_10013A3F0;
    uint64_t v13 = &v17;
    uint64_t v14 = a1;
    uint64_t v15 = v4;
    int v16 = v3;
  }

  else
  {
    uint64_t v6 = a2 + 356;
    uint64_t v17 = 0LL;
    uint64_t v18 = &v17;
    uint64_t v19 = 0x2000000000LL;
    uint64_t v20 = 0LL;
    if (_mdns_dns_service_queue_s_once != -1) {
      dispatch_once(&_mdns_dns_service_queue_s_once, &__block_literal_global_237);
    }
    int v5 = (dispatch_queue_s *)_mdns_dns_service_queue_s_queue;
    uint64_t v9 = _NSConcreteStackBlock;
    uint64_t v10 = 0x40000000LL;
    uint64_t v11 = __mdns_dns_service_manager_get_unscoped_mdns_alternative_service_block_invoke;
    uint64_t v12 = &unk_10013A458;
    uint64_t v13 = &v17;
    uint64_t v14 = a1;
    uint64_t v15 = v6;
  }

  dispatch_sync(v5, &v9);
  uint64_t v7 = v18[3];
  _Block_object_dispose(&v17, 8);
  return v7;
}

uint64_t _Querier_GetDiscoveredPushDNSService(uint64_t a1, _BYTE *a2, int a3)
{
  v15[0] = xmmword_1000FFD40;
  v15[1] = unk_1000FFD50;
  memset(&v15[2], 0, 224);
  AppendDomainName(v15, a2);
  int v5 = mdns_domain_name_create_with_labels(v15, 0LL);
  if (!v5) {
    return 0LL;
  }
  uint64_t v6 = v5;
  uint64_t v11 = 0LL;
  uint64_t v12 = &v11;
  uint64_t v13 = 0x2000000000LL;
  uint64_t v14 = 0LL;
  if (_mdns_dns_service_queue_s_once != -1) {
    dispatch_once(&_mdns_dns_service_queue_s_once, &__block_literal_global_237);
  }
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 0x40000000LL;
  v9[2] = __mdns_dns_service_manager_get_discovered_push_service_block_invoke;
  v9[3] = &unk_10013A4F8;
  v9[4] = &v11;
  void v9[5] = a1;
  void v9[6] = v6;
  int v10 = a3;
  dispatch_sync((dispatch_queue_t)_mdns_dns_service_queue_s_queue, v9);
  uint64_t v7 = v12[3];
  _Block_object_dispose(&v11, 8);
  os_release(v6);
  return v7;
}

uint64_t _Querier_GetCustomPushService(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 136);
  if (v3)
  {
    uint64_t v4 = a2 + 356;
    uint64_t v17 = 0LL;
    uint64_t v18 = &v17;
    uint64_t v19 = 0x2000000000LL;
    uint64_t v20 = 0LL;
    if (_mdns_dns_service_queue_s_once != -1) {
      dispatch_once(&_mdns_dns_service_queue_s_once, &__block_literal_global_237);
    }
    int v5 = (dispatch_queue_s *)_mdns_dns_service_queue_s_queue;
    uint64_t v9 = _NSConcreteStackBlock;
    uint64_t v10 = 0x40000000LL;
    uint64_t v11 = __mdns_dns_service_manager_get_interface_scoped_custom_push_service_block_invoke;
    uint64_t v12 = &unk_10013A298;
    uint64_t v13 = &v17;
    uint64_t v14 = a1;
    uint64_t v15 = v4;
    int v16 = v3;
  }

  else
  {
    uint64_t v6 = a2 + 356;
    uint64_t v17 = 0LL;
    uint64_t v18 = &v17;
    uint64_t v19 = 0x2000000000LL;
    uint64_t v20 = 0LL;
    if (_mdns_dns_service_queue_s_once != -1) {
      dispatch_once(&_mdns_dns_service_queue_s_once, &__block_literal_global_237);
    }
    int v5 = (dispatch_queue_s *)_mdns_dns_service_queue_s_queue;
    uint64_t v9 = _NSConcreteStackBlock;
    uint64_t v10 = 0x40000000LL;
    uint64_t v11 = __mdns_dns_service_manager_get_unscoped_custom_push_service_block_invoke;
    uint64_t v12 = &unk_10013A270;
    uint64_t v13 = &v17;
    uint64_t v14 = a1;
    uint64_t v15 = v6;
  }

  dispatch_sync(v5, &v9);
  uint64_t v7 = v18[3];
  _Block_object_dispose(&v17, 8);
  return v7;
}

uint64_t Querier_RegisterNativeDNSService(uint64_t a1)
{
  uint64_t DNSServiceManager = Querier_GetDNSServiceManager();
  if (!DNSServiceManager) {
    return 0LL;
  }
  uint64_t v3 = DNSServiceManager;
  uint64_t v12 = 0LL;
  uint64_t v13 = &v12;
  uint64_t v14 = 0x2000000000LL;
  int v15 = 0;
  uint64_t v8 = 0LL;
  uint64_t v9 = &v8;
  uint64_t v10 = 0x2000000000LL;
  uint64_t v11 = 0LL;
  if (_mdns_dns_service_queue_s_once != -1) {
    dispatch_once(&_mdns_dns_service_queue_s_once, &__block_literal_global_237);
  }
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000LL;
  block[2] = __mdns_dns_service_manager_register_native_service_block_invoke;
  block[3] = &unk_10013A0A8;
  void block[4] = &v8;
  void block[5] = &v12;
  block[6] = v3;
  void block[7] = a1;
  dispatch_sync((dispatch_queue_t)_mdns_dns_service_queue_s_queue, block);
  int v4 = *((_DWORD *)v13 + 6);
  uint64_t v5 = v9[3];
  _Block_object_dispose(&v8, 8);
  _Block_object_dispose(&v12, 8);
  if (v4)
  {
    uint64_t v6 = (os_log_s *)mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_FAULT))
      {
        LODWORD(block[0]) = 67109120;
        HIDWORD(block[0]) = v4;
        goto LABEL_12;
      }
    }

    else
    {
      uint64_t v6 = (os_log_s *)mDNSLogCategory_Default_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_FAULT))
      {
        LODWORD(block[0]) = 67109120;
        HIDWORD(block[0]) = v4;
LABEL_12:
        _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_FAULT,  "Failed to register native DNS service - error: %d.",  (uint8_t *)block,  8u);
      }
    }
  }

  return v5;
}

uint64_t Querier_RegisterCustomPushDNSServiceWithConnectionErrorHandler(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t DNSServiceManager = Querier_GetDNSServiceManager();
  if (!DNSServiceManager) {
    return 0LL;
  }
  uint64_t v7 = DNSServiceManager;
  uint64_t v16 = 0LL;
  uint64_t v17 = &v16;
  uint64_t v18 = 0x2000000000LL;
  int v19 = 0;
  uint64_t v12 = 0LL;
  uint64_t v13 = &v12;
  uint64_t v14 = 0x2000000000LL;
  uint64_t v15 = 0LL;
  if (_mdns_dns_service_queue_s_once != -1) {
    dispatch_once(&_mdns_dns_service_queue_s_once, &__block_literal_global_237);
  }
  *(void *)&blocCFIndex k = _NSConcreteStackBlock;
  *((void *)&block + 1) = 0x40000000LL;
  BOOL v21 = __mdns_dns_service_manager_register_custom_push_service_block_invoke;
  int v22 = &unk_10013A110;
  unsigned int v25 = &v16;
  uint64_t v26 = v7;
  int v29 = 0;
  uint64_t v27 = a1;
  uint64_t v28 = a2;
  uint64_t v23 = a3;
  int v24 = &v12;
  dispatch_sync((dispatch_queue_t)_mdns_dns_service_queue_s_queue, &block);
  uint64_t v8 = *((int *)v17 + 6);
  uint64_t v9 = v13[3];
  _Block_object_dispose(&v12, 8);
  _Block_object_dispose(&v16, 8);
  if ((_DWORD)v8)
  {
    uint64_t v10 = (os_log_s *)mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_FAULT))
      {
        LODWORD(block) = 134217984;
        *(void *)((char *)&block + 4) = v8;
        goto LABEL_12;
      }
    }

    else
    {
      uint64_t v10 = (os_log_s *)mDNSLogCategory_Default_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_FAULT))
      {
        LODWORD(block) = 134217984;
        *(void *)((char *)&block + 4) = v8;
LABEL_12:
        _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_FAULT,  "Failed to register custom push service - error: %{mdns:err}ld",  (uint8_t *)&block,  0xCu);
      }
    }
  }

  return v9;
}

uint64_t _Querier_VPNDNSServiceExistsForQName(uint64_t a1)
{
  uint64_t result = Querier_GetDNSServiceManager(a1);
  if (result)
  {
    uint64_t unscoped_system_service_with_options = mdns_dns_service_manager_get_unscoped_system_service_with_options( result,  a1,  0);
    return unscoped_system_service_with_options && (*(_WORD *)(unscoped_system_service_with_options + 276) & 0x200) != 0;
  }

  return result;
}

void Querier_RegisterPathResolver(uint64_t a1)
{
  uint64_t DNSServiceManager = Querier_GetDNSServiceManager(a1);
  if (DNSServiceManager)
  {
    uint64_t v3 = DNSServiceManager;
    if (_mdns_dns_service_queue_s_once != -1) {
      dispatch_once(&_mdns_dns_service_queue_s_once, &__block_literal_global_237);
    }
    v4[0] = _NSConcreteStackBlock;
    v4[1] = 0x40000000LL;
    v4[2] = __mdns_dns_service_manager_register_path_resolver_block_invoke;
    v4[3] = &__block_descriptor_tmp_13_798;
    v4[4] = v3;
    void v4[5] = a1;
    dispatch_sync((dispatch_queue_t)_mdns_dns_service_queue_s_queue, v4);
  }

uint64_t Querier_RegisterCustomDNSServiceWithPListData(const UInt8 *a1, CFIndex a2)
{
  uint64_t DNSServiceManager = Querier_GetDNSServiceManager();
  if (DNSServiceManager)
  {
    uint64_t v5 = DNSServiceManager;
    uint64_t v6 = CFDataCreate(0LL, a1, a2);
    if (v6)
    {
      uint64_t v7 = v6;
      CFPropertyListRef v8 = CFPropertyListCreateWithData(0LL, v6, 0LL, 0LL, 0LL);
      CFRelease(v7);
      if (v8)
      {
        CFTypeID v9 = CFGetTypeID(v8);
        if (v9 == CFDictionaryGetTypeID())
        {
          uint64_t v10 = (void *)_CFXPCCreateXPCObjectFromCFObject(v8);
          CFRelease(v8);
          if (v10)
          {
            uint64_t v11 = mdns_dns_service_manager_register_custom_service(v5, (uint64_t)v10);
            xpc_release(v10);
            return v11;
          }
        }

        else
        {
          CFRelease(v8);
        }
      }
    }
  }

  return 0LL;
}

void Querier_DeregisterCustomDNSService(uint64_t a1)
{
  uint64_t DNSServiceManager = Querier_GetDNSServiceManager();
  if (DNSServiceManager)
  {
    uint64_t v3 = DNSServiceManager;
    if (_mdns_dns_service_queue_s_once != -1) {
      dispatch_once(&_mdns_dns_service_queue_s_once, &__block_literal_global_237);
    }
    v4[0] = _NSConcreteStackBlock;
    v4[1] = 0x40000000LL;
    v4[2] = __mdns_dns_service_manager_deregister_custom_service_block_invoke;
    v4[3] = &__block_descriptor_tmp_15;
    v4[4] = v3;
    void v4[5] = a1;
    dispatch_sync((dispatch_queue_t)_mdns_dns_service_queue_s_queue, v4);
  }

void Querier_HandleUnicastQuestion(uint64_t a1)
{
  uint64_t v3 = (void **)(a1 + 96);
  uint64_t v2 = *(void *)(a1 + 96);
  if (v2)
  {
    if (*(_UNKNOWN ***)(v2 + 16) == &_mdns_querier_kind)
    {
      int v4 = 0LL;
      uint64_t v5 = 0LL;
      uint64_t v6 = 0LL;
      BOOL v7 = !mdns_querier_match( *(void *)(v2 + 88),  (unsigned __int8 *)(a1 + 356),  *(unsigned __int16 *)(a1 + 322),  *(unsigned __int16 *)(a1 + 324));
LABEL_62:
      *(_BYTE *)(a1 + 62_Block_object_dispose(va, 8) = v7;
      goto LABEL_63;
    }

    goto LABEL_40;
  }

  if (!*(void *)(a1 + 80)) {
    goto LABEL_40;
  }
  uint64_t v8 = *(void *)(a1 + 144);
  if (v8) {
    BOOL v9 = *(unsigned __int8 *)(v8 + 24) != 0;
  }
  else {
    BOOL v9 = 0;
  }
  CFMutableArrayRef Mutable = (const __CFSet *)_Querier_GetOrphanedQuerierSet_sOrphanedQuerierSet;
  if (!_Querier_GetOrphanedQuerierSet_sOrphanedQuerierSet)
  {
    CFMutableArrayRef Mutable = CFSetCreateMutable(kCFAllocatorDefault, 0LL, (const CFSetCallBacks *)&gMDNSObjectSetCallbacks);
    _Querier_GetOrphanedQuerierSet_sOrphanedQuerierSet = (uint64_t)Mutable;
    if (!Mutable) {
      goto LABEL_18;
    }
  }

  *(void *)atoken.val = 0LL;
  *(void *)&atoken.val[2] = &atoken;
  *(void *)&atoken.val[4] = 0x2000000000LL;
  *(void *)&atoken.val[6] = 0LL;
  v42[0] = _NSConcreteStackBlock;
  v42[1] = 0x40000000LL;
  v42[2] = __Querier_HandleUnicastQuestion_block_invoke;
  v42[3] = &unk_10013BE08;
  BOOL v43 = v9;
  v42[4] = &atoken;
  v42[5] = a1;
  mdns_cfset_enumerate(Mutable, (uint64_t)v42);
  uint64_t v11 = *(void **)(*(void *)&atoken.val[2] + 24LL);
  if (v11)
  {
    mdns_client_replace(v3, v11);
    CFSetRemoveValue(Mutable, *(const void **)(*(void *)&atoken.val[2] + 24LL));
    mdns_querier_set_time_limit_ms(*(void **)(*(void *)&atoken.val[2] + 24LL), 0);
    uint64_t v12 = (os_log_s *)mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
      {
LABEL_16:
        unsigned int v13 = bswap32(*(unsigned __int16 *)(a1 + 320));
        int v14 = *(_DWORD *)(*(void *)(*(void *)&atoken.val[2] + 24LL) + 232LL);
        *(_DWORD *)timespec buf = 67109376;
        unsigned int v45 = HIWORD(v13);
        __int16 v46 = 1024;
        int v47 = v14;
        _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEFAULT,  "[Q%u->Q%u] Adopted orphaned querier",  buf,  0xEu);
      }
    }

    else
    {
      uint64_t v12 = (os_log_s *)mDNSLogCategory_Default_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_16;
      }
    }
  }

  _Block_object_dispose(&atoken, 8);
LABEL_18:
  if (*v3)
  {
    BOOL v7 = 0;
    int v4 = 0LL;
    uint64_t v5 = 0LL;
    uint64_t v6 = 0LL;
    goto LABEL_62;
  }

  uint64_t v15 = *(void *)(a1 + 80);
  if (*(_BYTE *)(v15 + 281) == 5)
  {
    uint64_t v16 = *(void **)(v15 + 72);
    if (v16)
    {
      subscriber = mdns_push_server_create_subscriber(v16);
      if (subscriber)
      {
        uint64_t v18 = (uint64_t)subscriber;
        int v19 = (os_log_s *)mDNSLogCategory_Default;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
        {
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
          {
LABEL_47:
            unsigned int v29 = bswap32(*(unsigned __int16 *)(a1 + 320));
            uint64_t v30 = *(void *)(v18 + 120);
            atoken.val[0] = 67109376;
            atoken.val[1] = HIWORD(v29);
            LOWORD(atoken.val[2]) = 2048;
            *(void *)((char *)&atoken.val[2] + 2) = v30;
            _os_log_impl( (void *)&_mh_execute_header,  v19,  OS_LOG_TYPE_DEFAULT,  "[Q%u->Sub%llu] Created a subscriber for question",  (uint8_t *)&atoken,  0x12u);
          }
        }

        else
        {
          int v19 = (os_log_s *)mDNSLogCategory_Default_redacted;
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_47;
          }
        }

        uint64_t v6 = 0LL;
        uint64_t v5 = (void *)v18;
        goto LABEL_49;
      }
    }

CFArrayRef _Querier_ApplyUpdate(void *a1)
{
  uint64_t result = (const __CFArray *)a1[14];
  if (result)
  {
    uint64_t v3 = a1[4];
    uint64_t v4 = *(unsigned int *)(a1[7] + 96LL);
    v5[0] = _NSConcreteStackBlock;
    v5[1] = 0x40000000LL;
    v5[2] = ___Querier_ApplyUpdate_block_invoke;
    void v5[3] = &__block_descriptor_tmp_43_3204;
    v5[4] = v3;
    void v5[5] = v4;
    void v5[6] = a1;
    return (const __CFArray *)mdns_cfarray_enumerate(result, (uint64_t)v5);
  }

  return result;
}

void _Querier_HandleSubscriberInvalidation(uint64_t a1)
{
  uint64_t v2 = *(_BYTE **)((*(uint64_t (**)(uint64_t))(*(void *)(a1 + 16) + 80LL))(a1) + 24);
  unsigned int v3 = DomainNameHashValue((unint64_t)v2);
  uint64_t v4 = CacheGroupForName((uint64_t)mDNSStorage, v3, v2);
  if (v4)
  {
    uint64_t v5 = v4[2];
    if (v5)
    {
      uint64_t v6 = *(void *)(a1 + 120);
      while (1)
      {
        if (!*(_BYTE *)(v5 + 109)) {
          goto LABEL_45;
        }
        uint64_t v7 = *(void *)(v5 + 56);
        if (v7) {
          uint64_t v7 = *(void *)(v7 + 40);
        }
        if (v7 != v6) {
          goto LABEL_45;
        }
        uint64_t v8 = (os_log_s *)mDNSLogCategory_Default;
        if (gSensitiveLoggingEnabled == 1 && mDNSLogCategory_Default != mDNSLogCategory_State) {
          break;
        }
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v10 = *(void *)(v5 + 40);
          if (v10)
          {
            uint64_t v11 = *(_BYTE **)(v5 + 40);
            if (v10 == -256) {
              goto LABEL_19;
            }
LABEL_16:
            unsigned __int16 v12 = 257;
            if ((unint64_t)v11 < v10 + 256 && v11)
            {
              while (1)
              {
                uint64_t v13 = *v11;
                if (v13 > 0x3F)
                {
LABEL_37:
                  unsigned __int16 v12 = 257;
                  goto LABEL_40;
                }

                if (!*v11) {
                  break;
                }
                v11 += v13 + 1;
                if (v10 != -256) {
                  goto LABEL_16;
                }
LABEL_19:
                if (!v11) {
                  goto LABEL_37;
                }
              }

              unsigned __int16 v12 = (_WORD)v11 - v10 + 1;
            }

void _Querier_RemoveRecord(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  size_t v4 = *(unsigned __int16 *)(a1 + 56);
  if (v4 <= 0x2000)
  {
    BOOL v9 = *(_BYTE **)(*(void *)(a1 + 24) + 24LL);
    mDNS_Lock_((unsigned int *)mDNSStorage, (uint64_t)"_Querier_RemoveRecord", 1567);
    unsigned int v10 = DomainNameHashValue((unint64_t)v9);
    uint64_t v11 = CacheGroupForName((uint64_t)mDNSStorage, v10, v9);
    if (v11)
    {
      uint64_t v12 = v11[2];
      if (v12)
      {
        int v13 = *(unsigned __int16 *)(a1 + 52);
        int v14 = *(unsigned __int16 *)(a1 + 54);
        uint64_t v15 = *(const void **)(a1 + 32);
        __int16 v16 = *(_WORD *)(a2 + 276);
        do
        {
          if (*(void *)(v12 + 32) == a3)
          {
            if ((v16 & 0x4000) != 0) {
              goto LABEL_12;
            }
            uint64_t v17 = *(void *)(v12 + 56);
            if (v17) {
              uint64_t v17 = *(void *)(v17 + 24);
            }
            if (v17 == a2)
            {
LABEL_12:
              if (a4)
              {
                if (v14 == 255
                  || *(unsigned __int16 *)(v12 + 14) == v14
                  && ((int v22 = *(unsigned __int16 *)(v12 + 12), v22 == 255) || v22 == v13))
                {
                  mDNS_PurgeCacheResourceRecord((unsigned int *)mDNSStorage, v12);
                }
              }

              else if (*(unsigned __int16 *)(v12 + 12) == v13 {
                     && *(unsigned __int16 *)(v12 + 14) == v14
              }
                     && *(unsigned __int16 *)(v12 + 20) == (_DWORD)v4)
              {
                __memset_chk(_Querier_RemoveRecord_rdataBuf, 0LL, v4, 0x2000LL);
                putRData( 0LL,  _Querier_RemoveRecord_rdataBuf,  (unint64_t)&_Querier_GetMyPID_sOnce,  v12 + 8,  v18,  v19,  v20,  v21);
                if (!memcmp(_Querier_RemoveRecord_rdataBuf, v15, v4))
                {
                  mDNS_PurgeCacheResourceRecord((unsigned int *)mDNSStorage, v12);
                  break;
                }
              }
            }
          }

          uint64_t v12 = *(void *)v12;
        }

        while (v12);
      }
    }

    mDNS_Unlock_((uint64_t)mDNSStorage, (uint64_t)"_Querier_RemoveRecord", 1632);
  }

uint64_t Querier_GetDNSQuestion(uint64_t a1, _BYTE *a2)
{
  uint64_t result = qword_100158C80;
  if (!qword_100158C80)
  {
LABEL_8:
    char v6 = 0;
    if (!a2) {
      return result;
    }
    goto LABEL_9;
  }

  char v4 = 0;
  while (1)
  {
    uint64_t v5 = *(void *)(result + 96);
    if (!v5 || *(_UNKNOWN ***)(v5 + 16) != &_mdns_querier_kind) {
      uint64_t v5 = 0LL;
    }
    v4 |= result == qword_100158C88;
    if (v5 == a1) {
      break;
    }
    uint64_t result = *(void *)(result + 8);
    if (!result) {
      goto LABEL_8;
    }
  }

  char v6 = v4 & 1;
  if (a2) {
LABEL_9:
  }
    *a2 = v6;
  return result;
}

void Querier_ProcessDNSServiceChangesAsync()
{
  if (_Querier_InternalQueue_sOnce != -1) {
    dispatch_once(&_Querier_InternalQueue_sOnce, &__block_literal_global_38);
  }
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000LL;
  block[2] = __Querier_ProcessDNSServiceChangesAsync_block_invoke;
  block[3] = &__block_descriptor_tmp_22_3217;
  char v1 = 1;
  dispatch_async((dispatch_queue_t)_Querier_InternalQueue_sQueue, block);
}

BOOL Client_SameNameCacheRecordIsAnswer(uint64_t a1, uint64_t a2)
{
  unsigned int v4 = (*(uint64_t (**)(uint64_t))(*(void *)(a2 + 16) + 88LL))(a2);
  int v5 = *(unsigned __int16 *)(a1 + 14);
  if (*(_UNKNOWN ***)(a2 + 16) == &_mdns_querier_kind)
  {
    unsigned int v13 = *(unsigned __int8 *)(*(void *)(a2 + 88) + 70LL);
    if ((v13 & 4) != 0) {
      uint64_t v11 = (v13 >> 1) & 1;
    }
    else {
      uint64_t v11 = 0LL;
    }
  }

  else
  {
    uint64_t v11 = 0LL;
  }

  return RRTypeAnswersQuestionType(a1 + 8, v4, v11, v6, v7, v8, v9, v10);
}

uint64_t __DPCHandleNewQuestion_block_invoke(uint64_t a1, void *a2)
{
  return 1LL;
}

void _DPCSubscribe(uint64_t a1, void *a2)
{
  uint64_t v18 = 0LL;
  uint64_t v19 = &v18;
  uint64_t v20 = 0x2000000000LL;
  uint64_t v21 = 0LL;
  if (gDPCPushServers)
  {
    Value = (void *)CFDictionaryGetValue((CFDictionaryRef)gDPCPushServers, a2);
    if (Value)
    {
      int v5 = Value;
      uint64_t Subscriber = _DPCQuestionGetSubscriber(*(const __CFSet **)(a1 + 192), (uint64_t)a2);
      v19[3] = Subscriber;
      if (!Subscriber)
      {
        if (*(void *)(a1 + 192)
          || (CFMutableSetRef v7 = CFSetCreateMutable(kCFAllocatorDefault, 0LL, (const CFSetCallBacks *)&gMDNSObjectSetCallbacks),
              (*(void *)(a1 + 192) = v7) != 0LL))
        {
          uint64_t v8 = (const __CFDictionary *)gDPCSubscriberRegistries;
          if (gDPCSubscriberRegistries
            || (uint64_t v8 = CFDictionaryCreateMutable( kCFAllocatorDefault,  0LL,  &gInterfaceIDDictionaryKeyCallbacks,  &kCFTypeDictionaryValueCallBacks),  (gDPCSubscriberRegistries = (uint64_t)v8) != 0))
          {
            uint64_t v9 = (void *)CFDictionaryGetValue(v8, a2);
            if (!v9)
            {
              CFMutableBagRef Mutable = CFBagCreateMutable(kCFAllocatorDefault, 0LL, (const CFBagCallBacks *)&gMDNSObjectBagCallbacks);
              if (!Mutable) {
                goto LABEL_4;
              }
              uint64_t v9 = Mutable;
              CFDictionarySetValue((CFMutableDictionaryRef)gDPCSubscriberRegistries, a2, Mutable);
              CFRelease(v9);
            }

            uint64_t v11 = (const void *)_DPCGetRegisteredSubscriber(a2, a1 + 356, *(_WORD *)(a1 + 322), *(_WORD *)(a1 + 324));
            v19[3] = (uint64_t)v11;
            if (v11)
            {
              uint64_t v12 = 0LL;
            }

            else
            {
              unsigned int v13 = mdns_domain_name_create_with_labels((_BYTE *)(a1 + 356), 0LL);
              if (!v13) {
                goto LABEL_4;
              }
              uint64_t v12 = v13;
              int v14 = mdns_push_server_create_subscriber(v5);
              v19[3] = (uint64_t)v14;
              if (!v14) {
                goto LABEL_15;
              }
              uint64_t v15 = (uint64_t)v14;
              if (!*((_BYTE *)v14 + 49))
              {
                (*(void (**)(void *, void *, void, void))(v14[2] + 56LL))( v14,  v12,  *(unsigned __int16 *)(a1 + 322),  *(unsigned __int16 *)(a1 + 324));
                uint64_t v15 = v19[3];
              }

              if (_Querier_InternalQueue_sOnce != -1) {
                dispatch_once(&_Querier_InternalQueue_sOnce, &__block_literal_global_38);
              }
              mdns_client_set_queue(v15, (dispatch_object_t)_Querier_InternalQueue_sQueue);
              os_retain((void *)v19[3]);
              uint64_t v16 = v19[3];
              aBlock[0] = _NSConcreteStackBlock;
              aBlock[1] = 0x40000000LL;
              aBlock[2] = ___DPCSubscribe_block_invoke;
              aBlock[3] = &unk_10013C0E8;
              aBlock[4] = &v18;
              mdns_subscriber_set_event_handler(v16, aBlock);
              mdns_client_activate(v19[3]);
              uint64_t v11 = (const void *)v19[3];
            }

            CFSetAddValue(*(CFMutableSetRef *)(a1 + 192), v11);
            CFBagAddValue((CFMutableBagRef)v9, (const void *)v19[3]);
            if (v12) {
LABEL_15:
            }
              os_release(v12);
          }
        }
      }
    }
  }

uint64_t _DPCQuestionGetSubscriber(const __CFSet *a1, uint64_t a2)
{
  uint64_t v5 = 0LL;
  uint64_t v6 = &v5;
  uint64_t v7 = 0x2000000000LL;
  uint64_t v8 = 0LL;
  if (a1)
  {
    v4[0] = _NSConcreteStackBlock;
    v4[1] = 0x40000000LL;
    v4[2] = ___DPCQuestionGetSubscriber_block_invoke;
    v4[3] = &unk_10013C110;
    v4[4] = &v5;
    void v4[5] = a2;
    mdns_cfset_enumerate(a1, (uint64_t)v4);
    uint64_t v2 = v6[3];
  }

  else
  {
    uint64_t v2 = 0LL;
  }

  _Block_object_dispose(&v5, 8);
  return v2;
}

uint64_t _DPCGetRegisteredSubscriber(void *key, uint64_t a2, __int16 a3, __int16 a4)
{
  uint64_t v13 = 0LL;
  int v14 = &v13;
  uint64_t v15 = 0x2000000000LL;
  uint64_t v16 = 0LL;
  if (gDPCSubscriberRegistries)
  {
    Value = (const __CFBag *)CFDictionaryGetValue((CFDictionaryRef)gDPCSubscriberRegistries, key);
    if (Value)
    {
      v10[0] = _NSConcreteStackBlock;
      v10[1] = 0x40000000LL;
      v10[2] = ___DPCGetRegisteredSubscriber_block_invoke;
      void v10[3] = &unk_10013C168;
      __int16 v11 = a3;
      __int16 v12 = a4;
      v10[4] = &v13;
      v10[5] = a2;
      mdns_cfbag_enumerate(Value, (uint64_t)v10);
    }
  }

  uint64_t v8 = v14[3];
  _Block_object_dispose(&v13, 8);
  return v8;
}

void DPCBrowseHandler(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  if (DPCFeatureEnabled_sOnce != -1) {
    dispatch_once(&DPCFeatureEnabled_sOnce, &__block_literal_global_3237);
  }
  if (a4 == 1)
  {
    if (DPCFeatureEnabled_sEnabled)
    {
      uint64_t v6 = *(void **)(a3 + 24);
      if (!gDPCPushServers || !CFDictionaryGetValue((CFDictionaryRef)gDPCPushServers, *(const void **)(a3 + 24)))
      {
        uint64_t v7 = mdns_domain_name_create_with_labels(*(_BYTE **)(a3 + 32), 0LL);
        if (v7)
        {
          uint64_t v8 = v7;
          _DPCRemovePushServer(v6);
          if (gDPCPushServers
            || (gDPCPushServers = (uint64_t)CFDictionaryCreateMutable( kCFAllocatorDefault,  0LL,  &gInterfaceIDDictionaryKeyCallbacks,  (const CFDictionaryValueCallBacks *)&gMDNSObjectDictionaryValueCallbacks)) != 0)
          {
            uint64_t v9 = mdns_push_server_create();
            if (v9)
            {
              uint64_t v10 = v9;
              mdns_push_server_set_srv_name((uint64_t)v9, v8);
              v10[103] = 1;
              CFDictionarySetValue((CFMutableDictionaryRef)gDPCPushServers, v6, v10);
              uint64_t v11 = qword_100158C80;
              if (qword_100158C80)
              {
                uint64_t v12 = qword_100158C88;
                if (qword_100158C80 != qword_100158C88)
                {
                  do
                  {
                    if (!*(_WORD *)(v11 + 320) && *(int *)(v11 + 212) >= 1 && !*(void *)(v11 + 40))
                    {
                      int v14 = *(void **)(v11 + 136);
                      if (v14 == v6 || v14 == 0LL)
                      {
                        _DPCSubscribe(v11, v6);
                        uint64_t v12 = qword_100158C88;
                      }
                    }

                    uint64_t v11 = *(void *)(v11 + 8);
                    if (v11) {
                      BOOL v13 = v11 == v12;
                    }
                    else {
                      BOOL v13 = 1;
                    }
                  }

                  while (!v13);
                }
              }

              os_release(v10);
            }
          }

          os_release(v8);
        }
      }
    }
  }

void _DPCRemovePushServer(void *key)
{
  uint64_t v2 = qword_100158C80;
  if (qword_100158C80) {
    BOOL v3 = qword_100158C80 == qword_100158C88;
  }
  else {
    BOOL v3 = 1;
  }
  if (!v3)
  {
    do
    {
      uint64_t Subscriber = (const void *)_DPCQuestionGetSubscriber(*(const __CFSet **)(v2 + 192), (uint64_t)key);
      if (Subscriber) {
        CFSetRemoveValue(*(CFMutableSetRef *)(v2 + 192), Subscriber);
      }
      uint64_t v2 = *(void *)(v2 + 8);
      if (v2) {
        BOOL v5 = v2 == qword_100158C88;
      }
      else {
        BOOL v5 = 1;
      }
    }

    while (!v5);
  }

  if (gDPCSubscriberRegistries)
  {
    Value = (const __CFBag *)CFDictionaryGetValue((CFDictionaryRef)gDPCSubscriberRegistries, key);
    if (Value)
    {
      uint64_t v7 = Value;
      mdns_cfbag_enumerate(Value, (uint64_t)&__block_literal_global_54);
      CFBagRemoveAllValues(v7);
      CFDictionaryRemoveValue((CFMutableDictionaryRef)gDPCSubscriberRegistries, key);
    }
  }

  if (gDPCPushServers)
  {
    uint64_t v8 = CFDictionaryGetValue((CFDictionaryRef)gDPCPushServers, key);
    if (v8)
    {
      mdns_push_server_invalidate(v8);
      CFDictionaryRemoveValue((CFMutableDictionaryRef)gDPCPushServers, key);
    }
  }

uint64_t _dns_push_obj_dns_question_member_compare()
{
  return 2LL;
}

void _dns_push_obj_dns_question_member_finalize(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 16);
  if (v2)
  {
    ref_count_obj_release(v2);
    *(void *)(a1 + 16) = 0LL;
  }

_BYTE *domain_name_labels_create(_BYTE *a1, int *a2)
{
  int v4 = *a1;
  BOOL v5 = a1;
  if (*a1)
  {
    BOOL v5 = a1;
    do
    {
      uint64_t v6 = &v5[v4];
      int v7 = v6[1];
      BOOL v5 = v6 + 1;
      int v4 = v7;
    }

    while (v7);
  }

  size_t v8 = v5 - a1 + 1;
  if (v8 > 0x100)
  {
LABEL_18:
    uint64_t v10 = 0LL;
    int v15 = -6751;
    if (!a2) {
      return v10;
    }
    goto LABEL_15;
  }

  if (v5 - a1 == -1 || (uint64_t v9 = malloc(v5 - a1 + 1)) == 0LL)
  {
    __break(1u);
    goto LABEL_18;
  }

  uint64_t v10 = v9;
  memcpy(v9, a1, v8);
  int v11 = *v10;
  if (*v10)
  {
    uint64_t v12 = v10;
    do
    {
      ++v12;
      unsigned int v13 = v11 + 1;
      do
      {
        int v14 = *v12;
        ++v12;
        --v13;
      }

      while (v13 > 1);
      int v11 = *v12;
    }

    while (*v12);
  }

  int v15 = 0;
  if (a2) {
LABEL_15:
  }
    *a2 = v15;
  return v10;
}

_BYTE *domain_name_labels_get_parent(_BYTE *result, unint64_t a2)
{
  int v2 = *result;
  if (*result)
  {
    unint64_t v3 = 0LL;
    int v4 = *result;
    BOOL v5 = result;
    do
    {
      ++v3;
      uint64_t v6 = &v5[v4];
      int v7 = v6[1];
      BOOL v5 = v6 + 1;
      int v4 = v7;
    }

    while (v7);
  }

  else
  {
    unint64_t v3 = 0LL;
  }

  if (v3 < a2)
  {
    int v14 = (os_log_s *)mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_FAULT)) {
        return 0LL;
      }
    }

    else
    {
      int v14 = (os_log_s *)mDNSLogCategory_Default_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_FAULT)) {
        return 0LL;
      }
    }

    int v17 = 136447234;
    uint64_t v18 = "index <= label_count";
    __int16 v19 = 2082;
    uint64_t v20 = "";
    __int16 v21 = 2082;
    int v22 = "/Library/Caches/com.apple.xbs/Sources/mDNSResponder/mDNSShared/dns_objects/utilities/domain_name_labels.c";
    __int16 v23 = 1024;
    int v24 = 107;
    __int16 v25 = 2048;
    uint64_t v26 = 0LL;
    _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_FAULT,  "AssertMacros: %{public}s, %{public}s file: %{public}s, line: %d, value: %ld",  (uint8_t *)&v17,  0x30u);
    return 0LL;
  }

  if (*result) {
    BOOL v8 = a2 == 0;
  }
  else {
    BOOL v8 = 1;
  }
  if (!v8)
  {
    unint64_t v9 = a2 - 1;
    do
    {
      uint64_t v10 = &result[v2];
      int v11 = v10[1];
      uint64_t result = v10 + 1;
      int v2 = v11;
      BOOL v13 = v9-- != 0;
    }

    while (v2 && v13);
  }

  return result;
}

uint64_t domain_name_label_canonical_compare(unsigned __int8 *a1, unsigned __int8 *a2, int a3)
{
  unsigned int v4 = *a1;
  unsigned int v5 = *a2;
  if (a3 && v4 != v5) {
    return 2LL;
  }
  if (v4 >= v5) {
    uint64_t v7 = *a2;
  }
  else {
    uint64_t v7 = *a1;
  }
  if ((_DWORD)v7)
  {
    LODWORD(result) = 0;
    BOOL v8 = a1 + 1;
    unint64_t v9 = a2 + 1;
    while (1)
    {
      unsigned int v11 = *v8++;
      unsigned int v10 = v11;
      unsigned int v12 = v11 + 32;
      if (v11 - 65 < 0x1A) {
        unsigned int v10 = v12;
      }
      unsigned int v14 = *v9++;
      unsigned int v13 = v14;
      unsigned int v15 = v14 + 32;
      if (v14 - 65 < 0x1A) {
        unsigned int v13 = v15;
      }
      BOOL v16 = v10 >= v13;
      BOOL v17 = v10 == v13;
      unsigned int v18 = v10 > v13 ? 1 : result;
      uint64_t result = v16 ? v18 : 0xFFFFFFFFLL;
      if (!v17) {
        break;
      }
      if (!--v7) {
        goto LABEL_22;
      }
    }
  }

  else
  {
LABEL_22:
    BOOL v16 = v4 >= v5;
    BOOL v19 = v4 != v5;
    unsigned int v20 = v4 > v5;
    if (!v16) {
      unsigned int v20 = -1;
    }
    if ((v19 & a3) != 0) {
      return 2LL;
    }
    else {
      return v20;
    }
  }

  return result;
}

uint64_t domain_name_labels_canonical_compare(unsigned __int8 *a1, unsigned __int8 *a2, int a3)
{
  unsigned int v4 = a2;
  unsigned int v5 = a1;
  int v6 = *a1;
  uint64_t v7 = a1;
  if (*a1)
  {
    uint64_t v7 = a1;
    do
    {
      BOOL v8 = &v7[v6];
      int v9 = v8[1];
      uint64_t v7 = v8 + 1;
      int v6 = v9;
    }

    while (v9);
  }

  uint64_t v10 = v7 - a1;
  unint64_t v11 = v10 + 1;
  int v12 = *a2;
  unsigned int v13 = a2;
  if (*a2)
  {
    unsigned int v13 = a2;
    do
    {
      unsigned int v14 = &v13[v12];
      int v15 = v14[1];
      unsigned int v13 = v14 + 1;
      int v12 = v15;
    }

    while (v15);
  }

  LODWORD(result) = 3;
  if (v11 > 0x100) {
    goto LABEL_42;
  }
  uint64_t v17 = v13 - a2;
  unint64_t v18 = v13 - a2 + 1;
  if (v18 > 0x100) {
    goto LABEL_42;
  }
  if (v10 != v17 && (a3 & 1) != 0) {
    goto LABEL_11;
  }
  BOOL v19 = &v5[v11];
  unsigned int v20 = &a2[v18];
  bzero(v41, 0x800uLL);
  bzero(v40, 0x800uLL);
  if (v19 <= v5)
  {
    unsigned int v22 = 0;
  }

  else
  {
    int v21 = 0;
    do
    {
      v41[v21] = v5;
      unsigned int v22 = v21 + 1;
      v5 += *v5 + 1;
      ++v21;
    }

    while (v5 < v19);
  }

  if (v20 <= v4)
  {
    unsigned int v24 = 0;
    if ((a3 & 1) == 0) {
      goto LABEL_28;
    }
LABEL_23:
    if (v22 != v24)
    {
LABEL_11:
      LODWORD(result) = 2;
      goto LABEL_42;
    }

    if (v22)
    {
      uint64_t v25 = v22;
      uint64_t v26 = (unsigned __int8 **)v40;
      __int16 v27 = (unsigned __int8 **)v41;
      while (**v27 == **v26)
      {
        ++v26;
        ++v27;
        if (!--v25) {
          goto LABEL_28;
        }
      }

      goto LABEL_11;
    }

    goto LABEL_28;
  }

  int v23 = 0;
  do
  {
    v40[v23] = v4;
    unsigned int v24 = v23 + 1;
    v4 += *v4 + 1;
    ++v23;
  }

  while (v4 < v20);
  if ((a3 & 1) != 0) {
    goto LABEL_23;
  }
LABEL_28:
  uint64_t v28 = 0LL;
  uint64_t v29 = v22;
  uint64_t v30 = v24;
  __int16 v31 = &v40[v24 - 1];
  int v32 = &v41[v22 - 1];
  while (1)
  {
    uint64_t v33 = v30 + v28;
    int v34 = v29 + v28;
    if (!(v29 + v28) || !v33) {
      break;
    }
    LODWORD(result) = domain_name_label_canonical_compare((unsigned __int8 *)v32[v28], (unsigned __int8 *)v31[v28], a3);
    --v28;
    if ((_DWORD)result) {
      goto LABEL_42;
    }
  }

  int v35 = v34 | v33;
  if ((_DWORD)v33) {
    int v36 = 3;
  }
  else {
    int v36 = 1;
  }
  if (v34) {
    int v37 = v36;
  }
  else {
    int v37 = -1;
  }
  if (v35) {
    LODWORD(result) = v37;
  }
  else {
    LODWORD(result) = 0;
  }
LABEL_42:
  if ((_DWORD)result) {
    BOOL v38 = (_DWORD)result == 3;
  }
  else {
    BOOL v38 = 1;
  }
  int v39 = !v38;
  if ((v39 & a3) != 0) {
    return 2LL;
  }
  else {
    return result;
  }
}

uint64_t domain_name_labels_compute_hash(_BYTE *a1)
{
  int v1 = *a1;
  int v2 = a1;
  if (*a1)
  {
    int v2 = a1;
    do
    {
      unint64_t v3 = &v2[v1];
      int v4 = v3[1];
      int v2 = v3 + 1;
      int v1 = v4;
    }

    while (v4);
  }

  uint64_t v5 = 2166136261LL;
  uint64_t v6 = v2 - a1;
  if (v6 != -1)
  {
    uint64_t v7 = v6 + 1;
    do
    {
      int v9 = *a1++;
      int v8 = v9;
      int v10 = v9 + 32;
      uint64_t v5 = 16777619 * (v5 ^ v8);
      --v7;
    }

    while (v7);
  }

  return v5;
}

_BYTE *domain_name_labels_concatenate(_BYTE *__src, _BYTE *a2, char *__dst, int *a4)
{
  int v7 = *__src;
  int v8 = __src;
  if (*__src)
  {
    int v8 = __src;
    do
    {
      int v9 = &v8[v7];
      int v10 = v9[1];
      int v8 = v9 + 1;
      int v7 = v10;
    }

    while (v10);
  }

  uint64_t v11 = v8 - __src;
  int v12 = *a2;
  unsigned int v13 = a2;
  if (*a2)
  {
    unsigned int v13 = a2;
    do
    {
      unsigned int v14 = &v13[v12];
      int v15 = v14[1];
      unsigned int v13 = v14 + 1;
      int v12 = v15;
    }

    while (v15);
  }

  size_t v16 = v13 - a2 + 1;
  if (v16 + v11 > 0x100)
  {
    int v18 = -6751;
    if (!a4) {
      return __src;
    }
  }

  else
  {
    uint64_t v17 = v11 + 1;
    memcpy(__dst, __src, v11 + 1);
    char __src = memcpy(&__dst[v17 - 1], a2, v16);
    int v18 = 0;
    if (!a4) {
      return __src;
    }
  }

  *a4 = v18;
  return __src;
}

uint64_t IsEntitled(uint64_t a1)
{
  int v1 = (void *)xpc_connection_copy_entitlement_value(a1, "com.apple.mDNSResponder.log_utility");
  if (v1)
  {
    int v2 = v1;
    if (xpc_get_type(v1) == (xpc_type_t)&_xpc_type_BOOL && xpc_BOOL_get_value(v2))
    {
      xpc_release(v2);
      return 1LL;
    }

    xpc_release(v2);
  }

  else
  {
    int v4 = (os_log_s *)mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_16;
      }
      __int16 v17 = 0;
      uint64_t v6 = (uint8_t *)&v17;
    }

    else
    {
      int v4 = (os_log_s *)mDNSLogCategory_Default_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_16;
      }
      *(_WORD *)timespec buf = 0;
      uint64_t v6 = buf;
    }

    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "IsEntitled: Client Entitlement is NULL", v6, 2u);
  }

unsigned __int8 *base_x_encode(int a1, unsigned __int8 *a2, unint64_t a3, char *a4)
{
  uint64_t result = (unsigned __int8 *)base_x_get_encoded_string_length(a1, a3);
  int v9 = result;
  if (!a4)
  {
    uint64_t result = (unsigned __int8 *)malloc((size_t)(result + 1));
    a4 = (char *)result;
    if (!result)
    {
      __break(1u);
      return result;
    }
  }

  v9[(void)a4] = 0;
  switch(a1)
  {
    case 2:
      char v17 = 1;
      return base_32_hex_encode(a2, a3, v17, a4);
    case 1:
      char v17 = 0;
      return base_32_hex_encode(a2, a3, v17, a4);
    case 0:
      for (uint64_t i = &a2[a3]; a2 < i; a4 += 4)
      {
        int v18 = 0;
        unint64_t v11 = i - a2;
        if (i - a2 == 1)
        {
          unint64_t v15 = 0LL;
          unint64_t v13 = *a2 << 16;
          uint64_t v14 = 1LL;
        }

        else
        {
          if (v11 == 2)
          {
            unint64_t v12 = a2[1] << 8;
            unint64_t v13 = v12 | (*a2 << 16);
            uint64_t v14 = 2LL;
            unint64_t v15 = 3LL;
          }

          else
          {
            int v16 = a2[2];
            unint64_t v12 = v16 | (a2[1] << 8);
            unint64_t v13 = v12 | (*a2 << 16);
            if (v11 >= 3) {
              uint64_t v14 = 3LL;
            }
            else {
              uint64_t v14 = i - a2;
            }
            HIBYTE(v1_Block_object_dispose(va, 8) = b64_table[v16 & 0x3F];
            unint64_t v15 = 4LL;
          }

          BYTE2(v1_Block_object_dispose(va, 8) = b64_table[(v12 >> 6) & 0x3F];
        }

        BYTE1(v1_Block_object_dispose(va, 8) = b64_table[(v13 >> 12) & 0x3F];
        LOBYTE(v1_Block_object_dispose(va, 8) = b64_table[(unint64_t)v13 >> 18];
        if (v15)
        {
          if (v15 > 3) {
            goto LABEL_21;
          }
        }

        else
        {
          unint64_t v15 = 2LL;
        }

        uint64_t result = (unsigned __int8 *)memset((char *)&v18 + v15, 61, 4 - v15);
LABEL_21:
        a2 += v14;
        *(_DWORD *)a4 = v18;
      }

      break;
  }

  return result;
}

unint64_t base_x_get_encoded_string_length(int a1, unint64_t a2)
{
  if (a1 != 2)
  {
    if (a1 == 1)
    {
      if (a2 <= 0x1FFFFFFFFFFFFFFELL) {
        return (2 * (((a2 + 4) * (unsigned __int128)0xCCCCCCCCCCCCCCCDLL) >> 64)) & 0xFFFFFFFFFFFFFFF8LL;
      }
    }

    else if (!a1 && a2 <= 0x3FFFFFFFFFFFFFFELL)
    {
      return (2 * (((a2 + 2) * (unsigned __int128)0xAAAAAAAAAAAAAAABLL) >> 64)) & 0xFFFFFFFFFFFFFFFCLL;
    }

    return 0LL;
  }

  if (a2 > 0x1FFFFFFFFFFFFFFELL) {
    return 0LL;
  }
  unint64_t result = 8 * (a2 / 5);
  switch(a2 % 5)
  {
    case 0uLL:
      return result;
    case 1uLL:
      result |= 2uLL;
      break;
    case 2uLL:
      result |= 4uLL;
      break;
    case 3uLL:
      result |= 5uLL;
      break;
    case 4uLL:
      result |= 7uLL;
      break;
    default:
      return 0LL;
  }

  return result;
}

unsigned __int8 *base_32_hex_encode(unsigned __int8 *result, uint64_t a2, char a3, char *__dst)
{
  int v4 = &result[a2];
  if (&result[a2] > result)
  {
    int v7 = result;
    while (2)
    {
      uint64_t v22 = 0LL;
      unint64_t v8 = v4 - v7;
      uint64_t v9 = 0LL;
      switch(v4 - v7)
      {
        case 1LL:
          size_t v10 = 0LL;
          unsigned int v11 = *v7++;
          unint64_t v12 = (unint64_t)v11 << 32;
          goto LABEL_20;
        case 2LL:
          uint64_t v17 = 0LL;
          unint64_t v15 = (unint64_t)v7[1] << 24;
          unsigned int v18 = *v7;
          v7 += 2;
          unint64_t v12 = v15 | ((unint64_t)v18 << 32);
          goto LABEL_17;
        case 3LL:
          unsigned __int8 v19 = v7[2];
          unint64_t v15 = ((unint64_t)v19 << 16) | ((unint64_t)v7[1] << 24);
          unsigned int v20 = *v7;
          v7 += 3;
          unint64_t v12 = v15 | ((unint64_t)v20 << 32);
          BYTE4(v22) = b32_hex_table[2 * (v19 & 0xF)];
          uint64_t v17 = 5LL;
          goto LABEL_17;
        case 4LL:
          goto LABEL_6;
        default:
          uint64_t v9 = v7[4];
LABEL_6:
          unint64_t v13 = v7[3];
          unint64_t v14 = v9 | (v13 << 8);
          unint64_t v15 = ((unint64_t)v7[1] << 24) | ((unint64_t)v7[2] << 16) | v14;
          unint64_t v12 = v15 | ((unint64_t)*v7 << 32);
          if (v8 >= 5) {
            uint64_t v16 = 5LL;
          }
          else {
            uint64_t v16 = v4 - v7;
          }
          v7 += v16;
          if (v8 == 1)
          {
            size_t v10 = 0LL;
          }

          else
          {
            if (v8 == 4)
            {
              uint64_t v17 = 7LL;
            }

            else
            {
              HIBYTE(v22) = b32_hex_table[v9 & 0x1F];
              uint64_t v17 = 8LL;
            }

            char v21 = b32_hex_table[(v13 >> 2) & 0x1F];
            BYTE6(v22) = b32_hex_table[(v14 >> 5) & 0x1F];
            BYTE5(v22) = v21;
            BYTE4(v22) = b32_hex_table[(v15 >> 15) & 0x1F];
LABEL_17:
            BYTE3(v22) = b32_hex_table[(v15 >> 20) & 0x1F];
            BYTE2(v22) = b32_hex_table[(v15 >> 25) & 0x1F];
            if (v17) {
              size_t v10 = v17;
            }
            else {
              size_t v10 = 4LL;
            }
          }

uint64_t get_tlv_uint32(unsigned __int8 *a1, uint64_t a2, int a3, int *a4)
{
  do
  {
    int v4 = (unsigned __int16 *)a1;
    uint64_t result = 0LL;
    int v6 = -1;
    int v7 = (unsigned __int8 *)(v4 + 2);
    uint64_t v8 = __rev16(v4[1]);
    a1 = &v7[v8];
  }

  while (a3 != bswap32(*v4) >> 16);
  switch((_DWORD)v8)
  {
    case 4:
      int v6 = 0;
      uint64_t result = bswap32(*((_DWORD *)v4 + 1));
      break;
    case 2:
      int v6 = 0;
      uint64_t result = __rev16(v4[2]);
      break;
    case 1:
      int v6 = 0;
      uint64_t result = *v7;
      break;
    default:
LABEL_9:
      uint64_t result = 0LL;
      int v6 = -1;
      break;
  }

uint64_t _dns_push_obj_context_compare(uint64_t a1, uint64_t a2)
{
  return 2 * (a1 != a2);
}

void _dns_push_obj_context_finalize(void *a1)
{
  int v2 = (void *)a1[2];
  if (v2)
  {
    ref_count_obj_release(v2);
    a1[2] = 0LL;
  }

  unint64_t v3 = (void *)a1[3];
  if (v3)
  {
    ref_count_obj_release(v3);
    a1[3] = 0LL;
  }

  int v4 = (void *)a1[7];
  if (v4)
  {
    os_release(v4);
    a1[7] = 0LL;
  }

  if (a1[4])
  {
    uint64_t DNSServiceManager = Querier_GetDNSServiceManager();
    if (DNSServiceManager) {
      mdns_dns_service_manager_deregister_discovered_push_service(DNSServiceManager, a1[4]);
    }
  }

void dns_push_obj_context_set_interface_monitor(uint64_t a1, void *object)
{
  if (object) {
    os_retain(object);
  }
  int v4 = *(void **)(a1 + 56);
  if (v4) {
    os_release(v4);
  }
  *(void *)(a1 + 56) = object;
}

void __mdns_mach_ticks_per_second_block_invoke(id a1)
{
  kern_return_t v2;
  BOOL v3;
  os_log_s *v4;
  mach_timebase_info info;
  uint8_t buf[4];
  kern_return_t v7;
  __int16 v8;
  uint32_t numer;
  __int16 v10;
  uint32_t denom;
  unint64_t v1 = 1000000000LL;
  info = 0LL;
  int v2 = mach_timebase_info(&info);
  if (v2 || (info.numer ? (unint64_t v3 = info.denom == 0) : (unint64_t v3 = 1), v3))
  {
    if (_mdns_ticks_log_s_once != -1) {
      dispatch_once(&_mdns_ticks_log_s_once, &__block_literal_global_2);
    }
    int v4 = (os_log_s *)_mdns_ticks_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_ticks_log_s_log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)timespec buf = 67109632;
      int v7 = v2;
      uint64_t v8 = 1024;
      numer = info.numer;
      size_t v10 = 1024;
      denouint64_t m = info.denom;
      _os_log_error_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_ERROR,  "Unexpected results from mach_timebase_info: err %d numer %u denom %u",  buf,  0x14u);
    }
  }

  else
  {
    unint64_t v1 = 1000000000 * (unint64_t)info.denom / info.numer;
  }

  mdns_mach_ticks_per_second_s_ticks_per_second = v1;
}

void ___mdns_ticks_log_block_invoke(id a1)
{
  _mdns_ticks_log_s_log = (uint64_t)os_log_create("com.apple.mdns", "ticks");
}

unint64_t mdns_ticks_to_milliseconds(unint64_t a1)
{
  if (mdns_mach_ticks_per_second_s_once != -1) {
    dispatch_once(&mdns_mach_ticks_per_second_s_once, &__block_literal_global_3412);
  }
  return 1000 * (a1 % mdns_mach_ticks_per_second_s_ticks_per_second) / mdns_mach_ticks_per_second_s_ticks_per_second
       + 1000 * (a1 / mdns_mach_ticks_per_second_s_ticks_per_second);
}

uint64_t getLocalTimestampFromTimeval(uint64_t a1, char *a2)
{
  *(void *)uint64_t v8 = 0LL;
  uint64_t v9 = 0LL;
  int v10 = 0;
  __int16 v6 = 0;
  *(_DWORD *)uint64_t v5 = 0;
  localtime_r((const time_t *)a1, &v7);
  strftime(v8, 0x14uLL, "%F %T", &v7);
  strftime(v5, 6uLL, "%z", &v7);
  return snprintf(a2, 0x20uLL, "%s.%03u%s", v8, *(_DWORD *)(a1 + 8) / 1000, v5);
}

void EnumerateLocalRecords(uint64_t a1)
{
  CFMutableBagRef Mutable = CFSetCreateMutable(kCFAllocatorDefault, 0LL, (const CFSetCallBacks *)&mdns_domain_name_cf_set_callbacks);
  uint64_t v3 = pthread_mutex_lock((pthread_mutex_t *)(mDNSStorage[0] + 616));
  *(_DWORD *)(mDNSStorage[0] + 680) = mDNSPlatformRawTime(v3, v4, v5, v6, v7, v8, v9, v10);
  unsigned int v18 = (uint64_t **)xmmword_10015BD08;
  if (Mutable) {
    BOOL v19 = (void)xmmword_10015BD08 == 0LL;
  }
  else {
    BOOL v19 = 1;
  }
  if (!v19)
  {
    do
    {
      if (IsSubdomain((unsigned __int8 *)v18[5], "\x05local")
        && (((_BYTE)v18[1] & 0x32) != 0
         || IsSubdomain((unsigned __int8 *)v18[5], "\f_device-info\x04_tcp\x05local")))
      {
        unsigned int v20 = mdns_domain_name_create_with_labels(v18[5], 0LL);
        if (v20)
        {
          char v21 = v20;
          CFSetAddValue(Mutable, v20);
          os_release(v21);
        }
      }

      unsigned int v18 = (uint64_t **)*v18;
    }

    while (v18);
  }

  for (uint64_t i = 0LL; i != 499; ++i)
  {
    uint64_t v23 = mDNSStorage[i + 35];
    if (!v23) {
      continue;
    }
    do
    {
      unsigned int v24 = *(unsigned __int8 **)(v23 + 32);
      if (!v24) {
        goto LABEL_71;
      }
      uint64_t v25 = mdns_domain_name_create_with_labels(*(_BYTE **)(v23 + 32), 0LL);
      if (!v25) {
        goto LABEL_71;
      }
      uint64_t v26 = v25;
      if (Mutable && CFSetContainsValue(Mutable, v25)) {
        goto LABEL_70;
      }
      int v27 = IsSubdomain(*(unsigned __int8 **)(v23 + 32), "\f_device-info\x04_tcp\x05local");
      uint64_t v28 = *(uint64_t **)(v23 + 16);
      if (!v28) {
        goto LABEL_70;
      }
      LOBYTE(v29) = 0;
      uint64_t v30 = 0LL;
      int v31 = 0;
      do
      {
        int v32 = *((unsigned __int16 *)v28 + 6);
        if (v32 == 47) {
          goto LABEL_56;
        }
        uint64_t v33 = (_DWORD *)v28 + 33;
        if (v27)
        {
          if (v32 == 16)
          {
            uint64_t v34 = (uint64_t)(v28 + 1);
          }
        }

        if (!v30)
        {
          if (*v33 == 6)
          {
            if (*((unsigned __int8 *)v28 + 136) == 254)
            {
              BOOL v35 = (*((_BYTE *)v28 + 137) & 0xC0) == 128;
LABEL_38:
              int v29 = v35;
              goto LABEL_54;
            }
          }

          else
          {
            if (*v33 != 4) {
              goto LABEL_43;
            }
            if (*((unsigned __int8 *)v28 + 136) == 169)
            {
              BOOL v35 = *((unsigned __int8 *)v28 + 137) == 254;
              goto LABEL_38;
            }
          }

          goto LABEL_53;
        }

        if ((_BYTE)v29)
        {
          if (*v33 == 6)
          {
            if (*((unsigned __int8 *)v28 + 136) == 254 && (*((_BYTE *)v28 + 137) & 0xC0) == 0x80)
            {
LABEL_43:
              if ((_BYTE)v29) {
                BOOL v36 = 1;
              }
              else {
                BOOL v36 = v30 == 0LL;
              }
              if (!v36 && v27 == 0) {
                LOBYTE(v29) = 0;
              }
              int v31 = 1;
              goto LABEL_56;
            }
          }

          else if (*v33 == 4 && *((unsigned __int8 *)v28 + 136) == 169 && *((unsigned __int8 *)v28 + 137) == 254)
          {
            goto LABEL_43;
          }

void FlushRecordCache( unsigned __int8 *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = pthread_mutex_lock((pthread_mutex_t *)(mDNSStorage[0] + 616));
  *(_DWORD *)(mDNSStorage[0] + 680) = mDNSPlatformRawTime(v8, v9, v10, v11, v12, v13, v14, v15);
  mDNS_Lock_((unsigned int *)mDNSStorage, (uint64_t)"FlushRecordCache", 9341);
  for (uint64_t i = 0LL; i != 499; ++i)
  {
    for (uint64_t j = (void *)mDNSStorage[i + 35]; j; uint64_t j = (void *)*j)
    {
      unsigned int v18 = (_BYTE *)j[4];
      if (v18)
      {
        if (SameDomainNameBytes(v18, v27))
        {
          for (CFIndex k = (void *)j[2]; k; CFIndex k = (void *)*k)
            mDNS_PurgeCacheResourceRecord((unsigned int *)mDNSStorage, (uint64_t)k);
        }
      }
    }
  }

  mDNS_Unlock_((uint64_t)mDNSStorage, (uint64_t)"FlushRecordCache", 9352);
  KQueueUnlock((uint64_t)"FlushRecordCache", v20, v21, v22, v23, v24, v25, v26);
}

void NotifyOfElusiveBug( int a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *(void *)mDNSStorage;
  if (*(void *)mDNSStorage)
  {
    while (*(_DWORD *)(v8 + 6264) != 4 || *(_BYTE *)(v8 + 6268) != 17)
    {
      uint64_t v8 = *(void *)(v8 + 6384);
      if (!v8) {
        return;
      }
    }

    LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "NotifyOfElusiveBug: %s",  a4,  a5,  a6,  a7,  a8,  a1);
    LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "NotifyOfElusiveBug: %s",  v10,  v11,  v12,  v13,  v14,  a2);
    if (mDNSPlatformRawTime() <= 0x2BF1F)
    {
      uint64_t v15 = (os_log_s *)mDNSLogCategory_Default;
      int v16 = mDNSPlatformRawTime();
      LogMsgWithLevel( v15,  OS_LOG_TYPE_DEFAULT,  "Suppressing notification early in boot: %d",  v17,  v18,  v19,  v20,  v21,  v16);
    }
  }

void LogFatalError( char *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9)
{
}

void __mDNSDynamicStoreSetConfig_block_invoke(uint64_t a1)
{
  uint64_t v2 = pthread_mutex_lock((pthread_mutex_t *)(mDNSStorage[0] + 616));
  *(_DWORD *)(mDNSStorage[0] + 680) = mDNSPlatformRawTime(v2, v3, v4, v5, v6, v7, v8, v9);
  uint64_t v10 = CFWriteStreamCreateWithAllocatedBuffers(0LL, 0LL);
  int v16 = v10;
  if (!v10)
  {
    BOOL v36 = (os_log_s *)mDNSLogCategory_Default;
    int v37 = "mDNSDynamicStoreSetConfig : CFWriteStreamCreateWithAllocatedBuffers failed (Object creation failed)";
LABEL_8:
    LogMsgWithLevel(v36, OS_LOG_TYPE_DEFAULT, v37, v11, v12, v13, v14, v15, v65);
    uint64_t v22 = 0LL;
    goto LABEL_32;
  }

  CFWriteStreamOpen(v10);
  if (!CFPropertyListWrite(*(CFPropertyListRef *)(a1 + 32), v16, kCFPropertyListBinaryFormat_v1_0, 0LL, 0LL))
  {
    BOOL v36 = (os_log_s *)mDNSLogCategory_Default;
    int v37 = "mDNSDynamicStoreSetConfig : CFPropertyListWriteToStream failed (Could not write property list to stream)";
    goto LABEL_8;
  }

  uint64_t v22 = (const __CFData *)CFWriteStreamCopyProperty(v16, kCFStreamPropertyDataWritten);
  if (v22)
  {
    CFWriteStreamClose(v16);
    CFRelease(v16);
    BytePtr = CFDataGetBytePtr(v22);
    int v24 = *(_DWORD *)(a1 + 48);
    uint64_t v25 = *(const char **)(a1 + 40);
    CFIndex Length = CFDataGetLength(v22);
    int v32 = v24 - 1;
    CFIndex v33 = Length;
    int v34 = 0;
    CFArrayRef Copy = @"State:/Network/MulticastDNS";
    switch(v32)
    {
      case 0:
        goto LABEL_20;
      case 1:
        int v34 = 0;
        CFArrayRef Copy = @"State:/Network/DynamicDNS";
        goto LABEL_20;
      case 2:
        int v34 = 0;
        CFArrayRef Copy = @"State:/Network/PrivateDNS";
        goto LABEL_20;
      case 3:
        int v34 = 0;
        CFArrayRef Copy = @"State:/Network/BackToMyMac";
        goto LABEL_20;
      case 4:
        if (v25) {
          unsigned int v45 = v25;
        }
        else {
          unsigned int v45 = "";
        }
        CFMutableStringRef Mutable = CFStringCreateMutable(kCFAllocatorDefault, 0LL);
        CFStringAppend(Mutable, @"State:/Network/Interface/");
        CFStringAppendCString(Mutable, v45, 0x8000100u);
        CFStringAppend(Mutable, @"/SleepProxyServers");
        CFArrayRef Copy = CFStringCreateCopy(kCFAllocatorDefault, Mutable);
        if (Mutable) {
          CFRelease(Mutable);
        }
        int v34 = 1;
        goto LABEL_20;
      case 5:
        int v34 = 0;
        CFArrayRef Copy = @"State:/Network/mDNSResponder/DebugState";
LABEL_20:
        int v47 = CFDataCreateWithBytesNoCopy(0LL, BytePtr, v33, kCFAllocatorNull);
        if (v47)
        {
          uint64_t v53 = v47;
          CFPropertyListRef v54 = CFPropertyListCreateWithData(0LL, v47, 0LL, 0LL, 0LL);
          if (v54)
          {
            int v60 = v54;
            CFRelease(v53);
            SCDynamicStoreSetValue(0LL, Copy, v60);
            uint64_t v61 = (const __CFData *)v60;
          }

          else
          {
            LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "CFPropertyListCreateWithData of bytes failed",  v55,  v56,  v57,  v58,  v59,  v65);
            uint64_t v61 = v53;
          }

          CFRelease(v61);
        }

        else
        {
          LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "CFDataCreateWithBytesNoCopy of value failed",  v48,  v49,  v50,  v51,  v52,  v65);
        }

        if (Copy) {
          int v62 = v34;
        }
        else {
          int v62 = 0;
        }
        if (v62 == 1) {
          CFRelease(Copy);
        }
        break;
      default:
        LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "unrecognized key %d",  v27,  v28,  v29,  v30,  v31,  (int)@"State:/Network/MulticastDNS");
        break;
    }

    int v16 = 0LL;
  }

  else
  {
    LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "mDNSDynamicStoreSetConfig : CFWriteStreamCopyProperty failed (Object creation failed) ",  v17,  v18,  v19,  v20,  v21,  v65);
  }

void SetNetworkChanged(int a1)
{
  int v2 = dword_100158BC0;
  int v3 = dword_100158BF8;
  int v4 = dword_100158BF8 + a1;
  if (dword_100158BC0) {
    BOOL v5 = dword_100158BC0 - v4 < 1;
  }
  else {
    BOOL v5 = 0;
  }
  if (v5)
  {
    uint64_t v10 = mDNSLogCategory_State;
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    int v11 = 67109376;
    int v12 = v2 - v3;
    __int16 v13 = 1024;
    int v14 = a1;
    uint64_t v7 = "SetNetworkChanged: *NOT* increasing delay from %d to %d";
    uint64_t v8 = (os_log_s *)v10;
    uint32_t v9 = 14;
  }

  else
  {
    dword_100158BC0 = v4;
    uint64_t v6 = mDNSLogCategory_State;
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    int v11 = 67109120;
    int v12 = a1;
    uint64_t v7 = "SetNetworkChanged: Scheduling in %d ticks";
    uint64_t v8 = (os_log_s *)v6;
    uint32_t v9 = 8;
  }

  _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, v7, (uint8_t *)&v11, v9);
}

uint64_t CountProxyTargets( uint64_t a1, _DWORD *a2, _DWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10 = (uint64_t *)xmmword_10015BD08;
  if ((void)xmmword_10015BD08)
  {
    int v12 = 0;
    do
    {
      if (v10[4] == *(void *)(a1 + 6256) && *((_DWORD *)v10 + 36) == 4)
      {
        if (a2 && mDNS_LoggingEnabled) {
          LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "CountProxyTargets: fd %d %-7s IP%2d %.4a",  a4,  a5,  a6,  a7,  a8,  *(_DWORD *)(a1 + 6436));
        }
        ++v12;
      }

      uint64_t v10 = (uint64_t *)*v10;
    }

    while (v10);
    __int16 v13 = (uint64_t *)xmmword_10015BD08;
    if ((void)xmmword_10015BD08)
    {
      int v14 = 0;
      do
      {
        if (v13[4] == *(void *)(a1 + 6256) && *((_DWORD *)v13 + 36) == 6)
        {
          if (a3 && mDNS_LoggingEnabled) {
            LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "CountProxyTargets: fd %d %-7s IP%2d %.16a",  a4,  a5,  a6,  a7,  a8,  *(_DWORD *)(a1 + 6436));
          }
          ++v14;
        }

        __int16 v13 = (uint64_t *)*v13;
      }

      while (v13);
      if (a2) {
        goto LABEL_20;
      }
      goto LABEL_21;
    }
  }

  else
  {
    int v12 = 0;
  }

  int v14 = 0;
  if (a2) {
LABEL_20:
  }
    *a2 = v12;
LABEL_21:
  if (a3) {
    *a3 = v14;
  }
  return (v14 + v12);
}

uint64_t CloseBPF( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (mDNS_LoggingEnabled == 1) {
    LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "%s closing BPF fd %d",  a4,  a5,  a6,  a7,  a8,  a1 + 6310);
  }
  CFRunLoopRef Main = CFRunLoopGetMain();
  CFRunLoopRemoveSource(Main, *(CFRunLoopSourceRef *)(a1 + 6472), kCFRunLoopDefaultMode);
  uint64_t v10 = *(const void **)(a1 + 6472);
  if (v10)
  {
    CFRelease(v10);
    *(void *)(a1 + 6472) = 0LL;
  }

  CFSocketInvalidate(*(CFSocketRef *)(a1 + 6464));
  int v11 = *(const void **)(a1 + 6464);
  if (v11)
  {
    CFRelease(v11);
    *(void *)(a1 + 6464) = 0LL;
  }

  *(_DWORD *)(a1 + 6436) = -1;
  uint64_t result = *(unsigned int *)(a1 + 6440);
  if ((result & 0x80000000) == 0)
  {
    uint64_t result = close(result);
    *(_DWORD *)(a1 + 6440) = -1;
  }

  return result;
}

void __mDNSMacOSXNetworkChanged_block_invoke_2(id a1, int a2, int a3)
{
  if (a2 < 0)
  {
    uint64_t v19 = (os_log_s *)mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_ERROR)) {
        return;
      }
      LODWORD(buf.version) = 134217984;
      *(CFIndex *)((char *)&buf.version + 4) = a3;
    }

    else
    {
      uint64_t v19 = (os_log_s *)mDNSLogCategory_Default_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_ERROR)) {
        return;
      }
      LODWORD(buf.version) = 134217984;
      *(CFIndex *)((char *)&buf.version + 4) = a3;
    }

    _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "BPF request failed: %ld", (uint8_t *)&buf, 0xCu);
    return;
  }

  uint64_t v3 = *(void *)&a2;
  uint64_t v4 = pthread_mutex_lock((pthread_mutex_t *)(mDNSStorage[0] + 616));
  *(_DWORD *)(mDNSStorage[0] + 680) = mDNSPlatformRawTime(v4, v5, v6, v7, v8, v9, v10, v11);
  mDNS_Lock_((unsigned int *)mDNSStorage, (uint64_t)"mDNSPlatformReceiveBPF_fd", 3284);
  uint64_t v17 = *(void *)mDNSStorage[0];
  if (*(void *)mDNSStorage[0])
  {
    while (*(_DWORD *)(v17 + 6436) != -2)
    {
      uint64_t v17 = *(void *)(v17 + 6384);
      if (!v17) {
        goto LABEL_5;
      }
    }

    if (mDNS_LoggingEnabled == 1)
    {
      uint64_t v99 = v3;
      LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "%s using   BPF fd %d",  v12,  v13,  v14,  v15,  v16,  v17 + 6310);
    }

    int v114 = 0;
    if (ioctl(v3, 0x40044271uLL, &v114, v99) < 0)
    {
      uint64_t v27 = (os_log_s *)mDNSLogCategory_Default;
      uint64_t v28 = *__error();
      uint64_t v29 = __error();
      uint64_t v104 = v28;
      uint64_t v108 = (uint64_t)strerror(*v29);
      uint64_t v100 = v17 + 6310;
      LogMsgWithLevel( v27,  OS_LOG_TYPE_DEFAULT,  "mDNSPlatformReceiveBPF_fd: %d %s BIOCVERSION failed %d (%s)",  v30,  v31,  v32,  v33,  v34,  v3);
    }

    else if ((unsigned __int16)v114 != 1 || HIWORD(v114) != 1)
    {
      uint64_t v112 = (unsigned __int16)v114;
      uint64_t v113 = HIWORD(v114);
      uint64_t v104 = 1LL;
      uint64_t v108 = 1LL;
      uint64_t v100 = v17 + 6310;
      LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "mDNSPlatformReceiveBPF_fd: %d %s BIOCVERSION header %d.%d kernel %d.%d",  v21,  v22,  v23,  v24,  v25,  v3);
    }

    BOOL v35 = (_DWORD *)(v17 + 6444);
    if (ioctl(v3, 0x40044266uLL, v17 + 6444, v100, v104, v108, v112, v113) < 0)
    {
      BOOL v36 = (os_log_s *)mDNSLogCategory_Default;
      uint64_t v37 = *__error();
      uint64_t v38 = __error();
      uint64_t v105 = v37;
      int v109 = strerror(*v38);
      uint64_t v101 = v17 + 6310;
      LogMsgWithLevel( v36,  OS_LOG_TYPE_DEFAULT,  "mDNSPlatformReceiveBPF_fd: %d %s BIOCGBLEN failed %d (%s)",  v39,  v40,  v41,  v42,  v43,  v3);
    }

    if (*v35 >= 0x22F9u)
    {
      *BOOL v35 = 8952;
      if (ioctl(v3, 0xC0044266uLL, v17 + 6444) < 0)
      {
        uint64_t v49 = (os_log_s *)mDNSLogCategory_Default;
        uint64_t v50 = *__error();
        uint64_t v51 = __error();
        uint64_t v105 = v50;
        int v109 = strerror(*v51);
        uint64_t v101 = v17 + 6310;
        LogMsgWithLevel( v49,  OS_LOG_TYPE_DEFAULT,  "mDNSPlatformReceiveBPF_fd: %d %s BIOCSBLEN failed %d (%s)",  v52,  v53,  v54,  v55,  v56,  v3);
      }

      else if (mDNS_LoggingEnabled == 1)
      {
        uint64_t v101 = v17 + 6310;
        uint64_t v105 = *(unsigned int *)(v17 + 6444);
        LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "mDNSPlatformReceiveBPF_fd: %d %s BIOCSBLEN %d",  v44,  v45,  v46,  v47,  v48,  v3);
      }
    }

    if (ioctl(v3, 0x80044270uLL, &mDNSPlatformReceiveBPF_fd_opt_one, v101, v105, v109) < 0)
    {
      uint64_t v57 = (os_log_s *)mDNSLogCategory_Default;
      uint64_t v58 = *__error();
      uint64_t v59 = __error();
      uint64_t v106 = v58;
      uint64_t v110 = strerror(*v59);
      uint64_t v102 = v17 + 6310;
      LogMsgWithLevel( v57,  OS_LOG_TYPE_DEFAULT,  "mDNSPlatformReceiveBPF_fd: %d %s BIOCIMMEDIATE failed %d (%s)",  v60,  v61,  v62,  v63,  v64,  v3);
    }

    int v65 = fcntl(v3, 3, 0LL, v102, v106, v110);
    if (fcntl(v3, 4, v65 | 4u) < 0)
    {
      BOOL v66 = (os_log_s *)mDNSLogCategory_Default;
      uint64_t v67 = *__error();
      int v68 = __error();
      uint64_t v107 = v67;
      int v111 = strerror(*v68);
      uint64_t v103 = v17 + 6310;
      LogMsgWithLevel( v66,  OS_LOG_TYPE_DEFAULT,  "mDNSPlatformReceiveBPF_fd: %d %s O_NONBLOCK failed %d (%s)",  v69,  v70,  v71,  v72,  v73,  v3);
    }

    uint64_t v74 = 0LL;
    memset(v116, 0, sizeof(v116));
    while (1)
    {
      int v75 = *(unsigned __int8 *)(v17 + 6310 + v74);
      *((_BYTE *)v116 + v74) = v75;
      if (!v75) {
        break;
      }
      if (++v74 == 15)
      {
        HIBYTE(v116[0]) = 0;
        break;
      }
    }

    if (ioctl(v3, 0x8020426CuLL, v116, v103, v107, v111) < 0)
    {
      uint64_t v85 = (os_log_s *)mDNSLogCategory_Default;
      __error();
      int v86 = __error();
      strerror(*v86);
      LogMsgWithLevel( v85,  OS_LOG_TYPE_DEFAULT,  "mDNSPlatformReceiveBPF_fd: %d %s BIOCSETIF failed %d (%s)",  v87,  v88,  v89,  v90,  v91,  v3);
      *(_DWORD *)(v17 + 6436) = -3;
    }

    else
    {
      buf.version = 0LL;
      memset(&buf.retain, 0, 24);
      buf.info = (void *)v17;
      *(_DWORD *)(v17 + 6436) = v3;
      __int128 v76 = CFSocketCreateWithNative(kCFAllocatorDefault, v3, 1uLL, (CFSocketCallBack)bpf_callback, &buf);
      *(void *)(v17 + 6464) = v76;
      *(void *)(v17 + 6472) = CFSocketCreateRunLoopSource(kCFAllocatorDefault, v76, 0LL);
      CFRunLoopRef Main = CFRunLoopGetMain();
      CFRunLoopAddSource(Main, *(CFRunLoopSourceRef *)(v17 + 6472), kCFRunLoopDefaultMode);
      mDNSPlatformUpdateProxyList(*(void *)(v17 + 6256), v78, v79, v80, v81, v82, v83, v84);
    }
  }

  else
  {
LABEL_5:
    if (mDNS_LoggingEnabled == 1) {
      LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "mDNSPlatformReceiveBPF_fd: No Interfaces awaiting BPF fd %d; closing",
    }
        v12,
        v13,
        v14,
        v15,
        v16,
        v3);
    close(v3);
  }

  mDNS_Unlock_((uint64_t)mDNSStorage, (uint64_t)"mDNSPlatformReceiveBPF_fd", 3355);
  KQueueUnlock((uint64_t)"mDNSPlatformReceiveBPF_fd", v92, v93, v94, v95, v96, v97, v98);
}

void bpf_callback(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v6 = pthread_mutex_lock((pthread_mutex_t *)(mDNSStorage[0] + 616));
  *(_DWORD *)(mDNSStorage[0] + 680) = mDNSPlatformRawTime(v6, v7, v8, v9, v10, v11, v12, v13);
  int v21 = *(_DWORD *)(a5 + 6436);
  if ((v21 & 0x80000000) == 0)
  {
    ssize_t v22 = read(v21, (void *)(*(void *)(a5 + 6392) + 19952LL), *(unsigned int *)(a5 + 6444));
    if (v22 < 0)
    {
      uint64_t v80 = __error();
      int v86 = (os_log_s *)mDNSLogCategory_Default;
      if (*v80 == 35)
      {
        LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "bpf_callback got EAGAIN bailing",  v81,  v82,  v83,  v84,  v85,  v100);
      }

      else
      {
        __error();
        uint64_t v87 = __error();
        strerror(*v87);
        LogMsgWithLevel( v86,  OS_LOG_TYPE_DEFAULT,  "Closing %s BPF fd %d due to error %d (%s)",  v88,  v89,  v90,  v91,  v92,  a5 + 6310);
        CloseBPF(a5, v93, v94, v95, v96, v97, v98, v99);
      }
    }

    else
    {
      unint64_t v23 = *(void *)(a5 + 6392) + 19952LL;
      unint64_t v24 = v23 + v22;
      if (v23 < v23 + v22)
      {
        uint64_t v25 = (_OWORD *)((char *)v116 + 4);
        uint64_t v26 = (_OWORD *)((char *)v114 + 4);
        do
        {
          uint64_t v27 = *(void *)(a5 + 6392);
          uint64_t v28 = v23 + *(unsigned __int16 *)(v23 + 16);
          unint64_t v20 = v28 + *(unsigned int *)(v23 + 8);
          uint64_t v29 = *(void *)(a5 + 6256);
          uint64_t v30 = (_WORD *)(v28 + 14);
          v116[0] = 0LL;
          v116[1] = 0LL;
          int v117 = 0;
          v114[0] = 0LL;
          v114[1] = 0LL;
          int v115 = 0;
          if (v28 + 42 <= v20 && *(_WORD *)(v28 + 12) == 1544 && *v30 == 256 && *(_WORD *)(v28 + 16) == 8)
          {
            uint64_t v31 = v27 + 12664;
            do
            {
              uint64_t v31 = *(void *)v31;
              if (!v31) {
                goto LABEL_79;
              }
            }

            while (*(void *)(v31 + 6256) != v29);
            uint64_t v112 = v26;
            uint64_t v113 = v25;
            mDNS_Lock_((unsigned int *)v27, (uint64_t)"mDNSCoreReceiveRawARP", 17854);
            if (*(_WORD *)(v28 + 20) == 256)
            {
              uint64_t v32 = (_DWORD *)(v28 + 38);
              if (*(_DWORD *)(v28 + 28) != *(_DWORD *)(v28 + 38))
              {
                uint64_t v33 = *(void *)(v27 + 12624);
                if (v33)
                {
                  uint64_t v107 = (unsigned __int16 *)(v28 + 22);
                  uint64_t v103 = (_BYTE *)(v27 + 46976);
                  do
                  {
                    if (*(void *)(v33 + 32) != v29
                      || *(_BYTE *)(v33 + 8) == 1
                      || *(_DWORD *)(v33 + 144) != 4
                      || *(_DWORD *)(v33 + 148) != *v32)
                    {
                      goto LABEL_39;
                    }

                    int v34 = *v107;
                    if (v34 != *(unsigned __int16 *)(v33 + 132)
                      || *(unsigned __int16 *)(v28 + 24) != *(unsigned __int16 *)(v33 + 134)
                      || (BOOL v35 = "ARP Req from owner -- re-probing",
                          *(unsigned __int16 *)(v28 + 26) != *(unsigned __int16 *)(v33 + 136)))
                    {
                      BOOL v35 = "Ignoring  ARP Request from      ";
                      if (*(_BYTE *)(v33 + 191) != 4)
                      {
                        BOOL v35 = "Answering ARP Request from      ";
                        if (v34 == *(unsigned __int16 *)(v31 + 6304)
                          && *(unsigned __int16 *)(v28 + 24) == *(unsigned __int16 *)(v31 + 6306))
                        {
                          else {
                            BOOL v35 = "Answering ARP Request from      ";
                          }
                        }
                      }
                    }

                    int v109 = (char *)v35;
                    uint64_t v104 = (os_log_s *)mDNSLogCategory_Default;
                    GetRRDisplayString_rdb( (unsigned __int8 *)(v33 + 8),  (unsigned __int16 *)(*(void *)(v33 + 48) + 4LL),  v103);
                    LogMsgWithLevel( v104,  OS_LOG_TYPE_DEFAULT,  "Arp %-7s %s %.6a %.4a for %.4a -- H-MAC %.6a I-MAC %.6a %s",  v36,  v37,  v38,  v39,  v40,  v31 + 6310);
                    if (v109 == "ARP Req from owner -- re-probing")
                    {
                      if (*(unsigned __int8 *)(v33 + 189) <= 0x13u)
                      {
                        RestartARPProbing((_DWORD *)v27, v33);
                        goto LABEL_38;
                      }

                      uint64_t v32 = (_DWORD *)(v28 + 38);
                      if (mDNS_LoggingEnabled == 1)
                      {
                        uint64_t v47 = (os_log_s *)mDNSLogCategory_Default;
                        GetRRDisplayString_rdb( (unsigned __int8 *)(v33 + 8),  (unsigned __int16 *)(*(void *)(v33 + 48) + 4LL),  v103);
                        LogMsgWithLevel( v47,  OS_LOG_TYPE_DEFAULT,  "Reached maximum number of restarts for probing - %s",  v48,  v49,  v50,  v51,  v52,  (int)v103);
                        goto LABEL_38;
                      }
                    }

                    else
                    {
                      if (v109 == "Creating Local ARP Cache entry  ")
                      {
                        mDNSPlatformSetLocalAddressCacheEntry( (int *)(v33 + 144),  (const void *)(v33 + 132),  v29,  v41,  v42,  v43,  v44,  v45,  v101);
                        goto LABEL_38;
                      }

                      uint64_t v32 = (_DWORD *)(v28 + 38);
                      if (v109 == "Answering ARP Request from      ")
                      {
                        int v46 = *(_DWORD *)(v28 + 38);
                        int v118 = *(_DWORD *)(v28 + 28);
                        v119[0] = v46;
                        SendARP(v27, 2, v33, (uint64_t)v119, (uint64_t)v107, (uint64_t)&v118, (uint64_t)v107);
LABEL_38:
                        uint64_t v32 = (_DWORD *)(v28 + 38);
                      }
                    }

LABEL_93:
            mDNS_Unlock_(v27, (uint64_t)"mDNSCoreReceiveRawARP", 17941);
            uint64_t v25 = v113;
            uint64_t v26 = v112;
          }

          else if (v28 + 34 > v20 {
                 || *(_WORD *)(v28 + 12) != 8
          }
                 || (*(_BYTE *)(v28 + 20) & 0x1F) != 0
                 || *(_BYTE *)(v28 + 21))
          {
            uint64_t v19 = (int8x8_t *)(v28 + 54);
            if (v28 + 54 <= v20 && *(unsigned __int16 *)(v28 + 12) == 56710)
            {
              LODWORD(v116[0]) = 6;
              _OWORD *v25 = *(_OWORD *)(v28 + 22);
              LODWORD(v114[0]) = 6;
              _OWORD *v26 = *(_OWORD *)(v28 + 38);
              uint64_t v17 = *(unsigned __int8 *)(v28 + 20);
              uint64_t v77 = 24LL;
              if ((_DWORD)v17 != 58) {
                uint64_t v77 = 0LL;
              }
              if ((_DWORD)v17 == 17) {
                uint64_t v77 = 8LL;
              }
              if ((_DWORD)v17 == 6) {
                uint64_t v77 = 20LL;
              }
              if ((_DWORD)v17 == 1) {
                uint64_t v77 = 4LL;
              }
              if ((unint64_t)v19 + v77 <= v20) {
                mDNSCoreReceiveRawTransportPacket( v27,  (unsigned __int16 *)(v28 + 6),  v116,  v114,  v17,  v28,  v19,  v20,  v29,  bswap32(*(unsigned __int16 *)(v28 + 18)) >> 16);
              }
            }
          }

          else
          {
            uint64_t v19 = (int8x8_t *)&v30[2 * (*(_BYTE *)(v28 + 14) & 0xF)];
            uint64_t v78 = (char *)v30 + (bswap32(*(unsigned __int16 *)(v28 + 16)) >> 16);
            LODWORD(v116[0]) = 4;
            HIDWORD(v116[0]) = *(_DWORD *)(v28 + 26);
            LODWORD(v114[0]) = 4;
            HIDWORD(v114[0]) = *(_DWORD *)(v28 + 30);
            uint64_t v17 = *(unsigned __int8 *)(v28 + 23);
            uint64_t v79 = 24LL;
            if ((_DWORD)v17 != 58) {
              uint64_t v79 = 0LL;
            }
            if ((_DWORD)v17 == 17) {
              uint64_t v79 = 8LL;
            }
            if ((_DWORD)v17 == 6) {
              uint64_t v79 = 20LL;
            }
            if ((_DWORD)v17 == 1) {
              uint64_t v79 = 4LL;
            }
            if (v20 >= (unint64_t)v19 + v79) {
              mDNSCoreReceiveRawTransportPacket( v27,  (unsigned __int16 *)(v28 + 6),  v116,  v114,  v17,  v28,  v19,  v20,  v29,  0);
            }
          }

      if (_os_feature_enabled_impl("mDNSResponder", "unicast_assist_cache"))
      {
        while (1)
        {
          uint64_t v63 = (uint64_t **)s_interface_head_0;
          s_interface_head_0 = *(void *)s_interface_head_0;
          _unicast_assist_cache_free_interface(v63);
        }
      }

      goto LABEL_145;
    case 29:
      uint64_t v38 = mDNSLogCategory_Default;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_145;
        }
        LOWORD(v82) = 0;
        uint64_t v27 = "Sending SIGINFO to mDNSResponder daemon is deprecated. To trigger state dump, please use 'dns-sd -O', ente"
              "r 'dns-sd -h' for more information";
        goto LABEL_126;
      }

      uint64_t v38 = mDNSLogCategory_Default_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v82) = 0;
        uint64_t v27 = "Sending SIGINFO to mDNSResponder daemon is deprecated. To trigger state dump, please use 'dns-sd -O', ente"
              "r 'dns-sd -h' for more information";
        goto LABEL_126;
      }

      goto LABEL_145;
    case 30:
      mDNS_LoggingEnabled = 1;
      uint64_t v40 = (os_log_s *)mDNSLogCategory_Default;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
      {
        uint64_t v65 = os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT);
        if (!v65) {
          goto LABEL_101;
        }
        uint64_t v82 = 136446210;
        uint64_t v83 = "Enabled";
        goto LABEL_100;
      }

      uint64_t v40 = (os_log_s *)mDNSLogCategory_Default_redacted;
      uint64_t v65 = os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT);
      if (v65)
      {
        uint64_t v82 = 136446210;
        uint64_t v83 = "Enabled";
LABEL_100:
        _os_log_impl( (void *)&_mh_execute_header,  v40,  OS_LOG_TYPE_DEFAULT,  "SIGUSR1: Logging %{public}s on Apple Platforms",  (uint8_t *)&v82,  0xCu);
      }

void mDNSPlatformUpdateProxyList( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = *(void *)mDNSStorage[0];
  if (!*(void *)mDNSStorage[0])
  {
LABEL_5:
    LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "mDNSPlatformUpdateProxyList: ERROR InterfaceID %p not found",  a4,  a5,  a6,  a7,  a8,  a1);
    return;
  }

  while (*(void *)(v9 + 6256) != a1 || (*(_DWORD *)(v9 + 6436) & 0x80000000) != 0)
  {
    uint64_t v9 = *(void *)(v9 + 6384);
    if (!v9) {
      goto LABEL_5;
    }
  }

  unsigned int v95 = 0;
  unsigned int v94 = 0;
  int v10 = CountProxyTargets(v9, &v95, &v94, a4, a5, a6, a7, a8);
  uint64_t v16 = v95;
  uint64_t v17 = v94;
  if (v10 >= 251)
  {
    uint64_t v86 = v94;
    LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "mDNSPlatformUpdateProxyList: ERROR Too many address proxy records v4 %d v6 %d",  v11,  v12,  v13,  v14,  v15,  v95);
    uint64_t v16 = v95;
    if ((int)v95 >= 251)
    {
      uint64_t v16 = 250LL;
      unsigned int v95 = 250;
    }

    uint64_t v17 = (250 - v16);
    unsigned int v94 = 250 - v16;
  }

  uint64_t v18 = &unk_100158000;
  if (mDNS_LoggingEnabled == 1)
  {
    uint64_t v88 = (_OWORD *)v16;
    uint64_t v89 = v17;
    uint64_t v86 = v9 + 6310;
    uint64_t v87 = (char *)(v9 + 6304);
    LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "mDNSPlatformUpdateProxyList: fd %d %-7s MAC  %.6a %d v4 %d v6",  v11,  v12,  v13,  v14,  v15,  *(_DWORD *)(v9 + 6436));
    LODWORD(v16) = v95;
    LODWORD(v17) = v94;
  }

  uint64_t v92 = 0LL;
  uint64_t v93 = 0LL;
  if (v16 | v17)
  {
    uint64_t v19 = qword_10014BCDC;
    unint64_t v20 = &qword_10014BCDC[(int)v16];
    int v21 = &v20[(int)v17];
    ssize_t v22 = v21 + 2;
    byte_10014BCB7 = ((_DWORD)v21 + 16 - &mDNSPlatformUpdateProxyList_filter - 40) >> 3;
    byte_10014BCC7 = v16 + 3;
    unint64_t v23 = (uint64_t *)xmmword_10015BD08;
    if ((void)xmmword_10015BD08)
    {
      uint64_t v19 = qword_10014BCDC;
      do
      {
        if (v23[4] == a1 && *((_DWORD *)v23 + 36) == 4)
        {
          unsigned int v24 = *((_DWORD *)v23 + 37);
          *(_WORD *)uint64_t v19 = 21;
          *((_WORD *)v19 + 1) = (((_DWORD)v22 - (_DWORD)v19) >> 3);
          *((_DWORD *)v19++ + 1) = bswap32(v24);
        }

        unint64_t v23 = (uint64_t *)*v23;
      }

      while (v23);
    }

    *uint64_t v19 = 6LL;
    if (v19 != v20)
    {
      uint64_t v86 = (uint64_t)(v20 + 1);
      LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "mDNSPlatformUpdateProxyList: pc %p != chk6 %p",  v11,  v12,  v13,  v14,  v15,  (_DWORD)v19 + 8);
    }

    uint64_t v25 = v19 + 2;
    v19[1] = 0x3200000020LL;
    int v26 = *(_DWORD *)(v9 + 6440);
    if ((v26 & 0x80000000) == 0) {
      close(v26);
    }
    uint64_t v27 = v21 + 7;
    *(_DWORD *)(v9 + 6440) = socket(30, 2, 0);
    uint64_t v33 = (uint64_t *)xmmword_10015BD08;
    if ((void)xmmword_10015BD08)
    {
      int v34 = (_DWORD)v21 + 48;
      do
      {
        if (v33[4] == a1 && *((_DWORD *)v33 + 36) == 6)
        {
          *(_WORD *)uint64_t v25 = 21;
          *((_BYTE *)v25 + 2) = (v34 - (_DWORD)v25) >> 3;
          *((_BYTE *)v25 + 3) = 0;
          *((_DWORD *)v25 + 1) = bswap32(*((_DWORD *)v33 + 40));
          unsigned int v91 = *(_DWORD *)(v9 + 6424);
          __int128 v90 = NDP_prefix;
          *(_WORD *)((char *)&v90 + 13) = *(_WORD *)((char *)v33 + 161);
          HIBYTE(v90) = *((_BYTE *)v33 + 163);
          int v35 = setsockopt(*(_DWORD *)(v9 + 6440), 41, 13, &v90, 0x14u);
          if (v35 < 0)
          {
            int v36 = v35;
            if (*__error() != 49)
            {
              uint64_t v37 = mDNSLogCategory_Default;
              uint64_t v38 = *__error();
              uint64_t v39 = __error();
              uint64_t v40 = strerror(*v39);
              uint64_t v89 = v91;
              uint64_t v87 = v40;
              uint64_t v88 = &v90;
              uint64_t v86 = v38;
              uint64_t v41 = (os_log_s *)v37;
              uint64_t v18 = (_BYTE *)&unk_100158000;
              LogMsgWithLevel( v41,  OS_LOG_TYPE_DEFAULT,  "mDNSPlatformUpdateProxyList: IPV6_LEAVE_GROUP error %d errno %d (%s) group %.16a on %u",  v42,  v43,  v44,  v45,  v46,  v36);
            }
          }

          int v47 = setsockopt(*(_DWORD *)(v9 + 6440), 41, 12, &v90, 0x14u);
          if (v47 < 0)
          {
            int v48 = v47;
            if (*__error() != 48)
            {
              uint64_t v49 = mDNSLogCategory_Default;
              uint64_t v50 = *__error();
              uint64_t v51 = __error();
              uint64_t v52 = strerror(*v51);
              uint64_t v89 = v91;
              uint64_t v87 = v52;
              uint64_t v88 = &v90;
              uint64_t v86 = v50;
              uint64_t v53 = (os_log_s *)v49;
              uint64_t v18 = &unk_100158000;
              LogMsgWithLevel( v53,  OS_LOG_TYPE_DEFAULT,  "mDNSPlatformUpdateProxyList: IPV6_JOIN_GROUP error %d errno %d (%s) group %.16a on %u",  v54,  v55,  v56,  v57,  v58,  v48);
            }
          }

          if (v18[2840] == 1)
          {
            uint64_t v86 = (uint64_t)v33 + 148;
            LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "Joined IPv6 ND multicast group %.16a for %.16a",  v28,  v29,  v30,  v31,  v32,  (int)&v90);
          }

          ++v25;
        }

        uint64_t v33 = (uint64_t *)*v33;
      }

      while (v33);
    }

    if (v25 == v22)
    {
      *(_OWORD *)ssize_t v22 = xmmword_100100850;
      *((_OWORD *)v22 + 1) = xmmword_100100860;
      v22[4] = 22LL;
    }

    else
    {
      LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "mDNSPlatformUpdateProxyList: pc %p != fail %p",  v28,  v29,  v30,  v31,  v32,  (int)v25);
      uint64_t *v25 = 6LL;
      LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "mDNSPlatformUpdateProxyList: pc %p != ret4 %p",  v59,  v60,  v61,  v62,  v63,  (_DWORD)v25 + 8);
      *(_OWORD *)(v25 + 1) = xmmword_100100830;
      *(_OWORD *)(v25 + 3) = xmmword_100100840;
      uint64_t v86 = (uint64_t)v27;
      LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "mDNSPlatformUpdateProxyList: pc %p != ret6 %p",  v64,  v65,  v66,  v67,  v68,  (_DWORD)v25 + 40);
      uint64_t v27 = v25 + 5;
    }

    void *v27 = 0x5E00000006LL;
    LODWORD(v92) = (unint64_t)((char *)v25 - (char *)&mDNSPlatformUpdateProxyList_filter + 48) >> 3;
    uint64_t v93 = &mDNSPlatformUpdateProxyList_filter;
    int v71 = *(_DWORD *)(v9 + 6436);
    goto LABEL_54;
  }

  if (mDNS_LoggingEnabled == 1) {
    LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "mDNSPlatformUpdateProxyList: No need for filter",  v11,  v12,  v13,  v14,  v15,  v85);
  }
  if (!dword_100158BF8) {
    LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "mDNSPlatformUpdateProxyList: m->timenow == 0",  v11,  v12,  v13,  v14,  v15,  v85);
  }
  int v69 = *(_DWORD *)(v9 + 6440);
  if ((v69 & 0x80000000) == 0)
  {
    close(v69);
    *(_DWORD *)(v9 + 6440) = -1;
  }

  if (!dword_100158BC0)
  {
    int v70 = dword_100158BF8 + 2000;
    dword_100158BC0 = v70;
  }

  int v71 = *(_DWORD *)(v9 + 6436);
  if ((v71 & 0x80000000) == 0)
  {
    LODWORD(v92) = 1;
    uint64_t v93 = &mDNSPlatformUpdateProxyList_nullfilter;
LABEL_54:
    if (ioctl(v71, 0x8010427EuLL, &v92, v86, v87, v88, v89) < 0)
    {
      uint64_t v77 = (os_log_s *)mDNSLogCategory_Default;
      int v78 = v92;
      __error();
      uint64_t v79 = __error();
      strerror(*v79);
      LogMsgWithLevel( v77,  OS_LOG_TYPE_DEFAULT,  "mDNSPlatformUpdateProxyList: BIOCSETFNR(%d) failed %d (%s)",  v80,  v81,  v82,  v83,  v84,  v78);
    }

    else if (v18[2840] == 1)
    {
      LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "mDNSPlatformUpdateProxyList: BIOCSETFNR(%d) successful",  v72,  v73,  v74,  v75,  v76,  v92);
    }
  }

void __mDNSMacOSXNetworkChanged_block_invoke(id a1)
{
  mDNSMacOSXNetworkChanged_queue = (uint64_t)dispatch_queue_create("com.apple.mDNSResponder.bpf-queue", 0LL);
}

uint64_t CountMaskBits(int *a1)
{
  uint64_t v2 = 0LL;
  uint64_t result = 0LL;
  int v5 = *a1;
  uint64_t v4 = a1 + 1;
  uint64_t v6 = 16LL * (v5 == 6);
  uint64_t v7 = 4LL;
  if (v5 != 4) {
    uint64_t v7 = v6;
  }
  while (v2 != v7)
  {
    int v8 = *((char *)v4 + v2);
    if (v8 < 0)
    {
      do
      {
        uint64_t result = (result + 1);
        char v9 = 2 * v8;
        int v8 = (char)(2 * v8);
      }

      while (v9 < 0);
    }

    ++v2;
    if (v8) {
      return 0xFFFFFFFFLL;
    }
  }

  return result;
}

void mDNSGroupJoinOrLeave(int a1, uint64_t a2, int a3)
{
  __int128 v43 = 0u;
  __int128 v42 = 0u;
  __int128 v41 = 0u;
  __int128 v40 = 0u;
  __int128 v39 = 0u;
  __int128 v38 = 0u;
  memset(&v37[1], 0, 32);
  int v6 = *(_DWORD *)(a2 + 6424);
  v37[0] = v6;
  int v7 = *(unsigned __int16 *)(a2 + 6434);
  if (v7 != 30)
  {
    if (v7 != 2)
    {
      uint64_t v12 = mDNSLogCategory_Default;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_ERROR)) {
          return;
        }
        uint64_t v13 = "join";
        int v27 = 136446978;
        if (!a3) {
          uint64_t v13 = "leave";
        }
      }

      else
      {
        uint64_t v12 = mDNSLogCategory_Default_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_ERROR)) {
          return;
        }
        uint64_t v13 = "join";
        int v27 = 136446978;
        if (!a3) {
          uint64_t v13 = "leave";
        }
      }

      uint64_t v28 = v13;
      __int16 v29 = 2082;
      *(void *)uint64_t v30 = a2 + 6310;
      *(_WORD *)&v30[8] = 1024;
      *(_DWORD *)&v30[10] = v6;
      __int16 v31 = 1024;
      *(_DWORD *)uint64_t v32 = v7;
      ssize_t v22 = "Cannot %{public}s mcast group on %{public}s (%u) for unrecognized address family %d";
      unint64_t v23 = (os_log_s *)v12;
      uint32_t v24 = 34;
LABEL_54:
      _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, v22, (uint8_t *)&v27, v24);
      return;
    }

    LOWORD(v37[1]) = 528;
    v37[2] = -83885856;
    int v8 = (os_log_s *)mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
      {
        char v9 = "Join";
        int v27 = 136447234;
        if (!a3) {
          char v9 = "Leav";
        }
        goto LABEL_24;
      }
    }

    else
    {
      int v8 = (os_log_s *)mDNSLogCategory_Default_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
      {
        char v9 = "Join";
        int v27 = 136447234;
        if (!a3) {
          char v9 = "Leav";
        }
LABEL_24:
        uint64_t v28 = v9;
        __int16 v29 = 1042;
        *(_DWORD *)uint64_t v30 = 4;
        *(_WORD *)&v30[4] = 2098;
        *(void *)&v30[6] = &v37[2];
        __int16 v31 = 2082;
        *(void *)uint64_t v32 = a2 + 6310;
        *(_WORD *)&v32[8] = 1024;
        *(_DWORD *)&v32[10] = v6;
        _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "%{public}sing mcast group %{public, network:in_addr}.4P on %{public}s (%u)",  (uint8_t *)&v27,  0x2Cu);
      }
    }

    int v14 = 0;
    uint64_t v15 = "";
    goto LABEL_31;
  }

  LOWORD(v37[1]) = 7708;
  *(_OWORD *)&v37[3] = xmmword_1000FFEE8;
  int v10 = (os_log_s *)mDNSLogCategory_Default;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
  {
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v11 = "Join";
      int v27 = 136447234;
      if (!a3) {
        uint64_t v11 = "Leav";
      }
      goto LABEL_29;
    }
  }

  else
  {
    int v10 = (os_log_s *)mDNSLogCategory_Default_redacted;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v11 = "Join";
      int v27 = 136447234;
      if (!a3) {
        uint64_t v11 = "Leav";
      }
LABEL_29:
      uint64_t v28 = v11;
      __int16 v29 = 1042;
      *(_DWORD *)uint64_t v30 = 16;
      *(_WORD *)&v30[4] = 2098;
      *(void *)&v30[6] = &v37[3];
      __int16 v31 = 2082;
      *(void *)uint64_t v32 = a2 + 6310;
      *(_WORD *)&v32[8] = 1024;
      *(_DWORD *)&v32[10] = v6;
      _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "%{public}sing mcast group %{public, network:in6_addr}.16P on %{public}s (%u)",  (uint8_t *)&v27,  0x2Cu);
    }
  }

  int v14 = 41;
  uint64_t v15 = "V6";
LABEL_31:
  if (a3) {
    int v16 = 80;
  }
  else {
    int v16 = 81;
  }
  int v17 = setsockopt(a1, v14, v16, v37, 0x84u);
  if (v17)
  {
    if ((int v18 = v17, v19 = *__error(), a3) && v19 != 48 || !a3 && v19 != 49)
    {
      uint64_t v20 = mDNSLogCategory_Default;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_ERROR)) {
          return;
        }
        if (a3) {
          int v21 = "JOIN";
        }
        else {
          int v21 = "LEAVE";
        }
      }

      else
      {
        uint64_t v20 = mDNSLogCategory_Default_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_ERROR)) {
          return;
        }
        if (a3) {
          int v21 = "JOIN";
        }
        else {
          int v21 = "LEAVE";
        }
      }

      uint64_t v25 = strerror(v19);
      int v26 = *(_DWORD *)(a2 + 6424);
      int v27 = 136447746;
      uint64_t v28 = v15;
      __int16 v29 = 2082;
      *(void *)uint64_t v30 = v21;
      *(_WORD *)&v30[8] = 1024;
      *(_DWORD *)&v30[10] = v18;
      __int16 v31 = 1024;
      *(_DWORD *)uint64_t v32 = v19;
      *(_WORD *)&v32[4] = 2080;
      *(void *)&v32[6] = v25;
      __int16 v33 = 2082;
      uint64_t v34 = a2 + 6310;
      __int16 v35 = 1024;
      int v36 = v26;
      ssize_t v22 = "setsockopt - IPPROTO_IP%{public}s/MCAST_%{public}s_GROUP error %d errno %d (%s) on %{public}s (%u)";
      unint64_t v23 = (os_log_s *)v20;
      uint32_t v24 = 60;
      goto LABEL_54;
    }
  }

uint64_t getExtendedFlags(uint64_t a1)
{
  __int128 v22 = 0u;
  __int128 v23 = 0u;
  int v2 = socket(2, 2, 0);
  if (v2 < 0)
  {
    int v14 = (os_log_s *)mDNSLogCategory_Default;
    int v15 = *__error();
    int v16 = __error();
    strerror(*v16);
    LogMsgWithLevel( v14,  OS_LOG_TYPE_DEFAULT,  "getExtendedFlags: socket() call failed, errno = %d (%s)",  v17,  v18,  v19,  v20,  v21,  v15);
    return 0LL;
  }

  else
  {
    BYTE1(v23) = 2;
    if (!a1) {
      __break(1u);
    }
    int v3 = v2;
    uint64_t v4 = 0LL;
    while (1)
    {
      int v5 = *(unsigned __int8 *)(a1 + v4);
      *((_BYTE *)&v22 + v4) = v5;
      if (!v5) {
        break;
      }
      if (++v4 == 15)
      {
        HIBYTE(v22) = 0;
        break;
      }
    }

    if (ioctl(v2, 0xC020698EuLL, &v22) == -1)
    {
      int v6 = (os_log_s *)mDNSLogCategory_Default;
      __error();
      int v7 = __error();
      strerror(*v7);
      LogMsgWithLevel( v6,  OS_LOG_TYPE_DEFAULT,  "getExtendedFlags: SIOCGIFEFLAGS failed for %s, errno = %d (%s)",  v8,  v9,  v10,  v11,  v12,  a1);
      *(void *)&__int128 v23 = 0LL;
    }

    close(v3);
    return v23;
  }

CFIndex mDNSDomainLabelFromCFString(const __CFString *a1, _BYTE *a2)
{
  CFIndex usedBufLen = 0LL;
  v6.size_t length = CFStringGetLength(a1);
  v6.location = 0LL;
  CFIndex result = CFStringGetBytes(a1, v6, 0x8000100u, 0, 0, a2 + 1, 63LL, &usedBufLen);
  *a2 = usedBufLen;
  return result;
}

uint64_t CheckInterfaceSupport(uint64_t a1, const char *a2)
{
  int v3 = IOBSDNameMatching(kIOMainPortDefault, 0, (const char *)(a1 + 6310));
  io_service_t MatchingService = IOServiceGetMatchingService(kIOMainPortDefault, v3);
  if (!MatchingService) {
    return 0LL;
  }
  io_object_t v5 = MatchingService;
  CFRange v6 = CFStringCreateWithCString(0LL, a2, 0x8000100u);
  int v7 = RegistryEntrySearchCFPropertyAndIOObject(v5, v6, 0LL, 0LL);
  if (v6) {
    CFRelease(v6);
  }
  if (v7)
  {
    memset(v10, 0, sizeof(v10));
    IOObjectGetClass(v5, (char *)v10);
    uint64_t v8 = 0LL;
  }

  else
  {
    uint64_t v8 = 1LL;
  }

  IOObjectRelease(v5);
  return v8;
}

uint64_t RegistryEntrySearchCFPropertyAndIOObject( io_object_t a1, const __CFString *a2, void *a3, io_registry_entry_t *a4)
{
  io_registry_entry_t v7 = a1;
  IOObjectRetain(a1);
  while (1)
  {
    CFTypeRef CFProperty = IORegistryEntryCreateCFProperty(v7, a2, kCFAllocatorDefault, 0);
    if (CFProperty) {
      break;
    }
    io_registry_entry_t parent = 0;
    if (IORegistryEntryGetParentEntry(v7, "IOService", &parent)) {
      io_registry_entry_t parent = 0;
    }
    IOObjectRelease(v7);
    io_registry_entry_t v7 = parent;
    if (!parent) {
      return 3758097088LL;
    }
  }

  if (a3)
  {
    *a3 = CFProperty;
    if (a4)
    {
LABEL_9:
      uint64_t result = 0LL;
      *a4 = v7;
      return result;
    }
  }

  else
  {
    CFRelease(CFProperty);
    if (a4) {
      goto LABEL_9;
    }
  }

  IOObjectRelease(v7);
  return 0LL;
}

void mDNSPlatformSendRawPacket(void *__buf, uint64_t a2, uint64_t a3)
{
  if (!a3)
  {
    uint64_t v8 = mDNSLogCategory_NAT;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_NAT == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT, OS_LOG_TYPE_DEFAULT)) {
        return;
      }
      LOWORD(v23) = 0;
      io_registry_entry_t v7 = "mDNSPlatformSendRawPacket: No InterfaceID specified";
    }

    else
    {
      uint64_t v8 = mDNSLogCategory_NAT_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT_redacted, OS_LOG_TYPE_DEFAULT)) {
        return;
      }
      LOWORD(v23) = 0;
      io_registry_entry_t v7 = "mDNSPlatformSendRawPacket: No InterfaceID specified";
    }

    uint64_t v11 = (os_log_s *)v8;
    uint32_t v12 = 2;
LABEL_26:
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, v7, (uint8_t *)&v23, v12);
    return;
  }

  uint64_t v4 = *(void *)mDNSStorage;
  if (!*(void *)mDNSStorage)
  {
LABEL_6:
    uint64_t v5 = mDNSLogCategory_NAT;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_NAT == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT, OS_LOG_TYPE_DEFAULT)) {
        return;
      }
      int v23 = 134217984;
      *(void *)uint32_t v24 = a3;
      io_registry_entry_t v7 = "mDNSPlatformSendRawPacket: Invalid interface index %p";
    }

    else
    {
      uint64_t v5 = mDNSLogCategory_NAT_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT_redacted, OS_LOG_TYPE_DEFAULT)) {
        return;
      }
      int v23 = 134217984;
      *(void *)uint32_t v24 = a3;
      io_registry_entry_t v7 = "mDNSPlatformSendRawPacket: Invalid interface index %p";
    }

    uint64_t v11 = (os_log_s *)v5;
    uint32_t v12 = 12;
    goto LABEL_26;
  }

  while (!*(void *)(v4 + 6480) || *(_DWORD *)(v4 + 6424) != (_DWORD)a3)
  {
    uint64_t v4 = *(void *)(v4 + 6384);
    if (!v4) {
      goto LABEL_6;
    }
  }

  int v14 = *(_DWORD *)(v4 + 6436);
  if (v14 < 0)
  {
    uint64_t v16 = mDNSLogCategory_NAT;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_NAT == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT, OS_LOG_TYPE_DEFAULT)) {
        return;
      }
    }

    else
    {
      uint64_t v16 = mDNSLogCategory_NAT_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT_redacted, OS_LOG_TYPE_DEFAULT)) {
        return;
      }
    }

    int v23 = 136446466;
    *(void *)uint32_t v24 = v4 + 6310;
    *(_WORD *)&v24[8] = 1024;
    *(_DWORD *)uint64_t v25 = v14;
    io_registry_entry_t v7 = "mDNSPlatformSendRawPacket: %{public}s BPF_fd %d not ready";
    uint64_t v11 = (os_log_s *)v16;
    uint32_t v12 = 18;
    goto LABEL_26;
  }

  if (write(*(_DWORD *)(v4 + 6436), __buf, a2 - (void)__buf) < 0)
  {
    uint64_t v15 = mDNSLogCategory_NAT;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_NAT == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_NAT, OS_LOG_TYPE_DEFAULT))
      {
LABEL_44:
        int v19 = *(_DWORD *)(v4 + 6436);
        int v20 = *__error();
        uint64_t v21 = __error();
        __int128 v22 = strerror(*v21);
        int v23 = 67109634;
        *(_DWORD *)uint32_t v24 = v19;
        *(_WORD *)&v24[4] = 1024;
        *(_DWORD *)&v24[6] = v20;
        *(_WORD *)uint64_t v25 = 2082;
        *(void *)&v25[2] = v22;
        io_registry_entry_t v7 = "mDNSPlatformSendRawPacket: BPF write(%d) failed %d (%{public}s)";
        uint64_t v11 = (os_log_s *)v15;
        uint32_t v12 = 24;
        goto LABEL_26;
      }
    }

    else
    {
      uint64_t v15 = mDNSLogCategory_NAT_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_NAT_redacted, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_44;
      }
    }
  }

void mDNSPlatformSetLocalAddressCacheEntry( int *a1, const void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9)
{
  if (a3)
  {
    unsigned int v9 = a3;
    uint64_t v10 = *(void *)mDNSStorage[0];
    if (*(void *)mDNSStorage[0])
    {
      while (!*(void *)(v10 + 6480) || *(_DWORD *)(v10 + 6424) != (_DWORD)a3)
      {
        uint64_t v10 = *(void *)(v10 + 6384);
        if (!v10) {
          goto LABEL_6;
        }
      }

      if (mDNS_AddressIsLocalSubnet((uint64_t)mDNSStorage, a3, a1))
      {
        uint64_t v18 = *a1;
        if (mDNS_LoggingEnabled == 1) {
          LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "mDNSSetLocalAddressCacheEntry: Using XPC IPC calling out to Helper: ifindex is [%d] family is [%d]",  v13,  v14,  v15,  v16,  v17,  v9);
        }
        xpc_object_t v19 = xpc_dictionary_create(0LL, 0LL, 0LL);
        xpc_dictionary_set_uint64(v19, "HelperMode", 7uLL);
        xpc_dictionary_set_uint64(v19, "slace_ifindex", v9);
        xpc_dictionary_set_uint64(v19, "slace_family", v18);
        xpc_dictionary_set_data(v19, "slace_ip", a1 + 1, 0x10uLL);
        xpc_dictionary_set_data(v19, "slace_eth", a2, 6uLL);
        int v25 = SendDict_ToServer(v19);
        if (v19) {
          xpc_release(v19);
        }
        if (mDNS_LoggingEnabled == 1) {
          LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "mDNSSetLocalAddressCacheEntry: Using XPC IPC returning error_code %d",  v20,  v21,  v22,  v23,  v24,  v25);
        }
        if (v25)
        {
          LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "Set local address cache entry for %s %#a %.6a failed: %d",  v20,  v21,  v22,  v23,  v24,  v10 + 6310);
        }

        else if (mDNS_LoggingEnabled == 1)
        {
          LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "Set local address cache entry for %s %#a %.6a",  v20,  v21,  v22,  v23,  v24,  v10 + 6310);
        }
      }

      else if (mDNS_LoggingEnabled == 1)
      {
        LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "Don't need address cache entry for %s %#a %.6a",  v13,  v14,  v15,  v16,  v17,  v10 + 6310);
      }
    }

    else
    {
LABEL_6:
      LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "mDNSPlatformSetLocalAddressCacheEntry: Invalid interface index %p",  a4,  a5,  a6,  a7,  a8,  a3);
    }
  }

  else
  {
    LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "mDNSPlatformSetLocalAddressCacheEntry: No InterfaceID specified",  a4,  a5,  a6,  a7,  a8,  a9);
  }

void mDNSPlatformSendKeepalive( uint64_t a1, uint64_t a2, unsigned __int16 *a3, unsigned __int16 *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8 = a7;
  unsigned int v9 = a6;
  unsigned int v10 = a5;
  LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "mDNSPlatformSendKeepalive called\n",  (uint64_t)a4,  a5,  a6,  a7,  a8,  v30);
  uint64_t v20 = (const void *)(a1 + 4);
  uint64_t v21 = (const void *)(a2 + 4);
  uint64_t v22 = *a3;
  uint64_t v23 = *a4;
  if (mDNS_LoggingEnabled == 1) {
    LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "mDNSSendKeepalive: Using XPC IPC calling out to Helper: lport is[%d] rport is[%d] seq is[%d] ack is[%d] win is[%d]",  v15,  v16,  v17,  v18,  v19,  v22);
  }
  memset(v36, 0, sizeof(v36));
  __int128 v35 = 0u;
  memset(v33, 0, sizeof(v33));
  __int128 v32 = 0u;
  char v34 = 0;
  char v31 = 0;
  inet_ntop(30, v20, &v34, 0x2Eu);
  inet_ntop(30, v21, &v31, 0x2Eu);
  if (mDNS_LoggingEnabled == 1) {
    LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "mDNSSendKeepalive: Using XPC IPC calling out to Helper: sadd is %s, dadd is %s",  v24,  v25,  v26,  v27,  v28,  (int)&v34);
  }
  xpc_object_t v29 = xpc_dictionary_create(0LL, 0LL, 0LL);
  xpc_dictionary_set_uint64(v29, "HelperMode", 8uLL);
  xpc_dictionary_set_data(v29, "send_keepalive_sadd", v20, 0x10uLL);
  xpc_dictionary_set_data(v29, "send_keepalive_dadd", v21, 0x10uLL);
  xpc_dictionary_set_uint64(v29, "send_keepalive_lport", v22);
  xpc_dictionary_set_uint64(v29, "send_keepalive_rport", v23);
  xpc_dictionary_set_uint64(v29, "send_keepalive_seq", v10);
  xpc_dictionary_set_uint64(v29, "send_keepalive_ack", v9);
  xpc_dictionary_set_uint64(v29, "send_keepalive_win", v8);
  SendDict_ToServer(v29);
  if (v29) {
    xpc_release(v29);
  }
}

uint64_t GetRemoteMacinternal(int a1, _DWORD *a2, uint64_t a3)
{
  int v5 = 0;
  int v6 = 0;
  __int128 __src = 0uLL;
  while (1)
  {
    memset(v46, 0, sizeof(v46));
    bzero(__buf, 0x25CuLL);
    int v7 = socket(17, 3, 0);
    if (v7 < 0)
    {
      uint32_t v12 = __error();
      uint64_t v13 = *v12;
      uint64_t v14 = (os_log_s *)mDNSLogCategory_Default;
      int v15 = strerror(*v12);
      LogMsgWithLevel( v14,  OS_LOG_TYPE_DEFAULT,  "getMACAddress: Can not open the socket - %s",  v16,  v17,  v18,  v19,  v20,  v15);
      goto LABEL_24;
    }

    int v8 = v7;
    uint64_t v48 = 0x300000000LL;
    __buf[1] = 4357;
    int v50 = 6368;
    if (a1 == 2)
    {
      unsigned int v9 = 0LL;
      LOWORD(v46[0]) = 528;
      DWORD1(v46[0]) = *a2;
      *(_OWORD *)uint64_t v51 = v46[0];
      unsigned int v10 = (unsigned __int8 *)v46;
      uint64_t v11 = (int *)&v51[16];
    }

    else
    {
      unsigned int v10 = 0LL;
      if (a1 == 30)
      {
        LOWORD(v46[0]) = 7708;
        *(_OWORD *)((char *)v46 + _Block_object_dispose(va, 8) = *(_OWORD *)a2;
        *(_OWORD *)uint64_t v51 = v46[0];
        *(_OWORD *)&v51[12] = *(_OWORD *)((char *)v46 + 12);
        unsigned int v9 = (unsigned __int8 *)v46;
        uint64_t v11 = &v52;
      }

      else
      {
        unsigned int v9 = 0LL;
        uint64_t v11 = (int *)v51;
      }
    }

    *(_WORD *)uint64_t v11 = 4628;
    *(void *)((char *)v11 + 10) = 0LL;
    *(void *)((char *)v11 + 2) = 0LL;
    *((_WORD *)v11 + 9) = 0;
    __buf[0] = (char *)v11 - (char *)__buf + 20;
    if (write(v7, __buf, __buf[0]) < 0)
    {
      char v31 = __error();
      uint64_t v13 = *v31;
      __int128 v32 = (os_log_s *)mDNSLogCategory_Default;
      int v33 = strerror(*v31);
      LogMsgWithLevel( v32,  OS_LOG_TYPE_DEFAULT,  "getMACAddress: writing to routing socket: %s",  v34,  v35,  v36,  v37,  v38,  v33);
      close(v8);
LABEL_24:
      if ((_DWORD)v13 != -1) {
        return v13;
      }
      goto LABEL_36;
    }

    while (1)
    {
      ssize_t v21 = read(v8, __buf, 0x25CuLL);
      if (v21 < 1) {
        break;
      }
      if (v50 == 6368)
      {
        int v27 = v49;
        if (v27 == getpid()) {
          goto LABEL_16;
        }
      }
    }

    if (v21 < 0) {
      LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "getMACAddress: Read from routing socket failed",  v22,  v23,  v24,  v25,  v26,  v43);
    }
LABEL_16:
    uint64_t v28 = v51;
    if (a1 != 2)
    {
      uint64_t v28 = v10;
      unsigned int v9 = v51;
      if (a1 != 30)
      {
        __int128 v39 = (os_log_s *)mDNSLogCategory_Default;
        goto LABEL_28;
      }
    }

    xpc_object_t v29 = &v51[v51[0]];
    if (v29) {
      break;
    }
    __int128 v39 = (os_log_s *)mDNSLogCategory_Default;
LABEL_28:
    LogMsgWithLevel(v39, OS_LOG_TYPE_DEFAULT, "getMACAddress: sdl is NULL for family %d", v22, v23, v24, v25, v26, a1);
LABEL_35:
    close(v8);
LABEL_36:
    if (v5 == 2) {
      size_t v40 = 4LL;
    }
    else {
      size_t v40 = 16LL;
    }
    memcpy(a2, &__src, v40);
    ++v6;
    a1 = v5;
    if (v6 == 5) {
      return 0xFFFFFFFFLL;
    }
  }

  int v30 = v29[1];
  if (v30 == 30)
  {
    if (v9) {
      __int128 __src = *(_OWORD *)&v9[*v9 + 8];
    }
    else {
      LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "getMACAddress: sin6 is NULL",  v22,  v23,  v24,  v25,  v26,  v43);
    }
    int v5 = 30;
    goto LABEL_35;
  }

  if (v30 == 2)
  {
    if (v28) {
      LODWORD(__src) = *(_DWORD *)&v28[*v28 + 4];
    }
    else {
      LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "getMACAddress: sin is NULL",  v22,  v23,  v24,  v25,  v26,  v43);
    }
    int v5 = 2;
    goto LABEL_35;
  }

  __int128 v42 = &v29[v29[5]];
  *(_DWORD *)a3 = *((_DWORD *)v42 + 2);
  *(_WORD *)(a3 + 4) = *((_WORD *)v42 + 6);
  close(v8);
  return 0LL;
}

void mDNSPlatformGetRemoteMacAddr(int *a1)
{
  int v2 = *a1;
  int v3 = (os_log_s *)mDNSLogCategory_NAT;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_NAT == mDNSLogCategory_State)
  {
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_11;
    }
    *(_WORD *)CFSocketContext buf = 0;
  }

  else
  {
    int v3 = (os_log_s *)mDNSLogCategory_NAT_redacted;
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT_redacted, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_11;
    }
    *(_WORD *)CFSocketContext buf = 0;
  }

  _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEFAULT,  "mDNSPlatformGetRemoteMacAddr calling mDNSGet_RemoteMAC",  buf,  2u);
LABEL_11:
  if (v2 == 4) {
    int v6 = 2;
  }
  else {
    int v6 = 30;
  }
  int v20 = 0;
  __int16 v21 = 0;
  __int128 v27 = *(_OWORD *)(a1 + 1);
  if (!GetRemoteMacinternal(v6, &v27, (uint64_t)&v20))
  {
    int v7 = (char *)calloc(1uLL, 0x28uLL);
    if (!v7) {
      __break(1u);
    }
    int v8 = v7;
    unsigned int v9 = a1 + 1;
    unint64_t v10 = (unint64_t)(v7 + 20);
    snprintf( v7 + 20,  0x12uLL,  "%02x:%02x:%02x:%02x:%02x:%02x",  v20,  BYTE1(v20),  BYTE2(v20),  HIBYTE(v20),  v21,  HIBYTE(v21));
    if (v2 == 4) {
      int v11 = 4;
    }
    else {
      int v11 = 6;
    }
    *(_DWORD *)int v8 = v11;
    *(_OWORD *)(v8 + 4) = *v9;
    uint64_t v12 = xmmword_10015BD08;
    for (*((void *)&xmmword_10015BD18 + 1) = xmmword_10015BD08; v12; *((void *)&xmmword_10015BD18 + 1) = v12)
    {
      if (!*(_DWORD *)(v12 + 126) && *(_WORD *)(v12 + 12) == 10)
      {
        uint64_t v13 = *(_BYTE **)(v12 + 40);
        if (*v13) {
          uint64_t v14 = *v13 + 1LL;
        }
        else {
          uint64_t v14 = 0LL;
        }
        if (SameDomainLabelPointer(&v13[v14], "\n_keepalive"))
        {
          *(void *)CFSocketContext buf = 0LL;
          uint64_t v25 = 0LL;
          int v26 = 0;
          getKeepaliveRaddr((uint64_t)mDNSStorage, v12, (uint64_t)buf);
          if (mDNSSameAddress((int *)buf, v8))
          {
            unsigned __int16 v23 = 0;
            int v22 = 0;
            if (GetValueForMACAddr(v10, (unint64_t)(v8 + 38), (uint64_t)&v22, v15, v16, v17, v18, v19))
            {
            }
          }
        }
      }

      uint64_t v12 = *(void *)v12;
    }

    free(v8);
  }

uint64_t mDNSPlatformRetrieveTCPInfo(uint64_t a1, __int16 a2, uint64_t a3, __int16 a4, uint64_t a5)
{
  uint64_t v52 = 0LL;
  __int128 v50 = 0u;
  __int128 v51 = 0u;
  __int128 v48 = 0u;
  __int128 v49 = 0u;
  __int128 v46 = 0u;
  __int128 v47 = 0u;
  __int128 v44 = 0u;
  __int128 v45 = 0u;
  __int128 v42 = 0u;
  __int128 v43 = 0u;
  __int128 v40 = 0u;
  __int128 v41 = 0u;
  __int128 v38 = 0u;
  __int128 v39 = 0u;
  __int128 v36 = 0u;
  __int128 v37 = 0u;
  __int128 v34 = 0u;
  __int128 v35 = 0u;
  __int128 v32 = 0u;
  __int128 v33 = 0u;
  __int128 v30 = 0u;
  __int128 v31 = 0u;
  __int128 v29 = 0u;
  memset(v28, 0, sizeof(v28));
  if (*(_DWORD *)a1 == 6)
  {
    memset(v53, 0, 60);
    WORD2(v53[0]) = 7708;
    WORD3(v53[0]) = a2;
    *(_OWORD *)((char *)v53 + 12) = *(_OWORD *)(a1 + 4);
    LOWORD(v53[2]) = 7708;
    WORD1(v53[2]) = a4;
    *(_OWORD *)((char *)&v53[2] + _Block_object_dispose(va, 8) = *(_OWORD *)(a3 + 4);
    uint64_t info = _mdns_tcpinfo_get_info(v53, v28);
    if (_mdns_tcpinfo_log_s_once != -1) {
      dispatch_once(&_mdns_tcpinfo_log_s_once, &__block_literal_global_7384);
    }
    uint64_t v22 = _mdns_tcpinfo_log_s_log;
    if ((_DWORD)info) {
      os_log_type_t v23 = OS_LOG_TYPE_ERROR;
    }
    else {
      os_log_type_t v23 = OS_LOG_TYPE_INFO;
    }
    if (!os_log_type_enabled((os_log_t)_mdns_tcpinfo_log_s_log, v23)) {
      goto LABEL_18;
    }
    *(_DWORD *)CFSocketContext buf = 68159234;
    int v55 = 16;
    __int16 v56 = 2096;
    *(void *)uint64_t v57 = (unint64_t)v53 | 0xC;
    *(_WORD *)&v57[8] = 1024;
    *(_DWORD *)uint64_t v58 = bswap32(WORD3(v53[0])) >> 16;
    *(_WORD *)&v58[4] = 1040;
    *(_DWORD *)uint64_t v59 = 16;
    *(_WORD *)&v59[4] = 2096;
    *(void *)&v59[6] = (char *)&v53[2] + 8;
    __int16 v60 = 1024;
    unsigned int v61 = bswap32(WORD1(v53[2])) >> 16;
    __int16 v62 = 2048;
    uint64_t v63 = (int)info;
    uint64_t v18 = "TCP info get -- local: %{network:in6_addr}.16P.%d, remote: %{network:in6_addr}.16P.%d, error: %{mdns:err}ld";
    uint64_t v19 = (os_log_s *)v22;
    os_log_type_t v20 = v23;
    uint32_t v21 = 56;
    goto LABEL_17;
  }

  if (*(_DWORD *)a1 != 4) {
    return 4294901747LL;
  }
  int v6 = *(_DWORD *)(a1 + 4);
  unsigned int v7 = *(_DWORD *)(a3 + 4);
  *(_OWORD *)((char *)&v53[2] + 12) = 0uLL;
  memset(v53, 0, 32);
  WORD2(v53[0]) = 528;
  WORD3(v53[0]) = a2;
  DWORD2(v53[0]) = v6;
  LOWORD(v53[2]) = 528;
  WORD1(v53[2]) = a4;
  *(void *)((char *)&v53[2] + 4) = v7;
  uint64_t info = _mdns_tcpinfo_get_info(v53, v28);
  if (_mdns_tcpinfo_log_s_once != -1) {
    dispatch_once(&_mdns_tcpinfo_log_s_once, &__block_literal_global_7384);
  }
  uint64_t v9 = _mdns_tcpinfo_log_s_log;
  if ((_DWORD)info) {
    os_log_type_t v10 = OS_LOG_TYPE_ERROR;
  }
  else {
    os_log_type_t v10 = OS_LOG_TYPE_INFO;
  }
  if (os_log_type_enabled((os_log_t)_mdns_tcpinfo_log_s_log, v10))
  {
    *(_DWORD *)CFSocketContext buf = 67110144;
    int v55 = DWORD2(v53[0]);
    __int16 v56 = 1024;
    *(_DWORD *)uint64_t v57 = bswap32(WORD3(v53[0])) >> 16;
    *(_WORD *)&v57[4] = 1024;
    *(_DWORD *)&v57[6] = DWORD1(v53[2]);
    *(_WORD *)uint64_t v58 = 1024;
    *(_DWORD *)&v58[2] = bswap32(WORD1(v53[2])) >> 16;
    *(_WORD *)uint64_t v59 = 2048;
    *(void *)&v59[2] = (int)info;
    uint64_t v18 = "TCP info get -- local: %{network:in_addr}d:%d, remote: %{network:in_addr}d:%d, error: %{mdns:err}ld";
    uint64_t v19 = (os_log_s *)v9;
    os_log_type_t v20 = v10;
    uint32_t v21 = 36;
LABEL_17:
    _os_log_impl((void *)&_mh_execute_header, v19, v20, v18, buf, v21);
  }

CFNumberRef DictionaryIsEnabled(const __CFDictionary *a1)
{
  uint64_t result = (const __CFNumber *)CFDictionaryGetValue(a1, @"Enabled");
  if (result)
  {
    int valuePtr = 0;
    if (CFNumberGetValue(result, kCFNumberSInt32Type, &valuePtr))
    {
      return (const __CFNumber *)(valuePtr != 0);
    }

    else
    {
      LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "ERROR: DictionaryIsEnabled - CFNumberGetValue",  v2,  v3,  v4,  v5,  v6,  v7);
      return 0LL;
    }
  }

  return result;
}

void mDNSPlatformUpdateDNSStatus(uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 334) && *(_WORD *)(a1 + 320) && !*(_BYTE *)(a1 + 335))
  {
    int v1 = *(unsigned __int16 *)(a1 + 322);
    if (v1 == 1)
    {
      uint64_t v2 = mDNSStorage[0];
      *(_BYTE *)(mDNSStorage[0] + 68_Block_object_dispose(va, 8) = 0;
    }

    else
    {
      uint64_t v2 = mDNSStorage[0];
      if (v1 == 28) {
        *(_BYTE *)(mDNSStorage[0] + 689) = 0;
      }
    }

    int v3 = *(unsigned __int8 *)(v2 + 688);
    if (*(_BYTE *)(v2 + 688))
    {
      if (!*(_BYTE *)(v2 + 689) && (mDNS_LoggingEnabled & 1) != 0) {
        goto LABEL_14;
      }
    }

    else if (mDNS_LoggingEnabled == 1)
    {
LABEL_14:
      uint64_t v4 = (os_log_s *)mDNSLogCategory_Default;
      DNSTypeName(v1);
      LogMsgWithLevel( v4,  OS_LOG_TYPE_DEFAULT,  "mDNSPlatformUpdateDNSStatus: Trigger needed v4 %d, v6 %d, question %##s (%s)",  v5,  v6,  v7,  v8,  v9,  v3);
    }
  }

void mDNSPlatformTriggerDNSRetry( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9)
{
  int v11 = dword_100158BF8;
  int v12 = *(_DWORD *)(mDNSStorage[0] + 692);
  if (v12) {
    BOOL v13 = dword_100158BF8 - v12 <= 179999;
  }
  else {
    BOOL v13 = 0;
  }
  if (v13)
  {
    mDNS_Unlock_((uint64_t)mDNSStorage, (uint64_t)"mDNSPlatformTriggerDNSRetry", 5038);
    return;
  }

  mDNS_Unlock_((uint64_t)mDNSStorage, (uint64_t)"mDNSPlatformTriggerDNSRetry", 5041);
  if (a1 && !*(_BYTE *)(a1 + 334) && *(_WORD *)(a1 + 320))
  {
    char v14 = 1;
    if (!*(_BYTE *)(a1 + 335))
    {
      uint64_t v15 = mDNSStorage[0];
      int v16 = *(unsigned __int8 *)(mDNSStorage[0] + 688);
      *(_BYTE *)(mDNSStorage[0] + 68_Block_object_dispose(va, 8) = 1;
      if (!v16)
      {
        if (mDNS_LoggingEnabled == 1)
        {
          uint64_t v17 = (os_log_s *)mDNSLogCategory_Default;
          int v18 = v11 - *(_DWORD *)(v15 + 692);
          DNSTypeName(*(unsigned __int16 *)(a1 + 322));
          LogMsgWithLevel( v17,  OS_LOG_TYPE_DEFAULT,  "mDNSPlatformTriggerDNSRetry: Triggering because of IPv4, last trigger %d ms, %##s (%s)",  v19,  v20,  v21,  v22,  v23,  v18);
        }

        char v14 = 0;
      }
    }
  }

  else
  {
    char v14 = 1;
  }

  if (!a2
    || *(_BYTE *)(a2 + 334)
    || !*(_WORD *)(a2 + 320)
    || *(_BYTE *)(a2 + 335)
    || (uint64_t v24 = mDNSStorage[0], v25 = *(unsigned __int8 *)(mDNSStorage[0] + 689),
                              *(_BYTE *)(mDNSStorage[0] + 689) = 1,
                              v25))
  {
    if ((v14 & 1) != 0) {
      return;
    }
  }

  else if (mDNS_LoggingEnabled == 1)
  {
    int v26 = (os_log_s *)mDNSLogCategory_Default;
    int v27 = v11 - *(_DWORD *)(v24 + 692);
    DNSTypeName(*(unsigned __int16 *)(a2 + 322));
    LogMsgWithLevel( v26,  OS_LOG_TYPE_DEFAULT,  "mDNSPlatformTriggerDNSRetry: Triggering because of IPv6, last trigger %d ms, %##s (%s)",  v28,  v29,  v30,  v31,  v32,  v27);
  }

  uint64_t v33 = dns_configuration_copy();
  if (v33)
  {
    uint64_t v39 = v33;
    mDNS_Lock_((unsigned int *)mDNSStorage, (uint64_t)"mDNSPlatformTriggerDNSRetry", 5078);
    AckConfigd(v39);
    mDNS_Unlock_((uint64_t)mDNSStorage, (uint64_t)"mDNSPlatformTriggerDNSRetry", 5080);
    dns_configuration_free(v39);
  }

  else
  {
    LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "mDNSPlatformTriggerDNSRetry: ERROR!! configd did not return config",  v34,  v35,  v36,  v37,  v38,  a9);
  }

uint64_t AckConfigd(uint64_t a1)
{
  else {
    int v2 = dword_100158BF8;
  }
  *(_DWORD *)(mDNSStorage[0] + 692) = v2;
  return _dns_configuration_ack(a1, "com.apple.mDNSResponder");
}

uint64_t UpdateSearchDomainHash(_MD5_CTX *a1, const char *a2, uint64_t a3)
{
  *(void *)__s = 0LL;
  uint64_t v17 = 0LL;
  if (a2) {
    uint64_t v4 = a2;
  }
  else {
    uint64_t v4 = ".";
  }
  uint64_t v5 = a3 + 5;
  else {
    int v6 = a3;
  }
  unsigned int v7 = mDNS_snprintf(__s);
  uint64_t v8 = (os_log_s *)mDNSLogCategory_State;
  if (v7 >= 0x10 && os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)CFSocketContext buf = 67109120;
    LODWORD(v13) = v6;
    _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEBUG,  "UpdateSearchDomainHash: mDNS_snprintf failed for scopeid %u",  buf,  8u);
    uint64_t v8 = (os_log_s *)mDNSLogCategory_State;
  }

  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)CFSocketContext buf = 136315394;
    BOOL v13 = v4;
    __int16 v14 = 2080;
    uint64_t v15 = __s;
    _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEBUG,  "UpdateSearchDomainHash: buf %s, ifid_buf %s",  buf,  0x16u);
  }

  size_t v9 = strlen(v4);
  MD5_Update(a1, v4, v9 + 1);
  size_t v10 = strlen(__s);
  return MD5_Update(a1, __s, v10 + 1);
}

void ConfigResolvers(int *a1, uint64_t a2, int a3, int a4, _MD5_CTX *a5)
{
  uint64_t v5 = a2;
  if ((_DWORD)a2 == 2)
  {
    unsigned int v7 = (void **)(a1 + 9);
    int v6 = a1 + 8;
  }

  else if ((_DWORD)a2 == 1)
  {
    unsigned int v7 = (void **)(a1 + 4);
    int v6 = a1 + 3;
  }

  else
  {
    if ((_DWORD)a2) {
      return;
    }
    int v6 = a1;
    unsigned int v7 = (void **)(a1 + 1);
  }

  int v8 = *v6;
  size_t v9 = *v7;
  qsort(*v7, *v6, 8uLL, (int (__cdecl *)(const void *, const void *))compare_dns_configs);
  if (v8 >= 1)
  {
    uint64_t v10 = 0LL;
    uint64_t v97 = v8;
    while (1)
    {
      uint64_t v11 = v9[v10];
      int v12 = (os_log_s *)mDNSLogCategory_State;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT))
      {
        int v18 = *(unsigned __int8 **)v11;
        int v19 = *(_DWORD *)(v11 + 8);
        *(_DWORD *)CFSocketContext buf = 67241219;
        *(_DWORD *)&uint8_t buf[4] = v5;
        *(_WORD *)&uint8_t buf[8] = 1024;
        *(_DWORD *)&buf[10] = v10;
        *(_WORD *)&buf[14] = 2160;
        *(void *)&v115[0] = 1752392040LL;
        WORD4(v115[0]) = 2085;
        *(void *)((char *)v115 + 10) = v18;
        WORD1(v115[1]) = 1024;
        DWORD1(v115[1]) = v19;
        _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEFAULT,  "ConfigResolvers -- scope type: %{public, mdnsresponder:dns_scope_type}d, resolver[%d]: {domain: %{sensitive, m ask.hash}s, name server count: %d}",  buf,  0x28u);
      }

      uint64_t v20 = *(unsigned int *)(v11 + 64);
      if ((_DWORD)v20)
      {
        uint64_t v21 = *(void *)mDNSStorage[0];
        if (*(void *)mDNSStorage[0])
        {
          while (!*(void *)(v21 + 6256) || *(_DWORD *)(v21 + 6424) != (_DWORD)v20)
          {
            uint64_t v21 = *(void *)(v21 + 6384);
            if (!v21) {
              goto LABEL_16;
            }
          }

          uint64_t v20 = *(void *)(v21 + 6256);
        }

        else
        {
LABEL_16:
          LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "ConfigParseInterfaceID: interface specific index %d not found (interface may not be UP)",  v13,  v14,  v15,  v16,  v17,  *(_DWORD *)(v11 + 64));
        }
      }

      else
      {
        uint64_t v20 = 0LL;
      }

      if (!a3) {
        goto LABEL_73;
      }
      uint64_t v22 = v9;
      uint64_t v23 = v9[v10];
      uint64_t v24 = *((void *)a1 + 3);
      __int128 v127 = 0u;
      __int128 v128 = 0u;
      __int128 v125 = 0u;
      __int128 v126 = 0u;
      __int128 v123 = 0u;
      __int128 v124 = 0u;
      __int128 v121 = 0u;
      __int128 v122 = 0u;
      __int128 v119 = 0u;
      __int128 v120 = 0u;
      __int128 v117 = 0u;
      __int128 v118 = 0u;
      v115[1] = 0u;
      __int128 v116 = 0u;
      if (!(_DWORD)v5) {
        uint64_t v20 = 0LL;
      }
      *(_OWORD *)CFSocketContext buf = 0uLL;
      v115[0] = 0uLL;
      uint64_t v25 = v5;
      uint64_t v37 = mDNSLogCategory_State;
      BOOL v38 = os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT);
      if (v20)
      {
        if (!v38) {
          goto LABEL_72;
        }
        uint64_t v39 = &xmmword_10015BD30;
        while (1)
        {
          uint64_t v39 = *(__int128 **)v39;
          if (!v39) {
            break;
          }
          __int128 v40 = v39;
          if (*((void *)v39 + 782) == v20) {
            goto LABEL_41;
          }
        }

        __int128 v40 = 0LL;
LABEL_41:
        __int128 v47 = (char *)v40 + 6310;
        *(_DWORD *)int v100 = 67240450;
        if (v39) {
          __int128 v48 = v47;
        }
        else {
          __int128 v48 = 0LL;
        }
        *(_DWORD *)&v100[4] = 2;
        *(_WORD *)&v100[8] = 2082;
        *(void *)&v100[10] = v48;
        __int128 v41 = (os_log_s *)v37;
        __int128 v42 = "ConfigSearchDomains: Ignoring search domains for interface -- scope type: %{public, mdnsresponder:dns_scop"
              "e_type}d, ifname: %{public}s";
        uint32_t v43 = 18;
      }

      else
      {
        if (!v38) {
          goto LABEL_72;
        }
        *(_DWORD *)int v100 = 67240192;
        *(_DWORD *)&v100[4] = 2;
        __int128 v41 = (os_log_s *)v37;
        __int128 v42 = "ConfigSearchDomains: Ignoring search domains for interface -- scope type: %{public, mdnsresponder:dns_scope_type}d";
        uint32_t v43 = 8;
      }

      _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_DEFAULT, v42, v100, v43);
LABEL_72:
      uint64_t v5 = v25;
      size_t v9 = v22;
      if (!a4) {
        goto LABEL_77;
      }
LABEL_73:
      if (*(_WORD *)(v11 + 20) != 5353 && *(_DWORD *)(v11 + 8)) {
        goto LABEL_77;
      }
      __int16 v60 = *(const char **)(v11 + 48);
      if (!v60) {
        goto LABEL_77;
      }
      size_t v61 = strlen(*(const char **)(v11 + 48));
      if (strncmp(v60, "mdns", v61)) {
        goto LABEL_77;
      }
      __int128 v127 = 0u;
      __int128 v128 = 0u;
      __int128 v125 = 0u;
      __int128 v126 = 0u;
      __int128 v123 = 0u;
      __int128 v124 = 0u;
      __int128 v121 = 0u;
      __int128 v122 = 0u;
      __int128 v119 = 0u;
      __int128 v120 = 0u;
      __int128 v117 = 0u;
      __int128 v118 = 0u;
      __int128 v116 = 0u;
      *(_OWORD *)CFSocketContext buf = 0u;
      memset(v115, 0, sizeof(v115));
      if (!AppendDNSNameString(buf, *(unsigned __int8 **)v11, v62, v63, v64, v65, v66, v67))
      {
        LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "ConfigNonUnicastResolver: config->resolver bad domain %s",  v68,  v69,  v70,  v71,  v72,  *(void *)v11);
        goto LABEL_77;
      }

      int v73 = *(_DWORD *)(v11 + 56);
      uint64_t v74 = (os_log_s *)mDNSLogCategory_Default;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
      {
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEBUG))
        {
          for (uint64_t i = buf; ; i += v79 + 1)
          {
            LOWORD(v76) = 257;
            uint64_t v79 = *i;
            if (v79 > 0x3F)
            {
              LOWORD(v76) = 257;
              goto LABEL_102;
            }

            if (!*i)
            {
              unsigned int v76 = (_DWORD)i - buf + 1;
              goto LABEL_102;
            }
          }

          goto LABEL_102;
        }
      }

      else
      {
        uint64_t v74 = (os_log_s *)mDNSLogCategory_Default_redacted;
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEBUG))
        {
          for (uint64_t j = buf; ; j += v77 + 1)
          {
            LOWORD(v76) = 257;
            uint64_t v77 = *j;
            if (v77 > 0x3F)
            {
              LOWORD(v76) = 257;
              break;
            }

            if (!*j)
            {
              unsigned int v76 = (_DWORD)j - buf + 1;
              break;
            }
          }

uint64_t compare_dns_configs(uint64_t a1, uint64_t a2)
{
  unsigned int v2 = *(_DWORD *)(*(void *)a1 + 60LL);
  unsigned int v3 = *(_DWORD *)(*(void *)a2 + 60LL);
  BOOL v4 = v2 >= v3;
  BOOL v5 = v2 != v3;
  if (v4) {
    return v5;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

void mDNSPlatformDynDNSHostNameStatusChanged( unsigned __int8 *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int valuePtr = a2;
  if (mDNS_LoggingEnabled == 1) {
    LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "mDNSPlatformDynDNSHostNameStatusChanged %d %##s",  a4,  a5,  a6,  a7,  a8,  a2);
  }
  bzero(&cStr, 0x3F1uLL);
  ConvertDomainNameToCString_withescape(a1, (unsigned __int8 *)&cStr);
  LOBYTE(v9) = cStr;
  if (cStr)
  {
    uint64_t v10 = (unsigned __int8 *)&v42;
    do
    {
      unsigned __int8 v11 = __tolower((char)v9);
      int v9 = *v10;
      if (v11 == 46 && v9 == 0) {
        unsigned __int8 v13 = 0;
      }
      else {
        unsigned __int8 v13 = v11;
      }
      *(v10++ - 1) = v13;
    }

    while (v9);
  }

  __int128 v40 = @"HostNames";
  CFStringRef v14 = CFStringCreateWithCString(0LL, &cStr, 0x8000100u);
  keys = @"Status";
  CFTypeRef v39 = v14;
  if (!v14)
  {
    LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "SetDDNSNameStatus: CFStringCreateWithCString(%s) failed",  v15,  v16,  v17,  v18,  v19,  (int)&cStr);
    return;
  }

  CFTypeRef v20 = v14;
  values = CFNumberCreate(0LL, kCFNumberSInt32Type, &valuePtr);
  if (!values)
  {
    LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "SetDDNSNameStatus: CFNumberCreate(%d) failed",  v21,  v22,  v23,  v24,  v25,  valuePtr);
LABEL_28:
    CFRelease(v20);
    return;
  }

  CFTypeRef v36 = CFDictionaryCreate( 0LL,  (const void **)&keys,  (const void **)&values,  1LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
  if (v36)
  {
    CFTypeRef cf = CFDictionaryCreate(0LL, &v39, &v36, 1LL, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    if (cf)
    {
      CFDictionaryRef v26 = CFDictionaryCreate( 0LL,  (const void **)&v40,  &cf,  1LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
      if (v26)
      {
        CFDictionaryRef v32 = v26;
        mDNSDynamicStoreSetConfig(2, 0LL, v26, v27, v28, v29, v30, v31, v33);
        CFRelease(v32);
      }

      if (cf)
      {
        CFRelease(cf);
        CFTypeRef cf = 0LL;
      }
    }

    if (v36)
    {
      CFRelease(v36);
      CFTypeRef v36 = 0LL;
    }
  }

  if (values)
  {
    CFRelease(values);
    values = 0LL;
  }

  CFTypeRef v20 = v39;
  if (v39) {
    goto LABEL_28;
  }
}

uint64_t SupportsInNICProxy(uint64_t a1)
{
  if (UseInternalSleepProxy) {
    return CheckInterfaceSupport(a1, "mDNS_KEY");
  }
  unsigned int v2 = (os_log_s *)mDNSLogCategory_SPS;
  if (gSensitiveLoggingEnabled == 1 && mDNSLogCategory_SPS != mDNSLogCategory_State)
  {
    unsigned int v2 = (os_log_s *)mDNSLogCategory_SPS_redacted;
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_SPS_redacted, OS_LOG_TYPE_DEFAULT)) {
      return 0LL;
    }
    __int16 v6 = 0;
    BOOL v4 = (uint8_t *)&v6;
    goto LABEL_12;
  }

  if (os_log_type_enabled((os_log_t)mDNSLogCategory_SPS, OS_LOG_TYPE_DEFAULT))
  {
    __int16 v7 = 0;
    BOOL v4 = (uint8_t *)&v7;
LABEL_12:
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "SupportsInNICProxy: Internal Sleep Proxy is disabled",  v4,  2u);
  }

  return 0LL;
}

uint64_t GetPortArray(int a1, unsigned __int16 *a2)
{
  if (a1 == 1) {
    unsigned int v2 = "\x04_udp";
  }
  else {
    unsigned int v2 = "\x04_tcp";
  }
  unsigned int v3 = (uint64_t *)xmmword_10015BD08;
  if (!(void)xmmword_10015BD08) {
    return 0LL;
  }
  uint64_t v5 = 0LL;
  do
  {
    if (*((_WORD *)v3 + 6) == 33)
    {
      __int16 v6 = (_BYTE *)v3[5];
      uint64_t v7 = *v6 ? *v6 + 1LL : 0LL;
      int v8 = &v6[v7];
      uint64_t v9 = *v8 ? *v8 + 1LL : 0LL;
      if (SameDomainLabelPointer(&v8[v9], v2))
      {
        if (a2)
        {
          int v10 = *(unsigned __int16 *)(v3[6] + 8);
          if ((_DWORD)v5)
          {
            uint64_t v11 = v5;
            uint64_t v12 = v5;
            unsigned __int8 v13 = a2;
            while (1)
            {
              int v14 = *v13++;
              if (v14 == v10) {
                break;
              }
              if (!--v12) {
                goto LABEL_22;
              }
            }
          }

          else
          {
            uint64_t v11 = 0LL;
LABEL_22:
            uint64_t v5 = (v5 + 1);
            a2[v11] = v10;
          }
        }

        else
        {
          uint64_t v5 = (v5 + 1);
        }
      }
    }

    unsigned int v3 = (uint64_t *)*v3;
  }

  while (v3);
  return v5;
}

uint64_t CountProxyRecords(_DWORD *a1)
{
  *a1 = 0;
  int v1 = (uint64_t *)xmmword_10015BD08;
  if ((void)xmmword_10015BD08)
  {
    uint64_t v3 = 0LL;
    while ((*((_BYTE *)v1 + 123) & 1) != 0
         || *((unsigned __int8 *)v1 + 8) < 2u
         || v1[4]
         || !*((_BYTE *)v1 + 122) && !IsLocalDomain((_BYTE *)v1[5]))
    {
LABEL_22:
      int v1 = (uint64_t *)*v1;
      if (!v1) {
        return v3;
      }
    }

    BOOL v4 = (_BYTE *)v1[5];
    uint64_t v5 = v4;
    if (v4 == (_BYTE *)-256LL) {
      goto LABEL_12;
    }
LABEL_9:
    unsigned __int16 v6 = 257;
    if (v5 < v4 + 256 && v5)
    {
      do
      {
        uint64_t v7 = *v5;
        if (!*v5)
        {
          unsigned __int16 v6 = (_WORD)v5 - (_WORD)v4 + 1;
          goto LABEL_19;
        }

        v5 += v7 + 1;
        if (v4 != (_BYTE *)-256LL) {
          goto LABEL_9;
        }
LABEL_12:
        ;
      }

      while (v5);
      unsigned __int16 v6 = 257;
    }

void GetProxyRecords( unint64_t a1, _DWORD *a2, uint64_t a3, unsigned int *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = a4;
  unint64_t v10 = a1 + 12;
  uint64_t v11 = *a2;
  *(_DWORD *)a1 = 0;
  *(void *)(a1 + 4) = 0LL;
  uint64_t v12 = (uint64_t *)xmmword_10015BD08;
  if ((void)xmmword_10015BD08)
  {
    uint64_t v13 = a3;
    unint64_t v14 = a1;
    unsigned int v15 = 0;
    unint64_t v16 = v10 + v11;
    uint64_t v27 = (_WORD *)(a1 + 8);
    unint64_t v17 = a1 + 12;
    do
    {
      if ((*((_BYTE *)v12 + 123) & 1) == 0
        && *((unsigned __int8 *)v12 + 8) >= 2u
        && !v12[4]
        && (*((_BYTE *)v12 + 122) || IsLocalDomain((_BYTE *)v12[5])))
      {
        *(void *)(v13 + 8LL * v15) = v17;
        if ((v12[1] & 0x32) != 0) {
          *((_WORD *)v12 + 7) |= 0x8000u;
        }
        unint64_t v17 = PutResourceRecordTTLWithLimit(v14, v17, v27, (uint64_t)(v12 + 1), *((unsigned int *)v12 + 4), v16, a7, a8);
        *((_WORD *)v12 + 7) &= ~0x8000u;
        if (mDNS_LoggingEnabled == 1)
        {
          CFDictionaryRef v26 = (os_log_s *)mDNSLogCategory_Default;
          GetRRDisplayString_rdb((unsigned __int8 *)v12 + 8, (unsigned __int16 *)(v12[6] + 4), word_100164338);
          uint64_t v13 = a3;
          int v8 = a4;
          unint64_t v14 = a1;
          LogMsgWithLevel( v26,  OS_LOG_TYPE_DEFAULT,  "GetProxyRecords: %3d start %p end %p size %5d total %5d %s",  v18,  v19,  v20,  v21,  v22,  v15);
        }

        ++v15;
      }

      uint64_t v12 = (uint64_t *)*v12;
    }

    while (v12);
  }

  else
  {
    unsigned int v15 = 0;
    LODWORD(v17) = a1 + 12;
  }

  *a2 = v17 - v10;
  if (v8) {
    *int v8 = v15;
  }
}

uint64_t scalarSameDomainLabel(_BYTE *a1, unsigned __int8 *a2)
{
  unsigned int v2 = *a1;
  if (v2 <= 0x3F && v2 == *a2)
  {
    if (!*a1) {
      return 1LL;
    }
    uint64_t v3 = a1 + 1;
    BOOL v4 = a2 + 1;
    while (1)
    {
      int v6 = *v3++;
      int v5 = v6;
      int v8 = *v4++;
      int v7 = v8;
      if (!--v2) {
        return 1LL;
      }
    }
  }

  return 0LL;
}

uint64_t vectorSameDomainLabel(unsigned __int8 *a1, unsigned __int8 *a2)
{
  unsigned int v4 = *a1;
  unsigned int v2 = (int8x8_t *)(a1 + 1);
  unsigned int v3 = v4;
  if (v4 < 0x40)
  {
    if (v3 == *a2)
    {
      int v5 = (int8x8_t *)(a2 + 1);
      if (v3 < 0x10)
      {
LABEL_8:
        if (v3 < 8) {
          goto LABEL_11;
        }
        while (1)
        {
          uint32x2_t v9 = (uint32x2_t)vceq_s8( vadd_s8( vand_s8( vcgt_s8(vadd_s8(*v2, (int8x8_t)0x2525252525252525LL), (int8x8_t)0x6565656565656565LL),  (int8x8_t)0x2020202020202020LL),  *v2),  vadd_s8( vand_s8( vcgt_s8(vadd_s8(*v5, (int8x8_t)0x2525252525252525LL), (int8x8_t)0x6565656565656565LL),  (int8x8_t)0x2020202020202020LL),  *v5));
          if (vpmin_u32(v9, v9).u32[0] != -1) {
            break;
          }
          ++v5;
          ++v2;
          v3 -= 8;
          if (v3 <= 7)
          {
LABEL_11:
            while (v3)
            {
              unsigned int v11 = v2->u8[0];
              unsigned int v2 = (int8x8_t *)((char *)v2 + 1);
              uint64_t v10 = v11;
              int v12 = v5->u8[0];
              int v5 = (int8x8_t *)((char *)v5 + 1);
              --v3;
              if ((upper_to_lower_case_table[v10] + v10) != (upper_to_lower_case_table[v12]
                                                                                              + v12))
                return 0LL;
            }

            return 1LL;
          }
        }
      }

      else
      {
        v6.i64[0] = 0x2525252525252525LL;
        v6.i64[1] = 0x2525252525252525LL;
        v7.i64[0] = 0x6565656565656565LL;
        v7.i64[1] = 0x6565656565656565LL;
        v8.i64[0] = 0x2020202020202020LL;
        v8.i64[1] = 0x2020202020202020LL;
        while (vminvq_u32((uint32x4_t)vceqq_s8( vaddq_s8( vandq_s8(vcgtq_s8(vaddq_s8(*(int8x16_t *)v2->i8, v6), v7), v8),  *(int8x16_t *)v2->i8),  vaddq_s8( vandq_s8(vcgtq_s8(vaddq_s8(*(int8x16_t *)v5->i8, v6), v7), v8),  *(int8x16_t *)v5->i8))) == -1)
        {
          v5 += 2;
          v2 += 2;
          v3 -= 16;
          if (v3 <= 0xF) {
            goto LABEL_8;
          }
        }
      }
    }
  }

  else
  {
    fwrite("v: Malformed label (too long)\n", 0x1EuLL, 1uLL, __stderrp);
  }

  return 0LL;
}

void FreeEtcHosts(uint64_t a1, uint64_t a2, int a3)
{
  if (a3 == -65792)
  {
    int v5 = (os_log_s *)mDNSLogCategory_NAT;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_NAT == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_NAT, OS_LOG_TYPE_DEFAULT))
      {
LABEL_10:
        int8x16_t v8 = (_BYTE *)(a1 + 46976);
        GetRRDisplayString_rdb((unsigned __int8 *)(a2 + 8), (unsigned __int16 *)(*(void *)(a2 + 48) + 4LL), v8);
        int v9 = 141558275;
        uint64_t v10 = 1752392040LL;
        __int16 v11 = 2085;
        int v12 = v8;
        _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "FreeEtcHosts: %{sensitive, mask.hash}s",  (uint8_t *)&v9,  0x16u);
LABEL_12:
        free((void *)a2);
        return;
      }
    }

    else
    {
      int v5 = (os_log_s *)mDNSLogCategory_NAT_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_NAT_redacted, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_10;
      }
    }

    if (!a2) {
      return;
    }
    goto LABEL_12;
  }

_BYTE *GetRandomUUIDLocalHostname(_BYTE *a1)
{
  *a1 = 0;
  AppendDomainLabel(a1, (unsigned __int8 *)v3);
  return AppendLiteralLabelString(a1, "local");
}

void DynamicStoreReconnected(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = pthread_mutex_lock((pthread_mutex_t *)(mDNSStorage[0] + 616));
  unint64_t v11 = mDNSPlatformRawTime(v3, v4, v5, v6, v7, v8, v9, v10);
  *(_DWORD *)(mDNSStorage[0] + 680) = v11;
  if (mDNS_LoggingEnabled == 1) {
    LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "DynamicStoreReconnected: Reconnected",  v14,  v15,  v16,  v17,  v18,  v26);
  }
  SetLocalDomains(v11, v12, v13, v14, v15, v16, v17, v18, v26);
  if (*(_BYTE *)(a2 + 14352)) {
    mDNSPlatformDynDNSHostNameStatusChanged((unsigned __int8 *)(a2 + 14352), 1, v20, v21, v22, v23, v24, v25);
  }
  if (spsStatusDict) {
    CFDictionaryApplyFunction((CFDictionaryRef)spsStatusDict, (CFDictionaryApplierFunction)RefreshSPSStatus, 0LL);
  }
  KQueueUnlock((uint64_t)"DynamicStoreReconnected", v19, v20, v21, v22, v23, v24, v25);
}

void SetLocalDomains( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9)
{
  CFMutableStringRef Mutable = CFArrayCreateMutable(0LL, 0LL, &kCFTypeArrayCallBacks);
  if (Mutable)
  {
    uint64_t v15 = Mutable;
    CFArrayAppendValue(Mutable, @"local");
    CFArrayAppendValue(v15, @"254.169.in-addr.arpa");
    CFArrayAppendValue(v15, @"8.e.f.ip6.arpa");
    CFArrayAppendValue(v15, @"9.e.f.ip6.arpa");
    CFArrayAppendValue(v15, @"a.e.f.ip6.arpa");
    CFArrayAppendValue(v15, @"b.e.f.ip6.arpa");
    mDNSDynamicStoreSetConfig(1, 0LL, v15, v16, v17, v18, v19, v20, v21);
    CFRelease(v15);
  }

  else
  {
    LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "SetLocalDomains: CFArrayCreateMutable failed",  v10,  v11,  v12,  v13,  v14,  a9);
  }

void PowerChanged(uint64_t a1, uint64_t a2, int a3, intptr_t a4)
{
  uint64_t v7 = pthread_mutex_lock((pthread_mutex_t *)(mDNSStorage[0] + 616));
  unint64_t v15 = mDNSPlatformRawTime(v7, v8, v9, v10, v11, v12, v13, v14);
  *(_DWORD *)(mDNSStorage[0] + 680) = v15;
  *(_BYTE *)(a1 + 143) = SystemWakeForNetworkAccess(v15, v16, v17, v18, v19, v20, v21, v22);
  HIDWORD(v30) = a3;
  LODWORD(v30) = a3 + 536870336;
  switch((v30 >> 4))
  {
    case 0u:
      if (mDNS_LoggingEnabled == 1)
      {
        uint64_t v31 = (os_log_s *)mDNSLogCategory_Default;
        CFDictionaryRef v32 = "PowerChanged kIOMessageCanSystemPowerOff     (no action)";
        goto LABEL_26;
      }

      break;
    case 1u:
      if (mDNS_LoggingEnabled == 1) {
        LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "PowerChanged kIOMessageSystemWillPowerOff",  v25,  v26,  v27,  v28,  v29,  v42);
      }
      mDNSCoreMachineSleep(a1, 1);
      if (*(_BYTE *)(a1 + 141) == 2) {
        mDNSMacOSXNetworkChanged(v33, v23, v24, v25, v26, v27, v28, v29);
      }
      break;
    case 2u:
      if (mDNS_LoggingEnabled == 1)
      {
        uint64_t v31 = (os_log_s *)mDNSLogCategory_Default;
        CFDictionaryRef v32 = "PowerChanged kIOMessageSystemWillNotPowerOff (no action)";
        goto LABEL_26;
      }

      break;
    case 3u:
      if (mDNS_LoggingEnabled == 1)
      {
        uint64_t v31 = (os_log_s *)mDNSLogCategory_Default;
        CFDictionaryRef v32 = "PowerChanged kIOMessageCanSystemSleep";
        goto LABEL_26;
      }

      break;
    case 4u:
      if (mDNS_LoggingEnabled == 1) {
        LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "PowerChanged kIOMessageSystemWillSleep",  v25,  v26,  v27,  v28,  v29,  v42);
      }
      mDNSCoreMachineSleep(a1, 1);
      break;
    case 5u:
      if (mDNS_LoggingEnabled == 1)
      {
        uint64_t v31 = (os_log_s *)mDNSLogCategory_Default;
        CFDictionaryRef v32 = "PowerChanged kIOMessageSystemWillNotSleep    (no action)";
        goto LABEL_26;
      }

      break;
    case 0xCu:
      if (mDNS_LoggingEnabled == 1) {
        LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "PowerChanged kIOMessageSystemHasPoweredOn",  v25,  v26,  v27,  v28,  v29,  v42);
      }
      if (*(_BYTE *)(a1 + 141))
      {
        LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "PowerChanged kIOMessageSystemHasPoweredOn: ERROR m->SleepState %d",  v25,  v26,  v27,  v28,  v29,  *(unsigned __int8 *)(a1 + 141));
        PowerOn(a1);
      }

      mDNS_Lock_((unsigned int *)a1, (uint64_t)"PowerChanged", 6999);
      SetNetworkChanged(2000);
      mDNS_Unlock_(a1, (uint64_t)"PowerChanged", 7001);
      break;
    case 0xDu:
      if (mDNS_LoggingEnabled == 1)
      {
        uint64_t v31 = (os_log_s *)mDNSLogCategory_Default;
        CFDictionaryRef v32 = "PowerChanged kIOMessageSystemWillRestart     (no action)";
LABEL_26:
        LogMsgWithLevel(v31, OS_LOG_TYPE_DEFAULT, v32, v25, v26, v27, v28, v29, v42);
      }

      break;
    case 0xEu:
      if (mDNS_LoggingEnabled == 1) {
        LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "PowerChanged kIOMessageSystemWillPowerOn",  v25,  v26,  v27,  v28,  v29,  v42);
      }
      if (*(_BYTE *)(a1 + 141) != 2)
      {
        LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "kIOMessageSystemWillPowerOn: ERROR m->SleepState %d",  v25,  v26,  v27,  v28,  v29,  *(unsigned __int8 *)(a1 + 141));
        *(_BYTE *)(a1 + 141) = 2;
        mDNSMacOSXNetworkChanged(v34, v35, v36, v37, v38, v39, v40, v41);
      }

      PowerOn(a1);
      break;
    default:
      if (mDNS_LoggingEnabled == 1) {
        LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "PowerChanged unknown message %X",  v25,  v26,  v27,  v28,  v29,  a3);
      }
      break;
  }

  if (a3 == -536870288)
  {
    IOAllowPowerChange(*(_DWORD *)(*(void *)a1 + 568LL), a4);
  }

  else if (a3 == -536870272)
  {
    *(void *)(*(void *)a1 + 592LL) = a4;
  }

  KQueueUnlock((uint64_t)"PowerChanged Sleep/Wake", v23, v24, v25, v26, v27, v28, v29);
}

void RegisterLocalOnlyAddressRecord(_BYTE *a1, int a2, const void *a3, unsigned int a4)
{
  __int16 v6 = a2;
  if (a2 == 28)
  {
    if (a4 != 16) {
      return;
    }
  }

  else if (a2 != 1 || a4 != 4)
  {
    return;
  }

  uint64_t v8 = calloc(1uLL, 0x498uLL);
  if (v8)
  {
    uint64_t v9 = (uint64_t)v8;
    mDNS_SetupResourceRecord((uint64_t)v8, 0LL, -2LL, v6, 1u, 32, 4, (uint64_t)FreeEtcHosts, 0LL);
    uint64_t v10 = a1;
    if (a1 == (_BYTE *)-256LL)
    {
LABEL_9:
      while (v10)
      {
        uint64_t v11 = *v10;
        if (!*v10)
        {
          unsigned __int16 v27 = (_WORD)v10 - (_WORD)a1 + 1;
          uint64_t v12 = (_BYTE *)(v9 + 652);
          if (v27 > 0x100u) {
            goto LABEL_15;
          }
          __memcpy_chk(v12, a1, v27, 524LL);
          goto LABEL_16;
        }

        v10 += v11 + 1;
        if (a1 != (_BYTE *)-256LL) {
          goto LABEL_8;
        }
      }
    }

    else
    {
LABEL_8:
      if (v10 < a1 + 256) {
        goto LABEL_9;
      }
    }

    uint64_t v12 = (_BYTE *)(v9 + 652);
LABEL_15:
    *uint64_t v12 = 0;
LABEL_16:
    memcpy((void *)(*(void *)(v9 + 48) + 4LL), a3, a4);
    int v19 = mDNS_Register_internal((uint64_t)mDNSStorage, v9, v13, v14, v15, v16, v17, v18);
    if (v19)
    {
      int v20 = v19;
      uint64_t v21 = (os_log_s *)mDNSLogCategory_Default;
      GetRRDisplayString_rdb( (unsigned __int8 *)(v9 + 8),  (unsigned __int16 *)(*(void *)(v9 + 48) + 4LL),  word_100164338);
      LogMsgWithLevel( v21,  OS_LOG_TYPE_DEFAULT,  "RegisterLocalOnlyAddressRecord: mDNS_Register error %d registering %s",  v22,  v23,  v24,  v25,  v26,  v20);
      free((void *)v9);
    }
  }

  else
  {
    __break(1u);
  }

void mDNSMacOSXUpdateEtcHosts_internal()
{
  if (!mDNSMacOSXGetEtcHostsFD_etcq)
  {
    mDNSMacOSXGetEtcHostsFD_etcq = (uint64_t)&_dispatch_main_q;
    dispatch_async(&_dispatch_main_q, &__block_literal_global_450);
    goto LABEL_89;
  }

  uint64_t v0 = (dispatch_source_s *)mDNSMacOSXGetEtcHostsFD_hostssrc;
  if (mDNSMacOSXGetEtcHostsFD_hostssrc) {
    goto LABEL_3;
  }
  int v76 = open("/etc/hosts", 0);
  if (v76 == -1)
  {
    if (mDNSMacOSXGetEtcHostsFD_etcsrc)
    {
      if (mDNS_LoggingEnabled != 1) {
        goto LABEL_104;
      }
      __int128 v90 = (os_log_s *)mDNSLogCategory_Default;
      unsigned int v91 = "mDNSMacOSXGetEtcHostsFD: Returning etcfd because no etchosts";
    }

    else
    {
      int v92 = open("/etc", 0);
      if (v92 == -1)
      {
        if (mDNS_LoggingEnabled != 1) {
          goto LABEL_104;
        }
        __int128 v90 = (os_log_s *)mDNSLogCategory_Default;
        unsigned int v91 = "mDNSMacOSXGetEtcHostsFD: etc does not exist";
      }

      else
      {
        int v76 = v92;
        uint64_t v93 = dispatch_source_create( (dispatch_source_type_t)&_dispatch_source_type_vnode,  v92,  0x23uLL,  (dispatch_queue_t)mDNSMacOSXGetEtcHostsFD_etcq);
        mDNSMacOSXGetEtcHostsFD_etcsrc = (uint64_t)v93;
        if (!v93) {
          goto LABEL_126;
        }
        dispatch_source_set_event_handler(v93, &__block_literal_global_456);
        v101[0] = _NSConcreteStackBlock;
        v101[1] = 0x40000000LL;
        v101[2] = __mDNSMacOSXGetEtcHostsFD_block_invoke_4;
        v101[3] = &__block_descriptor_tmp_460;
        int v102 = v76;
        dispatch_source_set_cancel_handler((dispatch_source_t)mDNSMacOSXGetEtcHostsFD_etcsrc, v101);
        dispatch_resume((dispatch_object_t)mDNSMacOSXGetEtcHostsFD_etcsrc);
        int v76 = open("/etc/hosts", 0x8000);
        if (v76 != -1) {
          goto LABEL_92;
        }
        __int128 v90 = (os_log_s *)mDNSLogCategory_Default;
        unsigned int v91 = "mDNSMacOSXGetEtcHostsFD etc hosts does not exist, watching etc";
      }
    }

    LogMsgWithLevel(v90, OS_LOG_TYPE_DEFAULT, v91, v71, v72, v73, v74, v75, v94);
    goto LABEL_89;
  }

LABEL_92:
  uint64_t v77 = dispatch_source_create( (dispatch_source_type_t)&_dispatch_source_type_vnode,  v76,  0x7FuLL,  (dispatch_queue_t)mDNSMacOSXGetEtcHostsFD_etcq);
  mDNSMacOSXGetEtcHostsFD_hostssrc = (uint64_t)v77;
  if (!v77)
  {
LABEL_126:
    close(v76);
    goto LABEL_89;
  }

  dispatch_source_set_event_handler(v77, &__block_literal_global_463);
  *(void *)&__int128 v120 = _NSConcreteStackBlock;
  *((void *)&v120 + 1) = 0x40000000LL;
  *(void *)&__int128 v121 = __mDNSMacOSXGetEtcHostsFD_block_invoke_7;
  *((void *)&v121 + 1) = &__block_descriptor_tmp_468;
  LODWORD(v122) = v76;
  dispatch_source_set_cancel_handler((dispatch_source_t)mDNSMacOSXGetEtcHostsFD_hostssrc, &v120);
  dispatch_resume((dispatch_object_t)mDNSMacOSXGetEtcHostsFD_hostssrc);
  if (mDNSMacOSXGetEtcHostsFD_etcsrc)
  {
    dispatch_source_cancel((dispatch_source_t)mDNSMacOSXGetEtcHostsFD_etcsrc);
    if (mDNSMacOSXGetEtcHostsFD_etcsrc)
    {
      dispatch_release((dispatch_object_t)mDNSMacOSXGetEtcHostsFD_etcsrc);
      mDNSMacOSXGetEtcHostsFD_etcsrc = 0LL;
    }
  }

  if (mDNS_LoggingEnabled == 1) {
    LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "mDNSMacOSXGetEtcHostsFD: /etc/hosts being monitored, and not etc",  v2,  v3,  v4,  v5,  v6,  v94);
  }
  uint64_t v0 = (dispatch_source_s *)mDNSMacOSXGetEtcHostsFD_hostssrc;
  if (!mDNSMacOSXGetEtcHostsFD_hostssrc)
  {
LABEL_89:
    if ((mDNS_LoggingEnabled & 1) == 0) {
      goto LABEL_104;
    }
LABEL_102:
    int v78 = (os_log_s *)mDNSLogCategory_Default;
    uint64_t v79 = "mDNSMacOSXUpdateEtcHosts: /etc/hosts is not present";
LABEL_103:
    LogMsgWithLevel(v78, OS_LOG_TYPE_DEFAULT, v79, v2, v3, v4, v5, v6, v94);
    goto LABEL_104;
  }

void *CreatePTRRecord(_BYTE *a1)
{
  uint64_t result = calloc(1uLL, 0x498uLL);
  if (!result)
  {
    __break(1u);
    return result;
  }

  uint64_t v3 = (uint64_t)result;
  mDNS_SetupResourceRecord((uint64_t)result, 0LL, -2LL, 12, 0x1194u, 32, 4, 0LL, 0LL);
  uint64_t v4 = a1;
  if (a1 == (_BYTE *)-256LL)
  {
LABEL_4:
    while (v4)
    {
      uint64_t v5 = *v4;
      if (!*v4)
      {
        unsigned __int16 v11 = (_WORD)v4 - (_WORD)a1 + 1;
        uint64_t v6 = (_BYTE *)(v3 + 652);
        if (v11 > 0x100u) {
          goto LABEL_10;
        }
        __memcpy_chk(v6, a1, v11, 524LL);
        goto LABEL_11;
      }

      v4 += v5 + 1;
      if (a1 != (_BYTE *)-256LL) {
        goto LABEL_3;
      }
    }
  }

  else
  {
LABEL_3:
    if (v4 < a1 + 256) {
      goto LABEL_4;
    }
  }

  uint64_t v6 = (_BYTE *)(v3 + 652);
LABEL_10:
  *uint64_t v6 = 0;
LABEL_11:
  for (uint64_t i = "\tlocalhost"; ; i += v9 + 1)
  {
    if ("\tlocalhost" == (char *)-256LL)
    {
      if (!i) {
        goto LABEL_22;
      }
    }

    else if (i >= "hForNetworkChanges" || i == 0LL)
    {
LABEL_22:
      LOWORD(v10) = 257;
      goto LABEL_26;
    }

    uint64_t v9 = *(unsigned __int8 *)i;
    if (!*i) {
      break;
    }
  }

  unsigned int v10 = (_DWORD)i - "\tlocalhost" + 1;
LABEL_26:
  *(_WORD *)(v3 + 20) = v10;
  *(_BYTE *)(*(void *)(v3 + 48) + 4LL) = 0;
  for (uint64_t j = "\tlocalhost"; ; j += v14 + 1)
  {
    if ("\tlocalhost" == (char *)-256LL)
    {
      if (!j) {
        goto LABEL_37;
      }
    }

    else if (j >= "hForNetworkChanges" || j == 0LL)
    {
LABEL_37:
      uint64_t v15 = (_BYTE *)(*(void *)(v3 + 48) + 4LL);
LABEL_38:
      _BYTE *v15 = 0;
      goto LABEL_39;
    }

    uint64_t v14 = *(unsigned __int8 *)j;
    if (!*j) {
      break;
    }
  }

  uint64_t v15 = (_BYTE *)(*(void *)(v3 + 48) + 4LL);
  memcpy(v15, "\tlocalhost", (unsigned __int16)((_WORD)j - (unsigned __int16)"\tlocalhost" + 1));
LABEL_39:
  *(_DWORD *)(v3 + memset(&v5[1], 0, 24) = DomainNameHashValue(*(void *)(v3 + 40));
  SetNewRData(v3 + 8, 0LL, 0LL, v16, v17, v18, v19, v20);
  return (void *)mDNS_Register((unsigned int *)mDNSStorage, v3);
}

uint64_t __mDNSMacOSXGetEtcHostsFD_block_invoke_4(uint64_t a1)
{
  return close(*(_DWORD *)(a1 + 32));
}

uint64_t __mDNSMacOSXGetEtcHostsFD_block_invoke_7( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (mDNS_LoggingEnabled == 1) {
    LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "mDNSMacOSXGetEtcHostsFD: Closing etchosts fd %d",  a4,  a5,  a6,  a7,  a8,  *(_DWORD *)(a1 + 32));
  }
  return close(*(_DWORD *)(a1 + 32));
}

uint64_t EtcHostsParseOneName(uint64_t result, int a2, uint64_t a3, void *a4)
{
  *a4 = 0LL;
  uint64_t result = (int)result;
  while (1)
  {
    unsigned int v4 = *(unsigned __int8 *)(a3 + result);
    if (v4 > 0x22) {
      break;
    }
    if (v4 != 9 && v4 != 32) {
      goto LABEL_13;
    }
LABEL_8:
    if (a2 == (_DWORD)++result) {
      return 0xFFFFFFFFLL;
    }
  }

  if (v4 == 44) {
    goto LABEL_8;
  }
  if (v4 == 35) {
    return 0xFFFFFFFFLL;
  }
LABEL_13:
  *a4 = a3 + result;
  uint64_t v5 = (int)result + 1;
  while (1)
  {
    uint64_t result = (result + 1);
    uint64_t v6 = v5;
    unsigned int v7 = *(unsigned __int8 *)(a3 + v5++);
    BOOL v8 = v7 > 0x2C;
    uint64_t v9 = (1LL << v7) & 0x100100000200LL;
    if (!v8 && v9 != 0)
    {
      *(_BYTE *)(a3 + v6) = 0;
      return result;
    }
  }

  return result;
}

uint64_t mDNSMacOSXCreateEtcHostsEntry( _BYTE *a1, uint64_t a2, unint64_t a3, char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
  {
    uint64_t v22 = (os_log_s *)mDNSLogCategory_Default;
    int v23 = "mDNSMacOSXCreateEtcHostsEntry: ERROR!! name NULL";
LABEL_17:
    LogMsgWithLevel(v22, OS_LOG_TYPE_DEFAULT, v23, (uint64_t)a4, a5, a6, a7, a8, v61);
    return 0LL;
  }

  if (!(a2 | a3))
  {
    uint64_t v22 = (os_log_s *)mDNSLogCategory_Default;
    int v23 = "mDNSMacOSXCreateEtcHostsEntry: ERROR!! sa and cname both NULL";
    goto LABEL_17;
  }

  if (a2)
  {
    int v12 = *(unsigned __int8 *)(a2 + 1);
    if (v12 != 2 && v12 != 30)
    {
      LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "mDNSMacOSXCreateEtcHostsEntry: ERROR!! sa with bad family %d",  (uint64_t)a4,  a5,  a6,  a7,  a8,  *(unsigned __int8 *)(a2 + 1));
      return 0LL;
    }
  }

  if (a4)
  {
    unsigned int v14 = if_nametoindex(a4);
    if (!v14)
    {
      LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "mDNSMacOSXCreateEtcHostsEntry: hosts entry %##s with invalid ifname %s",  v15,  v16,  v17,  v18,  v19,  (int)a1);
      return 0LL;
    }

    uint64_t v20 = v14;
    if (a2) {
      goto LABEL_12;
    }
LABEL_20:
    int v21 = 5;
    goto LABEL_21;
  }

  uint64_t v20 = -2LL;
  if (!a2) {
    goto LABEL_20;
  }
LABEL_12:
  if (*(_BYTE *)(a2 + 1) == 2) {
    int v21 = 1;
  }
  else {
    int v21 = 28;
  }
LABEL_21:
  unsigned int v25 = DomainNameHashValue((unint64_t)a1);
  uint64_t v26 = AuthGroupForName(a5, v25, a1);
  if (!v26 || (uint64_t v32 = v26[2]) == 0)
  {
LABEL_37:
    uint64_t result = (uint64_t)calloc(1uLL, 0x498uLL);
    if (result)
    {
      uint64_t v34 = result;
      mDNS_SetupResourceRecord(result, 0LL, v20, v21, 1u, 32, 4, (uint64_t)FreeEtcHosts, 0LL);
      unsigned int v35 = a1;
      if (a1 == (_BYTE *)-256LL)
      {
LABEL_40:
        while (v35)
        {
          uint64_t v36 = *v35;
          if (!*v35)
          {
            unsigned __int16 v42 = (_WORD)v35 - (_WORD)a1 + 1;
            uint64_t v37 = (_BYTE *)(v34 + 652);
            if (v42 > 0x100u) {
              goto LABEL_46;
            }
            __memcpy_chk(v37, a1, v42, 524LL);
            if (a2) {
              goto LABEL_47;
            }
            goto LABEL_56;
          }

          v35 += v36 + 1;
          if (a1 != (_BYTE *)-256LL) {
            goto LABEL_39;
          }
        }
      }

      else
      {
LABEL_39:
        if (v35 < a1 + 256) {
          goto LABEL_40;
        }
      }

      uint64_t v37 = (_BYTE *)(v34 + 652);
LABEL_46:
      *uint64_t v37 = 0;
      if (a2)
      {
LABEL_47:
        int v38 = *(unsigned __int8 *)(a2 + 1);
        uint64_t v39 = *(void *)(v34 + 48);
        BOOL v40 = v38 == 2;
        if (v38 == 2) {
          __int16 v41 = 4;
        }
        else {
          __int16 v41 = 16;
        }
        *(_WORD *)(v34 + 20) = v41;
        if (v40)
        {
          *(_DWORD *)(v39 + 4) = *(_DWORD *)(a2 + 4);
        }

        else
        {
          *(_DWORD *)(v39 + 4) = *(_DWORD *)(a2 + 8);
          *(_DWORD *)(*(void *)(v34 + 48) + 8LL) = *(_DWORD *)(a2 + 12);
          *(_DWORD *)(*(void *)(v34 + 48) + 12LL) = *(_DWORD *)(a2 + 16);
          *(_DWORD *)(*(void *)(v34 + 48) + 16LL) = *(_DWORD *)(a2 + 20);
        }
      }

      else
      {
LABEL_56:
        uint64_t v43 = (char *)(a3 + 256);
        uint64_t v44 = (char *)a3;
        if (a3 == -256LL) {
          goto LABEL_60;
        }
LABEL_57:
        __int16 v45 = 257;
        if (v44 < v43 && v44)
        {
          while (1)
          {
            uint64_t v46 = *v44;
            if (v46 > 0x3F)
            {
LABEL_65:
              __int16 v45 = 257;
              goto LABEL_67;
            }

            if (!*v44) {
              break;
            }
            v44 += v46 + 1;
            if (a3 != -256LL) {
              goto LABEL_57;
            }
LABEL_60:
            if (!v44) {
              goto LABEL_65;
            }
          }

          __int16 v45 = (_WORD)v44 - a3 + 1;
        }

uint64_t EtcHostsAddNewEntries(uint64_t a1, int a2)
{
  uint64_t v4 = 0LL;
  while (1)
  {
    uint64_t v39 = v4;
    uint64_t v5 = *(void **)(a1 + 8 * v4 + 24);
    if (v5) {
      break;
    }
LABEL_32:
    uint64_t v4 = v39 + 1;
    if (v39 == 498) {
      return 0LL;
    }
  }

  while (1)
  {
    BOOL v40 = v5;
    uint64_t v6 = (void *)v5[2];
    if (v6) {
      break;
    }
LABEL_31:
    uint64_t v5 = (void *)*v40;
    if (!*v40) {
      goto LABEL_32;
    }
  }

  uint64_t v7 = 0LL;
  while (1)
  {
    uint64_t v8 = (uint64_t)v6;
    uint64_t v6 = (void *)*v6;
    uint64_t v9 = AuthGroupForName((uint64_t)&unk_10015A438, *(_DWORD *)(v8 + 24), *(_BYTE **)(v8 + 40));
    if (!v9) {
      break;
    }
    uint64_t v10 = v9[2];
    if (!v10) {
      break;
    }
    if (!v7) {
      uint64_t v7 = v9[2];
    }
    while (1)
    {
      if (*(_DWORD *)(v10 + 24) == *(_DWORD *)(v8 + 24))
      {
        if (resource_records_have_same_dnssec_rr_category(*(void *)(v10 + 64), *(void *)(v8 + 64)))
        {
          if (*(unsigned __int16 *)(v10 + 12) == *(unsigned __int16 *)(v8 + 12)
            && *(unsigned __int16 *)(v10 + 14) == *(unsigned __int16 *)(v8 + 14)
            && *(unsigned __int16 *)(v10 + 20) == *(unsigned __int16 *)(v8 + 20)
            && *(_DWORD *)(v10 + 28) == *(_DWORD *)(v8 + 28))
          {
            unsigned __int16 v11 = (unsigned __int8 *)(v10 + 8);
            if (SameRDataBody( v10 + 8,  (unsigned __int16 *)(*(void *)(v8 + 48) + 4LL),  (uint64_t (*)(uint64_t, unsigned __int16 *))SameDomainName))
            {
              if (SameDomainNameBytes(*(_BYTE **)(v10 + 40), *(_BYTE **)(v8 + 40))
                && *(void *)(v10 + 32) == *(void *)(v8 + 32))
              {
                break;
              }
            }
          }
        }
      }

      uint64_t v10 = *(void *)v10;
      if (!v10) {
        goto LABEL_19;
      }
    }

    uint64_t v8 = v10;
    unsigned int v25 = "EtcHostsAddNewEntries: Skipping, not adding %s";
    if ((mDNS_LoggingEnabled & 1) == 0) {
      goto LABEL_27;
    }
LABEL_26:
    uint64_t v26 = (os_log_s *)mDNSLogCategory_Default;
    GetRRDisplayString_rdb(v11, (unsigned __int16 *)(*(void *)(v8 + 48) + 4LL), word_100164338);
    LogMsgWithLevel(v26, OS_LOG_TYPE_DEFAULT, v25, v27, v28, v29, v30, v31, (int)word_100164338);
LABEL_27:
    if (!v6) {
      goto LABEL_31;
    }
  }

uint64_t EtcHostsDeleteOldEntries(uint64_t a1, int a2)
{
  uint64_t v2 = 0LL;
  uint64_t v3 = FreeEtcHosts;
  do
  {
    uint64_t v43 = v2;
    uint64_t v4 = mDNSStorage[v2 + 787];
    if (v4)
    {
      while (2)
      {
        uint64_t v46 = (uint64_t *)v4;
        uint64_t v5 = *(void **)(v4 + 16);
        while (v5)
        {
          uint64_t v6 = (uint64_t)v5;
          uint64_t v5 = (void *)*v5;
          if (*(void (**)(uint64_t, uint64_t, int))(v6 + 104) == v3)
          {
            uint64_t v7 = AuthGroupForName(a1, *(_DWORD *)(v6 + 24), *(_BYTE **)(v6 + 40));
            if (v7 && (uint64_t v8 = v7[2]) != 0)
            {
              while (*(_DWORD *)(v8 + 24) != *(_DWORD *)(v6 + 24)
                   || !resource_records_have_same_dnssec_rr_category( *(void *)(v8 + 64),  *(void *)(v6 + 64))
                   || *(unsigned __int16 *)(v8 + 12) != *(unsigned __int16 *)(v6 + 12)
                   || *(unsigned __int16 *)(v8 + 14) != *(unsigned __int16 *)(v6 + 14)
                   || *(unsigned __int16 *)(v8 + 20) != *(unsigned __int16 *)(v6 + 20)
                   || *(_DWORD *)(v8 + 28) != *(_DWORD *)(v6 + 28)
                   || !SameRDataBody( v8 + 8,  (unsigned __int16 *)(*(void *)(v6 + 48) + 4LL),  (uint64_t (*)(uint64_t, unsigned __int16 *))SameDomainName)
                   || !SameDomainNameBytes(*(_BYTE **)(v8 + 40), *(_BYTE **)(v6 + 40)))
              {
                uint64_t v8 = *(void *)v8;
                if (!v8) {
                  goto LABEL_17;
                }
              }

              if (mDNS_LoggingEnabled == 1)
              {
                uint64_t v30 = (os_log_s *)mDNSLogCategory_Default;
                GetRRDisplayString_rdb( (unsigned __int8 *)(v6 + 8),  (unsigned __int16 *)(*(void *)(v6 + 48) + 4LL),  word_100164338);
                LogMsgWithLevel( v30,  OS_LOG_TYPE_DEFAULT,  "EtcHostsDeleteOldEntries: Old record %s found in new, skipping",  v31,  v32,  v33,  v34,  v35,  (int)word_100164338);
              }
            }

            else
            {
LABEL_17:
              if (a2)
              {
                if (mDNS_LoggingEnabled == 1)
                {
                  uint64_t v37 = (os_log_s *)mDNSLogCategory_Default;
                  GetRRDisplayString_rdb( (unsigned __int8 *)(v6 + 8),  (unsigned __int16 *)(*(void *)(v6 + 48) + 4LL),  word_100164338);
                  LogMsgWithLevel( v37,  OS_LOG_TYPE_DEFAULT,  "EtcHostsDeleteOldEntries: Record %s not found in new, deleting",  v38,  v39,  v40,  v41,  v42,  (int)word_100164338);
                }

                return 1LL;
              }

              uint64_t v9 = v3;
              if (v6 == v46[2])
              {
                uint64_t v10 = *(unsigned __int8 **)v6;
                if (*(void *)v6)
                {
                  unsigned __int16 v11 = *(unsigned __int8 **)v6;
                  do
                  {
                    if (*((void *)v11 + 12) == v6)
                    {
                      if (mDNS_LoggingEnabled == 1)
                      {
                        uint64_t v12 = (os_log_s *)mDNSLogCategory_Default;
                        GetRRDisplayString_rdb( v11 + 8,  (unsigned __int16 *)(*((void *)v11 + 6) + 4LL),  word_100164338);
                        LogMsgWithLevel( v12,  OS_LOG_TYPE_DEFAULT,  "EtcHostsDeleteOldEntries: Updating Resource Record %s to primary",  v13,  v14,  v15,  v16,  v17,  (int)word_100164338);
                      }

                      *((void *)v11 + 12) = v10;
                    }

                    else
                    {
                      uint64_t v18 = (os_log_s *)mDNSLogCategory_Default;
                      GetRRDisplayString_rdb(v11 + 8, (unsigned __int16 *)(*((void *)v11 + 6) + 4LL), word_100164338);
                      LogMsgWithLevel( v18,  OS_LOG_TYPE_DEFAULT,  "EtcHostsDeleteOldEntries: ERROR!! Resource Record %s not pointing to primary %##s",  v19,  v20,  v21,  v22,  v23,  (int)word_100164338);
                    }

                    unsigned __int16 v11 = *(unsigned __int8 **)v11;
                  }

                  while (v11);
                }
              }

              if (mDNS_LoggingEnabled == 1)
              {
                uint64_t v24 = (os_log_s *)mDNSLogCategory_Default;
                GetRRDisplayString_rdb( (unsigned __int8 *)(v6 + 8),  (unsigned __int16 *)(*(void *)(v6 + 48) + 4LL),  word_100164338);
                LogMsgWithLevel( v24,  OS_LOG_TYPE_DEFAULT,  "EtcHostsDeleteOldEntries: Deleting %s",  v25,  v26,  v27,  v28,  v29,  (int)word_100164338);
              }

              mDNS_Deregister_internal((uint64_t)mDNSStorage, v6, 0);
              uint64_t v3 = v9;
            }
          }
        }

        uint64_t v4 = *v46;
        if (*v46) {
          continue;
        }
        break;
      }
    }

    uint64_t v2 = v43 + 1;
  }

  while (v43 != 498);
  return 0LL;
}

uint64_t FlushAllCacheRecords( uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = (unsigned int *)result;
  uint64_t v9 = 0LL;
  uint64_t v10 = (_BYTE *)(result + 46976);
  do
  {
    uint64_t v21 = v9;
    unsigned __int16 v11 = *(void **)&v8[2 * v9 + 70];
    if (v11)
    {
      while (1)
      {
        uint64_t v12 = v11[2];
        if (v12) {
          break;
        }
LABEL_18:
        unsigned __int16 v11 = (void *)*v11;
        if (!v11) {
          goto LABEL_19;
        }
      }

      while (1)
      {
        if (*(void *)(v12 + 32)) {
          goto LABEL_17;
        }
        if (!RRTypeAnswersQuestionType(v12 + 8, 1u, 3LL, a4, a5, a6, a7, a8))
        {
          uint64_t result = RRTypeAnswersQuestionType(v12 + 8, 0x1Cu, 3LL, v13, v14, v15, v16, v17);
          if (!(_DWORD)result) {
            goto LABEL_17;
          }
        }

        uint64_t v18 = (os_log_s *)mDNSLogCategory_Default;
        if (gSensitiveLoggingEnabled == 1 && mDNSLogCategory_Default != mDNSLogCategory_State) {
          break;
        }
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_15;
        }
LABEL_16:
        uint64_t result = mDNS_PurgeCacheResourceRecord(v8, v12);
LABEL_17:
        uint64_t v12 = *(void *)v12;
        if (!v12) {
          goto LABEL_18;
        }
      }

      uint64_t v18 = (os_log_s *)mDNSLogCategory_Default_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_16;
      }
LABEL_15:
      GetRRDisplayString_rdb((unsigned __int8 *)(v12 + 8), (unsigned __int16 *)(*(void *)(v12 + 48) + 4LL), v10);
      *(_DWORD *)CFSocketContext buf = 141558275;
      uint64_t v23 = 1752392040LL;
      __int16 v24 = 2085;
      uint64_t v25 = v10;
      _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_DEFAULT,  "FlushAllCacheRecords: Purging Resourcerecord - record description: %{sensitive, mask.hash}s.",  buf,  0x16u);
      goto LABEL_16;
    }

uint64_t UpdateEtcHosts(uint64_t a1, uint64_t a2)
{
  return EtcHostsAddNewEntries(a2, 0);
}

void __mDNSMacOSXGetEtcHostsFD_block_invoke_5(id a1)
{
  int data = dispatch_source_get_data((dispatch_source_t)mDNSMacOSXGetEtcHostsFD_hostssrc);
  if (mDNS_LoggingEnabled == 1) {
    LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "mDNSMacOSXGetEtcHostsFD: /etc/hosts changed 0x%x",  v1,  v2,  v3,  v4,  v5,  data);
  }
  if ((data & 0x21) != 0)
  {
    dispatch_source_cancel((dispatch_source_t)mDNSMacOSXGetEtcHostsFD_hostssrc);
    if (mDNSMacOSXGetEtcHostsFD_hostssrc)
    {
      dispatch_release((dispatch_object_t)mDNSMacOSXGetEtcHostsFD_hostssrc);
      mDNSMacOSXGetEtcHostsFD_hostssrc = 0LL;
    }

    usleep(0xF4240u);
    dispatch_async((dispatch_queue_t)mDNSMacOSXGetEtcHostsFD_etcq, &__block_literal_global_466);
  }

  else if ((data & 2) != 0)
  {
    mDNSMacOSXUpdateEtcHosts();
  }

void mDNSMacOSXUpdateEtcHosts()
{
  uint64_t v0 = pthread_mutex_lock((pthread_mutex_t *)(mDNSStorage[0] + 616));
  *(_DWORD *)(mDNSStorage[0] + 680) = mDNSPlatformRawTime(v0, v1, v2, v3, v4, v5, v6, v7);
  mDNSMacOSXUpdateEtcHosts_internal();
  KQueueUnlock((uint64_t)"/etc/hosts changed", v8, v9, v10, v11, v12, v13, v14);
}

void __mDNSMacOSXGetEtcHostsFD_block_invoke_2(id a1)
{
  int data = dispatch_source_get_data((dispatch_source_t)mDNSMacOSXGetEtcHostsFD_etcsrc);
  char v2 = data;
  LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "mDNSMacOSXGetEtcHostsFD: /etc changed 0x%x",  v3,  v4,  v5,  v6,  v7,  data);
  if ((v2 & 0x21) != 0)
  {
    dispatch_source_cancel((dispatch_source_t)mDNSMacOSXGetEtcHostsFD_etcsrc);
    if (mDNSMacOSXGetEtcHostsFD_etcsrc)
    {
      dispatch_release((dispatch_object_t)mDNSMacOSXGetEtcHostsFD_etcsrc);
      mDNSMacOSXGetEtcHostsFD_etcsrc = 0LL;
    }

    dispatch_async((dispatch_queue_t)mDNSMacOSXGetEtcHostsFD_etcq, &__block_literal_global_459);
  }

  else if ((v2 & 2) != 0 && !mDNSMacOSXGetEtcHostsFD_hostssrc)
  {
    mDNSMacOSXUpdateEtcHosts();
  }

void PowerOn(uint64_t a1)
{
  if (*(void *)(*(void *)a1 + 600LL))
  {
    int v7 = time(0LL);
    mdns_power_cancel_all_events(@"com.apple.mDNSResponder");
    uint64_t v8 = *(void *)(*(void *)a1 + 600LL);
    uint64_t v9 = v8 - v7;
    if (v9 < 31)
    {
      uint64_t v10 = v7 - v8;
      if (v10 < 31)
      {
        if (mDNS_LoggingEnabled) {
          LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "PowerChanged PowerOn %d seconds late, device is an AppleTV running iOS so not re-sleeping",  v2,  v3,  v4,  v5,  v6,  v10);
        }
      }

      else if (mDNS_LoggingEnabled)
      {
        LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "PowerChanged PowerOn %d seconds late, assuming not maintenance wake",  v2,  v3,  v4,  v5,  v6,  v10);
      }
    }

    else if (mDNS_LoggingEnabled == 1)
    {
      LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "PowerChanged PowerOn %d seconds early, assuming not maintenance wake",  v2,  v3,  v4,  v5,  v6,  v9);
    }
  }

  if (*(_DWORD *)(mDNSStorage[0] + 584))
  {
    if (mDNS_LoggingEnabled == 1) {
      LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "Sleep Assertion is already being held. Will not attempt to get it again for %d seconds for %s",  v2,  v3,  v4,  v5,  v6,  16);
    }
  }

  else
  {
    uint64_t valuePtr = 0x4030000000000000LL;
    CFStringRef v11 = CFStringCreateWithCString(0LL, "mDNSResponder:maintenance", 0x8000100u);
    CFNumberRef v12 = CFNumberCreate(0LL, kCFNumberDoubleType, &valuePtr);
    CFMutableStringRef Mutable = CFDictionaryCreateMutable(0LL, 0LL, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    CFDictionarySetValue(Mutable, @"AssertType", @"PreventUserIdleSystemSleep");
    CFDictionarySetValue(Mutable, @"TimeoutSeconds", v12);
    CFDictionarySetValue(Mutable, @"AssertName", v11);
    IOPMAssertionCreateWithProperties(Mutable, (IOPMAssertionID *)(mDNSStorage[0] + 584));
    if (v11) {
      CFRelease(v11);
    }
    if (v12) {
      CFRelease(v12);
    }
    if (Mutable) {
      CFRelease(Mutable);
    }
    if (mDNS_LoggingEnabled == 1) {
      LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "Got an idle sleep assertion for %d seconds for %s",  v14,  v15,  v16,  v17,  v18,  16);
    }
  }

void RefreshSPSStatus(const __CFString *a1, const __CFArray *a2)
{
  *(void *)buffer = 0LL;
  uint64_t v16 = 0LL;
  if (!CFStringGetCString(a1, buffer, 16LL, 0x8000100u)) {
    buffer[0] = 0;
  }
  if (mDNS_LoggingEnabled == 1)
  {
    uint64_t v8 = (os_log_s *)mDNSLogCategory_Default;
    CFArrayGetCount(a2);
    LogMsgWithLevel( v8,  OS_LOG_TYPE_DEFAULT,  "RefreshSPSStatus: Updating SPS state for key %s, array count %d",  v9,  v10,  v11,  v12,  v13,  (int)buffer);
  }

  mDNSDynamicStoreSetConfig(5, buffer, a2, v3, v4, v5, v6, v7, v14);
}

CFTypeRef CopyNameFromKey(CFStringRef theString)
{
  ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings(0LL, theString, @"/");
  if (!ArrayBySeparatingStrings) {
    return 0LL;
  }
  uint64_t v2 = ArrayBySeparatingStrings;
  if (CFArrayGetCount(ArrayBySeparatingStrings) == 5)
  {
    uint64_t ValueAtIndex = CFArrayGetValueAtIndex(v2, 3LL);
    CFTypeRef v4 = CFRetain(ValueAtIndex);
  }

  else
  {
    CFTypeRef v4 = 0LL;
  }

  CFRelease(v2);
  return v4;
}

void GetRandomUUIDLabel(_BYTE *a1)
{
  uint64_t v2 = a1 + 64;
  uint64_t v3 = a1 + 1;
  char v4 = v9[0];
  if (v9[0]) {
    BOOL v5 = v3 >= v2;
  }
  else {
    BOOL v5 = 1;
  }
  if (!v5)
  {
    uint64_t v6 = &v9[1];
    do
    {
      *v3++ = v4;
      int v7 = *v6++;
      char v4 = v7;
      if (v7) {
        BOOL v8 = v3 >= v2;
      }
      else {
        BOOL v8 = 1;
      }
    }

    while (!v8);
  }

  *a1 = (_BYTE)v3 + ~(_BYTE)a1;
}

void mDNSPlatformSendWakeupPacket( uint64_t a1, const char *a2, const char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = *(void *)mDNSStorage[0];
  if (!*(void *)mDNSStorage[0])
  {
LABEL_6:
    uint64_t v13 = (os_log_s *)mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_ERROR)) {
        return;
      }
      *(_DWORD *)CFSocketContext buf = 134217984;
      uint64_t v19 = a1;
    }

    else
    {
      uint64_t v13 = (os_log_s *)mDNSLogCategory_Default_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_ERROR)) {
        return;
      }
      *(_DWORD *)CFSocketContext buf = 134217984;
      uint64_t v19 = a1;
    }

    _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_ERROR,  "GetInterfaceSupportsWakeOnLANPacket: Invalid interface id %p",  buf,  0xCu);
    return;
  }

  int v10 = a4;
  while (!*(void *)(v9 + 6480) || *(_DWORD *)(v9 + 6424) != (_DWORD)a1)
  {
    uint64_t v9 = *(void *)(v9 + 6384);
    if (!v9) {
      goto LABEL_6;
    }
  }

  if (*(_DWORD *)(v9 + 6412) == 2)
  {
    unsigned int v16 = -1;
    switch(a1)
    {
      case -5LL:
        unsigned int v16 = -4;
        goto LABEL_22;
      case -3LL:
        unsigned int v16 = -3;
        goto LABEL_22;
      case -2LL:
        goto LABEL_22;
      case 0LL:
        goto LABEL_20;
      default:
        unsigned int v16 = a1;
        if ((_DWORD)a1)
        {
LABEL_22:
          if (mDNS_LoggingEnabled == 1) {
            LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "mDNSSendWakeupPacket: Entered ethernet address[%s],ip_address[%s], interface_id[%d], iteration[%d]",  a4,  a5,  a6,  a7,  a8,  (int)a2);
          }
          xpc_object_t v17 = xpc_dictionary_create(0LL, 0LL, 0LL);
          xpc_dictionary_set_uint64(v17, "HelperMode", 6uLL);
          xpc_dictionary_set_uint64(v17, "interface_index", v16);
          xpc_dictionary_set_string(v17, "ethernet_address", a2);
          xpc_dictionary_set_string(v17, "ip_address", a3);
          xpc_dictionary_set_uint64(v17, "swp_iteration", v10);
          SendDict_ToServer(v17);
          if (v17) {
            xpc_release(v17);
          }
        }

        else
        {
LABEL_20:
          LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "mDNSPlatformSendWakeupPacket: ERROR!! Invalid InterfaceID %u",  a4,  a5,  a6,  a7,  a8,  0);
        }

        break;
    }
  }

uint64_t mDNSPlatformInterfaceIsD2D( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 == -5) {
    return 0LL;
  }
  if (a1 == -3) {
    return 1LL;
  }
  if (AWDLInterfaceID) {
    BOOL v9 = AWDLInterfaceID == a1;
  }
  else {
    BOOL v9 = 0;
  }
  if (v9 || WiFiAwareInterfaceID && WiFiAwareInterfaceID == a1) {
    return 1LL;
  }
  uint64_t v10 = *(void *)mDNSStorage[0];
  if (*(void *)mDNSStorage[0])
  {
    while (!*(void *)(v10 + 6480) || *(_DWORD *)(v10 + 6424) != (_DWORD)a1)
    {
      uint64_t v10 = *(void *)(v10 + 6384);
      if (!v10) {
        goto LABEL_17;
      }
    }

    return *(unsigned __int8 *)(v10 + 6403);
  }

  else
  {
LABEL_17:
    if (mDNS_LoggingEnabled == 1) {
      LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "mDNSPlatformInterfaceIsD2D: Invalid interface index %d",  a4,  a5,  a6,  a7,  a8,  a1);
    }
    return 0LL;
  }

uint64_t mDNSPlatformValidRecordForInterface( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a2) {
    goto LABEL_6;
  }
  uint64_t v10 = *(void *)mDNSStorage[0];
  if (!*(void *)mDNSStorage[0]) {
    goto LABEL_6;
  }
  while (!*(void *)(v10 + 6480) || *(_DWORD *)(v10 + 6424) != (_DWORD)a2)
  {
    uint64_t v10 = *(void *)(v10 + 6384);
    if (!v10) {
      goto LABEL_6;
    }
  }

  if (*(_BYTE *)(v10 + 6457))
  {
    unsigned int v16 = (os_log_s *)mDNSLogCategory_mDNS;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
    {
      uint64_t result = os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEBUG);
      if ((_DWORD)result)
      {
        uint64_t v18 = *(void *)(a1 + 40);
        if (v18)
        {
          uint64_t v19 = *(_BYTE **)(a1 + 40);
          if (v18 == -256)
          {
LABEL_26:
            while (v19)
            {
              uint64_t v20 = *v19;
              if (!*v19)
              {
                int v23 = (unsigned __int16)((_WORD)v19 - v18 + 1);
                goto LABEL_46;
              }

              v19 += v20 + 1;
              if (v18 != -256) {
                goto LABEL_25;
              }
            }
          }

          else
          {
LABEL_25:
          }

          int v23 = 257;
        }

        else
        {
          int v23 = 0;
        }

        goto LABEL_46;
      }
    }

    else
    {
      unsigned int v16 = (os_log_s *)mDNSLogCategory_mDNS_redacted;
      uint64_t result = os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEBUG);
      if ((_DWORD)result)
      {
        uint64_t v18 = *(void *)(a1 + 40);
        if (v18)
        {
          uint64_t v21 = *(_BYTE **)(a1 + 40);
          if (v18 == -256)
          {
LABEL_35:
            while (v21)
            {
              uint64_t v22 = *v21;
              if (!*v21)
              {
                int v23 = (unsigned __int16)((_WORD)v21 - v18 + 1);
                goto LABEL_46;
              }

              v21 += v22 + 1;
              if (v18 != -256) {
                goto LABEL_34;
              }
            }
          }

          else
          {
LABEL_34:
          }

          int v23 = 257;
        }

        else
        {
          int v23 = 0;
        }

uint64_t mDNSPlatformValidQuestionForInterface( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = *(void *)(a1 + 136);
  uint64_t v10 = *(void *)(a2 + 6256);
  uint64_t v12 = *(void *)(a2 + 6256);
  unsigned int v13 = *(_DWORD *)(a1 + 304);
  if (v12 == AWDLInterfaceID || v12 == WiFiAwareInterfaceID) {
    return (v13 >> 20) & 1;
  }
  else {
    return (v13 >> 17) & 1;
  }
}

char *_mrcs_dns_proxy_copy_description( uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  __int128 v23 = 0u;
  __int128 v24 = 0u;
  __int128 v21 = 0u;
  __int128 v22 = 0u;
  __int128 v19 = 0u;
  __int128 v20 = 0u;
  *(_OWORD *)char __s1 = 0u;
  __int128 v18 = 0u;
  unint64_t v16 = 0LL;
  if (v16 > 0x7F)
  {
    uint64_t v11 = v16 + 1;
    if (v16 == -1LL) {
      goto LABEL_9;
    }
    uint64_t v12 = (char *)malloc(v16 + 1);
    if (!v12) {
      goto LABEL_9;
    }
    BOOL v8 = v12;
    if (_mrcs_dns_proxy_print_description(a1, a2, v12, v11, 0LL, 0LL, v13, v14))
    {
LABEL_10:
      free(v8);
      return 0LL;
    }
  }

  else
  {
    BOOL v8 = strdup(__s1);
    if (!v8)
    {
LABEL_9:
      __break(1u);
      goto LABEL_10;
    }
  }

  return v8;
}

void _mrcs_dns_proxy_finalize(void *a1)
{
  char v4 = a1 + 5;
  uint64_t v2 = (char *)a1[5];
  unint64_t v3 = v4[1];
  if (v3)
  {
    uint64_t v5 = 0LL;
    for (unint64_t i = 0LL; i < v3; ++i)
    {
      if (*(void *)&v2[v5])
      {
        free(*(void **)&v2[v5]);
        uint64_t v2 = (char *)a1[5];
        unint64_t v3 = a1[6];
        *(void *)&v2[v5] = 0LL;
      }

      v5 += 16LL;
    }
  }

  else if (!v2)
  {
    goto LABEL_9;
  }

  free(v2);
  a1[5] = 0LL;
LABEL_9:
  int v7 = (void *)a1[7];
  if (v7)
  {
    free(v7);
    a1[7] = 0LL;
  }

uint64_t _mrcs_dns_proxy_print_description( uint64_t a1, int a2, char *a3, uint64_t a4, void *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v48 = a3;
  uint64_t v12 = (uint64_t)&a3[a4];
  if (a2)
  {
    int v13 = mdns_snprintf_add( &v48,  v12,  "<%s: %p>: ",  a4,  (uint64_t)a5,  a6,  a7,  a8,  *(void *)(*(void *)(a1 + 16) + 8LL));
    if (v13 < 0) {
      return 4294960596LL;
    }
    uint64_t v14 = v13 & ~(v13 >> 31);
  }

  else
  {
    uint64_t v14 = 0LL;
  }

  int v15 = mdns_snprintf_add(&v48, v12, "input interfaces: {", a4, (uint64_t)a5, a6, a7, a8, v46);
  if (v15 < 0) {
    return 4294960596LL;
  }
  uint64_t v47 = (void *)a6;
  uint64_t v21 = v14 + (v15 & ~(v15 >> 31));
  if (*(void *)(a1 + 48))
  {
    uint64_t v22 = 0LL;
    unint64_t v23 = 0LL;
    __int128 v24 = "";
    do
    {
      unsigned int v25 = mdns_snprintf_add(&v48, v12, "%s%s/%u", v16, v17, v18, v19, v20, (char)v24);
      if ((v25 & 0x80000000) != 0) {
        return 4294960596LL;
      }
      v21 += v25;
      ++v23;
      v22 += 16LL;
      __int128 v24 = ", ";
    }

    while (v23 < *(void *)(a1 + 48));
  }

  uint64_t v26 = *(const char **)(a1 + 56);
  if (!v26) {
    uint64_t v26 = "";
  }
  int v27 = mdns_snprintf_add(&v48, v12, "}, output interface: %s/%u", v16, v17, v18, v19, v20, (char)v26);
  if (v27 < 0) {
    return 4294960596LL;
  }
  uint64_t v33 = v21 + (v27 & ~(v27 >> 31));
  if (!*(_BYTE *)(a1 + 76)) {
    goto LABEL_19;
  }
  uint64_t v51 = *(void *)(a1 + 28);
  int v52 = *(_DWORD *)(a1 + 36);
  int v53 = 0;
  *(_OWORD *)uint64_t v49 = 0u;
  memset(v50, 0, sizeof(v50));
  int v34 = inet_ntop(30, &v51, v49, 0x2Eu);
  char v40 = (char)v34;
  if (!v34)
  {
    if (*__error())
    {
      uint64_t result = *__error();
      if ((_DWORD)result) {
        return result;
      }
      goto LABEL_17;
    }

    return 4294960596LL;
  }

char *_mrcs_dns_proxy_manager_copy_description( uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  __int128 v48 = 0u;
  __int128 v49 = 0u;
  __int128 v46 = 0u;
  __int128 v47 = 0u;
  __int128 v44 = 0u;
  __int128 v45 = 0u;
  __int128 v42 = 0u;
  __int128 v43 = 0u;
  __int128 v40 = 0u;
  __int128 v41 = 0u;
  __int128 v38 = 0u;
  __int128 v39 = 0u;
  __int128 v36 = 0u;
  __int128 v37 = 0u;
  __int128 v34 = 0u;
  __int128 v35 = 0u;
  __int128 v32 = 0u;
  __int128 v33 = 0u;
  __int128 v30 = 0u;
  __int128 v31 = 0u;
  __int128 v28 = 0u;
  __int128 v29 = 0u;
  __int128 v26 = 0u;
  __int128 v27 = 0u;
  __int128 v24 = 0u;
  __int128 v25 = 0u;
  __int128 v22 = 0u;
  __int128 v23 = 0u;
  __int128 v20 = 0u;
  __int128 v21 = 0u;
  *(_OWORD *)char __s1 = 0u;
  __int128 v19 = 0u;
  unint64_t v17 = 0LL;
  if (v17 > 0x1FF)
  {
    uint64_t v11 = v17 + 1;
    if (v17 == -1LL) {
      goto LABEL_9;
    }
    uint64_t v12 = (char *)malloc(v17 + 1);
    if (!v12) {
      goto LABEL_9;
    }
    BOOL v8 = v12;
    if (_mrcs_dns_proxy_manager_print_description(a1, a2, v12, v11, 0LL, v13, v14, v15))
    {
LABEL_10:
      free(v8);
      return 0LL;
    }
  }

  else
  {
    BOOL v8 = strdup(__s1);
    if (!v8)
    {
LABEL_9:
      __break(1u);
      goto LABEL_10;
    }
  }

  return v8;
}

void _mrcs_dns_proxy_manager_finalize(uint64_t a1)
{
  uint64_t v2 = *(const void **)(a1 + 24);
  if (v2)
  {
    CFRelease(v2);
    *(void *)(a1 + memset(&v5[1], 0, 24) = 0LL;
  }

uint64_t _mrcs_dns_proxy_manager_print_description( uint64_t a1, int a2, char *a3, uint64_t a4, void *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  __int128 v36 = a3;
  uint64_t v10 = (uint64_t)&a3[a4];
  if (a2)
  {
    int v11 = mdns_snprintf_add( &v36,  v10,  "<%s: %p>: ",  a4,  (uint64_t)a5,  a6,  a7,  a8,  *(void *)(*(void *)(a1 + 16) + 8LL));
    if (v11 < 0) {
      return 4294960596LL;
    }
    uint64_t v12 = v11 & ~(v11 >> 31);
  }

  else
  {
    uint64_t v12 = 0LL;
  }

  unsigned int v13 = mdns_snprintf_add(&v36, v10, "{", a4, (uint64_t)a5, a6, a7, a8, v32);
  if ((v13 & 0x80000000) != 0) {
    return 4294960596LL;
  }
  uint64_t v14 = v12 + v13;
  CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 24));
  if (Count >= 1)
  {
    CFIndex v21 = Count;
    CFIndex v22 = 0LL;
    do
    {
      __int128 v23 = v22 ? "," : "";
      unsigned int v24 = mdns_snprintf_add(&v36, v10, "%s\n\t", v16, v17, v18, v19, v20, (char)v23);
      if ((v24 & 0x80000000) != 0) {
        return 4294960596LL;
      }
      unsigned int v25 = v24;
      uint64_t v34 = 0LL;
      uint64_t v35 = 0LL;
      uint64_t ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 24), v22);
      uint64_t result = _mrcs_dns_proxy_print_description( (uint64_t)ValueAtIndex,  0,  v36,  v10 - (void)v36,  &v35,  (uint64_t)&v34,  v27,  v28);
      if ((_DWORD)result) {
        return result;
      }
      v36 += v35;
      v14 += v25 + v34;
    }

    while (v21 != ++v22);
  }

  int v30 = mdns_snprintf_add(&v36, v10, "\n}", v16, v17, v18, v19, v20, v33);
  if (v30 < 0) {
    return 4294960596LL;
  }
  if (!a5) {
    return 0LL;
  }
  int v31 = v30;
  uint64_t result = 0LL;
  *a5 = v14 + (v31 & ~(v31 >> 31));
  return result;
}

uint64_t mrcs_dns_proxy_create(int *a1)
{
  uint64_t v2 = _os_object_alloc(&OBJC_CLASS___OS_mrcs_dns_proxy, 80LL);
  uint64_t v3 = v2;
  if (v2)
  {
    char v4 = &_mrcs_dns_proxy_kind;
    *(void *)(v2 + 16) = &_mrcs_dns_proxy_kind;
    do
    {
      uint64_t v5 = (void (*)(uint64_t))v4[2];
      if (v5) {
        v5(v3);
      }
      char v4 = (_UNKNOWN **)*v4;
    }

    while (v4);
  }

  if (a1)
  {
    if (v3) {
      int v6 = 0;
    }
    else {
      int v6 = -6728;
    }
    *a1 = v6;
  }

  return v3;
}

char *mrcs_dns_proxy_set_output_interface(uint64_t a1, unsigned int a2)
{
  *(_DWORD *)(a1 + 64) = a2;
  uint64_t v3 = *(void **)(a1 + 56);
  if (v3)
  {
    free(v3);
    *(void *)(a1 + 56) = 0LL;
    a2 = *(_DWORD *)(a1 + 64);
  }

  uint64_t result = mdns_system_interface_index_to_name(a2);
  *(void *)(a1 + 56) = result;
  return result;
}

uint64_t mrcs_dns_proxy_set_nat64_prefix(uint64_t a1, void *__src, unint64_t a3)
{
  *((void *)&v4 + 1) = a3;
  *(void *)&__int128 v4 = a3 - 32;
  unint64_t v3 = v4 >> 3;
  if (v3 > 8 || ((0x11Fu >> v3) & 1) == 0) {
    return 4294960553LL;
  }
  char v6 = a3;
  int v9 = dword_10010014C[v3];
  *(void *)(a1 + 2_Block_object_dispose(va, 8) = 0LL;
  uint64_t v10 = a1 + 28;
  *(_DWORD *)(a1 + 36) = 0;
  unint64_t v11 = a3 >> 3;
  if (a3 >= 8) {
    memcpy((void *)(a1 + 28), __src, a3 >> 3);
  }
  if ((v6 & 7) != 0) {
    *(_BYTE *)(v10 + v11) = *(_BYTE *)(v10 + v11) & ~(-1 << (8 - (v6 & 7))) | *((_BYTE *)__src + v11) & (-1 << (8 - (v6 & 7)));
  }
  uint64_t result = 0LL;
  *(_DWORD *)(a1 + memset(&v5[1], 0, 24) = v9;
  *(_BYTE *)(a1 + 76) = 1;
  return result;
}

uint64_t ___mrcs_dns_proxy_manager_conflicts_with_proxy_block_invoke(uint64_t a1, uint64_t a2)
{
  unint64_t v2 = *(void *)(a2 + 48);
  if (!v2) {
    return 1LL;
  }
  uint64_t v4 = 0LL;
  uint64_t v5 = *(void *)(a1 + 32);
  unint64_t v6 = *(void *)(v5 + 48);
  BOOL v7 = 1;
  do
  {
    if (v6)
    {
      int v8 = *(_DWORD *)(*(void *)(a2 + 40) + 16 * v4 + 8);
      uint64_t v9 = *(void *)(v5 + 40);
      if (*(_DWORD *)(v9 + 8) == v8) {
        break;
      }
      unint64_t v10 = 0LL;
      unint64_t v11 = (int *)(v9 + 24);
      while (v6 - 1 != v10)
      {
        int v12 = *v11;
        v11 += 4;
        ++v10;
        if (v12 == v8)
        {
          if (v10 < v6) {
            goto LABEL_10;
          }
          break;
        }
      }
    }

    BOOL v7 = ++v4 < v2;
  }

  while (v4 != v2);
LABEL_10:
  if (!v7) {
    return 1LL;
  }
  if (*(_DWORD *)(a2 + 64) == *(_DWORD *)(v5 + 64))
  {
    BOOL v13 = *(_BYTE *)(a2 + 76) != 0;
    uint64_t v14 = (unsigned int *)(a2 + 24);
    if (!*(_BYTE *)(a2 + 76)) {
      uint64_t v14 = 0LL;
    }
    uint64_t v15 = (unsigned int *)(v5 + 24);
    if (!*(_BYTE *)(v5 + 76))
    {
      uint64_t v15 = 0LL;
      BOOL v13 = 0;
    }

    if (v14 == v15)
    {
      if (!v13) {
        return 1LL;
      }
    }

    else
    {
      if (!v13) {
        return 0LL;
      }
      size_t v16 = *v14;
      if ((_DWORD)v16 != *v15) {
        return 0LL;
      }
      BOOL v17 = (v16 - 4) < 5 || (_DWORD)v16 == 12;
      if (!v17 || memcmp(v14 + 1, v15 + 1, v16)) {
        return 0LL;
      }
    }
  }

  return 0LL;
}

uint64_t mrcs_dns_proxy_manager_get_proxy_by_input_interface(const __CFArray *a1, int a2)
{
  uint64_t v6 = 0LL;
  BOOL v7 = &v6;
  uint64_t v8 = 0x2000000000LL;
  uint64_t v9 = 0LL;
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000LL;
  v4[2] = __mrcs_dns_proxy_manager_get_proxy_by_input_interface_block_invoke;
  v4[3] = &unk_10013C598;
  int v5 = a2;
  v4[4] = &v6;
  mdns_cfarray_enumerate(a1, (uint64_t)v4);
  uint64_t v2 = v7[3];
  _Block_object_dispose(&v6, 8);
  return v2;
}

BOOL __mrcs_dns_proxy_manager_get_proxy_by_input_interface_block_invoke(uint64_t a1, uint64_t a2)
{
  unint64_t v2 = *(void *)(a2 + 48);
  if (v2)
  {
    int v3 = *(_DWORD *)(a1 + 40);
    uint64_t v4 = *(void *)(a2 + 40);
    if (*(_DWORD *)(v4 + 8) == v3)
    {
LABEL_7:
      *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = a2;
    }

    else
    {
      unint64_t v5 = 0LL;
      uint64_t v6 = (int *)(v4 + 24);
      while (v2 - 1 != v5)
      {
        int v7 = *v6;
        v6 += 4;
        ++v5;
        if (v7 == v3)
        {
          if (v5 >= v2) {
            return *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) == 0LL;
          }
          goto LABEL_7;
        }
      }
    }
  }

  return *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) == 0LL;
}

void _mdns_client_finalize(void *a1)
{
  int v3 = a1 + 4;
  uint64_t v2 = a1[4];
  if (v2)
  {
    uint64_t v4 = a1[5];
    if (v4)
    {
      unint64_t v5 = (dispatch_queue_s *)a1[3];
      if (v5)
      {
        v7[0] = _NSConcreteStackBlock;
        v7[1] = 0x40000000LL;
        void v7[2] = ___mdns_client_finalize_block_invoke;
        v7[3] = &__block_descriptor_tmp_3_4070;
        v7[4] = v4;
        void v7[5] = v2;
        dispatch_async(v5, v7);
      }
    }
  }

  *int v3 = 0LL;
  v3[1] = 0LL;
  uint64_t v6 = (dispatch_object_s *)a1[3];
  if (v6)
  {
    dispatch_release(v6);
    a1[3] = 0LL;
  }

uint64_t ___mdns_client_finalize_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(a1 + 32))(*(void *)(a1 + 40));
}

void mdns_client_replace(void **a1, void *object)
{
  if (object) {
    os_retain(object);
  }
  if (*a1) {
    os_release(*a1);
  }
  *a1 = object;
}

void mdns_client_set_queue(uint64_t a1, dispatch_object_t object)
{
  if (!*(_BYTE *)(a1 + 49))
  {
    if (object) {
      dispatch_retain(object);
    }
    uint64_t v4 = *(dispatch_object_s **)(a1 + 24);
    if (v4) {
      dispatch_release(v4);
    }
    *(void *)(a1 + memset(&v5[1], 0, 24) = object;
  }

void mdns_client_activate(uint64_t a1)
{
  *(_BYTE *)(a1 + 49) = 1;
  uint64_t v2 = os_retain((void *)a1);
  int v3 = (dispatch_queue_s *)(*(uint64_t (**)(void *))(*(void *)(a1 + 16) + 48LL))(v2);
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000LL;
  block[2] = __mdns_client_activate_block_invoke;
  block[3] = &__block_descriptor_tmp_4088;
  void block[4] = a1;
  dispatch_async(v3, block);
}

void __mdns_client_activate_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (!*(_BYTE *)(v1 + 48))
  {
    uint64_t v2 = *(void (**)(void))(*(void *)(v1 + 16) + 64LL);
    uint64_t v3 = *(void *)(a1 + 32);
    if (v2)
    {
      v2(*(void *)(a1 + 32));
      uint64_t v3 = *(void *)(a1 + 32);
    }

    *(_BYTE *)(v1 + 4_Block_object_dispose(va, 8) = 1;
    uint64_t v1 = v3;
  }

  os_release((void *)v1);
}

void mdns_client_invalidate(uint64_t a1)
{
  *(_BYTE *)(a1 + 49) = 1;
  uint64_t v2 = os_retain((void *)a1);
  uint64_t v3 = (dispatch_queue_s *)(*(uint64_t (**)(void *))(*(void *)(a1 + 16) + 48LL))(v2);
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000LL;
  block[2] = __mdns_client_invalidate_block_invoke;
  block[3] = &__block_descriptor_tmp_2_4091;
  void block[4] = a1;
  dispatch_async(v3, block);
}

void __mdns_client_invalidate_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (*(_BYTE *)(v1 + 48) != 2)
  {
    uint64_t v2 = *(void (**)(void))(*(void *)(v1 + 16) + 72LL);
    uint64_t v3 = *(void *)(a1 + 32);
    if (v2)
    {
      v2(*(void *)(a1 + 32));
      uint64_t v3 = *(void *)(a1 + 32);
    }

    *(_BYTE *)(v1 + 4_Block_object_dispose(va, 8) = 2;
    uint64_t v1 = v3;
  }

  os_release((void *)v1);
}

uint64_t _dnssec_obj_rr_validator_compare()
{
  return 2LL;
}

void _dnssec_obj_rr_validator_finalize(void *a1)
{
  unint64_t v2 = a1[3];
  if (v2)
  {
    for (unint64_t i = 0LL; i < v2; ++i)
    {
      uint64_t v4 = *(void **)(a1[2] + 8 * i);
      if (v4)
      {
        ref_count_obj_release(v4);
        unint64_t v2 = a1[3];
        *(void *)(a1[2] + 8 * i) = 0LL;
      }
    }
  }

  unint64_t v5 = (void *)a1[2];
  if (v5)
  {
    free(v5);
    a1[2] = 0LL;
  }

  unint64_t v6 = a1[5];
  if (v6)
  {
    for (unint64_t j = 0LL; j < v6; ++j)
    {
      uint64_t v8 = *(void **)(a1[4] + 8 * j);
      if (v8)
      {
        ref_count_obj_release(v8);
        unint64_t v6 = a1[5];
        *(void *)(a1[4] + 8 * j) = 0LL;
      }
    }
  }

  uint64_t v9 = (void *)a1[4];
  if (v9)
  {
    free(v9);
    a1[4] = 0LL;
  }

  unint64_t v10 = a1[7];
  if (v10)
  {
    for (unint64_t k = 0LL; k < v10; ++k)
    {
      int v12 = *(void **)(a1[6] + 8 * k);
      if (v12)
      {
        ref_count_obj_release(v12);
        unint64_t v10 = a1[7];
        *(void *)(a1[6] + 8 * k) = 0LL;
      }
    }
  }

  BOOL v13 = (void *)a1[6];
  if (v13)
  {
    free(v13);
    a1[6] = 0LL;
  }

  unint64_t v14 = a1[9];
  if (v14)
  {
    for (unint64_t m = 0LL; m < v14; ++m)
    {
      size_t v16 = *(void **)(a1[8] + 8 * m);
      if (v16)
      {
        ref_count_obj_release(v16);
        unint64_t v14 = a1[9];
        *(void *)(a1[8] + 8 * m) = 0LL;
      }
    }
  }

  BOOL v17 = (void *)a1[8];
  if (v17)
  {
    free(v17);
    a1[8] = 0LL;
  }

  unint64_t v18 = a1[12];
  if (v18)
  {
    for (unint64_t n = 0LL; n < v18; ++n)
    {
      uint64_t v20 = *(void **)(a1[10] + 8 * n);
      if (v20)
      {
        ref_count_obj_release(v20);
        *(void *)(a1[10] + 8 * n) = 0LL;
        unint64_t v18 = a1[12];
      }
    }
  }

  CFIndex v21 = (void *)a1[10];
  if (v21)
  {
    free(v21);
    a1[10] = 0LL;
  }

void *dnssec_obj_rr_validator_create( _DWORD **a1, size_t a2, _DWORD **a3, size_t a4, _DWORD **a5, size_t a6, _DWORD **a7, size_t a8, _DWORD **a9, size_t a10, _DWORD *a11)
{
  uint64_t result = calloc(1uLL, 0x68uLL);
  if (!result) {
    goto LABEL_44;
  }
  uint64_t v20 = result;
  size_t v49 = a6;
  size_t v21 = a8;
  __int128 v23 = &_dnssec_obj_rr_validator_kind;
  result[1] = &_dnssec_obj_rr_validator_kind;
  do
  {
    unsigned int v24 = (uint64_t (*)(void *))v23[2];
    if (v24) {
      uint64_t result = (void *)v24(v20);
    }
    __int128 v23 = (_UNKNOWN **)*v23;
  }

  while (v23);
  ++*(_DWORD *)v20;
  if (!a2)
  {
    uint64_t v51 = 0LL;
    size_t v25 = v21;
    if (a4) {
      goto LABEL_10;
    }
LABEL_20:
    __int128 v48 = 0LL;
    size_t v26 = v49;
    if (v49) {
      goto LABEL_13;
    }
LABEL_21:
    uint64_t v50 = 0LL;
    if (v25) {
      goto LABEL_16;
    }
LABEL_22:
    uint64_t v27 = 0LL;
    goto LABEL_23;
  }

  uint64_t result = (void *)a2;
  if (a2 >> 61) {
    goto LABEL_44;
  }
  size_t v25 = v21;
  uint64_t result = calloc(a2, 8uLL);
  uint64_t v51 = result;
  if (!result) {
    goto LABEL_44;
  }
  if (!a4) {
    goto LABEL_20;
  }
LABEL_10:
  size_t v26 = v49;
  if (a4 >> 61) {
    goto LABEL_44;
  }
  uint64_t result = calloc(a4, 8uLL);
  __int128 v48 = result;
  if (!result) {
    goto LABEL_44;
  }
  if (!v49) {
    goto LABEL_21;
  }
LABEL_13:
  if (v26 >> 61) {
    goto LABEL_44;
  }
  uint64_t result = calloc(v26, 8uLL);
  uint64_t v50 = result;
  if (!result) {
    goto LABEL_44;
  }
  if (!v25) {
    goto LABEL_22;
  }
LABEL_16:
  if (v25 >> 61) {
    goto LABEL_44;
  }
  uint64_t result = calloc(v25, 8uLL);
  uint64_t v27 = result;
  if (!result) {
    goto LABEL_44;
  }
LABEL_23:
  uint64_t result = (void *)a10;
  if (a10)
  {
    if (a10 >> 61) {
      goto LABEL_44;
    }
    size_t v47 = a2;
    size_t v28 = a4;
    size_t v29 = v26;
    size_t v30 = v25;
    int v31 = v27;
    uint64_t result = calloc(a10, 8uLL);
    uint64_t v27 = v31;
    size_t v25 = v30;
    size_t v26 = v29;
    a4 = v28;
    a2 = v47;
    if (!result)
    {
LABEL_44:
      __break(1u);
      return result;
    }
  }

  if (a2)
  {
    char v32 = v51;
    size_t v33 = a2;
    do
    {
      uint64_t v34 = *a1++;
      *v32++ = v34;
      ++*v34;
      --v33;
    }

    while (v33);
  }

  if (a4)
  {
    uint64_t v35 = v48;
    size_t v36 = a4;
    do
    {
      __int128 v37 = *a3++;
      *v35++ = v37;
      ++*v37;
      --v36;
    }

    while (v36);
  }

  if (v26)
  {
    __int128 v38 = v50;
    size_t v39 = v26;
    do
    {
      __int128 v40 = *a5++;
      *v38++ = v40;
      ++*v40;
      --v39;
    }

    while (v39);
  }

  if (v25)
  {
    __int128 v41 = v27;
    size_t v42 = v25;
    do
    {
      __int128 v43 = *a7++;
      *v41++ = v43;
      ++*v43;
      --v42;
    }

    while (v42);
  }

  if (a10)
  {
    __int128 v44 = result;
    size_t v45 = a10;
    do
    {
      __int128 v46 = *a9++;
      *v44++ = v46;
      ++*v46;
      --v45;
    }

    while (v45);
  }

  v20[2] = v51;
  v20[3] = a2;
  void v20[4] = v48;
  v20[5] = a4;
  v20[6] = v50;
  v20[7] = v26;
  v20[8] = v27;
  v20[9] = v25;
  v20[10] = result;
  v20[12] = a10;
  *((_DWORD *)v20 + 22) = 0;
  ++*(_DWORD *)v20;
  if (a11) {
    *a11 = 0;
  }
  ref_count_obj_release(v20);
  return v20;
}

uint64_t dnssec_obj_rr_validator_validate_rrset(uint64_t a1, int *a2)
{
  int v20 = 0;
  if (!*(void *)(a1 + 24))
  {
    uint64_t v9 = 0LL;
    int v18 = -89888;
    goto LABEL_39;
  }

  if (*(_WORD *)(**(void **)(a1 + 16) + 32LL) != 48)
  {
    uint64_t v9 = dnssec_obj_rr_validator_validate_rrset_with_key_tag((void *)a1, 0, 0LL, &v20);
    if (!a2) {
      return v9;
    }
    goto LABEL_40;
  }

  if (*(void *)(a1 + 96))
  {
    int v22 = -6700;
    if (*(void *)(a1 + 40))
    {
      uint64_t v4 = 0LL;
      int v5 = *(_DWORD *)(a1 + 88);
      while (1)
      {
        uint64_t v6 = *(void *)(*(void *)(a1 + 80) + 8 * v4);
        uint64_t v7 = *(void *)(v6 + 16);
        if (*(_WORD *)(v7 + 32) == 43) {
          unsigned int v8 = bswap32(**(unsigned __int16 **)(v7 + 24)) >> 16;
        }
        else {
          unsigned int v8 = *(unsigned __int16 *)(v7 + 80);
        }
        size_t v21 = 0LL;
        uint64_t v9 = dnssec_obj_rr_validator_validate_rrset_with_key_tag((void *)a1, v8, &v21, &v22);
        if ((_DWORD)v9 != 1) {
          goto LABEL_18;
        }
        unint64_t v10 = v21;
        int v11 = time(0LL);
        if (v11 - *(_DWORD *)(v6 + 24) < 0 || *(_DWORD *)(v6 + 28) - v11 < 0) {
          break;
        }
        uint64_t v12 = *(void *)(v6 + 16);
        if (*(_WORD *)(v12 + 32) == 43)
        {
        }

        else if (ref_count_obj_compare(v12, (uint64_t)v10, 1LL))
        {
          break;
        }

        int v13 = 0;
        uint64_t v9 = 1LL;
LABEL_17:
        int v22 = v13;
LABEL_18:
        if (v21) {
          ref_count_obj_release(v21);
        }
        BOOL v14 = (_DWORD)v9 != 1;
        if (v5) {
          BOOL v14 = (_DWORD)v9 == 0;
        }
      }

      uint64_t v9 = 3LL;
      int v13 = -89893;
      goto LABEL_17;
    }

    goto LABEL_43;
  }

  if (*(void *)(a1 + 72))
  {
    int v22 = -6700;
    if (!*(void *)(a1 + 40))
    {
LABEL_43:
      uint64_t v9 = 0LL;
      int v18 = -89889;
      goto LABEL_39;
    }

    unint64_t v15 = 0LL;
    do
    {
      uint64_t v16 = *(void *)(*(void *)(a1 + 64) + 8 * v15);
      unsigned int v17 = bswap32(**(unsigned __int16 **)(v16 + 24)) >> 16;
      size_t v21 = 0LL;
      uint64_t v9 = dnssec_obj_rr_validator_validate_rrset_with_key_tag((void *)a1, v17, &v21, &v22);
      if ((_DWORD)v9 == 1)
      {
        else {
          uint64_t v9 = 3LL;
        }
      }

      if (v21) {
        ref_count_obj_release(v21);
      }
      ++v15;
    }

    while (v15 < *(void *)(a1 + 72) && !(_DWORD)v9);
LABEL_38:
    int v18 = v22;
  }

  else
  {
    uint64_t v9 = 0LL;
    int v18 = -89892;
  }

uint64_t dnssec_obj_rr_validator_validate_rrset_with_key_tag(void *a1, int a2, void *a3, _DWORD *a4)
{
  if (!a1[5])
  {
    uint64_t v35 = 0LL;
    int v99 = -89889;
LABEL_107:
    int v106 = v99;
    goto LABEL_42;
  }

  if (!a1[7])
  {
    uint64_t v35 = 0LL;
    int v99 = -89890;
    goto LABEL_107;
  }

  uint64_t v6 = a1[3];
  if (!v6)
  {
    int v100 = (os_log_s *)mDNSLogCategory_DNSSEC;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_DNSSEC == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC, OS_LOG_TYPE_FAULT))
      {
LABEL_117:
        int v106 = -89891;
        uint64_t v35 = 3LL;
        goto LABEL_42;
      }
    }

    else
    {
      int v100 = (os_log_s *)mDNSLogCategory_DNSSEC_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC_redacted, OS_LOG_TYPE_FAULT)) {
        goto LABEL_117;
      }
    }

    *(_DWORD *)CFSocketContext buf = 136447234;
    *(void *)&uint8_t buf[4] = "count > 0";
    *(_WORD *)&buf[12] = 2082;
    *(void *)&buf[14] = "";
    *(_WORD *)&_BYTE buf[22] = 2082;
    *(void *)&_BYTE buf[24] = "/Library/Caches/com.apple.xbs/Sources/mDNSResponder/mDNSMacOSX/dnssec_v2/dnssec_objs/dnssec_obj_rr.c";
    LOWORD(v110) = 1024;
    *(_DWORD *)((char *)&v110 + 2) = 266;
    WORD3(v110) = 2048;
    *((void *)&v110 + 1) = 0LL;
    _os_log_impl( (void *)&_mh_execute_header,  v100,  OS_LOG_TYPE_FAULT,  "AssertMacros: %{public}s, %{public}s file: %{public}s, line: %d, value: %ld",  buf,  0x30u);
    goto LABEL_117;
  }

  uint64_t v9 = v6 - 1;
  if (v6 == 1)
  {
    int v106 = -89889;
  }

  else
  {
    unint64_t v10 = (uint64_t *)a1[2];
    int v11 = *(unsigned __int16 *)(*v10 + 34);
    int v12 = *(unsigned __int16 *)(*v10 + 32);
    uint64_t v13 = *(void *)(*v10 + 16);
    BOOL v14 = v10 + 1;
    do
    {
      uint64_t v15 = *v14;
      if (*(unsigned __int16 *)(*v14 + 34) != v11
        || *(unsigned __int16 *)(v15 + 32) != v12
        || ref_count_obj_compare(*(void *)(v15 + 16), v13, 1LL))
      {
        goto LABEL_117;
      }

      ++v14;
      --v9;
    }

    while (v9);
    uint64_t v16 = a1[5];
    int v106 = -89889;
    if (!v16)
    {
      uint64_t v35 = 0LL;
      goto LABEL_42;
    }
  }

  char v103 = a3;
  __int128 v105 = a4;
  uint64_t v17 = 0LL;
  while (1)
  {
    uint64_t v18 = *(void *)(a1[4] + 8 * v17);
    uint64_t v19 = *(void *)(v18 + 24);
    int v20 = *(unsigned __int8 *)(v19 + 16);
    if (a2)
    {
      int v21 = *(unsigned __int8 *)(v19 + 17) | (v20 << 8);
      if (v21 != a2) {
        goto LABEL_23;
      }
    }

    else
    {
      int v21 = *(unsigned __int8 *)(v19 + 17) | (v20 << 8);
    }

    uint64_t v22 = a1[7];
    if (v22)
    {
      __int128 v23 = (uint64_t *)a1[6];
      while (1)
      {
        uint64_t v24 = *v23;
        if (*v23)
        {
          if (*(unsigned __int16 *)(v24 + 80) == v21
            && (dnssec_obj_rr_dnskey_is_valid_for_dnssec(*(_BYTE **)(v24 + 24), &v106) & 1) != 0)
          {
            break;
          }
        }

        ++v23;
        if (!--v22) {
          goto LABEL_23;
        }
      }

      uint64_t v25 = *(void *)a1[2];
      size_t v26 = (uint64_t *)bswap32(*(_DWORD *)(v19 + 12));
      unsigned int v27 = bswap32(*(_DWORD *)(v19 + 8));
      time_t v28 = time(0LL);
      RSAPublicKey = (__SecKey *)v28;
      if ((_DWORD)v28 - (_DWORD)v26 < 0 || ((v27 - (_DWORD)v28) & 0x80000000) != 0)
      {
        uint64_t v34 = (os_log_s *)mDNSLogCategory_DNSSEC;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_DNSSEC == mDNSLogCategory_State)
        {
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC, OS_LOG_TYPE_ERROR)) {
            goto LABEL_38;
          }
        }

        else
        {
          uint64_t v34 = (os_log_s *)mDNSLogCategory_DNSSEC_redacted;
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC_redacted, OS_LOG_TYPE_ERROR))
          {
LABEL_38:
            *(_DWORD *)CFSocketContext buf = 67109632;
            *(_DWORD *)&uint8_t buf[4] = (_DWORD)v26;
            *(_WORD *)&uint8_t buf[8] = 1024;
            *(_DWORD *)&buf[10] = (_DWORD)RSAPublicKey;
            *(_WORD *)&buf[14] = 1024;
            *(_DWORD *)&uint8_t buf[16] = v27;
            _os_log_impl( (void *)&_mh_execute_header,  v34,  OS_LOG_TYPE_ERROR,  "Invalid RRSIG timestamp - inception: %u, now: %u, expiration: %u",  buf,  0x14u);
          }
        }

        int v33 = -90000;
LABEL_40:
        int v106 = v33;
        goto LABEL_23;
      }

      int v106 = 0;
      if (dnssec_obj_rr_rrsig_covers_rr(v18, v25, &v106)) {
        break;
      }
    }

uint64_t _dnssec_obj_rr_compare(uint64_t a1, uint64_t a2, int a3)
{
  if (a3)
  {
    if (*(unsigned __int16 *)(a1 + 34) == *(unsigned __int16 *)(a2 + 34)
      && *(unsigned __int16 *)(a1 + 32) == *(unsigned __int16 *)(a2 + 32)
      && *(unsigned __int16 *)(a1 + 36) == *(unsigned __int16 *)(a2 + 36)
      && !ref_count_obj_compare(*(void *)(a1 + 16), *(void *)(a2 + 16), 1LL))
    {
      return 2
           * (memcmp(*(const void **)(a1 + 24), *(const void **)(a2 + 24), *(unsigned __int16 *)(a1 + 36)) != 0);
    }

    else
    {
      return 2LL;
    }
  }

  else if (!ref_count_obj_compare(*(void *)(a1 + 16), *(void *)(a2 + 16), 1LL) {
         && *(unsigned __int16 *)(a1 + 34) == *(unsigned __int16 *)(a2 + 34)
  }
         && *(unsigned __int16 *)(a1 + 32) == *(unsigned __int16 *)(a2 + 32))
  {
    uint64_t v6 = *(const void **)(a1 + 24);
    unsigned int v7 = *(unsigned __int16 *)(a1 + 36);
    unsigned int v8 = *(const void **)(a2 + 24);
    unsigned int v9 = *(unsigned __int16 *)(a2 + 36);
    if (v7 >= v9) {
      size_t v10 = v9;
    }
    else {
      size_t v10 = v7;
    }
    int v11 = memcmp(v6, v8, v10);
    if (v11 < 0)
    {
      return 0xFFFFFFFFLL;
    }

    else
    {
      BOOL v12 = v11 == 0;
      if (v11) {
        uint64_t result = 1LL;
      }
      else {
        uint64_t result = 0xFFFFFFFFLL;
      }
      if (v12 && v7 >= v9) {
        return v7 > v9;
      }
    }
  }

  else
  {
    return 3LL;
  }

  return result;
}

void _dnssec_obj_rr_finalize(uint64_t a1)
{
  unint64_t v2 = *(void **)(a1 + 16);
  if (v2)
  {
    ref_count_obj_release(v2);
    *(void *)(a1 + 16) = 0LL;
  }

  if (*(_BYTE *)(a1 + 38))
  {
    uint64_t v3 = *(void **)(a1 + 24);
    if (v3)
    {
      free(v3);
      *(void *)(a1 + memset(&v5[1], 0, 24) = 0LL;
    }
  }

  uint64_t v4 = *(void **)(a1 + 56);
  if (v4)
  {
    free(v4);
    *(void *)(a1 + 56) = 0LL;
  }

void dnssec_obj_rr_init_fields( uint64_t a1, unsigned __int8 *a2, __int16 a3, __int16 a4, const void *a5, unsigned int a6, int a7, uint64_t a8, int *a9)
{
  int v20 = 0;
  uint64_t v16 = dnssec_obj_domain_name_create_with_labels(a2, a7, &v20);
  int v17 = v20;
  if (v20) {
    goto LABEL_9;
  }
  *(_BYTE *)(a1 + 3_Block_object_dispose(va, 8) = a7;
  if (a7)
  {
    if (a6)
    {
      if (!a5)
      {
        int v17 = -6705;
        int v20 = -6705;
        goto LABEL_9;
      }

      uint64_t v18 = malloc(a6);
      if (!v18)
      {
        __break(1u);
        return;
      }

      uint64_t v19 = v18;
      memcpy(v18, a5, a6);
      a5 = v19;
    }

    else
    {
      a5 = 0LL;
    }
  }

  int v17 = 0;
  *(void *)(a1 + 16) = v16;
  *(void *)(a1 + memset(&v5[1], 0, 24) = a5;
  *(_WORD *)(a1 + 32) = a3;
  *(_WORD *)(a1 + 34) = a4;
  *(_WORD *)(a1 + 36) = a6;
  *(_DWORD *)(a1 + 40) = 3600;
  *(void *)(a1 + 72) = a8;
  int v20 = 0;
  uint64_t v16 = 0LL;
LABEL_9:
  if (a9) {
    *a9 = v17;
  }
  if (v16) {
    ref_count_obj_release(v16);
  }
}

char *dnssec_obj_rr_get_signed_data(uint64_t a1)
{
  uint64_t v1 = *(char **)(a1 + 56);
  if (!v1)
  {
    int v3 = *(_DWORD *)(a1 + 44);
    if (!v3) {
      goto LABEL_23;
    }
    uint64_t v4 = *(unsigned __int8 **)(a1 + 16);
    __int16 v5 = *(_WORD *)(a1 + 32);
    __int16 v6 = *(_WORD *)(a1 + 34);
    size_t v7 = *(unsigned __int16 *)(a1 + 36);
    unint64_t v8 = *(unsigned __int8 *)(a1 + 48);
    *(_DWORD *)CFSocketContext buf = 0;
    unsigned int v9 = (unsigned __int8 *)*((void *)v4 + 2);
    unsigned int v10 = *v9;
    if (*v9)
    {
      unint64_t v11 = 0LL;
      uint64_t v12 = *((void *)v4 + 2);
      do
      {
        ++v11;
        uint64_t v13 = v12 + v10;
        unsigned int v14 = *(unsigned __int8 *)(v13 + 1);
        uint64_t v12 = v13 + 1;
        unsigned int v10 = v14;
      }

      while (v14);
    }

    else
    {
      unint64_t v11 = 0LL;
    }

    if (v11 < v8) {
      goto LABEL_32;
    }
    if (v11 == v8)
    {
      uint64_t v15 = 0LL;
      ++*(_DWORD *)v4;
    }

    else
    {
      char v26 = 0;
      __int16 v25 = 10753;
      uint64_t v16 = dnssec_obj_domain_name_copy_parent_domain(v9, v11 - v8, (int *)buf);
      uint64_t v15 = v16;
      int v17 = *(_DWORD *)buf;
      if (*(_DWORD *)buf)
      {
        uint64_t v4 = 0LL;
        if (!v16) {
          goto LABEL_17;
        }
        goto LABEL_16;
      }

      uint64_t v4 = dnssec_obj_domain_name_create_concatenation_with_subdomain(&v25, *((_BYTE **)v16 + 2), buf);
      int v17 = *(_DWORD *)buf;
      if (*(_DWORD *)buf)
      {
LABEL_15:
        if (!v15)
        {
LABEL_17:
          if (v17)
          {
            if (v4) {
              ref_count_obj_release(v4);
            }
            goto LABEL_32;
          }

          size_t v18 = *((void *)v4 + 3);
          if (v7 + v18 != -10LL)
          {
            uint64_t v19 = (char *)malloc(v7 + v18 + 10);
            if (v19)
            {
              uint64_t v1 = v19;
              memcpy(v19, *((const void **)v4 + 2), v18);
              int v20 = &v1[*((void *)v4 + 3)];
              char *v20 = HIBYTE(v5);
              v20[1] = v5;
              v20[2] = HIBYTE(v6);
              v20[3] = v6;
              void v20[4] = HIBYTE(v3);
              v20[5] = BYTE2(v3);
              v20[6] = BYTE1(v3);
              v20[7] = v3;
              v20[8] = BYTE1(v7);
              v20[9] = v7;
              memcpy(v20 + 10, *(const void **)(a1 + 24), v7);
              ref_count_obj_release(v4);
              *(void *)(a1 + 56) = v1;
              *(void *)(a1 + 64) = v7 + v18 + 10;
              return v1;
            }
          }

          __break(1u);
LABEL_23:
          uint64_t v22 = (os_log_s *)mDNSLogCategory_DNSSEC;
          if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_DNSSEC == mDNSLogCategory_State)
          {
            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC, OS_LOG_TYPE_FAULT))
            {
LABEL_32:
              uint64_t v1 = 0LL;
              *(void *)(a1 + 56) = 0LL;
              return v1;
            }
          }

          else
          {
            uint64_t v22 = (os_log_s *)mDNSLogCategory_DNSSEC_redacted;
            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC_redacted, OS_LOG_TYPE_FAULT)) {
              goto LABEL_32;
            }
          }

          *(_DWORD *)CFSocketContext buf = 136447234;
          time_t v28 = "me->original_ttl != 0";
          __int16 v29 = 2082;
          size_t v30 = "";
          __int16 v31 = 2082;
          int v32 = "/Library/Caches/com.apple.xbs/Sources/mDNSResponder/mDNSMacOSX/dnssec_v2/dnssec_objs/dnssec_obj_rr.c";
          __int16 v33 = 1024;
          int v34 = 430;
          __int16 v35 = 2048;
          uint64_t v36 = 0LL;
          _os_log_impl( (void *)&_mh_execute_header,  v22,  OS_LOG_TYPE_FAULT,  "AssertMacros: %{public}s, %{public}s file: %{public}s, line: %d, value: %ld",  buf,  0x30u);
          goto LABEL_32;
        }

char *dnssec_obj_rr_copy_rdata_rfc_description(uint64_t a1, int *a2)
{
  uint64_t v4 = *(uint64_t (**)(uint64_t, int *))(a1 + 72);
  if (v4) {
    return (char *)v4(a1, a2);
  }
  size_t v6 = 2LL * *(unsigned __int16 *)(a1 + 36) + 7;
  uint64_t result = (char *)calloc(1uLL, v6);
  if (result)
  {
    size_t v7 = result;
    unint64_t v8 = &result[v6];
    unsigned int v9 = &result[snprintf(result, v6, "%u ", *(unsigned __int16 *)(a1 + 36))];
    unsigned int v10 = put_hex_from_bytes(*(unsigned __int8 **)(a1 + 24), *(unsigned __int16 *)(a1 + 36), v9, v8 - v9);
    if (a2)
    {
      if (v10 == v9) {
        int v11 = -6751;
      }
      else {
        int v11 = 0;
      }
      *a2 = v11;
    }

    return v7;
  }

  else
  {
    __break(1u);
  }

  return result;
}

void *_mdns_dns_service_definition_copy_description(uint64_t a1, int a2, char a3)
{
  uint64_t v30 = 0LL;
  __int16 v31 = &v30;
  uint64_t v32 = 0x2000000000LL;
  int v33 = 0;
  uint64_t v26 = 0LL;
  unsigned int v27 = &v26;
  uint64_t v28 = 0x2000000000LL;
  uint64_t v29 = 0LL;
  size_t v6 = (void *)mdns_string_builder_create();
  if (v6)
  {
    size_t v7 = v6;
    if (!a2
      || (int v8 = mdns_string_builder_append_formatted( v6,  "<%s: %p>: ",  *(const char **)(*(void *)(a1 + 16) + 8LL),  (const void *)a1),  (*((_DWORD *)v31 + 6) = v8) == 0))
    {
      unsigned int v9 = *(const char **)(a1 + 40);
      if (!v9) {
        unsigned int v9 = "";
      }
      int appended = mdns_string_builder_append_formatted( v7,  "interface: %s/%u, interface scope: ",  v9,  *(_DWORD *)(a1 + 48));
      *((_DWORD *)v31 + 6) = appended;
      if (!appended)
      {
        int v11 = *(unsigned __int8 *)(a1 + 52);
        if (v11 == 2)
        {
          int v12 = mdns_string_builder_append_formatted(v7, "unscoped+scoped", v21);
        }

        else if (v11 == 1)
        {
          int v12 = mdns_string_builder_append_formatted(v7, "scoped");
        }

        else
        {
          int v12 = *(_BYTE *)(a1 + 52)
              ? mdns_string_builder_append_formatted(v7, "«INVALID %d»")
              : mdns_string_builder_append_formatted(v7, "unscoped", v21);
        }

        *((_DWORD *)v31 + 6) = v12;
        if (!v12)
        {
          int v14 = mdns_string_builder_append_formatted(v7, ", addresses: {");
          *((_DWORD *)v31 + 6) = v14;
          if (!v14)
          {
            v27[3] = 0LL;
            uint64_t v16 = *(const __CFArray **)(a1 + 24);
            v24[0] = _NSConcreteStackBlock;
            v24[1] = 0x40000000LL;
            _DWORD v24[2] = ___mdns_dns_service_definition_copy_description_block_invoke;
            v24[3] = &unk_10013C698;
            v24[4] = &v30;
            void v24[5] = &v26;
            v24[6] = v7;
            char v25 = a3;
            mdns_cfarray_enumerate(v16, (uint64_t)v24);
            uint64_t v13 = 0LL;
            if (*((_DWORD *)v31 + 6)) {
              goto LABEL_18;
            }
            int v17 = mdns_string_builder_append_formatted(v7, "}");
            *((_DWORD *)v31 + 6) = v17;
            if (!v17)
            {
              int v18 = mdns_string_builder_append_formatted(v7, ", domains: {");
              *((_DWORD *)v31 + 6) = v18;
              if (!v18)
              {
                v27[3] = 0LL;
                uint64_t v19 = *(const __CFSet **)(a1 + 32);
                v22[0] = _NSConcreteStackBlock;
                v22[1] = 0x40000000LL;
                v22[2] = ___mdns_dns_service_definition_copy_description_block_invoke_2;
                v22[3] = &unk_10013C6C0;
                v22[4] = &v30;
                v22[5] = &v26;
                _BYTE v22[6] = v7;
                char v23 = a3;
                mdns_cfset_enumerate(v19, (uint64_t)v22);
                if (!*((_DWORD *)v31 + 6))
                {
                  int v20 = mdns_string_builder_append_formatted(v7, "}");
                  *((_DWORD *)v31 + 6) = v20;
                  if (!v20)
                  {
                    uint64_t v13 = mdns_string_builder_copy_string((uint64_t)v7);
                    goto LABEL_18;
                  }
                }
              }
            }
          }
        }
      }
    }

    uint64_t v13 = 0LL;
LABEL_18:
    os_release(v7);
    goto LABEL_19;
  }

  uint64_t v13 = 0LL;
LABEL_19:
  _Block_object_dispose(&v26, 8);
  _Block_object_dispose(&v30, 8);
  return v13;
}

void _mdns_dns_service_definition_finalize(void *a1)
{
  unint64_t v2 = (const void *)a1[3];
  if (v2)
  {
    CFRelease(v2);
    a1[3] = 0LL;
  }

  int v3 = (const void *)a1[4];
  if (v3)
  {
    CFRelease(v3);
    a1[4] = 0LL;
  }

  uint64_t v4 = (void *)a1[5];
  if (v4)
  {
    free(v4);
    a1[5] = 0LL;
  }

BOOL ___mdns_dns_service_definition_copy_description_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = mdns_string_builder_append_description_with_prefix( *(void **)(a1 + 48),  *(const char **)(*(void *)(*(void *)(a1 + 40) + 8LL)
                                                                                 + 24LL),
                                                                  a2,
                                                                  *(_BYTE *)(a1 + 56));
  *(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = ", ";
  return *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) == 0;
}

BOOL ___mdns_dns_service_definition_copy_description_block_invoke_2(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = mdns_string_builder_append_description_with_prefix( *(void **)(a1 + 48),  *(const char **)(*(void *)(*(void *)(a1 + 40) + 8LL)
                                                                                 + 24LL),
                                                                  a2,
                                                                  *(_BYTE *)(a1 + 56));
  *(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = ", ";
  return *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) == 0;
}

void *mdns_dns_service_definition_create()
{
  uint64_t v0 = _os_object_alloc(&OBJC_CLASS___OS_mdns_dns_service_definition, 56LL);
  uint64_t v1 = (void *)v0;
  if (v0)
  {
    unint64_t v2 = &_mdns_dns_service_definition_kind;
    *(void *)(v0 + 16) = &_mdns_dns_service_definition_kind;
    do
    {
      int v3 = (void (*)(void *))v2[2];
      if (v3) {
        v3(v1);
      }
      unint64_t v2 = (_UNKNOWN **)*v2;
    }

    while (v2);
    CFMutableArrayRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0LL, (const CFArrayCallBacks *)&mdns_cfarray_callbacks);
    v1[3] = Mutable;
    if (!Mutable
      || (CFMutableSetRef v5 = CFSetCreateMutable(kCFAllocatorDefault, 0LL, (const CFSetCallBacks *)&mdns_domain_name_cf_set_callbacks),
          (v1[4] = v5) == 0LL))
    {
      os_release(v1);
      return 0LL;
    }
  }

  return v1;
}

uint64_t mdns_dns_service_definition_create_from_xpc_dictionary(void *a1, int *a2)
{
  int v38 = 0;
  uint64_t v4 = mdns_dns_service_definition_create();
  uint64_t v5 = (uint64_t)v4;
  if (!v4)
  {
    int v21 = -6729;
    int v38 = -6729;
    if (!a2) {
      goto LABEL_32;
    }
    goto LABEL_31;
  }

  xpc_object_t optional_array = mdns_xpc_dictionary_get_optional_array(a1, "addresses");
  if (!optional_array)
  {
LABEL_9:
    xpc_object_t v14 = mdns_xpc_dictionary_get_optional_array(a1, "domains");
    if (v14)
    {
      uint64_t v15 = v14;
      size_t count = xpc_array_get_count(v14);
      if (count)
      {
        size_t v17 = count;
        size_t v18 = 0LL;
        do
        {
          string = (char *)xpc_array_get_string(v15, v18);
          if (!string) {
            goto LABEL_29;
          }
          int v20 = mdns_domain_name_create(string, &v38);
          int v21 = v38;
          if (v38) {
            goto LABEL_30;
          }
          uint64_t v22 = v20;
          CFSetAddValue(*(CFMutableSetRef *)(v5 + 32), v20);
          int v38 = 0;
          if (v22)
          {
            os_release(v22);
            int v21 = v38;
            if (v38) {
              goto LABEL_30;
            }
          }
        }

        while (v17 != ++v18);
      }
    }

    BOOL v37 = 0;
    xpc_object_t value = xpc_dictionary_get_value(a1, "ifindex");
    unsigned int uint64_limited = _mdns_xpc_object_get_uint64_limited(value, 0xFFFFFFFFuLL, &v37);
    if (!v37) {
      goto LABEL_29;
    }
    unsigned int v25 = uint64_limited;
    BOOL v37 = 0;
    BOOL v39 = 0;
    xpc_object_t v26 = xpc_dictionary_get_value(a1, "interface_scope");
    unsigned __int8 v27 = _mdns_xpc_object_get_uint64_limited(v26, 0xFFuLL, &v39);
    char v28 = v27;
    BOOL v29 = !v39 || v27 >= 3u;
    BOOL v30 = !v29;
    BOOL v37 = v30;
    if (v29) {
      goto LABEL_29;
    }
    BOOL v37 = 0;
    xpc_object_t object = _mdns_xpc_dictionary_get_object(a1, "local_purview", (const _xpc_type_s *)&_xpc_type_BOOL);
    BOOL v37 = object != 0LL;
    if (!object) {
      goto LABEL_29;
    }
    uint64_t v32 = object;
    BOOL v37 = 0;
    xpc_object_t v33 = _mdns_xpc_dictionary_get_object(a1, "mdns_alternative", (const _xpc_type_s *)&_xpc_type_BOOL);
    BOOL v37 = v33 != 0LL;
    if (!v33) {
      goto LABEL_29;
    }
    BOOL v34 = v32 == &_xpc_BOOL_true;
    BOOL v35 = v33 == &_xpc_BOOL_true;
    mdns_dns_service_definition_set_interface_index(v5, v25, v28);
    int v21 = 0;
    uint64_t v4 = 0LL;
    *(_BYTE *)(v5 + 53) = v34;
    *(_BYTE *)(v5 + 54) = v35;
    int v38 = 0;
    if (!a2) {
      goto LABEL_32;
    }
LABEL_31:
    *a2 = v21;
    goto LABEL_32;
  }

  size_t v7 = optional_array;
  size_t v8 = xpc_array_get_count(optional_array);
  if (!v8)
  {
LABEL_8:
    int v38 = 0;
    goto LABEL_9;
  }

  size_t v9 = v8;
  size_t v10 = 0LL;
  while (1)
  {
    int v11 = (char *)xpc_array_get_string(v7, v10);
    if (!v11) {
      break;
    }
    int v12 = (void *)mdns_address_create_from_ip_address_string(v11);
    if (!v12) {
      break;
    }
    uint64_t v13 = v12;
    CFArrayAppendValue(*(CFMutableArrayRef *)(v5 + 24), v12);
    os_release(v13);
    if (v9 == ++v10) {
      goto LABEL_8;
    }
  }

void mdns_dns_service_definition_set_interface_index(uint64_t a1, unsigned int a2, char a3)
{
  *(_BYTE *)(a1 + 52) = a3;
  if (*(_DWORD *)(a1 + 48) != a2)
  {
    *(_DWORD *)(a1 + 4_Block_object_dispose(va, 8) = a2;
    uint64_t v4 = *(void **)(a1 + 40);
    if (v4)
    {
      free(v4);
      *(void *)(a1 + 40) = 0LL;
      a2 = *(_DWORD *)(a1 + 48);
    }
  }

  if (a2)
  {
    if (!*(void *)(a1 + 40)) {
      *(void *)(a1 + 40) = mdns_system_interface_index_to_name(a2);
    }
  }

  else
  {
    *(_BYTE *)(a1 + 52) = 0;
  }

char *_mrcs_session_copy_description(void *a1)
{
  unint64_t v2 = 0LL;
  asprintf(&v2, "<%s: %p>", *(const char **)(a1[2] + 8LL), a1);
  return v2;
}

void _mrcs_session_finalize(uint64_t a1)
{
  unint64_t v2 = *(void **)(a1 + 32);
  if (v2)
  {
    xpc_release(v2);
    *(void *)(a1 + 32) = 0LL;
  }

char *_mrcs_dns_proxy_request_copy_description(void *a1)
{
  unint64_t v2 = 0LL;
  asprintf(&v2, "<%s: %p>", *(const char **)(a1[2] + 8LL), a1);
  return v2;
}

void _mrcs_dns_proxy_request_finalize(uint64_t a1)
{
  unint64_t v2 = *(void **)(a1 + 32);
  if (v2)
  {
    os_release(v2);
    *(void *)(a1 + 32) = 0LL;
  }

void *_mrcs_dns_service_registration_request_copy_description(void *a1, int a2, char a3)
{
  size_t v6 = (void *)mdns_string_builder_create();
  if (!v6) {
    return 0LL;
  }
  size_t v7 = v6;
  if (a2 && mdns_string_builder_append_formatted(v6, "<%s: %p>: ", *(const char **)(a1[2] + 8LL), a1))
  {
    size_t v8 = 0LL;
  }

  else
  {
    uint64_t v9 = a1[4];
    if (v9 || (uint64_t v9 = a1[5]) != 0) {
      mdns_string_builder_append_description(v7, v9, a3);
    }
    else {
      mdns_string_builder_append_formatted(v7, "<empty dns service definition>");
    }
    size_t v8 = mdns_string_builder_copy_string((uint64_t)v7);
  }

  os_release(v7);
  return v8;
}

void _mrcs_dns_service_registration_request_finalize(uint64_t a1)
{
  unint64_t v2 = *(void **)(a1 + 32);
  if (v2)
  {
    os_release(v2);
    *(void *)(a1 + 32) = 0LL;
  }

  int v3 = *(void **)(a1 + 40);
  if (v3)
  {
    os_release(v3);
    *(void *)(a1 + 40) = 0LL;
  }

uint64_t __mrcs_server_set_dns_proxy_handlers_block_invoke(uint64_t result)
{
  if ((g_activated & 1) == 0) {
    g_dns_proxy_handlers = *(void *)(result + 32);
  }
  return result;
}

void ___mrcs_server_queue_block_invoke(id a1)
{
  _mrcs_server_queue_s_queue = (uint64_t)dispatch_queue_create("com.apple.mDNSResponder.control.server", 0LL);
}

uint64_t __mrcs_server_set_dns_service_registration_handlers_block_invoke(uint64_t result)
{
  if ((g_activated & 1) == 0) {
    g_dns_service_registration_handlers = *(void *)(result + 32);
  }
  return result;
}

uint64_t __mrcs_server_set_discovery_proxy_handlers_block_invoke(uint64_t result)
{
  if ((g_activated & 1) == 0) {
    g_discovery_proxy_handlers = *(void *)(result + 32);
  }
  return result;
}

uint64_t __mrcs_server_set_record_cache_handlers_block_invoke(uint64_t result)
{
  if ((g_activated & 1) == 0) {
    g_record_cache_handlers = *(void *)(result + 32);
  }
  return result;
}

void __mrcs_server_activate_block_invoke(id a1)
{
  if (!_mrcs_dns_service_registration_request_kind_block_invoke_s_listener)
  {
    if (_mrcs_server_queue_s_once != -1) {
      dispatch_once(&_mrcs_server_queue_s_once, &__block_literal_global_17);
    }
    mach_uint64_t service = xpc_connection_create_mach_service( "com.apple.mDNSResponder.control",  (dispatch_queue_t)_mrcs_server_queue_s_queue,  1uLL);
    _mrcs_dns_service_registration_request_kind_block_invoke_s_listener = (uint64_t)mach_service;
    if (mach_service)
    {
      xpc_connection_set_event_handler(mach_service, &__block_literal_global_11);
      xpc_connection_activate((xpc_connection_t)_mrcs_dns_service_registration_request_kind_block_invoke_s_listener);
      g_activated = 1;
    }

    else
    {
      if (_mdns_server_log_s_once_4206 != -1) {
        dispatch_once(&_mdns_server_log_s_once_4206, &__block_literal_global_13);
      }
      unint64_t v2 = (os_log_s *)_mdns_server_log_s_log_4207;
      if (os_log_type_enabled((os_log_t)_mdns_server_log_s_log_4207, OS_LOG_TYPE_FAULT))
      {
        int v3 = 136446210;
        uint64_t v4 = "com.apple.mDNSResponder.control";
        _os_log_fault_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_FAULT,  "Failed to create XPC listener for %{public}s",  (uint8_t *)&v3,  0xCu);
      }
    }
  }

void __mrcs_server_activate_block_invoke_8(id a1, const void *a2)
{
  if (xpc_get_type((xpc_object_t)a2) == (xpc_type_t)&_xpc_type_connection)
  {
    uint64_t v3 = _os_object_alloc(&OBJC_CLASS___OS_mrcs_session, 56LL);
    if (v3)
    {
      uint64_t v4 = v3;
      uint64_t v5 = &_mrcs_session_kind;
      *(void *)(v3 + 16) = &_mrcs_session_kind;
      do
      {
        size_t v6 = (void (*)(uint64_t))v5[2];
        if (v6) {
          v6(v4);
        }
        uint64_t v5 = (_UNKNOWN **)*v5;
      }

      while (v5);
      *(void *)(v4 + 32) = a2;
      xpc_retain((xpc_object_t)a2);
      size_t v7 = &g_session_list_4211;
      do
      {
        size_t v8 = v7;
        uint64_t v9 = *v7;
        size_t v7 = (uint64_t *)(*v7 + 24);
      }

      while (v9);
      *(void *)(v4 + memset(&v5[1], 0, 24) = 0LL;
      *size_t v8 = v4;
      os_retain((void *)v4);
      os_retain((void *)v4);
      size_t v10 = *(_xpc_connection_s **)(v4 + 32);
      if (_mrcs_server_queue_s_once != -1) {
        dispatch_once(&_mrcs_server_queue_s_once, &__block_literal_global_17);
      }
      xpc_connection_set_target_queue(v10, (dispatch_queue_t)_mrcs_server_queue_s_queue);
      int v11 = *(_xpc_connection_s **)(v4 + 32);
      handler[0] = _NSConcreteStackBlock;
      handler[1] = 0x40000000LL;
      _OWORD handler[2] = ___mrcs_session_activate_block_invoke;
      handler[3] = &__block_descriptor_tmp_19_4212;
      handler[4] = v4;
      xpc_connection_set_event_handler(v11, handler);
      xpc_connection_activate(*(xpc_connection_t *)(v4 + 32));
      os_release((void *)v4);
    }

    else
    {
      xpc_connection_cancel((xpc_connection_t)a2);
    }
  }

void ___mrcs_session_activate_block_invoke(uint64_t a1, xpc_object_t object)
{
  if (xpc_get_type(object) != (xpc_type_t)&_xpc_type_dictionary)
  {
    uint64_t v4 = *(void *)(a1 + 32);
    if (object == &_xpc_error_connection_invalid)
    {
      int v11 = &g_session_list_4211;
      do
      {
        int v12 = v11;
        uint64_t v13 = *v11;
        int v11 = (uint64_t *)(*v11 + 24);
        if (v13) {
          BOOL v14 = v13 == v4;
        }
        else {
          BOOL v14 = 1;
        }
      }

      while (!v14);
      if (v13)
      {
        *int v12 = *(void *)(v4 + 24);
        *(void *)(v4 + memset(&v5[1], 0, 24) = 0LL;
        os_release((void *)v4);
        uint64_t v4 = *(void *)(a1 + 32);
      }

      uint64_t v15 = *(void **)(v4 + 32);
      if (v15)
      {
        xpc_connection_cancel(*(xpc_connection_t *)(v4 + 32));
        xpc_release(v15);
        *(void *)(v4 + 32) = 0LL;
      }

      for (unint64_t i = *(void **)(v4 + 40); i; unint64_t i = *(void **)(v4 + 40))
      {
        *(void *)(v4 + 40) = i[3];
        size_t v17 = *(void (**)(void))(g_dns_proxy_handlers + 8);
        if (v17) {
          v17(i[4]);
        }
        os_release(i);
      }

      for (unint64_t j = *(void **)(v4 + 48); j; unint64_t j = *(void **)(v4 + 48))
      {
        *(void *)(v4 + 4_Block_object_dispose(va, 8) = j[3];
        uint64_t v19 = *(void (**)(void))(g_dns_service_registration_handlers + 8);
        if (v19) {
          v19(j[7]);
        }
        os_release(j);
      }

      if (g_current_discovery_proxy_owner == v4)
      {
        int v20 = *(void (**)(void))(g_discovery_proxy_handlers + 8);
        if (!v20 || (v20(), (uint64_t v4 = g_current_discovery_proxy_owner) != 0))
        {
          os_release((void *)v4);
          g_current_discovery_proxy_owner = 0LL;
        }
      }

      os_release(*(void **)(a1 + 32));
    }

    else
    {
      uint64_t v5 = *(void **)(v4 + 32);
      if (v5)
      {
        xpc_connection_cancel(*(xpc_connection_t *)(v4 + 32));
        xpc_release(v5);
        *(void *)(*(void *)(a1 + 32) + 32LL) = 0LL;
      }
    }

    return;
  }

  size_t v6 = *(uint64_t **)(a1 + 32);
  if (!v6[4]) {
    return;
  }
  string = xpc_dictionary_get_string(object, "command");
  if (!string) {
    goto LABEL_41;
  }
  size_t v8 = string;
  uint64_t v9 = 0LL;
  uint64_t v160 = 5LL;
  unsigned int v161 = "record_cache.flush";
  uint64_t v162 = 9LL;
  uint64_t v146 = 8LL;
  size_t length = (size_t)"record_cache.local_record_inquiry";
  uint64_t v148 = 6LL;
  uint64_t v147 = "discovery_proxy.start";
  uint64_t v150 = 7LL;
  int v149 = "discovery_proxy.stop";
  uint64_t v152 = 1LL;
  unsigned int v151 = "dns_proxy.start";
  uint64_t v154 = 2LL;
  uint64_t v153 = "dns_proxy.stop";
  uint64_t v156 = 3LL;
  size_t v155 = "dns_proxy.get_state";
  uint64_t v158 = 4LL;
  uint64_t v157 = "dns_service_registration.start";
  int v159 = "dns_service_registration.stop";
  p_size_t length = (const char **)&length;
  while (strcmp(v8, *p_length))
  {
    ++v9;
    p_length += 2;
    if (v9 == 9) {
      goto LABEL_41;
    }
  }

  unsigned int v21 = *((unsigned __int8 *)&length + 16 * v9 + 8) - 1;
  if (v21 > 8)
  {
LABEL_41:
    LODWORD(v25) = -6707;
    goto LABEL_42;
  }

  if (!mdns_xpc_connection_is_entitled( v6[4],  (uint64_t)off_10013C950[(*((_BYTE *)&length + 16 * v9 + 8) - 1)]))
  {
    LODWORD(v25) = -71168;
    goto LABEL_42;
  }

  switch(v21)
  {
    case 0u:
      uint64_t uint64 = xpc_dictionary_get_uint64(object, "id");
      uint64_t v23 = v6[5];
      if (v23)
      {
        do
        {
          uint64_t v24 = v23;
          if (*(void *)(v23 + 40) == uint64)
          {
            LODWORD(v25) = -6709;
            goto LABEL_42;
          }

          uint64_t v23 = *(void *)(v23 + 24);
        }

        while (v23);
        uint64_t v138 = (uint64_t *)(v24 + 24);
        xpc_object_t xarray = (xpc_object_t)uint64;
      }

      else
      {
        uint64_t v138 = v6 + 5;
        xpc_object_t xarray = (xpc_object_t)uint64;
      }

      uint64_t v57 = (const char **)_mdns_xpc_dictionary_get_object(object, "params", (const _xpc_type_s *)&_xpc_type_dictionary);
      if (!v57)
      {
LABEL_129:
        LODWORD(v25) = -6705;
        goto LABEL_42;
      }

      uint64_t v58 = v57;
      int v144 = 0;
      uint64_t v31 = mrcs_dns_proxy_create(&v144);
      LODWORD(v25) = v144;
      if (v144) {
        goto LABEL_127;
      }
      xpc_object_t optional_array = (const char **)mdns_xpc_dictionary_get_optional_array(v58, "input_interfaces");
      if (!optional_array) {
        goto LABEL_199;
      }
      uint64_t v60 = optional_array;
      CFAllocatorRef allocator = (CFAllocatorRef)v58;
      size_t count = xpc_array_get_count(optional_array);
      if (!count) {
        goto LABEL_199;
      }
      uint64_t v62 = (const char ***)count;
      char v41 = 0LL;
      BOOL v143 = 0;
      do
      {
        xpc_object_t value = xpc_array_get_value(v60, (size_t)v41);
        unsigned int uint64_limited = _mdns_xpc_object_get_uint64_limited(value, 0xFFFFFFFFuLL, &v143);
        if (!v143) {
          goto LABEL_199;
        }
        unsigned int v65 = uint64_limited;
        unint64_t v66 = *(void *)(v31 + 48);
        if (v66)
        {
          uint64_t v67 = *(void *)(v31 + 40);
          unint64_t v68 = 0LL;
          unsigned int v69 = (int *)(v67 + 24);
          while (v66 - 1 != v68)
          {
            int v70 = *v69;
            v69 += 4;
            ++v68;
          }

          unint64_t v68 = *(void *)(v31 + 48);
LABEL_100:
          if (v68 < v66 || v66 == -1LL) {
            goto LABEL_113;
          }
          if (v66 >= 0xFFFFFFFFFFFFFFFLL) {
            goto LABEL_200;
          }
          size_t v71 = v66 + 1;
        }

        else
        {
          size_t v71 = 1LL;
        }

        unsigned int v72 = (const char **)calloc(v71, 0x10uLL);
        if (!v72)
        {
LABEL_200:
          __break(1u);
          goto LABEL_201;
        }

        p_size_t length = v72;
        if (*(void *)(v31 + 48))
        {
          uint64_t v73 = 0LL;
          unint64_t v74 = 0LL;
          do
          {
            uint64_t v75 = *(void *)(v31 + 40);
            *(_OWORD *)&v72[v73] = *(_OWORD *)(v75 + v73 * 8);
            *(void *)(v75 + v73 * _Block_object_dispose(va, 8) = 0LL;
            ++v74;
            unint64_t v76 = *(void *)(v31 + 48);
            v73 += 2LL;
          }

          while (v74 < v76);
        }

        else
        {
          unint64_t v76 = 0LL;
        }

        uint64_t v58 = &v72[2 * v76];
        *((_DWORD *)v58 + 2) = v65;
        *uint64_t v58 = mdns_system_interface_index_to_name(v65);
        int v77 = *(void **)(v31 + 40);
        if (v77) {
          free(v77);
        }
        *(void *)(v31 + 40) = p_length;
        *(void *)(v31 + 4_Block_object_dispose(va, 8) = v71;
LABEL_113:
        char v41 = (const char ***)((char *)v41 + 1);
      }

      while (v41 != v62);
      unsigned int output_interface = mrc_xpc_dns_proxy_params_get_output_interface(allocator, &v143);
      if (!v143) {
        goto LABEL_199;
      }
      mrcs_dns_proxy_set_output_interface(v31, output_interface);
      size_t length = 0LL;
      nat64_prefix = (char *)mrc_xpc_dns_proxy_params_get_nat64_prefix(allocator, &length);
      if (nat64_prefix)
      {
        int v80 = mrcs_dns_proxy_set_nat64_prefix(v31, nat64_prefix, length);
        int v144 = v80;
        if (v80)
        {
          LODWORD(v25) = v80;
          goto LABEL_127;
        }
      }

      BOOL force_aaaa_synthesis = mrc_xpc_dns_proxy_params_get_force_aaaa_synthesis(allocator, &v143);
      if (!v143)
      {
LABEL_199:
        LODWORD(v25) = -6705;
        int v144 = -6705;
        goto LABEL_127;
      }

      *(_BYTE *)(v31 + 77) = force_aaaa_synthesis;
      LODWORD(v25) = v144;
      if (v144) {
        goto LABEL_131;
      }
      *(_DWORD *)(v31 + 72) = xpc_connection_get_euid((xpc_connection_t)v6[4]);
      if (!*(void *)g_dns_proxy_handlers) {
        goto LABEL_130;
      }
      int v82 = (*(uint64_t (**)(uint64_t))g_dns_proxy_handlers)(v31);
      if (v82)
      {
        LODWORD(v25) = v82;
        goto LABEL_131;
      }

      uint64_t v83 = _os_object_alloc(&OBJC_CLASS___OS_mrcs_dns_proxy_request, 48LL);
      if (!v83)
      {
        LODWORD(v25) = -6728;
        goto LABEL_131;
      }

      uint64_t v84 = v83;
      unsigned int v25 = &_mrcs_dns_proxy_request_kind;
      *(void *)(v83 + 16) = &_mrcs_dns_proxy_request_kind;
      do
      {
        uint64_t v85 = (void (*)(uint64_t))v25[2];
        if (v85) {
          v85(v84);
        }
        unsigned int v25 = (_UNKNOWN **)*v25;
      }

      while (v25);
      *(void *)(v84 + 32) = v31;
      os_retain((void *)v31);
      *(void *)(v84 + 40) = xarray;
      *uint64_t v138 = v84;
LABEL_127:
      if (v31) {
        goto LABEL_131;
      }
LABEL_42:
      xpc_object_t v26 = object;
      int v27 = (int)v25;
LABEL_43:
      xpc_object_t reply = mrc_xpc_create_reply(v26, v27, 0LL);
      if (reply)
      {
LABEL_44:
        xpc_connection_send_message((xpc_connection_t)v6[4], reply);
        xpc_release(reply);
      }

      return;
    case 1u:
      uint64_t v46 = xpc_dictionary_get_uint64(object, "id");
      uint64_t v47 = v6 + 5;
      unsigned int v48 = (void *)v6[5];
      if (!v48) {
        goto LABEL_74;
      }
      if (v48[5] == v46) {
        goto LABEL_71;
      }
      while (1)
      {
        unsigned int v49 = v48;
        unsigned int v48 = (void *)v48[3];
        if (!v48) {
          goto LABEL_74;
        }
        if (v48[5] == v46)
        {
          uint64_t v47 = v49 + 3;
LABEL_71:
          void *v47 = v48[3];
          v48[3] = 0LL;
          uint64_t v50 = *(void (**)(void))(g_dns_proxy_handlers + 8);
          if (v50) {
            v50(v48[4]);
          }
          os_release(v48);
LABEL_187:
          LODWORD(v25) = 0;
          goto LABEL_42;
        }
      }

    case 2u:
      xpc_object_t empty = xpc_dictionary_create_empty();
      if (!empty)
      {
        LODWORD(v25) = -6729;
        goto LABEL_42;
      }

      BOOL v35 = empty;
      uint64_t v36 = *(uint64_t (**)(void))(g_dns_proxy_handlers + 16);
      if (!v36) {
        goto LABEL_84;
      }
      BOOL v37 = (const char *)v36();
      if (v37)
      {
        int v38 = (char *)v37;
        xpc_dictionary_set_string(v35, "description", v37);
        free(v38);
        goto LABEL_65;
      }

      int v45 = -6728;
      goto LABEL_165;
    case 3u:
      int v144 = 0;
      uint64_t v39 = xpc_dictionary_get_uint64(object, "id");
      uint64_t v31 = v39;
      char v41 = (const char ***)(v6 + 6);
      uint64_t v40 = v6[6];
      if (!v40) {
        goto LABEL_168;
      }
      if (*(void *)(v40 + 48) == v39) {
        goto LABEL_61;
      }
      while (1)
      {
        uint64_t v42 = *(void *)(v40 + 24);
        if (!v42) {
          break;
        }
        uint64_t v40 = *(void *)(v40 + 24);
        if (*(void *)(v42 + 48) == v39)
        {
LABEL_61:
          int v43 = -6721;
          goto LABEL_183;
        }
      }

      char v41 = (const char ***)(v40 + 24);
LABEL_168:
      xpc_object_t v120 = _mdns_xpc_dictionary_get_object(object, "params", (const _xpc_type_s *)&_xpc_type_dictionary);
      if (v120
        && (__int128 v121 = v120,
            (xpc_object_t v122 = _mdns_xpc_dictionary_get_object(v120, "definition", (const _xpc_type_s *)&_xpc_type_dictionary)) != 0LL)
        && (__int128 v123 = v122,
            BOOL v143 = 0,
            definition_xpc_type_t type = mrc_xpc_dns_service_registration_params_get_definition_type(v121, &v143),
            v143))
      {
        int v125 = definition_type;
        uint64_t v126 = _os_object_alloc(&OBJC_CLASS___OS_mrcs_dns_service_registration_request, 64LL);
        if (v126)
        {
          uint64_t v58 = (const char **)v126;
          __int128 v127 = &_mrcs_dns_service_registration_request_kind;
          *(void *)(v126 + 16) = &_mrcs_dns_service_registration_request_kind;
          do
          {
            __int128 v128 = (void (*)(const char **))v127[2];
            if (v128) {
              v128(v58);
            }
            __int128 v127 = (_UNKNOWN **)*v127;
          }

          while (v127);
          if (v125 == 2)
          {
            v58[5] = (const char *)mdns_dns_push_service_definition_create_from_xpc_dictionary(v123, &v144);
            if (!v144)
            {
              p_size_t length = (const char **)_mdns_xpc_dictionary_get_object( v121,  "reports_connection_errors",  (const _xpc_type_s *)&_xpc_type_BOOL);
              uint64_t v60 = (const char **)&_xpc_BOOL_true;
              if (p_length == (const char **)&_xpc_BOOL_true)
              {
LABEL_201:
                if (_mrcs_server_queue_s_once != -1) {
                  dispatch_once(&_mrcs_server_queue_s_once, &__block_literal_global_17);
                }
                uint64_t v131 = _mrcs_server_queue_s_queue;
                size_t length = (size_t)_NSConcreteStackBlock;
                uint64_t v146 = 0x40000000LL;
                uint64_t v147 = (const char *)___mrcs_session_handle_dns_service_registration_start_block_invoke;
                uint64_t v148 = (uint64_t)&__block_descriptor_tmp_26_4213;
                int v149 = (const char *)v6;
                uint64_t v150 = v31;
                __int128 v132 = &length;
              }

              else
              {
                uint64_t v131 = 0LL;
                __int128 v132 = 0LL;
              }

              if (!*(void *)g_dns_service_registration_handlers) {
                goto LABEL_211;
              }
              uint64_t v135 = (*(uint64_t (**)(const char *, uint64_t, size_t *))g_dns_service_registration_handlers)( v58[5],  v131,  v132);
              if (v135) {
                int v136 = 0;
              }
              else {
                int v136 = -6700;
              }
              int v144 = v136;
              v58[7] = (const char *)v135;
              if (p_length == v60 && v135)
              {
                os_retain(v6);
                goto LABEL_213;
              }

              if (v135) {
                goto LABEL_213;
              }
            }
          }

          else if (v125 == 1)
          {
            v58[4] = (const char *)mdns_dns_service_definition_create_from_xpc_dictionary(v123, &v144);
            if (!v144)
            {
              if (*(void *)g_dns_service_registration_handlers)
              {
                uint64_t v129 = (*(uint64_t (**)(void))g_dns_service_registration_handlers)();
                if (v129)
                {
                  int v144 = 0;
                  v58[7] = (const char *)v129;
LABEL_213:
                  _BYTE v58[6] = (const char *)v31;
                  *char v41 = v58;
                  goto LABEL_184;
                }

                int v137 = -6700;
                goto LABEL_216;
              }

LABEL_211:
              int v137 = -6714;
LABEL_216:
              int v144 = v137;
              v58[7] = 0LL;
            }
          }

          else
          {
            int v144 = -6705;
          }

          os_release(v58);
          goto LABEL_184;
        }

        int v43 = -6728;
      }

      else
      {
LABEL_182:
        int v43 = -6705;
      }

      goto LABEL_183;
    case 4u:
      uint64_t v29 = xpc_dictionary_get_uint64(object, "id");
      BOOL v30 = v6 + 6;
      uint64_t v31 = v6[6];
      if (!v31) {
        goto LABEL_74;
      }
      if (*(void *)(v31 + 48) == v29) {
        goto LABEL_51;
      }
      do
      {
        uint64_t v32 = v31;
        uint64_t v31 = *(void *)(v31 + 24);
        if (!v31)
        {
LABEL_74:
          LODWORD(v25) = -6708;
          goto LABEL_42;
        }
      }

      while (*(void *)(v31 + 48) != v29);
      BOOL v30 = (void *)(v32 + 24);
LABEL_51:
      void *v30 = *(void *)(v31 + 24);
      *(void *)(v31 + memset(&v5[1], 0, 24) = 0LL;
      xpc_object_t v33 = *(void (**)(void))(g_dns_service_registration_handlers + 8);
      if (v33)
      {
        v33(*(void *)(v31 + 56));
        LODWORD(v25) = 0;
      }

      else
      {
LABEL_130:
        LODWORD(v25) = -6714;
      }

LABEL_223:
                CFRelease(v95);
                CFRelease(v105);
                if (v112)
                {
                  __int128 v134 = v112;
                  goto LABEL_197;
                }

    uint64_t v126 = -6736;
    goto LABEL_199;
  }

  uint64_t v4 = *(void *)(cache_record + 96);
  if (!v4) {
    goto LABEL_223;
  }
  __int128 v121 = CacheGroupForName((uint64_t)mDNSStorage, *(_DWORD *)(v4 + 200), (_BYTE *)(v4 + 356));
  if (!v121) {
    goto LABEL_223;
  }
  uint64_t v5 = *v123;
  size_t v6 = resource_record_get_cache_record(*(void *)(*v123 + 56));
  if (v6)
  {
    else {
      size_t v7 = *(_DWORD *)(v6 + 80) + 1000 * a2;
    }
    size_t v8 = v121[2];
    if (v8)
    {
      while (1)
      {
        uint64_t v9 = *(void *)(v5 + 48);
        if (v9) {
          uint64_t v9 = *(void *)(v9 + 24);
        }
        size_t v10 = *(void *)(v8 + 56);
        if (v10) {
          size_t v10 = *(void *)(v10 + 24);
        }
        if (v9 == v10)
        {
          int v11 = *(void *)(v8 + 64);
          if (v11)
          {
            if (*(_DWORD *)(v11 + 32) == 1 && identical_dnssec_validated_same_name_resource_record(v5, v8 + 8)) {
              break;
            }
          }
        }

        size_t v8 = *(void *)v8;
        if (!v8) {
          goto LABEL_27;
        }
      }

      if (*(_BYTE *)(v8 + 109)) {
        int v12 = dword_100158BF8 + 939524096;
      }
      else {
        int v12 = *(_DWORD *)(v8 + 80) + 1000 * *(_DWORD *)(v8 + 16);
      }
      if (v12 <= 1) {
        int v12 = 1;
      }
      if ((int)(v7 - v12) <= 999)
      {
        uint64_t v126 = 0;
        goto LABEL_199;
      }
    }

    goto LABEL_27;
  }

  __int128 v105 = (os_log_s *)mDNSLogCategory_DNSSEC;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_DNSSEC == mDNSLogCategory_State)
  {
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC, OS_LOG_TYPE_FAULT)) {
      goto LABEL_27;
    }
  }

  else
  {
    __int128 v105 = (os_log_s *)mDNSLogCategory_DNSSEC_redacted;
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC_redacted, OS_LOG_TYPE_FAULT)) {
      goto LABEL_27;
    }
  }

  *(_DWORD *)CFSocketContext buf = 136447234;
  *(void *)__int128 v128 = "rr_cr != NULL";
  *(_WORD *)&v128[8] = 2082;
  *(void *)&v128[10] = "";
  *(_WORD *)&v128[18] = 2082;
  *(void *)&v128[20] = "/Library/Caches/com.apple.xbs/Sources/mDNSResponder/mDNSMacOSX/dnssec_v2/dnssec_objs/dnssec_obj"
                         "_validation_manager.c";
  *(_WORD *)&v128[28] = 1024;
  *(_DWORD *)&v128[30] = 1759;
  *(_WORD *)&v128[34] = 2048;
  *(void *)&v128[36] = 0LL;
  _os_log_impl( (void *)&_mh_execute_header,  v105,  OS_LOG_TYPE_FAULT,  "AssertMacros: %{public}s, %{public}s file: %{public}s, line: %d, value: %ld",  buf,  0x30u);
LABEL_27:
  uint64_t v13 = CacheGroupForName((uint64_t)mDNSStorage, *(_DWORD *)(v4 + 200), (_BYTE *)(v4 + 356));
  if (v13 && (uint64_t v19 = v13[2]) != 0)
  {
    int v20 = 0LL;
    do
    {
      unsigned int v21 = *(void *)(v19 + 64);
      if (v21
        && *(_DWORD *)(v21 + 32) == 1
        && SameNameRecordAnswersQuestion((unsigned __int8 *)(v19 + 8), 0, v4, v14, v15, v16, v17, v18))
      {
        *(_DWORD *)(v19 + 80) = dword_100158BF8 + ~(1000 * *(_DWORD *)(v19 + 16));
        *(_BYTE *)(v19 + 10_Block_object_dispose(va, 8) = 4;
        SetNextCacheCheckTimeForRecord((uint64_t)mDNSStorage, v19);
        ++v20;
      }

      uint64_t v19 = *(void *)v19;
    }

    while (v19);
  }

  else
  {
    int v20 = 0LL;
  }

  bzero(v144, 0x800uLL);
  if (v2 > 0x100)
  {
    uint64_t v126 = -6751;
    int v106 = (os_log_s *)mDNSLogCategory_DNSSEC;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_DNSSEC == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC, OS_LOG_TYPE_FAULT)) {
        goto LABEL_199;
      }
    }

    else
    {
      int v106 = (os_log_s *)mDNSLogCategory_DNSSEC_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC_redacted, OS_LOG_TYPE_FAULT)) {
        goto LABEL_199;
      }
    }

    size_t v110 = bswap32(*(unsigned __int16 *)(v4 + 320));
    *(_DWORD *)CFSocketContext buf = 67109632;
    *(_DWORD *)__int128 v128 = HIWORD(v110);
    *(_WORD *)&v128[4] = 2048;
    *(void *)&v128[6] = v2;
    *(_WORD *)&v128[14] = 2048;
    *(void *)&v128[16] = 256LL;
    _os_log_impl( (void *)&_mh_execute_header,  v106,  OS_LOG_TYPE_FAULT,  "[Q%u] RRSet size too large, unable to process - rr_count: %zu, size limit: %zu",  buf,  0x1Cu);
    goto LABEL_199;
  }

  CFDataRef v117 = 0LL;
  __int128 v118 = v20;
  __int128 v114 = (_BYTE *)(v4 + 356);
  int v115 = v4;
  uint64_t v22 = 0LL;
  __int128 v124 = 0LL;
  uint64_t v23 = 0LL;
  if (v2 <= 1) {
    uint64_t v24 = 1LL;
  }
  else {
    uint64_t v24 = v2;
  }
  xpc_object_t v120 = v24;
  while (1)
  {
    unsigned int v25 = v23;
    xpc_object_t v26 = v2;
    int v27 = (unsigned __int8 *)v123[v22];
    char v28 = resource_record_get_cache_record(*((void *)v27 + 7));
    if (!v28) {
      break;
    }
    uint64_t v29 = v121[2];
    if (v29)
    {
      BOOL v30 = v28;
      while (1)
      {
        uint64_t v31 = *((void *)v27 + 6);
        if (v31) {
          uint64_t v31 = *(void *)(v31 + 24);
        }
        uint64_t v32 = *(void *)(v29 + 56);
        if (v32) {
          uint64_t v32 = *(void *)(v32 + 24);
        }
        if (v31 == v32)
        {
          xpc_object_t v33 = *(void *)(v29 + 64);
          if (v33)
          {
            if (*(_DWORD *)(v33 + 32) == 1
              && identical_dnssec_validated_same_name_resource_record((uint64_t)v27, v29 + 8))
            {
              break;
            }
          }
        }

        uint64_t v29 = *(void *)v29;
        if (!v29) {
          goto LABEL_66;
        }
      }

      CFDataRef v116 = *(_DWORD *)(v29 + 16);
      *(_DWORD *)(v29 + 80) = *(_DWORD *)(v30 + 80);
      *(_DWORD *)(v29 + 16) = a2;
      *(_BYTE *)(v29 + 10_Block_object_dispose(va, 8) = 0;
      SetNextCacheCheckTimeForRecord((uint64_t)mDNSStorage, v29);
      BOOL v34 = mDNSLogCategory_DNSSEC;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_DNSSEC == mDNSLogCategory_State)
      {
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC, OS_LOG_TYPE_DEBUG))
        {
          size_t v71 = *(void *)(v30 + 40);
          if (v71)
          {
            unsigned int v72 = *(_BYTE **)(v30 + 40);
            if (v71 == -256)
            {
LABEL_132:
              while (v72)
              {
                uint64_t v73 = *v72;
                if (!*v72)
                {
                  uint64_t v75 = (_WORD)v72 - v71 + 1;
                  goto LABEL_145;
                }

                v72 += v73 + 1;
                if (v71 != -256) {
                  goto LABEL_131;
                }
              }
            }

            else
            {
LABEL_131:
            }

            uint64_t v75 = 257;
LABEL_145:
            __int128 v112 = v75;
          }

          else
          {
            __int128 v112 = 0;
          }

          int v80 = *(unsigned __int16 *)(v30 + 12);
          actual_ttl = resource_record_get_actual_ttl((uint64_t)mDNSStorage, v29 + 8);
          *(_DWORD *)CFSocketContext buf = 68158978;
          *(_DWORD *)__int128 v128 = v112;
          *(_WORD *)&v128[4] = 2098;
          *(void *)&v128[6] = v71;
          *(_WORD *)&v128[14] = 1024;
          *(_DWORD *)&v128[16] = v80;
          *(_WORD *)&v128[20] = 1024;
          *(_DWORD *)&v128[22] = v116;
          *(_WORD *)&v128[26] = 1024;
          *(_DWORD *)&v128[28] = a2;
          *(_WORD *)&v128[32] = 1024;
          *(_DWORD *)&v128[34] = actual_ttl;
          uint64_t v79 = (os_log_s *)v34;
LABEL_147:
          _os_log_impl( (void *)&_mh_execute_header,  v79,  OS_LOG_TYPE_DEBUG,  "Rescuing DNSSEC validated record - name: %{public, mdnsresponder:domain_name}.*P, type: %{mdns:rrtype}d, old original ttl: %u, new original ttl: %u, new actual ttl: %u",  buf,  0x2Au);
        }
      }

      else
      {
        BOOL v35 = mDNSLogCategory_DNSSEC_redacted;
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC_redacted, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v36 = *(void *)(v30 + 40);
          size_t v111 = (os_log_s *)v35;
          if (v36)
          {
            BOOL v37 = *(_BYTE **)(v30 + 40);
            if (v36 == -256)
            {
LABEL_61:
              while (v37)
              {
                int v38 = *v37;
                if (!*v37)
                {
                  unint64_t v74 = (_WORD)v37 - v36 + 1;
                  goto LABEL_142;
                }

                v37 += v38 + 1;
                if (v36 != -256) {
                  goto LABEL_60;
                }
              }
            }

            else
            {
LABEL_60:
            }

            unint64_t v74 = 257;
LABEL_142:
            unint64_t v76 = v74;
          }

          else
          {
            unint64_t v76 = 0;
          }

          int v77 = *(unsigned __int16 *)(v30 + 12);
          __int16 v78 = resource_record_get_actual_ttl((uint64_t)mDNSStorage, v29 + 8);
          *(_DWORD *)CFSocketContext buf = 68158978;
          *(_DWORD *)__int128 v128 = v76;
          *(_WORD *)&v128[4] = 2098;
          *(void *)&v128[6] = v36;
          *(_WORD *)&v128[14] = 1024;
          *(_DWORD *)&v128[16] = v77;
          *(_WORD *)&v128[20] = 1024;
          *(_DWORD *)&v128[22] = v116;
          *(_WORD *)&v128[26] = 1024;
          *(_DWORD *)&v128[28] = a2;
          *(_WORD *)&v128[32] = 1024;
          *(_DWORD *)&v128[34] = v78;
          uint64_t v79 = v111;
          goto LABEL_147;
        }
      }

      if (*(_BYTE *)(v29 + 109))
      {
        int v82 = dword_100158BF8;
        uint64_t v83 = dword_100158BF8 + 939524096;
      }

      else
      {
        uint64_t v83 = *(_DWORD *)(v29 + 80) + 1000 * *(_DWORD *)(v29 + 16);
        int v82 = dword_100158BF8;
      }

      unint64_t v2 = v26;
      uint64_t v23 = v25;
      unsigned int v65 = v120;
      if (v83 - v82 > 0)
      {
LABEL_152:
        ++v117;
        --v118;
        goto LABEL_107;
      }

      uint64_t v84 = (os_log_s *)mDNSLogCategory_DNSSEC;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_DNSSEC == mDNSLogCategory_State)
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC, OS_LOG_TYPE_FAULT)) {
          goto LABEL_152;
        }
      }

      else
      {
        uint64_t v84 = (os_log_s *)mDNSLogCategory_DNSSEC_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC_redacted, OS_LOG_TYPE_FAULT)) {
          goto LABEL_152;
        }
      }

      *(_DWORD *)CFSocketContext buf = 136447234;
      *(void *)__int128 v128 = "RRExpireTime(cr) - mDNSStorage.timenow > 0";
      *(_WORD *)&v128[8] = 2082;
      *(void *)&v128[10] = "";
      *(_WORD *)&v128[18] = 2082;
      *(void *)&v128[20] = "/Library/Caches/com.apple.xbs/Sources/mDNSResponder/mDNSMacOSX/dnssec_v2/dnssec_objs/dnssec"
                             "_obj_validation_manager.c";
      *(_WORD *)&v128[28] = 1024;
      *(_DWORD *)&v128[30] = 1826;
      *(_WORD *)&v128[34] = 2048;
      *(void *)&v128[36] = 0LL;
      _os_log_impl( (void *)&_mh_execute_header,  v84,  OS_LOG_TYPE_FAULT,  "AssertMacros: %{public}s, %{public}s file: %{public}s, line: %d, value: %ld",  buf,  0x30u);
      goto LABEL_152;
    }

void ___mrcs_session_handle_dns_service_registration_start_block_invoke(uint64_t a1, int a2, int a3)
{
  if (a2 == 1)
  {
    uint64_t v3 = *(void *)(a1 + 32);
    if (*(void *)(v3 + 32))
    {
      uint64_t v5 = *(void *)(a1 + 40);
      xpc_object_t empty = xpc_dictionary_create_empty();
      if (empty)
      {
        size_t v7 = empty;
        xpc_dictionary_set_int64(empty, "connection_error", a3);
        xpc_object_t v8 = xpc_dictionary_create_empty();
        xpc_dictionary_set_uint64(v8, "id", v5);
        xpc_dictionary_set_value(v8, "body", v7);
        xpc_release(v7);
        if (v8)
        {
          xpc_connection_send_message(*(xpc_connection_t *)(v3 + 32), v8);
          os_release(v8);
        }
      }
    }
  }

  else if (a2 == 2)
  {
    os_release(*(void **)(a1 + 32));
  }

void ___mrcs_session_handle_record_cache_local_record_inquiry_block_invoke( uint64_t a1, const char *a2, unsigned __int16 *a3, unsigned int a4, unsigned __int8 *a5)
{
  uint64_t v19 = 0LL;
  if (a3)
  {
    int v8 = DNSRecordDataToStringEx(a3, a4, 16, 0LL, 0LL, 0, (uint64_t)&v19);
    if (!v19)
    {
      int v9 = v8;
      if (_mdns_server_log_s_once_4206 != -1) {
        dispatch_once(&_mdns_server_log_s_once_4206, &__block_literal_global_13);
      }
      size_t v10 = (os_log_s *)_mdns_server_log_s_log_4207;
      if (os_log_type_enabled((os_log_t)_mdns_server_log_s_log_4207, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)CFSocketContext buf = 136380931;
        *(void *)&uint8_t buf[4] = a2;
        *(_WORD *)&buf[12] = 2048;
        *(void *)&buf[14] = v9;
        _os_log_fault_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_FAULT,  "Failed to create device-info TXT RDATA string -- record name: '%{private}s', error: %{mdns:err}ld",  buf,  0x16u);
      }
    }
  }

  memset(buf, 0, 46);
  int v11 = a5[1];
  if (v11 == 30)
  {
    int v12 = a5 + 8;
    int v13 = 30;
    goto LABEL_11;
  }

  if (v11 == 2)
  {
    int v12 = a5 + 4;
    int v13 = 2;
LABEL_11:
    BOOL v14 = inet_ntop(v13, v12, (char *)buf, 0x2Eu);
    goto LABEL_13;
  }

  BOOL v14 = 0LL;
LABEL_13:
  uint64_t v15 = *(void **)(a1 + 32);
  uint64_t v16 = (const char *)v19;
  xpc_object_t empty = xpc_dictionary_create_empty();
  xpc_dictionary_set_string(empty, "name", a2);
  if (v16) {
    xpc_dictionary_set_string(empty, "rdata", v16);
  }
  if (v14) {
    xpc_dictionary_set_string(empty, "source_address", v14);
  }
  xpc_object_t optional_array = mdns_xpc_dictionary_get_optional_array(v15, "record_info");
  if (!optional_array)
  {
    xpc_object_t optional_array = xpc_array_create_empty();
    xpc_dictionary_set_value(v15, "record_info", optional_array);
    if (optional_array) {
      xpc_release(optional_array);
    }
  }

  xpc_array_append_value(optional_array, empty);
  if (empty) {
    xpc_release(empty);
  }
  if (v19) {
    free(v19);
  }
}

void ___mdns_server_log_block_invoke_4223(id a1)
{
  _mdns_server_log_s_log_4207 = (uint64_t)os_log_create("com.apple.mdns", "mrcs_server");
}

char *_dnssec_obj_rr_dnskey_copy_rdata_rfc_description(uint64_t a1, int *a2)
{
  unsigned int v6 = (unsigned __int16)(rdata_parser_dnskey_get_public_key_size(*(unsigned __int16 *)(a1 + 36)) + 2) / 3u;
  uint64_t v7 = snprintf( 0LL,  0LL,  "%u %u %u  (Key Tag: %u)",  __rev16(**(unsigned __int16 **)(a1 + 24)),  *(unsigned __int8 *)(*(void *)(a1 + 24) + 2LL),  *(unsigned __int8 *)(*(void *)(a1 + 24) + 3LL),  *(unsigned __int16 *)(a1 + 80))
     + 4LL * v6;
  size_t v8 = v7 + 1;
  if (v7 == -1 || (int v9 = (char *)calloc(1uLL, v7 + 1)) == 0LL)
  {
    __break(1u);
  }

  else
  {
    unint64_t v2 = v9;
    int v10 = snprintf( v9,  v8,  "%u %u %u ",  __rev16(**(unsigned __int16 **)(a1 + 24)),  *(unsigned __int8 *)(*(void *)(a1 + 24) + 2LL),  *(unsigned __int8 *)(*(void *)(a1 + 24) + 3LL));
    int v3 = -6700;
    if (v10 >= 1)
    {
      uint64_t v11 = 4LL * v6;
      int v12 = &v2[v8];
      int v13 = &v2[v10];
      BOOL v14 = (unsigned __int8 *)(*(void *)(a1 + 24) + 4LL);
      public_key_unint64_t size = rdata_parser_dnskey_get_public_key_size(*(unsigned __int16 *)(a1 + 36));
      base_x_encode(0, v14, public_key_size, v13);
      int v16 = snprintf(&v13[v11], v12 - &v13[v11], " (Key Tag: %u)", *(unsigned __int16 *)(a1 + 80));
      BOOL v17 = v16 < 1;
      if (v16 >= 1) {
        int v3 = 0;
      }
      else {
        int v3 = -6700;
      }
      if (!a2) {
        goto LABEL_9;
      }
      goto LABEL_8;
    }
  }

  BOOL v17 = 1;
  if (a2) {
LABEL_8:
  }
    *a2 = v3;
LABEL_9:
  if (v17)
  {
    free(v2);
    return 0LL;
  }

  return v2;
}

uint64_t dnssec_obj_rr_dnskey_create(unsigned __int8 *a1, __int16 a2, _BYTE *a3, unsigned int a4, int *a5)
{
  int v22 = 0;
  if (a4 <= 4)
  {
    uint64_t v5 = 0LL;
    uint64_t v19 = 0LL;
    int v12 = -6705;
    int v22 = -6705;
  }

  else
  {
    uint64_t v11 = calloc(1uLL, 0x58uLL);
    if (v11)
    {
      uint64_t v5 = (uint64_t)v11;
      int v13 = &_dnssec_obj_rr_dnskey_kind;
      v11[1] = &_dnssec_obj_rr_dnskey_kind;
      do
      {
        BOOL v14 = (void (*)(uint64_t))v13[2];
        if (v14) {
          v14(v5);
        }
        int v13 = (_UNKNOWN **)*v13;
      }

      while (v13);
      ++*(_DWORD *)v5;
      dnssec_obj_rr_init_fields( v5,  a1,  48,  a2,  a3,  a4,  0,  (uint64_t)_dnssec_obj_rr_dnskey_copy_rdata_rfc_description,  &v22);
      int v12 = v22;
      if (!v22)
      {
        if (a3[3] != 1)
        {
          uint64_t v15 = 0LL;
          unsigned int v16 = 0;
          do
          {
            int v17 = a3[v15];
            if ((v15 & 1) == 0) {
              v17 <<= 8;
            }
            v16 += v17;
            ++v15;
          }

          while (a4 != v15);
          unsigned int v18 = v16 + HIWORD(v16);
          goto LABEL_14;
        }

        unsigned int v21 = (os_log_s *)mDNSLogCategory_DNSSEC;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_DNSSEC == mDNSLogCategory_State)
        {
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC, OS_LOG_TYPE_FAULT))
          {
LABEL_28:
            *(_DWORD *)CFSocketContext buf = 136447234;
            uint64_t v24 = "rdata_parser_dnskey_get_algorithm(rdata) != DNSKEY_ALGORITHM_RSAMD5";
            __int16 v25 = 2082;
            xpc_object_t v26 = "";
            __int16 v27 = 2082;
            char v28 = "/Library/Caches/com.apple.xbs/Sources/mDNSResponder/mDNSMacOSX/dnssec_v2/dnssec_objs/dnssec_obj_rr_dnskey.c";
            __int16 v29 = 1024;
            int v30 = 364;
            __int16 v31 = 2048;
            uint64_t v32 = 0LL;
            _os_log_impl( (void *)&_mh_execute_header,  v21,  OS_LOG_TYPE_FAULT,  "AssertMacros: %{public}s, %{public}s file: %{public}s, line: %d, value: %ld",  buf,  0x30u);
          }
        }

        else
        {
          unsigned int v21 = (os_log_s *)mDNSLogCategory_DNSSEC_redacted;
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC_redacted, OS_LOG_TYPE_FAULT)) {
            goto LABEL_28;
          }
        }

        LOWORD(v1_Block_object_dispose(va, 8) = 0;
LABEL_14:
        int v12 = 0;
        *(_WORD *)(v5 + 80) = v18;
        ++*(_DWORD *)v5;
        int v22 = 0;
        uint64_t v19 = v5;
        goto LABEL_15;
      }
    }

    else
    {
      __break(1u);
    }

    uint64_t v19 = 0LL;
  }

uint64_t dnssec_obj_rr_dnskey_is_valid_for_dnssec(_BYTE *a1, int *a2)
{
  if ((*a1 & 1) != 0)
  {
    char v2 = a1[2];
    if (v2)
    {
      unsigned int v3 = a1[3] - 5;
      unint64_t v4 = (0xF2DuLL >> (a1[3] - 5)) & 1;
      if (v4) {
        int v5 = 0;
      }
      else {
        int v5 = -88890;
      }
      BOOL v6 = v3 > 0xB;
      if (v3 <= 0xB) {
        char v2 = v4;
      }
      else {
        char v2 = 0;
      }
      if (v6) {
        int v7 = -88890;
      }
      else {
        int v7 = v5;
      }
    }

    else
    {
      int v7 = -88889;
    }
  }

  else
  {
    char v2 = 0;
    int v7 = -88888;
  }

  if (a2) {
    *a2 = v7;
  }
  return v2 & 1;
}

void *_mdns_xpc_dictionary_get_int64_limited(void *a1, const char *a2, uint64_t a3, uint64_t a4, BOOL *a5)
{
  uint64_t result = _mdns_xpc_dictionary_get_object(a1, a2, (const _xpc_type_s *)&_xpc_type_int64);
  if (!result)
  {
    BOOL v9 = 0;
    if (!a5) {
      return result;
    }
    goto LABEL_5;
  }

  uint64_t result = (void *)xpc_int64_get_value(result);
  BOOL v9 = (uint64_t)result >= a3 && (uint64_t)result <= a4;
  if (!v9) {
    uint64_t result = 0LL;
  }
  if (a5) {
LABEL_5:
  }
    *a5 = v9;
  return result;
}

xpc_object_t _mdns_xpc_dictionary_get_object(void *a1, const char *a2, const _xpc_type_s *a3)
{
  xpc_object_t value = xpc_dictionary_get_value(a1, a2);
  xpc_object_t v5 = value;
  if (value && xpc_get_type(value) != a3) {
    return 0LL;
  }
  return v5;
}

void *_mdns_xpc_object_get_uint64_limited(void *result, unint64_t a2, BOOL *a3)
{
  if (!result)
  {
LABEL_9:
    BOOL v6 = 0;
    if (!a3) {
      return result;
    }
    goto LABEL_6;
  }

  xpc_object_t v5 = result;
  if (xpc_get_type(result) != (xpc_type_t)&_xpc_type_uint64)
  {
    uint64_t result = 0LL;
    goto LABEL_9;
  }

  uint64_t result = (void *)xpc_uint64_get_value(v5);
  BOOL v6 = (unint64_t)result <= a2;
  if (a3) {
LABEL_6:
  }
    *a3 = v6;
  return result;
}

xpc_object_t mdns_xpc_dictionary_get_optional_array(void *a1, const char *a2)
{
  xpc_object_t value = xpc_dictionary_get_value(a1, a2);
  xpc_object_t v3 = value;
  if (value && xpc_get_type(value) != (xpc_type_t)&_xpc_type_array) {
    return 0LL;
  }
  return v3;
}

BOOL mdns_xpc_connection_is_entitled(uint64_t a1, uint64_t a2)
{
  char v2 = (void *)xpc_connection_copy_entitlement_value(a1, a2);
  xpc_object_t v3 = v2;
  if (v2) {
    xpc_release(v2);
  }
  return v3 == &_xpc_BOOL_true;
}

xpc_object_t mdns_xpc_string_create_with_format( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  return xpc_string_create_with_format_and_arguments("%.*s", &a9);
}

uint64_t mdns_xpc_string_recreate(xpc_object_t *a1, char *string)
{
  xpc_object_t v4 = *a1;
  if (!v4) {
    goto LABEL_6;
  }
  string_ptr = xpc_string_get_string_ptr(v4);
  if (!string_ptr || (uint64_t result = strcmp(string_ptr, string), (_DWORD)result))
  {
    if (*a1)
    {
      xpc_release(*a1);
      *a1 = 0LL;
    }

void *_mdns_address_copy_description(void *a1, int a2, char a3)
{
  BOOL v6 = (void *)mdns_string_builder_create();
  if (!v6) {
    return 0LL;
  }
  int v7 = v6;
  if (a2 && mdns_string_builder_append_formatted(v6, "<%s: %p>: ", *(const char **)(a1[2] + 8LL), a1)
    || mdns_string_builder_append_sockaddr_description(v7, (uint64_t)(a1 + 3), a3))
  {
    size_t v8 = 0LL;
  }

  else
  {
    size_t v8 = mdns_string_builder_copy_string((uint64_t)v7);
  }

  os_release(v7);
  return v8;
}

BOOL _mdns_address_equal(uint64_t a1, uint64_t a2)
{
  int v2 = *(unsigned __int8 *)(a1 + 25);
  if (v2 == 30) {
    return *(unsigned __int16 *)(a1 + 26) == *(unsigned __int16 *)(a2 + 26)
  }
        && *(void *)(a1 + 32) == *(void *)(a2 + 32)
        && *(void *)(a1 + 40) == *(void *)(a2 + 40);
  return v2 == 2
}

uint64_t _mdns_address_new()
{
  uint64_t v0 = _os_object_alloc(&OBJC_CLASS___OS_mdns_address, 56LL);
  uint64_t v1 = v0;
  if (v0)
  {
    int v2 = &_mdns_address_kind;
    *(void *)(v0 + 16) = &_mdns_address_kind;
    do
    {
      xpc_object_t v3 = (void (*)(uint64_t))v2[2];
      if (v3) {
        v3(v1);
      }
      int v2 = (_UNKNOWN **)*v2;
    }

    while (v2);
  }

  return v1;
}

uint64_t mdns_address_create_from_ip_address_string(char *a1)
{
  uint64_t v1 = a1;
  int v19 = 0;
  __int128 v28 = 0uLL;
  int v2 = *a1;
  if (v2 == 91)
  {
    xpc_object_t v3 = a1 + 1;
    uint64_t result = (uint64_t)strchr(a1 + 1, 93);
    if (!result) {
      return result;
    }
    uint64_t v5 = result;
    unsigned int v6 = *(unsigned __int8 *)(v5 + 1);
    if (v6 == 58)
    {
      int v7 = (unsigned __int8 *)(v5 + 2);
      goto LABEL_15;
    }

    if (*(_BYTE *)(v5 + 1)) {
      return 0LL;
    }
LABEL_24:
    int v14 = v19;
    uint64_t result = _mdns_address_new();
    if (result)
    {
      *(_WORD *)(result + memset(&v5[1], 0, 24) = 7708;
      *(_WORD *)(result + 26) = bswap32(v6) >> 16;
      *(_OWORD *)(result + 32) = v28;
      *(_DWORD *)(result + 4_Block_object_dispose(va, 8) = v14;
    }

    return result;
  }

  if (!_mdns_address_parse_ipv6(a1, 0LL, &v28, &v19))
  {
    unsigned int v6 = 0;
    goto LABEL_24;
  }

  __int128 v26 = 0u;
  __int128 v27 = 0u;
  __int128 v24 = 0u;
  __int128 v25 = 0u;
  __int128 v22 = 0u;
  __int128 v23 = 0u;
  *(_OWORD *)int v20 = 0u;
  __int128 v21 = 0u;
  size_t v8 = strchr(v1, 58);
  if (v8)
  {
    BOOL v9 = v8;
    int64_t v10 = v8 - v1;
    __memcpy_chk(v20, v1, v10, 128LL);
    v20[v10] = 0;
    int v7 = (unsigned __int8 *)(v9 + 1);
    uint64_t v1 = v20;
  }

  else
  {
    int v7 = 0LL;
  }

  if (inet_pton(2, v1, &v28) != 1) {
    return 0LL;
  }
LABEL_15:
  if (v7)
  {
    int v11 = *v7;
    if ((v11 - 48) <= 9)
    {
      unsigned int v6 = 0;
      int v12 = v7 + 1;
      while (1)
      {
        unsigned int v6 = 10 * v6 + (char)v11 - 48;
        if (HIWORD(v6)) {
          break;
        }
        int v13 = *v12++;
        int v11 = v13;
        if ((v13 - 48) >= 0xA)
        {
          if (!v11) {
            goto LABEL_23;
          }
          return 0LL;
        }
      }
    }

    return 0LL;
  }

  unsigned int v6 = 0;
LABEL_23:
  if (v2 == 91) {
    goto LABEL_24;
  }
  int v15 = v28;
  int v16 = BYTE1(v28);
  int v17 = BYTE2(v28);
  int v18 = BYTE3(v28);
  uint64_t result = _mdns_address_new();
  if (result)
  {
    *(_WORD *)(result + memset(&v5[1], 0, 24) = 528;
    *(_WORD *)(result + 26) = bswap32(v6) >> 16;
    *(_DWORD *)(result + 2_Block_object_dispose(va, 8) = bswap32((v15 << 24) | (v16 << 16) | (v17 << 8) | v18);
  }

  return result;
}

uint64_t _mdns_address_parse_ipv6(_BYTE *a1, unsigned __int8 *a2, _OWORD *a3, _DWORD *a4)
{
  unsigned int v6 = a2;
  if (!a2)
  {
    unsigned int v6 = a1 - 1;
    while (*++v6)
      ;
  }

  uint64_t v8 = v6 - a1;
  if (v6 <= a1)
  {
LABEL_8:
    unint64_t v9 = 0LL;
  }

  else
  {
    unint64_t v9 = (unint64_t)a1;
    while (*(_BYTE *)v9 != 37)
    {
      ++v9;
      if (!--v8) {
        goto LABEL_8;
      }
    }
  }

  if (v9) {
    unint64_t v10 = v9;
  }
  else {
    unint64_t v10 = (unint64_t)v6;
  }
  __int128 v29 = 0u;
  __int128 v30 = 0u;
  unint64_t v11 = v10 - (void)a1;
  __int128 v27 = 0u;
  __int128 v28 = 0u;
  __int128 v25 = 0u;
  __int128 v26 = 0u;
  *(_OWORD *)__int128 v23 = 0u;
  __int128 v24 = 0u;
  __memcpy_chk(v23, a1, v10 - (void)a1, 128LL);
  v23[v11] = 0;
  __int128 v22 = 0uLL;
  if (inet_pton(30, v23, &v22) != 1) {
    return 4294960554LL;
  }
  if (v9)
  {
    int v12 = (unsigned __int8 *)(v9 + 1);
    unint64_t v13 = (unint64_t)&v6[-v9 - 1];
    __dst[0] = 0LL;
    __dst[1] = 0LL;
    char v21 = 0;
    if (v13 >= 0x11)
    {
      if (v13 == -1LL || (v14 = malloc((size_t)&v6[-v9]), (int v15 = v14) == 0LL)) {
        __break(1u);
      }
    }

    else
    {
      int v14 = 0LL;
      int v15 = __dst;
    }

    memcpy(v15, (const void *)(v9 + 1), (size_t)&v6[-v9 - 1]);
    *((_BYTE *)v15 + v13) = 0;
    LODWORD(v13) = if_nametoindex((const char *)v15);
    if (v14) {
      free(v14);
    }
    if (!(_DWORD)v13)
    {
      if (v12 >= v6) {
        return 4294960554LL;
      }
      unint64_t v13 = 0LL;
      int v17 = &v6[~v9];
      int v18 = (unsigned __int8 *)(v9 + 1);
      while (1)
      {
        int v19 = *v18;
        unint64_t v13 = ((char)v19 - 48) + 10 * v13;
        if (HIDWORD(v13)) {
          return 4294960554LL;
        }
        ++v18;
        if (!--v17)
        {
          int v18 = v6;
          break;
        }
      }

      if (v18 != v6 || v18 == v12) {
        return 4294960554LL;
      }
    }
  }

  else
  {
    LODWORD(v13) = 0;
  }

  if (a3) {
    *a3 = v22;
  }
  uint64_t result = 0LL;
  if (a4) {
    *a4 = v13;
  }
  return result;
}

uint64_t _dnssec_obj_denial_of_existence_compare(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a1 + 16) != *(_DWORD *)(a2 + 16)) {
    return 2LL;
  }
  if (*(_DWORD *)(a1 + 44) != *(_DWORD *)(a2 + 44)) {
    return 2LL;
  }
  uint64_t v4 = *(unsigned __int8 *)(a1 + 72);
  if (*(_BYTE *)(a1 + 72))
  {
    uint64_t v5 = (unsigned __int8 *)(a2 + 104);
    unsigned int v6 = (unsigned __int8 *)(a1 + 104);
    do
    {
      int v8 = *v6++;
      int v7 = v8;
      int v9 = *v5++;
      if (v7 != v9) {
        return 2LL;
      }
    }

    while (--v4);
  }

  if (*(_BYTE *)(a1 + 40))
  {
    uint64_t v11 = 0LL;
    while (!ref_count_obj_compare( *(void *)(*(void *)(a1 + 32) + 8 * v11),  *(void *)(*(void *)(a2 + 32) + 8 * v11),  1LL))
    {
    }

    return 2LL;
  }

void _dnssec_obj_denial_of_existence_finalize(uint64_t a1)
{
  int v2 = *(void **)(a1 + 24);
  if (v2)
  {
    ref_count_obj_release(v2);
    *(void *)(a1 + memset(&v5[1], 0, 24) = 0LL;
  }

  unsigned int v3 = *(unsigned __int8 *)(a1 + 40);
  if (*(_BYTE *)(a1 + 40))
  {
    unint64_t v4 = 0LL;
    do
    {
      uint64_t v5 = *(void **)(*(void *)(a1 + 32) + 8 * v4);
      if (v5)
      {
        ref_count_obj_release(v5);
        *(void *)(*(void *)(a1 + 32) + 8 * v4) = 0LL;
        unsigned int v3 = *(unsigned __int8 *)(a1 + 40);
      }

      ++v4;
    }

    while (v4 < v3);
  }

  unsigned int v6 = *(void **)(a1 + 32);
  if (v6)
  {
    free(v6);
    *(void *)(a1 + 32) = 0LL;
  }

  int v7 = *(_DWORD *)(a1 + 44);
  if (v7 == 1)
  {
    unsigned int v8 = *(unsigned __int8 *)(a1 + 72);
    if (!*(_BYTE *)(a1 + 72)) {
      return;
    }
    unint64_t v12 = 0LL;
    uint64_t v13 = a1 + 48;
    do
    {
      uint64_t v14 = *(void **)(v13 + 8 * v12);
      if (v14)
      {
        ref_count_obj_release(v14);
        *(void *)(v13 + 8 * v12) = 0LL;
        unsigned int v8 = *(unsigned __int8 *)(a1 + 72);
      }

      ++v12;
    }

    while (v12 < v8);
  }

  else if (v7 == 2)
  {
    unsigned int v8 = *(unsigned __int8 *)(a1 + 72);
    if (!*(_BYTE *)(a1 + 72)) {
      return;
    }
    unint64_t v9 = 0LL;
    uint64_t v10 = a1 + 48;
    do
    {
      uint64_t v11 = *(void **)(v10 + 8 * v9);
      if (v11)
      {
        ref_count_obj_release(v11);
        *(void *)(v10 + 8 * uuid_unparse_lower(out, v9) = 0LL;
        unsigned int v8 = *(unsigned __int8 *)(a1 + 72);
      }

      ++v9;
    }

    while (v9 < v8);
  }

  else
  {
    unsigned int v8 = *(unsigned __int8 *)(a1 + 72);
  }

  if (v8)
  {
    unint64_t v15 = 0LL;
    do
    {
      unsigned __int8 v16 = *(_BYTE *)(a1 + v15 + 104);
      if (v16)
      {
        unint64_t v17 = 0LL;
        int v18 = (void *)(a1 + 8 * v15 + 80);
        do
        {
          int v19 = *(void **)(*v18 + 8 * v17);
          if (v19)
          {
            ref_count_obj_release(v19);
            *(void *)(*v18 + 8 * v17) = 0LL;
            unsigned __int8 v16 = *(_BYTE *)(a1 + v15 + 104);
          }

          ++v17;
        }

        while (v17 < v16);
      }

      uint64_t v20 = a1 + 8 * v15;
      __int128 v23 = *(void **)(v20 + 80);
      __int128 v22 = (void *)(v20 + 80);
      char v21 = v23;
      if (v23)
      {
        free(v21);
        *__int128 v22 = 0LL;
      }

      ++v15;
    }

    while (v15 < *(unsigned __int8 *)(a1 + 72));
  }

void *dnssec_obj_denial_of_existence_create( unsigned __int8 *a1, int a2, unsigned int a3, unsigned __int8 *a4, unsigned __int8 *a5, _DWORD *a6, unsigned __int8 *a7, unsigned int a8, uint64_t a9, unsigned __int8 a10, uint64_t *a11, unsigned __int8 a12, uint64_t a13, unsigned __int8 a14, int *a15)
{
  if (a6) {
    char v21 = a7;
  }
  else {
    char v21 = 0LL;
  }
  if (v21) {
    BOOL v22 = a6 == 0LL;
  }
  else {
    BOOL v22 = 1;
  }
  if (v22) {
    __int128 v23 = 0LL;
  }
  else {
    __int128 v23 = (unsigned __int8 *)a8;
  }
  if (a9) {
    uint64_t v24 = a10;
  }
  else {
    uint64_t v24 = 0LL;
  }
  if (a11) {
    unint64_t k = a12;
  }
  else {
    unint64_t k = 0LL;
  }
  uint64_t v234 = v24;
  if ((_DWORD)v24) {
    uint64_t v26 = a9;
  }
  else {
    uint64_t v26 = 0LL;
  }
  if ((_DWORD)k) {
    __int128 v27 = a11;
  }
  else {
    __int128 v27 = 0LL;
  }
  int v227 = v23;
  uint64_t v228 = a13;
  if (a13) {
    BOOL v28 = (v26 | (unint64_t)v27) == 0;
  }
  else {
    BOOL v28 = 1;
  }
  if (v28) {
    uint64_t v29 = 0LL;
  }
  else {
    uint64_t v29 = a14;
  }
  uint64_t v232 = v29;
  __int128 v30 = calloc(1uLL, 0x70uLL);
  if (!v30) {
    goto LABEL_383;
  }
  unint64_t v15 = v30;
  __int16 v31 = a15;
  uint64_t v32 = &_dnssec_obj_denial_of_existence_kind;
  v30[1] = &_dnssec_obj_denial_of_existence_kind;
  do
  {
    xpc_object_t v33 = (void (*)(void *))v32[2];
    if (v33) {
      v33(v15);
    }
    uint64_t v32 = (_UNKNOWN **)*v32;
  }

  while (v32);
  ++*(_DWORD *)v15;
  if (!(k | v234))
  {
    uint64_t v81 = 0LL;
    int v82 = -6705;
    goto LABEL_417;
  }

  if (!(_DWORD)k)
  {
    if (!(_DWORD)v234)
    {
      uint64_t v81 = 0LL;
      *((_DWORD *)v15 + 11) = 0;
      *((_DWORD *)v15 + 4) = 0;
      int v82 = -6705;
      uint64_t v83 = v15;
      *((_BYTE *)v15 + 72) = 0;
      goto LABEL_378;
    }

    LODWORD(v246) = 0;
    BOOL v50 = (_DWORD)a5 == a3 || (_DWORD)a5 == 5;
    *((_DWORD *)v15 + 11) = 1;
    *((_DWORD *)v15 + 4) = 2;
    *((_BYTE *)v15 + 107) = 0;
    *((_BYTE *)v15 + 72) = 0;
    xpc_object_t v51 = dnssec_obj_domain_name_create_with_labels(a1, 0, (int *)&v246);
    int v231 = a15;
    int v226 = v21;
    if ((_DWORD)v246)
    {
      uint64_t v56 = 0LL;
      uint64_t v17 = 0LL;
      uint64_t v57 = 0LL;
      size_t v55 = 0LL;
    }

    else
    {
      uint64_t v52 = 0LL;
      while (1)
      {
        BOOL does_not_exist = dnssec_obj_rr_nsec_asserts_name_exists_data_does_not_exist( *(void *)(v26 + 8 * v52),  (uint64_t)v51,  a2,  a3);
        uint64_t v54 = *(void *)(v26 + 8 * v52);
        if (does_not_exist)
        {
          ++*(_DWORD *)v54;
          v15[*((unsigned __int8 *)v15 + 72) + 6] = v54;
          uint64_t v84 = *((unsigned __int8 *)v15 + 72);
          ++*(_DWORD *)v15[v84 + 6];
          *((_BYTE *)v15 + 72) = v84 + 1;
          *((_DWORD *)v15 + 4) = 3;
          uint64_t v85 = *(_BYTE **)(v54 + 24);
          __int16 v86 = *(_WORD *)(v54 + 36);
          if ((dnssec_obj_rr_nsec_covers_dns_type(v85, v86, 0x2Bu) & 1) != 0)
          {
            char v87 = 0;
            uint64_t v88 = a6;
          }

          else
          {
            uint64_t v88 = a6;
            if ((dnssec_obj_rr_nsec_covers_dns_type(v85, v86, 6u) & 1) != 0) {
              char v87 = 0;
            }
            else {
              char v87 = dnssec_obj_rr_nsec_covers_dns_type(v85, v86, 2u);
            }
          }

          size_t v55 = 0LL;
          uint64_t v56 = 0LL;
          uint64_t v17 = 0LL;
          uint64_t v57 = 0LL;
          *((_BYTE *)v15 + 107) = v87;
          goto LABEL_211;
        }

        if (v234 == ++v52)
        {
          uint64_t v54 = 0LL;
          size_t v55 = 0LL;
          uint64_t v56 = 0LL;
          uint64_t v17 = 0LL;
          uint64_t v57 = 0LL;
          goto LABEL_206;
        }
      }

      BOOL v239 = v50;
      size_t v55 = *(unsigned __int8 **)(v26 + 8 * v52);
      ++*(_DWORD *)v55;
      *(_DWORD *)CFSocketContext buf = 0;
      int v89 = (_BYTE *)*((void *)v51 + 2);
      if (*v89)
      {
        xpc_object_t v90 = dnssec_obj_domain_name_copy_parent_domain(v89, 1uLL, (int *)buf);
        int v91 = v90;
        uint64_t v240 = v55;
        if (!*(_DWORD *)buf)
        {
          uint64_t v92 = *((void *)v55 + 2);
          uint64_t v93 = *((void *)v55 + 10);
          int v94 = dnssec_obj_domain_name_copy_closest_common_ancestor( *(unsigned __int8 **)(v92 + 16),  *((unsigned __int8 **)v90 + 2),  buf);
          if (!*(_DWORD *)buf)
          {
            uint64_t v95 = dnssec_obj_domain_name_copy_closest_common_ancestor( *(unsigned __int8 **)(v93 + 16),  *((unsigned __int8 **)v91 + 2),  buf);
            uint64_t v96 = v95;
            if (*(_DWORD *)buf)
            {
              LODWORD(v246) = *(_DWORD *)buf;
              ref_count_obj_release(v91);
              uint64_t v57 = 0LL;
              if (v96) {
                goto LABEL_134;
              }
            }

            else
            {
              unint64_t v97 = *((void *)v94 + 3);
              unint64_t v98 = *((void *)v95 + 3);
              if (v97 <= v98) {
                int v99 = v95;
              }
              else {
                int v99 = v94;
              }
              LOWORD(v242) = 10753;
              BYTE2(v242) = 0;
              uint64_t v57 = dnssec_obj_domain_name_create_concatenation_with_subdomain(&v242, *((_BYTE **)v99 + 2), buf);
              LODWORD(v246) = *(_DWORD *)buf;
              ref_count_obj_release(v91);
              ref_count_obj_release(v99);
              if (v97 > v98)
              {
                int v94 = 0LL;
LABEL_134:
                ref_count_obj_release(v96);
              }
            }

            int v91 = v94;
            unsigned int v100 = a3;
            uint64_t v101 = v234;
            if (!v94) {
              goto LABEL_137;
            }
            goto LABEL_136;
          }

          uint64_t v57 = 0LL;
          LODWORD(v246) = *(_DWORD *)buf;
          uint64_t v96 = v91;
          goto LABEL_134;
        }

        LODWORD(v246) = *(_DWORD *)buf;
        if (v90)
        {
          uint64_t v57 = 0LL;
          unsigned int v100 = a3;
          uint64_t v101 = v234;
LABEL_136:
          ref_count_obj_release(v91);
LABEL_137:
          if ((_DWORD)v246)
          {
            uint64_t v56 = 0LL;
            uint64_t v17 = 0LL;
            uint64_t v54 = 0LL;
            uint64_t v88 = a6;
            size_t v55 = v240;
            goto LABEL_212;
          }

          uint64_t v102 = 0LL;
          while (1)
          {
            char v103 = dnssec_obj_rr_nsec_asserts_name_does_not_exist(*(void *)(v26 + 8 * v102), (uint64_t)v57, a2);
            uint64_t v17 = *(void *)(v26 + 8 * v102);
            if ((v103 & 1) != 0) {
              break;
            }
            if (dnssec_obj_rr_nsec_asserts_name_exists_data_does_not_exist( *(void *)(v26 + 8 * v102),  (uint64_t)v57,  a2,  v100))
            {
              uint64_t v56 = *(unsigned __int8 **)(v26 + 8 * v102);
              ++*(_DWORD *)v56;
              int v144 = v15 + 6;
              size_t v55 = v240;
              v15[*((unsigned __int8 *)v15 + 72) + 6] = v240;
              uint64_t v145 = *((unsigned __int8 *)v15 + 72);
              ++*(_DWORD *)v15[v145 + 6];
              unsigned __int8 v146 = v145 + 1;
              *((_BYTE *)v15 + 72) = v146;
              if (v56 != v240)
              {
                v144[v146] = v56;
                uint64_t v147 = *((unsigned __int8 *)v15 + 72);
                ++*(_DWORD *)v144[v147];
                *((_BYTE *)v15 + 72) = v147 + 1;
              }

              uint64_t v54 = 0LL;
              uint64_t v17 = 0LL;
              int v105 = 6;
              goto LABEL_205;
            }

            if (v101 == ++v102)
            {
              if (v239)
              {
                uint64_t v54 = 0LL;
                uint64_t v56 = 0LL;
                uint64_t v17 = 0LL;
                size_t v55 = v240;
                v15[*((unsigned __int8 *)v15 + 72) + 6] = v240;
                uint64_t v104 = *((unsigned __int8 *)v15 + 72);
                ++*(_DWORD *)v15[v104 + 6];
                *((_BYTE *)v15 + 72) = v104 + 1;
                int v105 = 5;
                goto LABEL_205;
              }

              uint64_t v54 = 0LL;
              uint64_t v56 = 0LL;
              uint64_t v17 = 0LL;
              uint64_t v88 = a6;
              size_t v55 = v240;
LABEL_211:
              LODWORD(v246) = 0;
LABEL_212:
              dnssec_objs_sort((uint64_t)(v15 + 6), *((unsigned __int8 *)v15 + 72));
              int v82 = v246;
              if (v56) {
                ref_count_obj_release(v56);
              }
              if (v17) {
                ref_count_obj_release((void *)v17);
              }
              if (v57) {
                ref_count_obj_release(v57);
              }
              if (v55) {
                ref_count_obj_release(v55);
              }
              if (v54) {
                ref_count_obj_release((void *)v54);
              }
              if (v51) {
                ref_count_obj_release(v51);
              }
              __int16 v31 = a15;
              if (!v82) {
                goto LABEL_320;
              }
              int v149 = (os_log_s *)mDNSLogCategory_DNSSEC;
              if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_DNSSEC == mDNSLogCategory_State)
              {
                if (os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC, OS_LOG_TYPE_DEBUG))
                {
                  int v150 = (int)a1;
                  if (a1)
                  {
                    LODWORD(v221) = (_DWORD)a1;
                    int v222 = *a1;
                    if (*a1)
                    {
                      uint64_t v221 = a1;
                      do
                      {
                        unsigned int v223 = &v221[v222];
                        int v224 = v223[1];
                        uint64_t v221 = v223 + 1;
                        int v222 = v224;
                      }

                      while (v224);
                    }

                    int v150 = (_DWORD)v221 - (_DWORD)a1 + 1;
                  }

LABEL_415:
                  *(_DWORD *)CFSocketContext buf = 141559299;
                  *(void *)&uint8_t buf[4] = 1752392040LL;
                  *(_WORD *)&buf[12] = 1040;
                  *(_DWORD *)&buf[14] = v150;
                  *(_WORD *)&_BYTE buf[18] = 2101;
                  *(void *)&buf[20] = a1;
                  *(_WORD *)&buf[28] = 1024;
                  *(_DWORD *)&buf[30] = a3;
                  *(_WORD *)uint64_t v244 = 1024;
                  *(_DWORD *)&v244[2] = v234;
                  LOWORD(v245[0]) = 2082;
                  *(void *)((char *)v245 + 2) = "Unknown DNSSEC error.";
                  _os_log_impl( (void *)&_mh_execute_header,  v149,  OS_LOG_TYPE_DEBUG,  "Failed to find out a provable denial of existence NSEC set - qname: %{sensitive, mask.hash, mdnsresp onder:domain_name}.*P, qtype: %u, NSEC count: %u, error: %{public}s",  buf,  0x32u);
                }
              }

              else
              {
                int v149 = (os_log_s *)mDNSLogCategory_DNSSEC_redacted;
                if (os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC_redacted, OS_LOG_TYPE_DEBUG))
                {
                  int v150 = (int)a1;
                  if (a1)
                  {
                    LODWORD(v151) = (_DWORD)a1;
                    int v152 = *a1;
                    if (*a1)
                    {
                      unsigned int v151 = a1;
                      do
                      {
                        uint64_t v153 = &v151[v152];
                        int v154 = v153[1];
                        unsigned int v151 = v153 + 1;
                        int v152 = v154;
                      }

                      while (v154);
                    }

                    int v150 = (_DWORD)v151 - (_DWORD)a1 + 1;
                  }

                  goto LABEL_415;
                }
              }

LABEL_416:
              uint64_t v81 = 0LL;
LABEL_417:
              uint64_t v83 = v15;
              goto LABEL_378;
            }
          }

          ++*(_DWORD *)v17;
          size_t v140 = v15 + 6;
          size_t v55 = v240;
          v15[*((unsigned __int8 *)v15 + 72) + 6] = v240;
          uint64_t v141 = *((unsigned __int8 *)v15 + 72);
          ++*(_DWORD *)v15[v141 + 6];
          unsigned __int8 v142 = v141 + 1;
          *((_BYTE *)v15 + 72) = v142;
          if ((unsigned __int8 *)v17 != v240)
          {
            v140[v142] = v17;
            uint64_t v143 = *((unsigned __int8 *)v15 + 72);
            ++*(_DWORD *)v140[v143];
            *((_BYTE *)v15 + 72) = v143 + 1;
          }

          uint64_t v54 = 0LL;
          uint64_t v56 = 0LL;
          int v105 = 4;
LABEL_205:
          *((_DWORD *)v15 + 4) = v105;
LABEL_206:
          uint64_t v88 = a6;
          goto LABEL_211;
        }
      }

      else
      {
        LODWORD(v246) = -6736;
      }

      uint64_t v56 = 0LL;
      uint64_t v17 = 0LL;
      uint64_t v57 = 0LL;
    }

    uint64_t v54 = 0LL;
    uint64_t v88 = a6;
    goto LABEL_212;
  }

  int v231 = a15;
  int v242 = 0;
  *((_DWORD *)v15 + 11) = 2;
  *((_DWORD *)v15 + 4) = 2;
  *((_BYTE *)v15 + 107) = 0;
  *((_BYTE *)v15 + 72) = 0;
  int v226 = v21;
  if ((_DWORD)k != 1)
  {
    BOOL v34 = 0;
    uint64_t v35 = *v27;
    for (i = 1LL; i != k; BOOL v34 = i >= k)
    {
      uint64_t v37 = v27[i];
      if (v35 != v37)
      {
        int v38 = *(unsigned __int8 **)(v35 + 24);
        uint64_t v39 = *(unsigned __int8 **)(v37 + 24);
        if (*v38 != *v39) {
          break;
        }
        size_t v40 = v38[4];
        if ((_DWORD)v40 != v39[4] || memcmp(v38 + 5, v39 + 5, v40)) {
          break;
        }
      }

      ++i;
    }

    if (!v34) {
      goto LABEL_385;
    }
  }

  if ((a4 == 0LL) == ((_DWORD)a5 == a3)) {
    goto LABEL_385;
  }
  if (__rev16(*(unsigned __int16 *)(*(void *)(*v27 + 24) + 2LL)) >= 0x65)
  {
    if (k <= 3)
    {
      *((_DWORD *)v15 + 4) = 1;
      uint64_t v58 = v15 + 6;
      do
      {
        uint64_t v59 = (_DWORD *)*v27++;
        *v58++ = v59;
        ++*v59;
        ++*((_BYTE *)v15 + 72);
        --k;
      }

      while (k);
      uint64_t v17 = 0LL;
      size_t v16 = 0LL;
      __int128 v27 = 0LL;
      uint64_t v240 = 0LL;
      uint64_t v60 = 0LL;
      a4 = 0LL;
      a5 = 0LL;
      uint64_t v42 = 0LL;
      unsigned int v229 = 0LL;
      goto LABEL_298;
    }

LABEL_385:
    uint64_t v17 = 0LL;
    size_t v16 = 0LL;
    __int128 v27 = 0LL;
    uint64_t v240 = 0LL;
    uint64_t v60 = 0LL;
    a4 = 0LL;
    a5 = 0LL;
    unint64_t k = 0LL;
    uint64_t v42 = 0LL;
    unsigned int v229 = 0LL;
    goto LABEL_299;
  }

  unsigned int v229 = dnssec_obj_domain_name_create_with_labels(a1, 0, &v242);
  if (v242)
  {
    uint64_t v17 = 0LL;
    size_t v16 = 0LL;
    __int128 v27 = 0LL;
    uint64_t v240 = 0LL;
    uint64_t v60 = 0LL;
    a4 = 0LL;
    a5 = 0LL;
    unint64_t k = 0LL;
    uint64_t v42 = 0LL;
    goto LABEL_299;
  }

  if (!a4) {
    goto LABEL_75;
  }
  char v41 = dnssec_obj_domain_name_create_with_labels(a4, 0, &v242);
  uint64_t v42 = v41;
  if (v242)
  {
LABEL_396:
    uint64_t v17 = 0LL;
    size_t v16 = 0LL;
    __int128 v27 = 0LL;
    uint64_t v240 = 0LL;
LABEL_408:
    uint64_t v60 = 0LL;
    a4 = 0LL;
    a5 = 0LL;
    unint64_t k = 0LL;
    goto LABEL_299;
  }

  if (!v41)
  {
LABEL_75:
    for (uint64_t j = 0LL; j != k; ++j)
    {
      uint64_t v62 = v27[j];
      size_t v63 = *(_BYTE **)(v62 + 24);
      if (*v63 == 1
        && v63[1] <= 1u
        && dnssec_obj_rr_nsec3_asserts_name_exists_data_does_not_exist(v62, (uint64_t)v229, a2, a3))
      {
        unint64_t k = v27[j];
        ++*(_DWORD *)k;
        v15[*((unsigned __int8 *)v15 + 72) + 6] = k;
        uint64_t v133 = *((unsigned __int8 *)v15 + 72);
        ++*(_DWORD *)v15[v133 + 6];
        *((_BYTE *)v15 + 72) = v133 + 1;
        *((_DWORD *)v15 + 4) = 3;
        uint64_t v134 = *(void *)(k + 24);
        uint64_t v135 = *(unsigned __int8 *)(v134 + 4)
             + v134
             + 5
             + *(unsigned __int8 *)(*(unsigned __int8 *)(v134 + 4) + v134 + 5);
        int v136 = (_BYTE *)(v135 + 1);
        unint64_t v137 = v135
             + 1
             + (unsigned __int16)(*(_WORD *)(k + 36)
                                - (*(unsigned __int8 *)(v134 + 4)
                                 + 5
        unint64_t v138 = v135 + 2;
        if (v138 < v137)
        {
          int v155 = 0;
          uint64_t v156 = v136;
          do
          {
            uint64_t v157 = v156[1];
            unint64_t v158 = (unint64_t)&v156[v157 + 2];
            if (v158 > v137) {
              break;
            }
            if (*v156) {
              BOOL v159 = 0;
            }
            else {
              BOOL v159 = v157 >= 6;
            }
            if (v159) {
              v155 |= (v156[7] & 0x10) >> 4;
            }
            v156 += v157 + 2;
          }

          while (v158 + 1 < v137);
          LOBYTE(v139) = 0;
          if ((v155 & 1) == 0 && v138 < v137)
          {
            int v160 = 0;
            unsigned int v161 = v136;
            do
            {
              uint64_t v162 = v161[1];
              unint64_t v163 = (unint64_t)&v161[v162 + 2];
              if (v163 > v137) {
                break;
              }
              if (*v161) {
                BOOL v164 = 1;
              }
              else {
                BOOL v164 = (_DWORD)v162 == 0;
              }
              if (!v164) {
                v160 |= (v161[2] & 2) >> 1;
              }
              v161 += v162 + 2;
            }

            while (v163 + 1 < v137);
            LOBYTE(v139) = 0;
            if ((v160 & 1) == 0 && v138 < v137)
            {
              int v139 = 0;
              do
              {
                uint64_t v165 = v136[1];
                unint64_t v166 = (unint64_t)&v136[v165 + 2];
                if (v166 > v137) {
                  break;
                }
                if (*v136) {
                  BOOL v167 = 1;
                }
                else {
                  BOOL v167 = (_DWORD)v165 == 0;
                }
                if (!v167) {
                  v139 |= (v136[2] & 0x20) >> 5;
                }
                v136 += v165 + 2;
              }

              while (v166 + 1 < v137);
            }
          }
        }

        else
        {
          LOBYTE(v139) = 0;
        }

        uint64_t v17 = 0LL;
        size_t v16 = 0LL;
        __int128 v27 = 0LL;
        uint64_t v240 = 0LL;
        uint64_t v60 = 0LL;
        a4 = 0LL;
        a5 = 0LL;
        uint64_t v42 = 0LL;
        *((_BYTE *)v15 + 107) = v139 & 1;
        goto LABEL_298;
      }
    }

    int v235 = 0;
    size_t v16 = 0LL;
    uint64_t v17 = 0LL;
    uint64_t v240 = 0LL;
    uint64_t v225 = 0LL;
    LODWORD(v246) = 0;
    io_registry_entry_t parent = a1;
    int v65 = a2;
LABEL_81:
    if (!*parent) {
      goto LABEL_145;
    }
    int v237 = (void *)v16;
    uint64_t v238 = v17;
    unint64_t v66 = dnssec_obj_domain_name_create_with_labels(parent, 0, (int *)&v246);
    uint64_t v67 = v27;
    unint64_t v68 = k;
    while (1)
    {
      uint64_t v69 = *v67;
      if (*v67)
      {
        int v70 = *(_BYTE **)(v69 + 24);
        if (*v70 == 1 && v70[1] <= 1u)
        {
          if ((dnssec_obj_rr_nsec3_asserts_name_does_not_exist(*v67, (uint64_t)v66, v65) & 1) != 0)
          {
            ++*(_DWORD *)v69;
            if (v240) {
              ref_count_obj_release(v240);
            }
            ++*(_DWORD *)v66;
            if (v237) {
              ref_count_obj_release(v237);
            }
            int v76 = 0;
            ++*(_DWORD *)v69;
            int v235 = 1;
            int v77 = (void *)v69;
            uint64_t v240 = v66;
LABEL_120:
            ref_count_obj_release((void *)v69);
            int v78 = v76;
            size_t v16 = (size_t)v77;
            if (v66) {
LABEL_103:
            }
              ref_count_obj_release(v66);
LABEL_104:
            uint64_t v17 = v238;
            if (v238) {
              BOOL v79 = v16 == 0;
            }
            else {
              BOOL v79 = 1;
            }
            int v80 = !v79;
            int v65 = a2;
            if (((v78 | v80) & 1) == 0)
            {
              io_registry_entry_t parent = domain_name_labels_get_parent(parent, 1uLL);
              goto LABEL_81;
            }

            if ((v78 & 1) == 0)
            {
LABEL_145:
              if (v17 && v16)
              {
                uint64_t v106 = *(void *)(v17 + 24);
                uint64_t v107 = *(unsigned __int8 *)(v106 + 4)
                     + v106
                     + 5
                     + *(unsigned __int8 *)(*(unsigned __int8 *)(v106 + 4) + v106 + 5);
                __int128 v108 = (_BYTE *)(v107 + 1);
                unint64_t v109 = v107
                     + 1
                     + (unsigned __int16)(*(_WORD *)(v17 + 36)
                                        - (*(unsigned __int8 *)(v106 + 4)
                                         + 5
                unint64_t v110 = v107 + 2;
                if (v110 < v109)
                {
                  char v111 = 0;
                  __int128 v112 = v108;
                  do
                  {
                    uint64_t v113 = v112[1];
                    unint64_t v114 = (unint64_t)&v112[v113 + 2];
                    if (v114 > v109) {
                      break;
                    }
                    if (*v112) {
                      BOOL v115 = 0;
                    }
                    else {
                      BOOL v115 = v113 >= 5;
                    }
                    if (v115) {
                      v111 |= v112[6];
                    }
                    v112 += v113 + 2;
                  }

                  while (v114 + 1 < v109);
                  if ((v111 & 1) != 0) {
                    goto LABEL_418;
                  }
                  if (v110 < v109)
                  {
                    int v116 = 0;
                    CFDataRef v117 = v108;
                    do
                    {
                      uint64_t v118 = v117[1];
                      unint64_t v119 = (unint64_t)&v117[v118 + 2];
                      if (v119 > v109) {
                        break;
                      }
                      if (*v117) {
                        BOOL v120 = 1;
                      }
                      else {
                        BOOL v120 = (_DWORD)v118 == 0;
                      }
                      if (!v120) {
                        v116 |= (v117[2] & 0x20) >> 5;
                      }
                      v117 += v118 + 2;
                    }

                    while (v119 + 1 < v109);
                    if (v110 >= v109)
                    {
                      LOBYTE(v121) = 0;
                    }

                    else
                    {
                      int v121 = 0;
                      do
                      {
                        uint64_t v122 = v108[1];
                        unint64_t v123 = (unint64_t)&v108[v122 + 2];
                        if (v123 > v109) {
                          break;
                        }
                        if (*v108) {
                          BOOL v124 = 1;
                        }
                        else {
                          BOOL v124 = (_DWORD)v122 == 0;
                        }
                        if (!v124) {
                          v121 |= (v108[2] & 2) >> 1;
                        }
                        v108 += v122 + 2;
                      }

                      while (v123 + 1 < v109);
                    }

                    if ((v116 & 1) != 0 && (v121 & 1) == 0)
                    {
LABEL_418:
                      uint64_t v60 = 0LL;
                      a4 = 0LL;
                      a5 = 0LL;
                      unint64_t k = 0LL;
                      uint64_t v42 = 0LL;
                      int v242 = -90040;
                      goto LABEL_278;
                    }
                  }
                }

                uint8_t buf[2] = 0;
                *(_WORD *)CFSocketContext buf = 10753;
                a5 = dnssec_obj_domain_name_create_concatenation_with_subdomain(buf, *((_BYTE **)v225 + 2), &v242);
                if (v242) {
                  goto LABEL_277;
                }
                while (1)
                {
                  int v168 = *(_BYTE **)(*v27 + 24);
                  if (*v168 == 1 && v168[1] <= 1u)
                  {
                    char v169 = dnssec_obj_rr_nsec3_asserts_name_does_not_exist(*v27, (uint64_t)a5, a2);
                    a4 = (unsigned __int8 *)*v27;
                    if ((v169 & 1) != 0)
                    {
                      ++*(_DWORD *)a4;
                      int v170 = v15 + 6;
                      v15[*((unsigned __int8 *)v15 + 72) + 6] = v17;
                      uint64_t v171 = *((unsigned __int8 *)v15 + 72);
                      ++*(_DWORD *)v15[v171 + 6];
                      unsigned __int8 v172 = v171 + 1;
                      *((_BYTE *)v15 + 72) = v172;
                      if (v16 != v17)
                      {
                        v170[v172] = v16;
                        uint64_t v173 = *((unsigned __int8 *)v15 + 72);
                        ++*(_DWORD *)v170[v173];
                        unsigned __int8 v172 = v173 + 1;
                        *((_BYTE *)v15 + 72) = v172;
                      }

                      __int128 v27 = (uint64_t *)v225;
                      if (a4 != (unsigned __int8 *)v17 && a4 != (unsigned __int8 *)v16)
                      {
                        v170[v172] = a4;
                        uint64_t v174 = *((unsigned __int8 *)v15 + 72);
                        ++*(_DWORD *)v170[v174];
                        *((_BYTE *)v15 + 72) = v174 + 1;
                      }

                      if (a3 == 43 && (*(_BYTE *)(*(void *)(v16 + 24) + 1LL) & 1) != 0) {
                        goto LABEL_384;
                      }
                      uint64_t v60 = 0LL;
                      int v175 = 4;
                      goto LABEL_296;
                    }

                    if (dnssec_obj_rr_nsec3_asserts_name_exists_data_does_not_exist(*v27, (uint64_t)a5, a2, a3))
                    {
                      uint64_t v60 = (void *)*v27;
                      ++*(_DWORD *)*v27;
                      uint64_t v180 = v15 + 6;
                      v15[*((unsigned __int8 *)v15 + 72) + 6] = v17;
                      uint64_t v181 = *((unsigned __int8 *)v15 + 72);
                      ++*(_DWORD *)v15[v181 + 6];
                      unsigned __int8 v182 = v181 + 1;
                      *((_BYTE *)v15 + 72) = v182;
                      if (v16 != v17)
                      {
                        v180[v182] = v16;
                        uint64_t v183 = *((unsigned __int8 *)v15 + 72);
                        ++*(_DWORD *)v180[v183];
                        unsigned __int8 v182 = v183 + 1;
                        *((_BYTE *)v15 + 72) = v182;
                      }

                      __int128 v27 = (uint64_t *)v225;
                      if (v60 != (void *)v17 && v60 != (void *)v16)
                      {
                        v180[v182] = v60;
                        uint64_t v184 = *((unsigned __int8 *)v15 + 72);
                        ++*(_DWORD *)v180[v184];
                        *((_BYTE *)v15 + 72) = v184 + 1;
                      }

                      a4 = 0LL;
                      int v175 = 6;
LABEL_296:
                      *((_DWORD *)v15 + 4) = v175;
                      goto LABEL_297;
                    }
                  }

                  ++v27;
                  if (!--k)
                  {
                    if (a3 == 43 && (*(_BYTE *)(*(void *)(v16 + 24) + 1LL) & 1) != 0)
                    {
                      unsigned __int16 v176 = v15 + 6;
                      v15[*((unsigned __int8 *)v15 + 72) + 6] = v17;
                      uint64_t v177 = *((unsigned __int8 *)v15 + 72);
                      ++*(_DWORD *)v15[v177 + 6];
                      unsigned __int8 v178 = v177 + 1;
                      *((_BYTE *)v15 + 72) = v178;
                      if (v16 != v17)
                      {
                        v176[v178] = v16;
                        uint64_t v179 = *((unsigned __int8 *)v15 + 72);
                        ++*(_DWORD *)v176[v179];
                        *((_BYTE *)v15 + 72) = v179 + 1;
                      }

                      uint64_t v60 = 0LL;
                      a4 = 0LL;
                      *((_DWORD *)v15 + 4) = 3;
                      *((_BYTE *)v15 + 107) = 1;
                      __int128 v27 = (uint64_t *)v225;
                      goto LABEL_297;
                    }

                    int v242 = 0;
LABEL_277:
                    uint64_t v60 = 0LL;
                    a4 = 0LL;
                    unint64_t k = 0LL;
                    uint64_t v42 = 0LL;
LABEL_278:
                    __int128 v27 = (uint64_t *)v225;
                    goto LABEL_299;
                  }
                }
              }
            }

            uint64_t v60 = 0LL;
            a4 = 0LL;
            a5 = 0LL;
            unint64_t k = 0LL;
            uint64_t v42 = 0LL;
            int v242 = 0;
            goto LABEL_278;
          }

          if (*(unsigned __int16 *)(v69 + 34) == v65)
          {
            uint64_t nsec3_hashed_name = dnssec_obj_domain_name_get_nsec3_hashed_name((uint64_t)v66, v69);
            if (nsec3_hashed_name)
            {
              uint64_t v72 = nsec3_hashed_name;
              int v73 = ref_count_obj_compare(*(void *)(v69 + 16), nsec3_hashed_name, 1LL);
              int v74 = ref_count_obj_compare(*(void *)(v69 + 80), v72, 1LL);
              int v65 = a2;
              if (!v73 || !v74)
              {
                ++*(_DWORD *)v69;
                if ((v235 & 1) != 0)
                {
                  ++*(_DWORD *)v66;
                  ++*(_DWORD *)v69;
                  uint64_t v238 = v69;
                  uint64_t v225 = v66;
                }

                int v76 = v235 ^ 1;
                int v77 = v237;
                goto LABEL_120;
              }

              goto LABEL_91;
            }

            uint64_t v75 = (os_log_s *)mDNSLogCategory_DNSSEC;
            if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_DNSSEC == mDNSLogCategory_State)
            {
              int v65 = a2;
              if (os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC, OS_LOG_TYPE_FAULT))
              {
LABEL_98:
                *(_DWORD *)CFSocketContext buf = 136447234;
                *(void *)&uint8_t buf[4] = "hashed_name != NULL";
                *(_WORD *)&buf[12] = 2082;
                *(void *)&buf[14] = "";
                *(_WORD *)&_BYTE buf[22] = 2082;
                *(void *)&_BYTE buf[24] = "/Library/Caches/com.apple.xbs/Sources/mDNSResponder/mDNSMacOSX/dnssec_v2/dnssec_ob"
                                      "js/dnssec_obj_rr_nsec3.c";
                *(_WORD *)&uint8_t buf[32] = 1024;
                *(_DWORD *)uint64_t v244 = 281;
                *(_WORD *)&v244[4] = 2048;
                v245[0] = 0LL;
                _os_log_impl( (void *)&_mh_execute_header,  v75,  OS_LOG_TYPE_FAULT,  "AssertMacros: %{public}s, %{public}s file: %{public}s, line: %d, value: %ld",  buf,  0x30u);
              }
            }

            else
            {
              uint64_t v75 = (os_log_s *)mDNSLogCategory_DNSSEC_redacted;
              int v65 = a2;
              if (os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC_redacted, OS_LOG_TYPE_FAULT)) {
                goto LABEL_98;
              }
            }
          }
        }
      }

LABEL_91:
      ++v67;
      if (!--v68)
      {
        if (v240) {
          ref_count_obj_release(v240);
        }
        int v76 = 0;
        int v235 = 0;
        int v77 = 0LL;
        uint64_t v240 = 0LL;
        int v78 = 0;
        size_t v16 = 0LL;
        uint64_t v69 = (uint64_t)v237;
        if (v237) {
          goto LABEL_120;
        }
        if (v66) {
          goto LABEL_103;
        }
        goto LABEL_104;
      }
    }
  }

  uint64_t v42 = dnssec_obj_domain_name_create_with_labels(a4, 1, &v242);
  if (v242) {
    goto LABEL_396;
  }
  int v43 = (unsigned __int8 *)*((void *)v229 + 2);
  unsigned int v44 = *v43;
  if (*v43)
  {
    unint64_t v45 = 0LL;
    uint64_t v46 = *((void *)v229 + 2);
    do
    {
      ++v45;
      uint64_t v47 = v46 + v44;
      unsigned int v48 = *(unsigned __int8 *)(v47 + 1);
      uint64_t v46 = v47 + 1;
      unsigned int v44 = v48;
    }

    while (v48);
  }

  else
  {
    unint64_t v45 = 0LL;
  }

  int v125 = (_BYTE *)*((void *)v42 + 2);
  int v126 = *v125;
  if (*v125)
  {
    unint64_t v127 = 0LL;
    do
    {
      ++v127;
      __int128 v128 = &v125[v126];
      int v129 = v128[1];
      int v125 = v128 + 1;
      int v126 = v129;
    }

    while (v129);
  }

  else
  {
    unint64_t v127 = 0LL;
  }

  if (v45 <= v127)
  {
LABEL_405:
    uint64_t v17 = 0LL;
    size_t v16 = 0LL;
    __int128 v27 = 0LL;
    uint64_t v240 = 0LL;
    goto LABEL_193;
  }

  uint64_t v240 = dnssec_obj_domain_name_copy_parent_domain(v43, v45 + ~v127, &v242);
  if (v242)
  {
    uint64_t v17 = 0LL;
    size_t v16 = 0LL;
    __int128 v27 = 0LL;
    goto LABEL_408;
  }

  uint64_t v130 = 0LL;
  while (1)
  {
    uint64_t v131 = v27[v130];
    __int128 v132 = *(_BYTE **)(v131 + 24);
    if (*v132 == 1
      && v132[1] <= 1u
      && (dnssec_obj_rr_nsec3_asserts_name_does_not_exist(v131, (uint64_t)v240, a2) & 1) != 0)
    {
      break;
    }

    if (k == ++v130)
    {
      size_t v16 = 0LL;
      goto LABEL_192;
    }
  }

  size_t v16 = v27[v130];
  ++*(_DWORD *)v16;
  if ((_DWORD)a5 == a3)
  {
    uint64_t v17 = 0LL;
    __int128 v27 = 0LL;
    uint64_t v60 = 0LL;
    a4 = 0LL;
    a5 = 0LL;
    unint64_t k = 0LL;
    v15[*((unsigned __int8 *)v15 + 72) + 6] = v16;
    uint64_t v148 = *((unsigned __int8 *)v15 + 72);
    ++*(_DWORD *)v15[v148 + 6];
    *((_BYTE *)v15 + 72) = v148 + 1;
    *((_DWORD *)v15 + 4) = 5;
    goto LABEL_298;
  }

          uint64_t v85 = 1;
          goto LABEL_94;
        }

        int v19 = (unsigned __int8 *)(v11 + 80);
        if (!v38) {
          goto LABEL_81;
        }
LABEL_76:
        if (v157 && *(_WORD *)(v11 + 68))
        {
          __int16 v86 = (_BYTE *)(v38 + 11);
          if (v38 + 11 <= v163)
          {
            ++*(_WORD *)(*(void *)(v11 + 1016) + 10LL);
            *(void *)int v38 = 271122432LL;
            *(_DWORD *)(v38 + 7) = 0;
            char v87 = "AddEDNS0 option added to response";
            BOOL v22 = v159;
            if (mDNS_LoggingEnabled == 1) {
              goto LABEL_85;
            }
          }

          else
          {
            if ((mDNS_LoggingEnabled & 1) == 0)
            {
              unsigned int v48 = *(_BYTE **)(v11 + 1000);
              goto LABEL_91;
            }

            __int16 v86 = 0LL;
            char v87 = "AddEDNS0Option: not enough space";
            BOOL v22 = v159;
LABEL_85:
            LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  v87,  v31,  v32,  v33,  v34,  v35,  v154);
          }

          unsigned int v48 = *(_BYTE **)(v11 + 1000);
          if (!v86)
          {
            uint64_t v85 = 1;
            char v21 = v158;
            goto LABEL_95;
          }

          v39 += (_DWORD)v86 - (_DWORD)v48;
          *(void *)(v11 + 1000) = v86;
        }

        else
        {
          __int16 v86 = (_BYTE *)v38;
        }

        unsigned int v8 = v155;
        if (mDNS_LoggingEnabled == 1) {
          LogMsgWithLevel( (os_log_s *)mDNSLogCategory_Default,  OS_LOG_TYPE_DEFAULT,  "AddResourceRecord: Added %d bytes to the packet",  v31,  v32,  v33,  v34,  v35,  v39);
        }
        goto LABEL_142;
      }

          if (v34 == 1)
          {
            if (v35) {
              goto LABEL_125;
            }
          }

          else
          {
            if (v34)
            {
              unint64_t v9 = -6735;
              goto LABEL_110;
            }

            if (v35)
            {
              if (*(_BYTE *)(v1 + 144))
              {
                if (!v33)
                {
LABEL_96:
                  unint64_t v9 = -6754;
                  goto LABEL_110;
                }

LABEL_192:
  uint64_t v17 = 0LL;
  __int128 v27 = 0LL;
LABEL_193:
  uint64_t v60 = 0LL;
  a4 = 0LL;
  a5 = 0LL;
  for (unint64_t k = 0LL; ; unint64_t k = 0LL)
  {
LABEL_298:
    int v242 = 0;
LABEL_299:
    dnssec_objs_sort((uint64_t)(v15 + 6), *((unsigned __int8 *)v15 + 72));
    int v82 = v242;
    if (v60) {
      ref_count_obj_release(v60);
    }
    if (a4) {
      ref_count_obj_release(a4);
    }
    __int16 v31 = v231;
    if (a5) {
      ref_count_obj_release(a5);
    }
    if (v16) {
      ref_count_obj_release((void *)v16);
    }
    if (v17) {
      ref_count_obj_release((void *)v17);
    }
    if (v240) {
      ref_count_obj_release(v240);
    }
    if (v27) {
      ref_count_obj_release(v27);
    }
    if (k) {
      ref_count_obj_release((void *)k);
    }
    if (v42) {
      ref_count_obj_release(v42);
    }
    if (v229) {
      ref_count_obj_release(v229);
    }
    uint64_t v88 = a6;
    if (v82)
    {
      unsigned int v211 = (os_log_s *)mDNSLogCategory_DNSSEC;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_DNSSEC == mDNSLogCategory_State)
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC, OS_LOG_TYPE_DEBUG)) {
          goto LABEL_416;
        }
        int v212 = (int)a1;
        if (a1)
        {
          LODWORD(v217) = (_DWORD)a1;
          int v218 = *a1;
          if (*a1)
          {
            int v217 = a1;
            do
            {
              unsigned int v219 = &v217[v218];
              int v220 = v219[1];
              int v217 = v219 + 1;
              int v218 = v220;
            }

            while (v220);
          }

          int v212 = (_DWORD)v217 - (_DWORD)a1 + 1;
        }
      }

      else
      {
        unsigned int v211 = (os_log_s *)mDNSLogCategory_DNSSEC_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC_redacted, OS_LOG_TYPE_DEBUG)) {
          goto LABEL_416;
        }
        int v212 = (int)a1;
        if (a1)
        {
          LODWORD(v213) = (_DWORD)a1;
          int v214 = *a1;
          if (*a1)
          {
            unsigned __int16 v213 = a1;
            do
            {
              int v215 = &v213[v214];
              int v216 = v215[1];
              unsigned __int16 v213 = v215 + 1;
              int v214 = v216;
            }

            while (v216);
          }

          int v212 = (_DWORD)v213 - (_DWORD)a1 + 1;
        }
      }

      *(_DWORD *)CFSocketContext buf = 141559299;
      *(void *)&uint8_t buf[4] = 1752392040LL;
      *(_WORD *)&buf[12] = 1040;
      *(_DWORD *)&buf[14] = v212;
      *(_WORD *)&_BYTE buf[18] = 2101;
      *(void *)&buf[20] = a1;
      *(_WORD *)&buf[28] = 1024;
      *(_DWORD *)&buf[30] = a3;
      *(_WORD *)uint64_t v244 = 1024;
      *(_DWORD *)&v244[2] = v234;
      LOWORD(v245[0]) = 2082;
      *(void *)((char *)v245 + 2) = "Unknown DNSSEC error.";
      _os_log_impl( (void *)&_mh_execute_header,  v211,  OS_LOG_TYPE_DEBUG,  "Failed to find out a provable denial of existence NSEC3 set - qname: %{sensitive, mask.hash, mdnsresponder:domai n_name}.*P, qtype: %u, NSEC3 count: %u, error: %{public}s",  buf,  0x32u);
      uint64_t v81 = 0LL;
      uint64_t v83 = v15;
      __int16 v31 = v231;
      goto LABEL_378;
    }

LABEL_383:
    __break(1u);
LABEL_384:
    uint64_t v60 = 0LL;
    *((_DWORD *)v15 + 4) = 3;
    *((_BYTE *)v15 + 107) = 1;
LABEL_297:
    uint64_t v42 = 0LL;
  }

  uint64_t v185 = 0LL;
  int v242 = 0;
  memset(buf, 0, 24);
  uint64_t v246 = 0LL;
  int v247 = 0;
  unsigned int v186 = v15 + 6;
  LODWORD(v187) = *((unsigned __int8 *)v15 + 72);
  a4 = (unsigned __int8 *)&v246;
  int v188 = v187;
  uint64_t v17 = v228;
  do
  {
    if (!v188) {
      goto LABEL_331;
    }
    unint64_t v189 = 0LL;
    uint64_t v190 = *(void *)(v228 + 8 * v185);
    do
    {
      if (*((_DWORD *)v15 + 11) != 1)
      {
        if (!dnssec_obj_rr_rrsig_covers_rr(v190, v186[v189], &v242)) {
          goto LABEL_329;
        }
LABEL_328:
        ++*((_DWORD *)&v246 + v189);
        goto LABEL_329;
      }

      if (dnssec_obj_rr_rrsig_covers_rr(v190, v186[v189], &v242)) {
        goto LABEL_328;
      }
LABEL_329:
      ++v189;
      unint64_t v187 = *((unsigned __int8 *)v15 + 72);
    }

    while (v189 < v187);
    int v188 = *((unsigned __int8 *)v15 + 72);
LABEL_331:
    ++v185;
  }

  while (v185 != v232);
  if ((_DWORD)v187)
  {
    __int128 v27 = 0LL;
    size_t v16 = (size_t)&v246;
    a5 = buf;
    do
    {
      size_t v191 = *((unsigned int *)&v246 + (void)v27);
      if ((_DWORD)v191)
      {
        unsigned int v192 = calloc(v191, 8uLL);
        if (!v192) {
          goto LABEL_383;
        }
        *(void *)&buf[8 * (void)v27] = v192;
        LODWORD(v187) = *((unsigned __int8 *)v15 + 72);
      }

      __int128 v27 = (uint64_t *)((char *)v27 + 1);
    }

    while ((unint64_t)v27 < v187);
  }

  uint64_t v193 = 0LL;
  uint64_t v194 = v15 + 13;
  LODWORD(v195) = v187;
  while (2)
  {
    if (!(_DWORD)v187) {
      goto LABEL_349;
    }
    unint64_t v196 = 0LL;
    size_t v197 = *(_DWORD **)(v228 + 8 * v193);
    while (2)
    {
      if (*((_DWORD *)v15 + 11) == 1)
      {
      }

      else if (!dnssec_obj_rr_rrsig_covers_rr((uint64_t)v197, v194[v196 - 7], &v242))
      {
        goto LABEL_347;
      }

      uint64_t v198 = *(void *)&buf[8 * v196];
      if (v198)
      {
        *(void *)(v198 + 8LL * *((unsigned __int8 *)v194 + v196)) = v197;
        ++*v197;
        ++*((_BYTE *)v194 + v196);
      }

LABEL_347:
      ++v196;
      unint64_t v195 = *((unsigned __int8 *)v15 + 72);
      if (v196 < v195) {
        continue;
      }
      break;
    }

    LODWORD(v187) = *((unsigned __int8 *)v15 + 72);
LABEL_349:
    if (++v193 != v232) {
      continue;
    }
    break;
  }

  if ((_DWORD)v195)
  {
    uint64_t v199 = v195;
    unsigned int v200 = v15 + 10;
    uint64_t v201 = buf;
    do
    {
      *v200++ = *(void *)v201;
      *(void *)uint64_t v201 = 0LL;
      v201 += 8;
      --v199;
    }

    while (v199);
  }

  uint64_t v202 = 0LL;
  int v242 = 0;
  do
  {
    int v203 = *(void **)&buf[v202];
    if (v203)
    {
      free(v203);
      *(void *)&buf[v202] = 0LL;
    }

    v202 += 8LL;
  }

  while (v202 != 24);
  int v82 = v242;
  if (v242) {
    uint64_t v81 = 0LL;
  }
  else {
    uint64_t v81 = v15;
  }
  if (v242) {
    uint64_t v83 = v15;
  }
  else {
    uint64_t v83 = 0LL;
  }
  if (v88 && !v242) {
    goto LABEL_367;
  }
LABEL_378:
  if (v31) {
    *__int16 v31 = v82;
  }
  if (v83) {
    ref_count_obj_release(v83);
  }
  return v81;
}

void *_mrcs_cf_callback_retain(int a1, void *object)
{
  return object;
}

void _mrcs_cf_callback_release(int a1, void *object)
{
}

const char *_mrcs_cf_callback_copy_description(uint64_t a1)
{
  return _mdns_obj_copy_description_as_cfstring(a1);
}

id _unicast_assist_cache_log()
{
  if (_unicast_assist_cache_log_s_once != -1) {
    dispatch_once(&_unicast_assist_cache_log_s_once, &__block_literal_global_141);
  }
  return (id)_unicast_assist_cache_log_s_log;
}

uint64_t _unicast_assist_data_to_addr(void *a1, int *a2)
{
  id v3 = a1;
  if ([v3 length] == (id)4)
  {
    int v4 = 4;
LABEL_5:
    id v5 = v3;
    memcpy(a2 + 1, [v5 bytes], (size_t)objc_msgSend(v5, "length"));
    uint64_t v6 = 0LL;
    *a2 = v4;
    goto LABEL_9;
  }

  if ([v3 length] == (id)16)
  {
    int v4 = 6;
    goto LABEL_5;
  }

  id v7 = _unicast_assist_cache_log();
  unsigned int v8 = (os_log_s *)objc_claimAutoreleasedReturnValue(v7);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
  {
    int v10 = 134217984;
    id v11 = [v3 length];
    _os_log_error_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_ERROR,  "unicast assist _unicate_assist_data_to_addr bad addr size %lu",  (uint8_t *)&v10,  0xCu);
  }

  uint64_t v6 = 4294960553LL;
LABEL_9:

  return v6;
}

uint64_t _unicast_assist_hash_for_interface(int a1, int a2, _DWORD *a3)
{
  uint64_t v15 = 0LL;
  size_t v16 = &v15;
  uint64_t v17 = 0x2020000000LL;
  int v18 = 0;
  uint64_t v11 = 0LL;
  unint64_t v12 = &v11;
  uint64_t v13 = 0x2020000000LL;
  int v14 = 0;
  uint64_t v3 = *(void *)mDNSStorage[0];
  if (!*(void *)mDNSStorage[0])
  {
LABEL_5:
    uint64_t v6 = 4294960569LL;
LABEL_6:
    int v18 = v6;
    goto LABEL_7;
  }

  while (!*(void *)(v3 + 6480) || *(_DWORD *)(v3 + 6424) != a1)
  {
    uint64_t v3 = *(void *)(v3 + 6384);
    if (!v3) {
      goto LABEL_5;
    }
  }

  if (!strcmp((const char *)(v3 + 6310), "lo0"))
  {
    uint64_t v6 = 4294960591LL;
    goto LABEL_6;
  }

  v9[0] = _NSConcreteStackBlock;
  v9[1] = 3221225472LL;
  v9[2] = ___unicast_assist_hash_for_interface_block_invoke_150;
  v9[3] = &unk_10013CC48;
  int v10 = a2;
  v9[4] = &v15;
  void v9[5] = &v11;
  void v9[6] = v3;
  _unicast_assist_nwi_locked(v9);
  unsigned int v8 = v16;
  uint64_t v6 = *((unsigned int *)v16 + 6);
  if (a3 && !(_DWORD)v6)
  {
    *a3 = *((_DWORD *)v12 + 6);
    uint64_t v6 = *((unsigned int *)v8 + 6);
  }

void sub_1000C5AE8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

void unicast_assist_addr_add(_BYTE *a1, int a2, int a3, int a4, int *a5, uint64_t a6)
{
}

void _unicast_assist_addr_update_ex(_BYTE *a1, int a2, int a3, int a4, int *a5, uint64_t a6, int a7)
{
  int v54 = 0;
  int v11 = v54;
  int v12 = *a5;
  uint64_t v13 = s_interface_head_0;
  if (s_interface_head_0)
  {
    while (*(void *)(v13 + 24) != a6 || *(_DWORD *)(v13 + 32) != v54 || v12 != -1 && *(_DWORD *)(v13 + 36) != v12)
    {
      uint64_t v13 = *(void *)v13;
      if (!v13) {
        goto LABEL_8;
      }
    }

    uint64_t v15 = (int *)(v13 + 8);
  }

  else
  {
LABEL_8:
    int v14 = calloc(1uLL, 0x28uLL);
    if (!v14) {
      goto LABEL_74;
    }
    v14[1] = 0LL;
    uint64_t v15 = (int *)(v14 + 1);
    void v14[2] = v14 + 1;
    void v14[3] = a6;
    *((_DWORD *)v14 + _Block_object_dispose((const void *)(v9 - 64), 8) = v11;
    *((_DWORD *)v14 + 9) = v12;
    void *v14 = s_interface_head_0;
    s_interface_head_0 = (uint64_t)v14;
  }

  size_t v16 = 0LL;
  uint64_t v17 = v15;
  while (1)
  {
    uint64_t v17 = *(int **)v17;
    if (!v17) {
      break;
    }
    int v18 = v16;
    int v19 = mDNSSameAddress(v17 + 4, a5);
    size_t v16 = v17;
    if (v19)
    {
      if (*(int **)v15 == v17)
      {
        uint64_t v24 = *(int **)v17;
        *(void *)uint64_t v15 = *(void *)v17;
        if (!v24) {
          *((void *)v15 + 1) = v15;
        }
      }

      else
      {
        uint64_t v20 = **(void ***)v18;
        *(void *)int v18 = v20;
        if (!v20) {
          *((void *)v15 + 1) = v18;
        }
      }

      __int128 v23 = "updated";
      goto LABEL_21;
    }
  }

  char v21 = (int *)calloc(1uLL, 0x28uLL);
  if (!v21) {
    goto LABEL_74;
  }
  uint64_t v17 = v21;
  *((void *)v21 + 1) = 0LL;
  __int128 v22 = *(_OWORD *)a5;
  v21[8] = a5[4];
  *((_OWORD *)v21 + 1) = v22;
  __int128 v23 = "added";
LABEL_21:
  unsigned int v49 = v23;
  *(void *)uint64_t v17 = 0LL;
  **((void **)v15 + 1) = v17;
  *((void *)v15 + 1) = v17;
  __int128 v25 = (void **)*((void *)v17 + 1);
  int v26 = dword_100158BF8;
  if (!v25) {
    goto LABEL_48;
  }
  int v53 = a4;
  int v27 = 0;
  BOOL v28 = 0LL;
  uint64_t v29 = 0LL;
  __int128 v30 = 0LL;
  __int16 v31 = (void **)*((void *)v17 + 1);
  do
  {
    uint64_t v32 = (void **)*v31;
    if (v30 || *((_DWORD *)v31 + 2) != a2)
    {
      if (v27 == 18) {
        BOOL v34 = v31;
      }
      else {
        BOOL v34 = 0LL;
      }
      if (!v29)
      {
        uint64_t v29 = v34;
        ++v27;
      }

      xpc_object_t v33 = v25;
      if (!v30) {
        goto LABEL_35;
      }
    }

    else
    {
      *((_DWORD *)v31 + 3) = v26;
      if (v25 == v31)
      {
        __int16 v31 = 0LL;
        *((void *)v17 + 1) = v32;
        xpc_object_t v33 = v32;
        __int128 v30 = v25;
        if (!v25) {
          goto LABEL_35;
        }
      }

      else
      {
        *BOOL v28 = *(void **)*v28;
        xpc_object_t v33 = v25;
        __int128 v30 = v31;
        __int16 v31 = 0LL;
        if (!v30) {
          goto LABEL_35;
        }
      }
    }

    if (v29) {
      goto LABEL_42;
    }
LABEL_35:
    if (v31) {
      BOOL v28 = v31;
    }
    __int128 v25 = v33;
    __int16 v31 = v32;
  }

  while (v32);
  if (!v29) {
    goto LABEL_46;
  }
LABEL_42:
  for (unint64_t i = (void **)*v29; *v29; unint64_t i = (void **)*v29)
  {
    _BYTE *v29 = *i;
    id v36 = _unicast_assist_cache_log();
    uint64_t v37 = (os_log_s *)objc_claimAutoreleasedReturnValue(v36);
    if (os_log_type_enabled(v37, OS_LOG_TYPE_DEBUG))
    {
      int v38 = *((_DWORD *)i + 2);
      *(_DWORD *)CFSocketContext buf = 68289282;
      *(_DWORD *)uint64_t v56 = 20;
      *(_WORD *)&v56[4] = 2098;
      *(void *)&v56[6] = v17 + 4;
      *(_WORD *)&v56[14] = 1024;
      *(_DWORD *)&v56[16] = v38;
      _os_log_debug_impl( (void *)&_mh_execute_header,  v37,  OS_LOG_TYPE_DEBUG,  "unicast assist qhash flushed (overflow) - %{public, mdnsresponder:ip_addr}.20P qhash %x",  buf,  0x18u);
    }

    free(i);
  }

uint64_t ___unicast_assist_hash_for_interface_block_invoke_150(uint64_t a1)
{
  uint64_t result = nwi_state_get_ifstate(g_nwi_state_4412, *(void *)(a1 + 48) + 6310LL);
  if (result && (uint64_t result = nwi_ifstate_get_signature()) != 0)
  {
    int v3 = -2128831035;
    uint64_t v4 = a1 + 40;
  }

  else
  {
    uint64_t v4 = a1 + 32;
    int v3 = -6727;
  }

  *(_DWORD *)(*(void *)(*(void *)v4 + 8LL) + 24LL) = v3;
  return result;
}

void _unicast_assist_nwi_locked(void *a1)
{
  uint64_t v1 = a1;
  os_unfair_lock_lock((os_unfair_lock_t)&_unicast_assist_nwi_locked_s_lock);
  v1[2](v1);

  os_unfair_lock_unlock((os_unfair_lock_t)&_unicast_assist_nwi_locked_s_lock);
}

void ___unicast_assist_hash_for_interface_block_invoke(id a1)
{
  notify_key = (const char *)nwi_state_get_notify_key(a1);
  uint32_t v2 = notify_register_dispatch( notify_key,  &_unicast_assist_hash_for_interface_s_nwi_notify_token,  (dispatch_queue_t)_unicast_assist_internal_queue_s_queue,  &__block_literal_global_149);
  if (_unicast_assist_hash_for_interface_s_nwi_notify_token == -1)
  {
    uint32_t v3 = v2;
    id v4 = _unicast_assist_cache_log();
    id v5 = (os_log_s *)objc_claimAutoreleasedReturnValue(v4);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      v6[0] = 67109120;
      v6[1] = v3;
      _os_log_error_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_ERROR,  "Failed to register for NWI state notifications (status %u)",  (uint8_t *)v6,  8u);
    }
  }

  else
  {
    _unicast_assist_nwi_state_update();
  }

void _unicast_assist_nwi_state_update()
{
  uint64_t v0 = nwi_state_copy();
  if (!v0)
  {
    id v1 = _unicast_assist_cache_log();
    uint32_t v2 = (os_log_s *)objc_claimAutoreleasedReturnValue(v1);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)CFSocketContext buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_ERROR, "Failed to copy NWI state", buf, 2u);
    }
  }

  *(void *)CFSocketContext buf = 0LL;
  id v5 = buf;
  uint64_t v6 = 0x2020000000LL;
  uint64_t v7 = 0LL;
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3221225472LL;
  _DWORD v3[2] = ___unicast_assist_nwi_state_update_block_invoke;
  v3[3] = &unk_10013CC90;
  _OWORD v3[4] = buf;
  void v3[5] = v0;
  _unicast_assist_nwi_locked(v3);
  if (*((void *)v5 + 3))
  {
    nwi_state_release();
    *((void *)v5 + 3) = 0LL;
  }

  _Block_object_dispose(buf, 8);
}

void sub_1000C6398( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

uint64_t ___unicast_assist_nwi_state_update_block_invoke(uint64_t result)
{
  *(void *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = g_nwi_state_4412;
  g_nwi_state_4412 = *(void *)(result + 40);
  return result;
}

void ___unicast_assist_internal_queue_block_invoke(id a1)
{
  dispatch_queue_t v1 = dispatch_queue_create("com.apple.mDNSResponder.unicast-assist.interface-monitor", 0LL);
  uint32_t v2 = (void *)_unicast_assist_internal_queue_s_queue;
  _unicast_assist_internal_queue_s_queue = (uint64_t)v1;
}

void ___unicast_assist_cache_log_block_invoke(id a1)
{
  os_log_t v1 = os_log_create("com.apple.mDNSResponder", "ua_cache");
  uint32_t v2 = (void *)_unicast_assist_cache_log_s_log;
  _unicast_assist_cache_log_s_log = (uint64_t)v1;
}

void __unicast_assist_init_block_invoke(id a1)
{
  if (_os_feature_enabled_impl("mDNSResponder", "unicast_assist_cache")
    && objc_opt_class(&OBJC_CLASS___SKPresence)
    && _os_feature_enabled_impl("mDNSResponder", "presence"))
  {
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472LL;
    block[2] = __unicast_assist_init_block_invoke_2;
    block[3] = &unk_10013CBA0;
    os_log_t v1 = dispatch_queue_create("com.apple.mDNSResponder.unicast_assist.statuskit", 0LL);
    uint32_t v3 = v1;
    dispatch_async(v1, block);
    if (v1) {
  }
    }

void __unicast_assist_init_block_invoke_2(uint64_t a1)
{
  os_log_t v1 = -[UAPresenceManager initWithQueue:]( objc_alloc(&OBJC_CLASS___UAPresenceManager),  "initWithQueue:",  *(void *)(a1 + 32));
  uint32_t v2 = (void *)s_presense;
  s_presense = (uint64_t)v1;
}

uint64_t _unicast_assist_addr_enumerate_interface_hash(int a1, uint64_t a2, int a3, void *a4)
{
  id v7 = a4;
  uint64_t v8 = s_interface_head_0;
  while (*(void *)(v8 + 24) != a2 || *(_DWORD *)(v8 + 32) != a3)
  {
    uint64_t v8 = *(void *)v8;
    if (!v8) {
      goto LABEL_5;
    }
  }

  int v11 = *(void **)(v8 + 8);
  if (v11)
  {
    int v12 = 0;
    while (1)
    {
      uint64_t v13 = (uint64_t *)v11[1];
      if (v13) {
        break;
      }
LABEL_14:
      uint64_t v9 = 0LL;
      int v11 = (void *)*v11;
      if (!v11) {
        goto LABEL_6;
      }
    }

    while (1)
    {
      if (*((_DWORD *)v13 + 2) == a1)
      {
        if ((*((unsigned int (**)(id, void *, uint64_t, void))v7 + 2))( v7,  v11 + 2,  a2,  *((unsigned __int8 *)v13 + 17)))
        {
          *((_DWORD *)v13 + 3) = dword_100158BF8;
          *((_BYTE *)v13 + 16) = 1;
          if (++v12 >= 20) {
            break;
          }
        }
      }

      uint64_t v13 = (uint64_t *)*v13;
      if (!v13) {
        goto LABEL_14;
      }
    }

    id v14 = _unicast_assist_cache_log();
    uint64_t v15 = (os_log_s *)objc_claimAutoreleasedReturnValue(v14);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
    {
      v16[0] = 67109120;
      v16[1] = a1;
      _os_log_debug_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_DEBUG,  "unicast assist max limit reached - %x",  (uint8_t *)v16,  8u);
    }

    uint64_t v9 = 4294960545LL;
  }

  else
  {
LABEL_5:
    uint64_t v9 = 0LL;
  }

void _unicast_assist_cache_free_addr(void *a1)
{
  for (unint64_t i = (void *)a1[1]; i; unint64_t i = (void *)a1[1])
  {
    a1[1] = *i;
    free(i);
  }

  free(a1);
}

void _unicast_assist_cache_free_interface(uint64_t **a1)
{
  uint32_t v3 = a1 + 1;
  uint32_t v2 = a1[1];
  if (v2)
  {
    do
    {
      uint64_t v4 = *v2;
      *uint32_t v3 = (uint64_t *)*v2;
      if (!v4) {
        a1[2] = (uint64_t *)v3;
      }
      _unicast_assist_cache_free_addr(v2);
      uint32_t v2 = *v3;
    }

    while (*v3);
  }

  free(a1);
}

_BYTE *unicast_assist_auth_add(_BYTE *result, uint64_t a2, uint64_t a3)
{
  if (s_presense)
  {
    id v5 = result;
    id v6 = _unicast_assist_cache_log();
    id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue(v6);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
    {
      if (v5)
      {
        uint64_t v9 = v5;
        if (v5 == (_BYTE *)-256LL) {
          goto LABEL_11;
        }
LABEL_8:
        int v8 = 257;
        if (v9 < v5 + 256 && v9)
        {
          while (1)
          {
            uint64_t v10 = *v9;
            if (v10 > 0x3F)
            {
LABEL_16:
              int v8 = 257;
              goto LABEL_18;
            }

            if (!*v9) {
              break;
            }
            v9 += v10 + 1;
            if (v5 != (_BYTE *)-256LL) {
              goto LABEL_8;
            }
LABEL_11:
            if (!v9) {
              goto LABEL_16;
            }
          }

          int v8 = (unsigned __int16)((_WORD)v9 - (_WORD)v5 + 1);
        }
      }

      else
      {
        int v8 = 0;
      }

void *_mdns_resolver_copy_description(uint64_t a1, int a2, char a3)
{
  uint64_t v23 = 0LL;
  uint64_t v24 = &v23;
  uint64_t v25 = 0x2000000000LL;
  int v26 = 0;
  v22[0] = 0LL;
  v22[1] = v22;
  v22[2] = 0x2000000000LL;
  v22[3] = 0LL;
  id v6 = (void *)mdns_string_builder_create();
  if (v6)
  {
    id v7 = v6;
    if (a2)
    {
      int appended = mdns_string_builder_append_formatted( v6,  "<%s: %p>: ",  *(const char **)(*(void *)(a1 + 16) + 8LL),  (const void *)a1);
      *((_DWORD *)v24 + 6) = appended;
      if (appended) {
        goto LABEL_5;
      }
    }

    int v9 = mdns_string_builder_append_formatted(v7, "%s", *(const char **)(*(void *)(a1 + 16) + 48LL));
    *((_DWORD *)v24 + 6) = v9;
    if (v9) {
      goto LABEL_5;
    }
    __int16 v12 = *(nw_interface **)(a1 + 48);
    if (v12)
    {
      name = nw_interface_get_name(v12);
      __int16 v14 = name ? name : "???";
      uint32_t index = nw_interface_get_index(*(nw_interface_t *)(a1 + 48));
      int v16 = mdns_string_builder_append_formatted(v7, " using interface %s (%u)", v14, index);
      *((_DWORD *)v24 + 6) = v16;
      if (v16) {
        goto LABEL_5;
      }
    }

    int v17 = mdns_string_builder_append_formatted(v7, " with servers [");
    *((_DWORD *)v24 + 6) = v17;
    if (v17) {
      goto LABEL_5;
    }
    int v18 = *(const __CFArray **)(a1 + 56);
    v20[0] = _NSConcreteStackBlock;
    v20[1] = 0x40000000LL;
    v20[2] = ___mdns_resolver_copy_description_block_invoke;
    v20[3] = &unk_10013D2E8;
    void v20[4] = &v23;
    v20[5] = v22;
    v20[6] = v7;
    char v21 = a3;
    mdns_cfarray_enumerate(v18, (uint64_t)v20);
    if (*((_DWORD *)v24 + 6)
      || (int v19 = mdns_string_builder_append_formatted(v7, "]"), (*((_DWORD *)v24 + 6) = v19) != 0))
    {
LABEL_5:
      uint64_t v10 = 0LL;
    }

    else
    {
      uint64_t v10 = mdns_string_builder_copy_string((uint64_t)v7);
    }

    os_release(v7);
  }

  else
  {
    uint64_t v10 = 0LL;
  }

  _Block_object_dispose(v22, 8);
  _Block_object_dispose(&v23, 8);
  return v10;
}

void _mdns_resolver_finalize(void *a1)
{
  uint32_t v2 = (void *)a1[6];
  if (v2)
  {
    nw_release(v2);
    a1[6] = 0LL;
  }

  uint32_t v3 = (void *)a1[8];
  if (v3)
  {
    free(v3);
    a1[8] = 0LL;
  }

  uint64_t v4 = (const void *)a1[7];
  if (v4)
  {
    CFRelease(v4);
    a1[7] = 0LL;
  }

  id v5 = (dispatch_object_s *)a1[9];
  if (v5)
  {
    dispatch_release(v5);
    a1[9] = 0LL;
  }

  id v6 = (const void *)a1[10];
  if (v6)
  {
    _Block_release(v6);
    a1[10] = 0LL;
  }

BOOL ___mdns_resolver_copy_description_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = mdns_string_builder_append_description_with_prefix( *(void **)(a1 + 48),  *(const char **)(*(void *)(*(void *)(a1 + 40) + 8LL)
                                                                                 + 24LL),
                                                                  a2,
                                                                  *(_BYTE *)(a1 + 56));
  *(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = ", ";
  return *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) == 0;
}

void *_mdns_server_copy_description(uint64_t a1, int a2, int a3)
{
  id v6 = (void *)mdns_string_builder_create();
  if (v6)
  {
    id v7 = v6;
    if (!a2
      || !mdns_string_builder_append_formatted( v6,  "<%s: %p>: ",  *(const char **)(*(void *)(a1 + 16) + 8LL),  (const void *)a1))
    {
      if (nw_endpoint_get_type(*(nw_endpoint_t *)(a1 + 48)) == nw_endpoint_type_address)
      {
        nw_endpoint_t address = nw_endpoint_get_address(*(nw_endpoint_t *)(a1 + 48));
        if (*(_BYTE *)(a1 + 111)) {
          char v9 = a3 | 2;
        }
        else {
          char v9 = a3;
        }
        if (!mdns_string_builder_append_sockaddr_description(v7, (uint64_t)address, v9))
        {
LABEL_18:
          uint64_t v10 = mdns_string_builder_copy_string((uint64_t)v7);
          goto LABEL_19;
        }
      }

      else
      {
        memset(v16, 0, sizeof(v16));
        hostname = nw_endpoint_get_hostname(*(nw_endpoint_t *)(a1 + 48));
        __int16 v12 = "«MISSING HOSTNAME»";
        if (hostname)
        {
          __int16 v12 = hostname;
          if (a3)
          {
            int v13 = DNSMessagePrintObfuscatedString((uint64_t)v16, hostname);
            __int16 v12 = "«REDACTED HOSTNAME»";
            if (v13 >= 0) {
              __int16 v12 = (const char *)v16;
            }
          }
        }

        if (!mdns_string_builder_append_formatted(v7, "%s", v12))
        {
          if (*(_BYTE *)(a1 + 111)) {
            goto LABEL_18;
          }
          int port = nw_endpoint_get_port(*(nw_endpoint_t *)(a1 + 48));
        }
      }
    }

    uint64_t v10 = 0LL;
LABEL_19:
    os_release(v7);
    return v10;
  }

  return 0LL;
}

void _mdns_server_finalize(void *a1)
{
  uint32_t v2 = (void *)a1[6];
  if (v2)
  {
    nw_release(v2);
    a1[6] = 0LL;
  }

  uint32_t v3 = (void *)a1[7];
  if (v3)
  {
    nw_release(v3);
    a1[7] = 0LL;
  }

  uint64_t v4 = (void *)a1[8];
  if (v4)
  {
    id v5 = (void *)*v4;
    if (*v4)
    {
      do
      {
        id v6 = (void *)*v5;
        _pqw_qname_item_free(v5);
        id v5 = v6;
      }

      while (v6);
    }

    free(v4);
    a1[8] = 0LL;
  }

void _pqw_qname_item_free(void *a1)
{
  uint32_t v2 = (void *)a1[1];
  if (v2) {
    free(v2);
  }
  free(a1);
}

void *_mdns_session_copy_description(void *a1, int a2)
{
  uint64_t v4 = (void *)mdns_string_builder_create();
  if (!v4) {
    return 0LL;
  }
  id v5 = v4;
  else {
    id v6 = mdns_string_builder_copy_string((uint64_t)v5);
  }
  os_release(v5);
  return v6;
}

void _mdns_session_finalize(uint64_t a1)
{
  uint32_t v2 = *(void **)(a1 + 32);
  if (v2)
  {
    os_release(v2);
    *(void *)(a1 + 32) = 0LL;
  }

  *(void *)(a1 + 4_Block_object_dispose(va, 8) = 0LL;
}

void _mdns_https_resolver_finalize(void *a1)
{
  uint32_t v2 = (void *)a1[18];
  if (v2)
  {
    free(v2);
    a1[18] = 0LL;
  }

  uint32_t v3 = (void *)a1[19];
  if (v3)
  {
    free(v3);
    a1[19] = 0LL;
  }

  uint64_t v4 = (void *)a1[20];
  if (v4)
  {
    free(v4);
    a1[20] = 0LL;
  }

  id v5 = (void *)a1[21];
  if (v5)
  {
    xpc_release(v5);
    a1[21] = 0LL;
  }

  id v6 = (void *)a1[22];
  if (v6)
  {
    nw_release(v6);
    a1[22] = 0LL;
  }

  id v7 = (void *)a1[23];
  if (v7)
  {
    nw_release(v7);
    a1[23] = 0LL;
  }

  int v8 = (const void *)a1[24];
  if (v8)
  {
    CFRelease(v8);
    a1[24] = 0LL;
  }

uint64_t _mdns_https_resolver_set_provider_name(uint64_t a1, char *a2)
{
  return 0LL;
}

uint64_t _mdns_https_resolver_set_connection_hostname(uint64_t a1, char *a2)
{
  return 0LL;
}

uint64_t _mdns_https_resolver_set_port(uint64_t result, __int16 a2)
{
  *(_WORD *)(result + 22_Block_object_dispose(va, 8) = a2;
  return result;
}

uint64_t _mdns_https_resolver_set_url_path(uint64_t a1, char *a2)
{
  return 0LL;
}

uint64_t _mdns_https_resolver_set_identity(uint64_t a1, UInt8 *bytes, CFIndex length)
{
  unsigned int v7 = 0;
  if (bytes)
  {
    CFTypeRef v4 = _mdns_copy_sec_identity(bytes, length, (int *)&v7);
    uint64_t result = v7;
    if (v7) {
      return result;
    }
  }

  else
  {
    CFTypeRef v4 = 0LL;
  }

  id v6 = *(const void **)(a1 + 192);
  if (v6) {
    CFRelease(v6);
  }
  uint64_t result = 0LL;
  *(void *)(a1 + 192) = v4;
  return result;
}

uint64_t _mdns_https_resolver_update_odoh_config_async( void *a1, char *__s1, char *a3, const void *a4, size_t a5, void *a6)
{
  uint64_t v10 = a3;
  if (__s1)
  {
    __int16 v12 = strdup(__s1);
    if (!v12) {
      goto LABEL_14;
    }
    if (!v10) {
      goto LABEL_7;
    }
LABEL_6:
    uint64_t v10 = strdup(v10);
    if (v10) {
      goto LABEL_7;
    }
LABEL_14:
    __break(1u);
LABEL_15:
    dispatch_once(&_mdns_resolver_queue_s_once, &__block_literal_global_138);
LABEL_13:
    block[0] = _NSConcreteStackBlock;
    block[1] = 0x40000000LL;
    block[2] = ___mdns_https_resolver_update_odoh_config_async_block_invoke;
    block[3] = &__block_descriptor_tmp_39_4541;
    void block[4] = v12;
    void block[5] = a1;
    block[6] = v10;
    void block[7] = v6;
    block[8] = a6;
    dispatch_async((dispatch_queue_t)_mdns_resolver_queue_s_queue, block);
    return 0LL;
  }

  __int16 v12 = 0LL;
  if (a3) {
    goto LABEL_6;
  }
LABEL_7:
  xpc_object_t v6 = 0LL;
  if (!a4 || !a5 || (xpc_object_t v6 = xpc_data_create(a4, a5)) != 0LL)
  {
    if (a6) {
      nw_retain(a6);
    }
    os_retain(a1);
    if (_mdns_resolver_queue_s_once == -1) {
      goto LABEL_13;
    }
    goto LABEL_15;
  }

  if (v12) {
    free(v12);
  }
  if (v10) {
    free(v10);
  }
  return 4294960567LL;
}

nw_parameters_t _mdns_https_resolver_get_stream_params(void *a1, int *a2)
{
  nw_parameters_t v3 = (nw_parameters_t)a1[23];
  if (!v3)
  {
    if (a1[18])
    {
      uint64_t v13 = 0LL;
      __int16 v14 = &v13;
      uint64_t v15 = 0x2000000000LL;
      char v16 = 0;
      v12[0] = _NSConcreteStackBlock;
      v12[1] = 0x40000000LL;
      v12[2] = ___mdns_https_resolver_create_stream_params_block_invoke;
      void v12[3] = &unk_10013D218;
      void v12[4] = &v13;
      void v12[5] = a1;
      nw_parameters_t tcp = _mdns_nw_parameters_create_tcp(v12);
      if (!tcp)
      {
        _Block_object_dispose(&v13, 8);
        int v4 = -6729;
        goto LABEL_20;
      }

      nw_parameters_t v3 = tcp;
      int v8 = *((unsigned __int8 *)v14 + 24);
      _Block_object_dispose(&v13, 8);
      if (!v8)
      {
        nw_release(v3);
        int v4 = -6700;
LABEL_20:
        nw_parameters_t v3 = 0LL;
        goto LABEL_17;
      }
    }

    else
    {
      nw_parameters_t v3 = _mdns_nw_parameters_create_tcp(_nw_parameters_configure_protocol_default_configuration);
      if (!v3)
      {
        int v4 = -6729;
        goto LABEL_17;
      }
    }

    int v11 = 0LL;
    char v9 = (const char *)a1[20];
    if (!v9) {
      char v9 = "";
    }
    asprintf(&v11, "https://%s%s", (const char *)a1[18], v9);
    nw_parameters_set_url(v3, v11);
    if (v11) {
      free(v11);
    }
    uint64_t v10 = (nw_interface *)a1[6];
    if (v10) {
      nw_parameters_require_interface(v3, v10);
    }
    int v4 = 0;
LABEL_17:
    a1[23] = v3;
    if (!a2) {
      return v3;
    }
    goto LABEL_3;
  }

  int v4 = 0;
  if (a2) {
LABEL_3:
  }
    *a2 = v4;
  return v3;
}

uint64_t _mdns_https_resolver_get_effective_connection_hostname(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 152);
  if (!result) {
    return *(void *)(a1 + 144);
  }
  return result;
}

uint64_t _mdns_https_resolver_get_custom_port(uint64_t a1)
{
  return *(unsigned __int16 *)(a1 + 228);
}

uint64_t _mdns_https_resolver_get_client_address(uint64_t a1)
{
  return a1 + 200;
}

void ___mdns_https_resolver_create_stream_params_block_invoke(uint64_t a1, nw_protocol_options_t options)
{
  nw_parameters_t v3 = nw_tls_copy_sec_protocol_options(options);
  if (v3)
  {
    int v4 = v3;
    sec_protocol_options_set_tls_server_name(v3, *(const char **)(*(void *)(a1 + 40) + 144LL));
    sec_protocol_options_set_peer_authentication_required(v4, 1);
    sec_protocol_options_add_tls_application_protocol(v4, "h2");
    sec_release(v4);
    *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 1;
  }

nw_parameters_t _mdns_nw_parameters_create_tcp(void *a1)
{
  secure_nw_parameters_t tcp = nw_parameters_create_secure_tcp(a1, _nw_parameters_configure_protocol_default_configuration);
  nw_parameters_t v2 = secure_tcp;
  if (secure_tcp)
  {
    nw_parameters_set_indefinite(secure_tcp, 0LL);
    nw_parameters_set_no_wake_from_sleep(v2, 1LL);
  }

  return v2;
}

void ___mdns_https_resolver_update_odoh_config_async_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2)
  {
    uint64_t v3 = *(void *)(a1 + 40);
    int v4 = *(void **)(v3 + 144);
    if (v4)
    {
      free(v4);
      *(void *)(*(void *)(a1 + 40) + 144LL) = 0LL;
      uint64_t v2 = *(void *)(a1 + 32);
      uint64_t v3 = *(void *)(a1 + 40);
    }

    *(void *)(v3 + 144) = v2;
  }

  uint64_t v5 = *(void *)(a1 + 48);
  if (v5)
  {
    uint64_t v6 = *(void *)(a1 + 40);
    unsigned int v7 = *(void **)(v6 + 160);
    if (v7)
    {
      free(v7);
      *(void *)(*(void *)(a1 + 40) + 160LL) = 0LL;
      uint64_t v6 = *(void *)(a1 + 40);
      uint64_t v5 = *(void *)(a1 + 48);
    }

    *(void *)(v6 + 160) = v5;
  }

  int v8 = *(void **)(a1 + 40);
  uint64_t v10 = *(void **)(a1 + 56);
  char v9 = *(void **)(a1 + 64);
  int v11 = (void *)v8[23];
  if (v11)
  {
    nw_release(v11);
    v8[23] = 0LL;
  }

  __int16 v12 = (void *)v8[21];
  if (v12 != v10)
  {
    if (v12) {
      xpc_release(v12);
    }
    v8[21] = v10;
    if (v10) {
      xpc_retain(v10);
    }
  }

  uint64_t v13 = (void *)v8[22];
  if (v13 != v9)
  {
    if (v13) {
      nw_release(v13);
    }
    v8[22] = v9;
    if (v9) {
      nw_retain(v9);
    }
  }

  __int16 v14 = *(void **)(a1 + 56);
  if (v14) {
    xpc_release(v14);
  }
  uint64_t v15 = *(void **)(a1 + 64);
  if (v15) {
    nw_release(v15);
  }
  os_release(*(void **)(a1 + 40));
}

void ___mdns_resolver_queue_block_invoke(id a1)
{
  _mdns_resolver_queue_s_queue = (uint64_t)dispatch_queue_create("com.apple.mdns.resolver-queue", 0LL);
}

CFTypeRef _mdns_copy_sec_identity(UInt8 *bytes, CFIndex length, int *a3)
{
  CFTypeRef result = 0LL;
  CFDataRef v4 = CFDataCreate(0LL, bytes, length);
  if (!v4)
  {
LABEL_21:
    CFTypeRef v10 = 0LL;
    int v12 = -6729;
    if (!a3) {
      return v10;
    }
    goto LABEL_14;
  }

  CFDataRef v5 = v4;
  CFMutableArrayRef Mutable = CFDictionaryCreateMutable(0LL, 0LL, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (!Mutable)
  {
    CFRelease(v5);
    goto LABEL_21;
  }

  unsigned int v7 = Mutable;
  CFDictionarySetValue(Mutable, kSecReturnRef, kCFBooleanTrue);
  CFDictionarySetValue(v7, kSecValuePersistentRef, v5);
  CFDictionarySetValue(v7, kSecClass, kSecClassIdentity);
  CFDictionarySetValue(v7, kSecUseSystemKeychain, kCFBooleanTrue);
  OSStatus v8 = SecItemCopyMatching(v7, &result);
  if (v8)
  {
    int v12 = v8;
    if (_mdns_resolver_log_s_once != -1) {
      dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_48);
    }
    uint64_t v15 = (os_log_s *)_mdns_resolver_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)CFSocketContext buf = 138412546;
      CFDataRef v20 = v5;
      __int16 v21 = 2048;
      CFStringRef v22 = (CFStringRef)v12;
      _os_log_error_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_ERROR,  "Failed to find identity item -- reference: %@, error: %{mdns:err}ld",  buf,  0x16u);
    }

    CFTypeRef v10 = 0LL;
  }

  else if (result && (CFTypeID v9 = CFGetTypeID(result), v9 == SecIdentityGetTypeID()))
  {
    CFTypeRef v10 = result;
    CFTypeRef result = 0LL;
    if (_mdns_resolver_log_s_once != -1) {
      dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_48);
    }
    int v11 = (os_log_s *)_mdns_resolver_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)CFSocketContext buf = 138412290;
      CFDataRef v20 = v5;
      _os_log_debug_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEBUG,  "Found identity with reference %@",  buf,  0xCu);
    }

    int v12 = 0;
  }

  else
  {
    if (_mdns_resolver_log_s_once != -1) {
      dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_48);
    }
    __int16 v14 = (os_log_s *)_mdns_resolver_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_FAULT))
    {
      if (result)
      {
        CFTypeID v17 = CFGetTypeID(result);
        CFStringRef v16 = CFCopyTypeIDDescription(v17);
      }

      else
      {
        CFStringRef v16 = @"none";
      }

      *(_DWORD *)CFSocketContext buf = 138412546;
      CFDataRef v20 = v5;
      __int16 v21 = 2114;
      CFStringRef v22 = v16;
      _os_log_fault_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_FAULT,  "Unexpected identity item type -- reference: %@, type: %{public}@",  buf,  0x16u);
    }

    CFTypeRef v10 = 0LL;
    int v12 = -6756;
  }

  CFRelease(v5);
  CFRelease(v7);
  if (result) {
    CFRelease(result);
  }
  if (a3) {
LABEL_14:
  }
    *a3 = v12;
  return v10;
}

void ___mdns_resolver_log_block_invoke(id a1)
{
  _mdns_resolver_log_s_log = (uint64_t)os_log_create("com.apple.mdns", "resolver");
}

void _mdns_tls_resolver_finalize(void *a1)
{
  uint64_t v2 = (void *)a1[18];
  if (v2)
  {
    free(v2);
    a1[18] = 0LL;
  }

  uint64_t v3 = (void *)a1[19];
  if (v3)
  {
    free(v3);
    a1[19] = 0LL;
  }

  CFDataRef v4 = (void *)a1[20];
  if (v4)
  {
    nw_release(v4);
    a1[20] = 0LL;
  }

  CFDataRef v5 = (void *)a1[21];
  if (v5)
  {
    sec_release(v5);
    a1[21] = 0LL;
  }

uint64_t _mdns_tls_resolver_set_provider_name(uint64_t a1, char *a2)
{
  return 0LL;
}

uint64_t _mdns_tls_resolver_set_connection_hostname(uint64_t a1, char *a2)
{
  return 0LL;
}

uint64_t _mdns_tls_resolver_set_port(uint64_t result, __int16 a2)
{
  *(_WORD *)(result + 176) = a2;
  return result;
}

uint64_t _mdns_tls_resolver_set_identity(uint64_t a1, UInt8 *bytes, CFIndex length)
{
  unsigned int v8 = 0;
  if (bytes)
  {
    CFDataRef v4 = (__SecIdentity *)_mdns_copy_sec_identity(bytes, length, (int *)&v8);
    uint64_t result = v8;
    if (v8) {
      return result;
    }
    sec_identity_t v6 = sec_identity_create(v4);
    if (v4) {
      CFRelease(v4);
    }
    if (!v6) {
      return 4294960567LL;
    }
  }

  else
  {
    sec_identity_t v6 = 0LL;
  }

  unsigned int v7 = *(void **)(a1 + 168);
  if (v7) {
    sec_release(v7);
  }
  uint64_t result = 0LL;
  *(void *)(a1 + 16_Block_object_dispose(va, 8) = v6;
  return result;
}

nw_parameters_t _mdns_tls_resolver_get_stream_params(void *a1, int *a2)
{
  nw_parameters_t v3 = (nw_parameters_t)a1[20];
  if (!v3)
  {
    if (a1[18] || a1[21])
    {
      uint64_t v11 = 0LL;
      int v12 = &v11;
      uint64_t v13 = 0x2000000000LL;
      char v14 = 0;
      v10[0] = _NSConcreteStackBlock;
      v10[1] = 0x40000000LL;
      v10[2] = ___mdns_tls_resolver_create_stream_params_block_invoke;
      void v10[3] = &unk_10013D128;
      v10[4] = &v11;
      v10[5] = a1;
      nw_parameters_t tcp = _mdns_nw_parameters_create_tcp(v10);
      if (!tcp)
      {
        _Block_object_dispose(&v11, 8);
        int v4 = -6729;
LABEL_19:
        nw_parameters_t v3 = 0LL;
        goto LABEL_12;
      }

      nw_parameters_t v3 = tcp;
      int v8 = *((unsigned __int8 *)v12 + 24);
      _Block_object_dispose(&v11, 8);
      if (!v8)
      {
        int v4 = -6777;
LABEL_18:
        nw_release(v3);
        goto LABEL_19;
      }
    }

    else
    {
      nw_parameters_t v3 = _mdns_nw_parameters_create_tcp(_nw_parameters_configure_protocol_default_configuration);
      if (!v3)
      {
        int v4 = -6729;
        goto LABEL_12;
      }
    }

    CFTypeID v9 = (nw_interface *)a1[6];
    if (v9) {
      nw_parameters_require_interface(v3, v9);
    }
    int v4 = _mdns_add_dns_over_bytestream_framer(v3);
    if (!v4)
    {
LABEL_12:
      a1[20] = v3;
      if (!a2) {
        return v3;
      }
      goto LABEL_3;
    }

    goto LABEL_18;
  }

  int v4 = 0;
  if (a2) {
LABEL_3:
  }
    *a2 = v4;
  return v3;
}

uint64_t _mdns_tls_resolver_get_effective_connection_hostname(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 152);
  if (!result) {
    return *(void *)(a1 + 144);
  }
  return result;
}

uint64_t _mdns_tls_resolver_get_custom_port(uint64_t a1)
{
  return *(unsigned __int16 *)(a1 + 176);
}

void ___mdns_tls_resolver_create_stream_params_block_invoke(uint64_t a1, nw_protocol_options_t options)
{
  nw_parameters_t v3 = nw_tls_copy_sec_protocol_options(options);
  if (v3)
  {
    int v4 = v3;
    uint64_t v5 = *(void *)(a1 + 40);
    sec_identity_t v6 = *(const char **)(v5 + 144);
    if (v6)
    {
      sec_protocol_options_set_tls_server_name(v3, v6);
      sec_protocol_options_set_peer_authentication_required(v4, 1);
      uint64_t v5 = *(void *)(a1 + 40);
    }

    unsigned int v7 = *(sec_identity **)(v5 + 168);
    if (v7)
    {
      sec_protocol_options_set_local_identity(v4, v7);
      uint64_t v5 = *(void *)(a1 + 40);
    }

    verify_block[0] = _NSConcreteStackBlock;
    verify_block[1] = 0x40000000LL;
    verify_block[2] = ___mdns_tls_resolver_create_stream_params_block_invoke_2;
    verify_block[3] = &__block_descriptor_tmp_34_4569;
    verify_void block[4] = v5;
    if (_mdns_resolver_queue_s_once != -1) {
      dispatch_once(&_mdns_resolver_queue_s_once, &__block_literal_global_138);
    }
    sec_protocol_options_set_verify_block(v4, verify_block, (dispatch_queue_t)_mdns_resolver_queue_s_queue);
    *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 1;
    sec_release(v4);
  }

uint64_t _mdns_add_dns_over_bytestream_framer(nw_parameters *a1)
{
  nw_protocol_stack_t v1 = nw_parameters_copy_default_protocol_stack(a1);
  if (!v1) {
    return 4294960567LL;
  }
  uint64_t v2 = v1;
  if (_mdns_copy_dns_over_bytestream_framer_s_once != -1) {
    dispatch_once(&_mdns_copy_dns_over_bytestream_framer_s_once, &__block_literal_global_11_4555);
  }
  if (!_mdns_copy_dns_over_bytestream_framer_s_framer_def
    || (nw_retain((void *)_mdns_copy_dns_over_bytestream_framer_s_framer_def),
        (nw_parameters_t v3 = (void *)_mdns_copy_dns_over_bytestream_framer_s_framer_def) == 0LL))
  {
    uint64_t v5 = 4294960567LL;
    nw_protocol_options_t options = v2;
LABEL_9:
    nw_release(options);
    return v5;
  }

  nw_protocol_options_t options = nw_framer_create_options((nw_protocol_definition_t)_mdns_copy_dns_over_bytestream_framer_s_framer_def);
  if (options)
  {
    nw_protocol_stack_prepend_application_protocol(v2, options);
    uint64_t v5 = 0LL;
  }

  else
  {
    uint64_t v5 = 4294960567LL;
  }

  nw_release(v2);
  nw_release(v3);
  if (options) {
    goto LABEL_9;
  }
  return v5;
}

void ___mdns_copy_dns_over_bytestream_framer_block_invoke(id a1)
{
  _mdns_copy_dns_over_bytestream_framer_s_framer_def = (uint64_t)nw_framer_create_definition( "DNS over byte-stream",  0,  &__block_literal_global_24);
}

int ___mdns_create_dns_over_bytestream_framer_block_invoke(id a1, nw_framer *a2)
{
  return 1;
}

void _mdns_normal_resolver_kind_block_invoke_3( id a1, nw_framer *a2, nw_protocol_metadata *a3, unint64_t a4, BOOL a5)
{
  if (a4 < 0x10000)
  {
    *(_WORD *)output_buffer = bswap32(a4) >> 16;
    nw_framer_write_output(a2, output_buffer, 2uLL);
    nw_framer_write_output_no_copy(a2, a4);
  }

  else
  {
    nw_framer_mark_failed_with_error(a2, 40);
  }

unint64_t _mdns_normal_resolver_kind_block_invoke(id a1, nw_framer *a2)
{
  do
  {
    *(_WORD *)temp_buffer = 0;
    if (!nw_framer_parse_input(a2, 2uLL, 2uLL, temp_buffer, &__block_literal_global_17_4566)) {
      break;
    }
    size_t v3 = __rev16(*(unsigned __int16 *)temp_buffer);
    int v4 = nw_framer_message_create(a2);
    LODWORD(v3) = nw_framer_deliver_input_no_copy(a2, v3, v4, 1);
    nw_release(v4);
  }

  while ((_DWORD)v3);
  return 2LL;
}

unint64_t _mdns_normal_resolver_kind_block_invoke_2(id a1, char *a2, unint64_t a3, BOOL a4)
{
  return 2LL * (a3 > 1);
}

void ___mdns_tls_resolver_create_stream_params_block_invoke_2( uint64_t a1, int a2, sec_trust_t trust, uint64_t a4)
{
  sec_identity_t v6 = sec_trust_copy_ref(trust);
  OSStatus Allowed = SecTrustSetNetworkFetchAllowed(v6, 0);
  if (Allowed)
  {
    OSStatus v9 = Allowed;
    if (_mdns_resolver_log_s_once != -1) {
      dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_48);
    }
    CFTypeRef v10 = (os_log_s *)_mdns_resolver_log_s_log;
    if (!os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_ERROR)) {
      goto LABEL_15;
    }
    uint64_t v11 = *(void *)(*(void *)(a1 + 32) + 144LL);
    *(_DWORD *)CFSocketContext buf = 136315394;
    uint64_t v17 = v11;
    __int16 v18 = 2048;
    uint64_t v19 = v9;
    int v12 = "Failed to disable network fetch for trust evaluation -- provider name: %s, error: %{mdns:err}ld";
LABEL_18:
    _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, v12, buf, 0x16u);
    goto LABEL_15;
  }

  if (_mdns_resolver_queue_s_once != -1) {
    dispatch_once(&_mdns_resolver_queue_s_once, &__block_literal_global_138);
  }
  result[0] = _NSConcreteStackBlock;
  result[1] = 0x40000000LL;
  result[2] = ___mdns_tls_resolver_create_stream_params_block_invoke_30;
  result[3] = &unk_10013D0E0;
  result[4] = a4;
  OSStatus v8 = SecTrustEvaluateAsyncWithError(v6, (dispatch_queue_t)_mdns_resolver_queue_s_queue, result);
  if (!v8)
  {
    if (!v6) {
      return;
    }
    goto LABEL_6;
  }

  OSStatus v13 = v8;
  if (_mdns_resolver_log_s_once != -1) {
    dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_48);
  }
  CFTypeRef v10 = (os_log_s *)_mdns_resolver_log_s_log;
  if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_ERROR))
  {
    uint64_t v14 = *(void *)(*(void *)(a1 + 32) + 144LL);
    *(_DWORD *)CFSocketContext buf = 136315394;
    uint64_t v17 = v14;
    __int16 v18 = 2048;
    uint64_t v19 = v13;
    int v12 = "Failed to start aynchronous trust evaluation -- provider name: %s, error: %{mdns:err}ld";
    goto LABEL_18;
  }

uint64_t ___mdns_tls_resolver_create_stream_params_block_invoke_30( uint64_t a1, uint64_t a2, char a3, uint64_t a4)
{
  if ((a3 & 1) == 0)
  {
    if (_mdns_resolver_log_s_once != -1) {
      dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_48);
    }
    sec_identity_t v6 = (os_log_s *)_mdns_resolver_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_ERROR))
    {
      int v8 = 138412290;
      uint64_t v9 = a4;
      _os_log_error_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_ERROR,  "Aynchronous trust evaluation failed: %@",  (uint8_t *)&v8,  0xCu);
    }
  }

  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL))();
}

nw_parameters *_mdns_create_tcp_parameters(int *a1)
{
  nw_parameters_t tcp = _mdns_nw_parameters_create_tcp(_nw_parameters_configure_protocol_disable);
  size_t v3 = tcp;
  if (tcp)
  {
    int v4 = _mdns_add_dns_over_bytestream_framer(tcp);
    if (v4)
    {
      nw_release(v3);
      size_t v3 = 0LL;
    }

    else
    {
      nw_parameters_set_prefer_no_proxy(v3, 1);
    }
  }

  else
  {
    int v4 = -6729;
  }

  if (a1) {
    *a1 = v4;
  }
  return v3;
}

void _mdns_normal_resolver_finalize(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 144);
  if (v2)
  {
    nw_release(v2);
    *(void *)(a1 + 144) = 0LL;
  }

  size_t v3 = *(void **)(a1 + 152);
  if (v3)
  {
    nw_release(v3);
    *(void *)(a1 + 152) = 0LL;
  }

nw_parameters_t _mdns_normal_resolver_get_datagram_params(uint64_t a1, int *a2)
{
  nw_parameters_t v3 = *(nw_parameters_t *)(a1 + 144);
  if (v3)
  {
    int v4 = 0;
    if (a2) {
LABEL_3:
    }
      *a2 = v4;
  }

  else
  {
    nw_parameters_t secure_udp = nw_parameters_create_secure_udp( _nw_parameters_configure_protocol_disable,  _nw_parameters_configure_protocol_default_configuration);
    nw_parameters_t v3 = secure_udp;
    if (secure_udp)
    {
      nw_parameters_set_no_wake_from_sleep(secure_udp, 1LL);
      int v4 = 0;
    }

    else
    {
      int v4 = -6729;
    }

    *(void *)(a1 + 144) = v3;
    if (a2) {
      goto LABEL_3;
    }
  }

  return v3;
}

nw_parameters *_mdns_normal_resolver_get_stream_params(uint64_t a1, int *a2)
{
  uint64_t result = *(nw_parameters **)(a1 + 152);
  if (!result && (v6 = 0, result = _mdns_create_tcp_parameters(&v6), *(void *)(a1 + 152) = result, (int v5 = v6) != 0))
  {
    uint64_t result = 0LL;
    if (!a2) {
      return result;
    }
  }

  else
  {
    int v5 = 0;
    if (!a2) {
      return result;
    }
  }

  *a2 = v5;
  return result;
}

uint64_t _mdns_resolver_add_server_by_endpoint(uint64_t a1, void *a2)
{
  CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 56));
  if (Count > 31) {
    return 4294960532LL;
  }
  int v5 = Count;
  uint64_t v6 = _os_object_alloc(&OBJC_CLASS___OS_mdns_server, 120LL);
  if (!v6) {
    return 4294960568LL;
  }
  uint64_t v7 = v6;
  int v8 = &_mdns_server_kind;
  *(void *)(v6 + 16) = &_mdns_server_kind;
  do
  {
    uint64_t v9 = (void (*)(uint64_t))v8[2];
    if (v9) {
      v9(v7);
    }
    int v8 = (_UNKNOWN **)*v8;
  }

  while (v8);
  *(void *)(v7 + 4_Block_object_dispose(va, 8) = a2;
  nw_retain(a2);
  uint64_t v10 = *(void *)(a1 + 16);
  if (*(_WORD *)(v10 + 156))
  {
    int v11 = *(unsigned __int16 *)(v10 + 156);
  }

  *(_DWORD *)(v7 + 100) = v5 + 1;
  uint64_t v12 = mach_continuous_time();
  if (mdns_mach_ticks_per_second_s_once != -1) {
    dispatch_once(&mdns_mach_ticks_per_second_s_once, &__block_literal_global_3412);
  }
  uint64_t v13 = v12 - 3600 * mdns_mach_ticks_per_second_s_ticks_per_second;
  *(void *)(v7 + 80) = v13;
  *(void *)(v7 + 8_Block_object_dispose(va, 8) = v13;
  CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 56), (const void *)v7);
  os_release((void *)v7);
  return 0LL;
}

void __mdns_resolver_activate_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (*(_BYTE *)(v1 + 136) || *(_BYTE *)(v1 + 135)) {
    goto LABEL_31;
  }
  *(_BYTE *)(v1 + 135) = 1;
  if (*(void *)(v1 + 80) && !*(void *)(v1 + 72))
  {
    if (_mdns_resolver_log_s_once != -1) {
      dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_48);
    }
    uint64_t v25 = (os_log_s *)_mdns_resolver_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)CFSocketContext buf = 0;
      _os_log_error_impl( (void *)&_mh_execute_header,  v25,  OS_LOG_TYPE_ERROR,  "API misuse: an event handler without a queue is useless!",  buf,  2u);
    }

    int v26 = *(const void **)(v1 + 80);
    if (v26)
    {
      _Block_release(v26);
      *(void *)(v1 + 80) = 0LL;
    }
  }

  if (!*(_DWORD *)(v1 + 124)) {
    *(_DWORD *)(v1 + 1memset(&v5[1], 0, 24) = 1000;
  }
  if (CFArrayGetCount(*(CFArrayRef *)(v1 + 56)) <= 0)
  {
    uint64_t v17 = *(uint64_t (**)(uint64_t))(*(void *)(v1 + 16) + 120LL);
    if (v17)
    {
      uint64_t v18 = v17(v1);
      if (v18)
      {
        uint64_t v19 = v18;
        uint64_t v20 = *(void *)(v1 + 16);
        __int16 v21 = *(uint64_t (**)(uint64_t))(v20 + 128);
        if (v21)
        {
          uint64_t v22 = v21(v1);
          if ((_DWORD)v22) {
            goto LABEL_38;
          }
          uint64_t v20 = *(void *)(v1 + 16);
        }

        uint64_t v22 = *(unsigned __int16 *)(v20 + 156);
LABEL_38:
        host_with_numeric_int port = nw_endpoint_create_host_with_numeric_port(v19, v22);
        if (host_with_numeric_port)
        {
          uint64_t v24 = (void *)host_with_numeric_port;
          if (*(void *)(v1 + 48)) {
            nw_endpoint_set_interface(host_with_numeric_port);
          }
          _mdns_resolver_add_server_by_endpoint(v1, v24);
          nw_release(v24);
        }
      }
    }
  }

  CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(v1 + 56));
  if (Count >= 1)
  {
    CFIndex v3 = Count;
    CFIndex v4 = 0LL;
    int v5 = (void *)(v1 + 24);
    do
    {
      uint64_t ValueAtIndex = (char *)CFArrayGetValueAtIndex(*(CFArrayRef *)(v1 + 56), v4);
      *((void *)ValueAtIndex + 3) = 0LL;
      *int v5 = ValueAtIndex;
      if (nw_endpoint_get_type(*((nw_endpoint_t *)ValueAtIndex + 6)) == nw_endpoint_type_address)
      {
        evaluator_for_nw_endpoint_t endpoint = nw_path_create_evaluator_for_endpoint(*((void *)ValueAtIndex + 6), 0LL);
        *((void *)ValueAtIndex + 7) = evaluator_for_endpoint;
        if (evaluator_for_endpoint)
        {
          uint64_t v8 = evaluator_for_endpoint;
          if (_mdns_resolver_queue_s_once != -1) {
            dispatch_once(&_mdns_resolver_queue_s_once, &__block_literal_global_138);
          }
          nw_path_evaluator_set_queue(v8, _mdns_resolver_queue_s_queue);
          os_retain((void *)v1);
          os_retain(ValueAtIndex);
          uint64_t v9 = *((void *)ValueAtIndex + 7);
          if (_mdns_resolver_queue_s_once != -1) {
            dispatch_once(&_mdns_resolver_queue_s_once, &__block_literal_global_138);
          }
          *(void *)CFSocketContext buf = _NSConcreteStackBlock;
          *(void *)&uint8_t buf[8] = 0x40000000LL;
          *(void *)&uint8_t buf[16] = ___mdns_resolver_set_up_server_path_evaluator_block_invoke;
          __int128 v30 = &__block_descriptor_tmp_61_4615;
          uint64_t v31 = v1;
          uint64_t v32 = ValueAtIndex;
          nw_path_evaluator_set_update_handler(v9, _mdns_resolver_queue_s_queue, buf);
          uint64_t v10 = *((void *)ValueAtIndex + 7);
          v28[0] = _NSConcreteStackBlock;
          v28[1] = 0x40000000LL;
          _OWORD v28[2] = ___mdns_resolver_set_up_server_path_evaluator_block_invoke_62;
          v28[3] = &__block_descriptor_tmp_63;
          v28[4] = v1;
          v28[5] = ValueAtIndex;
          nw_path_evaluator_set_cancel_handler(v10, v28);
          nw_path_evaluator_start(*((void *)ValueAtIndex + 7));
          int v11 = (nw_path *)nw_path_evaluator_copy_path(*((void *)ValueAtIndex + 7));
          if (v11)
          {
            uint64_t v12 = v11;
            ValueAtIndex[106] = _mdns_get_server_usability_from_path( v11,  (*(_DWORD *)(*(void *)(v1 + 16) + 144LL) - 3) < 2);
            nw_release(v12);
          }

          goto LABEL_23;
        }

        if (_mdns_resolver_log_s_once != -1) {
          dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_48);
        }
        uint64_t v13 = (os_log_s *)_mdns_resolver_log_s_log;
        if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)CFSocketContext buf = 138412290;
          *(void *)&uint8_t buf[4] = ValueAtIndex;
          _os_log_error_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_ERROR,  "Failed to create path evaluator for %@",  buf,  0xCu);
        }
      }

      ValueAtIndex[106] = 2;
LABEL_23:
      if (_mdns_resolver_log_s_once != -1) {
        dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_48);
      }
      uint64_t v14 = (os_log_s *)_mdns_resolver_log_s_log;
      if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_DEFAULT))
      {
        unsigned int v15 = ValueAtIndex[106] + 1;
        CFStringRef v16 = "<INVALID USABILITY>";
        if (v15 <= 5) {
          CFStringRef v16 = off_10013D7F0[v15];
        }
        *(_DWORD *)CFSocketContext buf = 138412546;
        *(void *)&uint8_t buf[4] = ValueAtIndex;
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = v16;
        _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_DEFAULT,  "Server %@ usability is %{public}s",  buf,  0x16u);
      }

      ++v4;
      int v5 = ValueAtIndex + 24;
    }

    while (v3 != v4);
  }

  _mdns_resolver_check_for_problematic_servers(v1);
  uint64_t v1 = *(void *)(a1 + 32);
LABEL_31:
  os_release((void *)v1);
}