#error "100004C48: too big function (funcsize=0)"
int *sub_100022584()
{
  __int16 v0;
  char v1;
  int v2;
  os_log_s *v3;
  int v4;
  CFStringRef v5;
  CFStringRef v6;
  const char *CStringPtr;
  char *v8;
  char *v9;
  os_log_s *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  FILE *v18;
  FILE *v19;
  int v20;
  os_log_s *v21;
  int v22;
  CFStringRef v23;
  CFStringRef v24;
  const char *v25;
  char *v26;
  char *v27;
  os_log_s *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  FILE *v36;
  FILE *v37;
  int v38;
  os_log_s *v39;
  int v40;
  CFStringRef v41;
  CFStringRef v42;
  const char *v43;
  char *v44;
  char *v45;
  os_log_s *v46;
  FILE *v47;
  FILE *v48;
  double v49;
  double v50;
  int v51;
  os_log_s *v52;
  int v53;
  CFStringRef v54;
  CFStringRef v55;
  const char *v56;
  char *v57;
  char *v58;
  os_log_s *v59;
  FILE *v60;
  FILE *v61;
  int v62;
  os_log_s *v63;
  int v64;
  CFStringRef v65;
  CFStringRef v66;
  const char *v67;
  char *v68;
  char *v69;
  os_log_s *v70;
  FILE *v71;
  FILE *v72;
  int v73;
  os_log_s *v74;
  int v75;
  CFStringRef v76;
  CFStringRef v77;
  const char *v78;
  char *v79;
  char *v80;
  os_log_s *v81;
  FILE *v82;
  FILE *v83;
  int v84;
  os_log_s *v85;
  int v86;
  CFStringRef v87;
  CFStringRef v88;
  const char *v89;
  char *v90;
  char *v91;
  os_log_s *v92;
  FILE *v93;
  FILE *v94;
  int v95;
  os_log_s *v96;
  int v97;
  CFStringRef v98;
  CFStringRef v99;
  const char *v100;
  char *v101;
  char *v102;
  os_log_s *v103;
  FILE *v104;
  FILE *v105;
  char v106;
  int v107;
  os_log_s *v108;
  int v109;
  CFStringRef v110;
  CFStringRef v111;
  const char *v112;
  char *v113;
  char *v114;
  os_log_s *v115;
  FILE *v116;
  FILE *v117;
  int v118;
  os_log_s *v119;
  int v120;
  CFStringRef v121;
  CFStringRef v122;
  const char *v123;
  char *v124;
  char *v125;
  os_log_s *v126;
  FILE *v127;
  FILE *v128;
  int v129;
  os_log_s *v130;
  int v131;
  CFStringRef v132;
  CFStringRef v133;
  const char *v134;
  char *v135;
  char *v136;
  os_log_s *v137;
  FILE *v138;
  FILE *v139;
  int *result;
  char v141;
  int v142;
  os_log_s *v143;
  int v144;
  CFStringRef v145;
  CFStringRef v146;
  const char *v147;
  char *v148;
  char *v149;
  os_log_s *v150;
  FILE *v151;
  FILE *v152;
  uint8_t buf[4];
  _BYTE v154[10];
  __int16 v155;
  int v156;
  __int16 v157;
  int v158;
  if (sub_10002C400("/var/db/.spindump_ignore_thermal_pressure")) {
    v0 = 2;
  }
  else {
    v0 = 0;
  }
  word_1000E7D70 = word_1000E7D70 & 0xFFFD | v0;
  if (qword_1000E7C18 != -1) {
    dispatch_once(&qword_1000E7C18, &stru_1000D9078);
  }
  word_1000E7D70 = word_1000E7D70 & 0xFFFE | byte_1000E7C10;
  if (qword_1000E7C28 != -1) {
    dispatch_once(&qword_1000E7C28, &stru_1000D9098);
  }
  word_1000E7D70 = word_1000E7D70 & 0xFFFB | (4 * byte_1000E7C20);
  if (qword_1000E7C38 != -1) {
    dispatch_once(&qword_1000E7C38, &stru_1000D90B8);
  }
  v1 = word_1000E7D70;
  word_1000E7D70 = word_1000E7D70 & 0xFFF7 | (8 * byte_1000E7C30);
  if ((v1 & 4) != 0)
  {
    if (byte_1000E7D30)
    {
      v2 = *__error();
      v3 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Submissions suppressed", buf, 2u);
      }

      *__error() = v2;
    }

    if (byte_1000E7D31 && dword_1000E74E0 <= 2)
    {
      v4 = *__error();
      v5 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"Submissions suppressed");
      if (v5)
      {
        v6 = v5;
        CStringPtr = CFStringGetCStringPtr(v5, 0x8000100u);
        if (CStringPtr)
        {
          v8 = (char *)CStringPtr;
          v9 = 0LL;
        }

        else
        {
          v8 = (char *)calloc(0x400uLL, 1uLL);
          CFStringGetCString(v6, v8, 1024LL, 0x8000100u);
          v9 = v8;
        }

        if (qword_1000E7D38) {
          v19 = (FILE *)qword_1000E7D38;
        }
        else {
          v19 = __stderrp;
        }
        fprintf(v19, "%s\n", v8);
        if (v9) {
          free(v9);
        }
        CFRelease(v6);
      }

      else
      {
        v10 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v10, OS_LOG_TYPE_FAULT)) {
          sub_100085644(v10, v11, v12, v13, v14, v15, v16, v17);
        }
        if (qword_1000E7D38) {
          v18 = (FILE *)qword_1000E7D38;
        }
        else {
          v18 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v18);
      }

      *__error() = v4;
    }
  }

  if ((word_1000E7D70 & 8) != 0)
  {
    if (byte_1000E7D30)
    {
      v20 = *__error();
      v21 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "Submissions forced enabled", buf, 2u);
      }

      *__error() = v20;
    }

    if (byte_1000E7D31 && dword_1000E74E0 <= 2)
    {
      v22 = *__error();
      v23 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"Submissions forced enabled");
      if (v23)
      {
        v24 = v23;
        v25 = CFStringGetCStringPtr(v23, 0x8000100u);
        if (v25)
        {
          v26 = (char *)v25;
          v27 = 0LL;
        }

        else
        {
          v26 = (char *)calloc(0x400uLL, 1uLL);
          CFStringGetCString(v24, v26, 1024LL, 0x8000100u);
          v27 = v26;
        }

        if (qword_1000E7D38) {
          v37 = (FILE *)qword_1000E7D38;
        }
        else {
          v37 = __stderrp;
        }
        fprintf(v37, "%s\n", v26);
        if (v27) {
          free(v27);
        }
        CFRelease(v24);
      }

      else
      {
        v28 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v28, OS_LOG_TYPE_FAULT)) {
          sub_100085614(v28, v29, v30, v31, v32, v33, v34, v35);
        }
        if (qword_1000E7D38) {
          v36 = (FILE *)qword_1000E7D38;
        }
        else {
          v36 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v36);
      }

      *__error() = v22;
    }
  }

  if ((word_1000E7D70 & 1) != 0)
  {
    qword_1000E7D48 = 0x4059000000000000LL;
    if (byte_1000E7D30)
    {
      v38 = *__error();
      v39 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v39, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)buf = 134217984;
        *(void *)v154 = qword_1000E7D48;
        _os_log_impl( (void *)&_mh_execute_header,  v39,  OS_LOG_TYPE_INFO,  "Apple Internal: reporting full spins %.1f%% of the time",  buf,  0xCu);
      }

      *__error() = v38;
    }

    if (byte_1000E7D31 && dword_1000E74E0 <= 1)
    {
      v40 = *__error();
      v41 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"Apple Internal: reporting full spins %.1f%% of the time",  qword_1000E7D48);
      if (v41)
      {
        v42 = v41;
        v43 = CFStringGetCStringPtr(v41, 0x8000100u);
        if (v43)
        {
          v44 = (char *)v43;
          v45 = 0LL;
        }

        else
        {
          v44 = (char *)calloc(0x400uLL, 1uLL);
          CFStringGetCString(v42, v44, 1024LL, 0x8000100u);
          v45 = v44;
        }

        if (qword_1000E7D38) {
          v48 = (FILE *)qword_1000E7D38;
        }
        else {
          v48 = __stderrp;
        }
        fprintf(v48, "%s\n", v44);
        if (v45) {
          free(v45);
        }
        CFRelease(v42);
      }

      else
      {
        v46 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v46, OS_LOG_TYPE_FAULT)) {
          sub_1000855A8();
        }
        if (qword_1000E7D38) {
          v47 = (FILE *)qword_1000E7D38;
        }
        else {
          v47 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v47);
      }

      *__error() = v40;
    }
  }

  else
  {
    sub_1000471B8((uint64_t)@"spindump_percent_full_spin_reports", (uint64_t)&qword_1000E7D48, 0.0);
  }

  v49 = 1.0;
  if ((word_1000E7D70 & 1) != 0) {
    v49 = 100.0;
  }
  sub_1000471B8((uint64_t)@"io_exception_sampling_percentage", (uint64_t)&qword_1000E7D60, v49);
  v50 = 5.0;
  if ((word_1000E7D70 & 1) != 0) {
    v50 = 100.0;
  }
  sub_1000471B8((uint64_t)@"cpu_resource_1st_party_sampling_percentage", (uint64_t)&qword_1000E7D68, v50);
  sub_1000471B8((uint64_t)@"spindump_percent_short_spins_reported", (uint64_t)&unk_1000E7D50, 10.0);
  sub_1000471B8((uint64_t)@"spindump_threshold_defining_short_spins_s", (uint64_t)&unk_1000E7D58, 2.0);
  word_1000E7D70 &= 0xFF9Fu;
  if (byte_1000E7D30)
  {
    v51 = *__error();
    v52 = (os_log_s *)sub_10002EFA0();
    if (os_log_type_enabled(v52, OS_LOG_TYPE_DEBUG)) {
      sub_100085538();
    }
    *__error() = v51;
  }

  if (byte_1000E7D31 && dword_1000E74E0 <= 0)
  {
    v53 = *__error();
    v54 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"Submit spins:%d hangs:%d unavilable on this platform",  ((unsigned __int16)word_1000E7D70 >> 5) & 1,  ((unsigned __int16)word_1000E7D70 >> 6) & 1);
    if (v54)
    {
      v55 = v54;
      v56 = CFStringGetCStringPtr(v54, 0x8000100u);
      if (v56)
      {
        v57 = (char *)v56;
        v58 = 0LL;
      }

      else
      {
        v57 = (char *)calloc(0x400uLL, 1uLL);
        CFStringGetCString(v55, v57, 1024LL, 0x8000100u);
        v58 = v57;
      }

      if (qword_1000E7D38) {
        v61 = (FILE *)qword_1000E7D38;
      }
      else {
        v61 = __stderrp;
      }
      fprintf(v61, "%s\n", v57);
      if (v58) {
        free(v58);
      }
      CFRelease(v55);
    }

    else
    {
      v59 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v59, OS_LOG_TYPE_FAULT)) {
        sub_1000854D4();
      }
      if (qword_1000E7D38) {
        v60 = (FILE *)qword_1000E7D38;
      }
      else {
        v60 = __stderrp;
      }
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v60);
    }

    *__error() = v53;
  }

  word_1000E7D70 = (word_1000E7D70 & 0xDE7F | ((((unsigned __int16)word_1000E7D70 >> 2) & 1) << 7) & 0xDEFF | ((((unsigned __int16)word_1000E7D70 >> 2) & 1) << 13) | ((((unsigned __int16)word_1000E7D70 >> 2) & 1) << 8)) ^ 0x2180;
  if (byte_1000E7D30)
  {
    v62 = *__error();
    v63 = (os_log_s *)sub_10002EFA0();
    if (os_log_type_enabled(v63, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 67109632;
      *(_DWORD *)v154 = ((unsigned __int16)word_1000E7D70 >> 7) & 1;
      *(_WORD *)&v154[4] = 1024;
      *(_DWORD *)&v154[6] = HIBYTE(word_1000E7D70) & 1;
      v155 = 1024;
      v156 = ((unsigned __int16)word_1000E7D70 >> 2) & 1;
      _os_log_impl( (void *)&_mh_execute_header,  v63,  OS_LOG_TYPE_INFO,  "Submit resource reports cpu:%d io:%d due to suppression:%d",  buf,  0x14u);
    }

    *__error() = v62;
  }

  if (byte_1000E7D31 && dword_1000E74E0 <= 1)
  {
    v64 = *__error();
    v65 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"Submit resource reports cpu:%d io:%d due to suppression:%d",  ((unsigned __int16)word_1000E7D70 >> 7) & 1,  HIBYTE(word_1000E7D70) & 1,  ((unsigned __int16)word_1000E7D70 >> 2) & 1);
    if (v65)
    {
      v66 = v65;
      v67 = CFStringGetCStringPtr(v65, 0x8000100u);
      if (v67)
      {
        v68 = (char *)v67;
        v69 = 0LL;
      }

      else
      {
        v68 = (char *)calloc(0x400uLL, 1uLL);
        CFStringGetCString(v66, v68, 1024LL, 0x8000100u);
        v69 = v68;
      }

      if (qword_1000E7D38) {
        v72 = (FILE *)qword_1000E7D38;
      }
      else {
        v72 = __stderrp;
      }
      fprintf(v72, "%s\n", v68);
      if (v69) {
        free(v69);
      }
      CFRelease(v66);
    }

    else
    {
      v70 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v70, OS_LOG_TYPE_FAULT)) {
        sub_10008544C();
      }
      if (qword_1000E7D38) {
        v71 = (FILE *)qword_1000E7D38;
      }
      else {
        v71 = __stderrp;
      }
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v71);
    }

    *__error() = v64;
  }

  word_1000E7D70 = ((word_1000E7D70 << 8) & 0x400 | word_1000E7D70 & 0xF1FF | (word_1000E7D70 << 7) & 0x200 | (word_1000E7D70 << 9) & 0x800) ^ 0xE00;
  if (byte_1000E7D30)
  {
    v73 = *__error();
    v74 = (os_log_s *)sub_10002EFA0();
    if (os_log_type_enabled(v74, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 67109888;
      *(_DWORD *)v154 = ((unsigned __int16)word_1000E7D70 >> 9) & 1;
      *(_WORD *)&v154[4] = 1024;
      *(_DWORD *)&v154[6] = ((unsigned __int16)word_1000E7D70 >> 10) & 1;
      v155 = 1024;
      v156 = ((unsigned __int16)word_1000E7D70 >> 11) & 1;
      v157 = 1024;
      v158 = ((unsigned __int16)word_1000E7D70 >> 2) & 1;
      _os_log_impl( (void *)&_mh_execute_header,  v74,  OS_LOG_TYPE_INFO,  "Submit systemstats:%d sleep/wake failure:%d watchdog:%d due to suppression:%d",  buf,  0x1Au);
    }

    *__error() = v73;
  }

  if (byte_1000E7D31 && dword_1000E74E0 <= 1)
  {
    v75 = *__error();
    v76 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"Submit systemstats:%d sleep/wake failure:%d watchdog:%d due to suppression:%d",  ((unsigned __int16)word_1000E7D70 >> 9) & 1,  ((unsigned __int16)word_1000E7D70 >> 10) & 1,  ((unsigned __int16)word_1000E7D70 >> 11) & 1,  ((unsigned __int16)word_1000E7D70 >> 2) & 1);
    if (v76)
    {
      v77 = v76;
      v78 = CFStringGetCStringPtr(v76, 0x8000100u);
      if (v78)
      {
        v79 = (char *)v78;
        v80 = 0LL;
      }

      else
      {
        v79 = (char *)calloc(0x400uLL, 1uLL);
        CFStringGetCString(v77, v79, 1024LL, 0x8000100u);
        v80 = v79;
      }

      if (qword_1000E7D38) {
        v83 = (FILE *)qword_1000E7D38;
      }
      else {
        v83 = __stderrp;
      }
      fprintf(v83, "%s\n", v79);
      if (v80) {
        free(v80);
      }
      CFRelease(v77);
    }

    else
    {
      v81 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v81, OS_LOG_TYPE_FAULT)) {
        sub_1000853B8();
      }
      if (qword_1000E7D38) {
        v82 = (FILE *)qword_1000E7D38;
      }
      else {
        v82 = __stderrp;
      }
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v82);
    }

    *__error() = v75;
  }

  word_1000E7D70 &= ~0x1000u;
  if (byte_1000E7D30)
  {
    v84 = *__error();
    v85 = (os_log_s *)sub_10002EFA0();
    if (os_log_type_enabled(v85, OS_LOG_TYPE_DEBUG)) {
      sub_100085354();
    }
    *__error() = v84;
  }

  if (byte_1000E7D31 && dword_1000E74E0 <= 0)
  {
    v86 = *__error();
    v87 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"Submit service watchdog:%d unavilable on this platform",  ((unsigned __int16)word_1000E7D70 >> 12) & 1);
    if (v87)
    {
      v88 = v87;
      v89 = CFStringGetCStringPtr(v87, 0x8000100u);
      if (v89)
      {
        v90 = (char *)v89;
        v91 = 0LL;
      }

      else
      {
        v90 = (char *)calloc(0x400uLL, 1uLL);
        CFStringGetCString(v88, v90, 1024LL, 0x8000100u);
        v91 = v90;
      }

      if (qword_1000E7D38) {
        v94 = (FILE *)qword_1000E7D38;
      }
      else {
        v94 = __stderrp;
      }
      fprintf(v94, "%s\n", v90);
      if (v91) {
        free(v91);
      }
      CFRelease(v88);
    }

    else
    {
      v92 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v92, OS_LOG_TYPE_FAULT)) {
        sub_1000852F0();
      }
      if (qword_1000E7D38) {
        v93 = (FILE *)qword_1000E7D38;
      }
      else {
        v93 = __stderrp;
      }
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v93);
    }

    *__error() = v86;
  }

  byte_1000E7D44 = (byte_1000E7D44 & 0xFC | (2 * (word_1000E7D70 & 1))) ^ 2;
  if (byte_1000E7D30)
  {
    v95 = *__error();
    v96 = (os_log_s *)sub_10002EFA0();
    if (os_log_type_enabled(v96, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 67109376;
      *(_DWORD *)v154 = (byte_1000E7D44 >> 1) & 1;
      *(_WORD *)&v154[4] = 1024;
      *(_DWORD *)&v154[6] = word_1000E7D70 & 1;
      _os_log_impl( (void *)&_mh_execute_header,  v96,  OS_LOG_TYPE_INFO,  "Avoid affecting audio:%d due to internal:%d",  buf,  0xEu);
    }

    *__error() = v95;
  }

  if (byte_1000E7D31 && dword_1000E74E0 <= 1)
  {
    v97 = *__error();
    v98 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"Avoid affecting audio:%d due to internal:%d",  (byte_1000E7D44 >> 1) & 1,  word_1000E7D70 & 1);
    if (v98)
    {
      v99 = v98;
      v100 = CFStringGetCStringPtr(v98, 0x8000100u);
      if (v100)
      {
        v101 = (char *)v100;
        v102 = 0LL;
      }

      else
      {
        v101 = (char *)calloc(0x400uLL, 1uLL);
        CFStringGetCString(v99, v101, 1024LL, 0x8000100u);
        v102 = v101;
      }

      if (qword_1000E7D38) {
        v105 = (FILE *)qword_1000E7D38;
      }
      else {
        v105 = __stderrp;
      }
      fprintf(v105, "%s\n", v101);
      if (v102) {
        free(v102);
      }
      CFRelease(v99);
    }

    else
    {
      v103 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v103, OS_LOG_TYPE_FAULT)) {
        sub_100085268();
      }
      if (qword_1000E7D38) {
        v104 = (FILE *)qword_1000E7D38;
      }
      else {
        v104 = __stderrp;
      }
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v104);
    }

    *__error() = v97;
  }

  if (sub_10002C400("/var/db/.spindump_enable_symbolication")) {
    v106 = 8;
  }
  else {
    v106 = 0;
  }
  byte_1000E7D44 = byte_1000E7D44 & 0xF7 | v106;
  if (byte_1000E7D30)
  {
    v107 = *__error();
    v108 = (os_log_s *)sub_10002EFA0();
    if (os_log_type_enabled(v108, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 67109376;
      *(_DWORD *)v154 = (byte_1000E7D44 >> 3) & 1;
      *(_WORD *)&v154[4] = 1024;
      *(_DWORD *)&v154[6] = *(_DWORD *)v154;
      _os_log_impl( (void *)&_mh_execute_header,  v108,  OS_LOG_TYPE_INFO,  "Symbolicate:%d due to enable symbolication file existing:%d",  buf,  0xEu);
    }

    *__error() = v107;
  }

  if (byte_1000E7D31 && dword_1000E74E0 <= 1)
  {
    v109 = *__error();
    v110 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"Symbolicate:%d due to enable symbolication file existing:%d",  (byte_1000E7D44 >> 3) & 1,  (byte_1000E7D44 >> 3) & 1);
    if (v110)
    {
      v111 = v110;
      v112 = CFStringGetCStringPtr(v110, 0x8000100u);
      if (v112)
      {
        v113 = (char *)v112;
        v114 = 0LL;
      }

      else
      {
        v113 = (char *)calloc(0x400uLL, 1uLL);
        CFStringGetCString(v111, v113, 1024LL, 0x8000100u);
        v114 = v113;
      }

      if (qword_1000E7D38) {
        v117 = (FILE *)qword_1000E7D38;
      }
      else {
        v117 = __stderrp;
      }
      fprintf(v117, "%s\n", v113);
      if (v114) {
        free(v114);
      }
      CFRelease(v111);
    }

    else
    {
      v115 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v115, OS_LOG_TYPE_FAULT)) {
        sub_1000851EC();
      }
      if (qword_1000E7D38) {
        v116 = (FILE *)qword_1000E7D38;
      }
      else {
        v116 = __stderrp;
      }
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v116);
    }

    *__error() = v109;
  }

  byte_1000E7D44 |= 0x10u;
  if (byte_1000E7D30)
  {
    v118 = *__error();
    v119 = (os_log_s *)sub_10002EFA0();
    if (os_log_type_enabled(v119, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 67109120;
      *(_DWORD *)v154 = (byte_1000E7D44 >> 4) & 1;
      _os_log_impl((void *)&_mh_execute_header, v119, OS_LOG_TYPE_INFO, "NoBulkSymbolication:%d", buf, 8u);
    }

    *__error() = v118;
  }

  if (byte_1000E7D31 && dword_1000E74E0 <= 1)
  {
    v120 = *__error();
    v121 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"NoBulkSymbolication:%d",  (byte_1000E7D44 >> 4) & 1);
    if (v121)
    {
      v122 = v121;
      v123 = CFStringGetCStringPtr(v121, 0x8000100u);
      if (v123)
      {
        v124 = (char *)v123;
        v125 = 0LL;
      }

      else
      {
        v124 = (char *)calloc(0x400uLL, 1uLL);
        CFStringGetCString(v122, v124, 1024LL, 0x8000100u);
        v125 = v124;
      }

      if (qword_1000E7D38) {
        v128 = (FILE *)qword_1000E7D38;
      }
      else {
        v128 = __stderrp;
      }
      fprintf(v128, "%s\n", v124);
      if (v125) {
        free(v125);
      }
      CFRelease(v122);
    }

    else
    {
      v126 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v126, OS_LOG_TYPE_FAULT)) {
        sub_100085184();
      }
      if (qword_1000E7D38) {
        v127 = (FILE *)qword_1000E7D38;
      }
      else {
        v127 = __stderrp;
      }
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v127);
    }

    *__error() = v120;
  }

  byte_1000E7D44 &= ~4u;
  if (byte_1000E7D30)
  {
    v129 = *__error();
    v130 = (os_log_s *)sub_10002EFA0();
    if (os_log_type_enabled(v130, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 67109120;
      *(_DWORD *)v154 = (byte_1000E7D44 >> 2) & 1;
      _os_log_impl((void *)&_mh_execute_header, v130, OS_LOG_TYPE_INFO, "UseDsymForUUID:%d", buf, 8u);
    }

    *__error() = v129;
  }

  if (byte_1000E7D31 && dword_1000E74E0 <= 1)
  {
    v131 = *__error();
    v132 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"UseDsymForUUID:%d",  (byte_1000E7D44 >> 2) & 1);
    if (v132)
    {
      v133 = v132;
      v134 = CFStringGetCStringPtr(v132, 0x8000100u);
      if (v134)
      {
        v135 = (char *)v134;
        v136 = 0LL;
      }

      else
      {
        v135 = (char *)calloc(0x400uLL, 1uLL);
        CFStringGetCString(v133, v135, 1024LL, 0x8000100u);
        v136 = v135;
      }

      if (qword_1000E7D38) {
        v139 = (FILE *)qword_1000E7D38;
      }
      else {
        v139 = __stderrp;
      }
      fprintf(v139, "%s\n", v135);
      if (v136) {
        free(v136);
      }
      CFRelease(v133);
    }

    else
    {
      v137 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v137, OS_LOG_TYPE_FAULT)) {
        sub_10008511C();
      }
      if (qword_1000E7D38) {
        v138 = (FILE *)qword_1000E7D38;
      }
      else {
        v138 = __stderrp;
      }
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v138);
    }

    *__error() = v131;
  }

  result = (int *)sub_10002C400("/var/db/.spindump_disable_exclaves");
  if ((_DWORD)result) {
    v141 = 32;
  }
  else {
    v141 = 0;
  }
  byte_1000E7D44 = byte_1000E7D44 & 0xDF | v141;
  if (byte_1000E7D30)
  {
    v142 = *__error();
    v143 = (os_log_s *)sub_10002EFA0();
    if (os_log_type_enabled(v143, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 67109120;
      *(_DWORD *)v154 = (byte_1000E7D44 >> 5) & 1;
      _os_log_impl((void *)&_mh_execute_header, v143, OS_LOG_TYPE_INFO, "NoExclaves:%d", buf, 8u);
    }

    result = __error();
    *result = v142;
  }

  if (byte_1000E7D31 && dword_1000E74E0 <= 1)
  {
    v144 = *__error();
    v145 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"NoExclaves:%d",  (byte_1000E7D44 >> 5) & 1);
    if (v145)
    {
      v146 = v145;
      v147 = CFStringGetCStringPtr(v145, 0x8000100u);
      if (v147)
      {
        v148 = (char *)v147;
        v149 = 0LL;
      }

      else
      {
        v148 = (char *)calloc(0x400uLL, 1uLL);
        CFStringGetCString(v146, v148, 1024LL, 0x8000100u);
        v149 = v148;
      }

      if (qword_1000E7D38) {
        v152 = (FILE *)qword_1000E7D38;
      }
      else {
        v152 = __stderrp;
      }
      fprintf(v152, "%s\n", v148);
      if (v149) {
        free(v149);
      }
      CFRelease(v146);
    }

    else
    {
      v150 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v150, OS_LOG_TYPE_FAULT)) {
        sub_1000850B4();
      }
      if (qword_1000E7D38) {
        v151 = (FILE *)qword_1000E7D38;
      }
      else {
        v151 = __stderrp;
      }
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v151);
    }

    result = __error();
    *result = v144;
  }

  return result;
}

uint64_t sub_100023C08(uint64_t a1)
{
  v2[0] = _NSConcreteStackBlock;
  v2[1] = 3221225472LL;
  v3 = sub_100023C88;
  v4 = &unk_1000D9108;
  uint64_t v5 = a1;
  sub_100023C88((uint64_t)v2, 2);
  sub_100023C88((uint64_t)v2, 15);
  v3((uint64_t)v2, 1);
  return ((uint64_t (*)(void *, uint64_t))v3)(v2, 3LL);
}

void sub_100023C88(uint64_t a1, int a2)
{
  uintptr_t v4 = a2;
  dispatch_queue_global_t global_queue = dispatch_get_global_queue(25LL, 2uLL);
  dispatch_source_t v6 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_signal, v4, 0LL, global_queue);
  if (!v6)
  {
    if (byte_1000E7D30)
    {
      int v13 = *__error();
      v14 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
        sub_10008DF30(v14, v15, v16);
      }
      *__error() = v13;
    }

    if (byte_1000E7D31) {
      BOOL v17 = dword_1000E74E0 <= 3;
    }
    else {
      BOOL v17 = 0;
    }
    if (v17)
    {
      int v18 = *__error();
      v19 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"%s: unable to allocate source", "source");
      if (v19)
      {
        int v28 = v18;
        theString = v19;
        CStringPtr = CFStringGetCStringPtr(v19, 0x8000100u);
        if (CStringPtr)
        {
          v25 = (char *)CStringPtr;
          v26 = 0LL;
        }

        else
        {
          v25 = (char *)calloc(0x400uLL, 1uLL);
          CFStringGetCString(theString, v25, 1024LL, 0x8000100u);
          v26 = v25;
        }

        if (qword_1000E7D38) {
          v27 = (FILE *)qword_1000E7D38;
        }
        else {
          v27 = __stderrp;
        }
        fprintf(v27, "%s\n", v25);
        if (v26) {
          free(v26);
        }
        CFRelease(theString);
        int v18 = v28;
      }

      else
      {
        v20 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v20, OS_LOG_TYPE_FAULT)) {
          sub_10008DEBC(v20, v21, v22);
        }
        if (qword_1000E7D38) {
          v23 = (FILE *)qword_1000E7D38;
        }
        else {
          v23 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v23);
      }

      *__error() = v18;
    }

    sub_10002EE78( "RegisterExitHandlers_block_invoke",  "spindump.m",  4145,  "%s: unable to allocate source",  v7,  v8,  v9,  v10,  (char)"source");
    abort();
  }

  v11 = v6;
  signal(a2, (void (__cdecl *)(int))1);
  handler[0] = _NSConcreteStackBlock;
  handler[1] = 3221225472LL;
  handler[2] = sub_10005C550;
  handler[3] = &unk_1000D9728;
  uint64_t v12 = *(void *)(a1 + 32);
  handler[4] = v11;
  handler[5] = v12;
  dispatch_source_set_event_handler(v11, handler);
  dispatch_resume(v11);
}

void sub_100023EEC()
{
  v0 = dispatch_queue_attr_make_with_autorelease_frequency(0LL, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
  v1 = dispatch_queue_attr_make_with_qos_class(v0, QOS_CLASS_USER_INITIATED, 0);
  v2 = dispatch_queue_create("com.apple.spindump.communication", v1);
  dispatch_release(v1);
  dispatch_release(v0);
  if (!v2)
  {
    if (byte_1000E7D30)
    {
      int v8 = *__error();
      uint64_t v9 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
        sub_100086050(v9, v10, v11, v12, v13, v14, v15, v16);
      }
      *__error() = v8;
    }

    if (byte_1000E7D31) {
      BOOL v17 = dword_1000E74E0 <= 3;
    }
    else {
      BOOL v17 = 0;
    }
    if (v17)
    {
      int v18 = *__error();
      v19 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"%s: unable to allocate communication queue",  "communication_queue");
      if (v19)
      {
        int v33 = v18;
        theString = v19;
        CStringPtr = CFStringGetCStringPtr(v19, 0x8000100u);
        if (CStringPtr)
        {
          v30 = (char *)CStringPtr;
          v31 = 0LL;
        }

        else
        {
          v30 = (char *)calloc(0x400uLL, 1uLL);
          CFStringGetCString(theString, v30, 1024LL, 0x8000100u);
          v31 = v30;
        }

        if (qword_1000E7D38) {
          v32 = (FILE *)qword_1000E7D38;
        }
        else {
          v32 = __stderrp;
        }
        fprintf(v32, "%s\n", v30);
        if (v31) {
          free(v31);
        }
        CFRelease(theString);
        int v18 = v33;
      }

      else
      {
        v20 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v20, OS_LOG_TYPE_FAULT)) {
          sub_100085FE0(v20, v21, v22, v23, v24, v25, v26, v27);
        }
        if (qword_1000E7D38) {
          int v28 = (FILE *)qword_1000E7D38;
        }
        else {
          int v28 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v28);
      }

      *__error() = v18;
    }

    sub_10002EE78( "startup_ports",  "reading.m",  99,  "%s: unable to allocate communication queue",  v3,  v4,  v5,  v6,  (char)"communication_queue");
    abort();
  }

  mach_service = xpc_connection_create_mach_service("com.apple.spindump", v2, 1uLL);
  handler[0] = _NSConcreteStackBlock;
  handler[1] = 3221225472LL;
  handler[2] = sub_100025BC0;
  handler[3] = &unk_1000D9150;
  handler[4] = v2;
  xpc_connection_set_event_handler(mach_service, handler);
  xpc_connection_resume(mach_service);
  dispatch_release(v2);
  sub_10004CFE0();
}

_DWORD *sub_100024170( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((byte_1000E7D44 & 1) != 0)
  {
    if (byte_1000E7D30)
    {
      int v124 = *__error();
      v125 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v125, OS_LOG_TYPE_ERROR)) {
        sub_10008503C();
      }
      *__error() = v124;
    }

    if (byte_1000E7D31) {
      BOOL v126 = dword_1000E74E0 <= 3;
    }
    else {
      BOOL v126 = 0;
    }
    if (v126)
    {
      int v127 = *__error();
      v128 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"%s: Getting prefs for user %d as command-line",  "!global_preferences.command_line",  a1);
      if (v128)
      {
        v173 = v128;
        CStringPtr = CFStringGetCStringPtr(v128, 0x8000100u);
        if (CStringPtr)
        {
          v175 = (char *)CStringPtr;
          v176 = 0LL;
        }

        else
        {
          v175 = (char *)calloc(0x400uLL, 1uLL);
          CFStringGetCString(v173, v175, 1024LL, 0x8000100u);
          v176 = v175;
        }

        if (qword_1000E7D38) {
          v181 = (FILE *)qword_1000E7D38;
        }
        else {
          v181 = __stderrp;
        }
        fprintf(v181, "%s\n", v175);
        if (v176) {
          free(v176);
        }
        CFRelease(v173);
      }

      else
      {
        v129 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v129, OS_LOG_TYPE_FAULT)) {
          sub_100084FC4();
        }
        if (qword_1000E7D38) {
          v130 = (FILE *)qword_1000E7D38;
        }
        else {
          v130 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v130);
      }

      *__error() = v127;
    }

    sub_10002EE78( "get_user_preferences",  "preferences.m",  98,  "%s: Getting prefs for user %d as command-line",  a5,  a6,  a7,  a8,  (char)"!global_preferences.command_line");
LABEL_279:
    abort();
  }

  os_unfair_lock_lock((os_unfair_lock_t)&unk_1000E7BF0);
  uint64_t v9 = (NSMutableDictionary *)qword_1000E7BF8;
  if (!qword_1000E7BF8)
  {
    uint64_t v9 = -[NSMutableDictionary initWithCapacity:]( objc_alloc(&OBJC_CLASS___NSMutableDictionary),  "initWithCapacity:",  1LL);
    qword_1000E7BF8 = (uint64_t)v9;
    if (!v9)
    {
      if (byte_1000E7D30)
      {
        int v152 = *__error();
        v153 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v153, OS_LOG_TYPE_ERROR)) {
          sub_1000849E8(v153, v154, v155, v156, v157, v158, v159, v160);
        }
        *__error() = v152;
      }

      if (byte_1000E7D31) {
        BOOL v161 = dword_1000E74E0 <= 3;
      }
      else {
        BOOL v161 = 0;
      }
      if (v161)
      {
        int v162 = *__error();
        v163 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"%s: unable to allocate prefs dict",  "user_preferences_dict");
        if (v163)
        {
          v182 = v163;
          v183 = CFStringGetCStringPtr(v163, 0x8000100u);
          if (v183)
          {
            v184 = (char *)v183;
            v185 = 0LL;
          }

          else
          {
            v184 = (char *)calloc(0x400uLL, 1uLL);
            CFStringGetCString(v182, v184, 1024LL, 0x8000100u);
            v185 = v184;
          }

          if (qword_1000E7D38) {
            v187 = (FILE *)qword_1000E7D38;
          }
          else {
            v187 = __stderrp;
          }
          fprintf(v187, "%s\n", v184);
          if (v185) {
            free(v185);
          }
          CFRelease(v182);
        }

        else
        {
          v164 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v164, OS_LOG_TYPE_FAULT)) {
            sub_100084978(v164, v165, v166, v167, v168, v169, v170, v171);
          }
          if (qword_1000E7D38) {
            v172 = (FILE *)qword_1000E7D38;
          }
          else {
            v172 = __stderrp;
          }
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v172);
        }

        *__error() = v162;
      }

      sub_10002EE78( "get_user_preferences",  "preferences.m",  106,  "%s: unable to allocate prefs dict",  v10,  v11,  v12,  v13,  (char)"user_preferences_dict");
      goto LABEL_279;
    }
  }

  id v14 = -[NSMutableDictionary objectForKeyedSubscript:]( v9,  "objectForKeyedSubscript:",  +[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:", a1));
  if (v14)
  {
    uint64_t v15 = v14;
    os_unfair_lock_unlock((os_unfair_lock_t)&unk_1000E7BF0);
    return [v15 bytes];
  }

  BOOL v17 = calloc(1uLL, 0xCuLL);
  if (!v17)
  {
    if (byte_1000E7D30)
    {
      int v131 = *__error();
      v132 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v132, OS_LOG_TYPE_ERROR)) {
        sub_100084AC8(v132, v133, v134, v135, v136, v137, v138, v139);
      }
      *__error() = v131;
    }

    if (byte_1000E7D31) {
      BOOL v140 = dword_1000E74E0 <= 3;
    }
    else {
      BOOL v140 = 0;
    }
    if (v140)
    {
      int v141 = *__error();
      v142 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"%s: unable to allocate prefs", "prefs_for_uid");
      if (v142)
      {
        v177 = v142;
        v178 = CFStringGetCStringPtr(v142, 0x8000100u);
        if (v178)
        {
          v179 = (char *)v178;
          v180 = 0LL;
        }

        else
        {
          v179 = (char *)calloc(0x400uLL, 1uLL);
          CFStringGetCString(v177, v179, 1024LL, 0x8000100u);
          v180 = v179;
        }

        if (qword_1000E7D38) {
          v186 = (FILE *)qword_1000E7D38;
        }
        else {
          v186 = __stderrp;
        }
        fprintf(v186, "%s\n", v179);
        if (v180) {
          free(v180);
        }
        CFRelease(v177);
      }

      else
      {
        v143 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v143, OS_LOG_TYPE_FAULT)) {
          sub_100084A58(v143, v144, v145, v146, v147, v148, v149, v150);
        }
        if (qword_1000E7D38) {
          v151 = (FILE *)qword_1000E7D38;
        }
        else {
          v151 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v151);
      }

      *__error() = v141;
    }

    sub_10002EE78( "get_user_preferences",  "preferences.m",  116,  "%s: unable to allocate prefs",  v18,  v19,  v20,  v21,  (char)"prefs_for_uid");
    goto LABEL_279;
  }

  uint64_t v22 = v17;
  *BOOL v17 = a1;
  uint64_t v23 =  -[NSData initWithBytesNoCopy:length:freeWhenDone:]( objc_alloc(&OBJC_CLASS___NSData),  "initWithBytesNoCopy:length:freeWhenDone:",  v17,  12LL,  1LL);
  objc_msgSend( (id)qword_1000E7BF8,  "setObject:forKeyedSubscript:",  v23,  +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", a1));
  if (byte_1000E7D30)
  {
    int v24 = *__error();
    uint64_t v25 = (os_log_s *)sub_10002EFA0();
    if (os_log_type_enabled(v25, OS_LOG_TYPE_DEBUG)) {
      sub_100084F64();
    }
    *__error() = v24;
  }

  if (byte_1000E7D31 && dword_1000E74E0 <= 0)
  {
    int v26 = *__error();
    uint64_t v27 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"Initializing prefs for user %d", a1);
    if (v27)
    {
      int v28 = v27;
      v29 = CFStringGetCStringPtr(v27, 0x8000100u);
      if (v29)
      {
        v30 = (char *)v29;
        v31 = 0LL;
      }

      else
      {
        v30 = (char *)calloc(0x400uLL, 1uLL);
        CFStringGetCString(v28, v30, 1024LL, 0x8000100u);
        v31 = v30;
      }

      if (qword_1000E7D38) {
        v34 = (FILE *)qword_1000E7D38;
      }
      else {
        v34 = __stderrp;
      }
      fprintf(v34, "%s\n", v30);
      if (v31) {
        free(v31);
      }
      CFRelease(v28);
    }

    else
    {
      v32 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v32, OS_LOG_TYPE_FAULT)) {
        sub_100084F04();
      }
      if (qword_1000E7D38) {
        int v33 = (FILE *)qword_1000E7D38;
      }
      else {
        int v33 = __stderrp;
      }
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v33);
    }

    *__error() = v26;
  }

  v36 = (__int16 *)(v22 + 2);
  __int16 v35 = *((_WORD *)v22 + 4);
  v22[1] = -1;
  *((_WORD *)v22 + 4) = v35 & 0xFFC0 | 8;
  if (byte_1000E7D30)
  {
    int v37 = *__error();
    v38 = (os_log_s *)sub_10002EFA0();
    if (os_log_type_enabled(v38, OS_LOG_TYPE_INFO))
    {
      unsigned int v39 = (unsigned __int16)*v36;
      *(_DWORD *)buf = 67109888;
      int v189 = a1;
      __int16 v190 = 1024;
      int v191 = (v39 >> 5) & 1;
      __int16 v192 = 1024;
      int v193 = (v39 >> 3) & 1;
      __int16 v194 = 1024;
      int v195 = (v39 >> 2) & 1;
      _os_log_impl( (void *)&_mh_execute_header,  v38,  OS_LOG_TYPE_INFO,  "UID %d: Present UI:%d due to server mode:%d admin:%d",  buf,  0x1Au);
    }

    *__error() = v37;
  }

  if (byte_1000E7D31 && dword_1000E74E0 <= 1)
  {
    int v40 = *__error();
    v41 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"UID %d: Present UI:%d due to server mode:%d admin:%d",  a1,  ((unsigned __int16)*v36 >> 5) & 1,  ((unsigned __int16)*v36 >> 3) & 1,  ((unsigned __int16)*v36 >> 2) & 1);
    if (v41)
    {
      v42 = v41;
      v43 = CFStringGetCStringPtr(v41, 0x8000100u);
      if (v43)
      {
        v44 = (char *)v43;
        v45 = 0LL;
      }

      else
      {
        v44 = (char *)calloc(0x400uLL, 1uLL);
        CFStringGetCString(v42, v44, 1024LL, 0x8000100u);
        v45 = v44;
      }

      if (qword_1000E7D38) {
        v48 = (FILE *)qword_1000E7D38;
      }
      else {
        v48 = __stderrp;
      }
      fprintf(v48, "%s\n", v44);
      if (v45) {
        free(v45);
      }
      CFRelease(v42);
    }

    else
    {
      v46 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v46, OS_LOG_TYPE_FAULT)) {
        sub_100084E94();
      }
      if (qword_1000E7D38) {
        v47 = (FILE *)qword_1000E7D38;
      }
      else {
        v47 = __stderrp;
      }
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v47);
    }

    *__error() = v40;
  }

  *v36 &= 0xFF3Fu;
  if (byte_1000E7D30)
  {
    int v49 = *__error();
    v50 = (os_log_s *)sub_10002EFA0();
    if (os_log_type_enabled(v50, OS_LOG_TYPE_DEBUG)) {
      sub_100084E24();
    }
    *__error() = v49;
  }

  if (byte_1000E7D31 && dword_1000E74E0 <= 0)
  {
    int v51 = *__error();
    v52 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"UID %d: User requested spins:%d hangs:%d unavilable on this platform",  a1,  ((unsigned __int16)*v36 >> 6) & 1,  ((unsigned __int16)*v36 >> 7) & 1);
    if (v52)
    {
      v53 = v52;
      v54 = CFStringGetCStringPtr(v52, 0x8000100u);
      if (v54)
      {
        v55 = (char *)v54;
        v56 = 0LL;
      }

      else
      {
        v55 = (char *)calloc(0x400uLL, 1uLL);
        CFStringGetCString(v53, v55, 1024LL, 0x8000100u);
        v56 = v55;
      }

      if (qword_1000E7D38) {
        v59 = (FILE *)qword_1000E7D38;
      }
      else {
        v59 = __stderrp;
      }
      fprintf(v59, "%s\n", v55);
      if (v56) {
        free(v56);
      }
      CFRelease(v53);
    }

    else
    {
      v57 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v57, OS_LOG_TYPE_FAULT)) {
        sub_100084DBC();
      }
      if (qword_1000E7D38) {
        v58 = (FILE *)qword_1000E7D38;
      }
      else {
        v58 = __stderrp;
      }
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v58);
    }

    *__error() = v51;
  }

  __int16 v60 = *v36;
  if ((*v36 & 0x20) != 0 || (int v61 = v60 & 0x80 | word_1000E7D70 & 0x40) != 0) {
    LOWORD(v61) = 256;
  }
  __int16 *v36 = v61 | v60 & 0xFEFF;
  if (byte_1000E7D30)
  {
    int v62 = *__error();
    v63 = (os_log_s *)sub_10002EFA0();
    if (os_log_type_enabled(v63, OS_LOG_TYPE_INFO))
    {
      unsigned int v64 = (unsigned __int16)*v36;
      *(_DWORD *)buf = 67110144;
      int v189 = a1;
      __int16 v190 = 1024;
      int v191 = (v64 >> 8) & 1;
      __int16 v192 = 1024;
      int v193 = (v64 >> 5) & 1;
      __int16 v194 = 1024;
      int v195 = ((unsigned __int16)word_1000E7D70 >> 6) & 1;
      __int16 v196 = 1024;
      int v197 = (v64 >> 7) & 1;
      _os_log_impl( (void *)&_mh_execute_header,  v63,  OS_LOG_TYPE_INFO,  "UID %d: Gather samples for hangs:%d due to present:%d submit:%d user requested:%d",  buf,  0x20u);
    }

    *__error() = v62;
  }

  if (byte_1000E7D31 && dword_1000E74E0 <= 1)
  {
    int v65 = *__error();
    v66 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"UID %d: Gather samples for hangs:%d due to present:%d submit:%d user requested:%d",  a1,  HIBYTE(*v36) & 1,  ((unsigned __int16)*v36 >> 5) & 1,  ((unsigned __int16)word_1000E7D70 >> 6) & 1,  ((unsigned __int16)*v36 >> 7) & 1);
    if (v66)
    {
      v67 = v66;
      v68 = CFStringGetCStringPtr(v66, 0x8000100u);
      if (v68)
      {
        v69 = (char *)v68;
        v70 = 0LL;
      }

      else
      {
        v69 = (char *)calloc(0x400uLL, 1uLL);
        CFStringGetCString(v67, v69, 1024LL, 0x8000100u);
        v70 = v69;
      }

      if (qword_1000E7D38) {
        v73 = (FILE *)qword_1000E7D38;
      }
      else {
        v73 = __stderrp;
      }
      fprintf(v73, "%s\n", v69);
      if (v70) {
        free(v70);
      }
      CFRelease(v67);
    }

    else
    {
      v71 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v71, OS_LOG_TYPE_FAULT)) {
        sub_100084D40();
      }
      if (qword_1000E7D38) {
        v72 = (FILE *)qword_1000E7D38;
      }
      else {
        v72 = __stderrp;
      }
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v72);
    }

    *__error() = v65;
  }

  __int16 *v36 = *v36 & 0xFDFF | (((word_1000E7D70 & 0x20 | *v36 & 0x40) != 0) << 9);
  if (byte_1000E7D30)
  {
    int v74 = *__error();
    v75 = (os_log_s *)sub_10002EFA0();
    if (os_log_type_enabled(v75, OS_LOG_TYPE_INFO))
    {
      unsigned int v76 = (unsigned __int16)*v36;
      *(_DWORD *)buf = 67109888;
      int v189 = a1;
      __int16 v190 = 1024;
      int v191 = (v76 >> 9) & 1;
      __int16 v192 = 1024;
      int v193 = ((unsigned __int16)word_1000E7D70 >> 5) & 1;
      __int16 v194 = 1024;
      int v195 = (v76 >> 6) & 1;
      _os_log_impl( (void *)&_mh_execute_header,  v75,  OS_LOG_TYPE_INFO,  "UID %d: Gather samples for spins:%d due to submit:%d user requested:%d",  buf,  0x1Au);
    }

    *__error() = v74;
  }

  if (byte_1000E7D31 && dword_1000E74E0 <= 1)
  {
    int v77 = *__error();
    v78 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"UID %d: Gather samples for spins:%d due to submit:%d user requested:%d",  a1,  ((unsigned __int16)*v36 >> 9) & 1,  ((unsigned __int16)word_1000E7D70 >> 5) & 1,  ((unsigned __int16)*v36 >> 6) & 1);
    if (v78)
    {
      v79 = v78;
      v80 = CFStringGetCStringPtr(v78, 0x8000100u);
      if (v80)
      {
        v81 = (char *)v80;
        v82 = 0LL;
      }

      else
      {
        v81 = (char *)calloc(0x400uLL, 1uLL);
        CFStringGetCString(v79, v81, 1024LL, 0x8000100u);
        v82 = v81;
      }

      if (qword_1000E7D38) {
        v85 = (FILE *)qword_1000E7D38;
      }
      else {
        v85 = __stderrp;
      }
      fprintf(v85, "%s\n", v81);
      if (v82) {
        free(v82);
      }
      CFRelease(v79);
    }

    else
    {
      v83 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v83, OS_LOG_TYPE_FAULT)) {
        sub_100084CB4();
      }
      if (qword_1000E7D38) {
        v84 = (FILE *)qword_1000E7D38;
      }
      else {
        v84 = __stderrp;
      }
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v84);
    }

    *__error() = v77;
  }

  if ((word_1000E7D70 & 1) != 0)
  {
    __int16 v87 = *v36;
    __int16 v86 = ((word_1000E7D70 & 0x20 | *v36 & 0x40) != 0) << 10;
  }

  else
  {
    __int16 v86 = 0;
    __int16 v87 = *v36;
  }

  __int16 *v36 = v87 & 0xFBFF | v86;
  if (byte_1000E7D30)
  {
    int v88 = *__error();
    v89 = (os_log_s *)sub_10002EFA0();
    if (os_log_type_enabled(v89, OS_LOG_TYPE_INFO))
    {
      unsigned int v90 = (unsigned __int16)*v36;
      *(_DWORD *)buf = 67110144;
      int v189 = a1;
      __int16 v190 = 1024;
      int v191 = (v90 >> 10) & 1;
      __int16 v192 = 1024;
      int v193 = word_1000E7D70 & 1;
      __int16 v194 = 1024;
      int v195 = ((unsigned __int16)word_1000E7D70 >> 5) & 1;
      __int16 v196 = 1024;
      int v197 = (v90 >> 6) & 1;
      _os_log_impl( (void *)&_mh_execute_header,  v89,  OS_LOG_TYPE_INFO,  "UID %d: Gather samples for stuck apps:%d due to internal:%d submit:%d user requested:%d",  buf,  0x20u);
    }

    *__error() = v88;
  }

  if (byte_1000E7D31 && dword_1000E74E0 <= 1)
  {
    int v91 = *__error();
    v92 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"UID %d: Gather samples for stuck apps:%d due to internal:%d submit:%d user requested:%d",  a1,  ((unsigned __int16)*v36 >> 10) & 1,  word_1000E7D70 & 1,  ((unsigned __int16)word_1000E7D70 >> 5) & 1,  ((unsigned __int16)*v36 >> 6) & 1);
    if (v92)
    {
      v93 = v92;
      v94 = CFStringGetCStringPtr(v92, 0x8000100u);
      if (v94)
      {
        v95 = (char *)v94;
        v96 = 0LL;
      }

      else
      {
        v95 = (char *)calloc(0x400uLL, 1uLL);
        CFStringGetCString(v93, v95, 1024LL, 0x8000100u);
        v96 = v95;
      }

      if (qword_1000E7D38) {
        v99 = (FILE *)qword_1000E7D38;
      }
      else {
        v99 = __stderrp;
      }
      fprintf(v99, "%s\n", v95);
      if (v96) {
        free(v96);
      }
      CFRelease(v93);
    }

    else
    {
      v97 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v97, OS_LOG_TYPE_FAULT)) {
        sub_100084C38();
      }
      if (qword_1000E7D38) {
        v98 = (FILE *)qword_1000E7D38;
      }
      else {
        v98 = __stderrp;
      }
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v98);
    }

    *__error() = v91;
  }

  __int16 *v36 = *v36 & 0xF7FF | ((unsigned __int16)word_1000E7D70 >> 1) & 0x800;
  if (byte_1000E7D30)
  {
    int v100 = *__error();
    v101 = (os_log_s *)sub_10002EFA0();
    if (os_log_type_enabled(v101, OS_LOG_TYPE_INFO))
    {
      int v102 = ((unsigned __int16)*v36 >> 11) & 1;
      *(_DWORD *)buf = 67109632;
      int v189 = a1;
      __int16 v190 = 1024;
      int v191 = v102;
      __int16 v192 = 1024;
      int v193 = ((unsigned __int16)word_1000E7D70 >> 12) & 1;
      _os_log_impl( (void *)&_mh_execute_header,  v101,  OS_LOG_TYPE_INFO,  "UID %d: Gather samples for service watchdog:%d due to submit:%d",  buf,  0x14u);
    }

    *__error() = v100;
  }

  if (byte_1000E7D31 && dword_1000E74E0 <= 1)
  {
    int v103 = *__error();
    v104 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"UID %d: Gather samples for service watchdog:%d due to submit:%d",  a1,  ((unsigned __int16)*v36 >> 11) & 1,  ((unsigned __int16)word_1000E7D70 >> 12) & 1);
    if (v104)
    {
      v105 = v104;
      v106 = CFStringGetCStringPtr(v104, 0x8000100u);
      if (v106)
      {
        v107 = (char *)v106;
        v108 = 0LL;
      }

      else
      {
        v107 = (char *)calloc(0x400uLL, 1uLL);
        CFStringGetCString(v105, v107, 1024LL, 0x8000100u);
        v108 = v107;
      }

      if (qword_1000E7D38) {
        v111 = (FILE *)qword_1000E7D38;
      }
      else {
        v111 = __stderrp;
      }
      fprintf(v111, "%s\n", v107);
      if (v108) {
        free(v108);
      }
      CFRelease(v105);
    }

    else
    {
      v109 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v109, OS_LOG_TYPE_FAULT)) {
        sub_100084BA8();
      }
      if (qword_1000E7D38) {
        v110 = (FILE *)qword_1000E7D38;
      }
      else {
        v110 = __stderrp;
      }
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v110);
    }

    *__error() = v103;
  }

  __int16 *v36 = (*v36 << 12) & (*v36 << 11) & 0x1000 | *v36 & 0xEFFF;
  if (byte_1000E7D30)
  {
    int v112 = *__error();
    v113 = (os_log_s *)sub_10002EFA0();
    if (os_log_type_enabled(v113, OS_LOG_TYPE_INFO))
    {
      unsigned int v114 = (unsigned __int16)*v36;
      *(_DWORD *)buf = 67109888;
      int v189 = a1;
      __int16 v190 = 1024;
      int v191 = (v114 >> 12) & 1;
      __int16 v192 = 1024;
      int v193 = v114 & 1;
      __int16 v194 = 1024;
      int v195 = (v114 >> 1) & 1;
      _os_log_impl( (void *)&_mh_execute_header,  v113,  OS_LOG_TYPE_INFO,  "UID %d: Don't throttle short spin reports:%d due to pref isset:%d value:%d",  buf,  0x1Au);
    }

    *__error() = v112;
  }

  if (byte_1000E7D31 && dword_1000E74E0 <= 1)
  {
    int v115 = *__error();
    v116 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"UID %d: Don't throttle short spin reports:%d due to pref isset:%d value:%d",  a1,  ((unsigned __int16)*v36 >> 12) & 1,  *v36 & 1,  ((unsigned __int16)*v36 >> 1) & 1);
    if (v116)
    {
      v117 = v116;
      v118 = CFStringGetCStringPtr(v116, 0x8000100u);
      if (v118)
      {
        v119 = (char *)v118;
        v120 = 0LL;
      }

      else
      {
        v119 = (char *)calloc(0x400uLL, 1uLL);
        CFStringGetCString(v117, v119, 1024LL, 0x8000100u);
        v120 = v119;
      }

      if (qword_1000E7D38) {
        v123 = (FILE *)qword_1000E7D38;
      }
      else {
        v123 = __stderrp;
      }
      fprintf(v123, "%s\n", v119);
      if (v120) {
        free(v120);
      }
      CFRelease(v117);
    }

    else
    {
      v121 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v121, OS_LOG_TYPE_FAULT)) {
        sub_100084B38();
      }
      if (qword_1000E7D38) {
        v122 = (FILE *)qword_1000E7D38;
      }
      else {
        v122 = __stderrp;
      }
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v122);
    }

    *__error() = v115;
  }

  os_unfair_lock_unlock((os_unfair_lock_t)&unk_1000E7BF0);
  return v22;
}

BOOL sub_10002578C(pid_t a1)
{
  return !a1 || kill(a1, 0) == 0;
}

uint64_t sub_1000257B8()
{
  if (qword_1000E7C80 != -1) {
    dispatch_once(&qword_1000E7C80, &stru_1000D9748);
  }
  if (qword_1000E74F0)
  {
    int v16 = 0;
    size_t v15 = 4LL;
    if (sysctl(dword_1000E7C6C, qword_1000E74F0, &v16, &v15, 0LL, 0LL))
    {
      int v1 = *__error();
      v2 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
        sub_10008DE4C();
      }
      *__error() = v1;
      if (byte_1000E7D31 && dword_1000E74E0 <= 4)
      {
        int v3 = *__error();
        uint64_t v4 = *__error();
        uint64_t v5 = __error();
        uint64_t v6 = strerror(*v5);
        uint64_t v7 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"sysctl for security.mac.sandbox.audio_active failed: %d (%s)",  v4,  v6);
        if (v7)
        {
          theString = v7;
          CStringPtr = CFStringGetCStringPtr(v7, 0x8000100u);
          if (CStringPtr)
          {
            uint64_t v9 = (char *)CStringPtr;
            uint64_t v10 = 0LL;
          }

          else
          {
            uint64_t v9 = (char *)calloc(0x400uLL, 1uLL);
            CFStringGetCString(theString, v9, 1024LL, 0x8000100u);
            uint64_t v10 = v9;
          }

          if (qword_1000E7D38) {
            uint64_t v13 = (FILE *)qword_1000E7D38;
          }
          else {
            uint64_t v13 = __stderrp;
          }
          fprintf(v13, "%s\n", v9);
          if (v10) {
            free(v10);
          }
          CFRelease(theString);
        }

        else
        {
          uint64_t v11 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v11, OS_LOG_TYPE_FAULT)) {
            sub_10008DDDC();
          }
          if (qword_1000E7D38) {
            uint64_t v12 = (FILE *)qword_1000E7D38;
          }
          else {
            uint64_t v12 = __stderrp;
          }
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v12);
        }

        *__error() = v3;
      }

      qword_1000E74F0 = 0LL;
    }

    else if (v16)
    {
      return 1LL;
    }
  }

  return 0LL;
}

void sub_1000259E4(id a1)
{
  if (sysctlnametomib("security.mac.sandbox.audio_active", dword_1000E7C6C, (size_t *)&qword_1000E74F0))
  {
    int v1 = *__error();
    v2 = (os_log_s *)sub_10002EFA0();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      sub_10008E014();
    }
    *__error() = v1;
    if (byte_1000E7D31) {
      BOOL v3 = dword_1000E74E0 <= 4;
    }
    else {
      BOOL v3 = 0;
    }
    if (v3)
    {
      int v15 = *__error();
      uint64_t v4 = *__error();
      uint64_t v5 = __error();
      uint64_t v6 = strerror(*v5);
      uint64_t v7 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"sysctlnametomib for security.mac.sandbox.audio_active failed: %d (%s)",  v4,  v6);
      if (v7)
      {
        theString = v7;
        CStringPtr = CFStringGetCStringPtr(v7, 0x8000100u);
        if (CStringPtr)
        {
          uint64_t v9 = (char *)CStringPtr;
          uint64_t v10 = 0LL;
        }

        else
        {
          uint64_t v9 = (char *)calloc(0x400uLL, 1uLL);
          CFStringGetCString(theString, v9, 1024LL, 0x8000100u);
          uint64_t v10 = v9;
        }

        if (qword_1000E7D38) {
          uint64_t v13 = (FILE *)qword_1000E7D38;
        }
        else {
          uint64_t v13 = __stderrp;
        }
        fprintf(v13, "%s\n", v9);
        if (v10) {
          free(v10);
        }
        CFRelease(theString);
      }

      else
      {
        uint64_t v11 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v11, OS_LOG_TYPE_FAULT)) {
          sub_10008DFA4();
        }
        if (qword_1000E7D38) {
          uint64_t v12 = (FILE *)qword_1000E7D38;
        }
        else {
          uint64_t v12 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v12);
      }

      *__error() = v15;
    }

    qword_1000E74F0 = 0LL;
  }
}

  ;
}

  ;
}

void sub_100025BC0(uint64_t a1, xpc_object_t object)
{
  if (xpc_get_type(object) == (xpc_type_t)&_xpc_type_error)
  {
    if (byte_1000E7D30)
    {
      int v9 = *__error();
      uint64_t v10 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG)) {
        sub_100086134(object);
      }
      *__error() = v9;
    }

    if (byte_1000E7D31) {
      BOOL v11 = dword_1000E74E0 <= 0;
    }
    else {
      BOOL v11 = 0;
    }
    if (v11)
    {
      int v12 = *__error();
      string = xpc_dictionary_get_string(object, _xpc_error_key_description);
      id v14 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"Got xpc error for peer: %s", string);
      if (v14)
      {
        int v15 = v14;
        CStringPtr = CFStringGetCStringPtr(v14, 0x8000100u);
        if (CStringPtr)
        {
          BOOL v17 = (char *)CStringPtr;
          uint64_t v18 = 0LL;
        }

        else
        {
          BOOL v17 = (char *)calloc(0x400uLL, 1uLL);
          CFStringGetCString(v15, v17, 1024LL, 0x8000100u);
          uint64_t v18 = v17;
        }

        if (qword_1000E7D38) {
          uint64_t v21 = (FILE *)qword_1000E7D38;
        }
        else {
          uint64_t v21 = __stderrp;
        }
        fprintf(v21, "%s\n", v17);
        if (v18) {
          free(v18);
        }
        CFRelease(v15);
      }

      else
      {
        uint64_t v19 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v19, OS_LOG_TYPE_FAULT)) {
          sub_1000860C0(object, _xpc_error_key_description, v19);
        }
        if (qword_1000E7D38) {
          uint64_t v20 = (FILE *)qword_1000E7D38;
        }
        else {
          uint64_t v20 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v20);
      }

      *__error() = v12;
    }
  }

  else if (xpc_get_type(object) == (xpc_type_t)&_xpc_type_connection)
  {
    pid_t pid = xpc_connection_get_pid((xpc_connection_t)object);
    uid_t euid = xpc_connection_get_euid((xpc_connection_t)object);
    uint64_t v6 = (void *)xpc_connection_copy_entitlement_value(object, "com.apple.private.spindump.generatespindump");
    if (v6)
    {
      uint64_t v7 = v6;
      BOOL v8 = xpc_get_type(v6) == (xpc_type_t)&_xpc_type_BOOL && xpc_BOOL_get_value(v7);
      xpc_release(v7);
    }

    else
    {
      BOOL v8 = 0;
    }

    xpc_connection_set_target_queue((xpc_connection_t)object, *(dispatch_queue_t *)(a1 + 32));
    handler[0] = _NSConcreteStackBlock;
    handler[1] = 3221225472LL;
    handler[2] = sub_100048108;
    handler[3] = &unk_1000D9128;
    pid_t v23 = pid;
    uid_t v24 = euid;
    BOOL v25 = v8;
    __int16 v26 = 0;
    char v27 = 0;
    xpc_connection_set_event_handler((xpc_connection_t)object, handler);
    xpc_connection_resume((xpc_connection_t)object);
  }

size_t sub_100025E98(char *a1, size_t a2, int a3, double a4)
{
  size_t result = 0LL;
  if (a1 && a2)
  {
    time_t v16 = (uint64_t)(kCFAbsoluteTimeIntervalSince1970 + a4);
    localtime_r(&v16, &v17);
    size_t result = strftime(a1, a2, "%Y-%m-%d %T", &v17);
    if (result)
    {
      size_t v9 = result;
      uint64_t v10 = &a1[result];
      size_t v11 = a2 - result;
      if (a3)
      {
        double v12 = fmod(a4, 1.0);
        if (v12 > 0.0)
        {
          snprintf(&__str, 0x10uLL, "%f", v12);
          size_t v13 = strlcpy(v10, v19, v11);
          BOOL v14 = v11 > v13;
          v11 -= v13;
          if (!v14) {
            return a2 - 1;
          }
          v9 += v13;
          v10 += v13;
        }
      }

      size_t v15 = strftime(v10, v11, " %z", &v17);
      if (!v15) {
        v10[v9] = 0;
      }
      return v15 + v9;
    }

    else
    {
      *a1 = 0;
    }
  }

  return result;
}

const char *sub_100025FEC(unsigned int a1, int a2)
{
  v2 = "hang";
  if (a2) {
    v2 = "hang-lite";
  }
  if (a1 <= 0xE)
  {
    BOOL v3 = &off_1000D9320;
    if (a2) {
      BOOL v3 = &off_1000D92A8;
    }
    return v3[a1];
  }

  return v2;
}

void sub_100026030( uint64_t a1, NSString *a2, uint64_t a3, uint64_t a4, uint64_t a5, double a6, double a7, double a8, double a9, double a10)
{
  if ((a1 & 0x80000000) == 0)
  {
    if (byte_1000E7D30)
    {
      int v20 = *__error();
      uint64_t v21 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v21, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)buf = 136447490;
        uint64_t v149 = sub_10002EF3C(a1);
        __int16 v150 = 1024;
        *(_DWORD *)v151 = a1;
        *(_WORD *)&v151[4] = 2048;
        *(void *)&v151[6] = a3;
        *(_WORD *)&v151[14] = 2048;
        *(double *)&v151[16] = a6;
        *(_WORD *)&v151[24] = 2048;
        *(double *)&v151[26] = a7;
        __int16 v152 = 2048;
        uint64_t v153 = a4;
        _os_log_impl( (void *)&_mh_execute_header,  v21,  OS_LOG_TYPE_INFO,  "%{public}s [%d]: cpu resource: thread %#llx using %.0fs cpu over the last %.0f seconds with flags %#llx",  buf,  0x3Au);
      }

      *__error() = v20;
    }

    if (byte_1000E7D31) {
      BOOL v22 = dword_1000E74E0 <= 1;
    }
    else {
      BOOL v22 = 0;
    }
    if (!v22) {
      goto LABEL_52;
    }
    int v23 = *__error();
    uid_t v24 = sub_10002EF3C(a1);
    BOOL v25 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"%s [%d]: cpu resource: thread %#llx using %.0fs cpu over the last %.0f seconds with flags %#llx",  v24,  a1,  a3,  *(void *)&a6,  *(void *)&a7,  a4);
    if (v25)
    {
      __int16 v26 = v25;
      CStringPtr = CFStringGetCStringPtr(v25, 0x8000100u);
      if (CStringPtr)
      {
        int v28 = (char *)CStringPtr;
        v29 = 0LL;
      }

      else
      {
        int v28 = (char *)calloc(0x400uLL, 1uLL);
        CFStringGetCString(v26, v28, 1024LL, 0x8000100u);
        v29 = v28;
      }

      if (qword_1000E7D38) {
        unsigned int v39 = (FILE *)qword_1000E7D38;
      }
      else {
        unsigned int v39 = __stderrp;
      }
      fprintf(v39, "%s\n", v28);
      if (v29) {
        free(v29);
      }
LABEL_50:
      CFRelease(v26);
      goto LABEL_51;
    }

    int v37 = (os_log_s *)sub_10002EFA0();
    if (os_log_type_enabled(v37, OS_LOG_TYPE_FAULT))
    {
      uint64_t v135 = sub_10002EF3C(a1);
      *(_DWORD *)buf = 136316418;
      uint64_t v149 = v135;
      __int16 v150 = 1024;
      *(_DWORD *)v151 = a1;
      *(_WORD *)&v151[4] = 2048;
      *(void *)&v151[6] = a3;
      *(_WORD *)&v151[14] = 2048;
      *(double *)&v151[16] = a6;
      *(_WORD *)&v151[24] = 2048;
      *(double *)&v151[26] = a7;
      __int16 v152 = 2048;
      uint64_t v153 = a4;
      _os_log_fault_impl( (void *)&_mh_execute_header,  v37,  OS_LOG_TYPE_FAULT,  "Unable to format: %s [%d]: cpu resource: thread %#llx using %.0fs cpu over the last %.0f seconds with flags %#llx",  buf,  0x3Au);
    }

    if (qword_1000E7D38) {
      v38 = (FILE *)qword_1000E7D38;
    }
    else {
      v38 = __stderrp;
    }
    goto LABEL_31;
  }

  if (byte_1000E7D30)
  {
    int v30 = *__error();
    v31 = (os_log_s *)sub_10002EFA0();
    if (os_log_type_enabled(v31, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 134218752;
      uint64_t v149 = (_DWORD *)a3;
      __int16 v150 = 2048;
      *(double *)v151 = a6;
      *(_WORD *)&v151[8] = 2048;
      *(double *)&v151[10] = a7;
      *(_WORD *)&v151[18] = 2048;
      *(void *)&v151[20] = a4;
      _os_log_impl( (void *)&_mh_execute_header,  v31,  OS_LOG_TYPE_INFO,  "cpu resource: thread %#llx using %.0fs cpu over the last %.0f seconds with flags %#llx",  buf,  0x2Au);
    }

    *__error() = v30;
  }

  if (byte_1000E7D31) {
    BOOL v32 = dword_1000E74E0 <= 1;
  }
  else {
    BOOL v32 = 0;
  }
  if (v32)
  {
    int v23 = *__error();
    int v33 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"cpu resource: thread %#llx using %.0fs cpu over the last %.0f seconds with flags %#llx",  a3,  *(void *)&a6,  *(void *)&a7,  a4);
    if (v33)
    {
      __int16 v26 = v33;
      v34 = CFStringGetCStringPtr(v33, 0x8000100u);
      if (v34)
      {
        __int16 v35 = (char *)v34;
        v36 = 0LL;
      }

      else
      {
        __int16 v35 = (char *)calloc(0x400uLL, 1uLL);
        CFStringGetCString(v26, v35, 1024LL, 0x8000100u);
        v36 = v35;
      }

      if (qword_1000E7D38) {
        v41 = (FILE *)qword_1000E7D38;
      }
      else {
        v41 = __stderrp;
      }
      fprintf(v41, "%s\n", v35);
      if (v36) {
        free(v36);
      }
      goto LABEL_50;
    }

    int v40 = (os_log_s *)sub_10002EFA0();
    if (os_log_type_enabled(v40, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 134218752;
      uint64_t v149 = (_DWORD *)a3;
      __int16 v150 = 2048;
      *(double *)v151 = a6;
      *(_WORD *)&v151[8] = 2048;
      *(double *)&v151[10] = a7;
      *(_WORD *)&v151[18] = 2048;
      *(void *)&v151[20] = a4;
      _os_log_fault_impl( (void *)&_mh_execute_header,  v40,  OS_LOG_TYPE_FAULT,  "Unable to format: cpu resource: thread %#llx using %.0fs cpu over the last %.0f seconds with flags %#llx",  buf,  0x2Au);
    }

    if (qword_1000E7D38) {
      v38 = (FILE *)qword_1000E7D38;
    }
    else {
      v38 = __stderrp;
    }
LABEL_31:
    fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v38);
LABEL_51:
    *__error() = v23;
  }

LABEL_52:
  uint64_t v144 = sub_10002F014(a1);
  if (!a2) {
    a2 = sub_10002F04C(a1);
  }
  uint64_t v147 = 0LL;
  uint64_t v42 = sub_1000409B4(a1, (uint64_t)"cpu resource", 160, &v147);
  if ((word_1000E7D70 & 0x80) == 0)
  {
    if ((a1 & 0x80000000) != 0)
    {
      if (byte_1000E7D30)
      {
        int v49 = *__error();
        v50 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v50, OS_LOG_TYPE_DEBUG)) {
          sub_100082BE4();
        }
        *__error() = v49;
      }

      if (!byte_1000E7D31 || dword_1000E74E0 > 0) {
        goto LABEL_88;
      }
      int v45 = *__error();
      v47 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"cpu resource: not monitoring due to suppression cookie file");
      if (!v47)
      {
        v57 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v57, OS_LOG_TYPE_FAULT)) {
          sub_100082BB8();
        }
        goto LABEL_83;
      }
    }

    else
    {
      if (byte_1000E7D30)
      {
        int v43 = *__error();
        v44 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v44, OS_LOG_TYPE_DEBUG)) {
          sub_100082B50();
        }
        *__error() = v43;
      }

      if (!byte_1000E7D31 || dword_1000E74E0 > 0) {
        goto LABEL_88;
      }
      int v45 = *__error();
      v46 = sub_10002EF3C(a1);
      v47 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"%s [%d]: cpu resource: not monitoring due to suppression cookie file",  v46,  a1);
      if (!v47)
      {
        v48 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v48, OS_LOG_TYPE_FAULT)) {
          sub_100082AE8();
        }
LABEL_83:
        if (qword_1000E7D38) {
          v58 = (FILE *)qword_1000E7D38;
        }
        else {
          v58 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v58);
LABEL_87:
        *__error() = v45;
LABEL_88:
        v42 |= 0x8000uLL;
        goto LABEL_89;
      }
    }

    int v51 = v47;
    uint64_t v140 = a5;
    int v141 = a2;
    uint64_t v52 = a4;
    v53 = CFStringGetCStringPtr(v47, 0x8000100u);
    if (v53)
    {
      v54 = (char *)v53;
      v55 = 0LL;
    }

    else
    {
      v54 = (char *)calloc(0x400uLL, 1uLL);
      CFStringGetCString(v51, v54, 1024LL, 0x8000100u);
      v55 = v54;
    }

    if (qword_1000E7D38) {
      v56 = (FILE *)qword_1000E7D38;
    }
    else {
      v56 = __stderrp;
    }
    fprintf(v56, "%s\n", v54);
    if (v55) {
      free(v55);
    }
    CFRelease(v51);
    a4 = v52;
    a5 = v140;
    a2 = v141;
    goto LABEL_87;
  }

  if (*(void *)(a1 + 40)) {
    objc_msgSend(a2, "setReason:", +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:"));
  }
  if (*(void *)(a1 + 48)) {
    objc_msgSend( a2,  "setSignature:",  +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:"));
  }
  BOOL v32 = *(void *)(a1 + 56);
  if ((v32 & 1) != 0)
  {
    objc_msgSend(objc_msgSend(a2, "printOptions"), "setPrintHeavyStacks:", 1);
    BOOL v32 = *(void *)(a1 + 56);
  }

  [a2 setIncludeTextualFormatInReport:(v32 & 2) == 0];
  [a2 setIncludeBinaryFormatInReport:(*(void *)(a1 + 56) & 4) == 0];
  int v33 = *(void *)(a1 + 56);
  if ((v33 & 0x10) != 0)
  {
    [a2 setShouldSymbolicate:1];
    [a2 setShouldUseBulkSymbolication:0];
    int v33 = *(void *)(a1 + 56);
  }

  if ((v33 & 8) != 0)
  {
    [a2 setShouldSymbolicate:0];
    [a2 setShouldUseBulkSymbolication:0];
  }

  v34 = (uint64_t *)(a1 + 64);
  __int16 v35 = *(const char **)(a1 + 64);
  v36 = geteuid();
  int v37 = sub_10002C4A8(v35, 536872449, v36, 0x1A4u);
  if ((v37 & 0x80000000) == 0)
  {
    v38 = fdopen(v37, "w");
    if (v38)
    {
      unsigned int v39 = v38;
      [a2 saveReportToStream:v38];
      fclose(v39);
      if (*v6 < 0)
      {
        if (byte_1000E7D30)
        {
          v81 = *__error();
          uint64_t v82 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v82, OS_LOG_TYPE_DEFAULT))
          {
            int v83 = sub_10002EF3C(*(_DWORD *)(a1 + 76));
            v84 = *(_DWORD *)(a1 + 76);
            int v85 = *(_DWORD **)(a1 + 64);
            *(_DWORD *)buf = 136446722;
            int v124 = v83;
            v125 = 1024;
            uint64_t v126 = v84;
            double v127 = 2080;
            char v128 = v85;
            _os_log_impl( (void *)&_mh_execute_header,  v82,  OS_LOG_TYPE_DEFAULT,  "generate spindump: saved report (requested by %{public}s [%d]) to %s",  buf,  0x1Cu);
          }

          *__error() = v81;
        }

        if (!byte_1000E7D31 || dword_1000E74E0 > 2) {
          goto LABEL_144;
        }
        v47 = *__error();
        __int16 v86 = sub_10002EF3C(*(_DWORD *)(a1 + 76));
        int v51 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"generate spindump: saved report (requested by %s [%d]) to %s",  v86,  *(unsigned int *)(a1 + 76),  *(void *)(a1 + 64));
        if (!v51)
        {
          int v113 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v113, OS_LOG_TYPE_FAULT)) {
            sub_100081DB0();
          }
          goto LABEL_139;
        }
      }

      else
      {
        if (byte_1000E7D30)
        {
          int v40 = *__error();
          v41 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v41, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v42 = sub_10002EF3C(*(_DWORD *)(a1 + 72));
            int v43 = *(_DWORD *)(a1 + 72);
            v44 = sub_10002EF3C(*(_DWORD *)(a1 + 76));
            int v45 = *(_DWORD *)(a1 + 76);
            v46 = *(void *)(a1 + 64);
            *(_DWORD *)buf = 136447234;
            int v124 = v42;
            v125 = 1024;
            uint64_t v126 = v43;
            double v127 = 2082;
            char v128 = v44;
            int v129 = 1024;
            v130 = v45;
            uint64_t v131 = 2080;
            uint64_t v132 = v46;
            _os_log_impl( (void *)&_mh_execute_header,  v41,  OS_LOG_TYPE_DEFAULT,  "%{public}s [%d]: generate spindump: saved report (requested by %{public}s [%d]) to %s",  buf,  0x2Cu);
          }

          *__error() = v40;
        }

        if (!byte_1000E7D31 || dword_1000E74E0 > 2) {
          goto LABEL_144;
        }
        v47 = *__error();
        v48 = sub_10002EF3C(*(_DWORD *)(a1 + 72));
        int v49 = *(unsigned int *)(a1 + 72);
        v50 = sub_10002EF3C(*(_DWORD *)(a1 + 76));
        int v51 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"%s [%d]: generate spindump: saved report (requested by %s [%d]) to %s",  v48,  v49,  v50,  *(unsigned int *)(a1 + 76),  *(void *)(a1 + 64));
        if (!v51)
        {
          uint64_t v52 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v52, OS_LOG_TYPE_FAULT))
          {
            v53 = sub_10002EF3C(*(_DWORD *)(a1 + 72));
            v54 = *(_DWORD *)(a1 + 72);
            v55 = sub_10002EF3C(*(_DWORD *)(a1 + 76));
            v56 = *(_DWORD *)(a1 + 76);
            v57 = *(void *)(a1 + 64);
            *(_DWORD *)buf = 136316162;
            int v124 = v53;
            v125 = 1024;
            uint64_t v126 = v54;
            double v127 = 2080;
            char v128 = v55;
            int v129 = 1024;
            v130 = v56;
            uint64_t v131 = 2080;
            uint64_t v132 = v57;
            _os_log_fault_impl( (void *)&_mh_execute_header,  v52,  OS_LOG_TYPE_FAULT,  "Unable to format: %s [%d]: generate spindump: saved report (requested by %s [%d]) to %s",  buf,  0x2Cu);
          }

  uint64_t v145 = sub_10002F014(a1);
  if (!a2) {
    a2 = sub_10002F04C(a1);
  }
  uint64_t v42 = a2;
  uint64_t v148 = 0LL;
  int v43 = sub_1000409B4(a1, (uint64_t)"disk writes", 160, &v148);
  if ((word_1000E7D70 & 0x100) == 0)
  {
    if ((a1 & 0x80000000) != 0)
    {
      if (byte_1000E7D30)
      {
        v50 = *__error();
        int v51 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v51, OS_LOG_TYPE_DEBUG)) {
          sub_100083E10();
        }
        *__error() = v50;
      }

      if (!byte_1000E7D31 || dword_1000E74E0 > 0) {
        goto LABEL_88;
      }
      uint64_t v142 = a6;
      uint64_t v143 = v42;
      v46 = *__error();
      v48 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"disk writes: not monitoring due to suppression cookie file");
      if (!v48)
      {
        int v59 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v59, OS_LOG_TYPE_FAULT)) {
          sub_100083DE4();
        }
        goto LABEL_83;
      }
    }

    else
    {
      if (byte_1000E7D30)
      {
        v44 = *__error();
        int v45 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v45, OS_LOG_TYPE_DEBUG)) {
          sub_100083D7C();
        }
        *__error() = v44;
      }

      if (!byte_1000E7D31 || dword_1000E74E0 > 0) {
        goto LABEL_88;
      }
      uint64_t v142 = a6;
      uint64_t v143 = v42;
      v46 = *__error();
      v47 = sub_10002EF3C(a1);
      v48 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"%s [%d]: disk writes: not monitoring due to suppression cookie file",  v47,  a1);
      if (!v48)
      {
        int v49 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v49, OS_LOG_TYPE_FAULT)) {
          sub_100083D14();
        }
LABEL_83:
        if (qword_1000E7D38) {
          __int16 v60 = (FILE *)qword_1000E7D38;
        }
        else {
          __int16 v60 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v60);
LABEL_87:
        *__error() = v46;
        a6 = v142;
        uint64_t v42 = v143;
LABEL_88:
        v43 |= 0x8000uLL;
        goto LABEL_89;
      }
    }

    uint64_t v52 = v48;
    v53 = a3;
    v54 = a5;
    v55 = CFStringGetCStringPtr(v48, 0x8000100u);
    if (v55)
    {
      v56 = (char *)v55;
      v57 = 0LL;
    }

    else
    {
      v56 = (char *)calloc(0x400uLL, 1uLL);
      CFStringGetCString(v52, v56, 1024LL, 0x8000100u);
      v57 = v56;
    }

    if (qword_1000E7D38) {
      v58 = (FILE *)qword_1000E7D38;
    }
    else {
      v58 = __stderrp;
    }
    fprintf(v58, "%s\n", v56);
    if (v57) {
      free(v57);
    }
    CFRelease(v52);
    a5 = v54;
    a3 = v53;
    goto LABEL_87;
  }

  if (!self->super.super._hasSampled || self->super.super._isSampling)
  {
    if (self->_samplingMode != v5
      || v4 && (!self->_sampledProcesses || (objc_msgSend(v4, "isSubsetOfSet:") & 1) == 0))
    {
      self->_samplingMode = v5;
      sampledProcesses = self->_sampledProcesses;
      if (v5 == 3)
      {

        self->_sampledProcesses = 0LL;
      }

      else
      {
        if (!sampledProcesses)
        {
          int v33 = objc_alloc_init(&OBJC_CLASS___NSMutableSet);
          self->_sampledProcesses = v33;
          if ((self->super.super._targetProcessId & 0x80000000) == 0) {
            -[NSMutableSet addObject:]( v33,  "addObject:",  +[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:"));
          }
        }

        if (v4) {
          -[NSMutableSet unionSet:](self->_sampledProcesses, "unionSet:", v4);
        }
      }

      if (self->super.super._isSampling) {
        -[SPStackshotProvider sampleProcesses:onlyMainThreads:]( self->super.super._sampleProvider,  "sampleProcesses:onlyMainThreads:",  self->_sampledProcesses,  self->_samplingMode == 1);
      }
    }

    return;
  }

  targetProcessId = self->super.super._targetProcessId;
  v34 = &self->super.super._targetProcessId;
  if ((targetProcessId & 0x80000000) == 0)
  {
    if (byte_1000E7D30)
    {
      v36 = *__error();
      int v37 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v37, OS_LOG_TYPE_ERROR)) {
        sub_100090500();
      }
      *__error() = v36;
    }

    if (byte_1000E7D31) {
      v38 = dword_1000E74E0 <= 3;
    }
    else {
      v38 = 0;
    }
    if (!v38) {
      return;
    }
    unsigned int v39 = *__error();
    int v40 = sub_10002EF3C(*v34);
    v41 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"%s [%d]: Attempted to change sampling target after done sampling",  v40,  *v34);
    if (v41)
    {
      uint64_t v42 = v41;
      int v43 = CFStringGetCStringPtr(v41, 0x8000100u);
      if (v43)
      {
        v44 = (char *)v43;
        int v45 = 0LL;
      }

      else
      {
        v44 = (char *)calloc(0x400uLL, 1uLL);
        CFStringGetCString(v42, v44, 1024LL, 0x8000100u);
        int v45 = v44;
      }

      if (qword_1000E7D38) {
        v55 = (FILE *)qword_1000E7D38;
      }
      else {
        v55 = __stderrp;
      }
      fprintf(v55, "%s\n", v44);
      if (v45) {
        free(v45);
      }
      v56 = v42;
LABEL_114:
      CFRelease(v56);
LABEL_115:
      *__error() = v39;
      return;
    }

    v54 = (os_log_s *)sub_10002EFA0();
    if (os_log_type_enabled(v54, OS_LOG_TYPE_FAULT)) {
      sub_100090494();
    }
    goto LABEL_103;
  }

  if (byte_1000E7D30)
  {
    v46 = *__error();
    v47 = (os_log_s *)sub_10002EFA0();
    if (os_log_type_enabled(v47, OS_LOG_TYPE_ERROR)) {
      sub_100090598();
    }
    *__error() = v46;
  }

  if (byte_1000E7D31) {
    v48 = dword_1000E74E0 <= 3;
  }
  else {
    v48 = 0;
  }
  if (v48)
  {
    unsigned int v39 = *__error();
    int v49 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"Attempted to change sampling target after done sampling");
    if (v49)
    {
      v50 = v49;
      int v51 = CFStringGetCStringPtr(v49, 0x8000100u);
      if (v51)
      {
        uint64_t v52 = (char *)v51;
        v53 = 0LL;
      }

      else
      {
        uint64_t v52 = (char *)calloc(0x400uLL, 1uLL);
        CFStringGetCString(v50, v52, 1024LL, 0x8000100u);
        v53 = v52;
      }

      if (qword_1000E7D38) {
        int v59 = (FILE *)qword_1000E7D38;
      }
      else {
        int v59 = __stderrp;
      }
      fprintf(v59, "%s\n", v52);
      if (v53) {
        free(v53);
      }
      v56 = v50;
      goto LABEL_114;
    }

    v57 = (os_log_s *)sub_10002EFA0();
    if (os_log_type_enabled(v57, OS_LOG_TYPE_FAULT)) {
      sub_10009056C();
    }
LABEL_103:
    if (qword_1000E7D38) {
      v58 = (FILE *)qword_1000E7D38;
    }
    else {
      v58 = __stderrp;
    }
    fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v58);
    goto LABEL_115;
  }

LABEL_89:
  if ((sub_10004A830(-[NSString UTF8String](a2, "UTF8String"), 1) & 1) != 0
    || !sub_1000411CC(*(double *)&qword_1000E7D68))
  {
    if (v42) {
      goto LABEL_167;
    }
    uint64_t v65 = v147;
    if ((v147 & 0x80000000000LL) == 0)
    {
LABEL_103:
      uint64_t v66 = sub_10002EDE8("CPU resource for [%d] thread %#llx", a1, a3);
      dispatch_queue_global_t global_queue = dispatch_get_global_queue(9LL, 0LL);
      block[0] = _NSConcreteStackBlock;
      block[1] = 3221225472LL;
      block[2] = sub_1000414CC;
      block[3] = &unk_1000D8F60;
      int v146 = a1;
      block[7] = a3;
      block[8] = a4;
      block[4] = a2;
      block[5] = a5;
      *(double *)&block[9] = a6;
      *(double *)&block[10] = a7;
      *(double *)&block[11] = a8;
      *(double *)&block[12] = a9;
      *(double *)&block[13] = a10;
      block[14] = v144;
      block[15] = v65;
      block[6] = v66;
      dispatch_async(global_queue, block);
      return;
    }

    if (sub_10004CFBC())
    {
      if ((a1 & 0x80000000) != 0)
      {
        if (byte_1000E7D30)
        {
          uint64_t v90 = a3;
          int v91 = *__error();
          v92 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v92, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)buf = 0;
            _os_log_impl( (void *)&_mh_execute_header,  v92,  OS_LOG_TYPE_DEFAULT,  "cpu resource: deferring report generation due to game mode",  buf,  2u);
          }

          *__error() = v91;
          a3 = v90;
        }

        if (!byte_1000E7D31 || dword_1000E74E0 > 2) {
          goto LABEL_223;
        }
        uint64_t v142 = a3;
        int v72 = *__error();
        int v74 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"cpu resource: deferring report generation due to game mode");
        if (!v74)
        {
          uint64_t v136 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v136, OS_LOG_TYPE_FAULT)) {
            sub_1000827A0();
          }
          goto LABEL_218;
        }
      }

      else
      {
        if (byte_1000E7D30)
        {
          uint64_t v68 = a3;
          int v69 = *__error();
          v70 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v70, OS_LOG_TYPE_DEFAULT))
          {
            v71 = sub_10002EF3C(a1);
            *(_DWORD *)buf = 136446466;
            uint64_t v149 = v71;
            __int16 v150 = 1024;
            *(_DWORD *)v151 = a1;
            _os_log_impl( (void *)&_mh_execute_header,  v70,  OS_LOG_TYPE_DEFAULT,  "%{public}s [%d]: cpu resource: deferring report generation due to game mode",  buf,  0x12u);
          }

          *__error() = v69;
          a3 = v68;
        }

        if (!byte_1000E7D31 || dword_1000E74E0 > 2) {
          goto LABEL_223;
        }
        uint64_t v142 = a3;
        int v72 = *__error();
        v73 = sub_10002EF3C(a1);
        int v74 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"%s [%d]: cpu resource: deferring report generation due to game mode",  v73,  a1);
        if (!v74)
        {
          v75 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v75, OS_LOG_TYPE_FAULT)) {
            sub_100082738();
          }
LABEL_218:
          if (qword_1000E7D38) {
            uint64_t v137 = (FILE *)qword_1000E7D38;
          }
          else {
            uint64_t v137 = __stderrp;
          }
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v137);
LABEL_222:
          *__error() = v72;
          a3 = v142;
LABEL_223:
          sub_10004D744(a1, (uint64_t)a2, a3, a4, a5, a6, a7, a8, a9, a10);
          uint64_t v126 = v65 | 0x100000000000LL;
          double v127 = a8 - a7;
          char v128 = a4 & 1;
          int v129 = a1;
          v130 = a2;
          uint64_t v131 = v144;
          uint64_t v132 = 0LL;
          goto LABEL_201;
        }
      }

      v93 = v74;
      v94 = a2;
      uint64_t v95 = a5;
      v96 = CFStringGetCStringPtr(v74, 0x8000100u);
      if (v96)
      {
        v97 = (char *)v96;
        v98 = 0LL;
      }

      else
      {
        v97 = (char *)calloc(0x400uLL, 1uLL);
        CFStringGetCString(v93, v97, 1024LL, 0x8000100u);
        v98 = v97;
      }

      if (qword_1000E7D38) {
        uint64_t v133 = (FILE *)qword_1000E7D38;
      }
      else {
        uint64_t v133 = __stderrp;
      }
      fprintf(v133, "%s\n", v97);
      if (v98) {
        free(v98);
      }
      CFRelease(v93);
      a5 = v95;
      a2 = v94;
      goto LABEL_222;
    }

    if ((a1 & 0x80000000) != 0)
    {
      if (byte_1000E7D30)
      {
        uint64_t v99 = a3;
        int v100 = *__error();
        v101 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v101, OS_LOG_TYPE_DEBUG)) {
          sub_1000828C8();
        }
        *__error() = v100;
        a3 = v99;
      }

      if (!byte_1000E7D31 || dword_1000E74E0 > 0) {
        goto LABEL_103;
      }
      uint64_t v143 = a3;
      int v85 = *__error();
      __int16 v87 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"cpu resource: cannot defer report generation for game mode");
      if (!v87)
      {
        uint64_t v138 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v138, OS_LOG_TYPE_FAULT)) {
          sub_10008289C();
        }
        goto LABEL_226;
      }
    }

    else
    {
      if (byte_1000E7D30)
      {
        uint64_t v82 = a3;
        int v83 = *__error();
        v84 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v84, OS_LOG_TYPE_DEBUG)) {
          sub_100082834();
        }
        *__error() = v83;
        a3 = v82;
      }

      if (!byte_1000E7D31 || dword_1000E74E0 > 0) {
        goto LABEL_103;
      }
      uint64_t v143 = a3;
      int v85 = *__error();
      __int16 v86 = sub_10002EF3C(a1);
      __int16 v87 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"%s [%d]: cpu resource: cannot defer report generation for game mode",  v86,  a1);
      if (!v87)
      {
        int v88 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v88, OS_LOG_TYPE_FAULT)) {
          sub_1000827CC();
        }
LABEL_226:
        if (qword_1000E7D38) {
          uint64_t v139 = (FILE *)qword_1000E7D38;
        }
        else {
          uint64_t v139 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v139);
LABEL_230:
        *__error() = v85;
        a3 = v143;
        goto LABEL_103;
      }
    }

    int v102 = v87;
    int v103 = a2;
    uint64_t v104 = a5;
    v105 = CFStringGetCStringPtr(v87, 0x8000100u);
    if (v105)
    {
      v106 = (char *)v105;
      v107 = 0LL;
    }

    else
    {
      v106 = (char *)calloc(0x400uLL, 1uLL);
      CFStringGetCString(v102, v106, 1024LL, 0x8000100u);
      v107 = v106;
    }

    if (qword_1000E7D38) {
      uint64_t v134 = (FILE *)qword_1000E7D38;
    }
    else {
      uint64_t v134 = __stderrp;
    }
    fprintf(v134, "%s\n", v106);
    if (v107) {
      free(v107);
    }
    CFRelease(v102);
    a5 = v104;
    a2 = v103;
    goto LABEL_230;
  }

  if ((a1 & 0x80000000) != 0)
  {
    if (byte_1000E7D30)
    {
      int v76 = *__error();
      int v77 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v77, OS_LOG_TYPE_DEBUG)) {
        sub_100082ABC();
      }
      *__error() = v76;
    }

    if (!byte_1000E7D31 || dword_1000E74E0 > 0) {
      goto LABEL_166;
    }
    int v61 = *__error();
    v63 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"cpu resource: not monitoring due to throttling the number of reports generated for 1st party processes");
    if (!v63)
    {
      v108 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v108, OS_LOG_TYPE_FAULT)) {
        sub_100082A90();
      }
      goto LABEL_161;
    }

  if (!sub_1000411CC(*(double *)&qword_1000E7D60))
  {
    if (v43) {
      goto LABEL_148;
    }
    v67 = (uint64_t)a5;
    uint64_t v68 = v148;
    int v69 = (uint64_t)v42;
    if ((v148 & 0x80000000000LL) == 0)
    {
LABEL_102:
      v70 = sub_10002EDE8("Disk writes resource for [%d]", a1);
      dispatch_queue_global_t global_queue = dispatch_get_global_queue(9LL, 0LL);
      block[0] = _NSConcreteStackBlock;
      block[1] = 3221225472LL;
      block[2] = sub_100043474;
      block[3] = &unk_1000D8F88;
      uint64_t v147 = a1;
      block[4] = v69;
      block[5] = a4;
      block[7] = a3;
      block[8] = v67;
      *(double *)&block[9] = a7;
      *(double *)&block[10] = a8;
      block[11] = a6;
      *(double *)&block[12] = a9;
      block[13] = v145;
      block[14] = v68;
      block[6] = v70;
      dispatch_async(global_queue, block);
      return;
    }

    v78 = a6;
    if (sub_10004CFBC())
    {
      if ((a1 & 0x80000000) != 0)
      {
        if (byte_1000E7D30)
        {
          v119 = *__error();
          v120 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v120, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)buf = 0;
            _os_log_impl( (void *)&_mh_execute_header,  v120,  OS_LOG_TYPE_DEFAULT,  "disk writes: deferring report generation due to game mode",  buf,  2u);
          }

          *__error() = v119;
        }

        if (!byte_1000E7D31 || dword_1000E74E0 > 2) {
          goto LABEL_222;
        }
        uint64_t v82 = *__error();
        v84 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"disk writes: deferring report generation due to game mode");
        if (!v84)
        {
          uint64_t v138 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v138, OS_LOG_TYPE_FAULT)) {
            sub_100083BC0();
          }
          goto LABEL_217;
        }
      }

      else
      {
        if (byte_1000E7D30)
        {
          v79 = *__error();
          v80 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v80, OS_LOG_TYPE_DEFAULT))
          {
            v81 = sub_10002EF3C(a1);
            *(_DWORD *)buf = 136446466;
            __int16 v150 = v81;
            v151 = 1024;
            *(_DWORD *)__int16 v152 = a1;
            _os_log_impl( (void *)&_mh_execute_header,  v80,  OS_LOG_TYPE_DEFAULT,  "%{public}s [%d]: disk writes: deferring report generation due to game mode",  buf,  0x12u);
          }

          *__error() = v79;
          int v69 = (uint64_t)v42;
        }

        if (!byte_1000E7D31 || dword_1000E74E0 > 2) {
          goto LABEL_222;
        }
        uint64_t v82 = *__error();
        int v83 = sub_10002EF3C(a1);
        v84 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"%s [%d]: disk writes: deferring report generation due to game mode",  v83,  a1);
        if (!v84)
        {
          int v85 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v85, OS_LOG_TYPE_FAULT)) {
            sub_100083B58();
          }
LABEL_217:
          if (qword_1000E7D38) {
            uint64_t v139 = (FILE *)qword_1000E7D38;
          }
          else {
            uint64_t v139 = __stderrp;
          }
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v139);
          int v69 = (uint64_t)v42;
LABEL_221:
          *__error() = v82;
LABEL_222:
          sub_10004E7DC(a1, v69, a3, a4, v67, v78, a7, a8, a9);
          v111 = v68 | 0x100000000000LL;
          int v112 = a8 - a7;
          int v113 = a1;
          unsigned int v114 = (void *)v69;
          int v115 = v145;
          v116 = 0LL;
          int v117 = a8;
          v118 = v67;
          goto LABEL_182;
        }
      }

      v121 = v84;
      v122 = a3;
      v123 = (uint64_t)v42;
      int v124 = CFStringGetCStringPtr(v84, 0x8000100u);
      if (v124)
      {
        v125 = (char *)v124;
        uint64_t v126 = 0LL;
      }

      else
      {
        v125 = (char *)calloc(0x400uLL, 1uLL);
        CFStringGetCString(v121, v125, 1024LL, 0x8000100u);
        uint64_t v126 = v125;
      }

      if (qword_1000E7D38) {
        uint64_t v136 = (FILE *)qword_1000E7D38;
      }
      else {
        uint64_t v136 = __stderrp;
      }
      fprintf(v136, "%s\n", v125);
      if (v126) {
        free(v126);
      }
      CFRelease(v121);
      int v69 = v123;
      a3 = v122;
      goto LABEL_221;
    }

    if ((a1 & 0x80000000) != 0)
    {
      if (byte_1000E7D30)
      {
        double v127 = *__error();
        char v128 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v128, OS_LOG_TYPE_DEBUG)) {
          sub_100083CE8();
        }
        *__error() = v127;
      }

      a6 = v78;
      if (!byte_1000E7D31 || dword_1000E74E0 > 0) {
        goto LABEL_102;
      }
      v89 = *__error();
      int v91 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"disk writes: cannot defer report generation for game mode");
      if (!v91)
      {
        uint64_t v140 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v140, OS_LOG_TYPE_FAULT)) {
          sub_100083CBC();
        }
        goto LABEL_225;
      }
    }

    else
    {
      if (byte_1000E7D30)
      {
        __int16 v87 = *__error();
        int v88 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v88, OS_LOG_TYPE_DEBUG)) {
          sub_100083C54();
        }
        *__error() = v87;
      }

      a6 = v78;
      if (!byte_1000E7D31 || dword_1000E74E0 > 0) {
        goto LABEL_102;
      }
      v89 = *__error();
      uint64_t v90 = sub_10002EF3C(a1);
      int v91 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"%s [%d]: disk writes: cannot defer report generation for game mode",  v90,  a1);
      if (!v91)
      {
        v92 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v92, OS_LOG_TYPE_FAULT)) {
          sub_100083BEC();
        }
LABEL_225:
        if (qword_1000E7D38) {
          int v141 = (FILE *)qword_1000E7D38;
        }
        else {
          int v141 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v141);
        int v69 = (uint64_t)v42;
LABEL_229:
        *__error() = v89;
        a6 = v78;
        goto LABEL_102;
      }
    }

    int v129 = v91;
    v130 = a3;
    uint64_t v131 = (uint64_t)v42;
    uint64_t v132 = CFStringGetCStringPtr(v91, 0x8000100u);
    if (v132)
    {
      uint64_t v133 = (char *)v132;
      uint64_t v134 = 0LL;
    }

    else
    {
      uint64_t v133 = (char *)calloc(0x400uLL, 1uLL);
      CFStringGetCString(v129, v133, 1024LL, 0x8000100u);
      uint64_t v134 = v133;
    }

    if (qword_1000E7D38) {
      uint64_t v137 = (FILE *)qword_1000E7D38;
    }
    else {
      uint64_t v137 = __stderrp;
    }
    fprintf(v137, "%s\n", v133);
    if (v134) {
      free(v134);
    }
    CFRelease(v129);
    int v69 = v131;
    a3 = v130;
    goto LABEL_229;
  }

  if ((a1 & 0x80000000) != 0)
  {
    if (byte_1000E7D30)
    {
      int v72 = *__error();
      v73 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v73, OS_LOG_TYPE_DEBUG)) {
        sub_100083B2C();
      }
      *__error() = v72;
    }

    if (!byte_1000E7D31 || dword_1000E74E0 > 0) {
      goto LABEL_147;
    }
    v63 = *__error();
    uint64_t v65 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"disk writes: not monitoring due to tasking-specified sampling");
    if (!v65)
    {
      v93 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v93, OS_LOG_TYPE_FAULT)) {
        sub_100083B00();
      }
      goto LABEL_142;
    }

LABEL_122:
    v78 = v63;
    v79 = CFStringGetCStringPtr(v63, 0x8000100u);
    if (v79)
    {
      v80 = (char *)v79;
      v81 = 0LL;
    }

    else
    {
      v80 = (char *)calloc(0x400uLL, 1uLL);
      CFStringGetCString(v78, v80, 1024LL, 0x8000100u);
      v81 = v80;
    }

    if (qword_1000E7D38) {
      v89 = (FILE *)qword_1000E7D38;
    }
    else {
      v89 = __stderrp;
    }
    fprintf(v89, "%s\n", v80);
    if (v81) {
      free(v81);
    }
    CFRelease(v78);
    goto LABEL_165;
  }

  if (byte_1000E7D30)
  {
    int v59 = *__error();
    __int16 v60 = (os_log_s *)sub_10002EFA0();
    if (os_log_type_enabled(v60, OS_LOG_TYPE_DEBUG)) {
      sub_100082A28();
    }
    *__error() = v59;
  }

  if (!byte_1000E7D31 || dword_1000E74E0 > 0) {
    goto LABEL_166;
  }
  int v61 = *__error();
  int v62 = sub_10002EF3C(a1);
  v63 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"%s [%d]: cpu resource: not monitoring due to throttling the number of reports generated for 1st party processes",  v62,  a1);
  if (v63) {
    goto LABEL_122;
  }
  unsigned int v64 = (os_log_s *)sub_10002EFA0();
  if (os_log_type_enabled(v64, OS_LOG_TYPE_FAULT)) {
    sub_1000829C0();
  }
LABEL_161:
  if (qword_1000E7D38) {
    v109 = (FILE *)qword_1000E7D38;
  }
  else {
    v109 = __stderrp;
  }
  fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v109);
LABEL_165:
  *__error() = v61;
LABEL_166:
  v42 |= 0x200000uLL;
LABEL_167:
  if ((a1 & 0x80000000) != 0)
  {
    if (byte_1000E7D30)
    {
      int v117 = *__error();
      v118 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v118, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 134217984;
        uint64_t v149 = (_DWORD *)v42;
        _os_log_impl( (void *)&_mh_execute_header,  v118,  OS_LOG_TYPE_DEFAULT,  "cpu resource: not monitoring due to conditions %#llx",  buf,  0xCu);
      }

      *__error() = v117;
    }

    if (!byte_1000E7D31 || dword_1000E74E0 > 2) {
      goto LABEL_200;
    }
    int v113 = *__error();
    int v115 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"cpu resource: not monitoring due to conditions %#llx",  v42);
    if (!v115)
    {
      int v124 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v124, OS_LOG_TYPE_FAULT)) {
        sub_100082960();
      }
      goto LABEL_195;
    }

LABEL_184:
    v119 = v115;
    v120 = CFStringGetCStringPtr(v115, 0x8000100u);
    if (v120)
    {
      v121 = (char *)v120;
      v122 = 0LL;
    }

    else
    {
      v121 = (char *)calloc(0x400uLL, 1uLL);
      CFStringGetCString(v119, v121, 1024LL, 0x8000100u);
      v122 = v121;
    }

    if (qword_1000E7D38) {
      v123 = (FILE *)qword_1000E7D38;
    }
    else {
      v123 = __stderrp;
    }
    fprintf(v123, "%s\n", v121);
    if (v122) {
      free(v122);
    }
    CFRelease(v119);
    goto LABEL_199;
  }

  if (byte_1000E7D30)
  {
    int v110 = *__error();
    v111 = (os_log_s *)sub_10002EFA0();
    if (os_log_type_enabled(v111, OS_LOG_TYPE_DEFAULT))
    {
      int v112 = sub_10002EF3C(a1);
      *(_DWORD *)buf = 136446722;
      uint64_t v149 = v112;
      __int16 v150 = 1024;
      *(_DWORD *)v151 = a1;
      *(_WORD *)&v151[4] = 2048;
      *(void *)&v151[6] = v42;
      _os_log_impl( (void *)&_mh_execute_header,  v111,  OS_LOG_TYPE_DEFAULT,  "%{public}s [%d]: cpu resource: not monitoring due to conditions %#llx",  buf,  0x1Cu);
    }

    *__error() = v110;
  }

  if (!byte_1000E7D31 || dword_1000E74E0 > 2) {
    goto LABEL_200;
  }
  int v113 = *__error();
  unsigned int v114 = sub_10002EF3C(a1);
  int v115 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"%s [%d]: cpu resource: not monitoring due to conditions %#llx",  v114,  a1,  v42);
  if (v115) {
    goto LABEL_184;
  }
  v116 = (os_log_s *)sub_10002EFA0();
  if (os_log_type_enabled(v116, OS_LOG_TYPE_FAULT)) {
    sub_1000828F4();
  }
LABEL_195:
  if (qword_1000E7D38) {
    v125 = (FILE *)qword_1000E7D38;
  }
  else {
    v125 = __stderrp;
  }
  fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v125);
LABEL_199:
  *__error() = v113;
LABEL_200:
  uint64_t v126 = v147;
  double v127 = a8 - a7;
  char v128 = a4 & 1;
  int v129 = a1;
  v130 = a2;
  uint64_t v131 = v144;
  uint64_t v132 = v42;
LABEL_201:
  sub_10002F9E8(v129, v130, v131, v132, v126, v128, v127, a8, a6);
}

uint64_t sub_100027324( char *a1, off_t a2, uint64_t a3, _BYTE *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, double a9, double a10, double a11, double a12, double a13, double a14, double a15, unsigned int a16, unsigned __int8 a17, uint64_t a18, uint64_t a19, char a20, int a21, unsigned int a22, char a23, void *a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, unsigned int a29, unsigned int a30, void *a31, uint64_t a32)
{
  unsigned int v344 = a16 - 5;
  if (a16 - 5 >= 6)
  {
    if ((a3 & 0x80000000) != 0)
    {
      if (byte_1000E7D30)
      {
        int v322 = *__error();
        v323 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v323, OS_LOG_TYPE_ERROR)) {
          sub_100088AEC();
        }
        *__error() = v322;
      }

      if (byte_1000E7D31 && dword_1000E74E0 <= 3)
      {
        int v324 = *__error();
        v325 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"%s: Bad report type for microstackshots %d",  "report_type == DID_SYSTEM_STATS || report_type == DID_SYSTEM_STATS_IO || report_type == DID_MANUAL_MICR OSTACKSHOTS || report_type == DID_MANUAL_MICROSTACKSHOTS_IO || report_type == DID_CPU_RESOURCE || repor t_type == DID_DISK_WRITES_RESOURCE",  a16);
        if (v325)
        {
          v332 = v325;
          CStringPtr = CFStringGetCStringPtr(v325, 0x8000100u);
          if (CStringPtr)
          {
            v334 = (char *)CStringPtr;
            v335 = 0LL;
          }

          else
          {
            v334 = (char *)calloc(0x400uLL, 1uLL);
            CFStringGetCString(v332, v334, 1024LL, 0x8000100u);
            v335 = v334;
          }

          if (qword_1000E7D38) {
            v337 = (FILE *)qword_1000E7D38;
          }
          else {
            v337 = __stderrp;
          }
          fprintf(v337, "%s\n", v334);
          if (v335) {
            free(v335);
          }
          CFRelease(v332);
        }

        else
        {
          v326 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v326, OS_LOG_TYPE_FAULT)) {
            sub_100088A7C();
          }
          if (qword_1000E7D38) {
            v327 = (FILE *)qword_1000E7D38;
          }
          else {
            v327 = __stderrp;
          }
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v327);
        }

        *__error() = v324;
      }

      v338 = "report_type == DID_SYSTEM_STATS || report_type == DID_SYSTEM_STATS_IO || report_type == DID_MANUAL_MICROSTA"
             "CKSHOTS || report_type == DID_MANUAL_MICROSTACKSHOTS_IO || report_type == DID_CPU_RESOURCE || report_type ="
             "= DID_DISK_WRITES_RESOURCE";
      v289 = "%s: Bad report type for microstackshots %d";
    }

    else
    {
      if (byte_1000E7D30)
      {
        int v313 = *__error();
        v314 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v314, OS_LOG_TYPE_ERROR)) {
          sub_100088A04();
        }
        *__error() = v313;
      }

      if (byte_1000E7D31 && dword_1000E74E0 <= 3)
      {
        int v315 = *__error();
        v316 = sub_10002EF3C(a3);
        v317 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"%s [%d]: %s: Bad report type for microstackshots %d",  v316,  a3,  "report_type == DID_SYSTEM_STATS || report_type == DID_SYSTEM_STATS_IO || report_type == DID_MANUAL_MICR OSTACKSHOTS || report_type == DID_MANUAL_MICROSTACKSHOTS_IO || report_type == DID_CPU_RESOURCE || repor t_type == DID_DISK_WRITES_RESOURCE",  a16);
        if (v317)
        {
          v328 = v317;
          v329 = CFStringGetCStringPtr(v317, 0x8000100u);
          if (v329)
          {
            v330 = (char *)v329;
            v331 = 0LL;
          }

          else
          {
            v330 = (char *)calloc(0x400uLL, 1uLL);
            CFStringGetCString(v328, v330, 1024LL, 0x8000100u);
            v331 = v330;
          }

          if (qword_1000E7D38) {
            v336 = (FILE *)qword_1000E7D38;
          }
          else {
            v336 = __stderrp;
          }
          fprintf(v336, "%s\n", v330);
          if (v331) {
            free(v331);
          }
          CFRelease(v328);
        }

        else
        {
          v318 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v318, OS_LOG_TYPE_FAULT)) {
            sub_10008898C();
          }
          if (qword_1000E7D38) {
            v319 = (FILE *)qword_1000E7D38;
          }
          else {
            v319 = __stderrp;
          }
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v319);
        }

        *__error() = v315;
      }

      LOBYTE(v338) = sub_10002EF3C(a3);
      v289 = "%s [%d]: %s: Bad report type for microstackshots %d";
    }

    int v291 = 153;
LABEL_446:
    sub_10002EE78("DoMicrostackshotsOnly", "microstackshot.m", v291, v289, a5, a6, a7, a8, (char)v338);
    abort();
  }

  if (a16 - 7 < 2 != [a24 systemstatsFormat])
  {
    if ((a3 & 0x80000000) != 0)
    {
      if (byte_1000E7D30)
      {
        int v273 = *__error();
        v274 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v274, OS_LOG_TYPE_ERROR)) {
          sub_100087BDC(a24, a16, v274);
        }
        *__error() = v273;
      }

      if (byte_1000E7D31 && dword_1000E74E0 <= 3)
      {
        int v275 = *__error();
        v276 = CFStringCreateWithFormat( kCFAllocatorDefault,  0,  @"%s: report_type %d, but systemstatsFormat %d",  "((!!(report_type == DID_SYSTEM_STATS || report_type == DID_SYSTEM_STATS_IO)) == (!!printOptions.systemstatsFormat))",  a16,  [a24 systemstatsFormat]);
        if (v276)
        {
          v283 = v276;
          v284 = CFStringGetCStringPtr(v276, 0x8000100u);
          if (v284)
          {
            v285 = (char *)v284;
            v286 = 0LL;
          }

          else
          {
            v285 = (char *)calloc(0x400uLL, 1uLL);
            CFStringGetCString(v283, v285, 1024LL, 0x8000100u);
            v286 = v285;
          }

          if (qword_1000E7D38) {
            v290 = (FILE *)qword_1000E7D38;
          }
          else {
            v290 = __stderrp;
          }
          fprintf(v290, "%s\n", v285);
          if (v286) {
            free(v286);
          }
          CFRelease(v283);
        }

        else
        {
          v277 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v277, OS_LOG_TYPE_FAULT)) {
            sub_100087B50(a24, a16, v277);
          }
          if (qword_1000E7D38) {
            v278 = (FILE *)qword_1000E7D38;
          }
          else {
            v278 = __stderrp;
          }
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v278);
        }

        *__error() = v275;
      }

      [a24 systemstatsFormat];
      v338 = "((!!(report_type == DID_SYSTEM_STATS || report_type == DID_SYSTEM_STATS_IO)) == (!!printOptions.systemstatsFormat))";
      v289 = "%s: report_type %d, but systemstatsFormat %d";
    }

    else
    {
      if (byte_1000E7D30)
      {
        int v264 = *__error();
        v265 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v265, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136316162;
          *(void *)&uint8_t buf[4] = sub_10002EF3C(a3);
          __int16 v353 = 1024;
          __int16 v355 = 2080;
          int v354 = a3;
          v356 = "((!!(report_type == DID_SYSTEM_STATS || report_type == DID_SYSTEM_STATS_IO)) == (!!printOptions.systemstatsFormat))";
          __int16 v357 = 1024;
          unsigned int v358 = a16;
          __int16 v359 = 1024;
          unsigned int v360 = [a24 systemstatsFormat];
          _os_log_error_impl( (void *)&_mh_execute_header,  v265,  OS_LOG_TYPE_ERROR,  "%s [%d]: %s: report_type %d, but systemstatsFormat %d",  buf,  0x28u);
        }

        *__error() = v264;
      }

      if (byte_1000E7D31 && dword_1000E74E0 <= 3)
      {
        int v266 = *__error();
        v267 = sub_10002EF3C(a3);
        v268 = CFStringCreateWithFormat( kCFAllocatorDefault,  0,  @"%s [%d]: %s: report_type %d, but systemstatsFormat %d",  v267,  a3,  "((!!(report_type == DID_SYSTEM_STATS || report_type == DID_SYSTEM_STATS_IO)) == (!!printOptions.systemstatsFormat))",  a16,  [a24 systemstatsFormat]);
        if (v268)
        {
          v279 = v268;
          v280 = CFStringGetCStringPtr(v268, 0x8000100u);
          if (v280)
          {
            v281 = (char *)v280;
            v282 = 0LL;
          }

          else
          {
            v281 = (char *)calloc(0x400uLL, 1uLL);
            CFStringGetCString(v279, v281, 1024LL, 0x8000100u);
            v282 = v281;
          }

          if (qword_1000E7D38) {
            v287 = (FILE *)qword_1000E7D38;
          }
          else {
            v287 = __stderrp;
          }
          fprintf(v287, "%s\n", v281);
          if (v282) {
            free(v282);
          }
          CFRelease(v279);
        }

        else
        {
          v269 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v269, OS_LOG_TYPE_FAULT))
          {
            v270 = sub_10002EF3C(a3);
            unsigned int v271 = [a24 systemstatsFormat];
            *(_DWORD *)buf = 136316162;
            *(void *)&uint8_t buf[4] = v270;
            __int16 v353 = 1024;
            int v354 = a3;
            __int16 v355 = 2080;
            v356 = "((!!(report_type == DID_SYSTEM_STATS || report_type == DID_SYSTEM_STATS_IO)) == (!!printOptions.systemstatsFormat))";
            __int16 v357 = 1024;
            unsigned int v358 = a16;
            __int16 v359 = 1024;
            unsigned int v360 = v271;
            _os_log_fault_impl( (void *)&_mh_execute_header,  v269,  OS_LOG_TYPE_FAULT,  "Unable to format: %s [%d]: %s: report_type %d, but systemstatsFormat %d",  buf,  0x28u);
          }

          if (qword_1000E7D38) {
            v272 = (FILE *)qword_1000E7D38;
          }
          else {
            v272 = __stderrp;
          }
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v272);
        }

        *__error() = v266;
      }

      unsigned __int8 v288 = sub_10002EF3C(a3);
      [a24 systemstatsFormat];
      LOBYTE(v338) = v288;
      v289 = "%s [%d]: %s: report_type %d, but systemstatsFormat %d";
    }

    int v291 = 155;
    goto LABEL_446;
  }

  if (a16 == 5 && (_DWORD)a6)
  {
    id v45 = +[SAAuxiliaryData auxiliaryDataForTimestamp:]( &OBJC_CLASS___SAAuxiliaryData,  "auxiliaryDataForTimestamp:",  +[SATimestamp timestamp](&OBJC_CLASS___SATimestamp, "timestamp"));
    v46 = sub_10004B040(a3, a4, 1);
LABEL_7:
    int v50 = sub_10004A830(-[NSString UTF8String](v46, "UTF8String"), a6);
    uint64_t v48 = 0LL;
    if (v50) {
      int v49 = a3;
    }
    else {
      int v49 = -1;
    }
    id v47 = v45;
    goto LABEL_11;
  }

  v46 = sub_10004B040(a3, a4, a6);
  id v45 = 0LL;
  id v47 = 0LL;
  uint64_t v48 = a5;
  int v49 = a3;
  if (v344 <= 1) {
    goto LABEL_7;
  }
LABEL_11:
  id v340 = v47;
  id v51 = sub_100029D0C(a1, a2, v49, v48, a6, 1LL, 0LL, a22, a9, a10, a27, a28, a29, a30, a32);
  uint64_t v52 = v51;
  if (!v51) {
    goto LABEL_24;
  }
  if ((a3 & 0x80000000) == 0) {
    [v51 setTargetProcessId:a3];
  }
  if (a5) {
    [v52 setTargetThreadId:a5];
  }
  if (v46)
  {
    if ((objc_msgSend( objc_msgSend(objc_msgSend(v52, "targetProcess"), "mainBinaryPath"),  "isAbsolutePath") & 1) == 0)
    {
      id v53 = [v52 targetProcess];
      if (v53)
      {
        [v53 setMainBinaryPath:v46];
        [v52 postprocess];
      }
    }
  }

  if (!objc_msgSend(objc_msgSend(v52, "tasksByPid"), "count"))
  {
LABEL_24:
    if ((a3 & 0x80000000) != 0)
    {
      if (byte_1000E7D30)
      {
        int v60 = *__error();
        int v61 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v61, OS_LOG_TYPE_ERROR)) {
          sub_100087D84();
        }
        *__error() = v60;
      }

      if (!byte_1000E7D31 || dword_1000E74E0 > 3) {
        goto LABEL_92;
      }
      int v56 = *__error();
      v58 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"No microstackshots found");
      if (!v58)
      {
        uint64_t v95 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v95, OS_LOG_TYPE_FAULT)) {
          sub_100087D58();
        }
        goto LABEL_87;
      }

LABEL_41:
      int v62 = v58;
      v63 = CFStringGetCStringPtr(v58, 0x8000100u);
      if (v63)
      {
        unsigned int v64 = (char *)v63;
        uint64_t v65 = 0LL;
      }

      else
      {
        unsigned int v64 = (char *)calloc(0x400uLL, 1uLL);
        CFStringGetCString(v62, v64, 1024LL, 0x8000100u);
        uint64_t v65 = v64;
      }

      if (qword_1000E7D38) {
        int v83 = (FILE *)qword_1000E7D38;
      }
      else {
        int v83 = __stderrp;
      }
      fprintf(v83, "%s\n", v64);
      if (v65) {
        free(v65);
      }
      CFRelease(v62);
      goto LABEL_91;
    }

      uint64_t v21 = v10;
      CStringPtr = CFStringGetCStringPtr(v10, 0x8000100u);
      if (CStringPtr)
      {
        int v23 = (char *)CStringPtr;
        uid_t v24 = 0LL;
      }

      else
      {
        int v23 = (char *)calloc(0x400uLL, 1uLL);
        CFStringGetCString(v21, v23, 1024LL, 0x8000100u);
        uid_t v24 = v23;
      }

      if (qword_1000E7D38) {
        v41 = (FILE *)qword_1000E7D38;
      }
      else {
        v41 = __stderrp;
      }
      fprintf(v41, "%s\n", v23);
      if (v24) {
        free(v24);
      }
      uint64_t v42 = v21;
LABEL_93:
      CFRelease(v42);
LABEL_102:
      *__error() = v8;
      return mach_port_deallocate(mach_task_self_, name);
    }

    if (byte_1000E7D30)
    {
      BOOL v25 = *__error();
      __int16 v26 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v26,  OS_LOG_TYPE_DEFAULT,  "kqworkloop exhaustion: deallocating fatal port, allowing process to exit due to fatal resource exhaustion",  buf,  2u);
      }

      *__error() = v25;
    }

    if (byte_1000E7D31) {
      char v27 = dword_1000E74E0 <= 2;
    }
    else {
      char v27 = 0;
    }
    if (!v27) {
      return mach_port_deallocate(mach_task_self_, name);
    }
    BOOL v8 = *__error();
    int v28 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"kqworkloop exhaustion: deallocating fatal port, allowing process to exit due to fatal resource exhaustion");
    if (!v28)
    {
      v29 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v29, OS_LOG_TYPE_FAULT)) {
        sub_10008B388();
      }
      goto LABEL_98;
    }

LABEL_25:
    if (byte_1000E7D30)
    {
      int v54 = *__error();
      v55 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v55, OS_LOG_TYPE_ERROR)) {
        sub_100087CE0(a3, v55);
      }
      *__error() = v54;
    }

    if (!byte_1000E7D31 || dword_1000E74E0 > 3) {
      goto LABEL_92;
    }
    int v56 = *__error();
    v57 = sub_10002EF3C(a3);
    v58 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"%s [%d]: No microstackshots found", v57, a3);
    if (!v58)
    {
      int v59 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v59, OS_LOG_TYPE_FAULT)) {
        sub_100087C68(a3, v59);
      }
LABEL_87:
      if (qword_1000E7D38) {
        v96 = (FILE *)qword_1000E7D38;
      }
      else {
        v96 = __stderrp;
      }
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v96);
LABEL_91:
      *__error() = v56;
LABEL_92:

      return 0x800000LL;
    }

    goto LABEL_41;
  }

  if (a5 && v344 <= 1)
  {
    if (!objc_msgSend( objc_msgSend(objc_msgSend(v52, "targetProcess"), "threads"),  "objectForKeyedSubscript:",  +[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", a5))) {
      goto LABEL_24;
    }
  }

  else if ((a3 & 0x80000000) == 0 && !a5 && v344 <= 1 && ![v52 targetProcess])
  {
    goto LABEL_25;
  }

  uint64_t v342 = a3;
  unsigned int v66 = a16 - 9;
  BOOL v68 = (byte_1000E7D44 & 0x10) == 0 && v66 < 2;
  sub_1000571C4(v52, (byte_1000E7D44 >> 3) & 1, (byte_1000E7D44 >> 2) & 1, v68);
  __int128 v349 = 0u;
  __int128 v350 = 0u;
  __int128 v347 = 0u;
  __int128 v348 = 0u;
  id v69 = [a31 countByEnumeratingWithState:&v347 objects:v351 count:16];
  if (v69)
  {
    id v70 = v69;
    uint64_t v71 = *(void *)v348;
    do
    {
      for (i = 0LL; i != v70; i = (char *)i + 1)
      {
        if (*(void *)v348 != v71) {
          objc_enumerationMutation(a31);
        }
        [v52 useDsymForUUIDFor:*(void *)(*((void *)&v347 + 1) + 8 * (void)i)];
      }

      id v70 = [a31 countByEnumeratingWithState:&v347 objects:v351 count:16];
    }

    while (v70);
  }

  v73 = -[SASamplePrinter initWithSampleStore:](objc_alloc(&OBJC_CLASS___SASamplePrinter), "initWithSampleStore:", v52);
  int v74 = v73;
  if (a24) {
    -[SASamplePrinter setOptions:](v73, "setOptions:");
  }
  unsigned int v75 = a16 - 5;
  if (a11 != 0.0)
  {
    id v76 = [v52 endTime];
    if (v76)
    {
      int v77 = v76;
      [v76 machContTimeSeconds];
      if (v78 != 0.0)
      {
        [v77 machContTimeSeconds];
        if (v79 > a11)
        {
          [v77 machContTimeSeconds];
          double v81 = v80 - a11;
          double v82 = 0.0;
LABEL_96:
          double v86 = 0.0;
LABEL_97:
          v101 = +[SATimestamp timestampWithMachAbsTime:machAbsTimeSec:machContTime:machContTimeSec:wallTime:]( &OBJC_CLASS___SATimestamp,  "timestampWithMachAbsTime:machAbsTimeSec:machContTime:machContTimeSec:wallTime:",  0LL,  0LL,  v82,  v81,  v86);
          if (v101)
          {
            id v102 = [v52 indexOfFirstSampleOnOrAfterTimestamp:v101];
            if (v102 == (id)0x7FFFFFFFFFFFFFFFLL)
            {
              id v103 = [v52 endTime];
              if (!v103)
              {
                id v103 = [v52 startTime];
                if (!v103) {
                  goto LABEL_104;
                }
              }
            }

            else
            {
              id v103 = objc_msgSend(objc_msgSend(v52, "sampleTimestamps"), "objectAtIndexedSubscript:", v102);
            }

            -[SATimestamp guessMissingTimesBasedOnTimestamp:](v101, "guessMissingTimesBasedOnTimestamp:", v103);
          }

    int v23 = v22;
    CStringPtr = CFStringGetCStringPtr(v22, 0x8000100u);
    if (CStringPtr)
    {
      BOOL v25 = (char *)CStringPtr;
      __int16 v26 = 0LL;
    }

    else
    {
      BOOL v25 = (char *)calloc(0x400uLL, 1uLL);
      CFStringGetCString(v23, v25, 1024LL, 0x8000100u);
      __int16 v26 = v25;
    }

    if (qword_1000E7D38) {
      v46 = (FILE *)qword_1000E7D38;
    }
    else {
      v46 = __stderrp;
    }
    fprintf(v46, "%s\n", v25);
    if (v26) {
      free(v26);
    }
    CFRelease(v23);
    goto LABEL_72;
  }

  uint64_t v5 = v4;
  if (fstat(v4, &v80))
  {
    if (byte_1000E7D30)
    {
      uint64_t v6 = *__error();
      uint64_t v7 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR)) {
        sub_10008EB74();
      }
      *__error() = v6;
    }

    if (byte_1000E7D31) {
      BOOL v8 = dword_1000E74E0 <= 3;
    }
    else {
      BOOL v8 = 0;
    }
    if (!v8) {
      goto LABEL_92;
    }
    size_t v9 = *__error();
    uint64_t v10 = *__error();
    size_t v11 = __error();
    double v12 = strerror(*v11);
    size_t v13 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"Unable to stat %s: %d (%s)", a3, v10, v12);
    if (!v13)
    {
      BOOL v14 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v14, OS_LOG_TYPE_FAULT)) {
        sub_10008EB00();
      }
LABEL_87:
      if (qword_1000E7D38) {
        v57 = (FILE *)qword_1000E7D38;
      }
      else {
        v57 = __stderrp;
      }
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v57);
LABEL_91:
      *__error() = v9;
LABEL_92:
      close(v5);
      return 0LL;
    }

    goto LABEL_38;
  }

  if (v80.st_size <= 15)
  {
    if (byte_1000E7D30)
    {
      char v27 = *__error();
      int v28 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR)) {
        sub_10008E7A8();
      }
      *__error() = v27;
    }

    if (byte_1000E7D31) {
      v29 = dword_1000E74E0 <= 3;
    }
    else {
      v29 = 0;
    }
    if (!v29) {
      goto LABEL_92;
    }
    size_t v9 = *__error();
    size_t v13 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"%s isn't big enough for a kcdata header (only %lld bytes)",  a3,  v80.st_size);
    if (!v13)
    {
      int v56 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v56, OS_LOG_TYPE_FAULT)) {
        sub_10008E748();
      }
      goto LABEL_87;
    }

      uint64_t v10 = v5;
      CStringPtr = CFStringGetCStringPtr(v5, 0x8000100u);
      if (CStringPtr)
      {
        double v12 = (char *)CStringPtr;
        size_t v13 = 0LL;
      }

      else
      {
        double v12 = (char *)calloc(0x400uLL, 1uLL);
        CFStringGetCString(v10, v12, 1024LL, 0x8000100u);
        size_t v13 = v12;
      }

      if (qword_1000E7D38) {
        BOOL v14 = (FILE *)qword_1000E7D38;
      }
      else {
        BOOL v14 = __stderrp;
      }
      fprintf(v14, "%s\n", v12);
      if (v13) {
        free(v13);
      }
      CFRelease(v10);
      goto LABEL_40;
    }
  }

  else
  {
    tm v17 = *__error();
    uint64_t v18 = (os_log_s *)sub_10002EFA0();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_FAULT)) {
      sub_1000935B4();
    }
    *__error() = v17;
    if (byte_1000E7D31) {
      uint64_t v19 = dword_1000E74E0 <= 4;
    }
    else {
      uint64_t v19 = 0;
    }
    if (v19)
    {
      uint64_t v4 = *__error();
      uint64_t v5 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"shared instance isn't self");
      if (!v5)
      {
        int v20 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v20, OS_LOG_TYPE_FAULT)) {
          sub_100093588();
        }
        goto LABEL_36;
      }

      goto LABEL_25;
    }
  }

LABEL_104:
          -[SASamplePrinter filterToTimestampRangeStart:end:](v74, "filterToTimestampRangeStart:end:", v101, 0LL);
          goto LABEL_105;
        }
      }

      [v77 wallTime];
      if (v84 != 0.0)
      {
        [v77 wallTime];
        double v86 = v85 - a11;
        double v82 = 0.0;
        double v81 = 0.0;
        goto LABEL_97;
      }

      [v77 machAbsTimeSeconds];
      if (v98 != 0.0)
      {
        [v77 machAbsTimeSeconds];
        if (v99 > a11)
        {
          [v77 machAbsTimeSeconds];
          double v82 = v100 - a11;
          double v81 = 0.0;
          goto LABEL_96;
        }
      }

      if (byte_1000E7D30)
      {
        int v131 = *__error();
        uint64_t v132 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v132, OS_LOG_TYPE_ERROR)) {
          sub_100088908(v77, v132, a11);
        }
        *__error() = v131;
      }

      if (byte_1000E7D31 && dword_1000E74E0 <= 3)
      {
        uint64_t v133 = v46;
        int v134 = *__error();
        uint64_t v135 = CFStringCreateWithFormat( kCFAllocatorDefault,  0,  @"-last provided, but unable to calculate %.0f seconds earlier than %@",  *(void *)&a11,  [v77 debugDescription]);
        if (v135)
        {
          uint64_t v136 = v135;
          uint64_t v137 = CFStringGetCStringPtr(v135, 0x8000100u);
          if (v137)
          {
            uint64_t v138 = (char *)v137;
            uint64_t v139 = 0LL;
          }

          else
          {
            uint64_t v138 = (char *)calloc(0x400uLL, 1uLL);
            CFStringGetCString(v136, v138, 1024LL, 0x8000100u);
            uint64_t v139 = v138;
          }

          if (qword_1000E7D38) {
            v228 = (FILE *)qword_1000E7D38;
          }
          else {
            v228 = __stderrp;
          }
          fprintf(v228, "%s\n", v138);
          if (v139) {
            free(v139);
          }
          CFRelease(v136);
        }

        else
        {
          v217 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v217, OS_LOG_TYPE_FAULT)) {
            sub_100088884(v77, v217, a11);
          }
          if (qword_1000E7D38) {
            v218 = (FILE *)qword_1000E7D38;
          }
          else {
            v218 = __stderrp;
          }
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v218);
        }

        *__error() = v134;
        v46 = v133;
      }
    }

    else
    {
      if (byte_1000E7D30)
      {
        int v87 = *__error();
        int v88 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v88, OS_LOG_TYPE_ERROR)) {
          sub_100087E2C(v52, v88);
        }
        *__error() = v87;
      }

      if (byte_1000E7D31 && dword_1000E74E0 <= 3)
      {
        int v89 = *__error();
        uint64_t v90 = CFStringCreateWithFormat( kCFAllocatorDefault,  0,  @"-last provided, but unable to get data end time (%lu samples)",  [v52 numSamples]);
        if (v90)
        {
          int v91 = v90;
          v92 = CFStringGetCStringPtr(v90, 0x8000100u);
          if (v92)
          {
            v93 = (char *)v92;
            v94 = 0LL;
          }

          else
          {
            v93 = (char *)calloc(0x400uLL, 1uLL);
            CFStringGetCString(v91, v93, 1024LL, 0x8000100u);
            v94 = v93;
          }

          if (qword_1000E7D38) {
            int v195 = (FILE *)qword_1000E7D38;
          }
          else {
            int v195 = __stderrp;
          }
          fprintf(v195, "%s\n", v93);
          if (v94) {
            free(v94);
          }
          CFRelease(v91);
        }

        else
        {
          uint64_t v143 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v143, OS_LOG_TYPE_FAULT)) {
            sub_100087DB0(v52, v143);
          }
          if (qword_1000E7D38) {
            uint64_t v144 = (FILE *)qword_1000E7D38;
          }
          else {
            uint64_t v144 = __stderrp;
          }
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v144);
        }

        *__error() = v89;
      }
    }

    goto LABEL_92;
  }

LABEL_105:
  if (v340) {
    objc_msgSend(v52, "addAuxiliaryData:");
  }
  id v104 = objc_msgSend( v52,  "setEvent:",  +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", sub_100025FEC(a16, 0)));
  if (a16 != 5)
  {
    if (a16 != 10 && a16 != 8)
    {
      if (a16 != 6) {
        goto LABEL_114;
      }
      [v52 setBytesWritten:a18];
      [v52 setBytesWrittenLimit:a19];
      [v52 setWriteDuration:a13];
      [v52 setWriteLimitDuration:a15];
      objc_msgSend(-[SASamplePrinter options](v74, "options"), "setPrintSpinSignatureStack:", 1);
    }

    id v104 = [v52 setStepsNote:+[NSString stringWithFormat:]( NSString, "stringWithFormat:", @"%s/step", objc_msgSend((id)SAFormattedBytes(10485760, 0, 0), "UTF8String"))];
    goto LABEL_114;
  }

  [v52 setCpuUsed:a12];
  [v52 setCpuLimit:a14];
  [v52 setCpuDuration:a13];
  [v52 setCpuLimitDuration:a15];
  id v104 = objc_msgSend(-[SASamplePrinter options](v74, "options"), "setPrintSpinSignatureStack:", 1);
LABEL_114:
  if (a9 > 0.0 && a10 > 0.0)
  {
    unsigned int v75 = a16 - 5;
    id v104 = objc_msgSend( v52,  "setEventTimeRange:",  +[SATimeRange timeRangeStart:end:]( SATimeRange,  "timeRangeStart:end:",  +[SATimestamp timestampWithMachAbsTime:machAbsTimeSec:machContTime:machContTimeSec:wallTime:]( SATimestamp,  "timestampWithMachAbsTime:machAbsTimeSec:machContTime:machContTimeSec:wallTime:",  0,  0,  0.0,  0.0,  a9),  +[SATimestamp timestampWithMachAbsTime:machAbsTimeSec:machContTime:machContTimeSec:wallTime:]( SATimestamp,  "timestampWithMachAbsTime:machAbsTimeSec:machContTime:machContTimeSec:wallTime:",  0,  0,  0.0,  0.0,  a10)));
  }

  if (a7)
  {
    v105 = +[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:");
  }

  else
  {
    if (v75 > 1) {
      goto LABEL_122;
    }
    v105 = @"none";
  }

  id v104 = [v52 setActionTaken:v105];
LABEL_122:
  if (a25) {
    id v104 = objc_msgSend( v52,  "setSignature:",  +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", a25));
  }
  if (v66 >= 2) {
    id v104 = [v52 setSanitizePaths:1];
  }
  if (v75 > 1)
  {
    uint64_t v106 = 0LL;
  }

  else
  {
    id v104 = -[SASamplePrinter setIncidentUUID:](v74, "setIncidentUUID:", +[NSUUID UUID](&OBJC_CLASS___NSUUID, "UUID"));
    uint64_t v106 = 5LL;
  }

  -[SASamplePrinter setShareWithAppDevs:](v74, "setShareWithAppDevs:", AppAnalyticsEnabled(v104));
  objc_msgSend(-[SASamplePrinter options](v74, "options"), "setMicrostackshotsFormat:", 1);
  objc_msgSend(-[SASamplePrinter options](v74, "options"), "setOmitTasksBelowPercentOfTotalSamples:", v106);
  if (a26)
  {
    *(void *)buf = 0LL;
    v107 = -[NSData initWithContentsOfFile:options:error:]( objc_alloc(&OBJC_CLASS___NSData),  "initWithContentsOfFile:options:error:",  +[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", a26),  1LL,  buf);
    if (v107)
    {
      if (byte_1000E7D30)
      {
        int v108 = *__error();
        v109 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v109, OS_LOG_TYPE_DEBUG)) {
          sub_100088818();
        }
        *__error() = v108;
      }

      unsigned int v75 = a16 - 5;
      if (!byte_1000E7D31 || dword_1000E74E0 > 0) {
        goto LABEL_201;
      }
      int v110 = v107;
      int v111 = *__error();
      int v112 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"Appending data file %s", a26);
      if (!v112)
      {
        int v113 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v113, OS_LOG_TYPE_FAULT)) {
          sub_1000887B8();
        }
LABEL_196:
        if (qword_1000E7D38) {
          uint64_t v147 = (FILE *)qword_1000E7D38;
        }
        else {
          uint64_t v147 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v147);
LABEL_200:
        *__error() = v111;
        v107 = v110;
LABEL_201:
        uint64_t v114 = a16;
        goto LABEL_202;
      }
    }

    else
    {
      if (byte_1000E7D30)
      {
        int v124 = *__error();
        v125 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v125, OS_LOG_TYPE_ERROR)) {
          sub_10008873C(a26, (id *)buf, v125);
        }
        *__error() = v124;
      }

      unsigned int v75 = a16 - 5;
      if (!byte_1000E7D31 || dword_1000E74E0 > 3) {
        goto LABEL_201;
      }
      int v110 = 0LL;
      int v111 = *__error();
      int v112 = CFStringCreateWithFormat( kCFAllocatorDefault,  0,  @"reading in data file %s failed: %@",  a26,  [*(id *)buf localizedDescription]);
      if (!v112)
      {
        int v146 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v146, OS_LOG_TYPE_FAULT)) {
          sub_1000886C0(a26, (id *)buf, v146);
        }
        goto LABEL_196;
      }
    }

    uint64_t v126 = v112;
    double v127 = v46;
    char v128 = CFStringGetCStringPtr(v112, 0x8000100u);
    if (v128)
    {
      int v129 = (char *)v128;
      v130 = 0LL;
    }

    else
    {
      int v129 = (char *)calloc(0x400uLL, 1uLL);
      CFStringGetCString(v126, v129, 1024LL, 0x8000100u);
      v130 = v129;
    }

    if (qword_1000E7D38) {
      uint64_t v140 = (FILE *)qword_1000E7D38;
    }
    else {
      uint64_t v140 = __stderrp;
    }
    fprintf(v140, "%s\n", v129);
    if (v130) {
      free(v130);
    }
    CFRelease(v126);
    v46 = v127;
    unsigned int v75 = a16 - 5;
    goto LABEL_200;
  }

  uint64_t v114 = a16;
  if (byte_1000E7D30)
  {
    int v115 = *__error();
    v116 = (os_log_s *)sub_10002EFA0();
    if (os_log_type_enabled(v116, OS_LOG_TYPE_DEBUG)) {
      sub_100088694();
    }
    *__error() = v115;
    unsigned int v75 = a16 - 5;
  }

  v107 = 0LL;
  if (byte_1000E7D31 && dword_1000E74E0 <= 0)
  {
    int v117 = *__error();
    v118 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"No file to append");
    if (v118)
    {
      v119 = v118;
      v120 = v46;
      v121 = CFStringGetCStringPtr(v118, 0x8000100u);
      if (v121)
      {
        v122 = (char *)v121;
        v123 = 0LL;
      }

      else
      {
        v122 = (char *)calloc(0x400uLL, 1uLL);
        CFStringGetCString(v119, v122, 1024LL, 0x8000100u);
        v123 = v122;
      }

      if (qword_1000E7D38) {
        uint64_t v145 = (FILE *)qword_1000E7D38;
      }
      else {
        uint64_t v145 = __stderrp;
      }
      fprintf(v145, "%s\n", v122);
      if (v123) {
        free(v123);
      }
      CFRelease(v119);
      v46 = v120;
      unsigned int v75 = a16 - 5;
    }

    else
    {
      int v141 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v141, OS_LOG_TYPE_FAULT)) {
        sub_100088668();
      }
      if (qword_1000E7D38) {
        uint64_t v142 = (FILE *)qword_1000E7D38;
      }
      else {
        uint64_t v142 = __stderrp;
      }
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v142);
    }

    v107 = 0LL;
    *__error() = v117;
    goto LABEL_201;
  }

    v58 = v54;
    int v59 = CFStringGetCStringPtr(v54, 0x8000100u);
    if (v59)
    {
      int v60 = (char *)v59;
      int v61 = 0LL;
    }

    else
    {
      int v60 = (char *)calloc(0x400uLL, 1uLL);
      CFStringGetCString(v58, v60, 1024LL, 0x8000100u);
      int v61 = v60;
    }

    if (qword_1000E7D38) {
      double v78 = (FILE *)qword_1000E7D38;
    }
    else {
      double v78 = __stderrp;
    }
    fprintf(v78, "%s\n", v60);
    if (v61) {
      free(v61);
    }
    CFRelease(v58);
    goto LABEL_153;
  }

LABEL_202:
  if (v75 <= 3)
  {
    if (v75 > 1)
    {
      uint64_t v149 = 0LL;
      double v148 = 0.0;
    }

    else
    {
      objc_msgSend(objc_msgSend(v52, "startTime"), "wallTime");
      uint64_t v149 = a20 & 1;
    }

    int v150 = sub_10004B10C(v74, 0LL, (uint64_t)v107, v114, 0LL, v149, a17, 0LL, v148, a13, 0LL, 0LL);
    goto LABEL_387;
  }

  if (a23)
  {
    -[SASamplePrinter printToStream:](v74, "printToStream:", __stdoutp);
    int v150 = 1;
    goto LABEL_387;
  }

  if (v66 >= 2)
  {
    if ((v342 & 0x80000000) != 0)
    {
      if (byte_1000E7D30)
      {
        int v299 = *__error();
        v300 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v300, OS_LOG_TYPE_ERROR)) {
          sub_1000885F8();
        }
        *__error() = v299;
      }

      if (byte_1000E7D31 && dword_1000E74E0 <= 3)
      {
        int v301 = *__error();
        v302 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"%s: Bad report type %d",  "report_type == DID_MANUAL_MICROSTACKSHOTS_IO || report_type == DID_MANUAL_MICROSTACKSHOTS",  a16);
        if (v302)
        {
          v309 = v302;
          v310 = CFStringGetCStringPtr(v302, 0x8000100u);
          if (v310)
          {
            v311 = (char *)v310;
            v312 = 0LL;
          }

          else
          {
            v311 = (char *)calloc(0x400uLL, 1uLL);
            CFStringGetCString(v309, v311, 1024LL, 0x8000100u);
            v312 = v311;
          }

          if (qword_1000E7D38) {
            v321 = (FILE *)qword_1000E7D38;
          }
          else {
            v321 = __stderrp;
          }
          fprintf(v321, "%s\n", v311);
          if (v312) {
            free(v312);
          }
          CFRelease(v309);
        }

        else
        {
          v303 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v303, OS_LOG_TYPE_FAULT)) {
            sub_100088588();
          }
          if (qword_1000E7D38) {
            v304 = (FILE *)qword_1000E7D38;
          }
          else {
            v304 = __stderrp;
          }
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v304);
        }

        *__error() = v301;
      }

      v338 = "report_type == DID_MANUAL_MICROSTACKSHOTS_IO || report_type == DID_MANUAL_MICROSTACKSHOTS";
      v289 = "%s: Bad report type %d";
    }

    else
    {
      if (byte_1000E7D30)
      {
        int v292 = *__error();
        v293 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v293, OS_LOG_TYPE_ERROR)) {
          sub_100088510();
        }
        *__error() = v292;
      }

      if (byte_1000E7D31 && dword_1000E74E0 <= 3)
      {
        int v294 = *__error();
        v295 = sub_10002EF3C(v342);
        v296 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"%s [%d]: %s: Bad report type %d",  v295,  v342,  "report_type == DID_MANUAL_MICROSTACKSHOTS_IO || report_type == DID_MANUAL_MICROSTACKSHOTS",  a16);
        if (v296)
        {
          v305 = v296;
          v306 = CFStringGetCStringPtr(v296, 0x8000100u);
          if (v306)
          {
            v307 = (char *)v306;
            v308 = 0LL;
          }

          else
          {
            v307 = (char *)calloc(0x400uLL, 1uLL);
            CFStringGetCString(v305, v307, 1024LL, 0x8000100u);
            v308 = v307;
          }

          if (qword_1000E7D38) {
            v320 = (FILE *)qword_1000E7D38;
          }
          else {
            v320 = __stderrp;
          }
          fprintf(v320, "%s\n", v307);
          if (v308) {
            free(v308);
          }
          CFRelease(v305);
        }

        else
        {
          v297 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v297, OS_LOG_TYPE_FAULT)) {
            sub_100088498();
          }
          if (qword_1000E7D38) {
            v298 = (FILE *)qword_1000E7D38;
          }
          else {
            v298 = __stderrp;
          }
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v298);
        }

        *__error() = v294;
      }

      LOBYTE(v338) = sub_10002EF3C(v342);
      v289 = "%s [%d]: %s: Bad report type %d";
    }

    int v291 = 397;
    goto LABEL_446;
  }

  if ((_DWORD)v114 == 9) {
    v151 = "Powerstats";
  }
  else {
    v151 = "IOStats";
  }
  id v346 = 0LL;
  __int16 v152 = v46;
  if (a8) {
    uint64_t v153 = +[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:");
  }
  else {
    uint64_t v153 = 0LL;
  }
  uint64_t v154 = +[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v151);
  uid_t v155 = geteuid();
  int v156 = sub_10004CDE4(v153, v154, 0xFFFFFFFFLL, 1537, v155, 0x1A4u, &v346);
  if (v156 == -1)
  {
    if ((v342 & 0x80000000) != 0)
    {
      if (byte_1000E7D30)
      {
        int v196 = *__error();
        int v197 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v197, OS_LOG_TYPE_ERROR)) {
          sub_10008800C();
        }
        *__error() = v196;
      }

      int v150 = 0;
      if (!byte_1000E7D31 || dword_1000E74E0 > 3) {
        goto LABEL_386;
      }
      int v162 = *__error();
      id v198 = v346;
      uint64_t v199 = *__error();
      v200 = __error();
      v201 = strerror(*v200);
      v202 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"could not open log file %@: %d (%s)",  v198,  v199,  v201);
      if (!v202)
      {
        v234 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v234, OS_LOG_TYPE_FAULT)) {
          sub_100087F98();
        }
        if (qword_1000E7D38) {
          v235 = (FILE *)qword_1000E7D38;
        }
        else {
          v235 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v235);
        goto LABEL_317;
      }

      v179 = v202;
      v203 = CFStringGetCStringPtr(v202, 0x8000100u);
      if (v203)
      {
        v181 = (char *)v203;
        v182 = 0LL;
      }

      else
      {
        v181 = (char *)calloc(0x400uLL, 1uLL);
        CFStringGetCString(v179, v181, 1024LL, 0x8000100u);
        v182 = v181;
      }
    }

    else
    {
      if (byte_1000E7D30)
      {
        int v170 = *__error();
        uint64_t v171 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v171, OS_LOG_TYPE_ERROR)) {
          sub_100087F20(v342, &v346, v171);
        }
        *__error() = v170;
      }

      int v150 = 0;
      if (!byte_1000E7D31 || dword_1000E74E0 > 3) {
        goto LABEL_386;
      }
      v172 = v107;
      int v162 = *__error();
      v173 = sub_10002EF3C(v342);
      id v174 = v346;
      uint64_t v175 = *__error();
      v176 = __error();
      v177 = strerror(*v176);
      v178 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"%s [%d]: could not open log file %@: %d (%s)",  v173,  v342,  v174,  v175,  v177);
      if (!v178)
      {
        v229 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v229, OS_LOG_TYPE_FAULT)) {
          sub_100087EA8(v342, &v346, v229);
        }
        if (qword_1000E7D38) {
          v230 = (FILE *)qword_1000E7D38;
        }
        else {
          v230 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v230);
        int v150 = 0;
        v107 = v172;
        goto LABEL_385;
      }

      v179 = v178;
      v180 = CFStringGetCStringPtr(v178, 0x8000100u);
      if (v180)
      {
        v181 = (char *)v180;
        v182 = 0LL;
      }

      else
      {
        v181 = (char *)calloc(0x400uLL, 1uLL);
        CFStringGetCString(v179, v181, 1024LL, 0x8000100u);
        v182 = v181;
      }

      v107 = v172;
    }

    if (qword_1000E7D38) {
      v231 = (FILE *)qword_1000E7D38;
    }
    else {
      v231 = __stderrp;
    }
    fprintf(v231, "%s\n", v181);
    if (v182) {
      free(v182);
    }
    CFRelease(v179);
LABEL_317:
    int v150 = 0;
    goto LABEL_385;
  }

  int v157 = v156;
  uint64_t v158 = fdopen(v156, "w");
  int v150 = v158 != 0LL;
  if (v158)
  {
    uint64_t v159 = v158;
    -[SASamplePrinter printToStream:](v74, "printToStream:", v158);
    fclose(v159);
    v46 = v152;
    if (byte_1000E7D30)
    {
      int v160 = *__error();
      BOOL v161 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v161, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 138412290;
        *(void *)&uint8_t buf[4] = v346;
        _os_log_impl( (void *)&_mh_execute_header,  v161,  OS_LOG_TYPE_DEFAULT,  "Spindump analysis written to file %@",  buf,  0xCu);
      }

      *__error() = v160;
    }

    if (!byte_1000E7D31 || dword_1000E74E0 > 2) {
      goto LABEL_386;
    }
    int v162 = *__error();
    CFStringRef v163 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"Spindump analysis written to file %@", v346);
    if (!v163)
    {
      v219 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v219, OS_LOG_TYPE_FAULT)) {
        sub_100088080((uint64_t)&v346, v219, v220, v221, v222, v223, v224, v225);
      }
      if (qword_1000E7D38) {
        v226 = (FILE *)qword_1000E7D38;
      }
      else {
        v226 = __stderrp;
      }
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v226);
      goto LABEL_385;
    }

    v164 = v163;
    uint64_t v165 = v107;
    goto LABEL_226;
  }

  v345 = v107;
  if ((v342 & 0x80000000) != 0)
  {
    if (byte_1000E7D30)
    {
      int v204 = *__error();
      v205 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v205, OS_LOG_TYPE_ERROR)) {
        sub_100088424();
      }
      *__error() = v204;
    }

    if (byte_1000E7D31 && dword_1000E74E0 <= 3)
    {
      int v206 = *__error();
      id v207 = v346;
      uint64_t v208 = *__error();
      v209 = __error();
      v210 = strerror(*v209);
      v211 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"could not fdopen log file %@: %d (%s)",  v207,  v208,  v210);
      if (v211)
      {
        v212 = v211;
        int v213 = v206;
        v214 = CFStringGetCStringPtr(v211, 0x8000100u);
        if (v214)
        {
          v215 = (char *)v214;
          v216 = 0LL;
        }

        else
        {
          v215 = (char *)calloc(0x400uLL, 1uLL);
          CFStringGetCString(v212, v215, 1024LL, 0x8000100u);
          v216 = v215;
        }

        if (qword_1000E7D38) {
          v239 = (FILE *)qword_1000E7D38;
        }
        else {
          v239 = __stderrp;
        }
        fprintf(v239, "%s\n", v215);
        if (v216) {
          free(v216);
        }
        CFRelease(v212);
        int v206 = v213;
      }

      else
      {
        v237 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v237, OS_LOG_TYPE_FAULT)) {
          sub_1000883B0();
        }
        if (qword_1000E7D38) {
          v238 = (FILE *)qword_1000E7D38;
        }
        else {
          v238 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v238);
      }

      goto LABEL_352;
    }
  }

  else
  {
    if (byte_1000E7D30)
    {
      int v183 = *__error();
      v184 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v184, OS_LOG_TYPE_ERROR)) {
        sub_100088338(v342, &v346, v184);
      }
      *__error() = v183;
    }

    if (byte_1000E7D31 && dword_1000E74E0 <= 3)
    {
      int v343 = *__error();
      v185 = sub_10002EF3C(v342);
      id v186 = v346;
      uint64_t v187 = *__error();
      v188 = __error();
      int v189 = strerror(*v188);
      __int16 v190 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"%s [%d]: could not fdopen log file %@: %d (%s)",  v185,  v342,  v186,  v187,  v189);
      if (v190)
      {
        int v191 = v190;
        __int16 v192 = CFStringGetCStringPtr(v190, 0x8000100u);
        if (v192)
        {
          int v193 = (char *)v192;
          __int16 v194 = 0LL;
        }

        else
        {
          int v193 = (char *)calloc(0x400uLL, 1uLL);
          CFStringGetCString(v191, v193, 1024LL, 0x8000100u);
          __int16 v194 = v193;
        }

        if (qword_1000E7D38) {
          v236 = (FILE *)qword_1000E7D38;
        }
        else {
          v236 = __stderrp;
        }
        fprintf(v236, "%s\n", v193);
        if (v194) {
          free(v194);
        }
        CFRelease(v191);
      }

      else
      {
        v232 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v232, OS_LOG_TYPE_FAULT)) {
          sub_1000882C0(v342, &v346, v232);
        }
        if (qword_1000E7D38) {
          v233 = (FILE *)qword_1000E7D38;
        }
        else {
          v233 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v233);
      }

      int v206 = v343;
LABEL_352:
      *__error() = v206;
    }
  }

  close(v157);
  if ((v342 & 0x80000000) != 0)
  {
    v46 = v152;
    v107 = v345;
    if (byte_1000E7D30)
    {
      int v252 = *__error();
      v253 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v253, OS_LOG_TYPE_ERROR)) {
        sub_10008824C();
      }
      *__error() = v252;
    }

    if (!byte_1000E7D31 || dword_1000E74E0 > 3) {
      goto LABEL_386;
    }
    uint64_t v165 = v345;
    int v162 = *__error();
    id v254 = v346;
    uint64_t v255 = *__error();
    v256 = __error();
    v257 = strerror(*v256);
    CFStringRef v258 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"could not write to file %@: %d (%s)",  v254,  v255,  v257);
    if (!v258)
    {
      v262 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v262, OS_LOG_TYPE_FAULT)) {
        sub_1000881D8();
      }
      if (qword_1000E7D38) {
        v263 = (FILE *)qword_1000E7D38;
      }
      else {
        v263 = __stderrp;
      }
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v263);
      goto LABEL_293;
    }

    v164 = v258;
LABEL_226:
    uint64_t v166 = v46;
    uint64_t v167 = CFStringGetCStringPtr(v164, 0x8000100u);
    if (v167)
    {
      uint64_t v168 = (char *)v167;
      uint64_t v169 = 0LL;
    }

    else
    {
      uint64_t v168 = (char *)calloc(0x400uLL, 1uLL);
      CFStringGetCString(v164, v168, 1024LL, 0x8000100u);
      uint64_t v169 = v168;
    }

    if (qword_1000E7D38) {
      v227 = (FILE *)qword_1000E7D38;
    }
    else {
      v227 = __stderrp;
    }
    fprintf(v227, "%s\n", v168);
    if (v169) {
      free(v169);
    }
    CFRelease(v164);
    v46 = v166;
LABEL_293:
    v107 = v165;
LABEL_385:
    *__error() = v162;
    goto LABEL_386;
  }

  v46 = v152;
  if (byte_1000E7D30)
  {
    int v240 = *__error();
    v241 = (os_log_s *)sub_10002EFA0();
    if (os_log_type_enabled(v241, OS_LOG_TYPE_ERROR)) {
      sub_100088160(v342, &v346, v241);
    }
    *__error() = v240;
  }

  if (byte_1000E7D31 && dword_1000E74E0 <= 3)
  {
    int v162 = *__error();
    v242 = sub_10002EF3C(v342);
    id v243 = v346;
    uint64_t v244 = *__error();
    v245 = __error();
    v246 = strerror(*v245);
    v247 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"%s [%d]: could not write to file %@: %d (%s)",  v242,  v342,  v243,  v244,  v246);
    if (v247)
    {
      v248 = v247;
      v249 = CFStringGetCStringPtr(v247, 0x8000100u);
      if (v249)
      {
        v250 = (char *)v249;
        v251 = 0LL;
      }

      else
      {
        v250 = (char *)calloc(0x400uLL, 1uLL);
        CFStringGetCString(v248, v250, 1024LL, 0x8000100u);
        v251 = v250;
      }

      v107 = v345;
      if (qword_1000E7D38) {
        v261 = (FILE *)qword_1000E7D38;
      }
      else {
        v261 = __stderrp;
      }
      fprintf(v261, "%s\n", v250);
      if (v251) {
        free(v251);
      }
      CFRelease(v248);
      v46 = v152;
    }

    else
    {
      v259 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v259, OS_LOG_TYPE_FAULT)) {
        sub_1000880E8(v342, &v346, v259);
      }
      if (qword_1000E7D38) {
        v260 = (FILE *)qword_1000E7D38;
      }
      else {
        v260 = __stderrp;
      }
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v260);
      v46 = v152;
      v107 = v345;
    }

    goto LABEL_385;
  }

  v107 = v345;
LABEL_386:

LABEL_387:
  +[SABinary clearCoreSymbolicationCaches](&OBJC_CLASS___SABinary, "clearCoreSymbolicationCaches");

  if (v150) {
    return 0LL;
  }
  else {
    return 0x1000000LL;
  }
}

id sub_100029D0C( char *a1, off_t a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, double a9, double a10, uint64_t a11, uint64_t a12, unsigned int a13, unsigned int a14, uint64_t a15)
{
  uint64_t v15 = a8;
  int v16 = a6;
  int v17 = a5;
  int value = a3;
  if ((a6 & 1) == 0 && (a7 & 1) == 0)
  {
    if (byte_1000E7D30)
    {
      int v151 = *__error();
      __int16 v152 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v152, OS_LOG_TYPE_ERROR)) {
        sub_100087AE0(v152, v153, v154, v155, v156, v157, v158, v159);
      }
      *__error() = v151;
    }

    if (byte_1000E7D31) {
      BOOL v160 = dword_1000E74E0 <= 3;
    }
    else {
      BOOL v160 = 0;
    }
    if (v160)
    {
      int v171 = *__error();
      v172 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"%s: Nothing to do", "report || save");
      v173 = v172;
      if (v172)
      {
        CStringPtr = (char *)CFStringGetCStringPtr(v172, 0x8000100u);
        if (CStringPtr)
        {
          int v196 = 0LL;
        }

        else
        {
          CStringPtr = (char *)calloc(0x400uLL, 1uLL);
          CFStringGetCString(v173, CStringPtr, 1024LL, 0x8000100u);
          int v196 = CStringPtr;
        }

        if (qword_1000E7D38) {
          v211 = (FILE *)qword_1000E7D38;
        }
        else {
          v211 = __stderrp;
        }
        fprintf(v211, "%s\n", CStringPtr);
        if (v196) {
          free(v196);
        }
        CFRelease(v173);
      }

      else
      {
        id v174 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v174, OS_LOG_TYPE_FAULT)) {
          sub_100087A70(v174, v175, v176, v177, v178, v179, v180, v181);
        }
        if (qword_1000E7D38) {
          v182 = (FILE *)qword_1000E7D38;
        }
        else {
          v182 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v182);
      }

      *__error() = v171;
    }

    sub_10002EE78( "_HandleMicrostackshots",  "microstackshot.m",  450,  "%s: Nothing to do",  a5,  a6,  a7,  a8,  (char)"report || save");
    abort();
  }

  int v22 = a7 ^ 1;
  if (!a1 && (v22 & 1) == 0)
  {
    if (byte_1000E7D30)
    {
      int v161 = *__error();
      int v162 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v162, OS_LOG_TYPE_ERROR)) {
        sub_100087A00(v162, v163, v164, v165, v166, v167, v168, v169);
      }
      *__error() = v161;
    }

    if (byte_1000E7D31) {
      BOOL v170 = dword_1000E74E0 <= 3;
    }
    else {
      BOOL v170 = 0;
    }
    if (v170)
    {
      int v183 = *__error();
      v184 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"%s: No datastore path provided for saving",  "!save || datastorePath");
      v185 = v184;
      if (v184)
      {
        int v197 = (char *)CFStringGetCStringPtr(v184, 0x8000100u);
        if (v197)
        {
          id v198 = 0LL;
        }

        else
        {
          int v197 = (char *)calloc(0x400uLL, 1uLL);
          CFStringGetCString(v185, v197, 1024LL, 0x8000100u);
          id v198 = v197;
        }

        if (qword_1000E7D38) {
          v212 = (FILE *)qword_1000E7D38;
        }
        else {
          v212 = __stderrp;
        }
        fprintf(v212, "%s\n", v197);
        if (v198) {
          free(v198);
        }
        CFRelease(v185);
      }

      else
      {
        id v186 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v186, OS_LOG_TYPE_FAULT)) {
          sub_100087990(v186, v187, v188, v189, v190, v191, v192, v193);
        }
        if (qword_1000E7D38) {
          __int16 v194 = (FILE *)qword_1000E7D38;
        }
        else {
          __int16 v194 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v194);
      }

      *__error() = v183;
    }

    sub_10002EE78( "_HandleMicrostackshots",  "microstackshot.m",  451,  "%s: No datastore path provided for saving",  a5,  a6,  a7,  a8,  (char)"!save || datastorePath");
    abort();
  }

  if (a1) {
    int v23 = a6;
  }
  else {
    int v23 = 0;
  }
  if ((v23 & v22) != 1)
  {
    if (!&_systemstats_copy_microstackshots_to_file) {
      return 0LL;
    }
    if (a1 && (_DWORD)a7)
    {
      uid_t v31 = geteuid();
      unsigned int v222 = sub_10002C4A8(a1, 1537, v31, 0x1A4u);
      if (v222 == -1)
      {
        int v221 = v15;
        if (byte_1000E7D30)
        {
          int v32 = *__error();
          int v33 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR)) {
            sub_10008783C();
          }
          *__error() = v32;
        }

        if (byte_1000E7D31 && dword_1000E74E0 <= 3)
        {
          int v216 = *__error();
          uint64_t v34 = *__error();
          __int16 v35 = __error();
          v36 = strerror(*v35);
          int v37 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"Unable to open datastore file %s: %d (%s)",  a1,  v34,  v36);
          theString = v37;
          if (v37)
          {
            v38 = (char *)CFStringGetCStringPtr(v37, 0x8000100u);
            if (v38)
            {
              unsigned int v39 = 0LL;
            }

            else
            {
              v38 = (char *)calloc(0x400uLL, 1uLL);
              CFStringGetCString(theString, v38, 1024LL, 0x8000100u);
              unsigned int v39 = v38;
            }

            if (qword_1000E7D38) {
              id v102 = (FILE *)qword_1000E7D38;
            }
            else {
              id v102 = __stderrp;
            }
            fprintf(v102, "%s\n", v38);
            if (v39) {
              free(v39);
            }
            CFRelease(theString);
          }

          else
          {
            v97 = (os_log_s *)sub_10002EFA0();
            if (os_log_type_enabled(v97, OS_LOG_TYPE_FAULT)) {
              sub_1000877B8();
            }
            if (qword_1000E7D38) {
              double v98 = (FILE *)qword_1000E7D38;
            }
            else {
              double v98 = __stderrp;
            }
            fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v98);
          }

          *__error() = v216;
          LODWORD(v15) = v221;
        }

        if (!v16) {
          return 0LL;
        }
      }

      int v51 = v15;
      if (a2 && lseek(v222, a2, 0) == -1)
      {
        if (byte_1000E7D30)
        {
          int theStringa = *__error();
          id v103 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v103, OS_LOG_TYPE_ERROR)) {
            sub_100087734();
          }
          *__error() = theStringa;
        }

        if (byte_1000E7D31 && dword_1000E74E0 <= 3)
        {
          int v217 = *__error();
          uint64_t v104 = *__error();
          v105 = __error();
          uint64_t v106 = strerror(*v105);
          v107 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"Unable to seek %s to offset %lld: %d (%s)",  a1,  a2,  v104,  v106);
          theStringb = v107;
          if (v107)
          {
            int v108 = (char *)CFStringGetCStringPtr(v107, 0x8000100u);
            if (v108)
            {
              v109 = 0LL;
            }

            else
            {
              int v108 = (char *)calloc(0x400uLL, 1uLL);
              CFStringGetCString(theStringb, v108, 1024LL, 0x8000100u);
              v109 = v108;
            }

            if (qword_1000E7D38) {
              int v113 = (FILE *)qword_1000E7D38;
            }
            else {
              int v113 = __stderrp;
            }
            fprintf(v113, "%s\n", v108);
            if (v109) {
              free(v109);
            }
            CFRelease(theStringb);
          }

          else
          {
            int v110 = (os_log_s *)sub_10002EFA0();
            if (os_log_type_enabled(v110, OS_LOG_TYPE_FAULT)) {
              sub_1000876B0();
            }
            if (qword_1000E7D38) {
              int v111 = (FILE *)qword_1000E7D38;
            }
            else {
              int v111 = __stderrp;
            }
            fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v111);
          }

          *__error() = v217;
        }

        if ((v16 & 1) == 0)
        {
          close(v222);
          return 0LL;
        }
      }

      xpc_object_t empty = xpc_dictionary_create_empty();
      int v115 = empty;
      if (a9 > 0.0) {
        xpc_dictionary_set_uint64(empty, "time", (unint64_t)(kCFAbsoluteTimeIntervalSince1970 + a9));
      }
      systemstats_copy_microstackshots_to_file(v115, v222);
      close(v222);
      xpc_release(v115);
      if ((v16 & 1) == 0) {
        return 0LL;
      }
    }

    else
    {
      int v51 = a8;
      if ((a6 & 1) == 0)
      {
        if (byte_1000E7D30)
        {
          int v52 = *__error();
          id v53 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v53, OS_LOG_TYPE_ERROR)) {
            sub_100087920(v53, v54, v55, v56, v57, v58, v59, v60);
          }
          *__error() = v52;
        }

        if (byte_1000E7D31) {
          BOOL v61 = dword_1000E74E0 <= 3;
        }
        else {
          BOOL v61 = 0;
        }
        if (v61)
        {
          int v199 = *__error();
          v200 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"%s: Didn't already return without report option",  "report");
          v201 = v200;
          if (v200)
          {
            int v213 = (char *)CFStringGetCStringPtr(v200, 0x8000100u);
            if (v213)
            {
              v214 = 0LL;
            }

            else
            {
              int v213 = (char *)calloc(0x400uLL, 1uLL);
              CFStringGetCString(v201, v213, 1024LL, 0x8000100u);
              v214 = v213;
            }

            if (qword_1000E7D38) {
              v215 = (FILE *)qword_1000E7D38;
            }
            else {
              v215 = __stderrp;
            }
            fprintf(v215, "%s\n", v213);
            if (v214) {
              free(v214);
            }
            CFRelease(v201);
          }

          else
          {
            v202 = (os_log_s *)sub_10002EFA0();
            if (os_log_type_enabled(v202, OS_LOG_TYPE_FAULT)) {
              sub_1000878B0(v202, v203, v204, v205, v206, v207, v208, v209);
            }
            if (qword_1000E7D38) {
              v210 = (FILE *)qword_1000E7D38;
            }
            else {
              v210 = __stderrp;
            }
            fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v210);
          }

          *__error() = v199;
        }

        sub_10002EE78( "_HandleMicrostackshots",  "microstackshot.m",  555,  "%s: Didn't already return without report option",  a5,  a6,  a7,  a8,  (char)"report");
        abort();
      }
    }

    v116 = objc_alloc(&OBJC_CLASS___SASampleStore);
    if (v17)
    {
      id v30 = -[SASampleStore initForLiveSampling](v116, "initForLiveSampling");
      [v30 setShouldGatherKextStat:0];
      if (!a11)
      {
LABEL_199:
        if (a12 && *(_DWORD *)a12 && *(_DWORD *)(a12 + 4)) {
          [v30 setMachTimebase:*(void *)a12];
        }
        if (a13) {
          [v30 setHwPageSize:a13];
        }
        if (a14) {
          [v30 setVmPageSize:a14];
        }
        if ((byte_1000E7D44 & 2) != 0 && sub_1000257B8())
        {
          if (byte_1000E7D30)
          {
            int v117 = *__error();
            v118 = (os_log_s *)sub_10002EFA0();
            if (os_log_type_enabled(v118, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)buf = 0;
              _os_log_impl( (void *)&_mh_execute_header,  v118,  OS_LOG_TYPE_DEFAULT,  "Avoiding inspecting live processes for microstackshot report due to audio running",  buf,  2u);
            }

            *__error() = v117;
          }

          if (byte_1000E7D31 && dword_1000E74E0 <= 2)
          {
            int v119 = *__error();
            v120 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"Avoiding inspecting live processes for microstackshot report due to audio running");
            v121 = v120;
            if (v120)
            {
              v122 = (char *)CFStringGetCStringPtr(v120, 0x8000100u);
              if (v122)
              {
                v123 = 0LL;
              }

              else
              {
                v122 = (char *)calloc(0x400uLL, 1uLL);
                CFStringGetCString(v121, v122, 1024LL, 0x8000100u);
                v123 = v122;
              }

              if (qword_1000E7D38) {
                uint64_t v126 = (FILE *)qword_1000E7D38;
              }
              else {
                uint64_t v126 = __stderrp;
              }
              fprintf(v126, "%s\n", v122);
              if (v123) {
                free(v123);
              }
              CFRelease(v121);
            }

            else
            {
              int v124 = (os_log_s *)sub_10002EFA0();
              if (os_log_type_enabled(v124, OS_LOG_TYPE_FAULT)) {
                sub_100087510();
              }
              if (qword_1000E7D38) {
                v125 = (FILE *)qword_1000E7D38;
              }
              else {
                v125 = __stderrp;
              }
              fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v125);
            }

            *__error() = v119;
          }

          objc_msgSend( v30,  "setDataGatheringOptions:",  (unint64_t)objc_msgSend(v30, "dataGatheringOptions") & 0xFFFFFFFFFFFFFFFDLL);
        }

        sub_1000571C4( v30,  (byte_1000E7D44 >> 3) & 1,  (byte_1000E7D44 >> 2) & 1,  (byte_1000E7D44 & 0x10) == 0);
        *(void *)buf = 0LL;
        v237 = buf;
        uint64_t v238 = 0x2020000000LL;
        uint64_t v239 = 0LL;
        v234[0] = 0LL;
        v234[1] = v234;
        v234[2] = 0x2020000000LL;
        int v235 = 0;
        dispatch_semaphore_t v127 = dispatch_semaphore_create(0LL);
        dispatch_retain(v127);
        xpc_object_t v128 = xpc_dictionary_create_empty();
        int v129 = v128;
        if (a9 > 0.0) {
          xpc_dictionary_set_uint64(v128, "time", (unint64_t)(kCFAbsoluteTimeIntervalSince1970 + a9));
        }
        if (value >= 1) {
          xpc_dictionary_set_uint64(v129, "pid", value);
        }
        v130 = dispatch_queue_attr_make_with_autorelease_frequency(0LL, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
        dispatch_queue_t v131 = dispatch_queue_create("com.apple.spindump.microstackshot_parsing", v130);
        dispatch_release(v130);
        dispatch_retain(v131);
        v230[0] = _NSConcreteStackBlock;
        v230[1] = 3221225472LL;
        v230[2] = sub_10002B5E8;
        v230[3] = &unk_1000D9218;
        qos_class_t v231 = qos_class_self();
        int v232 = v51;
        int v233 = value;
        *(double *)&v230[11] = a9;
        *(double *)&v230[12] = a10;
        v230[4] = v30;
        v230[5] = a15;
        v230[7] = v131;
        v230[8] = v234;
        v230[9] = buf;
        v230[10] = a4;
        v230[6] = v127;
        systemstats_get_microstackshots(v129, v230);
        xpc_release(v129);
        uint64_t v226 = 0LL;
        v227 = &v226;
        uint64_t v228 = 0x2020000000LL;
        char v229 = 0;
        do
        {
          dispatch_time_t v132 = dispatch_time(0LL, 30000000000LL);
          if (!dispatch_semaphore_wait(v127, v132)) {
            break;
          }
          value_4[0] = _NSConcreteStackBlock;
          value_4[1] = 3221225472LL;
          value_4[2] = sub_10004AB98;
          value_4[3] = &unk_1000D9240;
          value_4[4] = v234;
          value_4[5] = &v226;
          dispatch_sync(v131, value_4);
        }

        while (!*((_BYTE *)v227 + 24));
        dispatch_release(v127);
        dispatch_release(v131);
        if (*((void *)v237 + 3))
        {
          if (byte_1000E7D30)
          {
            int v133 = *__error();
            int v134 = (os_log_s *)sub_10002EFA0();
            if (os_log_type_enabled(v134, OS_LOG_TYPE_ERROR))
            {
              int v135 = *((_DWORD *)v237 + 6);
              uint64_t v136 = strerror(v135);
              sub_100087674((uint64_t)v136, (uint64_t)v241, v135);
            }

            *__error() = v133;
          }

          if (byte_1000E7D31) {
            BOOL v137 = dword_1000E74E0 <= 3;
          }
          else {
            BOOL v137 = 0;
          }
          if (v137)
          {
            int v138 = *__error();
            uint64_t v139 = *((unsigned int *)v237 + 6);
            uint64_t v140 = strerror(*((_DWORD *)v237 + 6));
            int v141 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"Error grabbing microstackshots: %d (%s)",  v139,  v140);
            uint64_t v142 = v141;
            if (v141)
            {
              uint64_t v143 = (char *)CFStringGetCStringPtr(v141, 0x8000100u);
              if (v143)
              {
                uint64_t v144 = 0LL;
              }

              else
              {
                uint64_t v143 = (char *)calloc(0x400uLL, 1uLL);
                CFStringGetCString(v142, v143, 1024LL, 0x8000100u);
                uint64_t v144 = v143;
              }

              if (qword_1000E7D38) {
                uint64_t v149 = (FILE *)qword_1000E7D38;
              }
              else {
                uint64_t v149 = __stderrp;
              }
              fprintf(v149, "%s\n", v143);
              if (v144) {
                free(v144);
              }
              CFRelease(v142);
            }

            else
            {
              uint64_t v145 = (os_log_s *)sub_10002EFA0();
              if (os_log_type_enabled(v145, OS_LOG_TYPE_FAULT))
              {
                int v146 = *((_DWORD *)v237 + 6);
                uint64_t v147 = strerror(v146);
                sub_100087638((uint64_t)v147, (uint64_t)v240, v146);
              }

              if (qword_1000E7D38) {
                double v148 = (FILE *)qword_1000E7D38;
              }
              else {
                double v148 = __stderrp;
              }
              fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v148);
            }

            *__error() = v138;
          }
        }

        [v30 postprocess];
        _Block_object_dispose(&v226, 8);
        _Block_object_dispose(v234, 8);
        _Block_object_dispose(buf, 8);
        return v30;
      }
    }

    else
    {
      id v30 = -[SASampleStore initForFileParsing](v116, "initForFileParsing");
      if (!a11) {
        goto LABEL_199;
      }
    }

    objc_msgSend( v30,  "setMachineArchitecture:",  +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", a11));
    goto LABEL_199;
  }

  int v25 = open(a1, 0);
  if (v25 != -1)
  {
    int v26 = v25;
    if (a2 && lseek(v25, a2, 0) == -1)
    {
      if (byte_1000E7D30)
      {
        int v79 = *__error();
        double v80 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v80, OS_LOG_TYPE_ERROR)) {
          sub_1000875C0();
        }
        *__error() = v79;
      }

      if (byte_1000E7D31 && dword_1000E74E0 <= 3)
      {
        int v81 = *__error();
        uint64_t v82 = *__error();
        int v83 = __error();
        double v84 = strerror(*v83);
        double v85 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"Unable to seek %s to offset %lld: %d (%s)",  a1,  a2,  v82,  v84);
        double v86 = v85;
        if (v85)
        {
          int v87 = (char *)CFStringGetCStringPtr(v85, 0x8000100u);
          if (v87)
          {
            int v88 = 0LL;
          }

          else
          {
            int v87 = (char *)calloc(0x400uLL, 1uLL);
            CFStringGetCString(v86, v87, 1024LL, 0x8000100u);
            int v88 = v87;
          }

          if (qword_1000E7D38) {
            double v99 = (FILE *)qword_1000E7D38;
          }
          else {
            double v99 = __stderrp;
          }
          fprintf(v99, "%s\n", v87);
          if (v88) {
            free(v88);
          }
          CFRelease(v86);
        }

        else
        {
          v94 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v94, OS_LOG_TYPE_FAULT)) {
            sub_10008753C();
          }
          if (qword_1000E7D38) {
            uint64_t v95 = (FILE *)qword_1000E7D38;
          }
          else {
            uint64_t v95 = __stderrp;
          }
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v95);
        }

        *__error() = v81;
      }
    }

    else
    {
      gzFile v27 = gzdopen(v26, "r");
      if (v27)
      {
        int v28 = v27;
        v29 = objc_alloc(&OBJC_CLASS___SASampleStore);
        if (v17)
        {
          id v30 = -[SASampleStore initForLiveSampling](v29, "initForLiveSampling");
          [v30 setShouldGatherKextStat:0];
          if (!a11)
          {
LABEL_62:
            if (a12 && *(_DWORD *)a12 && *(_DWORD *)(a12 + 4)) {
              [v30 setMachTimebase:*(void *)a12];
            }
            if (a13) {
              [v30 setHwPageSize:a13];
            }
            if (a14) {
              [v30 setVmPageSize:a14];
            }
            if ((byte_1000E7D44 & 2) != 0 && sub_1000257B8())
            {
              if (byte_1000E7D30)
              {
                int v72 = *__error();
                v73 = (os_log_s *)sub_10002EFA0();
                if (os_log_type_enabled(v73, OS_LOG_TYPE_DEFAULT))
                {
                  *(_WORD *)buf = 0;
                  _os_log_impl( (void *)&_mh_execute_header,  v73,  OS_LOG_TYPE_DEFAULT,  "Avoiding inspecting live processes for microstackshot report due to audio running",  buf,  2u);
                }

                *__error() = v72;
              }

              if (byte_1000E7D31 && dword_1000E74E0 <= 2)
              {
                int v74 = *__error();
                unsigned int v75 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"Avoiding inspecting live processes for microstackshot report due to audio running");
                id v76 = v75;
                if (v75)
                {
                  int v77 = (char *)CFStringGetCStringPtr(v75, 0x8000100u);
                  if (v77)
                  {
                    double v78 = 0LL;
                  }

                  else
                  {
                    int v77 = (char *)calloc(0x400uLL, 1uLL);
                    CFStringGetCString(v76, v77, 1024LL, 0x8000100u);
                    double v78 = v77;
                  }

                  if (qword_1000E7D38) {
                    int v112 = (FILE *)qword_1000E7D38;
                  }
                  else {
                    int v112 = __stderrp;
                  }
                  fprintf(v112, "%s\n", v77);
                  if (v78) {
                    free(v78);
                  }
                  CFRelease(v76);
                }

                else
                {
                  double v100 = (os_log_s *)sub_10002EFA0();
                  if (os_log_type_enabled(v100, OS_LOG_TYPE_FAULT)) {
                    sub_100087510();
                  }
                  if (qword_1000E7D38) {
                    v101 = (FILE *)qword_1000E7D38;
                  }
                  else {
                    v101 = __stderrp;
                  }
                  fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v101);
                }

                *__error() = v74;
              }

              objc_msgSend( v30,  "setDataGatheringOptions:",  (unint64_t)objc_msgSend(v30, "dataGatheringOptions") & 0xFFFFFFFFFFFFFFFDLL);
            }

            sub_1000571C4( v30,  (byte_1000E7D44 >> 3) & 1,  (byte_1000E7D44 >> 2) & 1,  (byte_1000E7D44 & 0x10) == 0);
            sub_10002B6C8(v30, v28, 0LL, 0LL, v15, value, a4, a15, a9, a10);
            gzclose(v28);
            [v30 postprocess];
            return v30;
          }
        }

        else
        {
          id v30 = -[SASampleStore initForFileParsing](v29, "initForFileParsing");
          if (!a11) {
            goto LABEL_62;
          }
        }

        objc_msgSend( v30,  "setMachineArchitecture:",  +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", a11));
        goto LABEL_62;
      }

      if (byte_1000E7D30)
      {
        int v62 = *__error();
        v63 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v63, OS_LOG_TYPE_ERROR)) {
          sub_10008749C();
        }
        *__error() = v62;
      }

      if (byte_1000E7D31 && dword_1000E74E0 <= 3)
      {
        int v64 = *__error();
        uint64_t v65 = *__error();
        unsigned int v66 = __error();
        v67 = strerror(*v66);
        BOOL v68 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"Unable to gzdopen datastore file %s: %d (%s)",  a1,  v65,  v67);
        id v69 = v68;
        if (v68)
        {
          id v70 = (char *)CFStringGetCStringPtr(v68, 0x8000100u);
          if (v70)
          {
            uint64_t v71 = 0LL;
          }

          else
          {
            id v70 = (char *)calloc(0x400uLL, 1uLL);
            CFStringGetCString(v69, v70, 1024LL, 0x8000100u);
            uint64_t v71 = v70;
          }

          if (qword_1000E7D38) {
            v96 = (FILE *)qword_1000E7D38;
          }
          else {
            v96 = __stderrp;
          }
          fprintf(v96, "%s\n", v70);
          if (v71) {
            free(v71);
          }
          CFRelease(v69);
        }

        else
        {
          v92 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v92, OS_LOG_TYPE_FAULT)) {
            sub_100087418();
          }
          if (qword_1000E7D38) {
            v93 = (FILE *)qword_1000E7D38;
          }
          else {
            v93 = __stderrp;
          }
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v93);
        }

        *__error() = v64;
      }
    }

    close(v26);
    return 0LL;
  }

  if (byte_1000E7D30)
  {
    int v40 = *__error();
    v41 = (os_log_s *)sub_10002EFA0();
    if (os_log_type_enabled(v41, OS_LOG_TYPE_ERROR)) {
      sub_1000873A4();
    }
    *__error() = v40;
  }

  if (byte_1000E7D31) {
    BOOL v42 = dword_1000E74E0 <= 3;
  }
  else {
    BOOL v42 = 0;
  }
  if (!v42) {
    return 0LL;
  }
  int v43 = *__error();
  uint64_t v44 = *__error();
  id v45 = __error();
  v46 = strerror(*v45);
  id v47 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"Unable to open %s: %d (%s)", a1, v44, v46);
  uint64_t v48 = v47;
  if (v47)
  {
    int v49 = (char *)CFStringGetCStringPtr(v47, 0x8000100u);
    if (v49)
    {
      int v50 = 0LL;
    }

    else
    {
      int v49 = (char *)calloc(0x400uLL, 1uLL);
      CFStringGetCString(v48, v49, 1024LL, 0x8000100u);
      int v50 = v49;
    }

    if (qword_1000E7D38) {
      int v91 = (FILE *)qword_1000E7D38;
    }
    else {
      int v91 = __stderrp;
    }
    fprintf(v91, "%s\n", v49);
    if (v50) {
      free(v50);
    }
    CFRelease(v48);
  }

  else
  {
    int v89 = (os_log_s *)sub_10002EFA0();
    if (os_log_type_enabled(v89, OS_LOG_TYPE_FAULT)) {
      sub_100087320();
    }
    if (qword_1000E7D38) {
      uint64_t v90 = (FILE *)qword_1000E7D38;
    }
    else {
      uint64_t v90 = __stderrp;
    }
    fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v90);
  }

  id v30 = 0LL;
  *__error() = v43;
  return v30;
}

void sub_10002B580( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, char a26)
{
}

void sub_10002B5E8(uint64_t a1, int a2, uint64_t a3, int a4)
{
  if (a4 != 54)
  {
    uint64_t v19 = v4;
    uint64_t v20 = v5;
    dispatch_qos_class_t v8 = *(_DWORD *)(a1 + 104);
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472LL;
    block[2] = sub_10004A92C;
    block[3] = &unk_1000D91F0;
    block[4] = a3;
    uint64_t v16 = *(void *)(a1 + 108);
    uint64_t v14 = *(void *)(a1 + 80);
    __int128 v15 = *(_OWORD *)(a1 + 88);
    __int128 v11 = *(_OWORD *)(a1 + 32);
    char v18 = a2;
    __int128 v13 = *(_OWORD *)(a1 + 64);
    int v17 = a4;
    uint64_t v12 = *(void *)(a1 + 48);
    dispatch_block_t v9 = dispatch_block_create_with_qos_class((dispatch_block_flags_t)0LL, v8, 0, block);
    dispatch_sync(*(dispatch_queue_t *)(a1 + 56), v9);
    _Block_release(v9);
    if (a2)
    {
      dispatch_release(*(dispatch_object_t *)(a1 + 56));
      dispatch_release(*(dispatch_object_t *)(a1 + 48));
    }
  }

void sub_10002B6C8( void *a1, gzFile_s *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, double a9, double a10)
{
  uint64_t v10 = (void *)a8;
  uint64_t v13 = a7;
  if (a3)
  {
    int v17 = -[NSData initWithBytesNoCopy:length:freeWhenDone:]( objc_alloc(&OBJC_CLASS___NSData),  "initWithBytesNoCopy:length:freeWhenDone:",  a3,  a4,  0LL);
    unint64_t v18 = (unint64_t)[a1 addMicrostackshotsFromData:v17 ofTypes:a5 inTimeRangeStart:a6 end:v13 onlyPid:v10 onlyTid:a9 statistics:a10];

    if ((v18 & 0x8000000000000000LL) == 0) {
      return;
    }
    if (byte_1000E7D30)
    {
      int v19 = *__error();
      uint64_t v20 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR)) {
        sub_100088C68();
      }
      *__error() = v19;
    }

    if (!byte_1000E7D31 || dword_1000E74E0 > 3) {
      return;
    }
    int v22 = *__error();
    int v23 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"Data does not contain microstackshots");
    if (!v23)
    {
      uid_t v24 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v24, OS_LOG_TYPE_FAULT)) {
        sub_100088C3C();
      }
LABEL_112:
      if (qword_1000E7D38) {
        int v89 = (FILE *)qword_1000E7D38;
      }
      else {
        int v89 = __stderrp;
      }
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v89);
LABEL_116:
      *__error() = v22;
      return;
    }

    goto LABEL_101;
  }

  if (!a2)
  {
    if (byte_1000E7D30)
    {
      int v100 = *__error();
      v101 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v101, OS_LOG_TYPE_ERROR)) {
        sub_100088BCC(v101, v102, v103, v104, v105, v106, v107, v108);
      }
      *__error() = v100;
    }

    if (byte_1000E7D31) {
      BOOL v109 = dword_1000E74E0 <= 3;
    }
    else {
      BOOL v109 = 0;
    }
    if (v109)
    {
      int v110 = *__error();
      int v111 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"%s: No tracebuf nor gzfile", "gzfile");
      if (v111)
      {
        dispatch_semaphore_t v127 = v111;
        CStringPtr = CFStringGetCStringPtr(v111, 0x8000100u);
        if (CStringPtr)
        {
          int v129 = (char *)CStringPtr;
          v130 = 0LL;
        }

        else
        {
          int v129 = (char *)calloc(0x400uLL, 1uLL);
          CFStringGetCString(v127, v129, 1024LL, 0x8000100u);
          v130 = v129;
        }

        if (qword_1000E7D38) {
          dispatch_queue_t v131 = (FILE *)qword_1000E7D38;
        }
        else {
          dispatch_queue_t v131 = __stderrp;
        }
        fprintf(v131, "%s\n", v129);
        if (v130) {
          free(v130);
        }
        CFRelease(v127);
      }

      else
      {
        int v112 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v112, OS_LOG_TYPE_FAULT)) {
          sub_100088B5C(v112, v113, v114, v115, v116, v117, v118, v119);
        }
        if (qword_1000E7D38) {
          v120 = (FILE *)qword_1000E7D38;
        }
        else {
          v120 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v120);
      }

      *__error() = v110;
    }

    sub_10002EE78( "_ParseMicrostackshot",  "microstackshot.m",  699,  "%s: No tracebuf nor gzfile",  a5,  a6,  a7,  a8,  (char)"gzfile");
LABEL_180:
    abort();
  }

  unsigned int v132 = a5;
  uint64_t v26 = (char *)calloc(1uLL, 0x20000uLL);
  unint64_t v27 = 0x20000LL;
  int v28 = v26;
  char v29 = 0;
  size_t v30 = 0LL;
  while (1)
  {
    unint64_t v31 = v27;
    int v32 = gzread(a2, &v28[v30], v27 - v30);
    char v133 = v29;
    if (v32 <= 0) {
      break;
    }
    size_t v33 = v30 + v32;
    uint64_t v34 = -[NSData initWithBytesNoCopy:length:freeWhenDone:]( objc_alloc(&OBJC_CLASS___NSData),  "initWithBytesNoCopy:length:freeWhenDone:",  v28,  v33,  0LL);
    uint64_t v35 = v13;
    uint64_t v36 = v13;
    int v37 = v10;
    unint64_t v38 = (unint64_t)[a1 addMicrostackshotsFromData:v34 ofTypes:v132 inTimeRangeStart:a6 end:v36 onlyPid:v10 onlyTid:a9 statistics:a10];

    if ((v38 & 0x8000000000000000LL) != 0) {
      goto LABEL_90;
    }
    size_t v30 = v33 - v38;
    if (!v30) {
      goto LABEL_22;
    }
    if (v38)
    {
      memmove(v28, &v28[v38], v30);
LABEL_22:
      unint64_t v27 = v31;
      goto LABEL_25;
    }

    size_t v43 = 2 * v31;
    uint64_t v44 = (char *)reallocf(v28, v43);
    if (!v44)
    {
      if (byte_1000E7D30)
      {
        int v90 = *__error();
        int v91 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v91, OS_LOG_TYPE_ERROR)) {
          sub_100088FDC();
        }
        *__error() = v90;
      }

      if (byte_1000E7D31 && dword_1000E74E0 <= 3)
      {
        int v92 = *__error();
        v93 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"%s: realloc to %lu failed", "buf", v43);
        if (v93)
        {
          v122 = v93;
          v123 = CFStringGetCStringPtr(v93, 0x8000100u);
          if (v123)
          {
            int v124 = (char *)v123;
            v125 = 0LL;
          }

          else
          {
            int v124 = (char *)calloc(0x400uLL, 1uLL);
            CFStringGetCString(v122, v124, 1024LL, 0x8000100u);
            v125 = v124;
          }

          if (qword_1000E7D38) {
            uint64_t v126 = (FILE *)qword_1000E7D38;
          }
          else {
            uint64_t v126 = __stderrp;
          }
          fprintf(v126, "%s\n", v124);
          if (v125) {
            free(v125);
          }
          CFRelease(v122);
        }

        else
        {
          v94 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v94, OS_LOG_TYPE_FAULT)) {
            sub_100088F6C();
          }
          if (qword_1000E7D38) {
            uint64_t v95 = (FILE *)qword_1000E7D38;
          }
          else {
            uint64_t v95 = __stderrp;
          }
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v95);
        }

        *__error() = v92;
      }

      sub_10002EE78( "_ParseMicrostackshot",  "microstackshot.m",  750,  "%s: realloc to %lu failed",  v39,  v40,  v41,  v42,  (char)"buf");
      goto LABEL_180;
    }

    int v28 = v44;
    unint64_t v27 = v43;
LABEL_25:
    char v29 = 1;
    uint64_t v10 = v37;
    uint64_t v13 = v35;
    if (v30 >= v27)
    {
      if (byte_1000E7D30)
      {
        unint64_t v45 = v27;
        int v46 = *__error();
        id v47 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v47, OS_LOG_TYPE_ERROR)) {
          sub_100088EEC();
        }
        *__error() = v46;
        unint64_t v27 = v45;
      }

      if (byte_1000E7D31 && dword_1000E74E0 <= 3)
      {
        unint64_t v48 = v27;
        int v49 = *__error();
        int v50 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"%s: buf %lu, cap %lu",  "bufLength < bufCapacity",  v30,  v48);
        if (v50)
        {
          v96 = v50;
          v97 = CFStringGetCStringPtr(v50, 0x8000100u);
          if (v97)
          {
            double v98 = (char *)v97;
            double v99 = 0LL;
          }

          else
          {
            double v98 = (char *)calloc(0x400uLL, 1uLL);
            CFStringGetCString(v96, v98, 1024LL, 0x8000100u);
            double v99 = v98;
          }

          if (qword_1000E7D38) {
            v121 = (FILE *)qword_1000E7D38;
          }
          else {
            v121 = __stderrp;
          }
          fprintf(v121, "%s\n", v98);
          if (v99) {
            free(v99);
          }
          CFRelease(v96);
        }

        else
        {
          int v51 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v51, OS_LOG_TYPE_FAULT)) {
            sub_100088E6C();
          }
          if (qword_1000E7D38) {
            int v52 = (FILE *)qword_1000E7D38;
          }
          else {
            int v52 = __stderrp;
          }
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v52);
        }

        *__error() = v49;
      }

      sub_10002EE78( "_ParseMicrostackshot",  "microstackshot.m",  753,  "%s: buf %lu, cap %lu",  v39,  v40,  v41,  v42,  (char)"bufLength < bufCapacity");
      goto LABEL_180;
    }
  }

  if (v32 != -1)
  {
    objc_msgSend(v10, "setBytes_not_microstackshots:", (char *)objc_msgSend(v10, "bytes_not_microstackshots") + v30);
    goto LABEL_90;
  }

  int errnum = 0;
  id v53 = gzerror(a2, &errnum);
  if (errnum != -1)
  {
    uint64_t v54 = (uint64_t)v53;
    if (byte_1000E7D30)
    {
      int v55 = *__error();
      uint64_t v56 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v56, OS_LOG_TYPE_ERROR)) {
        sub_100088DF0(&errnum, v54, v56);
      }
      *__error() = v55;
    }

    if (byte_1000E7D31) {
      BOOL v57 = dword_1000E74E0 <= 3;
    }
    else {
      BOOL v57 = 0;
    }
    if (!v57) {
      goto LABEL_90;
    }
    int v58 = *__error();
    uint64_t v59 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"Read failed for microstackshots: %d (%s)",  errnum,  v54);
    if (v59)
    {
      uint64_t v60 = v59;
      BOOL v61 = CFStringGetCStringPtr(v59, 0x8000100u);
      if (v61)
      {
        int v62 = (char *)v61;
        v63 = 0LL;
      }

      else
      {
        int v62 = (char *)calloc(0x400uLL, 1uLL);
        CFStringGetCString(v60, v62, 1024LL, 0x8000100u);
        v63 = v62;
      }

      if (qword_1000E7D38) {
        unsigned int v75 = (FILE *)qword_1000E7D38;
      }
      else {
        unsigned int v75 = __stderrp;
      }
      fprintf(v75, "%s\n", v62);
      if (v63) {
        free(v63);
      }
      id v76 = v60;
      goto LABEL_88;
    }

    int v74 = (os_log_s *)sub_10002EFA0();
    if (os_log_type_enabled(v74, OS_LOG_TYPE_FAULT)) {
      sub_100088D74(&errnum, v54, v74);
    }
LABEL_77:
    if (qword_1000E7D38) {
      double v78 = (FILE *)qword_1000E7D38;
    }
    else {
      double v78 = __stderrp;
    }
    fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v78);
    goto LABEL_89;
  }

  int errnum = *__error();
  if (byte_1000E7D30)
  {
    int v64 = *__error();
    uint64_t v65 = (os_log_s *)sub_10002EFA0();
    if (os_log_type_enabled(v65, OS_LOG_TYPE_ERROR)) {
      sub_100088D04(&errnum, v65);
    }
    *__error() = v64;
  }

  if (byte_1000E7D31) {
    BOOL v66 = dword_1000E74E0 <= 3;
  }
  else {
    BOOL v66 = 0;
  }
  if (v66)
  {
    int v58 = *__error();
    uint64_t v67 = errnum;
    BOOL v68 = strerror(errnum);
    id v69 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"Read failed for microstackshots: %d (%s)",  v67,  v68);
    if (!v69)
    {
      int v77 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v77, OS_LOG_TYPE_FAULT)) {
        sub_100088C94(&errnum, v77);
      }
      goto LABEL_77;
    }

    id v70 = v69;
    uint64_t v71 = CFStringGetCStringPtr(v69, 0x8000100u);
    if (v71)
    {
      int v72 = (char *)v71;
      v73 = 0LL;
    }

    else
    {
      int v72 = (char *)calloc(0x400uLL, 1uLL);
      CFStringGetCString(v70, v72, 1024LL, 0x8000100u);
      v73 = v72;
    }

    if (qword_1000E7D38) {
      int v79 = (FILE *)qword_1000E7D38;
    }
    else {
      int v79 = __stderrp;
    }
    fprintf(v79, "%s\n", v72);
    if (v73) {
      free(v73);
    }
    id v76 = v70;
LABEL_88:
    CFRelease(v76);
LABEL_89:
    *__error() = v58;
  }

LABEL_90:
  if ((v133 & 1) == 0)
  {
    if (byte_1000E7D30)
    {
      int v80 = *__error();
      int v81 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v81, OS_LOG_TYPE_ERROR)) {
        sub_100088C68();
      }
      *__error() = v80;
    }

    if (byte_1000E7D31 && dword_1000E74E0 <= 3)
    {
      int v22 = *__error();
      int v23 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"Data does not contain microstackshots");
      if (!v23)
      {
        int v88 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v88, OS_LOG_TYPE_FAULT)) {
          sub_100088C3C();
        }
        goto LABEL_112;
      }

LABEL_101:
      int v83 = v23;
      double v84 = CFStringGetCStringPtr(v23, 0x8000100u);
      if (v84)
      {
        double v85 = (char *)v84;
        double v86 = 0LL;
      }

      else
      {
        double v85 = (char *)calloc(0x400uLL, 1uLL);
        CFStringGetCString(v83, v85, 1024LL, 0x8000100u);
        double v86 = v85;
      }

      if (qword_1000E7D38) {
        int v87 = (FILE *)qword_1000E7D38;
      }
      else {
        int v87 = __stderrp;
      }
      fprintf(v87, "%s\n", v85);
      if (v86) {
        free(v86);
      }
      CFRelease(v83);
      goto LABEL_116;
    }
  }

uint64_t sub_10002C310(char *a1, int a2, double a3, double a4)
{
  uint64_t v8 = a2;
  int v9 = snprintf(a1, a2, "Start time:      ");
  uint64_t v10 = &a1[v9];
  __int128 v11 = &a1[a2];
  if (v9 < a2) {
    v10 += sub_100025E98(&a1[v9], v8 - v9, 0, a3);
  }
  if (v10 < v11) {
    v10 += snprintf(v10, &a1[v8] - v10, "\nEnd time:        ");
  }
  if (v10 < v11) {
    v10 += sub_100025E98(v10, &a1[v8] - v10, 0, a4);
  }
  if (v10 < v11) {
    LODWORD(v10) = (_DWORD)v10 + snprintf(v10, &a1[v8] - v10, "\n");
  }
  return ((_DWORD)v10 - (_DWORD)a1);
}

BOOL sub_10002C400(const char *a1)
{
  return lstat(a1, &v2) == 0;
}

BOOL sub_10002C428()
{
  byte_1000E7D44 = byte_1000E7D44 & 0xFC | 1;
  if (sub_10002C400("/var/db/.spindump_enable_symbolication")) {
    char v0 = 8;
  }
  else {
    char v0 = 16;
  }
  byte_1000E7D44 = v0 | byte_1000E7D44 & 0xE3;
  BOOL result = sub_10002C400("/var/db/.spindump_disable_exclaves");
  if (result) {
    char v2 = 32;
  }
  else {
    char v2 = 0;
  }
  byte_1000E7D44 = byte_1000E7D44 & 0xDF | v2;
  return result;
}

uint64_t sub_10002C4A8(const char *a1, int a2, int a3, unsigned int a4)
{
  __int16 v6 = a2;
  if ((a2 & 0x200) != 0) {
    int v8 = -3585;
  }
  else {
    int v8 = -1025;
  }
  int v9 = v8 & a2;
  if ((lstat(a1, &v16) & 0x80000000) == 0)
  {
    if ((v16.st_mode & 0xF000) == 0x8000 && v16.st_nlink == 1 && v16.st_uid == a3 && (v16.st_mode & 0xFFF) == a4)
    {
      uint64_t v11 = open(a1, v9, 0LL);
      if ((v11 & 0x80000000) == 0)
      {
        uint64_t v12 = v11;
        if (!fstat(v11, &v17)
          && v17.st_nlink == v16.st_nlink
          && v17.st_uid == v16.st_uid
          && v17.st_mode == v16.st_mode
          && v17.st_ino == v16.st_ino
          && v17.st_dev == v16.st_dev)
        {
          if ((v6 & 0x400) != 0) {
            ftruncate(v12, 0LL);
          }
          return v12;
        }

        close(v12);
      }
    }

    return 0xFFFFFFFFLL;
  }

  uint64_t v13 = __error();
  uint64_t v12 = 0xFFFFFFFFLL;
  if ((v6 & 0x200) != 0 && *v13 == 2)
  {
    int v14 = open(a1, v9 | 0xA00, a4);
    if (v14 < 0) {
      return 0xFFFFFFFFLL;
    }
    else {
      return v14;
    }
  }

  return v12;
}

void sub_10002C60C(const char *a1)
{
  __endptr = 0LL;
  uint64_t v2 = strtol(a1, &__endptr, 0);
  if (__endptr != a1 && !*__endptr)
  {
    uint64_t v10 = v2;
    if (byte_1000E7D30)
    {
      int v11 = *__error();
      uint64_t v12 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG)) {
        sub_10008C2CC();
      }
      *__error() = v11;
    }

    if (byte_1000E7D31) {
      BOOL v13 = dword_1000E74E0 <= 0;
    }
    else {
      BOOL v13 = 0;
    }
    if (v13)
    {
      int v14 = *__error();
      __int128 v15 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"Found unix timestamp %ld", v10);
      if (v15)
      {
        stat v16 = v15;
        CStringPtr = CFStringGetCStringPtr(v15, 0x8000100u);
        if (CStringPtr)
        {
          unint64_t v18 = (char *)CStringPtr;
          int v19 = 0LL;
        }

        else
        {
          unint64_t v18 = (char *)calloc(0x400uLL, 1uLL);
          CFStringGetCString(v16, v18, 1024LL, 0x8000100u);
          int v19 = v18;
        }

        if (qword_1000E7D38) {
          int v74 = (FILE *)qword_1000E7D38;
        }
        else {
          int v74 = __stderrp;
        }
        fprintf(v74, "%s\n", v18);
        if (v19) {
          free(v19);
        }
        CFRelease(v16);
      }

      else
      {
        uint64_t v56 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v56, OS_LOG_TYPE_FAULT)) {
          sub_10008C268();
        }
        if (qword_1000E7D38) {
          BOOL v57 = (FILE *)qword_1000E7D38;
        }
        else {
          BOOL v57 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v57);
      }

      *__error() = v14;
    }

    return;
  }

  memset(&v114, 0, sizeof(v114));
  v114.tm_isdst = -1;
  BOOL v3 = strptime(a1, "%Y-%m-%d %T %z", &v114);
  __endptr = v3;
  if (v3 && !*v3)
  {
    time_t v20 = mktime(&v114);
    if (byte_1000E7D30)
    {
      int v21 = *__error();
      int v22 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v22, OS_LOG_TYPE_DEBUG)) {
        sub_10008C208();
      }
      *__error() = v21;
    }

    if (byte_1000E7D31) {
      BOOL v23 = dword_1000E74E0 <= 0;
    }
    else {
      BOOL v23 = 0;
    }
    if (!v23) {
      return;
    }
    int v24 = *__error();
    int v25 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"Found ISO timestamp with time zone number %ld",  v20);
    if (v25) {
      goto LABEL_68;
    }
    uint64_t v26 = (os_log_s *)sub_10002EFA0();
    if (!os_log_type_enabled(v26, OS_LOG_TYPE_FAULT)) {
      goto LABEL_144;
    }
    goto LABEL_39;
  }

  uint64_t v4 = strptime(a1, "%Y-%m-%dT%T %z", &v114);
  if (v4 && !*v4)
  {
    time_t v27 = mktime(&v114);
    if (byte_1000E7D30)
    {
      int v28 = *__error();
      char v29 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v29, OS_LOG_TYPE_DEBUG)) {
        sub_10008C208();
      }
      *__error() = v28;
    }

    if (byte_1000E7D31) {
      BOOL v30 = dword_1000E74E0 <= 0;
    }
    else {
      BOOL v30 = 0;
    }
    if (!v30) {
      return;
    }
    int v24 = *__error();
    int v25 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"Found ISO timestamp with time zone number %ld",  v27);
    if (v25) {
      goto LABEL_68;
    }
    unint64_t v31 = (os_log_s *)sub_10002EFA0();
    if (!os_log_type_enabled(v31, OS_LOG_TYPE_FAULT)) {
      goto LABEL_144;
    }
LABEL_39:
    sub_10008C1A4();
    goto LABEL_144;
  }

  uint64_t v5 = strptime(a1, "%Y-%m-%d %T %Z", &v114);
  __endptr = v5;
  if (v5 && !*v5)
  {
    time_t v32 = mktime(&v114);
    if (byte_1000E7D30)
    {
      int v33 = *__error();
      uint64_t v34 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v34, OS_LOG_TYPE_DEBUG)) {
        sub_10008C144();
      }
      *__error() = v33;
    }

    if (!byte_1000E7D31 || dword_1000E74E0 > 0) {
      return;
    }
    int v24 = *__error();
    int v25 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"Found ISO timestamp with time zone name %ld", v32);
    if (v25) {
      goto LABEL_68;
    }
    uint64_t v35 = (os_log_s *)sub_10002EFA0();
    if (os_log_type_enabled(v35, OS_LOG_TYPE_FAULT)) {
LABEL_143:
    }
      sub_10008C0E0();
LABEL_144:
    if (qword_1000E7D38) {
      double v78 = (FILE *)qword_1000E7D38;
    }
    else {
      double v78 = __stderrp;
    }
    fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v78);
LABEL_148:
    *__error() = v24;
    return;
  }

  __int16 v6 = strptime(a1, "%Y-%m-%dT%T %Z", &v114);
  if (v6 && !*v6)
  {
    time_t v36 = mktime(&v114);
    if (byte_1000E7D30)
    {
      int v37 = *__error();
      unint64_t v38 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v38, OS_LOG_TYPE_DEBUG)) {
        sub_10008C144();
      }
      *__error() = v37;
    }

    if (!byte_1000E7D31 || dword_1000E74E0 > 0) {
      return;
    }
    int v24 = *__error();
    int v25 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"Found ISO timestamp with time zone name %ld", v36);
    if (v25)
    {
LABEL_68:
      uint64_t v39 = v25;
      uint64_t v40 = CFStringGetCStringPtr(v25, 0x8000100u);
      if (v40)
      {
        uint64_t v41 = (char *)v40;
        uint64_t v42 = 0LL;
      }

      else
      {
        uint64_t v41 = (char *)calloc(0x400uLL, 1uLL);
        CFStringGetCString(v39, v41, 1024LL, 0x8000100u);
        uint64_t v42 = v41;
      }

      if (qword_1000E7D38) {
        int v55 = (FILE *)qword_1000E7D38;
      }
      else {
        int v55 = __stderrp;
      }
      fprintf(v55, "%s\n", v41);
      if (v42) {
        free(v42);
      }
      CFRelease(v39);
      goto LABEL_148;
    }

    int v77 = (os_log_s *)sub_10002EFA0();
    if (os_log_type_enabled(v77, OS_LOG_TYPE_FAULT)) {
      goto LABEL_143;
    }
    goto LABEL_144;
  }

  uint64_t v7 = strptime(a1, "%Y-%m-%d %T", &v114);
  __endptr = v7;
  if (v7 || (uint64_t v7 = strptime(a1, "%Y-%m-%dT%T", &v114), (__endptr = v7) != 0LL))
  {
    if (*v7 == 46)
    {
      *(void *)&v116[0] = 0LL;
      double v47 = strtod(v7 - 2, (char **)v116);
      if (*(void *)&v116[0] <= (unint64_t)v7)
      {
        if (byte_1000E7D30)
        {
          int v100 = *__error();
          v101 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v101, OS_LOG_TYPE_ERROR)) {
            sub_10008C05C();
          }
          *__error() = v100;
        }

        if (byte_1000E7D31 && dword_1000E74E0 <= 3)
        {
          int v102 = *__error();
          uint64_t v103 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"%s: endOfSecs %p endPtr %p",  "endOfSecs && endOfSecs > endptr",  *(void *)&v116[0],  v7);
          if (v103)
          {
            uint64_t v106 = v103;
            uint64_t v107 = CFStringGetCStringPtr(v103, 0x8000100u);
            if (v107)
            {
              uint64_t v108 = (char *)v107;
              BOOL v109 = 0LL;
            }

            else
            {
              uint64_t v108 = (char *)calloc(0x400uLL, 1uLL);
              CFStringGetCString(v106, v108, 1024LL, 0x8000100u);
              BOOL v109 = v108;
            }

            if (qword_1000E7D38) {
              int v110 = (FILE *)qword_1000E7D38;
            }
            else {
              int v110 = __stderrp;
            }
            fprintf(v110, "%s\n", v108);
            if (v109) {
              free(v109);
            }
            CFRelease(v106);
          }

          else
          {
            uint64_t v104 = (os_log_s *)sub_10002EFA0();
            if (os_log_type_enabled(v104, OS_LOG_TYPE_FAULT)) {
              sub_10008BFD8();
            }
            if (qword_1000E7D38) {
              uint64_t v105 = (FILE *)qword_1000E7D38;
            }
            else {
              uint64_t v105 = __stderrp;
            }
            fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v105);
          }

          *__error() = v102;
        }

        sub_10002EE78( "TimeFromString",  "spindump.m",  4001,  "%s: endOfSecs %p endPtr %p",  v43,  v44,  v45,  v46,  (char)"endOfSecs && endOfSecs > endptr");
        abort();
      }

      double v9 = v47;
      if (!**(_BYTE **)&v116[0]
        || ((unint64_t v48 = strptime(*(const char **)&v116[0], " %z", &v114), (__endptr = v48) != 0LL)
         || (unint64_t v48 = strptime(*(const char **)&v116[0], " %Z", &v114), (__endptr = v48) != 0LL))
        && !*v48)
      {
        time_t v8 = mktime(&v114);
        if (v9 > 0.0)
        {
          if (byte_1000E7D30)
          {
            int v58 = *__error();
            uint64_t v59 = (os_log_s *)sub_10002EFA0();
            if (os_log_type_enabled(v59, OS_LOG_TYPE_DEBUG)) {
              sub_10008BE80(v8, v59, v9);
            }
            *__error() = v58;
          }

          if (!byte_1000E7D31 || dword_1000E74E0 > 0) {
            goto LABEL_161;
          }
          int v60 = *__error();
          double v61 = fmod(v9, 1.0);
          int v62 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"Found ISO timestamp %ld with subseconds %f",  v8,  *(void *)&v61);
          if (v62)
          {
LABEL_117:
            uint64_t v67 = v62;
            BOOL v68 = CFStringGetCStringPtr(v62, 0x8000100u);
            if (v68)
            {
              id v69 = (char *)v68;
              id v70 = 0LL;
            }

            else
            {
              id v69 = (char *)calloc(0x400uLL, 1uLL);
              CFStringGetCString(v67, v69, 1024LL, 0x8000100u);
              id v70 = v69;
            }

            if (qword_1000E7D38) {
              double v85 = (FILE *)qword_1000E7D38;
            }
            else {
              double v85 = __stderrp;
            }
            fprintf(v85, "%s\n", v69);
            if (v70) {
              free(v70);
            }
            CFRelease(v67);
LABEL_160:
            *__error() = v60;
LABEL_161:
            fmod(v9, 1.0);
            return;
          }

          v63 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v63, OS_LOG_TYPE_FAULT)) {
            sub_10008BE0C(v8, v63, v64, v61);
          }
LABEL_138:
          if (qword_1000E7D38) {
            id v76 = (FILE *)qword_1000E7D38;
          }
          else {
            id v76 = __stderrp;
          }
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v76);
          goto LABEL_160;
        }

LABEL_110:
        if (byte_1000E7D30)
        {
          int v65 = *__error();
          BOOL v66 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v66, OS_LOG_TYPE_DEBUG)) {
            sub_10008BF78();
          }
          *__error() = v65;
        }

        if (!byte_1000E7D31 || dword_1000E74E0 > 0) {
          goto LABEL_161;
        }
        int v60 = *__error();
        int v62 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"Found ISO timestamp %ld", v8);
        if (v62) {
          goto LABEL_117;
        }
        unsigned int v75 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v75, OS_LOG_TYPE_FAULT)) {
          sub_10008BF14();
        }
        goto LABEL_138;
      }
    }

    else if (!*v7)
    {
      time_t v8 = mktime(&v114);
      double v9 = 0.0;
      goto LABEL_110;
    }
  }

  CFAbsoluteTime atp = 0.0;
  int v49 = CFLocaleCopyCurrent();
  if (v49)
  {
    int v50 = CFStringCreateWithCString(0LL, a1, 0x8000100u);
    if (v50)
    {
      uint64_t v51 = 0LL;
      int v52 = 0LL;
LABEL_78:
      uint64_t v53 = 0LL;
      while (1)
      {
        if (v52) {
          CFRelease(v52);
        }
        uint64_t v54 = CFDateFormatterCreate( 0LL,  v49,  (CFDateFormatterStyle)qword_10009ADF0[v51],  (CFDateFormatterStyle)qword_10009ADF0[v53]);
        if (!v54) {
          break;
        }
        int v52 = v54;
        CFDateFormatterSetProperty(v54, kCFDateFormatterIsLenient, kCFBooleanTrue);
        if (CFDateFormatterGetAbsoluteTimeFromString(v52, v50, 0LL, &atp)) {
          goto LABEL_176;
        }
        if (++v53 == 4)
        {
          if (++v51 != 4) {
            goto LABEL_78;
          }
          goto LABEL_176;
        }
      }

      if (byte_1000E7D30)
      {
        int v71 = *__error();
        int v72 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v72, OS_LOG_TYPE_ERROR)) {
          sub_10008BDE0();
        }
        *__error() = v71;
      }

      if (byte_1000E7D31) {
        BOOL v73 = dword_1000E74E0 <= 3;
      }
      else {
        BOOL v73 = 0;
      }
      if (v73)
      {
        int v79 = *__error();
        int v80 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"Unable to create date formatter");
        if (v80)
        {
          int v81 = v80;
          uint64_t v82 = CFStringGetCStringPtr(v80, 0x8000100u);
          if (v82)
          {
            int v83 = (char *)v82;
            double v84 = 0LL;
          }

          else
          {
            int v83 = (char *)calloc(0x400uLL, 1uLL);
            CFStringGetCString(v81, v83, 1024LL, 0x8000100u);
            double v84 = v83;
          }

          if (qword_1000E7D38) {
            int v88 = (FILE *)qword_1000E7D38;
          }
          else {
            int v88 = __stderrp;
          }
          fprintf(v88, "%s\n", v83);
          if (v84) {
            free(v84);
          }
          CFRelease(v81);
        }

        else
        {
          double v86 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v86, OS_LOG_TYPE_FAULT)) {
            sub_10008BDB4();
          }
          if (qword_1000E7D38) {
            int v87 = (FILE *)qword_1000E7D38;
          }
          else {
            int v87 = __stderrp;
          }
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v87);
        }

        int v52 = 0LL;
        *__error() = v79;
        goto LABEL_176;
      }
    }

    int v52 = 0LL;
  }

  else
  {
    int v52 = 0LL;
    int v50 = 0LL;
  }

    int v74 = v65;
    unsigned int v75 = CFStringGetCStringPtr(v65, 0x8000100u);
    if (v75)
    {
      id v76 = (char *)v75;
      int v77 = 0LL;
    }

    else
    {
      id v76 = (char *)calloc(0x400uLL, 1uLL);
      CFStringGetCString(v74, v76, 1024LL, 0x8000100u);
      int v77 = v76;
    }

    if (qword_1000E7D38) {
      double v86 = (FILE *)qword_1000E7D38;
    }
    else {
      double v86 = __stderrp;
    }
    fprintf(v86, "%s\n", v76);
    if (v77) {
      free(v77);
    }
    CFRelease(v74);
    goto LABEL_146;
  }

  if (byte_1000E7D30)
  {
    double v61 = *__error();
    int v62 = (os_log_s *)sub_10002EFA0();
    if (os_log_type_enabled(v62, OS_LOG_TYPE_DEBUG)) {
      sub_100083A98();
    }
    *__error() = v61;
  }

  if (!byte_1000E7D31 || dword_1000E74E0 > 0) {
    goto LABEL_147;
  }
  v63 = *__error();
  uint64_t v64 = sub_10002EF3C(a1);
  int v65 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"%s [%d]: disk writes: not monitoring due to tasking-specified sampling",  v64,  a1);
  if (v65) {
    goto LABEL_110;
  }
  BOOL v66 = (os_log_s *)sub_10002EFA0();
  if (os_log_type_enabled(v66, OS_LOG_TYPE_FAULT)) {
    sub_100083A30();
  }
LABEL_142:
  if (qword_1000E7D38) {
    v94 = (FILE *)qword_1000E7D38;
  }
  else {
    v94 = __stderrp;
  }
  fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v94);
LABEL_146:
  *__error() = v63;
LABEL_147:
  v43 |= 0x200000uLL;
LABEL_148:
  if ((a1 & 0x80000000) != 0)
  {
    if (byte_1000E7D30)
    {
      int v102 = *__error();
      uint64_t v103 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v103, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 134217984;
        int v150 = (_DWORD *)v43;
        _os_log_impl( (void *)&_mh_execute_header,  v103,  OS_LOG_TYPE_DEFAULT,  "disk writes: not monitoring due to conditions %#llx",  buf,  0xCu);
      }

      *__error() = v102;
    }

    if (!byte_1000E7D31 || dword_1000E74E0 > 2) {
      goto LABEL_181;
    }
    double v98 = *__error();
    int v100 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"disk writes: not monitoring due to conditions %#llx",  v43);
    if (!v100)
    {
      BOOL v109 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v109, OS_LOG_TYPE_FAULT)) {
        sub_1000839D0();
      }
      goto LABEL_176;
    }

LABEL_176:
  if (atp == 0.0)
  {
    memset(v116, 0, sizeof(v116));
    time_t v111 = (uint64_t)(CFAbsoluteTimeGetCurrent() + kCFAbsoluteTimeIntervalSince1970);
    localtime_r(&v111, &v112);
    strftime((char *)v116, 0x80uLL, "%Y-%m-%dT%T%z", &v112);
    if (byte_1000E7D30)
    {
      int v89 = *__error();
      int v90 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v90, OS_LOG_TYPE_ERROR)) {
        sub_10008BD44();
      }
      *__error() = v89;
    }

    if (byte_1000E7D31 && dword_1000E74E0 <= 3)
    {
      int v91 = *__error();
      int v92 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"Unable to parse time string %s, try using format '%%Y-%%m-%%dT%%T%%z', e.g. %s",  a1,  v116);
      if (v92)
      {
        v93 = v92;
        v94 = CFStringGetCStringPtr(v92, 0x8000100u);
        if (v94)
        {
          uint64_t v95 = (char *)v94;
          v96 = 0LL;
        }

        else
        {
          uint64_t v95 = (char *)calloc(0x400uLL, 1uLL);
          CFStringGetCString(v93, v95, 1024LL, 0x8000100u);
          v96 = v95;
        }

        if (qword_1000E7D38) {
          double v99 = (FILE *)qword_1000E7D38;
        }
        else {
          double v99 = __stderrp;
        }
        fprintf(v99, "%s\n", v95);
        if (v96) {
          free(v96);
        }
        CFRelease(v93);
      }

      else
      {
        v97 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v97, OS_LOG_TYPE_FAULT)) {
          sub_10008BCDC();
        }
        if (qword_1000E7D38) {
          double v98 = (FILE *)qword_1000E7D38;
        }
        else {
          double v98 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v98);
      }

      *__error() = v91;
    }
  }

  if (v50) {
    CFRelease(v50);
  }
  if (v49) {
    CFRelease(v49);
  }
  if (v52) {
    CFRelease(v52);
  }
}

uint64_t sub_10002D674()
{
  if (qword_1000E7548 != -1) {
    dispatch_once(&qword_1000E7548, &stru_1000D8B38);
  }
  return dword_1000E7540;
}

void sub_10002D6B4(id a1)
{
  *(void *)uint64_t v2 = 0x600000001LL;
  size_t v1 = 4LL;
  if (sysctl(v2, 2u, &dword_1000E7540, &v1, 0LL, 0LL) == -1) {
    sub_10007FB94();
  }
}

uint64_t sub_10002D73C(const char *a1, int a2, int a3, char a4, char **a5)
{
  pid_t v197 = getpid();
  __endptr = 0LL;
  if (!a1 || !*a1) {
    return 4294967294LL;
  }
  uint64_t v9 = strtol(a1, &__endptr, 0);
  if (__endptr != a1 && !*__endptr)
  {
    uint64_t v31 = v9;
    if (!(_DWORD)v9 || !kill(v9, 0))
    {
      if (a5)
      {
        if (proc_pidpath(v31, &buffer, 0x400u) >= 1)
        {
          id v70 = (char *)malloc(0x400uLL);
          *a5 = v70;
          basename_r((const char *)&buffer, v70);
        }

        if (byte_1000E7D30)
        {
          int v71 = *__error();
          int v72 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v72, OS_LOG_TYPE_DEBUG)) {
            sub_10007FD88();
          }
          *__error() = v71;
        }

        if (!byte_1000E7D31 || dword_1000E74E0 > 0) {
          return v31;
        }
        int v73 = *__error();
        int v74 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"Found pid %s [%d]", *a5, v31);
        if (v74)
        {
          unsigned int v75 = v74;
          CStringPtr = CFStringGetCStringPtr(v74, 0x8000100u);
          if (CStringPtr)
          {
            int v77 = (char *)CStringPtr;
            double v78 = 0LL;
          }

          else
          {
            int v77 = (char *)calloc(0x400uLL, 1uLL);
            CFStringGetCString(v75, v77, 1024LL, 0x8000100u);
            double v78 = v77;
          }

          if (qword_1000E7D38) {
            int v183 = (FILE *)qword_1000E7D38;
          }
          else {
            int v183 = __stderrp;
          }
          fprintf(v183, "%s\n", v77);
          if (v78) {
            free(v78);
          }
          v184 = v75;
LABEL_330:
          CFRelease(v184);
LABEL_331:
          *__error() = v73;
          return v31;
        }

        uint64_t v180 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v180, OS_LOG_TYPE_FAULT)) {
          sub_10007FD14();
        }
      }

      else
      {
        if (byte_1000E7D30)
        {
          int v151 = *__error();
          __int16 v152 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v152, OS_LOG_TYPE_DEBUG)) {
            sub_10007FCA0(v31, v152);
          }
          *__error() = v151;
        }

        if (!byte_1000E7D31 || dword_1000E74E0 > 0) {
          return v31;
        }
        int v73 = *__error();
        uint64_t v153 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"Found pid [%d]", v31);
        if (v153)
        {
          uint64_t v154 = v153;
          uint64_t v155 = CFStringGetCStringPtr(v153, 0x8000100u);
          if (v155)
          {
            uint64_t v156 = (char *)v155;
            uint64_t v157 = 0LL;
          }

          else
          {
            uint64_t v156 = (char *)calloc(0x400uLL, 1uLL);
            CFStringGetCString(v154, v156, 1024LL, 0x8000100u);
            uint64_t v157 = v156;
          }

          if (qword_1000E7D38) {
            uint64_t v187 = (FILE *)qword_1000E7D38;
          }
          else {
            uint64_t v187 = __stderrp;
          }
          fprintf(v187, "%s\n", v156);
          if (v157) {
            free(v157);
          }
          v184 = v154;
          goto LABEL_330;
        }

        v185 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v185, OS_LOG_TYPE_FAULT)) {
          sub_10007FC2C(v31, v185);
        }
      }

      if (qword_1000E7D38) {
        id v186 = (FILE *)qword_1000E7D38;
      }
      else {
        id v186 = __stderrp;
      }
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v186);
      goto LABEL_331;
    }
  }

  if (qword_1000E7548 != -1) {
    dispatch_once(&qword_1000E7548, &stru_1000D8B38);
  }
  int v10 = dword_1000E7540;
  uint64_t v192 = (unsigned int *)calloc(dword_1000E7540, 4uLL);
  int v11 = proc_listallpids(v192, 4 * v10);
  if (v11 == -1)
  {
    perror("proc_listallpids");
    free(v192);
    return 4294967294LL;
  }

  LODWORD(v12) = v11;
  BOOL v13 = (char *)calloc(v11, 0x400uLL);
  uint64_t v191 = v13;
  if ((int)v12 < 1)
  {
    if (a3)
    {
      sub_10002EEF8((char *)&buffer, 0x100uLL, "Multiple matches for %s: ", v14, v15, v16, v17, v18, (char)a1);
      int v50 = 0LL;
LABEL_133:
      uint64_t v31 = 4294967294LL;
LABEL_134:
      if (a5) {
        goto LABEL_304;
      }
      goto LABEL_305;
    }

    unsigned int v188 = v12;
    uint64_t v189 = a5;
    unsigned int v194 = -1;
LABEL_95:
    uint64_t v79 = v188;
    CFAllocatorRef alloc = (CFAllocatorRef)v188;
    int v81 = v191;
    int v80 = v192;
    uint64_t v82 = v191;
    while (1)
    {
      if (!strncasecmp(v81, a1, 0x400uLL))
      {
        if (byte_1000E7D30)
        {
          int v83 = *__error();
          double v84 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v84, OS_LOG_TYPE_DEBUG))
          {
            unsigned int v95 = *v80;
            int buffer = 136315394;
            v202 = v82;
            __int16 v203 = 1024;
            unsigned int v204 = v95;
            _os_log_debug_impl( (void *)&_mh_execute_header,  v84,  OS_LOG_TYPE_DEBUG,  "Found case insensitive match %s [%d]",  (uint8_t *)&buffer,  0x12u);
          }

          *__error() = v83;
        }

        if (byte_1000E7D31) {
          BOOL v85 = dword_1000E74E0 <= 0;
        }
        else {
          BOOL v85 = 0;
        }
        if (v85)
        {
          int v86 = *__error();
          int v87 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"Found case insensitive match %s [%d]",  v81,  *v80);
          if (v87)
          {
            int v88 = v87;
            int v89 = CFStringGetCStringPtr(v87, 0x8000100u);
            if (v89)
            {
              int v90 = (char *)v89;
              int v91 = 0LL;
            }

            else
            {
              int v90 = (char *)calloc(0x400uLL, 1uLL);
              CFStringGetCString(v88, v90, 1024LL, 0x8000100u);
              int v91 = v90;
            }

            if (qword_1000E7D38) {
              v94 = (FILE *)qword_1000E7D38;
            }
            else {
              v94 = __stderrp;
            }
            fprintf(v94, "%s\n", v90);
            if (v91) {
              free(v91);
            }
            CFRelease(v88);
          }

          else
          {
            int v92 = (os_log_s *)sub_10002EFA0();
            if (os_log_type_enabled(v92, OS_LOG_TYPE_FAULT))
            {
              unsigned int v96 = *v80;
              int buffer = 136315394;
              v202 = v82;
              __int16 v203 = 1024;
              unsigned int v204 = v96;
              _os_log_fault_impl( (void *)&_mh_execute_header,  v92,  OS_LOG_TYPE_FAULT,  "Unable to format: Found case insensitive match %s [%d]",  (uint8_t *)&buffer,  0x12u);
            }

            if (qword_1000E7D38) {
              v93 = (FILE *)qword_1000E7D38;
            }
            else {
              v93 = __stderrp;
            }
            fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v93);
          }

          *__error() = v86;
        }

        uint64_t v31 = *v80;
        if ((a4 & 1) != 0 || v197 != (_DWORD)v31)
        {
          if (v197 != (_DWORD)v31)
          {
LABEL_247:
            uint64_t v158 = v189;
            if (!v189) {
              goto LABEL_305;
            }
            uint64_t v159 = v81;
LABEL_292:
            *uint64_t v158 = strdup(v159);
            goto LABEL_305;
          }

          unsigned int v194 = *v80;
        }
      }

      ++v80;
      v81 += 1024;
      v82 += 1024;
      if (!--v79)
      {
        size_t v97 = strlen(a1);
        if (v97 <= 0x3FF)
        {
          size_t v98 = v97;
          uint64_t v99 = v188;
          int v100 = v191;
          v101 = v191;
          int v102 = v192;
          while (1)
          {
            if (!strncmp(v100, a1, v98))
            {
              if (byte_1000E7D30)
              {
                int v103 = *__error();
                uint64_t v104 = (os_log_s *)sub_10002EFA0();
                if (os_log_type_enabled(v104, OS_LOG_TYPE_DEBUG))
                {
                  unsigned int v115 = *v102;
                  int buffer = 136315394;
                  v202 = v101;
                  __int16 v203 = 1024;
                  unsigned int v204 = v115;
                  _os_log_debug_impl( (void *)&_mh_execute_header,  v104,  OS_LOG_TYPE_DEBUG,  "Found prefix match %s [%d]",  (uint8_t *)&buffer,  0x12u);
                }

                *__error() = v103;
              }

              if (byte_1000E7D31) {
                BOOL v105 = dword_1000E74E0 <= 0;
              }
              else {
                BOOL v105 = 0;
              }
              if (v105)
              {
                int v106 = *__error();
                uint64_t v107 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"Found prefix match %s [%d]",  v100,  *v102);
                if (v107)
                {
                  uint64_t v108 = v107;
                  BOOL v109 = CFStringGetCStringPtr(v107, 0x8000100u);
                  if (v109)
                  {
                    int v110 = (char *)v109;
                    time_t v111 = 0LL;
                  }

                  else
                  {
                    int v110 = (char *)calloc(0x400uLL, 1uLL);
                    CFStringGetCString(v108, v110, 1024LL, 0x8000100u);
                    time_t v111 = v110;
                  }

                  if (qword_1000E7D38) {
                    tm v114 = (FILE *)qword_1000E7D38;
                  }
                  else {
                    tm v114 = __stderrp;
                  }
                  fprintf(v114, "%s\n", v110);
                  if (v111) {
                    free(v111);
                  }
                  CFRelease(v108);
                }

                else
                {
                  tm v112 = (os_log_s *)sub_10002EFA0();
                  if (os_log_type_enabled(v112, OS_LOG_TYPE_FAULT))
                  {
                    unsigned int v116 = *v102;
                    int buffer = 136315394;
                    v202 = v101;
                    __int16 v203 = 1024;
                    unsigned int v204 = v116;
                    _os_log_fault_impl( (void *)&_mh_execute_header,  v112,  OS_LOG_TYPE_FAULT,  "Unable to format: Found prefix match %s [%d]",  (uint8_t *)&buffer,  0x12u);
                  }

                  if (qword_1000E7D38) {
                    uint64_t v113 = (FILE *)qword_1000E7D38;
                  }
                  else {
                    uint64_t v113 = __stderrp;
                  }
                  fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v113);
                }

                *__error() = v106;
              }

              uint64_t v31 = *v102;
              if ((a4 & 1) != 0 || v197 != (_DWORD)v31)
              {
                if (v197 != (_DWORD)v31)
                {
LABEL_290:
                  uint64_t v158 = v189;
                  if (!v189) {
                    goto LABEL_305;
                  }
                  uint64_t v159 = v100;
                  goto LABEL_292;
                }

                unsigned int v194 = *v102;
              }
            }

            ++v102;
            v100 += 1024;
            v101 += 1024;
            if (!--v99)
            {
              uint64_t v117 = v188;
              int v100 = v191;
              uint64_t v118 = v191;
              uint64_t v119 = v192;
              while (1)
              {
                if (!strncasecmp(v100, a1, v98))
                {
                  if (byte_1000E7D30)
                  {
                    int v120 = *__error();
                    v121 = (os_log_s *)sub_10002EFA0();
                    if (os_log_type_enabled(v121, OS_LOG_TYPE_DEBUG))
                    {
                      unsigned int v132 = *v119;
                      int buffer = 136315394;
                      v202 = v118;
                      __int16 v203 = 1024;
                      unsigned int v204 = v132;
                      _os_log_debug_impl( (void *)&_mh_execute_header,  v121,  OS_LOG_TYPE_DEBUG,  "Found case insensitive prefix match %s [%d]",  (uint8_t *)&buffer,  0x12u);
                    }

                    *__error() = v120;
                  }

                  if (byte_1000E7D31) {
                    BOOL v122 = dword_1000E74E0 <= 0;
                  }
                  else {
                    BOOL v122 = 0;
                  }
                  if (v122)
                  {
                    int v123 = *__error();
                    int v124 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"Found case insensitive prefix match %s [%d]",  v100,  *v119);
                    if (v124)
                    {
                      v125 = v124;
                      uint64_t v126 = CFStringGetCStringPtr(v124, 0x8000100u);
                      if (v126)
                      {
                        dispatch_semaphore_t v127 = (char *)v126;
                        xpc_object_t v128 = 0LL;
                      }

                      else
                      {
                        dispatch_semaphore_t v127 = (char *)calloc(0x400uLL, 1uLL);
                        CFStringGetCString(v125, v127, 1024LL, 0x8000100u);
                        xpc_object_t v128 = v127;
                      }

                      if (qword_1000E7D38) {
                        dispatch_queue_t v131 = (FILE *)qword_1000E7D38;
                      }
                      else {
                        dispatch_queue_t v131 = __stderrp;
                      }
                      fprintf(v131, "%s\n", v127);
                      if (v128) {
                        free(v128);
                      }
                      CFRelease(v125);
                    }

                    else
                    {
                      int v129 = (os_log_s *)sub_10002EFA0();
                      if (os_log_type_enabled(v129, OS_LOG_TYPE_FAULT))
                      {
                        unsigned int v133 = *v119;
                        int buffer = 136315394;
                        v202 = v118;
                        __int16 v203 = 1024;
                        unsigned int v204 = v133;
                        _os_log_fault_impl( (void *)&_mh_execute_header,  v129,  OS_LOG_TYPE_FAULT,  "Unable to format: Found case insensitive prefix match %s [%d]",  (uint8_t *)&buffer,  0x12u);
                      }

                      if (qword_1000E7D38) {
                        v130 = (FILE *)qword_1000E7D38;
                      }
                      else {
                        v130 = __stderrp;
                      }
                      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v130);
                    }

                    *__error() = v123;
                  }

                  uint64_t v31 = *v119;
                  if ((a4 & 1) != 0 || v197 != (_DWORD)v31)
                  {
                    if (v197 != (_DWORD)v31) {
                      goto LABEL_290;
                    }
                    unsigned int v194 = *v119;
                  }
                }

                ++v119;
                v100 += 1024;
                v118 += 1024;
                if (!--v117)
                {
                  uint64_t v134 = v188;
                  int v81 = v191;
                  int v135 = v191;
                  uint64_t v136 = v192;
                  while (1)
                  {
                    if (strstr(v81, a1))
                    {
                      if (byte_1000E7D30)
                      {
                        int v137 = *__error();
                        int v138 = (os_log_s *)sub_10002EFA0();
                        if (os_log_type_enabled(v138, OS_LOG_TYPE_DEBUG))
                        {
                          unsigned int v149 = *v136;
                          int buffer = 136315394;
                          v202 = v135;
                          __int16 v203 = 1024;
                          unsigned int v204 = v149;
                          _os_log_debug_impl( (void *)&_mh_execute_header,  v138,  OS_LOG_TYPE_DEBUG,  "Found partial match %s [%d]",  (uint8_t *)&buffer,  0x12u);
                        }

                        *__error() = v137;
                      }

                      if (byte_1000E7D31) {
                        BOOL v139 = dword_1000E74E0 <= 0;
                      }
                      else {
                        BOOL v139 = 0;
                      }
                      if (v139)
                      {
                        int v140 = *__error();
                        int v141 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"Found partial match %s [%d]",  v81,  *v136);
                        if (v141)
                        {
                          uint64_t v142 = v141;
                          uint64_t v143 = CFStringGetCStringPtr(v141, 0x8000100u);
                          if (v143)
                          {
                            uint64_t v144 = (char *)v143;
                            uint64_t v145 = 0LL;
                          }

                          else
                          {
                            uint64_t v144 = (char *)calloc(0x400uLL, 1uLL);
                            CFStringGetCString(v142, v144, 1024LL, 0x8000100u);
                            uint64_t v145 = v144;
                          }

                          if (qword_1000E7D38) {
                            double v148 = (FILE *)qword_1000E7D38;
                          }
                          else {
                            double v148 = __stderrp;
                          }
                          fprintf(v148, "%s\n", v144);
                          if (v145) {
                            free(v145);
                          }
                          CFRelease(v142);
                        }

                        else
                        {
                          int v146 = (os_log_s *)sub_10002EFA0();
                          if (os_log_type_enabled(v146, OS_LOG_TYPE_FAULT))
                          {
                            unsigned int v150 = *v136;
                            int buffer = 136315394;
                            v202 = v135;
                            __int16 v203 = 1024;
                            unsigned int v204 = v150;
                            _os_log_fault_impl( (void *)&_mh_execute_header,  v146,  OS_LOG_TYPE_FAULT,  "Unable to format: Found partial match %s [%d]",  (uint8_t *)&buffer,  0x12u);
                          }

                          if (qword_1000E7D38) {
                            uint64_t v147 = (FILE *)qword_1000E7D38;
                          }
                          else {
                            uint64_t v147 = __stderrp;
                          }
                          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v147);
                        }

                        *__error() = v140;
                      }

                      uint64_t v31 = *v136;
                      if ((a4 & 1) != 0 || v197 != (_DWORD)v31)
                      {
                        if (v197 != (_DWORD)v31) {
                          goto LABEL_247;
                        }
                        unsigned int v194 = *v136;
                      }
                    }

                    ++v136;
                    v81 += 1024;
                    v135 += 1024;
                    if (!--v134)
                    {
                      int v161 = v191;
                      BOOL v160 = v192;
                      int v162 = v191;
                      uint64_t v31 = v194;
                      while (1)
                      {
                        if (strcasestr(v161, a1))
                        {
                          if (byte_1000E7D30)
                          {
                            int v163 = *__error();
                            uint64_t v164 = (os_log_s *)sub_10002EFA0();
                            if (os_log_type_enabled(v164, OS_LOG_TYPE_DEBUG))
                            {
                              unsigned int v176 = *v160;
                              int buffer = 136315394;
                              v202 = v162;
                              __int16 v203 = 1024;
                              unsigned int v204 = v176;
                              _os_log_debug_impl( (void *)&_mh_execute_header,  v164,  OS_LOG_TYPE_DEBUG,  "Found case insensitive partial match %s [%d]",  (uint8_t *)&buffer,  0x12u);
                            }

                            *__error() = v163;
                          }

                          if (byte_1000E7D31) {
                            BOOL v165 = dword_1000E74E0 <= 0;
                          }
                          else {
                            BOOL v165 = 0;
                          }
                          if (v165)
                          {
                            int v166 = *__error();
                            uint64_t v167 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"Found case insensitive partial match %s [%d]",  v161,  *v160);
                            if (v167)
                            {
                              uint64_t v168 = v167;
                              uint64_t v169 = CFStringGetCStringPtr(v167, 0x8000100u);
                              if (v169)
                              {
                                BOOL v170 = (char *)v169;
                                int v171 = 0LL;
                              }

                              else
                              {
                                BOOL v170 = (char *)calloc(0x400uLL, 1uLL);
                                CFStringGetCString(v168, v170, 1024LL, 0x8000100u);
                                int v171 = v170;
                              }

                              if (qword_1000E7D38) {
                                id v174 = (FILE *)qword_1000E7D38;
                              }
                              else {
                                id v174 = __stderrp;
                              }
                              fprintf(v174, "%s\n", v170);
                              if (v171) {
                                free(v171);
                              }
                              CFRelease(v168);
                            }

                            else
                            {
                              v172 = (os_log_s *)sub_10002EFA0();
                              if (os_log_type_enabled(v172, OS_LOG_TYPE_FAULT))
                              {
                                unsigned int v177 = *v160;
                                int buffer = 136315394;
                                v202 = v162;
                                __int16 v203 = 1024;
                                unsigned int v204 = v177;
                                _os_log_fault_impl( (void *)&_mh_execute_header,  v172,  OS_LOG_TYPE_FAULT,  "Unable to format: Found case insensitive partial match %s [%d]",  (uint8_t *)&buffer,  0x12u);
                              }

                              if (qword_1000E7D38) {
                                v173 = (FILE *)qword_1000E7D38;
                              }
                              else {
                                v173 = __stderrp;
                              }
                              fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v173);
                            }

                            *__error() = v166;
                          }

                          uint64_t v175 = *v160;
                          if ((a4 & 1) != 0 || v197 != (_DWORD)v175)
                          {
                            if (v197 != (_DWORD)v175)
                            {
                              if (v189) {
                                *uint64_t v189 = strdup(v161);
                              }
                              uint64_t v31 = v175;
                              goto LABEL_305;
                            }

                            uint64_t v31 = *v160;
                          }
                        }

                        ++v160;
                        v161 += 1024;
                        v162 += 1024;
                        CFAllocatorRef alloc = (CFAllocatorRef)((char *)alloc - 1);
                        if (!alloc) {
                          goto LABEL_305;
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }

LABEL_131:
        uint64_t v31 = v194;
        goto LABEL_305;
      }
    }
  }

  unsigned int v188 = v12;
  uint64_t v19 = v12;
  uint64_t v12 = v12;
  time_t v20 = v13;
  int v21 = (int *)v192;
  do
  {
    int v22 = *v21++;
    if (proc_pidpath(v22, &buffer, 0x400u) >= 1) {
      basename_r((const char *)&buffer, v20);
    }
    v20 += 1024;
    --v12;
  }

  while (v12);
  uint64_t v189 = a5;
  int v195 = a2;
  if ((a3 & 1) == 0)
  {
    unsigned int v194 = -1;
    uint64_t v51 = &byte_1000E7D30;
    int v52 = v191;
    uint64_t v53 = v192;
    uint64_t v54 = v191;
    do
    {
      if (!strncmp(v52, a1, 0x400uLL))
      {
        if (*v51)
        {
          int v55 = *__error();
          uint64_t v56 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v56, OS_LOG_TYPE_DEBUG))
          {
            unsigned int v68 = *v53;
            int buffer = 136315394;
            v202 = v54;
            __int16 v203 = 1024;
            unsigned int v204 = v68;
            _os_log_debug_impl( (void *)&_mh_execute_header,  v56,  OS_LOG_TYPE_DEBUG,  "Found exact match %s [%d]",  (uint8_t *)&buffer,  0x12u);
          }

          *__error() = v55;
        }

        if (byte_1000E7D31) {
          BOOL v57 = dword_1000E74E0 <= 0;
        }
        else {
          BOOL v57 = 0;
        }
        if (v57)
        {
          int v58 = v51;
          int v59 = *__error();
          int v60 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"Found exact match %s [%d]", v52, *v53);
          if (v60)
          {
            double v61 = v60;
            int v62 = CFStringGetCStringPtr(v60, 0x8000100u);
            if (v62)
            {
              v63 = (char *)v62;
              uint64_t v64 = 0LL;
            }

            else
            {
              v63 = (char *)calloc(0x400uLL, 1uLL);
              CFStringGetCString(v61, v63, 1024LL, 0x8000100u);
              uint64_t v64 = v63;
            }

            if (qword_1000E7D38) {
              uint64_t v67 = (FILE *)qword_1000E7D38;
            }
            else {
              uint64_t v67 = __stderrp;
            }
            fprintf(v67, "%s\n", v63);
            if (v64) {
              free(v64);
            }
            CFRelease(v61);
          }

          else
          {
            int v65 = (os_log_s *)sub_10002EFA0();
            if (os_log_type_enabled(v65, OS_LOG_TYPE_FAULT))
            {
              unsigned int v69 = *v53;
              int buffer = 136315394;
              v202 = v54;
              __int16 v203 = 1024;
              unsigned int v204 = v69;
              _os_log_fault_impl( (void *)&_mh_execute_header,  v65,  OS_LOG_TYPE_FAULT,  "Unable to format: Found exact match %s [%d]",  (uint8_t *)&buffer,  0x12u);
            }

            if (qword_1000E7D38) {
              BOOL v66 = (FILE *)qword_1000E7D38;
            }
            else {
              BOOL v66 = __stderrp;
            }
            fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v66);
          }

          LOBYTE(a2) = v195;
          *__error() = v59;
          uint64_t v51 = v58;
        }

        uint64_t v31 = *v53;
        if ((a4 & 1) != 0 || v197 != (_DWORD)v31)
        {
          if (v197 != (_DWORD)v31)
          {
            uint64_t v158 = v189;
            if (!v189) {
              goto LABEL_305;
            }
            uint64_t v159 = v52;
            goto LABEL_292;
          }

          unsigned int v194 = *v53;
        }
      }

      ++v53;
      v52 += 1024;
      v54 += 1024;
      --v19;
    }

    while (v19);
    goto LABEL_95;
  }

  int v28 = 0;
  char v29 = 0;
  uint64_t v193 = 0LL;
  BOOL v30 = (char *)&buffer
      + (int)sub_10002EEF8( (char *)&buffer,  0x100uLL,  "Multiple matches for %s: ",  v23,  v24,  v25,  v26,  v27,  (char)a1);
  uint64_t v31 = 0xFFFFFFFFLL;
  time_t v32 = v191;
  int v33 = v192;
  do
  {
    if (a2)
    {
      if (strncmp(v32, a1, 0x400uLL)) {
        goto LABEL_30;
      }
    }

    else if (!strcasestr(v32, a1))
    {
      goto LABEL_30;
    }

    uint64_t v39 = *v33;
    if ((a4 & 1) != 0 || v197 != (_DWORD)v39)
    {
      if (v197 != (_DWORD)v39)
      {
        if (a5 && !v28) {
          uint64_t v193 = strdup(v32);
        }
        uint64_t v40 = ", ";
        if (!v29) {
          uint64_t v40 = "";
        }
        v30 += (int)sub_10002EEF8(v30, (char *)&v205 - v30, "%s%s [%d]", v34, v35, v36, v37, v38, (char)v40);
        ++v28;
        ++v29;
      }

      uint64_t v31 = v39;
    }

    a2 = v195;
LABEL_30:
    ++v33;
    v32 += 1024;
    --v19;
  }

  while (v19);
  if (v28 < 2)
  {
    int v50 = v193;
    if (v28) {
      goto LABEL_134;
    }
    goto LABEL_133;
  }

  if (byte_1000E7D30)
  {
    int v41 = *__error();
    uint64_t v42 = (os_log_s *)sub_10002EFA0();
    if (os_log_type_enabled(v42, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315138;
      p_int buffer = &buffer;
      _os_log_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_DEFAULT, "%s", buf, 0xCu);
    }

    *__error() = v41;
  }

  if (byte_1000E7D31) {
    BOOL v43 = dword_1000E74E0 <= 2;
  }
  else {
    BOOL v43 = 0;
  }
  if (v43)
  {
    int v44 = *__error();
    uint64_t v45 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"%s", &buffer);
    if (v45)
    {
      uint64_t v46 = v45;
      double v47 = CFStringGetCStringPtr(v45, 0x8000100u);
      if (v47)
      {
        unint64_t v48 = (char *)v47;
        int v49 = 0LL;
      }

      else
      {
        unint64_t v48 = (char *)calloc(0x400uLL, 1uLL);
        CFStringGetCString(v46, v48, 1024LL, 0x8000100u);
        int v49 = v48;
      }

      if (qword_1000E7D38) {
        uint64_t v181 = (FILE *)qword_1000E7D38;
      }
      else {
        uint64_t v181 = __stderrp;
      }
      fprintf(v181, "%s\n", v48);
      if (v49) {
        free(v49);
      }
      CFRelease(v46);
    }

    else
    {
      uint64_t v178 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v178, OS_LOG_TYPE_FAULT)) {
        sub_10007FBBC((uint64_t)&buffer, v178);
      }
      if (qword_1000E7D38) {
        uint64_t v179 = (FILE *)qword_1000E7D38;
      }
      else {
        uint64_t v179 = __stderrp;
      }
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v179);
    }

    *__error() = v44;
  }

  free(v193);
  int v50 = 0LL;
  uint64_t v31 = 0xFFFFFFFFLL;
  if (a5) {
LABEL_304:
  }
    *a5 = v50;
LABEL_305:
  free(v192);
  free(v191);
  return v31;
}

uint64_t sub_10002EDE8(char *__format, ...)
{
  return os_transaction_create(__str);
}

  ;
}

  ;
}

uint64_t sub_10002EE78( const char *a1, const char *a2, int a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t result = snprintf(byte_1000E7550, 0x400uLL, "Assertion Failed %s %s:%d ", a1, a2, a3);
  qword_1000E7508 = (uint64_t)byte_1000E7550;
  return result;
}

uint64_t sub_10002EEF8( char *a1, size_t a2, const char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  LODWORD(result) = vsnprintf(a1, a2, a3, &a9);
  else {
    return result;
  }
}

_DWORD *sub_10002EF3C(int a1)
{
  do
    unsigned int v1 = __ldxr((unsigned int *)&unk_1000E7B50);
  while (__stxr(v1 + 1, (unsigned int *)&unk_1000E7B50));
  BOOL v2 = (-v1 & 0x80000000) != 0;
  int v3 = -v1 & 3;
  int v4 = v1 & 3;
  if (!v2) {
    int v4 = -v3;
  }
  uint64_t v5 = (_DWORD *)((char *)&unk_1000E7950 + 128 * (uint64_t)v4);
  *uint64_t v5 = 0;
  proc_name(a1, v5, 0x80u);
  return v5;
}

uint64_t sub_10002EFA0()
{
  if (qword_1000E7B60 != -1) {
    dispatch_once(&qword_1000E7B60, &stru_1000D8B78);
  }
  return qword_1000E7B58;
}

void sub_10002EFE0(id a1)
{
  qword_1000E7B58 = (uint64_t)os_log_create("com.apple.spindump", "logging");
  if (!qword_1000E7B58) {
    sub_10007FDFC();
  }
}

uint64_t sub_10002F014(int a1)
{
  if (proc_pidinfo(a1, 20, 1uLL, buffer, 40) == 40) {
    return buffer[0];
  }
  else {
    return 0LL;
  }
}

NSString *sub_10002F04C(int a1)
{
  if (proc_pidpath(a1, buffer, 0x400u) < 1) {
    return 0LL;
  }
  else {
    return -[NSString initWithUTF8String:](objc_alloc(&OBJC_CLASS___NSString), "initWithUTF8String:", buffer);
  }
}

void sub_10002F0C8(int a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  v7[1] = 3221225472LL;
  v7[2] = sub_10002F394;
  v7[3] = &unk_1000D8C08;
  int v8 = a1;
  v7[4] = a4;
  v7[5] = a5;
  v7[0] = _NSConcreteStackBlock;
  sub_10002F138(a1, a2, a3, 0LL, a6, a7, 0LL, 0LL, 0.0, 0.0, (uint64_t)v7);
}

void sub_10002F138( int a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, double a9, double a10, uint64_t a11)
{
  if (qword_1000E7BB0 != -1) {
    dispatch_once(&qword_1000E7BB0, &stru_1000D8CD8);
  }
  switch(a4)
  {
    case 0LL:
      int v11 = (os_log_s *)qword_1000E7B70;
      break;
    case 1LL:
      int v11 = (os_log_s *)qword_1000E7B68;
      break;
    case 2LL:
      int v11 = (os_log_s *)qword_1000E7B78;
      break;
    case 3LL:
      int v11 = (os_log_s *)qword_1000E7B80;
      break;
    case 4LL:
      int v11 = (os_log_s *)qword_1000E7B88;
      break;
    case 5LL:
      int v11 = (os_log_s *)qword_1000E7B90;
      break;
    case 6LL:
      int v11 = (os_log_s *)qword_1000E7B98;
      break;
    case 7LL:
      int v11 = (os_log_s *)qword_1000E7BA0;
      break;
    case 8LL:
      int v11 = (os_log_s *)qword_1000E7BA8;
      break;
    default:
      break;
  }

  if (os_signpost_enabled(v11) || sub_10002F554(a4))
  {
    if (!a3)
    {
      if (proc_pidinfo(a1, 20, 1uLL, buffer, 40) == 40) {
        a3 = buffer[0];
      }
      else {
        a3 = 0LL;
      }
    }

    if (a2) {
      int v22 = a2;
    }
    else {
      int v22 = sub_10002F04C(a1);
    }
    uint64_t v23 = v22;
    id v24 = +[SATimestamp timestamp](&OBJC_CLASS___SATimestamp, "timestamp");
    uint64_t v25 = sub_10002EDE8("Event rate report for [%d] type %lu", a1, a4);
    if (qword_1000E7BC0 != -1) {
      dispatch_once(&qword_1000E7BC0, &stru_1000D8CF8);
    }
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472LL;
    block[2] = sub_100031034;
    block[3] = &unk_1000D8CB8;
    block[10] = a6;
    block[11] = a7;
    block[12] = a8;
    block[4] = v23;
    void block[5] = v24;
    *(double *)&block[13] = a9;
    *(double *)&block[14] = a10;
    int v27 = a1;
    block[8] = a11;
    block[9] = a5;
    block[15] = a3;
    block[6] = v11;
    block[7] = v25;
    dispatch_async((dispatch_queue_t)qword_1000E7BB8, block);
  }

void sub_10002F394(uint64_t a1, os_log_t log, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if (os_signpost_enabled(log))
  {
    int v12 = *(_DWORD *)(a1 + 48);
    uint64_t v13 = *(void *)(a1 + 32);
    uint64_t v14 = *(void *)(a1 + 40);
    *(_DWORD *)buf = 138544642;
    uint64_t v19 = a4;
    __int16 v20 = 2050;
    uint64_t v21 = a5;
    __int16 v22 = 2050;
    uint64_t v23 = a3;
    __int16 v24 = 1026;
    int v25 = v12;
    __int16 v26 = 2050;
    uint64_t v27 = v13;
    __int16 v28 = 2050;
    uint64_t v29 = v14;
    _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  log,  OS_SIGNPOST_INTERVAL_BEGIN,  0xEEEEB0B5B2B2EEEELL,  "Hang",  "BundleIdOverride=%{public, signpost.description:attribute}@ %{public, signpost.description:begin_time}llu cid=%{pu blic,name=cid}llu pid=%{public,name=pid}u conditionsPreventingSubmission=%{public,name=conditionsPreventingSubmiss ion}#llx otherConditions=%{public,name=otherConditions}#llx enableTelemetry=YES ",  buf,  0x3Au);
  }

  if (os_signpost_enabled(log))
  {
    *(_DWORD *)buf = 134349056;
    uint64_t v19 = a6;
    _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  log,  OS_SIGNPOST_INTERVAL_END,  0xEEEEB0B5B2B2EEEELL,  "Hang",  "%{public, signpost.description:end_time}llu",  buf,  0xCu);
  }

  if (&_AnalyticsIsEventUsed)
  {
    int IsEventUsed = AnalyticsIsEventUsed(@"com.apple.spindump.forcequitwhileunresponsive");
    if (a4)
    {
      if (IsEventUsed)
      {
        v16[0] = _NSConcreteStackBlock;
        v16[1] = 3221225472LL;
        v16[2] = sub_10002F5A0;
        v16[3] = &unk_1000D8BE8;
        v16[4] = a4;
        v16[5] = a3;
        v16[6] = a6;
        v16[7] = a5;
        __int128 v17 = *(_OWORD *)(a1 + 32);
        AnalyticsSendEventLazy(@"com.apple.spindump.forcequitwhileunresponsive", v16);
      }
    }
  }

uint64_t sub_10002F554(uint64_t a1)
{
  if (!&_AnalyticsIsEventUsed) {
    return 0LL;
  }
  else {
    unsigned int v1 = off_1000D8D18[a1 - 1];
  }
  return AnalyticsIsEventUsed(v1);
}

NSDictionary *sub_10002F5A0(void *a1)
{
  uint64_t v2 = a1[5];
  v5[0] = a1[4];
  v5[1] = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"%llu",  v2,  @"BundleID",  @"CoalitionID");
  v4[2] = @"Duration";
  SASecondsFromMachTimeUsingLiveTimebase(a1[6] - a1[7]);
  v5[2] = +[NSNumber numberWithDouble:](&OBJC_CLASS___NSNumber, "numberWithDouble:");
  v4[3] = @"ConditionsPreventingSubmission";
  v5[3] = +[NSNumber numberWithUnsignedLongLong:](&OBJC_CLASS___NSNumber, "numberWithUnsignedLongLong:", a1[8]);
  v4[4] = @"OtherConditions";
  v5[4] = +[NSNumber numberWithUnsignedLongLong:](&OBJC_CLASS___NSNumber, "numberWithUnsignedLongLong:", a1[9]);
  return +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v5,  v4,  5LL);
}

void sub_10002F6AC(int a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  v7[1] = 3221225472LL;
  v7[2] = sub_10002F720;
  v7[3] = &unk_1000D8C28;
  int v8 = a1;
  v7[4] = a4;
  v7[5] = a5;
  void v7[6] = a7;
  v7[7] = a6;
  v7[0] = _NSConcreteStackBlock;
  sub_10002F138(a1, a2, a3, 1LL, 0LL, 0LL, a6, a7, 0.0, 0.0, (uint64_t)v7);
}

void sub_10002F720(uint64_t a1, os_log_t log, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if (os_signpost_enabled(log))
  {
    int v12 = *(_DWORD *)(a1 + 64);
    uint64_t v13 = *(void *)(a1 + 32);
    uint64_t v14 = *(void *)(a1 + 40);
    *(_DWORD *)buf = 138544642;
    uint64_t v21 = a4;
    __int16 v22 = 2050;
    uint64_t v23 = a5;
    __int16 v24 = 2050;
    uint64_t v25 = a3;
    __int16 v26 = 1026;
    int v27 = v12;
    __int16 v28 = 2050;
    uint64_t v29 = v13;
    __int16 v30 = 2050;
    uint64_t v31 = v14;
    _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  log,  OS_SIGNPOST_INTERVAL_BEGIN,  0xEEEEB0B5B2B2EEEELL,  "SlowHIDResponse",  "BundleIdOverride=%{public, signpost.description:attribute}@ %{public, signpost.description:begin_time}llu cid=%{pu blic,name=cid}llu pid=%{public,name=pid}u conditionsPreventingSubmission=%{public,name=conditionsPreventingSubmiss ion}#llx otherConditions=%{public,name=otherConditions}#llx enableTelemetry=YES ",  buf,  0x3Au);
  }

  if (os_signpost_enabled(log))
  {
    *(_DWORD *)buf = 134349056;
    uint64_t v21 = a6;
    _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  log,  OS_SIGNPOST_INTERVAL_END,  0xEEEEB0B5B2B2EEEELL,  "SlowHIDResponse",  "%{public, signpost.description:end_time}llu",  buf,  0xCu);
  }

  if (&_AnalyticsIsEventUsed)
  {
    int IsEventUsed = AnalyticsIsEventUsed(@"com.apple.spindump.slowhidresponse");
    if (a4)
    {
      if (IsEventUsed)
      {
        v17[0] = _NSConcreteStackBlock;
        v17[1] = 3221225472LL;
        v17[2] = sub_10002F8DC;
        v17[3] = &unk_1000D8BE8;
        v17[4] = a4;
        v17[5] = a3;
        __int128 v16 = *(_OWORD *)(a1 + 32);
        __int128 v18 = *(_OWORD *)(a1 + 48);
        __int128 v19 = v16;
        AnalyticsSendEventLazy(@"com.apple.spindump.slowhidresponse", v17);
      }
    }
  }

NSDictionary *sub_10002F8DC(void *a1)
{
  uint64_t v2 = a1[5];
  v5[0] = a1[4];
  v5[1] = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"%llu",  v2,  @"BundleID",  @"CoalitionID");
  v4[2] = @"Duration";
  SASecondsFromMachTimeUsingLiveTimebase(a1[6] - a1[7]);
  v5[2] = +[NSNumber numberWithDouble:](&OBJC_CLASS___NSNumber, "numberWithDouble:");
  v4[3] = @"ConditionsPreventingSubmission";
  v5[3] = +[NSNumber numberWithUnsignedLongLong:](&OBJC_CLASS___NSNumber, "numberWithUnsignedLongLong:", a1[8]);
  v4[4] = @"OtherConditions";
  v5[4] = +[NSNumber numberWithUnsignedLongLong:](&OBJC_CLASS___NSNumber, "numberWithUnsignedLongLong:", a1[9]);
  return +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v5,  v4,  5LL);
}

void sub_10002F9E8( int a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, char a6, double a7, double a8, double a9)
{
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 3221225472LL;
  v9[2] = sub_10002FA60;
  v9[3] = &unk_1000D8C70;
  int v10 = a1;
  char v11 = a6;
  *(double *)&v9[4] = a9;
  v9[5] = a4;
  v9[6] = a5;
  *(double *)&v9[7] = a8;
  *(double *)&v9[8] = a7;
  sub_10002F138(a1, a2, a3, 2LL, 0LL, 0LL, 0LL, 0LL, a7, a8, (uint64_t)v9);
}

void sub_10002FA60(uint64_t a1, os_log_t log, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if (os_signpost_enabled(log))
  {
    int v12 = *(_DWORD *)(a1 + 72);
    int v13 = *(unsigned __int8 *)(a1 + 76);
    double v14 = round(*(double *)(a1 + 32));
    uint64_t v15 = *(void *)(a1 + 40);
    uint64_t v16 = *(void *)(a1 + 48);
    *(_DWORD *)buf = 138545154;
    uint64_t v23 = a4;
    __int16 v24 = 2050;
    uint64_t v25 = a5;
    __int16 v26 = 2050;
    uint64_t v27 = a3;
    __int16 v28 = 1026;
    int v29 = v12;
    __int16 v30 = 1026;
    int v31 = v13;
    __int16 v32 = 2050;
    double v33 = v14;
    __int16 v34 = 2050;
    uint64_t v35 = v15;
    __int16 v36 = 2050;
    uint64_t v37 = v16;
    _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  log,  OS_SIGNPOST_INTERVAL_BEGIN,  0xEEEEB0B5B2B2EEEELL,  "CPUResource",  "BundleIdOverride=%{public,signpost.description:attribute}@ %{public,signpost.description:begin_time}llu cid=%{publ ic,name=cid}llu pid=%{public,name=pid}u fatal=%{public,name=fatal}d cpuUsed=%{public,name=cpuUsed}.0f conditionsPr eventingSubmission=%{public,name=conditionsPreventingSubmission}#llx otherConditions=%{public,name=otherConditions }#llx enableTelemetry=YES ",  buf,  0x4Au);
  }

  if (os_signpost_enabled(log))
  {
    *(_DWORD *)buf = 134349056;
    uint64_t v23 = a6;
    _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  log,  OS_SIGNPOST_INTERVAL_END,  0xEEEEB0B5B2B2EEEELL,  "CPUResource",  "%{public, signpost.description:end_time}llu",  buf,  0xCu);
  }

  if (&_AnalyticsIsEventUsed)
  {
    int IsEventUsed = AnalyticsIsEventUsed(@"com.apple.spindump.cpuusageresource");
    if (a4)
    {
      if (IsEventUsed)
      {
        v18[0] = _NSConcreteStackBlock;
        v18[1] = 3221225472LL;
        v18[2] = sub_10002FC54;
        v18[3] = &unk_1000D8C50;
        v18[4] = a4;
        v18[5] = a3;
        __int128 v19 = *(_OWORD *)(a1 + 56);
        uint64_t v20 = *(void *)(a1 + 32);
        __int128 v21 = *(_OWORD *)(a1 + 40);
        AnalyticsSendEventLazy(@"com.apple.spindump.cpuusageresource", v18);
      }
    }
  }

NSDictionary *sub_10002FC54(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  v5[0] = *(void *)(a1 + 32);
  v5[1] = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"%llu",  v2,  @"BundleID",  @"CoalitionID");
  v4[2] = @"Duration";
  v5[2] = +[NSNumber numberWithDouble:]( &OBJC_CLASS___NSNumber,  "numberWithDouble:",  *(double *)(a1 + 48) - *(double *)(a1 + 56));
  v4[3] = @"CpuUsedS";
  v5[3] = +[NSNumber numberWithDouble:](&OBJC_CLASS___NSNumber, "numberWithDouble:", *(double *)(a1 + 64));
  v4[4] = @"ConditionsPreventingSubmission";
  v5[4] = +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  *(void *)(a1 + 72));
  void v4[5] = @"OtherConditions";
  void v5[5] = +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  *(void *)(a1 + 80));
  return +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v5,  v4,  6LL);
}

void sub_10002FD6C(int a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, double a7, double a8)
{
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 3221225472LL;
  v8[2] = sub_10002FDE0;
  v8[3] = &unk_1000D8C90;
  int v9 = a1;
  v8[4] = a6;
  v8[5] = a4;
  v8[6] = a5;
  *(double *)&v8[7] = a8;
  *(double *)&v8[8] = a7;
  sub_10002F138(a1, a2, a3, 3LL, 0LL, 0LL, 0LL, 0LL, a7, a8, (uint64_t)v8);
}

void sub_10002FDE0(uint64_t a1, os_log_t log, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if (os_signpost_enabled(log))
  {
    int v12 = *(_DWORD *)(a1 + 72);
    uint64_t v13 = *(void *)(a1 + 40);
    unint64_t v14 = *(void *)(a1 + 32) / 0xF4240uLL;
    uint64_t v15 = *(void *)(a1 + 48);
    *(_DWORD *)buf = 138544898;
    uint64_t v23 = a4;
    __int16 v24 = 2050;
    uint64_t v25 = a5;
    __int16 v26 = 2050;
    uint64_t v27 = a3;
    __int16 v28 = 1026;
    int v29 = v12;
    __int16 v30 = 2050;
    unint64_t v31 = v14;
    __int16 v32 = 2050;
    uint64_t v33 = v13;
    __int16 v34 = 2050;
    uint64_t v35 = v15;
    _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  log,  OS_SIGNPOST_INTERVAL_BEGIN,  0xEEEEB0B5B2B2EEEELL,  "DiskWritesResource",  "BundleIdOverride=%{public, signpost.description:attribute}@ %{public, signpost.description:begin_time}llu cid=%{pu blic,name=cid}llu pid=%{public,name=pid}u ioMB=%{public,name=ioMB}llu conditionsPreventingSubmission=%{public,name =conditionsPreventingSubmission}#llx otherConditions=%{public,name=otherConditions}#llx enableTelemetry=YES ",  buf,  0x44u);
  }

  if (os_signpost_enabled(log))
  {
    *(_DWORD *)buf = 134349056;
    uint64_t v23 = a6;
    _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  log,  OS_SIGNPOST_INTERVAL_END,  0xEEEEB0B5B2B2EEEELL,  "DiskWritesResource",  "%{public, signpost.description:end_time}llu",  buf,  0xCu);
  }

  if (&_AnalyticsIsEventUsed)
  {
    int IsEventUsed = AnalyticsIsEventUsed(@"com.apple.spindump.diskwritesresource");
    if (a4)
    {
      if (IsEventUsed)
      {
        v18[0] = _NSConcreteStackBlock;
        v18[1] = 3221225472LL;
        v18[2] = sub_10002FFD4;
        v18[3] = &unk_1000D8C50;
        v18[4] = a4;
        v18[5] = a3;
        __int128 v17 = *(_OWORD *)(a1 + 32);
        __int128 v19 = *(_OWORD *)(a1 + 56);
        __int128 v20 = v17;
        uint64_t v21 = *(void *)(a1 + 48);
        AnalyticsSendEventLazy(@"com.apple.spindump.diskwritesresource", v18);
      }
    }
  }

NSDictionary *sub_10002FFD4(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  v5[0] = *(void *)(a1 + 32);
  v5[1] = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"%llu",  v2,  @"BundleID",  @"CoalitionID");
  v4[2] = @"Duration";
  v5[2] = +[NSNumber numberWithDouble:]( &OBJC_CLASS___NSNumber,  "numberWithDouble:",  *(double *)(a1 + 48) - *(double *)(a1 + 56));
  v4[3] = @"Bytes";
  v5[3] = +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  *(void *)(a1 + 64));
  v4[4] = @"ConditionsPreventingSubmission";
  v5[4] = +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  *(void *)(a1 + 72));
  void v4[5] = @"OtherConditions";
  void v5[5] = +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  *(void *)(a1 + 80));
  return +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v5,  v4,  6LL);
}

void sub_1000300EC(int a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  v7[1] = 3221225472LL;
  v7[2] = sub_100030160;
  v7[3] = &unk_1000D8C28;
  int v8 = a1;
  v7[4] = a6;
  v7[5] = a7;
  void v7[6] = a4;
  v7[7] = a5;
  v7[0] = _NSConcreteStackBlock;
  sub_10002F138(a1, a2, a3, 4LL, 0LL, 0LL, 0LL, 0LL, 0.0, 0.0, (uint64_t)v7);
}

void sub_100030160(uint64_t a1, os_log_t log, uint64_t a3, uint64_t a4)
{
  if (os_signpost_enabled(log))
  {
    int v8 = *(_DWORD *)(a1 + 64);
    uint64_t v9 = *(void *)(a1 + 32);
    uint64_t v10 = *(void *)(a1 + 40);
    uint64_t v11 = *(void *)(a1 + 48);
    uint64_t v12 = *(void *)(a1 + 56);
    *(_DWORD *)buf = 138544898;
    uint64_t v19 = a4;
    __int16 v20 = 2050;
    uint64_t v21 = a3;
    __int16 v22 = 1026;
    int v23 = v8;
    __int16 v24 = 2050;
    uint64_t v25 = v9;
    __int16 v26 = 2050;
    uint64_t v27 = v10;
    __int16 v28 = 2050;
    uint64_t v29 = v11;
    __int16 v30 = 2050;
    uint64_t v31 = v12;
    _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  log,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "FileDescriptorExhaustion",  "BundleIdOverride=%{public, signpost.description:attribute}@ cid=%{public,name=cid}llu pid=%{public,name=pid}u numF Ds=%{public,name=numFDs}llu numFDsLimit=%{public,name=numFDsLimit}llu conditionsPreventingSubmission=%{public,name =conditionsPreventingSubmission}#llx otherConditions=%{public,name=otherConditions}#llx enableTelemetry=YES ",  buf,  0x44u);
  }

  if (&_AnalyticsIsEventUsed)
  {
    int IsEventUsed = AnalyticsIsEventUsed(@"com.apple.spindump.filedescriptorexhaustion");
    if (a4)
    {
      if (IsEventUsed)
      {
        v15[0] = _NSConcreteStackBlock;
        v15[1] = 3221225472LL;
        v15[2] = sub_1000302C8;
        v15[3] = &unk_1000D8BE8;
        v15[4] = a4;
        v15[5] = a3;
        __int128 v14 = *(_OWORD *)(a1 + 48);
        __int128 v16 = *(_OWORD *)(a1 + 32);
        __int128 v17 = v14;
        AnalyticsSendEventLazy(@"com.apple.spindump.filedescriptorexhaustion", v15);
      }
    }
  }

NSDictionary *sub_1000302C8(void *a1)
{
  uint64_t v2 = a1[5];
  v5[0] = a1[4];
  v5[1] = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"%llu",  v2,  @"BundleID",  @"CoalitionID");
  v4[2] = @"NumFileDescriptors";
  v5[2] = +[NSNumber numberWithUnsignedLongLong:](&OBJC_CLASS___NSNumber, "numberWithUnsignedLongLong:", a1[6]);
  v4[3] = @"NumFileDescriptorsLimit";
  v5[3] = +[NSNumber numberWithUnsignedLongLong:](&OBJC_CLASS___NSNumber, "numberWithUnsignedLongLong:", a1[7]);
  v4[4] = @"ConditionsPreventingSubmission";
  v5[4] = +[NSNumber numberWithUnsignedLongLong:](&OBJC_CLASS___NSNumber, "numberWithUnsignedLongLong:", a1[8]);
  void v4[5] = @"OtherConditions";
  void v5[5] = +[NSNumber numberWithUnsignedLongLong:](&OBJC_CLASS___NSNumber, "numberWithUnsignedLongLong:", a1[9]);
  return +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v5,  v4,  6LL);
}

void sub_1000303DC(int a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  v7[1] = 3221225472LL;
  v7[2] = sub_100030450;
  v7[3] = &unk_1000D8C28;
  int v8 = a1;
  v7[4] = a6;
  v7[5] = a7;
  void v7[6] = a4;
  v7[7] = a5;
  v7[0] = _NSConcreteStackBlock;
  sub_10002F138(a1, a2, a3, 5LL, 0LL, 0LL, 0LL, 0LL, 0.0, 0.0, (uint64_t)v7);
}

void sub_100030450(uint64_t a1, os_log_t log, uint64_t a3, uint64_t a4)
{
  if (os_signpost_enabled(log))
  {
    int v8 = *(_DWORD *)(a1 + 64);
    uint64_t v9 = *(void *)(a1 + 32);
    uint64_t v10 = *(void *)(a1 + 40);
    uint64_t v11 = *(void *)(a1 + 48);
    uint64_t v12 = *(void *)(a1 + 56);
    *(_DWORD *)buf = 138544898;
    uint64_t v19 = a4;
    __int16 v20 = 2050;
    uint64_t v21 = a3;
    __int16 v22 = 1026;
    int v23 = v8;
    __int16 v24 = 2050;
    uint64_t v25 = v9;
    __int16 v26 = 2050;
    uint64_t v27 = v10;
    __int16 v28 = 2050;
    uint64_t v29 = v11;
    __int16 v30 = 2050;
    uint64_t v31 = v12;
    _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  log,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "PortExhaustion",  "BundleIdOverride=%{public, signpost.description:attribute}@ cid=%{public,name=cid}llu pid=%{public,name=pid}u numP orts=%{public,name=numPorts}llu numPortsLimit=%{public,name=numPortsLimit}llu conditionsPreventingSubmission=%{pub lic,name=conditionsPreventingSubmission}#llx otherConditions=%{public,name=otherConditions}#llx enableTelemetry=YES ",  buf,  0x44u);
  }

  if (&_AnalyticsIsEventUsed)
  {
    int IsEventUsed = AnalyticsIsEventUsed(@"com.apple.spindump.portexhaustion");
    if (a4)
    {
      if (IsEventUsed)
      {
        v15[0] = _NSConcreteStackBlock;
        v15[1] = 3221225472LL;
        v15[2] = sub_1000305B8;
        v15[3] = &unk_1000D8BE8;
        v15[4] = a4;
        v15[5] = a3;
        __int128 v14 = *(_OWORD *)(a1 + 48);
        __int128 v16 = *(_OWORD *)(a1 + 32);
        __int128 v17 = v14;
        AnalyticsSendEventLazy(@"com.apple.spindump.portexhaustion", v15);
      }
    }
  }

NSDictionary *sub_1000305B8(void *a1)
{
  uint64_t v2 = a1[5];
  v5[0] = a1[4];
  v5[1] = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"%llu",  v2,  @"BundleID",  @"CoalitionID");
  v4[2] = @"NumPorts";
  v5[2] = +[NSNumber numberWithUnsignedLongLong:](&OBJC_CLASS___NSNumber, "numberWithUnsignedLongLong:", a1[6]);
  v4[3] = @"NumPortsLimit";
  v5[3] = +[NSNumber numberWithUnsignedLongLong:](&OBJC_CLASS___NSNumber, "numberWithUnsignedLongLong:", a1[7]);
  v4[4] = @"ConditionsPreventingSubmission";
  v5[4] = +[NSNumber numberWithUnsignedLongLong:](&OBJC_CLASS___NSNumber, "numberWithUnsignedLongLong:", a1[8]);
  void v4[5] = @"OtherConditions";
  void v5[5] = +[NSNumber numberWithUnsignedLongLong:](&OBJC_CLASS___NSNumber, "numberWithUnsignedLongLong:", a1[9]);
  return +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v5,  v4,  6LL);
}

void sub_1000306CC(int a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  v7[1] = 3221225472LL;
  v7[2] = sub_100030740;
  v7[3] = &unk_1000D8C28;
  int v8 = a1;
  v7[4] = a6;
  v7[5] = a7;
  void v7[6] = a4;
  v7[7] = a5;
  v7[0] = _NSConcreteStackBlock;
  sub_10002F138(a1, a2, a3, 6LL, 0LL, 0LL, 0LL, 0LL, 0.0, 0.0, (uint64_t)v7);
}

void sub_100030740(uint64_t a1, os_log_t log, uint64_t a3, uint64_t a4)
{
  if (os_signpost_enabled(log))
  {
    int v8 = *(_DWORD *)(a1 + 64);
    uint64_t v9 = *(void *)(a1 + 32);
    uint64_t v10 = *(void *)(a1 + 40);
    uint64_t v11 = *(void *)(a1 + 48);
    uint64_t v12 = *(void *)(a1 + 56);
    *(_DWORD *)buf = 138544898;
    uint64_t v19 = a4;
    __int16 v20 = 2050;
    uint64_t v21 = a3;
    __int16 v22 = 1026;
    int v23 = v8;
    __int16 v24 = 2050;
    uint64_t v25 = v9;
    __int16 v26 = 2050;
    uint64_t v27 = v10;
    __int16 v28 = 2050;
    uint64_t v29 = v11;
    __int16 v30 = 2050;
    uint64_t v31 = v12;
    _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  log,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "KQWorkLoopExhaustion",  "BundleIdOverride=%{public, signpost.description:attribute}@ cid=%{public,name=cid}llu pid=%{public,name=pid}u numK QWorkLoops=%{public,name=numKQWorkLoops}llu numKQWorkLoopsLimit=%{public,name=numKQWorkLoopsLimit}llu conditionsPr eventingSubmission=%{public,name=conditionsPreventingSubmission}#llx otherConditions=%{public,name=otherConditions }#llx enableTelemetry=YES ",  buf,  0x44u);
  }

  if (&_AnalyticsIsEventUsed)
  {
    int IsEventUsed = AnalyticsIsEventUsed(@"com.apple.spindump.kqworkloopexhaustion");
    if (a4)
    {
      if (IsEventUsed)
      {
        v15[0] = _NSConcreteStackBlock;
        v15[1] = 3221225472LL;
        v15[2] = sub_1000308A8;
        v15[3] = &unk_1000D8BE8;
        v15[4] = a4;
        v15[5] = a3;
        __int128 v14 = *(_OWORD *)(a1 + 48);
        __int128 v16 = *(_OWORD *)(a1 + 32);
        __int128 v17 = v14;
        AnalyticsSendEventLazy(@"com.apple.spindump.kqworkloopexhaustion", v15);
      }
    }
  }

NSDictionary *sub_1000308A8(void *a1)
{
  uint64_t v2 = a1[5];
  v5[0] = a1[4];
  v5[1] = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"%llu",  v2,  @"BundleID",  @"CoalitionID");
  v4[2] = @"NumKQWorkLoops";
  v5[2] = +[NSNumber numberWithUnsignedLongLong:](&OBJC_CLASS___NSNumber, "numberWithUnsignedLongLong:", a1[6]);
  v4[3] = @"NumKQWorkLoopsLimit";
  v5[3] = +[NSNumber numberWithUnsignedLongLong:](&OBJC_CLASS___NSNumber, "numberWithUnsignedLongLong:", a1[7]);
  v4[4] = @"ConditionsPreventingSubmission";
  v5[4] = +[NSNumber numberWithUnsignedLongLong:](&OBJC_CLASS___NSNumber, "numberWithUnsignedLongLong:", a1[8]);
  void v4[5] = @"OtherConditions";
  void v5[5] = +[NSNumber numberWithUnsignedLongLong:](&OBJC_CLASS___NSNumber, "numberWithUnsignedLongLong:", a1[9]);
  return +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v5,  v4,  6LL);
}

void sub_1000309BC(int a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  v7[1] = 3221225472LL;
  v7[2] = sub_100030A30;
  v7[3] = &unk_1000D8C28;
  int v8 = a1;
  v7[4] = a4;
  v7[5] = a5;
  void v7[6] = a7;
  v7[7] = a6;
  v7[0] = _NSConcreteStackBlock;
  sub_10002F138(a1, a2, a3, 7LL, 0LL, 0LL, a6, a7, 0.0, 0.0, (uint64_t)v7);
}

void sub_100030A30(uint64_t a1, os_log_t log, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if (os_signpost_enabled(log))
  {
    int v12 = *(_DWORD *)(a1 + 64);
    uint64_t v13 = *(void *)(a1 + 32);
    uint64_t v14 = *(void *)(a1 + 40);
    *(_DWORD *)buf = 138544642;
    uint64_t v21 = a4;
    __int16 v22 = 2050;
    uint64_t v23 = a5;
    __int16 v24 = 2050;
    uint64_t v25 = a3;
    __int16 v26 = 1026;
    int v27 = v12;
    __int16 v28 = 2050;
    uint64_t v29 = v13;
    __int16 v30 = 2050;
    uint64_t v31 = v14;
    _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  log,  OS_SIGNPOST_INTERVAL_BEGIN,  0xEEEEB0B5B2B2EEEELL,  "StuckApp",  "BundleIdOverride=%{public, signpost.description:attribute}@ %{public, signpost.description:begin_time}llu cid=%{pu blic,name=cid}llu pid=%{public,name=pid}u conditionsPreventingSubmission=%{public,name=conditionsPreventingSubmiss ion}#llx otherConditions=%{public,name=otherConditions}#llx enableTelemetry=YES ",  buf,  0x3Au);
  }

  if (os_signpost_enabled(log))
  {
    *(_DWORD *)buf = 134349056;
    uint64_t v21 = a6;
    _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  log,  OS_SIGNPOST_INTERVAL_END,  0xEEEEB0B5B2B2EEEELL,  "StuckApp",  "%{public, signpost.description:end_time}llu",  buf,  0xCu);
  }

  if (&_AnalyticsIsEventUsed)
  {
    int IsEventUsed = AnalyticsIsEventUsed(@"com.apple.spindump.stuckapp");
    if (a4)
    {
      if (IsEventUsed)
      {
        v17[0] = _NSConcreteStackBlock;
        v17[1] = 3221225472LL;
        v17[2] = sub_100030BEC;
        v17[3] = &unk_1000D8BE8;
        v17[4] = a4;
        v17[5] = a3;
        __int128 v16 = *(_OWORD *)(a1 + 32);
        __int128 v18 = *(_OWORD *)(a1 + 48);
        __int128 v19 = v16;
        AnalyticsSendEventLazy(@"com.apple.spindump.stuckapp", v17);
      }
    }
  }

NSDictionary *sub_100030BEC(void *a1)
{
  uint64_t v2 = a1[5];
  v5[0] = a1[4];
  v5[1] = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"%llu",  v2,  @"BundleID",  @"CoalitionID");
  v4[2] = @"Duration";
  SASecondsFromMachTimeUsingLiveTimebase(a1[6] - a1[7]);
  v5[2] = +[NSNumber numberWithDouble:](&OBJC_CLASS___NSNumber, "numberWithDouble:");
  v4[3] = @"ConditionsPreventingSubmission";
  v5[3] = +[NSNumber numberWithUnsignedLongLong:](&OBJC_CLASS___NSNumber, "numberWithUnsignedLongLong:", a1[8]);
  v4[4] = @"OtherConditions";
  v5[4] = +[NSNumber numberWithUnsignedLongLong:](&OBJC_CLASS___NSNumber, "numberWithUnsignedLongLong:", a1[9]);
  return +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v5,  v4,  5LL);
}

void sub_100030CF8(int a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  v7[1] = 3221225472LL;
  v7[2] = sub_100030D6C;
  v7[3] = &unk_1000D8C28;
  int v8 = a1;
  v7[4] = a4;
  v7[5] = a5;
  void v7[6] = a7;
  v7[7] = a6;
  v7[0] = _NSConcreteStackBlock;
  sub_10002F138(a1, a2, a3, 8LL, 0LL, 0LL, a6, a7, 0.0, 0.0, (uint64_t)v7);
}

void sub_100030D6C(uint64_t a1, os_log_t log, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if (os_signpost_enabled(log))
  {
    int v12 = *(_DWORD *)(a1 + 64);
    uint64_t v13 = *(void *)(a1 + 32);
    uint64_t v14 = *(void *)(a1 + 40);
    *(_DWORD *)buf = 138544642;
    uint64_t v21 = a4;
    __int16 v22 = 2050;
    uint64_t v23 = a5;
    __int16 v24 = 2050;
    uint64_t v25 = a3;
    __int16 v26 = 1026;
    int v27 = v12;
    __int16 v28 = 2050;
    uint64_t v29 = v13;
    __int16 v30 = 2050;
    uint64_t v31 = v14;
    _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  log,  OS_SIGNPOST_INTERVAL_BEGIN,  0xEEEEB0B5B2B2EEEELL,  "ServiceWatchdog",  "BundleIdOverride=%{public, signpost.description:attribute}@ %{public, signpost.description:begin_time}llu cid=%{pu blic,name=cid}llu pid=%{public,name=pid}u conditionsPreventingSubmission=%{public,name=conditionsPreventingSubmiss ion}#llx otherConditions=%{public,name=otherConditions}#llx enableTelemetry=YES ",  buf,  0x3Au);
  }

  if (os_signpost_enabled(log))
  {
    *(_DWORD *)buf = 134349056;
    uint64_t v21 = a6;
    _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  log,  OS_SIGNPOST_INTERVAL_END,  0xEEEEB0B5B2B2EEEELL,  "ServiceWatchdog",  "%{public, signpost.description:end_time}llu",  buf,  0xCu);
  }

  if (&_AnalyticsIsEventUsed)
  {
    int IsEventUsed = AnalyticsIsEventUsed(@"com.apple.spindump.servicewatchdog");
    if (a4)
    {
      if (IsEventUsed)
      {
        v17[0] = _NSConcreteStackBlock;
        v17[1] = 3221225472LL;
        v17[2] = sub_100030F28;
        v17[3] = &unk_1000D8BE8;
        v17[4] = a4;
        v17[5] = a3;
        __int128 v16 = *(_OWORD *)(a1 + 32);
        __int128 v18 = *(_OWORD *)(a1 + 48);
        __int128 v19 = v16;
        AnalyticsSendEventLazy(@"com.apple.spindump.servicewatchdog", v17);
      }
    }
  }

NSDictionary *sub_100030F28(void *a1)
{
  uint64_t v2 = a1[5];
  v5[0] = a1[4];
  v5[1] = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"%llu",  v2,  @"BundleID",  @"CoalitionID");
  v4[2] = @"Duration";
  SASecondsFromMachTimeUsingLiveTimebase(a1[6] - a1[7]);
  v5[2] = +[NSNumber numberWithDouble:](&OBJC_CLASS___NSNumber, "numberWithDouble:");
  v4[3] = @"ConditionsPreventingSubmission";
  v5[3] = +[NSNumber numberWithUnsignedLongLong:](&OBJC_CLASS___NSNumber, "numberWithUnsignedLongLong:", a1[8]);
  v4[4] = @"OtherConditions";
  v5[4] = +[NSNumber numberWithUnsignedLongLong:](&OBJC_CLASS___NSNumber, "numberWithUnsignedLongLong:", a1[9]);
  return +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v5,  v4,  5LL);
}

void sub_100031034( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = *(void *)(a1 + 32);
  if (v9
    && (uint64_t v10 = -[NSURL initFileURLWithPath:isDirectory:]( objc_alloc(&OBJC_CLASS___NSURL),  "initFileURLWithPath:isDirectory:",  v9,  0LL)) != 0LL)
  {
    uint64_t v11 = v10;
    int v12 = (__CFBundle *)_CFBundleCreateWithExecutableURLIfLooksLikeBundle(0LL, v10);
    if (v12)
    {
      uint64_t v13 = v12;
      int v83 = (id)CFBundleGetIdentifier(v12);
      CFRelease(v13);
    }

    else
    {
      int v83 = 0LL;
    }

    uint64_t v14 = v83;
  }

  else
  {
    uint64_t v14 = 0LL;
  }

  uint64_t v16 = *(void *)(a1 + 72);
  uint64_t v15 = *(void *)(a1 + 80);
  if (v16) {
    BOOL v17 = v15 == 0;
  }
  else {
    BOOL v17 = 1;
  }
  double v84 = (__CFString *)v14;
  if (v17)
  {
    uint64_t v18 = *(void *)(a1 + 88);
    if (v18 && *(void *)(a1 + 96))
    {
      [*(id *)(a1 + 40) machContTime];
      [*(id *)(a1 + 40) machAbsTime];
    }

    else
    {
      double v19 = *(double *)(a1 + 104);
      if (v19 == 0.0 || *(double *)(a1 + 112) == 0.0)
      {
        if (v16 | v18 | v15
          || (v19 == 0.0 ? (BOOL v24 = *(void *)(a1 + 96) == 0LL) : (BOOL v24 = 0), !v24 || *(double *)(a1 + 112) != 0.0))
        {
          if ((*(_DWORD *)(a1 + 128) & 0x80000000) != 0)
          {
            if (byte_1000E7D30)
            {
              int v49 = *__error();
              int v50 = (os_log_s *)sub_10002EFA0();
              if (os_log_type_enabled(v50, OS_LOG_TYPE_ERROR))
              {
                uint64_t v51 = *(void *)(a1 + 72);
                uint64_t v52 = *(void *)(a1 + 80);
                uint64_t v53 = *(void *)(a1 + 88);
                uint64_t v54 = *(void *)(a1 + 96);
                uint64_t v55 = *(void *)(a1 + 104);
                uint64_t v56 = *(void *)(a1 + 112);
                *(_DWORD *)buf = 136316674;
                int v86 = "startTimeMachCont == 0 && endTimeMachCont == 0 && startTimeMachAbs == 0 && endTimeMachAbs == 0 && "
                      "startTimeCF == 0 && endTimeCF == 0";
                __int16 v87 = 2048;
                *(void *)int v88 = v51;
                *(_WORD *)&v88[8] = 2048;
                *(void *)&v88[10] = v52;
                *(_WORD *)&v88[18] = 2048;
                *(void *)&v88[20] = v53;
                *(_WORD *)&v88[28] = 2048;
                *(void *)&v88[30] = v54;
                *(_WORD *)&v88[38] = 2048;
                *(void *)&v88[40] = v55;
                *(_WORD *)&v88[48] = 2048;
                *(void *)&v88[50] = v56;
                _os_log_error_impl( (void *)&_mh_execute_header,  v50,  OS_LOG_TYPE_ERROR,  "%s: No matching timestamps provided: %llu-%llu, %llu-%llu, %.2f-%.2f",  buf,  0x48u);
              }

              *__error() = v49;
            }

            if (byte_1000E7D31) {
              BOOL v57 = dword_1000E74E0 <= 3;
            }
            else {
              BOOL v57 = 0;
            }
            if (v57)
            {
              int v58 = *__error();
              int v59 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"%s: No matching timestamps provided: %llu-%llu, %llu-%llu, %.2f-%.2f",  "startTimeMachCont == 0 && endTimeMachCont == 0 && startTimeMachAbs == 0 && endTimeMachAbs == 0 && startTimeCF == 0 && endTimeCF == 0",  *(void *)(a1 + 72),  *(void *)(a1 + 80),  *(void *)(a1 + 88),  *(void *)(a1 + 96),  *(void *)(a1 + 104),  *(void *)(a1 + 112));
              if (v59)
              {
                int v72 = v59;
                CStringPtr = CFStringGetCStringPtr(v59, 0x8000100u);
                if (CStringPtr)
                {
                  int v74 = (char *)CStringPtr;
                  unsigned int v75 = 0LL;
                }

                else
                {
                  int v74 = (char *)calloc(0x400uLL, 1uLL);
                  CFStringGetCString(v72, v74, 1024LL, 0x8000100u);
                  unsigned int v75 = v74;
                }

                if (qword_1000E7D38) {
                  uint64_t v82 = (FILE *)qword_1000E7D38;
                }
                else {
                  uint64_t v82 = __stderrp;
                }
                fprintf(v82, "%s\n", v74);
                if (v75) {
                  free(v75);
                }
                CFRelease(v72);
              }

              else
              {
                int v60 = (os_log_s *)sub_10002EFA0();
                if (os_log_type_enabled(v60, OS_LOG_TYPE_FAULT))
                {
                  uint64_t v61 = *(void *)(a1 + 72);
                  uint64_t v62 = *(void *)(a1 + 80);
                  uint64_t v63 = *(void *)(a1 + 88);
                  uint64_t v64 = *(void *)(a1 + 96);
                  uint64_t v65 = *(void *)(a1 + 104);
                  uint64_t v66 = *(void *)(a1 + 112);
                  *(_DWORD *)buf = 136316674;
                  int v86 = "startTimeMachCont == 0 && endTimeMachCont == 0 && startTimeMachAbs == 0 && endTimeMachAbs == 0 &"
                        "& startTimeCF == 0 && endTimeCF == 0";
                  __int16 v87 = 2048;
                  *(void *)int v88 = v61;
                  *(_WORD *)&v88[8] = 2048;
                  *(void *)&v88[10] = v62;
                  *(_WORD *)&v88[18] = 2048;
                  *(void *)&v88[20] = v63;
                  *(_WORD *)&v88[28] = 2048;
                  *(void *)&v88[30] = v64;
                  *(_WORD *)&v88[38] = 2048;
                  *(void *)&v88[40] = v65;
                  *(_WORD *)&v88[48] = 2048;
                  *(void *)&v88[50] = v66;
                  _os_log_fault_impl( (void *)&_mh_execute_header,  v60,  OS_LOG_TYPE_FAULT,  "Unable to format: %s: No matching timestamps provided: %llu-%llu, %llu-%llu, %.2f-%.2f",  buf,  0x48u);
                }

                if (qword_1000E7D38) {
                  uint64_t v67 = (FILE *)qword_1000E7D38;
                }
                else {
                  uint64_t v67 = __stderrp;
                }
                fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v67);
              }

              *__error() = v58;
            }

            sub_10002EE78( "_SPEventRateReportEvent_block_invoke",  "SPEventRate.m",  339,  "%s: No matching timestamps provided: %llu-%llu, %llu-%llu, %.2f-%.2f",  a5,  v15,  a7,  a8,  (char)"startTimeMachCont == 0 && endTimeMachCont == 0 && startTimeMachAbs == 0 && endTimeMachAbs == 0 && st artTimeCF == 0 && endTimeCF == 0");
          }

          else
          {
            if (byte_1000E7D30)
            {
              int v25 = *__error();
              __int16 v26 = (os_log_s *)sub_10002EFA0();
              if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
              {
                int v27 = (const char *)sub_10002EF3C(*(_DWORD *)(a1 + 128));
                int v28 = *(_DWORD *)(a1 + 128);
                uint64_t v29 = *(void *)(a1 + 72);
                uint64_t v30 = *(void *)(a1 + 80);
                uint64_t v31 = *(void *)(a1 + 88);
                uint64_t v32 = *(void *)(a1 + 96);
                uint64_t v33 = *(void *)(a1 + 104);
                uint64_t v34 = *(void *)(a1 + 112);
                *(_DWORD *)buf = 136317186;
                int v86 = v27;
                __int16 v87 = 1024;
                *(_DWORD *)int v88 = v28;
                *(_WORD *)&v88[4] = 2080;
                *(void *)&v88[6] = "startTimeMachCont == 0 && endTimeMachCont == 0 && startTimeMachAbs == 0 && endTimeM"
                                     "achAbs == 0 && startTimeCF == 0 && endTimeCF == 0";
                *(_WORD *)&v88[14] = 2048;
                *(void *)&v88[16] = v29;
                *(_WORD *)&v88[24] = 2048;
                *(void *)&v88[26] = v30;
                *(_WORD *)&v88[34] = 2048;
                *(void *)&v88[36] = v31;
                *(_WORD *)&v88[44] = 2048;
                *(void *)&v88[46] = v32;
                *(_WORD *)&v88[54] = 2048;
                *(void *)&v88[56] = v33;
                __int16 v89 = 2048;
                uint64_t v90 = v34;
                _os_log_error_impl( (void *)&_mh_execute_header,  v26,  OS_LOG_TYPE_ERROR,  "%s [%d]: %s: No matching timestamps provided: %llu-%llu, %llu-%llu, %.2f-%.2f",  buf,  0x58u);
              }

              *__error() = v25;
            }

            if (byte_1000E7D31) {
              BOOL v35 = dword_1000E74E0 <= 3;
            }
            else {
              BOOL v35 = 0;
            }
            if (v35)
            {
              int v36 = *__error();
              uint64_t v37 = sub_10002EF3C(*(_DWORD *)(a1 + 128));
              uint64_t v38 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"%s [%d]: %s: No matching timestamps provided: %llu-%llu, %llu-%llu, %.2f-%.2f",  v37,  *(unsigned int *)(a1 + 128),  "startTimeMachCont == 0 && endTimeMachCont == 0 && startTimeMachAbs == 0 && endTimeMachAbs == 0 && startTimeCF == 0 && endTimeCF == 0",  *(void *)(a1 + 72),  *(void *)(a1 + 80),  *(void *)(a1 + 88),  *(void *)(a1 + 96),  *(void *)(a1 + 104),  *(void *)(a1 + 112));
              if (v38)
              {
                unsigned int v68 = v38;
                unsigned int v69 = CFStringGetCStringPtr(v38, 0x8000100u);
                if (v69)
                {
                  id v70 = (char *)v69;
                  int v71 = 0LL;
                }

                else
                {
                  id v70 = (char *)calloc(0x400uLL, 1uLL);
                  CFStringGetCString(v68, v70, 1024LL, 0x8000100u);
                  int v71 = v70;
                }

                if (qword_1000E7D38) {
                  id v76 = (FILE *)qword_1000E7D38;
                }
                else {
                  id v76 = __stderrp;
                }
                fprintf(v76, "%s\n", v70);
                if (v71) {
                  free(v71);
                }
                CFRelease(v68);
              }

              else
              {
                uint64_t v39 = (os_log_s *)sub_10002EFA0();
                if (os_log_type_enabled(v39, OS_LOG_TYPE_FAULT))
                {
                  uint64_t v40 = (const char *)sub_10002EF3C(*(_DWORD *)(a1 + 128));
                  int v41 = *(_DWORD *)(a1 + 128);
                  uint64_t v42 = *(void *)(a1 + 72);
                  uint64_t v43 = *(void *)(a1 + 80);
                  uint64_t v44 = *(void *)(a1 + 88);
                  uint64_t v45 = *(void *)(a1 + 96);
                  uint64_t v46 = *(void *)(a1 + 104);
                  uint64_t v47 = *(void *)(a1 + 112);
                  *(_DWORD *)buf = 136317186;
                  int v86 = v40;
                  __int16 v87 = 1024;
                  *(_DWORD *)int v88 = v41;
                  *(_WORD *)&v88[4] = 2080;
                  *(void *)&v88[6] = "startTimeMachCont == 0 && endTimeMachCont == 0 && startTimeMachAbs == 0 && endTim"
                                       "eMachAbs == 0 && startTimeCF == 0 && endTimeCF == 0";
                  *(_WORD *)&v88[14] = 2048;
                  *(void *)&v88[16] = v42;
                  *(_WORD *)&v88[24] = 2048;
                  *(void *)&v88[26] = v43;
                  *(_WORD *)&v88[34] = 2048;
                  *(void *)&v88[36] = v44;
                  *(_WORD *)&v88[44] = 2048;
                  *(void *)&v88[46] = v45;
                  *(_WORD *)&v88[54] = 2048;
                  *(void *)&v88[56] = v46;
                  __int16 v89 = 2048;
                  uint64_t v90 = v47;
                  _os_log_fault_impl( (void *)&_mh_execute_header,  v39,  OS_LOG_TYPE_FAULT,  "Unable to format: %s [%d]: %s: No matching timestamps provided: %llu-%llu, %llu-%llu, %.2f-%.2f",  buf,  0x58u);
                }

                if (qword_1000E7D38) {
                  unint64_t v48 = (FILE *)qword_1000E7D38;
                }
                else {
                  unint64_t v48 = __stderrp;
                }
                fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v48);
              }

              *__error() = v36;
            }

            char v77 = sub_10002EF3C(*(_DWORD *)(a1 + 128));
            sub_10002EE78( "_SPEventRateReportEvent_block_invoke",  "SPEventRate.m",  339,  "%s [%d]: %s: No matching timestamps provided: %llu-%llu, %llu-%llu, %.2f-%.2f",  v78,  v79,  v80,  v81,  v77);
          }

          abort();
        }
      }

      else
      {
        [*(id *)(a1 + 40) machContTime];
        id v20 = [*(id *)(a1 + 40) wallTime];
        SAMachTimeFromSecondsUsingLiveTimebase(v20, v21 - *(double *)(a1 + 104));
        [*(id *)(a1 + 40) machContTime];
        id v22 = [*(id *)(a1 + 40) wallTime];
        SAMachTimeFromSecondsUsingLiveTimebase(v22, v23 - *(double *)(a1 + 112));
      }
    }
  }

  (*(void (**)(void))(*(void *)(a1 + 64) + 16LL))();
}

void sub_1000317F4(id a1)
{
  qword_1000E7B68 = (uint64_t)os_log_create("com.apple.spindump", "SpinTelemetry");
  qword_1000E7B70 = (uint64_t)os_log_create("com.apple.spindump", "HangTelemetry");
  qword_1000E7B78 = (uint64_t)os_log_create("com.apple.spindump", "CPUResourceTelemetry");
  qword_1000E7B80 = (uint64_t)os_log_create("com.apple.spindump", "DiskWritesResourceTelemetry");
  qword_1000E7B88 = (uint64_t)os_log_create("com.apple.spindump", "FileDescriptorExhaustion");
  qword_1000E7B90 = (uint64_t)os_log_create("com.apple.spindump", "PortExhaustion");
  qword_1000E7B98 = (uint64_t)os_log_create("com.apple.spindump", "KQWorkLoopExhaustion");
  qword_1000E7BA0 = (uint64_t)os_log_create("com.apple.spindump", "StuckApp");
  qword_1000E7BA8 = (uint64_t)os_log_create("com.apple.spindump", "ServiceWatchdog");
}

void sub_1000318EC(id a1)
{
  unsigned int v1 = dispatch_queue_attr_make_with_autorelease_frequency(0LL, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
  uint64_t v2 = dispatch_queue_attr_make_with_qos_class(v1, QOS_CLASS_BACKGROUND, 0);
  qword_1000E7BB8 = (uint64_t)dispatch_queue_create("com.apple.spindump.eventrate", v2);
  dispatch_release(v2);
  dispatch_release(v1);
}

void sub_100031D60(const char *a1)
{
  uint64_t v2 = objc_autoreleasePoolPush();
  int v3 = strdup(a1);
  int v4 = (char *)calloc(0x400uLL, 1uLL);
  basename_r(v3, v4);
  uint64_t v5 = sub_10002EDE8("WR for %s", v4);
  free(v4);
  if (qword_1000E7BD0 != -1) {
    dispatch_once(&qword_1000E7BD0, &stru_1000D8DF8);
  }
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472LL;
  block[2] = sub_100031E48;
  block[3] = &unk_1000D8DD8;
  block[4] = v5;
  void block[5] = v3;
  dispatch_async((dispatch_queue_t)qword_1000E7BC8, block);
  objc_autoreleasePoolPop(v2);
}

void sub_100031E48(uint64_t a1)
{
  uint64_t v2 = objc_alloc_init(&OBJC_CLASS___NSUUID);
  if (!objc_opt_class(&OBJC_CLASS___WRWorkflow))
  {
    if (byte_1000E7D30)
    {
      int v12 = *__error();
      uint64_t v13 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR)) {
        sub_10007FF54();
      }
      *__error() = v12;
    }

    if (byte_1000E7D31) {
      BOOL v14 = dword_1000E74E0 <= 3;
    }
    else {
      BOOL v14 = 0;
    }
    if (v14)
    {
      int v15 = *__error();
      uint64_t v16 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"WR: WorkflowResponsivness unavailable, not generating spindump report(s) for %s",  *(void *)(a1 + 40));
      BOOL v17 = v16;
      if (v16)
      {
        CStringPtr = (char *)CFStringGetCStringPtr(v16, 0x8000100u);
        if (CStringPtr)
        {
          double v19 = 0LL;
        }

        else
        {
          CStringPtr = (char *)calloc(0x400uLL, 1uLL);
          CFStringGetCString(v17, CStringPtr, 1024LL, 0x8000100u);
          double v19 = CStringPtr;
        }

        if (qword_1000E7D38) {
          unsigned int v68 = (FILE *)qword_1000E7D38;
        }
        else {
          unsigned int v68 = __stderrp;
        }
        fprintf(v68, "%s\n", CStringPtr);
        if (v19) {
          free(v19);
        }
        CFRelease(v17);
      }

      else
      {
        uint64_t v29 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v29, OS_LOG_TYPE_FAULT)) {
          sub_10007FEF4();
        }
        if (qword_1000E7D38) {
          uint64_t v30 = (FILE *)qword_1000E7D38;
        }
        else {
          uint64_t v30 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v30);
      }

      *__error() = v15;
    }

    unsigned int v69 = *(void **)(a1 + 40);
    goto LABEL_188;
  }

  v509 = v2;
  uint64_t v580 = 0LL;
  uint64_t v515 = a1;
  v510 = (void **)(a1 + 40);
  int v3 =  -[WRWorkflowEventTracker initWithTailspin:error:]( objc_alloc(&OBJC_CLASS___WRWorkflowEventTracker),  "initWithTailspin:error:",  +[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", *(void *)(a1 + 40)),  &v580);
  v541 = v3;
  if (!v3)
  {
    if (byte_1000E7D30)
    {
      int v20 = *__error();
      double v21 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR)) {
        sub_100080018();
      }
      *__error() = v20;
    }

    if (byte_1000E7D31 && dword_1000E74E0 <= 3)
    {
      int v22 = *__error();
      double v23 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"WR: Unable to decode workflow event tracker: %@",  v580);
      BOOL v24 = v23;
      if (v23)
      {
        int v25 = (char *)CFStringGetCStringPtr(v23, 0x8000100u);
        if (v25)
        {
          __int16 v26 = 0LL;
        }

        else
        {
          int v25 = (char *)calloc(0x400uLL, 1uLL);
          CFStringGetCString(v24, v25, 1024LL, 0x8000100u);
          __int16 v26 = v25;
        }

        if (qword_1000E7D38) {
          uint64_t v79 = (FILE *)qword_1000E7D38;
        }
        else {
          uint64_t v79 = __stderrp;
        }
        fprintf(v79, "%s\n", v25);
        if (v26) {
          free(v26);
        }
        CFRelease(v24);
      }

      else
      {
        id v70 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v70, OS_LOG_TYPE_FAULT)) {
          sub_10007FFB8();
        }
        if (qword_1000E7D38) {
          int v71 = (FILE *)qword_1000E7D38;
        }
        else {
          int v71 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v71);
      }

      *__error() = v22;
    }

    goto LABEL_187;
  }

  id v511 = objc_msgSend(-[WRWorkflowEventTracker workflow](v3, "workflow"), "name");
  if (byte_1000E7D30)
  {
    int v4 = *__error();
    uint64_t v5 = (os_log_s *)sub_10002EFA0();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      __int16 v6 = *v510;
      *(_DWORD *)buf = 138412546;
      id v621 = v511;
      __int16 v622 = 2080;
      id v623 = v6;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "WR: %@: Received tailspin path %s",  buf,  0x16u);
    }

    *__error() = v4;
  }

  if (byte_1000E7D31 && dword_1000E74E0 <= 2)
  {
    int v7 = *__error();
    int v8 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"WR: %@: Received tailspin path %s", v511, *v510);
    uint64_t v9 = v8;
    if (v8)
    {
      uint64_t v10 = (char *)CFStringGetCStringPtr(v8, 0x8000100u);
      if (v10)
      {
        uint64_t v11 = 0LL;
      }

      else
      {
        uint64_t v10 = (char *)calloc(0x400uLL, 1uLL);
        CFStringGetCString(v9, v10, 1024LL, 0x8000100u);
        uint64_t v11 = v10;
      }

      if (qword_1000E7D38) {
        uint64_t v31 = (FILE *)qword_1000E7D38;
      }
      else {
        uint64_t v31 = __stderrp;
      }
      fprintf(v31, "%s\n", v10);
      if (v11) {
        free(v11);
      }
      CFRelease(v9);
    }

    else
    {
      int v27 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v27, OS_LOG_TYPE_FAULT)) {
        sub_100080BE8();
      }
      if (qword_1000E7D38) {
        int v28 = (FILE *)qword_1000E7D38;
      }
      else {
        int v28 = __stderrp;
      }
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v28);
    }

    *__error() = v7;
  }

  id v32 = -[WRWorkflowEventTracker eventStart](v541, "eventStart");
  if (!v32)
  {
    if (byte_1000E7D30)
    {
      int v47 = *__error();
      unint64_t v48 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v48, OS_LOG_TYPE_ERROR)) {
        sub_1000800D8();
      }
      *__error() = v47;
    }

    if (byte_1000E7D31 && dword_1000E74E0 <= 3)
    {
      int v49 = *__error();
      int v50 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"WR: %@: No workflow event start", v511);
      uint64_t v51 = v50;
      if (v50)
      {
        uint64_t v52 = (char *)CFStringGetCStringPtr(v50, 0x8000100u);
        if (v52)
        {
          uint64_t v53 = 0LL;
        }

        else
        {
          uint64_t v52 = (char *)calloc(0x400uLL, 1uLL);
          CFStringGetCString(v51, v52, 1024LL, 0x8000100u);
          uint64_t v53 = v52;
        }

        if (qword_1000E7D38) {
          uint64_t v82 = (FILE *)qword_1000E7D38;
        }
        else {
          uint64_t v82 = __stderrp;
        }
        fprintf(v82, "%s\n", v52);
        if (v53) {
          free(v53);
        }
        CFRelease(v51);
      }

      else
      {
        uint64_t v80 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v80, OS_LOG_TYPE_FAULT)) {
          sub_100080078();
        }
        if (qword_1000E7D38) {
          uint64_t v81 = (FILE *)qword_1000E7D38;
        }
        else {
          uint64_t v81 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v81);
      }

      *__error() = v49;
    }

    goto LABEL_187;
  }

  id v33 = -[WRWorkflowEventTracker eventEnd](v541, "eventEnd");
  if (!v33)
  {
    if (byte_1000E7D30)
    {
      int v54 = *__error();
      uint64_t v55 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v55, OS_LOG_TYPE_ERROR)) {
        sub_100080198();
      }
      *__error() = v54;
    }

    if (byte_1000E7D31 && dword_1000E74E0 <= 3)
    {
      int v56 = *__error();
      BOOL v57 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"WR: %@: No workflow event end", v511);
      int v58 = v57;
      if (v57)
      {
        int v59 = (char *)CFStringGetCStringPtr(v57, 0x8000100u);
        if (v59)
        {
          int v60 = 0LL;
        }

        else
        {
          int v59 = (char *)calloc(0x400uLL, 1uLL);
          CFStringGetCString(v58, v59, 1024LL, 0x8000100u);
          int v60 = v59;
        }

        if (qword_1000E7D38) {
          __int16 v87 = (FILE *)qword_1000E7D38;
        }
        else {
          __int16 v87 = __stderrp;
        }
        fprintf(v87, "%s\n", v59);
        if (v60) {
          free(v60);
        }
        CFRelease(v58);
      }

      else
      {
        int v83 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v83, OS_LOG_TYPE_FAULT)) {
          sub_100080138();
        }
        if (qword_1000E7D38) {
          double v84 = (FILE *)qword_1000E7D38;
        }
        else {
          double v84 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v84);
      }

      *__error() = v56;
    }

    goto LABEL_187;
  }

  uint64_t v34 = [v33 machContTimeNs];
  uint64_t v35 = v34 - (_BYTE *)[v32 machContTimeNs];
  double v36 = (double)v35 / 1000000000.0;
  if (v36 <= 0.0)
  {
    if (byte_1000E7D30)
    {
      int v61 = *__error();
      uint64_t v62 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v62, OS_LOG_TYPE_ERROR)) {
        sub_100080B84();
      }
      *__error() = v61;
    }

    if (byte_1000E7D31 && dword_1000E74E0 <= 3)
    {
      int v63 = *__error();
      uint64_t v64 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"WR: %@: Workflow event has invalid duration %.3f",  v511,  *(void *)&v36);
      uint64_t v65 = v64;
      if (v64)
      {
        uint64_t v66 = (char *)CFStringGetCStringPtr(v64, 0x8000100u);
        if (v66)
        {
          uint64_t v67 = 0LL;
        }

        else
        {
          uint64_t v66 = (char *)calloc(0x400uLL, 1uLL);
          CFStringGetCString(v65, v66, 1024LL, 0x8000100u);
          uint64_t v67 = v66;
        }

        if (qword_1000E7D38) {
          int v88 = (FILE *)qword_1000E7D38;
        }
        else {
          int v88 = __stderrp;
        }
        fprintf(v88, "%s\n", v66);
        if (v67) {
          free(v67);
        }
        CFRelease(v65);
      }

      else
      {
        BOOL v85 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v85, OS_LOG_TYPE_FAULT)) {
          sub_100080B20();
        }
        if (qword_1000E7D38) {
          int v86 = (FILE *)qword_1000E7D38;
        }
        else {
          int v86 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v86);
      }

      *__error() = v63;
    }

LABEL_187:
    unsigned int v69 = *(void **)(v515 + 40);
LABEL_188:
    free(v69);
    return;
  }

  id v37 = -[WRWorkflowEventTracker error](v541, "error");
  uint64_t v38 = v37;
  if (v37)
  {
    id v39 = [v37 domain];
    if ([v39 isEqualToString:WRErrorDomain] && objc_msgSend(v38, "code") == (id)4)
    {
      if (byte_1000E7D30)
      {
        int v40 = *__error();
        int v41 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v41, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 138412546;
          id v621 = v511;
          __int16 v622 = 2112;
          id v623 = v38;
          _os_log_impl( (void *)&_mh_execute_header,  v41,  OS_LOG_TYPE_DEFAULT,  "WR: %@: Workflow event has error %@, still considering for diagnostics",  buf,  0x16u);
        }

        *__error() = v40;
      }

      if (byte_1000E7D31 && dword_1000E74E0 <= 2)
      {
        int v42 = *__error();
        uint64_t v43 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"WR: %@: Workflow event has error %@, still considering for diagnostics",  v511,  v38);
        uint64_t v44 = v43;
        if (v43)
        {
          uint64_t v45 = (char *)CFStringGetCStringPtr(v43, 0x8000100u);
          if (v45)
          {
            uint64_t v46 = 0LL;
          }

          else
          {
            uint64_t v45 = (char *)calloc(0x400uLL, 1uLL);
            CFStringGetCString(v44, v45, 1024LL, 0x8000100u);
            uint64_t v46 = v45;
          }

          if (qword_1000E7D38) {
            v94 = (FILE *)qword_1000E7D38;
          }
          else {
            v94 = __stderrp;
          }
          fprintf(v94, "%s\n", v45);
          if (v46) {
            free(v46);
          }
          CFRelease(v44);
        }

        else
        {
          int v92 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v92, OS_LOG_TYPE_FAULT)) {
            sub_100080A50();
          }
          if (qword_1000E7D38) {
            v93 = (FILE *)qword_1000E7D38;
          }
          else {
            v93 = __stderrp;
          }
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v93);
        }

        *__error() = v42;
      }

      goto LABEL_203;
    }

    if (byte_1000E7D30)
    {
      int v72 = *__error();
      int v73 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v73, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 138412546;
        id v621 = v511;
        __int16 v622 = 2112;
        id v623 = v38;
        _os_log_impl( (void *)&_mh_execute_header,  v73,  OS_LOG_TYPE_DEFAULT,  "WR: %@: Workflow event has error %@, not considering for diagnostics",  buf,  0x16u);
      }

      *__error() = v72;
    }

    if (byte_1000E7D31 && dword_1000E74E0 <= 2)
    {
      int v74 = *__error();
      unsigned int v75 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"WR: %@: Workflow event has error %@, not considering for diagnostics",  v511,  v38);
      id v76 = v75;
      if (v75)
      {
        char v77 = (char *)CFStringGetCStringPtr(v75, 0x8000100u);
        if (v77)
        {
          uint64_t v78 = 0LL;
        }

        else
        {
          char v77 = (char *)calloc(0x400uLL, 1uLL);
          CFStringGetCString(v76, v77, 1024LL, 0x8000100u);
          uint64_t v78 = v77;
        }

        if (qword_1000E7D38) {
          int v91 = (FILE *)qword_1000E7D38;
        }
        else {
          int v91 = __stderrp;
        }
        fprintf(v91, "%s\n", v77);
        if (v78) {
          free(v78);
        }
        CFRelease(v76);
      }

      else
      {
        __int16 v89 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v89, OS_LOG_TYPE_FAULT)) {
          sub_100080AB8();
        }
        if (qword_1000E7D38) {
          uint64_t v90 = (FILE *)qword_1000E7D38;
        }
        else {
          uint64_t v90 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v90);
      }

      *__error() = v74;
    }

    goto LABEL_187;
  }

                      if (qword_1000E7D38) {
                        id v122 = (FILE *)qword_1000E7D38;
                      }
                      else {
                        id v122 = __stderrp;
                      }
                      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v122);
LABEL_191:
                      *__error() = v205;
                    }
                  }

                  else
                  {
                    if (byte_1000E7D30)
                    {
                      unsigned int v204 = *__error();
                      int v92 = (os_log_s *)sub_10002EFA0();
                      if (os_log_type_enabled(v92, OS_LOG_TYPE_ERROR))
                      {
                        id v181 = sub_10002EF3C(v9[i]);
                        cfi = v9[i];
                        uint64_t v171 = *__error();
                        xpc_object_t v128 = __error();
                        int v129 = strerror(*v128);
                        *(_DWORD *)id v221 = 136446978;
                        *(void *)id v222 = v181;
                        *(_WORD *)&v222[8] = 1024;
                        *(_DWORD *)&v222[10] = cfi;
                        id v223 = 1024;
                        id v224 = v171;
                        id v225 = 2080;
                        id v226 = v129;
                        _os_log_error_impl( (void *)&_mh_execute_header,  v92,  OS_LOG_TYPE_ERROR,  "%{public}s [%d]: Unable to spawn ddt: %d (%s)",  v221,  0x22u);
                      }

                      *__error() = v204;
                    }

                    if (byte_1000E7D31 && dword_1000E74E0 <= 3)
                    {
                      uint64_t v205 = *__error();
                      v93 = sub_10002EF3C(v9[i]);
                      uint64_t v177 = (void *)v9[i];
                      cfj = v93;
                      v94 = *__error();
                      unsigned int v95 = __error();
                      id v96 = strerror(*v95);
                      id v97 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"%s [%d]: Unable to spawn ddt: %d (%s)",  cfj,  v177,  v94,  v96);
                      if (!v97)
                      {
                        char v98 = (os_log_s *)sub_10002EFA0();
                        if (os_log_type_enabled(v98, OS_LOG_TYPE_FAULT))
                        {
                          id v178 = sub_10002EF3C(v9[i]);
                          cfk = v9[i];
                          uint64_t v169 = *__error();
                          double v99 = __error();
                          double v100 = strerror(*v99);
                          *(_DWORD *)id v221 = 136315906;
                          *(void *)id v222 = v178;
                          *(_WORD *)&v222[8] = 1024;
                          *(_DWORD *)&v222[10] = cfk;
                          id v223 = 1024;
                          id v224 = v169;
                          id v225 = 2080;
                          id v226 = v100;
                          id v101 = v98;
                          double v102 = "Unable to format: %s [%d]: Unable to spawn ddt: %d (%s)";
                          double v103 = 34;
                          goto LABEL_196;
                        }

                        goto LABEL_187;
                      }

LABEL_203:
  v578[0] = 0LL;
  v578[1] = v578;
  v578[2] = 0x2020000000LL;
  char v579 = 0;
  uint64_t v572 = 0LL;
  v573 = &v572;
  uint64_t v574 = 0x3052000000LL;
  v575 = sub_100037440;
  v576 = sub_100037450;
  uint64_t v577 = 0LL;
  uint64_t v566 = 0LL;
  v567 = &v566;
  uint64_t v568 = 0x3052000000LL;
  v569 = sub_100037440;
  v570 = sub_100037450;
  uint64_t v571 = 0LL;
  v559[0] = _NSConcreteStackBlock;
  v559[1] = 3221225472LL;
  v560 = sub_10003745C;
  v561 = &unk_1000D8D60;
  unsigned int v95 = *v510;
  v564 = &v572;
  v565 = v95;
  v563 = v578;
  id v562 = v511;
  v554[0] = _NSConcreteStackBlock;
  v554[1] = 3221225472LL;
  v555 = sub_100037A88;
  v556 = &unk_1000D8D88;
  v557 = &v566;
  v558 = &v572;
  uint64_t v580 = 0LL;
  id v503 = -[WRWorkflowEventTracker encodedStringWithError:](v541, "encodedStringWithError:", &v580);
  if (!v503)
  {
    int v416 = *__error();
    v417 = (os_log_s *)sub_10002EFA0();
    if (os_log_type_enabled(v417, OS_LOG_TYPE_FAULT)) {
      sub_1000809F0();
    }
    *__error() = v416;
    if (byte_1000E7D31 && dword_1000E74E0 <= 4)
    {
      int v418 = *__error();
      v419 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"Unable to encode workflow event tracked into a string: %@",  v580);
      v420 = v419;
      if (v419)
      {
        v421 = (char *)CFStringGetCStringPtr(v419, 0x8000100u);
        if (v421)
        {
          v422 = 0LL;
        }

        else
        {
          v421 = (char *)calloc(0x400uLL, 1uLL);
          CFStringGetCString(v420, v421, 1024LL, 0x8000100u);
          v422 = v421;
        }

        if (qword_1000E7D38) {
          v473 = (FILE *)qword_1000E7D38;
        }
        else {
          v473 = __stderrp;
        }
        fprintf(v473, "%s\n", v421);
        if (v422) {
          free(v422);
        }
        CFRelease(v420);
      }

      else
      {
        v471 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v471, OS_LOG_TYPE_FAULT)) {
          sub_100080990();
        }
        if (qword_1000E7D38) {
          v472 = (FILE *)qword_1000E7D38;
        }
        else {
          v472 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v472);
      }

      *__error() = v418;
    }
  }

  v540 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
  v496 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
  v498 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
  -[WRWorkflowEventTracker stats](v541, "stats");
  __int128 v598 = 0u;
  __int128 v599 = 0u;
  __int128 v600 = 0u;
  __int128 v601 = 0u;
  id v96 = objc_msgSend(-[WRWorkflowEventTracker workflow](v541, "workflow"), "workflowDiagnostics");
  id v97 = [v96 countByEnumeratingWithState:&v598 objects:buf count:16];
  if (!v97) {
    goto LABEL_293;
  }
  id obj = v96;
  uint64_t v500 = v35;
  char v98 = 0;
  CFAllocatorRef v508 = *(CFAllocatorRef *)v599;
  uint64_t v504 = WRErrorDomain;
  double v99 = (double)v552;
  while (2)
  {
    for (i = 0LL; i != v97; i = (char *)i + 1)
    {
      if (*(CFAllocatorRef *)v599 != v508) {
        objc_enumerationMutation(obj);
      }
      v537 = *(void **)(*((void *)&v598 + 1) + 8LL * (void)i);
      v534 = -[SPWRReportReason initWithWorkflowTracker:signpostTracker:diagnostic:]( objc_alloc(&OBJC_CLASS___SPWRReportReason),  "initWithWorkflowTracker:signpostTracker:diagnostic:",  v541,  0LL,  v537);
      double v100 = v99;
      if (([v537 reportOmittingNetworkBoundIntervals] & 1) == 0)
      {
        id v101 = objc_msgSend(-[WRWorkflowEventTracker eventEnd](v541, "eventEnd"), "machContTimeNs");
        double v100 = (double)(unint64_t)v101
             - (double)(unint64_t)objc_msgSend( -[WRWorkflowEventTracker eventStart](v541, "eventStart"),  "machContTimeNs");
      }

      [v537 triggerThresholdDurationSingle];
      double v102 = v100 / 1000000000.0;
      if (v103 <= v102)
      {
        if ([v537 reportOmittingNetworkBoundIntervals]) {
          -[SPWRReportReason setWorkflowDurationOmittingNetworkBoundIntervals:]( v534,  "setWorkflowDurationOmittingNetworkBoundIntervals:",  v102);
        }
        else {
          -[SPWRReportReason setWorkflowDuration:](v534, "setWorkflowDuration:", v102);
        }
        int v104 = 1;
      }

      else
      {
LABEL_213:
        int v104 = 0;
      }

      if ([v537 triggerEventTimeout]
        && (id v105 = -[WRWorkflowEventTracker error](v541, "error"),
            objc_msgSend(objc_msgSend(v105, "domain"), "isEqualToString:", v504))
        && [v105 code] == (id)4)
      {
        -[SPWRReportReason setWorkflowEventTimedOut:](v534, "setWorkflowEventTimedOut:", 1LL);
      }

      else if (!v104)
      {
        goto LABEL_287;
      }

      if ([v537 hasAnySpindumpReports])
      {
        v531 = (void *)v560(v559);
        if (!v531)
        {

          uint64_t v35 = v500;
LABEL_292:
          -[NSMutableArray addObject:](v496, "addObject:", @"overall");
          goto LABEL_293;
        }

        uint64_t v113 = (void *)v555((uint64_t)v554, v106, v107, v108, v109, v110, v111, v112);
        id v114 = [v537 reportProcessesWithName];
        if (v114)
        {
          v528 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
          *(void *)&__int128 v581 = _NSConcreteStackBlock;
          *((void *)&v581 + 1) = 3221225472LL;
          *(void *)&__int128 v582 = sub_1000382D8;
          *((void *)&v582 + 1) = &unk_1000D8E20;
          *(void *)&__int128 v583 = v114;
          *((void *)&v583 + 1) = v528;
          [v531 enumerateTasks:&v581];
        }

        else
        {
          v528 = 0LL;
        }

        id v115 = [v537 reportOtherSignpostWithName];
        if (v115)
        {
          id v116 = objc_msgSend(-[WRWorkflowEventTracker allSignpostTrackers](v541, "allSignpostTrackers"), "mutableCopy");
          if ([v116 count])
          {
            unint64_t v117 = 0LL;
            do
            {
              if ((objc_msgSend( objc_msgSend( objc_msgSend(objc_msgSend(v116, "objectAtIndexedSubscript:", v117), "signpost"),  "name"),  "isEqualToString:",  v115) & 1) == 0) {
                [v116 removeObjectAtIndex:v117--];
              }
              ++v117;
            }

            while (v117 < (unint64_t)[v116 count]);
          }

          __int128 v596 = 0u;
          __int128 v595 = 0u;
          __int128 v594 = 0u;
          __int128 v593 = 0u;
          id v118 = [v116 countByEnumeratingWithState:&v593 objects:v615 count:16];
          if (v118)
          {
            id v518 = v97;
            CFAllocatorRef v520 = *(CFAllocatorRef *)v594;
            id v516 = v116;
            do
            {
              id v522 = v118;
              for (j = 0LL; j != v522; j = (char *)j + 1)
              {
                if (*(CFAllocatorRef *)v594 != v520) {
                  objc_enumerationMutation(v116);
                }
                uint64_t v119 = *(void **)(*((void *)&v593 + 1) + 8LL * (void)j);
                id v120 = [v119 intervals];
                id v121 = [v119 incompleteIntervalStarts];
                id v122 = [v120 count];
                if ((char *)[v121 count] + (void)v122)
                {
                  __int128 v592 = 0u;
                  __int128 v591 = 0u;
                  __int128 v590 = 0u;
                  *(_OWORD *)v589 = 0u;
                  id v131 = [v119 intervals];
                  id v132 = [v131 countByEnumeratingWithState:v589 objects:v606 count:16];
                  if (v132)
                  {
                    uint64_t v133 = *(void *)v590;
                    do
                    {
                      for (k = 0LL; k != v132; k = (char *)k + 1)
                      {
                        if (*(void *)v590 != v133) {
                          objc_enumerationMutation(v131);
                        }
                        sub_100038320( v540,  (uint64_t)v534,  v531,  v541,  0,  v537,  (uint64_t)v119,  v528,  v113,  (uint64_t)objc_msgSend( objc_msgSend(*(id *)(*(void *)&v589[8] + 8 * (void)k), "start"),  "threadID"),  (uint64_t)objc_msgSend( objc_msgSend(*(id *)(*(void *)&v589[8] + 8 * (void)k), "end"),  "threadID"),  (unint64_t)objc_msgSend( objc_msgSend(*(id *)(*(void *)&v589[8] + 8 * (void)k), "start"),  "machContTimeNs"),  (unint64_t)objc_msgSend( objc_msgSend(*(id *)(*(void *)&v589[8] + 8 * (void)k), "end"),  "machContTimeNs"));
                      }

                      id v132 = [v131 countByEnumeratingWithState:v589 objects:v606 count:16];
                    }

                    while (v132);
                  }

                  __int128 v587 = 0u;
                  __int128 v588 = 0u;
                  *(_OWORD *)v585 = 0u;
                  __int128 v586 = 0u;
                  id v97 = v518;
                  id v116 = v516;
                  id v135 = [v119 incompleteIntervalStarts];
                  id v136 = [v135 countByEnumeratingWithState:v585 objects:v605 count:16];
                  if (v136)
                  {
                    uint64_t v137 = *(void *)v586;
                    do
                    {
                      for (m = 0LL; m != v136; m = (char *)m + 1)
                      {
                        if (*(void *)v586 != v137) {
                          objc_enumerationMutation(v135);
                        }
                        sub_100038320( v540,  (uint64_t)v534,  v531,  v541,  0,  v537,  (uint64_t)v119,  v528,  v113,  (uint64_t)[*(id *)(*(void *)&v585[8] + 8 * (void)m) threadID],  0,  (unint64_t)objc_msgSend( *(id *)(*(void *)&v585[8] + 8 * (void)m),  "machContTimeNs"),  (unint64_t)objc_msgSend( -[WRWorkflowEventTracker eventEnd](v541, "eventEnd"),  "machContTimeNs"));
                      }

                      id v136 = [v135 countByEnumeratingWithState:v585 objects:v605 count:16];
                    }

                    while (v136);
                  }
                }

                else
                {
                  if (byte_1000E7D30)
                  {
                    int v123 = *__error();
                    int v124 = (os_log_s *)sub_10002EFA0();
                    if (os_log_type_enabled(v124, OS_LOG_TYPE_ERROR))
                    {
                      id v142 = objc_msgSend(-[WRWorkflowEventTracker workflow](v541, "workflow"), "name");
                      id v143 = objc_msgSend(objc_msgSend(v119, "signpost"), "name");
                      id v144 = [v537 name];
                      *(_DWORD *)v616 = 138412802;
                      *(void *)&v616[4] = v142;
                      *(_WORD *)&v616[12] = 2112;
                      *(void *)&v616[14] = v143;
                      *(_WORD *)&v616[22] = 2112;
                      v617 = v144;
                      _os_log_error_impl( (void *)&_mh_execute_header,  v124,  OS_LOG_TYPE_ERROR,  "WR: %@: %@: diagnostic %@: Reporting spindump for this signpost due to overall workflow, but no intervals to report",  v616,  0x20u);
                    }

                    *__error() = v123;
                  }

                  if (byte_1000E7D31) {
                    BOOL v125 = dword_1000E74E0 <= 3;
                  }
                  else {
                    BOOL v125 = 0;
                  }
                  if (v125)
                  {
                    int v126 = *__error();
                    dispatch_semaphore_t v127 = CFStringCreateWithFormat( kCFAllocatorDefault,  0,  @"WR: %@: %@: diagnostic %@: Reporting spindump for this signpost due to overall workflow, but no intervals to report",  objc_msgSend(-[WRWorkflowEventTracker workflow](v541, "workflow"), "name"),  objc_msgSend(objc_msgSend(v119, "signpost"), "name"),  objc_msgSend(v537, "name"));
                    xpc_object_t v128 = v127;
                    if (v127)
                    {
                      int v129 = (char *)CFStringGetCStringPtr(v127, 0x8000100u);
                      if (v129)
                      {
                        v130 = 0LL;
                      }

                      else
                      {
                        int v129 = (char *)calloc(0x400uLL, 1uLL);
                        CFStringGetCString(v128, v129, 1024LL, 0x8000100u);
                        v130 = v129;
                      }

                      if (qword_1000E7D38) {
                        int v141 = (FILE *)qword_1000E7D38;
                      }
                      else {
                        int v141 = __stderrp;
                      }
                      fprintf(v141, "%s\n", v129);
                      if (v130) {
                        free(v130);
                      }
                      CFRelease(v128);
                    }

                    else
                    {
                      BOOL v139 = (os_log_s *)sub_10002EFA0();
                      if (os_log_type_enabled(v139, OS_LOG_TYPE_FAULT))
                      {
                        id v145 = objc_msgSend(-[WRWorkflowEventTracker workflow](v541, "workflow"), "name");
                        id v146 = objc_msgSend(objc_msgSend(v119, "signpost"), "name");
                        id v147 = [v537 name];
                        *(_DWORD *)v616 = 138412802;
                        *(void *)&v616[4] = v145;
                        *(_WORD *)&v616[12] = 2112;
                        *(void *)&v616[14] = v146;
                        *(_WORD *)&v616[22] = 2112;
                        v617 = v147;
                        _os_log_fault_impl( (void *)&_mh_execute_header,  v139,  OS_LOG_TYPE_FAULT,  "Unable to format: WR: %@: %@: diagnostic %@: Reporting spindump for this signpost due to overa ll workflow, but no intervals to report",  v616,  0x20u);
                      }

                      if (qword_1000E7D38) {
                        int v140 = (FILE *)qword_1000E7D38;
                      }
                      else {
                        int v140 = __stderrp;
                      }
                      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v140);
                    }

                    *__error() = v126;
                  }
                }
              }

              id v118 = [v116 countByEnumeratingWithState:&v593 objects:v615 count:16];
            }

            while (v118);
          }
        }

        else
        {
          sub_100038320( v540,  (uint64_t)v534,  v531,  v541,  0,  v537,  0,  v528,  v113,  (uint64_t)objc_msgSend(-[WRWorkflowEventTracker eventStart](v541, "eventStart"), "threadID"),  (uint64_t)objc_msgSend(-[WRWorkflowEventTracker eventEnd](v541, "eventEnd"), "threadID"),  (unint64_t)objc_msgSend(-[WRWorkflowEventTracker eventStart](v541, "eventStart"), "machContTimeNs"),  (unint64_t)objc_msgSend(-[WRWorkflowEventTracker eventEnd](v541, "eventEnd"), "machContTimeNs"));
        }
      }

      char v98 = 1;
LABEL_287:
    }

    id v97 = [obj countByEnumeratingWithState:&v598 objects:buf count:16];
    if (v97) {
      continue;
    }
    break;
  }

  uint64_t v35 = v500;
  if ((v98 & 1) != 0) {
    goto LABEL_292;
  }
LABEL_293:
  double v148 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
  if (v552 != v35) {
    -[NSMutableDictionary setObject:forKeyedSubscript:]( v148,  "setObject:forKeyedSubscript:",  +[NSNumber numberWithDouble:](&OBJC_CLASS___NSNumber, "numberWithDouble:", (double)v552 / 1000000000.0),  @"nonNetworkS");
  }
  if (v553) {
    -[NSMutableDictionary setObject:forKeyedSubscript:]( v148,  "setObject:forKeyedSubscript:",  +[NSNumber numberWithUnsignedLongLong:](&OBJC_CLASS___NSNumber, "numberWithUnsignedLongLong:"),  @"numIncomplete");
  }
  if (v551) {
    -[NSMutableDictionary setObject:forKeyedSubscript:]( v148,  "setObject:forKeyedSubscript:",  +[NSNumber numberWithDouble:](&OBJC_CLASS___NSNumber, "numberWithDouble:", (double)v551 / 1000000000.0),  @"untrackedS");
  }
  if (-[NSMutableDictionary count](v148, "count")) {
    -[NSMutableDictionary setObject:forKeyedSubscript:](v498, "setObject:forKeyedSubscript:", v148, @"overall");
  }

  __int128 v549 = 0u;
  __int128 v550 = 0u;
  __int128 v547 = 0u;
  __int128 v548 = 0u;
  id v149 = -[WRWorkflowEventTracker allSignpostTrackers](v541, "allSignpostTrackers");
  id v150 = [v149 countByEnumeratingWithState:&v547 objects:v604 count:16];
  if (v150)
  {
    uint64_t v497 = *(void *)v548;
    id v493 = v149;
    do
    {
      v505 = 0LL;
      id v494 = v150;
      do
      {
        if (*(void *)v548 != v497) {
          objc_enumerationMutation(v149);
        }
        v535 = *(void **)(*((void *)&v547 + 1) + 8LL * (void)v505);
        id v151 = objc_msgSend(-[WRWorkflowEventTracker eventEnd](v541, "eventEnd"), "machContTimeNs");
        if (!v535) {
          goto LABEL_455;
        }
        [v535 statsWithEventEndNs:v151];
        unint64_t v501 = v598;
        if (!(void)v598) {
          goto LABEL_455;
        }
        __int128 v152 = v599;
        __int128 v593 = 0u;
        __int128 v594 = 0u;
        __int128 v595 = 0u;
        __int128 v596 = 0u;
        id v153 = objc_msgSend(objc_msgSend(v535, "signpost"), "diagnostics");
        id v154 = [v153 countByEnumeratingWithState:&v593 objects:buf count:16];
        if (!v154) {
          goto LABEL_439;
        }
        id v499 = v154;
        id v495 = v153;
        char v155 = 0;
        uint64_t v502 = *(void *)v594;
        double v156 = (double)*((unint64_t *)&v152 + 1) / 1000000000.0;
        do
        {
          id obja = 0LL;
          do
          {
            if (*(void *)v594 != v502) {
              objc_enumerationMutation(v495);
            }
            v538 = *(void **)(*((void *)&v593 + 1) + 8LL * (void)obja);
            v532 = -[SPWRReportReason initWithWorkflowTracker:signpostTracker:diagnostic:]( objc_alloc(&OBJC_CLASS___SPWRReportReason),  "initWithWorkflowTracker:signpostTracker:diagnostic:",  v541,  v535,  v538);
            if ([v538 hasTriggerThresholdCount]
              && v501 >= [v538 triggerThresholdCount])
            {
              if ([v538 reportOtherSignpostWithName] || (void)v152)
              {
                -[SPWRReportReason setSignpostCount:](v532, "setSignpostCount:", v501);
                int v157 = 1;
              }

              else
              {
                if (byte_1000E7D30)
                {
                  int v164 = *__error();
                  BOOL v165 = (os_log_s *)sub_10002EFA0();
                  if (os_log_type_enabled(v165, OS_LOG_TYPE_ERROR))
                  {
                    id v221 = objc_msgSend(-[WRWorkflowEventTracker workflow](v541, "workflow"), "name");
                    id v222 = objc_msgSend(objc_msgSend(v535, "signpost"), "name");
                    id v223 = [v538 name];
                    *(_DWORD *)v607 = 138412802;
                    id v608 = v221;
                    __int16 v609 = 2112;
                    id v610 = v222;
                    __int16 v611 = 2112;
                    id v612 = v223;
                    _os_log_error_impl( (void *)&_mh_execute_header,  v165,  OS_LOG_TYPE_ERROR,  "WR: %@: %@: diagnostic %@: Reporting spindump for this signpost due to count threshold, but no int ervals to report",  v607,  0x20u);
                  }

                  *__error() = v164;
                }

                int v157 = 0;
                if (byte_1000E7D31 && dword_1000E74E0 <= 3)
                {
                  int v166 = *__error();
                  uint64_t v167 = CFStringCreateWithFormat( kCFAllocatorDefault,  0,  @"WR: %@: %@: diagnostic %@: Reporting spindump for this signpost due to count threshold, but no intervals to report",  objc_msgSend(-[WRWorkflowEventTracker workflow](v541, "workflow"), "name"),  objc_msgSend(objc_msgSend(v535, "signpost"), "name"),  objc_msgSend(v538, "name"));
                  uint64_t v168 = v167;
                  if (v167)
                  {
                    uint64_t v169 = (char *)CFStringGetCStringPtr(v167, 0x8000100u);
                    if (v169)
                    {
                      BOOL v170 = 0LL;
                    }

                    else
                    {
                      uint64_t v169 = (char *)calloc(0x400uLL, 1uLL);
                      CFStringGetCString(v168, v169, 1024LL, 0x8000100u);
                      BOOL v170 = v169;
                    }

                    if (qword_1000E7D38) {
                      uint64_t v220 = (FILE *)qword_1000E7D38;
                    }
                    else {
                      uint64_t v220 = __stderrp;
                    }
                    fprintf(v220, "%s\n", v169);
                    if (v170) {
                      free(v170);
                    }
                    CFRelease(v168);
                  }

                  else
                  {
                    v218 = (os_log_s *)sub_10002EFA0();
                    if (os_log_type_enabled(v218, OS_LOG_TYPE_FAULT))
                    {
                      id v224 = objc_msgSend(-[WRWorkflowEventTracker workflow](v541, "workflow"), "name");
                      id v225 = objc_msgSend(objc_msgSend(v535, "signpost"), "name");
                      id v226 = [v538 name];
                      *(_DWORD *)v607 = 138412802;
                      id v608 = v224;
                      __int16 v609 = 2112;
                      id v610 = v225;
                      __int16 v611 = 2112;
                      id v612 = v226;
                      _os_log_fault_impl( (void *)&_mh_execute_header,  v218,  OS_LOG_TYPE_FAULT,  "Unable to format: WR: %@: %@: diagnostic %@: Reporting spindump for this signpost due to count t hreshold, but no intervals to report",  v607,  0x20u);
                    }

                    if (qword_1000E7D38) {
                      v219 = (FILE *)qword_1000E7D38;
                    }
                    else {
                      v219 = __stderrp;
                    }
                    fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v219);
                  }

                  int v157 = 0;
                  *__error() = v166;
                }
              }
            }

            else
            {
              int v157 = 0;
            }

            double v158 = 0.0;
            if ([v538 hasTriggerThresholdDurationSingle])
            {
              [v538 triggerThresholdDurationSingle];
              if (v159 <= v156)
              {
                -[SPWRReportReason setSignpostDurationSingle:](v532, "setSignpostDurationSingle:", v156);
                [v538 triggerThresholdDurationSingle];
                double v158 = v160;
              }
            }

            if ([v538 hasTriggerThresholdDurationSum])
            {
              [v538 triggerThresholdDurationSum];
              if (v161 <= v156)
              {
                -[SPWRReportReason setSignpostDurationSum:](v532, "setSignpostDurationSum:", v156);
                int v157 = 1;
              }
            }

            if ([v538 hasTriggerThresholdDurationUnion]
              && ([v538 triggerThresholdDurationUnion], v162 <= v156))
            {
              -[SPWRReportReason setSignpostDurationUnion:](v532, "setSignpostDurationUnion:", v156);
              LOBYTE(v157) = 1;
            }

            else
            {
              if (v158 > 0.0) {
                int v163 = 1;
              }
              else {
                int v163 = v157;
              }
              if (v163 != 1) {
                goto LABEL_417;
              }
            }

            if ([v538 hasAnySpindumpReports])
            {
              v529 = (void *)v560(v559);
              if (!v529)
              {

                id v149 = v493;
                goto LABEL_437;
              }

              v523 = (void *)v555((uint64_t)v554, v171, v172, v173, v174, v175, v176, v177);
              id v178 = [v538 reportOtherSignpostWithName];
              if (v178)
              {
                id v179 = objc_msgSend( -[WRWorkflowEventTracker allSignpostTrackers](v541, "allSignpostTrackers"),  "mutableCopy");
                if ([v179 count])
                {
                  unint64_t v180 = 0LL;
                  do
                  {
                    id v181 = [v179 objectAtIndexedSubscript:v180];
                    id v182 = [v181 signpost];
                    if (!objc_msgSend(objc_msgSend(v182, "name"), "isEqualToString:", v178)
                      || objc_msgSend(objc_msgSend(v535, "signpost"), "individuationFieldName")
                      && [v182 individuationFieldName]
                      && (![v535 individuationIdentifier]
                       || ![v181 individuationIdentifier]
                       || (objc_msgSend( objc_msgSend(v535, "individuationIdentifier"),  "isEqualToString:",  objc_msgSend(v181, "individuationIdentifier")) & 1) == 0))
                    {
                      [v179 removeObjectAtIndex:v180--];
                    }

                    ++v180;
                  }

                  while (v180 < (unint64_t)[v179 count]);
                }

                CFAllocatorRef alloc = (NSArray *)[v179 copy];

                LOBYTE(v157) = 1;
              }

              else
              {
                CFAllocatorRef alloc = -[NSArray initWithObjects:](objc_alloc(&OBJC_CLASS___NSArray), "initWithObjects:", v535, 0LL);
              }

              id v183 = [v538 reportProcessesWithName];
              if (v183)
              {
                v526 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
                *(void *)v616 = _NSConcreteStackBlock;
                *(void *)&v616[8] = 3221225472LL;
                *(void *)&v616[16] = sub_10003C240;
                v617 = &unk_1000D8E20;
                id v618 = v183;
                v619 = v526;
                [v529 enumerateTasks:v616];
              }

              else
              {
                v526 = 0LL;
              }

              __int128 v592 = 0u;
              __int128 v591 = 0u;
              __int128 v590 = 0u;
              *(_OWORD *)v589 = 0u;
              v184 = (const __CFAllocator *)-[NSArray countByEnumeratingWithState:objects:count:]( alloc,  "countByEnumeratingWithState:objects:count:",  v589,  v615,  16LL);
              if (v184)
              {
                uint64_t v185 = *(void *)v590;
                uint64_t v513 = *(void *)v590;
                do
                {
                  CFAllocatorRef v521 = 0LL;
                  v517 = v184;
                  do
                  {
                    if (*(void *)v590 != v185) {
                      objc_enumerationMutation(alloc);
                    }
                    id v186 = *(void **)(*(void *)&v589[8] + 8LL * (void)v521);
                    id v187 = [v186 intervals];
                    id v519 = [v186 incompleteIntervalStarts];
                    id v188 = [v187 count];
                    if ((char *)[v519 count] + (void)v188)
                    {
                      __int128 v587 = 0u;
                      __int128 v588 = 0u;
                      *(_OWORD *)v585 = 0u;
                      __int128 v586 = 0u;
                      id v197 = [v187 countByEnumeratingWithState:v585 objects:v606 count:16];
                      if (v197)
                      {
                        uint64_t v198 = *(void *)v586;
                        do
                        {
                          for (n = 0LL; n != v197; n = (char *)n + 1)
                          {
                            if (*(void *)v586 != v198) {
                              objc_enumerationMutation(v187);
                            }
                            v200 = *(void **)(*(void *)&v585[8] + 8LL * (void)n);
                            if ((v157 & 1) == 0)
                            {
                              id v201 = objc_msgSend( objc_msgSend(*(id *)(*(void *)&v585[8] + 8 * (void)n), "start"),  "machContTimeNs");
                            }

                            sub_100038320( v540,  (uint64_t)v532,  v529,  v541,  v535,  v538,  (uint64_t)v186,  v526,  v523,  (uint64_t)objc_msgSend(objc_msgSend(v200, "start"), "threadID"),  (uint64_t)objc_msgSend(objc_msgSend(v200, "end"), "threadID"),  (unint64_t)objc_msgSend(objc_msgSend(v200, "start"), "machContTimeNs"),  (unint64_t)objc_msgSend(objc_msgSend(v200, "end"), "machContTimeNs"));
                          }

                          id v197 = [v187 countByEnumeratingWithState:v585 objects:v606 count:16];
                        }

                        while (v197);
                      }

                      __int128 v583 = 0u;
                      __int128 v584 = 0u;
                      __int128 v581 = 0u;
                      __int128 v582 = 0u;
                      uint64_t v185 = v513;
                      id v202 = [v519 countByEnumeratingWithState:&v581 objects:v605 count:16];
                      if (v202)
                      {
                        uint64_t v203 = *(void *)v582;
                        do
                        {
                          for (ii = 0LL; ii != v202; ii = (char *)ii + 1)
                          {
                            if (*(void *)v582 != v203) {
                              objc_enumerationMutation(v519);
                            }
                            uint64_t v205 = *(void **)(*((void *)&v581 + 1) + 8LL * (void)ii);
                            if ((v157 & 1) == 0)
                            {
                              id v206 = [*(id *)(*((void *)&v581 + 1) + 8 * (void)ii) machContTimeNs];
                            }

                            sub_100038320( v540,  (uint64_t)v532,  v529,  v541,  v535,  v538,  (uint64_t)v186,  v526,  v523,  (uint64_t)[v205 threadID],  0,  (unint64_t)objc_msgSend(v205, "machContTimeNs"),  (unint64_t)objc_msgSend( -[WRWorkflowEventTracker eventEnd](v541, "eventEnd"),  "machContTimeNs"));
                          }

                          id v202 = [v519 countByEnumeratingWithState:&v581 objects:v605 count:16];
                        }

                        while (v202);
                      }
                    }

                    else
                    {
                      if (byte_1000E7D30)
                      {
                        int v189 = *__error();
                        uint64_t v190 = (os_log_s *)sub_10002EFA0();
                        if (os_log_type_enabled(v190, OS_LOG_TYPE_ERROR))
                        {
                          id v210 = objc_msgSend(-[WRWorkflowEventTracker workflow](v541, "workflow"), "name");
                          id v211 = objc_msgSend(objc_msgSend(v186, "signpost"), "name");
                          id v212 = [v538 name];
                          id v213 = objc_msgSend(objc_msgSend(v186, "signpost"), "name");
                          *(_DWORD *)v607 = 138413058;
                          id v608 = v210;
                          __int16 v609 = 2112;
                          id v610 = v211;
                          __int16 v611 = 2112;
                          id v612 = v212;
                          __int16 v613 = 2112;
                          id v614 = v213;
                          _os_log_error_impl( (void *)&_mh_execute_header,  v190,  OS_LOG_TYPE_ERROR,  "WR: %@: %@: diagnostic %@: Reporting spindump for this signpost due to %@, but no intervals to report",  v607,  0x2Au);
                        }

                        *__error() = v189;
                      }

                      if (byte_1000E7D31) {
                        BOOL v191 = dword_1000E74E0 <= 3;
                      }
                      else {
                        BOOL v191 = 0;
                      }
                      if (v191)
                      {
                        int v192 = *__error();
                        uint64_t v193 = CFStringCreateWithFormat( kCFAllocatorDefault,  0,  @"WR: %@: %@: diagnostic %@: Reporting spindump for this signpost due to %@, but no intervals to report",  objc_msgSend(-[WRWorkflowEventTracker workflow](v541, "workflow"), "name"),  objc_msgSend(objc_msgSend(v186, "signpost"), "name"),  objc_msgSend(v538, "name"),  objc_msgSend(objc_msgSend(v186, "signpost"), "name"));
                        unsigned int v194 = v193;
                        if (v193)
                        {
                          int v195 = (char *)CFStringGetCStringPtr(v193, 0x8000100u);
                          if (v195)
                          {
                            int v196 = 0LL;
                          }

                          else
                          {
                            int v195 = (char *)calloc(0x400uLL, 1uLL);
                            CFStringGetCString(v194, v195, 1024LL, 0x8000100u);
                            int v196 = v195;
                          }

                          if (qword_1000E7D38) {
                            uint64_t v209 = (FILE *)qword_1000E7D38;
                          }
                          else {
                            uint64_t v209 = __stderrp;
                          }
                          fprintf(v209, "%s\n", v195);
                          if (v196) {
                            free(v196);
                          }
                          CFRelease(v194);
                        }

                        else
                        {
                          uint64_t v207 = (os_log_s *)sub_10002EFA0();
                          if (os_log_type_enabled(v207, OS_LOG_TYPE_FAULT))
                          {
                            id v214 = objc_msgSend(-[WRWorkflowEventTracker workflow](v541, "workflow"), "name");
                            id v215 = objc_msgSend(objc_msgSend(v186, "signpost"), "name");
                            id v216 = [v538 name];
                            id v217 = objc_msgSend(objc_msgSend(v186, "signpost"), "name");
                            *(_DWORD *)v607 = 138413058;
                            id v608 = v214;
                            __int16 v609 = 2112;
                            id v610 = v215;
                            __int16 v611 = 2112;
                            id v612 = v216;
                            __int16 v613 = 2112;
                            id v614 = v217;
                            _os_log_fault_impl( (void *)&_mh_execute_header,  v207,  OS_LOG_TYPE_FAULT,  "Unable to format: WR: %@: %@: diagnostic %@: Reporting spindump for this signpost due to % @, but no intervals to report",  v607,  0x2Au);
                          }

                          if (qword_1000E7D38) {
                            uint64_t v208 = (FILE *)qword_1000E7D38;
                          }
                          else {
                            uint64_t v208 = __stderrp;
                          }
                          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v208);
                        }

                        *__error() = v192;
                      }
                    }

                    CFAllocatorRef v521 = (CFAllocatorRef)((char *)v521 + 1);
                  }

                  while (v521 != v517);
                  v184 = (const __CFAllocator *)-[NSArray countByEnumeratingWithState:objects:count:]( alloc,  "countByEnumeratingWithState:objects:count:",  v589,  v615,  16LL);
                }

                while (v184);
              }
            }

            char v155 = 1;
LABEL_417:

            id obja = (char *)obja + 1;
          }

          while (obja != v499);
          id v227 = [v495 countByEnumeratingWithState:&v593 objects:buf count:16];
          id v499 = v227;
        }

        while (v227);
        id v149 = v493;
        if ((v155 & 1) == 0) {
          goto LABEL_439;
        }
LABEL_437:
        if ((-[NSMutableArray containsObject:]( v496,  "containsObject:",  objc_msgSend(objc_msgSend(v535, "signpost"), "name")) & 1) == 0) {
          -[NSMutableArray addObject:](v496, "addObject:", objc_msgSend(objc_msgSend(v535, "signpost"), "name"));
        }
LABEL_439:
        id v150 = v494;
        uint64_t v228 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
        uint64_t v229 = v598;
        if ((unint64_t)v598 >= 2)
        {
          -[NSMutableDictionary setObject:forKeyedSubscript:]( v228,  "setObject:forKeyedSubscript:",  +[NSNumber numberWithUnsignedLongLong:](&OBJC_CLASS___NSNumber, "numberWithUnsignedLongLong:"),  @"num");
          uint64_t v229 = v598;
        }

        if (v229 != (void)v601) {
          -[NSMutableDictionary setObject:forKeyedSubscript:]( v228,  "setObject:forKeyedSubscript:",  +[NSNumber numberWithUnsignedLongLong:](&OBJC_CLASS___NSNumber, "numberWithUnsignedLongLong:"),  @"numIncomplete");
        }
        uint64_t v230 = *((void *)&v601 + 1);
        if (*((void *)&v601 + 1))
        {
          -[NSMutableDictionary setObject:forKeyedSubscript:]( v228,  "setObject:forKeyedSubscript:",  +[NSNumber numberWithDouble:]( &OBJC_CLASS___NSNumber,  "numberWithDouble:",  (double)*((unint64_t *)&v601 + 1) / 1000000000.0),  @"unionS");
          uint64_t v230 = *((void *)&v601 + 1);
        }

        if (v230 != v602)
        {
          -[NSMutableDictionary setObject:forKeyedSubscript:]( v228,  "setObject:forKeyedSubscript:",  +[NSNumber numberWithDouble:](&OBJC_CLASS___NSNumber, "numberWithDouble:", (double)v602 / 1000000000.0),  @"sumS");
          uint64_t v230 = *((void *)&v601 + 1);
        }

        if (v230 != v603) {
          -[NSMutableDictionary setObject:forKeyedSubscript:]( v228,  "setObject:forKeyedSubscript:",  +[NSNumber numberWithDouble:](&OBJC_CLASS___NSNumber, "numberWithDouble:", (double)v603 / 1000000000.0),  @"maxS");
        }
        id v231 = [v535 environment];
        v546[0] = _NSConcreteStackBlock;
        v546[1] = 3221225472LL;
        v546[2] = sub_100037CA4;
        v546[3] = &unk_1000D8DB0;
        v546[4] = v228;
        v546[5] = v511;
        v546[6] = v535;
        [v231 enumerateKeysAndObjectsUsingBlock:v546];
        if (-[NSMutableDictionary count](v228, "count"))
        {
          if ([v535 individuationIdentifier]) {
            int v232 = +[NSString stringWithFormat:]( NSString,  "stringWithFormat:",  @"%@-%@",  objc_msgSend(objc_msgSend(v535, "signpost"), "name"),  objc_msgSend(v535, "individuationIdentifier"));
          }
          else {
            int v232 = (NSString *)objc_msgSend(objc_msgSend(v535, "signpost"), "name");
          }
          -[NSMutableDictionary setObject:forKeyedSubscript:]( v498,  "setObject:forKeyedSubscript:",  v228,  WRSanitizeForCA(v232));
        }

LABEL_455:
        v505 = (char *)v505 + 1;
      }

      while (v505 != v150);
      id v150 = [v149 countByEnumeratingWithState:&v547 objects:v604 count:16];
    }

    while (v150);
  }

  if (!-[NSMutableArray count](v540, "count"))
  {
    if (byte_1000E7D30)
    {
      int v243 = *__error();
      uint64_t v244 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v244, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)buf = 138412290;
        id v621 = v511;
        _os_log_impl( (void *)&_mh_execute_header,  v244,  OS_LOG_TYPE_INFO,  "WR: %@: no spindump reports to generate",  buf,  0xCu);
      }

      *__error() = v243;
    }

    if (!byte_1000E7D31 || dword_1000E74E0 > 1) {
      goto LABEL_534;
    }
    int v238 = *__error();
    v245 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"WR: %@: no spindump reports to generate", v511);
    v246 = v245;
    if (!v245)
    {
      v262 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v262, OS_LOG_TYPE_FAULT)) {
        sub_1000804B8();
      }
      if (qword_1000E7D38) {
        v263 = (FILE *)qword_1000E7D38;
      }
      else {
        v263 = __stderrp;
      }
      goto LABEL_518;
    }

    v247 = (char *)CFStringGetCStringPtr(v245, 0x8000100u);
    if (v247)
    {
      v248 = 0LL;
    }

    else
    {
      v247 = (char *)calloc(0x400uLL, 1uLL);
      CFStringGetCString(v246, v247, 1024LL, 0x8000100u);
      v248 = v247;
    }

    if (qword_1000E7D38) {
      v265 = (FILE *)qword_1000E7D38;
    }
    else {
      v265 = __stderrp;
    }
    fprintf(v265, "%s\n", v247);
    if (v248) {
      free(v248);
    }
    goto LABEL_532;
  }

  int v233 = (void *)v573[5];
  if (!v233)
  {
    int v249 = *__error();
    v250 = (os_log_s *)sub_10002EFA0();
    if (os_log_type_enabled(v250, OS_LOG_TYPE_FAULT)) {
      sub_100080554((uint64_t)v615, (uint64_t)-[NSMutableArray count](v540, "count"), v250);
    }
    *__error() = v249;
    if (!byte_1000E7D31 || dword_1000E74E0 > 4) {
      goto LABEL_534;
    }
    int v238 = *__error();
    v251 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"WR: have %lu reports, but no sampleStore",  -[NSMutableArray count](v540, "count"));
    v246 = v251;
    if (!v251)
    {
      int v266 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v266, OS_LOG_TYPE_FAULT)) {
        sub_100080518((uint64_t)v606, (uint64_t)-[NSMutableArray count](v540, "count"), v266);
      }
      if (qword_1000E7D38) {
        v263 = (FILE *)qword_1000E7D38;
      }
      else {
        v263 = __stderrp;
      }
      goto LABEL_518;
    }

    int v252 = (char *)CFStringGetCStringPtr(v251, 0x8000100u);
    if (v252)
    {
      v253 = 0LL;
    }

    else
    {
      int v252 = (char *)calloc(0x400uLL, 1uLL);
      CFStringGetCString(v246, v252, 1024LL, 0x8000100u);
      v253 = v252;
    }

    if (qword_1000E7D38) {
      v268 = (FILE *)qword_1000E7D38;
    }
    else {
      v268 = __stderrp;
    }
    fprintf(v268, "%s\n", v252);
    if (v253) {
      free(v253);
    }
LABEL_532:
    CFRelease(v246);
    goto LABEL_533;
  }

  id v234 = [v233 startTime];
  if (v234 || (id v234 = [(id)v573[5] endTime]) != 0)
  {
    [v234 machContTimeSeconds];
    if (v235 != 0.0)
    {
      if (byte_1000E7D30)
      {
        int v254 = *__error();
        uint64_t v255 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v255, OS_LOG_TYPE_DEFAULT))
        {
          id v256 = -[NSMutableArray count](v540, "count");
          *(_DWORD *)buf = 138412546;
          id v621 = v511;
          __int16 v622 = 2048;
          id v623 = v256;
          _os_log_impl( (void *)&_mh_execute_header,  v255,  OS_LOG_TYPE_DEFAULT,  "WR: %@: generating %lu spindump reports",  buf,  0x16u);
        }

        *__error() = v254;
      }

      if (byte_1000E7D31 && dword_1000E74E0 <= 2)
      {
        int v257 = *__error();
        CFStringRef v258 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"WR: %@: generating %lu spindump reports",  v511,  -[NSMutableArray count](v540, "count"));
        v259 = v258;
        if (v258)
        {
          v260 = (char *)CFStringGetCStringPtr(v258, 0x8000100u);
          if (v260)
          {
            v261 = 0LL;
          }

          else
          {
            v260 = (char *)calloc(0x400uLL, 1uLL);
            CFStringGetCString(v259, v260, 1024LL, 0x8000100u);
            v261 = v260;
          }

          if (qword_1000E7D38) {
            v314 = (FILE *)qword_1000E7D38;
          }
          else {
            v314 = __stderrp;
          }
          fprintf(v314, "%s\n", v260);
          if (v261) {
            free(v261);
          }
          CFRelease(v259);
        }

        else
        {
          v307 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v307, OS_LOG_TYPE_FAULT))
          {
            -[NSMutableArray count](v540, "count");
            sub_100080948();
          }

          if (qword_1000E7D38) {
            v308 = (FILE *)qword_1000E7D38;
          }
          else {
            v308 = __stderrp;
          }
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v308);
        }

        *__error() = v257;
      }

      [(id)v573[5] setWrWorkflowName:v511];
      id v315 = -[WRWorkflowEventTracker error](v541, "error");
      [(id)v573[5] setWrError:v315];
      __int128 v544 = 0u;
      __int128 v545 = 0u;
      __int128 v542 = 0u;
      __int128 v543 = 0u;
      id v527 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v540,  "countByEnumeratingWithState:objects:count:",  &v542,  v597,  16LL);
      if (v527)
      {
        uint64_t v524 = *(void *)v543;
        do
        {
          for (jj = 0LL; jj != v527; jj = (char *)jj + 1)
          {
            if (*(void *)v543 != v524) {
              objc_enumerationMutation(v540);
            }
            v316 = *(void **)(*((void *)&v542 + 1) + 8LL * (void)jj);
            v317 = (void *)v573[5];
            id v318 = [v316 reportReason];
            id v319 = objc_msgSend(objc_msgSend(v318, "workflowTracker"), "workflow");
            id v536 = [v319 name];
            id v320 = [v318 signpostTracker];
            id v321 = [v316 reportedSignpostTracker];
            id v539 = [v316 timeRange];
            id v530 = [v316 task];
            [v317 setWrWorkflowTimeoutDuration:0.0];
            [v317 setWrWorkflowDuration:0.0];
            [v317 setWrWorkflowDurationThreshold:0.0];
            [v317 setWrWorkflowDurationOmittingNetworkBoundIntervals:0.0];
            [v317 setWrWorkflowDurationOmittingNetworkBoundIntervalsThreshold:0.0];
            [v317 setWrSignpostName:0];
            [v317 setWrSignpostSubsystem:0];
            [v317 setWrSignpostCategory:0];
            [v317 setWrTriggeringSignpostName:0];
            [v317 setWrTriggeringSignpostSubsystem:0];
            [v317 setWrTriggeringSignpostCategory:0];
            [v317 setWrSignpostDurationUnion:0.0];
            [v317 setWrSignpostDurationUnionThreshold:0.0];
            [v317 setWrSignpostDurationSum:0.0];
            [v317 setWrSignpostDurationSumThreshold:0.0];
            [v317 setWrSignpostDurationSingle:0.0];
            [v317 setWrSignpostDurationSingleThreshold:0.0];
            [v317 setWrSignpostCount:0];
            [v317 setWrSignpostCountThreshold:0];
            if (v321)
            {
              objc_msgSend(v317, "setWrSignpostName:", objc_msgSend(objc_msgSend(v321, "signpost"), "name"));
              objc_msgSend(v317, "setWrSignpostSubsystem:", objc_msgSend(objc_msgSend(v321, "signpost"), "subsystem"));
              objc_msgSend(v317, "setWrSignpostCategory:", objc_msgSend(objc_msgSend(v321, "signpost"), "category"));
              if (v320)
              {
                if (byte_1000E7D30)
                {
                  int v322 = *__error();
                  v323 = (os_log_s *)sub_10002EFA0();
                  if (os_log_type_enabled(v323, OS_LOG_TYPE_INFO))
                  {
                    id v324 = objc_msgSend(objc_msgSend(v321, "signpost"), "name");
                    id v325 = objc_msgSend(objc_msgSend(v320, "signpost"), "name");
                    id v326 = [v530 name];
                    unsigned int v327 = [v530 pid];
                    *(_DWORD *)buf = 138413314;
                    id v621 = v536;
                    __int16 v622 = 2112;
                    id v623 = v324;
                    __int16 v624 = 2112;
                    NSUInteger v625 = (NSUInteger)v325;
                    __int16 v626 = 2112;
                    id v627 = v326;
                    __int16 v628 = 1024;
                    unsigned int v629 = v327;
                    _os_log_impl( (void *)&_mh_execute_header,  v323,  OS_LOG_TYPE_INFO,  "WR: %@ generating report for %@ due to %@ for %@ [%d]",  buf,  0x30u);
                  }

                  *__error() = v322;
                }

                if (byte_1000E7D31 && dword_1000E74E0 <= 1)
                {
                  int v328 = *__error();
                  v329 = CFStringCreateWithFormat( kCFAllocatorDefault,  0,  @"WR: %@ generating report for %@ due to %@ for %@ [%d]",  v536,  objc_msgSend(objc_msgSend(v321, "signpost"), "name"),  objc_msgSend(objc_msgSend(v320, "signpost"), "name"),  objc_msgSend(v530, "name"),  objc_msgSend(v530, "pid"));
                  v330 = v329;
                  if (v329)
                  {
                    v331 = (char *)CFStringGetCStringPtr(v329, 0x8000100u);
                    if (v331)
                    {
                      v332 = 0LL;
                    }

                    else
                    {
                      v331 = (char *)calloc(0x400uLL, 1uLL);
                      CFStringGetCString(v330, v331, 1024LL, 0x8000100u);
                      v332 = v331;
                    }

                    if (qword_1000E7D38) {
                      v356 = (FILE *)qword_1000E7D38;
                    }
                    else {
                      v356 = __stderrp;
                    }
                    fprintf(v356, "%s\n", v331);
                    if (v332) {
                      free(v332);
                    }
                    CFRelease(v330);
                  }

                  else
                  {
                    v352 = (os_log_s *)sub_10002EFA0();
                    if (os_log_type_enabled(v352, OS_LOG_TYPE_FAULT))
                    {
                      id v384 = objc_msgSend(objc_msgSend(v321, "signpost"), "name");
                      id v385 = objc_msgSend(objc_msgSend(v320, "signpost"), "name");
                      id v386 = [v530 name];
                      unsigned int v387 = [v530 pid];
                      *(_DWORD *)buf = 138413314;
                      id v621 = v536;
                      __int16 v622 = 2112;
                      id v623 = v384;
                      __int16 v624 = 2112;
                      NSUInteger v625 = (NSUInteger)v385;
                      __int16 v626 = 2112;
                      id v627 = v386;
                      __int16 v628 = 1024;
                      unsigned int v629 = v387;
                      _os_log_fault_impl( (void *)&_mh_execute_header,  v352,  OS_LOG_TYPE_FAULT,  "Unable to format: WR: %@ generating report for %@ due to %@ for %@ [%d]",  buf,  0x30u);
                    }

                    if (qword_1000E7D38) {
                      __int16 v353 = (FILE *)qword_1000E7D38;
                    }
                    else {
                      __int16 v353 = __stderrp;
                    }
                    fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v353);
                  }

                  *__error() = v328;
                }

                objc_msgSend(v317, "setWrTriggeringSignpostName:", objc_msgSend(objc_msgSend(v320, "signpost"), "name"));
                objc_msgSend( v317,  "setWrTriggeringSignpostSubsystem:",  objc_msgSend(objc_msgSend(v320, "signpost"), "subsystem"));
                objc_msgSend( v317,  "setWrTriggeringSignpostCategory:",  objc_msgSend(objc_msgSend(v320, "signpost"), "category"));
              }

              else
              {
                if (byte_1000E7D30)
                {
                  int v342 = *__error();
                  int v343 = (os_log_s *)sub_10002EFA0();
                  if (os_log_type_enabled(v343, OS_LOG_TYPE_INFO))
                  {
                    id v344 = objc_msgSend(objc_msgSend(v321, "signpost"), "name");
                    id v345 = [v530 name];
                    unsigned int v346 = [v530 pid];
                    *(_DWORD *)buf = 138413058;
                    id v621 = v536;
                    __int16 v622 = 2112;
                    id v623 = v344;
                    __int16 v624 = 2112;
                    NSUInteger v625 = (NSUInteger)v345;
                    __int16 v626 = 1024;
                    LODWORD(v627) = v346;
                    _os_log_impl( (void *)&_mh_execute_header,  v343,  OS_LOG_TYPE_INFO,  "WR: %@ generating report for %@ due to overall workflow for %@ [%d]",  buf,  0x26u);
                  }

                  *__error() = v342;
                }

                if (byte_1000E7D31 && dword_1000E74E0 <= 1)
                {
                  int v347 = *__error();
                  __int128 v348 = CFStringCreateWithFormat( kCFAllocatorDefault,  0,  @"WR: %@ generating report for %@ due to overall workflow for %@ [%d]",  v536,  objc_msgSend(objc_msgSend(v321, "signpost"), "name"),  objc_msgSend(v530, "name"),  objc_msgSend(v530, "pid"));
                  __int128 v349 = v348;
                  if (v348)
                  {
                    __int128 v350 = (char *)CFStringGetCStringPtr(v348, 0x8000100u);
                    if (v350)
                    {
                      v351 = 0LL;
                    }

                    else
                    {
                      __int128 v350 = (char *)calloc(0x400uLL, 1uLL);
                      CFStringGetCString(v349, v350, 1024LL, 0x8000100u);
                      v351 = v350;
                    }

                    if (qword_1000E7D38) {
                      v362 = (FILE *)qword_1000E7D38;
                    }
                    else {
                      v362 = __stderrp;
                    }
                    fprintf(v362, "%s\n", v350);
                    if (v351) {
                      free(v351);
                    }
                    CFRelease(v349);
                  }

                  else
                  {
                    unsigned int v360 = (os_log_s *)sub_10002EFA0();
                    if (os_log_type_enabled(v360, OS_LOG_TYPE_FAULT))
                    {
                      id v390 = objc_msgSend(objc_msgSend(v321, "signpost"), "name");
                      id v391 = [v530 name];
                      unsigned int v392 = [v530 pid];
                      *(_DWORD *)buf = 138413058;
                      id v621 = v536;
                      __int16 v622 = 2112;
                      id v623 = v390;
                      __int16 v624 = 2112;
                      NSUInteger v625 = (NSUInteger)v391;
                      __int16 v626 = 1024;
                      LODWORD(v627) = v392;
                      _os_log_fault_impl( (void *)&_mh_execute_header,  v360,  OS_LOG_TYPE_FAULT,  "Unable to format: WR: %@ generating report for %@ due to overall workflow for %@ [%d]",  buf,  0x26u);
                    }

                    if (qword_1000E7D38) {
                      v361 = (FILE *)qword_1000E7D38;
                    }
                    else {
                      v361 = __stderrp;
                    }
                    fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v361);
                  }

                  *__error() = v347;
                }
              }

              if ([v318 signpostCount])
              {
                objc_msgSend(v317, "setWrSignpostCount:", objc_msgSend(v318, "signpostCount"));
                objc_msgSend( v317,  "setWrSignpostCountThreshold:",  objc_msgSend(objc_msgSend(v318, "diagnostic"), "triggerThresholdCount"));
              }

              [v318 signpostDurationUnion];
              if (v363 > 0.0)
              {
                [v318 signpostDurationUnion];
                objc_msgSend(v317, "setWrSignpostDurationUnion:");
                objc_msgSend(objc_msgSend(v318, "diagnostic"), "triggerThresholdDurationUnion");
                objc_msgSend(v317, "setWrSignpostDurationUnionThreshold:");
              }

              [v318 signpostDurationSum];
              if (v364 > 0.0)
              {
                [v318 signpostDurationSum];
                objc_msgSend(v317, "setWrSignpostDurationSum:");
                objc_msgSend(objc_msgSend(v318, "diagnostic"), "triggerThresholdDurationSum");
                objc_msgSend(v317, "setWrSignpostDurationSumThreshold:");
              }

              [v318 signpostDurationSingle];
              if (v365 > 0.0)
              {
                [v318 signpostDurationSingle];
                objc_msgSend(v317, "setWrSignpostDurationSingle:");
                objc_msgSend(objc_msgSend(v318, "diagnostic"), "triggerThresholdDurationSingle");
                objc_msgSend(v317, "setWrSignpostDurationSingleThreshold:");
              }
            }

            else
            {
              if (byte_1000E7D30)
              {
                int v333 = *__error();
                v334 = (os_log_s *)sub_10002EFA0();
                if (os_log_type_enabled(v334, OS_LOG_TYPE_INFO))
                {
                  id v335 = [v530 name];
                  unsigned int v336 = [v530 pid];
                  *(_DWORD *)buf = 138412802;
                  id v621 = v536;
                  __int16 v622 = 2112;
                  id v623 = v335;
                  __int16 v624 = 1024;
                  LODWORD(v625) = v336;
                  _os_log_impl( (void *)&_mh_execute_header,  v334,  OS_LOG_TYPE_INFO,  "WR: %@ generating overall workflow report for %@ [%d]",  buf,  0x1Cu);
                }

                *__error() = v333;
              }

              if (byte_1000E7D31 && dword_1000E74E0 <= 1)
              {
                int v337 = *__error();
                v338 = CFStringCreateWithFormat( kCFAllocatorDefault,  0,  @"WR: %@ generating overall workflow report for %@ [%d]",  v536,  [v530 name],  objc_msgSend(v530, "pid"));
                v339 = v338;
                if (v338)
                {
                  id v340 = (char *)CFStringGetCStringPtr(v338, 0x8000100u);
                  if (v340)
                  {
                    v341 = 0LL;
                  }

                  else
                  {
                    id v340 = (char *)calloc(0x400uLL, 1uLL);
                    CFStringGetCString(v339, v340, 1024LL, 0x8000100u);
                    v341 = v340;
                  }

                  if (qword_1000E7D38) {
                    __int16 v357 = (FILE *)qword_1000E7D38;
                  }
                  else {
                    __int16 v357 = __stderrp;
                  }
                  fprintf(v357, "%s\n", v340);
                  if (v341) {
                    free(v341);
                  }
                  CFRelease(v339);
                }

                else
                {
                  int v354 = (os_log_s *)sub_10002EFA0();
                  if (os_log_type_enabled(v354, OS_LOG_TYPE_FAULT))
                  {
                    id v388 = [v530 name];
                    unsigned int v389 = [v530 pid];
                    *(_DWORD *)buf = 138412802;
                    id v621 = v536;
                    __int16 v622 = 2112;
                    id v623 = v388;
                    __int16 v624 = 1024;
                    LODWORD(v625) = v389;
                    _os_log_fault_impl( (void *)&_mh_execute_header,  v354,  OS_LOG_TYPE_FAULT,  "Unable to format: WR: %@ generating overall workflow report for %@ [%d]",  buf,  0x1Cu);
                  }

                  if (qword_1000E7D38) {
                    __int16 v355 = (FILE *)qword_1000E7D38;
                  }
                  else {
                    __int16 v355 = __stderrp;
                  }
                  fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v355);
                }

                *__error() = v337;
              }

              [v318 workflowDuration];
              if (v358 > 0.0)
              {
                [v318 workflowDuration];
                objc_msgSend(v317, "setWrWorkflowDuration:");
                objc_msgSend(objc_msgSend(v318, "diagnostic"), "triggerThresholdDurationSingle");
                objc_msgSend(v317, "setWrWorkflowDurationThreshold:");
              }

              [v318 workflowDurationOmittingNetworkBoundIntervals];
              if (v359 > 0.0)
              {
                [v318 workflowDurationOmittingNetworkBoundIntervals];
                objc_msgSend(v317, "setWrWorkflowDurationOmittingNetworkBoundIntervals:");
                objc_msgSend(objc_msgSend(v318, "diagnostic"), "triggerThresholdDurationSingle");
                objc_msgSend(v317, "setWrWorkflowDurationOmittingNetworkBoundIntervalsThreshold:");
              }

              if ([v318 workflowEventTimedOut])
              {
                [v319 maximumEventDuration];
                objc_msgSend(v317, "setWrWorkflowTimeoutDuration:");
              }
            }

            if (v320) {
              v366 = +[NSString stringWithFormat:]( NSString,  "stringWithFormat:",  @"Workflow responsiveness delay with %@ (%@)",  v536,  objc_msgSend(objc_msgSend(v320, "signpost"), "name"));
            }
            else {
              v366 = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Workflow responsiveness delay with %@",  v536);
            }
            [v317 setReason:v366];
            if (objc_msgSend(v317, "indexOfFirstSampleOnOrAfterTimestamp:", objc_msgSend(v539, "startTime")) == (id)0x7FFFFFFFFFFFFFFFLL
              || objc_msgSend(v317, "indexOfLastSampleOnOrBeforeTimestamp:", objc_msgSend(v539, "endTime")) == (id)0x7FFFFFFFFFFFFFFFLL)
            {
              if (byte_1000E7D30)
              {
                int v367 = *__error();
                v368 = (os_log_s *)sub_10002EFA0();
                if (os_log_type_enabled(v368, OS_LOG_TYPE_ERROR)) {
                  sub_10008064C(v589, &v589[1], v368);
                }
                *__error() = v367;
              }

              if (byte_1000E7D31 && dword_1000E74E0 <= 3)
              {
                int v369 = *__error();
                v370 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"Sample store contains no samples for the signpost interval, not generating spindump report");
                v371 = v370;
                if (v370)
                {
                  v372 = (char *)CFStringGetCStringPtr(v370, 0x8000100u);
                  if (v372)
                  {
                    v373 = 0LL;
                  }

                  else
                  {
                    v372 = (char *)calloc(0x400uLL, 1uLL);
                    CFStringGetCString(v371, v372, 1024LL, 0x8000100u);
                    v373 = v372;
                  }

                  if (qword_1000E7D38) {
                    v383 = (FILE *)qword_1000E7D38;
                  }
                  else {
                    v383 = __stderrp;
                  }
                  fprintf(v383, "%s\n", v372);
                  if (v373) {
                    free(v373);
                  }
                  CFRelease(v371);
                }

                else
                {
                  v377 = (os_log_s *)sub_10002EFA0();
                  if (os_log_type_enabled(v377, OS_LOG_TYPE_FAULT)) {
                    sub_100080610(v585, &v585[1], v377);
                  }
                  if (qword_1000E7D38) {
                    v378 = (FILE *)qword_1000E7D38;
                  }
                  else {
                    v378 = __stderrp;
                  }
                  fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v378);
                }

                *__error() = v369;
              }
            }

            else
            {
              objc_msgSend(v317, "setTargetProcess:", objc_msgSend(v316, "task"));
              if ([v316 thread])
              {
                objc_msgSend(v317, "setTargetThreadId:", objc_msgSend(objc_msgSend(v316, "thread"), "threadId"));
                id v374 = [v317 targetDispatchQueueId];
                if (v374 != objc_msgSend(objc_msgSend(v316, "dispatchQueue"), "identifier"))
                {
                  if (([v530 pid] & 0x80000000) == 0)
                  {
                    if (byte_1000E7D30)
                    {
                      int v449 = *__error();
                      v450 = (os_log_s *)sub_10002EFA0();
                      if (os_log_type_enabled(v450, OS_LOG_TYPE_ERROR))
                      {
                        sub_10002EF3C((int)[v530 pid]);
                        [v530 pid];
                        sub_100080828();
                      }

                      *__error() = v449;
                    }

                    if (byte_1000E7D31 && dword_1000E74E0 <= 3)
                    {
                      int v404 = *__error();
                      v405 = sub_10002EF3C((int)[v530 pid]);
                      v406 = CFStringCreateWithFormat( kCFAllocatorDefault,  0,  @"%s [%d]: %s: Unable to set target thread",  v405,  [v530 pid],  "sampleStore.targetDispatchQueueId == report.dispatchQueue.identifier");
                      v407 = v406;
                      if (v406)
                      {
                        v480 = (char *)CFStringGetCStringPtr(v406, 0x8000100u);
                        if (v480)
                        {
                          v481 = 0LL;
                        }

                        else
                        {
                          v480 = (char *)calloc(0x400uLL, 1uLL);
                          CFStringGetCString(v407, v480, 1024LL, 0x8000100u);
                          v481 = v480;
                        }

                        if (qword_1000E7D38) {
                          v484 = (FILE *)qword_1000E7D38;
                        }
                        else {
                          v484 = __stderrp;
                        }
                        fprintf(v484, "%s\n", v480);
                        if (v481) {
                          free(v481);
                        }
                        CFRelease(v407);
                      }

                      else
                      {
                        v408 = (os_log_s *)sub_10002EFA0();
                        if (os_log_type_enabled(v408, OS_LOG_TYPE_FAULT))
                        {
                          sub_10002EF3C((int)[v530 pid]);
                          [v530 pid];
                          sub_1000807E8();
                        }

                        if (qword_1000E7D38) {
                          v409 = (FILE *)qword_1000E7D38;
                        }
                        else {
                          v409 = __stderrp;
                        }
                        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v409);
                      }

                      *__error() = v404;
                    }

                    char v485 = sub_10002EF3C((int)[v530 pid]);
                    [v530 pid];
                    v490 = "%s [%d]: %s: Unable to set target thread";
                    int v491 = 236;
LABEL_920:
                    sub_10002EE78( "GenerateWorkflowResponsivenessReport",  "monitor-WorkflowResponsiveness.m",  v491,  v490,  v486,  v487,  v488,  v489,  v485);
LABEL_897:
                    abort();
                  }

                  if (byte_1000E7D30)
                  {
                    int v451 = *__error();
                    v452 = (os_log_s *)sub_10002EFA0();
                    if (os_log_type_enabled(v452, OS_LOG_TYPE_ERROR)) {
                      sub_1000808D8(v452, v453, v454, v455, v456, v457, v458, v459);
                    }
                    *__error() = v451;
                  }

                  v423 = "%s: Unable to set target thread";
                  int v424 = 236;
                  if (byte_1000E7D31 && dword_1000E74E0 <= 3)
                  {
                    int v425 = *__error();
                    v426 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"%s: Unable to set target thread",  "sampleStore.targetDispatchQueueId == report.dispatchQueue.identifier");
                    v427 = v426;
                    if (v426)
                    {
                      v474 = (char *)CFStringGetCStringPtr(v426, 0x8000100u);
                      if (v474)
                      {
                        v475 = 0LL;
                      }

                      else
                      {
                        v474 = (char *)calloc(0x400uLL, 1uLL);
                        CFStringGetCString(v427, v474, 1024LL, 0x8000100u);
                        v475 = v474;
                      }

                      if (qword_1000E7D38) {
                        v478 = (FILE *)qword_1000E7D38;
                      }
                      else {
                        v478 = __stderrp;
                      }
                      fprintf(v478, "%s\n", v474);
                      if (v475) {
                        free(v475);
                      }
                      CFRelease(v427);
                    }

                    else
                    {
                      v428 = (os_log_s *)sub_10002EFA0();
                      if (os_log_type_enabled(v428, OS_LOG_TYPE_FAULT)) {
                        sub_100080868(v428, v429, v430, v431, v432, v433, v434, v435);
                      }
                      if (qword_1000E7D38) {
                        v436 = (FILE *)qword_1000E7D38;
                      }
                      else {
                        v436 = __stderrp;
                      }
                      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v436);
                    }

                    *__error() = v425;
                    v423 = "%s: Unable to set target thread";
                    int v424 = 236;
                  }

LABEL_896:
                  sub_10002EE78( "GenerateWorkflowResponsivenessReport",  "monitor-WorkflowResponsiveness.m",  v424,  v423,  v400,  v401,  v402,  v403,  (char)"sampleStore.targetDispatchQueueId == report.dispatchQueue.identifier");
                  goto LABEL_897;
                }
              }

              if ([v316 dispatchQueue])
              {
                objc_msgSend( v317,  "setTargetDispatchQueueId:",  objc_msgSend(objc_msgSend(v316, "dispatchQueue"), "identifier"));
                id v375 = [v317 targetDispatchQueueId];
                if (v375 != objc_msgSend(objc_msgSend(v316, "dispatchQueue"), "identifier"))
                {
                  if (([v530 pid] & 0x80000000) == 0)
                  {
                    if (byte_1000E7D30)
                    {
                      int v460 = *__error();
                      v461 = (os_log_s *)sub_10002EFA0();
                      if (os_log_type_enabled(v461, OS_LOG_TYPE_ERROR))
                      {
                        sub_10002EF3C((int)[v530 pid]);
                        [v530 pid];
                        sub_1000806C8();
                      }

                      *__error() = v460;
                    }

                    if (byte_1000E7D31 && dword_1000E74E0 <= 3)
                    {
                      int v410 = *__error();
                      v411 = sub_10002EF3C((int)[v530 pid]);
                      v412 = CFStringCreateWithFormat( kCFAllocatorDefault,  0,  @"%s [%d]: %s: Unable to set target dispatch queue",  v411,  [v530 pid],  "sampleStore.targetDispatchQueueId == report.dispatchQueue.identifier");
                      v413 = v412;
                      if (v412)
                      {
                        v482 = (char *)CFStringGetCStringPtr(v412, 0x8000100u);
                        if (v482)
                        {
                          v483 = 0LL;
                        }

                        else
                        {
                          v482 = (char *)calloc(0x400uLL, 1uLL);
                          CFStringGetCString(v413, v482, 1024LL, 0x8000100u);
                          v483 = v482;
                        }

                        if (qword_1000E7D38) {
                          v492 = (FILE *)qword_1000E7D38;
                        }
                        else {
                          v492 = __stderrp;
                        }
                        fprintf(v492, "%s\n", v482);
                        if (v483) {
                          free(v483);
                        }
                        CFRelease(v413);
                      }

                      else
                      {
                        v414 = (os_log_s *)sub_10002EFA0();
                        if (os_log_type_enabled(v414, OS_LOG_TYPE_FAULT))
                        {
                          sub_10002EF3C((int)[v530 pid]);
                          [v530 pid];
                          sub_100080688();
                        }

                        if (qword_1000E7D38) {
                          v415 = (FILE *)qword_1000E7D38;
                        }
                        else {
                          v415 = __stderrp;
                        }
                        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v415);
                      }

                      *__error() = v410;
                    }

                    char v485 = sub_10002EF3C((int)[v530 pid]);
                    [v530 pid];
                    v490 = "%s [%d]: %s: Unable to set target dispatch queue";
                    int v491 = 240;
                    goto LABEL_920;
                  }

                  if (byte_1000E7D30)
                  {
                    int v462 = *__error();
                    v463 = (os_log_s *)sub_10002EFA0();
                    if (os_log_type_enabled(v463, OS_LOG_TYPE_ERROR)) {
                      sub_100080778(v463, v464, v465, v466, v467, v468, v469, v470);
                    }
                    *__error() = v462;
                  }

                  v423 = "%s: Unable to set target dispatch queue";
                  int v424 = 240;
                  if (byte_1000E7D31 && dword_1000E74E0 <= 3)
                  {
                    int v437 = *__error();
                    v438 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"%s: Unable to set target dispatch queue",  "sampleStore.targetDispatchQueueId == report.dispatchQueue.identifier");
                    v439 = v438;
                    if (v438)
                    {
                      v476 = (char *)CFStringGetCStringPtr(v438, 0x8000100u);
                      if (v476)
                      {
                        v477 = 0LL;
                      }

                      else
                      {
                        v476 = (char *)calloc(0x400uLL, 1uLL);
                        CFStringGetCString(v439, v476, 1024LL, 0x8000100u);
                        v477 = v476;
                      }

                      if (qword_1000E7D38) {
                        v479 = (FILE *)qword_1000E7D38;
                      }
                      else {
                        v479 = __stderrp;
                      }
                      fprintf(v479, "%s\n", v476);
                      if (v477) {
                        free(v477);
                      }
                      CFRelease(v439);
                    }

                    else
                    {
                      v440 = (os_log_s *)sub_10002EFA0();
                      if (os_log_type_enabled(v440, OS_LOG_TYPE_FAULT)) {
                        sub_100080708(v440, v441, v442, v443, v444, v445, v446, v447);
                      }
                      if (qword_1000E7D38) {
                        v448 = (FILE *)qword_1000E7D38;
                      }
                      else {
                        v448 = __stderrp;
                      }
                      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v448);
                    }

                    *__error() = v437;
                    v423 = "%s: Unable to set target dispatch queue";
                    int v424 = 240;
                  }

                  goto LABEL_896;
                }
              }

              [v317 setEvent:@"Workflow Responsiveness Delay"];
              if (v320) {
                v376 = +[NSString stringWithFormat:]( NSString,  "stringWithFormat:",  @"%@, %@.%@.%@, %@",  v536,  objc_msgSend(objc_msgSend(v320, "signpost"), "subsystem"),  objc_msgSend(objc_msgSend(v320, "signpost"), "category"),  objc_msgSend(objc_msgSend(v320, "signpost"), "name"),  objc_msgSend(objc_msgSend(v318, "diagnostic"), "name"));
              }
              else {
                v376 = +[NSString stringWithFormat:]( NSString,  "stringWithFormat:",  @"%@, %@",  v536,  objc_msgSend(objc_msgSend(v318, "diagnostic"), "name"));
              }
              [v317 setEventNote:v376];
              [v317 setEventTimeRange:v539];
              [v317 setCustomOutput:v503];
              v379 =  -[SASamplePrinter initWithSampleStore:]( objc_alloc(&OBJC_CLASS___SASamplePrinter),  "initWithSampleStore:",  v317);
              objc_msgSend(-[SASamplePrinter options](v379, "options"), "setPrintHeavyStacks:", 1);
              objc_msgSend(-[SASamplePrinter options](v379, "options"), "setPrintSpinSignatureStack:", 1);
              objc_msgSend(-[SASamplePrinter options](v379, "options"), "setForceOneBasedTimeIndexes:", 1);
              -[SASamplePrinter setIncidentUUID:](v379, "setIncidentUUID:", v509);
              -[SASamplePrinter filterToTimestampRangeStart:end:]( v379,  "filterToTimestampRangeStart:end:",  [v539 startTime],  objc_msgSend(v539, "endTime"));
              objc_msgSend( objc_msgSend(v539, "startTime"),  "deltaSecondsTo:timeDomainPriorityList:timeDomainUsed:",  objc_msgSend(v539, "endTime"),  &off_1000E2E58,  0);
              double v381 = v380;
              objc_msgSend(objc_msgSend(v539, "startTime"), "wallTime");
              sub_10004B10C(v379, 0LL, 0LL, 14LL, 0LL, 0LL, 1LL, 0LL, v382, v381, 0LL, 0LL);
            }
          }

          id v527 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v540,  "countByEnumeratingWithState:objects:count:",  &v542,  v597,  16LL);
        }

        while (v527);
      }

      goto LABEL_534;
    }
  }

  if (byte_1000E7D30)
  {
    int v236 = *__error();
    v237 = (os_log_s *)sub_10002EFA0();
    if (os_log_type_enabled(v237, OS_LOG_TYPE_ERROR))
    {
      [v234 debugDescription];
      sub_1000805C8();
    }

    *__error() = v236;
  }

  if (!byte_1000E7D31 || dword_1000E74E0 > 3) {
    goto LABEL_534;
  }
  int v238 = *__error();
  uint64_t v239 = CFStringCreateWithFormat( kCFAllocatorDefault,  0,  @"WR: %@: Unable to compare timesamps with tailspin data (%@)",  v511,  [v234 debugDescription]);
  int v240 = v239;
  if (!v239)
  {
    int v264 = (os_log_s *)sub_10002EFA0();
    if (os_log_type_enabled(v264, OS_LOG_TYPE_FAULT))
    {
      [v234 debugDescription];
      sub_100080590();
    }

    if (qword_1000E7D38) {
      v263 = (FILE *)qword_1000E7D38;
    }
    else {
      v263 = __stderrp;
    }
LABEL_518:
    fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v263);
    goto LABEL_533;
  }

  v241 = (char *)CFStringGetCStringPtr(v239, 0x8000100u);
  if (v241)
  {
    v242 = 0LL;
  }

  else
  {
    v241 = (char *)calloc(0x400uLL, 1uLL);
    CFStringGetCString(v240, v241, 1024LL, 0x8000100u);
    v242 = v241;
  }

  if (qword_1000E7D38) {
    v267 = (FILE *)qword_1000E7D38;
  }
  else {
    v267 = __stderrp;
  }
  fprintf(v267, "%s\n", v241);
  if (v242) {
    free(v242);
  }
  CFRelease(v240);
LABEL_533:
  *__error() = v238;
LABEL_534:

  if (&_DRShouldGatherLog)
  {
    sub_100037FC4(v498);
    v269 = -[NSMutableDictionary initWithObjectsAndKeys:]( objc_alloc(&OBJC_CLASS___NSMutableDictionary),  "initWithObjectsAndKeys:",  +[NSNumber numberWithDouble:](&OBJC_CLASS___NSNumber, "numberWithDouble:", v36 * 1000.0),  @"durationms",  @"239",  @"bugtype",  v511,  @"workflow",  v496,  @"exceededThresholds",  -[NSUUID UUIDString](v509, "UUIDString"),  @"IncidentUUID",  v498,  @"stats",  0LL);
    if (-[WRWorkflowEventTracker error](v541, "error"))
    {
      id v270 = objc_msgSend(-[WRWorkflowEventTracker error](v541, "error"), "domain");
      if ([v270 isEqualToString:WRErrorDomain]) {
        -[NSMutableDictionary setObject:forKeyedSubscript:]( v269,  "setObject:forKeyedSubscript:",  +[NSNumber numberWithInteger:]( NSNumber,  "numberWithInteger:",  objc_msgSend(-[WRWorkflowEventTracker error](v541, "error"), "code")),  @"error");
      }
      else {
        -[NSMutableDictionary setObject:forKeyedSubscript:]( v269,  "setObject:forKeyedSubscript:",  &off_1000E2D38,  @"error");
      }
    }

    *(void *)&__int128 v593 = 0LL;
    if (!DRShouldGatherLog( @"com.apple.spindump",  @"WorkflowResponsiveness",  v269,  @"tailspin",  &v593))
    {
      if ((void)v593)
      {
        if (byte_1000E7D30)
        {
          int v278 = *__error();
          v279 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v279, OS_LOG_TYPE_ERROR))
          {
            [(id)v593 description];
            sub_100080480();
          }

          *__error() = v278;
        }

        if (!byte_1000E7D31 || dword_1000E74E0 > 3) {
          goto LABEL_799;
        }
        int v280 = *__error();
        v281 = CFStringCreateWithFormat( kCFAllocatorDefault,  0,  @"WR: %@: error in DRShouldGatherLog call: %@",  v511,  [(id)v593 description]);
        v282 = v281;
        if (!v281)
        {
          v305 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v305, OS_LOG_TYPE_FAULT))
          {
            [(id)v593 description];
            sub_100080448();
          }

          if (qword_1000E7D38) {
            v306 = (FILE *)qword_1000E7D38;
          }
          else {
            v306 = __stderrp;
          }
          goto LABEL_635;
        }

        v283 = (char *)CFStringGetCStringPtr(v281, 0x8000100u);
        if (v283)
        {
          v284 = 0LL;
        }

        else
        {
          v283 = (char *)calloc(0x400uLL, 1uLL);
          CFStringGetCString(v282, v283, 1024LL, 0x8000100u);
          v284 = v283;
        }

        if (qword_1000E7D38) {
          v312 = (FILE *)qword_1000E7D38;
        }
        else {
          v312 = __stderrp;
        }
        fprintf(v312, "%s\n", v283);
        if (v284) {
          free(v284);
        }
      }

      else
      {
        if (byte_1000E7D30)
        {
          int v285 = *__error();
          v286 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v286, OS_LOG_TYPE_DEBUG)) {
            sub_1000803E8();
          }
          *__error() = v285;
        }

        if (!byte_1000E7D31 || dword_1000E74E0 > 0) {
          goto LABEL_799;
        }
        int v280 = *__error();
        v287 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"WR: %@: DRShouldGatherLog return false, not submitting tailspin",  v511);
        v282 = v287;
        if (!v287)
        {
          int v313 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v313, OS_LOG_TYPE_FAULT)) {
            sub_100080388();
          }
          if (qword_1000E7D38) {
            v306 = (FILE *)qword_1000E7D38;
          }
          else {
            v306 = __stderrp;
          }
          goto LABEL_635;
        }

        unsigned __int8 v288 = (char *)CFStringGetCStringPtr(v287, 0x8000100u);
        if (v288)
        {
          v289 = 0LL;
        }

        else
        {
          unsigned __int8 v288 = (char *)calloc(0x400uLL, 1uLL);
          CFStringGetCString(v282, v288, 1024LL, 0x8000100u);
          v289 = v288;
        }

        if (qword_1000E7D38) {
          v399 = (FILE *)qword_1000E7D38;
        }
        else {
          v399 = __stderrp;
        }
        fprintf(v399, "%s\n", v288);
        if (v289) {
          free(v289);
        }
      }

LABEL_797:
      CFRelease(v282);
      goto LABEL_798;
    }

    if (byte_1000E7D30)
    {
      int v271 = *__error();
      v272 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v272, OS_LOG_TYPE_DEBUG)) {
        sub_100080328();
      }
      *__error() = v271;
    }

    if (byte_1000E7D31 && dword_1000E74E0 <= 0)
    {
      int v273 = *__error();
      v274 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"WR: %@: submitting tailspin to Diagnostic Pipeline",  v511);
      int v275 = v274;
      if (v274)
      {
        v276 = (char *)CFStringGetCStringPtr(v274, 0x8000100u);
        if (v276)
        {
          v277 = 0LL;
        }

        else
        {
          v276 = (char *)calloc(0x400uLL, 1uLL);
          CFStringGetCString(v275, v276, 1024LL, 0x8000100u);
          v277 = v276;
        }

        if (qword_1000E7D38) {
          int v292 = (FILE *)qword_1000E7D38;
        }
        else {
          int v292 = __stderrp;
        }
        fprintf(v292, "%s\n", v276);
        if (v277) {
          free(v277);
        }
        CFRelease(v275);
      }

      else
      {
        v290 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v290, OS_LOG_TYPE_FAULT)) {
          sub_1000802C8();
        }
        if (qword_1000E7D38) {
          int v291 = (FILE *)qword_1000E7D38;
        }
        else {
          int v291 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v291);
      }

      *__error() = v273;
    }

    if (DRSubmitLog( @"com.apple.spindump",  @"WorkflowResponsiveness",  v511,  v269,  @"tailspin",  +[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", *v510),  0LL,  &v593))
    {
      if (byte_1000E7D30)
      {
        int v293 = *__error();
        int v294 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v294, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 138412290;
          id v621 = v511;
          _os_log_impl( (void *)&_mh_execute_header,  v294,  OS_LOG_TYPE_DEFAULT,  "WR: %@: submitted tailspin to Diagnostic Pipeline",  buf,  0xCu);
        }

        *__error() = v293;
      }

      if (byte_1000E7D31 && dword_1000E74E0 <= 2)
      {
        int v280 = *__error();
        v295 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"WR: %@: submitted tailspin to Diagnostic Pipeline",  v511);
        v282 = v295;
        if (v295)
        {
          v296 = (char *)CFStringGetCStringPtr(v295, 0x8000100u);
          if (v296)
          {
            v297 = 0LL;
          }

          else
          {
            v296 = (char *)calloc(0x400uLL, 1uLL);
            CFStringGetCString(v282, v296, 1024LL, 0x8000100u);
            v297 = v296;
          }

          if (qword_1000E7D38) {
            v393 = (FILE *)qword_1000E7D38;
          }
          else {
            v393 = __stderrp;
          }
          fprintf(v393, "%s\n", v296);
          if (v297) {
            free(v297);
          }
          goto LABEL_797;
        }

        v309 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v309, OS_LOG_TYPE_FAULT)) {
          sub_1000801F8();
        }
        if (qword_1000E7D38) {
          v306 = (FILE *)qword_1000E7D38;
        }
        else {
          v306 = __stderrp;
        }
LABEL_635:
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v306);
LABEL_798:
        *__error() = v280;
      }
    }

    else
    {
      if (byte_1000E7D30)
      {
        int v298 = *__error();
        int v299 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v299, OS_LOG_TYPE_ERROR))
        {
          [(id)v593 description];
          sub_100080290();
        }

        *__error() = v298;
      }

      if (byte_1000E7D31 && dword_1000E74E0 <= 3)
      {
        int v300 = *__error();
        int v301 = CFStringCreateWithFormat( kCFAllocatorDefault,  0,  @"WR: %@: error trying to provide tailspin to Diagnostic Pipeline: %@",  v511,  [(id)v593 description]);
        v302 = v301;
        if (v301)
        {
          v303 = (char *)CFStringGetCStringPtr(v301, 0x8000100u);
          if (v303)
          {
            v304 = 0LL;
          }

          else
          {
            v303 = (char *)calloc(0x400uLL, 1uLL);
            CFStringGetCString(v302, v303, 1024LL, 0x8000100u);
            v304 = v303;
          }

          if (qword_1000E7D38) {
            v394 = (FILE *)qword_1000E7D38;
          }
          else {
            v394 = __stderrp;
          }
          fprintf(v394, "%s\n", v303);
          if (v304) {
            free(v304);
          }
          CFRelease(v302);
        }

        else
        {
          v310 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v310, OS_LOG_TYPE_FAULT))
          {
            [(id)v593 description];
            sub_100080258();
          }

          if (qword_1000E7D38) {
            v311 = (FILE *)qword_1000E7D38;
          }
          else {
            v311 = __stderrp;
          }
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v311);
        }

        *__error() = v300;
      }

      v395 = +[NSPropertyListSerialization dataWithPropertyList:format:options:error:]( &OBJC_CLASS___NSPropertyListSerialization,  "dataWithPropertyList:format:options:error:",  v269,  200LL,  0LL,  0LL);
      v396 = (os_log_s *)sub_10002EFA0();
      if (os_signpost_enabled(v396))
      {
        id v397 = [(id)v593 localizedDescription];
        NSUInteger v398 = -[NSData length](v395, "length");
        *(_DWORD *)buf = 138543874;
        id v621 = v511;
        __int16 v622 = 2114;
        id v623 = v397;
        __int16 v624 = 2050;
        NSUInteger v625 = v398;
        _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v396,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "DPFailure",  "Workflow:%{signpost.telemetry:string1,public}@ error:%{signpost.telemetry:string2,public}@ contextDictionarySi ze:%{signpost.telemetry:number1,public}lu enableTelemetry=YES ",  buf,  0x20u);
      }
    }

LABEL_799:
  }

  free(*v510);
  _Block_object_dispose(&v566, 8);
  _Block_object_dispose(&v572, 8);
  _Block_object_dispose(v578, 8);
}

void sub_100037228(_Unwind_Exception *a1)
{
}

void sub_100037440(uint64_t a1, uint64_t a2)
{
}

void sub_100037450(uint64_t a1)
{
}

uint64_t sub_10003745C(void *a1)
{
  unsigned int v1 = a1;
  uint64_t v2 = *(void *)(a1[5] + 8LL);
  if (!*(_BYTE *)(v2 + 24))
  {
    *(_BYTE *)(v2 + 24) = 1;
    id v3 = +[NSMutableArray array](&OBJC_CLASS___NSMutableArray, "array");
    int v60 = 0LL;
    *(void *)(*(void *)(v1[6] + 8LL) + 40LL) = -[SASampleStore initForLiveSampling]( objc_alloc(&OBJC_CLASS___SASampleStore),  "initForLiveSampling");
    unsigned __int8 v53 = [*(id *)(*(void *)(v1[6] + 8) + 40) parseKTraceFile:v1[7] warningsOut:v3 errorOut:&v60];
    __int128 v56 = 0u;
    __int128 v57 = 0u;
    __int128 v58 = 0u;
    __int128 v59 = 0u;
    id obj = v3;
    id v4 = [v3 countByEnumeratingWithState:&v56 objects:v67 count:16];
    uint64_t v5 = &byte_1000E7D30;
    __int16 v6 = &byte_1000E7D31;
    int v7 = &dword_1000E74E0;
    if (v4)
    {
      id v8 = v4;
      uint64_t v9 = *(void *)v57;
      do
      {
        for (i = 0LL; i != v8; i = (char *)i + 1)
        {
          if (*(void *)v57 != v9) {
            objc_enumerationMutation(obj);
          }
          uint64_t v11 = *(const __CFString **)(*((void *)&v56 + 1) + 8LL * (void)i);
          if (*v5)
          {
            int v12 = *__error();
            uint64_t v13 = (os_log_s *)sub_10002EFA0();
            if (os_log_type_enabled(v13, OS_LOG_TYPE_INFO))
            {
              uint64_t v14 = v1[4];
              uint64_t v15 = v1[7];
              *(_DWORD *)buf = 138412802;
              uint64_t v62 = v14;
              __int16 v63 = 2080;
              uint64_t v64 = v15;
              __int16 v65 = 2112;
              uint64_t v66 = v11;
              _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_INFO,  "WR: %@: WARNING trying to create sample store from %s: %@\n",  buf,  0x20u);
            }

            *__error() = v12;
          }

          if (*v6) {
            BOOL v16 = *v7 <= 1;
          }
          else {
            BOOL v16 = 0;
          }
          if (v16)
          {
            int v17 = *__error();
            uint64_t v18 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"WR: %@: WARNING trying to create sample store from %s: %@\n",  v1[4],  v1[7],  v11);
            if (v18)
            {
              double v19 = v18;
              int v55 = v17;
              id v20 = v8;
              uint64_t v21 = v9;
              int v22 = v1;
              double v23 = v5;
              BOOL v24 = v6;
              int v25 = v7;
              CStringPtr = CFStringGetCStringPtr(v18, 0x8000100u);
              if (CStringPtr)
              {
                int v27 = (char *)CStringPtr;
                int v28 = 0LL;
              }

              else
              {
                int v27 = (char *)calloc(0x400uLL, 1uLL);
                CFStringGetCString(v19, v27, 1024LL, 0x8000100u);
                int v28 = v27;
              }

              if (qword_1000E7D38) {
                uint64_t v31 = (FILE *)qword_1000E7D38;
              }
              else {
                uint64_t v31 = __stderrp;
              }
              fprintf(v31, "%s\n", v27);
              if (v28) {
                free(v28);
              }
              CFRelease(v19);
              int v7 = v25;
              __int16 v6 = v24;
              uint64_t v5 = v23;
              unsigned int v1 = v22;
              uint64_t v9 = v21;
              id v8 = v20;
              int v17 = v55;
            }

            else
            {
              uint64_t v29 = (os_log_s *)sub_10002EFA0();
              if (os_log_type_enabled(v29, OS_LOG_TYPE_FAULT))
              {
                uint64_t v32 = v1[4];
                uint64_t v33 = v1[7];
                *(_DWORD *)buf = 138412802;
                uint64_t v62 = v32;
                __int16 v63 = 2080;
                uint64_t v64 = v33;
                __int16 v65 = 2112;
                uint64_t v66 = v11;
                _os_log_fault_impl( (void *)&_mh_execute_header,  v29,  OS_LOG_TYPE_FAULT,  "Unable to format: WR: %@: WARNING trying to create sample store from %s: %@\n",  buf,  0x20u);
              }

              if (qword_1000E7D38) {
                uint64_t v30 = (FILE *)qword_1000E7D38;
              }
              else {
                uint64_t v30 = __stderrp;
              }
              fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v30);
            }

            *__error() = v17;
          }
        }

        id v8 = [obj countByEnumeratingWithState:&v56 objects:v67 count:16];
      }

      while (v8);
    }

    if ((v53 & 1) == 0)
    {
      if (*v5)
      {
        int v34 = *__error();
        uint64_t v35 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
        {
          uint64_t v47 = v1[4];
          uint64_t v48 = v1[7];
          int v49 = v60;
          if (!v60) {
            int v49 = @"Unknown error";
          }
          *(_DWORD *)buf = 138412802;
          uint64_t v62 = v47;
          __int16 v63 = 2080;
          uint64_t v64 = v48;
          __int16 v65 = 2112;
          uint64_t v66 = v49;
          _os_log_error_impl( (void *)&_mh_execute_header,  v35,  OS_LOG_TYPE_ERROR,  "WR: %@: Not generating any spindump reports, unable to create sample store for %s: %@\n",  buf,  0x20u);
        }

        *__error() = v34;
      }

      if (*v6 && *v7 <= 3)
      {
        int v36 = *__error();
        id v37 = v60;
        if (!v60) {
          id v37 = @"Unknown error";
        }
        uint64_t v38 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"WR: %@: Not generating any spindump reports, unable to create sample store for %s: %@\n",  v1[4],  v1[7],  v37);
        if (v38)
        {
          id v39 = v38;
          int v40 = CFStringGetCStringPtr(v38, 0x8000100u);
          if (v40)
          {
            int v41 = (char *)v40;
            int v42 = 0LL;
          }

          else
          {
            int v41 = (char *)calloc(0x400uLL, 1uLL);
            CFStringGetCString(v39, v41, 1024LL, 0x8000100u);
            int v42 = v41;
          }

          if (qword_1000E7D38) {
            uint64_t v45 = (FILE *)qword_1000E7D38;
          }
          else {
            uint64_t v45 = __stderrp;
          }
          fprintf(v45, "%s\n", v41);
          if (v42) {
            free(v42);
          }
          CFRelease(v39);
        }

        else
        {
          uint64_t v43 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v43, OS_LOG_TYPE_FAULT))
          {
            uint64_t v50 = v1[4];
            uint64_t v51 = v1[7];
            uint64_t v52 = v60;
            if (!v60) {
              uint64_t v52 = @"Unknown error";
            }
            *(_DWORD *)buf = 138412802;
            uint64_t v62 = v50;
            __int16 v63 = 2080;
            uint64_t v64 = v51;
            __int16 v65 = 2112;
            uint64_t v66 = v52;
            _os_log_fault_impl( (void *)&_mh_execute_header,  v43,  OS_LOG_TYPE_FAULT,  "Unable to format: WR: %@: Not generating any spindump reports, unable to create sample store for %s: %@\n",  buf,  0x20u);
          }

          if (qword_1000E7D38) {
            uint64_t v44 = (FILE *)qword_1000E7D38;
          }
          else {
            uint64_t v44 = __stderrp;
          }
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v44);
        }

        *__error() = v36;
      }

      *(void *)(*(void *)(v1[6] + 8LL) + 40LL) = 0LL;
    }
  }

  return *(void *)(*(void *)(v1[6] + 8LL) + 40LL);
}

uint64_t sub_100037A88( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result = *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 40LL);
  if (!result)
  {
    uint64_t v10 = *(void **)(*(void *)(*(void *)(a1 + 40) + 8LL) + 40LL);
    if (!v10)
    {
      if (byte_1000E7D30)
      {
        int v11 = *__error();
        int v12 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR)) {
          sub_100080CD0(v12, v13, v14, v15, v16, v17, v18, v19);
        }
        *__error() = v11;
      }

      if (byte_1000E7D31) {
        BOOL v20 = dword_1000E74E0 <= 3;
      }
      else {
        BOOL v20 = 0;
      }
      if (v20)
      {
        int v21 = *__error();
        int v22 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"%s: TidToPidDictPromise called with no sample store",  "sampleStore");
        if (v22)
        {
          uint64_t v32 = v22;
          CStringPtr = CFStringGetCStringPtr(v22, 0x8000100u);
          if (CStringPtr)
          {
            int v34 = (char *)CStringPtr;
            uint64_t v35 = 0LL;
          }

          else
          {
            int v34 = (char *)calloc(0x400uLL, 1uLL);
            CFStringGetCString(v32, v34, 1024LL, 0x8000100u);
            uint64_t v35 = v34;
          }

          if (qword_1000E7D38) {
            int v36 = (FILE *)qword_1000E7D38;
          }
          else {
            int v36 = __stderrp;
          }
          fprintf(v36, "%s\n", v34);
          if (v35) {
            free(v35);
          }
          CFRelease(v32);
        }

        else
        {
          double v23 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v23, OS_LOG_TYPE_FAULT)) {
            sub_100080C60(v23, v24, v25, v26, v27, v28, v29, v30);
          }
          if (qword_1000E7D38) {
            uint64_t v31 = (FILE *)qword_1000E7D38;
          }
          else {
            uint64_t v31 = __stderrp;
          }
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v31);
        }

        *__error() = v21;
      }

      sub_10002EE78( "DoWorkflowResponsivenessDelay_block_invoke",  "monitor-WorkflowResponsiveness.m",  935,  "%s: TidToPidDictPromise called with no sample store",  a5,  a6,  a7,  a8,  (char)"sampleStore");
      abort();
    }

    *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40) = [v10 tidToPidDict];
    return *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 40LL);
  }

  return result;
}

void sub_100037CA4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = objc_opt_class(&OBJC_CLASS___NSNull);
  if ((objc_opt_isKindOfClass(a3, v6) & 1) == 0)
  {
    int v7 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"env_%@",  WRSanitizeForCA(a2));
    if ([*(id *)(a1 + 32) objectForKeyedSubscript:v7])
    {
      if (byte_1000E7D30)
      {
        int v8 = *__error();
        uint64_t v9 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
        {
          uint64_t v20 = *(void *)(a1 + 40);
          id v21 = objc_msgSend(objc_msgSend(*(id *)(a1 + 48), "signpost"), "name");
          *(_DWORD *)buf = 138413058;
          uint64_t v25 = v20;
          __int16 v26 = 2112;
          id v27 = v21;
          __int16 v28 = 2112;
          uint64_t v29 = a2;
          __int16 v30 = 2112;
          uint64_t v31 = a3;
          _os_log_error_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_ERROR,  "WR: %@: %@: %@ -> %@, conflicts with existing entry",  buf,  0x2Au);
        }

        *__error() = v8;
      }

      if (byte_1000E7D31) {
        BOOL v10 = dword_1000E74E0 <= 3;
      }
      else {
        BOOL v10 = 0;
      }
      if (v10)
      {
        int v11 = *__error();
        int v12 = CFStringCreateWithFormat( kCFAllocatorDefault,  0,  @"WR: %@: %@: %@ -> %@, conflicts with existing entry",  *(void *)(a1 + 40),  objc_msgSend(objc_msgSend(*(id *)(a1 + 48), "signpost"), "name"),  a2,  a3);
        if (v12)
        {
          uint64_t v13 = v12;
          CStringPtr = CFStringGetCStringPtr(v12, 0x8000100u);
          if (CStringPtr)
          {
            uint64_t v15 = (char *)CStringPtr;
            uint64_t v16 = 0LL;
          }

          else
          {
            uint64_t v15 = (char *)calloc(0x400uLL, 1uLL);
            CFStringGetCString(v13, v15, 1024LL, 0x8000100u);
            uint64_t v16 = v15;
          }

          if (qword_1000E7D38) {
            uint64_t v19 = (FILE *)qword_1000E7D38;
          }
          else {
            uint64_t v19 = __stderrp;
          }
          fprintf(v19, "%s\n", v15);
          if (v16) {
            free(v16);
          }
          CFRelease(v13);
        }

        else
        {
          uint64_t v17 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v17, OS_LOG_TYPE_FAULT))
          {
            uint64_t v22 = *(void *)(a1 + 40);
            id v23 = objc_msgSend(objc_msgSend(*(id *)(a1 + 48), "signpost"), "name");
            *(_DWORD *)buf = 138413058;
            uint64_t v25 = v22;
            __int16 v26 = 2112;
            id v27 = v23;
            __int16 v28 = 2112;
            uint64_t v29 = a2;
            __int16 v30 = 2112;
            uint64_t v31 = a3;
            _os_log_fault_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_FAULT,  "Unable to format: WR: %@: %@: %@ -> %@, conflicts with existing entry",  buf,  0x2Au);
          }

          if (qword_1000E7D38) {
            uint64_t v18 = (FILE *)qword_1000E7D38;
          }
          else {
            uint64_t v18 = __stderrp;
          }
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v18);
        }

        *__error() = v11;
      }
    }

    else
    {
      [*(id *)(a1 + 32) setObject:a3 forKeyedSubscript:v7];
    }
  }

void sub_100037FC4(void *a1)
{
  uint64_t v2 = objc_opt_class(&OBJC_CLASS___NSMutableDictionary);
  if ((objc_opt_isKindOfClass(a1, v2) & 1) != 0)
  {
    __int128 v29 = 0u;
    __int128 v30 = 0u;
    __int128 v27 = 0u;
    __int128 v28 = 0u;
    id v3 = [a1 allKeys];
    id v4 = [v3 countByEnumeratingWithState:&v27 objects:v32 count:16];
    if (v4)
    {
      id v5 = v4;
      uint64_t v6 = *(void *)v28;
      do
      {
        for (i = 0LL; i != v5; i = (char *)i + 1)
        {
          if (*(void *)v28 != v6) {
            objc_enumerationMutation(v3);
          }
          uint64_t v8 = *(void *)(*((void *)&v27 + 1) + 8LL * (void)i);
          id v9 = [a1 objectForKeyedSubscript:v8];
          v26[0] = _NSConcreteStackBlock;
          v26[1] = 3221225472LL;
          v26[2] = sub_10003C3D4;
          v26[3] = &unk_1000D8EC0;
          v26[4] = a1;
          v26[5] = v8;
          sub_10003C288(v9, (uint64_t)v26);
        }

        id v5 = [v3 countByEnumeratingWithState:&v27 objects:v32 count:16];
      }

      while (v5);
    }
  }

  else
  {
    uint64_t v10 = objc_opt_class(&OBJC_CLASS___NSMutableArray);
    if ((objc_opt_isKindOfClass(a1, v10) & 1) != 0)
    {
      if ([a1 count])
      {
        unint64_t v11 = 0LL;
        do
        {
          id v12 = [a1 objectAtIndexedSubscript:v11];
          v25[0] = _NSConcreteStackBlock;
          v25[1] = 3221225472LL;
          v25[2] = sub_10003C3E4;
          v25[3] = &unk_1000D8EE8;
          v25[4] = a1;
          v25[5] = v11;
          sub_10003C288(v12, (uint64_t)v25);
          ++v11;
        }

        while (v11 < (unint64_t)[a1 count]);
      }
    }

    else
    {
      uint64_t v13 = objc_opt_class(&OBJC_CLASS___NSMutableSet);
      if ((objc_opt_isKindOfClass(a1, v13) & 1) != 0)
      {
        id v14 = [a1 copy];
        __int128 v21 = 0u;
        __int128 v22 = 0u;
        __int128 v23 = 0u;
        __int128 v24 = 0u;
        id v15 = [v14 countByEnumeratingWithState:&v21 objects:v31 count:16];
        if (v15)
        {
          id v16 = v15;
          uint64_t v17 = *(void *)v22;
          do
          {
            for (j = 0LL; j != v16; j = (char *)j + 1)
            {
              if (*(void *)v22 != v17) {
                objc_enumerationMutation(v14);
              }
              uint64_t v19 = *(void **)(*((void *)&v21 + 1) + 8LL * (void)j);
              v20[0] = _NSConcreteStackBlock;
              v20[1] = 3221225472LL;
              v20[2] = sub_10003C3F4;
              v20[3] = &unk_1000D8EC0;
              v20[4] = a1;
              v20[5] = v19;
              sub_10003C288(v19, (uint64_t)v20);
            }

            id v16 = [v14 countByEnumeratingWithState:&v21 objects:v31 count:16];
          }

          while (v16);
        }
      }
    }
  }

void sub_100038288(id a1)
{
  unsigned int v1 = dispatch_queue_attr_make_with_autorelease_frequency(0LL, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
  uint64_t v2 = dispatch_queue_attr_make_with_qos_class(v1, QOS_CLASS_BACKGROUND, 0);
  qword_1000E7BC8 = (uint64_t)dispatch_queue_create("WR processing", v2);
  dispatch_release(v2);
}

id sub_1000382D8(uint64_t a1, void *a2)
{
  id result = objc_msgSend(objc_msgSend(a2, "name"), "isEqualToString:", *(void *)(a1 + 32));
  if ((_DWORD)result) {
    return [*(id *)(a1 + 40) addObject:a2];
  }
  return result;
}

void sub_100038320( void *a1, uint64_t a2, void *a3, void *a4, void *a5, void *a6, uint64_t a7, void *a8, void *a9, uint64_t a10, uint64_t a11, unint64_t a12, unint64_t a13)
{
  id v14 = a5;
  id v15 = a4;
  unint64_t v17 = a12;
  uint64_t v18 = a10;
  if (a8)
  {
    uint64_t v19 = a4;
    uint64_t v20 = a5;
    __int128 v21 = a6;
    __int128 v22 = a8;
LABEL_22:
    id v38 = +[SATimeRange timeRangeStart:end:]( &OBJC_CLASS___SATimeRange,  "timeRangeStart:end:",  +[SATimestamp timestampWithMachAbsTime:machAbsTimeSec:machContTime:machContTimeSec:wallTime:]( &OBJC_CLASS___SATimestamp,  "timestampWithMachAbsTime:machAbsTimeSec:machContTime:machContTimeSec:wallTime:",  0LL,  0LL,  0.0,  (double)v17 / 1000000000.0,  0.0),  +[SATimestamp timestampWithMachAbsTime:machAbsTimeSec:machContTime:machContTimeSec:wallTime:]( &OBJC_CLASS___SATimestamp,  "timestampWithMachAbsTime:machAbsTimeSec:machContTime:machContTimeSec:wallTime:",  0LL,  0LL,  0.0,  (double)a13 / 1000000000.0,  0.0));
    __int128 v111 = 0u;
    __int128 v112 = 0u;
    __int128 v113 = 0u;
    __int128 v114 = 0u;
    id v39 = -[NSArray countByEnumeratingWithState:objects:count:]( v22,  "countByEnumeratingWithState:objects:count:",  &v111,  v115,  16LL);
    if (v39)
    {
      id v40 = v39;
      uint64_t v41 = *(void *)v112;
      do
      {
        for (i = 0LL; i != v40; i = (char *)i + 1)
        {
          if (*(void *)v112 != v41) {
            objc_enumerationMutation(v22);
          }
          sub_100038FBC(a1, a2, v19, v20, v21, a7, a10, a11, v38, *(void **)(*((void *)&v111 + 1) + 8LL * (void)i));
        }

        id v40 = -[NSArray countByEnumeratingWithState:objects:count:]( v22,  "countByEnumeratingWithState:objects:count:",  &v111,  v115,  16LL);
      }

      while (v40);
    }

    return;
  }

  if (a11)
  {
    unint64_t v108 = a12;
    __int128 v23 = sub_100038E0C(a3, a9, a11, a13);
    if (!v23)
    {
      if (byte_1000E7D30)
      {
        int v24 = *__error();
        uint64_t v25 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
        {
          id v83 = objc_msgSend(objc_msgSend(v15, "workflow"), "name");
          double v84 = (const __CFString *)objc_msgSend(objc_msgSend(v14, "signpost"), "name");
          BOOL v85 = v15;
          int v86 = v14;
          if (v84) {
            __int16 v87 = v84;
          }
          else {
            __int16 v87 = @"<entire workflow>";
          }
          *(_DWORD *)buf = 138413314;
          id v117 = v83;
          __int16 v118 = 2112;
          uint64_t v119 = v87;
          id v14 = v86;
          id v15 = v85;
          __int16 v120 = 2112;
          id v121 = [a6 name];
          __int16 v122 = 2048;
          uint64_t v123 = a11;
          __int16 v124 = 2048;
          unint64_t v125 = a13;
          _os_log_error_impl( (void *)&_mh_execute_header,  v25,  OS_LOG_TYPE_ERROR,  "WR: %@: %@: diagnostic %@: Unable to find task with thread 0x%llx at %llu, cannot generate report",  buf,  0x34u);
        }

        *__error() = v24;
      }

      if (byte_1000E7D31) {
        BOOL v26 = dword_1000E74E0 <= 3;
      }
      else {
        BOOL v26 = 0;
      }
      if (v26)
      {
        int v27 = *__error();
        id v28 = objc_msgSend(objc_msgSend(v15, "workflow"), "name");
        __int128 v29 = (const __CFString *)objc_msgSend(objc_msgSend(v14, "signpost"), "name");
        __int128 v30 = v15;
        uint64_t v31 = v14;
        if (v29) {
          uint64_t v32 = v29;
        }
        else {
          uint64_t v32 = @"<entire workflow>";
        }
        uint64_t v33 = CFStringCreateWithFormat( kCFAllocatorDefault,  0,  @"WR: %@: %@: diagnostic %@: Unable to find task with thread 0x%llx at %llu, cannot generate report",  v28,  v32,  [a6 name],  a11,  a13);
        if (v33)
        {
          int v34 = v33;
          CStringPtr = CFStringGetCStringPtr(v33, 0x8000100u);
          if (CStringPtr)
          {
            int v36 = (char *)CStringPtr;
            id v37 = 0LL;
          }

          else
          {
            int v36 = (char *)calloc(0x400uLL, 1uLL);
            CFStringGetCString(v34, v36, 1024LL, 0x8000100u);
            id v37 = v36;
          }

          if (qword_1000E7D38) {
            id v76 = (FILE *)qword_1000E7D38;
          }
          else {
            id v76 = __stderrp;
          }
          fprintf(v76, "%s\n", v36);
          if (v37) {
            free(v37);
          }
          CFRelease(v34);
        }

        else
        {
          int v74 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v74, OS_LOG_TYPE_FAULT))
          {
            id v96 = objc_msgSend(objc_msgSend(v30, "workflow"), "name");
            id v97 = (const __CFString *)objc_msgSend(objc_msgSend(v31, "signpost"), "name");
            if (v97) {
              char v98 = v97;
            }
            else {
              char v98 = @"<entire workflow>";
            }
            id v99 = [a6 name];
            *(_DWORD *)buf = 138413314;
            id v117 = v96;
            __int16 v118 = 2112;
            uint64_t v119 = v98;
            __int16 v120 = 2112;
            id v121 = v99;
            __int16 v122 = 2048;
            uint64_t v123 = a11;
            __int16 v124 = 2048;
            unint64_t v125 = a13;
            _os_log_fault_impl( (void *)&_mh_execute_header,  v74,  OS_LOG_TYPE_FAULT,  "Unable to format: WR: %@: %@: diagnostic %@: Unable to find task with thread 0x%llx at %llu, cannot generate report",  buf,  0x34u);
          }

          if (qword_1000E7D38) {
            unsigned int v75 = (FILE *)qword_1000E7D38;
          }
          else {
            unsigned int v75 = __stderrp;
          }
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v75);
        }

        *__error() = v27;
      }

      return;
    }

LABEL_21:
    uint64_t v19 = v15;
    uint64_t v20 = v14;
    __int128 v21 = a6;
    __int128 v22 = -[NSArray initWithObjects:](objc_alloc(&OBJC_CLASS___NSArray), "initWithObjects:", v23, 0LL);
    unint64_t v17 = v108;
    goto LABEL_22;
  }

  if (a10)
  {
    unint64_t v108 = a12;
    __int128 v23 = sub_100038E0C(a3, a9, a10, a12);
    if (v23) {
      goto LABEL_21;
    }
    if (byte_1000E7D30)
    {
      __int128 v58 = v15;
      int v59 = *__error();
      int v60 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v60, OS_LOG_TYPE_ERROR))
      {
        id v92 = objc_msgSend(objc_msgSend(v58, "workflow"), "name");
        v93 = (const __CFString *)objc_msgSend(objc_msgSend(v14, "signpost"), "name");
        v94 = v14;
        if (v93) {
          unsigned int v95 = v93;
        }
        else {
          unsigned int v95 = @"<entire workflow>";
        }
        *(_DWORD *)buf = 138413314;
        id v117 = v92;
        __int16 v118 = 2112;
        uint64_t v119 = v95;
        id v14 = v94;
        uint64_t v18 = a10;
        __int16 v120 = 2112;
        id v121 = [a6 name];
        __int16 v122 = 2048;
        uint64_t v123 = a10;
        __int16 v124 = 2048;
        unint64_t v125 = a12;
        _os_log_error_impl( (void *)&_mh_execute_header,  v60,  OS_LOG_TYPE_ERROR,  "WR: %@: %@: diagnostic %@: Unable to find task with thread 0x%llx at %llu, cannot generate report",  buf,  0x34u);
      }

      *__error() = v59;
      id v15 = v58;
    }

    if (byte_1000E7D31) {
      BOOL v61 = dword_1000E74E0 <= 3;
    }
    else {
      BOOL v61 = 0;
    }
    if (v61)
    {
      int v62 = *__error();
      __int16 v63 = v15;
      id v64 = objc_msgSend(objc_msgSend(v15, "workflow"), "name");
      __int16 v65 = (const __CFString *)objc_msgSend(objc_msgSend(v14, "signpost"), "name");
      uint64_t v66 = v18;
      uint64_t v67 = v14;
      if (v65) {
        unsigned int v68 = v65;
      }
      else {
        unsigned int v68 = @"<entire workflow>";
      }
      unsigned int v69 = CFStringCreateWithFormat( kCFAllocatorDefault,  0,  @"WR: %@: %@: diagnostic %@: Unable to find task with thread 0x%llx at %llu, cannot generate report",  v64,  v68,  [a6 name],  v66,  a12);
      if (v69)
      {
        id v70 = v69;
        int v71 = CFStringGetCStringPtr(v69, 0x8000100u);
        if (v71)
        {
          int v72 = (char *)v71;
          int v73 = 0LL;
        }

        else
        {
          int v72 = (char *)calloc(0x400uLL, 1uLL);
          CFStringGetCString(v70, v72, 1024LL, 0x8000100u);
          int v73 = v72;
        }

        if (qword_1000E7D38) {
          uint64_t v82 = (FILE *)qword_1000E7D38;
        }
        else {
          uint64_t v82 = __stderrp;
        }
        fprintf(v82, "%s\n", v72);
        if (v73) {
          free(v73);
        }
        CFRelease(v70);
      }

      else
      {
        uint64_t v80 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v80, OS_LOG_TYPE_FAULT))
        {
          id v104 = objc_msgSend(objc_msgSend(v63, "workflow"), "name");
          id v105 = (const __CFString *)objc_msgSend(objc_msgSend(v67, "signpost"), "name");
          if (v105) {
            uint64_t v106 = v105;
          }
          else {
            uint64_t v106 = @"<entire workflow>";
          }
          id v107 = [a6 name];
          *(_DWORD *)buf = 138413314;
          id v117 = v104;
          __int16 v118 = 2112;
          uint64_t v119 = v106;
          __int16 v120 = 2112;
          id v121 = v107;
          __int16 v122 = 2048;
          uint64_t v123 = v66;
          __int16 v124 = 2048;
          unint64_t v125 = a12;
          _os_log_fault_impl( (void *)&_mh_execute_header,  v80,  OS_LOG_TYPE_FAULT,  "Unable to format: WR: %@: %@: diagnostic %@: Unable to find task with thread 0x%llx at %llu, cannot generate report",  buf,  0x34u);
        }

        if (qword_1000E7D38) {
          uint64_t v81 = (FILE *)qword_1000E7D38;
        }
        else {
          uint64_t v81 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v81);
      }

      *__error() = v62;
    }
  }

  else
  {
    if (byte_1000E7D30)
    {
      int v44 = *__error();
      uint64_t v45 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v45, OS_LOG_TYPE_ERROR))
      {
        id v88 = objc_msgSend(objc_msgSend(a4, "workflow"), "name");
        __int16 v89 = (const __CFString *)objc_msgSend(objc_msgSend(v14, "signpost"), "name");
        uint64_t v90 = v14;
        if (v89) {
          int v91 = v89;
        }
        else {
          int v91 = @"<entire workflow>";
        }
        *(_DWORD *)buf = 138412802;
        id v117 = v88;
        __int16 v118 = 2112;
        uint64_t v119 = v91;
        id v14 = v90;
        __int16 v120 = 2112;
        id v121 = [a6 name];
        _os_log_error_impl( (void *)&_mh_execute_header,  v45,  OS_LOG_TYPE_ERROR,  "WR: %@: %@: diagnostic %@: Unable to find task given no threads, cannot generate report",  buf,  0x20u);
      }

      *__error() = v44;
      id v15 = a4;
    }

    if (byte_1000E7D31) {
      BOOL v46 = dword_1000E74E0 <= 3;
    }
    else {
      BOOL v46 = 0;
    }
    if (v46)
    {
      int v47 = *__error();
      uint64_t v48 = v15;
      id v49 = objc_msgSend(objc_msgSend(v15, "workflow"), "name");
      uint64_t v50 = (const __CFString *)objc_msgSend(objc_msgSend(v14, "signpost"), "name");
      uint64_t v51 = v14;
      if (v50) {
        uint64_t v52 = v50;
      }
      else {
        uint64_t v52 = @"<entire workflow>";
      }
      unsigned __int8 v53 = CFStringCreateWithFormat( kCFAllocatorDefault,  0,  @"WR: %@: %@: diagnostic %@: Unable to find task given no threads, cannot generate report",  v49,  v52,  [a6 name]);
      if (v53)
      {
        int v54 = v53;
        int v55 = CFStringGetCStringPtr(v53, 0x8000100u);
        if (v55)
        {
          __int128 v56 = (char *)v55;
          __int128 v57 = 0LL;
        }

        else
        {
          __int128 v56 = (char *)calloc(0x400uLL, 1uLL);
          CFStringGetCString(v54, v56, 1024LL, 0x8000100u);
          __int128 v57 = v56;
        }

        if (qword_1000E7D38) {
          uint64_t v79 = (FILE *)qword_1000E7D38;
        }
        else {
          uint64_t v79 = __stderrp;
        }
        fprintf(v79, "%s\n", v56);
        if (v57) {
          free(v57);
        }
        CFRelease(v54);
      }

      else
      {
        char v77 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v77, OS_LOG_TYPE_FAULT))
        {
          id v100 = objc_msgSend(objc_msgSend(v48, "workflow"), "name");
          id v101 = (const __CFString *)objc_msgSend(objc_msgSend(v51, "signpost"), "name");
          if (v101) {
            double v102 = v101;
          }
          else {
            double v102 = @"<entire workflow>";
          }
          id v103 = [a6 name];
          *(_DWORD *)buf = 138412802;
          id v117 = v100;
          __int16 v118 = 2112;
          uint64_t v119 = v102;
          __int16 v120 = 2112;
          id v121 = v103;
          _os_log_fault_impl( (void *)&_mh_execute_header,  v77,  OS_LOG_TYPE_FAULT,  "Unable to format: WR: %@: %@: diagnostic %@: Unable to find task given no threads, cannot generate report",  buf,  0x20u);
        }

        if (qword_1000E7D38) {
          uint64_t v78 = (FILE *)qword_1000E7D38;
        }
        else {
          uint64_t v78 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v78);
      }

      *__error() = v47;
    }
  }

        unint64_t v17 = v9;
        uint64_t v18 = CFStringGetCStringPtr(v9, 0x8000100u);
        if (v18)
        {
          uint64_t v19 = (char *)v18;
          uint64_t v20 = 0LL;
        }

        else
        {
          uint64_t v19 = (char *)calloc(0x400uLL, 1uLL);
          CFStringGetCString(v17, v19, 1024LL, 0x8000100u);
          uint64_t v20 = v19;
        }

        if (qword_1000E7D38) {
          __int128 v21 = (FILE *)qword_1000E7D38;
        }
        else {
          __int128 v21 = __stderrp;
        }
        fprintf(v21, "%s\n", v19);
        if (v20) {
          free(v20);
        }
        CFRelease(v17);
        goto LABEL_36;
      }
    }
  }

void *sub_100038E0C(void *a1, void *a2, uint64_t a3, unint64_t a4)
{
  id v7 = objc_msgSend( a2,  "objectForKeyedSubscript:",  +[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:"));
  if (!v7) {
    return 0LL;
  }
  __int128 v24 = 0u;
  __int128 v25 = 0u;
  __int128 v22 = 0u;
  __int128 v23 = 0u;
  id v8 = objc_msgSend(objc_msgSend(a1, "tasksByPid", 0), "objectForKeyedSubscript:", v7);
  id v9 = [v8 countByEnumeratingWithState:&v22 objects:v26 count:16];
  if (!v9) {
    return 0LL;
  }
  id v10 = v9;
  double v11 = (double)a4 / 1000000000.0;
  uint64_t v12 = *(void *)v23;
  do
  {
    for (i = 0LL; i != v10; i = (char *)i + 1)
    {
      if (*(void *)v23 != v12) {
        objc_enumerationMutation(v8);
      }
      id v14 = *(void **)(*((void *)&v22 + 1) + 8LL * (void)i);
      if (objc_msgSend( objc_msgSend(v14, "threads"),  "objectForKeyedSubscript:",  +[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", a3)))
      {
        id v15 = [v14 startTimestamp];
        if (v15)
        {
          [v15 machContTimeSeconds];
          if (v16 != 0.0 && v11 < v16) {
            return 0LL;
          }
          id v18 = [v14 endTimestamp];
          if (v18)
          {
            [v18 machContTimeSeconds];
            if (v19 != 0.0 && v11 < v19) {
              return v14;
            }
          }
        }
      }
    }

    id v10 = [v8 countByEnumeratingWithState:&v22 objects:v26 count:16];
    id v14 = 0LL;
  }

  while (v10);
  return v14;
}

void sub_100038FBC( void *a1, uint64_t a2, void *a3, void *a4, void *a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, void *a10)
{
  if ([a5 reportSpindumpForThisThread])
  {
    if (a7 == a8 || a7 == 0) {
      uint64_t v14 = a8;
    }
    else {
      uint64_t v14 = 0LL;
    }
    if (a8) {
      uint64_t v15 = v14;
    }
    else {
      uint64_t v15 = a7;
    }
    if (v15)
    {
      id v16 = objc_msgSend( objc_msgSend(a10, "threads"),  "objectForKeyedSubscript:",  +[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", v15));
      if (v16)
      {
        unint64_t v17 = -[SPWRReport initWithReportReason:reportedSignpostTracker:task:timeRange:thread:dispatchQueue:]( objc_alloc(&OBJC_CLASS___SPWRReport),  "initWithReportReason:reportedSignpostTracker:task:timeRange:thread:dispatchQueue:",  a2,  a6,  a10,  a9,  v16,  0LL);
        [a1 addObject:v17];
      }

      else
      {
        if (byte_1000E7D30)
        {
          int v30 = *__error();
          uint64_t v31 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
          {
            id v321 = objc_msgSend(objc_msgSend(a3, "workflow"), "name");
            uint64_t v174 = (const __CFString *)objc_msgSend(objc_msgSend(a4, "signpost"), "name");
            uint64_t v175 = @"<entire workflow>";
            if (v174) {
              uint64_t v175 = v174;
            }
            *(_DWORD *)buf = 138413570;
            *(void *)&uint8_t buf[4] = v321;
            *(_WORD *)&_BYTE buf[12] = 2112;
            *(void *)&buf[14] = v175;
            *(_WORD *)&buf[22] = 2112;
            id v356 = [a5 name];
            *(_WORD *)__int16 v357 = 2112;
            *(void *)&v357[2] = [a10 name];
            *(_WORD *)&v357[10] = 1024;
            *(_DWORD *)&v357[12] = [a10 pid];
            *(_WORD *)&v357[16] = 2048;
            *(void *)&v357[18] = v15;
            _os_log_error_impl( (void *)&_mh_execute_header,  v31,  OS_LOG_TYPE_ERROR,  "WR: %@: %@: diagnostic %@: %@ [%d] has no thread 0x%llx, cannot generate report",  buf,  0x3Au);
          }

          *__error() = v30;
        }

        if (byte_1000E7D31) {
          BOOL v32 = dword_1000E74E0 <= 3;
        }
        else {
          BOOL v32 = 0;
        }
        if (v32)
        {
          int v313 = *__error();
          id v33 = objc_msgSend(objc_msgSend(a3, "workflow"), "name");
          int v34 = (const __CFString *)objc_msgSend(objc_msgSend(a4, "signpost"), "name");
          if (v34) {
            uint64_t v35 = v34;
          }
          else {
            uint64_t v35 = @"<entire workflow>";
          }
          int v36 = CFStringCreateWithFormat( kCFAllocatorDefault,  0,  @"WR: %@: %@: diagnostic %@: %@ [%d] has no thread 0x%llx, cannot generate report",  v33,  v35,  [a5 name],  objc_msgSend(a10, "name"),  objc_msgSend(a10, "pid"),  v15);
          id v37 = v36;
          if (v36)
          {
            CStringPtr = (char *)CFStringGetCStringPtr(v36, 0x8000100u);
            if (CStringPtr)
            {
              id v39 = 0LL;
            }

            else
            {
              CStringPtr = (char *)calloc(0x400uLL, 1uLL);
              CFStringGetCString(v37, CStringPtr, 1024LL, 0x8000100u);
              id v39 = CStringPtr;
            }

            if (qword_1000E7D38) {
              uint64_t v45 = (FILE *)qword_1000E7D38;
            }
            else {
              uint64_t v45 = __stderrp;
            }
            fprintf(v45, "%s\n", CStringPtr);
            if (v39) {
              free(v39);
            }
            CFRelease(v37);
          }

          else
          {
            uint64_t v43 = (os_log_s *)sub_10002EFA0();
            if (os_log_type_enabled(v43, OS_LOG_TYPE_FAULT))
            {
              id v312 = objc_msgSend(objc_msgSend(a3, "workflow"), "name");
              id v212 = (const __CFString *)objc_msgSend(objc_msgSend(a4, "signpost"), "name");
              if (v212) {
                id v213 = v212;
              }
              else {
                id v213 = @"<entire workflow>";
              }
              id v214 = [a5 name];
              id v215 = [a10 name];
              unsigned int v216 = [a10 pid];
              *(_DWORD *)buf = 138413570;
              *(void *)&uint8_t buf[4] = v312;
              *(_WORD *)&_BYTE buf[12] = 2112;
              *(void *)&buf[14] = v213;
              *(_WORD *)&buf[22] = 2112;
              id v356 = v214;
              *(_WORD *)__int16 v357 = 2112;
              *(void *)&v357[2] = v215;
              *(_WORD *)&v357[10] = 1024;
              *(_DWORD *)&v357[12] = v216;
              *(_WORD *)&v357[16] = 2048;
              *(void *)&v357[18] = v15;
              _os_log_fault_impl( (void *)&_mh_execute_header,  v43,  OS_LOG_TYPE_FAULT,  "Unable to format: WR: %@: %@: diagnostic %@: %@ [%d] has no thread 0x%llx, cannot generate report",  buf,  0x3Au);
            }

            if (qword_1000E7D38) {
              int v44 = (FILE *)qword_1000E7D38;
            }
            else {
              int v44 = __stderrp;
            }
            fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v44);
          }

          *__error() = v313;
        }
      }
    }

    else
    {
      if (byte_1000E7D30)
      {
        int v18 = *__error();
        double v19 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
        {
          id v162 = objc_msgSend(objc_msgSend(a3, "workflow"), "name");
          int v163 = (const __CFString *)objc_msgSend(objc_msgSend(a4, "signpost"), "name");
          if (v163) {
            int v164 = v163;
          }
          else {
            int v164 = @"<entire workflow>";
          }
          *(_DWORD *)buf = 138413314;
          *(void *)&uint8_t buf[4] = v162;
          *(_WORD *)&_BYTE buf[12] = 2112;
          *(void *)&buf[14] = v164;
          *(_WORD *)&buf[22] = 2112;
          id v356 = [a5 name];
          *(_WORD *)__int16 v357 = 2048;
          *(void *)&v357[2] = a7;
          *(_WORD *)&v357[10] = 2048;
          *(void *)&v357[12] = a8;
          _os_log_error_impl( (void *)&_mh_execute_header,  v19,  OS_LOG_TYPE_ERROR,  "WR: %@: %@: diagnostic %@ reports this thread, but signpost starts on 0x%llx and ends on 0x%llx",  buf,  0x34u);
        }

        *__error() = v18;
      }

      if (byte_1000E7D31) {
        BOOL v20 = dword_1000E74E0 <= 3;
      }
      else {
        BOOL v20 = 0;
      }
      if (v20)
      {
        int v21 = *__error();
        id v22 = objc_msgSend(objc_msgSend(a3, "workflow"), "name");
        __int128 v23 = (const __CFString *)objc_msgSend(objc_msgSend(a4, "signpost"), "name");
        __int128 v24 = @"<entire workflow>";
        if (v23) {
          __int128 v25 = v23;
        }
        else {
          __int128 v25 = @"<entire workflow>";
        }
        BOOL v26 = CFStringCreateWithFormat( kCFAllocatorDefault,  0,  @"WR: %@: %@: diagnostic %@ reports this thread, but signpost starts on 0x%llx and ends on 0x%llx",  v22,  v25,  [a5 name],  a7,  a8);
        int v27 = v26;
        if (v26)
        {
          id v28 = (char *)CFStringGetCStringPtr(v26, 0x8000100u);
          if (v28)
          {
            __int128 v29 = 0LL;
          }

          else
          {
            id v28 = (char *)calloc(0x400uLL, 1uLL);
            CFStringGetCString(v27, v28, 1024LL, 0x8000100u);
            __int128 v29 = v28;
          }

          if (qword_1000E7D38) {
            int v42 = (FILE *)qword_1000E7D38;
          }
          else {
            int v42 = __stderrp;
          }
          fprintf(v42, "%s\n", v28);
          if (v29) {
            free(v29);
          }
          CFRelease(v27);
        }

        else
        {
          id v40 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v40, OS_LOG_TYPE_FAULT))
          {
            id v196 = objc_msgSend(objc_msgSend(a3, "workflow"), "name");
            id v197 = (const __CFString *)objc_msgSend(objc_msgSend(a4, "signpost"), "name");
            if (v197) {
              __int128 v24 = v197;
            }
            id v198 = [a5 name];
            *(_DWORD *)buf = 138413314;
            *(void *)&uint8_t buf[4] = v196;
            *(_WORD *)&_BYTE buf[12] = 2112;
            *(void *)&buf[14] = v24;
            *(_WORD *)&buf[22] = 2112;
            id v356 = v198;
            *(_WORD *)__int16 v357 = 2048;
            *(void *)&v357[2] = a7;
            *(_WORD *)&v357[10] = 2048;
            *(void *)&v357[12] = a8;
            _os_log_fault_impl( (void *)&_mh_execute_header,  v40,  OS_LOG_TYPE_FAULT,  "Unable to format: WR: %@: %@: diagnostic %@ reports this thread, but signpost starts on 0x%llx and ends on 0x%llx",  buf,  0x34u);
          }

          if (qword_1000E7D38) {
            uint64_t v41 = (FILE *)qword_1000E7D38;
          }
          else {
            uint64_t v41 = __stderrp;
          }
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v41);
        }

        *__error() = v21;
      }
    }
  }

  id v46 = [a5 reportSpindumpForThreadWithName];
  int v47 = v46;
  if (v46)
  {
    if ([v46 hasPrefix:@"^"]
      && [v47 hasSuffix:@"$"])
    {
      *(void *)v352 = 0LL;
      uint64_t v48 = -[NSRegularExpression initWithPattern:options:error:]( objc_alloc(&OBJC_CLASS___NSRegularExpression),  "initWithPattern:options:error:",  v47,  0LL,  v352);
      if (!v48)
      {
        if (byte_1000E7D30)
        {
          int v49 = *__error();
          uint64_t v50 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v50, OS_LOG_TYPE_ERROR))
          {
            id v187 = objc_msgSend(objc_msgSend(a3, "workflow"), "name");
            id v188 = (const __CFString *)objc_msgSend(objc_msgSend(a4, "signpost"), "name");
            if (v188) {
              int v189 = v188;
            }
            else {
              int v189 = @"<entire workflow>";
            }
            id v190 = [a5 name];
            *(_DWORD *)buf = 138413314;
            *(void *)&uint8_t buf[4] = v187;
            *(_WORD *)&_BYTE buf[12] = 2112;
            *(void *)&buf[14] = v189;
            *(_WORD *)&buf[22] = 2112;
            id v356 = v190;
            *(_WORD *)__int16 v357 = 2112;
            *(void *)&v357[2] = v47;
            *(_WORD *)&v357[10] = 2112;
            *(void *)&v357[12] = *(void *)v352;
            _os_log_error_impl( (void *)&_mh_execute_header,  v50,  OS_LOG_TYPE_ERROR,  "WR: %@: %@: diagnostic %@ reports thread %@, but regex failed to compile: %@",  buf,  0x34u);
          }

          *__error() = v49;
        }

        if (byte_1000E7D31 && dword_1000E74E0 <= 3)
        {
          int v51 = *__error();
          id v52 = objc_msgSend(objc_msgSend(a3, "workflow"), "name");
          unsigned __int8 v53 = (const __CFString *)objc_msgSend(objc_msgSend(a4, "signpost"), "name");
          int v54 = @"<entire workflow>";
          if (v53) {
            int v55 = v53;
          }
          else {
            int v55 = @"<entire workflow>";
          }
          id v56 = [a5 name];
          __int128 v57 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"WR: %@: %@: diagnostic %@ reports thread %@, but regex failed to compile: %@",  v52,  v55,  v56,  v47,  *(void *)v352);
          __int128 v58 = v57;
          if (v57)
          {
            int v59 = (char *)CFStringGetCStringPtr(v57, 0x8000100u);
            if (v59)
            {
              int v60 = 0LL;
            }

            else
            {
              int v59 = (char *)calloc(0x400uLL, 1uLL);
              CFStringGetCString(v58, v59, 1024LL, 0x8000100u);
              int v60 = v59;
            }

            if (qword_1000E7D38) {
              BOOL v170 = (FILE *)qword_1000E7D38;
            }
            else {
              BOOL v170 = __stderrp;
            }
            fprintf(v170, "%s\n", v59);
            if (v60) {
              free(v60);
            }
            CFRelease(v58);
          }

          else
          {
            id v146 = (os_log_s *)sub_10002EFA0();
            if (os_log_type_enabled(v146, OS_LOG_TYPE_FAULT))
            {
              id v270 = objc_msgSend(objc_msgSend(a3, "workflow"), "name");
              int v271 = (const __CFString *)objc_msgSend(objc_msgSend(a4, "signpost"), "name");
              if (v271) {
                int v54 = v271;
              }
              id v272 = [a5 name];
              *(_DWORD *)buf = 138413314;
              *(void *)&uint8_t buf[4] = v270;
              *(_WORD *)&_BYTE buf[12] = 2112;
              *(void *)&buf[14] = v54;
              *(_WORD *)&buf[22] = 2112;
              id v356 = v272;
              *(_WORD *)__int16 v357 = 2112;
              *(void *)&v357[2] = v47;
              *(_WORD *)&v357[10] = 2112;
              *(void *)&v357[12] = *(void *)v352;
              _os_log_fault_impl( (void *)&_mh_execute_header,  v146,  OS_LOG_TYPE_FAULT,  "Unable to format: WR: %@: %@: diagnostic %@ reports thread %@, but regex failed to compile: %@",  buf,  0x34u);
            }

            if (qword_1000E7D38) {
              id v147 = (FILE *)qword_1000E7D38;
            }
            else {
              id v147 = __stderrp;
            }
            fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v147);
          }

          *__error() = v51;
        }

        goto LABEL_109;
      }
    }

    else
    {
      uint64_t v48 = 0LL;
    }

    v339 = 0LL;
    uint64_t v340 = (uint64_t)&v339;
    uint64_t v341 = 0x2020000000LL;
    LOBYTE(v342) = 0;
    id v61 = [a10 threads];
    *(void *)buf = _NSConcreteStackBlock;
    *(void *)&uint8_t buf[8] = 3221225472LL;
    *(void *)&buf[16] = sub_10003BC50;
    id v356 = &unk_1000D8E70;
    *(void *)__int16 v357 = a9;
    *(void *)&v357[8] = v48;
    *(void *)&v357[16] = v47;
    *(void *)&v357[24] = a2;
    uint64_t v358 = a6;
    double v359 = a10;
    unsigned int v360 = a1;
    v361 = &v339;
    [v61 enumerateKeysAndObjectsUsingBlock:buf];
    if (!*(_BYTE *)(v340 + 24))
    {
      if (byte_1000E7D30)
      {
        int v62 = *__error();
        __int16 v63 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v63, OS_LOG_TYPE_ERROR))
        {
          id v319 = objc_msgSend(objc_msgSend(a3, "workflow"), "name");
          int v157 = (const __CFString *)objc_msgSend(objc_msgSend(a4, "signpost"), "name");
          double v158 = @"<entire workflow>";
          if (v157) {
            double v158 = v157;
          }
          v310 = v158;
          id v308 = [a5 name];
          id v307 = [a10 name];
          unsigned int v304 = [a10 pid];
          id v159 = objc_msgSend(objc_msgSend(a9, "startTime"), "debugDescription");
          id v160 = objc_msgSend(objc_msgSend(a9, "endTime"), "debugDescription");
          *(_DWORD *)v352 = 138414082;
          *(void *)&v352[4] = v319;
          *(_WORD *)&v352[12] = 2112;
          *(void *)&v352[14] = v310;
          *(_WORD *)&v352[22] = 2112;
          *(void *)&v352[24] = v308;
          *(_WORD *)&v352[32] = 2112;
          *(void *)&v352[34] = v47;
          *(_WORD *)&v352[42] = 2112;
          *(void *)&v352[44] = v307;
          *(_WORD *)&v352[52] = 1024;
          *(_DWORD *)&v352[54] = v304;
          *(_WORD *)&v352[58] = 2112;
          *(void *)&v352[60] = v159;
          __int16 v353 = 2112;
          id v354 = v160;
          _os_log_error_impl( (void *)&_mh_execute_header,  v63,  OS_LOG_TYPE_ERROR,  "WR: %@: %@: diagnostic %@ reports thread %@, but %@ [%d] has no thread with that name during the interval %@ - %@",  v352,  0x4Eu);
        }

        *__error() = v62;
      }

      if (byte_1000E7D31 && dword_1000E74E0 <= 3)
      {
        int v306 = *__error();
        id v314 = objc_msgSend(objc_msgSend(a3, "workflow"), "name");
        id v64 = (const __CFString *)objc_msgSend(objc_msgSend(a4, "signpost"), "name");
        __int16 v65 = @"<entire workflow>";
        if (v64) {
          __int16 v65 = v64;
        }
        uint64_t v66 = CFStringCreateWithFormat( kCFAllocatorDefault,  0,  @"WR: %@: %@: diagnostic %@ reports thread %@, but %@ [%d] has no thread with that name during the interval %@ - %@",  v314,  v65,  [a5 name],  v47,  objc_msgSend(a10, "name"),  objc_msgSend(a10, "pid"),  objc_msgSend(objc_msgSend(a9, "startTime"), "debugDescription"),  objc_msgSend(objc_msgSend(a9, "endTime"), "debugDescription"));
        uint64_t v67 = v66;
        if (v66)
        {
          unsigned int v68 = (char *)CFStringGetCStringPtr(v66, 0x8000100u);
          if (v68)
          {
            unsigned int v69 = 0LL;
          }

          else
          {
            unsigned int v68 = (char *)calloc(0x400uLL, 1uLL);
            CFStringGetCString(v67, v68, 1024LL, 0x8000100u);
            unsigned int v69 = v68;
          }

          if (qword_1000E7D38) {
            int v72 = (FILE *)qword_1000E7D38;
          }
          else {
            int v72 = __stderrp;
          }
          fprintf(v72, "%s\n", v68);
          if (v69) {
            free(v69);
          }
          CFRelease(v67);
        }

        else
        {
          id v70 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v70, OS_LOG_TYPE_FAULT))
          {
            id v322 = objc_msgSend(objc_msgSend(a3, "workflow"), "name");
            id v182 = (const __CFString *)objc_msgSend(objc_msgSend(a4, "signpost"), "name");
            id v183 = @"<entire workflow>";
            if (v182) {
              id v183 = v182;
            }
            v311 = v183;
            id v309 = [a5 name];
            id v305 = [a10 name];
            unsigned int v184 = [a10 pid];
            id v185 = objc_msgSend(objc_msgSend(a9, "startTime"), "debugDescription");
            id v186 = objc_msgSend(objc_msgSend(a9, "endTime"), "debugDescription");
            *(_DWORD *)v352 = 138414082;
            *(void *)&v352[4] = v322;
            *(_WORD *)&v352[12] = 2112;
            *(void *)&v352[14] = v311;
            *(_WORD *)&v352[22] = 2112;
            *(void *)&v352[24] = v309;
            *(_WORD *)&v352[32] = 2112;
            *(void *)&v352[34] = v47;
            *(_WORD *)&v352[42] = 2112;
            *(void *)&v352[44] = v305;
            *(_WORD *)&v352[52] = 1024;
            *(_DWORD *)&v352[54] = v184;
            *(_WORD *)&v352[58] = 2112;
            *(void *)&v352[60] = v185;
            __int16 v353 = 2112;
            id v354 = v186;
            _os_log_fault_impl( (void *)&_mh_execute_header,  v70,  OS_LOG_TYPE_FAULT,  "Unable to format: WR: %@: %@: diagnostic %@ reports thread %@, but %@ [%d] has no thread with that name du ring the interval %@ - %@",  v352,  0x4Eu);
          }

          if (qword_1000E7D38) {
            int v71 = (FILE *)qword_1000E7D38;
          }
          else {
            int v71 = __stderrp;
          }
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v71);
        }

        *__error() = v306;
      }
    }

    _Block_object_dispose(&v339, 8);
  }

LABEL_109:
  if ([a5 reportSpindumpForMainThread])
  {
    id v73 = [a10 mainThread];
    if (v73)
    {
      int v74 = -[SPWRReport initWithReportReason:reportedSignpostTracker:task:timeRange:thread:dispatchQueue:]( objc_alloc(&OBJC_CLASS___SPWRReport),  "initWithReportReason:reportedSignpostTracker:task:timeRange:thread:dispatchQueue:",  a2,  a6,  a10,  a9,  v73,  0LL);
      [a1 addObject:v74];
    }

    else
    {
      if (byte_1000E7D30)
      {
        int v75 = *__error();
        id v76 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v76, OS_LOG_TYPE_ERROR))
        {
          id v320 = objc_msgSend(objc_msgSend(a3, "workflow"), "name");
          BOOL v165 = (const __CFString *)objc_msgSend(objc_msgSend(a4, "signpost"), "name");
          if (v165) {
            int v166 = v165;
          }
          else {
            int v166 = @"<entire workflow>";
          }
          id v167 = [a5 name];
          id v168 = [a10 name];
          unsigned int v169 = [a10 pid];
          *(_DWORD *)buf = 138413314;
          *(void *)&uint8_t buf[4] = v320;
          *(_WORD *)&_BYTE buf[12] = 2112;
          *(void *)&buf[14] = v166;
          *(_WORD *)&buf[22] = 2112;
          id v356 = v167;
          *(_WORD *)__int16 v357 = 2112;
          *(void *)&v357[2] = v168;
          *(_WORD *)&v357[10] = 1024;
          *(_DWORD *)&v357[12] = v169;
          _os_log_error_impl( (void *)&_mh_execute_header,  v76,  OS_LOG_TYPE_ERROR,  "WR: %@: %@: diagnostic %@ reports main thread, but %@ [%d] has no main thread",  buf,  0x30u);
        }

        *__error() = v75;
      }

      if (byte_1000E7D31 && dword_1000E74E0 <= 3)
      {
        int v315 = *__error();
        id v77 = objc_msgSend(objc_msgSend(a3, "workflow"), "name");
        uint64_t v78 = (const __CFString *)objc_msgSend(objc_msgSend(a4, "signpost"), "name");
        if (v78) {
          uint64_t v79 = v78;
        }
        else {
          uint64_t v79 = @"<entire workflow>";
        }
        uint64_t v80 = CFStringCreateWithFormat( kCFAllocatorDefault,  0,  @"WR: %@: %@: diagnostic %@ reports main thread, but %@ [%d] has no main thread",  v77,  v79,  [a5 name],  objc_msgSend(a10, "name"),  objc_msgSend(a10, "pid"));
        uint64_t v81 = v80;
        if (v80)
        {
          uint64_t v82 = (char *)CFStringGetCStringPtr(v80, 0x8000100u);
          if (v82)
          {
            id v83 = 0LL;
          }

          else
          {
            uint64_t v82 = (char *)calloc(0x400uLL, 1uLL);
            CFStringGetCString(v81, v82, 1024LL, 0x8000100u);
            id v83 = v82;
          }

          if (qword_1000E7D38) {
            int v86 = (FILE *)qword_1000E7D38;
          }
          else {
            int v86 = __stderrp;
          }
          fprintf(v86, "%s\n", v82);
          if (v83) {
            free(v83);
          }
          CFRelease(v81);
        }

        else
        {
          double v84 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v84, OS_LOG_TYPE_FAULT))
          {
            id v199 = objc_msgSend(objc_msgSend(a3, "workflow"), "name");
            v200 = (const __CFString *)objc_msgSend(objc_msgSend(a4, "signpost"), "name");
            if (v200) {
              id v201 = v200;
            }
            else {
              id v201 = @"<entire workflow>";
            }
            id v202 = [a5 name];
            id v203 = [a10 name];
            unsigned int v204 = [a10 pid];
            *(_DWORD *)buf = 138413314;
            *(void *)&uint8_t buf[4] = v199;
            *(_WORD *)&_BYTE buf[12] = 2112;
            *(void *)&buf[14] = v201;
            *(_WORD *)&buf[22] = 2112;
            id v356 = v202;
            *(_WORD *)__int16 v357 = 2112;
            *(void *)&v357[2] = v203;
            *(_WORD *)&v357[10] = 1024;
            *(_DWORD *)&v357[12] = v204;
            _os_log_fault_impl( (void *)&_mh_execute_header,  v84,  OS_LOG_TYPE_FAULT,  "Unable to format: WR: %@: %@: diagnostic %@ reports main thread, but %@ [%d] has no main thread",  buf,  0x30u);
          }

          if (qword_1000E7D38) {
            BOOL v85 = (FILE *)qword_1000E7D38;
          }
          else {
            BOOL v85 = __stderrp;
          }
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v85);
        }

        *__error() = v315;
      }
    }
  }

  id v87 = objc_msgSend( objc_msgSend( objc_msgSend(a10, "threads"),  "objectForKeyedSubscript:",  +[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", a7)),  "firstThreadStateOnOrAfterTime:sampleIndex:",  objc_msgSend(a9, "startTime"),  0x7FFFFFFFFFFFFFFFLL);
  id v88 = objc_msgSend( objc_msgSend( objc_msgSend(a10, "threads"),  "objectForKeyedSubscript:",  +[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", a8)),  "lastThreadStateOnOrBeforeTime:sampleIndex:",  objc_msgSend(a9, "endTime"),  0x7FFFFFFFFFFFFFFFLL);
  uint64_t v89 = (uint64_t)[v87 dispatchQueue];
  unint64_t v90 = (unint64_t)[v88 dispatchQueue];
  v316 = (void *)v90;
  if (!(v89 | v90))
  {
    if (byte_1000E7D30)
    {
      int v92 = *__error();
      v93 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v93, OS_LOG_TYPE_ERROR))
      {
        id v318 = objc_msgSend(objc_msgSend(a3, "workflow"), "name");
        id v150 = (const __CFString *)objc_msgSend(objc_msgSend(a4, "signpost"), "name");
        if (v150) {
          id v151 = v150;
        }
        else {
          id v151 = @"<entire workflow>";
        }
        id v152 = [a5 name];
        id v153 = objc_msgSend(objc_msgSend(a9, "startTime"), "debugDescription");
        id v154 = objc_msgSend(objc_msgSend(a9, "endTime"), "debugDescription");
        *(_DWORD *)buf = 138413826;
        *(void *)&uint8_t buf[4] = v318;
        *(_WORD *)&_BYTE buf[12] = 2112;
        *(void *)&buf[14] = v151;
        *(_WORD *)&buf[22] = 2112;
        id v356 = v152;
        *(_WORD *)__int16 v357 = 2048;
        *(void *)&v357[2] = a7;
        *(_WORD *)&v357[10] = 2112;
        *(void *)&v357[12] = v153;
        *(_WORD *)&v357[20] = 2048;
        *(void *)&v357[22] = a8;
        *(_WORD *)&v357[30] = 2112;
        uint64_t v358 = (uint64_t)v154;
        _os_log_error_impl( (void *)&_mh_execute_header,  v93,  OS_LOG_TYPE_ERROR,  "WR: %@: %@: diagnostic %@ reports this dispatch queue, but neither start %llu@%@ nor end %llu@%@ are on a dispatch queue",  buf,  0x48u);
      }

      *__error() = v92;
    }

    if (byte_1000E7D31 && dword_1000E74E0 <= 3)
    {
      int v317 = *__error();
      id v94 = objc_msgSend(objc_msgSend(a3, "workflow"), "name");
      unsigned int v95 = (const __CFString *)objc_msgSend(objc_msgSend(a4, "signpost"), "name");
      if (v95) {
        id v96 = v95;
      }
      else {
        id v96 = @"<entire workflow>";
      }
      id v97 = CFStringCreateWithFormat( kCFAllocatorDefault,  0,  @"WR: %@: %@: diagnostic %@ reports this dispatch queue, but neither start %llu@%@ nor end %llu@%@ are on a dispatch queue",  v94,  v96,  [a5 name],  a7,  objc_msgSend(objc_msgSend(a9, "startTime"), "debugDescription"),  a8,  objc_msgSend(objc_msgSend(a9, "endTime"), "debugDescription"));
      char v98 = v97;
      if (v97)
      {
        id v99 = (char *)CFStringGetCStringPtr(v97, 0x8000100u);
        if (v99)
        {
          id v100 = 0LL;
        }

        else
        {
          id v99 = (char *)calloc(0x400uLL, 1uLL);
          CFStringGetCString(v98, v99, 1024LL, 0x8000100u);
          id v100 = v99;
        }

        if (qword_1000E7D38) {
          uint64_t v134 = (FILE *)qword_1000E7D38;
        }
        else {
          uint64_t v134 = __stderrp;
        }
        fprintf(v134, "%s\n", v99);
        if (v100) {
          free(v100);
        }
        CFRelease(v98);
      }

      else
      {
        uint64_t v123 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v123, OS_LOG_TYPE_FAULT))
        {
          id v176 = objc_msgSend(objc_msgSend(a3, "workflow"), "name");
          uint64_t v177 = (const __CFString *)objc_msgSend(objc_msgSend(a4, "signpost"), "name");
          if (v177) {
            id v178 = v177;
          }
          else {
            id v178 = @"<entire workflow>";
          }
          id v179 = [a5 name];
          id v180 = objc_msgSend(objc_msgSend(a9, "startTime"), "debugDescription");
          id v181 = objc_msgSend(objc_msgSend(a9, "endTime"), "debugDescription");
          *(_DWORD *)buf = 138413826;
          *(void *)&uint8_t buf[4] = v176;
          *(_WORD *)&_BYTE buf[12] = 2112;
          *(void *)&buf[14] = v178;
          *(_WORD *)&buf[22] = 2112;
          id v356 = v179;
          *(_WORD *)__int16 v357 = 2048;
          *(void *)&v357[2] = a7;
          *(_WORD *)&v357[10] = 2112;
          *(void *)&v357[12] = v180;
          *(_WORD *)&v357[20] = 2048;
          *(void *)&v357[22] = a8;
          *(_WORD *)&v357[30] = 2112;
          uint64_t v358 = (uint64_t)v181;
          _os_log_fault_impl( (void *)&_mh_execute_header,  v123,  OS_LOG_TYPE_FAULT,  "Unable to format: WR: %@: %@: diagnostic %@ reports this dispatch queue, but neither start %llu@%@ nor end % llu@%@ are on a dispatch queue",  buf,  0x48u);
        }

        if (qword_1000E7D38) {
          __int16 v124 = (FILE *)qword_1000E7D38;
        }
        else {
          __int16 v124 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v124);
      }

      id v135 = __error();
      int v136 = v317;
      goto LABEL_284;
    }

    goto LABEL_332;
  }

  if (v89 == v90)
  {
LABEL_330:
    if (v89) {
      sub_10003C0EC(a1, a2, a6, (uint64_t)a9, (uint64_t)a10, v89);
    }
    goto LABEL_332;
  }

  else {
    unsigned int v91 = 0;
  }
  if (objc_msgSend(objc_msgSend(v88, "startTimestamp"), "le:", objc_msgSend(a9, "endTime")))
  {
    unsigned int v101 = objc_msgSend(objc_msgSend(v88, "endTimestamp"), "ge:", objc_msgSend(a9, "endTime"));
    if ((v91 & v101) == 1)
    {
      if (byte_1000E7D30)
      {
        int v102 = *__error();
        id v103 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v103, OS_LOG_TYPE_ERROR))
        {
          id v336 = objc_msgSend(objc_msgSend(a3, "workflow"), "name");
          uint64_t v207 = (const __CFString *)objc_msgSend(objc_msgSend(a4, "signpost"), "name");
          uint64_t v208 = @"<entire workflow>";
          if (v207) {
            uint64_t v208 = v207;
          }
          int v328 = v208;
          id v209 = [a5 name];
          id v210 = [(id)v89 debugDescription];
          id v211 = [v316 debugDescription];
          *(_DWORD *)buf = 138413314;
          *(void *)&uint8_t buf[4] = v336;
          *(_WORD *)&_BYTE buf[12] = 2112;
          *(void *)&buf[14] = v328;
          *(_WORD *)&buf[22] = 2112;
          id v356 = v209;
          *(_WORD *)__int16 v357 = 2112;
          *(void *)&v357[2] = v210;
          *(_WORD *)&v357[10] = 2112;
          *(void *)&v357[12] = v211;
          _os_log_error_impl( (void *)&_mh_execute_header,  v103,  OS_LOG_TYPE_ERROR,  "WR: %@: %@: diagnostic %@ reports this dispatch queue, but signpost starts on %@ and ends on %@, so not reporting",  buf,  0x34u);
        }

        *__error() = v102;
      }

      if (byte_1000E7D31 && dword_1000E74E0 <= 3)
      {
        int v332 = *__error();
        id v104 = objc_msgSend(objc_msgSend(a3, "workflow"), "name");
        id v105 = (const __CFString *)objc_msgSend(objc_msgSend(a4, "signpost"), "name");
        if (v105) {
          uint64_t v106 = v105;
        }
        else {
          uint64_t v106 = @"<entire workflow>";
        }
        id v107 = CFStringCreateWithFormat( kCFAllocatorDefault,  0,  @"WR: %@: %@: diagnostic %@ reports this dispatch queue, but signpost starts on %@ and ends on %@, so not reporting",  v104,  v106,  [a5 name],  objc_msgSend((id)v89, "debugDescription"),  objc_msgSend(v316, "debugDescription"));
        unint64_t v108 = v107;
        if (v107)
        {
          uint64_t v109 = (char *)CFStringGetCStringPtr(v107, 0x8000100u);
          if (v109)
          {
            uint64_t v110 = 0LL;
          }

          else
          {
            uint64_t v109 = (char *)calloc(0x400uLL, 1uLL);
            CFStringGetCString(v108, v109, 1024LL, 0x8000100u);
            uint64_t v110 = v109;
          }

          if (qword_1000E7D38) {
            uint64_t v173 = (FILE *)qword_1000E7D38;
          }
          else {
            uint64_t v173 = __stderrp;
          }
          fprintf(v173, "%s\n", v109);
          if (v110) {
            free(v110);
          }
LABEL_282:
          CFRelease(v108);
          goto LABEL_283;
        }

        double v161 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v161, OS_LOG_TYPE_FAULT))
        {
          id v287 = objc_msgSend(objc_msgSend(a3, "workflow"), "name");
          unsigned __int8 v288 = (const __CFString *)objc_msgSend(objc_msgSend(a4, "signpost"), "name");
          if (v288) {
            v289 = v288;
          }
          else {
            v289 = @"<entire workflow>";
          }
          id v290 = [a5 name];
          id v291 = [(id)v89 debugDescription];
          id v292 = [v316 debugDescription];
          *(_DWORD *)buf = 138413314;
          *(void *)&uint8_t buf[4] = v287;
          *(_WORD *)&_BYTE buf[12] = 2112;
          *(void *)&buf[14] = v289;
          *(_WORD *)&buf[22] = 2112;
          id v356 = v290;
          *(_WORD *)__int16 v357 = 2112;
          *(void *)&v357[2] = v291;
          *(_WORD *)&v357[10] = 2112;
          *(void *)&v357[12] = v292;
          _os_log_fault_impl( (void *)&_mh_execute_header,  v161,  OS_LOG_TYPE_FAULT,  "Unable to format: WR: %@: %@: diagnostic %@ reports this dispatch queue, but signpost starts on %@ and ends on %@, so not reporting",  buf,  0x34u);
        }

        if (qword_1000E7D38) {
          double v156 = (FILE *)qword_1000E7D38;
        }
        else {
          double v156 = __stderrp;
        }
        goto LABEL_244;
      }

      goto LABEL_332;
    }

    if ((v91 & 1) != 0) {
      goto LABEL_188;
    }
    if (v101)
    {
      if (byte_1000E7D30)
      {
        int v137 = *__error();
        int v138 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v138, OS_LOG_TYPE_DEBUG))
        {
          id v337 = objc_msgSend(objc_msgSend(a3, "workflow"), "name");
          int v293 = (const __CFString *)objc_msgSend(objc_msgSend(a4, "signpost"), "name");
          int v294 = @"<entire workflow>";
          if (v293) {
            int v294 = v293;
          }
          v330 = v294;
          id v295 = [a5 name];
          id v296 = [(id)v89 debugDescription];
          id v297 = [v316 debugDescription];
          *(_DWORD *)buf = 138413314;
          *(void *)&uint8_t buf[4] = v337;
          *(_WORD *)&_BYTE buf[12] = 2112;
          *(void *)&buf[14] = v330;
          *(_WORD *)&buf[22] = 2112;
          id v356 = v295;
          *(_WORD *)__int16 v357 = 2112;
          *(void *)&v357[2] = v296;
          *(_WORD *)&v357[10] = 2112;
          *(void *)&v357[12] = v297;
          _os_log_debug_impl( (void *)&_mh_execute_header,  v138,  OS_LOG_TYPE_DEBUG,  "WR: %@: %@: diagnostic %@ reports this dispatch queue, signpost starts on %@ and ends on %@, and end is at t he exact time, so using that",  buf,  0x34u);
        }

        *__error() = v137;
      }

      if (!byte_1000E7D31 || dword_1000E74E0 > 0)
      {
        uint64_t v89 = (uint64_t)v316;
        goto LABEL_330;
      }

      int v334 = *__error();
      id v139 = objc_msgSend(objc_msgSend(a3, "workflow"), "name");
      int v140 = (const __CFString *)objc_msgSend(objc_msgSend(a4, "signpost"), "name");
      if (v140) {
        int v141 = v140;
      }
      else {
        int v141 = @"<entire workflow>";
      }
      id v142 = CFStringCreateWithFormat( kCFAllocatorDefault,  0,  @"WR: %@: %@: diagnostic %@ reports this dispatch queue, signpost starts on %@ and ends on %@, and end is at the exact time, so using that",  v139,  v141,  [a5 name],  objc_msgSend((id)v89, "debugDescription"),  objc_msgSend(v316, "debugDescription"));
      id v143 = v142;
      if (v142)
      {
        id v144 = (char *)CFStringGetCStringPtr(v142, 0x8000100u);
        if (v144)
        {
          id v145 = 0LL;
        }

        else
        {
          id v144 = (char *)calloc(0x400uLL, 1uLL);
          CFStringGetCString(v143, v144, 1024LL, 0x8000100u);
          id v145 = v144;
        }

        if (qword_1000E7D38) {
          id v217 = (FILE *)qword_1000E7D38;
        }
        else {
          id v217 = __stderrp;
        }
        fprintf(v217, "%s\n", v144);
        if (v145) {
          free(v145);
        }
        CFRelease(v143);
      }

      else
      {
        uint64_t v205 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v205, OS_LOG_TYPE_FAULT))
        {
          id v298 = objc_msgSend(objc_msgSend(a3, "workflow"), "name");
          int v299 = (const __CFString *)objc_msgSend(objc_msgSend(a4, "signpost"), "name");
          if (v299) {
            int v300 = v299;
          }
          else {
            int v300 = @"<entire workflow>";
          }
          id v301 = [a5 name];
          id v302 = [(id)v89 debugDescription];
          id v303 = [v316 debugDescription];
          *(_DWORD *)buf = 138413314;
          *(void *)&uint8_t buf[4] = v298;
          *(_WORD *)&_BYTE buf[12] = 2112;
          *(void *)&buf[14] = v300;
          *(_WORD *)&buf[22] = 2112;
          id v356 = v301;
          *(_WORD *)__int16 v357 = 2112;
          *(void *)&v357[2] = v302;
          *(_WORD *)&v357[10] = 2112;
          *(void *)&v357[12] = v303;
          _os_log_fault_impl( (void *)&_mh_execute_header,  v205,  OS_LOG_TYPE_FAULT,  "Unable to format: WR: %@: %@: diagnostic %@ reports this dispatch queue, signpost starts on %@ and ends on % @, and end is at the exact time, so using that",  buf,  0x34u);
        }

        if (qword_1000E7D38) {
          id v206 = (FILE *)qword_1000E7D38;
        }
        else {
          id v206 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v206);
      }

      uint64_t v89 = (uint64_t)v316;
      goto LABEL_329;
    }
  }

  else if (v91)
  {
LABEL_188:
    if (byte_1000E7D30)
    {
      int v125 = *__error();
      int v126 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v126, OS_LOG_TYPE_DEBUG))
      {
        id v335 = objc_msgSend(objc_msgSend(a3, "workflow"), "name");
        BOOL v191 = (const __CFString *)objc_msgSend(objc_msgSend(a4, "signpost"), "name");
        int v192 = @"<entire workflow>";
        if (v191) {
          int v192 = v191;
        }
        unsigned int v327 = v192;
        id v193 = [a5 name];
        id v194 = [(id)v89 debugDescription];
        id v195 = [v316 debugDescription];
        *(_DWORD *)buf = 138413314;
        *(void *)&uint8_t buf[4] = v335;
        *(_WORD *)&_BYTE buf[12] = 2112;
        *(void *)&buf[14] = v327;
        *(_WORD *)&buf[22] = 2112;
        id v356 = v193;
        *(_WORD *)__int16 v357 = 2112;
        *(void *)&v357[2] = v194;
        *(_WORD *)&v357[10] = 2112;
        *(void *)&v357[12] = v195;
        _os_log_debug_impl( (void *)&_mh_execute_header,  v126,  OS_LOG_TYPE_DEBUG,  "WR: %@: %@: diagnostic %@ reports this dispatch queue, signpost starts on %@ and ends on %@, and start is at t he exact time, so using that",  buf,  0x34u);
      }

      *__error() = v125;
    }

    if (!byte_1000E7D31 || dword_1000E74E0 > 0) {
      goto LABEL_330;
    }
    int v334 = *__error();
    id v127 = objc_msgSend(objc_msgSend(a3, "workflow"), "name");
    xpc_object_t v128 = (const __CFString *)objc_msgSend(objc_msgSend(a4, "signpost"), "name");
    if (v128) {
      int v129 = v128;
    }
    else {
      int v129 = @"<entire workflow>";
    }
    v130 = CFStringCreateWithFormat( kCFAllocatorDefault,  0,  @"WR: %@: %@: diagnostic %@ reports this dispatch queue, signpost starts on %@ and ends on %@, and start is at the exact time, so using that",  v127,  v129,  [a5 name],  objc_msgSend((id)v89, "debugDescription"),  objc_msgSend(v316, "debugDescription"));
    id v131 = v130;
    if (v130)
    {
      id v132 = (char *)CFStringGetCStringPtr(v130, 0x8000100u);
      if (v132)
      {
        uint64_t v133 = 0LL;
      }

      else
      {
        id v132 = (char *)calloc(0x400uLL, 1uLL);
        CFStringGetCString(v131, v132, 1024LL, 0x8000100u);
        uint64_t v133 = v132;
      }

      if (qword_1000E7D38) {
        uint64_t v171 = (FILE *)qword_1000E7D38;
      }
      else {
        uint64_t v171 = __stderrp;
      }
      fprintf(v171, "%s\n", v132);
      if (v133) {
        free(v133);
      }
      CFRelease(v131);
    }

    else
    {
      double v148 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v148, OS_LOG_TYPE_FAULT))
      {
        id v329 = objc_msgSend(objc_msgSend(a3, "workflow"), "name");
        int v273 = (const __CFString *)objc_msgSend(objc_msgSend(a4, "signpost"), "name");
        if (v273) {
          v274 = v273;
        }
        else {
          v274 = @"<entire workflow>";
        }
        id v275 = [a5 name];
        id v276 = [(id)v89 debugDescription];
        id v277 = [v316 debugDescription];
        *(_DWORD *)buf = 138413314;
        *(void *)&uint8_t buf[4] = v329;
        *(_WORD *)&_BYTE buf[12] = 2112;
        *(void *)&buf[14] = v274;
        *(_WORD *)&buf[22] = 2112;
        id v356 = v275;
        *(_WORD *)__int16 v357 = 2112;
        *(void *)&v357[2] = v276;
        *(_WORD *)&v357[10] = 2112;
        *(void *)&v357[12] = v277;
        _os_log_fault_impl( (void *)&_mh_execute_header,  v148,  OS_LOG_TYPE_FAULT,  "Unable to format: WR: %@: %@: diagnostic %@ reports this dispatch queue, signpost starts on %@ and ends on %@, and start is at the exact time, so using that",  buf,  0x34u);
      }

      if (qword_1000E7D38) {
        id v149 = (FILE *)qword_1000E7D38;
      }
      else {
        id v149 = __stderrp;
      }
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v149);
    }

    if (byte_1000E7D30)
    {
      uint64_t v45 = *__error();
      id v46 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v46, OS_LOG_TYPE_INFO))
      {
        *(_WORD *)int v55 = 0;
        _os_log_impl((void *)&_mh_execute_header, v46, OS_LOG_TYPE_INFO, "Stopping sampling thread", v55, 2u);
      }

      *__error() = v45;
      if (byte_1000E7D31 && dword_1000E74E0 <= 1)
      {
        int v47 = *__error();
        uint64_t v48 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"Stopping sampling thread");
        int v49 = v48;
        if (v48)
        {
          uint64_t v50 = (char *)CFStringGetCStringPtr(v48, 0x8000100u);
          if (v50)
          {
            int v51 = 0LL;
          }

          else
          {
            uint64_t v50 = (char *)calloc(0x400uLL, 1uLL);
            CFStringGetCString(v49, v50, 1024LL, 0x8000100u);
            int v51 = v50;
          }

          if (qword_1000E7D38) {
            int v54 = (FILE *)qword_1000E7D38;
          }
          else {
            int v54 = __stderrp;
          }
          fprintf(v54, "%s\n", v50);
          if (v51) {
            free(v51);
          }
          CFRelease(v49);
        }

        else
        {
          id v52 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v52, OS_LOG_TYPE_FAULT)) {
            sub_100093034();
          }
          if (qword_1000E7D38) {
            unsigned __int8 v53 = (FILE *)qword_1000E7D38;
          }
          else {
            unsigned __int8 v53 = __stderrp;
          }
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v53);
        }

        *__error() = v47;
      }
    }

    pthread_join(self->_samplingThread, 0LL);
    dispatch_release((dispatch_object_t)self->_samplingStoppedSem);
    self->_samplingThread = 0LL;
    goto LABEL_132;
  }

  if (byte_1000E7D30)
  {
    id v10 = *__error();
    double v11 = (os_log_s *)sub_10002EFA0();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG)) {
      sub_100093008();
    }
    *__error() = v10;
  }

  if (byte_1000E7D31) {
    uint64_t v12 = dword_1000E74E0 <= 0;
  }
  else {
    uint64_t v12 = 0;
  }
  if (v12)
  {
    uint64_t v13 = *__error();
    uint64_t v14 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"No sampling thread to stop");
    uint64_t v15 = v14;
    if (v14)
    {
      id v16 = (char *)CFStringGetCStringPtr(v14, 0x8000100u);
      if (v16)
      {
        unint64_t v17 = 0LL;
      }

      else
      {
        id v16 = (char *)calloc(0x400uLL, 1uLL);
        CFStringGetCString(v15, v16, 1024LL, 0x8000100u);
        unint64_t v17 = v16;
      }

      if (qword_1000E7D38) {
        int v34 = (FILE *)qword_1000E7D38;
      }
      else {
        int v34 = __stderrp;
      }
      fprintf(v34, "%s\n", v16);
      if (v17) {
        free(v17);
      }
      CFRelease(v15);
    }

    else
    {
      BOOL v32 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v32, OS_LOG_TYPE_FAULT)) {
        sub_100092FDC();
      }
      if (qword_1000E7D38) {
        id v33 = (FILE *)qword_1000E7D38;
      }
      else {
        id v33 = __stderrp;
      }
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v33);
    }

    *__error() = v13;
  }

            uint64_t v13 = v17;
            goto LABEL_220;
          }

LABEL_329:
    *__error() = v334;
    goto LABEL_330;
  }

  if (byte_1000E7D30)
  {
    int v333 = *__error();
    __int128 v111 = (os_log_s *)sub_10002EFA0();
    if (os_log_type_enabled(v111, OS_LOG_TYPE_DEFAULT))
    {
      id v326 = objc_msgSend(objc_msgSend(a3, "workflow"), "name");
      __int128 v112 = (const __CFString *)objc_msgSend(objc_msgSend(a4, "signpost"), "name");
      if (v112) {
        __int128 v113 = v112;
      }
      else {
        __int128 v113 = @"<entire workflow>";
      }
      id v114 = [a5 name];
      id v115 = [(id)v89 debugDescription];
      id v116 = [v316 debugDescription];
      *(_DWORD *)buf = 138413314;
      *(void *)&uint8_t buf[4] = v326;
      *(_WORD *)&_BYTE buf[12] = 2112;
      *(void *)&buf[14] = v113;
      *(_WORD *)&buf[22] = 2112;
      id v356 = v114;
      *(_WORD *)__int16 v357 = 2112;
      *(void *)&v357[2] = v115;
      *(_WORD *)&v357[10] = 2112;
      *(void *)&v357[12] = v116;
      _os_log_impl( (void *)&_mh_execute_header,  v111,  OS_LOG_TYPE_DEFAULT,  "WR: %@: %@: diagnostic %@ reports this dispatch queue, but signpost starts on %@ and ends on %@, neither at the exact right time, so not reporting",  buf,  0x34u);
    }

    *__error() = v333;
  }

  if (byte_1000E7D31 && dword_1000E74E0 <= 2)
  {
    int v332 = *__error();
    id v117 = objc_msgSend(objc_msgSend(a3, "workflow"), "name");
    __int16 v118 = (const __CFString *)objc_msgSend(objc_msgSend(a4, "signpost"), "name");
    if (v118) {
      uint64_t v119 = v118;
    }
    else {
      uint64_t v119 = @"<entire workflow>";
    }
    __int16 v120 = CFStringCreateWithFormat( kCFAllocatorDefault,  0,  @"WR: %@: %@: diagnostic %@ reports this dispatch queue, but signpost starts on %@ and ends on %@, neither at the exact right time, so not reporting",  v117,  v119,  [a5 name],  objc_msgSend((id)v89, "debugDescription"),  objc_msgSend(v316, "debugDescription"));
    unint64_t v108 = v120;
    if (v120)
    {
      id v121 = (char *)CFStringGetCStringPtr(v120, 0x8000100u);
      if (v121)
      {
        __int16 v122 = 0LL;
      }

      else
      {
        id v121 = (char *)calloc(0x400uLL, 1uLL);
        CFStringGetCString(v108, v121, 1024LL, 0x8000100u);
        __int16 v122 = v121;
      }

      if (qword_1000E7D38) {
        uint64_t v172 = (FILE *)qword_1000E7D38;
      }
      else {
        uint64_t v172 = __stderrp;
      }
      fprintf(v172, "%s\n", v121);
      if (v122) {
        free(v122);
      }
      goto LABEL_282;
    }

    char v155 = (os_log_s *)sub_10002EFA0();
    if (os_log_type_enabled(v155, OS_LOG_TYPE_FAULT))
    {
      id v281 = objc_msgSend(objc_msgSend(a3, "workflow"), "name");
      v282 = (const __CFString *)objc_msgSend(objc_msgSend(a4, "signpost"), "name");
      if (v282) {
        v283 = v282;
      }
      else {
        v283 = @"<entire workflow>";
      }
      id v284 = [a5 name];
      id v285 = [(id)v89 debugDescription];
      id v286 = [v316 debugDescription];
      *(_DWORD *)buf = 138413314;
      *(void *)&uint8_t buf[4] = v281;
      *(_WORD *)&_BYTE buf[12] = 2112;
      *(void *)&buf[14] = v283;
      *(_WORD *)&buf[22] = 2112;
      id v356 = v284;
      *(_WORD *)__int16 v357 = 2112;
      *(void *)&v357[2] = v285;
      *(_WORD *)&v357[10] = 2112;
      *(void *)&v357[12] = v286;
      _os_log_fault_impl( (void *)&_mh_execute_header,  v155,  OS_LOG_TYPE_FAULT,  "Unable to format: WR: %@: %@: diagnostic %@ reports this dispatch queue, but signpost starts on %@ and ends on % @, neither at the exact right time, so not reporting",  buf,  0x34u);
    }

    if (qword_1000E7D38) {
      double v156 = (FILE *)qword_1000E7D38;
    }
    else {
      double v156 = __stderrp;
    }
LABEL_244:
    fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v156);
LABEL_283:
    id v135 = __error();
    int v136 = v332;
LABEL_284:
    *id v135 = v136;
  }

LABEL_332:
  id v218 = [a5 reportSpindumpForDispatchQueueWithLabel];
  v219 = v218;
  if (!v218) {
    return;
  }
  if ([v218 hasPrefix:@"^"]
    && [v219 hasSuffix:@"$"])
  {
    *(void *)v352 = 0LL;
    uint64_t v220 = -[NSRegularExpression initWithPattern:options:error:]( objc_alloc(&OBJC_CLASS___NSRegularExpression),  "initWithPattern:options:error:",  v219,  0LL,  v352);
    if (!v220)
    {
      if (byte_1000E7D30)
      {
        int v221 = *__error();
        id v222 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v222, OS_LOG_TYPE_ERROR))
        {
          id v266 = objc_msgSend(objc_msgSend(a3, "workflow"), "name");
          v267 = (const __CFString *)objc_msgSend(objc_msgSend(a4, "signpost"), "name");
          if (v267) {
            v268 = v267;
          }
          else {
            v268 = @"<entire workflow>";
          }
          id v269 = [a5 name];
          *(_DWORD *)buf = 138413314;
          *(void *)&uint8_t buf[4] = v266;
          *(_WORD *)&_BYTE buf[12] = 2112;
          *(void *)&buf[14] = v268;
          *(_WORD *)&buf[22] = 2112;
          id v356 = v269;
          *(_WORD *)__int16 v357 = 2112;
          *(void *)&v357[2] = v219;
          *(_WORD *)&v357[10] = 2112;
          *(void *)&v357[12] = *(void *)v352;
          _os_log_error_impl( (void *)&_mh_execute_header,  v222,  OS_LOG_TYPE_ERROR,  "WR: %@: %@: diagnostic %@ reports dispatch queue %@, but regex failed to compile: %@",  buf,  0x34u);
        }

        *__error() = v221;
      }

      if (byte_1000E7D31 && dword_1000E74E0 <= 3)
      {
        int v223 = *__error();
        id v224 = objc_msgSend(objc_msgSend(a3, "workflow"), "name");
        id v225 = (const __CFString *)objc_msgSend(objc_msgSend(a4, "signpost"), "name");
        id v226 = @"<entire workflow>";
        if (v225) {
          id v227 = v225;
        }
        else {
          id v227 = @"<entire workflow>";
        }
        id v228 = [a5 name];
        uint64_t v229 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"WR: %@: %@: diagnostic %@ reports dispatch queue %@, but regex failed to compile: %@",  v224,  v227,  v228,  v219,  *(void *)v352);
        uint64_t v230 = v229;
        if (v229)
        {
          id v231 = (char *)CFStringGetCStringPtr(v229, 0x8000100u);
          if (v231)
          {
            int v232 = 0LL;
          }

          else
          {
            id v231 = (char *)calloc(0x400uLL, 1uLL);
            CFStringGetCString(v230, v231, 1024LL, 0x8000100u);
            int v232 = v231;
          }

          if (qword_1000E7D38) {
            v259 = (FILE *)qword_1000E7D38;
          }
          else {
            v259 = __stderrp;
          }
          fprintf(v259, "%s\n", v231);
          if (v232) {
            free(v232);
          }
          CFRelease(v230);
        }

        else
        {
          v251 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v251, OS_LOG_TYPE_FAULT))
          {
            id v278 = objc_msgSend(objc_msgSend(a3, "workflow"), "name");
            v279 = (const __CFString *)objc_msgSend(objc_msgSend(a4, "signpost"), "name");
            if (v279) {
              id v226 = v279;
            }
            id v280 = [a5 name];
            *(_DWORD *)buf = 138413314;
            *(void *)&uint8_t buf[4] = v278;
            *(_WORD *)&_BYTE buf[12] = 2112;
            *(void *)&buf[14] = v226;
            *(_WORD *)&buf[22] = 2112;
            id v356 = v280;
            *(_WORD *)__int16 v357 = 2112;
            *(void *)&v357[2] = v219;
            *(_WORD *)&v357[10] = 2112;
            *(void *)&v357[12] = *(void *)v352;
            _os_log_fault_impl( (void *)&_mh_execute_header,  v251,  OS_LOG_TYPE_FAULT,  "Unable to format: WR: %@: %@: diagnostic %@ reports dispatch queue %@, but regex failed to compile: %@",  buf,  0x34u);
          }

          if (qword_1000E7D38) {
            int v252 = (FILE *)qword_1000E7D38;
          }
          else {
            int v252 = __stderrp;
          }
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v252);
        }

        *__error() = v223;
      }

      return;
    }
  }

  else
  {
    uint64_t v220 = 0LL;
  }

  uint64_t v346 = 0LL;
  int v347 = &v346;
  uint64_t v348 = 0x3052000000LL;
  __int128 v349 = sub_100037440;
  __int128 v350 = sub_100037450;
  uint64_t v351 = 0LL;
  id v233 = [a10 dispatchQueues];
  v339 = _NSConcreteStackBlock;
  uint64_t v340 = 3221225472LL;
  uint64_t v341 = (uint64_t)sub_10003C170;
  int v342 = &unk_1000D8E98;
  int v343 = v220;
  id v344 = v219;
  id v345 = &v346;
  [v233 enumerateKeysAndObjectsUsingBlock:&v339];
  id v234 = (void *)v347[5];
  if (v234)
  {
    memset(v352, 0, 64);
    id v235 = [v234 countByEnumeratingWithState:v352 objects:buf count:16];
    if (v235)
    {
      uint64_t v236 = **(void **)&v352[16];
      do
      {
        for (i = 0LL; i != v235; i = (char *)i + 1)
        {
          if (**(void **)&v352[16] != v236) {
            objc_enumerationMutation(v234);
          }
          sub_10003C0EC(a1, a2, a6, (uint64_t)a9, (uint64_t)a10, *(void *)(*(void *)&v352[8] + 8LL * (void)i));
        }

        id v235 = [v234 countByEnumeratingWithState:v352 objects:buf count:16];
      }

      while (v235);
    }
  }

  else
  {
    if (byte_1000E7D30)
    {
      int v238 = *__error();
      uint64_t v239 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v239, OS_LOG_TYPE_ERROR))
      {
        id v253 = objc_msgSend(objc_msgSend(a3, "workflow"), "name");
        int v254 = (const __CFString *)objc_msgSend(objc_msgSend(a4, "signpost"), "name");
        if (v254) {
          uint64_t v255 = v254;
        }
        else {
          uint64_t v255 = @"<entire workflow>";
        }
        id v256 = [a5 name];
        id v257 = [a10 name];
        unsigned int v258 = [a10 pid];
        *(_DWORD *)buf = 138413570;
        *(void *)&uint8_t buf[4] = v253;
        *(_WORD *)&_BYTE buf[12] = 2112;
        *(void *)&buf[14] = v255;
        *(_WORD *)&buf[22] = 2112;
        id v356 = v256;
        *(_WORD *)__int16 v357 = 2112;
        *(void *)&v357[2] = v219;
        *(_WORD *)&v357[10] = 2112;
        *(void *)&v357[12] = v257;
        *(_WORD *)&v357[20] = 1024;
        *(_DWORD *)&v357[22] = v258;
        _os_log_error_impl( (void *)&_mh_execute_header,  v239,  OS_LOG_TYPE_ERROR,  "WR: %@: %@: diagnostic %@ reports dispatch queue %@, but %@ [%d] has no such dispatch queue",  buf,  0x3Au);
      }

      *__error() = v238;
    }

    if (byte_1000E7D31 && dword_1000E74E0 <= 3)
    {
      int v240 = *__error();
      id v241 = objc_msgSend(objc_msgSend(a3, "workflow"), "name");
      v242 = (const __CFString *)objc_msgSend(objc_msgSend(a4, "signpost"), "name");
      if (v242) {
        int v243 = v242;
      }
      else {
        int v243 = @"<entire workflow>";
      }
      uint64_t v244 = CFStringCreateWithFormat( kCFAllocatorDefault,  0,  @"WR: %@: %@: diagnostic %@ reports dispatch queue %@, but %@ [%d] has no such dispatch queue",  v241,  v243,  [a5 name],  v219,  objc_msgSend(a10, "name"),  objc_msgSend(a10, "pid"));
      v245 = v244;
      if (v244)
      {
        v246 = (char *)CFStringGetCStringPtr(v244, 0x8000100u);
        if (v246)
        {
          v247 = 0LL;
        }

        else
        {
          v246 = (char *)calloc(0x400uLL, 1uLL);
          CFStringGetCString(v245, v246, 1024LL, 0x8000100u);
          v247 = v246;
        }

        if (qword_1000E7D38) {
          v250 = (FILE *)qword_1000E7D38;
        }
        else {
          v250 = __stderrp;
        }
        fprintf(v250, "%s\n", v246);
        if (v247) {
          free(v247);
        }
        CFRelease(v245);
      }

      else
      {
        v248 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v248, OS_LOG_TYPE_FAULT))
        {
          id v260 = objc_msgSend(objc_msgSend(a3, "workflow"), "name");
          v261 = (const __CFString *)objc_msgSend(objc_msgSend(a4, "signpost"), "name");
          if (v261) {
            v262 = v261;
          }
          else {
            v262 = @"<entire workflow>";
          }
          id v263 = [a5 name];
          id v264 = [a10 name];
          unsigned int v265 = [a10 pid];
          *(_DWORD *)buf = 138413570;
          *(void *)&uint8_t buf[4] = v260;
          *(_WORD *)&_BYTE buf[12] = 2112;
          *(void *)&buf[14] = v262;
          *(_WORD *)&buf[22] = 2112;
          id v356 = v263;
          *(_WORD *)__int16 v357 = 2112;
          *(void *)&v357[2] = v219;
          *(_WORD *)&v357[10] = 2112;
          *(void *)&v357[12] = v264;
          *(_WORD *)&v357[20] = 1024;
          *(_DWORD *)&v357[22] = v265;
          _os_log_fault_impl( (void *)&_mh_execute_header,  v248,  OS_LOG_TYPE_FAULT,  "Unable to format: WR: %@: %@: diagnostic %@ reports dispatch queue %@, but %@ [%d] has no such dispatch queue",  buf,  0x3Au);
        }

        if (qword_1000E7D38) {
          int v249 = (FILE *)qword_1000E7D38;
        }
        else {
          int v249 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v249);
      }

      *__error() = v240;
    }
  }

  _Block_object_dispose(&v346, 8);
}

void sub_10003BBD0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, char a35)
{
}

void sub_10003BC50(uint64_t a1, uint64_t a2, void *a3)
{
  v36[0] = 0LL;
  v36[1] = v36;
  v36[2] = 0x2020000000LL;
  char v37 = 0;
  uint64_t v30 = 0LL;
  uint64_t v31 = &v30;
  uint64_t v32 = 0x3052000000LL;
  id v33 = sub_100037440;
  int v34 = sub_100037450;
  uint64_t v35 = 0LL;
  uint64_t v24 = 0LL;
  __int128 v25 = &v24;
  uint64_t v26 = 0x3052000000LL;
  int v27 = sub_100037440;
  id v28 = sub_100037450;
  uint64_t v29 = 0LL;
  id v5 = [*(id *)(a1 + 32) startTime];
  id v6 = [*(id *)(a1 + 32) endTime];
  v14[0] = _NSConcreteStackBlock;
  v14[1] = 3221225472LL;
  v14[2] = sub_10003BEF0;
  v14[3] = &unk_1000D8E48;
  __int128 v15 = *(_OWORD *)(a1 + 40);
  int v21 = &v30;
  id v22 = &v24;
  __int128 v23 = v36;
  uint64_t v16 = *(void *)(a1 + 32);
  __int128 v17 = *(_OWORD *)(a1 + 56);
  uint64_t v18 = *(void *)(a1 + 72);
  double v19 = a3;
  __int128 v20 = *(_OWORD *)(a1 + 80);
  [a3 enumerateThreadStatesBetweenStartTime:v5 startSampleIndex:0x7FFFFFFFFFFFFFFFLL endTime:v6 endSampleIndex:0x7FFFFFFFFFFFFFFFLL reverseOrder:0 block:v14];
  id v7 = (void *)v31[5];
  if (v7 && v25[5])
  {
    if (objc_msgSend( objc_msgSend(v7, "startTimestamp"),  "gt:",  objc_msgSend(*(id *)(a1 + 32), "startTime"))) {
      id v8 = [(id)v31[5] startTimestamp];
    }
    else {
      id v8 = [*(id *)(a1 + 32) startTime];
    }
    id v9 = v8;
    if (objc_msgSend( objc_msgSend((id)v31[5], "endTimestamp"),  "lt:",  objc_msgSend(*(id *)(a1 + 32), "endTime"))) {
      id v10 = [(id)v31[5] endTimestamp];
    }
    else {
      id v10 = [*(id *)(a1 + 32) endTime];
    }
    id v11 = v10;
    if (v9 == [*(id *)(a1 + 32) startTime] && v11 == objc_msgSend(*(id *)(a1 + 32), "endTime")) {
      id v12 = *(id *)(a1 + 32);
    }
    else {
      id v12 = +[SATimeRange timeRangeStart:end:](&OBJC_CLASS___SATimeRange, "timeRangeStart:end:", v9, v11);
    }
    uint64_t v13 = -[SPWRReport initWithReportReason:reportedSignpostTracker:task:timeRange:thread:dispatchQueue:]( objc_alloc(&OBJC_CLASS___SPWRReport),  "initWithReportReason:reportedSignpostTracker:task:timeRange:thread:dispatchQueue:",  *(void *)(a1 + 56),  *(void *)(a1 + 64),  *(void *)(a1 + 72),  v12,  a3,  0LL);
    [*(id *)(a1 + 80) addObject:v13];
  }

  _Block_object_dispose(&v24, 8);
  _Block_object_dispose(&v30, 8);
  _Block_object_dispose(v36, 8);
}

void sub_10003BEB0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, ...)
{
}

void sub_10003BEF0(uint64_t a1, void *a2)
{
  id v4 = [a2 name];
  if (v4)
  {
    id v5 = v4;
    id v6 = *(void **)(a1 + 32);
    if (!v6) {
      goto LABEL_25;
    }
    if (objc_msgSend(v6, "numberOfMatchesInString:options:range:", v4, 4, 0, objc_msgSend(v4, "length")))
    {
LABEL_6:
      *(_BYTE *)(*(void *)(*(void *)(a1 + 96) + 8LL) + 24LL) = 1;
      uint64_t v7 = *(void *)(*(void *)(a1 + 104) + 8LL);
      if (!*(void *)(v7 + 40)) {
        *(void *)(v7 + 40) = a2;
      }
      *(void *)(*(void *)(*(void *)(a1 + 112) + 8LL) + 40LL) = a2;
      return;
    }

    if (!*(void *)(a1 + 32))
    {
LABEL_25:
    }
  }

  *(_BYTE *)(*(void *)(*(void *)(a1 + 120) + 8LL) + 24LL) = 1;
  id v8 = *(void **)(*(void *)(*(void *)(a1 + 104) + 8LL) + 40LL);
  if (v8 && *(void *)(*(void *)(*(void *)(a1 + 112) + 8LL) + 40LL))
  {
    if (objc_msgSend( objc_msgSend(v8, "startTimestamp"),  "gt:",  objc_msgSend(*(id *)(a1 + 48), "startTime"))) {
      id v9 = [*(id *)(*(void *)(*(void *)(a1 + 104) + 8) + 40) startTimestamp];
    }
    else {
      id v9 = [*(id *)(a1 + 48) startTime];
    }
    id v10 = v9;
    if (objc_msgSend( objc_msgSend(*(id *)(*(void *)(*(void *)(a1 + 104) + 8) + 40), "endTimestamp"),  "lt:",  objc_msgSend(*(id *)(a1 + 48), "endTime"))) {
      id v11 = [*(id *)(*(void *)(*(void *)(a1 + 104) + 8) + 40) endTimestamp];
    }
    else {
      id v11 = [*(id *)(a1 + 48) endTime];
    }
    id v12 = v11;
    if (v10 == [*(id *)(a1 + 48) startTime] && v12 == objc_msgSend(*(id *)(a1 + 48), "endTime")) {
      id v13 = *(id *)(a1 + 48);
    }
    else {
      id v13 = +[SATimeRange timeRangeStart:end:](&OBJC_CLASS___SATimeRange, "timeRangeStart:end:", v10, v12);
    }
    uint64_t v14 = -[SPWRReport initWithReportReason:reportedSignpostTracker:task:timeRange:thread:dispatchQueue:]( objc_alloc(&OBJC_CLASS___SPWRReport),  "initWithReportReason:reportedSignpostTracker:task:timeRange:thread:dispatchQueue:",  *(void *)(a1 + 56),  *(void *)(a1 + 64),  *(void *)(a1 + 72),  v13,  *(void *)(a1 + 80),  0LL);
    [*(id *)(a1 + 88) addObject:v14];
  }

void sub_10003C0EC(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v7 = -[SPWRReport initWithReportReason:reportedSignpostTracker:task:timeRange:thread:dispatchQueue:]( objc_alloc(&OBJC_CLASS___SPWRReport),  "initWithReportReason:reportedSignpostTracker:task:timeRange:thread:dispatchQueue:",  a2,  a3,  a5,  a4,  0LL,  a6);
  [a1 addObject:v7];
}

NSMutableArray *sub_10003C170(void *a1, uint64_t a2, void *a3)
{
  id result = (NSMutableArray *)[a3 dispatchQueueLabel];
  if (result)
  {
    id v6 = result;
    uint64_t v7 = (void *)a1[4];
    if (v7)
    {
      id result = (NSMutableArray *)objc_msgSend( v7,  "numberOfMatchesInString:options:range:",  result,  4,  0,  -[NSMutableArray length](result, "length"));
      if (result)
      {
LABEL_6:
        id v8 = *(void **)(*(void *)(a1[6] + 8LL) + 40LL);
        if (v8) {
          return (NSMutableArray *)[v8 addObject:a3];
        }
        id result = -[NSMutableArray initWithObjects:]( objc_alloc(&OBJC_CLASS___NSMutableArray),  "initWithObjects:",  a3,  0LL);
        *(void *)(*(void *)(a1[6] + 8LL) + 40LL) = result;
        return result;
      }

      if (a1[4]) {
        return result;
      }
    }

    id result = (NSMutableArray *)-[NSMutableArray isEqualToString:](v6, "isEqualToString:", a1[5]);
    if (!(_DWORD)result) {
      return result;
    }
    goto LABEL_6;
  }

  return result;
}

id sub_10003C240(uint64_t a1, void *a2)
{
  id result = objc_msgSend(objc_msgSend(a2, "name"), "isEqualToString:", *(void *)(a1 + 32));
  if ((_DWORD)result) {
    return [*(id *)(a1 + 40) addObject:a2];
  }
  return result;
}

uint64_t sub_10003C288(void *a1, uint64_t a2)
{
  uint64_t v4 = objc_opt_class(&OBJC_CLASS___NSNumber);
  if ((objc_opt_isKindOfClass(a1, v4) & 1) != 0)
  {
    [a1 doubleValue];
    BOOL v6 = v5 < 0.0;
    if (v5 == 0.0)
    {
      uint64_t result = +[NSDecimalNumber zero](&OBJC_CLASS___NSDecimalNumber, "zero");
    }

    else
    {
      double v11 = v5;
      double v12 = -v5;
      if (!v6) {
        double v12 = v11;
      }
      unsigned int v13 = vcvtpd_s64_f64(log10(v12));
      uint64_t v14 = llround(v11 * __exp10((double)(int)(3 - v13)));
      if (v14 >= 0) {
        uint64_t v15 = v14;
      }
      else {
        uint64_t v15 = -v14;
      }
      uint64_t result = +[NSDecimalNumber decimalNumberWithMantissa:exponent:isNegative:]( &OBJC_CLASS___NSDecimalNumber,  "decimalNumberWithMantissa:exponent:isNegative:",  v15,  (__int16)(v13 - 3),  (unint64_t)v14 >> 63);
    }
  }

  else
  {
    uint64_t v8 = objc_opt_class(&OBJC_CLASS___NSMutableDictionary);
    if ((objc_opt_isKindOfClass(a1, v8) & 1) != 0) {
      return sub_100037FC4(a1);
    }
    uint64_t v9 = objc_opt_class(&OBJC_CLASS___NSMutableArray);
    if ((objc_opt_isKindOfClass(a1, v9) & 1) != 0) {
      return sub_100037FC4(a1);
    }
    uint64_t v10 = objc_opt_class(&OBJC_CLASS___NSMutableSet);
    uint64_t result = objc_opt_isKindOfClass(a1, v10);
    if ((result & 1) != 0) {
      return sub_100037FC4(a1);
    }
  }

  return result;
}

id sub_10003C3D4(uint64_t a1, uint64_t a2)
{
  return [*(id *)(a1 + 32) setObject:a2 forKeyedSubscript:*(void *)(a1 + 40)];
}

id sub_10003C3E4(uint64_t a1, uint64_t a2)
{
  return [*(id *)(a1 + 32) setObject:a2 atIndexedSubscript:*(void *)(a1 + 40)];
}

id sub_10003C3F4(uint64_t a1, uint64_t a2)
{
  return [*(id *)(a1 + 32) addObject:a2];
}

void sub_10003C428( void *a1, os_log_s *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
}

void sub_10003C438(void *a1, os_log_s *a2, uint64_t a3, const char *a4, uint8_t *a5)
{
}

void sub_10003C444( void *a1, os_log_s *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
}

uint64_t sub_10003C454(uint64_t result, uint64_t a2, int a3, float a4)
{
  *(float *)a2 = a4;
  *(void *)(a2 + 4) = result;
  *(_WORD *)(a2 + 12) = 1024;
  *(_DWORD *)(a2 + 14) = a3;
  *(_WORD *)(a2 + 1_Block_object_dispose((const void *)(v17 - 80), 8) = 2080;
  return result;
}

uint64_t sub_10003C474(uint64_t result, uint64_t a2, uint64_t a3, float a4)
{
  *(float *)a3 = a4;
  *(void *)(a3 + 4) = result;
  *(_WORD *)(a3 + 12) = 2112;
  *(void *)(a3 + 14) = a2;
  return result;
}

void sub_10003C48C(void *a1, os_log_s *a2, uint64_t a3, const char *a4, uint8_t *a5)
{
}

  ;
}

void sub_10003C4A4(void *a1, os_log_s *a2, uint64_t a3, const char *a4, uint8_t *a5)
{
}

  ;
}

  ;
}

  ;
}

void sub_10003C4D4( void *a1, os_log_s *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
}

  ;
}

void sub_10003C4FC(uint64_t a1@<X8>)
{
  *(void *)(v1 - _Block_object_dispose((const void *)(v17 - 80), 8) = a1;
}

void sub_10003C508(void *a1@<X0>, const char *a2@<X3>, uint8_t *a3@<X4>, os_log_s *a4@<X8>)
{
}

void sub_10003C518(void *a1@<X0>, const char *a2@<X3>, uint8_t *a3@<X4>, os_log_s *a4@<X8>)
{
}

  ;
}

void sub_10003C540( unint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, const char *a7, const char *a8, double a9, double a10, uint64_t a11)
{
  unint64_t v17 = HIDWORD(a1);
  memset(buffer, 0, 128);
  proc_name(a1, buffer, 0x80u);
  if ((a3 & 0x80000000) == 0)
  {
    if (byte_1000E7D30)
    {
      int v18 = *__error();
      double v19 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v19, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)buf = 136449282;
        *(void *)&uint8_t buf[4] = sub_10002EF3C(a3);
        *(_WORD *)&_BYTE buf[12] = 1024;
        *(_DWORD *)&buf[14] = a3;
        *(_WORD *)&buf[18] = 2082;
        *(void *)&buf[20] = buffer;
        *(_WORD *)&buf[28] = 1024;
        *(_DWORD *)&buf[30] = a1;
        *(_WORD *)&buf[34] = 1024;
        *(_DWORD *)&buf[36] = v17;
        *(_WORD *)&buf[40] = 2048;
        *(void *)&buf[42] = a4;
        *(_WORD *)&buf[50] = 2048;
        *(double *)&buf[52] = a9;
        *(_WORD *)&buf[60] = 2048;
        *(double *)&buf[62] = a10;
        *(_WORD *)&buf[70] = 2048;
        *(void *)&buf[72] = a5;
        *(_WORD *)&buf[80] = 2080;
        *(void *)&buf[82] = a6;
        *(_WORD *)&buf[90] = 2080;
        *(void *)&buf[92] = a7;
        __int16 v337 = 2080;
        v338 = a8;
        __int16 v339 = 1024;
        BOOL v340 = a11 != 0;
        _os_log_impl( (void *)&_mh_execute_header,  v19,  OS_LOG_TYPE_INFO,  "%{public}s [%d]: generate spindump: requested by %{public}s [%d] uid %d, thread:%#llx duration:%.3f interval:% .6f flags:%#llx reason:%s signature:%s filename:%s callback:%d",  buf,  0x74u);
      }

      *__error() = v18;
    }

    if (byte_1000E7D31) {
      BOOL v20 = dword_1000E74E0 <= 1;
    }
    else {
      BOOL v20 = 0;
    }
    if (!v20) {
      goto LABEL_39;
    }
    int v21 = *__error();
    id v22 = sub_10002EF3C(a3);
    __int128 v23 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"%s [%d]: generate spindump: requested by %s [%d] uid %d, thread:%#llx duration:%.3f interval:%.6f flags:%#llx reason:%s signature:%s filename:%s callback:%d",  v22,  a3,  buffer,  a1,  v17,  a4,  *(void *)&a9,  *(void *)&a10,  a5,  a6,  a7,  a8,  a11 != 0);
    if (!v23)
    {
      uint64_t v24 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v24, OS_LOG_TYPE_FAULT))
      {
        __int128 v25 = sub_10002EF3C(a3);
        *(_DWORD *)buf = 136318210;
        *(void *)&uint8_t buf[4] = v25;
        *(_WORD *)&_BYTE buf[12] = 1024;
        *(_DWORD *)&buf[14] = a3;
        *(_WORD *)&buf[18] = 2080;
        *(void *)&buf[20] = buffer;
        *(_WORD *)&buf[28] = 1024;
        *(_DWORD *)&buf[30] = a1;
        *(_WORD *)&buf[34] = 1024;
        *(_DWORD *)&buf[36] = v17;
        *(_WORD *)&buf[40] = 2048;
        *(void *)&buf[42] = a4;
        *(_WORD *)&buf[50] = 2048;
        *(double *)&buf[52] = a9;
        *(_WORD *)&buf[60] = 2048;
        *(double *)&buf[62] = a10;
        *(_WORD *)&buf[70] = 2048;
        *(void *)&buf[72] = a5;
        *(_WORD *)&buf[80] = 2080;
        *(void *)&buf[82] = a6;
        *(_WORD *)&buf[90] = 2080;
        *(void *)&buf[92] = a7;
        __int16 v337 = 2080;
        v338 = a8;
        __int16 v339 = 1024;
        BOOL v340 = a11 != 0;
        uint64_t v26 = "Unable to format: %s [%d]: generate spindump: requested by %s [%d] uid %d, thread:%#llx duration:%.3f inte"
              "rval:%.6f flags:%#llx reason:%s signature:%s filename:%s callback:%d";
        int v27 = v24;
        uint32_t v28 = 116;
LABEL_250:
        _os_log_fault_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_FAULT, v26, buf, v28);
        goto LABEL_34;
      }

      goto LABEL_34;
    }

    goto LABEL_24;
  }

  if (byte_1000E7D30)
  {
    int v29 = *__error();
    uint64_t v30 = (os_log_s *)sub_10002EFA0();
    if (os_log_type_enabled(v30, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 136448770;
      *(void *)&uint8_t buf[4] = buffer;
      *(_WORD *)&_BYTE buf[12] = 1024;
      *(_DWORD *)&buf[14] = a1;
      *(_WORD *)&buf[18] = 1024;
      *(_DWORD *)&buf[20] = v17;
      *(_WORD *)&_BYTE buf[24] = 2048;
      *(void *)&buf[26] = a4;
      *(_WORD *)&buf[34] = 2048;
      *(double *)&buf[36] = a9;
      *(_WORD *)&buf[44] = 2048;
      *(double *)&buf[46] = a10;
      *(_WORD *)&buf[54] = 2048;
      *(void *)&buf[56] = a5;
      *(_WORD *)&buf[64] = 2080;
      *(void *)&buf[66] = a6;
      *(_WORD *)&buf[74] = 2080;
      *(void *)&buf[76] = a7;
      *(_WORD *)&buf[84] = 2080;
      *(void *)&buf[86] = a8;
      *(_WORD *)&buf[94] = 1024;
      *(_DWORD *)&buf[96] = a11 != 0;
      _os_log_impl( (void *)&_mh_execute_header,  v30,  OS_LOG_TYPE_INFO,  "generate spindump: requested by %{public}s [%d] uid %d, thread:%#llx duration:%.3f interval:%.6f flags:%#llx rea son:%s signature:%s filename:%s callback:%d",  buf,  0x64u);
    }

    *__error() = v29;
  }

  if (byte_1000E7D31) {
    BOOL v31 = dword_1000E74E0 <= 1;
  }
  else {
    BOOL v31 = 0;
  }
  if (v31)
  {
    int v21 = *__error();
    __int128 v23 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"generate spindump: requested by %s [%d] uid %d, thread:%#llx duration:%.3f interval:%.6f flags:%#llx reason:%s signature:%s filename:%s callback:%d",  buffer,  a1,  v17,  a4,  *(void *)&a9,  *(void *)&a10,  a5,  a6,  a7,  a8,  a11 != 0);
    if (!v23)
    {
      char v37 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v37, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)buf = 136317698;
        *(void *)&uint8_t buf[4] = buffer;
        *(_WORD *)&_BYTE buf[12] = 1024;
        *(_DWORD *)&buf[14] = a1;
        *(_WORD *)&buf[18] = 1024;
        *(_DWORD *)&buf[20] = v17;
        *(_WORD *)&_BYTE buf[24] = 2048;
        *(void *)&buf[26] = a4;
        *(_WORD *)&buf[34] = 2048;
        *(double *)&buf[36] = a9;
        *(_WORD *)&buf[44] = 2048;
        *(double *)&buf[46] = a10;
        *(_WORD *)&buf[54] = 2048;
        *(void *)&buf[56] = a5;
        *(_WORD *)&buf[64] = 2080;
        *(void *)&buf[66] = a6;
        *(_WORD *)&buf[74] = 2080;
        *(void *)&buf[76] = a7;
        *(_WORD *)&buf[84] = 2080;
        *(void *)&buf[86] = a8;
        *(_WORD *)&buf[94] = 1024;
        *(_DWORD *)&buf[96] = a11 != 0;
        uint64_t v26 = "Unable to format: generate spindump: requested by %s [%d] uid %d, thread:%#llx duration:%.3f interval:%.6f"
              " flags:%#llx reason:%s signature:%s filename:%s callback:%d";
        int v27 = v37;
        uint32_t v28 = 100;
        goto LABEL_250;
      }

LABEL_34:
      if (qword_1000E7D38) {
        id v38 = (FILE *)qword_1000E7D38;
      }
      else {
        id v38 = __stderrp;
      }
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v38);
LABEL_38:
      *__error() = v21;
      goto LABEL_39;
    }

LABEL_24:
    uint64_t v32 = v23;
    CStringPtr = CFStringGetCStringPtr(v23, 0x8000100u);
    if (CStringPtr)
    {
      int v34 = (char *)CStringPtr;
      uint64_t v35 = 0LL;
    }

    else
    {
      int v34 = (char *)calloc(0x400uLL, 1uLL);
      CFStringGetCString(v32, v34, 1024LL, 0x8000100u);
      uint64_t v35 = v34;
    }

    if (qword_1000E7D38) {
      int v36 = (FILE *)qword_1000E7D38;
    }
    else {
      int v36 = __stderrp;
    }
    fprintf(v36, "%s\n", v34);
    if (v35) {
      free(v35);
    }
    CFRelease(v32);
    goto LABEL_38;
  }

    double v11 = v6;
    CStringPtr = CFStringGetCStringPtr(v6, 0x8000100u);
    if (CStringPtr)
    {
      unsigned int v13 = (char *)CStringPtr;
      uint64_t v14 = 0LL;
    }

    else
    {
      unsigned int v13 = (char *)calloc(0x400uLL, 1uLL);
      CFStringGetCString(v11, v13, 1024LL, 0x8000100u);
      uint64_t v14 = v13;
    }

    if (qword_1000E7D38) {
      uint64_t v15 = (FILE *)qword_1000E7D38;
    }
    else {
      uint64_t v15 = __stderrp;
    }
    fprintf(v15, "%s\n", v13);
    if (v14) {
      free(v14);
    }
    CFRelease(v11);
    goto LABEL_39;
  }

  return result;
}

  ;
}

  ;
}

  ;
}

    double v11 = v6;
    CStringPtr = CFStringGetCStringPtr(v6, 0x8000100u);
    if (CStringPtr)
    {
      unsigned int v13 = (char *)CStringPtr;
      uint64_t v14 = 0LL;
    }

    else
    {
      unsigned int v13 = (char *)calloc(0x400uLL, 1uLL);
      CFStringGetCString(v11, v13, 1024LL, 0x8000100u);
      uint64_t v14 = v13;
    }

    if (qword_1000E7D38) {
      uint64_t v15 = (FILE *)qword_1000E7D38;
    }
    else {
      uint64_t v15 = __stderrp;
    }
    fprintf(v15, "%s\n", v13);
    if (v14) {
      free(v14);
    }
    CFRelease(v11);
    goto LABEL_39;
  }

    uint64_t v14 = v9;
    CStringPtr = CFStringGetCStringPtr(v9, 0x8000100u);
    if (CStringPtr)
    {
      uint64_t v16 = (char *)CStringPtr;
      unint64_t v17 = 0LL;
    }

    else
    {
      uint64_t v16 = (char *)calloc(0x400uLL, 1uLL);
      CFStringGetCString(v14, v16, 1024LL, 0x8000100u);
      unint64_t v17 = v16;
    }

    if (qword_1000E7D38) {
      int v18 = (FILE *)qword_1000E7D38;
    }
    else {
      int v18 = __stderrp;
    }
    fprintf(v18, "%s\n", v16);
    if (v17) {
      free(v17);
    }
    CFRelease(v14);
    goto LABEL_39;
  }

    double v12 = v7;
    CStringPtr = CFStringGetCStringPtr(v7, 0x8000100u);
    if (CStringPtr)
    {
      uint64_t v14 = (char *)CStringPtr;
      uint64_t v15 = 0LL;
    }

    else
    {
      uint64_t v14 = (char *)calloc(0x400uLL, 1uLL);
      CFStringGetCString(v12, v14, 1024LL, 0x8000100u);
      uint64_t v15 = v14;
    }

    if (qword_1000E7D38) {
      uint64_t v16 = (FILE *)qword_1000E7D38;
    }
    else {
      uint64_t v16 = __stderrp;
    }
    fprintf(v16, "%s\n", v14);
    if (v15) {
      free(v15);
    }
    CFRelease(v12);
    goto LABEL_39;
  }

  return [*v1 stopSamplingWithReason:2];
}

LABEL_39:
  if (a9 == 0.0) {
    a9 = 10.0;
  }
  if (a10 == 0.0) {
    double v39 = 0.01;
  }
  else {
    double v39 = a10;
  }
  memset(v335, 0, sizeof(v335));
  time_t v331 = time(0LL);
  localtime_r(&v331, &v332);
  strftime((char *)v335, 0x20uLL, "%Y-%m-%d-%T", &v332);
  id v40 = (char *)calloc(1uLL, 0x400uLL);
  uint64_t v41 = v40;
  if (!a8 || !*a8) {
    a8 = buffer;
  }
  if (snprintf( v40,  0x400uLL,  "/var/mobile/Library/Logs/CrashReporter/%s.%s.spindump.txt",  a8,  (const char *)v335) < 0x400)
  {
    int v42 = (char *)calloc(1uLL, 0x400uLL);
    if (dirname_r(v41, v42))
    {
      uint64_t v43 = (char *)calloc(1uLL, 0x400uLL);
      if (basename_r(v41, v43))
      {
        int v44 = realpath_DARWIN_EXTSN(v42, 0LL);
        if (v44)
        {
          uint64_t v45 = v44;
          id v46 = realpath_DARWIN_EXTSN("/var/mobile/Library/Logs/CrashReporter", 0LL);
          if (v46)
          {
            int v51 = v46;
            if (strcmp("/", v46))
            {
              int v315 = v43;
              if ((a3 & 0x80000000) != 0)
              {
                if (byte_1000E7D30)
                {
                  int v72 = *__error();
                  id v73 = (os_log_s *)sub_10002EFA0();
                  if (os_log_type_enabled(v73, OS_LOG_TYPE_DEBUG))
                  {
                    *(_DWORD *)buf = 136315906;
                    *(void *)&uint8_t buf[4] = v42;
                    *(_WORD *)&_BYTE buf[12] = 2080;
                    *(void *)&buf[14] = v315;
                    *(_WORD *)&buf[22] = 2080;
                    *(void *)&_BYTE buf[24] = v45;
                    *(_WORD *)&buf[32] = 2080;
                    *(void *)&buf[34] = v51;
                    _os_log_debug_impl( (void *)&_mh_execute_header,  v73,  OS_LOG_TYPE_DEBUG,  "dir %s, fullfilename %s, realDir %s, expectedRealDir %s",  buf,  0x2Au);
                  }

                  *__error() = v72;
                }

                int v54 = v315;
                if (byte_1000E7D31 && dword_1000E74E0 <= 0)
                {
                  int v74 = *__error();
                  CFStringRef v75 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"dir %s, fullfilename %s, realDir %s, expectedRealDir %s",  v42,  v315,  v45,  v51);
                  if (!v75)
                  {
                    id v139 = (os_log_s *)sub_10002EFA0();
                    if (os_log_type_enabled(v139, OS_LOG_TYPE_FAULT))
                    {
                      *(_DWORD *)buf = 136315906;
                      *(void *)&uint8_t buf[4] = v42;
                      *(_WORD *)&_BYTE buf[12] = 2080;
                      *(void *)&buf[14] = v315;
                      *(_WORD *)&buf[22] = 2080;
                      *(void *)&_BYTE buf[24] = v45;
                      *(_WORD *)&buf[32] = 2080;
                      *(void *)&buf[34] = v51;
                      _os_log_fault_impl( (void *)&_mh_execute_header,  v139,  OS_LOG_TYPE_FAULT,  "Unable to format: dir %s, fullfilename %s, realDir %s, expectedRealDir %s",  buf,  0x2Au);
                    }

                    if (qword_1000E7D38) {
                      int v140 = (FILE *)qword_1000E7D38;
                    }
                    else {
                      int v140 = __stderrp;
                    }
                    fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v140);
                    goto LABEL_116;
                  }

                  __int128 v57 = v75;
                  int v314 = v74;
                  goto LABEL_86;
                }
              }

              else
              {
                if (byte_1000E7D30)
                {
                  int v52 = *__error();
                  unsigned __int8 v53 = (os_log_s *)sub_10002EFA0();
                  if (os_log_type_enabled(v53, OS_LOG_TYPE_DEBUG))
                  {
                    double v156 = sub_10002EF3C(a3);
                    *(_DWORD *)buf = 136447490;
                    *(void *)&uint8_t buf[4] = v156;
                    *(_WORD *)&_BYTE buf[12] = 1024;
                    *(_DWORD *)&buf[14] = a3;
                    *(_WORD *)&buf[18] = 2080;
                    *(void *)&buf[20] = v42;
                    *(_WORD *)&buf[28] = 2080;
                    *(void *)&buf[30] = v315;
                    *(_WORD *)&buf[38] = 2080;
                    *(void *)&buf[40] = v45;
                    *(_WORD *)&buf[48] = 2080;
                    *(void *)&buf[50] = v51;
                    _os_log_debug_impl( (void *)&_mh_execute_header,  v53,  OS_LOG_TYPE_DEBUG,  "%{public}s [%d]: dir %s, fullfilename %s, realDir %s, expectedRealDir %s",  buf,  0x3Au);
                  }

                  *__error() = v52;
                }

                int v54 = v315;
                if (byte_1000E7D31 && dword_1000E74E0 <= 0)
                {
                  int v314 = *__error();
                  int v55 = sub_10002EF3C(a3);
                  CFStringRef v56 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"%s [%d]: dir %s, fullfilename %s, realDir %s, expectedRealDir %s",  v55,  a3,  v42,  v315,  v45,  v51);
                  if (!v56)
                  {
                    uint64_t v89 = (os_log_s *)sub_10002EFA0();
                    if (os_log_type_enabled(v89, OS_LOG_TYPE_FAULT))
                    {
                      int v164 = sub_10002EF3C(a3);
                      *(_DWORD *)buf = 136316418;
                      *(void *)&uint8_t buf[4] = v164;
                      *(_WORD *)&_BYTE buf[12] = 1024;
                      *(_DWORD *)&buf[14] = a3;
                      *(_WORD *)&buf[18] = 2080;
                      *(void *)&buf[20] = v42;
                      *(_WORD *)&buf[28] = 2080;
                      *(void *)&buf[30] = v315;
                      *(_WORD *)&buf[38] = 2080;
                      *(void *)&buf[40] = v45;
                      *(_WORD *)&buf[48] = 2080;
                      *(void *)&buf[50] = v51;
                      _os_log_fault_impl( (void *)&_mh_execute_header,  v89,  OS_LOG_TYPE_FAULT,  "Unable to format: %s [%d]: dir %s, fullfilename %s, realDir %s, expectedRealDir %s",  buf,  0x3Au);
                    }

                    if (qword_1000E7D38) {
                      unint64_t v90 = (FILE *)qword_1000E7D38;
                    }
                    else {
                      unint64_t v90 = __stderrp;
                    }
                    fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v90);
                    goto LABEL_115;
                  }

                  __int128 v57 = v56;
LABEL_86:
                  id v76 = v41;
                  id v77 = CFStringGetCStringPtr(v57, 0x8000100u);
                  if (v77)
                  {
                    uint64_t v78 = (char *)v77;
                    uint64_t v79 = 0LL;
                  }

                  else
                  {
                    uint64_t v78 = (char *)calloc(0x400uLL, 1uLL);
                    CFStringGetCString(v57, v78, 1024LL, 0x8000100u);
                    uint64_t v79 = v78;
                  }

                  if (qword_1000E7D38) {
                    unsigned int v91 = (FILE *)qword_1000E7D38;
                  }
                  else {
                    unsigned int v91 = __stderrp;
                  }
                  fprintf(v91, "%s\n", v78);
                  if (v79) {
                    free(v79);
                  }
                  CFRelease(v57);
                  uint64_t v41 = v76;
LABEL_115:
                  int v74 = v314;
LABEL_116:
                  *__error() = v74;
                  int v54 = v315;
                }
              }

              int v92 = strcmp(v51, v45);
              free(v42);
              free(v51);
              if (!v92)
              {
                unsigned int v93 = snprintf(v41, 0x400uLL, "%s/%s", v45, v54);
                free(v54);
                free(v45);
                if (v93 < 0x400)
                {
                  if (a6) {
                    uint64_t v94 = asprintf(&v330, "Requested by %s [%d] - %s");
                  }
                  else {
                    uint64_t v94 = asprintf(&v330, "Requested by %s [%d]");
                  }
                  if ((a5 & 0x80) == 0)
                  {
                    unsigned int v95 = v41;
                    double Current = SAMachAbsTimeSecondsGetCurrent(v94);
                    if ((a5 & 0x20) != 0) {
                      unsigned __int8 v97 = 2;
                    }
                    else {
                      unsigned __int8 v97 = 3;
                    }
                    if ((a5 & 0x40) != 0) {
                      unint64_t v98 = 384LL;
                    }
                    else {
                      unint64_t v98 = 385LL;
                    }
                    if (a7) {
                      id v99 = strdup(a7);
                    }
                    else {
                      id v99 = 0LL;
                    }
                    double v105 = a9 + Current;
                    if (a11) {
                      qos_class_t v106 = qos_class_self();
                    }
                    else {
                      qos_class_t v106 = QOS_CLASS_BACKGROUND;
                    }
                    dispatch_queue_global_t global_queue = dispatch_get_global_queue(v106, 0LL);
                    v320[0] = _NSConcreteStackBlock;
                    v320[1] = 3221225472LL;
                    v320[2] = sub_10003EFD4;
                    v320[3] = &unk_1000D8F38;
                    int v321 = a3;
                    v320[6] = v99;
                    v320[7] = a5;
                    v320[8] = v41;
                    v320[4] = a11;
                    v320[5] = v330;
                    unint64_t v322 = a1;
                    int v323 = a2;
                    if (sub_100069DB0( a3,  (v39 * 1000000.0),  0LL,  v97,  0LL,  v98,  (uint64_t)global_queue,  (uint64_t)v320,  v105))
                    {
                      return;
                    }

                    if ((a3 & 0x80000000) != 0)
                    {
                      if (byte_1000E7D30)
                      {
                        int v141 = *__error();
                        id v142 = (os_log_s *)sub_10002EFA0();
                        if (os_log_type_enabled(v142, OS_LOG_TYPE_ERROR)) {
                          sub_100081660();
                        }
                        *__error() = v141;
                      }

                      if (!byte_1000E7D31 || dword_1000E74E0 > 3) {
                        goto LABEL_260;
                      }
                      int v111 = *__error();
                      uint64_t v143 = *__error();
                      id v144 = __error();
                      id v145 = strerror(*v144);
                      id v146 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"generate spindump: unable to sample process: %d (%s)",  v143,  v145);
                      if (v146)
                      {
                        id v147 = v146;
                        double v148 = CFStringGetCStringPtr(v146, 0x8000100u);
                        if (v148)
                        {
                          id v149 = (char *)v148;
                          id v150 = 0LL;
                        }

                        else
                        {
                          id v149 = (char *)calloc(0x400uLL, 1uLL);
                          CFStringGetCString(v147, v149, 1024LL, 0x8000100u);
                          id v150 = v149;
                        }

                        if (qword_1000E7D38) {
                          id v162 = (FILE *)qword_1000E7D38;
                        }
                        else {
                          id v162 = __stderrp;
                        }
                        fprintf(v162, "%s\n", v149);
                        if (v150) {
                          free(v150);
                        }
                        id v159 = v147;
                        goto LABEL_258;
                      }

                      id v160 = (os_log_s *)sub_10002EFA0();
                      if (os_log_type_enabled(v160, OS_LOG_TYPE_FAULT)) {
                        sub_1000815F0();
                      }
                    }

                    else
                    {
                      if (byte_1000E7D30)
                      {
                        int v109 = *__error();
                        uint64_t v110 = (os_log_s *)sub_10002EFA0();
                        if (os_log_type_enabled(v110, OS_LOG_TYPE_ERROR)) {
                          sub_100081560();
                        }
                        *__error() = v109;
                      }

                      if (!byte_1000E7D31 || dword_1000E74E0 > 3) {
                        goto LABEL_260;
                      }
                      int v111 = *__error();
                      __int128 v112 = sub_10002EF3C(a3);
                      uint64_t v113 = *__error();
                      id v114 = __error();
                      id v115 = strerror(*v114);
                      id v116 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"%s [%d]: generate spindump: unable to sample process: %d (%s)",  v112,  a3,  v113,  v115);
                      if (v116)
                      {
                        id v117 = v116;
                        __int16 v118 = CFStringGetCStringPtr(v116, 0x8000100u);
                        if (v118)
                        {
                          uint64_t v119 = (char *)v118;
                          __int16 v120 = 0LL;
                        }

                        else
                        {
                          uint64_t v119 = (char *)calloc(0x400uLL, 1uLL);
                          CFStringGetCString(v117, v119, 1024LL, 0x8000100u);
                          __int16 v120 = v119;
                        }

                        if (qword_1000E7D38) {
                          double v158 = (FILE *)qword_1000E7D38;
                        }
                        else {
                          double v158 = __stderrp;
                        }
                        fprintf(v158, "%s\n", v119);
                        if (v120) {
                          free(v120);
                        }
                        id v159 = v117;
LABEL_258:
                        CFRelease(v159);
LABEL_259:
                        *__error() = v111;
                        uint64_t v41 = v95;
LABEL_260:
                        if (a11)
                        {
                          int v163 = __error();
                          (*(void (**)(uint64_t, void, void))(a11 + 16))(a11, *v163, 0LL);
                        }

                        free(v41);
                        if (v330) {
                          free(v330);
                        }
                        if (v99) {
                          free(v99);
                        }
                        return;
                      }

                      int v157 = (os_log_s *)sub_10002EFA0();
                      if (os_log_type_enabled(v157, OS_LOG_TYPE_FAULT)) {
                        sub_1000814D0();
                      }
                    }

                    if (qword_1000E7D38) {
                      double v161 = (FILE *)qword_1000E7D38;
                    }
                    else {
                      double v161 = __stderrp;
                    }
                    fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v161);
                    goto LABEL_259;
                  }

                  id v100 = v330;
                  v324[0] = _NSConcreteStackBlock;
                  v324[1] = 3221225472LL;
                  id v325 = sub_10003EF74;
                  id v326 = &unk_1000D8F10;
                  int v328 = v41;
                  id v329 = v330;
                  uint64_t v327 = a11;
                  unsigned int v101 = 2;
                  int v102 = (char **)calloc(2uLL, 8uLL);
                  id v103 = v102;
                  uint64_t v334 = 0LL;
                  *int v102 = "/usr/sbin/spindump";
                  v102[1] = "-noIPC";
                  if ((a3 & 0x80000000) != 0)
                  {
                    int v104 = 0;
                  }

                  else
                  {
                    id v103 = (char **)realloc(v102, 0x18uLL);
                    asprintf(v103 + 2, "%d", a3);
                    unsigned int v101 = 3;
                    int v104 = 4;
                  }

                  id v107 = v41;
                  if (a4)
                  {
                    id v103 = (char **)realloc(v103, 8 * v101 + 16);
                    v103[v101] = "-targetThreadID";
                    asprintf(&v103[v101 + 1], "%d", a3);
                    v104 |= 2 << v101;
                    v101 += 2;
                  }

                  uint64_t v121 = v101 + 2;
                  __int16 v122 = (char **)realloc(v103, 8 * v121);
                  if (round(a9) <= 0.0) {
                    double v123 = 1.0;
                  }
                  else {
                    double v123 = a9;
                  }
                  asprintf(&v122[v101], "%.0f", v123);
                  double v124 = v39 * 1000000.0;
                  if (round(v39 * 1000000.0) <= 0.0) {
                    double v124 = 1.0;
                  }
                  asprintf(&v122[v101 + 1], "%.0fu", v124);
                  LOBYTE(v334) = (3 << v101) | v104;
                  if ((a5 & 1) != 0)
                  {
                    if ((a5 & 2) != 0)
                    {
LABEL_158:
                      __int16 v122 = (char **)realloc(v122, 8LL * (v121 + 1));
                      v122[v121] = "-noText";
                      LODWORD(v121) = v121 + 1;
                      if ((a5 & 4) != 0) {
                        goto LABEL_159;
                      }
                      goto LABEL_166;
                    }
                  }

                  else
                  {
                    __int16 v122 = (char **)realloc(v122, 8LL * (v101 + 3));
                    v122[v121] = "-timeline";
                    LODWORD(v121) = v101 + 3;
                    if ((a5 & 2) != 0) {
                      goto LABEL_158;
                    }
                  }

                  if ((a5 & 4) != 0)
                  {
LABEL_159:
                    __int16 v122 = (char **)realloc(v122, 8LL * (v121 + 1));
                    v122[v121] = "-noBinary";
                    LODWORD(v121) = v121 + 1;
                    if ((a5 & 8) != 0) {
                      goto LABEL_160;
                    }
                    goto LABEL_167;
                  }

        uint64_t v30 = v18;
        BOOL v31 = v7;
        uint64_t v32 = CFStringGetCStringPtr(v18, 0x8000100u);
        if (v32)
        {
          id v33 = (char *)v32;
          int v34 = 0LL;
        }

        else
        {
          id v33 = (char *)calloc(0x400uLL, 1uLL);
          CFStringGetCString(v30, v33, 1024LL, 0x8000100u);
          int v34 = v33;
        }

        if (qword_1000E7D38) {
          uint64_t v47 = (FILE *)qword_1000E7D38;
        }
        else {
          uint64_t v47 = __stderrp;
        }
        fprintf(v47, "%s\n", v33);
        if (v34) {
          free(v34);
        }
        CFRelease(v30);
        uint64_t v7 = v31;
        goto LABEL_77;
      }
    }
  }

  else
  {
    if ((a1 & 0x80000000) == 0)
    {
      if (byte_1000E7D30)
      {
        unsigned int v13 = *__error();
        uint64_t v14 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v14, OS_LOG_TYPE_INFO))
        {
          *(_DWORD *)buf = 136446978;
          int v102 = sub_10002EF3C(a1);
          id v103 = 1024;
          *(_DWORD *)int v104 = a1;
          *(_WORD *)&v104[4] = 2048;
          *(void *)&v104[6] = a5;
          double v105 = 2048;
          qos_class_t v106 = a3;
          _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_INFO,  "%{public}s [%d]: file descriptor exhaustion: fatal, %llu fds with flags %#llx",  buf,  0x26u);
        }

        *__error() = v13;
      }

      if (byte_1000E7D31) {
        uint64_t v15 = dword_1000E74E0 <= 1;
      }
      else {
        uint64_t v15 = 0;
      }
      if (!v15) {
        goto LABEL_78;
      }
      uint64_t v16 = *__error();
      unint64_t v17 = sub_10002EF3C(a1);
      int v18 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"%s [%d]: file descriptor exhaustion: fatal, %llu fds with flags %#llx",  v17,  a1,  a5,  a3,  v94);
      if (!v18)
      {
        double v19 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v19, OS_LOG_TYPE_FAULT))
        {
          BOOL v20 = sub_10002EF3C(a1);
          *(_DWORD *)buf = 136315906;
          int v102 = v20;
          id v103 = 1024;
          *(_DWORD *)int v104 = a1;
          *(_WORD *)&v104[4] = 2048;
          *(void *)&v104[6] = a5;
          double v105 = 2048;
          qos_class_t v106 = a3;
          int v21 = "Unable to format: %s [%d]: file descriptor exhaustion: fatal, %llu fds with flags %#llx";
LABEL_28:
          _os_log_fault_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_FAULT, v21, buf, 0x26u);
          goto LABEL_62;
        }

        goto LABEL_62;
      }

      goto LABEL_39;
    }

    if (byte_1000E7D30)
    {
      int v27 = *__error();
      uint32_t v28 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v28, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)buf = 134218240;
        int v102 = (_DWORD *)a5;
        id v103 = 2048;
        *(void *)int v104 = a3;
        _os_log_impl( (void *)&_mh_execute_header,  v28,  OS_LOG_TYPE_INFO,  "file descriptor exhaustion: fatal, %llu fds with flags %#llx",  buf,  0x16u);
      }

      *__error() = v27;
    }

    if (byte_1000E7D31) {
      int v29 = dword_1000E74E0 <= 1;
    }
    else {
      int v29 = 0;
    }
    if (v29)
    {
      uint64_t v16 = *__error();
      int v18 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"file descriptor exhaustion: fatal, %llu fds with flags %#llx",  a5,  a3);
      if (!v18)
      {
        uint64_t v48 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v48, OS_LOG_TYPE_FAULT)) {
          sub_100084030();
        }
        goto LABEL_62;
      }

      goto LABEL_39;
    }
  }

        uint64_t v30 = v18;
        BOOL v31 = v7;
        uint64_t v32 = CFStringGetCStringPtr(v18, 0x8000100u);
        if (v32)
        {
          id v33 = (char *)v32;
          int v34 = 0LL;
        }

        else
        {
          id v33 = (char *)calloc(0x400uLL, 1uLL);
          CFStringGetCString(v30, v33, 1024LL, 0x8000100u);
          int v34 = v33;
        }

        if (qword_1000E7D38) {
          uint64_t v47 = (FILE *)qword_1000E7D38;
        }
        else {
          uint64_t v47 = __stderrp;
        }
        fprintf(v47, "%s\n", v33);
        if (v34) {
          free(v34);
        }
        CFRelease(v30);
        uint64_t v7 = v31;
        goto LABEL_77;
      }
    }
  }

  else
  {
    if ((a1 & 0x80000000) == 0)
    {
      if (byte_1000E7D30)
      {
        unsigned int v13 = *__error();
        uint64_t v14 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v14, OS_LOG_TYPE_INFO))
        {
          *(_DWORD *)buf = 136446978;
          int v102 = sub_10002EF3C(a1);
          id v103 = 1024;
          *(_DWORD *)int v104 = a1;
          *(_WORD *)&v104[4] = 2048;
          *(void *)&v104[6] = a5;
          double v105 = 2048;
          qos_class_t v106 = a3;
          _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_INFO,  "%{public}s [%d]: port exhaustion: fatal, %llu ports with flags %#llx",  buf,  0x26u);
        }

        *__error() = v13;
      }

      if (byte_1000E7D31) {
        uint64_t v15 = dword_1000E74E0 <= 1;
      }
      else {
        uint64_t v15 = 0;
      }
      if (!v15) {
        goto LABEL_78;
      }
      uint64_t v16 = *__error();
      unint64_t v17 = sub_10002EF3C(a1);
      int v18 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"%s [%d]: port exhaustion: fatal, %llu ports with flags %#llx",  v17,  a1,  a5,  a3,  v94);
      if (!v18)
      {
        double v19 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v19, OS_LOG_TYPE_FAULT))
        {
          BOOL v20 = sub_10002EF3C(a1);
          *(_DWORD *)buf = 136315906;
          int v102 = v20;
          id v103 = 1024;
          *(_DWORD *)int v104 = a1;
          *(_WORD *)&v104[4] = 2048;
          *(void *)&v104[6] = a5;
          double v105 = 2048;
          qos_class_t v106 = a3;
          int v21 = "Unable to format: %s [%d]: port exhaustion: fatal, %llu ports with flags %#llx";
LABEL_28:
          _os_log_fault_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_FAULT, v21, buf, 0x26u);
          goto LABEL_62;
        }

        goto LABEL_62;
      }

      goto LABEL_39;
    }

    if (byte_1000E7D30)
    {
      int v27 = *__error();
      uint32_t v28 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v28, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)buf = 134218240;
        int v102 = (_DWORD *)a5;
        id v103 = 2048;
        *(void *)int v104 = a3;
        _os_log_impl( (void *)&_mh_execute_header,  v28,  OS_LOG_TYPE_INFO,  "port exhaustion: fatal, %llu ports with flags %#llx",  buf,  0x16u);
      }

      *__error() = v27;
    }

    if (byte_1000E7D31) {
      int v29 = dword_1000E74E0 <= 1;
    }
    else {
      int v29 = 0;
    }
    if (v29)
    {
      uint64_t v16 = *__error();
      int v18 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"port exhaustion: fatal, %llu ports with flags %#llx",  a5,  a3);
      if (!v18)
      {
        uint64_t v48 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v48, OS_LOG_TYPE_FAULT)) {
          sub_1000842E4();
        }
        goto LABEL_62;
      }

      goto LABEL_39;
    }
  }

        uint64_t v30 = v18;
        BOOL v31 = v7;
        uint64_t v32 = CFStringGetCStringPtr(v18, 0x8000100u);
        if (v32)
        {
          id v33 = (char *)v32;
          int v34 = 0LL;
        }

        else
        {
          id v33 = (char *)calloc(0x400uLL, 1uLL);
          CFStringGetCString(v30, v33, 1024LL, 0x8000100u);
          int v34 = v33;
        }

        if (qword_1000E7D38) {
          uint64_t v47 = (FILE *)qword_1000E7D38;
        }
        else {
          uint64_t v47 = __stderrp;
        }
        fprintf(v47, "%s\n", v33);
        if (v34) {
          free(v34);
        }
        CFRelease(v30);
        uint64_t v7 = v31;
        goto LABEL_77;
      }
    }
  }

  else
  {
    if ((a1 & 0x80000000) == 0)
    {
      if (byte_1000E7D30)
      {
        unsigned int v13 = *__error();
        uint64_t v14 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v14, OS_LOG_TYPE_INFO))
        {
          *(_DWORD *)buf = 136446978;
          int v102 = sub_10002EF3C(a1);
          id v103 = 1024;
          *(_DWORD *)int v104 = a1;
          *(_WORD *)&v104[4] = 2048;
          *(void *)&v104[6] = a5;
          double v105 = 2048;
          qos_class_t v106 = a3;
          _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_INFO,  "%{public}s [%d]: kqworkloop exhaustion: fatal, %llu kqworkloops with flags %#llx",  buf,  0x26u);
        }

        *__error() = v13;
      }

      if (byte_1000E7D31) {
        uint64_t v15 = dword_1000E74E0 <= 1;
      }
      else {
        uint64_t v15 = 0;
      }
      if (!v15) {
        goto LABEL_78;
      }
      uint64_t v16 = *__error();
      unint64_t v17 = sub_10002EF3C(a1);
      int v18 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"%s [%d]: kqworkloop exhaustion: fatal, %llu kqworkloops with flags %#llx",  v17,  a1,  a5,  a3,  v94);
      if (!v18)
      {
        double v19 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v19, OS_LOG_TYPE_FAULT))
        {
          BOOL v20 = sub_10002EF3C(a1);
          *(_DWORD *)buf = 136315906;
          int v102 = v20;
          id v103 = 1024;
          *(_DWORD *)int v104 = a1;
          *(_WORD *)&v104[4] = 2048;
          *(void *)&v104[6] = a5;
          double v105 = 2048;
          qos_class_t v106 = a3;
          int v21 = "Unable to format: %s [%d]: kqworkloop exhaustion: fatal, %llu kqworkloops with flags %#llx";
LABEL_28:
          _os_log_fault_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_FAULT, v21, buf, 0x26u);
          goto LABEL_62;
        }

        goto LABEL_62;
      }

      goto LABEL_39;
    }

    if (byte_1000E7D30)
    {
      int v27 = *__error();
      uint32_t v28 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v28, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)buf = 134218240;
        int v102 = (_DWORD *)a5;
        id v103 = 2048;
        *(void *)int v104 = a3;
        _os_log_impl( (void *)&_mh_execute_header,  v28,  OS_LOG_TYPE_INFO,  "kqworkloop exhaustion: fatal, %llu kqworkloops with flags %#llx",  buf,  0x16u);
      }

      *__error() = v27;
    }

    if (byte_1000E7D31) {
      int v29 = dword_1000E74E0 <= 1;
    }
    else {
      int v29 = 0;
    }
    if (v29)
    {
      uint64_t v16 = *__error();
      int v18 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"kqworkloop exhaustion: fatal, %llu kqworkloops with flags %#llx",  a5,  a3);
      if (!v18)
      {
        uint64_t v48 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v48, OS_LOG_TYPE_FAULT)) {
          sub_100084598();
        }
        goto LABEL_62;
      }

      goto LABEL_39;
    }
  }

    id v22 = 0LL;
    id obj = 0LL;
    v657 = 0LL;
LABEL_40:
    int v21 = 0;
    goto LABEL_807;
  }

  v684[0] = _NSConcreteStackBlock;
  v684[1] = 3221225472LL;
  v685 = (void (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))sub_100079C04;
  v686 = &unk_1000D9240;
  v687 = &v689;
  v688 = &v693;
  sub_100079C04((uint64_t)v684, v7, v8, v9, v10, v11, v12, v13);
  uint64_t v15 = v694[3];
  do
  {
    uint64_t v15 = v694[3];
  }

  while (strncmp("Report Version:", (const char *)v15, 0xFuLL));
  uint64_t v16 = strtol((const char *)(v15 + 15), 0LL, 0);
  if (!v16)
  {
LABEL_19:
    if (byte_1000E7D30)
    {
      BOOL v31 = *__error();
      uint64_t v32 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR)) {
        sub_100093F98();
      }
      *__error() = v31;
    }

    if (byte_1000E7D31) {
      id v33 = dword_1000E74E0 <= 3;
    }
    else {
      id v33 = 0;
    }
    if (v33)
    {
      __int128 v23 = *__error();
      int v34 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"Parsing spindump text: No report version. Not a spindump file?");
      uint32_t v28 = v34;
      if (v34)
      {
        uint64_t v35 = (char *)CFStringGetCStringPtr(v34, 0x8000100u);
        if (v35)
        {
          int v36 = 0LL;
        }

        else
        {
          uint64_t v35 = (char *)calloc(0x400uLL, 1uLL);
          CFStringGetCString(v28, v35, 1024LL, 0x8000100u);
          int v36 = v35;
        }

        if (qword_1000E7D38) {
          CFStringRef v56 = (FILE *)qword_1000E7D38;
        }
        else {
          CFStringRef v56 = __stderrp;
        }
        fprintf(v56, "%s\n", v35);
        if (v36) {
          free(v36);
        }
        goto LABEL_152;
      }

      uint64_t v47 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v47, OS_LOG_TYPE_FAULT)) {
        sub_100093F6C();
      }
      if (qword_1000E7D38) {
        uint64_t v48 = (FILE *)qword_1000E7D38;
      }
      else {
        uint64_t v48 = __stderrp;
      }
      goto LABEL_109;
    }

    goto LABEL_39;
  }

  unint64_t v17 = v16;
  if (fgets((char *)v694[3], *((_DWORD *)v690 + 6), v14)
    && !strncmp("Report Variant:   condensed", (const char *)v694[3], 0x1BuLL))
  {
    if (byte_1000E7D30)
    {
      __int128 v57 = *__error();
      int v58 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v58, OS_LOG_TYPE_DEBUG)) {
        sub_100094598();
      }
      *__error() = v57;
    }

    v654 = 1;
    if (byte_1000E7D31 && dword_1000E74E0 <= 0)
    {
      int v59 = *__error();
      BOOL v60 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"Parsing spindump text: Detected condensed report variant");
      int v61 = v60;
      if (v60)
      {
        int v62 = (char *)CFStringGetCStringPtr(v60, 0x8000100u);
        if (v62)
        {
          __int16 v63 = 0LL;
        }

        else
        {
          int v62 = (char *)calloc(0x400uLL, 1uLL);
          CFStringGetCString(v61, v62, 1024LL, 0x8000100u);
          __int16 v63 = v62;
        }

        if (qword_1000E7D38) {
          unint64_t v90 = (FILE *)qword_1000E7D38;
        }
        else {
          unint64_t v90 = __stderrp;
        }
        fprintf(v90, "%s\n", v62);
        if (v63) {
          free(v63);
        }
        CFRelease(v61);
      }

      else
      {
        id v87 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v87, OS_LOG_TYPE_FAULT)) {
          sub_10009456C();
        }
        if (qword_1000E7D38) {
          id v88 = (FILE *)qword_1000E7D38;
        }
        else {
          id v88 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v88);
      }

      *__error() = v59;
      v654 = 1;
    }
  }

  else
  {
    v654 = 0;
  }

  if (fseek(v14, 0LL, 0))
  {
    if (byte_1000E7D30)
    {
      int v18 = *__error();
      double v19 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
      {
        __error();
        BOOL v20 = __error();
        strerror(*v20);
        sub_100094534();
      }

      *__error() = v18;
    }

    int v21 = 0;
    id v22 = 0LL;
    if (byte_1000E7D31)
    {
      id obj = 0LL;
      v657 = 0LL;
      if (dword_1000E74E0 > 3) {
        goto LABEL_807;
      }
      __int128 v23 = *__error();
      uint64_t v24 = *__error();
      __int128 v25 = __error();
      uint64_t v26 = strerror(*v25);
      int v27 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"Parsing spindump text requires a seekable file: %d (%s)",  v24,  v26);
      uint32_t v28 = v27;
      if (v27)
      {
        int v29 = (char *)CFStringGetCStringPtr(v27, 0x8000100u);
        if (v29)
        {
          uint64_t v30 = 0LL;
        }

        else
        {
          int v29 = (char *)calloc(0x400uLL, 1uLL);
          CFStringGetCString(v28, v29, 1024LL, 0x8000100u);
          uint64_t v30 = v29;
        }

        if (qword_1000E7D38) {
          id v83 = (FILE *)qword_1000E7D38;
        }
        else {
          id v83 = __stderrp;
        }
        fprintf(v83, "%s\n", v29);
        if (v30) {
          free(v30);
        }
LABEL_152:
        CFRelease(v28);
        goto LABEL_153;
      }

      int v74 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v74, OS_LOG_TYPE_FAULT))
      {
        __error();
        CFStringRef v75 = __error();
        strerror(*v75);
        sub_1000944FC();
      }

      if (qword_1000E7D38) {
        uint64_t v48 = (FILE *)qword_1000E7D38;
      }
      else {
        uint64_t v48 = __stderrp;
      }
      goto LABEL_109;
    }

    goto LABEL_787;
  }

  if (v17 <= 19)
  {
    if (byte_1000E7D30)
    {
      uint64_t v49 = *__error();
      uint64_t v50 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v50, OS_LOG_TYPE_ERROR)) {
        sub_100093FF0();
      }
      *__error() = v49;
    }

    int v21 = 0;
    id v22 = 0LL;
    if (byte_1000E7D31)
    {
      id obj = 0LL;
      v657 = 0LL;
      if (dword_1000E74E0 > 3) {
        goto LABEL_807;
      }
      __int128 v23 = *__error();
      int v51 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"Parsing spindump text: Unable to parse text of the report: spindump report version 20+ required");
      uint32_t v28 = v51;
      if (v51)
      {
        int v52 = (char *)CFStringGetCStringPtr(v51, 0x8000100u);
        if (v52)
        {
          unsigned __int8 v53 = 0LL;
        }

        else
        {
          int v52 = (char *)calloc(0x400uLL, 1uLL);
          CFStringGetCString(v28, v52, 1024LL, 0x8000100u);
          unsigned __int8 v53 = v52;
        }

        if (qword_1000E7D38) {
          unsigned int v91 = (FILE *)qword_1000E7D38;
        }
        else {
          unsigned int v91 = __stderrp;
        }
        fprintf(v91, "%s\n", v52);
        if (v53) {
          free(v53);
        }
        goto LABEL_152;
      }

      uint64_t v89 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v89, OS_LOG_TYPE_FAULT)) {
        sub_100093FC4();
      }
      if (qword_1000E7D38) {
        uint64_t v48 = (FILE *)qword_1000E7D38;
      }
      else {
        uint64_t v48 = __stderrp;
      }
LABEL_109:
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v48);
LABEL_153:
      int v65 = __error();
LABEL_806:
      id v22 = 0LL;
      id obj = 0LL;
      v657 = 0LL;
      int v21 = 0;
      *int v65 = v23;
      goto LABEL_807;
    }

LABEL_166:
                  if ((a5 & 8) != 0)
                  {
LABEL_160:
                    __int16 v122 = (char **)realloc(v122, 8LL * (v121 + 1));
                    v122[v121] = "-noSymbolicate";
                    LODWORD(v121) = v121 + 1;
                    if ((a5 & 0x20) != 0) {
                      goto LABEL_161;
                    }
                    goto LABEL_168;
                  }

LABEL_167:
                  if ((a5 & 0x20) != 0)
                  {
LABEL_161:
                    __int16 v122 = (char **)realloc(v122, 8LL * (v121 + 1));
                    v122[v121] = "-onlyTarget";
                    LODWORD(v121) = v121 + 1;
                    if ((a5 & 0x40) != 0) {
                      goto LABEL_162;
                    }
                    goto LABEL_169;
                  }

LABEL_168:
                  if ((a5 & 0x40) != 0)
                  {
LABEL_162:
                    __int16 v122 = (char **)realloc(v122, 8LL * (v121 + 1));
                    v122[v121] = "-sampleWithoutTarget";
                    LODWORD(v121) = v121 + 1;
                    if (!v100) {
                      goto LABEL_171;
                    }
                    goto LABEL_170;
                  }

LABEL_169:
                  if (!v100)
                  {
LABEL_171:
                    if (a7)
                    {
                      __int16 v122 = (char **)realloc(v122, 8LL * (v121 + 2));
                      v122[v121] = "-signature";
                      v122[(v121 + 1)] = (char *)a7;
                      LODWORD(v121) = v121 + 2;
                    }

                    if (v107)
                    {
                      uint64_t v125 = (v121 + 2);
                      __int16 v122 = (char **)realloc(v122, 8 * v125);
                      v122[v121] = "-o";
                      v122[(v121 + 1)] = v107;
                      LODWORD(v121) = v121 + 2;
                    }

                    else
                    {
                      uint64_t v125 = v121;
                    }

                    int v126 = realloc(v122, 8LL * (v121 + 1));
                    v126[v125] = 0LL;
                    id v127 = *_NSGetEnviron();
                    unsigned int v128 = 1;
                    do
                      uint64_t v129 = v128++ - 1;
                    while (v127[v129]);
                    v130 = malloc(8LL * v128);
                    memmove(v130, v127, 8 * v129);
                    *((void *)v130 + v129) = "XPC_NULL_BOOTSTRAP=1";
                    *((void *)v130 + v128 - 1) = 0LL;
                    LOBYTE(v313) = 0;
                    int v131 = SASpawnPlatformBinaryWithSigningIdentifier( "/usr/sbin/spindump",  "com.apple.spindump",  v126,  v130,  0LL,  0LL,  0LL,  0LL,  &v333,  v313,  0LL);
                    free(v130);
                    if ((v121 & 0x80000000) == 0)
                    {
                      uint64_t v132 = 0LL;
                      do
                      {
                        ++v132;
                      }

                      while ((_DWORD)v121 + 1 != v132);
                    }

                    free(v126);
                    if (v131 < 1)
                    {
                      uint64_t v136 = *__error();
                      v325((uint64_t)v324, v136, 0LL);
                    }

                    else
                    {
                      qos_class_t v133 = qos_class_self();
                      dispatch_queue_global_t v134 = dispatch_get_global_queue(v133, 0LL);
                      id v135 = dispatch_source_create( (dispatch_source_type_t)&_dispatch_source_type_proc,  v131,  0x80000000uLL,  v134);
                      *(void *)buf = _NSConcreteStackBlock;
                      *(void *)&uint8_t buf[8] = 3221225472LL;
                      *(void *)&buf[16] = sub_100045BD8;
                      *(void *)&_BYTE buf[24] = &unk_1000D8FD8;
                      *(_DWORD *)&buf[48] = v131;
                      *(_DWORD *)&buf[52] = v333;
                      *(void *)&buf[32] = v135;
                      *(void *)&buf[40] = v324;
                      dispatch_source_set_event_handler(v135, buf);
                      dispatch_activate(v135);
                    }

                    return;
                  }

LABEL_170:
                  __int16 v122 = (char **)realloc(v122, 8LL * (v121 + 2));
                  v122[v121] = "-reason";
                  v122[(v121 + 1)] = v100;
                  LODWORD(v121) = v121 + 2;
                  goto LABEL_171;
                }

                int v248 = *__error();
                int v249 = (os_log_s *)sub_10002EFA0();
                BOOL v250 = os_log_type_enabled(v249, OS_LOG_TYPE_FAULT);
                if ((a3 & 0x80000000) != 0)
                {
                  if (v250) {
                    sub_100081808();
                  }
                  *__error() = v248;
                  v251 = v41;
                  if (!byte_1000E7D31 || dword_1000E74E0 > 4) {
                    goto LABEL_485;
                  }
                  int v252 = *__error();
                  int v254 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"generate spindump: filepath %s too large",  v41);
                  if (!v254)
                  {
                    id v308 = (os_log_s *)sub_10002EFA0();
                    if (os_log_type_enabled(v308, OS_LOG_TYPE_FAULT)) {
                      sub_1000817A8();
                    }
                    goto LABEL_480;
                  }
                }

                else
                {
                  if (v250) {
                    sub_10008173C();
                  }
                  *__error() = v248;
                  v251 = v41;
                  if (!byte_1000E7D31 || dword_1000E74E0 > 4) {
                    goto LABEL_485;
                  }
                  int v252 = *__error();
                  id v253 = sub_10002EF3C(a3);
                  int v254 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"%s [%d]: generate spindump: filepath %s too large",  v253,  a3,  v41);
                  if (!v254)
                  {
                    uint64_t v255 = (os_log_s *)sub_10002EFA0();
                    if (os_log_type_enabled(v255, OS_LOG_TYPE_FAULT)) {
                      sub_1000816D0();
                    }
LABEL_480:
                    if (qword_1000E7D38) {
                      id v309 = (FILE *)qword_1000E7D38;
                    }
                    else {
                      id v309 = __stderrp;
                    }
                    fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v309);
LABEL_484:
                    *__error() = v252;
                    v251 = v41;
LABEL_485:
                    v310 = v251;
                    goto LABEL_496;
                  }
                }

                id v269 = v254;
                id v270 = CFStringGetCStringPtr(v254, 0x8000100u);
                if (v270)
                {
                  int v271 = (char *)v270;
                  id v272 = 0LL;
                }

                else
                {
                  int v271 = (char *)calloc(0x400uLL, 1uLL);
                  CFStringGetCString(v269, v271, 1024LL, 0x8000100u);
                  id v272 = v271;
                }

                if (qword_1000E7D38) {
                  id v302 = (FILE *)qword_1000E7D38;
                }
                else {
                  id v302 = __stderrp;
                }
                fprintf(v302, "%s\n", v271);
                if (v272) {
                  free(v272);
                }
                CFRelease(v269);
                goto LABEL_484;
              }

              v237 = v41;
              int v238 = *__error();
              uint64_t v239 = (os_log_s *)sub_10002EFA0();
              BOOL v240 = os_log_type_enabled(v239, OS_LOG_TYPE_FAULT);
              if ((a3 & 0x80000000) != 0)
              {
                if (v240) {
                  sub_1000819A0();
                }
                *__error() = v238;
                if (!byte_1000E7D31 || dword_1000E74E0 > 4) {
                  goto LABEL_495;
                }
                int v241 = *__error();
                id v264 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"generate spindump: filepath %s not in /var/mobile/Library/Logs/CrashReporter",  v237);
                if (v264)
                {
                  unsigned int v265 = v264;
                  id v266 = CFStringGetCStringPtr(v264, 0x8000100u);
                  if (v266)
                  {
                    v267 = (char *)v266;
                    v268 = 0LL;
                  }

                  else
                  {
                    v267 = (char *)calloc(0x400uLL, 1uLL);
                    CFStringGetCString(v265, v267, 1024LL, 0x8000100u);
                    v268 = v267;
                  }

                  if (qword_1000E7D38) {
                    v311 = (FILE *)qword_1000E7D38;
                  }
                  else {
                    v311 = __stderrp;
                  }
                  fprintf(v311, "%s\n", v267);
                  if (v268) {
                    free(v268);
                  }
                  id v305 = v265;
                  goto LABEL_493;
                }

                int v306 = (os_log_s *)sub_10002EFA0();
                if (os_log_type_enabled(v306, OS_LOG_TYPE_FAULT)) {
                  sub_100081940();
                }
              }

              else
              {
                if (v240) {
                  sub_1000818D4();
                }
                *__error() = v238;
                if (!byte_1000E7D31 || dword_1000E74E0 > 4) {
                  goto LABEL_495;
                }
                int v241 = *__error();
                v242 = sub_10002EF3C(a3);
                int v243 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"%s [%d]: generate spindump: filepath %s not in /var/mobile/Library/Logs/CrashReporter",  v242,  a3,  v237);
                if (v243)
                {
                  uint64_t v244 = v243;
                  v245 = CFStringGetCStringPtr(v243, 0x8000100u);
                  if (v245)
                  {
                    v246 = (char *)v245;
                    v247 = 0LL;
                  }

                  else
                  {
                    v246 = (char *)calloc(0x400uLL, 1uLL);
                    CFStringGetCString(v244, v246, 1024LL, 0x8000100u);
                    v247 = v246;
                  }

                  if (qword_1000E7D38) {
                    unsigned int v304 = (FILE *)qword_1000E7D38;
                  }
                  else {
                    unsigned int v304 = __stderrp;
                  }
                  fprintf(v304, "%s\n", v246);
                  if (v247) {
                    free(v247);
                  }
                  id v305 = v244;
LABEL_493:
                  CFRelease(v305);
LABEL_494:
                  *__error() = v241;
LABEL_495:
                  free(v45);
                  free(v315);
                  v310 = v237;
LABEL_496:
                  free(v310);
                  if (a11) {
                    (*(void (**)(uint64_t, uint64_t, void))(a11 + 16))(a11, 22LL, 0LL);
                  }
                  return;
                }

                id v301 = (os_log_s *)sub_10002EFA0();
                if (os_log_type_enabled(v301, OS_LOG_TYPE_FAULT)) {
                  sub_100081868();
                }
              }

              if (qword_1000E7D38) {
                id v307 = (FILE *)qword_1000E7D38;
              }
              else {
                id v307 = __stderrp;
              }
              fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v307);
              goto LABEL_494;
            }

            if ((a3 & 0x80000000) != 0)
            {
              if (byte_1000E7D30)
              {
                int v217 = *__error();
                id v218 = (os_log_s *)sub_10002EFA0();
                if (os_log_type_enabled(v218, OS_LOG_TYPE_ERROR)) {
                  sub_100081460(v218, v219, v220, v221, v222, v223, v224, v225);
                }
                *__error() = v217;
              }

              if (byte_1000E7D31 && dword_1000E74E0 <= 3)
              {
                int v226 = *__error();
                id v227 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"%s: expectedRealDir of / (from /var/mobile/Library/Logs/CrashReporter)",  "0 != strcmp(/, expectedRealDir)");
                if (v227)
                {
                  id v286 = v227;
                  id v287 = CFStringGetCStringPtr(v227, 0x8000100u);
                  if (v287)
                  {
                    unsigned __int8 v288 = (char *)v287;
                    v289 = 0LL;
                  }

                  else
                  {
                    unsigned __int8 v288 = (char *)calloc(0x400uLL, 1uLL);
                    CFStringGetCString(v286, v288, 1024LL, 0x8000100u);
                    v289 = v288;
                  }

                  if (qword_1000E7D38) {
                    int v300 = (FILE *)qword_1000E7D38;
                  }
                  else {
                    int v300 = __stderrp;
                  }
                  fprintf(v300, "%s\n", v288);
                  if (v289) {
                    free(v289);
                  }
                  CFRelease(v286);
                }

                else
                {
                  id v228 = (os_log_s *)sub_10002EFA0();
                  if (os_log_type_enabled(v228, OS_LOG_TYPE_FAULT)) {
                    sub_1000813F0(v228, v229, v230, v231, v232, v233, v234, v235);
                  }
                  if (qword_1000E7D38) {
                    uint64_t v236 = (FILE *)qword_1000E7D38;
                  }
                  else {
                    uint64_t v236 = __stderrp;
                  }
                  fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v236);
                }

                *__error() = v226;
              }

              id v312 = "0 != strcmp(/, expectedRealDir)";
              id v296 = "%s: expectedRealDir of / (from /var/mobile/Library/Logs/CrashReporter)";
            }

            else
            {
              if (byte_1000E7D30)
              {
                int v190 = *__error();
                BOOL v191 = (os_log_s *)sub_10002EFA0();
                if (os_log_type_enabled(v191, OS_LOG_TYPE_ERROR)) {
                  sub_100081378();
                }
                *__error() = v190;
              }

              if (byte_1000E7D31 && dword_1000E74E0 <= 3)
              {
                int v192 = *__error();
                id v193 = sub_10002EF3C(a3);
                id v194 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"%s [%d]: %s: expectedRealDir of / (from /var/mobile/Library/Logs/CrashReporter)",  v193,  a3,  "0 != strcmp(/, expectedRealDir)");
                if (v194)
                {
                  v282 = v194;
                  v283 = CFStringGetCStringPtr(v194, 0x8000100u);
                  if (v283)
                  {
                    id v284 = (char *)v283;
                    id v285 = 0LL;
                  }

                  else
                  {
                    id v284 = (char *)calloc(0x400uLL, 1uLL);
                    CFStringGetCString(v282, v284, 1024LL, 0x8000100u);
                    id v285 = v284;
                  }

                  if (qword_1000E7D38) {
                    int v299 = (FILE *)qword_1000E7D38;
                  }
                  else {
                    int v299 = __stderrp;
                  }
                  fprintf(v299, "%s\n", v284);
                  if (v285) {
                    free(v285);
                  }
                  CFRelease(v282);
                }

                else
                {
                  id v195 = (os_log_s *)sub_10002EFA0();
                  if (os_log_type_enabled(v195, OS_LOG_TYPE_FAULT)) {
                    sub_100081300();
                  }
                  if (qword_1000E7D38) {
                    id v196 = (FILE *)qword_1000E7D38;
                  }
                  else {
                    id v196 = __stderrp;
                  }
                  fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v196);
                }

                *__error() = v192;
              }

              LOBYTE(v312) = sub_10002EF3C(a3);
              id v296 = "%s [%d]: %s: expectedRealDir of / (from /var/mobile/Library/Logs/CrashReporter)";
            }

            int v298 = 1528;
          }

          else
          {
            if ((a3 & 0x80000000) != 0)
            {
              if (byte_1000E7D30)
              {
                int v197 = *__error();
                id v198 = (os_log_s *)sub_10002EFA0();
                if (os_log_type_enabled(v198, OS_LOG_TYPE_ERROR)) {
                  sub_100081290(v198, v199, v200, v201, v202, v203, v204, v205);
                }
                *__error() = v197;
              }

              if (byte_1000E7D31 && dword_1000E74E0 <= 3)
              {
                int v206 = *__error();
                uint64_t v207 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"%s: NULL expectedRealDir (from /var/mobile/Library/Logs/CrashReporter)",  "expectedRealDir");
                if (v207)
                {
                  id v278 = v207;
                  v279 = CFStringGetCStringPtr(v207, 0x8000100u);
                  if (v279)
                  {
                    id v280 = (char *)v279;
                    id v281 = 0LL;
                  }

                  else
                  {
                    id v280 = (char *)calloc(0x400uLL, 1uLL);
                    CFStringGetCString(v278, v280, 1024LL, 0x8000100u);
                    id v281 = v280;
                  }

                  if (qword_1000E7D38) {
                    id v297 = (FILE *)qword_1000E7D38;
                  }
                  else {
                    id v297 = __stderrp;
                  }
                  fprintf(v297, "%s\n", v280);
                  if (v281) {
                    free(v281);
                  }
                  CFRelease(v278);
                }

                else
                {
                  uint64_t v208 = (os_log_s *)sub_10002EFA0();
                  if (os_log_type_enabled(v208, OS_LOG_TYPE_FAULT)) {
                    sub_100081220(v208, v209, v210, v211, v212, v213, v214, v215);
                  }
                  if (qword_1000E7D38) {
                    unsigned int v216 = (FILE *)qword_1000E7D38;
                  }
                  else {
                    unsigned int v216 = __stderrp;
                  }
                  fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v216);
                }

                *__error() = v206;
              }

              id v312 = "expectedRealDir";
              id v296 = "%s: NULL expectedRealDir (from /var/mobile/Library/Logs/CrashReporter)";
            }

            else
            {
              if (byte_1000E7D30)
              {
                int v183 = *__error();
                unsigned int v184 = (os_log_s *)sub_10002EFA0();
                if (os_log_type_enabled(v184, OS_LOG_TYPE_ERROR)) {
                  sub_1000811A8();
                }
                *__error() = v183;
              }

              if (byte_1000E7D31 && dword_1000E74E0 <= 3)
              {
                int v185 = *__error();
                id v186 = sub_10002EF3C(a3);
                id v187 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"%s [%d]: %s: NULL expectedRealDir (from /var/mobile/Library/Logs/CrashReporter)",  v186,  a3,  "expectedRealDir");
                if (v187)
                {
                  v274 = v187;
                  id v275 = CFStringGetCStringPtr(v187, 0x8000100u);
                  if (v275)
                  {
                    id v276 = (char *)v275;
                    id v277 = 0LL;
                  }

                  else
                  {
                    id v276 = (char *)calloc(0x400uLL, 1uLL);
                    CFStringGetCString(v274, v276, 1024LL, 0x8000100u);
                    id v277 = v276;
                  }

                  if (qword_1000E7D38) {
                    id v295 = (FILE *)qword_1000E7D38;
                  }
                  else {
                    id v295 = __stderrp;
                  }
                  fprintf(v295, "%s\n", v276);
                  if (v277) {
                    free(v277);
                  }
                  CFRelease(v274);
                }

                else
                {
                  id v188 = (os_log_s *)sub_10002EFA0();
                  if (os_log_type_enabled(v188, OS_LOG_TYPE_FAULT)) {
                    sub_100081130();
                  }
                  if (qword_1000E7D38) {
                    int v189 = (FILE *)qword_1000E7D38;
                  }
                  else {
                    int v189 = __stderrp;
                  }
                  fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v189);
                }

                *__error() = v185;
              }

              LOBYTE(v312) = sub_10002EF3C(a3);
              id v296 = "%s [%d]: %s: NULL expectedRealDir (from /var/mobile/Library/Logs/CrashReporter)";
            }

            int v298 = 1527;
          }

          sub_10002EE78("DoGenerateSpindump", "monitor.m", v298, v296, v47, v48, v49, v50, (char)v312);
          abort();
        }

        int v173 = *__error();
        uint64_t v174 = (os_log_s *)sub_10002EFA0();
        BOOL v175 = os_log_type_enabled(v174, OS_LOG_TYPE_FAULT);
        if ((a3 & 0x80000000) != 0)
        {
          if (v175) {
            sub_1000810D0();
          }
          *__error() = v173;
          if (!byte_1000E7D31 || dword_1000E74E0 > 4) {
            goto LABEL_230;
          }
          id v176 = v43;
          int v177 = *__error();
          id v179 = v41;
          id v180 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"NULL realDir (dir %s from %s)", v42, v41);
          if (!v180)
          {
            int v293 = (os_log_s *)sub_10002EFA0();
            if (os_log_type_enabled(v293, OS_LOG_TYPE_FAULT)) {
              sub_100081070();
            }
            goto LABEL_412;
          }
        }

        else
        {
          if (v175)
          {
            id v303 = sub_10002EF3C(a3);
            *(_DWORD *)buf = 136446978;
            *(void *)&uint8_t buf[4] = v303;
            *(_WORD *)&_BYTE buf[12] = 1024;
            *(_DWORD *)&buf[14] = a3;
            *(_WORD *)&buf[18] = 2080;
            *(void *)&buf[20] = v42;
            *(_WORD *)&buf[28] = 2080;
            *(void *)&buf[30] = v41;
            _os_log_fault_impl( (void *)&_mh_execute_header,  v174,  OS_LOG_TYPE_FAULT,  "%{public}s [%d]: NULL realDir (dir %s from %s)",  buf,  0x26u);
          }

          *__error() = v173;
          if (!byte_1000E7D31 || dword_1000E74E0 > 4) {
            goto LABEL_230;
          }
          id v176 = v43;
          int v177 = *__error();
          id v178 = sub_10002EF3C(a3);
          id v179 = v41;
          id v180 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"%s [%d]: NULL realDir (dir %s from %s)",  v178,  a3,  v42,  v41);
          if (!v180)
          {
            id v181 = (os_log_s *)sub_10002EFA0();
            if (os_log_type_enabled(v181, OS_LOG_TYPE_FAULT))
            {
              id v182 = sub_10002EF3C(a3);
              *(_DWORD *)buf = 136315906;
              *(void *)&uint8_t buf[4] = v182;
              *(_WORD *)&_BYTE buf[12] = 1024;
              *(_DWORD *)&buf[14] = a3;
              *(_WORD *)&buf[18] = 2080;
              *(void *)&buf[20] = v42;
              *(_WORD *)&buf[28] = 2080;
              *(void *)&buf[30] = v41;
              _os_log_fault_impl( (void *)&_mh_execute_header,  v181,  OS_LOG_TYPE_FAULT,  "Unable to format: %s [%d]: NULL realDir (dir %s from %s)",  buf,  0x26u);
            }

LABEL_412:
            if (qword_1000E7D38) {
              int v294 = (FILE *)qword_1000E7D38;
            }
            else {
              int v294 = __stderrp;
            }
            fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v294);
LABEL_416:
            *__error() = v177;
            uint64_t v41 = v179;
            uint64_t v43 = v176;
            goto LABEL_230;
          }
        }

        id v260 = v180;
        v261 = CFStringGetCStringPtr(v180, 0x8000100u);
        if (v261)
        {
          v262 = (char *)v261;
          id v263 = 0LL;
        }

        else
        {
          v262 = (char *)calloc(0x400uLL, 1uLL);
          CFStringGetCString(v260, v262, 1024LL, 0x8000100u);
          id v263 = v262;
        }

        if (qword_1000E7D38) {
          id v290 = (FILE *)qword_1000E7D38;
        }
        else {
          id v290 = __stderrp;
        }
        fprintf(v290, "%s\n", v262);
        if (v263) {
          free(v263);
        }
        CFRelease(v260);
        goto LABEL_416;
      }

      int v65 = *__error();
      uint64_t v66 = (os_log_s *)sub_10002EFA0();
      BOOL v67 = os_log_type_enabled(v66, OS_LOG_TYPE_FAULT);
      if ((a3 & 0x80000000) != 0)
      {
        if (v67) {
          sub_100081010();
        }
        *__error() = v65;
        if (!byte_1000E7D31 || dword_1000E74E0 > 4) {
          goto LABEL_230;
        }
        int v68 = *__error();
        id v70 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"Unable to get basename of %s", v41);
        if (!v70)
        {
          id v154 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v154, OS_LOG_TYPE_FAULT)) {
            sub_100080FB0();
          }
          goto LABEL_225;
        }
      }

      else
      {
        if (v67) {
          sub_100080F44();
        }
        *__error() = v65;
        if (!byte_1000E7D31 || dword_1000E74E0 > 4) {
          goto LABEL_230;
        }
        int v68 = *__error();
        unsigned int v69 = sub_10002EF3C(a3);
        id v70 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"%s [%d]: Unable to get basename of %s",  v69,  a3,  v41);
        if (!v70)
        {
          int v71 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v71, OS_LOG_TYPE_FAULT)) {
            sub_100080ED8();
          }
LABEL_225:
          if (qword_1000E7D38) {
            char v155 = (FILE *)qword_1000E7D38;
          }
          else {
            char v155 = __stderrp;
          }
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v155);
LABEL_229:
          *__error() = v68;
LABEL_230:
          free(v41);
          free(v42);
          id v153 = v43;
          goto LABEL_231;
        }
      }

      double v84 = v70;
      BOOL v85 = v43;
      int v86 = CFStringGetCStringPtr(v70, 0x8000100u);
      if (v86)
      {
        id v87 = (char *)v86;
        id v88 = 0LL;
      }

      else
      {
        id v87 = (char *)calloc(0x400uLL, 1uLL);
        CFStringGetCString(v84, v87, 1024LL, 0x8000100u);
        id v88 = v87;
      }

      if (qword_1000E7D38) {
        int v138 = (FILE *)qword_1000E7D38;
      }
      else {
        int v138 = __stderrp;
      }
      fprintf(v138, "%s\n", v87);
      if (v88) {
        free(v88);
      }
      CFRelease(v84);
      uint64_t v43 = v85;
      goto LABEL_229;
    }

    int v58 = *__error();
    int v59 = (os_log_s *)sub_10002EFA0();
    BOOL v60 = os_log_type_enabled(v59, OS_LOG_TYPE_FAULT);
    if ((a3 & 0x80000000) != 0)
    {
      if (v60) {
        sub_100080E78();
      }
      *__error() = v58;
      if (!byte_1000E7D31 || dword_1000E74E0 > 4) {
        goto LABEL_222;
      }
      int v61 = *__error();
      __int16 v63 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"Unable to get dirname of %s", v41);
      if (!v63)
      {
        id v151 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v151, OS_LOG_TYPE_FAULT)) {
          sub_100080E18();
        }
        goto LABEL_217;
      }
    }

    else
    {
      if (v60) {
        sub_100080DAC();
      }
      *__error() = v58;
      if (!byte_1000E7D31 || dword_1000E74E0 > 4) {
        goto LABEL_222;
      }
      int v61 = *__error();
      int v62 = sub_10002EF3C(a3);
      __int16 v63 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"%s [%d]: Unable to get dirname of %s",  v62,  a3,  v41);
      if (!v63)
      {
        id v64 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v64, OS_LOG_TYPE_FAULT)) {
          sub_100080D40();
        }
LABEL_217:
        if (qword_1000E7D38) {
          id v152 = (FILE *)qword_1000E7D38;
        }
        else {
          id v152 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v152);
LABEL_221:
        *__error() = v61;
LABEL_222:
        free(v41);
        id v153 = v42;
        goto LABEL_231;
      }
    }

    uint64_t v80 = v63;
    uint64_t v81 = CFStringGetCStringPtr(v63, 0x8000100u);
    if (v81)
    {
      uint64_t v82 = (char *)v81;
      id v83 = 0LL;
    }

    else
    {
      uint64_t v82 = (char *)calloc(0x400uLL, 1uLL);
      CFStringGetCString(v80, v82, 1024LL, 0x8000100u);
      id v83 = v82;
    }

    if (qword_1000E7D38) {
      int v137 = (FILE *)qword_1000E7D38;
    }
    else {
      int v137 = __stderrp;
    }
    fprintf(v137, "%s\n", v82);
    if (v83) {
      free(v83);
    }
    CFRelease(v80);
    goto LABEL_221;
  }

  int v165 = *__error();
  int v166 = (os_log_s *)sub_10002EFA0();
  BOOL v167 = os_log_type_enabled(v166, OS_LOG_TYPE_FAULT);
  if ((a3 & 0x80000000) != 0)
  {
    if (v167) {
      sub_100081808();
    }
    *__error() = v165;
    if (!byte_1000E7D31 || dword_1000E74E0 > 4) {
      goto LABEL_409;
    }
    int v168 = *__error();
    BOOL v170 = v41;
    uint64_t v171 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"generate spindump: filepath %s too large", v41);
    if (!v171)
    {
      id v291 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v291, OS_LOG_TYPE_FAULT)) {
        sub_1000817A8();
      }
      goto LABEL_404;
    }

LABEL_357:
    id v256 = v171;
    id v257 = CFStringGetCStringPtr(v171, 0x8000100u);
    if (v257)
    {
      unsigned int v258 = (char *)v257;
      v259 = 0LL;
    }

    else
    {
      unsigned int v258 = (char *)calloc(0x400uLL, 1uLL);
      CFStringGetCString(v256, v258, 1024LL, 0x8000100u);
      v259 = v258;
    }

    if (qword_1000E7D38) {
      int v273 = (FILE *)qword_1000E7D38;
    }
    else {
      int v273 = __stderrp;
    }
    fprintf(v273, "%s\n", v258);
    if (v259) {
      free(v259);
    }
    CFRelease(v256);
    goto LABEL_408;
  }

  if (v167) {
    sub_10008173C();
  }
  *__error() = v165;
  if (!byte_1000E7D31 || dword_1000E74E0 > 4) {
    goto LABEL_409;
  }
  int v168 = *__error();
  unsigned int v169 = sub_10002EF3C(a3);
  BOOL v170 = v41;
  uint64_t v171 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"%s [%d]: generate spindump: filepath %s too large",  v169,  a3,  v41);
  if (v171) {
    goto LABEL_357;
  }
  uint64_t v172 = (os_log_s *)sub_10002EFA0();
  if (os_log_type_enabled(v172, OS_LOG_TYPE_FAULT)) {
    sub_1000816D0();
  }
LABEL_404:
  if (qword_1000E7D38) {
    id v292 = (FILE *)qword_1000E7D38;
  }
  else {
    id v292 = __stderrp;
  }
  fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v292);
LABEL_408:
  uint64_t v41 = v170;
  *__error() = v168;
LABEL_409:
  id v153 = v41;
LABEL_231:
  free(v153);
  if (a11) {
    (*(void (**)(uint64_t, uint64_t, void))(a11 + 16))(a11, 22LL, 0LL);
  }
}

uint64_t sub_10003EF74(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = *(void *)(a1 + 32);
  if (result) {
    return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(result + 16))(result, a2, a3);
  }
  return result;
}

void sub_10003EFD4(uint64_t a1, void *a2, int a3)
{
  BOOL v6 = (int *)(a1 + 72);
  if ((*(_DWORD *)(a1 + 72) & 0x80000000) == 0)
  {
    if (byte_1000E7D30)
    {
      int v7 = *__error();
      uint64_t v8 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG)) {
        sub_100081ED8(v6);
      }
      *__error() = v7;
    }

    if (byte_1000E7D31) {
      BOOL v9 = dword_1000E74E0 <= 0;
    }
    else {
      BOOL v9 = 0;
    }
    if (!v9) {
      goto LABEL_52;
    }
    int v10 = *__error();
    double v11 = sub_10002EF3C(*v6);
    uint64_t v12 = *v6;
    unsigned int v13 = sub_10006B9CC(a3);
    uint64_t v14 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"%s [%d]: generate spindump: done monitoring due to %s",  v11,  v12,  v13);
    if (v14)
    {
      uint64_t v15 = v14;
      CStringPtr = CFStringGetCStringPtr(v14, 0x8000100u);
      if (CStringPtr)
      {
        unint64_t v17 = (char *)CStringPtr;
        int v18 = 0LL;
      }

      else
      {
        unint64_t v17 = (char *)calloc(0x400uLL, 1uLL);
        CFStringGetCString(v15, v17, 1024LL, 0x8000100u);
        int v18 = v17;
      }

      if (qword_1000E7D38) {
        int v29 = (FILE *)qword_1000E7D38;
      }
      else {
        int v29 = __stderrp;
      }
      fprintf(v29, "%s\n", v17);
      if (v18) {
        free(v18);
      }
LABEL_50:
      CFRelease(v15);
      goto LABEL_51;
    }

    int v27 = (os_log_s *)sub_10002EFA0();
    if (os_log_type_enabled(v27, OS_LOG_TYPE_FAULT)) {
      sub_100081E40(v6);
    }
    if (qword_1000E7D38) {
      uint32_t v28 = (FILE *)qword_1000E7D38;
    }
    else {
      uint32_t v28 = __stderrp;
    }
    goto LABEL_31;
  }

  if (byte_1000E7D30)
  {
    int v19 = *__error();
    BOOL v20 = (os_log_s *)sub_10002EFA0();
    if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG)) {
      sub_100081FD8(a3, v20);
    }
    *__error() = v19;
  }

  if (byte_1000E7D31) {
    BOOL v21 = dword_1000E74E0 <= 0;
  }
  else {
    BOOL v21 = 0;
  }
  if (v21)
  {
    int v10 = *__error();
    id v22 = sub_10006B9CC(a3);
    __int128 v23 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"generate spindump: done monitoring due to %s", v22);
    if (v23)
    {
      uint64_t v15 = v23;
      uint64_t v24 = CFStringGetCStringPtr(v23, 0x8000100u);
      if (v24)
      {
        __int128 v25 = (char *)v24;
        uint64_t v26 = 0LL;
      }

      else
      {
        __int128 v25 = (char *)calloc(0x400uLL, 1uLL);
        CFStringGetCString(v15, v25, 1024LL, 0x8000100u);
        uint64_t v26 = v25;
      }

      if (qword_1000E7D38) {
        BOOL v31 = (FILE *)qword_1000E7D38;
      }
      else {
        BOOL v31 = __stderrp;
      }
      fprintf(v31, "%s\n", v25);
      if (v26) {
        free(v26);
      }
      goto LABEL_50;
    }

    uint64_t v30 = (os_log_s *)sub_10002EFA0();
    if (os_log_type_enabled(v30, OS_LOG_TYPE_FAULT)) {
      sub_100081F60(a3, v30);
    }
    if (qword_1000E7D38) {
      uint32_t v28 = (FILE *)qword_1000E7D38;
    }
    else {
      uint32_t v28 = __stderrp;
    }
LABEL_31:
    fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v28);
LABEL_51:
    *__error() = v10;
  }

LABEL_139:
          if (qword_1000E7D38) {
            id v114 = (FILE *)qword_1000E7D38;
          }
          else {
            id v114 = __stderrp;
          }
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v114);
LABEL_143:
          *__error() = v47;
LABEL_144:
          uint64_t v115 = *(void *)(a1 + 32);
          if (v115) {
            (*(void (**)(uint64_t, void, uint64_t))(v115 + 16))(v115, 0LL, *v34);
          }
          goto LABEL_163;
        }
      }

      id v87 = v51;
      id v88 = CFStringGetCStringPtr(v51, 0x8000100u);
      if (v88)
      {
        uint64_t v89 = (char *)v88;
        unint64_t v90 = 0LL;
      }

      else
      {
        uint64_t v89 = (char *)calloc(0x400uLL, 1uLL);
        CFStringGetCString(v87, v89, 1024LL, 0x8000100u);
        unint64_t v90 = v89;
      }

      if (qword_1000E7D38) {
        int v109 = (FILE *)qword_1000E7D38;
      }
      else {
        int v109 = __stderrp;
      }
      fprintf(v109, "%s\n", v89);
      if (v90) {
        free(v90);
      }
      CFRelease(v87);
      goto LABEL_143;
    }

    if ((*v6 & 0x80000000) == 0)
    {
      if (byte_1000E7D30)
      {
        int v69 = *__error();
        id v70 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v70, OS_LOG_TYPE_ERROR)) {
          sub_100081C50(v6, a1 + 64, v70);
        }
        *__error() = v69;
      }

      if (!byte_1000E7D31 || dword_1000E74E0 > 3) {
        goto LABEL_161;
      }
      int v60 = *__error();
      int v71 = sub_10002EF3C(*v6);
      uint64_t v72 = *v34;
      uint64_t v73 = *v6;
      uint64_t v74 = *__error();
      CFStringRef v75 = __error();
      id v76 = strerror(*v75);
      BOOL v67 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"%s [%d]: generate spindump: unable to fdopen %s for writing: %d (%s)",  v71,  v73,  v72,  v74,  v76);
      if (v67) {
        goto LABEL_92;
      }
      __int128 v112 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v112, OS_LOG_TYPE_FAULT)) {
        sub_100081BD8(v6, a1 + 64, v112);
      }
LABEL_156:
      if (qword_1000E7D38) {
        __int16 v118 = (FILE *)qword_1000E7D38;
      }
      else {
        __int16 v118 = __stderrp;
      }
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v118);
      goto LABEL_160;
    }

    if (byte_1000E7D30)
    {
      int v99 = *__error();
      id v100 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v100, OS_LOG_TYPE_ERROR)) {
        sub_100081D3C();
      }
      *__error() = v99;
    }

    if (!byte_1000E7D31 || dword_1000E74E0 > 3) {
      goto LABEL_161;
    }
    int v60 = *__error();
    uint64_t v101 = *v34;
    uint64_t v102 = *__error();
    id v103 = __error();
    int v104 = strerror(*v103);
    unsigned __int8 v97 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"generate spindump: unable to fdopen %s for writing: %d (%s)",  v101,  v102,  v104);
    if (!v97)
    {
      id v117 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v117, OS_LOG_TYPE_FAULT)) {
        sub_100081CC8();
      }
      goto LABEL_156;
    }

  uint64_t v110 = *(void *)(a1 + 72);
  if (v110)
  {
    int v111 = *(void (**)(void))(v110 + 16);
LABEL_234:
    v111();
  }

LABEL_119:
    double v105 = v97;
    qos_class_t v106 = CFStringGetCStringPtr(v97, 0x8000100u);
    if (v106)
    {
      id v107 = (char *)v106;
      unint64_t v108 = 0LL;
    }

    else
    {
      id v107 = (char *)calloc(0x400uLL, 1uLL);
      CFStringGetCString(v105, v107, 1024LL, 0x8000100u);
      unint64_t v108 = v107;
    }

    if (qword_1000E7D38) {
      id v116 = (FILE *)qword_1000E7D38;
    }
    else {
      id v116 = __stderrp;
    }
    fprintf(v116, "%s\n", v107);
    if (v108) {
      free(v108);
    }
    int v111 = v105;
    goto LABEL_153;
  }

  if (*v6 < 0)
  {
    if (byte_1000E7D30)
    {
      int v91 = *__error();
      int v92 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v92, OS_LOG_TYPE_ERROR)) {
        sub_100081B64();
      }
      *__error() = v91;
    }

    if (!byte_1000E7D31 || dword_1000E74E0 > 3) {
      goto LABEL_161;
    }
    int v60 = *__error();
    uint64_t v93 = *v34;
    uint64_t v94 = *__error();
    unsigned int v95 = __error();
    id v96 = strerror(*v95);
    unsigned __int8 v97 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"generate spindump: unable to open %s for writing: %d (%s)",  v93,  v94,  v96);
    if (!v97)
    {
      unint64_t v98 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v98, OS_LOG_TYPE_FAULT)) {
        sub_100081AF0();
      }
      goto LABEL_156;
    }

    goto LABEL_119;
  }

  if (byte_1000E7D30)
  {
    int v58 = *__error();
    int v59 = (os_log_s *)sub_10002EFA0();
    if (os_log_type_enabled(v59, OS_LOG_TYPE_ERROR)) {
      sub_100081A78(v6, a1 + 64, v59);
    }
    *__error() = v58;
  }

  if (!byte_1000E7D31 || dword_1000E74E0 > 3) {
    goto LABEL_161;
  }
  int v60 = *__error();
  int v61 = sub_10002EF3C(*v6);
  uint64_t v62 = *v34;
  uint64_t v63 = *v6;
  uint64_t v64 = *__error();
  int v65 = __error();
  uint64_t v66 = strerror(*v65);
  BOOL v67 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"%s [%d]: generate spindump: unable to open %s for writing: %d (%s)",  v61,  v63,  v62,  v64,  v66);
  if (!v67)
  {
    int v68 = (os_log_s *)sub_10002EFA0();
    if (os_log_type_enabled(v68, OS_LOG_TYPE_FAULT)) {
      sub_100081A00(v6, a1 + 64, v68);
    }
    goto LABEL_156;
  }

  else {
    int v61 = v27;
  }
  uint64_t v62 = sub_100046C44();
  uint64_t v63 = v61 | 0x80000000000LL;
  if (!v62) {
    uint64_t v63 = v61;
  }
  *a4 |= v63;
  return v16;
}

LABEL_92:
  id v77 = v67;
  uint64_t v78 = CFStringGetCStringPtr(v67, 0x8000100u);
  if (v78)
  {
    uint64_t v79 = (char *)v78;
    uint64_t v80 = 0LL;
  }

  else
  {
    uint64_t v79 = (char *)calloc(0x400uLL, 1uLL);
    CFStringGetCString(v77, v79, 1024LL, 0x8000100u);
    uint64_t v80 = v79;
  }

  if (qword_1000E7D38) {
    uint64_t v110 = (FILE *)qword_1000E7D38;
  }
  else {
    uint64_t v110 = __stderrp;
  }
  fprintf(v110, "%s\n", v79);
  if (v80) {
    free(v80);
  }
  int v111 = v77;
LABEL_153:
  CFRelease(v111);
LABEL_160:
  *__error() = v60;
LABEL_161:
  uint64_t v119 = *(void *)(a1 + 32);
  if (v119)
  {
    uint64_t v120 = *__error();
    (*(void (**)(uint64_t, uint64_t, void))(v119 + 16))(v119, v120, 0LL);
  }

LABEL_163:
  free(*(void **)(a1 + 64));
  uint64_t v121 = *(void **)(a1 + 40);
  if (v121) {
    free(v121);
  }
  __int16 v122 = *(void **)(a1 + 48);
  if (v122) {
    free(v122);
  }
}

uint64_t sub_10003FD08( uint64_t a1, void *a2, uint64_t a3, uint64_t a4, void *a5, double a6, double a7, double a8, double a9, double a10)
{
  id v20 = objc_alloc_init(&OBJC_CLASS___SAMicrostackshotStatistics);
  BOOL v21 = [a2 UTF8String];
  id v22 = [a5 UTF8String];
  uint64_t v23 = sub_100027324( 0LL,  0LL,  a1,  v21,  a3,  1LL,  (uint64_t)v22,  0LL,  a8 - a7,  a8,  0.0,  a6,  a7,  a9,  a10,  5u,  (word_1000E7D70 & 0x80) != 0,  0LL,  0LL,  a4,  SHIDWORD(a4),  0x11u,  0,  0LL,  0LL,  0LL,  0LL,  0LL,  0,  0,  0LL,  (uint64_t)v20);
  uint64_t v24 = objc_msgSend(objc_msgSend(v20, "total"), "num_out_of_order") != 0;
  if (objc_msgSend(objc_msgSend(v20, "total"), "num_missing_load_info")) {
    uint64_t v25 = ((unint64_t)(v24 & 1) << 41) | 0x10000000000LL;
  }
  else {
    uint64_t v25 = v24 << 41;
  }
  if (objc_msgSend(v20, "bytes_not_microstackshots")) {
    v25 |= 0x40000000000uLL;
  }
  if ((v23 & 0x800000) != 0)
  {
    if ((a1 & 0x80000000) == 0)
    {
      if (byte_1000E7D30)
      {
        int v32 = *__error();
        uint64_t v33 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR)) {
          sub_1000825A4(a1, v20, v33);
        }
        *__error() = v32;
      }

      if (byte_1000E7D31 && dword_1000E74E0 <= 3)
      {
        int v28 = *__error();
        int v34 = sub_10002EF3C(a1);
        uint64_t v30 = CFStringCreateWithFormat( kCFAllocatorDefault,  0,  @"%s [%d]: cpu resource: no microstackshots: %llu out-of-order microstackshots, %llu microstackshots missing load infos, %llu bytes invalid",  v34,  a1,  objc_msgSend(objc_msgSend(v20, "total"), "num_out_of_order"),  objc_msgSend(objc_msgSend(v20, "total"), "num_missing_load_info"),  objc_msgSend(v20, "bytes_not_microstackshots"));
        if (!v30)
        {
          uint64_t v35 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v35, OS_LOG_TYPE_FAULT)) {
            sub_100082518(a1, v20, v35);
          }
          goto LABEL_81;
        }

        goto LABEL_36;
      }

      goto LABEL_86;
    }

    if (byte_1000E7D30)
    {
      int v43 = *__error();
      int v44 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v44, OS_LOG_TYPE_ERROR)) {
        sub_1000826B4();
      }
      *__error() = v43;
    }

    if (byte_1000E7D31 && dword_1000E74E0 <= 3)
    {
      int v45 = *__error();
      uint64_t v46 = CFStringCreateWithFormat( kCFAllocatorDefault,  0,  @"cpu resource: no microstackshots: %llu out-of-order microstackshots, %llu microstackshots missing load infos, %llu bytes invalid",  objc_msgSend(objc_msgSend(v20, "total"), "num_out_of_order"),  objc_msgSend(objc_msgSend(v20, "total"), "num_missing_load_info"),  objc_msgSend(v20, "bytes_not_microstackshots"));
      if (!v46)
      {
        int v47 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v47, OS_LOG_TYPE_FAULT)) {
          sub_100082630();
        }
        goto LABEL_106;
      }

      goto LABEL_70;
    }
  }

  else if (v25)
  {
    if ((a1 & 0x80000000) == 0)
    {
      if (byte_1000E7D30)
      {
        int v26 = *__error();
        int v27 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136447234;
          id v87 = sub_10002EF3C(a1);
          __int16 v88 = 1024;
          *(_DWORD *)uint64_t v89 = a1;
          *(_WORD *)&v89[4] = 2048;
          *(void *)&v89[6] = objc_msgSend(objc_msgSend(v20, "total"), "num_out_of_order");
          *(_WORD *)&v89[14] = 2048;
          *(void *)&v89[16] = objc_msgSend(objc_msgSend(v20, "total"), "num_missing_load_info");
          __int16 v90 = 2048;
          id v91 = objc_msgSend(v20, "bytes_not_microstackshots");
          _os_log_impl( (void *)&_mh_execute_header,  v27,  OS_LOG_TYPE_DEFAULT,  "%{public}s [%d]: cpu resource: some microstackshots with errors: %llu out-of-order microstackshots, %llu mic rostackshots missing load infos, %llu bytes invalid",  buf,  0x30u);
        }

        *__error() = v26;
      }

      if (byte_1000E7D31 && dword_1000E74E0 <= 2)
      {
        int v28 = *__error();
        int v29 = sub_10002EF3C(a1);
        uint64_t v30 = CFStringCreateWithFormat( kCFAllocatorDefault,  0,  @"%s [%d]: cpu resource: some microstackshots with errors: %llu out-of-order microstackshots, %llu microstackshots missing load infos, %llu bytes invalid",  v29,  a1,  objc_msgSend(objc_msgSend(v20, "total"), "num_out_of_order"),  objc_msgSend(objc_msgSend(v20, "total"), "num_missing_load_info"),  objc_msgSend(v20, "bytes_not_microstackshots"));
        if (!v30)
        {
          BOOL v31 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v31, OS_LOG_TYPE_FAULT)) {
            sub_100082408(a1, v20, v31);
          }
LABEL_81:
          if (qword_1000E7D38) {
            int v60 = (FILE *)qword_1000E7D38;
          }
          else {
            int v60 = __stderrp;
          }
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v60);
LABEL_85:
          *__error() = v28;
          goto LABEL_86;
        }

        goto LABEL_36;
      }

      goto LABEL_86;
    }

    if (byte_1000E7D30)
    {
      int v48 = *__error();
      uint64_t v49 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v49, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 134218496;
        id v87 = objc_msgSend(objc_msgSend(v20, "total"), "num_out_of_order");
        __int16 v88 = 2048;
        *(void *)uint64_t v89 = objc_msgSend(objc_msgSend(v20, "total"), "num_missing_load_info");
        *(_WORD *)&v89[8] = 2048;
        *(void *)&v89[10] = objc_msgSend(v20, "bytes_not_microstackshots");
        _os_log_impl( (void *)&_mh_execute_header,  v49,  OS_LOG_TYPE_DEFAULT,  "cpu resource: some microstackshots with errors: %llu out-of-order microstackshots, %llu microstackshots missin g load infos, %llu bytes invalid",  buf,  0x20u);
      }

      *__error() = v48;
    }

    if (byte_1000E7D31 && dword_1000E74E0 <= 2)
    {
      int v45 = *__error();
      uint64_t v46 = CFStringCreateWithFormat( kCFAllocatorDefault,  0,  @"cpu resource: some microstackshots with errors: %llu out-of-order microstackshots, %llu microstackshots missing load infos, %llu bytes invalid",  objc_msgSend(objc_msgSend(v20, "total"), "num_out_of_order"),  objc_msgSend(objc_msgSend(v20, "total"), "num_missing_load_info"),  objc_msgSend(v20, "bytes_not_microstackshots"));
      if (!v46)
      {
        uint64_t v50 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v50, OS_LOG_TYPE_FAULT)) {
          sub_100082494();
        }
LABEL_106:
        if (qword_1000E7D38) {
          uint64_t v74 = (FILE *)qword_1000E7D38;
        }
        else {
          uint64_t v74 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v74);
LABEL_110:
        *__error() = v45;
        goto LABEL_111;
      }

      goto LABEL_70;
    }
  }

  else
  {
    if ((a1 & 0x80000000) == 0)
    {
      if (byte_1000E7D30)
      {
        int v36 = *__error();
        int v37 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v37, OS_LOG_TYPE_DEBUG)) {
          sub_1000821B4(a1, v20, v37);
        }
        *__error() = v36;
      }

      if (byte_1000E7D31 && dword_1000E74E0 <= 0)
      {
        int v28 = *__error();
        id v38 = sub_10002EF3C(a1);
        uint64_t v30 = CFStringCreateWithFormat( kCFAllocatorDefault,  0,  @"%s [%d]: cpu resource: all microstackshots without errors: %llu out-of-order microstackshots, %llu microstackshots missing load infos, %llu bytes invalid",  v38,  a1,  objc_msgSend(objc_msgSend(v20, "total"), "num_out_of_order"),  objc_msgSend(objc_msgSend(v20, "total"), "num_missing_load_info"),  objc_msgSend(v20, "bytes_not_microstackshots"));
        if (!v30)
        {
          int v59 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v59, OS_LOG_TYPE_FAULT)) {
            sub_100082128(a1, v20, v59);
          }
          goto LABEL_81;
        }

LABEL_36:
        double v39 = v30;
        CStringPtr = CFStringGetCStringPtr(v30, 0x8000100u);
        if (CStringPtr)
        {
          uint64_t v41 = (char *)CStringPtr;
          int v42 = 0LL;
        }

        else
        {
          uint64_t v41 = (char *)calloc(0x400uLL, 1uLL);
          CFStringGetCString(v39, v41, 1024LL, 0x8000100u);
          int v42 = v41;
        }

        if (qword_1000E7D38) {
          int v51 = (FILE *)qword_1000E7D38;
        }
        else {
          int v51 = __stderrp;
        }
        fprintf(v51, "%s\n", v41);
        if (v42) {
          free(v42);
        }
        CFRelease(v39);
        goto LABEL_85;
      }

        int v37 = v28;
        CStringPtr = CFStringGetCStringPtr(v28, 0x8000100u);
        if (CStringPtr)
        {
          double v39 = (char *)CStringPtr;
          int v40 = 0LL;
        }

        else
        {
          double v39 = (char *)calloc(0x400uLL, 1uLL);
          CFStringGetCString(v37, v39, 1024LL, 0x8000100u);
          int v40 = v39;
        }

        if (qword_1000E7D38) {
          uint64_t v49 = (FILE *)qword_1000E7D38;
        }
        else {
          uint64_t v49 = __stderrp;
        }
        fprintf(v49, "%s\n", v39);
        if (v40) {
          free(v40);
        }
        CFRelease(v37);
        goto LABEL_85;
      }

      unint64_t v17 = v9;
      CStringPtr = CFStringGetCStringPtr(v9, 0x8000100u);
      if (CStringPtr)
      {
        int v19 = (char *)CStringPtr;
        id v20 = 0LL;
      }

      else
      {
        int v19 = (char *)calloc(0x400uLL, 1uLL);
        CFStringGetCString(v17, v19, 1024LL, 0x8000100u);
        id v20 = v19;
      }

      if (qword_1000E7D38) {
        BOOL v21 = (FILE *)qword_1000E7D38;
      }
      else {
        BOOL v21 = __stderrp;
      }
      fprintf(v21, "%s\n", v19);
      if (v20) {
        free(v20);
      }
      CFRelease(v17);
      goto LABEL_45;
    }
  }

LABEL_86:
      if (byte_1000E7D30)
      {
        int v61 = *__error();
        uint64_t v62 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v62, OS_LOG_TYPE_DEBUG)) {
          sub_1000820BC();
        }
        *__error() = v61;
      }

      if (byte_1000E7D31 && dword_1000E74E0 <= 0)
      {
        int v63 = *__error();
        uint64_t v64 = sub_10002EF3C(a1);
        int v65 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"%s [%d]: cpu resource: done reporting (%#llx)",  v64,  a1,  v23);
        if (v65)
        {
          uint64_t v66 = v65;
          BOOL v67 = CFStringGetCStringPtr(v65, 0x8000100u);
          if (v67)
          {
            int v68 = (char *)v67;
            int v69 = 0LL;
          }

          else
          {
            int v68 = (char *)calloc(0x400uLL, 1uLL);
            CFStringGetCString(v66, v68, 1024LL, 0x8000100u);
            int v69 = v68;
          }

          if (qword_1000E7D38) {
            int v71 = (FILE *)qword_1000E7D38;
          }
          else {
            int v71 = __stderrp;
          }
          fprintf(v71, "%s\n", v68);
          if (v69) {
            free(v69);
          }
          uint64_t v72 = v66;
LABEL_133:
          CFRelease(v72);
LABEL_134:
          *__error() = v63;
          goto LABEL_135;
        }

        id v70 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v70, OS_LOG_TYPE_FAULT)) {
          sub_100082050();
        }
        goto LABEL_122;
      }

      goto LABEL_135;
    }

    if (byte_1000E7D30)
    {
      int v52 = *__error();
      unsigned __int8 v53 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v53, OS_LOG_TYPE_DEBUG)) {
        sub_100082384();
      }
      *__error() = v52;
    }

    if (byte_1000E7D31 && dword_1000E74E0 <= 0)
    {
      int v45 = *__error();
      uint64_t v46 = CFStringCreateWithFormat( kCFAllocatorDefault,  0,  @"cpu resource: all microstackshots without errors: %llu out-of-order microstackshots, %llu microstackshots missing load infos, %llu bytes invalid",  objc_msgSend(objc_msgSend(v20, "total"), "num_out_of_order"),  objc_msgSend(objc_msgSend(v20, "total"), "num_missing_load_info"),  objc_msgSend(v20, "bytes_not_microstackshots"));
      if (!v46)
      {
        uint64_t v73 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v73, OS_LOG_TYPE_FAULT)) {
          sub_100082300();
        }
        goto LABEL_106;
      }

      if (byte_1000E7D30)
      {
        int v59 = *__error();
        int v60 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v60, OS_LOG_TYPE_DEBUG)) {
          sub_1000832E8();
        }
        *__error() = v59;
      }

      if (byte_1000E7D31 && dword_1000E74E0 <= 0)
      {
        int v61 = *__error();
        uint64_t v62 = sub_10002EF3C(a1);
        int v63 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"%s [%d]: disk writes: done reporting (%#llx)",  v62,  a1,  v21);
        if (v63)
        {
          uint64_t v64 = v63;
          int v65 = CFStringGetCStringPtr(v63, 0x8000100u);
          if (v65)
          {
            uint64_t v66 = (char *)v65;
            BOOL v67 = 0LL;
          }

          else
          {
            uint64_t v66 = (char *)calloc(0x400uLL, 1uLL);
            CFStringGetCString(v64, v66, 1024LL, 0x8000100u);
            BOOL v67 = v66;
          }

          if (qword_1000E7D38) {
            int v69 = (FILE *)qword_1000E7D38;
          }
          else {
            int v69 = __stderrp;
          }
          fprintf(v69, "%s\n", v66);
          if (v67) {
            free(v67);
          }
          id v70 = v64;
LABEL_133:
          CFRelease(v70);
LABEL_134:
          *__error() = v61;
          goto LABEL_135;
        }

        int v68 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v68, OS_LOG_TYPE_FAULT)) {
          sub_10008327C();
        }
        goto LABEL_122;
      }

      goto LABEL_135;
    }

    if (byte_1000E7D30)
    {
      uint64_t v50 = *__error();
      int v51 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v51, OS_LOG_TYPE_DEBUG)) {
        sub_1000835B0();
      }
      *__error() = v50;
    }

    if (byte_1000E7D31 && dword_1000E74E0 <= 0)
    {
      int v43 = *__error();
      int v44 = CFStringCreateWithFormat( kCFAllocatorDefault,  0,  @"disk writes: all microstackshots without errors: %llu out-of-order microstackshots, %llu microstackshots missing load infos, %llu bytes invalid",  objc_msgSend(objc_msgSend(v18, "total"), "num_out_of_order"),  objc_msgSend(objc_msgSend(v18, "total"), "num_missing_load_info"),  objc_msgSend(v18, "bytes_not_microstackshots"));
      if (!v44)
      {
        int v71 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v71, OS_LOG_TYPE_FAULT)) {
          sub_10008352C();
        }
        goto LABEL_106;
      }

LABEL_70:
      int v54 = v46;
      int v55 = CFStringGetCStringPtr(v46, 0x8000100u);
      if (v55)
      {
        int v56 = (char *)v55;
        uint64_t v57 = 0LL;
      }

      else
      {
        int v56 = (char *)calloc(0x400uLL, 1uLL);
        CFStringGetCString(v54, v56, 1024LL, 0x8000100u);
        uint64_t v57 = v56;
      }

      if (qword_1000E7D38) {
        int v58 = (FILE *)qword_1000E7D38;
      }
      else {
        int v58 = __stderrp;
      }
      fprintf(v58, "%s\n", v56);
      if (v57) {
        free(v57);
      }
      CFRelease(v54);
      goto LABEL_110;
    }
  }

      int v52 = v44;
      unsigned __int8 v53 = CFStringGetCStringPtr(v44, 0x8000100u);
      if (v53)
      {
        int v54 = (char *)v53;
        int v55 = 0LL;
      }

      else
      {
        int v54 = (char *)calloc(0x400uLL, 1uLL);
        CFStringGetCString(v52, v54, 1024LL, 0x8000100u);
        int v55 = v54;
      }

      if (qword_1000E7D38) {
        int v56 = (FILE *)qword_1000E7D38;
      }
      else {
        int v56 = __stderrp;
      }
      fprintf(v56, "%s\n", v54);
      if (v55) {
        free(v55);
      }
      CFRelease(v52);
      goto LABEL_110;
    }
  }

LABEL_111:
  if (byte_1000E7D30)
  {
    int v75 = *__error();
    id v76 = (os_log_s *)sub_10002EFA0();
    if (os_log_type_enabled(v76, OS_LOG_TYPE_DEBUG)) {
      sub_1000822A0();
    }
    *__error() = v75;
  }

  if (byte_1000E7D31 && dword_1000E74E0 <= 0)
  {
    int v63 = *__error();
    id v77 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"cpu resource: done reporting (%#llx)", v23);
    if (v77)
    {
      uint64_t v78 = v77;
      uint64_t v79 = CFStringGetCStringPtr(v77, 0x8000100u);
      if (v79)
      {
        uint64_t v80 = (char *)v79;
        int v81 = 0LL;
      }

      else
      {
        uint64_t v80 = (char *)calloc(0x400uLL, 1uLL);
        CFStringGetCString(v78, v80, 1024LL, 0x8000100u);
        int v81 = v80;
      }

      if (qword_1000E7D38) {
        int v84 = (FILE *)qword_1000E7D38;
      }
      else {
        int v84 = __stderrp;
      }
      fprintf(v84, "%s\n", v80);
      if (v81) {
        free(v81);
      }
      uint64_t v72 = v78;
      goto LABEL_133;
    }

    uint64_t v82 = (os_log_s *)sub_10002EFA0();
    if (os_log_type_enabled(v82, OS_LOG_TYPE_FAULT)) {
      sub_100082240();
    }
LABEL_122:
    if (qword_1000E7D38) {
      id v83 = (FILE *)qword_1000E7D38;
    }
    else {
      id v83 = __stderrp;
    }
    fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v83);
    goto LABEL_134;
  }

  if (byte_1000E7D30)
  {
    uint64_t v73 = *__error();
    uint64_t v74 = (os_log_s *)sub_10002EFA0();
    if (os_log_type_enabled(v74, OS_LOG_TYPE_DEBUG)) {
      sub_1000834CC();
    }
    *__error() = v73;
  }

  if (byte_1000E7D31 && dword_1000E74E0 <= 0)
  {
    int v61 = *__error();
    int v75 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"disk writes: done reporting (%#llx)", v21);
    if (v75)
    {
      id v76 = v75;
      id v77 = CFStringGetCStringPtr(v75, 0x8000100u);
      if (v77)
      {
        uint64_t v78 = (char *)v77;
        uint64_t v79 = 0LL;
      }

      else
      {
        uint64_t v78 = (char *)calloc(0x400uLL, 1uLL);
        CFStringGetCString(v76, v78, 1024LL, 0x8000100u);
        uint64_t v79 = v78;
      }

      if (qword_1000E7D38) {
        uint64_t v82 = (FILE *)qword_1000E7D38;
      }
      else {
        uint64_t v82 = __stderrp;
      }
      fprintf(v82, "%s\n", v78);
      if (v79) {
        free(v79);
      }
      id v70 = v76;
      goto LABEL_133;
    }

    uint64_t v80 = (os_log_s *)sub_10002EFA0();
    if (os_log_type_enabled(v80, OS_LOG_TYPE_FAULT)) {
      sub_10008346C();
    }
LABEL_122:
    if (qword_1000E7D38) {
      int v81 = (FILE *)qword_1000E7D38;
    }
    else {
      int v81 = __stderrp;
    }
    fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v81);
    goto LABEL_134;
  }

  objc_sync_exit(self);
}

LABEL_135:
  return v23;
}

  return v21;
}

uint64_t sub_1000409B4(uint64_t a1, uint64_t a2, char a3, void *a4)
{
  if (!sub_10005BC88(a1))
  {
    uint64_t v15 = 0LL;
    uint64_t v16 = 0LL;
    goto LABEL_45;
  }

  if ((a3 & 0x10) != 0)
  {
    uint64_t v16 = 0LL;
    uint64_t v15 = 16LL;
    goto LABEL_45;
  }

  if ((a1 & 0x80000000) != 0)
  {
    if (byte_1000E7D30)
    {
      int v17 = *__error();
      int v18 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG)) {
        sub_100083084();
      }
      *__error() = v17;
    }

    if (byte_1000E7D31) {
      BOOL v19 = dword_1000E74E0 <= 0;
    }
    else {
      BOOL v19 = 0;
    }
    if (!v19) {
      goto LABEL_26;
    }
    int v11 = *__error();
    unsigned int v13 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"%s: being debugged", a2);
    if (!v13)
    {
      uint64_t v25 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v25, OS_LOG_TYPE_FAULT)) {
        sub_100083024();
      }
      goto LABEL_39;
    }

LABEL_28:
    id v20 = v13;
    CStringPtr = CFStringGetCStringPtr(v13, 0x8000100u);
    if (CStringPtr)
    {
      id v22 = (char *)CStringPtr;
      uint64_t v23 = 0LL;
    }

    else
    {
      id v22 = (char *)calloc(0x400uLL, 1uLL);
      CFStringGetCString(v20, v22, 1024LL, 0x8000100u);
      uint64_t v23 = v22;
    }

    if (qword_1000E7D38) {
      uint64_t v24 = (FILE *)qword_1000E7D38;
    }
    else {
      uint64_t v24 = __stderrp;
    }
    fprintf(v24, "%s\n", v22);
    if (v23) {
      free(v23);
    }
    CFRelease(v20);
    goto LABEL_43;
  }

  if (byte_1000E7D30)
  {
    int v8 = *__error();
    BOOL v9 = (os_log_s *)sub_10002EFA0();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG)) {
      sub_100082FAC();
    }
    *__error() = v8;
  }

  if (byte_1000E7D31) {
    BOOL v10 = dword_1000E74E0 <= 0;
  }
  else {
    BOOL v10 = 0;
  }
  if (v10)
  {
    int v11 = *__error();
    uint64_t v12 = sub_10002EF3C(a1);
    unsigned int v13 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"%s [%d]: %s: being debugged", v12, a1, a2);
    if (!v13)
    {
      uint64_t v14 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v14, OS_LOG_TYPE_FAULT)) {
        sub_100082F40();
      }
LABEL_39:
      if (qword_1000E7D38) {
        int v26 = (FILE *)qword_1000E7D38;
      }
      else {
        int v26 = __stderrp;
      }
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v26);
LABEL_43:
      uint64_t v15 = 0LL;
      *__error() = v11;
      goto LABEL_44;
    }

    goto LABEL_28;
  }

        unsigned int v13 = v11;
        CStringPtr = CFStringGetCStringPtr(v11, 0x8000100u);
        if (CStringPtr)
        {
          uint64_t v15 = (char *)CStringPtr;
          uint64_t v16 = 0LL;
        }

        else
        {
          uint64_t v15 = (char *)calloc(0x400uLL, 1uLL);
          CFStringGetCString(v13, v15, 1024LL, 0x8000100u);
          uint64_t v16 = v15;
        }

        if (qword_1000E7D38) {
          int v17 = (FILE *)qword_1000E7D38;
        }
        else {
          int v17 = __stderrp;
        }
        fprintf(v17, "%s\n", v15);
        if (v16) {
          free(v16);
        }
        CFRelease(v13);
        goto LABEL_43;
      }
    }

    return 0LL;
  }

  return 1LL;
}

LABEL_26:
  uint64_t v15 = 0LL;
LABEL_44:
  uint64_t v16 = 16LL;
LABEL_45:
  if (sub_1000466D0()) {
    v15 |= 0x100uLL;
  }
  if (sub_10005C560()) {
    uint64_t v27 = v15 | 0x80;
  }
  else {
    uint64_t v27 = v15;
  }
  if (qword_1000E7BE8 != -1) {
    dispatch_once(&qword_1000E7BE8, &stru_1000D9018);
  }
  if ((byte_1000E7BE0 & 1) != 0) {
    goto LABEL_119;
  }
  task_name_t v67 = 0;
  uint64_t v28 = task_inspect_for_pid(mach_task_self_, a1, &v67);
  if ((_DWORD)v28)
  {
    uint64_t v29 = v28;
    if ((a1 & 0x80000000) == 0)
    {
      if (byte_1000E7D30)
      {
        int v30 = *__error();
        BOOL v31 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR)) {
          sub_100082E14();
        }
        *__error() = v30;
      }

      if (byte_1000E7D31 && dword_1000E74E0 <= 3)
      {
        int v32 = *__error();
        uint64_t v33 = sub_10002EF3C(a1);
        int v34 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"%s [%d]: Unable to inspect task for suspended state (%d), assuming not suspended",  v33,  a1,  v29);
        if (!v34)
        {
          uint64_t v35 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v35, OS_LOG_TYPE_FAULT)) {
            sub_100082DA8();
          }
LABEL_114:
          if (qword_1000E7D38) {
            int v60 = (FILE *)qword_1000E7D38;
          }
          else {
            int v60 = __stderrp;
          }
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v60);
          goto LABEL_118;
        }

        goto LABEL_73;
      }

      goto LABEL_119;
    }

    if (byte_1000E7D30)
    {
      int v45 = *__error();
      uint64_t v46 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v46, OS_LOG_TYPE_ERROR)) {
        sub_100082EE0();
      }
      *__error() = v45;
    }

    if (!byte_1000E7D31 || dword_1000E74E0 > 3) {
      goto LABEL_119;
    }
    int v32 = *__error();
    int v47 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"Unable to inspect task for suspended state (%d), assuming not suspended",  v29);
    if (!v47)
    {
      int v48 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v48, OS_LOG_TYPE_FAULT)) {
        sub_100082E80();
      }
      goto LABEL_114;
    }

LABEL_93:
    int v51 = v47;
    int v52 = CFStringGetCStringPtr(v47, 0x8000100u);
    if (v52)
    {
      unsigned __int8 v53 = (char *)v52;
      int v54 = 0LL;
    }

    else
    {
      unsigned __int8 v53 = (char *)calloc(0x400uLL, 1uLL);
      CFStringGetCString(v51, v53, 1024LL, 0x8000100u);
      int v54 = v53;
    }

    if (qword_1000E7D38) {
      uint64_t v57 = (FILE *)qword_1000E7D38;
    }
    else {
      uint64_t v57 = __stderrp;
    }
    fprintf(v57, "%s\n", v53);
    if (v54) {
      free(v54);
    }
    int v56 = v51;
    goto LABEL_109;
  }

  mach_msg_type_number_t task_info_outCnt = 10;
  uint64_t v36 = task_info(v67, 0x12u, task_info_out, &task_info_outCnt);
  if (!(_DWORD)v36)
  {
    if (task_info_out[0]) {
      v27 |= 0x20uLL;
    }
    goto LABEL_119;
  }

  uint64_t v37 = v36;
  if ((a1 & 0x80000000) != 0)
  {
    if (byte_1000E7D30)
    {
      int v49 = *__error();
      uint64_t v50 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v50, OS_LOG_TYPE_ERROR)) {
        sub_100082D48();
      }
      *__error() = v49;
    }

    if (!byte_1000E7D31 || dword_1000E74E0 > 3) {
      goto LABEL_119;
    }
    int v32 = *__error();
    int v47 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"Unable to get suspended state (%d), assuming not suspended",  v37);
    if (!v47)
    {
      int v59 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v59, OS_LOG_TYPE_FAULT)) {
        sub_100082CE8();
      }
      goto LABEL_114;
    }

    goto LABEL_93;
  }

  if (byte_1000E7D30)
  {
    int v38 = *__error();
    double v39 = (os_log_s *)sub_10002EFA0();
    if (os_log_type_enabled(v39, OS_LOG_TYPE_ERROR)) {
      sub_100082C7C();
    }
    *__error() = v38;
  }

  if (byte_1000E7D31 && dword_1000E74E0 <= 3)
  {
    int v32 = *__error();
    int v40 = sub_10002EF3C(a1);
    int v34 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"%s [%d]: Unable to get suspended state (%d), assuming not suspended",  v40,  a1,  v37);
    if (!v34)
    {
      int v58 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v58, OS_LOG_TYPE_FAULT)) {
        sub_100082C10();
      }
      goto LABEL_114;
    }

LABEL_73:
    uint64_t v41 = v34;
    int v42 = CFStringGetCStringPtr(v34, 0x8000100u);
    if (v42)
    {
      int v43 = (char *)v42;
      int v44 = 0LL;
    }

    else
    {
      int v43 = (char *)calloc(0x400uLL, 1uLL);
      CFStringGetCString(v41, v43, 1024LL, 0x8000100u);
      int v44 = v43;
    }

    if (qword_1000E7D38) {
      int v55 = (FILE *)qword_1000E7D38;
    }
    else {
      int v55 = __stderrp;
    }
    fprintf(v55, "%s\n", v43);
    if (v44) {
      free(v44);
    }
    int v56 = v41;
LABEL_109:
    CFRelease(v56);
LABEL_118:
    *__error() = v32;
  }

uint64_t sub_1000411CC(double a1)
{
  if (a1 > 0.0)
  {
    if (a1 < 100.0)
    {
      if (qword_1000E7BD8 != -1) {
        dispatch_once(&qword_1000E7BD8, &stru_1000D8FF8);
      }
      double v2 = (double)rand() * 100.0 / 2147483650.0;
      BOOL v3 = v2 > a1;
      if (v2 > a1)
      {
        if (byte_1000E7D30)
        {
          int v4 = *__error();
          double v5 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG)) {
            sub_10008314C();
          }
          *__error() = v4;
        }

        if (byte_1000E7D31) {
          BOOL v6 = dword_1000E74E0 <= 0;
        }
        else {
          BOOL v6 = 0;
        }
        if (!v6) {
          return 1LL;
        }
        int v10 = *__error();
        int v11 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"Should restrict submission due to roll of %.4f (pref is %.4f)",  *(void *)&v2,  *(void *)&a1);
        if (!v11)
        {
          uint64_t v12 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT)) {
            sub_1000830E4();
          }
LABEL_39:
          if (qword_1000E7D38) {
            BOOL v19 = (FILE *)qword_1000E7D38;
          }
          else {
            BOOL v19 = __stderrp;
          }
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v19);
LABEL_43:
          *__error() = v10;
          return v3;
        }

        goto LABEL_28;
      }

      if (byte_1000E7D30)
      {
        int v7 = *__error();
        int v8 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG)) {
          sub_100083218();
        }
        *__error() = v7;
      }

      if (byte_1000E7D31) {
        BOOL v9 = dword_1000E74E0 <= 0;
      }
      else {
        BOOL v9 = 0;
      }
      if (v9)
      {
        int v10 = *__error();
        int v11 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"Should not restrict submission due to roll of %.4f (pref is %.4f)",  *(void *)&v2,  *(void *)&a1);
        if (!v11)
        {
          int v18 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v18, OS_LOG_TYPE_FAULT)) {
            sub_1000831B0();
          }
          goto LABEL_39;
        }

void sub_1000414CC(uint64_t a1)
{
  uint64_t v2 = sub_10003FD08( *(unsigned int *)(a1 + 128),  *(void **)(a1 + 32),  *(void *)(a1 + 56),  *(void *)(a1 + 64),  *(void **)(a1 + 40),  *(double *)(a1 + 72),  *(double *)(a1 + 80),  *(double *)(a1 + 88),  *(double *)(a1 + 96),  *(double *)(a1 + 104));
  sub_10002F9E8( *(_DWORD *)(a1 + 128),  *(void **)(a1 + 32),  *(void *)(a1 + 112),  v2,  *(void *)(a1 + 120) | v3,  *(_DWORD *)(a1 + 64) & 1,  *(double *)(a1 + 88) - *(double *)(a1 + 80),  *(double *)(a1 + 88),  *(double *)(a1 + 72));
}

uint64_t sub_100041538( uint64_t a1, void *a2, uint64_t a3, void *a4, uint64_t a5, uint64_t a6, double a7, double a8, double a9)
{
  id v18 = objc_alloc_init(&OBJC_CLASS___SAMicrostackshotStatistics);
  BOOL v19 = [a2 UTF8String];
  id v20 = [a4 UTF8String];
  uint64_t v21 = sub_100027324( 0LL,  0LL,  a1,  v19,  0LL,  1LL,  (uint64_t)v20,  0LL,  a8 - a7,  a8,  0.0,  0.0,  a7,  0.0,  a9,  6u,  HIBYTE(word_1000E7D70) & 1,  a5,  a6,  a3,  SHIDWORD(a3),  8u,  0,  0LL,  0LL,  0LL,  0LL,  0LL,  0,  0,  0LL,  (uint64_t)v18);
  uint64_t v22 = objc_msgSend(objc_msgSend(v18, "total"), "num_out_of_order") != 0;
  if (objc_msgSend(objc_msgSend(v18, "total"), "num_missing_load_info")) {
    uint64_t v23 = ((unint64_t)(v22 & 1) << 41) | 0x10000000000LL;
  }
  else {
    uint64_t v23 = v22 << 41;
  }
  if (objc_msgSend(v18, "bytes_not_microstackshots")) {
    v23 |= 0x40000000000uLL;
  }
  if ((v21 & 0x800000) != 0)
  {
    if ((a1 & 0x80000000) == 0)
    {
      if (byte_1000E7D30)
      {
        int v30 = *__error();
        BOOL v31 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR)) {
          sub_1000837D0(a1, v18, v31);
        }
        *__error() = v30;
      }

      if (byte_1000E7D31 && dword_1000E74E0 <= 3)
      {
        int v26 = *__error();
        int v32 = sub_10002EF3C(a1);
        uint64_t v28 = CFStringCreateWithFormat( kCFAllocatorDefault,  0,  @"%s [%d]: disk writes: no microstackshots: %llu out-of-order microstackshots, %llu microstackshots missing load infos, %llu bytes invalid",  v32,  a1,  objc_msgSend(objc_msgSend(v18, "total"), "num_out_of_order"),  objc_msgSend(objc_msgSend(v18, "total"), "num_missing_load_info"),  objc_msgSend(v18, "bytes_not_microstackshots"));
        if (!v28)
        {
          uint64_t v33 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v33, OS_LOG_TYPE_FAULT)) {
            sub_100083744(a1, v18, v33);
          }
          goto LABEL_81;
        }

        goto LABEL_36;
      }

      goto LABEL_86;
    }

    if (byte_1000E7D30)
    {
      int v41 = *__error();
      int v42 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v42, OS_LOG_TYPE_ERROR)) {
        sub_1000838E0();
      }
      *__error() = v41;
    }

    if (byte_1000E7D31 && dword_1000E74E0 <= 3)
    {
      int v43 = *__error();
      int v44 = CFStringCreateWithFormat( kCFAllocatorDefault,  0,  @"disk writes: no microstackshots: %llu out-of-order microstackshots, %llu microstackshots missing load infos, %llu bytes invalid",  objc_msgSend(objc_msgSend(v18, "total"), "num_out_of_order"),  objc_msgSend(objc_msgSend(v18, "total"), "num_missing_load_info"),  objc_msgSend(v18, "bytes_not_microstackshots"));
      if (!v44)
      {
        int v45 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v45, OS_LOG_TYPE_FAULT)) {
          sub_10008385C();
        }
        goto LABEL_106;
      }

      goto LABEL_70;
    }
  }

  else if (v23)
  {
    if ((a1 & 0x80000000) == 0)
    {
      if (byte_1000E7D30)
      {
        int v24 = *__error();
        uint64_t v25 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136447234;
          BOOL v85 = sub_10002EF3C(a1);
          __int16 v86 = 1024;
          *(_DWORD *)id v87 = a1;
          *(_WORD *)&v87[4] = 2048;
          *(void *)&v87[6] = objc_msgSend(objc_msgSend(v18, "total"), "num_out_of_order");
          *(_WORD *)&v87[14] = 2048;
          *(void *)&v87[16] = objc_msgSend(objc_msgSend(v18, "total"), "num_missing_load_info");
          __int16 v88 = 2048;
          id v89 = objc_msgSend(v18, "bytes_not_microstackshots");
          _os_log_impl( (void *)&_mh_execute_header,  v25,  OS_LOG_TYPE_DEFAULT,  "%{public}s [%d]: disk writes: some microstackshots with errors: %llu out-of-order microstackshots, %llu micr ostackshots missing load infos, %llu bytes invalid",  buf,  0x30u);
        }

        *__error() = v24;
      }

      if (byte_1000E7D31 && dword_1000E74E0 <= 2)
      {
        int v26 = *__error();
        uint64_t v27 = sub_10002EF3C(a1);
        uint64_t v28 = CFStringCreateWithFormat( kCFAllocatorDefault,  0,  @"%s [%d]: disk writes: some microstackshots with errors: %llu out-of-order microstackshots, %llu microstackshots missing load infos, %llu bytes invalid",  v27,  a1,  objc_msgSend(objc_msgSend(v18, "total"), "num_out_of_order"),  objc_msgSend(objc_msgSend(v18, "total"), "num_missing_load_info"),  objc_msgSend(v18, "bytes_not_microstackshots"));
        if (!v28)
        {
          uint64_t v29 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v29, OS_LOG_TYPE_FAULT)) {
            sub_100083634(a1, v18, v29);
          }
LABEL_81:
          if (qword_1000E7D38) {
            int v58 = (FILE *)qword_1000E7D38;
          }
          else {
            int v58 = __stderrp;
          }
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v58);
LABEL_85:
          *__error() = v26;
          goto LABEL_86;
        }

        goto LABEL_36;
      }

      goto LABEL_86;
    }

    if (byte_1000E7D30)
    {
      int v46 = *__error();
      int v47 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v47, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 134218496;
        BOOL v85 = objc_msgSend(objc_msgSend(v18, "total"), "num_out_of_order");
        __int16 v86 = 2048;
        *(void *)id v87 = objc_msgSend(objc_msgSend(v18, "total"), "num_missing_load_info");
        *(_WORD *)&v87[8] = 2048;
        *(void *)&v87[10] = objc_msgSend(v18, "bytes_not_microstackshots");
        _os_log_impl( (void *)&_mh_execute_header,  v47,  OS_LOG_TYPE_DEFAULT,  "disk writes: some microstackshots with errors: %llu out-of-order microstackshots, %llu microstackshots missing load infos, %llu bytes invalid",  buf,  0x20u);
      }

      *__error() = v46;
    }

    if (byte_1000E7D31 && dword_1000E74E0 <= 2)
    {
      int v43 = *__error();
      int v44 = CFStringCreateWithFormat( kCFAllocatorDefault,  0,  @"disk writes: some microstackshots with errors: %llu out-of-order microstackshots, %llu microstackshots missing load infos, %llu bytes invalid",  objc_msgSend(objc_msgSend(v18, "total"), "num_out_of_order"),  objc_msgSend(objc_msgSend(v18, "total"), "num_missing_load_info"),  objc_msgSend(v18, "bytes_not_microstackshots"));
      if (!v44)
      {
        int v48 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v48, OS_LOG_TYPE_FAULT)) {
          sub_1000836C0();
        }
LABEL_106:
        if (qword_1000E7D38) {
          uint64_t v72 = (FILE *)qword_1000E7D38;
        }
        else {
          uint64_t v72 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v72);
LABEL_110:
        *__error() = v43;
        goto LABEL_111;
      }

      goto LABEL_70;
    }
  }

  else
  {
    if ((a1 & 0x80000000) == 0)
    {
      if (byte_1000E7D30)
      {
        int v34 = *__error();
        uint64_t v35 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v35, OS_LOG_TYPE_DEBUG)) {
          sub_1000833E0(a1, v18, v35);
        }
        *__error() = v34;
      }

      if (byte_1000E7D31 && dword_1000E74E0 <= 0)
      {
        int v26 = *__error();
        uint64_t v36 = sub_10002EF3C(a1);
        uint64_t v28 = CFStringCreateWithFormat( kCFAllocatorDefault,  0,  @"%s [%d]: disk writes: all microstackshots without errors: %llu out-of-order microstackshots, %llu microstackshots missing load infos, %llu bytes invalid",  v36,  a1,  objc_msgSend(objc_msgSend(v18, "total"), "num_out_of_order"),  objc_msgSend(objc_msgSend(v18, "total"), "num_missing_load_info"),  objc_msgSend(v18, "bytes_not_microstackshots"));
        if (!v28)
        {
          uint64_t v57 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v57, OS_LOG_TYPE_FAULT)) {
            sub_100083354(a1, v18, v57);
          }
          goto LABEL_81;
        }

void sub_1000421D8( uint64_t a1, NSString *a2, uint64_t a3, uint64_t a4, _DWORD *a5, uint64_t a6, double a7, double a8, double a9)
{
  if ((a1 & 0x80000000) == 0)
  {
    if (byte_1000E7D30)
    {
      int v17 = *__error();
      id v18 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v18, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)buf = 136447234;
        id v150 = sub_10002EF3C(a1);
        __int16 v151 = 1024;
        *(_DWORD *)id v152 = a1;
        *(_WORD *)&v152[4] = 2048;
        *(void *)&v152[6] = a5;
        *(_WORD *)&v152[14] = 2048;
        *(double *)&v152[16] = a7;
        __int16 v153 = 2048;
        uint64_t v154 = a3;
        _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_INFO,  "%{public}s [%d]: disk writes: %llu bytes over the last %.0f seconds with flags %#llx",  buf,  0x30u);
      }

      *__error() = v17;
    }

    if (byte_1000E7D31) {
      BOOL v19 = dword_1000E74E0 <= 1;
    }
    else {
      BOOL v19 = 0;
    }
    if (!v19) {
      goto LABEL_52;
    }
    int v20 = *__error();
    uint64_t v21 = sub_10002EF3C(a1);
    uint64_t v22 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"%s [%d]: disk writes: %llu bytes over the last %.0f seconds with flags %#llx",  v21,  a1,  a5,  *(void *)&a7,  a3);
    if (v22)
    {
      uint64_t v23 = v22;
      int v24 = a2;
      CStringPtr = CFStringGetCStringPtr(v22, 0x8000100u);
      if (CStringPtr)
      {
        int v26 = (char *)CStringPtr;
        uint64_t v27 = 0LL;
      }

      else
      {
        int v26 = (char *)calloc(0x400uLL, 1uLL);
        CFStringGetCString(v23, v26, 1024LL, 0x8000100u);
        uint64_t v27 = v26;
      }

      if (qword_1000E7D38) {
        double v39 = (FILE *)qword_1000E7D38;
      }
      else {
        double v39 = __stderrp;
      }
      fprintf(v39, "%s\n", v26);
      if (v27) {
        free(v27);
      }
      CFRelease(v23);
      a2 = v24;
      goto LABEL_51;
    }

    uint64_t v37 = (os_log_s *)sub_10002EFA0();
    if (os_log_type_enabled(v37, OS_LOG_TYPE_FAULT))
    {
      id v135 = sub_10002EF3C(a1);
      *(_DWORD *)buf = 136316162;
      id v150 = v135;
      __int16 v151 = 1024;
      *(_DWORD *)id v152 = a1;
      *(_WORD *)&v152[4] = 2048;
      *(void *)&v152[6] = a5;
      *(_WORD *)&v152[14] = 2048;
      *(double *)&v152[16] = a7;
      __int16 v153 = 2048;
      uint64_t v154 = a3;
      _os_log_fault_impl( (void *)&_mh_execute_header,  v37,  OS_LOG_TYPE_FAULT,  "Unable to format: %s [%d]: disk writes: %llu bytes over the last %.0f seconds with flags %#llx",  buf,  0x30u);
    }

    if (qword_1000E7D38) {
      int v38 = (FILE *)qword_1000E7D38;
    }
    else {
      int v38 = __stderrp;
    }
LABEL_31:
    fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v38);
LABEL_51:
    *__error() = v20;
    goto LABEL_52;
  }

  if (byte_1000E7D30)
  {
    int v28 = *__error();
    uint64_t v29 = (os_log_s *)sub_10002EFA0();
    if (os_log_type_enabled(v29, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 134218496;
      id v150 = a5;
      __int16 v151 = 2048;
      *(double *)id v152 = a7;
      *(_WORD *)&v152[8] = 2048;
      *(void *)&v152[10] = a3;
      _os_log_impl( (void *)&_mh_execute_header,  v29,  OS_LOG_TYPE_INFO,  "disk writes: %llu bytes over the last %.0f seconds with flags %#llx",  buf,  0x20u);
    }

    *__error() = v28;
  }

  if (byte_1000E7D31) {
    BOOL v30 = dword_1000E74E0 <= 1;
  }
  else {
    BOOL v30 = 0;
  }
  if (v30)
  {
    int v20 = *__error();
    BOOL v31 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"disk writes: %llu bytes over the last %.0f seconds with flags %#llx",  a5,  *(void *)&a7,  a3);
    if (v31)
    {
      int v32 = v31;
      uint64_t v33 = a2;
      int v34 = CFStringGetCStringPtr(v31, 0x8000100u);
      if (v34)
      {
        uint64_t v35 = (char *)v34;
        uint64_t v36 = 0LL;
      }

      else
      {
        uint64_t v35 = (char *)calloc(0x400uLL, 1uLL);
        CFStringGetCString(v32, v35, 1024LL, 0x8000100u);
        uint64_t v36 = v35;
      }

      if (qword_1000E7D38) {
        int v41 = (FILE *)qword_1000E7D38;
      }
      else {
        int v41 = __stderrp;
      }
      fprintf(v41, "%s\n", v35);
      if (v36) {
        free(v36);
      }
      CFRelease(v32);
      a2 = v33;
      goto LABEL_51;
    }

    int v40 = (os_log_s *)sub_10002EFA0();
    if (os_log_type_enabled(v40, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 134218496;
      id v150 = a5;
      __int16 v151 = 2048;
      *(double *)id v152 = a7;
      *(_WORD *)&v152[8] = 2048;
      *(void *)&v152[10] = a3;
      _os_log_fault_impl( (void *)&_mh_execute_header,  v40,  OS_LOG_TYPE_FAULT,  "Unable to format: disk writes: %llu bytes over the last %.0f seconds with flags %#llx",  buf,  0x20u);
    }

    if (qword_1000E7D38) {
      int v38 = (FILE *)qword_1000E7D38;
    }
    else {
      int v38 = __stderrp;
    }
    goto LABEL_31;
  }

LABEL_165:
    int v104 = v100;
    double v105 = CFStringGetCStringPtr(v100, 0x8000100u);
    if (v105)
    {
      qos_class_t v106 = (char *)v105;
      id v107 = 0LL;
    }

    else
    {
      qos_class_t v106 = (char *)calloc(0x400uLL, 1uLL);
      CFStringGetCString(v104, v106, 1024LL, 0x8000100u);
      id v107 = v106;
    }

    if (qword_1000E7D38) {
      unint64_t v108 = (FILE *)qword_1000E7D38;
    }
    else {
      unint64_t v108 = __stderrp;
    }
    fprintf(v108, "%s\n", v106);
    if (v107) {
      free(v107);
    }
    CFRelease(v104);
    goto LABEL_180;
  }

  if (byte_1000E7D30)
  {
    int v95 = *__error();
    id v96 = (os_log_s *)sub_10002EFA0();
    if (os_log_type_enabled(v96, OS_LOG_TYPE_DEFAULT))
    {
      unsigned __int8 v97 = sub_10002EF3C(a1);
      *(_DWORD *)buf = 136446722;
      id v150 = v97;
      __int16 v151 = 1024;
      *(_DWORD *)id v152 = a1;
      *(_WORD *)&v152[4] = 2048;
      *(void *)&v152[6] = v43;
      _os_log_impl( (void *)&_mh_execute_header,  v96,  OS_LOG_TYPE_DEFAULT,  "%{public}s [%d]: disk writes: not monitoring due to conditions %#llx",  buf,  0x1Cu);
    }

    *__error() = v95;
  }

  if (!byte_1000E7D31 || dword_1000E74E0 > 2) {
    goto LABEL_181;
  }
  int v98 = *__error();
  int v99 = sub_10002EF3C(a1);
  id v100 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"%s [%d]: disk writes: not monitoring due to conditions %#llx",  v99,  a1,  v43);
  if (v100) {
    goto LABEL_165;
  }
  uint64_t v101 = (os_log_s *)sub_10002EFA0();
  if (os_log_type_enabled(v101, OS_LOG_TYPE_FAULT)) {
    sub_100083964();
  }
LABEL_176:
  if (qword_1000E7D38) {
    uint64_t v110 = (FILE *)qword_1000E7D38;
  }
  else {
    uint64_t v110 = __stderrp;
  }
  fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v110);
LABEL_180:
  *__error() = v98;
LABEL_181:
  uint64_t v111 = v148;
  double v112 = a8 - a7;
  int v113 = a1;
  id v114 = v42;
  uint64_t v115 = v145;
  uint64_t v116 = v43;
  double v117 = a8;
  uint64_t v118 = (uint64_t)a5;
LABEL_182:
  sub_10002FD6C(v113, v114, v115, v116, v111, v118, v112, v117);
}

  if (qword_1000E7D38) {
    uint64_t v116 = (FILE *)qword_1000E7D38;
  }
  else {
    uint64_t v116 = __stderrp;
  }
  fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v116);
LABEL_169:
  uint64_t v16 = 0LL;
  *__error() = v48;
LABEL_220:
  objc_autoreleasePoolPop(v13);
  return v16;
}

void sub_100043474(uint64_t a1)
{
  uint64_t v2 = sub_100041538( *(unsigned int *)(a1 + 120),  *(void **)(a1 + 32),  *(void *)(a1 + 56),  *(void **)(a1 + 40),  *(void *)(a1 + 64),  *(void *)(a1 + 88),  *(double *)(a1 + 72),  *(double *)(a1 + 80),  *(double *)(a1 + 96));
  sub_10002FD6C( *(_DWORD *)(a1 + 120),  *(void **)(a1 + 32),  *(void *)(a1 + 104),  v2,  *(void *)(a1 + 112) | v3,  *(void *)(a1 + 64),  *(double *)(a1 + 80) - *(double *)(a1 + 72),  *(double *)(a1 + 80));
}

void sub_1000434D8( uint64_t a1, NSString *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, mach_port_name_t a7)
{
  mach_port_name_t v7 = a7;
  uint64_t v94 = a4;
  unsigned int v96 = a7 - 1;
  if (a7 - 1 > 0xFFFFFFFD)
  {
    if ((a1 & 0x80000000) != 0)
    {
      if (byte_1000E7D30)
      {
        int v35 = *__error();
        uint64_t v36 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v36, OS_LOG_TYPE_INFO))
        {
          *(_DWORD *)buf = 134218240;
          int v102 = (_DWORD *)a5;
          __int16 v103 = 2048;
          *(void *)int v104 = a3;
          _os_log_impl( (void *)&_mh_execute_header,  v36,  OS_LOG_TYPE_INFO,  "file descriptor exhaustion: %llu fds with flags %#llx",  buf,  0x16u);
        }

        *__error() = v35;
      }

      if (byte_1000E7D31) {
        BOOL v37 = dword_1000E74E0 <= 1;
      }
      else {
        BOOL v37 = 0;
      }
      if (v37)
      {
        int v16 = *__error();
        int v38 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"file descriptor exhaustion: %llu fds with flags %#llx",  a5,  a3);
        if (v38)
        {
          double v39 = v38;
          int v40 = a2;
          uint64_t v41 = a5;
          uint64_t v42 = a6;
          mach_port_name_t v43 = v7;
          CStringPtr = CFStringGetCStringPtr(v38, 0x8000100u);
          if (CStringPtr)
          {
            int v45 = (char *)CStringPtr;
            int v46 = 0LL;
          }

          else
          {
            int v45 = (char *)calloc(0x400uLL, 1uLL);
            CFStringGetCString(v39, v45, 1024LL, 0x8000100u);
            int v46 = v45;
          }

          if (qword_1000E7D38) {
            uint64_t v53 = (FILE *)qword_1000E7D38;
          }
          else {
            uint64_t v53 = __stderrp;
          }
          fprintf(v53, "%s\n", v45);
          if (v46) {
            free(v46);
          }
          CFRelease(v39);
          mach_port_name_t v7 = v43;
          a6 = v42;
          a5 = v41;
          a2 = v40;
          goto LABEL_77;
        }

        int v52 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v52, OS_LOG_TYPE_FAULT)) {
          sub_100084090();
        }
        uint64_t v49 = qword_1000E7D38;
        int v50 = __stderrp;
        goto LABEL_63;
      }
    }

    else
    {
      if (byte_1000E7D30)
      {
        int v22 = *__error();
        uint64_t v23 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v23, OS_LOG_TYPE_INFO))
        {
          *(_DWORD *)buf = 136446978;
          int v102 = sub_10002EF3C(a1);
          __int16 v103 = 1024;
          *(_DWORD *)int v104 = a1;
          *(_WORD *)&v104[4] = 2048;
          *(void *)&v104[6] = a5;
          __int16 v105 = 2048;
          uint64_t v106 = a3;
          _os_log_impl( (void *)&_mh_execute_header,  v23,  OS_LOG_TYPE_INFO,  "%{public}s [%d]: file descriptor exhaustion: %llu fds with flags %#llx",  buf,  0x26u);
        }

        *__error() = v22;
      }

      if (byte_1000E7D31) {
        BOOL v24 = dword_1000E74E0 <= 1;
      }
      else {
        BOOL v24 = 0;
      }
      if (v24)
      {
        int v16 = *__error();
        uint64_t v25 = sub_10002EF3C(a1);
        id v18 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"%s [%d]: file descriptor exhaustion: %llu fds with flags %#llx",  v25,  a1,  a5,  a3,  v94);
        if (!v18)
        {
          BOOL v19 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v19, OS_LOG_TYPE_FAULT))
          {
            int v26 = sub_10002EF3C(a1);
            *(_DWORD *)buf = 136315906;
            int v102 = v26;
            __int16 v103 = 1024;
            *(_DWORD *)int v104 = a1;
            *(_WORD *)&v104[4] = 2048;
            *(void *)&v104[6] = a5;
            __int16 v105 = 2048;
            uint64_t v106 = a3;
            uint64_t v21 = "Unable to format: %s [%d]: file descriptor exhaustion: %llu fds with flags %#llx";
            goto LABEL_28;
          }

LABEL_62:
          uint64_t v49 = qword_1000E7D38;
          int v50 = __stderrp;
LABEL_63:
          if (v49) {
            int v51 = (FILE *)v49;
          }
          else {
            int v51 = v50;
          }
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v51);
LABEL_77:
          *__error() = v16;
          goto LABEL_78;
        }

          uint64_t v49 = qword_1000E7D38;
          int v50 = __stderrp;
LABEL_63:
          if (v49) {
            int v51 = (FILE *)v49;
          }
          else {
            int v51 = v50;
          }
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v51);
LABEL_77:
          *__error() = v16;
          goto LABEL_78;
        }

          uint64_t v49 = qword_1000E7D38;
          int v50 = __stderrp;
LABEL_63:
          if (v49) {
            int v51 = (FILE *)v49;
          }
          else {
            int v51 = v50;
          }
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v51);
LABEL_77:
          *__error() = v16;
          goto LABEL_78;
        }

            if ((a1 & 0x80000000) != 0)
            {
              if (byte_1000E7D30)
              {
                uint64_t v131 = *__error();
                uint64_t v132 = (os_log_s *)sub_10002EFA0();
                if (os_log_type_enabled(v132, OS_LOG_TYPE_ERROR)) {
                  sub_100086734();
                }
                *__error() = v131;
              }

              if (byte_1000E7D31) {
                qos_class_t v133 = dword_1000E74E0 <= 3;
              }
              else {
                qos_class_t v133 = 0;
              }
              if (!v133) {
                goto LABEL_308;
              }
              int v73 = *__error();
              int v75 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"Attemping to generate spindump, but not entitled");
              if (!v75)
              {
                int v173 = (os_log_s *)sub_10002EFA0();
                if (os_log_type_enabled(v173, OS_LOG_TYPE_FAULT)) {
                  sub_100086708();
                }
                goto LABEL_303;
              }
            }

            else
            {
              if (byte_1000E7D30)
              {
                uint64_t v70 = *__error();
                int v71 = (os_log_s *)sub_10002EFA0();
                if (os_log_type_enabled(v71, OS_LOG_TYPE_ERROR)) {
                  sub_100086688(a1, v71);
                }
                *__error() = v70;
              }

              if (byte_1000E7D31) {
                int v72 = dword_1000E74E0 <= 3;
              }
              else {
                int v72 = 0;
              }
              if (!v72) {
                goto LABEL_308;
              }
              int v73 = *__error();
              int v74 = sub_10002EF3C(a1);
              int v75 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"%s [%d]: Attemping to generate spindump, but not entitled",  v74,  a1);
              if (!v75)
              {
                id v76 = (os_log_s *)sub_10002EFA0();
                if (os_log_type_enabled(v76, OS_LOG_TYPE_FAULT)) {
                  sub_100086608(a1, v76);
                }
LABEL_303:
                if (qword_1000E7D38) {
                  uint64_t v174 = (FILE *)qword_1000E7D38;
                }
                else {
                  uint64_t v174 = __stderrp;
                }
                fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v174);
LABEL_307:
                *__error() = v73;
LABEL_308:
                if (v33)
                {
                  xpc_dictionary_set_int64(v45, "errno", 1LL);
                  xpc_connection_send_message(v39, v45);
                  xpc_release(v45);
                }

                return;
              }
            }

            dispatch_queue_global_t v134 = v75;
            CStringPtr = CFStringGetCStringPtr(v75, 0x8000100u);
            if (CStringPtr)
            {
              uint64_t v136 = (char *)CStringPtr;
              int v137 = 0LL;
            }

            else
            {
              uint64_t v136 = (char *)calloc(0x400uLL, 1uLL);
              CFStringGetCString(v134, v136, 1024LL, 0x8000100u);
              int v137 = v136;
            }

            if (qword_1000E7D38) {
              int v165 = (FILE *)qword_1000E7D38;
            }
            else {
              int v165 = __stderrp;
            }
            fprintf(v165, "%s\n", v136);
            if (v137) {
              free(v137);
            }
            CFRelease(v134);
            goto LABEL_307;
          }

          if (byte_1000E7D30)
          {
            int v238 = *__error();
            uint64_t v239 = (os_log_s *)sub_10002EFA0();
            if (os_log_type_enabled(v239, OS_LOG_TYPE_ERROR)) {
              sub_100086598(v239, v240, v241, v242, v243, v244, v245, v246);
            }
            *__error() = v238;
          }

          if (byte_1000E7D31) {
            v247 = dword_1000E74E0 <= 3;
          }
          else {
            v247 = 0;
          }
          if (v247)
          {
            int v248 = *__error();
            int v249 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"%s: unable to create reply", "reply");
            if (v249)
            {
              v267 = v249;
              v268 = CFStringGetCStringPtr(v249, 0x8000100u);
              if (v268)
              {
                id v269 = (char *)v268;
                id v270 = 0LL;
              }

              else
              {
                id v269 = (char *)calloc(0x400uLL, 1uLL);
                CFStringGetCString(v267, v269, 1024LL, 0x8000100u);
                id v270 = v269;
              }

              if (qword_1000E7D38) {
                v274 = (FILE *)qword_1000E7D38;
              }
              else {
                v274 = __stderrp;
              }
              fprintf(v274, "%s\n", v269);
              if (v270) {
                free(v270);
              }
              CFRelease(v267);
            }

            else
            {
              BOOL v250 = (os_log_s *)sub_10002EFA0();
              if (os_log_type_enabled(v250, OS_LOG_TYPE_FAULT)) {
                sub_100086528(v250, v251, v252, v253, v254, v255, v256, v257);
              }
              if (qword_1000E7D38) {
                unsigned int v258 = (FILE *)qword_1000E7D38;
              }
              else {
                unsigned int v258 = __stderrp;
              }
              fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v258);
            }

            *__error() = v248;
          }

          sub_10002EE78( "SPHandleGenerateSpindump",  "reading.m",  257,  "%s: unable to create reply",  v41,  v42,  v43,  v44,  (char)"reply");
        }

        else
        {
          if (byte_1000E7D30)
          {
            int v217 = *__error();
            id v218 = (os_log_s *)sub_10002EFA0();
            if (os_log_type_enabled(v218, OS_LOG_TYPE_ERROR)) {
              sub_1000864B8(v218, v219, v220, v221, v222, v223, v224, v225);
            }
            *__error() = v217;
          }

          if (byte_1000E7D31) {
            int v226 = dword_1000E74E0 <= 3;
          }
          else {
            int v226 = 0;
          }
          if (v226)
          {
            id v227 = *__error();
            id v228 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"%s: unable to get connection",  "connection");
            if (v228)
            {
              id v263 = v228;
              id v264 = CFStringGetCStringPtr(v228, 0x8000100u);
              if (v264)
              {
                unsigned int v265 = (char *)v264;
                id v266 = 0LL;
              }

              else
              {
                unsigned int v265 = (char *)calloc(0x400uLL, 1uLL);
                CFStringGetCString(v263, v265, 1024LL, 0x8000100u);
                id v266 = v265;
              }

              if (qword_1000E7D38) {
                int v273 = (FILE *)qword_1000E7D38;
              }
              else {
                int v273 = __stderrp;
              }
              fprintf(v273, "%s\n", v265);
              if (v266) {
                free(v266);
              }
              CFRelease(v263);
            }

            else
            {
              uint64_t v229 = (os_log_s *)sub_10002EFA0();
              if (os_log_type_enabled(v229, OS_LOG_TYPE_FAULT)) {
                sub_100086448(v229, v230, v231, v232, v233, v234, v235, v236);
              }
              if (qword_1000E7D38) {
                v237 = (FILE *)qword_1000E7D38;
              }
              else {
                v237 = __stderrp;
              }
              fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v237);
            }

            *__error() = v227;
          }

          sub_10002EE78( "SPHandleGenerateSpindump",  "reading.m",  255,  "%s: unable to get connection",  v35,  v36,  v37,  v38,  (char)"connection");
        }

        abort();
      }

      int v45 = 0LL;
      double v39 = 0LL;
      if ((a2 & 1) != 0) {
        goto LABEL_45;
      }
      goto LABEL_62;
    case 11LL:
      int v48 = xpc_dictionary_get_int64(xdict, "pid");
      if (!(_DWORD)v48)
      {
        if (byte_1000E7D30)
        {
          mach_port_name_t v87 = *__error();
          __int16 v88 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v88, OS_LOG_TYPE_ERROR)) {
            sub_100087004();
          }
          *__error() = v87;
        }

        if (byte_1000E7D31) {
          int v89 = dword_1000E74E0 <= 3;
        }
        else {
          int v89 = 0;
        }
        if (!v89) {
          return;
        }
        BOOL v15 = *__error();
        int v16 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"Error reporting fd exhaustion: no pid provided");
        if (v16) {
          goto LABEL_292;
        }
        __int16 v90 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v90, OS_LOG_TYPE_FAULT)) {
          sub_100086FD8();
        }
        goto LABEL_335;
      }

      uint64_t v49 = xpc_dictionary_get_uint64(xdict, "flags");
      int v50 = xpc_dictionary_get_int64(xdict, "num_fds");
      if (v50)
      {
        int v51 = v50;
        int v52 = xpc_dictionary_get_int64(xdict, "num_fds_limit");
        uint64_t v53 = xpc_dictionary_get_string(xdict, "pname");
        if (v53) {
          uint64_t v54 = +[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v53);
        }
        else {
          uint64_t v54 = 0LL;
        }
        id v144 = xpc_dictionary_get_string(xdict, "action");
        if (v144)
        {
          uint64_t v145 = sub_100055AE4(v144);
          id v146 = +[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v145);
          free(v145);
        }

        else
        {
          id v146 = 0LL;
        }

        __int16 v153 = xpc_dictionary_copy_mach_send(xdict, "fatal_port");
        sub_1000434D8(v48, v54, v49, (uint64_t)v146, v51, v52, v153);
        return;
      }

      if (byte_1000E7D30)
      {
        id v107 = *__error();
        unint64_t v108 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v108, OS_LOG_TYPE_ERROR)) {
          sub_10008705C();
        }
        *__error() = v107;
      }

      if (byte_1000E7D31) {
        int v109 = dword_1000E74E0 <= 3;
      }
      else {
        int v109 = 0;
      }
      if (v109)
      {
        BOOL v15 = *__error();
        int v16 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"Error reporting fd exhaustion: no num fds provided");
        if (v16) {
          goto LABEL_292;
        }
        uint64_t v110 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v110, OS_LOG_TYPE_FAULT)) {
          sub_100087030();
        }
        goto LABEL_335;
      }

      return;
    case 12LL:
      uint64_t v55 = xpc_dictionary_get_int64(xdict, "pid");
      if (!(_DWORD)v55)
      {
        if (byte_1000E7D30)
        {
          id v91 = *__error();
          int v92 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v92, OS_LOG_TYPE_ERROR)) {
            sub_1000870B4();
          }
          *__error() = v91;
        }

        if (byte_1000E7D31) {
          uint64_t v93 = dword_1000E74E0 <= 3;
        }
        else {
          uint64_t v93 = 0;
        }
        if (!v93) {
          return;
        }
        BOOL v15 = *__error();
        int v16 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"Error reporting port exhaustion: no pid provided");
        if (v16) {
          goto LABEL_292;
        }
        uint64_t v94 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v94, OS_LOG_TYPE_FAULT)) {
          sub_100087088();
        }
        goto LABEL_335;
      }

      int v56 = xpc_dictionary_get_uint64(xdict, "flags");
      uint64_t v57 = xpc_dictionary_get_int64(xdict, "num_ports");
      if (v57)
      {
        int v58 = v57;
        int v59 = xpc_dictionary_get_int64(xdict, "num_ports_limit");
        int v60 = xpc_dictionary_get_string(xdict, "pname");
        if (v60) {
          int v61 = +[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v60);
        }
        else {
          int v61 = 0LL;
        }
        int v147 = xpc_dictionary_get_string(xdict, "action");
        if (v147)
        {
          uint64_t v148 = sub_100055AE4(v147);
          id v149 = +[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v148);
          free(v148);
        }

        else
        {
          id v149 = 0LL;
        }

        uint64_t v154 = xpc_dictionary_copy_mach_send(xdict, "fatal_port");
        sub_1000441D8(v55, v61, v56, (uint64_t)v149, v58, v59, v154);
        return;
      }

      if (byte_1000E7D30)
      {
        uint64_t v111 = *__error();
        double v112 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v112, OS_LOG_TYPE_ERROR)) {
          sub_10008710C();
        }
        *__error() = v111;
      }

      if (byte_1000E7D31) {
        int v113 = dword_1000E74E0 <= 3;
      }
      else {
        int v113 = 0;
      }
      if (v113)
      {
        BOOL v15 = *__error();
        int v16 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"Error reporting port exhaustion: no num ports provided");
        if (v16) {
          goto LABEL_292;
        }
        id v114 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v114, OS_LOG_TYPE_FAULT)) {
          sub_1000870E0();
        }
        goto LABEL_335;
      }

      return;
    case 13LL:
      int v62 = xpc_dictionary_get_string(xdict, "filename");
      if (v62)
      {
        sub_100031D60(v62);
        return;
      }

      if (byte_1000E7D30)
      {
        int v95 = *__error();
        unsigned int v96 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v96, OS_LOG_TYPE_ERROR)) {
          sub_100087214();
        }
        *__error() = v95;
      }

      if (byte_1000E7D31) {
        uint64_t v97 = dword_1000E74E0 <= 3;
      }
      else {
        uint64_t v97 = 0;
      }
      if (!v97) {
        return;
      }
      BOOL v15 = *__error();
      int v16 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"Error reporting workflow repsonsiveness delay: no tailspin file provided");
      if (v16) {
        goto LABEL_292;
      }
      int v98 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v98, OS_LOG_TYPE_FAULT)) {
        sub_1000871E8();
      }
      goto LABEL_335;
    case 14LL:
      int v63 = xpc_dictionary_get_int64(xdict, "pid");
      if (!(_DWORD)v63)
      {
        if (byte_1000E7D30)
        {
          int v99 = *__error();
          uint64_t v100 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v100, OS_LOG_TYPE_ERROR)) {
            sub_100087164();
          }
          *__error() = v99;
        }

        if (byte_1000E7D31) {
          uint64_t v101 = dword_1000E74E0 <= 3;
        }
        else {
          uint64_t v101 = 0;
        }
        if (!v101) {
          return;
        }
        BOOL v15 = *__error();
        int v16 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"Error reporting kqworkloop exhaustion: no pid provided");
        if (v16) {
          goto LABEL_292;
        }
        int v102 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v102, OS_LOG_TYPE_FAULT)) {
          sub_100087138();
        }
        goto LABEL_335;
      }

      uint64_t v64 = xpc_dictionary_get_uint64(xdict, "flags");
      uint64_t v65 = xpc_dictionary_get_int64(xdict, "num_kqworkloops");
      if (v65)
      {
        uint64_t v66 = v65;
        mach_port_name_t v67 = xpc_dictionary_get_int64(xdict, "num_kqworkloops_limit");
        uint64_t v68 = xpc_dictionary_get_string(xdict, "pname");
        if (v68) {
          uint64_t v69 = +[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v68);
        }
        else {
          uint64_t v69 = 0LL;
        }
        id v150 = xpc_dictionary_get_string(xdict, "action");
        if (v150)
        {
          __int16 v151 = sub_100055AE4(v150);
          id v152 = +[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v151);
          free(v151);
        }

        else
        {
          id v152 = 0LL;
        }

        char v155 = xpc_dictionary_copy_mach_send(xdict, "fatal_port");
        sub_100044ED8(v63, v69, v64, (uint64_t)v152, v66, v67, v155);
        return;
      }

      if (byte_1000E7D30)
      {
        uint64_t v115 = *__error();
        uint64_t v116 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v116, OS_LOG_TYPE_ERROR)) {
          sub_1000871BC();
        }
        *__error() = v115;
      }

      if (byte_1000E7D31) {
        double v117 = dword_1000E74E0 <= 3;
      }
      else {
        double v117 = 0;
      }
      if (v117)
      {
        BOOL v15 = *__error();
        int v16 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"Error reporting kqworkloop exhaustion: no num kqworkloops provided");
        if (v16) {
          goto LABEL_292;
        }
        uint64_t v118 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v118, OS_LOG_TYPE_FAULT)) {
          sub_100087190();
        }
        goto LABEL_335;
      }

      return;
    default:
      id v18 = *__error();
      BOOL v19 = (os_log_s *)sub_10002EFA0();
      int v20 = os_log_type_enabled(v19, OS_LOG_TYPE_FAULT);
      if ((a1 & 0x80000000) == 0)
      {
        if (v20) {
          sub_100086310(a1);
        }
        *__error() = v18;
        if (byte_1000E7D31) {
          uint64_t v21 = dword_1000E74E0 <= 4;
        }
        else {
          uint64_t v21 = 0;
        }
        if (!v21) {
          return;
        }
        BOOL v15 = *__error();
        int v22 = sub_10002EF3C(a1);
        int v16 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"%s [%d]: Unknown message to libspindump (%lld)",  v22,  a1,  int64);
        if (!v16)
        {
          uint64_t v23 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v23, OS_LOG_TYPE_FAULT)) {
            sub_100086298(a1);
          }
LABEL_335:
          if (qword_1000E7D38) {
            int v189 = (FILE *)qword_1000E7D38;
          }
          else {
            int v189 = __stderrp;
          }
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v189);
LABEL_339:
          *__error() = v15;
          return;
        }

        goto LABEL_292;
      }

      if (v20) {
        sub_1000863E8();
      }
      *__error() = v18;
      if (byte_1000E7D31) {
        int v81 = dword_1000E74E0 <= 4;
      }
      else {
        int v81 = 0;
      }
      if (v81)
      {
        BOOL v15 = *__error();
        int v16 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"Unknown message to libspindump (%lld)", int64);
        if (!v16)
        {
          int v82 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v82, OS_LOG_TYPE_FAULT)) {
            sub_100086388();
          }
          goto LABEL_335;
        }

LABEL_78:
  uint64_t v97 = sub_10002F014(a1);
  if (!a2) {
    a2 = sub_10002F04C(a1);
  }
  uint64_t v100 = 0LL;
  uint64_t v54 = sub_1000409B4(a1, (uint64_t)"file descriptor exhaustion", 176, &v100);
  uint64_t v55 = v54;
  if ((word_1000E7D70 & 4) != 0)
  {
    if ((a1 & 0x80000000) != 0)
    {
      if (byte_1000E7D30)
      {
        int v62 = *__error();
        int v63 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v63, OS_LOG_TYPE_DEBUG)) {
          sub_100084004();
        }
        *__error() = v62;
      }

      if (!byte_1000E7D31 || dword_1000E74E0 > 0) {
        goto LABEL_116;
      }
      int v58 = *__error();
      int v60 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"file descriptor exhaustion: not monitoring due to suppression cookie file");
      if (!v60)
      {
        int v72 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v72, OS_LOG_TYPE_FAULT)) {
          sub_100083FD8();
        }
        goto LABEL_111;
      }
    }

    else
    {
      if (byte_1000E7D30)
      {
        int v56 = *__error();
        uint64_t v57 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v57, OS_LOG_TYPE_DEBUG)) {
          sub_100083F70();
        }
        *__error() = v56;
      }

      if (!byte_1000E7D31 || dword_1000E74E0 > 0) {
        goto LABEL_116;
      }
      int v58 = *__error();
      int v59 = sub_10002EF3C(a1);
      int v60 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"%s [%d]: file descriptor exhaustion: not monitoring due to suppression cookie file",  v59,  a1);
      if (!v60)
      {
        int v61 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v61, OS_LOG_TYPE_FAULT)) {
          sub_100083F08();
        }
LABEL_111:
        if (qword_1000E7D38) {
          int v73 = (FILE *)qword_1000E7D38;
        }
        else {
          int v73 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v73);
LABEL_115:
        *__error() = v58;
LABEL_116:
        v55 |= 0x8000uLL;
        goto LABEL_117;
      }
    }

    uint64_t v64 = v60;
    int v95 = v58;
    uint64_t v65 = a5;
    uint64_t v66 = a6;
    mach_port_name_t v67 = v7;
    uint64_t v68 = CFStringGetCStringPtr(v60, 0x8000100u);
    if (v68)
    {
      uint64_t v69 = (char *)v68;
      uint64_t v70 = 0LL;
    }

    else
    {
      uint64_t v69 = (char *)calloc(0x400uLL, 1uLL);
      CFStringGetCString(v64, v69, 1024LL, 0x8000100u);
      uint64_t v70 = v69;
    }

    if (qword_1000E7D38) {
      int v71 = (FILE *)qword_1000E7D38;
    }
    else {
      int v71 = __stderrp;
    }
    fprintf(v71, "%s\n", v69);
    if (v70) {
      free(v70);
    }
    CFRelease(v64);
    mach_port_name_t v7 = v67;
    a6 = v66;
    a5 = v65;
    int v58 = v95;
    goto LABEL_115;
  }

  if (!v54)
  {
    v98[0] = _NSConcreteStackBlock;
    v98[1] = 3221225472LL;
    v98[2] = sub_1000441BC;
    v98[3] = &unk_1000D8FB0;
    int v99 = a1;
    v98[4] = a2;
    v98[5] = v97;
    v98[6] = v100;
    v98[7] = a5;
    v98[8] = a6;
    sub_100051480(0LL, a1, (uint64_t)a2, a3, v94, a5, a6, v7, (uint64_t)v98);
    return;
  }

  uint64_t v97 = sub_10002F014(a1);
  if (!a2) {
    a2 = sub_10002F04C(a1);
  }
  uint64_t v100 = 0LL;
  uint64_t v54 = sub_1000409B4(a1, (uint64_t)"port exhaustion", 176, &v100);
  uint64_t v55 = v54;
  if ((word_1000E7D70 & 4) != 0)
  {
    if ((a1 & 0x80000000) != 0)
    {
      if (byte_1000E7D30)
      {
        int v62 = *__error();
        int v63 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v63, OS_LOG_TYPE_DEBUG)) {
          sub_1000842B8();
        }
        *__error() = v62;
      }

      if (!byte_1000E7D31 || dword_1000E74E0 > 0) {
        goto LABEL_116;
      }
      int v58 = *__error();
      int v60 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"port exhaustion: not monitoring due to suppression cookie file");
      if (!v60)
      {
        int v72 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v72, OS_LOG_TYPE_FAULT)) {
          sub_10008428C();
        }
        goto LABEL_111;
      }
    }

    else
    {
      if (byte_1000E7D30)
      {
        int v56 = *__error();
        uint64_t v57 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v57, OS_LOG_TYPE_DEBUG)) {
          sub_100084224();
        }
        *__error() = v56;
      }

      if (!byte_1000E7D31 || dword_1000E74E0 > 0) {
        goto LABEL_116;
      }
      int v58 = *__error();
      int v59 = sub_10002EF3C(a1);
      int v60 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"%s [%d]: port exhaustion: not monitoring due to suppression cookie file",  v59,  a1);
      if (!v60)
      {
        int v61 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v61, OS_LOG_TYPE_FAULT)) {
          sub_1000841BC();
        }
LABEL_111:
        if (qword_1000E7D38) {
          int v73 = (FILE *)qword_1000E7D38;
        }
        else {
          int v73 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v73);
LABEL_115:
        *__error() = v58;
LABEL_116:
        v55 |= 0x8000uLL;
        goto LABEL_117;
      }
    }

    uint64_t v64 = v60;
    int v95 = v58;
    uint64_t v65 = a5;
    uint64_t v66 = a6;
    mach_port_name_t v67 = v7;
    uint64_t v68 = CFStringGetCStringPtr(v60, 0x8000100u);
    if (v68)
    {
      uint64_t v69 = (char *)v68;
      uint64_t v70 = 0LL;
    }

    else
    {
      uint64_t v69 = (char *)calloc(0x400uLL, 1uLL);
      CFStringGetCString(v64, v69, 1024LL, 0x8000100u);
      uint64_t v70 = v69;
    }

    if (qword_1000E7D38) {
      int v71 = (FILE *)qword_1000E7D38;
    }
    else {
      int v71 = __stderrp;
    }
    fprintf(v71, "%s\n", v69);
    if (v70) {
      free(v70);
    }
    CFRelease(v64);
    mach_port_name_t v7 = v67;
    a6 = v66;
    a5 = v65;
    int v58 = v95;
    goto LABEL_115;
  }

  if (!v54)
  {
    v98[0] = _NSConcreteStackBlock;
    v98[1] = 3221225472LL;
    v98[2] = sub_100044EBC;
    v98[3] = &unk_1000D8FB0;
    int v99 = a1;
    v98[4] = a2;
    v98[5] = v97;
    v98[6] = v100;
    v98[7] = a5;
    v98[8] = a6;
    sub_100051480(1LL, a1, (uint64_t)a2, a3, v94, a5, a6, v7, (uint64_t)v98);
    return;
  }

  uint64_t v97 = sub_10002F014(a1);
  if (!a2) {
    a2 = sub_10002F04C(a1);
  }
  uint64_t v100 = 0LL;
  uint64_t v54 = sub_1000409B4(a1, (uint64_t)"kqworkloop exhaustion", 176, &v100);
  uint64_t v55 = v54;
  if ((word_1000E7D70 & 4) != 0)
  {
    if ((a1 & 0x80000000) != 0)
    {
      if (byte_1000E7D30)
      {
        int v62 = *__error();
        int v63 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v63, OS_LOG_TYPE_DEBUG)) {
          sub_10008456C();
        }
        *__error() = v62;
      }

      if (!byte_1000E7D31 || dword_1000E74E0 > 0) {
        goto LABEL_116;
      }
      int v58 = *__error();
      int v60 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"kqworkloop exhaustion: not monitoring due to suppression cookie file");
      if (!v60)
      {
        int v72 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v72, OS_LOG_TYPE_FAULT)) {
          sub_100084540();
        }
        goto LABEL_111;
      }
    }

    else
    {
      if (byte_1000E7D30)
      {
        int v56 = *__error();
        uint64_t v57 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v57, OS_LOG_TYPE_DEBUG)) {
          sub_1000844D8();
        }
        *__error() = v56;
      }

      if (!byte_1000E7D31 || dword_1000E74E0 > 0) {
        goto LABEL_116;
      }
      int v58 = *__error();
      int v59 = sub_10002EF3C(a1);
      int v60 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"%s [%d]: kqworkloop exhaustion: not monitoring due to suppression cookie file",  v59,  a1);
      if (!v60)
      {
        int v61 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v61, OS_LOG_TYPE_FAULT)) {
          sub_100084470();
        }
LABEL_111:
        if (qword_1000E7D38) {
          int v73 = (FILE *)qword_1000E7D38;
        }
        else {
          int v73 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v73);
LABEL_115:
        *__error() = v58;
LABEL_116:
        v55 |= 0x8000uLL;
        goto LABEL_117;
      }
    }

    uint64_t v64 = v60;
    int v95 = v58;
    uint64_t v65 = a5;
    uint64_t v66 = a6;
    mach_port_name_t v67 = v7;
    uint64_t v68 = CFStringGetCStringPtr(v60, 0x8000100u);
    if (v68)
    {
      uint64_t v69 = (char *)v68;
      uint64_t v70 = 0LL;
    }

    else
    {
      uint64_t v69 = (char *)calloc(0x400uLL, 1uLL);
      CFStringGetCString(v64, v69, 1024LL, 0x8000100u);
      uint64_t v70 = v69;
    }

    if (qword_1000E7D38) {
      int v71 = (FILE *)qword_1000E7D38;
    }
    else {
      int v71 = __stderrp;
    }
    fprintf(v71, "%s\n", v69);
    if (v70) {
      free(v70);
    }
    CFRelease(v64);
    mach_port_name_t v7 = v67;
    a6 = v66;
    a5 = v65;
    int v58 = v95;
    goto LABEL_115;
  }

  if (!v54)
  {
    v98[0] = _NSConcreteStackBlock;
    v98[1] = 3221225472LL;
    v98[2] = sub_100045BBC;
    v98[3] = &unk_1000D8FB0;
    int v99 = a1;
    v98[4] = a2;
    v98[5] = v97;
    v98[6] = v100;
    v98[7] = a5;
    v98[8] = a6;
    sub_100051480(2LL, a1, (uint64_t)a2, a3, v94, a5, a6, v7, (uint64_t)v98);
    return;
  }

                -[NSMutableArray addObject:](v36, "addObject:", v52);
                dispatch_semaphore_signal(dsema);
                goto LABEL_61;
              }

              if ((v9[i] & 0x80000000) != 0)
              {
                if (byte_1000E7D30)
                {
                  uint64_t v201 = *__error();
                  uint64_t v65 = (os_log_s *)sub_10002EFA0();
                  if (os_log_type_enabled(v65, OS_LOG_TYPE_ERROR))
                  {
                    cfh = *__error();
                    int v119 = __error();
                    uint64_t v120 = strerror(*v119);
                    *(_DWORD *)uint64_t v221 = 67109378;
                    *(_DWORD *)uint64_t v222 = cfh;
                    *(_WORD *)&v222[4] = 2080;
                    *(void *)&v222[6] = v120;
                    _os_log_error_impl( (void *)&_mh_execute_header,  v65,  OS_LOG_TYPE_ERROR,  "Unable to spawn heap: %d (%s)",  v221,  0x12u);
                  }

                  *__error() = v201;
                }

                if (byte_1000E7D31 && dword_1000E74E0 <= 3)
                {
                  uint64_t v200 = *__error();
                  uint64_t v66 = *__error();
                  mach_port_name_t v67 = __error();
                  uint64_t v68 = strerror(*v67);
                  int v58 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"Unable to spawn heap: %d (%s)",  v66,  v68);
                  if (v58) {
                    goto LABEL_96;
                  }
                  int v77 = (os_log_s *)sub_10002EFA0();
                  if (os_log_type_enabled(v77, OS_LOG_TYPE_FAULT))
                  {
                    cfn = *__error();
                    int v126 = __error();
                    int v127 = strerror(*v126);
                    *(_DWORD *)uint64_t v221 = 67109378;
                    *(_DWORD *)uint64_t v222 = cfn;
                    *(_WORD *)&v222[4] = 2080;
                    *(void *)&v222[6] = v127;
                    int v62 = v77;
                    int v63 = "Unable to format: Unable to spawn heap: %d (%s)";
                    uint64_t v64 = 18;
LABEL_194:
                    _os_log_fault_impl((void *)&_mh_execute_header, v62, OS_LOG_TYPE_FAULT, v63, v221, v64);
                  }

LABEL_117:
  if ((a1 & 0x80000000) != 0)
  {
    if (byte_1000E7D30)
    {
      int v81 = *__error();
      int v82 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v82, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 134217984;
        int v102 = (_DWORD *)v55;
        _os_log_impl( (void *)&_mh_execute_header,  v82,  OS_LOG_TYPE_DEFAULT,  "file descriptor exhaustion: not monitoring due to conditions %#llx",  buf,  0xCu);
      }

      *__error() = v81;
    }

    if (!byte_1000E7D31 || dword_1000E74E0 > 2) {
      goto LABEL_150;
    }
    int v77 = *__error();
    int v79 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"file descriptor exhaustion: not monitoring due to conditions %#llx",  v55);
    if (!v79)
    {
      int v92 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v92, OS_LOG_TYPE_FAULT)) {
        sub_100083EA8();
      }
      goto LABEL_145;
    }

  if ((a1 & 0x80000000) != 0)
  {
    if (byte_1000E7D30)
    {
      int v81 = *__error();
      int v82 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v82, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 134217984;
        int v102 = (_DWORD *)v55;
        _os_log_impl( (void *)&_mh_execute_header,  v82,  OS_LOG_TYPE_DEFAULT,  "port exhaustion: not monitoring due to conditions %#llx",  buf,  0xCu);
      }

      *__error() = v81;
    }

    if (!byte_1000E7D31 || dword_1000E74E0 > 2) {
      goto LABEL_150;
    }
    int v77 = *__error();
    int v79 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"port exhaustion: not monitoring due to conditions %#llx",  v55);
    if (!v79)
    {
      int v92 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v92, OS_LOG_TYPE_FAULT)) {
        sub_10008415C();
      }
      goto LABEL_145;
    }

  if ((a1 & 0x80000000) != 0)
  {
    if (byte_1000E7D30)
    {
      int v81 = *__error();
      int v82 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v82, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 134217984;
        int v102 = (_DWORD *)v55;
        _os_log_impl( (void *)&_mh_execute_header,  v82,  OS_LOG_TYPE_DEFAULT,  "kqworkloop exhaustion: not monitoring due to conditions %#llx",  buf,  0xCu);
      }

      *__error() = v81;
    }

    if (!byte_1000E7D31 || dword_1000E74E0 > 2) {
      goto LABEL_150;
    }
    int v77 = *__error();
    int v79 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"kqworkloop exhaustion: not monitoring due to conditions %#llx",  v55);
    if (!v79)
    {
      int v92 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v92, OS_LOG_TYPE_FAULT)) {
        sub_100084410();
      }
      goto LABEL_145;
    }

LABEL_134:
    id v83 = v79;
    int v84 = a2;
    uint64_t v85 = a5;
    uint64_t v86 = a6;
    mach_port_name_t v87 = v7;
    __int16 v88 = CFStringGetCStringPtr(v79, 0x8000100u);
    if (v88)
    {
      int v89 = (char *)v88;
      __int16 v90 = 0LL;
    }

    else
    {
      int v89 = (char *)calloc(0x400uLL, 1uLL);
      CFStringGetCString(v83, v89, 1024LL, 0x8000100u);
      __int16 v90 = v89;
    }

    if (qword_1000E7D38) {
      id v91 = (FILE *)qword_1000E7D38;
    }
    else {
      id v91 = __stderrp;
    }
    fprintf(v91, "%s\n", v89);
    if (v90) {
      free(v90);
    }
    CFRelease(v83);
    mach_port_name_t v7 = v87;
    a6 = v86;
    a5 = v85;
    a2 = v84;
    goto LABEL_149;
  }

  if (byte_1000E7D30)
  {
    int v74 = *__error();
    int v75 = (os_log_s *)sub_10002EFA0();
    if (os_log_type_enabled(v75, OS_LOG_TYPE_DEFAULT))
    {
      id v76 = sub_10002EF3C(a1);
      *(_DWORD *)buf = 136446722;
      int v102 = v76;
      __int16 v103 = 1024;
      *(_DWORD *)int v104 = a1;
      *(_WORD *)&v104[4] = 2048;
      *(void *)&v104[6] = v55;
      _os_log_impl( (void *)&_mh_execute_header,  v75,  OS_LOG_TYPE_DEFAULT,  "%{public}s [%d]: file descriptor exhaustion: not monitoring due to conditions %#llx",  buf,  0x1Cu);
    }

    *__error() = v74;
  }

  if (!byte_1000E7D31 || dword_1000E74E0 > 2) {
    goto LABEL_150;
  }
  int v77 = *__error();
  uint64_t v78 = sub_10002EF3C(a1);
  int v79 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"%s [%d]: file descriptor exhaustion: not monitoring due to conditions %#llx",  v78,  a1,  v55);
  if (v79) {
    goto LABEL_134;
  }
  uint64_t v80 = (os_log_s *)sub_10002EFA0();
  if (os_log_type_enabled(v80, OS_LOG_TYPE_FAULT)) {
    sub_100083E3C();
  }
LABEL_145:
  if (qword_1000E7D38) {
    uint64_t v93 = (FILE *)qword_1000E7D38;
  }
  else {
    uint64_t v93 = __stderrp;
  }
  fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v93);
LABEL_149:
  *__error() = v77;
LABEL_150:
  sub_1000300EC(a1, a2, v97, v55, v100, a5, a6);
  if (v96 <= 0xFFFFFFFD) {
    sub_100052FA4(0LL, a1, v7);
  }
}

    id v83 = v79;
    int v84 = a2;
    uint64_t v85 = a5;
    uint64_t v86 = a6;
    mach_port_name_t v87 = v7;
    __int16 v88 = CFStringGetCStringPtr(v79, 0x8000100u);
    if (v88)
    {
      int v89 = (char *)v88;
      __int16 v90 = 0LL;
    }

    else
    {
      int v89 = (char *)calloc(0x400uLL, 1uLL);
      CFStringGetCString(v83, v89, 1024LL, 0x8000100u);
      __int16 v90 = v89;
    }

    if (qword_1000E7D38) {
      id v91 = (FILE *)qword_1000E7D38;
    }
    else {
      id v91 = __stderrp;
    }
    fprintf(v91, "%s\n", v89);
    if (v90) {
      free(v90);
    }
    CFRelease(v83);
    mach_port_name_t v7 = v87;
    a6 = v86;
    a5 = v85;
    a2 = v84;
    goto LABEL_149;
  }

  if (byte_1000E7D30)
  {
    int v74 = *__error();
    int v75 = (os_log_s *)sub_10002EFA0();
    if (os_log_type_enabled(v75, OS_LOG_TYPE_DEFAULT))
    {
      id v76 = sub_10002EF3C(a1);
      *(_DWORD *)buf = 136446722;
      int v102 = v76;
      __int16 v103 = 1024;
      *(_DWORD *)int v104 = a1;
      *(_WORD *)&v104[4] = 2048;
      *(void *)&v104[6] = v55;
      _os_log_impl( (void *)&_mh_execute_header,  v75,  OS_LOG_TYPE_DEFAULT,  "%{public}s [%d]: port exhaustion: not monitoring due to conditions %#llx",  buf,  0x1Cu);
    }

    *__error() = v74;
  }

  if (!byte_1000E7D31 || dword_1000E74E0 > 2) {
    goto LABEL_150;
  }
  int v77 = *__error();
  uint64_t v78 = sub_10002EF3C(a1);
  int v79 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"%s [%d]: port exhaustion: not monitoring due to conditions %#llx",  v78,  a1,  v55);
  if (v79) {
    goto LABEL_134;
  }
  uint64_t v80 = (os_log_s *)sub_10002EFA0();
  if (os_log_type_enabled(v80, OS_LOG_TYPE_FAULT)) {
    sub_1000840F0();
  }
LABEL_145:
  if (qword_1000E7D38) {
    uint64_t v93 = (FILE *)qword_1000E7D38;
  }
  else {
    uint64_t v93 = __stderrp;
  }
  fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v93);
LABEL_149:
  *__error() = v77;
LABEL_150:
  sub_1000303DC(a1, a2, v97, v55, v100, a5, a6);
  if (v96 <= 0xFFFFFFFD) {
    sub_100052FA4(1LL, a1, v7);
  }
}

    id v83 = v79;
    int v84 = a2;
    uint64_t v85 = a5;
    uint64_t v86 = a6;
    mach_port_name_t v87 = v7;
    __int16 v88 = CFStringGetCStringPtr(v79, 0x8000100u);
    if (v88)
    {
      int v89 = (char *)v88;
      __int16 v90 = 0LL;
    }

    else
    {
      int v89 = (char *)calloc(0x400uLL, 1uLL);
      CFStringGetCString(v83, v89, 1024LL, 0x8000100u);
      __int16 v90 = v89;
    }

    if (qword_1000E7D38) {
      id v91 = (FILE *)qword_1000E7D38;
    }
    else {
      id v91 = __stderrp;
    }
    fprintf(v91, "%s\n", v89);
    if (v90) {
      free(v90);
    }
    CFRelease(v83);
    mach_port_name_t v7 = v87;
    a6 = v86;
    a5 = v85;
    a2 = v84;
    goto LABEL_149;
  }

  if (byte_1000E7D30)
  {
    int v74 = *__error();
    int v75 = (os_log_s *)sub_10002EFA0();
    if (os_log_type_enabled(v75, OS_LOG_TYPE_DEFAULT))
    {
      id v76 = sub_10002EF3C(a1);
      *(_DWORD *)buf = 136446722;
      int v102 = v76;
      __int16 v103 = 1024;
      *(_DWORD *)int v104 = a1;
      *(_WORD *)&v104[4] = 2048;
      *(void *)&v104[6] = v55;
      _os_log_impl( (void *)&_mh_execute_header,  v75,  OS_LOG_TYPE_DEFAULT,  "%{public}s [%d]: kqworkloop exhaustion: not monitoring due to conditions %#llx",  buf,  0x1Cu);
    }

    *__error() = v74;
  }

  if (!byte_1000E7D31 || dword_1000E74E0 > 2) {
    goto LABEL_150;
  }
  int v77 = *__error();
  uint64_t v78 = sub_10002EF3C(a1);
  int v79 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"%s [%d]: kqworkloop exhaustion: not monitoring due to conditions %#llx",  v78,  a1,  v55);
  if (v79) {
    goto LABEL_134;
  }
  uint64_t v80 = (os_log_s *)sub_10002EFA0();
  if (os_log_type_enabled(v80, OS_LOG_TYPE_FAULT)) {
    sub_1000843A4();
  }
LABEL_145:
  if (qword_1000E7D38) {
    uint64_t v93 = (FILE *)qword_1000E7D38;
  }
  else {
    uint64_t v93 = __stderrp;
  }
  fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v93);
LABEL_149:
  *__error() = v77;
LABEL_150:
  sub_1000306CC(a1, a2, v97, v55, v100, a5, a6);
  if (v96 <= 0xFFFFFFFD) {
    sub_100052FA4(2LL, a1, v7);
  }
}

void sub_1000441BC(uint64_t a1, uint64_t a2)
{
}

void sub_1000441D8( uint64_t a1, NSString *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, mach_port_name_t a7)
{
  mach_port_name_t v7 = a7;
  uint64_t v94 = a4;
  unsigned int v96 = a7 - 1;
  if (a7 - 1 > 0xFFFFFFFD)
  {
    if ((a1 & 0x80000000) != 0)
    {
      if (byte_1000E7D30)
      {
        int v35 = *__error();
        uint64_t v36 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v36, OS_LOG_TYPE_INFO))
        {
          *(_DWORD *)buf = 134218240;
          int v102 = (_DWORD *)a5;
          __int16 v103 = 2048;
          *(void *)int v104 = a3;
          _os_log_impl( (void *)&_mh_execute_header,  v36,  OS_LOG_TYPE_INFO,  "port exhaustion: %llu ports with flags %#llx",  buf,  0x16u);
        }

        *__error() = v35;
      }

      if (byte_1000E7D31) {
        BOOL v37 = dword_1000E74E0 <= 1;
      }
      else {
        BOOL v37 = 0;
      }
      if (v37)
      {
        int v16 = *__error();
        int v38 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"port exhaustion: %llu ports with flags %#llx",  a5,  a3);
        if (v38)
        {
          double v39 = v38;
          int v40 = a2;
          uint64_t v41 = a5;
          uint64_t v42 = a6;
          mach_port_name_t v43 = v7;
          CStringPtr = CFStringGetCStringPtr(v38, 0x8000100u);
          if (CStringPtr)
          {
            int v45 = (char *)CStringPtr;
            int v46 = 0LL;
          }

          else
          {
            int v45 = (char *)calloc(0x400uLL, 1uLL);
            CFStringGetCString(v39, v45, 1024LL, 0x8000100u);
            int v46 = v45;
          }

          if (qword_1000E7D38) {
            uint64_t v53 = (FILE *)qword_1000E7D38;
          }
          else {
            uint64_t v53 = __stderrp;
          }
          fprintf(v53, "%s\n", v45);
          if (v46) {
            free(v46);
          }
          CFRelease(v39);
          mach_port_name_t v7 = v43;
          a6 = v42;
          a5 = v41;
          a2 = v40;
          goto LABEL_77;
        }

        int v52 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v52, OS_LOG_TYPE_FAULT)) {
          sub_100084344();
        }
        uint64_t v49 = qword_1000E7D38;
        int v50 = __stderrp;
        goto LABEL_63;
      }
    }

    else
    {
      if (byte_1000E7D30)
      {
        int v22 = *__error();
        uint64_t v23 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v23, OS_LOG_TYPE_INFO))
        {
          *(_DWORD *)buf = 136446978;
          int v102 = sub_10002EF3C(a1);
          __int16 v103 = 1024;
          *(_DWORD *)int v104 = a1;
          *(_WORD *)&v104[4] = 2048;
          *(void *)&v104[6] = a5;
          __int16 v105 = 2048;
          uint64_t v106 = a3;
          _os_log_impl( (void *)&_mh_execute_header,  v23,  OS_LOG_TYPE_INFO,  "%{public}s [%d]: port exhaustion: %llu ports with flags %#llx",  buf,  0x26u);
        }

        *__error() = v22;
      }

      if (byte_1000E7D31) {
        BOOL v24 = dword_1000E74E0 <= 1;
      }
      else {
        BOOL v24 = 0;
      }
      if (v24)
      {
        int v16 = *__error();
        uint64_t v25 = sub_10002EF3C(a1);
        id v18 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"%s [%d]: port exhaustion: %llu ports with flags %#llx",  v25,  a1,  a5,  a3,  v94);
        if (!v18)
        {
          BOOL v19 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v19, OS_LOG_TYPE_FAULT))
          {
            int v26 = sub_10002EF3C(a1);
            *(_DWORD *)buf = 136315906;
            int v102 = v26;
            __int16 v103 = 1024;
            *(_DWORD *)int v104 = a1;
            *(_WORD *)&v104[4] = 2048;
            *(void *)&v104[6] = a5;
            __int16 v105 = 2048;
            uint64_t v106 = a3;
            uint64_t v21 = "Unable to format: %s [%d]: port exhaustion: %llu ports with flags %#llx";
            goto LABEL_28;
          }

void sub_100044EBC(uint64_t a1, uint64_t a2)
{
}

void sub_100044ED8( uint64_t a1, NSString *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, mach_port_name_t a7)
{
  mach_port_name_t v7 = a7;
  uint64_t v94 = a4;
  unsigned int v96 = a7 - 1;
  if (a7 - 1 > 0xFFFFFFFD)
  {
    if ((a1 & 0x80000000) != 0)
    {
      if (byte_1000E7D30)
      {
        int v35 = *__error();
        uint64_t v36 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v36, OS_LOG_TYPE_INFO))
        {
          *(_DWORD *)buf = 134218240;
          int v102 = (_DWORD *)a5;
          __int16 v103 = 2048;
          *(void *)int v104 = a3;
          _os_log_impl( (void *)&_mh_execute_header,  v36,  OS_LOG_TYPE_INFO,  "kqworkloop exhaustion: %llu kqworkloops with flags %#llx",  buf,  0x16u);
        }

        *__error() = v35;
      }

      if (byte_1000E7D31) {
        BOOL v37 = dword_1000E74E0 <= 1;
      }
      else {
        BOOL v37 = 0;
      }
      if (v37)
      {
        int v16 = *__error();
        int v38 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"kqworkloop exhaustion: %llu kqworkloops with flags %#llx",  a5,  a3);
        if (v38)
        {
          double v39 = v38;
          int v40 = a2;
          uint64_t v41 = a5;
          uint64_t v42 = a6;
          mach_port_name_t v43 = v7;
          CStringPtr = CFStringGetCStringPtr(v38, 0x8000100u);
          if (CStringPtr)
          {
            int v45 = (char *)CStringPtr;
            int v46 = 0LL;
          }

          else
          {
            int v45 = (char *)calloc(0x400uLL, 1uLL);
            CFStringGetCString(v39, v45, 1024LL, 0x8000100u);
            int v46 = v45;
          }

          if (qword_1000E7D38) {
            uint64_t v53 = (FILE *)qword_1000E7D38;
          }
          else {
            uint64_t v53 = __stderrp;
          }
          fprintf(v53, "%s\n", v45);
          if (v46) {
            free(v46);
          }
          CFRelease(v39);
          mach_port_name_t v7 = v43;
          a6 = v42;
          a5 = v41;
          a2 = v40;
          goto LABEL_77;
        }

        int v52 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v52, OS_LOG_TYPE_FAULT)) {
          sub_1000845F8();
        }
        uint64_t v49 = qword_1000E7D38;
        int v50 = __stderrp;
        goto LABEL_63;
      }
    }

    else
    {
      if (byte_1000E7D30)
      {
        int v22 = *__error();
        uint64_t v23 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v23, OS_LOG_TYPE_INFO))
        {
          *(_DWORD *)buf = 136446978;
          int v102 = sub_10002EF3C(a1);
          __int16 v103 = 1024;
          *(_DWORD *)int v104 = a1;
          *(_WORD *)&v104[4] = 2048;
          *(void *)&v104[6] = a5;
          __int16 v105 = 2048;
          uint64_t v106 = a3;
          _os_log_impl( (void *)&_mh_execute_header,  v23,  OS_LOG_TYPE_INFO,  "%{public}s [%d]: kqworkloop exhaustion: %llu kqworkloops with flags %#llx",  buf,  0x26u);
        }

        *__error() = v22;
      }

      if (byte_1000E7D31) {
        BOOL v24 = dword_1000E74E0 <= 1;
      }
      else {
        BOOL v24 = 0;
      }
      if (v24)
      {
        int v16 = *__error();
        uint64_t v25 = sub_10002EF3C(a1);
        id v18 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"%s [%d]: kqworkloop exhaustion: %llu kqworkloops with flags %#llx",  v25,  a1,  a5,  a3,  v94);
        if (!v18)
        {
          BOOL v19 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v19, OS_LOG_TYPE_FAULT))
          {
            int v26 = sub_10002EF3C(a1);
            *(_DWORD *)buf = 136315906;
            int v102 = v26;
            __int16 v103 = 1024;
            *(_DWORD *)int v104 = a1;
            *(_WORD *)&v104[4] = 2048;
            *(void *)&v104[6] = a5;
            __int16 v105 = 2048;
            uint64_t v106 = a3;
            uint64_t v21 = "Unable to format: %s [%d]: kqworkloop exhaustion: %llu kqworkloops with flags %#llx";
            goto LABEL_28;
          }

void sub_100045BBC(uint64_t a1, uint64_t a2)
{
}

void sub_100045BD8(uint64_t a1)
{
  while (waitpid(*(_DWORD *)(a1 + 48), 0LL, 0) == -1 && *__error() == 4)
    ;
  size_t v2 = 0x4000LL;
  uint64_t v3 = (char *)malloc(0x4000uLL);
  unint64_t v4 = 0LL;
  do
  {
    size_t v5 = v4;
    if (v2 - 1 <= v4)
    {
      v2 *= 2LL;
      uint64_t v3 = (char *)reallocf(v3, v2);
    }

    ssize_t v6 = read(*(_DWORD *)(a1 + 52), &v3[v5], v2 + ~v5);
    unint64_t v4 = v6 + v5;
  }

  while (v6 > 0);
  if (v6 < 0)
  {
    if (byte_1000E7D30)
    {
      int v7 = *__error();
      int v8 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR)) {
        sub_100084908();
      }
      *__error() = v7;
    }

    if (byte_1000E7D31) {
      BOOL v9 = dword_1000E74E0 <= 3;
    }
    else {
      BOOL v9 = 0;
    }
    if (v9)
    {
      int v10 = *__error();
      uint64_t v11 = *__error();
      uint64_t v12 = __error();
      int v13 = strerror(*v12);
      uint64_t v14 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"read from child returned error: %d (%s)",  v11,  v13);
      if (v14)
      {
        BOOL v15 = v14;
        CStringPtr = CFStringGetCStringPtr(v14, 0x8000100u);
        if (CStringPtr)
        {
          int v17 = (char *)CStringPtr;
          id v18 = 0LL;
        }

        else
        {
          int v17 = (char *)calloc(0x400uLL, 1uLL);
          CFStringGetCString(v15, v17, 1024LL, 0x8000100u);
          id v18 = v17;
        }

        if (qword_1000E7D38) {
          uint64_t v21 = (FILE *)qword_1000E7D38;
        }
        else {
          uint64_t v21 = __stderrp;
        }
        fprintf(v21, "%s\n", v17);
        if (v18) {
          free(v18);
        }
        CFRelease(v15);
      }

      else
      {
        BOOL v19 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v19, OS_LOG_TYPE_FAULT)) {
          sub_100084898();
        }
        if (qword_1000E7D38) {
          int v20 = (FILE *)qword_1000E7D38;
        }
        else {
          int v20 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v20);
      }

      *__error() = v10;
    }
  }

  close(*(_DWORD *)(a1 + 52));
  v3[v5] = 0;
  int v22 = strnstr(v3, "Spindump analysis written to file ", v5);
  if (!v22)
  {
    int v26 = *__error();
    int v27 = (os_log_s *)sub_10002EFA0();
    if (os_log_type_enabled(v27, OS_LOG_TYPE_FAULT)) {
      sub_1000846B8();
    }
    *__error() = v26;
    if (!byte_1000E7D31 || dword_1000E74E0 > 4) {
      goto LABEL_73;
    }
    int v28 = *__error();
    BOOL v29 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"Spindump output doesn't contain output path: %s",  v3);
    if (!v29)
    {
      BOOL v30 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v30, OS_LOG_TYPE_FAULT)) {
        sub_100084658();
      }
      goto LABEL_68;
    }

    goto LABEL_57;
  }

  uint64_t v23 = v22 + 34;
  BOOL v24 = strnstr(v22 + 34, "\n", &v3[v5] - (v22 + 34));
  if (!v24)
  {
    int v31 = *__error();
    int v32 = (os_log_s *)sub_10002EFA0();
    if (os_log_type_enabled(v32, OS_LOG_TYPE_FAULT)) {
      sub_100084778();
    }
    *__error() = v31;
    if (!byte_1000E7D31 || dword_1000E74E0 > 4) {
      goto LABEL_73;
    }
    int v28 = *__error();
    BOOL v29 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"No newline in spindump output: %s", v3);
    if (!v29)
    {
      uint64_t v33 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v33, OS_LOG_TYPE_FAULT)) {
        sub_100084718();
      }
      goto LABEL_68;
    }

LABEL_57:
    uint64_t v36 = v29;
    BOOL v37 = CFStringGetCStringPtr(v29, 0x8000100u);
    if (v37)
    {
      int v38 = (char *)v37;
      double v39 = 0LL;
    }

    else
    {
      int v38 = (char *)calloc(0x400uLL, 1uLL);
      CFStringGetCString(v36, v38, 1024LL, 0x8000100u);
      double v39 = v38;
    }

    if (qword_1000E7D38) {
      int v40 = (FILE *)qword_1000E7D38;
    }
    else {
      int v40 = __stderrp;
    }
    fprintf(v40, "%s\n", v38);
    if (v39) {
      free(v39);
    }
    CFRelease(v36);
LABEL_72:
    *__error() = v28;
LABEL_73:
    uint64_t v25 = *(void (**)(void))(*(void *)(a1 + 40) + 16LL);
    goto LABEL_74;
  }

  *BOOL v24 = 0;
  if (!sub_10002C400(v23))
  {
    int v34 = *__error();
    int v35 = (os_log_s *)sub_10002EFA0();
    if (os_log_type_enabled(v35, OS_LOG_TYPE_FAULT)) {
      sub_100084838();
    }
    *__error() = v34;
    if (!byte_1000E7D31 || dword_1000E74E0 > 4) {
      goto LABEL_73;
    }
    int v28 = *__error();
    BOOL v29 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"Spindump output file doesn't exist: %s", v23);
    if (v29) {
      goto LABEL_57;
    }
    uint64_t v41 = (os_log_s *)sub_10002EFA0();
    if (os_log_type_enabled(v41, OS_LOG_TYPE_FAULT)) {
      sub_1000847D8();
    }
LABEL_68:
    if (qword_1000E7D38) {
      uint64_t v42 = (FILE *)qword_1000E7D38;
    }
    else {
      uint64_t v42 = __stderrp;
    }
    fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v42);
    goto LABEL_72;
  }

  uint64_t v25 = *(void (**)(void))(*(void *)(a1 + 40) + 16LL);
LABEL_74:
  v25();
  free(v3);
  dispatch_source_cancel(*(dispatch_source_t *)(a1 + 32));
  dispatch_release(*(dispatch_object_t *)(a1 + 32));
}

void sub_100046190(id a1)
{
  uint64_t v1 = getenv("SPINDUMP_IGNORE_SUSPENSION");
  if (v1)
  {
    if (strcmp(v1, "0")) {
      byte_1000E7BE0 = 1;
    }
  }

void sub_100046210( void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
}

  ;
}

  ;
}

  ;
}

  ;
}

  ;
}

  ;
}

  ;
}

void sub_1000462D4( void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
}

void sub_1000462E8( void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
}

  ;
}

void sub_100046330( void *a1, os_log_s *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
}

id sub_100046340()
{
  return [v0 total];
}

void sub_100046348(void *a1, uint64_t a2, os_log_t log, const char *a4, ...)
{
}

  ;
}

void sub_100046368( void *a1, os_log_s *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
}

_DWORD *sub_100046378(int a1)
{
  return sub_10002EF3C(a1);
}

  ;
}

_DWORD *sub_100046388(int a1)
{
  return sub_10002EF3C(a1);
}

void sub_100046390( void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
}

void sub_1000463A4( void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
}

  ;
}

  ;
}

id sub_1000463F4()
{
  return objc_msgSend(v0, "bytes_not_microstackshots");
}

  ;
}

  ;
}

  ;
}

char *sub_100046448(int *a1)
{
  return strerror(*a1);
}

void sub_100046450( void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
}

void sub_100046464( void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
}

  ;
}

  ;
}

  ;
}

int *sub_1000464BC()
{
  return __error();
}

_DWORD *sub_1000464CC(int a1)
{
  return sub_10002EF3C(a1);
}

  ;
}

id sub_1000464E4(void *a1, const char *a2)
{
  return [a1 total];
}

  ;
}

  ;
}

_DWORD *sub_100046520(int *a1)
{
  return sub_10002EF3C(*a1);
}

_DWORD *sub_10004652C(int *a1)
{
  return sub_10002EF3C(*a1);
}

int *sub_100046534()
{
  return __error();
}

void sub_100046540( void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
}

void sub_100046554( void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
}

void sub_100046568( void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
}

void sub_10004657C( void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
}

void sub_100046590( void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
}

void sub_1000465A4( void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
}

void sub_1000465B8( void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
}

void sub_1000465CC( void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
}

void sub_1000465E0( void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
}

int *sub_1000465F4()
{
  return __error();
}

int *sub_1000465FC()
{
  return __error();
}

const char *sub_100046604()
{
  return sub_10006B9CC(v0);
}

int *sub_100046614()
{
  return __error();
}

int *sub_10004661C()
{
  return __error();
}

_DWORD *sub_100046624@<X0>(int a1@<W0>, uint64_t a2@<X8>)
{
  *(void *)(v2 - 24) = a2;
  return sub_10002EF3C(a1);
}

void sub_10004662C( void *a1, os_log_s *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
}

void sub_10004663C( void *a1, os_log_s *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
}

void sub_10004664C( void *a1, os_log_s *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
}

  ;
}

  ;
}

const char *sub_10004668C(unsigned __int8 a1)
{
  return sub_10006B9CC(a1);
}

  ;
}

_DWORD *sub_1000466A4( _DWORD *result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((_DWORD)a2)
  {
    int v8 = a2;
    uint64_t result = sub_100024170((uint64_t)result, a2, a3, a4, a5, a6, a7, a8);
    if (result) {
      result[1] = v8;
    }
  }

  return result;
}

BOOL sub_1000466D0()
{
  if (qword_1000E7C00 != -1) {
    dispatch_once(&qword_1000E7C00, &stru_1000D9038);
  }
  if (dword_1000E74E4 == -1) {
    return 0LL;
  }
  uint64_t state = notify_get_state(dword_1000E74E4, &state64);
  if ((_DWORD)state)
  {
    uint64_t v1 = state;
    if (byte_1000E7D30)
    {
      int v2 = *__error();
      uint64_t v3 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR)) {
        sub_100085794();
      }
      *__error() = v2;
    }

    if (byte_1000E7D31) {
      BOOL v4 = dword_1000E74E0 <= 3;
    }
    else {
      BOOL v4 = 0;
    }
    if (!v4) {
      return 0LL;
    }
    int v15 = *__error();
    int v16 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"Failed to get thermal level: %d", v1);
    if (v16)
    {
      int v17 = v16;
      CStringPtr = CFStringGetCStringPtr(v16, 0x8000100u);
      if (CStringPtr)
      {
        BOOL v19 = (char *)CStringPtr;
        int v20 = 0LL;
      }

      else
      {
        BOOL v19 = (char *)calloc(0x400uLL, 1uLL);
        CFStringGetCString(v17, v19, 1024LL, 0x8000100u);
        int v20 = v19;
      }

      if (qword_1000E7D38) {
        uint64_t v23 = (FILE *)qword_1000E7D38;
      }
      else {
        uint64_t v23 = __stderrp;
      }
      fprintf(v23, "%s\n", v19);
      if (v20) {
        free(v20);
      }
      CFRelease(v17);
    }

    else
    {
      uint64_t v21 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v21, OS_LOG_TYPE_FAULT)) {
        sub_100085734();
      }
      if (qword_1000E7D38) {
        int v22 = (FILE *)qword_1000E7D38;
      }
      else {
        int v22 = __stderrp;
      }
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v22);
    }

    BOOL v24 = __error();
    BOOL result = 0LL;
    *BOOL v24 = v15;
  }

  else
  {
    if (byte_1000E7D30)
    {
      int v6 = *__error();
      int v7 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG)) {
        sub_1000856D4();
      }
      *__error() = v6;
    }

    if (byte_1000E7D31) {
      BOOL v8 = dword_1000E74E0 <= 0;
    }
    else {
      BOOL v8 = 0;
    }
    if (v8)
    {
      int v9 = *__error();
      int v10 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"Got thermal level: %lld", state64);
      if (v10)
      {
        uint64_t v11 = v10;
        uint64_t v12 = CFStringGetCStringPtr(v10, 0x8000100u);
        if (v12)
        {
          int v13 = (char *)v12;
          uint64_t v14 = 0LL;
        }

        else
        {
          int v13 = (char *)calloc(0x400uLL, 1uLL);
          CFStringGetCString(v11, v13, 1024LL, 0x8000100u);
          uint64_t v14 = v13;
        }

        if (qword_1000E7D38) {
          int v27 = (FILE *)qword_1000E7D38;
        }
        else {
          int v27 = __stderrp;
        }
        fprintf(v27, "%s\n", v13);
        if (v14) {
          free(v14);
        }
        CFRelease(v11);
      }

      else
      {
        uint64_t v25 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v25, OS_LOG_TYPE_FAULT)) {
          sub_100085674();
        }
        if (qword_1000E7D38) {
          int v26 = (FILE *)qword_1000E7D38;
        }
        else {
          int v26 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v26);
      }

      *__error() = v9;
    }

    return state64 > 0x1D;
  }

  return result;
}

void sub_100046A68(id a1)
{
  uint64_t v1 = notify_register_check(kOSThermalNotificationPressureLevelName, &dword_1000E74E4);
  if ((_DWORD)v1)
  {
    uint64_t v2 = v1;
    if (byte_1000E7D30)
    {
      int v3 = *__error();
      BOOL v4 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR)) {
        sub_100085854();
      }
      *__error() = v3;
    }

    if (byte_1000E7D31) {
      BOOL v5 = dword_1000E74E0 <= 3;
    }
    else {
      BOOL v5 = 0;
    }
    if (v5)
    {
      int v6 = *__error();
      int v7 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"Failed to register for thermal level: %d", v2);
      if (v7)
      {
        BOOL v8 = v7;
        CStringPtr = CFStringGetCStringPtr(v7, 0x8000100u);
        if (CStringPtr)
        {
          int v10 = (char *)CStringPtr;
          uint64_t v11 = 0LL;
        }

        else
        {
          int v10 = (char *)calloc(0x400uLL, 1uLL);
          CFStringGetCString(v8, v10, 1024LL, 0x8000100u);
          uint64_t v11 = v10;
        }

        if (qword_1000E7D38) {
          uint64_t v14 = (FILE *)qword_1000E7D38;
        }
        else {
          uint64_t v14 = __stderrp;
        }
        fprintf(v14, "%s\n", v10);
        if (v11) {
          free(v11);
        }
        CFRelease(v8);
      }

      else
      {
        uint64_t v12 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT)) {
          sub_1000857F4();
        }
        if (qword_1000E7D38) {
          int v13 = (FILE *)qword_1000E7D38;
        }
        else {
          int v13 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v13);
      }

      *__error() = v6;
    }

    dword_1000E74E4 = -1;
  }

BOOL sub_100046C44()
{
  if (qword_1000E7C08 != -1) {
    dispatch_once(&qword_1000E7C08, &stru_1000D9058);
  }
  if (dword_1000E74E8 == -1) {
    return 0LL;
  }
  uint64_t state64 = 0LL;
  uint64_t state = notify_get_state(dword_1000E74E8, &state64);
  if ((_DWORD)state)
  {
    uint64_t v1 = state;
    if (byte_1000E7D30)
    {
      int v2 = *__error();
      int v3 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR)) {
        sub_1000859D4();
      }
      *__error() = v2;
    }

    if (byte_1000E7D31) {
      BOOL v4 = dword_1000E74E0 <= 3;
    }
    else {
      BOOL v4 = 0;
    }
    if (!v4) {
      return 0LL;
    }
    int v15 = *__error();
    int v16 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"GM check: Failed to get game mode state: %d", v1);
    if (v16)
    {
      int v17 = v16;
      CStringPtr = CFStringGetCStringPtr(v16, 0x8000100u);
      if (CStringPtr)
      {
        BOOL v19 = (char *)CStringPtr;
        int v20 = 0LL;
      }

      else
      {
        BOOL v19 = (char *)calloc(0x400uLL, 1uLL);
        CFStringGetCString(v17, v19, 1024LL, 0x8000100u);
        int v20 = v19;
      }

      if (qword_1000E7D38) {
        uint64_t v23 = (FILE *)qword_1000E7D38;
      }
      else {
        uint64_t v23 = __stderrp;
      }
      fprintf(v23, "%s\n", v19);
      if (v20) {
        free(v20);
      }
      CFRelease(v17);
    }

    else
    {
      uint64_t v21 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v21, OS_LOG_TYPE_FAULT)) {
        sub_100085974();
      }
      if (qword_1000E7D38) {
        int v22 = (FILE *)qword_1000E7D38;
      }
      else {
        int v22 = __stderrp;
      }
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v22);
    }

    BOOL v24 = __error();
    BOOL result = 0LL;
    *BOOL v24 = v15;
  }

  else
  {
    if (byte_1000E7D30)
    {
      int v6 = *__error();
      int v7 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG)) {
        sub_100085914();
      }
      *__error() = v6;
    }

    if (byte_1000E7D31) {
      BOOL v8 = dword_1000E74E0 <= 0;
    }
    else {
      BOOL v8 = 0;
    }
    if (v8)
    {
      int v9 = *__error();
      int v10 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"GM check: Got game mode: %lld", state64);
      if (v10)
      {
        uint64_t v11 = v10;
        uint64_t v12 = CFStringGetCStringPtr(v10, 0x8000100u);
        if (v12)
        {
          int v13 = (char *)v12;
          uint64_t v14 = 0LL;
        }

        else
        {
          int v13 = (char *)calloc(0x400uLL, 1uLL);
          CFStringGetCString(v11, v13, 1024LL, 0x8000100u);
          uint64_t v14 = v13;
        }

        if (qword_1000E7D38) {
          int v27 = (FILE *)qword_1000E7D38;
        }
        else {
          int v27 = __stderrp;
        }
        fprintf(v27, "%s\n", v13);
        if (v14) {
          free(v14);
        }
        CFRelease(v11);
      }

      else
      {
        uint64_t v25 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v25, OS_LOG_TYPE_FAULT)) {
          sub_1000858B4();
        }
        if (qword_1000E7D38) {
          int v26 = (FILE *)qword_1000E7D38;
        }
        else {
          int v26 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v26);
      }

      *__error() = v9;
    }

    return state64 != 0;
  }

  return result;
}

void sub_100046FE0(id a1)
{
  uint64_t v1 = notify_register_check("com.apple.system.console_mode_changed", &dword_1000E74E8);
  if ((_DWORD)v1)
  {
    uint64_t v2 = v1;
    if (byte_1000E7D30)
    {
      int v3 = *__error();
      BOOL v4 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR)) {
        sub_100085A94();
      }
      *__error() = v3;
    }

    if (byte_1000E7D31) {
      BOOL v5 = dword_1000E74E0 <= 3;
    }
    else {
      BOOL v5 = 0;
    }
    if (v5)
    {
      int v6 = *__error();
      int v7 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"Failed to register for game mode state: %d", v2);
      if (v7)
      {
        BOOL v8 = v7;
        CStringPtr = CFStringGetCStringPtr(v7, 0x8000100u);
        if (CStringPtr)
        {
          int v10 = (char *)CStringPtr;
          uint64_t v11 = 0LL;
        }

        else
        {
          int v10 = (char *)calloc(0x400uLL, 1uLL);
          CFStringGetCString(v8, v10, 1024LL, 0x8000100u);
          uint64_t v11 = v10;
        }

        if (qword_1000E7D38) {
          uint64_t v14 = (FILE *)qword_1000E7D38;
        }
        else {
          uint64_t v14 = __stderrp;
        }
        fprintf(v14, "%s\n", v10);
        if (v11) {
          free(v11);
        }
        CFRelease(v8);
      }

      else
      {
        uint64_t v12 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT)) {
          sub_100085A34();
        }
        if (qword_1000E7D38) {
          int v13 = (FILE *)qword_1000E7D38;
        }
        else {
          int v13 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v13);
      }

      *__error() = v6;
    }

    dword_1000E74E8 = -1;
  }

uint64_t sub_1000471B8(uint64_t a1, uint64_t a2, double a3)
{
  v21[0] = _NSConcreteStackBlock;
  v21[1] = 3221225472LL;
  int v22 = sub_100047640;
  uint64_t v23 = &unk_1000D90E0;
  uint64_t v24 = a1;
  uint64_t v25 = a2;
  double v26 = a3;
  int v3 = dispatch_queue_attr_make_with_autorelease_frequency(0LL, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
  BOOL v4 = dispatch_queue_create("Tasking notification", v3);
  dispatch_release(v3);
  handler[0] = _NSConcreteStackBlock;
  handler[1] = 3221225472LL;
  handler[2] = sub_100047BF0;
  handler[3] = &unk_1000D9108;
  void handler[4] = v21;
  uint64_t v5 = notify_register_dispatch("com.apple.da.tasking_changed", &out_token, v4, handler);
  if ((_DWORD)v5)
  {
    uint64_t v6 = v5;
    if (byte_1000E7D30)
    {
      int v7 = *__error();
      BOOL v8 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR)) {
        sub_100085B54();
      }
      *__error() = v7;
    }

    if (byte_1000E7D31 && dword_1000E74E0 <= 3)
    {
      int v9 = *__error();
      int v10 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"Unable to register for tasking update notifications: %d",  v6);
      if (v10)
      {
        uint64_t v11 = v10;
        CStringPtr = CFStringGetCStringPtr(v10, 0x8000100u);
        if (CStringPtr)
        {
          int v13 = (char *)CStringPtr;
          uint64_t v14 = 0LL;
        }

        else
        {
          int v13 = (char *)calloc(0x400uLL, 1uLL);
          CFStringGetCString(v11, v13, 1024LL, 0x8000100u);
          uint64_t v14 = v13;
        }

        if (qword_1000E7D38) {
          int v17 = (FILE *)qword_1000E7D38;
        }
        else {
          int v17 = __stderrp;
        }
        fprintf(v17, "%s\n", v13);
        if (v14) {
          free(v14);
        }
        CFRelease(v11);
      }

      else
      {
        int v15 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v15, OS_LOG_TYPE_FAULT)) {
          sub_100085AF4();
        }
        if (qword_1000E7D38) {
          int v16 = (FILE *)qword_1000E7D38;
        }
        else {
          int v16 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v16);
      }

      *__error() = v9;
    }
  }

  return ((uint64_t (*)(void *))v22)(v21);
}

void sub_100047420(id a1)
{
  int has_internal_diagnostics = os_variant_has_internal_diagnostics("com.apple.spindump");
  byte_1000E7C10 = has_internal_diagnostics;
  if (has_internal_diagnostics)
  {
    if (byte_1000E7D30)
    {
      int v2 = *__error();
      int v3 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v3, OS_LOG_TYPE_INFO))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_INFO, "apple internal", buf, 2u);
      }

      *__error() = v2;
    }

    if (byte_1000E7D31) {
      BOOL v4 = dword_1000E74E0 <= 1;
    }
    else {
      BOOL v4 = 0;
    }
    if (v4)
    {
      int v5 = *__error();
      uint64_t v6 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"apple internal");
      if (v6)
      {
        int v7 = v6;
        CStringPtr = CFStringGetCStringPtr(v6, 0x8000100u);
        if (CStringPtr)
        {
          int v9 = (char *)CStringPtr;
          int v10 = 0LL;
        }

        else
        {
          int v9 = (char *)calloc(0x400uLL, 1uLL);
          CFStringGetCString(v7, v9, 1024LL, 0x8000100u);
          int v10 = v9;
        }

        if (qword_1000E7D38) {
          int v20 = (FILE *)qword_1000E7D38;
        }
        else {
          int v20 = __stderrp;
        }
        fprintf(v20, "%s\n", v9);
        if (v10) {
          free(v10);
        }
        CFRelease(v7);
      }

      else
      {
        uint64_t v11 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v11, OS_LOG_TYPE_FAULT)) {
          sub_100085BB4(v11, v12, v13, v14, v15, v16, v17, v18);
        }
        if (qword_1000E7D38) {
          BOOL v19 = (FILE *)qword_1000E7D38;
        }
        else {
          BOOL v19 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v19);
      }

      *__error() = v5;
    }
  }

void sub_1000475F8(id a1)
{
  byte_1000E7C20 = sub_10002C400("/var/db/.suppress_spin_reports");
}

void sub_10004761C(id a1)
{
  byte_1000E7C30 = sub_10002C400("/var/db/.enable_spin_reports");
}

double sub_100047640(uint64_t a1)
{
  int v2 = (void *)(a1 + 32);
  uint64_t v3 = OSAGetDATaskingValue(*(void *)(a1 + 32));
  if (!v3)
  {
    if (byte_1000E7D30)
    {
      int v20 = *__error();
      uint64_t v21 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v21, OS_LOG_TYPE_INFO))
      {
        uint64_t v22 = *(void *)(a1 + 32);
        uint64_t v23 = *(void *)(a1 + 48);
        *(_DWORD *)buf = 138543618;
        uint64_t v49 = v22;
        __int16 v50 = 2048;
        uint64_t v51 = v23;
        _os_log_impl( (void *)&_mh_execute_header,  v21,  OS_LOG_TYPE_INFO,  "Tasking setting for %{public}@ not available, using default %.1f",  buf,  0x16u);
      }

      *__error() = v20;
    }

    if (byte_1000E7D31) {
      BOOL v24 = dword_1000E74E0 <= 1;
    }
    else {
      BOOL v24 = 0;
    }
    if (!v24) {
      goto LABEL_77;
    }
    int v25 = *__error();
    double v26 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"Tasking setting for %@ not available, using default %.1f",  *(void *)(a1 + 32),  *(void *)(a1 + 48));
    if (v26)
    {
      int v27 = v26;
      CStringPtr = CFStringGetCStringPtr(v26, 0x8000100u);
      if (CStringPtr)
      {
        BOOL v29 = (char *)CStringPtr;
        BOOL v30 = 0LL;
      }

      else
      {
        BOOL v29 = (char *)calloc(0x400uLL, 1uLL);
        CFStringGetCString(v27, v29, 1024LL, 0x8000100u);
        BOOL v30 = v29;
      }

      if (qword_1000E7D38) {
        int v44 = (FILE *)qword_1000E7D38;
      }
      else {
        int v44 = __stderrp;
      }
      fprintf(v44, "%s\n", v29);
      if (v30) {
        free(v30);
      }
      int v45 = v27;
      goto LABEL_75;
    }

    double v39 = (os_log_s *)sub_10002EFA0();
    if (os_log_type_enabled(v39, OS_LOG_TYPE_FAULT)) {
      sub_100085BE4();
    }
LABEL_49:
    if (qword_1000E7D38) {
      mach_port_name_t v43 = (FILE *)qword_1000E7D38;
    }
    else {
      mach_port_name_t v43 = __stderrp;
    }
    fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v43);
    goto LABEL_76;
  }

  BOOL v4 = (void *)v3;
  uint64_t v5 = objc_opt_class(&OBJC_CLASS___NSNumber);
  if ((objc_opt_isKindOfClass(v4, v5) & 1) == 0)
  {
    if (byte_1000E7D30)
    {
      int v31 = *__error();
      int v32 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR)) {
        sub_100085D24();
      }
      *__error() = v31;
    }

    if (byte_1000E7D31) {
      BOOL v33 = dword_1000E74E0 <= 3;
    }
    else {
      BOOL v33 = 0;
    }
    if (!v33) {
      goto LABEL_77;
    }
    int v25 = *__error();
    int v34 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"Tasking setting for %@: %@ isn't a number",  *v2,  v4);
    if (v34)
    {
      int v35 = v34;
      uint64_t v36 = CFStringGetCStringPtr(v34, 0x8000100u);
      if (v36)
      {
        BOOL v37 = (char *)v36;
        int v38 = 0LL;
      }

      else
      {
        BOOL v37 = (char *)calloc(0x400uLL, 1uLL);
        CFStringGetCString(v35, v37, 1024LL, 0x8000100u);
        int v38 = v37;
      }

      if (qword_1000E7D38) {
        int v47 = (FILE *)qword_1000E7D38;
      }
      else {
        int v47 = __stderrp;
      }
      fprintf(v47, "%s\n", v37);
      if (v38) {
        free(v38);
      }
      int v45 = v35;
LABEL_75:
      CFRelease(v45);
LABEL_76:
      *__error() = v25;
LABEL_77:
      double result = *(double *)(a1 + 48);
      **(double **)(a1 + 40) = result;
      return result;
    }

    uint64_t v42 = (os_log_s *)sub_10002EFA0();
    if (os_log_type_enabled(v42, OS_LOG_TYPE_FAULT)) {
      sub_100085CB8();
    }
    goto LABEL_49;
  }

  [v4 doubleValue];
  BOOL v8 = *(double **)(a1 + 40);
  int v7 = (uint64_t **)(a1 + 40);
  *BOOL v8 = result;
  if (byte_1000E7D30)
  {
    int v9 = *__error();
    int v10 = (os_log_s *)sub_10002EFA0();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v11 = *v2;
      uint64_t v12 = **v7;
      *(_DWORD *)buf = 138543618;
      uint64_t v49 = v11;
      __int16 v50 = 2048;
      uint64_t v51 = v12;
      _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "Tasking setting for %{public}@: %.1f",  buf,  0x16u);
    }

    *__error() = v9;
  }

  if (byte_1000E7D31) {
    BOOL v13 = dword_1000E74E0 <= 2;
  }
  else {
    BOOL v13 = 0;
  }
  if (v13)
  {
    int v14 = *__error();
    uint64_t v15 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"Tasking setting for %@: %.1f", *v2, **v7);
    if (v15)
    {
      uint64_t v16 = v15;
      uint64_t v17 = CFStringGetCStringPtr(v15, 0x8000100u);
      if (v17)
      {
        uint64_t v18 = (char *)v17;
        BOOL v19 = 0LL;
      }

      else
      {
        uint64_t v18 = (char *)calloc(0x400uLL, 1uLL);
        CFStringGetCString(v16, v18, 1024LL, 0x8000100u);
        BOOL v19 = v18;
      }

      if (qword_1000E7D38) {
        int v46 = (FILE *)qword_1000E7D38;
      }
      else {
        int v46 = __stderrp;
      }
      fprintf(v46, "%s\n", v18);
      if (v19) {
        free(v19);
      }
      CFRelease(v16);
    }

    else
    {
      int v40 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v40, OS_LOG_TYPE_FAULT)) {
        sub_100085C4C();
      }
      if (qword_1000E7D38) {
        uint64_t v41 = (FILE *)qword_1000E7D38;
      }
      else {
        uint64_t v41 = __stderrp;
      }
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v41);
    }

    *__error() = v14;
  }

  return result;
}

uint64_t sub_100047BF0(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL))();
}

  ;
}

void sub_100047C28(void *a1, uint64_t a2, os_log_t log, const char *a4, ...)
{
}

  ;
}

void sub_100047C64( void *a1, os_log_s *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
}

  ;
}

  ;
}

  ;
}

  ;
}

void sub_100047CC4(void *a1, os_log_s *a2, uint64_t a3, const char *a4, uint8_t *a5)
{
}

void sub_100047CD0(void *a1, uint64_t a2, os_log_t log, const char *a4, ...)
{
}

void sub_100047CE4(uint64_t a1@<X8>)
{
  *(void *)(v1 - _Block_object_dispose((const void *)(v17 - 80), 8) = a1;
}

  ;
}

void sub_100047D00( void *a1, os_log_s *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
}

  ;
}

  ;
}

double sub_100047D3C()
{
  return 2.0542726e-289;
}

  ;
}

  ;
}

void sub_100047D70(uint64_t a1@<X8>)
{
  *(void *)(v1 - _Block_object_dispose((const void *)(v17 - 80), 8) = a1;
}

uint64_t sub_100047D84(uint64_t a1)
{
  if (proc_pidinfo(a1, 13, 1uLL, buffer, 64)) {
    return v34;
  }
  if ((a1 & 0x80000000) != 0)
  {
    if (byte_1000E7D30)
    {
      int v16 = *__error();
      uint64_t v17 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR)) {
        sub_100085F58(v17);
      }
      *__error() = v16;
    }

    if (byte_1000E7D31) {
      BOOL v18 = dword_1000E74E0 <= 3;
    }
    else {
      BOOL v18 = 0;
    }
    if (!v18) {
      return 0xFFFFFFFFLL;
    }
    int v6 = *__error();
    uint64_t v19 = *__error();
    int v20 = __error();
    uint64_t v21 = strerror(*v20);
    uint64_t v22 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"Unable to get uid: %d (%s)", v19, v21);
    if (v22)
    {
      uint64_t v23 = v22;
      CStringPtr = CFStringGetCStringPtr(v22, 0x8000100u);
      if (CStringPtr)
      {
        int v25 = (char *)CStringPtr;
        double v26 = 0LL;
      }

      else
      {
        int v25 = (char *)calloc(0x400uLL, 1uLL);
        CFStringGetCString(v23, v25, 1024LL, 0x8000100u);
        double v26 = v25;
      }

      if (qword_1000E7D38) {
        int v32 = (FILE *)qword_1000E7D38;
      }
      else {
        int v32 = __stderrp;
      }
      fprintf(v32, "%s\n", v25);
      if (v26) {
        free(v26);
      }
      BOOL v29 = v23;
      goto LABEL_50;
    }

    BOOL v30 = (os_log_s *)sub_10002EFA0();
    if (os_log_type_enabled(v30, OS_LOG_TYPE_FAULT)) {
      sub_100085ED0(v30);
    }
LABEL_39:
    if (qword_1000E7D38) {
      int v31 = (FILE *)qword_1000E7D38;
    }
    else {
      int v31 = __stderrp;
    }
    fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v31);
    goto LABEL_51;
  }

  if (byte_1000E7D30)
  {
    int v3 = *__error();
    BOOL v4 = (os_log_s *)sub_10002EFA0();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR)) {
      sub_100085E38(a1, v4);
    }
    *__error() = v3;
  }

  if (byte_1000E7D31) {
    BOOL v5 = dword_1000E74E0 <= 3;
  }
  else {
    BOOL v5 = 0;
  }
  if (!v5) {
    return 0xFFFFFFFFLL;
  }
  int v6 = *__error();
  int v7 = sub_10002EF3C(a1);
  uint64_t v8 = *__error();
  int v9 = __error();
  int v10 = strerror(*v9);
  uint64_t v11 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"%s [%d]: Unable to get uid: %d (%s)",  v7,  a1,  v8,  v10);
  if (!v11)
  {
    int v27 = (os_log_s *)sub_10002EFA0();
    if (os_log_type_enabled(v27, OS_LOG_TYPE_FAULT)) {
      sub_100085DA0(a1, v27);
    }
    goto LABEL_39;
  }

  uint64_t v12 = v11;
  BOOL v13 = CFStringGetCStringPtr(v11, 0x8000100u);
  if (v13)
  {
    int v14 = (char *)v13;
    uint64_t v15 = 0LL;
  }

  else
  {
    int v14 = (char *)calloc(0x400uLL, 1uLL);
    CFStringGetCString(v12, v14, 1024LL, 0x8000100u);
    uint64_t v15 = v14;
  }

  if (qword_1000E7D38) {
    int v28 = (FILE *)qword_1000E7D38;
  }
  else {
    int v28 = __stderrp;
  }
  fprintf(v28, "%s\n", v14);
  if (v15) {
    free(v15);
  }
  BOOL v29 = v12;
LABEL_50:
  CFRelease(v29);
LABEL_51:
  *__error() = v6;
  return 0xFFFFFFFFLL;
}

void sub_100048108(uint64_t a1, xpc_object_t object)
{
  if (xpc_get_type(object) == (xpc_type_t)&_xpc_type_error)
  {
    if (byte_1000E7D30)
    {
      int v4 = *__error();
      BOOL v5 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG)) {
        sub_100086220(object);
      }
      *__error() = v4;
    }

    if (byte_1000E7D31) {
      BOOL v6 = dword_1000E74E0 <= 0;
    }
    else {
      BOOL v6 = 0;
    }
    if (v6)
    {
      int v7 = *__error();
      string = xpc_dictionary_get_string(object, _xpc_error_key_description);
      int v9 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"Got xpc error message in libspindump client connection: %s",  string);
      if (v9)
      {
        int v10 = v9;
        CStringPtr = CFStringGetCStringPtr(v9, 0x8000100u);
        if (CStringPtr)
        {
          uint64_t v12 = (char *)CStringPtr;
          BOOL v13 = 0LL;
        }

        else
        {
          uint64_t v12 = (char *)calloc(0x400uLL, 1uLL);
          CFStringGetCString(v10, v12, 1024LL, 0x8000100u);
          BOOL v13 = v12;
        }

        if (qword_1000E7D38) {
          int v16 = (FILE *)qword_1000E7D38;
        }
        else {
          int v16 = __stderrp;
        }
        fprintf(v16, "%s\n", v12);
        if (v13) {
          free(v13);
        }
        CFRelease(v10);
      }

      else
      {
        int v14 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v14, OS_LOG_TYPE_FAULT)) {
          sub_1000861AC(object, _xpc_error_key_description, v14);
        }
        if (qword_1000E7D38) {
          uint64_t v15 = (FILE *)qword_1000E7D38;
        }
        else {
          uint64_t v15 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v15);
      }

      *__error() = v7;
    }
  }

  else if (xpc_get_type(object) == (xpc_type_t)&_xpc_type_dictionary)
  {
    sub_100048330(*(void *)(a1 + 32), *(_DWORD *)(a1 + 40), object);
  }

void sub_100048330(unint64_t a1, int a2, xpc_object_t xdict)
{
  int64_t int64 = xpc_dictionary_get_int64(xdict, "message");
  switch(int64)
  {
    case 3LL:
      int64_t v7 = xpc_dictionary_get_int64(xdict, "pid");
      if (!(_DWORD)v7)
      {
        if (byte_1000E7D30)
        {
          int v77 = *__error();
          uint64_t v78 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v78, OS_LOG_TYPE_ERROR)) {
            sub_10008678C();
          }
          *__error() = v77;
        }

        if (byte_1000E7D31) {
          BOOL v79 = dword_1000E74E0 <= 3;
        }
        else {
          BOOL v79 = 0;
        }
        if (!v79) {
          return;
        }
        int v15 = *__error();
        int v16 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"Error reporting CPU resource: no pid provided");
        if (v16) {
          goto LABEL_292;
        }
        uint64_t v80 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v80, OS_LOG_TYPE_FAULT)) {
          sub_100086760();
        }
        goto LABEL_335;
      }

      uint64_t int64 = xpc_dictionary_get_uint64(xdict, "tid");
      uint64_t v9 = xpc_dictionary_get_uint64(xdict, "flags");
      xpc_object_t value = xpc_dictionary_get_value(xdict, "cpu");
      if (!value || (uint64_t v11 = value, xpc_get_type(value) != (xpc_type_t)&_xpc_type_double))
      {
        if (byte_1000E7D30)
        {
          int v12 = *__error();
          BOOL v13 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR)) {
            sub_1000867E4();
          }
          *__error() = v12;
        }

        if (byte_1000E7D31) {
          BOOL v14 = dword_1000E74E0 <= 3;
        }
        else {
          BOOL v14 = 0;
        }
        if (!v14) {
          return;
        }
        int v15 = *__error();
        int v16 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"Error reporting CPU resource: no cpu_used provided");
        if (v16) {
          goto LABEL_292;
        }
        uint64_t v17 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v17, OS_LOG_TYPE_FAULT)) {
          sub_1000867B8();
        }
        goto LABEL_335;
      }

      double v138 = xpc_double_get_value(v11);
      if (v138 <= 0.0)
      {
        if (byte_1000E7D30)
        {
          int v162 = *__error();
          int v163 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v163, OS_LOG_TYPE_ERROR)) {
            sub_100086C2C();
          }
          *__error() = v162;
        }

        if (!byte_1000E7D31 || dword_1000E74E0 > 3) {
          return;
        }
        int v15 = *__error();
        int v16 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"Error reporting CPU resource: bad cpu_used (%f)",  *(void *)&v138);
        if (v16) {
          goto LABEL_292;
        }
        int v164 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v164, OS_LOG_TYPE_FAULT)) {
          sub_100086BC8();
        }
        goto LABEL_335;
      }

      xpc_object_t v139 = xpc_dictionary_get_value(xdict, "duration");
      if (!v139 || (int v140 = v139, xpc_get_type(v139) != (xpc_type_t)&_xpc_type_double))
      {
        if (byte_1000E7D30)
        {
          int v141 = *__error();
          uint64_t v142 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v142, OS_LOG_TYPE_ERROR)) {
            sub_10008683C();
          }
          *__error() = v141;
        }

        if (!byte_1000E7D31 || dword_1000E74E0 > 3) {
          return;
        }
        int v15 = *__error();
        int v16 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"Error reporting CPU resource: no duration provided");
        if (v16) {
          goto LABEL_292;
        }
        uint64_t v143 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v143, OS_LOG_TYPE_FAULT)) {
          sub_100086810();
        }
        goto LABEL_335;
      }

      double v175 = xpc_double_get_value(v140);
      if (v175 <= 0.0)
      {
        if (byte_1000E7D30)
        {
          int v190 = *__error();
          BOOL v191 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v191, OS_LOG_TYPE_ERROR)) {
            sub_100086B64();
          }
          *__error() = v190;
        }

        if (!byte_1000E7D31 || dword_1000E74E0 > 3) {
          return;
        }
        int v15 = *__error();
        int v16 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"Error reporting CPU resource: bad duration (%f)",  *(void *)&v175);
        if (v16) {
          goto LABEL_292;
        }
        int v192 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v192, OS_LOG_TYPE_FAULT)) {
          sub_100086B00();
        }
        goto LABEL_335;
      }

      xpc_object_t v176 = xpc_dictionary_get_value(xdict, "endtime");
      if (!v176 || (int v177 = v176, xpc_get_type(v176) != (xpc_type_t)&_xpc_type_double))
      {
        if (byte_1000E7D30)
        {
          int v178 = *__error();
          id v179 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v179, OS_LOG_TYPE_ERROR)) {
            sub_100086894();
          }
          *__error() = v178;
        }

        if (!byte_1000E7D31 || dword_1000E74E0 > 3) {
          return;
        }
        int v15 = *__error();
        int v16 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"Error reporting CPU resource: no endtime provided");
        if (v16) {
          goto LABEL_292;
        }
        id v180 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v180, OS_LOG_TYPE_FAULT)) {
          sub_100086868();
        }
        goto LABEL_335;
      }

      double v197 = xpc_double_get_value(v177);
      xpc_object_t v198 = xpc_dictionary_get_value(xdict, "cpu_limit");
      if (!v198 || (uint64_t v199 = v198, xpc_get_type(v198) != (xpc_type_t)&_xpc_type_double))
      {
        if (byte_1000E7D30)
        {
          int v200 = *__error();
          uint64_t v201 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v201, OS_LOG_TYPE_ERROR)) {
            sub_1000868EC();
          }
          *__error() = v200;
        }

        if (!byte_1000E7D31 || dword_1000E74E0 > 3) {
          return;
        }
        int v15 = *__error();
        int v16 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"Error reporting CPU resource: no cpu_used_limit provided");
        if (v16) {
          goto LABEL_292;
        }
        uint64_t v202 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v202, OS_LOG_TYPE_FAULT)) {
          sub_1000868C0();
        }
        goto LABEL_335;
      }

      double v205 = xpc_double_get_value(v199);
      if (v205 < 0.0)
      {
        if (byte_1000E7D30)
        {
          int v206 = *__error();
          uint64_t v207 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v207, OS_LOG_TYPE_ERROR)) {
            sub_10008697C();
          }
          *__error() = v206;
        }

        if (!byte_1000E7D31 || dword_1000E74E0 > 3) {
          return;
        }
        int v15 = *__error();
        int v16 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"Error reporting CPU resource: bad cpu_used_limit (%f)",  *(void *)&v205);
        if (v16) {
          goto LABEL_292;
        }
        uint64_t v208 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v208, OS_LOG_TYPE_FAULT)) {
          sub_100086918();
        }
        goto LABEL_335;
      }

      xpc_object_t v212 = xpc_dictionary_get_value(xdict, "duration_limit");
      if (!v212 || (uint64_t v213 = v212, xpc_get_type(v212) != (xpc_type_t)&_xpc_type_double))
      {
        if (byte_1000E7D30)
        {
          int v214 = *__error();
          uint64_t v215 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v215, OS_LOG_TYPE_ERROR)) {
            sub_100086A0C();
          }
          *__error() = v214;
        }

        if (!byte_1000E7D31 || dword_1000E74E0 > 3) {
          return;
        }
        int v15 = *__error();
        int v16 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"Error reporting CPU resource: no duration_limit provided");
        if (v16) {
          goto LABEL_292;
        }
        unsigned int v216 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v216, OS_LOG_TYPE_FAULT)) {
          sub_1000869E0();
        }
        goto LABEL_335;
      }

      double v259 = xpc_double_get_value(v213);
      if (v259 >= 0.0)
      {
        string = xpc_dictionary_get_string(xdict, "pname");
        if (string) {
          id v272 = +[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", string);
        }
        else {
          id v272 = 0LL;
        }
        id v275 = xpc_dictionary_get_string(xdict, "action");
        if (v275)
        {
          id v276 = sub_100055AE4(v275);
          id v277 = +[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v276);
          free(v276);
        }

        else
        {
          id v277 = 0LL;
        }

        sub_100026030(v7, v272, uint64, v9, (uint64_t)v277, v138, v175, v197, v205, v259);
        return;
      }

      if (byte_1000E7D30)
      {
        int v260 = *__error();
        v261 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v261, OS_LOG_TYPE_ERROR)) {
          sub_100086A9C();
        }
        *__error() = v260;
      }

      if (byte_1000E7D31 && dword_1000E74E0 <= 3)
      {
        int v15 = *__error();
        int v16 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"Error reporting CPU resource: bad duration_limit (%f)",  *(void *)&v259);
        if (v16) {
          goto LABEL_292;
        }
        v262 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v262, OS_LOG_TYPE_FAULT)) {
          sub_100086A38();
        }
        goto LABEL_335;
      }

      return;
    case 5LL:
      int64_t v24 = xpc_dictionary_get_int64(xdict, "pid");
      if (!(_DWORD)v24)
      {
        if (byte_1000E7D30)
        {
          int v83 = *__error();
          int v84 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v84, OS_LOG_TYPE_ERROR)) {
            sub_100086CBC();
          }
          *__error() = v83;
        }

        if (byte_1000E7D31) {
          BOOL v85 = dword_1000E74E0 <= 3;
        }
        else {
          BOOL v85 = 0;
        }
        if (!v85) {
          return;
        }
        int v15 = *__error();
        int v16 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"Error reporting disk writes resource: no pid provided");
        if (v16) {
          goto LABEL_292;
        }
        uint64_t v86 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v86, OS_LOG_TYPE_FAULT)) {
          sub_100086C90();
        }
        goto LABEL_335;
      }

      uint64_t v25 = xpc_dictionary_get_uint64(xdict, "flags");
      int64_t v26 = xpc_dictionary_get_int64(xdict, "io");
      if (!v26)
      {
        if (byte_1000E7D30)
        {
          int v103 = *__error();
          int v104 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v104, OS_LOG_TYPE_ERROR)) {
            sub_100086D14();
          }
          *__error() = v103;
        }

        if (byte_1000E7D31) {
          BOOL v105 = dword_1000E74E0 <= 3;
        }
        else {
          BOOL v105 = 0;
        }
        if (!v105) {
          return;
        }
        int v15 = *__error();
        int v16 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"Error reporting disk writes resource: no num bytes provided");
        if (v16) {
          goto LABEL_292;
        }
        uint64_t v106 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v106, OS_LOG_TYPE_FAULT)) {
          sub_100086CE8();
        }
        goto LABEL_335;
      }

      int v27 = (_DWORD *)v26;
      xpc_object_t v28 = xpc_dictionary_get_value(xdict, "duration");
      if (!v28 || (BOOL v29 = v28, xpc_get_type(v28) != (xpc_type_t)&_xpc_type_double))
      {
        if (byte_1000E7D30)
        {
          int v30 = *__error();
          int v31 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR)) {
            sub_100086D6C();
          }
          *__error() = v30;
        }

        if (!byte_1000E7D31 || dword_1000E74E0 > 3) {
          return;
        }
        int v15 = *__error();
        int v16 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"Error reporting disk writes resource: no duration provided");
        if (v16) {
          goto LABEL_292;
        }
        int v32 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v32, OS_LOG_TYPE_FAULT)) {
          sub_100086D40();
        }
        goto LABEL_335;
      }

      double v156 = xpc_double_get_value(v29);
      if (v156 <= 0.0)
      {
        if (byte_1000E7D30)
        {
          int v166 = *__error();
          BOOL v167 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v167, OS_LOG_TYPE_ERROR)) {
            sub_100086F74();
          }
          *__error() = v166;
        }

        if (!byte_1000E7D31 || dword_1000E74E0 > 3) {
          return;
        }
        int v15 = *__error();
        int v16 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"Error reporting disk writes resource: bad duration (%f)",  *(void *)&v156);
        if (v16) {
          goto LABEL_292;
        }
        id v188 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v188, OS_LOG_TYPE_FAULT)) {
          sub_100086F10();
        }
        goto LABEL_335;
      }

      xpc_object_t v157 = xpc_dictionary_get_value(xdict, "endtime");
      if (!v157 || (double v158 = v157, xpc_get_type(v157) != (xpc_type_t)&_xpc_type_double))
      {
        if (byte_1000E7D30)
        {
          int v159 = *__error();
          id v160 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v160, OS_LOG_TYPE_ERROR)) {
            sub_100086DC4();
          }
          *__error() = v159;
        }

        if (!byte_1000E7D31 || dword_1000E74E0 > 3) {
          return;
        }
        int v15 = *__error();
        int v16 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"Error reporting disk writes resource: no endtime provided");
        if (v16) {
          goto LABEL_292;
        }
        double v161 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v161, OS_LOG_TYPE_FAULT)) {
          sub_100086D98();
        }
        goto LABEL_335;
      }

      double v181 = xpc_double_get_value(v158);
      int64_t v182 = xpc_dictionary_get_int64(xdict, "io_limit");
      xpc_object_t v183 = xpc_dictionary_get_value(xdict, "duration_limit");
      if (!v183 || (unsigned int v184 = v183, xpc_get_type(v183) != (xpc_type_t)&_xpc_type_double))
      {
        if (byte_1000E7D30)
        {
          int v185 = *__error();
          id v186 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v186, OS_LOG_TYPE_ERROR)) {
            sub_100086E1C();
          }
          *__error() = v185;
        }

        if (!byte_1000E7D31 || dword_1000E74E0 > 3) {
          return;
        }
        int v15 = *__error();
        int v16 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"Error reporting disk writes resource: no duration_limit provided");
        if (v16) {
          goto LABEL_292;
        }
        id v187 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v187, OS_LOG_TYPE_FAULT)) {
          sub_100086DF0();
        }
        goto LABEL_335;
      }

      double v193 = xpc_double_get_value(v184);
      if (v193 >= 0.0)
      {
        uint64_t v203 = xpc_dictionary_get_string(xdict, "pname");
        if (v203) {
          uint64_t v204 = +[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v203);
        }
        else {
          uint64_t v204 = 0LL;
        }
        uint64_t v209 = xpc_dictionary_get_string(xdict, "action");
        if (v209)
        {
          uint64_t v210 = sub_100055AE4(v209);
          uint64_t v211 = +[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v210);
          free(v210);
        }

        else
        {
          uint64_t v211 = 0LL;
        }

        sub_1000421D8(v24, v204, v25, (uint64_t)v211, v27, v182, v156, v181, v193);
        return;
      }

      if (byte_1000E7D30)
      {
        int v194 = *__error();
        id v195 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v195, OS_LOG_TYPE_ERROR)) {
          sub_100086EAC();
        }
        *__error() = v194;
      }

      if (byte_1000E7D31 && dword_1000E74E0 <= 3)
      {
        int v15 = *__error();
        int v16 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"Error reporting disk writes resource: bad duration_limit (%f)",  *(void *)&v193);
        if (v16) {
          goto LABEL_292;
        }
        id v196 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v196, OS_LOG_TYPE_FAULT)) {
          sub_100086E48();
        }
        goto LABEL_335;
      }

      return;
    case 9LL:
      BOOL v33 = xpc_dictionary_get_BOOL(xdict, "callback");
      if (v33)
      {
        xpc_connection_t remote_connection = xpc_dictionary_get_remote_connection(xdict);
        if (remote_connection)
        {
          double v39 = remote_connection;
          xpc_object_t reply = xpc_dictionary_create_reply(xdict);
          if (reply)
          {
            int v45 = reply;
            if ((a2 & 1) != 0)
            {
LABEL_45:
              id v278 = v45;
              int v46 = v39;
              if (xpc_dictionary_get_value(xdict, "pid")) {
                int64_t v47 = xpc_dictionary_get_int64(xdict, "pid");
              }
              else {
                int64_t v47 = 0xFFFFFFFFLL;
              }
              int64_t v119 = xpc_dictionary_get_int64(xdict, "tid");
              xpc_object_t v120 = xpc_dictionary_get_value(xdict, "duration");
              double v121 = 0.0;
              double v122 = 0.0;
              if (v120)
              {
                uint64_t v123 = v120;
              }

              xpc_object_t v124 = xpc_dictionary_get_value(xdict, "interval");
              if (v124)
              {
                __int16 v125 = v124;
              }

              uint64_t v126 = xpc_dictionary_get_uint64(xdict, "flags");
              int v127 = xpc_dictionary_get_string(xdict, "reason");
              unsigned int v128 = (char *)xpc_dictionary_get_string(xdict, "signature");
              __int16 v129 = xpc_dictionary_get_string(xdict, "filename");
              if (v33)
              {
                xpc_retain(v46);
                v279[0] = _NSConcreteStackBlock;
                v279[1] = 3221225472LL;
                v279[2] = sub_10004A59C;
                v279[3] = &unk_1000D9178;
                v279[4] = v278;
                v279[5] = v46;
                v279[6] = sub_10002EDE8( "Pending reply for spindump request from [%d] for app [%d] thread %#llx",  a1,  v47,  v119);
                uint64_t v130 = v279;
              }

              else
              {
                uint64_t v130 = 0LL;
              }

              if (v128) {
                unsigned int v128 = sub_100055AE4(v128);
              }
              sub_10003C540(a1, a2, v47, v119, v126, (uint64_t)v127, v128, v129, v122, v121, (uint64_t)v130);
              free(v128);
              return;
            }

LABEL_292:
        int v168 = v16;
        unsigned int v169 = CFStringGetCStringPtr(v16, 0x8000100u);
        if (v169)
        {
          BOOL v170 = (char *)v169;
          uint64_t v171 = 0LL;
        }

        else
        {
          BOOL v170 = (char *)calloc(0x400uLL, 1uLL);
          CFStringGetCString(v168, v170, 1024LL, 0x8000100u);
          uint64_t v171 = v170;
        }

        if (qword_1000E7D38) {
          uint64_t v172 = (FILE *)qword_1000E7D38;
        }
        else {
          uint64_t v172 = __stderrp;
        }
        fprintf(v172, "%s\n", v170);
        if (v171) {
          free(v171);
        }
        CFRelease(v168);
        goto LABEL_339;
      }

      return;
  }

void sub_10004A59C(uint64_t a1, int a2, const char *a3)
{
  if (a3) {
    xpc_dictionary_set_string(*(xpc_object_t *)(a1 + 32), "path", a3);
  }
  xpc_connection_send_message(*(xpc_connection_t *)(a1 + 40), *(xpc_object_t *)(a1 + 32));

  xpc_release(*(xpc_object_t *)(a1 + 32));
  xpc_release(*(xpc_object_t *)(a1 + 40));
}

void sub_10004A604( void *a1, os_log_s *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
}

  ;
}

void sub_10004A620( void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
}

id sub_10004A634(char *a1, off_t a2, int a3, uint64_t a4, double a5, double a6)
{
  id result = sub_100029D0C(a1, a2, a3, 0LL, a4, 0LL, 1LL, 0xFFFFFFFFLL, a5, a6, 0LL, 0LL, 0, 0, 0LL);
  if (result)
  {
    if (byte_1000E7D30)
    {
      int v11 = *__error();
      int v12 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR)) {
        sub_1000872B0(v12, v13, v14, v15, v16, v17, v18, v19);
      }
      *__error() = v11;
    }

    if (byte_1000E7D31) {
      BOOL v20 = dword_1000E74E0 <= 3;
    }
    else {
      BOOL v20 = 0;
    }
    if (v20)
    {
      int v21 = *__error();
      uint64_t v22 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"%s: _HandleMicrostackshots returned a SASampleStore when saving to a file",  "!sampleStore");
      int v37 = v21;
      if (v22)
      {
        theString = v22;
        CStringPtr = CFStringGetCStringPtr(v22, 0x8000100u);
        if (CStringPtr)
        {
          BOOL v33 = (char *)CStringPtr;
          unsigned int v34 = 0LL;
        }

        else
        {
          BOOL v33 = (char *)calloc(0x400uLL, 1uLL);
          CFStringGetCString(theString, v33, 1024LL, 0x8000100u);
          unsigned int v34 = v33;
        }

        if (qword_1000E7D38) {
          uint64_t v35 = (FILE *)qword_1000E7D38;
        }
        else {
          uint64_t v35 = __stderrp;
        }
        fprintf(v35, "%s\n", v33);
        if (v34) {
          free(v34);
        }
        CFRelease(theString);
      }

      else
      {
        uint64_t v23 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v23, OS_LOG_TYPE_FAULT)) {
          sub_100087240(v23, v24, v25, v26, v27, v28, v29, v30);
        }
        if (qword_1000E7D38) {
          int v31 = (FILE *)qword_1000E7D38;
        }
        else {
          int v31 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v31);
      }

      *__error() = v37;
    }

    sub_10002EE78( "SaveMicrostackshotsToFile",  "microstackshot.m",  88,  "%s: _HandleMicrostackshots returned a SASampleStore when saving to a file",  v7,  v8,  v9,  v10,  (char)"!sampleStore");
    abort();
  }

  return result;
}

uint64_t sub_10004A830(const char *a1, int a2)
{
  if (!a1 || *a1 != 47) {
    return 1LL;
  }
  for (uint64_t i = 0LL; i != 6; ++i)
  {
    size_t v5 = strlen((&off_1000D9198)[i]);
    if (!strncmp(a1, (&off_1000D9198)[i], v5)) {
      return 0LL;
    }
  }

  if (!a2) {
    return 1LL;
  }
  BOOL v6 = -[NSURL initFileURLWithFileSystemRepresentation:isDirectory:relativeToURL:]( objc_alloc(&OBJC_CLASS___NSURL),  "initFileURLWithFileSystemRepresentation:isDirectory:relativeToURL:",  a1,  0LL,  0LL);
  if (!v6) {
    return 1LL;
  }
  uint64_t v7 = v6;
  uint64_t v8 = (__CFBundle *)_CFBundleCreateWithExecutableURLIfLooksLikeBundle(0LL, v6);

  if (!v8) {
    return 1LL;
  }
  Identifier = (__CFString *)CFBundleGetIdentifier(v8);
  BOOL v10 = !Identifier || (-[__CFString hasPrefix:](Identifier, "hasPrefix:", @"com.apple.") & 1) == 0;
  CFRelease(v8);
  return v10;
}

void sub_10004A92C(uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(a1 + 64) + 8LL);
  if (*(_DWORD *)(v1 + 24) == 2)
  {
    if (qword_1000E7C40 != -1) {
      dispatch_once(&qword_1000E7C40, &stru_1000D91C8);
    }
  }

  else
  {
    *(_DWORD *)(v1 + 24) = 1;
    int v3 = *(void **)(a1 + 32);
    if (v3)
    {
      bytes_ptr = xpc_data_get_bytes_ptr(v3);
      size_t length = xpc_data_get_length(*(xpc_object_t *)(a1 + 32));
      sub_10002B6C8( *(void **)(a1 + 40),  0LL,  (uint64_t)bytes_ptr,  length,  *(unsigned int *)(a1 + 104),  *(unsigned int *)(a1 + 108),  *(void *)(a1 + 80),  *(void *)(a1 + 48),  *(double *)(a1 + 88),  *(double *)(a1 + 96));
    }

    if (*(_BYTE *)(a1 + 116))
    {
      *(void *)(*(void *)(*(void *)(a1 + 72) + 8LL) + 24LL) = *(int *)(a1 + 112);
      dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 56));
    }
  }

void sub_10004A9F4(id a1)
{
  if (byte_1000E7D30)
  {
    int v1 = *__error();
    int v2 = (os_log_s *)sub_10002EFA0();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG)) {
      sub_100089078();
    }
    *__error() = v1;
  }

  if (byte_1000E7D31) {
    BOOL v3 = dword_1000E74E0 <= 0;
  }
  else {
    BOOL v3 = 0;
  }
  if (v3)
  {
    int v4 = *__error();
    size_t v5 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"Already timed out, not parsing system stats microstackshots");
    if (v5)
    {
      BOOL v6 = v5;
      CStringPtr = CFStringGetCStringPtr(v5, 0x8000100u);
      if (CStringPtr)
      {
        uint64_t v8 = (char *)CStringPtr;
        uint64_t v9 = 0LL;
      }

      else
      {
        uint64_t v8 = (char *)calloc(0x400uLL, 1uLL);
        CFStringGetCString(v6, v8, 1024LL, 0x8000100u);
        uint64_t v9 = v8;
      }

      if (qword_1000E7D38) {
        int v12 = (FILE *)qword_1000E7D38;
      }
      else {
        int v12 = __stderrp;
      }
      fprintf(v12, "%s\n", v8);
      if (v9) {
        free(v9);
      }
      CFRelease(v6);
    }

    else
    {
      BOOL v10 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_FAULT)) {
        sub_10008904C();
      }
      if (qword_1000E7D38) {
        int v11 = (FILE *)qword_1000E7D38;
      }
      else {
        int v11 = __stderrp;
      }
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v11);
    }

    *__error() = v4;
  }

int *sub_10004AB98(int *result)
{
  uint64_t v1 = *(void *)(*((void *)result + 4) + 8LL);
  if (*(_DWORD *)(v1 + 24))
  {
    *(_DWORD *)(v1 + 24) = 0;
    if (byte_1000E7D30)
    {
      int v2 = *__error();
      BOOL v3 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 67109120;
        int v19 = 30;
        _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEFAULT,  "Timed out system stats microstackshots after %d seconds, but it's parsing, so waiting a bit longer",  buf,  8u);
      }

      id result = __error();
      *id result = v2;
    }

    if (byte_1000E7D31) {
      BOOL v4 = dword_1000E74E0 <= 2;
    }
    else {
      BOOL v4 = 0;
    }
    if (!v4) {
      return result;
    }
    int v5 = *__error();
    BOOL v6 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"Timed out system stats microstackshots after %d seconds, but it's parsing, so waiting a bit longer",  30LL);
    if (!v6)
    {
      uint64_t v7 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_FAULT)) {
        sub_100089178();
      }
LABEL_35:
      if (qword_1000E7D38) {
        uint64_t v17 = (FILE *)qword_1000E7D38;
      }
      else {
        uint64_t v17 = __stderrp;
      }
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v17);
LABEL_39:
      id result = __error();
      *id result = v5;
      return result;
    }

    goto LABEL_24;
  }

  *(_DWORD *)(v1 + 24) = 2;
  *(_BYTE *)(*(void *)(*((void *)result + 5) + 8LL) + 24LL) = 1;
  if (byte_1000E7D30)
  {
    int v8 = *__error();
    uint64_t v9 = (os_log_s *)sub_10002EFA0();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
      sub_100089108();
    }
    id result = __error();
    *id result = v8;
  }

  if (byte_1000E7D31) {
    BOOL v10 = dword_1000E74E0 <= 3;
  }
  else {
    BOOL v10 = 0;
  }
  if (v10)
  {
    int v5 = *__error();
    BOOL v6 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"Timed out waiting for system stats microstackshots after %d seconds",  30LL);
    if (!v6)
    {
      uint64_t v16 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v16, OS_LOG_TYPE_FAULT)) {
        sub_1000890A4();
      }
      goto LABEL_35;
    }

int *sub_10004AF04()
{
  return __error();
}

void sub_10004AF10(void *a1, os_log_s *a2, uint64_t a3, const char *a4, uint8_t *a5)
{
}

void sub_10004AF1C(void *a1, os_log_s *a2, uint64_t a3, const char *a4, uint8_t *a5)
{
}

  ;
}

  ;
}

void sub_10004AF48( void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
}

void sub_10004AF5C( void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
}

void sub_10004AF70( void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
}

void sub_10004AF84( void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
}

  ;
}

  ;
}

int *sub_10004AFD0()
{
  return __error();
}

  ;
}

char *sub_10004AFE8(int *a1)
{
  return strerror(*a1);
}

uint64_t sub_10004AFF8(uint64_t result, uint64_t a2, int a3, float a4)
{
  *(float *)a2 = a4;
  *(_DWORD *)(a2 + 4) = a3;
  *(_WORD *)(a2 + _Block_object_dispose((const void *)(v17 - 80), 8) = 2080;
  *(void *)(a2 + 10) = result;
  return result;
}

  ;
}

id sub_10004B020(uint64_t a1, id *a2)
{
  return [*a2 localizedDescription];
}

  ;
}

NSString *sub_10004B040(int a1, _BYTE *a2, int a3)
{
  if (a2 && *a2 == 47) {
    return -[NSString initWithUTF8String:](objc_alloc(&OBJC_CLASS___NSString), "initWithUTF8String:", a2);
  }
  if (a3 && proc_pidpath(a1, buffer, 0x400u) > 0) {
    return -[NSString initWithUTF8String:](objc_alloc(&OBJC_CLASS___NSString), "initWithUTF8String:", buffer);
  }
  return 0LL;
}

uint64_t sub_10004B10C( void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, double a9, double a10, uint64_t a11, uint64_t a12)
{
  int v14 = a8;
  int v15 = a6;
  int v16 = a5;
  if (byte_1000E7D30)
  {
    int v20 = *__error();
    int v21 = (os_log_s *)sub_10002EFA0();
    if (os_log_type_enabled(v21, OS_LOG_TYPE_DEBUG)) {
      sub_100089728(a4, v16, v21);
    }
    *__error() = v20;
  }

  if (byte_1000E7D31) {
    BOOL v22 = dword_1000E74E0 <= 0;
  }
  else {
    BOOL v22 = 0;
  }
  if (v22)
  {
    int v23 = *__error();
    uint64_t v24 = sub_100025FEC(a4, v16);
    uint64_t v25 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"Saving %s report", v24);
    if (v25)
    {
      uint64_t v26 = v25;
      CStringPtr = CFStringGetCStringPtr(v25, 0x8000100u);
      if (CStringPtr)
      {
        uint64_t v28 = (char *)CStringPtr;
        uint64_t v29 = 0LL;
      }

      else
      {
        uint64_t v28 = (char *)calloc(0x400uLL, 1uLL);
        CFStringGetCString(v26, v28, 1024LL, 0x8000100u);
        uint64_t v29 = v28;
      }

      if (qword_1000E7D38) {
        int v32 = (FILE *)qword_1000E7D38;
      }
      else {
        int v32 = __stderrp;
      }
      fprintf(v32, "%s\n", v28);
      if (v29) {
        free(v29);
      }
      CFRelease(v26);
    }

    else
    {
      uint64_t v30 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v30, OS_LOG_TYPE_FAULT)) {
        sub_1000896C4();
      }
      if (qword_1000E7D38) {
        int v31 = (FILE *)qword_1000E7D38;
      }
      else {
        int v31 = __stderrp;
      }
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v31);
    }

    *__error() = v23;
  }

  BOOL v33 = @"periodic-io-microstackshot-report";
  unsigned int v34 = @"144";
  switch((int)a4)
  {
    case 3:
      if (byte_1000E7D30)
      {
        int v35 = *__error();
        uint64_t v36 = (char *)sub_10002EFA0();
        if (os_log_type_enabled((os_log_t)v36, OS_LOG_TYPE_ERROR)) {
          sub_100089634(a1, v36);
        }
        *__error() = v35;
      }

      if (byte_1000E7D31) {
        BOOL v37 = dword_1000E74E0 <= 3;
      }
      else {
        BOOL v37 = 0;
      }
      if (v37)
      {
        int v38 = *__error();
        double v39 = (const char *)objc_msgSend( objc_msgSend(objc_msgSend(objc_msgSend(a1, "sampleStore"), "targetProcess"), "name"),  "UTF8String");
        if (v39) {
          int v40 = v39;
        }
        else {
          int v40 = "No app";
        }
        uint64_t v41 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"%s: %s: DID_MANUAL status while reporting",  "status != DID_MANUAL",  v40);
        if (v41)
        {
          uint64_t v78 = v41;
          BOOL v79 = CFStringGetCStringPtr(v41, 0x8000100u);
          if (v79)
          {
            uint64_t v80 = (char *)v79;
            BOOL v81 = 0LL;
          }

          else
          {
            uint64_t v80 = (char *)calloc(0x400uLL, 1uLL);
            CFStringGetCString(v78, v80, 1024LL, 0x8000100u);
            BOOL v81 = v80;
          }

          if (qword_1000E7D38) {
            BOOL v85 = (FILE *)qword_1000E7D38;
          }
          else {
            BOOL v85 = __stderrp;
          }
          fprintf(v85, "%s\n", v80);
          if (v81) {
            free(v81);
          }
          CFRelease(v78);
        }

        else
        {
          uint64_t v42 = (char *)sub_10002EFA0();
          if (os_log_type_enabled((os_log_t)v42, OS_LOG_TYPE_FAULT)) {
            sub_1000895A4(a1, v42);
          }
          if (qword_1000E7D38) {
            uint64_t v43 = (FILE *)qword_1000E7D38;
          }
          else {
            uint64_t v43 = __stderrp;
          }
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v43);
        }

        *__error() = v38;
      }

      objc_msgSend(objc_msgSend(objc_msgSend(objc_msgSend(a1, "sampleStore"), "targetProcess"), "name"), "UTF8String");
      sub_10002EE78( "SaveReport",  "reporting.m",  453,  "%s: %s: DID_MANUAL status while reporting",  v86,  v87,  v88,  v89,  (char)"status != DID_MANUAL");
      goto LABEL_132;
    case 4:
      uint64_t v44 = objc_alloc_init(&OBJC_CLASS___NSDate);
      int v45 = objc_alloc_init(&OBJC_CLASS___NSDateFormatter);
      -[NSDateFormatter setDateFormat:](v45, "setDateFormat:", @"yyyy-MM-dd-HHmmss");
      int v46 = -[NSDateFormatter stringFromDate:](v45, "stringFromDate:", v44);

      int64_t v47 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"/var/mobile/Library/Logs/CrashReporter/ShutdownStall-%@.txt",  v46);
      int64_t v48 = fopen(-[NSString UTF8String](v47, "UTF8String"), "wx");
      if (v48)
      {
        uint64_t v49 = v48;
        uint64_t v50 = 1LL;
        fwrite("Use spindump -i to generate textual report\n\n", 0x2CuLL, 1uLL, v48);
        objc_msgSend(objc_msgSend(a1, "sampleStore"), "saveBinaryFormatToStream:", v49);
        fclose(v49);
      }

      else
      {
        int v100 = *__error();
        BOOL v101 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v101, OS_LOG_TYPE_FAULT)) {
          sub_100089330();
        }
        *__error() = v100;
        if (byte_1000E7D31 && dword_1000E74E0 <= 4)
        {
          int v102 = *__error();
          uint64_t v103 = *__error();
          int v104 = __error();
          BOOL v105 = strerror(*v104);
          uint64_t v106 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"Unable to create stream from %@: %d (%s)",  v47,  v103,  v105);
          if (v106)
          {
            int v107 = v106;
            unint64_t v108 = CFStringGetCStringPtr(v106, 0x8000100u);
            if (v108)
            {
              BOOL v109 = (char *)v108;
              uint64_t v110 = 0LL;
            }

            else
            {
              BOOL v109 = (char *)calloc(0x400uLL, 1uLL);
              CFStringGetCString(v107, v109, 1024LL, 0x8000100u);
              uint64_t v110 = v109;
            }

            if (qword_1000E7D38) {
              int v140 = (FILE *)qword_1000E7D38;
            }
            else {
              int v140 = __stderrp;
            }
            fprintf(v140, "%s\n", v109);
            if (v110) {
              free(v110);
            }
            CFRelease(v107);
          }

          else
          {
            uint64_t v130 = (os_log_s *)sub_10002EFA0();
            if (os_log_type_enabled(v130, OS_LOG_TYPE_FAULT)) {
              sub_1000892AC();
            }
            if (qword_1000E7D38) {
              int v131 = (FILE *)qword_1000E7D38;
            }
            else {
              int v131 = __stderrp;
            }
            fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v131);
          }

          *__error() = v102;
        }

        return 0LL;
      }

      return v50;
    case 5:
      id v51 = objc_msgSend(objc_msgSend(objc_msgSend(a1, "sampleStore"), "targetProcess"), "name");
      if (v51)
      {
        id v52 = v51;
        uint64_t v53 = objc_alloc(&OBJC_CLASS___NSString);
        if (v15)
        {
          BOOL v33 = -[NSString initWithFormat:](v53, "initWithFormat:", @"%@.cpu_resource_fatal", v52);
          unsigned int v34 = @"206";
        }

        else
        {
          BOOL v33 = -[NSString initWithFormat:](v53, "initWithFormat:", @"%@.cpu_resource", v52);
          unsigned int v34 = (const __CFString *)kOSAProblemTypeExcResource;
        }

        goto LABEL_71;
      }

      if (byte_1000E7D30)
      {
        int v115 = *__error();
        uint64_t v116 = (char *)sub_10002EFA0();
        if (os_log_type_enabled((os_log_t)v116, OS_LOG_TYPE_ERROR)) {
          sub_100089434(a1, v116);
        }
        *__error() = v115;
      }

      if (byte_1000E7D31) {
        BOOL v117 = dword_1000E74E0 <= 3;
      }
      else {
        BOOL v117 = 0;
      }
      if (v117)
      {
        int v118 = *__error();
        int64_t v119 = CFStringCreateWithFormat( kCFAllocatorDefault,  0,  @"%s: No app name for cpu resource report %s",  "appName",  objc_msgSend( objc_msgSend(objc_msgSend(objc_msgSend(a1, "sampleStore"), "targetProcess"), "debugDescription"),  "UTF8String"));
        if (v119)
        {
          uint64_t v132 = v119;
          BOOL v133 = CFStringGetCStringPtr(v119, 0x8000100u);
          if (v133)
          {
            dispatch_queue_global_t v134 = (char *)v133;
            id v135 = 0LL;
          }

          else
          {
            dispatch_queue_global_t v134 = (char *)calloc(0x400uLL, 1uLL);
            CFStringGetCString(v132, v134, 1024LL, 0x8000100u);
            id v135 = v134;
          }

          if (qword_1000E7D38) {
            int v141 = (FILE *)qword_1000E7D38;
          }
          else {
            int v141 = __stderrp;
          }
          fprintf(v141, "%s\n", v134);
          if (v135) {
            free(v135);
          }
          CFRelease(v132);
        }

        else
        {
          xpc_object_t v120 = (char *)sub_10002EFA0();
          if (os_log_type_enabled((os_log_t)v120, OS_LOG_TYPE_FAULT)) {
            sub_1000893B4(a1, v120);
          }
          if (qword_1000E7D38) {
            double v121 = (FILE *)qword_1000E7D38;
          }
          else {
            double v121 = __stderrp;
          }
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v121);
        }

        *__error() = v118;
      }

      objc_msgSend( objc_msgSend(objc_msgSend(objc_msgSend(a1, "sampleStore"), "targetProcess"), "debugDescription"),  "UTF8String");
      sub_10002EE78( "SaveReport",  "reporting.m",  383,  "%s: No app name for cpu resource report %s",  v142,  v143,  v144,  v145,  (char)"appName");
      goto LABEL_132;
    case 6:
      id v54 = objc_msgSend(objc_msgSend(objc_msgSend(a1, "sampleStore"), "targetProcess"), "name");
      if (!v54)
      {
        if (byte_1000E7D30)
        {
          int v122 = *__error();
          uint64_t v123 = (char *)sub_10002EFA0();
          if (os_log_type_enabled((os_log_t)v123, OS_LOG_TYPE_ERROR)) {
            sub_100089434(a1, v123);
          }
          *__error() = v122;
        }

        if (byte_1000E7D31) {
          BOOL v124 = dword_1000E74E0 <= 3;
        }
        else {
          BOOL v124 = 0;
        }
        if (v124)
        {
          int v125 = *__error();
          uint64_t v126 = CFStringCreateWithFormat( kCFAllocatorDefault,  0,  @"%s: No app name for cpu resource report %s",  "appName",  objc_msgSend( objc_msgSend(objc_msgSend(objc_msgSend(a1, "sampleStore"), "targetProcess"), "debugDescription"),  "UTF8String"));
          if (v126)
          {
            uint64_t v136 = v126;
            int v137 = CFStringGetCStringPtr(v126, 0x8000100u);
            if (v137)
            {
              double v138 = (char *)v137;
              xpc_object_t v139 = 0LL;
            }

            else
            {
              double v138 = (char *)calloc(0x400uLL, 1uLL);
              CFStringGetCString(v136, v138, 1024LL, 0x8000100u);
              xpc_object_t v139 = v138;
            }

            if (qword_1000E7D38) {
              id v146 = (FILE *)qword_1000E7D38;
            }
            else {
              id v146 = __stderrp;
            }
            fprintf(v146, "%s\n", v138);
            if (v139) {
              free(v139);
            }
            CFRelease(v136);
          }

          else
          {
            int v127 = (char *)sub_10002EFA0();
            if (os_log_type_enabled((os_log_t)v127, OS_LOG_TYPE_FAULT)) {
              sub_1000893B4(a1, v127);
            }
            if (qword_1000E7D38) {
              unsigned int v128 = (FILE *)qword_1000E7D38;
            }
            else {
              unsigned int v128 = __stderrp;
            }
            fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v128);
          }

          *__error() = v125;
        }

        objc_msgSend( objc_msgSend(objc_msgSend(objc_msgSend(a1, "sampleStore"), "targetProcess"), "debugDescription"),  "UTF8String");
        sub_10002EE78( "SaveReport",  "reporting.m",  409,  "%s: No app name for cpu resource report %s",  v147,  v148,  v149,  v150,  (char)"appName");
LABEL_132:
        abort();
      }

      BOOL v33 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"%@.diskwrites_resource",  v54);
      if (v15 && qword_1000E7C48 != -1) {
        dispatch_once(&qword_1000E7C48, &stru_1000D9260);
      }
      unsigned int v34 = @"145";
LABEL_71:
      if (a12)
      {
        if (byte_1000E7D30)
        {
          int v91 = *__error();
          int v92 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v92, OS_LOG_TYPE_ERROR)) {
            sub_100089528(v92);
          }
          *__error() = v91;
        }

        if (byte_1000E7D31) {
          BOOL v93 = dword_1000E74E0 <= 3;
        }
        else {
          BOOL v93 = 0;
        }
        if (v93)
        {
          int v94 = *__error();
          int v95 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"%s: asking for URL when generating report via OSA",  "!url_out");
          if (v95)
          {
            int v111 = v95;
            double v112 = CFStringGetCStringPtr(v95, 0x8000100u);
            if (v112)
            {
              BOOL v113 = (char *)v112;
              id v114 = 0LL;
            }

            else
            {
              BOOL v113 = (char *)calloc(0x400uLL, 1uLL);
              CFStringGetCString(v111, v113, 1024LL, 0x8000100u);
              id v114 = v113;
            }

            if (qword_1000E7D38) {
              __int16 v129 = (FILE *)qword_1000E7D38;
            }
            else {
              __int16 v129 = __stderrp;
            }
            fprintf(v129, "%s\n", v113);
            if (v114) {
              free(v114);
            }
            CFRelease(v111);
          }

          else
          {
            unsigned int v96 = (os_log_s *)sub_10002EFA0();
            if (os_log_type_enabled(v96, OS_LOG_TYPE_FAULT)) {
              sub_1000894B4(v96, v97, v98);
            }
            if (qword_1000E7D38) {
              int v99 = (FILE *)qword_1000E7D38;
            }
            else {
              int v99 = __stderrp;
            }
            fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v99);
          }

          *__error() = v94;
        }

        sub_10002EE78( "SaveReport",  "reporting.m",  554,  "%s: asking for URL when generating report via OSA",  a5,  a6,  a7,  a8,  (char)"!url_out");
        goto LABEL_132;
      }

      id v65 = objc_msgSend(objc_msgSend(a1, "sampleStore"), "targetProcess");
      if ([v65 developerType] == 1)
      {
        uint64_t v66 = 1LL;
      }

      else if ([v65 developerType] == -1 && objc_msgSend(v65, "bundleIdentifier"))
      {
        uint64_t v66 = (uint64_t)objc_msgSend(objc_msgSend(v65, "bundleIdentifier"), "hasPrefix:", @"com.apple.");
      }

      else
      {
        uint64_t v66 = 0LL;
      }

      v155[0] = kOSALogMetadataAppName;
      if ((_DWORD)a4 == 4)
      {
        int64_t v67 = @"shutdown_stall";
      }

      else
      {
        uint64_t v68 = (const __CFString *)[v65 name];
        if (v68) {
          int64_t v67 = v68;
        }
        else {
          int64_t v67 = @"Unknown";
        }
      }

      v156[0] = v67;
      v155[1] = @"app_name";
      uint64_t v69 = (const __CFString *)[v65 name];
      if (v69) {
        int v70 = v69;
      }
      else {
        int v70 = @"Unknown";
      }
      v156[1] = v70;
      v155[2] = @"is_first_party";
      v156[2] = +[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", v66);
      v155[3] = @"share_with_app_devs";
      v156[3] = +[NSNumber numberWithBool:]( &OBJC_CLASS___NSNumber,  "numberWithBool:",  -[OSASystemConfiguration optIn3rdParty]( +[OSASystemConfiguration sharedInstance](&OBJC_CLASS___OSASystemConfiguration, "sharedInstance"),  "optIn3rdParty"));
      id v71 = -[NSDictionary mutableCopy]( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v156,  v155,  4LL),  "mutableCopy");
      if ([a1 incidentUUID])
      {
        id v72 = objc_msgSend(objc_msgSend(a1, "incidentUUID"), "UUIDString");
        [v71 setObject:v72 forKeyedSubscript:kOSALogMetadataIncidentID];
      }

      if ([v65 mainBinary])
      {
        int v73 = (const __CFString *)objc_msgSend(objc_msgSend(objc_msgSend(v65, "mainBinary"), "uuid"), "UUIDString");
        if (v73) {
          int v74 = v73;
        }
        else {
          int v74 = &stru_1000DCBB0;
        }
        [v71 setObject:v74 forKeyedSubscript:@"slice_uuid"];
      }

      if ([v65 bundleIdentifier])
      {
        id v75 = [v65 bundleIdentifier];
        [v71 setObject:v75 forKeyedSubscript:kOSALogMetadataBundleID];
      }

      if ([v65 bundleVersion]) {
        objc_msgSend(v71, "setObject:forKeyedSubscript:", objc_msgSend(v65, "bundleVersion"), @"build_version");
      }
      if ([v65 bundleShortVersion]) {
        objc_msgSend(v71, "setObject:forKeyedSubscript:", objc_msgSend(v65, "bundleShortVersion"), @"app_version");
      }
      if ([v65 isBeta])
      {
        [v71 setObject:&__kCFBooleanTrue forKeyedSubscript:@"is_beta"];
        if ([v65 cohortID]) {
          objc_msgSend(v71, "setObject:forKeyedSubscript:", objc_msgSend(v65, "cohortID"), @"app_cohort");
        }
      }

      if ([v65 adamID]) {
        [v71 setObject:+[NSString stringWithFormat:]( NSString, "stringWithFormat:", @"%llu", objc_msgSend(v65, "adamID")), @"adam_id" forKeyedSubscript];
      }
      if ([v65 distributorID]) {
        objc_msgSend(v71, "setObject:forKeyedSubscript:", objc_msgSend(v65, "distributorID"), @"distributor_id");
      }
      if (v14 && objc_msgSend(objc_msgSend(v65, "mainBinaryPath"), "isAbsolutePath"))
      {
        id v76 = [v65 mainBinaryPath];
        [v71 setObject:v76 forKeyedSubscript:kOSALogOptionReopenPath];
      }

      if (a9 > 0.0)
      {
        sub_100025E98(v154, 0x32uLL, 0, a9);
        objc_msgSend( v71,  "setObject:forKeyedSubscript:",  +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v154),  @"timestamp");
      }

      if (a10 > 0.0) {
        [v71 setObject:+[NSString stringWithFormat:](NSString, "stringWithFormat:", @"%.0f", a10 * 1000.0), @"duration_ms" forKeyedSubscript];
      }
      v152[0] = _NSConcreteStackBlock;
      v152[1] = 3221225472LL;
      v152[2] = sub_10004C518;
      v152[3] = &unk_1000D9288;
      int v153 = a4;
      v152[4] = a1;
      v152[5] = a2;
      v152[6] = a3;
      uint64_t v50 = OSAWriteLogForSubmission(v34, v33, v71, 0LL, v152);

      return v50;
    case 7:
      unsigned int v34 = (const __CFString *)kOSAProblemTypeNewMicroSS;
      BOOL v33 = @"periodic-microstackshot-report";
      goto LABEL_71;
    case 8:
      goto LABEL_71;
    case 9:
    case 10:
      unsigned int v34 = 0LL;
      BOOL v33 = 0LL;
      goto LABEL_71;
    case 14:
      BOOL v33 = 0LL;
      unsigned int v34 = @"239";
      goto LABEL_71;
    default:
      int v55 = *__error();
      uint64_t v56 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v56, OS_LOG_TYPE_FAULT)) {
        sub_100089244(a4, v56, v57);
      }
      *__error() = v55;
      if (byte_1000E7D31) {
        BOOL v58 = dword_1000E74E0 <= 4;
      }
      else {
        BOOL v58 = 0;
      }
      if (!v58) {
        return 0LL;
      }
      int v59 = *__error();
      int v60 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"SaveReport: Unsupported status %d", a4);
      if (v60)
      {
        int v61 = v60;
        int v62 = CFStringGetCStringPtr(v60, 0x8000100u);
        if (v62)
        {
          int64_t v63 = (char *)v62;
          uint64_t v64 = 0LL;
        }

        else
        {
          int64_t v63 = (char *)calloc(0x400uLL, 1uLL);
          CFStringGetCString(v61, v63, 1024LL, 0x8000100u);
          uint64_t v64 = v63;
        }

        if (qword_1000E7D38) {
          __int16 v90 = (FILE *)qword_1000E7D38;
        }
        else {
          __int16 v90 = __stderrp;
        }
        fprintf(v90, "%s\n", v63);
        if (v64) {
          free(v64);
        }
        CFRelease(v61);
      }

      else
      {
        int v82 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v82, OS_LOG_TYPE_FAULT)) {
          sub_1000891DC(a4, v82, v83);
        }
        if (qword_1000E7D38) {
          int v84 = (FILE *)qword_1000E7D38;
        }
        else {
          int v84 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v84);
      }

      uint64_t v50 = 0LL;
      *__error() = v59;
      return v50;
  }

void sub_10004C384(id a1)
{
  int v1 = *__error();
  int v2 = (os_log_s *)sub_10002EFA0();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
    sub_1000897D8(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  *__error() = v1;
  if (byte_1000E7D31) {
    BOOL v10 = dword_1000E74E0 <= 4;
  }
  else {
    BOOL v10 = 0;
  }
  if (v10)
  {
    int v11 = *__error();
    int v12 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"No bug type for fatal disk writes reports, using non-fatal bug type");
    if (v12)
    {
      uint64_t v13 = v12;
      CStringPtr = CFStringGetCStringPtr(v12, 0x8000100u);
      if (CStringPtr)
      {
        int v15 = (char *)CStringPtr;
        int v16 = 0LL;
      }

      else
      {
        int v15 = (char *)calloc(0x400uLL, 1uLL);
        CFStringGetCString(v13, v15, 1024LL, 0x8000100u);
        int v16 = v15;
      }

      if (qword_1000E7D38) {
        uint64_t v26 = (FILE *)qword_1000E7D38;
      }
      else {
        uint64_t v26 = __stderrp;
      }
      fprintf(v26, "%s\n", v15);
      if (v16) {
        free(v16);
      }
      CFRelease(v13);
    }

    else
    {
      uint64_t v17 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v17, OS_LOG_TYPE_FAULT)) {
        sub_1000897A8(v17, v18, v19, v20, v21, v22, v23, v24);
      }
      if (qword_1000E7D38) {
        uint64_t v25 = (FILE *)qword_1000E7D38;
      }
      else {
        uint64_t v25 = __stderrp;
      }
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v25);
    }

    *__error() = v11;
  }

int *sub_10004C518(uint64_t a1, void *a2)
{
  if ([a2 fileDescriptor] == -1)
  {
    int v35 = *__error();
    uint64_t v36 = (os_log_s *)sub_10002EFA0();
    if (os_log_type_enabled(v36, OS_LOG_TYPE_FAULT)) {
      sub_10008987C(a2, v36);
    }
    id result = __error();
    *id result = v35;
    if (byte_1000E7D31) {
      BOOL v37 = dword_1000E74E0 <= 4;
    }
    else {
      BOOL v37 = 0;
    }
    if (v37)
    {
      int v38 = *__error();
      double v39 = CFStringCreateWithFormat( kCFAllocatorDefault,  0,  @"OSAWriteLogForSubmission provided invalid fd: %@",  [a2 debugDescription]);
      if (!v39)
      {
        uint64_t v57 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v57, OS_LOG_TYPE_FAULT)) {
          sub_100089808(a2, v57);
        }
        goto LABEL_105;
      }

      int v40 = v39;
      CStringPtr = CFStringGetCStringPtr(v39, 0x8000100u);
      if (CStringPtr)
      {
        uint64_t v42 = (char *)CStringPtr;
        uint64_t v43 = 0LL;
      }

      else
      {
        uint64_t v42 = (char *)calloc(0x400uLL, 1uLL);
        CFStringGetCString(v40, v42, 1024LL, 0x8000100u);
        uint64_t v43 = v42;
      }

      if (qword_1000E7D38) {
        int v60 = (FILE *)qword_1000E7D38;
      }
      else {
        int v60 = __stderrp;
      }
      fprintf(v60, "%s\n", v42);
      if (v43) {
        free(v43);
      }
      int v59 = v40;
LABEL_102:
      CFRelease(v59);
LABEL_109:
      id result = __error();
      *id result = v38;
    }
  }

  else
  {
    int v4 = dup((int)[a2 fileDescriptor]);
    if (v4 == -1)
    {
      int v49 = *__error();
      uint64_t v50 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v50, OS_LOG_TYPE_FAULT)) {
        sub_100089960();
      }
      id result = __error();
      *id result = v49;
      if (byte_1000E7D31) {
        BOOL v51 = dword_1000E74E0 <= 4;
      }
      else {
        BOOL v51 = 0;
      }
      if (v51)
      {
        int v38 = *__error();
        id v52 = __error();
        int64_t v47 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"dup of OSA file handle failed: %{errnod}d",  *v52);
        if (!v47)
        {
          int v61 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v61, OS_LOG_TYPE_FAULT)) {
            sub_1000898F0();
          }
          goto LABEL_105;
        }

        goto LABEL_84;
      }
    }

    else
    {
      uint64_t v5 = fdopen(v4, "a");
      if (v5)
      {
        uint64_t v6 = v5;
        if (*(_DWORD *)(a1 + 56) == 4)
        {
          fwrite("Use spindump -i to generate textual report\n\n", 0x2CuLL, 1uLL, v5);
          objc_msgSend(objc_msgSend(*(id *)(a1 + 32), "sampleStore"), "saveBinaryFormatToStream:", v6);
        }

        else
        {
          uint64_t v7 = *(void **)(a1 + 40);
          if (v7)
          {
            if (fwrite([v7 bytes], (size_t)objc_msgSend(*(id *)(a1 + 40), "length"), 1uLL, v6) != 1)
            {
              if (byte_1000E7D30)
              {
                int v8 = *__error();
                uint64_t v9 = (os_log_s *)sub_10002EFA0();
                if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
                  sub_100089BF4(v6);
                }
                *__error() = v8;
              }

              if (byte_1000E7D31 && dword_1000E74E0 <= 3)
              {
                int v10 = *__error();
                uint64_t v11 = ferror(v6);
                int v12 = strerror(v11);
                uint64_t v13 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"Unable to write pre-blob to output file: %d (%s)",  v11,  v12);
                if (v13)
                {
                  int v14 = v13;
                  int v15 = CFStringGetCStringPtr(v13, 0x8000100u);
                  if (v15)
                  {
                    int v16 = (char *)v15;
                    uint64_t v17 = 0LL;
                  }

                  else
                  {
                    int v16 = (char *)calloc(0x400uLL, 1uLL);
                    CFStringGetCString(v14, v16, 1024LL, 0x8000100u);
                    uint64_t v17 = v16;
                  }

                  if (qword_1000E7D38) {
                    uint64_t v20 = (FILE *)qword_1000E7D38;
                  }
                  else {
                    uint64_t v20 = __stderrp;
                  }
                  fprintf(v20, "%s\n", v16);
                  if (v17) {
                    free(v17);
                  }
                  CFRelease(v14);
                }

                else
                {
                  uint64_t v18 = (os_log_s *)sub_10002EFA0();
                  if (os_log_type_enabled(v18, OS_LOG_TYPE_FAULT)) {
                    sub_100089B88(v6);
                  }
                  if (qword_1000E7D38) {
                    uint64_t v19 = (FILE *)qword_1000E7D38;
                  }
                  else {
                    uint64_t v19 = __stderrp;
                  }
                  fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v19);
                }

                *__error() = v10;
              }
            }

            fwrite("\n================================================================\n", 0x42uLL, 1uLL, v6);
          }

          [*(id *)(a1 + 32) printToStream:v6];
          if (*(void *)(a1 + 48))
          {
            fwrite("\n================================================================\n", 0x42uLL, 1uLL, v6);
            if (fwrite( [*(id *)(a1 + 48) bytes],  (size_t)objc_msgSend(*(id *)(a1 + 48), "length"),  1uLL,  v6) != 1)
            {
              if (byte_1000E7D30)
              {
                int v21 = *__error();
                uint64_t v22 = (os_log_s *)sub_10002EFA0();
                if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR)) {
                  sub_100089B1C(v6);
                }
                *__error() = v21;
              }

              if (byte_1000E7D31 && dword_1000E74E0 <= 3)
              {
                int v23 = *__error();
                uint64_t v24 = ferror(v6);
                uint64_t v25 = strerror(v24);
                uint64_t v26 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"Unable to write post-blob to output file: %d (%s)",  v24,  v25);
                if (v26)
                {
                  uint64_t v27 = v26;
                  uint64_t v28 = CFStringGetCStringPtr(v26, 0x8000100u);
                  if (v28)
                  {
                    uint64_t v29 = (char *)v28;
                    uint64_t v30 = 0LL;
                  }

                  else
                  {
                    uint64_t v29 = (char *)calloc(0x400uLL, 1uLL);
                    CFStringGetCString(v27, v29, 1024LL, 0x8000100u);
                    uint64_t v30 = v29;
                  }

                  if (qword_1000E7D38) {
                    BOOL v33 = (FILE *)qword_1000E7D38;
                  }
                  else {
                    BOOL v33 = __stderrp;
                  }
                  fprintf(v33, "%s\n", v29);
                  if (v30) {
                    free(v30);
                  }
                  CFRelease(v27);
                }

                else
                {
                  int v31 = (os_log_s *)sub_10002EFA0();
                  if (os_log_type_enabled(v31, OS_LOG_TYPE_FAULT)) {
                    sub_100089AB0(v6);
                  }
                  if (qword_1000E7D38) {
                    int v32 = (FILE *)qword_1000E7D38;
                  }
                  else {
                    int v32 = __stderrp;
                  }
                  fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v32);
                }

                *__error() = v23;
              }
            }
          }
        }

        return (int *)fclose(v6);
      }

      int v44 = *__error();
      int v45 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v45, OS_LOG_TYPE_FAULT)) {
        sub_100089A40();
      }
      id result = __error();
      *id result = v44;
      if (byte_1000E7D31 && dword_1000E74E0 <= 4)
      {
        int v38 = *__error();
        int v46 = __error();
        int64_t v47 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"unable to fdopen OSA dup fd: %{errno}d",  *v46);
        if (!v47)
        {
          int64_t v48 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v48, OS_LOG_TYPE_FAULT)) {
            sub_1000899D0();
          }
LABEL_105:
          if (qword_1000E7D38) {
            int v62 = (FILE *)qword_1000E7D38;
          }
          else {
            int v62 = __stderrp;
          }
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v62);
          goto LABEL_109;
        }

LABEL_84:
        uint64_t v53 = v47;
        id v54 = CFStringGetCStringPtr(v47, 0x8000100u);
        if (v54)
        {
          int v55 = (char *)v54;
          uint64_t v56 = 0LL;
        }

        else
        {
          int v55 = (char *)calloc(0x400uLL, 1uLL);
          CFStringGetCString(v53, v55, 1024LL, 0x8000100u);
          uint64_t v56 = v55;
        }

        if (qword_1000E7D38) {
          BOOL v58 = (FILE *)qword_1000E7D38;
        }
        else {
          BOOL v58 = __stderrp;
        }
        fprintf(v58, "%s\n", v55);
        if (v56) {
          free(v56);
        }
        int v59 = v53;
        goto LABEL_102;
      }
    }
  }

  return result;
}

CFStringRef sub_10004CD1C(int a1, int a2)
{
  int v2 = @"--------------------------------------------------\nTimeline format: stacks are sorted chronologically\nUse -i and -heavy to re-report with count sorting\n--------------------------------------------------";
  if (a1) {
    int v2 = @"------------------------------------------------------------\nHeavy format: stacks are sorted by count\nUse -i and -timeline to re-report with chronological sorting\n------------------------------------------------------------";
  }
  uint64_t v3 = @"--------------------------------------------------\nTimeline format: stacks are sorted chronologically\n--------------------------------------------------";
  if (a1) {
    uint64_t v3 = @"----------------------------------------\nHeavy format: stacks are sorted by count\n----------------------------------------";
  }
  if (a2) {
    return v2;
  }
  else {
    return v3;
  }
}

void sub_10004CD54( void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
}

void sub_10004CD68(void *a1, os_log_s *a2, uint64_t a3, const char *a4, uint8_t *a5)
{
}

  ;
}

void sub_10004CD88( void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
}

void sub_10004CD9C( void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
}

id sub_10004CDB0(void *a1, const char *a2)
{
  return [a1 sampleStore];
}

uint64_t sub_10004CDB8(FILE *a1)
{
  return ferror(a1);
}

char *sub_10004CDC0(int __errnum)
{
  return strerror(__errnum);
}

int *sub_10004CDC8()
{
  return __error();
}

  ;
}

uint64_t sub_10004CDE4(NSString *a1, void *a2, uint64_t a3, int a4, int a5, unsigned int a6, void *a7)
{
  if (a1)
  {
    int v12 = a1;
    if (stat(-[NSString fileSystemRepresentation](a1, "fileSystemRepresentation"), &v25)
      || (v25.st_mode & 0xF000) != 0x4000)
    {
      uint64_t v14 = sub_10002C4A8(-[NSString UTF8String](v12, "UTF8String"), a4, a5, a6);
      if (!a7) {
        return v14;
      }
      goto LABEL_21;
    }

    uint64_t v13 = (const __CFString *)v12;
  }

  else
  {
    uint64_t v13 = @"/tmp";
  }

  uint64_t v22 = a7;
  if (a2)
  {
    if ((a3 & 0x80000000) != 0) {
      int v15 = (NSString *)[a2 stringByReplacingOccurrencesOfString:@" " withString:@"_"];
    }
    else {
      int v15 = +[NSString stringWithFormat:]( NSString,  "stringWithFormat:",  @"%@_%i",  [a2 stringByReplacingOccurrencesOfString:@" " withString:@"_"],  a3);
    }
    int v16 = (const __CFString *)v15;
    uint64_t v17 = @".spindump.txt";
  }

  else
  {
    int v16 = @"spindump";
    uint64_t v17 = @".txt";
  }

  int v12 = +[NSString stringWithFormat:](&OBJC_CLASS___NSString, "stringWithFormat:", @"%@/%@%@", v13, v16, v17);
  int v18 = a4 | 0x800;
  LODWORD(v19) = 1;
  do
  {
    for (i = v12; !stat(-[NSString fileSystemRepresentation](i, "fileSystemRepresentation"), &v24); int v12 = i)
    {
      uint64_t v19 = (v19 + 1);
      uint64_t i = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"%@/%@.%d%@",  v13,  v16,  v19,  v17);
    }

    uint64_t v14 = sub_10002C4A8(-[NSString UTF8String](v12, "UTF8String"), v18, a5, a6);
  }

  while ((_DWORD)v14 == -1 && *__error() == 17);
  a7 = v22;
  if (v22) {
LABEL_21:
  }
    *a7 = v12;
  return v14;
}

BOOL sub_10004CFBC()
{
  return objc_opt_class(&OBJC_CLASS___BGSystemTaskScheduler) != 0;
}

void sub_10004CFE0()
{
  if (objc_opt_class(&OBJC_CLASS___BGSystemTaskScheduler))
  {
    if (qword_1000E7C58 != -1) {
      dispatch_once(&qword_1000E7C58, &stru_1000D9448);
    }
    dispatch_async((dispatch_queue_t)qword_1000E7C50, &stru_1000D9398);
  }

  else
  {
    if (byte_1000E7D30)
    {
      int v0 = *__error();
      int v1 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v1, OS_LOG_TYPE_INFO))
      {
        *(_WORD *)buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v1,  OS_LOG_TYPE_INFO,  "Deferred reports not supported, not checking for them",  buf,  2u);
      }

      *__error() = v0;
    }

    if (byte_1000E7D31) {
      BOOL v2 = dword_1000E74E0 <= 1;
    }
    else {
      BOOL v2 = 0;
    }
    if (v2)
    {
      int v3 = *__error();
      int v4 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"Deferred reports not supported, not checking for them");
      if (v4)
      {
        uint64_t v5 = v4;
        CStringPtr = CFStringGetCStringPtr(v4, 0x8000100u);
        if (CStringPtr)
        {
          uint64_t v7 = (char *)CStringPtr;
          int v8 = 0LL;
        }

        else
        {
          uint64_t v7 = (char *)calloc(0x400uLL, 1uLL);
          CFStringGetCString(v5, v7, 1024LL, 0x8000100u);
          int v8 = v7;
        }

        if (qword_1000E7D38) {
          uint64_t v11 = (FILE *)qword_1000E7D38;
        }
        else {
          uint64_t v11 = __stderrp;
        }
        fprintf(v11, "%s\n", v7);
        if (v8) {
          free(v8);
        }
        CFRelease(v5);
      }

      else
      {
        uint64_t v9 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v9, OS_LOG_TYPE_FAULT)) {
          sub_100089C60();
        }
        if (qword_1000E7D38) {
          int v10 = (FILE *)qword_1000E7D38;
        }
        else {
          int v10 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v10);
      }

      *__error() = v3;
    }
  }

void sub_10004D1FC(id a1)
{
  id v1 = +[BGSystemTaskScheduler sharedScheduler](&OBJC_CLASS___BGSystemTaskScheduler, "sharedScheduler");
  if (qword_1000E7C58 != -1) {
    dispatch_once(&qword_1000E7C58, &stru_1000D9448);
  }
  if ([v1 registerForTaskWithIdentifier:@"com.apple.spindump.deferred_report_generation" usingQueue:qword_1000E7C50 launchHandler:&stru_1000D93D8])
  {
    if (byte_1000E7D30)
    {
      int v2 = *__error();
      int v3 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG)) {
        sub_100089CC0();
      }
      *__error() = v2;
    }

    if (byte_1000E7D31) {
      BOOL v4 = dword_1000E74E0 <= 0;
    }
    else {
      BOOL v4 = 0;
    }
    if (!v4) {
      return;
    }
    int v5 = *__error();
    uint64_t v6 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"Registered for deferred report generation");
    if (!v6)
    {
      uint64_t v7 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_FAULT)) {
        sub_100089C90();
      }
LABEL_35:
      if (qword_1000E7D38) {
        uint64_t v17 = (FILE *)qword_1000E7D38;
      }
      else {
        uint64_t v17 = __stderrp;
      }
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v17);
LABEL_39:
      *__error() = v5;
      return;
    }

    goto LABEL_24;
  }

  int v8 = *__error();
  uint64_t v9 = (os_log_s *)sub_10002EFA0();
  if (os_log_type_enabled(v9, OS_LOG_TYPE_FAULT)) {
    sub_100089D1C();
  }
  *__error() = v8;
  if (byte_1000E7D31) {
    BOOL v10 = dword_1000E74E0 <= 4;
  }
  else {
    BOOL v10 = 0;
  }
  if (v10)
  {
    int v5 = *__error();
    uint64_t v6 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"Failed to register for deferred report generation");
    if (!v6)
    {
      int v16 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v16, OS_LOG_TYPE_FAULT)) {
        sub_100089CEC();
      }
      goto LABEL_35;
    }

void sub_10004D498(id a1, BGNonRepeatingSystemTask *a2)
{
  v16[0] = 0LL;
  v16[1] = v16;
  v16[2] = 0x3020000000LL;
  char v17 = 0;
  v15[0] = _NSConcreteStackBlock;
  v15[1] = 3221225472LL;
  v15[2] = sub_10004EAA4;
  v15[3] = &unk_1000D9470;
  v15[4] = v16;
  -[BGNonRepeatingSystemTask setExpirationHandler:](a2, "setExpirationHandler:", v15);
  v14[0] = _NSConcreteStackBlock;
  v14[1] = 3221225472LL;
  v14[2] = sub_10004EC64;
  v14[3] = &unk_1000D9498;
  void v14[4] = v16;
  if ((sub_10004EC74((uint64_t)v14) & 1) == 0)
  {
    uint64_t v13 = 0LL;
    if ((-[BGNonRepeatingSystemTask setTaskExpiredWithRetryAfter:error:]( a2,  "setTaskExpiredWithRetryAfter:error:",  &v13,  0.0) & 1) != 0) {
      goto LABEL_4;
    }
    int v3 = *__error();
    BOOL v4 = (os_log_s *)sub_10002EFA0();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      sub_100089DAC();
    }
    *__error() = v3;
    if (byte_1000E7D31 && dword_1000E74E0 <= 4)
    {
      int v5 = *__error();
      uint64_t v6 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"Failed to set expiry: %@", v13);
      uint64_t v7 = v6;
      if (v6)
      {
        CStringPtr = (char *)CFStringGetCStringPtr(v6, 0x8000100u);
        if (CStringPtr)
        {
          uint64_t v9 = 0LL;
        }

        else
        {
          CStringPtr = (char *)calloc(0x400uLL, 1uLL);
          CFStringGetCString(v7, CStringPtr, 1024LL, 0x8000100u);
          uint64_t v9 = CStringPtr;
        }

        if (qword_1000E7D38) {
          int v12 = (FILE *)qword_1000E7D38;
        }
        else {
          int v12 = __stderrp;
        }
        fprintf(v12, "%s\n", CStringPtr);
        if (v9) {
          free(v9);
        }
        CFRelease(v7);
      }

      else
      {
        BOOL v10 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v10, OS_LOG_TYPE_FAULT)) {
          sub_100089D4C();
        }
        if (qword_1000E7D38) {
          uint64_t v11 = (FILE *)qword_1000E7D38;
        }
        else {
          uint64_t v11 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v11);
      }

      *__error() = v5;
    }
  }

  -[BGNonRepeatingSystemTask setTaskCompleted](a2, "setTaskCompleted");
LABEL_4:
  _Block_object_dispose(v16, 8);
}

void sub_10004D708( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
}

void sub_10004D744( int a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, double a6, double a7, double a8, double a9, double a10)
{
  uint64_t v20 = sub_10002EDE8("create deferred cpu usage report for [%d]", a1);
  if (qword_1000E7C58 != -1) {
    dispatch_once(&qword_1000E7C58, &stru_1000D9448);
  }
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472LL;
  block[2] = sub_10004D848;
  block[3] = &unk_1000D9400;
  int v22 = a1;
  block[7] = a3;
  block[8] = a4;
  block[4] = a2;
  void block[5] = a5;
  *(double *)&block[9] = a6;
  *(double *)&block[10] = a7;
  *(double *)&block[11] = a8;
  *(double *)&block[12] = a9;
  *(double *)&block[13] = a10;
  void block[6] = v20;
  dispatch_async((dispatch_queue_t)qword_1000E7C50, block);
}

void sub_10004D848(uint64_t a1)
{
  int v2 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
  -[NSMutableDictionary setObject:forKeyedSubscript:]( v2,  "setObject:forKeyedSubscript:",  &off_1000E2D98,  @"message");
  -[NSMutableDictionary setObject:forKeyedSubscript:]( v2,  "setObject:forKeyedSubscript:",  +[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", *(unsigned int *)(a1 + 112)),  @"pid");
  -[NSMutableDictionary setObject:forKeyedSubscript:]( v2,  "setObject:forKeyedSubscript:",  *(void *)(a1 + 32),  @"pname");
  if (*(void *)(a1 + 56)) {
    -[NSMutableDictionary setObject:forKeyedSubscript:]( v2,  "setObject:forKeyedSubscript:",  +[NSNumber numberWithUnsignedLongLong:](&OBJC_CLASS___NSNumber, "numberWithUnsignedLongLong:"),  @"tid");
  }
  -[NSMutableDictionary setObject:forKeyedSubscript:]( v2,  "setObject:forKeyedSubscript:",  +[NSNumber numberWithUnsignedLongLong:](&OBJC_CLASS___NSNumber, "numberWithUnsignedLongLong:", *(void *)(a1 + 64)),  @"flags");
  -[NSMutableDictionary setObject:forKeyedSubscript:]( v2,  "setObject:forKeyedSubscript:",  *(void *)(a1 + 40),  @"action");
  -[NSMutableDictionary setObject:forKeyedSubscript:]( v2,  "setObject:forKeyedSubscript:",  +[NSNumber numberWithDouble:](&OBJC_CLASS___NSNumber, "numberWithDouble:", *(double *)(a1 + 72)),  @"cpu");
  -[NSMutableDictionary setObject:forKeyedSubscript:]( v2,  "setObject:forKeyedSubscript:",  +[NSNumber numberWithDouble:](&OBJC_CLASS___NSNumber, "numberWithDouble:", *(double *)(a1 + 80)),  @"duration");
  -[NSMutableDictionary setObject:forKeyedSubscript:]( v2,  "setObject:forKeyedSubscript:",  +[NSNumber numberWithDouble:](&OBJC_CLASS___NSNumber, "numberWithDouble:", *(double *)(a1 + 88)),  @"endtime");
  if (*(double *)(a1 + 96) > 0.0 && *(double *)(a1 + 104) > 0.0)
  {
    -[NSMutableDictionary setObject:forKeyedSubscript:]( v2,  "setObject:forKeyedSubscript:",  +[NSNumber numberWithDouble:](&OBJC_CLASS___NSNumber, "numberWithDouble:"),  @"cpu_limit");
    -[NSMutableDictionary setObject:forKeyedSubscript:]( v2,  "setObject:forKeyedSubscript:",  +[NSNumber numberWithDouble:](&OBJC_CLASS___NSNumber, "numberWithDouble:", *(double *)(a1 + 104)),  @"duration_limit");
  }

  sub_10004D9E8((uint64_t)v2);
}

void sub_10004D9E8(uint64_t a1)
{
  int v2 = +[NSURL fileURLWithPath:isDirectory:]( &OBJC_CLASS___NSURL,  "fileURLWithPath:isDirectory:",  @"/private/var/db/spindump/DeferredReports.plist",  0LL);
  int v3 = &AnalyticsIsEventUsed_ptr;
  if (-[NSFileManager fileExistsAtPath:]( +[NSFileManager defaultManager](&OBJC_CLASS___NSFileManager, "defaultManager"),  "fileExistsAtPath:",  @"/private/var/db/spindump/DeferredReports.plist"))
  {
    *(void *)buf = 0LL;
    BOOL v4 = (NSMutableArray *)-[NSArray mutableCopy]( +[NSArray arrayWithContentsOfURL:error:]( &OBJC_CLASS___NSArray,  "arrayWithContentsOfURL:error:",  v2,  buf),  "mutableCopy");
    if (v4) {
      goto LABEL_52;
    }
    int v5 = *__error();
    uint64_t v6 = (os_log_s *)sub_10002EFA0();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)) {
      sub_10008A250();
    }
    *__error() = v5;
    if (byte_1000E7D31 && dword_1000E74E0 <= 4)
    {
      int v7 = *__error();
      int v8 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"Unable to read deferred reports plist, overwriting it: %@",  *(void *)buf);
      if (v8)
      {
        uint64_t v9 = v8;
        CStringPtr = CFStringGetCStringPtr(v8, 0x8000100u);
        if (CStringPtr)
        {
          uint64_t v11 = (char *)CStringPtr;
          int v12 = 0LL;
        }

        else
        {
          uint64_t v11 = (char *)calloc(0x400uLL, 1uLL);
          CFStringGetCString(v9, v11, 1024LL, 0x8000100u);
          int v12 = v11;
        }

        if (qword_1000E7D38) {
          uint64_t v27 = (FILE *)qword_1000E7D38;
        }
        else {
          uint64_t v27 = __stderrp;
        }
        fprintf(v27, "%s\n", v11);
        if (v12) {
          free(v12);
        }
        CFRelease(v9);
      }

      else
      {
        stat v25 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v25, OS_LOG_TYPE_FAULT)) {
          sub_10008A1F0();
        }
        if (qword_1000E7D38) {
          uint64_t v26 = (FILE *)qword_1000E7D38;
        }
        else {
          uint64_t v26 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v26);
      }

      *__error() = v7;
    }

    uint64_t v95 = 0LL;
    if (!-[NSFileManager removeItemAtURL:error:]( +[NSFileManager defaultManager](&OBJC_CLASS___NSFileManager, "defaultManager"),  "removeItemAtURL:error:",  v2,  &v95))
    {
      int v84 = *__error();
      BOOL v85 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v85, OS_LOG_TYPE_FAULT)) {
        sub_10008A0B8();
      }
      *__error() = v84;
      if (byte_1000E7D31 && dword_1000E74E0 <= 4)
      {
        int v86 = *__error();
        uint64_t v87 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"Unable to remove deferred reports plist: %@",  v95);
        if (v87)
        {
          uint64_t v88 = v87;
          uint64_t v89 = CFStringGetCStringPtr(v87, 0x8000100u);
          if (v89)
          {
            __int16 v90 = (char *)v89;
            int v91 = 0LL;
          }

          else
          {
            __int16 v90 = (char *)calloc(0x400uLL, 1uLL);
            CFStringGetCString(v88, v90, 1024LL, 0x8000100u);
            int v91 = v90;
          }

          if (qword_1000E7D38) {
            int v94 = (FILE *)qword_1000E7D38;
          }
          else {
            int v94 = __stderrp;
          }
          fprintf(v94, "%s\n", v90);
          if (v91) {
            free(v91);
          }
          CFRelease(v88);
        }

        else
        {
          int v92 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v92, OS_LOG_TYPE_FAULT)) {
            sub_10008A058();
          }
          if (qword_1000E7D38) {
            BOOL v93 = (FILE *)qword_1000E7D38;
          }
          else {
            BOOL v93 = __stderrp;
          }
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v93);
        }

        *__error() = v86;
      }
    }
  }

  else
  {
    if (byte_1000E7D30)
    {
      int v13 = *__error();
      uint64_t v14 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG)) {
        sub_10008A2E0();
      }
      *__error() = v13;
    }

    if (byte_1000E7D31) {
      BOOL v15 = dword_1000E74E0 <= 0;
    }
    else {
      BOOL v15 = 0;
    }
    if (v15)
    {
      int v16 = *__error();
      char v17 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"No existing deferred reports, creating new plist");
      if (v17)
      {
        int v18 = v17;
        uint64_t v19 = CFStringGetCStringPtr(v17, 0x8000100u);
        if (v19)
        {
          uint64_t v20 = (char *)v19;
          int v21 = 0LL;
        }

        else
        {
          uint64_t v20 = (char *)calloc(0x400uLL, 1uLL);
          CFStringGetCString(v18, v20, 1024LL, 0x8000100u);
          int v21 = v20;
        }

        if (qword_1000E7D38) {
          stat v24 = (FILE *)qword_1000E7D38;
        }
        else {
          stat v24 = __stderrp;
        }
        fprintf(v24, "%s\n", v20);
        if (v21) {
          free(v21);
        }
        CFRelease(v18);
      }

      else
      {
        int v22 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v22, OS_LOG_TYPE_FAULT)) {
          sub_10008A2B0();
        }
        if (qword_1000E7D38) {
          int v23 = (FILE *)qword_1000E7D38;
        }
        else {
          int v23 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v23);
      }

      *__error() = v16;
      int v3 = &AnalyticsIsEventUsed_ptr;
    }
  }

  BOOL v4 = -[NSMutableArray initWithCapacity:](objc_alloc(&OBJC_CLASS___NSMutableArray), "initWithCapacity:", 1LL);
LABEL_52:
  -[NSMutableArray addObject:](v4, "addObject:", a1);
  uint64_t v95 = 0LL;
  if ((-[NSMutableArray writeToURL:error:](v4, "writeToURL:error:", v2, &v95) & 1) == 0)
  {
    int v37 = *__error();
    int v38 = (os_log_s *)sub_10002EFA0();
    if (os_log_type_enabled(v38, OS_LOG_TYPE_FAULT)) {
      sub_10008A184();
    }
    *__error() = v37;
    if (byte_1000E7D31 && dword_1000E74E0 <= 4)
    {
      int v39 = *__error();
      id v40 = -[NSMutableArray count](v4, "count");
      uint64_t v41 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"Unable to write %lu deferred reports to plist: %@",  v40,  v95);
      if (v41)
      {
        uint64_t v42 = v41;
        uint64_t v43 = CFStringGetCStringPtr(v41, 0x8000100u);
        if (v43)
        {
          int v44 = (char *)v43;
          int v45 = 0LL;
        }

        else
        {
          int v44 = (char *)calloc(0x400uLL, 1uLL);
          CFStringGetCString(v42, v44, 1024LL, 0x8000100u);
          int v45 = v44;
        }

        if (qword_1000E7D38) {
          int v74 = (FILE *)qword_1000E7D38;
        }
        else {
          int v74 = __stderrp;
        }
        fprintf(v74, "%s\n", v44);
        if (v45) {
          free(v45);
        }
        CFRelease(v42);
      }

      else
      {
        int64_t v48 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v48, OS_LOG_TYPE_FAULT)) {
          sub_10008A118();
        }
        if (qword_1000E7D38) {
          int v49 = (FILE *)qword_1000E7D38;
        }
        else {
          int v49 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v49);
      }

      *__error() = v39;
    }

    *(void *)buf = 0LL;
    if ((objc_msgSend(objc_msgSend(v3[27], "defaultManager"), "removeItemAtURL:error:", v2, buf) & 1) == 0)
    {
      int v75 = *__error();
      id v76 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v76, OS_LOG_TYPE_FAULT)) {
        sub_10008A0B8();
      }
      *__error() = v75;
      if (byte_1000E7D31)
      {
        if (dword_1000E74E0 <= 4)
        {
          int v53 = *__error();
          id v54 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"Unable to remove deferred reports plist: %@",  *(void *)buf);
          if (!v54)
          {
            int v77 = (os_log_s *)sub_10002EFA0();
            if (os_log_type_enabled(v77, OS_LOG_TYPE_FAULT)) {
              sub_10008A058();
            }
            goto LABEL_149;
          }

          goto LABEL_105;
        }
      }
    }

    return;
  }

  if (byte_1000E7D30)
  {
    int v28 = *__error();
    uint64_t v29 = (os_log_s *)sub_10002EFA0();
    if (os_log_type_enabled(v29, OS_LOG_TYPE_INFO))
    {
      id v30 = -[NSMutableArray count](v4, "count");
      *(_DWORD *)buf = 134217984;
      *(void *)&uint8_t buf[4] = v30;
      _os_log_impl( (void *)&_mh_execute_header,  v29,  OS_LOG_TYPE_INFO,  "Added report to pending deferred reports (have %lu)",  buf,  0xCu);
    }

    *__error() = v28;
  }

  if (byte_1000E7D31 && dword_1000E74E0 <= 1)
  {
    int v31 = *__error();
    int v32 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"Added report to pending deferred reports (have %lu)",  -[NSMutableArray count](v4, "count"));
    if (v32)
    {
      BOOL v33 = v32;
      unsigned int v34 = CFStringGetCStringPtr(v32, 0x8000100u);
      if (v34)
      {
        int v35 = (char *)v34;
        uint64_t v36 = 0LL;
      }

      else
      {
        int v35 = (char *)calloc(0x400uLL, 1uLL);
        CFStringGetCString(v33, v35, 1024LL, 0x8000100u);
        uint64_t v36 = v35;
      }

      if (qword_1000E7D38) {
        uint64_t v50 = (FILE *)qword_1000E7D38;
      }
      else {
        uint64_t v50 = __stderrp;
      }
      fprintf(v50, "%s\n", v35);
      if (v36) {
        free(v36);
      }
      CFRelease(v33);
    }

    else
    {
      int v46 = (char *)sub_10002EFA0();
      if (os_log_type_enabled((os_log_t)v46, OS_LOG_TYPE_FAULT)) {
        sub_100089FE4(v4, v46);
      }
      if (qword_1000E7D38) {
        int64_t v47 = (FILE *)qword_1000E7D38;
      }
      else {
        int64_t v47 = __stderrp;
      }
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v47);
    }

    *__error() = v31;
  }

  if (objc_opt_class(&OBJC_CLASS___BGSystemTaskScheduler))
  {
    if (objc_msgSend( +[BGSystemTaskScheduler sharedScheduler](BGSystemTaskScheduler, "sharedScheduler"),  "taskRequestForIdentifier:",  @"com.apple.spindump.deferred_report_generation"))
    {
      if (byte_1000E7D30)
      {
        int v51 = *__error();
        id v52 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v52, OS_LOG_TYPE_DEBUG)) {
          sub_100089FB8();
        }
        *__error() = v51;
      }

      if (byte_1000E7D31 && dword_1000E74E0 <= 0)
      {
        int v53 = *__error();
        id v54 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"Deferred report task already exists");
        if (!v54)
        {
          int v55 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v55, OS_LOG_TYPE_FAULT)) {
            sub_100089F88();
          }
LABEL_149:
          if (qword_1000E7D38) {
            uint64_t v80 = (FILE *)qword_1000E7D38;
          }
          else {
            uint64_t v80 = __stderrp;
          }
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v80);
LABEL_153:
          *__error() = v53;
          return;
        }

        goto LABEL_105;
      }

      return;
    }

    id v62 = [[BGNonRepeatingSystemTaskRequest alloc] initWithIdentifier:@"com.apple.spindump.deferred_report_generation"];
    [v62 setPriority:1];
    [v62 setScheduleAfter:1.0];
    [v62 setRequiresNetworkConnectivity:0];
    [v62 setRequiresExternalPower:0];
    if (objc_msgSend( +[BGSystemTaskScheduler sharedScheduler]( BGSystemTaskScheduler,  "sharedScheduler"),  "submitTaskRequest:error:",  v62,  buf))
    {
      if (byte_1000E7D30)
      {
        int v63 = *__error();
        uint64_t v64 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v64, OS_LOG_TYPE_DEBUG)) {
          sub_100089E9C();
        }
        *__error() = v63;
      }

      if (!byte_1000E7D31 || dword_1000E74E0 > 0) {
        goto LABEL_168;
      }
      int v65 = *__error();
      uint64_t v66 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"Submitted deferred report task successfully");
      if (!v66)
      {
        int64_t v67 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v67, OS_LOG_TYPE_FAULT)) {
          sub_100089E6C();
        }
LABEL_163:
        if (qword_1000E7D38) {
          uint64_t v83 = (FILE *)qword_1000E7D38;
        }
        else {
          uint64_t v83 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v83);
LABEL_167:
        *__error() = v65;
LABEL_168:

        return;
      }
    }

    else
    {
      int v68 = *__error();
      uint64_t v69 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v69, OS_LOG_TYPE_FAULT)) {
        sub_100089F28();
      }
      *__error() = v68;
      if (!byte_1000E7D31 || dword_1000E74E0 > 4) {
        goto LABEL_168;
      }
      int v65 = *__error();
      uint64_t v66 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"Failed to submit task with error: %@",  *(void *)buf);
      if (!v66)
      {
        int v82 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v82, OS_LOG_TYPE_FAULT)) {
          sub_100089EC8();
        }
        goto LABEL_163;
      }
    }

    int v70 = v66;
    id v71 = CFStringGetCStringPtr(v66, 0x8000100u);
    if (v71)
    {
      id v72 = (char *)v71;
      int v73 = 0LL;
    }

    else
    {
      id v72 = (char *)calloc(0x400uLL, 1uLL);
      CFStringGetCString(v70, v72, 1024LL, 0x8000100u);
      int v73 = v72;
    }

    if (qword_1000E7D38) {
      BOOL v81 = (FILE *)qword_1000E7D38;
    }
    else {
      BOOL v81 = __stderrp;
    }
    fprintf(v81, "%s\n", v72);
    if (v73) {
      free(v73);
    }
    CFRelease(v70);
    goto LABEL_167;
  }

  int v56 = *__error();
  uint64_t v57 = (os_log_s *)sub_10002EFA0();
  if (os_log_type_enabled(v57, OS_LOG_TYPE_FAULT)) {
    sub_100089E3C();
  }
  *__error() = v56;
  if (byte_1000E7D31 && dword_1000E74E0 <= 4)
  {
    int v53 = *__error();
    id v54 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"Attempting to defer reports when not supported. Caller should check before calling");
    if (!v54)
    {
      BOOL v79 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v79, OS_LOG_TYPE_FAULT)) {
        sub_100089E0C();
      }
      goto LABEL_149;
    }

void sub_10004E7DC( int a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, double a7, double a8, double a9)
{
  uint64_t v18 = sub_10002EDE8("create deferred disk writes report for [%d]", a1);
  if (qword_1000E7C58 != -1) {
    dispatch_once(&qword_1000E7C58, &stru_1000D9448);
  }
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472LL;
  block[2] = sub_10004E8DC;
  block[3] = &unk_1000D9428;
  int v20 = a1;
  block[4] = a2;
  void block[5] = a4;
  block[7] = a3;
  block[8] = a5;
  *(double *)&block[9] = a7;
  *(double *)&block[10] = a8;
  block[11] = a6;
  *(double *)&block[12] = a9;
  void block[6] = v18;
  dispatch_async((dispatch_queue_t)qword_1000E7C50, block);
}

void sub_10004E8DC(uint64_t a1)
{
  int v2 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
  -[NSMutableDictionary setObject:forKeyedSubscript:]( v2,  "setObject:forKeyedSubscript:",  &off_1000E2DB0,  @"message");
  -[NSMutableDictionary setObject:forKeyedSubscript:]( v2,  "setObject:forKeyedSubscript:",  +[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", *(unsigned int *)(a1 + 104)),  @"pid");
  -[NSMutableDictionary setObject:forKeyedSubscript:]( v2,  "setObject:forKeyedSubscript:",  *(void *)(a1 + 32),  @"pname");
  -[NSMutableDictionary setObject:forKeyedSubscript:]( v2,  "setObject:forKeyedSubscript:",  +[NSNumber numberWithUnsignedLongLong:](&OBJC_CLASS___NSNumber, "numberWithUnsignedLongLong:", *(void *)(a1 + 56)),  @"flags");
  -[NSMutableDictionary setObject:forKeyedSubscript:]( v2,  "setObject:forKeyedSubscript:",  *(void *)(a1 + 40),  @"action");
  -[NSMutableDictionary setObject:forKeyedSubscript:]( v2,  "setObject:forKeyedSubscript:",  +[NSNumber numberWithUnsignedLongLong:](&OBJC_CLASS___NSNumber, "numberWithUnsignedLongLong:", *(void *)(a1 + 64)),  @"io");
  -[NSMutableDictionary setObject:forKeyedSubscript:]( v2,  "setObject:forKeyedSubscript:",  +[NSNumber numberWithDouble:](&OBJC_CLASS___NSNumber, "numberWithDouble:", *(double *)(a1 + 72)),  @"duration");
  -[NSMutableDictionary setObject:forKeyedSubscript:]( v2,  "setObject:forKeyedSubscript:",  +[NSNumber numberWithDouble:](&OBJC_CLASS___NSNumber, "numberWithDouble:", *(double *)(a1 + 80)),  @"endtime");
  if (*(void *)(a1 + 88) && *(double *)(a1 + 96) > 0.0)
  {
    -[NSMutableDictionary setObject:forKeyedSubscript:]( v2,  "setObject:forKeyedSubscript:",  +[NSNumber numberWithUnsignedLongLong:](&OBJC_CLASS___NSNumber, "numberWithUnsignedLongLong:"),  @"io_limit");
    -[NSMutableDictionary setObject:forKeyedSubscript:]( v2,  "setObject:forKeyedSubscript:",  +[NSNumber numberWithDouble:](&OBJC_CLASS___NSNumber, "numberWithDouble:", *(double *)(a1 + 96)),  @"duration_limit");
  }

  sub_10004D9E8((uint64_t)v2);
}

void sub_10004EA54(id a1)
{
  id v1 = dispatch_queue_attr_make_with_autorelease_frequency(0LL, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
  int v2 = dispatch_queue_attr_make_with_qos_class(v1, QOS_CLASS_BACKGROUND, 0);
  qword_1000E7C50 = (uint64_t)dispatch_queue_create("com.apple.spindump.deferred_report_generation", v2);
  dispatch_release(v2);
}

int *sub_10004EAA4(int *result)
{
  id v1 = result;
  if (byte_1000E7D30)
  {
    int v2 = *__error();
    int v3 = (os_log_s *)sub_10002EFA0();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG)) {
      sub_10008A33C();
    }
    id result = __error();
    *id result = v2;
  }

  if (byte_1000E7D31) {
    BOOL v4 = dword_1000E74E0 <= 0;
  }
  else {
    BOOL v4 = 0;
  }
  if (v4)
  {
    int v5 = *__error();
    uint64_t v6 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"Deferred tasks expired");
    if (v6)
    {
      int v7 = v6;
      CStringPtr = CFStringGetCStringPtr(v6, 0x8000100u);
      if (CStringPtr)
      {
        uint64_t v9 = (char *)CStringPtr;
        BOOL v10 = 0LL;
      }

      else
      {
        uint64_t v9 = (char *)calloc(0x400uLL, 1uLL);
        CFStringGetCString(v7, v9, 1024LL, 0x8000100u);
        BOOL v10 = v9;
      }

      if (qword_1000E7D38) {
        int v13 = (FILE *)qword_1000E7D38;
      }
      else {
        int v13 = __stderrp;
      }
      fprintf(v13, "%s\n", v9);
      if (v10) {
        free(v10);
      }
      CFRelease(v7);
    }

    else
    {
      uint64_t v11 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v11, OS_LOG_TYPE_FAULT)) {
        sub_10008A30C();
      }
      if (qword_1000E7D38) {
        int v12 = (FILE *)qword_1000E7D38;
      }
      else {
        int v12 = __stderrp;
      }
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v12);
    }

    id result = __error();
    *id result = v5;
  }

  *(_BYTE *)(*(void *)(*((void *)v1 + 4) + 8LL) + 40LL) = 1;
  return result;
}

uint64_t sub_10004EC64(uint64_t a1)
{
  return *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 40LL);
}

uint64_t sub_10004EC74(uint64_t a1)
{
  if (byte_1000E7D30)
  {
    int v2 = *__error();
    int v3 = (os_log_s *)sub_10002EFA0();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Generating deferred reports", buf, 2u);
    }

    *__error() = v2;
  }

  if (byte_1000E7D31) {
    BOOL v4 = dword_1000E74E0 <= 2;
  }
  else {
    BOOL v4 = 0;
  }
  if (v4)
  {
    int v5 = *__error();
    uint64_t v6 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"Generating deferred reports");
    if (v6)
    {
      int v7 = v6;
      CStringPtr = CFStringGetCStringPtr(v6, 0x8000100u);
      if (CStringPtr)
      {
        uint64_t v9 = (char *)CStringPtr;
        BOOL v10 = 0LL;
      }

      else
      {
        uint64_t v9 = (char *)calloc(0x400uLL, 1uLL);
        CFStringGetCString(v7, v9, 1024LL, 0x8000100u);
        BOOL v10 = v9;
      }

      if (qword_1000E7D38) {
        int v13 = (FILE *)qword_1000E7D38;
      }
      else {
        int v13 = __stderrp;
      }
      fprintf(v13, "%s\n", v9);
      if (v10) {
        free(v10);
      }
      CFRelease(v7);
    }

    else
    {
      uint64_t v11 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v11, OS_LOG_TYPE_FAULT)) {
        sub_10008A92C();
      }
      if (qword_1000E7D38) {
        int v12 = (FILE *)qword_1000E7D38;
      }
      else {
        int v12 = __stderrp;
      }
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v12);
    }

    *__error() = v5;
  }

  if (!-[NSFileManager fileExistsAtPath:]( +[NSFileManager defaultManager](&OBJC_CLASS___NSFileManager, "defaultManager"),  "fileExistsAtPath:",  @"/private/var/db/spindump/DeferredReports.plist"))
  {
    if (byte_1000E7D30)
    {
      int v150 = *__error();
      __int16 v151 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v151, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v151, OS_LOG_TYPE_DEFAULT, "No deferred reports", buf, 2u);
      }

      *__error() = v150;
    }

    if (byte_1000E7D31) {
      BOOL v152 = dword_1000E74E0 <= 2;
    }
    else {
      BOOL v152 = 0;
    }
    if (v152)
    {
      int v153 = *__error();
      mach_port_name_t v154 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"No deferred reports");
      if (!v154)
      {
        int v177 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v177, OS_LOG_TYPE_FAULT)) {
          sub_10008A8FC();
        }
        goto LABEL_333;
      }

      goto LABEL_305;
    }

    return 1LL;
  }

  uint64_t v14 = +[NSURL fileURLWithPath:isDirectory:]( &OBJC_CLASS___NSURL,  "fileURLWithPath:isDirectory:",  @"/private/var/db/spindump/DeferredReports.plist",  0LL);
  uint64_t v256 = 0LL;
  BOOL v15 = +[NSArray arrayWithContentsOfURL:error:](&OBJC_CLASS___NSArray, "arrayWithContentsOfURL:error:", v14, &v256);
  if (v15)
  {
    int v16 = v15;
    uint64_t v17 = objc_opt_class(&OBJC_CLASS___NSDictionary);
    __int128 v281 = 0u;
    __int128 v282 = 0u;
    __int128 v283 = 0u;
    __int128 v284 = 0u;
    id v18 = -[NSArray countByEnumeratingWithState:objects:count:]( v16,  "countByEnumeratingWithState:objects:count:",  &v281,  buf,  16LL);
    if (!v18) {
      goto LABEL_37;
    }
    id v19 = v18;
    uint64_t v20 = *(void *)v282;
    do
    {
      for (uint64_t i = 0LL; i != v19; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v282 != v20) {
          objc_enumerationMutation(v16);
        }
        if ((objc_opt_isKindOfClass(*(void *)(*((void *)&v281 + 1) + 8LL * (void)i), v17) & 1) == 0)
        {
          if (byte_1000E7D30)
          {
            int v159 = *__error();
            id v160 = (os_log_s *)sub_10002EFA0();
            if (os_log_type_enabled(v160, OS_LOG_TYPE_ERROR)) {
              sub_10008A8C4();
            }
            *__error() = v159;
          }

          if (byte_1000E7D31) {
            BOOL v161 = dword_1000E74E0 <= 3;
          }
          else {
            BOOL v161 = 0;
          }
          if (v161)
          {
            int v162 = *__error();
            int v163 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"Invalid deferred reports plist");
            if (v163)
            {
              int v164 = v163;
              int v165 = CFStringGetCStringPtr(v163, 0x8000100u);
              if (v165)
              {
                int v166 = (char *)v165;
                BOOL v167 = 0LL;
              }

              else
              {
                int v166 = (char *)calloc(0x400uLL, 1uLL);
                CFStringGetCString(v164, v166, 1024LL, 0x8000100u);
                BOOL v167 = v166;
              }

              if (qword_1000E7D38) {
                uint64_t v204 = (FILE *)qword_1000E7D38;
              }
              else {
                uint64_t v204 = __stderrp;
              }
              fprintf(v204, "%s\n", v166);
              if (v167) {
                free(v167);
              }
              CFRelease(v164);
            }

            else
            {
              int v200 = (os_log_s *)sub_10002EFA0();
              if (os_log_type_enabled(v200, OS_LOG_TYPE_FAULT)) {
                sub_10008A894();
              }
              if (qword_1000E7D38) {
                uint64_t v201 = (FILE *)qword_1000E7D38;
              }
              else {
                uint64_t v201 = __stderrp;
              }
              fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v201);
            }

            *__error() = v162;
          }

          *(void *)buf = 0LL;
          if (!-[NSFileManager removeItemAtURL:error:]( +[NSFileManager defaultManager](&OBJC_CLASS___NSFileManager, "defaultManager"),  "removeItemAtURL:error:",  v14,  buf))
          {
            int v205 = *__error();
            int v206 = (os_log_s *)sub_10002EFA0();
            if (os_log_type_enabled(v206, OS_LOG_TYPE_FAULT)) {
              sub_10008A0B8();
            }
            *__error() = v205;
            if (byte_1000E7D31)
            {
              if (dword_1000E74E0 <= 4)
              {
                int v153 = *__error();
                mach_port_name_t v154 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"Unable to remove deferred reports plist: %@",  *(void *)buf);
                if (!v154)
                {
                  uint64_t v207 = (os_log_s *)sub_10002EFA0();
                  if (os_log_type_enabled(v207, OS_LOG_TYPE_FAULT)) {
                    goto LABEL_397;
                  }
                  goto LABEL_333;
                }

LABEL_305:
                mach_port_name_t v155 = v154;
                double v156 = CFStringGetCStringPtr(v154, 0x8000100u);
                if (v156)
                {
                  xpc_object_t v157 = (char *)v156;
                  double v158 = 0LL;
                }

                else
                {
                  xpc_object_t v157 = (char *)calloc(0x400uLL, 1uLL);
                  CFStringGetCString(v155, v157, 1024LL, 0x8000100u);
                  double v158 = v157;
                }

                if (qword_1000E7D38) {
                  id v179 = (FILE *)qword_1000E7D38;
                }
                else {
                  id v179 = __stderrp;
                }
                fprintf(v179, "%s\n", v157);
                if (v158) {
                  free(v158);
                }
                CFRelease(v155);
LABEL_344:
                *__error() = v153;
              }
            }
          }

          return 1LL;
        }
      }

      id v19 = -[NSArray countByEnumeratingWithState:objects:count:]( v16,  "countByEnumeratingWithState:objects:count:",  &v281,  buf,  16LL);
    }

    while (v19);
LABEL_37:
    unint64_t v22 = 0LL;
    if (-[NSArray count](v16, "count"))
    {
      while (1)
      {
        id v23 = -[NSArray objectAtIndexedSubscript:](v16, "objectAtIndexedSubscript:", v22);
        id v24 = sub_100051348(v23, (uint64_t)@"message");
        if (!v24) {
          break;
        }
        stat v25 = v24;
        id v26 = [v24 longLongValue];
        if (v26 == (id)5)
        {
          id v53 = objc_msgSend(sub_100051348(v23, (uint64_t)@"pid"), "intValue");
          if ((_DWORD)v53)
          {
            uint64_t v54 = (uint64_t)v53;
            id v55 = objc_msgSend(sub_100051348(v23, (uint64_t)@"flags"), "unsignedLongLongValue");
            id v56 = objc_msgSend(sub_100051348(v23, (uint64_t)@"io"), "longLongValue");
            if ((uint64_t)v56 <= 0)
            {
              if (byte_1000E7D30)
              {
                int v87 = *__error();
                uint64_t v88 = (os_log_s *)sub_10002EFA0();
                if (os_log_type_enabled(v88, OS_LOG_TYPE_ERROR))
                {
                  *(_DWORD *)buf = 134217984;
                  *(void *)&uint8_t buf[4] = v56;
                  _os_log_error_impl( (void *)&_mh_execute_header,  v88,  OS_LOG_TYPE_ERROR,  "deferred disk writes resource: bad bytes (%lld)",  buf,  0xCu);
                }

                *__error() = v87;
              }

              if (!byte_1000E7D31 || dword_1000E74E0 > 3) {
                goto LABEL_174;
              }
              int v41 = *__error();
              uint64_t v42 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"deferred disk writes resource: bad bytes (%lld)",  v56);
              if (!v42)
              {
                uint64_t v89 = (os_log_s *)sub_10002EFA0();
                if (!os_log_type_enabled(v89, OS_LOG_TYPE_FAULT)) {
                  goto LABEL_151;
                }
                *(_DWORD *)buf = 134217984;
                *(void *)&uint8_t buf[4] = v56;
                int v44 = v89;
                int v45 = "Unable to format: deferred disk writes resource: bad bytes (%lld)";
                goto LABEL_164;
              }
            }

            else
            {
              objc_msgSend(sub_100051348(v23, (uint64_t)@"duration"), "doubleValue");
              double v58 = v57;
              if (v57 <= 0.0)
              {
                if (byte_1000E7D30)
                {
                  int v90 = *__error();
                  int v91 = (os_log_s *)sub_10002EFA0();
                  if (os_log_type_enabled(v91, OS_LOG_TYPE_ERROR))
                  {
                    *(_DWORD *)buf = 134217984;
                    *(double *)&uint8_t buf[4] = v58;
                    _os_log_error_impl( (void *)&_mh_execute_header,  v91,  OS_LOG_TYPE_ERROR,  "deferred disk writes resource: bad duration (%f)",  buf,  0xCu);
                  }

                  *__error() = v90;
                }

                if (!byte_1000E7D31 || dword_1000E74E0 > 3) {
                  goto LABEL_174;
                }
                int v41 = *__error();
                uint64_t v42 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"deferred disk writes resource: bad duration (%f)",  *(void *)&v58);
                if (!v42)
                {
                  int v92 = (os_log_s *)sub_10002EFA0();
                  if (!os_log_type_enabled(v92, OS_LOG_TYPE_FAULT)) {
                    goto LABEL_151;
                  }
                  *(_DWORD *)buf = 134217984;
                  *(double *)&uint8_t buf[4] = v58;
                  int v44 = v92;
                  int v45 = "Unable to format: deferred disk writes resource: bad duration (%f)";
                  goto LABEL_164;
                }
              }

              else
              {
                objc_msgSend(sub_100051348(v23, (uint64_t)@"endtime"), "doubleValue");
                if (v59 <= 0.0)
                {
                  if (byte_1000E7D30)
                  {
                    int v99 = *__error();
                    int v100 = (os_log_s *)sub_10002EFA0();
                    if (os_log_type_enabled(v100, OS_LOG_TYPE_ERROR)) {
                      sub_10008A86C(&v271, v272);
                    }
                    *__error() = v99;
                  }

                  if (!byte_1000E7D31 || dword_1000E74E0 > 3) {
                    goto LABEL_174;
                  }
                  int v41 = *__error();
                  uint64_t v42 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"deferred disk writes resource: no endtime provided");
                  if (!v42)
                  {
                    BOOL v101 = (os_log_s *)sub_10002EFA0();
                    if (os_log_type_enabled(v101, OS_LOG_TYPE_FAULT)) {
                      sub_10008A840(&v269, v270);
                    }
                    goto LABEL_151;
                  }
                }

                else
                {
                  double v60 = v59;
                  uint64_t v61 = (uint64_t)objc_msgSend(sub_100051348(v23, (uint64_t)@"io_limit"), "longLongValue");
                  if (v61 < 0)
                  {
                    if (byte_1000E7D30)
                    {
                      int v110 = *__error();
                      int v111 = (os_log_s *)sub_10002EFA0();
                      if (os_log_type_enabled(v111, OS_LOG_TYPE_ERROR))
                      {
                        *(_DWORD *)buf = 134217984;
                        *(void *)&uint8_t buf[4] = v61;
                        _os_log_error_impl( (void *)&_mh_execute_header,  v111,  OS_LOG_TYPE_ERROR,  "deferred disk writes resource: bad io_limit_bytes (%lld)",  buf,  0xCu);
                      }

                      *__error() = v110;
                    }

                    if (!byte_1000E7D31 || dword_1000E74E0 > 3) {
                      goto LABEL_174;
                    }
                    int v41 = *__error();
                    uint64_t v42 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"deferred disk writes resource: bad io_limit_bytes (%lld)",  v61);
                    if (!v42)
                    {
                      double v112 = (os_log_s *)sub_10002EFA0();
                      if (!os_log_type_enabled(v112, OS_LOG_TYPE_FAULT)) {
                        goto LABEL_151;
                      }
                      *(_DWORD *)buf = 134217984;
                      *(void *)&uint8_t buf[4] = v61;
                      int v44 = v112;
                      int v45 = "Unable to format: deferred disk writes resource: bad io_limit_bytes (%lld)";
                      goto LABEL_164;
                    }
                  }

                  else
                  {
                    objc_msgSend(sub_100051348(v23, (uint64_t)@"duration_limit"), "doubleValue");
                    double v63 = v62;
                    if (v62 >= 0.0)
                    {
                      id v247 = sub_1000513A8(v23, (uint64_t)@"pname");
                      id v113 = sub_1000513A8(v23, (uint64_t)@"action");
                      if (v113)
                      {
                        id v114 = sub_100055AE4((const char *)[v113 UTF8String]);
                        int v249 = +[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v114);
                        free(v114);
                      }

                      else
                      {
                        int v249 = 0LL;
                      }

                      if ((v54 & 0x80000000) != 0)
                      {
                        if (byte_1000E7D30)
                        {
                          int v245 = *__error();
                          BOOL v124 = (os_log_s *)sub_10002EFA0();
                          if (os_log_type_enabled(v124, OS_LOG_TYPE_INFO))
                          {
                            *(_WORD *)buf = 0;
                            _os_log_impl( (void *)&_mh_execute_header,  v124,  OS_LOG_TYPE_INFO,  "deferred disk writes resource: generating deferred report",  buf,  2u);
                          }

                          *__error() = v245;
                        }

                        if (byte_1000E7D31 && dword_1000E74E0 <= 1)
                        {
                          int v244 = *__error();
                          int v125 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"deferred disk writes resource: generating deferred report");
                          if (!v125)
                          {
                            uint64_t v145 = (os_log_s *)sub_10002EFA0();
                            if (os_log_type_enabled(v145, OS_LOG_TYPE_FAULT)) {
                              sub_10008A814(&v267, v268);
                            }
                            goto LABEL_275;
                          }

                          cf = v125;
                          uint64_t v126 = CFStringGetCStringPtr(v125, 0x8000100u);
                          if (v126)
                          {
                            int v127 = (char *)v126;
                            uint64_t v240 = 0LL;
                          }

                          else
                          {
                            int v127 = (char *)calloc(0x400uLL, 1uLL);
                            CFStringGetCString(cf, v127, 1024LL, 0x8000100u);
                            uint64_t v240 = v127;
                          }

                          if (qword_1000E7D38) {
                            uint64_t v149 = (FILE *)qword_1000E7D38;
                          }
                          else {
                            uint64_t v149 = __stderrp;
                          }
                          fprintf(v149, "%s\n", v127);
                          uint64_t v144 = v240;
                          if (v240) {
LABEL_271:
                          }
                            free(v144);
LABEL_272:
                          CFRelease(cf);
LABEL_279:
                          *__error() = v244;
                        }
                      }

                      else
                      {
                        if (byte_1000E7D30)
                        {
                          int v243 = *__error();
                          BOOL v117 = (os_log_s *)sub_10002EFA0();
                          if (os_log_type_enabled(v117, OS_LOG_TYPE_INFO))
                          {
                            int v118 = sub_10002EF3C(v54);
                            *(_DWORD *)buf = 136446466;
                            *(void *)&uint8_t buf[4] = v118;
                            __int16 v279 = 1024;
                            LODWORD(v280) = v54;
                            _os_log_impl( (void *)&_mh_execute_header,  v117,  OS_LOG_TYPE_INFO,  "%{public}s [%d]: deferred disk writes resource: generating deferred report",  buf,  0x12u);
                          }

                          *__error() = v243;
                        }

                        if (byte_1000E7D31 && dword_1000E74E0 <= 1)
                        {
                          int v244 = *__error();
                          int64_t v119 = sub_10002EF3C(v54);
                          xpc_object_t v120 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"%s [%d]: deferred disk writes resource: generating deferred report",  v119,  v54);
                          if (v120)
                          {
                            uint64_t v239 = v61;
                            double v121 = v120;
                            int v122 = CFStringGetCStringPtr(v120, 0x8000100u);
                            cf = v121;
                            if (v122)
                            {
                              uint64_t v123 = (char *)v122;
                              int v238 = 0LL;
                            }

                            else
                            {
                              uint64_t v123 = (char *)calloc(0x400uLL, 1uLL);
                              CFStringGetCString(v121, v123, 1024LL, 0x8000100u);
                              int v238 = v123;
                            }

                            if (qword_1000E7D38) {
                              uint64_t v143 = (FILE *)qword_1000E7D38;
                            }
                            else {
                              uint64_t v143 = __stderrp;
                            }
                            fprintf(v143, "%s\n", v123);
                            uint64_t v144 = v238;
                            uint64_t v61 = v239;
                            if (v238) {
                              goto LABEL_271;
                            }
                            goto LABEL_272;
                          }

                          int v140 = (os_log_s *)sub_10002EFA0();
                          if (os_log_type_enabled(v140, OS_LOG_TYPE_FAULT))
                          {
                            int v141 = sub_10002EF3C(v54);
                            *(_DWORD *)buf = 136315394;
                            *(void *)&uint8_t buf[4] = v141;
                            __int16 v279 = 1024;
                            LODWORD(v280) = v54;
                            _os_log_fault_impl( (void *)&_mh_execute_header,  v140,  OS_LOG_TYPE_FAULT,  "Unable to format: %s [%d]: deferred disk writes resource: generating deferred report",  buf,  0x12u);
                          }

LABEL_275:
                          if (qword_1000E7D38) {
                            id v146 = (FILE *)qword_1000E7D38;
                          }
                          else {
                            id v146 = __stderrp;
                          }
                          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v146);
                          goto LABEL_279;
                        }
                      }

                      sub_100041538(v54, v247, (uint64_t)v55, v249, (uint64_t)v56, v61, v58, v60, v63);
                      goto LABEL_174;
                    }

                    if (byte_1000E7D30)
                    {
                      int v64 = *__error();
                      int v65 = (os_log_s *)sub_10002EFA0();
                      if (os_log_type_enabled(v65, OS_LOG_TYPE_ERROR))
                      {
                        *(_DWORD *)buf = 134217984;
                        *(double *)&uint8_t buf[4] = v63;
                        _os_log_error_impl( (void *)&_mh_execute_header,  v65,  OS_LOG_TYPE_ERROR,  "deferred disk writes resource: bad duration_limit (%f)",  buf,  0xCu);
                      }

                      *__error() = v64;
                    }

                    if (!byte_1000E7D31 || dword_1000E74E0 > 3) {
                      goto LABEL_174;
                    }
                    int v41 = *__error();
                    uint64_t v42 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"deferred disk writes resource: bad duration_limit (%f)",  *(void *)&v63);
                    if (!v42)
                    {
                      uint64_t v66 = (os_log_s *)sub_10002EFA0();
                      if (os_log_type_enabled(v66, OS_LOG_TYPE_FAULT))
                      {
                        *(_DWORD *)buf = 134217984;
                        *(double *)&uint8_t buf[4] = v63;
                        int v44 = v66;
                        int v45 = "Unable to format: deferred disk writes resource: bad duration_limit (%f)";
                        goto LABEL_164;
                      }

    int v137 = v70;
    double v138 = CFStringGetCStringPtr(v70, 0x8000100u);
    if (v138)
    {
      xpc_object_t v139 = (char *)v138;
      int v140 = 0LL;
    }

    else
    {
      xpc_object_t v139 = (char *)calloc(0x400uLL, 1uLL);
      CFStringGetCString(v137, v139, 1024LL, 0x8000100u);
      int v140 = v139;
    }

    if (qword_1000E7D38) {
      uint64_t v144 = (FILE *)qword_1000E7D38;
    }
    else {
      uint64_t v144 = __stderrp;
    }
    fprintf(v144, "%s\n", v139);
    if (v140) {
      free(v140);
    }
    uint64_t v143 = v137;
    goto LABEL_311;
  }

  if ((a6 & 0x10) != 0 && ([v24 omitSensitiveStrings] & 1) == 0)
  {
    if ((pid & 0x80000000) != 0)
    {
      if (byte_1000E7D30)
      {
        id v115 = *__error();
        uint64_t v116 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v116, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(buffer) = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v116,  OS_LOG_TYPE_DEFAULT,  "Already sampling with sensitive strings",  (uint8_t *)&buffer,  2u);
        }

        *__error() = v115;
      }

      if (!byte_1000E7D31 || dword_1000E74E0 > 2) {
        goto LABEL_321;
      }
      id v27 = *__error();
      int v70 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"Already sampling with sensitive strings");
      if (!v70)
      {
        BOOL v117 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v117, OS_LOG_TYPE_FAULT)) {
          sub_1000925AC();
        }
        goto LABEL_316;
      }

      goto LABEL_275;
    }

    if (byte_1000E7D30)
    {
      uint64_t v83 = *__error();
      int v84 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v84, OS_LOG_TYPE_DEFAULT))
      {
        BOOL v85 = sub_10002EF3C(pid);
        int buffer = 136446466;
        int v185 = v85;
        id v186 = 1024;
        id v187 = pid;
        _os_log_impl( (void *)&_mh_execute_header,  v84,  OS_LOG_TYPE_DEFAULT,  "%{public}s [%d]: Already sampling with sensitive strings",  (uint8_t *)&buffer,  0x12u);
      }

      *__error() = v83;
    }

    if (!byte_1000E7D31 || dword_1000E74E0 > 2) {
      goto LABEL_321;
    }
    id v27 = *__error();
    int v86 = sub_10002EF3C(pid);
    id v29 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"%s [%d]: Already sampling with sensitive strings",  v86,  pid);
    if (!v29)
    {
      int v87 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v87, OS_LOG_TYPE_FAULT)) {
        sub_100092544();
      }
      goto LABEL_316;
    }

LABEL_151:
                      if (qword_1000E7D38) {
                        int v94 = (FILE *)qword_1000E7D38;
                      }
                      else {
                        int v94 = __stderrp;
                      }
                      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v94);
                      goto LABEL_173;
                    }
                  }
                }
              }
            }
          }

          else
          {
            if (byte_1000E7D30)
            {
              int v80 = *__error();
              BOOL v81 = (os_log_s *)sub_10002EFA0();
              if (os_log_type_enabled(v81, OS_LOG_TYPE_ERROR)) {
                sub_10008A7EC(&v275, v276);
              }
              *__error() = v80;
            }

            if (!byte_1000E7D31 || dword_1000E74E0 > 3) {
              goto LABEL_174;
            }
            int v41 = *__error();
            uint64_t v42 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"deferred disk writes resource: no pid provided");
            if (!v42)
            {
              int v82 = (os_log_s *)sub_10002EFA0();
              if (os_log_type_enabled(v82, OS_LOG_TYPE_FAULT)) {
                sub_10008A7C0(&v273, v274);
              }
              goto LABEL_151;
            }
          }

          goto LABEL_66;
        }

        if (v26 == (id)3)
        {
          id v27 = objc_msgSend(sub_100051348(v23, (uint64_t)@"pid"), "intValue");
          if ((_DWORD)v27)
          {
            uint64_t v28 = (uint64_t)v27;
            id v29 = objc_msgSend(sub_100051348(v23, (uint64_t)@"tid"), "unsignedLongLongValue");
            id v30 = objc_msgSend(sub_100051348(v23, (uint64_t)@"flags"), "unsignedLongLongValue");
            objc_msgSend(sub_100051348(v23, (uint64_t)@"cpu"), "doubleValue");
            double v32 = v31;
            if (v31 <= 0.0)
            {
              if (byte_1000E7D30)
              {
                int v84 = *__error();
                BOOL v85 = (os_log_s *)sub_10002EFA0();
                if (os_log_type_enabled(v85, OS_LOG_TYPE_ERROR))
                {
                  *(_DWORD *)buf = 134217984;
                  *(double *)&uint8_t buf[4] = v32;
                  _os_log_error_impl( (void *)&_mh_execute_header,  v85,  OS_LOG_TYPE_ERROR,  "deferred cpu resource: bad cpu_used (%f)",  buf,  0xCu);
                }

                *__error() = v84;
              }

              if (!byte_1000E7D31 || dword_1000E74E0 > 3) {
                goto LABEL_174;
              }
              int v41 = *__error();
              uint64_t v42 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"deferred cpu resource: bad cpu_used (%f)",  *(void *)&v32);
              if (!v42)
              {
                int v86 = (os_log_s *)sub_10002EFA0();
                if (!os_log_type_enabled(v86, OS_LOG_TYPE_FAULT)) {
                  goto LABEL_151;
                }
                *(_DWORD *)buf = 134217984;
                *(double *)&uint8_t buf[4] = v32;
                int v44 = v86;
                int v45 = "Unable to format: deferred cpu resource: bad cpu_used (%f)";
LABEL_164:
                _os_log_fault_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_FAULT, v45, buf, 0xCu);
                goto LABEL_151;
              }
            }

            else
            {
              objc_msgSend(sub_100051348(v23, (uint64_t)@"duration"), "doubleValue");
              double v34 = v33;
              if (v33 <= 0.0)
              {
                if (byte_1000E7D30)
                {
                  int v95 = *__error();
                  unsigned int v96 = (os_log_s *)sub_10002EFA0();
                  if (os_log_type_enabled(v96, OS_LOG_TYPE_ERROR))
                  {
                    *(_DWORD *)buf = 134217984;
                    *(double *)&uint8_t buf[4] = v34;
                    _os_log_error_impl( (void *)&_mh_execute_header,  v96,  OS_LOG_TYPE_ERROR,  "deferred cpu resource: bad duration (%f)",  buf,  0xCu);
                  }

                  *__error() = v95;
                }

                if (!byte_1000E7D31 || dword_1000E74E0 > 3) {
                  goto LABEL_174;
                }
                int v41 = *__error();
                uint64_t v42 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"deferred cpu resource: bad duration (%f)",  *(void *)&v34);
                if (!v42)
                {
                  uint64_t v97 = (os_log_s *)sub_10002EFA0();
                  if (!os_log_type_enabled(v97, OS_LOG_TYPE_FAULT)) {
                    goto LABEL_151;
                  }
                  *(_DWORD *)buf = 134217984;
                  *(double *)&uint8_t buf[4] = v34;
                  int v44 = v97;
                  int v45 = "Unable to format: deferred cpu resource: bad duration (%f)";
                  goto LABEL_164;
                }
              }

              else
              {
                objc_msgSend(sub_100051348(v23, (uint64_t)@"endtime"), "doubleValue");
                if (v35 <= 0.0)
                {
                  if (byte_1000E7D30)
                  {
                    int v102 = *__error();
                    uint64_t v103 = (os_log_s *)sub_10002EFA0();
                    if (os_log_type_enabled(v103, OS_LOG_TYPE_ERROR)) {
                      sub_10008A798(&v261, v262);
                    }
                    *__error() = v102;
                  }

                  if (!byte_1000E7D31 || dword_1000E74E0 > 3) {
                    goto LABEL_174;
                  }
                  int v41 = *__error();
                  uint64_t v42 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"deferred cpu resource: no endtime provided");
                  if (!v42)
                  {
                    int v104 = (os_log_s *)sub_10002EFA0();
                    if (os_log_type_enabled(v104, OS_LOG_TYPE_FAULT)) {
                      sub_10008A76C(&v259, v260);
                    }
                    goto LABEL_151;
                  }
                }

                else
                {
                  double v36 = v35;
                  objc_msgSend(sub_100051348(v23, (uint64_t)@"cpu_limit"), "doubleValue");
                  double v38 = v37;
                  if (v37 >= 0.0)
                  {
                    objc_msgSend(sub_100051348(v23, (uint64_t)@"duration_limit"), "doubleValue");
                    double v106 = v105;
                    if (v105 >= 0.0)
                    {
                      id v250 = sub_1000513A8(v23, (uint64_t)@"pname");
                      id v115 = sub_1000513A8(v23, (uint64_t)@"action");
                      if (v115)
                      {
                        uint64_t v116 = sub_100055AE4((const char *)[v115 UTF8String]);
                        int v248 = +[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v116);
                        free(v116);
                      }

                      else
                      {
                        int v248 = 0LL;
                      }

                      if ((v28 & 0x80000000) != 0)
                      {
                        if (byte_1000E7D30)
                        {
                          int v135 = *__error();
                          uint64_t v136 = (os_log_s *)sub_10002EFA0();
                          if (os_log_type_enabled(v136, OS_LOG_TYPE_INFO))
                          {
                            *(_WORD *)buf = 0;
                            _os_log_impl( (void *)&_mh_execute_header,  v136,  OS_LOG_TYPE_INFO,  "deferred cpu resource: generating deferred report",  buf,  2u);
                          }

                          *__error() = v135;
                        }

                        if (byte_1000E7D31 && dword_1000E74E0 <= 1)
                        {
                          int v246 = *__error();
                          uint64_t v132 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"deferred cpu resource: generating deferred report");
                          if (v132) {
                            goto LABEL_255;
                          }
                          uint64_t v147 = (os_log_s *)sub_10002EFA0();
                          if (os_log_type_enabled(v147, OS_LOG_TYPE_FAULT)) {
                            sub_10008A740(&v257, v258);
                          }
LABEL_283:
                          if (qword_1000E7D38) {
                            uint64_t v148 = (FILE *)qword_1000E7D38;
                          }
                          else {
                            uint64_t v148 = __stderrp;
                          }
                          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v148);
LABEL_287:
                          *__error() = v246;
                        }
                      }

                      else
                      {
                        if (byte_1000E7D30)
                        {
                          int v128 = *__error();
                          __int16 v129 = (os_log_s *)sub_10002EFA0();
                          if (os_log_type_enabled(v129, OS_LOG_TYPE_INFO))
                          {
                            uint64_t v130 = sub_10002EF3C(v28);
                            *(_DWORD *)buf = 136446466;
                            *(void *)&uint8_t buf[4] = v130;
                            __int16 v279 = 1024;
                            LODWORD(v280) = v28;
                            _os_log_impl( (void *)&_mh_execute_header,  v129,  OS_LOG_TYPE_INFO,  "%{public}s [%d]: deferred cpu resource: generating deferred report",  buf,  0x12u);
                          }

                          *__error() = v128;
                        }

                        if (byte_1000E7D31 && dword_1000E74E0 <= 1)
                        {
                          int v246 = *__error();
                          int v131 = sub_10002EF3C(v28);
                          uint64_t v132 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"%s [%d]: deferred cpu resource: generating deferred report",  v131,  v28);
                          if (!v132)
                          {
                            BOOL v133 = (os_log_s *)sub_10002EFA0();
                            if (os_log_type_enabled(v133, OS_LOG_TYPE_FAULT))
                            {
                              dispatch_queue_global_t v134 = sub_10002EF3C(v28);
                              *(_DWORD *)buf = 136315394;
                              *(void *)&uint8_t buf[4] = v134;
                              __int16 v279 = 1024;
                              LODWORD(v280) = v28;
                              _os_log_fault_impl( (void *)&_mh_execute_header,  v133,  OS_LOG_TYPE_FAULT,  "Unable to format: %s [%d]: deferred cpu resource: generating deferred report",  buf,  0x12u);
                            }

                            goto LABEL_283;
                          }

LABEL_255:
                          int v137 = v132;
                          double v138 = CFStringGetCStringPtr(v132, 0x8000100u);
                          if (v138)
                          {
                            xpc_object_t v139 = (char *)v138;
                            cfa = 0LL;
                          }

                          else
                          {
                            xpc_object_t v139 = (char *)calloc(0x400uLL, 1uLL);
                            CFStringGetCString(v137, v139, 1024LL, 0x8000100u);
                            cfa = v139;
                          }

                          if (qword_1000E7D38) {
                            uint64_t v142 = (FILE *)qword_1000E7D38;
                          }
                          else {
                            uint64_t v142 = __stderrp;
                          }
                          fprintf(v142, "%s\n", v139);
                          if (cfa) {
                            free(cfa);
                          }
                          CFRelease(v137);
                          goto LABEL_287;
                        }
                      }

                      sub_10003FD08(v28, v250, (uint64_t)v29, (uint64_t)v30, v248, v32, v34, v36, v38, v106);
                      goto LABEL_174;
                    }

                    if (byte_1000E7D30)
                    {
                      int v107 = *__error();
                      unint64_t v108 = (os_log_s *)sub_10002EFA0();
                      if (os_log_type_enabled(v108, OS_LOG_TYPE_ERROR))
                      {
                        *(_DWORD *)buf = 134217984;
                        *(double *)&uint8_t buf[4] = v106;
                        _os_log_error_impl( (void *)&_mh_execute_header,  v108,  OS_LOG_TYPE_ERROR,  "deferred cpu resource: bad duration_limit (%f)",  buf,  0xCu);
                      }

                      *__error() = v107;
                    }

                    if (!byte_1000E7D31 || dword_1000E74E0 > 3) {
                      goto LABEL_174;
                    }
                    int v41 = *__error();
                    uint64_t v42 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"deferred cpu resource: bad duration_limit (%f)",  *(void *)&v106);
                    if (!v42)
                    {
                      BOOL v109 = (os_log_s *)sub_10002EFA0();
                      if (!os_log_type_enabled(v109, OS_LOG_TYPE_FAULT)) {
                        goto LABEL_151;
                      }
                      *(_DWORD *)buf = 134217984;
                      *(double *)&uint8_t buf[4] = v106;
                      int v44 = v109;
                      int v45 = "Unable to format: deferred cpu resource: bad duration_limit (%f)";
                      goto LABEL_164;
                    }
                  }

                  else
                  {
                    if (byte_1000E7D30)
                    {
                      int v39 = *__error();
                      id v40 = (os_log_s *)sub_10002EFA0();
                      if (os_log_type_enabled(v40, OS_LOG_TYPE_ERROR))
                      {
                        *(_DWORD *)buf = 134217984;
                        *(double *)&uint8_t buf[4] = v38;
                        _os_log_error_impl( (void *)&_mh_execute_header,  v40,  OS_LOG_TYPE_ERROR,  "deferred cpu resource: bad cpu_used_limit (%f)",  buf,  0xCu);
                      }

                      *__error() = v39;
                    }

                    if (!byte_1000E7D31 || dword_1000E74E0 > 3) {
                      goto LABEL_174;
                    }
                    int v41 = *__error();
                    uint64_t v42 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"deferred cpu resource: bad cpu_used_limit (%f)",  *(void *)&v38);
                    if (!v42)
                    {
                      uint64_t v43 = (os_log_s *)sub_10002EFA0();
                      if (os_log_type_enabled(v43, OS_LOG_TYPE_FAULT))
                      {
                        *(_DWORD *)buf = 134217984;
                        *(double *)&uint8_t buf[4] = v38;
                        int v44 = v43;
                        int v45 = "Unable to format: deferred cpu resource: bad cpu_used_limit (%f)";
                        goto LABEL_164;
                      }

                      goto LABEL_151;
                    }
                  }
                }
              }
            }
          }

          else
          {
            if (byte_1000E7D30)
            {
              int v77 = *__error();
              uint64_t v78 = (os_log_s *)sub_10002EFA0();
              if (os_log_type_enabled(v78, OS_LOG_TYPE_ERROR)) {
                sub_10008A718(&v265, v266);
              }
              *__error() = v77;
            }

            if (!byte_1000E7D31 || dword_1000E74E0 > 3) {
              goto LABEL_174;
            }
            int v41 = *__error();
            uint64_t v42 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"deferred cpu resource: no pid provided");
            if (!v42)
            {
              BOOL v79 = (os_log_s *)sub_10002EFA0();
              if (os_log_type_enabled(v79, OS_LOG_TYPE_FAULT)) {
                sub_10008A6EC(&v263, v264);
              }
              goto LABEL_151;
            }
          }

          goto LABEL_66;
        }

        if (byte_1000E7D30)
        {
          int v67 = *__error();
          int v68 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v68, OS_LOG_TYPE_ERROR)) {
            sub_10008A69C((uint64_t)&v281, v25);
          }
          *__error() = v67;
        }

        if (byte_1000E7D31) {
          BOOL v69 = dword_1000E74E0 <= 3;
        }
        else {
          BOOL v69 = 0;
        }
        if (!v69) {
          goto LABEL_174;
        }
        int v41 = *__error();
        int v70 = CFStringCreateWithFormat( kCFAllocatorDefault,  0,  @"Unhandled deferred report type %llu",  [v25 longLongValue]);
        if (!v70)
        {
          BOOL v93 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v93, OS_LOG_TYPE_FAULT)) {
            sub_10008A64C((uint64_t)v277, v25);
          }
          goto LABEL_151;
        }

        id v71 = v70;
        id v72 = CFStringGetCStringPtr(v70, 0x8000100u);
        if (v72)
        {
          int v73 = (char *)v72;
          int v74 = 0LL;
        }

        else
        {
          int v73 = (char *)calloc(0x400uLL, 1uLL);
          CFStringGetCString(v71, v73, 1024LL, 0x8000100u);
          int v74 = v73;
        }

        if (qword_1000E7D38) {
          uint64_t v98 = (FILE *)qword_1000E7D38;
        }
        else {
          uint64_t v98 = __stderrp;
        }
        fprintf(v98, "%s\n", v73);
        if (v74) {
          free(v74);
        }
        id v76 = v71;
LABEL_172:
        CFRelease(v76);
LABEL_173:
        *__error() = v41;
LABEL_174:
        if (++v22 >= -[NSArray count](v16, "count")) {
          goto LABEL_345;
        }
      }

      if (byte_1000E7D30)
      {
        int v46 = *__error();
        int64_t v47 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v47, OS_LOG_TYPE_ERROR)) {
          sub_10008A624(&v254, v255);
        }
        *__error() = v46;
      }

      if (byte_1000E7D31) {
        BOOL v48 = dword_1000E74E0 <= 3;
      }
      else {
        BOOL v48 = 0;
      }
      if (!v48) {
        goto LABEL_174;
      }
      int v41 = *__error();
      uint64_t v42 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"Bad deferred report type value type");
      if (!v42)
      {
        uint64_t v83 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v83, OS_LOG_TYPE_FAULT)) {
          sub_10008A5F8(&v252, v253);
        }
        goto LABEL_151;
      }

LABEL_66:
      int v49 = v42;
      uint64_t v50 = CFStringGetCStringPtr(v42, 0x8000100u);
      if (v50)
      {
        int v51 = (char *)v50;
        id v52 = 0LL;
      }

      else
      {
        int v51 = (char *)calloc(0x400uLL, 1uLL);
        CFStringGetCString(v49, v51, 1024LL, 0x8000100u);
        id v52 = v51;
      }

      if (qword_1000E7D38) {
        int v75 = (FILE *)qword_1000E7D38;
      }
      else {
        int v75 = __stderrp;
      }
      fprintf(v75, "%s\n", v51);
      if (v52) {
        free(v52);
      }
      id v76 = v49;
      goto LABEL_172;
    }

LABEL_345:
    if (v22 >= -[NSArray count](v16, "count"))
    {
      if (byte_1000E7D30)
      {
        int v190 = *__error();
        BOOL v191 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v191, OS_LOG_TYPE_DEFAULT))
        {
          NSUInteger v192 = -[NSArray count](v16, "count");
          *(_DWORD *)buf = 134217984;
          *(void *)&uint8_t buf[4] = v192;
          _os_log_impl( (void *)&_mh_execute_header,  v191,  OS_LOG_TYPE_DEFAULT,  "Generated %lu deferred reports",  buf,  0xCu);
        }

        *__error() = v190;
      }

      if (byte_1000E7D31) {
        BOOL v193 = dword_1000E74E0 <= 2;
      }
      else {
        BOOL v193 = 0;
      }
      if (v193)
      {
        int v194 = *__error();
        id v195 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"Generated %lu deferred reports",  -[NSArray count](v16, "count"));
        if (v195)
        {
          id v196 = v195;
          double v197 = CFStringGetCStringPtr(v195, 0x8000100u);
          if (v197)
          {
            xpc_object_t v198 = (char *)v197;
            uint64_t v199 = 0LL;
          }

          else
          {
            xpc_object_t v198 = (char *)calloc(0x400uLL, 1uLL);
            CFStringGetCString(v196, v198, 1024LL, 0x8000100u);
            uint64_t v199 = v198;
          }

          if (qword_1000E7D38) {
            id v228 = (FILE *)qword_1000E7D38;
          }
          else {
            id v228 = __stderrp;
          }
          fprintf(v228, "%s\n", v198);
          if (v199) {
            free(v199);
          }
          CFRelease(v196);
        }

        else
        {
          int v214 = (char *)sub_10002EFA0();
          if (os_log_type_enabled((os_log_t)v214, OS_LOG_TYPE_FAULT)) {
            sub_10008A584(v16, v214);
          }
          if (qword_1000E7D38) {
            uint64_t v215 = (FILE *)qword_1000E7D38;
          }
          else {
            uint64_t v215 = __stderrp;
          }
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v215);
        }

        *__error() = v194;
      }

      *(void *)buf = 0LL;
      if (!-[NSFileManager removeItemAtURL:error:]( +[NSFileManager defaultManager](&OBJC_CLASS___NSFileManager, "defaultManager"),  "removeItemAtURL:error:",  v14,  buf))
      {
        int v229 = *__error();
        uint64_t v230 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v230, OS_LOG_TYPE_FAULT)) {
          sub_10008A0B8();
        }
        *__error() = v229;
        if (byte_1000E7D31)
        {
          if (dword_1000E74E0 <= 4)
          {
            int v153 = *__error();
            mach_port_name_t v154 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"Unable to remove deferred reports plist: %@",  *(void *)buf);
            if (!v154)
            {
              uint64_t v231 = (os_log_s *)sub_10002EFA0();
              if (os_log_type_enabled(v231, OS_LOG_TYPE_FAULT)) {
                sub_10008A058();
              }
              goto LABEL_333;
            }

            goto LABEL_305;
          }
        }
      }

      return 1LL;
    }

    if (byte_1000E7D30)
    {
      int v180 = *__error();
      double v181 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v181, OS_LOG_TYPE_DEFAULT))
      {
        int64_t v182 = -[NSArray count](v16, "count");
        *(_DWORD *)buf = 134218240;
        *(void *)&uint8_t buf[4] = &v182[-v22];
        __int16 v279 = 2048;
        unint64_t v280 = v22;
        _os_log_impl( (void *)&_mh_execute_header,  v181,  OS_LOG_TYPE_DEFAULT,  "Task expired with %lu remaining deferred reports (generated %lu)",  buf,  0x16u);
      }

      *__error() = v180;
    }

    if (byte_1000E7D31) {
      BOOL v183 = dword_1000E74E0 <= 2;
    }
    else {
      BOOL v183 = 0;
    }
    if (v183)
    {
      int v184 = *__error();
      int v185 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"Task expired with %lu remaining deferred reports (generated %lu)",  (char *)-[NSArray count](v16, "count") - v22,  v22);
      if (v185)
      {
        id v186 = v185;
        id v187 = CFStringGetCStringPtr(v185, 0x8000100u);
        if (v187)
        {
          id v188 = (char *)v187;
          int v189 = 0LL;
        }

        else
        {
          id v188 = (char *)calloc(0x400uLL, 1uLL);
          CFStringGetCString(v186, v188, 1024LL, 0x8000100u);
          int v189 = v188;
        }

        if (qword_1000E7D38) {
          unsigned int v216 = (FILE *)qword_1000E7D38;
        }
        else {
          unsigned int v216 = __stderrp;
        }
        fprintf(v216, "%s\n", v188);
        if (v189) {
          free(v189);
        }
        CFRelease(v186);
      }

      else
      {
        xpc_object_t v212 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v212, OS_LOG_TYPE_FAULT)) {
          sub_10008A50C();
        }
        if (qword_1000E7D38) {
          uint64_t v213 = (FILE *)qword_1000E7D38;
        }
        else {
          uint64_t v213 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v213);
      }

      *__error() = v184;
    }

    if (v22)
    {
      int v217 = -[NSArray subarrayWithRange:](v16, "subarrayWithRange:", v22, (char *)-[NSArray count](v16, "count") - v22);
      *(void *)buf = 0LL;
      if (!-[NSArray writeToURL:error:](v217, "writeToURL:error:", v14, buf))
      {
        int v219 = *__error();
        uint64_t v220 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v220, OS_LOG_TYPE_FAULT)) {
          sub_10008A4A0();
        }
        *__error() = v219;
        if (byte_1000E7D31 && dword_1000E74E0 <= 4)
        {
          int v221 = *__error();
          id v222 = -[NSArray count](v217, "count");
          uint64_t v223 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"Unable to write %lu remaining deferred reports to plist: %@",  v222,  *(void *)buf);
          if (v223)
          {
            uint64_t v224 = v223;
            uint64_t v225 = CFStringGetCStringPtr(v223, 0x8000100u);
            if (v225)
            {
              BOOL v226 = (char *)v225;
              int v227 = 0LL;
            }

            else
            {
              BOOL v226 = (char *)calloc(0x400uLL, 1uLL);
              CFStringGetCString(v224, v226, 1024LL, 0x8000100u);
              int v227 = v226;
            }

            if (qword_1000E7D38) {
              uint64_t v234 = (FILE *)qword_1000E7D38;
            }
            else {
              uint64_t v234 = __stderrp;
            }
            fprintf(v234, "%s\n", v226);
            if (v227) {
              free(v227);
            }
            CFRelease(v224);
          }

          else
          {
            uint64_t v232 = (os_log_s *)sub_10002EFA0();
            if (os_log_type_enabled(v232, OS_LOG_TYPE_FAULT)) {
              sub_10008A434();
            }
            if (qword_1000E7D38) {
              uint64_t v233 = (FILE *)qword_1000E7D38;
            }
            else {
              uint64_t v233 = __stderrp;
            }
            fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v233);
          }

          *__error() = v221;
        }

        uint64_t v251 = 0LL;
        if (!-[NSFileManager removeItemAtURL:error:]( +[NSFileManager defaultManager](&OBJC_CLASS___NSFileManager, "defaultManager"),  "removeItemAtURL:error:",  v14,  &v251))
        {
          int v235 = *__error();
          uint64_t v236 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v236, OS_LOG_TYPE_FAULT)) {
            sub_10008A0B8();
          }
          *__error() = v235;
          if (byte_1000E7D31)
          {
            if (dword_1000E74E0 <= 4)
            {
              int v153 = *__error();
              mach_port_name_t v154 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"Unable to remove deferred reports plist: %@",  v251);
              if (!v154)
              {
                v237 = (os_log_s *)sub_10002EFA0();
                if (os_log_type_enabled(v237, OS_LOG_TYPE_FAULT)) {
                  sub_10008A058();
                }
                goto LABEL_333;
              }

              goto LABEL_305;
            }
          }
        }

        return 1LL;
      }
    }

    return 0LL;
  }

  else
  {
    if (byte_1000E7D30)
    {
      int v168 = *__error();
      unsigned int v169 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v169, OS_LOG_TYPE_ERROR)) {
        sub_10008A3C8();
      }
      *__error() = v168;
    }

    if (byte_1000E7D31) {
      BOOL v170 = dword_1000E74E0 <= 3;
    }
    else {
      BOOL v170 = 0;
    }
    if (v170)
    {
      int v171 = *__error();
      uint64_t v172 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"Unable to read deferred reports plist: %@",  v256);
      if (v172)
      {
        int v173 = v172;
        uint64_t v174 = CFStringGetCStringPtr(v172, 0x8000100u);
        if (v174)
        {
          double v175 = (char *)v174;
          xpc_object_t v176 = 0LL;
        }

        else
        {
          double v175 = (char *)calloc(0x400uLL, 1uLL);
          CFStringGetCString(v173, v175, 1024LL, 0x8000100u);
          xpc_object_t v176 = v175;
        }

        if (qword_1000E7D38) {
          uint64_t v208 = (FILE *)qword_1000E7D38;
        }
        else {
          uint64_t v208 = __stderrp;
        }
        fprintf(v208, "%s\n", v175);
        if (v176) {
          free(v176);
        }
        CFRelease(v173);
      }

      else
      {
        uint64_t v202 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v202, OS_LOG_TYPE_FAULT)) {
          sub_10008A368();
        }
        if (qword_1000E7D38) {
          uint64_t v203 = (FILE *)qword_1000E7D38;
        }
        else {
          uint64_t v203 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v203);
      }

      *__error() = v171;
    }

    *(void *)buf = 0LL;
    if (!-[NSFileManager removeItemAtURL:error:]( +[NSFileManager defaultManager](&OBJC_CLASS___NSFileManager, "defaultManager"),  "removeItemAtURL:error:",  v14,  buf))
    {
      int v209 = *__error();
      uint64_t v210 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v210, OS_LOG_TYPE_FAULT)) {
        sub_10008A0B8();
      }
      *__error() = v209;
      if (byte_1000E7D31)
      {
        if (dword_1000E74E0 <= 4)
        {
          int v153 = *__error();
          mach_port_name_t v154 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"Unable to remove deferred reports plist: %@",  *(void *)buf);
          if (v154) {
            goto LABEL_305;
          }
          uint64_t v211 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v211, OS_LOG_TYPE_FAULT)) {
LABEL_397:
          }
            sub_10008A058();
LABEL_333:
          if (qword_1000E7D38) {
            int v178 = (FILE *)qword_1000E7D38;
          }
          else {
            int v178 = __stderrp;
          }
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v178);
          goto LABEL_344;
        }
      }
    }

    return 1LL;
  }

id sub_100051348(void *a1, uint64_t a2)
{
  uint64_t v4 = objc_opt_class(&OBJC_CLASS___NSNumber);
  id v5 = [a1 objectForKeyedSubscript:a2];
  if (!v5) {
    return 0LL;
  }
  id v6 = v5;
  if ((objc_opt_isKindOfClass(v5, v4) & 1) == 0) {
    return 0LL;
  }
  return v6;
}

id sub_1000513A8(void *a1, uint64_t a2)
{
  uint64_t v4 = objc_opt_class(&OBJC_CLASS___NSString);
  id v5 = [a1 objectForKeyedSubscript:a2];
  if (!v5) {
    return 0LL;
  }
  id v6 = v5;
  if ((objc_opt_isKindOfClass(v5, v4) & 1) == 0) {
    return 0LL;
  }
  return v6;
}

void sub_100051408(void *a1, os_log_s *a2, uint64_t a3, const char *a4, uint8_t *a5)
{
}

_BYTE *sub_100051414(_BYTE *result, _BYTE *a2)
{
  *id result = 0;
  *a2 = 0;
  return result;
}

void sub_100051424(void *a1, int a2, os_log_t log, const char *a4, uint8_t *a5)
{
}

  ;
}

id sub_10005144C(void *a1, const char *a2)
{
  return [a1 count];
}

id sub_100051454(uint64_t a1, void *a2)
{
  return [a2 longLongValue];
}

  ;
}

  ;
}

void sub_100051480( uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, int a8, uint64_t a9)
{
  uint64_t v17 = sub_10002EDE8("Resource exhaustion for [%d]", a2);
  dispatch_queue_global_t global_queue = dispatch_get_global_queue(25LL, 0LL);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472LL;
  block[2] = sub_10005154C;
  block[3] = &unk_1000D94E8;
  int v20 = a2;
  int v21 = a8;
  block[8] = a1;
  block[9] = a4;
  block[4] = v17;
  void block[5] = a3;
  void block[6] = a5;
  block[7] = a9;
  block[10] = a6;
  block[11] = a7;
  dispatch_async(global_queue, block);
}

void sub_10005154C(uint64_t a1)
{
  time_t v2 = time(0LL);
  id v3 = +[NSMutableString string](&OBJC_CLASS___NSMutableString, "string");
  uint64_t v4 = (unsigned int *)(a1 + 96);
  uint64_t v5 = snprintf(__str, 8uLL, "%d", *(_DWORD *)(a1 + 96));
  if ((unint64_t)(*(void *)(a1 + 64) - 1LL) > 1)
  {
LABEL_64:
    if ((byte_1000E7D44 & 2) != 0 && (uint64_t v5 = sub_1000257B8(), (v5 & 1) != 0))
    {
      int v45 = 0LL;
    }

    else
    {
      uint64_t v46 = stackshot_config_create(v5);
      stackshot_config_set_flags(v46, 1302536203LL);
      int v45 =  sub_10006BCB4( v46,  +[NSMutableSet setWithObject:]( &OBJC_CLASS___NSMutableSet,  "setWithObject:",  +[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", *v4)));
      stackshot_config_dealloc(v46);
    }

    objc_msgSend(v3, "appendFormat:", @"lsof -n -M -P -T -w +c 0 -s +fg +L -p %d\n", *v4);
    *(void *)buf = "/usr/sbin/lsof";
    *(void *)&uint8_t buf[8] = "-n";
    *(void *)&uint8_t buf[16] = "-M";
    *(void *)&uint8_t buf[24] = "-P";
    uint64_t v210 = "-T";
    uint64_t v211 = "-w";
    xpc_object_t v212 = "+c";
    uint64_t v213 = "0";
    int v214 = "-s";
    uint64_t v215 = "+fg";
    unsigned int v216 = "+L";
    int v217 = "-p";
    id v218 = __str;
    uint64_t v219 = 0LL;
    int v207 = -1;
    LOBYTE(v189) = 0;
    pid_t v47 = SASpawnPlatformBinaryWithSigningIdentifier( "/usr/sbin/lsof",  "com.apple.lsof",  buf,  0LL,  0LL,  0LL,  &v207,  0LL,  0LL,  (_DWORD)v189,  0LL);
    if ((v47 & 0x80000000) == 0)
    {
      pid_t v48 = v47;
      time_t v194 = v2;
      uint64_t v196 = a1;
      int v49 = calloc(0x20uLL, 0x400uLL);
      ssize_t v50 = read(v207, v49, vm_page_size - 1);
      if (v50 < 1)
      {
        waitpid(v48, 0LL, 0);
        free(v49);
        [v3 appendFormat:@"\n"];
        a1 = v196;
      }

      else
      {
        ssize_t v51 = v50;
        pid_t v192 = v48;
        int v190 = v45;
        char v52 = 0;
        do
        {
          *((_BYTE *)v49 + v51) = 0;
          id v53 = -[NSString initWithBytesNoCopy:length:encoding:freeWhenDone:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithBytesNoCopy:length:encoding:freeWhenDone:",  v49,  v51,  4LL,  0LL);
          if (v53)
          {
            uint64_t v54 = v53;
            [v3 appendString:v53];

            char v52 = 1;
          }

          else if ((*v4 & 0x80000000) != 0)
          {
            if (byte_1000E7D30)
            {
              int v66 = *__error();
              int v67 = (os_log_s *)sub_10002EFA0();
              if (os_log_type_enabled(v67, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)uint64_t v208 = 136315138;
                *(void *)&v208[4] = v49;
                _os_log_error_impl( (void *)&_mh_execute_header,  v67,  OS_LOG_TYPE_ERROR,  "Unable to convert lsof output to NSString: %s",  v208,  0xCu);
              }

              *__error() = v66;
            }

            if (byte_1000E7D31) {
              BOOL v68 = dword_1000E74E0 <= 3;
            }
            else {
              BOOL v68 = 0;
            }
            if (v68)
            {
              int v69 = *__error();
              int v70 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"Unable to convert lsof output to NSString: %s",  v49);
              if (v70)
              {
                id v71 = v70;
                CStringPtr = CFStringGetCStringPtr(v70, 0x8000100u);
                if (CStringPtr)
                {
                  int v73 = (char *)CStringPtr;
                  int v74 = 0LL;
                }

                else
                {
                  int v73 = (char *)calloc(0x400uLL, 1uLL);
                  CFStringGetCString(v71, v73, 1024LL, 0x8000100u);
                  int v74 = v73;
                }

                if (qword_1000E7D38) {
                  int v80 = (FILE *)qword_1000E7D38;
                }
                else {
                  int v80 = __stderrp;
                }
                fprintf(v80, "%s\n", v73);
                if (v74) {
                  free(v74);
                }
                CFRelease(v71);
              }

              else
              {
                uint64_t v78 = (os_log_s *)sub_10002EFA0();
                if (os_log_type_enabled(v78, OS_LOG_TYPE_FAULT))
                {
                  *(_DWORD *)uint64_t v208 = 136315138;
                  *(void *)&v208[4] = v49;
                  _os_log_fault_impl( (void *)&_mh_execute_header,  v78,  OS_LOG_TYPE_FAULT,  "Unable to format: Unable to convert lsof output to NSString: %s",  v208,  0xCu);
                }

                if (qword_1000E7D38) {
                  BOOL v79 = (FILE *)qword_1000E7D38;
                }
                else {
                  BOOL v79 = __stderrp;
                }
                fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v79);
              }

              *__error() = v69;
            }
          }

          else
          {
            if (byte_1000E7D30)
            {
              int v55 = *__error();
              id v56 = (os_log_s *)sub_10002EFA0();
              if (os_log_type_enabled(v56, OS_LOG_TYPE_ERROR))
              {
                BOOL v81 = sub_10002EF3C(*v4);
                int v82 = *v4;
                *(_DWORD *)uint64_t v208 = 136446722;
                *(void *)&v208[4] = v81;
                *(_WORD *)&v208[12] = 1024;
                *(_DWORD *)&v208[14] = v82;
                *(_WORD *)&v208[18] = 2080;
                *(void *)&v208[20] = v49;
                _os_log_error_impl( (void *)&_mh_execute_header,  v56,  OS_LOG_TYPE_ERROR,  "%{public}s [%d]: Unable to convert lsof output to NSString: %s",  v208,  0x1Cu);
              }

              *__error() = v55;
            }

            if (byte_1000E7D31) {
              BOOL v57 = dword_1000E74E0 <= 3;
            }
            else {
              BOOL v57 = 0;
            }
            if (v57)
            {
              id v58 = v3;
              int v59 = *__error();
              double v60 = sub_10002EF3C(*v4);
              uint64_t v61 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"%s [%d]: Unable to convert lsof output to NSString: %s",  v60,  *v4,  v49);
              if (v61)
              {
                double v62 = v61;
                double v63 = CFStringGetCStringPtr(v61, 0x8000100u);
                if (v63)
                {
                  int v64 = (char *)v63;
                  int v65 = 0LL;
                }

                else
                {
                  int v64 = (char *)calloc(0x400uLL, 1uLL);
                  CFStringGetCString(v62, v64, 1024LL, 0x8000100u);
                  int v65 = v64;
                }

                if (qword_1000E7D38) {
                  int v77 = (FILE *)qword_1000E7D38;
                }
                else {
                  int v77 = __stderrp;
                }
                fprintf(v77, "%s\n", v64);
                if (v65) {
                  free(v65);
                }
                CFRelease(v62);
              }

              else
              {
                int v75 = (os_log_s *)sub_10002EFA0();
                if (os_log_type_enabled(v75, OS_LOG_TYPE_FAULT))
                {
                  uint64_t v83 = sub_10002EF3C(*v4);
                  int v84 = *v4;
                  *(_DWORD *)uint64_t v208 = 136315650;
                  *(void *)&v208[4] = v83;
                  *(_WORD *)&v208[12] = 1024;
                  *(_DWORD *)&v208[14] = v84;
                  *(_WORD *)&v208[18] = 2080;
                  *(void *)&v208[20] = v49;
                  _os_log_fault_impl( (void *)&_mh_execute_header,  v75,  OS_LOG_TYPE_FAULT,  "Unable to format: %s [%d]: Unable to convert lsof output to NSString: %s",  v208,  0x1Cu);
                }

                if (qword_1000E7D38) {
                  id v76 = (FILE *)qword_1000E7D38;
                }
                else {
                  id v76 = __stderrp;
                }
                fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v76);
              }

              *__error() = v59;
              id v3 = v58;
            }
          }

          ssize_t v51 = read(v207, v49, vm_page_size - 1);
        }

        while (v51 > 0);
        waitpid(v192, 0LL, 0);
        free(v49);
        [v3 appendFormat:@"\n"];
        a1 = v196;
        if ((v52 & 1) != 0)
        {
          time_t v2 = v194;
          int v45 = v190;
LABEL_142:
          mach_port_name_t v96 = *(_DWORD *)(a1 + 100);
          if (v96 + 1 >= 2) {
            sub_100052FA4(*(void *)(a1 + 64), *(unsigned int *)(a1 + 96), v96);
          }
          dispatch_queue_global_t global_queue = dispatch_get_global_queue(9LL, 0LL);
          block[1] = 3221225472LL;
          __int128 v98 = *(_OWORD *)(a1 + 80);
          __int128 v203 = *(_OWORD *)(a1 + 64);
          int8x16_t v198 = vextq_s8(*(int8x16_t *)(a1 + 32), *(int8x16_t *)(a1 + 32), 8uLL);
          block[0] = _NSConcreteStackBlock;
          block[2] = sub_1000536CC;
          block[3] = &unk_1000D94C0;
          time_t v204 = v2;
          int v206 = *(_DWORD *)(a1 + 96);
          uint64_t v100 = *(void *)(a1 + 48);
          uint64_t v99 = *(void *)(a1 + 56);
          uint64_t v199 = v45;
          uint64_t v200 = v100;
          __int128 v205 = v98;
          id v201 = v3;
          uint64_t v202 = v99;
          dispatch_async(global_queue, block);
          return;
        }
      }

      goto LABEL_244;
    }

    if ((*v4 & 0x80000000) != 0)
    {
      if (byte_1000E7D30)
      {
        int v120 = *__error();
        double v121 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v121, OS_LOG_TYPE_ERROR)) {
          sub_10008B17C();
        }
        *__error() = v120;
      }

      if (!byte_1000E7D31 || dword_1000E74E0 > 3) {
        goto LABEL_243;
      }
      int v103 = *__error();
      uint64_t v122 = *__error();
      uint64_t v123 = __error();
      BOOL v124 = strerror(*v123);
      BOOL v109 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"Unable to spawn lsof: %d (%s)", v122, v124);
      if (!v109)
      {
        mach_port_name_t v154 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v154, OS_LOG_TYPE_FAULT)) {
          sub_10008B10C();
        }
        goto LABEL_238;
      }
    }

    else
    {
      if (byte_1000E7D30)
      {
        int v101 = *__error();
        int v102 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v102, OS_LOG_TYPE_ERROR)) {
          sub_10008B090();
        }
        *__error() = v101;
      }

      if (!byte_1000E7D31 || dword_1000E74E0 > 3) {
        goto LABEL_243;
      }
      int v103 = *__error();
      int v104 = sub_10002EF3C(*v4);
      uint64_t v105 = *v4;
      uint64_t v106 = *__error();
      int v107 = __error();
      unint64_t v108 = strerror(*v107);
      BOOL v109 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"%s [%d]: Unable to spawn lsof: %d (%s)",  v104,  v105,  v106,  v108);
      if (!v109)
      {
        int v110 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v110, OS_LOG_TYPE_FAULT)) {
          sub_10008B014();
        }
LABEL_238:
        if (qword_1000E7D38) {
          mach_port_name_t v155 = (FILE *)qword_1000E7D38;
        }
        else {
          mach_port_name_t v155 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v155);
LABEL_242:
        *__error() = v103;
LABEL_243:
        uint64_t v156 = *__error();
        xpc_object_t v157 = __error();
        objc_msgSend(v3, "appendFormat:", @"Unable to spawn lsof: %d (%s)\n\n", v156, strerror(*v157));
LABEL_244:
        BOOL v134 = sub_10002578C(*v4);
        int v158 = *v4;
        if (v134)
        {
          if ((v158 & 0x80000000) == 0)
          {
            if (byte_1000E7D30)
            {
              int v159 = *__error();
              id v160 = (os_log_s *)sub_10002EFA0();
              if (os_log_type_enabled(v160, OS_LOG_TYPE_ERROR)) {
                sub_10008AE14();
              }
              *__error() = v159;
            }

            if (!byte_1000E7D31 || dword_1000E74E0 > 3) {
              goto LABEL_307;
            }
            int v138 = *__error();
            BOOL v161 = sub_10002EF3C(*v4);
            int v140 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"%s [%d]: Unable to gather lsof for resource exhaustion report, though process is alive",  v161,  *v4);
            if (!v140)
            {
              int v162 = (os_log_s *)sub_10002EFA0();
              if (os_log_type_enabled(v162, OS_LOG_TYPE_FAULT)) {
                sub_10008ADA4();
              }
LABEL_302:
              if (qword_1000E7D38) {
                int v184 = (FILE *)qword_1000E7D38;
              }
              else {
                int v184 = __stderrp;
              }
              fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v184);
              goto LABEL_306;
            }

            goto LABEL_263;
          }

          if (byte_1000E7D30)
          {
            int v172 = *__error();
            int v173 = (os_log_s *)sub_10002EFA0();
            if (os_log_type_enabled(v173, OS_LOG_TYPE_ERROR)) {
              sub_10008AEB0();
            }
            *__error() = v172;
          }

          if (!byte_1000E7D31 || dword_1000E74E0 > 3) {
            goto LABEL_307;
          }
          int v138 = *__error();
          uint64_t v148 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"Unable to gather lsof for resource exhaustion report, though process is alive");
          if (!v148)
          {
            uint64_t v174 = (os_log_s *)sub_10002EFA0();
            if (os_log_type_enabled(v174, OS_LOG_TYPE_FAULT)) {
              sub_10008AE84();
            }
            goto LABEL_302;
          }

LABEL_288:
          int v177 = v148;
          int v178 = CFStringGetCStringPtr(v148, 0x8000100u);
          if (v178)
          {
            id v179 = (char *)v178;
            int v180 = 0LL;
          }

          else
          {
            id v179 = (char *)calloc(0x400uLL, 1uLL);
            CFStringGetCString(v177, v179, 1024LL, 0x8000100u);
            int v180 = v179;
          }

          if (qword_1000E7D38) {
            double v181 = (FILE *)qword_1000E7D38;
          }
          else {
            double v181 = __stderrp;
          }
          fprintf(v181, "%s\n", v179);
          if (v180) {
            free(v180);
          }
          int v171 = v177;
          goto LABEL_297;
        }

        if (v158 < 0)
        {
          if (byte_1000E7D30)
          {
            int v175 = *__error();
            xpc_object_t v176 = (os_log_s *)sub_10002EFA0();
            if (os_log_type_enabled(v176, OS_LOG_TYPE_ERROR)) {
              sub_10008AFE8();
            }
            *__error() = v175;
          }

          if (!byte_1000E7D31 || dword_1000E74E0 > 3) {
            goto LABEL_307;
          }
          int v138 = *__error();
          uint64_t v148 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"Unable to gather lsof for resource exhaustion report; process is no longer around");
          if (!v148)
          {
            BOOL v183 = (os_log_s *)sub_10002EFA0();
            if (os_log_type_enabled(v183, OS_LOG_TYPE_FAULT)) {
              sub_10008AFBC();
            }
            goto LABEL_302;
          }

          goto LABEL_288;
        }

        if (byte_1000E7D30)
        {
          int v163 = *__error();
          int v164 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v164, OS_LOG_TYPE_ERROR)) {
            sub_10008AF4C();
          }
          *__error() = v163;
        }

        if (!byte_1000E7D31 || dword_1000E74E0 > 3) {
          goto LABEL_307;
        }
        int v138 = *__error();
        int v165 = sub_10002EF3C(*v4);
        int v140 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"%s [%d]: Unable to gather lsof for resource exhaustion report; process is no longer around",
                 v165,
                 *v4);
        if (!v140)
        {
          int64_t v182 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v182, OS_LOG_TYPE_FAULT)) {
            sub_10008AEDC();
          }
          goto LABEL_302;
        }

        goto LABEL_263;
      }
    }

    int v125 = v109;
    uint64_t v126 = CFStringGetCStringPtr(v109, 0x8000100u);
    if (v126)
    {
      int v127 = (char *)v126;
      int v128 = 0LL;
    }

    else
    {
      int v127 = (char *)calloc(0x400uLL, 1uLL);
      CFStringGetCString(v125, v127, 1024LL, 0x8000100u);
      int v128 = v127;
    }

    if (qword_1000E7D38) {
      int v153 = (FILE *)qword_1000E7D38;
    }
    else {
      int v153 = __stderrp;
    }
    fprintf(v153, "%s\n", v127);
    if (v128) {
      free(v128);
    }
    CFRelease(v125);
    goto LABEL_242;
  }

  objc_msgSend(v3, "appendFormat:", @"ddt %d\n", *v4);
  *(void *)uint64_t v208 = "/usr/local/bin/ddt";
  *(void *)&v208[8] = __str;
  *(void *)&v208[16] = 0LL;
  int v207 = -1;
  pid_t v6 = SASpawnPlatformBinaryWithSigningIdentifier( "/usr/local/bin/ddt",  "com.apple.ddt",  v208,  0LL,  0LL,  0LL,  &v207,  0LL,  0LL,  0,  0LL);
  if (v6 < 0)
  {
    if ((*v4 & 0x80000000) != 0)
    {
      if (byte_1000E7D30)
      {
        int v111 = *__error();
        double v112 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v112, OS_LOG_TYPE_ERROR)) {
          sub_10008AD34();
        }
        *__error() = v111;
      }

      if (!byte_1000E7D31 || dword_1000E74E0 > 3) {
        goto LABEL_188;
      }
      int v87 = *__error();
      uint64_t v113 = *__error();
      id v114 = __error();
      id v115 = strerror(*v114);
      BOOL v93 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"Unable to spawn ddt: %d (%s)", v113, v115);
      if (!v93)
      {
        uint64_t v130 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v130, OS_LOG_TYPE_FAULT)) {
          sub_10008ACC4();
        }
        goto LABEL_183;
      }
    }

    else
    {
      if (byte_1000E7D30)
      {
        int v85 = *__error();
        int v86 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v86, OS_LOG_TYPE_ERROR)) {
          sub_10008AC48();
        }
        *__error() = v85;
      }

      if (!byte_1000E7D31 || dword_1000E74E0 > 3) {
        goto LABEL_188;
      }
      int v87 = *__error();
      uint64_t v88 = sub_10002EF3C(*v4);
      uint64_t v89 = *v4;
      uint64_t v90 = *__error();
      int v91 = __error();
      int v92 = strerror(*v91);
      BOOL v93 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"%s [%d]: Unable to spawn ddt: %d (%s)",  v88,  v89,  v90,  v92);
      if (!v93)
      {
        int v94 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v94, OS_LOG_TYPE_FAULT)) {
          sub_10008ABCC();
        }
LABEL_183:
        if (qword_1000E7D38) {
          int v131 = (FILE *)qword_1000E7D38;
        }
        else {
          int v131 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v131);
LABEL_187:
        *__error() = v87;
LABEL_188:
        uint64_t v132 = *__error();
        BOOL v133 = __error();
        uint64_t v188 = v132;
        int v189 = strerror(*v133);
        int v95 = @"Unable to spawn ddt: %d (%s)\n\n";
        goto LABEL_189;
      }
    }

    uint64_t v116 = v93;
    BOOL v117 = CFStringGetCStringPtr(v93, 0x8000100u);
    if (v117)
    {
      int v118 = (char *)v117;
      int64_t v119 = 0LL;
    }

    else
    {
      int v118 = (char *)calloc(0x400uLL, 1uLL);
      CFStringGetCString(v116, v118, 1024LL, 0x8000100u);
      int64_t v119 = v118;
    }

    if (qword_1000E7D38) {
      __int16 v129 = (FILE *)qword_1000E7D38;
    }
    else {
      __int16 v129 = __stderrp;
    }
    fprintf(v129, "%s\n", v118);
    if (v119) {
      free(v119);
    }
    CFRelease(v116);
    goto LABEL_187;
  }

  pid_t v7 = v6;
  int v8 = calloc(0x20uLL, 0x400uLL);
  ssize_t v9 = read(v207, v8, vm_page_size - 1);
  if (v9 < 1)
  {
    waitpid(v7, 0LL, 0);
    free(v8);
    int v95 = @"\n";
LABEL_189:
    objc_msgSend(v3, "appendFormat:", v95, v188, v189);
    goto LABEL_190;
  }

  ssize_t v10 = v9;
  pid_t v191 = v7;
  time_t v193 = v2;
  uint64_t v195 = a1;
  char v11 = 0;
  do
  {
    *((_BYTE *)v8 + v10) = 0;
    int v12 = -[NSString initWithBytesNoCopy:length:encoding:freeWhenDone:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithBytesNoCopy:length:encoding:freeWhenDone:",  v8,  v10,  4LL,  0LL);
    if (v12)
    {
      int v13 = v12;
      [v3 appendString:v12];

      char v11 = 1;
    }

    else if ((*v4 & 0x80000000) != 0)
    {
      if (byte_1000E7D30)
      {
        int v25 = *__error();
        id v26 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136315138;
          *(void *)&uint8_t buf[4] = v8;
          _os_log_error_impl( (void *)&_mh_execute_header,  v26,  OS_LOG_TYPE_ERROR,  "Unable to convert ddt output to NSString: %s",  buf,  0xCu);
        }

        *__error() = v25;
      }

      if (byte_1000E7D31) {
        BOOL v27 = dword_1000E74E0 <= 3;
      }
      else {
        BOOL v27 = 0;
      }
      if (v27)
      {
        int v28 = *__error();
        id v29 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"Unable to convert ddt output to NSString: %s",  v8);
        if (v29)
        {
          id v30 = v29;
          id v31 = v3;
          double v32 = CFStringGetCStringPtr(v29, 0x8000100u);
          if (v32)
          {
            double v33 = (char *)v32;
            double v34 = 0LL;
          }

          else
          {
            double v33 = (char *)calloc(0x400uLL, 1uLL);
            CFStringGetCString(v30, v33, 1024LL, 0x8000100u);
            double v34 = v33;
          }

          if (qword_1000E7D38) {
            id v40 = (FILE *)qword_1000E7D38;
          }
          else {
            id v40 = __stderrp;
          }
          fprintf(v40, "%s\n", v33);
          if (v34) {
            free(v34);
          }
          CFRelease(v30);
          id v3 = v31;
        }

        else
        {
          double v38 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v38, OS_LOG_TYPE_FAULT))
          {
            *(_DWORD *)buf = 136315138;
            *(void *)&uint8_t buf[4] = v8;
            _os_log_fault_impl( (void *)&_mh_execute_header,  v38,  OS_LOG_TYPE_FAULT,  "Unable to format: Unable to convert ddt output to NSString: %s",  buf,  0xCu);
          }

          if (qword_1000E7D38) {
            int v39 = (FILE *)qword_1000E7D38;
          }
          else {
            int v39 = __stderrp;
          }
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v39);
        }

        *__error() = v28;
      }
    }

    else
    {
      if (byte_1000E7D30)
      {
        int v14 = *__error();
        BOOL v15 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
        {
          int v41 = sub_10002EF3C(*v4);
          int v42 = *v4;
          *(_DWORD *)buf = 136446722;
          *(void *)&uint8_t buf[4] = v41;
          *(_WORD *)&_BYTE buf[12] = 1024;
          *(_DWORD *)&buf[14] = v42;
          *(_WORD *)&buf[18] = 2080;
          *(void *)&buf[20] = v8;
          _os_log_error_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_ERROR,  "%{public}s [%d]: Unable to convert ddt output to NSString: %s",  buf,  0x1Cu);
        }

        *__error() = v14;
      }

      if (byte_1000E7D31) {
        BOOL v16 = dword_1000E74E0 <= 3;
      }
      else {
        BOOL v16 = 0;
      }
      if (v16)
      {
        int v17 = *__error();
        id v18 = sub_10002EF3C(*v4);
        id v19 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"%s [%d]: Unable to convert ddt output to NSString: %s",  v18,  *v4,  v8);
        if (v19)
        {
          int v20 = v19;
          id v21 = v3;
          unint64_t v22 = CFStringGetCStringPtr(v19, 0x8000100u);
          if (v22)
          {
            id v23 = (char *)v22;
            id v24 = 0LL;
          }

          else
          {
            id v23 = (char *)calloc(0x400uLL, 1uLL);
            CFStringGetCString(v20, v23, 1024LL, 0x8000100u);
            id v24 = v23;
          }

          if (qword_1000E7D38) {
            double v37 = (FILE *)qword_1000E7D38;
          }
          else {
            double v37 = __stderrp;
          }
          fprintf(v37, "%s\n", v23);
          if (v24) {
            free(v24);
          }
          CFRelease(v20);
          id v3 = v21;
        }

        else
        {
          double v35 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v35, OS_LOG_TYPE_FAULT))
          {
            uint64_t v43 = sub_10002EF3C(*v4);
            int v44 = *v4;
            *(_DWORD *)buf = 136315650;
            *(void *)&uint8_t buf[4] = v43;
            *(_WORD *)&_BYTE buf[12] = 1024;
            *(_DWORD *)&buf[14] = v44;
            *(_WORD *)&buf[18] = 2080;
            *(void *)&buf[20] = v8;
            _os_log_fault_impl( (void *)&_mh_execute_header,  v35,  OS_LOG_TYPE_FAULT,  "Unable to format: %s [%d]: Unable to convert ddt output to NSString: %s",  buf,  0x1Cu);
          }

          if (qword_1000E7D38) {
            double v36 = (FILE *)qword_1000E7D38;
          }
          else {
            double v36 = __stderrp;
          }
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v36);
        }

        *__error() = v17;
      }
    }

    ssize_t v10 = read(v207, v8, vm_page_size - 1);
  }

  while (v10 > 0);
  waitpid(v191, 0LL, 0);
  free(v8);
  uint64_t v5 = (uint64_t)[v3 appendFormat:@"\n"];
  a1 = v195;
  if ((v11 & 1) != 0)
  {
    time_t v2 = v193;
    goto LABEL_64;
  }

LABEL_190:
  BOOL v134 = sub_10002578C(*v4);
  int v135 = *v4;
  if (v134)
  {
    if (v135 < 0)
    {
      if (byte_1000E7D30)
      {
        int v146 = *__error();
        uint64_t v147 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v147, OS_LOG_TYPE_ERROR)) {
          sub_10008AA68();
        }
        *__error() = v146;
      }

      if (!byte_1000E7D31 || dword_1000E74E0 > 3) {
        goto LABEL_307;
      }
      int v138 = *__error();
      uint64_t v148 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"Unable to gather ddt for resource exhaustion report, though process is alive");
      if (!v148)
      {
        uint64_t v149 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v149, OS_LOG_TYPE_FAULT)) {
          sub_10008AA3C();
        }
        goto LABEL_302;
      }

      goto LABEL_288;
    }

    if (byte_1000E7D30)
    {
      int v136 = *__error();
      int v137 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v137, OS_LOG_TYPE_ERROR)) {
        sub_10008A9CC();
      }
      *__error() = v136;
    }

    if (!byte_1000E7D31 || dword_1000E74E0 > 3) {
      goto LABEL_307;
    }
    int v138 = *__error();
    xpc_object_t v139 = sub_10002EF3C(*v4);
    int v140 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"%s [%d]: Unable to gather ddt for resource exhaustion report, though process is alive",  v139,  *v4);
    if (!v140)
    {
      int v141 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v141, OS_LOG_TYPE_FAULT)) {
        sub_10008A95C();
      }
      goto LABEL_302;
    }
  }

  else
  {
    if (v135 < 0)
    {
      if (byte_1000E7D30)
      {
        int v150 = *__error();
        __int16 v151 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v151, OS_LOG_TYPE_ERROR)) {
          sub_10008ABA0();
        }
        *__error() = v150;
      }

      if (!byte_1000E7D31 || dword_1000E74E0 > 3) {
        goto LABEL_307;
      }
      int v138 = *__error();
      uint64_t v148 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"Unable to gather ddt for resource exhaustion report; process is no longer around");
      if (!v148)
      {
        BOOL v152 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v152, OS_LOG_TYPE_FAULT)) {
          sub_10008AB74();
        }
        goto LABEL_302;
      }

      goto LABEL_288;
    }

    if (byte_1000E7D30)
    {
      int v142 = *__error();
      uint64_t v143 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v143, OS_LOG_TYPE_ERROR)) {
        sub_10008AB04();
      }
      *__error() = v142;
    }

    if (!byte_1000E7D31 || dword_1000E74E0 > 3) {
      goto LABEL_307;
    }
    int v138 = *__error();
    uint64_t v144 = sub_10002EF3C(*v4);
    int v140 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"%s [%d]: Unable to gather ddt for resource exhaustion report; process is no longer around",
             v144,
             *v4);
    if (!v140)
    {
      uint64_t v145 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v145, OS_LOG_TYPE_FAULT)) {
        sub_10008AA94();
      }
      goto LABEL_302;
    }
  }

LABEL_263:
  int v166 = v140;
  BOOL v167 = CFStringGetCStringPtr(v140, 0x8000100u);
  if (v167)
  {
    int v168 = (char *)v167;
    unsigned int v169 = 0LL;
  }

  else
  {
    int v168 = (char *)calloc(0x400uLL, 1uLL);
    CFStringGetCString(v166, v168, 1024LL, 0x8000100u);
    unsigned int v169 = v168;
  }

  if (qword_1000E7D38) {
    BOOL v170 = (FILE *)qword_1000E7D38;
  }
  else {
    BOOL v170 = __stderrp;
  }
  fprintf(v170, "%s\n", v168);
  if (v169) {
    free(v169);
  }
  int v171 = v166;
LABEL_297:
  CFRelease(v171);
LABEL_306:
  *__error() = v138;
LABEL_307:
  mach_port_name_t v185 = *(_DWORD *)(a1 + 100);
  if (v185 + 1 >= 2) {
    sub_100052FA4(*(void *)(a1 + 64), *(unsigned int *)(a1 + 96), v185);
  }
  uint64_t v186 = *(void *)(a1 + 56);
  if (v186)
  {
    if (v134) {
      uint64_t v187 = 0x2000000000LL;
    }
    else {
      uint64_t v187 = 0x1000000000LL;
    }
    (*(void (**)(uint64_t, uint64_t))(v186 + 16))(v186, v187);
  }
}

uint64_t sub_100052FA4(uint64_t a1, uint64_t a2, mach_port_name_t name)
{
  if (a1 == 2)
  {
    if ((a2 & 0x80000000) == 0)
    {
      if (byte_1000E7D30)
      {
        int v12 = *__error();
        int v13 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136446466;
          int v49 = sub_10002EF3C(a2);
          __int16 v50 = 1024;
          int v51 = a2;
          _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEFAULT,  "%{public}s [%d]: kqworkloop exhaustion: deallocating fatal port, allowing process to exit due to fatal resource exhaustion",  buf,  0x12u);
        }

        *__error() = v12;
      }

      if (byte_1000E7D31) {
        BOOL v14 = dword_1000E74E0 <= 2;
      }
      else {
        BOOL v14 = 0;
      }
      if (!v14) {
        return mach_port_deallocate(mach_task_self_, name);
      }
      int v8 = *__error();
      BOOL v15 = sub_10002EF3C(a2);
      ssize_t v10 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"%s [%d]: kqworkloop exhaustion: deallocating fatal port, allowing process to exit due to fatal resource exhaustion",  v15,  a2);
      if (!v10)
      {
        BOOL v16 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v16, OS_LOG_TYPE_FAULT)) {
          sub_10008B31C(a2);
        }
        goto LABEL_98;
      }

LABEL_77:
    double v37 = v28;
    double v38 = CFStringGetCStringPtr(v28, 0x8000100u);
    if (v38)
    {
      int v39 = (char *)v38;
      id v40 = 0LL;
    }

    else
    {
      int v39 = (char *)calloc(0x400uLL, 1uLL);
      CFStringGetCString(v37, v39, 1024LL, 0x8000100u);
      id v40 = v39;
    }

    if (qword_1000E7D38) {
      uint64_t v43 = (FILE *)qword_1000E7D38;
    }
    else {
      uint64_t v43 = __stderrp;
    }
    fprintf(v43, "%s\n", v39);
    if (v40) {
      free(v40);
    }
    int v42 = v37;
    goto LABEL_93;
  }

  if (a1 == 1)
  {
    if ((a2 & 0x80000000) == 0)
    {
      if (byte_1000E7D30)
      {
        int v17 = *__error();
        id v18 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136446466;
          int v49 = sub_10002EF3C(a2);
          __int16 v50 = 1024;
          int v51 = a2;
          _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_DEFAULT,  "%{public}s [%d]: port exhaustion: deallocating fatal port, allowing process to exit due to fatal resource exhaustion",  buf,  0x12u);
        }

        *__error() = v17;
      }

      if (byte_1000E7D31) {
        BOOL v19 = dword_1000E74E0 <= 2;
      }
      else {
        BOOL v19 = 0;
      }
      if (!v19) {
        return mach_port_deallocate(mach_task_self_, name);
      }
      int v8 = *__error();
      int v20 = sub_10002EF3C(a2);
      ssize_t v10 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"%s [%d]: port exhaustion: deallocating fatal port, allowing process to exit due to fatal resource exhaustion",  v20,  a2);
      if (!v10)
      {
        int v44 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v44, OS_LOG_TYPE_FAULT)) {
          sub_10008B284(a2);
        }
        goto LABEL_98;
      }

      goto LABEL_41;
    }

    if (byte_1000E7D30)
    {
      int v30 = *__error();
      id v31 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v31,  OS_LOG_TYPE_DEFAULT,  "port exhaustion: deallocating fatal port, allowing process to exit due to fatal resource exhaustion",  buf,  2u);
      }

      *__error() = v30;
    }

    if (byte_1000E7D31) {
      BOOL v32 = dword_1000E74E0 <= 2;
    }
    else {
      BOOL v32 = 0;
    }
    if (!v32) {
      return mach_port_deallocate(mach_task_self_, name);
    }
    int v8 = *__error();
    int v28 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"port exhaustion: deallocating fatal port, allowing process to exit due to fatal resource exhaustion");
    if (!v28)
    {
      double v33 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v33, OS_LOG_TYPE_FAULT)) {
        sub_10008B2F0();
      }
      goto LABEL_98;
    }

    goto LABEL_77;
  }

  if (a1) {
    return mach_port_deallocate(mach_task_self_, name);
  }
  if ((a2 & 0x80000000) == 0)
  {
    if (byte_1000E7D30)
    {
      int v5 = *__error();
      pid_t v6 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446466;
        int v49 = sub_10002EF3C(a2);
        __int16 v50 = 1024;
        int v51 = a2;
        _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "%{public}s [%d]: file descriptor exhaustion: deallocating fatal port, allowing process to exit due to fatal re source exhaustion",  buf,  0x12u);
      }

      *__error() = v5;
    }

    if (byte_1000E7D31) {
      BOOL v7 = dword_1000E74E0 <= 2;
    }
    else {
      BOOL v7 = 0;
    }
    if (!v7) {
      return mach_port_deallocate(mach_task_self_, name);
    }
    int v8 = *__error();
    ssize_t v9 = sub_10002EF3C(a2);
    ssize_t v10 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"%s [%d]: file descriptor exhaustion: deallocating fatal port, allowing process to exit due to fatal resource exhaustion",  v9,  a2);
    if (!v10)
    {
      char v11 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v11, OS_LOG_TYPE_FAULT)) {
        sub_10008B1EC(a2);
      }
LABEL_98:
      if (qword_1000E7D38) {
        uint64_t v46 = (FILE *)qword_1000E7D38;
      }
      else {
        uint64_t v46 = __stderrp;
      }
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v46);
      goto LABEL_102;
    }

    goto LABEL_41;
  }

  if (byte_1000E7D30)
  {
    int v34 = *__error();
    double v35 = (os_log_s *)sub_10002EFA0();
    if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v35,  OS_LOG_TYPE_DEFAULT,  "file descriptor exhaustion: deallocating fatal port, allowing process to exit due to fatal resource exhaustion",  buf,  2u);
    }

    *__error() = v34;
  }

  if (byte_1000E7D31) {
    BOOL v36 = dword_1000E74E0 <= 2;
  }
  else {
    BOOL v36 = 0;
  }
  if (v36)
  {
    int v8 = *__error();
    int v28 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"file descriptor exhaustion: deallocating fatal port, allowing process to exit due to fatal resource exhaustion");
    if (!v28)
    {
      int v45 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v45, OS_LOG_TYPE_FAULT)) {
        sub_10008B258();
      }
      goto LABEL_98;
    }

    goto LABEL_77;
  }

  return mach_port_deallocate(mach_task_self_, name);
}

          if (qword_1000E7D38) {
            id v58 = (FILE *)qword_1000E7D38;
          }
          else {
            id v58 = __stderrp;
          }
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v58);
          goto LABEL_81;
        }

        if (byte_1000E7D30)
        {
          id v31 = *__error();
          BOOL v32 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v32, OS_LOG_TYPE_DEBUG))
          {
            double v63 = *(void *)(a1 + 56);
            int v64 = *(void *)(a1 + 48) - v84.st_ctimespec.tv_sec;
            *(_DWORD *)buf = 136315650;
            BOOL v81 = __str;
            int v82 = 2048;
            *(void *)uint64_t v83 = v64;
            *(_WORD *)&v83[8] = 2048;
            *(void *)&v83[10] = v63;
            _os_log_debug_impl( (void *)&_mh_execute_header,  v32,  OS_LOG_TYPE_DEBUG,  "Not unlinking %s which is %lds old (<%lds)",  buf,  0x20u);
          }

          *__error() = v31;
        }

        if (byte_1000E7D31) {
          double v33 = dword_1000E74E0 <= 0;
        }
        else {
          double v33 = 0;
        }
        if (!v33) {
          continue;
        }
        ssize_t v10 = *__error();
        char v11 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"Not unlinking %s which is %lds old (<%lds)",  __str,  *(void *)(a1 + 48) - v84.st_ctimespec.tv_sec,  *(void *)(a1 + 56));
        if (!v11)
        {
          int v34 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v34, OS_LOG_TYPE_FAULT))
          {
            double v35 = *(void *)(a1 + 56);
            BOOL v36 = *(void *)(a1 + 48) - v84.st_ctimespec.tv_sec;
            *(_DWORD *)buf = 136315650;
            BOOL v81 = __str;
            int v82 = 2048;
            *(void *)uint64_t v83 = v36;
            *(_WORD *)&v83[8] = 2048;
            *(void *)&v83[10] = v35;
            double v37 = buf;
            double v38 = v34;
            int v39 = "Unable to format: Not unlinking %s which is %lds old (<%lds)";
            id v40 = 32;
            goto LABEL_86;
          }

    double v38 = v13;
    CStringPtr = CFStringGetCStringPtr(v13, 0x8000100u);
    if (CStringPtr)
    {
      id v40 = (char *)CStringPtr;
      int v41 = 0LL;
    }

    else
    {
      id v40 = (char *)calloc(0x400uLL, 1uLL);
      CFStringGetCString(v38, v40, 1024LL, 0x8000100u);
      int v41 = v40;
    }

    if (qword_1000E7D38) {
      int v42 = (FILE *)qword_1000E7D38;
    }
    else {
      int v42 = __stderrp;
    }
    fprintf(v42, "%s\n", v40);
    if (v41) {
      free(v41);
    }
    uint64_t v43 = v38;
    goto LABEL_93;
  }

  if ((*(_DWORD *)(v1 + 72) & 0x80000000) != 0)
  {
    if (byte_1000E7D30)
    {
      BOOL v32 = *__error();
      double v33 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v33, OS_LOG_TYPE_DEBUG)) {
        sub_100090BC4();
      }
      *__error() = v32;
    }

    if (byte_1000E7D31) {
      int v34 = dword_1000E74E0 <= 0;
    }
    else {
      int v34 = 0;
    }
    if (!v34) {
      return;
    }
    int v12 = *__error();
    int v13 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"Lost race: already done sampling");
    if (!v13)
    {
      double v35 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v35, OS_LOG_TYPE_FAULT)) {
        sub_100090B98();
      }
      goto LABEL_98;
    }

    goto LABEL_77;
  }

  if (byte_1000E7D30)
  {
    BOOL v15 = *__error();
    BOOL v16 = (os_log_s *)sub_10002EFA0();
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG)) {
      sub_100090B2C();
    }
    *__error() = v15;
  }

  if (byte_1000E7D31) {
    int v17 = dword_1000E74E0 <= 0;
  }
  else {
    int v17 = 0;
  }
  if (v17)
  {
    int v12 = *__error();
    id v18 = sub_10002EF3C(*(_DWORD *)(*v2 + 72));
    BOOL v19 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"%s [%d]: Lost race: already done sampling",  v18,  *(unsigned int *)(*v2 + 72));
    if (v19)
    {
LABEL_44:
      id v24 = v19;
      int v25 = CFStringGetCStringPtr(v19, 0x8000100u);
      if (v25)
      {
        id v26 = (char *)v25;
        BOOL v27 = 0LL;
      }

      else
      {
        id v26 = (char *)calloc(0x400uLL, 1uLL);
        CFStringGetCString(v24, v26, 1024LL, 0x8000100u);
        BOOL v27 = v26;
      }

      if (qword_1000E7D38) {
        int v44 = (FILE *)qword_1000E7D38;
      }
      else {
        int v44 = __stderrp;
      }
      fprintf(v44, "%s\n", v26);
      if (v27) {
        free(v27);
      }
      uint64_t v43 = v24;
LABEL_93:
      CFRelease(v43);
LABEL_102:
      *__error() = v12;
      return;
    }

    int v20 = (os_log_s *)sub_10002EFA0();
    if (os_log_type_enabled(v20, OS_LOG_TYPE_FAULT)) {
      sub_100090AC0();
    }
LABEL_98:
    if (qword_1000E7D38) {
      pid_t v47 = (FILE *)qword_1000E7D38;
    }
    else {
      pid_t v47 = __stderrp;
    }
    fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v47);
    goto LABEL_102;
  }

void sub_1000536CC(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 80);
  if (v2 == 2)
  {
    char v3 = *(_BYTE *)(a1 + 88);
    uint64_t v4 = "ExhaustionFatal_KQWorkLoops";
    int v5 = "Exhaustion_KQWorkLoops";
  }

  else if (v2 == 1)
  {
    char v3 = *(_BYTE *)(a1 + 88);
    uint64_t v4 = "ExhaustionFatal_Ports";
    int v5 = "Exhaustion_Ports";
  }

  else
  {
    if (v2)
    {
      pid_t v6 = 0LL;
      goto LABEL_11;
    }

    char v3 = *(_BYTE *)(a1 + 88);
    uint64_t v4 = "ExhaustionFatal_FileDescriptors";
    int v5 = "Exhaustion_FileDescriptors";
  }

  if ((v3 & 1) != 0) {
    pid_t v6 = v4;
  }
  else {
    pid_t v6 = v5;
  }
LABEL_11:
  localtime_r((const time_t *)(a1 + 96), &v155);
  strftime(v164, 0x40uLL, "%F_%H-%M-%S", &v155);
  BOOL v7 = +[NSString stringWithFormat:]( NSString,  "stringWithFormat:",  @"/private/var/db/spindump/%s_%@_%s.txt",  v6,  objc_msgSend( objc_msgSend(*(id *)(a1 + 32), "lastPathComponent"),  "stringByReplacingOccurrencesOfString:withString:",  @" ",  @"_"),  v164);
  uid_t v8 = geteuid();
  int v9 = sub_10004CDE4(v7, 0LL, 0LL, 1538, v8, 0x1A4u, 0LL);
  if ((v9 & 0x80000000) == 0)
  {
    int v10 = v9;
    char v11 = (int *)dup(v9);
    int v12 = fdopen(v10, "w");
    if (v12)
    {
      int v13 = v12;
      id v14 = -[SASampleStore initForLiveSampling](objc_alloc(&OBJC_CLASS___SASampleStore), "initForLiveSampling");
      sub_1000571C4( v14,  (byte_1000E7D44 >> 3) & 1,  (byte_1000E7D44 >> 2) & 1,  (byte_1000E7D44 >> 4) & 1);
      [v14 addKCDataStackshot:*(void *)(a1 + 48)];
      BOOL v15 = (int *)(a1 + 120);
      [v14 setTargetProcessId:*(unsigned int *)(a1 + 120)];
      [v14 postprocess];
      if (*(void *)(a1 + 56)) {
        BOOL v16 = *(const __CFString **)(a1 + 56);
      }
      else {
        BOOL v16 = @"none";
      }
      [v14 setActionTaken:v16];
      unint64_t v17 = *(void *)(a1 + 80);
      if (v17 <= 2) {
        [v14 setEvent:off_1000D9508[v17]];
      }
      if ((*(void *)(a1 + 88) & 1LL) != 0) {
        id v18 = @" (fatal)";
      }
      else {
        id v18 = &stru_1000DCBB0;
      }
      [v14 setEventNote:+[NSString stringWithFormat:]( NSString, "stringWithFormat:", @"%llu allocated, exceeding limit of %llu%@", *(void *)(a1 + 104), *(void *)(a1 + 112), v18)];
      if ((*(void *)(a1 + 88) & 1LL) != 0) {
        BOOL v19 = @"Process killed";
      }
      else {
        BOOL v19 = @"none";
      }
      [v14 setActionTaken:v19];
      int v20 = -[SASamplePrinter initWithSampleStore:]( objc_alloc(&OBJC_CLASS___SASamplePrinter),  "initWithSampleStore:",  v14);
      objc_msgSend(-[SASamplePrinter options](v20, "options"), "setDisplayHeader:", 1);
      objc_msgSend(-[SASamplePrinter options](v20, "options"), "setDisplayBody:", 0);
      objc_msgSend(-[SASamplePrinter options](v20, "options"), "setDisplayFooter:", 0);
      -[SASamplePrinter setIncidentUUID:](v20, "setIncidentUUID:", +[NSUUID UUID](&OBJC_CLASS___NSUUID, "UUID"));
      -[SASamplePrinter printToStream:](v20, "printToStream:", v13);
      fputc(10, v13);
      id v21 = [*(id *)(a1 + 64) lengthOfBytesUsingEncoding:4];
      if (!v21)
      {
LABEL_207:
        objc_msgSend(-[SASamplePrinter options](v20, "options"), "setDisplayHeader:", 0);
        objc_msgSend(-[SASamplePrinter options](v20, "options"), "setDisplayBody:", 1);
        objc_msgSend(-[SASamplePrinter options](v20, "options"), "setDisplayFooter:", 1);
        -[SASamplePrinter printToStream:](v20, "printToStream:", v13);

        fwrite("\n\n", 2uLL, 1uLL, v13);
        [v14 setCustomOutput:*(void *)(a1 + 64)];
        [v14 saveBinaryFormatToStream:v13];

        fclose(v13);
        if ((_DWORD)v11 != -1)
        {
          sub_1000555AC(v11);
          close((int)v11);
        }

        if (byte_1000E7D30)
        {
          int v134 = *__error();
          int v135 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v135, OS_LOG_TYPE_DEFAULT))
          {
            id v136 = [*(id *)(a1 + 32) lastPathComponent];
            int v137 = *(_DWORD *)(a1 + 120);
            *(_DWORD *)buf = 138413058;
            id v157 = v136;
            __int16 v158 = 1024;
            int v159 = v137;
            __int16 v160 = 2082;
            BOOL v161 = v6;
            __int16 v162 = 2112;
            int v163 = v7;
            _os_log_impl( (void *)&_mh_execute_header,  v135,  OS_LOG_TYPE_DEFAULT,  "%@ [%d] Saved %{public}s report to %@",  buf,  0x26u);
          }

          *__error() = v134;
        }

        if (byte_1000E7D31 && dword_1000E74E0 <= 2)
        {
          int v138 = *__error();
          xpc_object_t v139 = CFStringCreateWithFormat( kCFAllocatorDefault,  0,  @"%@ [%d] Saved %s report to %@",  [*(id *)(a1 + 32) lastPathComponent],  *(unsigned int *)(a1 + 120),  v6,  v7);
          if (v139)
          {
            int v140 = v139;
            CStringPtr = CFStringGetCStringPtr(v139, 0x8000100u);
            if (CStringPtr)
            {
              int v142 = (char *)CStringPtr;
              uint64_t v143 = 0LL;
            }

            else
            {
              int v142 = (char *)calloc(0x400uLL, 1uLL);
              CFStringGetCString(v140, v142, 1024LL, 0x8000100u);
              uint64_t v143 = v142;
            }

            if (qword_1000E7D38) {
              int v146 = (FILE *)qword_1000E7D38;
            }
            else {
              int v146 = __stderrp;
            }
            fprintf(v146, "%s\n", v142);
            if (v143) {
              free(v143);
            }
            CFRelease(v140);
          }

          else
          {
            uint64_t v144 = (os_log_s *)sub_10002EFA0();
            if (os_log_type_enabled(v144, OS_LOG_TYPE_FAULT))
            {
              id v148 = [*(id *)(a1 + 32) lastPathComponent];
              int v149 = *(_DWORD *)(a1 + 120);
              *(_DWORD *)buf = 138413058;
              id v157 = v148;
              __int16 v158 = 1024;
              int v159 = v149;
              __int16 v160 = 2080;
              BOOL v161 = v6;
              __int16 v162 = 2112;
              int v163 = v7;
              _os_log_fault_impl( (void *)&_mh_execute_header,  v144,  OS_LOG_TYPE_FAULT,  "Unable to format: %@ [%d] Saved %s report to %@",  buf,  0x26u);
            }

            if (qword_1000E7D38) {
              uint64_t v145 = (FILE *)qword_1000E7D38;
            }
            else {
              uint64_t v145 = __stderrp;
            }
            fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v145);
          }

          *__error() = v138;
        }

        sub_100054BA0(v6, 3600LL);
        uint64_t v147 = *(void *)(a1 + 72);
        if (v147)
        {
          int v111 = *(void (**)(void))(v147 + 16);
          goto LABEL_234;
        }

        goto LABEL_235;
      }

      size_t v22 = (size_t)v21;
      unsigned int v154 = v11;
      id v23 = malloc((size_t)v21);
      if ([*(id *)(a1 + 64) getCString:v23 maxLength:v22 encoding:4])
      {
        size_t v24 = fwrite(v23, v22, 1uLL, v13);
        int v25 = v23;
        if (v24 != 1)
        {
          if ((*v15 & 0x80000000) == 0)
          {
            if (byte_1000E7D30)
            {
              int v26 = *__error();
              BOOL v27 = (os_log_s *)sub_10002EFA0();
              if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR)) {
                sub_10008B7FC();
              }
              *__error() = v26;
              int v25 = v23;
            }

            if (!byte_1000E7D31 || dword_1000E74E0 > 3) {
              goto LABEL_206;
            }
            int v153 = v25;
            int v152 = *__error();
            int v28 = sub_10002EF3C(*v15);
            uint64_t v29 = *v15;
            uint64_t v30 = ferror(v13);
            id v31 = strerror(v30);
            BOOL v32 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"%s [%d]: Unable to write ddt/lsof output to buffer: %d (%s)",  v28,  v29,  v30,  v31);
            if (!v32)
            {
              double v33 = (os_log_s *)sub_10002EFA0();
              if (os_log_type_enabled(v33, OS_LOG_TYPE_FAULT)) {
                goto LABEL_159;
              }
              goto LABEL_160;
            }

            goto LABEL_95;
          }

          if (byte_1000E7D30)
          {
            int v94 = *__error();
            int v95 = (os_log_s *)sub_10002EFA0();
            if (os_log_type_enabled(v95, OS_LOG_TYPE_ERROR)) {
              sub_10008B8E0(v13);
            }
            *__error() = v94;
            int v25 = v23;
          }

          if (!byte_1000E7D31 || dword_1000E74E0 > 3) {
            goto LABEL_206;
          }
          int v96 = *__error();
          uint64_t v97 = ferror(v13);
          __int128 v98 = strerror(v97);
          uint64_t v99 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"Unable to write ddt/lsof output to buffer: %d (%s)",  v97,  v98);
          if (!v99)
          {
            BOOL v124 = (os_log_s *)sub_10002EFA0();
            if (os_log_type_enabled(v124, OS_LOG_TYPE_FAULT)) {
              sub_10008B874(v13);
            }
            if (qword_1000E7D38) {
              int v125 = (FILE *)qword_1000E7D38;
            }
            else {
              int v125 = __stderrp;
            }
            fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v125);
            goto LABEL_205;
          }

          uint64_t v100 = v99;
          int v152 = v96;
          int v153 = v25;
          int v101 = CFStringGetCStringPtr(v99, 0x8000100u);
          if (v101)
          {
            int v102 = (char *)v101;
            int v103 = 0LL;
LABEL_190:
            if (qword_1000E7D38) {
              int v131 = (FILE *)qword_1000E7D38;
            }
            else {
              int v131 = __stderrp;
            }
            fprintf(v131, "%s\n", v102);
            if (!v103) {
              goto LABEL_201;
            }
            CFAllocatorRef v132 = (CFAllocatorRef)v103;
LABEL_200:
            free(v132);
LABEL_201:
            __int16 v129 = v100;
            goto LABEL_202;
          }

          goto LABEL_189;
        }

LABEL_206:
        free(v25);
        char v11 = (int *)v154;
        goto LABEL_207;
      }

      int v153 = v23;
      id v64 = [*(id *)(a1 + 64) dataUsingEncoding:4 allowLossyConversion:1];
      if (v64)
      {
        int v25 = v23;
        if (fwrite([v64 bytes], (size_t)objc_msgSend(v64, "length"), 1uLL, v13) == 1) {
          goto LABEL_206;
        }
        if ((*v15 & 0x80000000) == 0)
        {
          if (byte_1000E7D30)
          {
            int v65 = *__error();
            int v66 = (os_log_s *)sub_10002EFA0();
            if (os_log_type_enabled(v66, OS_LOG_TYPE_ERROR)) {
              sub_10008B7FC();
            }
            *__error() = v65;
            int v25 = v23;
          }

          if (!byte_1000E7D31 || dword_1000E74E0 > 3) {
            goto LABEL_206;
          }
          int v152 = *__error();
          int v67 = sub_10002EF3C(*v15);
          uint64_t v68 = *v15;
          uint64_t v69 = ferror(v13);
          int v70 = strerror(v69);
          id v71 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"%s [%d]: Unable to write ddt/lsof output to buffer: %d (%s)",  v67,  v68,  v69,  v70);
          if (!v71)
          {
            uint64_t v122 = (os_log_s *)sub_10002EFA0();
            if (os_log_type_enabled(v122, OS_LOG_TYPE_FAULT)) {
LABEL_159:
            }
              sub_10008B784();
LABEL_160:
            if (qword_1000E7D38) {
              uint64_t v123 = (FILE *)qword_1000E7D38;
            }
            else {
              uint64_t v123 = __stderrp;
            }
            fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v123);
            goto LABEL_203;
          }

          id v72 = v71;
          int v73 = CFStringGetCStringPtr(v71, 0x8000100u);
          if (v73)
          {
            int v74 = (char *)v73;
            CFAllocatorRef alloc = 0LL;
          }

          else
          {
            int v74 = (char *)calloc(0x400uLL, 1uLL);
            CFStringGetCString(v72, v74, 1024LL, 0x8000100u);
            CFAllocatorRef alloc = (CFAllocatorRef)v74;
          }

          if (qword_1000E7D38) {
            int v128 = (FILE *)qword_1000E7D38;
          }
          else {
            int v128 = __stderrp;
          }
          fprintf(v128, "%s\n", v74);
          CFAllocatorRef v120 = alloc;
          if (!alloc) {
            goto LABEL_182;
          }
          goto LABEL_181;
        }

        if (byte_1000E7D30)
        {
          int v112 = *__error();
          uint64_t v113 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v113, OS_LOG_TYPE_ERROR)) {
            sub_10008B8E0(v13);
          }
          *__error() = v112;
        }

        if (!byte_1000E7D31 || dword_1000E74E0 > 3) {
          goto LABEL_206;
        }
        int v152 = *__error();
        uint64_t v114 = ferror(v13);
        id v115 = strerror(v114);
        uint64_t v116 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"Unable to write ddt/lsof output to buffer: %d (%s)",  v114,  v115);
        if (v116)
        {
          uint64_t v100 = v116;
          BOOL v117 = CFStringGetCStringPtr(v116, 0x8000100u);
          if (v117)
          {
            int v118 = (char *)v117;
            CFAllocatorRef alloca = 0LL;
          }

          else
          {
            int v118 = (char *)calloc(0x400uLL, 1uLL);
            CFStringGetCString(v100, v118, 1024LL, 0x8000100u);
            CFAllocatorRef alloca = (CFAllocatorRef)v118;
          }

          if (qword_1000E7D38) {
            BOOL v133 = (FILE *)qword_1000E7D38;
          }
          else {
            BOOL v133 = __stderrp;
          }
          fprintf(v133, "%s\n", v118);
          CFAllocatorRef v132 = alloca;
          if (!alloca) {
            goto LABEL_201;
          }
          goto LABEL_200;
        }

        uint64_t v130 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v130, OS_LOG_TYPE_FAULT)) {
          sub_10008B874(v13);
        }
        if (qword_1000E7D38) {
          int v127 = (FILE *)qword_1000E7D38;
        }
        else {
          int v127 = __stderrp;
        }
      }

      else
      {
        if ((*v15 & 0x80000000) == 0)
        {
          if (byte_1000E7D30)
          {
            int v84 = *__error();
            int v85 = (os_log_s *)sub_10002EFA0();
            if (os_log_type_enabled(v85, OS_LOG_TYPE_ERROR)) {
              sub_10008B9BC();
            }
            *__error() = v84;
          }

          int v25 = v23;
          if (!byte_1000E7D31 || dword_1000E74E0 > 3) {
            goto LABEL_206;
          }
          int v152 = *__error();
          int v86 = sub_10002EF3C(*v15);
          BOOL v32 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"%s [%d]: Unable to convert ddt/lsof output to buffer",  v86,  *v15);
          if (!v32)
          {
            double v121 = (os_log_s *)sub_10002EFA0();
            if (os_log_type_enabled(v121, OS_LOG_TYPE_FAULT)) {
              sub_10008B94C();
            }
            goto LABEL_160;
          }

LABEL_95:
          id v72 = v32;
          int v87 = CFStringGetCStringPtr(v32, 0x8000100u);
          if (v87)
          {
            uint64_t v88 = (char *)v87;
            uint64_t v89 = 0LL;
          }

          else
          {
            uint64_t v88 = (char *)calloc(0x400uLL, 1uLL);
            CFStringGetCString(v72, v88, 1024LL, 0x8000100u);
            uint64_t v89 = v88;
          }

          if (qword_1000E7D38) {
            int64_t v119 = (FILE *)qword_1000E7D38;
          }
          else {
            int64_t v119 = __stderrp;
          }
          fprintf(v119, "%s\n", v88);
          if (!v89) {
            goto LABEL_182;
          }
          CFAllocatorRef v120 = (CFAllocatorRef)v89;
LABEL_181:
          free(v120);
LABEL_182:
          __int16 v129 = v72;
LABEL_202:
          CFRelease(v129);
LABEL_203:
          int v25 = v153;
          goto LABEL_204;
        }

        if (byte_1000E7D30)
        {
          int v104 = *__error();
          uint64_t v105 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v105, OS_LOG_TYPE_ERROR)) {
            sub_10008BA58();
          }
          *__error() = v104;
        }

        int v25 = v23;
        if (!byte_1000E7D31 || dword_1000E74E0 > 3) {
          goto LABEL_206;
        }
        int v152 = *__error();
        uint64_t v106 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"Unable to convert ddt/lsof output to buffer");
        if (v106)
        {
          uint64_t v100 = v106;
          int v107 = CFStringGetCStringPtr(v106, 0x8000100u);
          if (v107)
          {
            int v102 = (char *)v107;
            int v103 = 0LL;
            goto LABEL_190;
          }

LABEL_189:
          int v102 = (char *)calloc(0x400uLL, 1uLL);
          CFStringGetCString(v100, v102, 1024LL, 0x8000100u);
          int v103 = v102;
          goto LABEL_190;
        }

        uint64_t v126 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v126, OS_LOG_TYPE_FAULT)) {
          sub_10008BA2C();
        }
        if (qword_1000E7D38) {
          int v127 = (FILE *)qword_1000E7D38;
        }
        else {
          int v127 = __stderrp;
        }
      }

      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v127);
LABEL_204:
      int v96 = v152;
LABEL_205:
      *__error() = v96;
      goto LABEL_206;
    }

    int v45 = (int *)(a1 + 120);
    if ((*(_DWORD *)(a1 + 120) & 0x80000000) == 0)
    {
      if (byte_1000E7D30)
      {
        int v46 = *__error();
        pid_t v47 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v47, OS_LOG_TYPE_ERROR)) {
          sub_10008B61C();
        }
        *__error() = v46;
      }

      if (byte_1000E7D31 && dword_1000E74E0 <= 3)
      {
        int v37 = *__error();
        pid_t v48 = sub_10002EF3C(*v45);
        uint64_t v49 = *v45;
        uint64_t v50 = *__error();
        int v51 = __error();
        char v52 = strerror(*v51);
        uint64_t v43 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"%s [%d]: could not fdopen log file %@: %d (%s)",  v48,  v49,  v7,  v50,  v52);
        if (v43) {
          goto LABEL_55;
        }
        int v92 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v92, OS_LOG_TYPE_FAULT)) {
          sub_10008B59C();
        }
        goto LABEL_134;
      }

      goto LABEL_139;
    }

    if (byte_1000E7D30)
    {
      int v75 = *__error();
      id v76 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v76, OS_LOG_TYPE_ERROR)) {
        sub_10008B710();
      }
      *__error() = v75;
    }

    if (!byte_1000E7D31 || dword_1000E74E0 > 3) {
      goto LABEL_139;
    }
    int v37 = *__error();
    uint64_t v77 = *__error();
    uint64_t v78 = __error();
    BOOL v79 = strerror(*v78);
    double v62 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"could not fdopen log file %@: %d (%s)",  v7,  v77,  v79);
    if (!v62)
    {
      unint64_t v108 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v108, OS_LOG_TYPE_FAULT)) {
        sub_10008B69C();
      }
      goto LABEL_134;
    }

LABEL_85:
    int v80 = v62;
    BOOL v81 = CFStringGetCStringPtr(v62, 0x8000100u);
    if (v81)
    {
      int v82 = (char *)v81;
      uint64_t v83 = 0LL;
    }

    else
    {
      int v82 = (char *)calloc(0x400uLL, 1uLL);
      CFStringGetCString(v80, v82, 1024LL, 0x8000100u);
      uint64_t v83 = v82;
    }

    if (qword_1000E7D38) {
      BOOL v93 = (FILE *)qword_1000E7D38;
    }
    else {
      BOOL v93 = __stderrp;
    }
    fprintf(v93, "%s\n", v82);
    if (v83) {
      free(v83);
    }
    int v91 = v80;
    goto LABEL_113;
  }

  int v34 = (int *)(a1 + 120);
  if ((*(_DWORD *)(a1 + 120) & 0x80000000) != 0)
  {
    if (byte_1000E7D30)
    {
      int v57 = *__error();
      id v58 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v58, OS_LOG_TYPE_ERROR)) {
        sub_10008B528();
      }
      *__error() = v57;
    }

    if (!byte_1000E7D31 || dword_1000E74E0 > 3) {
      goto LABEL_139;
    }
    int v37 = *__error();
    uint64_t v59 = *__error();
    double v60 = __error();
    uint64_t v61 = strerror(*v60);
    double v62 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"could not open log file %@: %d (%s)", v7, v59, v61);
    if (!v62)
    {
      double v63 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v63, OS_LOG_TYPE_FAULT)) {
        sub_10008B4B4();
      }
      goto LABEL_134;
    }

    goto LABEL_85;
  }

  if (byte_1000E7D30)
  {
    int v35 = *__error();
    BOOL v36 = (os_log_s *)sub_10002EFA0();
    if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR)) {
      sub_10008B434();
    }
    *__error() = v35;
  }

  if (byte_1000E7D31 && dword_1000E74E0 <= 3)
  {
    int v37 = *__error();
    double v38 = sub_10002EF3C(*v34);
    uint64_t v39 = *v34;
    uint64_t v40 = *__error();
    int v41 = __error();
    int v42 = strerror(*v41);
    uint64_t v43 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"%s [%d]: could not open log file %@: %d (%s)",  v38,  v39,  v7,  v40,  v42);
    if (v43)
    {
LABEL_55:
      id v53 = v43;
      uint64_t v54 = CFStringGetCStringPtr(v43, 0x8000100u);
      if (v54)
      {
        int v55 = (char *)v54;
        id v56 = 0LL;
      }

      else
      {
        int v55 = (char *)calloc(0x400uLL, 1uLL);
        CFStringGetCString(v53, v55, 1024LL, 0x8000100u);
        id v56 = v55;
      }

      if (qword_1000E7D38) {
        uint64_t v90 = (FILE *)qword_1000E7D38;
      }
      else {
        uint64_t v90 = __stderrp;
      }
      fprintf(v90, "%s\n", v55);
      if (v56) {
        free(v56);
      }
      int v91 = v53;
LABEL_113:
      CFRelease(v91);
LABEL_138:
      *__error() = v37;
      goto LABEL_139;
    }

    int v44 = (os_log_s *)sub_10002EFA0();
    if (os_log_type_enabled(v44, OS_LOG_TYPE_FAULT)) {
      sub_10008B3B4();
    }
LABEL_134:
    if (qword_1000E7D38) {
      BOOL v109 = (FILE *)qword_1000E7D38;
    }
    else {
      BOOL v109 = __stderrp;
    }
    fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v109);
    goto LABEL_138;
  }

      uint64_t v50 = v6;
      int v51 = CFStringGetCStringPtr(v6, 0x8000100u);
      if (v51)
      {
        char v52 = (char *)v51;
        id v53 = 0LL;
      }

      else
      {
        char v52 = (char *)calloc(0x400uLL, 1uLL);
        CFStringGetCString(v50, v52, 1024LL, 0x8000100u);
        id v53 = v52;
      }

      if (qword_1000E7D38) {
        uint64_t v54 = (FILE *)qword_1000E7D38;
      }
      else {
        uint64_t v54 = __stderrp;
      }
      fprintf(v54, "%s\n", v52);
      if (v53) {
        free(v53);
      }
      CFRelease(v50);
      goto LABEL_115;
    }
  }

  else
  {
    strcpy((char *)buf, "/var/tmp/spindump-stuck-stackshot.");
    int v96 = time(0LL);
    localtime_r(&v96, &v97);
    int v25 = strftime((char *)&buf[34], 0x3DEuLL, "%Y-%m-%d-%T", &v97);
    int v26 = v25 + 34;
    if (v25 + 34 >= 0x400)
    {
      int v85 = *__error();
      int v86 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v86, OS_LOG_TYPE_FAULT)) {
        sub_10008DAF8();
      }
      *__error() = v85;
      if (byte_1000E7D31 && dword_1000E74E0 <= 4)
      {
        int v87 = *__error();
        uint64_t v88 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"filePath %s cut off with date (needed %zu chars)",  buf,  v26);
        if (v88)
        {
          uint64_t v89 = v88;
          uint64_t v90 = CFStringGetCStringPtr(v88, 0x8000100u);
          if (v90)
          {
            int v91 = (char *)v90;
            int v92 = 0LL;
          }

          else
          {
            int v91 = (char *)calloc(0x400uLL, 1uLL);
            CFStringGetCString(v89, v91, 1024LL, 0x8000100u);
            int v92 = v91;
          }

          if (qword_1000E7D38) {
            int v95 = (FILE *)qword_1000E7D38;
          }
          else {
            int v95 = __stderrp;
          }
          fprintf(v95, "%s\n", v91);
          if (v92) {
            free(v92);
          }
          CFRelease(v89);
        }

        else
        {
          BOOL v93 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v93, OS_LOG_TYPE_FAULT)) {
            sub_10008DA90();
          }
          if (qword_1000E7D38) {
            int v94 = (FILE *)qword_1000E7D38;
          }
          else {
            int v94 = __stderrp;
          }
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v94);
        }

        *__error() = v87;
      }
    }

    BOOL v27 = getpid();
    snprintf((char *)&buf[v26], 990 - v25, ".%d.buf", v27);
    int v28 = fopen((const char *)buf, "w");
    if (v28)
    {
      uint64_t v29 = v28;
      uint64_t v30 = stackshot_config_create(v28);
      stackshot_config_set_flags(v30, 1302536203LL);
      id v31 = sub_10006BCB4(v30, 0LL);
      BOOL v32 = v31;
      if (v31 && -[NSData length](v31, "length"))
      {
        double v33 = fwrite(-[NSData bytes](v32, "bytes"), -[NSData length](v32, "length"), 1uLL, v29);

        stackshot_config_dealloc(v30);
        if (v33 == 1)
        {
          fclose(v29);
          if (byte_1000E7D30)
          {
            int v34 = *__error();
            int v35 = (os_log_s *)sub_10002EFA0();
            if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)__int128 v98 = 136315138;
              uint64_t v99 = buf;
              _os_log_impl( (void *)&_mh_execute_header,  v35,  OS_LOG_TYPE_DEFAULT,  "spindump-stuck: Wrote stackshot to %s",  v98,  0xCu);
            }

            *__error() = v34;
          }

          if (byte_1000E7D31 && dword_1000E74E0 <= 2)
          {
            int v5 = *__error();
            pid_t v6 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"spindump-stuck: Wrote stackshot to %s", buf);
            if (!v6)
            {
              BOOL v36 = (os_log_s *)sub_10002EFA0();
              if (os_log_type_enabled(v36, OS_LOG_TYPE_FAULT)) {
                sub_10008D93C();
              }
              goto LABEL_111;
            }

            goto LABEL_85;
          }
        }

        else
        {
          if (byte_1000E7D30)
          {
            int v55 = *__error();
            id v56 = (os_log_s *)sub_10002EFA0();
            int v57 = (int)v56;
            if (os_log_type_enabled(v56, OS_LOG_TYPE_ERROR)) {
              sub_10008DA18((int)buf, v29, v57, v58, v59, v60, v61, v62);
            }
            *__error() = v55;
          }

          if (byte_1000E7D31 && dword_1000E74E0 <= 3)
          {
            double v63 = *__error();
            id v64 = ferror(v29);
            int v65 = strerror(v64);
            int v66 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"Unable to write stackshot to %s: %d (%s)",  buf,  v64,  v65);
            if (v66)
            {
              int v67 = v66;
              uint64_t v68 = CFStringGetCStringPtr(v66, 0x8000100u);
              if (v68)
              {
                uint64_t v69 = (char *)v68;
                int v70 = 0LL;
              }

              else
              {
                uint64_t v69 = (char *)calloc(0x400uLL, 1uLL);
                CFStringGetCString(v67, v69, 1024LL, 0x8000100u);
                int v70 = v69;
              }

              if (qword_1000E7D38) {
                int v84 = (FILE *)qword_1000E7D38;
              }
              else {
                int v84 = __stderrp;
              }
              fprintf(v84, "%s\n", v69);
              if (v70) {
                free(v70);
              }
              CFRelease(v67);
            }

            else
            {
              id v76 = (os_log_s *)sub_10002EFA0();
              uint64_t v77 = (int)v76;
              if (os_log_type_enabled(v76, OS_LOG_TYPE_FAULT)) {
                sub_10008D9A0((int)buf, v29, v77, v78, v79, v80, v81, v82);
              }
              if (qword_1000E7D38) {
                uint64_t v83 = (FILE *)qword_1000E7D38;
              }
              else {
                uint64_t v83 = __stderrp;
              }
              fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v83);
            }

            *__error() = v63;
          }

          fclose(v29);
        }
      }

      else
      {
        if (byte_1000E7D30)
        {
          int v37 = *__error();
          double v38 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR)) {
            sub_10008D910();
          }
          *__error() = v37;
        }

        if (byte_1000E7D31 && dword_1000E74E0 <= 3)
        {
          uint64_t v39 = *__error();
          uint64_t v40 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"spindump-stuck: Unable to take stackshot");
          if (v40)
          {
            int v41 = v40;
            int v42 = CFStringGetCStringPtr(v40, 0x8000100u);
            if (v42)
            {
              uint64_t v43 = (char *)v42;
              int v44 = 0LL;
            }

            else
            {
              uint64_t v43 = (char *)calloc(0x400uLL, 1uLL);
              CFStringGetCString(v41, v43, 1024LL, 0x8000100u);
              int v44 = v43;
            }

            if (qword_1000E7D38) {
              int v75 = (FILE *)qword_1000E7D38;
            }
            else {
              int v75 = __stderrp;
            }
            fprintf(v75, "%s\n", v43);
            if (v44) {
              free(v44);
            }
            CFRelease(v41);
          }

          else
          {
            id v71 = (os_log_s *)sub_10002EFA0();
            if (os_log_type_enabled(v71, OS_LOG_TYPE_FAULT)) {
              sub_10008D8E4();
            }
            if (qword_1000E7D38) {
              id v72 = (FILE *)qword_1000E7D38;
            }
            else {
              id v72 = __stderrp;
            }
            fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v72);
          }

          *__error() = v39;
        }

        stackshot_config_dealloc(v30);
      }
    }

    else
    {
      if (byte_1000E7D30)
      {
        int v45 = *__error();
        int v46 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v46, OS_LOG_TYPE_ERROR)) {
          sub_10008D864();
        }
        *__error() = v45;
      }

      if (byte_1000E7D31 && dword_1000E74E0 <= 3)
      {
        int v5 = *__error();
        pid_t v47 = *__error();
        pid_t v48 = __error();
        uint64_t v49 = strerror(*v48);
        pid_t v6 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"spindump-stuck: Unable to open %s: %d (%s)",  buf,  v47,  v49);
        if (!v6)
        {
          int v73 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v73, OS_LOG_TYPE_FAULT)) {
            sub_10008D7E4();
          }
          goto LABEL_111;
        }

        goto LABEL_85;
      }
    }
  }

LABEL_235:
}

  ;
}

  ;
}

uint64_t sub_100054B70()
{
  return ferror(v0);
}

int *sub_100054B80()
{
  return __error();
}

int *sub_100054B8C()
{
  return __error();
}

int *sub_100054B98()
{
  return __error();
}

void sub_100054BA0(const char *a1, uint64_t a2)
{
  time_t v4 = time(0LL);
  int v5 = strdup(a1);
  uint64_t v6 = sub_10002EDE8("Cleanup spindump dir for %s", a1);
  dispatch_queue_global_t global_queue = dispatch_get_global_queue(9LL, 0LL);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472LL;
  block[2] = sub_100054C44;
  block[3] = &unk_1000D9528;
  void block[6] = v4;
  block[7] = a2;
  void block[4] = v6;
  void block[5] = v5;
  dispatch_async(global_queue, block);
}

void sub_100054C44(uint64_t a1)
{
  uint64_t v2 = opendir("/private/var/db/spindump");
  if (v2)
  {
    char v3 = v2;
    *__error() = 0;
    for (uint64_t i = readdir(v3); i; uint64_t i = readdir(v3))
    {
      d_name = i->d_name;
      size_t v6 = strlen(*(const char **)(a1 + 40));
      if (!strncmp(d_name, *(const char **)(a1 + 40), v6))
      {
        snprintf(__str, 0x80uLL, "/private/var/db/spindump/%s", d_name);
        if (stat(__str, &v84))
        {
          if (byte_1000E7D30)
          {
            int v16 = *__error();
            unint64_t v17 = (os_log_s *)sub_10002EFA0();
            if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
            {
              int v59 = *__error();
              double v60 = __error();
              uint64_t v61 = strerror(*v60);
              *(_DWORD *)buf = 136315650;
              BOOL v81 = __str;
              __int16 v82 = 1024;
              *(_DWORD *)uint64_t v83 = v59;
              *(_WORD *)&v83[4] = 2080;
              *(void *)&v83[6] = v61;
              _os_log_error_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_ERROR,  "Stat failed, attemping unlink of %s: %d (%s)",  buf,  0x1Cu);
            }

            *__error() = v16;
          }

          if (byte_1000E7D31) {
            BOOL v18 = dword_1000E74E0 <= 3;
          }
          else {
            BOOL v18 = 0;
          }
          if (!v18) {
            goto LABEL_82;
          }
          int v19 = *__error();
          uint64_t v20 = *__error();
          id v21 = __error();
          size_t v22 = strerror(*v21);
          id v23 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"Stat failed, attemping unlink of %s: %d (%s)",  __str,  v20,  v22);
          if (v23) {
            goto LABEL_65;
          }
          size_t v24 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v24, OS_LOG_TYPE_FAULT))
          {
            int v25 = *__error();
            int v26 = __error();
            BOOL v27 = strerror(*v26);
            *(_DWORD *)buf = 136315650;
            BOOL v81 = __str;
            __int16 v82 = 1024;
            *(_DWORD *)uint64_t v83 = v25;
            *(_WORD *)&v83[4] = 2080;
            *(void *)&v83[6] = v27;
            int v28 = v24;
            uint64_t v29 = "Unable to format: Stat failed, attemping unlink of %s: %d (%s)";
            uint32_t v30 = 28;
            goto LABEL_76;
          }

          goto LABEL_77;
        }

        if (v84.st_ctimespec.tv_sec <= *(void *)(a1 + 48) - *(void *)(a1 + 56))
        {
          if (byte_1000E7D30)
          {
            int v44 = *__error();
            int v45 = (os_log_s *)sub_10002EFA0();
            if (os_log_type_enabled(v45, OS_LOG_TYPE_INFO))
            {
              uint64_t v46 = *(void *)(a1 + 56);
              __darwin_time_t v47 = *(void *)(a1 + 48) - v84.st_ctimespec.tv_sec;
              *(_DWORD *)buf = 136315650;
              BOOL v81 = __str;
              __int16 v82 = 2048;
              *(void *)uint64_t v83 = v47;
              *(_WORD *)&v83[8] = 2048;
              *(void *)&v83[10] = v46;
              _os_log_impl( (void *)&_mh_execute_header,  v45,  OS_LOG_TYPE_INFO,  "Unlinking %s which is %lds old (>=%lds)",  buf,  0x20u);
            }

            *__error() = v44;
          }

          if (byte_1000E7D31) {
            BOOL v48 = dword_1000E74E0 <= 1;
          }
          else {
            BOOL v48 = 0;
          }
          if (!v48) {
            goto LABEL_82;
          }
          int v19 = *__error();
          id v23 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"Unlinking %s which is %lds old (>=%lds)",  __str,  *(void *)(a1 + 48) - v84.st_ctimespec.tv_sec,  *(void *)(a1 + 56));
          if (v23)
          {
LABEL_65:
            uint64_t v49 = v23;
            CStringPtr = CFStringGetCStringPtr(v23, 0x8000100u);
            if (CStringPtr)
            {
              int v51 = (char *)CStringPtr;
              char v52 = 0LL;
            }

            else
            {
              int v51 = (char *)calloc(0x400uLL, 1uLL);
              CFStringGetCString(v49, v51, 1024LL, 0x8000100u);
              char v52 = v51;
            }

            if (qword_1000E7D38) {
              id v53 = (FILE *)qword_1000E7D38;
            }
            else {
              id v53 = __stderrp;
            }
            fprintf(v53, "%s\n", v51);
            if (v52) {
              free(v52);
            }
            CFRelease(v49);
LABEL_81:
            *__error() = v19;
LABEL_82:
            unlink(__str);
            continue;
          }

          int v55 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v55, OS_LOG_TYPE_FAULT))
          {
            uint64_t v56 = *(void *)(a1 + 56);
            __darwin_time_t v57 = *(void *)(a1 + 48) - v84.st_ctimespec.tv_sec;
            *(_DWORD *)buf = 136315650;
            BOOL v81 = __str;
            __int16 v82 = 2048;
            *(void *)uint64_t v83 = v57;
            *(_WORD *)&v83[8] = 2048;
            *(void *)&v83[10] = v56;
            int v28 = v55;
            uint64_t v29 = "Unable to format: Unlinking %s which is %lds old (>=%lds)";
            uint32_t v30 = 32;
LABEL_76:
            _os_log_fault_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_FAULT, v29, buf, v30);
          }

LABEL_43:
          if (qword_1000E7D38) {
            int v42 = (FILE *)qword_1000E7D38;
          }
          else {
            int v42 = __stderrp;
          }
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v42);
          goto LABEL_54;
        }
      }

      else
      {
        if (byte_1000E7D30)
        {
          int v7 = *__error();
          uid_t v8 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
          {
            __darwin_ino64_t v54 = *(void *)(a1 + 40);
            v84.st_dev = 136315394;
            *(void *)&v84.st_mode = d_name;
            WORD2(v84.st_ino) = 2080;
            *(__darwin_ino64_t *)((char *)&v84.st_ino + 6) = v54;
            _os_log_debug_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEBUG,  "File %s doesn't match prefix %s",  (uint8_t *)&v84,  0x16u);
          }

          *__error() = v7;
        }

        if (byte_1000E7D31) {
          BOOL v9 = dword_1000E74E0 <= 0;
        }
        else {
          BOOL v9 = 0;
        }
        if (!v9) {
          continue;
        }
        int v10 = *__error();
        char v11 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"File %s doesn't match prefix %s",  d_name,  *(void *)(a1 + 40));
        if (!v11)
        {
          int v41 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v41, OS_LOG_TYPE_FAULT))
          {
            __darwin_ino64_t v62 = *(void *)(a1 + 40);
            v84.st_dev = 136315394;
            *(void *)&v84.st_mode = d_name;
            WORD2(v84.st_ino) = 2080;
            *(__darwin_ino64_t *)((char *)&v84.st_ino + 6) = v62;
            int v37 = (uint8_t *)&v84;
            double v38 = v41;
            uint64_t v39 = "Unable to format: File %s doesn't match prefix %s";
            uint32_t v40 = 22;
LABEL_86:
            _os_log_fault_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_FAULT, v39, v37, v40);
          }

          goto LABEL_43;
        }
      }

      int v12 = v11;
      int v13 = CFStringGetCStringPtr(v11, 0x8000100u);
      if (v13)
      {
        id v14 = (char *)v13;
        BOOL v15 = 0LL;
      }

      else
      {
        id v14 = (char *)calloc(0x400uLL, 1uLL);
        CFStringGetCString(v12, v14, 1024LL, 0x8000100u);
        BOOL v15 = v14;
      }

      if (qword_1000E7D38) {
        uint64_t v43 = (FILE *)qword_1000E7D38;
      }
      else {
        uint64_t v43 = __stderrp;
      }
      fprintf(v43, "%s\n", v14);
      if (v15) {
        free(v15);
      }
      CFRelease(v12);
LABEL_54:
      *__error() = v10;
    }

    closedir(v3);
    free(*(void **)(a1 + 40));
  }

  else
  {
    if (byte_1000E7D30)
    {
      int v65 = *__error();
      int v66 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v66, OS_LOG_TYPE_ERROR)) {
        sub_10008BB00();
      }
      *__error() = v65;
    }

    if (byte_1000E7D31) {
      BOOL v67 = dword_1000E74E0 <= 3;
    }
    else {
      BOOL v67 = 0;
    }
    if (v67)
    {
      int v68 = *__error();
      uint64_t v69 = *__error();
      int v70 = __error();
      id v71 = strerror(*v70);
      id v72 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"Unable to opendir /private/var/db/spindump: %d (%s)",  v69,  v71);
      if (v72)
      {
        int v73 = v72;
        int v74 = CFStringGetCStringPtr(v72, 0x8000100u);
        if (v74)
        {
          int v75 = (char *)v74;
          id v76 = 0LL;
        }

        else
        {
          int v75 = (char *)calloc(0x400uLL, 1uLL);
          CFStringGetCString(v73, v75, 1024LL, 0x8000100u);
          id v76 = v75;
        }

        if (qword_1000E7D38) {
          BOOL v79 = (FILE *)qword_1000E7D38;
        }
        else {
          BOOL v79 = __stderrp;
        }
        fprintf(v79, "%s\n", v75);
        if (v76) {
          free(v76);
        }
        CFRelease(v73);
      }

      else
      {
        uint64_t v77 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v77, OS_LOG_TYPE_FAULT)) {
          sub_10008BA84();
        }
        if (qword_1000E7D38) {
          uint64_t v78 = (FILE *)qword_1000E7D38;
        }
        else {
          uint64_t v78 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v78);
      }

      *__error() = v68;
    }
  }

int *sub_1000555AC(int *result)
{
  uint64_t v26 = 66053LL;
  id result = (int *)ffsctl((int)result, 0xC0084A44uLL, &v26, 0);
  if ((_DWORD)result)
  {
    id v1 = result;
    if (byte_1000E7D30)
    {
      int v2 = *__error();
      char v3 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR)) {
        sub_10008BC6C((int)v1);
      }
      id result = __error();
      *id result = v2;
    }

    if (byte_1000E7D31) {
      BOOL v4 = dword_1000E74E0 <= 3;
    }
    else {
      BOOL v4 = 0;
    }
    if (!v4) {
      return result;
    }
    int v5 = *__error();
    size_t v6 = strerror((int)v1);
    int v7 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"Failed to mark file purgeable: %d (%s)", v1, v6);
    if (v7)
    {
      uid_t v8 = v7;
      CStringPtr = CFStringGetCStringPtr(v7, 0x8000100u);
      if (CStringPtr)
      {
        int v10 = (char *)CStringPtr;
        char v11 = 0LL;
      }

      else
      {
        int v10 = (char *)calloc(0x400uLL, 1uLL);
        CFStringGetCString(v8, v10, 1024LL, 0x8000100u);
        char v11 = v10;
      }

      if (qword_1000E7D38) {
        id v21 = (FILE *)qword_1000E7D38;
      }
      else {
        id v21 = __stderrp;
      }
      fprintf(v21, "%s\n", v10);
      if (v11) {
        free(v11);
      }
      size_t v22 = v8;
LABEL_49:
      CFRelease(v22);
LABEL_50:
      id result = __error();
      *id result = v5;
      return result;
    }

    uint64_t v20 = (os_log_s *)sub_10002EFA0();
    if (os_log_type_enabled(v20, OS_LOG_TYPE_FAULT)) {
      sub_10008BBFC((int)v1);
    }
    goto LABEL_38;
  }

  if (byte_1000E7D30)
  {
    int v12 = *__error();
    int v13 = (os_log_s *)sub_10002EFA0();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG)) {
      sub_10008BBBC(v13);
    }
    id result = __error();
    *id result = v12;
  }

  if (byte_1000E7D31) {
    BOOL v14 = dword_1000E74E0 <= 0;
  }
  else {
    BOOL v14 = 0;
  }
  if (v14)
  {
    int v5 = *__error();
    BOOL v15 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"Marked file purgeable");
    if (v15)
    {
      int v16 = v15;
      unint64_t v17 = CFStringGetCStringPtr(v15, 0x8000100u);
      if (v17)
      {
        BOOL v18 = (char *)v17;
        int v19 = 0LL;
      }

      else
      {
        BOOL v18 = (char *)calloc(0x400uLL, 1uLL);
        CFStringGetCString(v16, v18, 1024LL, 0x8000100u);
        int v19 = v18;
      }

      if (qword_1000E7D38) {
        int v25 = (FILE *)qword_1000E7D38;
      }
      else {
        int v25 = __stderrp;
      }
      fprintf(v25, "%s\n", v18);
      if (v19) {
        free(v19);
      }
      size_t v22 = v16;
      goto LABEL_49;
    }

    id v23 = (os_log_s *)sub_10002EFA0();
    if (os_log_type_enabled(v23, OS_LOG_TYPE_FAULT)) {
      sub_10008BB7C(v23);
    }
LABEL_38:
    if (qword_1000E7D38) {
      size_t v24 = (FILE *)qword_1000E7D38;
    }
    else {
      size_t v24 = __stderrp;
    }
    fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v24);
    goto LABEL_50;
  }

  return result;
}

void sub_1000558C4(id a1, OS_dispatch_source *a2)
{
  if (byte_1000E7D30)
  {
    int v3 = *__error();
    BOOL v4 = (os_log_s *)sub_10002EFA0();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 134217984;
      uintptr_t handle = dispatch_source_get_handle((dispatch_source_t)a2);
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_INFO, "Received signal %ld, exiting", buf, 0xCu);
    }

    *__error() = v3;
  }

  if (byte_1000E7D31) {
    BOOL v5 = dword_1000E74E0 <= 1;
  }
  else {
    BOOL v5 = 0;
  }
  if (v5)
  {
    int v6 = *__error();
    uintptr_t v7 = dispatch_source_get_handle((dispatch_source_t)a2);
    uid_t v8 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"Received signal %ld, exiting", v7);
    if (v8)
    {
      int v12 = v8;
      CStringPtr = CFStringGetCStringPtr(v8, 0x8000100u);
      if (CStringPtr)
      {
        BOOL v14 = (char *)CStringPtr;
        BOOL v15 = 0LL;
      }

      else
      {
        BOOL v14 = (char *)calloc(0x400uLL, 1uLL);
        CFStringGetCString(v12, v14, 1024LL, 0x8000100u);
        BOOL v15 = v14;
      }

      if (qword_1000E7D38) {
        int v16 = (FILE *)qword_1000E7D38;
      }
      else {
        int v16 = __stderrp;
      }
      fprintf(v16, "%s\n", v14);
      if (v15) {
        free(v15);
      }
      CFRelease(v12);
    }

    else
    {
      BOOL v9 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v9, OS_LOG_TYPE_FAULT))
      {
        uintptr_t v10 = dispatch_source_get_handle((dispatch_source_t)a2);
        *(_DWORD *)buf = 134217984;
        uintptr_t handle = v10;
        _os_log_fault_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_FAULT,  "Unable to format: Received signal %ld, exiting",  buf,  0xCu);
      }

      if (qword_1000E7D38) {
        char v11 = (FILE *)qword_1000E7D38;
      }
      else {
        char v11 = __stderrp;
      }
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v11);
    }

    *__error() = v6;
  }

  exit(0);
}

_BYTE *sub_100055AE4(const char *a1)
{
  if (!a1) {
    return 0LL;
  }
  int v2 = strnlen(a1, 0x100uLL);
  if (v2 < 256)
  {
    int v3 = strdup(a1);
    if (v2 < 1) {
      return v3;
    }
  }

  else
  {
    int v3 = malloc(0x100uLL);
    __strlcpy_chk(v3, a1, 256LL, 256LL);
    int v2 = 255;
  }

  for (uint64_t i = 0LL; i != v2; ++i)
  {
  }

  return v3;
}

int *sub_100055B90(void *a1)
{
  if (objc_msgSend(objc_msgSend(a1, "total"), "num_missing_load_info")
    || objc_msgSend(objc_msgSend(a1, "total"), "num_out_of_order")
    || (id result = (int *)objc_msgSend(a1, "bytes_not_microstackshots")) != 0)
  {
    if (objc_msgSend(objc_msgSend(a1, "total"), "num_missing_load_info"))
    {
      if (byte_1000E7D30)
      {
        int v3 = *__error();
        BOOL v4 = (char *)sub_10002EFA0();
        if (os_log_type_enabled((os_log_t)v4, OS_LOG_TYPE_ERROR)) {
          sub_10008CD48(a1, v4);
        }
        *__error() = v3;
      }

      if (byte_1000E7D31) {
        BOOL v5 = dword_1000E74E0 <= 3;
      }
      else {
        BOOL v5 = 0;
      }
      if (v5)
      {
        int v6 = *__error();
        uintptr_t v7 = CFStringCreateWithFormat( kCFAllocatorDefault,  0,  @"%llu microstackshots dropped due to missing load infos",  objc_msgSend(objc_msgSend(a1, "total"), "num_missing_load_info"));
        if (v7)
        {
          uid_t v8 = v7;
          CStringPtr = CFStringGetCStringPtr(v7, 0x8000100u);
          if (CStringPtr)
          {
            uintptr_t v10 = (char *)CStringPtr;
            char v11 = 0LL;
          }

          else
          {
            uintptr_t v10 = (char *)calloc(0x400uLL, 1uLL);
            CFStringGetCString(v8, v10, 1024LL, 0x8000100u);
            char v11 = v10;
          }

          if (qword_1000E7D38) {
            BOOL v14 = (FILE *)qword_1000E7D38;
          }
          else {
            BOOL v14 = __stderrp;
          }
          fprintf(v14, "%s\n", v10);
          if (v11) {
            free(v11);
          }
          CFRelease(v8);
        }

        else
        {
          int v12 = (char *)sub_10002EFA0();
          if (os_log_type_enabled((os_log_t)v12, OS_LOG_TYPE_FAULT)) {
            sub_10008CCD4(a1, v12);
          }
          if (qword_1000E7D38) {
            int v13 = (FILE *)qword_1000E7D38;
          }
          else {
            int v13 = __stderrp;
          }
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v13);
        }

        *__error() = v6;
      }
    }

    if (objc_msgSend(objc_msgSend(a1, "total"), "num_out_of_order"))
    {
      if (byte_1000E7D30)
      {
        int v15 = *__error();
        int v16 = (char *)sub_10002EFA0();
        if (os_log_type_enabled((os_log_t)v16, OS_LOG_TYPE_ERROR)) {
          sub_10008CC60(a1, v16);
        }
        *__error() = v15;
      }

      if (byte_1000E7D31) {
        BOOL v17 = dword_1000E74E0 <= 3;
      }
      else {
        BOOL v17 = 0;
      }
      if (v17)
      {
        int v18 = *__error();
        int v19 = CFStringCreateWithFormat( kCFAllocatorDefault,  0,  @"%llu microstackshots dropped due to being out of order",  objc_msgSend(objc_msgSend(a1, "total"), "num_out_of_order"));
        if (v19)
        {
          uint64_t v20 = v19;
          id v21 = CFStringGetCStringPtr(v19, 0x8000100u);
          if (v21)
          {
            size_t v22 = (char *)v21;
            id v23 = 0LL;
          }

          else
          {
            size_t v22 = (char *)calloc(0x400uLL, 1uLL);
            CFStringGetCString(v20, v22, 1024LL, 0x8000100u);
            id v23 = v22;
          }

          if (qword_1000E7D38) {
            uint64_t v26 = (FILE *)qword_1000E7D38;
          }
          else {
            uint64_t v26 = __stderrp;
          }
          fprintf(v26, "%s\n", v22);
          if (v23) {
            free(v23);
          }
          CFRelease(v20);
        }

        else
        {
          size_t v24 = (char *)sub_10002EFA0();
          if (os_log_type_enabled((os_log_t)v24, OS_LOG_TYPE_FAULT)) {
            sub_10008CBEC(a1, v24);
          }
          if (qword_1000E7D38) {
            int v25 = (FILE *)qword_1000E7D38;
          }
          else {
            int v25 = __stderrp;
          }
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v25);
        }

        *__error() = v18;
      }
    }

    id result = (int *)objc_msgSend(a1, "bytes_not_microstackshots");
    if (result)
    {
      if (byte_1000E7D30)
      {
        int v27 = *__error();
        int v28 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR)) {
          sub_10008CB78(a1, v28);
        }
        id result = __error();
        *id result = v27;
      }

      if (byte_1000E7D31 && dword_1000E74E0 <= 3)
      {
        int v29 = *__error();
        uint32_t v30 = CFStringCreateWithFormat( kCFAllocatorDefault,  0,  @"%llu bytes of microstackshot data was invalid (ignored)",  objc_msgSend(a1, "bytes_not_microstackshots"));
        if (v30)
        {
          int v31 = v30;
          BOOL v32 = CFStringGetCStringPtr(v30, 0x8000100u);
          if (v32)
          {
            BOOL v33 = (char *)v32;
            int v34 = 0LL;
          }

          else
          {
            BOOL v33 = (char *)calloc(0x400uLL, 1uLL);
            CFStringGetCString(v31, v33, 1024LL, 0x8000100u);
            int v34 = v33;
          }

          if (qword_1000E7D38) {
            int v37 = (FILE *)qword_1000E7D38;
          }
          else {
            int v37 = __stderrp;
          }
          fprintf(v37, "%s\n", v33);
          if (v34) {
            free(v34);
          }
          CFRelease(v31);
        }

        else
        {
          uint64_t v35 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v35, OS_LOG_TYPE_FAULT)) {
            sub_10008CB04(a1, v35);
          }
          if (qword_1000E7D38) {
            __darwin_time_t v36 = (FILE *)qword_1000E7D38;
          }
          else {
            __darwin_time_t v36 = __stderrp;
          }
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v36);
        }

        id result = __error();
        *id result = v29;
      }
    }
  }

  if (byte_1000E7D30)
  {
    int v38 = *__error();
    uint64_t v39 = (os_log_s *)sub_10002EFA0();
    if (os_log_type_enabled(v39, OS_LOG_TYPE_INFO))
    {
      int v191 = v38;
      uint32_t v40 = (char *)objc_msgSend(objc_msgSend(a1, "total"), "bytes");
      log = v39;
      int v41 = &v40[(void)objc_msgSend(objc_msgSend(a1, "total"), "bytes_duplicate")];
      id v42 = objc_msgSend(objc_msgSend(a1, "total"), "bytes_out_of_order");
      uint64_t v43 = &v41[(unint64_t)objc_msgSend(objc_msgSend(a1, "total"), "bytes_missing_load_info") + (void)v42];
      uint64_t v188 = (char *)objc_msgSend(a1, "bytes_not_microstackshots") + (void)v43;
      id v186 = objc_msgSend(a1, "bytes_not_microstackshots");
      id v184 = objc_msgSend(a1, "num_microstackshots_filtered_out");
      id v182 = objc_msgSend(objc_msgSend(a1, "total"), "count");
      id v180 = objc_msgSend(objc_msgSend(a1, "total"), "bytes");
      id v178 = objc_msgSend(objc_msgSend(a1, "total"), "num_load_infos");
      id v176 = objc_msgSend(objc_msgSend(a1, "total"), "num_frames");
      id v174 = objc_msgSend(objc_msgSend(a1, "total"), "num_duplicate");
      id v172 = objc_msgSend(objc_msgSend(a1, "total"), "bytes_duplicate");
      id v170 = objc_msgSend(objc_msgSend(a1, "total"), "num_out_of_order");
      id v168 = objc_msgSend(objc_msgSend(a1, "total"), "bytes_out_of_order");
      id v166 = objc_msgSend(objc_msgSend(a1, "total"), "num_missing_load_info");
      id v164 = objc_msgSend(objc_msgSend(a1, "total"), "bytes_missing_load_info");
      id v162 = objc_msgSend(objc_msgSend(a1, "interrupt"), "count");
      id v160 = objc_msgSend(objc_msgSend(a1, "interrupt"), "bytes");
      id v158 = objc_msgSend(objc_msgSend(a1, "interrupt"), "num_load_infos");
      id v156 = objc_msgSend(objc_msgSend(a1, "interrupt"), "num_frames");
      id v154 = objc_msgSend(objc_msgSend(a1, "interrupt"), "num_duplicate");
      id v152 = objc_msgSend(objc_msgSend(a1, "interrupt"), "bytes_duplicate");
      id v150 = objc_msgSend(objc_msgSend(a1, "interrupt"), "num_out_of_order");
      id v148 = objc_msgSend(objc_msgSend(a1, "interrupt"), "bytes_out_of_order");
      id v146 = objc_msgSend(objc_msgSend(a1, "interrupt"), "num_missing_load_info");
      id v144 = objc_msgSend(objc_msgSend(a1, "interrupt"), "bytes_missing_load_info");
      id v142 = objc_msgSend(objc_msgSend(a1, "timer"), "count");
      id v140 = objc_msgSend(objc_msgSend(a1, "timer"), "bytes");
      id v138 = objc_msgSend(objc_msgSend(a1, "timer"), "num_load_infos");
      id v136 = objc_msgSend(objc_msgSend(a1, "timer"), "num_frames");
      id v134 = objc_msgSend(objc_msgSend(a1, "timer"), "num_duplicate");
      id v132 = objc_msgSend(objc_msgSend(a1, "timer"), "bytes_duplicate");
      id v130 = objc_msgSend(objc_msgSend(a1, "timer"), "num_out_of_order");
      id v128 = objc_msgSend(objc_msgSend(a1, "timer"), "bytes_out_of_order");
      id v126 = objc_msgSend(objc_msgSend(a1, "timer"), "num_missing_load_info");
      id v124 = objc_msgSend(objc_msgSend(a1, "timer"), "bytes_missing_load_info");
      id v122 = objc_msgSend(objc_msgSend(a1, "io"), "count");
      id v118 = objc_msgSend(objc_msgSend(a1, "io"), "bytes");
      id v114 = objc_msgSend(objc_msgSend(a1, "io"), "num_load_infos");
      id v108 = objc_msgSend(objc_msgSend(a1, "io"), "num_frames");
      id v104 = objc_msgSend(objc_msgSend(a1, "io"), "num_duplicate");
      id v100 = objc_msgSend(objc_msgSend(a1, "io"), "bytes_duplicate");
      id v96 = objc_msgSend(objc_msgSend(a1, "io"), "num_out_of_order");
      id v92 = objc_msgSend(objc_msgSend(a1, "io"), "bytes_out_of_order");
      id v88 = objc_msgSend(objc_msgSend(a1, "io"), "num_missing_load_info");
      id v84 = objc_msgSend(objc_msgSend(a1, "io"), "bytes_missing_load_info");
      id v112 = objc_msgSend(objc_msgSend(a1, "pmi"), "count");
      id v120 = objc_msgSend(objc_msgSend(a1, "pmi"), "bytes");
      id v116 = objc_msgSend(objc_msgSend(a1, "pmi"), "num_load_infos");
      id v110 = objc_msgSend(objc_msgSend(a1, "pmi"), "num_frames");
      id v106 = objc_msgSend(objc_msgSend(a1, "pmi"), "num_duplicate");
      id v102 = objc_msgSend(objc_msgSend(a1, "pmi"), "bytes_duplicate");
      id v98 = objc_msgSend(objc_msgSend(a1, "pmi"), "num_out_of_order");
      id v94 = objc_msgSend(objc_msgSend(a1, "pmi"), "bytes_out_of_order");
      id v90 = objc_msgSend(objc_msgSend(a1, "pmi"), "num_missing_load_info");
      id v86 = objc_msgSend(objc_msgSend(a1, "pmi"), "bytes_missing_load_info");
      id v82 = objc_msgSend(objc_msgSend(a1, "macf"), "count");
      id v80 = objc_msgSend(objc_msgSend(a1, "macf"), "bytes");
      id v78 = objc_msgSend(objc_msgSend(a1, "macf"), "num_load_infos");
      id v76 = objc_msgSend(objc_msgSend(a1, "macf"), "num_frames");
      id v74 = objc_msgSend(objc_msgSend(a1, "macf"), "num_duplicate");
      id v72 = objc_msgSend(objc_msgSend(a1, "macf"), "bytes_duplicate");
      id v70 = objc_msgSend(objc_msgSend(a1, "macf"), "num_out_of_order");
      id v69 = objc_msgSend(objc_msgSend(a1, "macf"), "bytes_out_of_order");
      id v68 = objc_msgSend(objc_msgSend(a1, "macf"), "num_missing_load_info");
      id v67 = objc_msgSend(objc_msgSend(a1, "macf"), "bytes_missing_load_info");
      id v66 = objc_msgSend(objc_msgSend(a1, "unknown_type"), "count");
      id v44 = objc_msgSend(objc_msgSend(a1, "unknown_type"), "bytes");
      id v45 = objc_msgSend(objc_msgSend(a1, "unknown_type"), "num_load_infos");
      id v46 = objc_msgSend(objc_msgSend(a1, "unknown_type"), "num_frames");
      id v47 = objc_msgSend(objc_msgSend(a1, "unknown_type"), "num_duplicate");
      id v48 = objc_msgSend(objc_msgSend(a1, "unknown_type"), "bytes_duplicate");
      id v49 = objc_msgSend(objc_msgSend(a1, "unknown_type"), "num_out_of_order");
      id v50 = objc_msgSend(objc_msgSend(a1, "unknown_type"), "bytes_out_of_order");
      id v51 = objc_msgSend(objc_msgSend(a1, "unknown_type"), "num_missing_load_info");
      id v52 = objc_msgSend(objc_msgSend(a1, "unknown_type"), "bytes_missing_load_info");
      time_t v194 = v188;
      id v196 = v186;
      id v198 = v184;
      id v200 = v182;
      id v202 = v180;
      id v204 = v178;
      id v206 = v176;
      id v208 = v174;
      id v210 = v172;
      id v212 = v170;
      id v214 = v168;
      id v216 = v166;
      id v218 = v164;
      id v220 = v162;
      id v222 = v160;
      id v224 = v158;
      id v226 = v156;
      id v228 = v154;
      id v230 = v152;
      id v232 = v150;
      id v234 = v148;
      id v236 = v146;
      id v238 = v144;
      id v240 = v142;
      id v242 = v140;
      id v244 = v138;
      id v246 = v136;
      id v248 = v134;
      id v250 = v132;
      id v252 = v130;
      id v254 = v128;
      id v256 = v126;
      id v258 = v124;
      id v260 = v122;
      id v262 = v118;
      id v264 = v114;
      id v266 = v108;
      id v268 = v104;
      id v270 = v100;
      id v272 = v96;
      id v274 = v92;
      id v276 = v88;
      id v278 = v84;
      *(_DWORD *)buf = 134236416;
      id v280 = v112;
      __int16 v195 = 2048;
      __int16 v197 = 2048;
      __int16 v199 = 2048;
      __int16 v201 = 2048;
      __int16 v203 = 2048;
      __int16 v205 = 2048;
      __int16 v207 = 2048;
      __int16 v209 = 2048;
      __int16 v211 = 2048;
      __int16 v213 = 2048;
      __int16 v215 = 2048;
      __int16 v217 = 2048;
      __int16 v219 = 2048;
      __int16 v221 = 2048;
      __int16 v223 = 2048;
      __int16 v225 = 2048;
      __int16 v227 = 2048;
      __int16 v229 = 2048;
      __int16 v231 = 2048;
      __int16 v233 = 2048;
      __int16 v235 = 2048;
      __int16 v237 = 2048;
      __int16 v239 = 2048;
      __int16 v241 = 2048;
      __int16 v243 = 2048;
      __int16 v245 = 2048;
      __int16 v247 = 2048;
      __int16 v249 = 2048;
      __int16 v251 = 2048;
      __int16 v253 = 2048;
      __int16 v255 = 2048;
      __int16 v257 = 2048;
      __int16 v259 = 2048;
      __int16 v261 = 2048;
      __int16 v263 = 2048;
      __int16 v265 = 2048;
      __int16 v267 = 2048;
      __int16 v269 = 2048;
      __int16 v271 = 2048;
      __int16 v273 = 2048;
      __int16 v275 = 2048;
      __int16 v277 = 2048;
      __int16 v279 = 2048;
      __int16 v281 = 2048;
      id v282 = v120;
      __int16 v283 = 2048;
      id v284 = v116;
      __int16 v285 = 2048;
      id v286 = v110;
      __int16 v287 = 2048;
      id v288 = v106;
      __int16 v289 = 2048;
      id v290 = v102;
      __int16 v291 = 2048;
      id v292 = v98;
      __int16 v293 = 2048;
      id v294 = v94;
      __int16 v295 = 2048;
      id v296 = v90;
      __int16 v297 = 2048;
      id v298 = v86;
      __int16 v299 = 2048;
      id v300 = v82;
      __int16 v301 = 2048;
      id v302 = v80;
      __int16 v303 = 2048;
      id v304 = v78;
      __int16 v305 = 2048;
      id v306 = v76;
      __int16 v307 = 2048;
      id v308 = v74;
      __int16 v309 = 2048;
      id v310 = v72;
      __int16 v311 = 2048;
      id v312 = v70;
      __int16 v313 = 2048;
      id v314 = v69;
      __int16 v315 = 2048;
      id v316 = v68;
      __int16 v317 = 2048;
      id v318 = v67;
      __int16 v319 = 2048;
      id v320 = v66;
      char v321 = 0;
      char v322 = 8;
      id v323 = v44;
      char v324 = 0;
      char v325 = 8;
      id v326 = v45;
      char v327 = 0;
      char v328 = 8;
      id v329 = v46;
      char v330 = 0;
      char v331 = 8;
      id v332 = v47;
      char v333 = 0;
      char v334 = 8;
      id v335 = v48;
      int v38 = v191;
      char v336 = 0;
      char v337 = 8;
      id v338 = v49;
      char v339 = 0;
      char v340 = 8;
      id v341 = v50;
      char v342 = 0;
      char v343 = 8;
      id v344 = v51;
      char v345 = 0;
      char v346 = 8;
      id v347 = v52;
      _os_log_impl( (void *)&_mh_execute_header,  log,  OS_LOG_TYPE_INFO,  "Microstackshot statistics:\n %llu bytes parsed (%llu bytes invalid)\n %llu filtered out\n \n total     count          %llu (%llu bytes)\n num_load_infos %llu\n num_frames     %llu\n duplicate      %llu (%llu bytes)\n out_of_order   %llu (%llu bytes)\n no_load_info   %llu (%llu bytes)\n \n interrupt count          %llu (%llu bytes)\n num_load_infos %llu\n num_frames     %llu\n duplicate      %llu (%llu bytes)\n out_of_order   %llu (%llu bytes)\n no_load_info   %llu (%llu bytes)\n \n timer     count          %llu (%llu bytes)\n num_load_infos %llu\n num_frames     %llu\n duplicate      %llu (%llu bytes)\n out_of_order   %llu (%llu bytes)\n no_load_info   %llu (%llu bytes)\n \n io        count          %llu (%llu bytes)\n num_load_infos %llu\n num_frames     %llu\n duplicate      %llu (%llu bytes)\n out_of_order   %llu (%llu bytes)\n no_load_info   %llu (%llu bytes)\n \n pmi       count          %llu (%llu bytes)\n num_load_infos %llu\n num_frames     %llu\n duplicate      %llu (%llu bytes)\n out_of_order   %llu (%llu bytes)\n no_load_info   %llu (%llu bytes)\n \n macf      count          %llu (%llu bytes)\n num_load_infos %llu\n num_frames     %llu\n duplicate      %llu (%llu bytes)\n out_of_order   %llu (%llu bytes)\n no_load_info   %llu (%llu bytes)\n \n"
        "unknown   count          %llu (%llu bytes)\n"
        "          num_load_infos %llu\n"
        "          num_frames     %llu\n"
        "          duplicate      %llu (%llu bytes)\n"
        "          out_of_order   %llu (%llu bytes)\n"
        "          no_load_info   %llu (%llu bytes)",
        buf,
        0x2DCu);
    }

    id result = __error();
    *id result = v38;
  }

  if (byte_1000E7D31) {
    BOOL v53 = dword_1000E74E0 <= 1;
  }
  else {
    BOOL v53 = 0;
  }
  if (v53)
  {
    int v192 = *__error();
    __darwin_ino64_t v54 = (char *)objc_msgSend(objc_msgSend(a1, "total"), "bytes");
    int v55 = &v54[(void)objc_msgSend(objc_msgSend(a1, "total"), "bytes_duplicate")];
    id v56 = objc_msgSend(objc_msgSend(a1, "total"), "bytes_out_of_order");
    __darwin_time_t v57 = &v55[(unint64_t)objc_msgSend(objc_msgSend(a1, "total"), "bytes_missing_load_info") + (void)v56];
    int v189 = (char *)objc_msgSend(a1, "bytes_not_microstackshots") + (void)v57;
    id v187 = objc_msgSend(a1, "bytes_not_microstackshots");
    id v185 = objc_msgSend(a1, "num_microstackshots_filtered_out");
    id v183 = objc_msgSend(objc_msgSend(a1, "total"), "count");
    id v181 = objc_msgSend(objc_msgSend(a1, "total"), "bytes");
    id v179 = objc_msgSend(objc_msgSend(a1, "total"), "num_load_infos");
    id v177 = objc_msgSend(objc_msgSend(a1, "total"), "num_frames");
    id v175 = objc_msgSend(objc_msgSend(a1, "total"), "num_duplicate");
    id v173 = objc_msgSend(objc_msgSend(a1, "total"), "bytes_duplicate");
    id v171 = objc_msgSend(objc_msgSend(a1, "total"), "num_out_of_order");
    id v169 = objc_msgSend(objc_msgSend(a1, "total"), "bytes_out_of_order");
    id v167 = objc_msgSend(objc_msgSend(a1, "total"), "num_missing_load_info");
    id v165 = objc_msgSend(objc_msgSend(a1, "total"), "bytes_missing_load_info");
    id v163 = objc_msgSend(objc_msgSend(a1, "interrupt"), "count");
    id v161 = objc_msgSend(objc_msgSend(a1, "interrupt"), "bytes");
    id v159 = objc_msgSend(objc_msgSend(a1, "interrupt"), "num_load_infos");
    id v157 = objc_msgSend(objc_msgSend(a1, "interrupt"), "num_frames");
    id v155 = objc_msgSend(objc_msgSend(a1, "interrupt"), "num_duplicate");
    id v153 = objc_msgSend(objc_msgSend(a1, "interrupt"), "bytes_duplicate");
    id v151 = objc_msgSend(objc_msgSend(a1, "interrupt"), "num_out_of_order");
    id v149 = objc_msgSend(objc_msgSend(a1, "interrupt"), "bytes_out_of_order");
    id v147 = objc_msgSend(objc_msgSend(a1, "interrupt"), "num_missing_load_info");
    id v145 = objc_msgSend(objc_msgSend(a1, "interrupt"), "bytes_missing_load_info");
    id v143 = objc_msgSend(objc_msgSend(a1, "timer"), "count");
    id v141 = objc_msgSend(objc_msgSend(a1, "timer"), "bytes");
    id v139 = objc_msgSend(objc_msgSend(a1, "timer"), "num_load_infos");
    id v137 = objc_msgSend(objc_msgSend(a1, "timer"), "num_frames");
    id v135 = objc_msgSend(objc_msgSend(a1, "timer"), "num_duplicate");
    id v133 = objc_msgSend(objc_msgSend(a1, "timer"), "bytes_duplicate");
    id v131 = objc_msgSend(objc_msgSend(a1, "timer"), "num_out_of_order");
    id v129 = objc_msgSend(objc_msgSend(a1, "timer"), "bytes_out_of_order");
    id v127 = objc_msgSend(objc_msgSend(a1, "timer"), "num_missing_load_info");
    id v125 = objc_msgSend(objc_msgSend(a1, "timer"), "bytes_missing_load_info");
    id v123 = objc_msgSend(objc_msgSend(a1, "io"), "count");
    id v121 = objc_msgSend(objc_msgSend(a1, "io"), "bytes");
    id v119 = objc_msgSend(objc_msgSend(a1, "io"), "num_load_infos");
    id v117 = objc_msgSend(objc_msgSend(a1, "io"), "num_frames");
    id v115 = objc_msgSend(objc_msgSend(a1, "io"), "num_duplicate");
    id v113 = objc_msgSend(objc_msgSend(a1, "io"), "bytes_duplicate");
    id v111 = objc_msgSend(objc_msgSend(a1, "io"), "num_out_of_order");
    id v109 = objc_msgSend(objc_msgSend(a1, "io"), "bytes_out_of_order");
    id v107 = objc_msgSend(objc_msgSend(a1, "io"), "num_missing_load_info");
    id v105 = objc_msgSend(objc_msgSend(a1, "io"), "bytes_missing_load_info");
    id v103 = objc_msgSend(objc_msgSend(a1, "pmi"), "count");
    id v101 = objc_msgSend(objc_msgSend(a1, "pmi"), "bytes");
    id v99 = objc_msgSend(objc_msgSend(a1, "pmi"), "num_load_infos");
    id v97 = objc_msgSend(objc_msgSend(a1, "pmi"), "num_frames");
    id v95 = objc_msgSend(objc_msgSend(a1, "pmi"), "num_duplicate");
    id v93 = objc_msgSend(objc_msgSend(a1, "pmi"), "bytes_duplicate");
    id v91 = objc_msgSend(objc_msgSend(a1, "pmi"), "num_out_of_order");
    id v89 = objc_msgSend(objc_msgSend(a1, "pmi"), "bytes_out_of_order");
    id v87 = objc_msgSend(objc_msgSend(a1, "pmi"), "num_missing_load_info");
    id v85 = objc_msgSend(objc_msgSend(a1, "pmi"), "bytes_missing_load_info");
    id v83 = objc_msgSend(objc_msgSend(a1, "macf"), "count");
    id v81 = objc_msgSend(objc_msgSend(a1, "macf"), "bytes");
    id v79 = objc_msgSend(objc_msgSend(a1, "macf"), "num_load_infos");
    id v77 = objc_msgSend(objc_msgSend(a1, "macf"), "num_frames");
    id v75 = objc_msgSend(objc_msgSend(a1, "macf"), "num_duplicate");
    id v73 = objc_msgSend(objc_msgSend(a1, "macf"), "bytes_duplicate");
    id v71 = objc_msgSend(objc_msgSend(a1, "macf"), "num_out_of_order");
    objc_msgSend(objc_msgSend(a1, "macf"), "bytes_out_of_order");
    objc_msgSend(objc_msgSend(a1, "macf"), "num_missing_load_info");
    objc_msgSend(objc_msgSend(a1, "macf"), "bytes_missing_load_info");
    objc_msgSend(objc_msgSend(a1, "unknown_type"), "count");
    objc_msgSend(objc_msgSend(a1, "unknown_type"), "bytes");
    objc_msgSend(objc_msgSend(a1, "unknown_type"), "num_load_infos");
    objc_msgSend(objc_msgSend(a1, "unknown_type"), "num_frames");
    objc_msgSend(objc_msgSend(a1, "unknown_type"), "num_duplicate");
    objc_msgSend(objc_msgSend(a1, "unknown_type"), "bytes_duplicate");
    objc_msgSend(objc_msgSend(a1, "unknown_type"), "num_out_of_order");
    objc_msgSend(objc_msgSend(a1, "unknown_type"), "bytes_out_of_order");
    objc_msgSend(objc_msgSend(a1, "unknown_type"), "num_missing_load_info");
    objc_msgSend(objc_msgSend(a1, "unknown_type"), "bytes_missing_load_info");
    id v58 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"Microstackshot statistics:\n%llu bytes parsed (%llu bytes invalid)\n%llu filtered out\n\ntotal     count          %llu (%llu bytes)\n          num_load_infos %llu\n          num_frames     %llu\n          duplicate      %llu (%llu bytes)\n          out_of_order   %llu (%llu bytes)\n          no_load_info   %llu (%llu bytes)\n\ninterrupt count          %llu (%llu bytes)\n          num_load_infos %llu\n          num_frames     %llu\n          duplicate      %llu (%llu bytes)\n          out_of_order   %llu (%llu bytes)\n          no_load_info   %llu (%llu bytes)\n\ntimer     count          %llu (%llu bytes)\n          num_load_infos %llu\n          num_frames     %llu\n          duplicate      %llu (%llu bytes)\n          out_of_order   %llu (%llu bytes)\n          no_load_info   %llu (%llu bytes)\n\nio        count          %llu (%llu bytes)\n          num_load_infos %llu\n          num_frames     %llu\n          duplicate      %llu (%llu bytes)\n          out_of_order   %llu (%llu bytes)\n          no_load_info   %llu (%llu bytes)\n\npmi       count          %llu (%llu bytes)\n          num_load_infos %llu\n          num_frames     %llu\n          duplicate      %llu (%llu bytes)\n          out_of_order   %llu (%llu bytes)\n          no_load_info   %llu (%llu bytes)\n\nmacf      count          %llu (%llu bytes)\n          num_load_infos %llu\n          num_frames     %llu\n          duplicate      %llu (%llu bytes)\n          out_of_order   %llu (%llu bytes)\n          no_load_info   %llu (%llu bytes)\n\nunknown   count          %llu (%llu bytes)\n          num_load_infos %llu\n          num_frames     %llu\n          duplicate      %llu (%llu bytes)\n          out_of_order   %llu (%llu bytes)\n          no_load_info   %llu (%llu bytes)",  v189,  v187,  v185,  v183,  v181,  v179,  v177,  v175,  v173,  v171,  v169,  v167,  v165,  v163,  v161,  v159,  v157,  v155,  v153,  v151,  v149,  v147,  v145,  v143,  v141,  v139,  v137,  v135,  v133,  v131,  v129,  v127,  v125,  v123,  v121,  v119,  v117,  v115,  v113,  v111,  v109,  v107,  v105,  v103,  v101,  v99,
            v97,
            v95,
            v93,
            v91,
            v89,
            v87,
            v85,
            v83,
            v81,
            v79,
            v77,
            v75,
            v73,
            v71);
    if (v58)
    {
      int v59 = v58;
      double v60 = CFStringGetCStringPtr(v58, 0x8000100u);
      if (v60)
      {
        uint64_t v61 = (char *)v60;
        __darwin_ino64_t v62 = 0LL;
      }

      else
      {
        uint64_t v61 = (char *)calloc(0x400uLL, 1uLL);
        CFStringGetCString(v59, v61, 1024LL, 0x8000100u);
        __darwin_ino64_t v62 = v61;
      }

      if (qword_1000E7D38) {
        int v65 = (FILE *)qword_1000E7D38;
      }
      else {
        int v65 = __stderrp;
      }
      fprintf(v65, "%s\n", v61);
      if (v62) {
        free(v62);
      }
      CFRelease(v59);
    }

    else
    {
      uint64_t v63 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v63, OS_LOG_TYPE_FAULT)) {
        sub_10008C32C(a1, v63);
      }
      if (qword_1000E7D38) {
        __darwin_time_t v64 = (FILE *)qword_1000E7D38;
      }
      else {
        __darwin_time_t v64 = __stderrp;
      }
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v64);
    }

    id result = __error();
    *id result = v192;
  }

  return result;
}

void sub_10005718C(uint64_t a1)
{
}

id sub_1000571C4(void *a1, int a2, int a3, int a4)
{
  unint64_t v8 = (unint64_t)[a1 dataGatheringOptions];
  if (a2)
  {
    [a1 setDataGatheringOptions:v8 | 0x60];
    unint64_t v9 = (unint64_t)[a1 dataGatheringOptions];
    if (a3) {
      unint64_t v10 = v9 | 8;
    }
    else {
      unint64_t v10 = v9 & 0xFFFFFFFFFFFFFFF7LL;
    }
  }

  else
  {
    unint64_t v10 = v8 & 0xFFFFFFFFFFFFFF97LL;
  }

  [a1 setDataGatheringOptions:v10];
  unint64_t v11 = (unint64_t)[a1 dataGatheringOptions] & 0xFFFFFFFFFFFFFFEFLL;
  uint64_t v12 = 16LL;
  if (!a4) {
    uint64_t v12 = 0LL;
  }
  return [a1 setDataGatheringOptions:v11 | v12];
}

void sub_100057254( void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7, int a8, uint8_t *a9, void *a10, char a11)
{
  if (a2) {
    objc_msgSend( a1,  "setSignature:",  +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", a2));
  }
  BOOL v17 = a9;
  if (a3) {
    objc_msgSend( a1,  "setReason:",  +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", a3));
  }
  [a1 setUseDsymForUUIDForEverything:a6];
  [a1 setFindDsymsForIDs:a4];
  [a1 setIncludeBinaryFormatInReport:a8 ^ 1u];
  [a1 setIncludeTextualFormatInReport:a7 ^ 1u];
  [a1 setHeaderOnly:0];
  [a1 setDsymPaths:a5];
  id v75 = 0LL;
  if (a9)
  {
    while (1)
    {
      int v19 = -[NSString initWithUTF8String:](objc_alloc(&OBJC_CLASS___NSString), "initWithUTF8String:", v17);
      id v20 = [a1 targetProcessId];
      uid_t v21 = geteuid();
      int v22 = sub_10004CDE4(v19, a10, (uint64_t)v20, 1537, v21, 0x1A4u, &v75);
      if (v19) {

      }
      if (v22 != -1)
      {
        id v23 = fdopen(v22, "w");
        if (v23) {
          break;
        }
      }

      if (byte_1000E7D30)
      {
        int v24 = *__error();
        int v25 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
        {
          BOOL v53 = v17;
          if (v75) {
            BOOL v53 = (uint8_t *)[v75 UTF8String];
          }
          int v54 = *__error();
          int v55 = __error();
          id v56 = strerror(*v55);
          *(_DWORD *)id v76 = 136315650;
          *(void *)&v76[4] = v53;
          __int16 v77 = 1024;
          int v78 = v54;
          __int16 v79 = 2080;
          id v80 = v56;
          _os_log_error_impl( (void *)&_mh_execute_header,  v25,  OS_LOG_TYPE_ERROR,  "Spindump failed to save report to %s: %d (%s)",  v76,  0x1Cu);
        }

        *__error() = v24;
      }

      if (byte_1000E7D31) {
        BOOL v26 = dword_1000E74E0 <= 3;
      }
      else {
        BOOL v26 = 0;
      }
      if (v26)
      {
        int v27 = *__error();
        int v28 = v17;
        if (v75) {
          int v28 = (uint8_t *)[v75 UTF8String];
        }
        uint64_t v29 = *__error();
        uint32_t v30 = __error();
        int v31 = strerror(*v30);
        BOOL v32 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"Spindump failed to save report to %s: %d (%s)",  v28,  v29,  v31);
        if (v32)
        {
          BOOL v33 = v32;
          CStringPtr = CFStringGetCStringPtr(v32, 0x8000100u);
          if (CStringPtr)
          {
            uint64_t v35 = (char *)CStringPtr;
            __darwin_time_t v36 = 0LL;
          }

          else
          {
            uint64_t v35 = (char *)calloc(0x400uLL, 1uLL);
            CFStringGetCString(v33, v35, 1024LL, 0x8000100u);
            __darwin_time_t v36 = v35;
          }

          if (qword_1000E7D38) {
            uint64_t v39 = (FILE *)qword_1000E7D38;
          }
          else {
            uint64_t v39 = __stderrp;
          }
          fprintf(v39, "%s\n", v35);
          if (v36) {
            free(v36);
          }
          CFRelease(v33);
        }

        else
        {
          int v37 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v37, OS_LOG_TYPE_FAULT))
          {
            __darwin_time_t v57 = v17;
            if (v75) {
              __darwin_time_t v57 = (uint8_t *)[v75 UTF8String];
            }
            int v58 = *__error();
            int v59 = __error();
            double v60 = strerror(*v59);
            *(_DWORD *)id v76 = 136315650;
            *(void *)&v76[4] = v57;
            __int16 v77 = 1024;
            int v78 = v58;
            __int16 v79 = 2080;
            id v80 = v60;
            _os_log_fault_impl( (void *)&_mh_execute_header,  v37,  OS_LOG_TYPE_FAULT,  "Unable to format: Spindump failed to save report to %s: %d (%s)",  v76,  0x1Cu);
          }

          if (qword_1000E7D38) {
            int v38 = (FILE *)qword_1000E7D38;
          }
          else {
            int v38 = __stderrp;
          }
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v38);
        }

        *__error() = v27;
      }

      id v75 = 0LL;
      if (v22 != -1) {
        close(v22);
      }
      if (byte_1000E7D30)
      {
        int v40 = *__error();
        int v41 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v41, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v41,  OS_LOG_TYPE_DEFAULT,  "Please enter a new output location (or an empty line to output to stdout, including spindump binary format)",  buf,  2u);
        }

        *__error() = v40;
      }

      if (byte_1000E7D31 && dword_1000E74E0 <= 2)
      {
        int v42 = *__error();
        uint64_t v43 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"Please enter a new output location (or an empty line to output to stdout, including spindump binary format)");
        if (v43)
        {
          id v44 = v43;
          id v45 = CFStringGetCStringPtr(v43, 0x8000100u);
          if (v45)
          {
            id v46 = (char *)v45;
            id v47 = 0LL;
          }

          else
          {
            id v46 = (char *)calloc(0x400uLL, 1uLL);
            CFStringGetCString(v44, v46, 1024LL, 0x8000100u);
            id v47 = v46;
          }

          if (qword_1000E7D38) {
            id v50 = (FILE *)qword_1000E7D38;
          }
          else {
            id v50 = __stderrp;
          }
          fprintf(v50, "%s\n", v46);
          if (v47) {
            free(v47);
          }
          CFRelease(v44);
        }

        else
        {
          id v48 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v48, OS_LOG_TYPE_FAULT))
          {
            *(_WORD *)buf = 0;
            _os_log_fault_impl( (void *)&_mh_execute_header,  v48,  OS_LOG_TYPE_FAULT,  "Unable to format: Please enter a new output location (or an empty line to output to stdout, including spin dump binary format)",  buf,  2u);
          }

          if (qword_1000E7D38) {
            id v49 = (FILE *)qword_1000E7D38;
          }
          else {
            id v49 = __stderrp;
          }
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v49);
        }

        *__error() = v42;
      }

      id v51 = fgetln(__stdinp, (size_t *)v76);
      uint64_t v52 = *(void *)v76;
      if (!*(void *)v76) {
        goto LABEL_8;
      }
      if (v51[*(void *)v76 - 1] == 10)
      {
        v51[*(void *)v76 - 1] = 0;
        uint64_t v52 = --*(void *)v76;
      }

      BOOL v17 = v81;
      __memcpy_chk(v81, v51, v52, 1024LL);
      v81[v52] = 0;
    }

    uint64_t v61 = v23;
    [a1 saveReportToStream:v23];
    fclose(v61);
    if (byte_1000E7D30)
    {
      int v62 = *__error();
      uint64_t v63 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v63, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)id v81 = 138412290;
        id v82 = v75;
        _os_log_impl( (void *)&_mh_execute_header,  v63,  OS_LOG_TYPE_DEFAULT,  "Spindump analysis written to file %@",  v81,  0xCu);
      }

      *__error() = v62;
    }

    if (byte_1000E7D31 && dword_1000E74E0 <= 2)
    {
      int v64 = *__error();
      int v65 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"Spindump analysis written to file %@", v75);
      if (v65)
      {
        id v68 = v65;
        id v69 = CFStringGetCStringPtr(v65, 0x8000100u);
        if (v69)
        {
          id v70 = (char *)v69;
          id v71 = 0LL;
        }

        else
        {
          id v70 = (char *)calloc(0x400uLL, 1uLL);
          CFStringGetCString(v68, v70, 1024LL, 0x8000100u);
          id v71 = v70;
        }

        if (qword_1000E7D38) {
          id v72 = (FILE *)qword_1000E7D38;
        }
        else {
          id v72 = __stderrp;
        }
        fprintf(v72, "%s\n", v70);
        if (v71) {
          free(v71);
        }
        CFRelease(v68);
      }

      else
      {
        id v66 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v66, OS_LOG_TYPE_FAULT))
        {
          *(_DWORD *)id v81 = 138412290;
          id v82 = v75;
          _os_log_fault_impl( (void *)&_mh_execute_header,  v66,  OS_LOG_TYPE_FAULT,  "Unable to format: Spindump analysis written to file %@",  v81,  0xCu);
        }

        if (qword_1000E7D38) {
          id v67 = (FILE *)qword_1000E7D38;
        }
        else {
          id v67 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v67);
      }

      *__error() = v64;
      if ((a11 & 1) == 0) {
        goto LABEL_106;
      }
    }

    else if (!a11)
    {
      goto LABEL_106;
    }

    [a1 setIncludeBinaryFormatInReport:0];
    char v18 = 0;
  }

  else
  {
    if ((a11 & 1) == 0) {
      goto LABEL_107;
    }
    BOOL v17 = 0LL;
LABEL_8:
    char v18 = 1;
  }

  [a1 saveReportToStream:__stdoutp];
  if ((v18 & 1) != 0)
  {

    if (v17) {
      exit(69);
    }
LABEL_107:
    exit(0);
  }

LABEL_106:
  goto LABEL_107;
}

void sub_100057AC8(id a1)
{
  if (byte_1000E7D30)
  {
    int v1 = *__error();
    int v2 = (os_log_s *)sub_10002EFA0();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Timed out, exiting", buf, 2u);
    }

    *__error() = v1;
  }

  if (byte_1000E7D31) {
    BOOL v3 = dword_1000E74E0 <= 2;
  }
  else {
    BOOL v3 = 0;
  }
  if (v3)
  {
    int v4 = *__error();
    BOOL v5 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"Timed out, exiting");
    if (v5)
    {
      unint64_t v8 = v5;
      CStringPtr = CFStringGetCStringPtr(v5, 0x8000100u);
      if (CStringPtr)
      {
        unint64_t v10 = (char *)CStringPtr;
        unint64_t v11 = 0LL;
      }

      else
      {
        unint64_t v10 = (char *)calloc(0x400uLL, 1uLL);
        CFStringGetCString(v8, v10, 1024LL, 0x8000100u);
        unint64_t v11 = v10;
      }

      if (qword_1000E7D38) {
        uint64_t v12 = (FILE *)qword_1000E7D38;
      }
      else {
        uint64_t v12 = __stderrp;
      }
      fprintf(v12, "%s\n", v10);
      if (v11) {
        free(v11);
      }
      CFRelease(v8);
    }

    else
    {
      int v6 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)int v13 = 0;
        _os_log_fault_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_FAULT,  "Unable to format: Timed out, exiting",  v13,  2u);
      }

      if (qword_1000E7D38) {
        uintptr_t v7 = (FILE *)qword_1000E7D38;
      }
      else {
        uintptr_t v7 = __stderrp;
      }
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v7);
    }

    *__error() = v4;
  }

  exit(75);
}

id sub_100057C98(uint64_t a1, void *a2)
{
  int v4 = *(NSString **)(a1 + 32);
  if (v4) {
    int v4 = +[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:");
  }
  [a2 setSignature:v4];
  BOOL v5 = *(NSString **)(a1 + 40);
  if (v5) {
    BOOL v5 = +[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:");
  }
  [a2 setReason:v5];
  if (*(_DWORD *)(a1 + 56)) {
    int v6 = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"sampling started after %d seconds",  *(unsigned int *)(a1 + 56));
  }
  else {
    int v6 = 0LL;
  }
  [a2 setDurationNote:v6];
  [a2 setExtraDuration:(double)*(int *)(a1 + 56)];
  [a2 setStepsNote:0];
  [a2 setSanitizePaths:0];
  [a2 setOmitThirdPartyProcessStacks:0];
  [a2 setIncludeBinaryFormatInReport:1];
  [a2 setIncludeTextualFormatInReport:0];
  uintptr_t v7 = objc_alloc_init(&OBJC_CLASS___NSMutableString);
  int v8 = sub_10002D674();
  unint64_t v9 = (unsigned int *)calloc(v8, 4uLL);
  uint64_t v10 = proc_listallpids(v9, 4 * v8);
  if ((_DWORD)v10 == -1)
  {
    if (byte_1000E7D30)
    {
      int v20 = *__error();
      uid_t v21 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR)) {
        sub_10008CE2C();
      }
      *__error() = v20;
    }

    if (byte_1000E7D31 && dword_1000E74E0 <= 3)
    {
      int v22 = *__error();
      uint64_t v23 = *__error();
      int v24 = __error();
      int v25 = strerror(*v24);
      BOOL v26 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"Unable to get pid list: %d (%s)", v23, v25);
      if (v26)
      {
        int v27 = v26;
        CStringPtr = CFStringGetCStringPtr(v26, 0x8000100u);
        if (CStringPtr)
        {
          uint64_t v29 = (char *)CStringPtr;
          uint32_t v30 = 0LL;
        }

        else
        {
          uint64_t v29 = (char *)calloc(0x400uLL, 1uLL);
          CFStringGetCString(v27, v29, 1024LL, 0x8000100u);
          uint32_t v30 = v29;
        }

        if (qword_1000E7D38) {
          id v160 = (FILE *)qword_1000E7D38;
        }
        else {
          id v160 = __stderrp;
        }
        fprintf(v160, "%s\n", v29);
        if (v30) {
          free(v30);
        }
        CFRelease(v27);
      }

      else
      {
        id v155 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v155, OS_LOG_TYPE_FAULT)) {
          sub_10008CDBC();
        }
        if (qword_1000E7D38) {
          id v156 = (FILE *)qword_1000E7D38;
        }
        else {
          id v156 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v156);
      }

      *__error() = v22;
    }

    uint64_t v161 = *__error();
    id v162 = __error();
    -[NSMutableString appendFormat:]( v7,  "appendFormat:",  @"Unable to get pid list for heap/ddt: %d %s\n",  v161,  strerror(*v162));
  }

  else
  {
    uint64_t v11 = v10;
    if (byte_1000E7D30)
    {
      int v12 = *__error();
      int v13 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 67109120;
        int v230 = v11;
        _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEFAULT,  "Running heap/ddt for all (%d) processes",  buf,  8u);
      }

      *__error() = v12;
    }

    if (byte_1000E7D31 && dword_1000E74E0 <= 2)
    {
      int v14 = *__error();
      int v15 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"Running heap/ddt for all (%d) processes", v11);
      if (v15)
      {
        int v16 = v15;
        BOOL v17 = CFStringGetCStringPtr(v15, 0x8000100u);
        if (v17)
        {
          char v18 = (char *)v17;
          int v19 = 0LL;
        }

        else
        {
          char v18 = (char *)calloc(0x400uLL, 1uLL);
          CFStringGetCString(v16, v18, 1024LL, 0x8000100u);
          int v19 = v18;
        }

        if (qword_1000E7D38) {
          BOOL v33 = (FILE *)qword_1000E7D38;
        }
        else {
          BOOL v33 = __stderrp;
        }
        fprintf(v33, "%s\n", v18);
        if (v19) {
          free(v19);
        }
        CFRelease(v16);
      }

      else
      {
        int v31 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v31, OS_LOG_TYPE_FAULT)) {
          sub_10008CFC8();
        }
        if (qword_1000E7D38) {
          BOOL v32 = (FILE *)qword_1000E7D38;
        }
        else {
          BOOL v32 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v32);
      }

      *__error() = v14;
    }

    qsort_b(v9, (int)v11, 4uLL, &stru_1000D9610);
    dsema = dispatch_semaphore_create(8LL);
    dispatch_group_t object = dispatch_group_create();
    int v34 = *(_DWORD *)(a1 + 60);
    if (v34)
    {
      dispatch_time_t v35 = *(void *)(a1 + 48);
      if (v34 >= 11) {
        dispatch_time_t v35 = dispatch_time(v35, 1000000000LL * (v34 - 10));
      }
      dispatch_time_t timeout = v35;
    }

    else
    {
      dispatch_time_t timeout = -1LL;
    }

    __darwin_time_t v36 = -[NSMutableArray initWithCapacity:]( objc_alloc(&OBJC_CLASS___NSMutableArray),  "initWithCapacity:",  2 * (int)v11);
    if ((int)v11 >= 1)
    {
      for (uint64_t i = 0LL; v11 != i; ++i)
      {
        int v38 = objc_autoreleasePoolPush();
        int v39 = v9[i];
        if (v39 < 2 || v39 == getpid()) {
          goto LABEL_61;
        }
        int v40 = *(_DWORD *)(a1 + 60);
        if (v40)
        {
          double v41 = *(double *)&qword_1000E7D28 + (double)v40;
          if (v41 - CFAbsoluteTimeGetCurrent() < 10.0) {
            goto LABEL_59;
          }
        }

        if (sub_10002578C(v9[i]))
        {
          bzero(buf, 0x400uLL);
          if (proc_pidpath(v9[i], buf, 0x400u) < 1
            || !strnstr((const char *)buf, "dext", 0x400uLL)
            && !strnstr((const char *)buf, "/DriverExtensions/", 0x400uLL))
          {
            if (!dispatch_semaphore_wait(dsema, timeout))
            {
              int v43 = *(_DWORD *)(a1 + 60);
              if (v43)
              {
                double v44 = *(double *)&qword_1000E7D28 + (double)v43;
                if (v44 - CFAbsoluteTimeGetCurrent() < 10.0)
                {
                  uint64_t v52 = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"\nOut of time, skipping heap/ddt for %d\n",  v9[i],  v165,  v166);
                  goto LABEL_78;
                }
              }

              if (!sub_10002578C(v9[i]))
              {
                uint64_t v52 = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"[%d] has exited, cannot take heap/ddt\n",  v9[i],  v165,  v166);
                goto LABEL_78;
              }

              snprintf(__str, 8uLL, "%d", v9[i]);
              v227[0] = "/usr/bin/heap";
              v227[1] = "--addresses=.*transaction.*";
              v227[2] = "--forkCorpseRetryTime=0";
              v227[3] = __str;
              v227[4] = 0LL;
              int v219 = -1;
              int v218 = -1;
              LOBYTE(v165) = 0;
              unsigned int v45 = SASpawnPlatformBinaryWithSigningIdentifier( "/usr/bin/heap",  "com.apple.dt.SamplingTools.heap",  v227,  0LL,  0LL,  0LL,  &v219,  0LL,  &v218,  v165,  0LL);
              __int16 v207 = v7;
              id v208 = v36;
              if ((v45 & 0x80000000) == 0)
              {
                unsigned int v198 = v45;
                if (byte_1000E7D30)
                {
                  int cf = *__error();
                  id v46 = (os_log_s *)sub_10002EFA0();
                  if (os_log_type_enabled(v46, OS_LOG_TYPE_DEBUG))
                  {
                    unsigned int v104 = v9[i];
                    *(_DWORD *)__int16 v221 = 136315394;
                    *(void *)id v222 = buf;
                    *(_WORD *)&v222[8] = 1024;
                    *(_DWORD *)&v222[10] = v104;
                    _os_log_debug_impl( (void *)&_mh_execute_header,  v46,  OS_LOG_TYPE_DEBUG,  "Running heap for %s [%d]",  v221,  0x12u);
                  }

                  *__error() = cf;
                }

                if (byte_1000E7D31 && dword_1000E74E0 <= 0)
                {
                  int v47 = *__error();
                  id v48 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"Running heap for %s [%d]",  buf,  v9[i]);
                  if (v48)
                  {
                    int v172 = v47;
                    id v49 = v48;
                    id v50 = CFStringGetCStringPtr(v48, 0x8000100u);
                    cfa = v49;
                    if (v50)
                    {
                      id v51 = (char *)v50;
                      id v167 = 0LL;
                    }

                    else
                    {
                      id v51 = (char *)calloc(0x400uLL, 1uLL);
                      CFStringGetCString(v49, v51, 1024LL, 0x8000100u);
                      id v167 = v51;
                    }

                    if (qword_1000E7D38) {
                      id v73 = (FILE *)qword_1000E7D38;
                    }
                    else {
                      id v73 = __stderrp;
                    }
                    fprintf(v73, "%s\n", v51);
                    int v47 = v172;
                    if (v167) {
                      free(v167);
                    }
                    CFRelease(cfa);
                  }

                  else
                  {
                    id v71 = (os_log_s *)sub_10002EFA0();
                    if (os_log_type_enabled(v71, OS_LOG_TYPE_FAULT))
                    {
                      unsigned int v117 = v9[i];
                      *(_DWORD *)__int16 v221 = 136315394;
                      *(void *)id v222 = buf;
                      *(_WORD *)&v222[8] = 1024;
                      *(_DWORD *)&v222[10] = v117;
                      _os_log_fault_impl( (void *)&_mh_execute_header,  v71,  OS_LOG_TYPE_FAULT,  "Unable to format: Running heap for %s [%d]",  v221,  0x12u);
                    }

                    if (qword_1000E7D38) {
                      id v72 = (FILE *)qword_1000E7D38;
                    }
                    else {
                      id v72 = __stderrp;
                    }
                    fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v72);
                  }

                  *__error() = v47;
                }

                dispatch_retain(object);
                id v74 = dsema;
                dispatch_retain(dsema);
                dispatch_group_enter(object);
                id v75 = -[NSMutableString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSMutableString),  "initWithFormat:",  @"\nheap --addresses=.*transaction.* --forkCorpseRetryTime=0 %d\n",  v9[i]);
                -[NSMutableArray addObject:](v208, "addObject:", v75);
                v216[0] = _NSConcreteStackBlock;
                v216[1] = 3221225472LL;
                v216[2] = sub_100059A24;
                v216[3] = &unk_1000D9638;
                int v217 = i;
                v216[4] = v75;
                v216[5] = dsema;
                v216[6] = object;
                v216[7] = v9;
                sub_1000597B0(v198, v219, v218, (uint64_t)v75, (uint64_t)v216);
LABEL_127:
                if (dispatch_semaphore_wait(v74, timeout))
                {
                  __darwin_time_t v36 = v208;
                  -[NSMutableArray addObject:]( v208,  "addObject:",  +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"\nOut of time, skipping ddt for %d\n",  v9[i]));
LABEL_129:
                  uintptr_t v7 = v207;
                  goto LABEL_61;
                }

                int v81 = *(_DWORD *)(a1 + 60);
                uintptr_t v7 = v207;
                __darwin_time_t v36 = v208;
                if (v81 && (double v82 = *(double *)&qword_1000E7D28 + (double)v81, v82 - CFAbsoluteTimeGetCurrent() < 10.0))
                {
                  uint64_t v52 = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"\nOut of time, skipping ddt for %d\n",  v9[i],  v165,  v166);
                }

                else if (sub_10002578C(v9[i]))
                {
                  v220[0] = "/usr/local/bin/ddt";
                  v220[1] = __str;
                  v220[2] = 0LL;
                  int v215 = -1;
                  int v214 = -1;
                  LOBYTE(v165) = 0;
                  unsigned int v83 = SASpawnPlatformBinaryWithSigningIdentifier( "/usr/local/bin/ddt",  "com.apple.ddt",  v220,  0LL,  0LL,  0LL,  &v215,  0LL,  &v214,  v165,  0LL);
                  if ((v83 & 0x80000000) == 0)
                  {
                    unsigned int v203 = v83;
                    if (byte_1000E7D30)
                    {
                      int v84 = *__error();
                      id v85 = (os_log_s *)sub_10002EFA0();
                      if (os_log_type_enabled(v85, OS_LOG_TYPE_DEBUG))
                      {
                        unsigned int v125 = v9[i];
                        *(_DWORD *)__int16 v221 = 136315394;
                        *(void *)id v222 = buf;
                        *(_WORD *)&v222[8] = 1024;
                        *(_DWORD *)&v222[10] = v125;
                        _os_log_debug_impl( (void *)&_mh_execute_header,  v85,  OS_LOG_TYPE_DEBUG,  "Running ddt for %s [%d]",  v221,  0x12u);
                      }

                      *__error() = v84;
                    }

                    if (byte_1000E7D31 && dword_1000E74E0 <= 0)
                    {
                      int v86 = *__error();
                      id v87 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"Running ddt for %s [%d]",  buf,  v9[i]);
                      if (v87)
                      {
                        int v176 = v86;
                        id v88 = v87;
                        id v89 = CFStringGetCStringPtr(v87, 0x8000100u);
                        cfc = v88;
                        if (v89)
                        {
                          id v90 = (char *)v89;
                          id v91 = 0LL;
                        }

                        else
                        {
                          id v90 = (char *)calloc(0x400uLL, 1uLL);
                          CFStringGetCString(v88, v90, 1024LL, 0x8000100u);
                          id v91 = v90;
                        }

                        if (qword_1000E7D38) {
                          id v113 = (FILE *)qword_1000E7D38;
                        }
                        else {
                          id v113 = __stderrp;
                        }
                        fprintf(v113, "%s\n", v90);
                        int v86 = v176;
                        if (v91) {
                          free(v91);
                        }
                        CFRelease(cfc);
                      }

                      else
                      {
                        id v111 = (os_log_s *)sub_10002EFA0();
                        if (os_log_type_enabled(v111, OS_LOG_TYPE_FAULT))
                        {
                          unsigned int v130 = v9[i];
                          *(_DWORD *)__int16 v221 = 136315394;
                          *(void *)id v222 = buf;
                          *(_WORD *)&v222[8] = 1024;
                          *(_DWORD *)&v222[10] = v130;
                          _os_log_fault_impl( (void *)&_mh_execute_header,  v111,  OS_LOG_TYPE_FAULT,  "Unable to format: Running ddt for %s [%d]",  v221,  0x12u);
                        }

                        if (qword_1000E7D38) {
                          id v112 = (FILE *)qword_1000E7D38;
                        }
                        else {
                          id v112 = __stderrp;
                        }
                        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v112);
                      }

                      *__error() = v86;
                    }

                    dispatch_retain(object);
                    dispatch_retain(dsema);
                    dispatch_group_enter(object);
                    id v114 = -[NSMutableString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSMutableString),  "initWithFormat:",  @"\nddt %d\n",  v9[i]);
                    __darwin_time_t v36 = v208;
                    -[NSMutableArray addObject:](v208, "addObject:", v114);
                    v212[0] = _NSConcreteStackBlock;
                    v212[1] = 3221225472LL;
                    v212[2] = sub_100059EB8;
                    v212[3] = &unk_1000D9638;
                    int v213 = i;
                    v212[4] = v114;
                    v212[5] = dsema;
                    v212[6] = object;
                    v212[7] = v9;
                    sub_1000597B0(v203, v215, v214, (uint64_t)v114, (uint64_t)v212);
                    goto LABEL_129;
                  }

                  if ((v9[i] & 0x80000000) != 0)
                  {
                    if (byte_1000E7D30)
                    {
                      int v206 = *__error();
                      id v105 = (os_log_s *)sub_10002EFA0();
                      if (os_log_type_enabled(v105, OS_LOG_TYPE_ERROR))
                      {
                        int cfl = *__error();
                        id v131 = __error();
                        id v132 = strerror(*v131);
                        *(_DWORD *)__int16 v221 = 67109378;
                        *(_DWORD *)id v222 = cfl;
                        *(_WORD *)&v222[4] = 2080;
                        *(void *)&v222[6] = v132;
                        _os_log_error_impl( (void *)&_mh_execute_header,  v105,  OS_LOG_TYPE_ERROR,  "Unable to spawn ddt: %d (%s)",  v221,  0x12u);
                      }

                      *__error() = v206;
                    }

                    if (byte_1000E7D31 && dword_1000E74E0 <= 3)
                    {
                      int v205 = *__error();
                      uint64_t v106 = *__error();
                      id v107 = __error();
                      id v108 = strerror(*v107);
                      id v97 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"Unable to spawn ddt: %d (%s)",  v106,  v108);
                      if (v97) {
                        goto LABEL_162;
                      }
                      id v121 = (os_log_s *)sub_10002EFA0();
                      if (os_log_type_enabled(v121, OS_LOG_TYPE_FAULT))
                      {
                        int cfo = *__error();
                        id v133 = __error();
                        id v134 = strerror(*v133);
                        *(_DWORD *)__int16 v221 = 67109378;
                        *(_DWORD *)id v222 = cfo;
                        *(_WORD *)&v222[4] = 2080;
                        *(void *)&v222[6] = v134;
                        id v101 = v121;
                        id v102 = "Unable to format: Unable to spawn ddt: %d (%s)";
                        uint32_t v103 = 18;
LABEL_196:
                        _os_log_fault_impl((void *)&_mh_execute_header, v101, OS_LOG_TYPE_FAULT, v102, v221, v103);
                      }

LABEL_162:
                      cfd = v97;
                      id v109 = CFStringGetCStringPtr(v97, 0x8000100u);
                      if (v109)
                      {
                        id v110 = (char *)v109;
                        id v179 = 0LL;
                      }

                      else
                      {
                        id v110 = (char *)calloc(0x400uLL, 1uLL);
                        CFStringGetCString(cfd, v110, 1024LL, 0x8000100u);
                        id v179 = v110;
                      }

                      if (qword_1000E7D38) {
                        id v118 = (FILE *)qword_1000E7D38;
                      }
                      else {
                        id v118 = __stderrp;
                      }
                      fprintf(v118, "%s\n", v110);
                      if (v179) {
                        free(v179);
                      }
                      CFRelease(cfd);
                      goto LABEL_191;
                    }
                  }

                  CFTypeRef cfm = (CFTypeRef)v9[i];
                  uint64_t v123 = *__error();
                  id v124 = __error();
                  uint64_t v52 = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Unable to spawn ddt for %d: %d %s\n",  cfm,  v123,  strerror(*v124));
                }

                else
                {
                  uint64_t v52 = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"[%d] has exited, cannot take ddt\n",  v9[i],  v165,  v166);
                }

LABEL_121:
                  if (qword_1000E7D38) {
                    int v78 = (FILE *)qword_1000E7D38;
                  }
                  else {
                    int v78 = __stderrp;
                  }
                  fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v78);
LABEL_125:
                  *__error() = v200;
                }
              }

              else
              {
                if (byte_1000E7D30)
                {
                  int v199 = *__error();
                  BOOL v53 = (os_log_s *)sub_10002EFA0();
                  if (os_log_type_enabled(v53, OS_LOG_TYPE_ERROR))
                  {
                    id v180 = sub_10002EF3C(v9[i]);
                    unsigned int cfe = v9[i];
                    int v170 = *__error();
                    id v115 = __error();
                    id v116 = strerror(*v115);
                    *(_DWORD *)__int16 v221 = 136446978;
                    *(void *)id v222 = v180;
                    *(_WORD *)&v222[8] = 1024;
                    *(_DWORD *)&v222[10] = cfe;
                    __int16 v223 = 1024;
                    int v224 = v170;
                    __int16 v225 = 2080;
                    id v226 = v116;
                    _os_log_error_impl( (void *)&_mh_execute_header,  v53,  OS_LOG_TYPE_ERROR,  "%{public}s [%d]: Unable to spawn heap: %d (%s)",  v221,  0x22u);
                  }

                  *__error() = v199;
                }

                if (byte_1000E7D31 && dword_1000E74E0 <= 3)
                {
                  int v200 = *__error();
                  int v54 = sub_10002EF3C(v9[i]);
                  id v173 = (void *)v9[i];
                  CFTypeRef cff = v54;
                  uint64_t v55 = *__error();
                  id v56 = __error();
                  __darwin_time_t v57 = strerror(*v56);
                  int v58 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"%s [%d]: Unable to spawn heap: %d (%s)",  cff,  v173,  v55,  v57);
                  if (!v58)
                  {
                    int v59 = (os_log_s *)sub_10002EFA0();
                    if (os_log_type_enabled(v59, OS_LOG_TYPE_FAULT))
                    {
                      id v174 = sub_10002EF3C(v9[i]);
                      unsigned int cfg = v9[i];
                      int v168 = *__error();
                      double v60 = __error();
                      uint64_t v61 = strerror(*v60);
                      *(_DWORD *)__int16 v221 = 136315906;
                      *(void *)id v222 = v174;
                      *(_WORD *)&v222[8] = 1024;
                      *(_DWORD *)&v222[10] = cfg;
                      __int16 v223 = 1024;
                      int v224 = v168;
                      __int16 v225 = 2080;
                      id v226 = v61;
                      int v62 = v59;
                      uint64_t v63 = "Unable to format: %s [%d]: Unable to spawn heap: %d (%s)";
                      uint32_t v64 = 34;
                      goto LABEL_194;
                    }

                    goto LABEL_121;
                  }

LABEL_96:
                  cfb = v58;
                  id v69 = CFStringGetCStringPtr(v58, 0x8000100u);
                  if (v69)
                  {
                    id v70 = (char *)v69;
                    id v175 = 0LL;
                  }

                  else
                  {
                    id v70 = (char *)calloc(0x400uLL, 1uLL);
                    CFStringGetCString(cfb, v70, 1024LL, 0x8000100u);
                    id v175 = v70;
                  }

                  if (qword_1000E7D38) {
                    id v76 = (FILE *)qword_1000E7D38;
                  }
                  else {
                    id v76 = __stderrp;
                  }
                  fprintf(v76, "%s\n", v70);
                  if (v175) {
                    free(v175);
                  }
                  CFRelease(cfb);
                  goto LABEL_125;
                }
              }

              uint64_t v202 = v9[i];
              uint64_t v79 = *__error();
              id v80 = __error();
              -[NSMutableArray addObject:]( v36,  "addObject:",  +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Unable to spawn heap for %d: %d %s\n",  v202,  v79,  strerror(*v80)));
              id v74 = dsema;
              dispatch_semaphore_signal(dsema);
              goto LABEL_127;
            }

  hidEventSem = self->_hidEventSem;
  uint64_t v55 = dispatch_time(0LL, 60000000000LL);
  if (!dispatch_semaphore_wait((dispatch_semaphore_t)hidEventSem, v55))
  {
    if (-[SPProcessEvent eventTimeRange](self, "eventTimeRange"))
    {
      if (objc_msgSend( -[SATimeRange startTime](-[SPProcessEvent eventTimeRange](self, "eventTimeRange"), "startTime"),  "compare:",  objc_msgSend(a3, "timestamp")) == (id)-1 && objc_msgSend( -[SATimeRange endTime](-[SPProcessEvent eventTimeRange](self, "eventTimeRange"), "endTime"),  "compare:",  self->_startedMonitoringTimestamp) == (id)1)
      {
        if ((*v8 & 0x80000000) != 0)
        {
          if (byte_1000E7D30)
          {
            uint64_t v106 = *__error();
            id v107 = (os_log_s *)sub_10002EFA0();
            if (os_log_type_enabled(v107, OS_LOG_TYPE_DEBUG)) {
              sub_1000917CC();
            }
            *__error() = v106;
          }

          if (!byte_1000E7D31 || dword_1000E74E0 > 0) {
            goto LABEL_234;
          }
          uint64_t v66 = *__error();
          id v108 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"Received HID event, reporting spin");
          if (v108)
          {
            id v109 = v108;
            id v110 = CFStringGetCStringPtr(v108, 0x8000100u);
            if (v110)
            {
              id v111 = (char *)v110;
              id v112 = 0LL;
            }

            else
            {
              id v111 = (char *)calloc(0x400uLL, 1uLL);
              CFStringGetCString(v109, v111, 1024LL, 0x8000100u);
              id v112 = v111;
            }

            if (qword_1000E7D38) {
              id v121 = (FILE *)qword_1000E7D38;
            }
            else {
              id v121 = __stderrp;
            }
            fprintf(v121, "%s\n", v111);
            if (v112) {
              free(v112);
            }
            id v118 = v109;
            goto LABEL_232;
          }

          id v119 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v119, OS_LOG_TYPE_FAULT)) {
            sub_1000917A0();
          }
        }

        else
        {
          if (byte_1000E7D30)
          {
            uint32_t v64 = *__error();
            int v65 = (os_log_s *)sub_10002EFA0();
            if (os_log_type_enabled(v65, OS_LOG_TYPE_DEBUG)) {
              sub_100091734();
            }
            *__error() = v64;
          }

          if (!byte_1000E7D31 || dword_1000E74E0 > 0) {
            goto LABEL_234;
          }
          uint64_t v66 = *__error();
          id v67 = sub_10002EF3C(*v8);
          id v68 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"%s [%d]: Received HID event, reporting spin",  v67,  *v8);
          if (v68)
          {
            id v69 = v68;
            id v70 = CFStringGetCStringPtr(v68, 0x8000100u);
            if (v70)
            {
              id v71 = (char *)v70;
              id v72 = 0LL;
            }

            else
            {
              id v71 = (char *)calloc(0x400uLL, 1uLL);
              CFStringGetCString(v69, v71, 1024LL, 0x8000100u);
              id v72 = v71;
            }

            if (qword_1000E7D38) {
              unsigned int v117 = (FILE *)qword_1000E7D38;
            }
            else {
              unsigned int v117 = __stderrp;
            }
            fprintf(v117, "%s\n", v71);
            if (v72) {
              free(v72);
            }
            id v118 = v69;
LABEL_232:
            CFRelease(v118);
LABEL_233:
            *__error() = v66;
LABEL_234:
            if (v4 == 3) {
              LOBYTE(v4) = 4;
            }
            goto LABEL_88;
          }

          id v116 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v116, OS_LOG_TYPE_FAULT)) {
            sub_1000916C8();
          }
        }

        if (qword_1000E7D38) {
          id v120 = (FILE *)qword_1000E7D38;
        }
        else {
          id v120 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v120);
        goto LABEL_233;
      }

      if ((*v8 & 0x80000000) != 0)
      {
        if (byte_1000E7D30)
        {
          uint64_t v94 = *__error();
          id v95 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v95, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)buf = 0;
            _os_log_impl( (void *)&_mh_execute_header,  v95,  OS_LOG_TYPE_DEFAULT,  "Canceling spin with no HID event in its time range",  buf,  2u);
          }

          *__error() = v94;
        }

        LOBYTE(v4) = 8;
        if (!byte_1000E7D31 || dword_1000E74E0 > 2) {
          goto LABEL_206;
        }
        unsigned int v83 = *__error();
        id v85 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"Canceling spin with no HID event in its time range");
        if (!v85)
        {
          id v96 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v96, OS_LOG_TYPE_FAULT)) {
            sub_100091864();
          }
          goto LABEL_200;
        }
      }

      else
      {
        if (byte_1000E7D30)
        {
          uint64_t v79 = *__error();
          id v80 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v80, OS_LOG_TYPE_DEFAULT))
          {
            int v81 = sub_10002EF3C(*v8);
            double v82 = *v8;
            *(_DWORD *)buf = 136446466;
            id v128 = v81;
            id v129 = 1024;
            unsigned int v130 = v82;
            _os_log_impl( (void *)&_mh_execute_header,  v80,  OS_LOG_TYPE_DEFAULT,  "%{public}s [%d]: Canceling spin with no HID event in its time range",  buf,  0x12u);
          }

          *__error() = v79;
        }

        LOBYTE(v4) = 8;
        if (!byte_1000E7D31 || dword_1000E74E0 > 2) {
          goto LABEL_206;
        }
        unsigned int v83 = *__error();
        int v84 = sub_10002EF3C(*v8);
        id v85 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"%s [%d]: Canceling spin with no HID event in its time range",  v84,  *v8);
        if (!v85)
        {
          int v86 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v86, OS_LOG_TYPE_FAULT)) {
            sub_1000917F8();
          }
LABEL_200:
          if (qword_1000E7D38) {
            id v114 = (FILE *)qword_1000E7D38;
          }
          else {
            id v114 = __stderrp;
          }
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v114);
LABEL_204:
          *__error() = v83;
          goto LABEL_205;
        }
      }
    }

    else if ((*v8 & 0x80000000) != 0)
    {
      if (byte_1000E7D30)
      {
        id v97 = *__error();
        id v98 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v98, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v98,  OS_LOG_TYPE_DEFAULT,  "Canceling spin with no HID event where process exited",  buf,  2u);
        }

        *__error() = v97;
      }

      LOBYTE(v4) = 8;
      if (!byte_1000E7D31 || dword_1000E74E0 > 2) {
        goto LABEL_206;
      }
      unsigned int v83 = *__error();
      id v85 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"Canceling spin with no HID event where process exited");
      if (!v85)
      {
        id v113 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v113, OS_LOG_TYPE_FAULT)) {
          sub_10009169C();
        }
        goto LABEL_200;
      }
    }

    else
    {
      if (byte_1000E7D30)
      {
        id v87 = *__error();
        id v88 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v88, OS_LOG_TYPE_DEFAULT))
        {
          id v89 = sub_10002EF3C(*v8);
          id v90 = *v8;
          *(_DWORD *)buf = 136446466;
          id v128 = v89;
          id v129 = 1024;
          unsigned int v130 = v90;
          _os_log_impl( (void *)&_mh_execute_header,  v88,  OS_LOG_TYPE_DEFAULT,  "%{public}s [%d]: Canceling spin with no HID event where process exited",  buf,  0x12u);
        }

        *__error() = v87;
      }

      LOBYTE(v4) = 8;
      if (!byte_1000E7D31 || dword_1000E74E0 > 2) {
        goto LABEL_206;
      }
      unsigned int v83 = *__error();
      id v91 = sub_10002EF3C(*v8);
      id v85 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"%s [%d]: Canceling spin with no HID event where process exited",  v91,  *v8);
      if (!v85)
      {
        id v92 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v92, OS_LOG_TYPE_FAULT)) {
          sub_100091630();
        }
        goto LABEL_200;
      }
    }

    id v99 = v85;
    id v100 = CFStringGetCStringPtr(v85, 0x8000100u);
    if (v100)
    {
      id v101 = (char *)v100;
      id v102 = 0LL;
    }

    else
    {
      id v101 = (char *)calloc(0x400uLL, 1uLL);
      CFStringGetCString(v99, v101, 1024LL, 0x8000100u);
      id v102 = v101;
    }

    if (qword_1000E7D38) {
      id v105 = (FILE *)qword_1000E7D38;
    }
    else {
      id v105 = __stderrp;
    }
    fprintf(v105, "%s\n", v101);
    if (v102) {
      free(v102);
    }
    CFRelease(v99);
    goto LABEL_204;
  }

  if ((*v8 & 0x80000000) != 0)
  {
    if (byte_1000E7D30)
    {
      id v73 = *__error();
      id v74 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v74, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v74,  OS_LOG_TYPE_DEFAULT,  "Timed out waiting for HID event, canceling spin",  buf,  2u);
      }

      *__error() = v73;
    }

    if (!byte_1000E7D31 || dword_1000E74E0 > 2) {
      goto LABEL_181;
    }
    double v60 = *__error();
    int v62 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"Timed out waiting for HID event, canceling spin");
    if (!v62)
    {
      uint32_t v103 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v103, OS_LOG_TYPE_FAULT)) {
        sub_1000918FC();
      }
      goto LABEL_176;
    }

LABEL_59:
            int v42 = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"\nOut of time, skipping heap/ddt for %d\n",  v9[i]);
            goto LABEL_60;
          }

          int v42 = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"[%d] is DriverKit, skipping heap/ddt\n",  v9[i]);
        }

        else
        {
          int v42 = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"[%d] has exited, cannot take heap/ddt\n",  v9[i]);
        }

LABEL_60:
        -[NSMutableArray addObject:](v36, "addObject:", v42);
LABEL_61:
        objc_autoreleasePoolPop(v38);
      }
    }

    if (dispatch_group_wait(object, timeout))
    {
      if (byte_1000E7D30)
      {
        int v135 = *__error();
        id v136 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v136, OS_LOG_TYPE_ERROR)) {
          sub_10008CF64();
        }
        *__error() = v135;
      }

      if (byte_1000E7D31) {
        BOOL v137 = dword_1000E74E0 <= 3;
      }
      else {
        BOOL v137 = 0;
      }
      if (v137)
      {
        int v138 = *__error();
        id v139 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"Timed out running heap/ddt for all (%d) processes",  v11);
        if (v139)
        {
          id v140 = v139;
          id v141 = CFStringGetCStringPtr(v139, 0x8000100u);
          if (v141)
          {
            id v142 = (char *)v141;
            id v143 = 0LL;
          }

          else
          {
            id v142 = (char *)calloc(0x400uLL, 1uLL);
            CFStringGetCString(v140, v142, 1024LL, 0x8000100u);
            id v143 = v142;
          }

          if (qword_1000E7D38) {
            id v157 = (FILE *)qword_1000E7D38;
          }
          else {
            id v157 = __stderrp;
          }
          fprintf(v157, "%s\n", v142);
          if (v143) {
            free(v143);
          }
          CFRelease(v140);
        }

        else
        {
          id v153 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v153, OS_LOG_TYPE_FAULT)) {
            sub_10008CF00();
          }
          if (qword_1000E7D38) {
            id v154 = (FILE *)qword_1000E7D38;
          }
          else {
            id v154 = __stderrp;
          }
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v154);
        }

        *__error() = v138;
      }

      -[NSMutableString appendFormat:]( v7,  "appendFormat:",  @"Timed out waiting for heap/ddt, last %d heap/ddt invocations may be truncated\n",  8LL);
    }

    else
    {
      if (byte_1000E7D30)
      {
        int v144 = *__error();
        id v145 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v145, OS_LOG_TYPE_INFO))
        {
          *(_DWORD *)buf = 67109120;
          int v230 = v11;
          _os_log_impl( (void *)&_mh_execute_header,  v145,  OS_LOG_TYPE_INFO,  "Done running heap/ddt for all (%d) processes",  buf,  8u);
        }

        *__error() = v144;
      }

      if (byte_1000E7D31) {
        BOOL v146 = dword_1000E74E0 <= 1;
      }
      else {
        BOOL v146 = 0;
      }
      if (v146)
      {
        int v147 = *__error();
        id v148 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"Done running heap/ddt for all (%d) processes",  v11);
        if (v148)
        {
          id v149 = v148;
          id v150 = CFStringGetCStringPtr(v148, 0x8000100u);
          if (v150)
          {
            id v151 = (char *)v150;
            id v152 = 0LL;
          }

          else
          {
            id v151 = (char *)calloc(0x400uLL, 1uLL);
            CFStringGetCString(v149, v151, 1024LL, 0x8000100u);
            id v152 = v151;
          }

          if (qword_1000E7D38) {
            id v163 = (FILE *)qword_1000E7D38;
          }
          else {
            id v163 = __stderrp;
          }
          fprintf(v163, "%s\n", v151);
          if (v152) {
            free(v152);
          }
          CFRelease(v149);
        }

        else
        {
          id v158 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v158, OS_LOG_TYPE_FAULT)) {
            sub_10008CE9C();
          }
          if (qword_1000E7D38) {
            id v159 = (FILE *)qword_1000E7D38;
          }
          else {
            id v159 = __stderrp;
          }
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v159);
        }

        *__error() = v147;
      }
    }

    dispatch_release(object);
    dispatch_release(dsema);
    -[NSMutableString appendString:]( v7,  "appendString:",  -[NSMutableArray componentsJoinedByString:](v36, "componentsJoinedByString:", &stru_1000DCBB0));
  }

  [a2 setCustomOutput:v7];

  return [a2 performSamplePrinterWork:&stru_1000D9678];
}

int sub_1000597A0(id a1, const void *a2, const void *a3)
{
  return *(_DWORD *)a2 - *(_DWORD *)a3;
}

void sub_1000597B0(unsigned int a1, int a2, int a3, uint64_t a4, uint64_t a5)
{
  unint64_t v9 = dispatch_queue_attr_make_with_autorelease_frequency(0LL, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
  uint64_t v10 = dispatch_queue_create("com.apple.spindump.readchildren", v9);
  fcntl(a2, 4, 4LL);
  fcntl(a3, 4, 4LL);
  v28[0] = 0LL;
  v28[1] = v28;
  v28[2] = 0x2020000000LL;
  v28[3] = calloc(1uLL, 0x400uLL);
  uint64_t v11 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_read, a2, 0LL, v10);
  handler[0] = _NSConcreteStackBlock;
  handler[1] = 3221225472LL;
  handler[2] = sub_10005D2C0;
  handler[3] = &unk_1000D97B0;
  int v27 = a2;
  void handler[4] = a4;
  void handler[5] = v28;
  dispatch_source_set_event_handler(v11, handler);
  v24[0] = _NSConcreteStackBlock;
  v24[1] = 3221225472LL;
  v24[2] = sub_10005D358;
  v24[3] = &unk_1000D97D8;
  int v25 = a2;
  v24[4] = v11;
  dispatch_source_set_cancel_handler(v11, v24);
  dispatch_activate(v11);
  int v12 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_read, a3, 0LL, v10);
  v22[0] = _NSConcreteStackBlock;
  v22[1] = 3221225472LL;
  v22[2] = sub_10005D380;
  v22[3] = &unk_1000D97B0;
  int v23 = a3;
  v22[4] = a4;
  v22[5] = v28;
  dispatch_source_set_event_handler(v12, v22);
  v20[0] = _NSConcreteStackBlock;
  v20[1] = 3221225472LL;
  v20[2] = sub_10005D418;
  v20[3] = &unk_1000D97D8;
  int v21 = a3;
  v20[4] = v12;
  dispatch_source_set_cancel_handler(v12, v20);
  dispatch_activate(v12);
  int v13 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_proc, a1, 0x80000000uLL, v10);
  v16[0] = _NSConcreteStackBlock;
  v16[1] = 3221225472LL;
  v16[2] = sub_10005D440;
  v16[3] = &unk_1000D9800;
  v16[4] = v11;
  void v16[5] = v12;
  unsigned int v17 = a1;
  int v18 = a2;
  int v19 = a3;
  v16[6] = v13;
  v16[7] = a4;
  v16[9] = v28;
  void v16[8] = a5;
  dispatch_source_set_event_handler(v13, v16);
  v15[0] = _NSConcreteStackBlock;
  v15[1] = 3221225472LL;
  v15[2] = sub_10005D5D8;
  v15[3] = &unk_1000D95B0;
  v15[4] = v13;
  dispatch_source_set_cancel_handler(v13, v15);
  dispatch_activate(v13);
  dispatch_release(v10);
  _Block_object_dispose(v28, 8);
}

void sub_100059A24(uint64_t a1)
{
  if (![*(id *)(a1 + 32) length])
  {
    int v2 = (void *)(a1 + 56);
    BOOL v3 = (int *)(a1 + 64);
    if ((*(_DWORD *)(*(void *)(a1 + 56) + 4LL * *(int *)(a1 + 64)) & 0x80000000) != 0)
    {
      if (byte_1000E7D30)
      {
        int v11 = *__error();
        int v12 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR)) {
          sub_10008D23C();
        }
        *__error() = v11;
      }

      if (byte_1000E7D31) {
        BOOL v13 = dword_1000E74E0 <= 3;
      }
      else {
        BOOL v13 = 0;
      }
      if (!v13) {
        goto LABEL_41;
      }
      int v7 = *__error();
      unint64_t v9 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"No output from heap for %d",  *(unsigned int *)(*v2 + 4LL * *v3));
      if (!v9)
      {
        int v19 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v19, OS_LOG_TYPE_FAULT)) {
          sub_10008D1D4();
        }
        goto LABEL_36;
      }
    }

    else
    {
      if (byte_1000E7D30)
      {
        int v4 = *__error();
        BOOL v5 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR)) {
          sub_10008D164();
        }
        *__error() = v4;
      }

      if (byte_1000E7D31) {
        BOOL v6 = dword_1000E74E0 <= 3;
      }
      else {
        BOOL v6 = 0;
      }
      if (!v6) {
        goto LABEL_41;
      }
      int v7 = *__error();
      int v8 = sub_10002EF3C(*(_DWORD *)(*v2 + 4LL * *v3));
      unint64_t v9 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"%s [%d]: No output from heap for %d",  v8,  *(unsigned int *)(*v2 + 4LL * *v3),  *(unsigned int *)(*v2 + 4LL * *v3));
      if (!v9)
      {
        uint64_t v10 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v10, OS_LOG_TYPE_FAULT)) {
          sub_10008D0F4();
        }
LABEL_36:
        if (qword_1000E7D38) {
          int v20 = (FILE *)qword_1000E7D38;
        }
        else {
          int v20 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v20);
LABEL_40:
        *__error() = v7;
LABEL_41:
        objc_msgSend( *(id *)(a1 + 32),  "appendFormat:",  @"No output from heap for %d\n",  *(unsigned int *)(*(void *)(a1 + 56) + 4 * *(int *)(a1 + 64)));
        goto LABEL_42;
      }
    }

    int v14 = v9;
    CStringPtr = CFStringGetCStringPtr(v9, 0x8000100u);
    if (CStringPtr)
    {
      int v16 = (char *)CStringPtr;
      unsigned int v17 = 0LL;
    }

    else
    {
      int v16 = (char *)calloc(0x400uLL, 1uLL);
      CFStringGetCString(v14, v16, 1024LL, 0x8000100u);
      unsigned int v17 = v16;
    }

    if (qword_1000E7D38) {
      int v18 = (FILE *)qword_1000E7D38;
    }
    else {
      int v18 = __stderrp;
    }
    fprintf(v18, "%s\n", v16);
    if (v17) {
      free(v17);
    }
    CFRelease(v14);
    goto LABEL_40;
  }

LABEL_42:
  if (byte_1000E7D30)
  {
    int v21 = *__error();
    int v22 = (os_log_s *)sub_10002EFA0();
    if (os_log_type_enabled(v22, OS_LOG_TYPE_DEBUG)) {
      sub_10008D094();
    }
    *__error() = v21;
  }

  if (byte_1000E7D31) {
    BOOL v23 = dword_1000E74E0 <= 0;
  }
  else {
    BOOL v23 = 0;
  }
  if (v23)
  {
    int v24 = *__error();
    int v25 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"heap for [%d] completed",  *(unsigned int *)(*(void *)(a1 + 56) + 4LL * *(int *)(a1 + 64)));
    if (v25)
    {
      BOOL v26 = v25;
      int v27 = CFStringGetCStringPtr(v25, 0x8000100u);
      if (v27)
      {
        int v28 = (char *)v27;
        uint64_t v29 = 0LL;
      }

      else
      {
        int v28 = (char *)calloc(0x400uLL, 1uLL);
        CFStringGetCString(v26, v28, 1024LL, 0x8000100u);
        uint64_t v29 = v28;
      }

      if (qword_1000E7D38) {
        BOOL v32 = (FILE *)qword_1000E7D38;
      }
      else {
        BOOL v32 = __stderrp;
      }
      fprintf(v32, "%s\n", v28);
      if (v29) {
        free(v29);
      }
      CFRelease(v26);
    }

    else
    {
      uint32_t v30 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v30, OS_LOG_TYPE_FAULT)) {
        sub_10008D02C();
      }
      if (qword_1000E7D38) {
        int v31 = (FILE *)qword_1000E7D38;
      }
      else {
        int v31 = __stderrp;
      }
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v31);
    }

    *__error() = v24;
  }

  dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 40));
  dispatch_group_leave(*(dispatch_group_t *)(a1 + 48));
  dispatch_release(*(dispatch_object_t *)(a1 + 48));
  dispatch_release(*(dispatch_object_t *)(a1 + 40));
}

  if (byte_1000E7D30)
  {
    int v21 = *__error();
    int v22 = (os_log_s *)sub_10002EFA0();
    if (os_log_type_enabled(v22, OS_LOG_TYPE_DEBUG)) {
      sub_10008D30C();
    }
    *__error() = v21;
  }

  if (byte_1000E7D31) {
    BOOL v23 = dword_1000E74E0 <= 0;
  }
  else {
    BOOL v23 = 0;
  }
  if (v23)
  {
    int v24 = *__error();
    int v25 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"ddt for [%d] completed",  *(unsigned int *)(*(void *)(a1 + 56) + 4LL * *(int *)(a1 + 64)));
    if (v25)
    {
      BOOL v26 = v25;
      int v27 = CFStringGetCStringPtr(v25, 0x8000100u);
      if (v27)
      {
        int v28 = (char *)v27;
        uint64_t v29 = 0LL;
      }

      else
      {
        int v28 = (char *)calloc(0x400uLL, 1uLL);
        CFStringGetCString(v26, v28, 1024LL, 0x8000100u);
        uint64_t v29 = v28;
      }

      if (qword_1000E7D38) {
        BOOL v32 = (FILE *)qword_1000E7D38;
      }
      else {
        BOOL v32 = __stderrp;
      }
      fprintf(v32, "%s\n", v28);
      if (v29) {
        free(v29);
      }
      CFRelease(v26);
    }

    else
    {
      uint32_t v30 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v30, OS_LOG_TYPE_FAULT)) {
        sub_10008D2A4();
      }
      if (qword_1000E7D38) {
        int v31 = (FILE *)qword_1000E7D38;
      }
      else {
        int v31 = __stderrp;
      }
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v31);
    }

    *__error() = v24;
  }

  dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 40));
  dispatch_group_leave(*(dispatch_group_t *)(a1 + 48));
  dispatch_release(*(dispatch_object_t *)(a1 + 48));
  dispatch_release(*(dispatch_object_t *)(a1 + 40));
}

void sub_100059EB8(uint64_t a1)
{
  if (![*(id *)(a1 + 32) length])
  {
    int v2 = (void *)(a1 + 56);
    BOOL v3 = (int *)(a1 + 64);
    if ((*(_DWORD *)(*(void *)(a1 + 56) + 4LL * *(int *)(a1 + 64)) & 0x80000000) != 0)
    {
      if (byte_1000E7D30)
      {
        int v11 = *__error();
        int v12 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR)) {
          sub_10008D4B4();
        }
        *__error() = v11;
      }

      if (byte_1000E7D31) {
        BOOL v13 = dword_1000E74E0 <= 3;
      }
      else {
        BOOL v13 = 0;
      }
      if (!v13) {
        goto LABEL_41;
      }
      int v7 = *__error();
      unint64_t v9 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"No output from ddt for %d",  *(unsigned int *)(*v2 + 4LL * *v3));
      if (!v9)
      {
        int v19 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v19, OS_LOG_TYPE_FAULT)) {
          sub_10008D44C();
        }
        goto LABEL_36;
      }
    }

    else
    {
      if (byte_1000E7D30)
      {
        int v4 = *__error();
        BOOL v5 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR)) {
          sub_10008D3DC();
        }
        *__error() = v4;
      }

      if (byte_1000E7D31) {
        BOOL v6 = dword_1000E74E0 <= 3;
      }
      else {
        BOOL v6 = 0;
      }
      if (!v6) {
        goto LABEL_41;
      }
      int v7 = *__error();
      int v8 = sub_10002EF3C(*(_DWORD *)(*v2 + 4LL * *v3));
      unint64_t v9 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"%s [%d]: No output from ddt for %d",  v8,  *(unsigned int *)(*v2 + 4LL * *v3),  *(unsigned int *)(*v2 + 4LL * *v3));
      if (!v9)
      {
        uint64_t v10 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v10, OS_LOG_TYPE_FAULT)) {
          sub_10008D36C();
        }
LABEL_36:
        if (qword_1000E7D38) {
          int v20 = (FILE *)qword_1000E7D38;
        }
        else {
          int v20 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v20);
LABEL_40:
        *__error() = v7;
LABEL_41:
        objc_msgSend( *(id *)(a1 + 32),  "appendFormat:",  @"No output from ddt for %d\n",  *(unsigned int *)(*(void *)(a1 + 56) + 4 * *(int *)(a1 + 64)));
        goto LABEL_42;
      }
    }

    int v14 = v9;
    CStringPtr = CFStringGetCStringPtr(v9, 0x8000100u);
    if (CStringPtr)
    {
      int v16 = (char *)CStringPtr;
      unsigned int v17 = 0LL;
    }

    else
    {
      int v16 = (char *)calloc(0x400uLL, 1uLL);
      CFStringGetCString(v14, v16, 1024LL, 0x8000100u);
      unsigned int v17 = v16;
    }

    if (qword_1000E7D38) {
      int v18 = (FILE *)qword_1000E7D38;
    }
    else {
      int v18 = __stderrp;
    }
    fprintf(v18, "%s\n", v16);
    if (v17) {
      free(v17);
    }
    CFRelease(v14);
    goto LABEL_40;
  }

void sub_10005A34C(id a1, SASamplePrinter *a2)
{
  if ((sub_10004B10C(a2, 0LL, 0LL, 4LL, 0LL, 0LL, 0LL, 0LL, 0.0, 0.0, 0LL, 0LL) & 1) != 0)
  {
    if (byte_1000E7D30)
    {
      int v2 = *__error();
      BOOL v3 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Saved shutdown report", buf, 2u);
      }

      *__error() = v2;
    }

    if (byte_1000E7D31) {
      BOOL v4 = dword_1000E74E0 <= 2;
    }
    else {
      BOOL v4 = 0;
    }
    if (v4)
    {
      int v5 = *__error();
      BOOL v6 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"Saved shutdown report");
      if (v6)
      {
        int v16 = v6;
        CStringPtr = CFStringGetCStringPtr(v6, 0x8000100u);
        if (CStringPtr)
        {
          int v18 = (char *)CStringPtr;
          int v19 = 0LL;
        }

        else
        {
          int v18 = (char *)calloc(0x400uLL, 1uLL);
          CFStringGetCString(v16, v18, 1024LL, 0x8000100u);
          int v19 = v18;
        }

        if (qword_1000E7D38) {
          int v24 = (FILE *)qword_1000E7D38;
        }
        else {
          int v24 = __stderrp;
        }
        fprintf(v24, "%s\n", v18);
        if (v19) {
          free(v19);
        }
        CFRelease(v16);
      }

      else
      {
        int v7 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v7, OS_LOG_TYPE_FAULT))
        {
          *(_WORD *)BOOL v26 = 0;
          _os_log_fault_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_FAULT,  "Unable to format: Saved shutdown report",  v26,  2u);
        }

        if (qword_1000E7D38) {
          int v8 = (FILE *)qword_1000E7D38;
        }
        else {
          int v8 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v8);
      }

      *__error() = v5;
    }

    exit(0);
  }

  if (byte_1000E7D30)
  {
    int v9 = *__error();
    uint64_t v10 = (os_log_s *)sub_10002EFA0();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v29 = 0;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "Failed to save shutdown report", v29, 2u);
    }

    *__error() = v9;
  }

  if (byte_1000E7D31) {
    BOOL v11 = dword_1000E74E0 <= 2;
  }
  else {
    BOOL v11 = 0;
  }
  if (v11)
  {
    int v12 = *__error();
    BOOL v13 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"Failed to save shutdown report");
    if (v13)
    {
      int v20 = v13;
      int v21 = CFStringGetCStringPtr(v13, 0x8000100u);
      if (v21)
      {
        int v22 = (char *)v21;
        BOOL v23 = 0LL;
      }

      else
      {
        int v22 = (char *)calloc(0x400uLL, 1uLL);
        CFStringGetCString(v20, v22, 1024LL, 0x8000100u);
        BOOL v23 = v22;
      }

      if (qword_1000E7D38) {
        int v25 = (FILE *)qword_1000E7D38;
      }
      else {
        int v25 = __stderrp;
      }
      fprintf(v25, "%s\n", v22);
      if (v23) {
        free(v23);
      }
      CFRelease(v20);
    }

    else
    {
      int v14 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v14, OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)int v28 = 0;
        _os_log_fault_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_FAULT,  "Unable to format: Failed to save shutdown report",  v28,  2u);
      }

      if (qword_1000E7D38) {
        int v15 = (FILE *)qword_1000E7D38;
      }
      else {
        int v15 = __stderrp;
      }
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v15);
    }

    *__error() = v12;
  }

  exit(69);
}

id sub_10005A700(uint64_t a1, dispatch_source_s *a2)
{
  double Current = SAMachAbsTimeSecondsGetCurrent(a1);
  id v5 = +[SPSampledProcess allSampledProcesses](&OBJC_CLASS___SPSampledProcess, "allSampledProcesses");
  if ((byte_1000E7C68 & 1) != 0)
  {
    double v6 = Current - *(double *)&qword_1000E7C60;
    if (Current - *(double *)&qword_1000E7C60 > 1.0)
    {
      if (byte_1000E7D30)
      {
        int v62 = *__error();
        uint64_t v63 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v63, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 134217984;
          double v81 = COERCE_DOUBLE(dispatch_source_get_handle(a2));
          _os_log_impl( (void *)&_mh_execute_header,  v63,  OS_LOG_TYPE_DEFAULT,  "Interrupted again by signal %ld, exiting",  buf,  0xCu);
        }

        *__error() = v62;
      }

      if (byte_1000E7D31) {
        BOOL v64 = dword_1000E74E0 <= 2;
      }
      else {
        BOOL v64 = 0;
      }
      if (v64)
      {
        int v65 = *__error();
        uintptr_t handle = dispatch_source_get_handle(a2);
        id v67 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"Interrupted again by signal %ld, exiting",  handle);
        if (v67)
        {
          id v70 = v67;
          CStringPtr = CFStringGetCStringPtr(v67, 0x8000100u);
          if (CStringPtr)
          {
            id v72 = (char *)CStringPtr;
            id v73 = 0LL;
          }

          else
          {
            id v72 = (char *)calloc(0x400uLL, 1uLL);
            CFStringGetCString(v70, v72, 1024LL, 0x8000100u);
            id v73 = v72;
          }

          if (qword_1000E7D38) {
            id v74 = (FILE *)qword_1000E7D38;
          }
          else {
            id v74 = __stderrp;
          }
          fprintf(v74, "%s\n", v72);
          if (v73) {
            free(v73);
          }
          CFRelease(v70);
        }

        else
        {
          id v68 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v68, OS_LOG_TYPE_FAULT)) {
            sub_10008D51C(a2, v68);
          }
          if (qword_1000E7D38) {
            id v69 = (FILE *)qword_1000E7D38;
          }
          else {
            id v69 = __stderrp;
          }
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v69);
        }

        *__error() = v65;
      }

      exit(75);
    }

    if (byte_1000E7D30)
    {
      int v7 = *__error();
      int v8 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 134218240;
        double v81 = Current - *(double *)&qword_1000E7C60;
        __int16 v82 = 2048;
        uintptr_t v83 = dispatch_source_get_handle(a2);
        _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "Interrupted again after %.2f seconds by signal %ld, not exiting",  buf,  0x16u);
      }

      *__error() = v7;
    }

    if (byte_1000E7D31) {
      BOOL v9 = dword_1000E74E0 <= 2;
    }
    else {
      BOOL v9 = 0;
    }
    if (v9)
    {
      int v10 = *__error();
      double v11 = Current - *(double *)&qword_1000E7C60;
      uintptr_t v12 = dispatch_source_get_handle(a2);
      BOOL v13 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"Interrupted again after %.2f seconds by signal %ld, not exiting",  *(void *)&v11,  v12);
      if (v13)
      {
        int v14 = v13;
        int v15 = CFStringGetCStringPtr(v13, 0x8000100u);
        if (v15)
        {
          int v16 = (char *)v15;
          unsigned int v17 = 0LL;
        }

        else
        {
          int v16 = (char *)calloc(0x400uLL, 1uLL);
          CFStringGetCString(v14, v16, 1024LL, 0x8000100u);
          unsigned int v17 = v16;
        }

        if (qword_1000E7D38) {
          int v20 = (FILE *)qword_1000E7D38;
        }
        else {
          int v20 = __stderrp;
        }
        fprintf(v20, "%s\n", v16);
        if (v17) {
          free(v17);
        }
        CFRelease(v14);
      }

      else
      {
        int v18 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v18, OS_LOG_TYPE_FAULT)) {
          sub_10008D6EC(a2, v18, Current);
        }
        if (qword_1000E7D38) {
          int v19 = (FILE *)qword_1000E7D38;
        }
        else {
          int v19 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v19);
      }

      *__error() = v10;
    }
  }

  else
  {
    qword_1000E7C60 = *(void *)&Current;
    byte_1000E7C68 = 1;
  }

  if (!objc_msgSend(v5, "count", v6))
  {
    if (byte_1000E7D30)
    {
      int v35 = *__error();
      __darwin_time_t v36 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT))
      {
        double v37 = COERCE_DOUBLE(dispatch_source_get_handle(a2));
        *(_DWORD *)buf = 134217984;
        double v81 = v37;
        _os_log_impl( (void *)&_mh_execute_header,  v36,  OS_LOG_TYPE_DEFAULT,  "Interrupted by signal %ld while saving report. Interrupt again after a second to exit early",  buf,  0xCu);
      }

      *__error() = v35;
    }

    if (byte_1000E7D31) {
      BOOL v38 = dword_1000E74E0 <= 2;
    }
    else {
      BOOL v38 = 0;
    }
    if (!v38) {
      goto LABEL_97;
    }
    int v39 = *__error();
    uintptr_t v40 = dispatch_source_get_handle(a2);
    double v41 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"Interrupted by signal %ld while saving report. Interrupt again after a second to exit early",  v40);
    if (v41) {
      goto LABEL_66;
    }
    int v42 = (os_log_s *)sub_10002EFA0();
    if (os_log_type_enabled(v42, OS_LOG_TYPE_FAULT)) {
      sub_10008D58C(a2, v42);
    }
    goto LABEL_92;
  }

  int v22 = *(_DWORD *)(a1 + 32);
  int v21 = (unsigned int *)(a1 + 32);
  if (v22)
  {
    if (byte_1000E7D30)
    {
      int v23 = *__error();
      int v24 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
      {
        double v25 = COERCE_DOUBLE(dispatch_source_get_handle(a2));
        unsigned int v26 = *v21;
        *(_DWORD *)buf = 134218240;
        double v81 = v25;
        __int16 v82 = 1024;
        LODWORD(v83) = v26;
        _os_log_impl( (void *)&_mh_execute_header,  v24,  OS_LOG_TYPE_DEFAULT,  "Interrupted by signal %ld, waiting %d seconds...",  buf,  0x12u);
      }

      *__error() = v23;
    }

    if (byte_1000E7D31) {
      BOOL v27 = dword_1000E74E0 <= 2;
    }
    else {
      BOOL v27 = 0;
    }
    if (v27)
    {
      int v28 = *__error();
      uintptr_t v29 = dispatch_source_get_handle(a2);
      uint32_t v30 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"Interrupted by signal %ld, waiting %d seconds...",  v29,  *v21);
      if (v30)
      {
        int v31 = v30;
        BOOL v32 = CFStringGetCStringPtr(v30, 0x8000100u);
        if (v32)
        {
          BOOL v33 = (char *)v32;
          int v34 = 0LL;
        }

        else
        {
          BOOL v33 = (char *)calloc(0x400uLL, 1uLL);
          CFStringGetCString(v31, v33, 1024LL, 0x8000100u);
          int v34 = v33;
        }

        if (qword_1000E7D38) {
          uint64_t v55 = (FILE *)qword_1000E7D38;
        }
        else {
          uint64_t v55 = __stderrp;
        }
        fprintf(v55, "%s\n", v33);
        if (v34) {
          free(v34);
        }
        CFRelease(v31);
      }

      else
      {
        uint64_t v52 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v52, OS_LOG_TYPE_FAULT)) {
          sub_10008D66C(a2);
        }
        if (qword_1000E7D38) {
          BOOL v53 = (FILE *)qword_1000E7D38;
        }
        else {
          BOOL v53 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v53);
      }

      *__error() = v28;
    }

    sleep(*v21);
    goto LABEL_97;
  }

  if (byte_1000E7D30)
  {
    int v43 = *__error();
    double v44 = (os_log_s *)sub_10002EFA0();
    if (os_log_type_enabled(v44, OS_LOG_TYPE_DEFAULT))
    {
      double v45 = COERCE_DOUBLE(dispatch_source_get_handle(a2));
      *(_DWORD *)buf = 134217984;
      double v81 = v45;
      _os_log_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_DEFAULT, "Interrupted by signal %ld", buf, 0xCu);
    }

    *__error() = v43;
  }

  if (byte_1000E7D31) {
    BOOL v46 = dword_1000E74E0 <= 2;
  }
  else {
    BOOL v46 = 0;
  }
  if (v46)
  {
    int v39 = *__error();
    uintptr_t v47 = dispatch_source_get_handle(a2);
    double v41 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"Interrupted by signal %ld", v47);
    if (v41)
    {
LABEL_66:
      id v48 = v41;
      id v49 = CFStringGetCStringPtr(v41, 0x8000100u);
      if (v49)
      {
        id v50 = (char *)v49;
        id v51 = 0LL;
      }

      else
      {
        id v50 = (char *)calloc(0x400uLL, 1uLL);
        CFStringGetCString(v48, v50, 1024LL, 0x8000100u);
        id v51 = v50;
      }

      if (qword_1000E7D38) {
        int v54 = (FILE *)qword_1000E7D38;
      }
      else {
        int v54 = __stderrp;
      }
      fprintf(v54, "%s\n", v50);
      if (v51) {
        free(v51);
      }
      CFRelease(v48);
      goto LABEL_96;
    }

    id v56 = (os_log_s *)sub_10002EFA0();
    if (os_log_type_enabled(v56, OS_LOG_TYPE_FAULT)) {
      sub_10008D5FC(a2, v56);
    }
LABEL_92:
    if (qword_1000E7D38) {
      __darwin_time_t v57 = (FILE *)qword_1000E7D38;
    }
    else {
      __darwin_time_t v57 = __stderrp;
    }
    fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v57);
LABEL_96:
    *__error() = v39;
  }

LABEL_97:
  __int128 v77 = 0u;
  __int128 v78 = 0u;
  __int128 v75 = 0u;
  __int128 v76 = 0u;
  id result = [v5 countByEnumeratingWithState:&v75 objects:v79 count:16];
  if (result)
  {
    id v59 = result;
    uint64_t v60 = *(void *)v76;
    do
    {
      uint64_t v61 = 0LL;
      do
      {
        if (*(void *)v76 != v60) {
          objc_enumerationMutation(v5);
        }
        [*(id *)(*((void *)&v75 + 1) + 8 * (void)v61) stopSamplingWithReason:5];
        uint64_t v61 = (char *)v61 + 1;
      }

      while (v59 != v61);
      id result = [v5 countByEnumeratingWithState:&v75 objects:v79 count:16];
      id v59 = result;
    }

    while (result);
  }

  return result;
}

void sub_10005B07C(id a1)
{
  uint64_t v1 = getpid();
  if (sub_10005BC88(v1))
  {
    if (byte_1000E7D30)
    {
      int v2 = *__error();
      BOOL v3 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG)) {
        sub_10008D7B8();
      }
      *__error() = v2;
    }

    if (byte_1000E7D31) {
      BOOL v4 = dword_1000E74E0 <= 0;
    }
    else {
      BOOL v4 = 0;
    }
    if (!v4) {
      return;
    }
    int v5 = *__error();
    double v6 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"spindump-stuck: Running under debugger, ignoring");
    if (!v6)
    {
      int v7 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_FAULT)) {
        sub_10008D78C();
      }
LABEL_111:
      if (qword_1000E7D38) {
        id v74 = (FILE *)qword_1000E7D38;
      }
      else {
        id v74 = __stderrp;
      }
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v74);
LABEL_115:
      *__error() = v5;
      return;
    }

    goto LABEL_85;
  }

  int v8 = getenv("XPC_NULL_BOOTSTRAP");
  if (v8) {
    BOOL v9 = v8;
  }
  else {
    BOOL v9 = "0";
  }
  if (strcmp("1", v9))
  {
    if (byte_1000E7D30)
    {
      int v10 = *__error();
      double v11 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "spindump-stuck: Spindump has taken over a minute to process samples and may be stuck, try using -noIPC",  buf,  2u);
      }

      *__error() = v10;
    }

    if (byte_1000E7D31) {
      BOOL v12 = dword_1000E74E0 <= 2;
    }
    else {
      BOOL v12 = 0;
    }
    if (v12)
    {
      int v13 = *__error();
      int v14 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"spindump-stuck: Spindump has taken over a minute to process samples and may be stuck, try using -noIPC");
      if (v14)
      {
        int v15 = v14;
        CStringPtr = CFStringGetCStringPtr(v14, 0x8000100u);
        if (CStringPtr)
        {
          unsigned int v17 = (char *)CStringPtr;
          int v18 = 0LL;
        }

        else
        {
          unsigned int v17 = (char *)calloc(0x400uLL, 1uLL);
          CFStringGetCString(v15, v17, 1024LL, 0x8000100u);
          int v18 = v17;
        }

        if (qword_1000E7D38) {
          int v21 = (FILE *)qword_1000E7D38;
        }
        else {
          int v21 = __stderrp;
        }
        fprintf(v21, "%s\n", v17);
        if (v18) {
          free(v18);
        }
        CFRelease(v15);
      }

      else
      {
        int v19 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v19, OS_LOG_TYPE_FAULT)) {
          sub_10008DBB8();
        }
        if (qword_1000E7D38) {
          int v20 = (FILE *)qword_1000E7D38;
        }
        else {
          int v20 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v20);
      }

      *__error() = v13;
    }
  }

  if ((byte_1000E7D44 & 2) != 0 && sub_1000257B8())
  {
    if (byte_1000E7D30)
    {
      int v22 = *__error();
      int v23 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v23, OS_LOG_TYPE_DEBUG)) {
        sub_10008DB8C();
      }
      *__error() = v22;
    }

    if (byte_1000E7D31 && dword_1000E74E0 <= 0)
    {
      int v5 = *__error();
      double v6 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"spindump-stuck: Audio running, avoiding stackshot");
      if (!v6)
      {
        int v24 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v24, OS_LOG_TYPE_FAULT)) {
          sub_10008DB60();
        }
        goto LABEL_111;
      }

BOOL sub_10005BC88(uint64_t a1)
{
  if (!proc_pidinfo(a1, 13, 1uLL, buffer, 64))
  {
    if ((a1 & 0x80000000) != 0)
    {
      if (byte_1000E7D30)
      {
        int v16 = *__error();
        unsigned int v17 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR)) {
          sub_10008DD6C();
        }
        *__error() = v16;
      }

      if (byte_1000E7D31) {
        BOOL v18 = dword_1000E74E0 <= 3;
      }
      else {
        BOOL v18 = 0;
      }
      if (!v18) {
        return 0LL;
      }
      int v6 = *__error();
      uint64_t v19 = *__error();
      int v20 = __error();
      int v21 = strerror(*v20);
      int v22 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"Unable to get proc info, assuming not being debugged: %d (%s)",  v19,  v21);
      if (v22)
      {
        int v23 = v22;
        CStringPtr = CFStringGetCStringPtr(v22, 0x8000100u);
        if (CStringPtr)
        {
          size_t v25 = (char *)CStringPtr;
          size_t v26 = 0LL;
        }

        else
        {
          size_t v25 = (char *)calloc(0x400uLL, 1uLL);
          CFStringGetCString(v23, v25, 1024LL, 0x8000100u);
          size_t v26 = v25;
        }

        if (qword_1000E7D38) {
          BOOL v32 = (FILE *)qword_1000E7D38;
        }
        else {
          BOOL v32 = __stderrp;
        }
        fprintf(v32, "%s\n", v25);
        if (v26) {
          free(v26);
        }
        uintptr_t v29 = v23;
        goto LABEL_51;
      }

      uint64_t v30 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v30, OS_LOG_TYPE_FAULT)) {
        sub_10008DCFC();
      }
    }

    else
    {
      if (byte_1000E7D30)
      {
        int v3 = *__error();
        BOOL v4 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR)) {
          sub_10008DC70();
        }
        *__error() = v3;
      }

      if (byte_1000E7D31) {
        BOOL v5 = dword_1000E74E0 <= 3;
      }
      else {
        BOOL v5 = 0;
      }
      if (!v5) {
        return 0LL;
      }
      int v6 = *__error();
      int v7 = sub_10002EF3C(a1);
      uint64_t v8 = *__error();
      BOOL v9 = __error();
      int v10 = strerror(*v9);
      double v11 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"%s [%d]: Unable to get proc info, assuming not being debugged: %d (%s)",  v7,  a1,  v8,  v10);
      if (v11)
      {
        BOOL v12 = v11;
        int v13 = CFStringGetCStringPtr(v11, 0x8000100u);
        if (v13)
        {
          int v14 = (char *)v13;
          int v15 = 0LL;
        }

        else
        {
          int v14 = (char *)calloc(0x400uLL, 1uLL);
          CFStringGetCString(v12, v14, 1024LL, 0x8000100u);
          int v15 = v14;
        }

        if (qword_1000E7D38) {
          int v28 = (FILE *)qword_1000E7D38;
        }
        else {
          int v28 = __stderrp;
        }
        fprintf(v28, "%s\n", v14);
        if (v15) {
          free(v15);
        }
        uintptr_t v29 = v12;
LABEL_51:
        CFRelease(v29);
LABEL_52:
        *__error() = v6;
        return 0LL;
      }

      pid_t v27 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v27, OS_LOG_TYPE_FAULT)) {
        sub_10008DBE4();
      }
    }

    if (qword_1000E7D38) {
      int v31 = (FILE *)qword_1000E7D38;
    }
    else {
      int v31 = __stderrp;
    }
    fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v31);
    goto LABEL_52;
  }

  return (buffer[32] & 2) != 0;
}

void sub_10005C014(uint64_t a1, void *a2)
{
  BOOL v4 = (NSString *)[a2 targetProcessName];
  if (!v4)
  {
    if (*(void *)(a1 + 64)) {
      BOOL v4 = +[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:");
    }
    else {
      BOOL v4 = 0LL;
    }
  }

  if (*(_BYTE *)(a1 + 108))
  {
    dispatch_group_wait((dispatch_group_t)qword_1000E7D90, 0xFFFFFFFFFFFFFFFFLL);
    if ((byte_1000E7D44 & 0x18) == 0x10)
    {
      if (byte_1000E7D30)
      {
        int v5 = *__error();
        int v6 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "SIGINFO received, generating report...",  buf,  2u);
        }

        *__error() = v5;
      }

      if (byte_1000E7D31) {
        BOOL v7 = dword_1000E74E0 <= 2;
      }
      else {
        BOOL v7 = 0;
      }
      if (!v7) {
        goto LABEL_46;
      }
      int v8 = *__error();
      BOOL v9 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"SIGINFO received, generating report...");
      if (!v9)
      {
        int v10 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v10, OS_LOG_TYPE_FAULT))
        {
          __int16 v35 = 0;
          double v11 = "Unable to format: SIGINFO received, generating report...";
          BOOL v12 = (uint8_t *)&v35;
LABEL_31:
          _os_log_fault_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_FAULT, v11, v12, 2u);
          goto LABEL_32;
        }

        goto LABEL_32;
      }

      goto LABEL_36;
    }

    if (byte_1000E7D30)
    {
      int v13 = *__error();
      int v14 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)BOOL v38 = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_DEFAULT,  "SIGINFO received, processing symbols...",  v38,  2u);
      }

      *__error() = v13;
    }

    if (byte_1000E7D31) {
      BOOL v15 = dword_1000E74E0 <= 2;
    }
    else {
      BOOL v15 = 0;
    }
    if (v15)
    {
      int v8 = *__error();
      BOOL v9 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"SIGINFO received, processing symbols...");
      if (!v9)
      {
        int v10 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v10, OS_LOG_TYPE_FAULT))
        {
          *(_WORD *)int v37 = 0;
          double v11 = "Unable to format: SIGINFO received, processing symbols...";
          BOOL v12 = v37;
          goto LABEL_31;
        }

LABEL_32:
        if (qword_1000E7D38) {
          int v16 = (FILE *)qword_1000E7D38;
        }
        else {
          int v16 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v16);
LABEL_45:
        *__error() = v8;
        goto LABEL_46;
      }

LABEL_46:
  if (*(void *)(a1 + 32)) {
    objc_msgSend(a2, "setPrintOptions:");
  }
  [a2 setForceOneBasedTimeIndexes:*(unsigned __int8 *)(a1 + 109)];
  if (*(void *)(a1 + 72)) {
    objc_msgSend(a2, "setTargetThreadId:");
  }
  if ((int)[a2 numSamplesAvoidedDueToAudio] >= 1 && !objc_msgSend(a2, "numSamples"))
  {
    if (byte_1000E7D30)
    {
      int v22 = *__error();
      int v23 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)int v34 = 0;
        _os_log_error_impl( (void *)&_mh_execute_header,  v23,  OS_LOG_TYPE_ERROR,  "Unable to sample due to audio running",  v34,  2u);
      }

      *__error() = v22;
    }

    if (byte_1000E7D31 && dword_1000E74E0 <= 3)
    {
      int v24 = *__error();
      size_t v25 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"Unable to sample due to audio running");
      if (v25)
      {
        int v28 = v25;
        uintptr_t v29 = CFStringGetCStringPtr(v25, 0x8000100u);
        if (v29)
        {
          uint64_t v30 = (char *)v29;
          int v31 = 0LL;
        }

        else
        {
          uint64_t v30 = (char *)calloc(0x400uLL, 1uLL);
          CFStringGetCString(v28, v30, 1024LL, 0x8000100u);
          int v31 = v30;
        }

        if (qword_1000E7D38) {
          BOOL v32 = (FILE *)qword_1000E7D38;
        }
        else {
          BOOL v32 = __stderrp;
        }
        fprintf(v32, "%s\n", v30);
        if (v31) {
          free(v31);
        }
        CFRelease(v28);
      }

      else
      {
        size_t v26 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v26, OS_LOG_TYPE_FAULT))
        {
          *(_WORD *)size_t v33 = 0;
          _os_log_fault_impl( (void *)&_mh_execute_header,  v26,  OS_LOG_TYPE_FAULT,  "Unable to format: Unable to sample due to audio running",  v33,  2u);
        }

        if (qword_1000E7D38) {
          pid_t v27 = (FILE *)qword_1000E7D38;
        }
        else {
          pid_t v27 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v27);
      }

      *__error() = v24;
    }

    exit(69);
  }

  sub_100057254( a2,  *(void *)(a1 + 80),  *(void *)(a1 + 88),  *(void *)(a1 + 40),  *(void *)(a1 + 48),  *(unsigned __int8 *)(a1 + 110),  *(unsigned __int8 *)(a1 + 111),  *(unsigned __int8 *)(a1 + 112),  *(uint8_t **)(a1 + 96),  v4,  *(_DWORD *)(a1 + 104) != 0);
}

uint64_t sub_10005C550(uint64_t a1)
{
  return (*(uint64_t (**)(void, void))(*(void *)(a1 + 40) + 16LL))( *(void *)(a1 + 40),  *(void *)(a1 + 32));
}

BOOL sub_10005C560()
{
  if (qword_1000E7C98 != -1) {
    dispatch_once(&qword_1000E7C98, &stru_1000D9768);
  }
  if (!qword_1000E74F8) {
    return 0LL;
  }
  unsigned int v28 = 0;
  size_t v27 = 4LL;
  if (sysctl(dword_1000E7C88, qword_1000E74F8, &v28, &v27, 0LL, 0LL))
  {
    int v13 = *__error();
    int v14 = (os_log_s *)sub_10002EFA0();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_FAULT)) {
      sub_10008E1C0();
    }
    *__error() = v13;
    if (byte_1000E7D31 && dword_1000E74E0 <= 4)
    {
      int v15 = *__error();
      uint64_t v16 = *__error();
      unsigned int v17 = __error();
      BOOL v18 = strerror(*v17);
      uint64_t v19 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"sysctl for kern.memorystatus_vm_pressure_level failed: %d (%s)",  v16,  v18);
      if (v19)
      {
        int v20 = v19;
        CStringPtr = CFStringGetCStringPtr(v19, 0x8000100u);
        if (CStringPtr)
        {
          int v22 = (char *)CStringPtr;
          int v23 = 0LL;
        }

        else
        {
          int v22 = (char *)calloc(0x400uLL, 1uLL);
          CFStringGetCString(v20, v22, 1024LL, 0x8000100u);
          int v23 = v22;
        }

        if (qword_1000E7D38) {
          size_t v26 = (FILE *)qword_1000E7D38;
        }
        else {
          size_t v26 = __stderrp;
        }
        fprintf(v26, "%s\n", v22);
        if (v23) {
          free(v23);
        }
        CFRelease(v20);
      }

      else
      {
        int v24 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v24, OS_LOG_TYPE_FAULT)) {
          sub_10008E150();
        }
        if (qword_1000E7D38) {
          size_t v25 = (FILE *)qword_1000E7D38;
        }
        else {
          size_t v25 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v25);
      }

      *__error() = v15;
    }

    unsigned int v28 = 0;
    qword_1000E74F8 = 0LL;
  }

  if (byte_1000E7D30)
  {
    int v0 = *__error();
    uint64_t v1 = (os_log_s *)sub_10002EFA0();
    if (os_log_type_enabled(v1, OS_LOG_TYPE_DEBUG)) {
      sub_10008E0EC();
    }
    *__error() = v0;
  }

  if (byte_1000E7D31) {
    BOOL v2 = dword_1000E74E0 <= 0;
  }
  else {
    BOOL v2 = 0;
  }
  if (v2)
  {
    int v3 = *__error();
    BOOL v4 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"Memory pressure %d", v28);
    if (v4)
    {
      int v5 = v4;
      int v6 = CFStringGetCStringPtr(v4, 0x8000100u);
      if (v6)
      {
        BOOL v7 = (char *)v6;
        int v8 = 0LL;
      }

      else
      {
        BOOL v7 = (char *)calloc(0x400uLL, 1uLL);
        CFStringGetCString(v5, v7, 1024LL, 0x8000100u);
        int v8 = v7;
      }

      if (qword_1000E7D38) {
        double v11 = (FILE *)qword_1000E7D38;
      }
      else {
        double v11 = __stderrp;
      }
      fprintf(v11, "%s\n", v7);
      if (v8) {
        free(v8);
      }
      CFRelease(v5);
    }

    else
    {
      BOOL v9 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v9, OS_LOG_TYPE_FAULT)) {
        sub_10008E084();
      }
      if (qword_1000E7D38) {
        int v10 = (FILE *)qword_1000E7D38;
      }
      else {
        int v10 = __stderrp;
      }
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v10);
    }

    *__error() = v3;
  }

  return v28 > 3;
}

void sub_10005C92C(id a1)
{
  if (sysctlnametomib("kern.memorystatus_vm_pressure_level", dword_1000E7C88, (size_t *)&qword_1000E74F8))
  {
    int v1 = *__error();
    BOOL v2 = (os_log_s *)sub_10002EFA0();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT)) {
      sub_10008E2A0();
    }
    *__error() = v1;
    if (byte_1000E7D31) {
      BOOL v3 = dword_1000E74E0 <= 4;
    }
    else {
      BOOL v3 = 0;
    }
    if (v3)
    {
      int v15 = *__error();
      uint64_t v4 = *__error();
      int v5 = __error();
      int v6 = strerror(*v5);
      BOOL v7 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"sysctlnametomib for kern.memorystatus_vm_pressure_level failed: %d (%s)",  v4,  v6);
      if (v7)
      {
        theString = v7;
        CStringPtr = CFStringGetCStringPtr(v7, 0x8000100u);
        if (CStringPtr)
        {
          BOOL v9 = (char *)CStringPtr;
          int v10 = 0LL;
        }

        else
        {
          BOOL v9 = (char *)calloc(0x400uLL, 1uLL);
          CFStringGetCString(theString, v9, 1024LL, 0x8000100u);
          int v10 = v9;
        }

        if (qword_1000E7D38) {
          int v13 = (FILE *)qword_1000E7D38;
        }
        else {
          int v13 = __stderrp;
        }
        fprintf(v13, "%s\n", v9);
        if (v10) {
          free(v10);
        }
        CFRelease(theString);
      }

      else
      {
        double v11 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v11, OS_LOG_TYPE_FAULT)) {
          sub_10008E230();
        }
        if (qword_1000E7D38) {
          BOOL v12 = (FILE *)qword_1000E7D38;
        }
        else {
          BOOL v12 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v12);
      }

      *__error() = v15;
    }

    qword_1000E74F8 = 0LL;
  }

void sub_10005CB08()
{
  if (geteuid())
  {
    if (byte_1000E7D30)
    {
      int v0 = *__error();
      int v1 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR)) {
        sub_10008E388();
      }
      *__error() = v0;
    }

    if (byte_1000E7D31) {
      BOOL v2 = dword_1000E74E0 <= 3;
    }
    else {
      BOOL v2 = 0;
    }
    if (v2)
    {
      int v3 = *__error();
      uint64_t v4 = geteuid();
      int v5 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"%s: spindump must run as root to create spindump directory (running as %d)",  "geteuid() == 0",  v4);
      if (v5)
      {
        int v8 = v5;
        CStringPtr = CFStringGetCStringPtr(v5, 0x8000100u);
        if (CStringPtr)
        {
          int v10 = 0LL;
        }

        else
        {
          int v10 = (char *)calloc(0x400uLL, 1uLL);
          CFStringGetCString(v8, v10, 1024LL, 0x8000100u);
          CStringPtr = v10;
        }

        double v11 = (FILE *)qword_1000E7D38;
        if (!qword_1000E7D38) {
          double v11 = __stderrp;
        }
        fprintf(v11, "%s\n", CStringPtr);
        if (v10) {
          free(v10);
        }
        CFRelease(v8);
      }

      else
      {
        int v6 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)) {
          sub_10008E310();
        }
        if (qword_1000E7D38) {
          BOOL v7 = (FILE *)qword_1000E7D38;
        }
        else {
          BOOL v7 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v7);
      }

      *__error() = v3;
    }

    geteuid();
    sub_10002EE78( "MakeSpindumpDirectory",  "spindump.m",  4222,  "%s: spindump must run as root to create spindump directory (running as %d)",  v12,  v13,  v14,  v15,  (char)"geteuid() == 0");
    abort();
  }

  if (qword_1000E7CA0 != -1) {
    dispatch_once(&qword_1000E7CA0, &stru_1000D9788);
  }
}

void sub_10005CD20(id a1)
{
  if (!stat("/private/var/db/spindump", &v55))
  {
    if ((v55.st_mode & 0xF000) == 0x4000) {
      return;
    }
    if (byte_1000E7D30)
    {
      int v15 = *__error();
      uint64_t v16 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR)) {
        sub_10008E474(v16, v17, v18);
      }
      *__error() = v15;
    }

    if (byte_1000E7D31) {
      BOOL v19 = dword_1000E74E0 <= 3;
    }
    else {
      BOOL v19 = 0;
    }
    if (v19)
    {
      int v20 = *__error();
      int v21 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"%s: /private/var/db/spindump already exists and isnt a directory!",  "(((st.st_mode) & 0170000) == 0040000)");
      if (v21)
      {
        double v44 = v21;
        CStringPtr = CFStringGetCStringPtr(v21, 0x8000100u);
        if (CStringPtr)
        {
          BOOL v46 = (char *)CStringPtr;
          uint64_t v47 = 0LL;
        }

        else
        {
          BOOL v46 = (char *)calloc(0x400uLL, 1uLL);
          CFStringGetCString(v44, v46, 1024LL, 0x8000100u);
          uint64_t v47 = v46;
        }

        if (qword_1000E7D38) {
          int v54 = (FILE *)qword_1000E7D38;
        }
        else {
          int v54 = __stderrp;
        }
        fprintf(v54, "%s\n", v46);
        if (v47) {
          free(v47);
        }
        CFRelease(v44);
      }

      else
      {
        int v22 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v22, OS_LOG_TYPE_FAULT)) {
          sub_10008E400(v22, v23, v24);
        }
        if (qword_1000E7D38) {
          size_t v25 = (FILE *)qword_1000E7D38;
        }
        else {
          size_t v25 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v25);
      }

      *__error() = v20;
    }

    sub_10002EE78( "MakeSpindumpDirectory_block_invoke",  "spindump.m",  4237,  "%s: /private/var/db/spindump already exists and isnt a directory!",  v1,  v2,  v3,  v4,  (char)"(((st.st_mode) & 0170000) == 0040000)");
LABEL_85:
    abort();
  }

  uint64_t v5 = *__error();
  if (byte_1000E7D30)
  {
    int v6 = *__error();
    BOOL v7 = (os_log_s *)sub_10002EFA0();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG)) {
      sub_10008E674();
    }
    *__error() = v6;
  }

  if (byte_1000E7D31) {
    BOOL v8 = dword_1000E74E0 <= 0;
  }
  else {
    BOOL v8 = 0;
  }
  if (v8)
  {
    int v9 = *__error();
    int v10 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"Creating spindump directory /private/var/db/spindump after stat said %d",  v5);
    if (v10)
    {
      double v11 = v10;
      uint64_t v12 = CFStringGetCStringPtr(v10, 0x8000100u);
      if (v12)
      {
        uint64_t v13 = (char *)v12;
        uint64_t v14 = 0LL;
      }

      else
      {
        uint64_t v13 = (char *)calloc(0x400uLL, 1uLL);
        CFStringGetCString(v11, v13, 1024LL, 0x8000100u);
        uint64_t v14 = v13;
      }

      if (qword_1000E7D38) {
        unsigned int v28 = (FILE *)qword_1000E7D38;
      }
      else {
        unsigned int v28 = __stderrp;
      }
      fprintf(v28, "%s\n", v13);
      if (v14) {
        free(v14);
      }
      CFRelease(v11);
    }

    else
    {
      size_t v26 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v26, OS_LOG_TYPE_FAULT)) {
        sub_10008E610();
      }
      if (qword_1000E7D38) {
        size_t v27 = (FILE *)qword_1000E7D38;
      }
      else {
        size_t v27 = __stderrp;
      }
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v27);
    }

    *__error() = v9;
  }

  if (mkdir("/private/var/db/spindump", 0x1EDu))
  {
    if (byte_1000E7D30)
    {
      int v29 = *__error();
      uint64_t v30 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR)) {
        sub_10008E57C();
      }
      *__error() = v29;
    }

    if (byte_1000E7D31) {
      BOOL v31 = dword_1000E74E0 <= 3;
    }
    else {
      BOOL v31 = 0;
    }
    if (v31)
    {
      int v32 = *__error();
      size_t v33 = strerror(v5);
      uint64_t v34 = *__error();
      __int16 v35 = __error();
      __darwin_time_t v36 = strerror(*v35);
      int v37 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"%s: unable to create /private/var/db/spindump after state failed with %d (%s): %d (%s)",  "ret == 0",  v5,  v33,  v34,  v36);
      if (v37)
      {
        uintptr_t v40 = v37;
        double v41 = CFStringGetCStringPtr(v37, 0x8000100u);
        if (v41)
        {
          int v42 = (char *)v41;
          int v43 = 0LL;
        }

        else
        {
          int v42 = (char *)calloc(0x400uLL, 1uLL);
          CFStringGetCString(v40, v42, 1024LL, 0x8000100u);
          int v43 = v42;
        }

        if (qword_1000E7D38) {
          id v48 = (FILE *)qword_1000E7D38;
        }
        else {
          id v48 = __stderrp;
        }
        fprintf(v48, "%s\n", v42);
        if (v43) {
          free(v43);
        }
        CFRelease(v40);
      }

      else
      {
        BOOL v38 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v38, OS_LOG_TYPE_FAULT)) {
          sub_10008E4E8();
        }
        if (qword_1000E7D38) {
          int v39 = (FILE *)qword_1000E7D38;
        }
        else {
          int v39 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v39);
      }

      *__error() = v32;
    }

    strerror(v5);
    __error();
    id v49 = __error();
    strerror(*v49);
    sub_10002EE78( "MakeSpindumpDirectory_block_invoke",  "spindump.m",  4234,  "%s: unable to create /private/var/db/spindump after state failed with %d (%s): %d (%s)",  v50,  v51,  v52,  v53,  (char)"ret == 0");
    goto LABEL_85;
  }

ssize_t sub_10005D2C0(ssize_t result)
{
  uint64_t v1 = *(void **)(*(void *)(*(void *)(result + 40) + 8LL) + 24LL);
  if (v1)
  {
    ssize_t v2 = result;
    id result = read(*(_DWORD *)(result + 48), v1, 0x3FFuLL);
    if (result >= 1)
    {
      do
      {
        *(_BYTE *)(*(void *)(*(void *)(*(void *)(v2 + 40) + 8LL) + 24LL) + result) = 0;
        objc_msgSend( *(id *)(v2 + 32),  "appendFormat:",  @"%s",  *(void *)(*(void *)(*(void *)(v2 + 40) + 8) + 24));
        id result = read(*(_DWORD *)(v2 + 48), *(void **)(*(void *)(*(void *)(v2 + 40) + 8LL) + 24LL), 0x3FFuLL);
      }

      while (result > 0);
    }
  }

  return result;
}

void sub_10005D358(uint64_t a1)
{
}

ssize_t sub_10005D380(ssize_t result)
{
  uint64_t v1 = *(void **)(*(void *)(*(void *)(result + 40) + 8LL) + 24LL);
  if (v1)
  {
    ssize_t v2 = result;
    id result = read(*(_DWORD *)(result + 48), v1, 0x3FFuLL);
    if (result >= 1)
    {
      do
      {
        *(_BYTE *)(*(void *)(*(void *)(*(void *)(v2 + 40) + 8LL) + 24LL) + result) = 0;
        objc_msgSend( *(id *)(v2 + 32),  "appendFormat:",  @"%s",  *(void *)(*(void *)(*(void *)(v2 + 40) + 8) + 24));
        id result = read(*(_DWORD *)(v2 + 48), *(void **)(*(void *)(*(void *)(v2 + 40) + 8LL) + 24LL), 0x3FFuLL);
      }

      while (result > 0);
    }
  }

  return result;
}

void sub_10005D418(uint64_t a1)
{
}

uint64_t sub_10005D440(uint64_t a1)
{
  int v5 = 0;
  while (waitpid(*(_DWORD *)(a1 + 80), &v5, 0) == -1 && *__error() == 4)
    ;
  dispatch_source_cancel(*(dispatch_source_t *)(a1 + 32));
  dispatch_source_cancel(*(dispatch_source_t *)(a1 + 40));
  dispatch_source_cancel(*(dispatch_source_t *)(a1 + 48));
  fcntl(*(_DWORD *)(a1 + 84), 4, 0LL);
  fcntl(*(_DWORD *)(a1 + 88), 4, 0LL);
  ssize_t v2 = read(*(_DWORD *)(a1 + 84), *(void **)(*(void *)(*(void *)(a1 + 72) + 8LL) + 24LL), 0x3FFuLL);
  if (v2 >= 1)
  {
    do
    {
      *(_BYTE *)(*(void *)(*(void *)(*(void *)(a1 + 72) + 8LL) + 24LL) + v2) = 0;
      objc_msgSend( *(id *)(a1 + 56),  "appendFormat:",  @"%s",  *(void *)(*(void *)(*(void *)(a1 + 72) + 8) + 24));
      ssize_t v2 = read(*(_DWORD *)(a1 + 84), *(void **)(*(void *)(*(void *)(a1 + 72) + 8LL) + 24LL), 0x3FFuLL);
    }

    while (v2 > 0);
  }

  ssize_t v3 = read(*(_DWORD *)(a1 + 88), *(void **)(*(void *)(*(void *)(a1 + 72) + 8LL) + 24LL), 0x3FFuLL);
  if (v3 >= 1)
  {
    do
    {
      *(_BYTE *)(*(void *)(*(void *)(*(void *)(a1 + 72) + 8LL) + 24LL) + v3) = 0;
      objc_msgSend( *(id *)(a1 + 56),  "appendFormat:",  @"%s",  *(void *)(*(void *)(*(void *)(a1 + 72) + 8) + 24));
      ssize_t v3 = read(*(_DWORD *)(a1 + 88), *(void **)(*(void *)(*(void *)(a1 + 72) + 8LL) + 24LL), 0x3FFuLL);
    }

    while (v3 > 0);
  }

  free(*(void **)(*(void *)(*(void *)(a1 + 72) + 8LL) + 24LL));
  *(void *)(*(void *)(*(void *)(a1 + 72) + 8LL) + 24LL) = 0LL;
  return (*(uint64_t (**)(void))(*(void *)(a1 + 64) + 16LL))();
}

void sub_10005D5D8(uint64_t a1)
{
}

  ;
}

  ;
}

_DWORD *sub_10005D614(void *a1, int *a2)
{
  return sub_10002EF3C(*(_DWORD *)(*a1 + 4LL * *a2));
}

  ;
}

id sub_10005D65C()
{
  return [v0 macf];
}

id sub_10005D664()
{
  return [v0 timer];
}

id sub_10005D66C()
{
  return [v0 pmi];
}

id sub_10005D674()
{
  return [v0 interrupt];
}

id sub_10005D67C()
{
  return objc_msgSend(v0, "unknown_type");
}

id sub_10005D684()
{
  return [v0 io];
}

void sub_10005D68C(void *a1, os_log_s *a2, uint64_t a3, const char *a4, uint8_t *a5)
{
}

  ;
}

  ;
}

void sub_10005D6C4(void *a1, os_log_s *a2, uint64_t a3, const char *a4, uint8_t *a5)
{
}

id sub_10005D6D0(void *a1, const char *a2)
{
  return [a1 total];
}

uintptr_t sub_10005D6D8(dispatch_source_t source)
{
  return dispatch_source_get_handle(source);
}

  ;
}

int *sub_10005D6F0()
{
  return __error();
}

uint64_t sub_10005D6F8( int a1, FILE *a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14)
{
  return ferror(a2);
}

  ;
}

LABEL_38:
    uint64_t v30 = v13;
    BOOL v31 = CFStringGetCStringPtr(v13, 0x8000100u);
    if (v31)
    {
      int v32 = (char *)v31;
      size_t v33 = 0LL;
    }

    else
    {
      int v32 = (char *)calloc(0x400uLL, 1uLL);
      CFStringGetCString(v30, v32, 1024LL, 0x8000100u);
      size_t v33 = v32;
    }

    if (qword_1000E7D38) {
      int v45 = (FILE *)qword_1000E7D38;
    }
    else {
      int v45 = __stderrp;
    }
    fprintf(v45, "%s\n", v32);
    if (v33) {
      free(v33);
    }
    CFRelease(v30);
    goto LABEL_91;
  }

  uint64_t v34 = mmap(0LL, v80.st_size, 1, 1, v5, 0LL);
  close(v5);
  if (v34 == (_DWORD *)-1LL)
  {
    if (byte_1000E7D30)
    {
      id v49 = *__error();
      uint64_t v50 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v50, OS_LOG_TYPE_ERROR)) {
        sub_10008E88C();
      }
      *__error() = v49;
    }

    if (byte_1000E7D31) {
      uint64_t v51 = dword_1000E74E0 <= 3;
    }
    else {
      uint64_t v51 = 0;
    }
    if (!v51) {
      return 0LL;
    }
    uint64_t v18 = *__error();
    uint64_t v52 = *__error();
    uint64_t v53 = __error();
    int v54 = strerror(*v53);
    int v22 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"Unable to map %s: %d (%s)", a3, v52, v54);
    if (!v22)
    {
      stat v55 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v55, OS_LOG_TYPE_FAULT)) {
        sub_10008E818();
      }
LABEL_54:
      if (qword_1000E7D38) {
        double v44 = (FILE *)qword_1000E7D38;
      }
      else {
        double v44 = __stderrp;
      }
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v44);
LABEL_72:
      uint64_t v47 = __error();
      id result = 0LL;
      char *v47 = v18;
      return result;
    }

    goto LABEL_25;
  }

  if (v34 + 4 > (_DWORD *)((char *)v34 + v80.st_size)
    || (char *)v34 + v34[1] + 16 > (char *)v34 + v80.st_size)
  {
    if (byte_1000E7D30)
    {
      __int16 v35 = *__error();
      __darwin_time_t v36 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v36, OS_LOG_TYPE_DEBUG)) {
        sub_10008E960();
      }
      *__error() = v35;
    }

    if (!byte_1000E7D31 || dword_1000E74E0 > 0) {
      goto LABEL_132;
    }
    int v37 = *__error();
    BOOL v38 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"Not a kcdata file: kcdata in %s not valid (file length %lld)",  a3,  v80.st_size);
    if (v38) {
      goto LABEL_50;
    }
    id v67 = (os_log_s *)sub_10002EFA0();
    if (os_log_type_enabled(v67, OS_LOG_TYPE_FAULT)) {
      sub_10008E900();
    }
    goto LABEL_108;
  }

  if (*v34 != 1503811591)
  {
    if (byte_1000E7D30)
    {
      id v69 = *__error();
      id v70 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v70, OS_LOG_TYPE_ERROR)) {
        sub_10008EA88();
      }
      *__error() = v69;
    }

    if (!byte_1000E7D31 || dword_1000E74E0 > 3) {
      goto LABEL_132;
    }
    int v37 = *__error();
    LODWORD(v71) = *v34;
    if ((*v34 & 0xFFFFFFF0) == 0x20) {
      id v71 = 17LL;
    }
    else {
      id v71 = v71;
    }
    BOOL v38 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"%s isn't a kcdata stackshot file (header type %#x)",  a3,  v71);
    if (v38)
    {
LABEL_50:
      int v39 = v38;
      uintptr_t v40 = CFStringGetCStringPtr(v38, 0x8000100u);
      if (v40)
      {
        double v41 = (char *)v40;
        int v42 = 0LL;
      }

      else
      {
        double v41 = (char *)calloc(0x400uLL, 1uLL);
        CFStringGetCString(v39, v41, 1024LL, 0x8000100u);
        int v42 = v41;
      }

      if (qword_1000E7D38) {
        id v73 = (FILE *)qword_1000E7D38;
      }
      else {
        id v73 = __stderrp;
      }
      fprintf(v73, "%s\n", v41);
      if (v42) {
        free(v42);
      }
      CFRelease(v39);
      goto LABEL_131;
    }

    id v72 = (os_log_s *)sub_10002EFA0();
    if (os_log_type_enabled(v72, OS_LOG_TYPE_FAULT)) {
      sub_10008EA10();
    }
LABEL_108:
    if (qword_1000E7D38) {
      id v68 = (FILE *)qword_1000E7D38;
    }
    else {
      id v68 = __stderrp;
    }
    fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v68);
LABEL_131:
    *__error() = v37;
LABEL_132:
    munmap(v34, v80.st_size);
    return 0LL;
  }

  int v58 = -[SASampleStore initForFileParsing](objc_alloc(&OBJC_CLASS___SASampleStore), "initForFileParsing");
  if ((byte_1000E7D44 & 2) != 0 && sub_1000257B8())
  {
    if (byte_1000E7D30)
    {
      int v59 = *__error();
      int v60 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v60, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v60,  OS_LOG_TYPE_DEFAULT,  "Avoiding inspecting live processes for stackshot file due to audio running",  buf,  2u);
      }

      *__error() = v59;
    }

    if (byte_1000E7D31 && dword_1000E74E0 <= 2)
    {
      int v61 = *__error();
      int v62 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"Avoiding inspecting live processes for stackshot file due to audio running");
      if (v62)
      {
        int v63 = v62;
        uint64_t v64 = CFStringGetCStringPtr(v62, 0x8000100u);
        if (v64)
        {
          int v65 = (char *)v64;
          uint64_t v66 = 0LL;
        }

        else
        {
          int v65 = (char *)calloc(0x400uLL, 1uLL);
          CFStringGetCString(v63, v65, 1024LL, 0x8000100u);
          uint64_t v66 = v65;
        }

        if (qword_1000E7D38) {
          __int128 v76 = (FILE *)qword_1000E7D38;
        }
        else {
          __int128 v76 = __stderrp;
        }
        fprintf(v76, "%s\n", v65);
        if (v66) {
          free(v66);
        }
        CFRelease(v63);
      }

      else
      {
        id v74 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v74, OS_LOG_TYPE_FAULT)) {
          sub_10008E9D0(v74);
        }
        if (qword_1000E7D38) {
          __int128 v75 = (FILE *)qword_1000E7D38;
        }
        else {
          __int128 v75 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v75);
      }

      *__error() = v61;
    }

    objc_msgSend( v58,  "setDataGatheringOptions:",  (unint64_t)objc_msgSend(v58, "dataGatheringOptions") & 0xFFFFFFFFFFFFFFFDLL);
  }

  sub_1000571C4( v58,  (byte_1000E7D44 >> 3) & 1,  (byte_1000E7D44 >> 2) & 1,  (byte_1000E7D44 & 0x10) == 0);
  int v77 = objc_alloc(&OBJC_CLASS___NSData);
  int v78 = -[NSData initWithBytesNoCopy:length:deallocator:]( v77,  "initWithBytesNoCopy:length:deallocator:",  v34,  v80.st_size,  &stru_1000D9840);
  [v58 addKCDataStackshots:v78 createSeparateSamplePerStackshot:1];

  [v58 postprocess];
  return v58;
}

void sub_10005E1AC(id a1, void *a2, unint64_t a3)
{
}

  ;
}

void sub_10005E1D0(uint64_t a1@<X8>)
{
  *(void *)(v1 - _Block_object_dispose(va, 8) = a1;
}

void sub_10005E1DC(uint64_t a1@<X8>)
{
  *(void *)(v1 - _Block_object_dispose(va, 8) = a1;
}

LABEL_50:
  -[SPProcessEvent dropTransaction](self, "dropTransaction");
  processingQueue = self->_processingQueue;
  if (processingQueue) {
    dispatch_release((dispatch_object_t)processingQueue);
  }
  exitSource = self->_exitSource;
  if (exitSource) {
    dispatch_release((dispatch_object_t)exitSource);
  }
  timeoutSource = self->_timeoutSource;
  if (timeoutSource) {
    dispatch_release((dispatch_object_t)timeoutSource);
  }

  completionCallbackQueue = self->_completionCallbackQueue;
  if (completionCallbackQueue)
  {
    dispatch_release((dispatch_object_t)completionCallbackQueue);
    self->_completionCallbackQueue = 0LL;
  }

  completionCallbackBlock = self->_completionCallbackBlock;
  if (completionCallbackBlock)
  {
    _Block_release(completionCallbackBlock);
    self->_completionCallbackBlock = 0LL;
  }

  v40.receiver = self;
  v40.super_class = (Class)&OBJC_CLASS___SPProcessEvent;
  -[SPProcessEvent dealloc](&v40, "dealloc");
}

double sub_10005E81C(void *a1, void *a2)
{
  if (v4 != 0.0)
  {
    [a2 machAbsTimeSeconds];
    if (v5 != 0.0)
    {
      [a2 machAbsTimeSeconds];
      double v7 = v6;
      [a1 machAbsTimeSeconds];
      return v7 - v8;
    }
  }

  [a1 machContTimeSeconds];
  if (v9 != 0.0)
  {
    [a2 machContTimeSeconds];
    if (v10 != 0.0)
    {
      [a2 machContTimeSeconds];
      double v7 = v11;
      [a1 machContTimeSeconds];
      return v7 - v8;
    }
  }

  [a1 wallTime];
  double v12 = 0.0;
  if (v13 != 0.0)
  {
    [a2 wallTime];
    if (v14 != 0.0)
    {
      [a2 wallTime];
      double v7 = v15;
      [a1 wallTime];
      return v7 - v8;
    }
  }

  return v12;
}

LABEL_48:
  if (self->_reason) {
    objc_msgSend(a3, "setReason:");
  }
  sub_1000571C4(a3, self->_shouldSymbolicate, self->_useDsymForUUIDForEverything, self->_shouldUseBulkSymbolication);
  stepsNote = self->_stepsNote;
  numSamplesAvoidedDueToAudioAtStart = self->_numSamplesAvoidedDueToAudioAtStart;
  BOOL v38 = (self->_numSamplesAvoidedDueToAudioAtEnd - numSamplesAvoidedDueToAudioAtStart);
  if ((int)v38 >= 1)
  {
    if (stepsNote) {
      int v39 = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"%@, %d samples avoided due to audio",  self->_stepsNote,  v38);
    }
    else {
      int v39 = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"%d samples avoided due to audio",  (self->_numSamplesAvoidedDueToAudioAtEnd - numSamplesAvoidedDueToAudioAtStart),  v97);
    }
    stepsNote = v39;
  }

  [a3 setTargetThreadId:0];
  if ((*p_targetProcessId & 0x80000000) == 0) {
    objc_msgSend(a3, "setTargetProcessId:");
  }
  if (self->_targetThreadId) {
    objc_msgSend(a3, "setTargetThreadId:");
  }
  if (self->_targetProcessAbsolutePath)
  {
    if ((objc_msgSend( objc_msgSend(objc_msgSend(a3, "targetProcess"), "mainBinaryPath"),  "isAbsolutePath") & 1) == 0)
    {
      uintptr_t v40 = [a3 targetProcess];
      if (v40) {
        [v40 setMainBinaryPath:self->_targetProcessAbsolutePath];
      }
    }
  }

  [a3 setTargetHIDEventMachAbs:self->_targetHIDEventMachAbs];
  [a3 setTargetHIDEventEndMachAbs:self->_targetHIDEventEndMachAbs];
  if (self->_isLiveSampling) {
    [a3 setShouldGatherKextStat:!self->_headerOnly];
  }
  if (self->_dsymPaths) {
    +[SABinary addDsymPaths:](&OBJC_CLASS___SABinary, "addDsymPaths:");
  }
  id v100 = 0u;
  id v101 = 0u;
  id v98 = 0u;
  id v99 = 0u;
  findDsymsForIDs = self->_findDsymsForIDs;
  int v42 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( findDsymsForIDs,  "countByEnumeratingWithState:objects:count:",  &v98,  v102,  16LL);
  if (v42)
  {
    int v43 = v42;
    double v44 = *(void *)v99;
    do
    {
      for (uint64_t i = 0LL; i != v43; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v99 != v44) {
          objc_enumerationMutation(findDsymsForIDs);
        }
        [a3 useDsymForUUIDFor:*(void *)(*((void *)&v98 + 1) + 8 * (void)i)];
      }

      int v43 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( findDsymsForIDs,  "countByEnumeratingWithState:objects:count:",  &v98,  v102,  16LL);
    }

    while (v43);
  }

  [a3 postprocess];

  self->_targetProcessBundleName = (NSString *)objc_msgSend(objc_msgSend(a3, "targetProcess"), "bundleName");
  self->_targetProcessBundleId = (NSString *)objc_msgSend(objc_msgSend(a3, "targetProcess"), "bundleIdentifier");
  BOOL v46 = (const __CFString *)objc_msgSend(objc_msgSend(a3, "targetProcess"), "bundleShortVersion");
  uint64_t v47 = @"???";
  if (v46) {
    id v48 = v46;
  }
  else {
    id v48 = @"???";
  }
  id v49 = (const __CFString *)objc_msgSend(objc_msgSend(a3, "targetProcess"), "bundleVersion");
  if (v49) {
    uint64_t v47 = v49;
  }

  self->_targetProcessVersion = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"%@ (%@)",  v48,  v47);
  self->_targetProcessAdamId = -[NSString initWithFormat:]( [NSString alloc],  "initWithFormat:",  @"%llu",  objc_msgSend(objc_msgSend(a3, "targetProcess"), "adamID"));

  self->_targetProcessName = (NSString *)objc_msgSend(objc_msgSend(a3, "targetProcess"), "name");
  self->_targetProcessMainBinaryUUID = (NSUUID *) objc_msgSend( objc_msgSend(objc_msgSend(a3, "targetProcess"), "mainBinary"),  "uuid");

  else {
    uint64_t v50 = 0LL;
  }
  self->_targetProcessAbsolutePath = v50;
  uint64_t v51 = objc_msgSend(objc_msgSend(a3, "targetProcess"), "isUnresponsive");
  uint64_t v52 = 0.0;
  if (v51) {
    objc_msgSend(objc_msgSend(a3, "targetProcess", 0.0), "timeOfLastResponse");
  }
  self->_targetProcessTimeOfLastResponse = v52;

  self->_hardwareModel = (NSString *)[a3 hardwareModel];
  [a3 setEvent:self->_event];
  [a3 setEventNote:self->_eventNote];
  [a3 setEventTimeRange:self->_eventTimeRange];
  [a3 setSignature:self->_signature];
  [a3 setExtraDuration:self->_extraDuration];
  [a3 setDurationNote:self->_durationNote];
  [a3 setStepsNote:stepsNote];
  [a3 setSanitizePaths:self->_sanitizePaths];
  [a3 setCustomOutput:self->_customOutput];
}

  *a11 = v44;
  int v45 = [a3 rangeWithName:@"startIndex"];
  if (v45 == (id)0x7FFFFFFFFFFFFFFFLL)
  {
    uint64_t v47 = 0;
    *a14 = 0;
  }

  else
  {
    *a14 = sub_10007BD4C(objc_msgSend(a1, "substringWithRange:", v45, v46));
    id v48 = [a3 rangeWithName:@"endIndex"];
    if (v48 == (id)0x7FFFFFFFFFFFFFFFLL) {
      uint64_t v47 = *a14;
    }
    else {
      uint64_t v47 = sub_10007BD4C(objc_msgSend(a1, "substringWithRange:", v48, v49));
    }
  }

  *uint64_t v18 = v47;
  objc_autoreleasePoolPop(context);
}

LABEL_51:
  +[SABinary clearCoreSymbolicationCaches](&OBJC_CLASS___SABinary, "clearCoreSymbolicationCaches");
  targetProcessId = self->_targetProcessId;
  size_t v33 = &self->_targetProcessId;
  if ((targetProcessId & 0x80000000) == 0)
  {
    if (byte_1000E7D30)
    {
      __int16 v35 = *__error();
      __darwin_time_t v36 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v36, OS_LOG_TYPE_INFO))
      {
        int v37 = sub_10002EF3C(*v33);
        BOOL v38 = *v33;
        *(_DWORD *)buf = 136446466;
        int v62 = v37;
        int v63 = 1024;
        uint64_t v64 = v38;
        _os_log_impl( (void *)&_mh_execute_header,  v36,  OS_LOG_TYPE_INFO,  "%{public}s [%d]: Done generating report",  buf,  0x12u);
      }

      *__error() = v35;
    }

    if (byte_1000E7D31) {
      int v39 = dword_1000E74E0 <= 1;
    }
    else {
      int v39 = 0;
    }
    if (!v39) {
      goto LABEL_100;
    }
    uintptr_t v40 = *__error();
    double v41 = sub_10002EF3C(*v33);
    int v42 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"%s [%d]: Done generating report",  v41,  *v33);
    if (v42)
    {
      int v43 = v42;
      double v44 = CFStringGetCStringPtr(v42, 0x8000100u);
      if (v44)
      {
        int v45 = (char *)v44;
        BOOL v46 = 0LL;
      }

      else
      {
        int v45 = (char *)calloc(0x400uLL, 1uLL);
        CFStringGetCString(v43, v45, 1024LL, 0x8000100u);
        BOOL v46 = v45;
      }

      if (qword_1000E7D38) {
        id v56 = (FILE *)qword_1000E7D38;
      }
      else {
        id v56 = __stderrp;
      }
      fprintf(v56, "%s\n", v45);
      if (v46) {
        free(v46);
      }
      int v57 = v43;
LABEL_98:
      CFRelease(v57);
LABEL_99:
      *__error() = v40;
      goto LABEL_100;
    }

    stat v55 = (os_log_s *)sub_10002EFA0();
    if (os_log_type_enabled(v55, OS_LOG_TYPE_FAULT)) {
      sub_10008F15C();
    }
    goto LABEL_87;
  }

  if (byte_1000E7D30)
  {
    uint64_t v47 = *__error();
    id v48 = (os_log_s *)sub_10002EFA0();
    if (os_log_type_enabled(v48, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v48, OS_LOG_TYPE_INFO, "Done generating report", buf, 2u);
    }

    *__error() = v47;
  }

  if (byte_1000E7D31) {
    id v49 = dword_1000E74E0 <= 1;
  }
  else {
    id v49 = 0;
  }
  if (v49)
  {
    uintptr_t v40 = *__error();
    uint64_t v50 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"Done generating report");
    if (v50)
    {
      uint64_t v51 = v50;
      uint64_t v52 = CFStringGetCStringPtr(v50, 0x8000100u);
      if (v52)
      {
        uint64_t v53 = (char *)v52;
        int v54 = 0LL;
      }

      else
      {
        uint64_t v53 = (char *)calloc(0x400uLL, 1uLL);
        CFStringGetCString(v51, v53, 1024LL, 0x8000100u);
        int v54 = v53;
      }

      if (qword_1000E7D38) {
        int v60 = (FILE *)qword_1000E7D38;
      }
      else {
        int v60 = __stderrp;
      }
      fprintf(v60, "%s\n", v53);
      if (v54) {
        free(v54);
      }
      int v57 = v51;
      goto LABEL_98;
    }

    int v58 = (os_log_s *)sub_10002EFA0();
    if (os_log_type_enabled(v58, OS_LOG_TYPE_FAULT)) {
      sub_10008F1C8();
    }
LABEL_87:
    if (qword_1000E7D38) {
      int v59 = (FILE *)qword_1000E7D38;
    }
    else {
      int v59 = __stderrp;
    }
    fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v59);
    goto LABEL_99;
  }

LABEL_100:
  objc_autoreleasePoolPop(v7);
}

void sub_1000606D8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

void sub_1000606F0(id a1)
{
  qword_1000E7CB0 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
  uint64_t v1 = dispatch_queue_attr_make_with_autorelease_frequency(0LL, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
  qword_1000E7CB8 = (uint64_t)dispatch_queue_create("com.apple.spindump.create_sampled_process", v1);
  dispatch_release(v1);
}

void sub_100060748(uint64_t a1, uint64_t a2)
{
}

void sub_100060758(uint64_t a1)
{
}

id sub_100060764(uint64_t a1)
{
  *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 40) = [(id)qword_1000E7CB0 objectForKey:*(void *)(a1 + 32)];
  id result = *(id *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 40LL);
  if (result)
  {
    ssize_t v3 = *(_BYTE **)(a1 + 48);
    if (v3)
    {
      *ssize_t v3 = 1;
      id result = *(id *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 40LL);
    }

    id result = [result isWSBased];
    uint64_t v4 = *(void *)(*(void *)(a1 + 40) + 8LL);
    else {
      *(void *)(v4 + 40) = 0LL;
    }
  }

  else
  {
    if (*(_BYTE *)(a1 + 60))
    {
      *(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 40LL) = -[SPSampledProcess initWithPid:isWSBased:]( objc_alloc(&OBJC_CLASS___SPSampledProcess),  "initWithPid:isWSBased:",  *(unsigned int *)(a1 + 56),  *(unsigned __int8 *)(a1 + 61));
      id result = [(id)qword_1000E7CB0 setObject:*(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 40) forKey:*(void *)(a1 + 32)];
      *(_BYTE *)(*(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 40LL) + 299LL) = 1;
    }

    double v5 = *(_BYTE **)(a1 + 48);
    if (v5) {
      *double v5 = 0;
    }
  }

  return result;
}

id sub_1000608D4(uint64_t a1)
{
  ssize_t v2 = -[NSNumber initWithInt:](objc_alloc(&OBJC_CLASS___NSNumber), "initWithInt:", *(unsigned int *)(a1 + 40));
  id v3 = *(id *)(a1 + 32);
  if (v3 == [(id)qword_1000E7CB0 objectForKey:v2]) {
    [(id)qword_1000E7CB0 removeObjectForKey:v2];
  }

  id result = [(id)qword_1000E7CB0 count];
  if (!result) {
    return +[SPSampledProcess stopMemoryPressureTimer](&OBJC_CLASS___SPSampledProcess, "stopMemoryPressureTimer");
  }
  return result;
}

id sub_100060CEC(uint64_t a1)
{
  uint64_t v1 = (id *)(a1 + 32);
  if ((*(_DWORD *)(*(void *)(a1 + 32) + 72LL) & 0x80000000) == 0)
  {
    if (byte_1000E7D30)
    {
      int v2 = *__error();
      id v3 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v3, OS_LOG_TYPE_INFO))
      {
        uint64_t v4 = sub_10002EF3C(*((_DWORD *)*v1 + 18));
        int v5 = *((_DWORD *)*v1 + 18);
        *(_DWORD *)buf = 136446466;
        uint64_t v24 = v4;
        __int16 v25 = 1024;
        int v26 = v5;
        _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_INFO, "%{public}s [%d]: exited - HID", buf, 0x12u);
      }

      *__error() = v2;
    }

    if (byte_1000E7D31) {
      BOOL v6 = dword_1000E74E0 <= 1;
    }
    else {
      BOOL v6 = 0;
    }
    if (!v6) {
      goto LABEL_40;
    }
    int v7 = *__error();
    double v8 = sub_10002EF3C(*((_DWORD *)*v1 + 18));
    double v9 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"%s [%d]: exited - HID",  v8,  *((unsigned int *)*v1 + 18));
    if (!v9)
    {
      double v10 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_FAULT)) {
        sub_10008F454();
      }
LABEL_35:
      if (qword_1000E7D38) {
        int v20 = (FILE *)qword_1000E7D38;
      }
      else {
        int v20 = __stderrp;
      }
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v20);
LABEL_39:
      *__error() = v7;
      goto LABEL_40;
    }

    goto LABEL_24;
  }

  if (byte_1000E7D30)
  {
    int v11 = *__error();
    double v12 = (os_log_s *)sub_10002EFA0();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_INFO, "exited - HID", buf, 2u);
    }

    *__error() = v11;
  }

  if (byte_1000E7D31) {
    BOOL v13 = dword_1000E74E0 <= 1;
  }
  else {
    BOOL v13 = 0;
  }
  if (v13)
  {
    int v7 = *__error();
    double v9 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"exited - HID");
    if (!v9)
    {
      BOOL v19 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v19, OS_LOG_TYPE_FAULT)) {
        sub_10008F4C0();
      }
      goto LABEL_35;
    }

LABEL_40:
  v22[0] = _NSConcreteStackBlock;
  v22[1] = 3221225472LL;
  v22[2] = sub_1000610C8;
  v22[3] = &unk_1000D98E0;
  v22[4] = *v1;
  sub_10006103C((uint64_t)v22);
  return [*v1 deleteHIDExitSource];
}

  unsigned int v28 = *v5;
  int v29 = (dispatch_queue_s *)*((void *)*v5 + 7);
  if (v29)
  {
    if (v28[8])
    {
      block[0] = _NSConcreteStackBlock;
      block[1] = 3221225472LL;
      block[2] = sub_100068A74;
      block[3] = &unk_1000D9930;
      void block[4] = v28;
      id v73 = v11;
      dispatch_async(v29, block);
      dispatch_release(*((dispatch_object_t *)*v5 + 7));
      *((void *)*v5 + 7) = 0LL;
    }
  }

void sub_10006103C(uint64_t a1)
{
  if (qword_1000E7CD0 != -1) {
    dispatch_once(&qword_1000E7CD0, &stru_1000D9A90);
  }
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472LL;
  block[2] = sub_10006BA50;
  block[3] = &unk_1000D9AB8;
  void block[4] = a1;
  dispatch_sync((dispatch_queue_t)qword_1000E7CC0, block);
}

int *sub_1000610C8(uint64_t a1, void *a2)
{
  id v3 = (int **)(a1 + 32);
  id result = (int *)objc_msgSend( a2,  "objectForKeyedSubscript:",  +[NSNumber numberWithInt:]( NSNumber,  "numberWithInt:",  *(unsigned int *)(*(void *)(a1 + 32) + 72)));
  int v5 = *v3;
  if (result) {
    BOOL v6 = result == v5;
  }
  else {
    BOOL v6 = 0;
  }
  if (v6)
  {
    uint64_t v17 = result;
    if (result[18] < 0)
    {
      if (byte_1000E7D30)
      {
        int v33 = *__error();
        uint64_t v34 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v34, OS_LOG_TYPE_DEBUG)) {
          sub_10008F5F0();
        }
        *__error() = v33;
      }

      if (byte_1000E7D31) {
        BOOL v35 = dword_1000E74E0 <= 0;
      }
      else {
        BOOL v35 = 0;
      }
      if (!v35) {
        goto LABEL_84;
      }
      int v21 = *__error();
      uint64_t v23 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"Process exited, no longer waiting for HID event");
      if (!v23)
      {
        BOOL v46 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v46, OS_LOG_TYPE_FAULT)) {
          sub_10008F5C4();
        }
        goto LABEL_79;
      }
    }

    else
    {
      if (byte_1000E7D30)
      {
        int v18 = *__error();
        BOOL v19 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG)) {
          sub_10008F558();
        }
        *__error() = v18;
      }

      if (byte_1000E7D31) {
        BOOL v20 = dword_1000E74E0 <= 0;
      }
      else {
        BOOL v20 = 0;
      }
      if (!v20) {
        goto LABEL_84;
      }
      int v21 = *__error();
      int v22 = sub_10002EF3C((*v3)[18]);
      uint64_t v23 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"%s [%d]: Process exited, no longer waiting for HID event",  v22,  (*v3)[18]);
      if (!v23)
      {
        uint64_t v24 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v24, OS_LOG_TYPE_FAULT)) {
          sub_10008F4EC();
        }
LABEL_79:
        if (qword_1000E7D38) {
          uint64_t v47 = (FILE *)qword_1000E7D38;
        }
        else {
          uint64_t v47 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v47);
LABEL_83:
        *__error() = v21;
LABEL_84:
        dispatch_semaphore_signal(*((dispatch_semaphore_t *)v17 + 53));
        return (int *)objc_msgSend( a2,  "setObject:forKeyedSubscript:",  0,  +[NSNumber numberWithInt:](NSNumber, "numberWithInt:", (*v3)[18]));
      }
    }

    __darwin_time_t v36 = v23;
    CStringPtr = CFStringGetCStringPtr(v23, 0x8000100u);
    if (CStringPtr)
    {
      BOOL v38 = (char *)CStringPtr;
      int v39 = 0LL;
    }

    else
    {
      BOOL v38 = (char *)calloc(0x400uLL, 1uLL);
      CFStringGetCString(v36, v38, 1024LL, 0x8000100u);
      int v39 = v38;
    }

    if (qword_1000E7D38) {
      double v41 = (FILE *)qword_1000E7D38;
    }
    else {
      double v41 = __stderrp;
    }
    fprintf(v41, "%s\n", v38);
    if (v39) {
      free(v39);
    }
    CFRelease(v36);
    goto LABEL_83;
  }

  if ((v5[18] & 0x80000000) == 0)
  {
    if (byte_1000E7D30)
    {
      int v7 = *__error();
      double v8 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG)) {
        sub_10008F688();
      }
      id result = __error();
      *id result = v7;
    }

    if (byte_1000E7D31) {
      BOOL v9 = dword_1000E74E0 <= 0;
    }
    else {
      BOOL v9 = 0;
    }
    if (!v9) {
      return result;
    }
    int v10 = *__error();
    int v11 = sub_10002EF3C((*v3)[18]);
    double v12 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"%s [%d]: Process exited, and not waiting for a HID event",  v11,  (*v3)[18]);
    if (v12)
    {
      BOOL v13 = v12;
      double v14 = CFStringGetCStringPtr(v12, 0x8000100u);
      if (v14)
      {
        double v15 = (char *)v14;
        uint64_t v16 = 0LL;
      }

      else
      {
        double v15 = (char *)calloc(0x400uLL, 1uLL);
        CFStringGetCString(v13, v15, 1024LL, 0x8000100u);
        uint64_t v16 = v15;
      }

      if (qword_1000E7D38) {
        int v42 = (FILE *)qword_1000E7D38;
      }
      else {
        int v42 = __stderrp;
      }
      fprintf(v42, "%s\n", v15);
      if (v16) {
        free(v16);
      }
      int v43 = v13;
LABEL_92:
      CFRelease(v43);
LABEL_93:
      id result = __error();
      *id result = v10;
      return result;
    }

    uintptr_t v40 = (os_log_s *)sub_10002EFA0();
    if (os_log_type_enabled(v40, OS_LOG_TYPE_FAULT)) {
      sub_10008F61C();
    }
    goto LABEL_73;
  }

  if (byte_1000E7D30)
  {
    int v25 = *__error();
    int v26 = (os_log_s *)sub_10002EFA0();
    if (os_log_type_enabled(v26, OS_LOG_TYPE_DEBUG)) {
      sub_10008F720();
    }
    id result = __error();
    *id result = v25;
  }

  if (byte_1000E7D31) {
    BOOL v27 = dword_1000E74E0 <= 0;
  }
  else {
    BOOL v27 = 0;
  }
  if (v27)
  {
    int v10 = *__error();
    unsigned int v28 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"Process exited, and not waiting for a HID event");
    if (v28)
    {
      int v29 = v28;
      uint64_t v30 = CFStringGetCStringPtr(v28, 0x8000100u);
      if (v30)
      {
        BOOL v31 = (char *)v30;
        int v32 = 0LL;
      }

      else
      {
        BOOL v31 = (char *)calloc(0x400uLL, 1uLL);
        CFStringGetCString(v29, v31, 1024LL, 0x8000100u);
        int v32 = v31;
      }

      if (qword_1000E7D38) {
        id v48 = (FILE *)qword_1000E7D38;
      }
      else {
        id v48 = __stderrp;
      }
      fprintf(v48, "%s\n", v31);
      if (v32) {
        free(v32);
      }
      int v43 = v29;
      goto LABEL_92;
    }

    double v44 = (os_log_s *)sub_10002EFA0();
    if (os_log_type_enabled(v44, OS_LOG_TYPE_FAULT)) {
      sub_10008F6F4();
    }
LABEL_73:
    if (qword_1000E7D38) {
      int v45 = (FILE *)qword_1000E7D38;
    }
    else {
      int v45 = __stderrp;
    }
    fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v45);
    goto LABEL_93;
  }

  return result;
}

void sub_100061714(uint64_t a1)
{
  v1[0] = _NSConcreteStackBlock;
  v1[1] = 3221225472LL;
  v1[2] = sub_100061770;
  v1[3] = &unk_1000D9908;
  v1[4] = *(void *)(a1 + 32);
  char v2 = *(_BYTE *)(a1 + 40);
  sub_10006103C((uint64_t)v1);
}

int *sub_100061770(uint64_t a1, void *a2)
{
  id v3 = (int **)(a1 + 32);
  id result = (int *)objc_msgSend( a2,  "objectForKeyedSubscript:",  +[NSNumber numberWithInt:]( NSNumber,  "numberWithInt:",  objc_msgSend(*(id *)(a1 + 32), "targetProcessId")));
  int v5 = *v3;
  if (!*((_BYTE *)v3 + 8))
  {
    if (result)
    {
      if (result != v5)
      {
        if (v5[18] < 0)
        {
          if (byte_1000E7D30)
          {
            int v67 = *__error();
            id v68 = (os_log_s *)sub_10002EFA0();
            if (os_log_type_enabled(v68, OS_LOG_TYPE_DEBUG)) {
              sub_10008FE70();
            }
            *__error() = v67;
          }

          if (byte_1000E7D31) {
            BOOL v69 = dword_1000E74E0 <= 0;
          }
          else {
            BOOL v69 = 0;
          }
          if (!v69) {
            goto LABEL_216;
          }
          int v18 = *__error();
          BOOL v20 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"Previous spin waiting for HID event");
          if (!v20)
          {
            id v107 = (os_log_s *)sub_10002EFA0();
            if (os_log_type_enabled(v107, OS_LOG_TYPE_FAULT)) {
              sub_10008FE44();
            }
            goto LABEL_211;
          }
        }

        else
        {
          if (byte_1000E7D30)
          {
            int v15 = *__error();
            uint64_t v16 = (os_log_s *)sub_10002EFA0();
            if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG)) {
              sub_10008FDD8();
            }
            *__error() = v15;
          }

          if (byte_1000E7D31) {
            BOOL v17 = dword_1000E74E0 <= 0;
          }
          else {
            BOOL v17 = 0;
          }
          if (!v17) {
            goto LABEL_216;
          }
          int v18 = *__error();
          BOOL v19 = sub_10002EF3C((*v3)[18]);
          BOOL v20 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"%s [%d]: Previous spin waiting for HID event",  v19,  (*v3)[18]);
          if (!v20)
          {
            int v21 = (os_log_s *)sub_10002EFA0();
            if (os_log_type_enabled(v21, OS_LOG_TYPE_FAULT)) {
              sub_10008FD6C();
            }
LABEL_211:
            if (qword_1000E7D38) {
              id v108 = (FILE *)qword_1000E7D38;
            }
            else {
              id v108 = __stderrp;
            }
            fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v108);
LABEL_215:
            *__error() = v18;
LABEL_216:
            id result = *v3;
            if (!*((void *)*v3 + 53)) {
              return result;
            }
            if (([result targetProcessId] & 0x80000000) != 0)
            {
              if (byte_1000E7D30)
              {
                int v135 = *__error();
                id v136 = (os_log_s *)sub_10002EFA0();
                if (os_log_type_enabled(v136, OS_LOG_TYPE_ERROR)) {
                  sub_10008FCFC(v136, v137, v138, v139, v140, v141, v142, v143);
                }
                *__error() = v135;
              }

              if (byte_1000E7D31 && dword_1000E74E0 <= 3)
              {
                int v144 = *__error();
                id v145 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"%s: _hidEventSem non-NULL when already tracking this process in previous spin",  "_hidEventSem == NULL");
                if (v145)
                {
                  id v179 = v145;
                  CStringPtr = CFStringGetCStringPtr(v145, 0x8000100u);
                  if (CStringPtr)
                  {
                    id v181 = (char *)CStringPtr;
                    id v182 = 0LL;
                  }

                  else
                  {
                    id v181 = (char *)calloc(0x400uLL, 1uLL);
                    CFStringGetCString(v179, v181, 1024LL, 0x8000100u);
                    id v182 = v181;
                  }

                  if (qword_1000E7D38) {
                    time_t v194 = (FILE *)qword_1000E7D38;
                  }
                  else {
                    time_t v194 = __stderrp;
                  }
                  fprintf(v194, "%s\n", v181);
                  if (v182) {
                    free(v182);
                  }
                  CFRelease(v179);
                }

                else
                {
                  BOOL v146 = (os_log_s *)sub_10002EFA0();
                  if (os_log_type_enabled(v146, OS_LOG_TYPE_FAULT)) {
                    sub_10008FC8C(v146, v147, v148, v149, v150, v151, v152, v153);
                  }
                  if (qword_1000E7D38) {
                    id v154 = (FILE *)qword_1000E7D38;
                  }
                  else {
                    id v154 = __stderrp;
                  }
                  fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v154);
                }

                *__error() = v144;
              }

              int v199 = "_hidEventSem == NULL";
              time_t v193 = "%s: _hidEventSem non-NULL when already tracking this process in previous spin";
            }

            else
            {
              if (byte_1000E7D30)
              {
                int v113 = *__error();
                id v114 = (os_log_s *)sub_10002EFA0();
                if (os_log_type_enabled(v114, OS_LOG_TYPE_ERROR)) {
                  sub_10008FC0C();
                }
                *__error() = v113;
              }

              if (byte_1000E7D31 && dword_1000E74E0 <= 3)
              {
                int v115 = *__error();
                id v116 = sub_10002EF3C((int)[*v3 targetProcessId]);
                unsigned int v117 = CFStringCreateWithFormat( kCFAllocatorDefault,  0,  @"%s [%d]: %s: _hidEventSem non-NULL when already tracking this process in previous spin",  v116,  [*v3 targetProcessId],  "_hidEventSem == NULL");
                if (v117)
                {
                  id v175 = v117;
                  int v176 = CFStringGetCStringPtr(v117, 0x8000100u);
                  if (v176)
                  {
                    id v177 = (char *)v176;
                    id v178 = 0LL;
                  }

                  else
                  {
                    id v177 = (char *)calloc(0x400uLL, 1uLL);
                    CFStringGetCString(v175, v177, 1024LL, 0x8000100u);
                    id v178 = v177;
                  }

                  if (qword_1000E7D38) {
                    int v191 = (FILE *)qword_1000E7D38;
                  }
                  else {
                    int v191 = __stderrp;
                  }
                  fprintf(v191, "%s\n", v177);
                  if (v178) {
                    free(v178);
                  }
                  CFRelease(v175);
                }

                else
                {
                  id v118 = (os_log_s *)sub_10002EFA0();
                  if (os_log_type_enabled(v118, OS_LOG_TYPE_FAULT)) {
                    sub_10008FB8C();
                  }
                  if (qword_1000E7D38) {
                    id v119 = (FILE *)qword_1000E7D38;
                  }
                  else {
                    id v119 = __stderrp;
                  }
                  fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v119);
                }

                *__error() = v115;
              }

              unsigned __int8 v192 = sub_10002EF3C((int)[*v3 targetProcessId]);
              [*v3 targetProcessId];
              LOBYTE(v199) = v192;
              time_t v193 = "%s [%d]: %s: _hidEventSem non-NULL when already tracking this process in previous spin";
            }

            int v195 = 951;
            goto LABEL_356;
          }
        }

        id v70 = v20;
        id v71 = CFStringGetCStringPtr(v20, 0x8000100u);
        if (v71)
        {
          id v72 = (char *)v71;
          id v73 = 0LL;
        }

        else
        {
          id v72 = (char *)calloc(0x400uLL, 1uLL);
          CFStringGetCString(v70, v72, 1024LL, 0x8000100u);
          id v73 = v72;
        }

        if (qword_1000E7D38) {
          id v101 = (FILE *)qword_1000E7D38;
        }
        else {
          id v101 = __stderrp;
        }
        fprintf(v101, "%s\n", v72);
        if (v73) {
          free(v73);
        }
        CFRelease(v70);
        goto LABEL_215;
      }

      if (result[18] < 0)
      {
        if (byte_1000E7D30)
        {
          int v89 = *__error();
          id v90 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v90, OS_LOG_TYPE_DEBUG)) {
            sub_10008FB60();
          }
          *__error() = v89;
        }

        if (byte_1000E7D31) {
          BOOL v91 = dword_1000E74E0 <= 0;
        }
        else {
          BOOL v91 = 0;
        }
        if (!v91) {
          goto LABEL_282;
        }
        int v56 = *__error();
        int v58 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"No longer waiting for HID event");
        if (!v58)
        {
          id v133 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v133, OS_LOG_TYPE_FAULT)) {
            sub_10008FB34();
          }
          goto LABEL_277;
        }
      }

      else
      {
        if (byte_1000E7D30)
        {
          int v53 = *__error();
          int v54 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v54, OS_LOG_TYPE_DEBUG)) {
            sub_10008FAC8();
          }
          *__error() = v53;
        }

        if (byte_1000E7D31) {
          BOOL v55 = dword_1000E74E0 <= 0;
        }
        else {
          BOOL v55 = 0;
        }
        if (!v55) {
          goto LABEL_282;
        }
        int v56 = *__error();
        int v57 = sub_10002EF3C((*v3)[18]);
        int v58 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"%s [%d]: No longer waiting for HID event",  v57,  (*v3)[18]);
        if (!v58)
        {
          int v59 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v59, OS_LOG_TYPE_FAULT)) {
            sub_10008FA5C();
          }
LABEL_277:
          if (qword_1000E7D38) {
            id v134 = (FILE *)qword_1000E7D38;
          }
          else {
            id v134 = __stderrp;
          }
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v134);
LABEL_281:
          *__error() = v56;
LABEL_282:
          dispatch_semaphore_signal(*((dispatch_semaphore_t *)*v3 + 53));
          dispatch_release(*((dispatch_object_t *)*v3 + 53));
          *((void *)*v3 + 53) = 0LL;
          objc_msgSend( a2,  "setObject:forKeyedSubscript:",  0,  +[NSNumber numberWithInt:](NSNumber, "numberWithInt:", objc_msgSend(*v3, "targetProcessId")));
          return (int *)[*v3 deleteHIDExitSource];
        }
      }

      id v92 = v58;
      id v93 = CFStringGetCStringPtr(v58, 0x8000100u);
      if (v93)
      {
        uint64_t v94 = (char *)v93;
        id v95 = 0LL;
      }

      else
      {
        uint64_t v94 = (char *)calloc(0x400uLL, 1uLL);
        CFStringGetCString(v92, v94, 1024LL, 0x8000100u);
        id v95 = v94;
      }

      if (qword_1000E7D38) {
        id v122 = (FILE *)qword_1000E7D38;
      }
      else {
        id v122 = __stderrp;
      }
      fprintf(v122, "%s\n", v94);
      if (v95) {
        free(v95);
      }
      CFRelease(v92);
      goto LABEL_281;
    }

    if (v5[18] < 0)
    {
      if (byte_1000E7D30)
      {
        int v82 = *__error();
        uintptr_t v83 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v83, OS_LOG_TYPE_DEBUG)) {
          sub_10008FA30();
        }
        *__error() = v82;
      }

      if (byte_1000E7D31) {
        BOOL v84 = dword_1000E74E0 <= 0;
      }
      else {
        BOOL v84 = 0;
      }
      if (!v84) {
        goto LABEL_251;
      }
      int v42 = *__error();
      double v44 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"Doesn't require HID event and we weren't waiting before anyway");
      if (!v44)
      {
        uint64_t v123 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v123, OS_LOG_TYPE_FAULT)) {
          sub_10008FA04();
        }
        goto LABEL_246;
      }
    }

    else
    {
      if (byte_1000E7D30)
      {
        int v39 = *__error();
        uintptr_t v40 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v40, OS_LOG_TYPE_DEBUG)) {
          sub_10008F998();
        }
        *__error() = v39;
      }

      if (byte_1000E7D31) {
        BOOL v41 = dword_1000E74E0 <= 0;
      }
      else {
        BOOL v41 = 0;
      }
      if (!v41) {
        goto LABEL_251;
      }
      int v42 = *__error();
      int v43 = sub_10002EF3C((*v3)[18]);
      double v44 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"%s [%d]: Doesn't require HID event and we weren't waiting before anyway",  v43,  (*v3)[18]);
      if (!v44)
      {
        int v45 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v45, OS_LOG_TYPE_FAULT)) {
          sub_10008F92C();
        }
LABEL_246:
        if (qword_1000E7D38) {
          id v124 = (FILE *)qword_1000E7D38;
        }
        else {
          id v124 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v124);
LABEL_250:
        *__error() = v42;
LABEL_251:
        id result = *v3;
        if (!*((void *)*v3 + 53)) {
          return result;
        }
        if (([result targetProcessId] & 0x80000000) != 0)
        {
          if (byte_1000E7D30)
          {
            int v155 = *__error();
            id v156 = (os_log_s *)sub_10002EFA0();
            if (os_log_type_enabled(v156, OS_LOG_TYPE_ERROR)) {
              sub_10008F8BC(v156, v157, v158, v159, v160, v161, v162, v163);
            }
            *__error() = v155;
          }

          if (byte_1000E7D31 && dword_1000E74E0 <= 3)
          {
            int v164 = *__error();
            uint64_t v165 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"%s: _hidEventSem non-NULL when not requiring HID event",  "_hidEventSem == NULL");
            if (v165)
            {
              id v187 = v165;
              uint64_t v188 = CFStringGetCStringPtr(v165, 0x8000100u);
              if (v188)
              {
                int v189 = (char *)v188;
                int v190 = 0LL;
              }

              else
              {
                int v189 = (char *)calloc(0x400uLL, 1uLL);
                CFStringGetCString(v187, v189, 1024LL, 0x8000100u);
                int v190 = v189;
              }

              if (qword_1000E7D38) {
                unsigned int v198 = (FILE *)qword_1000E7D38;
              }
              else {
                unsigned int v198 = __stderrp;
              }
              fprintf(v198, "%s\n", v189);
              if (v190) {
                free(v190);
              }
              CFRelease(v187);
            }

            else
            {
              uint64_t v166 = (os_log_s *)sub_10002EFA0();
              if (os_log_type_enabled(v166, OS_LOG_TYPE_FAULT)) {
                sub_10008F84C(v166, v167, v168, v169, v170, v171, v172, v173);
              }
              if (qword_1000E7D38) {
                id v174 = (FILE *)qword_1000E7D38;
              }
              else {
                id v174 = __stderrp;
              }
              fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v174);
            }

            *__error() = v164;
          }

          int v199 = "_hidEventSem == NULL";
          time_t v193 = "%s: _hidEventSem non-NULL when not requiring HID event";
        }

        else
        {
          if (byte_1000E7D30)
          {
            int v125 = *__error();
            id v126 = (os_log_s *)sub_10002EFA0();
            if (os_log_type_enabled(v126, OS_LOG_TYPE_ERROR)) {
              sub_10008F7CC();
            }
            *__error() = v125;
          }

          if (byte_1000E7D31 && dword_1000E74E0 <= 3)
          {
            int v127 = *__error();
            id v128 = sub_10002EF3C((int)[*v3 targetProcessId]);
            id v129 = CFStringCreateWithFormat( kCFAllocatorDefault,  0,  @"%s [%d]: %s: _hidEventSem non-NULL when not requiring HID event",  v128,  [*v3 targetProcessId],  "_hidEventSem == NULL");
            if (v129)
            {
              id v183 = v129;
              id v184 = CFStringGetCStringPtr(v129, 0x8000100u);
              if (v184)
              {
                id v185 = (char *)v184;
                id v186 = 0LL;
              }

              else
              {
                id v185 = (char *)calloc(0x400uLL, 1uLL);
                CFStringGetCString(v183, v185, 1024LL, 0x8000100u);
                id v186 = v185;
              }

              if (qword_1000E7D38) {
                id v196 = (FILE *)qword_1000E7D38;
              }
              else {
                id v196 = __stderrp;
              }
              fprintf(v196, "%s\n", v185);
              if (v186) {
                free(v186);
              }
              CFRelease(v183);
            }

            else
            {
              unsigned int v130 = (os_log_s *)sub_10002EFA0();
              if (os_log_type_enabled(v130, OS_LOG_TYPE_FAULT)) {
                sub_10008F74C();
              }
              if (qword_1000E7D38) {
                id v131 = (FILE *)qword_1000E7D38;
              }
              else {
                id v131 = __stderrp;
              }
              fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v131);
            }

            *__error() = v127;
          }

          unsigned __int8 v197 = sub_10002EF3C((int)[*v3 targetProcessId]);
          [*v3 targetProcessId];
          LOBYTE(v199) = v197;
          time_t v193 = "%s [%d]: %s: _hidEventSem non-NULL when not requiring HID event";
        }

        int v195 = 963;
LABEL_356:
        sub_10002EE78( "-[SPSampledProcess requireHIDEvent:]_block_invoke",  "SPProcessEvent.m",  v195,  v193,  v109,  v110,  v111,  v112,  (char)v199);
        abort();
      }
    }

    int v85 = v44;
    int v86 = CFStringGetCStringPtr(v44, 0x8000100u);
    if (v86)
    {
      int v87 = (char *)v86;
      id v88 = 0LL;
    }

    else
    {
      int v87 = (char *)calloc(0x400uLL, 1uLL);
      CFStringGetCString(v85, v87, 1024LL, 0x8000100u);
      id v88 = v87;
    }

    if (qword_1000E7D38) {
      unsigned int v104 = (FILE *)qword_1000E7D38;
    }
    else {
      unsigned int v104 = __stderrp;
    }
    fprintf(v104, "%s\n", v87);
    if (v88) {
      free(v88);
    }
    CFRelease(v85);
    goto LABEL_250;
  }

  if (!result)
  {
    if (v5[18] < 0)
    {
      if (byte_1000E7D30)
      {
        int v60 = *__error();
        int v61 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v61, OS_LOG_TYPE_DEBUG)) {
          sub_10008FFA0();
        }
        *__error() = v60;
      }

      if (byte_1000E7D31) {
        BOOL v62 = dword_1000E74E0 <= 0;
      }
      else {
        BOOL v62 = 0;
      }
      if (!v62) {
        goto LABEL_194;
      }
      int v25 = *__error();
      BOOL v27 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"Requires HID event");
      if (!v27)
      {
        id v102 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v102, OS_LOG_TYPE_FAULT)) {
          sub_10008FF74();
        }
        goto LABEL_189;
      }
    }

    else
    {
      if (byte_1000E7D30)
      {
        int v22 = *__error();
        uint64_t v23 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v23, OS_LOG_TYPE_DEBUG)) {
          sub_10008FF08();
        }
        *__error() = v22;
      }

      if (byte_1000E7D31) {
        BOOL v24 = dword_1000E74E0 <= 0;
      }
      else {
        BOOL v24 = 0;
      }
      if (!v24) {
        goto LABEL_194;
      }
      int v25 = *__error();
      int v26 = sub_10002EF3C((*v3)[18]);
      BOOL v27 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"%s [%d]: Requires HID event",  v26,  (*v3)[18]);
      if (!v27)
      {
        unsigned int v28 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v28, OS_LOG_TYPE_FAULT)) {
          sub_10008FE9C();
        }
LABEL_189:
        if (qword_1000E7D38) {
          uint32_t v103 = (FILE *)qword_1000E7D38;
        }
        else {
          uint32_t v103 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v103);
LABEL_193:
        *__error() = v25;
LABEL_194:
        *((void *)*v3 + 53) = dispatch_semaphore_create(0LL);
        objc_msgSend( a2,  "setObject:forKeyedSubscript:",  *v3,  +[NSNumber numberWithInt:](NSNumber, "numberWithInt:", objc_msgSend(*v3, "targetProcessId")));
        return (int *)[*v3 createHIDExitSource];
      }
    }

    int v63 = v27;
    uint64_t v64 = CFStringGetCStringPtr(v27, 0x8000100u);
    if (v64)
    {
      int v65 = (char *)v64;
      uint64_t v66 = 0LL;
    }

    else
    {
      int v65 = (char *)calloc(0x400uLL, 1uLL);
      CFStringGetCString(v63, v65, 1024LL, 0x8000100u);
      uint64_t v66 = v65;
    }

    if (qword_1000E7D38) {
      tm v97 = (FILE *)qword_1000E7D38;
    }
    else {
      tm v97 = __stderrp;
    }
    fprintf(v97, "%s\n", v65);
    if (v66) {
      free(v66);
    }
    CFRelease(v63);
    goto LABEL_193;
  }

  if (result != v5)
  {
    if (v5[18] < 0)
    {
      if (byte_1000E7D30)
      {
        int v46 = *__error();
        uint64_t v47 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v47, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v47,  OS_LOG_TYPE_DEFAULT,  "Already waiting for HID event from previous spin, canceling this spin",  buf,  2u);
        }

        *__error() = v46;
      }

      if (byte_1000E7D31) {
        BOOL v48 = dword_1000E74E0 <= 2;
      }
      else {
        BOOL v48 = 0;
      }
      if (!v48) {
        return (int *)[*v3 stopSamplingWithReason:7];
      }
      int v11 = *__error();
      BOOL v13 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"Already waiting for HID event from previous spin, canceling this spin");
      if (!v13)
      {
        id v99 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v99, OS_LOG_TYPE_FAULT)) {
          sub_100090168();
        }
        goto LABEL_174;
      }
    }

    else
    {
      if (byte_1000E7D30)
      {
        int v6 = *__error();
        int v7 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
        {
          double v8 = sub_10002EF3C((*v3)[18]);
          int v9 = (*v3)[18];
          *(_DWORD *)buf = 136446466;
          int v201 = v8;
          __int16 v202 = 1024;
          int v203 = v9;
          _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "%{public}s [%d]: Already waiting for HID event from previous spin, canceling this spin",  buf,  0x12u);
        }

        *__error() = v6;
      }

      if (byte_1000E7D31) {
        BOOL v10 = dword_1000E74E0 <= 2;
      }
      else {
        BOOL v10 = 0;
      }
      if (!v10) {
        return (int *)[*v3 stopSamplingWithReason:7];
      }
      int v11 = *__error();
      double v12 = sub_10002EF3C((*v3)[18]);
      BOOL v13 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"%s [%d]: Already waiting for HID event from previous spin, canceling this spin",  v12,  (*v3)[18]);
      if (!v13)
      {
        double v14 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v14, OS_LOG_TYPE_FAULT)) {
          sub_1000900FC();
        }
LABEL_174:
        if (qword_1000E7D38) {
          id v100 = (FILE *)qword_1000E7D38;
        }
        else {
          id v100 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v100);
LABEL_178:
        *__error() = v11;
        return (int *)[*v3 stopSamplingWithReason:7];
      }
    }

    id v49 = v13;
    uint64_t v50 = CFStringGetCStringPtr(v13, 0x8000100u);
    if (v50)
    {
      uint64_t v51 = (char *)v50;
      uint64_t v52 = 0LL;
    }

    else
    {
      uint64_t v51 = (char *)calloc(0x400uLL, 1uLL);
      CFStringGetCString(v49, v51, 1024LL, 0x8000100u);
      uint64_t v52 = v51;
    }

    if (qword_1000E7D38) {
      time_t v96 = (FILE *)qword_1000E7D38;
    }
    else {
      time_t v96 = __stderrp;
    }
    fprintf(v96, "%s\n", v51);
    if (v52) {
      free(v52);
    }
    CFRelease(v49);
    goto LABEL_178;
  }

  if ((result[18] & 0x80000000) == 0)
  {
    if (byte_1000E7D30)
    {
      int v29 = *__error();
      uint64_t v30 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v30, OS_LOG_TYPE_DEBUG)) {
        sub_100090038();
      }
      id result = __error();
      *id result = v29;
    }

    if (byte_1000E7D31) {
      BOOL v31 = dword_1000E74E0 <= 0;
    }
    else {
      BOOL v31 = 0;
    }
    if (!v31) {
      return result;
    }
    int v32 = *__error();
    int v33 = sub_10002EF3C((*v3)[18]);
    uint64_t v34 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"%s [%d]: Already waiting for HID event",  v33,  (*v3)[18]);
    if (v34)
    {
      BOOL v35 = v34;
      __darwin_time_t v36 = CFStringGetCStringPtr(v34, 0x8000100u);
      if (v36)
      {
        int v37 = (char *)v36;
        BOOL v38 = 0LL;
      }

      else
      {
        int v37 = (char *)calloc(0x400uLL, 1uLL);
        CFStringGetCString(v35, v37, 1024LL, 0x8000100u);
        BOOL v38 = v37;
      }

      if (qword_1000E7D38) {
        id v105 = (FILE *)qword_1000E7D38;
      }
      else {
        id v105 = __stderrp;
      }
      fprintf(v105, "%s\n", v37);
      if (v38) {
        free(v38);
      }
      uint64_t v106 = v35;
LABEL_273:
      CFRelease(v106);
LABEL_274:
      id result = __error();
      *id result = v32;
      return result;
    }

    id v98 = (os_log_s *)sub_10002EFA0();
    if (os_log_type_enabled(v98, OS_LOG_TYPE_FAULT)) {
      sub_10008FFCC();
    }
    goto LABEL_233;
  }

  if (byte_1000E7D30)
  {
    int v74 = *__error();
    __int128 v75 = (os_log_s *)sub_10002EFA0();
    if (os_log_type_enabled(v75, OS_LOG_TYPE_DEBUG)) {
      sub_1000900D0();
    }
    id result = __error();
    *id result = v74;
  }

  if (byte_1000E7D31) {
    BOOL v76 = dword_1000E74E0 <= 0;
  }
  else {
    BOOL v76 = 0;
  }
  if (v76)
  {
    int v32 = *__error();
    int v77 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"Already waiting for HID event");
    if (v77)
    {
      int v78 = v77;
      int v79 = CFStringGetCStringPtr(v77, 0x8000100u);
      if (v79)
      {
        int v80 = (char *)v79;
        int v81 = 0LL;
      }

      else
      {
        int v80 = (char *)calloc(0x400uLL, 1uLL);
        CFStringGetCString(v78, v80, 1024LL, 0x8000100u);
        int v81 = v80;
      }

      if (qword_1000E7D38) {
        id v132 = (FILE *)qword_1000E7D38;
      }
      else {
        id v132 = __stderrp;
      }
      fprintf(v132, "%s\n", v80);
      if (v81) {
        free(v81);
      }
      uint64_t v106 = v78;
      goto LABEL_273;
    }

    id v120 = (os_log_s *)sub_10002EFA0();
    if (os_log_type_enabled(v120, OS_LOG_TYPE_FAULT)) {
      sub_1000900A4();
    }
LABEL_233:
    if (qword_1000E7D38) {
      id v121 = (FILE *)qword_1000E7D38;
    }
    else {
      id v121 = __stderrp;
    }
    fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v121);
    goto LABEL_274;
  }

  return result;
}

int *sub_100062F30(uint64_t a1, void *a2)
{
  uint64_t v4 = (unsigned int *)(a1 + 64);
  id result = (int *)objc_msgSend( a2,  "objectForKeyedSubscript:",  +[NSNumber numberWithInt:](NSNumber, "numberWithInt:", *(unsigned int *)(a1 + 64)));
  if (result)
  {
    uint64_t v6 = (uint64_t)result;
    int v7 = (id *)(a1 + 32);
    id result = (int *)[*((id *)result + 52) gt:*(void *)(a1 + 32)];
    if ((_DWORD)result)
    {
      if ((*v4 & 0x80000000) == 0)
      {
        if (byte_1000E7D30)
        {
          int v8 = *__error();
          int v9 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
          {
            id v90 = sub_10002EF3C(*v4);
            int v91 = *v4;
            [*(id *)(v6 + 416) machAbsTimeSeconds];
            double v93 = v92;
            [*v7 machAbsTimeSeconds];
            *(_DWORD *)buf = 136446722;
            id v101 = v90;
            __int16 v102 = 1024;
            int v103 = v91;
            __int16 v104 = 2048;
            double v105 = v93 - v94;
            _os_log_debug_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEBUG,  "%{public}s [%d]: Got hid event from %.1fs earlier than the spin we monitored, continuing to wait",  buf,  0x1Cu);
          }

          id result = __error();
          *id result = v8;
        }

        if (byte_1000E7D31) {
          BOOL v10 = dword_1000E74E0 <= 0;
        }
        else {
          BOOL v10 = 0;
        }
        if (v10)
        {
          int v11 = *__error();
          double v12 = sub_10002EF3C(*v4);
          uint64_t v13 = *v4;
          [*(id *)(v6 + 416) machAbsTimeSeconds];
          double v15 = v14;
          [*v7 machAbsTimeSeconds];
          BOOL v17 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"%s [%d]: Got hid event from %.1fs earlier than the spin we monitored, continuing to wait",  v12,  v13,  v15 - v16);
          if (v17)
          {
            int v18 = v17;
            CStringPtr = CFStringGetCStringPtr(v17, 0x8000100u);
            if (CStringPtr)
            {
              BOOL v20 = (char *)CStringPtr;
              int v21 = 0LL;
            }

            else
            {
              BOOL v20 = (char *)calloc(0x400uLL, 1uLL);
              CFStringGetCString(v18, v20, 1024LL, 0x8000100u);
              int v21 = v20;
            }

            if (qword_1000E7D38) {
              int v79 = (FILE *)qword_1000E7D38;
            }
            else {
              int v79 = __stderrp;
            }
            fprintf(v79, "%s\n", v20);
            if (v21) {
              free(v21);
            }
            CFRelease(v18);
          }

          else
          {
            int v74 = (os_log_s *)sub_10002EFA0();
            if (os_log_type_enabled(v74, OS_LOG_TYPE_FAULT))
            {
              id v95 = sub_10002EF3C(*v4);
              int v96 = *v4;
              [*(id *)(v6 + 416) machAbsTimeSeconds];
              double v98 = v97;
              [*v7 machAbsTimeSeconds];
              *(_DWORD *)buf = 136315650;
              id v101 = v95;
              __int16 v102 = 1024;
              int v103 = v96;
              __int16 v104 = 2048;
              double v105 = v98 - v99;
              _os_log_fault_impl( (void *)&_mh_execute_header,  v74,  OS_LOG_TYPE_FAULT,  "Unable to format: %s [%d]: Got hid event from %.1fs earlier than the spin we monitored, continuing to wait",  buf,  0x1Cu);
            }

            if (qword_1000E7D38) {
              __int128 v75 = (FILE *)qword_1000E7D38;
            }
            else {
              __int128 v75 = __stderrp;
            }
            fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v75);
          }

          id result = __error();
          *id result = v11;
        }

        return result;
      }

      if (byte_1000E7D30)
      {
        int v53 = *__error();
        int v54 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v54, OS_LOG_TYPE_DEBUG)) {
          sub_100090360(v6, (uint64_t)v7, v54);
        }
        id result = __error();
        *id result = v53;
      }

      if (byte_1000E7D31) {
        BOOL v55 = dword_1000E74E0 <= 0;
      }
      else {
        BOOL v55 = 0;
      }
      if (!v55) {
        return result;
      }
      int v47 = *__error();
      [*(id *)(v6 + 416) machAbsTimeSeconds];
      double v57 = v56;
      [*v7 machAbsTimeSeconds];
      int v59 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"Got hid event from %.1fs earlier than the spin we monitored, continuing to wait",  v57 - v58);
      if (v59)
      {
        int v60 = v59;
        int v61 = CFStringGetCStringPtr(v59, 0x8000100u);
        if (v61)
        {
          BOOL v62 = (char *)v61;
          int v63 = 0LL;
        }

        else
        {
          BOOL v62 = (char *)calloc(0x400uLL, 1uLL);
          CFStringGetCString(v60, v62, 1024LL, 0x8000100u);
          int v63 = v62;
        }

        if (qword_1000E7D38) {
          id v88 = (FILE *)qword_1000E7D38;
        }
        else {
          id v88 = __stderrp;
        }
        fprintf(v88, "%s\n", v62);
        if (v63) {
          free(v63);
        }
        int v87 = v60;
LABEL_143:
        CFRelease(v87);
LABEL_144:
        id result = __error();
        *id result = v47;
        return result;
      }

      int v82 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v82, OS_LOG_TYPE_FAULT)) {
        sub_1000902C4(v6);
      }
      goto LABEL_119;
    }

    *(_BYTE *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL) = 1;
    if ((*(_DWORD *)(a1 + 64) & 0x80000000) != 0)
    {
      if (byte_1000E7D30)
      {
        int v64 = *__error();
        int v65 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v65, OS_LOG_TYPE_INFO))
        {
          *(_WORD *)buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v65, OS_LOG_TYPE_INFO, "Got hid event", buf, 2u);
        }

        *__error() = v64;
      }

      if (byte_1000E7D31) {
        BOOL v66 = dword_1000E74E0 <= 1;
      }
      else {
        BOOL v66 = 0;
      }
      if (!v66) {
        goto LABEL_154;
      }
      int v37 = *__error();
      int v67 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"Got hid event");
      if (v67)
      {
        id v68 = v67;
        BOOL v69 = CFStringGetCStringPtr(v67, 0x8000100u);
        if (v69)
        {
          id v70 = (char *)v69;
          id v71 = 0LL;
        }

        else
        {
          id v70 = (char *)calloc(0x400uLL, 1uLL);
          CFStringGetCString(v68, v70, 1024LL, 0x8000100u);
          id v71 = v70;
        }

        if (qword_1000E7D38) {
          int v89 = (FILE *)qword_1000E7D38;
        }
        else {
          int v89 = __stderrp;
        }
        fprintf(v89, "%s\n", v70);
        if (v71) {
          free(v71);
        }
        int v81 = v68;
        goto LABEL_152;
      }

      BOOL v84 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v84, OS_LOG_TYPE_FAULT)) {
        sub_100090468();
      }
    }

    else
    {
      if (byte_1000E7D30)
      {
        int v32 = *__error();
        int v33 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v33, OS_LOG_TYPE_INFO))
        {
          uint64_t v34 = sub_10002EF3C(*v4);
          int v35 = *v4;
          *(_DWORD *)buf = 136446466;
          id v101 = v34;
          __int16 v102 = 1024;
          int v103 = v35;
          _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_INFO, "%{public}s [%d]: Got hid event", buf, 0x12u);
        }

        *__error() = v32;
      }

      if (byte_1000E7D31) {
        BOOL v36 = dword_1000E74E0 <= 1;
      }
      else {
        BOOL v36 = 0;
      }
      if (!v36) {
        goto LABEL_154;
      }
      int v37 = *__error();
      BOOL v38 = sub_10002EF3C(*v4);
      int v39 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"%s [%d]: Got hid event", v38, *v4);
      if (v39)
      {
        uintptr_t v40 = v39;
        BOOL v41 = CFStringGetCStringPtr(v39, 0x8000100u);
        if (v41)
        {
          int v42 = (char *)v41;
          int v43 = 0LL;
        }

        else
        {
          int v42 = (char *)calloc(0x400uLL, 1uLL);
          CFStringGetCString(v40, v42, 1024LL, 0x8000100u);
          int v43 = v42;
        }

        if (qword_1000E7D38) {
          int v80 = (FILE *)qword_1000E7D38;
        }
        else {
          int v80 = __stderrp;
        }
        fprintf(v80, "%s\n", v42);
        if (v43) {
          free(v43);
        }
        int v81 = v40;
LABEL_152:
        CFRelease(v81);
LABEL_153:
        *__error() = v37;
LABEL_154:
        objc_msgSend( (id)v6,  "setEventTimeRange:",  +[SATimeRange timeRangeStart:end:]( SATimeRange,  "timeRangeStart:end:",  *(void *)(a1 + 40),  *(void *)(a1 + 32)));
        [(id)v6 setReportTimeStart:*(void *)(a1 + 40)];
        [(id)v6 setReportTimeEnd:*(void *)(a1 + 32)];
        [(id)v6 setTargetHIDEventMachAbs:*(void *)(a1 + 56)];
        objc_msgSend((id)v6, "setTargetHIDEventEndMachAbs:", objc_msgSend(*(id *)(a1 + 32), "machAbsTime"));
        dispatch_semaphore_signal(*(dispatch_semaphore_t *)(v6 + 424));
        objc_msgSend( a2,  "setObject:forKeyedSubscript:",  0,  +[NSNumber numberWithInt:](NSNumber, "numberWithInt:", *(unsigned int *)(a1 + 64)));
        return (int *)[(id)v6 deleteHIDExitSource];
      }

      BOOL v76 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v76, OS_LOG_TYPE_FAULT)) {
        sub_1000903FC();
      }
    }

    if (qword_1000E7D38) {
      int v85 = (FILE *)qword_1000E7D38;
    }
    else {
      int v85 = __stderrp;
    }
    fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v85);
    goto LABEL_153;
  }

  if ((*v4 & 0x80000000) == 0)
  {
    if (byte_1000E7D30)
    {
      int v22 = *__error();
      uint64_t v23 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v23, OS_LOG_TYPE_DEBUG)) {
        sub_100090200();
      }
      id result = __error();
      *id result = v22;
    }

    if (byte_1000E7D31) {
      BOOL v24 = dword_1000E74E0 <= 0;
    }
    else {
      BOOL v24 = 0;
    }
    if (v24)
    {
      int v25 = *__error();
      int v26 = sub_10002EF3C(*v4);
      BOOL v27 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"%s [%d]: No sampled process for hid event",  v26,  *v4);
      if (v27)
      {
        unsigned int v28 = v27;
        int v29 = CFStringGetCStringPtr(v27, 0x8000100u);
        if (v29)
        {
          uint64_t v30 = (char *)v29;
          BOOL v31 = 0LL;
        }

        else
        {
          uint64_t v30 = (char *)calloc(0x400uLL, 1uLL);
          CFStringGetCString(v28, v30, 1024LL, 0x8000100u);
          BOOL v31 = v30;
        }

        if (qword_1000E7D38) {
          int v77 = (FILE *)qword_1000E7D38;
        }
        else {
          int v77 = __stderrp;
        }
        fprintf(v77, "%s\n", v30);
        if (v31) {
          free(v31);
        }
        CFRelease(v28);
      }

      else
      {
        id v72 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v72, OS_LOG_TYPE_FAULT)) {
          sub_100090194();
        }
        if (qword_1000E7D38) {
          id v73 = (FILE *)qword_1000E7D38;
        }
        else {
          id v73 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v73);
      }

      id result = __error();
      *id result = v25;
    }

    return result;
  }

  if (byte_1000E7D30)
  {
    int v44 = *__error();
    int v45 = (os_log_s *)sub_10002EFA0();
    if (os_log_type_enabled(v45, OS_LOG_TYPE_DEBUG)) {
      sub_100090298();
    }
    id result = __error();
    *id result = v44;
  }

  if (byte_1000E7D31) {
    BOOL v46 = dword_1000E74E0 <= 0;
  }
  else {
    BOOL v46 = 0;
  }
  if (v46)
  {
    int v47 = *__error();
    BOOL v48 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"No sampled process for hid event");
    if (v48)
    {
      id v49 = v48;
      uint64_t v50 = CFStringGetCStringPtr(v48, 0x8000100u);
      if (v50)
      {
        uint64_t v51 = (char *)v50;
        uint64_t v52 = 0LL;
      }

      else
      {
        uint64_t v51 = (char *)calloc(0x400uLL, 1uLL);
        CFStringGetCString(v49, v51, 1024LL, 0x8000100u);
        uint64_t v52 = v51;
      }

      if (qword_1000E7D38) {
        int v86 = (FILE *)qword_1000E7D38;
      }
      else {
        int v86 = __stderrp;
      }
      fprintf(v86, "%s\n", v51);
      if (v52) {
        free(v52);
      }
      int v87 = v49;
      goto LABEL_143;
    }

    int v78 = (os_log_s *)sub_10002EFA0();
    if (os_log_type_enabled(v78, OS_LOG_TYPE_FAULT)) {
      sub_10009026C();
    }
LABEL_119:
    if (qword_1000E7D38) {
      uintptr_t v83 = (FILE *)qword_1000E7D38;
    }
    else {
      uintptr_t v83 = __stderrp;
    }
    fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v83);
    goto LABEL_144;
  }

  return result;
}

void sub_100065110(uint64_t a1)
{
  id v3 = (uint64_t *)(a1 + 32);
  uint64_t v2 = *(void *)(a1 + 32);
  if (!*(_BYTE *)(v2 + 298) || *(_BYTE *)(v2 + 297))
  {
    uint64_t v4 = *(dispatch_source_s **)(v2 + 32);
    if (!v4)
    {
      dispatch_queue_global_t global_queue = dispatch_get_global_queue(25LL, 2uLL);
      *(void *)(*v3 + 32) = dispatch_source_create( (dispatch_source_type_t)&_dispatch_source_type_timer,  0LL,  0LL,  global_queue);
      uint64_t v6 = *v3;
      int v7 = *(dispatch_source_s **)(*v3 + 32);
      handler[0] = _NSConcreteStackBlock;
      handler[1] = 3221225472LL;
      handler[2] = sub_100065510;
      handler[3] = &unk_1000D95B0;
      void handler[4] = v6;
      dispatch_source_set_event_handler(v7, handler);
      dispatch_resume(*(dispatch_object_t *)(*v3 + 32));
      uint64_t v2 = *v3;
      uint64_t v4 = *(dispatch_source_s **)(*v3 + 32);
    }

    unsigned int v8 = *(_DWORD *)(v2 + 400);
    if (v8 >= 0x3E8) {
      uint64_t v9 = 1000000LL;
    }
    else {
      uint64_t v9 = 1000LL * v8;
    }
    dispatch_time_t v10 = dispatch_time(0LL, (unint64_t)((*(double *)(a1 + 40) - *(double *)(a1 + 48)) * 1000000000.0));
    dispatch_source_set_timer(v4, v10, 0xFFFFFFFFFFFFFFFFLL, v9);
    return;
  }

  if ((*(_DWORD *)(v2 + 72) & 0x80000000) == 0)
  {
    if (byte_1000E7D30)
    {
      int v11 = *__error();
      double v12 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG)) {
        sub_100090B2C();
      }
      *__error() = v11;
    }

    if (byte_1000E7D31) {
      BOOL v13 = dword_1000E74E0 <= 0;
    }
    else {
      BOOL v13 = 0;
    }
    if (!v13) {
      return;
    }
    int v14 = *__error();
    double v15 = sub_10002EF3C(*(_DWORD *)(*v3 + 72));
    double v16 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"%s [%d]: Lost race: already done sampling",  v15,  *(unsigned int *)(*v3 + 72));
    if (v16)
    {
      BOOL v17 = v16;
      CStringPtr = CFStringGetCStringPtr(v16, 0x8000100u);
      if (CStringPtr)
      {
        BOOL v19 = (char *)CStringPtr;
        BOOL v20 = 0LL;
      }

      else
      {
        BOOL v19 = (char *)calloc(0x400uLL, 1uLL);
        CFStringGetCString(v17, v19, 1024LL, 0x8000100u);
        BOOL v20 = v19;
      }

      if (qword_1000E7D38) {
        uint64_t v30 = (FILE *)qword_1000E7D38;
      }
      else {
        uint64_t v30 = __stderrp;
      }
      fprintf(v30, "%s\n", v19);
      if (v20) {
        free(v20);
      }
      BOOL v31 = v17;
LABEL_56:
      CFRelease(v31);
LABEL_57:
      *__error() = v14;
      return;
    }

    int v29 = (os_log_s *)sub_10002EFA0();
    if (os_log_type_enabled(v29, OS_LOG_TYPE_FAULT)) {
      sub_100090AC0();
    }
    goto LABEL_45;
  }

  if (byte_1000E7D30)
  {
    int v21 = *__error();
    int v22 = (os_log_s *)sub_10002EFA0();
    if (os_log_type_enabled(v22, OS_LOG_TYPE_DEBUG)) {
      sub_100090BC4();
    }
    *__error() = v21;
  }

  if (byte_1000E7D31) {
    BOOL v23 = dword_1000E74E0 <= 0;
  }
  else {
    BOOL v23 = 0;
  }
  if (v23)
  {
    int v14 = *__error();
    BOOL v24 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"Lost race: already done sampling");
    if (v24)
    {
      int v25 = v24;
      int v26 = CFStringGetCStringPtr(v24, 0x8000100u);
      if (v26)
      {
        BOOL v27 = (char *)v26;
        unsigned int v28 = 0LL;
      }

      else
      {
        BOOL v27 = (char *)calloc(0x400uLL, 1uLL);
        CFStringGetCString(v25, v27, 1024LL, 0x8000100u);
        unsigned int v28 = v27;
      }

      if (qword_1000E7D38) {
        uint64_t v34 = (FILE *)qword_1000E7D38;
      }
      else {
        uint64_t v34 = __stderrp;
      }
      fprintf(v34, "%s\n", v27);
      if (v28) {
        free(v28);
      }
      BOOL v31 = v25;
      goto LABEL_56;
    }

    int v32 = (os_log_s *)sub_10002EFA0();
    if (os_log_type_enabled(v32, OS_LOG_TYPE_FAULT)) {
      sub_100090B98();
    }
LABEL_45:
    if (qword_1000E7D38) {
      int v33 = (FILE *)qword_1000E7D38;
    }
    else {
      int v33 = __stderrp;
    }
    fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v33);
    goto LABEL_57;
  }

void sub_100065510(uint64_t a1)
{
  uint64_t v1 = (id *)(a1 + 32);
  double v2 = *(double *)(*(void *)(a1 + 32) + 48LL);
  double Current = SAMachAbsTimeSecondsGetCurrent(a1);
  int v4 = *((_DWORD *)*v1 + 18);
  if (v2 <= Current)
  {
    if (v4 < 0)
    {
      if (byte_1000E7D30)
      {
        int v30 = *__error();
        BOOL v31 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v31, OS_LOG_TYPE_DEBUG)) {
          sub_100090E24();
        }
        *__error() = v30;
      }

      if (byte_1000E7D31) {
        BOOL v32 = dword_1000E74E0 <= 0;
      }
      else {
        BOOL v32 = 0;
      }
      if (!v32) {
        goto LABEL_81;
      }
      int v18 = *__error();
      BOOL v20 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"Monitoring timed out");
      if (!v20)
      {
        int v43 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v43, OS_LOG_TYPE_FAULT)) {
          sub_100090DF8();
        }
        goto LABEL_76;
      }
    }

    else
    {
      if (byte_1000E7D30)
      {
        int v15 = *__error();
        double v16 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG)) {
          sub_100090D8C();
        }
        *__error() = v15;
      }

      if (byte_1000E7D31) {
        BOOL v17 = dword_1000E74E0 <= 0;
      }
      else {
        BOOL v17 = 0;
      }
      if (!v17) {
        goto LABEL_81;
      }
      int v18 = *__error();
      BOOL v19 = sub_10002EF3C(*((_DWORD *)*v1 + 18));
      BOOL v20 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"%s [%d]: Monitoring timed out",  v19,  *((unsigned int *)*v1 + 18));
      if (!v20)
      {
        int v21 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v21, OS_LOG_TYPE_FAULT)) {
          sub_100090D20();
        }
LABEL_76:
        if (qword_1000E7D38) {
          int v44 = (FILE *)qword_1000E7D38;
        }
        else {
          int v44 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v44);
LABEL_80:
        *__error() = v18;
LABEL_81:
        [*v1 stopSamplingWithReason:3];
        return;
      }
    }

    int v33 = v20;
    CStringPtr = CFStringGetCStringPtr(v20, 0x8000100u);
    if (CStringPtr)
    {
      int v35 = (char *)CStringPtr;
      BOOL v36 = 0LL;
    }

    else
    {
      int v35 = (char *)calloc(0x400uLL, 1uLL);
      CFStringGetCString(v33, v35, 1024LL, 0x8000100u);
      BOOL v36 = v35;
    }

    if (qword_1000E7D38) {
      BOOL v38 = (FILE *)qword_1000E7D38;
    }
    else {
      BOOL v38 = __stderrp;
    }
    fprintf(v38, "%s\n", v35);
    if (v36) {
      free(v36);
    }
    CFRelease(v33);
    goto LABEL_80;
  }

  if ((v4 & 0x80000000) == 0)
  {
    if (byte_1000E7D30)
    {
      int v5 = *__error();
      uint64_t v6 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG)) {
        sub_100090C5C();
      }
      *__error() = v5;
    }

    if (byte_1000E7D31) {
      BOOL v7 = dword_1000E74E0 <= 0;
    }
    else {
      BOOL v7 = 0;
    }
    if (!v7) {
      return;
    }
    int v8 = *__error();
    uint64_t v9 = sub_10002EF3C(*((_DWORD *)*v1 + 18));
    dispatch_time_t v10 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"%s [%d]: Monitoring timeout was extended, doing nothing",  v9,  *((unsigned int *)*v1 + 18));
    if (v10)
    {
      int v11 = v10;
      double v12 = CFStringGetCStringPtr(v10, 0x8000100u);
      if (v12)
      {
        BOOL v13 = (char *)v12;
        int v14 = 0LL;
      }

      else
      {
        BOOL v13 = (char *)calloc(0x400uLL, 1uLL);
        CFStringGetCString(v11, v13, 1024LL, 0x8000100u);
        int v14 = v13;
      }

      if (qword_1000E7D38) {
        int v39 = (FILE *)qword_1000E7D38;
      }
      else {
        int v39 = __stderrp;
      }
      fprintf(v39, "%s\n", v13);
      if (v14) {
        free(v14);
      }
      uintptr_t v40 = v11;
LABEL_89:
      CFRelease(v40);
LABEL_90:
      *__error() = v8;
      return;
    }

    int v37 = (os_log_s *)sub_10002EFA0();
    if (os_log_type_enabled(v37, OS_LOG_TYPE_FAULT)) {
      sub_100090BF0();
    }
    goto LABEL_70;
  }

  if (byte_1000E7D30)
  {
    int v22 = *__error();
    BOOL v23 = (os_log_s *)sub_10002EFA0();
    if (os_log_type_enabled(v23, OS_LOG_TYPE_DEBUG)) {
      sub_100090CF4();
    }
    *__error() = v22;
  }

  if (byte_1000E7D31) {
    BOOL v24 = dword_1000E74E0 <= 0;
  }
  else {
    BOOL v24 = 0;
  }
  if (v24)
  {
    int v8 = *__error();
    int v25 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"Monitoring timeout was extended, doing nothing");
    if (v25)
    {
      int v26 = v25;
      BOOL v27 = CFStringGetCStringPtr(v25, 0x8000100u);
      if (v27)
      {
        unsigned int v28 = (char *)v27;
        int v29 = 0LL;
      }

      else
      {
        unsigned int v28 = (char *)calloc(0x400uLL, 1uLL);
        CFStringGetCString(v26, v28, 1024LL, 0x8000100u);
        int v29 = v28;
      }

      if (qword_1000E7D38) {
        int v45 = (FILE *)qword_1000E7D38;
      }
      else {
        int v45 = __stderrp;
      }
      fprintf(v45, "%s\n", v28);
      if (v29) {
        free(v29);
      }
      uintptr_t v40 = v26;
      goto LABEL_89;
    }

    BOOL v41 = (os_log_s *)sub_10002EFA0();
    if (os_log_type_enabled(v41, OS_LOG_TYPE_FAULT)) {
      sub_100090CC8();
    }
LABEL_70:
    if (qword_1000E7D38) {
      int v42 = (FILE *)qword_1000E7D38;
    }
    else {
      int v42 = __stderrp;
    }
    fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v42);
    goto LABEL_90;
  }

void sub_100065E94(void *a1)
{
  uint64_t v2 = a1[4];
  id v3 = *(dispatch_object_s **)(v2 + 56);
  if (v3)
  {
    dispatch_release(v3);
    uint64_t v2 = a1[4];
  }

  int v4 = *(const void **)(v2 + 64);
  if (v4)
  {
    _Block_release(v4);
    uint64_t v2 = a1[4];
  }

  *(void *)(v2 + 56) = a1[5];
  *(void *)(a1[4] + 64LL) = a1[6];
}

void sub_100065F44(uint64_t a1)
{
  uint64_t v2 = (uint64_t *)(a1 + 32);
  uint64_t v1 = *(void *)(a1 + 32);
  int v3 = *(unsigned __int8 *)(a1 + 40);
  int v4 = *(dispatch_object_s **)(v1 + 40);
  if (!v3)
  {
    if (v4)
    {
      dispatch_release(v4);
      *(void *)(*v2 + 40) = 0LL;
    }

    return;
  }

  if (v4) {
    return;
  }
  if (!*(_BYTE *)(v1 + 298) || *(_BYTE *)(v1 + 297))
  {
    uintptr_t v5 = *(unsigned int *)(v1 + 72);
    if ((int)v5 < 1)
    {
      if ((_DWORD)v5)
      {
        if (byte_1000E7D30)
        {
          int v9 = *__error();
          dispatch_time_t v10 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
          {
            *(_WORD *)buf = 0;
            _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_INFO,  "No target process to monitor for exiting",  buf,  2u);
          }

          *__error() = v9;
        }

        if (byte_1000E7D31) {
          BOOL v11 = dword_1000E74E0 <= 1;
        }
        else {
          BOOL v11 = 0;
        }
        if (!v11) {
          return;
        }
        int v12 = *__error();
        BOOL v13 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"No target process to monitor for exiting");
        if (!v13)
        {
          int v14 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v14, OS_LOG_TYPE_FAULT)) {
            sub_100091184();
          }
          goto LABEL_98;
        }
      }

      else
      {
        if (byte_1000E7D30)
        {
          int v28 = *__error();
          int v29 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v29, OS_LOG_TYPE_INFO))
          {
            *(_WORD *)buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_INFO, "Can't stop when kernel exits", buf, 2u);
          }

          *__error() = v28;
        }

        if (byte_1000E7D31) {
          BOOL v30 = dword_1000E74E0 <= 1;
        }
        else {
          BOOL v30 = 0;
        }
        if (!v30) {
          return;
        }
        int v12 = *__error();
        BOOL v13 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"Can't stop when kernel exits");
        if (!v13)
        {
          BOOL v31 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v31, OS_LOG_TYPE_FAULT)) {
            sub_100091158();
          }
          goto LABEL_98;
        }
      }
    }

    else
    {
      dispatch_queue_global_t global_queue = dispatch_get_global_queue(25LL, 2uLL);
      *(void *)(*v2 + 40) = dispatch_source_create( (dispatch_source_type_t)&_dispatch_source_type_proc,  v5,  0xA0000000uLL,  global_queue);
      uint64_t v7 = *v2;
      int v8 = *(dispatch_source_s **)(*v2 + 40);
      if (v8)
      {
        handler[0] = _NSConcreteStackBlock;
        handler[1] = 3221225472LL;
        handler[2] = sub_10006660C;
        handler[3] = &unk_1000D95B0;
        void handler[4] = v7;
        dispatch_source_set_event_handler(v8, handler);
        dispatch_resume(*(dispatch_object_t *)(*v2 + 40));
        return;
      }

      if ((*(_DWORD *)(v7 + 72) & 0x80000000) == 0)
      {
        if (byte_1000E7D30)
        {
          int v21 = *__error();
          int v22 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR)) {
            sub_100091094();
          }
          *__error() = v21;
        }

        if (byte_1000E7D31 && dword_1000E74E0 <= 3)
        {
          int v12 = *__error();
          BOOL v23 = sub_10002EF3C(*(_DWORD *)(*v2 + 72));
          BOOL v19 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"%s [%d]: Unable to allocate proc exit dispatch source",  v23,  *(unsigned int *)(*v2 + 72));
          if (v19) {
            goto LABEL_44;
          }
          int v45 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v45, OS_LOG_TYPE_FAULT)) {
            sub_100091028();
          }
          goto LABEL_98;
        }

        return;
      }

      if (byte_1000E7D30)
      {
        int v36 = *__error();
        int v37 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v37, OS_LOG_TYPE_ERROR)) {
          sub_10009112C();
        }
        *__error() = v36;
      }

      if (!byte_1000E7D31 || dword_1000E74E0 > 3) {
        return;
      }
      int v12 = *__error();
      BOOL v13 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"Unable to allocate proc exit dispatch source");
      if (!v13)
      {
        BOOL v46 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v46, OS_LOG_TYPE_FAULT)) {
          sub_100091100();
        }
        goto LABEL_98;
      }
    }

id sub_10006660C(uint64_t a1)
{
  uint64_t v1 = (id *)(a1 + 32);
  if ((*(_DWORD *)(*(void *)(a1 + 32) + 72LL) & 0x80000000) == 0)
  {
    if (byte_1000E7D30)
    {
      int v2 = *__error();
      int v3 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG)) {
        sub_10009121C();
      }
      *__error() = v2;
    }

    if (byte_1000E7D31) {
      BOOL v4 = dword_1000E74E0 <= 0;
    }
    else {
      BOOL v4 = 0;
    }
    if (!v4) {
      return [*v1 stopSamplingWithReason:2];
    }
    int v5 = *__error();
    uint64_t v6 = sub_10002EF3C(*((_DWORD *)*v1 + 18));
    uint64_t v7 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"%s [%d]: exited", v6, *((unsigned int *)*v1 + 18));
    if (!v7)
    {
      int v8 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_FAULT)) {
        sub_1000911B0();
      }
LABEL_35:
      if (qword_1000E7D38) {
        int v18 = (FILE *)qword_1000E7D38;
      }
      else {
        int v18 = __stderrp;
      }
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v18);
LABEL_39:
      *__error() = v5;
      return [*v1 stopSamplingWithReason:2];
    }

    goto LABEL_24;
  }

  if (byte_1000E7D30)
  {
    int v9 = *__error();
    dispatch_time_t v10 = (os_log_s *)sub_10002EFA0();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG)) {
      sub_1000912B4();
    }
    *__error() = v9;
  }

  if (byte_1000E7D31) {
    BOOL v11 = dword_1000E74E0 <= 0;
  }
  else {
    BOOL v11 = 0;
  }
  if (v11)
  {
    int v5 = *__error();
    uint64_t v7 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"exited");
    if (!v7)
    {
      BOOL v17 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v17, OS_LOG_TYPE_FAULT)) {
        sub_100091288();
      }
      goto LABEL_35;
    }

id sub_100066CE8(id result)
{
  uint64_t v1 = *((void *)result + 4);
  if (*(_BYTE *)(v1 + 297))
  {
    int v2 = result;
    *(_BYTE *)(v1 + 297) = 0;
    [*((id *)result + 4) removeSelfFromPidCache];
    uint64_t v3 = v2[4];
    BOOL v4 = *(dispatch_object_s **)(v3 + 32);
    if (v4)
    {
      dispatch_release(v4);
      *(void *)(v2[4] + 32LL) = 0LL;
      uint64_t v3 = v2[4];
    }

    int v5 = *(dispatch_object_s **)(v3 + 40);
    if (v5)
    {
      dispatch_release(v5);
      *(void *)(v2[4] + 40LL) = 0LL;
      uint64_t v3 = v2[4];
    }

    BOOL v6 = *(_BYTE *)(v3 + 301) == 0;
    uint64_t v8 = *(void *)(v3 + 16);
    uint64_t v7 = *(void **)(v3 + 24);
    v9[0] = _NSConcreteStackBlock;
    v9[1] = 3221225472LL;
    v9[2] = sub_100066DA8;
    v9[3] = &unk_1000D99A8;
    v9[4] = v3;
    char v10 = *((_BYTE *)v2 + 40);
    return [v7 stopAndWaitForAllSamplingToComplete:v6 withCompletionCallbackOnQueue:v8 withBlock:v9];
  }

  return result;
}

id sub_100066DA8(uint64_t a1, uint64_t a2)
{
  return [*(id *)(a1 + 32) _samplingHasCompletedWithEndSnapshot:a2 withReason:*(unsigned __int8 *)(a1 + 40)];
}

LABEL_54:
    uintptr_t v40 = v16;
    BOOL v41 = CFStringGetCStringPtr(v16, 0x8000100u);
    if (v41)
    {
      int v42 = (char *)v41;
      int v43 = 0LL;
    }

    else
    {
      int v42 = (char *)calloc(0x400uLL, 1uLL);
      CFStringGetCString(v40, v42, 1024LL, 0x8000100u);
      int v43 = v42;
    }

    if (qword_1000E7D38) {
      id v49 = (FILE *)qword_1000E7D38;
    }
    else {
      id v49 = __stderrp;
    }
    fprintf(v49, "%s\n", v42);
    if (v43) {
      free(v43);
    }
    CFRelease(v40);
    goto LABEL_95;
  }

LABEL_127:
    __int128 v75 = v62;
    BOOL v76 = CFStringGetCStringPtr(v62, 0x8000100u);
    if (v76)
    {
      int v77 = (char *)v76;
      int v78 = 0LL;
    }

    else
    {
      int v77 = (char *)calloc(0x400uLL, 1uLL);
      CFStringGetCString(v75, v77, 1024LL, 0x8000100u);
      int v78 = v77;
    }

    if (qword_1000E7D38) {
      double v93 = (FILE *)qword_1000E7D38;
    }
    else {
      double v93 = __stderrp;
    }
    fprintf(v93, "%s\n", v77);
    if (v78) {
      free(v78);
    }
    CFRelease(v75);
    goto LABEL_180;
  }

  if (byte_1000E7D30)
  {
    double v56 = *__error();
    double v57 = (os_log_s *)sub_10002EFA0();
    if (os_log_type_enabled(v57, OS_LOG_TYPE_DEFAULT))
    {
      double v58 = sub_10002EF3C(*v8);
      int v59 = *v8;
      *(_DWORD *)buf = 136446466;
      id v128 = v58;
      id v129 = 1024;
      unsigned int v130 = v59;
      _os_log_impl( (void *)&_mh_execute_header,  v57,  OS_LOG_TYPE_DEFAULT,  "%{public}s [%d]: Timed out waiting for HID event, canceling spin",  buf,  0x12u);
    }

    *__error() = v56;
  }

  if (!byte_1000E7D31 || dword_1000E74E0 > 2) {
    goto LABEL_181;
  }
  int v60 = *__error();
  int v61 = sub_10002EF3C(*v8);
  BOOL v62 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"%s [%d]: Timed out waiting for HID event, canceling spin",  v61,  *v8);
  if (v62) {
    goto LABEL_127;
  }
  int v63 = (os_log_s *)sub_10002EFA0();
  if (os_log_type_enabled(v63, OS_LOG_TYPE_FAULT)) {
    sub_100091890();
  }
LABEL_176:
  if (qword_1000E7D38) {
    __int16 v104 = (FILE *)qword_1000E7D38;
  }
  else {
    __int16 v104 = __stderrp;
  }
  fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v104);
LABEL_180:
  *__error() = v60;
LABEL_181:
  v126[0] = _NSConcreteStackBlock;
  v126[1] = 3221225472LL;
  v126[2] = sub_100067F1C;
  v126[3] = &unk_1000D98E0;
  v126[4] = self;
  sub_10006103C((uint64_t)v126);
LABEL_205:
  LOBYTE(v4) = 8;
LABEL_206:
  completionCallbackQueue = self->super.super._completionCallbackQueue;
  if (completionCallbackQueue)
  {
    if (self->super.super._completionCallbackBlock)
    {
      block[0] = _NSConcreteStackBlock;
      block[1] = 3221225472LL;
      block[2] = sub_1000681FC;
      block[3] = &unk_1000D9930;
      void block[4] = self;
      int v125 = v4;
      dispatch_async((dispatch_queue_t)completionCallbackQueue, block);
      dispatch_release((dispatch_object_t)self->super.super._completionCallbackQueue);
      self->super.super._completionCallbackQueue = 0LL;
    }
  }

BOOL sub_100067F0C(int a1)
{
  return (a1 - 6) < 0xFFFFFFFC;
}

_DWORD *sub_100067F1C(uint64_t a1, void *a2)
{
  uint64_t v3 = (id *)(a1 + 32);
  id result = objc_msgSend( a2,  "objectForKeyedSubscript:",  +[NSNumber numberWithInt:]( NSNumber,  "numberWithInt:",  *(unsigned int *)(*(void *)(a1 + 32) + 72)));
  if (result && result == *v3)
  {
    if ((result[18] & 0x80000000) != 0)
    {
      if (byte_1000E7D30)
      {
        int v12 = *__error();
        BOOL v13 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG)) {
          sub_100091AC4();
        }
        *__error() = v12;
      }

      if (byte_1000E7D31) {
        BOOL v14 = dword_1000E74E0 <= 0;
      }
      else {
        BOOL v14 = 0;
      }
      if (!v14) {
        goto LABEL_42;
      }
      int v8 = *__error();
      char v10 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"Removing self from processes waiting on HID event list");
      if (!v10)
      {
        BOOL v20 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v20, OS_LOG_TYPE_FAULT)) {
          sub_100091A98();
        }
        goto LABEL_37;
      }
    }

    else
    {
      if (byte_1000E7D30)
      {
        int v5 = *__error();
        BOOL v6 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG)) {
          sub_100091A2C();
        }
        *__error() = v5;
      }

      if (byte_1000E7D31) {
        BOOL v7 = dword_1000E74E0 <= 0;
      }
      else {
        BOOL v7 = 0;
      }
      if (!v7) {
        goto LABEL_42;
      }
      int v8 = *__error();
      int v9 = sub_10002EF3C(*((_DWORD *)*v3 + 18));
      char v10 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"%s [%d]: Removing self from processes waiting on HID event list",  v9,  *((unsigned int *)*v3 + 18));
      if (!v10)
      {
        BOOL v11 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v11, OS_LOG_TYPE_FAULT)) {
          sub_1000919C0();
        }
LABEL_37:
        if (qword_1000E7D38) {
          int v21 = (FILE *)qword_1000E7D38;
        }
        else {
          int v21 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v21);
LABEL_41:
        *__error() = v8;
LABEL_42:
        objc_msgSend( a2,  "setObject:forKeyedSubscript:",  0,  +[NSNumber numberWithInt:](NSNumber, "numberWithInt:", *((unsigned int *)*v3 + 18)));
        return [*v3 deleteHIDExitSource];
      }
    }

    int v15 = v10;
    CStringPtr = CFStringGetCStringPtr(v10, 0x8000100u);
    if (CStringPtr)
    {
      BOOL v17 = (char *)CStringPtr;
      int v18 = 0LL;
    }

    else
    {
      BOOL v17 = (char *)calloc(0x400uLL, 1uLL);
      CFStringGetCString(v15, v17, 1024LL, 0x8000100u);
      int v18 = v17;
    }

    if (qword_1000E7D38) {
      BOOL v19 = (FILE *)qword_1000E7D38;
    }
    else {
      BOOL v19 = __stderrp;
    }
    fprintf(v19, "%s\n", v17);
    if (v18) {
      free(v18);
    }
    CFRelease(v15);
    goto LABEL_41;
  }

  return result;
}

void sub_1000681FC(uint64_t a1)
{
  *(void *)(*(void *)(a1 + 32) + 64LL) = 0LL;
}

void sub_100068240(uint64_t a1, void *a2)
{
  int v5 = (id *)(a1 + 32);
  BOOL v4 = *(_DWORD **)(a1 + 32);
  if ((v4[18] & 0x80000000) == 0)
  {
    objc_msgSend(a2, "setTargetProcessId:");
    BOOL v4 = *v5;
  }

  if (*((void *)v4 + 19))
  {
    objc_msgSend(a2, "setTargetThreadId:");
    BOOL v4 = *v5;
  }

  if (*((void *)v4 + 15))
  {
    if ((objc_msgSend( objc_msgSend(objc_msgSend(a2, "targetProcess"), "mainBinaryPath"),  "isAbsolutePath") & 1) == 0)
    {
      id v6 = [a2 targetProcess];
      if (v6) {
        [v6 setMainBinaryPath:*((void *)*v5 + 15)];
      }
    }
  }

  [a2 setTargetHIDEventMachAbs:*((void *)*v5 + 20)];
  [a2 setTargetHIDEventEndMachAbs:*((void *)*v5 + 21)];

  *((void *)*v5 + 10) = objc_msgSend(objc_msgSend(a2, "targetProcess"), "name");
  else {
    id v7 = 0LL;
  }
  *((void *)*v5 + 15) = v7;
  unsigned int v8 = objc_msgSend(objc_msgSend(a2, "targetProcess"), "isUnresponsive");
  uint64_t v9 = 0LL;
  if (v8) {
    objc_msgSend(objc_msgSend(a2, "targetProcess", 0.0), "timeOfLastResponse");
  }
  *(void *)(*(void *)(a1 + 32) + 144LL) = v9;
  char v10 = *(void **)(a1 + 40);
  if (!v10)
  {
    char v11 = 1;
    goto LABEL_40;
  }

  char v11 = *(_BYTE *)(a1 + 48);
  if ([v10 stackshotProvider] != *((id *)*v5 + 3))
  {
    if ((*((_DWORD *)*v5 + 18) & 0x80000000) != 0)
    {
      if (byte_1000E7D30)
      {
        int v37 = *__error();
        BOOL v38 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR)) {
          sub_100091C6C(v38, v39, v40, v41, v42, v43, v44, v45);
        }
        *__error() = v37;
      }

      if (byte_1000E7D31 && dword_1000E74E0 <= 3)
      {
        int v46 = *__error();
        int v47 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"%s: Mismatched sample providers",  "endSnapshot.stackshotProvider == _sampleProvider");
        if (v47)
        {
          int v61 = v47;
          CStringPtr = CFStringGetCStringPtr(v47, 0x8000100u);
          if (CStringPtr)
          {
            int v63 = (char *)CStringPtr;
            int v64 = 0LL;
          }

          else
          {
            int v63 = (char *)calloc(0x400uLL, 1uLL);
            CFStringGetCString(v61, v63, 1024LL, 0x8000100u);
            int v64 = v63;
          }

          if (qword_1000E7D38) {
            id v71 = (FILE *)qword_1000E7D38;
          }
          else {
            id v71 = __stderrp;
          }
          fprintf(v71, "%s\n", v63);
          if (v64) {
            free(v64);
          }
          CFRelease(v61);
        }

        else
        {
          BOOL v48 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v48, OS_LOG_TYPE_FAULT)) {
            sub_100091BFC(v48, v49, v50, v51, v52, v53, v54, v55);
          }
          if (qword_1000E7D38) {
            double v56 = (FILE *)qword_1000E7D38;
          }
          else {
            double v56 = __stderrp;
          }
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v56);
        }

        *__error() = v46;
      }

      sub_10002EE78( "-[SPSampledProcess _samplingHasCompletedWithEndSnapshot:withReason:]_block_invoke",  "SPProcessEvent.m",  1346,  "%s: Mismatched sample providers",  v12,  v13,  v14,  v15,  (char)"endSnapshot.stackshotProvider == _sampleProvider");
    }

    else
    {
      if (byte_1000E7D30)
      {
        int v30 = *__error();
        BOOL v31 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR)) {
          sub_100091B78();
        }
        *__error() = v30;
      }

      if (byte_1000E7D31 && dword_1000E74E0 <= 3)
      {
        int v32 = *__error();
        int v33 = sub_10002EF3C(*((_DWORD *)*v5 + 18));
        BOOL v34 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"%s [%d]: %s: Mismatched sample providers",  v33,  *((unsigned int *)*v5 + 18),  "endSnapshot.stackshotProvider == _sampleProvider");
        if (v34)
        {
          double v57 = v34;
          double v58 = CFStringGetCStringPtr(v34, 0x8000100u);
          if (v58)
          {
            int v59 = (char *)v58;
            int v60 = 0LL;
          }

          else
          {
            int v59 = (char *)calloc(0x400uLL, 1uLL);
            CFStringGetCString(v57, v59, 1024LL, 0x8000100u);
            int v60 = v59;
          }

          if (qword_1000E7D38) {
            int v65 = (FILE *)qword_1000E7D38;
          }
          else {
            int v65 = __stderrp;
          }
          fprintf(v65, "%s\n", v59);
          if (v60) {
            free(v60);
          }
          CFRelease(v57);
        }

        else
        {
          int v35 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v35, OS_LOG_TYPE_FAULT)) {
            sub_100091AF0();
          }
          if (qword_1000E7D38) {
            int v36 = (FILE *)qword_1000E7D38;
          }
          else {
            int v36 = __stderrp;
          }
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v36);
        }

        *__error() = v32;
      }

      char v66 = sub_10002EF3C(*((_DWORD *)*v5 + 18));
      sub_10002EE78( "-[SPSampledProcess _samplingHasCompletedWithEndSnapshot:withReason:]_block_invoke",  "SPProcessEvent.m",  1346,  "%s [%d]: %s: Mismatched sample providers",  v67,  v68,  v69,  v70,  v66);
    }

    abort();
  }

  *(_DWORD *)(*(void *)(a1 + 32) + 284) = [*(id *)(a1 + 40) numSamplesAvoidedDueToAudio];
  *(_DWORD *)(*(void *)(a1 + 32) + 276) = [*(id *)(a1 + 40) numSamples];
  if (![*(id *)(a1 + 32) eventTimeRange])
  {
    id v16 = *v5;
    double v17 = *((double *)*v5 + 18);
    if (v17 > 0.0)
    {
      int v18 = (void *)*((void *)v16 + 52);
      if (!v18) {
        goto LABEL_21;
      }
      [v18 wallTime];
      if (v17 < v19) {
        goto LABEL_22;
      }
      id v16 = *v5;
      if (!*((void *)*v5 + 52))
      {
LABEL_21:
        double v20 = *((double *)v16 + 18);
        objc_msgSend(objc_msgSend(*(id *)(a1 + 40), "timestamp"), "wallTime");
        if (v20 < v21)
        {
LABEL_22:
          int v22 = +[SATimestamp timestampWithMachAbsTime:machAbsTimeSec:machContTime:machContTimeSec:wallTime:]( &OBJC_CLASS___SATimestamp,  "timestampWithMachAbsTime:machAbsTimeSec:machContTime:machContTimeSec:wallTime:",  0LL,  0LL,  0.0,  0.0,  *((double *)*v5 + 18));
          id v23 = (id)*((void *)*v5 + 52);
          if (!v23) {
            id v23 = [*(id *)(a1 + 40) timestamp];
          }
          -[SATimestamp guessMissingTimesBasedOnTimestamp:](v22, "guessMissingTimesBasedOnTimestamp:", v23);
          if (!v22) {
            goto LABEL_30;
          }
          goto LABEL_29;
        }

        id v16 = *v5;
      }
    }

    int v22 = (SATimestamp *)*((void *)v16 + 52);
    if (v22)
    {
LABEL_29:
      objc_msgSend( *(id *)(a1 + 32),  "setEventTimeRange:",  +[SATimeRange timeRangeStart:end:]( SATimeRange,  "timeRangeStart:end:",  v22,  objc_msgSend(*(id *)(a1 + 40), "timestamp")));
      [*(id *)(a1 + 32) setReportTimeStart:v22];
      objc_msgSend(*(id *)(a1 + 32), "setReportTimeEnd:", objc_msgSend(*(id *)(a1 + 40), "timestamp"));
    }
  }

LABEL_30:
  if (*((int *)*v5 + 18) >= 1 && [*v5 eventTimeRange])
  {
    uint64_t v75 = 0LL;
    BOOL v76 = &v75;
    uint64_t v77 = 0x2020000000LL;
    uint64_t v78 = 0LL;
    id v24 = [*v5 reportTimeStart];
    if (!v24) {
      id v24 = objc_msgSend(objc_msgSend(*v5, "eventTimeRange"), "startTime");
    }
    id v25 = [a2 indexOfFirstSampleOnOrAfterTimestamp:v24];
    id v26 = [*v5 reportTimeEnd];
    if (!v26) {
      id v26 = objc_msgSend(objc_msgSend(*v5, "eventTimeRange"), "endTime");
    }
    id v27 = [a2 indexOfLastSampleOnOrBeforeTimestamp:v26];
    if (v25 != (id)0x7FFFFFFFFFFFFFFFLL && v27 != (id)0x7FFFFFFFFFFFFFFFLL)
    {
      v74[0] = _NSConcreteStackBlock;
      v74[1] = 3221225472LL;
      v74[2] = sub_100068A1C;
      v74[3] = &unk_1000D99D0;
      v74[4] = &v75;
      v74[5] = v25;
      v74[6] = v27;
      objc_msgSend( objc_msgSend(a2, "targetProcess"),  "enumerateTaskStatesBetweenStartTime:startSampleIndex:endTime:endSampleIndex:reverseOrder:block:",  v24,  v25,  v26,  v27,  0,  v74);
    }

    *((_DWORD *)*v5 + 72) = v76[3];
    _Block_object_dispose(&v75, 8);
  }

void sub_1000689F8(_Unwind_Exception *a1)
{
}

id sub_100068A1C(void *a1, void *a2)
{
  if ([a2 suspendCount] || (id result = objc_msgSend(a2, "isPidSuspended"), (_DWORD)result))
  {
    id result = [a2 sampleCountInSampleIndexRangeStart:a1[5] end:a1[6]];
    *(void *)(*(void *)(a1[4] + 8LL) + 24LL) += result;
  }

  return result;
}

void sub_100068A74(uint64_t a1)
{
  *(void *)(*(void *)(a1 + 32) + 64LL) = 0LL;
}

LABEL_55:
  sampleProvider = self->super.super._sampleProvider;
  v80[0] = _NSConcreteStackBlock;
  v80[1] = 3221225472LL;
  v80[2] = sub_1000693C4;
  v80[3] = &unk_1000D9A20;
  v80[4] = self;
  v80[5] = a3;
  -[SPStackshotProvider performSampleStoreWork:](sampleProvider, "performSampleStoreWork:", v80);
}

  sampleProvider = self->super.super._sampleProvider;
  v80[0] = _NSConcreteStackBlock;
  v80[1] = 3221225472LL;
  v80[2] = sub_100069D30;
  v80[3] = &unk_1000D9A48;
  v80[4] = self;
  v80[5] = a3;
  -[SPStackshotProvider performSampleStoreWork:](sampleProvider, "performSampleStoreWork:", v80);
}

id sub_1000693C4(uint64_t a1, void *a2, double a3)
{
  LODWORD(a3) = *(_DWORD *)(*(void *)(a1 + 32) + 400LL);
  [a2 setAttemptedSamplingInterval:(double)*(unint64_t *)&a3 / 1000000.0];
  [*(id *)(a1 + 32) reportTimeThreshold];
  objc_msgSend(a2, "setReportTimeThreshold:");
  return [*(id *)(a1 + 32) _saveReportToStream:*(void *)(a1 + 40) withSampleStore:a2];
}

uint64_t sub_100069D30(uint64_t a1, void *a2, double a3)
{
  LODWORD(a3) = *(_DWORD *)(*(void *)(a1 + 32) + 400LL);
  [a2 setAttemptedSamplingInterval:(double)*(unint64_t *)&a3 / 1000000.0];
  [*(id *)(a1 + 32) reportTimeThreshold];
  objc_msgSend(a2, "setReportTimeThreshold:");
  [*(id *)(a1 + 32) _samplePrinterForSampleStore:a2];
  return (*(uint64_t (**)(void))(*(void *)(a1 + 40) + 16LL))();
}

id sub_100069DB0( uint64_t pid, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unint64_t a6, uint64_t a7, uint64_t a8, double a9)
{
  if (!(_DWORD)a4 || !a7 || !a8)
  {
    int v18 = __error();
    id result = 0LL;
    int v20 = 22;
LABEL_323:
    *int v18 = v20;
    return result;
  }

  if ((pid & 0x80000000) != 0) {
    goto LABEL_17;
  }
  if (proc_pidpath(pid, &buffer, 0x400u) >= 1)
  {
    double v17 = +[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", &buffer);
    if ((a6 & 1) == 0) {
      goto LABEL_19;
    }
LABEL_18:
    if (sub_10002578C(pid)) {
      goto LABEL_19;
    }
    if ((pid & 0x80000000) != 0)
    {
      if (byte_1000E7D30)
      {
        int v62 = *__error();
        int v63 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v63, OS_LOG_TYPE_ERROR)) {
          sub_1000928F0();
        }
        *__error() = v62;
      }

      if (!byte_1000E7D31 || dword_1000E74E0 > 3) {
        goto LABEL_194;
      }
      int v35 = *__error();
      int v37 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"process doesn't exist, not sampling");
      if (!v37)
      {
        int v113 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v113, OS_LOG_TYPE_FAULT)) {
          sub_1000928C4();
        }
        goto LABEL_189;
      }
    }

    else
    {
      if (byte_1000E7D30)
      {
        int v33 = *__error();
        BOOL v34 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR)) {
          sub_10009285C();
        }
        *__error() = v33;
      }

      if (!byte_1000E7D31 || dword_1000E74E0 > 3) {
        goto LABEL_194;
      }
      int v35 = *__error();
      int v36 = sub_10002EF3C(pid);
      int v37 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"%s [%d]: process doesn't exist, not sampling",  v36,  pid);
      if (!v37)
      {
        BOOL v38 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v38, OS_LOG_TYPE_FAULT)) {
          sub_1000927F4();
        }
LABEL_189:
        if (qword_1000E7D38) {
          id v114 = (FILE *)qword_1000E7D38;
        }
        else {
          id v114 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v114);
LABEL_193:
        *__error() = v35;
LABEL_194:
        int v18 = __error();
        id result = 0LL;
        int v20 = 2;
        goto LABEL_323;
      }
    }

    int v64 = v37;
    CStringPtr = CFStringGetCStringPtr(v37, 0x8000100u);
    if (CStringPtr)
    {
      char v66 = (char *)CStringPtr;
      uint64_t v67 = 0LL;
    }

    else
    {
      char v66 = (char *)calloc(0x400uLL, 1uLL);
      CFStringGetCString(v64, v66, 1024LL, 0x8000100u);
      uint64_t v67 = v66;
    }

    if (qword_1000E7D38) {
      id v95 = (FILE *)qword_1000E7D38;
    }
    else {
      id v95 = __stderrp;
    }
    fprintf(v95, "%s\n", v66);
    if (v67) {
      free(v67);
    }
    CFRelease(v64);
    goto LABEL_193;
  }

  if (byte_1000E7D30)
  {
    int v21 = *__error();
    int v22 = (os_log_s *)sub_10002EFA0();
    if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR)) {
      sub_1000929A8();
    }
    *__error() = v21;
  }

  if (!byte_1000E7D31 || dword_1000E74E0 > 3)
  {
LABEL_17:
    double v17 = 0LL;
    if ((a6 & 1) == 0) {
      goto LABEL_19;
    }
    goto LABEL_18;
  }

  int v180 = *__error();
  uint64_t v44 = sub_10002EF3C(pid);
  uint64_t v45 = *__error();
  int v46 = __error();
  int v47 = strerror(*v46);
  BOOL v48 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"%s [%d]: Unable to get path: %d (%s)",  v44,  pid,  v45,  v47);
  if (v48)
  {
    uint64_t v49 = v48;
    uint64_t v50 = CFStringGetCStringPtr(v48, 0x8000100u);
    if (v50)
    {
      uint64_t v51 = (char *)v50;
      uint64_t v52 = 0LL;
    }

    else
    {
      uint64_t v51 = (char *)calloc(0x400uLL, 1uLL);
      CFStringGetCString(v49, v51, 1024LL, 0x8000100u);
      uint64_t v52 = v51;
    }

    if (qword_1000E7D38) {
      int v96 = (FILE *)qword_1000E7D38;
    }
    else {
      int v96 = __stderrp;
    }
    fprintf(v96, "%s\n", v51);
    if (v52) {
      free(v52);
    }
    CFRelease(v49);
  }

  else
  {
    int v81 = (os_log_s *)sub_10002EFA0();
    if (os_log_type_enabled(v81, OS_LOG_TYPE_FAULT)) {
      sub_10009291C();
    }
    if (qword_1000E7D38) {
      int v82 = (FILE *)qword_1000E7D38;
    }
    else {
      int v82 = __stderrp;
    }
    fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v82);
  }

  double v17 = 0LL;
  *__error() = v180;
  if ((a6 & 1) != 0) {
    goto LABEL_18;
  }
LABEL_19:
  id v179 = v17;
  char v183 = 0;
  id v24 = +[SPSampledProcess copySampledProcessForPid:isWSBased:createIfUnsampled:wasSampled:]( &OBJC_CLASS___SPSampledProcess,  "copySampledProcessForPid:isWSBased:createIfUnsampled:wasSampled:",  pid,  (a6 >> 2) & 1,  1LL,  &v183);
  if (v24) {
    goto LABEL_20;
  }
  if ((a6 & 2) == 0 || !v183)
  {
LABEL_332:
    if ((pid & 0x80000000) != 0)
    {
      if (byte_1000E7D30)
      {
        int v162 = *__error();
        uint64_t v163 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v163, OS_LOG_TYPE_ERROR)) {
          sub_100091F50();
        }
        *__error() = v162;
      }

      if (!byte_1000E7D31 || dword_1000E74E0 > 3) {
        goto LABEL_322;
      }
      int v158 = *__error();
      uint64_t v160 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"Unable to create SPSampledProcess");
      if (!v160)
      {
        uint64_t v169 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v169, OS_LOG_TYPE_FAULT)) {
          sub_100091F24();
        }
        goto LABEL_360;
      }
    }

    else
    {
      if (byte_1000E7D30)
      {
        int v156 = *__error();
        uint64_t v157 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v157, OS_LOG_TYPE_ERROR)) {
          sub_100091EBC();
        }
        *__error() = v156;
      }

      if (!byte_1000E7D31 || dword_1000E74E0 > 3) {
        goto LABEL_322;
      }
      int v158 = *__error();
      uint64_t v159 = sub_10002EF3C(pid);
      uint64_t v160 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"%s [%d]: Unable to create SPSampledProcess",  v159,  pid);
      if (!v160)
      {
        uint64_t v161 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v161, OS_LOG_TYPE_FAULT)) {
          sub_100091E54();
        }
LABEL_360:
        if (qword_1000E7D38) {
          uint64_t v170 = (FILE *)qword_1000E7D38;
        }
        else {
          uint64_t v170 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v170);
LABEL_364:
        *__error() = v158;
        goto LABEL_322;
      }
    }

    int v164 = v160;
    uint64_t v165 = CFStringGetCStringPtr(v160, 0x8000100u);
    if (v165)
    {
      uint64_t v166 = (char *)v165;
      uint64_t v167 = 0LL;
    }

    else
    {
      uint64_t v166 = (char *)calloc(0x400uLL, 1uLL);
      CFStringGetCString(v164, v166, 1024LL, 0x8000100u);
      uint64_t v167 = v166;
    }

    if (qword_1000E7D38) {
      uint64_t v168 = (FILE *)qword_1000E7D38;
    }
    else {
      uint64_t v168 = __stderrp;
    }
    fprintf(v168, "%s\n", v166);
    if (v167) {
      free(v167);
    }
    CFRelease(v164);
    goto LABEL_364;
  }

  id v31 = +[SPSampledProcess copySampledProcessForPid:isWSBased:createIfUnsampled:wasSampled:]( &OBJC_CLASS___SPSampledProcess,  "copySampledProcessForPid:isWSBased:createIfUnsampled:wasSampled:",  pid,  (a6 & 4) == 0,  0LL,  0LL);
  if (v31)
  {
    int v32 = v31;
    [v31 stopSamplingWithReason:9];

    goto LABEL_331;
  }

  if ((pid & 0x80000000) != 0)
  {
    if (byte_1000E7D30)
    {
      int v178 = *__error();
      id v108 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v108, OS_LOG_TYPE_DEBUG)) {
        sub_100092774((a6 & 4) != 0, v108, v109);
      }
      *__error() = v178;
    }

    if (byte_1000E7D31 && dword_1000E74E0 <= 0)
    {
      int v177 = *__error();
      if ((a6 & 4) != 0) {
        uint64_t v110 = "non-";
      }
      else {
        uint64_t v110 = "";
      }
      int v79 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"Unable to find existing %sWindowServer-based sampled process",  v110);
      if (!v79)
      {
        CFAllocatorRef allocb = (CFAllocatorRef)v110;
        uint64_t v148 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v148, OS_LOG_TYPE_FAULT)) {
          sub_100092710((uint64_t)allocb, v148, v149, v150, v151, v152, v153, v154);
        }
        goto LABEL_326;
      }

LABEL_185:
      CFAllocatorRef alloca = v79;
      uint64_t v111 = CFStringGetCStringPtr(v79, 0x8000100u);
      if (v111)
      {
        uint64_t v112 = (char *)v111;
        uint64_t v171 = 0LL;
      }

      else
      {
        uint64_t v112 = (char *)calloc(0x400uLL, 1uLL);
        CFStringGetCString(alloca, v112, 1024LL, 0x8000100u);
        uint64_t v171 = v112;
      }

      if (qword_1000E7D38) {
        id v124 = (FILE *)qword_1000E7D38;
      }
      else {
        id v124 = __stderrp;
      }
      fprintf(v124, "%s\n", v112);
      if (v171) {
        free(v171);
      }
      CFRelease(alloca);
      goto LABEL_330;
    }
  }

  else
  {
    if (byte_1000E7D30)
    {
      int v176 = *__error();
      BOOL v76 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v76, OS_LOG_TYPE_DEBUG)) {
        sub_100092668(pid);
      }
      *__error() = v176;
    }

    if (byte_1000E7D31 && dword_1000E74E0 <= 0)
    {
      int v177 = *__error();
      uint64_t v77 = sub_10002EF3C(pid);
      if ((a6 & 4) != 0) {
        uint64_t v78 = "non-";
      }
      else {
        uint64_t v78 = "";
      }
      int v79 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"%s [%d]: Unable to find existing %sWindowServer-based sampled process",  v77,  pid,  v78);
      if (!v79)
      {
        int v80 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v80, OS_LOG_TYPE_FAULT)) {
          sub_1000925D8(pid);
        }
LABEL_326:
        if (qword_1000E7D38) {
          int v155 = (FILE *)qword_1000E7D38;
        }
        else {
          int v155 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v155);
LABEL_330:
        *__error() = v177;
        goto LABEL_331;
      }

      goto LABEL_185;
    }
  }

LABEL_331:
  id v24 = +[SPSampledProcess copySampledProcessForPid:isWSBased:createIfUnsampled:wasSampled:]( &OBJC_CLASS___SPSampledProcess,  "copySampledProcessForPid:isWSBased:createIfUnsampled:wasSampled:",  pid,  (a6 >> 2) & 1,  1LL,  &v183);
  if (!v24) {
    goto LABEL_332;
  }
LABEL_20:
  if (!v183)
  {
    [v24 setSamplingIntervalUs:a2];
    [v24 setOccasionalDataIntervalSec:a3];
    [v24 setSamplingMode:a4 withAdditionalSampledProcesses:a5];
    [v24 setOmitSensitiveStrings:(a6 >> 4) & 1];
    [v24 setCancelOnMemoryPressure:(a6 >> 5) & 1];
    if ([v24 startSampling])
    {
      if ((a6 & 0x40) != 0) {
        [v24 requireHIDEvent:1];
      }
      goto LABEL_280;
    }

    if ((pid & 0x80000000) != 0)
    {
      if (byte_1000E7D30)
      {
        int v88 = *__error();
        int v89 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v89, OS_LOG_TYPE_ERROR)) {
          sub_100092078();
        }
        *__error() = v88;
      }

      if (!byte_1000E7D31 || dword_1000E74E0 > 3) {
        goto LABEL_242;
      }
      int v55 = *__error();
      id v90 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"Failed to start sampling");
      if (v90)
      {
        int v91 = v90;
        double v92 = CFStringGetCStringPtr(v90, 0x8000100u);
        if (v92)
        {
          double v93 = (char *)v92;
          double v94 = 0LL;
        }

        else
        {
          double v93 = (char *)calloc(0x400uLL, 1uLL);
          CFStringGetCString(v91, v93, 1024LL, 0x8000100u);
          double v94 = v93;
        }

        if (qword_1000E7D38) {
          int v125 = (FILE *)qword_1000E7D38;
        }
        else {
          int v125 = __stderrp;
        }
        fprintf(v125, "%s\n", v93);
        if (v94) {
          free(v94);
        }
        id v121 = v91;
        goto LABEL_240;
      }

      id v122 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v122, OS_LOG_TYPE_FAULT)) {
        sub_10009204C();
      }
    }

    else
    {
      if (byte_1000E7D30)
      {
        int v53 = *__error();
        uint64_t v54 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v54, OS_LOG_TYPE_ERROR)) {
          sub_100091FE4();
        }
        *__error() = v53;
      }

      if (!byte_1000E7D31 || dword_1000E74E0 > 3) {
        goto LABEL_242;
      }
      int v55 = *__error();
      double v56 = sub_10002EF3C(pid);
      double v57 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"%s [%d]: Failed to start sampling", v56, pid);
      if (v57)
      {
        double v58 = v57;
        int v59 = CFStringGetCStringPtr(v57, 0x8000100u);
        if (v59)
        {
          int v60 = (char *)v59;
          int v61 = 0LL;
        }

        else
        {
          int v60 = (char *)calloc(0x400uLL, 1uLL);
          CFStringGetCString(v58, v60, 1024LL, 0x8000100u);
          int v61 = v60;
        }

        if (qword_1000E7D38) {
          id v120 = (FILE *)qword_1000E7D38;
        }
        else {
          id v120 = __stderrp;
        }
        fprintf(v120, "%s\n", v60);
        if (v61) {
          free(v61);
        }
        id v121 = v58;
LABEL_240:
        CFRelease(v121);
LABEL_241:
        *__error() = v55;
LABEL_242:
        [v24 removeSelfFromPidCache];
LABEL_321:

LABEL_322:
        int v18 = __error();
        id result = 0LL;
        int v20 = 37;
        goto LABEL_323;
      }

      id v119 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v119, OS_LOG_TYPE_FAULT)) {
        sub_100091F7C();
      }
    }

    if (qword_1000E7D38) {
      uint64_t v123 = (FILE *)qword_1000E7D38;
    }
    else {
      uint64_t v123 = __stderrp;
    }
    fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v123);
    goto LABEL_241;
  }

  if ((a6 & 0x102) == 0x100)
  {
    if ((pid & 0x80000000) == 0)
    {
      if (byte_1000E7D30)
      {
        int v25 = *__error();
        id v26 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v26, OS_LOG_TYPE_DEBUG)) {
          sub_10009210C();
        }
        *__error() = v25;
      }

      if (!byte_1000E7D31 || dword_1000E74E0 > 0) {
        goto LABEL_321;
      }
      int v27 = *__error();
      int v28 = sub_10002EF3C(pid);
      int v29 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"%s [%d]: Not overriding existing sampling callback",  v28,  pid);
      if (!v29)
      {
        int v30 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v30, OS_LOG_TYPE_FAULT)) {
          sub_1000920A4();
        }
LABEL_316:
        if (qword_1000E7D38) {
          uint64_t v147 = (FILE *)qword_1000E7D38;
        }
        else {
          uint64_t v147 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v147);
        goto LABEL_320;
      }

      goto LABEL_266;
    }

    if (byte_1000E7D30)
    {
      int v68 = *__error();
      uint64_t v69 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v69, OS_LOG_TYPE_DEBUG)) {
        sub_1000921A0();
      }
      *__error() = v68;
    }

    if (!byte_1000E7D31 || dword_1000E74E0 > 0) {
      goto LABEL_321;
    }
    int v27 = *__error();
    uint64_t v70 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"Not overriding existing sampling callback");
    if (!v70)
    {
      id v71 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v71, OS_LOG_TYPE_FAULT)) {
        sub_100092174();
      }
      goto LABEL_316;
    }

LABEL_266:
    id v131 = v29;
    id v132 = CFStringGetCStringPtr(v29, 0x8000100u);
    if (v132)
    {
      id v133 = (char *)v132;
      id v134 = 0LL;
    }

    else
    {
      id v133 = (char *)calloc(0x400uLL, 1uLL);
      CFStringGetCString(v131, v133, 1024LL, 0x8000100u);
      id v134 = v133;
    }

    if (qword_1000E7D38) {
      uint64_t v142 = (FILE *)qword_1000E7D38;
    }
    else {
      uint64_t v142 = __stderrp;
    }
    fprintf(v142, "%s\n", v133);
    if (v134) {
      free(v134);
    }
    uint64_t v143 = v131;
LABEL_311:
    CFRelease(v143);
LABEL_320:
    *__error() = v27;
    goto LABEL_321;
  }

  if ((a6 & 2) != 0)
  {
    if ((pid & 0x80000000) != 0)
    {
      if (byte_1000E7D30)
      {
        int v101 = *__error();
        __int16 v102 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v102, OS_LOG_TYPE_DEBUG)) {
          sub_100092518();
        }
        *__error() = v101;
      }

      if (byte_1000E7D31 && dword_1000E74E0 <= 0)
      {
        int v103 = *__error();
        uint64_t v42 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"Already sampling, overriding existing callback");
        int v175 = v103;
        if (!v42)
        {
          id v126 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v126, OS_LOG_TYPE_FAULT)) {
            sub_1000924EC();
          }
          goto LABEL_245;
        }

        goto LABEL_173;
      }
    }

    else
    {
      if (byte_1000E7D30)
      {
        int v72 = *__error();
        char v73 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v73, OS_LOG_TYPE_DEBUG)) {
          sub_100092484();
        }
        *__error() = v72;
      }

      if (byte_1000E7D31 && dword_1000E74E0 <= 0)
      {
        int v175 = *__error();
        int v74 = sub_10002EF3C(pid);
        uint64_t v42 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"%s [%d]: Already sampling, overriding existing callback",  v74,  pid);
        if (!v42)
        {
          uint64_t v75 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v75, OS_LOG_TYPE_FAULT)) {
            sub_10009241C();
          }
          goto LABEL_245;
        }

        goto LABEL_173;
      }
    }
  }

  else if ((pid & 0x80000000) != 0)
  {
    if (byte_1000E7D30)
    {
      int v97 = *__error();
      double v98 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v98, OS_LOG_TYPE_DEBUG)) {
        sub_1000923F0();
      }
      *__error() = v97;
    }

    if (byte_1000E7D31 && dword_1000E74E0 <= 0)
    {
      int v99 = *__error();
      uint64_t v42 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"Already sampling, not overriding existing callback");
      int v175 = v99;
      if (!v42)
      {
        id v100 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v100, OS_LOG_TYPE_FAULT)) {
          sub_1000923C4();
        }
        goto LABEL_245;
      }

LABEL_173:
      __int16 v104 = v42;
      double v105 = CFStringGetCStringPtr(v42, 0x8000100u);
      CFAllocatorRef alloc = (CFAllocatorRef)v104;
      if (v105)
      {
        uint64_t v106 = (char *)v105;
        id v107 = 0LL;
      }

      else
      {
        uint64_t v106 = (char *)calloc(0x400uLL, 1uLL);
        CFStringGetCString(v104, v106, 1024LL, 0x8000100u);
        id v107 = v106;
      }

      if (qword_1000E7D38) {
        id v118 = (FILE *)qword_1000E7D38;
      }
      else {
        id v118 = __stderrp;
      }
      fprintf(v118, "%s\n", v106);
      if (v107) {
        free(v107);
      }
      CFRelease(alloc);
      goto LABEL_249;
    }
  }

  else
  {
    if (byte_1000E7D30)
    {
      int v39 = *__error();
      uint64_t v40 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v40, OS_LOG_TYPE_DEBUG)) {
        sub_10009235C();
      }
      *__error() = v39;
    }

    if (byte_1000E7D31 && dword_1000E74E0 <= 0)
    {
      int v175 = *__error();
      uint64_t v41 = sub_10002EF3C(pid);
      uint64_t v42 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"%s [%d]: Already sampling, not overriding existing callback",  v41,  pid);
      if (!v42)
      {
        uint64_t v43 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v43, OS_LOG_TYPE_FAULT)) {
          sub_1000922F4();
        }
LABEL_245:
        if (qword_1000E7D38) {
          int v127 = (FILE *)qword_1000E7D38;
        }
        else {
          int v127 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v127);
LABEL_249:
        *__error() = v175;
        goto LABEL_250;
      }

      goto LABEL_173;
    }
  }

LABEL_250:
  if ([v24 samplingIntervalUs] != (_DWORD)a2
    || (_DWORD)a3
    && [v24 occasionalDataIntervalSec]
    && [v24 occasionalDataIntervalSec] != (_DWORD)a3)
  {
    if ((pid & 0x80000000) != 0)
    {
      if (byte_1000E7D30)
      {
        int v135 = *__error();
        id v136 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v136, OS_LOG_TYPE_ERROR)) {
          sub_1000922C8();
        }
        *__error() = v135;
      }

      if (!byte_1000E7D31 || dword_1000E74E0 > 3) {
        goto LABEL_321;
      }
      int v27 = *__error();
      uint64_t v70 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"Already sampling with incompatible parameters");
      if (!v70)
      {
        BOOL v146 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v146, OS_LOG_TYPE_FAULT)) {
          sub_10009229C();
        }
        goto LABEL_316;
      }

      goto LABEL_275;
    }

    if (byte_1000E7D30)
    {
      int v128 = *__error();
      id v129 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v129, OS_LOG_TYPE_ERROR)) {
        sub_100092234();
      }
      *__error() = v128;
    }

    if (!byte_1000E7D31 || dword_1000E74E0 > 3) {
      goto LABEL_321;
    }
    int v27 = *__error();
    unsigned int v130 = sub_10002EF3C(pid);
    int v29 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"%s [%d]: Already sampling with incompatible parameters",  v130,  pid);
    if (!v29)
    {
      id v145 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v145, OS_LOG_TYPE_FAULT)) {
        sub_1000921CC();
      }
      goto LABEL_316;
    }

    goto LABEL_266;
  }

  if ([v24 samplingMode] >= a4)
  {
    if ((a6 & 2) != 0)
    {
      [v24 setSamplingMode:a4 withAdditionalSampledProcesses:a5];
      [v24 setCancelOnMemoryPressure:(a6 >> 5) & 1];
LABEL_291:
      [v24 requireHIDEvent:(a6 >> 6) & 1];
      LODWORD(v141) = 1;
LABEL_292:
      if ((a6 & 8) != 0) {
        [v24 setIsUrgent:1];
      }
      v182[0] = _NSConcreteStackBlock;
      v182[1] = 3221225472LL;
      v182[2] = sub_10006B714;
      v182[3] = &unk_1000D9A70;
      v182[4] = v24;
      v182[5] = a8;
      [v24 setSamplingCompletionHandlerQueue:a7 andBlock:v182];
      goto LABEL_295;
    }

    if ((a6 & 0x20) == 0) {
      objc_msgSend(v24, "setCancelOnMemoryPressure:", 0, a5);
    }
  }

  else
  {
    [v24 setSamplingMode:a4 withAdditionalSampledProcesses:a5];
    if ((a6 & 0x22) != 0x20)
    {
      [v24 setCancelOnMemoryPressure:(a6 >> 5) & 1];
      if ((a6 & 2) != 0) {
        goto LABEL_291;
      }
    }
  }

LABEL_280:
  uint64_t v141 = (a6 >> 1) & 1;
  if ((a6 & 2) != 0 || !v183) {
    goto LABEL_292;
  }
LABEL_295:
  if (a9 > 0.0) {
    [v24 setSamplingTimeoutAtTime:a9];
  }
  if (((v183 != 0) & ~(_DWORD)v141) == 0) {
    [v24 setStopWhenProcessExits:a6 & 1];
  }
  if ((a6 & 0x80) != 0) {
    [v24 gatherLoadInfoForPid:pid];
  }
  if (v179) {
    [v24 setTargetProcessAbsolutePath:v179];
  }
  return v24;
}

uint64_t sub_10006B714(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void, void, uint64_t))(*(void *)(a1 + 40) + 16LL))( *(void *)(a1 + 40),  *(void *)(a1 + 32),  a2);
}

uint64_t sub_10006B728(int a1)
{
  uint64_t v1 = 0x400000LL;
  if (a1 == 37) {
    uint64_t v1 = 0x4000LL;
  }
  if (a1 == 2) {
    return 0x8000000000LL;
  }
  else {
    return v1;
  }
}

const char *sub_10006B9CC(int a1)
{
  else {
    return off_1000D9AD8[(char)(a1 - 1)];
  }
}

void sub_10006B9F8(id a1)
{
  qword_1000E7CC8 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
  uint64_t v1 = dispatch_queue_attr_make_with_autorelease_frequency(0LL, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
  qword_1000E7CC0 = (uint64_t)dispatch_queue_create("com.apple.spindump.processes_waiting_for_hid_event", v1);
  dispatch_release(v1);
}

uint64_t sub_10006BA50(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL))();
}

_DWORD *sub_10006BA64(uint64_t a1)
{
  return sub_10002EF3C(*(_DWORD *)(*(void *)a1 + 72LL));
}

_DWORD *sub_10006BA74(int *a1)
{
  return sub_10002EF3C(*a1);
}

  ;
}

  ;
}

  ;
}

  ;
}

  ;
}

  ;
}

  ;
}

id sub_10006BB38(id *a1)
{
  return [*a1 targetProcessId];
}

id sub_10006BB44()
{
  return [*v0 targetProcessId];
}

void sub_10006BB50(void *a1, os_log_s *a2, uint64_t a3, const char *a4, uint8_t *a5)
{
}

void sub_10006BB5C(void *a1, uint64_t a2, os_log_t log, const char *a4, ...)
{
}

void sub_10006BB70(void *a1, uint64_t a2, os_log_t log, const char *a4, ...)
{
}

void sub_10006BB84(void *a1, uint64_t a2, os_log_t log, const char *a4, ...)
{
}

  ;
}

id sub_10006BBA8()
{
  return [*v0 machAbsTimeSeconds];
}

void sub_10006BBB4(uint64_t a1@<X8>)
{
  *(void *)(v1 - _Block_object_dispose((const void *)(v1 - 112), 8) = a1;
}

NSData *sub_10006BCB4(uint64_t a1, void *a2)
{
  if (a2)
  {
    uint64_t v3 = a2;
    __int128 v38 = 0u;
    __int128 v39 = 0u;
    __int128 v36 = 0u;
    __int128 v37 = 0u;
    id v4 = [a2 countByEnumeratingWithState:&v36 objects:v44 count:16];
    if (v4)
    {
      id v5 = v4;
      id v6 = 0LL;
      uint64_t v7 = *(void *)v37;
      do
      {
        unsigned int v8 = 0LL;
        do
        {
          if (*(void *)v37 != v7) {
            objc_enumerationMutation(v3);
          }
          uint64_t v9 = *(void **)(*((void *)&v36 + 1) + 8LL * (void)v8);
          stackshot_config_set_pid(a1, [v9 intValue]);
          int v10 = stackshot_capture_with_config(a1);
          if (v10)
          {
            if (v10 == 2)
            {
              if (byte_1000E7D30)
              {
                int v11 = *__error();
                uint64_t v12 = (os_log_s *)sub_10002EFA0();
                if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG)) {
                  sub_100092A8C((uint64_t)v43, v9);
                }
                *__error() = v11;
              }

              if (byte_1000E7D31) {
                BOOL v13 = dword_1000E74E0 <= 0;
              }
              else {
                BOOL v13 = 0;
              }
              if (v13)
              {
                int v14 = *__error();
                uint64_t v15 = CFStringCreateWithFormat( kCFAllocatorDefault,  0,  @"pid %d doesn't exist",  [v9 intValue]);
                if (v15)
                {
                  id v16 = v15;
                  int v33 = v14;
                  double v17 = v3;
                  int v18 = v6;
                  CStringPtr = CFStringGetCStringPtr(v15, 0x8000100u);
                  if (CStringPtr)
                  {
                    int v20 = (char *)CStringPtr;
                    int v21 = 0LL;
                  }

                  else
                  {
                    int v20 = (char *)calloc(0x400uLL, 1uLL);
                    CFStringGetCString(v16, v20, 1024LL, 0x8000100u);
                    int v21 = v20;
                  }

                  if (qword_1000E7D38) {
                    int v27 = (FILE *)qword_1000E7D38;
                  }
                  else {
                    int v27 = __stderrp;
                  }
                  fprintf(v27, "%s\n", v20);
                  if (v21) {
                    free(v21);
                  }
                  CFRelease(v16);
                  id v6 = v18;
                  uint64_t v3 = v17;
                  int v14 = v33;
                }

                else
                {
                  int v25 = (os_log_s *)sub_10002EFA0();
                  if (os_log_type_enabled(v25, OS_LOG_TYPE_FAULT)) {
                    sub_100092A3C((uint64_t)v42, v9);
                  }
                  if (qword_1000E7D38) {
                    id v26 = (FILE *)qword_1000E7D38;
                  }
                  else {
                    id v26 = __stderrp;
                  }
                  fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v26);
                }

                *__error() = v14;
              }

              [v3 removeObject:v9];
            }

            else
            {
              block[0] = _NSConcreteStackBlock;
              block[1] = 3221225472LL;
              block[2] = sub_10006C338;
              block[3] = &unk_1000D9B28;
              int v35 = v10;
              if (qword_1000E7CE0 != -1) {
                dispatch_once(&qword_1000E7CE0, block);
              }
            }
          }

          else
          {
            if (v6)
            {
              stackshot_int buffer = stackshot_config_get_stackshot_buffer(a1);
              -[NSMutableData appendBytes:length:]( v6,  "appendBytes:length:",  stackshot_buffer,  stackshot_config_get_stackshot_size(a1));
            }

            else
            {
              id v23 = objc_alloc(&OBJC_CLASS___NSMutableData);
              uint64_t v24 = stackshot_config_get_stackshot_buffer(a1);
              id v6 = -[NSMutableData initWithBytes:length:]( v23,  "initWithBytes:length:",  v24,  stackshot_config_get_stackshot_size(a1));
            }

            stackshot_config_dealloc_buffer(a1);
          }

          unsigned int v8 = (char *)v8 + 1;
        }

        while (v5 != v8);
        id v28 = [v3 countByEnumeratingWithState:&v36 objects:v44 count:16];
        id v5 = v28;
      }

      while (v28);
      return (NSData *)v6;
    }

    return 0LL;
  }

  stackshot_config_set_pid(a1, 0xFFFFFFFFLL);
  int v29 = stackshot_capture_with_config(a1);
  if (!v29)
  {
    int v30 = objc_alloc(&OBJC_CLASS___NSData);
    uint64_t v31 = stackshot_config_get_stackshot_buffer(a1);
    return -[NSData initWithBytesNoCopy:length:freeWhenDone:]( v30,  "initWithBytesNoCopy:length:freeWhenDone:",  v31,  stackshot_config_get_stackshot_size(a1),  0LL);
  }

  v40[0] = _NSConcreteStackBlock;
  v40[1] = 3221225472LL;
  v40[2] = sub_10006C180;
  v40[3] = &unk_1000D9B28;
  int v41 = v29;
  if (qword_1000E7CD8 != -1)
  {
    dispatch_once(&qword_1000E7CD8, v40);
    return 0LL;
  }

  return 0LL;
}

int *sub_10006C180(int *result)
{
  uint64_t v1 = result;
  if (byte_1000E7D30)
  {
    int v2 = *__error();
    uint64_t v3 = (os_log_s *)sub_10002EFA0();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR)) {
      sub_100092B40();
    }
    id result = __error();
    *id result = v2;
  }

  if (byte_1000E7D31) {
    BOOL v4 = dword_1000E74E0 <= 3;
  }
  else {
    BOOL v4 = 0;
  }
  if (v4)
  {
    int v5 = *__error();
    id v6 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"Stackshot failed: %d", v1[8]);
    if (v6)
    {
      uint64_t v7 = v6;
      CStringPtr = CFStringGetCStringPtr(v6, 0x8000100u);
      if (CStringPtr)
      {
        uint64_t v9 = (char *)CStringPtr;
        int v10 = 0LL;
      }

      else
      {
        uint64_t v9 = (char *)calloc(0x400uLL, 1uLL);
        CFStringGetCString(v7, v9, 1024LL, 0x8000100u);
        int v10 = v9;
      }

      if (qword_1000E7D38) {
        BOOL v13 = (FILE *)qword_1000E7D38;
      }
      else {
        BOOL v13 = __stderrp;
      }
      fprintf(v13, "%s\n", v9);
      if (v10) {
        free(v10);
      }
      CFRelease(v7);
    }

    else
    {
      int v11 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v11, OS_LOG_TYPE_FAULT)) {
        sub_100092ADC();
      }
      if (qword_1000E7D38) {
        uint64_t v12 = (FILE *)qword_1000E7D38;
      }
      else {
        uint64_t v12 = __stderrp;
      }
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v12);
    }

    id result = __error();
    *id result = v5;
  }

  return result;
}

int *sub_10006C338(int *result)
{
  uint64_t v1 = result;
  if (byte_1000E7D30)
  {
    int v2 = *__error();
    uint64_t v3 = (os_log_s *)sub_10002EFA0();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR)) {
      sub_100092B40();
    }
    id result = __error();
    *id result = v2;
  }

  if (byte_1000E7D31) {
    BOOL v4 = dword_1000E74E0 <= 3;
  }
  else {
    BOOL v4 = 0;
  }
  if (v4)
  {
    int v5 = *__error();
    id v6 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"Stackshot failed: %d", v1[8]);
    if (v6)
    {
      uint64_t v7 = v6;
      CStringPtr = CFStringGetCStringPtr(v6, 0x8000100u);
      if (CStringPtr)
      {
        uint64_t v9 = (char *)CStringPtr;
        int v10 = 0LL;
      }

      else
      {
        uint64_t v9 = (char *)calloc(0x400uLL, 1uLL);
        CFStringGetCString(v7, v9, 1024LL, 0x8000100u);
        int v10 = v9;
      }

      if (qword_1000E7D38) {
        BOOL v13 = (FILE *)qword_1000E7D38;
      }
      else {
        BOOL v13 = __stderrp;
      }
      fprintf(v13, "%s\n", v9);
      if (v10) {
        free(v10);
      }
      CFRelease(v7);
    }

    else
    {
      int v11 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v11, OS_LOG_TYPE_FAULT)) {
        sub_100092ADC();
      }
      if (qword_1000E7D38) {
        uint64_t v12 = (FILE *)qword_1000E7D38;
      }
      else {
        uint64_t v12 = __stderrp;
      }
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v12);
    }

    id result = __error();
    *id result = v5;
  }

  return result;
}

void sub_10006D154(_Unwind_Exception *a1)
{
}

uint64_t sub_10006D1CC(uint64_t a1)
{
  context = objc_autoreleasePoolPush();
  integer_t policy_info = 0;
  int v2 = pthread_self();
  thread_act_t v3 = pthread_mach_thread_np(v2);
  if (thread_policy_set(v3, 1u, &policy_info, 1u))
  {
    int v86 = *__error();
    int v87 = (os_log_s *)sub_10002EFA0();
    if (os_log_type_enabled(v87, OS_LOG_TYPE_FAULT)) {
      sub_100092FB0();
    }
    *__error() = v86;
    if (byte_1000E7D31 && dword_1000E74E0 <= 4)
    {
      int v88 = *__error();
      int v89 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"failed to set the sampling thread to a fixed-priority policy");
      id v90 = v89;
      if (v89)
      {
        CStringPtr = (char *)CFStringGetCStringPtr(v89, 0x8000100u);
        if (CStringPtr)
        {
          double v92 = 0LL;
        }

        else
        {
          CStringPtr = (char *)calloc(0x400uLL, 1uLL);
          CFStringGetCString(v90, CStringPtr, 1024LL, 0x8000100u);
          double v92 = CStringPtr;
        }

        if (qword_1000E7D38) {
          uint64_t v111 = (FILE *)qword_1000E7D38;
        }
        else {
          uint64_t v111 = __stderrp;
        }
        fprintf(v111, "%s\n", CStringPtr);
        if (v92) {
          free(v92);
        }
        CFRelease(v90);
      }

      else
      {
        __int16 v102 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v102, OS_LOG_TYPE_FAULT)) {
          sub_100092F84();
        }
        if (qword_1000E7D38) {
          int v103 = (FILE *)qword_1000E7D38;
        }
        else {
          int v103 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v103);
      }

      *__error() = v88;
    }
  }

  integer_t v136 = 63;
  BOOL v4 = pthread_self();
  thread_act_t v5 = pthread_mach_thread_np(v4);
  if (thread_policy_set(v5, 3u, &v136, 1u))
  {
    int v93 = *__error();
    double v94 = (os_log_s *)sub_10002EFA0();
    if (os_log_type_enabled(v94, OS_LOG_TYPE_FAULT)) {
      sub_100092F58();
    }
    *__error() = v93;
    if (byte_1000E7D31 && dword_1000E74E0 <= 4)
    {
      int v95 = *__error();
      int v96 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"failed to set sampling thread's priority");
      int v97 = v96;
      if (v96)
      {
        double v98 = (char *)CFStringGetCStringPtr(v96, 0x8000100u);
        if (v98)
        {
          int v99 = 0LL;
        }

        else
        {
          double v98 = (char *)calloc(0x400uLL, 1uLL);
          CFStringGetCString(v97, v98, 1024LL, 0x8000100u);
          int v99 = v98;
        }

        if (qword_1000E7D38) {
          uint64_t v112 = (FILE *)qword_1000E7D38;
        }
        else {
          uint64_t v112 = __stderrp;
        }
        fprintf(v112, "%s\n", v98);
        if (v99) {
          free(v99);
        }
        CFRelease(v97);
      }

      else
      {
        __int16 v104 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v104, OS_LOG_TYPE_FAULT)) {
          sub_100092F2C();
        }
        if (qword_1000E7D38) {
          double v105 = (FILE *)qword_1000E7D38;
        }
        else {
          double v105 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v105);
      }

      *__error() = v95;
    }
  }

  dispatch_semaphore_t v6 = 0LL;
  uint64_t v132 = 0LL;
  id v133 = &v132;
  uint64_t v134 = 0x2020000000LL;
  uint64_t v135 = 0LL;
  dsema = v6;
  group = dispatch_group_create();
  int v7 = byte_1000E7D89;
  if (byte_1000E7D89) {
    dispatch_suspend(*(dispatch_object_t *)(a1 + 24));
  }
  uint64_t v128 = 0LL;
  id v129 = &v128;
  uint64_t v130 = 0x2020000000LL;
  uint64_t v131 = 0LL;
  dispatch_time_t v8 = dispatch_time(0LL, 0LL);
  double Current = SAMachAbsTimeSecondsGetCurrent(v8);
  int v113 = v7;
  [*(id *)(a1 + 8) startingSamplingLiveSystem];
  uint64_t v10 = 0LL;
  id v118 = 0LL;
  unsigned __int8 v119 = 0;
  do
  {
    int v11 = objc_autoreleasePoolPush();
    if ((byte_1000E7D44 & 2) != 0 && sub_1000257B8())
    {
      ++*(_DWORD *)(a1 + 88);
      goto LABEL_118;
    }

    ++*(_DWORD *)(a1 + 84);
    uint64_t v12 = (_DWORD *)dispatch_semaphore_wait(*(dispatch_semaphore_t *)(a1 + 112), 0LL);
    if (v12)
    {
      if (byte_1000E7D30)
      {
        int v13 = *__error();
        int v14 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
          sub_100092F00(&v126, v127);
        }
        uint64_t v12 = __error();
        *uint64_t v12 = v13;
      }

      if (byte_1000E7D31) {
        BOOL v15 = dword_1000E74E0 <= 3;
      }
      else {
        BOOL v15 = 0;
      }
      if (v15)
      {
        int v17 = *__error();
        int v18 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"Unable to update sampling pid list");
        double v19 = v18;
        if (v18)
        {
          int v20 = (char *)CFStringGetCStringPtr(v18, 0x8000100u);
          if (v20)
          {
            int v21 = 0LL;
          }

          else
          {
            int v20 = (char *)calloc(0x400uLL, 1uLL);
            CFStringGetCString(v19, v20, 1024LL, 0x8000100u);
            int v21 = v20;
          }

          if (qword_1000E7D38) {
            uint64_t v24 = (FILE *)qword_1000E7D38;
          }
          else {
            uint64_t v24 = __stderrp;
          }
          fprintf(v24, "%s\n", v20);
          if (v21) {
            free(v21);
          }
          CFRelease(v19);
        }

        else
        {
          int v22 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v22, OS_LOG_TYPE_FAULT)) {
            sub_100092ED4(&v124, v125);
          }
          if (qword_1000E7D38) {
            id v23 = (FILE *)qword_1000E7D38;
          }
          else {
            id v23 = __stderrp;
          }
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v23);
        }

        uint64_t v12 = __error();
        BOOL v16 = 0;
        *uint64_t v12 = v17;
      }

      else
      {
        BOOL v16 = 0;
      }
    }

    else
    {
      BOOL v16 = *(_BYTE *)(a1 + 104) != 0;
      if (*(_BYTE *)(a1 + 104))
      {
        *(_BYTE *)(a1 + 104) = 0;

        id v118 = [*(id *)(a1 + 96) mutableCopy];
      }

      uint64_t v12 = (_DWORD *)dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 112));
    }

    uint64_t v25 = v129[3];
    if (v25) {
      v129[3] = 0LL;
    }
    else {
      uint64_t v25 = stackshot_config_create(v12);
    }
    if ((byte_1000E7D44 & 0x20) != 0) {
      uint64_t v26 = 0x44DA1200BLL;
    }
    else {
      uint64_t v26 = 1302405131LL;
    }
    if (v10) {
      int v27 = v16;
    }
    else {
      int v27 = 1;
    }
    if (v27 == 1)
    {
      stackshot_config_set_flags(v25, v26);
      stackshot_config_set_delta_timestamp(v25, 0LL);
    }

    else
    {
      stackshot_config_set_flags(v25, v26 | 0x40000);
      stackshot_config_set_delta_timestamp(v25, v10);
      if (dword_1000E7D08)
      {
        uint64_t v28 = (((double)dword_1000E7D08 * 1.2) + 0x3FFFF) & 0xFFFC0000;
        stackshot_config_set_size_hint(v25, v28);
        goto LABEL_55;
      }
    }

    uint64_t v28 = 0LL;
LABEL_55:
    uint64_t v10 = mach_absolute_time();
    int v29 = sub_10006BCB4(v25, v118);
    if (v29)
    {
      double v30 = SASecondsFromMachTimeUsingLiveTimebase(v10);
      if (-[NSData length](v29, "length") >= 0xFFFFFFFF)
      {
        if (byte_1000E7D30)
        {
          int v84 = *__error();
          int v85 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v85, OS_LOG_TYPE_ERROR)) {
            sub_100092E88(buf, -[NSData length](v29, "length"));
          }
          *__error() = v84;
        }

        if (byte_1000E7D31 && dword_1000E74E0 <= 3)
        {
          int v79 = *__error();
          int v80 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"%s: bad stackshot data length %lu",  "stackshotData.length < 4294967295U",  -[NSData length](v29, "length"));
          int v81 = v80;
          if (v80)
          {
            id v100 = (char *)CFStringGetCStringPtr(v80, 0x8000100u);
            if (v100)
            {
              int v101 = 0LL;
            }

            else
            {
              id v100 = (char *)calloc(0x400uLL, 1uLL);
              CFStringGetCString(v81, v100, 1024LL, 0x8000100u);
              int v101 = v100;
            }

            if (qword_1000E7D38) {
              uint64_t v106 = (FILE *)qword_1000E7D38;
            }
            else {
              uint64_t v106 = __stderrp;
            }
            fprintf(v106, "%s\n", v100);
            if (v101) {
              free(v101);
            }
            CFRelease(v81);
          }

          else
          {
            int v82 = (os_log_s *)sub_10002EFA0();
            if (os_log_type_enabled(v82, OS_LOG_TYPE_FAULT)) {
              sub_100092E48(v138, -[NSData length](v29, "length"));
            }
            if (qword_1000E7D38) {
              int v83 = (FILE *)qword_1000E7D38;
            }
            else {
              int v83 = __stderrp;
            }
            fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v83);
          }

          *__error() = v79;
        }

        -[NSData length](v29, "length");
        sub_10002EE78( "_SamplingThread",  "SPSampleProvider.m",  270,  "%s: bad stackshot data length %lu",  v107,  v108,  v109,  v110,  (char)"stackshotData.length < 4294967295U");
        abort();
      }

      NSUInteger v31 = -[NSData length](v29, "length");
      NSUInteger v32 = v31;
      if ((v27 & 1) == 0)
      {
        if ((_DWORD)v28 && v28 < v31)
        {
          if (byte_1000E7D30)
          {
            int v33 = *__error();
            BOOL v34 = (os_log_s *)sub_10002EFA0();
            if (os_log_type_enabled(v34, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)buf = 67109632;
              int v140 = dword_1000E7D08;
              __int16 v141 = 1024;
              *(_DWORD *)uint64_t v142 = v28;
              *(_WORD *)&v142[4] = 1024;
              *(_DWORD *)&v142[6] = v32;
              _os_log_debug_impl( (void *)&_mh_execute_header,  v34,  OS_LOG_TYPE_DEBUG,  "Hint too small (previous %d, hint %d, actual %d)",  buf,  0x14u);
            }

            *__error() = v33;
          }

          if (byte_1000E7D31 && dword_1000E74E0 <= 0)
          {
            int v115 = *__error();
            int v35 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"Hint too small (previous %d, hint %d, actual %d)",  dword_1000E7D08,  v28,  v32);
            __int128 v36 = v35;
            if (v35)
            {
              __int128 v37 = (char *)CFStringGetCStringPtr(v35, 0x8000100u);
              if (v37)
              {
                __int128 v38 = 0LL;
              }

              else
              {
                __int128 v37 = (char *)calloc(0x400uLL, 1uLL);
                CFStringGetCString(v36, v37, 1024LL, 0x8000100u);
                __int128 v38 = v37;
              }

              if (qword_1000E7D38) {
                int v41 = (FILE *)qword_1000E7D38;
              }
              else {
                int v41 = __stderrp;
              }
              fprintf(v41, "%s\n", v37);
              if (v38) {
                free(v38);
              }
              CFRelease(v36);
            }

            else
            {
              __int128 v39 = (os_log_s *)sub_10002EFA0();
              if (os_log_type_enabled(v39, OS_LOG_TYPE_FAULT))
              {
                *(_DWORD *)buf = 67109632;
                int v140 = dword_1000E7D08;
                __int16 v141 = 1024;
                *(_DWORD *)uint64_t v142 = v28;
                *(_WORD *)&v142[4] = 1024;
                *(_DWORD *)&v142[6] = v32;
                _os_log_fault_impl( (void *)&_mh_execute_header,  v39,  OS_LOG_TYPE_FAULT,  "Unable to format: Hint too small (previous %d, hint %d, actual %d)",  buf,  0x14u);
              }

              if (qword_1000E7D38) {
                uint64_t v40 = (FILE *)qword_1000E7D38;
              }
              else {
                uint64_t v40 = __stderrp;
              }
              fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v40);
            }

            *__error() = v115;
          }
        }
      }

      if (dsema)
      {
        uint64_t v42 = (unint64_t *)(v133 + 3);
        do
        {
          unint64_t v43 = __ldxr(v42);
          int64_t v44 = v43 + v32;
        }

        while (__stxr(v44, v42));
        v119 |= v44 > 20971519;
      }

      dispatch_queue_global_t global_queue = dispatch_get_global_queue(25LL, 0LL);
      block[0] = _NSConcreteStackBlock;
      block[1] = 3221225472LL;
      block[2] = sub_1000713C8;
      block[3] = &unk_1000D9C10;
      *(double *)&void block[6] = v30;
      void block[4] = a1;
      void block[5] = group;
      dispatch_async(global_queue, block);
      if (qword_1000E7D18 != -1) {
        dispatch_once(&qword_1000E7D18, &stru_1000D9C30);
      }
      if (qword_1000E7D10)
      {
        id v46 = -[NSData bytes](v29, "bytes");
        NSUInteger v47 = -[NSData length](v29, "length");
        if (fwrite(v46, v47, 1uLL, (FILE *)qword_1000E7D10) != 1)
        {
          if (byte_1000E7D30)
          {
            int v48 = *__error();
            uint64_t v49 = (os_log_s *)sub_10002EFA0();
            if (os_log_type_enabled(v49, OS_LOG_TYPE_ERROR))
            {
              int v63 = ferror((FILE *)qword_1000E7D10);
              int v64 = strerror(v63);
              *(_DWORD *)buf = 67109378;
              int v140 = v63;
              __int16 v141 = 2080;
              *(void *)uint64_t v142 = v64;
              _os_log_error_impl( (void *)&_mh_execute_header,  v49,  OS_LOG_TYPE_ERROR,  "Unable to write stackshot: %d (%s)",  buf,  0x12u);
            }

            *__error() = v48;
          }

          if (byte_1000E7D31 && dword_1000E74E0 <= 3)
          {
            int v116 = *__error();
            uint64_t v50 = ferror((FILE *)qword_1000E7D10);
            uint64_t v51 = strerror(v50);
            uint64_t v52 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"Unable to write stackshot: %d (%s)",  v50,  v51);
            int v53 = v52;
            if (v52)
            {
              uint64_t v54 = (char *)CFStringGetCStringPtr(v52, 0x8000100u);
              if (v54)
              {
                int v55 = 0LL;
              }

              else
              {
                uint64_t v54 = (char *)calloc(0x400uLL, 1uLL);
                CFStringGetCString(v53, v54, 1024LL, 0x8000100u);
                int v55 = v54;
              }

              if (qword_1000E7D38) {
                double v58 = (FILE *)qword_1000E7D38;
              }
              else {
                double v58 = __stderrp;
              }
              fprintf(v58, "%s\n", v54);
              if (v55) {
                free(v55);
              }
              CFRelease(v53);
            }

            else
            {
              double v56 = (os_log_s *)sub_10002EFA0();
              if (os_log_type_enabled(v56, OS_LOG_TYPE_FAULT))
              {
                int v65 = ferror((FILE *)qword_1000E7D10);
                char v66 = strerror(v65);
                *(_DWORD *)buf = 67109378;
                int v140 = v65;
                __int16 v141 = 2080;
                *(void *)uint64_t v142 = v66;
                _os_log_fault_impl( (void *)&_mh_execute_header,  v56,  OS_LOG_TYPE_FAULT,  "Unable to format: Unable to write stackshot: %d (%s)",  buf,  0x12u);
              }

              if (qword_1000E7D38) {
                double v57 = (FILE *)qword_1000E7D38;
              }
              else {
                double v57 = __stderrp;
              }
              fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v57);
            }

            *__error() = v116;
          }

          fclose((FILE *)qword_1000E7D10);
          qword_1000E7D10 = 0LL;
        }
      }

      int v59 = *(dispatch_queue_s **)(a1 + 24);
      v121[0] = _NSConcreteStackBlock;
      v121[1] = 3221225472LL;
      v121[2] = sub_1000719BC;
      v121[3] = &unk_1000D9C58;
      v121[4] = a1;
      v121[5] = v29;
      v121[7] = &v128;
      v121[6] = dsema;
      int v122 = v32;
      v121[8] = &v132;
      v121[9] = v25;
      dispatch_group_async(group, v59, v121);
    }

LABEL_118:
    objc_autoreleasePoolPop(v11);
    if (((dsema != 0LL) & v119) == 1)
    {
      if (qword_1000E7D20 != -1) {
        dispatch_once(&qword_1000E7D20, &stru_1000D9C78);
      }
      uint64_t v60 = dispatch_semaphore_wait(dsema, 0xFFFFFFFFFFFFFFFFLL);
      unsigned __int8 v119 = 0;
    }

    double v61 = SAMachAbsTimeSecondsGetCurrent(v60);
    unsigned int v62 = *(_DWORD *)(a1 + 64);
    double Current = Current + (double)v62 / 1000000.0;
    if (Current <= v61)
    {
      dispatch_time_t v8 = dispatch_time(0LL, 0LL);
      double Current = v61;
    }

    else
    {
      dispatch_time_t v8 = dispatch_time(v8, 1000LL * v62);
    }
  }

  while (dispatch_semaphore_wait(*(dispatch_semaphore_t *)(a1 + 48), v8));
  [*(id *)(a1 + 8) finishedSamplingLiveSystem];

  if (v113)
  {
    if (qword_1000E7D90 && dispatch_group_wait((dispatch_group_t)qword_1000E7D90, 0LL))
    {
      if (byte_1000E7D30)
      {
        int v67 = *__error();
        int v68 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v68, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v68,  OS_LOG_TYPE_DEFAULT,  "Sampling completed, waiting for SIGINFO...",  buf,  2u);
        }

        *__error() = v67;
      }

      if (byte_1000E7D31 && dword_1000E74E0 <= 2)
      {
        int v69 = *__error();
        uint64_t v70 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"Sampling completed, waiting for SIGINFO...");
        id v71 = v70;
        if (v70)
        {
          int v72 = (char *)CFStringGetCStringPtr(v70, 0x8000100u);
          if (v72)
          {
            char v73 = 0LL;
          }

          else
          {
            int v72 = (char *)calloc(0x400uLL, 1uLL);
            CFStringGetCString(v71, v72, 1024LL, 0x8000100u);
            char v73 = v72;
          }

          if (qword_1000E7D38) {
            BOOL v76 = (FILE *)qword_1000E7D38;
          }
          else {
            BOOL v76 = __stderrp;
          }
          fprintf(v76, "%s\n", v72);
          if (v73) {
            free(v73);
          }
          CFRelease(v71);
        }

        else
        {
          int v74 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v74, OS_LOG_TYPE_FAULT)) {
            sub_100092E1C();
          }
          if (qword_1000E7D38) {
            uint64_t v75 = (FILE *)qword_1000E7D38;
          }
          else {
            uint64_t v75 = __stderrp;
          }
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v75);
        }

        *__error() = v69;
      }

      dispatch_group_wait((dispatch_group_t)qword_1000E7D90, 0xFFFFFFFFFFFFFFFFLL);
    }

    dispatch_resume(*(dispatch_object_t *)(a1 + 24));
  }

  dispatch_group_wait(group, 0xFFFFFFFFFFFFFFFFLL);
  uint64_t v77 = v129[3];
  if (v77) {
    stackshot_config_dealloc(v77);
  }
  if (dsema) {
    dispatch_release(dsema);
  }
  dispatch_release(group);
  _Block_object_dispose(&v128, 8);
  _Block_object_dispose(&v132, 8);
  objc_autoreleasePoolPop(context);
  return 0LL;
}

void sub_10006E3F4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, uint64_t a47, char a48)
{
}

LABEL_132:
  objc_sync_exit(self);
}

void sub_10006ED50(_Unwind_Exception *a1)
{
}

void sub_10006EE30(id a1)
{
  uint64_t v1 = dispatch_queue_attr_make_with_autorelease_frequency(0LL, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
  qword_1000E7CF0 = (uint64_t)dispatch_queue_create("com.apple.spindump.sample_provider_singleton", v1);
  dispatch_release(v1);
}

void sub_10006EF60( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

void sub_10006EF78(uint64_t a1, uint64_t a2)
{
}

void sub_10006EF88(uint64_t a1)
{
}

void sub_10006EF94(uint64_t a1)
{
  int v2 = dword_1000E7CF8;
  if (!dword_1000E7CF8)
  {
    qword_1000E7D00 = objc_alloc_init(&OBJC_CLASS___SPStackshotProvider);
    int v2 = dword_1000E7CF8;
  }

  dword_1000E7CF8 = v2 + 1;
  id v3 = +[SATimestamp timestamp](&OBJC_CLASS___SATimestamp, "timestamp");
  uint64_t v4 = *(unsigned int *)(qword_1000E7D00 + 84);
  uint64_t v5 = *(unsigned int *)(qword_1000E7D00 + 88);
  if ([(id)qword_1000E7D00 startWithSamplingIntervalUs:*(unsigned int *)(a1 + 48) andOccasionalDataIntervalSec:*(unsigned int *)(a1 + 52) andOnlySampleProcesses:*(void *)(a1 + 32) andOnlySampleMain Threads:*(unsigned __int8 *)(a1 + 56) andOmitSensitiveStrings:*(unsigned __int8 *)(a1 + 57)])
  {
    dispatch_semaphore_t v6 = objc_alloc(&OBJC_CLASS___SPStackshotProviderSnapshot);
    *(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 40LL) = -[SPStackshotProviderSnapshot initWithStackshotProvider:timestamp:numSamples:numSamplesAvoidedDueToAudio:]( v6,  "initWithStackshotProvider:timestamp:numSamples:numSa mplesAvoidedDueToAudio:",  qword_1000E7D00,  v3,  v4,  v5);
  }

  else
  {
    *(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 40LL) = 0LL;
    if (!--dword_1000E7CF8)
    {
      int v7 = *__error();
      dispatch_time_t v8 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_FAULT)) {
        sub_1000930E4();
      }
      *__error() = v7;
      if (byte_1000E7D31 && dword_1000E74E0 <= 4)
      {
        int v9 = *__error();
        uint64_t v10 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"shared instance has 0 references");
        if (v10)
        {
          int v11 = v10;
          CStringPtr = CFStringGetCStringPtr(v10, 0x8000100u);
          if (CStringPtr)
          {
            int v13 = (char *)CStringPtr;
            int v14 = 0LL;
          }

          else
          {
            int v13 = (char *)calloc(0x400uLL, 1uLL);
            CFStringGetCString(v11, v13, 1024LL, 0x8000100u);
            int v14 = v13;
          }

          if (qword_1000E7D38) {
            int v17 = (FILE *)qword_1000E7D38;
          }
          else {
            int v17 = __stderrp;
          }
          fprintf(v17, "%s\n", v13);
          if (v14) {
            free(v14);
          }
          CFRelease(v11);
        }

        else
        {
          BOOL v15 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v15, OS_LOG_TYPE_FAULT)) {
            sub_1000930B8();
          }
          if (qword_1000E7D38) {
            BOOL v16 = (FILE *)qword_1000E7D38;
          }
          else {
            BOOL v16 = __stderrp;
          }
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v16);
        }

        *__error() = v9;
      }

      qword_1000E7D00 = 0LL;
    }
  }

void sub_10006F9F8(_Unwind_Exception *a1)
{
}

LABEL_200:
        id v23 = 1;
        goto LABEL_201;
      }

      if (byte_1000E7D30)
      {
        int v59 = *__error();
        uint64_t v60 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v60, OS_LOG_TYPE_ERROR)) {
          sub_10009335C();
        }
        *__error() = v59;
      }

      id v23 = 0;
      if (!byte_1000E7D31 || dword_1000E74E0 > 3) {
        goto LABEL_201;
      }
      uint64_t v42 = *__error();
      double v61 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"Already sampling with sensitive strings, so can't start monitoring since we don't want sensitive strings");
      int64_t v44 = v61;
      if (v61)
      {
        unsigned int v62 = (char *)CFStringGetCStringPtr(v61, 0x8000100u);
        if (v62)
        {
          int v63 = 0LL;
        }

        else
        {
          unsigned int v62 = (char *)calloc(0x400uLL, 1uLL);
          CFStringGetCString(v44, v62, 1024LL, 0x8000100u);
          int v63 = v62;
        }

        if (qword_1000E7D38) {
          uint64_t v111 = (FILE *)qword_1000E7D38;
        }
        else {
          uint64_t v111 = __stderrp;
        }
        fprintf(v111, "%s\n", v62);
        if (v63) {
          free(v63);
        }
LABEL_107:
        CFRelease(v44);
        goto LABEL_108;
      }

      int v91 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v91, OS_LOG_TYPE_FAULT)) {
        sub_100093330();
      }
      if (qword_1000E7D38) {
        double v58 = (FILE *)qword_1000E7D38;
      }
      else {
        double v58 = __stderrp;
      }
    }

    else
    {
      if (!self->_hasSampled)
      {
        dispatch_group_enter((dispatch_group_t)self->_samplingGroup);
        self->_hasSampled = 1;
        ++self->_numClientsSampling;
        self->_samplingIntervalUs = v11;
        self->_occasionalDataIntervalSec = v10;
        self->_previousTimeOccasionalDataWasGathered = 0.0;
        self->_omitSensitiveStrings = v7;
        -[SASampleStore setOmitSensitiveStrings:](self->_sampleStore, "setOmitSensitiveStrings:", v7);
        dispatch_semaphore_wait((dispatch_semaphore_t)self->_pidsSem, 0xFFFFFFFFFFFFFFFFLL);
        self->_sampleOnlyPidsHasUpdate = 1;

        if (a5)
        {
          self->_sampleOnlyPids = (NSMutableSet *)[a5 mutableCopy];
          if (byte_1000E7D30)
          {
            int v35 = *__error();
            __int128 v36 = (os_log_s *)sub_10002EFA0();
            if (os_log_type_enabled(v36, OS_LOG_TYPE_INFO))
            {
              *(_DWORD *)buf = 136315138;
              *(void *)unsigned __int8 v119 = objc_msgSend(objc_msgSend(a5, "description"), "UTF8String");
              _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_INFO, "Sampling only %s", buf, 0xCu);
            }

            *__error() = v35;
          }

          if (byte_1000E7D31 && dword_1000E74E0 <= 1)
          {
            __int128 v37 = *__error();
            __int128 v38 = CFStringCreateWithFormat( kCFAllocatorDefault,  0,  @"Sampling only %s",  objc_msgSend(objc_msgSend(a5, "description"), "UTF8String"));
            __int128 v39 = v38;
            if (v38)
            {
              uint64_t v40 = (char *)CFStringGetCStringPtr(v38, 0x8000100u);
              if (v40)
              {
                int v41 = 0LL;
              }

              else
              {
                uint64_t v40 = (char *)calloc(0x400uLL, 1uLL);
                CFStringGetCString(v39, v40, 1024LL, 0x8000100u);
                int v41 = v40;
              }

              if (qword_1000E7D38) {
                int v84 = (FILE *)qword_1000E7D38;
              }
              else {
                int v84 = __stderrp;
              }
              fprintf(v84, "%s\n", v40);
              if (v41) {
                free(v41);
              }
              CFRelease(v39);
            }

            else
            {
              uint64_t v78 = (os_log_s *)sub_10002EFA0();
              if (os_log_type_enabled(v78, OS_LOG_TYPE_FAULT)) {
                sub_100093298((uint64_t)objc_msgSend(objc_msgSend(a5, "description"), "UTF8String"), (uint64_t)v122, v78);
              }
              if (qword_1000E7D38) {
                int v79 = (FILE *)qword_1000E7D38;
              }
              else {
                int v79 = __stderrp;
              }
              fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v79);
            }

            *__error() = v37;
          }
        }

        else
        {
          self->_sampleOnlyPids = 0LL;
          if (byte_1000E7D30)
          {
            uint64_t v49 = *__error();
            uint64_t v50 = (os_log_s *)sub_10002EFA0();
            if (os_log_type_enabled(v50, OS_LOG_TYPE_DEBUG)) {
              sub_10009326C();
            }
            *__error() = v49;
          }

          dispatch_time_t v8 = 0LL;
          if (byte_1000E7D31 && dword_1000E74E0 <= 0)
          {
            uint64_t v51 = *__error();
            uint64_t v52 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"Sampling everything");
            int v53 = v52;
            if (v52)
            {
              uint64_t v54 = (char *)CFStringGetCStringPtr(v52, 0x8000100u);
              if (v54)
              {
                int v55 = 0LL;
              }

              else
              {
                uint64_t v54 = (char *)calloc(0x400uLL, 1uLL);
                CFStringGetCString(v53, v54, 1024LL, 0x8000100u);
                int v55 = v54;
              }

              if (qword_1000E7D38) {
                double v92 = (FILE *)qword_1000E7D38;
              }
              else {
                double v92 = __stderrp;
              }
              fprintf(v92, "%s\n", v54);
              if (v55) {
                free(v55);
              }
              CFRelease(v53);
            }

            else
            {
              int v85 = (os_log_s *)sub_10002EFA0();
              if (os_log_type_enabled(v85, OS_LOG_TYPE_FAULT)) {
                sub_100093240();
              }
              if (qword_1000E7D38) {
                int v86 = (FILE *)qword_1000E7D38;
              }
              else {
                int v86 = __stderrp;
              }
              fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v86);
            }

            dispatch_time_t v8 = 0LL;
            *__error() = v51;
          }
        }

        -[SASampleStore setSampleOnlyMainThreads:](self->_sampleStore, "setSampleOnlyMainThreads:", v8);
        dispatch_semaphore_signal((dispatch_semaphore_t)self->_pidsSem);
        -[SPStackshotProvider startSamplingThread](self, "startSamplingThread");
        if (byte_1000E7D30)
        {
          int v93 = *__error();
          double v94 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v94, OS_LOG_TYPE_DEBUG))
          {
            uint64_t v108 = self->_samplingIntervalUs;
            uint64_t v107 = self->_occasionalDataIntervalSec;
            uint64_t v109 = -[SASampleStore sampleOnlyMainThreads](self->_sampleStore, "sampleOnlyMainThreads");
            uint64_t v110 = "";
            *(_DWORD *)buf = 67109634;
            *(_DWORD *)unsigned __int8 v119 = v108;
            if (v109) {
              uint64_t v110 = ", sampling only main threads";
            }
            *(_WORD *)&v119[4] = 1024;
            *(_DWORD *)&v119[6] = v107;
            id v120 = 2080;
            v121[0] = v110;
            _os_log_debug_impl( (void *)&_mh_execute_header,  v94,  OS_LOG_TYPE_DEBUG,  "Started sampling with %uus-interval stackshots and %us-interval occasional data%s",  buf,  0x18u);
          }

          *__error() = v93;
        }

        id v23 = 1;
        if (!byte_1000E7D31 || dword_1000E74E0 > 0) {
          goto LABEL_201;
        }
        int v95 = *__error();
        int v96 = self->_samplingIntervalUs;
        int v97 = self->_occasionalDataIntervalSec;
        else {
          double v98 = "";
        }
        int v99 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"Started sampling with %uus-interval stackshots and %us-interval occasional data%s",  v96,  v97,  v98);
        id v100 = v99;
        if (v99)
        {
          int v101 = (char *)CFStringGetCStringPtr(v99, 0x8000100u);
          if (v101)
          {
            __int16 v102 = 0LL;
          }

          else
          {
            int v101 = (char *)calloc(0x400uLL, 1uLL);
            CFStringGetCString(v100, v101, 1024LL, 0x8000100u);
            __int16 v102 = v101;
          }

          if (qword_1000E7D38) {
            double v105 = (FILE *)qword_1000E7D38;
          }
          else {
            double v105 = __stderrp;
          }
          fprintf(v105, "%s\n", v101);
          if (v102) {
            free(v102);
          }
          CFRelease(v100);
        }

        else
        {
          int v103 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v103, OS_LOG_TYPE_FAULT))
          {
            int v115 = self->_samplingIntervalUs;
            id v114 = self->_occasionalDataIntervalSec;
            else {
              int v116 = "";
            }
            *(_DWORD *)buf = 67109634;
            *(_DWORD *)unsigned __int8 v119 = v115;
            *(_WORD *)&v119[4] = 1024;
            *(_DWORD *)&v119[6] = v114;
            id v120 = 2080;
            v121[0] = v116;
            _os_log_fault_impl( (void *)&_mh_execute_header,  v103,  OS_LOG_TYPE_FAULT,  "Unable to format: Started sampling with %uus-interval stackshots and %us-interval occasional data%s",  buf,  0x18u);
          }

          if (qword_1000E7D38) {
            __int16 v104 = (FILE *)qword_1000E7D38;
          }
          else {
            __int16 v104 = __stderrp;
          }
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v104);
        }

        *__error() = v95;
        goto LABEL_200;
      }

      if (byte_1000E7D30)
      {
        uint64_t v24 = *__error();
        uint64_t v25 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR)) {
          sub_100093300();
        }
        *__error() = v24;
      }

      if (byte_1000E7D31) {
        uint64_t v26 = dword_1000E74E0 <= 3;
      }
      else {
        uint64_t v26 = 0;
      }
      if (!v26)
      {
LABEL_29:
        id v23 = 0;
LABEL_201:
        objc_sync_exit(self);
        return v23;
      }

      uint64_t v42 = *__error();
      unint64_t v43 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"Caught a sampling provider that isn't sampling, but has already sampled");
      int64_t v44 = v43;
      if (v43)
      {
        uint64_t v45 = (char *)CFStringGetCStringPtr(v43, 0x8000100u);
        if (v45)
        {
          id v46 = 0LL;
        }

        else
        {
          uint64_t v45 = (char *)calloc(0x400uLL, 1uLL);
          CFStringGetCString(v44, v45, 1024LL, 0x8000100u);
          id v46 = v45;
        }

        if (qword_1000E7D38) {
          char v66 = (FILE *)qword_1000E7D38;
        }
        else {
          char v66 = __stderrp;
        }
        fprintf(v66, "%s\n", v45);
        if (v46) {
          free(v46);
        }
        goto LABEL_107;
      }

      double v57 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v57, OS_LOG_TYPE_FAULT)) {
        sub_1000932D4();
      }
      if (qword_1000E7D38) {
        double v58 = (FILE *)qword_1000E7D38;
      }
      else {
        double v58 = __stderrp;
      }
    }

    fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v58);
LABEL_108:
    id v23 = 0;
    *__error() = v42;
    goto LABEL_201;
  }

  return 0;
}

void sub_100070AB0(_Unwind_Exception *a1)
{
}

void sub_100070BC0(uint64_t a1, double a2, double a3, double a4, double a5)
{
  double v5 = *(double *)(a1 + 40);
  uint64_t v6 = *(void *)(a1 + 32);
  double v7 = *(double *)(v6 + 56);
  if (v5 + -1.0 > v7)
  {
    LODWORD(a5) = *(_DWORD *)(v6 + 68);
    if (v5 + 1.0 < v7 + (double)*(unint64_t *)&a5)
    {
      *(double *)(v6 + 56) = v5;
      id v9 = +[SAAuxiliaryData auxiliaryDataForTimestamp:]( &OBJC_CLASS___SAAuxiliaryData,  "auxiliaryDataForTimestamp:",  0LL);
      uint64_t v10 = *(void *)(a1 + 32);
      int v11 = *(dispatch_queue_s **)(v10 + 24);
      v12[0] = _NSConcreteStackBlock;
      v12[1] = 3221225472LL;
      v12[2] = sub_100070C74;
      v12[3] = &unk_1000D9B98;
      v12[4] = v10;
      v12[5] = v9;
      dispatch_async(v11, v12);
    }
  }

id sub_100070C74(uint64_t a1)
{
  return [*(id *)(*(void *)(a1 + 32) + 8) addAuxiliaryData:*(void *)(a1 + 40)];
}

void sub_100070DF4(_Unwind_Exception *a1)
{
}

void sub_100070E0C(uint64_t a1)
{
  if (qword_1000E7D00 == *(void *)(a1 + 32))
  {
    if (--dword_1000E7CF8)
    {
      if (byte_1000E7D30)
      {
        int v1 = *__error();
        int v2 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG)) {
          sub_10009355C();
        }
        *__error() = v1;
      }

      if (byte_1000E7D31) {
        BOOL v3 = dword_1000E74E0 <= 0;
      }
      else {
        BOOL v3 = 0;
      }
      if (!v3) {
        return;
      }
      int v4 = *__error();
      double v5 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"Stackshot provider shared instance not yet done");
      if (!v5)
      {
        uint64_t v6 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)) {
          sub_100093530();
        }
LABEL_36:
        if (qword_1000E7D38) {
          BOOL v16 = (FILE *)qword_1000E7D38;
        }
        else {
          BOOL v16 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v16);
LABEL_40:
        *__error() = v4;
        return;
      }

      goto LABEL_25;
    }

    qword_1000E7D00 = 0LL;
    if (byte_1000E7D30)
    {
      int v7 = *__error();
      dispatch_time_t v8 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG)) {
        sub_100093504();
      }
      *__error() = v7;
    }

    if (byte_1000E7D31) {
      BOOL v9 = dword_1000E74E0 <= 0;
    }
    else {
      BOOL v9 = 0;
    }
    if (v9)
    {
      int v4 = *__error();
      double v5 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"Stackshot provider shared instance done");
      if (!v5)
      {
        BOOL v15 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v15, OS_LOG_TYPE_FAULT)) {
          sub_1000934D8();
        }
        goto LABEL_36;
      }

uint64_t sub_100071128(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL))();
}

void sub_100071138(uint64_t a1)
{
  if (v2 + -1.0 > *(double *)(*(void *)(a1 + 40) + 56LL))
  {
    [*(id *)(a1 + 32) machAbsTimeSeconds];
    *(void *)(*(void *)(a1 + 40) + 56LL) = v3;
    id v4 = +[SAAuxiliaryData auxiliaryDataForTimestamp:](&OBJC_CLASS___SAAuxiliaryData, "auxiliaryDataForTimestamp:", 0LL);
    uint64_t v5 = *(void *)(a1 + 40);
    uint64_t v6 = *(dispatch_queue_s **)(v5 + 24);
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472LL;
    block[2] = sub_100071258;
    block[3] = &unk_1000D9B98;
    void block[4] = v5;
    void block[5] = v4;
    dispatch_async(v6, block);
  }

  int v7 = *(dispatch_queue_s **)(a1 + 48);
  if (v7)
  {
    uint64_t v8 = *(void *)(a1 + 56);
    if (v8)
    {
      v11[0] = _NSConcreteStackBlock;
      v11[1] = 3221225472LL;
      v11[2] = sub_100071264;
      v11[3] = &unk_1000D9BC0;
      uint64_t v10 = *(void *)(a1 + 32);
      uint64_t v9 = *(void *)(a1 + 40);
      v11[4] = v9;
      v11[5] = v10;
      v11[7] = *(void *)(a1 + 64);
      v11[6] = v8;
      if (*(_BYTE *)(a1 + 72)) {
        dispatch_group_notify(*(dispatch_group_t *)(v9 + 32), v7, v11);
      }
      else {
        dispatch_async(v7, v11);
      }
    }
  }

id sub_100071258(uint64_t a1)
{
  return [*(id *)(*(void *)(a1 + 32) + 8) addAuxiliaryData:*(void *)(a1 + 40)];
}

uint64_t sub_100071264(uint64_t a1)
{
  double v2 =  -[SPStackshotProviderSnapshot initWithStackshotProvider:timestamp:numSamples:numSamplesAvoidedDueToAudio:]( objc_alloc(&OBJC_CLASS___SPStackshotProviderSnapshot),  "initWithStackshotProvider:timestamp:numSamples:numSamplesAvoidedDueToAudio:",  *(void *)(a1 + 32),  *(void *)(a1 + 40),  *(unsigned int *)(a1 + 56),  *(unsigned int *)(a1 + 60));
  return (*(uint64_t (**)(void))(*(void *)(a1 + 48) + 16LL))();
}

uint64_t sub_10007130C(uint64_t a1)
{
  return (*(uint64_t (**)(void, void))(*(void *)(a1 + 40) + 16LL))( *(void *)(a1 + 40),  *(void *)(*(void *)(a1 + 32) + 8LL));
}

id sub_10007137C(uint64_t a1)
{
  return objc_msgSend( *(id *)(*(void *)(a1 + 32) + 120),  "addObject:",  +[NSNumber numberWithInt:](NSNumber, "numberWithInt:", *(unsigned int *)(a1 + 40)));
}

void sub_1000713C8(double *a1)
{
  uint64_t v1 = *((void *)a1 + 4);
  unsigned int v2 = *(_DWORD *)(v1 + 68);
  if (v2)
  {
    if (a1[6] > *(double *)(v1 + 56) + (double)v2)
    {
      id v4 = objc_autoreleasePoolPush();
      *(double *)(*((void *)a1 + 4) + 56LL) = a1[6];
      id v5 = +[SAAuxiliaryData auxiliaryDataForTimestamp:]( &OBJC_CLASS___SAAuxiliaryData,  "auxiliaryDataForTimestamp:",  0LL);
      uint64_t v7 = *((void *)a1 + 4);
      uint64_t v6 = (dispatch_group_s *)*((void *)a1 + 5);
      uint64_t v8 = *(dispatch_queue_s **)(v7 + 24);
      v9[0] = _NSConcreteStackBlock;
      v9[1] = 3221225472LL;
      v9[2] = sub_100071480;
      v9[3] = &unk_1000D9B98;
      v9[4] = v7;
      void v9[5] = v5;
      dispatch_group_async(v6, v8, v9);
      objc_autoreleasePoolPop(v4);
    }
  }

id sub_100071480(uint64_t a1)
{
  return [*(id *)(*(void *)(a1 + 32) + 8) addAuxiliaryData:*(void *)(a1 + 40)];
}

void sub_10007148C(id a1)
{
  uint64_t v1 = getenv("SPINDUMP_SAVE_STACKSHOTS");
  if (v1 && strcmp(v1, "0"))
  {
    strcpy(__filename, "/var/mobile/stackshots.");
    time_t v36 = time(0LL);
    localtime_r(&v36, &v37);
    size_t v2 = strftime(&__filename[23], 0x3E9uLL, "%Y-%m-%d-%T", &v37);
    size_t v3 = v2 + 23;
    if (v2 + 23 >= 0x400)
    {
      size_t v35 = v2;
      int v24 = *__error();
      uint64_t v25 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v25, OS_LOG_TYPE_FAULT)) {
        sub_1000937C4();
      }
      *__error() = v24;
      size_t v2 = v35;
      if (byte_1000E7D31 && dword_1000E74E0 <= 4)
      {
        int v26 = *__error();
        int v27 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"filePath %s cut off with date (needed %zu chars)",  __filename,  v3);
        if (v27)
        {
          uint64_t v28 = v27;
          CStringPtr = CFStringGetCStringPtr(v27, 0x8000100u);
          if (CStringPtr)
          {
            double v30 = (char *)CStringPtr;
            NSUInteger v31 = 0LL;
          }

          else
          {
            double v30 = (char *)calloc(0x400uLL, 1uLL);
            CFStringGetCString(v28, v30, 1024LL, 0x8000100u);
            NSUInteger v31 = v30;
          }

          if (qword_1000E7D38) {
            BOOL v34 = (FILE *)qword_1000E7D38;
          }
          else {
            BOOL v34 = __stderrp;
          }
          fprintf(v34, "%s\n", v30);
          if (v31) {
            free(v31);
          }
          CFRelease(v28);
        }

        else
        {
          NSUInteger v32 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v32, OS_LOG_TYPE_FAULT)) {
            sub_100093760();
          }
          if (qword_1000E7D38) {
            int v33 = (FILE *)qword_1000E7D38;
          }
          else {
            int v33 = __stderrp;
          }
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v33);
        }

        *__error() = v26;
        size_t v2 = v35;
      }
    }

    size_t v4 = 1001 - v2;
    pid_t v5 = getpid();
    snprintf(&__filename[v3], v4, ".%d.buf", v5);
    qword_1000E7D10 = (uint64_t)fopen(__filename, "w");
    if (qword_1000E7D10)
    {
      if (byte_1000E7D30)
      {
        int v6 = *__error();
        uint64_t v7 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136315138;
          __int128 v39 = __filename;
          _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Saving stackshots to %s", buf, 0xCu);
        }

        *__error() = v6;
      }

      if (byte_1000E7D31 && dword_1000E74E0 <= 2)
      {
        int v8 = *__error();
        uint64_t v9 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"Saving stackshots to %s", __filename);
        if (!v9)
        {
          uint64_t v10 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v10, OS_LOG_TYPE_FAULT)) {
            sub_1000936F8((uint64_t)__filename, v10, v11);
          }
LABEL_32:
          if (qword_1000E7D38) {
            id v23 = (FILE *)qword_1000E7D38;
          }
          else {
            id v23 = __stderrp;
          }
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v23);
LABEL_36:
          *__error() = v8;
          return;
        }

        goto LABEL_21;
      }
    }

    else
    {
      if (byte_1000E7D30)
      {
        int v12 = *__error();
        int v13 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR)) {
          sub_10009366C((uint64_t)__filename, v13);
        }
        *__error() = v12;
      }

      if (byte_1000E7D31 && dword_1000E74E0 <= 3)
      {
        int v8 = *__error();
        uint64_t v14 = *__error();
        BOOL v15 = __error();
        BOOL v16 = strerror(*v15);
        uint64_t v9 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"Unable to open %s to save stackshots: %d (%s)",  __filename,  v14,  v16);
        if (!v9)
        {
          int v22 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v22, OS_LOG_TYPE_FAULT)) {
            sub_1000935E0((uint64_t)__filename, v22);
          }
          goto LABEL_32;
        }

uint64_t sub_1000719BC(uint64_t a1)
{
  context = objc_autoreleasePoolPush();
  [*(id *)(*(void *)(a1 + 32) + 8) addKCDataStackshots:*(void *)(a1 + 40) createSeparateSamplePerStackshot:0];
  __int128 v47 = 0u;
  __int128 v48 = 0u;
  __int128 v49 = 0u;
  __int128 v50 = 0u;
  size_t v2 = *(void **)(*(void *)(a1 + 32) + 120LL);
  id v3 = [v2 countByEnumeratingWithState:&v47 objects:v55 count:16];
  if (!v3) {
    goto LABEL_58;
  }
  id v4 = v3;
  uint64_t v5 = *(void *)v48;
  do
  {
    for (uint64_t i = 0LL; i != v4; uint64_t i = (char *)i + 1)
    {
      if (*(void *)v48 != v5) {
        objc_enumerationMutation(v2);
      }
      uint64_t v7 = *(void **)(*((void *)&v47 + 1) + 8LL * (void)i);
      if ((objc_msgSend( *(id *)(*(void *)(a1 + 32) + 8),  "cacheLoadInfoForProcess:",  objc_msgSend(v7, "intValue")) & 1) == 0)
      {
        if (([v7 intValue] & 0x80000000) != 0)
        {
          if (byte_1000E7D30)
          {
            int v18 = *__error();
            BOOL v19 = (os_log_s *)sub_10002EFA0();
            if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR)) {
              sub_100093854(&v45, v46);
            }
            *__error() = v18;
          }

          if (byte_1000E7D31) {
            BOOL v20 = dword_1000E74E0 <= 3;
          }
          else {
            BOOL v20 = 0;
          }
          if (v20)
          {
            int v11 = *__error();
            int v21 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"Unable to cache load info");
            if (v21)
            {
              int v22 = v21;
              CStringPtr = CFStringGetCStringPtr(v21, 0x8000100u);
              if (CStringPtr)
              {
                int v24 = (char *)CStringPtr;
                uint64_t v25 = 0LL;
              }

              else
              {
                int v24 = (char *)calloc(0x400uLL, 1uLL);
                CFStringGetCString(v22, v24, 1024LL, 0x8000100u);
                uint64_t v25 = v24;
              }

              if (qword_1000E7D38) {
                int v33 = (FILE *)qword_1000E7D38;
              }
              else {
                int v33 = __stderrp;
              }
              fprintf(v33, "%s\n", v24);
              if (v25) {
                free(v25);
              }
              double v30 = v22;
LABEL_54:
              CFRelease(v30);
LABEL_55:
              *__error() = v11;
              continue;
            }

            NSUInteger v31 = (os_log_s *)sub_10002EFA0();
            if (os_log_type_enabled(v31, OS_LOG_TYPE_FAULT)) {
              sub_100093828(&v43, v44);
            }
LABEL_43:
            if (qword_1000E7D38) {
              NSUInteger v32 = (FILE *)qword_1000E7D38;
            }
            else {
              NSUInteger v32 = __stderrp;
            }
            fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v32);
            goto LABEL_55;
          }
        }

        else
        {
          if (byte_1000E7D30)
          {
            int v8 = *__error();
            uint64_t v9 = (os_log_s *)sub_10002EFA0();
            if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
            {
              BOOL v34 = sub_10002EF3C((int)[v7 intValue]);
              unsigned int v35 = [v7 intValue];
              *(_DWORD *)buf = 136446466;
              uint64_t v52 = v34;
              __int16 v53 = 1024;
              unsigned int v54 = v35;
              _os_log_error_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_ERROR,  "%{public}s [%d]: Unable to cache load info",  buf,  0x12u);
            }

            *__error() = v8;
          }

          if (byte_1000E7D31) {
            BOOL v10 = dword_1000E74E0 <= 3;
          }
          else {
            BOOL v10 = 0;
          }
          if (v10)
          {
            int v11 = *__error();
            int v12 = sub_10002EF3C((int)[v7 intValue]);
            int v13 = CFStringCreateWithFormat( kCFAllocatorDefault,  0,  @"%s [%d]: Unable to cache load info",  v12,  [v7 intValue]);
            if (v13)
            {
              uint64_t v14 = v13;
              BOOL v15 = CFStringGetCStringPtr(v13, 0x8000100u);
              if (v15)
              {
                BOOL v16 = (char *)v15;
                int v17 = 0LL;
              }

              else
              {
                BOOL v16 = (char *)calloc(0x400uLL, 1uLL);
                CFStringGetCString(v14, v16, 1024LL, 0x8000100u);
                int v17 = v16;
              }

              if (qword_1000E7D38) {
                int v29 = (FILE *)qword_1000E7D38;
              }
              else {
                int v29 = __stderrp;
              }
              fprintf(v29, "%s\n", v16);
              if (v17) {
                free(v17);
              }
              double v30 = v14;
              goto LABEL_54;
            }

            int v26 = (os_log_s *)sub_10002EFA0();
            if (os_log_type_enabled(v26, OS_LOG_TYPE_FAULT))
            {
              int v27 = sub_10002EF3C((int)[v7 intValue]);
              unsigned int v28 = [v7 intValue];
              *(_DWORD *)buf = 136315394;
              uint64_t v52 = v27;
              __int16 v53 = 1024;
              unsigned int v54 = v28;
              _os_log_fault_impl( (void *)&_mh_execute_header,  v26,  OS_LOG_TYPE_FAULT,  "Unable to format: %s [%d]: Unable to cache load info",  buf,  0x12u);
            }

            goto LABEL_43;
          }
        }
      }
    }

    id v4 = [v2 countByEnumeratingWithState:&v47 objects:v55 count:16];
  }

  while (v4);
LABEL_58:
  [*(id *)(*(void *)(a1 + 32) + 120) removeAllObjects];
  objc_autoreleasePoolPop(context);

  uint64_t v36 = *(void *)(a1 + 72);
  if (*(void *)(*(void *)(*(void *)(a1 + 56) + 8LL) + 24LL))
  {
    uint64_t result = stackshot_config_dealloc(v36);
  }

  else
  {
    uint64_t result = stackshot_config_dealloc_buffer(v36);
    *(void *)(*(void *)(*(void *)(a1 + 56) + 8LL) + 24LL) = *(void *)(a1 + 72);
  }

  if (*(void *)(a1 + 48))
  {
    uint64_t v38 = *(unsigned int *)(a1 + 80);
    __int128 v39 = (unint64_t *)(*(void *)(*(void *)(a1 + 64) + 8LL) + 24LL);
    do
      unint64_t v40 = __ldxr(v39);
    while (__stxr(v40 - v38, v39));
    uint64_t v41 = v40 - v38;
  }

  return result;
}

void sub_100071F50(id a1)
{
  if (byte_1000E7D30)
  {
    int v1 = *__error();
    size_t v2 = (os_log_s *)sub_10002EFA0();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR)) {
      sub_1000938AC();
    }
    *__error() = v1;
  }

  if (byte_1000E7D31) {
    BOOL v3 = dword_1000E74E0 <= 3;
  }
  else {
    BOOL v3 = 0;
  }
  if (v3)
  {
    int v4 = *__error();
    uint64_t v5 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"Unable to process samples fast enough, throttling sampling rate to avoid bloating memory. Use -noThrottle to avoid this.");
    if (v5)
    {
      int v6 = v5;
      CStringPtr = CFStringGetCStringPtr(v5, 0x8000100u);
      if (CStringPtr)
      {
        int v8 = (char *)CStringPtr;
        uint64_t v9 = 0LL;
      }

      else
      {
        int v8 = (char *)calloc(0x400uLL, 1uLL);
        CFStringGetCString(v6, v8, 1024LL, 0x8000100u);
        uint64_t v9 = v8;
      }

      if (qword_1000E7D38) {
        int v12 = (FILE *)qword_1000E7D38;
      }
      else {
        int v12 = __stderrp;
      }
      fprintf(v12, "%s\n", v8);
      if (v9) {
        free(v9);
      }
      CFRelease(v6);
    }

    else
    {
      BOOL v10 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_FAULT)) {
        sub_100093880();
      }
      if (qword_1000E7D38) {
        int v11 = (FILE *)qword_1000E7D38;
      }
      else {
        int v11 = __stderrp;
      }
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v11);
    }

    *__error() = v4;
  }

void sub_1000720F4(void *a1, os_log_s *a2, uint64_t a3, const char *a4, uint8_t *a5)
{
}

void sub_100072100(void *a1, int a2, os_log_t log, const char *a4, uint8_t *a5)
{
}

uint64_t sub_100072110(uint64_t result, uint64_t a2, int a3)
{
  *(void *)(a2 + 4) = v3;
  *(_WORD *)(a2 + 12) = 1024;
  *(_DWORD *)(a2 + 14) = a3;
  *(_WORD *)(a2 + 1_Block_object_dispose(va, 8) = 2080;
  *(void *)(a2 + 20) = result;
  return result;
}

id sub_100072130(uint64_t a1, void *a2)
{
  return [a2 intValue];
}

  ;
}

  ;
}

void sub_100072170(void *a1, os_log_s *a2, uint64_t a3, const char *a4, uint8_t *a5)
{
}

void sub_10007217C(uint64_t a1@<X8>)
{
  *(void *)(v1 - _Block_object_dispose(va, 8) = a1;
}

uint64_t sub_100072188@<X0>(uint64_t result@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  *(void *)(result + 4) = a3;
  *(_WORD *)(result + 12) = 2048;
  *(void *)(result + 14) = a2;
  return result;
}

void sub_10007219C(void *a1, os_log_s *a2, uint64_t a3, const char *a4, uint8_t *a5)
{
}

LABEL_113:
      double v57 = v22;
      double v58 = CFStringGetCStringPtr(v22, 0x8000100u);
      if (v58)
      {
        int v59 = (char *)v58;
        uint64_t v60 = 0LL;
      }

      else
      {
        int v59 = (char *)calloc(0x400uLL, 1uLL);
        CFStringGetCString(v57, v59, 1024LL, 0x8000100u);
        uint64_t v60 = v59;
      }

      if (qword_1000E7D38) {
        double v61 = (FILE *)qword_1000E7D38;
      }
      else {
        double v61 = __stderrp;
      }
      fprintf(v61, "%s\n", v59);
      if (v60) {
        free(v60);
      }
      CFRelease(v57);
      goto LABEL_128;
    }
  }

  return result;
}

id *sub_100072B04(uint64_t a1, void *a2, char a3, void *a4, void *a5, void *a6, void *a7)
{
  int v13 = (objc_class *)objc_opt_self();
  if (a4 && a7)
  {
    if (byte_1000E7D30)
    {
      int v20 = *__error();
      int v21 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR)) {
        sub_100093CE8(a4);
      }
      *__error() = v20;
    }

    if (byte_1000E7D31) {
      BOOL v22 = dword_1000E74E0 <= 3;
    }
    else {
      BOOL v22 = 0;
    }
    if (v22)
    {
      int v23 = *__error();
      int v24 = CFStringCreateWithFormat( kCFAllocatorDefault,  0,  @"%s: bodies (%s) and angle bracket contents (%s)",  "!(bodies && angleBracketContents)",  objc_msgSend(objc_msgSend(a4, "debugDescription"), "UTF8String"),  objc_msgSend(objc_msgSend(a7, "debugDescription"), "UTF8String"));
      if (v24)
      {
        theString = v24;
        CStringPtr = CFStringGetCStringPtr(v24, 0x8000100u);
        if (CStringPtr)
        {
          unsigned int v35 = (char *)CStringPtr;
          uint64_t v36 = 0LL;
        }

        else
        {
          unsigned int v35 = (char *)calloc(0x400uLL, 1uLL);
          CFStringGetCString(theString, v35, 1024LL, 0x8000100u);
          uint64_t v36 = v35;
        }

        if (qword_1000E7D38) {
          uint64_t v41 = (FILE *)qword_1000E7D38;
        }
        else {
          uint64_t v41 = __stderrp;
        }
        fprintf(v41, "%s\n", v35);
        if (v36) {
          free(v36);
        }
        CFRelease(theString);
      }

      else
      {
        uint64_t v25 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v25, OS_LOG_TYPE_FAULT)) {
          sub_100093C54(a4, (uint64_t)a7, v25);
        }
        if (qword_1000E7D38) {
          int v26 = (FILE *)qword_1000E7D38;
        }
        else {
          int v26 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v26);
      }

      *__error() = v23;
    }

    objc_msgSend(objc_msgSend(a4, "debugDescription"), "UTF8String");
    objc_msgSend(objc_msgSend(a7, "debugDescription"), "UTF8String");
    sub_10002EE78( "+[SPTreeNode nodeWithParent:isKernel:bodies:address:stateInfo:angleBracketContents:]",  "SPTextualReportParser.m",  69,  "%s: bodies (%s) and angle bracket contents (%s)",  v42,  v43,  v44,  v45,  (char)"!(bodies && angleBracketContents)");
LABEL_61:
    abort();
  }

  if (!a7 && !a6 && !a4)
  {
    if (byte_1000E7D30)
    {
      int v27 = *__error();
      unsigned int v28 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR)) {
        sub_100093DF0(v28);
      }
      *__error() = v27;
    }

    if (byte_1000E7D31) {
      BOOL v29 = dword_1000E74E0 <= 3;
    }
    else {
      BOOL v29 = 0;
    }
    if (v29)
    {
      int v30 = *__error();
      NSUInteger v31 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"%s: No frame bodies, state, nor angle bracket contents",  "bodies || angleBracketContents || stateInfo");
      if (v31)
      {
        tm v37 = v31;
        uint64_t v38 = CFStringGetCStringPtr(v31, 0x8000100u);
        if (v38)
        {
          __int128 v39 = (char *)v38;
          unint64_t v40 = 0LL;
        }

        else
        {
          __int128 v39 = (char *)calloc(0x400uLL, 1uLL);
          CFStringGetCString(v37, v39, 1024LL, 0x8000100u);
          unint64_t v40 = v39;
        }

        if (qword_1000E7D38) {
          id v46 = (FILE *)qword_1000E7D38;
        }
        else {
          id v46 = __stderrp;
        }
        fprintf(v46, "%s\n", v39);
        if (v40) {
          free(v40);
        }
        CFRelease(v37);
      }

      else
      {
        NSUInteger v32 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v32, OS_LOG_TYPE_FAULT)) {
          sub_100093D74(v32);
        }
        if (qword_1000E7D38) {
          int v33 = (FILE *)qword_1000E7D38;
        }
        else {
          int v33 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v33);
      }

      *__error() = v30;
    }

    sub_10002EE78( "+[SPTreeNode nodeWithParent:isKernel:bodies:address:stateInfo:angleBracketContents:]",  "SPTextualReportParser.m",  70,  "%s: No frame bodies, state, nor angle bracket contents",  v14,  v15,  v16,  v17,  (char)"bodies || angleBracketContents || stateInfo");
    goto LABEL_61;
  }

  int v18 = (id *)objc_alloc_init(v13);
  objc_storeWeak(v18 + 7, a2);
  *((_BYTE *)v18 + _Block_object_dispose(va, 8) = a3;
  v18[2] = [a4 copy];
  v18[4] = a5;
  v18[5] = [a6 copy];
  v18[3] = [a7 copy];
  return v18;
}

id *sub_100072FB0(uint64_t a1, int a2, void *a3, void *a4, void *a5, void *a6)
{
  if (!a1) {
    return 0LL;
  }
  int v11 = (id *)a1;
  int v12 = *(void **)(a1 + 48);
  if (!v12)
  {
    *(void *)(a1 + 4_Block_object_dispose(va, 8) = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
    goto LABEL_13;
  }

  __int128 v22 = 0u;
  __int128 v23 = 0u;
  __int128 v20 = 0u;
  __int128 v21 = 0u;
  id v13 = [v12 countByEnumeratingWithState:&v20 objects:v24 count:16];
  if (!v13)
  {
LABEL_13:
    uint64_t v17 = sub_100072B04((uint64_t)&OBJC_CLASS___SPTreeNode, v11, a2, a3, a4, a5, a6);
    [v11[6] addObject:v17];
    return v17;
  }

  id v14 = v13;
  uint64_t v15 = *(void *)v21;
  BOOL v19 = v11;
LABEL_5:
  uint64_t v16 = 0LL;
  while (1)
  {
    if (*(void *)v21 != v15) {
      objc_enumerationMutation(v12);
    }
    uint64_t v17 = *(id **)(*((void *)&v20 + 1) + 8 * v16);
    if (v14 == (id)++v16)
    {
      id v14 = [v12 countByEnumeratingWithState:&v20 objects:v24 count:16];
      int v11 = v19;
      if (v14) {
        goto LABEL_5;
      }
      goto LABEL_13;
    }
  }

uint64_t sub_100073138(uint64_t result, int a2, void *a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if (result)
  {
    uint64_t v6 = result;
    if (*(unsigned __int8 *)(result + 8) == a2 && *(void *)(result + 32) == a4)
    {
      uint64_t v9 = *(void *)(result + 40);
      if (!(a5 | v9)
        || (uint64_t result = 0LL, a5)
        && v9
        && (uint64_t result = (uint64_t)[*(id *)(v6 + 40) isEqualToString:a5], (_DWORD)result))
      {
        uint64_t v10 = *(void *)(v6 + 24);
        if (!(a6 | v10)
          || (uint64_t result = 0LL, a6)
          && v10
          && (uint64_t result = (uint64_t)[*(id *)(v6 + 24) isEqualToString:a6], (_DWORD)result))
        {
          if (*(void *)(v6 + 32) == -1LL) {
            return 1LL;
          }
          unint64_t v11 = (unint64_t)[*(id *)(v6 + 16) firstObject];
          unint64_t v12 = (unint64_t)[a3 firstObject];
          if (!(v11 | v12)) {
            return 1LL;
          }
          unint64_t v13 = v12;
          uint64_t result = 0LL;
          if (v11)
          {
            if (v13)
            {
              uint64_t result = (uint64_t)objc_msgSend((id)v11, "isEqualToString:");
              if ((_DWORD)result) {
                return 1LL;
              }
            }
          }
        }
      }
    }

    else
    {
      return 0LL;
    }
  }

  return result;
}

uint64_t sub_100073314(uint64_t result)
{
  if (result) {
    return *(unsigned int *)(result + 12);
  }
  return result;
}

uint64_t sub_100073320(uint64_t result, int a2)
{
  if (result) {
    *(_DWORD *)(result + 12) = a2;
  }
  return result;
}

uint64_t sub_10007332C(uint64_t result)
{
  if (result) {
    return *(_BYTE *)(result + 8) & 1;
  }
  return result;
}

uint64_t sub_10007333C(uint64_t result)
{
  if (result) {
    return *(void *)(result + 16);
  }
  return result;
}

uint64_t sub_100073348(uint64_t result)
{
  if (result) {
    return *(void *)(result + 24);
  }
  return result;
}

uint64_t sub_100073354(uint64_t result)
{
  if (result) {
    return *(void *)(result + 32);
  }
  return result;
}

uint64_t sub_100073360(uint64_t result)
{
  if (result) {
    return *(void *)(result + 40);
  }
  return result;
}

uint64_t sub_10007336C(uint64_t result)
{
  if (result) {
    return *(void *)(result + 48);
  }
  return result;
}

id *sub_100073378(id *result)
{
  if (result) {
    return (id *)objc_loadWeak(result + 7);
  }
  return result;
}

void *sub_100073390( void *a1, void *a2, char a3, uint64_t a4, uint64_t a5, void *a6, void *a7, void *a8, void *a9)
{
  if (!a1) {
    return 0LL;
  }
  v18.receiver = a1;
  v18.super_class = (Class)&OBJC_CLASS___SPLoadInfo;
  uint64_t v16 = objc_msgSendSuper2(&v18, "init");
  if (v16)
  {
    void v16[5] = a2;
    *((_BYTE *)v16 + 32) = a3;
    v16[7] = a4;
    void v16[8] = a5;
    v16[1] = [a6 copy];
    v16[2] = [a7 copy];
    v16[3] = [a8 copy];
    v16[6] = [a9 copy];
  }

  return v16;
}

id *sub_100073524(id *result)
{
  if (result)
  {
    uint64_t v1 = result;
    uint64_t result = (id *)[result[5] bundleIdentifier];
    if (!result) {
      return (id *)v1[1];
    }
  }

  return result;
}

id *sub_100073554(id *result)
{
  if (result)
  {
    uint64_t v1 = result;
    uint64_t result = (id *)[result[5] name];
    if (!result) {
      return (id *)v1[2];
    }
  }

  return result;
}

void *sub_100073584(uint64_t a1)
{
  if (!a1) {
    return 0LL;
  }
  size_t v2 = *(void **)(a1 + 24);
  if (!v2)
  {
    unint64_t v3 = (unint64_t)[*(id *)(a1 + 40) bundleVersion];
    id v4 = [*(id *)(a1 + 40) bundleShortVersion];
    id v5 = [*(id *)(a1 + 40) binaryVersion];
    unint64_t v6 = (unint64_t)v5;
    if (!v4 && !v3 && !v5) {
      return 0LL;
    }
    id v7 = +[NSMutableString string](&OBJC_CLASS___NSMutableString, "string");
    size_t v2 = v7;
    if (v4)
    {
      [v7 appendString:v4];
      if (!(v3 | v6)) {
        return v2;
      }
      [v2 appendString:@" "];
    }

    if (v3 | v6)
    {
      if (v3) {
        unint64_t v8 = v3;
      }
      else {
        unint64_t v8 = v6;
      }
      [v2 appendFormat:@"(%@)", v8];
    }
  }

  return v2;
}

uint64_t sub_10007365C(uint64_t result)
{
  if (result) {
    return *(_BYTE *)(result + 32) & 1;
  }
  return result;
}

uint64_t sub_10007366C(uint64_t result)
{
  if (result) {
    return *(void *)(result + 56);
  }
  return result;
}

uint64_t sub_100073678(uint64_t result)
{
  if (result) {
    return *(void *)(result + 64);
  }
  return result;
}

LABEL_787:
    id obj = 0LL;
    v657 = 0LL;
    goto LABEL_807;
  }

  if (v654) {
    char v66 = @"^(?<indentCount>\\d+)(?<kernelDot>\\*)?\\s+(?<count>\\d+)\\s+(?:(?<binaryIndex>\\d+)\\s+\\+\\s+(?<offsetIntoBinary>\\d+)|\\?\\?\\?)$";
  }
  else {
    char v66 = @"^(?<indentWhitespace> +(?<kernelDot>\\*)?)(?<countAndWhitespace>(?<count>\\d+)\\s+)(?:\\?\\?\\?(?:\\s+\\+\\s+(?<offsetIntoUnknownSymbol>\\d+))?|(?<symbolName>.*?)\\s+\\+\\s+(?<offsetIntoSymbol>\\d+))(?:\\s+\\((?:(?<sourceFilepath>.+?)(?::(?<sourceLineNumber>\\d+)(?:[:\\.,](?<sourceColumnNumber>\\d+))?)?\\s+in\\s+)?(?:<(?<binaryUuid>[\\dabcdef\\-]{32,36})>|(?<binaryName>.+?))\\s+\\+\\s+(?<offsetIntoBinary>\\d+)\\))?(?:\\s+\\[(?<address>(?:0x)?[\\dabcdef]+)\\])?(?:\\s+\\((?<stateInfo>.+?)\\))?(?:\\s+(?<startIndex>\\d+)(?:\\s*-\\s*(?<endIndex>\\d+))?)?$";
  }
  v697 = 0LL;
  int v67 = -[NSRegularExpression initWithPattern:options:error:]( objc_alloc(&OBJC_CLASS___NSRegularExpression),  "initWithPattern:options:error:",  v66,  1LL,  &v697);
  if (!v67)
  {
    if (byte_1000E7D30)
    {
      uint64_t v456 = *__error();
      uint64_t v457 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v457, OS_LOG_TYPE_ERROR))
      {
        -[__CFString UTF8String](v66, "UTF8String");
        objc_msgSend(objc_msgSend(v697, "debugDescription"), "UTF8String");
        sub_100094060();
      }

      *__error() = v456;
    }

    if (byte_1000E7D31 && dword_1000E74E0 <= 3)
    {
      v406 = *__error();
      v407 = -[__CFString UTF8String](v66, "UTF8String");
      v408 = CFStringCreateWithFormat( kCFAllocatorDefault,  0,  @"%s: Unable to compile regex %s: %s",  "regex",  v407,  objc_msgSend(objc_msgSend(v697, "debugDescription"), "UTF8String"));
      v409 = v408;
      if (v408)
      {
        v555 = (char *)CFStringGetCStringPtr(v408, 0x8000100u);
        if (v555)
        {
          v556 = 0LL;
        }

        else
        {
          v555 = (char *)calloc(0x400uLL, 1uLL);
          CFStringGetCString(v409, v555, 1024LL, 0x8000100u);
          v556 = v555;
        }

        if (qword_1000E7D38) {
          v569 = (FILE *)qword_1000E7D38;
        }
        else {
          v569 = __stderrp;
        }
        fprintf(v569, "%s\n", v555);
        if (v556) {
          free(v556);
        }
        CFRelease(v409);
      }

      else
      {
        int v410 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v410, OS_LOG_TYPE_FAULT))
        {
          -[__CFString UTF8String](v66, "UTF8String");
          objc_msgSend(objc_msgSend(v697, "debugDescription"), "UTF8String");
          sub_10009401C();
        }

        if (qword_1000E7D38) {
          v411 = (FILE *)qword_1000E7D38;
        }
        else {
          v411 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v411);
      }

      *__error() = v406;
    }

    -[__CFString UTF8String](v66, "UTF8String");
    objc_msgSend(objc_msgSend(v697, "debugDescription"), "UTF8String");
    sub_10002EE78( "CallTreeFrameLineRegex",  "SPTextualReportParser.m",  1858,  "%s: Unable to compile regex %s: %s",  v570,  v571,  v572,  v573,  (char)"regex");
LABEL_1042:
    abort();
  }

  v643 = v67;
  if (v654) {
    int v68 = @"^(?<indentCount>\\d+)(?<kernelDot>\\*)?\\s+(?<count>\\d+)\\s+(?:state\\s+(?<stateInfo>(?:0x)?[\\dabcdef]+)|<(?<angleBracketContents>.*)>|(?<otherInfo>[^<\\s\\d].*))$";
  }
  else {
    int v68 = @"^(?<indentWhitespace> +(?<kernelDot>\\*)?)(?<countAndWhitespace>(?<count>\\d+)\\s+)?<(?<angleBracketContents>.*)>(?:\\s+\\((?<stateInfo>.+?)\\))?(?:\\s+(?<startIndex>\\d+)(?:\\s*-\\s*(?<endIndex>\\d+))?)?$";
  }
  v697 = 0LL;
  int v69 = -[NSRegularExpression initWithPattern:options:error:]( objc_alloc(&OBJC_CLASS___NSRegularExpression),  "initWithPattern:options:error:",  v68,  1LL,  &v697);
  if (!v69)
  {
    if (byte_1000E7D30)
    {
      uint64_t v458 = *__error();
      uint64_t v459 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v459, OS_LOG_TYPE_ERROR)) {
        sub_1000940EC((uint64_t)-[__CFString UTF8String](v68, "UTF8String"), buf);
      }
      *__error() = v458;
    }

    if (byte_1000E7D31 && dword_1000E74E0 <= 3)
    {
      v412 = *__error();
      v413 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"%s: Unable to compile regex %s",  "regex",  -[__CFString UTF8String](v68, "UTF8String"));
      v414 = v413;
      if (v413)
      {
        id v522 = (char *)CFStringGetCStringPtr(v413, 0x8000100u);
        if (v522)
        {
          v523 = 0LL;
        }

        else
        {
          id v522 = (char *)calloc(0x400uLL, 1uLL);
          CFStringGetCString(v414, v522, 1024LL, 0x8000100u);
          v523 = v522;
        }

        if (qword_1000E7D38) {
          v546 = (FILE *)qword_1000E7D38;
        }
        else {
          v546 = __stderrp;
        }
        fprintf(v546, "%s\n", v522);
        if (v523) {
          free(v523);
        }
        CFRelease(v414);
      }

      else
      {
        v415 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v415, OS_LOG_TYPE_FAULT)) {
          sub_1000940AC((uint64_t)-[__CFString UTF8String](v68, "UTF8String"), v702);
        }
        if (qword_1000E7D38) {
          int v416 = (FILE *)qword_1000E7D38;
        }
        else {
          int v416 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v416);
      }

      *__error() = v412;
    }

    -[__CFString UTF8String](v68, "UTF8String");
    unint64_t v551 = 1921;
    unint64_t v552 = "CallTreeNonFrameLineRegex";
    goto LABEL_1041;
  }

  id v621 = v69;
  if (v654) {
    uint64_t v70 = @"^(?<binaryIndex>\\d+)\\t(?<kernelDot>\\*)?(?<bundleIdentifier>\\S+)?\\t(?<version>.+?)?\\t<(?<binaryUuid>[\\dabcdef\\-]{32,36})>\\t(?<segmentName>\\S+?)?\\t(?<binaryPath>.+?)?$";
  }
  else {
    uint64_t v70 = @"^\\s*(?<kernelDot>\\*)?(?:(?<startAddress>(?:0x)?[\\dabcdef]+)|\\?\\?\\?)\\s*\\-\\s*(?:(?<endAddress>(?:0x)?[\\dabcdef]+)|\\?\\?\\?)\\s*(?:\\?\\?\\?|(?<bundleIdentifier>\\S+\\.\\S+\\.\\S+)|(?<name>.+?\\b))\\s+(?<version>(?:\\d[\\S]*?)?(?:\\s*\\(\\S+?\\)))?\\s*<(?<binaryUuid>[\\dabcdef\\-]{32,36})>(?<segmentName>\\S+?)?(?:\\s+(?<binaryPath>.+?)?)?$";
  }
  v697 = 0LL;
  id v71 = -[NSRegularExpression initWithPattern:options:error:]( objc_alloc(&OBJC_CLASS___NSRegularExpression),  "initWithPattern:options:error:",  v70,  1LL,  &v697);
  if (!v71)
  {
    if (byte_1000E7D30)
    {
      int v460 = *__error();
      v461 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v461, OS_LOG_TYPE_ERROR)) {
        sub_1000940EC((uint64_t)-[__CFString UTF8String](v70, "UTF8String"), buf);
      }
      *__error() = v460;
    }

    if (byte_1000E7D31 && dword_1000E74E0 <= 3)
    {
      v417 = *__error();
      int v418 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"%s: Unable to compile regex %s",  "regex",  -[__CFString UTF8String](v70, "UTF8String"));
      v419 = v418;
      if (v418)
      {
        uint64_t v524 = (char *)CFStringGetCStringPtr(v418, 0x8000100u);
        if (v524)
        {
          v525 = 0LL;
        }

        else
        {
          uint64_t v524 = (char *)calloc(0x400uLL, 1uLL);
          CFStringGetCString(v419, v524, 1024LL, 0x8000100u);
          v525 = v524;
        }

        if (qword_1000E7D38) {
          uint64_t v553 = (FILE *)qword_1000E7D38;
        }
        else {
          uint64_t v553 = __stderrp;
        }
        fprintf(v553, "%s\n", v524);
        if (v525) {
          free(v525);
        }
        CFRelease(v419);
      }

      else
      {
        v420 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v420, OS_LOG_TYPE_FAULT)) {
          sub_1000940AC((uint64_t)-[__CFString UTF8String](v70, "UTF8String"), v702);
        }
        if (qword_1000E7D38) {
          v421 = (FILE *)qword_1000E7D38;
        }
        else {
          v421 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v421);
      }

      *__error() = v417;
    }

    -[__CFString UTF8String](v70, "UTF8String");
    unint64_t v551 = 2000;
    unint64_t v552 = "LoadInfoLineRegex";
    goto LABEL_1041;
  }

  id v618 = v71;
  v697 = 0LL;
  int v72 = -[NSRegularExpression initWithPattern:options:error:]( objc_alloc(&OBJC_CLASS___NSRegularExpression),  "initWithPattern:options:error:",  @"^UUID:(?<whitespace>\\s*)(?:<?(?<binaryUuid>[\\dabcdef\\-]{32,36})>?|(?<binaryIndex>\\d+))$",  1LL,  &v697);
  if (!v72)
  {
    if (byte_1000E7D30)
    {
      int v462 = *__error();
      v463 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v463, OS_LOG_TYPE_ERROR)) {
        sub_1000940EC( (uint64_t)[@"^UUID:(?<whitespace>\\s*)(?:<?(?<binaryUuid>[\\dabcdef\\-]{32,36})>?|(?<binaryIndex>\\d+))$" UTF8String],  buf);
      }
      *__error() = v462;
    }

    if (byte_1000E7D31 && dword_1000E74E0 <= 3)
    {
      v422 = *__error();
      v423 = CFStringCreateWithFormat( kCFAllocatorDefault,  0,  @"%s: Unable to compile regex %s",  "regex",  [@"^UUID:(?<whitespace>\\s*)(?:<?(?<binaryUuid>[\\dabcdef\\-]{32,36})>?|(?<binaryIndex>\\d+))$" UTF8String]);
      int v424 = v423;
      if (v423)
      {
        v526 = (char *)CFStringGetCStringPtr(v423, 0x8000100u);
        if (v526)
        {
          id v527 = 0LL;
        }

        else
        {
          v526 = (char *)calloc(0x400uLL, 1uLL);
          CFStringGetCString(v424, v526, 1024LL, 0x8000100u);
          id v527 = v526;
        }

        if (qword_1000E7D38) {
          v554 = (FILE *)qword_1000E7D38;
        }
        else {
          v554 = __stderrp;
        }
        fprintf(v554, "%s\n", v526);
        if (v527) {
          free(v527);
        }
        CFRelease(v424);
      }

      else
      {
        int v425 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v425, OS_LOG_TYPE_FAULT)) {
          sub_1000940AC( (uint64_t)[@"^UUID:(?<whitespace>\\s*)(?:<?(?<binaryUuid>[\\dabcdef\\-]{32,36})>?|(?<binaryIndex>\\d+))$" UTF8String],  v702);
        }
        if (qword_1000E7D38) {
          v426 = (FILE *)qword_1000E7D38;
        }
        else {
          v426 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v426);
      }

      *__error() = v422;
    }

    [@"^UUID:(?<whitespace>\\s*)(?:<?(?<binaryUuid>[\\dabcdef\\-]{32,36})>?|(?<binaryIndex>\\d+))$" UTF8String];
    unint64_t v551 = 2026;
    unint64_t v552 = "UUIDLineRegex";
LABEL_1041:
    sub_10002EE78( v552,  "SPTextualReportParser.m",  v551,  "%s: Unable to compile regex %s",  v547,  v548,  v549,  v550,  (char)"regex");
    goto LABEL_1042;
  }

  id v612 = v72;
  v683 = 0;
  if (v654)
  {
    v681 = 2;
    v682 = 2;
    char v73 = 1;
    v683 = 1;
  }

  else
  {
    v681 = -1;
    v682 = -1;
    *(void *)buf = _NSConcreteStackBlock;
    *(void *)&uint8_t buf[8] = 3221225472LL;
    *(void *)&uint8_t buf[16] = sub_10007F7E0;
    *(void *)&uint8_t buf[24] = &unk_1000D9E18;
    *(void *)&_BYTE buf[32] = v643;
    *(void *)&buf[40] = &v683;
    *(void *)&buf[48] = &v681;
    v704 = &v682;
    sub_10007C8F8(v14, 0, (uint64_t)buf);
    if (v681 <= 0)
    {
      if (byte_1000E7D30)
      {
        BOOL v76 = *__error();
        uint64_t v77 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v77, OS_LOG_TYPE_INFO))
        {
          *(_WORD *)buf = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v77,  OS_LOG_TYPE_INFO,  "Parsing spindump text: Unable to detect initial indentation, using 2",  buf,  2u);
        }

        *__error() = v76;
      }

      if (byte_1000E7D31 && dword_1000E74E0 <= 1)
      {
        uint64_t v78 = *__error();
        int v79 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"Parsing spindump text: Unable to detect initial indentation, using 2");
        int v80 = v79;
        if (v79)
        {
          int v81 = (char *)CFStringGetCStringPtr(v79, 0x8000100u);
          if (v81)
          {
            int v82 = 0LL;
          }

          else
          {
            int v81 = (char *)calloc(0x400uLL, 1uLL);
            CFStringGetCString(v80, v81, 1024LL, 0x8000100u);
            int v82 = v81;
          }

          if (qword_1000E7D38) {
            int v97 = (FILE *)qword_1000E7D38;
          }
          else {
            int v97 = __stderrp;
          }
          fprintf(v97, "%s\n", v81);
          if (v82) {
            free(v82);
          }
          CFRelease(v80);
        }

        else
        {
          int v95 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v95, OS_LOG_TYPE_FAULT)) {
            sub_1000944D0();
          }
          if (qword_1000E7D38) {
            int v96 = (FILE *)qword_1000E7D38;
          }
          else {
            int v96 = __stderrp;
          }
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v96);
        }

        *__error() = v78;
      }

      v681 = 2;
    }

    if (v682 <= 0)
    {
      if (byte_1000E7D30)
      {
        double v98 = *__error();
        int v99 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v99, OS_LOG_TYPE_INFO))
        {
          *(_WORD *)buf = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v99,  OS_LOG_TYPE_INFO,  "Parsing spindump text: Unable to detect incremental indentation, using 2",  buf,  2u);
        }

        *__error() = v98;
      }

      if (byte_1000E7D31 && dword_1000E74E0 <= 1)
      {
        id v100 = *__error();
        int v101 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"Parsing spindump text: Unable to detect incremental indentation, using 2");
        __int16 v102 = v101;
        if (v101)
        {
          int v103 = (char *)CFStringGetCStringPtr(v101, 0x8000100u);
          if (v103)
          {
            __int16 v104 = 0LL;
          }

          else
          {
            int v103 = (char *)calloc(0x400uLL, 1uLL);
            CFStringGetCString(v102, v103, 1024LL, 0x8000100u);
            __int16 v104 = v103;
          }

          if (qword_1000E7D38) {
            uint64_t v107 = (FILE *)qword_1000E7D38;
          }
          else {
            uint64_t v107 = __stderrp;
          }
          fprintf(v107, "%s\n", v103);
          if (v104) {
            free(v104);
          }
          CFRelease(v102);
        }

        else
        {
          double v105 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v105, OS_LOG_TYPE_FAULT)) {
            sub_1000944A4();
          }
          if (qword_1000E7D38) {
            uint64_t v106 = (FILE *)qword_1000E7D38;
          }
          else {
            uint64_t v106 = __stderrp;
          }
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v106);
        }

        *__error() = v100;
      }

      v682 = 2;
    }

    char v73 = v683;
  }

  if (!self->_isHeavy && v73)
  {
    if (byte_1000E7D30)
    {
      uint64_t v108 = *__error();
      uint64_t v109 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v109, OS_LOG_TYPE_ERROR)) {
        sub_100094478();
      }
      *__error() = v108;
    }

    __int128 v21 = 0;
    __int128 v22 = 0LL;
    if (!byte_1000E7D31) {
      goto LABEL_787;
    }
    id obj = 0LL;
    v657 = 0LL;
    if (dword_1000E74E0 > 3) {
      goto LABEL_807;
    }
    __int128 v23 = *__error();
    uint64_t v110 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"Parsing spindump text: Original report is not in timeline mode, so unable to output timeline mode");
    uint64_t v111 = v110;
    if (v110)
    {
      uint64_t v112 = (char *)CFStringGetCStringPtr(v110, 0x8000100u);
      if (v112)
      {
        int v113 = 0LL;
      }

      else
      {
        uint64_t v112 = (char *)calloc(0x400uLL, 1uLL);
        CFStringGetCString(v111, v112, 1024LL, 0x8000100u);
        int v113 = v112;
      }

      if (qword_1000E7D38) {
        id v129 = (FILE *)qword_1000E7D38;
      }
      else {
        id v129 = __stderrp;
      }
      fprintf(v129, "%s\n", v112);
      if (v113) {
        free(v113);
      }
LABEL_804:
      CFRelease(v111);
      goto LABEL_805;
    }

    int v127 = (os_log_s *)sub_10002EFA0();
    if (os_log_type_enabled(v127, OS_LOG_TYPE_FAULT)) {
      sub_10009444C();
    }
    if (qword_1000E7D38) {
      uint64_t v128 = (FILE *)qword_1000E7D38;
    }
    else {
      uint64_t v128 = __stderrp;
    }
    goto LABEL_246;
  }

  startIndex = self->_startIndex;
  if (v73)
  {
    if (startIndex || self->_endIndex)
    {
      if (byte_1000E7D30)
      {
        int v115 = *__error();
        int v116 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v116, OS_LOG_TYPE_ERROR)) {
          sub_100094420();
        }
        *__error() = v115;
      }

      __int128 v21 = 0;
      __int128 v22 = 0LL;
      if (!byte_1000E7D31) {
        goto LABEL_787;
      }
      id obj = 0LL;
      v657 = 0LL;
      if (dword_1000E74E0 > 3) {
        goto LABEL_807;
      }
      __int128 v23 = *__error();
      unsigned int v117 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"Parsing spindump text: Original report is not in timeline mode, so unable to filter to start/end indexes");
      uint64_t v111 = v117;
      if (v117)
      {
        id v118 = (char *)CFStringGetCStringPtr(v117, 0x8000100u);
        if (v118)
        {
          unsigned __int8 v119 = 0LL;
        }

        else
        {
          id v118 = (char *)calloc(0x400uLL, 1uLL);
          CFStringGetCString(v111, v118, 1024LL, 0x8000100u);
          unsigned __int8 v119 = v118;
        }

        if (qword_1000E7D38) {
          id v133 = (FILE *)qword_1000E7D38;
        }
        else {
          id v133 = __stderrp;
        }
        fprintf(v133, "%s\n", v118);
        if (v119) {
          free(v119);
        }
        goto LABEL_804;
      }

      uint64_t v130 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v130, OS_LOG_TYPE_FAULT)) {
        sub_1000943F4();
      }
      if (qword_1000E7D38) {
        uint64_t v128 = (FILE *)qword_1000E7D38;
      }
      else {
        uint64_t v128 = __stderrp;
      }
LABEL_246:
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v128);
LABEL_805:
      int v65 = __error();
      goto LABEL_806;
    }
  }

  else if (startIndex)
  {
LABEL_220:
    if (byte_1000E7D30)
    {
      id v120 = *__error();
      id v121 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v121, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v121,  OS_LOG_TYPE_DEFAULT,  "Parsing spindump text: Stacks will be filtered to the sample index range specified, but process and thread sum mary information and timestamps will still reflect full time range",  buf,  2u);
      }

      *__error() = v120;
    }

    if (byte_1000E7D31 && dword_1000E74E0 <= 2)
    {
      int v122 = *__error();
      uint64_t v123 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"Parsing spindump text: Stacks will be filtered to the sample index range specified, but process and thread summary information and timestamps will still reflect full time range");
      char v124 = v123;
      if (v123)
      {
        int v125 = (char *)CFStringGetCStringPtr(v123, 0x8000100u);
        if (v125)
        {
          char v126 = 0LL;
        }

        else
        {
          int v125 = (char *)calloc(0x400uLL, 1uLL);
          CFStringGetCString(v124, v125, 1024LL, 0x8000100u);
          char v126 = v125;
        }

        if (qword_1000E7D38) {
          uint64_t v134 = (FILE *)qword_1000E7D38;
        }
        else {
          uint64_t v134 = __stderrp;
        }
        fprintf(v134, "%s\n", v125);
        if (v126) {
          free(v126);
        }
        CFRelease(v124);
      }

      else
      {
        uint64_t v131 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v131, OS_LOG_TYPE_FAULT)) {
          sub_1000943C8();
        }
        if (qword_1000E7D38) {
          uint64_t v132 = (FILE *)qword_1000E7D38;
        }
        else {
          uint64_t v132 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v132);
      }

      *__error() = v122;
    }

    goto LABEL_268;
  }

  if (self->_endIndex) {
    goto LABEL_220;
  }
LABEL_268:
  if (self->_symbolicate)
  {
    if (byte_1000E7D30)
    {
      uint64_t v135 = *__error();
      integer_t v136 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v136, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v136,  OS_LOG_TYPE_DEFAULT,  "Parsing spindump text: Symbolicating...",  buf,  2u);
      }

      *__error() = v135;
    }

    if (byte_1000E7D31 && dword_1000E74E0 <= 2)
    {
      uint64_t v137 = *__error();
      uint64_t v138 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"Parsing spindump text: Symbolicating...");
      uint64_t v139 = v138;
      if (v138)
      {
        int v140 = (char *)CFStringGetCStringPtr(v138, 0x8000100u);
        if (v140)
        {
          __int16 v141 = 0LL;
        }

        else
        {
          int v140 = (char *)calloc(0x400uLL, 1uLL);
          CFStringGetCString(v139, v140, 1024LL, 0x8000100u);
          __int16 v141 = v140;
        }

        if (qword_1000E7D38) {
          int v144 = (FILE *)qword_1000E7D38;
        }
        else {
          int v144 = __stderrp;
        }
        fprintf(v144, "%s\n", v140);
        if (v141) {
          free(v141);
        }
        CFRelease(v139);
      }

      else
      {
        uint64_t v142 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v142, OS_LOG_TYPE_FAULT)) {
          sub_10009439C();
        }
        if (qword_1000E7D38) {
          uint64_t v143 = (FILE *)qword_1000E7D38;
        }
        else {
          uint64_t v143 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v143);
      }

      *__error() = v137;
    }

    sub_10007A048( v14,  (uint64_t)v643,  (uint64_t)v618,  v654,  self->_useDsymForUUIDForEverything,  (uint64_t)self->_findDsymsForIDs);
  }

  v657 = sub_10007A220(v14, 0, (uint64_t)v618, v654);
  if (!v657)
  {
    if (byte_1000E7D30)
    {
      id v397 = *__error();
      NSUInteger v398 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v398, OS_LOG_TYPE_ERROR)) {
        sub_100094158();
      }
      *__error() = v397;
    }

    __int128 v21 = 0;
    __int128 v22 = 0LL;
    if (!byte_1000E7D31) {
      goto LABEL_787;
    }
    id obj = 0LL;
    v657 = 0LL;
    if (dword_1000E74E0 > 3) {
      goto LABEL_807;
    }
    __int128 v23 = *__error();
    v399 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"Parsing spindump text: Unable to find any Binary Images");
    uint64_t v111 = v399;
    if (v399)
    {
      uint64_t v400 = (char *)CFStringGetCStringPtr(v399, 0x8000100u);
      if (v400)
      {
        uint64_t v401 = 0LL;
      }

      else
      {
        uint64_t v400 = (char *)calloc(0x400uLL, 1uLL);
        CFStringGetCString(v111, v400, 1024LL, 0x8000100u);
        uint64_t v401 = v400;
      }

      if (qword_1000E7D38) {
        uint64_t v403 = (FILE *)qword_1000E7D38;
      }
      else {
        uint64_t v403 = __stderrp;
      }
      fprintf(v403, "%s\n", v400);
      if (v401) {
        free(v401);
      }
      goto LABEL_804;
    }

    uint64_t v402 = (os_log_s *)sub_10002EFA0();
    if (os_log_type_enabled(v402, OS_LOG_TYPE_FAULT)) {
      sub_10009412C();
    }
    if (qword_1000E7D38) {
      uint64_t v128 = (FILE *)qword_1000E7D38;
    }
    else {
      uint64_t v128 = __stderrp;
    }
    goto LABEL_246;
  }

  if (fgets((char *)v694[3], *((_DWORD *)v690 + 6), v14))
  {
    id obj = 0LL;
    __int128 v22 = 0LL;
    __int16 v622 = 0LL;
    LODWORD(v642) = 0;
    Weak = 0LL;
    id v610 = 0;
    v619 = 0;
    v638 = 0;
    __int16 v611 = 0LL;
    v640 = 0xFFFFFFFFLL;
    v616 = -1LL;
    v617 = v6;
    v645 = a4;
    while (1)
    {
      context = objc_autoreleasePoolPush();
      id v145 = (const char *)v694[3];
      uint64_t v153 = strnlen(v145, *((int *)v690 + 6));
      if (v145[v153 - 1] != 10)
      {
        v685((uint64_t)v684, v146, v147, v148, v149, v150, v151, v152);
        goto LABEL_303;
      }

      v145[v153 - 1] = 0;
      uint64_t v154 = +[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v694[3]);
      int v155 = -[NSRegularExpression firstMatchInString:options:range:]( v643,  "firstMatchInString:options:range:",  v154,  0LL,  0LL,  -[NSString length](v154, "length"));
      v642 = (v642 + 1);
      if (v155) {
        break;
      }
      int v162 = -[NSRegularExpression firstMatchInString:options:range:]( v621,  "firstMatchInString:options:range:",  v154,  0LL,  0LL,  -[NSString length](v154, "length"));
      if (!v162)
      {
        if (-[NSRegularExpression firstMatchInString:options:range:]( v618,  "firstMatchInString:options:range:",  v154,  0LL,  0LL,  -[NSString length](v154, "length")))
        {
          goto LABEL_521;
        }

        int v199 = -[NSRegularExpression firstMatchInString:options:range:]( v612,  "firstMatchInString:options:range:",  v154,  0LL,  0LL,  -[NSString length](v154, "length"));
        int v200 = v199;
        if (v199)
        {
          __int16 v202 = -[NSTextCheckingResult rangeWithName:](v199, "rangeWithName:", @"binaryIndex");
          if (v202 == (id)0x7FFFFFFFFFFFFFFFLL) {
            goto LABEL_349;
          }
          id v290 = sub_10007BD4C(-[NSString substringWithRange:](v154, "substringWithRange:", v202, v201));
          if (v290 >= (unint64_t)-[NSMutableArray count](v657, "count"))
          {
            if (byte_1000E7D30)
            {
              id v298 = v154;
              __int16 v299 = *__error();
              id v300 = (os_log_s *)sub_10002EFA0();
              if (os_log_type_enabled(v300, OS_LOG_TYPE_ERROR))
              {
                v395 = -[NSMutableArray count](v657, "count");
                *(_DWORD *)buf = 134218754;
                *(void *)&uint8_t buf[4] = v290;
                *(_WORD *)&_BYTE buf[12] = 2048;
                *(void *)&buf[14] = v395;
                *(_WORD *)&buf[22] = 1024;
                *(_DWORD *)&uint8_t buf[24] = v642;
                *(_WORD *)&buf[28] = 2112;
                *(void *)&buf[30] = v298;
                _os_log_error_impl( (void *)&_mh_execute_header,  v300,  OS_LOG_TYPE_ERROR,  "Parsing spindump text: corrupt condensed file, UUID line has out-of-bounds binary index %lu (%lu binaries) (%d: %@)",  buf,  0x26u);
                unint64_t v6 = v617;
                a4 = v645;
              }

              *__error() = v299;
              uint64_t v154 = v298;
            }

            if (byte_1000E7D31 && dword_1000E74E0 <= 3)
            {
              __int16 v301 = v154;
              id v302 = *__error();
              __int16 v303 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"Parsing spindump text: corrupt condensed file, UUID line has out-of-bounds binary index %lu (%lu binaries) (%d: %@)",  v290,  -[NSMutableArray count](v657, "count"),  v642,  v301);
              id v304 = v303;
              if (v303)
              {
                __int16 v305 = (char *)CFStringGetCStringPtr(v303, 0x8000100u);
                if (v305)
                {
                  id v306 = 0LL;
                }

                else
                {
                  __int16 v305 = (char *)calloc(0x400uLL, 1uLL);
                  CFStringGetCString(v304, v305, 1024LL, 0x8000100u);
                  id v306 = v305;
                }

                if (qword_1000E7D38) {
                  __int16 v355 = (FILE *)qword_1000E7D38;
                }
                else {
                  __int16 v355 = __stderrp;
                }
                fprintf(v355, "%s\n", v305);
                if (v306) {
                  free(v306);
                }
                CFRelease(v304);
              }

              else
              {
                uint64_t v348 = (os_log_s *)sub_10002EFA0();
                if (os_log_type_enabled(v348, OS_LOG_TYPE_FAULT))
                {
                  v396 = -[NSMutableArray count](v657, "count");
                  *(_DWORD *)buf = 134218754;
                  *(void *)&uint8_t buf[4] = v290;
                  *(_WORD *)&_BYTE buf[12] = 2048;
                  *(void *)&buf[14] = v396;
                  *(_WORD *)&buf[22] = 1024;
                  *(_DWORD *)&uint8_t buf[24] = v642;
                  *(_WORD *)&buf[28] = 2112;
                  *(void *)&buf[30] = v301;
                  _os_log_fault_impl( (void *)&_mh_execute_header,  v348,  OS_LOG_TYPE_FAULT,  "Unable to format: Parsing spindump text: corrupt condensed file, UUID line has out-of-bounds binary index %lu (%lu binaries) (%d: %@)",  buf,  0x26u);
                }

                if (qword_1000E7D38) {
                  __int128 v349 = (FILE *)qword_1000E7D38;
                }
                else {
                  __int128 v349 = __stderrp;
                }
                fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v349);
              }

              *__error() = v302;
              unint64_t v6 = v617;
              a4 = v645;
            }

LABEL_349:
            fprintf(a4, "%s\n");
          }

          else
          {
            __int16 v291 = -[NSMutableArray objectAtIndexedSubscript:](v657, "objectAtIndexedSubscript:", v290);
            -[NSTextCheckingResult rangeWithName:](v200, "rangeWithName:", @"whitespace");
            if (v291) {
              id v292 = (void *)v291[5];
            }
            else {
              id v292 = 0LL;
            }
            objc_msgSend(objc_msgSend(objc_msgSend(v292, "uuid"), "UUIDString"), "UTF8String");
            fprintf(a4, "UUID:%*s%s\n");
          }

LABEL_521:
          uint64_t v153 = 0;
LABEL_303:
          uint64_t v161 = 5;
          goto LABEL_583;
        }

        if (self->_isHeavy != v683 && obj)
        {
          if (-[NSString length](v154, "length"))
          {
            if (byte_1000E7D30)
            {
              __int16 v281 = v154;
              id v282 = *__error();
              __int16 v283 = (os_log_s *)sub_10002EFA0();
              if (os_log_type_enabled(v283, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)buf = 67109378;
                *(_DWORD *)&uint8_t buf[4] = v642;
                *(_WORD *)&uint8_t buf[8] = 2112;
                *(void *)&buf[10] = v281;
                _os_log_error_impl( (void *)&_mh_execute_header,  v283,  OS_LOG_TYPE_ERROR,  "Parsing spindump text: Unexpected line in call tree, ignoring (%d: %@)",  buf,  0x12u);
              }

              unint64_t v6 = v617;
              *__error() = v282;
              uint64_t v154 = v281;
            }

            uint64_t v153 = 0;
            uint64_t v161 = 5;
            if (!byte_1000E7D31 || dword_1000E74E0 > 3) {
              goto LABEL_583;
            }
            id v284 = v154;
            __int16 v285 = *__error();
            id v286 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"Parsing spindump text: Unexpected line in call tree, ignoring (%d: %@)",  v642,  v284);
            __int16 v287 = v286;
            if (v286)
            {
              id v288 = (char *)CFStringGetCStringPtr(v286, 0x8000100u);
              if (v288)
              {
                __int16 v289 = 0LL;
              }

              else
              {
                id v288 = (char *)calloc(0x400uLL, 1uLL);
                CFStringGetCString(v287, v288, 1024LL, 0x8000100u);
                __int16 v289 = v288;
              }

              if (qword_1000E7D38) {
                v394 = (FILE *)qword_1000E7D38;
              }
              else {
                v394 = __stderrp;
              }
              fprintf(v394, "%s\n", v288);
              if (v289) {
                free(v289);
              }
              CFRelease(v287);
            }

            else
            {
              __int16 v353 = (os_log_s *)sub_10002EFA0();
              if (os_log_type_enabled(v353, OS_LOG_TYPE_FAULT))
              {
                *(_DWORD *)buf = 67109378;
                *(_DWORD *)&uint8_t buf[4] = v642;
                *(_WORD *)&uint8_t buf[8] = 2112;
                *(void *)&buf[10] = v284;
                _os_log_fault_impl( (void *)&_mh_execute_header,  v353,  OS_LOG_TYPE_FAULT,  "Unable to format: Parsing spindump text: Unexpected line in call tree, ignoring (%d: %@)",  buf,  0x12u);
              }

              if (qword_1000E7D38) {
                id v354 = (FILE *)qword_1000E7D38;
              }
              else {
                id v354 = __stderrp;
              }
              fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v354);
            }

            uint64_t v153 = 0;
            *__error() = v285;
            goto LABEL_773;
          }

          v632 = v154;
          __int16 v311 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
          -[NSMutableArray sortUsingComparator:](obj, "sortUsingComparator:", &stru_1000D9CB8);
          -[NSMutableArray addObject:](v311, "addObject:", obj);
          __int16 v628 = v311;
          id v312 = -[NSMutableArray objectAtIndex:](obj, "objectAtIndex:", 0LL);
          if (v312) {
            __int16 v313 = v312[3];
          }
          else {
            __int16 v313 = 0;
          }
          __int16 v622 = 0LL;
          v652 = vcvtpd_s64_f64(log10((double)v313)) + 2;
          id v314 = self;
          __int16 v315 = v311;
          do
          {
            while (1)
            {
LABEL_590:
              if (!-[NSMutableArray count](v315, "count"))
              {

                id obj = 0LL;
                unint64_t v6 = v617;
                a4 = v645;
                uint64_t v154 = v632;
                goto LABEL_621;
              }

              id v316 = -[NSMutableArray lastObject](v315, "lastObject");
              if ([v316 count]) {
                break;
              }
              -[NSMutableArray removeLastObject](v315, "removeLastObject");
            }

            __int16 v317 = [v316 objectAtIndex:0];
            [v316 removeObjectAtIndex:0];
            id v318 = -[NSMutableArray count](v315, "count");
            omitFramesBelowSampleCount = v314->_omitFramesBelowSampleCount;
            if (omitFramesBelowSampleCount < 1) {
              break;
            }
            id v320 = v317 ? *((_DWORD *)v317 + 3) : 0;
          }

          while (v320 < omitFramesBelowSampleCount);
          v636 = (id *)v317;
          char v321 = v622;
          char v322 = (unsigned int *)&v22[8 * v622 - 8];
          id v323 = (8LL * (int)v622) | 4;
          v620 = v318 - 1;
          while (1)
          {
            char v324 = v321;
            char v325 = v323;
            --v321;
            id v326 = *v322;
            v322 -= 2;
            v323 -= 8LL;
            if (v326 < v318 - 1)
            {
              id v623 = v325;
              NSUInteger v625 = v324;
              char v327 = v322[3];
              goto LABEL_602;
            }
          }

          id v623 = v323;
          NSUInteger v625 = v321;
          char v327 = 0;
LABEL_602:
          if (!v317)
          {
LABEL_1087:
            if (byte_1000E7D30)
            {
              v585 = *__error();
              __int128 v586 = (os_log_s *)sub_10002EFA0();
              if (os_log_type_enabled(v586, OS_LOG_TYPE_ERROR)) {
                sub_1000941C4((uint64_t)objc_msgSend(objc_msgSend(v317, "debugDescription"), "UTF8String"), buf);
              }
              *__error() = v585;
            }

            if (byte_1000E7D31) {
              v575 = dword_1000E74E0 <= 3;
            }
            else {
              v575 = 0;
            }
            if (v575)
            {
              __int128 v587 = *__error();
              __int128 v588 = CFStringCreateWithFormat( kCFAllocatorDefault,  0,  @"%s: No angle bracket contents nor state info for non-frame (%s)",  "heaviestNode.angleBracketContents || heaviestNode.stateInfo",  objc_msgSend(objc_msgSend(v317, "debugDescription"), "UTF8String"));
              v589 = v588;
              if (v588)
              {
                __int128 v596 = (char *)CFStringGetCStringPtr(v588, 0x8000100u);
                if (v596)
                {
                  v597 = 0LL;
                }

                else
                {
                  __int128 v596 = (char *)calloc(0x400uLL, 1uLL);
                  CFStringGetCString(v589, v596, 1024LL, 0x8000100u);
                  v597 = v596;
                }

                if (qword_1000E7D38) {
                  unint64_t v602 = (FILE *)qword_1000E7D38;
                }
                else {
                  unint64_t v602 = __stderrp;
                }
                fprintf(v602, "%s\n", v596);
                if (v597) {
                  free(v597);
                }
                CFRelease(v589);
              }

              else
              {
                __int128 v590 = (os_log_s *)sub_10002EFA0();
                if (os_log_type_enabled(v590, OS_LOG_TYPE_FAULT)) {
                  sub_100094184((uint64_t)objc_msgSend(objc_msgSend(v317, "debugDescription"), "UTF8String"), v702);
                }
                if (qword_1000E7D38) {
                  __int128 v591 = (FILE *)qword_1000E7D38;
                }
                else {
                  __int128 v591 = __stderrp;
                }
                fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v591);
              }

              *__error() = v587;
            }

            objc_msgSend(objc_msgSend(v636, "debugDescription"), "UTF8String");
            sub_10002EE78( "-[SPTextualReportParser parseSpindumpFile:andReportToStream:]",  "SPTextualReportParser.m",  839,  "%s: No angle bracket contents nor state info for non-frame (%s)",  v576,  v577,  v578,  v579,  (char)"heaviestNode.angleBracketContents || heaviestNode.stateInfo");
            abort();
          }

          char v328 = (void *)*((void *)v317 + 2);
          if (v328)
          {
            id v329 = 0LL;
            v647 = v327 + v318 - 1;
            while (1)
            {
              char v330 = [v328 count];
              char v331 = (void *)*((void *)v317 + 2);
              id v332 = [v331 objectAtIndexedSubscript:v329];
              sub_10007BDB8( v645,  v681 + v682 * (v647 + v329++),  *((_BYTE *)v317 + 8) & 1,  *((_DWORD *)v317 + 3),  v652,  (const char *)[v332 UTF8String],  *((void *)v317 + 4),  (const char *)objc_msgSend(*((id *)v317 + 5), "UTF8String"),  0,  0);
              char v328 = (void *)*((void *)v317 + 2);
            }

            if ((unint64_t)[v331 count] > 1)
            {
              __int128 v22 = (char *)realloc(v22, 8LL * ((int)v625 + 1));
              *(_DWORD *)&v22[v623 - 4] = v620;
              char v333 = [*((id *)v317 + 2) count];
              else {
                char v334 = *(_DWORD *)&v22[8 * (v625 - 1) + 4];
              }
              *(_DWORD *)&v22[v623] = v333 - 1 + v334;
              __int16 v622 = v625 + 1;
LABEL_616:
              char v336 = (void *)*((void *)v317 + 6);
              id v314 = self;
              __int16 v315 = v628;
              if (v336 && [v636[6] count])
              {
                [v336 sortUsingComparator:&stru_1000D9CB8];
                -[NSMutableArray addObject:](v628, "addObject:", v336);
              }

              goto LABEL_590;
            }
          }

          else
          {
            id v335 = (void *)*((void *)v317 + 3);
            if (!v335 && !*((void *)v317 + 5)) {
              goto LABEL_1087;
            }
            sub_10007C6A8( v645,  v681 + v682 * (v327 + v620),  *((_BYTE *)v317 + 8) & 1,  *((_DWORD *)v317 + 3),  v652,  (const char *)[v335 UTF8String],  (uint64_t)objc_msgSend(*((id *)v317 + 5), "UTF8String"),  0,  0);
          }

          __int16 v622 = v625;
          goto LABEL_616;
        }

LABEL_621:
        if (-[NSString length](v154, "length") && (_DWORD)v640 != -1)
        {
          if (byte_1000E7D30)
          {
            char v337 = v154;
            id v338 = *__error();
            char v339 = (os_log_s *)sub_10002EFA0();
            if (os_log_type_enabled(v339, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 67109378;
              *(_DWORD *)&uint8_t buf[4] = v642;
              *(_WORD *)&uint8_t buf[8] = 2112;
              *(void *)&buf[10] = v337;
              _os_log_error_impl( (void *)&_mh_execute_header,  v339,  OS_LOG_TYPE_ERROR,  "Parsing spindump text: Unexpected end of call tree (%d: %@)",  buf,  0x12u);
            }

            unint64_t v6 = v617;
            a4 = v645;
            *__error() = v338;
            uint64_t v154 = v337;
          }

          if (byte_1000E7D31 && dword_1000E74E0 <= 3)
          {
            char v340 = v154;
            id v341 = *__error();
            char v342 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"Parsing spindump text: Unexpected end of call tree (%d: %@)",  v642,  v340);
            char v343 = v342;
            if (v342)
            {
              id v344 = (char *)CFStringGetCStringPtr(v342, 0x8000100u);
              if (v344)
              {
                char v345 = 0LL;
              }

              else
              {
                id v344 = (char *)calloc(0x400uLL, 1uLL);
                CFStringGetCString(v343, v344, 1024LL, 0x8000100u);
                char v345 = v344;
              }

              if (qword_1000E7D38) {
                id v356 = (FILE *)qword_1000E7D38;
              }
              else {
                id v356 = __stderrp;
              }
              fprintf(v356, "%s\n", v344);
              if (v345) {
                free(v345);
              }
              CFRelease(v343);
            }

            else
            {
              __int128 v350 = (os_log_s *)sub_10002EFA0();
              if (os_log_type_enabled(v350, OS_LOG_TYPE_FAULT))
              {
                *(_DWORD *)buf = 67109378;
                *(_DWORD *)&uint8_t buf[4] = v642;
                *(_WORD *)&uint8_t buf[8] = 2112;
                *(void *)&buf[10] = v340;
                _os_log_fault_impl( (void *)&_mh_execute_header,  v350,  OS_LOG_TYPE_FAULT,  "Unable to format: Parsing spindump text: Unexpected end of call tree (%d: %@)",  buf,  0x12u);
              }

              if (qword_1000E7D38) {
                uint64_t v351 = (FILE *)qword_1000E7D38;
              }
              else {
                uint64_t v351 = __stderrp;
              }
              fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v351);
            }

            *__error() = v341;
            unint64_t v6 = v617;
            a4 = v645;
            uint64_t v154 = v340;
          }
        }

        fprintf(a4, "%s\n", (const char *)v694[3]);
        if (-[NSString containsString:](v154, "containsString:", @"Binary Images:"))
        {
          v664 = 0u;
          v665 = 0u;
          v662 = 0u;
          v663 = 0u;
          __int16 v357 = 0LL;
          uint64_t v358 = 0;
          double v359 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v657,  "countByEnumeratingWithState:objects:count:",  &v662,  v699,  16LL);
          if (v359)
          {
            unsigned int v360 = *(void *)v663;
            do
            {
              v361 = 0LL;
              do
              {
                if (*(void *)v663 != v360) {
                  objc_enumerationMutation(v657);
                }
                v362 = *(void *)(*((void *)&v662 + 1) + 8LL * (void)v361);
                if (v362)
                {
                  double v363 = [*(id *)(v362 + 40) bundleIdentifier];
                  if (!v363) {
                    double v363 = *(id *)(v362 + 8);
                  }
                }

                else
                {
                  double v363 = 0LL;
                }

                double v364 = [v363 length];
                double v365 = (int)v364;
                if (!v364)
                {
                  if (v362)
                  {
                    v366 = [*(id *)(v362 + 40) name];
                    if (!v366) {
                      v366 = *(id *)(v362 + 16);
                    }
                  }

                  else
                  {
                    v366 = 0LL;
                  }

                  int v367 = [v366 length];
                  if (v367) {
                    double v365 = (int)v367;
                  }
                  else {
                    double v365 = 3;
                  }
                }

                v368 = sub_100073584(v362);
                if ([v368 length]) {
                  v365 += [v368 length] + 1;
                }
                if (v362) {
                  int v369 = *(void **)(v362 + 48);
                }
                else {
                  int v369 = 0LL;
                }
                v370 = [v369 length];
                else {
                  __int16 v357 = v357;
                }
                if (v358 <= v370) {
                  uint64_t v358 = v370;
                }
                v361 = (char *)v361 + 1;
              }

              while (v359 != v361);
              v371 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v657,  "countByEnumeratingWithState:objects:count:",  &v662,  v699,  16LL);
              double v359 = v371;
            }

            while (v371);
          }

          v660 = 0u;
          v661 = 0u;
          v658 = 0u;
          v659 = 0u;
          v648 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v657,  "countByEnumeratingWithState:objects:count:",  &v658,  v698,  16LL);
          if (v648)
          {
            v653 = 0LL;
            v372 = *(void *)v659;
            __int16 v626 = *(void *)v659;
            while (1)
            {
              if (v372 != v626) {
                objc_enumerationMutation(v657);
              }
              v373 = *(void *)(*((void *)&v658 + 1) + 8LL * (void)v653);
              if (v373)
              {
                id v374 = *(_BYTE *)(v373 + 32);
                id v375 = *(void *)(v373 + 56);
                v376 = *(void *)(v373 + 64);
                v377 = [*(id *)(v373 + 40) bundleIdentifier];
                unsigned int v629 = v374 & 1;
                if (!v377) {
                  v377 = *(id *)(v373 + 8);
                }
              }

              else
              {
                v376 = 0LL;
                unsigned int v629 = 0;
                id v375 = 0LL;
                v377 = 0LL;
              }

              v641 = (const char *)[v377 UTF8String];
              if (v373)
              {
                v378 = [*(id *)(v373 + 40) name];
                if (!v378) {
                  v378 = *(id *)(v373 + 16);
                }
              }

              else
              {
                v378 = 0LL;
              }

              v637 = (const char *)[v378 UTF8String];
              v633 = (const char *)[sub_100073584(v373) UTF8String];
              if (v373) {
                v379 = *(void **)(v373 + 40);
              }
              else {
                v379 = 0LL;
              }
              double v380 = (const char *)objc_msgSend(objc_msgSend(objc_msgSend(v379, "uuid"), "UUIDString"), "UTF8String");
              if (v373) {
                double v381 = *(void **)(v373 + 48);
              }
              else {
                double v381 = 0LL;
              }
              double v382 = (const char *)[v381 UTF8String];
              if (v373) {
                v383 = *(void **)(v373 + 40);
              }
              else {
                v383 = 0LL;
              }
              id v384 = (const char *)objc_msgSend(objc_msgSend(v383, "path"), "UTF8String");
              if (v375)
              {
                id v385 = "";
                if (v629) {
                  id v385 = "*";
                }
                snprintf(buf, 0x20uLL, "%s0x%llx", v385, v375);
                id v386 = v645;
                fprintf(v645, "%22s - ", buf);
                if (v376) {
                  fprintf(v645, "%#18llx  ");
                }
                else {
                  fwrite("               ???  ", 0x14uLL, 1uLL, v645);
                }
              }

              else
              {
                id v386 = v645;
                fprintf(v645, "%2s");
              }

              unsigned int v387 = "???";
              if (v637) {
                unsigned int v387 = v637;
              }
              if (v641) {
                unsigned int v387 = v641;
              }
              unsigned int v392 = fprintf(v386, "%s", v387);
              if (v633) {
                unsigned int v392 = (fprintf(v386, " %s", v633) + v392);
              }
              if ((int)v392 > (int)v357)
              {
                if (byte_1000E7D30)
                {
                  v505 = *__error();
                  v506 = (os_log_s *)sub_10002EFA0();
                  if (os_log_type_enabled(v506, OS_LOG_TYPE_ERROR))
                  {
                    *(_DWORD *)buf = 136316418;
                    *(void *)&uint8_t buf[4] = "numChars < nameAndVersionWidth + 1";
                    *(_WORD *)&_BYTE buf[12] = 1024;
                    *(_DWORD *)&buf[14] = v392;
                    *(_WORD *)&buf[18] = 1024;
                    *(_DWORD *)&buf[20] = v357;
                    *(_WORD *)&uint8_t buf[24] = 2080;
                    *(void *)&buf[26] = v641;
                    *(_WORD *)&buf[34] = 2080;
                    *(void *)&buf[36] = v637;
                    *(_WORD *)&buf[44] = 2080;
                    *(void *)&buf[46] = v633;
                    _os_log_error_impl( (void *)&_mh_execute_header,  v506,  OS_LOG_TYPE_ERROR,  "%s: Printed %d characters when max is %d: %s, %s, %s",  buf,  0x36u);
                  }

                  *__error() = v505;
                }

                if (byte_1000E7D31 && dword_1000E74E0 <= 3)
                {
                  v492 = *__error();
                  id v493 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"%s: Printed %d characters when max is %d: %s, %s, %s",  "numChars < nameAndVersionWidth + 1",  v392,  v357,  v641,  v637,  v633);
                  id v494 = v493;
                  if (v493)
                  {
                    __int128 v544 = (char *)CFStringGetCStringPtr(v493, 0x8000100u);
                    if (v544)
                    {
                      __int128 v545 = 0LL;
                    }

                    else
                    {
                      __int128 v544 = (char *)calloc(0x400uLL, 1uLL);
                      CFStringGetCString(v494, v544, 1024LL, 0x8000100u);
                      __int128 v545 = v544;
                    }

                    if (qword_1000E7D38) {
                      uint64_t v568 = (FILE *)qword_1000E7D38;
                    }
                    else {
                      uint64_t v568 = __stderrp;
                    }
                    fprintf(v568, "%s\n", v544);
                    if (v545) {
                      free(v545);
                    }
                    CFRelease(v494);
                  }

                  else
                  {
                    id v495 = (os_log_s *)sub_10002EFA0();
                    if (os_log_type_enabled(v495, OS_LOG_TYPE_FAULT))
                    {
                      *(_DWORD *)buf = 136316418;
                      *(void *)&uint8_t buf[4] = "numChars < nameAndVersionWidth + 1";
                      *(_WORD *)&_BYTE buf[12] = 1024;
                      *(_DWORD *)&buf[14] = v392;
                      *(_WORD *)&buf[18] = 1024;
                      *(_DWORD *)&buf[20] = v357;
                      *(_WORD *)&uint8_t buf[24] = 2080;
                      *(void *)&buf[26] = v641;
                      *(_WORD *)&buf[34] = 2080;
                      *(void *)&buf[36] = v637;
                      *(_WORD *)&buf[44] = 2080;
                      *(void *)&buf[46] = v633;
                      _os_log_fault_impl( (void *)&_mh_execute_header,  v495,  OS_LOG_TYPE_FAULT,  "Unable to format: %s: Printed %d characters when max is %d: %s, %s, %s",  buf,  0x36u);
                    }

                    if (qword_1000E7D38) {
                      v496 = (FILE *)qword_1000E7D38;
                    }
                    else {
                      v496 = __stderrp;
                    }
                    fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v496);
                  }

                  *__error() = v492;
                }

                sub_10002EE78( "PrintLoadInfoLine",  "SPTextualReportParser.m",  2436,  "%s: Printed %d characters when max is %d: %s, %s, %s",  v388,  v389,  v390,  v391,  (char)"numChars < nameAndVersionWidth + 1");
                abort();
              }

              fprintf(v645, "%*s", v357 + 1 - v392, "");
              fprintf(v645, "<%s>", v380);
              if (v382) {
                v393 = fprintf(v645, "%s", v382);
              }
              else {
                v393 = 0;
              }
              if (v358 > v393) {
                fprintf(v645, "%*s", v358 - v393, "");
              }
              if (v384) {
                fprintf(v645, "  %s", v384);
              }
              fputc(10, v645);
              v653 = (char *)v653 + 1;
              if (v653 >= v648)
              {
                v648 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v657,  "countByEnumeratingWithState:objects:count:",  &v658,  v698,  16LL);
                if (!v648) {
                  break;
                }
                v653 = 0LL;
              }

              v372 = *(void *)v659;
            }
          }

          if ((v654 & 1) == 0)
          {

            v657 = sub_10007A220(v14, v642, (uint64_t)v618, 0);
          }

          uint64_t v161 = 0;
          uint64_t v153 = 0;
          v619 = 0;
          id v610 = 0;
          Weak = 0LL;
          v640 = 0xFFFFFFFFLL;
LABEL_773:
          unint64_t v6 = v617;
          goto LABEL_583;
        }

        uint64_t v161 = 0;
        uint64_t v153 = 0;
        v619 = 0;
        id v610 = 0;
        Weak = 0LL;
        __int16 v297 = 0xFFFFFFFFLL;
LABEL_549:
        v640 = v297;
        goto LABEL_583;
      }

      v676 = -1;
      v675 = -1;
      v674 = 0;
      v673 = 0;
      v672 = 0;
      v697 = 0LL;
      v671 = 0LL;
      v670 = 0LL;
      sub_10007BEC4( v154,  v642,  v162,  v654,  v681,  v682,  &v676,  &v675,  &v674,  &v673,  &v672,  &v697,  (NSMutableString **)&v671,  (int *)&v670 + 1,  &v670);
      uint64_t v163 = v697;
      int v164 = v697;
      uint64_t v165 = v671;
      uint64_t v166 = v671;
      uint64_t v167 = v673;
      if (v673 <= 0)
      {
        if (v619 < 1 || (int v203 = v675, v675 <= v681 + v619))
        {
          uint64_t v172 = 0LL;
          uint64_t v171 = 0;
          v676 = 0;
        }

        else
        {
          uint64_t v172 = ((v675 - (v681 + v619)) / v682);
          v676 = v172;
          if ((v172 & 0x80000000) != 0)
          {
            if (byte_1000E7D30)
            {
              v631 = v154;
              int v204 = *__error();
              int v205 = (os_log_s *)sub_10002EFA0();
              if (os_log_type_enabled(v205, OS_LOG_TYPE_DEBUG))
              {
                *(_DWORD *)buf = 67109890;
                *(_DWORD *)&uint8_t buf[4] = v172;
                *(_WORD *)&uint8_t buf[8] = 1024;
                *(_DWORD *)&buf[10] = v203;
                *(_WORD *)&buf[14] = 1024;
                *(_DWORD *)&uint8_t buf[16] = v642;
                *(_WORD *)&buf[20] = 2112;
                *(void *)&buf[22] = v631;
                _os_log_debug_impl( (void *)&_mh_execute_header,  v205,  OS_LOG_TYPE_DEBUG,  "Parsing spindump text: Bad indent level %d for %d whitespace (%d: %@)",  buf,  0x1Eu);
              }

              *__error() = v204;
              uint64_t v154 = v631;
            }

            if (byte_1000E7D31 && dword_1000E74E0 <= 0)
            {
              v650 = *__error();
              int v206 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"Parsing spindump text: Bad indent level %d for %d whitespace (%d: %@)",  v172,  v203,  v642,  v154);
              if (v206)
              {
                __int16 v207 = v206;
                id v208 = (char *)CFStringGetCStringPtr(v206, 0x8000100u);
                if (v208)
                {
                  __int16 v209 = 0LL;
                  unint64_t v6 = v617;
                }

                else
                {
                  unint64_t v6 = v617;
                  id v208 = (char *)calloc(0x400uLL, 1uLL);
                  CFStringGetCString(v207, v208, 1024LL, 0x8000100u);
                  __int16 v209 = v208;
                }

                if (qword_1000E7D38) {
                  v352 = (FILE *)qword_1000E7D38;
                }
                else {
                  v352 = __stderrp;
                }
                fprintf(v352, "%s\n", v208);
                if (v209) {
                  free(v209);
                }
                CFRelease(v207);
              }

              else
              {
                char v346 = (os_log_s *)sub_10002EFA0();
                if (os_log_type_enabled(v346, OS_LOG_TYPE_FAULT))
                {
                  *(_DWORD *)buf = 67109890;
                  *(_DWORD *)&uint8_t buf[4] = v172;
                  *(_WORD *)&uint8_t buf[8] = 1024;
                  *(_DWORD *)&buf[10] = v203;
                  *(_WORD *)&buf[14] = 1024;
                  *(_DWORD *)&uint8_t buf[16] = v642;
                  *(_WORD *)&buf[20] = 2112;
                  *(void *)&buf[22] = v154;
                  _os_log_fault_impl( (void *)&_mh_execute_header,  v346,  OS_LOG_TYPE_FAULT,  "Unable to format: Parsing spindump text: Bad indent level %d for %d whitespace (%d: %@)",  buf,  0x1Eu);
                }

                if (qword_1000E7D38) {
                  id v347 = (FILE *)qword_1000E7D38;
                }
                else {
                  id v347 = __stderrp;
                }
                fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v347);
                unint64_t v6 = v617;
              }

              *__error() = v650;
            }

            uint64_t v172 = 0LL;
            v676 = 0;
          }

          if (v638) {
            goto LABEL_397;
          }
          uint64_t v171 = 1;
          if ((v172 & 0x80000000) != 0)
          {
LABEL_952:
            uint64_t v497 = v154;
            if (byte_1000E7D30)
            {
              v507 = *__error();
              CFAllocatorRef v508 = (os_log_s *)sub_10002EFA0();
              if (os_log_type_enabled(v508, OS_LOG_TYPE_ERROR))
              {
                -[NSString UTF8String](v154, "UTF8String");
                sub_100094248();
              }

              *__error() = v507;
            }

            if (byte_1000E7D31 && dword_1000E74E0 <= 3)
            {
              v498 = *__error();
              id v499 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"%s: Non-frame line has count but no indent level (%d: %s)",  "rawIndentLevel >= 0",  v642,  -[NSString UTF8String](v154, "UTF8String"));
              uint64_t v500 = v499;
              if (v499)
              {
                v559 = (char *)CFStringGetCStringPtr(v499, 0x8000100u);
                if (v559)
                {
                  v560 = 0LL;
                }

                else
                {
                  v559 = (char *)calloc(0x400uLL, 1uLL);
                  CFStringGetCString(v500, v559, 1024LL, 0x8000100u);
                  v560 = v559;
                }

                if (qword_1000E7D38) {
                  uint64_t v580 = (FILE *)qword_1000E7D38;
                }
                else {
                  uint64_t v580 = __stderrp;
                }
                fprintf(v580, "%s\n", v559);
                if (v560) {
                  free(v560);
                }
                CFRelease(v500);
              }

              else
              {
                unint64_t v501 = (os_log_s *)sub_10002EFA0();
                if (os_log_type_enabled(v501, OS_LOG_TYPE_FAULT))
                {
                  -[NSString UTF8String](v497, "UTF8String");
                  sub_100094204();
                }

                if (qword_1000E7D38) {
                  uint64_t v502 = (FILE *)qword_1000E7D38;
                }
                else {
                  uint64_t v502 = __stderrp;
                }
                fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v502);
              }

              *__error() = v498;
            }

            -[NSString UTF8String](v497, "UTF8String");
            sub_10002EE78( "-[SPTextualReportParser parseSpindumpFile:andReportToStream:]",  "SPTextualReportParser.m",  659,  "%s: Non-frame line has count but no indent level (%d: %s)",  v581,  v582,  v583,  v584,  (char)"rawIndentLevel >= 0");
            abort();
          }
        }
      }

      else
      {
        uint64_t v168 = HIDWORD(v670);
        if (HIDWORD(v670))
        {
          uint64_t v169 = self->_startIndex;
          if (v169)
          {
            if (SHIDWORD(v670) < v169)
            {
              uint64_t v167 = HIDWORD(v670) + v673 - v169;
              v673 = v167;
              HIDWORD(v670) = v169;
              uint64_t v168 = v169;
            }
          }
        }

        if ((_DWORD)v670)
        {
          endIndex = self->_endIndex;
          if (endIndex)
          {
            if (endIndex < (int)v670)
            {
              v167 += endIndex - v670;
              v673 = v167;
              LODWORD(v670) = endIndex;
            }
          }
        }

        if (v167 < 1)
        {
          if (v168)
          {
            id v250 = self->_endIndex;
            if (v250) {
              __int16 v223 = v168 <= v250;
            }
            else {
              __int16 v223 = 1;
            }
            goto LABEL_393;
          }

LABEL_397:
          uint64_t v161 = 5;
LABEL_498:
          uint64_t v153 = 0;
          goto LABEL_583;
        }

        uint64_t v171 = 1;
        uint64_t v172 = v676;
        if ((v676 & 0x80000000) != 0) {
          goto LABEL_952;
        }
      }

      if (v171 && (int)v172 > (int)v640 && (_DWORD)v172 != (_DWORD)v640 + 1)
      {
        if (byte_1000E7D30)
        {
          id v240 = v154;
          __int16 v241 = *__error();
          id v242 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v242, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 67109378;
            *(_DWORD *)&uint8_t buf[4] = v642;
            *(_WORD *)&uint8_t buf[8] = 2112;
            *(void *)&buf[10] = v240;
            _os_log_error_impl( (void *)&_mh_execute_header,  v242,  OS_LOG_TYPE_ERROR,  "Parsing spindump text: Unexpected indent for line (%d: %@)",  buf,  0x12u);
          }

          *__error() = v241;
          uint64_t v154 = v240;
        }

        uint64_t v161 = 2;
        if (byte_1000E7D31 && dword_1000E74E0 <= 3)
        {
          __int16 v243 = v154;
          id v244 = *__error();
          __int16 v245 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"Parsing spindump text: Unexpected indent for line (%d: %@)",  v642,  v243);
          id v246 = v245;
          if (v245)
          {
            __int16 v247 = (char *)CFStringGetCStringPtr(v245, 0x8000100u);
            if (v247)
            {
              id v248 = 0LL;
            }

            else
            {
              __int16 v247 = (char *)calloc(0x400uLL, 1uLL);
              CFStringGetCString(v246, v247, 1024LL, 0x8000100u);
              id v248 = v247;
            }

            if (qword_1000E7D38) {
              __int16 v309 = (FILE *)qword_1000E7D38;
            }
            else {
              __int16 v309 = __stderrp;
            }
            fprintf(v309, "%s\n", v247);
            if (v248) {
              free(v248);
            }
            CFRelease(v246);
          }

          else
          {
            __int16 v307 = (os_log_s *)sub_10002EFA0();
            if (os_log_type_enabled(v307, OS_LOG_TYPE_FAULT))
            {
              *(_DWORD *)buf = 67109378;
              *(_DWORD *)&uint8_t buf[4] = v642;
              *(_WORD *)&uint8_t buf[8] = 2112;
              *(void *)&buf[10] = v243;
              _os_log_fault_impl( (void *)&_mh_execute_header,  v307,  OS_LOG_TYPE_FAULT,  "Unable to format: Parsing spindump text: Unexpected indent for line (%d: %@)",  buf,  0x12u);
            }

            if (qword_1000E7D38) {
              id v308 = (FILE *)qword_1000E7D38;
            }
            else {
              id v308 = __stderrp;
            }
            fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v308);
          }

          *__error() = v244;
          uint64_t v161 = 2;
        }

        goto LABEL_498;
      }

      if (v167 < 1)
      {
        __int16 v249 = v619;
      }

      else
      {
        __int16 v249 = v619;
        if (v619 <= 0)
        {
          __int16 v249 = v672;
          if (v672 <= 0) {
            __int16 v249 = vcvtpd_s64_f64(log10((double)v167)) + 2;
          }
        }
      }

      v619 = v249;
      if (!v171)
      {
        if ((self->_isHeavy != v683) | v610 & 1)
        {
          id v258 = v622;
          goto LABEL_579;
        }

        v651 = 0;
        v635 = 0;
        id v260 = 0;
        goto LABEL_481;
      }

      v651 = v171;
      id v256 = v154;
      __int16 v257 = &v22[8 * v622 + 4];
      while (1)
      {
        id v258 = v622;
        int v33 = (int)v622 < 1;
        __int16 v622 = (v622 - 1);
        if (v33) {
          break;
        }
        __int16 v259 = *((_DWORD *)v257 - 3);
        v257 -= 8;
        if (v259 < v172)
        {
          id v260 = *(_DWORD *)v257;
          goto LABEL_470;
        }
      }

      id v260 = 0;
LABEL_470:
      if (!((self->_isHeavy != v683) | v610 & 1))
      {
        v635 = v619;
        __int16 v622 = v258;
LABEL_481:
        id v262 = v682;
        __int16 v263 = v681;
        id v264 = v674;
        __int16 v265 = (const char *)[v163 UTF8String];
        id v266 = [v165 UTF8String];
        sub_10007C6A8(v645, v263 + (v260 + v172) * v262, v264, v167, v635, v265, (uint64_t)v266, SHIDWORD(v670), v670);
        id v258 = v622;
        unint64_t v6 = v617;
        uint64_t v171 = v651;
        goto LABEL_579;
      }

      if (!(_DWORD)v172)
      {
        if (!obj)
        {
          id obj = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
          uint64_t v171 = v651;
          goto LABEL_576;
        }

        v668 = 0u;
        v669 = 0u;
        v666 = 0u;
        v667 = 0u;
        id v294 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( obj,  "countByEnumeratingWithState:objects:count:",  &v666,  v700,  16LL);
        if (!v294) {
          goto LABEL_545;
        }
        __int16 v295 = *(void *)v667;
        while (1)
        {
          for (uint64_t i = 0LL; i != v294; uint64_t i = (char *)i + 1)
          {
            if (*(void *)v667 != v295) {
              objc_enumerationMutation(obj);
            }
            Weak = *(id **)(*((void *)&v666 + 1) + 8LL * (void)i);
            if ((sub_100073138((uint64_t)Weak, v674, 0LL, -1LL, (uint64_t)v671, (uint64_t)v697) & 1) != 0)
            {
              uint64_t v171 = v651;
              if (Weak) {
                goto LABEL_578;
              }
LABEL_576:
              Weak = sub_100072B04( (uint64_t)&OBJC_CLASS___SPTreeNode,  0LL,  v674,  0LL,  (void *)0xFFFFFFFFFFFFFFFFLL,  v671,  v697);
              -[NSMutableArray addObject:](obj, "addObject:", Weak);
              goto LABEL_577;
            }
          }

          id v294 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( obj,  "countByEnumeratingWithState:objects:count:",  &v666,  v700,  16LL);
          if (!v294)
          {
LABEL_545:
            uint64_t v171 = v651;
            goto LABEL_576;
          }
        }
      }

      if (!Weak)
      {
        if (byte_1000E7D30)
        {
          v528 = *__error();
          v529 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v529, OS_LOG_TYPE_ERROR))
          {
            id v530 = -[NSString UTF8String](v256, "UTF8String");
            *(_DWORD *)buf = 136315906;
            *(void *)&uint8_t buf[4] = "previousNode";
            *(_WORD *)&_BYTE buf[12] = 1024;
            *(_DWORD *)&buf[14] = v172;
            *(_WORD *)&buf[18] = 1024;
            *(_DWORD *)&buf[20] = v642;
            *(_WORD *)&uint8_t buf[24] = 2080;
            *(void *)&buf[26] = v530;
            _os_log_error_impl( (void *)&_mh_execute_header,  v529,  OS_LOG_TYPE_ERROR,  "%s: no previousNode for indent of %d (%d: %s)",  buf,  0x22u);
          }

          *__error() = v528;
        }

        if (byte_1000E7D31) {
          v531 = dword_1000E74E0 <= 3;
        }
        else {
          v531 = 0;
        }
        if (v531)
        {
          v532 = *__error();
          v533 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"%s: no previousNode for indent of %d (%d: %s)",  "previousNode",  v172,  v642,  -[NSString UTF8String](v256, "UTF8String"));
          v534 = v533;
          if (v533)
          {
            v606 = (char *)CFStringGetCStringPtr(v533, 0x8000100u);
            if (v606)
            {
              v607 = 0LL;
            }

            else
            {
              v606 = (char *)calloc(0x400uLL, 1uLL);
              CFStringGetCString(v534, v606, 1024LL, 0x8000100u);
              v607 = v606;
            }

            if (qword_1000E7D38) {
              __int16 v609 = (FILE *)qword_1000E7D38;
            }
            else {
              __int16 v609 = __stderrp;
            }
            fprintf(v609, "%s\n", v606);
            if (v607) {
              free(v607);
            }
            CFRelease(v534);
          }

          else
          {
            v535 = (os_log_s *)sub_10002EFA0();
            if (os_log_type_enabled(v535, OS_LOG_TYPE_FAULT))
            {
              id v536 = -[NSString UTF8String](v256, "UTF8String");
              *(_DWORD *)buf = 136315906;
              *(void *)&uint8_t buf[4] = "previousNode";
              *(_WORD *)&_BYTE buf[12] = 1024;
              *(_DWORD *)&buf[14] = v172;
              *(_WORD *)&buf[18] = 1024;
              *(_DWORD *)&buf[20] = v642;
              *(_WORD *)&uint8_t buf[24] = 2080;
              *(void *)&buf[26] = v536;
              _os_log_fault_impl( (void *)&_mh_execute_header,  v535,  OS_LOG_TYPE_FAULT,  "Unable to format: %s: no previousNode for indent of %d (%d: %s)",  buf,  0x22u);
            }

            if (qword_1000E7D38) {
              v537 = (FILE *)qword_1000E7D38;
            }
            else {
              v537 = __stderrp;
            }
            fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v537);
          }

          *__error() = v532;
        }

        -[NSString UTF8String](v256, "UTF8String");
        sub_10002EE78( "-[SPTextualReportParser parseSpindumpFile:andReportToStream:]",  "SPTextualReportParser.m",  716,  "%s: no previousNode for indent of %d (%d: %s)",  v538,  v539,  v540,  v541,  (char)"previousNode");
LABEL_941:
        abort();
      }

      do
      {
        Weak = (id *)objc_loadWeak(Weak + 7);
        if (!Weak)
        {
          if (byte_1000E7D30)
          {
            v476 = *__error();
            v477 = (os_log_s *)sub_10002EFA0();
            if (os_log_type_enabled(v477, OS_LOG_TYPE_ERROR))
            {
              v478 = v676;
              v479 = -[NSString UTF8String](v256, "UTF8String");
              *(_DWORD *)buf = 136316162;
              *(void *)&uint8_t buf[4] = "previousNode";
              *(_WORD *)&_BYTE buf[12] = 1024;
              *(_DWORD *)&buf[14] = v478;
              *(_WORD *)&buf[18] = 1024;
              *(_DWORD *)&buf[20] = v640;
              *(_WORD *)&uint8_t buf[24] = 1024;
              *(_DWORD *)&buf[26] = v642;
              *(_WORD *)&buf[30] = 2080;
              *(void *)&_BYTE buf[32] = v479;
              _os_log_error_impl( (void *)&_mh_execute_header,  v477,  OS_LOG_TYPE_ERROR,  "%s: no previousNode for indent %d, previousIndentLevel %d (%d: %s)",  buf,  0x28u);
            }

            *__error() = v476;
          }

          if (byte_1000E7D31) {
            v480 = dword_1000E74E0 < 4;
          }
          else {
            v480 = 0;
          }
          if (v480)
          {
            v481 = *__error();
            v482 = v676;
            v483 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"%s: no previousNode for indent %d, previousIndentLevel %d (%d: %s)",  "previousNode",  v676,  v640,  v642,  -[NSString UTF8String](v256, "UTF8String"));
            v484 = v483;
            if (v483)
            {
              __int128 v599 = (char *)CFStringGetCStringPtr(v483, 0x8000100u);
              if (v599)
              {
                __int128 v600 = 0LL;
              }

              else
              {
                __int128 v599 = (char *)calloc(0x400uLL, 1uLL);
                CFStringGetCString(v484, v599, 1024LL, 0x8000100u);
                __int128 v600 = v599;
              }

              if (qword_1000E7D38) {
                unint64_t v603 = (FILE *)qword_1000E7D38;
              }
              else {
                unint64_t v603 = __stderrp;
              }
              fprintf(v603, "%s\n", v599);
              if (v600) {
                free(v600);
              }
              CFRelease(v484);
            }

            else
            {
              char v485 = (os_log_s *)sub_10002EFA0();
              if (os_log_type_enabled(v485, OS_LOG_TYPE_FAULT))
              {
                uint64_t v486 = -[NSString UTF8String](v256, "UTF8String");
                *(_DWORD *)buf = 136316162;
                *(void *)&uint8_t buf[4] = "previousNode";
                *(_WORD *)&_BYTE buf[12] = 1024;
                *(_DWORD *)&buf[14] = v482;
                *(_WORD *)&buf[18] = 1024;
                *(_DWORD *)&buf[20] = v640;
                *(_WORD *)&uint8_t buf[24] = 1024;
                *(_DWORD *)&buf[26] = v642;
                *(_WORD *)&buf[30] = 2080;
                *(void *)&_BYTE buf[32] = v486;
                _os_log_fault_impl( (void *)&_mh_execute_header,  v485,  OS_LOG_TYPE_FAULT,  "Unable to format: %s: no previousNode for indent %d, previousIndentLevel %d (%d: %s)",  buf,  0x28u);
              }

              if (qword_1000E7D38) {
                uint64_t v487 = (FILE *)qword_1000E7D38;
              }
              else {
                uint64_t v487 = __stderrp;
              }
              fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v487);
            }

            *__error() = v481;
          }

          -[NSString UTF8String](v256, "UTF8String");
          sub_10002EE78( "-[SPTextualReportParser parseSpindumpFile:andReportToStream:]",  "SPTextualReportParser.m",  721,  "%s: no previousNode for indent %d, previousIndentLevel %d (%d: %s)",  v488,  v489,  v490,  v491,  (char)"previousNode");
          goto LABEL_941;
        }

        __int16 v261 = v640 - 1;
        int v33 = (int)v640 <= (int)v676;
        v640 = (v640 - 1);
      }

      while (!v33);
      uint64_t v165 = v671;
      uint64_t v163 = v697;
      LODWORD(v640) = v261;
LABEL_478:
      Weak = sub_100072FB0((uint64_t)Weak, v674, 0LL, (void *)0xFFFFFFFFFFFFFFFFLL, v165, v163);
      uint64_t v171 = v651;
LABEL_577:
      if (Weak) {
LABEL_578:
      }
        *((_DWORD *)Weak + 3) += v673;
      else {
        Weak = 0LL;
      }
LABEL_579:
      uint64_t v161 = 0;
      uint64_t v153 = 0;
      if (v171) {
        id v310 = v676;
      }
      else {
        id v310 = v640;
      }
      v640 = v310;
      __int16 v622 = v258;
LABEL_583:
      objc_autoreleasePoolPop(context);
      if (v161 && v161 != 5) {
        goto LABEL_40;
      }
      a4 = v645;
    }

    LOBYTE(v671) = 0;
    LOBYTE(v676) = 0;
    int v156 = sub_10007A31C(v154, v155, v654, v681, v682);
    v634 = -[NSTextCheckingResult rangeWithName:](v155, "rangeWithName:", @"kernelDot");
    v697 = (id)-1LL;
    uint64_t v157 = sub_10007A3B0(v154, v642, v155, v657, v654, (unint64_t *)&v697);
    int v158 = (unint64_t)v157;
    id v627 = v156;
    v630 = v154;
    if (v616 == -1)
    {
      uint64_t v160 = -1LL;
      uint64_t v159 = (unint64_t)v611;
    }

    else
    {
      uint64_t v159 = 0LL;
      uint64_t v160 = -1LL;
      if (v697 == (id)v616 && v611 == v157)
      {
        uint64_t v159 = (unint64_t)v611;
        LOBYTE(v676) = 1;
        uint64_t v160 = v616;
      }
    }

    id v174 = -[NSTextCheckingResult rangeWithName:](v155, "rangeWithName:", @"symbolName");
    if (v174 == (id)0x7FFFFFFFFFFFFFFFLL) {
      int v175 = 0LL;
    }
    else {
      int v175 = -[NSString substringWithRange:](v630, "substringWithRange:", v174, v173);
    }
    int v177 = -[NSTextCheckingResult rangeWithName:](v155, "rangeWithName:", @"offsetIntoSymbol");
    if (v177 == (id)0x7FFFFFFFFFFFFFFFLL) {
      int v178 = -1LL;
    }
    else {
      int v178 = (int)sub_10007BD4C(-[NSString substringWithRange:](v630, "substringWithRange:", v177, v176));
    }
    id v179 = v697;
    LOBYTE(v671) = 0;
    *(void *)buf = _NSConcreteStackBlock;
    *(void *)&uint8_t buf[8] = 3221225472LL;
    *(void *)&uint8_t buf[16] = sub_10007F5E4;
    *(void *)&uint8_t buf[24] = &unk_1000D9DF0;
    *(void *)&_BYTE buf[32] = v643;
    *(void *)&buf[40] = v621;
    v713 = v654;
    v710 = v681;
    v711 = v682;
    v712 = v627;
    v714 = v634 != (id)0x7FFFFFFFFFFFFFFFLL;
    v707 = &v676;
    v708 = v697;
    *(void *)&buf[48] = v158;
    v704 = (int *)v657;
    v705 = v175;
    v706 = &v671;
    v709 = v178;
    sub_10007C8F8(v14, v642, (uint64_t)buf);
    int v180 = v676;
    if ((_BYTE)v676) {
      id v181 = v158;
    }
    else {
      id v181 = v159;
    }
    __int16 v611 = (id)v181;
    if ((_BYTE)v676) {
      id v182 = (uint64_t)v179;
    }
    else {
      id v182 = v160;
    }
    v616 = v182;
    char v183 = v671;
    id v184 = objc_autoreleasePoolPush();
    __int16 v186 = -[NSTextCheckingResult rangeWithName:](v155, "rangeWithName:", @"count");
    if (v186 == (id)0x7FFFFFFFFFFFFFFFLL)
    {
      if (byte_1000E7D30)
      {
        uint64_t v469 = *__error();
        uint64_t v470 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v470, OS_LOG_TYPE_ERROR))
        {
          -[NSString UTF8String](v630, "UTF8String");
          sub_1000942D0();
        }

        *__error() = v469;
      }

      if (byte_1000E7D31 && dword_1000E74E0 <= 3)
      {
        uint64_t v464 = *__error();
        uint64_t v465 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"%s: frame match with no count (%d: %s)",  "range.location != NSNotFound",  v642,  -[NSString UTF8String](v630, "UTF8String"));
        uint64_t v466 = v465;
        if (v465)
        {
          __int128 v542 = (char *)CFStringGetCStringPtr(v465, 0x8000100u);
          if (v542)
          {
            __int128 v543 = 0LL;
          }

          else
          {
            __int128 v542 = (char *)calloc(0x400uLL, 1uLL);
            CFStringGetCString(v466, v542, 1024LL, 0x8000100u);
            __int128 v543 = v542;
          }

          if (qword_1000E7D38) {
            v561 = (FILE *)qword_1000E7D38;
          }
          else {
            v561 = __stderrp;
          }
          fprintf(v561, "%s\n", v542);
          if (v543) {
            free(v543);
          }
          CFRelease(v466);
        }

        else
        {
          uint64_t v467 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v467, OS_LOG_TYPE_FAULT))
          {
            -[NSString UTF8String](v630, "UTF8String");
            sub_10009428C();
          }

          if (qword_1000E7D38) {
            uint64_t v468 = (FILE *)qword_1000E7D38;
          }
          else {
            uint64_t v468 = __stderrp;
          }
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v468);
        }

        *__error() = v464;
      }

      -[NSString UTF8String](v630, "UTF8String", v186);
      uint64_t v566 = "%s: frame match with no count (%d: %s)";
      v567 = 1553;
    }

    else
    {
      v639 = sub_10007BD4C(-[NSString substringWithRange:](v630, "substringWithRange:", v186, v185));
      if ((v654 & 1) != 0)
      {
        v649 = sub_10007EEDC(v630, v155, v158, (uint64_t)v179, v183 != 0, v180 != 0);
        int v187 = 0;
        uint64_t v188 = 0LL;
        LODWORD(v15_Block_object_dispose(va, 8) = 0;
        int v189 = 0LL;
        __int16 v624 = -1LL;
LABEL_363:
        objc_autoreleasePoolPop(v184);
        if (objc_msgSend(-[NSMutableArray firstObject](v649, "firstObject"), "length"))
        {
          id v210 = v649;
          __int16 v211 = v188;
          if (!v683)
          {
            if ((_DWORD)v158 && (_DWORD)v189)
            {
LABEL_369:
              id v212 = self->_startIndex;
              if (v212 && (int)v158 < v212)
              {
                v639 = v158 + v639 - v212;
                LODWORD(v15_Block_object_dispose(va, 8) = self->_startIndex;
              }

LABEL_372:
              if ((_DWORD)v189 && (int v213 = self->_endIndex) != 0 && (int)v189 > v213)
              {
                int v214 = v187;
                v639 = v639 - v189 + v213;
                int v189 = self->_endIndex;
              }

              else
              {
                int v214 = v187;
              }

              if (v639 <= 0)
              {
                v638 = v639 < 1;
                if ((_DWORD)v158)
                {
                  id v222 = self->_endIndex;
                  if (v222) {
                    __int16 v223 = (int)v158 <= v222;
                  }
                  else {
                    __int16 v223 = 1;
                  }
LABEL_393:
                  int v224 = !v223;
                  v610 |= v224;
                }

                goto LABEL_397;
              }

              if ((int)v627 > (int)v640 && (_DWORD)v627 != (_DWORD)v640 + 1)
              {
                if (byte_1000E7D30)
                {
                  int v215 = *__error();
                  id v216 = (os_log_s *)sub_10002EFA0();
                  if (os_log_type_enabled(v216, OS_LOG_TYPE_ERROR))
                  {
                    *(_DWORD *)buf = 67109378;
                    *(_DWORD *)&uint8_t buf[4] = v642;
                    *(_WORD *)&uint8_t buf[8] = 2112;
                    *(void *)&buf[10] = v630;
                    _os_log_error_impl( (void *)&_mh_execute_header,  v216,  OS_LOG_TYPE_ERROR,  "Parsing spindump text: Unexpected indent for line (%d: %@)",  buf,  0x12u);
                  }

                  *__error() = v215;
                }

                v638 = v639 < 1;
                uint64_t v161 = 2;
                if (byte_1000E7D31 && dword_1000E74E0 <= 3)
                {
                  int v217 = *__error();
                  int v218 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"Parsing spindump text: Unexpected indent for line (%d: %@)",  v642,  v630);
                  int v219 = v218;
                  if (v218)
                  {
                    id v220 = (char *)CFStringGetCStringPtr(v218, 0x8000100u);
                    if (v220)
                    {
                      __int16 v221 = 0LL;
                    }

                    else
                    {
                      id v220 = (char *)calloc(0x400uLL, 1uLL);
                      CFStringGetCString(v219, v220, 1024LL, 0x8000100u);
                      __int16 v221 = v220;
                    }

                    if (qword_1000E7D38) {
                      id v278 = (FILE *)qword_1000E7D38;
                    }
                    else {
                      id v278 = __stderrp;
                    }
                    fprintf(v278, "%s\n", v220);
                    if (v221) {
                      free(v221);
                    }
                    CFRelease(v219);
                  }

                  else
                  {
                    id v254 = (os_log_s *)sub_10002EFA0();
                    if (os_log_type_enabled(v254, OS_LOG_TYPE_FAULT))
                    {
                      *(_DWORD *)buf = 67109378;
                      *(_DWORD *)&uint8_t buf[4] = v642;
                      *(_WORD *)&uint8_t buf[8] = 2112;
                      *(void *)&buf[10] = v630;
                      _os_log_fault_impl( (void *)&_mh_execute_header,  v254,  OS_LOG_TYPE_FAULT,  "Unable to format: Parsing spindump text: Unexpected indent for line (%d: %@)",  buf,  0x12u);
                    }

                    if (qword_1000E7D38) {
                      __int16 v255 = (FILE *)qword_1000E7D38;
                    }
                    else {
                      __int16 v255 = __stderrp;
                    }
                    fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v255);
                  }

                  *__error() = v217;
                }

                goto LABEL_498;
              }

              if (self->_isHeavy == v683)
              {
                __int16 v225 = self->_omitFramesBelowSampleCount;
                if (v225 < 1 || v639 >= v225)
                {
                  id v226 = v619;
                  if (v619 <= 0)
                  {
                    id v226 = v214;
                    if (v214 <= 0) {
                      id v226 = vcvtpd_s64_f64(log10((double)v639)) + 2;
                    }
                  }

                  v619 = v226;
                  __int16 v227 = v622;
                  id v228 = (unsigned int *)&v22[8 * v622 - 8];
                  __int16 v229 = (8LL * (int)v622) | 4;
                  __int16 v613 = v158;
                  v615 = v188;
                  while (1)
                  {
                    int v230 = v227;
                    __int16 v231 = v229;
                    --v227;
                    id v232 = *v228;
                    v228 -= 2;
                    v229 -= 8LL;
                    if (v232 < v627)
                    {
                      __int16 v233 = v228[3];
                      goto LABEL_483;
                    }
                  }

                  __int16 v233 = 0;
LABEL_483:
                  __int16 v267 = 0LL;
                  id v268 = v233 + v627;
                  while (v267 < (unint64_t)-[NSMutableArray count](v649, "count"))
                  {
                    __int16 v269 = v189;
                    id v270 = -[NSMutableArray objectAtIndexedSubscript:](v649, "objectAtIndexedSubscript:", v267);
                    __int16 v271 = v682;
                    id v272 = v681;
                    __int16 v273 = (const char *)[v270 UTF8String];
                    id v274 = -[NSString UTF8String](v615, "UTF8String");
                    __int16 v275 = v272 + v271 * (v268 + v267);
                    int v189 = v269;
                    sub_10007BDB8( v645,  v275,  v634 != (id)0x7FFFFFFFFFFFFFFFLL,  v639,  v619,  v273,  v624,  v274,  v613,  v269);
                    ++v267;
                    unint64_t v6 = v617;
                  }

                  if ((unint64_t)-[NSMutableArray count](v649, "count") <= 1)
                  {
                    __int16 v622 = v230;
                  }

                  else
                  {
                    __int128 v22 = (char *)realloc(v22, 8LL * ((int)v230 + 1));
                    *(_DWORD *)&v22[v231 - 4] = v627;
                    id v276 = -[NSMutableArray count](v649, "count");
                    else {
                      __int16 v277 = *(_DWORD *)&v22[8 * (v230 - 1) + 4];
                    }
                    *(_DWORD *)&v22[v231] = v276 - 1 + v277;
                    __int16 v622 = v230 + 1;
                  }
                }

LABEL_548:
                uint64_t v161 = 0;
                uint64_t v153 = 0;
                v638 = 0;
                __int16 v297 = v627;
                goto LABEL_549;
              }

              if ((_DWORD)v627)
              {
                if (!Weak)
                {
                  if (byte_1000E7D30)
                  {
                    v509 = *__error();
                    v510 = (os_log_s *)sub_10002EFA0();
                    if (os_log_type_enabled(v510, OS_LOG_TYPE_ERROR))
                    {
                      id v511 = -[NSString UTF8String](v630, "UTF8String");
                      *(_DWORD *)buf = 136315906;
                      *(void *)&uint8_t buf[4] = "previousNode";
                      *(_WORD *)&_BYTE buf[12] = 1024;
                      *(_DWORD *)&buf[14] = v627;
                      *(_WORD *)&buf[18] = 1024;
                      *(_DWORD *)&buf[20] = v642;
                      *(_WORD *)&uint8_t buf[24] = 2080;
                      *(void *)&buf[26] = v511;
                      _os_log_error_impl( (void *)&_mh_execute_header,  v510,  OS_LOG_TYPE_ERROR,  "%s: no previousNode for indent of %d (%d: %s)",  buf,  0x22u);
                    }

                    *__error() = v509;
                  }

                  if (byte_1000E7D31 && dword_1000E74E0 <= 3)
                  {
                    v512 = *__error();
                    uint64_t v513 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"%s: no previousNode for indent of %d (%d: %s)",  "previousNode",  v627,  v642,  -[NSString UTF8String](v630, "UTF8String"));
                    v514 = v513;
                    if (v513)
                    {
                      v604 = (char *)CFStringGetCStringPtr(v513, 0x8000100u);
                      if (v604)
                      {
                        v605 = 0LL;
                      }

                      else
                      {
                        v604 = (char *)calloc(0x400uLL, 1uLL);
                        CFStringGetCString(v514, v604, 1024LL, 0x8000100u);
                        v605 = v604;
                      }

                      if (qword_1000E7D38) {
                        id v608 = (FILE *)qword_1000E7D38;
                      }
                      else {
                        id v608 = __stderrp;
                      }
                      fprintf(v608, "%s\n", v604);
                      if (v605) {
                        free(v605);
                      }
                      CFRelease(v514);
                    }

                    else
                    {
                      uint64_t v515 = (os_log_s *)sub_10002EFA0();
                      if (os_log_type_enabled(v515, OS_LOG_TYPE_FAULT))
                      {
                        id v516 = -[NSString UTF8String](v630, "UTF8String");
                        *(_DWORD *)buf = 136315906;
                        *(void *)&uint8_t buf[4] = "previousNode";
                        *(_WORD *)&_BYTE buf[12] = 1024;
                        *(_DWORD *)&buf[14] = v627;
                        *(_WORD *)&buf[18] = 1024;
                        *(_DWORD *)&buf[20] = v642;
                        *(_WORD *)&uint8_t buf[24] = 2080;
                        *(void *)&buf[26] = v516;
                        _os_log_fault_impl( (void *)&_mh_execute_header,  v515,  OS_LOG_TYPE_FAULT,  "Unable to format: %s: no previousNode for indent of %d (%d: %s)",  buf,  0x22u);
                      }

                      if (qword_1000E7D38) {
                        v517 = (FILE *)qword_1000E7D38;
                      }
                      else {
                        v517 = __stderrp;
                      }
                      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v517);
                    }

                    *__error() = v512;
                  }

                  -[NSString UTF8String](v630, "UTF8String");
                  sub_10002EE78( "-[SPTextualReportParser parseSpindumpFile:andReportToStream:]",  "SPTextualReportParser.m",  578,  "%s: no previousNode for indent of %d (%d: %s)",  v518,  v519,  v520,  v521,  (char)"previousNode");
                  goto LABEL_887;
                }

                if ((int)v640 >= (int)v627)
                {
                  while (1)
                  {
                    Weak = (id *)objc_loadWeak(Weak + 7);
                    if (!Weak) {
                      break;
                    }
                    int v33 = (int)v640 <= (int)v627;
                    v640 = (v640 - 1);
                    if (v33) {
                      goto LABEL_423;
                    }
                  }

                  if (byte_1000E7D30)
                  {
                    uint64_t v442 = *__error();
                    uint64_t v443 = (os_log_s *)sub_10002EFA0();
                    if (os_log_type_enabled(v443, OS_LOG_TYPE_ERROR))
                    {
                      uint64_t v444 = -[NSString UTF8String](v630, "UTF8String");
                      *(_DWORD *)buf = 136316162;
                      *(void *)&uint8_t buf[4] = "previousNode";
                      *(_WORD *)&_BYTE buf[12] = 1024;
                      *(_DWORD *)&buf[14] = v627;
                      *(_WORD *)&buf[18] = 1024;
                      *(_DWORD *)&buf[20] = v640;
                      *(_WORD *)&uint8_t buf[24] = 1024;
                      *(_DWORD *)&buf[26] = v642;
                      *(_WORD *)&buf[30] = 2080;
                      *(void *)&_BYTE buf[32] = v444;
                      _os_log_error_impl( (void *)&_mh_execute_header,  v443,  OS_LOG_TYPE_ERROR,  "%s: no previousNode for indent %d, previousIndentLevel %d (%d: %s)",  buf,  0x28u);
                    }

                    *__error() = v442;
                  }

                  if (byte_1000E7D31) {
                    uint64_t v445 = dword_1000E74E0 <= 3;
                  }
                  else {
                    uint64_t v445 = 0;
                  }
                  if (v445)
                  {
                    uint64_t v446 = *__error();
                    uint64_t v447 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"%s: no previousNode for indent %d, previousIndentLevel %d (%d: %s)",  "previousNode",  v627,  v640,  v642,  -[NSString UTF8String](v630, "UTF8String"));
                    v448 = v447;
                    if (v447)
                    {
                      __int128 v594 = (char *)CFStringGetCStringPtr(v447, 0x8000100u);
                      if (v594)
                      {
                        __int128 v595 = 0LL;
                      }

                      else
                      {
                        __int128 v594 = (char *)calloc(0x400uLL, 1uLL);
                        CFStringGetCString(v448, v594, 1024LL, 0x8000100u);
                        __int128 v595 = v594;
                      }

                      if (qword_1000E7D38) {
                        __int128 v601 = (FILE *)qword_1000E7D38;
                      }
                      else {
                        __int128 v601 = __stderrp;
                      }
                      fprintf(v601, "%s\n", v594);
                      if (v595) {
                        free(v595);
                      }
                      CFRelease(v448);
                    }

                    else
                    {
                      int v449 = (os_log_s *)sub_10002EFA0();
                      if (os_log_type_enabled(v449, OS_LOG_TYPE_FAULT))
                      {
                        v450 = -[NSString UTF8String](v630, "UTF8String");
                        *(_DWORD *)buf = 136316162;
                        *(void *)&uint8_t buf[4] = "previousNode";
                        *(_WORD *)&_BYTE buf[12] = 1024;
                        *(_DWORD *)&buf[14] = v627;
                        *(_WORD *)&buf[18] = 1024;
                        *(_DWORD *)&buf[20] = v640;
                        *(_WORD *)&uint8_t buf[24] = 1024;
                        *(_DWORD *)&buf[26] = v642;
                        *(_WORD *)&buf[30] = 2080;
                        *(void *)&_BYTE buf[32] = v450;
                        _os_log_fault_impl( (void *)&_mh_execute_header,  v449,  OS_LOG_TYPE_FAULT,  "Unable to format: %s: no previousNode for indent %d, previousIndentLevel %d (%d: %s)",  buf,  0x28u);
                      }

                      if (qword_1000E7D38) {
                        int v451 = (FILE *)qword_1000E7D38;
                      }
                      else {
                        int v451 = __stderrp;
                      }
                      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v451);
                    }

                    *__error() = v446;
                  }

                  -[NSString UTF8String](v630, "UTF8String");
                  sub_10002EE78( "-[SPTextualReportParser parseSpindumpFile:andReportToStream:]",  "SPTextualReportParser.m",  583,  "%s: no previousNode for indent %d, previousIndentLevel %d (%d: %s)",  v452,  v453,  v454,  v455,  (char)"previousNode");
LABEL_887:
                  abort();
                }

LABEL_423:
                Weak = sub_100072FB0((uint64_t)Weak, v634 != (id)0x7FFFFFFFFFFFFFFFLL, v649, (void *)v624, v188, 0LL);
              }

              else
              {
                if (obj)
                {
                  v679 = 0u;
                  v680 = 0u;
                  v677 = 0u;
                  v678 = 0u;
                  __int16 v251 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( obj,  "countByEnumeratingWithState:objects:count:",  &v677,  v701,  16LL);
                  if (v251)
                  {
                    id v252 = *(void *)v678;
LABEL_448:
                    __int16 v253 = 0LL;
                    while (1)
                    {
                      if (*(void *)v678 != v252) {
                        objc_enumerationMutation(obj);
                      }
                      Weak = *(id **)(*((void *)&v677 + 1) + 8 * v253);
                      if ((sub_100073138( (uint64_t)Weak,  v634 != (id)0x7FFFFFFFFFFFFFFFLL,  v649,  v624,  (uint64_t)v188,  0LL) & 1) != 0) {
                        break;
                      }
                      if (v251 == (id)++v253)
                      {
                        __int16 v251 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( obj,  "countByEnumeratingWithState:objects:count:",  &v677,  v701,  16LL);
                        if (v251) {
                          goto LABEL_448;
                        }
                        goto LABEL_525;
                      }
                    }

                    if (Weak) {
                      goto LABEL_527;
                    }
                  }
                }

                else
                {
                  id obj = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
                }

LABEL_525:
                Weak = sub_100072B04( (uint64_t)&OBJC_CLASS___SPTreeNode,  0LL,  v634 != (id)0x7FFFFFFFFFFFFFFFLL,  v649,  (void *)v624,  v188,  0LL);
                -[NSMutableArray addObject:](obj, "addObject:", Weak);
              }

              if (Weak) {
LABEL_527:
              }
                *((_DWORD *)Weak + 3) += v639;
              else {
                Weak = 0LL;
              }
              goto LABEL_548;
            }

            if (byte_1000E7D30)
            {
              id v234 = *__error();
              __int16 v235 = (os_log_s *)sub_10002EFA0();
              if (os_log_type_enabled(v235, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)buf = 67109378;
                *(_DWORD *)&uint8_t buf[4] = v642;
                *(_WORD *)&uint8_t buf[8] = 2112;
                *(void *)&buf[10] = v630;
                _os_log_error_impl( (void *)&_mh_execute_header,  v235,  OS_LOG_TYPE_ERROR,  "Parsing spindump text: No start/end index for frame line in timeline report (%d: %@)",  buf,  0x12u);
              }

              *__error() = v234;
            }

            if (byte_1000E7D31 && dword_1000E74E0 <= 3)
            {
              id v614 = *__error();
              id v236 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"Parsing spindump text: No start/end index for frame line in timeline report (%d: %@)",  v642,  v630);
              __int16 v237 = v236;
              if (v236)
              {
                id v238 = (char *)CFStringGetCStringPtr(v236, 0x8000100u);
                if (v238)
                {
                  __int16 v239 = 0LL;
                }

                else
                {
                  id v238 = (char *)calloc(0x400uLL, 1uLL);
                  CFStringGetCString(v237, v238, 1024LL, 0x8000100u);
                  __int16 v239 = v238;
                }

                if (qword_1000E7D38) {
                  __int16 v293 = (FILE *)qword_1000E7D38;
                }
                else {
                  __int16 v293 = __stderrp;
                }
                fprintf(v293, "%s\n", v238);
                if (v239) {
                  free(v239);
                }
                CFRelease(v237);
              }

              else
              {
                __int16 v279 = (os_log_s *)sub_10002EFA0();
                if (os_log_type_enabled(v279, OS_LOG_TYPE_FAULT))
                {
                  *(_DWORD *)buf = 67109378;
                  *(_DWORD *)&uint8_t buf[4] = v642;
                  *(_WORD *)&uint8_t buf[8] = 2112;
                  *(void *)&buf[10] = v630;
                  _os_log_fault_impl( (void *)&_mh_execute_header,  v279,  OS_LOG_TYPE_FAULT,  "Unable to format: Parsing spindump text: No start/end index for frame line in timeline report (%d: %@)",  buf,  0x12u);
                }

                if (qword_1000E7D38) {
                  id v280 = (FILE *)qword_1000E7D38;
                }
                else {
                  id v280 = __stderrp;
                }
                fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v280);
              }

              *__error() = v614;
            }
          }

          if (!(_DWORD)v158) {
            goto LABEL_372;
          }
          goto LABEL_369;
        }

        if (byte_1000E7D30)
        {
          v427 = *__error();
          v428 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v428, OS_LOG_TYPE_ERROR))
          {
            uint64_t v429 = objc_msgSend(-[NSMutableArray debugDescription](v649, "debugDescription"), "UTF8String");
            uint64_t v430 = -[NSString UTF8String](v630, "UTF8String");
            *(_DWORD *)buf = 136315906;
            *(void *)&uint8_t buf[4] = "frameBodies.firstObject.length > 0";
            *(_WORD *)&_BYTE buf[12] = 2080;
            *(void *)&buf[14] = v429;
            *(_WORD *)&buf[22] = 1024;
            *(_DWORD *)&uint8_t buf[24] = v642;
            *(_WORD *)&buf[28] = 2080;
            *(void *)&buf[30] = v430;
            _os_log_error_impl( (void *)&_mh_execute_header,  v428,  OS_LOG_TYPE_ERROR,  "%s: No frame bodies in %s (%d: %s)",  buf,  0x26u);
          }

          *__error() = v427;
        }

        if (byte_1000E7D31 && dword_1000E74E0 <= 3)
        {
          uint64_t v431 = *__error();
          uint64_t v432 = CFStringCreateWithFormat( kCFAllocatorDefault,  0,  @"%s: No frame bodies in %s (%d: %s)",  "frameBodies.firstObject.length > 0",  objc_msgSend(-[NSMutableArray debugDescription](v649, "debugDescription"), "UTF8String"),  v642,  -[NSString UTF8String](v630, "UTF8String"));
          uint64_t v433 = v432;
          if (v432)
          {
            __int128 v592 = (char *)CFStringGetCStringPtr(v432, 0x8000100u);
            if (v592)
            {
              __int128 v593 = 0LL;
            }

            else
            {
              __int128 v592 = (char *)calloc(0x400uLL, 1uLL);
              CFStringGetCString(v433, v592, 1024LL, 0x8000100u);
              __int128 v593 = v592;
            }

            if (qword_1000E7D38) {
              __int128 v598 = (FILE *)qword_1000E7D38;
            }
            else {
              __int128 v598 = __stderrp;
            }
            fprintf(v598, "%s\n", v592);
            if (v593) {
              free(v593);
            }
            CFRelease(v433);
          }

          else
          {
            uint64_t v434 = (os_log_s *)sub_10002EFA0();
            if (os_log_type_enabled(v434, OS_LOG_TYPE_FAULT))
            {
              uint64_t v435 = objc_msgSend(-[NSMutableArray debugDescription](v649, "debugDescription"), "UTF8String");
              v436 = -[NSString UTF8String](v630, "UTF8String");
              *(_DWORD *)buf = 136315906;
              *(void *)&uint8_t buf[4] = "frameBodies.firstObject.length > 0";
              *(_WORD *)&_BYTE buf[12] = 2080;
              *(void *)&buf[14] = v435;
              *(_WORD *)&buf[22] = 1024;
              *(_DWORD *)&uint8_t buf[24] = v642;
              *(_WORD *)&buf[28] = 2080;
              *(void *)&buf[30] = v436;
              _os_log_fault_impl( (void *)&_mh_execute_header,  v434,  OS_LOG_TYPE_FAULT,  "Unable to format: %s: No frame bodies in %s (%d: %s)",  buf,  0x26u);
            }

            if (qword_1000E7D38) {
              int v437 = (FILE *)qword_1000E7D38;
            }
            else {
              int v437 = __stderrp;
            }
            fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v437);
          }

          *__error() = v431;
        }

        objc_msgSend(-[NSMutableArray debugDescription](v649, "debugDescription"), "UTF8String");
        -[NSString UTF8String](v630, "UTF8String");
        sub_10002EE78( "-[SPTextualReportParser parseSpindumpFile:andReportToStream:]",  "SPTextualReportParser.m",  484,  "%s: No frame bodies in %s (%d: %s)",  v438,  v439,  v440,  v441,  (char)"frameBodies.firstObject.length > 0");
LABEL_1086:
        abort();
      }

      if (-[NSTextCheckingResult rangeWithName:](v155, "rangeWithName:", @"countAndWhitespace") != (id)0x7FFFFFFFFFFFFFFFLL)
      {
        int v187 = v190;
        unsigned __int8 v192 = -[NSTextCheckingResult rangeWithName:](v155, "rangeWithName:", @"address");
        if (v192 == (id)0x7FFFFFFFFFFFFFFFLL)
        {
          __int16 v624 = 0LL;
          if (v158 && v179 != (id)0x7FFFFFFFFFFFFFFFLL) {
            __int16 v624 = (unint64_t)v179 + *(void *)(v158 + 56);
          }
        }

        else
        {
          __int16 v624 = sub_10007BD4C(-[NSString substringWithRange:](v630, "substringWithRange:", v192, v191));
        }

        v649 = sub_10007EEDC(v630, v155, v158, (uint64_t)v179, v183 != 0, v180 != 0);
        time_t v194 = -[NSTextCheckingResult rangeWithName:](v155, "rangeWithName:", @"stateInfo");
        if (v194 == (id)0x7FFFFFFFFFFFFFFFLL) {
          uint64_t v188 = 0LL;
        }
        else {
          uint64_t v188 = -[NSString substringWithRange:](v630, "substringWithRange:", v194, v193);
        }
        id v196 = -[NSTextCheckingResult rangeWithName:](v155, "rangeWithName:", @"startIndex");
        if (v196 == (id)0x7FFFFFFFFFFFFFFFLL)
        {
          LODWORD(v15_Block_object_dispose(va, 8) = 0;
          int v189 = 0LL;
        }

        else
        {
          int v158 = sub_10007BD4C(-[NSString substringWithRange:](v630, "substringWithRange:", v196, v195));
          unsigned int v198 = -[NSTextCheckingResult rangeWithName:](v155, "rangeWithName:", @"endIndex");
          if (v198 == (id)0x7FFFFFFFFFFFFFFFLL) {
            int v189 = v158;
          }
          else {
            int v189 = sub_10007BD4C(-[NSString substringWithRange:](v630, "substringWithRange:", v198, v197));
          }
        }

        goto LABEL_363;
      }

      if (byte_1000E7D30)
      {
        id v503 = *__error();
        uint64_t v504 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v504, OS_LOG_TYPE_ERROR))
        {
          -[NSString UTF8String](v630, "UTF8String");
          sub_100094358();
        }

        *__error() = v503;
      }

      if (byte_1000E7D31 && dword_1000E74E0 <= 3)
      {
        v471 = *__error();
        v472 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"%s: frame match with no count and whitespace (%d: %s)",  "range.location != NSNotFound",  v642,  -[NSString UTF8String](v630, "UTF8String"));
        v473 = v472;
        if (v472)
        {
          v557 = (char *)CFStringGetCStringPtr(v472, 0x8000100u);
          if (v557)
          {
            v558 = 0LL;
          }

          else
          {
            v557 = (char *)calloc(0x400uLL, 1uLL);
            CFStringGetCString(v473, v557, 1024LL, 0x8000100u);
            v558 = v557;
          }

          if (qword_1000E7D38) {
            uint64_t v574 = (FILE *)qword_1000E7D38;
          }
          else {
            uint64_t v574 = __stderrp;
          }
          fprintf(v574, "%s\n", v557);
          if (v558) {
            free(v558);
          }
          CFRelease(v473);
        }

        else
        {
          v474 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v474, OS_LOG_TYPE_FAULT))
          {
            -[NSString UTF8String](v630, "UTF8String");
            sub_100094314();
          }

          if (qword_1000E7D38) {
            v475 = (FILE *)qword_1000E7D38;
          }
          else {
            v475 = __stderrp;
          }
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v475);
        }

        *__error() = v471;
      }

      -[NSString UTF8String](v630, "UTF8String");
      uint64_t v566 = "%s: frame match with no count and whitespace (%d: %s)";
      v567 = 1557;
    }

    sub_10002EE78( "ParseFrameLine",  "SPTextualReportParser.m",  v567,  v566,  v562,  v563,  v564,  v565,  (char)"range.location != NSNotFound");
    goto LABEL_1086;
  }

  __int128 v22 = 0LL;
  id obj = 0LL;
LABEL_789:
  __int128 v21 = 1;
LABEL_807:
  int v404 = (void *)v694[3];
  if (v404) {
    free(v404);
  }
  if (v14) {
    fclose(v14);
  }
  if (v22) {
    free(v22);
  }

  _Block_object_dispose(&v689, 8);
  _Block_object_dispose(&v693, 8);
  objc_autoreleasePoolPop(v6);
  return v21 & 1;
}

void sub_1000797CC(_Unwind_Exception *a1)
{
}

void *sub_100079C04( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = a1 + 32;
  uint64_t v10 = *(void *)(*(void *)(a1 + 32) + 8LL);
  int v11 = *(_DWORD *)(v10 + 24);
  if (v11)
  {
    *(_DWORD *)(v10 + 24) = 2 * v11;
    int v12 = *(_DWORD *)(*(void *)(*(void *)v9 + 8LL) + 24LL);
    if (v12 <= 0)
    {
      if (byte_1000E7D30)
      {
        int v13 = *__error();
        id v14 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
          sub_100094720();
        }
        *__error() = v13;
      }

      if (byte_1000E7D31) {
        BOOL v15 = dword_1000E74E0 <= 3;
      }
      else {
        BOOL v15 = 0;
      }
      if (v15)
      {
        int v16 = *__error();
        uint64_t v17 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"%s: bufSize overflow (%d)",  "bufSize > 0",  *(unsigned int *)(*(void *)(*(void *)v9 + 8LL) + 24LL));
        if (v17)
        {
          uint64_t v36 = v17;
          CStringPtr = CFStringGetCStringPtr(v17, 0x8000100u);
          if (CStringPtr)
          {
            uint64_t v38 = (char *)CStringPtr;
            __int128 v39 = 0LL;
          }

          else
          {
            uint64_t v38 = (char *)calloc(0x400uLL, 1uLL);
            CFStringGetCString(v36, v38, 1024LL, 0x8000100u);
            __int128 v39 = v38;
          }

          if (qword_1000E7D38) {
            unint64_t v40 = (FILE *)qword_1000E7D38;
          }
          else {
            unint64_t v40 = __stderrp;
          }
          fprintf(v40, "%s\n", v38);
          if (v39) {
            free(v39);
          }
          CFRelease(v36);
        }

        else
        {
          objc_super v18 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v18, OS_LOG_TYPE_FAULT)) {
            sub_1000946B0();
          }
          if (qword_1000E7D38) {
            BOOL v19 = (FILE *)qword_1000E7D38;
          }
          else {
            BOOL v19 = __stderrp;
          }
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v19);
        }

        *__error() = v16;
      }

      sub_10002EE78( "-[SPTextualReportParser parseSpindumpFile:andReportToStream:]_block_invoke",  "SPTextualReportParser.m",  287,  "%s: bufSize overflow (%d)",  a5,  a6,  a7,  a8,  (char)"bufSize > 0");
      goto LABEL_56;
    }
  }

  else
  {
    *(_DWORD *)(v10 + 24) = 0x4000;
    int v12 = *(_DWORD *)(*(void *)(*(void *)v9 + 8LL) + 24LL);
  }

  uint64_t result = reallocf(*(void **)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL), v12);
  *(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = result;
  if (!*(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL))
  {
    if (byte_1000E7D30)
    {
      int v25 = *__error();
      int v26 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR)) {
        sub_100094640();
      }
      *__error() = v25;
    }

    if (byte_1000E7D31 && dword_1000E74E0 <= 3)
    {
      int v27 = *__error();
      unsigned int v28 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"%s: Unable to allocate %d buffer",  "buf",  *(unsigned int *)(*(void *)(*(void *)v9 + 8LL) + 24LL));
      if (v28)
      {
        NSUInteger v31 = v28;
        NSUInteger v32 = CFStringGetCStringPtr(v28, 0x8000100u);
        if (v32)
        {
          int v33 = (char *)v32;
          BOOL v34 = 0LL;
        }

        else
        {
          int v33 = (char *)calloc(0x400uLL, 1uLL);
          CFStringGetCString(v31, v33, 1024LL, 0x8000100u);
          BOOL v34 = v33;
        }

        if (qword_1000E7D38) {
          unsigned int v35 = (FILE *)qword_1000E7D38;
        }
        else {
          unsigned int v35 = __stderrp;
        }
        fprintf(v35, "%s\n", v33);
        if (v34) {
          free(v34);
        }
        CFRelease(v31);
      }

      else
      {
        BOOL v29 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v29, OS_LOG_TYPE_FAULT)) {
          sub_1000945D0();
        }
        if (qword_1000E7D38) {
          int v30 = (FILE *)qword_1000E7D38;
        }
        else {
          int v30 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v30);
      }

      *__error() = v27;
    }

    sub_10002EE78( "-[SPTextualReportParser parseSpindumpFile:andReportToStream:]_block_invoke",  "SPTextualReportParser.m",  290,  "%s: Unable to allocate %d buffer",  v21,  v22,  v23,  v24,  (char)"buf");
LABEL_56:
    abort();
  }

  return result;
}

void sub_10007A048(FILE *a1, uint64_t a2, uint64_t a3, char a4, char a5, uint64_t a6)
{
  context = objc_autoreleasePoolPush();
  id v12 = +[NSMutableDictionary dictionary](&OBJC_CLASS___NSMutableDictionary, "dictionary");
  id v13 = +[NSMutableDictionary dictionary](&OBJC_CLASS___NSMutableDictionary, "dictionary");
  v27[0] = 0LL;
  v27[1] = v27;
  v27[2] = 0x2020000000LL;
  char v28 = a5;
  id v14 = +[NSMutableSet set](&OBJC_CLASS___NSMutableSet, "set");
  uint64_t v21 = 0LL;
  uint64_t v22 = &v21;
  uint64_t v23 = 0x3052000000LL;
  uint64_t v24 = sub_10007E4F0;
  int v25 = sub_10007E500;
  uint64_t v26 = 0LL;
  BOOL v15 = sub_10007A220(a1, 0, a3, a4);
  void v22[5] = (uint64_t)v15;
  v18[0] = _NSConcreteStackBlock;
  v18[1] = 3221225472LL;
  v18[2] = sub_10007E50C;
  v18[3] = &unk_1000D9D28;
  char v19 = a5;
  char v20 = a4;
  v18[9] = v13;
  v18[10] = v27;
  v18[11] = &v21;
  v18[12] = a1;
  v18[4] = a6;
  v18[5] = a3;
  void v18[6] = a2;
  v18[7] = v12;
  v18[8] = v14;
  sub_10007C8F8(a1, 0, (uint64_t)v18);

  v17[0] = _NSConcreteStackBlock;
  v17[1] = 3221225472LL;
  v17[2] = sub_10007E854;
  v17[3] = &unk_1000D9D78;
  v17[4] = v14;
  v17[5] = v13;
  [v12 enumerateKeysAndObjectsUsingBlock:v17];
  _Block_object_dispose(&v21, 8);
  _Block_object_dispose(v27, 8);
  objc_autoreleasePoolPop(context);
}

void sub_10007A1F4(_Unwind_Exception *a1)
{
}

NSMutableArray *sub_10007A220(FILE *a1, int a2, uint64_t a3, char a4)
{
  unint64_t v8 = objc_autoreleasePoolPush();
  uint64_t v9 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
  uint64_t v13 = 0LL;
  id v14 = &v13;
  uint64_t v15 = 0x2020000000LL;
  char v16 = 0;
  v11[0] = _NSConcreteStackBlock;
  v11[1] = 3221225472LL;
  v11[2] = sub_10007CFDC;
  v11[3] = &unk_1000D9CE0;
  v11[5] = v9;
  v11[6] = &v13;
  v11[4] = a3;
  char v12 = a4;
  sub_10007C8F8(a1, a2, (uint64_t)v11);
  if (!*((_BYTE *)v14 + 24))
  {

    uint64_t v9 = 0LL;
  }

  _Block_object_dispose(&v13, 8);
  objc_autoreleasePoolPop(v8);
  return v9;
}

void sub_10007A304( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

unint64_t sub_10007A31C(void *a1, void *a2, int a3, int a4, int a5)
{
  if (a3)
  {
    id v6 = [a2 rangeWithName:@"indentCount"];
    if (v6 == (id)0x7FFFFFFFFFFFFFFFLL) {
      return 0xFFFFFFFFLL;
    }
    else {
      return sub_10007BD4C(objc_msgSend(a1, "substringWithRange:", v6, v7));
    }
  }

  else
  {
    if ([a2 rangeWithName:@"indentWhitespace"] == (id)0x7FFFFFFFFFFFFFFFLL) {
      unint64_t result = 0xFFFFFFFFLL;
    }
    else {
      unint64_t result = v11;
    }
    if ((result & 0x80000000) == 0) {
      return (((int)result - a4) / a5);
    }
  }

  return result;
}

id sub_10007A3B0(void *a1, uint64_t a2, void *a3, void *a4, int a5, unint64_t *a6)
{
  char v12 = objc_autoreleasePoolPush();
  uint64_t v13 = v12;
  *a6 = -1LL;
  if (a5)
  {
    id v14 = [a3 rangeWithName:@"binaryIndex"];
    if (v14 == (id)0x7FFFFFFFFFFFFFFFLL) {
      goto LABEL_3;
    }
    unint64_t v25 = sub_10007BD4C(objc_msgSend(a1, "substringWithRange:", v14, v15));
    if (v25 < (unint64_t)[a4 count])
    {
      id v16 = [a4 objectAtIndexedSubscript:v25];
      id v26 = [a3 rangeWithName:@"offsetIntoBinary"];
      if (v26 == (id)0x7FFFFFFFFFFFFFFFLL)
      {
        if (byte_1000E7D30)
        {
          int v141 = *__error();
          uint64_t v142 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v142, OS_LOG_TYPE_ERROR)) {
            sub_100094804();
          }
          *__error() = v141;
        }

        if (byte_1000E7D31 && dword_1000E74E0 <= 3)
        {
          int v143 = *__error();
          int v144 = CFStringCreateWithFormat( kCFAllocatorDefault,  0,  @"%s: load info has binary but no offset into binary (%d: %s)",  "range.location != NSNotFound",  a2,  [a1 UTF8String]);
          if (v144)
          {
            uint64_t v153 = v144;
            CStringPtr = CFStringGetCStringPtr(v144, 0x8000100u);
            if (CStringPtr)
            {
              int v155 = (char *)CStringPtr;
              int v156 = 0LL;
            }

            else
            {
              int v155 = (char *)calloc(0x400uLL, 1uLL);
              CFStringGetCString(v153, v155, 1024LL, 0x8000100u);
              int v156 = v155;
            }

            if (qword_1000E7D38) {
              uint64_t v157 = (FILE *)qword_1000E7D38;
            }
            else {
              uint64_t v157 = __stderrp;
            }
            fprintf(v157, "%s\n", v155);
            if (v156) {
              free(v156);
            }
            CFRelease(v153);
          }

          else
          {
            id v145 = (os_log_s *)sub_10002EFA0();
            if (os_log_type_enabled(v145, OS_LOG_TYPE_FAULT)) {
              sub_100094790();
            }
            if (qword_1000E7D38) {
              BOOL v146 = (FILE *)qword_1000E7D38;
            }
            else {
              BOOL v146 = __stderrp;
            }
            fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v146);
          }

          *__error() = v143;
        }

        [a1 UTF8String];
        sub_10002EE78( "LoadInfoForFrameLine",  "SPTextualReportParser.m",  1117,  "%s: load info has binary but no offset into binary (%d: %s)",  v158,  v159,  v160,  v161,  (char)"range.location != NSNotFound");
        goto LABEL_284;
      }

      id v28 = v26;
      BOOL v29 = a1;
      goto LABEL_218;
    }

    if (byte_1000E7D30)
    {
      uint64_t v52 = v13;
      int v53 = *__error();
      unsigned int v54 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v54, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 134218754;
        id v193 = (id)v25;
        __int16 v194 = 2048;
        *(void *)int v195 = [a4 count];
        *(_WORD *)&v195[8] = 1024;
        *(_DWORD *)&v195[10] = a2;
        *(_WORD *)&v195[14] = 2112;
        *(void *)&v195[16] = a1;
        _os_log_error_impl( (void *)&_mh_execute_header,  v54,  OS_LOG_TYPE_ERROR,  "Parsing spindump text: corrupt condensed file, frame line has out-of-bounds binary index %lu (%lu binaries) (%d: %@)",  buf,  0x26u);
      }

      *__error() = v53;
      uint64_t v13 = v52;
    }

    if (!byte_1000E7D31 || dword_1000E74E0 > 3)
    {
LABEL_3:
      id v16 = 0LL;
      goto LABEL_220;
    }

    int v48 = *__error();
    __int128 v49 = CFStringCreateWithFormat( kCFAllocatorDefault,  0,  @"Parsing spindump text: corrupt condensed file, frame line has out-of-bounds binary index %lu (%lu binaries) (%d: %@)",  v25,  [a4 count],  a2,  a1);
    if (v49) {
      goto LABEL_107;
    }
    double v56 = (os_log_s *)sub_10002EFA0();
    if (!os_log_type_enabled(v56, OS_LOG_TYPE_FAULT)) {
      goto LABEL_165;
    }
    id v57 = [a4 count];
    *(_DWORD *)buf = 134218754;
    id v193 = (id)v25;
    __int16 v194 = 2048;
    *(void *)int v195 = v57;
    *(_WORD *)&v195[8] = 1024;
    *(_DWORD *)&v195[10] = a2;
    *(_WORD *)&v195[14] = 2112;
    *(void *)&v195[16] = a1;
    uint64_t v51 = "Unable to format: Parsing spindump text: corrupt condensed file, frame line has out-of-bounds binary index %lu"
          " (%lu binaries) (%d: %@)";
    double v58 = v56;
    uint32_t v59 = 38;
    goto LABEL_164;
  }

  uint64_t v17 = v12;
  id v18 = [a3 rangeWithName:@"address"];
  if (v18 != (id)0x7FFFFFFFFFFFFFFFLL)
  {
    int v30 = a1;
    unint64_t v31 = sub_10007BD4C(objc_msgSend(a1, "substringWithRange:", v18, v19));
    v190[0] = _NSConcreteStackBlock;
    v190[1] = 3221225472LL;
    v190[2] = sub_10007E4CC;
    v190[3] = &unk_1000D9D00;
    v190[4] = v31;
    unint64_t v32 = SABinarySearchArray(a4, 1280LL, v190);
    if (v32 >= (unint64_t)[a4 count])
    {
      id v16 = 0LL;
      uint64_t v13 = v17;
    }

    else
    {
      int v33 = [a4 objectAtIndexedSubscript:v32];
      if (v33) {
        unint64_t v34 = v33[7];
      }
      else {
        unint64_t v34 = 0LL;
      }
      uint64_t v13 = v17;
      if (v34 <= v31) {
        id v16 = v33;
      }
      else {
        id v16 = 0LL;
      }
      if (v16) {
        goto LABEL_64;
      }
    }

    if (v32)
    {
      id v60 = [a4 objectAtIndexedSubscript:v32 - 1];
      if (v60)
      {
        id v16 = v60;
        if (*((void *)v60 + 8) - 1LL >= v31) {
          goto LABEL_65;
        }
      }

      goto LABEL_61;
    }

LABEL_64:
    if (v16)
    {
LABEL_65:
      unint64_t v24 = v31 - *((void *)v16 + 7);
      goto LABEL_219;
    }

LABEL_61:
    if ([a3 rangeWithName:@"binaryName"] == (id)0x7FFFFFFFFFFFFFFFLL
      && [a3 rangeWithName:@"binaryUuid"] == (id)0x7FFFFFFFFFFFFFFFLL)
    {
      id v16 = 0LL;
      goto LABEL_109;
    }

    if (byte_1000E7D30)
    {
      int v61 = *__error();
      unsigned int v62 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v62, OS_LOG_TYPE_ERROR)) {
        sub_100094A3C();
      }
      *__error() = v61;
    }

    id v16 = 0LL;
    uint64_t v13 = v17;
    if (!byte_1000E7D31 || dword_1000E74E0 > 3) {
      goto LABEL_220;
    }
    int v48 = *__error();
    __int128 v49 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"Parsing spindump text: Unable to find load info for (%d: %@)",  a2,  v30);
    if (!v49)
    {
      int v63 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v63, OS_LOG_TYPE_FAULT)) {
        sub_1000949D4();
      }
      goto LABEL_165;
    }

    goto LABEL_107;
  }

  uint64_t v181 = a2;
  id v20 = [a3 rangeWithName:@"binaryUuid"];
  if (v20 != (id)0x7FFFFFFFFFFFFFFFLL)
  {
    id v35 = v20;
    uint64_t v36 = v21;
    int v180 = a1;
    tm v37 = sub_10007E3B0(objc_msgSend(a1, "substringWithRange:", v20, v21));
    if (v37)
    {
      uint64_t v38 = v37;
      __int128 v188 = 0u;
      __int128 v189 = 0u;
      __int128 v186 = 0u;
      __int128 v187 = 0u;
      id v39 = [a4 countByEnumeratingWithState:&v186 objects:v198 count:16];
      if (!v39) {
        goto LABEL_36;
      }
      id v40 = v39;
      uint64_t v41 = 0LL;
      uint64_t v42 = *(void *)v187;
      while (1)
      {
        uint64_t v43 = 0LL;
        id v16 = v41;
        do
        {
          if (*(void *)v187 != v42) {
            objc_enumerationMutation(a4);
          }
          uint64_t v41 = *(void **)(*((void *)&v186 + 1) + 8LL * (void)v43);
          if (v41) {
            uint64_t v44 = (void *)v41[5];
          }
          else {
            uint64_t v44 = 0LL;
          }
          if (objc_msgSend(objc_msgSend(v44, "uuid"), "isEqual:", v38))
          {
            if (v16)
            {
              if (*((void *)v16 + 6))
              {
                if (byte_1000E7D30)
                {
                  int v80 = *__error();
                  int v81 = (os_log_s *)sub_10002EFA0();
                  if (os_log_type_enabled(v81, OS_LOG_TYPE_DEFAULT))
                  {
                    id v82 = [*((id *)v16 + 5) uuid];
                    uint64_t v83 = *((void *)v16 + 6);
                    *(_DWORD *)buf = 138413314;
                    id v193 = v38;
                    __int16 v194 = 2112;
                    *(void *)int v195 = v82;
                    *(_WORD *)&v195[8] = 2112;
                    *(void *)&v195[10] = v83;
                    *(_WORD *)&v195[18] = 1024;
                    *(_DWORD *)&v195[20] = v181;
                    __int16 v196 = 2112;
                    unsigned __int8 v197 = v180;
                    _os_log_impl( (void *)&_mh_execute_header,  v81,  OS_LOG_TYPE_DEFAULT,  "Parsing spindump text: No address for frame line, and binary UUID %@ matches multiple load infos, assuming %@ segment %@ (%d: %@)",  buf,  0x30u);
                  }

                  *__error() = v80;
                }

                if (byte_1000E7D31) {
                  BOOL v84 = dword_1000E74E0 <= 2;
                }
                else {
                  BOOL v84 = 0;
                }
                if (!v84)
                {
LABEL_151:
                  uint64_t v13 = v17;
                  goto LABEL_196;
                }

                int v85 = *__error();
                int v86 = CFStringCreateWithFormat( kCFAllocatorDefault,  0,  @"Parsing spindump text: No address for frame line, and binary UUID %@ matches multiple load infos, assuming %@ segment %@ (%d: %@)",  v38,  [*((id *)v16 + 5) uuid],  *((void *)v16 + 6),  v181,  v180);
                uint64_t v13 = v17;
                if (!v86)
                {
                  int v87 = (os_log_s *)sub_10002EFA0();
                  if (os_log_type_enabled(v87, OS_LOG_TYPE_FAULT))
                  {
                    id v88 = [*((id *)v16 + 5) uuid];
                    uint64_t v89 = *((void *)v16 + 6);
                    *(_DWORD *)buf = 138413314;
                    id v193 = v38;
                    __int16 v194 = 2112;
                    *(void *)int v195 = v88;
                    *(_WORD *)&v195[8] = 2112;
                    *(void *)&v195[10] = v89;
                    *(_WORD *)&v195[18] = 1024;
                    *(_DWORD *)&v195[20] = v181;
                    __int16 v196 = 2112;
                    unsigned __int8 v197 = v180;
                    id v90 = "Unable to format: Parsing spindump text: No address for frame line, and binary UUID %@ matches"
                          " multiple load infos, assuming %@ segment %@ (%d: %@)";
                    int v91 = v87;
                    uint32_t v92 = 48;
                    goto LABEL_222;
                  }

                  goto LABEL_191;
                }

LABEL_171:
                unsigned int v117 = v86;
                id v118 = CFStringGetCStringPtr(v86, 0x8000100u);
                if (v118)
                {
                  unsigned __int8 v119 = (char *)v118;
                  id v120 = 0LL;
                }

                else
                {
                  unsigned __int8 v119 = (char *)calloc(0x400uLL, 1uLL);
                  CFStringGetCString(v117, v119, 1024LL, 0x8000100u);
                  id v120 = v119;
                }

                if (qword_1000E7D38) {
                  int v125 = (FILE *)qword_1000E7D38;
                }
                else {
                  int v125 = __stderrp;
                }
                fprintf(v125, "%s\n", v119);
                if (v120) {
                  free(v120);
                }
                CFRelease(v117);
              }

              else
              {
                if (byte_1000E7D30)
                {
                  int v107 = *__error();
                  uint64_t v108 = (os_log_s *)sub_10002EFA0();
                  if (os_log_type_enabled(v108, OS_LOG_TYPE_DEFAULT))
                  {
                    id v109 = [*((id *)v16 + 5) uuid];
                    *(_DWORD *)buf = 138413058;
                    id v193 = v38;
                    __int16 v194 = 2112;
                    *(void *)int v195 = v109;
                    *(_WORD *)&v195[8] = 1024;
                    *(_DWORD *)&v195[10] = v181;
                    *(_WORD *)&v195[14] = 2112;
                    *(void *)&v195[16] = v180;
                    _os_log_impl( (void *)&_mh_execute_header,  v108,  OS_LOG_TYPE_DEFAULT,  "Parsing spindump text: No address for frame line, and binary UUID %@ matches multiple load infos, assuming %@ (%d: %@)",  buf,  0x26u);
                  }

                  *__error() = v107;
                }

                if (byte_1000E7D31) {
                  BOOL v110 = dword_1000E74E0 <= 2;
                }
                else {
                  BOOL v110 = 0;
                }
                if (!v110) {
                  goto LABEL_151;
                }
                int v85 = *__error();
                int v86 = CFStringCreateWithFormat( kCFAllocatorDefault,  0,  @"Parsing spindump text: No address for frame line, and binary UUID %@ matches multiple load infos, assuming %@ (%d: %@)",  v38,  [*((id *)v16 + 5) uuid],  v181,  v180);
                uint64_t v13 = v17;
                if (v86) {
                  goto LABEL_171;
                }
                int v127 = (os_log_s *)sub_10002EFA0();
                if (os_log_type_enabled(v127, OS_LOG_TYPE_FAULT))
                {
                  id v139 = [*((id *)v16 + 5) uuid];
                  *(_DWORD *)buf = 138413058;
                  id v193 = v38;
                  __int16 v194 = 2112;
                  *(void *)int v195 = v139;
                  *(_WORD *)&v195[8] = 1024;
                  *(_DWORD *)&v195[10] = v181;
                  *(_WORD *)&v195[14] = 2112;
                  *(void *)&v195[16] = v180;
                  id v90 = "Unable to format: Parsing spindump text: No address for frame line, and binary UUID %@ matches m"
                        "ultiple load infos, assuming %@ (%d: %@)";
                  int v91 = v127;
                  uint32_t v92 = 38;
LABEL_222:
                  _os_log_fault_impl((void *)&_mh_execute_header, v91, OS_LOG_TYPE_FAULT, v90, buf, v92);
                }

LABEL_191:
                if (qword_1000E7D38) {
                  uint64_t v128 = (FILE *)qword_1000E7D38;
                }
                else {
                  uint64_t v128 = __stderrp;
                }
                fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v128);
              }

              *__error() = v85;
              goto LABEL_196;
            }
          }

          else
          {
            uint64_t v41 = v16;
          }

          uint64_t v43 = (char *)v43 + 1;
          id v16 = v41;
        }

        while (v40 != v43);
        id v45 = [a4 countByEnumeratingWithState:&v186 objects:v198 count:16];
        id v40 = v45;
        if (!v45)
        {
          id v16 = v41;
          uint64_t v13 = v17;
          if (!v41)
          {
LABEL_36:
            if (byte_1000E7D30)
            {
              int v46 = *__error();
              __int128 v47 = (os_log_s *)sub_10002EFA0();
              if (os_log_type_enabled(v47, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)buf = 138412802;
                id v193 = v38;
                __int16 v194 = 1024;
                *(_DWORD *)int v195 = v181;
                *(_WORD *)&v195[4] = 2112;
                *(void *)&v195[6] = v180;
                _os_log_error_impl( (void *)&_mh_execute_header,  v47,  OS_LOG_TYPE_ERROR,  "Parsing spindump text: No matching binary for frame line with binary UUID %@! (%d: %@)",  buf,  0x1Cu);
              }

              *__error() = v46;
            }

            id v16 = 0LL;
            if (byte_1000E7D31)
            {
              uint64_t v13 = v17;
              if (dword_1000E74E0 > 3) {
                goto LABEL_220;
              }
              int v48 = *__error();
              __int128 v49 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"Parsing spindump text: No matching binary for frame line with binary UUID %@! (%d: %@)",  v38,  v181,  v180);
              if (!v49)
              {
                __int128 v50 = (os_log_s *)sub_10002EFA0();
                if (os_log_type_enabled(v50, OS_LOG_TYPE_FAULT))
                {
                  *(_DWORD *)buf = 138412802;
                  id v193 = v38;
                  __int16 v194 = 1024;
                  *(_DWORD *)int v195 = v181;
                  *(_WORD *)&v195[4] = 2112;
                  *(void *)&v195[6] = v180;
                  uint64_t v51 = "Unable to format: Parsing spindump text: No matching binary for frame line with binary UUID %@! (%d: %@)";
                  goto LABEL_163;
                }

                goto LABEL_165;
              }

              goto LABEL_107;
            }

LABEL_196:
          id v129 = [a3 rangeWithName:@"offsetIntoBinary"];
          if (v129 == (id)0x7FFFFFFFFFFFFFFFLL)
          {
            if (byte_1000E7D30)
            {
              int v130 = *__error();
              uint64_t v131 = (os_log_s *)sub_10002EFA0();
              if (os_log_type_enabled(v131, OS_LOG_TYPE_ERROR)) {
                sub_1000948EC();
              }
              *__error() = v130;
            }

            if (byte_1000E7D31 && dword_1000E74E0 <= 3)
            {
              int v132 = *__error();
              id v133 = CFStringCreateWithFormat( kCFAllocatorDefault,  0,  @"%s: frame regex returned binary but no offset into binary (%d: %s)",  "range.location != NSNotFound",  v181,  [v180 UTF8String]);
              if (v133)
              {
                int v162 = v133;
                uint64_t v163 = CFStringGetCStringPtr(v133, 0x8000100u);
                if (v163)
                {
                  int v164 = (char *)v163;
                  uint64_t v165 = 0LL;
                }

                else
                {
                  int v164 = (char *)calloc(0x400uLL, 1uLL);
                  CFStringGetCString(v162, v164, 1024LL, 0x8000100u);
                  uint64_t v165 = v164;
                }

                if (qword_1000E7D38) {
                  uint64_t v170 = (FILE *)qword_1000E7D38;
                }
                else {
                  uint64_t v170 = __stderrp;
                }
                fprintf(v170, "%s\n", v164);
                if (v165) {
                  free(v165);
                }
                CFRelease(v162);
              }

              else
              {
                uint64_t v134 = (os_log_s *)sub_10002EFA0();
                if (os_log_type_enabled(v134, OS_LOG_TYPE_FAULT)) {
                  sub_100094960();
                }
                if (qword_1000E7D38) {
                  uint64_t v135 = (FILE *)qword_1000E7D38;
                }
                else {
                  uint64_t v135 = __stderrp;
                }
                fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v135);
              }

              *__error() = v132;
            }

            [v180 UTF8String];
            sub_10002EE78( "LoadInfoForFrameLine",  "SPTextualReportParser.m",  1197,  "%s: frame regex returned binary but no offset into binary (%d: %s)",  v171,  v172,  v173,  v174,  (char)"range.location != NSNotFound");
LABEL_284:
            abort();
          }

      abort();
    }

    unint64_t result = (int *)[a2 length];
    if (result)
    {
      if (byte_1000E7D30)
      {
        id v16 = *__error();
        uint64_t v17 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR)) {
          sub_100094DE0();
        }
        unint64_t result = __error();
        *unint64_t result = v16;
      }

      if (byte_1000E7D31) {
        id v18 = dword_1000E74E0 <= 3;
      }
      else {
        id v18 = 0;
      }
      if (v18)
      {
        uint64_t v19 = *__error();
        id v20 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"Parsing spindump text: Unexpected line in load infos, ignoring (%d: %@)",  a3,  a2);
        if (v20)
        {
          uint64_t v21 = v20;
          id v22 = CFStringGetCStringPtr(v20, 0x8000100u);
          if (v22)
          {
            uint64_t v23 = (char *)v22;
            unint64_t v24 = 0LL;
          }

          else
          {
            uint64_t v23 = (char *)calloc(0x400uLL, 1uLL);
            CFStringGetCString(v21, v23, 1024LL, 0x8000100u);
            unint64_t v24 = v23;
          }

          if (qword_1000E7D38) {
            BOOL v76 = (FILE *)qword_1000E7D38;
          }
          else {
            BOOL v76 = __stderrp;
          }
          fprintf(v76, "%s\n", v23);
          if (v24) {
            free(v24);
          }
          CFRelease(v21);
        }

        else
        {
          int v72 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v72, OS_LOG_TYPE_FAULT)) {
            sub_100094D78();
          }
          if (qword_1000E7D38) {
            char v73 = (FILE *)qword_1000E7D38;
          }
          else {
            char v73 = __stderrp;
          }
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v73);
        }

        unint64_t result = __error();
        *unint64_t result = v19;
      }
    }

    else
    {
      unint64_t result = (int *)[*(id *)(a1 + 40) count];
      if (!result)
      {
        if (byte_1000E7D30)
        {
          int v63 = *__error();
          id v64 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v64, OS_LOG_TYPE_INFO))
          {
            *(_DWORD *)buf = 67109378;
            *(_DWORD *)integer_t v136 = a3;
            *(_WORD *)&v136[4] = 2112;
            *(void *)&v136[6] = a2;
            _os_log_impl( (void *)&_mh_execute_header,  v64,  OS_LOG_TYPE_INFO,  "Parsing spindump text: No load infos, ended at line (%d: %@)",  buf,  0x12u);
          }

          unint64_t result = __error();
          *unint64_t result = v63;
        }

        if (byte_1000E7D31) {
          id v65 = dword_1000E74E0 <= 1;
        }
        else {
          id v65 = 0;
        }
        if (v65)
        {
          id v66 = *__error();
          int v67 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"Parsing spindump text: No load infos, ended at line (%d: %@)",  a3,  a2);
          if (v67)
          {
            uint64_t v68 = v67;
            int v69 = CFStringGetCStringPtr(v67, 0x8000100u);
            if (v69)
            {
              uint64_t v70 = (char *)v69;
              id v71 = 0LL;
            }

            else
            {
              uint64_t v70 = (char *)calloc(0x400uLL, 1uLL);
              CFStringGetCString(v68, v70, 1024LL, 0x8000100u);
              id v71 = v70;
            }

            if (qword_1000E7D38) {
              int v81 = (FILE *)qword_1000E7D38;
            }
            else {
              int v81 = __stderrp;
            }
            fprintf(v81, "%s\n", v70);
            if (v71) {
              free(v71);
            }
            CFRelease(v68);
          }

          else
          {
            uint64_t v78 = (os_log_s *)sub_10002EFA0();
            if (os_log_type_enabled(v78, OS_LOG_TYPE_FAULT)) {
              sub_100094D10();
            }
            if (qword_1000E7D38) {
              int v79 = (FILE *)qword_1000E7D38;
            }
            else {
              int v79 = __stderrp;
            }
            fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v79);
          }

          unint64_t result = __error();
          *unint64_t result = v66;
        }
      }

      *a4 = 1;
    }
  }

  else
  {
    unint64_t result = (int *)[a2 containsString:@"Binary Images:"];
    if ((_DWORD)result) {
      *(_BYTE *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL) = 1;
    }
  }

  return result;
}

LABEL_217:
          id v28 = v129;
          BOOL v29 = v180;
LABEL_218:
          unint64_t v24 = sub_10007BD4C(objc_msgSend(v29, "substringWithRange:", v28, v27));
LABEL_219:
          *a6 = v24;
          goto LABEL_220;
        }
      }
    }

    if (byte_1000E7D30)
    {
      int v74 = *__error();
      uint64_t v75 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v75, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 138412802;
        id v193 = objc_msgSend(a1, "substringWithRange:", v35, v36);
        __int16 v194 = 1024;
        *(_DWORD *)int v195 = v181;
        *(_WORD *)&v195[4] = 2112;
        *(void *)&v195[6] = a1;
        _os_log_impl( (void *)&_mh_execute_header,  v75,  OS_LOG_TYPE_DEFAULT,  "Parsing spindump text: unable to parse UUID %@ in line (%d: %@)",  buf,  0x1Cu);
      }

      *__error() = v74;
    }

    id v16 = 0LL;
    if (!byte_1000E7D31) {
      goto LABEL_109;
    }
    uint64_t v13 = v17;
    if (dword_1000E74E0 > 2) {
      goto LABEL_220;
    }
    int v48 = *__error();
    __int128 v49 = CFStringCreateWithFormat( kCFAllocatorDefault,  0,  @"Parsing spindump text: unable to parse UUID %@ in line (%d: %@)",  objc_msgSend(a1, "substringWithRange:", v35, v36),  v181,  a1);
    if (v49) {
      goto LABEL_107;
    }
    __int128 v50 = (os_log_s *)sub_10002EFA0();
    if (!os_log_type_enabled(v50, OS_LOG_TYPE_FAULT)) {
      goto LABEL_165;
    }
    id v115 = objc_msgSend(a1, "substringWithRange:", v35, v36);
    *(_DWORD *)buf = 138412802;
    id v193 = v115;
    __int16 v194 = 1024;
    *(_DWORD *)int v195 = v181;
    *(_WORD *)&v195[4] = 2112;
    *(void *)&v195[6] = a1;
    uint64_t v51 = "Unable to format: Parsing spindump text: unable to parse UUID %@ in line (%d: %@)";
LABEL_163:
    double v58 = v50;
    uint32_t v59 = 28;
LABEL_164:
    _os_log_fault_impl((void *)&_mh_execute_header, v58, OS_LOG_TYPE_FAULT, v51, buf, v59);
    goto LABEL_165;
  }

  id v22 = [a3 rangeWithName:@"binaryName"];
  uint64_t v13 = v17;
  if (v22 == (id)0x7FFFFFFFFFFFFFFFLL)
  {
    id v16 = 0LL;
    unint64_t v24 = -1LL;
    goto LABEL_219;
  }

  int v180 = a1;
  id v64 = objc_msgSend(a1, "substringWithRange:", v22, v23);
  __int128 v182 = 0u;
  __int128 v183 = 0u;
  __int128 v184 = 0u;
  __int128 v185 = 0u;
  id v65 = [a4 countByEnumeratingWithState:&v182 objects:v191 count:16];
  if (!v65) {
    goto LABEL_91;
  }
  id v66 = v65;
  int v67 = 0LL;
  uint64_t v68 = *(void *)v183;
  do
  {
    int v69 = 0LL;
    id v16 = v67;
    do
    {
      if (*(void *)v183 != v68) {
        objc_enumerationMutation(a4);
      }
      int v67 = *(void **)(*((void *)&v182 + 1) + 8LL * (void)v69);
      if (v67) {
        uint64_t v70 = (void *)v67[5];
      }
      else {
        uint64_t v70 = 0LL;
      }
      if (objc_msgSend(objc_msgSend(v70, "name"), "isEqualToString:", v64))
      {
        if (v16)
        {
          if (*((void *)v16 + 6))
          {
            if (byte_1000E7D30)
            {
              int v93 = *__error();
              double v94 = (os_log_s *)sub_10002EFA0();
              if (os_log_type_enabled(v94, OS_LOG_TYPE_DEFAULT))
              {
                id v95 = [*((id *)v16 + 5) uuid];
                uint64_t v96 = *((void *)v16 + 6);
                *(_DWORD *)buf = 138413314;
                id v193 = v64;
                __int16 v194 = 2112;
                *(void *)int v195 = v95;
                *(_WORD *)&v195[8] = 2112;
                *(void *)&v195[10] = v96;
                *(_WORD *)&v195[18] = 1024;
                *(_DWORD *)&v195[20] = v181;
                __int16 v196 = 2112;
                unsigned __int8 v197 = v180;
                _os_log_impl( (void *)&_mh_execute_header,  v94,  OS_LOG_TYPE_DEFAULT,  "Parsing spindump text: No address for frame line, and binary name %@ matches multiple load infos, assu ming %@ segment %@ (%d: %@)",  buf,  0x30u);
              }

              *__error() = v93;
            }

            if (byte_1000E7D31) {
              BOOL v97 = dword_1000E74E0 <= 2;
            }
            else {
              BOOL v97 = 0;
            }
            if (!v97)
            {
LABEL_160:
              uint64_t v13 = v17;
              goto LABEL_216;
            }

            int v98 = *__error();
            int v99 = CFStringCreateWithFormat( kCFAllocatorDefault,  0,  @"Parsing spindump text: No address for frame line, and binary name %@ matches multiple load infos, assuming %@ segment %@ (%d: %@)",  v64,  [*((id *)v16 + 5) uuid],  *((void *)v16 + 6),  v181,  v180);
            uint64_t v13 = v17;
            if (!v99)
            {
              id v100 = (os_log_s *)sub_10002EFA0();
              if (os_log_type_enabled(v100, OS_LOG_TYPE_FAULT))
              {
                id v101 = [*((id *)v16 + 5) uuid];
                uint64_t v102 = *((void *)v16 + 6);
                *(_DWORD *)buf = 138413314;
                id v193 = v64;
                __int16 v194 = 2112;
                *(void *)int v195 = v101;
                *(_WORD *)&v195[8] = 2112;
                *(void *)&v195[10] = v102;
                *(_WORD *)&v195[18] = 1024;
                *(_DWORD *)&v195[20] = v181;
                __int16 v196 = 2112;
                unsigned __int8 v197 = v180;
                int v103 = "Unable to format: Parsing spindump text: No address for frame line, and binary name %@ matches mu"
                       "ltiple load infos, assuming %@ segment %@ (%d: %@)";
                __int16 v104 = v100;
                uint32_t v105 = 48;
LABEL_224:
                _os_log_fault_impl((void *)&_mh_execute_header, v104, OS_LOG_TYPE_FAULT, v103, buf, v105);
                goto LABEL_211;
              }

              goto LABEL_211;
            }
          }

          else
          {
            if (byte_1000E7D30)
            {
              int v111 = *__error();
              uint64_t v112 = (os_log_s *)sub_10002EFA0();
              if (os_log_type_enabled(v112, OS_LOG_TYPE_DEFAULT))
              {
                id v113 = [*((id *)v16 + 5) uuid];
                *(_DWORD *)buf = 138413058;
                id v193 = v64;
                __int16 v194 = 2112;
                *(void *)int v195 = v113;
                *(_WORD *)&v195[8] = 1024;
                *(_DWORD *)&v195[10] = v181;
                *(_WORD *)&v195[14] = 2112;
                *(void *)&v195[16] = v180;
                _os_log_impl( (void *)&_mh_execute_header,  v112,  OS_LOG_TYPE_DEFAULT,  "Parsing spindump text: No address for frame line, and binary name %@ matches multiple load infos, assu ming %@ (%d: %@)",  buf,  0x26u);
              }

              *__error() = v111;
            }

            if (byte_1000E7D31) {
              BOOL v114 = dword_1000E74E0 <= 2;
            }
            else {
              BOOL v114 = 0;
            }
            if (!v114) {
              goto LABEL_160;
            }
            int v98 = *__error();
            int v99 = CFStringCreateWithFormat( kCFAllocatorDefault,  0,  @"Parsing spindump text: No address for frame line, and binary name %@ matches multiple load infos, assuming %@ (%d: %@)",  v64,  [*((id *)v16 + 5) uuid],  v181,  v180);
            uint64_t v13 = v17;
            if (!v99)
            {
              integer_t v136 = (os_log_s *)sub_10002EFA0();
              if (os_log_type_enabled(v136, OS_LOG_TYPE_FAULT))
              {
                id v140 = [*((id *)v16 + 5) uuid];
                *(_DWORD *)buf = 138413058;
                id v193 = v64;
                __int16 v194 = 2112;
                *(void *)int v195 = v140;
                *(_WORD *)&v195[8] = 1024;
                *(_DWORD *)&v195[10] = v181;
                *(_WORD *)&v195[14] = 2112;
                *(void *)&v195[16] = v180;
                int v103 = "Unable to format: Parsing spindump text: No address for frame line, and binary name %@ matches mu"
                       "ltiple load infos, assuming %@ (%d: %@)";
                __int16 v104 = v136;
                uint32_t v105 = 38;
                goto LABEL_224;
              }

LABEL_211:
              if (qword_1000E7D38) {
                uint64_t v137 = (FILE *)qword_1000E7D38;
              }
              else {
                uint64_t v137 = __stderrp;
              }
              fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v137);
LABEL_215:
              *__error() = v98;
LABEL_216:
              id v129 = [a3 rangeWithName:@"offsetIntoBinary"];
              if (v129 == (id)0x7FFFFFFFFFFFFFFFLL)
              {
                if (byte_1000E7D30)
                {
                  int v147 = *__error();
                  uint64_t v148 = (os_log_s *)sub_10002EFA0();
                  if (os_log_type_enabled(v148, OS_LOG_TYPE_ERROR)) {
                    sub_1000948EC();
                  }
                  *__error() = v147;
                }

                if (byte_1000E7D31 && dword_1000E74E0 <= 3)
                {
                  int v149 = *__error();
                  uint64_t v150 = CFStringCreateWithFormat( kCFAllocatorDefault,  0,  @"%s: frame regex returned binary but no offset into binary (%d: %s)",  "range.location != NSNotFound",  v181,  [v180 UTF8String]);
                  if (v150)
                  {
                    uint64_t v166 = v150;
                    uint64_t v167 = CFStringGetCStringPtr(v150, 0x8000100u);
                    if (v167)
                    {
                      uint64_t v168 = (char *)v167;
                      uint64_t v169 = 0LL;
                    }

                    else
                    {
                      uint64_t v168 = (char *)calloc(0x400uLL, 1uLL);
                      CFStringGetCString(v166, v168, 1024LL, 0x8000100u);
                      uint64_t v169 = v168;
                    }

                    if (qword_1000E7D38) {
                      int v175 = (FILE *)qword_1000E7D38;
                    }
                    else {
                      int v175 = __stderrp;
                    }
                    fprintf(v175, "%s\n", v168);
                    if (v169) {
                      free(v169);
                    }
                    CFRelease(v166);
                  }

                  else
                  {
                    uint64_t v151 = (os_log_s *)sub_10002EFA0();
                    if (os_log_type_enabled(v151, OS_LOG_TYPE_FAULT)) {
                      sub_100094878();
                    }
                    if (qword_1000E7D38) {
                      uint64_t v152 = (FILE *)qword_1000E7D38;
                    }
                    else {
                      uint64_t v152 = __stderrp;
                    }
                    fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v152);
                  }

                  *__error() = v149;
                }

                [v180 UTF8String];
                sub_10002EE78( "LoadInfoForFrameLine",  "SPTextualReportParser.m",  1225,  "%s: frame regex returned binary but no offset into binary (%d: %s)",  v176,  v177,  v178,  v179,  (char)"range.location != NSNotFound");
                goto LABEL_284;
              }

              goto LABEL_217;
            }
          }

          id v121 = v99;
          int v122 = CFStringGetCStringPtr(v99, 0x8000100u);
          if (v122)
          {
            uint64_t v123 = (char *)v122;
            char v124 = 0LL;
          }

          else
          {
            uint64_t v123 = (char *)calloc(0x400uLL, 1uLL);
            CFStringGetCString(v121, v123, 1024LL, 0x8000100u);
            char v124 = v123;
          }

          if (qword_1000E7D38) {
            char v126 = (FILE *)qword_1000E7D38;
          }
          else {
            char v126 = __stderrp;
          }
          fprintf(v126, "%s\n", v123);
          if (v124) {
            free(v124);
          }
          CFRelease(v121);
          goto LABEL_215;
        }
      }

      else
      {
        int v67 = v16;
      }

      int v69 = (char *)v69 + 1;
      id v16 = v67;
    }

    while (v66 != v69);
    id v71 = [a4 countByEnumeratingWithState:&v182 objects:v191 count:16];
    id v66 = v71;
  }

  while (v71);
  id v16 = v67;
  uint64_t v13 = v17;
  if (v67) {
    goto LABEL_216;
  }
LABEL_91:
  if (byte_1000E7D30)
  {
    int v72 = *__error();
    char v73 = (os_log_s *)sub_10002EFA0();
    if (os_log_type_enabled(v73, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 138412802;
      id v193 = v64;
      __int16 v194 = 1024;
      *(_DWORD *)int v195 = v181;
      *(_WORD *)&v195[4] = 2112;
      *(void *)&v195[6] = v180;
      _os_log_error_impl( (void *)&_mh_execute_header,  v73,  OS_LOG_TYPE_ERROR,  "Parsing spindump text: No matching binary for frame line with binary name %@! (%d: %@)",  buf,  0x1Cu);
    }

    *__error() = v72;
    uint64_t v13 = v17;
  }

  id v16 = 0LL;
  if (!byte_1000E7D31 || dword_1000E74E0 > 3) {
    goto LABEL_220;
  }
  int v48 = *__error();
  __int128 v49 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"Parsing spindump text: No matching binary for frame line with binary name %@! (%d: %@)",  v64,  v181,  v180);
  if (v49)
  {
LABEL_107:
    BOOL v76 = v49;
    uint64_t v77 = CFStringGetCStringPtr(v49, 0x8000100u);
    if (v77)
    {
      uint64_t v78 = (char *)v77;
      int v79 = 0LL;
    }

    else
    {
      uint64_t v78 = (char *)calloc(0x400uLL, 1uLL);
      CFStringGetCString(v76, v78, 1024LL, 0x8000100u);
      int v79 = v78;
    }

    if (qword_1000E7D38) {
      uint64_t v106 = (FILE *)qword_1000E7D38;
    }
    else {
      uint64_t v106 = __stderrp;
    }
    fprintf(v106, "%s\n", v78);
    if (v79) {
      free(v79);
    }
    CFRelease(v76);
    goto LABEL_169;
  }

  __int128 v50 = (os_log_s *)sub_10002EFA0();
  if (os_log_type_enabled(v50, OS_LOG_TYPE_FAULT))
  {
    *(_DWORD *)buf = 138412802;
    id v193 = v64;
    __int16 v194 = 1024;
    *(_DWORD *)int v195 = v181;
    *(_WORD *)&v195[4] = 2112;
    *(void *)&v195[6] = v180;
    uint64_t v51 = "Unable to format: Parsing spindump text: No matching binary for frame line with binary name %@! (%d: %@)";
    goto LABEL_163;
  }

unint64_t sub_10007BD4C(void *a1)
{
  size_t v2 = objc_autoreleasePoolPush();
  unint64_t v3 = (const char *)[a1 UTF8String];
  if (!v3)
  {
    id v4 = [a1 dataUsingEncoding:4 allowLossyConversion:1];
    if (!v4)
    {
      unint64_t v5 = 0LL;
      goto LABEL_5;
    }

    unint64_t v3 = (const char *)[v4 bytes];
  }

  unint64_t v5 = strtoull(v3, 0LL, 0);
LABEL_5:
  objc_autoreleasePoolPop(v2);
  return v5;
}

uint64_t sub_10007BDB8( FILE *a1, int a2, int a3, int a4, int a5, const char *a6, uint64_t a7, const char *a8, int a9, int a10)
{
  id v16 = "";
  if (a3) {
    id v16 = "*";
  }
  fprintf(a1, "%*s", a2, v16);
  fprintf(a1, "%-*d", a5, a4);
  fputs(a6, a1);
  if (a7 != -1) {
    fprintf(a1, " [0x%llx]", a7);
  }
  if (a8) {
    fprintf(a1, " (%s)", a8);
  }
  if (a9)
  {
    fprintf(a1, " %d", a9);
    if (a9 != a10) {
      fprintf(a1, "-%d", a10);
    }
  }

  return fputc(10, a1);
}

void sub_10007BEC4( void *a1, uint64_t a2, void *a3, int a4, int a5, int a6, _DWORD *a7, _DWORD *a8, BOOL *a9, _DWORD *a10, int *a11, void *a12, NSMutableString **a13, int *a14, _DWORD *a15)
{
  id v18 = a15;
  context = objc_autoreleasePoolPush();
  id v19 = [a3 rangeWithName:@"angleBracketContents"];
  if (v19 != (id)0x7FFFFFFFFFFFFFFFLL
    || (id v19 = [a3 rangeWithName:@"otherInfo"], v19 != (id)0x7FFFFFFFFFFFFFFFLL))
  {
    *a12 = objc_msgSend(a1, "substringWithRange:", v19, v20);
  }

  id v21 = [a3 rangeWithName:@"stateInfo"];
  if (v21 != (id)0x7FFFFFFFFFFFFFFFLL)
  {
    id v23 = objc_msgSend(a1, "substringWithRange:", v21, v22);
    if (a4)
    {
      unint64_t v24 = sub_10007BD4C(v23);
      unint64_t v25 = objc_alloc_init(&OBJC_CLASS___NSMutableString);
      id v26 = v25;
      if ((v24 & 2) != 0) {
        uint64_t v27 = @"Frontmost App";
      }
      else {
        uint64_t v27 = @"Non-Frontmost App";
      }
      -[NSMutableString appendString:](v25, "appendString:", v27);
      if ((v24 & 0x20) != 0) {
        id v28 = @", Suppressed";
      }
      else {
        id v28 = @", Non-Suppressed";
      }
      -[NSMutableString appendString:](v26, "appendString:", v28);
      if ((v24 & 0x80) != 0) {
        BOOL v29 = @", Kernel mode";
      }
      else {
        BOOL v29 = @", User mode";
      }
      -[NSMutableString appendString:](v26, "appendString:", v29);
      if ((v24 & 0x10) != 0)
      {
        if ((v24 & 4) != 0) {
          int v30 = @", User Idle";
        }
        else {
          int v30 = @", User Active";
        }
        -[NSMutableString appendString:](v26, "appendString:", v30);
      }

      if ((v24 & 8) != 0) {
        unint64_t v31 = @", On Battery";
      }
      else {
        unint64_t v31 = @", On AC";
      }
      -[NSMutableString appendString:](v26, "appendString:", v31);
      uint64_t v32 = ((v24 >> 8) & 7) - 1;
      else {
        int v33 = (&off_1000D9E38)[v32];
      }
      -[NSMutableString appendFormat:](v26, "appendFormat:", @", Effective %s", v33);
      uint64_t v34 = ((v24 >> 11) & 7) - 1;
      else {
        id v35 = (&off_1000D9E38)[v34];
      }
      -[NSMutableString appendFormat:](v26, "appendFormat:", @", Requested %s", v35);
      uint64_t v36 = ((v24 >> 14) & 7) - 1;
      else {
        tm v37 = (&off_1000D9E38)[v36];
      }
      -[NSMutableString appendFormat:](v26, "appendFormat:", @", Override %s", v37);
    }

    else
    {
      id v26 = (NSMutableString *)v23;
    }

    *a13 = v26;
    id v18 = a15;
  }

  id v38 = [a3 rangeWithName:@"count"];
  if (v38 == (id)0x7FFFFFFFFFFFFFFFLL)
  {
    *a10 = -1;
    *a11 = -1;
  }

  else
  {
    *a10 = sub_10007BD4C(objc_msgSend(a1, "substringWithRange:", v38, v39));
    if ((a4 & 1) != 0)
    {
      int v40 = -1;
    }

    else if ([a3 rangeWithName:@"countAndWhitespace"] == (id)0x7FFFFFFFFFFFFFFFLL)
    {
      if (byte_1000E7D30)
      {
        int v50 = *__error();
        uint64_t v51 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v51, OS_LOG_TYPE_ERROR)) {
          sub_100094B18();
        }
        *__error() = v50;
      }

      if (byte_1000E7D31 && dword_1000E74E0 <= 3)
      {
        int v52 = *__error();
        int v53 = CFStringCreateWithFormat( kCFAllocatorDefault,  0,  @"%s: frame match with no count and whitespace (%d: %s)",  "range.location != NSNotFound",  a2,  [a1 UTF8String]);
        if (v53)
        {
          unsigned int v62 = v53;
          CStringPtr = CFStringGetCStringPtr(v53, 0x8000100u);
          if (CStringPtr)
          {
            id v64 = (char *)CStringPtr;
            id v65 = 0LL;
          }

          else
          {
            id v64 = (char *)calloc(0x400uLL, 1uLL);
            CFStringGetCString(v62, v64, 1024LL, 0x8000100u);
            id v65 = v64;
          }

          if (qword_1000E7D38) {
            uint64_t v70 = (FILE *)qword_1000E7D38;
          }
          else {
            uint64_t v70 = __stderrp;
          }
          fprintf(v70, "%s\n", v64);
          if (v65) {
            free(v65);
          }
          CFRelease(v62);
        }

        else
        {
          unsigned int v54 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v54, OS_LOG_TYPE_FAULT)) {
            sub_100094B8C();
          }
          if (qword_1000E7D38) {
            int v55 = (FILE *)qword_1000E7D38;
          }
          else {
            int v55 = __stderrp;
          }
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v55);
        }

        *__error() = v52;
      }

      [a1 UTF8String];
      sub_10002EE78( "ParseCallTreeNonFrameLine",  "SPTextualReportParser.m",  2228,  "%s: frame match with no count and whitespace (%d: %s)",  v71,  v72,  v73,  v74,  (char)"range.location != NSNotFound");
LABEL_102:
      abort();
    }

    *a11 = v40;
    *a7 = sub_10007A31C(a1, a3, a4, a5, a6);
  }

  if ([a3 rangeWithName:@"indentWhitespace"] != (id)0x7FFFFFFFFFFFFFFFLL) {
    *a8 = v41;
  }
  *a9 = [a3 rangeWithName:@"kernelDot"] != (id)0x7FFFFFFFFFFFFFFFLL;
  id v42 = [a3 rangeWithName:@"count"];
  if (v42 == (id)0x7FFFFFFFFFFFFFFFLL)
  {
    int v44 = -1;
    *a10 = -1;
    goto LABEL_48;
  }

  *a10 = sub_10007BD4C(objc_msgSend(a1, "substringWithRange:", v42, v43));
  if ((a4 & 1) != 0)
  {
    int v44 = -1;
    goto LABEL_48;
  }

  if ([a3 rangeWithName:@"countAndWhitespace"] == (id)0x7FFFFFFFFFFFFFFFLL)
  {
    if (byte_1000E7D30)
    {
      int v56 = *__error();
      id v57 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v57, OS_LOG_TYPE_ERROR)) {
        sub_100094B18();
      }
      *__error() = v56;
    }

    if (byte_1000E7D31 && dword_1000E74E0 <= 3)
    {
      int v58 = *__error();
      uint32_t v59 = CFStringCreateWithFormat( kCFAllocatorDefault,  0,  @"%s: frame match with no count and whitespace (%d: %s)",  "range.location != NSNotFound",  a2,  [a1 UTF8String]);
      if (v59)
      {
        id v66 = v59;
        int v67 = CFStringGetCStringPtr(v59, 0x8000100u);
        if (v67)
        {
          uint64_t v68 = (char *)v67;
          int v69 = 0LL;
        }

        else
        {
          uint64_t v68 = (char *)calloc(0x400uLL, 1uLL);
          CFStringGetCString(v66, v68, 1024LL, 0x8000100u);
          int v69 = v68;
        }

        if (qword_1000E7D38) {
          uint64_t v75 = (FILE *)qword_1000E7D38;
        }
        else {
          uint64_t v75 = __stderrp;
        }
        fprintf(v75, "%s\n", v68);
        if (v69) {
          free(v69);
        }
        CFRelease(v66);
      }

      else
      {
        id v60 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v60, OS_LOG_TYPE_FAULT)) {
          sub_100094AA4();
        }
        if (qword_1000E7D38) {
          int v61 = (FILE *)qword_1000E7D38;
        }
        else {
          int v61 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v61);
      }

      *__error() = v58;
    }

    [a1 UTF8String];
    sub_10002EE78( "ParseCallTreeNonFrameLine",  "SPTextualReportParser.m",  2261,  "%s: frame match with no count and whitespace (%d: %s)",  v76,  v77,  v78,  v79,  (char)"range.location != NSNotFound");
    goto LABEL_102;
  }

uint64_t sub_10007C6A8(FILE *a1, int a2, int a3, int a4, int a5, const char *a6, uint64_t a7, int a8, int a9)
{
  uint64_t v15 = "*";
  if (!a3) {
    uint64_t v15 = "";
  }
  fprintf(a1, "%*s", a2, v15);
  if (a4 < 1)
  {
    if (a5 >= 1) {
      fprintf(a1, "%*s");
    }
  }

  else
  {
    fprintf(a1, "%-*d");
  }

  if (a6)
  {
    fprintf(a1, "<%s>", a6);
    if (a7) {
      fprintf(a1, " (%s)");
    }
  }

  else if (a7)
  {
    fprintf(a1, "<%s>");
  }

  if (a8)
  {
    fprintf(a1, " %d", a8);
    if (a8 != a9) {
      fprintf(a1, "-%d", a9);
    }
  }

  return fputc(10, a1);
}

int64_t sub_10007C7D4(id a1, SPTreeNode *a2, SPTreeNode *a3)
{
  if (a2)
  {
    int count = a2->_count;
    if (a3)
    {
LABEL_3:
      int v4 = a3->_count;
      goto LABEL_4;
    }
  }

  else
  {
    int count = 0;
    if (a3) {
      goto LABEL_3;
    }
  }

  int v4 = 0;
LABEL_4:
  if (count < v4) {
    return 1LL;
  }
  if (a2)
  {
    int v6 = a2->_count;
    if (a3)
    {
LABEL_8:
      int v7 = a3->_count;
      goto LABEL_9;
    }
  }

  else
  {
    int v6 = 0;
    if (a3) {
      goto LABEL_8;
    }
  }

  int v7 = 0;
LABEL_9:
  if (v6 <= v7) {
    return 0LL;
  }
  else {
    return -1LL;
  }
}

void sub_10007C8F8(FILE *a1, int a2, uint64_t a3)
{
  LODWORD(v4) = a2;
  off_t v6 = ftello(a1);
  if (v6 == -1)
  {
    if (byte_1000E7D30)
    {
      int v19 = *__error();
      uint64_t v20 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR)) {
        sub_100094C8C();
      }
      *__error() = v19;
    }

    if (byte_1000E7D31) {
      BOOL v21 = dword_1000E74E0 <= 3;
    }
    else {
      BOOL v21 = 0;
    }
    if (v21)
    {
      int v49 = *__error();
      uint64_t v50 = *__error();
      uint64_t v51 = __error();
      int v52 = strerror(*v51);
      int v53 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"%s: ftello failed: %d (%s)",  "pos != -1",  v50,  v52);
      unsigned int v54 = v53;
      if (v53)
      {
        CStringPtr = (char *)CFStringGetCStringPtr(v53, 0x8000100u);
        if (CStringPtr)
        {
          int v58 = 0LL;
        }

        else
        {
          CStringPtr = (char *)calloc(0x400uLL, 1uLL);
          CFStringGetCString(v54, CStringPtr, 1024LL, 0x8000100u);
          int v58 = CStringPtr;
        }

        if (qword_1000E7D38) {
          uint32_t v59 = (FILE *)qword_1000E7D38;
        }
        else {
          uint32_t v59 = __stderrp;
        }
        fprintf(v59, "%s\n", CStringPtr);
        if (v58) {
          free(v58);
        }
        CFRelease(v54);
      }

      else
      {
        int v55 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v55, OS_LOG_TYPE_FAULT)) {
          sub_100094C00();
        }
        if (qword_1000E7D38) {
          int v56 = (FILE *)qword_1000E7D38;
        }
        else {
          int v56 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v56);
      }

      *__error() = v49;
    }

    __error();
    uint64_t v22 = __error();
    strerror(*v22);
    sub_10002EE78( "LookaheadLines",  "SPTextualReportParser.m",  965,  "%s: ftello failed: %d (%s)",  v23,  v24,  v25,  v26,  (char)"pos != -1");
    abort();
  }

  off_t v14 = v6;
  uint64_t v72 = 0LL;
  uint64_t v73 = &v72;
  uint64_t v74 = 0x2020000000LL;
  uint64_t v75 = 0LL;
  uint64_t v68 = 0LL;
  int v69 = &v68;
  uint64_t v70 = 0x2020000000LL;
  int v71 = 0;
  v63[0] = _NSConcreteStackBlock;
  v63[1] = 3221225472LL;
  id v64 = sub_10007DF6C;
  id v65 = &unk_1000D9240;
  id v66 = &v68;
  int v67 = &v72;
  sub_10007DF6C((uint64_t)v63, v7, v8, v9, v10, v11, v12, v13);
  if (fgets((char *)v73[3], *((_DWORD *)v69 + 6), a1))
  {
    do
    {
      uint64_t v15 = (const char *)v73[3];
      int v16 = strnlen(v15, *((int *)v69 + 6));
      if (v15[v16 - 1] == 10)
      {
        v15[v16 - 1] = 0;
        uint64_t v17 = objc_alloc(&OBJC_CLASS___NSString);
        id v18 = -[NSString initWithUTF8String:](v17, "initWithUTF8String:", v73[3]);
        uint64_t v4 = (v4 + 1);
        buf[0] = 0;
        (*(void (**)(uint64_t, NSString *, uint64_t, uint8_t *))(a3 + 16))(a3, v18, v4, buf);

        if (buf[0]) {
          break;
        }
        int v16 = 0;
      }

      else
      {
        ((void (*)(void *))v64)(v63);
      }
    }

    while (fgets((char *)(v73[3] + v16), *((_DWORD *)v69 + 6) - v16, a1));
  }

  free((void *)v73[3]);
  if (fseeko(a1, v14, 0))
  {
    if (byte_1000E7D30)
    {
      int v27 = *__error();
      id v28 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
      {
        int v29 = *__error();
        int v30 = __error();
        unint64_t v31 = strerror(*v30);
        *(_DWORD *)buf = 136315906;
        uint64_t v77 = "ret == 0";
        __int16 v78 = 2048;
        off_t v79 = v14;
        __int16 v80 = 1024;
        int v81 = v29;
        __int16 v82 = 2080;
        uint64_t v83 = v31;
        _os_log_error_impl( (void *)&_mh_execute_header,  v28,  OS_LOG_TYPE_ERROR,  "%s: Unable to seek back to %lld after searching for load infos: %d (%s)",  buf,  0x26u);
      }

      *__error() = v27;
    }

    if (byte_1000E7D31) {
      BOOL v32 = dword_1000E74E0 <= 3;
    }
    else {
      BOOL v32 = 0;
    }
    if (v32)
    {
      int v33 = *__error();
      uint64_t v34 = *__error();
      id v35 = __error();
      uint64_t v36 = strerror(*v35);
      tm v37 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"%s: Unable to seek back to %lld after searching for load infos: %d (%s)",  "ret == 0",  v14,  v34,  v36);
      id v38 = v37;
      if (v37)
      {
        id v60 = (char *)CFStringGetCStringPtr(v37, 0x8000100u);
        if (v60)
        {
          int v61 = 0LL;
        }

        else
        {
          id v60 = (char *)calloc(0x400uLL, 1uLL);
          CFStringGetCString(v38, v60, 1024LL, 0x8000100u);
          int v61 = v60;
        }

        if (qword_1000E7D38) {
          unsigned int v62 = (FILE *)qword_1000E7D38;
        }
        else {
          unsigned int v62 = __stderrp;
        }
        fprintf(v62, "%s\n", v60);
        if (v61) {
          free(v61);
        }
        CFRelease(v38);
      }

      else
      {
        uint64_t v39 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v39, OS_LOG_TYPE_FAULT))
        {
          int v40 = *__error();
          int v41 = __error();
          id v42 = strerror(*v41);
          *(_DWORD *)buf = 136315906;
          uint64_t v77 = "ret == 0";
          __int16 v78 = 2048;
          off_t v79 = v14;
          __int16 v80 = 1024;
          int v81 = v40;
          __int16 v82 = 2080;
          uint64_t v83 = v42;
          _os_log_fault_impl( (void *)&_mh_execute_header,  v39,  OS_LOG_TYPE_FAULT,  "Unable to format: %s: Unable to seek back to %lld after searching for load infos: %d (%s)",  buf,  0x26u);
        }

        if (qword_1000E7D38) {
          uint64_t v43 = (FILE *)qword_1000E7D38;
        }
        else {
          uint64_t v43 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v43);
      }

      *__error() = v33;
    }

    __error();
    int v44 = __error();
    strerror(*v44);
    sub_10002EE78( "LookaheadLines",  "SPTextualReportParser.m",  1008,  "%s: Unable to seek back to %lld after searching for load infos: %d (%s)",  v45,  v46,  v47,  v48,  (char)"ret == 0");
    abort();
  }

  _Block_object_dispose(&v68, 8);
  _Block_object_dispose(&v72, 8);
}

void sub_10007CF7C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  uint64_t v12 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  uint64_t v15 = va_arg(va1, void);
  uint64_t v16 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

int *sub_10007CFDC(uint64_t a1, void *a2, uint64_t a3, _BYTE *a4)
{
  if (*(_BYTE *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL))
  {
    id v8 = objc_msgSend(*(id *)(a1 + 32), "firstMatchInString:options:range:", a2, 0, 0, objc_msgSend(a2, "length"));
    if (v8)
    {
      uint64_t v9 = v8;
      int v10 = *(unsigned __int8 *)(a1 + 56);
      id v11 = [v8 rangeWithName:@"kernelDot"];
      if (v10)
      {
        id v12 = [v9 rangeWithName:@"binaryIndex"];
        if (v12 == (id)0x7FFFFFFFFFFFFFFFLL)
        {
          uint64_t v95 = a3;
          if (byte_1000E7D30)
          {
            int v96 = *__error();
            BOOL v97 = (os_log_s *)sub_10002EFA0();
            if (os_log_type_enabled(v97, OS_LOG_TYPE_ERROR)) {
              sub_10009508C();
            }
            *__error() = v96;
          }

          if (byte_1000E7D31) {
            BOOL v98 = dword_1000E74E0 <= 3;
          }
          else {
            BOOL v98 = 0;
          }
          if (v98)
          {
            int v99 = *__error();
            id v100 = CFStringCreateWithFormat( kCFAllocatorDefault,  0,  @"%s: Parsing spindump text: No binary index (%d: %s)",  "range.location != NSNotFound",  v95,  [a2 UTF8String]);
            if (v100)
            {
              int v111 = v100;
              CStringPtr = CFStringGetCStringPtr(v100, 0x8000100u);
              if (CStringPtr)
              {
                id v113 = (char *)CStringPtr;
                BOOL v114 = 0LL;
              }

              else
              {
                id v113 = (char *)calloc(0x400uLL, 1uLL);
                CFStringGetCString(v111, v113, 1024LL, 0x8000100u);
                BOOL v114 = v113;
              }

              if (qword_1000E7D38) {
                int v125 = (FILE *)qword_1000E7D38;
              }
              else {
                int v125 = __stderrp;
              }
              fprintf(v125, "%s\n", v113);
              if (v114) {
                free(v114);
              }
              CFRelease(v111);
            }

            else
            {
              id v101 = (os_log_s *)sub_10002EFA0();
              if (os_log_type_enabled(v101, OS_LOG_TYPE_FAULT)) {
                sub_100095018();
              }
              if (qword_1000E7D38) {
                uint64_t v102 = (FILE *)qword_1000E7D38;
              }
              else {
                uint64_t v102 = __stderrp;
              }
              fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v102);
            }

            *__error() = v99;
          }

          [a2 UTF8String];
          sub_10002EE78( "ParseLoadInfoLine",  "SPTextualReportParser.m",  2343,  "%s: Parsing spindump text: No binary index (%d: %s)",  v126,  v127,  v128,  v129,  (char)"range.location != NSNotFound");
          goto LABEL_196;
        }

        unint64_t v14 = sub_10007BD4C(objc_msgSend(a2, "substringWithRange:", v12, v13));
      }

      else
      {
        unint64_t v14 = 0LL;
      }

      id v25 = [v9 rangeWithName:@"startAddress"];
      if (v25 == (id)0x7FFFFFFFFFFFFFFFLL) {
        unint64_t v133 = 0LL;
      }
      else {
        unint64_t v133 = sub_10007BD4C(objc_msgSend(a2, "substringWithRange:", v25, v26));
      }
      int v130 = a4;
      id v27 = [v9 rangeWithName:@"endAddress"];
      if (v27 == (id)0x7FFFFFFFFFFFFFFFLL) {
        unint64_t v132 = 0LL;
      }
      else {
        unint64_t v132 = sub_10007BD4C(objc_msgSend(a2, "substringWithRange:", v27, v28));
      }
      id v29 = [v9 rangeWithName:@"bundleIdentifier"];
      if (v29 == (id)0x7FFFFFFFFFFFFFFFLL) {
        id v31 = 0LL;
      }
      else {
        id v31 = objc_msgSend(a2, "substringWithRange:", v29, v30);
      }
      id v32 = [v9 rangeWithName:@"name"];
      if (v32 == (id)0x7FFFFFFFFFFFFFFFLL) {
        id v34 = 0LL;
      }
      else {
        id v34 = objc_msgSend(a2, "substringWithRange:", v32, v33);
      }
      uint64_t v134 = (int *)v14;
      id v35 = [v9 rangeWithName:@"version"];
      if (v35 == (id)0x7FFFFFFFFFFFFFFFLL) {
        id v37 = 0LL;
      }
      else {
        id v37 = objc_msgSend(a2, "substringWithRange:", v35, v36);
      }
      id v38 = [v9 rangeWithName:@"binaryUuid"];
      if (v38 == (id)0x7FFFFFFFFFFFFFFFLL)
      {
        if (byte_1000E7D30)
        {
          int v83 = *__error();
          BOOL v84 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v84, OS_LOG_TYPE_ERROR)) {
            sub_100094EBC();
          }
          *__error() = v83;
        }

        if (byte_1000E7D31 && dword_1000E74E0 <= 3)
        {
          int v85 = *__error();
          int v86 = CFStringCreateWithFormat( kCFAllocatorDefault,  0,  @"%s: No uuid in load info (%d: %s)",  "range.location != NSNotFound",  a3,  [a2 UTF8String]);
          if (v86)
          {
            int v103 = v86;
            __int16 v104 = CFStringGetCStringPtr(v86, 0x8000100u);
            if (v104)
            {
              uint32_t v105 = (char *)v104;
              uint64_t v106 = 0LL;
            }

            else
            {
              uint32_t v105 = (char *)calloc(0x400uLL, 1uLL);
              CFStringGetCString(v103, v105, 1024LL, 0x8000100u);
              uint64_t v106 = v105;
            }

            if (qword_1000E7D38) {
              id v115 = (FILE *)qword_1000E7D38;
            }
            else {
              id v115 = __stderrp;
            }
            fprintf(v115, "%s\n", v105);
            if (v106) {
              free(v106);
            }
            CFRelease(v103);
          }

          else
          {
            int v87 = (os_log_s *)sub_10002EFA0();
            if (os_log_type_enabled(v87, OS_LOG_TYPE_FAULT)) {
              sub_100094E48();
            }
            if (qword_1000E7D38) {
              id v88 = (FILE *)qword_1000E7D38;
            }
            else {
              id v88 = __stderrp;
            }
            fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v88);
          }

          *__error() = v85;
        }

        [a2 UTF8String];
        sub_10002EE78( "ParseLoadInfoLine",  "SPTextualReportParser.m",  2391,  "%s: No uuid in load info (%d: %s)",  v116,  v117,  v118,  v119,  (char)"range.location != NSNotFound");
      }

      else
      {
        uint64_t v131 = a3;
        int v40 = sub_10007E3B0(objc_msgSend(a2, "substringWithRange:", v38, v39));
        id v41 = [v9 rangeWithName:@"segmentName"];
        if (v41 == (id)0x7FFFFFFFFFFFFFFFLL) {
          id v43 = 0LL;
        }
        else {
          id v43 = objc_msgSend(a2, "substringWithRange:", v41, v42);
        }
        id v44 = [v9 rangeWithName:@"binaryPath"];
        if (v44 == (id)0x7FFFFFFFFFFFFFFFLL) {
          id v46 = 0LL;
        }
        else {
          id v46 = objc_msgSend(a2, "substringWithRange:", v44, v45);
        }
        id v47 = v31;
        id v48 = v34;
        id v49 = v37;
        uint64_t v50 = v40;
        id v51 = v43;
        id v52 = v46;
        if (v40)
        {
          if (*(_BYTE *)(a1 + 56) && (unint64_t result = (int *)[*(id *)(a1 + 40) count], v134 != result))
          {
            if (byte_1000E7D30)
            {
              int v55 = *__error();
              int v56 = (os_log_s *)sub_10002EFA0();
              if (os_log_type_enabled(v56, OS_LOG_TYPE_ERROR))
              {
                id v80 = [*(id *)(a1 + 40) count];
                *(_DWORD *)buf = 134218754;
                *(void *)integer_t v136 = v80;
                *(_WORD *)&v136[8] = 2048;
                *(void *)&v136[10] = v134;
                __int16 v137 = 1024;
                int v138 = v131;
                __int16 v139 = 2112;
                id v140 = a2;
                _os_log_error_impl( (void *)&_mh_execute_header,  v56,  OS_LOG_TYPE_ERROR,  "Parsing spindump text: corrupt condensed file, binary at position %lu has index %lu (%d: %@)",  buf,  0x26u);
              }

              unint64_t result = __error();
              *unint64_t result = v55;
            }

            if (byte_1000E7D31 && dword_1000E74E0 <= 3)
            {
              int v57 = *__error();
              int v58 = CFStringCreateWithFormat( kCFAllocatorDefault,  0,  @"Parsing spindump text: corrupt condensed file, binary at position %lu has index %lu (%d: %@)",  [*(id *)(a1 + 40) count],  v134,  v131,  a2);
              if (v58)
              {
                uint32_t v59 = v58;
                id v60 = CFStringGetCStringPtr(v58, 0x8000100u);
                if (v60)
                {
                  int v61 = (char *)v60;
                  unsigned int v62 = 0LL;
                }

                else
                {
                  int v61 = (char *)calloc(0x400uLL, 1uLL);
                  CFStringGetCString(v59, v61, 1024LL, 0x8000100u);
                  unsigned int v62 = v61;
                }

                if (qword_1000E7D38) {
                  uint64_t v77 = (FILE *)qword_1000E7D38;
                }
                else {
                  uint64_t v77 = __stderrp;
                }
                fprintf(v77, "%s\n", v61);
                if (v62) {
                  free(v62);
                }
                CFRelease(v59);
              }

              else
              {
                uint64_t v74 = (os_log_s *)sub_10002EFA0();
                if (os_log_type_enabled(v74, OS_LOG_TYPE_FAULT))
                {
                  id v82 = [*(id *)(a1 + 40) count];
                  *(_DWORD *)buf = 134218754;
                  *(void *)integer_t v136 = v82;
                  *(_WORD *)&v136[8] = 2048;
                  *(void *)&v136[10] = v134;
                  __int16 v137 = 1024;
                  int v138 = v131;
                  __int16 v139 = 2112;
                  id v140 = a2;
                  _os_log_fault_impl( (void *)&_mh_execute_header,  v74,  OS_LOG_TYPE_FAULT,  "Unable to format: Parsing spindump text: corrupt condensed file, binary at position %lu has index %lu (%d: %@)",  buf,  0x26u);
                }

                if (qword_1000E7D38) {
                  uint64_t v75 = (FILE *)qword_1000E7D38;
                }
                else {
                  uint64_t v75 = __stderrp;
                }
                fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v75);
              }

              unint64_t result = __error();
              *unint64_t result = v57;
            }

            *(_BYTE *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL) = 0;
            _BYTE *v130 = 1;
          }

          else
          {
            else {
              id v53 = 0LL;
            }
            unsigned int v54 = +[SABinary binaryWithUUID:absolutePath:]( &OBJC_CLASS___SABinary,  "binaryWithUUID:absolutePath:",  v40,  v53);
            if (!-[SABinary path](v54, "path"))
            {
              if (v46) {
                -[SABinary addPath:](v54, "addPath:", v46);
              }
            }

            return (int *)objc_msgSend( *(id *)(a1 + 40),  "addObject:",   sub_100073390( [SPLoadInfo alloc],  v54,  v11 != (id)0x7FFFFFFFFFFFFFFFLL,  v133,  v132,  v31,  v34,  v37,  v43));
          }

          return result;
        }

        if (byte_1000E7D30)
        {
          int v89 = *__error();
          id v90 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v90, OS_LOG_TYPE_ERROR)) {
            sub_100094FA4();
          }
          *__error() = v89;
        }

        if (byte_1000E7D31 && dword_1000E74E0 <= 3)
        {
          int v91 = *__error();
          uint32_t v92 = CFStringCreateWithFormat( kCFAllocatorDefault,  0,  @"%s: No UUID in (%d: %s)",  "uuid",  v131,  [a2 UTF8String]);
          if (v92)
          {
            int v107 = v92;
            uint64_t v108 = CFStringGetCStringPtr(v92, 0x8000100u);
            if (v108)
            {
              id v109 = (char *)v108;
              BOOL v110 = 0LL;
            }

            else
            {
              id v109 = (char *)calloc(0x400uLL, 1uLL);
              CFStringGetCString(v107, v109, 1024LL, 0x8000100u);
              BOOL v110 = v109;
            }

            if (qword_1000E7D38) {
              id v120 = (FILE *)qword_1000E7D38;
            }
            else {
              id v120 = __stderrp;
            }
            fprintf(v120, "%s\n", v109);
            if (v110) {
              free(v110);
            }
            CFRelease(v107);
          }

          else
          {
            int v93 = (os_log_s *)sub_10002EFA0();
            if (os_log_type_enabled(v93, OS_LOG_TYPE_FAULT)) {
              sub_100094F30();
            }
            if (qword_1000E7D38) {
              double v94 = (FILE *)qword_1000E7D38;
            }
            else {
              double v94 = __stderrp;
            }
            fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v94);
          }

          *__error() = v91;
        }

        [a2 UTF8String];
        sub_10002EE78( "CopyNextLoadInfos_block_invoke",  "SPTextualReportParser.m",  1066,  "%s: No UUID in (%d: %s)",  v121,  v122,  v123,  v124,  (char)"uuid");
      }

void *sub_10007DF6C( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = a1 + 32;
  uint64_t v10 = *(void *)(*(void *)(a1 + 32) + 8LL);
  int v11 = *(_DWORD *)(v10 + 24);
  if (v11)
  {
    *(_DWORD *)(v10 + 24) = 2 * v11;
    int v12 = *(_DWORD *)(*(void *)(*(void *)v9 + 8LL) + 24LL);
    if (v12 <= 0)
    {
      if (byte_1000E7D30)
      {
        int v13 = *__error();
        unint64_t v14 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
          sub_100094720();
        }
        *__error() = v13;
      }

      if (byte_1000E7D31) {
        BOOL v15 = dword_1000E74E0 <= 3;
      }
      else {
        BOOL v15 = 0;
      }
      if (v15)
      {
        int v16 = *__error();
        uint64_t v17 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"%s: bufSize overflow (%d)",  "bufSize > 0",  *(unsigned int *)(*(void *)(*(void *)v9 + 8LL) + 24LL));
        if (v17)
        {
          uint64_t v36 = v17;
          CStringPtr = CFStringGetCStringPtr(v17, 0x8000100u);
          if (CStringPtr)
          {
            id v38 = (char *)CStringPtr;
            uint64_t v39 = 0LL;
          }

          else
          {
            id v38 = (char *)calloc(0x400uLL, 1uLL);
            CFStringGetCString(v36, v38, 1024LL, 0x8000100u);
            uint64_t v39 = v38;
          }

          if (qword_1000E7D38) {
            int v40 = (FILE *)qword_1000E7D38;
          }
          else {
            int v40 = __stderrp;
          }
          fprintf(v40, "%s\n", v38);
          if (v39) {
            free(v39);
          }
          CFRelease(v36);
        }

        else
        {
          BOOL v18 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v18, OS_LOG_TYPE_FAULT)) {
            sub_1000946B0();
          }
          if (qword_1000E7D38) {
            int v19 = (FILE *)qword_1000E7D38;
          }
          else {
            int v19 = __stderrp;
          }
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v19);
        }

        *__error() = v16;
      }

      sub_10002EE78( "LookaheadLines_block_invoke",  "SPTextualReportParser.m",  976,  "%s: bufSize overflow (%d)",  a5,  a6,  a7,  a8,  (char)"bufSize > 0");
      goto LABEL_56;
    }
  }

  else
  {
    *(_DWORD *)(v10 + 24) = 0x4000;
    int v12 = *(_DWORD *)(*(void *)(*(void *)v9 + 8LL) + 24LL);
  }

  unint64_t result = reallocf(*(void **)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL), v12);
  *(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = result;
  if (!*(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL))
  {
    if (byte_1000E7D30)
    {
      int v25 = *__error();
      uint64_t v26 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR)) {
        sub_100094640();
      }
      *__error() = v25;
    }

    if (byte_1000E7D31 && dword_1000E74E0 <= 3)
    {
      int v27 = *__error();
      uint64_t v28 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"%s: Unable to allocate %d buffer",  "buf",  *(unsigned int *)(*(void *)(*(void *)v9 + 8LL) + 24LL));
      if (v28)
      {
        id v31 = v28;
        id v32 = CFStringGetCStringPtr(v28, 0x8000100u);
        if (v32)
        {
          uint64_t v33 = (char *)v32;
          id v34 = 0LL;
        }

        else
        {
          uint64_t v33 = (char *)calloc(0x400uLL, 1uLL);
          CFStringGetCString(v31, v33, 1024LL, 0x8000100u);
          id v34 = v33;
        }

        if (qword_1000E7D38) {
          id v35 = (FILE *)qword_1000E7D38;
        }
        else {
          id v35 = __stderrp;
        }
        fprintf(v35, "%s\n", v33);
        if (v34) {
          free(v34);
        }
        CFRelease(v31);
      }

      else
      {
        id v29 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v29, OS_LOG_TYPE_FAULT)) {
          sub_1000945D0();
        }
        if (qword_1000E7D38) {
          uint64_t v30 = (FILE *)qword_1000E7D38;
        }
        else {
          uint64_t v30 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v30);
      }

      *__error() = v27;
    }

    sub_10002EE78( "LookaheadLines_block_invoke",  "SPTextualReportParser.m",  979,  "%s: Unable to allocate %d buffer",  v21,  v22,  v23,  v24,  (char)"buf");
LABEL_56:
    abort();
  }

  return result;
}

NSUUID *sub_10007E3B0(void *a1)
{
  size_t v2 = -[NSUUID initWithUUIDString:](objc_alloc(&OBJC_CLASS___NSUUID), "initWithUUIDString:", a1);
  if (!v2)
  {
    if ((unint64_t)[a1 length] < 0x20)
    {
      size_t v2 = 0LL;
    }

    else
    {
      unint64_t v3 = -[NSString initWithFormat:]( [NSString alloc],  "initWithFormat:",  @"%@-%@-%@-%@-%@",  objc_msgSend(a1, "substringWithRange:", 0, 8),  objc_msgSend(a1, "substringWithRange:", 8, 4),  objc_msgSend(a1, "substringWithRange:", 12, 4),  objc_msgSend(a1, "substringWithRange:", 16, 4),  objc_msgSend(a1, "substringWithRange:", 20, 12));
      size_t v2 = -[NSUUID initWithUUIDString:](objc_alloc(&OBJC_CLASS___NSUUID), "initWithUUIDString:", v3);
    }
  }

  return v2;
}

uint64_t sub_10007E4CC(uint64_t a1, uint64_t a2)
{
  if (a2) {
    unint64_t v2 = *(void *)(a2 + 56);
  }
  else {
    unint64_t v2 = 0LL;
  }
  unint64_t v3 = *(void *)(a1 + 32);
  BOOL v4 = v3 > v2;
  if (v3 >= v2) {
    uint64_t v5 = 0LL;
  }
  else {
    uint64_t v5 = -1LL;
  }
  if (v4) {
    return 1LL;
  }
  else {
    return v5;
  }
}

void sub_10007E4F0(uint64_t a1, uint64_t a2)
{
}

void sub_10007E500(uint64_t a1)
{
}

id *sub_10007E50C(uint64_t a1, void *a2, uint64_t a3, _BYTE *a4)
{
  if (!*(_BYTE *)(a1 + 104)
    && (([a2 hasPrefix:@"Process:"] & 1) != 0
     || [a2 hasPrefix:@"Powerstats for:"]))
  {
    __int128 v23 = 0u;
    __int128 v24 = 0u;
    __int128 v21 = 0u;
    __int128 v22 = 0u;
    id v8 = *(void **)(a1 + 32);
    id v9 = [v8 countByEnumeratingWithState:&v21 objects:v25 count:16];
    if (v9)
    {
      id v10 = v9;
      uint64_t v11 = *(void *)v22;
      do
      {
        for (uint64_t i = 0LL; i != v10; uint64_t i = (char *)i + 1)
        {
          if (*(void *)v22 != v11) {
            objc_enumerationMutation(v8);
          }
          *(_BYTE *)(*(void *)(*(void *)(a1 + 80) + 8) + 24) = [a2 containsString:*(void *)(*((void *)&v21 + 1) + 8 * (void)i)];
        }

        id v10 = [v8 countByEnumeratingWithState:&v21 objects:v25 count:16];
      }

      while (v10);
    }
  }

  unint64_t result = (id *)[a2 containsString:@"Binary Images:"];
  if ((_DWORD)result)
  {
    if (!*(_BYTE *)(a1 + 105))
    {

      unint64_t result = (id *)sub_10007A220(*(FILE **)(a1 + 96), a3, *(void *)(a1 + 40), *(_BYTE *)(a1 + 105));
      *(void *)(*(void *)(*(void *)(a1 + 88) + 8LL) + 40LL) = result;
      if (!*(void *)(*(void *)(*(void *)(a1 + 88) + 8LL) + 40LL)) {
        *a4 = 1;
      }
    }
  }

  else
  {
    unint64_t result = (id *)objc_msgSend( *(id *)(a1 + 48),  "firstMatchInString:options:range:",  a2,  0,  0,  objc_msgSend(a2, "length"));
    if (result)
    {
      unint64_t v20 = -1LL;
      unint64_t result = (id *)sub_10007A3B0( a2,  a3,  result,  *(void **)(*(void *)(*(void *)(a1 + 88) + 8LL) + 40LL),  *(unsigned __int8 *)(a1 + 105),  &v20);
      if (result)
      {
        unint64_t v14 = result;
        if (!objc_msgSend(*(id *)(a1 + 56), "objectForKeyedSubscript:", objc_msgSend(result[5], "uuid"))) {
          objc_msgSend(*(id *)(a1 + 56), "setObject:forKeyedSubscript:", v14[5], objc_msgSend(v14[5], "uuid"));
        }
        if (*(_BYTE *)(*(void *)(*(void *)(a1 + 80) + 8LL) + 24LL)) {
          objc_msgSend(*(id *)(a1 + 64), "addObject:", objc_msgSend(v14[5], "uuid"));
        }
        id v15 = objc_msgSend(*(id *)(a1 + 72), "objectForKeyedSubscript:", objc_msgSend(v14[5], "uuid"));
        if (!v15)
        {
          id v15 = +[NSMutableDictionary dictionary](&OBJC_CLASS___NSMutableDictionary, "dictionary");
          objc_msgSend(*(id *)(a1 + 72), "setObject:forKeyedSubscript:", v15, objc_msgSend(v14[5], "uuid"));
        }

        int v16 = (NSNull *)v14[6];
        if (!v16) {
          int v16 = +[NSNull null](&OBJC_CLASS___NSNull, "null");
        }
        id v17 = [v15 objectForKeyedSubscript:v16];
        if (!v17)
        {
          id v17 = +[NSMutableSet set](&OBJC_CLASS___NSMutableSet, "set");
          BOOL v18 = (NSNull *)v14[6];
          if (!v18) {
            BOOL v18 = +[NSNull null](&OBJC_CLASS___NSNull, "null");
          }
          [v15 setObject:v17 forKeyedSubscript:v18];
        }

        unint64_t v19 = v20;
        objc_msgSend( v17,  "addObject:",  +[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", v20));
        return (id *)objc_msgSend( v17,  "addObject:",  +[NSNumber numberWithUnsignedLongLong:]( NSNumber,  "numberWithUnsignedLongLong:",  v19 - 1));
      }
    }
  }

  return result;
}

int *sub_10007E854(uint64_t a1, uint64_t a2, void *a3)
{
  else {
    uint64_t v5 = 628LL;
  }
  unint64_t result = (int *)[a3 cacheSymbolOwnerWithOptions:v5 pid:0xFFFFFFFFLL];
  if ((result & 1) != 0)
  {
    id v7 = objc_msgSend(*(id *)(a1 + 40), "objectForKeyedSubscript:", objc_msgSend(a3, "uuid"));
    v24[0] = _NSConcreteStackBlock;
    v24[1] = 3221225472LL;
    v24[2] = sub_10007EB74;
    v24[3] = &unk_1000D9D50;
    v24[4] = a3;
    [v7 enumerateKeysAndObjectsUsingBlock:v24];
    [a3 symbolicateAllInstructionsWithOptions:628 pid:0xFFFFFFFFLL];
    return (int *)[a3 clearCoreSymbolicationCache];
  }

  else
  {
    if (byte_1000E7D30)
    {
      int v8 = *__error();
      id v9 = (os_log_s *)sub_10002EFA0();
      if (os_log_type_enabled(v9, OS_LOG_TYPE_INFO))
      {
        id v10 = [a3 uuid];
        id v11 = [a3 path];
        if (!v11) {
          id v11 = [a3 name];
        }
        *(_DWORD *)buf = 138412546;
        id v26 = v10;
        __int16 v27 = 2112;
        id v28 = v11;
        _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_INFO,  "Parsing spindump text: Unable to find symbol owner for %@ %@",  buf,  0x16u);
      }

      unint64_t result = __error();
      *unint64_t result = v8;
    }

    if (byte_1000E7D31) {
      BOOL v12 = dword_1000E74E0 <= 1;
    }
    else {
      BOOL v12 = 0;
    }
    if (v12)
    {
      int v13 = *__error();
      id v14 = [a3 uuid];
      id v15 = [a3 path];
      if (!v15) {
        id v15 = [a3 name];
      }
      int v16 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"Parsing spindump text: Unable to find symbol owner for %@ %@",  v14,  v15);
      if (v16)
      {
        id v17 = v16;
        CStringPtr = CFStringGetCStringPtr(v16, 0x8000100u);
        if (CStringPtr)
        {
          unint64_t v19 = (char *)CStringPtr;
          unint64_t v20 = 0LL;
        }

        else
        {
          unint64_t v19 = (char *)calloc(0x400uLL, 1uLL);
          CFStringGetCString(v17, v19, 1024LL, 0x8000100u);
          unint64_t v20 = v19;
        }

        if (qword_1000E7D38) {
          __int128 v23 = (FILE *)qword_1000E7D38;
        }
        else {
          __int128 v23 = __stderrp;
        }
        fprintf(v23, "%s\n", v19);
        if (v20) {
          free(v20);
        }
        CFRelease(v17);
      }

      else
      {
        __int128 v21 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v21, OS_LOG_TYPE_FAULT)) {
          sub_100095100(a3, v21);
        }
        if (qword_1000E7D38) {
          __int128 v22 = (FILE *)qword_1000E7D38;
        }
        else {
          __int128 v22 = __stderrp;
        }
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v22);
      }

      unint64_t result = __error();
      *unint64_t result = v13;
    }
  }

  return result;
}

int *sub_10007EB74(uint64_t a1, NSNull *a2, void *a3)
{
  if (+[NSNull null](&OBJC_CLASS___NSNull, "null") == a2)
  {
    __int128 v30 = 0u;
    __int128 v31 = 0u;
    __int128 v28 = 0u;
    __int128 v29 = 0u;
    unint64_t result = (int *)[a3 countByEnumeratingWithState:&v28 objects:v36 count:16];
    if (result)
    {
      int v13 = result;
      uint64_t v14 = *(void *)v29;
      do
      {
        id v15 = 0LL;
        do
        {
          if (*(void *)v29 != v14) {
            objc_enumerationMutation(a3);
          }
          objc_msgSend( *(id *)(a1 + 32),  "instructionAtOffsetIntoBinary:",  objc_msgSend(*(id *)(*((void *)&v28 + 1) + 8 * (void)v15), "unsignedLongLongValue"));
          id v15 = (int *)((char *)v15 + 1);
        }

        while (v13 != v15);
        unint64_t result = (int *)[a3 countByEnumeratingWithState:&v28 objects:v36 count:16];
        int v13 = result;
      }

      while (result);
    }
  }

  else
  {
    id v7 = *(void **)(a1 + 32);
    off_t v6 = (id *)(a1 + 32);
    unint64_t result = (int *)[v7 segmentWithName:a2];
    if (result)
    {
      id v9 = result;
      __int128 v34 = 0u;
      __int128 v35 = 0u;
      __int128 v32 = 0u;
      __int128 v33 = 0u;
      unint64_t result = (int *)[a3 countByEnumeratingWithState:&v32 objects:v37 count:16];
      if (result)
      {
        id v10 = result;
        uint64_t v11 = *(void *)v33;
        do
        {
          BOOL v12 = 0LL;
          do
          {
            if (*(void *)v33 != v11) {
              objc_enumerationMutation(a3);
            }
            objc_msgSend( v9,  "instructionAtOffsetIntoSegment:",  objc_msgSend(*(id *)(*((void *)&v32 + 1) + 8 * (void)v12), "unsignedLongLongValue"));
            BOOL v12 = (int *)((char *)v12 + 1);
          }

          while (v10 != v12);
          unint64_t result = (int *)[a3 countByEnumeratingWithState:&v32 objects:v37 count:16];
          id v10 = result;
        }

        while (result);
      }
    }

    else
    {
      if (byte_1000E7D30)
      {
        int v16 = *__error();
        id v17 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR)) {
          sub_100095238((uint64_t)a2, v6);
        }
        unint64_t result = __error();
        *unint64_t result = v16;
      }

      if (byte_1000E7D31) {
        BOOL v18 = dword_1000E74E0 <= 3;
      }
      else {
        BOOL v18 = 0;
      }
      if (v18)
      {
        int v19 = *__error();
        unint64_t v20 = CFStringCreateWithFormat( kCFAllocatorDefault,  0,  @"Parsing spindump text: Unable to find segment %@ in %@ %@",  a2,  [*v6 uuid],  objc_msgSend(*v6, "name"));
        if (v20)
        {
          __int128 v21 = v20;
          CStringPtr = CFStringGetCStringPtr(v20, 0x8000100u);
          if (CStringPtr)
          {
            __int128 v23 = (char *)CStringPtr;
            __int128 v24 = 0LL;
          }

          else
          {
            __int128 v23 = (char *)calloc(0x400uLL, 1uLL);
            CFStringGetCString(v21, v23, 1024LL, 0x8000100u);
            __int128 v24 = v23;
          }

          if (qword_1000E7D38) {
            __int16 v27 = (FILE *)qword_1000E7D38;
          }
          else {
            __int16 v27 = __stderrp;
          }
          fprintf(v27, "%s\n", v23);
          if (v24) {
            free(v24);
          }
          CFRelease(v21);
        }

        else
        {
          int v25 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v25, OS_LOG_TYPE_FAULT)) {
            sub_1000951B8((uint64_t)a2, v6, v25);
          }
          if (qword_1000E7D38) {
            id v26 = (FILE *)qword_1000E7D38;
          }
          else {
            id v26 = __stderrp;
          }
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v26);
        }

        unint64_t result = __error();
        *unint64_t result = v19;
      }
    }
  }

  return result;
}

NSMutableArray *sub_10007EEDC(void *a1, void *a2, uint64_t a3, uint64_t a4, unsigned int a5, int a6)
{
  BOOL v12 = objc_autoreleasePoolPush();
  id v13 = [a2 rangeWithName:@"fakeFrameInfo"];
  if (v13 != (id)0x7FFFFFFFFFFFFFFFLL)
  {
    BOOL v18 = -[NSArray initWithObjects:]( [NSArray alloc],  "initWithObjects:",  objc_msgSend(a1, "substringWithRange:", v13, v14),  0);
LABEL_21:
    __int128 v30 = (NSMutableArray *)v18;
    goto LABEL_22;
  }

  id v15 = [a2 rangeWithName:@"symbolName"];
  if (v15 == (id)0x7FFFFFFFFFFFFFFFLL)
  {
    id v17 = 0LL;
  }

  else
  {
    id v19 = objc_msgSend(a1, "substringWithRange:", v15, v16);
    else {
      id v17 = v19;
    }
  }

  id v20 = [a2 rangeWithName:@"sourceFilepath"];
  if (v20 == (id)0x7FFFFFFFFFFFFFFFLL) {
    id v22 = 0LL;
  }
  else {
    id v22 = objc_msgSend(a1, "substringWithRange:", v20, v21);
  }
  id v23 = [a2 rangeWithName:@"binaryName"];
  if (v23 != (id)0x7FFFFFFFFFFFFFFFLL)
  {
    __int128 v28 = (NSString *)objc_msgSend(a1, "substringWithRange:", v23, v24);
LABEL_16:
    __int16 v27 = v28;
    goto LABEL_17;
  }

  id v25 = [a2 rangeWithName:@"binaryUuid"];
  if (v25 != (id)0x7FFFFFFFFFFFFFFFLL)
  {
    __int128 v28 = +[NSString stringWithFormat:]( NSString,  "stringWithFormat:",  @"<%@>",  objc_msgSend(a1, "substringWithRange:", v25, v26));
    goto LABEL_16;
  }

  __int16 v27 = 0LL;
LABEL_17:
  v42[0] = _NSConcreteStackBlock;
  v42[1] = 3221225472LL;
  v42[2] = sub_10007F2A8;
  v42[3] = &unk_1000D9DA0;
  v42[4] = a2;
  v42[5] = a1;
  v42[6] = v17;
  v42[7] = v22;
  v42[8] = v27;
  if (a6 || a4 == 0x7FFFFFFFFFFFFFFFLL) {
    goto LABEL_19;
  }
  if (!a3 || (__int128 v32 = *(void **)(a3 + 40)) == 0LL)
  {
    __int128 v29 = objc_alloc(&OBJC_CLASS___NSArray);
    if (v27) {
      goto LABEL_20;
    }
LABEL_36:
    id v37 = +[NSMutableString string](&OBJC_CLASS___NSMutableString, "string");
    [v37 appendString:@"???"];
    BOOL v18 = -[NSArray initWithObjects:](v29, "initWithObjects:", v37, 0LL);
    goto LABEL_21;
  }

  if (*(void *)(a3 + 48))
  {
    id v33 = objc_msgSend(*(id *)(a3 + 40), "segmentWithName:");
    if (!v33)
    {
LABEL_19:
      __int128 v29 = objc_alloc(&OBJC_CLASS___NSArray);
LABEL_20:
      BOOL v18 = -[NSArray initWithObjects:](v29, "initWithObjects:", sub_10007F2A8((uint64_t)v42), 0LL);
      goto LABEL_21;
    }

    id v34 = [v33 instructionAtOffsetIntoSegment:a4 - a5];
  }

  else
  {
    id v34 = [*(id *)(a3 + 40) instructionAtOffsetIntoBinary:a4 - a5];
  }

  __int128 v35 = v34;
  if (!v34)
  {
    __int128 v29 = objc_alloc(&OBJC_CLASS___NSArray);
    goto LABEL_36;
  }

  if ((unint64_t)[v34 numSymbols] <= 1)
  {
    if (v22) {
      goto LABEL_19;
    }
    unsigned __int8 v38 = [v35 hasSourceInfo];
    if (v17)
    {
      if ((v38 & 1) == 0) {
        goto LABEL_19;
      }
    }
  }

  if ([v32 name]) {
    uint64_t v36 = (NSString *)[v32 name];
  }
  else {
    uint64_t v36 = +[NSString stringWithFormat:]( NSString,  "stringWithFormat:",  @"<%@>",  objc_msgSend(objc_msgSend(v32, "uuid"), "UUIDString"));
  }
  uint64_t v39 = (uint64_t)v36;
  __int128 v30 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
  v40[0] = _NSConcreteStackBlock;
  v40[1] = 3221225472LL;
  v40[2] = sub_10007F53C;
  v40[3] = &unk_1000D9DC8;
  char v41 = a5;
  void v40[4] = v35;
  v40[5] = v39;
  v40[6] = v30;
  v40[7] = a4;
  [v35 enumerateSymbols:v40];
  if (!-[NSMutableArray count](v30, "count"))
  {

    BOOL v18 = -[NSArray initWithObjects:]( objc_alloc(&OBJC_CLASS___NSArray),  "initWithObjects:",  sub_10007F3E4(0LL, -1LL, 0LL, 0LL, 0LL, v39, a4),  0LL);
    goto LABEL_21;
  }

LABEL_22:
  objc_autoreleasePoolPop(v12);
  return v30;
}

void *sub_10007F2A8(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) rangeWithName:@"offsetIntoSymbol"];
  if (v2 == (id)0x7FFFFFFFFFFFFFFFLL
    && (id v2 = [*(id *)(a1 + 32) rangeWithName:@"offsetIntoUnknownSymbol"],
        v2 == (id)0x7FFFFFFFFFFFFFFFLL))
  {
    unint64_t v4 = -1LL;
  }

  else
  {
    unint64_t v4 = sub_10007BD4C(objc_msgSend(*(id *)(a1 + 40), "substringWithRange:", v2, v3));
  }

  id v5 = [*(id *)(a1 + 32) rangeWithName:@"sourceLineNumber"];
  if (v5 == (id)0x7FFFFFFFFFFFFFFFLL) {
    unint64_t v7 = 0LL;
  }
  else {
    unint64_t v7 = sub_10007BD4C(objc_msgSend(*(id *)(a1 + 40), "substringWithRange:", v5, v6));
  }
  id v8 = [*(id *)(a1 + 32) rangeWithName:@"sourceColumnNumber"];
  if (v8 == (id)0x7FFFFFFFFFFFFFFFLL) {
    unint64_t v10 = 0LL;
  }
  else {
    unint64_t v10 = sub_10007BD4C(objc_msgSend(*(id *)(a1 + 40), "substringWithRange:", v8, v9));
  }
  id v11 = [*(id *)(a1 + 32) rangeWithName:@"offsetIntoBinary"];
  if (v11 == (id)0x7FFFFFFFFFFFFFFFLL) {
    unint64_t v13 = -1LL;
  }
  else {
    unint64_t v13 = sub_10007BD4C(objc_msgSend(*(id *)(a1 + 40), "substringWithRange:", v11, v12));
  }
  return sub_10007F3E4(*(void *)(a1 + 48), v4, *(void *)(a1 + 56), v7, v10, *(void *)(a1 + 64), v13);
}

void *sub_10007F3E4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  id v14 = +[NSMutableString string](&OBJC_CLASS___NSMutableString, "string");
  id v15 = v14;
  if (!a1)
  {
    [v14 appendString:@"???"];
    if (!a6) {
      return v15;
    }
    goto LABEL_7;
  }

  [v14 appendString:a1];
  if (a2 != -1) {
    objc_msgSend(v15, "appendFormat:", @" + %llu", a2);
  }
  if (a6)
  {
LABEL_7:
    objc_msgSend(v15, "appendString:", @" (");
    if (a3)
    {
      [v15 appendString:a3];
      if ((int)a4 >= 1)
      {
        objc_msgSend(v15, "appendFormat:", @":%u", a4);
      }

      [v15 appendString:@" in "];
    }

    [v15 appendFormat:@"%@", a6];
    if (a7 != -1) {
      objc_msgSend(v15, "appendFormat:", @" + %llu", a7);
    }
    [v15 appendString:@""]);
  }

  return v15;
}

id sub_10007F53C(uint64_t a1, void *a2, void *a3)
{
  return objc_msgSend( *(id *)(a1 + 48),  "addObject:",  sub_10007F3E4( (uint64_t)objc_msgSend(a2, "name"),  (_BYTE *)objc_msgSend(*(id *)(a1 + 32), "offsetIntoSegment")
           - (_BYTE *)[a2 offsetIntoSegment]
           + *(unsigned __int8 *)(a1 + 64),
             (uint64_t)[a3 fileName],
             (uint64_t)[a3 lineNum],
             (uint64_t)[a3 columnNum],
             *(void *)(a1 + 40),
             *(void *)(a1 + 56)));
}

unint64_t sub_10007F5E4(uint64_t a1, void *a2, uint64_t a3, _BYTE *a4)
{
  id v8 = objc_msgSend(*(id *)(a1 + 32), "firstMatchInString:options:range:", a2, 0, 0, objc_msgSend(a2, "length"));
  if (v8)
  {
    uint64_t v9 = v8;
    *a4 = 1;
    unint64_t result = sub_10007A31C(a2, v8, *(unsigned __int8 *)(a1 + 116), *(_DWORD *)(a1 + 104), *(_DWORD *)(a1 + 108));
    BOOL v11 = 0;
    if ((int)result > *(_DWORD *)(a1 + 112))
    {
      if (*(_BYTE *)(a1 + 117)
        || (unint64_t result = (unint64_t)[v9 rangeWithName:@"kernelDot"],
            result == 0x7FFFFFFFFFFFFFFFLL))
      {
        BOOL v11 = 1;
      }
    }

    uint64_t v12 = *(_BYTE **)(a1 + 80);
    **(_BYTE **)(a1 + 72) = v11;
    if (!*v12)
    {
      uint64_t v13 = *(void *)(a1 + 48);
      if (v13)
      {
        if (*(void *)(v13 + 40))
        {
          if (*(void *)(a1 + 88) != -1LL)
          {
            unint64_t v17 = -1LL;
            unint64_t result = (unint64_t)sub_10007A3B0( a2,  a3,  v9,  *(void **)(a1 + 56),  *(unsigned __int8 *)(a1 + 116),  &v17);
            if (*(void *)(a1 + 48) == result && v17 == *(void *)(a1 + 88))
            {
              unint64_t result = (unint64_t)[v9 rangeWithName:@"symbolName"];
              uint64_t v15 = *(void *)(a1 + 64);
              if (result == 0x7FFFFFFFFFFFFFFFLL)
              {
                if (v15)
                {
LABEL_23:
                  **(_BYTE **)(a1 + 80) = 1;
                  return result;
                }
              }

              else
              {
                if (!v15) {
                  goto LABEL_23;
                }
                unint64_t result = (unint64_t)objc_msgSend( *(id *)(a1 + 64),  "isEqual:",  objc_msgSend(a2, "substringWithRange:", result, v14));
                if ((result & 1) == 0) {
                  goto LABEL_23;
                }
              }

              unint64_t result = (unint64_t)[v9 rangeWithName:@"offsetIntoSymbol"];
              if (result != 0x7FFFFFFFFFFFFFFFLL)
              {
                unint64_t result = sub_10007BD4C(objc_msgSend(a2, "substringWithRange:", result, v16));
                if (result != *(void *)(a1 + 96)) {
                  goto LABEL_23;
                }
              }
            }
          }
        }
      }
    }
  }

  else
  {
    unint64_t result = (unint64_t)objc_msgSend( *(id *)(a1 + 40),  "firstMatchInString:options:range:",  a2,  0,  0,  objc_msgSend(a2, "length"));
    if (!result) {
      *a4 = 1;
    }
  }

  return result;
}

id sub_10007F7E0(uint64_t a1, void *a2, uint64_t a3, _BYTE *a4)
{
  id result = objc_msgSend(*(id *)(a1 + 32), "firstMatchInString:options:range:", a2, 0, 0, objc_msgSend(a2, "length"));
  if (result)
  {
    uint64_t v9 = result;
    **(_BYTE **)(a1 + 40) = [result rangeWithName:@"startIndex"] == (id)0x7FFFFFFFFFFFFFFFLL;
    id result = [v9 rangeWithName:@"indentWhitespace"];
    if (result == (id)0x7FFFFFFFFFFFFFFFLL) {
      int v11 = -1;
    }
    else {
      int v11 = v10;
    }
    if (v11 < 0)
    {
      if (byte_1000E7D30)
      {
        int v16 = *__error();
        unint64_t v17 = (os_log_s *)sub_10002EFA0();
        if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR)) {
          sub_100095324();
        }
        *__error() = v16;
      }

      if (byte_1000E7D31) {
        BOOL v18 = dword_1000E74E0 <= 3;
      }
      else {
        BOOL v18 = 0;
      }
      if (v18)
      {
        int v19 = *__error();
        id v20 = CFStringCreateWithFormat( kCFAllocatorDefault,  0,  @"%s: frame match with no whitespace indent (%d: %s)",  "whitespaceLength >= 0",  a3,  [a2 UTF8String]);
        if (v20)
        {
          id v23 = v20;
          CStringPtr = CFStringGetCStringPtr(v20, 0x8000100u);
          if (CStringPtr)
          {
            id v25 = (char *)CStringPtr;
            uint64_t v26 = 0LL;
          }

          else
          {
            id v25 = (char *)calloc(0x400uLL, 1uLL);
            CFStringGetCString(v23, v25, 1024LL, 0x8000100u);
            uint64_t v26 = v25;
          }

          if (qword_1000E7D38) {
            __int16 v27 = (FILE *)qword_1000E7D38;
          }
          else {
            __int16 v27 = __stderrp;
          }
          fprintf(v27, "%s\n", v25);
          if (v26) {
            free(v26);
          }
          CFRelease(v23);
        }

        else
        {
          uint64_t v21 = (os_log_s *)sub_10002EFA0();
          if (os_log_type_enabled(v21, OS_LOG_TYPE_FAULT)) {
            sub_1000952B0();
          }
          if (qword_1000E7D38) {
            id v22 = (FILE *)qword_1000E7D38;
          }
          else {
            id v22 = __stderrp;
          }
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v22);
        }

        *__error() = v19;
      }

      [a2 UTF8String];
      sub_10002EE78( "LookaheadForIndentStyleAndHeavyMode_block_invoke",  "SPTextualReportParser.m",  1738,  "%s: frame match with no whitespace indent (%d: %s)",  v28,  v29,  v30,  v31,  (char)"whitespaceLength >= 0");
      abort();
    }

    uint64_t v12 = *(int **)(a1 + 48);
    int v13 = *v12;
    if (*v12 == -1)
    {
      *uint64_t v12 = v11;
    }

    else
    {
      BOOL v14 = __OFSUB__(v11, v13);
      int v15 = v11 - v13;
      if (!((v15 < 0) ^ v14 | (v15 == 0)))
      {
        **(_DWORD **)(a1 + 56) = v15;
        *a4 = 1;
      }
    }
  }

  return result;
}

  ;
}

uint64_t sub_10007FAB4@<X0>(uint64_t result@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  *(void *)(a2 + 4) = a3;
  *(_WORD *)(a2 + 12) = 2080;
  *(void *)(a2 + 14) = result;
  return result;
}

void sub_10007FAC8(uint64_t a1@<X8>)
{
  *(void *)(v1 - _Block_object_dispose(va, 8) = a1;
}

id sub_10007FADC@<X0>(void *a1@<X0>, uint64_t x8_0@<X8>)
{
  *(void *)(v3 - 24) = x8_0;
  return [a1 UTF8String];
}

  ;
}

void sub_10007FAFC(void *a1, int a2, os_log_t log, const char *a4, uint8_t *a5)
{
}

  ;
}

void sub_10007FB2C(void *a1, os_log_s *a2, uint64_t a3, const char *a4, uint8_t *a5)
{
}

  ;
}

uint64_t sub_10007FB54(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(void *)(a2 + 4) = v3;
  *(_WORD *)(a2 + 12) = 2080;
  *(void *)(a2 + 14) = a3;
  *(_WORD *)(a2 + 22) = 2080;
  *(void *)(a2 + 24) = result;
  return result;
}

id sub_10007FB70()
{
  return [v0 debugDescription];
}

id sub_10007FB7C(uint64_t a1, id *a2)
{
  return [*a2 uuid];
}

id sub_10007FB88()
{
  return [*v0 name];
}

void sub_10007FB94()
{
  dword_1000E7540 = 1064;
}

void sub_10007FBBC(uint64_t a1, os_log_s *a2)
{
  int v2 = 136315138;
  uint64_t v3 = a1;
  _os_log_fault_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_FAULT, "Unable to format: %s", (uint8_t *)&v2, 0xCu);
  sub_10002EE70();
}

void sub_10007FC2C(int a1, os_log_s *a2)
{
  v2[0] = 67109120;
  v2[1] = a1;
  _os_log_fault_impl( (void *)&_mh_execute_header,  a2,  OS_LOG_TYPE_FAULT,  "Unable to format: Found pid [%d]",  (uint8_t *)v2,  8u);
}

void sub_10007FCA0(int a1, os_log_s *a2)
{
  v2[0] = 67109120;
  v2[1] = a1;
  _os_log_debug_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_DEBUG, "Found pid [%d]", (uint8_t *)v2, 8u);
}

void sub_10007FD14()
{
}

void sub_10007FD88()
{
}

void sub_10007FDFC()
{
  uint64_t v0 = _os_assert_log(0LL);
  _os_crash(v0);
  __break(1u);
}

void sub_10007FE14( os_log_s *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10007FE84( os_log_s *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10007FEF4()
{
}

void sub_10007FF54()
{
}

void sub_10007FFB8()
{
}

void sub_100080018()
{
}

void sub_100080078()
{
}

void sub_1000800D8()
{
}

void sub_100080138()
{
}

void sub_100080198()
{
}

void sub_1000801F8()
{
}

void sub_100080258()
{
}

void sub_100080290()
{
}

void sub_1000802C8()
{
}

void sub_100080328()
{
}

void sub_100080388()
{
  sub_10003C428( (void *)&_mh_execute_header,  v0,  v1,  "Unable to format: WR: %@: DRShouldGatherLog return false, not submitting tailspin",  v2,  v3,  v4,  v5,  v6);
  sub_10002EE70();
}

void sub_1000803E8()
{
  sub_10003C4D4( (void *)&_mh_execute_header,  v0,  v1,  "WR: %@: DRShouldGatherLog return false, not submitting tailspin",  v2,  v3,  v4,  v5,  v6);
  sub_10002EE70();
}

void sub_100080448()
{
}

void sub_100080480()
{
}

void sub_1000804B8()
{
}

void sub_100080518(uint64_t a1, uint64_t a2, os_log_s *a3)
{
  *(_DWORD *)a1 = 134217984;
  *(void *)(a1 + 4) = a2;
  sub_10003C438( (void *)&_mh_execute_header,  a3,  (uint64_t)a3,  "Unable to format: WR: have %lu reports, but no sampleStore",  (uint8_t *)a1);
}

void sub_100080554(uint64_t a1, uint64_t a2, os_log_s *a3)
{
  *(_DWORD *)a1 = 134217984;
  *(void *)(a1 + 4) = a2;
  sub_10003C438((void *)&_mh_execute_header, a3, (uint64_t)a3, "WR: have %lu reports, but no sampleStore", (uint8_t *)a1);
}

void sub_100080590()
{
}

void sub_1000805C8()
{
  *(_DWORD *)uint64_t v0 = 138412546;
  *(void *)(v0 + 4) = v1;
  *(_WORD *)(v0 + 12) = 2114;
  *(void *)(v0 + 14) = v2;
  sub_10003C4A4( (void *)&_mh_execute_header,  v4,  v0,  "WR: %@: Unable to compare timesamps with tailspin data (%{public}@)",  v3);
}

void sub_100080610(uint8_t *buf, _BYTE *a2, os_log_t log)
{
  *buf = 0;
  *a2 = 0;
  _os_log_fault_impl( (void *)&_mh_execute_header,  log,  OS_LOG_TYPE_FAULT,  "Unable to format: Sample store contains no samples for the signpost interval, not generating spindump report",  buf,  2u);
}

void sub_10008064C(uint8_t *buf, _BYTE *a2, os_log_t log)
{
  *buf = 0;
  *a2 = 0;
  _os_log_error_impl( (void *)&_mh_execute_header,  log,  OS_LOG_TYPE_ERROR,  "Sample store contains no samples for the signpost interval, not generating spindump report",  buf,  2u);
}

void sub_100080688()
{
  *(void *)(v3 + 20) = "sampleStore.targetDispatchQueueId == report.dispatchQueue.identifier";
  sub_10003C508( (void *)&_mh_execute_header,  "Unable to format: %s [%d]: %s: Unable to set target dispatch queue",  v4,  v5);
}

void sub_1000806C8()
{
  *(void *)(v3 + 20) = "sampleStore.targetDispatchQueueId == report.dispatchQueue.identifier";
  sub_10003C518((void *)&_mh_execute_header, "%s [%d]: %s: Unable to set target dispatch queue", v4, v5);
}

void sub_100080708( os_log_s *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100080778( os_log_s *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_1000807E8()
{
  *(void *)(v3 + 20) = "sampleStore.targetDispatchQueueId == report.dispatchQueue.identifier";
  sub_10003C508((void *)&_mh_execute_header, "Unable to format: %s [%d]: %s: Unable to set target thread", v4, v5);
}

void sub_100080828()
{
  *(void *)(v3 + 20) = "sampleStore.targetDispatchQueueId == report.dispatchQueue.identifier";
  sub_10003C518((void *)&_mh_execute_header, "%s [%d]: %s: Unable to set target thread", v4, v5);
}

void sub_100080868( os_log_s *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_1000808D8( os_log_s *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100080948()
{
  *(_DWORD *)uint64_t v0 = 138412546;
  *(void *)(v0 + 4) = v1;
  *(_WORD *)(v0 + 12) = 2048;
  *(void *)(v0 + 14) = v2;
  sub_10003C48C((void *)&_mh_execute_header, v4, v2, "Unable to format: WR: %@: generating %lu spindump reports", v3);
}

void sub_100080990()
{
}

void sub_1000809F0()
{
}

void sub_100080A50()
{
}

void sub_100080AB8()
{
}

void sub_100080B20()
{
}

void sub_100080B84()
{
}

void sub_100080BE8()
{
  __int16 v3 = 2080;
  uint64_t v4 = v0;
  sub_10003C48C((void *)&_mh_execute_header, v1, (uint64_t)v1, "Unable to format: WR: %@: Received tailspin path %s", v2);
  sub_10002EE70();
}

void sub_100080C60( os_log_s *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100080CD0( os_log_s *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100080D40()
{
}

void sub_100080DAC()
{
}

void sub_100080E18()
{
}

void sub_100080E78()
{
}

void sub_100080ED8()
{
}

void sub_100080F44()
{
}

void sub_100080FB0()
{
}

void sub_100081010()
{
}

void sub_100081070()
{
}

void sub_1000810D0()
{
}

void sub_100081130()
{
}

void sub_1000811A8()
{
}

void sub_100081220( os_log_s *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100081290( os_log_s *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100081300()
{
}

void sub_100081378()
{
}

void sub_1000813F0( os_log_s *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100081460( os_log_s *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_1000814D0()
{
  uint64_t v2 = __error();
  sub_100046448(v2);
  sub_1000464EC();
  _os_log_fault_impl( (void *)&_mh_execute_header,  v0,  OS_LOG_TYPE_FAULT,  "Unable to format: %s [%d]: generate spindump: unable to sample process: %d (%s)",  v3,  0x22u);
  sub_1000461CC();
}

void sub_100081560()
{
  uint64_t v2 = __error();
  sub_100046448(v2);
  sub_1000464EC();
  _os_log_error_impl( (void *)&_mh_execute_header,  v0,  OS_LOG_TYPE_ERROR,  "%{public}s [%d]: generate spindump: unable to sample process: %d (%s)",  v3,  0x22u);
  sub_1000461CC();
}

void sub_1000815F0()
{
  int v0 = sub_100046614();
  sub_100046448(v0);
  sub_100046490();
  sub_1000462D4( (void *)&_mh_execute_header,  v1,  v2,  "Unable to format: generate spindump: unable to sample process: %d (%s)",  v3,  v4,  v5,  v6,  v7);
  sub_1000462C8();
}

void sub_100081660()
{
  int v0 = sub_100046614();
  sub_100046448(v0);
  sub_100046490();
  sub_100046590( (void *)&_mh_execute_header,  v1,  v2,  "generate spindump: unable to sample process: %d (%s)",  v3,  v4,  v5,  v6,  v7);
  sub_1000462C8();
}

void sub_1000816D0()
{
}

void sub_10008173C()
{
}

void sub_1000817A8()
{
}

void sub_100081808()
{
}

void sub_100081868()
{
}

void sub_1000818D4()
{
}

void sub_100081940()
{
}

void sub_1000819A0()
{
}

#error "100081A50: call analysis failed (funcsize=28)"
#error "100081AC8: call analysis failed (funcsize=28)"
void sub_100081AF0()
{
  int *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;
  sub_100046534();
  int v0 = sub_1000465F4();
  sub_100046448(v0);
  sub_1000463B8();
  sub_100046210( (void *)&_mh_execute_header,  v1,  v2,  "Unable to format: generate spindump: unable to open %s for writing: %d (%s)",  v3,  v4,  v5,  v6,  v7);
  sub_1000461CC();
}

void sub_100081B64()
{
  int v0 = sub_1000465F4();
  sub_100046448(v0);
  sub_1000463B8();
  sub_100046464( (void *)&_mh_execute_header,  v1,  v2,  "generate spindump: unable to open %s for writing: %d (%s)",  v3,  v4,  v5,  v6,  v7);
  sub_1000461CC();
}

#error "100081C28: call analysis failed (funcsize=28)"
#error "100081CA0: call analysis failed (funcsize=28)"
void sub_100081CC8()
{
  int *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;
  sub_100046534();
  int v0 = sub_1000465F4();
  sub_100046448(v0);
  sub_1000463B8();
  sub_100046210( (void *)&_mh_execute_header,  v1,  v2,  "Unable to format: generate spindump: unable to fdopen %s for writing: %d (%s)",  v3,  v4,  v5,  v6,  v7);
  sub_1000461CC();
}

void sub_100081D3C()
{
  int v0 = sub_1000465F4();
  sub_100046448(v0);
  sub_1000463B8();
  sub_100046464( (void *)&_mh_execute_header,  v1,  v2,  "generate spindump: unable to fdopen %s for writing: %d (%s)",  v3,  v4,  v5,  v6,  v7);
  sub_1000461CC();
}

void sub_100081DB0()
{
}

void sub_100081E40(int *a1)
{
}

void sub_100081ED8(int *a1)
{
}

void sub_100081F60(unsigned __int8 a1, os_log_s *a2)
{
}

void sub_100081FD8(unsigned __int8 a1, os_log_s *a2)
{
}

void sub_100082050()
{
}

void sub_1000820BC()
{
}

#error "10008218C: call analysis failed (funcsize=33)"
#error "100082218: call analysis failed (funcsize=33)"
void sub_100082240()
{
  os_log_s *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;
  sub_10003C498();
  sub_10003C428( (void *)&_mh_execute_header,  v0,  v1,  "Unable to format: cpu resource: done reporting (%#llx)",  v2,  v3,  v4,  v5,  v6);
  sub_10002EE70();
}

void sub_1000822A0()
{
}

void sub_100082300()
{
}

void sub_100082384()
{
}

#error "10008246C: call analysis failed (funcsize=33)"
void sub_100082494()
{
  void *v0;
  const char *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint8_t v8;
  sub_10004635C();
  objc_msgSend(sub_1000464E4(v0, v1), "num_out_of_order");
  objc_msgSend(sub_100046340(), "num_missing_load_info");
  sub_1000463F4();
  sub_100046294();
  sub_1000463A4( (void *)&_mh_execute_header,  v2,  v3,  "Unable to format: cpu resource: some microstackshots with errors: %llu out-of-order microstackshots, %llu microstack shots missing load infos, %llu bytes invalid",  v4,  v5,  v6,  v7,  v8);
  sub_1000461CC();
}

#error "10008257C: call analysis failed (funcsize=33)"
#error "100082608: call analysis failed (funcsize=33)"
void sub_100082630()
{
  void *v0;
  const char *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint8_t v8;
  sub_10004635C();
  objc_msgSend(sub_1000464E4(v0, v1), "num_out_of_order");
  objc_msgSend(sub_100046340(), "num_missing_load_info");
  sub_1000463F4();
  sub_100046294();
  sub_1000463A4( (void *)&_mh_execute_header,  v2,  v3,  "Unable to format: cpu resource: no microstackshots: %llu out-of-order microstackshots, %llu microstackshots missing load infos, %llu bytes invalid",  v4,  v5,  v6,  v7,  v8);
  sub_1000461CC();
}

void sub_1000826B4()
{
}

void sub_100082738()
{
}

void sub_1000827A0()
{
}

void sub_1000827CC()
{
}

void sub_100082834()
{
}

void sub_10008289C()
{
}

void sub_1000828C8()
{
}

void sub_1000828F4()
{
}

void sub_100082960()
{
}

void sub_1000829C0()
{
}

void sub_100082A28()
{
}

void sub_100082A90()
{
}

void sub_100082ABC()
{
}

void sub_100082AE8()
{
}

void sub_100082B50()
{
}

void sub_100082BB8()
{
}

void sub_100082BE4()
{
}

void sub_100082C10()
{
}

void sub_100082C7C()
{
}

void sub_100082CE8()
{
}

void sub_100082D48()
{
}

void sub_100082DA8()
{
}

void sub_100082E14()
{
}

void sub_100082E80()
{
}

void sub_100082EE0()
{
}

void sub_100082F40()
{
}

void sub_100082FAC()
{
}

void sub_100083024()
{
}

void sub_100083084()
{
}

void sub_1000830E4()
{
}

void sub_10008314C()
{
}

void sub_1000831B0()
{
}

void sub_100083218()
{
}

void sub_10008327C()
{
}

void sub_1000832E8()
{
}

#error "1000833B8: call analysis failed (funcsize=33)"
#error "100083444: call analysis failed (funcsize=33)"
void sub_10008346C()
{
  os_log_s *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;
  sub_10003C498();
  sub_10003C428( (void *)&_mh_execute_header,  v0,  v1,  "Unable to format: disk writes: done reporting (%#llx)",  v2,  v3,  v4,  v5,  v6);
  sub_10002EE70();
}

void sub_1000834CC()
{
}

void sub_10008352C()
{
}

void sub_1000835B0()
{
}

#error "100083698: call analysis failed (funcsize=33)"
void sub_1000836C0()
{
  void *v0;
  const char *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint8_t v8;
  sub_10004635C();
  objc_msgSend(sub_1000464E4(v0, v1), "num_out_of_order");
  objc_msgSend(sub_100046340(), "num_missing_load_info");
  sub_1000463F4();
  sub_100046294();
  sub_1000463A4( (void *)&_mh_execute_header,  v2,  v3,  "Unable to format: disk writes: some microstackshots with errors: %llu out-of-order microstackshots, %llu microstacks hots missing load infos, %llu bytes invalid",  v4,  v5,  v6,  v7,  v8);
  sub_1000461CC();
}

#error "1000837A8: call analysis failed (funcsize=33)"
#error "100083834: call analysis failed (funcsize=33)"
void sub_10008385C()
{
  void *v0;
  const char *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint8_t v8;
  sub_10004635C();
  objc_msgSend(sub_1000464E4(v0, v1), "num_out_of_order");
  objc_msgSend(sub_100046340(), "num_missing_load_info");
  sub_1000463F4();
  sub_100046294();
  sub_1000463A4( (void *)&_mh_execute_header,  v2,  v3,  "Unable to format: disk writes: no microstackshots: %llu out-of-order microstackshots, %llu microstackshots missing l oad infos, %llu bytes invalid",  v4,  v5,  v6,  v7,  v8);
  sub_1000461CC();
}

void sub_1000838E0()
{
}

void sub_100083964()
{
}

void sub_1000839D0()
{
}

void sub_100083A30()
{
}

void sub_100083A98()
{
}

void sub_100083B00()
{
}

void sub_100083B2C()
{
}

void sub_100083B58()
{
}

void sub_100083BC0()
{
}

void sub_100083BEC()
{
}

void sub_100083C54()
{
}

void sub_100083CBC()
{
}

void sub_100083CE8()
{
}

void sub_100083D14()
{
}

void sub_100083D7C()
{
}

void sub_100083DE4()
{
}

void sub_100083E10()
{
}

void sub_100083E3C()
{
}

void sub_100083EA8()
{
}

void sub_100083F08()
{
}

void sub_100083F70()
{
}

void sub_100083FD8()
{
}

void sub_100084004()
{
}

void sub_100084030()
{
}

void sub_100084090()
{
}

void sub_1000840F0()
{
}

void sub_10008415C()
{
}

void sub_1000841BC()
{
}

void sub_100084224()
{
}

void sub_10008428C()
{
}

void sub_1000842B8()
{
}

void sub_1000842E4()
{
}

void sub_100084344()
{
}

void sub_1000843A4()
{
}

void sub_100084410()
{
}

void sub_100084470()
{
}

void sub_1000844D8()
{
}

void sub_100084540()
{
}

void sub_10008456C()
{
}

void sub_100084598()
{
}

void sub_1000845F8()
{
}

void sub_100084658()
{
}

void sub_1000846B8()
{
}

void sub_100084718()
{
}

void sub_100084778()
{
}

void sub_1000847D8()
{
}

void sub_100084838()
{
}

void sub_100084898()
{
  uint64_t v0 = sub_100046614();
  sub_100046448(v0);
  sub_100046490();
  sub_1000462D4( (void *)&_mh_execute_header,  v1,  v2,  "Unable to format: read from child returned error: %d (%s)",  v3,  v4,  v5,  v6,  v7);
  sub_1000462C8();
}

void sub_100084908()
{
  uint64_t v0 = sub_100046614();
  sub_100046448(v0);
  sub_100046490();
  sub_100046590((void *)&_mh_execute_header, v1, v2, "read from child returned error: %d (%s)", v3, v4, v5, v6, v7);
  sub_1000462C8();
}

void sub_100084978( os_log_s *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_1000849E8( os_log_s *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100084A58( os_log_s *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100084AC8( os_log_s *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100084B38()
{
}

void sub_100084BA8()
{
  v3[0] = 67109632;
  v3[1] = v1;
  __int16 v4 = 1024;
  int v5 = (v0 >> 11) & 1;
  __int16 v6 = 1024;
  int v7 = ((unsigned __int16)word_1000E7D70 >> 12) & 1;
  sub_100047CC4( (void *)&_mh_execute_header,  v2,  (uint64_t)v2,  "Unable to format: UID %d: Gather samples for service watchdog:%d due to submit:%d",  (uint8_t *)v3);
  sub_10002EE70();
}

void sub_100084C38()
{
}

void sub_100084CB4()
{
  LOWORD(sub_10003C428((void *)&_mh_execute_header, v0, v1, "Spindump output file doesn't exist: %s", v2, v3, v4, v5, v6) = 1024;
  HIWORD(sub_10003C428((void *)&_mh_execute_header, v0, v1, "Spindump output file doesn't exist: %s", v2, v3, v4, v5, v6) = v2;
  LOWORD(sub_1000462E8( (void *)&_mh_execute_header,  v1,  v2,  "%{public}s [%d]: kqworkloop exhaustion: not monitoring due to suppression cookie file",  v3,  v4,  v5,  v6, v7) = ((v1 >> 6) & 1) >> 16;
  sub_100047C28( (void *)&_mh_execute_header,  v3,  v4,  "Unable to format: UID %d: Gather samples for spins:%d due to submit:%d user requested:%d",  v5,  v6,  (v0 >> 5) & 1,  v7);
  sub_100047C74();
}

void sub_100084D40()
{
}

void sub_100084DBC()
{
}

void sub_100084E24()
{
}

void sub_100084E94()
{
}

void sub_100084F04()
{
}

void sub_100084F64()
{
}

void sub_100084FC4()
{
  v1[0] = 136315394;
  sub_100047D5C();
  _os_log_fault_impl( (void *)&_mh_execute_header,  v0,  OS_LOG_TYPE_FAULT,  "Unable to format: %s: Getting prefs for user %d as command-line",  (uint8_t *)v1,  0x12u);
  sub_10002EE70();
}

void sub_10008503C()
{
  v1[0] = 136315394;
  sub_100047D5C();
  _os_log_error_impl( (void *)&_mh_execute_header,  v0,  OS_LOG_TYPE_ERROR,  "%s: Getting prefs for user %d as command-line",  (uint8_t *)v1,  0x12u);
  sub_10002EE70();
}

void sub_1000850B4()
{
}

void sub_10008511C()
{
}

void sub_100085184()
{
}

void sub_1000851EC()
{
}

void sub_100085268()
{
}

void sub_1000852F0()
{
}

void sub_100085354()
{
}

void sub_1000853B8()
{
  int v6 = v0;
  sub_100047D48();
  int v7 = v1;
  __int16 v8 = v2;
  int v9 = v3;
  _os_log_fault_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_FAULT,  "Unable to format: Submit systemstats:%d sleep/wake failure:%d watchdog:%d due to suppression:%d",  v5,  0x1Au);
  sub_100047C74();
}

void sub_10008544C()
{
  v3[0] = 67109632;
  v3[1] = ((unsigned __int16)word_1000E7D70 >> 7) & 1;
  sub_100047D48();
  v3[4] = v0;
  sub_100047CC4( (void *)&_mh_execute_header,  v1,  v2,  "Unable to format: Submit resource reports cpu:%d io:%d due to suppression:%d",  (uint8_t *)v3);
  sub_10002EE70();
}

void sub_1000854D4()
{
}

void sub_100085538()
{
}

void sub_1000855A8()
{
}

void sub_100085614( os_log_s *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100085644( os_log_s *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100085674()
{
}

void sub_1000856D4()
{
}

void sub_100085734()
{
}

void sub_100085794()
{
}

void sub_1000857F4()
{
}

void sub_100085854()
{
}

void sub_1000858B4()
{
}

void sub_100085914()
{
}

void sub_100085974()
{
}

void sub_1000859D4()
{
}

void sub_100085A34()
{
}

void sub_100085A94()
{
}

void sub_100085AF4()
{
}

void sub_100085B54()
{
}

void sub_100085BB4( os_log_s *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100085BE4()
{
}

void sub_100085C4C()
{
}

void sub_100085CB8()
{
}

void sub_100085D24()
{
  __int16 v3 = 2114;
  uint64_t v4 = v0;
  _os_log_error_impl( (void *)&_mh_execute_header,  v1,  OS_LOG_TYPE_ERROR,  "Tasking setting for %{public}@: %{public}@ isn't a number",  v2,  0x16u);
  sub_10002EE70();
}

void sub_100085DA0(int a1, os_log_s *a2)
{
  __int16 v3 = __error();
  sub_100046448(v3);
  sub_1000464EC();
  _os_log_fault_impl( (void *)&_mh_execute_header,  a2,  OS_LOG_TYPE_FAULT,  "Unable to format: %s [%d]: Unable to get uid: %d (%s)",  v4,  0x22u);
  sub_1000461CC();
}

void sub_100085E38(int a1, os_log_s *a2)
{
  __int16 v3 = __error();
  sub_100046448(v3);
  sub_1000464EC();
  _os_log_error_impl( (void *)&_mh_execute_header,  a2,  OS_LOG_TYPE_ERROR,  "%{public}s [%d]: Unable to get uid: %d (%s)",  v4,  0x22u);
  sub_1000461CC();
}

void sub_100085ED0(os_log_s *a1)
{
  uint64_t v2 = __error();
  sub_100046448(v2);
  sub_100046490();
  _os_log_fault_impl( (void *)&_mh_execute_header,  a1,  OS_LOG_TYPE_FAULT,  "Unable to format: Unable to get uid: %d (%s)",  v3,  0x12u);
  sub_1000462C8();
}

void sub_100085F58(os_log_s *a1)
{
  uint64_t v2 = __error();
  sub_100046448(v2);
  sub_100046490();
  _os_log_error_impl((void *)&_mh_execute_header, a1, OS_LOG_TYPE_ERROR, "Unable to get uid: %d (%s)", v3, 0x12u);
  sub_1000462C8();
}

void sub_100085FE0( os_log_s *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100086050( os_log_s *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_1000860C0(void *a1, const char *a2, os_log_s *a3)
{
}

void sub_100086134(void *a1)
{
}

void sub_1000861AC(void *a1, const char *a2, os_log_s *a3)
{
}

void sub_100086220(void *a1)
{
}

void sub_100086298(int a1)
{
}

void sub_100086310(int a1)
{
}

void sub_100086388()
{
}

void sub_1000863E8()
{
}

void sub_100086448( os_log_s *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_1000864B8( os_log_s *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100086528( os_log_s *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100086598( os_log_s *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100086608(int a1, os_log_s *a2)
{
}

void sub_100086688(int a1, os_log_s *a2)
{
}

void sub_100086708()
{
}

void sub_100086734()
{
}

void sub_100086760()
{
}

void sub_10008678C()
{
}

void sub_1000867B8()
{
}

void sub_1000867E4()
{
}

void sub_100086810()
{
}

void sub_10008683C()
{
}

void sub_100086868()
{
}

void sub_100086894()
{
}

void sub_1000868C0()
{
}

void sub_1000868EC()
{
}

void sub_100086918()
{
}

void sub_10008697C()
{
}

void sub_1000869E0()
{
}

void sub_100086A0C()
{
}

void sub_100086A38()
{
}

void sub_100086A9C()
{
}

void sub_100086B00()
{
}

void sub_100086B64()
{
}

void sub_100086BC8()
{
}

void sub_100086C2C()
{
}

void sub_100086C90()
{
}

void sub_100086CBC()
{
}

void sub_100086CE8()
{
}

void sub_100086D14()
{
}

void sub_100086D40()
{
}

void sub_100086D6C()
{
}

void sub_100086D98()
{
}

void sub_100086DC4()
{
}

void sub_100086DF0()
{
}

void sub_100086E1C()
{
}

void sub_100086E48()
{
}

void sub_100086EAC()
{
}

void sub_100086F10()
{
}

void sub_100086F74()
{
}

void sub_100086FD8()
{
}

void sub_100087004()
{
}

void sub_100087030()
{
}

void sub_10008705C()
{
}

void sub_100087088()
{
}

void sub_1000870B4()
{
}

void sub_1000870E0()
{
}

void sub_10008710C()
{
}

void sub_100087138()
{
}

void sub_100087164()
{
}

void sub_100087190()
{
}

void sub_1000871BC()
{
}

void sub_1000871E8()
{
}

void sub_100087214()
{
}

void sub_100087240( os_log_s *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10003C428( (void *)&_mh_execute_header,  a1,  a3,  "Unable to format: %s: _HandleMicrostackshots returned a SASampleStore when saving to a file",  a5,  a6,  a7,  a8,  2u);
  sub_10002EE70();
}

void sub_1000872B0( os_log_s *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10003C444( (void *)&_mh_execute_header,  a1,  a3,  "%s: _HandleMicrostackshots returned a SASampleStore when saving to a file",  a5,  a6,  a7,  a8,  2u);
  sub_10002EE70();
}

void sub_100087320()
{
  uint64_t v0 = __error();
  strerror(*v0);
  sub_1000463B8();
  sub_100046210((void *)&_mh_execute_header, v1, v2, "Unable to format: Unable to open %s: %d (%s)", v3, v4, v5, v6, v7);
  sub_1000461CC();
}

void sub_1000873A4()
{
  uint64_t v0 = sub_1000465F4();
  sub_100046448(v0);
  sub_1000463B8();
  sub_100046464((void *)&_mh_execute_header, v1, v2, "Unable to open %s: %d (%s)", v3, v4, v5, v6, v7);
  sub_1000461CC();
}

void sub_100087418()
{
  uint64_t v0 = __error();
  strerror(*v0);
  sub_1000463B8();
  sub_100046210( (void *)&_mh_execute_header,  v1,  v2,  "Unable to format: Unable to gzdopen datastore file %s: %d (%s)",  v3,  v4,  v5,  v6,  v7);
  sub_1000461CC();
}

void sub_10008749C()
{
  uint64_t v0 = sub_1000465F4();
  sub_100046448(v0);
  sub_1000463B8();
  sub_100046464((void *)&_mh_execute_header, v1, v2, "Unable to gzdopen datastore file %s: %d (%s)", v3, v4, v5, v6, v7);
  sub_1000461CC();
}

void sub_100087510()
{
}

void sub_10008753C()
{
  uint64_t v0 = __error();
  strerror(*v0);
  sub_10004AEB4();
  sub_10004AF5C( (void *)&_mh_execute_header,  v1,  v2,  "Unable to format: Unable to seek %s to offset %lld: %d (%s)",  v3,  v4,  v5,  v6,  v7);
  sub_1000461CC();
}

void sub_1000875C0()
{
  uint64_t v0 = __error();
  sub_100046448(v0);
  sub_10004AEB4();
  sub_10004AF84((void *)&_mh_execute_header, v1, v2, "Unable to seek %s to offset %lld: %d (%s)", v3, v4, v5, v6, v7);
  sub_1000461CC();
}

void sub_100087638(uint64_t a1, uint64_t a2, int a3)
{
}

void sub_100087674(uint64_t a1, uint64_t a2, int a3)
{
}

void sub_1000876B0()
{
  uint64_t v0 = __error();
  strerror(*v0);
  sub_10004AEB4();
  sub_10004AF5C( (void *)&_mh_execute_header,  v1,  v2,  "Unable to format: Unable to seek %s to offset %lld: %d (%s)",  v3,  v4,  v5,  v6,  v7);
  sub_1000461CC();
}

void sub_100087734()
{
  uint64_t v0 = __error();
  strerror(*v0);
  sub_10004AEB4();
  sub_10004AF84((void *)&_mh_execute_header, v1, v2, "Unable to seek %s to offset %lld: %d (%s)", v3, v4, v5, v6, v7);
  sub_1000461CC();
}

void sub_1000877B8()
{
  uint64_t v0 = __error();
  strerror(*v0);
  sub_1000463B8();
  sub_100046210( (void *)&_mh_execute_header,  v1,  v2,  "Unable to format: Unable to open datastore file %s: %d (%s)",  v3,  v4,  v5,  v6,  v7);
  sub_1000461CC();
}

void sub_10008783C()
{
  uint64_t v0 = sub_1000465F4();
  sub_100046448(v0);
  sub_1000463B8();
  sub_100046464((void *)&_mh_execute_header, v1, v2, "Unable to open datastore file %s: %d (%s)", v3, v4, v5, v6, v7);
  sub_1000461CC();
}

void sub_1000878B0( os_log_s *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10003C428( (void *)&_mh_execute_header,  a1,  a3,  "Unable to format: %s: Didn't already return without report option",  a5,  a6,  a7,  a8,  2u);
  sub_10002EE70();
}

void sub_100087920( os_log_s *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10003C444( (void *)&_mh_execute_header,  a1,  a3,  "%s: Didn't already return without report option",  a5,  a6,  a7,  a8,  2u);
  sub_10002EE70();
}

void sub_100087990( os_log_s *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100087A00( os_log_s *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100087A70( os_log_s *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100087AE0( os_log_s *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100087B50(void *a1, uint64_t a2, os_log_s *a3)
{
  v4[0] = 136315650;
  sub_10004AF98();
  _os_log_fault_impl( (void *)&_mh_execute_header,  a3,  OS_LOG_TYPE_FAULT,  "Unable to format: %s: report_type %d, but systemstatsFormat %d",  (uint8_t *)v4,  0x18u);
  sub_1000462C8();
}

void sub_100087BDC(void *a1, uint64_t a2, os_log_s *a3)
{
  v4[0] = 136315650;
  sub_10004AF98();
  _os_log_error_impl( (void *)&_mh_execute_header,  a3,  OS_LOG_TYPE_ERROR,  "%s: report_type %d, but systemstatsFormat %d",  (uint8_t *)v4,  0x18u);
  sub_1000462C8();
}

void sub_100087C68(int a1, os_log_s *a2)
{
}

void sub_100087CE0(int a1, os_log_s *a2)
{
}

void sub_100087D58()
{
}

void sub_100087D84()
{
}

void sub_100087DB0(void *a1, os_log_s *a2)
{
}

void sub_100087E2C(void *a1, os_log_s *a2)
{
}

#error "100087EF8: call analysis failed (funcsize=28)"
#error "100087F70: call analysis failed (funcsize=28)"
void sub_100087F98()
{
  int *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;
  sub_100046534();
  uint64_t v0 = sub_1000465F4();
  sub_100046448(v0);
  sub_1000463B8();
  sub_100046210( (void *)&_mh_execute_header,  v1,  v2,  "Unable to format: could not open log file %@: %d (%s)",  v3,  v4,  v5,  v6,  v7);
  sub_1000461CC();
}

void sub_10008800C()
{
  uint64_t v0 = sub_1000465F4();
  sub_100046448(v0);
  sub_1000463B8();
  sub_100046464((void *)&_mh_execute_header, v1, v2, "could not open log file %@: %d (%s)", v3, v4, v5, v6, v7);
  sub_1000461CC();
}

void sub_100088080( uint64_t a1, os_log_s *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

#error "100088138: call analysis failed (funcsize=28)"
#error "1000881B0: call analysis failed (funcsize=28)"
void sub_1000881D8()
{
  int *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;
  sub_100046534();
  uint64_t v0 = sub_1000465F4();
  sub_100046448(v0);
  sub_1000463B8();
  sub_100046210( (void *)&_mh_execute_header,  v1,  v2,  "Unable to format: could not write to file %@: %d (%s)",  v3,  v4,  v5,  v6,  v7);
  sub_1000461CC();
}

void sub_10008824C()
{
  uint64_t v0 = sub_1000465F4();
  sub_100046448(v0);
  sub_1000463B8();
  sub_100046464((void *)&_mh_execute_header, v1, v2, "could not write to file %@: %d (%s)", v3, v4, v5, v6, v7);
  sub_1000461CC();
}

#error "100088310: call analysis failed (funcsize=28)"
#error "100088388: call analysis failed (funcsize=28)"
void sub_1000883B0()
{
  int *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;
  sub_100046534();
  uint64_t v0 = sub_1000465F4();
  sub_100046448(v0);
  sub_1000463B8();
  sub_100046210( (void *)&_mh_execute_header,  v1,  v2,  "Unable to format: could not fdopen log file %@: %d (%s)",  v3,  v4,  v5,  v6,  v7);
  sub_1000461CC();
}

void sub_100088424()
{
  uint64_t v0 = sub_1000465F4();
  sub_100046448(v0);
  sub_1000463B8();
  sub_100046464((void *)&_mh_execute_header, v1, v2, "could not fdopen log file %@: %d (%s)", v3, v4, v5, v6, v7);
  sub_1000461CC();
}

void sub_100088498()
{
}

void sub_100088510()
{
}

void sub_100088588()
{
  v2[0] = 136315394;
  sub_100047D5C();
  sub_10004AF1C((void *)&_mh_execute_header, v0, v1, "Unable to format: %s: Bad report type %d", (uint8_t *)v2);
  sub_10002EE70();
}

void sub_1000885F8()
{
  v2[0] = 136315394;
  sub_100047D5C();
  sub_10004AF10((void *)&_mh_execute_header, v0, v1, "%s: Bad report type %d", (uint8_t *)v2);
  sub_10002EE70();
}

void sub_100088668()
{
}

void sub_100088694()
{
}

void sub_1000886C0(uint64_t a1, id *a2, os_log_s *a3)
{
  int v6 = 136315394;
  uint64_t v7 = a1;
  sub_10004AF28();
  sub_10003C48C( (void *)&_mh_execute_header,  a3,  v5,  "Unable to format: reading in data file %s failed: %@",  (uint8_t *)&v6);
  sub_1000462C8();
}

void sub_10008873C(uint64_t a1, id *a2, os_log_s *a3)
{
  int v6 = 136315394;
  uint64_t v7 = a1;
  sub_10004AF28();
  sub_10003C4A4((void *)&_mh_execute_header, a3, v5, "reading in data file %s failed: %@", (uint8_t *)&v6);
  sub_1000462C8();
}

void sub_1000887B8()
{
}

void sub_100088818()
{
}

void sub_100088884(void *a1, os_log_s *a2, double a3)
{
  int v6 = 134218242;
  double v7 = a3;
  sub_10004AF28();
  sub_10003C48C( (void *)&_mh_execute_header,  a2,  v5,  "Unable to format: -last provided, but unable to calculate %.0f seconds earlier than %@",  (uint8_t *)&v6);
  sub_10004AFD8();
}

void sub_100088908(void *a1, os_log_s *a2, double a3)
{
  int v6 = 134218242;
  double v7 = a3;
  sub_10004AF28();
  sub_10003C4A4( (void *)&_mh_execute_header,  a2,  v5,  "-last provided, but unable to calculate %.0f seconds earlier than %@",  (uint8_t *)&v6);
  sub_10004AFD8();
}

void sub_10008898C()
{
}

void sub_100088A04()
{
}

void sub_100088A7C()
{
  v2[0] = 136315394;
  sub_100047D5C();
  sub_10004AF1C( (void *)&_mh_execute_header,  v0,  v1,  "Unable to format: %s: Bad report type for microstackshots %d",  (uint8_t *)v2);
  sub_10002EE70();
}

void sub_100088AEC()
{
  v2[0] = 136315394;
  sub_100047D5C();
  sub_10004AF10((void *)&_mh_execute_header, v0, v1, "%s: Bad report type for microstackshots %d", (uint8_t *)v2);
  sub_10002EE70();
}

void sub_100088B5C( os_log_s *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100088BCC( os_log_s *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100088C3C()
{
}

void sub_100088C68()
{
}

void sub_100088C94(int *a1, os_log_s *a2)
{
}

void sub_100088D04(int *a1, os_log_s *a2)
{
}

void sub_100088D74(int *a1, uint64_t a2, os_log_s *a3)
{
  int v3 = *a1;
  v4[0] = 67109378;
  v4[1] = v3;
  __int16 v5 = 2080;
  uint64_t v6 = a2;
  sub_10004AF1C( (void *)&_mh_execute_header,  a3,  (uint64_t)a3,  "Unable to format: Read failed for microstackshots: %d (%s)",  (uint8_t *)v4);
  sub_10002EE70();
}

void sub_100088DF0(int *a1, uint64_t a2, os_log_s *a3)
{
  int v3 = *a1;
  v4[0] = 67109378;
  v4[1] = v3;
  __int16 v5 = 2082;
  uint64_t v6 = a2;
  sub_10004AF10( (void *)&_mh_execute_header,  a3,  (uint64_t)a3,  "Read failed for microstackshots: %d (%{public}s)",  (uint8_t *)v4);
  sub_10002EE70();
}

void sub_100088E6C()
{
  v1[0] = 136315650;
  sub_10004AFB4();
  _os_log_fault_impl( (void *)&_mh_execute_header,  v0,  OS_LOG_TYPE_FAULT,  "Unable to format: %s: buf %lu, cap %lu",  (uint8_t *)v1,  0x20u);
}

void sub_100088EEC()
{
  v1[0] = 136315650;
  sub_10004AFB4();
  _os_log_error_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_ERROR, "%s: buf %lu, cap %lu", (uint8_t *)v1, 0x20u);
}

void sub_100088F6C()
{
  v2[0] = 136315394;
  sub_10004B02C();
  sub_10003C48C((void *)&_mh_execute_header, v0, v1, "Unable to format: %s: realloc to %lu failed", (uint8_t *)v2);
  sub_10002EE70();
}

void sub_100088FDC()
{
  v2[0] = 136315394;
  sub_10004B02C();
  sub_10003C4A4((void *)&_mh_execute_header, v0, v1, "%s: realloc to %lu failed", (uint8_t *)v2);
  sub_10002EE70();
}

void sub_10008904C()
{
}

void sub_100089078()
{
}

void sub_1000890A4()
{
}

void sub_100089108()
{
}

void sub_100089178()
{
}

void sub_1000891DC(int a1, os_log_s *a2, uint64_t a3)
{
  v3[0] = 67109120;
  v3[1] = a1;
  sub_10004CD68( (void *)&_mh_execute_header,  a2,  a3,  "Unable to format: SaveReport: Unsupported status %d",  (uint8_t *)v3);
  sub_100046380();
}

void sub_100089244(int a1, os_log_s *a2, uint64_t a3)
{
  v3[0] = 67109120;
  v3[1] = a1;
  sub_10004CD68((void *)&_mh_execute_header, a2, a3, "SaveReport: Unsupported status %d", (uint8_t *)v3);
  sub_100046380();
}

void sub_1000892AC()
{
  os_log_t v0 = __error();
  strerror(*v0);
  sub_1000463B8();
  sub_100046210( (void *)&_mh_execute_header,  v1,  v2,  "Unable to format: Unable to create stream from %@: %d (%s)",  v3,  v4,  v5,  v6,  v7);
  sub_1000461CC();
}

void sub_100089330()
{
  os_log_t v0 = __error();
  strerror(*v0);
  sub_1000463B8();
  sub_100046210((void *)&_mh_execute_header, v1, v2, "Unable to create stream from %@: %d (%s)", v3, v4, v5, v6, v7);
  sub_1000461CC();
}

void sub_1000893B4(void *a1, const char *a2)
{
}

void sub_100089434(void *a1, const char *a2)
{
}

void sub_1000894B4(os_log_s *a1, uint64_t a2, uint64_t a3)
{
  int v3 = 136315138;
  uint64_t v4 = "!url_out";
  sub_10003C438( (void *)&_mh_execute_header,  a1,  a3,  "Unable to format: %s: asking for URL when generating report via OSA",  (uint8_t *)&v3);
  sub_10002EE70();
}

void sub_100089528(os_log_t log)
{
  int v1 = 136315138;
  uint64_t v2 = "!url_out";
  _os_log_error_impl( (void *)&_mh_execute_header,  log,  OS_LOG_TYPE_ERROR,  "%s: asking for URL when generating report via OSA",  (uint8_t *)&v1,  0xCu);
  sub_10002EE70();
}

void sub_1000895A4(void *a1, const char *a2)
{
}

void sub_100089634(void *a1, const char *a2)
{
}

void sub_1000896C4()
{
}

void sub_100089728(unsigned int a1, char a2, os_log_s *a3)
{
}

void sub_1000897A8( os_log_s *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_1000897D8( os_log_s *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100089808(void *a1, os_log_s *a2)
{
}

void sub_10008987C(void *a1, os_log_s *a2)
{
}

void sub_1000898F0()
{
}

void sub_100089960()
{
}

void sub_1000899D0()
{
}

void sub_100089A40()
{
}

void sub_100089AB0(FILE *a1)
{
  int v1 = sub_10004CDB8(a1);
  sub_10004CDC0(v1);
  sub_100046490();
  sub_1000462D4( (void *)&_mh_execute_header,  v2,  v3,  "Unable to format: Unable to write post-blob to output file: %d (%s)",  v4,  v5,  v6,  v7,  v8);
  sub_1000462C8();
}

void sub_100089B1C(FILE *a1)
{
  int v1 = sub_10004CDB8(a1);
  sub_10004CDC0(v1);
  sub_100046490();
  sub_100046590( (void *)&_mh_execute_header,  v2,  v3,  "Unable to write post-blob to output file: %d (%s)",  v4,  v5,  v6,  v7,  v8);
  sub_1000462C8();
}

void sub_100089B88(FILE *a1)
{
  int v1 = sub_10004CDB8(a1);
  sub_10004CDC0(v1);
  sub_100046490();
  sub_1000462D4( (void *)&_mh_execute_header,  v2,  v3,  "Unable to format: Unable to write pre-blob to output file: %d (%s)",  v4,  v5,  v6,  v7,  v8);
  sub_1000462C8();
}

void sub_100089BF4(FILE *a1)
{
  int v1 = sub_10004CDB8(a1);
  sub_10004CDC0(v1);
  sub_100046490();
  sub_100046590( (void *)&_mh_execute_header,  v2,  v3,  "Unable to write pre-blob to output file: %d (%s)",  v4,  v5,  v6,  v7,  v8);
  sub_1000462C8();
}

void sub_100089C60()
{
}

void sub_100089C90()
{
}

void sub_100089CC0()
{
}

void sub_100089CEC()
{
}

void sub_100089D1C()
{
}

void sub_100089D4C()
{
}

void sub_100089DAC()
{
}

void sub_100089E0C()
{
}

void sub_100089E3C()
{
}

void sub_100089E6C()
{
}

void sub_100089E9C()
{
}

void sub_100089EC8()
{
}

void sub_100089F28()
{
}

void sub_100089F88()
{
}

void sub_100089FB8()
{
}

void sub_100089FE4(void *a1, char *a2)
{
  int v4 = 134217984;
  id v5 = sub_10005144C(a1, a2);
  sub_10003C438( (void *)&_mh_execute_header,  (os_log_s *)a2,  v3,  "Unable to format: Added report to pending deferred reports (have %lu)",  (uint8_t *)&v4);
  sub_1000462C8();
}

void sub_10008A058()
{
}

void sub_10008A0B8()
{
}

void sub_10008A118()
{
}

void sub_10008A184()
{
}

void sub_10008A1F0()
{
}

void sub_10008A250()
{
}

void sub_10008A2B0()
{
}

void sub_10008A2E0()
{
}

void sub_10008A30C()
{
}

void sub_10008A33C()
{
}

void sub_10008A368()
{
}

void sub_10008A3C8()
{
}

void sub_10008A434()
{
}

void sub_10008A4A0()
{
}

void sub_10008A50C()
{
}

void sub_10008A584(void *a1, char *a2)
{
  int v4 = 134217984;
  id v5 = sub_10005144C(a1, a2);
  sub_10003C438( (void *)&_mh_execute_header,  (os_log_s *)a2,  v3,  "Unable to format: Generated %lu deferred reports",  (uint8_t *)&v4);
  sub_1000462C8();
}

void sub_10008A5F8(_BYTE *a1, _BYTE *a2)
{
}

void sub_10008A624(_BYTE *a1, _BYTE *a2)
{
}

void sub_10008A64C(uint64_t a1, void *a2)
{
  id v5 = sub_100051454(a1, a2);
  *(_DWORD *)int v4 = 134217984;
  *os_log_t v3 = v5;
  _os_log_fault_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_FAULT,  "Unable to format: Unhandled deferred report type %llu",  v4,  0xCu);
  sub_100051474();
}

void sub_10008A69C(uint64_t a1, void *a2)
{
  id v5 = sub_100051454(a1, a2);
  *(_DWORD *)int v4 = 134217984;
  *os_log_t v3 = v5;
  _os_log_error_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_ERROR,  "Unhandled deferred report type %llu",  v4,  0xCu);
  sub_100051474();
}

void sub_10008A6EC(_BYTE *a1, _BYTE *a2)
{
}

void sub_10008A718(_BYTE *a1, _BYTE *a2)
{
}

void sub_10008A740(_BYTE *a1, _BYTE *a2)
{
}

void sub_10008A76C(_BYTE *a1, _BYTE *a2)
{
}

void sub_10008A798(_BYTE *a1, _BYTE *a2)
{
}

void sub_10008A7C0(_BYTE *a1, _BYTE *a2)
{
}

void sub_10008A7EC(_BYTE *a1, _BYTE *a2)
{
}

void sub_10008A814(_BYTE *a1, _BYTE *a2)
{
}

void sub_10008A840(_BYTE *a1, _BYTE *a2)
{
}

void sub_10008A86C(_BYTE *a1, _BYTE *a2)
{
}

void sub_10008A894()
{
}

void sub_10008A8C4()
{
}

void sub_10008A8FC()
{
}

void sub_10008A92C()
{
}

void sub_10008A95C()
{
}

void sub_10008A9CC()
{
}

void sub_10008AA3C()
{
}

void sub_10008AA68()
{
}

void sub_10008AA94()
{
    v3,
    v4,
    v5,
    v6,
    v7);
  sub_1000462C8();
}

void sub_10008AB04()
{
    v3,
    v4,
    v5,
    v6,
    v7);
  sub_1000462C8();
}

void sub_10008AB74()
{
    v2,
    v3,
    v4,
    v5,
    v6);
  sub_100046380();
}

void sub_10008ABA0()
{
    v2,
    v3,
    v4,
    v5,
    v6);
  sub_100046380();
}

void sub_10008ABCC()
{
  uint64_t v1 = sub_100054B98();
  sub_100046448(v1);
  sub_1000464EC();
  sub_10004AF48( (void *)&_mh_execute_header,  v2,  v3,  "Unable to format: %s [%d]: Unable to spawn ddt: %d (%s)",  v4,  v5,  v6,  v7,  v8);
  sub_1000461CC();
}

void sub_10008AC48()
{
  uint64_t v1 = sub_100054B98();
  sub_100046448(v1);
  sub_1000464EC();
  sub_10004AF70( (void *)&_mh_execute_header,  v2,  v3,  "%{public}s [%d]: Unable to spawn ddt: %d (%s)",  v4,  v5,  v6,  v7,  v8);
  sub_1000461CC();
}

void sub_10008ACC4()
{
  os_log_t v0 = sub_100046614();
  sub_100046448(v0);
  sub_100046490();
  sub_1000462D4( (void *)&_mh_execute_header,  v1,  v2,  "Unable to format: Unable to spawn ddt: %d (%s)",  v3,  v4,  v5,  v6,  v7);
  sub_1000462C8();
}

void sub_10008AD34()
{
  os_log_t v0 = sub_100046614();
  sub_100046448(v0);
  sub_100046490();
  sub_100046590((void *)&_mh_execute_header, v1, v2, "Unable to spawn ddt: %d (%s)", v3, v4, v5, v6, v7);
  sub_1000462C8();
}

void sub_10008ADA4()
{
}

void sub_10008AE14()
{
}

void sub_10008AE84()
{
}

void sub_10008AEB0()
{
}

void sub_10008AEDC()
{
    v3,
    v4,
    v5,
    v6,
    v7);
  sub_1000462C8();
}

void sub_10008AF4C()
{
    v3,
    v4,
    v5,
    v6,
    v7);
  sub_1000462C8();
}

void sub_10008AFBC()
{
    v2,
    v3,
    v4,
    v5,
    v6);
  sub_100046380();
}

void sub_10008AFE8()
{
    v2,
    v3,
    v4,
    v5,
    v6);
  sub_100046380();
}

void sub_10008B014()
{
  uint64_t v1 = sub_100054B98();
  sub_100046448(v1);
  sub_1000464EC();
  sub_10004AF48( (void *)&_mh_execute_header,  v2,  v3,  "Unable to format: %s [%d]: Unable to spawn lsof: %d (%s)",  v4,  v5,  v6,  v7,  v8);
  sub_1000461CC();
}

void sub_10008B090()
{
  uint64_t v1 = sub_100054B98();
  sub_100046448(v1);
  sub_1000464EC();
  sub_10004AF70( (void *)&_mh_execute_header,  v2,  v3,  "%{public}s [%d]: Unable to spawn lsof: %d (%s)",  v4,  v5,  v6,  v7,  v8);
  sub_1000461CC();
}

void sub_10008B10C()
{
  os_log_t v0 = sub_100046614();
  sub_100046448(v0);
  sub_100046490();
  sub_1000462D4( (void *)&_mh_execute_header,  v1,  v2,  "Unable to format: Unable to spawn lsof: %d (%s)",  v3,  v4,  v5,  v6,  v7);
  sub_1000462C8();
}

void sub_10008B17C()
{
  os_log_t v0 = sub_100046614();
  sub_100046448(v0);
  sub_100046490();
  sub_100046590((void *)&_mh_execute_header, v1, v2, "Unable to spawn lsof: %d (%s)", v3, v4, v5, v6, v7);
  sub_1000462C8();
}

void sub_10008B1EC(int a1)
{
}

void sub_10008B258()
{
}

void sub_10008B284(int a1)
{
}

void sub_10008B2F0()
{
}

void sub_10008B31C(int a1)
{
}

void sub_10008B388()
{
}

void sub_10008B3B4()
{
  uint64_t v1 = sub_1000465FC();
  sub_100046448(v1);
  sub_10004AE7C();
  sub_1000465CC( (void *)&_mh_execute_header,  v2,  v3,  "Unable to format: %s [%d]: could not open log file %@: %d (%s)",  v4,  v5,  v6,  v7,  v8);
  sub_1000462B4();
}

void sub_10008B434()
{
  uint64_t v1 = sub_1000465FC();
  sub_100046448(v1);
  sub_10004AE7C();
  sub_100046568( (void *)&_mh_execute_header,  v2,  v3,  "%{public}s [%d]: could not open log file %@: %d (%s)",  v4,  v5,  v6,  v7,  v8);
  sub_1000462B4();
}

void sub_10008B4B4()
{
  os_log_t v0 = sub_1000465F4();
  sub_100046448(v0);
  sub_1000463B8();
  sub_100046210( (void *)&_mh_execute_header,  v1,  v2,  "Unable to format: could not open log file %@: %d (%s)",  v3,  v4,  v5,  v6,  v7);
  sub_1000461CC();
}

void sub_10008B528()
{
  os_log_t v0 = sub_1000465F4();
  sub_100046448(v0);
  sub_1000463B8();
  sub_100046464((void *)&_mh_execute_header, v1, v2, "could not open log file %@: %d (%s)", v3, v4, v5, v6, v7);
  sub_1000461CC();
}

void sub_10008B59C()
{
  uint64_t v1 = sub_1000465FC();
  sub_100046448(v1);
  sub_10004AE7C();
  sub_1000465CC( (void *)&_mh_execute_header,  v2,  v3,  "Unable to format: %s [%d]: could not fdopen log file %@: %d (%s)",  v4,  v5,  v6,  v7,  v8);
  sub_1000462B4();
}

void sub_10008B61C()
{
  uint64_t v1 = sub_1000465FC();
  sub_100046448(v1);
  sub_10004AE7C();
  sub_100046568( (void *)&_mh_execute_header,  v2,  v3,  "%{public}s [%d]: could not fdopen log file %@: %d (%s)",  v4,  v5,  v6,  v7,  v8);
  sub_1000462B4();
}

void sub_10008B69C()
{
  os_log_t v0 = sub_1000465F4();
  sub_100046448(v0);
  sub_1000463B8();
  sub_100046210( (void *)&_mh_execute_header,  v1,  v2,  "Unable to format: could not fdopen log file %@: %d (%s)",  v3,  v4,  v5,  v6,  v7);
  sub_1000461CC();
}

void sub_10008B710()
{
  os_log_t v0 = sub_1000465F4();
  sub_100046448(v0);
  sub_1000463B8();
  sub_100046464((void *)&_mh_execute_header, v1, v2, "could not fdopen log file %@: %d (%s)", v3, v4, v5, v6, v7);
  sub_1000461CC();
}

void sub_10008B784()
{
  int v1 = sub_100054B70();
  sub_10004CDC0(v1);
  sub_100054B44();
  sub_10004AF48( (void *)&_mh_execute_header,  v2,  v3,  "Unable to format: %s [%d]: Unable to write ddt/lsof output to buffer: %d (%s)",  v4,  v5,  v6,  v7,  v8);
  sub_1000461CC();
}

void sub_10008B7FC()
{
  int v1 = sub_100054B70();
  sub_10004CDC0(v1);
  sub_100054B44();
  sub_10004AF70( (void *)&_mh_execute_header,  v2,  v3,  "%{public}s [%d]: Unable to write ddt/lsof output to buffer: %d (%s)",  v4,  v5,  v6,  v7,  v8);
  sub_1000461CC();
}

void sub_10008B874(FILE *a1)
{
  int v1 = sub_10004CDB8(a1);
  sub_10004CDC0(v1);
  sub_100046490();
  sub_1000462D4( (void *)&_mh_execute_header,  v2,  v3,  "Unable to format: Unable to write ddt/lsof output to buffer: %d (%s)",  v4,  v5,  v6,  v7,  v8);
  sub_1000462C8();
}

void sub_10008B8E0(FILE *a1)
{
  int v1 = sub_10004CDB8(a1);
  sub_10004CDC0(v1);
  sub_100046490();
  sub_100046590( (void *)&_mh_execute_header,  v2,  v3,  "Unable to write ddt/lsof output to buffer: %d (%s)",  v4,  v5,  v6,  v7,  v8);
  sub_1000462C8();
}

void sub_10008B94C()
{
}

void sub_10008B9BC()
{
}

void sub_10008BA2C()
{
}

void sub_10008BA58()
{
}

void sub_10008BA84()
{
  os_log_t v0 = __error();
  strerror(*v0);
  sub_100046490();
  sub_1000462D4( (void *)&_mh_execute_header,  v1,  v2,  "Unable to format: Unable to opendir /private/var/db/spindump: %d (%s)",  v3,  v4,  v5,  v6,  v7);
  sub_1000462C8();
}

void sub_10008BB00()
{
  os_log_t v0 = __error();
  strerror(*v0);
  sub_100046490();
  sub_100046590( (void *)&_mh_execute_header,  v1,  v2,  "Unable to opendir /private/var/db/spindump: %d (%s)",  v3,  v4,  v5,  v6,  v7);
  sub_1000462C8();
}

void sub_10008BB7C(os_log_t log)
{
  *(_WORD *)uint64_t v1 = 0;
  _os_log_fault_impl( (void *)&_mh_execute_header,  log,  OS_LOG_TYPE_FAULT,  "Unable to format: Marked file purgeable",  v1,  2u);
}

void sub_10008BBBC(os_log_t log)
{
  *(_WORD *)uint64_t v1 = 0;
  _os_log_debug_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_DEBUG, "Marked file purgeable", v1, 2u);
}

void sub_10008BBFC(int a1)
{
}

void sub_10008BC6C(int a1)
{
}

void sub_10008BCDC()
{
}

void sub_10008BD44()
{
}

void sub_10008BDB4()
{
}

void sub_10008BDE0()
{
}

void sub_10008BE0C(uint64_t a1, os_log_s *a2, uint64_t a3, double a4)
{
  int v4 = 134218240;
  uint64_t v5 = a1;
  __int16 v6 = 2048;
  double v7 = a4;
  sub_10003C48C( (void *)&_mh_execute_header,  a2,  a3,  "Unable to format: Found ISO timestamp %ld with subseconds %f",  (uint8_t *)&v4);
  sub_10002EE70();
}

void sub_10008BE80(uint64_t a1, os_log_s *a2, double a3)
{
  int v4 = 134218240;
  uint64_t v5 = a1;
  __int16 v6 = 2048;
  double v7 = fmod(a3, 1.0);
  _os_log_debug_impl( (void *)&_mh_execute_header,  a2,  OS_LOG_TYPE_DEBUG,  "Found ISO timestamp %ld with subseconds %f",  (uint8_t *)&v4,  0x16u);
  sub_1000462C8();
}

void sub_10008BF14()
{
}

void sub_10008BF78()
{
}

void sub_10008BFD8()
{
  v1[0] = 136315650;
  sub_10005D6A8();
  _os_log_fault_impl( (void *)&_mh_execute_header,  v0,  OS_LOG_TYPE_FAULT,  "Unable to format: %s: endOfSecs %p endPtr %p",  (uint8_t *)v1,  0x20u);
}

void sub_10008C05C()
{
  v1[0] = 136315650;
  sub_10005D6A8();
  _os_log_error_impl( (void *)&_mh_execute_header,  v0,  OS_LOG_TYPE_ERROR,  "%s: endOfSecs %p endPtr %p",  (uint8_t *)v1,  0x20u);
}

void sub_10008C0E0()
{
}

void sub_10008C144()
{
}

void sub_10008C1A4()
{
}

void sub_10008C208()
{
}

void sub_10008C268()
{
}

void sub_10008C2CC()
{
}

void sub_10008C32C(void *a1, os_log_s *a2)
{
  uint64_t v3 = (char *)objc_msgSend(objc_msgSend(a1, "total"), "bytes");
  uint64_t v4 = &v3[(void)objc_msgSend(sub_100046340(), "bytes_duplicate")];
  id v5 = objc_msgSend(sub_100046340(), "bytes_out_of_order");
  uint8_t v6 = &v4[(unint64_t)objc_msgSend(sub_100046340(), "bytes_missing_load_info") + (void)v5];
  int v9 = (char *)objc_msgSend(a1, "bytes_not_microstackshots") + (void)v6;
  id v11 = objc_msgSend(a1, "bytes_not_microstackshots");
  id v13 = objc_msgSend(a1, "num_microstackshots_filtered_out");
  id v15 = [sub_100046340() count];
  id v17 = [sub_100046340() bytes];
  id v19 = objc_msgSend(sub_100046340(), "num_load_infos");
  id v21 = objc_msgSend(sub_100046340(), "num_frames");
  id v23 = objc_msgSend(sub_100046340(), "num_duplicate");
  id v25 = objc_msgSend(sub_100046340(), "bytes_duplicate");
  id v27 = objc_msgSend(sub_100046340(), "num_out_of_order");
  id v29 = objc_msgSend(sub_100046340(), "bytes_out_of_order");
  id v31 = objc_msgSend(sub_100046340(), "num_missing_load_info");
  id v33 = objc_msgSend(sub_100046340(), "bytes_missing_load_info");
  id v35 = [sub_10005D674() count];
  id v37 = [sub_10005D674() bytes];
  id v39 = objc_msgSend(sub_10005D674(), "num_load_infos");
  id v41 = objc_msgSend(sub_10005D674(), "num_frames");
  id v43 = objc_msgSend(sub_10005D674(), "num_duplicate");
  id v45 = objc_msgSend(sub_10005D674(), "bytes_duplicate");
  id v47 = objc_msgSend(sub_10005D674(), "num_out_of_order");
  id v49 = objc_msgSend(sub_10005D674(), "bytes_out_of_order");
  id v51 = objc_msgSend(sub_10005D674(), "num_missing_load_info");
  id v53 = objc_msgSend(sub_10005D674(), "bytes_missing_load_info");
  id v55 = [sub_10005D664() count];
  id v57 = [sub_10005D664() bytes];
  id v59 = objc_msgSend(sub_10005D664(), "num_load_infos");
  id v61 = objc_msgSend(sub_10005D664(), "num_frames");
  id v63 = objc_msgSend(sub_10005D664(), "num_duplicate");
  id v65 = objc_msgSend(sub_10005D664(), "bytes_duplicate");
  id v67 = objc_msgSend(sub_10005D664(), "num_out_of_order");
  id v69 = objc_msgSend(sub_10005D664(), "bytes_out_of_order");
  id v71 = objc_msgSend(sub_10005D664(), "num_missing_load_info");
  id v73 = objc_msgSend(sub_10005D664(), "bytes_missing_load_info");
  id v75 = [sub_10005D684() count];
  id v77 = [sub_10005D684() bytes];
  id v79 = objc_msgSend(sub_10005D684(), "num_load_infos");
  id v81 = objc_msgSend(sub_10005D684(), "num_frames");
  id v83 = objc_msgSend(sub_10005D684(), "num_duplicate");
  id v85 = objc_msgSend(sub_10005D684(), "bytes_duplicate");
  id v87 = objc_msgSend(sub_10005D684(), "num_out_of_order");
  id v89 = objc_msgSend(sub_10005D684(), "bytes_out_of_order");
  id v91 = objc_msgSend(sub_10005D684(), "num_missing_load_info");
  id v93 = objc_msgSend(sub_10005D684(), "bytes_missing_load_info");
  id v95 = [sub_10005D66C() count];
  *(_DWORD *)buf = 134236416;
  id v97 = [sub_10005D66C() bytes];
  __int16 v10 = 2048;
  __int16 v12 = 2048;
  __int16 v14 = 2048;
  __int16 v16 = 2048;
  __int16 v18 = 2048;
  __int16 v20 = 2048;
  __int16 v22 = 2048;
  __int16 v24 = 2048;
  __int16 v26 = 2048;
  __int16 v28 = 2048;
  __int16 v30 = 2048;
  __int16 v32 = 2048;
  __int16 v34 = 2048;
  __int16 v36 = 2048;
  __int16 v38 = 2048;
  __int16 v40 = 2048;
  __int16 v42 = 2048;
  __int16 v44 = 2048;
  __int16 v46 = 2048;
  __int16 v48 = 2048;
  __int16 v50 = 2048;
  __int16 v52 = 2048;
  __int16 v54 = 2048;
  __int16 v56 = 2048;
  __int16 v58 = 2048;
  __int16 v60 = 2048;
  __int16 v62 = 2048;
  __int16 v64 = 2048;
  __int16 v66 = 2048;
  __int16 v68 = 2048;
  __int16 v70 = 2048;
  __int16 v72 = 2048;
  __int16 v74 = 2048;
  __int16 v76 = 2048;
  __int16 v78 = 2048;
  __int16 v80 = 2048;
  __int16 v82 = 2048;
  __int16 v84 = 2048;
  __int16 v86 = 2048;
  __int16 v88 = 2048;
  __int16 v90 = 2048;
  __int16 v92 = 2048;
  __int16 v94 = 2048;
  __int16 v96 = 2048;
  __int16 v98 = 2048;
  id v99 = objc_msgSend(sub_10005D66C(), "num_load_infos");
  __int16 v100 = 2048;
  id v101 = objc_msgSend(sub_10005D66C(), "num_frames");
  __int16 v102 = 2048;
  id v103 = objc_msgSend(sub_10005D66C(), "num_duplicate");
  __int16 v104 = 2048;
  id v105 = objc_msgSend(sub_10005D66C(), "bytes_duplicate");
  __int16 v106 = 2048;
  id v107 = objc_msgSend(sub_10005D66C(), "num_out_of_order");
  __int16 v108 = 2048;
  id v109 = objc_msgSend(sub_10005D66C(), "bytes_out_of_order");
  __int16 v110 = 2048;
  id v111 = objc_msgSend(sub_10005D66C(), "num_missing_load_info");
  __int16 v112 = 2048;
  id v113 = objc_msgSend(sub_10005D66C(), "bytes_missing_load_info");
  __int16 v114 = 2048;
  id v115 = [sub_10005D65C() count];
  __int16 v116 = 2048;
  id v117 = [sub_10005D65C() bytes];
  __int16 v118 = 2048;
  id v119 = objc_msgSend(sub_10005D65C(), "num_load_infos");
  __int16 v120 = 2048;
  id v121 = objc_msgSend(sub_10005D65C(), "num_frames");
  __int16 v122 = 2048;
  id v123 = objc_msgSend(sub_10005D65C(), "num_duplicate");
  __int16 v124 = 2048;
  id v125 = objc_msgSend(sub_10005D65C(), "bytes_duplicate");
  __int16 v126 = 2048;
  id v127 = objc_msgSend(sub_10005D65C(), "num_out_of_order");
  __int16 v128 = 2048;
  id v129 = objc_msgSend(sub_10005D65C(), "bytes_out_of_order");
  __int16 v130 = 2048;
  id v131 = objc_msgSend(sub_10005D65C(), "num_missing_load_info");
  __int16 v132 = 2048;
  id v133 = objc_msgSend(sub_10005D65C(), "bytes_missing_load_info");
  __int16 v134 = 2048;
  id v135 = [sub_10005D67C() count];
  __int16 v136 = 2048;
  id v137 = [sub_10005D67C() bytes];
  __int16 v138 = 2048;
  id v139 = objc_msgSend(sub_10005D67C(), "num_load_infos");
  __int16 v140 = 2048;
  id v141 = objc_msgSend(sub_10005D67C(), "num_frames");
  __int16 v142 = 2048;
  id v143 = objc_msgSend(sub_10005D67C(), "num_duplicate");
  __int16 v144 = 2048;
  id v145 = objc_msgSend(sub_10005D67C(), "bytes_duplicate");
  __int16 v146 = 2048;
  id v147 = objc_msgSend(sub_10005D67C(), "num_out_of_order");
  __int16 v148 = 2048;
  id v149 = objc_msgSend(sub_10005D67C(), "bytes_out_of_order");
  __int16 v150 = 2048;
  id v151 = objc_msgSend(sub_10005D67C(), "num_missing_load_info");
  __int16 v152 = 2048;
  id v153 = objc_msgSend(sub_10005D67C(), "bytes_missing_load_info");
  _os_log_fault_impl( (void *)&_mh_execute_header,  a2,  OS_LOG_TYPE_FAULT,  "Unable to format: Microstackshot statistics:\n %llu bytes parsed (%llu bytes invalid)\n %llu filtered out\n \n total     count          %llu (%llu bytes)\n num_load_infos %llu\n num_frames     %llu\n duplicate      %llu (%llu bytes)\n out_of_order   %llu (%llu bytes)\n no_load_info   %llu (%llu bytes)\n \n interrupt count          %llu (%llu bytes)\n num_load_infos %llu\n num_frames     %llu\n duplicate      %llu (%llu bytes)\n out_of_order   %llu (%llu bytes)\n no_load_info   %llu (%llu bytes)\n \n timer     count          %llu (%llu bytes)\n num_load_infos %llu\n num_frames     %llu\n duplicate      %llu (%llu bytes)\n out_of_order   %llu (%llu bytes)\n no_load_info   %llu (%llu bytes)\n \n io        count          %llu (%llu bytes)\n num_load_infos %llu\n num_frames     %llu\n duplicate      %llu (%llu bytes)\n out_of_order   %llu (%llu bytes)\n no_load_info   %llu (%llu bytes)\n \n pmi       count          %llu (%llu bytes)\n num_load_infos %llu\n num_frames     %llu\n duplicate      %llu (%llu bytes)\n out_of_order   %llu (%llu bytes)\n no_load_info   %llu (%llu bytes)\n \n macf      count          %llu (%llu bytes)\n num_load_infos %llu\n num_frames     %llu\n duplicate      %llu (%llu bytes)\n out_of_order   %llu (%llu bytes)\n no_load_info   %llu (%llu bytes)\n \n"
    "unknown   count          %llu (%llu bytes)\n"
    "          num_load_infos %llu\n"
    "          num_frames     %llu\n"
    "          duplicate      %llu (%llu bytes)\n"
    "          out_of_order   %llu (%llu bytes)\n"
    "          no_load_info   %llu (%llu bytes)",
    buf,
    0x2DCu);
}

void sub_10008CB04(void *a1, os_log_s *a2)
{
}

void sub_10008CB78(void *a1, os_log_s *a2)
{
}

void sub_10008CBEC(void *a1, char *a2)
{
}

void sub_10008CC60(void *a1, char *a2)
{
}

void sub_10008CCD4(void *a1, char *a2)
{
}

void sub_10008CD48(void *a1, char *a2)
{
}

void sub_10008CDBC()
{
  os_log_t v0 = sub_100046614();
  sub_100046448(v0);
  sub_100046490();
  sub_1000462D4( (void *)&_mh_execute_header,  v1,  v2,  "Unable to format: Unable to get pid list: %d (%s)",  v3,  v4,  v5,  v6,  v7);
  sub_1000462C8();
}

void sub_10008CE2C()
{
  os_log_t v0 = sub_100046614();
  sub_100046448(v0);
  sub_100046490();
  sub_100046590((void *)&_mh_execute_header, v1, v2, "Unable to get pid list: %d (%s)", v3, v4, v5, v6, v7);
  sub_1000462C8();
}

void sub_10008CE9C()
{
}

void sub_10008CF00()
{
}

void sub_10008CF64()
{
}

void sub_10008CFC8()
{
}

void sub_10008D02C()
{
}

void sub_10008D094()
{
}

void sub_10008D0F4()
{
}

void sub_10008D164()
{
}

void sub_10008D1D4()
{
}

void sub_10008D23C()
{
}

void sub_10008D2A4()
{
}

void sub_10008D30C()
{
}

void sub_10008D36C()
{
}

void sub_10008D3DC()
{
}

void sub_10008D44C()
{
}

void sub_10008D4B4()
{
}

void sub_10008D51C(dispatch_source_s *a1, os_log_s *a2)
{
}

void sub_10008D58C(dispatch_source_s *a1, os_log_s *a2)
{
}

void sub_10008D5FC(dispatch_source_s *a1, os_log_s *a2)
{
}

void sub_10008D66C(dispatch_source_s *a1)
{
}

void sub_10008D6EC(dispatch_source_s *a1, os_log_s *a2, double a3)
{
  int v5 = 134218240;
  double v6 = a3 - *(double *)&qword_1000E7C60;
  __int16 v7 = 2048;
  uintptr_t handle = dispatch_source_get_handle(a1);
  sub_10003C48C( (void *)&_mh_execute_header,  a2,  v4,  "Unable to format: Interrupted again after %.2f seconds by signal %ld, not exiting",  (uint8_t *)&v5);
}

void sub_10008D78C()
{
}

void sub_10008D7B8()
{
}

void sub_10008D7E4()
{
  os_log_t v0 = __error();
  sub_100046448(v0);
  sub_1000463B8();
  sub_100046210( (void *)&_mh_execute_header,  v1,  v2,  "Unable to format: spindump-stuck: Unable to open %s: %d (%s)",  v3,  v4,  v5,  v6,  v7);
  sub_1000461CC();
}

void sub_10008D864()
{
  os_log_t v0 = __error();
  sub_100046448(v0);
  sub_1000463B8();
  sub_100046464((void *)&_mh_execute_header, v1, v2, "spindump-stuck: Unable to open %s: %d (%s)", v3, v4, v5, v6, v7);
  sub_1000461CC();
}

void sub_10008D8E4()
{
}

void sub_10008D910()
{
}

void sub_10008D93C()
{
}

void sub_10008D9A0(int a1, FILE *a2, int a3, int a4, int a5, int a6, int a7, int a8)
{
  int v8 = sub_10005D6F8(a1, a2, a3, a4, a5, a6, a7, a8, v15, v17, v18, v19, v20, v21);
  strerror(v8);
  sub_1000463B8();
  sub_100046210( (void *)&_mh_execute_header,  v9,  v10,  "Unable to format: Unable to write stackshot to %s: %d (%s)",  v11,  v12,  v13,  v14,  v16);
  sub_1000461CC();
}

void sub_10008DA18(int a1, FILE *a2, int a3, int a4, int a5, int a6, int a7, int a8)
{
  int v8 = sub_10005D6F8(a1, a2, a3, a4, a5, a6, a7, a8, v15, v17, v18, v19, v20, v21);
  strerror(v8);
  sub_1000463B8();
  sub_100046464( (void *)&_mh_execute_header,  v9,  v10,  "Unable to write stackshot to %s: %d (%s)",  v11,  v12,  v13,  v14,  v16);
  sub_1000461CC();
}

void sub_10008DA90()
{
}

void sub_10008DAF8()
{
}

void sub_10008DB60()
{
}

void sub_10008DB8C()
{
}

void sub_10008DBB8()
{
}

void sub_10008DBE4()
{
  uint64_t v2 = sub_100054B98();
  sub_100046448(v2);
  sub_1000464EC();
  _os_log_fault_impl( (void *)&_mh_execute_header,  v0,  OS_LOG_TYPE_FAULT,  "Unable to format: %s [%d]: Unable to get proc info, assuming not being debugged: %d (%s)",  v3,  0x22u);
  sub_1000461CC();
}

void sub_10008DC70()
{
  uint64_t v2 = sub_100054B98();
  sub_100046448(v2);
  sub_1000464EC();
  _os_log_error_impl( (void *)&_mh_execute_header,  v0,  OS_LOG_TYPE_ERROR,  "%{public}s [%d]: Unable to get proc info, assuming not being debugged: %d (%s)",  v3,  0x22u);
  sub_1000461CC();
}

void sub_10008DCFC()
{
  os_log_t v0 = sub_100046614();
  sub_100046448(v0);
  sub_100046490();
  sub_1000462D4( (void *)&_mh_execute_header,  v1,  v2,  "Unable to format: Unable to get proc info, assuming not being debugged: %d (%s)",  v3,  v4,  v5,  v6,  v7);
  sub_1000462C8();
}

void sub_10008DD6C()
{
  os_log_t v0 = sub_100046614();
  sub_100046448(v0);
  sub_100046490();
  sub_100046590( (void *)&_mh_execute_header,  v1,  v2,  "Unable to get proc info, assuming not being debugged: %d (%s)",  v3,  v4,  v5,  v6,  v7);
  sub_1000462C8();
}

void sub_10008DDDC()
{
  os_log_t v0 = sub_100046614();
  sub_100046448(v0);
  sub_100046490();
  sub_1000462D4( (void *)&_mh_execute_header,  v1,  v2,  "Unable to format: sysctl for security.mac.sandbox.audio_active failed: %d (%s)",  v3,  v4,  v5,  v6,  v7);
  sub_1000462C8();
}

void sub_10008DE4C()
{
  os_log_t v0 = sub_100046614();
  sub_100046448(v0);
  sub_100046490();
  sub_1000462D4( (void *)&_mh_execute_header,  v1,  v2,  "sysctl for security.mac.sandbox.audio_active failed: %d (%s)",  v3,  v4,  v5,  v6,  v7);
  sub_1000462C8();
}

void sub_10008DEBC(os_log_s *a1, uint64_t a2, uint64_t a3)
{
  int v3 = 136315138;
  uint64_t v4 = "source";
  sub_10003C438((void *)&_mh_execute_header, a1, a3, "Unable to format: %s: unable to allocate source", (uint8_t *)&v3);
  sub_10002EE70();
}

void sub_10008DF30(os_log_s *a1, uint64_t a2, uint64_t a3)
{
  int v3 = 136315138;
  uint64_t v4 = "source";
  sub_10005D68C((void *)&_mh_execute_header, a1, a3, "%s: unable to allocate source", (uint8_t *)&v3);
  sub_10002EE70();
}

void sub_10008DFA4()
{
  os_log_t v0 = sub_100046614();
  sub_100046448(v0);
  sub_100046490();
  sub_1000462D4( (void *)&_mh_execute_header,  v1,  v2,  "Unable to format: sysctlnametomib for security.mac.sandbox.audio_active failed: %d (%s)",  v3,  v4,  v5,  v6,  v7);
  sub_1000462C8();
}

void sub_10008E014()
{
  os_log_t v0 = sub_100046614();
  sub_100046448(v0);
  sub_100046490();
  sub_1000462D4( (void *)&_mh_execute_header,  v1,  v2,  "sysctlnametomib for security.mac.sandbox.audio_active failed: %d (%s)",  v3,  v4,  v5,  v6,  v7);
  sub_1000462C8();
}

void sub_10008E084()
{
}

void sub_10008E0EC()
{
}

void sub_10008E150()
{
  os_log_t v0 = sub_100046614();
  sub_100046448(v0);
  sub_100046490();
  sub_1000462D4( (void *)&_mh_execute_header,  v1,  v2,  "Unable to format: sysctl for kern.memorystatus_vm_pressure_level failed: %d (%s)",  v3,  v4,  v5,  v6,  v7);
  sub_1000462C8();
}

void sub_10008E1C0()
{
  os_log_t v0 = sub_100046614();
  sub_100046448(v0);
  sub_100046490();
  sub_1000462D4( (void *)&_mh_execute_header,  v1,  v2,  "sysctl for kern.memorystatus_vm_pressure_level failed: %d (%s)",  v3,  v4,  v5,  v6,  v7);
  sub_1000462C8();
}

void sub_10008E230()
{
  os_log_t v0 = sub_100046614();
  sub_100046448(v0);
  sub_100046490();
  sub_1000462D4( (void *)&_mh_execute_header,  v1,  v2,  "Unable to format: sysctlnametomib for kern.memorystatus_vm_pressure_level failed: %d (%s)",  v3,  v4,  v5,  v6,  v7);
  sub_1000462C8();
}

void sub_10008E2A0()
{
  os_log_t v0 = sub_100046614();
  sub_100046448(v0);
  sub_100046490();
  sub_1000462D4( (void *)&_mh_execute_header,  v1,  v2,  "sysctlnametomib for kern.memorystatus_vm_pressure_level failed: %d (%s)",  v3,  v4,  v5,  v6,  v7);
  sub_1000462C8();
}

void sub_10008E310()
{
}

void sub_10008E388()
{
}

void sub_10008E400(os_log_s *a1, uint64_t a2, uint64_t a3)
{
  int v3 = 136315138;
  uint64_t v4 = "(((st.st_mode) & 0170000) == 0040000)";
  sub_10003C438( (void *)&_mh_execute_header,  a1,  a3,  "Unable to format: %s: /private/var/db/spindump already exists and isnt a directory!",  (uint8_t *)&v3);
  sub_10002EE70();
}

void sub_10008E474(os_log_s *a1, uint64_t a2, uint64_t a3)
{
  int v3 = 136315138;
  uint64_t v4 = "(((st.st_mode) & 0170000) == 0040000)";
  sub_10005D68C( (void *)&_mh_execute_header,  a1,  a3,  "%s: /private/var/db/spindump already exists and isnt a directory!",  (uint8_t *)&v3);
  sub_10002EE70();
}

void sub_10008E4E8()
{
  uint64_t v2 = sub_100054B98();
  sub_100046448(v2);
  sub_10005D628();
  _os_log_fault_impl( (void *)&_mh_execute_header,  v0,  OS_LOG_TYPE_FAULT,  "Unable to format: %s: unable to create /private/var/db/spindump after state failed with %d (%s): %d (%s)",  v3,  0x2Cu);
  sub_10005D6E0();
}

void sub_10008E57C()
{
  uint64_t v2 = sub_100054B98();
  sub_100046448(v2);
  sub_10005D628();
  _os_log_error_impl( (void *)&_mh_execute_header,  v0,  OS_LOG_TYPE_ERROR,  "%s: unable to create /private/var/db/spindump after state failed with %d (%s): %d (%s)",  v3,  0x2Cu);
  sub_10005D6E0();
}

void sub_10008E610()
{
}

void sub_10008E674()
{
}

void sub_10008E6D4()
{
  uint64_t v0 = sub_1000465F4();
  sub_100046448(v0);
  sub_1000463B8();
  sub_100046210((void *)&_mh_execute_header, v1, v2, "Unable to format: Unable to open %s: %d (%s)", v3, v4, v5, v6, v7);
  sub_1000461CC();
}

void sub_10008E748()
{
}

void sub_10008E7A8()
{
}

void sub_10008E818()
{
  os_log_t v0 = sub_1000465F4();
  sub_100046448(v0);
  sub_1000463B8();
  sub_100046210((void *)&_mh_execute_header, v1, v2, "Unable to format: Unable to map %s: %d (%s)", v3, v4, v5, v6, v7);
  sub_1000461CC();
}

void sub_10008E88C()
{
  os_log_t v0 = sub_1000465F4();
  sub_100046448(v0);
  sub_1000463B8();
  sub_100046464((void *)&_mh_execute_header, v1, v2, "Unable to map %s: %d (%s)", v3, v4, v5, v6, v7);
  sub_1000461CC();
}

void sub_10008E900()
{
}

void sub_10008E960()
{
}

void sub_10008E9D0(os_log_t log)
{
  *(_WORD *)os_log_t v1 = 0;
  _os_log_fault_impl( (void *)&_mh_execute_header,  log,  OS_LOG_TYPE_FAULT,  "Unable to format: Avoiding inspecting live processes for stackshot file due to audio running",  v1,  2u);
}

void sub_10008EA10()
{
}

void sub_10008EA88()
{
}

void sub_10008EB00()
{
  os_log_t v0 = sub_1000465F4();
  sub_100046448(v0);
  sub_1000463B8();
  sub_100046210((void *)&_mh_execute_header, v1, v2, "Unable to format: Unable to stat %s: %d (%s)", v3, v4, v5, v6, v7);
  sub_1000461CC();
}

void sub_10008EB74()
{
  os_log_t v0 = sub_1000465F4();
  sub_100046448(v0);
  sub_1000463B8();
  sub_100046464((void *)&_mh_execute_header, v1, v2, "Unable to stat %s: %d (%s)", v3, v4, v5, v6, v7);
  sub_1000461CC();
}

void sub_10008EBE8(int *a1)
{
}

void sub_10008EC68(int *a1)
{
}

void sub_10008ECE8( uint64_t a1, os_log_s *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10008ED50(uint64_t a1, os_log_s *a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a1 + 8);
  int v4 = 134217984;
  uint64_t v5 = v3;
  sub_10006BB50((void *)&_mh_execute_header, a2, a3, "dealloc with %p transaction", (uint8_t *)&v4);
  sub_10002EE70();
}

void sub_10008EDBC()
{
}

void sub_10008EE38()
{
}

void sub_10008EEB4( os_log_s *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10008EF24( os_log_s *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10008EF94()
{
}

void sub_10008F000()
{
}

void sub_10008F02C()
{
}

void sub_10008F098()
{
}

void sub_10008F104()
{
}

void sub_10008F130()
{
}

void sub_10008F15C()
{
}

void sub_10008F1C8()
{
}

void sub_10008F1F4()
{
}

void sub_10008F260()
{
}

void sub_10008F2CC()
{
}

void sub_10008F2F8()
{
}

void sub_10008F324()
{
}

void sub_10008F390()
{
}

void sub_10008F3FC()
{
}

void sub_10008F428()
{
}

void sub_10008F454()
{
}

void sub_10008F4C0()
{
}

void sub_10008F4EC()
{
}

void sub_10008F558()
{
}

void sub_10008F5C4()
{
}

void sub_10008F5F0()
{
}

void sub_10008F61C()
{
}

void sub_10008F688()
{
}

void sub_10008F6F4()
{
}

void sub_10008F720()
{
}

void sub_10008F74C()
{
  int v1 = sub_10006BB38(v0);
  sub_10002EF3C(v1);
  sub_10006BB44();
  sub_10006BAAC();
  sub_100046210( (void *)&_mh_execute_header,  v2,  v3,  "Unable to format: %s [%d]: %s: _hidEventSem non-NULL when not requiring HID event",  v4,  v5,  v6,  v7,  v8);
  sub_1000461CC();
}

void sub_10008F7CC()
{
  int v1 = sub_10006BB38(v0);
  sub_10002EF3C(v1);
  sub_10006BB44();
  sub_10006BAAC();
  sub_100046464( (void *)&_mh_execute_header,  v2,  v3,  "%s [%d]: %s: _hidEventSem non-NULL when not requiring HID event",  v4,  v5,  v6,  v7,  v8);
  sub_1000461CC();
}

void sub_10008F84C( os_log_s *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10008F8BC( os_log_s *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10008F92C()
{
}

void sub_10008F998()
{
}

void sub_10008FA04()
{
}

void sub_10008FA30()
{
}

void sub_10008FA5C()
{
}

void sub_10008FAC8()
{
}

void sub_10008FB34()
{
}

void sub_10008FB60()
{
}

void sub_10008FB8C()
{
  int v1 = sub_10006BB38(v0);
  sub_10002EF3C(v1);
  sub_10006BB44();
  sub_10006BAAC();
  sub_100046210( (void *)&_mh_execute_header,  v2,  v3,  "Unable to format: %s [%d]: %s: _hidEventSem non-NULL when already tracking this process in previous spin",  v4,  v5,  v6,  v7,  v8);
  sub_1000461CC();
}

void sub_10008FC0C()
{
  int v1 = sub_10006BB38(v0);
  sub_10002EF3C(v1);
  sub_10006BB44();
  sub_10006BAAC();
  sub_100046464( (void *)&_mh_execute_header,  v2,  v3,  "%s [%d]: %s: _hidEventSem non-NULL when already tracking this process in previous spin",  v4,  v5,  v6,  v7,  v8);
  sub_1000461CC();
}

void sub_10008FC8C( os_log_s *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10008FCFC( os_log_s *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10008FD6C()
{
}

void sub_10008FDD8()
{
}

void sub_10008FE44()
{
}

void sub_10008FE70()
{
}

void sub_10008FE9C()
{
}

void sub_10008FF08()
{
}

void sub_10008FF74()
{
}

void sub_10008FFA0()
{
}

void sub_10008FFCC()
{
}

void sub_100090038()
{
}

void sub_1000900A4()
{
}

void sub_1000900D0()
{
}

void sub_1000900FC()
{
}

void sub_100090168()
{
}

void sub_100090194()
{
}

void sub_100090200()
{
}

void sub_10009026C()
{
}

void sub_100090298()
{
}

void sub_1000902C4(uint64_t a1)
{
}

void sub_100090360(uint64_t a1, uint64_t a2, os_log_s *a3)
{
  int v7 = 134217984;
  double v8 = v3 - v5;
  sub_10006BB50( (void *)&_mh_execute_header,  a3,  v6,  "Got hid event from %.1fs earlier than the spin we monitored, continuing to wait",  (uint8_t *)&v7);
  sub_100046518();
}

void sub_1000903FC()
{
}

void sub_100090468()
{
}

void sub_100090494()
{
}

void sub_100090500()
{
}

void sub_10009056C()
{
}

void sub_100090598()
{
}

void sub_1000905C4()
{
}

void sub_100090630()
{
}

void sub_10009069C()
{
}

void sub_1000906C8()
{
}

void sub_1000906F4()
{
}

void sub_100090758()
{
}

void sub_1000907C4()
{
}

void sub_100090828()
{
}

void sub_100090894()
{
}

void sub_100090900()
{
}

void sub_10009096C()
{
}

void sub_100090998()
{
}

void sub_1000909C4(int *a1)
{
}

void sub_100090A58( os_log_s *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100090AC0()
{
}

void sub_100090B2C()
{
}

void sub_100090B98()
{
}

void sub_100090BC4()
{
}

void sub_100090BF0()
{
}

void sub_100090C5C()
{
}

void sub_100090CC8()
{
}

void sub_100090CF4()
{
}

void sub_100090D20()
{
}

void sub_100090D8C()
{
}

void sub_100090DF8()
{
}

void sub_100090E24()
{
}

void sub_100090E50()
{
}

void sub_100090ECC()
{
}

void sub_100090F48( os_log_s *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100090FB8( os_log_s *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100091028()
{
}

void sub_100091094()
{
}

void sub_100091100()
{
}

void sub_10009112C()
{
}

void sub_100091158()
{
}

void sub_100091184()
{
}

void sub_1000911B0()
{
}

void sub_10009121C()
{
}

void sub_100091288()
{
}

void sub_1000912B4()
{
}

void sub_1000912E0(int *a1)
{
}

void sub_100091370(int *a1, unsigned __int8 a2, os_log_s *a3)
{
  uint8_t v6 = sub_10006BA74(a1);
  int v7 = *a1;
  int v8 = 136446722;
  uint64_t v9 = v6;
  __int16 v10 = 1024;
  int v11 = v7;
  __int16 v12 = 1024;
  int v13 = a2;
  _os_log_debug_impl( (void *)&_mh_execute_header,  a3,  OS_LOG_TYPE_DEBUG,  "%{public}s [%d]: Already not sampling when stopped with reason %d",  (uint8_t *)&v8,  0x18u);
  sub_100046518();
}

void sub_10009141C(int a1, os_log_s *a2)
{
  v2[0] = 67109120;
  v2[1] = a1;
  _os_log_fault_impl( (void *)&_mh_execute_header,  a2,  OS_LOG_TYPE_FAULT,  "Unable to format: Already not sampling when stopped with reason %d",  (uint8_t *)v2,  8u);
  sub_100046380();
}

void sub_10009148C(unsigned __int8 a1, os_log_s *a2)
{
  v2[0] = 67109120;
  v2[1] = a1;
  _os_log_debug_impl( (void *)&_mh_execute_header,  a2,  OS_LOG_TYPE_DEBUG,  "Already not sampling when stopped with reason %d",  (uint8_t *)v2,  8u);
  sub_100046380();
}

void sub_100091500()
{
}

void sub_10009156C()
{
}

void sub_1000915D8()
{
}

void sub_100091604()
{
}

void sub_100091630()
{
}

void sub_10009169C()
{
}

void sub_1000916C8()
{
}

void sub_100091734()
{
}

void sub_1000917A0()
{
}

void sub_1000917CC()
{
}

void sub_1000917F8()
{
}

void sub_100091864()
{
}

void sub_100091890()
{
}

void sub_1000918FC()
{
}

void sub_100091928()
{
}

void sub_100091994()
{
}

void sub_1000919C0()
{
}

void sub_100091A2C()
{
}

void sub_100091A98()
{
}

void sub_100091AC4()
{
}

void sub_100091AF0()
{
}

void sub_100091B78()
{
}

void sub_100091BFC( os_log_s *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100091C6C( os_log_s *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100091CDC()
{
  LODWORD(sub_10004CD68( (void *)&_mh_execute_header,  v0,  v1,  "Unable to format: Creating spindump directory /private/var/db/spindump after stat said %d", v2) = 136315906;
  sub_10006BB14();
  sub_10006BB70((void *)&_mh_execute_header, v0, v1, "%s: save report fail %d %d %d", v2, v3, v4, v5);
}

void sub_100091D4C()
{
}

void sub_100091DB8()
{
}

void sub_100091DE4()
{
  LODWORD(sub_10004CD68( (void *)&_mh_execute_header,  v0,  v1,  "Unable to format: Creating spindump directory /private/var/db/spindump after stat said %d", v2) = 136315906;
  sub_10006BB14();
  sub_10006BB70((void *)&_mh_execute_header, v0, v1, "%s: save report fail %d %d %d", v2, v3, v4, v5);
}

void sub_100091E54()
{
}

void sub_100091EBC()
{
}

void sub_100091F24()
{
}

void sub_100091F50()
{
}

void sub_100091F7C()
{
}

void sub_100091FE4()
{
}

void sub_10009204C()
{
}

void sub_100092078()
{
}

void sub_1000920A4()
{
}

void sub_10009210C()
{
}

void sub_100092174()
{
}

void sub_1000921A0()
{
}

void sub_1000921CC()
{
}

void sub_100092234()
{
}

void sub_10009229C()
{
}

void sub_1000922C8()
{
}

void sub_1000922F4()
{
}

void sub_10009235C()
{
}

void sub_1000923C4()
{
}

void sub_1000923F0()
{
}

void sub_10009241C()
{
}

void sub_100092484()
{
}

void sub_1000924EC()
{
}

void sub_100092518()
{
}

void sub_100092544()
{
}

void sub_1000925AC()
{
}

void sub_1000925D8(int a1)
{
}

void sub_100092668(int a1)
{
}

void sub_100092710( uint64_t a1, os_log_s *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100092774(char a1, os_log_s *a2, uint64_t a3)
{
  uint64_t v3 = "";
  if ((a1 & 1) != 0) {
    uint64_t v3 = "non-";
  }
  int v4 = 136315138;
  uint64_t v5 = v3;
  sub_10006BB50( (void *)&_mh_execute_header,  a2,  a3,  "Unable to find existing %sWindowServer-based sampled process",  (uint8_t *)&v4);
  sub_10002EE70();
}

void sub_1000927F4()
{
}

void sub_10009285C()
{
}

void sub_1000928C4()
{
}

void sub_1000928F0()
{
}

void sub_10009291C()
{
  uint64_t v1 = __error();
  strerror(*v1);
  sub_1000464EC();
  sub_10006BB98();
  _os_log_fault_impl(v2, v3, v4, v5, v6, 0x22u);
  sub_1000461CC();
}

void sub_1000929A8()
{
  uint64_t v2 = __error();
  strerror(*v2);
  sub_1000464EC();
  _os_log_error_impl( (void *)&_mh_execute_header,  v0,  OS_LOG_TYPE_ERROR,  "%{public}s [%d]: Unable to get path: %d (%s)",  v3,  0x22u);
  sub_1000461CC();
}

void sub_100092A3C(uint64_t a1, void *a2)
{
  unsigned int v5 = sub_100072130(a1, a2);
  *(_DWORD *)os_log_type_t v4 = 67109120;
  *os_log_t v3 = v5;
  _os_log_fault_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_FAULT,  "Unable to format: pid %d doesn't exist",  v4,  8u);
  sub_100051474();
}

void sub_100092A8C(uint64_t a1, void *a2)
{
  unsigned int v5 = sub_100072130(a1, a2);
  *(_DWORD *)os_log_type_t v4 = 67109120;
  *os_log_t v3 = v5;
  _os_log_debug_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEBUG, "pid %d doesn't exist", v4, 8u);
  sub_100051474();
}

void sub_100092ADC()
{
}

void sub_100092B40()
{
}

void sub_100092BA4()
{
}

void sub_100092BD0()
{
}

void sub_100092BFC()
{
}

void sub_100092C28()
{
  v2[0] = 136315394;
  sub_10007215C();
  sub_10004AF1C( (void *)&_mh_execute_header,  v0,  v1,  "Unable to format: %s: Still have %d clients sampling when dealloc'ed",  (uint8_t *)v2);
  sub_10002EE70();
}

void sub_100092C98()
{
  v2[0] = 136315394;
  sub_10007215C();
  sub_10004AF10( (void *)&_mh_execute_header,  v0,  v1,  "%s: Still have %d clients sampling when dealloc'ed",  (uint8_t *)v2);
  sub_10002EE70();
}

void sub_100092D08(uint64_t a1, _DWORD *a2, int a3)
{
  *a2 = 136315650;
  sub_100072110(a1, (uint64_t)a2, a3);
  sub_100072170( (void *)&_mh_execute_header,  v5,  v3,  "Unable to format: %s: Unable to create sampling thread: %d (%s)",  v4);
}

void sub_100092D50(uint64_t a1, _DWORD *a2, int a3)
{
  *a2 = 136315650;
  sub_100072110(a1, (uint64_t)a2, a3);
  sub_10007219C((void *)&_mh_execute_header, v5, v3, "%s: Unable to create sampling thread: %d (%s)", v4);
}

void sub_100092D98()
{
}

void sub_100092DC4()
{
}

void sub_100092DF0()
{
}

void sub_100092E1C()
{
}

void sub_100092E48(_DWORD *a1, uint64_t a2)
{
  *a1 = 136315394;
  sub_100072188((uint64_t)a1, a2, (uint64_t)"stackshotData.length < 4294967295U");
  sub_100072100((void *)&_mh_execute_header, v2, v3, "Unable to format: %s: bad stackshot data length %lu", v4);
}

void sub_100092E88(_DWORD *a1, uint64_t a2)
{
  *a1 = 136315394;
  sub_100072188((uint64_t)a1, a2, (uint64_t)"stackshotData.length < 4294967295U");
  _os_log_error_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_ERROR, "%s: bad stackshot data length %lu", v3, 0x16u);
}

void sub_100092ED4(_BYTE *a1, _BYTE *a2)
{
}

void sub_100092F00(_BYTE *a1, _BYTE *a2)
{
}

void sub_100092F2C()
{
}

void sub_100092F58()
{
}

void sub_100092F84()
{
}

void sub_100092FB0()
{
}

void sub_100092FDC()
{
}

void sub_100093008()
{
}

void sub_100093034()
{
}

void sub_100093060()
{
}

void sub_10009308C()
{
}

void sub_1000930B8()
{
}

void sub_1000930E4()
{
}

void sub_100093110(uint64_t a1, uint64_t a2, uint64_t a3, os_log_s *a4)
{
  *(_DWORD *)a2 = 138412546;
  *(void *)(a2 + 4) = a1;
  *(_WORD *)(a2 + 12) = 1024;
  *(_DWORD *)(a2 + 14) = a3;
  sub_10004AF1C( (void *)&_mh_execute_header,  a4,  a3,  "Unable to format: No one's sampling when requested to adjust sampling target to %@ %d",  (uint8_t *)a2);
}

void sub_10009315C(uint64_t a1, char a2, uint64_t a3, os_log_s *a4)
{
  *(_DWORD *)a3 = 138543618;
  *(void *)(a3 + 4) = a1;
  *(_WORD *)(a3 + 12) = 1024;
  *(_DWORD *)(a3 + 14) = a2 & 1;
  sub_10004AF10( (void *)&_mh_execute_header,  a4,  a3,  "No one's sampling when requested to adjust sampling target to %{public}@ %d",  (uint8_t *)a3);
}

void sub_1000931AC()
{
}

void sub_1000931D8()
{
}

void sub_100093204(uint64_t a1, uint64_t a2, os_log_s *a3)
{
  *(_DWORD *)a2 = 136315138;
  *(void *)(a2 + 4) = a1;
  sub_10003C438( (void *)&_mh_execute_header,  a3,  (uint64_t)a3,  "Unable to format: Changing to sampling %s also",  (uint8_t *)a2);
}

void sub_100093240()
{
}

void sub_10009326C()
{
}

void sub_100093298(uint64_t a1, uint64_t a2, os_log_s *a3)
{
  *(_DWORD *)a2 = 136315138;
  *(void *)(a2 + 4) = a1;
  sub_10003C438((void *)&_mh_execute_header, a3, (uint64_t)a3, "Unable to format: Sampling only %s", (uint8_t *)a2);
}

void sub_1000932D4()
{
}

void sub_100093300()
{
}

void sub_100093330()
{
}

void sub_10009335C()
{
}

void sub_10009338C()
{
}

void sub_1000933F0()
{
}

void sub_100093464()
{
}

void sub_1000934D8()
{
}

void sub_100093504()
{
}

void sub_100093530()
{
}

void sub_10009355C()
{
}

void sub_100093588()
{
}

void sub_1000935B4()
{
}

void sub_1000935E0(uint64_t a1, os_log_s *a2)
{
  uint64_t v3 = __error();
  strerror(*v3);
  sub_1000463B8();
  sub_100072170( (void *)&_mh_execute_header,  a2,  v4,  "Unable to format: Unable to open %s to save stackshots: %d (%s)",  v5);
  sub_1000461CC();
}

void sub_10009366C(uint64_t a1, os_log_s *a2)
{
  uint64_t v3 = __error();
  strerror(*v3);
  sub_1000463B8();
  sub_10007219C((void *)&_mh_execute_header, a2, v4, "Unable to open %s to save stackshots: %d (%s)", v5);
  sub_1000461CC();
}

void sub_1000936F8(uint64_t a1, os_log_s *a2, uint64_t a3)
{
  int v3 = 136315138;
  uint64_t v4 = a1;
  sub_10003C438((void *)&_mh_execute_header, a2, a3, "Unable to format: Saving stackshots to %s", (uint8_t *)&v3);
  sub_10002EE70();
}

void sub_100093760()
{
}

void sub_1000937C4()
{
}

void sub_100093828(_BYTE *a1, _BYTE *a2)
{
}

void sub_100093854(_BYTE *a1, _BYTE *a2)
{
}

void sub_100093880()
{
}

void sub_1000938AC()
{
}

void sub_1000938DC()
{
}

void sub_10009393C()
{
}

void sub_1000939A8()
{
}

void sub_100093A08()
{
}

void sub_100093A78(os_log_t log)
{
  *(_WORD *)os_log_t v1 = 0;
  _os_log_fault_impl( (void *)&_mh_execute_header,  log,  OS_LOG_TYPE_FAULT,  "Unable to format: Avoiding inspecting live processes for tailspin file due to audio running",  v1,  2u);
}

void sub_100093AB8()
{
}

void sub_100093B18()
{
}

void sub_100093B84()
{
}

void sub_100093BE4()
{
}

void sub_100093C54(void *a1, uint64_t a2, os_log_s *a3)
{
  v5[0] = 136315650;
  sub_10007FB38();
  sub_10007FB2C( (void *)&_mh_execute_header,  a3,  v4,  "Unable to format: %s: bodies (%s) and angle bracket contents (%s)",  (uint8_t *)v5);
  sub_1000461CC();
}

void sub_100093CE8(void *a1)
{
}

void sub_100093D74(os_log_t log)
{
  int v1 = 136315138;
  uint64_t v2 = "bodies || angleBracketContents || stateInfo";
  _os_log_fault_impl( (void *)&_mh_execute_header,  log,  OS_LOG_TYPE_FAULT,  "Unable to format: %s: No frame bodies, state, nor angle bracket contents",  (uint8_t *)&v1,  0xCu);
  sub_10002EE70();
}

void sub_100093DF0(os_log_t log)
{
  int v1 = 136315138;
  uint64_t v2 = "bodies || angleBracketContents || stateInfo";
  _os_log_error_impl( (void *)&_mh_execute_header,  log,  OS_LOG_TYPE_ERROR,  "%s: No frame bodies, state, nor angle bracket contents",  (uint8_t *)&v1,  0xCu);
  sub_10002EE70();
}

void sub_100093E6C()
{
  os_log_t v0 = __error();
  sub_100046448(v0);
  sub_1000463B8();
  sub_100046210((void *)&_mh_execute_header, v1, v2, "Unable to format: Unable to open %s: %d (%s)", v3, v4, v5, v6, v7);
  sub_1000461CC();
}

void sub_100093EEC()
{
  os_log_t v0 = __error();
  sub_100046448(v0);
  sub_1000463B8();
  sub_100046464((void *)&_mh_execute_header, v1, v2, "Unable to open %s: %d (%s)", v3, v4, v5, v6, v7);
  sub_1000461CC();
}

void sub_100093F6C()
{
}

void sub_100093F98()
{
}

void sub_100093FC4()
{
}

void sub_100093FF0()
{
}

void sub_10009401C()
{
  _DWORD *v0 = 136315650;
  sub_10007FB54(v1, (uint64_t)v0, v2);
  sub_10007FB2C((void *)&_mh_execute_header, v5, v3, "Unable to format: %s: Unable to compile regex %s: %s", v4);
}

void sub_100094060()
{
  _DWORD *v0 = 136315650;
  sub_10007FB54(v1, (uint64_t)v0, v2);
  _os_log_error_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_ERROR,  "%s: Unable to compile regex %s: %s",  v3,  0x20u);
}

void sub_1000940AC(uint64_t a1, _DWORD *a2)
{
  *a2 = 136315394;
  sub_10007FAB4(a1, (uint64_t)a2, (uint64_t)"regex");
  sub_100072100((void *)&_mh_execute_header, v2, v3, "Unable to format: %s: Unable to compile regex %s", v4);
}

void sub_1000940EC(uint64_t a1, _DWORD *a2)
{
  *a2 = 136315394;
  sub_10007FAB4(a1, (uint64_t)a2, (uint64_t)"regex");
  sub_10007FAFC((void *)&_mh_execute_header, v2, v3, "%s: Unable to compile regex %s", v4);
}

void sub_10009412C()
{
}

void sub_100094158()
{
}

void sub_100094184(uint64_t a1, _DWORD *a2)
{
  *a2 = 136315394;
  sub_10007FAB4(a1, (uint64_t)a2, (uint64_t)"heaviestNode.angleBracketContents || heaviestNode.stateInfo");
  sub_100072100( (void *)&_mh_execute_header,  v2,  v3,  "Unable to format: %s: No angle bracket contents nor state info for non-frame (%s)",  v4);
}

void sub_1000941C4(uint64_t a1, _DWORD *a2)
{
  *a2 = 136315394;
  sub_10007FAB4(a1, (uint64_t)a2, (uint64_t)"heaviestNode.angleBracketContents || heaviestNode.stateInfo");
  sub_10007FAFC( (void *)&_mh_execute_header,  v2,  v3,  "%s: No angle bracket contents nor state info for non-frame (%s)",  v4);
}

void sub_100094204()
{
  _DWORD *v0 = 136315650;
  sub_100072110(v1, (uint64_t)v0, v2);
  sub_100072170( (void *)&_mh_execute_header,  v5,  v3,  "Unable to format: %s: Non-frame line has count but no indent level (%d: %s)",  v4);
}

void sub_100094248()
{
  _DWORD *v0 = 136315650;
  sub_100072110(v1, (uint64_t)v0, v2);
  sub_10007219C((void *)&_mh_execute_header, v5, v3, "%s: Non-frame line has count but no indent level (%d: %s)", v4);
}

void sub_10009428C()
{
  _DWORD *v0 = 136315650;
  sub_100072110(v1, (uint64_t)v0, v2);
  sub_100072170((void *)&_mh_execute_header, v5, v3, "Unable to format: %s: frame match with no count (%d: %s)", v4);
}

void sub_1000942D0()
{
  _DWORD *v0 = 136315650;
  sub_100072110(v1, (uint64_t)v0, v2);
  sub_10007219C((void *)&_mh_execute_header, v5, v3, "%s: frame match with no count (%d: %s)", v4);
}

void sub_100094314()
{
  _DWORD *v0 = 136315650;
  sub_100072110(v1, (uint64_t)v0, v2);
  sub_100072170( (void *)&_mh_execute_header,  v5,  v3,  "Unable to format: %s: frame match with no count and whitespace (%d: %s)",  v4);
}

void sub_100094358()
{
  _DWORD *v0 = 136315650;
  sub_100072110(v1, (uint64_t)v0, v2);
  sub_10007219C((void *)&_mh_execute_header, v5, v3, "%s: frame match with no count and whitespace (%d: %s)", v4);
}

void sub_10009439C()
{
}

void sub_1000943C8()
{
}

void sub_1000943F4()
{
}

void sub_100094420()
{
}

void sub_10009444C()
{
}

void sub_100094478()
{
}

void sub_1000944A4()
{
}

void sub_1000944D0()
{
}

void sub_1000944FC()
{
}

void sub_100094534()
{
}

void sub_10009456C()
{
}

void sub_100094598()
{
}

void sub_1000945D0()
{
  v2[0] = 136315394;
  sub_10007215C();
  sub_10004AF1C( (void *)&_mh_execute_header,  v0,  v1,  "Unable to format: %s: Unable to allocate %d buffer",  (uint8_t *)v2);
  sub_10002EE70();
}

void sub_100094640()
{
  v2[0] = 136315394;
  sub_10007215C();
  sub_10004AF10((void *)&_mh_execute_header, v0, v1, "%s: Unable to allocate %d buffer", (uint8_t *)v2);
  sub_10002EE70();
}

void sub_1000946B0()
{
  v2[0] = 136315394;
  sub_10007215C();
  sub_10004AF1C((void *)&_mh_execute_header, v0, v1, "Unable to format: %s: bufSize overflow (%d)", (uint8_t *)v2);
  sub_10002EE70();
}

void sub_100094720()
{
  v2[0] = 136315394;
  sub_10007215C();
  sub_10004AF10((void *)&_mh_execute_header, v0, v1, "%s: bufSize overflow (%d)", (uint8_t *)v2);
  sub_10002EE70();
}

void sub_100094790()
{
}

void sub_100094804()
{
}

void sub_100094878()
{
  sub_100046210( (void *)&_mh_execute_header,  v1,  v2,  "Unable to format: %s: frame regex returned binary but no offset into binary (%d: %s)",  v3,  v4,  v5,  v6,  2u);
  sub_10006BAE4();
}

void sub_1000948EC()
{
  sub_100046464( (void *)&_mh_execute_header,  v1,  v2,  "%s: frame regex returned binary but no offset into binary (%d: %s)",  v3,  v4,  v5,  v6,  2u);
  sub_10006BAE4();
}

void sub_100094960()
{
  sub_100046210( (void *)&_mh_execute_header,  v1,  v2,  "Unable to format: %s: frame regex returned binary but no offset into binary (%d: %s)",  v3,  v4,  v5,  v6,  2u);
  sub_10006BAE4();
}

void sub_1000949D4()
{
}

void sub_100094A3C()
{
}

void sub_100094AA4()
{
}

void sub_100094B18()
{
}

void sub_100094B8C()
{
}

void sub_100094C00()
{
  os_log_t v0 = __error();
  strerror(*v0);
  sub_10007FA94();
  sub_100046210((void *)&_mh_execute_header, v1, v2, "Unable to format: %s: ftello failed: %d (%s)", v3, v4, v5, v6, 2u);
  sub_10006BAE4();
}

void sub_100094C8C()
{
  os_log_t v0 = __error();
  sub_100046448(v0);
  sub_10007FA94();
  sub_100046464((void *)&_mh_execute_header, v1, v2, "%s: ftello failed: %d (%s)", v3, v4, v5, v6, 2u);
  sub_10006BAE4();
}

void sub_100094D10()
{
}

void sub_100094D78()
{
}

void sub_100094DE0()
{
}

void sub_100094E48()
{
}

void sub_100094EBC()
{
}

void sub_100094F30()
{
}

void sub_100094FA4()
{
}

void sub_100095018()
{
}

void sub_10009508C()
{
}

void sub_100095100(void *a1, os_log_s *a2)
{
  id v4 = [a1 uuid];
  id v5 = [a1 path];
  if (!v5) {
    id v5 = [a1 name];
  }
  int v6 = 138412546;
  id v7 = v4;
  __int16 v8 = 2112;
  id v9 = v5;
  _os_log_fault_impl( (void *)&_mh_execute_header,  a2,  OS_LOG_TYPE_FAULT,  "Unable to format: Parsing spindump text: Unable to find symbol owner for %@ %@",  (uint8_t *)&v6,  0x16u);
}

void sub_1000951B8(uint64_t a1, id *a2, os_log_s *a3)
{
}

void sub_100095238(uint64_t a1, id *a2)
{
}

void sub_1000952B0()
{
}

void sub_100095324()
{
}

id objc_msgSend_addMicrostackshotsFromData_ofTypes_inTimeRangeStart_end_onlyPid_onlyTid_statistics_( void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "addMicrostackshotsFromData:ofTypes:inTimeRangeStart:end:onlyPid:onlyTid:statistics:");
}

id objc_msgSend_enumerateTaskStatesBetweenStartTime_startSampleIndex_endTime_endSampleIndex_reverseOrder_block_( void *a1, const char *a2, ...)
{
  return objc_msgSend( a1,  "enumerateTaskStatesBetweenStartTime:startSampleIndex:endTime:endSampleIndex:reverseOrder:block:");
}

id objc_msgSend_enumerateThreadStatesBetweenStartTime_startSampleIndex_endTime_endSampleIndex_reverseOrder_block_( void *a1, const char *a2, ...)
{
  return objc_msgSend( a1,  "enumerateThreadStatesBetweenStartTime:startSampleIndex:endTime:endSampleIndex:reverseOrder:block:");
}

id objc_msgSend_initWithReportReason_reportedSignpostTracker_task_timeRange_thread_dispatchQueue_( void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "initWithReportReason:reportedSignpostTracker:task:timeRange:thread:dispatchQueue:");
}

id objc_msgSend_initWithStackshotProvider_timestamp_numSamples_numSamplesAvoidedDueToAudio_( void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "initWithStackshotProvider:timestamp:numSamples:numSamplesAvoidedDueToAudio:");
}

id objc_msgSend_snapshotWithSamplingIntervalUs_andOccasionalDataIntervalSec_andOnlySampleProcesses_andOnlySampleMainThreads_andOmitSensitiveStrings_( void *a1, const char *a2, ...)
{
  return objc_msgSend( a1,  "snapshotWithSamplingIntervalUs:andOccasionalDataIntervalSec:andOnlySampleProcesses:andOnlySampleMainThreads:a ndOmitSensitiveStrings:");
}

id objc_msgSend_startWithSamplingIntervalUs_andOccasionalDataIntervalSec_andOnlySampleProcesses_andOnlySampleMainThreads_andOmitSensitiveStrings_( void *a1, const char *a2, ...)
{
  return objc_msgSend( a1,  "startWithSamplingIntervalUs:andOccasionalDataIntervalSec:andOnlySampleProcesses:andOnlySampleMainThreads:andO mitSensitiveStrings:");
}

id objc_msgSend_stopAndWaitForAllSamplingToComplete_withCompletionCallbackOnQueue_withBlock_( void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "stopAndWaitForAllSamplingToComplete:withCompletionCallbackOnQueue:withBlock:");
}

id objc_msgSend_timestampWithMachAbsTime_machAbsTimeSec_machContTime_machContTimeSec_wallTime_( void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "timestampWithMachAbsTime:machAbsTimeSec:machContTime:machContTimeSec:wallTime:");
}