uint64_t NANGenericServiceProtocol.encryptedSignature.setter(uint64_t a1, unint64_t a2)
{
  sub_10006E050(a1, a2);
  return sub_100020B40(a1, a2);
}

void (*NANGenericServiceProtocol.encryptedSignature.modify(uint64_t *a1))(uint64_t *a1, char a2)
{
  a1[2] = (uint64_t)v1;
  uint64_t v3 = type metadata accessor for NANAttribute.CustomDeviceInformation.CustomAttributes(0LL);
  v4 = (char *)malloc(*(void *)(*(void *)(v3 - 8) + 64LL));
  a1[3] = (uint64_t)v4;
  sub_1000667B0(*v1, (uint64_t)v4);
  v5 = (uint64_t *)&v4[*(int *)(v3 + 32)];
  uint64_t v6 = *v5;
  unint64_t v7 = v5[1];
  sub_10002255C(*v5, v7);
  sub_10005802C((uint64_t)v4, type metadata accessor for NANAttribute.CustomDeviceInformation.CustomAttributes);
  *a1 = v6;
  a1[1] = v7;
  return sub_100067924;
}

void sub_100067924(uint64_t *a1, char a2)
{
}

uint64_t NANGenericServiceProtocol.encryptedExtraServiceSpecificInfo.getter(uint64_t a1)
{
  uint64_t v2 = type metadata accessor for NANAttribute.CustomDeviceInformation.CustomAttributes(0LL);
  __chkstk_darwin(v2);
  v4 = (char *)&v8 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  sub_1000667B0(a1, (uint64_t)v4);
  v5 = &v4[*(int *)(v2 + 36)];
  uint64_t v6 = *(void *)v5;
  sub_10002255C(*(void *)v5, *((void *)v5 + 1));
  sub_10005802C((uint64_t)v4, type metadata accessor for NANAttribute.CustomDeviceInformation.CustomAttributes);
  return v6;
}

uint64_t NANGenericServiceProtocol.encryptedExtraServiceSpecificInfo.setter(uint64_t a1, unint64_t a2)
{
  return sub_100020B40(a1, a2);
}

void (*NANGenericServiceProtocol.encryptedExtraServiceSpecificInfo.modify( uint64_t *a1))(uint64_t *a1, char a2)
{
  a1[2] = (uint64_t)v1;
  uint64_t v3 = type metadata accessor for NANAttribute.CustomDeviceInformation.CustomAttributes(0LL);
  v4 = (char *)malloc(*(void *)(*(void *)(v3 - 8) + 64LL));
  a1[3] = (uint64_t)v4;
  sub_1000667B0(*v1, (uint64_t)v4);
  v5 = (uint64_t *)&v4[*(int *)(v3 + 36)];
  uint64_t v6 = *v5;
  unint64_t v7 = v5[1];
  sub_10002255C(*v5, v7);
  sub_10005802C((uint64_t)v4, type metadata accessor for NANAttribute.CustomDeviceInformation.CustomAttributes);
  *a1 = v6;
  a1[1] = v7;
  return sub_100067A9C;
}

void sub_100067A9C(uint64_t *a1, char a2)
{
}

void sub_100067AA8(uint64_t *a1, char a2, void (*a3)(uint64_t, unint64_t))
{
  uint64_t v4 = *a1;
  unint64_t v5 = a1[1];
  uint64_t v6 = (void *)a1[3];
  uint64_t v7 = *a1;
  if ((a2 & 1) != 0)
  {
    sub_10002255C(v7, v5);
    a3(v4, v5);
    sub_100020B40(v4, v5);
  }

  else
  {
    a3(v7, v5);
  }

  sub_100020B40(v4, v5);
  free(v6);
}

unint64_t NANGenericServiceProtocol.vendorSpecificData.getter(uint64_t a1)
{
  uint64_t v2 = type metadata accessor for NANGenericServiceProtocol.Attribute(0LL);
  uint64_t v3 = *(void *)(v2 - 8);
  __chkstk_darwin();
  unint64_t v5 = (unsigned __int16 *)((char *)&v13 - ((v4 + 15) & 0xFFFFFFFFFFFFFFF0LL));
  __chkstk_darwin();
  uint64_t v7 = (char *)&v13 - v6;
  __chkstk_darwin();
  v9 = (char *)&v13 - v8;
  if (*(void *)(a1 + 16))
  {
    unint64_t v10 = sub_10001C01C(7);
    if ((v11 & 1) != 0)
    {
      sub_100057FE8( *(void *)(a1 + 56) + *(void *)(v3 + 72) * v10,  (uint64_t)v7,  type metadata accessor for NANGenericServiceProtocol.Attribute);
      sub_100022628((uint64_t)v7, (uint64_t)v9, type metadata accessor for NANGenericServiceProtocol.Attribute);
      sub_100022628((uint64_t)v9, (uint64_t)v5, type metadata accessor for NANGenericServiceProtocol.Attribute);
      sub_10005802C((uint64_t)v5, type metadata accessor for NANGenericServiceProtocol.Attribute);
    }
  }

  return 0LL;
}

uint64_t NANGenericServiceProtocol.description.getter(uint64_t a1)
{
  uint64_t v57 = sub_100002274(&qword_100406238);
  uint64_t v2 = __chkstk_darwin(v57);
  v56 = (char *)&v48 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v4 = __chkstk_darwin(v2);
  uint64_t v55 = (uint64_t)&v48 - v5;
  uint64_t v6 = __chkstk_darwin(v4);
  v54 = (char *)&v48 - v7;
  __chkstk_darwin(v6);
  v53 = (char *)&v48 - v8;
  int64_t v9 = *(void *)(a1 + 16);
  unint64_t v10 = _swiftEmptyArrayStorage;
  if (v9)
  {
    v59 = _swiftEmptyArrayStorage;
    swift_bridgeObjectRetain(a1);
    sub_1000696B4(0, v9, 0);
    uint64_t result = sub_1000204CC(a1);
    uint64_t v13 = result;
    uint64_t v14 = 0LL;
    uint64_t v15 = a1 + 64;
    char v17 = v16 & 1;
    uint64_t v48 = a1 + 80;
    int64_t v49 = v9;
    uint64_t v51 = a1 + 64;
    uint64_t v52 = a1;
    uint64_t v50 = v12;
    while ((v17 & 1) == 0)
    {
      if (v13 < 0 || v13 >= 1LL << *(_BYTE *)(a1 + 32))
      {
        __break(1u);
LABEL_27:
        __break(1u);
LABEL_28:
        __break(1u);
LABEL_29:
        __break(1u);
LABEL_30:
        __break(1u);
LABEL_31:
        __break(1u);
        break;
      }

      unint64_t v21 = (unint64_t)v13 >> 6;
      if (*(_DWORD *)(a1 + 36) != (_DWORD)v12) {
        goto LABEL_28;
      }
      uint64_t v58 = v14;
      uint64_t v22 = v57;
      v23 = v53;
      uint64_t v24 = (uint64_t)&v53[*(int *)(v57 + 48)];
      uint64_t v25 = *(void *)(a1 + 48);
      uint64_t v26 = *(void *)(a1 + 56);
      char v27 = *(_BYTE *)(v25 + v13);
      uint64_t v28 = type metadata accessor for NANGenericServiceProtocol.Attribute(0LL);
      sub_100057FE8( v26 + *(void *)(*(void *)(v28 - 8) + 72LL) * v13,  v24,  type metadata accessor for NANGenericServiceProtocol.Attribute);
      _BYTE *v23 = v27;
      v29 = v54;
      _BYTE *v54 = v27;
      sub_100057FE8( v24,  (uint64_t)&v29[*(int *)(v22 + 48)],  type metadata accessor for NANGenericServiceProtocol.Attribute);
      uint64_t v30 = (uint64_t)v29;
      uint64_t v31 = v55;
      sub_1000586C0(v30, v55, &qword_100406238);
      sub_1000225EC((uint64_t)v23, &qword_100406238);
      uint64_t v32 = *(int *)(v22 + 48);
      v33 = &v56[v32];
      sub_100057FE8(v31 + v32, (uint64_t)&v56[v32], type metadata accessor for NANGenericServiceProtocol.Attribute);
      uint64_t v34 = String.init<A>(describing:)(v33, v28);
      uint64_t v36 = v35;
      sub_1000225EC(v31, &qword_100406238);
      unint64_t v10 = v59;
      uint64_t result = swift_isUniquelyReferenced_nonNull_native(v59);
      if ((result & 1) == 0)
      {
        uint64_t result = sub_1000696B4(0, v10[2] + 1LL, 1);
        unint64_t v10 = v59;
      }

      unint64_t v38 = v10[2];
      unint64_t v37 = v10[3];
      if (v38 >= v37 >> 1)
      {
        uint64_t result = sub_1000696B4(v37 > 1, v38 + 1, 1);
        unint64_t v10 = v59;
      }

      v10[2] = v38 + 1;
      v39 = &v10[2 * v38];
      v39[4] = v34;
      v39[5] = v36;
      a1 = v52;
      int64_t v18 = 1LL << *(_BYTE *)(v52 + 32);
      if (v13 >= v18) {
        goto LABEL_29;
      }
      uint64_t v15 = v51;
      uint64_t v40 = *(void *)(v51 + 8 * v21);
      if ((v40 & (1LL << v13)) == 0) {
        goto LABEL_30;
      }
      LODWORD(v12) = v50;
      if (*(_DWORD *)(v52 + 36) != (_DWORD)v50) {
        goto LABEL_31;
      }
      unint64_t v41 = v40 & (-2LL << (v13 & 0x3F));
      if (v41)
      {
        int64_t v18 = __clz(__rbit64(v41)) | v13 & 0xFFFFFFFFFFFFFFC0LL;
        int64_t v19 = v49;
        uint64_t v20 = v58;
      }

      else
      {
        unint64_t v42 = v21 + 1;
        unint64_t v43 = (unint64_t)(v18 + 63) >> 6;
        int64_t v19 = v49;
        uint64_t v20 = v58;
        if (v21 + 1 < v43)
        {
          unint64_t v44 = *(void *)(v51 + 8 * v42);
          if (v44)
          {
LABEL_23:
            int64_t v18 = __clz(__rbit64(v44)) + (v42 << 6);
          }

          else
          {
            while (v43 - 2 != v21)
            {
              unint64_t v44 = *(void *)(v48 + 8 * v21++);
              if (v44)
              {
                unint64_t v42 = v21 + 1;
                goto LABEL_23;
              }
            }
          }
        }
      }

      char v17 = 0;
      uint64_t v14 = v20 + 1;
      uint64_t v13 = v18;
      if (v14 == v19)
      {
        swift_bridgeObjectRelease(v52);
        goto LABEL_25;
      }
    }

    __break(1u);
  }

  else
  {
LABEL_25:
    v59 = v10;
    uint64_t v45 = sub_100002274((uint64_t *)&unk_100410510);
    uint64_t v46 = sub_1000572E4(&qword_10040FEE0, (uint64_t *)&unk_100410510, (uint64_t)&protocol conformance descriptor for [A]);
    uint64_t v47 = BidirectionalCollection<>.joined(separator:)(8236LL, 0xE200000000000000LL, v45, v46);
    swift_bridgeObjectRelease(v10);
    return v47;
  }

  return result;
}

uint64_t NANGenericServiceProtocol.customMirror.getter(uint64_t a1)
{
  v3[3] = sub_100002274(&qword_100406240);
  v3[0] = a1;
  swift_bridgeObjectRetain(a1);
  return Mirror.init(reflecting:)(v3);
}

uint64_t NANGenericServiceProtocol.hash(into:)(__int128 *a1, uint64_t a2)
{
  return swift_bridgeObjectRelease(a2);
}

uint64_t sub_1000680E4(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = type metadata accessor for NANGenericServiceProtocol.Attribute(0LL);
  uint64_t v46 = *(void *)(v4 - 8);
  uint64_t v5 = __chkstk_darwin(v4);
  uint64_t v7 = (char *)&v41 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  __chkstk_darwin(v5);
  int64_t v9 = (char *)&v41 - v8;
  uint64_t v10 = sub_100002274(&qword_1004064B8);
  uint64_t v11 = __chkstk_darwin(v10);
  uint64_t v13 = (char *)&v41 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t result = __chkstk_darwin(v11);
  char v16 = (char *)&v41 - v15;
  if (a1 == a2) {
    return 1LL;
  }
  if (*(void *)(a1 + 16) != *(void *)(a2 + 16)) {
    return 0LL;
  }
  uint64_t v44 = a1;
  int64_t v45 = 0LL;
  uint64_t v19 = *(void *)(a1 + 64);
  uint64_t v18 = a1 + 64;
  uint64_t v17 = v19;
  uint64_t v20 = 1LL << *(_BYTE *)(v18 - 32);
  uint64_t v21 = -1LL;
  if (v20 < 64) {
    uint64_t v21 = ~(-1LL << v20);
  }
  unint64_t v22 = v21 & v17;
  uint64_t v42 = v18;
  int64_t v43 = (unint64_t)(v20 + 63) >> 6;
  int64_t v41 = v43 - 1;
  while (1)
  {
    if (v22)
    {
      unint64_t v23 = __clz(__rbit64(v22));
      v22 &= v22 - 1;
      unint64_t v24 = v23 | (v45 << 6);
LABEL_8:
      char v25 = *(_BYTE *)(*(void *)(v44 + 48) + v24);
      uint64_t v26 = *(void *)(v44 + 56) + *(void *)(v46 + 72) * v24;
      uint64_t v27 = sub_100002274(&qword_100406238);
      sub_100057FE8( v26,  (uint64_t)&v13[*(int *)(v27 + 48)],  type metadata accessor for NANGenericServiceProtocol.Attribute);
      *uint64_t v13 = v25;
      (*(void (**)(_BYTE *, void, uint64_t, uint64_t))(*(void *)(v27 - 8) + 56LL))(v13, 0LL, 1LL, v27);
      goto LABEL_27;
    }

    int64_t v28 = v45 + 1;
    if (__OFADD__(v45, 1LL))
    {
      __break(1u);
      goto LABEL_36;
    }

    if (v28 < v43)
    {
      unint64_t v29 = *(void *)(v42 + 8 * v28);
      if (v29) {
        goto LABEL_12;
      }
      int64_t v30 = v45 + 2;
      ++v45;
      if (v28 + 1 < v43)
      {
        unint64_t v29 = *(void *)(v42 + 8 * v30);
        if (v29) {
          goto LABEL_15;
        }
        int64_t v45 = v28 + 1;
        if (v28 + 2 < v43)
        {
          unint64_t v29 = *(void *)(v42 + 8 * (v28 + 2));
          if (v29)
          {
            v28 += 2LL;
            goto LABEL_12;
          }

          int64_t v30 = v28 + 3;
          int64_t v45 = v28 + 2;
          if (v28 + 3 < v43) {
            break;
          }
        }
      }
    }

uint64_t sub_1000684A0(uint64_t a1, uint64_t a2)
{
  uint64_t v56 = type metadata accessor for NANInternetSharingStatistics.Requester(0LL);
  uint64_t v4 = *(void *)(v56 - 8);
  uint64_t v5 = __chkstk_darwin(v56);
  uint64_t v7 = (char *)&v49 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  __chkstk_darwin(v5);
  int64_t v9 = (char *)&v49 - v8;
  uint64_t v10 = sub_100002274(&qword_1004063D0);
  uint64_t v11 = __chkstk_darwin(v10);
  uint64_t v13 = (char *)&v49 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t result = __chkstk_darwin(v11);
  uint64_t v58 = (unsigned __int16 *)((char *)&v49 - v15);
  if (a1 == a2) {
    return 1LL;
  }
  if (*(void *)(a1 + 16) != *(void *)(a2 + 16)) {
    return 0LL;
  }
  int64_t v57 = 0LL;
  uint64_t v53 = a1;
  uint64_t v54 = v4;
  uint64_t v18 = *(void *)(a1 + 64);
  uint64_t v17 = a1 + 64;
  uint64_t v16 = v18;
  uint64_t v19 = 1LL << *(_BYTE *)(v17 - 32);
  uint64_t v20 = -1LL;
  if (v19 < 64) {
    uint64_t v20 = ~(-1LL << v19);
  }
  unint64_t v21 = v20 & v16;
  uint64_t v50 = v17;
  int64_t v51 = (unint64_t)(v19 + 63) >> 6;
  int64_t v49 = v51 - 1;
  uint64_t v22 = (uint64_t)v7;
  uint64_t v52 = v7;
  uint64_t v55 = v9;
  while (1)
  {
    if (v21)
    {
      unint64_t v23 = __clz(__rbit64(v21));
      v21 &= v21 - 1;
      unint64_t v24 = v58;
      unint64_t v25 = v23 | (v57 << 6);
LABEL_8:
      uint64_t v26 = *(void *)(v53 + 48) - v25 + 8 * v25;
      __int16 v27 = *(_WORD *)(v26 + 4);
      char v28 = *(_BYTE *)(v26 + 6);
      uint64_t v29 = *(void *)(v53 + 56) + *(void *)(v4 + 72) * v25;
      uint64_t v30 = sub_100002274(&qword_1004063D8);
      LODWORD(v26) = *(_DWORD *)v26;
      sub_100057FE8( v29,  (uint64_t)&v13[*(int *)(v30 + 48)],  type metadata accessor for NANInternetSharingStatistics.Requester);
      *(_DWORD *)uint64_t v13 = v26;
      *((_WORD *)v13 + 2) = v27;
      v13[6] = v28;
      (*(void (**)(char *, void, uint64_t, uint64_t))(*(void *)(v30 - 8) + 56LL))(v13, 0LL, 1LL, v30);
      uint64_t v31 = (uint64_t)v52;
      goto LABEL_27;
    }

    unint64_t v24 = v58;
    int64_t v32 = v57 + 1;
    if (__OFADD__(v57, 1LL))
    {
      __break(1u);
      goto LABEL_38;
    }

    uint64_t v31 = v22;
    if (v32 < v51)
    {
      unint64_t v33 = *(void *)(v50 + 8 * v32);
      if (v33) {
        goto LABEL_12;
      }
      int64_t v34 = v57 + 2;
      ++v57;
      if (v32 + 1 < v51)
      {
        unint64_t v33 = *(void *)(v50 + 8 * v34);
        if (v33) {
          goto LABEL_15;
        }
        int64_t v57 = v32 + 1;
        if (v32 + 2 < v51)
        {
          unint64_t v33 = *(void *)(v50 + 8 * (v32 + 2));
          if (v33)
          {
            v32 += 2LL;
            goto LABEL_12;
          }

          int64_t v34 = v32 + 3;
          int64_t v57 = v32 + 2;
          if (v32 + 3 < v51) {
            break;
          }
        }
      }
    }

LABEL_38:
  __break(1u);
  return result;
}

  __break(1u);
  return result;
}

  __break(1u);
  return result;
}

  swift_release(v6);
  uint64_t v2 = v39;
  int v37 = 1LL << *(_BYTE *)(v6 + 32);
  if (v37 > 63) {
    bzero(v41, ((unint64_t)(v37 + 63) >> 3) & 0x1FFFFFFFFFFFFFF8LL);
  }
  else {
    *uint64_t v41 = -1LL << v37;
  }
  *(void *)(v6 + 16) = 0LL;
LABEL_42:
  swift_release(v6);
  *uint64_t v2 = v8;
}

  uint64_t v54 = v121.i64[1];
  if (v121.i64[1])
  {
    uint64_t v55 = v121.i64[0];
    swift_bridgeObjectRetain(v121.i64[1]);
    if ((swift_isUniquelyReferenced_nonNull_native(v40) & 1) == 0) {
      uint64_t v40 = sub_1000A60A0(0LL, v40[2] + 1LL, 1, v40);
    }
    int64_t v57 = v40[2];
    uint64_t v56 = v40[3];
    if (v57 >= v56 >> 1) {
      uint64_t v40 = sub_1000A60A0((void *)(v56 > 1), v57 + 1, 1, v40);
    }
    v40[2] = v57 + 1;
    uint64_t v58 = &v40[2 * v57];
    v58[4] = v55;
    v58[5] = v54;
  }

  v59 = v117;
  v60 = sub_100002274(&qword_10040AB68);
  swift_arrayDestroy(v118, v59, v60);
  v116[0] = v40;
  v61 = sub_100002274((uint64_t *)&unk_100410510);
  v62 = sub_1000572E4(&qword_10040FEE0, (uint64_t *)&unk_100410510, (uint64_t)&protocol conformance descriptor for [A]);
  v63 = BidirectionalCollection<>.joined(separator:)(8236LL, 0xE200000000000000LL, v61, v62);
  v65 = v64;
  swift_bridgeObjectRelease(v40);
  v139 = &type metadata for String;
  v137 = v63;
  v138 = v65;
  v66 = (uint64_t)v99;
  sub_1000226B0((uint64_t)&v44[v19[10]], (uint64_t)v99, qword_100410330);
  v67 = v101;
  if ((*(unsigned int (**)(uint64_t, uint64_t, uint64_t))(v45 + 48))(v66, 1LL, v101) == 1)
  {
    v141 = 0u;
    v142 = 0u;
    v140 = 0u;
  }

  else
  {
    v68 = v96;
    v69 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(v45 + 32))(v96, v66, v67);
    strcpy((char *)&v140, "keepAliveUUID");
    HIWORD(v140) = -4864;
    v70 = UUID.uuidString.getter(v69);
    *((void *)&v142 + 1) = &type metadata for String;
    *(void *)&v141 = v70;
    *((void *)&v141 + 1) = v71;
    (*(void (**)(char *, uint64_t))(v45 + 8))(v68, v67);
  }

  v72 = *(void *)&v44[v19[11]];
  if (*(void *)(v72 + 16))
  {
    v143 = 0xD00000000000001CLL;
    v144 = 0x80000001003670F0LL;
    v73 = sub_100002274(&qword_10040AB58);
    swift_bridgeObjectRetain(v72);
  }

  else
  {
    v72 = 0LL;
    v73 = 0LL;
    v143 = 0LL;
    v144 = 0LL;
    v147 = 0LL;
    v146 = 0LL;
  }

  v145 = v72;
  v148 = v73;
  v74 = (uint64_t)&v44[v19[12]];
  v75 = (uint64_t)v102;
  sub_1000226B0(v74, (uint64_t)v102, (uint64_t *)&unk_10040DCC0);
  v76 = v104;
  if ((*(unsigned int (**)(uint64_t, uint64_t, uint64_t))(v103 + 48))(v75, 1LL, v104) == 1)
  {
    v150 = 0u;
    v151 = 0u;
    v149 = 0u;
  }

  else
  {
    v77 = v75;
    v78 = v97;
    sub_100022628(v77, v97, type metadata accessor for NANInternetSharingStatistics.Requester);
    *(void *)&v149 = 0xD000000000000019LL;
    *((void *)&v149 + 1) = 0x8000000100367110LL;
    *((void *)&v151 + 1) = v76;
    v79 = sub_10002278C(&v150);
    sub_100022628(v78, (uint64_t)v79, type metadata accessor for NANInternetSharingStatistics.Requester);
  }

  v80 = _swiftEmptyArrayStorage;
  for (i = 32LL; i != 320; i += 48LL)
  {
    sub_1000226B0((uint64_t)&v122[i], (uint64_t)v116, &qword_10040AB70);
    sub_1000586C0((uint64_t)v116, (uint64_t)v115, &qword_10040AB70);
    if (*((void *)&v115[0] + 1))
    {
      v112 = v115[0];
      v113 = v115[1];
      v114 = v115[2];
      if ((swift_isUniquelyReferenced_nonNull_native(v80) & 1) == 0) {
        v80 = sub_1000A7834(0LL, v80[2] + 1LL, 1, v80);
      }
      v83 = v80[2];
      v82 = v80[3];
      if (v83 >= v82 >> 1) {
        v80 = sub_1000A7834((void *)(v82 > 1), v83 + 1, 1, v80);
      }
      v80[2] = v83 + 1;
      v84 = &v80[6 * v83];
      v85 = v112;
      v86 = v114;
      v84[3] = v113;
      v84[4] = v86;
      v84[2] = v85;
    }

    else
    {
      sub_1000225EC((uint64_t)v115, &qword_10040AB70);
    }
  }

  v87 = v123;
  v88 = sub_100002274(&qword_10040AB70);
  swift_arrayDestroy(v124, v87, v88);
  v89 = sub_1001A1288((uint64_t)v80);
  swift_bridgeObjectRelease(v80);
  v116[0] = v89;
  v90 = type metadata accessor for Mirror.DisplayStyle(0LL);
  v91 = v107;
  (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(*(void *)(v90 - 8) + 56LL))(v107, 1LL, 1LL, v90);
  v92 = v109;
  (*(void (**)(char *, void, uint64_t))(v106 + 104))( v109,  enum case for Mirror.AncestorRepresentation.generated(_:),  v108);
  v93 = sub_100002274(&qword_100405DC0);
  v94 = sub_1000572E4( (unint64_t *)&qword_10040C630,  &qword_100405DC0,  (uint64_t)&protocol conformance descriptor for [A]);
  return Mirror.init<A, B>(_:children:displayStyle:ancestorRepresentation:)(v105, v116, v91, v92, v111, v93, v94);
}

  __break(1u);
  return result;
}

  __break(1u);
  return result;
}

                  v104 = (v35 - 1) & v35;
                  v105 = v36;
                  uint64_t v13 = __clz(__rbit64(v35)) + (v36 << 6);
                }

                int v37 = *(void *)(*(void *)(v28 + 56) + 8 * v13);
                BOOL v38 = *(void *)(v37 + 16);
                if (v38)
                {
                  v103 = v34;
                  v107[0] = (uint64_t)_swiftEmptyArrayStorage;
                  swift_bridgeObjectRetain(v37);
                  sub_100267F94(0, v38, 0);
                  uint64_t v14 = (void *)v107[0];
                  v102 = v37;
                  uint64_t v39 = (void *)(v37 + 80);
                  do
                  {
                    uint64_t v40 = *(v39 - 6);
                    uint64_t v41 = *(v39 - 5);
                    uint64_t v43 = *(v39 - 4);
                    uint64_t v42 = *(v39 - 3);
                    unint64_t v44 = *((_BYTE *)v39 - 16);
                    v106 = *(v39 - 1);
                    char v45 = *v39;
                    swift_bridgeObjectRetain(v40);
                    sub_100058430(v41, v43, v42);
                    v107[0] = (uint64_t)v14;
                    int v47 = v14[2];
                    uint64_t v46 = v14[3];
                    if (v47 >= v46 >> 1)
                    {
                      sub_100267F94(v46 > 1, v47 + 1, 1);
                      uint64_t v14 = (void *)v107[0];
                    }

                    v14[2] = v47 + 1;
                    int v48 = &v14[7 * v47];
                    v48[4] = v40;
                    v48[5] = v41;
                    v48[6] = v43;
                    v48[7] = v42;
                    *((_BYTE *)v48 + 64) = v44;
                    v48[9] = v106;
                    v48[10] = v45;
                    v39 += 7;
                    --v38;
                  }

                  while (v38);
                  swift_bridgeObjectRelease(v102);
                  uint64_t v6 = v100;
                  uint64_t v12 = v101;
                  int64_t v34 = v103;
                  char v28 = (uint64_t)v98;
                }

                else
                {
                  uint64_t v14 = _swiftEmptyArrayStorage;
                }

                uint64_t v11 = v14[2];
                int64_t v49 = v34[2];
                uint64_t v7 = v49 + v11;
                if (__OFADD__(v49, v11))
                {
                  __break(1u);
LABEL_102:
                  __break(1u);
LABEL_103:
                  __break(1u);
LABEL_104:
                  __break(1u);
LABEL_105:
                  __break(1u);
LABEL_106:
                  __break(1u);
LABEL_107:
                  __break(1u);
LABEL_108:
                  __break(1u);
LABEL_109:
                  __break(1u);
LABEL_110:
                  __break(1u);
                  goto LABEL_111;
                }

                uint64_t v50 = swift_isUniquelyReferenced_nonNull_native(v34);
                if ((v50 & 1) != 0 && v7 <= v34[3] >> 1)
                {
                  uint64_t v13 = v14[2];
                  if (!v13)
                  {
LABEL_20:
                    if (v11) {
                      goto LABEL_102;
                    }
LABEL_21:
                    swift_bridgeObjectRelease(v14);
                    uint64_t v11 = v104;
                    unint64_t v33 = v105;
                    continue;
                  }
                }

                else
                {
                  if (v49 <= v7) {
                    int64_t v51 = v49 + v11;
                  }
                  else {
                    int64_t v51 = v49;
                  }
                  int64_t v34 = sub_1002CA104((void *)v50, v51, 1, v34);
                  uint64_t v13 = v14[2];
                  if (!v13) {
                    goto LABEL_20;
                  }
                }

                break;
              }

              uint64_t v13 = v34[2];
              uint64_t v52 = (unint64_t)&v34[7 * v13 + 4];
              if ((unint64_t)(v14 + 4) < v52 + 56 * v11 && v52 < (unint64_t)&v14[7 * v11 + 4])
              {
LABEL_114:
                v84 = _fatalErrorMessage(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  "UnsafeMutablePointer.initialize overlapping range",  49LL,  2LL,  "Swift/UnsafePointer.swift",  25LL,  2,  1092LL,  0);
                __break(1u);
                goto LABEL_115;
              }

              swift_arrayInitWithCopy(v52);
              if (v11)
              {
                uint64_t v54 = v34[2];
                uint64_t v55 = __OFADD__(v54, v11);
                uint64_t v13 = v54 + v11;
                if (v55) {
                  goto LABEL_104;
                }
                v34[2] = v13;
              }

              goto LABEL_21;
            }

  swift_bridgeObjectRetain(v4);
  char v28 = sub_1002D5A58(v27);
  swift_bridgeObjectRelease(v4);
  uint64_t v29 = *(void *)(v28 + 16);
  swift_bridgeObjectRelease(v28);
  if (v29 < 2) {
    goto LABEL_57;
  }
  if (v16 == 0x300000000LL)
  {
    if (v8 != 0x300000000LL) {
      goto LABEL_49;
    }
LABEL_57:
    swift_bridgeObjectRelease(v4);
    return 0LL;
  }

  if (v8 == 0x300000000LL) {
    uint64_t v30 = 0;
  }
  else {
    uint64_t v30 = a1;
  }
  if (v8 != 0x300000000LL && v30 == (_DWORD)a2)
  {
    uint64_t v31 = a1 & 0xFF00000000LL;
    if ((a2 & 0xFF00000000LL) == 0x300000000LL)
    {
      if (v31 == 0x300000000LL) {
        goto LABEL_57;
      }
    }

    else if (v31 != 0x300000000LL {
           && ((0x801004u >> ((a2 >> 29) & 0xF8)) & 0xFFC) == ((0x801004u >> ((a1 >> 29) & 0xF8)) & 0xFFC))
    }
    {
      goto LABEL_57;
    }
  }

    sub_10026E188((void **)&v22, (const void **)&v21, &v20);
    return 1LL;
  }

  uint64_t result = _fatalErrorMessage(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  "UnsafeMutablePointer.moveInitialize with negative count",  55LL,  2LL,  "Swift/UnsafePointer.swift",  25LL,  2,  1046LL,  0);
  __break(1u);
  return result;
}

Swift::Int NANGenericServiceProtocol.hashValue.getter(uint64_t a1)
{
  return Hasher._finalize()();
}

uint64_t sub_100068924()
{
  return NANGenericServiceProtocol.description.getter(*v0);
}

uint64_t sub_10006892C()
{
  uint64_t v1 = *v0;
  v3[3] = sub_100002274(&qword_100406240);
  v3[0] = v1;
  swift_bridgeObjectRetain(v1);
  return Mirror.init(reflecting:)(v3);
}

Swift::Int sub_10006897C()
{
  uint64_t v1 = *v0;
  Hasher.init(_seed:)(v3, 0LL);
  swift_bridgeObjectRetain(v1);
  sub_10006C6D0(v3, v1);
  swift_bridgeObjectRelease(v1);
  return Hasher._finalize()();
}

uint64_t sub_1000689D0(__int128 *a1)
{
  uint64_t v3 = *v1;
  swift_bridgeObjectRetain(v3);
  sub_10006C6D0(a1, v3);
  return swift_bridgeObjectRelease(v3);
}

Swift::Int sub_100068A08(uint64_t a1)
{
  uint64_t v2 = *v1;
  Hasher.init(_seed:)(v4, a1);
  swift_bridgeObjectRetain(v2);
  sub_10006C6D0(v4, v2);
  swift_bridgeObjectRelease(v2);
  return Hasher._finalize()();
}

uint64_t sub_100068A58(uint64_t *a1, uint64_t *a2)
{
  return sub_1000680E4(*a1, *a2);
}

uint64_t NANBeacon.Metadata.rssi.setter(uint64_t result)
{
  void *v1 = result;
  return result;
}

void *NANGenericServiceProtocol.AttributeFilter.standardizedAttributes.unsafeMutableAddressor()
{
  return &static NANGenericServiceProtocol.AttributeFilter.standardizedAttributes;
}

void sub_100068A78(void *a1@<X8>)
{
  *a1 = 0LL;
}

void *sub_100068A80@<X0>(void *result@<X0>, void *a2@<X8>)
{
  *a2 = *v2 | *result;
  return result;
}

void *sub_100068A94@<X0>(void *result@<X0>, void *a2@<X8>)
{
  *a2 = *v2 ^ *result;
  return result;
}

BOOL sub_100068AA8(void *a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  uint64_t v4 = *v2 & *a2;
  if (v4 != *a2) {
    *v2 |= v3;
  }
  *a1 = v3;
  return v4 != v3;
}

void *sub_100068AD8@<X0>(void *result@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3 = *v2 & *result;
  if (v3) {
    *v2 &= ~*result;
  }
  *(void *)a2 = v3;
  *(_BYTE *)(a2 + 8) = v3 == 0;
  return result;
}

uint64_t *sub_100068B04@<X0>(uint64_t *result@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3 = *result;
  uint64_t v4 = *v2;
  *v2 |= *result;
  uint64_t v5 = v4 & v3;
  *(void *)a2 = v5;
  *(_BYTE *)(a2 + 8) = v5 == 0;
  return result;
}

void *sub_100068B28(void *result)
{
  *v1 |= *result;
  return result;
}

void *sub_100068B3C(void *result)
{
  *v1 ^= *result;
  return result;
}

void *sub_100068B50@<X0>(void *result@<X0>, void *a2@<X8>)
{
  *a2 = *v2 & ~*result;
  return result;
}

BOOL sub_100068B64(void *a1)
{
  return (*v1 & *a1) == 0LL;
}

BOOL sub_100068B78()
{
  return *v0 == 0LL;
}

void *sub_100068B88(void *result)
{
  *v1 &= ~*result;
  return result;
}

uint64_t sub_100068B9C@<X0>(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  uint64_t v4 = sub_10019AD18();
  uint64_t result = swift_bridgeObjectRelease(a1);
  *a2 = v4;
  return result;
}

void NANGenericServiceProtocol.packetData(for:)(uint64_t a1, uint64_t a2)
{
  unint64_t v4 = sub_10000D9B0((uint64_t)_swiftEmptyArrayStorage);
  uint64_t v5 = type metadata accessor for BinaryEncoder();
  uint64_t v6 = swift_allocObject(v5, 40LL, 7LL);
  *(_OWORD *)(v6 + 16) = xmmword_1003398F0;
  *(void *)(v6 + 32) = v4;
  v9[3] = &type metadata for BinaryEncoder.UnkeyedContainer;
  v9[4] = sub_10006E360();
  v9[0] = v6;
  swift_retain();
  uint64_t v7 = swift_bridgeObjectRetain(a2);
  sub_100062EA0(v7, a1, (uint64_t)v9);
  swift_bridgeObjectRelease(a2);
  swift_beginAccess(v6 + 16, v8, 0LL, 0LL);
  __asm { BR              X10 }

uint64_t sub_100068D4C(unsigned __int8 *a1, char a2, uint64_t a3)
{
  uint64_t v39 = a3;
  uint64_t v6 = type metadata accessor for NANAttribute.CustomDeviceInformation.CustomAttributes(0LL);
  __chkstk_darwin(v6);
  int v37 = (char *)&v35 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v8 = type metadata accessor for NWEndpoint.Port(0LL);
  __chkstk_darwin(v8);
  uint64_t v9 = type metadata accessor for NANGenericServiceProtocol.Attribute(0LL);
  __chkstk_darwin(v9);
  uint64_t v11 = (char *)&v35 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v12 = sub_100002274(&qword_100406238);
  uint64_t v13 = __chkstk_darwin(v12);
  BOOL v38 = (char *)&v35 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v15 = __chkstk_darwin(v13);
  uint64_t v17 = (char *)&v35 - v16;
  uint64_t result = __chkstk_darwin(v15);
  uint64_t v20 = a1;
  uint64_t v22 = (char *)&v35 - v21;
  if ((a2 & 1) != 0 && *a1 < 7u)
  {
LABEL_10:
    uint64_t v40 = v19;
    uint64_t v33 = *(int *)(v19 + 48);
    uint64_t v36 = v20;
    sub_100057FE8((uint64_t)&v20[v33], (uint64_t)v11, type metadata accessor for NANGenericServiceProtocol.Attribute);
    int64_t v34 = (char *)&loc_100069000 + dword_100069614[swift_getEnumCaseMultiPayload(v11, v9)];
    __asm { BR              X10 }
  }

  if ((a2 & 2) != 0)
  {
    unsigned int v23 = *a1;
    if (v23 >= 7)
    {
      uint64_t v36 = v3;
      uint64_t v40 = v19;
      uint64_t v24 = *(int *)(v19 + 48);
      unint64_t v25 = (unsigned __int16 *)&v22[v24];
      uint64_t v26 = (uint64_t)&a1[v24];
      *uint64_t v22 = v23;
      sub_100057FE8( (uint64_t)&a1[v24],  (uint64_t)&v22[v24],  type metadata accessor for NANGenericServiceProtocol.Attribute);
      if (swift_getEnumCaseMultiPayload(v25, v9) == 8)
      {
        LODWORD(v35) = *((unsigned __int8 *)v25 + 2);
        uint64_t v27 = *((void *)v25 + 1);
        unint64_t v28 = *((void *)v25 + 2);
        unsigned int v29 = *v25;
        sub_1000208D8(v27, v28);
        char v30 = sub_100023504(0xF21700u, v29 | ((_DWORD)v35 << 16));
        uint64_t v20 = a1;
        uint64_t v19 = v40;
        if ((v30 & 1) != 0) {
          goto LABEL_10;
        }
      }

      else
      {
        sub_10005802C((uint64_t)v25, type metadata accessor for NANGenericServiceProtocol.Attribute);
        uint64_t v20 = a1;
        uint64_t v19 = v40;
      }

      uint64_t v31 = (uint64_t)&v17[*(int *)(v19 + 48)];
      *uint64_t v17 = *v20;
      sub_100057FE8(v26, v31, type metadata accessor for NANGenericServiceProtocol.Attribute);
      int EnumCaseMultiPayload = swift_getEnumCaseMultiPayload(v31, v9);
      uint64_t result = sub_10005802C(v31, type metadata accessor for NANGenericServiceProtocol.Attribute);
      uint64_t v19 = v40;
      uint64_t v20 = a1;
      if (EnumCaseMultiPayload == 7) {
        goto LABEL_10;
      }
    }
  }

  return result;
}

void *NANGenericServiceProtocol.init(from:)(void *a1)
{
  return sub_10006DC1C(a1);
}

void *sub_100069670@<X0>(void *a1@<X0>, void *a2@<X8>)
{
  uint64_t result = sub_10006DC1C(a1);
  if (!v2) {
    *a2 = result;
  }
  return result;
}

uint64_t sub_100069698(char a1, int64_t a2, char a3)
{
  uint64_t result = sub_100069A38(a1, a2, a3, (void *)*v3);
  *uint64_t v3 = result;
  return result;
}

uint64_t sub_1000696B4(char a1, int64_t a2, char a3)
{
  uint64_t result = sub_100069BC0(a1, a2, a3, *v3);
  *uint64_t v3 = (char *)result;
  return result;
}

uint64_t sub_1000696D0(char a1, int64_t a2, char a3)
{
  uint64_t result = sub_100069D28(a1, a2, a3, (void *)*v3);
  *uint64_t v3 = result;
  return result;
}

uint64_t sub_1000696EC(char a1, int64_t a2, char a3)
{
  uint64_t result = sub_100069EB0(a1, a2, a3, *v3);
  *uint64_t v3 = (char *)result;
  return result;
}

uint64_t sub_100069708(char a1, int64_t a2, char a3)
{
  uint64_t result = sub_10006AD28(a1, a2, a3, *v3, &qword_100406420);
  *uint64_t v3 = (char *)result;
  return result;
}

uint64_t sub_10006972C(char a1, int64_t a2, char a3)
{
  uint64_t result = sub_10006A170(a1, a2, a3, *v3, &qword_1004040A8);
  *uint64_t v3 = (char *)result;
  return result;
}

uint64_t sub_100069750(char a1, int64_t a2, char a3)
{
  uint64_t result = sub_10006A008(a1, a2, a3, *v3);
  *uint64_t v3 = (char *)result;
  return result;
}

uint64_t sub_10006976C(char a1, int64_t a2, char a3)
{
  uint64_t result = sub_10006A170(a1, a2, a3, *v3, &qword_1004063C0);
  *uint64_t v3 = (char *)result;
  return result;
}

uint64_t sub_100069790(char a1, int64_t a2, char a3)
{
  uint64_t result = sub_10006A170(a1, a2, a3, *v3, &qword_1004063C8);
  *uint64_t v3 = (char *)result;
  return result;
}

uint64_t sub_1000697B4(char a1, int64_t a2, char a3)
{
  uint64_t result = sub_10006A2B8(a1, a2, a3, (void *)*v3);
  *uint64_t v3 = result;
  return result;
}

uint64_t sub_1000697D0(char a1, int64_t a2, char a3)
{
  uint64_t result = sub_10006A4A0(a1, a2, a3, *v3);
  *uint64_t v3 = (char *)result;
  return result;
}

uint64_t sub_1000697EC(char a1, int64_t a2, char a3)
{
  uint64_t result = sub_10006A608(a1, a2, a3, *v3);
  *uint64_t v3 = (char *)result;
  return result;
}

uint64_t sub_100069808(char a1, int64_t a2, char a3)
{
  uint64_t result = sub_10006AD28(a1, a2, a3, *v3, &qword_100406380);
  *uint64_t v3 = (char *)result;
  return result;
}

uint64_t sub_10006982C(char a1, int64_t a2, char a3)
{
  uint64_t result = sub_10006A754(a1, a2, a3, *v3);
  *uint64_t v3 = (char *)result;
  return result;
}

uint64_t sub_100069848(char a1, int64_t a2, char a3)
{
  uint64_t result = sub_10006A8BC(a1, a2, a3, *v3);
  *uint64_t v3 = (char *)result;
  return result;
}

uint64_t sub_100069864(char a1, int64_t a2, char a3)
{
  uint64_t result = sub_10006AA18(a1, a2, a3, *v3);
  *uint64_t v3 = (char *)result;
  return result;
}

uint64_t sub_100069880(char a1, int64_t a2, char a3)
{
  uint64_t result = sub_10006AB94(a1, a2, a3, (void *)*v3);
  *uint64_t v3 = result;
  return result;
}

uint64_t sub_10006989C(char a1, int64_t a2, char a3)
{
  uint64_t result = sub_10006AFD8(a1, a2, a3, *v3);
  *uint64_t v3 = (char *)result;
  return result;
}

uint64_t sub_1000698B8(char a1, int64_t a2, char a3)
{
  uint64_t result = sub_10006B134(a1, a2, a3, *v3);
  *uint64_t v3 = (char *)result;
  return result;
}

uint64_t sub_1000698D4(char a1, int64_t a2, char a3)
{
  uint64_t result = sub_10006B2B0(a1, a2, a3, *v3);
  *uint64_t v3 = (char *)result;
  return result;
}

uint64_t sub_1000698F0(char a1, int64_t a2, char a3)
{
  uint64_t result = sub_10006B424(a1, a2, a3, *v3);
  *uint64_t v3 = (char *)result;
  return result;
}

uint64_t sub_10006990C(char a1, int64_t a2, char a3)
{
  uint64_t result = sub_10006BBA8( a1,  a2,  a3,  (void *)*v3,  &qword_100406408,  (uint64_t (*)(void))&type metadata accessor for SymmetricKey);
  *uint64_t v3 = result;
  return result;
}

uint64_t sub_100069938(char a1, int64_t a2, char a3)
{
  uint64_t result = sub_10006BBA8( a1,  a2,  a3,  (void *)*v3,  &qword_100406358,  type metadata accessor for LongTermPairingKeys.PublicIdentity);
  *uint64_t v3 = result;
  return result;
}

uint64_t sub_100069964(char a1, int64_t a2, char a3)
{
  uint64_t result = sub_10006B580(a1, a2, a3, (void *)*v3);
  *uint64_t v3 = result;
  return result;
}

uint64_t sub_100069980(char a1, int64_t a2, char a3)
{
  uint64_t result = sub_10006B708(a1, a2, a3, *v3);
  *uint64_t v3 = (char *)result;
  return result;
}

uint64_t sub_10006999C(char a1, int64_t a2, char a3)
{
  uint64_t result = sub_10006B860(a1, a2, a3, (void *)*v3);
  *uint64_t v3 = result;
  return result;
}

uint64_t sub_1000699B8(char a1, int64_t a2, char a3)
{
  uint64_t result = sub_10006BA04(a1, a2, a3, (void *)*v3);
  *uint64_t v3 = result;
  return result;
}

uint64_t sub_1000699D4(char a1, int64_t a2, char a3)
{
  uint64_t result = sub_10006BBA8(a1, a2, a3, (void *)*v3, &qword_10040D7E0, type metadata accessor for NANAttribute);
  *uint64_t v3 = result;
  return result;
}

uint64_t sub_100069A00(char a1, int64_t a2, char a3)
{
  uint64_t result = sub_10006BD88(a1, a2, a3, *v3);
  *uint64_t v3 = (char *)result;
  return result;
}

uint64_t sub_100069A1C(char a1, int64_t a2, char a3)
{
  uint64_t result = sub_10006BEF0(a1, a2, a3, (void *)*v3);
  *uint64_t v3 = result;
  return result;
}

uint64_t sub_100069A38(char a1, int64_t a2, char a3, void *a4)
{
  if ((a3 & 1) != 0)
  {
    unint64_t v6 = a4[3];
    int64_t v7 = v6 >> 1;
    if ((uint64_t)(v6 >> 1) < a2)
    {
      if (v7 + 0x4000000000000000LL < 0)
      {
        __break(1u);
        goto LABEL_32;
      }

      int64_t v7 = v6 & 0xFFFFFFFFFFFFFFFELL;
    }
  }

  else
  {
    int64_t v7 = a2;
  }

  uint64_t v8 = a4[2];
  if (v7 <= v8) {
    uint64_t v9 = a4[2];
  }
  else {
    uint64_t v9 = v7;
  }
  if (v9)
  {
    uint64_t v10 = sub_100002274(&qword_100406448);
    uint64_t v11 = (void *)swift_allocObject(v10, 16 * v9 + 32, 7LL);
    int64_t v12 = j__malloc_size(v11);
    uint64_t v13 = v12 - 32;
    if (v12 < 32) {
      uint64_t v13 = v12 - 17;
    }
    v11[2] = v8;
    v11[3] = 2 * (v13 >> 4);
  }

  else
  {
    uint64_t v11 = _swiftEmptyArrayStorage;
  }

  unint64_t v14 = (unint64_t)(v11 + 4);
  unint64_t v15 = (unint64_t)(a4 + 4);
  if ((a1 & 1) != 0)
  {
    if (v11 != a4 || v14 >= v15 + 16 * v8) {
      memmove(v11 + 4, a4 + 4, 16 * v8);
    }
    a4[2] = 0LL;
    goto LABEL_30;
  }

  if (v15 >= v14 + 16 * v8 || v14 >= v15 + 16 * v8)
  {
    sub_100002274(&qword_100406450);
    swift_arrayInitWithCopy(v11 + 4);
LABEL_30:
    swift_release(a4);
    return (uint64_t)v11;
  }

uint64_t sub_100069BC0(char a1, int64_t a2, char a3, char *a4)
{
  if ((a3 & 1) != 0)
  {
    unint64_t v6 = *((void *)a4 + 3);
    int64_t v7 = v6 >> 1;
    if ((uint64_t)(v6 >> 1) < a2)
    {
      if (v7 + 0x4000000000000000LL < 0)
      {
        __break(1u);
        goto LABEL_32;
      }

      int64_t v7 = v6 & 0xFFFFFFFFFFFFFFFELL;
    }
  }

  else
  {
    int64_t v7 = a2;
  }

  uint64_t v8 = *((void *)a4 + 2);
  if (v7 <= v8) {
    uint64_t v9 = *((void *)a4 + 2);
  }
  else {
    uint64_t v9 = v7;
  }
  if (v9)
  {
    uint64_t v10 = sub_100002274((uint64_t *)&unk_10040CD70);
    uint64_t v11 = (char *)swift_allocObject(v10, 16 * v9 + 32, 7LL);
    int64_t v12 = j__malloc_size(v11);
    uint64_t v13 = v12 - 32;
    if (v12 < 32) {
      uint64_t v13 = v12 - 17;
    }
    *((void *)v11 + 2) = v8;
    *((void *)v11 + 3) = 2 * (v13 >> 4);
  }

  else
  {
    uint64_t v11 = (char *)_swiftEmptyArrayStorage;
  }

  unint64_t v14 = v11 + 32;
  unint64_t v15 = a4 + 32;
  if ((a1 & 1) != 0)
  {
    if (v11 != a4 || v14 >= &v15[16 * v8]) {
      memmove(v14, v15, 16 * v8);
    }
    *((void *)a4 + 2) = 0LL;
    goto LABEL_30;
  }

  if (v15 >= &v14[16 * v8] || v14 >= &v15[16 * v8])
  {
    swift_arrayInitWithCopy(v14);
LABEL_30:
    swift_release(a4);
    return (uint64_t)v11;
  }

uint64_t sub_100069D28(char a1, int64_t a2, char a3, void *a4)
{
  if ((a3 & 1) != 0)
  {
    unint64_t v6 = a4[3];
    int64_t v7 = v6 >> 1;
    if ((uint64_t)(v6 >> 1) < a2)
    {
      if (v7 + 0x4000000000000000LL < 0)
      {
        __break(1u);
        goto LABEL_32;
      }

      int64_t v7 = v6 & 0xFFFFFFFFFFFFFFFELL;
    }
  }

  else
  {
    int64_t v7 = a2;
  }

  uint64_t v8 = a4[2];
  if (v7 <= v8) {
    uint64_t v9 = a4[2];
  }
  else {
    uint64_t v9 = v7;
  }
  if (v9)
  {
    uint64_t v10 = sub_100002274(&qword_100406360);
    uint64_t v11 = (void *)swift_allocObject(v10, 16 * v9 + 32, 7LL);
    int64_t v12 = j__malloc_size(v11);
    uint64_t v13 = v12 - 32;
    if (v12 < 32) {
      uint64_t v13 = v12 - 17;
    }
    v11[2] = v8;
    v11[3] = 2 * (v13 >> 4);
  }

  else
  {
    uint64_t v11 = _swiftEmptyArrayStorage;
  }

  unint64_t v14 = (unint64_t)(v11 + 4);
  unint64_t v15 = (unint64_t)(a4 + 4);
  if ((a1 & 1) != 0)
  {
    if (v11 != a4 || v14 >= v15 + 16 * v8) {
      memmove(v11 + 4, a4 + 4, 16 * v8);
    }
    a4[2] = 0LL;
    goto LABEL_30;
  }

  if (v15 >= v14 + 16 * v8 || v14 >= v15 + 16 * v8)
  {
    sub_100002274(&qword_100406368);
    swift_arrayInitWithCopy(v11 + 4);
LABEL_30:
    swift_release(a4);
    return (uint64_t)v11;
  }

uint64_t sub_100069EB0(char a1, int64_t a2, char a3, char *a4)
{
  if ((a3 & 1) != 0)
  {
    unint64_t v6 = *((void *)a4 + 3);
    int64_t v7 = v6 >> 1;
    if ((uint64_t)(v6 >> 1) < a2)
    {
      if (v7 + 0x4000000000000000LL < 0)
      {
        __break(1u);
        goto LABEL_32;
      }

      int64_t v7 = v6 & 0xFFFFFFFFFFFFFFFELL;
    }
  }

  else
  {
    int64_t v7 = a2;
  }

  uint64_t v8 = *((void *)a4 + 2);
  if (v7 <= v8) {
    uint64_t v9 = *((void *)a4 + 2);
  }
  else {
    uint64_t v9 = v7;
  }
  if (v9)
  {
    uint64_t v10 = sub_100002274(&qword_1004063A0);
    uint64_t v11 = (char *)swift_allocObject(v10, 16 * v9 + 32, 7LL);
    int64_t v12 = j__malloc_size(v11);
    uint64_t v13 = v12 - 32;
    if (v12 < 32) {
      uint64_t v13 = v12 - 17;
    }
    *((void *)v11 + 2) = v8;
    *((void *)v11 + 3) = 2 * (v13 >> 4);
  }

  else
  {
    uint64_t v11 = (char *)_swiftEmptyArrayStorage;
  }

  unint64_t v14 = v11 + 32;
  unint64_t v15 = a4 + 32;
  size_t v16 = 16 * v8;
  if ((a1 & 1) != 0)
  {
    if (v11 != a4 || v14 >= &v15[v16]) {
      memmove(v14, v15, v16);
    }
    *((void *)a4 + 2) = 0LL;
    goto LABEL_30;
  }

  if (v15 >= &v14[v16] || v14 >= &v15[v16])
  {
    memcpy(v14, v15, v16);
LABEL_30:
    swift_release(a4);
    return (uint64_t)v11;
  }

uint64_t sub_10006A008(char a1, int64_t a2, char a3, char *a4)
{
  if ((a3 & 1) != 0)
  {
    unint64_t v6 = *((void *)a4 + 3);
    int64_t v7 = v6 >> 1;
    if ((uint64_t)(v6 >> 1) < a2)
    {
      if (v7 + 0x4000000000000000LL < 0)
      {
        __break(1u);
        goto LABEL_32;
      }

      int64_t v7 = v6 & 0xFFFFFFFFFFFFFFFELL;
    }
  }

  else
  {
    int64_t v7 = a2;
  }

  uint64_t v8 = *((void *)a4 + 2);
  if (v7 <= v8) {
    uint64_t v9 = *((void *)a4 + 2);
  }
  else {
    uint64_t v9 = v7;
  }
  if (v9)
  {
    uint64_t v10 = sub_100002274(&qword_1004063B8);
    uint64_t v11 = (char *)swift_allocObject(v10, 16 * v9 + 32, 7LL);
    int64_t v12 = j__malloc_size(v11);
    uint64_t v13 = v12 - 32;
    if (v12 < 32) {
      uint64_t v13 = v12 - 17;
    }
    *((void *)v11 + 2) = v8;
    *((void *)v11 + 3) = 2 * (v13 >> 4);
  }

  else
  {
    uint64_t v11 = (char *)_swiftEmptyArrayStorage;
  }

  unint64_t v14 = v11 + 32;
  unint64_t v15 = a4 + 32;
  if ((a1 & 1) != 0)
  {
    if (v11 != a4 || v14 >= &v15[16 * v8]) {
      memmove(v14, v15, 16 * v8);
    }
    *((void *)a4 + 2) = 0LL;
    goto LABEL_30;
  }

  if (v15 >= &v14[16 * v8] || v14 >= &v15[16 * v8])
  {
    swift_arrayInitWithCopy(v14);
LABEL_30:
    swift_release(a4);
    return (uint64_t)v11;
  }

uint64_t sub_10006A170(char a1, int64_t a2, char a3, char *a4, uint64_t *a5)
{
  if ((a3 & 1) != 0)
  {
    unint64_t v7 = *((void *)a4 + 3);
    int64_t v8 = v7 >> 1;
    if ((uint64_t)(v7 >> 1) < a2)
    {
      if (v8 + 0x4000000000000000LL < 0)
      {
        __break(1u);
        goto LABEL_30;
      }

      int64_t v8 = v7 & 0xFFFFFFFFFFFFFFFELL;
    }
  }

  else
  {
    int64_t v8 = a2;
  }

  int64_t v9 = *((void *)a4 + 2);
  if (v8 <= v9) {
    int64_t v10 = *((void *)a4 + 2);
  }
  else {
    int64_t v10 = v8;
  }
  if (v10)
  {
    uint64_t v11 = sub_100002274(a5);
    int64_t v12 = (char *)swift_allocObject(v11, v10 + 32, 7LL);
    size_t v13 = j__malloc_size(v12);
    *((void *)v12 + 2) = v9;
    *((void *)v12 + 3) = 2 * v13 - 64;
  }

  else
  {
    int64_t v12 = (char *)_swiftEmptyArrayStorage;
  }

  unint64_t v14 = v12 + 32;
  unint64_t v15 = a4 + 32;
  if ((a1 & 1) != 0)
  {
    if (v12 != a4 || v14 >= &v15[v9]) {
      memmove(v14, v15, v9);
    }
    *((void *)a4 + 2) = 0LL;
    goto LABEL_28;
  }

  if (v15 >= &v14[v9] || v14 >= &v15[v9])
  {
    memcpy(v14, v15, v9);
LABEL_28:
    swift_release(a4);
    return (uint64_t)v12;
  }

uint64_t sub_10006A2B8(char a1, int64_t a2, char a3, void *a4)
{
  if ((a3 & 1) != 0)
  {
    unint64_t v6 = a4[3];
    int64_t v7 = v6 >> 1;
    if ((uint64_t)(v6 >> 1) < a2)
    {
      if (v7 + 0x4000000000000000LL < 0)
      {
LABEL_35:
        __break(1u);
        goto LABEL_36;
      }

      int64_t v7 = v6 & 0xFFFFFFFFFFFFFFFELL;
    }
  }

  else
  {
    int64_t v7 = a2;
  }

  uint64_t v8 = a4[2];
  if (v7 <= v8) {
    uint64_t v9 = a4[2];
  }
  else {
    uint64_t v9 = v7;
  }
  if (!v9)
  {
    unint64_t v15 = _swiftEmptyArrayStorage;
    goto LABEL_19;
  }

  uint64_t v10 = sub_100002274(&qword_1004064A8);
  uint64_t v11 = *(void *)(sub_100002274(&qword_100405118) - 8);
  uint64_t v12 = *(void *)(v11 + 72);
  uint64_t v13 = *(unsigned __int8 *)(v11 + 80);
  uint64_t v14 = (v13 + 32) & ~v13;
  unint64_t v15 = (void *)swift_allocObject(v10, v14 + v12 * v9, v13 | 7);
  size_t v16 = j__malloc_size(v15);
  if (!v12)
  {
    __break(1u);
LABEL_34:
    __break(1u);
    goto LABEL_35;
  }

  if (v16 - v14 == 0x8000000000000000LL && v12 == -1) {
    goto LABEL_34;
  }
  v15[2] = v8;
  v15[3] = 2 * ((uint64_t)(v16 - v14) / v12);
LABEL_19:
  uint64_t v18 = sub_100002274(&qword_100405118);
  uint64_t v19 = *(void *)(v18 - 8);
  unint64_t v20 = (*(unsigned __int8 *)(v19 + 80) + 32LL) & ~(unint64_t)*(unsigned __int8 *)(v19 + 80);
  uint64_t v21 = (char *)v15 + v20;
  uint64_t v22 = (char *)a4 + v20;
  if ((a1 & 1) != 0)
  {
    if (v15 < a4 || v21 >= &v22[*(void *)(v19 + 72) * v8])
    {
      swift_arrayInitWithTakeFrontToBack(v21, v22, v8, v18);
    }

    else if (v15 != a4)
    {
      swift_arrayInitWithTakeBackToFront();
    }

    a4[2] = 0LL;
    goto LABEL_32;
  }

  uint64_t v23 = *(void *)(v19 + 72) * v8;
  uint64_t v24 = &v21[v23];
  unint64_t v25 = (unint64_t)&v22[v23];
  if (v22 >= v24 || (unint64_t)v21 >= v25)
  {
    swift_arrayInitWithCopy(v21);
LABEL_32:
    swift_release(a4);
    return (uint64_t)v15;
  }

uint64_t sub_10006A4A0(char a1, int64_t a2, char a3, char *a4)
{
  if ((a3 & 1) != 0)
  {
    unint64_t v6 = *((void *)a4 + 3);
    int64_t v7 = v6 >> 1;
    if ((uint64_t)(v6 >> 1) < a2)
    {
      if (v7 + 0x4000000000000000LL < 0)
      {
        __break(1u);
        goto LABEL_30;
      }

      int64_t v7 = v6 & 0xFFFFFFFFFFFFFFFELL;
    }
  }

  else
  {
    int64_t v7 = a2;
  }

  uint64_t v8 = *((void *)a4 + 2);
  if (v7 <= v8) {
    uint64_t v9 = *((void *)a4 + 2);
  }
  else {
    uint64_t v9 = v7;
  }
  if (v9)
  {
    uint64_t v10 = sub_100002274(&qword_10040F270);
    uint64_t v11 = (char *)swift_allocObject(v10, 10 * v9 + 32, 7LL);
    size_t v12 = j__malloc_size(v11);
    *((void *)v11 + 2) = v8;
    *((void *)v11 + 3) = 2 * ((uint64_t)(v12 - 32) / 10);
  }

  else
  {
    uint64_t v11 = (char *)_swiftEmptyArrayStorage;
  }

  uint64_t v13 = v11 + 32;
  uint64_t v14 = a4 + 32;
  size_t v15 = 10 * v8;
  if ((a1 & 1) != 0)
  {
    if (v11 != a4 || v13 >= &v14[v15]) {
      memmove(v13, v14, v15);
    }
    *((void *)a4 + 2) = 0LL;
    goto LABEL_28;
  }

  if (v14 >= &v13[v15] || v13 >= &v14[v15])
  {
    memcpy(v13, v14, v15);
LABEL_28:
    swift_release(a4);
    return (uint64_t)v11;
  }

uint64_t sub_10006A608(char a1, int64_t a2, char a3, char *a4)
{
  if ((a3 & 1) != 0)
  {
    unint64_t v6 = *((void *)a4 + 3);
    int64_t v7 = v6 >> 1;
    if ((uint64_t)(v6 >> 1) < a2)
    {
      if (v7 + 0x4000000000000000LL < 0)
      {
        __break(1u);
        goto LABEL_30;
      }

      int64_t v7 = v6 & 0xFFFFFFFFFFFFFFFELL;
    }
  }

  else
  {
    int64_t v7 = a2;
  }

  int64_t v8 = *((void *)a4 + 2);
  if (v7 <= v8) {
    int64_t v9 = *((void *)a4 + 2);
  }
  else {
    int64_t v9 = v7;
  }
  if (v9)
  {
    uint64_t v10 = sub_100002274(&qword_100406458);
    uint64_t v11 = (char *)swift_allocObject(v10, v9 + 32, 7LL);
    size_t v12 = j__malloc_size(v11);
    *((void *)v11 + 2) = v8;
    *((void *)v11 + 3) = 2 * v12 - 64;
  }

  else
  {
    uint64_t v11 = (char *)_swiftEmptyArrayStorage;
  }

  uint64_t v13 = v11 + 32;
  uint64_t v14 = a4 + 32;
  if ((a1 & 1) != 0)
  {
    if (v11 != a4 || v13 >= &v14[v8]) {
      memmove(v13, v14, v8);
    }
    *((void *)a4 + 2) = 0LL;
    goto LABEL_28;
  }

  if (v14 >= &v13[v8] || v13 >= &v14[v8])
  {
    memcpy(v13, v14, v8);
LABEL_28:
    swift_release(a4);
    return (uint64_t)v11;
  }

uint64_t sub_10006A754(char a1, int64_t a2, char a3, char *a4)
{
  if ((a3 & 1) != 0)
  {
    unint64_t v6 = *((void *)a4 + 3);
    int64_t v7 = v6 >> 1;
    if ((uint64_t)(v6 >> 1) < a2)
    {
      if (v7 + 0x4000000000000000LL < 0)
      {
        __break(1u);
        goto LABEL_32;
      }

      int64_t v7 = v6 & 0xFFFFFFFFFFFFFFFELL;
    }
  }

  else
  {
    int64_t v7 = a2;
  }

  uint64_t v8 = *((void *)a4 + 2);
  if (v7 <= v8) {
    uint64_t v9 = *((void *)a4 + 2);
  }
  else {
    uint64_t v9 = v7;
  }
  if (v9)
  {
    uint64_t v10 = sub_100002274(&qword_100406410);
    uint64_t v11 = (char *)swift_allocObject(v10, 16 * v9 + 32, 7LL);
    int64_t v12 = j__malloc_size(v11);
    uint64_t v13 = v12 - 32;
    if (v12 < 32) {
      uint64_t v13 = v12 - 17;
    }
    *((void *)v11 + 2) = v8;
    *((void *)v11 + 3) = 2 * (v13 >> 4);
  }

  else
  {
    uint64_t v11 = (char *)_swiftEmptyArrayStorage;
  }

  uint64_t v14 = v11 + 32;
  size_t v15 = a4 + 32;
  if ((a1 & 1) != 0)
  {
    if (v11 != a4 || v14 >= &v15[16 * v8]) {
      memmove(v14, v15, 16 * v8);
    }
    *((void *)a4 + 2) = 0LL;
    goto LABEL_30;
  }

  if (v15 >= &v14[16 * v8] || v14 >= &v15[16 * v8])
  {
    swift_arrayInitWithCopy(v14);
LABEL_30:
    swift_release(a4);
    return (uint64_t)v11;
  }

uint64_t sub_10006A8BC(char a1, int64_t a2, char a3, char *a4)
{
  if ((a3 & 1) != 0)
  {
    unint64_t v6 = *((void *)a4 + 3);
    int64_t v7 = v6 >> 1;
    if ((uint64_t)(v6 >> 1) < a2)
    {
      if (v7 + 0x4000000000000000LL < 0)
      {
        __break(1u);
        goto LABEL_32;
      }

      int64_t v7 = v6 & 0xFFFFFFFFFFFFFFFELL;
    }
  }

  else
  {
    int64_t v7 = a2;
  }

  uint64_t v8 = *((void *)a4 + 2);
  if (v7 <= v8) {
    uint64_t v9 = *((void *)a4 + 2);
  }
  else {
    uint64_t v9 = v7;
  }
  if (v9)
  {
    uint64_t v10 = sub_100002274(&qword_1004063F0);
    uint64_t v11 = (char *)swift_allocObject(v10, 8 * v9 + 32, 7LL);
    int64_t v12 = j__malloc_size(v11);
    uint64_t v13 = v12 - 32;
    if (v12 < 32) {
      uint64_t v13 = v12 - 25;
    }
    *((void *)v11 + 2) = v8;
    *((void *)v11 + 3) = 2 * (v13 >> 3);
  }

  else
  {
    uint64_t v11 = (char *)_swiftEmptyArrayStorage;
  }

  uint64_t v14 = v11 + 32;
  size_t v15 = a4 + 32;
  if ((a1 & 1) != 0)
  {
    if (v11 != a4 || v14 >= &v15[8 * v8]) {
      memmove(v14, v15, 8 * v8);
    }
    *((void *)a4 + 2) = 0LL;
    goto LABEL_30;
  }

  if (v15 >= &v14[8 * v8] || v14 >= &v15[8 * v8])
  {
    memcpy(v14, v15, 8 * v8);
LABEL_30:
    swift_release(a4);
    return (uint64_t)v11;
  }

uint64_t sub_10006AA18(char a1, int64_t a2, char a3, char *a4)
{
  if ((a3 & 1) != 0)
  {
    unint64_t v6 = *((void *)a4 + 3);
    int64_t v7 = v6 >> 1;
    if ((uint64_t)(v6 >> 1) < a2)
    {
      if (v7 + 0x4000000000000000LL < 0)
      {
        __break(1u);
        goto LABEL_30;
      }

      int64_t v7 = v6 & 0xFFFFFFFFFFFFFFFELL;
    }
  }

  else
  {
    int64_t v7 = a2;
  }

  uint64_t v8 = *((void *)a4 + 2);
  if (v7 <= v8) {
    uint64_t v9 = *((void *)a4 + 2);
  }
  else {
    uint64_t v9 = v7;
  }
  if (v9)
  {
    uint64_t v10 = sub_100002274(&qword_1004064D0);
    uint64_t v11 = (char *)swift_allocObject(v10, 14 * v9 + 32, 7LL);
    size_t v12 = j__malloc_size(v11);
    *((void *)v11 + 2) = v8;
    *((void *)v11 + 3) = 2 * ((uint64_t)(v12 - 32) / 14);
  }

  else
  {
    uint64_t v11 = (char *)_swiftEmptyArrayStorage;
  }

  uint64_t v13 = v11 + 32;
  uint64_t v14 = a4 + 32;
  if ((a1 & 1) != 0)
  {
    if (v11 != a4 || v13 >= &v14[14 * v8]) {
      memmove(v13, v14, 14 * v8);
    }
    *((void *)a4 + 2) = 0LL;
    goto LABEL_28;
  }

  if (v14 >= &v13[14 * v8] || v13 >= &v14[14 * v8])
  {
    memcpy(v13, v14, 14 * v8);
LABEL_28:
    swift_release(a4);
    return (uint64_t)v11;
  }

uint64_t sub_10006AB94(char a1, int64_t a2, char a3, void *a4)
{
  if ((a3 & 1) != 0)
  {
    unint64_t v6 = a4[3];
    int64_t v7 = v6 >> 1;
    if ((uint64_t)(v6 >> 1) < a2)
    {
      if (v7 + 0x4000000000000000LL < 0)
      {
        __break(1u);
        goto LABEL_32;
      }

      int64_t v7 = v6 & 0xFFFFFFFFFFFFFFFELL;
    }
  }

  else
  {
    int64_t v7 = a2;
  }

  uint64_t v8 = a4[2];
  if (v7 <= v8) {
    uint64_t v9 = a4[2];
  }
  else {
    uint64_t v9 = v7;
  }
  if (v9)
  {
    uint64_t v10 = sub_100002274(&qword_1004063A8);
    uint64_t v11 = (void *)swift_allocObject(v10, 16 * v9 + 32, 7LL);
    int64_t v12 = j__malloc_size(v11);
    uint64_t v13 = v12 - 32;
    if (v12 < 32) {
      uint64_t v13 = v12 - 17;
    }
    v11[2] = v8;
    v11[3] = 2 * (v13 >> 4);
  }

  else
  {
    uint64_t v11 = _swiftEmptyArrayStorage;
  }

  unint64_t v14 = (unint64_t)(v11 + 4);
  unint64_t v15 = (unint64_t)(a4 + 4);
  if ((a1 & 1) != 0)
  {
    if (v11 != a4 || v14 >= v15 + 16 * v8) {
      memmove(v11 + 4, a4 + 4, 16 * v8);
    }
    a4[2] = 0LL;
    goto LABEL_30;
  }

  if (v15 >= v14 + 16 * v8 || v14 >= v15 + 16 * v8)
  {
    sub_100002274(&qword_1004063B0);
    swift_arrayInitWithCopy(v11 + 4);
LABEL_30:
    swift_release(a4);
    return (uint64_t)v11;
  }

uint64_t sub_10006AD1C(char a1, int64_t a2, char a3, char *a4)
{
  return sub_10006AD28(a1, a2, a3, a4, &qword_100406440);
}

uint64_t sub_10006AD28(char a1, int64_t a2, char a3, char *a4, uint64_t *a5)
{
  if ((a3 & 1) != 0)
  {
    unint64_t v7 = *((void *)a4 + 3);
    int64_t v8 = v7 >> 1;
    if ((uint64_t)(v7 >> 1) < a2)
    {
      if (v8 + 0x4000000000000000LL < 0)
      {
        __break(1u);
        goto LABEL_32;
      }

      int64_t v8 = v7 & 0xFFFFFFFFFFFFFFFELL;
    }
  }

  else
  {
    int64_t v8 = a2;
  }

  uint64_t v9 = *((void *)a4 + 2);
  if (v8 <= v9) {
    uint64_t v10 = *((void *)a4 + 2);
  }
  else {
    uint64_t v10 = v8;
  }
  if (v10)
  {
    uint64_t v11 = sub_100002274(a5);
    int64_t v12 = (char *)swift_allocObject(v11, 8 * v10 + 32, 7LL);
    int64_t v13 = j__malloc_size(v12);
    uint64_t v14 = v13 - 32;
    if (v13 < 32) {
      uint64_t v14 = v13 - 25;
    }
    *((void *)v12 + 2) = v9;
    *((void *)v12 + 3) = 2 * (v14 >> 3);
  }

  else
  {
    int64_t v12 = (char *)_swiftEmptyArrayStorage;
  }

  unint64_t v15 = v12 + 32;
  size_t v16 = a4 + 32;
  size_t v17 = 8 * v9;
  if ((a1 & 1) != 0)
  {
    if (v12 != a4 || v15 >= &v16[v17]) {
      memmove(v15, v16, v17);
    }
    *((void *)a4 + 2) = 0LL;
    goto LABEL_30;
  }

  if (v16 >= &v15[v17] || v15 >= &v16[v17])
  {
    memcpy(v15, v16, v17);
LABEL_30:
    swift_release(a4);
    return (uint64_t)v12;
  }

uint64_t sub_10006AE7C(char a1, int64_t a2, char a3, char *a4)
{
  if ((a3 & 1) != 0)
  {
    unint64_t v6 = *((void *)a4 + 3);
    int64_t v7 = v6 >> 1;
    if ((uint64_t)(v6 >> 1) < a2)
    {
      if (v7 + 0x4000000000000000LL < 0)
      {
        __break(1u);
        goto LABEL_32;
      }

      int64_t v7 = v6 & 0xFFFFFFFFFFFFFFFELL;
    }
  }

  else
  {
    int64_t v7 = a2;
  }

  uint64_t v8 = *((void *)a4 + 2);
  if (v7 <= v8) {
    uint64_t v9 = *((void *)a4 + 2);
  }
  else {
    uint64_t v9 = v7;
  }
  if (v9)
  {
    uint64_t v10 = sub_100002274(&qword_100406438);
    uint64_t v11 = (char *)swift_allocObject(v10, 32 * v9 + 32, 7LL);
    int64_t v12 = j__malloc_size(v11);
    uint64_t v13 = v12 - 32;
    if (v12 < 32) {
      uint64_t v13 = v12 - 1;
    }
    *((void *)v11 + 2) = v8;
    *((void *)v11 + 3) = 2 * (v13 >> 5);
  }

  else
  {
    uint64_t v11 = (char *)_swiftEmptyArrayStorage;
  }

  uint64_t v14 = v11 + 32;
  unint64_t v15 = a4 + 32;
  if ((a1 & 1) != 0)
  {
    if (v11 != a4 || v14 >= &v15[32 * v8]) {
      memmove(v14, v15, 32 * v8);
    }
    *((void *)a4 + 2) = 0LL;
    goto LABEL_30;
  }

  if (v15 >= &v14[32 * v8] || v14 >= &v15[32 * v8])
  {
    memcpy(v14, v15, 32 * v8);
LABEL_30:
    swift_release(a4);
    return (uint64_t)v11;
  }

uint64_t sub_10006AFD8(char a1, int64_t a2, char a3, char *a4)
{
  if ((a3 & 1) != 0)
  {
    unint64_t v6 = *((void *)a4 + 3);
    int64_t v7 = v6 >> 1;
    if ((uint64_t)(v6 >> 1) < a2)
    {
      if (v7 + 0x4000000000000000LL < 0)
      {
        __break(1u);
        goto LABEL_32;
      }

      int64_t v7 = v6 & 0xFFFFFFFFFFFFFFFELL;
    }
  }

  else
  {
    int64_t v7 = a2;
  }

  uint64_t v8 = *((void *)a4 + 2);
  if (v7 <= v8) {
    uint64_t v9 = *((void *)a4 + 2);
  }
  else {
    uint64_t v9 = v7;
  }
  if (v9)
  {
    uint64_t v10 = sub_100002274(&qword_1004064C8);
    uint64_t v11 = (char *)swift_allocObject(v10, 4 * v9 + 32, 7LL);
    int64_t v12 = j__malloc_size(v11);
    uint64_t v13 = v12 - 32;
    if (v12 < 32) {
      uint64_t v13 = v12 - 29;
    }
    *((void *)v11 + 2) = v8;
    *((void *)v11 + 3) = 2 * (v13 >> 2);
  }

  else
  {
    uint64_t v11 = (char *)_swiftEmptyArrayStorage;
  }

  uint64_t v14 = v11 + 32;
  unint64_t v15 = a4 + 32;
  if ((a1 & 1) != 0)
  {
    if (v11 != a4 || v14 >= &v15[4 * v8]) {
      memmove(v14, v15, 4 * v8);
    }
    *((void *)a4 + 2) = 0LL;
    goto LABEL_30;
  }

  if (v15 >= &v14[4 * v8] || v14 >= &v15[4 * v8])
  {
    memcpy(v14, v15, 4 * v8);
LABEL_30:
    swift_release(a4);
    return (uint64_t)v11;
  }

uint64_t sub_10006B134(char a1, int64_t a2, char a3, char *a4)
{
  if ((a3 & 1) != 0)
  {
    unint64_t v6 = *((void *)a4 + 3);
    int64_t v7 = v6 >> 1;
    if ((uint64_t)(v6 >> 1) < a2)
    {
      if (v7 + 0x4000000000000000LL < 0)
      {
        __break(1u);
        goto LABEL_30;
      }

      int64_t v7 = v6 & 0xFFFFFFFFFFFFFFFELL;
    }
  }

  else
  {
    int64_t v7 = a2;
  }

  uint64_t v8 = *((void *)a4 + 2);
  if (v7 <= v8) {
    uint64_t v9 = *((void *)a4 + 2);
  }
  else {
    uint64_t v9 = v7;
  }
  if (v9)
  {
    uint64_t v10 = sub_100002274(&qword_100406428);
    uint64_t v11 = (char *)swift_allocObject(v10, 7 * v9 + 32, 7LL);
    size_t v12 = j__malloc_size(v11);
    *((void *)v11 + 2) = v8;
    *((void *)v11 + 3) = 2 * ((uint64_t)(v12 - 32) / 7);
  }

  else
  {
    uint64_t v11 = (char *)_swiftEmptyArrayStorage;
  }

  uint64_t v13 = v11 + 32;
  uint64_t v14 = a4 + 32;
  if ((a1 & 1) != 0)
  {
    if (v11 != a4 || v13 >= &v14[8 * v8 - v8]) {
      memmove(v13, v14, 7 * v8);
    }
    *((void *)a4 + 2) = 0LL;
    goto LABEL_28;
  }

  if (v14 >= &v13[7 * v8] || v13 >= &v14[7 * v8])
  {
    memcpy(v13, v14, 7 * v8);
LABEL_28:
    swift_release(a4);
    return (uint64_t)v11;
  }

uint64_t sub_10006B2B0(char a1, int64_t a2, char a3, char *a4)
{
  if ((a3 & 1) != 0)
  {
    unint64_t v6 = *((void *)a4 + 3);
    int64_t v7 = v6 >> 1;
    if ((uint64_t)(v6 >> 1) < a2)
    {
      if (v7 + 0x4000000000000000LL < 0)
      {
        __break(1u);
        goto LABEL_30;
      }

      int64_t v7 = v6 & 0xFFFFFFFFFFFFFFFELL;
    }
  }

  else
  {
    int64_t v7 = a2;
  }

  uint64_t v8 = *((void *)a4 + 2);
  if (v7 <= v8) {
    uint64_t v9 = *((void *)a4 + 2);
  }
  else {
    uint64_t v9 = v7;
  }
  if (v9)
  {
    uint64_t v10 = sub_100002274(&qword_100406430);
    uint64_t v11 = (char *)swift_allocObject(v10, 34 * v9 + 32, 7LL);
    size_t v12 = j__malloc_size(v11);
    *((void *)v11 + 2) = v8;
    *((void *)v11 + 3) = 2 * ((uint64_t)(v12 - 32) / 34);
  }

  else
  {
    uint64_t v11 = (char *)_swiftEmptyArrayStorage;
  }

  uint64_t v13 = v11 + 32;
  uint64_t v14 = a4 + 32;
  if ((a1 & 1) != 0)
  {
    if (v11 != a4 || v13 >= &v14[34 * v8]) {
      memmove(v13, v14, 34 * v8);
    }
    *((void *)a4 + 2) = 0LL;
    goto LABEL_28;
  }

  if (v14 >= &v13[34 * v8] || v13 >= &v14[34 * v8])
  {
    memcpy(v13, v14, 34 * v8);
LABEL_28:
    swift_release(a4);
    return (uint64_t)v11;
  }

uint64_t sub_10006B424(char a1, int64_t a2, char a3, char *a4)
{
  if ((a3 & 1) != 0)
  {
    unint64_t v6 = *((void *)a4 + 3);
    int64_t v7 = v6 >> 1;
    if ((uint64_t)(v6 >> 1) < a2)
    {
      if (v7 + 0x4000000000000000LL < 0)
      {
        __break(1u);
        goto LABEL_32;
      }

      int64_t v7 = v6 & 0xFFFFFFFFFFFFFFFELL;
    }
  }

  else
  {
    int64_t v7 = a2;
  }

  uint64_t v8 = *((void *)a4 + 2);
  if (v7 <= v8) {
    uint64_t v9 = *((void *)a4 + 2);
  }
  else {
    uint64_t v9 = v7;
  }
  if (v9)
  {
    uint64_t v10 = sub_100002274(&qword_100406418);
    uint64_t v11 = (char *)swift_allocObject(v10, 8 * v9 + 32, 7LL);
    int64_t v12 = j__malloc_size(v11);
    uint64_t v13 = v12 - 32;
    if (v12 < 32) {
      uint64_t v13 = v12 - 25;
    }
    *((void *)v11 + 2) = v8;
    *((void *)v11 + 3) = 2 * (v13 >> 3);
  }

  else
  {
    uint64_t v11 = (char *)_swiftEmptyArrayStorage;
  }

  uint64_t v14 = v11 + 32;
  unint64_t v15 = a4 + 32;
  if ((a1 & 1) != 0)
  {
    if (v11 != a4 || v14 >= &v15[8 * v8]) {
      memmove(v14, v15, 8 * v8);
    }
    *((void *)a4 + 2) = 0LL;
    goto LABEL_30;
  }

  if (v15 >= &v14[8 * v8] || v14 >= &v15[8 * v8])
  {
    memcpy(v14, v15, 8 * v8);
LABEL_30:
    swift_release(a4);
    return (uint64_t)v11;
  }

uint64_t sub_10006B580(char a1, int64_t a2, char a3, void *a4)
{
  if ((a3 & 1) != 0)
  {
    unint64_t v6 = a4[3];
    int64_t v7 = v6 >> 1;
    if ((uint64_t)(v6 >> 1) < a2)
    {
      if (v7 + 0x4000000000000000LL < 0)
      {
        __break(1u);
        goto LABEL_32;
      }

      int64_t v7 = v6 & 0xFFFFFFFFFFFFFFFELL;
    }
  }

  else
  {
    int64_t v7 = a2;
  }

  uint64_t v8 = a4[2];
  if (v7 <= v8) {
    uint64_t v9 = a4[2];
  }
  else {
    uint64_t v9 = v7;
  }
  if (v9)
  {
    uint64_t v10 = sub_100002274(&qword_100406400);
    uint64_t v11 = (void *)swift_allocObject(v10, 8 * v9 + 32, 7LL);
    int64_t v12 = j__malloc_size(v11);
    uint64_t v13 = v12 - 32;
    if (v12 < 32) {
      uint64_t v13 = v12 - 25;
    }
    v11[2] = v8;
    v11[3] = 2 * (v13 >> 3);
  }

  else
  {
    uint64_t v11 = _swiftEmptyArrayStorage;
  }

  unint64_t v14 = (unint64_t)(v11 + 4);
  unint64_t v15 = (unint64_t)(a4 + 4);
  if ((a1 & 1) != 0)
  {
    if (v11 != a4 || v14 >= v15 + 8 * v8) {
      memmove(v11 + 4, a4 + 4, 8 * v8);
    }
    a4[2] = 0LL;
    goto LABEL_30;
  }

  if (v15 >= v14 + 8 * v8 || v14 >= v15 + 8 * v8)
  {
    sub_100002274((uint64_t *)&unk_10040D5A0);
    swift_arrayInitWithCopy(v11 + 4);
LABEL_30:
    swift_release(a4);
    return (uint64_t)v11;
  }

uint64_t sub_10006B708(char a1, int64_t a2, char a3, char *a4)
{
  if ((a3 & 1) != 0)
  {
    unint64_t v6 = *((void *)a4 + 3);
    int64_t v7 = v6 >> 1;
    if ((uint64_t)(v6 >> 1) < a2)
    {
      if (v7 + 0x4000000000000000LL < 0)
      {
        __break(1u);
        goto LABEL_32;
      }

      int64_t v7 = v6 & 0xFFFFFFFFFFFFFFFELL;
    }
  }

  else
  {
    int64_t v7 = a2;
  }

  uint64_t v8 = *((void *)a4 + 2);
  if (v7 <= v8) {
    uint64_t v9 = *((void *)a4 + 2);
  }
  else {
    uint64_t v9 = v7;
  }
  if (v9)
  {
    uint64_t v10 = sub_100002274(&qword_1004063F8);
    uint64_t v11 = (char *)swift_allocObject(v10, 2 * v9 + 32, 7LL);
    int64_t v12 = j__malloc_size(v11);
    int64_t v13 = v12 - 32;
    if (v12 < 32) {
      int64_t v13 = v12 - 31;
    }
    *((void *)v11 + 2) = v8;
    *((void *)v11 + 3) = v13 & 0xFFFFFFFFFFFFFFFELL;
  }

  else
  {
    uint64_t v11 = (char *)_swiftEmptyArrayStorage;
  }

  unint64_t v14 = v11 + 32;
  unint64_t v15 = a4 + 32;
  if ((a1 & 1) != 0)
  {
    if (v11 != a4 || v14 >= &v15[2 * v8]) {
      memmove(v14, v15, 2 * v8);
    }
    *((void *)a4 + 2) = 0LL;
    goto LABEL_30;
  }

  if (v15 >= &v14[2 * v8] || v14 >= &v15[2 * v8])
  {
    memcpy(v14, v15, 2 * v8);
LABEL_30:
    swift_release(a4);
    return (uint64_t)v11;
  }

uint64_t sub_10006B860(char a1, int64_t a2, char a3, void *a4)
{
  if ((a3 & 1) != 0)
  {
    unint64_t v6 = a4[3];
    int64_t v7 = v6 >> 1;
    if ((uint64_t)(v6 >> 1) < a2)
    {
      if (v7 + 0x4000000000000000LL < 0)
      {
        __break(1u);
        goto LABEL_30;
      }

      int64_t v7 = v6 & 0xFFFFFFFFFFFFFFFELL;
    }
  }

  else
  {
    int64_t v7 = a2;
  }

  uint64_t v8 = a4[2];
  if (v7 <= v8) {
    uint64_t v9 = a4[2];
  }
  else {
    uint64_t v9 = v7;
  }
  if (v9)
  {
    uint64_t v10 = sub_100002274(&qword_1004063E0);
    uint64_t v11 = (void *)swift_allocObject(v10, 24 * v9 + 32, 7LL);
    size_t v12 = j__malloc_size(v11);
    v11[2] = v8;
    v11[3] = 2 * ((uint64_t)(v12 - 32) / 24);
  }

  else
  {
    uint64_t v11 = _swiftEmptyArrayStorage;
  }

  unint64_t v13 = (unint64_t)(v11 + 4);
  unint64_t v14 = (unint64_t)(a4 + 4);
  if ((a1 & 1) != 0)
  {
    if (v11 != a4 || v13 >= v14 + 24 * v8) {
      memmove(v11 + 4, a4 + 4, 24 * v8);
    }
    a4[2] = 0LL;
    goto LABEL_28;
  }

  if (v14 >= v13 + 24 * v8 || v13 >= v14 + 24 * v8)
  {
    sub_100002274(&qword_1004063E8);
    swift_arrayInitWithCopy(v11 + 4);
LABEL_28:
    swift_release(a4);
    return (uint64_t)v11;
  }

uint64_t sub_10006BA04(char a1, int64_t a2, char a3, void *a4)
{
  if ((a3 & 1) != 0)
  {
    unint64_t v6 = a4[3];
    int64_t v7 = v6 >> 1;
    if ((uint64_t)(v6 >> 1) < a2)
    {
      if (v7 + 0x4000000000000000LL < 0)
      {
        __break(1u);
        goto LABEL_30;
      }

      int64_t v7 = v6 & 0xFFFFFFFFFFFFFFFELL;
    }
  }

  else
  {
    int64_t v7 = a2;
  }

  uint64_t v8 = a4[2];
  if (v7 <= v8) {
    uint64_t v9 = a4[2];
  }
  else {
    uint64_t v9 = v7;
  }
  if (v9)
  {
    uint64_t v10 = sub_100002274(&qword_100406390);
    uint64_t v11 = (void *)swift_allocObject(v10, 48 * v9 + 32, 7LL);
    size_t v12 = j__malloc_size(v11);
    v11[2] = v8;
    v11[3] = 2 * ((uint64_t)(v12 - 32) / 48);
  }

  else
  {
    uint64_t v11 = _swiftEmptyArrayStorage;
  }

  unint64_t v13 = (unint64_t)(v11 + 4);
  unint64_t v14 = (unint64_t)(a4 + 4);
  if ((a1 & 1) != 0)
  {
    if (v11 != a4 || v13 >= v14 + 48 * v8) {
      memmove(v11 + 4, a4 + 4, 48 * v8);
    }
    a4[2] = 0LL;
    goto LABEL_28;
  }

  if (v14 >= v13 + 48 * v8 || v13 >= v14 + 48 * v8)
  {
    sub_100002274(&qword_100406398);
    swift_arrayInitWithCopy(v11 + 4);
LABEL_28:
    swift_release(a4);
    return (uint64_t)v11;
  }

uint64_t sub_10006BBA8( char a1, int64_t a2, char a3, void *a4, uint64_t *a5, uint64_t (*a6)(void))
{
  if ((a3 & 1) != 0)
  {
    unint64_t v9 = a4[3];
    int64_t v10 = v9 >> 1;
    if ((uint64_t)(v9 >> 1) < a2)
    {
      if (v10 + 0x4000000000000000LL < 0)
      {
LABEL_35:
        __break(1u);
        goto LABEL_36;
      }

      int64_t v10 = v9 & 0xFFFFFFFFFFFFFFFELL;
    }
  }

  else
  {
    int64_t v10 = a2;
  }

  uint64_t v11 = a4[2];
  if (v10 <= v11) {
    uint64_t v12 = a4[2];
  }
  else {
    uint64_t v12 = v10;
  }
  if (!v12)
  {
    uint64_t v18 = _swiftEmptyArrayStorage;
    goto LABEL_19;
  }

  uint64_t v13 = sub_100002274(a5);
  uint64_t v14 = *(void *)(a6(0LL) - 8);
  uint64_t v15 = *(void *)(v14 + 72);
  uint64_t v16 = *(unsigned __int8 *)(v14 + 80);
  uint64_t v17 = (v16 + 32) & ~v16;
  uint64_t v18 = (void *)swift_allocObject(v13, v17 + v15 * v12, v16 | 7);
  size_t v19 = j__malloc_size(v18);
  if (!v15)
  {
    __break(1u);
LABEL_34:
    __break(1u);
    goto LABEL_35;
  }

  if (v19 - v17 == 0x8000000000000000LL && v15 == -1) {
    goto LABEL_34;
  }
  v18[2] = v11;
  v18[3] = 2 * ((uint64_t)(v19 - v17) / v15);
LABEL_19:
  uint64_t v21 = a6(0LL);
  uint64_t v22 = *(void *)(v21 - 8);
  unint64_t v23 = (*(unsigned __int8 *)(v22 + 80) + 32LL) & ~(unint64_t)*(unsigned __int8 *)(v22 + 80);
  uint64_t v24 = (char *)v18 + v23;
  unint64_t v25 = (char *)a4 + v23;
  if ((a1 & 1) != 0)
  {
    if (v18 < a4 || v24 >= &v25[*(void *)(v22 + 72) * v11])
    {
      swift_arrayInitWithTakeFrontToBack(v24, v25, v11, v21);
    }

    else if (v18 != a4)
    {
      swift_arrayInitWithTakeBackToFront();
    }

    a4[2] = 0LL;
    goto LABEL_32;
  }

  uint64_t v26 = *(void *)(v22 + 72) * v11;
  uint64_t v27 = &v24[v26];
  unint64_t v28 = (unint64_t)&v25[v26];
  if (v25 >= v27 || (unint64_t)v24 >= v28)
  {
    swift_arrayInitWithCopy(v24);
LABEL_32:
    swift_release(a4);
    return (uint64_t)v18;
  }

uint64_t sub_10006BD88(char a1, int64_t a2, char a3, char *a4)
{
  if ((a3 & 1) != 0)
  {
    unint64_t v6 = *((void *)a4 + 3);
    int64_t v7 = v6 >> 1;
    if ((uint64_t)(v6 >> 1) < a2)
    {
      if (v7 + 0x4000000000000000LL < 0)
      {
        __break(1u);
        goto LABEL_32;
      }

      int64_t v7 = v6 & 0xFFFFFFFFFFFFFFFELL;
    }
  }

  else
  {
    int64_t v7 = a2;
  }

  uint64_t v8 = *((void *)a4 + 2);
  if (v7 <= v8) {
    uint64_t v9 = *((void *)a4 + 2);
  }
  else {
    uint64_t v9 = v7;
  }
  if (v9)
  {
    uint64_t v10 = sub_100002274(&qword_100406388);
    uint64_t v11 = (char *)swift_allocObject(v10, 32 * v9 + 32, 7LL);
    int64_t v12 = j__malloc_size(v11);
    uint64_t v13 = v12 - 32;
    if (v12 < 32) {
      uint64_t v13 = v12 - 1;
    }
    *((void *)v11 + 2) = v8;
    *((void *)v11 + 3) = 2 * (v13 >> 5);
  }

  else
  {
    uint64_t v11 = (char *)_swiftEmptyArrayStorage;
  }

  uint64_t v14 = v11 + 32;
  uint64_t v15 = a4 + 32;
  if ((a1 & 1) != 0)
  {
    if (v11 != a4 || v14 >= &v15[32 * v8]) {
      memmove(v14, v15, 32 * v8);
    }
    *((void *)a4 + 2) = 0LL;
    goto LABEL_30;
  }

  if (v15 >= &v14[32 * v8] || v14 >= &v15[32 * v8])
  {
    swift_arrayInitWithCopy(v14);
LABEL_30:
    swift_release(a4);
    return (uint64_t)v11;
  }

uint64_t sub_10006BEF0(char a1, int64_t a2, char a3, void *a4)
{
  if ((a3 & 1) != 0)
  {
    unint64_t v6 = a4[3];
    int64_t v7 = v6 >> 1;
    if ((uint64_t)(v6 >> 1) < a2)
    {
      if (v7 + 0x4000000000000000LL < 0)
      {
        __break(1u);
        goto LABEL_30;
      }

      int64_t v7 = v6 & 0xFFFFFFFFFFFFFFFELL;
    }
  }

  else
  {
    int64_t v7 = a2;
  }

  uint64_t v8 = a4[2];
  if (v7 <= v8) {
    uint64_t v9 = a4[2];
  }
  else {
    uint64_t v9 = v7;
  }
  if (v9)
  {
    uint64_t v10 = sub_100002274(&qword_100406370);
    uint64_t v11 = (void *)swift_allocObject(v10, 24 * v9 + 32, 7LL);
    size_t v12 = j__malloc_size(v11);
    v11[2] = v8;
    v11[3] = 2 * ((uint64_t)(v12 - 32) / 24);
  }

  else
  {
    uint64_t v11 = _swiftEmptyArrayStorage;
  }

  unint64_t v13 = (unint64_t)(v11 + 4);
  unint64_t v14 = (unint64_t)(a4 + 4);
  if ((a1 & 1) != 0)
  {
    if (v11 != a4 || v13 >= v14 + 24 * v8) {
      memmove(v11 + 4, a4 + 4, 24 * v8);
    }
    a4[2] = 0LL;
    goto LABEL_28;
  }

  if (v14 >= v13 + 24 * v8 || v13 >= v14 + 24 * v8)
  {
    sub_100002274(&qword_100406378);
    swift_arrayInitWithCopy(v11 + 4);
LABEL_28:
    swift_release(a4);
    return (uint64_t)v11;
  }

void sub_10006C098(__int128 *a1, uint64_t a2)
{
  v73 = a1;
  uint64_t v3 = type metadata accessor for DispatchTimeInterval(0LL);
  uint64_t v4 = *(void *)(v3 - 8);
  __chkstk_darwin(v3);
  unint64_t v6 = (uint64_t *)((char *)&v58 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0LL));
  uint64_t v72 = type metadata accessor for NANInternetSharingStatistics.Requester(0LL);
  uint64_t v66 = *(void *)(v72 - 8);
  __chkstk_darwin(v72);
  uint64_t v77 = (uint64_t)&v58 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v8 = sub_100002274(&qword_1004063D0);
  uint64_t v9 = __chkstk_darwin(v8);
  uint64_t v11 = (char *)&v58 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  __chkstk_darwin(v9);
  unint64_t v13 = (Swift::UInt8 *)&v58 - v12;
  uint64_t v14 = *(void *)(a2 + 64);
  uint64_t v63 = a2 + 64;
  uint64_t v15 = 1LL << *(_BYTE *)(a2 + 32);
  uint64_t v16 = -1LL;
  if (v15 < 64) {
    uint64_t v16 = ~(-1LL << v15);
  }
  unint64_t v17 = v16 & v14;
  int v70 = enum case for DispatchTimeInterval.seconds(_:);
  int v64 = enum case for DispatchTimeInterval.milliseconds(_:);
  int v62 = enum case for DispatchTimeInterval.microseconds(_:);
  int v61 = enum case for DispatchTimeInterval.nanoseconds(_:);
  int v60 = enum case for DispatchTimeInterval.never(_:);
  int64_t v65 = (unint64_t)(v15 + 63) >> 6;
  int64_t v59 = v65 - 1;
  uint64_t v67 = a2;
  swift_bridgeObjectRetain(a2);
  Swift::UInt v18 = 0LL;
  int64_t v74 = 0LL;
  uint64_t v71 = v4;
  v68 = v13;
  v69 = v11;
  while (1)
  {
    Swift::UInt v78 = v18;
    if (v17)
    {
      uint64_t v76 = (v17 - 1) & v17;
      unint64_t v27 = __clz(__rbit64(v17)) | (v74 << 6);
      goto LABEL_14;
    }

    int64_t v33 = v74 + 1;
    if (__OFADD__(v74, 1LL))
    {
      __break(1u);
      goto LABEL_48;
    }

    if (v33 < v65)
    {
      unint64_t v34 = *(void *)(v63 + 8 * v33);
      if (v34) {
        goto LABEL_18;
      }
      int64_t v35 = v74 + 2;
      ++v74;
      if (v33 + 1 < v65)
      {
        unint64_t v34 = *(void *)(v63 + 8 * v35);
        if (v34)
        {
          ++v33;
          goto LABEL_18;
        }

        int64_t v36 = v33 + 2;
        int64_t v74 = v33 + 1;
        if (v33 + 2 < v65) {
          break;
        }
      }
    }

LABEL_11:
    Hasher._combine(_:)(v25);
    uint64_t v26 = v77;
    Hasher._combine(_:)(*(_BYTE *)(v77 + *(int *)(v72 + 20)));
    sub_10005802C(v26, type metadata accessor for NANInternetSharingStatistics.Requester);
    Swift::UInt v18 = Hasher._finalize()() ^ v78;
    unint64_t v17 = v76;
  }

  unint64_t v34 = *(void *)(v63 + 8 * v36);
  if (v34)
  {
    v33 += 2LL;
LABEL_18:
    uint64_t v76 = (v34 - 1) & v34;
    unint64_t v27 = __clz(__rbit64(v34)) + (v33 << 6);
    int64_t v74 = v33;
LABEL_14:
    uint64_t v28 = *(void *)(v67 + 48) - v27 + 8 * v27;
    __int16 v29 = *(_WORD *)(v28 + 4);
    char v30 = *(_BYTE *)(v28 + 6);
    uint64_t v31 = *(void *)(v67 + 56) + *(void *)(v66 + 72) * v27;
    uint64_t v32 = sub_100002274(&qword_1004063D8);
    LODWORD(v28) = *(_DWORD *)v28;
    sub_100057FE8( v31,  (uint64_t)&v11[*(int *)(v32 + 48)],  type metadata accessor for NANInternetSharingStatistics.Requester);
    *(_DWORD *)uint64_t v11 = v28;
    *((_WORD *)v11 + 2) = v29;
    v11[6] = v30;
    (*(void (**)(char *, void, uint64_t, uint64_t))(*(void *)(v32 - 8) + 56LL))(v11, 0LL, 1LL, v32);
    goto LABEL_31;
  }

  while (1)
  {
    int64_t v33 = v36 + 1;
    if (__OFADD__(v36, 1LL)) {
      break;
    }
    if (v33 >= v65)
    {
      int64_t v74 = v59;
      goto LABEL_30;
    }

    unint64_t v34 = *(void *)(v63 + 8 * v33);
    ++v36;
    if (v34) {
      goto LABEL_18;
    }
  }

  uint64_t v5 = __CFADD__(a1, a2 << 7);
  uint64_t result = a1 + (a2 << 7);
  if (v5)
  {
LABEL_14:
    __break(1u);
    goto LABEL_15;
  }

  return result;
}

  uint64_t v5 = __CFADD__(a1, 16 * a2);
  uint64_t result = a1 + 16 * a2;
  if (v5)
  {
LABEL_14:
    __break(1u);
    goto LABEL_15;
  }

  return result;
}

      a2 = (a2 + 1) & v41;
      if (((*(void *)(v42 + ((a2 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> a2) & 1) == 0) {
        goto LABEL_25;
      }
    }

    unint64_t v17 = v18;
    sub_10005802C((uint64_t)v10, v18);
    goto LABEL_11;
  }
      }
    }
  }

      Swift::UInt v18 = 0LL;
      uint64_t v19 = 0;
      goto LABEL_12;
    }

    if (v16 >= v14 && (a3 & 1) == 0)
    {
      sub_10013C6E0();
      goto LABEL_7;
    }

    sub_100136EC0(v14, a3 & 1);
    uint64_t v20 = sub_10001C214(a2);
    if ((v15 & 1) == (v21 & 1))
    {
      uint64_t v11 = v20;
      v8[4] = v20;
      if ((v15 & 1) != 0) {
        goto LABEL_8;
      }
      goto LABEL_11;
    }
  }

  uint64_t result = (void (*)(uint64_t *))KEY_TYPE_OF_DICTIONARY_VIOLATES_HASHABLE_REQUIREMENTS(_:)(&type metadata for DNSRecords.PTR);
  __break(1u);
  return result;
}

      BOOL v22 = sub_100002274((uint64_t *)&unk_1004050D0);
      BOOL v23 = *(void *)(v22 - 8);
      unint64_t v24 = 1LL;
      goto LABEL_12;
    }

    if (v20 >= v18 && (a4 & 1) == 0)
    {
      sub_10013D260();
      goto LABEL_7;
    }

    sub_100138518(v18, a4 & 1);
    Swift::UInt64 v25 = sub_10001C4F8(a2, a3);
    if ((v19 & 1) == (v26 & 1))
    {
      uint64_t v15 = v25;
      v10[4] = v25;
      if ((v19 & 1) != 0) {
        goto LABEL_8;
      }
      goto LABEL_11;
    }
  }

  uint64_t result = (void (*)(uint64_t **))KEY_TYPE_OF_DICTIONARY_VIOLATES_HASHABLE_REQUIREMENTS(_:)(&type metadata for NANServiceName);
  __break(1u);
  return result;
}

    v23[(v16 >> 6) + 8] |= 1LL << v16;
    unint64_t v27 = (uint64_t *)(v23[6] + 16 * v16);
    *unint64_t v27 = v12;
    v27[1] = v13;
    *(void *)(v23[7] + 8 * v16) = v56;
    uint64_t v28 = v23[2];
    __int16 v29 = __OFADD__(v28, 1LL);
    char v30 = v28 + 1;
    if (v29)
    {
LABEL_25:
      __break(1u);
      goto LABEL_26;
    }

    v23[2] = v30;
LABEL_13:
    sub_10018D19C();
    if (v32)
    {
      unint64_t v34 = v31;
      int64_t v35 = v32;
      int64_t v36 = v33;
      do
      {
        uint64_t v43 = (void *)*a5;
        Swift::UInt8 v44 = sub_10001C008(v34, v35);
        Swift::UInt8 v46 = v43[2];
        Swift::UInt8 v47 = (v45 & 1) == 0;
        __int16 v29 = __OFADD__(v46, v47);
        uint64_t v48 = v46 + v47;
        if (v29) {
          goto LABEL_24;
        }
        uint64_t v49 = v45;
        if (v43[3] < v48)
        {
          sub_100139230(v48, 1LL);
          Swift::UInt8 v44 = sub_10001C008(v34, v35);
          if ((v49 & 1) != (v50 & 1)) {
            goto LABEL_26;
          }
        }

        __int128 v51 = (void *)*a5;
        if ((v49 & 1) != 0)
        {
          uint64_t v37 = 8 * v44;
          uint64_t v38 = *(id *)(v51[7] + 8 * v44);
          swift_bridgeObjectRelease(v35);

          uint64_t v39 = v51[7];
          *(void *)(v39 + v37) = v38;
        }

        else
        {
          v51[(v44 >> 6) + 8] |= 1LL << v44;
          Swift::UInt8 v52 = (uint64_t *)(v51[6] + 16 * v44);
          *Swift::UInt8 v52 = v34;
          v52[1] = v35;
          *(void *)(v51[7] + 8 * v44) = v36;
          Swift::UInt8 v53 = v51[2];
          __int16 v29 = __OFADD__(v53, 1LL);
          Swift::UInt8 v54 = v53 + 1;
          if (v29) {
            goto LABEL_25;
          }
          v51[2] = v54;
        }

        sub_10018D19C();
        unint64_t v34 = v40;
        int64_t v35 = v41;
        int64_t v36 = v42;
      }

      while (v41);
    }

  uint64_t result = _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  "Not enough bits to represent the passed value",  45LL,  2LL,  "Swift/Integers.swift",  20LL,  2,  3455LL,  0);
LABEL_17:
  __break(1u);
  return result;
}

  uint64_t result = _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  "Not enough bits to represent the passed value",  45LL,  2LL,  "Swift/Integers.swift",  20LL,  2,  3455LL,  0);
LABEL_17:
  __break(1u);
  return result;
}

  __break(1u);
  return result;
}

  __break(1u);
  return result;
}

  __break(1u);
  return result;
}

  uint64_t result = _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  "Not enough bits to represent the passed value",  45LL,  2LL,  "Swift/Integers.swift",  20LL,  2,  3455LL,  0);
LABEL_17:
  __break(1u);
  return result;
}

  __break(1u);
  return result;
}

  __break(1u);
  return result;
}

  __break(1u);
  return result;
}

  __break(1u);
  return result;
}

    v15[(v9 >> 6) + 8] |= 1LL << v9;
    unint64_t v17 = 8 * v9;
    *(void *)(v15[6] + v17) = a2;
    *(void *)(v15[7] + v17) = a1;
    Swift::UInt v18 = v15[2];
    uint64_t v19 = __OFADD__(v18, 1LL);
    uint64_t v20 = v18 + 1;
    if (!v19)
    {
      v15[2] = v20;
      return a2;
    }

    goto LABEL_14;
  }

  sub_100240168((uint64_t)result, a3 & 1);
  uint64_t result = (id)sub_1003277F4((uint64_t)a2);
  if ((v13 & 1) == (v16 & 1))
  {
    uint64_t v9 = (unint64_t)result;
    uint64_t v15 = (void *)*v4;
    if ((v13 & 1) != 0) {
      goto LABEL_8;
    }
    goto LABEL_11;
  }

    v18[(v12 >> 6) + 8] |= 1LL << v12;
    BOOL v22 = (uint64_t *)(v18[6] + 16 * v12);
    *BOOL v22 = a2;
    v22[1] = a3;
    *(void *)(v18[7] + 8 * v12) = a1;
    BOOL v23 = v18[2];
    unint64_t v24 = __OFADD__(v23, 1LL);
    Swift::UInt64 v25 = v23 + 1;
    if (!v24)
    {
      v18[2] = v25;
      swift_bridgeObjectRetain(a3);
      return;
    }

    goto LABEL_14;
  }

  sub_100240B10(v15, a4 & 1);
  uint64_t v20 = sub_10001C008(a2, a3);
  if ((v16 & 1) == (v21 & 1))
  {
    uint64_t v12 = v20;
    Swift::UInt v18 = (void *)*v5;
    if ((v16 & 1) != 0) {
      goto LABEL_8;
    }
    goto LABEL_11;
  }

    swift_unownedRetainStrong(v11);
    sub_1002EABC0();
    swift_release(v11);
    *(void *)uint64_t v8 = 5LL;
    unint64_t v27 = *(void (**)(char *, uint64_t, uint64_t))(v4 + 104);
    v27(v8, v23, v3);
    uint64_t v28 = static DispatchTimeInterval.< infix(_:_:)((uint64_t)v10, (uint64_t)v8);
    __int16 v29 = *(void (**)(char *, uint64_t))(v4 + 8);
    v29(v8, v3);
    v29(v10, v3);
    if (v28) {
      goto LABEL_13;
    }
    swift_unownedRetainStrong(v11);
    sub_1002EAA14((uint64_t)v10);
    swift_release(v11);
    *(void *)uint64_t v8 = 5LL;
    v27(v8, v23, v3);
    char v30 = static DispatchTimeInterval.< infix(_:_:)((uint64_t)v10, (uint64_t)v8);
    v29(v8, v3);
    v29(v10, v3);
    if (v30)
    {
LABEL_13:
      LOBYTE(v22) = *((_BYTE *)v1 + 16);
      uint64_t v26 = 3;
    }

    else
    {
      if (*((_BYTE *)v1 + 16) != 1
        || (sub_10028C4AC(),
            *(void *)uint64_t v8 = 8LL,
            v27(v8, v23, v3),
            uint64_t v31 = static DispatchTimeInterval.< infix(_:_:)((uint64_t)v10, (uint64_t)v8),
            v29(v8, v3),
            v29(v10, v3),
            !v31))
      {
        sub_10028C4AC();
        __asm { BR              X10 }
      }

      LOBYTE(v22) = *((_BYTE *)v1 + 16);
      uint64_t v26 = 2;
    }

    goto LABEL_14;
  }

            uint64_t v19 = v94;
            uint64_t v20 = v95;
            uint64_t v11 = v87;
            Swift::UInt v18 = v86;
          }

          ++v19;
        }

        while (v19 != v18);
      }

      swift_bridgeObjectRelease(v11);
      __int128 v81 = v12[2];
      if (v81)
      {
        sub_100002274(&qword_10040CD10);
        __int128 v82 = (void *)static _DictionaryStorage.allocate(capacity:)(v81);
      }

      else
      {
        __int128 v82 = &_swiftEmptyDictionarySingleton;
      }

      v107[0] = (uint64_t)v82;
      uint64_t v83 = swift_bridgeObjectRetain(v12);
      sub_1002A026C(v83, 1, v107);
      v84 = (uint64_t)v12;
      if (v6)
      {
LABEL_115:
        swift_bridgeObjectRelease(v84);
        uint64_t result = swift_release(v107[0]);
        __break(1u);
      }

      else
      {
        swift_bridgeObjectRelease_n(v12, 2LL);
        v85 = *(void *)(v95 + 24);
        *(void *)(v95 + 24) = v107[0];
        sub_10028D52C(v85);
        return swift_bridgeObjectRelease(v85);
      }
    }
  }

  return result;
}

      uint64_t v10 = _StringObject.sharedUTF8.getter(v5, a4);
      if (!v10) {
        return static String._uncheckedFromUTF8(_:)(v10, v9 - v8);
      }
      goto LABEL_5;
    }

    v15[0] = a3;
    v15[1] = a4 & 0xFFFFFFFFFFFFFFLL;
    return static String._uncheckedFromUTF8(_:)((char *)v15 + v8, v9 - v8);
  }

      uint64_t v19 = type metadata accessor for NANPeer.Service(0LL);
      uint64_t v20 = *(void *)(v19 - 8);
      Swift::UInt64 v21 = 1LL;
      goto LABEL_12;
    }

    if (v17 >= v15 && (a3 & 1) == 0)
    {
      sub_10032ADA0();
      goto LABEL_7;
    }

    sub_100241120(v15, a3 & 1);
    BOOL v22 = sub_100327958(a2);
    if ((v16 & 1) == (v23 & 1))
    {
      uint64_t v12 = v22;
      *(void *)(a1 + 16) = v22;
      if ((v16 & 1) != 0) {
        goto LABEL_8;
      }
      goto LABEL_11;
    }
  }

  uint64_t result = (void (*)(uint64_t))KEY_TYPE_OF_DICTIONARY_VIOLATES_HASHABLE_REQUIREMENTS(_:)(&type metadata for UInt8);
  __break(1u);
  return result;
}

      unint64_t v17 = 0LL;
      goto LABEL_12;
    }

    if (v16 >= v14 && (a3 & 1) == 0)
    {
      sub_10032C37C();
      goto LABEL_7;
    }

    sub_1002435A0(v14, a3 & 1);
    Swift::UInt v18 = sub_10001C578(a2);
    if ((v15 & 1) == (v19 & 1))
    {
      uint64_t v11 = v18;
      v8[3] = v18;
      if ((v15 & 1) != 0) {
        goto LABEL_8;
      }
      goto LABEL_11;
    }
  }

  Swift::UInt64 v21 = type metadata accessor for UUID(0LL);
  uint64_t result = (void (*)(uint64_t **))KEY_TYPE_OF_DICTIONARY_VIOLATES_HASHABLE_REQUIREMENTS(_:)(v21);
  __break(1u);
  return result;
}

      uint64_t v16 = 0LL;
      goto LABEL_12;
    }

    if (v15 >= v13 && (a3 & 1) == 0)
    {
      sub_100329D88();
      goto LABEL_7;
    }

    sub_10023F470(v13, a3 & 1);
    unint64_t v17 = sub_100327790(a2);
    if ((v14 & 1) == (v18 & 1))
    {
      uint64_t v10 = v17;
      *(void *)(a1 + 16) = v17;
      if ((v14 & 1) != 0) {
        goto LABEL_8;
      }
      goto LABEL_11;
    }
  }

  uint64_t result = (unint64_t (*)(unint64_t))KEY_TYPE_OF_DICTIONARY_VIOLATES_HASHABLE_REQUIREMENTS(_:)(&type metadata for NANAttribute.AttributeType);
  __break(1u);
  return result;
}

      Swift::UInt v18 = 0LL;
      goto LABEL_12;
    }

    if (v17 >= v15 && (a3 & 1) == 0)
    {
      sub_100329F28();
      goto LABEL_7;
    }

    sub_10023F748(v15, a3 & 1);
    uint64_t v19 = sub_10001C15C(v10);
    if ((v16 & 1) == (v20 & 1))
    {
      uint64_t v12 = v19;
      v8[3] = v19;
      if ((v16 & 1) != 0) {
        goto LABEL_8;
      }
      goto LABEL_11;
    }
  }

  uint64_t result = (void (*)(uint64_t **))KEY_TYPE_OF_DICTIONARY_VIOLATES_HASHABLE_REQUIREMENTS(_:)(&type metadata for WiFiAddress);
  __break(1u);
  return result;
}

    uint64_t v19 = 0;
    return v19 & 1;
  }

  unint64_t v17 = v15;
  Swift::UInt v18 = _stringCompareWithSmolCheck(_:_:expecting:)(v11, v13, v14, v15, 0LL);

  swift_bridgeObjectRelease(v13);
  swift_bridgeObjectRelease(v17);
  if ((v18 & 1) == 0) {
    goto LABEL_14;
  }
  uint64_t v19 = 0;
  if (a3) {
    goto LABEL_14;
  }
  return v19 & 1;
}

void sub_10006C6D0(__int128 *a1, uint64_t a2)
{
  uint64_t v4 = type metadata accessor for NANGenericServiceProtocol.Attribute(0LL);
  uint64_t v41 = *(void *)(v4 - 8);
  __chkstk_darwin(v4);
  unint64_t v6 = (char *)&v38 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v7 = sub_100002274(&qword_1004064B8);
  uint64_t v8 = __chkstk_darwin(v7);
  uint64_t v10 = (char *)&v38 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  __chkstk_darwin(v8);
  uint64_t v12 = (char *)&v38 - v11;
  uint64_t v13 = *(void *)(a2 + 64);
  uint64_t v39 = a2 + 64;
  uint64_t v14 = 1LL << *(_BYTE *)(a2 + 32);
  uint64_t v15 = -1LL;
  if (v14 < 64) {
    uint64_t v15 = ~(-1LL << v14);
  }
  unint64_t v16 = v15 & v13;
  int64_t v40 = (unint64_t)(v14 + 63) >> 6;
  int64_t v38 = v40 - 1;
  uint64_t v42 = a2;
  swift_bridgeObjectRetain(a2);
  Swift::UInt v17 = 0LL;
  int64_t v43 = 0LL;
  Swift::UInt v18 = (uint64_t *)&unk_100406238;
  if (!v16) {
    goto LABEL_6;
  }
LABEL_4:
  unint64_t v19 = __clz(__rbit64(v16));
  v16 &= v16 - 1;
  unint64_t v20 = v19 | (v43 << 6);
LABEL_5:
  char v21 = *(_BYTE *)(*(void *)(v42 + 48) + v20);
  uint64_t v22 = *(void *)(v42 + 56) + *(void *)(v41 + 72) * v20;
  BOOL v23 = v18;
  uint64_t v24 = sub_100002274(v18);
  sub_100057FE8(v22, (uint64_t)&v10[*(int *)(v24 + 48)], type metadata accessor for NANGenericServiceProtocol.Attribute);
  *uint64_t v10 = v21;
  Swift::UInt64 v25 = *(void (**)(_BYTE *, void, uint64_t, uint64_t))(*(void *)(v24 - 8) + 56LL);
  uint64_t v26 = v24;
  Swift::UInt v18 = v23;
  v25(v10, 0LL, 1LL, v26);
  while (1)
  {
    sub_1000586C0((uint64_t)v10, (uint64_t)v12, &qword_1004064B8);
    uint64_t v32 = sub_100002274(v18);
    if ((*(unsigned int (**)(char *, uint64_t, uint64_t))(*(void *)(v32 - 8) + 48LL))(v12, 1LL, v32) == 1)
    {
      swift_release(v42);
      Hasher._combine(_:)(v17);
      return;
    }

    uint64_t v33 = (uint64_t)&v12[*(int *)(v32 + 48)];
    char v34 = *v12;
    sub_100022628(v33, (uint64_t)v6, type metadata accessor for NANGenericServiceProtocol.Attribute);
    uint64_t v35 = *((void *)a1 + 8);
    __int128 v36 = a1[1];
    __int128 v44 = *a1;
    __int128 v45 = v36;
    __int128 v37 = a1[3];
    __int128 v46 = a1[2];
    __int128 v47 = v37;
    uint64_t v48 = v35;
    Hasher._combine(_:)(0xDD06050403020100LL >> (8 * v34));
    sub_1000641D0();
    sub_10005802C((uint64_t)v6, type metadata accessor for NANGenericServiceProtocol.Attribute);
    v17 ^= Hasher._finalize()();
    if (v16) {
      goto LABEL_4;
    }
LABEL_6:
    int64_t v27 = v43 + 1;
    if (__OFADD__(v43, 1LL))
    {
      __break(1u);
      goto LABEL_27;
    }

    if (v27 < v40)
    {
      unint64_t v28 = *(void *)(v39 + 8 * v27);
      if (v28) {
        goto LABEL_9;
      }
      int64_t v29 = v43 + 2;
      ++v43;
      if (v27 + 1 < v40)
      {
        unint64_t v28 = *(void *)(v39 + 8 * v29);
        if (v28)
        {
          ++v27;
LABEL_9:
          unint64_t v16 = (v28 - 1) & v28;
          unint64_t v20 = __clz(__rbit64(v28)) + (v27 << 6);
          int64_t v43 = v27;
          goto LABEL_5;
        }

        int64_t v30 = v27 + 2;
        int64_t v43 = v27 + 1;
        if (v27 + 2 < v40) {
          break;
        }
      }
    }

void sub_10006CA4C(uint64_t a1, uint64_t a2)
{
  Swift::UInt64 v25 = (char *)a2;
  uint64_t v24 = a1;
  uint64_t v2 = type metadata accessor for NANAttribute.CustomDeviceInformation.CustomAttributes(0LL);
  __chkstk_darwin(v2);
  v23[1] = (char *)v23 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v4 = type metadata accessor for NWEndpoint.Port(0LL);
  v23[3] = *(void *)(v4 - 8);
  v23[4] = v4;
  __chkstk_darwin(v4);
  v23[0] = (char *)v23 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v6 = type metadata accessor for NANGenericServiceProtocol.Attribute(0LL);
  uint64_t v7 = __chkstk_darwin(v6);
  v23[2] = (char *)v23 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v9 = __chkstk_darwin(v7);
  v23[5] = (char *)v23 - v10;
  uint64_t v11 = __chkstk_darwin(v9);
  uint64_t v12 = __chkstk_darwin(v11);
  uint64_t v13 = __chkstk_darwin(v12);
  uint64_t v14 = __chkstk_darwin(v13);
  uint64_t v15 = __chkstk_darwin(v14);
  uint64_t v16 = __chkstk_darwin(v15);
  __chkstk_darwin(v16);
  uint64_t v17 = sub_100002274(&qword_100406348);
  uint64_t v18 = __chkstk_darwin(v17);
  unint64_t v20 = (char *)v23 - ((v19 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v21 = (uint64_t)&v20[*(int *)(v18 + 48)];
  sub_100057FE8(v24, (uint64_t)v20, type metadata accessor for NANGenericServiceProtocol.Attribute);
  sub_100057FE8((uint64_t)v25, v21, type metadata accessor for NANGenericServiceProtocol.Attribute);
  Swift::UInt64 v25 = v20;
  uint64_t v22 = (char *)sub_10006CC9C + 4 * byte_10033BF34[swift_getEnumCaseMultiPayload(v20, v6)];
  __asm { BR              X10 }

BOOL sub_10006CC9C()
{
  uint64_t v4 = *(void *)(v3 - 96);
  sub_100057FE8(v4, v0, type metadata accessor for NANGenericServiceProtocol.Attribute);
  if (swift_getEnumCaseMultiPayload(v2, v1))
  {
    (*(void (**)(uint64_t, void))(*(void *)(v3 - 136) + 8LL))(v0, *(void *)(v3 - 128));
    sub_1000225EC(v4, &qword_100406348);
    return 0;
  }

  else
  {
    uint64_t v7 = *(void *)(v3 - 136);
    uint64_t v6 = *(void *)(v3 - 128);
    uint64_t v8 = *(void *)(v3 - 160);
    (*(void (**)(uint64_t, uint64_t, uint64_t))(v7 + 32))(v8, v2, v6);
    uint64_t v9 = sub_10000AF70( &qword_100406350,  (uint64_t (*)(uint64_t))&type metadata accessor for NWEndpoint.Port,  (uint64_t)&protocol conformance descriptor for NWEndpoint.Port);
    ((void (*)(uint64_t, uint64_t))dispatch thunk of RawRepresentable.rawValue.getter)(v6, v9);
    ((void (*)(uint64_t, uint64_t))dispatch thunk of RawRepresentable.rawValue.getter)(v6, v9);
    BOOL v5 = *(unsigned __int16 *)(v3 - 82) == *(unsigned __int16 *)(v3 - 84);
    uint64_t v10 = *(void (**)(uint64_t, uint64_t))(v7 + 8);
    v10(v8, v6);
    v10(v0, v6);
    sub_10005802C(v4, type metadata accessor for NANGenericServiceProtocol.Attribute);
  }

  return v5;
}

uint64_t type metadata accessor for NANGenericServiceProtocol.Attribute(uint64_t a1)
{
  uint64_t result = qword_1004062E8;
  if (!qword_1004062E8) {
    return swift_getSingletonMetadata(a1, &nominal type descriptor for NANGenericServiceProtocol.Attribute);
  }
  return result;
}

uint64_t sub_10006D2CC(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = sub_100002274((uint64_t *)&unk_10040D470);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v4 - 8) + 24LL))(a2, a1, v4);
  return a2;
}

uint64_t sub_10006D314(uint64_t result)
{
  else {
    unsigned int v1 = 8;
  }
  else {
    return result;
  }
}

uint64_t sub_10006D334(uint64_t a1, char a2, void *a3)
{
  uint64_t v7 = type metadata accessor for NANGenericServiceProtocol.Attribute(0LL);
  uint64_t v64 = *(void *)(v7 - 8);
  uint64_t v8 = __chkstk_darwin(v7);
  uint64_t v60 = (uint64_t)&v56 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  __chkstk_darwin(v8);
  uint64_t v11 = (char *)&v56 - v10;
  uint64_t v12 = sub_100002274(&qword_100405120);
  uint64_t result = __chkstk_darwin(v12);
  uint64_t v16 = (char *)&v56 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v17 = *(void *)(a1 + 16);
  if (v17)
  {
    uint64_t v58 = v3;
    uint64_t v59 = a1;
    uint64_t v18 = (uint64_t)&v16[*(int *)(result + 48)];
    unint64_t v57 = (*(unsigned __int8 *)(v14 + 80) + 32LL) & ~(unint64_t)*(unsigned __int8 *)(v14 + 80);
    uint64_t v19 = a1 + v57;
    uint64_t v63 = *(void *)(v14 + 72);
    swift_bridgeObjectRetain(a1);
    sub_1000226B0(v19, (uint64_t)v16, &qword_100405120);
    int v61 = v16;
    uint64_t v62 = v18;
    char v20 = *v16;
    uint64_t v21 = (uint64_t)v11;
    sub_100022628(v18, (uint64_t)v11, type metadata accessor for NANGenericServiceProtocol.Attribute);
    uint64_t v22 = (void *)*a3;
    unint64_t v24 = sub_10001C01C(v20);
    uint64_t v25 = v22[2];
    BOOL v26 = (v23 & 1) == 0;
    uint64_t v27 = v25 + v26;
    if (__OFADD__(v25, v26))
    {
LABEL_26:
      __break(1u);
      goto LABEL_27;
    }

    char v28 = v23;
    if (v22[3] < v27)
    {
      sub_100137118(v27, a2 & 1);
      unint64_t v29 = sub_10001C01C(v20);
      if ((v28 & 1) != (v30 & 1))
      {
LABEL_28:
        uint64_t result = KEY_TYPE_OF_DICTIONARY_VIOLATES_HASHABLE_REQUIREMENTS(_:)(&type metadata for NANGenericServiceProtocol.AttributeID);
        __break(1u);
        return result;
      }

      unint64_t v24 = v29;
      uint64_t v31 = (void *)*a3;
      if ((v28 & 1) == 0) {
        goto LABEL_12;
      }
LABEL_9:
      uint64_t v32 = v60;
      sub_100022628((uint64_t)v11, v60, type metadata accessor for NANGenericServiceProtocol.Attribute);
      sub_1000701FC(v32, v31[7] + *(void *)(v64 + 72) * v24);
      uint64_t v33 = v17 - 1;
      if (v17 == 1) {
        return swift_bridgeObjectRelease(v59);
      }
LABEL_16:
      uint64_t v37 = v59 + v63 + v57;
      int64_t v38 = type metadata accessor for NANGenericServiceProtocol.Attribute;
      while (1)
      {
        int64_t v40 = v61;
        sub_1000226B0(v37, (uint64_t)v61, &qword_100405120);
        char v41 = *v40;
        uint64_t v42 = (uint64_t)v11;
        int64_t v43 = v38;
        sub_100022628(v62, v42, v38);
        __int128 v44 = (void *)*a3;
        unint64_t v46 = sub_10001C01C(v41);
        uint64_t v47 = v44[2];
        BOOL v48 = (v45 & 1) == 0;
        uint64_t v49 = v47 + v48;
        if (__OFADD__(v47, v48)) {
          goto LABEL_26;
        }
        char v50 = v45;
        if (v44[3] < v49)
        {
          sub_100137118(v49, 1LL);
          unint64_t v51 = sub_10001C01C(v41);
          if ((v50 & 1) != (v52 & 1)) {
            goto LABEL_28;
          }
          unint64_t v46 = v51;
        }

        Swift::UInt8 v53 = (void *)*a3;
        if ((v50 & 1) != 0)
        {
          uint64_t v39 = v60;
          int64_t v38 = v43;
          sub_100022628(v21, v60, v43);
          sub_1000701FC(v39, v53[7] + *(void *)(v64 + 72) * v46);
        }

        else
        {
          v53[(v46 >> 6) + 8] |= 1LL << v46;
          *(_BYTE *)(v53[6] + v46) = v41;
          int64_t v38 = v43;
          sub_100022628(v21, v53[7] + *(void *)(v64 + 72) * v46, v43);
          uint64_t v54 = v53[2];
          BOOL v35 = __OFADD__(v54, 1LL);
          uint64_t v55 = v54 + 1;
          if (v35) {
            goto LABEL_27;
          }
          v53[2] = v55;
        }

        v37 += v63;
        --v33;
        uint64_t v11 = (char *)v21;
        if (!v33) {
          return swift_bridgeObjectRelease(v59);
        }
      }
    }

    if ((a2 & 1) != 0)
    {
      uint64_t v31 = (void *)*a3;
      if ((v23 & 1) != 0) {
        goto LABEL_9;
      }
    }

    else
    {
      sub_10013C8CC();
      uint64_t v31 = (void *)*a3;
      if ((v28 & 1) != 0) {
        goto LABEL_9;
      }
    }

void *sub_10006D728(uint64_t a1)
{
  uint64_t v2 = type metadata accessor for NANGenericServiceProtocol.Attribute(0LL);
  uint64_t v43 = *(void *)(v2 - 8);
  uint64_t v3 = __chkstk_darwin(v2);
  uint64_t v38 = (uint64_t)&v34 - ((v4 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  __chkstk_darwin(v3);
  uint64_t v42 = (uint64_t)&v34 - v5;
  uint64_t v6 = sub_100002274(&qword_100406480);
  __chkstk_darwin(v6);
  uint64_t v8 = (char *)&v34 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v9 = sub_100002274(&qword_100405120);
  uint64_t v10 = *(void *)(v9 - 8);
  uint64_t v11 = __chkstk_darwin(v9);
  uint64_t v41 = (uint64_t)&v34 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  __chkstk_darwin(v11);
  uint64_t v37 = (uint64_t)&v34 - v13;
  uint64_t v14 = sub_100002274(&qword_100405118);
  uint64_t v15 = __chkstk_darwin(v14);
  uint64_t v17 = (char *)&v34 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  __chkstk_darwin(v15);
  char v20 = (char *)&v34 - v19;
  uint64_t v21 = *(void *)(a1 + 16);
  if (v21)
  {
    uint64_t v22 = a1 + ((*(unsigned __int8 *)(v18 + 80) + 32LL) & ~(unint64_t)*(unsigned __int8 *)(v18 + 80));
    uint64_t v40 = *(void *)(v18 + 72);
    uint64_t v35 = a1;
    swift_bridgeObjectRetain(a1);
    char v23 = _swiftEmptyArrayStorage;
    uint64_t v36 = v2;
    do
    {
      sub_1000226B0(v22, (uint64_t)v20, &qword_100405118);
      sub_1000226B0((uint64_t)v20, (uint64_t)v17, &qword_100405118);
      if ((*(unsigned int (**)(char *, uint64_t, uint64_t))(v43 + 48))(v17, 1LL, v2) != 1)
      {
        uint64_t v39 = v23;
        uint64_t v24 = v42;
        sub_100022628((uint64_t)v17, v42, type metadata accessor for NANGenericServiceProtocol.Attribute);
        uint64_t v25 = v24;
        uint64_t v26 = v38;
        sub_100057FE8(v25, v38, type metadata accessor for NANGenericServiceProtocol.Attribute);
        uint64_t v27 = (char *)&loc_10006D9B0 + 4 * byte_10033BF3D[swift_getEnumCaseMultiPayload(v26, v2)];
        __asm { BR              X10 }
      }

      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v10 + 56))(v8, 1LL, 1LL, v9);
      sub_1000225EC((uint64_t)v20, &qword_100405118);
      if ((*(unsigned int (**)(char *, uint64_t, uint64_t))(v10 + 48))(v8, 1LL, v9) == 1)
      {
        sub_1000225EC((uint64_t)v8, &qword_100406480);
      }

      else
      {
        uint64_t v28 = v37;
        sub_1000586C0((uint64_t)v8, v37, &qword_100405120);
        sub_1000586C0(v28, v41, &qword_100405120);
        if ((swift_isUniquelyReferenced_nonNull_native(v23) & 1) == 0) {
          char v23 = (void *)sub_1000A62B8(0, v23[2] + 1LL, 1, (unint64_t)v23);
        }
        unint64_t v30 = v23[2];
        unint64_t v29 = v23[3];
        if (v30 >= v29 >> 1) {
          char v23 = (void *)sub_1000A62B8(v29 > 1, v30 + 1, 1, (unint64_t)v23);
        }
        v23[2] = v30 + 1;
        sub_1000586C0( v41,  (uint64_t)v23 + ((*(unsigned __int8 *)(v10 + 80) + 32LL) & ~(unint64_t)*(unsigned __int8 *)(v10 + 80))
        + *(void *)(v10 + 72) * v30,
          &qword_100405120);
        uint64_t v2 = v36;
      }

      v22 += v40;
      --v21;
    }

    while (v21);
    swift_bridgeObjectRelease_n(v35, 2LL);
    uint64_t v31 = v23[2];
    if (v31) {
      goto LABEL_14;
    }
LABEL_16:
    uint64_t v32 = &_swiftEmptyDictionarySingleton;
    goto LABEL_17;
  }

  swift_bridgeObjectRelease(a1);
  char v23 = _swiftEmptyArrayStorage;
  uint64_t v31 = _swiftEmptyArrayStorage[2];
  if (!v31) {
    goto LABEL_16;
  }
LABEL_14:
  sub_100002274(&qword_100405128);
  uint64_t v32 = (void *)static _DictionaryStorage.allocate(capacity:)(v31);
LABEL_17:
  __int128 v44 = v32;
  sub_10006D334((uint64_t)v23, 1, &v44);
  swift_bridgeObjectRelease(v23);
  return v44;
}

void *sub_10006DC1C(void *a1)
{
  uint64_t v3 = sub_100002274(&qword_100405118);
  uint64_t v4 = *(void *)(v3 - 8);
  __chkstk_darwin(v3);
  uint64_t v6 = (char *)&v25 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v7 = a1[3];
  uint64_t v8 = a1[4];
  uint64_t v9 = sub_100021104(a1, v7);
  dispatch thunk of Decoder.unkeyedContainer()(v28, v7, v8);
  if (v1)
  {
    sub_100002AC4(a1);
  }

  else
  {
    uint64_t v10 = sub_100002274(&qword_100406460);
    uint64_t v11 = v29;
    uint64_t v12 = v30;
    sub_1000237C8((uint64_t)v28, v29);
    unint64_t v13 = sub_100070180();
    dispatch thunk of UnkeyedDecodingContainer.decode<A>(_:)(v10, v10, v13, v11, v12);
    uint64_t v15 = v31;
    int64_t v16 = *(void *)(v31 + 16);
    if (v16)
    {
      uint64_t v26 = a1;
      uint64_t v27 = _swiftEmptyArrayStorage;
      sub_1000697B4(0, v16, 0);
      uint64_t v17 = v27;
      uint64_t v25 = v15;
      uint64_t v18 = (unint64_t *)(v15 + 48);
      do
      {
        uint64_t v19 = *(v18 - 1);
        unint64_t v20 = *v18;
        uint64_t v21 = *((unsigned __int8 *)v18 - 16);
        sub_100020AFC(v19, *v18);
        sub_100020AFC(v19, v20);
        sub_100063120(v21);
        uint64_t v22 = type metadata accessor for NANGenericServiceProtocol.Attribute(0LL);
        (*(void (**)(char *, void, uint64_t, uint64_t))(*(void *)(v22 - 8) + 56LL))(v6, 0LL, 1LL, v22);
        sub_1000208D8(v19, v20);
        uint64_t v27 = v17;
        unint64_t v24 = v17[2];
        unint64_t v23 = v17[3];
        if (v24 >= v23 >> 1)
        {
          sub_1000697B4(v23 > 1, v24 + 1, 1);
          uint64_t v17 = v27;
        }

        v18 += 3;
        v17[2] = v24 + 1;
        sub_1000586C0( (uint64_t)v6,  (uint64_t)v17 + ((*(unsigned __int8 *)(v4 + 80) + 32LL) & ~(unint64_t)*(unsigned __int8 *)(v4 + 80))
        + *(void *)(v4 + 72) * v24,
          &qword_100405118);
        --v16;
      }

      while (v16);
      swift_bridgeObjectRelease(v25);
      a1 = v26;
    }

    else
    {
      swift_bridgeObjectRelease(v31);
      uint64_t v17 = _swiftEmptyArrayStorage;
    }

    uint64_t v9 = sub_10006D728((uint64_t)v17);
    sub_100002AC4(v28);
    sub_100002AC4(a1);
  }

  return v9;
}

uint64_t sub_10006DEC8(uint64_t a1, unint64_t a2)
{
  uint64_t v5 = sub_100002274(&qword_100405118);
  uint64_t v6 = __chkstk_darwin(v5);
  uint64_t v8 = (char *)&v18 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  __chkstk_darwin(v6);
  uint64_t v10 = (char *)&v18 - v9;
  uint64_t v11 = type metadata accessor for NANAttribute.CustomDeviceInformation.CustomAttributes(0LL);
  __chkstk_darwin(v11);
  unint64_t v13 = (char *)&v18 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v14 = *v2;
  sub_10002255C(a1, a2);
  sub_1000667B0(v14, (uint64_t)v13);
  uint64_t v15 = &v13[*(int *)(v11 + 28)];
  sub_100020B40(*(void *)v15, *((void *)v15 + 1));
  *(void *)uint64_t v15 = a1;
  *((void *)v15 + 1) = a2;
  sub_100057FE8( (uint64_t)v13,  (uint64_t)v10,  type metadata accessor for NANAttribute.CustomDeviceInformation.CustomAttributes);
  uint64_t v16 = type metadata accessor for NANGenericServiceProtocol.Attribute(0LL);
  swift_storeEnumTagMultiPayload(v10, v16, 7LL);
  (*(void (**)(char *, void, uint64_t, uint64_t))(*(void *)(v16 - 8) + 56LL))(v10, 0LL, 1LL, v16);
  sub_1000226B0((uint64_t)v10, (uint64_t)v8, &qword_100405118);
  sub_100013D20((uint64_t)v8, 7);
  sub_10005802C((uint64_t)v13, type metadata accessor for NANAttribute.CustomDeviceInformation.CustomAttributes);
  return sub_1000225EC((uint64_t)v10, &qword_100405118);
}

uint64_t sub_10006E050(uint64_t a1, unint64_t a2)
{
  uint64_t v5 = sub_100002274(&qword_100405118);
  uint64_t v6 = __chkstk_darwin(v5);
  uint64_t v8 = (char *)&v18 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  __chkstk_darwin(v6);
  uint64_t v10 = (char *)&v18 - v9;
  uint64_t v11 = type metadata accessor for NANAttribute.CustomDeviceInformation.CustomAttributes(0LL);
  __chkstk_darwin(v11);
  unint64_t v13 = (char *)&v18 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v14 = *v2;
  sub_10002255C(a1, a2);
  sub_1000667B0(v14, (uint64_t)v13);
  uint64_t v15 = &v13[*(int *)(v11 + 32)];
  sub_100020B40(*(void *)v15, *((void *)v15 + 1));
  *(void *)uint64_t v15 = a1;
  *((void *)v15 + 1) = a2;
  sub_100057FE8( (uint64_t)v13,  (uint64_t)v10,  type metadata accessor for NANAttribute.CustomDeviceInformation.CustomAttributes);
  uint64_t v16 = type metadata accessor for NANGenericServiceProtocol.Attribute(0LL);
  swift_storeEnumTagMultiPayload(v10, v16, 7LL);
  (*(void (**)(char *, void, uint64_t, uint64_t))(*(void *)(v16 - 8) + 56LL))(v10, 0LL, 1LL, v16);
  sub_1000226B0((uint64_t)v10, (uint64_t)v8, &qword_100405118);
  sub_100013D20((uint64_t)v8, 7);
  sub_10005802C((uint64_t)v13, type metadata accessor for NANAttribute.CustomDeviceInformation.CustomAttributes);
  return sub_1000225EC((uint64_t)v10, &qword_100405118);
}

uint64_t sub_10006E1D8(uint64_t a1, unint64_t a2)
{
  uint64_t v5 = sub_100002274(&qword_100405118);
  uint64_t v6 = __chkstk_darwin(v5);
  uint64_t v8 = (char *)&v18 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  __chkstk_darwin(v6);
  uint64_t v10 = (char *)&v18 - v9;
  uint64_t v11 = type metadata accessor for NANAttribute.CustomDeviceInformation.CustomAttributes(0LL);
  __chkstk_darwin(v11);
  unint64_t v13 = (char *)&v18 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v14 = *v2;
  sub_10002255C(a1, a2);
  sub_1000667B0(v14, (uint64_t)v13);
  uint64_t v15 = &v13[*(int *)(v11 + 36)];
  sub_100020B40(*(void *)v15, *((void *)v15 + 1));
  *(void *)uint64_t v15 = a1;
  *((void *)v15 + 1) = a2;
  sub_100057FE8( (uint64_t)v13,  (uint64_t)v10,  type metadata accessor for NANAttribute.CustomDeviceInformation.CustomAttributes);
  uint64_t v16 = type metadata accessor for NANGenericServiceProtocol.Attribute(0LL);
  swift_storeEnumTagMultiPayload(v10, v16, 7LL);
  (*(void (**)(char *, void, uint64_t, uint64_t))(*(void *)(v16 - 8) + 56LL))(v10, 0LL, 1LL, v16);
  sub_1000226B0((uint64_t)v10, (uint64_t)v8, &qword_100405118);
  sub_100013D20((uint64_t)v8, 7);
  sub_10005802C((uint64_t)v13, type metadata accessor for NANAttribute.CustomDeviceInformation.CustomAttributes);
  return sub_1000225EC((uint64_t)v10, &qword_100405118);
}

unint64_t sub_10006E360()
{
  unint64_t result = qword_100406248;
  if (!qword_100406248)
  {
    unint64_t result = swift_getWitnessTable(&unk_10034CEF4, &type metadata for BinaryEncoder.UnkeyedContainer);
    atomic_store(result, (unint64_t *)&qword_100406248);
  }

  return result;
}

void _s7CoreP2P25NANGenericServiceProtocolVyACSg10Foundation4DataVcfC_0(uint64_t a1, unint64_t a2)
{
  uint64_t v4 = sub_100002274(&qword_100405118);
  __chkstk_darwin(v4);
  sub_100020AFC(a1, a2);
  sub_10000D9B0((uint64_t)_swiftEmptyArrayStorage);
  uint64_t v5 = type metadata accessor for BinaryDecoder();
  uint64_t v6 = (void *)swift_allocObject(v5, 48LL, 7LL);
  v6[5] = &_swiftEmptyDictionarySingleton;
  v6[2] = a1;
  v6[3] = a2;
  __asm { BR              X9 }

uint64_t sub_10006E474(uint64_t a1)
{
  *(void *)(v4 - 224) = v3;
  v2[4] = (int)v3;
  swift_beginAccess(a1, v4 - 112, 1LL, 0LL);
  uint64_t v5 = v2[5];
  v2[5] = v1;
  uint64_t v6 = swift_bridgeObjectRelease(v5);
  uint64_t v8 = v2[2];
  unint64_t v7 = v2[3];
  *(void *)(v4 - 192) = v8;
  *(void *)(v4 - 200) = v8 >> 32;
  *(void *)(v4 - 208) = _swiftEmptyArrayStorage;
  return ((uint64_t (*)(uint64_t))((char *)sub_10006E4FC + 4 * byte_10033BF4A[v7 >> 62]))(v6);
}

void *sub_10006E4FC@<X0>(uint64_t a1@<X8>)
{
  if (a1 < *(void *)(v8 - 200))
  {
    *(void *)(v8 - 160) = v5;
    *(void *)(v8 - 152) = sub_10000AF70( (unint64_t *)&qword_100405DE8,  (uint64_t (*)(uint64_t))type metadata accessor for BinaryDecoder,  v7);
    *(void *)(v8 - 184) = v2;
    swift_retain();
    sub_1001FD344((void *)(v8 - 184), v8 - 144);
    if (v3)
    {
      *(void *)(v8 - 144) = v3;
      swift_errorRetain(v3);
      uint64_t v9 = sub_100002274((uint64_t *)&unk_10040C5B0);
      if ((swift_dynamicCast(v8 - 184, v8 - 144, v9, v1, 0LL) & 1) != 0)
      {
        uint64_t v10 = *(void *)(v8 - 184);
        int v11 = *(unsigned __int8 *)(v8 - 168);
        if (v11 == 2)
        {
          if ((v10 & 1) != 0)
          {
            swift_errorRelease(v3);
            swift_errorRelease(*(void *)(v8 - 144));
            goto LABEL_28;
          }
        }

        else
        {
          sub_10007030C(v10, *(void *)(v8 - 176), v11);
        }
      }

      swift_bridgeObjectRelease(*(void *)(v8 - 208));
      swift_errorRelease(*(void *)(v8 - 144));
      swift_release(v2);
      sub_1000208D8(*(void *)(v8 - 224), *(void *)(v8 - 216));
      swift_errorRelease(v3);
      return 0LL;
    }

    *(_DWORD *)(v8 - 228) = *(unsigned __int8 *)(v8 - 144);
    uint64_t v12 = *(void *)(v8 - 136);
    *(void *)(v8 - 248) = *(void *)(v8 - 128);
    *(void *)(v8 - 240) = v12;
    if ((swift_isUniquelyReferenced_nonNull_native(*(void *)(v8 - 208)) & 1) != 0) {
      unint64_t v13 = *(void **)(v8 - 208);
    }
    else {
      unint64_t v13 = sub_1000A6D74(0LL, *(void *)(*(void *)(v8 - 208) + 16LL) + 1LL, 1, *(void **)(v8 - 208));
    }
    unint64_t v15 = v13[2];
    unint64_t v14 = v13[3];
    unint64_t v16 = v15 + 1;
    if (v15 >= v14 >> 1)
    {
      *(void *)(v8 - 208) = v16;
      *(void *)(v8 - 256) = v15;
      uint64_t v19 = sub_1000A6D74((void *)(v14 > 1), v15 + 1, 1, v13);
      unint64_t v16 = *(void *)(v8 - 208);
      unint64_t v15 = *(void *)(v8 - 256);
      unint64_t v13 = v19;
    }

    v13[2] = v16;
    *(void *)(v8 - 208) = v13;
    uint64_t v17 = &v13[3 * v15];
    *((_BYTE *)v17 + 32) = *(_DWORD *)(v8 - 228);
    uint64_t v18 = *(void *)(v8 - 248);
    v17[5] = *(void *)(v8 - 240);
    v17[6] = v18;
LABEL_28:
    JUMPOUT(0x10006E4E4LL);
  }

  swift_release(v2);
  uint64_t v20 = *(void *)(v8 - 208);
  int64_t v21 = *(void *)(v20 + 16);
  if (v21)
  {
    *(void *)(v8 - 184) = _swiftEmptyArrayStorage;
    uint64_t v22 = v20;
    sub_1000697B4(0, v21, 0);
    unint64_t v23 = *(void **)(v8 - 184);
    unint64_t v24 = (unint64_t *)(v22 + 48);
    do
    {
      uint64_t v25 = *(v24 - 1);
      unint64_t v26 = *v24;
      uint64_t v27 = *((unsigned __int8 *)v24 - 16);
      sub_100020AFC(v25, *v24);
      sub_100020AFC(v25, v26);
      sub_100063120(v27);
      if (v3)
      {
        swift_errorRelease(v3);
        uint64_t v28 = type metadata accessor for NANGenericServiceProtocol.Attribute(0LL);
        (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(v28 - 8) + 56LL))(v4, 1LL, 1LL, v28);
        uint64_t v3 = 0LL;
      }

      else
      {
        uint64_t v29 = type metadata accessor for NANGenericServiceProtocol.Attribute(0LL);
        (*(void (**)(uint64_t, void, uint64_t, uint64_t))(*(void *)(v29 - 8) + 56LL))(v4, 0LL, 1LL, v29);
      }

      sub_1000208D8(v25, v26);
      *(void *)(v8 - 184) = v23;
      unint64_t v31 = v23[2];
      unint64_t v30 = v23[3];
      if (v31 >= v30 >> 1)
      {
        sub_1000697B4(v30 > 1, v31 + 1, 1);
        unint64_t v23 = *(void **)(v8 - 184);
      }

      v24 += 3;
      v23[2] = v31 + 1;
      sub_1000586C0( v4,  (uint64_t)v23 + ((*(unsigned __int8 *)(v6 + 80) + 32LL) & ~(unint64_t)*(unsigned __int8 *)(v6 + 80))
      + *(void *)(v6 + 72) * v31,
        &qword_100405118);
      --v21;
    }

    while (v21);
    swift_bridgeObjectRelease(*(void *)(v8 - 208));
  }

  else
  {
    swift_bridgeObjectRelease(*(void *)(v8 - 208));
    unint64_t v23 = _swiftEmptyArrayStorage;
  }

  uint64_t v32 = sub_10006D728((uint64_t)v23);
  sub_1000208D8(*(void *)(v8 - 224), *(void *)(v8 - 216));
  return v32;
}

unint64_t sub_10006E848()
{
  unint64_t result = qword_100406250;
  if (!qword_100406250)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for NANGenericServiceProtocol,  &type metadata for NANGenericServiceProtocol);
    atomic_store(result, (unint64_t *)&qword_100406250);
  }

  return result;
}

unint64_t sub_10006E890()
{
  unint64_t result = qword_100406258;
  if (!qword_100406258)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for NANGenericServiceProtocol.AttributeFilter,  &type metadata for NANGenericServiceProtocol.AttributeFilter);
    atomic_store(result, (unint64_t *)&qword_100406258);
  }

  return result;
}

unint64_t sub_10006E8D8()
{
  unint64_t result = qword_100406260;
  if (!qword_100406260)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for NANGenericServiceProtocol.AttributeFilter,  &type metadata for NANGenericServiceProtocol.AttributeFilter);
    atomic_store(result, (unint64_t *)&qword_100406260);
  }

  return result;
}

unint64_t sub_10006E920()
{
  unint64_t result = qword_100406268;
  if (!qword_100406268)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for NANGenericServiceProtocol.AttributeFilter,  &type metadata for NANGenericServiceProtocol.AttributeFilter);
    atomic_store(result, (unint64_t *)&qword_100406268);
  }

  return result;
}

unint64_t sub_10006E968()
{
  unint64_t result = qword_100406270;
  if (!qword_100406270)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for NANGenericServiceProtocol.AttributeFilter,  &type metadata for NANGenericServiceProtocol.AttributeFilter);
    atomic_store(result, (unint64_t *)&qword_100406270);
  }

  return result;
}

ValueMetadata *type metadata accessor for NANGenericServiceProtocol()
{
  return &type metadata for NANGenericServiceProtocol;
}

ValueMetadata *type metadata accessor for NANGenericServiceProtocol.AttributeFilter()
{
  return &type metadata for NANGenericServiceProtocol.AttributeFilter;
}

uint64_t getEnumTagSinglePayload for NANCipherSuite(unsigned __int8 *a1, unsigned int a2)
{
  if (!a2) {
    return 0LL;
  }
  if (a2 < 0xF9) {
    goto LABEL_17;
  }
  if (a2 + 7 >= 0xFFFF00) {
    int v2 = 4;
  }
  else {
    int v2 = 2;
  }
  if ((a2 + 7) >> 8 < 0xFF) {
    int v3 = 1;
  }
  else {
    int v3 = v2;
  }
  if (v3 == 4)
  {
    int v4 = *(_DWORD *)(a1 + 1);
    if (v4) {
      return (*a1 | (v4 << 8)) - 7;
    }
  }

  else
  {
    if (v3 == 2)
    {
      int v4 = *(unsigned __int16 *)(a1 + 1);
      if (!*(_WORD *)(a1 + 1)) {
        goto LABEL_17;
      }
      return (*a1 | (v4 << 8)) - 7;
    }

    int v4 = a1[1];
    if (a1[1]) {
      return (*a1 | (v4 << 8)) - 7;
    }
  }

uint64_t storeEnumTagSinglePayload for NANGenericServiceProtocol.AttributeID( _BYTE *a1, unsigned int a2, unsigned int a3)
{
  if (a3 + 7 >= 0xFFFF00) {
    int v3 = 4;
  }
  else {
    int v3 = 2;
  }
  if ((a3 + 7) >> 8 < 0xFF) {
    LODWORD(v4) = 1;
  }
  else {
    LODWORD(v4) = v3;
  }
  if (a3 >= 0xF9) {
    uint64_t v4 = v4;
  }
  else {
    uint64_t v4 = 0LL;
  }
  if (a2 <= 0xF8) {
    return ((uint64_t (*)(void))((char *)&loc_10006EAA8 + 4 * byte_10033BF53[v4]))();
  }
  *a1 = a2 + 7;
  return ((uint64_t (*)(void))((char *)sub_10006EADC + 4 * byte_10033BF4E[v4]))();
}

uint64_t sub_10006EADC(uint64_t result)
{
  *(_BYTE *)(result + 1) = v1;
  return result;
}

uint64_t sub_10006EAE4(uint64_t result, int a2)
{
  *(_WORD *)(result + 1) = 0;
  if (a2) {
    JUMPOUT(0x10006EAECLL);
  }
  return result;
}

uint64_t sub_10006EAF8(uint64_t result, int a2)
{
  *(_DWORD *)(result + 1) = 0;
  if (!a2) {
    JUMPOUT(0x10006EB00LL);
  }
  *(_BYTE *)unint64_t result = a2 + 7;
  return result;
}

uint64_t sub_10006EB04(uint64_t result)
{
  *(_DWORD *)(result + 1) = v1;
  return result;
}

uint64_t sub_10006EB0C(uint64_t result)
{
  *(_WORD *)(result + 1) = v1;
  return result;
}

ValueMetadata *type metadata accessor for NANGenericServiceProtocol.AttributeID()
{
  return &type metadata for NANGenericServiceProtocol.AttributeID;
}

char *sub_10006EB28(char *a1, char *a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a3 - 8);
  int v6 = *(_DWORD *)(v5 + 80);
  if ((v6 & 0x20000) != 0)
  {
    uint64_t v9 = *(void *)a2;
    *(void *)a1 = *(void *)a2;
    a1 = (char *)(v9 + ((v6 + 16LL) & ~(unint64_t)v6));
    swift_retain();
  }

  else
  {
    switch(swift_getEnumCaseMultiPayload(a2, a3))
    {
      case 0u:
        uint64_t v8 = type metadata accessor for NWEndpoint.Port(0LL);
        (*(void (**)(char *, char *, uint64_t))(*(void *)(v8 - 8) + 16LL))(a1, a2, v8);
        swift_storeEnumTagMultiPayload(a1, a3, 0LL);
        break;
      case 2u:
        uint64_t v11 = *((void *)a2 + 1);
        *(void *)a1 = *(void *)a2;
        *((void *)a1 + 1) = v11;
        swift_bridgeObjectRetain(v11);
        swift_storeEnumTagMultiPayload(a1, a3, 2LL);
        break;
      case 3u:
        uint64_t v12 = *((void *)a2 + 1);
        *(void *)a1 = *(void *)a2;
        *((void *)a1 + 1) = v12;
        swift_bridgeObjectRetain(v12);
        swift_storeEnumTagMultiPayload(a1, a3, 3LL);
        break;
      case 4u:
        uint64_t v14 = *(void *)a2;
        unint64_t v13 = *((void *)a2 + 1);
        sub_100020AFC(v14, v13);
        *(void *)a1 = v14;
        *((void *)a1 + 1) = v13;
        swift_storeEnumTagMultiPayload(a1, a3, 4LL);
        break;
      case 5u:
        uint64_t v16 = *(void *)a2;
        unint64_t v15 = *((void *)a2 + 1);
        sub_100020AFC(v16, v15);
        *(void *)a1 = v16;
        *((void *)a1 + 1) = v15;
        swift_storeEnumTagMultiPayload(a1, a3, 5LL);
        break;
      case 6u:
        uint64_t v18 = *(void *)a2;
        unint64_t v17 = *((void *)a2 + 1);
        sub_100020AFC(v18, v17);
        *(void *)a1 = v18;
        *((void *)a1 + 1) = v17;
        swift_storeEnumTagMultiPayload(a1, a3, 6LL);
        break;
      case 7u:
        *a1 = *a2;
        *(_WORD *)(a1 + 1) = *(_WORD *)(a2 + 1);
        uint64_t v19 = (int *)type metadata accessor for NANAttribute.CustomDeviceInformation.CustomAttributes(0LL);
        uint64_t v20 = v19[6];
        int64_t v21 = &a1[v20];
        uint64_t v22 = &a2[v20];
        uint64_t v23 = type metadata accessor for P256.KeyAgreement.PublicKey(0LL);
        uint64_t v24 = *(void *)(v23 - 8);
        if ((*(unsigned int (**)(char *, uint64_t, uint64_t))(v24 + 48))(v22, 1LL, v23))
        {
          uint64_t v25 = sub_100002274((uint64_t *)&unk_10040D470);
          memcpy(v21, v22, *(void *)(*(void *)(v25 - 8) + 64LL));
        }

        else
        {
          (*(void (**)(char *, char *, uint64_t))(v24 + 16))(v21, v22, v23);
          (*(void (**)(char *, void, uint64_t, uint64_t))(v24 + 56))(v21, 0LL, 1LL, v23);
        }

        uint64_t v28 = v19[7];
        uint64_t v29 = &a1[v28];
        unint64_t v30 = &a2[v28];
        unint64_t v31 = *((void *)v30 + 1);
        if (v31 >> 60 == 15)
        {
          *(_OWORD *)uint64_t v29 = *(_OWORD *)v30;
        }

        else
        {
          uint64_t v32 = *(void *)v30;
          sub_100020AFC(*(void *)v30, *((void *)v30 + 1));
          *(void *)uint64_t v29 = v32;
          *((void *)v29 + 1) = v31;
        }

        uint64_t v33 = v19[8];
        uint64_t v34 = &a1[v33];
        uint64_t v35 = &a2[v33];
        unint64_t v36 = *((void *)v35 + 1);
        if (v36 >> 60 == 15)
        {
          *(_OWORD *)uint64_t v34 = *(_OWORD *)v35;
        }

        else
        {
          uint64_t v37 = *(void *)v35;
          sub_100020AFC(*(void *)v35, *((void *)v35 + 1));
          *(void *)uint64_t v34 = v37;
          *((void *)v34 + 1) = v36;
        }

        uint64_t v38 = v19[9];
        uint64_t v39 = &a1[v38];
        uint64_t v40 = &a2[v38];
        unint64_t v41 = *((void *)v40 + 1);
        if (v41 >> 60 == 15)
        {
          *(_OWORD *)uint64_t v39 = *(_OWORD *)v40;
        }

        else
        {
          uint64_t v42 = *(void *)v40;
          sub_100020AFC(*(void *)v40, *((void *)v40 + 1));
          *(void *)uint64_t v39 = v42;
          *((void *)v39 + 1) = v41;
        }

        uint64_t v43 = v19[10];
        __int128 v44 = &a1[v43];
        char v45 = &a2[v43];
        uint64_t v46 = type metadata accessor for UUID(0LL);
        uint64_t v47 = *(void *)(v46 - 8);
        if ((*(unsigned int (**)(char *, uint64_t, uint64_t))(v47 + 48))(v45, 1LL, v46))
        {
          uint64_t v48 = sub_100002274(qword_100410330);
          memcpy(v44, v45, *(void *)(*(void *)(v48 - 8) + 64LL));
        }

        else
        {
          (*(void (**)(char *, char *, uint64_t))(v47 + 16))(v44, v45, v46);
          (*(void (**)(char *, void, uint64_t, uint64_t))(v47 + 56))(v44, 0LL, 1LL, v46);
        }

        uint64_t v49 = v19[11];
        uint64_t v50 = *(void *)&a2[v49];
        *(void *)&a1[v49] = v50;
        uint64_t v51 = v19[12];
        char v52 = &a1[v51];
        Swift::UInt8 v53 = &a2[v51];
        uint64_t v54 = type metadata accessor for NANInternetSharingStatistics.Requester(0LL);
        uint64_t v55 = *(void *)(v54 - 8);
        uint64_t v56 = *(unsigned int (**)(char *, uint64_t, uint64_t))(v55 + 48);
        swift_bridgeObjectRetain(v50);
        if (v56(v53, 1LL, v54))
        {
          uint64_t v57 = sub_100002274((uint64_t *)&unk_10040DCC0);
          memcpy(v52, v53, *(void *)(*(void *)(v57 - 8) + 64LL));
        }

        else
        {
          uint64_t v58 = type metadata accessor for DispatchTimeInterval(0LL);
          (*(void (**)(char *, char *, uint64_t))(*(void *)(v58 - 8) + 16LL))(v52, v53, v58);
          v52[*(int *)(v54 + 20)] = v53[*(int *)(v54 + 20)];
          (*(void (**)(char *, void, uint64_t, uint64_t))(v55 + 56))(v52, 0LL, 1LL, v54);
        }

        uint64_t v59 = v19[13];
        uint64_t v60 = &a1[v59];
        int v61 = &a2[v59];
        *(_OWORD *)uint64_t v60 = *(_OWORD *)v61;
        *(_OWORD *)(v60 + 9) = *(_OWORD *)(v61 + 9);
        swift_storeEnumTagMultiPayload(a1, a3, 7LL);
        break;
      case 8u:
        *(_WORD *)a1 = *(_WORD *)a2;
        a1[2] = a2[2];
        uint64_t v27 = *((void *)a2 + 1);
        unint64_t v26 = *((void *)a2 + 2);
        sub_100020AFC(v27, v26);
        *((void *)a1 + 1) = v27;
        *((void *)a1 + 2) = v26;
        swift_storeEnumTagMultiPayload(a1, a3, 8LL);
        break;
      default:
        memcpy(a1, a2, *(void *)(v5 + 64));
        break;
    }
  }

  return a1;
}

uint64_t sub_10006EFB8(uint64_t *a1, uint64_t a2)
{
  int v2 = a1;
  uint64_t result = swift_getEnumCaseMultiPayload(a1, a2);
  switch((int)result)
  {
    case 0:
      uint64_t v6 = type metadata accessor for NWEndpoint.Port(0LL);
      return (*(uint64_t (**)(uint64_t *, uint64_t))(*(void *)(v6 - 8) + 8LL))(v2, v6);
    case 2:
    case 3:
      return swift_bridgeObjectRelease(v2[1]);
    case 4:
    case 5:
    case 6:
      uint64_t v4 = *v2;
      unint64_t v5 = v2[1];
      goto LABEL_18;
    case 7:
      BOOL v7 = (int *)type metadata accessor for NANAttribute.CustomDeviceInformation.CustomAttributes(0LL);
      uint64_t v8 = (char *)v2 + v7[6];
      uint64_t v9 = type metadata accessor for P256.KeyAgreement.PublicKey(0LL);
      uint64_t v10 = *(void *)(v9 - 8);
      uint64_t v11 = (uint64_t *)((char *)v2 + v7[7]);
      unint64_t v12 = v11[1];
      if (v12 >> 60 != 15) {
        sub_1000208D8(*v11, v12);
      }
      unint64_t v13 = (uint64_t *)((char *)v2 + v7[8]);
      unint64_t v14 = v13[1];
      if (v14 >> 60 != 15) {
        sub_1000208D8(*v13, v14);
      }
      unint64_t v15 = (uint64_t *)((char *)v2 + v7[9]);
      unint64_t v16 = v15[1];
      if (v16 >> 60 != 15) {
        sub_1000208D8(*v15, v16);
      }
      unint64_t v17 = (char *)v2 + v7[10];
      uint64_t v18 = type metadata accessor for UUID(0LL);
      uint64_t v19 = *(void *)(v18 - 8);
      swift_bridgeObjectRelease(*(uint64_t *)((char *)v2 + v7[11]));
      int v2 = (uint64_t *)((char *)v2 + v7[12]);
      uint64_t v20 = type metadata accessor for NANInternetSharingStatistics.Requester(0LL);
      uint64_t result = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*(void *)(v20 - 8) + 48LL))(v2, 1LL, v20);
      if (!(_DWORD)result)
      {
        uint64_t v6 = type metadata accessor for DispatchTimeInterval(0LL);
        return (*(uint64_t (**)(uint64_t *, uint64_t))(*(void *)(v6 - 8) + 8LL))(v2, v6);
      }

      return result;
    case 8:
      uint64_t v4 = v2[1];
      unint64_t v5 = v2[2];
LABEL_18:
      uint64_t result = sub_1000208D8(v4, v5);
      break;
    default:
      return result;
  }

  return result;
}

char *sub_10006F1A0(char *a1, char *a2, uint64_t a3)
{
  switch(swift_getEnumCaseMultiPayload(a2, a3))
  {
    case 0u:
      uint64_t v6 = type metadata accessor for NWEndpoint.Port(0LL);
      (*(void (**)(char *, char *, uint64_t))(*(void *)(v6 - 8) + 16LL))(a1, a2, v6);
      BOOL v7 = a1;
      uint64_t v8 = a3;
      uint64_t v9 = 0LL;
      goto LABEL_29;
    case 2u:
      uint64_t v10 = *((void *)a2 + 1);
      *(void *)a1 = *(void *)a2;
      *((void *)a1 + 1) = v10;
      swift_bridgeObjectRetain(v10);
      BOOL v7 = a1;
      uint64_t v8 = a3;
      uint64_t v9 = 2LL;
      goto LABEL_29;
    case 3u:
      uint64_t v11 = *((void *)a2 + 1);
      *(void *)a1 = *(void *)a2;
      *((void *)a1 + 1) = v11;
      swift_bridgeObjectRetain(v11);
      BOOL v7 = a1;
      uint64_t v8 = a3;
      uint64_t v9 = 3LL;
      goto LABEL_29;
    case 4u:
      uint64_t v13 = *(void *)a2;
      unint64_t v12 = *((void *)a2 + 1);
      sub_100020AFC(v13, v12);
      *(void *)a1 = v13;
      *((void *)a1 + 1) = v12;
      BOOL v7 = a1;
      uint64_t v8 = a3;
      uint64_t v9 = 4LL;
      goto LABEL_29;
    case 5u:
      uint64_t v15 = *(void *)a2;
      unint64_t v14 = *((void *)a2 + 1);
      sub_100020AFC(v15, v14);
      *(void *)a1 = v15;
      *((void *)a1 + 1) = v14;
      BOOL v7 = a1;
      uint64_t v8 = a3;
      uint64_t v9 = 5LL;
      goto LABEL_29;
    case 6u:
      uint64_t v17 = *(void *)a2;
      unint64_t v16 = *((void *)a2 + 1);
      sub_100020AFC(v17, v16);
      *(void *)a1 = v17;
      *((void *)a1 + 1) = v16;
      BOOL v7 = a1;
      uint64_t v8 = a3;
      uint64_t v9 = 6LL;
      goto LABEL_29;
    case 7u:
      *a1 = *a2;
      *(_WORD *)(a1 + 1) = *(_WORD *)(a2 + 1);
      uint64_t v18 = (int *)type metadata accessor for NANAttribute.CustomDeviceInformation.CustomAttributes(0LL);
      uint64_t v19 = v18[6];
      uint64_t v20 = &a1[v19];
      int64_t v21 = &a2[v19];
      uint64_t v22 = type metadata accessor for P256.KeyAgreement.PublicKey(0LL);
      uint64_t v23 = *(void *)(v22 - 8);
      if ((*(unsigned int (**)(char *, uint64_t, uint64_t))(v23 + 48))(v21, 1LL, v22))
      {
        uint64_t v24 = sub_100002274((uint64_t *)&unk_10040D470);
        memcpy(v20, v21, *(void *)(*(void *)(v24 - 8) + 64LL));
      }

      else
      {
        (*(void (**)(char *, char *, uint64_t))(v23 + 16))(v20, v21, v22);
        (*(void (**)(char *, void, uint64_t, uint64_t))(v23 + 56))(v20, 0LL, 1LL, v22);
      }

      uint64_t v27 = v18[7];
      uint64_t v28 = &a1[v27];
      uint64_t v29 = &a2[v27];
      unint64_t v30 = *((void *)v29 + 1);
      if (v30 >> 60 == 15)
      {
        *(_OWORD *)uint64_t v28 = *(_OWORD *)v29;
      }

      else
      {
        uint64_t v31 = *(void *)v29;
        sub_100020AFC(*(void *)v29, *((void *)v29 + 1));
        *(void *)uint64_t v28 = v31;
        *((void *)v28 + 1) = v30;
      }

      uint64_t v32 = v18[8];
      uint64_t v33 = &a1[v32];
      uint64_t v34 = &a2[v32];
      unint64_t v35 = *((void *)v34 + 1);
      if (v35 >> 60 == 15)
      {
        *(_OWORD *)uint64_t v33 = *(_OWORD *)v34;
      }

      else
      {
        uint64_t v36 = *(void *)v34;
        sub_100020AFC(*(void *)v34, *((void *)v34 + 1));
        *(void *)uint64_t v33 = v36;
        *((void *)v33 + 1) = v35;
      }

      uint64_t v37 = v18[9];
      uint64_t v38 = &a1[v37];
      uint64_t v39 = &a2[v37];
      unint64_t v40 = *((void *)v39 + 1);
      if (v40 >> 60 == 15)
      {
        *(_OWORD *)uint64_t v38 = *(_OWORD *)v39;
      }

      else
      {
        uint64_t v41 = *(void *)v39;
        sub_100020AFC(*(void *)v39, *((void *)v39 + 1));
        *(void *)uint64_t v38 = v41;
        *((void *)v38 + 1) = v40;
      }

      uint64_t v42 = v18[10];
      uint64_t v43 = &a1[v42];
      __int128 v44 = &a2[v42];
      uint64_t v45 = type metadata accessor for UUID(0LL);
      uint64_t v46 = *(void *)(v45 - 8);
      if ((*(unsigned int (**)(char *, uint64_t, uint64_t))(v46 + 48))(v44, 1LL, v45))
      {
        uint64_t v47 = sub_100002274(qword_100410330);
        memcpy(v43, v44, *(void *)(*(void *)(v47 - 8) + 64LL));
      }

      else
      {
        (*(void (**)(char *, char *, uint64_t))(v46 + 16))(v43, v44, v45);
        (*(void (**)(char *, void, uint64_t, uint64_t))(v46 + 56))(v43, 0LL, 1LL, v45);
      }

      uint64_t v48 = v18[11];
      uint64_t v49 = *(void *)&a2[v48];
      *(void *)&a1[v48] = v49;
      uint64_t v50 = v18[12];
      uint64_t v51 = &a1[v50];
      char v52 = &a2[v50];
      uint64_t v53 = type metadata accessor for NANInternetSharingStatistics.Requester(0LL);
      uint64_t v54 = *(void *)(v53 - 8);
      uint64_t v55 = *(unsigned int (**)(char *, uint64_t, uint64_t))(v54 + 48);
      swift_bridgeObjectRetain(v49);
      if (v55(v52, 1LL, v53))
      {
        uint64_t v56 = sub_100002274((uint64_t *)&unk_10040DCC0);
        memcpy(v51, v52, *(void *)(*(void *)(v56 - 8) + 64LL));
      }

      else
      {
        uint64_t v57 = type metadata accessor for DispatchTimeInterval(0LL);
        (*(void (**)(char *, char *, uint64_t))(*(void *)(v57 - 8) + 16LL))(v51, v52, v57);
        v51[*(int *)(v53 + 20)] = v52[*(int *)(v53 + 20)];
        (*(void (**)(char *, void, uint64_t, uint64_t))(v54 + 56))(v51, 0LL, 1LL, v53);
      }

      uint64_t v58 = v18[13];
      uint64_t v59 = &a1[v58];
      uint64_t v60 = &a2[v58];
      *(_OWORD *)uint64_t v59 = *(_OWORD *)v60;
      *(_OWORD *)(v59 + 9) = *(_OWORD *)(v60 + 9);
      BOOL v7 = a1;
      uint64_t v8 = a3;
      uint64_t v9 = 7LL;
      goto LABEL_29;
    case 8u:
      *(_WORD *)a1 = *(_WORD *)a2;
      a1[2] = a2[2];
      uint64_t v26 = *((void *)a2 + 1);
      unint64_t v25 = *((void *)a2 + 2);
      sub_100020AFC(v26, v25);
      *((void *)a1 + 1) = v26;
      *((void *)a1 + 2) = v25;
      BOOL v7 = a1;
      uint64_t v8 = a3;
      uint64_t v9 = 8LL;
LABEL_29:
      swift_storeEnumTagMultiPayload(v7, v8, v9);
      break;
    default:
      memcpy(a1, a2, *(void *)(*(void *)(a3 - 8) + 64LL));
      break;
  }

  return a1;
}

char *sub_10006F5EC(char *a1, char *a2, uint64_t a3)
{
  if (a1 != a2)
  {
    sub_10005802C((uint64_t)a1, type metadata accessor for NANGenericServiceProtocol.Attribute);
    switch(swift_getEnumCaseMultiPayload(a2, a3))
    {
      case 0u:
        uint64_t v6 = type metadata accessor for NWEndpoint.Port(0LL);
        (*(void (**)(char *, char *, uint64_t))(*(void *)(v6 - 8) + 16LL))(a1, a2, v6);
        BOOL v7 = a1;
        uint64_t v8 = a3;
        uint64_t v9 = 0LL;
        goto LABEL_30;
      case 2u:
        *(void *)a1 = *(void *)a2;
        uint64_t v10 = *((void *)a2 + 1);
        *((void *)a1 + 1) = v10;
        swift_bridgeObjectRetain(v10);
        BOOL v7 = a1;
        uint64_t v8 = a3;
        uint64_t v9 = 2LL;
        goto LABEL_30;
      case 3u:
        *(void *)a1 = *(void *)a2;
        uint64_t v11 = *((void *)a2 + 1);
        *((void *)a1 + 1) = v11;
        swift_bridgeObjectRetain(v11);
        BOOL v7 = a1;
        uint64_t v8 = a3;
        uint64_t v9 = 3LL;
        goto LABEL_30;
      case 4u:
        uint64_t v13 = *(void *)a2;
        unint64_t v12 = *((void *)a2 + 1);
        sub_100020AFC(v13, v12);
        *(void *)a1 = v13;
        *((void *)a1 + 1) = v12;
        BOOL v7 = a1;
        uint64_t v8 = a3;
        uint64_t v9 = 4LL;
        goto LABEL_30;
      case 5u:
        uint64_t v15 = *(void *)a2;
        unint64_t v14 = *((void *)a2 + 1);
        sub_100020AFC(v15, v14);
        *(void *)a1 = v15;
        *((void *)a1 + 1) = v14;
        BOOL v7 = a1;
        uint64_t v8 = a3;
        uint64_t v9 = 5LL;
        goto LABEL_30;
      case 6u:
        uint64_t v17 = *(void *)a2;
        unint64_t v16 = *((void *)a2 + 1);
        sub_100020AFC(v17, v16);
        *(void *)a1 = v17;
        *((void *)a1 + 1) = v16;
        BOOL v7 = a1;
        uint64_t v8 = a3;
        uint64_t v9 = 6LL;
        goto LABEL_30;
      case 7u:
        *a1 = *a2;
        *(_WORD *)(a1 + 1) = *(_WORD *)(a2 + 1);
        uint64_t v18 = (int *)type metadata accessor for NANAttribute.CustomDeviceInformation.CustomAttributes(0LL);
        uint64_t v19 = v18[6];
        uint64_t v20 = &a1[v19];
        int64_t v21 = &a2[v19];
        uint64_t v22 = type metadata accessor for P256.KeyAgreement.PublicKey(0LL);
        uint64_t v23 = *(void *)(v22 - 8);
        if ((*(unsigned int (**)(char *, uint64_t, uint64_t))(v23 + 48))(v21, 1LL, v22))
        {
          uint64_t v24 = sub_100002274((uint64_t *)&unk_10040D470);
          memcpy(v20, v21, *(void *)(*(void *)(v24 - 8) + 64LL));
        }

        else
        {
          (*(void (**)(char *, char *, uint64_t))(v23 + 16))(v20, v21, v22);
          (*(void (**)(char *, void, uint64_t, uint64_t))(v23 + 56))(v20, 0LL, 1LL, v22);
        }

        uint64_t v28 = v18[7];
        uint64_t v29 = &a1[v28];
        unint64_t v30 = &a2[v28];
        unint64_t v31 = *((void *)v30 + 1);
        if (v31 >> 60 == 15)
        {
          *(_OWORD *)uint64_t v29 = *(_OWORD *)v30;
        }

        else
        {
          uint64_t v32 = *(void *)v30;
          sub_100020AFC(*(void *)v30, *((void *)v30 + 1));
          *(void *)uint64_t v29 = v32;
          *((void *)v29 + 1) = v31;
        }

        uint64_t v33 = v18[8];
        uint64_t v34 = &a1[v33];
        unint64_t v35 = &a2[v33];
        unint64_t v36 = *((void *)v35 + 1);
        if (v36 >> 60 == 15)
        {
          *(_OWORD *)uint64_t v34 = *(_OWORD *)v35;
        }

        else
        {
          uint64_t v37 = *(void *)v35;
          sub_100020AFC(*(void *)v35, *((void *)v35 + 1));
          *(void *)uint64_t v34 = v37;
          *((void *)v34 + 1) = v36;
        }

        uint64_t v38 = v18[9];
        uint64_t v39 = &a1[v38];
        unint64_t v40 = &a2[v38];
        unint64_t v41 = *((void *)v40 + 1);
        if (v41 >> 60 == 15)
        {
          *(_OWORD *)uint64_t v39 = *(_OWORD *)v40;
        }

        else
        {
          uint64_t v42 = *(void *)v40;
          sub_100020AFC(*(void *)v40, *((void *)v40 + 1));
          *(void *)uint64_t v39 = v42;
          *((void *)v39 + 1) = v41;
        }

        uint64_t v43 = v18[10];
        __int128 v44 = &a1[v43];
        uint64_t v45 = &a2[v43];
        uint64_t v46 = type metadata accessor for UUID(0LL);
        uint64_t v47 = *(void *)(v46 - 8);
        if ((*(unsigned int (**)(char *, uint64_t, uint64_t))(v47 + 48))(v45, 1LL, v46))
        {
          uint64_t v48 = sub_100002274(qword_100410330);
          memcpy(v44, v45, *(void *)(*(void *)(v48 - 8) + 64LL));
        }

        else
        {
          (*(void (**)(char *, char *, uint64_t))(v47 + 16))(v44, v45, v46);
          (*(void (**)(char *, void, uint64_t, uint64_t))(v47 + 56))(v44, 0LL, 1LL, v46);
        }

        uint64_t v49 = v18[11];
        uint64_t v50 = *(void *)&a2[v49];
        *(void *)&a1[v49] = v50;
        uint64_t v51 = v18[12];
        char v52 = &a1[v51];
        uint64_t v53 = &a2[v51];
        uint64_t v54 = type metadata accessor for NANInternetSharingStatistics.Requester(0LL);
        uint64_t v55 = *(void *)(v54 - 8);
        uint64_t v56 = *(unsigned int (**)(char *, uint64_t, uint64_t))(v55 + 48);
        swift_bridgeObjectRetain(v50);
        if (v56(v53, 1LL, v54))
        {
          uint64_t v57 = sub_100002274((uint64_t *)&unk_10040DCC0);
          memcpy(v52, v53, *(void *)(*(void *)(v57 - 8) + 64LL));
        }

        else
        {
          uint64_t v58 = type metadata accessor for DispatchTimeInterval(0LL);
          (*(void (**)(char *, char *, uint64_t))(*(void *)(v58 - 8) + 16LL))(v52, v53, v58);
          v52[*(int *)(v54 + 20)] = v53[*(int *)(v54 + 20)];
          (*(void (**)(char *, void, uint64_t, uint64_t))(v55 + 56))(v52, 0LL, 1LL, v54);
        }

        uint64_t v59 = v18[13];
        uint64_t v60 = &a1[v59];
        int v61 = &a2[v59];
        __int128 v62 = *(_OWORD *)v61;
        *(_OWORD *)(v60 + 9) = *(_OWORD *)(v61 + 9);
        *(_OWORD *)uint64_t v60 = v62;
        BOOL v7 = a1;
        uint64_t v8 = a3;
        uint64_t v9 = 7LL;
        goto LABEL_30;
      case 8u:
        __int16 v25 = *(_WORD *)a2;
        a1[2] = a2[2];
        *(_WORD *)a1 = v25;
        uint64_t v27 = *((void *)a2 + 1);
        unint64_t v26 = *((void *)a2 + 2);
        sub_100020AFC(v27, v26);
        *((void *)a1 + 1) = v27;
        *((void *)a1 + 2) = v26;
        BOOL v7 = a1;
        uint64_t v8 = a3;
        uint64_t v9 = 8LL;
LABEL_30:
        swift_storeEnumTagMultiPayload(v7, v8, v9);
        break;
      default:
        memcpy(a1, a2, *(void *)(*(void *)(a3 - 8) + 64LL));
        break;
    }
  }

  return a1;
}

char *sub_10006FA60(char *a1, char *a2, uint64_t a3)
{
  int EnumCaseMultiPayload = swift_getEnumCaseMultiPayload(a2, a3);
  if (EnumCaseMultiPayload == 7)
  {
    *a1 = *a2;
    *(_WORD *)(a1 + 1) = *(_WORD *)(a2 + 1);
    uint64_t v11 = (int *)type metadata accessor for NANAttribute.CustomDeviceInformation.CustomAttributes(0LL);
    uint64_t v12 = v11[6];
    uint64_t v13 = &a1[v12];
    unint64_t v14 = &a2[v12];
    uint64_t v15 = type metadata accessor for P256.KeyAgreement.PublicKey(0LL);
    uint64_t v16 = *(void *)(v15 - 8);
    if ((*(unsigned int (**)(char *, uint64_t, uint64_t))(v16 + 48))(v14, 1LL, v15))
    {
      uint64_t v17 = sub_100002274((uint64_t *)&unk_10040D470);
      memcpy(v13, v14, *(void *)(*(void *)(v17 - 8) + 64LL));
    }

    else
    {
      (*(void (**)(char *, char *, uint64_t))(v16 + 32))(v13, v14, v15);
      (*(void (**)(char *, void, uint64_t, uint64_t))(v16 + 56))(v13, 0LL, 1LL, v15);
    }

    *(_OWORD *)&a1[v11[7]] = *(_OWORD *)&a2[v11[7]];
    *(_OWORD *)&a1[v11[8]] = *(_OWORD *)&a2[v11[8]];
    *(_OWORD *)&a1[v11[9]] = *(_OWORD *)&a2[v11[9]];
    uint64_t v18 = v11[10];
    uint64_t v19 = &a1[v18];
    uint64_t v20 = &a2[v18];
    uint64_t v21 = type metadata accessor for UUID(0LL);
    uint64_t v22 = *(void *)(v21 - 8);
    if ((*(unsigned int (**)(char *, uint64_t, uint64_t))(v22 + 48))(v20, 1LL, v21))
    {
      uint64_t v23 = sub_100002274(qword_100410330);
      memcpy(v19, v20, *(void *)(*(void *)(v23 - 8) + 64LL));
    }

    else
    {
      (*(void (**)(char *, char *, uint64_t))(v22 + 32))(v19, v20, v21);
      (*(void (**)(char *, void, uint64_t, uint64_t))(v22 + 56))(v19, 0LL, 1LL, v21);
    }

    *(void *)&a1[v11[11]] = *(void *)&a2[v11[11]];
    uint64_t v24 = v11[12];
    __int16 v25 = &a1[v24];
    unint64_t v26 = &a2[v24];
    uint64_t v27 = type metadata accessor for NANInternetSharingStatistics.Requester(0LL);
    uint64_t v28 = *(void *)(v27 - 8);
    if ((*(unsigned int (**)(char *, uint64_t, uint64_t))(v28 + 48))(v26, 1LL, v27))
    {
      uint64_t v29 = sub_100002274((uint64_t *)&unk_10040DCC0);
      memcpy(v25, v26, *(void *)(*(void *)(v29 - 8) + 64LL));
    }

    else
    {
      uint64_t v30 = type metadata accessor for DispatchTimeInterval(0LL);
      (*(void (**)(char *, char *, uint64_t))(*(void *)(v30 - 8) + 32LL))(v25, v26, v30);
      v25[*(int *)(v27 + 20)] = v26[*(int *)(v27 + 20)];
      (*(void (**)(char *, void, uint64_t, uint64_t))(v28 + 56))(v25, 0LL, 1LL, v27);
    }

    uint64_t v31 = v11[13];
    uint64_t v32 = &a1[v31];
    uint64_t v33 = &a2[v31];
    *(_OWORD *)uint64_t v32 = *(_OWORD *)v33;
    *(_OWORD *)(v32 + 9) = *(_OWORD *)(v33 + 9);
    uint64_t v8 = a1;
    uint64_t v9 = a3;
    uint64_t v10 = 7LL;
    goto LABEL_15;
  }

  if (!EnumCaseMultiPayload)
  {
    uint64_t v7 = type metadata accessor for NWEndpoint.Port(0LL);
    (*(void (**)(char *, char *, uint64_t))(*(void *)(v7 - 8) + 32LL))(a1, a2, v7);
    uint64_t v8 = a1;
    uint64_t v9 = a3;
    uint64_t v10 = 0LL;
LABEL_15:
    swift_storeEnumTagMultiPayload(v8, v9, v10);
    return a1;
  }

  memcpy(a1, a2, *(void *)(*(void *)(a3 - 8) + 64LL));
  return a1;
}

char *sub_10006FD1C(char *a1, char *a2, uint64_t a3)
{
  if (a1 != a2)
  {
    sub_10005802C((uint64_t)a1, type metadata accessor for NANGenericServiceProtocol.Attribute);
    int EnumCaseMultiPayload = swift_getEnumCaseMultiPayload(a2, a3);
    if (EnumCaseMultiPayload == 7)
    {
      *a1 = *a2;
      *(_WORD *)(a1 + 1) = *(_WORD *)(a2 + 1);
      uint64_t v11 = (int *)type metadata accessor for NANAttribute.CustomDeviceInformation.CustomAttributes(0LL);
      uint64_t v12 = v11[6];
      uint64_t v13 = &a1[v12];
      unint64_t v14 = &a2[v12];
      uint64_t v15 = type metadata accessor for P256.KeyAgreement.PublicKey(0LL);
      uint64_t v16 = *(void *)(v15 - 8);
      if ((*(unsigned int (**)(char *, uint64_t, uint64_t))(v16 + 48))(v14, 1LL, v15))
      {
        uint64_t v17 = sub_100002274((uint64_t *)&unk_10040D470);
        memcpy(v13, v14, *(void *)(*(void *)(v17 - 8) + 64LL));
      }

      else
      {
        (*(void (**)(char *, char *, uint64_t))(v16 + 32))(v13, v14, v15);
        (*(void (**)(char *, void, uint64_t, uint64_t))(v16 + 56))(v13, 0LL, 1LL, v15);
      }

      *(_OWORD *)&a1[v11[7]] = *(_OWORD *)&a2[v11[7]];
      *(_OWORD *)&a1[v11[8]] = *(_OWORD *)&a2[v11[8]];
      *(_OWORD *)&a1[v11[9]] = *(_OWORD *)&a2[v11[9]];
      uint64_t v18 = v11[10];
      uint64_t v19 = &a1[v18];
      uint64_t v20 = &a2[v18];
      uint64_t v21 = type metadata accessor for UUID(0LL);
      uint64_t v22 = *(void *)(v21 - 8);
      if ((*(unsigned int (**)(char *, uint64_t, uint64_t))(v22 + 48))(v20, 1LL, v21))
      {
        uint64_t v23 = sub_100002274(qword_100410330);
        memcpy(v19, v20, *(void *)(*(void *)(v23 - 8) + 64LL));
      }

      else
      {
        (*(void (**)(char *, char *, uint64_t))(v22 + 32))(v19, v20, v21);
        (*(void (**)(char *, void, uint64_t, uint64_t))(v22 + 56))(v19, 0LL, 1LL, v21);
      }

      *(void *)&a1[v11[11]] = *(void *)&a2[v11[11]];
      uint64_t v24 = v11[12];
      __int16 v25 = &a1[v24];
      unint64_t v26 = &a2[v24];
      uint64_t v27 = type metadata accessor for NANInternetSharingStatistics.Requester(0LL);
      uint64_t v28 = *(void *)(v27 - 8);
      if ((*(unsigned int (**)(char *, uint64_t, uint64_t))(v28 + 48))(v26, 1LL, v27))
      {
        uint64_t v29 = sub_100002274((uint64_t *)&unk_10040DCC0);
        memcpy(v25, v26, *(void *)(*(void *)(v29 - 8) + 64LL));
      }

      else
      {
        uint64_t v30 = type metadata accessor for DispatchTimeInterval(0LL);
        (*(void (**)(char *, char *, uint64_t))(*(void *)(v30 - 8) + 32LL))(v25, v26, v30);
        v25[*(int *)(v27 + 20)] = v26[*(int *)(v27 + 20)];
        (*(void (**)(char *, void, uint64_t, uint64_t))(v28 + 56))(v25, 0LL, 1LL, v27);
      }

      uint64_t v31 = v11[13];
      uint64_t v32 = &a1[v31];
      uint64_t v33 = &a2[v31];
      *(_OWORD *)uint64_t v32 = *(_OWORD *)v33;
      *(_OWORD *)(v32 + 9) = *(_OWORD *)(v33 + 9);
      uint64_t v8 = a1;
      uint64_t v9 = a3;
      uint64_t v10 = 7LL;
      goto LABEL_16;
    }

    if (!EnumCaseMultiPayload)
    {
      uint64_t v7 = type metadata accessor for NWEndpoint.Port(0LL);
      (*(void (**)(char *, char *, uint64_t))(*(void *)(v7 - 8) + 32LL))(a1, a2, v7);
      uint64_t v8 = a1;
      uint64_t v9 = a3;
      uint64_t v10 = 0LL;
LABEL_16:
      swift_storeEnumTagMultiPayload(v8, v9, v10);
      return a1;
    }

    memcpy(a1, a2, *(void *)(*(void *)(a3 - 8) + 64LL));
  }

  return a1;
}

uint64_t getEnumTagSinglePayload for NANAttribute(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(*(void *)(a3 - 8) + 48LL))();
}

uint64_t storeEnumTagSinglePayload for NANAttribute(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(*(void *)(a4 - 8) + 56LL))();
}

uint64_t sub_10007000C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return swift_storeEnumTagMultiPayload(a1, a3, a2);
}

uint64_t sub_10007001C(uint64_t a1)
{
  uint64_t result = type metadata accessor for NWEndpoint.Port(319LL);
  if (v3 <= 0x3F)
  {
    v5[0] = *(void *)(result - 8) + 64LL;
    v5[1] = &unk_10033C250;
    v5[2] = &unk_10033C268;
    v5[3] = &unk_10033C268;
    v5[4] = &unk_10033C280;
    v5[5] = &unk_10033C280;
    v5[6] = &unk_10033C280;
    uint64_t result = type metadata accessor for NANAttribute.CustomDeviceInformation.CustomAttributes(319LL);
    if (v4 <= 0x3F)
    {
      v5[7] = *(void *)(result - 8) + 64LL;
      v5[8] = &unk_10033C298;
      swift_initEnumMetadataMultiPayload(a1, 256LL, 9LL, v5);
      return 0LL;
    }
  }

  return result;
}

uint64_t sub_1000700C8()
{
  return sub_10000AF70( &qword_100406320,  type metadata accessor for NANGenericServiceProtocol.Attribute,  (uint64_t)&unk_10033C2B0);
}

unint64_t sub_1000700F8()
{
  unint64_t result = qword_100406328;
  if (!qword_100406328)
  {
    unint64_t result = swift_getWitnessTable(&unk_10033C458, &type metadata for NANGenericServiceProtocol.AttributeID);
    atomic_store(result, (unint64_t *)&qword_100406328);
  }

  return result;
}

unint64_t sub_10007013C()
{
  unint64_t result = qword_100406330;
  if (!qword_100406330)
  {
    unint64_t result = swift_getWitnessTable(&unk_10033C420, &type metadata for NANGenericServiceProtocol.AttributeID);
    atomic_store(result, (unint64_t *)&qword_100406330);
  }

  return result;
}

unint64_t sub_100070180()
{
  unint64_t result = qword_100406468;
  if (!qword_100406468)
  {
    uint64_t v1 = sub_1000022F8(&qword_100406460);
    sub_1000572E4( &qword_100406470,  &qword_100406478,  (uint64_t)&protocol conformance descriptor for TypeLengthValue<A, B>);
    unint64_t result = swift_getWitnessTable(&protocol conformance descriptor for <A> [A], v1);
    atomic_store(result, (unint64_t *)&qword_100406468);
  }

  return result;
}

uint64_t sub_1000701FC(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = type metadata accessor for NANGenericServiceProtocol.Attribute(0LL);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v4 - 8) + 40LL))(a2, a1, v4);
  return a2;
}

unint64_t sub_100070240()
{
  unint64_t result = qword_100406488;
  if (!qword_100406488)
  {
    unint64_t result = swift_getWitnessTable(&unk_10034078C, &type metadata for BinaryDecoder.UnkeyedContainer);
    atomic_store(result, (unint64_t *)&qword_100406488);
  }

  return result;
}

unint64_t sub_100070284()
{
  unint64_t result = qword_100406490;
  if (!qword_100406490)
  {
    unint64_t result = swift_getWitnessTable(&protocol conformance descriptor for OUI, &type metadata for OUI);
    atomic_store(result, (unint64_t *)&qword_100406490);
  }

  return result;
}

unint64_t sub_1000702C8()
{
  unint64_t result = qword_100406498;
  if (!qword_100406498)
  {
    unint64_t result = swift_getWitnessTable(&protocol conformance descriptor for Data, &type metadata for Data);
    atomic_store(result, (unint64_t *)&qword_100406498);
  }

  return result;
}

uint64_t sub_10007030C(uint64_t a1, unint64_t a2, char a3)
{
  if (a3 == 3) {
    return sub_100070320(a1, a2);
  }
  return a1;
}

uint64_t sub_100070320(uint64_t a1, unint64_t a2)
{
  if (a2 >= 4) {
    return swift_bridgeObjectRelease(a2);
  }
  return result;
}

char *sub_100070338(char *result, uint64_t a2, uint64_t a3)
{
  uint64_t v13 = result;
  uint64_t v4 = a2 - (void)result;
  if (__OFSUB__(a2, result))
  {
LABEL_18:
    __break(1u);
    goto LABEL_19;
  }

  if (!v4) {
    return (char *)_swiftEmptyArrayStorage;
  }
  uint64_t result = (char *)sub_1000697EC(0, v4 & ~(v4 >> 63), 0);
  if ((v4 & 0x8000000000000000LL) == 0)
  {
    uint64_t v6 = (char *)a2;
    for (int64_t i = v6 - v13; ; --i)
    {
      uint64_t v8 = *(void *)(a3 + 24);
      uint64_t v9 = *(void *)(a3 + 32);
      sub_1000237C8(a3, v8);
      unint64_t v10 = sub_100089CC8();
      uint64_t result = (char *)UnkeyedDecodingContainer.inferredDecode<A>()( v8,  (uint64_t)&type metadata for NANBitmap.Band,  v9,  v10);
      if (v3)
      {
        swift_release(_swiftEmptyArrayStorage);
        return (char *)_swiftEmptyArrayStorage;
      }

      unint64_t v12 = _swiftEmptyArrayStorage[2];
      unint64_t v11 = _swiftEmptyArrayStorage[3];
      if (v12 >= v11 >> 1) {
        uint64_t result = (char *)sub_1000697EC(v11 > 1, v12 + 1, 1);
      }
      _swiftEmptyArrayStorage[2] = v12 + 1;
      *((_BYTE *)&_swiftEmptyArrayStorage[4] + v12) = v15;
      if (!i) {
        goto LABEL_17;
      }
      if (!--v4) {
        return (char *)_swiftEmptyArrayStorage;
      }
    }

    __break(1u);
LABEL_17:
    __break(1u);
    goto LABEL_18;
  }

char *sub_100070498(char *result, uint64_t a2, uint64_t a3)
{
  uint64_t v17 = result;
  uint64_t v4 = a2 - (void)result;
  if (__OFSUB__(a2, result))
  {
LABEL_18:
    __break(1u);
    goto LABEL_19;
  }

  uint64_t v5 = v3;
  if (!v4) {
    return (char *)_swiftEmptyArrayStorage;
  }
  uint64_t result = (char *)sub_1000697D0(0, v4 & ~(v4 >> 63), 0);
  if ((v4 & 0x8000000000000000LL) == 0)
  {
    uint64_t v6 = (char *)a2;
    int64_t v7 = v6 - v17;
    while (1)
    {
      uint64_t v8 = *(void *)(a3 + 24);
      uint64_t v9 = *(void *)(a3 + 32);
      sub_1000237C8(a3, v8);
      unint64_t v10 = sub_100089D0C();
      uint64_t result = (char *)UnkeyedDecodingContainer.inferredDecode<A>()( v8,  (uint64_t)&type metadata for NANBitmap.Channel,  v9,  v10);
      if (v5)
      {
        swift_release(_swiftEmptyArrayStorage);
        return (char *)_swiftEmptyArrayStorage;
      }

      __int16 v11 = v22;
      char v12 = v23;
      unint64_t v14 = _swiftEmptyArrayStorage[2];
      unint64_t v13 = _swiftEmptyArrayStorage[3];
      if (v14 >= v13 >> 1)
      {
        uint64_t result = (char *)sub_1000697D0(v13 > 1, v14 + 1, 1);
        char v12 = v23;
        __int16 v11 = v22;
      }

      _swiftEmptyArrayStorage[2] = v14 + 1;
      char v15 = (char *)_swiftEmptyArrayStorage + 10 * v14;
      v15[32] = v19;
      *((_WORD *)v15 + 17) = v20;
      v15[36] = v21;
      *((_WORD *)v15 + 19) = v11;
      v15[40] = v12;
      if (!v7) {
        goto LABEL_17;
      }
      --v7;
      --v4;
      uint64_t v5 = 0LL;
      if (!v4) {
        return (char *)_swiftEmptyArrayStorage;
      }
    }

    __break(1u);
LABEL_17:
    __break(1u);
    goto LABEL_18;
  }

void *NANBitmap.Band.tvWhiteSpaces.unsafeMutableAddressor()
{
  return &static NANBitmap.Band.tvWhiteSpaces;
}

void *NANBitmap.Band.sub1GHzExcludingTVWhiteSpaces.unsafeMutableAddressor()
{
  return &static NANBitmap.Band.sub1GHzExcludingTVWhiteSpaces;
}

void *NANBitmap.Band.ghz2_4.unsafeMutableAddressor()
{
  return &static NANBitmap.Band.ghz2_4;
}

void *NANBitmap.Band.ghz3_6.unsafeMutableAddressor()
{
  return &static NANBitmap.Band.ghz3_6;
}

uint64_t static NANBitmap.Band.ghz3_6.getter()
{
  return 8LL;
}

void *NANBitmap.Band.ghz_4_9_to_5_0.unsafeMutableAddressor()
{
  return &static NANBitmap.Band.ghz_4_9_to_5_0;
}

void *NANBitmap.Band.ghz_60.unsafeMutableAddressor()
{
  return &static NANBitmap.Band.ghz_60;
}

void *NANBitmap.Band.ghz_45.unsafeMutableAddressor()
{
  return &static NANBitmap.Band.ghz_45;
}

uint64_t static NANBitmap.Band.ghz_45.getter()
{
  return 64LL;
}

void *NANBitmap.Band.ghz_6.unsafeMutableAddressor()
{
  return &static NANBitmap.Band.ghz_6;
}

uint64_t static NANBitmap.Band.ghz_6.getter()
{
  return 128LL;
}

void *NANBitmap.Band.all.unsafeMutableAddressor()
{
  return &static NANBitmap.Band.all;
}

uint64_t static NANBitmap.Band.all.getter()
{
  return 255LL;
}

CoreP2P::NANBitmap::Band_optional __swiftcall NANBitmap.Band.Iterator.next()()
{
  uint64_t v1 = *((void *)v0 + 1);
  if (v1 <= 7)
  {
    if (v1 >= -8)
    {
      int v10 = *v0;
      uint64_t v8 = 8LL;
      unint64_t v3 = *((void *)v0 + 1);
      if (v1 < 0) {
        goto LABEL_23;
      }
LABEL_19:
      if (v3 > 7)
      {
        unsigned __int8 v2 = 0;
LABEL_16:
        *((void *)v0 + 1) = v8 + 1;
        return (CoreP2P::NANBitmap::Band_optional)(v2 | ((v1 > 7) << 8));
      }

      int v11 = 1 << v3;
      while ((v11 & ~v10) != 0)
      {
        *((void *)v0 + 1) = ++v3;
        if ((v3 & 0x8000000000000000LL) == 0) {
          goto LABEL_19;
        }
LABEL_23:
        int v11 = 0;
        if (v3 <= 0xFFFFFFFFFFFFFFF8LL)
        {
          unsigned __int8 v2 = 0;
          uint64_t v8 = -8LL;
          goto LABEL_16;
        }
      }
    }

    else
    {
      unint64_t v3 = *((void *)v0 + 1);
    }

    unint64_t v4 = v3 - 9;
    int v5 = 1 << v3;
    uint64_t v6 = -8LL;
    if (v3 > 0xFFFFFFFFFFFFFFF8LL) {
      uint64_t v6 = v3;
    }
    if ((v3 & 0x8000000000000000LL) != 0LL) {
      LOBYTE(v5) = 0;
    }
    else {
      uint64_t v6 = v3;
    }
    BOOL v7 = __CFADD__(v4, 18LL);
    if (v4 <= 0xFFFFFFFFFFFFFFEELL) {
      uint64_t v8 = v3;
    }
    else {
      uint64_t v8 = v6;
    }
    if (v3 != -9LL && v7) {
      unsigned __int8 v2 = v5;
    }
    else {
      unsigned __int8 v2 = 0;
    }
    goto LABEL_16;
  }

  unsigned __int8 v2 = 0;
  return (CoreP2P::NANBitmap::Band_optional)(v2 | ((v1 > 7) << 8));
}

CoreP2P::NANBitmap::Band_optional sub_100070788@<W0>(Swift::UInt8 *a1@<X8>)
{
  CoreP2P::NANBitmap::Band_optional result = NANBitmap.Band.Iterator.next()();
  *a1 = result.value.rawValue;
  a1[1] = result.is_nil;
  return result;
}

CoreP2P::NANBitmap::Band::Iterator __swiftcall NANBitmap.Band.makeIterator()()
{
  Swift::Int v0 = 0LL;
  result.currentIndex = v0;
  return result;
}

uint64_t NANBitmap.Band.bands.getter(uint64_t result)
{
  uint64_t v1 = 0LL;
  int v2 = result;
  unint64_t v3 = _swiftEmptyArrayStorage;
  while (v1 >= -8)
  {
    while (v1 < 0)
    {
      int v4 = 0;
      if ((unint64_t)v1 <= 0xFFFFFFFFFFFFFFF8LL)
      {
        unsigned __int8 v6 = 0;
        uint64_t v1 = -7LL;
        if (__OFADD__(-8LL, 1LL)) {
          goto LABEL_49;
        }
        goto LABEL_34;
      }

uint64_t sub_100070978(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v6 = sub_100086F38();
  return RawRepresentable<>.init(from:)(a1, a2, a3, v6);
}

uint64_t sub_1000709D4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v6 = sub_100086F38();
  return RawRepresentable<>.encode(to:)(a1, a2, a3, v6);
}

void sub_100070A20(uint64_t a1@<X8>)
{
  *(_BYTE *)a1 = *v1;
  *(void *)(a1 + 8) = 0LL;
}

uint64_t sub_100070A30()
{
  return sub_10008011C(*v0);
}

uint64_t sub_100070A38(uint64_t a1, _BYTE *a2, uint64_t a3)
{
  return sub_100176B7C(a1, a2, a3, *v3);
}

uint64_t sub_100070A40(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return Sequence.withContiguousStorageIfAvailable<A>(_:)(a1, a2, a4, a3);
}

void sub_100070A60(_BYTE *a1@<X8>)
{
  *a1 = 0;
}

uint64_t sub_100070A68@<X0>(uint64_t a1@<X0>, _BYTE *a2@<X8>)
{
  char v4 = sub_10019AD1C();
  uint64_t result = swift_bridgeObjectRelease(a1);
  *a2 = v4;
  return result;
}

unint64_t NANBitmap.Channel.channelBitmap.getter(unint64_t a1)
{
  return a1 >> 16;
}

uint64_t NANBitmap.Channel.channelBitmap.setter(uint64_t result)
{
  *(_WORD *)(v1 + 2) = result;
  return result;
}

uint64_t (*NANBitmap.Channel.channelBitmap.modify())()
{
  return NANBitmap.Channel.operatingClass.getter;
}

unint64_t NANBitmap.Channel.primaryChannelBitmap.getter(unint64_t a1)
{
  return HIDWORD(a1);
}

uint64_t NANBitmap.Channel.primaryChannelBitmap.setter(uint64_t result)
{
  *(_BYTE *)(v1 + 4) = result;
  return result;
}

uint64_t (*NANBitmap.Channel.primaryChannelBitmap.modify())()
{
  return NANBitmap.Channel.operatingClass.getter;
}

uint64_t NANBitmap.Channel.auxiliaryChannelBitmap.getter(uint64_t a1, char a2)
{
  return HIWORD(a1) | ((a2 & 1) << 16);
}

uint64_t NANBitmap.Channel.auxiliaryChannelBitmap.setter(uint64_t result)
{
  *(_WORD *)(v1 + 6) = result;
  *(_BYTE *)(v1 + 8) = BYTE2(result) & 1;
  return result;
}

uint64_t (*NANBitmap.Channel.auxiliaryChannelBitmap.modify())()
{
  return NANBitmap.Channel.operatingClass.getter;
}

CoreP2P::NANBitmap::Channel __swiftcall NANBitmap.Channel.init(operatingClass:channelBitmap:primaryChannelBitmap:auxiliaryChannelBitmap:)( Swift::UInt8 operatingClass, Swift::UInt16 channelBitmap, Swift::UInt8 primaryChannelBitmap, Swift::UInt16_optional auxiliaryChannelBitmap)
{
  unint64_t v4 = operatingClass | ((unint64_t)channelBitmap << 16) | ((unint64_t)primaryChannelBitmap << 32) | (*(void *)&auxiliaryChannelBitmap.value << 48);
  Swift::Bool is_nil = auxiliaryChannelBitmap.is_nil;
  result.operatingClass = v4;
  result.gap1 = BYTE1(v4);
  result.channelBitmap = WORD1(v4);
  result.primaryChannelBitmap = BYTE4(v4);
  result.gap5 = BYTE5(v4);
  result.auxiliaryChannelBitmap.value = HIWORD(v4);
  result.auxiliaryChannelBitmap.Swift::Bool is_nil = is_nil;
  return result;
}

void NANBitmap.Channel.hash(into:)(int a1, unint64_t a2, char a3)
{
  Swift::UInt16 v4 = HIWORD(a2);
  unint64_t v5 = a2 >> 16;
  unint64_t v6 = HIDWORD(a2);
  Hasher._combine(_:)(a2);
  Hasher._combine(_:)(v5);
  Hasher._combine(_:)(v6);
  if ((a3 & 1) != 0)
  {
    Hasher._combine(_:)(0);
  }

  else
  {
    Hasher._combine(_:)(1u);
    Hasher._combine(_:)(v4);
  }

uint64_t static NANBitmap.Channel.__derived_struct_equals(_:_:)( unint64_t a1, char a2, unint64_t a3, char a4)
{
  uint64_t result = 0LL;
  if (a1 == a3 && ((a1 >> 16) & 0xFFFFFF) == ((a3 >> 16) & 0xFFFFFF))
  {
    if ((a2 & 1) != 0)
    {
      if ((a4 & 1) != 0) {
        return 1LL;
      }
    }

    else if (HIWORD(a1) == HIWORD(a3) && (a4 & 1) == 0)
    {
      return 1LL;
    }

    return 0LL;
  }

  return result;
}

uint64_t sub_100070C14()
{
  return ((uint64_t (*)(uint64_t, unint64_t))((char *)sub_100070C50 + 4 * byte_10033C480[*v0]))( 0x6E6974617265706FLL,  0xEE007373616C4367LL);
}

uint64_t sub_100070C50()
{
  return 0x426C656E6E616863LL;
}

unint64_t sub_100070C74()
{
  return 0xD000000000000014LL;
}

unint64_t sub_100070C90()
{
  return 0xD000000000000016LL;
}

uint64_t sub_100070CB0@<X0>(uint64_t a1@<X0>, unint64_t a2@<X1>, _BYTE *a3@<X8>)
{
  uint64_t result = sub_10008657C(a1, a2);
  *a3 = result;
  return result;
}

void sub_100070CD4(_BYTE *a1@<X8>)
{
  *a1 = 4;
}

uint64_t sub_100070CE0(uint64_t a1)
{
  unint64_t v2 = sub_1000800D8();
  return CodingKey.description.getter(a1, v2);
}

uint64_t sub_100070D08(uint64_t a1)
{
  unint64_t v2 = sub_1000800D8();
  return CodingKey.debugDescription.getter(a1, v2);
}

uint64_t NANBitmap.Channel.encode(to:)(void *a1, unint64_t a2, char a3)
{
  uint64_t v7 = sub_100002274(&qword_1004064D8);
  uint64_t v8 = *(void *)(v7 - 8);
  __chkstk_darwin(v7);
  uint64_t v10 = (char *)&v15 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v11 = a1[3];
  uint64_t v12 = a1[4];
  sub_100021104(a1, v11);
  unint64_t v13 = sub_1000800D8();
  dispatch thunk of Encoder.container<A>(keyedBy:)( &type metadata for NANBitmap.Channel.CodingKeys,  &type metadata for NANBitmap.Channel.CodingKeys,  v13,  v11,  v12);
  char v19 = 0;
  KeyedEncodingContainer.encode(_:forKey:)(a2, &v19, v7);
  if (!v3)
  {
    char v18 = 1;
    KeyedEncodingContainer.encode(_:forKey:)(a2 >> 16, &v18, v7);
    char v17 = 2;
    KeyedEncodingContainer.encode(_:forKey:)(HIDWORD(a2), &v17, v7);
    char v16 = 3;
    KeyedEncodingContainer.encodeIfPresent(_:forKey:)(HIWORD(a2) | ((a3 & 1) << 16), &v16, v7);
  }

  return (*(uint64_t (**)(char *, uint64_t))(v8 + 8))(v10, v7);
}

Swift::Int NANBitmap.Channel.hashValue.getter(unint64_t a1, char a2)
{
  unint64_t v4 = a1 >> 16;
  unint64_t v5 = HIDWORD(a1);
  Hasher.init(_seed:)(v7, 0LL);
  Hasher._combine(_:)(a1);
  Hasher._combine(_:)(v4);
  Hasher._combine(_:)(v5);
  if ((a2 & 1) != 0)
  {
    Hasher._combine(_:)(0);
  }

  else
  {
    Hasher._combine(_:)(1u);
    Hasher._combine(_:)(HIWORD(a1));
  }

  return Hasher._finalize()();
}

Swift::Int sub_100070F48()
{
  Swift::UInt16 v1 = *(_WORD *)(v0 + 6);
  int v2 = *(unsigned __int8 *)(v0 + 8);
  Swift::UInt8 v3 = *(_BYTE *)v0;
  Swift::UInt16 v4 = *(_WORD *)(v0 + 2);
  Swift::UInt8 v5 = *(_BYTE *)(v0 + 4);
  Hasher.init(_seed:)(v7, 0LL);
  Hasher._combine(_:)(v3);
  Hasher._combine(_:)(v4);
  Hasher._combine(_:)(v5);
  if (v2 == 1)
  {
    Hasher._combine(_:)(0);
  }

  else
  {
    Hasher._combine(_:)(1u);
    Hasher._combine(_:)(v1);
  }

  return Hasher._finalize()();
}

void sub_100070FF0()
{
  Swift::UInt16 v1 = *(_WORD *)(v0 + 6);
  int v2 = *(unsigned __int8 *)(v0 + 8);
  Swift::UInt16 v3 = *(_WORD *)(v0 + 2);
  Swift::UInt8 v4 = *(_BYTE *)(v0 + 4);
  Hasher._combine(_:)(*(_BYTE *)v0);
  Hasher._combine(_:)(v3);
  Hasher._combine(_:)(v4);
  if (v2 == 1)
  {
    Hasher._combine(_:)(0);
  }

  else
  {
    Hasher._combine(_:)(1u);
    Hasher._combine(_:)(v1);
  }

Swift::Int sub_10007106C(uint64_t a1)
{
  Swift::UInt16 v2 = *(_WORD *)(v1 + 6);
  int v3 = *(unsigned __int8 *)(v1 + 8);
  Swift::UInt8 v4 = *(_BYTE *)v1;
  Swift::UInt16 v5 = *(_WORD *)(v1 + 2);
  Swift::UInt8 v6 = *(_BYTE *)(v1 + 4);
  Hasher.init(_seed:)(v8, a1);
  Hasher._combine(_:)(v4);
  Hasher._combine(_:)(v5);
  Hasher._combine(_:)(v6);
  if (v3 == 1)
  {
    Hasher._combine(_:)(0);
  }

  else
  {
    Hasher._combine(_:)(1u);
    Hasher._combine(_:)(v2);
  }

  return Hasher._finalize()();
}

uint64_t sub_100071110@<X0>(void *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t result = sub_1000853DC(a1);
  if (!v2)
  {
    *(_BYTE *)a2 = result;
    *(_WORD *)(a2 + 2) = WORD1(result);
    *(_BYTE *)(a2 + 4) = BYTE4(result);
    *(_WORD *)(a2 + 6) = HIWORD(result);
    *(_BYTE *)(a2 + 8) = v5 & 1;
  }

  return result;
}

unint64_t NANBitmap.Channel.init(from:)(void *a1)
{
  return sub_1000853DC(a1) & 0xFFFF00FFFFFF00FFLL;
}

uint64_t sub_100071188(void *a1)
{
  return NANBitmap.Channel.encode(to:)( a1,  *v1 | ((unint64_t)*((unsigned __int16 *)v1 + 1) << 16) | ((unint64_t)v1[4] << 32) | ((unint64_t)*((unsigned __int16 *)v1 + 3) << 48),  v1[8]);
}

uint64_t sub_1000711C4(unsigned __int8 *a1, unsigned __int8 *a2)
{
  char v5 = a2[8];
  if ((a1[8] & 1) != 0)
  {
    if (a2[8]) {
      return 1LL;
    }
  }

  else
  {
    if ((v5 & 1) == 0) {
      return 1LL;
    }
  }

  return 0LL;
}

uint64_t NANBitmap.Time.control.setter(uint64_t result)
{
  _WORD *v1 = result;
  return result;
}

uint64_t NANBitmap.Time.Control.bitDuration.getter(char a1)
{
  return _s7CoreP2P19NANIntervalDurationO8rawValueACSgs5UInt8V_tcfC_0(a1 & 7);
}

uint64_t NANBitmap.Time.Control.period.getter(__int16 a1)
{
  unint64_t v1 = sub_1000713C8(3uLL, 3LL, a1);
  uint64_t result = _s7CoreP2P14IEEE80211FrameV10ManagementO14AuthenticationO0F9AlgorithmO8rawValueAISgs5UInt8V_tcfC_0(v1);
  return result;
}

uint64_t NANBitmap.Time.Control.rawStartOffset.getter(unsigned int a1)
{
  return (a1 >> 6) & 0x1FF;
}

uint64_t sub_100071298@<X0>(uint64_t result@<X0>, uint64_t a2@<X1>, __int16 a3@<W2>, unint64_t a4@<X8>)
{
  if (__OFADD__(result, a2))
  {
    __break(1u);
LABEL_23:
    __break(1u);
LABEL_24:
    if (a4 <= 0xFFFFFFFFFFFFFFC0LL) {
      return 0LL;
    }
    return (unint64_t)(unsigned __int16)(a3 & (result >> -(char)a4)) << -(char)a4;
  }

  if (result + a2 > 16)
  {
    unint64_t v4 = sub_1000033FC();
    uint64_t v5 = swift_allocError(&type metadata for WiFiError, v4, 0LL, 0LL);
    *(void *)uint64_t v6 = 0LL;
    *(void *)(v6 + 8) = 0LL;
    *(_BYTE *)(v6 + 16) = 2;
    return swift_willThrow(v5);
  }

  if (a2 < 0) {
    goto LABEL_23;
  }
  a4 = result;
  if (a2)
  {
    uint64_t result = 0LL;
    unint64_t v7 = 0LL;
    while (1)
    {
      if (v7 <= 0x3F) {
        result |= 1LL << v7;
      }
      if (a2 - 1 == v7) {
        break;
      }
      if (a2 == ++v7)
      {
        __break(1u);
        break;
      }
    }

    if (a4 - 65 < 0xFFFFFFFFFFFFFF7FLL) {
      return 0LL;
    }
    if ((a4 & 0x8000000000000000LL) == 0)
    {
      if (a4 >= 0x40) {
        return 0LL;
      }
      return (unsigned __int16)(a3 & (result << a4)) >> a4;
    }

    goto LABEL_24;
  }

  uint64_t result = 0LL;
  if ((a4 & 0x8000000000000000LL) == 0)
  {
    if (a4 >= 0x40) {
      return result;
    }
    return (unsigned __int16)(a3 & (result << a4)) >> a4;
  }

  if (a4 > 0xFFFFFFFFFFFFFFC0LL) {
    return (unint64_t)(unsigned __int16)(a3 & (result >> -(char)a4)) << -(char)a4;
  }
  return result;
}

unint64_t sub_1000713C8(unint64_t result, uint64_t a2, __int16 a3)
{
  if (__OFADD__(result, a2))
  {
    __break(1u);
    goto LABEL_24;
  }

  if ((uint64_t)(result + a2) > 16)
  {
    unint64_t v4 = sub_1000033FC();
    uint64_t v5 = swift_allocError(&type metadata for WiFiError, v4, 0LL, 0LL);
    *(void *)uint64_t v6 = 0LL;
    *(void *)(v6 + 8) = 0LL;
    *(_BYTE *)(v6 + 16) = 2;
    swift_willThrow(v5);
    return v7;
  }

  if (a2 < 0) {
    goto LABEL_25;
  }
  if (a2)
  {
    uint64_t v3 = 0LL;
    unint64_t v8 = 0LL;
    while (1)
    {
      if (v8 <= 0x3F) {
        v3 |= 1LL << v8;
      }
      if (a2 - 1 == v8) {
        break;
      }
      if (a2 == ++v8)
      {
        __break(1u);
        break;
      }
    }

    if (result - 65 < 0xFFFFFFFFFFFFFF7FLL) {
      return 0LL;
    }
    if ((result & 0x8000000000000000LL) != 0) {
      goto LABEL_26;
    }
    if (result >= 0x40) {
      return 0LL;
    }
LABEL_20:
    unint64_t v7 = (unsigned __int16)(a3 & (v3 << result)) >> result;
    while (v7 > 0xFF)
    {
LABEL_24:
      __break(1u);
LABEL_25:
      __break(1u);
LABEL_26:
      if (result <= 0xFFFFFFFFFFFFFFC0LL) {
        return 0LL;
      }
LABEL_29:
      uint64_t v3 = (unsigned __int16)(a3 & (v3 >> -(char)result));
      unint64_t v7 = v3 << -(char)result;
      if ((v7 & 0x8000000000000000LL) != 0)
      {
        __break(1u);
        return result;
      }
    }

    return v7;
  }

  if (result - 65 < 0xFFFFFFFFFFFFFF7FLL) {
    return 0LL;
  }
  if ((result & 0x8000000000000000LL) != 0)
  {
    uint64_t v3 = 0LL;
    unint64_t v7 = 0LL;
    if (result > 0xFFFFFFFFFFFFFFC0LL) {
      goto LABEL_29;
    }
    return v7;
  }

  unint64_t v7 = 0LL;
  uint64_t v3 = 0LL;
  if (result < 0x40) {
    goto LABEL_20;
  }
  return v7;
}

unint64_t sub_100071514(unint64_t a1, uint64_t a2, __int16 a3)
{
  return sub_100071550(a1, a2, a3);
}

unint64_t sub_100071528(unint64_t a1, uint64_t a2, char a3)
{
  return sub_100071A4C(a1, a2, a3);
}

uint64_t sub_10007153C@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, char a3@<W2>, unint64_t a4@<X8>)
{
  return sub_1000717D8(a1, a2, a3, a4);
}

unint64_t sub_100071550(unint64_t result, uint64_t a2, __int16 a3)
{
  if (__OFADD__(result, a2))
  {
    __break(1u);
    goto LABEL_24;
  }

  if ((uint64_t)(result + a2) > 16)
  {
    unint64_t v4 = sub_1000033FC();
    uint64_t v5 = swift_allocError(&type metadata for WiFiError, v4, 0LL, 0LL);
    *(void *)uint64_t v6 = 0LL;
    *(void *)(v6 + 8) = 0LL;
    *(_BYTE *)(v6 + 16) = 2;
    swift_willThrow(v5);
    return v7;
  }

  if (a2 < 0) {
    goto LABEL_25;
  }
  if (a2)
  {
    uint64_t v3 = 0LL;
    unint64_t v8 = 0LL;
    while (1)
    {
      if (v8 < 0x40) {
        v3 |= 1LL << v8;
      }
      if (a2 - 1 == v8) {
        break;
      }
      if (a2 == ++v8)
      {
        __break(1u);
        break;
      }
    }

    if (result - 65 < 0xFFFFFFFFFFFFFF7FLL) {
      return 0LL;
    }
    if ((result & 0x8000000000000000LL) != 0) {
      goto LABEL_26;
    }
    if (result >= 0x40) {
      return 0LL;
    }
LABEL_20:
    unint64_t v7 = (unsigned __int16)(a3 & (v3 << result)) >> result;
    while (v7 > 0xFF)
    {
LABEL_24:
      __break(1u);
LABEL_25:
      __break(1u);
LABEL_26:
      if (result <= 0xFFFFFFFFFFFFFFC0LL) {
        return 0LL;
      }
LABEL_29:
      uint64_t v3 = (unsigned __int16)(a3 & (v3 >> -(char)result));
      unint64_t v7 = v3 << -(char)result;
      if ((v7 & 0x8000000000000000LL) != 0)
      {
        __break(1u);
        return result;
      }
    }

    return v7;
  }

  if (result - 65 < 0xFFFFFFFFFFFFFF7FLL) {
    return 0LL;
  }
  unint64_t v7 = 0LL;
  uint64_t v3 = 0LL;
  if ((result & 0x8000000000000000LL) != 0)
  {
    if (result > 0xFFFFFFFFFFFFFFC0LL) {
      goto LABEL_29;
    }
    return v7;
  }

  if (result < 0x40) {
    goto LABEL_20;
  }
  return v7;
}

uint64_t sub_100071694@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, __int16 a3@<W2>, unint64_t a4@<X8>)
{
  return sub_1000716A8(a1, a2, a3, a4);
}

uint64_t sub_1000716A8@<X0>(uint64_t result@<X0>, uint64_t a2@<X1>, __int16 a3@<W2>, unint64_t a4@<X8>)
{
  if (__OFADD__(result, a2))
  {
    __break(1u);
LABEL_23:
    __break(1u);
LABEL_24:
    if (a4 <= 0xFFFFFFFFFFFFFFC0LL) {
      return 0LL;
    }
    return (unint64_t)(unsigned __int16)(a3 & (result >> -(char)a4)) << -(char)a4;
  }

  if (result + a2 > 16)
  {
    unint64_t v4 = sub_1000033FC();
    uint64_t v5 = swift_allocError(&type metadata for WiFiError, v4, 0LL, 0LL);
    *(void *)uint64_t v6 = 0LL;
    *(void *)(v6 + 8) = 0LL;
    *(_BYTE *)(v6 + 16) = 2;
    return swift_willThrow(v5);
  }

  if (a2 < 0) {
    goto LABEL_23;
  }
  a4 = result;
  if (a2)
  {
    uint64_t result = 0LL;
    unint64_t v7 = 0LL;
    while (1)
    {
      if (v7 < 0x40) {
        result |= 1LL << v7;
      }
      if (a2 - 1 == v7) {
        break;
      }
      if (a2 == ++v7)
      {
        __break(1u);
        break;
      }
    }

    if (a4 - 65 < 0xFFFFFFFFFFFFFF7FLL) {
      return 0LL;
    }
    if ((a4 & 0x8000000000000000LL) == 0)
    {
      if (a4 >= 0x40) {
        return 0LL;
      }
      return (unsigned __int16)(a3 & (result << a4)) >> a4;
    }

    goto LABEL_24;
  }

  uint64_t result = 0LL;
  if ((a4 & 0x8000000000000000LL) == 0)
  {
    if (a4 >= 0x40) {
      return result;
    }
    return (unsigned __int16)(a3 & (result << a4)) >> a4;
  }

  if (a4 > 0xFFFFFFFFFFFFFFC0LL) {
    return (unint64_t)(unsigned __int16)(a3 & (result >> -(char)a4)) << -(char)a4;
  }
  return result;
}

uint64_t sub_1000717D8@<X0>(uint64_t result@<X0>, uint64_t a2@<X1>, char a3@<W2>, unint64_t a4@<X8>)
{
  if (__OFADD__(result, a2))
  {
    __break(1u);
LABEL_23:
    __break(1u);
LABEL_24:
    if (a4 <= 0xFFFFFFFFFFFFFFC0LL) {
      return 0LL;
    }
    return (unint64_t)(a3 & (result >> -(char)a4)) << -(char)a4;
  }

  if (result + a2 > 8)
  {
    unint64_t v4 = sub_1000033FC();
    uint64_t v5 = swift_allocError(&type metadata for WiFiError, v4, 0LL, 0LL);
    *(void *)uint64_t v6 = 0LL;
    *(void *)(v6 + 8) = 0LL;
    *(_BYTE *)(v6 + 16) = 2;
    return swift_willThrow(v5);
  }

  if (a2 < 0) {
    goto LABEL_23;
  }
  a4 = result;
  if (a2)
  {
    uint64_t result = 0LL;
    unint64_t v7 = 0LL;
    while (1)
    {
      if (v7 < 0x40) {
        result |= 1LL << v7;
      }
      if (a2 - 1 == v7) {
        break;
      }
      if (a2 == ++v7)
      {
        __break(1u);
        break;
      }
    }

    if (a4 - 65 < 0xFFFFFFFFFFFFFF7FLL) {
      return 0LL;
    }
    if ((a4 & 0x8000000000000000LL) == 0)
    {
      if (a4 >= 0x40) {
        return 0LL;
      }
      return (a3 & (result << a4)) >> a4;
    }

    goto LABEL_24;
  }

  uint64_t result = 0LL;
  if ((a4 & 0x8000000000000000LL) == 0)
  {
    if (a4 >= 0x40) {
      return result;
    }
    return (a3 & (result << a4)) >> a4;
  }

  if (a4 > 0xFFFFFFFFFFFFFFC0LL) {
    return (unint64_t)(a3 & (result >> -(char)a4)) << -(char)a4;
  }
  return result;
}

unint64_t sub_100071908(unint64_t result, uint64_t a2, unsigned int a3)
{
  if (__OFADD__(result, a2))
  {
    __break(1u);
    goto LABEL_24;
  }

  if ((uint64_t)(result + a2) > 32)
  {
    unint64_t v4 = sub_1000033FC();
    uint64_t v5 = swift_allocError(&type metadata for WiFiError, v4, 0LL, 0LL);
    *(void *)uint64_t v6 = 0LL;
    *(void *)(v6 + 8) = 0LL;
    *(_BYTE *)(v6 + 16) = 2;
    swift_willThrow(v5);
    return v7;
  }

  if (a2 < 0) {
    goto LABEL_25;
  }
  if (a2)
  {
    uint64_t v3 = 0LL;
    unint64_t v8 = 0LL;
    while (1)
    {
      if (v8 < 0x40) {
        v3 |= 1LL << v8;
      }
      if (a2 - 1 == v8) {
        break;
      }
      if (a2 == ++v8)
      {
        __break(1u);
        break;
      }
    }

    if (result - 65 < 0xFFFFFFFFFFFFFF7FLL) {
      return 0LL;
    }
    if ((result & 0x8000000000000000LL) != 0) {
      goto LABEL_26;
    }
    if (result >= 0x40) {
      return 0LL;
    }
LABEL_20:
    uint64_t v9 = v3 << result;
    uint64_t v3 = a3;
    unint64_t v7 = (v9 & a3) >> result;
    while (v7 > 0xFF)
    {
LABEL_24:
      __break(1u);
LABEL_25:
      __break(1u);
LABEL_26:
      if (result <= 0xFFFFFFFFFFFFFFC0LL) {
        return 0LL;
      }
LABEL_29:
      uint64_t v3 = (v3 >> -(char)result) & a3;
      unint64_t v7 = v3 << -(char)result;
      if ((v7 & 0x8000000000000000LL) != 0)
      {
        __break(1u);
        return result;
      }
    }

    return v7;
  }

  if (result - 65 < 0xFFFFFFFFFFFFFF7FLL) {
    return 0LL;
  }
  unint64_t v7 = 0LL;
  uint64_t v3 = 0LL;
  if ((result & 0x8000000000000000LL) != 0)
  {
    if (result > 0xFFFFFFFFFFFFFFC0LL) {
      goto LABEL_29;
    }
    return v7;
  }

  if (result < 0x40) {
    goto LABEL_20;
  }
  return v7;
}

unint64_t sub_100071A4C(unint64_t result, uint64_t a2, char a3)
{
  if (__OFADD__(result, a2))
  {
    __break(1u);
LABEL_23:
    __break(1u);
LABEL_24:
    if (result <= 0xFFFFFFFFFFFFFFC0LL) {
      return 0LL;
    }
    goto LABEL_27;
  }

  if ((uint64_t)(result + a2) > 8)
  {
    unint64_t v4 = sub_1000033FC();
    uint64_t v5 = swift_allocError(&type metadata for WiFiError, v4, 0LL, 0LL);
    *(void *)uint64_t v6 = 0LL;
    *(void *)(v6 + 8) = 0LL;
    *(_BYTE *)(v6 + 16) = 2;
    swift_willThrow(v5);
    return v7;
  }

  if (a2 < 0) {
    goto LABEL_23;
  }
  if (a2)
  {
    uint64_t v3 = 0LL;
    unint64_t v8 = 0LL;
    while (1)
    {
      if (v8 < 0x40) {
        v3 |= 1LL << v8;
      }
      if (a2 - 1 == v8) {
        break;
      }
      if (a2 == ++v8)
      {
        __break(1u);
        break;
      }
    }

    if (result - 65 < 0xFFFFFFFFFFFFFF7FLL) {
      return 0LL;
    }
    if ((result & 0x8000000000000000LL) == 0)
    {
      if (result >= 0x40) {
        return 0LL;
      }
      return (a3 & (v3 << result)) >> result;
    }

    goto LABEL_24;
  }

  if (result - 65 < 0xFFFFFFFFFFFFFF7FLL) {
    return 0LL;
  }
  unint64_t v7 = 0LL;
  uint64_t v3 = 0LL;
  if ((result & 0x8000000000000000LL) == 0)
  {
    if (result >= 0x40) {
      return v7;
    }
    return (a3 & (v3 << result)) >> result;
  }

  if (result <= 0xFFFFFFFFFFFFFFC0LL) {
    return v7;
  }
LABEL_27:
  unint64_t v7 = (unint64_t)(a3 & (v3 >> -(char)result)) << -(char)result;
  if ((v7 & 0x8000000000000000LL) != 0) {
    __break(1u);
  }
  if (v7 <= 0xFF) {
    return v7;
  }
  __break(1u);
  return result;
}

unint64_t NANBitmap.Time.Control.startOffset.getter(unsigned int a1)
{
  unint64_t v1 = (a1 >> 6) & 0x1FF;
  unint64_t result = NANIntervalDuration.timeUnits.getter(0);
  if (is_mul_ok(v1, result)) {
    result *= v1;
  }
  else {
    __break(1u);
  }
  return result;
}

CoreP2P::NANBitmap::Time::Control __swiftcall NANBitmap.Time.Control.init(bitDuration:period:startOffset:)( CoreP2P::NANIntervalDuration bitDuration, CoreP2P::NANTimeUnit::SchedulePeriod period, CoreP2P::NANTimeUnit startOffset)
{
  unint64_t v7 = NANIntervalDuration.timeUnits.getter(0);
  if (!v7)
  {
    __break(1u);
    goto LABEL_12;
  }

  if ((startOffset.rawValue & 0xF) != 0)
  {
LABEL_12:
    __break(1u);
    goto LABEL_13;
  }

  Swift::UInt64 v8 = startOffset.rawValue / v7;
  if (v8 > 0x1FF)
  {
LABEL_13:
    __break(1u);
    swift_unexpectedError(v3, "CoreP2P/NANAvailability.swift", 29LL, 1LL);
    __break(1u);
    swift_unexpectedError(v3, "CoreP2P/NANAvailability.swift", 29LL, 1LL);
    __break(1u);
    result.rawValue = swift_unexpectedError(v3, "CoreP2P/NANAvailability.swift", 29LL, 1LL);
    __break(1u);
    return result;
  }

  __int16 v9 = sub_1001A05D8(bitDuration, 0LL, 3LL);
  unsigned __int16 v10 = sub_1001A05D8(period, 3uLL, 3LL);
  unsigned __int16 v11 = sub_1001A05EC(v8, 6uLL, 9LL);
  else {
    unsigned __int16 v12 = 0;
  }
  __int16 v13 = v12 | v9;
  else {
    unsigned __int16 v14 = 0;
  }
  return (CoreP2P::NANBitmap::Time::Control)(v14 | v13);
}

CoreP2P::NANBitmap::Time::Control __swiftcall NANBitmap.Time.Control.offset(by:)(CoreP2P::NANTimeUnit by)
{
  unsigned int v2 = v1;
  unsigned __int8 v4 = _s7CoreP2P19NANIntervalDurationO8rawValueACSgs5UInt8V_tcfC_0(v1 & 7);
  if (v4 == 4) {
    unsigned __int8 v5 = 0;
  }
  else {
    unsigned __int8 v5 = v4;
  }
  unint64_t v6 = sub_1000713C8(3uLL, 3LL, v2);
  unsigned __int8 v7 = _s7CoreP2P14IEEE80211FrameV10ManagementO14AuthenticationO0F9AlgorithmO8rawValueAISgs5UInt8V_tcfC_0(v6);
  if (v7 == 8) {
    unsigned __int8 v7 = 0;
  }
  unint64_t v8 = (v2 >> 6) & 0x1FF;
  unint64_t v9 = NANIntervalDuration.timeUnits.getter(0);
  if (!is_mul_ok(v8, v9))
  {
    __break(1u);
    goto LABEL_19;
  }

  BOOL v10 = __CFADD__(v8 * v9, by.rawValue);
  Swift::UInt64 v11 = v8 * v9 + by.rawValue;
  if (v10)
  {
LABEL_19:
    __break(1u);
    goto LABEL_20;
  }

  unint64_t v12 = NANIntervalDuration.timeUnits.getter(0);
  if (!v12)
  {
LABEL_20:
    __break(1u);
    goto LABEL_21;
  }

  if ((v11 & 0xF) != 0)
  {
LABEL_21:
    __break(1u);
    goto LABEL_22;
  }

  unint64_t v13 = v11 / v12;
  if (v13 > 0x1FF)
  {
LABEL_22:
    __break(1u);
    swift_unexpectedError(0LL, "CoreP2P/NANAvailability.swift", 29LL, 1LL);
    __break(1u);
    swift_unexpectedError(0LL, "CoreP2P/NANAvailability.swift", 29LL, 1LL);
    __break(1u);
    result.rawValue = swift_unexpectedError(0LL, "CoreP2P/NANAvailability.swift", 29LL, 1LL);
    __break(1u);
    return result;
  }

  __int16 v14 = sub_1001A05D8(v5, 0LL, 3LL);
  unsigned __int16 v15 = sub_1001A05D8(v7, 3uLL, 3LL);
  unsigned __int16 v16 = sub_1001A05EC(v13, 6uLL, 9LL);
  else {
    unsigned __int16 v17 = 0;
  }
  __int16 v18 = v17 | v14;
  else {
    unsigned __int16 v19 = 0;
  }
  return (CoreP2P::NANBitmap::Time::Control)(v19 | v18);
}

unint64_t sub_100071E98(uint64_t a1)
{
  return sub_100071F14(a1, 4u, &static NANBitmap.Time.Control.availability);
}

_WORD *NANBitmap.Time.Control.availability.unsafeMutableAddressor()
{
  if (qword_100404118 != -1) {
    swift_once(&qword_100404118, sub_100071E98);
  }
  return &static NANBitmap.Time.Control.availability;
}

uint64_t static NANBitmap.Time.Control.availability.getter()
{
  return sub_10007207C(&qword_100404118, &static NANBitmap.Time.Control.availability);
}

unint64_t sub_100071F04(uint64_t a1)
{
  return sub_100071F14(a1, 3u, &static NANBitmap.Time.Control.perDiscoveryWindow);
}

unint64_t sub_100071F14(uint64_t a1, unsigned __int8 a2, _WORD *a3)
{
  if (NANIntervalDuration.timeUnits.getter(0))
  {
    __int16 v6 = sub_1001A05D8(0, 0LL, 3LL);
    unsigned __int16 v7 = sub_1001A05D8(a2, 3uLL, 3LL);
    unint64_t result = sub_1001A05EC(0LL, 6uLL, 9LL);
    else {
      unsigned __int16 v9 = 0;
    }
    __int16 v10 = v9 | v6;
    else {
      __int16 v11 = 0;
    }
    *a3 = v11 | v10;
  }

  else
  {
    __break(1u);
    swift_unexpectedError(v3, "CoreP2P/NANAvailability.swift", 29LL, 1LL);
    __break(1u);
    swift_unexpectedError(v3, "CoreP2P/NANAvailability.swift", 29LL, 1LL);
    __break(1u);
    unint64_t result = swift_unexpectedError(v3, "CoreP2P/NANAvailability.swift", 29LL, 1LL);
    __break(1u);
  }

  return result;
}

__int16 *NANBitmap.Time.Control.perDiscoveryWindow.unsafeMutableAddressor()
{
  if (qword_100404120 != -1) {
    swift_once(&qword_100404120, sub_100071F04);
  }
  return &static NANBitmap.Time.Control.perDiscoveryWindow;
}

uint64_t static NANBitmap.Time.Control.perDiscoveryWindow.getter()
{
  return sub_10007207C(&qword_100404120, (unsigned __int16 *)&static NANBitmap.Time.Control.perDiscoveryWindow);
}

uint64_t sub_10007207C(void *a1, unsigned __int16 *a2)
{
  if (*a1 != -1LL) {
    swift_once();
  }
  return *a2;
}

uint64_t sub_1000720BC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v6 = sub_1000870E8();
  return RawRepresentable<>.init(from:)(a1, a2, a3, v6);
}

uint64_t sub_100072118(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v6 = sub_1000870E8();
  return RawRepresentable<>.encode(to:)(a1, a2, a3, v6);
}

void sub_100072164(_WORD *a1@<X8>)
{
  *a1 = 0;
}

uint64_t sub_10007216C@<X0>(uint64_t a1@<X0>, _WORD *a2@<X8>)
{
  __int16 v4 = sub_10019AD20();
  uint64_t result = swift_bridgeObjectRelease(a1);
  *a2 = v4;
  return result;
}

uint64_t NANBitmap.Time.bitmapData.getter(uint64_t a1, uint64_t a2, unint64_t a3)
{
  return a2;
}

uint64_t NANBitmap.Time.init(from:)(void *a1)
{
  return sub_100085710(a1);
}

uint64_t NANBitmap.Time.encode(to:)(void *a1, __int16 a2, uint64_t a3, unint64_t a4)
{
  uint64_t v8 = a1[3];
  uint64_t v9 = a1[4];
  sub_100021104(a1, v8);
  dispatch thunk of Encoder.unkeyedContainer()(v23, v8, v9);
  LOWORD(v22[0]) = a2;
  uint64_t v10 = v24;
  uint64_t v11 = v25;
  sub_1000237C8((uint64_t)v23, v24);
  unint64_t v12 = sub_100085868();
  dispatch thunk of UnkeyedEncodingContainer.encode<A>(_:)( v22,  &type metadata for NANBitmap.Time.Control,  v12,  v10,  v11);
  if (!v4)
  {
    sub_100020AFC(a3, a4);
    sub_100072350(a3, a4);
    uint64_t v15 = v13;
    unint64_t v16 = v14;
    v22[0] = v13;
    v22[1] = v14;
    uint64_t v17 = v24;
    uint64_t v18 = v25;
    sub_1000237C8((uint64_t)v23, v24);
    uint64_t v19 = sub_100002274(&qword_1004063B0);
    uint64_t v20 = sub_1000572E4( &qword_1004064F0,  &qword_1004063B0,  (uint64_t)&protocol conformance descriptor for LengthValue<A>);
    dispatch thunk of UnkeyedEncodingContainer.encode<A>(_:)(v22, v19, v20, v17, v18);
    sub_1000208D8(v15, v16);
  }

  return sub_100002AC4(v23);
}

void sub_100072350(uint64_t a1, uint64_t a2)
{
  __asm { BR              X10 }

uint64_t sub_100072388()
{
  if (BYTE6(v0) == 255LL)
  {
    unint64_t v2 = sub_1000033FC();
    uint64_t v3 = swift_allocError(&type metadata for WiFiError, v2, 0LL, 0LL);
    *(void *)uint64_t v4 = 0LL;
    *(void *)(v4 + 8) = 0LL;
    *(_BYTE *)(v4 + 16) = 2;
    swift_willThrow(v3);
    sub_1000208D8(v1, v0);
  }

  return v1;
}

void sub_10007242C(uint64_t a1, uint64_t a2)
{
  __asm { BR              X10 }

uint64_t NANBitmap.Time.description.getter(unsigned __int16 a1, uint64_t a2, unint64_t a3)
{
  uint64_t v6 = type metadata accessor for Data.Iterator(0LL);
  __chkstk_darwin(v6);
  uint64_t v29 = (char *)&v25 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  sub_100020AFC(a2, a3);
  unint64_t v8 = sub_100083634(a1, a2, a3);
  unint64_t v10 = v8;
  uint64_t v12 = v11;
  v31[0] = 0LL;
  v31[1] = 0xE000000000000000LL;
  if (v8 == v11) {
    return 0LL;
  }
  char v14 = v9;
  unint64_t v15 = v8 >> 7;
  uint64_t v29 = (char *)HIBYTE(v9);
  unint64_t v27 = v9 >> 40;
  *(void *)&__int128 v28 = HIWORD(v9);
  unint64_t v26 = HIDWORD(v9);
  __int128 v25 = xmmword_100339900;
  unint64_t v16 = v9 >> 24;
  unint64_t v17 = v9 >> 16;
  unint64_t v18 = v9 >> 8;
  do
  {
    v30[0] = v14;
    v30[1] = v18;
    v30[2] = v17;
    v30[3] = v16;
    v30[4] = v26;
    v30[5] = v27;
    v30[6] = v28;
    v30[7] = (_BYTE)v29;
    unint64_t v19 = v10 + 128;
    if (v10 >= 0xFFFFFFFFFFFFFF80LL)
    {
      __break(1u);
      __break(1u);
      __break(1u);
      JUMPOUT(0x100072974LL);
    }

    char v20 = v30[v15];
    uint64_t v21 = sub_100002274((uint64_t *)&unk_100405140);
    uint64_t v22 = swift_allocObject(v21, 72LL, 7LL);
    *(_OWORD *)(v22 + 16) = v25;
    *(void *)(v22 + 56) = &type metadata for UInt8;
    *(void *)(v22 + 64) = &protocol witness table for UInt8;
    *(_BYTE *)(v22 + 32) = v20;
    v23._countAndFlagsBits = String.init(format:_:)(1479684133LL, 0xE400000000000000LL, v22);
    object = v23._object;
    String.append(_:)(v23);
    swift_bridgeObjectRelease(object);
    v10 += 128LL;
    ++v15;
  }

  while (v19 != v12);
  return v31[0];
}

uint64_t TimeBitmap.init(bitmap:)(unint64_t a1, uint64_t a2, unint64_t a3)
{
  uint64_t result = sub_100083634(a1, a2, a3);
  if (v3) {
    return v5;
  }
  return result;
}

uint64_t NANBitmap.Time.hash(into:)(uint64_t a1, Swift::UInt16 a2, uint64_t a3, unint64_t a4)
{
  return sub_1000208D8(a3, a4);
}

void static NANBitmap.Time.__derived_struct_equals(_:_:)(__int16 a1, uint64_t a2, uint64_t a3, __int16 a4)
{
  if (a1 == a4) {
    _s7CoreP2P6NANPMKV23__derived_struct_equalsySbAC_ACtFZ_0(a2, a3);
  }
}

Swift::Int NANBitmap.Time.hashValue.getter(Swift::UInt16 a1, uint64_t a2, unint64_t a3)
{
  return Hasher._finalize()();
}

Swift::Int sub_100072AA4()
{
  uint64_t v1 = *(void *)(v0 + 8);
  unint64_t v2 = *(void *)(v0 + 16);
  Swift::UInt16 v3 = *(_WORD *)v0;
  Hasher.init(_seed:)(v5, 0LL);
  Hasher._combine(_:)(v3);
  sub_100020AFC(v1, v2);
  Data.hash(into:)(v5, v1, v2);
  sub_1000208D8(v1, v2);
  return Hasher._finalize()();
}

uint64_t sub_100072B1C(uint64_t a1)
{
  uint64_t v3 = *(void *)(v1 + 8);
  unint64_t v4 = *(void *)(v1 + 16);
  Hasher._combine(_:)(*(_WORD *)v1);
  sub_100020AFC(v3, v4);
  Data.hash(into:)(a1, v3, v4);
  return sub_1000208D8(v3, v4);
}

Swift::Int sub_100072B74(uint64_t a1)
{
  uint64_t v2 = *(void *)(v1 + 8);
  unint64_t v3 = *(void *)(v1 + 16);
  Swift::UInt16 v4 = *(_WORD *)v1;
  Hasher.init(_seed:)(v6, a1);
  Hasher._combine(_:)(v4);
  sub_100020AFC(v2, v3);
  Data.hash(into:)(v6, v2, v3);
  sub_1000208D8(v2, v3);
  return Hasher._finalize()();
}

uint64_t sub_100072BE8@<X0>(void *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t result = sub_100085710(a1);
  if (!v2)
  {
    *(_WORD *)a2 = result;
    *(void *)(a2 + 8) = v5;
    *(void *)(a2 + 16) = v6;
  }

  return result;
}

uint64_t sub_100072C14(void *a1)
{
  return NANBitmap.Time.encode(to:)(a1, *(_WORD *)v1, *(void *)(v1 + 8), *(void *)(v1 + 16));
}

uint64_t sub_100072C30()
{
  return NANBitmap.Time.description.getter(*(_WORD *)v0, *(void *)(v0 + 8), *(void *)(v0 + 16));
}

void sub_100072C3C(unsigned __int16 *a1, unsigned __int16 *a2)
{
  if (*a1 == *a2) {
    _s7CoreP2P6NANPMKV23__derived_struct_equalsySbAC_ACtFZ_0(*((void *)a1 + 1), *((void *)a1 + 2));
  }
}

void *TimeBitmap.bitDuration.unsafeMutableAddressor()
{
  return &static TimeBitmap.bitDuration;
}

uint64_t TimeBitmap.slotsView.setter(uint64_t result, uint64_t a2, uint64_t a3)
{
  *unint64_t v3 = result;
  v3[1] = a2;
  v3[2] = a3;
  return result;
}

uint64_t TimeBitmap.init()()
{
  return 0LL;
}

void *TimeBitmap.zero.unsafeMutableAddressor()
{
  return &static TimeBitmap.zero;
}

void *TimeBitmap.Slot.FF.unsafeMutableAddressor()
{
  return &static TimeBitmap.Slot.FF;
}

void *TimeBitmap.all.unsafeMutableAddressor()
{
  return &static TimeBitmap.all;
}

uint64_t static TimeBitmap.all.getter()
{
  return 0LL;
}

uint64_t _s7CoreP2P10TimeBitmapVyA2C4SlotV_A7EtcfC_0()
{
  return 0LL;
}

uint64_t TimeBitmap.formUnion(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_100072F1C(a1, a2, a3, TimeBitmap.SlotsView.formUnion(_:));
}

int8x8_t TimeBitmap.SlotsView.formUnion(_:)(uint64_t a1, uint64_t a2, unint64_t a3)
{
  uint64x2_t v4 = (uint64x2_t)vdupq_n_s64(a3);
  v5.i32[0] = a3;
  v5.i32[1] = a3 >> 8;
  int8x8_t result = vorr_s8( v3[2],  vmovn_s16( vuzp1q_s16( (int16x8_t)vmovn_hight_s64(v5, (int64x2_t)vshlq_u64(v4, (uint64x2_t)xmmword_10033E7F0)),  (int16x8_t)vuzp1q_s32( (int32x4_t)vshlq_u64(v4, (uint64x2_t)xmmword_10033E800),  (int32x4_t)vshlq_u64(v4, (uint64x2_t)xmmword_10033E810)))));
  v3[2] = result;
  return result;
}

uint64_t TimeBitmap.formIntersection(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_100072F1C(a1, a2, a3, TimeBitmap.SlotsView.formIntersection(_:));
}

int8x8_t TimeBitmap.SlotsView.formIntersection(_:)(uint64_t a1, uint64_t a2, unint64_t a3)
{
  uint64x2_t v4 = (uint64x2_t)vdupq_n_s64(a3);
  v5.i32[0] = a3;
  v5.i32[1] = a3 >> 8;
  int8x8_t result = vand_s8( v3[2],  vmovn_s16( vuzp1q_s16( (int16x8_t)vmovn_hight_s64(v5, (int64x2_t)vshlq_u64(v4, (uint64x2_t)xmmword_10033E7F0)),  (int16x8_t)vuzp1q_s32( (int32x4_t)vshlq_u64(v4, (uint64x2_t)xmmword_10033E800),  (int32x4_t)vshlq_u64(v4, (uint64x2_t)xmmword_10033E810)))));
  v3[2] = result;
  return result;
}

uint64_t TimeBitmap.formSymmetricDifference(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_100072F1C(a1, a2, a3, TimeBitmap.SlotsView.formSymmetricDifference(_:));
}

int8x8_t TimeBitmap.SlotsView.formSymmetricDifference(_:)(uint64_t a1, uint64_t a2, unint64_t a3)
{
  uint64x2_t v4 = (uint64x2_t)vdupq_n_s64(a3);
  v5.i32[0] = a3;
  v5.i32[1] = a3 >> 8;
  int8x8_t result = veor_s8( v3[2],  vmovn_s16( vuzp1q_s16( (int16x8_t)vmovn_hight_s64(v5, (int64x2_t)vshlq_u64(v4, (uint64x2_t)xmmword_10033E7F0)),  (int16x8_t)vuzp1q_s32( (int32x4_t)vshlq_u64(v4, (uint64x2_t)xmmword_10033E800),  (int32x4_t)vshlq_u64(v4, (uint64x2_t)xmmword_10033E810)))));
  v3[2] = result;
  return result;
}

uint64_t TimeBitmap.subtract(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_100072F1C(a1, a2, a3, TimeBitmap.SlotsView.subtract(_:));
}

int8x8_t TimeBitmap.SlotsView.subtract(_:)(uint64_t a1, uint64_t a2, unint64_t a3)
{
  uint64x2_t v4 = (uint64x2_t)vdupq_n_s64(a3);
  v5.i32[0] = a3;
  v5.i32[1] = a3 >> 8;
  int8x8_t result = vbic_s8( v3[2],  vmovn_s16( vuzp1q_s16( (int16x8_t)vmovn_hight_s64(v5, (int64x2_t)vshlq_u64(v4, (uint64x2_t)xmmword_10033E7F0)),  (int16x8_t)vuzp1q_s32( (int32x4_t)vshlq_u64(v4, (uint64x2_t)xmmword_10033E800),  (int32x4_t)vshlq_u64(v4, (uint64x2_t)xmmword_10033E810)))));
  v3[2] = result;
  return result;
}

Swift::Void __swiftcall TimeBitmap.SlotsView.invert()()
{
  unint64_t v1 = *v0;
  unint64_t v2 = v0[1];
  if (*v0 != v2)
  {
    unint64_t v3 = v0 + 2;
    for (unint64_t i = v1 >> 7; ; ++i)
    {
      unint64_t v5 = v1 + 128;
      if (v1 >= 0xFFFFFFFFFFFFFF80LL) {
        break;
      }
      uint64_t v6 = *v3;
      *((_BYTE *)v3 + i) = ~*((_BYTE *)&v6 + i);
      v1 += 128LL;
      if (v5 == v2) {
        return;
      }
    }

    __break(1u);
  }

uint64_t TimeBitmap.union(_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return a4;
}

uint64_t TimeBitmap.intersection(_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return a4;
}

uint64_t TimeBitmap.symmetricDifference(_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return a4;
}

uint64_t TimeBitmap.subtracting(_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return a4;
}

unint64_t TimeBitmap.inverted()(unint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v7 = a3;
  if (result != a2)
  {
    unint64_t v3 = result >> 7;
    for (unint64_t i = result; ; i += 128LL)
    {
      unint64_t v5 = i + 128;
      if (i >= 0xFFFFFFFFFFFFFF80LL) {
        break;
      }
      uint64_t v6 = v7;
      *((_BYTE *)&v7 + v3) = ~*((_BYTE *)&v6 + v3);
      ++v3;
      if (v5 == a2) {
        return result;
      }
    }

    __break(1u);
  }

  return result;
}

unint64_t TimeBitmap.subscript.getter(unint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7 = a4;
  unint64_t result = NANIntervalDuration.timeUnits.getter(0);
  if (!result)
  {
    __break(1u);
    goto LABEL_7;
  }

  if (((a1 / result) & 0x8000000000000000LL) != 0)
  {
LABEL_7:
    __break(1u);
    goto LABEL_8;
  }

  unsigned int v6 = *((unsigned __int8 *)&v7 + ((a1 / result) >> 3));
  unint64_t result = NANIntervalDuration.timeUnits.getter(0);
  if (!result)
  {
LABEL_8:
    __break(1u);
    goto LABEL_9;
  }

  if (((a1 / result) & 0x8000000000000000LL) == 0) {
    return (v6 >> ((a1 / result) & 7)) & 1;
  }
LABEL_9:
  __break(1u);
  return result;
}

unint64_t TimeBitmap.SlotsView.subscript.getter( unint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6 = a4;
  unint64_t result = NANIntervalDuration.timeUnits.getter(0);
  if (result)
  {
    if (((a1 / result) & 0x8000000000000000LL) == 0) {
      return *((unsigned __int8 *)&v6 + ((a1 / result) >> 3));
    }
  }

  else
  {
    __break(1u);
  }

  __break(1u);
  return result;
}

unint64_t TimeBitmap.subscript.setter(uint64_t a1, unint64_t a2)
{
  return sub_100086770(a2);
}

uint64_t TimeBitmap.SlotsView.subscript.setter(uint64_t result, unint64_t a2)
{
  *(_BYTE *)(v2 + (a2 >> 7) + 16) = result;
  return result;
}

unint64_t (*TimeBitmap.subscript.modify( uint64_t a1, unint64_t a2, uint64_t a3))(unint64_t *a1)
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v3;
  *(_BYTE *)(a1 + 16) = TimeBitmap.subscript.getter(a2, a2, a3, *(void *)(v3 + 16)) & 1;
  return sub_1000731C4;
}

unint64_t sub_1000731C4(unint64_t *a1)
{
  return sub_100086770(*a1);
}

CoreP2P::NANTimeUnit __swiftcall TimeBitmap.index(after:)(CoreP2P::NANTimeUnit after)
{
  BOOL v1 = __CFADD__(after.rawValue, 16LL);
  result.rawValue = after.rawValue + 16;
  if (v1) {
    __break(1u);
  }
  return result;
}

CoreP2P::NANTimeUnit __swiftcall TimeBitmap.index(before:)(CoreP2P::NANTimeUnit before)
{
  BOOL v1 = before.rawValue >= 0x10;
  result.rawValue = before.rawValue - 16;
  if (!v1) {
    __break(1u);
  }
  return result;
}

CoreP2P::NANTimeUnit __swiftcall TimeBitmap.index(_:offsetBy:)(CoreP2P::NANTimeUnit _, Swift::Int offsetBy)
{
  if (offsetBy < 0) {
    goto LABEL_7;
  }
  if ((unint64_t)offsetBy >> 60)
  {
    __break(1u);
    goto LABEL_6;
  }

  BOOL v2 = __CFADD__(_.rawValue, 16 * offsetBy);
  result.rawValue = _.rawValue + 16 * offsetBy;
  if (v2)
  {
LABEL_6:
    __break(1u);
LABEL_7:
    result.rawValue = _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  "Negative value is not representable",  35LL,  2LL,  "Swift/Integers.swift",  20LL,  2,  3451LL,  0);
    __break(1u);
  }

  return result;
}

Swift::Int __swiftcall TimeBitmap.distance(from:to:)(Swift::Int from, CoreP2P::NANTimeUnit to)
{
  if (to.rawValue >= from) {
    return (to.rawValue - from) >> 4;
  }
  __break(1u);
  return from;
}

uint64_t NANDataManagementFrameTransferCompleteEvent.status.getter(uint64_t a1, uint64_t a2)
{
  return a2;
}

unint64_t TimeBitmap.description.getter(unint64_t result, uint64_t a2, unint64_t a3)
{
  uint64_t v21 = 0LL;
  unint64_t v22 = 0xE000000000000000LL;
  if (result == a2) {
    return 0LL;
  }
  char v3 = a3;
  unint64_t v4 = result;
  unint64_t v5 = result >> 7;
  unint64_t v17 = HIWORD(a3);
  unint64_t v18 = HIBYTE(a3);
  unint64_t v16 = a3 >> 40;
  unint64_t v6 = HIDWORD(a3);
  unint64_t v7 = a3 >> 24;
  unint64_t v8 = a3 >> 16;
  unint64_t v9 = a3 >> 8;
  while (1)
  {
    v20[0] = v3;
    v20[1] = v9;
    v20[2] = v8;
    v20[3] = v7;
    v20[4] = v6;
    v20[5] = v16;
    v20[6] = v17;
    v20[7] = v18;
    unint64_t v10 = v4 + 128;
    if (v4 >= 0xFFFFFFFFFFFFFF80LL) {
      break;
    }
    char v11 = v20[v5];
    uint64_t v12 = sub_100002274((uint64_t *)&unk_100405140);
    uint64_t v13 = swift_allocObject(v12, 72LL, 7LL);
    *(_OWORD *)(v13 + 16) = xmmword_100339900;
    *(void *)(v13 + 56) = &type metadata for UInt8;
    *(void *)(v13 + 64) = &protocol witness table for UInt8;
    *(_BYTE *)(v13 + 32) = v11;
    v14._countAndFlagsBits = String.init(format:_:)(1479684133LL, 0xE400000000000000LL, v13);
    object = v14._object;
    String.append(_:)(v14);
    CoreP2P::NANTimeUnit result = swift_bridgeObjectRelease(object);
    v4 += 128LL;
    ++v5;
    if (v10 == a2) {
      return v21;
    }
  }

  __break(1u);
  return result;
}

void *TimeBitmap.Slot.OO.unsafeMutableAddressor()
{
  return &static TimeBitmap.Slot.OO;
}

void *TimeBitmap.Slot.FO.unsafeMutableAddressor()
{
  return &static TimeBitmap.Slot.FO;
}

uint64_t static TimeBitmap.Slot.FO.getter()
{
  return 240LL;
}

void *TimeBitmap.Slot.OF.unsafeMutableAddressor()
{
  return &static TimeBitmap.Slot.OF;
}

uint64_t static NANDiscoveryWindowIndex.last.getter()
{
  return 15LL;
}

Swift::Void __swiftcall TimeBitmap.Slot.setBit(_:)(Swift::UInt8 a1)
{
  if (a1 > 7u) {
    __break(1u);
  }
  else {
    *v1 |= 1 << a1;
  }
}

Swift::Void __swiftcall TimeBitmap.Slot.clearBit(_:)(Swift::UInt8 a1)
{
  if (a1 > 7u) {
    __break(1u);
  }
  else {
    *v1 &= (-1 << a1) - 1;
  }
}

void InfraScanCompleteEvent.hash(into:)(int a1, Swift::UInt8 a2)
{
}

Swift::Int InfraScanCompleteEvent.hashValue.getter(Swift::UInt8 a1)
{
  return Hasher._finalize()();
}

unint64_t TimeBitmap.SlotsView.subscript.modify(uint64_t a1, unint64_t a2)
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v2;
  uint64_t v6 = *(void *)(v2 + 16);
  unint64_t result = NANIntervalDuration.timeUnits.getter(0);
  if (result)
  {
    if (((a2 / result) & 0x8000000000000000LL) == 0)
    {
      *(_BYTE *)(a1 + 16) = *((_BYTE *)&v6 + ((a2 / result) >> 3));
      return (unint64_t)sub_100073550;
    }
  }

  else
  {
    __break(1u);
  }

  __break(1u);
  return result;
}

uint64_t sub_100073550(uint64_t result)
{
  *(_BYTE *)(*(void *)(result + 8) + (*(void *)result >> 7) + 16LL) = *(_BYTE *)(result + 16);
  return result;
}

CoreP2P::NANTimeUnit __swiftcall TimeBitmap.SlotsView.index(after:)(CoreP2P::NANTimeUnit after)
{
  BOOL v1 = __CFADD__(after.rawValue, 128LL);
  result.rawValue = after.rawValue + 128;
  if (v1) {
    __break(1u);
  }
  return result;
}

CoreP2P::NANTimeUnit __swiftcall TimeBitmap.SlotsView.index(_:offsetBy:)(CoreP2P::NANTimeUnit _, Swift::Int offsetBy)
{
  if (offsetBy < 0) {
    goto LABEL_7;
  }
  if ((unint64_t)offsetBy >> 57)
  {
    __break(1u);
    goto LABEL_6;
  }

  BOOL v2 = __CFADD__(_.rawValue, offsetBy << 7);
  result.rawValue = _.rawValue + (offsetBy << 7);
  if (v2)
  {
LABEL_6:
    __break(1u);
LABEL_7:
    result.rawValue = _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  "Negative value is not representable",  35LL,  2LL,  "Swift/Integers.swift",  20LL,  2,  3451LL,  0);
    __break(1u);
  }

  return result;
}

CoreP2P::NANTimeUnit __swiftcall TimeBitmap.SlotsView.index(before:)(CoreP2P::NANTimeUnit before)
{
  BOOL v1 = before.rawValue >= 0x80;
  result.rawValue = before.rawValue - 128;
  if (!v1) {
    __break(1u);
  }
  return result;
}

Swift::Int __swiftcall TimeBitmap.SlotsView.distance(from:to:)(Swift::Int from, CoreP2P::NANTimeUnit to)
{
  if (to.rawValue >= from) {
    return (to.rawValue - from) >> 7;
  }
  __break(1u);
  return from;
}

BOOL static TimeBitmap.SlotsView.== infix(_:_:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  return a3 == a6;
}

void TimeBitmap.SlotsView.hash(into:)(int a1, int a2, int a3, unint64_t a4)
{
  unint64_t v4 = a4 >> 8;
  unint64_t v5 = a4 >> 16;
  unint64_t v6 = a4 >> 24;
  unint64_t v7 = HIDWORD(a4);
  unint64_t v8 = a4 >> 40;
  unint64_t v9 = HIWORD(a4);
  unint64_t v10 = HIBYTE(a4);
  Hasher._combine(_:)(a4);
  Hasher._combine(_:)(v4);
  Hasher._combine(_:)(v5);
  Hasher._combine(_:)(v6);
  Hasher._combine(_:)(v7);
  Hasher._combine(_:)(v8);
  Hasher._combine(_:)(v9);
  Hasher._combine(_:)(v10);
}

BOOL TimeBitmap.SlotsView.isEmpty.getter(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return a3 == 0;
}

Swift::Int TimeBitmap.hashValue.getter(uint64_t a1, uint64_t a2, unint64_t a3)
{
  Swift::UInt8 v3 = a3;
  unint64_t v4 = a3 >> 8;
  unint64_t v5 = a3 >> 16;
  unint64_t v6 = a3 >> 24;
  unint64_t v7 = HIDWORD(a3);
  unint64_t v8 = a3 >> 40;
  unint64_t v9 = HIWORD(a3);
  unint64_t v10 = HIBYTE(a3);
  Hasher.init(_seed:)(v12, 0LL);
  Hasher._combine(_:)(v3);
  Hasher._combine(_:)(v4);
  Hasher._combine(_:)(v5);
  Hasher._combine(_:)(v6);
  Hasher._combine(_:)(v7);
  Hasher._combine(_:)(v8);
  Hasher._combine(_:)(v9);
  Hasher._combine(_:)(v10);
  return Hasher._finalize()();
}

uint64_t sub_10007380C@<X0>(void *a1@<X0>, uint64_t a2@<X1>, void *a3@<X2>, uint64_t a4@<X8>)
{
  return sub_100073E60(a1, a2, a3, sub_10008681C, a4);
}

Swift::Int sub_10007381C()
{
  Swift::UInt8 v1 = v0[16];
  Swift::UInt8 v2 = v0[17];
  Swift::UInt8 v3 = v0[18];
  Swift::UInt8 v4 = v0[19];
  Swift::UInt8 v5 = v0[20];
  Swift::UInt8 v6 = v0[21];
  Swift::UInt8 v7 = v0[22];
  Swift::UInt8 v8 = v0[23];
  Hasher.init(_seed:)(v10, 0LL);
  Hasher._combine(_:)(v1);
  Hasher._combine(_:)(v2);
  Hasher._combine(_:)(v3);
  Hasher._combine(_:)(v4);
  Hasher._combine(_:)(v5);
  Hasher._combine(_:)(v6);
  Hasher._combine(_:)(v7);
  Hasher._combine(_:)(v8);
  return Hasher._finalize()();
}

void sub_1000738F0()
{
  Swift::UInt8 v1 = v0[17];
  Swift::UInt8 v2 = v0[18];
  Swift::UInt8 v3 = v0[19];
  Swift::UInt8 v4 = v0[20];
  Swift::UInt8 v5 = v0[21];
  Swift::UInt8 v6 = v0[22];
  Swift::UInt8 v7 = v0[23];
  Hasher._combine(_:)(v0[16]);
  Hasher._combine(_:)(v1);
  Hasher._combine(_:)(v2);
  Hasher._combine(_:)(v3);
  Hasher._combine(_:)(v4);
  Hasher._combine(_:)(v5);
  Hasher._combine(_:)(v6);
  Hasher._combine(_:)(v7);
}

Swift::Int sub_10007398C(uint64_t a1)
{
  Swift::UInt8 v2 = v1[16];
  Swift::UInt8 v3 = v1[17];
  Swift::UInt8 v4 = v1[18];
  Swift::UInt8 v5 = v1[19];
  Swift::UInt8 v6 = v1[20];
  Swift::UInt8 v7 = v1[21];
  Swift::UInt8 v8 = v1[22];
  Swift::UInt8 v9 = v1[23];
  Hasher.init(_seed:)(v11, a1);
  Hasher._combine(_:)(v2);
  Hasher._combine(_:)(v3);
  Hasher._combine(_:)(v4);
  Hasher._combine(_:)(v5);
  Hasher._combine(_:)(v6);
  Hasher._combine(_:)(v7);
  Hasher._combine(_:)(v8);
  Hasher._combine(_:)(v9);
  return Hasher._finalize()();
}

void *sub_100073A5C@<X0>(void *result@<X0>, void *a2@<X8>)
{
  if (*result < 0x80uLL) {
    __break(1u);
  }
  else {
    *a2 = *result - 128LL;
  }
  return result;
}

void *sub_100073A74(void *result)
{
  if (*result < 0x80uLL) {
    __break(1u);
  }
  else {
    *result -= 128LL;
  }
  return result;
}

BOOL sub_100073A8C(uint64_t a1, uint64_t a2)
{
  return *(void *)(a1 + 16) == *(void *)(a2 + 16);
}

void sub_100073AE0(void *a1@<X8>)
{
  *a1 = *(void *)(v1 + 8);
}

unint64_t sub_100073AEC(_BYTE *a1, unint64_t *a2)
{
  unint64_t v4 = *a2;
  uint64_t v6 = *(void *)(v2 + 16);
  unint64_t result = NANIntervalDuration.timeUnits.getter(0);
  if (result)
  {
    if (((v4 / result) & 0x8000000000000000LL) == 0)
    {
      *a1 = *((_BYTE *)&v6 + ((v4 / result) >> 3));
      return (unint64_t)NANBitmap.Channel.operatingClass.getter;
    }
  }

  else
  {
    __break(1u);
  }

  __break(1u);
  return result;
}

unint64_t *sub_100073B5C@<X0>(unint64_t *result@<X0>, unint64_t *a2@<X8>)
{
  unint64_t v3 = *v2;
  unint64_t v4 = v2[1];
  if (v4 < *v2)
  {
    __break(1u);
    goto LABEL_6;
  }

  unint64_t v5 = *result;
  if (*result < v3)
  {
LABEL_6:
    __break(1u);
    goto LABEL_7;
  }

  unint64_t v6 = result[1];
  if (v4 >= v6)
  {
    unint64_t v7 = v2[2];
    a2[2] = v3;
    a2[3] = v4;
    a2[4] = v7;
    *a2 = v5;
    a2[1] = v6;
    return result;
  }

double sub_100073BA0@<D0>(uint64_t a1@<X8>)
{
  uint64_t v2 = *(void *)v1;
  uint64_t v3 = *((void *)v1 + 1);
  *(double *)a1 = *v1;
  *(void *)(a1 + 8) = v3;
  double result = v1[2];
  *(double *)(a1 + 16) = result;
  *(void *)(a1 + 24) = v2;
  *(void *)(a1 + 32) = v3;
  return result;
}

BOOL sub_100073BB8()
{
  return *(void *)(v0 + 16) == 0LL;
}

void sub_100073C0C(uint64_t a1@<X8>)
{
  *(void *)a1 = 0LL;
  *(_WORD *)(a1 + 8) = 256;
}

void *sub_100073C1C@<X0>(void *result@<X0>, unint64_t a2@<X1>, void *a3@<X8>)
{
  if ((a2 & 0x8000000000000000LL) == 0)
  {
    if (a2 >> 57)
    {
      __break(1u);
    }

    else if (!__CFADD__(*result, a2 << 7))
    {
      *a3 = *result + (a2 << 7);
      return result;
    }

    __break(1u);
  }

  double result = (void *)_assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  "Negative value is not representable",  35LL,  2LL,  "Swift/Integers.swift",  20LL,  2,  3451LL,  0);
  __break(1u);
  return result;
}

void *sub_100073CA0(void *result, void *a2)
{
  if (*a2 >= *result) {
    return (void *)((*a2 - *result) >> 7);
  }
  __break(1u);
  return result;
}

void *sub_100073CC8@<X0>(void *result@<X0>, void *a2@<X8>)
{
  if (*result >= 0xFFFFFFFFFFFFFF80LL) {
    __break(1u);
  }
  else {
    *a2 = *result + 128LL;
  }
  return result;
}

void *sub_100073CE0(void *result)
{
  if (*result >= 0xFFFFFFFFFFFFFF80LL) {
    __break(1u);
  }
  else {
    *result += 128LL;
  }
  return result;
}

__n128 sub_100073CF8@<Q0>(__n128 *a1@<X8>)
{
  __n128 result = *v1;
  *a1 = *v1;
  a1[1].n128_u64[0] = v1[1].n128_u64[0];
  a1[1].n128_u64[1] = result.n128_u64[0];
  return result;
}

unint64_t sub_100073D0C()
{
  unint64_t v1 = v0[1];
  if (v1 >= *v0) {
    return (v1 - *v0) >> 7;
  }
  __break(1u);
  return result;
}

void *sub_100073D24()
{
  return sub_100080BBC(*(void **)v0, *(void *)(v0 + 8), *(void *)(v0 + 16));
}

unint64_t sub_100073D30(unint64_t a1, _BYTE *a2, uint64_t a3)
{
  return sub_100080400(a1, a2, a3, *v3, v3[1], v3[2]);
}

uint64_t sub_100073D40@<X0>(void *a1@<X0>, uint64_t a2@<X1>, void *a3@<X2>, uint64_t a4@<X8>)
{
  return sub_100073E60(a1, a2, a3, sub_1000868CC, a4);
}

unint64_t sub_100073D50()
{
  return TimeBitmap.description.getter(*(void *)v0, *(void *)(v0 + 8), *(void *)(v0 + 16));
}

void *sub_100073D5C@<X0>(void *result@<X0>, void *a2@<X8>)
{
  if (*result < 0x10uLL) {
    __break(1u);
  }
  else {
    *a2 = *result - 16LL;
  }
  return result;
}

void *sub_100073D74(void *result)
{
  if (*result < 0x10uLL) {
    __break(1u);
  }
  else {
    *result -= 16LL;
  }
  return result;
}

uint64_t (*sub_100073D8C(_BYTE *a1, unint64_t *a2, uint64_t a3))(void)
{
  *a1 = TimeBitmap.subscript.getter(*a2, (uint64_t)a2, a3, *(void *)(v3 + 16)) & 1;
  return NANBitmap.Channel.operatingClass.getter;
}

BOOL sub_100073DC8()
{
  return *v0 == v0[1];
}

void *sub_100073DDC@<X0>(void *result@<X0>, unint64_t a2@<X1>, void *a3@<X8>)
{
  if ((a2 & 0x8000000000000000LL) == 0)
  {
    if (a2 >> 60)
    {
      __break(1u);
    }

    else if (!__CFADD__(*result, 16 * a2))
    {
      *a3 = *result + 16 * a2;
      return result;
    }

    __break(1u);
  }

  unint64_t result = (void *)_assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  "Negative value is not representable",  35LL,  2LL,  "Swift/Integers.swift",  20LL,  2,  3451LL,  0);
  __break(1u);
  return result;
}

uint64_t sub_100073E60@<X0>( void *a1@<X0>, uint64_t a2@<X1>, void *a3@<X2>, uint64_t (*a4)(void, uint64_t, void)@<X5>, uint64_t a5@<X8>)
{
  uint64_t result = a4(*a1, a2, *a3);
  *(void *)a5 = result;
  *(_BYTE *)(a5 + 8) = v7 & 1;
  return result;
}

void *sub_100073E94(void *result, void *a2)
{
  if (*a2 >= *result) {
    return (void *)((*a2 - *result) >> 4);
  }
  __break(1u);
  return result;
}

void *sub_100073EB0(void *result, void *a2)
{
  if (*result < *a2 || *result >= a2[1]) {
    __break(1u);
  }
  return result;
}

void *sub_100073ECC(void *result, void *a2)
{
  if (*result < *a2 || a2[1] < *result) {
    __break(1u);
  }
  return result;
}

void *sub_100073EE8(void *result, void *a2)
{
  if (*result < *a2 || a2[1] < result[1]) {
    __break(1u);
  }
  return result;
}

void *sub_100073F04@<X0>(void *result@<X0>, void *a2@<X8>)
{
  if (*result >= 0xFFFFFFFFFFFFFFF0LL) {
    __break(1u);
  }
  else {
    *a2 = *result + 16LL;
  }
  return result;
}

void *sub_100073F1C(void *result)
{
  if (*result >= 0xFFFFFFFFFFFFFFF0LL) {
    __break(1u);
  }
  else {
    *result += 16LL;
  }
  return result;
}

unint64_t sub_100073F34()
{
  unint64_t v1 = v0[1];
  if (v1 >= *v0) {
    return (v1 - *v0) >> 4;
  }
  __break(1u);
  return result;
}

unint64_t *sub_100073F4C()
{
  return sub_100080C74(*(unint64_t **)v0, *(void *)(v0 + 8), *(void *)(v0 + 16));
}

unint64_t *sub_100073F58(unint64_t *a1, uint64_t a2, uint64_t a3)
{
  return sub_1000802DC(a1, a2, a3, *v3, v3[1], v3[2]);
}

uint64_t sub_100073F64(char a1)
{
  __int16 v1 = 2 * (a1 & 1);
  if ((a1 & 2) != 0) {
    v1 |= 0xCu;
  }
  if ((a1 & 4) != 0) {
    v1 |= 0x28u;
  }
  if ((a1 & 8) != 0) {
    v1 |= 0x8Cu;
  }
  if ((a1 & 0x10) != 0) {
    v1 |= 0x210u;
  }
  if ((a1 & 0x20) != 0) {
    v1 |= 0x814u;
  }
  if ((a1 & 0x40) != 0) {
    v1 |= 0x2018u;
  }
  if (a1 >= 0) {
    __int16 v2 = v1;
  }
  else {
    __int16 v2 = v1 | 0x801C;
  }
  __int16 v4 = v2;
  return sub_1000EF854((uint64_t)&v4, (uint64_t)&v5);
}

uint64_t sub_100074030(char a1)
{
  int v1 = 2 * (a1 & 1);
  if ((a1 & 2) != 0) {
    v1 |= 0x30u;
  }
  if ((a1 & 4) != 0) {
    v1 |= 0x220u;
  }
  if ((a1 & 8) != 0) {
    v1 |= 0x2030u;
  }
  if ((a1 & 0x10) != 0) {
    v1 |= 0x20040u;
  }
  if ((a1 & 0x20) != 0) {
    v1 |= 0x200050u;
  }
  if ((a1 & 0x40) != 0) {
    v1 |= 0x2000060u;
  }
  if (a1 >= 0) {
    int v2 = v1;
  }
  else {
    int v2 = v1 | 0x20000070;
  }
  int v4 = v2;
  return sub_1000EF854((uint64_t)&v4, (uint64_t)&v5);
}

uint64_t TimeBitmap.nanBitmap.getter(unint64_t a1, unint64_t a2, unint64_t a3)
{
  unint64_t v7 = a1;
  unint64_t v8 = a1;
  if (a1 != a2)
  {
    unint64_t v9 = a1 >> 7;
    unint64_t v7 = a1;
    while (1)
    {
      uint64_t v50 = (void *)a3;
      if (*((_BYTE *)&v50 + v9)) {
        break;
      }
      unint64_t v10 = v7 + 128;
      if (v7 >= 0xFFFFFFFFFFFFFF80LL)
      {
LABEL_39:
        __break(1u);
        goto LABEL_40;
      }

      v7 += 128LL;
      ++v9;
      if (v10 == a2)
      {
        unint64_t v7 = a2;
        break;
      }
    }

    unint64_t v11 = a2;
    while (1)
    {
      BOOL v12 = v11 >= 0x80;
      v11 -= 128LL;
      if (!v12)
      {
        __break(1u);
        goto LABEL_39;
      }

      uint64_t v50 = (void *)a3;
      if (*((_BYTE *)&v50 + (v11 >> 7))) {
        break;
      }
      if (v11 == a1)
      {
        unint64_t v8 = a1;
        goto LABEL_14;
      }
    }

    unint64_t v8 = v11 + 128;
    if (v11 >= 0xFFFFFFFFFFFFFF80LL) {
      goto LABEL_49;
    }
  }

LABEL_14:
  unint64_t v3 = v7 - a1;
  if (v7 < a1) {
    goto LABEL_42;
  }
  unint64_t v42 = v8;
  unint64_t v13 = NANIntervalDuration.timeUnits.getter(0);
  if (!v13)
  {
LABEL_43:
    __break(1u);
    goto LABEL_44;
  }

  if ((v3 & 0xF) != 0)
  {
LABEL_44:
    __break(1u);
    goto LABEL_45;
  }

  unint64_t v14 = v3 / v13;
  if (v3 / v13 > 0x1FF)
  {
LABEL_45:
    __break(1u);
    goto LABEL_46;
  }

  unint64_t v3 = 0LL;
  int v15 = sub_1001A05D8(0, 0LL, 3LL);
  int v16 = sub_1001A05D8(4u, 3uLL, 3LL);
  int v17 = sub_1001A05EC(v14, 6uLL, 9LL);
  int v18 = v17;
  unint64_t v19 = v42 - v7;
  if (v42 > v7)
  {
    if (a2 < a1)
    {
LABEL_46:
      __break(1u);
      goto LABEL_47;
    }

    if (v7 < a1)
    {
LABEL_47:
      __break(1u);
      goto LABEL_48;
    }

    if (v42 > a2)
    {
LABEL_48:
      __break(1u);
LABEL_49:
      __break(1u);
      swift_unexpectedError(v3, "CoreP2P/NANAvailability.swift", 29LL, 1LL);
      __break(1u);
      swift_unexpectedError(v3, "CoreP2P/NANAvailability.swift", 29LL, 1LL);
      __break(1u);
      uint64_t result = swift_unexpectedError(v3, "CoreP2P/NANAvailability.swift", 29LL, 1LL);
      __break(1u);
      return result;
    }

    char v20 = _swiftEmptyArrayStorage;
    if (v19 >= 0x80)
    {
      int v40 = v17;
      int v41 = v15;
      unint64_t v3 = v19 >> 7;
      uint64_t v50 = _swiftEmptyArrayStorage;
      sub_10006972C(0, v19 >> 7, 0);
      unint64_t v21 = v42;
      char v20 = v50;
      unint64_t v22 = v7 >> 7;
      unint64_t v23 = HIBYTE(a3);
      unint64_t v24 = HIWORD(a3);
      unint64_t v25 = a3 >> 40;
      unint64_t v26 = HIDWORD(a3);
      unint64_t v27 = a3 >> 24;
      while (v7 < v21)
      {
        __int16 v43 = a3;
        char v44 = BYTE2(a3);
        char v45 = v27;
        char v46 = v26;
        char v47 = v25;
        char v48 = v24;
        char v49 = v23;
        unint64_t v29 = v20[2];
        unint64_t v28 = v20[3];
        char v30 = *((_BYTE *)&v43 + v22);
        uint64_t v50 = v20;
        if (v29 >= v28 >> 1)
        {
          unint64_t v38 = v24;
          unint64_t v39 = v23;
          unint64_t v36 = v26;
          unint64_t v37 = v25;
          unint64_t v35 = v27;
          sub_10006972C(v28 > 1, v29 + 1, 1);
          unint64_t v27 = v35;
          unint64_t v26 = v36;
          unint64_t v25 = v37;
          unint64_t v24 = v38;
          unint64_t v23 = v39;
          unint64_t v21 = v42;
          char v20 = v50;
        }

        v20[2] = v29 + 1;
        *((_BYTE *)v20 + v29 + 32) = v30;
        if (v7 >= 0xFFFFFFFFFFFFFF80LL) {
          goto LABEL_41;
        }
        ++v22;
        v7 += 128LL;
        if (!--v3)
        {
          int v15 = v41;
          int v18 = v40;
          goto LABEL_31;
        }
      }

  unint64_t v13 = *v3;
  *(void *)(*v3 + 8 * (a2 >> 6) + 56) |= 1LL << a2;
  *(void *)(*(void *)(v13 + 48) + 8 * a2) = v5;
  unint64_t v14 = *(void *)(v13 + 16);
  int v15 = __OFADD__(v14, 1LL);
  int v16 = v14 + 1;
  if (v15) {
    __break(1u);
  }
  else {
    *(void *)(v13 + 16) = v16;
  }
  return result;
}

  unint64_t v13 = *v3;
  *(void *)(*v3 + 8 * (a2 >> 6) + 56) |= 1LL << a2;
  *(_BYTE *)(*(void *)(v13 + 48) + a2) = v5;
  unint64_t v14 = *(void *)(v13 + 16);
  int v15 = __OFADD__(v14, 1LL);
  int v16 = v14 + 1;
  if (v15) {
    __break(1u);
  }
  else {
    *(void *)(v13 + 16) = v16;
  }
  return result;
}

        _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  "Negative value is not representable",  35LL,  2LL,  "Swift/Integers.swift",  20LL,  2,  3451LL,  0);
        goto LABEL_16;
      }
    }

    __break(1u);
    goto LABEL_14;
  }

  return sub_1000208D8(v1, v2);
}

        _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  "Negative value is not representable",  35LL,  2LL,  "Swift/Integers.swift",  20LL,  2,  3451LL,  0);
        goto LABEL_16;
      }
    }

    __break(1u);
    goto LABEL_14;
  }

  return sub_1000208D8(v1, v2);
}

    unint64_t v10 = 1;
    unint64_t v23 = v4;
LABEL_15:
    swift_bridgeObjectRelease(v4);
    swift_bridgeObjectRelease(v23);
    return v10 & 1;
  }

    unint64_t v25 = *(void **)a5;
    *(void *)(*(void *)a5 + 8 * (v17 >> 6) + 64) |= 1LL << v17;
    *(void *)(v25[6] + 8 * v17) = v14;
    sub_100022594(v47, (_OWORD *)(v25[7] + 32 * v17));
    unint64_t v26 = v25[2];
    unint64_t v27 = __OFADD__(v26, 1LL);
    unint64_t v28 = v26 + 1;
    if (v27)
    {
LABEL_28:
      __break(1u);
      goto LABEL_29;
    }

    v25[2] = v28;
LABEL_16:
    sub_10018CFC4((uint64_t)&v48);
    for (unint64_t i = v48; v48; unint64_t i = v48)
    {
      sub_100022594(v49, v47);
      int v32 = *(void **)a5;
      int v33 = sub_10001C470((uint64_t)i);
      unint64_t v35 = v32[2];
      unint64_t v36 = (v34 & 1) == 0;
      unint64_t v27 = __OFADD__(v35, v36);
      unint64_t v37 = v35 + v36;
      if (v27) {
        goto LABEL_27;
      }
      unint64_t v38 = v34;
      if (v32[3] < v37)
      {
        sub_100137ED4(v37, 1LL);
        int v33 = sub_10001C470((uint64_t)i);
        if ((v38 & 1) != (v39 & 1)) {
          goto LABEL_29;
        }
      }

      if ((v38 & 1) != 0)
      {
        char v30 = 32 * v33;
        sub_100002AE4(*(void *)(*(void *)a5 + 56LL) + 32 * v33, (uint64_t)v45);
        sub_100002AE4((uint64_t)v45, (uint64_t)v46);
        sub_100002AC4(v45);
        sub_100002AC4(v47);

        int v31 = (void *)(*(void *)(*(void *)a5 + 56LL) + v30);
        sub_100002AC4(v31);
        sub_100022594(v46, v31);
      }

      else
      {
        int v40 = *(void **)a5;
        *(void *)(*(void *)a5 + 8 * (v33 >> 6) + 64) |= 1LL << v33;
        *(void *)(v40[6] + 8 * v33) = i;
        sub_100022594(v47, (_OWORD *)(v40[7] + 32 * v33));
        int v41 = v40[2];
        unint64_t v27 = __OFADD__(v41, 1LL);
        unint64_t v42 = v41 + 1;
        if (v27) {
          goto LABEL_28;
        }
        v40[2] = v42;
      }

      sub_10018CFC4((uint64_t)&v48);
    }

      v54(v52, v135);
      goto LABEL_15;
    }

    __break(1u);
    goto LABEL_15;
  }

  if ((int)v0 > (uint64_t)v0 >> 32)
  {
    __break(1u);
    goto LABEL_14;
  }

  unint64_t v3 = sub_100020AFC(v0, v2);
  int v4 = ((uint64_t (*)(uint64_t))__DataStorage._bytes.getter)(v3);
  if (!v4)
  {
    __DataStorage._length.getter();
    __break(1u);
    goto LABEL_18;
  }

  uint64_t v5 = v4;
  unint64_t v6 = __DataStorage._offset.getter();
  unint64_t v7 = (int)v0 - v6;
  if (__OFSUB__((int)v0, v6))
  {
LABEL_15:
    __break(1u);
    goto LABEL_16;
  }

  unint64_t v8 = ((__n128 (*)(void))__DataStorage._length.getter)();
  unint64_t v9 = v5 + v7;
  unint64_t v10 = *(_BYTE *)(v5 + v7);
  v8.n128_u32[0] = *(_DWORD *)(v9 + 1);
  unint64_t v11 = vmovl_u8((uint8x8_t)v8.n128_u64[0]);
  unint64_t v36 = (int32x4_t)v11;
  LOBYTE(v12) = *(_BYTE *)(v9 + 5);
  LOBYTE(v13) = *(_BYTE *)(v9 + 6);
  unint64_t v14 = *(unsigned __int8 *)(v9 + 7);
  v11.i32[0] = *(_DWORD *)(v9 + 9);
  unint64_t v35 = vmovl_u8(*(uint8x8_t *)v11.i8);
  sub_1000208D8(v0, v2);
LABEL_12:
  sub_1000208D8(v0, v2);
  sub_1000208D8(v0, v2);
  unint64_t v29 = vmovl_u16((uint16x4_t)(v36.i64[0] & 0xFF00FF00FF00FFLL));
  v30.i64[0] = v29.u32[0];
  v30.i64[1] = v29.u32[1];
  int v31 = v30;
  v30.i64[0] = v29.u32[2];
  v30.i64[1] = v29.u32[3];
  int v32 = vorrq_s8( (int8x16_t)vshlq_u64(v31, (uint64x2_t)xmmword_10033A9C0),  (int8x16_t)vshlq_u64(v30, (uint64x2_t)xmmword_10035C790));
  return (*(void *)&vorr_s8(*(int8x8_t *)v32.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v32, v32, 8uLL)) | ((unint64_t)v12 << 40) | v10)
}

      sub_1002A732C((uint64_t)&v157);
      return sub_10005802C(v33, type metadata accessor for DriverEvent);
    }

    sub_1002A732C((uint64_t)&v157);
    goto LABEL_21;
  }

  v152 = *(void *)(NANBitmap.Channel.operatingClass.getter(v160) + 8);
  unint64_t v42 = qword_100410BB8;
  __int16 v43 = (char *)v153;
  char v44 = (void *)&unk_10040E000;
  if (*(_BYTE *)(v153 + qword_100410BB8) != 1) {
    goto LABEL_31;
  }
  char v45 = type metadata accessor for P2PTimer(0LL);
  char v46 = v148;
  v138 = v45;
  variable initialization expression of AWDLPeer.lastUpdated();
  char v47 = &v43[qword_10040EFA8];
  char v48 = swift_beginAccess(&v43[qword_10040EFA8], v159, 0LL, 0LL);
  uint64_t v50 = v149;
  char v49 = v150;
  uint64_t v51 = *(void (**)(char *, char *, uint64_t, __n128))(v149 + 16);
  char v52 = v43;
  uint64_t v53 = v142;
  v137 = v47;
  v51(v142, v47, v150, v48);
  uint64_t v54 = (uint64_t)v143;
  DispatchTime.distance(to:)(v46);
  uint64_t v55 = *(void (**)(char *, uint64_t))(v50 + 8);
  uint64_t v56 = v53;
  __int16 v43 = v52;
  v55(v56, v49);
  v55(v46, v49);
  uint64_t v57 = NANConstants.maximumServiceRetryRate.unsafeMutableAddressor();
  uint64_t v59 = (uint64_t)v144;
  uint64_t v58 = v145;
  uint64_t v60 = v146;
  (*(void (**)(char *, uint64_t, uint64_t))(v145 + 16))(v144, v57, v146);
  LOBYTE(v55) = static DispatchTimeInterval.< infix(_:_:)(v59, v54);
  int v61 = *(void (**)(uint64_t, uint64_t))(v58 + 8);
  v61(v59, v60);
  __int128 v62 = v54;
  char v44 = (void *)&unk_10040E000;
  v61(v62, v60);
  if ((v55 & 1) != 0)
  {
    v151 = (void *)v42;
    uint64_t v63 = &v52[qword_100410BC0];
    uint64_t v64 = v52;
    v146 = (uint64_t)v63;
    int64_t v65 = (os_log_s *)Logger.logObject.getter(v64);
    uint64_t v66 = static os_log_type_t.error.getter(v65);
    uint64_t v67 = os_log_type_enabled(v65, (os_log_type_t)v66);
    v134 = v33;
    if (v67)
    {
      LODWORD(v145) = v66;
      v68 = swift_slowAlloc(22LL, -1LL);
      v69 = (char **)swift_slowAlloc(8LL, -1LL);
      int v70 = swift_slowAlloc(32LL, -1LL);
      v154[0] = v70;
      *(_DWORD *)v68 = 138412546;
      v156 = v64;
      uint64_t v71 = v64;
      uint64_t v72 = v152;
      UnsafeMutableRawBufferPointer.copyMemory(from:)(&v156, &v157);
      char *v69 = v64;

      *(_WORD *)(v68 + 12) = 2080;
      v73 = 0xD000000000000011LL;
      int64_t v74 = 0x8000000100364DC0LL;
      switch(v72)
      {
        case -1LL:
          break;
        case 1LL:
          v73 = 0x754F2064656D6954LL;
          int64_t v74 = 0xE900000000000074LL;
          break;
        case 2LL:
          v73 = 0x7165522072657355LL;
          int64_t v74 = 0xEE00646574736575LL;
          break;
        case 3LL:
          v73 = 0x6961462070696843LL;
          int64_t v74 = 0xEC0000006572756CLL;
          break;
        case 4LL:
          v73 = 0xD000000000000018LL;
          int64_t v74 = 0x8000000100364D20LL;
          break;
        default:
          int64_t v74 = 0xE700000000000000LL;
          v73 = 0x6E776F6E6B6E55LL;
          break;
      }

      v156 = (char *)sub_10000235C(v73, v74, v154);
      UnsafeMutableRawBufferPointer.copyMemory(from:)(&v156, &v157);
      swift_bridgeObjectRelease(v74);
      _os_log_impl( (void *)&_mh_execute_header,  v65,  (os_log_type_t)v145,  "%@ got an early termination with reason: %s. Retrying",  (uint8_t *)v68,  0x16u);
      v97 = sub_100002274(&qword_100404DE0);
      swift_arrayDestroy(v69, 1LL, v97);
      swift_slowDealloc(v69, -1LL, -1LL);
      swift_arrayDestroy(v70, 1LL, &type metadata for Any[8]);
      swift_slowDealloc(v70, -1LL, -1LL);
      swift_slowDealloc(v68, -1LL, -1LL);

      int v33 = v134;
      char v44 = &unk_10040E000;
    }

    else
    {
    }

    v99 = v147;
    v98 = v148;
    v100 = v136;
    v101 = v137;
    variable initialization expression of AWDLPeer.lastUpdated();
    v102 = swift_beginAccess(v101, v154, 33LL, 0LL);
    (*(void (**)(char *, char *, uint64_t, __n128))(v149 + 40))(v101, v98, v150, v102);
    swift_endAccess(v154);
    v103 = *(void *)&v64[v44[500]];
    swift_unownedRetainStrong(v103);
    sub_1002E8C08();
    swift_release(v103);
    swift_unownedRetainStrong(v103);
    v104 = *(void (**)(char *, uint64_t, uint64_t))(v99 + 16);
    v105 = v99;
    v106 = AssociatedTypeWitness;
    v104(v100, v103 + *(void *)(*(void *)v103 + 96LL), AssociatedTypeWitness);
    swift_release(v103);
    v107 = &v64[qword_100410BB0];
    swift_beginAccess(&v64[qword_100410BB0], v154, 0LL, 0LL);
    v108 = (uint64_t)v107;
    v109 = v100;
    v110 = v135;
    sub_100057FE8(v108, v135, type metadata accessor for NANSubscribe.Configuration);
    v111 = swift_getAssociatedConformanceWitness( v140,  v139,  v106,  &protocol requirements base descriptor for NANController,  &associated conformance descriptor for NANController.P2PControls.Driver: NANWiFiDriver);
    (*(void (**)(uint64_t, uint64_t, uint64_t))(v111 + 184))(v110, v106, v111);
    sub_10005802C(v110, type metadata accessor for NANSubscribe.Configuration);
    (*(void (**)(char *, uint64_t))(v105 + 8))(v109, v106);
  }

  else
  {
LABEL_31:
    v112 = v43;
    v113 = (os_log_s *)Logger.logObject.getter(v112);
    v114 = static os_log_type_t.default.getter(v113);
    if (os_log_type_enabled(v113, (os_log_type_t)v114))
    {
      LODWORD(v149) = v114;
      v151 = (void *)v42;
      v134 = v33;
      v115 = swift_slowAlloc(22LL, -1LL);
      v116 = (char **)swift_slowAlloc(8LL, -1LL);
      v150 = swift_slowAlloc(32LL, -1LL);
      v155 = (uint64_t)v112;
      v156 = (char *)v150;
      *(_DWORD *)v115 = 138412546;
      v117 = v112;
      v118 = v152;
      UnsafeMutableRawBufferPointer.copyMemory(from:)(&v155, &v156);
      *v116 = v112;

      *(_WORD *)(v115 + 12) = 2080;
      v119 = 0xD000000000000011LL;
      v120 = 0x8000000100364DC0LL;
      switch(v118)
      {
        case -1LL:
          break;
        case 1LL:
          v119 = 0x754F2064656D6954LL;
          v120 = 0xE900000000000074LL;
          break;
        case 2LL:
          v119 = 0x7165522072657355LL;
          v120 = 0xEE00646574736575LL;
          break;
        case 3LL:
          v119 = 0x6961462070696843LL;
          v120 = 0xEC0000006572756CLL;
          break;
        case 4LL:
          v119 = 0xD000000000000018LL;
          v120 = 0x8000000100364D20LL;
          break;
        default:
          v120 = 0xE700000000000000LL;
          v119 = 0x6E776F6E6B6E55LL;
          break;
      }

      v155 = sub_10000235C(v119, v120, (uint64_t *)&v156);
      UnsafeMutableRawBufferPointer.copyMemory(from:)(&v155, &v156);
      swift_bridgeObjectRelease(v120);
      _os_log_impl( (void *)&_mh_execute_header,  v113,  (os_log_type_t)v149,  "%@ was terminated with reason %s",  (uint8_t *)v115,  0x16u);
      v121 = sub_100002274(&qword_100404DE0);
      swift_arrayDestroy(v116, 1LL, v121);
      swift_slowDealloc(v116, -1LL, -1LL);
      v122 = v150;
      swift_arrayDestroy(v150, 1LL, &type metadata for Any[8]);
      swift_slowDealloc(v122, -1LL, -1LL);
      swift_slowDealloc(v115, -1LL, -1LL);

      int v33 = v134;
      __int16 v43 = (char *)v153;
      char v44 = &unk_10040E000;
      unint64_t v42 = (uint64_t)v151;
    }

    else
    {
    }

    v43[v42] = 0;
    v123 = *(void *)&v112[qword_10040EFB0];
    *(void *)&v112[qword_10040EFB0] = 0LL;
    swift_release(v123);
    v124 = qword_10040EFB8;
    v125 = *(void **)&v112[qword_10040EFB8];
    v126 = v33;
    if (v125)
    {
      [v125 subscribeTerminatedWithReason:v152];
      v125 = *(void **)&v112[v124];
    }

    *(void *)&v112[v124] = 0LL;
    swift_unknownObjectRelease(v125);
    v127 = *(void *)&v112[v44[500]];
    v128 = swift_unownedRetainStrong(v127);
    v132 = sub_1002E8D68(v128, v129, v130, v131);
    swift_release(v127);
    sub_10029E604((uint64_t)v112);
    swift_release(v132);
    int v33 = v126;
  }

  return sub_10005802C(v33, type metadata accessor for DriverEvent);
}

  if (a4)
  {
    sub_100058CD0(0LL, (unint64_t *)&unk_10040CC00, &OBJC_CLASS___AWDLTrafficRegistrationConfiguration_ptr);
    unint64_t v22 = v7;
    unint64_t v23 = a4;
    unint64_t v24 = static NSObject.== infix(_:_:)(v22, v23);

    if ((v24 & 1) != 0) {
      goto LABEL_11;
    }
  }

  unint64_t v25 = objc_msgSend(v7, "uniqueIdentifier", v19);
  unint64_t v26 = static String._unconditionallyBridgeFromObjectiveC(_:)(v25);
  unint64_t v28 = v27;
  char v30 = static String._unconditionallyBridgeFromObjectiveC(_:)(a2);
  int v31 = v29;
  if (v26 == v30 && v28 == v29)
  {

    swift_bridgeObjectRelease_n(v28, 2LL);
  }

  else
  {
    int v32 = _stringCompareWithSmolCheck(_:_:expecting:)(v26, v28, v30, v29, 0LL);

    swift_bridgeObjectRelease(v28);
    swift_bridgeObjectRelease(v31);
    if ((v32 & 1) == 0)
    {
      char v20 = 1;
      return v20 & 1;
    }
  }

  char v20 = AWDLTrafficRegistrationService.allowsMultipleConcurrentPeers.getter(a2) ^ 1;
  return v20 & 1;
}

  unint64_t v14 = *v3;
  *(void *)(*v3 + 8 * (a2 >> 6) + 56) |= 1LL << a2;
  *(void *)(*(void *)(v14 + 48) + 8 * a2) = v5;
  int v15 = *(void *)(v14 + 16);
  int v16 = __OFADD__(v15, 1LL);
  int v17 = v15 + 1;
  if (v16) {
    __break(1u);
  }
  else {
    *(void *)(v14 + 16) = v17;
  }
  return result;
}

  int v17 = *v3;
  *(void *)(*v3 + 8 * (a2 >> 6) + 56) |= 1LL << a2;
  int v18 = *(void *)(v17 + 48) - a2 + 8 * a2;
  *(_WORD *)int v18 = v5;
  *(_BYTE *)(v18 + 2) = v22;
  *(_BYTE *)(v18 + 3) = v23;
  *(_BYTE *)(v18 + 4) = v10;
  *(_BYTE *)(v18 + 5) = BYTE5(v5);
  *(_BYTE *)(v18 + 6) = v11;
  unint64_t v19 = *(void *)(v17 + 16);
  char v20 = __OFADD__(v19, 1LL);
  unint64_t v21 = v19 + 1;
  if (v20) {
    __break(1u);
  }
  else {
    *(void *)(v17 + 16) = v21;
  }
  return result;
}

LABEL_31:
    sub_1000FB08C((uint64_t)v20);
    swift_bridgeObjectRelease(v20);
  }

  else {
    int v31 = 0;
  }
  int v32 = v31 | v15;
  else {
    int v33 = 0;
  }
  return v33 | v32;
}

  Hasher._combine(_:)(v23);
}

      v34 += 2;
      if (!--v33)
      {
        int v32 = v60;
        swift_bridgeObjectRelease(v60);
        goto LABEL_46;
      }
    }

    unint64_t v39 = &static WiFiDriverCapabilities.supportsSimultaneousDualBand;
    if (qword_1004040E0 != -1)
    {
      swift_once(&qword_1004040E0, sub_10005DC0C);
      unint64_t v39 = &static WiFiDriverCapabilities.supportsSimultaneousDualBand;
    }

      v39 += 2;
      if (!--v38)
      {
        swift_bridgeObjectRelease(v71);
        goto LABEL_46;
      }
    }

    char v44 = &static WiFiDriverCapabilities.supportsSimultaneousDualBand;
    if (qword_1004040E0 != -1)
    {
      swift_once(&qword_1004040E0, sub_10005DC0C);
      char v44 = &static WiFiDriverCapabilities.supportsSimultaneousDualBand;
    }

      swift_arrayDestroy(v99, v100, v97);
      swift_slowDealloc(v98, -1LL, -1LL);
      swift_slowDealloc(v89, -1LL, -1LL);

      return sub_10005802C(v30, type metadata accessor for DriverEvent);
    }

  __break(1u);
}

  __break(1u);
  return result;
}

    v162 = (v50 - 1) & v50;
    v163 = v51;
    char v48 = __clz(__rbit64(v50)) + (v51 << 6);
LABEL_32:
    uint64_t v53 = *(void *)(v159 + 48);
    v169 = *(void *)(v158 + 72);
    uint64_t v54 = v157;
    sub_100057FE8(v53 + v169 * v48, v157, type metadata accessor for AWDLPeer.AdvertisedService);
    sub_1002B1744(v54, (uint64_t)v10);
    Hasher.init(_seed:)(&v180, *(void *)(a2 + 40));
    swift_bridgeObjectRetain(a2);
    AWDLPeer.AdvertisedService.hash(into:)((uint64_t)&v180);
    uint64_t v55 = Hasher._finalize()();
    uint64_t v56 = -1LL << *(_BYTE *)(a2 + 32);
    uint64_t v57 = v55 & ~v56;
    if (((*(void *)(v170 + ((v57 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> v57) & 1) != 0)
    {
      v168 = ~v56;
      do
      {
        uint64_t v58 = v57 * v169;
        sub_100057FE8(*(void *)(a2 + 48) + v57 * v169, v38, type metadata accessor for AWDLPeer.AdvertisedService);
        uint64_t v59 = *(void *)(v38 + 8);
        uint64_t v60 = *(void *)(v38 + 16);
        int v61 = *(void *)(v38 + 24);
        v173 = *(void *)(v38 + 32);
        v174 = v61;
        __int128 v62 = *(unsigned __int8 *)(v38 + 40);
        uint64_t v63 = *(unsigned __int8 *)(v38 + 41);
        uint64_t v64 = *((void *)v10 + 1);
        int64_t v65 = *((void *)v10 + 2);
        uint64_t v66 = *((void *)v10 + 3);
        v171 = *((void *)v10 + 4);
        v172 = v66;
        uint64_t v67 = v10[40];
        v68 = v10[41];
        v180 = v59;
        v181 = v60;
        v175 = v64;
        v176 = v65;
        v69 = sub_10000B08C();
        if (StringProtocol.caseInsensitiveCompare<A>(_:)( &v175,  &type metadata for String,  &type metadata for String,  v69,  v69))
        {
          sub_10005802C(v38, type metadata accessor for AWDLPeer.AdvertisedService);
        }

        else
        {
          v165 = v58;
          v164 = v69;
          int v70 = static DNSRecords.Identifier.== infix(_:_:)(v174, v173, v62 | (v63 << 8), v172, v171, v67 | (v68 << 8));
          sub_10005802C(v38, type metadata accessor for AWDLPeer.AdvertisedService);
          if (v70)
          {
            uint64_t v71 = v166;
            swift_bridgeObjectRelease(v166);
            isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native(v71);
            v180 = v71;
            if ((isUniquelyReferenced_nonNull_native & 1) == 0)
            {
              sub_10013F090();
              uint64_t v71 = v180;
            }

            v73 = *(void *)(v71 + 48) + v165;
            int64_t v74 = v149;
            sub_1002B1744(v73, v149);
            sub_10013FB10(v57);
            a2 = v180;
            swift_bridgeObjectRelease(0x8000000000000000LL);
            int v75 = v74;
            uint64_t v76 = v151;
            sub_1002B1744(v75, (uint64_t)v151);
            Swift::UInt v78 = v76[6];
            uint64_t v77 = v76[7];
            __int128 v80 = v76[8];
            __int128 v79 = v76[9];
            __int128 v82 = v76[10];
            __int128 v81 = v76[11];
            uint64_t v83 = v76[12];
            v85 = *((void *)v167 + 6);
            v84 = *((void *)v167 + 7);
            v86 = *((void *)v167 + 8);
            v174 = *((void *)v167 + 9);
            v88 = *((void *)v167 + 10);
            v87 = *((void *)v167 + 11);
            v89 = *((void *)v167 + 12);
            if (!v77)
            {
              if (!v84) {
                goto LABEL_55;
              }
LABEL_45:
              v103 = v78;
              v170 = v77;
              v171 = v78;
              v104 = v87;
              v105 = v85;
              v106 = v77;
              v107 = v84;
              v172 = v80;
              v173 = v79;
              v169 = v81;
              sub_100020AB0(v103, v106, v80, v79, v82, v81, v83);
              sub_100020AB0(v105, v107, v86, v174, v88, v104, v89);
              sub_10002091C(v171, v170, v172, v173, v82, v169, v83);
              v98 = v105;
              v99 = v107;
              v100 = v86;
              v101 = v174;
              v102 = v88;
              v108 = v104;
              v109 = v89;
              goto LABEL_51;
            }

            if (!v84) {
              goto LABEL_45;
            }
            v180 = v78;
            v181 = v77;
            v175 = v85;
            v176 = v84;
            v90 = v78;
            v165 = v87;
            v91 = v85;
            v92 = v77;
            v93 = v84;
            v170 = v92;
            v171 = v90;
            v172 = v80;
            v173 = v79;
            v166 = v82;
            v169 = v81;
            sub_100020AB0(v90, v92, v80, v79, v82, v81, v83);
            v148 = v93;
            v94 = v86;
            v168 = v86;
            v95 = v174;
            v96 = v88;
            v97 = v165;
            sub_100020AB0(v91, v93, v94, v174, v96, v165, v89);
            if (StringProtocol.caseInsensitiveCompare<A>(_:)( &v175,  &type metadata for String,  &type metadata for String,  v164,  v164))
            {
              sub_10002091C(v91, v148, v168, v95, v96, v97, v89);
              v99 = v170;
              v98 = v171;
              v100 = v172;
              v101 = v173;
              v102 = v166;
              goto LABEL_50;
            }

            v110 = v89;
            v111 = v97;
            v112 = v91;
            v113 = v111;
            v114 = v166;
            if (static DNSRecords.Identifier.== infix(_:_:)(v172, v173, v166 & 0xFF01, v168, v95, v96 & 0xFF01))
            {
              v164 = v96;
              v115 = v169;
              _s7CoreP2P6NANPMKV23__derived_struct_equalsySbAC_ACtFZ_0(v169, v83);
              v117 = v116;
              sub_10002091C(v112, v148, v168, v95, v164, v113, v110);
              sub_10002091C(v171, v170, v172, v173, v166, v115, v83);
              if ((v117 & 1) != 0) {
                goto LABEL_55;
              }
              goto LABEL_52;
            }

            sub_10002091C(v112, v148, v168, v95, v96, v113, v110);
            v99 = v170;
            v98 = v171;
            v100 = v172;
            v101 = v173;
            v102 = v114;
LABEL_50:
            v108 = v169;
            v109 = v83;
LABEL_51:
            sub_10002091C(v98, v99, v100, v101, v102, v108, v109);
LABEL_52:
            v118 = v167;
            v120 = *((void *)v167 + 3);
            v119 = *((void *)v167 + 4);
            v121 = v167[40];
            v122 = v167[41];
            v123 = v156;
            swift_beginAccess(v156, &v180, 32LL, 0LL);
            v124 = *v123;
            v175 = v120;
            v176 = v119;
            v177 = v121;
            v178 = v122;
            v126 = type metadata accessor for AWDLDiscoveryEngine.Browse(0LL, v160, v161, v125);
            sub_100004DEC();
            swift_bridgeObjectRetain(v119);
            Dictionary.subscript.getter(&v175, v124, &type metadata for DNSRecords.Identifier, v126);
            swift_bridgeObjectRelease(v119);
            v127 = v179;
            if (v179)
            {
              swift_endAccess(&v180);
              sub_1002ABA88( v118,  *(unsigned __int16 *)(v153 + v152[5]) | ((unint64_t)*(unsigned int *)(v153 + v152[5] + 2) << 16));
              swift_release(v127);
            }

            else
            {
              swift_endAccess(&v180);
            }

uint64_t TimeBitmap.init(period:repeating:)(unsigned __int8 a1, uint64_t a2)
{
  if (!NANIntervalDuration.timeUnits.getter(0))
  {
    __break(1u);
    goto LABEL_18;
  }

  __int16 v6 = sub_1001A05D8(0, 0LL, 3LL);
  if (v2)
  {
LABEL_18:
    swift_unexpectedError(v2, "CoreP2P/NANAvailability.swift", 29LL, 1LL);
    __break(1u);
    swift_unexpectedError(v2, "CoreP2P/NANAvailability.swift", 29LL, 1LL);
    __break(1u);
    uint64_t result = swift_unexpectedError(v3, "CoreP2P/NANAvailability.swift", 29LL, 1LL);
    __break(1u);
    return result;
  }

  __int16 v7 = v6;
  unsigned __int16 v8 = sub_1001A05D8(a1, 3uLL, 3LL);
  unsigned __int16 v9 = sub_1001A05EC(0LL, 6uLL, 9LL);
  int64_t v10 = *(void *)(a2 + 16);
  if (v10)
  {
    __int16 v23 = v7;
    sub_10006972C(0, v10, 0);
    uint64_t v11 = 0LL;
    uint64_t v12 = _swiftEmptyArrayStorage[2];
    do
    {
      char v13 = *(_BYTE *)(a2 + v11 + 32);
      unint64_t v14 = _swiftEmptyArrayStorage[3];
      if (v12 + v11 >= v14 >> 1) {
        sub_10006972C(v14 > 1, v12 + v11 + 1, 1);
      }
      _swiftEmptyArrayStorage[2] = v12 + v11 + 1;
      *((_BYTE *)&_swiftEmptyArrayStorage[4] + v12 + v11++) = v13;
    }

    while (v10 != v11);
    swift_bridgeObjectRelease(a2);
    __int16 v7 = v23;
  }

  else
  {
    swift_bridgeObjectRelease(a2);
  }

  else {
    unsigned __int16 v15 = 0;
  }
  __int16 v16 = v15 | v7;
  else {
    unsigned __int16 v17 = 0;
  }
  unsigned __int16 v18 = v17 | v16;
  uint64_t v19 = sub_1000FB08C((uint64_t)_swiftEmptyArrayStorage);
  unint64_t v21 = v20;
  swift_bridgeObjectRelease(_swiftEmptyArrayStorage);
  return sub_100083634(v18, v19, v21);
}

uint64_t sub_1000746E0()
{
  uint64_t result = _s7CoreP2P10TimeBitmapV14repeatingPerDWyA2C4SlotV_A3FtFZ_0(240, 0, 0, 0);
  static TimeBitmap.primaryDiscoveryWindow = result;
  unk_1004106C0 = v1;
  LOWORD(qword_1004106C8) = v2;
  BYTE2(qword_1004106C8) = v3;
  BYTE3(qword_1004106C8) = v4;
  BYTE4(qword_1004106C8) = v5;
  BYTE5(qword_1004106C8) = v6;
  BYTE6(qword_1004106C8) = v7;
  HIBYTE(qword_1004106C8) = v8;
  return result;
}

uint64_t *TimeBitmap.primaryDiscoveryWindow.unsafeMutableAddressor()
{
  if (qword_100404128 != -1) {
    swift_once(&qword_100404128, sub_1000746E0);
  }
  return &static TimeBitmap.primaryDiscoveryWindow;
}

uint64_t static TimeBitmap.primaryDiscoveryWindow.getter()
{
  if (qword_100404128 != -1) {
    swift_once(&qword_100404128, sub_1000746E0);
  }
  return static TimeBitmap.primaryDiscoveryWindow;
}

uint64_t sub_1000747D4()
{
  uint64_t result = _s7CoreP2P10TimeBitmapV14repeatingPerDWyA2C4SlotV_A3FtFZ_0(0, 240, 0, 0);
  static TimeBitmap.secondaryDiscoveryWindow = result;
  *(void *)algn_1004106D8 = v1;
  LOWORD(qword_1004106E0) = v2;
  BYTE2(qword_1004106E0) = v3;
  BYTE3(qword_1004106E0) = v4;
  BYTE4(qword_1004106E0) = v5;
  BYTE5(qword_1004106E0) = v6;
  BYTE6(qword_1004106E0) = v7;
  HIBYTE(qword_1004106E0) = v8;
  return result;
}

uint64_t *TimeBitmap.secondaryDiscoveryWindow.unsafeMutableAddressor()
{
  if (qword_100404130 != -1) {
    swift_once(&qword_100404130, sub_1000747D4);
  }
  return &static TimeBitmap.secondaryDiscoveryWindow;
}

uint64_t static TimeBitmap.secondaryDiscoveryWindow.getter()
{
  if (qword_100404130 != -1) {
    swift_once(&qword_100404130, sub_1000747D4);
  }
  return static TimeBitmap.secondaryDiscoveryWindow;
}

void *TimeBitmap.twoGHzOutOfBoundActionFrameBitmap.unsafeMutableAddressor()
{
  return &static TimeBitmap.twoGHzOutOfBoundActionFrameBitmap;
}

uint64_t static TimeBitmap.twoGHzOutOfBoundActionFrameBitmap.getter()
{
  return 0LL;
}

void *TimeBitmap.fiveGHzOutOfBoundActionFrameBitmap.unsafeMutableAddressor()
{
  return &static TimeBitmap.fiveGHzOutOfBoundActionFrameBitmap;
}

uint64_t static TimeBitmap.fiveGHzOutOfBoundActionFrameBitmap.getter()
{
  return 0LL;
}

BOOL static InfrastructureQualityOfService.< infix(_:_:)(unsigned __int8 a1, unsigned __int8 a2)
{
  return a1 < a2;
}

uint64_t NANAvailabilityEntry.UsagePreference.rawValue.getter(uint64_t result)
{
  return result;
}

_UNKNOWN **static NANAvailabilityEntry.UsagePreference.allCases.getter()
{
  return &off_1003D6E40;
}

unint64_t sub_100074928@<X0>(unint64_t *a1@<X0>, _BYTE *a2@<X8>)
{
  unint64_t result = _s7CoreP2P20NANAvailabilityEntryV15UsagePreferenceO8rawValueAESgSi_tcfC_0(*a1);
  *a2 = result;
  return result;
}

void sub_100074950(void *a1@<X8>)
{
  *a1 = *v1;
}

void sub_10007495C(void *a1@<X8>)
{
  *a1 = &off_1003D6E68;
}

BOOL sub_10007496C(unsigned __int8 *a1, unsigned __int8 *a2)
{
  return *a1 < *a2;
}

BOOL sub_100074980(unsigned __int8 *a1, unsigned __int8 *a2)
{
  return *a2 >= *a1;
}

BOOL sub_100074994(unsigned __int8 *a1, unsigned __int8 *a2)
{
  return *a1 >= *a2;
}

BOOL sub_1000749A8(unsigned __int8 *a1, unsigned __int8 *a2)
{
  return *a2 < *a1;
}

void *NANAvailabilityEntry.Control.committed.unsafeMutableAddressor()
{
  return &static NANAvailabilityEntry.Control.committed;
}

void *NANAvailabilityEntry.Control.potential.unsafeMutableAddressor()
{
  return &static NANAvailabilityEntry.Control.potential;
}

void *NANAvailabilityEntry.Control.conditional.unsafeMutableAddressor()
{
  return &static NANAvailabilityEntry.Control.conditional;
}

uint64_t NANAvailabilityEntry.Control.usagePreference.getter(unsigned int a1)
{
  return (a1 >> 3) & 3;
}

double NANAvailabilityEntry.Control.utilization.getter(unsigned int a1)
{
  return (double)((a1 >> 5) & 3) * 0.2;
}

uint64_t NANAvailabilityEntry.Control.rxNSS.getter(unsigned int a1)
{
  return (a1 >> 8) & 0xF;
}

uint64_t NANAvailabilityEntry.Control.init(from:)(void *a1)
{
  return sub_100085000(a1);
}

CoreP2P::NANAvailabilityEntry::Control __swiftcall NANAvailabilityEntry.Control.init(entryType:usagePreference:)( CoreP2P::NANAvailabilityEntry::Control entryType, CoreP2P::NANAvailabilityEntry::UsagePreference usagePreference)
{
  return (CoreP2P::NANAvailabilityEntry::Control)(entryType.rawValue | (8 * usagePreference));
}

_WORD *sub_100074A28@<X0>(_WORD *result@<X0>, _WORD *a2@<X8>)
{
  *a2 = *result;
  return result;
}

Swift::Int sub_100074A34()
{
  Swift::UInt16 v1 = *v0;
  Hasher.init(_seed:)(v3, 0LL);
  Hasher._combine(_:)(v1);
  return Hasher._finalize()();
}

void sub_100074A78()
{
}

Swift::Int sub_100074AA0(uint64_t a1)
{
  Swift::UInt16 v2 = *v1;
  Hasher.init(_seed:)(v4, a1);
  Hasher._combine(_:)(v2);
  return Hasher._finalize()();
}

uint64_t sub_100074AE0@<X0>(void *a1@<X0>, _WORD *a2@<X8>)
{
  uint64_t result = sub_100085000(a1);
  if (!v2) {
    *a2 = result;
  }
  return result;
}

uint64_t sub_100074B08(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v6 = sub_100087928();
  return RawRepresentable<>.encode(to:)(a1, a2, a3, v6);
}

_WORD *sub_100074B54@<X0>(_WORD *result@<X0>, _WORD *a2@<X8>)
{
  *a2 = *v2 | *result;
  return result;
}

_WORD *sub_100074B68@<X0>(_WORD *result@<X0>, _WORD *a2@<X8>)
{
  *a2 = *v2 & *result;
  return result;
}

_WORD *sub_100074B7C@<X0>(_WORD *result@<X0>, _WORD *a2@<X8>)
{
  *a2 = *v2 ^ *result;
  return result;
}

BOOL sub_100074B90(_WORD *a1, unsigned __int16 *a2)
{
  int v3 = *a2;
  int v4 = (unsigned __int16)*v2;
  if ((v4 & v3) != v3) {
    *uint64_t v2 = v4 | v3;
  }
  *a1 = v3;
  return (v4 & v3) != v3;
}

unsigned __int16 *sub_100074BC0@<X0>(unsigned __int16 *result@<X0>, uint64_t a2@<X8>)
{
  int v3 = *result;
  int v4 = (unsigned __int16)*v2;
  int v5 = v4 & v3;
  if ((v4 & v3) != 0) {
    *uint64_t v2 = v4 & ~(_WORD)v3;
  }
  *(_WORD *)a2 = v5;
  *(_BYTE *)(a2 + 2) = v5 == 0;
  return result;
}

unsigned __int16 *sub_100074BEC@<X0>(unsigned __int16 *result@<X0>, uint64_t a2@<X8>)
{
  int v3 = *result;
  int v4 = (unsigned __int16)*v2;
  *uint64_t v2 = v4 | v3;
  int v5 = v4 & v3;
  *(_WORD *)a2 = v5;
  *(_BYTE *)(a2 + 2) = v5 == 0;
  return result;
}

_WORD *sub_100074C10(_WORD *result)
{
  *v1 |= *result;
  return result;
}

_WORD *sub_100074C24(_WORD *result)
{
  *v1 &= *result;
  return result;
}

_WORD *sub_100074C38(_WORD *result)
{
  *v1 ^= *result;
  return result;
}

_WORD *sub_100074C4C@<X0>(_WORD *result@<X0>, _WORD *a2@<X8>)
{
  *a2 = *v2 & ~*result;
  return result;
}

BOOL sub_100074C60(unsigned __int16 *a1)
{
  return (*v1 & ~*a1) == 0;
}

BOOL sub_100074C74(_WORD *a1)
{
  return (unsigned __int16)(*v1 & *a1) == 0;
}

BOOL sub_100074C88(unsigned __int16 *a1)
{
  return (*a1 & ~*v1) == 0;
}

BOOL sub_100074C9C()
{
  return *v0 == 0;
}

_WORD *sub_100074CAC(_WORD *result)
{
  *v1 &= ~*result;
  return result;
}

_WORD *sub_100074CC0@<X0>(_WORD *result@<X0>, uint64_t a2@<X8>)
{
  *(_WORD *)a2 = *result;
  *(_BYTE *)(a2 + 2) = 0;
  return result;
}

void sub_100074CD0(_WORD *a1@<X8>)
{
  *a1 = *v1;
}

BOOL sub_100074CDC(unsigned __int16 *a1, unsigned __int16 *a2)
{
  return *a1 == *a2;
}

CoreP2P::WiFiInterfaceLinkState_optional __swiftcall WiFiInterfaceLinkState.init(rawValue:)(Swift::UInt8 rawValue)
{
  if (rawValue == 1) {
    v1.value = CoreP2P_WiFiInterfaceLinkState_linkUp;
  }
  else {
    v1.value = CoreP2P_WiFiInterfaceLinkState_unknownDefault;
  }
  if (rawValue) {
    return v1;
  }
  else {
    return 0;
  }
}

uint64_t AWDLSoftAPChannelChangedEvent.enabled.getter(char a1)
{
  return a1 & 1;
}

_BYTE *sub_100074D14@<X0>(_BYTE *result@<X0>, char *a2@<X8>)
{
  if (*result == 1) {
    char v2 = 1;
  }
  else {
    char v2 = 2;
  }
  if (*result) {
    char v3 = v2;
  }
  else {
    char v3 = 0;
  }
  *a2 = v3;
  return result;
}

uint64_t NANAvailabilityEntry.BandChannelEntries.Control.entriesType.setter(char a1)
{
  uint64_t result = a1 & 1;
  unint64_t v3 = *v1;
  if ((v3 & 1) != 0)
  {
    if ((_DWORD)result) {
      return result;
    }
    goto LABEL_5;
  }

  if ((_DWORD)result)
  {
LABEL_5:
    char v4 = sub_1001A05C4(result, 0LL, 1LL);
    uint64_t result = sub_1001A05B0(v3 >> 4, 4LL, 4LL);
    _BYTE *v1 = v4 | v3 & 2 | result;
  }

  return result;
}

void *NANAvailabilityEntry.BandChannelEntries.Control.nonContiguousBandwidth.unsafeMutableAddressor()
{
  return &static NANAvailabilityEntry.BandChannelEntries.Control.nonContiguousBandwidth;
}

uint64_t NANAvailabilityEntry.BandChannelEntries.Control.numberOfEntries.getter(unsigned __int8 a1)
{
  return a1 >> 4;
}

CoreP2P::NANAvailabilityEntry::BandChannelEntries::Control_optional __swiftcall NANAvailabilityEntry.BandChannelEntries.Control.init(entriesType:nonContiguousBandwidth:numberOfEntries:)( CoreP2P::NANAvailabilityEntry::BandChannelEntries::Control::EntriesType entriesType, Swift::Bool nonContiguousBandwidth, Swift::Int numberOfEntries)
{
  if (numberOfEntries > 15)
  {
    unsigned __int8 v7 = 0;
    __int16 v8 = 1;
  }

  else
  {
    char v5 = sub_1001A05C4(entriesType & 1, 0LL, 1LL);
    char v6 = sub_1001A05B0(numberOfEntries, 4LL, 4LL);
    __int16 v8 = 0;
    if (nonContiguousBandwidth) {
      char v10 = 2;
    }
    else {
      char v10 = 0;
    }
    unsigned __int8 v7 = v5 | v10 | v6;
  }

  return (CoreP2P::NANAvailabilityEntry::BandChannelEntries::Control_optional)(v7 | (unsigned __int16)(v8 << 8));
}

uint64_t (*NANAvailabilityEntry.BandChannelEntries.Control.entriesType.modify( uint64_t a1))(uint64_t a1, char a2)
{
  *(void *)a1 = v1;
  *(_BYTE *)(a1 + 8) = *v1 & 1;
  return sub_100074E98;
}

uint64_t sub_100074E98(uint64_t a1, char a2)
{
  char v2 = *(_BYTE **)a1;
  uint64_t result = *(unsigned __int8 *)(a1 + 8);
  unint64_t v4 = *v2;
  if ((a2 & 1) != 0)
  {
    if ((v4 & 1) != 0)
    {
      if ((result & 1) != 0) {
        return result;
      }
    }

    else if ((result & 1) == 0)
    {
      return result;
    }

    char v5 = sub_1001A05C4(result, 0LL, 1LL);
    uint64_t result = sub_1001A05B0(v4 >> 4, 4LL, 4LL);
LABEL_12:
    *char v2 = v5 | v4 & 2 | result;
    return result;
  }

  if ((v4 & 1) != 0)
  {
    if ((result & 1) != 0) {
      return result;
    }
    goto LABEL_11;
  }

  if ((_DWORD)result)
  {
LABEL_11:
    char v5 = sub_1001A05C4(result, 0LL, 1LL);
    uint64_t result = sub_1001A05B0(v4 >> 4, 4LL, 4LL);
    goto LABEL_12;
  }

  return result;
}

void *NANAvailabilityEntry.BandChannelEntries.Control.maximumNumberOfEntries.unsafeMutableAddressor()
{
  return &static NANAvailabilityEntry.BandChannelEntries.Control.maximumNumberOfEntries;
}

uint64_t NANAvailabilityEntry.BandChannelEntries.Control.numberOfEntries.setter(uint64_t result)
{
  unint64_t v3 = *v1;
  if (result != v3 >> 4)
  {
    uint64_t v4 = result;
    if ((v3 & 1) != 0)
    {
      if (result > 15) {
        goto LABEL_10;
      }
      unsigned __int8 v5 = 1;
    }

    else
    {
      if (result > 15)
      {
        __break(1u);
LABEL_10:
        __break(1u);
        uint64_t result = swift_errorRelease(v2);
        __break(1u);
        return result;
      }

      unsigned __int8 v5 = 0;
    }

    char v6 = sub_1001A05C4(v5, 0LL, 1LL);
    uint64_t result = sub_1001A05B0(v4, 4LL, 4LL);
    _BYTE *v1 = v6 | result | v3 & 2;
  }

  return result;
}

uint64_t (*NANAvailabilityEntry.BandChannelEntries.Control.numberOfEntries.modify( unint64_t *a1))(uint64_t result, char a2)
{
  *a1 = (unint64_t)*v1 >> 4;
  a1[1] = (unint64_t)v1;
  return sub_100075048;
}

uint64_t sub_100075048(uint64_t result, char a2)
{
  uint64_t v3 = *(void *)result;
  uint64_t v4 = *(_BYTE **)(result + 8);
  unint64_t v5 = *v4;
  if ((a2 & 1) != 0)
  {
    if (*(void *)result == v5 >> 4) {
      return result;
    }
    if ((v5 & 1) != 0)
    {
      if (v3 > 15)
      {
LABEL_18:
        __break(1u);
        goto LABEL_19;
      }

      unsigned __int8 v6 = 1;
    }

    else
    {
      if (v3 > 15)
      {
        __break(1u);
LABEL_17:
        __break(1u);
        goto LABEL_18;
      }

      unsigned __int8 v6 = 0;
    }
  }

  else
  {
    if (*(void *)result == v5 >> 4) {
      return result;
    }
    if ((v5 & 1) != 0)
    {
      if (v3 > 15)
      {
LABEL_19:
        __break(1u);
        uint64_t result = swift_errorRelease(v2);
        __break(1u);
        return result;
      }

      unsigned __int8 v6 = 1;
    }

    else
    {
      if (v3 > 15) {
        goto LABEL_17;
      }
      unsigned __int8 v6 = 0;
    }
  }

  char v7 = sub_1001A05C4(v6, 0LL, 1LL);
  uint64_t result = sub_1001A05B0(v3, 4LL, 4LL);
  _BYTE *v4 = v7 | result | v5 & 2;
  return result;
}

CoreP2P::NANAvailabilityEntry::BandChannelEntries::Control __swiftcall NANAvailabilityEntry.BandChannelEntries.Control.init(entriesType:)( CoreP2P::NANAvailabilityEntry::BandChannelEntries::Control::EntriesType entriesType)
{
  char v1 = sub_1001A05C4(entriesType & 1, 0LL, 1LL);
  return (CoreP2P::NANAvailabilityEntry::BandChannelEntries::Control)(sub_1001A05B0(1LL, 4LL, 4LL) | v1);
}

_BYTE *sub_1000751CC@<X0>(_BYTE *result@<X0>, _BYTE *a2@<X8>)
{
  *a2 = *result;
  return result;
}

uint64_t sub_1000751D8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v6 = sub_100087A90();
  return RawRepresentable<>.init(from:)(a1, a2, a3, v6);
}

uint64_t sub_100075234(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v6 = sub_100087A90();
  return RawRepresentable<>.encode(to:)(a1, a2, a3, v6);
}

_BYTE *sub_100075280@<X0>(_BYTE *result@<X0>, _BYTE *a2@<X8>)
{
  *a2 = *v2 | *result;
  return result;
}

_BYTE *sub_100075294@<X0>(_BYTE *result@<X0>, _BYTE *a2@<X8>)
{
  *a2 = *v2 & *result;
  return result;
}

_BYTE *sub_1000752A8@<X0>(_BYTE *result@<X0>, _BYTE *a2@<X8>)
{
  *a2 = *v2 ^ *result;
  return result;
}

BOOL sub_1000752BC(_BYTE *a1, unsigned __int8 *a2)
{
  int v3 = *a2;
  int v4 = *v2;
  if ((v4 & v3) != v3) {
    *uint64_t v2 = v4 | v3;
  }
  *a1 = v3;
  return (v4 & v3) != v3;
}

unsigned __int8 *sub_1000752EC@<X0>(unsigned __int8 *result@<X0>, _BYTE *a2@<X8>)
{
  int v3 = *result;
  int v4 = *v2;
  int v5 = v4 & v3;
  if ((v4 & v3) != 0) {
    *uint64_t v2 = v4 & ~(_BYTE)v3;
  }
  *a2 = v5;
  a2[1] = v5 == 0;
  return result;
}

unsigned __int8 *sub_100075318@<X0>(unsigned __int8 *result@<X0>, _BYTE *a2@<X8>)
{
  int v3 = *result;
  int v4 = *v2;
  *uint64_t v2 = v4 | v3;
  int v5 = v4 & v3;
  *a2 = v5;
  a2[1] = v5 == 0;
  return result;
}

_BYTE *sub_10007533C(_BYTE *result)
{
  *v1 |= *result;
  return result;
}

_BYTE *sub_100075350(_BYTE *result)
{
  *v1 &= *result;
  return result;
}

_BYTE *sub_100075364(_BYTE *result)
{
  *v1 ^= *result;
  return result;
}

_BYTE *sub_100075378@<X0>(_BYTE *result@<X0>, _BYTE *a2@<X8>)
{
  *a2 = *v2 & ~*result;
  return result;
}

BOOL sub_10007538C(unsigned __int8 *a1)
{
  return (*v1 & ~*a1) == 0;
}

BOOL sub_1000753A0(_BYTE *a1)
{
  return (*v1 & *a1) == 0;
}

BOOL sub_1000753B4(unsigned __int8 *a1)
{
  return (*a1 & ~*v1) == 0;
}

BOOL sub_1000753C8()
{
  return *v0 == 0;
}

_BYTE *sub_1000753D8(_BYTE *result)
{
  *v1 &= ~*result;
  return result;
}

unsigned __int8 *sub_1000753EC@<X0>(unsigned __int8 *result@<X0>, _WORD *a2@<X8>)
{
  *a2 = *result;
  return result;
}

uint64_t sub_1000753FC()
{
  uint64_t v1 = *((void *)v0 + 1);
  unsigned __int8 v2 = v0[16];
  unint64_t v3 = *v0;
  swift_bridgeObjectRetain(v1);
  if ((v2 & 1) != 0)
  {
    if ((v3 & 1) == 0)
    {
      char v4 = sub_1001A05C4(1u, 0LL, 1LL);
      LOBYTE(v3) = v4 | v3 & 2 | sub_1001A05B0(v3 >> 4, 4LL, 4LL);
      unsigned __int8 *v0 = v3;
    }

    unint64_t v5 = *(void *)(v1 + 16);
    uint64_t result = swift_bridgeObjectRelease(v1);
    if (v5 != v3 >> 4)
    {
      if ((v3 & 1) != 0)
      {
        if (v5 <= 0xF)
        {
          unsigned __int8 v7 = 1;
          goto LABEL_18;
        }

        goto LABEL_22;
      }

      if (v5 <= 0xF)
      {
        unsigned __int8 v7 = 0;
LABEL_18:
        char v9 = sub_1001A05C4(v7, 0LL, 1LL);
        uint64_t result = sub_1001A05B0(v5, 4LL, 4LL);
        unsigned __int8 *v0 = v9 | v3 & 2 | result;
        return result;
      }

      __break(1u);
LABEL_21:
      __break(1u);
LABEL_22:
      __break(1u);
      goto LABEL_23;
    }
  }

  else
  {
    if ((v3 & 1) != 0)
    {
      char v8 = sub_1001A05C4(0, 0LL, 1LL);
      LOBYTE(v3) = v8 | v3 & 2 | sub_1001A05B0(v3 >> 4, 4LL, 4LL);
      unsigned __int8 *v0 = v3;
    }

    unint64_t v5 = *(void *)(v1 + 16);
    uint64_t result = swift_bridgeObjectRelease(v1);
    if (v5 != v3 >> 4)
    {
      if ((v3 & 1) != 0)
      {
        if (v5 <= 0xF)
        {
          unsigned __int8 v7 = 1;
          goto LABEL_18;
        }

uint64_t NANAvailabilityEntry.BandChannelEntries.entries.getter(uint64_t a1, uint64_t a2)
{
  return swift_bridgeObjectRetain(a2);
}

uint64_t NANAvailabilityEntry.BandChannelEntries.entries.setter(uint64_t a1, char a2)
{
  *(void *)(v2 + 8) = a1;
  *(_BYTE *)(v2 + 16) = a2 & 1;
  return sub_1000753FC();
}

uint64_t (*NANAvailabilityEntry.BandChannelEntries.entries.modify( void *a1))(uint64_t a1, char a2)
{
  *a1 = v1;
  return sub_100075648;
}

uint64_t sub_100075648(uint64_t a1, char a2)
{
  if ((a2 & 1) == 0) {
    return sub_1000753FC();
  }
  return result;
}

Swift::Void __swiftcall NANAvailabilityEntry.BandChannelEntries.add(channel:)(CoreP2P::NANBitmap::Channel channel)
{
  if (*(_BYTE *)(v1 + 16) == 1)
  {
    Swift::Bool is_nil = channel.auxiliaryChannelBitmap.is_nil;
    uint64_t v3 = *(void *)&channel.operatingClass;
    char v4 = *(void **)(v1 + 8);
    uint64_t v5 = swift_bridgeObjectRetain(v4);
    unint64_t v6 = v4;
    if ((swift_isUniquelyReferenced_nonNull_native(v5) & 1) == 0) {
      unint64_t v6 = sub_1000A6F98(0LL, v4[2] + 1LL, 1, v4);
    }
    unint64_t v8 = v6[2];
    unint64_t v7 = v6[3];
    if (v8 >= v7 >> 1) {
      unint64_t v6 = sub_1000A6F98((void *)(v7 > 1), v8 + 1, 1, v6);
    }
    v6[2] = v8 + 1;
    char v9 = (char *)v6 + 10 * v8;
    v9[32] = v3;
    *((_WORD *)v9 + 17) = WORD1(v3);
    v9[36] = BYTE4(v3);
    *((_WORD *)v9 + 19) = HIWORD(v3);
    v9[40] = is_nil;
    swift_bridgeObjectRelease(v4);
    *(void *)(v1 + 8) = v6;
    *(_BYTE *)(v1 + 16) = 1;
    sub_1000753FC();
  }

void NANAvailabilityEntry.BandChannelEntries.hash(into:)(uint64_t a1, Swift::UInt8 a2, uint64_t a3, char a4)
{
  if ((a4 & 1) != 0)
  {
    sub_100082AF8(a1, a3);
  }

  else
  {
    Swift::UInt v7 = *(void *)(a3 + 16);
    Hasher._combine(_:)(v7);
    if (v7)
    {
      unint64_t v8 = (Swift::UInt8 *)(a3 + 32);
      do
      {
        Swift::UInt8 v9 = *v8++;
        Hasher._combine(_:)(v9);
        --v7;
      }

      while (v7);
    }
  }

uint64_t static NANAvailabilityEntry.BandChannelEntries.__derived_struct_equals(_:_:)( char a1, uint64_t a2, char a3, char a4, uint64_t a5, char a6)
{
  if (a1 != a4) {
    return 0LL;
  }
  if ((a3 & 1) != 0)
  {
    if ((a6 & 1) != 0 && (sub_10007A3AC(a2, a5) & 1) != 0) {
      return 1LL;
    }
  }

  else if ((a6 & 1) == 0 && sub_10007A464(a2, a5))
  {
    return 1LL;
  }

  return 0LL;
}

Swift::Int NANAvailabilityEntry.BandChannelEntries.hashValue.getter(Swift::UInt8 a1, uint64_t a2, char a3)
{
  if ((a3 & 1) != 0)
  {
    sub_100082AF8((uint64_t)v10, a2);
  }

  else
  {
    Swift::UInt v6 = *(void *)(a2 + 16);
    Hasher._combine(_:)(v6);
    if (v6)
    {
      Swift::UInt v7 = (Swift::UInt8 *)(a2 + 32);
      do
      {
        Swift::UInt8 v8 = *v7++;
        Hasher._combine(_:)(v8);
        --v6;
      }

      while (v6);
    }
  }

  return Hasher._finalize()();
}

Swift::Int sub_1000758E8()
{
  return NANAvailabilityEntry.BandChannelEntries.hashValue.getter( *(_BYTE *)v0,  *(void *)(v0 + 8),  *(_BYTE *)(v0 + 16));
}

void sub_1000758F8(uint64_t a1)
{
}

Swift::Int sub_100075908(uint64_t a1)
{
  uint64_t v2 = *(void *)(v1 + 8);
  char v3 = *(_BYTE *)(v1 + 16);
  Swift::UInt8 v4 = *(_BYTE *)v1;
  Hasher.init(_seed:)(v9, a1);
  Hasher._combine(_:)(v4);
  if ((v3 & 1) != 0)
  {
    sub_100082AF8((uint64_t)v9, v2);
  }

  else
  {
    Swift::UInt v5 = *(void *)(v2 + 16);
    Hasher._combine(_:)(v5);
    if (v5)
    {
      Swift::UInt v6 = (Swift::UInt8 *)(v2 + 32);
      do
      {
        Swift::UInt8 v7 = *v6++;
        Hasher._combine(_:)(v7);
        --v5;
      }

      while (v5);
    }
  }

  return Hasher._finalize()();
}

uint64_t sub_100075998@<X0>(void *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t result = sub_1000861B8(a1);
  if (!v2)
  {
    *(_BYTE *)a2 = result;
    *(void *)(a2 + 8) = v5;
    *(_BYTE *)(a2 + 16) = v6 & 1;
  }

  return result;
}

uint64_t NANAvailabilityEntry.BandChannelEntries.init(from:)(void *a1)
{
  return sub_1000861B8(a1);
}

uint64_t sub_1000759EC(void *a1)
{
  return NANAvailabilityEntry.BandChannelEntries.encode(to:)(a1, *(_BYTE *)v1, *(void *)(v1 + 8), *(_BYTE *)(v1 + 16));
}

uint64_t NANAvailabilityEntry.BandChannelEntries.encode(to:)(void *a1, char a2, uint64_t a3, char a4)
{
  uint64_t v8 = a1[3];
  uint64_t v9 = a1[4];
  sub_100021104(a1, v8);
  dispatch thunk of Encoder.unkeyedContainer()(v21, v8, v9);
  LOBYTE(v24) = a2;
  uint64_t v10 = v22;
  uint64_t v11 = v23;
  sub_1000237C8((uint64_t)v21, v22);
  unint64_t v12 = sub_100086B64();
  dispatch thunk of UnkeyedEncodingContainer.encode<A>(_:)( &v24,  &type metadata for NANAvailabilityEntry.BandChannelEntries.Control,  v12,  v10,  v11);
  if (!v4)
  {
    if ((a4 & 1) != 0)
    {
      uint64_t v24 = a3;
      uint64_t v13 = v22;
      uint64_t v14 = v23;
      sub_1000237C8((uint64_t)v21, v22);
      unsigned __int16 v15 = &qword_100406500;
      uint64_t v16 = sub_100002274(&qword_100406500);
      unsigned __int16 v17 = (unint64_t *)&unk_100406508;
      unsigned __int16 v18 = sub_100086BA8;
    }

    else
    {
      uint64_t v24 = a3;
      uint64_t v13 = v22;
      uint64_t v14 = v23;
      sub_1000237C8((uint64_t)v21, v22);
      unsigned __int16 v15 = &qword_100406518;
      uint64_t v16 = sub_100002274(&qword_100406518);
      unsigned __int16 v17 = (unint64_t *)&unk_100406520;
      unsigned __int16 v18 = sub_100086BEC;
    }

    uint64_t v19 = sub_100087780(v17, v15, (void (*)(void))v18, (uint64_t)&protocol conformance descriptor for <A> [A]);
    dispatch thunk of UnkeyedEncodingContainer.encode<A>(_:)(&v24, v16, v19, v13, v14);
  }

  return sub_100002AC4(v21);
}

uint64_t sub_100075B74(unsigned __int8 *a1, unsigned __int8 *a2)
{
  if (*a1 == *a2)
  {
    uint64_t v4 = *((void *)a1 + 1);
    uint64_t v5 = *((void *)a2 + 1);
    int v6 = a2[16];
    if ((a1[16] & 1) != 0)
    {
      if (v6 && (sub_10007A3AC(v4, v5) & 1) != 0) {
        return 1LL;
      }
    }

    else if ((v6 & 1) == 0 && sub_10007A464(v4, v5))
    {
      return 1LL;
    }
  }

  return 0LL;
}

uint64_t IEEE80211InformationElement.RSNCapability.version.getter()
{
  return *v0;
}

uint64_t NANAvailabilityEntry.timeBitmap.getter()
{
  uint64_t v1 = v0[1];
  sub_100058430(v1, v0[2], v0[3]);
  return v1;
}

uint64_t NANAvailabilityEntry.timeBitmap.setter(uint64_t a1, uint64_t a2, unint64_t a3)
{
  uint64_t result = sub_100057CA0(*((void *)v3 + 1), *((void *)v3 + 2), *((void *)v3 + 3));
  *((void *)v3 + 1) = a1;
  *((void *)v3 + 2) = a2;
  *((void *)v3 + 3) = a3;
  __int16 v8 = *v3;
  if (a3 >> 60 == 15)
  {
    if ((*v3 & 0x1000) == 0) {
      return result;
    }
    __int16 v9 = v8 & 0xEFFF;
  }

  else
  {
    if ((*v3 & 0x1000) != 0) {
      return result;
    }
    __int16 v9 = v8 | 0x1000;
  }

  *char v3 = v9;
  return result;
}

__int16 **(*NANAvailabilityEntry.timeBitmap.modify(void *a1))(__int16 **result, char a2)
{
  *a1 = v1;
  return sub_100075CA4;
}

__int16 **sub_100075CA4(__int16 **result, char a2)
{
  if ((a2 & 1) == 0)
  {
    uint64_t v2 = *result;
    __int16 v3 = **result;
    if (*((void *)*result + 3) >> 60 == 15LL)
    {
      if ((**result & 0x1000) != 0) {
        *uint64_t v2 = v3 & 0xEFFF;
      }
    }

    else if ((**result & 0x1000) == 0)
    {
      *uint64_t v2 = v3 | 0x1000;
    }
  }

  return result;
}

uint64_t NANAvailabilityEntry.bandChannelEntries.getter()
{
  uint64_t v1 = *(void *)(v0 + 40);
  uint64_t v2 = *(unsigned __int8 *)(v0 + 32);
  swift_bridgeObjectRetain(v1);
  return v2;
}

uint64_t NANAvailabilityEntry.bandChannelEntries.setter(char a1, uint64_t a2, char a3)
{
  uint64_t result = swift_bridgeObjectRelease(*(void *)(v3 + 40));
  *(_BYTE *)(v3 + 32) = a1;
  *(void *)(v3 + 40) = a2;
  *(_BYTE *)(v3 + 48) = a3 & 1;
  return result;
}

uint64_t (*IEEE80211InformationElement.PreAssociationSecurityNegotiationParameters.ephemeralPublicKey.modify())()
{
  return NANBitmap.Channel.operatingClass.getter;
}

uint64_t NANAvailabilityEntry.init(control:timeBitmap:bandChannelEntries:)@<X0>( uint64_t result@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, unint64_t a4@<X3>, char a5@<W4>, uint64_t a6@<X5>, char a7@<W6>, uint64_t a8@<X8>)
{
  *(_WORD *)a8 = result & 0xEFFF | ((a4 >> 60 != 15) << 12);
  *(void *)(a8 + 8) = a2;
  *(void *)(a8 + 16) = a3;
  *(void *)(a8 + 24) = a4;
  *(_BYTE *)(a8 + 32) = a5;
  *(void *)(a8 + 40) = a6;
  *(_BYTE *)(a8 + 48) = a7 & 1;
  return result;
}

double static NANAvailabilityEntry.potentialEntry(on:with:)@<D0>( uint64_t a1@<X0>, char a2@<W1>, unsigned __int8 a3@<W2>, uint64_t a4@<X8>)
{
  char v8 = sub_1001A05C4(1u, 0LL, 1LL);
  char v9 = sub_1001A05B0(1LL, 4LL, 4LL) | v8;
  uint64_t v10 = sub_100002274(&qword_10040F270);
  uint64_t v11 = swift_allocObject(v10, 42LL, 7LL);
  *(void *)&double result = 1LL;
  *(_OWORD *)(v11 + 16) = xmmword_100339900;
  *(_BYTE *)(v11 + 32) = a1;
  *(_WORD *)(v11 + 34) = WORD1(a1);
  *(_BYTE *)(v11 + 36) = BYTE4(a1);
  *(_WORD *)(v11 + 38) = HIWORD(a1);
  *(_BYTE *)(v11 + 40) = a2 & 1;
  *(_WORD *)a4 = (8 * a3) | 2;
  *(void *)(a4 + 8) = 0LL;
  *(void *)(a4 + 16) = 0LL;
  *(void *)(a4 + 24) = 0xF000000000000000LL;
  *(_BYTE *)(a4 + 32) = v9;
  *(void *)(a4 + 40) = v11;
  *(_BYTE *)(a4 + 48) = 1;
  return result;
}

uint64_t static NANAvailabilityEntry.committedEntry(on:for:)@<X0>( uint64_t a1@<X0>, char a2@<W1>, unsigned __int16 a3@<W2>, uint64_t a4@<X3>, unint64_t a5@<X4>, uint64_t a6@<X8>)
{
  char v12 = sub_1001A05C4(1u, 0LL, 1LL);
  char v13 = sub_1001A05B0(1LL, 4LL, 4LL) | v12;
  uint64_t v14 = sub_100002274(&qword_10040F270);
  uint64_t v15 = swift_allocObject(v14, 42LL, 7LL);
  *(_OWORD *)(v15 + 16) = xmmword_100339900;
  *(_BYTE *)(v15 + 32) = a1;
  *(_WORD *)(v15 + 34) = WORD1(a1);
  *(_BYTE *)(v15 + 36) = BYTE4(a1);
  *(_WORD *)(v15 + 38) = HIWORD(a1);
  *(_BYTE *)(v15 + 40) = a2 & 1;
  uint64_t result = sub_100020AFC(a4, a5);
  *(_WORD *)a6 = 4097;
  *(void *)(a6 + 8) = a3;
  *(void *)(a6 + 16) = a4;
  *(void *)(a6 + 24) = a5;
  *(_BYTE *)(a6 + 32) = v13;
  *(void *)(a6 + 40) = v15;
  *(_BYTE *)(a6 + 48) = 1;
  return result;
}

void NANAvailabilityEntry.hash(into:)(uint64_t a1)
{
  uint64_t v2 = v1;
  Hasher._combine(_:)(*(_WORD *)v2);
  unint64_t v4 = *(void *)(v2 + 24);
  if (v4 >> 60 == 15)
  {
    Hasher._combine(_:)(0);
  }

  else
  {
    uint64_t v6 = *(void *)(v2 + 8);
    uint64_t v5 = *(void *)(v2 + 16);
    Hasher._combine(_:)(1u);
    Hasher._combine(_:)(v6);
    sub_100020AFC(v5, v4);
    Data.hash(into:)(a1, v5, v4);
    sub_100057CA0(v6, v5, v4);
  }

  uint64_t v7 = *(void *)(v2 + 40);
  char v8 = *(_BYTE *)(v2 + 48);
  Hasher._combine(_:)(*(_BYTE *)(v2 + 32));
  if ((v8 & 1) != 0)
  {
    sub_100082AF8(a1, v7);
  }

  else
  {
    Swift::UInt v9 = *(void *)(v7 + 16);
    Hasher._combine(_:)(v9);
    if (v9)
    {
      uint64_t v10 = (Swift::UInt8 *)(v7 + 32);
      do
      {
        Swift::UInt8 v11 = *v10++;
        Hasher._combine(_:)(v11);
        --v9;
      }

      while (v9);
    }
  }

Swift::Int NANAvailabilityEntry.hashValue.getter()
{
  return Hasher._finalize()();
}

Swift::Int sub_1000760F0(uint64_t a1)
{
  return Hasher._finalize()();
}

double NANAvailabilityEntry.init(from:)@<D0>(void *a1@<X0>, uint64_t a2@<X8>)
{
  if (!v2)
  {
    __int128 v5 = v6[1];
    *(_OWORD *)a2 = v6[0];
    *(_OWORD *)(a2 + 16) = v5;
    double result = *(double *)&v7;
    *(_OWORD *)(a2 + 32) = v7;
    *(_BYTE *)(a2 + 48) = v8;
  }

  return result;
}

uint64_t sub_100076174(void *a1)
{
  return NANAvailabilityEntry.encode(to:)(a1);
}

uint64_t NANAvailabilityEntry.encode(to:)(void *a1)
{
  uint64_t v3 = v1;
  uint64_t v4 = a1[3];
  uint64_t v5 = a1[4];
  sub_100021104(a1, v4);
  dispatch thunk of Encoder.unkeyedContainer()(v21, v4, v5);
  unint64_t v6 = sub_10000D9B0((uint64_t)_swiftEmptyArrayStorage);
  uint64_t v7 = type metadata accessor for BinaryEncoder();
  uint64_t v8 = swift_allocObject(v7, 40LL, 7LL);
  *(_OWORD *)(v8 + 16) = xmmword_1003398F0;
  *(void *)(v8 + 32) = v6;
  v17[0] = *(_WORD *)v3;
  uint64_t v19 = v7;
  uint64_t v9 = sub_10000AF70( (unint64_t *)&qword_1004064B0,  (uint64_t (*)(uint64_t))type metadata accessor for BinaryEncoder,  (uint64_t)&protocol conformance descriptor for BinaryEncoder);
  uint64_t v20 = v9;
  v18[0] = v8;
  unint64_t v10 = sub_100086C30();
  swift_retain();
  dispatch thunk of Encodable.encode(to:)(v18, &type metadata for NANAvailabilityEntry.Control, v10);
  if (!v2)
  {
    sub_100002AC4(v18);
    sub_100086C74(v3 + 8, (uint64_t)v22);
    uint64_t v19 = v7;
    uint64_t v20 = v9;
    v18[0] = v8;
    sub_100086C74((uint64_t)v22, (uint64_t)v17);
    swift_retain();
    sub_100086CBC((uint64_t)v22);
    uint64_t v11 = sub_100002274(&qword_100406538);
    unint64_t v12 = sub_100086CE8();
    Optional<A>.encode(to:)(v18, v11, v12);
    sub_100002AC4(v18);
    sub_100086D2C((uint64_t)v22);
    uint64_t v14 = *(void *)(v3 + 40);
    uint64_t v15 = *(unsigned __int8 *)(v3 + 48);
    char v16 = *(_BYTE *)(v3 + 32);
    uint64_t v19 = v7;
    uint64_t v20 = v9;
    v18[0] = v8;
    swift_retain();
    swift_bridgeObjectRetain(v14);
    NANAvailabilityEntry.BandChannelEntries.encode(to:)(v18, v16, v14, v15);
    sub_100002AC4(v18);
    swift_bridgeObjectRelease(v14);
    swift_beginAccess(v8 + 16, v18, 0LL, 0LL);
    __asm { BR              X12 }
  }

  sub_100002AC4(v18);
  swift_release(v8);
  return sub_100002AC4(v21);
}

void sub_1000763F4( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, __int128 a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, char a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24)
{
  uint64_t v27 = BYTE6(v24);
  uint64_t v28 = a23;
  uint64_t v29 = a24;
  sub_1000237C8((uint64_t)&a20, a23);
  dispatch thunk of UnkeyedEncodingContainer.encode(_:)(v27, v28, v29);
  if (!v26)
  {
    a13 = *(_OWORD *)(v25 + 16);
    uint64_t v30 = a23;
    uint64_t v31 = a24;
    sub_1000237C8((uint64_t)&a20, a23);
    unint64_t v32 = sub_10005CD78();
    dispatch thunk of UnkeyedEncodingContainer.encode<A>(_:)(&a13, &type metadata for Data, v32, v30, v31);
  }

  JUMPOUT(0x1000762ACLL);
}

uint64_t sub_100076540(uint64_t a1, uint64_t a2)
{
  __int128 v2 = *(_OWORD *)(a1 + 16);
  v5[0] = *(_OWORD *)a1;
  v5[1] = v2;
  v5[2] = *(_OWORD *)(a1 + 32);
  char v6 = *(_BYTE *)(a1 + 48);
  __int128 v3 = *(_OWORD *)(a2 + 16);
  v7[0] = *(_OWORD *)a2;
  v7[1] = v3;
  v7[2] = *(_OWORD *)(a2 + 32);
  char v8 = *(_BYTE *)(a2 + 48);
  return _s7CoreP2P20NANAvailabilityEntryV23__derived_struct_equalsySbAC_ACtFZ_0( (unsigned __int16 *)v5,  (unsigned __int16 *)v7) & 1;
}

uint64_t NANAttribute.Availability.description.getter(unsigned int a1, unint64_t a2)
{
  unsigned int v4 = a1 & 0xFFFF00FF;
  swift_bridgeObjectRetain(a2);
  uint64_t v5 = sub_100084CF0(a2, v4, a2);
  swift_bridgeObjectRelease(a2);
  uint64_t v6 = sub_100002274((uint64_t *)&unk_100410510);
  uint64_t v7 = sub_1000572E4(&qword_10040FEE0, (uint64_t *)&unk_100410510, (uint64_t)&protocol conformance descriptor for [A]);
  uint64_t v8 = BidirectionalCollection<>.joined(separator:)(32LL, 0xE100000000000000LL, v6, v7);
  unint64_t v10 = v9;
  swift_bridgeObjectRelease(v5);
  int v11 = HIWORD(a1) & 0xF;
  if (v11 == 1)
  {
    unint64_t v12 = 0xE900000000000079LL;
    uint64_t v13 = 0x7261646E6F636573LL;
  }

  else if (v11)
  {
    uint64_t v13 = dispatch thunk of CustomStringConvertible.description.getter( &type metadata for UInt8,  &protocol witness table for UInt8);
    unint64_t v12 = v14;
  }

  else
  {
    unint64_t v12 = 0xE700000000000000LL;
    uint64_t v13 = 0x7972616D697270LL;
  }

  unint64_t v15 = v12;
  String.append(_:)(*(Swift::String *)&v13);
  swift_bridgeObjectRelease(v12);
  v16._countAndFlagsBits = 8250LL;
  v16._object = (void *)0xE200000000000000LL;
  String.append(_:)(v16);
  v17._countAndFlagsBits = v8;
  v17._object = v10;
  String.append(_:)(v17);
  swift_bridgeObjectRelease(v10);
  v18._countAndFlagsBits = 93LL;
  v18._object = (void *)0xE100000000000000LL;
  String.append(_:)(v18);
  return 91LL;
}

void sub_100076744(unsigned __int16 *a1@<X0>, int a2@<W1>, unint64_t a3@<X2>, uint64_t *a4@<X8>)
{
  uint64_t v57 = a4;
  uint64_t v7 = type metadata accessor for Mirror(0LL);
  uint64_t v8 = *(void *)(v7 - 8);
  __chkstk_darwin(v7);
  unint64_t v10 = (char *)&v55 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  unsigned int v11 = *a1;
  uint64_t v12 = *((void *)a1 + 5);
  if ((v11 & 7) != 2)
  {
    BOOL v13 = (v11 & 7) != 1 || *((_BYTE *)a1 + 48) == 0;
    if (!v13 && *(void *)(v12 + 16) == 1LL)
    {
      uint64_t v14 = *((void *)a1 + 1);
      uint64_t v56 = *((void *)a1 + 2);
      unint64_t v15 = *((void *)a1 + 3);
      unint64_t v16 = NANBitmap.Channel.channel.getter(*(unsigned __int8 *)(v12 + 32) | ((unint64_t)*(unsigned __int16 *)(v12 + 34) << 16) | ((unint64_t)*(unsigned __int8 *)(v12 + 36) << 32) | ((unint64_t)*(unsigned __int16 *)(v12 + 38) << 48));
      if ((v16 & 0xFF00000000LL) != 0x300000000LL && v15 >> 60 != 15)
      {
        unint64_t v18 = v16;
        uint64_t v62 = 60LL;
        unint64_t v63 = 0xE100000000000000LL;
        uint64_t v19 = v56;
        sub_100058430(v14, v56, v15);
        v20._countAndFlagsBits = Channel.description.getter(v18 & 0xFFFFFFFFFFFFLL);
        object = v20._object;
        String.append(_:)(v20);
        swift_bridgeObjectRelease(object);
        v22._countAndFlagsBits = 8250LL;
        v22._object = (void *)0xE200000000000000LL;
        String.append(_:)(v22);
        v23._countAndFlagsBits = NANBitmap.Time.description.getter(v14, v19, v15);
        uint64_t v24 = v23._object;
        String.append(_:)(v23);
        swift_bridgeObjectRelease(v24);
        v25._countAndFlagsBits = 62LL;
        v25._object = (void *)0xE100000000000000LL;
        String.append(_:)(v25);
        sub_100057CA0(v14, v19, v15);
LABEL_30:
        uint64_t v44 = v62;
        unint64_t v46 = v63;
        goto LABEL_31;
      }
    }

uint64_t sub_100076B9C()
{
  return NANAttribute.Availability.description.getter(*v0 | (*((unsigned __int16 *)v0 + 1) << 16), *((void *)v0 + 1));
}

void *static Array<A>.potentialAvailability(using:supportsSimultaneousDualBand:for:)( char a1, char a2, uint64_t a3)
{
  uint64_t v33 = _swiftEmptyArrayStorage;
  unsigned __int8 v34 = _swiftEmptyArrayStorage;
  swift_bridgeObjectRetain(a3);
  uint64_t v8 = sub_100080F00(a3);
  swift_bridgeObjectRelease(a3);
  unint64_t v32 = v8;
  sub_100081248((uint64_t *)&v32, sub_1000EAA20, sub_1000812C0);
  uint64_t v9 = (uint64_t)v32;
  uint64_t v10 = v32[2];
  if (v10)
  {
    unsigned int v11 = (unsigned __int8 *)v32 + 38;
    do
    {
      uint64_t v15 = *(v11 - 2);
      unsigned __int8 v16 = *v11;
      unint64_t v17 = sub_100188DE4(*(unsigned int *)(v11 - 6) | (unint64_t)(v15 << 32) | ((unint64_t)*(v11 - 1) << 40));
      if ((v18 & 0x100) == 0)
      {
        unint64_t v19 = v17 & 0xFFFF00FFFFFF00FFLL;
        if ((a2 & 1) != 0 && (_DWORD)v15)
        {
          uint64_t v4 = v19 | v4 & 0xFF000000FF00LL;
          char v12 = v18 & 1;
          BOOL v13 = &v33;
          uint64_t v14 = v4;
        }

        else
        {
          uint64_t v3 = v19 | v3 & 0xFF000000FF00LL;
          char v12 = v18 & 1;
          BOOL v13 = &v34;
          uint64_t v14 = v3;
        }

        sub_100076E50(v14, v12, v16, (uint64_t)v13);
      }

      v11 += 8;
      --v10;
    }

    while (v10);
    swift_release(v9);
    Swift::String v20 = v34;
    if (v34[2]) {
      goto LABEL_11;
    }
LABEL_15:
    swift_bridgeObjectRelease(v20);
    Swift::String v22 = _swiftEmptyArrayStorage;
    goto LABEL_16;
  }

  swift_release(v32);
  Swift::String v20 = _swiftEmptyArrayStorage;
  if (!_swiftEmptyArrayStorage[2]) {
    goto LABEL_15;
  }
LABEL_11:
  __int16 v21 = sub_1001A05D8(0, 0LL, 4LL) | 0x20;
  Swift::String v22 = sub_1000A71D8(0LL, 1LL, 1, _swiftEmptyArrayStorage);
  unint64_t v24 = v22[2];
  unint64_t v23 = v22[3];
  if (v24 >= v23 >> 1) {
    Swift::String v22 = sub_1000A71D8((void *)(v23 > 1), v24 + 1, 1, v22);
  }
  void v22[2] = v24 + 1;
  Swift::String v25 = &v22[2 * v24];
  *((_BYTE *)v25 + 32) = a1;
  *((_WORD *)v25 + 17) = v21;
  v25[5] = v20;
LABEL_16:
  Swift::String v26 = v33;
  if (v33[2])
  {
    __int16 v27 = sub_1001A05D8(1u, 0LL, 4LL) | 0x20;
    if ((swift_isUniquelyReferenced_nonNull_native(v22) & 1) == 0) {
      Swift::String v22 = sub_1000A71D8(0LL, v22[2] + 1LL, 1, v22);
    }
    unint64_t v29 = v22[2];
    unint64_t v28 = v22[3];
    if (v29 >= v28 >> 1) {
      Swift::String v22 = sub_1000A71D8((void *)(v28 > 1), v29 + 1, 1, v22);
    }
    void v22[2] = v29 + 1;
    uint64_t v30 = &v22[2 * v29];
    *((_BYTE *)v30 + 32) = a1;
    *((_WORD *)v30 + 17) = v27;
    v30[5] = v26;
  }

  else
  {
    swift_bridgeObjectRelease(v33);
  }

  return v22;
}

uint64_t sub_100076E50(uint64_t a1, char a2, unsigned __int8 a3, uint64_t a4)
{
  uint64_t v5 = *(void **)a4;
  if (*(void *)(*(void *)a4 + 16LL)) {
    __asm { BR              X12 }
  }

  char v6 = sub_1001A05C4(1u, 0LL, 1LL);
  char v7 = sub_1001A05B0(1LL, 4LL, 4LL);
  uint64_t v8 = sub_100002274(&qword_10040F270);
  uint64_t v9 = swift_allocObject(v8, 42LL, 7LL);
  *(_OWORD *)(v9 + 16) = xmmword_100339900;
  *(_BYTE *)(v9 + 32) = a1;
  *(_WORD *)(v9 + 34) = WORD1(a1);
  *(_BYTE *)(v9 + 36) = BYTE4(a1);
  *(_WORD *)(v9 + 38) = HIWORD(a1);
  *(_BYTE *)(v9 + 40) = a2 & 1;
  uint64_t result = swift_isUniquelyReferenced_nonNull_native(v5);
  if ((result & 1) == 0)
  {
    uint64_t result = (uint64_t)sub_1000A70B4(0LL, v5[2] + 1LL, 1, v5);
    uint64_t v5 = (void *)result;
  }

  unint64_t v12 = v5[2];
  unint64_t v11 = v5[3];
  if (v12 >= v11 >> 1)
  {
    uint64_t result = (uint64_t)sub_1000A70B4((void *)(v11 > 1), v12 + 1, 1, v5);
    uint64_t v5 = (void *)result;
  }

  v5[2] = v12 + 1;
  BOOL v13 = &v5[7 * v12];
  *((_WORD *)v13 + 16) = (8 * a3) | 2;
  v13[5] = 0LL;
  v13[6] = 0LL;
  v13[7] = 0xF000000000000000LL;
  *((_BYTE *)v13 + 64) = v7 | v6;
  v13[9] = v9;
  *((_BYTE *)v13 + 80) = 1;
  *(void *)a4 = v5;
  return result;
}

void *NANMapID.primary.unsafeMutableAddressor()
{
  return &static NANMapID.primary;
}

void *NANMapID.secondary.unsafeMutableAddressor()
{
  return &static NANMapID.secondary;
}

void *static Array<A>.committedAvailability(using:supportsSimultaneousDualBand:for:)( char a1, char a2, uint64_t a3)
{
  uint64_t v5 = sub_100080FE4(a3);
  swift_bridgeObjectRelease(a3);
  uint64_t v62 = v5;
  sub_100081248((uint64_t *)&v62, sub_1000EAA34, sub_1000819D0);
  char v52 = a1;
  uint64_t v6 = v62[2];
  uint64_t v51 = (uint64_t)v62;
  if (v6)
  {
    char v7 = (unsigned __int8 *)v62 + 63;
    uint64_t v54 = _swiftEmptyArrayStorage;
    uint64_t v55 = _swiftEmptyArrayStorage;
    do
    {
      uint64_t v9 = *(v7 - 27);
      unint64_t v59 = *(void *)(v7 - 23);
      uint64_t v61 = v6;
      unint64_t v58 = *(void *)(v7 - 15);
      uint64_t v10 = *(v7 - 7);
      uint64_t v11 = *(v7 - 6);
      uint64_t v12 = *(v7 - 5);
      uint64_t v13 = *(v7 - 4);
      uint64_t v14 = *(v7 - 3);
      uint64_t v15 = *(v7 - 2);
      uint64_t v16 = *(v7 - 1);
      uint64_t v17 = *v7;
      unint64_t v18 = sub_100188DE4((v9 << 32) | ((unint64_t)*(v7 - 26) << 40) | *(unsigned int *)(v7 - 31));
      if ((v19 & 0x100) != 0)
      {
        uint64_t v8 = v61;
      }

      else
      {
        unint64_t v56 = v18;
        char v57 = v19;
        unsigned __int16 v20 = TimeBitmap.nanBitmap.getter( v59,  v58,  v10 | (v11 << 8) | (v12 << 16) | (v13 << 24) | (v14 << 32) | (v15 << 40) | (v16 << 48) | (v17 << 56));
        uint64_t v22 = v21;
        uint64_t v24 = v23;
        char v25 = sub_1001A05C4(1u, 0LL, 1LL);
        unsigned __int16 v60 = v20;
        if ((a2 & 1) != 0 && (_DWORD)v9)
        {
          char v26 = v25;
          uint64_t v27 = v24;
          char v28 = sub_1001A05B0(1LL, 4LL, 4LL);
          uint64_t v29 = sub_100002274(&qword_10040F270);
          uint64_t v30 = swift_allocObject(v29, 42LL, 7LL);
          *(_OWORD *)(v30 + 16) = xmmword_100339900;
          *(_BYTE *)(v30 + 32) = v56;
          *(_WORD *)(v30 + 34) = WORD1(v56);
          *(_BYTE *)(v30 + 36) = BYTE4(v56);
          *(_WORD *)(v30 + 38) = HIWORD(v56);
          *(_BYTE *)(v30 + 40) = v57 & 1;
          uint64_t v31 = v22;
          if ((swift_isUniquelyReferenced_nonNull_native(v54) & 1) != 0) {
            unint64_t v32 = v54;
          }
          else {
            unint64_t v32 = sub_1000A70B4(0LL, v54[2] + 1LL, 1, v54);
          }
          uint64_t v8 = v61;
          unint64_t v34 = v32[2];
          unint64_t v33 = v32[3];
          unint64_t v35 = v34 + 1;
          if (v34 >= v33 >> 1) {
            unint64_t v32 = sub_1000A70B4((void *)(v33 > 1), v34 + 1, 1, v32);
          }
          uint64_t v54 = v32;
        }

        else
        {
          char v26 = v25;
          char v28 = sub_1001A05B0(1LL, 4LL, 4LL);
          uint64_t v36 = sub_100002274(&qword_10040F270);
          uint64_t v30 = swift_allocObject(v36, 42LL, 7LL);
          *(_OWORD *)(v30 + 16) = xmmword_100339900;
          *(_BYTE *)(v30 + 32) = v56;
          *(_WORD *)(v30 + 34) = WORD1(v56);
          *(_BYTE *)(v30 + 36) = BYTE4(v56);
          *(_WORD *)(v30 + 38) = HIWORD(v56);
          *(_BYTE *)(v30 + 40) = v57 & 1;
          uint64_t v31 = v22;
          if ((swift_isUniquelyReferenced_nonNull_native(v55) & 1) != 0) {
            unint64_t v32 = v55;
          }
          else {
            unint64_t v32 = sub_1000A70B4(0LL, v55[2] + 1LL, 1, v55);
          }
          uint64_t v8 = v61;
          uint64_t v27 = v24;
          unint64_t v34 = v32[2];
          unint64_t v37 = v32[3];
          unint64_t v35 = v34 + 1;
          if (v34 >= v37 >> 1) {
            unint64_t v32 = sub_1000A70B4((void *)(v37 > 1), v34 + 1, 1, v32);
          }
          uint64_t v55 = v32;
        }

        v32[2] = v35;
        unint64_t v38 = &v32[7 * v34];
        *((_WORD *)v38 + 16) = 4097;
        v38[5] = v60;
        v38[6] = v31;
        v38[7] = v27;
        *((_BYTE *)v38 + 64) = v28 | v26;
        v38[9] = v30;
        *((_BYTE *)v38 + 80) = 1;
      }

      v7 += 32;
      uint64_t v6 = v8 - 1;
    }

    while (v6);
  }

  else
  {
    uint64_t v54 = _swiftEmptyArrayStorage;
    uint64_t v55 = _swiftEmptyArrayStorage;
  }

  swift_release(v51);
  if (v55[2])
  {
    char v39 = v52;
    __int16 v40 = sub_1001A05D8(0, 0LL, 4LL) | 0x10;
    unint64_t v41 = sub_1000A71D8(0LL, 1LL, 1, _swiftEmptyArrayStorage);
    unint64_t v43 = v41[2];
    unint64_t v42 = v41[3];
    if (v43 >= v42 >> 1) {
      unint64_t v41 = sub_1000A71D8((void *)(v42 > 1), v43 + 1, 1, v41);
    }
    v41[2] = v43 + 1;
    uint64_t v44 = &v41[2 * v43];
    *((_BYTE *)v44 + 32) = v52;
    *((_WORD *)v44 + 17) = v40;
    unint64_t v45 = v54;
    v44[5] = v55;
    if (v54[2]) {
      goto LABEL_26;
    }
LABEL_32:
    swift_bridgeObjectRelease(v45);
    return v41;
  }

  swift_bridgeObjectRelease(v55);
  unint64_t v41 = _swiftEmptyArrayStorage;
  char v39 = v52;
  unint64_t v45 = v54;
  if (!v54[2]) {
    goto LABEL_32;
  }
LABEL_26:
  __int16 v46 = sub_1001A05D8(1u, 0LL, 4LL) | 0x10;
  if ((swift_isUniquelyReferenced_nonNull_native(v41) & 1) == 0) {
    unint64_t v41 = sub_1000A71D8(0LL, v41[2] + 1LL, 1, v41);
  }
  unint64_t v48 = v41[2];
  unint64_t v47 = v41[3];
  if (v48 >= v47 >> 1) {
    unint64_t v41 = sub_1000A71D8((void *)(v47 > 1), v48 + 1, 1, v41);
  }
  v41[2] = v48 + 1;
  uint64_t v49 = &v41[2 * v48];
  *((_BYTE *)v49 + 32) = v39;
  *((_WORD *)v49 + 17) = v46;
  v49[5] = v54;
  return v41;
}

uint64_t NANScheduleEntry.timeBitmap.getter(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  return a2;
}

uint64_t NANScheduleEntry.timeBitmap.setter(__int16 a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = sub_1000208D8(*(void *)(v3 + 16), *(void *)(v3 + 24));
  *(_WORD *)(v3 + 8) = a1;
  *(void *)(v3 + 16) = a2;
  *(void *)(v3 + 24) = a3;
  return result;
}

uint64_t NANScheduleEntry.hash(into:)( uint64_t a1, Swift::UInt8 a2, Swift::UInt16 a3, uint64_t a4, unint64_t a5)
{
  return sub_1000208D8(a4, a5);
}

BOOL static NANScheduleEntry.__derived_struct_equals(_:_:)( char a1, __int16 a2, uint64_t a3, uint64_t a4, char a5, __int16 a6)
{
  BOOL result = 0;
  if (a1 == a5 && a2 == a6)
  {
    _s7CoreP2P6NANPMKV23__derived_struct_equalsySbAC_ACtFZ_0(a3, a4);
    if ((v6 & 1) != 0) {
      return 1;
    }
  }

  return result;
}

uint64_t sub_1000778A8()
{
  if (*v0) {
    return 0x6D746942656D6974LL;
  }
  else {
    return 0x444970616DLL;
  }
}

uint64_t sub_1000778E4@<X0>(uint64_t a1@<X0>, unint64_t a2@<X1>, _BYTE *a3@<X8>)
{
  uint64_t result = sub_1000893EC(a1, a2);
  *a3 = result;
  return result;
}

uint64_t sub_100077908(uint64_t a1)
{
  unint64_t v2 = sub_100086D58();
  return CodingKey.description.getter(a1, v2);
}

uint64_t sub_100077930(uint64_t a1)
{
  unint64_t v2 = sub_100086D58();
  return CodingKey.debugDescription.getter(a1, v2);
}

uint64_t NANScheduleEntry.encode(to:)(void *a1, char a2, __int16 a3, uint64_t a4, uint64_t a5)
{
  uint64_t v20 = a4;
  uint64_t v21 = a5;
  uint64_t v9 = sub_100002274(&qword_100406548);
  uint64_t v10 = *(void *)(v9 - 8);
  __chkstk_darwin(v9);
  uint64_t v12 = (char *)&v19 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v14 = a1[3];
  uint64_t v13 = a1[4];
  sub_100021104(a1, v14);
  unint64_t v15 = sub_100086D58();
  dispatch thunk of Encoder.container<A>(keyedBy:)( &type metadata for NANScheduleEntry.CodingKeys,  &type metadata for NANScheduleEntry.CodingKeys,  v15,  v14,  v13);
  LOBYTE(v22) = a2;
  char v25 = 0;
  unint64_t v16 = sub_100086D9C();
  KeyedEncodingContainer.encode<A>(_:forKey:)(&v22, &v25, v9, &type metadata for NANMapID, v16);
  if (!v5)
  {
    __int16 v22 = a3;
    uint64_t v23 = v20;
    uint64_t v24 = v21;
    char v25 = 1;
    unint64_t v17 = sub_100086CE8();
    KeyedEncodingContainer.encode<A>(_:forKey:)(&v22, &v25, v9, &type metadata for NANBitmap.Time, v17);
  }

  return (*(uint64_t (**)(char *, uint64_t))(v10 + 8))(v12, v9);
}

Swift::Int NANScheduleEntry.hashValue.getter( Swift::UInt8 a1, Swift::UInt16 a2, uint64_t a3, unint64_t a4)
{
  return Hasher._finalize()();
}

uint64_t NANScheduleEntry.init(from:)(void *a1)
{
  return sub_100084E74(a1);
}

Swift::Int sub_100077B64()
{
  uint64_t v1 = *(void *)(v0 + 16);
  unint64_t v2 = *(void *)(v0 + 24);
  Swift::UInt8 v3 = *(_BYTE *)v0;
  Swift::UInt16 v4 = *(_WORD *)(v0 + 8);
  Hasher.init(_seed:)(v6, 0LL);
  Hasher._combine(_:)(v3);
  Hasher._combine(_:)(v4);
  sub_100020AFC(v1, v2);
  Data.hash(into:)(v6, v1, v2);
  sub_1000208D8(v1, v2);
  return Hasher._finalize()();
}

uint64_t sub_100077BF4(uint64_t a1)
{
  uint64_t v3 = *(void *)(v1 + 16);
  unint64_t v4 = *(void *)(v1 + 24);
  Swift::UInt16 v5 = *(_WORD *)(v1 + 8);
  Hasher._combine(_:)(*(_BYTE *)v1);
  Hasher._combine(_:)(v5);
  sub_100020AFC(v3, v4);
  Data.hash(into:)(a1, v3, v4);
  return sub_1000208D8(v3, v4);
}

Swift::Int sub_100077C60(uint64_t a1)
{
  uint64_t v2 = *(void *)(v1 + 16);
  unint64_t v3 = *(void *)(v1 + 24);
  Swift::UInt8 v4 = *(_BYTE *)v1;
  Swift::UInt16 v5 = *(_WORD *)(v1 + 8);
  Hasher.init(_seed:)(v7, a1);
  Hasher._combine(_:)(v4);
  Hasher._combine(_:)(v5);
  sub_100020AFC(v2, v3);
  Data.hash(into:)(v7, v2, v3);
  sub_1000208D8(v2, v3);
  return Hasher._finalize()();
}

uint64_t sub_100077CEC@<X0>(void *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t result = sub_100084E74(a1);
  if (!v2)
  {
    *(_BYTE *)a2 = result;
    *(_WORD *)(a2 + 8) = v5;
    *(void *)(a2 + 16) = v6;
    *(void *)(a2 + 24) = v7;
  }

  return result;
}

uint64_t sub_100077D1C(void *a1)
{
  return NANScheduleEntry.encode(to:)(a1, *(_BYTE *)v1, *(_WORD *)(v1 + 8), *(void *)(v1 + 16), *(void *)(v1 + 24));
}

BOOL sub_100077D3C(unsigned __int8 *a1, unsigned __int8 *a2)
{
  BOOL result = 0;
  if (*a1 == *a2 && *((unsigned __int16 *)a1 + 4) == *((unsigned __int16 *)a2 + 4))
  {
    _s7CoreP2P6NANPMKV23__derived_struct_equalsySbAC_ACtFZ_0(*((void *)a1 + 2), *((void *)a1 + 3));
    if ((v2 & 1) != 0) {
      return 1;
    }
  }

  return result;
}

uint64_t NANMapIDs.init(rawValue:)(unsigned int a1)
{
  unsigned __int8 v1 = a1 & 1;
  if ((a1 & 1) != 0) {
    int v2 = 0;
  }
  else {
    int v2 = (a1 >> 1) & 0xF;
  }
  return v2 & 0xFFFF00FF | (v1 << 8);
}

CoreP2P::NANMapID __swiftcall NANMapID.init(rawValue:)(Swift::UInt8 rawValue)
{
  return (CoreP2P::NANMapID)(rawValue & 0xF);
}

void *NANMapIDs.init(decoder:)(void *a1)
{
  uint64_t v3 = a1[3];
  uint64_t v4 = a1[4];
  __int16 v5 = sub_100021104(a1, v3);
  dispatch thunk of Decoder.singleValueContainer()(v12, v3, v4);
  if (v1)
  {
    sub_100002AC4(a1);
  }

  else
  {
    uint64_t v6 = v13;
    uint64_t v7 = v14;
    sub_100021104(v12, v13);
    unsigned int v8 = dispatch thunk of SingleValueDecodingContainer.decode(_:)(v6, v7);
    unsigned __int8 v10 = v8 & 1;
    if ((v8 & 1) != 0) {
      int v11 = 0;
    }
    else {
      int v11 = (v8 >> 1) & 0xF;
    }
    sub_100002AC4(v12);
    sub_100002AC4(a1);
    return (void *)(v11 & 0xFFFF00FF | (v10 << 8));
  }

  return v5;
}

uint64_t NANMapIDs.encode(to:)(void *a1, int a2)
{
  uint64_t v3 = a1[3];
  uint64_t v4 = a1[4];
  sub_100021104(a1, v3);
  dispatch thunk of Encoder.singleValueContainer()(v9, v3, v4);
  if ((a2 & 0x100) != 0) {
    uint64_t v5 = 1LL;
  }
  else {
    uint64_t v5 = (2 * a2);
  }
  uint64_t v6 = v10;
  uint64_t v7 = v11;
  sub_1000237C8((uint64_t)v9, v10);
  dispatch thunk of SingleValueEncodingContainer.encode(_:)(v5, v6, v7);
  return sub_100002AC4(v9);
}

uint64_t NANMapIDs.rawValue.getter(int a1)
{
  if ((a1 & 0x100) != 0) {
    return 1LL;
  }
  else {
    return (2 * a1);
  }
}

unsigned __int8 *sub_100077F34@<X0>(unsigned __int8 *result@<X0>, uint64_t a2@<X8>)
{
  unsigned int v2 = *result;
  int v3 = (v2 >> 1) & 0xF;
  int v4 = v2 & 1;
  if (v4) {
    LOWORD(v3) = 0;
  }
  *(_WORD *)a2 = v3 | ((_WORD)v4 << 8);
  *(_BYTE *)(a2 + 2) = 0;
  return result;
}

void sub_100077F54(char *a1@<X8>)
{
  if (v1[1]) {
    char v2 = 1;
  }
  else {
    char v2 = 2 * *v1;
  }
  *a1 = v2;
}

Swift::Int sub_100077F70()
{
  char v1 = *v0;
  int v2 = v0[1];
  Hasher.init(_seed:)(v5, 0LL);
  if (v2) {
    Swift::UInt8 v3 = 1;
  }
  else {
    Swift::UInt8 v3 = 2 * v1;
  }
  Hasher._combine(_:)(v3);
  return Hasher._finalize()();
}

void sub_100077FC0()
{
  if (v0[1]) {
    Swift::UInt8 v1 = 1;
  }
  else {
    Swift::UInt8 v1 = 2 * *v0;
  }
  Hasher._combine(_:)(v1);
}

Swift::Int sub_100077FF8(uint64_t a1)
{
  char v2 = *v1;
  int v3 = v1[1];
  Hasher.init(_seed:)(v6, a1);
  if (v3) {
    Swift::UInt8 v4 = 1;
  }
  else {
    Swift::UInt8 v4 = 2 * v2;
  }
  Hasher._combine(_:)(v4);
  return Hasher._finalize()();
}

uint64_t sub_100078044(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v6 = sub_1000899A4();
  return RawRepresentable<>.init(from:)(a1, a2, a3, v6);
}

uint64_t sub_1000780A0(void *a1)
{
  int v2 = *v1;
  int v3 = v1[1];
  uint64_t v4 = a1[3];
  uint64_t v5 = a1[4];
  sub_100021104(a1, v4);
  dispatch thunk of Encoder.singleValueContainer()(v10, v4, v5);
  if (v3) {
    uint64_t v6 = 1LL;
  }
  else {
    uint64_t v6 = (2 * v2);
  }
  uint64_t v7 = v11;
  uint64_t v8 = v12;
  sub_1000237C8((uint64_t)v10, v11);
  dispatch thunk of SingleValueEncodingContainer.encode(_:)(v6, v7, v8);
  return sub_100002AC4(v10);
}

uint64_t sub_100078144(_BYTE *a1, _BYTE *a2)
{
  if (a1[1]) {
    char v2 = a2[1];
  }
  else {
    char v2 = (((*a1 ^ *a2) & 0x7F) == 0) & ~a2[1];
  }
  return v2 & 1;
}

uint64_t NANMapID.init(decoder:)(void *a1)
{
  uint64_t v3 = a1[3];
  uint64_t v4 = a1[4];
  uint64_t v5 = (uint64_t)sub_100021104(a1, v3);
  dispatch thunk of Decoder.singleValueContainer()(v9, v3, v4);
  if (!v1)
  {
    uint64_t v6 = v10;
    uint64_t v7 = v11;
    sub_100021104(v9, v10);
    uint64_t v5 = dispatch thunk of SingleValueDecodingContainer.decode(_:)(v6, v7) & 0xF;
    sub_100002AC4(v9);
  }

  sub_100002AC4(a1);
  return v5;
}

uint64_t NANMapID.description.getter(char a1)
{
  if (!a1) {
    return 0x7972616D697270LL;
  }
  if (a1 == 1) {
    return 0x7261646E6F636573LL;
  }
  return dispatch thunk of CustomStringConvertible.description.getter( &type metadata for UInt8,  &protocol witness table for UInt8);
}

uint64_t sub_1000782B4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v6 = sub_100089960();
  return RawRepresentable<>.init(from:)(a1, a2, a3, v6);
}

uint64_t sub_100078310(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v6 = sub_100089960();
  return RawRepresentable<>.encode(to:)(a1, a2, a3, v6);
}

_BYTE *sub_10007835C@<X0>(_BYTE *result@<X0>, _WORD *a2@<X8>)
{
  *a2 = *result & 0xF;
  return result;
}

uint64_t sub_100078370()
{
  if (*v0 == 1) {
    return 0x7261646E6F636573LL;
  }
  if (*v0) {
    return dispatch thunk of CustomStringConvertible.description.getter( &type metadata for UInt8,  &protocol witness table for UInt8);
  }
  return 0x7972616D697270LL;
}

uint64_t NonNANOperatingChannelInformation.channelNumber.getter(unsigned int a1)
{
  return a1 >> 8;
}

uint64_t NonNANOperatingChannelInformation.channelCenterFrequency.getter(unsigned int a1)
{
  return HIWORD(a1);
}

uint64_t NonNANOperatingChannelInformation.channelCenterFrequency.setter(uint64_t result)
{
  *(_BYTE *)(v1 + 2) = result;
  return result;
}

unint64_t NonNANOperatingChannelInformation.channel.getter(__int16 a1)
{
  return sub_1001889D8(HIBYTE(a1)) & 0xFFFFFFFFFFFFLL;
}

void NonNANOperatingChannelInformation.hash(into:)(int a1, unsigned int a2)
{
  unsigned int v2 = a2 >> 8;
  unsigned int v3 = HIWORD(a2);
  Hasher._combine(_:)(a2);
  Hasher._combine(_:)(v2);
  Hasher._combine(_:)(v3);
}

BOOL static NonNANOperatingChannelInformation.__derived_struct_equals(_:_:)(int a1, int a2)
{
  return (a1 & 0xFFFFFF) == (a2 & 0xFFFFFF);
}

unint64_t sub_10007847C()
{
  unint64_t v1 = 0x4E6C656E6E616863LL;
  if (*v0 != 1) {
    unint64_t v1 = 0xD000000000000016LL;
  }
  if (*v0) {
    return v1;
  }
  else {
    return 0xD000000000000014LL;
  }
}

uint64_t sub_1000784E8@<X0>(uint64_t a1@<X0>, unint64_t a2@<X1>, _BYTE *a3@<X8>)
{
  uint64_t result = sub_1000894E0(a1, a2);
  *a3 = result;
  return result;
}

uint64_t sub_10007850C(uint64_t a1)
{
  unint64_t v2 = sub_100086DE0();
  return CodingKey.description.getter(a1, v2);
}

uint64_t sub_100078534(uint64_t a1)
{
  unint64_t v2 = sub_100086DE0();
  return CodingKey.debugDescription.getter(a1, v2);
}

uint64_t NonNANOperatingChannelInformation.encode(to:)(void *a1, uint64_t a2)
{
  uint64_t v5 = sub_100002274(&qword_100406560);
  uint64_t v6 = *(void *)(v5 - 8);
  __chkstk_darwin(v5);
  uint64_t v8 = (char *)&v13 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v9 = a1[3];
  uint64_t v10 = a1[4];
  sub_100021104(a1, v9);
  unint64_t v11 = sub_100086DE0();
  dispatch thunk of Encoder.container<A>(keyedBy:)( &type metadata for NonNANOperatingChannelInformation.CodingKeys,  &type metadata for NonNANOperatingChannelInformation.CodingKeys,  v11,  v9,  v10);
  char v16 = 0;
  KeyedEncodingContainer.encode(_:forKey:)(a2, &v16, v5);
  if (!v2)
  {
    char v15 = 1;
    KeyedEncodingContainer.encode(_:forKey:)(a2 >> 8, &v15, v5);
    char v14 = 2;
    KeyedEncodingContainer.encode(_:forKey:)(WORD1(a2), &v14, v5);
  }

  return (*(uint64_t (**)(char *, uint64_t))(v6 + 8))(v8, v5);
}

Swift::Int NonNANOperatingChannelInformation.hashValue.getter(unsigned int a1)
{
  Swift::UInt8 v1 = a1;
  unsigned int v2 = a1 >> 8;
  unsigned int v3 = HIWORD(a1);
  Hasher.init(_seed:)(v5, 0LL);
  Hasher._combine(_:)(v1);
  Hasher._combine(_:)(v2);
  Hasher._combine(_:)(v3);
  return Hasher._finalize()();
}

uint64_t NonNANOperatingChannelInformation.init(from:)(void *a1)
{
  return sub_100085260(a1) & 0xFFFFFF;
}

Swift::Int sub_10007871C()
{
  Swift::UInt8 v1 = *v0;
  Swift::UInt8 v2 = v0[1];
  Swift::UInt8 v3 = v0[2];
  Hasher.init(_seed:)(v5, 0LL);
  Hasher._combine(_:)(v1);
  Hasher._combine(_:)(v2);
  Hasher._combine(_:)(v3);
  return Hasher._finalize()();
}

void sub_100078788()
{
  Swift::UInt8 v1 = v0[1];
  Swift::UInt8 v2 = v0[2];
  Hasher._combine(_:)(*v0);
  Hasher._combine(_:)(v1);
  Hasher._combine(_:)(v2);
}

Swift::Int sub_1000787D0(uint64_t a1)
{
  Swift::UInt8 v2 = *v1;
  Swift::UInt8 v3 = v1[1];
  Swift::UInt8 v4 = v1[2];
  Hasher.init(_seed:)(v6, a1);
  Hasher._combine(_:)(v2);
  Hasher._combine(_:)(v3);
  Hasher._combine(_:)(v4);
  return Hasher._finalize()();
}

uint64_t sub_100078838@<X0>(void *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t result = sub_100085260(a1);
  if (!v2)
  {
    *(_WORD *)a2 = result;
    *(_BYTE *)(a2 + 2) = BYTE2(result);
  }

  return result;
}

uint64_t sub_100078870(void *a1)
{
  return NonNANOperatingChannelInformation.encode(to:)(a1, *v1 | (*((unsigned __int8 *)v1 + 2) << 16));
}

BOOL sub_100078890(unsigned __int8 *a1, unsigned __int8 *a2)
{
  return *a1 == *a2 && a1[1] == a2[1] && a1[2] == a2[2];
}

CoreP2P::NonNANBeaconInformation __swiftcall NonNANBeaconInformation.init(targetBeaconTransmissionTimeOffset:beaconInterval:)( Swift::UInt16 targetBeaconTransmissionTimeOffset, Swift::UInt16 beaconInterval)
{
  return (CoreP2P::NonNANBeaconInformation)(targetBeaconTransmissionTimeOffset | (beaconInterval << 16));
}

void NonNANBeaconInformation.hash(into:)(int a1, unsigned int a2)
{
  unsigned int v2 = HIWORD(a2);
  Hasher._combine(_:)(a2);
  Hasher._combine(_:)(v2);
}

BOOL static NonNANBeaconInformation.__derived_struct_equals(_:_:)(int a1, int a2)
{
  return a1 == a2;
}

unint64_t sub_10007890C()
{
  if (*v0) {
    return 0xD000000000000011LL;
  }
  else {
    return 0xD000000000000022LL;
  }
}

uint64_t sub_10007894C@<X0>(uint64_t a1@<X0>, unint64_t a2@<X1>, _BYTE *a3@<X8>)
{
  uint64_t result = sub_100089650(a1, a2);
  *a3 = result;
  return result;
}

uint64_t sub_100078970(uint64_t a1)
{
  unint64_t v2 = sub_100086E24();
  return CodingKey.description.getter(a1, v2);
}

uint64_t sub_100078998(uint64_t a1)
{
  unint64_t v2 = sub_100086E24();
  return CodingKey.debugDescription.getter(a1, v2);
}

uint64_t NonNANBeaconInformation.encode(to:)(void *a1, uint64_t a2)
{
  uint64_t v5 = sub_100002274(&qword_100406570);
  uint64_t v6 = *(void *)(v5 - 8);
  __chkstk_darwin(v5);
  uint64_t v8 = (char *)&v13 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v9 = a1[3];
  uint64_t v10 = a1[4];
  sub_100021104(a1, v9);
  unint64_t v11 = sub_100086E24();
  dispatch thunk of Encoder.container<A>(keyedBy:)( &type metadata for NonNANBeaconInformation.CodingKeys,  &type metadata for NonNANBeaconInformation.CodingKeys,  v11,  v9,  v10);
  char v15 = 0;
  KeyedEncodingContainer.encode(_:forKey:)(a2, &v15, v5);
  if (!v2)
  {
    char v14 = 1;
    KeyedEncodingContainer.encode(_:forKey:)(WORD1(a2), &v14, v5);
  }

  return (*(uint64_t (**)(char *, uint64_t))(v6 + 8))(v8, v5);
}

Swift::Int NonNANBeaconInformation.hashValue.getter(unsigned int a1)
{
  Swift::UInt16 v1 = a1;
  unsigned int v2 = HIWORD(a1);
  Hasher.init(_seed:)(v4, 0LL);
  Hasher._combine(_:)(v1);
  Hasher._combine(_:)(v2);
  return Hasher._finalize()();
}

uint64_t NonNANBeaconInformation.init(from:)(void *a1)
{
  return sub_100085110(a1);
}

Swift::Int sub_100078B44()
{
  Swift::UInt16 v1 = *v0;
  Swift::UInt16 v2 = v0[1];
  Hasher.init(_seed:)(v4, 0LL);
  Hasher._combine(_:)(v1);
  Hasher._combine(_:)(v2);
  return Hasher._finalize()();
}

void sub_100078BA0()
{
  Swift::UInt16 v1 = v0[1];
  Hasher._combine(_:)(*v0);
  Hasher._combine(_:)(v1);
}

Swift::Int sub_100078BDC(uint64_t a1)
{
  Swift::UInt16 v2 = *v1;
  Swift::UInt16 v3 = v1[1];
  Hasher.init(_seed:)(v5, a1);
  Hasher._combine(_:)(v2);
  Hasher._combine(_:)(v3);
  return Hasher._finalize()();
}

uint64_t sub_100078C34@<X0>(void *a1@<X0>, _DWORD *a2@<X8>)
{
  uint64_t result = sub_100085110(a1);
  if (!v2) {
    *a2 = result;
  }
  return result;
}

uint64_t sub_100078C5C(void *a1)
{
  return NonNANBeaconInformation.encode(to:)(a1, *v1);
}

uint64_t sub_100078C74(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v6 = sub_100089048();
  return RawRepresentable<>.init(from:)(a1, a2, a3, v6);
}

uint64_t sub_100078CD0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v6 = sub_100089048();
  return RawRepresentable<>.encode(to:)(a1, a2, a3, v6);
}

uint64_t IEEE80211InformationElement.HighThroughputCapability.mcs.setter(uint64_t a1, uint64_t a2)
{
  uint64_t result = sub_1000208D8(*(void *)(v2 + 8), *(void *)(v2 + 16));
  *(void *)(v2 + 8) = a1;
  *(void *)(v2 + 16) = a2;
  return result;
}

uint64_t DeprecatedNANAvailability.init(from:)(void *a1)
{
  return sub_100085B2C(a1) & 0x1FFFF;
}

uint64_t DeprecatedNANAvailability.encode(to:)(void *a1, unsigned int a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8 = a1[3];
  uint64_t v9 = a1[4];
  sub_100021104(a1, v8);
  dispatch thunk of Encoder.unkeyedContainer()(v25, v8, v9);
  char v10 = sub_1001A05C4(a2, 0LL, 4LL);
  if (!v4)
  {
    char v11 = v10;
    unsigned __int8 v12 = sub_1001A05C4(BYTE1(a2), 4uLL, 2LL);
    unsigned __int8 v13 = sub_1001A05B0(HIWORD(a2) & 1, 6LL, 1LL);
    else {
      unsigned __int8 v14 = 0;
    }
    char v15 = v14 | v11;
    else {
      unsigned __int8 v16 = 0;
    }
    LOBYTE(v24[0]) = v16 | v15;
    uint64_t v17 = v26;
    uint64_t v18 = v27;
    sub_1000237C8((uint64_t)v25, v26);
    unint64_t v19 = sub_100086E68();
    dispatch thunk of UnkeyedEncodingContainer.encode<A>(_:)( v24,  &type metadata for DeprecatedNANAvailability.AvailabilityControl,  v19,  v17,  v18);
    v24[0] = a3;
    v24[1] = a4;
    uint64_t v20 = v26;
    uint64_t v21 = v27;
    sub_1000237C8((uint64_t)v25, v26);
    unint64_t v22 = sub_10005CD78();
    dispatch thunk of UnkeyedEncodingContainer.encode<A>(_:)(v24, &type metadata for Data, v22, v20, v21);
  }

  return sub_100002AC4(v25);
}

uint64_t DeprecatedNANAvailability.hash(into:)(uint64_t a1, unsigned int a2, uint64_t a3, unint64_t a4)
{
  char v6 = BYTE2(a2);
  unsigned int v8 = a2 >> 8;
  Hasher._combine(_:)(a2);
  Hasher._combine(_:)(v8);
  Hasher._combine(_:)(v6 & 1);
  sub_100020AFC(a3, a4);
  Data.hash(into:)(a1, a3, a4);
  return sub_1000208D8(a3, a4);
}

void static DeprecatedNANAvailability.__derived_struct_equals(_:_:)(int a1, uint64_t a2, uint64_t a3, int a4)
{
}

Swift::Int DeprecatedNANAvailability.hashValue.getter(unsigned int a1, uint64_t a2, unint64_t a3)
{
  unsigned int v6 = a1 >> 8;
  Hasher.init(_seed:)(v8, 0LL);
  Hasher._combine(_:)(a1);
  Hasher._combine(_:)(v6);
  Hasher._combine(_:)(BYTE2(a1) & 1);
  sub_100020AFC(a2, a3);
  Data.hash(into:)(v8, a2, a3);
  sub_1000208D8(a2, a3);
  return Hasher._finalize()();
}

Swift::Int sub_100079038()
{
  Swift::UInt8 v1 = *(_BYTE *)(v0 + 2);
  uint64_t v2 = *(void *)(v0 + 8);
  unint64_t v3 = *(void *)(v0 + 16);
  Swift::UInt8 v4 = *(_BYTE *)v0;
  Swift::UInt8 v5 = *(_BYTE *)(v0 + 1);
  Hasher.init(_seed:)(v7, 0LL);
  Hasher._combine(_:)(v4);
  Hasher._combine(_:)(v5);
  Hasher._combine(_:)(v1);
  sub_100020AFC(v2, v3);
  Data.hash(into:)(v7, v2, v3);
  sub_1000208D8(v2, v3);
  return Hasher._finalize()();
}

uint64_t sub_1000790D8(uint64_t a1)
{
  Swift::UInt8 v3 = *(_BYTE *)(v1 + 2);
  uint64_t v4 = *(void *)(v1 + 8);
  unint64_t v5 = *(void *)(v1 + 16);
  Swift::UInt8 v6 = *(_BYTE *)(v1 + 1);
  Hasher._combine(_:)(*(_BYTE *)v1);
  Hasher._combine(_:)(v6);
  Hasher._combine(_:)(v3);
  sub_100020AFC(v4, v5);
  Data.hash(into:)(a1, v4, v5);
  return sub_1000208D8(v4, v5);
}

Swift::Int sub_100079150(uint64_t a1)
{
  Swift::UInt8 v2 = *(_BYTE *)(v1 + 2);
  uint64_t v3 = *(void *)(v1 + 8);
  unint64_t v4 = *(void *)(v1 + 16);
  Swift::UInt8 v5 = *(_BYTE *)v1;
  Swift::UInt8 v6 = *(_BYTE *)(v1 + 1);
  Hasher.init(_seed:)(v8, a1);
  Hasher._combine(_:)(v5);
  Hasher._combine(_:)(v6);
  Hasher._combine(_:)(v2);
  sub_100020AFC(v3, v4);
  Data.hash(into:)(v8, v3, v4);
  sub_1000208D8(v3, v4);
  return Hasher._finalize()();
}

uint64_t sub_1000791EC@<X0>(void *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t result = sub_100085B2C(a1);
  if (!v2)
  {
    *(_WORD *)a2 = result;
    *(_BYTE *)(a2 + 2) = BYTE2(result) & 1;
    *(void *)(a2 + 8) = v5;
    *(void *)(a2 + 16) = v6;
  }

  return result;
}

uint64_t sub_100079228(void *a1)
{
  if (*((_BYTE *)v1 + 2)) {
    int v2 = 0x10000;
  }
  else {
    int v2 = 0;
  }
  return DeprecatedNANAvailability.encode(to:)(a1, *v1 | v2, *((void *)v1 + 1), *((void *)v1 + 2));
}

void sub_100079258(unsigned __int8 *a1, unsigned __int8 *a2)
{
  if (*a1 == *a2 && a1[1] == a2[1] && ((a1[2] ^ a2[2]) & 1) == 0) {
    _s7CoreP2P6NANPMKV23__derived_struct_equalsySbAC_ACtFZ_0(*((void *)a1 + 1), *((void *)a1 + 2));
  }
}

uint64_t DeprecatedNANAvailabilityEntry.init(from:)(void *a1)
{
  return sub_1000858AC(a1) & 0xFFFFFF;
}

uint64_t DeprecatedNANAvailabilityEntry.hash(into:)( uint64_t a1, unsigned int a2, uint64_t a3, unint64_t a4)
{
  unsigned int v7 = a2 >> 8;
  unsigned int v8 = HIWORD(a2);
  Hasher._combine(_:)(a2);
  Hasher._combine(_:)(v7);
  Hasher._combine(_:)(v8);
  sub_100020AFC(a3, a4);
  Data.hash(into:)(a1, a3, a4);
  return sub_1000208D8(a3, a4);
}

void static DeprecatedNANAvailabilityEntry.__derived_struct_equals(_:_:)( int a1, uint64_t a2, uint64_t a3, int a4)
{
  if ((a1 & 0xFFFFFF) == (a4 & 0xFFFFFF)) {
    _s7CoreP2P6NANPMKV23__derived_struct_equalsySbAC_ACtFZ_0(a2, a3);
  }
}

uint64_t sub_100079364()
{
  return ((uint64_t (*)(uint64_t, unint64_t))((char *)sub_100079394 + 4 * byte_10033C489[*v0]))( 0x6C6F72746E6F63LL,  0xE700000000000000LL);
}

uint64_t sub_100079394()
{
  return 0x6E6974617265706FLL;
}

uint64_t sub_1000793B8()
{
  return 0x4E6C656E6E616863LL;
}

uint64_t sub_1000793DC()
{
  return 0x6962616C69617661LL;
}

uint64_t sub_100079400@<X0>(uint64_t a1@<X0>, unint64_t a2@<X1>, _BYTE *a3@<X8>)
{
  uint64_t result = sub_10008973C(a1, a2);
  *a3 = result;
  return result;
}

uint64_t sub_100079424(uint64_t a1)
{
  unint64_t v2 = sub_100086EAC();
  return CodingKey.description.getter(a1, v2);
}

uint64_t sub_10007944C(uint64_t a1)
{
  unint64_t v2 = sub_100086EAC();
  return CodingKey.debugDescription.getter(a1, v2);
}

uint64_t DeprecatedNANAvailabilityEntry.encode(to:)(void *a1, unsigned int a2, uint64_t a3, uint64_t a4)
{
  uint64_t v21 = a4;
  uint64_t v8 = sub_100002274(&qword_100406588);
  uint64_t v9 = *(void *)(v8 - 8);
  __chkstk_darwin(v8);
  char v11 = (char *)&v20 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v12 = a1[3];
  uint64_t v13 = a1[4];
  sub_100021104(a1, v12);
  unint64_t v14 = sub_100086EAC();
  dispatch thunk of Encoder.container<A>(keyedBy:)( &type metadata for DeprecatedNANAvailabilityEntry.CodingKeys,  &type metadata for DeprecatedNANAvailabilityEntry.CodingKeys,  v14,  v12,  v13);
  LOBYTE(v22[0]) = a2;
  char v23 = 0;
  unint64_t v15 = sub_100086EF0();
  KeyedEncodingContainer.encode<A>(_:forKey:)(v22, &v23, v8, &type metadata for NANIntervalDuration, v15);
  if (!v4)
  {
    uint64_t v16 = a3;
    uint64_t v17 = v21;
    LOBYTE(v22[0]) = 1;
    KeyedEncodingContainer.encode(_:forKey:)(a2 >> 8, v22, v8);
    LOBYTE(v22[0]) = 2;
    KeyedEncodingContainer.encode(_:forKey:)(HIWORD(a2), v22, v8);
    v22[0] = v16;
    v22[1] = v17;
    char v23 = 3;
    unint64_t v18 = sub_10005CD78();
    KeyedEncodingContainer.encode<A>(_:forKey:)(v22, &v23, v8, &type metadata for Data, v18);
  }

  return (*(uint64_t (**)(char *, uint64_t))(v9 + 8))(v11, v8);
}

Swift::Int DeprecatedNANAvailabilityEntry.hashValue.getter(unsigned int a1, uint64_t a2, unint64_t a3)
{
  Swift::UInt8 v5 = a1;
  unsigned int v6 = a1 >> 8;
  unsigned int v7 = HIWORD(a1);
  Hasher.init(_seed:)(v9, 0LL);
  Hasher._combine(_:)(v5);
  Hasher._combine(_:)(v6);
  Hasher._combine(_:)(v7);
  sub_100020AFC(a2, a3);
  Data.hash(into:)(v9, a2, a3);
  sub_1000208D8(a2, a3);
  return Hasher._finalize()();
}

Swift::Int sub_1000796BC()
{
  uint64_t v1 = *(void *)(v0 + 8);
  unint64_t v2 = *(void *)(v0 + 16);
  Swift::UInt8 v3 = *(_BYTE *)v0;
  Swift::UInt8 v4 = *(_BYTE *)(v0 + 1);
  Swift::UInt8 v5 = *(_BYTE *)(v0 + 2);
  Hasher.init(_seed:)(v7, 0LL);
  Hasher._combine(_:)(v3);
  Hasher._combine(_:)(v4);
  Hasher._combine(_:)(v5);
  sub_100020AFC(v1, v2);
  Data.hash(into:)(v7, v1, v2);
  sub_1000208D8(v1, v2);
  return Hasher._finalize()();
}

uint64_t sub_10007975C(uint64_t a1)
{
  uint64_t v3 = *(void *)(v1 + 8);
  unint64_t v4 = *(void *)(v1 + 16);
  Swift::UInt8 v5 = *(_BYTE *)(v1 + 1);
  Swift::UInt8 v6 = *(_BYTE *)(v1 + 2);
  Hasher._combine(_:)(*(_BYTE *)v1);
  Hasher._combine(_:)(v5);
  Hasher._combine(_:)(v6);
  sub_100020AFC(v3, v4);
  Data.hash(into:)(a1, v3, v4);
  return sub_1000208D8(v3, v4);
}

Swift::Int sub_1000797D4(uint64_t a1)
{
  uint64_t v2 = *(void *)(v1 + 8);
  unint64_t v3 = *(void *)(v1 + 16);
  Swift::UInt8 v4 = *(_BYTE *)v1;
  Swift::UInt8 v5 = *(_BYTE *)(v1 + 1);
  Swift::UInt8 v6 = *(_BYTE *)(v1 + 2);
  Hasher.init(_seed:)(v8, a1);
  Hasher._combine(_:)(v4);
  Hasher._combine(_:)(v5);
  Hasher._combine(_:)(v6);
  sub_100020AFC(v2, v3);
  Data.hash(into:)(v8, v2, v3);
  sub_1000208D8(v2, v3);
  return Hasher._finalize()();
}

uint64_t sub_100079870@<X0>(void *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t result = sub_1000858AC(a1);
  if (!v2)
  {
    *(_WORD *)a2 = result;
    *(_BYTE *)(a2 + 2) = BYTE2(result);
    *(void *)(a2 + 8) = v5;
    *(void *)(a2 + 16) = v6;
  }

  return result;
}

uint64_t sub_1000798AC(void *a1)
{
  return DeprecatedNANAvailabilityEntry.encode(to:)( a1,  *v1 | (*((unsigned __int8 *)v1 + 2) << 16),  *((void *)v1 + 1),  *((void *)v1 + 2));
}

void sub_1000798D0(unsigned __int8 *a1, unsigned __int8 *a2)
{
  if (*a1 == *a2 && a1[1] == a2[1] && a1[2] == a2[2]) {
    _s7CoreP2P6NANPMKV23__derived_struct_equalsySbAC_ACtFZ_0(*((void *)a1 + 1), *((void *)a1 + 2));
  }
}

BOOL sub_100079910(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 16);
  if (v2 != *(void *)(a2 + 16)) {
    return 0LL;
  }
  if (!v2 || a1 == a2) {
    return 1LL;
  }
  if (*(_DWORD *)(a1 + 32) != *(_DWORD *)(a2 + 32)) {
    return 0LL;
  }
  unint64_t v3 = (int *)(a1 + 36);
  Swift::UInt8 v4 = (int *)(a2 + 36);
  uint64_t v5 = v2 - 1;
  do
  {
    BOOL result = v5 == 0;
    if (!v5) {
      break;
    }
    int v8 = *v3++;
    int v7 = v8;
    int v9 = *v4++;
    --v5;
  }

  while (v7 == v9);
  return result;
}

uint64_t _s7CoreP2P12NANAttributeO18PublicAvailabilityV23__derived_struct_equalsySbAE_AEtFZ_0( uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 16);
  if (v2 != *(void *)(a2 + 16)) {
    return 0LL;
  }
  if (v2 && a1 != a2)
  {
    if (*(unsigned __int8 *)(a1 + 32) == *(unsigned __int8 *)(a2 + 32)
      && *(unsigned __int16 *)(a1 + 40) == *(unsigned __int16 *)(a2 + 40))
    {
      __asm { BR              X10 }
    }

    return 0LL;
  }

  return 1LL;
}

uint64_t sub_10007A3AC(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 16);
  if (v2 != *(void *)(a2 + 16)) {
    return 0LL;
  }
  if (v2 && a1 != a2)
  {
    if (*(unsigned __int8 *)(a1 + 32) == *(unsigned __int8 *)(a2 + 32)
      && *(unsigned __int16 *)(a1 + 34) == *(unsigned __int16 *)(a2 + 34)
      && *(unsigned __int8 *)(a1 + 36) == *(unsigned __int8 *)(a2 + 36))
    {
      uint64_t v5 = (unsigned __int8 *)(a2 + 46);
      uint64_t v6 = (unsigned __int8 *)(a1 + 46);
      do
      {
        char v7 = *(v5 - 6);
        if ((*(v6 - 6) & 1) != 0)
        {
          if (!*(v5 - 6)) {
            return 0LL;
          }
        }

        else
        {
          if ((v7 & 1) != 0) {
            return 0LL;
          }
        }

        if (!--v2) {
          return 1LL;
        }
        int v8 = *(v5 - 4);
        int v9 = *((unsigned __int16 *)v5 - 1);
        int v11 = *v5;
        v5 += 10;
        int v10 = v11;
        int v12 = *v6;
        int v13 = *((unsigned __int16 *)v6 - 1);
        int v14 = *(v6 - 4);
        v6 += 10;
      }

      while (v14 == v8 && v13 == v9 && v12 == v10);
    }

    return 0LL;
  }

  return 1LL;
}

BOOL sub_10007A464(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 16);
  if (v2 != *(void *)(a2 + 16)) {
    return 0LL;
  }
  if (!v2 || a1 == a2) {
    return 1LL;
  }
  unint64_t v3 = (unsigned __int8 *)(a1 + 33);
  Swift::UInt8 v4 = (unsigned __int8 *)(a2 + 33);
  uint64_t v5 = v2 - 1;
  do
  {
    BOOL result = v5 == 0;
    if (!v5) {
      break;
    }
    int v8 = *v3++;
    int v7 = v8;
    int v9 = *v4++;
    --v5;
  }

  while (v7 == v9);
  return result;
}

uint64_t sub_10007A4D0(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 16);
  if (v2 != *(void *)(a2 + 16)) {
    return 0LL;
  }
  if (v2 && a1 != a2)
  {
    if (*(_DWORD *)(a1 + 32) == *(_DWORD *)(a2 + 32)
      && ((0x801004u >> (8 * *(_BYTE *)(a1 + 36))) & 0xFFC) == ((0x801004u >> (8 * *(_BYTE *)(a2 + 36))) & 0xFFC))
    {
      uint64_t v3 = a1 + 37;
      for (unint64_t i = (unsigned __int8 *)(a2 + 37); ; i += 8)
      {
        int v5 = *i;
        int v6 = i[1];
        int v7 = *(unsigned __int8 *)(v3 + 1);
        switch(*(_BYTE *)v3)
        {
          case 2:
            if (v5 != 2 || v7 != v6) {
              return 0LL;
            }
            break;
          case 3:
            if (v5 != 3 || v7 != v6) {
              return 0LL;
            }
            break;
          case 4:
            if (v5 != 4 || v7 != v6) {
              return 0LL;
            }
            break;
          case 5:
            if (v5 != 5 || v7 != v6) {
              return 0LL;
            }
            break;
          case 6:
            if (v5 != 6 || v7 != v6) {
              return 0LL;
            }
            break;
          default:
            if (((*(_BYTE *)v3 & 1) == 0) == (v5 & 1) || v7 != v6) {
              return 0LL;
            }
            break;
        }

        if (!--v2) {
          break;
        }
        if (*(_DWORD *)(v3 + 3) != *(_DWORD *)(i + 3)) {
          return 0LL;
        }
        uint64_t result = 0LL;
        char v15 = *(_BYTE *)(v3 + 7);
        v3 += 8LL;
        unsigned __int8 v16 = i[7];
      }

      return 1LL;
    }

    return 0LL;
  }

  return 1LL;
}

uint64_t _s7CoreP2P15AWDLActionFrameV28AWDLChannelSequenceParameterV23__derived_struct_equalsySbAE_AEtFZ_0( uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 16);
  if (v2 != *(void *)(a2 + 16)) {
    return 0LL;
  }
  if (v2 && a1 != a2)
  {
    uint64_t v3 = (unsigned int *)(a1 + 32);
    for (unint64_t i = (unsigned int *)(a2 + 32); ; i += 2)
    {
      unint64_t v5 = *v3 | ((unint64_t)*((unsigned __int16 *)v3 + 2) << 32);
      unint64_t v6 = *i | ((unint64_t)*((unsigned __int16 *)i + 2) << 32);
      uint64_t v7 = v6 & 0xFF00000000LL;
      if ((v5 & 0xFF00000000LL) != 0x300000000LL) {
        break;
      }
      if (v7 != 0x300000000LL) {
        return 0LL;
      }
LABEL_6:
      v3 += 2;
      if (!--v2) {
        return 1LL;
      }
    }

    if (v7 != 0x300000000LL
      && *v3 == *i
      && (0x801004u >> ((v5 >> 29) & 0xF8)) == (0x801004u >> ((v6 >> 29) & 0xF8)))
    {
      unint64_t v8 = v6 >> 40;
      switch(v5 >> 40)
      {
        case 2uLL:
          if ((_DWORD)v8 != 2) {
            return 0LL;
          }
          goto LABEL_6;
        case 3uLL:
          if ((_DWORD)v8 != 3) {
            return 0LL;
          }
          goto LABEL_6;
        case 4uLL:
          if ((_DWORD)v8 != 4) {
            return 0LL;
          }
          goto LABEL_6;
        case 5uLL:
          if ((_DWORD)v8 != 5) {
            return 0LL;
          }
          goto LABEL_6;
        case 6uLL:
          if ((_DWORD)v8 != 6) {
            return 0LL;
          }
          goto LABEL_6;
        default:
          goto LABEL_6;
      }
    }

    return 0LL;
  }

  return 1LL;
}

BOOL _s7CoreP2P15AWDLActionFrameV12SyncTreePathV23__derived_struct_equalsySbAE_AEtFZ_0( uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 16);
  if (v2 != *(void *)(a2 + 16)) {
    return 0LL;
  }
  if (!v2 || a1 == a2) {
    return 1LL;
  }
  uint64_t v3 = v2 - 1;
  uint64_t v4 = a1 + 37;
  uint64_t v5 = a2 + 37;
  do
  {
    int v6 = *(_DWORD *)(v4 - 5) ^ *(_DWORD *)(v5 - 5) | *(unsigned __int16 *)(v4 - 1) ^ *(unsigned __int16 *)(v5 - 1);
    BOOL result = v6 == 0;
    BOOL v9 = v3-- != 0;
    if (v6) {
      break;
    }
    v4 += 6LL;
    v5 += 6LL;
  }

  while (v9);
  return result;
}

uint64_t sub_10007A838(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 16);
  if (v2 != *(void *)(a2 + 16)) {
    return 0LL;
  }
  if (v2)
  {
    if (a1 != a2) {
      __asm { BR              X8 }
    }
  }

  return 1LL;
}

uint64_t _s7CoreP2P12NANAttributeO13ServiceIDListV23__derived_struct_equalsySbAE_AEtFZ_0( uint64_t a1, uint64_t a2)
{
  return sub_10007DA60(a1, a2);
}

uint64_t sub_10007B190(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 16);
  if (v2 != *(void *)(a2 + 16)) {
    return 0LL;
  }
  if (v2 && a1 != a2)
  {
    if (*(unsigned __int8 *)(a1 + 32) == *(unsigned __int8 *)(a2 + 32)
      && *(unsigned __int8 *)(a1 + 33) == *(unsigned __int8 *)(a2 + 33)
      && *(unsigned __int8 *)(a1 + 34) == *(unsigned __int8 *)(a2 + 34))
    {
      __asm { BR              X10 }
    }

    return 0LL;
  }

  return 1LL;
}

uint64_t sub_10007BBCC(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 16);
  if (v2 == *(void *)(a2 + 16))
  {
    if (!v2 || a1 == a2) {
      return 1LL;
    }
    uint64_t v3 = 0LL;
    uint64_t v23 = a2 + 32;
    uint64_t v24 = a1 + 32;
    uint64_t v22 = *(void *)(a1 + 16);
    while (1)
    {
      int v6 = (unsigned __int16 *)(v24 + 56 * v3);
      uint64_t v7 = (unsigned __int16 *)(v23 + 56 * v3);
      if (*v6 != *v7) {
        return 0LL;
      }
      uint64_t v9 = *((void *)v6 + 1);
      uint64_t v8 = *((void *)v6 + 2);
      unint64_t v10 = *((void *)v6 + 3);
      uint64_t v11 = *((void *)v6 + 5);
      uint64_t v12 = *((void *)v7 + 1);
      uint64_t v13 = *((void *)v7 + 2);
      unint64_t v14 = *((void *)v7 + 3);
      uint64_t v5 = *((void *)v7 + 5);
      uint64_t v29 = v12;
      char v25 = *((_BYTE *)v7 + 48);
      char v26 = *((_BYTE *)v6 + 48);
      int v27 = *((unsigned __int8 *)v7 + 32);
      int v28 = *((unsigned __int8 *)v6 + 32);
      if (v10 >> 60 != 15) {
        break;
      }
      if (v14 >> 60 != 15) {
        goto LABEL_34;
      }
      sub_100058430(v9, v8, v10);
      swift_bridgeObjectRetain(v11);
      sub_100058430(v12, v13, v14);
      swift_bridgeObjectRetain(v5);
      if (v28 != v27)
      {
        uint64_t v21 = v12;
        goto LABEL_33;
      }

      if ((v26 & 1) != 0)
      {
        if ((v25 & 1) == 0) {
          goto LABEL_31;
        }
        char v15 = sub_10007A3AC(v11, v5);
        sub_100057CA0(v29, v13, v14);
        swift_bridgeObjectRelease(v5);
        sub_100057CA0(v9, v8, v10);
        swift_bridgeObjectRelease(v11);
        if ((v15 & 1) == 0) {
          return 0LL;
        }
      }

      else
      {
        if ((v25 & 1) != 0 || (uint64_t v16 = *(void *)(v11 + 16), v16 != *(void *)(v5 + 16)))
        {
LABEL_31:
          uint64_t v21 = v12;
LABEL_33:
          sub_100057CA0(v21, v13, v14);
          swift_bridgeObjectRelease(v5);
          sub_100057CA0(v9, v8, v10);
          swift_bridgeObjectRelease(v11);
          return 0LL;
        }

        if (v16)
        {
          if (v11 == v5)
          {
            uint64_t v5 = v11;
          }

          else
          {
            if (v16 != 1)
            {
              uint64_t v17 = 2 - v16;
              uint64_t v18 = 34LL;
              while (v17 + v18 != 34)
              {
                int v19 = *(unsigned __int8 *)(v11 + v18);
                int v20 = *(unsigned __int8 *)(v5 + v18++);
                if (v19 != v20) {
                  goto LABEL_31;
                }
              }
            }
          }
        }

        sub_100057CA0(v12, v13, v14);
        swift_bridgeObjectRelease(v5);
        sub_100057CA0(v9, v8, v10);
        swift_bridgeObjectRelease(v11);
      }

      ++v3;
      uint64_t result = 1LL;
      if (v3 == v22) {
        return result;
      }
    }

    if (v14 >> 60 == 15)
    {
LABEL_34:
      sub_100058430(v9, v8, v10);
      sub_100058430(v12, v13, v14);
      sub_100057CA0(v9, v8, v10);
      sub_100057CA0(v12, v13, v14);
    }

    else if ((unsigned __int16)*((void *)v6 + 1) == (unsigned __int16)v12)
    {
      __asm { BR              X8 }
    }
  }

  return 0LL;
}

uint64_t _s7CoreP2P12NANAttributeO32FineTimingMeasurementRangeReportV23__derived_struct_equalsySbAE_AEtFZ_0( uint64_t a1, uint64_t a2, uint8x8_t a3, uint8x8_t a4)
{
  uint64_t v4 = *(void *)(a1 + 16);
  if (v4 != *(void *)(a2 + 16)) {
    return 0LL;
  }
  if (v4 && a1 != a2)
  {
    for (uint64_t i = 0LL; ; i += 16LL)
    {
      uint64_t v6 = a1 + i;
      uint64_t v7 = a2 + i;
      if (*(_DWORD *)(a1 + i + 32) != *(_DWORD *)(a2 + i + 32)) {
        break;
      }
      uint64_t v8 = 0LL;
      BOOL v10 = *(_DWORD *)(v6 + 36) != *(_DWORD *)(v7 + 36)
         || *(unsigned __int16 *)(v6 + 40) != *(unsigned __int16 *)(v7 + 40);
      a3.i32[0] = *(_DWORD *)(v6 + 42);
      a4.i32[0] = *(_DWORD *)(v7 + 42);
      a4 = (uint8x8_t)vmovl_u8(a4).u64[0];
      a3 = (uint8x8_t)vcltz_s16(vshl_n_s16(vceq_s16((int16x4_t)*(_OWORD *)&vmovl_u8(a3), (int16x4_t)a4), 0xFuLL));
      if (!--v4) {
        return 1LL;
      }
    }

    return 0LL;
  }

  return 1LL;
}

BOOL sub_10007CA54(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 16);
  if (v2 != *(void *)(a2 + 16)) {
    return 0LL;
  }
  if (!v2 || a1 == a2) {
    return 1LL;
  }
  if (*(unsigned __int8 *)(a1 + 32) != *(unsigned __int8 *)(a2 + 32)
    || *(unsigned __int8 *)(a1 + 33) != *(unsigned __int8 *)(a2 + 33))
  {
    return 0LL;
  }

  uint64_t v5 = (unsigned __int8 *)(a2 + 35);
  uint64_t v6 = (unsigned __int8 *)(a1 + 35);
  do
  {
    BOOL result = --v2 == 0;
    if (!v2) {
      break;
    }
    int v7 = *(v5 - 1);
    int v9 = *v5;
    v5 += 2;
    int v8 = v9;
    int v10 = *v6;
    int v11 = *(v6 - 1);
    v6 += 2;
  }

  while (v11 == v7 && v10 == v8);
  return result;
}

uint64_t _s7CoreP2P12NANAttributeO26SecurityContextInformationV23__derived_struct_equalsySbAE_AEtFZ_0( uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 16);
  if (v2 != *(void *)(a2 + 16)) {
    return 0LL;
  }
  if (v2 && a1 != a2)
  {
    if (*(unsigned __int8 *)(a1 + 32) == *(unsigned __int8 *)(a2 + 32)
      && *(unsigned __int8 *)(a1 + 33) == *(unsigned __int8 *)(a2 + 33))
    {
      __asm { BR              X10 }
    }

    return 0LL;
  }

  return 1LL;
}

uint64_t sub_10007D504(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 16);
  if (v2 == *(void *)(a2 + 16))
  {
    if (!v2 || a1 == a2) {
      return 1LL;
    }
    uint64_t v3 = a2 + 38;
    for (uint64_t i = a1 + 38; *(unsigned __int8 *)(i - 6) == *(unsigned __int8 *)(v3 - 6); i += 7LL)
    {
      v3 += 7LL;
      if (!--v2) {
        return 1LL;
      }
    }
  }

  return 0LL;
}

uint64_t sub_10007D5BC(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 16);
  if (v2 != *(void *)(a2 + 16)) {
    return 0LL;
  }
  if (v2 && a1 != a2)
  {
    for (uint64_t i = 0LL; ; i += 14LL)
    {
      __int16 v5 = *(_WORD *)(a1 + i + 38);
      __int16 v6 = *(_WORD *)(a1 + i + 40);
      __int16 v7 = *(_WORD *)(a1 + i + 42);
      __int16 v8 = *(_WORD *)(a1 + i + 44);
      __int16 v9 = *(_WORD *)(a2 + i + 38);
      __int16 v10 = *(_WORD *)(a2 + i + 40);
      __int16 v11 = *(_WORD *)(a2 + i + 42);
      __int16 v12 = *(_WORD *)(a2 + i + 44);
      if (*(_DWORD *)(a1 + i + 32) != *(_DWORD *)(a2 + i + 32)
        || *(unsigned __int16 *)(a1 + i + 36) != *(unsigned __int16 *)(a2 + i + 36))
      {
        break;
      }

      int v14 = v9 & 0xFF00;
      if ((v5 & 0xFF00) == 0x2200)
      {
        if (v14 != 8704) {
          return 0LL;
        }
      }

      else if (v14 == 8704 {
             || word_10033E73C[(char)v5] != word_10033E73C[(char)v9]
      }
             || *(unsigned __int16 *)((char *)&unk_10033E7A8 + (((uint64_t)v5 >> 7) & 0xFFFFFFFFFFFFFELL)) != *(unsigned __int16 *)((char *)&unk_10033E7A8 + (((uint64_t)v9 >> 7) & 0xFFFFFFFFFFFFFELL)))
      {
        return 0LL;
      }

      int v15 = v10 & 0xFF00;
      if ((v6 & 0xFF00) == 0x2200)
      {
        if (v15 != 8704) {
          return 0LL;
        }
      }

      else if (v15 == 8704 {
             || word_10033E73C[(char)v6] != word_10033E73C[(char)v10]
      }
             || *(unsigned __int16 *)((char *)&unk_10033E7A8 + (((uint64_t)v6 >> 7) & 0xFFFFFFFFFFFFFELL)) != *(unsigned __int16 *)((char *)&unk_10033E7A8 + (((uint64_t)v10 >> 7) & 0xFFFFFFFFFFFFFELL)))
      {
        return 0LL;
      }

      int v16 = v11 & 0xFF00;
      if ((v7 & 0xFF00) == 0x2200)
      {
        if (v16 != 8704) {
          return 0LL;
        }
      }

      else if (v16 == 8704 {
             || word_10033E73C[(char)v7] != word_10033E73C[(char)v11]
      }
             || *(unsigned __int16 *)((char *)&unk_10033E7A8 + (((uint64_t)v7 >> 7) & 0xFFFFFFFFFFFFFELL)) != *(unsigned __int16 *)((char *)&unk_10033E7A8 + (((uint64_t)v11 >> 7) & 0xFFFFFFFFFFFFFELL)))
      {
        return 0LL;
      }

      int v17 = v12 & 0xFF00;
      if ((v8 & 0xFF00) == 0x2200)
      {
        if (v17 != 8704) {
          return 0LL;
        }
      }

      else if (v17 == 8704 {
             || word_10033E73C[(char)v8] != word_10033E73C[(char)v12]
      }
             || *(unsigned __int16 *)((char *)&unk_10033E7A8 + (((uint64_t)v8 >> 7) & 0xFFFFFFFFFFFFFELL)) != *(unsigned __int16 *)((char *)&unk_10033E7A8 + (((uint64_t)v12 >> 7) & 0xFFFFFFFFFFFFFELL)))
      {
        return 0LL;
      }

      uint64_t v4 = 1LL;
      if (!--v2) {
        return v4;
      }
    }

    return 0LL;
  }

  return 1LL;
}

uint64_t _s7CoreP2P19InfraScanStartEventV23__derived_struct_equalsySbAC_ACtFZ_0(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 16);
  if (v2 != *(void *)(a2 + 16)) {
    return 0LL;
  }
  if (v2 && a1 != a2)
  {
    if (*(_DWORD *)(a1 + 32) == *(_DWORD *)(a2 + 32)
      && ((0x801004u >> (8 * *(_BYTE *)(a1 + 36))) & 0xFFC) == ((0x801004u >> (8 * *(_BYTE *)(a2 + 36))) & 0xFFC))
    {
      uint64_t v3 = a1 + 37;
      for (uint64_t i = (unsigned __int8 *)(a2 + 37); ; i += 8)
      {
        int v5 = *i;
        switch(*(_BYTE *)v3)
        {
          case 2:
            if (v5 != 2) {
              return 0LL;
            }
            break;
          case 3:
            if (v5 != 3) {
              return 0LL;
            }
            break;
          case 4:
            if (v5 != 4) {
              return 0LL;
            }
            break;
          case 5:
            if (v5 != 5) {
              return 0LL;
            }
            break;
          case 6:
            if (v5 != 6) {
              return 0LL;
            }
            break;
          default:
            break;
        }

        if (!--v2) {
          break;
        }
        if (*(_DWORD *)(v3 + 3) != *(_DWORD *)(i + 3)) {
          return 0LL;
        }
        uint64_t result = 0LL;
        int v7 = (0x801004u >> (8 * *(_BYTE *)(v3 + 7)));
        unsigned int v8 = 0x801004u >> (8 * i[7]);
        v3 += 8LL;
      }

      return 1LL;
    }

    return 0LL;
  }

  return 1LL;
}

BOOL sub_10007D95C(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 16);
  if (v2 != *(void *)(a2 + 16)) {
    return 0LL;
  }
  if (!v2 || a1 == a2) {
    return 1LL;
  }
  uint64_t v3 = (double *)(a1 + 40);
  uint64_t v4 = (double *)(a2 + 40);
  uint64_t v5 = v2 - 1;
  do
  {
    BOOL result = v5 == 0;
    if (!v5) {
      break;
    }
    double v7 = *v3++;
    double v8 = v7;
    double v9 = *v4++;
    --v5;
  }

  while (v8 == v9);
  return result;
}

uint64_t _s7CoreP2P21NANInformationElementV23__derived_struct_equalsySbAC_ACtFZ_0(uint64_t a1, uint64_t a2)
{
  return sub_10007E474( a1,  a2,  type metadata accessor for NANAttribute,  (uint64_t (*)(char *, char *))_s7CoreP2P12NANAttributeO21__derived_enum_equalsySbAC_ACtFZ_0);
}

BOOL sub_10007D9DC(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 16);
  if (v2 != *(void *)(a2 + 16)) {
    return 0LL;
  }
  if (!v2 || a1 == a2) {
    return 1LL;
  }
  uint64_t v3 = (char *)(a1 + 33);
  uint64_t v4 = (char *)(a2 + 33);
  uint64_t v5 = v2 - 1;
  do
  {
    BOOL result = v5 == 0;
    if (!v5) {
      break;
    }
    uint64_t v8 = *v3++;
    uint64_t v7 = v8;
    uint64_t v9 = *v4++;
    --v5;
  }

  while (byte_10033E72E[v7] == byte_10033E72E[v9]);
  return result;
}

uint64_t sub_10007DA60(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 16);
  if (v2 != *(void *)(a2 + 16)) {
    return 0LL;
  }
  if (v2)
  {
    if (a1 != a2) {
      __asm { BR              X8 }
    }
  }

  return 1LL;
}

uint64_t sub_10007E374(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 16);
  if (v2 == *(void *)(a2 + 16))
  {
    if (!v2 || a1 == a2)
    {
      char v7 = 1;
    }

    else
    {
      uint64_t v3 = a1 + 32;
      uint64_t v4 = a2 + 32;
      uint64_t v5 = v2 - 1;
      do
      {
        sub_1000899E8(v3, (uint64_t)v11);
        sub_1000899E8(v4, (uint64_t)v12);
        sub_100089A24( (uint64_t)v11,  (void (*)(void, void, void, void, void, void, void))sub_100058460);
        sub_100089A24( (uint64_t)v12,  (void (*)(void, void, void, void, void, void, void))sub_100058460);
        static IEEE80211InformationElement.__derived_enum_equals(_:_:)((uint64_t)v11);
        char v7 = v6;
        sub_100089A24( (uint64_t)v12,  (void (*)(void, void, void, void, void, void, void))sub_100057CD0);
        sub_100089A24( (uint64_t)v11,  (void (*)(void, void, void, void, void, void, void))sub_100057CD0);
        BOOL v9 = v5-- != 0;
        if ((v7 & 1) == 0) {
          break;
        }
        v4 += 56LL;
        v3 += 56LL;
      }

      while (v9);
    }
  }

  else
  {
    char v7 = 0;
  }

  return v7 & 1;
}

uint64_t sub_10007E460(uint64_t a1, uint64_t a2)
{
  return sub_10007E474( a1,  a2,  type metadata accessor for AWDLActionFrame.AWDLAttribute,  (uint64_t (*)(char *, char *))_s7CoreP2P15AWDLActionFrameV13AWDLAttributeO21__derived_enum_equalsySbAE_AEtFZ_0);
}

uint64_t sub_10007E474( uint64_t a1, uint64_t a2, uint64_t (*a3)(void), uint64_t (*a4)(char *, char *))
{
  uint64_t v8 = a3(0LL);
  uint64_t v9 = __chkstk_darwin(v8);
  __int16 v11 = (char *)&v23 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  __chkstk_darwin(v9);
  int v14 = (char *)&v23 - v13;
  uint64_t v15 = *(void *)(a1 + 16);
  if (v15 == *(void *)(a2 + 16))
  {
    if (!v15 || a1 == a2)
    {
      char v19 = 1;
    }

    else
    {
      unint64_t v16 = (*(unsigned __int8 *)(v12 + 80) + 32LL) & ~(unint64_t)*(unsigned __int8 *)(v12 + 80);
      uint64_t v17 = *(void *)(v12 + 72);
      uint64_t v18 = v15 - 1;
      do
      {
        sub_100057FE8(a1 + v16, (uint64_t)v14, a3);
        sub_100057FE8(a2 + v16, (uint64_t)v11, a3);
        char v19 = a4(v14, v11);
        sub_10005802C((uint64_t)v11, a3);
        sub_10005802C((uint64_t)v14, a3);
        BOOL v21 = v18-- != 0;
        if ((v19 & 1) == 0) {
          break;
        }
        v16 += v17;
      }

      while (v21);
    }
  }

  else
  {
    char v19 = 0;
  }

  return v19 & 1;
}

uint64_t sub_10007E5B0(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 16);
  if (v2 == *(void *)(a2 + 16))
  {
    if (!v2 || a1 == a2) {
      return 1LL;
    }
    if (*(unsigned __int8 *)(a1 + 32) == *(unsigned __int8 *)(a2 + 32)) {
      __asm { BR              X10 }
    }
  }

  return 0LL;
}

uint64_t sub_10007FD10(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 16);
  if (v2 != *(void *)(a2 + 16)) {
    return 0LL;
  }
  if (!v2 || a1 == a2) {
    return 1LL;
  }
  uint64_t v3 = (void *)(a2 + 56);
  for (uint64_t i = (uint64_t *)(a1 + 56); ; i += 4)
  {
    uint64_t v6 = *(i - 1);
    uint64_t v5 = *i;
    uint64_t v8 = *(v3 - 1);
    uint64_t v7 = *v3;
    uint64_t v15 = *(i - 3);
    uint64_t v16 = *(i - 2);
    uint64_t v13 = *(v3 - 3);
    uint64_t v14 = *(v3 - 2);
    swift_bridgeObjectRetain(*v3);
    swift_bridgeObjectRetain(v5);
    if (v15 != v13 || v16 != v14)
    {
      swift_bridgeObjectRelease(v5);
LABEL_20:
      uint64_t v12 = v7;
      goto LABEL_22;
    }

    if (v5) {
      break;
    }
    if (v7) {
      goto LABEL_20;
    }
LABEL_6:
    v3 += 4;
    if (!--v2) {
      return 1LL;
    }
  }

  if (v7)
  {
    if (v6 == v8 && v5 == v7)
    {
      swift_bridgeObjectRelease(v5);
      swift_bridgeObjectRelease(v7);
    }

    else
    {
      char v10 = _stringCompareWithSmolCheck(_:_:expecting:)(v6, v5, v8, v7, 0LL);
      swift_bridgeObjectRelease(v5);
      swift_bridgeObjectRelease(v7);
      if ((v10 & 1) == 0) {
        return 0LL;
      }
    }

    goto LABEL_6;
  }

  uint64_t v12 = v5;
LABEL_22:
  swift_bridgeObjectRelease(v12);
  return 0LL;
}

void sub_10007FE70(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  __asm { BR              X10 }

uint64_t sub_10007FED0( int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, __int16 a10, char __s2, char a12, char a13, char a14, char a15, char a16, char a17, char a18, char a19, char a20, char a21, char a22, char a23, char a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37)
{
  uint64_t v42 = v39;
  __int16 v43 = v40;
  char v44 = BYTE2(v40);
  char v45 = BYTE3(v40);
  char v46 = BYTE4(v40);
  char v47 = BYTE5(v40);
  if (!v38)
  {
    __break(1u);
    JUMPOUT(0x1000800B4LL);
  }

  uint64_t result = memcmp(v38, &v42, BYTE6(v40));
  *unint64_t v37 = (_DWORD)result == 0;
  return result;
}

unint64_t sub_1000800D8()
{
  unint64_t result = qword_1004064E0;
  if (!qword_1004064E0)
  {
    unint64_t result = swift_getWitnessTable(&unk_10033E6DC, &type metadata for NANBitmap.Channel.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_1004064E0);
  }

  return result;
}

uint64_t sub_10008011C(uint64_t result)
{
  uint64_t v1 = 0LL;
  size_t v2 = 0LL;
  uint64_t v3 = (char *)_swiftEmptyArrayStorage;
  uint64_t v4 = (char *)&_swiftEmptyArrayStorage[4];
  int v5 = result;
  do
  {
    if (v1 < -8)
    {
LABEL_14:
      else {
        char v10 = 1 << v1;
      }
      BOOL v6 = __OFADD__(v1++, 1LL);
      if (!v6) {
        goto LABEL_18;
      }
LABEL_34:
      __break(1u);
      break;
    }

    while (v1 < 0)
    {
      int v7 = 0;
      BOOL v9 = __OFADD__(v1, 8LL);
      if ((unint64_t)v1 <= 0xFFFFFFFFFFFFFFF8LL)
      {
        char v10 = 0;
        uint64_t v1 = -7LL;
        if (v9) {
          goto LABEL_34;
        }
        goto LABEL_18;
      }

unint64_t *sub_1000802DC( unint64_t *result, uint64_t a2, uint64_t a3, unint64_t a4, unint64_t a5, unint64_t a6)
{
  if (!a2)
  {
LABEL_5:
    a3 = 0LL;
    goto LABEL_6;
  }

  if (!a3)
  {
LABEL_6:
    unint64_t v7 = a4;
LABEL_7:
    *unint64_t result = a4;
    result[1] = a5;
    result[2] = a6;
    result[3] = v7;
    return (unint64_t *)a3;
  }

  if ((a3 & 0x8000000000000000LL) == 0)
  {
    if (a4 != a5)
    {
      unint64_t v12 = a6;
      unint64_t v8 = a4 + 16;
      if (a4 >= 0xFFFFFFFFFFFFFFF0LL)
      {
LABEL_14:
        __break(1u);
LABEL_15:
        a3 = v6 + 1;
        unint64_t v7 = a5;
      }

      else
      {
        uint64_t v6 = 0LL;
        unsigned int v9 = *((unsigned __int8 *)&v12 + (a4 >> 7));
        unint64_t v7 = a4;
        while (1)
        {
          uint64_t v10 = (v7 >> 4) & 7;
          unint64_t v7 = v8;
          *(_BYTE *)(a2 + v6) = (v9 >> v10) & 1;
          if (a3 - 1 == v6) {
            break;
          }
          if (v8 == a5) {
            goto LABEL_15;
          }
          unint64_t v12 = a6;
          ++v6;
          unsigned int v9 = *((unsigned __int8 *)&v12 + (v8 >> 7));
          BOOL v11 = __CFADD__(v8, 16LL);
          v8 += 16LL;
          if (v11) {
            goto LABEL_14;
          }
        }
      }

      goto LABEL_7;
    }

    goto LABEL_5;
  }

  __break(1u);
  return result;
}

unint64_t sub_100080400( unint64_t result, _BYTE *a2, uint64_t a3, unint64_t a4, unint64_t a5, unint64_t a6)
{
  char v6 = a6;
  unint64_t v9 = result;
  unint64_t v10 = HIBYTE(a6);
  unint64_t v11 = HIWORD(a6);
  unint64_t v12 = a6 >> 40;
  unint64_t v13 = HIDWORD(a6);
  unint64_t v14 = a6 >> 24;
  unint64_t v15 = a6 >> 16;
  unint64_t v16 = a6 >> 8;
  if (!a2) {
    goto LABEL_5;
  }
  if (!a3)
  {
LABEL_6:
    unint64_t v17 = a4;
LABEL_7:
    *(void *)unint64_t v9 = a4;
    *(void *)(v9 + 8) = a5;
    *(_BYTE *)(v9 + 16) = v6;
    *(_BYTE *)(v9 + 17) = v16;
    *(_BYTE *)(v9 + 18) = v15;
    *(_BYTE *)(v9 + 19) = v14;
    *(_BYTE *)(v9 + 20) = v13;
    *(_BYTE *)(v9 + 21) = v12;
    *(_BYTE *)(v9 + 22) = v11;
    *(_BYTE *)(v9 + 23) = v10;
    *(void *)(v9 + 24) = v17;
    return a3;
  }

  if (a3 < 0) {
    goto LABEL_21;
  }
  if (a4 == a5)
  {
LABEL_5:
    a3 = 0LL;
    goto LABEL_6;
  }

  unint64_t v24 = HIBYTE(a6);
  uint64_t v25 = a3;
  unint64_t v26 = a6;
  unint64_t v23 = HIWORD(a6);
  unint64_t result = NANIntervalDuration.timeUnits.getter(0);
  if (!result) {
    goto LABEL_22;
  }
  a3 = v25;
  if (((a4 / result) & 0x8000000000000000LL) != 0)
  {
LABEL_23:
    __break(1u);
    goto LABEL_24;
  }

  unint64_t v17 = a4 + 128;
  LOBYTE(v11) = v23;
  LOBYTE(v10) = v24;
  if (a4 < 0xFFFFFFFFFFFFFF80LL)
  {
    *a2 = *((_BYTE *)&v26 + ((a4 / result) >> 3));
    uint64_t v19 = v25 - 1;
    if (v25 == 1) {
      goto LABEL_7;
    }
    uint64_t v20 = 0LL;
    unint64_t v21 = (char *)&v26 + (v17 >> 7);
    while (v19 != v20)
    {
      if (a5 == v17)
      {
        a3 = v20 + 1;
        unint64_t v17 = a5;
        goto LABEL_7;
      }

      LOBYTE(v26) = v6;
      BYTE1(v26) = v16;
      BYTE2(v26) = v15;
      BYTE3(v26) = v14;
      BYTE4(v26) = v13;
      BYTE5(v26) = v12;
      BYTE6(v26) = v23;
      HIBYTE(v26) = v24;
      unint64_t v22 = v17 + 128;
      if (v17 >= 0xFFFFFFFFFFFFFF80LL) {
        goto LABEL_20;
      }
      a2[v20 + 1] = v21[v20];
      ++v20;
      v17 += 128LL;
      if (v19 == v20)
      {
        unint64_t v17 = v22;
        goto LABEL_7;
      }
    }

    __break(1u);
LABEL_20:
    __break(1u);
LABEL_21:
    __break(1u);
LABEL_22:
    __break(1u);
    goto LABEL_23;
  }

LABEL_24:
  __break(1u);
  return result;
}

  Hasher._combine(_:)(v26);
  unint64_t v33 = v47;
  v21(v47, v0 + v20[9], v1);
  unint64_t v34 = v22(v33, v1);
  if (v34 == v24)
  {
    (*(void (**)(uint64_t *, uint64_t))(v2 + 96))(v33, v1);
    unint64_t v35 = 0x7FFFFFFFFFFFFFFFLL;
    if (*v33 <= 0) {
      unint64_t v35 = 0x8000000000000000LL;
    }
    else {
      uint64_t v36 = v35;
    }
    goto LABEL_39;
  }

  if (v34 == enum case for DispatchTimeInterval.milliseconds(_:))
  {
    (*(void (**)(uint64_t *, uint64_t))(v2 + 96))(v33, v1);
    unint64_t v37 = *v33;
    unint64_t v38 = 1000000LL;
LABEL_34:
    uint64_t v39 = v37 * v38;
    uint64_t v40 = (unsigned __int128)(v37 * (__int128)v38) >> 64 != (v37 * v38) >> 63;
    uint64_t v31 = v37 <= 0;
    unint64_t v41 = 0x7FFFFFFFFFFFFFFFLL;
    if (v31) {
      unint64_t v41 = 0x8000000000000000LL;
    }
    if (v40) {
      uint64_t v36 = v41;
    }
    else {
      uint64_t v36 = v39;
    }
    goto LABEL_39;
  }

  if (v34 == enum case for DispatchTimeInterval.microseconds(_:))
  {
    (*(void (**)(uint64_t *, uint64_t))(v2 + 96))(v33, v1);
    unint64_t v37 = *v33;
    unint64_t v38 = 1000LL;
    goto LABEL_34;
  }

  if (v34 == enum case for DispatchTimeInterval.nanoseconds(_:))
  {
    (*(void (**)(uint64_t *, uint64_t))(v2 + 96))(v33, v1);
    uint64_t v36 = *v33;
  }

  else
  {
    if (v34 != enum case for DispatchTimeInterval.never(_:)) {
      (*(void (**)(uint64_t *, uint64_t))(v2 + 8))(v33, v1);
    }
    uint64_t v36 = 0x7FFFFFFFFFFFFFFFLL;
  }

    int v5 = (v12 - 1) & v12;
    unint64_t v10 = __clz(__rbit64(v12)) + (v8 << 6);
LABEL_5:
    unint64_t result = (*(uint64_t (**)(void))(*(void *)(v1 + 56) + 16 * v10))();
  }

  unint64_t v13 = v11 + 5;
  if (v13 >= v6)
  {
LABEL_25:
    swift_release(v1);
    return swift_bridgeObjectRelease(v1);
  }

  unint64_t v12 = *(void *)(v2 + 8 * v13);
  if (v12)
  {
    unint64_t v8 = v13;
    goto LABEL_24;
  }

  while (1)
  {
    unint64_t v8 = v13 + 1;
    if (__OFADD__(v13, 1LL)) {
      break;
    }
    if (v8 >= v6) {
      goto LABEL_25;
    }
    unint64_t v12 = *(void *)(v2 + 8 * v8);
    ++v13;
    if (v12) {
      goto LABEL_24;
    }
  }

        unint64_t v11 = (v20 - 1) & v20;
        size_t v18 = __clz(__rbit64(v20)) + (v14 << 6);
      }

      unint64_t v22 = (uint64_t *)(*(void *)(v5 + 48) + 16 * v18);
      unint64_t v24 = *v22;
      unint64_t v23 = v22[1];
      uint64_t v25 = (_OWORD *)(*(void *)(v5 + 56) + 32 * v18);
      if ((a2 & 1) != 0)
      {
        sub_100022594(v25, v38);
      }

      else
      {
        sub_100002AE4((uint64_t)v25, (uint64_t)v38);
        swift_bridgeObjectRetain(v23);
      }

      Hasher.init(_seed:)(v37, *(void *)(v8 + 40));
      String.hash(into:)(v37, v24, v23);
      unint64_t result = Hasher._finalize()();
      unint64_t v26 = -1LL << *(_BYTE *)(v8 + 32);
      int v27 = result & ~v26;
      int v28 = v27 >> 6;
      if (((-1LL << v27) & ~*(void *)(v12 + 8 * (v27 >> 6))) != 0)
      {
        unint64_t v15 = __clz(__rbit64((-1LL << v27) & ~*(void *)(v12 + 8 * (v27 >> 6)))) | v27 & 0x7FFFFFFFFFFFFFC0LL;
      }

      else
      {
        uint64_t v29 = 0;
        uint64_t v30 = (unint64_t)(63 - v26) >> 6;
        do
        {
          if (++v28 == v30 && (v29 & 1) != 0)
          {
            __break(1u);
            goto LABEL_43;
          }

          uint64_t v31 = v28 == v30;
          if (v28 == v30) {
            int v28 = 0LL;
          }
          v29 |= v31;
          unint64_t v32 = *(void *)(v12 + 8 * v28);
        }

        while (v32 == -1);
        unint64_t v15 = __clz(__rbit64(~v32)) + (v28 << 6);
      }

      *(void *)(v12 + ((v15 >> 3) & 0x1FFFFFFFFFFFFFF8LL)) |= 1LL << v15;
      unint64_t v16 = (void *)(*(void *)(v8 + 48) + 16 * v15);
      *unint64_t v16 = v24;
      v16[1] = v23;
      unint64_t result = (uint64_t)sub_100022594(v38, (_OWORD *)(*(void *)(v8 + 56) + 32 * v15));
      ++*(void *)(v8 + 16);
    }
  }

  unint64_t result = swift_release(v5);
  *uint64_t v3 = v8;
  return result;
}

  swift_release(v5);
  if ((v23 & 1) == 0) {
    goto LABEL_31;
  }
LABEL_27:
  uint64_t v20 = 1LL << *(_BYTE *)(v5 + 32);
  if (v20 >= 64) {
    bzero(v12, ((unint64_t)(v20 + 63) >> 3) & 0x1FFFFFFFFFFFFFF8LL);
  }
  else {
    *unint64_t v12 = -1LL << v20;
  }
  *(void *)(v5 + 16) = 0LL;
LABEL_31:
  unint64_t result = swift_release(v5);
  *uint64_t v3 = v7;
  return result;
}

    unint64_t v11 = (v21 - 1) & v21;
    size_t v18 = __clz(__rbit64(v21)) + (v15 << 6);
LABEL_25:
    unint64_t v23 = *(void **)(*(void *)(v5 + 48) + 8 * v18);
    unint64_t v24 = (_OWORD *)(*(void *)(v5 + 56) + 32 * v18);
    if ((a2 & 1) != 0)
    {
      sub_100022594(v24, v39);
    }

    else
    {
      sub_100002AE4((uint64_t)v24, (uint64_t)v39);
      uint64_t v25 = v23;
    }

    Hasher.init(_seed:)(v38, *(void *)(v8 + 40));
    type metadata accessor for CFString(0LL);
    int v27 = v26;
    int v28 = sub_10000AF70( &qword_1004050E8,  (uint64_t (*)(uint64_t))type metadata accessor for CFString,  (uint64_t)&unk_10033836C);
    _CFObject.hash(into:)(v38, v27, v28);
    unint64_t result = Hasher._finalize()();
    uint64_t v29 = -1LL << *(_BYTE *)(v8 + 32);
    uint64_t v30 = result & ~v29;
    uint64_t v31 = v30 >> 6;
    if (((-1LL << v30) & ~*(void *)(v13 + 8 * (v30 >> 6))) != 0)
    {
      unint64_t v16 = __clz(__rbit64((-1LL << v30) & ~*(void *)(v13 + 8 * (v30 >> 6)))) | v30 & 0x7FFFFFFFFFFFFFC0LL;
    }

    else
    {
      unint64_t v32 = 0;
      unint64_t v33 = (unint64_t)(63 - v29) >> 6;
      do
      {
        if (++v31 == v33 && (v32 & 1) != 0)
        {
          __break(1u);
          goto LABEL_45;
        }

        unint64_t v34 = v31 == v33;
        if (v31 == v33) {
          uint64_t v31 = 0LL;
        }
        v32 |= v34;
        unint64_t v35 = *(void *)(v13 + 8 * v31);
      }

      while (v35 == -1);
      unint64_t v16 = __clz(__rbit64(~v35)) + (v31 << 6);
    }

    *(void *)(v13 + ((v16 >> 3) & 0x1FFFFFFFFFFFFFF8LL)) |= 1LL << v16;
    *(void *)(*(void *)(v8 + 48) + 8 * v16) = v23;
    unint64_t result = (uint64_t)sub_100022594(v39, (_OWORD *)(*(void *)(v8 + 56) + 32 * v16));
    ++*(void *)(v8 + 16);
  }

  swift_release(v5);
  uint64_t v20 = (void *)(v5 + 64);
  if ((a2 & 1) == 0) {
    goto LABEL_44;
  }
LABEL_40:
  uint64_t v36 = 1LL << *(_BYTE *)(v5 + 32);
  if (v36 >= 64) {
    bzero(v20, ((unint64_t)(v36 + 63) >> 3) & 0x1FFFFFFFFFFFFFF8LL);
  }
  else {
    *uint64_t v20 = -1LL << v36;
  }
  *(void *)(v5 + 16) = 0LL;
LABEL_44:
  unint64_t result = swift_release(v5);
  *uint64_t v3 = v8;
  return result;
}

    unint64_t v11 = (v21 - 1) & v21;
    size_t v18 = __clz(__rbit64(v21)) + (v15 << 6);
LABEL_25:
    unint64_t v23 = *(unsigned __int8 *)(*(void *)(v5 + 48) + v18);
    unint64_t v24 = (_OWORD *)(*(void *)(v5 + 56) + 32 * v18);
    if ((a2 & 1) != 0) {
      sub_100022594(v24, v38);
    }
    else {
      sub_100002AE4((uint64_t)v24, (uint64_t)v38);
    }
    Hasher.init(_seed:)(v37, *(void *)(v8 + 40));
    if (v23) {
      uint64_t v25 = 0x64657463656A6572LL;
    }
    else {
      uint64_t v25 = 0x6553657669746361LL;
    }
    if (v23) {
      unint64_t v26 = 0xEF65636976726553LL;
    }
    else {
      unint64_t v26 = 0xED00006563697672LL;
    }
    String.hash(into:)(v37, v25, v26);
    swift_bridgeObjectRelease(v26);
    unint64_t result = Hasher._finalize()();
    int v27 = -1LL << *(_BYTE *)(v8 + 32);
    int v28 = result & ~v27;
    uint64_t v29 = v28 >> 6;
    if (((-1LL << v28) & ~*(void *)(v13 + 8 * (v28 >> 6))) != 0)
    {
      unint64_t v16 = __clz(__rbit64((-1LL << v28) & ~*(void *)(v13 + 8 * (v28 >> 6)))) | v28 & 0x7FFFFFFFFFFFFFC0LL;
    }

    else
    {
      uint64_t v30 = 0;
      uint64_t v31 = (unint64_t)(63 - v27) >> 6;
      do
      {
        if (++v29 == v31 && (v30 & 1) != 0)
        {
          __break(1u);
          goto LABEL_51;
        }

        unint64_t v32 = v29 == v31;
        if (v29 == v31) {
          uint64_t v29 = 0LL;
        }
        v30 |= v32;
        unint64_t v33 = *(void *)(v13 + 8 * v29);
      }

      while (v33 == -1);
      unint64_t v16 = __clz(__rbit64(~v33)) + (v29 << 6);
    }

    *(void *)(v13 + ((v16 >> 3) & 0x1FFFFFFFFFFFFFF8LL)) |= 1LL << v16;
    *(_BYTE *)(*(void *)(v8 + 48) + v16) = v23;
    unint64_t result = (uint64_t)sub_100022594(v38, (_OWORD *)(*(void *)(v8 + 56) + 32 * v16));
    ++*(void *)(v8 + 16);
  }

  swift_release(v5);
  uint64_t v3 = v35;
  uint64_t v20 = (void *)(v5 + 64);
  if ((a2 & 1) == 0) {
    goto LABEL_50;
  }
LABEL_46:
  unint64_t v34 = 1LL << *(_BYTE *)(v5 + 32);
  if (v34 >= 64) {
    bzero(v20, ((unint64_t)(v34 + 63) >> 3) & 0x1FFFFFFFFFFFFFF8LL);
  }
  else {
    *uint64_t v20 = -1LL << v34;
  }
  *(void *)(v5 + 16) = 0LL;
LABEL_50:
  unint64_t result = swift_release(v5);
  *uint64_t v3 = v8;
  return result;
}

    unint64_t v11 = (v21 - 1) & v21;
    size_t v18 = __clz(__rbit64(v21)) + (v15 << 6);
LABEL_25:
    unint64_t v23 = *(unsigned __int8 *)(*(void *)(v5 + 48) + v18);
    unint64_t v24 = (_OWORD *)(*(void *)(v5 + 56) + 32 * v18);
    if ((a2 & 1) != 0) {
      sub_100022594(v24, v38);
    }
    else {
      sub_100002AE4((uint64_t)v24, (uint64_t)v38);
    }
    Hasher.init(_seed:)(v37, *(void *)(v8 + 40));
    if (v23)
    {
      if (v23 == 1)
      {
        uint64_t v25 = 0xEB00000000726F74LL;
        unint64_t v26 = 0x616974696E497369LL;
      }

      else
      {
        uint64_t v25 = 0xE800000000000000LL;
        unint64_t v26 = 0x6E6F697461727564LL;
      }
    }

    else
    {
      uint64_t v25 = 0xE700000000000000LL;
      unint64_t v26 = 0x65636976726573LL;
    }

    String.hash(into:)(v37, v26, v25);
    swift_bridgeObjectRelease(v25);
    unint64_t result = Hasher._finalize()();
    int v27 = -1LL << *(_BYTE *)(v8 + 32);
    int v28 = result & ~v27;
    uint64_t v29 = v28 >> 6;
    if (((-1LL << v28) & ~*(void *)(v13 + 8 * (v28 >> 6))) != 0)
    {
      unint64_t v16 = __clz(__rbit64((-1LL << v28) & ~*(void *)(v13 + 8 * (v28 >> 6)))) | v28 & 0x7FFFFFFFFFFFFFC0LL;
    }

    else
    {
      uint64_t v30 = 0;
      uint64_t v31 = (unint64_t)(63 - v27) >> 6;
      do
      {
        if (++v29 == v31 && (v30 & 1) != 0)
        {
          __break(1u);
          goto LABEL_50;
        }

        unint64_t v32 = v29 == v31;
        if (v29 == v31) {
          uint64_t v29 = 0LL;
        }
        v30 |= v32;
        unint64_t v33 = *(void *)(v13 + 8 * v29);
      }

      while (v33 == -1);
      unint64_t v16 = __clz(__rbit64(~v33)) + (v29 << 6);
    }

    *(void *)(v13 + ((v16 >> 3) & 0x1FFFFFFFFFFFFFF8LL)) |= 1LL << v16;
    *(_BYTE *)(*(void *)(v8 + 48) + v16) = v23;
    unint64_t result = (uint64_t)sub_100022594(v38, (_OWORD *)(*(void *)(v8 + 56) + 32 * v16));
    ++*(void *)(v8 + 16);
  }

  swift_release(v5);
  uint64_t v3 = v35;
  uint64_t v20 = (void *)(v5 + 64);
  if ((a2 & 1) == 0) {
    goto LABEL_49;
  }
LABEL_45:
  unint64_t v34 = 1LL << *(_BYTE *)(v5 + 32);
  if (v34 >= 64) {
    bzero(v20, ((unint64_t)(v34 + 63) >> 3) & 0x1FFFFFFFFFFFFFF8LL);
  }
  else {
    *uint64_t v20 = -1LL << v34;
  }
  *(void *)(v5 + 16) = 0LL;
LABEL_49:
  unint64_t result = swift_release(v5);
  *uint64_t v3 = v8;
  return result;
}

    unint64_t v11 = (v21 - 1) & v21;
    size_t v18 = __clz(__rbit64(v21)) + (v15 << 6);
LABEL_25:
    unint64_t v23 = *(unsigned __int8 *)(*(void *)(v5 + 48) + v18);
    unint64_t v24 = (_OWORD *)(*(void *)(v5 + 56) + 32 * v18);
    if ((a2 & 1) != 0) {
      sub_100022594(v24, v38);
    }
    else {
      sub_100002AE4((uint64_t)v24, (uint64_t)v38);
    }
    Hasher.init(_seed:)(v37, *(void *)(v8 + 40));
    if (v23) {
      uint64_t v25 = 0x6E6F73616572LL;
    }
    else {
      uint64_t v25 = 0x65636976726573LL;
    }
    if (v23) {
      unint64_t v26 = 0xE600000000000000LL;
    }
    else {
      unint64_t v26 = 0xE700000000000000LL;
    }
    String.hash(into:)(v37, v25, v26);
    swift_bridgeObjectRelease(v26);
    unint64_t result = Hasher._finalize()();
    int v27 = -1LL << *(_BYTE *)(v8 + 32);
    int v28 = result & ~v27;
    uint64_t v29 = v28 >> 6;
    if (((-1LL << v28) & ~*(void *)(v13 + 8 * (v28 >> 6))) != 0)
    {
      unint64_t v16 = __clz(__rbit64((-1LL << v28) & ~*(void *)(v13 + 8 * (v28 >> 6)))) | v28 & 0x7FFFFFFFFFFFFFC0LL;
    }

    else
    {
      uint64_t v30 = 0;
      uint64_t v31 = (unint64_t)(63 - v27) >> 6;
      do
      {
        if (++v29 == v31 && (v30 & 1) != 0)
        {
          __break(1u);
          goto LABEL_51;
        }

        unint64_t v32 = v29 == v31;
        if (v29 == v31) {
          uint64_t v29 = 0LL;
        }
        v30 |= v32;
        unint64_t v33 = *(void *)(v13 + 8 * v29);
      }

      while (v33 == -1);
      unint64_t v16 = __clz(__rbit64(~v33)) + (v29 << 6);
    }

    *(void *)(v13 + ((v16 >> 3) & 0x1FFFFFFFFFFFFFF8LL)) |= 1LL << v16;
    *(_BYTE *)(*(void *)(v8 + 48) + v16) = v23;
    unint64_t result = (uint64_t)sub_100022594(v38, (_OWORD *)(*(void *)(v8 + 56) + 32 * v16));
    ++*(void *)(v8 + 16);
  }

  swift_release(v5);
  uint64_t v3 = v35;
  uint64_t v20 = (void *)(v5 + 64);
  if ((a2 & 1) == 0) {
    goto LABEL_50;
  }
LABEL_46:
  unint64_t v34 = 1LL << *(_BYTE *)(v5 + 32);
  if (v34 >= 64) {
    bzero(v20, ((unint64_t)(v34 + 63) >> 3) & 0x1FFFFFFFFFFFFFF8LL);
  }
  else {
    *uint64_t v20 = -1LL << v34;
  }
  *(void *)(v5 + 16) = 0LL;
LABEL_50:
  unint64_t result = swift_release(v5);
  *uint64_t v3 = v8;
  return result;
}

        unint64_t v14 = (v22 - 1) & v22;
        uint64_t v20 = __clz(__rbit64(v22)) + (v17 << 6);
      }

      unint64_t v24 = *(unsigned __int8 *)(*(void *)(v8 + 48) + v20);
      uint64_t v25 = (_OWORD *)(*(void *)(v8 + 56) + 32 * v20);
      if ((a2 & 1) != 0) {
        sub_100022594(v25, v41);
      }
      else {
        sub_100002AE4((uint64_t)v25, (uint64_t)v41);
      }
      Hasher.init(_seed:)(v40, *(void *)(v11 + 40));
      unint64_t v26 = a4(v24);
      int v28 = v27;
      String.hash(into:)(v40, v26, v27);
      swift_bridgeObjectRelease(v28);
      unint64_t result = Hasher._finalize()();
      uint64_t v29 = -1LL << *(_BYTE *)(v11 + 32);
      uint64_t v30 = result & ~v29;
      uint64_t v31 = v30 >> 6;
      if (((-1LL << v30) & ~*(void *)(v15 + 8 * (v30 >> 6))) != 0)
      {
        size_t v18 = __clz(__rbit64((-1LL << v30) & ~*(void *)(v15 + 8 * (v30 >> 6)))) | v30 & 0x7FFFFFFFFFFFFFC0LL;
      }

      else
      {
        unint64_t v32 = 0;
        unint64_t v33 = (unint64_t)(63 - v29) >> 6;
        do
        {
          if (++v31 == v33 && (v32 & 1) != 0)
          {
            __break(1u);
            goto LABEL_43;
          }

          unint64_t v34 = v31 == v33;
          if (v31 == v33) {
            uint64_t v31 = 0LL;
          }
          v32 |= v34;
          unint64_t v35 = *(void *)(v15 + 8 * v31);
        }

        while (v35 == -1);
        size_t v18 = __clz(__rbit64(~v35)) + (v31 << 6);
      }

      *(void *)(v15 + ((v18 >> 3) & 0x1FFFFFFFFFFFFFF8LL)) |= 1LL << v18;
      *(_BYTE *)(*(void *)(v11 + 48) + v18) = v24;
      unint64_t result = (uint64_t)sub_100022594(v41, (_OWORD *)(*(void *)(v11 + 56) + 32 * v18));
      ++*(void *)(v11 + 16);
    }
  }

  unint64_t result = swift_release(v8);
  *char v6 = v11;
  return result;
}

        unint64_t v12 = (v19 - 1) & v19;
        __int16 v43 = v20;
        unint64_t v17 = __clz(__rbit64(v19)) + (v20 << 6);
      }

      unint64_t v22 = *(void *)(v5 + 56);
      unint64_t v23 = (unsigned __int8 *)(*(void *)(v5 + 48) + 6 * v17);
      unint64_t v24 = v23[5];
      uint64_t v25 = v23[4];
      unint64_t v26 = v23[3];
      int v27 = v23[2];
      int v28 = v23[1];
      uint64_t v29 = *v23;
      char v44 = *(void *)(v22 + 8 * v17);
      Hasher.init(_seed:)(v45, *(void *)(v8 + 40));
      NANClusterChangeEvent.hash(into:)( (int)v45,  (v24 << 40) | (v25 << 32) | (v26 << 24) | (v27 << 16) | (v28 << 8) | v29);
      unint64_t result = Hasher._finalize()();
      uint64_t v30 = -1LL << *(_BYTE *)(v8 + 32);
      uint64_t v31 = result & ~v30;
      unint64_t v32 = v31 >> 6;
      if (((-1LL << v31) & ~*(void *)(v13 + 8 * (v31 >> 6))) != 0)
      {
        unint64_t v14 = __clz(__rbit64((-1LL << v31) & ~*(void *)(v13 + 8 * (v31 >> 6)))) | v31 & 0x7FFFFFFFFFFFFFC0LL;
      }

      else
      {
        unint64_t v33 = 0;
        unint64_t v34 = (unint64_t)(63 - v30) >> 6;
        do
        {
          if (++v32 == v34 && (v33 & 1) != 0)
          {
            __break(1u);
            goto LABEL_42;
          }

          unint64_t v35 = v32 == v34;
          if (v32 == v34) {
            unint64_t v32 = 0LL;
          }
          v33 |= v35;
          uint64_t v36 = *(void *)(v13 + 8 * v32);
        }

        while (v36 == -1);
        unint64_t v14 = __clz(__rbit64(~v36)) + (v32 << 6);
      }

      *(void *)(v13 + ((v14 >> 3) & 0x1FFFFFFFFFFFFFF8LL)) |= 1LL << v14;
      unint64_t v15 = (_BYTE *)(*(void *)(v8 + 48) + 6 * v14);
      *unint64_t v15 = v29;
      v15[1] = v28;
      v15[2] = v27;
      v15[3] = v26;
      v15[4] = v25;
      v15[5] = v24;
      unint64_t v9 = v43;
      *(void *)(*(void *)(v8 + 56) + 8 * v14) = v44;
      ++*(void *)(v8 + 16);
      int v5 = v42;
    }
  }

  unint64_t result = swift_release(v5);
LABEL_41:
  *uint64_t v3 = v8;
  return result;
}

        unint64_t v13 = (v20 - 1) & v20;
        size_t v18 = __clz(__rbit64(v20)) + (v9 << 6);
      }

      unint64_t v22 = *(_BYTE *)(*(void *)(v5 + 48) + v18);
      unint64_t v23 = *(_BYTE *)(*(void *)(v5 + 56) + v18);
      unint64_t result = static Hasher._hash(seed:bytes:count:)(*(void *)(v8 + 40), v22, 1LL);
      unint64_t v24 = -1LL << *(_BYTE *)(v8 + 32);
      uint64_t v25 = result & ~v24;
      unint64_t v26 = v25 >> 6;
      if (((-1LL << v25) & ~*(void *)(v15 + 8 * (v25 >> 6))) != 0)
      {
        unint64_t v16 = __clz(__rbit64((-1LL << v25) & ~*(void *)(v15 + 8 * (v25 >> 6)))) | v25 & 0x7FFFFFFFFFFFFFC0LL;
      }

      else
      {
        int v27 = 0;
        int v28 = (unint64_t)(63 - v24) >> 6;
        do
        {
          if (++v26 == v28 && (v27 & 1) != 0)
          {
            __break(1u);
            goto LABEL_42;
          }

          uint64_t v29 = v26 == v28;
          if (v26 == v28) {
            unint64_t v26 = 0LL;
          }
          v27 |= v29;
          uint64_t v30 = *(void *)(v15 + 8 * v26);
        }

        while (v30 == -1);
        unint64_t v16 = __clz(__rbit64(~v30)) + (v26 << 6);
      }

      *(void *)(v15 + ((v16 >> 3) & 0x1FFFFFFFFFFFFFF8LL)) |= 1LL << v16;
      *(_BYTE *)(*(void *)(v8 + 48) + v16) = v22;
      *(_BYTE *)(*(void *)(v8 + 56) + v16) = v23;
      ++*(void *)(v8 + 16);
    }
  }

  unint64_t result = swift_release(v5);
LABEL_41:
  *uint64_t v3 = v8;
  return result;
}

        unint64_t v12 = (v19 - 1) & v19;
        unint64_t v17 = __clz(__rbit64(v19)) + (v9 << 6);
      }

      unint64_t v21 = (unsigned int *)(*(void *)(v5 + 48) + 8 * v17);
      unint64_t v22 = *((unsigned __int8 *)v21 + 5);
      unint64_t v23 = *((unsigned __int8 *)v21 + 4);
      unint64_t v24 = *v21;
      uint64_t v25 = *(_BYTE *)(*(void *)(v5 + 56) + v17);
      Hasher.init(_seed:)(v38, *(void *)(v8 + 40));
      Channel.hash(into:)((int)v38, (v22 << 40) | (v23 << 32) | v24);
      unint64_t result = Hasher._finalize()();
      unint64_t v26 = -1LL << *(_BYTE *)(v8 + 32);
      int v27 = result & ~v26;
      int v28 = v27 >> 6;
      if (((-1LL << v27) & ~*(void *)(v13 + 8 * (v27 >> 6))) != 0)
      {
        unint64_t v14 = __clz(__rbit64((-1LL << v27) & ~*(void *)(v13 + 8 * (v27 >> 6)))) | v27 & 0x7FFFFFFFFFFFFFC0LL;
      }

      else
      {
        uint64_t v29 = 0;
        uint64_t v30 = (unint64_t)(63 - v26) >> 6;
        do
        {
          if (++v28 == v30 && (v29 & 1) != 0)
          {
            __break(1u);
            goto LABEL_42;
          }

          uint64_t v31 = v28 == v30;
          if (v28 == v30) {
            int v28 = 0LL;
          }
          v29 |= v31;
          unint64_t v32 = *(void *)(v13 + 8 * v28);
        }

        while (v32 == -1);
        unint64_t v14 = __clz(__rbit64(~v32)) + (v28 << 6);
      }

      *(void *)(v13 + ((v14 >> 3) & 0x1FFFFFFFFFFFFFF8LL)) |= 1LL << v14;
      unint64_t v15 = *(void *)(v8 + 48) + 8 * v14;
      *(_DWORD *)unint64_t v15 = v24;
      *(_BYTE *)(v15 + 4) = v23;
      *(_BYTE *)(v15 + 5) = v22;
      *(_BYTE *)(*(void *)(v8 + 56) + v14) = v25;
      ++*(void *)(v8 + 16);
    }
  }

  unint64_t result = swift_release(v5);
LABEL_41:
  *uint64_t v3 = v8;
  return result;
}

        unint64_t v12 = (v20 - 1) & v20;
        size_t v18 = __clz(__rbit64(v20)) + (v9 << 6);
      }

      unint64_t v22 = *(void *)(v5 + 56);
      unint64_t v23 = (unsigned int *)(*(void *)(v5 + 48) + 8 * v18);
      unint64_t v24 = *((unsigned __int8 *)v23 + 5);
      uint64_t v25 = *((unsigned __int8 *)v23 + 4);
      unint64_t v26 = *v23;
      int v27 = (uint64_t *)(v22 + 24 * v18);
      int v28 = v27[2];
      uint64_t v30 = *v27;
      uint64_t v29 = v27[1];
      Hasher.init(_seed:)(v44, *(void *)(v8 + 40));
      Channel.hash(into:)((int)v44, (v24 << 40) | (v25 << 32) | v26);
      unint64_t result = Hasher._finalize()();
      uint64_t v31 = -1LL << *(_BYTE *)(v8 + 32);
      unint64_t v32 = result & ~v31;
      unint64_t v33 = v32 >> 6;
      if (((-1LL << v32) & ~*(void *)(v13 + 8 * (v32 >> 6))) != 0)
      {
        unint64_t v14 = __clz(__rbit64((-1LL << v32) & ~*(void *)(v13 + 8 * (v32 >> 6)))) | v32 & 0x7FFFFFFFFFFFFFC0LL;
      }

      else
      {
        unint64_t v34 = 0;
        unint64_t v35 = (unint64_t)(63 - v31) >> 6;
        do
        {
          if (++v33 == v35 && (v34 & 1) != 0)
          {
            __break(1u);
            goto LABEL_42;
          }

          uint64_t v36 = v33 == v35;
          if (v33 == v35) {
            unint64_t v33 = 0LL;
          }
          v34 |= v36;
          unint64_t v37 = *(void *)(v13 + 8 * v33);
        }

        while (v37 == -1);
        unint64_t v14 = __clz(__rbit64(~v37)) + (v33 << 6);
      }

      *(void *)(v13 + ((v14 >> 3) & 0x1FFFFFFFFFFFFFF8LL)) |= 1LL << v14;
      unint64_t v15 = *(void *)(v8 + 48) + 8 * v14;
      *(_DWORD *)unint64_t v15 = v26;
      *(_BYTE *)(v15 + 4) = v25;
      *(_BYTE *)(v15 + 5) = v24;
      unint64_t v16 = (void *)(*(void *)(v8 + 56) + 24 * v14);
      *unint64_t v16 = v30;
      v16[1] = v29;
      v16[2] = v28;
      ++*(void *)(v8 + 16);
      int v5 = v43;
    }
  }

  unint64_t result = swift_release(v5);
LABEL_41:
  *uint64_t v3 = v8;
  return result;
}

    uint64_t v51 = *v41;
    *(void *)(a1 + 112) = *(void *)(a2 + 112);
    *unint64_t v38 = v51;
    goto LABEL_30;
  }

  if (v40 == 5)
  {
    __int16 v43 = *v42;
    char v44 = *(_OWORD *)(a2 + 96);
    *(void *)(a1 + 112) = *(void *)(a2 + 112);
    char *v39 = v43;
    *(_OWORD *)(a1 + 96) = v44;
    goto LABEL_30;
  }

  *(_BYTE *)(a1 + 80) = *(_BYTE *)(a2 + 80);
  *(_WORD *)(a1 + 82) = *(_WORD *)(a2 + 82);
  char v47 = *(_DWORD *)(a2 + 84);
  *(_BYTE *)(a1 + 88) = *(_BYTE *)(a2 + 88);
  *(_DWORD *)(a1 + 84) = v47;
  *(_WORD *)(a1 + 89) = *(_WORD *)(a2 + 89);
  unint64_t v48 = *(unsigned __int8 *)(a2 + 96);
  if (v48 == 4) {
    goto LABEL_24;
  }
  *(_BYTE *)(a1 + 96) = v48;
LABEL_28:
  Swift::String v53 = *(void *)(a2 + 104);
  uint64_t v54 = *(void *)(a2 + 112);
  sub_100020AFC(v53, v54);
  *(void *)(a1 + 104) = v53;
  *(void *)(a1 + 112) = v54;
LABEL_30:
  unint64_t v59 = (__int128 *)(a1 + 120);
  unsigned __int16 v60 = (__int128 *)(a2 + 120);
  uint64_t v61 = *(unsigned __int8 *)(a2 + 144);
  if (*(unsigned __int8 *)(a1 + 144) == 255)
  {
    if (v61 == 255)
    {
      unint64_t v63 = *v60;
      *(_OWORD *)(a1 + 129) = *(_OWORD *)(a2 + 129);
      char *v59 = v63;
    }

    else
    {
      uint64_t v72 = v61 & 1;
      v73 = *(void *)(a2 + 120);
      int64_t v74 = *(void *)(a2 + 128);
      int v75 = *(void *)(a2 + 136);
      sub_10024B284(v73, v74, v75, v61 & 1);
      *(void *)(a1 + 120) = v73;
      *(void *)(a1 + 128) = v74;
      *(void *)(a1 + 136) = v75;
      *(_BYTE *)(a1 + 144) = v72;
    }
  }

  else if (v61 == 255)
  {
    sub_1000225EC(a1 + 120, &qword_10040D058);
    uint64_t v62 = *(_OWORD *)(a2 + 129);
    char *v59 = *v60;
    *(_OWORD *)(a1 + 129) = v62;
  }

  else
  {
    uint64_t v64 = v61 & 1;
    int64_t v65 = *(void *)(a2 + 120);
    uint64_t v66 = *(void *)(a2 + 128);
    uint64_t v67 = *(void *)(a2 + 136);
    sub_10024B284(v65, v66, v67, v61 & 1);
    v68 = *(void *)(a1 + 120);
    v69 = *(void *)(a1 + 128);
    int v70 = *(void *)(a1 + 136);
    uint64_t v71 = *(_BYTE *)(a1 + 144);
    *(void *)(a1 + 120) = v65;
    *(void *)(a1 + 128) = v66;
    *(void *)(a1 + 136) = v67;
    *(_BYTE *)(a1 + 144) = v64;
    sub_10024B358(v68, v69, v70, v71);
  }

  uint64_t v76 = *(int *)(a3 + 28);
  uint64_t v77 = a1 + v76;
  Swift::UInt v78 = a2 + v76;
  __int128 v79 = type metadata accessor for DispatchTime(0LL);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v79 - 8) + 24LL))(v77, v78, v79);
  return a1;
}

    int v5 = (v17 - 1) & v17;
    unint64_t v9 = __clz(__rbit64(v17)) + (v7 << 6);
LABEL_5:
    unint64_t v10 = (unsigned __int16 *)(*(void *)(a1 + 48) + 6 * v9);
    unint64_t v11 = *(unsigned int *)(v10 + 1);
    unint64_t v12 = *v10;
    swift_bridgeObjectRetain(0x8000000100368340LL);
    v13._countAndFlagsBits = 32LL;
    v13._object = (void *)0xE100000000000000LL;
    String.append(_:)(v13);
    v14._countAndFlagsBits = WiFiAddress.description.getter(v12 | (v11 << 16));
    object = v14._object;
    String.append(_:)(v14);
    swift_bridgeObjectRelease(0x8000000100368340LL);
    swift_bridgeObjectRelease(object);
  }

  size_t v18 = v16 + 5;
  if (v18 >= v6)
  {
LABEL_25:
    swift_release(a1);
    swift_bridgeObjectRelease(a1);
    swift_bridgeObjectRetain(0x8000000100368340LL);
    v19._countAndFlagsBits = 62LL;
    v19._object = (void *)0xE100000000000000LL;
    String.append(_:)(v19);
    swift_bridgeObjectRelease(0x8000000100368340LL);
    return;
  }

  unint64_t v17 = *(void *)(v2 + 8 * v18);
  if (v17)
  {
    unint64_t v7 = v18;
    goto LABEL_24;
  }

  while (1)
  {
    unint64_t v7 = v18 + 1;
    if (__OFADD__(v18, 1LL)) {
      break;
    }
    if (v7 >= v6) {
      goto LABEL_25;
    }
    unint64_t v17 = *(void *)(v2 + 8 * v7);
    ++v18;
    if (v17) {
      goto LABEL_24;
    }
  }

  char v46 = 0LL;
  char v47 = 0xE000000000000000LL;
  _StringGuts.grow(_:)(30LL);
  v37._object = (void *)0x8000000100366D80LL;
  v37._countAndFlagsBits = 0xD00000000000001BLL;
  String.append(_:)(v37);
  _print_unlocked<A, B>(_:_:)( v49,  &v46,  &type metadata for WiFiAddress,  &type metadata for DefaultStringInterpolation,  &protocol witness table for DefaultStringInterpolation);
  v38._countAndFlagsBits = 39LL;
  v38._object = (void *)0xE100000000000000LL;
  String.append(_:)(v38);
  unint64_t result = _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  v46,  v47,  "Swift/NativeDictionary.swift",  28LL,  2LL,  783LL,  0);
  __break(1u);
  return result;
}

      unint64_t v12 = (v18 - 1) & v18;
      unint64_t v16 = __clz(__rbit64(v18)) + (v13 << 6);
    }

    uint64_t v20 = *(void *)(v7 + 72);
    sub_100057FE8(*(void *)(a4 + 48) + v20 * v16, (uint64_t)v9, type metadata accessor for AWDLPeer.AdvertisedService);
    Hasher.init(_seed:)(v33, *(void *)(v10 + 40));
    AWDLPeer.AdvertisedService.hash(into:)((uint64_t)v33);
    unint64_t result = Hasher._finalize()();
    unint64_t v21 = -1LL << *(_BYTE *)(v10 + 32);
    unint64_t v22 = result & ~v21;
    unint64_t v23 = v22 >> 6;
    if (((-1LL << v22) & ~*(void *)(v14 + 8 * (v22 >> 6))) != 0)
    {
      unint64_t v24 = __clz(__rbit64((-1LL << v22) & ~*(void *)(v14 + 8 * (v22 >> 6)))) | v22 & 0x7FFFFFFFFFFFFFC0LL;
    }

    else
    {
      uint64_t v25 = 0;
      unint64_t v26 = (unint64_t)(63 - v21) >> 6;
      do
      {
        if (++v23 == v26 && (v25 & 1) != 0)
        {
          __break(1u);
          goto LABEL_39;
        }

        int v27 = v23 == v26;
        if (v23 == v26) {
          unint64_t v23 = 0LL;
        }
        v25 |= v27;
        int v28 = *(void *)(v14 + 8 * v23);
      }

      while (v28 == -1);
      unint64_t v24 = __clz(__rbit64(~v28)) + (v23 << 6);
    }

    *(void *)(v14 + ((v24 >> 3) & 0x1FFFFFFFFFFFFFF8LL)) |= 1LL << v24;
    unint64_t result = sub_1002B1744((uint64_t)v9, *(void *)(v10 + 48) + v24 * v20);
    ++*(void *)(v10 + 16);
    if (__OFSUB__(a3--, 1LL)) {
      break;
    }
    if (!a3) {
      goto LABEL_37;
    }
  }

      char v52 = (v14 - 1) & v14;
      Swift::String v53 = v15;
      unint64_t v12 = __clz(__rbit64(v14)) + (v15 << 6);
    }

    unint64_t v17 = a4[7];
    size_t v18 = (Swift::UInt8 *)(a4[6] - v12 + 8 * v12);
    uint64_t v19 = *v18;
    uint64_t v20 = v18[1];
    unint64_t v21 = v18[2];
    unint64_t v22 = v18[3];
    unint64_t v23 = v18[4];
    unint64_t v24 = v18[5];
    uint64_t v25 = v18[6];
    unint64_t v26 = v50;
    uint64_t v54 = *(void *)(v51 + 72);
    sub_100057FE8(v17 + v54 * v12, v50, type metadata accessor for NANPeer.Service.AuthenticationStatus);
    int v27 = v25;
    int v28 = v24;
    uint64_t v29 = v23;
    uint64_t v30 = v22;
    uint64_t v31 = v21;
    unint64_t v32 = v20;
    unint64_t v33 = v19;
    sub_100022628(v26, (uint64_t)v56, type metadata accessor for NANPeer.Service.AuthenticationStatus);
    unint64_t v34 = v57;
    Hasher.init(_seed:)(v58, v57[5]);
    Hasher._combine(_:)(v33);
    NANClusterChangeEvent.hash(into:)( (int)v58,  v32 | (v31 << 8) | (v30 << 16) | (v29 << 24) | (v28 << 32) | (v27 << 40));
    unint64_t v35 = Hasher._finalize()();
    uint64_t v36 = -1LL << *((_BYTE *)v34 + 32);
    unint64_t v37 = v35 & ~v36;
    unint64_t v38 = v37 >> 6;
    if (((-1LL << v37) & ~v11[v37 >> 6]) != 0)
    {
      uint64_t v39 = __clz(__rbit64((-1LL << v37) & ~v11[v37 >> 6])) | v37 & 0x7FFFFFFFFFFFFFC0LL;
      unint64_t result = v56;
    }

    else
    {
      uint64_t v40 = 0;
      unint64_t v41 = (unint64_t)(63 - v36) >> 6;
      unint64_t result = v56;
      do
      {
        if (++v38 == v41 && (v40 & 1) != 0)
        {
          __break(1u);
          goto LABEL_39;
        }

        uint64_t v42 = v38 == v41;
        if (v38 == v41) {
          unint64_t v38 = 0LL;
        }
        v40 |= v42;
        __int16 v43 = v11[v38];
      }

      while (v43 == -1);
      uint64_t v39 = __clz(__rbit64(~v43)) + (v38 << 6);
    }

    *(void *)((char *)v11 + ((v39 >> 3) & 0x1FFFFFFFFFFFFFF8LL)) |= 1LL << v39;
    char v44 = v57;
    char v45 = (Swift::UInt8 *)(v57[6] - v39 + 8 * v39);
    *char v45 = v33;
    v45[1] = v32;
    v45[2] = v31;
    v45[3] = v30;
    v45[4] = v29;
    v45[5] = v28;
    v45[6] = v27;
    unint64_t result = (void *)sub_100022628( (uint64_t)result,  v44[7] + v39 * v54,  type metadata accessor for NANPeer.Service.AuthenticationStatus);
    ++v44[2];
    a3 = v55 - 1;
    if (__OFSUB__(v55, 1LL)) {
      break;
    }
    a4 = v49;
    unint64_t v9 = v52;
    unint64_t v10 = v53;
    if (v55 == 1) {
      return v57;
    }
  }

      char v44 = (v18 - 1) & v18;
      char v45 = v19;
      unint64_t v16 = __clz(__rbit64(v18)) + (v19 << 6);
    }

    unint64_t v21 = v42;
    unint64_t v22 = v43;
    unint64_t v23 = *(void *)(v43 + 72);
    (*(void (**)(char *, unint64_t, uint64_t))(v43 + 16))(v42, a4[6] + v23 * v16, v15);
    unint64_t v24 = *(void **)(a4[7] + 8 * v16);
    uint64_t v25 = *(void (**)(char *, char *, uint64_t))(v22 + 32);
    v25(v46, v21, v15);
    unint64_t v26 = *(void *)(v11 + 40);
    int v27 = sub_10000AF70( &qword_10040F8C0,  (uint64_t (*)(uint64_t))&type metadata accessor for UUID,  (uint64_t)&protocol conformance descriptor for UUID);
    int v28 = v24;
    unint64_t result = dispatch thunk of Hashable._rawHashValue(seed:)(v26, v15, v27);
    uint64_t v29 = -1LL << *(_BYTE *)(v11 + 32);
    uint64_t v30 = result & ~v29;
    uint64_t v31 = v30 >> 6;
    if (((-1LL << v30) & ~*(void *)(v14 + 8 * (v30 >> 6))) != 0)
    {
      unint64_t v32 = __clz(__rbit64((-1LL << v30) & ~*(void *)(v14 + 8 * (v30 >> 6)))) | v30 & 0x7FFFFFFFFFFFFFC0LL;
    }

    else
    {
      unint64_t v33 = 0;
      unint64_t v34 = (unint64_t)(63 - v29) >> 6;
      do
      {
        if (++v31 == v34 && (v33 & 1) != 0)
        {
          __break(1u);
          goto LABEL_39;
        }

        unint64_t v35 = v31 == v34;
        if (v31 == v34) {
          uint64_t v31 = 0LL;
        }
        v33 |= v35;
        uint64_t v36 = *(void *)(v14 + 8 * v31);
      }

      while (v36 == -1);
      unint64_t v32 = __clz(__rbit64(~v36)) + (v31 << 6);
    }

    *(void *)(v14 + ((v32 >> 3) & 0x1FFFFFFFFFFFFFF8LL)) |= 1LL << v32;
    unint64_t result = ((uint64_t (*)(unint64_t, char *, uint64_t))v25)( *(void *)(v11 + 48) + v32 * v23,  v46,  v47);
    *(void *)(*(void *)(v11 + 56) + 8 * v32) = v28;
    ++*(void *)(v11 + 16);
    if (__OFSUB__(a3--, 1LL)) {
      break;
    }
    a4 = v41;
    unint64_t v12 = v44;
    unint64_t v13 = v45;
    if (!a3) {
      return v11;
    }
  }

      unint64_t v37 = (v13 - 1) & v13;
      unint64_t v38 = v14;
      unint64_t v11 = __clz(__rbit64(v13)) + (v14 << 6);
    }

    unint64_t v16 = *(void *)(v4 + 56);
    unint64_t v17 = (unsigned __int8 *)(*(void *)(v4 + 48) + 6 * v11);
    size_t v18 = *v17;
    uint64_t v19 = v17[1];
    uint64_t v20 = v17[2];
    unint64_t v21 = v17[3];
    unint64_t v22 = v17[4];
    unint64_t v23 = v17[5];
    uint64_t v39 = *(void *)(v16 + 8 * v11);
    Hasher.init(_seed:)(v40, *(void *)(v7 + 40));
    NANClusterChangeEvent.hash(into:)( (int)v40,  v18 | (v19 << 8) | (v20 << 16) | (v21 << 24) | (v22 << 32) | (v23 << 40));
    unint64_t result = Hasher._finalize()();
    unint64_t v24 = -1LL << *(_BYTE *)(v7 + 32);
    uint64_t v25 = result & ~v24;
    unint64_t v26 = v25 >> 6;
    if (((-1LL << v25) & ~*(void *)(v10 + 8 * (v25 >> 6))) != 0)
    {
      int v27 = __clz(__rbit64((-1LL << v25) & ~*(void *)(v10 + 8 * (v25 >> 6)))) | v25 & 0x7FFFFFFFFFFFFFC0LL;
    }

    else
    {
      int v28 = 0;
      uint64_t v29 = (unint64_t)(63 - v24) >> 6;
      do
      {
        if (++v26 == v29 && (v28 & 1) != 0)
        {
          __break(1u);
          goto LABEL_39;
        }

        uint64_t v30 = v26 == v29;
        if (v26 == v29) {
          unint64_t v26 = 0LL;
        }
        v28 |= v30;
        uint64_t v31 = *(void *)(v10 + 8 * v26);
      }

      while (v31 == -1);
      int v27 = __clz(__rbit64(~v31)) + (v26 << 6);
    }

    *(void *)(v10 + ((v27 >> 3) & 0x1FFFFFFFFFFFFFF8LL)) |= 1LL << v27;
    unint64_t v32 = (_BYTE *)(*(void *)(v7 + 48) + 6 * v27);
    *unint64_t v32 = v18;
    v32[1] = v19;
    v32[2] = v20;
    v32[3] = v21;
    v32[4] = v22;
    v32[5] = v23;
    unint64_t result = v39;
    *(void *)(*(void *)(v7 + 56) + 8 * v27) = v39;
    ++*(void *)(v7 + 16);
    if (__OFSUB__(v5--, 1LL)) {
      break;
    }
    unint64_t result = swift_bridgeObjectRetain(v39);
    uint64_t v4 = v36;
    unint64_t v8 = v37;
    unint64_t v9 = v38;
    if (!v5) {
      return v7;
    }
  }

      char v46 = (v15 - 1) & v15;
      char v47 = v16;
      unint64_t v13 = __clz(__rbit64(v15)) + (v16 << 6);
    }

    size_t v18 = a4[7];
    uint64_t v19 = (unsigned __int8 *)(a4[6] + 6 * v13);
    uint64_t v20 = *v19;
    unint64_t v21 = v19[1];
    unint64_t v22 = v19[2];
    unint64_t v23 = v19[3];
    unint64_t v24 = v19[4];
    uint64_t v25 = v19[5];
    unint64_t v26 = v44;
    unint64_t v48 = *(void *)(v45 + 72);
    sub_100057FE8(v18 + v48 * v13, v44, type metadata accessor for NANPeer);
    sub_100022628(v26, v12, type metadata accessor for NANPeer);
    int v27 = v50;
    Hasher.init(_seed:)(v51, v50[5]);
    NANClusterChangeEvent.hash(into:)( (int)v51,  v20 | (v21 << 8) | (v22 << 16) | (v23 << 24) | (v24 << 32) | (v25 << 40));
    int v28 = Hasher._finalize()();
    uint64_t v29 = -1LL << *((_BYTE *)v27 + 32);
    uint64_t v30 = v28 & ~v29;
    uint64_t v31 = v30 >> 6;
    if (((-1LL << v30) & ~v11[v30 >> 6]) != 0)
    {
      unint64_t v32 = __clz(__rbit64((-1LL << v30) & ~v11[v30 >> 6])) | v30 & 0x7FFFFFFFFFFFFFC0LL;
      unint64_t result = v43;
    }

    else
    {
      unint64_t v33 = 0;
      unint64_t v34 = (unint64_t)(63 - v29) >> 6;
      unint64_t result = v43;
      do
      {
        if (++v31 == v34 && (v33 & 1) != 0)
        {
          __break(1u);
          goto LABEL_39;
        }

        unint64_t v35 = v31 == v34;
        if (v31 == v34) {
          uint64_t v31 = 0LL;
        }
        v33 |= v35;
        uint64_t v36 = v11[v31];
      }

      while (v36 == -1);
      unint64_t v32 = __clz(__rbit64(~v36)) + (v31 << 6);
    }

    *(void *)((char *)v11 + ((v32 >> 3) & 0x1FFFFFFFFFFFFFF8LL)) |= 1LL << v32;
    unint64_t v37 = v50;
    unint64_t v38 = (_BYTE *)(v50[6] + 6 * v32);
    *unint64_t v38 = v20;
    v38[1] = v21;
    v38[2] = v22;
    v38[3] = v23;
    v38[4] = v24;
    v38[5] = v25;
    unint64_t v12 = (uint64_t)result;
    unint64_t result = (void *)sub_100022628((uint64_t)result, v37[7] + v32 * v48, type metadata accessor for NANPeer);
    ++v37[2];
    a3 = v49 - 1;
    if (__OFSUB__(v49, 1LL)) {
      break;
    }
    a4 = v42;
    unint64_t v9 = v46;
    unint64_t v10 = v47;
    if (v49 == 1) {
      return v50;
    }
  }

      unint64_t v9 = (v15 - 1) & v15;
      uint64_t v39 = v16;
      unint64_t v13 = __clz(__rbit64(v15)) + (v16 << 6);
    }

    size_t v18 = *(void *)(v4 + 56);
    uint64_t v19 = *(void *)(v4 + 48) + 24 * v13;
    unint64_t v21 = *(void *)v19;
    uint64_t v20 = *(void *)(v19 + 8);
    unint64_t v22 = *(unsigned __int8 *)(v19 + 16);
    unint64_t v23 = *(_BYTE *)(v19 + 17);
    uint64_t v40 = *(void *)(v18 + 8 * v13);
    Hasher.init(_seed:)(v41, *(void *)(v8 + 40));
    unint64_t v24 = String.lowercased()();
    swift_bridgeObjectRetain(v20);
    String.hash(into:)(v41, v24._countAndFlagsBits, v24._object);
    swift_bridgeObjectRelease(v24._object);
    uint64_t v25 = v22 ? 7365749LL : 7365492LL;
    String.hash(into:)(v41, v25, 0xE300000000000000LL);
    swift_bridgeObjectRelease(0xE300000000000000LL);
    Hasher._combine(_:)(v23);
    unint64_t result = Hasher._finalize()();
    unint64_t v26 = -1LL << *(_BYTE *)(v8 + 32);
    int v27 = result & ~v26;
    int v28 = v27 >> 6;
    if (((-1LL << v27) & ~*(void *)(v11 + 8 * (v27 >> 6))) != 0)
    {
      uint64_t v29 = __clz(__rbit64((-1LL << v27) & ~*(void *)(v11 + 8 * (v27 >> 6)))) | v27 & 0x7FFFFFFFFFFFFFC0LL;
    }

    else
    {
      uint64_t v30 = 0;
      uint64_t v31 = (unint64_t)(63 - v26) >> 6;
      do
      {
        if (++v28 == v31 && (v30 & 1) != 0)
        {
          __break(1u);
          goto LABEL_42;
        }

        unint64_t v32 = v28 == v31;
        if (v28 == v31) {
          int v28 = 0LL;
        }
        v30 |= v32;
        unint64_t v33 = *(void *)(v11 + 8 * v28);
      }

      while (v33 == -1);
      uint64_t v29 = __clz(__rbit64(~v33)) + (v28 << 6);
    }

    *(void *)(v11 + ((v29 >> 3) & 0x1FFFFFFFFFFFFFF8LL)) |= 1LL << v29;
    unint64_t v34 = *(void *)(v8 + 48) + 24 * v29;
    *(void *)unint64_t v34 = v21;
    *(void *)(v34 + 8) = v20;
    *(_BYTE *)(v34 + 16) = v22;
    *(_BYTE *)(v34 + 17) = v23;
    *(void *)(*(void *)(v8 + 56) + 8 * v29) = v40;
    ++*(void *)(v8 + 16);
    if (__OFSUB__(v5--, 1LL)) {
      break;
    }
    uint64_t v4 = v38;
    unint64_t v10 = v39;
    if (!v5) {
      return v8;
    }
  }

  swift_release(v3);
  size_t v2 = v18;
  unint64_t v16 = 1LL << *(_BYTE *)(v3 + 32);
  if (v16 > 63) {
    bzero((void *)(v3 + 56), ((unint64_t)(v16 + 63) >> 3) & 0x1FFFFFFFFFFFFFF8LL);
  }
  else {
    *unint64_t v7 = -1LL << v16;
  }
  *(void *)(v3 + 16) = 0LL;
LABEL_28:
  unint64_t result = swift_release(v3);
  *size_t v2 = v5;
  return result;
}

  unint64_t result = swift_release_n(v3, 2LL);
  size_t v2 = v16;
LABEL_26:
  *size_t v2 = v5;
  return result;
}

uint64_t sub_1000805A8(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8 = type metadata accessor for LongTermPairingKeys.PublicIdentity(0LL);
  uint64_t v9 = *(void *)(v8 - 8);
  uint64_t v10 = __chkstk_darwin(v8);
  unint64_t v12 = (char *)&v29 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t result = __chkstk_darwin(v10);
  unint64_t v15 = (char *)&v29 - v14;
  uint64_t v17 = a4 + 64;
  uint64_t v16 = *(void *)(a4 + 64);
  uint64_t v32 = -1LL << *(_BYTE *)(a4 + 32);
  if (-v32 < 64) {
    uint64_t v18 = ~(-1LL << -(char)v32);
  }
  else {
    uint64_t v18 = -1LL;
  }
  unint64_t v19 = v18 & v16;
  if (!a2)
  {
    int64_t v20 = 0LL;
    a3 = 0LL;
LABEL_34:
    uint64_t v28 = ~v32;
    *a1 = a4;
    a1[1] = v17;
    a1[2] = v28;
    a1[3] = v20;
    a1[4] = v19;
    return a3;
  }

  if (!a3)
  {
    int64_t v20 = 0LL;
    goto LABEL_34;
  }

  if (a3 < 0)
  {
LABEL_41:
    __break(1u);
    goto LABEL_42;
  }

  uint64_t v31 = a1;
  int64_t v20 = 0LL;
  uint64_t v21 = 0LL;
  uint64_t v33 = a4 + 64;
  int64_t v34 = (unint64_t)(63 - v32) >> 6;
  int64_t v30 = v34 - 1;
  if (!v19) {
    goto LABEL_9;
  }
LABEL_8:
  unint64_t v22 = __clz(__rbit64(v19));
  v19 &= v19 - 1;
  unint64_t v23 = v22 | (v20 << 6);
  while (1)
  {
    ++v21;
    uint64_t v27 = *(void *)(v9 + 72);
    sub_100057FE8( *(void *)(a4 + 56) + v27 * v23,  (uint64_t)v12,  type metadata accessor for LongTermPairingKeys.PublicIdentity);
    sub_100089A60((uint64_t)v12, (uint64_t)v15);
    uint64_t result = sub_100089A60((uint64_t)v15, a2);
    if (v21 == a3) {
      goto LABEL_33;
    }
    a2 += v27;
    if (v19) {
      goto LABEL_8;
    }
LABEL_9:
    int64_t v24 = v20 + 1;
    if (__OFADD__(v20, 1LL))
    {
      __break(1u);
      goto LABEL_41;
    }

    if (v24 >= v34)
    {
      unint64_t v19 = 0LL;
      a3 = v21;
LABEL_33:
      a1 = v31;
      uint64_t v17 = v33;
      goto LABEL_34;
    }

    uint64_t v17 = v33;
    unint64_t v25 = *(void *)(v33 + 8 * v24);
    if (!v25) {
      break;
    }
LABEL_18:
    unint64_t v19 = (v25 - 1) & v25;
    unint64_t v23 = __clz(__rbit64(v25)) + (v24 << 6);
    int64_t v20 = v24;
  }

  v20 += 2LL;
  if (v24 + 1 >= v34)
  {
    unint64_t v19 = 0LL;
    int64_t v20 = v24;
LABEL_39:
    a3 = v21;
    a1 = v31;
    goto LABEL_34;
  }

  unint64_t v25 = *(void *)(v33 + 8 * v20);
  if (v25) {
    goto LABEL_14;
  }
  int64_t v26 = v24 + 2;
  if (v24 + 2 >= v34) {
    goto LABEL_36;
  }
  unint64_t v25 = *(void *)(v33 + 8 * v26);
  if (v25) {
    goto LABEL_17;
  }
  int64_t v20 = v24 + 3;
  if (v24 + 3 >= v34)
  {
    unint64_t v19 = 0LL;
    int64_t v20 = v24 + 2;
    goto LABEL_39;
  }

  unint64_t v25 = *(void *)(v33 + 8 * v20);
  if (v25)
  {
LABEL_14:
    int64_t v24 = v20;
    goto LABEL_18;
  }

  int64_t v26 = v24 + 4;
  if (v24 + 4 >= v34)
  {
LABEL_36:
    unint64_t v19 = 0LL;
    goto LABEL_39;
  }

  unint64_t v25 = *(void *)(v33 + 8 * v26);
  if (v25)
  {
LABEL_17:
    int64_t v24 = v26;
    goto LABEL_18;
  }

  while (1)
  {
    int64_t v24 = v26 + 1;
    if (__OFADD__(v26, 1LL)) {
      break;
    }
    if (v24 >= v34)
    {
      unint64_t v19 = 0LL;
      int64_t v20 = v30;
      goto LABEL_39;
    }

    unint64_t v25 = *(void *)(v33 + 8 * v24);
    ++v26;
    if (v25) {
      goto LABEL_18;
    }
  }

void *sub_100080854(void *result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = a4 + 64;
  uint64_t v5 = -1LL;
  uint64_t v6 = -1LL << *(_BYTE *)(a4 + 32);
  if (-v6 < 64) {
    uint64_t v5 = ~(-1LL << -(char)v6);
  }
  unint64_t v7 = v5 & *(void *)(a4 + 64);
  if (!a2)
  {
    int64_t v8 = 0LL;
    a3 = 0LL;
LABEL_35:
    *uint64_t result = a4;
    result[1] = v4;
    result[2] = ~v6;
    result[3] = v8;
    result[4] = v7;
    return (void *)a3;
  }

  if (!a3)
  {
    int64_t v8 = 0LL;
    goto LABEL_35;
  }

  if (a3 < 0)
  {
LABEL_37:
    __break(1u);
    goto LABEL_38;
  }

  int64_t v8 = 0LL;
  uint64_t v9 = 0LL;
  int64_t v10 = (unint64_t)(63 - v6) >> 6;
  while (v7)
  {
    unint64_t v11 = __clz(__rbit64(v7));
    v7 &= v7 - 1;
    unint64_t v12 = v11 | (v8 << 6);
LABEL_8:
    ++v9;
    uint64_t v13 = *(void *)(a4 + 48) + 8 * v12;
    int v14 = *(_DWORD *)v13;
    char v15 = *(_BYTE *)(*(void *)(a4 + 56) + v12);
    LOWORD(v13) = *(_WORD *)(v13 + 4);
    *(_DWORD *)a2 = v14;
    *(_WORD *)(a2 + 4) = v13;
    *(_BYTE *)(a2 + 6) = v15;
    a2 += 8LL;
    if (v9 == a3) {
      goto LABEL_35;
    }
  }

  int64_t v16 = v8 + 1;
  if (__OFADD__(v8, 1LL))
  {
    __break(1u);
    goto LABEL_37;
  }

  if (v16 >= v10) {
    goto LABEL_30;
  }
  unint64_t v17 = *(void *)(v4 + 8 * v16);
  if (v17) {
    goto LABEL_19;
  }
  v8 += 2LL;
  if (v16 + 1 >= v10)
  {
    unint64_t v7 = 0LL;
    int64_t v8 = v16;
    goto LABEL_34;
  }

  unint64_t v17 = *(void *)(v4 + 8 * v8);
  if (v17)
  {
LABEL_15:
    int64_t v16 = v8;
LABEL_19:
    unint64_t v19 = __clz(__rbit64(v17));
    unint64_t v7 = (v17 - 1) & v17;
    unint64_t v12 = v19 + (v16 << 6);
    int64_t v8 = v16;
    goto LABEL_8;
  }

  int64_t v18 = v16 + 2;
  if (v16 + 2 >= v10) {
    goto LABEL_30;
  }
  unint64_t v17 = *(void *)(v4 + 8 * v18);
  if (v17)
  {
LABEL_18:
    int64_t v16 = v18;
    goto LABEL_19;
  }

  int64_t v8 = v16 + 3;
  if (v16 + 3 >= v10)
  {
    unint64_t v7 = 0LL;
    int64_t v8 = v16 + 2;
    goto LABEL_34;
  }

  unint64_t v17 = *(void *)(v4 + 8 * v8);
  if (v17) {
    goto LABEL_15;
  }
  int64_t v18 = v16 + 4;
  if (v16 + 4 >= v10)
  {
LABEL_30:
    unint64_t v7 = 0LL;
LABEL_34:
    a3 = v9;
    goto LABEL_35;
  }

  unint64_t v17 = *(void *)(v4 + 8 * v18);
  if (v17) {
    goto LABEL_18;
  }
  while (1)
  {
    int64_t v16 = v18 + 1;
    if (__OFADD__(v18, 1LL)) {
      break;
    }
    if (v16 >= v10)
    {
      unint64_t v7 = 0LL;
      int64_t v8 = v10 - 1;
      goto LABEL_34;
    }

    unint64_t v17 = *(void *)(v4 + 8 * v16);
    ++v18;
    if (v17) {
      goto LABEL_19;
    }
  }

void *sub_100080A00(void *result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = a4 + 64;
  uint64_t v5 = -1LL;
  uint64_t v6 = -1LL << *(_BYTE *)(a4 + 32);
  if (-v6 < 64) {
    uint64_t v5 = ~(-1LL << -(char)v6);
  }
  unint64_t v7 = v5 & *(void *)(a4 + 64);
  if (!a2)
  {
    int64_t v8 = 0LL;
    a3 = 0LL;
LABEL_35:
    *uint64_t result = a4;
    result[1] = v4;
    result[2] = ~v6;
    result[3] = v8;
    result[4] = v7;
    return (void *)a3;
  }

  if (!a3)
  {
    int64_t v8 = 0LL;
    goto LABEL_35;
  }

  if (a3 < 0)
  {
LABEL_37:
    __break(1u);
    goto LABEL_38;
  }

  int64_t v8 = 0LL;
  uint64_t v9 = 0LL;
  int64_t v10 = (unint64_t)(63 - v6) >> 6;
  while (v7)
  {
    unint64_t v11 = __clz(__rbit64(v7));
    v7 &= v7 - 1;
    unint64_t v12 = v11 | (v8 << 6);
LABEL_8:
    ++v9;
    uint64_t v13 = *(void *)(a4 + 48) + 8 * v12;
    int v14 = *(_DWORD *)v13;
    LOWORD(v13) = *(_WORD *)(v13 + 4);
    uint64_t v15 = *(void *)(a4 + 56) + 24 * v12;
    __int128 v16 = *(_OWORD *)v15;
    uint64_t v17 = *(void *)(v15 + 16);
    *(_DWORD *)a2 = v14;
    *(_WORD *)(a2 + 4) = v13;
    *(_OWORD *)(a2 + 8) = v16;
    *(void *)(a2 + 24) = v17;
    a2 += 32LL;
    if (v9 == a3) {
      goto LABEL_35;
    }
  }

  int64_t v18 = v8 + 1;
  if (__OFADD__(v8, 1LL))
  {
    __break(1u);
    goto LABEL_37;
  }

  if (v18 >= v10) {
    goto LABEL_30;
  }
  unint64_t v19 = *(void *)(v4 + 8 * v18);
  if (v19) {
    goto LABEL_19;
  }
  v8 += 2LL;
  if (v18 + 1 >= v10)
  {
    unint64_t v7 = 0LL;
    int64_t v8 = v18;
    goto LABEL_34;
  }

  unint64_t v19 = *(void *)(v4 + 8 * v8);
  if (v19)
  {
LABEL_15:
    int64_t v18 = v8;
LABEL_19:
    unint64_t v21 = __clz(__rbit64(v19));
    unint64_t v7 = (v19 - 1) & v19;
    unint64_t v12 = v21 + (v18 << 6);
    int64_t v8 = v18;
    goto LABEL_8;
  }

  int64_t v20 = v18 + 2;
  if (v18 + 2 >= v10) {
    goto LABEL_30;
  }
  unint64_t v19 = *(void *)(v4 + 8 * v20);
  if (v19)
  {
LABEL_18:
    int64_t v18 = v20;
    goto LABEL_19;
  }

  int64_t v8 = v18 + 3;
  if (v18 + 3 >= v10)
  {
    unint64_t v7 = 0LL;
    int64_t v8 = v18 + 2;
    goto LABEL_34;
  }

  unint64_t v19 = *(void *)(v4 + 8 * v8);
  if (v19) {
    goto LABEL_15;
  }
  int64_t v20 = v18 + 4;
  if (v18 + 4 >= v10)
  {
LABEL_30:
    unint64_t v7 = 0LL;
LABEL_34:
    a3 = v9;
    goto LABEL_35;
  }

  unint64_t v19 = *(void *)(v4 + 8 * v20);
  if (v19) {
    goto LABEL_18;
  }
  while (1)
  {
    int64_t v18 = v20 + 1;
    if (__OFADD__(v20, 1LL)) {
      break;
    }
    if (v18 >= v10)
    {
      unint64_t v7 = 0LL;
      int64_t v8 = v10 - 1;
      goto LABEL_34;
    }

    unint64_t v19 = *(void *)(v4 + 8 * v18);
    ++v20;
    if (v19) {
      goto LABEL_19;
    }
  }

void *sub_100080BBC(void *result, unint64_t a2, unint64_t a3)
{
  unint64_t v3 = a2 - (void)result;
  if (a2 < (unint64_t)result)
  {
    __break(1u);
  }

  else
  {
    if (v3 <= 0x7F) {
      return _swiftEmptyArrayStorage;
    }
    unint64_t v7 = (unint64_t)result;
    uint64_t v8 = v3 >> 7;
    uint64_t v9 = sub_100002274(&qword_100406850);
    uint64_t v4 = swift_allocObject(v9, v8 + 32, 7LL);
    size_t v10 = j__malloc_size((const void *)v4);
    *(void *)(v4 + 16) = v8;
    *(void *)(v4 + 24) = 2 * v10 - 64;
    uint64_t result = (void *)sub_100080400((unint64_t)&v11, (_BYTE *)(v4 + 32), v8, v7, a2, a3);
    if (result == (void *)v8) {
      return (void *)v4;
    }
  }

  __break(1u);
  return result;
}

unint64_t *sub_100080C74(unint64_t *result, unint64_t a2, unint64_t a3)
{
  unint64_t v3 = a2 - (void)result;
  if (a2 < (unint64_t)result)
  {
    __break(1u);
  }

  else
  {
    if (v3 <= 0xF) {
      return _swiftEmptyArrayStorage;
    }
    unint64_t v7 = (unint64_t)result;
    uint64_t v8 = v3 >> 4;
    uint64_t v9 = sub_100002274(&qword_100406848);
    uint64_t v4 = (void *)swift_allocObject(v9, v8 + 32, 7LL);
    size_t v10 = j__malloc_size(v4);
    v4[2] = v8;
    v4[3] = 2 * v10 - 64;
    uint64_t result = sub_1000802DC(v11, (uint64_t)(v4 + 4), v8, v7, a2, a3);
  }

  __break(1u);
  return result;
}

void *sub_100080D2C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 16);
  if (!v1) {
    return _swiftEmptyArrayStorage;
  }
  uint64_t v3 = sub_100002274(&qword_100406380);
  uint64_t v4 = (void *)swift_allocObject(v3, 8 * v1 + 32, 7LL);
  int64_t v5 = j__malloc_size(v4);
  uint64_t v6 = v5 - 32;
  if (v5 < 32) {
    uint64_t v6 = v5 - 25;
  }
  v4[2] = v1;
  v4[3] = 2 * (v6 >> 3);
  unint64_t v7 = sub_100176C70(&v10, (uint64_t)(v4 + 4), v1, a1);
  uint64_t v8 = v10;
  swift_bridgeObjectRetain(a1);
  swift_bridgeObjectRelease(v8);
  if (v7 != (void *)v1)
  {
    __break(1u);
    return _swiftEmptyArrayStorage;
  }

  return v4;
}

void *sub_100080DE8(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 16);
  if (!v1) {
    return _swiftEmptyArrayStorage;
  }
  uint64_t v3 = sub_100002274(&qword_100406358);
  uint64_t v4 = *(void *)(type metadata accessor for LongTermPairingKeys.PublicIdentity(0LL) - 8);
  uint64_t v5 = *(void *)(v4 + 72);
  uint64_t v6 = *(unsigned __int8 *)(v4 + 80);
  uint64_t v7 = (v6 + 32) & ~v6;
  uint64_t v8 = (void *)swift_allocObject(v3, v7 + v5 * v1, v6 | 7);
  uint64_t result = (void *)j__malloc_size(v8);
  if (v5)
  {
    if ((void *)((char *)result - v7) != (void *)0x8000000000000000LL || v5 != -1)
    {
      v8[2] = v1;
      v8[3] = 2 * (((uint64_t)result - v7) / v5);
      uint64_t v11 = sub_1000805A8(&v13, (uint64_t)v8 + v7, v1, a1);
      uint64_t v12 = v13;
      swift_bridgeObjectRetain(a1);
      sub_100057324(v12);
      if (v11 == v1) {
        return v8;
      }
      __break(1u);
      return _swiftEmptyArrayStorage;
    }
  }

  else
  {
    __break(1u);
  }

  __break(1u);
  return result;
}

void *sub_100080F00(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 16);
  if (!v1) {
    return _swiftEmptyArrayStorage;
  }
  uint64_t v3 = sub_100002274(&qword_100406440);
  uint64_t v4 = (void *)swift_allocObject(v3, 8 * v1 + 32, 7LL);
  int64_t v5 = j__malloc_size(v4);
  uint64_t v6 = v5 - 32;
  if (v5 < 32) {
    uint64_t v6 = v5 - 25;
  }
  v4[2] = v1;
  v4[3] = 2 * (v6 >> 3);
  uint64_t v7 = sub_100080854(&v10, (uint64_t)(v4 + 4), v1, a1);
  uint64_t v8 = v10;
  swift_bridgeObjectRetain(a1);
  sub_100057324(v8);
  if (v7 != (void *)v1)
  {
    __break(1u);
    return _swiftEmptyArrayStorage;
  }

  return v4;
}

void *sub_100080FE4(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 16);
  if (!v1) {
    return _swiftEmptyArrayStorage;
  }
  uint64_t v3 = sub_100002274(&qword_100406438);
  uint64_t v4 = (void *)swift_allocObject(v3, 32 * v1 + 32, 7LL);
  int64_t v5 = j__malloc_size(v4);
  uint64_t v6 = v5 - 32;
  if (v5 < 32) {
    uint64_t v6 = v5 - 1;
  }
  v4[2] = v1;
  v4[3] = 2 * (v6 >> 5);
  uint64_t v7 = sub_100080A00(&v10, (uint64_t)(v4 + 4), v1, a1);
  uint64_t v8 = v10;
  swift_bridgeObjectRetain(a1);
  sub_100057324(v8);
  if (v7 != (void *)v1)
  {
    __break(1u);
    return _swiftEmptyArrayStorage;
  }

  return v4;
}

char *sub_1000810C8(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  unint64_t v4 = a4 >> 1;
  uint64_t v5 = (a4 >> 1) - a3;
  if (__OFSUB__(a4 >> 1, a3)) {
    goto LABEL_16;
  }
  if (!v5) {
    return (char *)_swiftEmptyArrayStorage;
  }
  if (v5 > 0)
  {
    uint64_t v8 = sub_100002274((uint64_t *)&unk_10040F220);
    uint64_t v9 = (char *)swift_allocObject(v8, 7 * v5 + 32, 7LL);
    size_t v10 = j__malloc_size(v9);
    *((void *)v9 + 2) = v5;
    *((void *)v9 + 3) = 2 * ((uint64_t)(v10 - 32) / 7);
    if (v4 != a3) {
      goto LABEL_5;
    }
    goto LABEL_15;
  }

  uint64_t v9 = (char *)_swiftEmptyArrayStorage;
  if (v4 == a3)
  {
LABEL_15:
    __break(1u);
LABEL_16:
    __break(1u);
    goto LABEL_17;
  }

LABEL_5:
  if (v5 < 0)
  {
LABEL_17:
    uint64_t result = (char *)_fatalErrorMessage(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  "UnsafeMutablePointer.initialize with negative count",  51LL,  2LL,  "Swift/UnsafePointer.swift",  25LL,  2,  1090LL,  0);
    goto LABEL_18;
  }

  uint64_t v11 = v9 + 32;
  uint64_t v12 = (char *)(a2 - a3 + 8 * a3);
  if (v12 >= &v9[7 * v5 + 32] || v11 >= &v12[7 * v5])
  {
    memcpy(v11, v12, 7 * v5);
    return v9;
  }

  uint64_t result = (char *)_fatalErrorMessage(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  "UnsafeMutablePointer.initialize overlapping range",  49LL,  2LL,  "Swift/UnsafePointer.swift",  25LL,  2,  1092LL,  0);
LABEL_18:
  __break(1u);
  return result;
}

  if ((a1 & 0x80000000) == 0)
  {
    if ((a1 & 0x40000000) == 0) {
      goto LABEL_7;
    }
LABEL_14:
    uint64_t v1 = v1 | 0x80;
    if ((a1 & 0x20000000) == 0) {
      return v1;
    }
    return v1 | 0x200;
  }

  uint64_t v1 = v1 | 0x40;
  if ((a1 & 0x40000000) != 0) {
    goto LABEL_14;
  }
LABEL_7:
  if ((a1 & 0x20000000) != 0) {
    return v1 | 0x200;
  }
  return v1;
}

  *a3 = result;
  a3[1] = v5;
  return result;
}

        uint64_t v6 = (v6 + 1) & v7;
      }

      while (((*(void *)(v4 + ((v6 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> v6) & 1) != 0);
    }

    unint64_t v21 = (uint64_t *)(v4 + 8 * ((unint64_t)v3 >> 6));
    unint64_t v22 = *v21;
    unint64_t v23 = (-1LL << v3) - 1;
  }

  else
  {
    unint64_t v21 = (uint64_t *)(v4 + 8 * (result >> 6));
    unint64_t v23 = *v21;
    unint64_t v22 = (-1LL << result) - 1;
  }

  *unint64_t v21 = v23 & v22;
  int64_t v24 = *(void *)(a2 + 16);
  unint64_t v25 = __OFSUB__(v24, 1LL);
  int64_t v26 = v24 - 1;
  if (v25)
  {
    __break(1u);
  }

  else
  {
    *(void *)(a2 + 16) = v26;
    ++*(_DWORD *)(a2 + 36);
  }

  return result;
}

        uint64_t v6 = (v6 + 1) & v7;
      }

      while (((*(void *)(v4 + ((v6 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> v6) & 1) != 0);
    }

    int64_t v20 = (uint64_t *)(v4 + 8 * ((unint64_t)v3 >> 6));
    unint64_t v21 = *v20;
    unint64_t v22 = (-1LL << v3) - 1;
  }

  else
  {
    int64_t v20 = (uint64_t *)(v4 + 8 * (result >> 6));
    unint64_t v22 = *v20;
    unint64_t v21 = (-1LL << result) - 1;
  }

  *int64_t v20 = v22 & v21;
  unint64_t v23 = *(void *)(a2 + 16);
  int64_t v24 = __OFSUB__(v23, 1LL);
  unint64_t v25 = v23 - 1;
  if (v24)
  {
    __break(1u);
  }

  else
  {
    *(void *)(a2 + 16) = v25;
    ++*(_DWORD *)(a2 + 36);
  }

  return result;
}

        uint64_t v6 = (v6 + 1) & v7;
      }

      while (((*(void *)(v4 + ((v6 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> v6) & 1) != 0);
    }

    unint64_t v21 = (uint64_t *)(v4 + 8 * ((unint64_t)v3 >> 6));
    unint64_t v22 = *v21;
    unint64_t v23 = (-1LL << v3) - 1;
  }

  else
  {
    unint64_t v21 = (uint64_t *)(v4 + 8 * (result >> 6));
    unint64_t v23 = *v21;
    unint64_t v22 = (-1LL << result) - 1;
  }

  *unint64_t v21 = v23 & v22;
  int64_t v24 = *(void *)(a2 + 16);
  unint64_t v25 = __OFSUB__(v24, 1LL);
  int64_t v26 = v24 - 1;
  if (v25)
  {
    __break(1u);
  }

  else
  {
    *(void *)(a2 + 16) = v26;
    ++*(_DWORD *)(a2 + 36);
  }

  return result;
}

      v6 += 16;
      ++v5;
      if (v7 == v3)
      {
LABEL_32:
        unint64_t v4 = a1;
        goto LABEL_33;
      }
    }

    switch(v6[1])
    {
      case 2:
        if (v2 != 2) {
          goto LABEL_5;
        }
        break;
      case 3:
        if (v2 != 3) {
          goto LABEL_5;
        }
        break;
      case 4:
        if (v2 != 4) {
          goto LABEL_5;
        }
        break;
      case 5:
        if (v2 != 5) {
          goto LABEL_5;
        }
        break;
      case 6:
        if (v2 != 6) {
          goto LABEL_5;
        }
        break;
      default:
        break;
    }

    uint64_t v8 = *((void *)v6 + 1);
    uint64_t v9 = *(void *)(v8 + 16);
    unint64_t v4 = a1;
    if (v9)
    {
      size_t v10 = 0LL;
      uint64_t v11 = v8 + 32;
      while (1)
      {
        uint64_t v12 = *(void *)(v11 + 16 * v10 + 8);
        uint64_t v13 = *(void *)(v12 + 16);
        if (v13)
        {
          if (*(_DWORD *)(v12 + 32) == (_DWORD)a1) {
            goto LABEL_64;
          }
          if (v13 != 1)
          {
            if (*(_DWORD *)(v12 + 36) == (_DWORD)a1)
            {
LABEL_64:
              unint64_t v4 = *(_DWORD *)(v11 + 16 * v10);
              goto LABEL_33;
            }

            if (v13 != 2) {
              break;
            }
          }
        }

  uint64_t v8 = v3[2];
  if ((v3[3] >> 1) - v8 < v2)
  {
LABEL_22:
    __break(1u);
    goto LABEL_23;
  }

  uint64_t v9 = (unint64_t)&v3[2 * v8 + 4];
  if (a1 + 32 < v9 + 16 * v2 && v9 < a1 + 32 + 16 * v2) {
    goto LABEL_24;
  }
  swift_arrayInitWithCopy(v9);
  if (!v2)
  {
LABEL_19:
    uint64_t result = swift_bridgeObjectRelease(a1);
    unsigned __int16 *v1 = v3;
    return result;
  }

  uint64_t v11 = v3[2];
  uint64_t v12 = __OFADD__(v11, v2);
  uint64_t v13 = v11 + v2;
  if (!v12)
  {
    v3[2] = v13;
    goto LABEL_19;
  }

  uint64_t v8 = v3[2];
  if ((v3[3] >> 1) - v8 < v2)
  {
LABEL_22:
    __break(1u);
    goto LABEL_23;
  }

  uint64_t v9 = (char *)v3 + v8 + 32;
  memcpy(v9, (const void *)(a1 + 32), v2);
  if (!v2)
  {
LABEL_19:
    uint64_t result = swift_bridgeObjectRelease(a1);
    unsigned __int16 *v1 = v3;
    return result;
  }

  uint64_t v11 = v3[2];
  uint64_t v12 = __OFADD__(v11, v2);
  uint64_t v13 = v11 + v2;
  if (!v12)
  {
    v3[2] = v13;
    goto LABEL_19;
  }

  uint64_t v8 = v3[2];
  if ((v3[3] >> 1) - v8 < v2)
  {
LABEL_22:
    __break(1u);
    goto LABEL_23;
  }

  uint64_t v9 = &v3[v8 + 4];
  memcpy(v9, (const void *)(a1 + 32), 8 * v2);
  if (!v2)
  {
LABEL_19:
    uint64_t result = swift_bridgeObjectRelease(a1);
    unsigned __int16 *v1 = v3;
    return result;
  }

  uint64_t v11 = v3[2];
  uint64_t v12 = __OFADD__(v11, v2);
  uint64_t v13 = v11 + v2;
  if (!v12)
  {
    v3[2] = v13;
    goto LABEL_19;
  }

  uint64_t v8 = v3[2];
  if ((v3[3] >> 1) - v8 < v2)
  {
LABEL_22:
    __break(1u);
    goto LABEL_23;
  }

  uint64_t v9 = (unint64_t)&v3[2 * v8 + 4];
  if (a1 + 32 < v9 + 16 * v2 && v9 < a1 + 32 + 16 * v2) {
    goto LABEL_24;
  }
  swift_arrayInitWithCopy(v9);
  if (!v2)
  {
LABEL_19:
    uint64_t result = swift_bridgeObjectRelease(a1);
    unsigned __int16 *v1 = v3;
    return result;
  }

  uint64_t v11 = v3[2];
  uint64_t v12 = __OFADD__(v11, v2);
  uint64_t v13 = v11 + v2;
  if (!v12)
  {
    v3[2] = v13;
    goto LABEL_19;
  }

  int64_t v30 = *v14;
  *int v14 = v26;
  swift_bridgeObjectRelease(v30);
  uint64_t v31 = *v14;
  if ((v23 & 1) != 0)
  {
    swift_bridgeObjectRetain(v31);
  }

  else
  {
    uint64_t v32 = swift_bridgeObjectRetain(v31);
    uint64_t v33 = v15[6];
    unint64_t v48 = *((_OWORD *)v15 + 1);
    uint64_t v42 = *((_OWORD *)v15 + 2);
    ((void (*)(void **__return_ptr, uint64_t))v15[7])(&v52, v32);
    v49[0] = v48;
    v49[1] = v42;
    uint64_t v50 = v33;
    int64_t v34 = _s16P2PActivityStateOMa(0LL, (uint64_t)v49);
    (*(void (**)(_OWORD *, void **, uint64_t))(*(void *)(v34 - 8) + 32LL))(v49, &v52, v34);
    char v52 = v44;
    unint64_t v35 = v44;
    _NativeDictionary._insert(at:key:value:)(v27, &v52, v49, v31, v12, v24, v57);
  }

  swift_bridgeObjectRelease(v31);
  sub_10022D674(a3);
  unint64_t v37 = v36;
  swift_endAccess(v51);

  swift_bridgeObjectRelease(v43);
  sub_10023105C(v44, v37);
  swift_release(v15);
  return swift_release(v46);
}

        uint64_t v6 = (v6 + 1) & v7;
      }

      while (((*(void *)(v4 + ((v6 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> v6) & 1) != 0);
    }

    *(void *)(v4 + (((unint64_t)v2 >> 3) & 0x1FFFFFFFFFFFFFF8LL)) &= (-1LL << v2) - 1;
    uint64_t result = swift_release(v3);
  }

  else
  {
    *(void *)(v4 + ((result >> 3) & 0x1FFFFFFFFFFFFFF8LL)) &= (-1LL << result) - 1;
  }

  uint64_t v15 = *(void *)(v3 + 16);
  __int128 v16 = __OFSUB__(v15, 1LL);
  uint64_t v17 = v15 - 1;
  if (v16)
  {
    __break(1u);
  }

  else
  {
    *(void *)(v3 + 16) = v17;
    ++*(_DWORD *)(v3 + 36);
  }

  return result;
}

        uint64_t v6 = (v6 + 1) & v7;
      }

      while (((*(void *)(v4 + ((v6 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> v6) & 1) != 0);
    }

    *(void *)(v4 + (((unint64_t)v2 >> 3) & 0x1FFFFFFFFFFFFFF8LL)) &= (-1LL << v2) - 1;
    uint64_t result = swift_release(v3);
  }

  else
  {
    *(void *)(v4 + ((result >> 3) & 0x1FFFFFFFFFFFFFF8LL)) &= (-1LL << result) - 1;
  }

  int64_t v18 = *(void *)(v3 + 16);
  unint64_t v19 = __OFSUB__(v18, 1LL);
  int64_t v20 = v18 - 1;
  if (v19)
  {
    __break(1u);
  }

  else
  {
    *(void *)(v3 + 16) = v20;
    ++*(_DWORD *)(v3 + 36);
  }

  return result;
}

        uint64_t v6 = (v6 + 1) & v7;
      }

      while (((*(void *)(v4 + ((v6 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> v6) & 1) != 0);
    }

    *(void *)(v4 + (((unint64_t)v2 >> 3) & 0x1FFFFFFFFFFFFFF8LL)) &= (-1LL << v2) - 1;
    uint64_t result = swift_release(v3);
  }

  else
  {
    *(void *)(v4 + ((result >> 3) & 0x1FFFFFFFFFFFFFF8LL)) &= (-1LL << result) - 1;
  }

  int64_t v20 = *(void *)(v3 + 16);
  unint64_t v21 = __OFSUB__(v20, 1LL);
  unint64_t v22 = v20 - 1;
  if (v21)
  {
    __break(1u);
  }

  else
  {
    *(void *)(v3 + 16) = v22;
    ++*(_DWORD *)(v3 + 36);
  }

  return result;
}

  uint64_t v8 = v3[2];
  if ((v3[3] >> 1) - v8 < v2)
  {
LABEL_22:
    __break(1u);
    goto LABEL_23;
  }

  uint64_t v9 = (unint64_t)&v3[7 * v8 + 4];
  if (a1 + 32 < v9 + 56 * v2 && v9 < a1 + 32 + 56 * v2) {
    goto LABEL_24;
  }
  swift_arrayInitWithCopy(v9);
  if (!v2)
  {
LABEL_19:
    swift_bridgeObjectRelease(a1);
    unsigned __int16 *v1 = v3;
    return;
  }

  uint64_t v11 = v3[2];
  uint64_t v12 = __OFADD__(v11, v2);
  uint64_t v13 = v11 + v2;
  if (!v12)
  {
    v3[2] = v13;
    goto LABEL_19;
  }

  uint64_t v8 = v3[2];
  if ((v3[3] >> 1) - v8 < v2)
  {
LABEL_22:
    __break(1u);
    goto LABEL_23;
  }

  uint64_t v9 = (unint64_t)&v3[v8 + 4];
  if (a1 + 32 < v9 + 8 * v2 && v9 < a1 + 32 + 8 * v2) {
    goto LABEL_24;
  }
  type metadata accessor for AWDLTrafficRegistrationService(0LL);
  swift_arrayInitWithCopy(v9);
  if (!v2)
  {
LABEL_19:
    swift_bridgeObjectRelease(a1);
    unsigned __int16 *v1 = v3;
    return;
  }

  uint64_t v11 = v3[2];
  uint64_t v12 = __OFADD__(v11, v2);
  uint64_t v13 = v11 + v2;
  if (!v12)
  {
    v3[2] = v13;
    goto LABEL_19;
  }

        uint64_t v6 = (v6 + 1) & v7;
      }

      while (((*(void *)(v4 + ((v6 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> v6) & 1) != 0);
    }

    int64_t v20 = (uint64_t *)(v4 + 8 * ((unint64_t)v3 >> 6));
    unint64_t v21 = *v20;
    unint64_t v22 = (-1LL << v3) - 1;
  }

  else
  {
    int64_t v20 = (uint64_t *)(v4 + 8 * (result >> 6));
    unint64_t v22 = *v20;
    unint64_t v21 = (-1LL << result) - 1;
  }

  *int64_t v20 = v22 & v21;
  unint64_t v23 = *(void *)(a2 + 16);
  int64_t v24 = __OFSUB__(v23, 1LL);
  unint64_t v25 = v23 - 1;
  if (v24)
  {
    __break(1u);
  }

  else
  {
    *(void *)(a2 + 16) = v25;
    ++*(_DWORD *)(a2 + 36);
  }

  return result;
}

        uint64_t v6 = (v6 + 1) & v7;
      }

      while (((*(void *)(v4 + ((v6 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> v6) & 1) != 0);
    }

    unint64_t v21 = (uint64_t *)(v4 + 8 * ((unint64_t)v3 >> 6));
    unint64_t v22 = *v21;
    unint64_t v23 = (-1LL << v3) - 1;
  }

  else
  {
    unint64_t v21 = (uint64_t *)(v4 + 8 * (result >> 6));
    unint64_t v23 = *v21;
    unint64_t v22 = (-1LL << result) - 1;
  }

  *unint64_t v21 = v23 & v22;
  int64_t v24 = *(void *)(a2 + 16);
  unint64_t v25 = __OFSUB__(v24, 1LL);
  int64_t v26 = v24 - 1;
  if (v25)
  {
    __break(1u);
  }

  else
  {
    *(void *)(a2 + 16) = v26;
    ++*(_DWORD *)(a2 + 36);
  }

  return result;
}

        uint64_t v6 = (v6 + 1) & v7;
      }

      while (((*(void *)(v4 + ((v6 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> v6) & 1) != 0);
    }

    uint64_t v17 = (uint64_t *)(v4 + 8 * ((unint64_t)v3 >> 6));
    int64_t v18 = *v17;
    unint64_t v19 = (-1LL << v3) - 1;
  }

  else
  {
    uint64_t v17 = (uint64_t *)(v4 + 8 * (result >> 6));
    unint64_t v19 = *v17;
    int64_t v18 = (-1LL << result) - 1;
  }

  *uint64_t v17 = v19 & v18;
  int64_t v20 = *(void *)(a2 + 16);
  unint64_t v21 = __OFSUB__(v20, 1LL);
  unint64_t v22 = v20 - 1;
  if (v21)
  {
    __break(1u);
  }

  else
  {
    *(void *)(a2 + 16) = v22;
    ++*(_DWORD *)(a2 + 36);
  }

  return result;
}

  swift_bridgeObjectRelease(v9);
  uint64_t result = 0LL;
  int64_t v18 = (_BYTE *)(*(void *)(*v29 + 48LL) - v12 + 8 * v12);
  LOBYTE(v3) = *v18;
  LOBYTE(v9) = v18[1];
  unint64_t v19 = v18[2];
  int64_t v20 = v18[3];
  unint64_t v21 = v18[4];
  LOBYTE(v22) = v18[5];
  unint64_t v23 = v18[6];
LABEL_9:
  *a1 = v3;
  a1[1] = v9;
  a1[2] = v19;
  a1[3] = v20;
  a1[4] = v21;
  a1[5] = v22;
  a1[6] = v23;
  return result;
}

  swift_bridgeObjectRelease(v9);
  isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native(*v2);
  uint64_t v17 = *v2;
  v23[0] = *v2;
  *size_t v2 = 0x8000000000000000LL;
  if (!isUniquelyReferenced_nonNull_native)
  {
    sub_1002B1C74();
    uint64_t v17 = v23[0];
  }

  int64_t v18 = *(void *)(v17 + 48) - v12 + 8 * v12;
  unint64_t v19 = *(_WORD *)(v18 + 4);
  int64_t v20 = *(_BYTE *)(v18 + 6);
  *(_DWORD *)a2 = *(_DWORD *)v18;
  *(_WORD *)(a2 + 4) = v19;
  *(_BYTE *)(a2 + 6) = v20;
  sub_1002B24E8(v12);
  unint64_t v21 = *v2;
  *size_t v2 = v23[0];
  swift_bridgeObjectRelease(v21);
  unint64_t v22 = 0;
LABEL_10:
  *(_BYTE *)(a2 + 7) = v22;
}

uint64_t sub_100081248(uint64_t *a1, uint64_t (*a2)(uint64_t), uint64_t (*a3)(void *))
{
  uint64_t v6 = *a1;
  if ((swift_isUniquelyReferenced_nonNull_native(*a1) & 1) == 0) {
    uint64_t v6 = a2(v6);
  }
  uint64_t v7 = *(void *)(v6 + 16);
  v9[0] = v6 + 32;
  v9[1] = v7;
  uint64_t result = a3(v9);
  *a1 = v6;
  return result;
}

Swift::Int sub_1000812C0(uint64_t *a1)
{
  Swift::Int v3 = a1[1];
  Swift::Int result = _minimumMergeRunLength(_:)(v3);
  if (result >= v3)
  {
    if ((v3 & 0x8000000000000000LL) == 0)
    {
      uint64_t v88 = *a1;
      uint64_t v89 = *a1 + 8;
      uint64_t v90 = -1LL;
      uint64_t v91 = 1LL;
      while (1)
      {
        uint64_t v92 = v89;
        uint64_t v93 = v90;
        do
        {
          int v94 = *(_DWORD *)v92;
          if (*(_DWORD *)v92 >= *(_DWORD *)(v92 - 8)) {
            break;
          }
          if (!v88) {
            goto LABEL_147;
          }
          __int16 v95 = *(_WORD *)(v92 + 4);
          char v96 = *(_BYTE *)(v92 + 6);
          *(void *)uint64_t v92 = *(void *)(v92 - 8);
          *(_DWORD *)(v92 - 8) = v94;
          *(_WORD *)(v92 - 4) = v95;
          *(_BYTE *)(v92 - 2) = v96;
          v92 -= 8LL;
        }

        while (!__CFADD__(v93++, 1LL));
        ++v91;
        --v90;
        v89 += 8LL;
        if (v91 == v3) {
          return result;
        }
      }
    }

    goto LABEL_143;
  }

  if (v3 >= 0) {
    uint64_t v5 = v3;
  }
  else {
    uint64_t v5 = v3 + 1;
  }
  if (v3 < -1)
  {
LABEL_152:
    Swift::Int result = _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  "Can't construct Array with count < 0",  36LL,  2LL,  "Swift/Array.swift",  17LL,  2,  936LL,  0);
    __break(1u);
    return result;
  }

  Swift::Int v6 = result;
  uint64_t v111 = v1;
  v104 = a1;
  if (v3 < 2)
  {
    size_t v10 = _swiftEmptyArrayStorage;
    __dst = (char *)&_swiftEmptyArrayStorage[4];
    if (v3 != 1)
    {
      unint64_t v14 = _swiftEmptyArrayStorage[2];
      uint64_t v13 = (char *)_swiftEmptyArrayStorage;
      goto LABEL_109;
    }

    v106 = _swiftEmptyArrayStorage;
  }

  else
  {
    uint64_t v7 = v5 >> 1;
    uint64_t v8 = sub_100002274(&qword_100406898);
    uint64_t v9 = static Array._allocateBufferUninitialized(minimumCapacity:)(v7, v8);
    *(void *)(v9 + 16) = v7;
    v106 = (void *)v9;
    __dst = (char *)(v9 + 32);
  }

  Swift::Int v11 = 0LL;
  uint64_t v12 = *a1;
  uint64_t v105 = *a1 + 16;
  uint64_t v13 = (char *)_swiftEmptyArrayStorage;
  Swift::Int v107 = v6;
  Swift::Int v108 = v3;
  uint64_t v109 = v12;
  while (1)
  {
    Swift::Int v15 = v11++;
    if (v11 < v3)
    {
      unsigned int v16 = *(_DWORD *)(v12 + 8 * v11);
      uint64_t v17 = 8 * v15;
      unsigned int v18 = *(_DWORD *)(v12 + 8 * v15);
      Swift::Int v11 = v15 + 2;
      if (v15 + 2 < v3)
      {
        unint64_t v19 = (_DWORD *)(v105 + 8 * v15);
        while (v16 < v18 != *v19 >= *(v19 - 2))
        {
          v19 += 2;
          if (v3 == ++v11)
          {
            Swift::Int v11 = v3;
            break;
          }
        }
      }

      if (v16 < v18)
      {
        if (v11 < v15) {
          goto LABEL_144;
        }
        if (v15 < v11)
        {
          uint64_t v20 = 8 * v11 - 8;
          Swift::Int v21 = v11;
          Swift::Int v22 = v15;
          do
          {
            if (v22 != --v21)
            {
              if (!v12) {
                goto LABEL_150;
              }
              int64_t v24 = (void *)(v12 + v17);
              int v25 = *(_DWORD *)(v12 + v17);
              char v26 = *(_BYTE *)(v12 + v17 + 4);
              char v27 = *(_BYTE *)(v12 + v17 + 5);
              char v28 = *(_BYTE *)(v12 + v17 + 6);
              uint64_t v23 = v12 + v20;
              *(_DWORD *)uint64_t v23 = v25;
              *(_BYTE *)(v23 + 4) = v26;
              *(_BYTE *)(v23 + 5) = v27;
              *(_BYTE *)(v23 + 6) = v28;
            }

            ++v22;
            v20 -= 8LL;
            v17 += 8LL;
          }

          while (v22 < v21);
        }
      }
    }

    if (v11 < v3)
    {
      if (__OFSUB__(v11, v15)) {
        goto LABEL_142;
      }
      if (v11 - v15 < v6)
      {
        Swift::Int v29 = v15 + v6;
        if (__OFADD__(v15, v6)) {
          goto LABEL_145;
        }
        if (v29 >= v3) {
          Swift::Int v29 = v3;
        }
        if (v29 < v15) {
          goto LABEL_146;
        }
        if (v11 != v29)
        {
          int64_t v30 = (int *)(v12 + 8 * v11);
          do
          {
            uint64_t v31 = v30;
            Swift::Int v32 = v15;
            do
            {
              int v33 = *v31;
              if (!v12) {
                goto LABEL_148;
              }
              __int16 v34 = *((_WORD *)v31 + 2);
              char v35 = *((_BYTE *)v31 + 6);
              *(void *)uint64_t v31 = *((void *)v31 - 1);
              *(v31 - 2) = v33;
              *((_WORD *)v31 - 2) = v34;
              *((_BYTE *)v31 - 2) = v35;
              ++v32;
              v31 -= 2;
            }

            while (v11 != v32);
            ++v11;
            v30 += 2;
          }

          while (v11 != v29);
          Swift::Int v11 = v29;
        }
      }
    }

    if (v11 < v15)
    {
LABEL_137:
      __break(1u);
      goto LABEL_138;
    }

    if ((swift_isUniquelyReferenced_nonNull_native(v13) & 1) == 0) {
      uint64_t v13 = sub_1000EA720(0LL, *((void *)v13 + 2) + 1LL, 1, v13);
    }
    unint64_t v37 = *((void *)v13 + 2);
    unint64_t v36 = *((void *)v13 + 3);
    unint64_t v14 = v37 + 1;
    uint64_t v12 = v109;
    if (v37 >= v36 >> 1)
    {
      uint64_t v12 = v109;
      uint64_t v13 = sub_1000EA720((char *)(v36 > 1), v37 + 1, 1, v13);
    }

    *((void *)v13 + 2) = v14;
    unint64_t v38 = v13 + 32;
    uint64_t v39 = &v13[16 * v37 + 32];
    *(void *)uint64_t v39 = v15;
    *((void *)v39 + 1) = v11;
    if (v37) {
      break;
    }
    unint64_t v14 = 1LL;
LABEL_15:
    Swift::Int v6 = v107;
    Swift::Int v3 = v108;
    if (v11 >= v108)
    {
      size_t v10 = v106;
LABEL_109:
      v87 = v13;
      v106 = v10;
      if (v14 < 2) {
        goto LABEL_99;
      }
      uint64_t v98 = *v104;
      while (1)
      {
        unint64_t v99 = v14 - 2;
        if (v14 < 2) {
          break;
        }
        if (!v98) {
          goto LABEL_151;
        }
        v86 = v87;
        uint64_t v100 = *(void *)&v87[16 * v99 + 32];
        uint64_t v101 = *(void *)&v87[16 * v14 + 24];
        sub_1000820E4( (char *)(v98 + 8 * v100),  (char *)(v98 + 8LL * *(void *)&v87[16 * v14 + 16]),  v98 + 8 * v101,  __dst);
        if (v111) {
          goto LABEL_98;
        }
        if (v101 < v100) {
          goto LABEL_139;
        }
        if ((swift_isUniquelyReferenced_nonNull_native(v86) & 1) == 0) {
          v86 = sub_1000EAA0C((uint64_t)v86);
        }
        if (v99 >= *((void *)v86 + 2)) {
          goto LABEL_140;
        }
        v102 = &v86[16 * v99 + 32];
        *(void *)v102 = v100;
        *((void *)v102 + 1) = v101;
        unint64_t v103 = *((void *)v86 + 2);
        if (v14 > v103) {
          goto LABEL_141;
        }
        memmove(&v86[16 * v14 + 16], &v86[16 * v14 + 32], 16 * (v103 - v14));
        v87 = v86;
        *((void *)v86 + 2) = v103 - 1;
        unint64_t v14 = v103 - 1;
        if (v103 <= 2) {
          goto LABEL_99;
        }
      }

LABEL_138:
      __break(1u);
LABEL_139:
      __break(1u);
LABEL_140:
      __break(1u);
LABEL_141:
      __break(1u);
LABEL_142:
      __break(1u);
LABEL_143:
      __break(1u);
LABEL_144:
      __break(1u);
LABEL_145:
      __break(1u);
LABEL_146:
      __break(1u);
LABEL_147:
      __break(1u);
LABEL_148:
      __break(1u);
LABEL_149:
      __break(1u);
LABEL_150:
      __break(1u);
LABEL_151:
      __break(1u);
      goto LABEL_152;
    }
  }

  while (1)
  {
    unint64_t v40 = v14 - 1;
    if (v14 >= 4)
    {
      char v45 = &v38[16 * v14];
      uint64_t v46 = *((void *)v45 - 8);
      uint64_t v47 = *((void *)v45 - 7);
      BOOL v51 = __OFSUB__(v47, v46);
      uint64_t v48 = v47 - v46;
      if (v51) {
        goto LABEL_126;
      }
      uint64_t v50 = *((void *)v45 - 6);
      uint64_t v49 = *((void *)v45 - 5);
      BOOL v51 = __OFSUB__(v49, v50);
      uint64_t v43 = v49 - v50;
      char v44 = v51;
      if (v51) {
        goto LABEL_127;
      }
      unint64_t v52 = v14 - 2;
      Swift::String v53 = &v38[16 * v14 - 32];
      uint64_t v55 = *(void *)v53;
      uint64_t v54 = *((void *)v53 + 1);
      BOOL v51 = __OFSUB__(v54, v55);
      uint64_t v56 = v54 - v55;
      if (v51) {
        goto LABEL_129;
      }
      BOOL v51 = __OFADD__(v43, v56);
      uint64_t v57 = v43 + v56;
      if (v51) {
        goto LABEL_132;
      }
      if (v57 >= v48)
      {
        int v75 = &v38[16 * v40];
        uint64_t v77 = *(void *)v75;
        uint64_t v76 = *((void *)v75 + 1);
        BOOL v51 = __OFSUB__(v76, v77);
        uint64_t v78 = v76 - v77;
        if (v51) {
          goto LABEL_136;
        }
        BOOL v68 = v43 < v78;
        goto LABEL_87;
      }
    }

    else
    {
      if (v14 != 3)
      {
        uint64_t v69 = *((void *)v13 + 4);
        uint64_t v70 = *((void *)v13 + 5);
        BOOL v51 = __OFSUB__(v70, v69);
        uint64_t v62 = v70 - v69;
        char v63 = v51;
        goto LABEL_81;
      }

      uint64_t v42 = *((void *)v13 + 4);
      uint64_t v41 = *((void *)v13 + 5);
      BOOL v51 = __OFSUB__(v41, v42);
      uint64_t v43 = v41 - v42;
      char v44 = v51;
    }

    if ((v44 & 1) != 0) {
      goto LABEL_128;
    }
    unint64_t v52 = v14 - 2;
    unint64_t v58 = &v38[16 * v14 - 32];
    uint64_t v60 = *(void *)v58;
    uint64_t v59 = *((void *)v58 + 1);
    BOOL v61 = __OFSUB__(v59, v60);
    uint64_t v62 = v59 - v60;
    char v63 = v61;
    if (v61) {
      goto LABEL_131;
    }
    uint64_t v64 = &v38[16 * v40];
    uint64_t v66 = *(void *)v64;
    uint64_t v65 = *((void *)v64 + 1);
    BOOL v51 = __OFSUB__(v65, v66);
    uint64_t v67 = v65 - v66;
    if (v51) {
      goto LABEL_134;
    }
    if (__OFADD__(v62, v67)) {
      goto LABEL_135;
    }
    if (v62 + v67 >= v43)
    {
      BOOL v68 = v43 < v67;
LABEL_87:
      if (v68) {
        unint64_t v40 = v52;
      }
      goto LABEL_89;
    }

      __break(1u);
LABEL_139:
      __break(1u);
LABEL_140:
      __break(1u);
LABEL_141:
      __break(1u);
LABEL_142:
      __break(1u);
LABEL_143:
      __break(1u);
LABEL_144:
      __break(1u);
LABEL_145:
      __break(1u);
LABEL_146:
      __break(1u);
LABEL_147:
      __break(1u);
LABEL_148:
      __break(1u);
LABEL_149:
      __break(1u);
LABEL_150:
      __break(1u);
LABEL_151:
      __break(1u);
      goto LABEL_152;
    }
  }

  while (1)
  {
    unint64_t v37 = v13 - 1;
    if (v13 >= 4)
    {
      uint64_t v42 = &v35[16 * v13];
      uint64_t v43 = *((void *)v42 - 8);
      char v44 = *((void *)v42 - 7);
      uint64_t v48 = __OFSUB__(v44, v43);
      char v45 = v44 - v43;
      if (v48) {
        goto LABEL_126;
      }
      uint64_t v47 = *((void *)v42 - 6);
      uint64_t v46 = *((void *)v42 - 5);
      uint64_t v48 = __OFSUB__(v46, v47);
      unint64_t v40 = v46 - v47;
      uint64_t v41 = v48;
      if (v48) {
        goto LABEL_127;
      }
      uint64_t v49 = v13 - 2;
      uint64_t v50 = &v35[16 * v13 - 32];
      unint64_t v52 = *(void *)v50;
      BOOL v51 = *((void *)v50 + 1);
      uint64_t v48 = __OFSUB__(v51, v52);
      Swift::String v53 = v51 - v52;
      if (v48) {
        goto LABEL_129;
      }
      uint64_t v48 = __OFADD__(v40, v53);
      uint64_t v54 = v40 + v53;
      if (v48) {
        goto LABEL_132;
      }
      if (v54 >= v45)
      {
        uint64_t v72 = &v35[16 * v37];
        uint64_t v74 = *(void *)v72;
        uint64_t v73 = *((void *)v72 + 1);
        uint64_t v48 = __OFSUB__(v73, v74);
        int v75 = v73 - v74;
        if (v48) {
          goto LABEL_136;
        }
        uint64_t v65 = v40 < v75;
        goto LABEL_87;
      }
    }

    else
    {
      if (v13 != 3)
      {
        uint64_t v66 = *((void *)v12 + 4);
        uint64_t v67 = *((void *)v12 + 5);
        uint64_t v48 = __OFSUB__(v67, v66);
        uint64_t v59 = v67 - v66;
        uint64_t v60 = v48;
        goto LABEL_81;
      }

      uint64_t v39 = *((void *)v12 + 4);
      unint64_t v38 = *((void *)v12 + 5);
      uint64_t v48 = __OFSUB__(v38, v39);
      unint64_t v40 = v38 - v39;
      uint64_t v41 = v48;
    }

    if ((v41 & 1) != 0) {
      goto LABEL_128;
    }
    uint64_t v49 = v13 - 2;
    uint64_t v55 = &v35[16 * v13 - 32];
    uint64_t v57 = *(void *)v55;
    uint64_t v56 = *((void *)v55 + 1);
    unint64_t v58 = __OFSUB__(v56, v57);
    uint64_t v59 = v56 - v57;
    uint64_t v60 = v58;
    if (v58) {
      goto LABEL_131;
    }
    BOOL v61 = &v35[16 * v37];
    char v63 = *(void *)v61;
    uint64_t v62 = *((void *)v61 + 1);
    uint64_t v48 = __OFSUB__(v62, v63);
    uint64_t v64 = v62 - v63;
    if (v48) {
      goto LABEL_134;
    }
    if (__OFADD__(v59, v64)) {
      goto LABEL_135;
    }
    if (v59 + v64 >= v40)
    {
      uint64_t v65 = v40 < v64;
LABEL_87:
      if (v65) {
        unint64_t v37 = v49;
      }
      goto LABEL_89;
    }

Swift::Int sub_1000819D0(uint64_t *a1)
{
  Swift::Int v3 = a1[1];
  Swift::Int result = _minimumMergeRunLength(_:)(v3);
  if (result >= v3)
  {
    if ((v3 & 0x8000000000000000LL) == 0)
    {
      uint64_t v96 = 0LL;
      uint64_t v97 = *a1;
      uint64_t v98 = 1LL;
      while (1)
      {
        unsigned int v99 = *(_DWORD *)(v97 + 32 * v98);
        uint64_t v100 = v96;
        do
        {
          uint64_t v101 = (_OWORD *)(v97 + v100);
          if (v99 >= *(_DWORD *)(v97 + v100)) {
            break;
          }
          if (!v97) {
            goto LABEL_142;
          }
          uint64_t v102 = v97 + v100;
          __int16 v103 = *(_WORD *)(v97 + v100 + 36);
          __int128 v104 = *(_OWORD *)(v97 + v100 + 40);
          uint64_t v105 = *(void *)(v97 + v100 + 56);
          __int128 v106 = v101[1];
          *(_OWORD *)(v97 + v100 + 32) = *v101;
          *(_OWORD *)(v97 + v100 + 48) = v106;
          *(_DWORD *)uint64_t v102 = v99;
          *(_WORD *)(v102 + 4) = v103;
          *(_OWORD *)(v102 + 8) = v104;
          *(void *)(v102 + 24) = v105;
          v100 -= 32LL;
        }

        while (v100 != -32);
        ++v98;
        v96 += 32LL;
        if (v98 == v3) {
          return result;
        }
      }
    }

    goto LABEL_138;
  }

  if (v3 >= 0) {
    uint64_t v5 = v3;
  }
  else {
    uint64_t v5 = v3 + 1;
  }
  if (v3 < -1)
  {
LABEL_147:
    Swift::Int result = _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  "Can't construct Array with count < 0",  36LL,  2LL,  "Swift/Array.swift",  17LL,  2,  936LL,  0);
    __break(1u);
    return result;
  }

  Swift::Int v6 = result;
  v114 = a1;
  if (v3 < 2)
  {
    size_t v10 = _swiftEmptyArrayStorage;
    __dst = (char *)&_swiftEmptyArrayStorage[4];
    if (v3 != 1)
    {
      unint64_t v14 = _swiftEmptyArrayStorage[2];
      uint64_t v13 = (char *)_swiftEmptyArrayStorage;
      goto LABEL_104;
    }

    v116 = _swiftEmptyArrayStorage;
  }

  else
  {
    uint64_t v7 = v5 >> 1;
    uint64_t v8 = sub_100002274(&qword_100406890);
    uint64_t v9 = static Array._allocateBufferUninitialized(minimumCapacity:)(v7, v8);
    *(void *)(v9 + 16) = v7;
    v116 = (void *)v9;
    __dst = (char *)(v9 + 32);
  }

  Swift::Int v11 = 0LL;
  uint64_t v12 = *a1;
  uint64_t v115 = *a1 + 64;
  uint64_t v113 = *a1 + 24;
  uint64_t v13 = (char *)_swiftEmptyArrayStorage;
  Swift::Int v117 = v6;
  Swift::Int v118 = v3;
  uint64_t v119 = v12;
  while (1)
  {
    Swift::Int v15 = v11++;
    if (v11 < v3)
    {
      unsigned int v16 = *(_DWORD *)(v12 + 32 * v11);
      uint64_t v17 = 32 * v15;
      unsigned int v18 = *(_DWORD *)(v12 + 32 * v15);
      Swift::Int v11 = v15 + 2;
      if (v15 + 2 < v3)
      {
        unint64_t v19 = (unsigned int *)(v115 + 32 * v15);
        unsigned int v20 = v16;
        while (1)
        {
          unsigned int v22 = *v19;
          v19 += 8;
          unsigned int v21 = v22;
          if (v16 < v18 == v22 >= v20) {
            break;
          }
          ++v11;
          unsigned int v20 = v21;
          if (v3 == v11)
          {
            Swift::Int v11 = v3;
            break;
          }
        }
      }

      if (v16 < v18)
      {
        if (v11 < v15) {
          goto LABEL_139;
        }
        if (v15 < v11)
        {
          uint64_t v23 = 32 * v11;
          Swift::Int v24 = v11;
          Swift::Int v25 = v15;
          do
          {
            if (v25 != --v24)
            {
              if (!v12) {
                goto LABEL_145;
              }
              char v26 = (_OWORD *)(v12 + v17);
              int v27 = *(_DWORD *)(v12 + v17);
              uint64_t v28 = v12 + v23;
              __int16 v29 = *(_WORD *)(v12 + v17 + 4);
              __int128 v30 = *(_OWORD *)(v12 + v17 + 8);
              uint64_t v31 = *(void *)(v12 + v17 + 24);
              __int128 v32 = *(_OWORD *)(v12 + v23 - 16);
              *char v26 = *(_OWORD *)(v12 + v23 - 32);
              v26[1] = v32;
              *(_DWORD *)(v28 - 32) = v27;
              *(_WORD *)(v28 - 28) = v29;
              *(_OWORD *)(v28 - 24) = v30;
              *(void *)(v28 - 8) = v31;
            }

            ++v25;
            v23 -= 32LL;
            v17 += 32LL;
          }

          while (v25 < v24);
        }
      }
    }

    if (v11 < v3)
    {
      if (__OFSUB__(v11, v15)) {
        goto LABEL_137;
      }
      if (v11 - v15 < v6)
      {
        Swift::Int v33 = v15 + v6;
        if (__OFADD__(v15, v6)) {
          goto LABEL_140;
        }
        if (v33 >= v3) {
          Swift::Int v33 = v3;
        }
        if (v33 < v15) {
          goto LABEL_141;
        }
        if (v11 != v33)
        {
          uint64_t v34 = v113 + 32 * v11;
          do
          {
            unsigned int v35 = *(_DWORD *)(v12 + 32 * v11);
            Swift::Int v36 = v15;
            uint64_t v37 = v34;
            do
            {
              if (v35 >= *(_DWORD *)(v37 - 56)) {
                break;
              }
              if (!v12) {
                goto LABEL_143;
              }
              unint64_t v38 = (_OWORD *)(v37 - 24);
              __int128 v40 = *(_OWORD *)(v37 - 56);
              __int128 v39 = *(_OWORD *)(v37 - 40);
              *(void *)(v37 - 32) = *(void *)v37;
              v37 -= 32LL;
              __int16 v41 = *(_WORD *)(v37 + 12);
              __int128 v42 = *(_OWORD *)(v37 + 16);
              *unint64_t v38 = v40;
              v38[1] = v39;
              *(_DWORD *)(v37 - 24) = v35;
              *(_WORD *)(v37 - 20) = v41;
              *(_OWORD *)(v37 - 16) = v42;
              ++v36;
            }

            while (v11 != v36);
            ++v11;
            v34 += 32LL;
          }

          while (v11 != v33);
          Swift::Int v11 = v33;
        }
      }
    }

    if (v11 < v15)
    {
LABEL_132:
      __break(1u);
      goto LABEL_133;
    }

    if ((swift_isUniquelyReferenced_nonNull_native(v13) & 1) == 0) {
      uint64_t v13 = sub_1000EA720(0LL, *((void *)v13 + 2) + 1LL, 1, v13);
    }
    unint64_t v44 = *((void *)v13 + 2);
    unint64_t v43 = *((void *)v13 + 3);
    unint64_t v14 = v44 + 1;
    uint64_t v12 = v119;
    if (v44 >= v43 >> 1)
    {
      uint64_t v93 = sub_1000EA720((char *)(v43 > 1), v44 + 1, 1, v13);
      uint64_t v12 = v119;
      uint64_t v13 = v93;
    }

    *((void *)v13 + 2) = v14;
    char v45 = v13 + 32;
    uint64_t v46 = &v13[16 * v44 + 32];
    *(void *)uint64_t v46 = v15;
    *((void *)v46 + 1) = v11;
    if (v44) {
      break;
    }
    unint64_t v14 = 1LL;
LABEL_15:
    Swift::Int v6 = v117;
    Swift::Int v3 = v118;
    if (v11 >= v118)
    {
      size_t v10 = v116;
LABEL_104:
      __int16 v95 = v13;
      v116 = v10;
      if (v14 < 2) {
        goto LABEL_95;
      }
      uint64_t v107 = *v114;
      while (1)
      {
        unint64_t v108 = v14 - 2;
        if (v14 < 2) {
          break;
        }
        if (!v107) {
          goto LABEL_146;
        }
        int v94 = v95;
        uint64_t v109 = *(void *)&v95[16 * v108 + 32];
        uint64_t v110 = *(void *)&v95[16 * v14 + 24];
        sub_100082360( (char *)(v107 + 32 * v109),  (char *)(v107 + 32LL * *(void *)&v95[16 * v14 + 16]),  v107 + 32 * v110,  __dst);
        if (v1) {
          goto LABEL_94;
        }
        if (v110 < v109) {
          goto LABEL_134;
        }
        if ((swift_isUniquelyReferenced_nonNull_native(v94) & 1) == 0) {
          int v94 = sub_1000EAA0C((uint64_t)v94);
        }
        if (v108 >= *((void *)v94 + 2)) {
          goto LABEL_135;
        }
        uint64_t v111 = &v94[16 * v108 + 32];
        *(void *)uint64_t v111 = v109;
        *((void *)v111 + 1) = v110;
        unint64_t v112 = *((void *)v94 + 2);
        if (v14 > v112) {
          goto LABEL_136;
        }
        memmove(&v94[16 * v14 + 16], &v94[16 * v14 + 32], 16 * (v112 - v14));
        __int16 v95 = v94;
        *((void *)v94 + 2) = v112 - 1;
        unint64_t v14 = v112 - 1;
        if (v112 <= 2) {
          goto LABEL_95;
        }
      }

LABEL_77:
    if ((v70 & 1) != 0) {
      goto LABEL_125;
    }
    uint64_t v78 = &v45[16 * v47];
    uint64_t v80 = *(void *)v78;
    uint64_t v79 = *((void *)v78 + 1);
    BOOL v58 = __OFSUB__(v79, v80);
    uint64_t v81 = v79 - v80;
    if (v58) {
      goto LABEL_128;
    }
    if (v81 < v69) {
      goto LABEL_15;
    }
LABEL_85:
    unint64_t v86 = v47 - 1;
    if (v47 - 1 >= v14)
    {
      __break(1u);
LABEL_118:
      __break(1u);
LABEL_119:
      __break(1u);
LABEL_120:
      __break(1u);
LABEL_121:
      __break(1u);
LABEL_122:
      __break(1u);
LABEL_123:
      __break(1u);
LABEL_124:
      __break(1u);
LABEL_125:
      __break(1u);
LABEL_126:
      __break(1u);
LABEL_127:
      __break(1u);
LABEL_128:
      __break(1u);
LABEL_129:
      __break(1u);
LABEL_130:
      __break(1u);
LABEL_131:
      __break(1u);
      goto LABEL_132;
    }

    if (!v12) {
      goto LABEL_144;
    }
    v87 = v13;
    uint64_t v88 = &v45[16 * v86];
    uint64_t v89 = *(void *)v88;
    uint64_t v90 = &v45[16 * v47];
    uint64_t v91 = *((void *)v90 + 1);
    sub_100082360((char *)(v12 + 32LL * *(void *)v88), (char *)(v12 + 32LL * *(void *)v90), v12 + 32 * v91, __dst);
    if (v1) {
      break;
    }
    if (v91 < v89) {
      goto LABEL_118;
    }
    if (v47 > *((void *)v87 + 2)) {
      goto LABEL_119;
    }
    *(void *)uint64_t v88 = v89;
    *(void *)&v45[16 * v86 + 8] = v91;
    unint64_t v92 = *((void *)v87 + 2);
    if (v47 >= v92) {
      goto LABEL_120;
    }
    uint64_t v13 = v87;
    unint64_t v14 = v92 - 1;
    memmove(&v45[16 * v47], v90 + 16, 16 * (v92 - 1 - v47));
    *((void *)v87 + 2) = v92 - 1;
    uint64_t v12 = v119;
    if (v92 <= 2) {
      goto LABEL_15;
    }
  }

  int v94 = v87;
LABEL_94:
  __int16 v95 = v94;
LABEL_95:
  swift_bridgeObjectRelease(v95);
  v116[2] = 0LL;
  return swift_bridgeObjectRelease(v116);
}

      v361 = *(_DWORD *)(v38 + 4);
      if ((*(_DWORD *)NANAttribute.CustomDeviceInformation.Flags.triggeredWatchdogReset.unsafeMutableAddressor() & ~v361) == 0)
      {
        v362 = *(uint64_t *)((char *)v517 + *(void *)(*v517 + 280));
        swift_unownedRetainStrong(v362);
        v363 = v497;
        *(void *)&v518 = v118 & 0xFFFFFFFF000000FFLL | (unsigned __int16)(v518 << 8) | ((unint64_t)BYTE1(v518) << 16) & 0xFFFFFFFF00FFFFFFLL | ((unint64_t)BYTE2(v518) << 24) | ((unint64_t)BYTE3(v518) << 32) | ((unint64_t)BYTE4(v518) << 40);
        sub_1002EA528(v518, v497);
        v512 = v362;
        swift_release(v362);
        v364 = v493;
        sub_1000226B0(v363 + *(int *)(v505 + 84), v493, qword_100410330);
        sub_10005802C(v363, type metadata accessor for NANPeer);
        __int128 v42 = v496;
        uint64_t v54 = *(void *)(v495 + 48);
        v365 = ((uint64_t (*)(uint64_t, uint64_t, _BYTE *))v54)(v364, 1LL, v496);
        uint64_t v46 = (uint64_t *)v490;
        sub_100057FE8(v38, (uint64_t)v490, type metadata accessor for NANAttribute.CustomDeviceInformation);
        v366 = v364;
        unint64_t v47 = v491;
        sub_1000226B0(v366, v491, qword_100410330);
        v511 = v54;
        if (v365 != 1) {
          goto LABEL_92;
        }
        sub_1000225EC(v47, qword_100410330);
        sub_10005802C((uint64_t)v46, type metadata accessor for NANAttribute.CustomDeviceInformation);
        LODWORD(v513) = 0;
        v367 = v508;
        v368 = v509;
        v369 = (uint64_t)v485;
LABEL_111:
        type metadata accessor for P2PTimer(0LL);
        v397 = (uint64_t)v486;
        variable initialization expression of AWDLPeer.lastUpdated();
        (*(void (**)(uint64_t, void, uint64_t, uint64_t))(v367 + 56))(v397, 0LL, 1LL, v368);
        sub_100286D18(v397);
        sub_100057FE8(v38, v369, type metadata accessor for NANAttribute.CustomDeviceInformation);
        sub_100058090(&v525, &v521);
        v398 = (void *)NANBitmap.Channel.operatingClass.getter(&v521);
        v399 = v398[3];
        v400 = v398[4];
        v401 = v398[5];
        sub_1001074E8( (uint64_t)&v525,  (void (*)(void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, __int16))sub_100107584);
        v402 = sub_10005852C(v399, v400, v401);
        v403 = (os_log_s *)Logger.logObject.getter(v402);
        v404 = static os_log_type_t.default.getter();
        if (os_log_type_enabled(v403, v404))
        {
          v473 = v50;
          v405 = swift_slowAlloc(22LL, -1LL);
          v510 = swift_slowAlloc(64LL, -1LL);
          v531 = (void *)v510;
          *(_DWORD *)v405 = 136315394;
          v406 = WiFiAddress.description.getter(v518);
          v408 = v407;
          v519 = sub_10000235C(v406, v407, (uint64_t *)&v531);
          UnsafeMutableRawBufferPointer.copyMemory(from:)(&v519, v520);
          swift_bridgeObjectRelease(v408);
          sub_1001074E8( (uint64_t)&v525,  (void (*)(void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, __int16))sub_1000578CC);
          sub_1001074E8( (uint64_t)&v525,  (void (*)(void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, __int16))sub_1000578CC);
          *(_WORD *)(v405 + 12) = 2080;
          if ((v513 & 1) != 0)
          {
            v409 = 0xE800000000000000LL;
            v410 = 0x676E69686374616DLL;
          }

          else
          {
            v412 = v480;
            sub_1000226B0(v369 + *(int *)(v514 + 28) + (uint64_t)v494[10], v480, qword_100410330);
            v413 = ((uint64_t (*)(uint64_t, uint64_t, _BYTE *))v511)(v412, 1LL, v496);
            sub_1000225EC(v412, qword_100410330);
            if (v413 == 1) {
              v410 = 0x676E697373696DLL;
            }
            else {
              v410 = 0x686374616D73696DLL;
            }
            if (v413 == 1) {
              v409 = 0xE700000000000000LL;
            }
            else {
              v409 = 0xEB00000000676E69LL;
            }
          }

          v411 = (uint64_t)v487;
          v519 = sub_10000235C(v410, v409, (uint64_t *)&v531);
          UnsafeMutableRawBufferPointer.copyMemory(from:)(&v519, v520);
          swift_bridgeObjectRelease(v409);
          sub_10005802C(v369, type metadata accessor for NANAttribute.CustomDeviceInformation);
          _os_log_impl( (void *)&_mh_execute_header,  v403,  v404,  "Received SOS watchdog recovery from %s with %s UUID",  (uint8_t *)v405,  0x16u);
          v414 = v510;
          swift_arrayDestroy(v510, 2LL, &type metadata for Any[8]);
          swift_slowDealloc(v414, -1LL, -1LL);
          swift_slowDealloc(v405, -1LL, -1LL);

          uint64_t v50 = v473;
          unint64_t v38 = v500;
        }

        else
        {

          sub_1001074E8( (uint64_t)&v525,  (void (*)(void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, __int16))sub_1000578CC);
          sub_1001074E8( (uint64_t)&v525,  (void (*)(void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, __int16))sub_1000578CC);
          sub_10005802C(v369, type metadata accessor for NANAttribute.CustomDeviceInformation);
          v411 = (uint64_t)v487;
        }

        v415 = v512;
        swift_unownedRetainStrong(v512);
        (*(void (**)(uint64_t, uint64_t, uint64_t, _BYTE *))(v495 + 56))(v411, 1LL, 1LL, v496);
        v416 = v497;
        v417 = v518;
        sub_1002EA528(v518, v497);
        sub_10029FF60(v411, v416 + *(int *)(v505 + 84));
        sub_1002EA6EC(v416, v417);
        swift_release(v415);
        v418 = v517;
        v419 = (uint64_t *)((char *)v517 + qword_10040DD20);
        swift_beginAccess((char *)v517 + qword_10040DD20, &v531, 0LL, 0LL);
        v420 = *v419;
        v422 = (uint64_t)v515;
        v421 = v516;
        v424 = _s17InitiatorInstanceCMa(0LL, (uint64_t)v515, v516, v423);
        swift_bridgeObjectRetain(v420);
        v425 = swift_getWitnessTable(&unk_10035EA58, v424);
        v426 = v513 & 1;
        sub_100286E04(v420, (uint64_t)v533, v513 & 1, v422, v424, v421, v425);
        swift_bridgeObjectRelease(v420);
        v427 = (uint64_t *)((char *)v418 + qword_10040DD28);
        swift_beginAccess((char *)v418 + qword_10040DD28, &v519, 0LL, 0LL);
        v428 = *v427;
        v430 = _s17ResponderInstanceCMa(0LL, v422, v421, v429);
        swift_bridgeObjectRetain(v428);
        v431 = swift_getWitnessTable(&unk_10035D5D8, v430);
        sub_100286E04(v428, (uint64_t)v533, v426, v422, v430, v421, v431);
        sub_1001074E8( (uint64_t)&v525,  (void (*)(void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, __int16))sub_1000578CC);
        swift_bridgeObjectRelease(v428);
        sub_100286518();
        sub_1002814F4();
        sub_1000225EC(v493, qword_100410330);
LABEL_123:
        v325 = type metadata accessor for NANAttribute.CustomDeviceInformation;
        v326 = v38;
        goto LABEL_51;
      }

      if ((*(_DWORD *)NANAttribute.CustomDeviceInformation.Flags.linkConditionFeedbackRequest.unsafeMutableAddressor() & ~v361) == 0
        || (v379 = v38 + *(int *)(v514 + 28), (*(_BYTE *)(v379 + v494[13] + 24) & 1) == 0))
      {
        sub_1001074E8( (uint64_t)&v525,  (void (*)(void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, __int16))sub_1000578CC);
        goto LABEL_123;
      }

      v380 = v494[11];
      if (!*(void *)(*(void *)(v379 + v380) + 16LL))
      {
        sub_100058090(&v525, &v521);
        v432 = (uint64_t *)NANBitmap.Channel.operatingClass.getter(&v521);
        v433 = sub_10005852C(v432[3], v432[4], v432[5]);
        v434 = (os_log_s *)Logger.logObject.getter(v433);
        v435 = static os_log_type_t.error.getter();
        if (os_log_type_enabled(v434, v435))
        {
          v436 = (uint8_t *)swift_slowAlloc(12LL, -1LL);
          v437 = swift_slowAlloc(32LL, -1LL);
          *(_DWORD *)v436 = 136315138;
          v531 = (void *)v437;
          v438 = WiFiAddress.description.getter(v118 & 0xFFFFFFFF000000FFLL | (unsigned __int16)(v518 << 8) | ((unint64_t)BYTE1(v518) << 16) & 0xFFFFFFFF00FFFFFFLL | ((unint64_t)BYTE2(v518) << 24) | ((unint64_t)BYTE3(v518) << 32) | ((unint64_t)BYTE4(v518) << 40));
          v440 = v439;
          v519 = sub_10000235C(v438, v439, (uint64_t *)&v531);
          UnsafeMutableRawBufferPointer.copyMemory(from:)(&v519, v520);
          swift_bridgeObjectRelease(v440);
          sub_1001074E8( (uint64_t)&v525,  (void (*)(void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, __int16))sub_1000578CC);
          sub_1001074E8( (uint64_t)&v525,  (void (*)(void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, __int16))sub_1000578CC);
          _os_log_impl( (void *)&_mh_execute_header,  v434,  v435,  "No keep alive datapath identifers provided skipping update from %s",  v436,  0xCu);
          swift_arrayDestroy(v437, 1LL, &type metadata for Any[8]);
          swift_slowDealloc(v437, -1LL, -1LL);
          swift_slowDealloc(v436, -1LL, -1LL);
        }

        else
        {

          sub_1001074E8( (uint64_t)&v525,  (void (*)(void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, __int16))sub_1000578CC);
          sub_1001074E8( (uint64_t)&v525,  (void (*)(void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, __int16))sub_1000578CC);
        }

        v325 = type metadata accessor for NANAttribute.CustomDeviceInformation;
        v326 = v500;
        goto LABEL_51;
      }

      v473 = v50;
      if (v121 == 4)
      {
        v507 = (unint64_t)v156;
        v381 = v475;
        sub_1000226B0(v379 + v494[10], v475, qword_100410330);
        if ((*(unsigned int (**)(uint64_t, uint64_t, _BYTE *))(v495 + 48))(v381, 1LL, v496) == 1)
        {
          sub_1001074E8( (uint64_t)&v525,  (void (*)(void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, __int16))sub_1000578CC);
          sub_1000225EC(v381, qword_100410330);
        }

        else
        {
          v442 = v495;
          v441 = v496;
          v443 = v474;
          (*(void (**)(char *, uint64_t, _BYTE *))(v495 + 32))(v474, v381, v496);
          v444 = *(uint64_t *)((char *)v517 + *(void *)(*v517 + 280));
          swift_unownedRetainStrong(v444);
          v445 = (uint64_t)v487;
          (*(void (**)(char *, char *, _BYTE *))(v442 + 16))(v487, v443, v441);
          (*(void (**)(uint64_t, void, uint64_t, _BYTE *))(v442 + 56))(v445, 0LL, 1LL, v441);
          v446 = v118 & 0xFFFFFFFF000000FFLL | (unsigned __int16)(v518 << 8) | ((unint64_t)BYTE1(v518) << 16) & 0xFFFFFFFF00FFFFFFLL | ((unint64_t)BYTE2(v518) << 24) | ((unint64_t)BYTE3(v518) << 32) | ((unint64_t)BYTE4(v518) << 40);
          v447 = v497;
          sub_1002EA528(v446, v497);
          sub_10029FF60(v445, v447 + *(int *)(v505 + 84));
          sub_1002EA6EC(v447, v446);
          swift_release(v444);
          sub_1001074E8( (uint64_t)&v525,  (void (*)(void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, __int16))sub_1000578CC);
          (*(void (**)(char *, _BYTE *))(v442 + 8))(v474, v441);
        }

        v156 = (char *)v507;
      }

      else
      {
        sub_1001074E8( (uint64_t)&v525,  (void (*)(void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, __int16))sub_1000578CC);
      }

      v448 = *(void *)(v379 + v380);
      v449 = swift_bridgeObjectRetain(v448);
      v450 = sub_100332ACC(v449);
      swift_bridgeObjectRelease(v448);
      __chkstk_darwin();
      v451 = v517;
      *(&v472 - 2) = (uint64_t)v517;
      *(&v472 - 1) = v38;
      sub_1002FFCD4((uint64_t (*)(int *))sub_1002A1728, (uint64_t)(&v472 - 4), v450);
      swift_bridgeObjectRelease(v450);
      v452 = *(uint64_t *)((char *)v451 + *(void *)(*v451 + 280));
      swift_unownedRetainStrong(v452);
      v453 = v511;
      v454 = v478;
      (*(void (**)(char *, uint64_t, uint64_t))(v512 + 16))( v478,  v452 + *(void *)(*(void *)v452 + 96LL),  v511);
      swift_release(v452);
      v455 = *(void *)(v379 + v380);
      v456 = swift_getAssociatedConformanceWitness( v516,  v515,  v453,  &protocol requirements base descriptor for NANController,  &associated conformance descriptor for NANController.P2PControls.Driver: NANWiFiDriver);
      v457 = *(void (**)(uint64_t, uint64_t, uint64_t))(v456 + 360);
      v458 = swift_bridgeObjectRetain(v455);
      v457(v458, v453, v456);
      if (v156)
      {
        (*(void (**)(char *, uint64_t))(v512 + 8))(v454, v453);
        swift_bridgeObjectRelease(v455);
        v459 = v38;
        v460 = v477;
        v461 = sub_100057FE8(v459, v477, type metadata accessor for NANAttribute.CustomDeviceInformation);
        v462 = (os_log_s *)Logger.logObject.getter(v461);
        v463 = static os_log_type_t.error.getter();
        if (os_log_type_enabled(v462, v463))
        {
          v464 = (uint8_t *)swift_slowAlloc(12LL, -1LL);
          v465 = (void *)swift_slowAlloc(32LL, -1LL);
          v521 = v465;
          *(_DWORD *)v464 = 136315138;
          *(void *)&v518 = v464 + 4;
          v466 = *(void *)(v460 + *(int *)(v514 + 28) + v494[11]);
          v467 = swift_bridgeObjectRetain(v466);
          v468 = Array.description.getter(v467, &type metadata for NANPeerServiceIdentifier);
          v470 = v469;
          swift_bridgeObjectRelease(v466);
          v531 = (void *)sub_10000235C(v468, v470, (uint64_t *)&v521);
          UnsafeMutableRawBufferPointer.copyMemory(from:)(&v531, v532);
          swift_bridgeObjectRelease(v470);
          sub_10005802C(v477, type metadata accessor for NANAttribute.CustomDeviceInformation);
          _os_log_impl( (void *)&_mh_execute_header,  v462,  v463,  "Failed to notify driver of datapath identifiers received in keep alive: %s",  v464,  0xCu);
          swift_arrayDestroy(v465, 1LL, &type metadata for Any[8]);
          swift_slowDealloc(v465, -1LL, -1LL);
          swift_slowDealloc(v464, -1LL, -1LL);
          swift_errorRelease(v156);
        }

        else
        {
          swift_errorRelease(v156);

          sub_10005802C(v460, type metadata accessor for NANAttribute.CustomDeviceInformation);
        }

        v471 = v500;
      }

      else
      {
        (*(void (**)(char *, uint64_t))(v512 + 8))(v454, v453);
        swift_bridgeObjectRelease(v455);
        v471 = v38;
      }

      sub_10005802C(v471, type metadata accessor for NANAttribute.CustomDeviceInformation);
      uint64_t v50 = v473;
      return sub_10005802C((uint64_t)v50, type metadata accessor for DriverEvent);
    case 0x11u:
      v251 = NANBitmap.Channel.operatingClass.getter(&v527);
      v252 = *(void *)v251;
      if (*(uint64_t *)((char *)v517 + qword_10040DD38) != *(void *)v251)
      {
        v253 = *(_BYTE *)(v251 + 28);
        v254 = *(unsigned __int8 *)(v251 + 29);
        v255 = *(_DWORD *)(v251 + 24);
        v256 = *(uint64_t *)((char *)v517 + *(void *)(*v517 + 280));
        swift_unownedRetainStrong(v256);
        v257 = sub_1002EA434();
        swift_release(v256);
        if (v255 == (_DWORD)v257
          && ((0x801004u >> (8 * v253)) & 0xFFC) == ((0x801004u >> ((v257 >> 29) & 0xF8)) & 0xFFC))
        {
          switch(v254)
          {
            case 2:
              v258 = BYTE5(v257) == 2;
              goto LABEL_100;
            case 3:
              v258 = BYTE5(v257) == 3;
              goto LABEL_100;
            case 4:
              v258 = BYTE5(v257) == 4;
              goto LABEL_100;
            case 5:
              v258 = BYTE5(v257) == 5;
              goto LABEL_100;
            case 6:
              v258 = BYTE5(v257) == 6;
LABEL_100:
              v386 = v517;
              if (!v258) {
                return sub_10005802C((uint64_t)v50, type metadata accessor for DriverEvent);
              }
              goto LABEL_102;
            default:
              v386 = v517;
              if (BYTE5(v257) - 2 >= 5 && ((v254 & 1) == 0) != ((v257 >> 40) & 1))
              {
LABEL_102:
                v387 = *(uint64_t *)((char *)v386 + qword_10040DD38);
                *(uint64_t *)((char *)v386 + qword_10040DD38) = v252;
                sub_1002806A0(v387);
              }

              break;
          }
        }
      }

      return sub_10005802C((uint64_t)v50, type metadata accessor for DriverEvent);
    case 0x14u:
      v259 = *(void *)NANBitmap.Channel.operatingClass.getter(&v527);
      v260 = *(uint64_t **)((char *)v517 + *(void *)(*v517 + 280));
      swift_unownedRetainStrong(v260);
      v261 = v511;
      v262 = v512;
      v263 = v510;
      (*(void (**)(uint64_t, char *, uint64_t))(v512 + 16))(v510, (char *)v260 + *(void *)(*v260 + 96), v511);
      swift_release(v260);
      v264 = swift_getAssociatedConformanceWitness( v516,  v515,  v261,  &protocol requirements base descriptor for NANController,  &associated conformance descriptor for NANController.P2PControls.Driver: NANWiFiDriver);
      v265 = (*(uint64_t (**)(uint64_t, uint64_t))(v264 + 368))(v261, v264);
      (*(void (**)(uint64_t, uint64_t))(v262 + 8))(v263, v261);
      if ((v265 & 1) == 0) {
        goto LABEL_60;
      }
      swift_unownedRetainStrong(v260);
      v266 = *(void *)(v259 + 16);
      if (v266)
      {
        v517 = v260;
        v473 = v46;
        v521 = _swiftEmptyArrayStorage;
        *(void *)&v518 = v259;
        sub_100267F54(0, v266, 0);
        v267 = v518;
        v268 = 0LL;
        v269 = v521;
        v270 = v521[2];
        v271 = v270;
        do
        {
          v272 = *(_DWORD *)(v267 + v268 + 32);
          v273 = *(_BYTE *)(v267 + v268 + 36);
          v274 = *(_BYTE *)(v267 + v268 + 37);
          v521 = v269;
          v275 = v269[3];
          v276 = v270 + 1;
          if (v270 >= v275 >> 1)
          {
            sub_100267F54(v275 > 1, v270 + 1, 1);
            v267 = v518;
            v269 = v521;
          }

          v269[2] = v276;
          v277 = &v269[v271 + v268 / 8];
          *((_DWORD *)v277 + 8) = v272;
          *((_BYTE *)v277 + 36) = v273;
          *((_BYTE *)v277 + 37) = v274;
          *((_BYTE *)v277 + 38) = 2;
          v268 += 8LL;
          v270 = v276;
          --v266;
        }

        while (v266);
        sub_1001074E8( (uint64_t)&v525,  (void (*)(void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, __int16))sub_1000578CC);
        uint64_t v50 = v473;
        v260 = v517;
      }

      else
      {
        sub_1001074E8( (uint64_t)&v525,  (void (*)(void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, __int16))sub_1000578CC);
        v269 = _swiftEmptyArrayStorage;
      }

      v342 = v269[2];
      if (v342)
      {
        sub_100002274(&qword_10040CD10);
        v343 = (void *)static _DictionaryStorage.allocate(capacity:)(v342);
      }

      else
      {
        v343 = _swiftEmptyDictionarySingleton;
      }

      v521 = v343;
      sub_1002A0500((uint64_t)v269, 1, (uint64_t *)&v521);
      swift_bridgeObjectRelease(v269);
      sub_1002EA7E8((uint64_t)v521);
      swift_release(v260);
      return sub_10005802C((uint64_t)v50, type metadata accessor for DriverEvent);
    default:
      sub_1001074E8( (uint64_t)&v525,  (void (*)(void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, __int16))sub_1000578CC);
      goto LABEL_48;
  }

    if ((v54 & 1) != 0) {
      goto LABEL_125;
    }
    uint64_t v62 = &v29[16 * v31];
    uint64_t v64 = *(void *)v62;
    uint64_t v63 = *((void *)v62 + 1);
    __int128 v42 = __OFSUB__(v63, v64);
    uint64_t v65 = v63 - v64;
    if (v42) {
      goto LABEL_128;
    }
    if (v65 < v53) {
      goto LABEL_15;
    }
LABEL_85:
    char v70 = v31 - 1;
    if (v31 - 1 >= v12)
    {
      __break(1u);
LABEL_118:
      __break(1u);
LABEL_119:
      __break(1u);
LABEL_120:
      __break(1u);
LABEL_121:
      __break(1u);
LABEL_122:
      __break(1u);
LABEL_123:
      __break(1u);
LABEL_124:
      __break(1u);
LABEL_125:
      __break(1u);
LABEL_126:
      __break(1u);
LABEL_127:
      __break(1u);
LABEL_128:
      __break(1u);
LABEL_129:
      __break(1u);
LABEL_130:
      __break(1u);
LABEL_131:
      __break(1u);
      goto LABEL_132;
    }

    if (!v10) {
      goto LABEL_144;
    }
    uint64_t v71 = &v29[16 * v70];
    uint64_t v72 = *(void *)v71;
    uint64_t v73 = v29;
    uint64_t v74 = &v29[16 * v31];
    BOOL v75 = *((void *)v74 + 1);
    sub_1002FAC9C((char *)(v10 + *(void *)v71), (char *)(v10 + *(void *)v74), v10 + v75, __dst);
    if (v1) {
      break;
    }
    if (v75 < v72) {
      goto LABEL_118;
    }
    if (v31 > *((void *)v11 + 2)) {
      goto LABEL_119;
    }
    *(void *)uint64_t v71 = v72;
    *(void *)&v73[16 * v70 + 8] = v75;
    uint64_t v76 = *((void *)v11 + 2);
    if (v31 >= v76) {
      goto LABEL_120;
    }
    uint64_t v12 = v76 - 1;
    memmove(v74, v74 + 16, 16 * (v76 - 1 - v31));
    __int16 v29 = v73;
    *((void *)v11 + 2) = v76 - 1;
    size_t v10 = v97;
    if (v76 <= 2) {
      goto LABEL_15;
    }
  }

  uint64_t v78 = v11;
LABEL_94:
  uint64_t v79 = v78;
LABEL_95:
  swift_bridgeObjectRelease(v79);
  v94[2] = 0LL;
  return swift_bridgeObjectRelease(v94);
}

uint64_t sub_1000820E4(char *__src, char *a2, unint64_t a3, char *__dst)
{
  unint64_t v4 = __dst;
  Swift::Int v6 = a2;
  uint64_t v7 = __src;
  int64_t v8 = a2 - __src;
  int64_t v9 = a2 - __src + 7;
  if (a2 - __src >= 0) {
    int64_t v9 = a2 - __src;
  }
  uint64_t v10 = v9 >> 3;
  uint64_t v11 = a3 - (void)a2;
  uint64_t v12 = a3 - (void)a2 + 7;
  uint64_t v13 = v12 >> 3;
  Swift::Int v25 = __dst;
  char v26 = __src;
  if (v10 >= v13)
  {
    if (v11 >= -7)
    {
      uint64_t v17 = 8 * v13;
      if (__dst != a2 || &a2[v17] <= __dst) {
        memmove(__dst, a2, 8 * v13);
      }
      unsigned int v18 = &v4[v17];
      Swift::Int v24 = &v4[v17];
      char v26 = v6;
      if (v7 < v6 && (unint64_t)(v11 - 8) <= 0xFFFFFFFFFFFFFFF0LL)
      {
        unint64_t v19 = (char *)(a3 - 8);
        unsigned int v20 = v6;
        while (1)
        {
          unsigned int v21 = v19 + 8;
          unsigned int v22 = *((_DWORD *)v20 - 2);
          v20 -= 8;
          if (*((_DWORD *)v18 - 2) >= v22)
          {
            Swift::Int v24 = v18 - 8;
            if (v21 < v18 || v19 >= v18 || v21 != v18) {
              *(void *)unint64_t v19 = *((void *)v18 - 1);
            }
            unsigned int v20 = v6;
            v18 -= 8;
            if (v6 <= v7) {
              goto LABEL_42;
            }
          }

          else
          {
            if (v21 != v6 || v19 >= v6) {
              *(void *)unint64_t v19 = *(void *)v20;
            }
            char v26 = v20;
            if (v20 <= v7) {
              goto LABEL_42;
            }
          }

          v19 -= 8;
          Swift::Int v6 = v20;
          if (v18 <= v4) {
            goto LABEL_42;
          }
        }
      }

      goto LABEL_42;
    }
  }

  else if (v8 >= -7)
  {
    size_t v14 = 8 * v10;
    if (__dst != __src || &__src[v14] <= __dst) {
      memmove(__dst, __src, v14);
    }
    Swift::Int v15 = &v4[v14];
    Swift::Int v24 = &v4[v14];
    if ((unint64_t)v6 < a3 && (unint64_t)(v8 - 8) <= 0xFFFFFFFFFFFFFFF0LL)
    {
      do
      {
        if (*(_DWORD *)v6 >= *(_DWORD *)v4)
        {
          if (v7 != v4) {
            *(void *)uint64_t v7 = *(void *)v4;
          }
          v4 += 8;
          Swift::Int v25 = v4;
          unsigned int v16 = v6;
        }

        else
        {
          unsigned int v16 = v6 + 8;
          if (v7 < v6 || v7 >= v16 || v7 != v6) {
            *(void *)uint64_t v7 = *(void *)v6;
          }
        }

        v7 += 8;
        if (v4 >= v15) {
          break;
        }
        Swift::Int v6 = v16;
      }

      while ((unint64_t)v16 < a3);
      char v26 = v7;
    }

uint64_t sub_100082360(char *__src, char *a2, unint64_t a3, char *__dst)
{
  unint64_t v4 = __dst;
  Swift::Int v6 = a2;
  uint64_t v7 = __src;
  int64_t v8 = a2 - __src;
  int64_t v9 = a2 - __src + 31;
  if (a2 - __src >= 0) {
    int64_t v9 = a2 - __src;
  }
  uint64_t v10 = v9 >> 5;
  uint64_t v11 = a3 - (void)a2;
  uint64_t v12 = a3 - (void)a2 + 31;
  uint64_t v13 = v12 >> 5;
  uint64_t v28 = __src;
  int v27 = __dst;
  if (v10 >= v12 >> 5)
  {
    if (v11 >= -31)
    {
      if (__dst != a2 || &a2[32 * v13] <= __dst) {
        memmove(__dst, a2, 32 * v13);
      }
      unsigned int v18 = &v4[32 * v13];
      char v26 = v18;
      uint64_t v28 = v6;
      if (v7 < v6 && v11 >= 32)
      {
        unint64_t v19 = (char *)(a3 - 32);
        unsigned int v20 = v6;
        while (1)
        {
          unsigned int v21 = v19 + 32;
          unsigned int v22 = *((_DWORD *)v20 - 8);
          v20 -= 32;
          if (*((_DWORD *)v18 - 8) >= v22)
          {
            char v26 = v18 - 32;
            if (v21 < v18 || v19 >= v18 || v21 != v18)
            {
              __int128 v24 = *((_OWORD *)v18 - 1);
              *(_OWORD *)unint64_t v19 = *((_OWORD *)v18 - 2);
              *((_OWORD *)v19 + 1) = v24;
            }

            unsigned int v20 = v6;
            v18 -= 32;
            if (v6 <= v7) {
              goto LABEL_42;
            }
          }

          else
          {
            if (v21 != v6 || v19 >= v6)
            {
              __int128 v23 = *((_OWORD *)v20 + 1);
              *(_OWORD *)unint64_t v19 = *(_OWORD *)v20;
              *((_OWORD *)v19 + 1) = v23;
            }

            uint64_t v28 = v20;
            if (v20 <= v7) {
              goto LABEL_42;
            }
          }

          v19 -= 32;
          Swift::Int v6 = v20;
          if (v18 <= v4) {
            goto LABEL_42;
          }
        }
      }

      goto LABEL_42;
    }
  }

  else if (v8 >= -31)
  {
    if (__dst != __src || &__src[32 * v10] <= __dst) {
      memmove(__dst, __src, 32 * v10);
    }
    size_t v14 = &v4[32 * v10];
    char v26 = v14;
    if ((unint64_t)v6 < a3 && v8 >= 32)
    {
      do
      {
        if (*(_DWORD *)v6 >= *(_DWORD *)v4)
        {
          if (v7 != v4)
          {
            __int128 v17 = *((_OWORD *)v4 + 1);
            *(_OWORD *)uint64_t v7 = *(_OWORD *)v4;
            *((_OWORD *)v7 + 1) = v17;
          }

          v4 += 32;
          int v27 = v4;
          Swift::Int v15 = v6;
        }

        else
        {
          Swift::Int v15 = v6 + 32;
          if (v7 < v6 || v7 >= v15 || v7 != v6)
          {
            __int128 v16 = *((_OWORD *)v6 + 1);
            *(_OWORD *)uint64_t v7 = *(_OWORD *)v6;
            *((_OWORD *)v7 + 1) = v16;
          }
        }

        v7 += 32;
        if (v4 >= v14) {
          break;
        }
        Swift::Int v6 = v15;
      }

      while ((unint64_t)v15 < a3);
      uint64_t v28 = v7;
    }

uint64_t sub_1000825D8(uint64_t a1, uint64_t a2, uint64_t a3, char a4)
{
  uint64_t v21 = a3;
  char v22 = a4;
  uint64_t v9 = sub_100002274(&qword_1004068F8);
  uint64_t v10 = sub_100002274((uint64_t *)&unk_100410490);
  if (swift_dynamicCast(v19, &v21, v9, v10, 6LL))
  {
    sub_1000589F8(v19, (uint64_t)&v23);
    uint64_t v11 = *((void *)&v24 + 1);
    uint64_t v12 = v25;
    uint64_t v13 = sub_100021104(&v23, *((uint64_t *)&v24 + 1));
    __chkstk_darwin(v13);
    v18[2] = v4;
    void v18[3] = a1;
    v18[4] = a2;
    dispatch thunk of ContiguousBytes.withUnsafeBytes<A>(_:)( &type metadata for (),  sub_100089D50,  v18,  &type metadata for () + 1,  v11,  v12);
    return sub_100002AC4(&v23);
  }

  uint64_t v20 = 0LL;
  memset(v19, 0, sizeof(v19));
  sub_1000225EC((uint64_t)v19, &qword_100406900);
  if (a3 <= 0)
  {
    __int128 v16 = 0LL;
    uint64_t v17 = 0LL;
  }

  else
  {
    if ((unint64_t)a3 > 0x20)
    {
      Swift::Int v15 = (_BYTE *)swift_slowAlloc(a3, -1LL);
      sub_100082790(v15, a3, a3, a4, v4, a1, a2, a3);
      return swift_slowDealloc(v15, -1LL, -1LL);
    }

    __int128 v23 = 0u;
    __int128 v24 = 0u;
    __int128 v16 = &v23;
    uint64_t v17 = a3;
  }

  return sub_100082790(v16, v17, a3, a4, v4, a1, a2, a3);
}

uint64_t sub_100082790( _BYTE *a1, uint64_t a2, uint64_t a3, char a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result = sub_100176A3C((uint64_t)&v16, a1, a2, a3, a4);
  if (result == a2)
  {
    uint64_t v14 = v17;
    uint64_t v15 = v16;
    if (v17 == v16) {
      return Data._Representation.replaceSubrange(_:with:count:)(a6, a7, a1, a8);
    }
  }

  else
  {
    __break(1u);
  }

  if ((v14 & 0x8000000000000000LL) == 0 && v14 < v15) {
    __break(1u);
  }
  __break(1u);
  return result;
}

void sub_100082834(uint64_t a1, uint64_t a2)
{
  Swift::UInt v4 = *(void *)(a2 + 16);
  Hasher._combine(_:)(v4);
  if (v4)
  {
    uint64_t v5 = (unint64_t *)(a2 + 56);
    do
    {
      uint64_t v6 = *(v5 - 1);
      unint64_t v7 = *v5;
      Swift::UInt16 v8 = *((_WORD *)v5 - 8);
      Hasher._combine(_:)(*((_BYTE *)v5 - 24));
      Hasher._combine(_:)(v8);
      sub_100020AFC(v6, v7);
      Data.hash(into:)(a1, v6, v7);
      sub_1000208D8(v6, v7);
      v5 += 4;
      --v4;
    }

    while (v4);
  }

void sub_1000828C4(uint64_t a1, uint64_t a2)
{
  Swift::UInt v3 = *(void *)(a2 + 16);
  Hasher._combine(_:)(v3);
  if (v3)
  {
    uint64_t v4 = a2 + 32;
    do
    {
      __int16 v5 = *(_WORD *)(v4 + 6);
      __int16 v6 = *(_WORD *)(v4 + 8);
      __int16 v12 = *(_WORD *)(v4 + 10);
      __int16 v13 = *(_WORD *)(v4 + 12);
      Swift::UInt8 v7 = *(_BYTE *)(v4 + 1);
      Swift::UInt8 v8 = *(_BYTE *)(v4 + 2);
      Swift::UInt8 v9 = *(_BYTE *)(v4 + 3);
      Swift::UInt8 v10 = *(_BYTE *)(v4 + 4);
      Swift::UInt8 v11 = *(_BYTE *)(v4 + 5);
      Hasher._combine(_:)(*(_BYTE *)v4);
      Hasher._combine(_:)(v7);
      Hasher._combine(_:)(v8);
      Hasher._combine(_:)(v9);
      Hasher._combine(_:)(v10);
      Hasher._combine(_:)(v11);
      if ((v5 & 0xFF00) == 0x2200)
      {
        Hasher._combine(_:)(0);
      }

      else
      {
        Hasher._combine(_:)(1u);
        Hasher._combine(_:)(word_10033E73C[(char)v5]);
        Hasher._combine(_:)(*(_WORD *)((char *)&unk_10033E7A8 + (((uint64_t)v5 >> 7) & 0xFFFFFFFFFFFFFELL)));
      }

      if ((v6 & 0xFF00) == 0x2200)
      {
        Hasher._combine(_:)(0);
      }

      else
      {
        Hasher._combine(_:)(1u);
        Hasher._combine(_:)(word_10033E73C[(char)v6]);
        Hasher._combine(_:)(*(_WORD *)((char *)&unk_10033E7A8 + (((uint64_t)v6 >> 7) & 0xFFFFFFFFFFFFFELL)));
      }

      if ((v12 & 0xFF00) == 0x2200)
      {
        Hasher._combine(_:)(0);
      }

      else
      {
        Hasher._combine(_:)(1u);
        Hasher._combine(_:)(word_10033E73C[(char)v12]);
        Hasher._combine(_:)(*(_WORD *)((char *)&unk_10033E7A8 + (((uint64_t)v12 >> 7) & 0xFFFFFFFFFFFFFELL)));
      }

      if ((v13 & 0xFF00) == 0x2200)
      {
        Hasher._combine(_:)(0);
      }

      else
      {
        Hasher._combine(_:)(1u);
        Hasher._combine(_:)(word_10033E73C[(char)v13]);
        Hasher._combine(_:)(*(_WORD *)((char *)&unk_10033E7A8 + (((uint64_t)v13 >> 7) & 0xFFFFFFFFFFFFFELL)));
      }

      v4 += 14LL;
      --v3;
    }

    while (v3);
  }

void sub_100082AA4(uint64_t a1, uint64_t a2)
{
  Swift::UInt v3 = *(void *)(a2 + 16);
  Hasher._combine(_:)(v3);
  if (v3)
  {
    uint64_t v4 = (Swift::UInt64 *)(a2 + 32);
    do
    {
      Swift::UInt64 v6 = *v4++;
      Swift::UInt64 v5 = v6;
      if ((v6 & 0x7FFFFFFFFFFFFFFFLL) != 0) {
        Swift::UInt64 v7 = v5;
      }
      else {
        Swift::UInt64 v7 = 0LL;
      }
      Hasher._combine(_:)(v7);
      --v3;
    }

    while (v3);
  }

void sub_100082AF8(uint64_t a1, uint64_t a2)
{
  Swift::UInt v3 = *(void *)(a2 + 16);
  Hasher._combine(_:)(v3);
  if (v3)
  {
    uint64_t v4 = (unsigned __int8 *)(a2 + 40);
    do
    {
      Swift::UInt16 v5 = *((_WORD *)v4 - 1);
      int v6 = *v4;
      Swift::UInt16 v7 = *((_WORD *)v4 - 3);
      Swift::UInt8 v8 = *(v4 - 4);
      Hasher._combine(_:)(*(v4 - 8));
      Hasher._combine(_:)(v7);
      Hasher._combine(_:)(v8);
      if (v6 == 1)
      {
        Hasher._combine(_:)(0);
      }

      else
      {
        Hasher._combine(_:)(1u);
        Hasher._combine(_:)(v5);
      }

      v4 += 10;
      --v3;
    }

    while (v3);
  }

void sub_100082BA0(uint64_t a1, uint64_t a2)
{
  Swift::UInt v3 = *(void *)(a2 + 16);
  Hasher._combine(_:)(v3);
  if (v3)
  {
    uint64_t v4 = (unsigned __int8 *)(a2 + 37);
    do
    {
      char v6 = *(v4 - 1);
      int v7 = *v4;
      Hasher._combine(_:)(*(_DWORD *)(v4 - 5));
      Hasher._combine(_:)(0x801004u >> (8 * v6));
      switch(v7)
      {
        case 2:
          Swift::UInt v5 = 0LL;
          goto LABEL_4;
        case 3:
          Swift::UInt v5 = 1LL;
          goto LABEL_4;
        case 4:
          Swift::UInt v5 = 3LL;
          goto LABEL_4;
        case 5:
          Swift::UInt v5 = 4LL;
          goto LABEL_4;
        case 6:
          Swift::UInt v5 = 5LL;
LABEL_4:
          Hasher._combine(_:)(v5);
          break;
        default:
          Hasher._combine(_:)(2uLL);
          Hasher._combine(_:)(v7 & 1);
          break;
      }

      v4 += 8;
      --v3;
    }

    while (v3);
  }

void sub_100082C84(uint64_t a1, uint64_t a2)
{
  Swift::UInt v3 = *(void *)(a2 + 16);
  Hasher._combine(_:)(v3);
  if (v3)
  {
    uint64_t v4 = (unsigned int *)(a2 + 32);
    do
    {
      unint64_t v6 = *v4 | ((unint64_t)*((unsigned __int16 *)v4 + 2) << 32);
      if ((v6 & 0xFF00000000LL) == 0x300000000LL)
      {
        Swift::UInt8 v5 = 0;
LABEL_4:
        Hasher._combine(_:)(v5);
      }

      else
      {
        Hasher._combine(_:)(1u);
        Hasher._combine(_:)(v6);
        Hasher._combine(_:)(0x801004u >> ((v6 >> 29) & 0xF8));
        switch(v6 >> 40)
        {
          case 2uLL:
            Hasher._combine(_:)(0LL);
            break;
          case 3uLL:
            Hasher._combine(_:)(1uLL);
            break;
          case 4uLL:
            Hasher._combine(_:)(3uLL);
            break;
          case 5uLL:
            Hasher._combine(_:)(4uLL);
            break;
          case 6uLL:
            Hasher._combine(_:)(5uLL);
            break;
          default:
            Hasher._combine(_:)(2uLL);
            Swift::UInt8 v5 = BYTE5(v6) & 1;
            goto LABEL_4;
        }
      }

      v4 += 2;
      --v3;
    }

    while (v3);
  }

void sub_100082DA0(uint64_t a1, uint64_t a2)
{
  Swift::UInt v3 = *(void *)(a2 + 16);
  Hasher._combine(_:)(v3);
  if (v3)
  {
    uint64_t v4 = (Swift::UInt8 *)(a2 + 38);
    do
    {
      char v6 = *(v4 - 2);
      int v7 = *(v4 - 1);
      Swift::UInt8 v8 = *v4;
      Hasher._combine(_:)(*(_DWORD *)(v4 - 6));
      Hasher._combine(_:)(0x801004u >> (8 * v6));
      switch(v7)
      {
        case 2:
          Swift::UInt v5 = 0LL;
          goto LABEL_4;
        case 3:
          Swift::UInt v5 = 1LL;
          goto LABEL_4;
        case 4:
          Swift::UInt v5 = 3LL;
          goto LABEL_4;
        case 5:
          Swift::UInt v5 = 4LL;
          goto LABEL_4;
        case 6:
          Swift::UInt v5 = 5LL;
LABEL_4:
          Hasher._combine(_:)(v5);
          break;
        default:
          Hasher._combine(_:)(2uLL);
          Hasher._combine(_:)(v7 & 1);
          break;
      }

      v4 += 8;
      Hasher._combine(_:)(v8);
      --v3;
    }

    while (v3);
  }

void sub_100082E90(uint64_t a1, uint64_t a2)
{
  Swift::UInt v4 = *(void *)(a2 + 16);
  Hasher._combine(_:)(v4);
  if (v4)
  {
    uint64_t v5 = a2 + 32;
    do
    {
      uint64_t v6 = *(void *)(v5 + 8);
      unint64_t v7 = *(void *)(v5 + 16);
      Swift::UInt8 v8 = *(_BYTE *)(v5 + 1);
      Hasher._combine(_:)(*(_BYTE *)v5);
      Hasher._combine(_:)(v8);
      sub_100020AFC(v6, v7);
      Data.hash(into:)(a1, v6, v7);
      sub_1000208D8(v6, v7);
      v5 += 24LL;
      --v4;
    }

    while (v4);
  }

void NANAttribute.FineTimingMeasurementRangeReport.hash(into:)(uint64_t a1, uint64_t a2)
{
  Swift::UInt v3 = *(void *)(a2 + 16);
  Hasher._combine(_:)(v3);
  if (v3)
  {
    Swift::UInt v4 = (Swift::UInt8 *)(a2 + 45);
    do
    {
      Swift::UInt32 v5 = *(_DWORD *)(v4 - 13);
      Swift::UInt8 v6 = *(v4 - 9);
      Swift::UInt8 v7 = *(v4 - 8);
      Swift::UInt8 v8 = *(v4 - 7);
      Swift::UInt8 v9 = *(v4 - 6);
      Swift::UInt8 v10 = *(v4 - 5);
      Swift::UInt8 v11 = *(v4 - 4);
      Swift::UInt8 v12 = *(v4 - 3);
      Swift::UInt8 v14 = *(v4 - 2);
      Swift::UInt8 v15 = *(v4 - 1);
      Swift::UInt8 v13 = *v4;
      v4 += 16;
      Hasher._combine(_:)(v5);
      Hasher._combine(_:)(v6);
      Hasher._combine(_:)(v7);
      Hasher._combine(_:)(v8);
      Hasher._combine(_:)(v9);
      Hasher._combine(_:)(v10);
      Hasher._combine(_:)(v11);
      Hasher._combine(_:)(v12);
      Hasher._combine(_:)(v14);
      Hasher._combine(_:)(v15);
      Hasher._combine(_:)(v13);
      --v3;
    }

    while (v3);
  }

void sub_10008300C(uint64_t a1, uint64_t a2)
{
  Swift::UInt v4 = *(void *)(a2 + 16);
  Hasher._combine(_:)(v4);
  Swift::UInt v22 = v4;
  if (v4)
  {
    uint64_t v5 = 0LL;
    uint64_t v21 = a2 + 32;
    do
    {
      uint64_t v6 = v21 + 56 * v5;
      uint64_t v7 = *(void *)(v6 + 8);
      uint64_t v8 = *(void *)(v6 + 16);
      unint64_t v9 = *(void *)(v6 + 24);
      Swift::UInt8 v10 = *(_BYTE *)(v6 + 32);
      uint64_t v11 = *(void *)(v6 + 40);
      char v12 = *(_BYTE *)(v6 + 48);
      Hasher._combine(_:)(*(_WORD *)v6);
      uint64_t v24 = v7;
      if (v9 >> 60 == 15)
      {
        Hasher._combine(_:)(0);
        sub_100058430(v7, v8, v9);
        swift_bridgeObjectRetain(v11);
      }

      else
      {
        Hasher._combine(_:)(1u);
        Hasher._combine(_:)(v7);
        sub_100058430(v7, v8, v9);
        swift_bridgeObjectRetain(v11);
        sub_100058430(v7, v8, v9);
        Data.hash(into:)(a1, v8, v9);
        sub_100057CA0(v7, v8, v9);
      }

      Hasher._combine(_:)(v10);
      Hasher._combine(_:)(*(void *)(v11 + 16));
      uint64_t v13 = *(void *)(v11 + 16);
      uint64_t v23 = v8;
      if ((v12 & 1) != 0)
      {
        if (v13)
        {
          Swift::UInt8 v14 = (unsigned __int8 *)(v11 + 40);
          do
          {
            Swift::UInt16 v15 = *((_WORD *)v14 - 1);
            int v16 = *v14;
            Swift::UInt16 v17 = *((_WORD *)v14 - 3);
            Swift::UInt8 v18 = *(v14 - 4);
            Hasher._combine(_:)(*(v14 - 8));
            Hasher._combine(_:)(v17);
            Hasher._combine(_:)(v18);
            if (v16 == 1)
            {
              Hasher._combine(_:)(0);
            }

            else
            {
              Hasher._combine(_:)(1u);
              Hasher._combine(_:)(v15);
            }

            v14 += 10;
            --v13;
          }

          while (v13);
        }
      }

      else if (v13)
      {
        unint64_t v19 = (Swift::UInt8 *)(v11 + 32);
        do
        {
          Swift::UInt8 v20 = *v19++;
          Hasher._combine(_:)(v20);
          --v13;
        }

        while (v13);
      }

      ++v5;
      sub_100057CA0(v24, v23, v9);
      swift_bridgeObjectRelease(v11);
    }

    while (v5 != v22);
  }

void sub_1000831EC(uint64_t a1, uint64_t a2)
{
  Swift::UInt v4 = *(void *)(a2 + 16);
  Hasher._combine(_:)(v4);
  if (v4)
  {
    uint64_t v5 = a2 + 32;
    do
    {
      uint64_t v6 = *(void *)(v5 + 8);
      unint64_t v7 = *(void *)(v5 + 16);
      Swift::UInt8 v8 = *(_BYTE *)(v5 + 1);
      Swift::UInt8 v9 = *(_BYTE *)(v5 + 2);
      Hasher._combine(_:)(*(_BYTE *)v5);
      Hasher._combine(_:)(v8);
      Hasher._combine(_:)(v9);
      sub_100020AFC(v6, v7);
      Data.hash(into:)(a1, v6, v7);
      sub_1000208D8(v6, v7);
      v5 += 24LL;
      --v4;
    }

    while (v4);
  }

void sub_100083290(uint64_t a1, uint64_t a2)
{
  Swift::UInt v3 = *(void *)(a2 + 16);
  Hasher._combine(_:)(v3);
  if (v3)
  {
    Swift::UInt v4 = (Swift::UInt8 *)(a2 + 38);
    do
    {
      Swift::UInt8 v5 = *(v4 - 6);
      Swift::UInt8 v6 = *(v4 - 5);
      Swift::UInt8 v7 = *(v4 - 4);
      Swift::UInt8 v8 = *(v4 - 3);
      Swift::UInt8 v9 = *(v4 - 2);
      Swift::UInt8 v10 = *(v4 - 1);
      Swift::UInt8 v11 = *v4;
      v4 += 7;
      Hasher._combine(_:)(v5);
      Hasher._combine(_:)(v6);
      Hasher._combine(_:)(v7);
      Hasher._combine(_:)(v8);
      Hasher._combine(_:)(v9);
      Hasher._combine(_:)(v10);
      Hasher._combine(_:)(v11);
      --v3;
    }

    while (v3);
  }

void sub_10008333C(uint64_t a1, uint64_t a2)
{
  Swift::UInt v4 = *(void *)(a2 + 16);
  Hasher._combine(_:)(v4);
  if (v4)
  {
    Swift::UInt8 v5 = (void *)(a2 + 80);
    do
    {
      uint64_t v7 = *(v5 - 5);
      unint64_t v6 = *(v5 - 4);
      uint64_t v8 = *(v5 - 3);
      unint64_t v9 = *(v5 - 2);
      uint64_t v11 = *(v5 - 1);
      uint64_t v10 = *v5;
      Hasher._combine(_:)(*((_BYTE *)v5 - 48) + 1);
      sub_100020AFC(v7, v6);
      sub_10002255C(v8, v9);
      swift_bridgeObjectRetain(v10);
      sub_100020AFC(v7, v6);
      Data.hash(into:)(a1, v7, v6);
      sub_1000208D8(v7, v6);
      if (v9 >> 60 == 15)
      {
        Hasher._combine(_:)(0);
        if (v10) {
          goto LABEL_9;
        }
      }

      else
      {
        Hasher._combine(_:)(1u);
        sub_100020AFC(v8, v9);
        Data.hash(into:)(a1, v8, v9);
        sub_100020B40(v8, v9);
        if (v10)
        {
LABEL_9:
          Hasher._combine(_:)(1u);
          swift_bridgeObjectRetain(v10);
          String.hash(into:)(a1, v11, v10);
          swift_bridgeObjectRelease(v10);
          goto LABEL_4;
        }
      }

      Hasher._combine(_:)(0);
LABEL_4:
      sub_1000208D8(v7, v6);
      sub_100020B40(v8, v9);
      swift_bridgeObjectRelease(v10);
      v5 += 7;
      --v4;
    }

    while (v4);
  }

uint64_t _s7CoreP2P20NANAvailabilityEntryV23__derived_struct_equalsySbAC_ACtFZ_0( unsigned __int16 *a1, unsigned __int16 *a2)
{
  if (*a1 != *a2) {
    return 0LL;
  }
  uint64_t v4 = *((void *)a1 + 1);
  uint64_t v5 = *((void *)a1 + 2);
  unint64_t v6 = *((void *)a1 + 3);
  uint64_t v7 = *((void *)a2 + 1);
  uint64_t v8 = *((void *)a2 + 2);
  unint64_t v9 = *((void *)a2 + 3);
  if (v6 >> 60 != 15)
  {
    if (v9 >> 60 != 15)
    {
      sub_100058430(*((void *)a1 + 1), v5, v6);
      sub_100058430(v7, v8, v9);
      _s7CoreP2P6NANPMKV23__derived_struct_equalsySbAC_ACtFZ_0(v5, v6);
      char v13 = v12;
      sub_100057CA0(v7, v8, v9);
      sub_100057CA0(v4, v5, v6);
      if ((v13 & 1) == 0) {
        return 0LL;
      }
      goto LABEL_4;
    }

unint64_t _s7CoreP2P20NANAvailabilityEntryV15UsagePreferenceO8rawValueAESgSi_tcfC_0( unint64_t result)
{
  if (result >= 4) {
    return 4LL;
  }
  return result;
}

uint64_t sub_100083634(unint64_t a1, uint64_t a2, unint64_t a3)
{
  uint64_t v7 = type metadata accessor for Data.Iterator(0LL);
  __chkstk_darwin(v7);
  if (a3 >> 60 == 15)
  {
    unint64_t v8 = sub_1000033FC();
    uint64_t v9 = swift_allocError(&type metadata for WiFiError, v8, 0LL, 0LL);
    *(_OWORD *)uint64_t v10 = xmmword_100337020;
    *(_BYTE *)(v10 + 16) = 2;
    return swift_willThrow(v9);
  }

  else
  {
    sub_100159FC8(4u);
    sub_100020AFC(a2, a3);
    if (v3)
    {
      swift_errorRelease(v3);
    }

    else
    {
      int v15 = _s7CoreP2P19NANIntervalDurationO8rawValueACSgs5UInt8V_tcfC_0(a1 & 7);
      if ((v15 - 1) < 3) {
        __asm { BR              X10 }
      }

      if (!v15)
      {
        sub_100020AFC(a2, a3);
        unsigned int v16 = (a1 >> 6) & 7;
        if (v16)
        {
          uint64_t v17 = (a1 >> 6) & 7;
          if (v17 >= 5)
          {
            int v19 = a1 >> 6;
            int v18 = v17 - v19;
            Swift::UInt8 v20 = &_mh_execute_header;
            int8x8_t v21 = 0LL;
            int v22 = v18;
            int8x8_t v23 = 0LL;
            do
            {
              int8x8_t v21 = vorr_s8( v21,  (int8x8_t)vshl_u32( (uint32x2_t)0x100000001LL,  (uint32x2_t)vand_s8((int8x8_t)v20, (int8x8_t)0xFF000000FFLL)));
              int8x8_t v23 = vorr_s8( v23,  (int8x8_t)vshl_u32( (uint32x2_t)0x100000001LL,  (uint32x2_t)vand_s8( (int8x8_t)vadd_s32((int32x2_t)v20, (int32x2_t)0x200000002LL),  (int8x8_t)0xFF000000FFLL)));
              Swift::UInt8 v20 = (const mach_header_64 *)vadd_s32((int32x2_t)v20, (int32x2_t)0x400000004LL);
              v22 -= 4;
            }

            while (v22);
          }

          else
          {
            LOBYTE(v18) = 0;
          }

          if (v16 == (v18 + 1)
            || v16 > (v18 + 1)
            && (v16 == (v18 + 2)
             || v16 > (v18 + 2)
             && (v16 == (v18 + 3)
              || v16 > (v18 + 3)
              && (v16 == (v18 + 4)
               || v16 > (v18 + 4)
               && (v16 == (v18 + 5)
                || v16 > (v18 + 5)
                && (v16 == (v18 + 6)
                 || v16 > (v18 + 6) && v16 == (v18 + 7)))))))
          {
            __asm { BR              X11 }
          }

          __break(1u);
          JUMPOUT(0x100083D0CLL);
        }

        __asm { BR              X10 }
      }
    }

    unint64_t v12 = sub_1000033FC();
    uint64_t v13 = swift_allocError(&type metadata for WiFiError, v12, 0LL, 0LL);
    *(_OWORD *)uint64_t v14 = xmmword_100337020;
    *(_BYTE *)(v14 + 16) = 2;
    swift_willThrow(v13);
    sub_100057CA0(a1, a2, a3);
    return sub_100057CA0(a1, a2, a3);
  }

void *sub_100084CF0(uint64_t a1, int a2, unint64_t a3)
{
  uint64_t v4 = v3;
  int64_t v5 = *(void *)(a1 + 16);
  unint64_t v6 = _swiftEmptyArrayStorage;
  if (v5)
  {
    __int128 v32 = _swiftEmptyArrayStorage;
    sub_1000696B4(0, v5, 0);
    unint64_t v6 = _swiftEmptyArrayStorage;
    unsigned int v9 = a2 & 0xFFFF00FF;
    for (uint64_t i = (_BYTE *)(a1 + 80); ; i += 56)
    {
      uint64_t v11 = *((void *)i - 5);
      uint64_t v12 = *((void *)i - 4);
      unint64_t v13 = *((void *)i - 3);
      char v14 = *(i - 16);
      uint64_t v15 = *((void *)i - 1);
      char v16 = *i;
      unsigned __int16 v24 = *((_WORD *)i - 24);
      uint64_t v25 = v11;
      uint64_t v26 = v12;
      unint64_t v27 = v13;
      char v28 = v14;
      uint64_t v29 = v15;
      char v30 = v16;
      sub_100058430(v11, v12, v13);
      swift_bridgeObjectRetain(v15);
      sub_100076744(&v24, v9, a3, v31);
      if (v4) {
        break;
      }
      uint64_t v4 = 0LL;
      sub_100057CA0(v11, v12, v13);
      swift_bridgeObjectRelease(v15);
      uint64_t v17 = v31[0];
      uint64_t v18 = v31[1];
      __int128 v32 = v6;
      unint64_t v20 = v6[2];
      unint64_t v19 = v6[3];
      if (v20 >= v19 >> 1)
      {
        sub_1000696B4(v19 > 1, v20 + 1, 1);
        unint64_t v6 = v32;
      }

      _OWORD v6[2] = v20 + 1;
      int8x8_t v21 = &v6[2 * v20];
      v21[4] = v17;
      void v21[5] = v18;
      if (!--v5) {
        return v6;
      }
    }

    sub_100057CA0(v11, v12, v13);
    swift_release(v6);
    swift_bridgeObjectRelease(v15);
  }

  return v6;
}

uint64_t sub_100084E74(void *a1)
{
  uint64_t v2 = sub_100002274(&qword_100406878);
  uint64_t v3 = *(void *)(v2 - 8);
  __chkstk_darwin(v2);
  int64_t v5 = (char *)&v13 - ((v4 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v6 = a1[3];
  uint64_t v7 = a1[4];
  sub_100021104(a1, v6);
  unint64_t v8 = sub_100086D58();
  dispatch thunk of Decoder.container<A>(keyedBy:)( &type metadata for NANScheduleEntry.CodingKeys,  &type metadata for NANScheduleEntry.CodingKeys,  v8,  v6,  v7);
  char v14 = 0;
  unint64_t v9 = sub_100089B2C();
  KeyedDecodingContainer.decode<A>(_:forKey:)( &v13,  &type metadata for NANMapID,  &v14,  v2,  &type metadata for NANMapID,  v9);
  uint64_t v10 = v13;
  char v14 = 1;
  unint64_t v11 = sub_100089B70();
  KeyedDecodingContainer.decode<A>(_:forKey:)( &v13,  &type metadata for NANBitmap.Time,  &v14,  v2,  &type metadata for NANBitmap.Time,  v11);
  (*(void (**)(char *, uint64_t))(v3 + 8))(v5, v2);
  sub_100002AC4(a1);
  return v10;
}

uint64_t sub_100085000(void *a1)
{
  uint64_t v3 = a1[3];
  uint64_t v4 = a1[4];
  uint64_t v5 = (uint64_t)sub_100021104(a1, v3);
  dispatch thunk of Decoder.singleValueContainer()(v13, v3, v4);
  if (!v1)
  {
    uint64_t v6 = v14;
    uint64_t v7 = v15;
    sub_100021104(v13, v14);
    uint64_t v5 = dispatch thunk of SingleValueDecodingContainer.decode(_:)(v6, v7);
    sub_100002AC4(v13);
    BOOL v8 = (v5 & 7) == 7 || (v5 & 7) == 0;
    if (v8 || (~(_DWORD)v5 & 5) == 0)
    {
      unint64_t v9 = sub_1000033FC();
      uint64_t v10 = swift_allocError(&type metadata for WiFiError, v9, 0LL, 0LL);
      *(_OWORD *)uint64_t v11 = xmmword_100337020;
      *(_BYTE *)(v11 + 16) = 2;
      swift_willThrow(v10);
    }
  }

  sub_100002AC4(a1);
  return v5;
}

uint64_t sub_100085110(void *a1)
{
  uint64_t v3 = sub_100002274(&qword_100406868);
  uint64_t v4 = *(void *)(v3 - 8);
  __chkstk_darwin(v3);
  uint64_t v6 = (char *)&v13 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v7 = a1[3];
  uint64_t v8 = a1[4];
  sub_100021104(a1, v7);
  unint64_t v9 = sub_100086E24();
  dispatch thunk of Decoder.container<A>(keyedBy:)( &type metadata for NonNANBeaconInformation.CodingKeys,  &type metadata for NonNANBeaconInformation.CodingKeys,  v9,  v7,  v8);
  if (v1)
  {
    sub_100002AC4(a1);
  }

  else
  {
    char v15 = 0;
    unsigned __int16 v10 = KeyedDecodingContainer.decode(_:forKey:)(&v15, v3);
    char v14 = 1;
    unsigned __int16 v11 = KeyedDecodingContainer.decode(_:forKey:)(&v14, v3);
    (*(void (**)(char *, uint64_t))(v4 + 8))(v6, v3);
    sub_100002AC4(a1);
    return v10 | (v11 << 16);
  }

  return v7;
}

uint64_t sub_100085260(void *a1)
{
  uint64_t v3 = sub_100002274(&qword_100406870);
  uint64_t v4 = *(void *)(v3 - 8);
  __chkstk_darwin(v3);
  uint64_t v6 = (char *)&v14 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v7 = a1[3];
  uint64_t v8 = a1[4];
  sub_100021104(a1, v7);
  unint64_t v9 = sub_100086DE0();
  dispatch thunk of Decoder.container<A>(keyedBy:)( &type metadata for NonNANOperatingChannelInformation.CodingKeys,  &type metadata for NonNANOperatingChannelInformation.CodingKeys,  v9,  v7,  v8);
  if (v1) {
    return sub_100002AC4(a1);
  }
  char v17 = 0;
  unsigned __int8 v10 = KeyedDecodingContainer.decode(_:forKey:)(&v17, v3);
  char v16 = 1;
  unsigned __int8 v11 = KeyedDecodingContainer.decode(_:forKey:)(&v16, v3);
  char v15 = 2;
  unsigned __int8 v12 = KeyedDecodingContainer.decode(_:forKey:)(&v15, v3);
  (*(void (**)(char *, uint64_t))(v4 + 8))(v6, v3);
  sub_100002AC4(a1);
  return (unsigned __int16)(v11 << 8) | (v12 << 16) | v10;
}

uint64_t sub_1000853DC(void *a1)
{
  uint64_t v3 = type metadata accessor for CodingUserInfoKey(0LL);
  uint64_t v4 = *(void *)(v3 - 8);
  __chkstk_darwin(v3);
  uint64_t v6 = (char *)&v29 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v7 = a1[3];
  uint64_t v8 = a1[4];
  sub_100021104(a1, v7);
  dispatch thunk of Decoder.unkeyedContainer()(v33, v7, v8);
  if (v1) {
    return sub_100002AC4(a1);
  }
  uint64_t v9 = v34;
  uint64_t v10 = v35;
  sub_1000237C8((uint64_t)v33, v34);
  UnkeyedDecodingContainer.inferredDecode<A>()( v9,  (uint64_t)&type metadata for UInt8,  v10,  (uint64_t)&protocol witness table for UInt8);
  uint64_t v11 = v31;
  uint64_t v12 = v34;
  uint64_t v13 = v35;
  sub_1000237C8((uint64_t)v33, v34);
  UnkeyedDecodingContainer.inferredDecode<A>()( v12,  (uint64_t)&type metadata for UInt16,  v13,  (uint64_t)&protocol witness table for UInt16);
  uint64_t v14 = (unsigned __int16)v31;
  uint64_t v15 = v34;
  uint64_t v16 = v35;
  sub_1000237C8((uint64_t)v33, v34);
  UnkeyedDecodingContainer.inferredDecode<A>()( v15,  (uint64_t)&type metadata for UInt8,  v16,  (uint64_t)&protocol witness table for UInt8);
  uint64_t v29 = v31;
  uint64_t v30 = v11;
  uint64_t v18 = a1[3];
  uint64_t v19 = a1[4];
  sub_100021104(a1, v18);
  uint64_t v20 = dispatch thunk of Decoder.userInfo.getter(v18, v19);
  if (qword_100404160 != -1) {
    swift_once(&qword_100404160, sub_1000BD3FC);
  }
  uint64_t v21 = sub_1000032DC(v3, (uint64_t)static CodingUserInfoKey.channelInformationHasAuxillaryBitmap);
  (*(void (**)(char *, uint64_t, uint64_t))(v4 + 16))(v6, v21, v3);
  if (*(void *)(v20 + 16) && (unint64_t v22 = sub_10001C320((uint64_t)v6), (v23 & 1) != 0))
  {
    sub_100002AE4(*(void *)(v20 + 56) + 32 * v22, (uint64_t)&v31);
  }

  else
  {
    __int128 v31 = 0u;
    __int128 v32 = 0u;
  }

  swift_bridgeObjectRelease(v20);
  (*(void (**)(char *, uint64_t))(v4 + 8))(v6, v3);
  if (!*((void *)&v32 + 1))
  {
    sub_1000225EC((uint64_t)&v31, &qword_100405280);
LABEL_15:
    unint64_t v28 = 0LL;
    goto LABEL_16;
  }

  if ((swift_dynamicCast(&v36, &v31, (char *)&type metadata for Any + 8, &type metadata for Bool, 6LL) & 1) == 0
    || v36 != 1)
  {
    goto LABEL_15;
  }

  uint64_t v24 = v34;
  uint64_t v25 = v35;
  sub_1000237C8((uint64_t)v33, v34);
  uint64_t v26 = sub_100002274(&qword_100406918);
  unint64_t v27 = sub_100089DD8();
  UnkeyedDecodingContainer.inferredDecode<A>()(v24, v26, v25, v27);
  unint64_t v28 = (unint64_t)(unsigned __int16)v31 << 48;
LABEL_16:
  sub_100002AC4(v33);
  sub_100002AC4(a1);
  return v30 | (v14 << 16) | (v29 << 32) | v28;
}

uint64_t sub_100085710(void *a1)
{
  uint64_t v3 = a1[3];
  uint64_t v4 = a1[4];
  sub_100021104(a1, v3);
  dispatch thunk of Decoder.unkeyedContainer()(v14, v3, v4);
  if (!v1)
  {
    uint64_t v5 = v15;
    uint64_t v6 = v16;
    sub_1000237C8((uint64_t)v14, v15);
    unint64_t v7 = sub_100089D94();
    UnkeyedDecodingContainer.inferredDecode<A>()(v5, (uint64_t)&type metadata for NANBitmap.Time.Control, v6, v7);
    uint64_t v3 = v13;
    uint64_t v8 = sub_100002274(&qword_1004063B0);
    uint64_t v9 = v15;
    uint64_t v10 = v16;
    sub_1000237C8((uint64_t)v14, v15);
    uint64_t v11 = sub_1000572E4( &qword_100406910,  &qword_1004063B0,  (uint64_t)&protocol conformance descriptor for LengthValue<A>);
    dispatch thunk of UnkeyedDecodingContainer.decode<A>(_:)(v8, v8, v11, v9, v10);
    sub_100002AC4(v14);
  }

  sub_100002AC4(a1);
  return v3;
}

unint64_t sub_100085868()
{
  unint64_t result = qword_1004064E8;
  if (!qword_1004064E8)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for NANBitmap.Time.Control,  &type metadata for NANBitmap.Time.Control);
    atomic_store(result, (unint64_t *)&qword_1004064E8);
  }

  return result;
}

uint64_t sub_1000858AC(void *a1)
{
  uint64_t v3 = a1[3];
  uint64_t v4 = a1[4];
  sub_100021104(a1, v3);
  dispatch thunk of Decoder.unkeyedContainer()(v17, v3, v4);
  if (!v1)
  {
    uint64_t v5 = v18;
    uint64_t v6 = v19;
    sub_1000237C8((uint64_t)v17, v18);
    unint64_t v7 = sub_100089AA4();
    UnkeyedDecodingContainer.inferredDecode<A>()(v5, (uint64_t)&type metadata for NANIntervalDuration, v6, v7);
    LOBYTE(v6) = v20;
    uint64_t v8 = v18;
    uint64_t v9 = v19;
    sub_1000237C8((uint64_t)v17, v18);
    UnkeyedDecodingContainer.inferredDecode<A>()( v8,  (uint64_t)&type metadata for UInt8,  v9,  (uint64_t)&protocol witness table for UInt8);
    uint64_t v10 = v18;
    uint64_t v11 = v19;
    sub_1000237C8((uint64_t)v17, v18);
    UnkeyedDecodingContainer.inferredDecode<A>()( v10,  (uint64_t)&type metadata for UInt8,  v11,  (uint64_t)&protocol witness table for UInt8);
    unint64_t v12 = NANIntervalDuration.deprecatedAvailabilityMapSize.getter(v6);
    uint64_t v13 = v18;
    uint64_t v14 = v19;
    sub_1000237C8((uint64_t)v17, v18);
    UnkeyedDecodingContainer.decodeData(with:)(v12, v13, v14);
    __asm { BR              X10 }
  }

  return sub_100002AC4(a1);
}

void sub_100085A80(uint64_t a1, ...)
{
  uint64_t v4 = Data.subdata(in:)(0LL, BYTE6(v3), v1, v3);
  unint64_t v6 = v5;
  sub_1000208D8(v1, v3);
  sub_100020AFC(v4, v6);
  sub_1000208D8(v1, v3);
  sub_100002AC4((uint64_t *)va);
  sub_100002AC4(v2);
  sub_1000208D8(v4, v6);
  JUMPOUT(0x100085A28LL);
}

uint64_t sub_100085B2C(void *a1)
{
  uint64_t v3 = a1[3];
  uint64_t v4 = a1[4];
  sub_100021104(a1, v3);
  dispatch thunk of Decoder.unkeyedContainer()(v17, v3, v4);
  if (!v1)
  {
    uint64_t v5 = v18;
    uint64_t v6 = v19;
    sub_1000237C8((uint64_t)v17, v18);
    unint64_t v7 = sub_100089AE8();
    UnkeyedDecodingContainer.inferredDecode<A>()( v5,  (uint64_t)&type metadata for DeprecatedNANAvailability.AvailabilityControl,  v6,  v7);
    unsigned __int8 v8 = _s7CoreP2P19NANIntervalDurationO8rawValueACSgs5UInt8V_tcfC_0((v20 >> 4) & 3);
    if (v8 != 4)
    {
      unint64_t v12 = NANIntervalDuration.deprecatedAvailabilityMapSize.getter(v8);
      uint64_t v13 = v18;
      uint64_t v14 = v19;
      sub_1000237C8((uint64_t)v17, v18);
      UnkeyedDecodingContainer.decodeData(with:)(v12, v13, v14);
      __asm { BR              X10 }
    }

    unint64_t v9 = sub_1000033FC();
    uint64_t v10 = swift_allocError(&type metadata for WiFiError, v9, 0LL, 0LL);
    *(_OWORD *)uint64_t v11 = xmmword_100337020;
    *(_BYTE *)(v11 + 16) = 2;
    swift_willThrow(v10);
    sub_100002AC4(v17);
  }

  return sub_100002AC4(a1);
}

void sub_100085CCC(uint64_t a1, ...)
{
  uint64_t v4 = Data.subdata(in:)(0LL, BYTE6(v3), v2, v3);
  unint64_t v6 = v5;
  sub_1000208D8(v2, v3);
  sub_100020AFC(v4, v6);
  sub_1000208D8(v2, v3);
  sub_100002AC4((uint64_t *)va);
  sub_100002AC4(v1);
  sub_1000208D8(v4, v6);
  JUMPOUT(0x100085C6CLL);
}

void sub_100085D7C(uint64_t a1, unint64_t a2)
{
  unint64_t v4 = a2 >> 62;
  sub_100020AFC(a1, a2);
  sub_10000D9B0((uint64_t)_swiftEmptyArrayStorage);
  uint64_t v5 = type metadata accessor for BinaryDecoder();
  unint64_t v6 = (void *)swift_allocObject(v5, 48LL, 7LL);
  v6[5] = &_swiftEmptyDictionarySingleton;
  _OWORD v6[2] = a1;
  v6[3] = a2;
  __asm { BR              X10 }

uint64_t sub_100085E08(uint64_t a1)
{
  *(void *)(v5 + 32) = (int)v3;
  swift_beginAccess(a1, &v30, 1LL, 0LL);
  *(void *)(v5 + 40) = v1;
  ((void (*)())swift_bridgeObjectRelease)();
  unint64_t v28 = &type metadata for BinaryDecoder.UnkeyedContainer;
  unint64_t v8 = sub_100070240();
  unint64_t v29 = v8;
  v27[0] = v5;
  sub_1000237C8((uint64_t)v27, (uint64_t)&type metadata for BinaryDecoder.UnkeyedContainer);
  unint64_t v9 = sub_100089BB4();
  swift_retain();
  UnkeyedDecodingContainer.inferredDecode<A>()( (uint64_t)&type metadata for BinaryDecoder.UnkeyedContainer,  (uint64_t)&type metadata for NANAvailabilityEntry.Control,  v8,  v9);
  if (v4) {
    goto LABEL_7;
  }
  if ((~v24 & 5) == 0)
  {
    unint64_t v10 = sub_1000033FC();
    uint64_t v11 = swift_allocError(&type metadata for WiFiError, v10, 0LL, 0LL);
    *(_OWORD *)uint64_t v12 = xmmword_100337020;
    *(_BYTE *)(v12 + 16) = 2;
    swift_willThrow(v11);
LABEL_7:
    sub_1000208D8(v3, v2);
    swift_release(v5);
    sub_100002AC4(v27);
    return sub_100057CA0(0LL, 0LL, 0xF000000000000000LL);
  }

  if ((v24 & 0x1000) != 0)
  {
    uint64_t v16 = v28;
    unint64_t v17 = v29;
    sub_1000237C8((uint64_t)v27, (uint64_t)v28);
    unint64_t v18 = sub_100089B70();
    dispatch thunk of UnkeyedDecodingContainer.decode<A>(_:)( &type metadata for NANBitmap.Time,  &type metadata for NANBitmap.Time,  v18,  v16,  v17);
    unsigned __int16 v22 = v24;
    uint64_t v23 = v6;
    uint64_t v13 = v24;
    uint64_t v14 = v25;
    unint64_t v15 = v26;
  }

  else
  {
    unsigned __int16 v22 = v24;
    uint64_t v23 = v6;
    uint64_t v13 = 0LL;
    uint64_t v14 = 0LL;
    unint64_t v15 = 0xF000000000000000LL;
  }

  unsigned __int8 v20 = v28;
  *(void *)(v7 - 72) = v29;
  sub_1000237C8((uint64_t)v27, (uint64_t)v20);
  unint64_t v21 = sub_100089BF8();
  UnkeyedDecodingContainer.inferredDecode<A>()( (uint64_t)v20,  (uint64_t)&type metadata for NANAvailabilityEntry.BandChannelEntries,  *(void *)(v7 - 72),  v21);
  sub_1000208D8(v3, v2);
  swift_release(v5);
  ((void (*)())swift_bridgeObjectRetain)();
  sub_100002AC4(v27);
  sub_100058430(v13, v14, v15);
  sub_100057CA0(v13, v14, v15);
  uint64_t result = ((uint64_t (*)())swift_bridgeObjectRelease)();
  *(_WORD *)uint64_t v23 = v22;
  *(void *)(v23 + 8) = v13;
  *(void *)(v23 + 16) = v14;
  *(void *)(v23 + 24) = v15;
  *(_BYTE *)(v23 + 32) = v24;
  *(void *)(v23 + 40) = v25;
  *(_BYTE *)(v23 + 48) = v26;
  return result;
}

uint64_t sub_10008607C@<X0>(void *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v5 = a1[3];
  uint64_t v6 = a1[4];
  sub_100021104(a1, v5);
  dispatch thunk of Decoder.unkeyedContainer()(v15, v5, v6);
  if (v2) {
    return sub_100002AC4(a1);
  }
  uint64_t v7 = sub_100002274(&qword_1004068A0);
  uint64_t v8 = v16;
  uint64_t v9 = v17;
  sub_1000237C8((uint64_t)v15, v16);
  uint64_t v10 = sub_1000572E4(&qword_1004068A8, &qword_1004068A0, (uint64_t)&protocol conformance descriptor for LengthValue<A>);
  dispatch thunk of UnkeyedDecodingContainer.decode<A>(_:)(v7, v7, v10, v8, v9);
  sub_100085D7C(v13, v14);
  sub_100002AC4(v15);
  uint64_t result = sub_100002AC4(a1);
  __int128 v12 = v19;
  *(_OWORD *)a2 = v18;
  *(_OWORD *)(a2 + 16) = v12;
  *(_OWORD *)(a2 + 32) = v20;
  *(_BYTE *)(a2 + 48) = v21;
  return result;
}

uint64_t sub_1000861B8(void *a1)
{
  uint64_t v3 = type metadata accessor for CodingUserInfoKey(0LL);
  uint64_t v4 = *(void *)(v3 - 8);
  uint64_t v5 = __chkstk_darwin(v3);
  uint64_t v7 = (char *)&v26 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  __chkstk_darwin(v5);
  uint64_t v9 = (char *)&v26 - v8;
  uint64_t v10 = a1[3];
  uint64_t v11 = a1[4];
  sub_100021104(a1, v10);
  dispatch thunk of Decoder.unkeyedContainer()(v32, v10, v11);
  if (v1)
  {
    sub_100002AC4(a1);
  }

  else
  {
    uint64_t v12 = v33;
    uint64_t v13 = v34;
    sub_1000237C8((uint64_t)v32, v33);
    unint64_t v14 = sub_100089C3C();
    UnkeyedDecodingContainer.inferredDecode<A>()( v12,  (uint64_t)&type metadata for NANAvailabilityEntry.BandChannelEntries.Control,  v13,  v14);
    uint64_t v10 = v30[0];
    if ((v30[0] & 1) != 0)
    {
      unint64_t v35 = (unint64_t)v30[0] >> 4;
      uint64_t v16 = a1[3];
      unint64_t v27 = (void (*)(char *, uint64_t, uint64_t))a1[4];
      sub_100021104(a1, v16);
      uint64_t v17 = dispatch thunk of Decoder.userInfo.getter(v16, v27);
      if (qword_100404160 != -1) {
        swift_once(&qword_100404160, sub_1000BD3FC);
      }
      uint64_t v18 = sub_1000032DC(v3, (uint64_t)static CodingUserInfoKey.channelInformationHasAuxillaryBitmap);
      __int128 v19 = *(void (**)(char *, uint64_t, uint64_t))(v4 + 16);
      uint64_t v26 = v18;
      unint64_t v27 = v19;
      ((void (*)(char *))v19)(v9);
      else {
        memset(v31, 0, sizeof(v31));
      }
      swift_bridgeObjectRelease(v17);
      (*(void (**)(char *, uint64_t))(v4 + 8))(v9, v3);
      sub_10002084C((uint64_t)a1, (uint64_t)v30);
      uint64_t v22 = sub_100002274(&qword_1004068C8);
      uint64_t v23 = type metadata accessor for BinaryDecoder();
      if ((swift_dynamicCast(v29, v30, v22, v23, 6LL) & 1) != 0)
      {
        uint64_t v24 = v29[0];
        v27(v7, v26, v3);
        v29[3] = &type metadata for Bool;
        LOBYTE(v29[0]) = (v10 & 2) != 0;
        swift_beginAccess(v24 + 40, v28, 33LL, 0LL);
        sub_100013C3C((uint64_t)v29, (uint64_t)v7);
        swift_endAccess(v28);
        swift_release(v24);
      }

      sub_100070498(0LL, v35, (uint64_t)v32);
      sub_10002084C((uint64_t)a1, (uint64_t)v30);
      if ((swift_dynamicCast(v29, v30, v22, v23, 6LL) & 1) != 0)
      {
        uint64_t v25 = v29[0];
        v27(v7, v26, v3);
        sub_100089C80((uint64_t)v31, (uint64_t)v29);
        swift_beginAccess(v25 + 40, v28, 33LL, 0LL);
        sub_100013C3C((uint64_t)v29, (uint64_t)v7);
        swift_endAccess(v28);
        swift_release(v25);
      }

      sub_1000225EC((uint64_t)v31, &qword_100405280);
    }

    else
    {
      sub_100070338(0LL, (unint64_t)v30[0] >> 4, (uint64_t)v32);
    }

    sub_100002AC4(v32);
    sub_100002AC4(a1);
  }

  return v10;
}

uint64_t sub_10008657C(uint64_t a1, unint64_t a2)
{
  if (a1 == 0x6E6974617265706FLL && a2 == 0xEE007373616C4367LL)
  {
    unint64_t v5 = 0xEE007373616C4367LL;
    goto LABEL_8;
  }

  if ((_stringCompareWithSmolCheck(_:_:expecting:)(0x6E6974617265706FLL, 0xEE007373616C4367LL, a1, a2, 0LL) & 1) != 0)
  {
    unint64_t v5 = a2;
LABEL_8:
    swift_bridgeObjectRelease(v5);
    return 0LL;
  }

  if (a1 == 0x426C656E6E616863LL && a2 == 0xED000070616D7469LL)
  {
    unint64_t v7 = 0xED000070616D7469LL;
LABEL_14:
    swift_bridgeObjectRelease(v7);
    return 1LL;
  }

  if ((_stringCompareWithSmolCheck(_:_:expecting:)(0x426C656E6E616863LL, 0xED000070616D7469LL, a1, a2, 0LL) & 1) != 0)
  {
    unint64_t v7 = a2;
    goto LABEL_14;
  }

  if (a1 == 0xD000000000000014LL)
  {
    unint64_t v8 = 0x8000000100363E20LL;
    if (a2 == 0x8000000100363E20LL) {
      goto LABEL_19;
    }
  }

  if ((_stringCompareWithSmolCheck(_:_:expecting:)(0xD000000000000014LL, 0x8000000100363E20LL, a1, a2, 0LL) & 1) != 0)
  {
    unint64_t v8 = a2;
LABEL_19:
    swift_bridgeObjectRelease(v8);
    return 2LL;
  }

  if (a1 == 0xD000000000000016LL && a2 == 0x8000000100363E40LL)
  {
    swift_bridgeObjectRelease(0x8000000100363E40LL);
    return 3LL;
  }

  else
  {
    char v9 = _stringCompareWithSmolCheck(_:_:expecting:)(0xD000000000000016LL, 0x8000000100363E40LL, a1, a2, 0LL);
    swift_bridgeObjectRelease(a2);
    if ((v9 & 1) != 0) {
      return 3LL;
    }
    else {
      return 4LL;
    }
  }

unint64_t sub_100086770(unint64_t a1)
{
  unint64_t result = NANIntervalDuration.timeUnits.getter(0);
  if (!result)
  {
    __break(1u);
    goto LABEL_9;
  }

  unint64_t v4 = a1 / result;
  if (((a1 / result) & 0x8000000000000000LL) != 0)
  {
LABEL_9:
    __break(1u);
    goto LABEL_10;
  }

  uint64_t v6 = *(void *)(v1 + 16);
  uint64_t v5 = v1 + 16;
  uint64_t v8 = v6;
  unint64_t result = NANIntervalDuration.timeUnits.getter(0);
  if (!result)
  {
LABEL_10:
    __break(1u);
    goto LABEL_11;
  }

  if (((a1 / result) & 0x8000000000000000LL) != 0)
  {
LABEL_11:
    __break(1u);
    goto LABEL_12;
  }

  char v7 = *((_BYTE *)&v8 + ((a1 / result) >> 3));
  unint64_t result = NANIntervalDuration.timeUnits.getter(0);
  if (!result)
  {
LABEL_12:
    __break(1u);
    goto LABEL_13;
  }

  if (((a1 / result) & 0x8000000000000000LL) == 0)
  {
    *(_BYTE *)(v5 + ((a1 / result) >> 3)) = v7 | (1 << (v4 & 7));
    return result;
  }

uint64_t sub_10008681C(unint64_t a1, uint64_t a2, unint64_t a3)
{
  unint64_t v3 = a3 - a1;
  if (a3 < a1)
  {
    __break(1u);
    goto LABEL_14;
  }

  if (a2 <= 0)
  {
    if (v3 < 0x80)
    {
      if (a2 < 0) {
        return 0LL;
      }
      goto LABEL_11;
    }
  }

  else
  {
    if (a2 > v3 >> 7) {
      return 0LL;
    }
    __break(1u);
  }

  if (a2 < 0)
  {
LABEL_15:
    char v6 = 2;
    uint64_t result = _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  "Negative value is not representable",  35LL,  2LL,  "Swift/Integers.swift",  20LL,  v6,  3451LL,  0);
    __break(1u);
    return result;
  }

uint64_t sub_1000868CC(unint64_t a1, uint64_t a2, unint64_t a3)
{
  unint64_t v3 = a3 - a1;
  if (a3 < a1)
  {
    __break(1u);
    goto LABEL_14;
  }

  if (a2 <= 0)
  {
    if (v3 < 0x10)
    {
      if (a2 < 0) {
        return 0LL;
      }
      goto LABEL_11;
    }
  }

  else
  {
    if (a2 > v3 >> 4) {
      return 0LL;
    }
    __break(1u);
  }

  if (a2 < 0)
  {
LABEL_15:
    char v6 = 2;
    uint64_t result = _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  "Negative value is not representable",  35LL,  2LL,  "Swift/Integers.swift",  20LL,  v6,  3451LL,  0);
    __break(1u);
    return result;
  }

uint64_t _s7CoreP2P10TimeBitmapV14repeatingPerDWyA2C4SlotV_A3FtFZ_0(char a1, char a2, char a3, char a4)
{
  if (qword_100404120 != -1) {
    swift_once(&qword_100404120, sub_100071F04);
  }
  unint64_t v8 = (unsigned __int16)static NANBitmap.Time.Control.perDiscoveryWindow;
  sub_10006972C(0, 4LL, 0);
  unint64_t v10 = _swiftEmptyArrayStorage[2];
  unint64_t v9 = _swiftEmptyArrayStorage[3];
  int64_t v11 = v9 >> 1;
  unint64_t v12 = v10 + 1;
  if (v9 >> 1 <= v10)
  {
    sub_10006972C(v9 > 1, v10 + 1, 1);
    unint64_t v9 = _swiftEmptyArrayStorage[3];
    int64_t v11 = v9 >> 1;
  }

  _swiftEmptyArrayStorage[2] = v12;
  *((_BYTE *)&_swiftEmptyArrayStorage[4] + v10) = a1;
  unint64_t v13 = v10 + 2;
  if (v11 < (uint64_t)(v10 + 2))
  {
    sub_10006972C(v9 > 1, v10 + 2, 1);
    unint64_t v9 = _swiftEmptyArrayStorage[3];
    int64_t v11 = v9 >> 1;
  }

  _swiftEmptyArrayStorage[2] = v13;
  *((_BYTE *)&_swiftEmptyArrayStorage[4] + v12) = a2;
  unint64_t v14 = v10 + 3;
  _swiftEmptyArrayStorage[2] = v14;
  *((_BYTE *)&_swiftEmptyArrayStorage[4] + v13) = a3;
  unint64_t v15 = _swiftEmptyArrayStorage[3];
  _swiftEmptyArrayStorage[2] = v10 + 4;
  *((_BYTE *)&_swiftEmptyArrayStorage[4] + v14) = a4;
  uint64_t v16 = sub_1000FB08C((uint64_t)_swiftEmptyArrayStorage);
  unint64_t v18 = v17;
  swift_release(_swiftEmptyArrayStorage);
  return sub_100083634(v8, v16, v18);
}

unint64_t sub_100086B64()
{
  unint64_t result = qword_1004064F8;
  if (!qword_1004064F8)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for NANAvailabilityEntry.BandChannelEntries.Control,  &type metadata for NANAvailabilityEntry.BandChannelEntries.Control);
    atomic_store(result, (unint64_t *)&qword_1004064F8);
  }

  return result;
}

unint64_t sub_100086BA8()
{
  unint64_t result = qword_100406510;
  if (!qword_100406510)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for NANBitmap.Channel,  &type metadata for NANBitmap.Channel);
    atomic_store(result, (unint64_t *)&qword_100406510);
  }

  return result;
}

unint64_t sub_100086BEC()
{
  unint64_t result = qword_100406528;
  if (!qword_100406528)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for NANBitmap.Band,  &type metadata for NANBitmap.Band);
    atomic_store(result, (unint64_t *)&qword_100406528);
  }

  return result;
}

unint64_t sub_100086C30()
{
  unint64_t result = qword_100406530;
  if (!qword_100406530)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for NANAvailabilityEntry.Control,  &type metadata for NANAvailabilityEntry.Control);
    atomic_store(result, (unint64_t *)&qword_100406530);
  }

  return result;
}

uint64_t sub_100086C74(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = sub_100002274(&qword_100406538);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v4 - 8) + 32LL))(a2, a1, v4);
  return a2;
}

uint64_t sub_100086CBC(uint64_t a1)
{
  return a1;
}

unint64_t sub_100086CE8()
{
  unint64_t result = qword_100406540;
  if (!qword_100406540)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for NANBitmap.Time,  &type metadata for NANBitmap.Time);
    atomic_store(result, (unint64_t *)&qword_100406540);
  }

  return result;
}

uint64_t sub_100086D2C(uint64_t a1)
{
  return a1;
}

unint64_t sub_100086D58()
{
  unint64_t result = qword_100406550;
  if (!qword_100406550)
  {
    unint64_t result = swift_getWitnessTable(&unk_10033E68C, &type metadata for NANScheduleEntry.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_100406550);
  }

  return result;
}

unint64_t sub_100086D9C()
{
  unint64_t result = qword_100406558;
  if (!qword_100406558)
  {
    unint64_t result = swift_getWitnessTable(&protocol conformance descriptor for NANMapID, &type metadata for NANMapID);
    atomic_store(result, (unint64_t *)&qword_100406558);
  }

  return result;
}

unint64_t sub_100086DE0()
{
  unint64_t result = qword_100406568;
  if (!qword_100406568)
  {
    unint64_t result = swift_getWitnessTable(&unk_10033E63C, &type metadata for NonNANOperatingChannelInformation.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_100406568);
  }

  return result;
}

unint64_t sub_100086E24()
{
  unint64_t result = qword_100406578;
  if (!qword_100406578)
  {
    unint64_t result = swift_getWitnessTable(&unk_10033E5EC, &type metadata for NonNANBeaconInformation.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_100406578);
  }

  return result;
}

unint64_t sub_100086E68()
{
  unint64_t result = qword_100406580;
  if (!qword_100406580)
  {
    unint64_t result = swift_getWitnessTable(&unk_10033E5C4, &type metadata for DeprecatedNANAvailability.AvailabilityControl);
    atomic_store(result, (unint64_t *)&qword_100406580);
  }

  return result;
}

unint64_t sub_100086EAC()
{
  unint64_t result = qword_100406590;
  if (!qword_100406590)
  {
    unint64_t result = swift_getWitnessTable(&unk_10033E574, &type metadata for DeprecatedNANAvailabilityEntry.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_100406590);
  }

  return result;
}

unint64_t sub_100086EF0()
{
  unint64_t result = qword_100406598;
  if (!qword_100406598)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for NANIntervalDuration,  &type metadata for NANIntervalDuration);
    atomic_store(result, (unint64_t *)&qword_100406598);
  }

  return result;
}

unint64_t sub_100086F38()
{
  unint64_t result = qword_1004065A0;
  if (!qword_1004065A0)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for NANBitmap.Band,  &type metadata for NANBitmap.Band);
    atomic_store(result, (unint64_t *)&qword_1004065A0);
  }

  return result;
}

unint64_t sub_100086F80()
{
  unint64_t result = qword_1004065A8;
  if (!qword_1004065A8)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for NANBitmap.Band,  &type metadata for NANBitmap.Band);
    atomic_store(result, (unint64_t *)&qword_1004065A8);
  }

  return result;
}

unint64_t sub_100086FC8()
{
  unint64_t result = qword_1004065B0;
  if (!qword_1004065B0)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for NANBitmap.Band,  &type metadata for NANBitmap.Band);
    atomic_store(result, (unint64_t *)&qword_1004065B0);
  }

  return result;
}

unint64_t sub_100087010()
{
  unint64_t result = qword_1004065B8;
  if (!qword_1004065B8)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for NANBitmap.Band.Iterator,  &type metadata for NANBitmap.Band.Iterator);
    atomic_store(result, (unint64_t *)&qword_1004065B8);
  }

  return result;
}

unint64_t sub_100087058()
{
  unint64_t result = qword_1004065C0;
  if (!qword_1004065C0)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for NANBitmap.Band,  &type metadata for NANBitmap.Band);
    atomic_store(result, (unint64_t *)&qword_1004065C0);
  }

  return result;
}

unint64_t sub_1000870A0()
{
  unint64_t result = qword_1004065C8;
  if (!qword_1004065C8)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for NANBitmap.Channel,  &type metadata for NANBitmap.Channel);
    atomic_store(result, (unint64_t *)&qword_1004065C8);
  }

  return result;
}

unint64_t sub_1000870E8()
{
  unint64_t result = qword_1004065D0;
  if (!qword_1004065D0)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for NANBitmap.Time.Control,  &type metadata for NANBitmap.Time.Control);
    atomic_store(result, (unint64_t *)&qword_1004065D0);
  }

  return result;
}

unint64_t sub_100087130()
{
  unint64_t result = qword_1004065D8;
  if (!qword_1004065D8)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for NANBitmap.Time.Control,  &type metadata for NANBitmap.Time.Control);
    atomic_store(result, (unint64_t *)&qword_1004065D8);
  }

  return result;
}

unint64_t sub_100087178()
{
  unint64_t result = qword_1004065E0;
  if (!qword_1004065E0)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for NANBitmap.Time.Control,  &type metadata for NANBitmap.Time.Control);
    atomic_store(result, (unint64_t *)&qword_1004065E0);
  }

  return result;
}

unint64_t sub_1000871C0()
{
  unint64_t result = qword_1004065E8;
  if (!qword_1004065E8)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for NANBitmap.Time.Control,  &type metadata for NANBitmap.Time.Control);
    atomic_store(result, (unint64_t *)&qword_1004065E8);
  }

  return result;
}

unint64_t sub_100087208()
{
  unint64_t result = qword_1004065F0;
  if (!qword_1004065F0)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for NANBitmap.Time,  &type metadata for NANBitmap.Time);
    atomic_store(result, (unint64_t *)&qword_1004065F0);
  }

  return result;
}

unint64_t sub_100087250()
{
  unint64_t result = qword_1004065F8;
  if (!qword_1004065F8)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for TimeBitmap.Slot,  &type metadata for TimeBitmap.Slot);
    atomic_store(result, (unint64_t *)&qword_1004065F8);
  }

  return result;
}

unint64_t sub_100087298()
{
  unint64_t result = qword_100406600;
  if (!qword_100406600)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for TimeBitmap.SlotsView,  &type metadata for TimeBitmap.SlotsView);
    atomic_store(result, (unint64_t *)&qword_100406600);
  }

  return result;
}

uint64_t sub_1000872DC()
{
  return sub_100087780( &qword_100406608,  &qword_100406610,  (void (*)(void))sub_100087310,  (uint64_t)&protocol conformance descriptor for <> DefaultIndices<A>);
}

unint64_t sub_100087310()
{
  unint64_t result = qword_100406618;
  if (!qword_100406618)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for TimeBitmap.SlotsView,  &type metadata for TimeBitmap.SlotsView);
    atomic_store(result, (unint64_t *)&qword_100406618);
  }

  return result;
}

uint64_t sub_100087354()
{
  return sub_100087780( &qword_100406620,  &qword_100406628,  (void (*)(void))sub_100087310,  (uint64_t)&protocol conformance descriptor for <> Slice<A>);
}

unint64_t sub_10008738C()
{
  unint64_t result = qword_100406630;
  if (!qword_100406630)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for TimeBitmap.SlotsView,  &type metadata for TimeBitmap.SlotsView);
    atomic_store(result, (unint64_t *)&qword_100406630);
  }

  return result;
}

unint64_t sub_1000873D4()
{
  unint64_t result = qword_100406638;
  if (!qword_100406638)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for TimeBitmap.SlotsView,  &type metadata for TimeBitmap.SlotsView);
    atomic_store(result, (unint64_t *)&qword_100406638);
  }

  return result;
}

uint64_t sub_100087418()
{
  return sub_100087780( &qword_100406640,  &qword_100406610,  (void (*)(void))sub_100087298,  (uint64_t)&protocol conformance descriptor for <> DefaultIndices<A>);
}

uint64_t sub_10008744C()
{
  return sub_100087780( &qword_100406648,  &qword_100406628,  (void (*)(void))sub_100087298,  (uint64_t)&protocol conformance descriptor for <> Slice<A>);
}

unint64_t sub_100087484()
{
  unint64_t result = qword_100406650;
  if (!qword_100406650)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for TimeBitmap.SlotsView,  &type metadata for TimeBitmap.SlotsView);
    atomic_store(result, (unint64_t *)&qword_100406650);
  }

  return result;
}

unint64_t sub_1000874CC()
{
  unint64_t result = qword_100406658;
  if (!qword_100406658)
  {
    unint64_t result = swift_getWitnessTable(&protocol conformance descriptor for NANTimeUnit, &type metadata for NANTimeUnit);
    atomic_store(result, (unint64_t *)&qword_100406658);
  }

  return result;
}

uint64_t sub_100087510()
{
  return sub_1000572E4( &qword_100406660,  &qword_100406610,  (uint64_t)&protocol conformance descriptor for DefaultIndices<A>);
}

uint64_t sub_10008753C()
{
  return sub_1000572E4(&qword_100406668, &qword_100406628, (uint64_t)&protocol conformance descriptor for Slice<A>);
}

uint64_t sub_100087568()
{
  return sub_1000572E4( &qword_100406670,  &qword_100406678,  (uint64_t)&protocol conformance descriptor for IndexingIterator<A>);
}

unint64_t sub_100087598()
{
  unint64_t result = qword_100406680;
  if (!qword_100406680)
  {
    unint64_t result = swift_getWitnessTable(&protocol conformance descriptor for TimeBitmap, &type metadata for TimeBitmap);
    atomic_store(result, (unint64_t *)&qword_100406680);
  }

  return result;
}

unint64_t sub_1000875E0()
{
  unint64_t result = qword_100406688;
  if (!qword_100406688)
  {
    unint64_t result = swift_getWitnessTable(&protocol conformance descriptor for TimeBitmap, &type metadata for TimeBitmap);
    atomic_store(result, (unint64_t *)&qword_100406688);
  }

  return result;
}

uint64_t sub_100087624()
{
  return sub_100087780( &qword_100406690,  &qword_100406698,  (void (*)(void))sub_100087658,  (uint64_t)&protocol conformance descriptor for <> DefaultIndices<A>);
}

unint64_t sub_100087658()
{
  unint64_t result = qword_1004066A0;
  if (!qword_1004066A0)
  {
    unint64_t result = swift_getWitnessTable(&protocol conformance descriptor for TimeBitmap, &type metadata for TimeBitmap);
    atomic_store(result, (unint64_t *)&qword_1004066A0);
  }

  return result;
}

uint64_t sub_10008769C()
{
  return sub_100087780( &qword_1004066A8,  &qword_1004066B0,  (void (*)(void))sub_100087658,  (uint64_t)&protocol conformance descriptor for <> Slice<A>);
}

unint64_t sub_1000876D4()
{
  unint64_t result = qword_1004066B8;
  if (!qword_1004066B8)
  {
    unint64_t result = swift_getWitnessTable(&protocol conformance descriptor for TimeBitmap, &type metadata for TimeBitmap);
    atomic_store(result, (unint64_t *)&qword_1004066B8);
  }

  return result;
}

uint64_t sub_100087718()
{
  return sub_100087780( &qword_1004066C0,  &qword_100406698,  (void (*)(void))sub_1000875E0,  (uint64_t)&protocol conformance descriptor for <> DefaultIndices<A>);
}

uint64_t sub_10008774C()
{
  return sub_100087780( &qword_1004066C8,  &qword_1004066B0,  (void (*)(void))sub_1000875E0,  (uint64_t)&protocol conformance descriptor for <> Slice<A>);
}

uint64_t sub_100087780(unint64_t *a1, uint64_t *a2, void (*a3)(void), uint64_t a4)
{
  uint64_t result = *a1;
  if (!result)
  {
    uint64_t v8 = sub_1000022F8(a2);
    a3();
    uint64_t result = swift_getWitnessTable(a4, v8);
    atomic_store(result, a1);
  }

  return result;
}

unint64_t sub_1000877E8()
{
  unint64_t result = qword_1004066D0;
  if (!qword_1004066D0)
  {
    unint64_t result = swift_getWitnessTable(&protocol conformance descriptor for TimeBitmap, &type metadata for TimeBitmap);
    atomic_store(result, (unint64_t *)&qword_1004066D0);
  }

  return result;
}

uint64_t sub_10008782C()
{
  return sub_1000572E4( &qword_1004066D8,  &qword_100406698,  (uint64_t)&protocol conformance descriptor for DefaultIndices<A>);
}

uint64_t sub_100087858()
{
  return sub_1000572E4(&qword_1004066E0, &qword_1004066B0, (uint64_t)&protocol conformance descriptor for Slice<A>);
}

uint64_t sub_100087884()
{
  return sub_1000572E4( &qword_1004066E8,  &qword_1004066F0,  (uint64_t)&protocol conformance descriptor for IndexingIterator<A>);
}

uint64_t sub_1000878B0()
{
  return sub_1000572E4(&qword_1004066F8, &qword_100406700, (uint64_t)&protocol conformance descriptor for [A]);
}

unint64_t sub_1000878E0()
{
  unint64_t result = qword_100406708;
  if (!qword_100406708)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for NANAvailabilityEntry.UsagePreference,  &type metadata for NANAvailabilityEntry.UsagePreference);
    atomic_store(result, (unint64_t *)&qword_100406708);
  }

  return result;
}

unint64_t sub_100087928()
{
  unint64_t result = qword_100406710;
  if (!qword_100406710)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for NANAvailabilityEntry.Control,  &type metadata for NANAvailabilityEntry.Control);
    atomic_store(result, (unint64_t *)&qword_100406710);
  }

  return result;
}

unint64_t sub_100087970()
{
  unint64_t result = qword_100406718;
  if (!qword_100406718)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for NANAvailabilityEntry.Control,  &type metadata for NANAvailabilityEntry.Control);
    atomic_store(result, (unint64_t *)&qword_100406718);
  }

  return result;
}

unint64_t sub_1000879B8()
{
  unint64_t result = qword_100406720;
  if (!qword_100406720)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for NANAvailabilityEntry.Control,  &type metadata for NANAvailabilityEntry.Control);
    atomic_store(result, (unint64_t *)&qword_100406720);
  }

  return result;
}

unint64_t sub_100087A00()
{
  unint64_t result = qword_100406728;
  if (!qword_100406728)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for NANAvailabilityEntry.Control,  &type metadata for NANAvailabilityEntry.Control);
    atomic_store(result, (unint64_t *)&qword_100406728);
  }

  return result;
}

unint64_t sub_100087A48()
{
  unint64_t result = qword_100406730;
  if (!qword_100406730)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for NANAvailabilityEntry.BandChannelEntries.Control.EntriesType,  &type metadata for NANAvailabilityEntry.BandChannelEntries.Control.EntriesType);
    atomic_store(result, (unint64_t *)&qword_100406730);
  }

  return result;
}

unint64_t sub_100087A90()
{
  unint64_t result = qword_100406738;
  if (!qword_100406738)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for NANAvailabilityEntry.BandChannelEntries.Control,  &type metadata for NANAvailabilityEntry.BandChannelEntries.Control);
    atomic_store(result, (unint64_t *)&qword_100406738);
  }

  return result;
}

unint64_t sub_100087AD8()
{
  unint64_t result = qword_100406740;
  if (!qword_100406740)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for NANAvailabilityEntry.BandChannelEntries.Control,  &type metadata for NANAvailabilityEntry.BandChannelEntries.Control);
    atomic_store(result, (unint64_t *)&qword_100406740);
  }

  return result;
}

unint64_t sub_100087B20()
{
  unint64_t result = qword_100406748;
  if (!qword_100406748)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for NANAvailabilityEntry.BandChannelEntries.Control,  &type metadata for NANAvailabilityEntry.BandChannelEntries.Control);
    atomic_store(result, (unint64_t *)&qword_100406748);
  }

  return result;
}

unint64_t sub_100087B68()
{
  unint64_t result = qword_100406750;
  if (!qword_100406750)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for NANAvailabilityEntry.BandChannelEntries.Control,  &type metadata for NANAvailabilityEntry.BandChannelEntries.Control);
    atomic_store(result, (unint64_t *)&qword_100406750);
  }

  return result;
}

unint64_t sub_100087BB0()
{
  unint64_t result = qword_100406758;
  if (!qword_100406758)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for NANAvailabilityEntry.BandChannelEntries,  &type metadata for NANAvailabilityEntry.BandChannelEntries);
    atomic_store(result, (unint64_t *)&qword_100406758);
  }

  return result;
}

unint64_t sub_100087BF8()
{
  unint64_t result = qword_100406760;
  if (!qword_100406760)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for NANAvailabilityEntry,  &type metadata for NANAvailabilityEntry);
    atomic_store(result, (unint64_t *)&qword_100406760);
  }

  return result;
}

unint64_t sub_100087C40()
{
  unint64_t result = qword_100406768;
  if (!qword_100406768)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for NANScheduleEntry,  &type metadata for NANScheduleEntry);
    atomic_store(result, (unint64_t *)&qword_100406768);
  }

  return result;
}

unint64_t sub_100087C88()
{
  unint64_t result = qword_100406770;
  if (!qword_100406770)
  {
    unint64_t result = swift_getWitnessTable(&protocol conformance descriptor for NANMapIDs, &type metadata for NANMapIDs);
    atomic_store(result, (unint64_t *)&qword_100406770);
  }

  return result;
}

unint64_t sub_100087CD0()
{
  unint64_t result = qword_100406778;
  if (!qword_100406778)
  {
    unint64_t result = swift_getWitnessTable(&protocol conformance descriptor for NANMapID, &type metadata for NANMapID);
    atomic_store(result, (unint64_t *)&qword_100406778);
  }

  return result;
}

unint64_t sub_100087D18()
{
  unint64_t result = qword_100406780;
  if (!qword_100406780)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for NonNANOperatingChannelInformation,  &type metadata for NonNANOperatingChannelInformation);
    atomic_store(result, (unint64_t *)&qword_100406780);
  }

  return result;
}

unint64_t sub_100087D60()
{
  unint64_t result = qword_100406788;
  if (!qword_100406788)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for NonNANBeaconInformation,  &type metadata for NonNANBeaconInformation);
    atomic_store(result, (unint64_t *)&qword_100406788);
  }

  return result;
}

unint64_t sub_100087DA8()
{
  unint64_t result = qword_100406790;
  if (!qword_100406790)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for DeprecatedNANAvailability,  &type metadata for DeprecatedNANAvailability);
    atomic_store(result, (unint64_t *)&qword_100406790);
  }

  return result;
}

unint64_t sub_100087DF0()
{
  unint64_t result = qword_100406798;
  if (!qword_100406798)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for DeprecatedNANAvailabilityEntry,  &type metadata for DeprecatedNANAvailabilityEntry);
    atomic_store(result, (unint64_t *)&qword_100406798);
  }

  return result;
}

ValueMetadata *type metadata accessor for NANBitmap()
{
  return &type metadata for NANBitmap;
}

ValueMetadata *type metadata accessor for NANBitmap.Band()
{
  return &type metadata for NANBitmap.Band;
}

ValueMetadata *type metadata accessor for NANBitmap.Band.Iterator()
{
  return &type metadata for NANBitmap.Band.Iterator;
}

uint64_t initializeBufferWithCopyOfBuffer for NANBitmap.Channel(uint64_t result, uint64_t *a2)
{
  uint64_t v2 = *a2;
  *(_BYTE *)(result + 8) = *((_BYTE *)a2 + 8);
  *(void *)unint64_t result = v2;
  return result;
}

uint64_t getEnumTagSinglePayload for NANBitmap.Channel(uint64_t a1, int a2)
{
  if (a2 && *(_BYTE *)(a1 + 9)) {
    return (*(_DWORD *)a1 + 1);
  }
  else {
    return 0LL;
  }
}

uint64_t storeEnumTagSinglePayload for NANBitmap.Channel(uint64_t result, int a2, int a3)
{
  if (a2)
  {
    *(_BYTE *)(result + 8) = 0;
    *(void *)unint64_t result = (a2 - 1);
    if (!a3) {
      return result;
    }
    char v3 = 1;
  }

  else
  {
    if (!a3) {
      return result;
    }
    char v3 = 0;
  }

  *(_BYTE *)(result + 9) = v3;
  return result;
}

ValueMetadata *type metadata accessor for NANBitmap.Channel()
{
  return &type metadata for NANBitmap.Channel;
}

uint64_t sub_100087ED8(uint64_t a1, uint64_t a2)
{
  *(_WORD *)a1 = *(_WORD *)a2;
  uint64_t v3 = *(void *)(a2 + 8);
  unint64_t v4 = *(void *)(a2 + 16);
  sub_100020AFC(v3, v4);
  *(void *)(a1 + 8) = v3;
  *(void *)(a1 + 16) = v4;
  return a1;
}

uint64_t assignWithCopy for NANBitmap.Time(uint64_t a1, uint64_t a2)
{
  *(_WORD *)a1 = *(_WORD *)a2;
  uint64_t v3 = *(void *)(a2 + 8);
  unint64_t v4 = *(void *)(a2 + 16);
  sub_100020AFC(v3, v4);
  uint64_t v5 = *(void *)(a1 + 8);
  unint64_t v6 = *(void *)(a1 + 16);
  *(void *)(a1 + 8) = v3;
  *(void *)(a1 + 16) = v4;
  sub_1000208D8(v5, v6);
  return a1;
}

uint64_t assignWithTake for NANBitmap.Time(uint64_t a1, uint64_t a2)
{
  *(_WORD *)a1 = *(_WORD *)a2;
  uint64_t v3 = *(void *)(a1 + 8);
  unint64_t v4 = *(void *)(a1 + 16);
  *(_OWORD *)(a1 + 8) = *(_OWORD *)(a2 + 8);
  sub_1000208D8(v3, v4);
  return a1;
}

uint64_t getEnumTagSinglePayload for NANBitmap.Time(uint64_t a1, unsigned int a2)
{
  if (!a2) {
    return 0LL;
  }
  if (a2 >= 0xD && *(_BYTE *)(a1 + 24)) {
    return (*(_DWORD *)a1 + 13);
  }
  unsigned int v3 = (((*(void *)(a1 + 16) >> 60) >> 2) & 0xFFFFFFF3 | (4 * ((*(void *)(a1 + 16) >> 60) & 3))) ^ 0xF;
  if (v3 >= 0xC) {
    unsigned int v3 = -1;
  }
  return v3 + 1;
}

uint64_t storeEnumTagSinglePayload for NANBitmap.Time(uint64_t result, unsigned int a2, unsigned int a3)
{
  if (a2 > 0xC)
  {
    *(void *)(result + 8) = 0LL;
    *(void *)(result + 16) = 0LL;
    *(void *)unint64_t result = a2 - 13;
    if (a3 >= 0xD) {
      *(_BYTE *)(result + 24) = 1;
    }
  }

  else
  {
    if (a3 >= 0xD) {
      *(_BYTE *)(result + 24) = 0;
    }
    if (a2)
    {
      *(void *)(result + 8) = 0LL;
      *(void *)(result + 16) = (unint64_t)(((-a2 >> 2) & 3) - 4 * a2) << 60;
    }
  }

  return result;
}

ValueMetadata *type metadata accessor for NANBitmap.Time()
{
  return &type metadata for NANBitmap.Time;
}

ValueMetadata *type metadata accessor for NANBitmap.Time.Control()
{
  return &type metadata for NANBitmap.Time.Control;
}

ValueMetadata *type metadata accessor for TimeBitmap()
{
  return &type metadata for TimeBitmap;
}

ValueMetadata *type metadata accessor for TimeBitmap.Slot()
{
  return &type metadata for TimeBitmap.Slot;
}

ValueMetadata *type metadata accessor for TimeBitmap.SlotsView()
{
  return &type metadata for TimeBitmap.SlotsView;
}

uint64_t destroy for NANAvailabilityEntry(uint64_t *a1)
{
  unint64_t v2 = a1[3];
  if (v2 >> 60 != 15) {
    sub_1000208D8(a1[2], v2);
  }
  return swift_bridgeObjectRelease(a1[5]);
}

uint64_t initializeWithCopy for NANAvailabilityEntry(uint64_t a1, uint64_t a2)
{
  *(_WORD *)a1 = *(_WORD *)a2;
  unint64_t v4 = *(void *)(a2 + 24);
  if (v4 >> 60 == 15)
  {
    *(_OWORD *)(a1 + 8) = *(_OWORD *)(a2 + 8);
    *(void *)(a1 + 24) = *(void *)(a2 + 24);
  }

  else
  {
    *(_WORD *)(a1 + 8) = *(_WORD *)(a2 + 8);
    uint64_t v5 = *(void *)(a2 + 16);
    sub_100020AFC(v5, v4);
    *(void *)(a1 + 16) = v5;
    *(void *)(a1 + 24) = v4;
  }

  *(_BYTE *)(a1 + 32) = *(_BYTE *)(a2 + 32);
  uint64_t v6 = *(void *)(a2 + 40);
  char v7 = *(_BYTE *)(a2 + 48);
  *(void *)(a1 + 40) = v6;
  *(_BYTE *)(a1 + 48) = v7;
  swift_bridgeObjectRetain(v6);
  return a1;
}

uint64_t assignWithCopy for NANAvailabilityEntry(uint64_t a1, uint64_t a2)
{
  *(_WORD *)a1 = *(_WORD *)a2;
  uint64_t v4 = a1 + 8;
  uint64_t v5 = (__int128 *)(a2 + 8);
  if (*(void *)(a1 + 24) >> 60 == 15LL)
  {
    if (*(void *)(a2 + 24) >> 60 == 15LL)
    {
      __int128 v6 = *v5;
      *(void *)(a1 + 24) = *(void *)(a2 + 24);
      *(_OWORD *)uint64_t v4 = v6;
    }

    else
    {
      *(_WORD *)(a1 + 8) = *(_WORD *)(a2 + 8);
      uint64_t v8 = *(void *)(a2 + 16);
      unint64_t v9 = *(void *)(a2 + 24);
      sub_100020AFC(v8, v9);
      *(void *)(a1 + 16) = v8;
      *(void *)(a1 + 24) = v9;
    }
  }

  else if (*(void *)(a2 + 24) >> 60 == 15LL)
  {
    sub_10008826C(a1 + 8);
    uint64_t v7 = *((void *)v5 + 2);
    *(_OWORD *)uint64_t v4 = *v5;
    *(void *)(v4 + 16) = v7;
  }

  else
  {
    *(_WORD *)(a1 + 8) = *(_WORD *)(a2 + 8);
    uint64_t v10 = *(void *)(a2 + 16);
    unint64_t v11 = *(void *)(a2 + 24);
    sub_100020AFC(v10, v11);
    uint64_t v12 = *(void *)(a1 + 16);
    unint64_t v13 = *(void *)(a1 + 24);
    *(void *)(a1 + 16) = v10;
    *(void *)(a1 + 24) = v11;
    sub_1000208D8(v12, v13);
  }

  *(_BYTE *)(a1 + 32) = *(_BYTE *)(a2 + 32);
  uint64_t v14 = *(void *)(a2 + 40);
  char v15 = *(_BYTE *)(a2 + 48);
  uint64_t v16 = *(void *)(a1 + 40);
  *(void *)(a1 + 40) = v14;
  *(_BYTE *)(a1 + 48) = v15;
  swift_bridgeObjectRetain(v14);
  swift_bridgeObjectRelease(v16);
  return a1;
}

uint64_t sub_10008826C(uint64_t a1)
{
  return a1;
}

__n128 initializeWithTake for NANAvailabilityEntry(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)a2;
  __int128 v3 = *(_OWORD *)(a2 + 16);
  __int128 v4 = *(_OWORD *)(a2 + 32);
  *(_BYTE *)(a1 + 48) = *(_BYTE *)(a2 + 48);
  *(_OWORD *)(a1 + 16) = v3;
  *(_OWORD *)(a1 + 32) = v4;
  *(__n128 *)a1 = result;
  return result;
}

uint64_t assignWithTake for NANAvailabilityEntry(uint64_t a1, uint64_t a2)
{
  *(_WORD *)a1 = *(_WORD *)a2;
  uint64_t v4 = a1 + 8;
  uint64_t v5 = a2 + 8;
  unint64_t v6 = *(void *)(a1 + 24);
  if (v6 >> 60 != 15)
  {
    unint64_t v7 = *(void *)(a2 + 24);
    if (v7 >> 60 != 15)
    {
      *(_WORD *)(a1 + 8) = *(_WORD *)(a2 + 8);
      uint64_t v8 = *(void *)(a1 + 16);
      *(void *)(a1 + 16) = *(void *)(a2 + 16);
      *(void *)(a1 + 24) = v7;
      sub_1000208D8(v8, v6);
      goto LABEL_6;
    }

    sub_10008826C(a1 + 8);
  }

  *(_OWORD *)uint64_t v4 = *(_OWORD *)v5;
  *(void *)(v4 + 16) = *(void *)(v5 + 16);
LABEL_6:
  *(_BYTE *)(a1 + 32) = *(_BYTE *)(a2 + 32);
  char v9 = *(_BYTE *)(a2 + 48);
  uint64_t v10 = *(void *)(a1 + 40);
  *(void *)(a1 + 40) = *(void *)(a2 + 40);
  *(_BYTE *)(a1 + 48) = v9;
  swift_bridgeObjectRelease(v10);
  return a1;
}

uint64_t getEnumTagSinglePayload for NANAvailabilityEntry(uint64_t a1, unsigned int a2)
{
  if (!a2) {
    return 0LL;
  }
  if (a2 >= 0xFF && *(_BYTE *)(a1 + 49)) {
    return (*(_DWORD *)a1 + 255);
  }
  unsigned int v3 = *(unsigned __int8 *)(a1 + 48);
  if (v3 <= 1) {
    int v4 = -1;
  }
  else {
    int v4 = v3 ^ 0xFF;
  }
  return (v4 + 1);
}

uint64_t storeEnumTagSinglePayload for NANAvailabilityEntry(uint64_t result, unsigned int a2, unsigned int a3)
{
  if (a2 > 0xFE)
  {
    *(void *)(result + 40) = 0LL;
    *(_OWORD *)(result + 24) = 0u;
    *(_OWORD *)(result + 8) = 0u;
    *(_BYTE *)(result + 48) = 0;
    *(void *)__n128 result = a2 - 255;
    if (a3 >= 0xFF) {
      *(_BYTE *)(result + 49) = 1;
    }
  }

  else
  {
    if (a3 >= 0xFF) {
      *(_BYTE *)(result + 49) = 0;
    }
    if (a2) {
      *(_BYTE *)(result + 48) = -(char)a2;
    }
  }

  return result;
}

ValueMetadata *type metadata accessor for NANAvailabilityEntry()
{
  return &type metadata for NANAvailabilityEntry;
}

ValueMetadata *type metadata accessor for NANAvailabilityEntry.UsagePreference()
{
  return &type metadata for NANAvailabilityEntry.UsagePreference;
}

ValueMetadata *type metadata accessor for NANAvailabilityEntry.Control()
{
  return &type metadata for NANAvailabilityEntry.Control;
}

uint64_t sub_10008843C(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)a1 = *(_BYTE *)a2;
  uint64_t v3 = *(void *)(a2 + 8);
  char v4 = *(_BYTE *)(a2 + 16);
  *(void *)(a1 + 8) = v3;
  *(_BYTE *)(a1 + 16) = v4;
  swift_bridgeObjectRetain(v3);
  return a1;
}

uint64_t assignWithCopy for NANAvailabilityEntry.BandChannelEntries(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)a1 = *(_BYTE *)a2;
  uint64_t v3 = *(void *)(a2 + 8);
  char v4 = *(_BYTE *)(a2 + 16);
  uint64_t v5 = *(void *)(a1 + 8);
  *(void *)(a1 + 8) = v3;
  *(_BYTE *)(a1 + 16) = v4;
  swift_bridgeObjectRetain(v3);
  swift_bridgeObjectRelease(v5);
  return a1;
}

uint64_t assignWithTake for NANAvailabilityEntry.BandChannelEntries(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)a1 = *(_BYTE *)a2;
  char v3 = *(_BYTE *)(a2 + 16);
  uint64_t v4 = *(void *)(a1 + 8);
  *(void *)(a1 + 8) = *(void *)(a2 + 8);
  *(_BYTE *)(a1 + 16) = v3;
  swift_bridgeObjectRelease(v4);
  return a1;
}

uint64_t getEnumTagSinglePayload for NANAvailabilityEntry.BandChannelEntries(uint64_t a1, unsigned int a2)
{
  if (!a2) {
    return 0LL;
  }
  if (a2 >= 0xFF && *(_BYTE *)(a1 + 17)) {
    return (*(_DWORD *)a1 + 255);
  }
  unsigned int v3 = *(unsigned __int8 *)(a1 + 16);
  if (v3 <= 1) {
    int v4 = -1;
  }
  else {
    int v4 = v3 ^ 0xFF;
  }
  return (v4 + 1);
}

uint64_t storeEnumTagSinglePayload for NANAvailabilityEntry.BandChannelEntries( uint64_t result, unsigned int a2, unsigned int a3)
{
  if (a2 > 0xFE)
  {
    *(_BYTE *)(result + 16) = 0;
    *(void *)__n128 result = a2 - 255;
    *(void *)(result + 8) = 0LL;
    if (a3 >= 0xFF) {
      *(_BYTE *)(result + 17) = 1;
    }
  }

  else
  {
    if (a3 >= 0xFF) {
      *(_BYTE *)(result + 17) = 0;
    }
    if (a2) {
      *(_BYTE *)(result + 16) = -(char)a2;
    }
  }

  return result;
}

ValueMetadata *type metadata accessor for NANAvailabilityEntry.BandChannelEntries()
{
  return &type metadata for NANAvailabilityEntry.BandChannelEntries;
}

ValueMetadata *type metadata accessor for NANAvailabilityEntry.BandChannelEntries.Control()
{
  return &type metadata for NANAvailabilityEntry.BandChannelEntries.Control;
}

ValueMetadata *type metadata accessor for NANAvailabilityEntry.BandChannelEntries.Control.EntriesType()
{
  return &type metadata for NANAvailabilityEntry.BandChannelEntries.Control.EntriesType;
}

uint64_t destroy for NANAttribute.P2POperation(uint64_t a1)
{
  return sub_1000208D8(*(void *)(a1 + 16), *(void *)(a1 + 24));
}

uint64_t initializeWithCopy for NANScheduleEntry(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)a1 = *(_BYTE *)a2;
  *(_WORD *)(a1 + 8) = *(_WORD *)(a2 + 8);
  uint64_t v3 = *(void *)(a2 + 16);
  unint64_t v4 = *(void *)(a2 + 24);
  sub_100020AFC(v3, v4);
  *(void *)(a1 + 16) = v3;
  *(void *)(a1 + 24) = v4;
  return a1;
}

uint64_t assignWithCopy for NANScheduleEntry(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)a1 = *(_BYTE *)a2;
  *(_WORD *)(a1 + 8) = *(_WORD *)(a2 + 8);
  uint64_t v3 = *(void *)(a2 + 16);
  unint64_t v4 = *(void *)(a2 + 24);
  sub_100020AFC(v3, v4);
  uint64_t v5 = *(void *)(a1 + 16);
  unint64_t v6 = *(void *)(a1 + 24);
  *(void *)(a1 + 16) = v3;
  *(void *)(a1 + 24) = v4;
  sub_1000208D8(v5, v6);
  return a1;
}

uint64_t assignWithTake for NANScheduleEntry(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)a1 = *(_BYTE *)a2;
  *(_WORD *)(a1 + 8) = *(_WORD *)(a2 + 8);
  uint64_t v3 = *(void *)(a1 + 16);
  unint64_t v4 = *(void *)(a1 + 24);
  *(_OWORD *)(a1 + 16) = *(_OWORD *)(a2 + 16);
  sub_1000208D8(v3, v4);
  return a1;
}

uint64_t getEnumTagSinglePayload for NANScheduleEntry(uint64_t a1, unsigned int a2)
{
  if (!a2) {
    return 0LL;
  }
  if (a2 >= 0xD && *(_BYTE *)(a1 + 32)) {
    return (*(_DWORD *)a1 + 13);
  }
  unsigned int v3 = (((*(void *)(a1 + 24) >> 60) >> 2) & 0xFFFFFFF3 | (4 * ((*(void *)(a1 + 24) >> 60) & 3))) ^ 0xF;
  if (v3 >= 0xC) {
    unsigned int v3 = -1;
  }
  return v3 + 1;
}

uint64_t storeEnumTagSinglePayload for NANScheduleEntry(uint64_t result, unsigned int a2, unsigned int a3)
{
  if (a2 > 0xC)
  {
    *(void *)(result + 16) = 0LL;
    *(void *)(result + 24) = 0LL;
    *(void *)__n128 result = a2 - 13;
    *(void *)(result + 8) = 0LL;
    if (a3 >= 0xD) {
      *(_BYTE *)(result + 32) = 1;
    }
  }

  else
  {
    if (a3 >= 0xD) {
      *(_BYTE *)(result + 32) = 0;
    }
    if (a2)
    {
      *(void *)(result + 16) = 0LL;
      *(void *)(result + 24) = (unint64_t)(((-a2 >> 2) & 3) - 4 * a2) << 60;
    }
  }

  return result;
}

ValueMetadata *type metadata accessor for NANScheduleEntry()
{
  return &type metadata for NANScheduleEntry;
}

uint64_t getEnumTagSinglePayload for NANMapIDs(uint64_t a1, int a2)
{
  if (!a2) {
    return 0LL;
  }
  unsigned int v2 = a2 + 0xFFFF;
  else {
    unsigned int v3 = 4;
  }
  if (v2 < 0xFF0000) {
    unsigned int v3 = 1;
  }
  if (v2 >= 0x10000) {
    uint64_t v4 = v3;
  }
  else {
    uint64_t v4 = 0LL;
  }
  return ((uint64_t (*)(void))((char *)&loc_1000887B4 + 4 * byte_10033C4AF[v4]))();
}

uint64_t sub_1000887CC(unsigned __int16 *a1)
{
  uint64_t v1 = a1[1];
  if (a1[1]) {
    return (*a1 | ((_DWORD)v1 << 16)) - 0xFFFF;
  }
  return v1;
}

void sub_1000887D8(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 2)) {
    JUMPOUT(0x1000887E0LL);
  }
  JUMPOUT(0x1000887F0LL);
}

uint64_t storeEnumTagSinglePayload for NANMapIDs(_WORD *a1, int a2, int a3)
{
  unsigned int v3 = a3 + 0xFFFF;
  else {
    int v4 = 4;
  }
  if (v3 < 0xFF0000) {
    int v4 = 1;
  }
  if (v3 >= 0x10000) {
    LODWORD(v5) = v4;
  }
  else {
    LODWORD(v5) = 0;
  }
  if (a3) {
    uint64_t v5 = v5;
  }
  else {
    uint64_t v5 = 0LL;
  }
  if (!a2) {
    return ((uint64_t (*)(void))((char *)sub_10008887C + 4 * byte_10033C4B9[v5]))();
  }
  *a1 = a2 - 1;
  return ((uint64_t (*)(void))((char *)sub_10008885C + 4 * byte_10033C4B4[v5]))();
}

uint64_t sub_10008885C(uint64_t result)
{
  *(_BYTE *)(result + 2) = v1;
  return result;
}

uint64_t sub_10008887C(uint64_t result)
{
  *(_BYTE *)(result + 2) = 0;
  return result;
}

uint64_t sub_100088884(uint64_t result)
{
  *(_DWORD *)(result + 2) = v1;
  return result;
}

uint64_t sub_10008888C(uint64_t result)
{
  *(_WORD *)(result + 2) = v1;
  return result;
}

uint64_t sub_100088894(uint64_t result)
{
  *(_WORD *)(result + 2) = 0;
  return result;
}

uint64_t sub_10008889C(uint64_t result)
{
  *(_DWORD *)(result + 2) = 0;
  return result;
}

ValueMetadata *type metadata accessor for NANMapIDs()
{
  return &type metadata for NANMapIDs;
}

ValueMetadata *type metadata accessor for NANMapID()
{
  return &type metadata for NANMapID;
}

ValueMetadata *type metadata accessor for NonNANOperatingChannelInformation()
{
  return &type metadata for NonNANOperatingChannelInformation;
}

ValueMetadata *type metadata accessor for NonNANBeaconInformation()
{
  return &type metadata for NonNANBeaconInformation;
}

uint64_t destroy for NANServiceInfo(uint64_t a1)
{
  return sub_1000208D8(*(void *)(a1 + 8), *(void *)(a1 + 16));
}

uint64_t assignWithCopy for DeprecatedNANAvailability(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)a1 = *(_BYTE *)a2;
  *(_BYTE *)(a1 + 1) = *(_BYTE *)(a2 + 1);
  *(_BYTE *)(a1 + 2) = *(_BYTE *)(a2 + 2);
  uint64_t v3 = *(void *)(a2 + 8);
  unint64_t v4 = *(void *)(a2 + 16);
  sub_100020AFC(v3, v4);
  uint64_t v5 = *(void *)(a1 + 8);
  unint64_t v6 = *(void *)(a1 + 16);
  *(void *)(a1 + 8) = v3;
  *(void *)(a1 + 16) = v4;
  sub_1000208D8(v5, v6);
  return a1;
}

uint64_t assignWithTake for DeprecatedNANAvailability(uint64_t a1, uint64_t a2)
{
  *(_WORD *)a1 = *(_WORD *)a2;
  *(_BYTE *)(a1 + 2) = *(_BYTE *)(a2 + 2);
  uint64_t v3 = *(void *)(a1 + 8);
  unint64_t v4 = *(void *)(a1 + 16);
  *(_OWORD *)(a1 + 8) = *(_OWORD *)(a2 + 8);
  sub_1000208D8(v3, v4);
  return a1;
}

uint64_t getEnumTagSinglePayload for DeprecatedNANAvailability(uint64_t a1, unsigned int a2)
{
  if (!a2) {
    return 0LL;
  }
  if (a2 >= 0xFF && *(_BYTE *)(a1 + 24)) {
    return (*(_DWORD *)a1 + 255);
  }
  unsigned int v3 = *(unsigned __int8 *)(a1 + 2);
  BOOL v4 = v3 >= 2;
  int v5 = (v3 + 2147483646) & 0x7FFFFFFF;
  if (!v4) {
    int v5 = -1;
  }
  return (v5 + 1);
}

uint64_t storeEnumTagSinglePayload for DeprecatedNANAvailability( uint64_t result, unsigned int a2, unsigned int a3)
{
  if (a2 > 0xFE)
  {
    *(void *)(result + 8) = 0LL;
    *(void *)(result + 16) = 0LL;
    *(void *)__n128 result = a2 - 255;
    if (a3 >= 0xFF) {
      *(_BYTE *)(result + 24) = 1;
    }
  }

  else
  {
    if (a3 >= 0xFF) {
      *(_BYTE *)(result + 24) = 0;
    }
    if (a2) {
      *(_BYTE *)(result + 2) = a2 + 1;
    }
  }

  return result;
}

ValueMetadata *type metadata accessor for DeprecatedNANAvailability()
{
  return &type metadata for DeprecatedNANAvailability;
}

uint64_t _s7CoreP2P25DeprecatedNANAvailabilityVwCP_0(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)a1 = *(_BYTE *)a2;
  *(_WORD *)(a1 + 1) = *(_WORD *)(a2 + 1);
  uint64_t v3 = *(void *)(a2 + 8);
  unint64_t v4 = *(void *)(a2 + 16);
  sub_100020AFC(v3, v4);
  *(void *)(a1 + 8) = v3;
  *(void *)(a1 + 16) = v4;
  return a1;
}

uint64_t assignWithTake for DeprecatedNANAvailabilityEntry(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)a1 = *(_BYTE *)a2;
  *(_WORD *)(a1 + 1) = *(_WORD *)(a2 + 1);
  uint64_t v3 = *(void *)(a1 + 8);
  unint64_t v4 = *(void *)(a1 + 16);
  *(_OWORD *)(a1 + 8) = *(_OWORD *)(a2 + 8);
  sub_1000208D8(v3, v4);
  return a1;
}

uint64_t getEnumTagSinglePayload for NANServiceInfo(unsigned __int8 *a1, unsigned int a2)
{
  if (!a2) {
    return 0LL;
  }
  if (a2 >= 0xFD && a1[24]) {
    return (*(_DWORD *)a1 + 253);
  }
  unsigned int v3 = *a1;
  BOOL v4 = v3 >= 4;
  int v5 = v3 - 4;
  if (!v4) {
    int v5 = -1;
  }
  return (v5 + 1);
}

uint64_t storeEnumTagSinglePayload for NANServiceInfo(uint64_t result, unsigned int a2, unsigned int a3)
{
  if (a2 > 0xFC)
  {
    *(void *)(result + 8) = 0LL;
    *(void *)(result + 16) = 0LL;
    *(void *)__n128 result = a2 - 253;
    if (a3 >= 0xFD) {
      *(_BYTE *)(result + 24) = 1;
    }
  }

  else
  {
    if (a3 >= 0xFD) {
      *(_BYTE *)(result + 24) = 0;
    }
    if (a2) {
      *(_BYTE *)__n128 result = a2 + 3;
    }
  }

  return result;
}

ValueMetadata *type metadata accessor for DeprecatedNANAvailabilityEntry()
{
  return &type metadata for DeprecatedNANAvailabilityEntry;
}

ValueMetadata *type metadata accessor for DeprecatedNANAvailabilityEntry.CodingKeys()
{
  return &type metadata for DeprecatedNANAvailabilityEntry.CodingKeys;
}

ValueMetadata *type metadata accessor for DeprecatedNANAvailability.AvailabilityControl()
{
  return &type metadata for DeprecatedNANAvailability.AvailabilityControl;
}

ValueMetadata *type metadata accessor for NonNANBeaconInformation.CodingKeys()
{
  return &type metadata for NonNANBeaconInformation.CodingKeys;
}

uint64_t storeEnumTagSinglePayload for NonNANOperatingChannelInformation.CodingKeys( _BYTE *a1, unsigned int a2, unsigned int a3)
{
  if (a3 + 2 >= 0xFFFF00) {
    int v3 = 4;
  }
  else {
    int v3 = 2;
  }
  if ((a3 + 2) >> 8 < 0xFF) {
    LODWORD(v4) = 1;
  }
  else {
    LODWORD(v4) = v3;
  }
  if (a3 >= 0xFE) {
    uint64_t v4 = v4;
  }
  else {
    uint64_t v4 = 0LL;
  }
  if (a2 <= 0xFD) {
    return ((uint64_t (*)(void))((char *)&loc_100088BEC + 4 * byte_10033C4C3[v4]))();
  }
  *a1 = a2 + 2;
  return ((uint64_t (*)(void))((char *)sub_100088C20 + 4 * byte_10033C4BE[v4]))();
}

uint64_t sub_100088C20(uint64_t result)
{
  *(_BYTE *)(result + 1) = v1;
  return result;
}

uint64_t sub_100088C28(uint64_t result, int a2)
{
  *(_WORD *)(result + 1) = 0;
  if (a2) {
    JUMPOUT(0x100088C30LL);
  }
  return result;
}

uint64_t sub_100088C3C(uint64_t result, int a2)
{
  *(_DWORD *)(result + 1) = 0;
  if (!a2) {
    JUMPOUT(0x100088C44LL);
  }
  *(_BYTE *)__n128 result = a2 + 2;
  return result;
}

uint64_t sub_100088C48(uint64_t result)
{
  *(_DWORD *)(result + 1) = v1;
  return result;
}

uint64_t sub_100088C50(uint64_t result)
{
  *(_WORD *)(result + 1) = v1;
  return result;
}

ValueMetadata *type metadata accessor for NonNANOperatingChannelInformation.CodingKeys()
{
  return &type metadata for NonNANOperatingChannelInformation.CodingKeys;
}

uint64_t _s7CoreP2P20NANAvailabilityEntryV18BandChannelEntriesV7ControlV11EntriesTypeOwst_0( _BYTE *a1, unsigned int a2, unsigned int a3)
{
  if (a3 + 1 >= 0xFFFF00) {
    int v3 = 4;
  }
  else {
    int v3 = 2;
  }
  if ((a3 + 1) >> 8 < 0xFF) {
    LODWORD(v4) = 1;
  }
  else {
    LODWORD(v4) = v3;
  }
  if (a3 >= 0xFF) {
    uint64_t v4 = v4;
  }
  else {
    uint64_t v4 = 0LL;
  }
  if (a2 <= 0xFE) {
    return ((uint64_t (*)(void))((char *)&loc_100088CB8 + 4 * byte_10033C4CD[v4]))();
  }
  *a1 = a2 + 1;
  return ((uint64_t (*)(void))((char *)sub_100088CEC + 4 * byte_10033C4C8[v4]))();
}

uint64_t sub_100088CEC(uint64_t result)
{
  *(_BYTE *)(result + 1) = v1;
  return result;
}

uint64_t sub_100088CF4(uint64_t result, int a2)
{
  *(_WORD *)(result + 1) = 0;
  if (a2) {
    JUMPOUT(0x100088CFCLL);
  }
  return result;
}

uint64_t sub_100088D08(uint64_t result, int a2)
{
  *(_DWORD *)(result + 1) = 0;
  if (!a2) {
    JUMPOUT(0x100088D10LL);
  }
  *(_BYTE *)__n128 result = a2 + 1;
  return result;
}

uint64_t sub_100088D14(uint64_t result)
{
  *(_DWORD *)(result + 1) = v1;
  return result;
}

uint64_t sub_100088D1C(uint64_t result)
{
  *(_WORD *)(result + 1) = v1;
  return result;
}

ValueMetadata *type metadata accessor for NANScheduleEntry.CodingKeys()
{
  return &type metadata for NANScheduleEntry.CodingKeys;
}

uint64_t getEnumTagSinglePayload for NANBloomFilter.Index(unsigned __int8 *a1, unsigned int a2)
{
  if (!a2) {
    return 0LL;
  }
  if (a2 < 0xFD) {
    goto LABEL_17;
  }
  if (a2 + 3 >= 0xFFFF00) {
    int v2 = 4;
  }
  else {
    int v2 = 2;
  }
  if ((a2 + 3) >> 8 < 0xFF) {
    int v3 = 1;
  }
  else {
    int v3 = v2;
  }
  if (v3 == 4)
  {
    int v4 = *(_DWORD *)(a1 + 1);
    if (v4) {
      return (*a1 | (v4 << 8)) - 3;
    }
  }

  else
  {
    if (v3 == 2)
    {
      int v4 = *(unsigned __int16 *)(a1 + 1);
      if (!*(_WORD *)(a1 + 1)) {
        goto LABEL_17;
      }
      return (*a1 | (v4 << 8)) - 3;
    }

    int v4 = a1[1];
    if (a1[1]) {
      return (*a1 | (v4 << 8)) - 3;
    }
  }

uint64_t _s7CoreP2P20NANAvailabilityEntryV15UsagePreferenceOwst_0( _BYTE *a1, unsigned int a2, unsigned int a3)
{
  if (a3 + 3 >= 0xFFFF00) {
    int v3 = 4;
  }
  else {
    int v3 = 2;
  }
  if ((a3 + 3) >> 8 < 0xFF) {
    LODWORD(v4) = 1;
  }
  else {
    LODWORD(v4) = v3;
  }
  if (a3 >= 0xFD) {
    uint64_t v4 = v4;
  }
  else {
    uint64_t v4 = 0LL;
  }
  if (a2 <= 0xFC) {
    return ((uint64_t (*)(void))((char *)&loc_100088E14 + 4 * byte_10033C4D7[v4]))();
  }
  *a1 = a2 + 3;
  return ((uint64_t (*)(void))((char *)sub_100088E48 + 4 * byte_10033C4D2[v4]))();
}

uint64_t sub_100088E48(uint64_t result)
{
  *(_BYTE *)(result + 1) = v1;
  return result;
}

uint64_t sub_100088E50(uint64_t result, int a2)
{
  *(_WORD *)(result + 1) = 0;
  if (a2) {
    JUMPOUT(0x100088E58LL);
  }
  return result;
}

uint64_t sub_100088E64(uint64_t result, int a2)
{
  *(_DWORD *)(result + 1) = 0;
  if (!a2) {
    JUMPOUT(0x100088E6CLL);
  }
  *(_BYTE *)__n128 result = a2 + 3;
  return result;
}

uint64_t sub_100088E70(uint64_t result)
{
  *(_DWORD *)(result + 1) = v1;
  return result;
}

uint64_t sub_100088E78(uint64_t result)
{
  *(_WORD *)(result + 1) = v1;
  return result;
}

ValueMetadata *type metadata accessor for NANBitmap.Channel.CodingKeys()
{
  return &type metadata for NANBitmap.Channel.CodingKeys;
}

unint64_t sub_100088E98()
{
  unint64_t result = qword_1004067A0;
  if (!qword_1004067A0)
  {
    unint64_t result = swift_getWitnessTable(&unk_10033E074, &type metadata for NANBitmap.Channel.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_1004067A0);
  }

  return result;
}

unint64_t sub_100088EE0()
{
  unint64_t result = qword_1004067A8;
  if (!qword_1004067A8)
  {
    unint64_t result = swift_getWitnessTable(&unk_10033E12C, &type metadata for NANScheduleEntry.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_1004067A8);
  }

  return result;
}

unint64_t sub_100088F28()
{
  unint64_t result = qword_1004067B0;
  if (!qword_1004067B0)
  {
    unint64_t result = swift_getWitnessTable(&unk_10033E1E4, &type metadata for NonNANOperatingChannelInformation.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_1004067B0);
  }

  return result;
}

unint64_t sub_100088F70()
{
  unint64_t result = qword_1004067B8;
  if (!qword_1004067B8)
  {
    unint64_t result = swift_getWitnessTable(&unk_10033E29C, &type metadata for NonNANBeaconInformation.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_1004067B8);
  }

  return result;
}

unint64_t sub_100088FB8()
{
  unint64_t result = qword_1004067C0;
  if (!qword_1004067C0)
  {
    unint64_t result = swift_getWitnessTable(&unk_10033E2F4, &type metadata for DeprecatedNANAvailability.AvailabilityControl);
    atomic_store(result, (unint64_t *)&qword_1004067C0);
  }

  return result;
}

unint64_t sub_100089000()
{
  unint64_t result = qword_1004067C8;
  if (!qword_1004067C8)
  {
    unint64_t result = swift_getWitnessTable(&unk_10033E2C4, &type metadata for DeprecatedNANAvailability.AvailabilityControl);
    atomic_store(result, (unint64_t *)&qword_1004067C8);
  }

  return result;
}

unint64_t sub_100089048()
{
  unint64_t result = qword_1004067D0;
  if (!qword_1004067D0)
  {
    unint64_t result = swift_getWitnessTable(&unk_10033E31C, &type metadata for DeprecatedNANAvailability.AvailabilityControl);
    atomic_store(result, (unint64_t *)&qword_1004067D0);
  }

  return result;
}

unint64_t sub_100089090()
{
  unint64_t result = qword_1004067D8;
  if (!qword_1004067D8)
  {
    unint64_t result = swift_getWitnessTable(&unk_10033E354, &type metadata for DeprecatedNANAvailability.AvailabilityControl);
    atomic_store(result, (unint64_t *)&qword_1004067D8);
  }

  return result;
}

unint64_t sub_1000890D8()
{
  unint64_t result = qword_1004067E0;
  if (!qword_1004067E0)
  {
    unint64_t result = swift_getWitnessTable(&unk_10033E54C, &type metadata for DeprecatedNANAvailabilityEntry.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_1004067E0);
  }

  return result;
}

unint64_t sub_100089120()
{
  unint64_t result = qword_1004067E8;
  if (!qword_1004067E8)
  {
    unint64_t result = swift_getWitnessTable(&unk_10033E4BC, &type metadata for DeprecatedNANAvailabilityEntry.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_1004067E8);
  }

  return result;
}

unint64_t sub_100089168()
{
  unint64_t result = qword_1004067F0;
  if (!qword_1004067F0)
  {
    unint64_t result = swift_getWitnessTable(&unk_10033E4E4, &type metadata for DeprecatedNANAvailabilityEntry.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_1004067F0);
  }

  return result;
}

unint64_t sub_1000891B0()
{
  unint64_t result = qword_1004067F8;
  if (!qword_1004067F8)
  {
    unint64_t result = swift_getWitnessTable(&unk_10033E20C, &type metadata for NonNANBeaconInformation.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_1004067F8);
  }

  return result;
}

unint64_t sub_1000891F8()
{
  unint64_t result = qword_100406800;
  if (!qword_100406800)
  {
    unint64_t result = swift_getWitnessTable(&unk_10033E234, &type metadata for NonNANBeaconInformation.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_100406800);
  }

  return result;
}

unint64_t sub_100089240()
{
  unint64_t result = qword_100406808;
  if (!qword_100406808)
  {
    unint64_t result = swift_getWitnessTable(&unk_10033E154, &type metadata for NonNANOperatingChannelInformation.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_100406808);
  }

  return result;
}

unint64_t sub_100089288()
{
  unint64_t result = qword_100406810;
  if (!qword_100406810)
  {
    unint64_t result = swift_getWitnessTable(&unk_10033E17C, &type metadata for NonNANOperatingChannelInformation.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_100406810);
  }

  return result;
}

unint64_t sub_1000892D0()
{
  unint64_t result = qword_100406818;
  if (!qword_100406818)
  {
    unint64_t result = swift_getWitnessTable(&unk_10033E09C, &type metadata for NANScheduleEntry.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_100406818);
  }

  return result;
}

unint64_t sub_100089318()
{
  unint64_t result = qword_100406820;
  if (!qword_100406820)
  {
    unint64_t result = swift_getWitnessTable(&unk_10033E0C4, &type metadata for NANScheduleEntry.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_100406820);
  }

  return result;
}

unint64_t sub_100089360()
{
  unint64_t result = qword_100406828;
  if (!qword_100406828)
  {
    unint64_t result = swift_getWitnessTable(&unk_10033DFE4, &type metadata for NANBitmap.Channel.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_100406828);
  }

  return result;
}

unint64_t sub_1000893A8()
{
  unint64_t result = qword_100406830;
  if (!qword_100406830)
  {
    unint64_t result = swift_getWitnessTable(&unk_10033E00C, &type metadata for NANBitmap.Channel.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_100406830);
  }

  return result;
}

uint64_t sub_1000893EC(uint64_t a1, unint64_t a2)
{
  if (a1 == 0x444970616DLL && a2 == 0xE500000000000000LL)
  {
    unint64_t v5 = 0xE500000000000000LL;
    goto LABEL_8;
  }

  if ((_stringCompareWithSmolCheck(_:_:expecting:)(0x444970616DLL, 0xE500000000000000LL, a1, a2, 0LL) & 1) != 0)
  {
    unint64_t v5 = a2;
LABEL_8:
    swift_bridgeObjectRelease(v5);
    return 0LL;
  }

  if (a1 == 0x6D746942656D6974LL && a2 == 0xEA00000000007061LL)
  {
    swift_bridgeObjectRelease(0xEA00000000007061LL);
    return 1LL;
  }

  else
  {
    char v7 = _stringCompareWithSmolCheck(_:_:expecting:)(0x6D746942656D6974LL, 0xEA00000000007061LL, a1, a2, 0LL);
    swift_bridgeObjectRelease(a2);
    if ((v7 & 1) != 0) {
      return 1LL;
    }
    else {
      return 2LL;
    }
  }

uint64_t sub_1000894E0(uint64_t a1, unint64_t a2)
{
  if (a1 == 0xD000000000000014LL)
  {
    unint64_t v4 = 0x8000000100363E60LL;
    if (a2 == 0x8000000100363E60LL) {
      goto LABEL_5;
    }
  }

  if ((_stringCompareWithSmolCheck(_:_:expecting:)(0xD000000000000014LL, 0x8000000100363E60LL, a1, a2, 0LL) & 1) != 0)
  {
    unint64_t v4 = a2;
LABEL_5:
    swift_bridgeObjectRelease(v4);
    return 0LL;
  }

  if (a1 == 0x4E6C656E6E616863LL && a2 == 0xED00007265626D75LL)
  {
    unint64_t v6 = 0xED00007265626D75LL;
LABEL_11:
    swift_bridgeObjectRelease(v6);
    return 1LL;
  }

  if ((_stringCompareWithSmolCheck(_:_:expecting:)(0x4E6C656E6E616863LL, 0xED00007265626D75LL, a1, a2, 0LL) & 1) != 0)
  {
    unint64_t v6 = a2;
    goto LABEL_11;
  }

  if (a1 == 0xD000000000000016LL && a2 == 0x8000000100363E80LL)
  {
    swift_bridgeObjectRelease(0x8000000100363E80LL);
    return 2LL;
  }

  else
  {
    char v7 = _stringCompareWithSmolCheck(_:_:expecting:)(0xD000000000000016LL, 0x8000000100363E80LL, a1, a2, 0LL);
    swift_bridgeObjectRelease(a2);
    if ((v7 & 1) != 0) {
      return 2LL;
    }
    else {
      return 3LL;
    }
  }

uint64_t sub_100089650(uint64_t a1, unint64_t a2)
{
  if (a1 == 0xD000000000000022LL && a2 == 0x8000000100363EA0LL)
  {
    unint64_t v4 = 0x8000000100363EA0LL;
LABEL_6:
    swift_bridgeObjectRelease(v4);
    return 0LL;
  }

  if ((_stringCompareWithSmolCheck(_:_:expecting:)(0xD000000000000022LL, 0x8000000100363EA0LL, a1, a2, 0LL) & 1) != 0)
  {
    unint64_t v4 = a2;
    goto LABEL_6;
  }

  if (a1 == 0xD000000000000011LL && a2 == 0x8000000100363ED0LL)
  {
    swift_bridgeObjectRelease(0x8000000100363ED0LL);
    return 1LL;
  }

  else
  {
    char v6 = _stringCompareWithSmolCheck(_:_:expecting:)(0xD000000000000011LL, 0x8000000100363ED0LL, a1, a2, 0LL);
    swift_bridgeObjectRelease(a2);
    if ((v6 & 1) != 0) {
      return 1LL;
    }
    else {
      return 2LL;
    }
  }

uint64_t sub_10008973C(uint64_t a1, unint64_t a2)
{
  if (a1 == 0x6C6F72746E6F63LL && a2 == 0xE700000000000000LL)
  {
    unint64_t v5 = 0xE700000000000000LL;
    goto LABEL_8;
  }

  if ((_stringCompareWithSmolCheck(_:_:expecting:)(0x6C6F72746E6F63LL, 0xE700000000000000LL, a1, a2, 0LL) & 1) != 0)
  {
    unint64_t v5 = a2;
LABEL_8:
    swift_bridgeObjectRelease(v5);
    return 0LL;
  }

  if (a1 == 0x6E6974617265706FLL && a2 == 0xEE007373616C4367LL)
  {
    unint64_t v7 = 0xEE007373616C4367LL;
LABEL_14:
    swift_bridgeObjectRelease(v7);
    return 1LL;
  }

  if ((_stringCompareWithSmolCheck(_:_:expecting:)(0x6E6974617265706FLL, 0xEE007373616C4367LL, a1, a2, 0LL) & 1) != 0)
  {
    unint64_t v7 = a2;
    goto LABEL_14;
  }

  if (a1 == 0x4E6C656E6E616863LL && a2 == 0xED00007265626D75LL)
  {
    unint64_t v8 = 0xED00007265626D75LL;
LABEL_20:
    swift_bridgeObjectRelease(v8);
    return 2LL;
  }

  if ((_stringCompareWithSmolCheck(_:_:expecting:)(0x4E6C656E6E616863LL, 0xED00007265626D75LL, a1, a2, 0LL) & 1) != 0)
  {
    unint64_t v8 = a2;
    goto LABEL_20;
  }

  if (a1 == 0x6962616C69617661LL && a2 == 0xEF70614D7974696CLL)
  {
    swift_bridgeObjectRelease(0xEF70614D7974696CLL);
    return 3LL;
  }

  else
  {
    char v9 = _stringCompareWithSmolCheck(_:_:expecting:)(0x6962616C69617661LL, 0xEF70614D7974696CLL, a1, a2, 0LL);
    swift_bridgeObjectRelease(a2);
    if ((v9 & 1) != 0) {
      return 3LL;
    }
    else {
      return 4LL;
    }
  }

unint64_t sub_100089960()
{
  unint64_t result = qword_100406838;
  if (!qword_100406838)
  {
    unint64_t result = swift_getWitnessTable(&protocol conformance descriptor for NANMapID, &type metadata for NANMapID);
    atomic_store(result, (unint64_t *)&qword_100406838);
  }

  return result;
}

unint64_t sub_1000899A4()
{
  unint64_t result = qword_100406840;
  if (!qword_100406840)
  {
    unint64_t result = swift_getWitnessTable(&protocol conformance descriptor for NANMapIDs, &type metadata for NANMapIDs);
    atomic_store(result, (unint64_t *)&qword_100406840);
  }

  return result;
}

uint64_t sub_1000899E8(uint64_t a1, uint64_t a2)
{
  return a2;
}

uint64_t sub_100089A24( uint64_t a1, void (*a2)(void, void, void, void, void, void, void))
{
  return a1;
}

uint64_t sub_100089A60(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = type metadata accessor for LongTermPairingKeys.PublicIdentity(0LL);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v4 - 8) + 32LL))(a2, a1, v4);
  return a2;
}

unint64_t sub_100089AA4()
{
  unint64_t result = qword_100406858;
  if (!qword_100406858)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for NANIntervalDuration,  &type metadata for NANIntervalDuration);
    atomic_store(result, (unint64_t *)&qword_100406858);
  }

  return result;
}

unint64_t sub_100089AE8()
{
  unint64_t result = qword_100406860;
  if (!qword_100406860)
  {
    unint64_t result = swift_getWitnessTable(&unk_10033E41C, &type metadata for DeprecatedNANAvailability.AvailabilityControl);
    atomic_store(result, (unint64_t *)&qword_100406860);
  }

  return result;
}

unint64_t sub_100089B2C()
{
  unint64_t result = qword_100406880;
  if (!qword_100406880)
  {
    unint64_t result = swift_getWitnessTable(&protocol conformance descriptor for NANMapID, &type metadata for NANMapID);
    atomic_store(result, (unint64_t *)&qword_100406880);
  }

  return result;
}

unint64_t sub_100089B70()
{
  unint64_t result = qword_100406888;
  if (!qword_100406888)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for NANBitmap.Time,  &type metadata for NANBitmap.Time);
    atomic_store(result, (unint64_t *)&qword_100406888);
  }

  return result;
}

unint64_t sub_100089BB4()
{
  unint64_t result = qword_1004068B0;
  if (!qword_1004068B0)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for NANAvailabilityEntry.Control,  &type metadata for NANAvailabilityEntry.Control);
    atomic_store(result, (unint64_t *)&qword_1004068B0);
  }

  return result;
}

unint64_t sub_100089BF8()
{
  unint64_t result = qword_1004068B8;
  if (!qword_1004068B8)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for NANAvailabilityEntry.BandChannelEntries,  &type metadata for NANAvailabilityEntry.BandChannelEntries);
    atomic_store(result, (unint64_t *)&qword_1004068B8);
  }

  return result;
}

unint64_t sub_100089C3C()
{
  unint64_t result = qword_1004068C0;
  if (!qword_1004068C0)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for NANAvailabilityEntry.BandChannelEntries.Control,  &type metadata for NANAvailabilityEntry.BandChannelEntries.Control);
    atomic_store(result, (unint64_t *)&qword_1004068C0);
  }

  return result;
}

uint64_t sub_100089C80(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = sub_100002274(&qword_100405280);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v4 - 8) + 16LL))(a2, a1, v4);
  return a2;
}

unint64_t sub_100089CC8()
{
  unint64_t result = qword_1004068D0;
  if (!qword_1004068D0)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for NANBitmap.Band,  &type metadata for NANBitmap.Band);
    atomic_store(result, (unint64_t *)&qword_1004068D0);
  }

  return result;
}

unint64_t sub_100089D0C()
{
  unint64_t result = qword_1004068D8;
  if (!qword_1004068D8)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for NANBitmap.Channel,  &type metadata for NANBitmap.Channel);
    atomic_store(result, (unint64_t *)&qword_1004068D8);
  }

  return result;
}

uint64_t sub_100089D50(uint64_t a1, uint64_t a2)
{
  if (a1) {
    uint64_t v3 = a2 - a1;
  }
  else {
    uint64_t v3 = 0LL;
  }
  return Data._Representation.replaceSubrange(_:with:count:)(*(void *)(v2 + 24), *(void *)(v2 + 32), a1, v3);
}

unint64_t sub_100089D94()
{
  unint64_t result = qword_100406908;
  if (!qword_100406908)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for NANBitmap.Time.Control,  &type metadata for NANBitmap.Time.Control);
    atomic_store(result, (unint64_t *)&qword_100406908);
  }

  return result;
}

unint64_t sub_100089DD8()
{
  unint64_t result = qword_100406920;
  if (!qword_100406920)
  {
    uint64_t v1 = sub_1000022F8(&qword_100406918);
    unint64_t result = swift_getWitnessTable(&protocol conformance descriptor for <A> A?, v1);
    atomic_store(result, (unint64_t *)&qword_100406920);
  }

  return result;
}

BOOL sub_100089E94(uint64_t a1, uint64_t a2)
{
  return sub_100073A8C(a1, a2);
}

BOOL sub_100089F34(unsigned int a1, uint64_t a2)
{
  return ((~*(unsigned __int8 *)(a2 + ((unint64_t)a1 >> 3)) >> (a1 & 7)) & 1) == 0;
}

uint64_t sub_100089F58@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4 = v10[0];
  uint64_t v5 = v10[1];
  uint64_t v7 = v10[2];
  uint64_t v6 = v10[3];
  uint64_t result = sub_1000586C0(a1, (uint64_t)v11, &qword_100406B98);
  if ((v11[32] & 1) == 0)
  {
    if ((v4 & 0x100000000LL) == 0)
    {
      uint64_t v6 = 0LL;
      uint64_t v7 = 0LL;
      uint64_t v5 = 0LL;
      uint64_t v4 = v4;
      char v9 = 0;
      goto LABEL_7;
    }

void *static DeviceDriver<>.parse(event:)( unint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, unint64_t a5, unint64_t a6)
{
  unint64_t v774 = a6;
  unint64_t v775 = a5;
  unint64_t v776 = a3;
  uint64_t v777 = a2;
  uint64_t v7 = type metadata accessor for Logger(0LL);
  unint64_t v771 = *(void *)(v7 - 8);
  v772.i64[0] = v7;
  __chkstk_darwin(v7);
  v773 = (char *)&v726 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v9 = type metadata accessor for DNSRecords.SRV(0LL);
  uint64_t v10 = __chkstk_darwin(v9);
  uint64_t v12 = (char *)&v726 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  __chkstk_darwin(v10);
  uint64_t v14 = (char *)&v726 - v13;
  uint64_t v15 = sub_100002274(&qword_100405DF8);
  __chkstk_darwin(v15);
  unint64_t v17 = (char *)&v726 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  unint64_t v770 = 0LL;
  uint64_t v18 = type metadata accessor for AWDLStatistics.LowLatencyStatistics(0LL);
  uint64_t v19 = *(void *)(v18 - 8);
  __chkstk_darwin(v18);
  char v21 = (char *)&v726 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t result = _swiftEmptyArrayStorage;
  unint64_t v769 = a1;
  switch(a1)
  {
    case 1uLL:
      uint64_t v23 = sub_100002274(&qword_100405E00);
      uint64_t v24 = type metadata accessor for DriverEvent(0LL);
      uint64_t v25 = *(void *)(v24 - 8);
      uint64_t v26 = *(void *)(v25 + 72);
      uint64_t v27 = *(unsigned __int8 *)(v25 + 80);
      uint64_t v28 = (v27 + 32) & ~v27;
      uint64_t v29 = swift_allocObject(v23, v28 + v26, v27 | 7);
      *(_OWORD *)(v29 + 16) = xmmword_100339900;
      uint64_t v30 = v29 + v28;
      *(_OWORD *)uint64_t v30 = 0u;
      *(_OWORD *)(v30 + 16) = 0u;
      *(_OWORD *)(v30 + 25) = 0u;
      goto LABEL_9;
    case 2uLL:
      uint64_t v31 = sub_100002274(&qword_100405E00);
      uint64_t v24 = type metadata accessor for DriverEvent(0LL);
      uint64_t v32 = *(void *)(v24 - 8);
      uint64_t v33 = *(void *)(v32 + 72);
      uint64_t v34 = *(unsigned __int8 *)(v32 + 80);
      uint64_t v35 = (v34 + 32) & ~v34;
      uint64_t v29 = swift_allocObject(v31, v35 + v33, v34 | 7);
      *(_OWORD *)(v29 + 16) = xmmword_100339900;
      uint64_t v30 = v29 + v35;
      uint64_t v36 = 2LL;
      goto LABEL_8;
    case 3uLL:
      uint64_t v37 = sub_100002274(&qword_100405E00);
      uint64_t v24 = type metadata accessor for DriverEvent(0LL);
      uint64_t v38 = *(void *)(v24 - 8);
      uint64_t v39 = *(void *)(v38 + 72);
      uint64_t v40 = *(unsigned __int8 *)(v38 + 80);
      uint64_t v41 = (v40 + 32) & ~v40;
      uint64_t v29 = swift_allocObject(v37, v41 + v39, v40 | 7);
      *(_OWORD *)(v29 + 16) = xmmword_100339900;
      uint64_t v30 = v29 + v41;
      uint64_t v36 = 3LL;
      goto LABEL_8;
    case 9uLL:
      type metadata accessor for apple80211_join_status(0LL);
      uint64_t v43 = v42;
      unint64_t v45 = v776;
      uint64_t v44 = v777;
      sub_100020AFC(v777, v776);
      sub_1000A163C(v43, v44, v45);
      sub_1000586C0((uint64_t)&v1034, (uint64_t)&v1051, &qword_100405E10);
      sub_1000586C0((uint64_t)&v1051, (uint64_t)v1055, &qword_100405E10);
      memcpy(v1179, v1055, 0x1CCuLL);
      uint64_t v46 = sub_100002274(&qword_100405E00);
      uint64_t v47 = type metadata accessor for DriverEvent(0LL);
      uint64_t v48 = *(void *)(v47 - 8);
      uint64_t v49 = *(void *)(v48 + 72);
      uint64_t v50 = *(unsigned __int8 *)(v48 + 80);
      uint64_t v51 = (v50 + 32) & ~v50;
      uint64_t v52 = swift_allocObject(v46, v51 + v49, v50 | 7);
      *(_OWORD *)(v52 + 16) = xmmword_100339900;
      uint64_t v53 = v52 + v51;
      *(void *)uint64_t v53 = sub_1000A2168() & 0xFFFFFFFFFFFFLL;
      *(void *)(v53 + 8) = v54;
      *(void *)(v53 + 16) = v56;
      *(void *)(v53 + 24) = v55;
      *(void *)(v53 + 32) = 0LL;
      __int16 v57 = 1024;
      goto LABEL_99;
    case 0xBuLL:
      uint64_t v58 = sub_100002274(&qword_100405E00);
      uint64_t v24 = type metadata accessor for DriverEvent(0LL);
      uint64_t v59 = *(void *)(v24 - 8);
      uint64_t v60 = *(void *)(v59 + 72);
      uint64_t v61 = *(unsigned __int8 *)(v59 + 80);
      uint64_t v62 = (v61 + 32) & ~v61;
      uint64_t v29 = swift_allocObject(v58, v62 + v60, v61 | 7);
      *(_OWORD *)(v29 + 16) = xmmword_100339900;
      uint64_t v30 = v29 + v62;
      uint64_t v36 = 1LL;
LABEL_8:
      *(void *)uint64_t v30 = v36;
      *(_OWORD *)(v30 + 24) = 0u;
      *(_OWORD *)(v30 + 8) = 0u;
      *(_BYTE *)(v30 + 40) = 0;
LABEL_9:
      *(_BYTE *)(v30 + 41) = 10;
      uint64_t v63 = v24;
      uint64_t v64 = 2LL;
      goto LABEL_10;
    case 0x2EuLL:
      uint64_t v65 = sub_100002274(&qword_100405E00);
      uint64_t v66 = type metadata accessor for DriverEvent(0LL);
      uint64_t v67 = *(void *)(v66 - 8);
      uint64_t v68 = *(void *)(v67 + 72);
      uint64_t v69 = *(unsigned __int8 *)(v67 + 80);
      uint64_t v70 = (v69 + 32) & ~v69;
      uint64_t v71 = swift_allocObject(v65, v70 + v68, v69 | 7);
      *(_OWORD *)(v71 + 16) = xmmword_100339900;
      uint64_t v72 = v71 + v70;
      uint64_t v73 = type metadata accessor for DriverEvent.AWDL(0LL);
      uint64_t v74 = v71 + v70;
      uint64_t v75 = 10LL;
      goto LABEL_188;
    case 0x2FuLL:
      type metadata accessor for apple80211_peer_presence_indication(0LL);
      uint64_t v77 = v76;
      unint64_t v45 = v776;
      uint64_t v44 = v777;
      sub_100020AFC(v777, v776);
      sub_1000A163C(v77, v44, v45);
      if ((v1055[4].i8[4] & 1) != 0) {
        goto LABEL_181;
      }
      if (v1055[0].i32[2] != 1) {
        goto LABEL_186;
      }
      __int8 v78 = v1055[0].i8[0];
      unint64_t v775 = (unint64_t)v1055[0].i64[0] >> 40;
      __int8 v79 = v1055[0].i8[4];
      unint64_t v80 = (unint64_t)v1055[0].i64[0] >> 24;
      unint64_t v81 = (unint64_t)v1055[0].i64[0] >> 16;
      unint64_t v82 = (unint64_t)v1055[0].i64[0] >> 8;
      uint64_t v83 = sub_100002274(&qword_100405E00);
      uint64_t v84 = type metadata accessor for DriverEvent(0LL);
      uint64_t v85 = *(void *)(v84 - 8);
      uint64_t v86 = *(void *)(v85 + 72);
      uint64_t v87 = *(unsigned __int8 *)(v85 + 80);
      uint64_t v88 = (v87 + 32) & ~v87;
      uint64_t v52 = swift_allocObject(v83, v88 + v86, v87 | 7);
      *(_OWORD *)(v52 + 16) = xmmword_100339900;
      uint64_t v89 = (__int8 *)(v52 + v88);
      *uint64_t v89 = v78;
      v89[1] = v82;
      v89[2] = v81;
      v89[3] = v80;
      v89[4] = v79;
      v89[5] = v775;
      uint64_t v90 = type metadata accessor for DriverEvent.AWDL(0LL);
      swift_storeEnumTagMultiPayload(v52 + v88, v90, 7LL);
      swift_storeEnumTagMultiPayload(v52 + v88, v84, 1LL);
      unint64_t v92 = v776;
      uint64_t v91 = v777;
      goto LABEL_209;
    case 0x30uLL:
      __asm { BR              X9 }

      return result;
    case 0x31uLL:
      type metadata accessor for apple80211_chip_reset(0LL);
      uint64_t v94 = v93;
      unint64_t v45 = v776;
      uint64_t v44 = v777;
      sub_100020AFC(v777, v776);
      sub_1000A163C(v94, v44, v45);
      if ((v1055[0].i8[4] & 1) != 0) {
        goto LABEL_181;
      }
      __int32 v95 = v1055[0].i32[0];
      uint64_t v96 = sub_100002274(&qword_100405E00);
      uint64_t v97 = type metadata accessor for DriverEvent(0LL);
      uint64_t v98 = *(void *)(v97 - 8);
      uint64_t v99 = *(void *)(v98 + 72);
      uint64_t v100 = *(unsigned __int8 *)(v98 + 80);
      uint64_t v101 = (v100 + 32) & ~v100;
      uint64_t v102 = swift_allocObject(v96, v101 + v99, v100 | 7);
      *(_OWORD *)(v102 + 16) = xmmword_100339900;
      uint64_t v103 = v102 + v101;
      char v104 = v95 == 1;
      goto LABEL_21;
    case 0x37uLL:
      type metadata accessor for apple80211_driver_availability(0LL);
      uint64_t v106 = v105;
      unint64_t v45 = v776;
      uint64_t v44 = v777;
      sub_100020AFC(v777, v776);
      sub_1000A163C(v106, v44, v45);
      sub_1000586C0((uint64_t)&v1034, (uint64_t)&v1051, &qword_100405E18);
      sub_1000586C0((uint64_t)&v1051, (uint64_t)v1055, &qword_100405E18);
      uint64_t v107 = v773;
      if (!v1055[0].i32[2]) {
        goto LABEL_182;
      }
      uint64_t v108 = sub_100002274(&qword_100405E00);
      uint64_t v97 = type metadata accessor for DriverEvent(0LL);
      uint64_t v109 = *(void *)(v97 - 8);
      uint64_t v110 = *(void *)(v109 + 72);
      uint64_t v111 = *(unsigned __int8 *)(v109 + 80);
      uint64_t v112 = (v111 + 32) & ~v111;
      uint64_t v102 = swift_allocObject(v108, v112 + v110, v111 | 7);
      *(_OWORD *)(v102 + 16) = xmmword_100339900;
      uint64_t v103 = v102 + v112;
      char v104 = 4;
LABEL_21:
      *(_BYTE *)uint64_t v103 = v104;
      uint64_t v113 = v97;
      uint64_t v114 = 4LL;
      goto LABEL_171;
    case 0x3BuLL:
      uint64_t v115 = sub_100002274(&qword_100405E00);
      uint64_t v116 = type metadata accessor for DriverEvent(0LL);
      uint64_t v117 = *(void *)(v116 - 8);
      uint64_t v118 = *(void *)(v117 + 72);
      uint64_t v119 = *(unsigned __int8 *)(v117 + 80);
      uint64_t v120 = (v119 + 32) & ~v119;
      uint64_t v29 = swift_allocObject(v115, v120 + v118, v119 | 7);
      *(_OWORD *)(v29 + 16) = xmmword_100339900;
      uint64_t v30 = v29 + v120;
      uint64_t v63 = v116;
      uint64_t v64 = 5LL;
LABEL_10:
      swift_storeEnumTagMultiPayload(v30, v63, v64);
      return (void *)v29;
    case 0x41uLL:
      uint64_t v121 = sub_100002274(&qword_100405E00);
      uint64_t v66 = type metadata accessor for DriverEvent(0LL);
      uint64_t v122 = *(void *)(v66 - 8);
      uint64_t v123 = *(void *)(v122 + 72);
      uint64_t v124 = *(unsigned __int8 *)(v122 + 80);
      uint64_t v125 = (v124 + 32) & ~v124;
      uint64_t v71 = swift_allocObject(v121, v125 + v123, v124 | 7);
      *(_OWORD *)(v71 + 16) = xmmword_100339900;
      uint64_t v72 = v71 + v125;
      uint64_t v73 = type metadata accessor for DriverEvent.AWDL(0LL);
      uint64_t v74 = v71 + v125;
      uint64_t v75 = 12LL;
      goto LABEL_188;
    case 0x42uLL:
      type metadata accessor for apple80211_assoc_ready(0LL);
      uint64_t v127 = v126;
      unint64_t v45 = v776;
      uint64_t v44 = v777;
      sub_100020AFC(v777, v776);
      sub_1000A163C(v127, v44, v45);
      if ((v1055[1].i8[8] & 1) != 0) {
        goto LABEL_181;
      }
      uint64_t v128 = v1055[1].i64[0];
      uint64_t v129 = v1055[0].i64[1];
      uint64_t v130 = v1055[0].i64[0];
      uint64_t v131 = sub_100002274(&qword_100405E00);
      uint64_t v132 = type metadata accessor for DriverEvent(0LL);
      uint64_t v133 = *(void *)(v132 - 8);
      uint64_t v134 = *(void *)(v133 + 72);
      uint64_t v135 = *(unsigned __int8 *)(v133 + 80);
      uint64_t v136 = (v135 + 32) & ~v135;
      uint64_t v137 = swift_allocObject(v131, v136 + v134, v135 | 7);
      *(_OWORD *)(v137 + 16) = xmmword_100339900;
      uint64_t v138 = v137 + v136;
      sub_1000A22C4(v130, v129, v128, (uint64_t)v1055);
      __int8 v139 = v1055[2].i8[8];
      *(void *)uint64_t v138 = v1055[0].u16[0];
      *(int64x2_t *)(v138 + 8) = *(int64x2_t *)((char *)v1055 + 8);
      *(int64x2_t *)(v138 + 24) = *(int64x2_t *)((char *)&v1055[1] + 8);
      *(_BYTE *)(v138 + 40) = v139;
      *(_BYTE *)(v138 + 41) = 5;
      swift_storeEnumTagMultiPayload(v137 + v136, v132, 2LL);
      uint64_t v140 = v777;
      goto LABEL_178;
    case 0x43uLL:
      uint64_t v141 = sub_100002274(&qword_100405E00);
      uint64_t v66 = type metadata accessor for DriverEvent(0LL);
      uint64_t v142 = *(void *)(v66 - 8);
      uint64_t v143 = *(void *)(v142 + 72);
      uint64_t v144 = *(unsigned __int8 *)(v142 + 80);
      uint64_t v145 = (v144 + 32) & ~v144;
      uint64_t v71 = swift_allocObject(v141, v145 + v143, v144 | 7);
      *(_OWORD *)(v71 + 16) = xmmword_100339900;
      uint64_t v72 = v71 + v145;
      *(_BYTE *)(v71 + v145) = 1;
      goto LABEL_28;
    case 0x44uLL:
      uint64_t v146 = sub_100002274(&qword_100405E00);
      uint64_t v66 = type metadata accessor for DriverEvent(0LL);
      uint64_t v147 = *(void *)(v66 - 8);
      uint64_t v148 = *(void *)(v147 + 72);
      uint64_t v149 = *(unsigned __int8 *)(v147 + 80);
      uint64_t v150 = (v149 + 32) & ~v149;
      uint64_t v71 = swift_allocObject(v146, v150 + v148, v149 | 7);
      *(_OWORD *)(v71 + 16) = xmmword_100339900;
      uint64_t v72 = v71 + v150;
      *(_BYTE *)(v71 + v150) = 0;
LABEL_28:
      uint64_t v73 = type metadata accessor for DriverEvent.AWDL(0LL);
      uint64_t v74 = v72;
      uint64_t v75 = 0LL;
      goto LABEL_188;
    case 0x4AuLL:
      type metadata accessor for apple80211_message_auth(0LL);
      uint64_t v152 = v151;
      unint64_t v45 = v776;
      uint64_t v44 = v777;
      sub_100020AFC(v777, v776);
      sub_1000A163C(v152, v44, v45);
      if ((v1055[6].i8[8] & 1) != 0) {
        goto LABEL_181;
      }
      __int16 v153 = v1055[0].i16[2];
      __int16 v154 = v1055[0].i16[0];
      uint64_t v155 = sub_100002274(&qword_100405E00);
      uint64_t v156 = type metadata accessor for DriverEvent(0LL);
      uint64_t v157 = *(void *)(v156 - 8);
      uint64_t v158 = *(void *)(v157 + 72);
      uint64_t v159 = *(unsigned __int8 *)(v157 + 80);
      uint64_t v160 = (v159 + 32) & ~v159;
      uint64_t v137 = swift_allocObject(v155, v160 + v158, v159 | 7);
      *(_OWORD *)(v137 + 16) = xmmword_100339900;
      uint64_t v161 = v137 + v160;
      unsigned __int8 v162 = _s7CoreP2P15IEEE80211StatusO8rawValueACSgs6UInt16V_tcfC_0(v154 & 0x1FF);
      if (v162 == 54) {
        unsigned __int8 v163 = 1;
      }
      else {
        unsigned __int8 v163 = v162;
      }
      unsigned __int8 v164 = _s7CoreP2P15IEEE80211ReasonO8rawValueACSgs6UInt16V_tcfC_0(v153 & 0x1FF);
      if (v164 == 34) {
        unsigned __int8 v165 = 1;
      }
      else {
        unsigned __int8 v165 = v164;
      }
      *(void *)uint64_t v161 = v163 | ((unint64_t)v165 << 8);
      *(_OWORD *)(v161 + 8) = 0u;
      *(_OWORD *)(v161 + 24) = 0u;
      __int16 v166 = 1792;
      goto LABEL_45;
    case 0x4EuLL:
      type metadata accessor for apple80211_message_assoc(0LL);
      uint64_t v168 = v167;
      unint64_t v45 = v776;
      uint64_t v44 = v777;
      sub_100020AFC(v777, v776);
      sub_1000A163C(v168, v44, v45);
      if ((v1055[0].i8[8] & 1) != 0) {
        goto LABEL_181;
      }
      __int16 v169 = v1055[0].i16[2];
      __int16 v170 = v1055[0].i16[0];
      uint64_t v171 = sub_100002274(&qword_100405E00);
      uint64_t v156 = type metadata accessor for DriverEvent(0LL);
      uint64_t v172 = *(void *)(v156 - 8);
      uint64_t v173 = *(void *)(v172 + 72);
      uint64_t v174 = *(unsigned __int8 *)(v172 + 80);
      uint64_t v175 = (v174 + 32) & ~v174;
      uint64_t v137 = swift_allocObject(v171, v175 + v173, v174 | 7);
      *(_OWORD *)(v137 + 16) = xmmword_100339900;
      uint64_t v161 = v137 + v175;
      unsigned __int8 v176 = _s7CoreP2P15IEEE80211StatusO8rawValueACSgs6UInt16V_tcfC_0(v170 & 0x1FF);
      if (v176 == 54) {
        unsigned __int8 v177 = 1;
      }
      else {
        unsigned __int8 v177 = v176;
      }
      unsigned __int8 v178 = _s7CoreP2P15IEEE80211ReasonO8rawValueACSgs6UInt16V_tcfC_0(v169 & 0x1FF);
      if (v178 == 34) {
        unsigned __int8 v179 = 1;
      }
      else {
        unsigned __int8 v179 = v178;
      }
      *(void *)uint64_t v161 = v177 | ((unint64_t)v179 << 8);
      *(_OWORD *)(v161 + 8) = 0u;
      *(_OWORD *)(v161 + 24) = 0u;
      __int16 v166 = 1536;
LABEL_45:
      *(_WORD *)(v161 + 40) = v166;
      uint64_t v180 = v161;
      uint64_t v181 = v156;
      uint64_t v182 = 2LL;
      goto LABEL_177;
    case 0x52uLL:
      type metadata accessor for apple80211_channel(0LL);
      uint64_t v184 = v183;
      unint64_t v45 = v776;
      uint64_t v44 = v777;
      sub_100020AFC(v777, v776);
      sub_1000A163C(v184, v44, v45);
      if ((v1055[0].i8[12] & 1) != 0) {
        goto LABEL_181;
      }
      unsigned int v185 = v1055[0].u32[2];
      unsigned int v186 = v1055[0].u32[1];
      uint64_t v187 = sub_100002274(&qword_100405E00);
      uint64_t v188 = type metadata accessor for DriverEvent(0LL);
      uint64_t v189 = *(void *)(v188 - 8);
      uint64_t v190 = *(void *)(v189 + 72);
      uint64_t v191 = *(unsigned __int8 *)(v189 + 80);
      uint64_t v192 = (v191 + 32) & ~v191;
      uint64_t v137 = swift_allocObject(v187, v192 + v190, v191 | 7);
      *(_OWORD *)(v137 + 16) = xmmword_100339900;
      uint64_t v193 = v137 + v192;
      *(void *)uint64_t v193 = sub_1000A810C(v186, v185) & 0xFFFFFFFFFFFFLL;
      *(_OWORD *)(v193 + 8) = 0u;
      *(_OWORD *)(v193 + 24) = 0u;
      *(_WORD *)(v193 + 40) = 2048;
      uint64_t v180 = v137 + v192;
      uint64_t v181 = v188;
      uint64_t v182 = 2LL;
      goto LABEL_177;
    case 0x5FuLL:
      type metadata accessor for apple80211_nan_device_role_changed_event_data(0LL);
      uint64_t v195 = v194;
      unint64_t v45 = v776;
      uint64_t v44 = v777;
      sub_100020AFC(v777, v776);
      sub_1000A163C(v195, v44, v45);
      if ((v1055[0].i8[12] & 1) != 0) {
        goto LABEL_181;
      }
      uint64_t v196 = v1055[0].u8[8];
      unint64_t v197 = v1055[0].i64[0];
      uint64_t v198 = sub_100002274(&qword_100405E00);
      uint64_t v199 = type metadata accessor for DriverEvent(0LL);
      uint64_t v200 = *(void *)(v199 - 8);
      uint64_t v201 = *(void *)(v200 + 72);
      uint64_t v202 = *(unsigned __int8 *)(v200 + 80);
      uint64_t v203 = (v202 + 32) & ~v202;
      uint64_t v204 = swift_allocObject(v198, v203 + v201, v202 | 7);
      *(_OWORD *)(v204 + 16) = xmmword_100339900;
      v205 = (void *)(v204 + v203);
      if ((_DWORD)v197 == 3)
      {
        uint64_t v206 = v204;
        __int8 v207 = HIDWORD(v197) == 1;
      }

      else if ((_DWORD)v197 == 2)
      {
        uint64_t v206 = v204;
        __int8 v207 = 4;
      }

      else
      {
        uint64_t v206 = v204;
        if ((_DWORD)v197 == 1) {
          __int8 v207 = 3;
        }
        else {
          __int8 v207 = 0;
        }
      }

      v1055[0].i8[0] = v207;
      v1055[0].i64[1] = v196;
      sub_100058768((uint64_t)v1055);
      sub_100058090(v1055, v205);
      v546 = v205;
      uint64_t v547 = v199;
      goto LABEL_218;
    case 0x61uLL:
      type metadata accessor for apple80211_nan_cluster_changed_event_data(0LL);
      uint64_t v209 = v208;
      unint64_t v45 = v776;
      uint64_t v44 = v777;
      sub_100020AFC(v777, v776);
      sub_1000A163C(v209, v44, v45);
      if ((v1051.i8[6] & 1) != 0) {
        goto LABEL_181;
      }
      __int8 v210 = v1051.i8[0];
      unint64_t v211 = v1051.u32[0] | ((unint64_t)v1051.u16[2] << 32);
      unint64_t v212 = (unint64_t)v1051.u16[2] >> 8;
      uint64_t v213 = sub_100002274(&qword_100405E00);
      uint64_t v214 = type metadata accessor for DriverEvent(0LL);
      uint64_t v215 = *(void *)(v214 - 8);
      uint64_t v216 = *(void *)(v215 + 72);
      uint64_t v217 = *(unsigned __int8 *)(v215 + 80);
      uint64_t v218 = v44;
      uint64_t v219 = (v217 + 32) & ~v217;
      uint64_t v220 = swift_allocObject(v213, v219 + v216, v217 | 7);
      *(_OWORD *)(v220 + 16) = xmmword_100339900;
      v221 = (void *)(v220 + v219);
      v1055[0].i8[0] = v210;
      v222.i64[0] = 0xFFFFFFFFFFFFLL;
      v222.i64[1] = 0xFFFFFFFFFFFFLL;
      uint64x2_t v223 = (uint64x2_t)vandq_s8((int8x16_t)vdupq_n_s64(v211), v222);
      int16x8_t v224 = (int16x8_t)vshlq_u64(v223, (uint64x2_t)xmmword_10033A8F0);
      *(int32x2_t *)v223.i8 = vmovn_s64((int64x2_t)vshlq_u64(v223, (uint64x2_t)xmmword_10033A8E0));
      *(int32x2_t *)v224.i8 = vmovn_s64((int64x2_t)v224);
      v224.i16[1] = v224.i16[2];
      v224.i16[2] = v223.i16[0];
      v224.i16[3] = v223.i16[2];
      *(__int32 *)((char *)v1055[0].i32 + 1) = vmovn_s16(v224).u32[0];
      v1055[0].i8[5] = v212;
      sub_100058774((uint64_t)v1055);
      goto LABEL_107;
    case 0x62uLL:
      KeyPath = (uint64_t *)swift_getKeyPath(&unk_10033E888);
      v226 = (void *)swift_getKeyPath(&unk_10033E8A8);
      unint64_t v45 = v776;
      uint64_t v44 = v777;
      sub_100020AFC(v777, v776);
      unint64_t v227 = sub_1000A9AFC();
      unint64_t v228 = sub_1000A9B40();
      sub_1000A0F14(KeyPath, v226, v44, v45, (uint64_t)&type metadata for IEEE80211Frame, v227, (uint64_t)v1055, v228);
      swift_release(KeyPath);
      swift_release(v226);
      sub_1000586C0((uint64_t)v1055, (uint64_t)&v1034, &qword_100405E68);
      sub_1000586C0((uint64_t)&v1034, (uint64_t)&v1051, &qword_100405E68);
      uint64_t v229 = v1051.i32[0];
      unsigned int v230 = v1051.u32[2];
      uint64_t v231 = v1052.u8[0];
      unsigned int v232 = v1051.u32[3];
      uint64_t v233 = v1052.u32[1];
      unint64_t v774 = v1052.u32[2];
      uint64_t v234 = sub_100002274(&qword_100405E00);
      uint64_t v235 = type metadata accessor for DriverEvent(0LL);
      uint64_t v236 = *(void *)(v235 - 8);
      uint64_t v237 = *(void *)(v236 + 72);
      uint64_t v238 = *(unsigned __int8 *)(v236 + 80);
      uint64_t v239 = (v238 + 32) & ~v238;
      uint64_t v240 = swift_allocObject(v234, v239 + v237, v238 | 7);
      *(_OWORD *)(v240 + 16) = xmmword_100339900;
      unint64_t v775 = v240;
      v241 = (void *)(v240 + v239);
      sub_100058148((uint64_t)v1053);
      unint64_t v242 = sub_1000A810C(v230, v232);
      if ((v242 & 0xFF00000000LL) == 0x300000000LL)
      {
        if (qword_1004043A0 != -1) {
          swift_once(&qword_1004043A0, sub_100186540);
        }
        LODWORD(v242) = static Channel.nanPrimary;
        LOBYTE(v243) = byte_1004108A4;
        LOBYTE(v244) = byte_1004108A5;
        uint64_t v245 = v777;
      }

      else
      {
        unint64_t v243 = HIDWORD(v242);
        unint64_t v244 = v242 >> 40;
        uint64_t v245 = v777;
      }

      v1055[8] = v1053[8];
      v1055[9] = v1053[9];
      v1055[10] = v1054[0];
      *(int64x2_t *)((char *)&v1055[10] + 9) = *(int64x2_t *)((char *)v1054 + 9);
      v1055[4] = v1053[4];
      v1055[5] = v1053[5];
      v1055[6] = v1053[6];
      v1055[7] = v1053[7];
      v1055[0] = v1053[0];
      v1055[1] = v1053[1];
      v1055[2] = v1053[2];
      v1055[3] = v1053[3];
      v1055[12].i64[0] = v229;
      v1055[12].i32[2] = v242;
      v1055[12].i8[12] = v243;
      v1055[12].i8[13] = v244;
      v1055[13].i64[0] = v231;
      v1055[13].i64[1] = v774 | (v233 << 32);
      sub_10005854C((uint64_t)v1055);
      sub_100058090(v1055, v241);
      swift_storeEnumTagMultiPayload(v241, v235, 0LL);
      sub_100058558((uint64_t)&v1034);
      uint64_t v682 = v245;
      goto LABEL_201;
    case 0x63uLL:
      type metadata accessor for apple80211_nan_follow_up_tx_complete_event_data(0LL);
      uint64_t v247 = v246;
      unint64_t v45 = v776;
      uint64_t v44 = v777;
      sub_100020AFC(v777, v776);
      sub_1000A163C(v247, v44, v45);
      if ((v1052.i8[4] & 1) != 0) {
        goto LABEL_181;
      }
      unsigned int v248 = v1052.i32[0];
      unint64_t v249 = v1051.u64[1];
      unsigned __int16 v250 = v1051.i16[0];
      uint64_t v251 = sub_100002274(&qword_100405E00);
      uint64_t v214 = type metadata accessor for DriverEvent(0LL);
      uint64_t v252 = *(void *)(v214 - 8);
      uint64_t v253 = *(void *)(v252 + 72);
      uint64_t v254 = *(unsigned __int8 *)(v252 + 80);
      uint64_t v218 = v44;
      uint64_t v255 = (v254 + 32) & ~v254;
      uint64_t v220 = swift_allocObject(v251, v255 + v253, v254 | 7);
      *(_OWORD *)(v220 + 16) = xmmword_100339900;
      v1055[0].i64[0] = sub_1000A17D4(v250, v249, v248);
      v1055[0].i8[8] = v256;
      sub_100058678((uint64_t)v1055);
      sub_100058090(v1055, (void *)(v220 + v255));
      uint64_t v257 = v220 + v255;
      goto LABEL_108;
    case 0x64uLL:
      v258 = (uint64_t *)swift_getKeyPath(&unk_10033EA08);
      v259 = (void *)swift_getKeyPath(&unk_10033EA28);
      unint64_t v45 = v776;
      uint64_t v44 = v777;
      sub_100020AFC(v777, v776);
      uint64_t v260 = sub_100002274(&qword_100405E78);
      unint64_t v261 = sub_1000A9B84();
      unint64_t v262 = sub_1000A9B40();
      sub_1000A0F14(v258, v259, v44, v45, v260, v261, (uint64_t)&v1051, v262);
      swift_release(v258);
      swift_release(v259);
      uint64_t v263 = v1053[0].i64[0];
      if (!v1053[0].i64[0]) {
        goto LABEL_181;
      }
      __int8 v264 = v1051.i8[0];
      unint64_t v265 = (unint64_t)v1051.i64[0] >> 8;
      unint64_t v266 = (unint64_t)v1051.i64[0] >> 16;
      unint64_t v267 = (unint64_t)v1051.i64[0] >> 24;
      unint64_t v771 = HIDWORD(v1051.i64[0]);
      v772.i64[0] = (unint64_t)v1051.i64[0] >> 40;
      v773 = (char *)HIWORD(v1051.i64[0]);
      unint64_t v774 = HIBYTE(v1051.i64[0]);
      unint64_t v775 = v1051.i8[8];
      uint64_t v268 = sub_100002274(&qword_100405E00);
      uint64_t v269 = type metadata accessor for DriverEvent(0LL);
      uint64_t v270 = *(void *)(v269 - 8);
      uint64_t v271 = *(void *)(v270 + 72);
      uint64_t v272 = *(unsigned __int8 *)(v270 + 80);
      uint64_t v273 = (v272 + 32) & ~v272;
      uint64_t v220 = swift_allocObject(v268, v273 + v271, v272 | 7);
      *(_OWORD *)(v220 + 16) = xmmword_100339900;
      v274 = (void *)(v220 + v273);
      v1055[0].i8[0] = v264;
      v1055[0].i8[1] = v265;
      v1055[0].i8[2] = v266;
      v1055[0].i8[3] = v267;
      v1055[0].i8[4] = v771;
      v1055[0].i8[5] = v772.i8[0];
      v1055[0].i8[6] = (char)v773;
      v1055[0].i8[7] = v774;
      v1055[0].i64[1] = v775;
      v1055[1].i64[0] = v263;
      sub_10005875C((uint64_t)v1055);
      goto LABEL_74;
    case 0x66uLL:
      v275 = (uint64_t *)swift_getKeyPath(&unk_10033E9C8);
      v276 = (void *)swift_getKeyPath(&unk_10033E9E8);
      unint64_t v45 = v776;
      uint64_t v44 = v777;
      sub_100020AFC(v777, v776);
      uint64_t v277 = sub_100002274(&qword_100405E78);
      unint64_t v278 = sub_1000A9B84();
      unint64_t v279 = sub_1000A9B40();
      sub_1000A0F14(v275, v276, v44, v45, v277, v278, (uint64_t)&v1051, v279);
      swift_release(v275);
      swift_release(v276);
      uint64_t v280 = v1053[0].i64[0];
      if (!v1053[0].i64[0]) {
        goto LABEL_181;
      }
      __int8 v281 = v1051.i8[0];
      unint64_t v282 = (unint64_t)v1051.i64[0] >> 8;
      unint64_t v283 = (unint64_t)v1051.i64[0] >> 16;
      unint64_t v771 = (unint64_t)v1051.i64[0] >> 24;
      v772.i64[0] = HIDWORD(v1051.i64[0]);
      v773 = (char *)((unint64_t)v1051.i64[0] >> 40);
      unint64_t v774 = HIWORD(v1051.i64[0]);
      unint64_t v775 = v1051.i8[8];
      unint64_t v284 = HIBYTE(v1051.i64[0]);
      uint64_t v285 = sub_100002274(&qword_100405E00);
      uint64_t v286 = type metadata accessor for DriverEvent(0LL);
      uint64_t v287 = *(void *)(v286 - 8);
      uint64_t v288 = *(void *)(v287 + 72);
      uint64_t v289 = *(unsigned __int8 *)(v287 + 80);
      uint64_t v290 = (v289 + 32) & ~v289;
      uint64_t v291 = swift_allocObject(v285, v290 + v288, v289 | 7);
      *(_OWORD *)(v291 + 16) = xmmword_100339900;
      v1055[0].i8[0] = v281;
      v1055[0].i8[1] = v284;
      v1055[0].i8[2] = v282;
      v1055[0].i8[3] = v283;
      v1055[0].i8[4] = v771;
      v1055[0].i8[5] = v772.i8[0];
      v1055[0].i8[6] = (char)v773;
      v1055[0].i8[7] = v774;
      v1055[0].i64[1] = v775;
      v1055[1].i64[0] = v280;
      sub_100058750((uint64_t)v1055);
      sub_100058090(v1055, (void *)(v291 + v290));
      swift_storeEnumTagMultiPayload(v291 + v290, v286, 0LL);
      uint64_t v292 = v777;
      goto LABEL_86;
    case 0x68uLL:
      type metadata accessor for apple80211_nan_publish_terminated_event_data(0LL);
      uint64_t v294 = v293;
      unint64_t v45 = v776;
      uint64_t v44 = v777;
      sub_100020AFC(v777, v776);
      sub_1000A163C(v294, v44, v45);
      if ((v1051.i8[2] & 1) != 0) {
        goto LABEL_181;
      }
      __int16 v295 = v1051.i16[0];
      uint64_t v296 = sub_100002274(&qword_100405E00);
      uint64_t v297 = type metadata accessor for DriverEvent(0LL);
      uint64_t v298 = *(void *)(v297 - 8);
      uint64_t v299 = *(void *)(v298 + 72);
      uint64_t v300 = *(unsigned __int8 *)(v298 + 80);
      uint64_t v301 = (v300 + 32) & ~v300;
      uint64_t v302 = swift_allocObject(v296, v301 + v299, v300 | 7);
      *(_OWORD *)(v302 + 16) = xmmword_100339900;
      v303 = (void *)(v302 + v301);
      uint64_t v52 = v302;
      else {
        uint64_t v304 = qword_10033F0E0[(char)(HIBYTE(v295) - 1)];
      }
      v1055[0].i8[0] = v295;
      v1055[0].i64[1] = v304;
      sub_100058690((uint64_t)v1055);
      goto LABEL_206;
    case 0x69uLL:
      type metadata accessor for apple80211_nan_subscribe_terminated_event_data(0LL);
      uint64_t v306 = v305;
      unint64_t v45 = v776;
      uint64_t v44 = v777;
      sub_100020AFC(v777, v776);
      sub_1000A163C(v306, v44, v45);
      if ((v1051.i8[2] & 1) != 0) {
        goto LABEL_181;
      }
      __int16 v307 = v1051.i16[0];
      uint64_t v308 = sub_100002274(&qword_100405E00);
      uint64_t v297 = type metadata accessor for DriverEvent(0LL);
      uint64_t v309 = *(void *)(v297 - 8);
      uint64_t v310 = *(void *)(v309 + 72);
      uint64_t v311 = *(unsigned __int8 *)(v309 + 80);
      uint64_t v312 = (v311 + 32) & ~v311;
      uint64_t v313 = swift_allocObject(v308, v312 + v310, v311 | 7);
      *(_OWORD *)(v313 + 16) = xmmword_100339900;
      v303 = (void *)(v313 + v312);
      uint64_t v52 = v313;
      else {
        uint64_t v314 = qword_10033F0E0[(char)(HIBYTE(v307) - 1)];
      }
      v1055[0].i8[0] = v307;
      v1055[0].i64[1] = v314;
      sub_10005869C((uint64_t)v1055);
LABEL_206:
      sub_100058090(v1055, v303);
      uint64_t v396 = (uint64_t)v303;
      uint64_t v397 = v297;
      goto LABEL_207;
    case 0x6AuLL:
      v315 = (uint64_t *)swift_getKeyPath(&unk_10033E8C8);
      v316 = (void *)swift_getKeyPath(&unk_10033E8E8);
      unint64_t v45 = v776;
      uint64_t v44 = v777;
      sub_100020AFC(v777, v776);
      uint64_t v317 = sub_100002274(&qword_100405E78);
      unint64_t v318 = sub_1000A9B84();
      unint64_t v319 = sub_1000A9B40();
      sub_1000A0F14(v315, v316, v44, v45, v317, v318, (uint64_t)&v1051, v319);
      swift_release(v315);
      swift_release(v316);
      uint64_t v320 = v1053[0].i64[0];
      if (!v1053[0].i64[0]) {
        goto LABEL_181;
      }
      __int8 v321 = v1051.i8[0];
      unint64_t v322 = (unint64_t)v1051.i64[0] >> 8;
      unint64_t v323 = (unint64_t)v1051.i64[0] >> 16;
      unint64_t v324 = (unint64_t)v1051.i64[0] >> 24;
      unint64_t v771 = HIDWORD(v1051.i64[0]);
      v772.i64[0] = (unint64_t)v1051.i64[0] >> 40;
      v773 = (char *)HIWORD(v1051.i64[0]);
      unint64_t v774 = HIBYTE(v1051.i64[0]);
      unint64_t v775 = v1051.i8[8];
      uint64_t v325 = sub_100002274(&qword_100405E00);
      uint64_t v269 = type metadata accessor for DriverEvent(0LL);
      uint64_t v326 = *(void *)(v269 - 8);
      uint64_t v327 = *(void *)(v326 + 72);
      uint64_t v328 = *(unsigned __int8 *)(v326 + 80);
      uint64_t v329 = (v328 + 32) & ~v328;
      uint64_t v220 = swift_allocObject(v325, v329 + v327, v328 | 7);
      *(_OWORD *)(v220 + 16) = xmmword_100339900;
      v274 = (void *)(v220 + v329);
      v1055[0].i8[0] = v321;
      v1055[0].i8[1] = v322;
      v1055[0].i8[2] = v323;
      v1055[0].i8[3] = v324;
      v1055[0].i8[4] = v771;
      v1055[0].i8[5] = v772.i8[0];
      v1055[0].i8[6] = (char)v773;
      v1055[0].i8[7] = v774;
      v1055[0].i64[1] = v775;
      v1055[1].i64[0] = v320;
      sub_100058684((uint64_t)v1055);
LABEL_74:
      sub_100058090(v1055, v274);
      uint64_t v330 = (uint64_t)v274;
      uint64_t v331 = v269;
      goto LABEL_79;
    case 0x70uLL:
      v332 = (uint64_t *)swift_getKeyPath(&unk_10033E988);
      v333 = (void *)swift_getKeyPath(&unk_10033E9A8);
      unint64_t v45 = v776;
      uint64_t v44 = v777;
      sub_100020AFC(v777, v776);
      uint64_t v334 = sub_100002274(&qword_100405E78);
      unint64_t v335 = sub_1000A9B84();
      unint64_t v336 = sub_1000A9B40();
      sub_1000A0F14(v332, v333, v44, v45, v334, v335, (uint64_t)&v1051, v336);
      swift_release(v332);
      swift_release(v333);
      uint64_t v337 = v1052.i64[1];
      if (!v1052.i64[1]) {
        goto LABEL_181;
      }
      __int8 v338 = v1051.i8[8];
      __int8 v339 = v1051.i8[0];
      unint64_t v340 = (unint64_t)v1051.i64[0] >> 8;
      unint64_t v341 = (unint64_t)v1051.i64[0] >> 24;
      unint64_t v766 = HIDWORD(v1051.i64[0]);
      unint64_t v767 = (unint64_t)v1051.i64[0] >> 40;
      unint64_t v768 = HIWORD(v1051.i64[0]);
      unint64_t v769 = HIBYTE(v1051.i64[0]);
      unint64_t v770 = (unint64_t)v1051.i64[1] >> 8;
      unint64_t v771 = (unint64_t)v1051.i64[1] >> 16;
      v772.i64[0] = (unint64_t)v1051.i64[1] >> 24;
      v773 = (char *)HIDWORD(v1051.i64[1]);
      unint64_t v774 = (unint64_t)v1051.i64[1] >> 40;
      unint64_t v775 = HIWORD(v1051.i64[1]);
      uint64_t v342 = sub_100002274(&qword_100405E00);
      uint64_t v343 = type metadata accessor for DriverEvent(0LL);
      uint64_t v344 = *(void *)(v343 - 8);
      uint64_t v345 = *(void *)(v344 + 72);
      uint64_t v346 = *(unsigned __int8 *)(v344 + 80);
      uint64_t v347 = (v346 + 32) & ~v346;
      uint64_t v137 = swift_allocObject(v342, v347 + v345, v346 | 7);
      *(_OWORD *)(v137 + 16) = xmmword_100339900;
      v1055[0].i8[0] = v339;
      v1055[0].i8[1] = v340;
      v1055[0].i8[2] = v341;
      v1055[0].i8[3] = v766;
      v1055[0].i8[4] = v767;
      v1055[0].i8[5] = v768;
      v1055[0].i8[6] = v769;
      v1055[0].i8[7] = v338;
      v1055[0].i8[8] = v770;
      v1055[0].i8[9] = v771;
      v1055[0].i8[10] = v772.i8[0];
      v1055[0].i8[11] = (char)v773;
      v1055[0].i8[12] = v774;
      v1055[0].i8[13] = v775;
      v1055[1].i64[0] = v337;
      sub_100058744((uint64_t)v1055);
      sub_100058090(v1055, (void *)(v137 + v347));
      swift_storeEnumTagMultiPayload(v137 + v347, v343, 0LL);
      unint64_t v348 = v776;
      uint64_t v140 = v777;
      goto LABEL_179;
    case 0x71uLL:
      v349 = (uint64_t *)swift_getKeyPath(&unk_10033E948);
      v350 = (void *)swift_getKeyPath(&unk_10033E968);
      unint64_t v45 = v776;
      uint64_t v44 = v777;
      sub_100020AFC(v777, v776);
      uint64_t v351 = sub_100002274(&qword_100405E78);
      unint64_t v352 = sub_1000A9B84();
      unint64_t v353 = sub_1000A9B40();
      sub_1000A0F14(v349, v350, v44, v45, v351, v352, (uint64_t)&v1051, v353);
      swift_release(v349);
      swift_release(v350);
      uint64_t v354 = v1052.i64[1];
      if (!v1052.i64[1]) {
        goto LABEL_181;
      }
      __int8 v355 = v1052.i8[0];
      unint64_t v356 = (unint64_t)v1052.i64[0] >> 8;
      unint64_t v357 = (unint64_t)v1052.i64[0] >> 16;
      unint64_t v358 = (unint64_t)v1052.i64[0] >> 24;
      uint64_t v359 = sub_100002274(&qword_100405E00);
      uint64_t v360 = type metadata accessor for DriverEvent(0LL);
      uint64_t v361 = *(void *)(v360 - 8);
      uint64_t v362 = *(void *)(v361 + 72);
      uint64_t v363 = *(unsigned __int8 *)(v361 + 80);
      uint64_t v364 = (v363 + 32) & ~v363;
      uint64_t v220 = swift_allocObject(v359, v364 + v362, v363 | 7);
      *(_OWORD *)(v220 + 16) = xmmword_100339900;
      uint64x2_t v365 = (uint64x2_t)vdupq_lane_s64(v1051.i64[0], 0);
      v1055[0].i8[0] = v1051.i8[0];
      *(int8x8_t *)&v1055[0].i8[1] = vmovn_s16( vuzp1q_s16( (int16x8_t)vuzp1q_s32( (int32x4_t)vshlq_u64(v365, (uint64x2_t)xmmword_10033A8F0),  (int32x4_t)vshlq_u64(v365, (uint64x2_t)xmmword_10033A8E0)),  (int16x8_t)vuzp1q_s32( (int32x4_t)vshlq_u64(v365, (uint64x2_t)xmmword_10033A920),  (int32x4_t)vshlq_u64(v1051, (uint64x2_t)xmmword_10033A910))));
      v1055[0].i8[9] = v1051.i8[15];
      v1055[0].i8[10] = v355;
      v1055[0].i8[11] = v356;
      v1055[0].i8[12] = v357;
      v1055[0].i8[13] = v358;
      *(__int32 *)((char *)&v1055[0].i32[3] + 2) = v1051.i32[2];
      v1055[1].i16[1] = v1051.i16[6];
      v1055[1].i64[1] = v354;
      sub_100058738((uint64_t)v1055);
      sub_100058090(v1055, (void *)(v220 + v364));
      uint64_t v330 = v220 + v364;
      uint64_t v331 = v360;
LABEL_79:
      uint64_t v366 = 0LL;
      goto LABEL_80;
    case 0x72uLL:
      v369 = (uint64_t *)swift_getKeyPath(&unk_10033E908);
      v370 = (void *)swift_getKeyPath(&unk_10033E928);
      unint64_t v45 = v776;
      uint64_t v44 = v777;
      sub_100020AFC(v777, v776);
      uint64_t v371 = sub_100002274(&qword_100405E78);
      unint64_t v372 = sub_1000A9B84();
      unint64_t v373 = sub_1000A9B40();
      sub_1000A0F14(v369, v370, v44, v45, v371, v372, (uint64_t)v1055, v373);
      swift_release(v369);
      swift_release(v370);
      uint64_t v374 = v1055[1].i64[0];
      if (!v1055[1].i64[0]) {
        goto LABEL_181;
      }
      uint64_t v375 = type metadata accessor for DriverEvent(0LL);
      int8x16_t v772 = (int8x16_t)v1055[0];
      uint64x2_t v376 = (uint64x2_t)vdupq_laneq_s64(v1055[0], 1);
      unsigned __int32 v377 = v1055[0].i32[0];
      __int8 v378 = v1055[0].i8[1];
      unint64_t v379 = (unint64_t)v1055[0].i64[0] >> 40;
      v773 = (char *)v1055[0].u16[3];
      unint64_t v774 = v1055[0].u8[7];
      unint64_t v775 = (unint64_t)v1055[0].u64 + 2;
      uint64_t v380 = (uint64_t)vmovn_s16( vuzp1q_s16( (int16x8_t)vuzp1q_s32( (int32x4_t)vshlq_u64(v376, (uint64x2_t)xmmword_10033A8F0),  (int32x4_t)vshlq_u64(v376, (uint64x2_t)xmmword_10033A8E0)),  (int16x8_t)vuzp1q_s32( (int32x4_t)vshlq_u64( (uint64x2_t)vextq_s8(v772, v772, 8uLL),  (uint64x2_t)xmmword_10033A900),  (int32x4_t)vshlq_u64( (uint64x2_t)vdupq_lane_s64(v1055[0].i64[0], 0),  (uint64x2_t)xmmword_10033A8E0))));
      uint64_t v381 = sub_100002274(&qword_100405E00);
      uint64_t v382 = *(void *)(v375 - 8);
      uint64_t v383 = *(void *)(v382 + 72);
      uint64_t v384 = *(unsigned __int8 *)(v382 + 80);
      uint64_t v385 = (v384 + 32) & ~v384;
      uint64_t v291 = swift_allocObject(v381, v385 + v383, v384 | 7);
      *(_OWORD *)(v291 + 16) = xmmword_100339900;
      v386 = (void *)(v291 + v385);
      v1055[0].i8[0] = v377;
      *(_BYTE *)unint64_t v775 = v772.i8[8];
      if (((v377 >> 8) & 0xFE) != 0) {
        __int8 v387 = 2;
      }
      else {
        __int8 v387 = v378;
      }
      v1055[0].i8[1] = v387;
      *(uint64_t *)((char *)v1055[0].i64 + 3) = v380;
      v1055[0].i8[11] = v379;
      v1055[0].i8[12] = (char)v773;
      v1055[0].i8[13] = v774;
      v1055[1].i64[0] = v374;
      sub_10005872C((uint64_t)v1055);
      sub_100058090(v1055, v386);
      swift_storeEnumTagMultiPayload(v386, v375, 0LL);
      uint64_t v292 = v44;
LABEL_86:
      sub_1000208D8(v292, v776);
      return (void *)v291;
    case 0x75uLL:
      type metadata accessor for apple80211_nan_data_path_established_event_data(0LL);
      uint64_t v389 = v388;
      unint64_t v45 = v776;
      uint64_t v44 = v777;
      sub_100020AFC(v777, v776);
      sub_1000A163C(v389, v44, v45);
      sub_1000586C0((uint64_t)&v1034, (uint64_t)&v1051, &qword_100405E70);
      sub_1000586C0((uint64_t)&v1051, (uint64_t)v1055, &qword_100405E70);
      uint64_t v390 = sub_100002274(&qword_100405E00);
      uint64_t v391 = type metadata accessor for DriverEvent(0LL);
      uint64_t v392 = *(void *)(v391 - 8);
      uint64_t v393 = *(void *)(v392 + 72);
      uint64_t v394 = *(unsigned __int8 *)(v392 + 80);
      uint64_t v395 = (v394 + 32) & ~v394;
      uint64_t v52 = swift_allocObject(v390, v395 + v393, v394 | 7);
      *(_OWORD *)(v52 + 16) = xmmword_100339900;
      LOBYTE(v1034) = v1055[0].i8[1];
      *(_DWORD *)((char *)&v1034 + 1) = *(__int32 *)((char *)v1055[0].i32 + 3);
      *(_WORD *)((char *)&v1034 + 5) = *(__int16 *)((char *)&v1055[0].i16[3] + 1);
      BYTE7(v1034) = v1055[0].u8[0] == 1;
      DWORD2(v1034) = *(__int32 *)((char *)&v1055[0].i32[2] + 1);
      WORD6(v1034) = *(__int16 *)((char *)&v1055[0].i16[6] + 1);
      sub_100058720((uint64_t)&v1034);
      sub_100058090(&v1034, (void *)(v52 + v395));
      uint64_t v396 = v52 + v395;
      uint64_t v397 = v391;
LABEL_207:
      uint64_t v440 = 0LL;
      goto LABEL_208;
    case 0x76uLL:
      type metadata accessor for apple80211_nan_data_path_end_event_data(0LL);
      uint64_t v399 = v398;
      unint64_t v45 = v776;
      uint64_t v44 = v777;
      sub_100020AFC(v777, v776);
      sub_1000A163C(v399, v44, v45);
      if ((v1052.i8[12] & 1) != 0) {
        goto LABEL_181;
      }
      uint64_t v400 = v1051.i64[1];
      uint64_t v401 = v1051.i64[0];
      unint64_t v402 = HIDWORD(v1051.i64[0]);
      uint64_t v403 = sub_100002274(&qword_100405E00);
      uint64_t v404 = type metadata accessor for DriverEvent(0LL);
      uint64_t v405 = *(void *)(v404 - 8);
      uint64_t v406 = *(void *)(v405 + 72);
      uint64_t v407 = *(unsigned __int8 *)(v405 + 80);
      uint64_t v408 = (v407 + 32) & ~v407;
      uint64_t v409 = swift_allocObject(v403, v408 + v406, v407 | 7);
      *(_OWORD *)(v409 + 16) = xmmword_100339900;
      v410 = (void *)(v409 + v408);
      uint64_t v411 = v409;
      else {
        uint64_t v412 = qword_10033F110[v401 >> 32];
      }
      uint64_t v704 = v777;
      v1055[0].i8[0] = v401;
      *(__int16 *)((char *)v1055[0].i16 + 1) = v400;
      v1055[0].i8[3] = BYTE2(v400);
      v1055[0].i8[4] = BYTE3(v400);
      v1055[0].i8[5] = BYTE4(v400);
      v1055[0].i16[3] = BYTE5(v400);
      v1055[0].i64[1] = v412;
      sub_1000586B4((uint64_t)v1055);
      sub_100058090(v1055, v410);
      swift_storeEnumTagMultiPayload(v410, v404, 0LL);
      sub_1000208D8(v704, v45);
      return (void *)v411;
    case 0x7AuLL:
      type metadata accessor for apple80211_nan_dw_start_event_data(0LL);
      uint64_t v414 = v413;
      unint64_t v45 = v776;
      uint64_t v44 = v777;
      sub_100020AFC(v777, v776);
      sub_1000A163C(v414, v44, v45);
      if ((v1055[4].i8[8] & 1) != 0) {
        goto LABEL_181;
      }
      __int32 v415 = v1055[4].i32[0];
      uint64_t v416 = v1055[3].i64[1];
      uint64_t v417 = v1055[3].i64[0];
      uint64_t v418 = sub_100002274(&qword_100405E00);
      uint64_t v419 = type metadata accessor for DriverEvent(0LL);
      uint64_t v420 = *(void *)(v419 - 8);
      uint64_t v421 = *(void *)(v420 + 72);
      uint64_t v422 = *(unsigned __int8 *)(v420 + 80);
      uint64_t v423 = (v422 + 32) & ~v422;
      uint64_t v424 = swift_allocObject(v418, v423 + v421, v422 | 7);
      uint64_t v425 = HIWORD(v415);
      *(_OWORD *)(v424 + 16) = xmmword_100339900;
      uint64_t v220 = v424;
      v426 = (void *)(v424 + v423);
      uint64_t v427 = __ROR8__(v417, 32);
      uint64_t v428 = __ROR8__(v416, 32);
      unint64_t v429 = sub_1001889D8((unsigned __int16)v415);
      if ((v429 & 0xFF00000000LL) == 0x300000000LL)
      {
        if (qword_1004043A0 != -1) {
          swift_once(&qword_1004043A0, sub_100186540);
        }
        LODWORD(v429) = static Channel.nanPrimary;
        LOBYTE(v430) = byte_1004108A4;
        LOBYTE(v431) = byte_1004108A5;
        uint64_t v432 = v777;
      }

      else
      {
        unint64_t v430 = HIDWORD(v429);
        unint64_t v431 = v429 >> 40;
        uint64_t v432 = v777;
      }

      v1055[0].i64[0] = v425;
      v1055[0].i64[1] = v427;
      v1055[1].i64[0] = v428;
      v1055[1].i32[2] = v429;
      v1055[1].i8[12] = v430;
      v1055[1].i8[13] = v431;
      sub_1000580E4((uint64_t)v1055);
      sub_100058090(v1055, v426);
      swift_storeEnumTagMultiPayload(v426, v419, 0LL);
      uint64_t v367 = v432;
      goto LABEL_196;
    case 0x7DuLL:
      type metadata accessor for apple80211_infra_scan_start_event_data(0LL);
      uint64_t v434 = v433;
      unint64_t v45 = v776;
      uint64_t v44 = v777;
      sub_100020AFC(v777, v776);
      sub_1000A163C(v434, v44, v45);
      sub_1000586C0((uint64_t)&v1034, (uint64_t)&v1051, &qword_100405E08);
      sub_1000586C0((uint64_t)&v1051, (uint64_t)v1055, &qword_100405E08);
      memcpy(v1179, v1055, 0x193uLL);
      uint64_t v435 = sub_100002274(&qword_100405E00);
      uint64_t v47 = type metadata accessor for DriverEvent(0LL);
      uint64_t v436 = *(void *)(v47 - 8);
      uint64_t v437 = *(void *)(v436 + 72);
      uint64_t v438 = *(unsigned __int8 *)(v436 + 80);
      uint64_t v439 = (v438 + 32) & ~v438;
      uint64_t v52 = swift_allocObject(v435, v439 + v437, v438 | 7);
      *(_OWORD *)(v52 + 16) = xmmword_100339900;
      uint64_t v53 = v52 + v439;
      *(void *)uint64_t v53 = sub_1000A24E8();
      *(_OWORD *)(v53 + 8) = 0u;
      *(_OWORD *)(v53 + 24) = 0u;
      __int16 v57 = 256;
LABEL_99:
      *(_WORD *)(v53 + 40) = v57;
      uint64_t v396 = v53;
      uint64_t v397 = v47;
      uint64_t v440 = 2LL;
      goto LABEL_208;
    case 0x7EuLL:
      type metadata accessor for apple80211_infra_scan_complete_event_data(0LL);
      uint64_t v442 = v441;
      unint64_t v45 = v776;
      uint64_t v44 = v777;
      sub_100020AFC(v777, v776);
      sub_1000A163C(v442, v44, v45);
      if ((v1055[0].i8[2] & 1) != 0) {
        goto LABEL_181;
      }
      uint64_t v443 = v1055[0].u8[0];
      uint64_t v444 = sub_100002274(&qword_100405E00);
      uint64_t v445 = type metadata accessor for DriverEvent(0LL);
      uint64_t v446 = *(void *)(v445 - 8);
      uint64_t v447 = *(void *)(v446 + 72);
      uint64_t v448 = *(unsigned __int8 *)(v446 + 80);
      uint64_t v449 = (v448 + 32) & ~v448;
      uint64_t v102 = swift_allocObject(v444, v449 + v447, v448 | 7);
      *(_OWORD *)(v102 + 16) = xmmword_100339900;
      uint64_t v103 = v102 + v449;
      *(void *)uint64_t v103 = v443;
      *(_OWORD *)(v103 + 8) = 0u;
      *(_OWORD *)(v103 + 24) = 0u;
      *(_BYTE *)(v103 + 40) = 0;
      char v450 = 2;
      goto LABEL_170;
    case 0x7FuLL:
      type metadata accessor for apple80211_nan_infra_assoc_start_event_data(0LL);
      uint64_t v452 = v451;
      unint64_t v45 = v776;
      uint64_t v44 = v777;
      sub_100020AFC(v777, v776);
      sub_1000A163C(v452, v44, v45);
      if ((v1055[0].i8[12] & 1) != 0) {
        goto LABEL_181;
      }
      unint64_t v453 = sub_1000A810C(v1055[0].u32[1], v1055[0].u32[2]);
      uint64_t v107 = v773;
      if ((v453 & 0xFF00000000LL) == 0x300000000LL) {
        goto LABEL_182;
      }
      unint64_t v454 = v453;
      uint64_t v455 = sub_100002274(&qword_100405E00);
      uint64_t v456 = type metadata accessor for DriverEvent(0LL);
      uint64_t v457 = *(void *)(v456 - 8);
      uint64_t v458 = *(void *)(v457 + 72);
      uint64_t v459 = *(unsigned __int8 *)(v457 + 80);
      uint64_t v460 = (v459 + 32) & ~v459;
      uint64_t v461 = swift_allocObject(v455, v460 + v458, v459 | 7);
      *(_OWORD *)(v461 + 16) = xmmword_100339900;
      uint64_t v462 = v461 + v460;
      *(void *)uint64_t v462 = v454 & 0xFFFFFFFFFFFFLL;
      *(_OWORD *)(v462 + 24) = 0u;
      *(_OWORD *)(v462 + 8) = 0u;
      *(_BYTE *)(v462 + 40) = 0;
      *(_BYTE *)(v462 + 41) = 3;
      swift_storeEnumTagMultiPayload(v461 + v460, v456, 2LL);
      sub_1000208D8(v44, v45);
      return (void *)v461;
    case 0x81uLL:
      type metadata accessor for apple80211_nan_dp_host_assist_event_data(0LL);
      uint64_t v464 = v463;
      unint64_t v45 = v776;
      uint64_t v44 = v777;
      sub_100020AFC(v777, v776);
      sub_1000A163C(v464, v44, v45);
      if ((v1052.i8[4] & 1) != 0) {
        goto LABEL_181;
      }
      uint64_t v465 = v1051.i64[1];
      unsigned __int16 v466 = v1051.i16[0];
      uint64_t v467 = sub_100002274(&qword_100405E00);
      uint64_t v214 = type metadata accessor for DriverEvent(0LL);
      uint64_t v468 = *(void *)(v214 - 8);
      uint64_t v469 = *(void *)(v468 + 72);
      uint64_t v470 = *(unsigned __int8 *)(v468 + 80);
      uint64_t v218 = v44;
      uint64_t v471 = (v470 + 32) & ~v470;
      uint64_t v220 = swift_allocObject(v467, v471 + v469, v470 | 7);
      *(_OWORD *)(v220 + 16) = xmmword_100339900;
      v221 = (void *)(v220 + v471);
      v1055[0].i64[0] = sub_1000A171C(v466, v465);
      v1055[0].i16[4] = v472;
      v1055[0].i8[10] = v473;
      v1055[0].i8[11] = v474;
      v1055[0].i8[12] = v475;
      v1055[0].i8[13] = v476;
      v1055[0].i8[14] = v477;
      v1055[0].i8[15] = v478;
      sub_1000586A8((uint64_t)v1055);
LABEL_107:
      sub_100058090(v1055, v221);
      uint64_t v257 = (uint64_t)v221;
LABEL_108:
      uint64_t v479 = v214;
      uint64_t v480 = 0LL;
      goto LABEL_195;
    case 0x8EuLL:
      type metadata accessor for apple80211_awdl_low_latency_statistics_reduced(0LL);
      uint64_t v482 = v481;
      uint64_t v483 = v776;
      uint64_t v484 = v777;
      sub_100020AFC(v777, v776);
      sub_1000A163C(v482, v484, v483);
      sub_1000586C0((uint64_t)v1179, (uint64_t)&v1034, &qword_100405E50);
      sub_1000586C0((uint64_t)&v1034, (uint64_t)&v1051, &qword_100405E50);
      if (sub_100057FCC((uint64_t)&v1051) == 1)
      {
        (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v19 + 56))(v17, 1LL, 1LL, v18);
      }

      else
      {
        sub_1000586C0((uint64_t)&v1034, (uint64_t)v1178, &qword_100405E50);
        memcpy(v1055, v1178, 0x650uLL);
        sub_1000A1B34((uint64_t)v1055, (uint64_t)v17);
      }

      uint64_t v107 = v773;
      if ((*(unsigned int (**)(char *, uint64_t, uint64_t))(v19 + 48))(v17, 1LL, v18) == 1)
      {
        sub_1000225EC((uint64_t)v17, &qword_100405DF8);
        unint64_t v45 = v776;
        uint64_t v44 = v777;
        goto LABEL_182;
      }

      sub_100022628((uint64_t)v17, (uint64_t)v21, type metadata accessor for AWDLStatistics.LowLatencyStatistics);
      uint64_t v696 = sub_100002274(&qword_100405E00);
      uint64_t v697 = type metadata accessor for DriverEvent(0LL);
      uint64_t v698 = *(void *)(v697 - 8);
      uint64_t v699 = *(void *)(v698 + 72);
      uint64_t v700 = *(unsigned __int8 *)(v698 + 80);
      uint64_t v701 = (v700 + 32) & ~v700;
      uint64_t v702 = swift_allocObject(v696, v701 + v699, v700 | 7);
      *(_OWORD *)(v702 + 16) = xmmword_100339900;
      sub_100057FE8((uint64_t)v21, v702 + v701, type metadata accessor for AWDLStatistics.LowLatencyStatistics);
      uint64_t v703 = type metadata accessor for DriverEvent.AWDL(0LL);
      swift_storeEnumTagMultiPayload(v702 + v701, v703, 3LL);
      swift_storeEnumTagMultiPayload(v702 + v701, v697, 1LL);
      sub_1000208D8(v777, v776);
      sub_10005802C((uint64_t)v21, type metadata accessor for AWDLStatistics.LowLatencyStatistics);
      return (void *)v702;
    case 0x95uLL:
      type metadata accessor for apple80211_p2p_airplay_statistics(0LL);
      uint64_t v486 = v485;
      unint64_t v45 = v776;
      uint64_t v44 = v777;
      sub_100020AFC(v777, v776);
      sub_1000A163C(v486, v44, v45);
      sub_1000586C0((uint64_t)v1179, (uint64_t)&v1034, &qword_100405E40);
      sub_1000586C0((uint64_t)&v1034, (uint64_t)&v1051, &qword_100405E40);
      sub_1000586C0((uint64_t)&v1034, (uint64_t)v1178, &qword_100405E40);
      v1055[10] = (int64x2_t)v1178[10];
      v1055[11] = (int64x2_t)v1178[11];
      v1055[12] = (int64x2_t)v1178[12];
      v1055[6] = (int64x2_t)v1178[6];
      v1055[7] = (int64x2_t)v1178[7];
      v1055[8] = (int64x2_t)v1178[8];
      v1055[9] = (int64x2_t)v1178[9];
      v1055[2] = (int64x2_t)v1178[2];
      v1055[3] = (int64x2_t)v1178[3];
      v1055[4] = (int64x2_t)v1178[4];
      v1055[5] = (int64x2_t)v1178[5];
      v1055[0] = (int64x2_t)v1178[0];
      v1055[1] = (int64x2_t)v1178[1];
      sub_1000A9378((uint64_t)v1055, (uint64_t)v1180);
      sub_1000586C0((uint64_t)v1180, (uint64_t)&v1181, &qword_100405E48);
      uint64_t v107 = v773;
      if (!(void)v1185) {
        goto LABEL_182;
      }
      uint64_t v487 = sub_100002274(&qword_100405E00);
      uint64_t v488 = type metadata accessor for DriverEvent(0LL);
      uint64_t v489 = *(void *)(v488 - 8);
      uint64_t v490 = *(void *)(v489 + 72);
      uint64_t v491 = *(unsigned __int8 *)(v489 + 80);
      uint64_t v492 = (v491 + 32) & ~v491;
      uint64_t v52 = swift_allocObject(v487, v492 + v490, v491 | 7);
      *(_OWORD *)(v52 + 16) = xmmword_100339900;
      v493 = (_OWORD *)(v52 + v492);
      __int128 v494 = *(_OWORD *)v1182;
      _OWORD *v493 = v1181;
      v493[1] = v494;
      __int128 v495 = v1186;
      __int128 v496 = v1184;
      v493[5] = v1185;
      v493[6] = v495;
      __int128 v497 = v1183;
      v493[2] = *(_OWORD *)&v1182[16];
      v493[3] = v497;
      v493[4] = v496;
      uint64_t v498 = type metadata accessor for DriverEvent.AWDL(0LL);
      swift_storeEnumTagMultiPayload(v52 + v492, v498, 2LL);
      uint64_t v396 = v52 + v492;
      uint64_t v397 = v488;
      uint64_t v440 = 1LL;
LABEL_208:
      swift_storeEnumTagMultiPayload(v396, v397, v440);
      uint64_t v91 = v44;
      unint64_t v92 = v45;
LABEL_209:
      sub_1000208D8(v91, v92);
      return (void *)v52;
    case 0x9DuLL:
      type metadata accessor for apple80211_nan_low_latency_peer_statistics(0LL);
      uint64_t v500 = v499;
      unint64_t v45 = v776;
      uint64_t v44 = v777;
      sub_100020AFC(v777, v776);
      sub_1000A163C(v500, v44, v45);
      sub_1000586C0((uint64_t)&v1034, (uint64_t)&v1051, &qword_100405E58);
      sub_1000586C0((uint64_t)&v1051, (uint64_t)v1055, &qword_100405E58);
      v772.i64[0] = (uint64_t)v1168;
      v740 = v1150;
      v733 = v1114;
      v734 = v1132;
      v731 = (__int128 *)v1093;
      v728 = (__int128 *)v1097;
      v729 = v1075;
      v726 = v1057;
      uint64_t v501 = sub_100002274(&qword_100405E00);
      unint64_t v774 = type metadata accessor for DriverEvent(0LL);
      uint64_t v502 = *(void *)(v774 - 8);
      uint64_t v503 = *(void *)(v502 + 72);
      uint64_t v504 = *(unsigned __int8 *)(v502 + 80);
      uint64_t v505 = (v504 + 32) & ~v504;
      uint64_t v506 = swift_allocObject(v501, v505 + v503, v504 | 7);
      unint64_t v775 = v506;
      *(_OWORD *)(v506 + 16) = xmmword_100339900;
      v773 = (char *)(v506 + v505);
      LODWORD(v763) = v1055[0].i32[0];
      LODWORD(v762) = v1055[0].u8[4];
      LODWORD(v761) = v1055[0].u8[5];
      LODWORD(v760) = v1055[0].u8[6];
      LODWORD(v759) = v1055[1].u8[0];
      LODWORD(v758) = v1055[1].u8[1];
      LODWORD(v757) = v1055[1].u8[2];
      int v755 = v1055[2].u8[5];
      LODWORD(v756) = v1055[2].u8[4];
      __int32 v753 = v1055[3].i32[0];
      int v754 = v1055[2].u8[6];
      uint64_t v751 = v1055[4].i64[0];
      uint64_t v752 = v1055[3].i64[1];
      uint64_t v749 = v1055[5].i64[0];
      uint64_t v750 = v1055[4].i64[1];
      uint64_t v747 = v1055[6].i64[0];
      uint64_t v748 = v1055[5].i64[1];
      unint64_t v770 = v1055[7].u64[0];
      unint64_t v771 = v1055[6].u64[1];
      unint64_t v768 = v1055[8].u64[0];
      unint64_t v769 = v1055[7].u64[1];
      unint64_t v766 = v1055[9].u64[0];
      unint64_t v767 = v1055[8].u64[1];
      unint64_t v764 = v1055[10].u64[0];
      unint64_t v765 = v1055[9].u64[1];
      uint64_t v1015 = v1055[18].i64[0];
      uint64_t v1017 = v1055[19].i64[1];
      uint64_t v1019 = v1055[21].i64[0];
      uint64_t v1021 = v1055[22].i64[1];
      uint64_t v1023 = v1055[24].i64[0];
      uint64_t v1025 = v1055[25].i64[1];
      uint64_t v1027 = v1055[27].i64[0];
      uint64_t v1029 = v1055[28].i64[1];
      uint64_t v745 = v1055[10].i64[1];
      uint64_t v746 = v1055[11].i64[0];
      __int128 v1016 = *(__int128 *)((char *)&v1055[18] + 8);
      int64x2_t v1018 = v1055[20];
      __int128 v1020 = *(__int128 *)((char *)&v1055[21] + 8);
      int64x2_t v1022 = v1055[23];
      __int128 v1024 = *(__int128 *)((char *)&v1055[24] + 8);
      int64x2_t v1026 = v1055[26];
      __int128 v1028 = *(__int128 *)((char *)&v1055[27] + 8);
      int64x2_t v1030 = v1055[29];
      __int128 v1032 = *(__int128 *)((char *)&v1055[30] + 8);
      uint64_t v1031 = v1055[30].i64[0];
      uint64_t v1033 = v1055[31].i64[1];
      uint64_t v507 = v1055[12].i64[0];
      int64x2_t v1014 = v1055[17];
      uint64_t v508 = v1055[0].i64[1];
      uint64_t v509 = *(uint64_t *)((char *)v1055[1].i64 + 4);
      uint64_t v510 = v1055[2].i64[1];
      uint64_t v743 = v1055[16].i64[1];
      uint64_t v744 = v1055[11].i64[1];
      uint64_t v739 = v1055[12].i64[1];
      uint64_t v741 = v1055[16].i64[0];
      uint64_t v742 = v1055[13].i64[1];
      __int32 v736 = v1055[2].i32[0];
      __int32 v737 = v1055[1].i32[3];
      v738 = sub_1000A4F60((uint64_t)&v1014);
      int64x2_t v994 = v1055[47];
      __int128 v996 = *(__int128 *)((char *)&v1055[48] + 8);
      uint64_t v995 = v1055[48].i64[0];
      uint64_t v997 = v1055[49].i64[1];
      int64x2_t v998 = v1055[50];
      __int128 v1000 = *(__int128 *)((char *)&v1055[51] + 8);
      uint64_t v999 = v1055[51].i64[0];
      uint64_t v1001 = v1055[52].i64[1];
      int64x2_t v1002 = v1055[53];
      __int128 v1004 = *(__int128 *)((char *)&v1055[54] + 8);
      uint64_t v1003 = v1055[54].i64[0];
      uint64_t v1005 = v1055[55].i64[1];
      int64x2_t v1006 = v1055[56];
      __int128 v1008 = *(__int128 *)((char *)&v1055[57] + 8);
      uint64_t v1007 = v1055[57].i64[0];
      uint64_t v1009 = v1055[58].i64[1];
      int64x2_t v1010 = v1055[59];
      __int128 v1012 = *(__int128 *)((char *)&v1055[60] + 8);
      uint64_t v1011 = v1055[60].i64[0];
      uint64_t v1013 = v1055[61].i64[1];
      v735 = sub_1000A4F60((uint64_t)&v994);
      int64x2_t v974 = v1055[62];
      __int128 v976 = *(__int128 *)((char *)&v1055[63] + 8);
      uint64_t v975 = v1055[63].i64[0];
      uint64_t v977 = v1055[64].i64[1];
      int64x2_t v978 = v1055[65];
      __int128 v980 = *(__int128 *)((char *)&v1055[66] + 8);
      uint64_t v979 = v1055[66].i64[0];
      uint64_t v981 = v1055[67].i64[1];
      int64x2_t v982 = v1055[68];
      __int128 v984 = *(__int128 *)((char *)&v1055[69] + 8);
      uint64_t v983 = v1055[69].i64[0];
      uint64_t v985 = v1055[70].i64[1];
      int64x2_t v986 = v1055[71];
      __int128 v988 = *(__int128 *)((char *)&v1055[72] + 8);
      uint64_t v987 = v1055[72].i64[0];
      uint64_t v989 = v1055[73].i64[1];
      int64x2_t v990 = v1055[74];
      __int128 v992 = *(__int128 *)((char *)&v1055[75] + 8);
      uint64_t v991 = v1055[75].i64[0];
      uint64_t v993 = v1055[76].i64[1];
      v511 = sub_1000A4F60((uint64_t)&v974);
      int64x2_t v954 = v1055[77];
      __int128 v956 = *(__int128 *)((char *)&v1055[78] + 8);
      uint64_t v955 = v1055[78].i64[0];
      uint64_t v957 = v1055[79].i64[1];
      int64x2_t v958 = v1055[80];
      __int128 v960 = *(__int128 *)((char *)&v1055[81] + 8);
      uint64_t v959 = v1055[81].i64[0];
      uint64_t v961 = v1055[82].i64[1];
      int64x2_t v962 = v1055[83];
      __int128 v964 = *(__int128 *)((char *)&v1055[84] + 8);
      uint64_t v963 = v1055[84].i64[0];
      uint64_t v965 = v1055[85].i64[1];
      int64x2_t v966 = v1055[86];
      __int128 v968 = *(__int128 *)((char *)&v1055[87] + 8);
      uint64_t v967 = v1055[87].i64[0];
      uint64_t v969 = v1055[88].i64[1];
      int64x2_t v970 = v1055[89];
      __int128 v972 = *(__int128 *)((char *)&v1055[90] + 8);
      uint64_t v971 = v1055[90].i64[0];
      uint64_t v973 = v1055[91].i64[1];
      v732 = sub_1000A4F60((uint64_t)&v954);
      int64x2_t v934 = v1055[92];
      __int128 v936 = *(__int128 *)((char *)&v1055[93] + 8);
      uint64_t v935 = v1055[93].i64[0];
      uint64_t v937 = v1055[94].i64[1];
      int64x2_t v938 = v1055[95];
      __int128 v940 = *(__int128 *)((char *)&v1055[96] + 8);
      uint64_t v939 = v1055[96].i64[0];
      uint64_t v941 = v1055[97].i64[1];
      int64x2_t v942 = v1055[98];
      __int128 v944 = *(__int128 *)((char *)&v1055[99] + 8);
      uint64_t v943 = v1055[99].i64[0];
      uint64_t v945 = v1055[100].i64[1];
      int64x2_t v946 = v1055[101];
      v512 = v726;
      __int128 v948 = *(_OWORD *)v726;
      uint64_t v947 = v1056;
      uint64_t v949 = v1057[2];
      __int128 v950 = v1058;
      __int128 v952 = *((_OWORD *)v726 + 3);
      uint64_t v951 = v1059;
      uint64_t v953 = v1060;
      v730 = sub_1000A4F60((uint64_t)&v934);
      __int128 v914 = *v728;
      __int128 v916 = v1098;
      uint64_t v915 = v1097[2];
      uint64_t v917 = v1099;
      __int128 v918 = v728[3];
      __int128 v920 = v1101;
      uint64_t v919 = v1100;
      uint64_t v921 = v1102;
      __int128 v922 = v728[6];
      __int128 v924 = v1104;
      uint64_t v923 = v1103;
      uint64_t v925 = v1105;
      __int128 v926 = v728[9];
      __int128 v928 = v1107;
      uint64_t v927 = v1106;
      uint64_t v929 = v1108;
      __int128 v930 = v728[12];
      __int128 v932 = v1110;
      uint64_t v931 = v1109;
      uint64_t v933 = v1111;
      v728 = (__int128 *)sub_1000A4F60((uint64_t)&v914);
      __int128 v902 = v1061;
      __int128 v904 = v512[6];
      uint64_t v903 = v1062;
      uint64_t v905 = v1063;
      __int128 v906 = v1064;
      __int128 v908 = v512[9];
      uint64_t v907 = v1065;
      uint64_t v909 = v1066;
      __int128 v910 = v1067;
      __int128 v912 = v512[12];
      uint64_t v911 = v1068;
      uint64_t v913 = v1069;
      v727 = sub_1000A50E4(&v902);
      __int128 v884 = v1070;
      __int128 v886 = v512[15];
      uint64_t v885 = v1071;
      uint64_t v887 = v1072;
      __int128 v888 = v1073;
      __int128 v890 = *v729;
      uint64_t v889 = v1074;
      uint64_t v891 = v1075[2];
      __int128 v892 = v1076;
      __int128 v894 = v729[3];
      uint64_t v893 = v1077;
      uint64_t v895 = v1078;
      __int128 v896 = v1079;
      v513 = v729;
      __int128 v898 = v729[6];
      uint64_t v897 = v1080;
      uint64_t v899 = v1081;
      __int128 v900 = v1082;
      uint64_t v901 = v1083;
      v726 = sub_1000A5320((uint64_t)&v884);
      __int128 v866 = v513[9];
      __int128 v868 = v1085;
      uint64_t v867 = v1084;
      uint64_t v869 = v1086;
      __int128 v870 = v513[12];
      __int128 v872 = v1088;
      uint64_t v871 = v1087;
      uint64_t v873 = v1089;
      __int128 v874 = v513[15];
      __int128 v876 = v1091;
      uint64_t v875 = v1090;
      uint64_t v877 = v1092;
      __int128 v878 = *v731;
      __int128 v880 = v1094;
      uint64_t v879 = v1093[2];
      uint64_t v881 = v1095;
      __int128 v882 = v731[3];
      uint64_t v883 = v1096;
      v514 = sub_1000A5320((uint64_t)&v866);
      __int128 v846 = v1112;
      __int128 v848 = *v733;
      uint64_t v847 = v1113;
      uint64_t v849 = v1114[2];
      __int128 v850 = v1115;
      __int128 v852 = v733[3];
      uint64_t v851 = v1116;
      uint64_t v853 = v1117;
      __int128 v854 = v1118;
      __int128 v856 = v733[6];
      uint64_t v855 = v1119;
      uint64_t v857 = v1120;
      __int128 v858 = v1121;
      __int128 v860 = v733[9];
      uint64_t v859 = v1122;
      uint64_t v861 = v1123;
      __int128 v862 = v1124;
      v515 = v733;
      __int128 v864 = v733[12];
      uint64_t v863 = v1125;
      uint64_t v865 = v1126;
      v516 = sub_1000A4F60((uint64_t)&v846);
      __int128 v826 = v1127;
      __int128 v828 = v515[15];
      uint64_t v827 = v1128;
      uint64_t v829 = v1129;
      __int128 v830 = v1130;
      __int128 v832 = *v734;
      uint64_t v831 = v1131;
      uint64_t v833 = v1132[2];
      __int128 v834 = v1133;
      __int128 v836 = v734[3];
      uint64_t v835 = v1134;
      uint64_t v837 = v1135;
      __int128 v838 = v1136;
      __int128 v840 = v734[6];
      uint64_t v839 = v1137;
      uint64_t v841 = v1138;
      __int128 v842 = v1139;
      v517 = v734;
      __int128 v844 = v734[9];
      uint64_t v843 = v1140;
      uint64_t v845 = v1141;
      v518 = sub_1000A4F60((uint64_t)&v826);
      __int128 v806 = v1142;
      __int128 v808 = v517[12];
      uint64_t v807 = v1143;
      uint64_t v809 = v1144;
      __int128 v810 = v1145;
      __int128 v812 = v517[15];
      uint64_t v811 = v1146;
      uint64_t v813 = v1147;
      __int128 v814 = v1148;
      __int128 v816 = *v740;
      uint64_t v815 = v1149;
      uint64_t v817 = v1150[2];
      __int128 v818 = v1151;
      __int128 v820 = v740[3];
      uint64_t v819 = v1152;
      uint64_t v821 = v1153;
      __int128 v822 = v1154;
      v519 = v740;
      __int128 v824 = v740[6];
      uint64_t v823 = v1155;
      uint64_t v825 = v1156;
      v520 = sub_1000A4F60((uint64_t)&v806);
      __int128 v786 = v1157;
      __int128 v788 = v519[9];
      uint64_t v787 = v1158;
      uint64_t v789 = v1159;
      __int128 v790 = v1160;
      __int128 v792 = v519[12];
      uint64_t v791 = v1161;
      uint64_t v793 = v1162;
      __int128 v794 = v1163;
      __int128 v796 = v519[15];
      uint64_t v795 = v1164;
      uint64_t v797 = v1165;
      __int128 v798 = v1166;
      __int128 v800 = *(_OWORD *)v772.i64[0];
      uint64_t v799 = v1167;
      uint64_t v801 = v1168[2];
      __int128 v802 = v1169;
      uint64_t v521 = v772.i64[0];
      __int128 v804 = *(_OWORD *)(v772.i64[0] + 48);
      uint64_t v803 = v1170;
      uint64_t v805 = v1171;
      v522 = sub_1000A4F60((uint64_t)&v786);
      __int128 v778 = v1172;
      uint64_t v779 = v1173;
      __int128 v780 = *(_OWORD *)(v521 + 96);
      uint64_t v781 = v1174;
      __int128 v782 = v1175;
      uint64_t v783 = v1176;
      __int128 v784 = *(_OWORD *)(v521 + 144);
      uint64_t v785 = v1177;
      v523 = sub_1000A5494(&v778);
      LODWORD(v1179[0]) = v763;
      BYTE4(v1179[0]) = v762;
      BYTE5(v1179[0]) = v761;
      BYTE6(v1179[0]) = v760;
      LOBYTE(v1179[2]) = v759;
      BYTE1(v1179[2]) = v758;
      WORD1(v1179[2]) = v757;
      HIDWORD(v1179[3]) = v737;
      LODWORD(v1179[4]) = v736;
      BYTE4(v1179[4]) = v756;
      BYTE5(v1179[4]) = v755;
      BYTE6(v1179[4]) = v754;
      LODWORD(v1179[6]) = v753;
      v1179[7] = v752;
      v1179[8] = v751;
      v1179[9] = v750;
      v1179[10] = v749;
      v1179[11] = v748;
      v1179[12] = v747;
      *(uint64_t *)((char *)&v1179[2] + 4) = v509;
      v1179[1] = v508;
      v1179[5] = v510;
      v1179[13] = v771;
      v1179[14] = v770;
      v1179[15] = v769;
      v1179[16] = v768;
      v1179[17] = v767;
      v1179[18] = v766;
      v1179[19] = v765;
      v1179[20] = v764;
      v1179[21] = v745;
      v1179[22] = v746;
      v1179[23] = v744;
      v1179[24] = v507;
      v1179[25] = v739;
      v1179[26] = v741;
      v1179[27] = v743;
      v1179[28] = v742;
      v1179[29] = (uint64_t)v738;
      v1179[30] = (uint64_t)v735;
      v1179[31] = (uint64_t)v511;
      v1179[32] = (uint64_t)v732;
      v1179[33] = (uint64_t)v730;
      v1179[34] = (uint64_t)v728;
      v1179[35] = (uint64_t)v727;
      v1179[36] = (uint64_t)v726;
      v1179[37] = (uint64_t)v514;
      v1179[38] = (uint64_t)v516;
      v1179[39] = (uint64_t)v518;
      v1179[40] = (uint64_t)v520;
      v1179[41] = (uint64_t)v522;
      v1179[42] = (uint64_t)v523;
      memset(&v1179[43], 0, 17);
      sub_100058084((uint64_t)v1179);
      v524 = (int64x2_t *)v1179;
      goto LABEL_193;
    case 0x9EuLL:
      type metadata accessor for apple80211_nan_oob_act_frm_tx_status(0LL);
      uint64_t v526 = v525;
      unint64_t v45 = v776;
      uint64_t v44 = v777;
      sub_100020AFC(v777, v776);
      sub_1000A163C(v526, v44, v45);
      if ((v1051.i8[10] & 1) != 0) {
        goto LABEL_181;
      }
      __int16 v527 = v1051.i16[0];
      unint64_t v528 = (unint64_t)v1051.i64[0] >> 16;
      __int16 v529 = v1051.i16[4];
      unsigned int v530 = HIWORD(v1051.i64[0]) | (v1051.u16[4] << 16);
      uint64_t v531 = sub_100002274(&qword_100405E00);
      uint64_t v532 = type metadata accessor for DriverEvent(0LL);
      uint64_t v533 = *(void *)(v532 - 8);
      uint64_t v534 = *(void *)(v533 + 72);
      uint64_t v535 = *(unsigned __int8 *)(v533 + 80);
      uint64_t v536 = (v535 + 32) & ~v535;
      uint64_t v220 = swift_allocObject(v531, v536 + v534, v535 | 7);
      *(_OWORD *)(v220 + 16) = xmmword_100339900;
      v1055[0].i16[0] = v527;
      *(uint64_t *)((char *)v1055[0].i64 + 2) = __PAIR64__(v530, v528);
      v1055[0].i32[0] = sub_1000A1804(v1055[0].u64[0], v529);
      sub_100058118((uint64_t)v1055);
      sub_100058090(v1055, (void *)(v220 + v536));
      swift_storeEnumTagMultiPayload(v220 + v536, v532, 0LL);
      uint64_t v367 = v777;
      goto LABEL_196;
    case 0x9FuLL:
      type metadata accessor for apple80211_nan_oob_act_frm_rx_data(0LL);
      uint64_t v538 = v537;
      unint64_t v45 = v776;
      uint64_t v44 = v777;
      sub_100020AFC(v777, v776);
      sub_1000A163C(v538, v44, v45);
      sub_1000586C0((uint64_t)&v1034, (uint64_t)&v1051, &qword_100405E60);
      sub_1000586C0((uint64_t)&v1051, (uint64_t)v1055, &qword_100405E60);
      memcpy(v1179, v1055, 0x3E1uLL);
      uint64_t v539 = sub_100002274(&qword_100405E00);
      uint64_t v540 = type metadata accessor for DriverEvent(0LL);
      uint64_t v541 = *(void *)(v540 - 8);
      uint64_t v542 = *(void *)(v541 + 72);
      uint64_t v543 = *(unsigned __int8 *)(v541 + 80);
      uint64_t v544 = (v543 + 32) & ~v543;
      uint64_t v206 = swift_allocObject(v539, v544 + v542, v543 | 7);
      *(_OWORD *)(v206 + 16) = xmmword_100339900;
      v545 = (void *)(v206 + v544);
      sub_1000A184C();
      *(void *)&v1178[0] = v1181;
      DWORD2(v1178[0]) = DWORD2(v1181);
      LOBYTE(v1178[1]) = v1182[0];
      *(_OWORD *)((char *)&v1178[1] + 8) = *(_OWORD *)&v1182[8];
      *((void *)&v1178[2] + 1) = *(void *)&v1182[24];
      sub_10005810C((uint64_t)v1178);
      sub_100058090(v1178, v545);
      v546 = v545;
      uint64_t v547 = v540;
LABEL_218:
      swift_storeEnumTagMultiPayload(v546, v547, 0LL);
      sub_1000208D8(v44, v45);
      return (void *)v206;
    case 0xACuLL:
      type metadata accessor for apple80211_hostap_state(0LL);
      uint64_t v549 = v548;
      unint64_t v45 = v776;
      uint64_t v44 = v777;
      sub_100020AFC(v777, v776);
      sub_1000A163C(v549, v44, v45);
      if ((v1055[1].i8[0] & 1) != 0) {
        goto LABEL_181;
      }
      unsigned int v550 = v1055[0].u16[4];
      uint64_t v551 = v1055[0].u32[1];
      uint64_t v552 = sub_100002274(&qword_100405E00);
      uint64_t v553 = type metadata accessor for DriverEvent(0LL);
      uint64_t v554 = *(void *)(v553 - 8);
      uint64_t v555 = *(void *)(v554 + 72);
      uint64_t v556 = *(unsigned __int8 *)(v554 + 80);
      uint64_t v557 = (v556 + 32) & ~v556;
      uint64_t v137 = swift_allocObject(v552, v557 + v555, v556 | 7);
      *(_OWORD *)(v137 + 16) = xmmword_100339900;
      uint64_t v558 = v137 + v557;
      unint64_t v559 = sub_1001889D8(v550);
      *(_BYTE *)uint64_t v558 = v551 != 0;
      *(_DWORD *)(v558 + 4) = v559;
      *(_WORD *)(v558 + 8) = WORD2(v559);
      uint64_t v560 = type metadata accessor for DriverEvent.AWDL(0LL);
      swift_storeEnumTagMultiPayload(v137 + v557, v560, 5LL);
      uint64_t v180 = v137 + v557;
      uint64_t v181 = v553;
      goto LABEL_167;
    case 0xB3uLL:
      type metadata accessor for apple80211_awdl_service_reg_soft_error_event(0LL);
      uint64_t v562 = v561;
      unint64_t v45 = v776;
      uint64_t v44 = v777;
      sub_100020AFC(v777, v776);
      sub_1000A163C(v562, v44, v45);
      sub_1000586C0((uint64_t)&v1034, (uint64_t)&v1051, &qword_100405E20);
      sub_1000586C0((uint64_t)&v1051, (uint64_t)v1055, &qword_100405E20);
      uint64_t v563 = v1055[0].u32[1];
      uint64_t v107 = v773;
      if (v1055[0].i32[1] > 0xFFu) {
        goto LABEL_182;
      }
      __int128 v1046 = *(__int128 *)((char *)&v1055[12] + 8);
      __int128 v1047 = *(__int128 *)((char *)&v1055[13] + 8);
      __int128 v1048 = *(__int128 *)((char *)&v1055[14] + 8);
      __int128 v1049 = *(__int128 *)((char *)&v1055[15] + 8);
      __int128 v1042 = *(__int128 *)((char *)&v1055[8] + 8);
      __int128 v1043 = *(__int128 *)((char *)&v1055[9] + 8);
      __int128 v1044 = *(__int128 *)((char *)&v1055[10] + 8);
      __int128 v1045 = *(__int128 *)((char *)&v1055[11] + 8);
      __int128 v1038 = *(__int128 *)((char *)&v1055[4] + 8);
      __int128 v1039 = *(__int128 *)((char *)&v1055[5] + 8);
      __int128 v1040 = *(__int128 *)((char *)&v1055[6] + 8);
      __int128 v1041 = *(__int128 *)((char *)&v1055[7] + 8);
      __int128 v1034 = *(__int128 *)((char *)v1055 + 8);
      __int128 v1035 = *(__int128 *)((char *)&v1055[1] + 8);
      __int128 v1036 = *(__int128 *)((char *)&v1055[2] + 8);
      __int128 v1037 = *(__int128 *)((char *)&v1055[3] + 8);
      uint64_t v564 = sub_100002274(&qword_100405E28);
      *((void *)&v1178[1] + 1) = v564;
      *(void *)&v1178[2] = sub_100057F44();
      v565 = (void *)swift_allocObject(&unk_1003E08D8, 48LL, 7LL);
      *(void *)&v1178[0] = v565;
      v565[2] = 0LL;
      v565[3] = v563;
      v565[4] = &v1034;
      v565[5] = &v1050;
      v566 = (__int128 *)sub_100021104(v1178, v564);
      __int128 v567 = v566[1];
      __int128 v1181 = *v566;
      *(_OWORD *)v1182 = v567;
      uint64_t v568 = v564;
      unint64_t v569 = v770;
      Slice<>.withUnsafeBytes<A>(_:)( v1180,  sub_1000FA8EC,  0LL,  v568,  &type metadata for Data._Representation,  &protocol witness table for UnsafeRawBufferPointer);
      uint64_t v570 = v1180[0];
      unint64_t v571 = v1180[1];
      sub_100002AC4(v1178);
      static DNSRecords.createRecord(with:value:)(v570, v571, 0LL, 0xF000000000000000LL);
      if (v569)
      {
        sub_1000208D8(v570, v571);
        swift_errorRelease(v569);
        unint64_t v770 = 0LL;
        uint64_t v44 = v777;
        goto LABEL_182;
      }

      sub_1000208D8(v570, v571);
      uint64_t v705 = sub_100002274(&qword_100404DB8);
      if (swift_dynamicCast(&v1034, v1179, v705, &type metadata for DNSRecords.Identifier, 0LL))
      {
        uint64_t v706 = *((void *)&v1034 + 1);
        uint64_t v707 = v1034;
        char v708 = v1035;
      }

      else if (swift_dynamicCast(&v1034, v1179, v705, &type metadata for DNSRecords.PTR, 0LL))
      {
        uint64_t v706 = *((void *)&v1035 + 1);
        uint64_t v707 = v1035;
        char v708 = v1036;
        swift_bridgeObjectRelease(*((void *)&v1034 + 1));
      }

      else if (swift_dynamicCast(v14, v1179, v705, v9, 0LL))
      {
        sub_100022628((uint64_t)v14, (uint64_t)v12, type metadata accessor for DNSRecords.SRV);
        uint64_t v707 = *((void *)v12 + 2);
        uint64_t v706 = *((void *)v12 + 3);
        char v708 = v12[32];
        swift_bridgeObjectRetain(v706);
        sub_10005802C((uint64_t)v12, type metadata accessor for DNSRecords.SRV);
      }

      else
      {
        unint64_t v770 = 0LL;
        if (!swift_dynamicCast(&v1034, v1179, v705, &type metadata for DNSRecords.TXT, 0LL))
        {
          sub_100002AC4(v1179);
          uint64_t v44 = v777;
          goto LABEL_182;
        }

        uint64_t v706 = *((void *)&v1035 + 1);
        uint64_t v707 = v1035;
        char v708 = v1036;
        uint64_t v709 = *((void *)&v1036 + 1);
        unint64_t v710 = v1037;
        swift_bridgeObjectRelease(*((void *)&v1034 + 1));
        sub_1000208D8(v709, v710);
      }

      sub_100002AC4(v1179);
      uint64_t v711 = sub_100002274(&qword_100405E00);
      uint64_t v712 = type metadata accessor for DriverEvent(0LL);
      uint64_t v713 = *(void *)(v712 - 8);
      uint64_t v714 = *(void *)(v713 + 72);
      uint64_t v715 = *(unsigned __int8 *)(v713 + 80);
      uint64_t v716 = (v715 + 32) & ~v715;
      uint64_t v220 = swift_allocObject(v711, v716 + v714, v715 | 7);
      *(_OWORD *)(v220 + 16) = xmmword_100339900;
      uint64_t v717 = v220 + v716;
      *(void *)&__int128 v1034 = 0LL;
      *((void *)&v1034 + 1) = 0xE000000000000000LL;
      _StringGuts.grow(_:)(35LL);
      swift_bridgeObjectRelease(*((void *)&v1034 + 1));
      *(void *)&__int128 v1034 = 0xD000000000000015LL;
      *((void *)&v1034 + 1) = 0x8000000100363110LL;
      v718._countAndFlagsBits = v707;
      DNSRecords.Identifier.description.getter(v707, v706, v708);
      object = v718._object;
      String.append(_:)(v718);
      swift_bridgeObjectRelease(v706);
      swift_bridgeObjectRelease(object);
      v720._countAndFlagsBits = 0x2064656B61654C20LL;
      v720._object = (void *)0xE90000000000005BLL;
      String.append(_:)(v720);
      LODWORD(v1179[0]) = v1055[0].i32[0];
      v721._countAndFlagsBits = dispatch thunk of CustomStringConvertible.description.getter( &type metadata for UInt32,  &protocol witness table for UInt32);
      v722 = v721._object;
      String.append(_:)(v721);
      swift_bridgeObjectRelease(v722);
      v723._countAndFlagsBits = 93LL;
      v723._object = (void *)0xE100000000000000LL;
      String.append(_:)(v723);
      uint64_t v724 = *((void *)&v1034 + 1);
      *(void *)uint64_t v717 = v1034;
      *(void *)(v717 + 8) = v724;
      *(void *)(v717 + 16) = 0xD000000000000096LL;
      *(void *)(v717 + 24) = 0x8000000100363130LL;
      *(_BYTE *)(v717 + 32) = 1;
      uint64_t v725 = type metadata accessor for DriverEvent.AWDL(0LL);
      swift_storeEnumTagMultiPayload(v717, v725, 6LL);
      uint64_t v330 = v717;
      uint64_t v331 = v712;
      uint64_t v366 = 1LL;
LABEL_80:
      swift_storeEnumTagMultiPayload(v330, v331, v366);
      unint64_t v368 = v776;
      uint64_t v367 = v777;
      goto LABEL_197;
    case 0xB6uLL:
      type metadata accessor for apple80211_p2p_thread_coex_event(0LL);
      uint64_t v573 = v572;
      unint64_t v45 = v776;
      uint64_t v44 = v777;
      sub_100020AFC(v777, v776);
      sub_1000A163C(v573, v44, v45);
      if ((v1055[0].i8[2] & 1) != 0) {
        goto LABEL_181;
      }
      __int8 v574 = v1055[0].i8[0];
      __int8 v575 = v1055[0].i8[1];
      uint64_t v576 = sub_100002274(&qword_100405E00);
      uint64_t v577 = type metadata accessor for DriverEvent(0LL);
      uint64_t v578 = *(void *)(v577 - 8);
      uint64_t v579 = *(void *)(v578 + 72);
      uint64_t v580 = *(unsigned __int8 *)(v578 + 80);
      uint64_t v581 = (v580 + 32) & ~v580;
      uint64_t v137 = swift_allocObject(v576, v581 + v579, v580 | 7);
      *(_OWORD *)(v137 + 16) = xmmword_100339900;
      v582 = (__int8 *)(v137 + v581);
      __int8 *v582 = v574;
      v582[1] = v575;
      uint64_t v583 = type metadata accessor for DriverEvent.AWDL(0LL);
      swift_storeEnumTagMultiPayload(v137 + v581, v583, 4LL);
      uint64_t v180 = v137 + v581;
      uint64_t v181 = v577;
      goto LABEL_167;
    case 0xC3uLL:
      uint64_t v584 = sub_100002274(&qword_100405E00);
      uint64_t v66 = type metadata accessor for DriverEvent(0LL);
      uint64_t v585 = *(void *)(v66 - 8);
      uint64_t v586 = *(void *)(v585 + 72);
      uint64_t v587 = *(unsigned __int8 *)(v585 + 80);
      uint64_t v588 = (v587 + 32) & ~v587;
      uint64_t v71 = swift_allocObject(v584, v588 + v586, v587 | 7);
      *(_OWORD *)(v71 + 16) = xmmword_100339900;
      uint64_t v72 = v71 + v588;
      uint64_t v73 = type metadata accessor for DriverEvent.AWDL(0LL);
      uint64_t v74 = v71 + v588;
      uint64_t v75 = 11LL;
      goto LABEL_188;
    case 0xC5uLL:
      type metadata accessor for apple80211_nan_preferred_channels_changed_event(0LL);
      uint64_t v590 = v589;
      unint64_t v45 = v776;
      uint64_t v44 = v777;
      sub_100020AFC(v777, v776);
      sub_1000A163C(v590, v44, v45);
      if ((v1055[1].i8[12] & 1) != 0) {
        goto LABEL_181;
      }
      __int8 v591 = v1055[0].i8[8];
      __int8 v592 = v1055[0].i8[4];
      unint64_t v593 = (unint64_t)v1055[0].i64[0] >> 40;
      __int8 v594 = v1055[1].i8[8];
      __int8 v595 = v1055[0].i8[6];
      __int8 v596 = v1055[1].i8[0];
      __int8 v597 = v1055[0].i8[7];
      unint64_t v756 = (unint64_t)v1055[0].i64[1] >> 8;
      unint64_t v757 = (unint64_t)v1055[0].i64[1] >> 16;
      unint64_t v758 = (unint64_t)v1055[0].i64[1] >> 24;
      uint64_t v759 = v1055[0].u32[3];
      unint64_t v760 = (unint64_t)v1055[0].i64[1] >> 40;
      uint64_t v761 = v1055[0].u16[7];
      uint64_t v762 = v1055[0].u8[15];
      unint64_t v763 = (unint64_t)v1055[1].i64[0] >> 8;
      unint64_t v764 = (unint64_t)v1055[1].i64[0] >> 16;
      unint64_t v765 = (unint64_t)v1055[1].i64[0] >> 24;
      unint64_t v766 = v1055[1].u32[1];
      unint64_t v767 = (unint64_t)v1055[1].i64[0] >> 40;
      unint64_t v768 = v1055[1].u16[3];
      unint64_t v769 = v1055[1].u8[7];
      v772.i32[0] = (unsigned __int32)v1055[1].i32[2] >> 8;
      LODWORD(v771) = HIWORD(v1055[1].i32[2]);
      LODWORD(v770) = HIBYTE(v1055[1].i32[2]);
      uint64_t v598 = sub_100002274(&qword_100405E00);
      unint64_t v774 = type metadata accessor for DriverEvent(0LL);
      uint64_t v599 = *(void *)(v774 - 8);
      uint64_t v600 = *(void *)(v599 + 72);
      uint64_t v601 = *(unsigned __int8 *)(v599 + 80);
      uint64_t v602 = (v601 + 32) & ~v601;
      uint64_t v603 = swift_allocObject(v598, v602 + v600, v601 | 7);
      unint64_t v775 = v603;
      *(_OWORD *)(v603 + 16) = xmmword_100339900;
      v773 = (char *)(v603 + v602);
      v1051.i8[0] = v592;
      v1051.i8[1] = v593;
      v1051.i8[2] = v595;
      v1051.i8[3] = v597;
      v1051.i8[4] = v591;
      v1051.i8[5] = v756;
      v1051.i8[6] = v757;
      v1051.i8[7] = v758;
      v1051.i8[8] = v759;
      v1051.i8[9] = v760;
      v1051.i8[10] = v761;
      v1051.i8[11] = v762;
      v1051.i8[12] = v596;
      v1051.i8[13] = v763;
      v1051.i8[14] = v764;
      v1051.i8[15] = v765;
      v1052.i8[0] = v766;
      v1052.i8[1] = v767;
      v1052.i8[2] = v768;
      v1052.i8[3] = v769;
      v1052.i8[4] = v594;
      v1052.i8[5] = v772.i8[0];
      v1052.i8[6] = v771;
      v1052.i8[7] = v770;
      if (qword_100404370 != -1) {
        swift_once(&qword_100404370, sub_10018635C);
      }
      uint64_t v604 = 0LL;
      v605 = _swiftEmptyArrayStorage;
      break;
    case 0xC8uLL:
      type metadata accessor for apple80211_awdl_stats_p2p_failure(0LL);
      uint64_t v634 = v633;
      unint64_t v45 = v776;
      uint64_t v44 = v777;
      sub_100020AFC(v777, v776);
      sub_1000A163C(v634, v44, v45);
      if ((v1055[2].i8[8] & 1) != 0) {
        goto LABEL_181;
      }
      int64x2_t v1052 = v1055[1];
      v1053[0].i64[0] = v1055[2].i64[0];
      uint64x2_t v1051 = (uint64x2_t)v1055[0];
      NSString v635 = sub_1000A99DC((uint64_t)&v1051);
      uint64_t v107 = v773;
      if (!v635) {
        goto LABEL_182;
      }
      NSString v637 = v635;
      char v638 = v636;
      uint64_t v639 = sub_100002274(&qword_100405E00);
      uint64_t v640 = type metadata accessor for DriverEvent(0LL);
      uint64_t v641 = *(void *)(v640 - 8);
      uint64_t v642 = *(void *)(v641 + 72);
      uint64_t v643 = *(unsigned __int8 *)(v641 + 80);
      uint64_t v644 = (v643 + 32) & ~v643;
      uint64_t v137 = swift_allocObject(v639, v644 + v642, v643 | 7);
      *(_OWORD *)(v137 + 16) = xmmword_100339900;
      uint64_t v645 = v137 + v644;
      *(void *)uint64_t v645 = v637;
      *(_BYTE *)(v645 + 8) = v638;
      uint64_t v646 = type metadata accessor for DriverEvent.AWDL(0LL);
      swift_storeEnumTagMultiPayload(v137 + v644, v646, 8LL);
      uint64_t v180 = v137 + v644;
      uint64_t v181 = v640;
LABEL_167:
      uint64_t v182 = 1LL;
      goto LABEL_177;
    case 0xD7uLL:
      type metadata accessor for ether_addr(0LL);
      uint64_t v648 = v647;
      unint64_t v45 = v776;
      uint64_t v44 = v777;
      sub_100020AFC(v777, v776);
      sub_1000A163C(v648, v44, v45);
      if ((v1055[0].i8[6] & 1) != 0) {
        goto LABEL_181;
      }
      unint64_t v649 = v1055[0].u32[0] | ((unint64_t)v1055[0].u16[2] << 32);
      uint64_t v650 = sub_100002274(&qword_100405E00);
      uint64_t v445 = type metadata accessor for DriverEvent(0LL);
      uint64_t v651 = *(void *)(v445 - 8);
      uint64_t v652 = *(void *)(v651 + 72);
      uint64_t v653 = *(unsigned __int8 *)(v651 + 80);
      uint64_t v654 = (v653 + 32) & ~v653;
      uint64_t v102 = swift_allocObject(v650, v654 + v652, v653 | 7);
      *(_OWORD *)(v102 + 16) = xmmword_100339900;
      uint64_t v103 = v102 + v654;
      *(void *)uint64_t v103 = v649;
      *(_OWORD *)(v103 + 24) = 0u;
      *(_OWORD *)(v103 + 8) = 0u;
      *(_BYTE *)(v103 + 40) = 0;
      char v450 = 9;
LABEL_170:
      *(_BYTE *)(v103 + 41) = v450;
      uint64_t v113 = v445;
      uint64_t v114 = 2LL;
LABEL_171:
      swift_storeEnumTagMultiPayload(v103, v113, v114);
      sub_1000208D8(v44, v45);
      return (void *)v102;
    case 0xE1uLL:
      type metadata accessor for apple80211_channel_band(0LL);
      uint64_t v656 = v655;
      unint64_t v45 = v776;
      uint64_t v44 = v777;
      sub_100020AFC(v777, v776);
      sub_1000A163C(v656, v44, v45);
      if ((v1055[0].i8[4] & 1) != 0) {
        goto LABEL_181;
      }
      if (v1055[0].i32[0] >= 4u) {
        __int8 v657 = 1;
      }
      else {
        __int8 v657 = 0x2010001u >> (8 * v1055[0].i8[0]);
      }
      uint64_t v658 = sub_100002274(&qword_100405E00);
      uint64_t v659 = type metadata accessor for DriverEvent(0LL);
      uint64_t v660 = *(void *)(v659 - 8);
      uint64_t v661 = *(void *)(v660 + 72);
      uint64_t v662 = *(unsigned __int8 *)(v660 + 80);
      uint64_t v663 = (v662 + 32) & ~v662;
      uint64_t v137 = swift_allocObject(v658, v663 + v661, v662 | 7);
      *(_OWORD *)(v137 + 16) = xmmword_100339900;
      v1055[0].i8[0] = v657;
      sub_1000580CC((uint64_t)v1055);
      sub_100058090(v1055, (void *)(v137 + v663));
      uint64_t v180 = v137 + v663;
      uint64_t v181 = v659;
      uint64_t v182 = 0LL;
LABEL_177:
      swift_storeEnumTagMultiPayload(v180, v181, v182);
      uint64_t v140 = v44;
LABEL_178:
      unint64_t v348 = v45;
LABEL_179:
      sub_1000208D8(v140, v348);
      return (void *)v137;
    case 0xEAuLL:
      type metadata accessor for apple80211_idle_detect(0LL);
      uint64_t v665 = v664;
      unint64_t v45 = v776;
      uint64_t v44 = v777;
      sub_100020AFC(v777, v776);
      sub_1000A163C(v665, v44, v45);
      if ((v1055[0].i8[8] & 1) != 0)
      {
LABEL_181:
        uint64_t v107 = v773;
LABEL_182:
        Logger.init(subsystem:category:)( 0xD000000000000012LL,  0x8000000100360620LL,  0x726576697264LL,  0xE600000000000000LL);
        sub_100020AFC(v44, v45);
        uint64_t v666 = sub_100020AFC(v44, v45);
        v667 = (os_log_s *)Logger.logObject.getter(v666);
        os_log_type_t v668 = static os_log_type_t.error.getter();
        if (os_log_type_enabled(v667, v668))
        {
          uint64_t v669 = swift_slowAlloc(22LL, -1LL);
          uint64_t v670 = swift_slowAlloc(32LL, -1LL);
          v1179[0] = v670;
          *(_DWORD *)uint64_t v669 = 134218242;
          *(void *)&v1178[0] = v769;
          UnsafeMutableRawBufferPointer.copyMemory(from:)(v1178, (char *)v1178 + 8);
          *(_WORD *)(v669 + 12) = 2080;
          sub_100020AFC(v777, v45);
          sub_100020B54(0LL, 0xE000000000000000LL, v777, v45);
          uint64_t v672 = v671;
          unint64_t v674 = v673;
          sub_1000208D8(v777, v776);
          *(void *)&v1178[0] = sub_10000235C(v672, v674, v1179);
          uint64_t v44 = v777;
          UnsafeMutableRawBufferPointer.copyMemory(from:)(v1178, (char *)v1178 + 8);
          unint64_t v675 = v674;
          unint64_t v45 = v776;
          swift_bridgeObjectRelease(v675);
          sub_1000208D8(v44, v45);
          sub_1000208D8(v44, v45);
          _os_log_impl( (void *)&_mh_execute_header,  v667,  v668,  "Failed to parse event[%ld]: %s",  (uint8_t *)v669,  0x16u);
          swift_arrayDestroy(v670, 1LL, (char *)&type metadata for Any + 8);
          swift_slowDealloc(v670, -1LL, -1LL);
          swift_slowDealloc(v669, -1LL, -1LL);
        }

        else
        {
          sub_1000208D8(v44, v45);
          sub_1000208D8(v44, v45);
        }

        (*(void (**)(char *, uint64_t))(v771 + 8))(v107, v772.i64[0]);
LABEL_186:
        sub_1000208D8(v44, v45);
        return _swiftEmptyArrayStorage;
      }

      else
      {
        unsigned __int32 v683 = v1055[0].i32[0];
        uint64_t v684 = v1055[0].u32[1];
        uint64_t v685 = sub_100002274(&qword_100405E00);
        uint64_t v686 = type metadata accessor for DriverEvent(0LL);
        uint64_t v687 = *(void *)(v686 - 8);
        uint64_t v688 = *(void *)(v687 + 72);
        uint64_t v689 = *(unsigned __int8 *)(v687 + 80);
        uint64_t v690 = (v689 + 32) & ~v689;
        uint64_t v220 = swift_allocObject(v685, v690 + v688, v689 | 7);
        *(_OWORD *)(v220 + 16) = xmmword_100339900;
        uint64_t v691 = v220 + v690;
        *(void *)(v220 + v690) = v683;
        uint64_t v692 = enum case for DispatchTimeInterval.milliseconds(_:);
        uint64_t v693 = type metadata accessor for DispatchTimeInterval(0LL);
        uint64_t v218 = v44;
        v694 = *(void (**)(void))(*(void *)(v693 - 8) + 104LL);
        ((void (*)(uint64_t, uint64_t, uint64_t))v694)(v691, v692, v693);
        *(void *)(v691 + *(int *)(type metadata accessor for AWDLIdleActivity(0LL) + 20)) = v684;
        v694();
        uint64_t v695 = type metadata accessor for DriverEvent.AWDL(0LL);
        swift_storeEnumTagMultiPayload(v691, v695, 9LL);
        uint64_t v257 = v691;
        uint64_t v479 = v686;
        uint64_t v480 = 1LL;
LABEL_195:
        swift_storeEnumTagMultiPayload(v257, v479, v480);
        uint64_t v367 = v218;
LABEL_196:
        unint64_t v368 = v45;
LABEL_197:
        sub_1000208D8(v367, v368);
        return (void *)v220;
      }

    case 0xEBuLL:
      uint64_t v676 = sub_100002274(&qword_100405E00);
      uint64_t v66 = type metadata accessor for DriverEvent(0LL);
      uint64_t v677 = *(void *)(v66 - 8);
      uint64_t v678 = *(void *)(v677 + 72);
      uint64_t v679 = *(unsigned __int8 *)(v677 + 80);
      uint64_t v680 = (v679 + 32) & ~v679;
      uint64_t v71 = swift_allocObject(v676, v680 + v678, v679 | 7);
      *(_OWORD *)(v71 + 16) = xmmword_100339900;
      uint64_t v72 = v71 + v680;
      uint64_t v73 = type metadata accessor for DriverEvent.AWDL(0LL);
      uint64_t v74 = v71 + v680;
      uint64_t v75 = 13LL;
LABEL_188:
      swift_storeEnumTagMultiPayload(v74, v73, v75);
      swift_storeEnumTagMultiPayload(v72, v66, 1LL);
      return (void *)v71;
    default:
      return result;
  }

  do
  {
    uint64_t v607 = v1051.u32[v604];
    v608 = off_10040A198;
    if (*((void *)off_10040A198 + 2))
    {
      uint64_t v609 = static Hasher._hash(seed:bytes:count:)(*((void *)off_10040A198 + 5), v1051.u32[v604], 4LL);
      uint64_t v610 = -1LL << v608[32];
      unint64_t v611 = v609 & ~v610;
      if (((*(void *)&v608[((v611 >> 3) & 0xFFFFFFFFFFFFF8LL) + 56] >> v611) & 1) != 0)
      {
        uint64_t v612 = *((void *)v608 + 6);
        if (*(_DWORD *)(v612 + 4 * v611) == (_DWORD)v607)
        {
LABEL_141:
          __int8 v614 = 0;
          __int8 v615 = 3;
LABEL_160:
          v1055[0].i32[0] = v607;
          v1055[0].i8[4] = v614;
          v1055[0].i8[5] = v615;
          sub_100185C58();
          __int32 v628 = v1055[0].i32[0];
          __int8 v629 = v1055[0].i8[4];
          __int8 v630 = v1055[0].i8[5];
          if ((swift_isUniquelyReferenced_nonNull_native(v605) & 1) == 0) {
            v605 = sub_1000A65E8(0LL, v605[2] + 1LL, 1, v605);
          }
          unint64_t v632 = v605[2];
          unint64_t v631 = v605[3];
          if (v632 >= v631 >> 1) {
            v605 = sub_1000A65E8((void *)(v631 > 1), v632 + 1, 1, v605);
          }
          v605[2] = v632 + 1;
          v606 = &v605[v632];
          *((_DWORD *)v606 + 8) = v628;
          *((_BYTE *)v606 + 36) = v629;
          *((_BYTE *)v606 + 37) = v630;
          goto LABEL_134;
        }

        uint64_t v613 = ~v610;
        while (1)
        {
          unint64_t v611 = (v611 + 1) & v613;
          if (((*(void *)&v608[((v611 >> 3) & 0xFFFFFFFFFFFFF8LL) + 56] >> v611) & 1) == 0) {
            break;
          }
          if (*(_DWORD *)(v612 + 4 * v611) == (_DWORD)v607) {
            goto LABEL_141;
          }
        }
      }
    }

    if (qword_100404378 != -1) {
      swift_once(&qword_100404378, sub_100186380);
    }
    v616 = off_10040A1A0;
    if (!*((void *)off_10040A1A0 + 2)) {
      goto LABEL_151;
    }
    uint64_t v617 = static Hasher._hash(seed:bytes:count:)(*((void *)off_10040A1A0 + 5), v607, 4LL);
    uint64_t v618 = -1LL << v616[32];
    unint64_t v619 = v617 & ~v618;
    if (((*(void *)&v616[((v619 >> 3) & 0xFFFFFFFFFFFFF8LL) + 56] >> v619) & 1) == 0) {
      goto LABEL_151;
    }
    uint64_t v620 = *((void *)v616 + 6);
    if (*(_DWORD *)(v620 + 4 * v619) == (_DWORD)v607)
    {
LABEL_150:
      __int8 v614 = 1;
      __int8 v615 = 4;
      goto LABEL_160;
    }

    uint64_t v621 = ~v618;
    while (1)
    {
      unint64_t v619 = (v619 + 1) & v621;
      if (((*(void *)&v616[((v619 >> 3) & 0xFFFFFFFFFFFFF8LL) + 56] >> v619) & 1) == 0) {
        break;
      }
      if (*(_DWORD *)(v620 + 4 * v619) == (_DWORD)v607) {
        goto LABEL_150;
      }
    }

LABEL_151:
    if (qword_100404380 != -1) {
      swift_once(&qword_100404380, sub_1001863A4);
    }
    v622 = off_10040A1A8;
    if (*((void *)off_10040A1A8 + 2))
    {
      uint64_t v623 = static Hasher._hash(seed:bytes:count:)(*((void *)off_10040A1A8 + 5), v607, 4LL);
      uint64_t v624 = -1LL << v622[32];
      unint64_t v625 = v623 & ~v624;
      if (((*(void *)&v622[((v625 >> 3) & 0xFFFFFFFFFFFFF8LL) + 56] >> v625) & 1) != 0)
      {
        uint64_t v626 = *((void *)v622 + 6);
        if (*(_DWORD *)(v626 + 4 * v625) == (_DWORD)v607)
        {
LABEL_159:
          __int8 v614 = 2;
          __int8 v615 = 5;
          goto LABEL_160;
        }

        uint64_t v627 = ~v624;
        while (1)
        {
          unint64_t v625 = (v625 + 1) & v627;
          if (((*(void *)&v622[((v625 >> 3) & 0xFFFFFFFFFFFFF8LL) + 56] >> v625) & 1) == 0) {
            break;
          }
          if (*(_DWORD *)(v626 + 4 * v625) == (_DWORD)v607) {
            goto LABEL_159;
          }
        }
      }
    }

LABEL_134:
    ++v604;
  }

  while (v604 != 8);
  v1055[0].i64[0] = (uint64_t)v605;
  sub_1000580D8((uint64_t)v1055);
  v524 = v1055;
LABEL_193:
  v681 = v773;
  sub_100058090(v524, v773);
  swift_storeEnumTagMultiPayload(v681, v774, 0LL);
  uint64_t v682 = v777;
LABEL_201:
  sub_1000208D8(v682, v776);
  return (void *)v775;
}

uint64_t AppleIO80211Driver.__allocating_init(device:role:name:)(uint64_t a1, char a2, uint64_t a3, uint64_t a4)
{
  uint64_t v9 = swift_allocObject(v4, *(unsigned int *)(v4 + 48), *(unsigned __int16 *)(v4 + 52));
  AppleIO80211Driver.init(device:role:name:)(a1, a2, a3, a4);
  return v9;
}

unint64_t Channel.init(apple80211:)(uint64_t a1, unsigned int a2)
{
  return sub_1000A810C(HIDWORD(a1), a2) & 0xFFFFFFFFFFFFLL;
}

BOOL sub_10008F720(unsigned int a1, uint64_t a2)
{
  if (!*(void *)(a2 + 16)) {
    return 0LL;
  }
  uint64_t v4 = static Hasher._hash(seed:bytes:count:)(*(void *)(a2 + 40), a1, 4LL);
  uint64_t v5 = -1LL << *(_BYTE *)(a2 + 32);
  unint64_t v6 = v4 & ~v5;
  uint64_t v7 = a2 + 56;
  if (((*(void *)(a2 + 56 + ((v6 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> v6) & 1) == 0) {
    return 0LL;
  }
  uint64_t v8 = *(void *)(a2 + 48);
  if (*(_DWORD *)(v8 + 4 * v6) == a1) {
    return 1LL;
  }
  uint64_t v10 = ~v5;
  unint64_t v11 = (v6 + 1) & v10;
  if (((*(void *)(v7 + ((v11 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> v11) & 1) == 0) {
    return 0LL;
  }
  do
  {
    int v12 = *(_DWORD *)(v8 + 4 * v11);
    BOOL result = v12 == a1;
    if (v12 == a1) {
      break;
    }
    unint64_t v11 = (v11 + 1) & v10;
  }

  while (((*(void *)(v7 + ((v11 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> v11) & 1) != 0);
  return result;
}

uint64_t sub_10008F7EC(int a1, uint64_t a2)
{
  if (*(void *)(a2 + 16))
  {
    Hasher.init(_seed:)(v10, *(void *)(a2 + 40));
    switch((char)a1)
    {
      case 2:
        Swift::UInt v4 = 0LL;
        goto LABEL_9;
      case 3:
        Swift::UInt v4 = 1LL;
        goto LABEL_9;
      case 4:
        Swift::UInt v4 = 3LL;
        goto LABEL_9;
      case 5:
        Swift::UInt v4 = 4LL;
        goto LABEL_9;
      case 6:
        Swift::UInt v4 = 5LL;
LABEL_9:
        Hasher._combine(_:)(v4);
        break;
      default:
        Hasher._combine(_:)(2uLL);
        Hasher._combine(_:)(a1 & 1);
        break;
    }

    Swift::Int v5 = Hasher._finalize()();
    uint64_t v6 = -1LL << *(_BYTE *)(a2 + 32);
    unint64_t v7 = v5 & ~v6;
    if (((*(void *)(a2 + 56 + ((v7 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> v7) & 1) != 0)
    {
      uint64_t v8 = ~v6;
      while (1)
      {
        switch(*(_BYTE *)(*(void *)(a2 + 48) + v7))
        {
          case 2:
            return 1LL;
          case 3:
            goto LABEL_13;
          case 4:
            goto LABEL_13;
          case 5:
            goto LABEL_13;
          case 6:
            return 1LL;
          default:
LABEL_13:
            unint64_t v7 = (v7 + 1) & v8;
            if (((*(void *)(a2 + 56 + ((v7 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> v7) & 1) == 0) {
              return 0LL;
            }
            break;
        }
      }
    }
  }

  return 0LL;
}

uint64_t Channel.Band.apple80211Band.getter(unsigned __int8 a1)
{
  return a1 + 1;
}

uint64_t sub_10008F9B8(uint64_t a1)
{
  return sub_10008F9D0(a1, (uint64_t (*)(uint64_t, uint64_t))sub_1000ABC68);
}

uint64_t sub_10008F9C4(uint64_t a1)
{
  return sub_10008F9D0(a1, sub_1000AB114);
}

uint64_t sub_10008F9D0(uint64_t a1, uint64_t (*a2)(uint64_t, uint64_t))
{
  uint64_t result = sub_10019EA70(0LL, *(void *)(*(void *)v2 + 16LL), 0LL, *(void *)(a1 + 16), a2);
  unint64_t v4 = *(void *)(*(void *)v2 + 16LL);
  unint64_t v5 = *(void *)(a1 + 16);
  if (v4 < v5)
  {
    unint64_t v6 = (2 * v5) | 1;
    uint64_t v7 = swift_bridgeObjectRetain(a1);
    sub_10019EB3C(v7, a1 + 32, v4, v6);
    return swift_bridgeObjectRelease(a1);
  }

  return result;
}

uint64_t IO80211Device.loadCapabilities(on:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t result = (*(uint64_t (**)(uint64_t, _BYTE *, char *, void, uint64_t, uint64_t, uint64_t, uint64_t))(a4 + 32))( 12LL,  &v6[4],  &v7,  0LL,  a1,  a2,  a3,  a4);
  if (!v4) {
    return *(void *)v6;
  }
  return result;
}

uint64_t AppleBroadcomDriver.interfaceName.getter()
{
  uint64_t v1 = *(void *)(v0 + 16);
  swift_bridgeObjectRetain(*(void *)(v0 + 24));
  return v1;
}

uint64_t AppleBroadcomDriver.interfaceRole.getter()
{
  return *(unsigned __int8 *)(v0 + 32);
}

uint64_t AppleBroadcomDriver.device.getter()
{
  return swift_retain(*(void *)(v0 + 40));
}

uint64_t AppleBroadcomDriver.eventSource.getter()
{
  uint64_t v1 = v0[6];
  sub_1000A9C00(v1, v0[7], v0[8]);
  return v1;
}

uint64_t AppleBroadcomDriver.eventSource.setter(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v7 = v3[6];
  uint64_t v8 = v3[7];
  uint64_t v9 = v3[8];
  v3[6] = a1;
  v3[7] = a2;
  v3[8] = a3;
  return sub_1000A9C2C(v7, v8, v9);
}

void *AppleBroadcomDriver.eventSource.modify(uint64_t a1)
{
  return &j__swift_endAccess;
}

void *AppleIO80211Driver.capabilities.getter()
{
  uint64_t v1 = *(void *)(v0 + 72);
  if (v1)
  {
    uint64_t v2 = *(void **)(v0 + 72);
  }

  else
  {
    uint64_t v2 = sub_10008FCA0();
    uint64_t v3 = *(void *)(v0 + 72);
    *(void *)(v0 + 72) = v2;
    swift_bridgeObjectRetain(v2);
    swift_bridgeObjectRelease(v3);
    uint64_t v1 = 0LL;
  }

  swift_bridgeObjectRetain(v1);
  return v2;
}

void *sub_10008FCA0()
{
  uint64_t v16 = _swiftEmptyArrayStorage;
  uint64_t v1 = v0[5];
  uint64_t v2 = v0[2];
  uint64_t v3 = v0[3];
  swift_retain();
  swift_bridgeObjectRetain(v3);
  uint64_t v4 = AppleDevice.loadCapabilities(on:)(v2, v3);
  uint64_t v6 = v5;
  swift_bridgeObjectRelease(v3);
  swift_release(v1);
  if (qword_1004040C8 == -1)
  {
    if ((v6 & 0x10000000000LL) == 0) {
      goto LABEL_4;
    }
    goto LABEL_3;
  }

  swift_once(&qword_1004040C8, sub_10005DA98);
  if ((v6 & 0x10000000000LL) != 0)
  {
LABEL_3:
    uint64_t v7 = static WiFiDriverCapabilities.supportsNAN;
    swift_beginAccess(&v16, v17, 33LL, 0LL);
    sub_10008F9D0(v7, (uint64_t (*)(uint64_t, uint64_t))sub_1000ABC68);
    swift_endAccess(v17);
  }

void *IO80211Driver<>.loadCapabilities()(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(void *)(a2 + 8);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v6,  a1,  &protocol requirements base descriptor for DeviceDriver);
  uint64_t v8 = *(void *)(AssociatedTypeWitness - 8);
  __chkstk_darwin(AssociatedTypeWitness);
  uint64_t v10 = (char *)&v27 - v9;
  uint64_t v28 = _swiftEmptyArrayStorage;
  (*(void (**)(uint64_t, uint64_t))(v6 + 56))(a1, v6);
  uint64_t v11 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 40))(a1, a3);
  uint64_t v13 = v12;
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a2,  a1,  AssociatedTypeWitness,  &protocol requirements base descriptor for IO80211Driver,  &associated conformance descriptor for IO80211Driver.DeviceDriver.Device: IO80211Device);
  uint64_t v15 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(AssociatedConformanceWitness + 16))( v11,  v13,  AssociatedTypeWitness,  AssociatedConformanceWitness);
  uint64_t v17 = v16;
  (*(void (**)(char *, uint64_t))(v8 + 8))(v10, AssociatedTypeWitness);
  swift_bridgeObjectRelease(v13);
  if (qword_1004040C8 == -1)
  {
    if ((v17 & 0x10000000000LL) == 0) {
      goto LABEL_4;
    }
    goto LABEL_3;
  }

  swift_once(&qword_1004040C8, sub_10005DA98);
  if ((v17 & 0x10000000000LL) != 0)
  {
LABEL_3:
    uint64_t v18 = static WiFiDriverCapabilities.supportsNAN;
    swift_beginAccess(&v28, v29, 33LL, 0LL);
    sub_10008F9D0(v18, (uint64_t (*)(uint64_t, uint64_t))sub_1000ABC68);
    swift_endAccess(v29);
  }

uint64_t AppleIO80211Driver.logger.getter@<X0>(uint64_t a1@<X8>)
{
  uint64_t v3 = v1 + OBJC_IVAR____TtC7CoreP2P18AppleIO80211Driver_logger;
  uint64_t v4 = type metadata accessor for Logger(0LL);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v4 - 8) + 16LL))(a1, v3, v4);
}

void AppleIO80211Driver.init(device:role:name:)(uint64_t a1, char a2, uint64_t a3, uint64_t a4)
{
  uint64_t v9 = type metadata accessor for Logger(0LL);
  __chkstk_darwin(v9);
  *(_OWORD *)(v4 + 48) = 0u;
  *(_OWORD *)(v4 + 64) = 0u;
  *(void *)(v4 + 40) = a1;
  *(_BYTE *)(v4 + 32) = a2;
  *(void *)(v4 + 16) = a3;
  *(void *)(v4 + 24) = a4;
  __asm { BR              X10 }

uint64_t sub_1000905E4()
{
  uint64_t v6 = ((uint64_t (*)(uint64_t, uint64_t))swift_retain_n)(v0, 2LL);
  uint64_t v7 = (os_log_s *)Logger.logObject.getter(v6);
  os_log_type_t v8 = static os_log_type_t.info.getter();
  if (os_log_type_enabled(v7, v8))
  {
    uint64_t v9 = (uint8_t *)swift_slowAlloc(12LL, -1LL);
    uint64_t v10 = swift_slowAlloc(32LL, -1LL);
    *(void *)(v5 - 88) = v10;
    *(_DWORD *)uint64_t v9 = 136315138;
    swift_retain();
    AppleIO80211Driver.description.getter();
    uint64_t v12 = v11;
    unint64_t v14 = v13;
    swift_release(v0);
    *(void *)(v5 - 96) = sub_10000235C(v12, v14, (uint64_t *)(v5 - 88));
    UnsafeMutableRawBufferPointer.copyMemory(from:)(v5 - 96, v5 - 88);
    ((void (*)(uint64_t, uint64_t))swift_release_n)(v0, 2LL);
    swift_bridgeObjectRelease(v14);
    _os_log_impl((void *)&_mh_execute_header, v7, v8, "Created %s", v9, 0xCu);
    swift_arrayDestroy(v10, 1LL, (char *)&type metadata for Any + 8);
    swift_slowDealloc(v10, -1LL, -1LL);
    swift_slowDealloc(v9, -1LL, -1LL);
  }

  else
  {
    ((void (*)(uint64_t, uint64_t))swift_release_n)(v0, 2LL);
  }

  swift_release(v2);
  return v0;
}

uint64_t AppleIO80211Driver.deinit()
{
  uint64_t v1 = v0;
  swift_beginAccess(v0 + 48, v18, 33LL, 0LL);
  uint64_t v2 = *(void *)(v0 + 64);
  if (v2)
  {
    uint64_t v3 = *(void *)(v1 + 48);
    swift_unownedRetain(v3);
    swift_bridgeObjectRetain(v2);
    swift_unownedRelease(v3);
    swift_bridgeObjectRelease(v2);
    uint64_t v4 = *(void *)(v1 + 48);
    swift_unownedRetainStrong(v4);
    AppleDevice.stopMonitoringEvents(on:)(*(Swift::String *)(v1 + 56));
    swift_release(v4);
  }

  swift_endAccess(v18);
  uint64_t v5 = v1 + OBJC_IVAR____TtC7CoreP2P18AppleIO80211Driver_logger;
  uint64_t v6 = swift_retain_n(v1, 2LL);
  uint64_t v7 = (os_log_s *)Logger.logObject.getter(v6);
  os_log_type_t v8 = static os_log_type_t.info.getter();
  if (os_log_type_enabled(v7, v8))
  {
    uint64_t v9 = (uint8_t *)swift_slowAlloc(12LL, -1LL);
    uint64_t v10 = swift_slowAlloc(32LL, -1LL);
    v18[0] = v10;
    *(_DWORD *)uint64_t v9 = 136315138;
    swift_retain();
    AppleIO80211Driver.description.getter();
    uint64_t v12 = v11;
    unint64_t v14 = v13;
    swift_release(v1);
    uint64_t v17 = sub_10000235C(v12, v14, v18);
    UnsafeMutableRawBufferPointer.copyMemory(from:)(&v17, v18);
    swift_release_n(v1, 2LL);
    swift_bridgeObjectRelease(v14);
    _os_log_impl((void *)&_mh_execute_header, v7, v8, "Destroyed %s", v9, 0xCu);
    swift_arrayDestroy(v10, 1LL, (char *)&type metadata for Any + 8);
    swift_slowDealloc(v10, -1LL, -1LL);
    swift_slowDealloc(v9, -1LL, -1LL);
  }

  else
  {

    swift_release_n(v1, 2LL);
  }

  swift_bridgeObjectRelease(*(void *)(v1 + 24));
  swift_release(*(void *)(v1 + 40));
  sub_1000A9C2C(*(void *)(v1 + 48), *(void *)(v1 + 56), *(void *)(v1 + 64));
  swift_bridgeObjectRelease(*(void *)(v1 + 72));
  uint64_t v15 = type metadata accessor for Logger(0LL);
  (*(void (**)(uint64_t, uint64_t))(*(void *)(v15 - 8) + 8LL))(v5, v15);
  return v1;
}

uint64_t AppleIO80211Driver.__deallocating_deinit()
{
  return swift_deallocClassInstance( v0,  *(unsigned int *)(*(void *)v0 + 48LL),  *(unsigned __int16 *)(*(void *)v0 + 52LL));
}

uint64_t DeviceDriver<>.countryCode.getter(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if ((*(unsigned __int8 (**)(uint64_t, uint64_t))(a3 + 32))(a1, a3) == 4)
  {
    if (qword_1004041A8 != -1) {
      swift_once(&qword_1004041A8, sub_100122F4C);
    }
    return (unsigned __int16)static CountryCode.unknown;
  }

  else
  {
    uint64_t v9 = sub_100002274(&qword_100406948);
    sub_1000A063C(51LL, v9, a1, v9, a2, a3, a4);
    return v11;
  }

uint64_t sub_100090B14(__int16 a1, uint64_t a2, uint64_t a3)
{
  return sub_1000A56DC(a1, a2, a3, (uint64_t (*)(uint64_t, unint64_t))sub_10004EA60);
}

uint64_t DeviceDriver<>.update(countryCode:)(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  int v11 = 0;
  __int16 v12 = a1;
  char v13 = 0;
  type metadata accessor for apple80211_country_code_data(0LL);
  return sub_1000A0728(51LL, (uint64_t)&v11, a2, v9, a3, a4, a5);
}

uint64_t DeviceDriver<>.userspaceP2POptions.getter(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return v10;
}

uint64_t sub_100090C38(uint64_t a1)
{
  return sub_10004EAA8(0x185uLL, 1, a1);
}

uint64_t DeviceDriver<>.update(userspaceP2POptions:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v12 = a1;
  int v11 = 1;
  type metadata accessor for apple80211_userspace_p2p_options_t(0LL);
  return sub_1000A0728(389LL, (uint64_t)&v11, a2, v9, a3, *(void *)(a4 + 16), a5);
}

uint64_t sub_100090CDC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return sub_1000A5760(a1, a2, a3, a4, (uint64_t (*)(uint64_t, int *))sub_10004E948);
}

uint64_t DeviceDriver<>.updateGateway(macAddress:ipAddress:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  return sub_100090D44(a1, a2, a3, a4, a5, a6, 450LL);
}

uint64_t sub_100090D10(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return sub_1000A5864(a1, a2, a3, a4, (uint64_t (*)(uint64_t, int *))sub_10004E948);
}

uint64_t DeviceDriver<>.updateInfraPeer(macAddress:ipAddress:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  return sub_100090D44(a1, a2, a3, a4, a5, a6, 451LL);
}

uint64_t sub_100090D44(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  return sub_1000A0DD8(a1 & 0xFFFFFFFFFFFFLL, a2, a7, a3, a4, a5, a6);
}

void sub_100090D74(char a1)
{
}

void DeviceDriver<>.updateInterfaceState(for:active:)(char a1)
{
  __asm { BR              X10 }

uint64_t sub_100090DD8(uint64_t a1, char a2)
{
  v8[0] = (a2 & 1) != 0;
  v8[1] = 6;
  uint64_t v9 = 1LL;
  int v10 = 0;
  type metadata accessor for apple80211_virtual_if_state(0LL);
  return sub_1000A0728(503LL, (uint64_t)v8, v4, v6, v3, *(void *)(v5 + 16), v2);
}

BOOL sub_100090E54()
{
  return v0 != 0;
}

BOOL IO80211Driver<>.awdlEnabled.getter(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v7 = v6;
  uint64_t v8 = *(void *)(a3 + 8);
  uint64_t v9 = *(void *)(a2 + 8);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v8,  a1,  &protocol requirements base descriptor for DeviceDriver);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a3,  a1,  AssociatedTypeWitness,  &protocol requirements base descriptor for IO80211Driver,  &associated conformance descriptor for IO80211Driver.DeviceDriver.Device: IO80211Device);
  sub_1000A063C(117LL, v7, a1, v7, v8, v9, AssociatedConformanceWitness);
  return v13 != 0;
}

uint64_t sub_100090F7C()
{
  return v0;
}

uint64_t IO80211Driver<>.awdlSubstate.getter(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v7 = v6;
  uint64_t v8 = *(void *)(a3 + 8);
  uint64_t v9 = *(void *)(a2 + 8);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v8,  a1,  &protocol requirements base descriptor for DeviceDriver);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a3,  a1,  AssociatedTypeWitness,  &protocol requirements base descriptor for IO80211Driver,  &associated conformance descriptor for IO80211Driver.DeviceDriver.Device: IO80211Device);
  sub_1000A063C(148LL, v7, a1, v7, v8, v9, AssociatedConformanceWitness);
  return v13;
}

uint64_t sub_100091098()
{
  unint64_t v0 = sub_10009FD0C(0xF4uLL);
  unsigned __int16 v1 = WORD2(v0);
  unsigned __int16 v3 = v2;
  unint64_t v4 = sub_1001889D8(HIWORD(v0));
  sub_1001889D8(v1);
  sub_1001889D8(v3);
  return v4 & 0xFFFFFFFFFFFFLL;
}

uint64_t IO80211Driver<>.peerPreferredChannels.getter(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v7 = v6;
  uint64_t v8 = *(void *)(a3 + 8);
  uint64_t v9 = *(void *)(a2 + 8);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v8,  a1,  &protocol requirements base descriptor for DeviceDriver);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a3,  a1,  AssociatedTypeWitness,  &protocol requirements base descriptor for IO80211Driver,  &associated conformance descriptor for IO80211Driver.DeviceDriver.Device: IO80211Device);
  sub_1000A063C(244LL, v7, a1, v7, v8, v9, AssociatedConformanceWitness);
  unint64_t v12 = sub_1001889D8(v15);
  sub_1001889D8(v14);
  sub_1001889D8(v16);
  return v12 & 0xFFFFFFFFFFFFLL;
}

uint64_t sub_10009122C()
{
  return sub_1000AA5E0((uint64_t)__dst);
}

uint64_t IO80211Driver<>.awdlChannelSequence.getter(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v7 = v6;
  uint64_t v8 = *(void *)(a3 + 8);
  uint64_t v9 = *(void *)(a2 + 8);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v8,  a1,  &protocol requirements base descriptor for DeviceDriver);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a3,  a1,  AssociatedTypeWitness,  &protocol requirements base descriptor for IO80211Driver,  &associated conformance descriptor for IO80211Driver.DeviceDriver.Device: IO80211Device);
  sub_1000A063C(129LL, v7, a1, v7, v8, v9, AssociatedConformanceWitness);
  memcpy(__dst, __src, 0x190uLL);
  return sub_1000AA5E0((uint64_t)__dst);
}

uint64_t sub_1000913DC()
{
  return sub_1000913FC();
}

uint64_t sub_1000913FC()
{
  uint64_t v1 = swift_slowAlloc(0x2000LL, -1LL);
  uint64_t v2 = v0[5];
  uint64_t v3 = v0[2];
  uint64_t v4 = v0[3];
  swift_retain();
  swift_bridgeObjectRetain(v4);
  AppleDevice.getRequest(requestType:data:on:)(0x1D2uLL, v1, v1 + 0x2000, 0, v3, v4);
  swift_bridgeObjectRelease(v4);
  uint64_t result = swift_release(v2);
  uint64_t v6 = 0LL;
  uint64_t v7 = _swiftEmptyArrayStorage;
  while (1)
  {
    char v8 = *(_BYTE *)(v1 + v6);
    if (v8) {
      break;
    }
LABEL_2:
    if (++v6 == 0x2000)
    {
      swift_slowDealloc(v1, -1LL, -1LL);
      return (uint64_t)v7;
    }
  }

  if ((v6 & 0xE000) != 0) {
    goto LABEL_16;
  }
  uint64_t v9 = 0LL;
  while (((1LL << v9) & ~v8) != 0)
  {
LABEL_7:
    if (++v9 == 8) {
      goto LABEL_2;
    }
  }

  int v10 = (unsigned __int16)(8 * v6) + (unsigned __int16)v9;
  if ((v10 & 0x10000) == 0)
  {
    uint64_t result = swift_isUniquelyReferenced_nonNull_native(v7);
    if ((result & 1) == 0)
    {
      uint64_t result = (uint64_t)sub_1000A72E4(0LL, v7[2] + 1LL, 1, v7);
      uint64_t v7 = (void *)result;
    }

    unint64_t v12 = v7[2];
    unint64_t v11 = v7[3];
    if (v12 >= v11 >> 1)
    {
      uint64_t result = (uint64_t)sub_1000A72E4((void *)(v11 > 1), v12 + 1, 1, v7);
      uint64_t v7 = (void *)result;
    }

    v7[2] = v12 + 1;
    *((_WORD *)v7 + v12 + 16) = v10;
    goto LABEL_7;
  }

  __break(1u);
LABEL_16:
  __break(1u);
  return result;
}

uint64_t IO80211Driver<>.activePorts.getter(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = swift_slowAlloc(0x2000LL, -1LL);
  uint64_t v7 = *(void *)(a3 + 8);
  uint64_t v8 = *(void *)(a2 + 8);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v7,  a1,  &protocol requirements base descriptor for DeviceDriver);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a3,  a1,  AssociatedTypeWitness,  &protocol requirements base descriptor for IO80211Driver,  &associated conformance descriptor for IO80211Driver.DeviceDriver.Device: IO80211Device);
  uint64_t result = sub_10009F90C(466LL, v6, v6 + 0x2000, a1, v7, v8, AssociatedConformanceWitness);
  uint64_t v12 = 0LL;
  unsigned int v13 = _swiftEmptyArrayStorage;
  while (1)
  {
    char v14 = *(_BYTE *)(v6 + v12);
    if (v14) {
      break;
    }
LABEL_2:
    if (++v12 == 0x2000)
    {
      swift_slowDealloc(v6, -1LL, -1LL);
      return (uint64_t)v13;
    }
  }

  if ((v12 & 0xE000) != 0) {
    goto LABEL_16;
  }
  uint64_t v15 = 0LL;
  while (((1LL << v15) & ~v14) != 0)
  {
LABEL_7:
    if (++v15 == 8) {
      goto LABEL_2;
    }
  }

  int v16 = (unsigned __int16)(8 * v12) + (unsigned __int16)v15;
  if ((v16 & 0x10000) == 0)
  {
    uint64_t result = swift_isUniquelyReferenced_nonNull_native(v13);
    if ((result & 1) == 0)
    {
      uint64_t result = (uint64_t)sub_1000A72E4(0LL, v13[2] + 1LL, 1, v13);
      unsigned int v13 = (void *)result;
    }

    unint64_t v18 = v13[2];
    unint64_t v17 = v13[3];
    if (v18 >= v17 >> 1)
    {
      uint64_t result = (uint64_t)sub_1000A72E4((void *)(v17 > 1), v18 + 1, 1, v13);
      unsigned int v13 = (void *)result;
    }

    v13[2] = v18 + 1;
    *((_WORD *)v13 + v18 + 16) = v16;
    goto LABEL_7;
  }

  __break(1u);
LABEL_16:
  __break(1u);
  return result;
}

uint64_t sub_100091784( uint64_t a1, uint64_t a2, int a3, __int16 a4, unsigned __int16 a5, uint64_t a6, unint64_t a7, char a8)
{
  return sub_1000917B4(a1, a2 & 0xFFFFFFFFFFFFLL, a3, a4, a5, a6, a7 & 0xFFFFFFFFFFFFLL | ((HIWORD(a7) & 1) << 48), a8);
}

uint64_t sub_1000917B4( uint64_t a1, uint64_t a2, int a3, __int16 a4, unsigned __int16 a5, uint64_t a6, uint64_t a7, char a8)
{
  *(_WORD *)&v31[8] = 0;
  memset(&v31[12], 0, 156);
  *(void *)uint64_t v31 = 1LL;
  *(_DWORD *)&v31[168] = a8 & 1;
  *(_DWORD *)&v31[172] = sub_1000A2BBC(a6);
  LOWORD(v32) = a4;
  *(_DWORD *)((char *)&v32 + 2) = a5;
  uint64_t v14 = static String._unconditionallyBridgeFromObjectiveC(_:)(a1);
  uint64_t v16 = v15;
  uint64_t KeyPath = swift_getKeyPath(&unk_10033EA48);
  uint64_t v34 = v31;
  uint64_t v35 = KeyPath;
  uint64_t v36 = 128LL;
  uint64_t v18 = (uint64_t)sub_10003B5A4( (void *(*)(uint64_t *__return_ptr, void *))sub_100054614,  (uint64_t)v33,  v14,  v16);
  swift_bridgeObjectRelease(v16);
  swift_release(KeyPath);
  uint64_t v19 = 127LL;
  if (v18 < 127) {
    uint64_t v19 = v18;
  }
  if (v19 < 0) {
    __break(1u);
  }
  *(_DWORD *)&v31[12] = v19;
  *(_DWORD *)&v31[144] = a3;
  *(_WORD *)&v31[4] = a2;
  v31[6] = BYTE2(a2);
  v31[7] = BYTE3(a2);
  v31[8] = BYTE4(a2);
  v31[9] = BYTE5(a2);
  if ((a7 & 0x1000000000000LL) == 0)
  {
    uint64_t v20 = sub_100002274(&qword_1004040A8);
    uint64_t v21 = swift_allocObject(v20, 38LL, 7LL);
    *(_OWORD *)(v21 + 16) = xmmword_10033A980;
    *(_WORD *)(v21 + 32) = a7;
    *(_BYTE *)(v21 + 34) = BYTE2(a7);
    *(_BYTE *)(v21 + 35) = BYTE3(a7);
    *(_BYTE *)(v21 + 36) = BYTE4(a7);
    *(_BYTE *)(v21 + 37) = BYTE5(a7);
    uint64_t v22 = sub_1000FB08C(v21);
    unint64_t v24 = v23;
    swift_bridgeObjectRelease(v21);
    *(void *)&v37[0] = v22;
    *((void *)&v37[0] + 1) = v24;
    unint64_t v25 = sub_10005D508();
    DataProtocol.copyBytes(to:)(&v31[152], &v31[168], &type metadata for Data, v25);
    sub_1000208D8(v22, v24);
  }

  v37[8] = *(_OWORD *)&v31[128];
  v37[9] = *(_OWORD *)&v31[144];
  v37[10] = *(_OWORD *)&v31[160];
  uint64_t v38 = v32;
  v37[4] = *(_OWORD *)&v31[64];
  v37[5] = *(_OWORD *)&v31[80];
  v37[6] = *(_OWORD *)&v31[96];
  v37[7] = *(_OWORD *)&v31[112];
  v37[0] = *(_OWORD *)v31;
  v37[1] = *(_OWORD *)&v31[16];
  v37[2] = *(_OWORD *)&v31[32];
  v37[3] = *(_OWORD *)&v31[48];
  uint64_t v26 = v30[5];
  uint64_t v27 = v30[2];
  uint64_t v28 = v30[3];
  swift_retain();
  swift_bridgeObjectRetain(v28);
  AppleDevice.setRequest(requestType:data:on:)(0xA4uLL, (uint64_t)v37, (uint64_t)v39, 0, v27, v28);
  swift_bridgeObjectRelease(v28);
  return swift_release(v26);
}

uint64_t IO80211Driver<>.trafficRegistration(for:to:desiredLatency:desiredChannel:desiredSecondaryChannel:options:ssidHash:active:)( uint64_t a1, uint64_t a2, int a3, __int16 a4, unsigned __int16 a5, uint64_t a6, uint64_t a7, char a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  *(_WORD *)&v38[8] = 0;
  memset(&v38[12], 0, 156);
  *(void *)uint64_t v38 = 1LL;
  *(_DWORD *)&v38[168] = a8 & 1;
  *(_DWORD *)&v38[172] = sub_1000A2BBC(a6);
  LOWORD(v39) = a4;
  *(_DWORD *)((char *)&v39 + 2) = a5;
  uint64_t v17 = static String._unconditionallyBridgeFromObjectiveC(_:)(a1);
  uint64_t v19 = v18;
  uint64_t KeyPath = swift_getKeyPath(&unk_10033EA48);
  uint64_t v41 = v38;
  uint64_t v42 = KeyPath;
  uint64_t v43 = 128LL;
  uint64_t v21 = (uint64_t)sub_10003B5A4( (void *(*)(uint64_t *__return_ptr, void *))sub_100054614,  (uint64_t)v40,  v17,  v19);
  swift_bridgeObjectRelease(v19);
  swift_release(KeyPath);
  uint64_t v22 = 127LL;
  if (v21 < 127) {
    uint64_t v22 = v21;
  }
  if (v22 < 0) {
    __break(1u);
  }
  uint64_t v23 = a10;
  *(_DWORD *)&v38[12] = v22;
  *(_DWORD *)&v38[144] = a3;
  *(_WORD *)&v38[4] = a2;
  v38[6] = BYTE2(a2);
  v38[7] = BYTE3(a2);
  v38[8] = BYTE4(a2);
  v38[9] = BYTE5(a2);
  if ((a7 & 0x1000000000000LL) == 0)
  {
    uint64_t v24 = sub_100002274(&qword_1004040A8);
    uint64_t v25 = swift_allocObject(v24, 38LL, 7LL);
    *(_OWORD *)(v25 + 16) = xmmword_10033A980;
    *(_WORD *)(v25 + 32) = a7;
    *(_BYTE *)(v25 + 34) = BYTE2(a7);
    *(_BYTE *)(v25 + 35) = BYTE3(a7);
    *(_BYTE *)(v25 + 36) = BYTE4(a7);
    *(_BYTE *)(v25 + 37) = BYTE5(a7);
    uint64_t v26 = sub_1000FB08C(v25);
    unint64_t v28 = v27;
    uint64_t v29 = v25;
    uint64_t v23 = a10;
    swift_bridgeObjectRelease(v29);
    *(void *)&v44[0] = v26;
    *((void *)&v44[0] + 1) = v28;
    unint64_t v30 = sub_10005D508();
    DataProtocol.copyBytes(to:)(&v38[152], &v38[168], &type metadata for Data, v30);
    sub_1000208D8(v26, v28);
  }

  v44[8] = *(_OWORD *)&v38[128];
  v44[9] = *(_OWORD *)&v38[144];
  v44[10] = *(_OWORD *)&v38[160];
  uint64_t v45 = v39;
  v44[4] = *(_OWORD *)&v38[64];
  v44[5] = *(_OWORD *)&v38[80];
  v44[6] = *(_OWORD *)&v38[96];
  v44[7] = *(_OWORD *)&v38[112];
  v44[0] = *(_OWORD *)v38;
  v44[1] = *(_OWORD *)&v38[16];
  v44[2] = *(_OWORD *)&v38[32];
  v44[3] = *(_OWORD *)&v38[48];
  type metadata accessor for apple80211_awdl_peer_traffic_registration(0LL);
  uint64_t v32 = v31;
  uint64_t v33 = *(void *)(a11 + 8);
  uint64_t v34 = *(void *)(v23 + 8);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v33,  a9,  &protocol requirements base descriptor for DeviceDriver);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a11,  a9,  AssociatedTypeWitness,  &protocol requirements base descriptor for IO80211Driver,  &associated conformance descriptor for IO80211Driver.DeviceDriver.Device: IO80211Device);
  return sub_1000A0728(164LL, (uint64_t)v44, a9, v32, v33, v34, AssociatedConformanceWitness);
}

uint64_t sub_100091DC8(char a1, uint64_t a2)
{
  return sub_10004EB38(0x1A1uLL, qword_10033EED8[a1], a2 & 0xFFFFFFFFFFFFLL);
}

uint64_t IO80211Driver<>.transmit(unicastMasterIndicationOptions:to:)( char a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  int v8 = dword_10033F030[a1];
  v16[0] = 1;
  v16[1] = v8;
  __int16 v17 = a2;
  char v18 = BYTE2(a2);
  char v19 = BYTE3(a2);
  char v20 = BYTE4(a2);
  char v21 = BYTE5(a2);
  type metadata accessor for apple80211_awdl_UMI_data(0LL);
  uint64_t v10 = v9;
  uint64_t v11 = *(void *)(a5 + 8);
  uint64_t v12 = *(void *)(a4 + 8);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v11,  a3,  &protocol requirements base descriptor for DeviceDriver);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a5,  a3,  AssociatedTypeWitness,  &protocol requirements base descriptor for IO80211Driver,  &associated conformance descriptor for IO80211Driver.DeviceDriver.Device: IO80211Device);
  return sub_1000A0728(417LL, (uint64_t)v16, a3, v10, v11, v12, AssociatedConformanceWitness);
}

unint64_t sub_100091EFC()
{
  unint64_t result = sub_10009FEEC(0xD9uLL);
  if ((result & 0x8000000000000000LL) != 0) {
    __break(1u);
  }
  else {
    result >>= 32;
  }
  return result;
}

uint64_t IO80211Driver<>.operatingMode.getter(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v7 = v6;
  uint64_t v8 = *(void *)(a3 + 8);
  uint64_t v9 = *(void *)(a2 + 8);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v8,  a1,  &protocol requirements base descriptor for DeviceDriver);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a3,  a1,  AssociatedTypeWitness,  &protocol requirements base descriptor for IO80211Driver,  &associated conformance descriptor for IO80211Driver.DeviceDriver.Device: IO80211Device);
  sub_1000A063C(217LL, v7, a1, v7, v8, v9, AssociatedConformanceWitness);
  uint64_t result = v13;
  if ((v13 & 0x80000000) != 0) {
    __break(1u);
  }
  return result;
}

uint64_t sub_100092028(uint64_t a1)
{
  if ((a1 & 0x80000000) == 0) {
    return sub_10004EC24(0xD9uLL, a1 << 32);
  }
  char v2 = 2;
  uint64_t result = _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  "Negative value is not representable",  35LL,  2LL,  "Swift/Integers.swift",  20LL,  v2,  3451LL,  0);
  __break(1u);
  return result;
}

uint64_t IO80211Driver<>.updateOperatingMode(_:)(int a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a1 < 0)
  {
    uint64_t result = _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  "Negative value is not representable",  35LL,  2LL,  "Swift/Integers.swift",  20LL,  2,  3451LL,  0);
    __break(1u);
  }

  else
  {
    v14[0] = 0;
    v14[1] = a1;
    type metadata accessor for apple80211_awdl_oper_mode(0LL);
    uint64_t v8 = v7;
    uint64_t v9 = *(void *)(a4 + 8);
    uint64_t v10 = *(void *)(a3 + 8);
    uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v9,  a2,  &protocol requirements base descriptor for DeviceDriver);
    uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a4,  a2,  AssociatedTypeWitness,  &protocol requirements base descriptor for IO80211Driver,  &associated conformance descriptor for IO80211Driver.DeviceDriver.Device: IO80211Device);
    return sub_1000A0728(217LL, (uint64_t)v14, a2, v8, v9, v10, AssociatedConformanceWitness);
  }

  return result;
}

void *sub_1000921A8(char a1)
{
  uint64_t v4 = *v1;
  v3[2] = a1 & 1;
  v3[3] = &v4;
  return sub_10003B82C( (uint64_t (*)(void *))sub_1000AB4A4,  (uint64_t)v3,  0x5379616C70726961LL,  0xEB000000006B6E69LL,  &v4);
}

void *IO80211Driver<>.setAirPlaySinkMode(_:)(char a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v5[2] = a2;
  _OWORD v5[3] = a3;
  v5[4] = a4;
  uint64_t v6 = (void *)(a1 & 1);
  return sub_10003B82C( (uint64_t (*)(void *))sub_1000ABC00,  (uint64_t)v5,  0x5379616C70726961LL,  0xEB000000006B6E69LL,  v6);
}

uint64_t sub_100092264(char a1)
{
  if ((a1 & 1) != 0) {
    uint64_t v1 = 0x100000001LL;
  }
  else {
    uint64_t v1 = 1LL;
  }
  return sub_10004ECE0(0xA3uLL, v1);
}

uint64_t IO80211Driver<>.setAirPlaySoloMode(_:)(char a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  int v14 = 1;
  char v15 = a1;
  type metadata accessor for apple80211_awdl_social_time_slots(0LL);
  uint64_t v8 = v7;
  uint64_t v9 = *(void *)(a4 + 8);
  uint64_t v10 = *(void *)(a3 + 8);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v9,  a2,  &protocol requirements base descriptor for DeviceDriver);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a4,  a2,  AssociatedTypeWitness,  &protocol requirements base descriptor for IO80211Driver,  &associated conformance descriptor for IO80211Driver.DeviceDriver.Device: IO80211Device);
  return sub_1000A0728(163LL, (uint64_t)&v14, a2, v8, v9, v10, AssociatedConformanceWitness);
}

uint64_t sub_100092354(uint64_t a1)
{
  return sub_100092374(a1);
}

uint64_t sub_100092374(uint64_t a1)
{
  __int128 v19 = 0u;
  __int128 v20 = 0u;
  __int128 v17 = 0u;
  __int128 v18 = 0u;
  __int128 v15 = 0u;
  __int128 v16 = 0u;
  __int128 v13 = 0u;
  __int128 v14 = 0u;
  unint64_t v2 = *(void *)(a1 + 16);
  uint64_t v3 = 64LL;
  if (v2 < 0x40) {
    uint64_t v3 = *(void *)(a1 + 16);
  }
  LODWORD(v21) = 0;
  HIDWORD(v21) = v3;
  if (v3)
  {
    uint64_t v4 = (_WORD *)&v13 + 2;
    uint64_t v5 = (_DWORD *)(a1 + 32);
    while (1)
    {
      if (!v2) {
        __break(1u);
      }
      if (*v5 >= 0x10000u) {
        break;
      }
      *v4++ = *v5;
      --v2;
      v5 += 2;
      if (!--v3) {
        goto LABEL_8;
      }
    }

    uint64_t result = _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  "Not enough bits to represent the passed value",  45LL,  2LL,  "Swift/Integers.swift",  20LL,  2,  3455LL,  0);
    __break(1u);
  }

  else
  {
LABEL_8:
    v10[6] = v19;
    v10[7] = v20;
    uint64_t v11 = v21;
    v10[2] = v15;
    void v10[3] = v16;
    v10[4] = v17;
    void v10[5] = v18;
    v10[0] = v13;
    v10[1] = v14;
    uint64_t v6 = v1[5];
    uint64_t v7 = v1[2];
    uint64_t v8 = v1[3];
    swift_retain();
    swift_bridgeObjectRetain(v8);
    AppleDevice.setRequest(requestType:data:on:)(0x1A3uLL, (uint64_t)v10, (uint64_t)&v12, 0, v7, v8);
    swift_bridgeObjectRelease(v8);
    return swift_release(v6);
  }

  return result;
}

uint64_t IO80211Driver<>.updateLTERestrictedChannels(_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  __int128 v26 = 0u;
  __int128 v27 = 0u;
  __int128 v24 = 0u;
  __int128 v25 = 0u;
  __int128 v22 = 0u;
  __int128 v23 = 0u;
  __int128 v20 = 0u;
  __int128 v21 = 0u;
  unint64_t v7 = *(void *)(a1 + 16);
  uint64_t v8 = 64LL;
  if (v7 < 0x40) {
    uint64_t v8 = *(void *)(a1 + 16);
  }
  LODWORD(v28) = 0;
  HIDWORD(v28) = v8;
  if (v8)
  {
    uint64_t v9 = (_WORD *)&v20 + 2;
    uint64_t v10 = (_DWORD *)(a1 + 32);
    while (v7)
    {
      if (*v10 >= 0x10000u) {
        goto LABEL_10;
      }
      *v9++ = *v10;
      --v7;
      v10 += 2;
      if (!--v8) {
        goto LABEL_8;
      }
    }

    __break(1u);
LABEL_10:
    uint64_t result = _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  "Not enough bits to represent the passed value",  45LL,  2LL,  "Swift/Integers.swift",  20LL,  2,  3455LL,  0);
    __break(1u);
  }

  else
  {
LABEL_8:
    v18[6] = v26;
    v18[7] = v27;
    uint64_t v19 = v28;
    v18[2] = v22;
    uint64_t v18[3] = v23;
    v18[4] = v24;
    v18[5] = v25;
    v18[0] = v20;
    v18[1] = v21;
    type metadata accessor for apple80211_lte_restricted_channels(0LL);
    uint64_t v12 = v11;
    uint64_t v13 = *(void *)(a4 + 8);
    uint64_t v14 = *(void *)(a3 + 8);
    uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v13,  a2,  &protocol requirements base descriptor for DeviceDriver);
    uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a4,  a2,  AssociatedTypeWitness,  &protocol requirements base descriptor for IO80211Driver,  &associated conformance descriptor for IO80211Driver.DeviceDriver.Device: IO80211Device);
    return sub_1000A0728(419LL, (uint64_t)v18, a2, v12, v13, v14, AssociatedConformanceWitness);
  }

  return result;
}

void sub_10009268C(uint64_t a1, uint64_t a2, uint64_t a3)
{
}

void sub_1000926AC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t KeyPath = swift_getKeyPath(&unk_10033EA68);
  dispatch thunk of AnyKeyPath._storedInlineOffset.getter(KeyPath);
  char v6 = v5;
  swift_release(KeyPath);
  if ((v6 & 1) == 0) {
    __asm { BR              X9 }
  }

  __break(1u);
  JUMPOUT(0x100093468LL);
}

void IO80211Driver<>.registerService(active:keyData:valueData:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t KeyPath = swift_getKeyPath(&unk_10033EA68);
  dispatch thunk of AnyKeyPath._storedInlineOffset.getter(KeyPath);
  char v6 = v5;
  swift_release(KeyPath);
  if ((v6 & 1) == 0) {
    __asm { BR              X9 }
  }

  __break(1u);
  JUMPOUT(0x1000943C0LL);
}

uint64_t sub_100094558(uint64_t a1)
{
  return sub_100094578(a1);
}

uint64_t sub_100094578(uint64_t a1)
{
  uint64_t v3 = (int *)type metadata accessor for AWDLPeer(0LL);
  __chkstk_darwin(v3);
  char v5 = (char *)&v52 - ((v4 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v6 = sub_100002274((uint64_t *)&unk_1004104A0);
  __chkstk_darwin(v6);
  uint64_t v8 = (char *)&v52 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  sub_1000226B0(a1 + v3[14], (uint64_t)v8, (uint64_t *)&unk_1004104A0);
  uint64_t v9 = type metadata accessor for AWDLActionFrame.DataPathState(0LL);
  if ((*(unsigned int (**)(char *, uint64_t, uint64_t))(*(void *)(v9 - 8) + 48LL))(v8, 1LL, v9) == 1)
  {
    sub_1000225EC((uint64_t)v8, (uint64_t *)&unk_1004104A0);
LABEL_4:
    unsigned int v58 = 0;
    goto LABEL_6;
  }

  uint64_t v10 = &v8[*(int *)(v9 + 140)];
  unsigned int v11 = *(_DWORD *)v10;
  char v12 = v10[4];
  sub_10005802C((uint64_t)v8, type metadata accessor for AWDLActionFrame.DataPathState);
  if ((v12 & 1) != 0) {
    goto LABEL_4;
  }
  unsigned int v58 = v11;
  if (v11 >= 0x10000) {
    goto LABEL_43;
  }
LABEL_6:
  uint64_t v13 = a1 + v3[12];
  unint64_t v15 = *(void *)v13;
  unint64_t v14 = *(void *)(v13 + 8);
  uint64_t v16 = *(void *)(v13 + 40);
  uint64_t v17 = a1 + v3[21];
  if ((*(_BYTE *)(v17 + 4) & 1) != 0)
  {
    unsigned int v57 = 0;
  }

  else
  {
    unsigned int v57 = *(_DWORD *)v17;
    if (v57 >= 0x10000) {
      goto LABEL_43;
    }
  }

  unint64_t v18 = HIWORD(v15);
  unint64_t v19 = HIDWORD(v14);
  unint64_t v20 = HIWORD(v14);
  if (!v16)
  {
    LODWORD(v18) = 0;
    LODWORD(v14) = 0;
  }

  int v55 = v14;
  int v56 = v18;
  if (v16) {
    int v21 = v20;
  }
  else {
    int v21 = 0;
  }
  if (v16) {
    int v22 = v19;
  }
  else {
    int v22 = 0;
  }
  int v53 = v22;
  int v54 = v21;
  uint64_t v23 = a1 + v3[24];
  uint64_t v24 = *(void *)v23;
  char v25 = *(_BYTE *)(v23 + 8);
  sub_100057FE8(a1, (uint64_t)v5, type metadata accessor for AWDLPeer);
  if ((v25 & 1) != 0)
  {
    __int128 v26 = &v5[v3[23]];
    uint64_t v24 = *(void *)v26;
    char v27 = v26[8];
    sub_10005802C((uint64_t)v5, type metadata accessor for AWDLPeer);
    if ((v27 & 1) != 0)
    {
      LOBYTE(v24) = 0;
      goto LABEL_23;
    }
  }

  else
  {
    sub_10005802C((uint64_t)v5, type metadata accessor for AWDLPeer);
  }

  if (v24 < -128)
  {
    __break(1u);
LABEL_42:
    __break(1u);
  }

  if (v24 > 127) {
    goto LABEL_42;
  }
LABEL_23:
  uint64_t v28 = *(void *)(v13 + 40);
  if (v28) {
    LOBYTE(v28) = *(_BYTE *)(v13 + 28);
  }
  uint64_t v29 = a1 + v3[9];
  if (*(_BYTE *)(v29 + 48) == 1)
  {
    LOBYTE(v30) = 0;
    LOBYTE(v31) = 0;
    LOBYTE(v32) = 0;
    LOBYTE(v33) = 0;
    LOBYTE(v34) = 0;
    LOBYTE(v35) = 0;
    LOBYTE(v36) = 0;
    int v37 = 0;
    LODWORD(v38) = 0;
    uint64_t v39 = a1 + v3[22];
    int v40 = *(unsigned __int8 *)(v39 + 4);
    int v41 = *(_DWORD *)v39;
    if (v40) {
      int v41 = 0;
    }
    goto LABEL_36;
  }

  unint64_t v30 = *(void *)(v29 + 16);
  if (v30 >= 0x100)
  {
LABEL_43:
    _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  "Not enough bits to represent the passed value",  45LL,  2LL,  "Swift/Integers.swift",  20LL,  2,  3455LL,  0);
    __break(1u);
    JUMPOUT(0x100094A6CLL);
  }

  unint64_t v31 = *(void *)v29;
  uint64_t v43 = *(void *)(v29 + 24);
  uint64_t v42 = *(void *)(v29 + 32);
  uint64_t v44 = a1 + v3[22];
  if (*(_BYTE *)(v44 + 4)) {
    int v41 = 0;
  }
  else {
    int v41 = *(_DWORD *)v44;
  }
  if ((v42 & 1) != 0) {
    __asm { BR              X17 }
  }

  int v37 = HIDWORD(v43);
  if ((v43 & 1) != 0) {
    __asm { BR              X16 }
  }

  unint64_t v38 = HIDWORD(v30);
  unint64_t v36 = v31 >> 40;
  unint64_t v35 = HIDWORD(v31);
  unint64_t v34 = v31 >> 24;
  unint64_t v33 = v31 >> 16;
  unint64_t v32 = v31 >> 8;
LABEL_36:
  __int16 v45 = WORD1(v15);
  uint64_t v46 = a1 + v3[5];
  __int16 v47 = *(_WORD *)(v46 + 4);
  if (!v16) {
    __int16 v45 = 0;
  }
  v59[0] = v58;
  v59[1] = v45;
  v59[2] = v57;
  v59[3] = v55;
  v59[4] = v54;
  v59[5] = v53;
  v59[6] = v56;
  char v60 = v24;
  char v61 = 0;
  char v62 = v28;
  char v63 = 0;
  char v64 = v30;
  int v65 = v41;
  int v66 = v37;
  int v67 = v38;
  char v68 = v31;
  char v69 = v32;
  char v70 = v33;
  char v71 = v34;
  char v72 = v35;
  char v73 = v36;
  int v74 = *(_DWORD *)v46;
  __int16 v75 = v47;
  uint64_t v48 = v1[5];
  uint64_t v49 = v1[2];
  uint64_t v50 = v1[3];
  swift_retain();
  swift_bridgeObjectRetain(v50);
  AppleDevice.setRequest(requestType:data:on:)(0xE5uLL, (uint64_t)v59, (uint64_t)&v76, 0, v49, v50);
  swift_bridgeObjectRelease(v50);
  return swift_release(v48);
}

uint64_t IO80211Driver<>.elect(peer:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v68 = a4;
  uint64_t v7 = (int *)type metadata accessor for AWDLPeer(0LL);
  __chkstk_darwin(v7);
  uint64_t v9 = (char *)&v61 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v10 = sub_100002274((uint64_t *)&unk_1004104A0);
  __chkstk_darwin(v10);
  char v12 = (char *)&v61 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  sub_1000226B0(a1 + v7[14], (uint64_t)v12, (uint64_t *)&unk_1004104A0);
  uint64_t v13 = type metadata accessor for AWDLActionFrame.DataPathState(0LL);
  if ((*(unsigned int (**)(char *, uint64_t, uint64_t))(*(void *)(v13 - 8) + 48LL))(v12, 1LL, v13) == 1)
  {
    sub_1000225EC((uint64_t)v12, (uint64_t *)&unk_1004104A0);
    unsigned int v66 = 0;
  }

  else
  {
    unint64_t v14 = &v12[*(int *)(v13 + 140)];
    unsigned int v15 = *(_DWORD *)v14;
    char v16 = v14[4];
    sub_10005802C((uint64_t)v12, type metadata accessor for AWDLActionFrame.DataPathState);
    if ((v16 & 1) != 0)
    {
      unsigned int v66 = 0;
    }

    else
    {
      unsigned int v66 = v15;
      if (v15 >= 0x10000) {
        goto LABEL_43;
      }
    }
  }

  uint64_t v17 = a1 + v7[12];
  unint64_t v19 = *(void *)v17;
  unint64_t v18 = *(void *)(v17 + 8);
  uint64_t v20 = *(void *)(v17 + 40);
  uint64_t v21 = a1 + v7[21];
  char v22 = *(_BYTE *)(v21 + 4);
  uint64_t v67 = a3;
  if ((v22 & 1) != 0)
  {
    unsigned int v65 = 0;
  }

  else
  {
    unsigned int v65 = *(_DWORD *)v21;
    if (v65 >= 0x10000) {
      goto LABEL_43;
    }
  }

  unint64_t v23 = HIWORD(v19);
  unint64_t v24 = HIDWORD(v18);
  unint64_t v25 = HIWORD(v18);
  if (!v20)
  {
    LODWORD(v23) = 0;
    LODWORD(v18) = 0;
  }

  int v63 = v18;
  int v64 = v23;
  if (v20) {
    int v26 = v25;
  }
  else {
    int v26 = 0;
  }
  if (v20) {
    int v27 = v24;
  }
  else {
    int v27 = 0;
  }
  int v61 = v27;
  int v62 = v26;
  uint64_t v28 = a1 + v7[24];
  uint64_t v29 = *(void *)v28;
  char v30 = *(_BYTE *)(v28 + 8);
  sub_100057FE8(a1, (uint64_t)v9, type metadata accessor for AWDLPeer);
  if ((v30 & 1) != 0)
  {
    unint64_t v31 = &v9[v7[23]];
    uint64_t v29 = *(void *)v31;
    char v32 = v31[8];
    sub_10005802C((uint64_t)v9, type metadata accessor for AWDLPeer);
    if ((v32 & 1) != 0)
    {
      LOBYTE(v29) = 0;
      goto LABEL_23;
    }
  }

  else
  {
    sub_10005802C((uint64_t)v9, type metadata accessor for AWDLPeer);
  }

  if (v29 < -128)
  {
    __break(1u);
    goto LABEL_42;
  }

  if (v29 > 127)
  {
LABEL_42:
    __break(1u);
    goto LABEL_43;
  }

uint64_t sub_100094FDC@<X0>(uint64_t a1@<X8>)
{
  return sub_1000586C0((uint64_t)v5, a1, &qword_100406950);
}

uint64_t IO80211Driver<>.statistics.getter@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v9 = v8;
  uint64_t v10 = *(void *)(a3 + 8);
  uint64_t v11 = *(void *)(a2 + 8);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v10,  a1,  &protocol requirements base descriptor for DeviceDriver);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a3,  a1,  AssociatedTypeWitness,  &protocol requirements base descriptor for IO80211Driver,  &associated conformance descriptor for IO80211Driver.DeviceDriver.Device: IO80211Device);
  sub_1000A063C(223LL, v9, a1, v9, v10, v11, AssociatedConformanceWitness);
  memcpy(__dst, __src, 0xE80uLL);
  sub_1000AA6B0((uint64_t)__dst);
  sub_1000586C0((uint64_t)__dst, (uint64_t)v17, &qword_100406950);
  return sub_1000586C0((uint64_t)v17, a4, &qword_100406950);
}

uint64_t sub_1000951CC@<X0>(uint64_t a1@<X8>)
{
  return sub_1000586C0((uint64_t)v5, a1, &qword_100406958);
}

uint64_t IO80211Driver<>.lowLatencyStatistics.getter@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v9 = v8;
  uint64_t v10 = *(void *)(a3 + 8);
  uint64_t v11 = *(void *)(a2 + 8);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v10,  a1,  &protocol requirements base descriptor for DeviceDriver);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a3,  a1,  AssociatedTypeWitness,  &protocol requirements base descriptor for IO80211Driver,  &associated conformance descriptor for IO80211Driver.DeviceDriver.Device: IO80211Device);
  sub_1000A063C(343LL, v9, a1, v9, v10, v11, AssociatedConformanceWitness);
  memcpy(__dst, __src, 0xFB0uLL);
  NANBitmap.Channel.operatingClass.getter(__dst);
  sub_1000586C0((uint64_t)__dst, (uint64_t)v17, &qword_100406958);
  return sub_1000586C0((uint64_t)v17, a4, &qword_100406958);
}

uint64_t sub_1000953BC@<X0>(uint64_t a1@<X8>)
{
  return sub_1000953DC(a1);
}

uint64_t sub_1000953DC@<X0>(uint64_t a1@<X8>)
{
  uint64_t v4 = (unsigned __int8 *)swift_slowAlloc(14LL, -1LL);
  *(void *)uint64_t v4 = 0LL;
  *(void *)(v4 + 6) = 0LL;
  uint64_t v5 = v1[5];
  uint64_t v6 = v1[2];
  uint64_t v7 = v1[3];
  swift_retain();
  swift_bridgeObjectRetain(v7);
  AppleDevice.getRequest(requestType:data:on:)(0x143uLL, (uint64_t)v4, (uint64_t)(v4 + 14), 0, v6, v7);
  swift_bridgeObjectRelease(v7);
  swift_release(v5);
  if (v2) {
    return swift_slowDealloc(v4, -1LL, -1LL);
  }
  uint64_t v9 = *v4;
  uint64_t v10 = v4[1];
  unsigned __int8 v26 = v4[2];
  uint64_t v11 = *((unsigned __int16 *)v4 + 2);
  int v12 = v4[6];
  uint64_t v13 = v4[7];
  uint64_t v27 = v4[8];
  uint64_t v28 = v4[9];
  uint64_t v29 = v4[10];
  uint64_t v30 = v4[11];
  uint64_t v32 = v4[12];
  uint64_t v14 = v4[3];
  swift_slowDealloc(v4, -1LL, -1LL);
  uint64_t v15 = NANBitmap.Band.bands.getter(v14);
  uint64_t v16 = sub_100002274(&qword_100404AE0);
  uint64_t inited = swift_initStackObject(v16, v31);
  *(_OWORD *)(inited + 16) = xmmword_10033B810;
  *(_BYTE *)(inited + 32) = sub_1001A05B0(v9, 0LL, 4LL);
  unsigned __int8 v18 = sub_1001A05B0(v10, 4LL, 4LL);
  *(_BYTE *)(inited + 33) = v18;
  char v19 = *(_BYTE *)(inited + 32);
  swift_bridgeObjectRelease(inited);
  else {
    unsigned __int8 v20 = 0;
  }
  char v25 = v20 | v19;
  uint64_t v21 = (int *)type metadata accessor for NANDriverCapabilities(0LL);
  char v22 = (void *)(a1 + v21[8]);
  *char v22 = v11;
  uint64_t v23 = enum case for DispatchTimeInterval.milliseconds(_:);
  uint64_t v24 = type metadata accessor for DispatchTimeInterval(0LL);
  uint64_t result = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)(v24 - 8) + 104LL))(v22, v23, v24);
  *(void *)a1 = v15;
  *(void *)(a1 + 8) = &off_1003D6E90;
  *(_BYTE *)(a1 + 16) = v26;
  *(_BYTE *)(a1 + 17) = v25;
  *(void *)(a1 + v21[9]) = v13;
  *(void *)(a1 + v21[10]) = v27;
  *(void *)(a1 + v21[11]) = v28;
  *(void *)(a1 + v21[12]) = v29;
  *(void *)(a1 + v21[13]) = v30;
  *(void *)(a1 + v21[14]) = v32;
  *(_BYTE *)(a1 + v21[15]) = v12 != 0;
  return result;
}

uint64_t IO80211Driver<>.initializeNAN()@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v10 = v9;
  uint64_t v11 = *(void *)(a2 + 8);
  uint64_t v12 = *(void *)(a3 + 16);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v11,  a1,  &protocol requirements base descriptor for DeviceDriver);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a2,  a1,  AssociatedTypeWitness,  &protocol requirements base descriptor for IO80211Driver,  &associated conformance descriptor for IO80211Driver.DeviceDriver.Device: IO80211Device);
  uint64_t result = sub_1000A063C(323LL, v10, a1, v10, v11, v12, AssociatedConformanceWitness);
  if (!v4)
  {
    uint64_t v16 = v37[34];
    uint64_t v17 = v37[35];
    char v32 = v37[36];
    uint64_t v18 = v38;
    int v19 = v39;
    uint64_t v20 = v40;
    uint64_t v33 = v41;
    uint64_t v34 = v42;
    uint64_t v35 = v43;
    uint64_t v36 = v44;
    uint64_t v46 = v45;
    uint64_t v21 = NANBitmap.Band.bands.getter(v37[37]);
    uint64_t v22 = sub_100002274(&qword_100404AE0);
    uint64_t inited = swift_initStackObject(v22, v37);
    *(void *)(inited + 24) = 4LL;
    *(_BYTE *)(inited + 32) = sub_1001A05B0(v16, 0LL, 4LL);
    unsigned __int8 v24 = sub_1001A05B0(v17, 4LL, 4LL);
    *(_BYTE *)(inited + 33) = v24;
    char v25 = *(_BYTE *)(inited + 32);
    else {
      unsigned __int8 v26 = 0;
    }
    char v31 = v26 | v25;
    swift_setDeallocating(inited);
    uint64_t v27 = (int *)type metadata accessor for NANDriverCapabilities(0LL);
    uint64_t v28 = (void *)(a4 + v27[8]);
    *uint64_t v28 = v18;
    uint64_t v29 = enum case for DispatchTimeInterval.milliseconds(_:);
    uint64_t v30 = type metadata accessor for DispatchTimeInterval(0LL);
    uint64_t result = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)(v30 - 8) + 104LL))(v28, v29, v30);
    *(void *)a4 = v21;
    *(void *)(a4 + 8) = &off_1003D6EB8;
    *(_BYTE *)(a4 + 16) = v32;
    *(_BYTE *)(a4 + 17) = v31;
    *(void *)(a4 + v27[9]) = v20;
    *(void *)(a4 + v27[10]) = v33;
    *(void *)(a4 + v27[11]) = v34;
    *(void *)(a4 + v27[12]) = v35;
    *(void *)(a4 + v27[13]) = v36;
    *(void *)(a4 + v27[14]) = v46;
    *(_BYTE *)(a4 + v27[15]) = v19 != 0;
  }

  return result;
}

BOOL sub_1000958D8()
{
  return sub_1000A02F0(0x10CuLL) != 0;
}

BOOL IO80211Driver<>.nanState.getter(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v7 = v6;
  uint64_t v8 = *(void *)(a2 + 8);
  uint64_t v9 = *(void *)(a3 + 16);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v8,  a1,  &protocol requirements base descriptor for DeviceDriver);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a2,  a1,  AssociatedTypeWitness,  &protocol requirements base descriptor for IO80211Driver,  &associated conformance descriptor for IO80211Driver.DeviceDriver.Device: IO80211Device);
  sub_1000A063C(268LL, v7, a1, v7, v8, v9, AssociatedConformanceWitness);
  return v13 != 0;
}

uint64_t sub_100095A00(char a1)
{
  return sub_10004EDA4(0x10CuLL, a1 & 1);
}

uint64_t IO80211Driver<>.update(nanState:)(char a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  char v14 = a1 & 1;
  type metadata accessor for apple80211_nan_enable(0LL);
  uint64_t v8 = v7;
  uint64_t v9 = *(void *)(a3 + 8);
  uint64_t v10 = *(void *)(a4 + 16);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v9,  a2,  &protocol requirements base descriptor for DeviceDriver);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a3,  a2,  AssociatedTypeWitness,  &protocol requirements base descriptor for IO80211Driver,  &associated conformance descriptor for IO80211Driver.DeviceDriver.Device: IO80211Device);
  return sub_1000A0728(268LL, (uint64_t)&v14, a2, v8, v9, v10, AssociatedConformanceWitness);
}

unint64_t sub_100095AE4()
{
  return v2 | ((unint64_t)v3 << 32) | ((unint64_t)v4 << 40);
}

unint64_t IO80211Driver<>.clusterID.getter(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v7 = v6;
  uint64_t v8 = *(void *)(a2 + 8);
  uint64_t v9 = *(void *)(a3 + 16);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v8,  a1,  &protocol requirements base descriptor for DeviceDriver);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a2,  a1,  AssociatedTypeWitness,  &protocol requirements base descriptor for IO80211Driver,  &associated conformance descriptor for IO80211Driver.DeviceDriver.Device: IO80211Device);
  sub_1000A063C(270LL, v7, a1, v7, v8, v9, AssociatedConformanceWitness);
  return v13 | ((unint64_t)v14 << 32) | ((unint64_t)v15 << 40);
}

uint64_t sub_100095C4C(uint64_t a1)
{
  return sub_10004EDEC( 0x10EuLL,  a1 & 0xFFFFFFFFFF00LL | ((unint64_t)a1 << 48) & 0xFFFFFFFFFFFF00LL | ((unint64_t)BYTE1(a1) << 56) | a1,  WORD1(a1));
}

uint64_t IO80211Driver<>.update(clusterID:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  __int16 v14 = a1;
  char v15 = BYTE2(a1);
  char v16 = BYTE3(a1);
  char v17 = BYTE4(a1);
  char v18 = BYTE5(a1);
  __int16 v19 = a1;
  char v20 = BYTE2(a1);
  char v21 = BYTE3(a1);
  char v22 = BYTE4(a1);
  char v23 = BYTE5(a1);
  type metadata accessor for apple80211_nan_cluster_id(0LL);
  uint64_t v8 = v7;
  uint64_t v9 = *(void *)(a3 + 8);
  uint64_t v10 = *(void *)(a4 + 16);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v9,  a2,  &protocol requirements base descriptor for DeviceDriver);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a3,  a2,  AssociatedTypeWitness,  &protocol requirements base descriptor for IO80211Driver,  &associated conformance descriptor for IO80211Driver.DeviceDriver.Device: IO80211Device);
  return sub_1000A0728(270LL, (uint64_t)&v14, a2, v8, v9, v10, AssociatedConformanceWitness);
}

uint64_t sub_100095D88()
{
  unsigned __int8 v0 = (unsigned __int16)sub_1000A021C(0x119uLL) >> 8;
  return sub_1000A021C(0x11AuLL) & 0xFF00 | v0;
}

uint64_t IO80211Driver<>.electionMetric.getter(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v7 = v6;
  uint64_t v8 = *(void *)(a2 + 8);
  uint64_t v9 = *(void *)(a3 + 16);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v8,  a1,  &protocol requirements base descriptor for DeviceDriver);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a2,  a1,  AssociatedTypeWitness,  &protocol requirements base descriptor for IO80211Driver,  &associated conformance descriptor for IO80211Driver.DeviceDriver.Device: IO80211Device);
  sub_1000A063C(281LL, v7, a1, v7, v8, v9, AssociatedConformanceWitness);
  type metadata accessor for apple80211_nan_random_factor(0LL);
  sub_1000A063C(282LL, v12, a1, v12, v8, v9, AssociatedConformanceWitness);
  return v15 | (v14 << 8);
}

uint64_t sub_100095F18(__int16 a1)
{
  uint64_t result = sub_10004EEFC(0x119uLL, a1 | (unsigned __int16)(a1 << 8));
  if (!v1) {
    return sub_10004EEFC(0x11AuLL, a1 & 0xFF00u | HIBYTE(a1));
  }
  return result;
}

uint64_t IO80211Driver<>.update(electionMetric:)(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  char v8 = HIBYTE(a1);
  v18[0] = a1;
  v18[1] = a1;
  type metadata accessor for apple80211_nan_master_pref(0LL);
  uint64_t v10 = v9;
  uint64_t v11 = *(void *)(a3 + 8);
  uint64_t v12 = *(void *)(a4 + 16);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v11,  a2,  &protocol requirements base descriptor for DeviceDriver);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a3,  a2,  AssociatedTypeWitness,  &protocol requirements base descriptor for IO80211Driver,  &associated conformance descriptor for IO80211Driver.DeviceDriver.Device: IO80211Device);
  uint64_t result = sub_1000A0728(281LL, (uint64_t)v18, a2, v10, v11, v12, AssociatedConformanceWitness);
  if (!v4)
  {
    v17[0] = v8;
    v17[1] = v8;
    type metadata accessor for apple80211_nan_random_factor(0LL);
    return sub_1000A0728(282LL, (uint64_t)v17, a2, v16, v11, v12, AssociatedConformanceWitness);
  }

  return result;
}

uint64_t sub_100096068()
{
  return sub_100096088();
}

uint64_t sub_100096088()
{
  __int16 v0 = sub_1000A021C(0x111uLL);
  uint64_t v1 = HIBYTE(v0);
  unsigned __int8 v2 = _s7CoreP2P18NANAwakeDWIntervalO8intervalACSgAA11NANTimeUnitV_tcfC_0(v0);
  if (v2 == 5) {
    unsigned __int8 v3 = 0;
  }
  else {
    unsigned __int8 v3 = v2;
  }
  int v4 = _s7CoreP2P18NANAwakeDWIntervalO8intervalACSgAA11NANTimeUnitV_tcfC_0(v1);
  else {
    int v5 = v4;
  }
  return v3 | (v5 << 8);
}

uint64_t IO80211Driver<>.dwAwakePeriods.getter(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v7 = v6;
  uint64_t v8 = *(void *)(a2 + 8);
  uint64_t v9 = *(void *)(a3 + 16);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v8,  a1,  &protocol requirements base descriptor for DeviceDriver);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a2,  a1,  AssociatedTypeWitness,  &protocol requirements base descriptor for IO80211Driver,  &associated conformance descriptor for IO80211Driver.DeviceDriver.Device: IO80211Device);
  sub_1000A063C(273LL, v7, a1, v7, v8, v9, AssociatedConformanceWitness);
  unsigned __int8 v12 = _s7CoreP2P18NANAwakeDWIntervalO8intervalACSgAA11NANTimeUnitV_tcfC_0(v17);
  if (v12 == 5) {
    unsigned __int8 v13 = 0;
  }
  else {
    unsigned __int8 v13 = v12;
  }
  int v14 = _s7CoreP2P18NANAwakeDWIntervalO8intervalACSgAA11NANTimeUnitV_tcfC_0(v18);
  else {
    int v15 = v14;
  }
  return v13 | (v15 << 8);
}

void sub_100096208(char a1)
{
}

void sub_100096228(char a1)
{
  __asm { BR              X12 }

uint64_t sub_100096274(unsigned int a1)
{
  v6[0] = 1;
  v6[1] = 0x1008040100uLL >> ((a1 >> 5) & 0xF8);
  uint64_t v2 = v1[5];
  uint64_t v3 = v1[2];
  uint64_t v4 = v1[3];
  swift_retain();
  swift_bridgeObjectRetain(v4);
  AppleDevice.setRequest(requestType:data:on:)(0x111uLL, (uint64_t)v6, (uint64_t)&v7, 0, v3, v4);
  swift_bridgeObjectRelease(v4);
  return swift_release(v2);
}

void IO80211Driver<>.update(dwAwakePeriods:)(char a1)
{
  __asm { BR              X12 }

uint64_t sub_100096384(unsigned int a1)
{
  v11[0] = 1;
  v11[1] = 0x1008040100uLL >> ((a1 >> 5) & 0xF8);
  type metadata accessor for apple80211_nan_dw_awake_period(0LL);
  uint64_t v5 = v4;
  uint64_t v6 = *(void *)(v2 + 8);
  uint64_t v7 = *(void *)(v3 + 16);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v6,  v1,  &protocol requirements base descriptor for DeviceDriver);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v2,  v1,  AssociatedTypeWitness,  &protocol requirements base descriptor for IO80211Driver,  &associated conformance descriptor for IO80211Driver.DeviceDriver.Device: IO80211Device);
  return sub_1000A0728(273LL, (uint64_t)v11, v1, v5, v6, v7, AssociatedConformanceWitness);
}

unint64_t sub_100096448(uint64_t a1, uint64_t a2)
{
  return sub_1000964A8(a1, a2, 0x11FuLL);
}

unint64_t IO80211Driver<>.primaryChannel.getter(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_100096510( a1,  a2,  a3,  (uint64_t (*)(void))type metadata accessor for apple80211_nan_primary_master_channel,  287LL);
}

uint64_t sub_100096460(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_100096610(a1, a2, a3, 287LL, (uint64_t (*)(uint64_t, uint64_t))sub_10004EDA4);
}

uint64_t IO80211Driver<>.update(primaryChannel:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return sub_1000966C8( a1,  a2,  a3,  a4,  (uint64_t (*)(void))type metadata accessor for apple80211_nan_primary_master_channel,  287LL);
}

unint64_t sub_1000964A0(uint64_t a1, uint64_t a2)
{
  return sub_1000964A8(a1, a2, 0x120uLL);
}

unint64_t sub_1000964A8(uint64_t a1, uint64_t a2, unint64_t a3)
{
  unsigned __int8 v3 = sub_1000A02F0(a3);
  return sub_1001889D8(v3) & 0xFFFFFFFFFFFFLL;
}

unint64_t IO80211Driver<>.secondaryChannel.getter(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_100096510( a1,  a2,  a3,  (uint64_t (*)(void))type metadata accessor for apple80211_nan_secondary_master_channel,  288LL);
}

unint64_t sub_100096510( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t (*a4)(void), uint64_t a5)
{
  uint64_t v9 = a4(0LL);
  uint64_t v10 = *(void *)(a2 + 8);
  uint64_t v11 = *(void *)(a3 + 16);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v10,  a1,  &protocol requirements base descriptor for DeviceDriver);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a2,  a1,  AssociatedTypeWitness,  &protocol requirements base descriptor for IO80211Driver,  &associated conformance descriptor for IO80211Driver.DeviceDriver.Device: IO80211Device);
  sub_1000A063C(a5, v9, a1, v9, v10, v11, AssociatedConformanceWitness);
  return sub_1001889D8(v15) & 0xFFFFFFFFFFFFLL;
}

uint64_t sub_1000965F0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_100096610(a1, a2, a3, 288LL, (uint64_t (*)(uint64_t, uint64_t))sub_10004EDA4);
}

uint64_t sub_100096610( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t (*a5)(uint64_t, uint64_t))
{
  if ((a1 & 0xFF00000000LL) == 0x300000000LL)
  {
    uint64_t v5 = 0LL;
    return a5(a4, v5);
  }

  uint64_t v5 = a1;
  uint64_t result = _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  "Not enough bits to represent the passed value",  45LL,  2LL,  "Swift/Integers.swift",  20LL,  2,  3455LL,  0);
  __break(1u);
  return result;
}

uint64_t IO80211Driver<>.update(secondaryChannel:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return sub_1000966C8( a1,  a2,  a3,  a4,  (uint64_t (*)(void))type metadata accessor for apple80211_nan_secondary_master_channel,  288LL);
}

uint64_t sub_1000966C8( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t (*a5)(void), uint64_t a6)
{
  if ((a1 & 0xFF00000000LL) == 0x300000000LL)
  {
    LOBYTE(a1) = 0;
LABEL_4:
    char v16 = a1;
    uint64_t v10 = a5(0LL);
    uint64_t v11 = *(void *)(a3 + 8);
    uint64_t v12 = *(void *)(a4 + 16);
    uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v11,  a2,  &protocol requirements base descriptor for DeviceDriver);
    uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a3,  a2,  AssociatedTypeWitness,  &protocol requirements base descriptor for IO80211Driver,  &associated conformance descriptor for IO80211Driver.DeviceDriver.Device: IO80211Device);
    return sub_1000A0728(a6, (uint64_t)&v16, a2, v10, v11, v12, AssociatedConformanceWitness);
  }

  uint64_t result = _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  "Not enough bits to represent the passed value",  45LL,  2LL,  "Swift/Integers.swift",  20LL,  2,  3455LL,  0);
  __break(1u);
  return result;
}

BOOL sub_1000967F4()
{
  return sub_1000A02F0(0x113uLL) != 0;
}

BOOL IO80211Driver<>.hostElection.getter(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v7 = v6;
  uint64_t v8 = *(void *)(a2 + 8);
  uint64_t v9 = *(void *)(a3 + 16);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v8,  a1,  &protocol requirements base descriptor for DeviceDriver);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a2,  a1,  AssociatedTypeWitness,  &protocol requirements base descriptor for IO80211Driver,  &associated conformance descriptor for IO80211Driver.DeviceDriver.Device: IO80211Device);
  sub_1000A063C(275LL, v7, a1, v7, v8, v9, AssociatedConformanceWitness);
  return v13 != 0;
}

uint64_t sub_10009691C(char a1)
{
  return sub_10004EDA4(0x113uLL, a1 & 1);
}

uint64_t IO80211Driver<>.update(hostElection:)(char a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  char v14 = a1;
  type metadata accessor for apple80211_nan_host_election(0LL);
  uint64_t v8 = v7;
  uint64_t v9 = *(void *)(a3 + 8);
  uint64_t v10 = *(void *)(a4 + 16);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v9,  a2,  &protocol requirements base descriptor for DeviceDriver);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a3,  a2,  AssociatedTypeWitness,  &protocol requirements base descriptor for IO80211Driver,  &associated conformance descriptor for IO80211Driver.DeviceDriver.Device: IO80211Device);
  return sub_1000A0728(275LL, (uint64_t)&v14, a2, v8, v9, v10, AssociatedConformanceWitness);
}

uint64_t sub_1000969FC(uint64_t a1)
{
  return sub_1000AA7C8(a1);
}

uint64_t IO80211Driver<>.transmitAllFrames(with:)(uint64_t a1)
{
  uint64_t v2 = v1;
  unint64_t v4 = sub_10000D9B0((uint64_t)_swiftEmptyArrayStorage);
  uint64_t v5 = type metadata accessor for BinaryEncoder();
  uint64_t v6 = (uint64_t *)swift_allocObject(v5, 40LL, 7LL);
  *((_OWORD *)v6 + 1) = xmmword_1003398F0;
  v6[4] = v4;
  v11[3] = v5;
  unint64_t v11[4] = sub_10000AF70( (unint64_t *)&qword_1004064B0,  (uint64_t (*)(uint64_t))type metadata accessor for BinaryEncoder,  (uint64_t)&protocol conformance descriptor for BinaryEncoder);
  v11[0] = v6;
  uint64_t v7 = type metadata accessor for NANAttribute(0LL);
  uint64_t v8 = sub_10000AF70( &qword_100406960,  type metadata accessor for NANAttribute,  (uint64_t)&protocol conformance descriptor for NANAttribute);
  swift_bridgeObjectRetain(a1);
  swift_retain();
  Array<A>.encode(to:)(v11, a1, v7, v8);
  sub_100002AC4(v11);
  if (!v2)
  {
    swift_bridgeObjectRelease(a1);
    swift_beginAccess(v6 + 2, v11, 0LL, 0LL);
    unint64_t v10 = v6[3];
    sub_100020AFC(v6[2], v10);
    swift_release(v6);
    __asm { BR              X9 }
  }

  swift_release(v6);
  return swift_bridgeObjectRelease(a1);
}

uint64_t sub_100096DA8(unsigned __int8 *a1)
{
  return sub_100096DC8(a1);
}

uint64_t sub_100096DC8(unsigned __int8 *a1)
{
  unint64_t v2 = *a1;
  uint64_t v3 = *((void *)a1 + 3);
  uint64_t v4 = *((void *)a1 + 4);
  unsigned __int8 v5 = a1[1];
  if (v2 >= 5) {
    char v6 = 3;
  }
  else {
    char v6 = 0x201000303uLL >> (8 * v2);
  }
  unsigned __int8 v7 = a1[16];
  int v8 = *((_DWORD *)a1 + 5);
  __int16 v9 = *((_WORD *)a1 + 3);
  v14[0] = v6;
  v14[4] = v5;
  v14[5] = v7;
  int v15 = 0;
  __int16 v16 = 0;
  int v17 = *(_DWORD *)(a1 + 2);
  __int16 v18 = v9;
  __int16 v19 = 0;
  int v20 = HIDWORD(v3);
  int v21 = v3;
  int v22 = HIDWORD(v4);
  int v23 = v4;
  uint64_t v24 = *((void *)a1 + 1);
  int v25 = v8;
  uint64_t v10 = v1[5];
  uint64_t v11 = v1[2];
  uint64_t v12 = v1[3];
  swift_retain();
  swift_bridgeObjectRetain(v12);
  AppleDevice.setRequest(requestType:data:on:)(0x14BuLL, (uint64_t)v14, (uint64_t)&v26, 0, v11, v12);
  swift_bridgeObjectRelease(v12);
  return swift_release(v10);
}

uint64_t IO80211Driver<>.update(electionParameters:)(unsigned __int8 *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v7 = *a1;
  uint64_t v8 = *((void *)a1 + 3);
  uint64_t v9 = *((void *)a1 + 4);
  unsigned __int8 v10 = a1[1];
  unsigned __int8 v11 = a1[16];
  int v12 = *((_DWORD *)a1 + 5);
  if (v7 >= 5) {
    char v13 = 3;
  }
  else {
    char v13 = 0x201000303uLL >> (8 * v7);
  }
  __int16 v14 = *((_WORD *)a1 + 3);
  v22[0] = v13;
  v22[4] = v10;
  v22[5] = v11;
  int v23 = 0;
  __int16 v24 = 0;
  int v25 = *(_DWORD *)(a1 + 2);
  __int16 v26 = v14;
  __int16 v27 = 0;
  int v28 = HIDWORD(v8);
  int v29 = v8;
  int v30 = HIDWORD(v9);
  int v31 = v9;
  uint64_t v32 = *((void *)a1 + 1);
  int v33 = v12;
  type metadata accessor for apple80211_nan_role_cfg(0LL);
  uint64_t v16 = v15;
  uint64_t v17 = *(void *)(a3 + 8);
  uint64_t v18 = *(void *)(a4 + 16);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v17,  a2,  &protocol requirements base descriptor for DeviceDriver);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a3,  a2,  AssociatedTypeWitness,  &protocol requirements base descriptor for IO80211Driver,  &associated conformance descriptor for IO80211Driver.DeviceDriver.Device: IO80211Device);
  return sub_1000A0728(331LL, (uint64_t)v22, a2, v16, v17, v18, AssociatedConformanceWitness);
}

uint64_t sub_100097020(uint64_t a1)
{
  return sub_100097040(a1);
}

uint64_t sub_100097040(uint64_t a1)
{
  uint64_t v2 = type metadata accessor for DispatchTimeInterval(0LL);
  uint64_t v66 = *(void *)(v2 - 8);
  uint64_t v67 = v2;
  __chkstk_darwin(v2);
  unsigned int v65 = (void **)((char *)&v63 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0LL));
  char v73 = (void *)type metadata accessor for SHA256Digest(0LL);
  uint64_t v71 = *(v73 - 1);
  __chkstk_darwin(v73);
  unsigned __int8 v5 = (char *)&v63 - ((v4 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  char v6 = (void *)type metadata accessor for SHA256(0LL);
  unint64_t v69 = *(v6 - 1);
  char v70 = v6;
  __chkstk_darwin(v6);
  uint64_t v8 = (char *)&v63 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  char v91 = 0;
  memset(v79, 0, sizeof(v79));
  bzero(&v80, 0xCA9uLL);
  memset(v92, 0, sizeof(v92));
  memset(&v93[3], 0, 22);
  HIBYTE(v90) = *(_BYTE *)a1;
  uint64_t v9 = *(void *)(a1 + 16);
  uint64_t v68 = *(void *)(a1 + 8);
  uint64_t v64 = a1;
  uint64_t v10 = swift_bridgeObjectRetain(v9);
  SHA256.init()(v10);
  Swift::String v11 = String.lowercased()();
  swift_bridgeObjectRelease(v9);
  swift_bridgeObjectRetain(v11._object);
  uint64_t v12 = v72;
  sub_10016B208( v11._countAndFlagsBits,  (uint64_t)v11._object,  (uint64_t)v8,  v11._countAndFlagsBits,  (uint64_t)v11._object,  v13);
  uint64_t v14 = swift_bridgeObjectRelease(v11._object);
  SHA256.finalize()(v14);
  SHA256Digest.withUnsafeBytes<A>(_:)(v96, sub_10016BB10, 0LL, &type metadata for Data);
  (*(void (**)(char *, void *))(v71 + 8))(v5, v73);
  uint64_t v15 = v96[0];
  unint64_t v16 = v96[1];
  (*(void (**)(char *, _BYTE *))(v69 + 8))(v8, v70);
  v96[0] = v15;
  v96[1] = v16;
  unint64_t v17 = sub_10005D508();
  DataProtocol.copyBytes(to:)(v79, &v79[6], &type metadata for Data, v17);
  sub_1000208D8(v15, v16);
  uint64_t KeyPath = swift_getKeyPath(&unk_10033EA88);
  char v70 = &v79[6];
  v94[2] = &v79[6];
  v94[3] = KeyPath;
  v94[4] = 255LL;
  uint64_t v19 = (uint64_t)sub_10003B5A4( (void *(*)(uint64_t *__return_ptr, void *))sub_100054614,  (uint64_t)v94,  v68,  v9);
  swift_release(KeyPath);
  uint64_t v20 = 254LL;
  if (v19 < 254) {
    uint64_t v20 = v19;
  }
  if (v20 < 0)
  {
    __break(1u);
LABEL_33:
    __break(1u);
    goto LABEL_34;
  }

  unint64_t v69 = v17;
  char v73 = v83;
  __int16 v80 = v20;
  int v21 = (int *)type metadata accessor for NANSubscribe.Configuration(0LL);
  uint64_t v22 = v64;
  int v23 = (unsigned __int8 *)(v64 + v21[12]);
  uint64_t v24 = *((void *)v23 + 1);
  uint64_t v72 = v12;
  uint64_t v25 = *v23;
  uint64_t v26 = swift_getKeyPath(&unk_10033EAA8);
  uint64_t v27 = swift_getKeyPath(&unk_10033EAC8);
  sub_1000A2EDC(v79, v26, v27, v25, v24);
  swift_release(v26);
  swift_release(v27);
  int v28 = (unsigned __int8 *)(v22 + v21[11]);
  uint64_t v29 = *((void *)v28 + 1);
  uint64_t v30 = *v28;
  uint64_t v31 = swift_getKeyPath(&unk_10033EAE8);
  uint64_t v32 = swift_getKeyPath(&unk_10033EB08);
  sub_1000A2EDC(v79, v31, v32, v30, v29);
  swift_release(v31);
  swift_release(v32);
  LODWORD(v71) = NANSubscribe.Configuration.serviceInfo.getter();
  uint64_t v34 = v33;
  unint64_t v36 = v35;
  sub_100020AFC(v33, v35);
  unint64_t v37 = sub_10000D9B0((uint64_t)_swiftEmptyArrayStorage);
  uint64_t v38 = type metadata accessor for BinaryEncoder();
  uint64_t v39 = swift_allocObject(v38, 40LL, 7LL);
  *(_OWORD *)(v39 + 16) = xmmword_1003398F0;
  *(void *)(v39 + 32) = v37;
  v96[3] = v38;
  v96[4] = sub_10000AF70( (unint64_t *)&qword_1004064B0,  (uint64_t (*)(uint64_t))type metadata accessor for BinaryEncoder,  (uint64_t)&protocol conformance descriptor for BinaryEncoder);
  v96[0] = v39;
  sub_100020AFC(v34, v36);
  swift_retain();
  uint64_t v40 = v72;
  NANServiceInfo.encode(to:)((uint64_t)v96, v71, v34, v36);
  if (v40)
  {
    sub_100002AC4(v96);
    sub_1000208D8(v34, v36);
    sub_1000208D8(v34, v36);
    swift_release(v39);
    swift_errorRelease(v40);
    sub_1000208D8(v34, v36);
    uint64_t v72 = 0LL;
  }

  else
  {
    uint64_t v72 = 0LL;
    sub_100002AC4(v96);
    sub_1000208D8(v34, v36);
    sub_1000208D8(v34, v36);
    swift_beginAccess(v39 + 16, &v95, 0LL, 0LL);
    uint64_t v41 = *(void *)(v39 + 16);
    unint64_t v42 = *(void *)(v39 + 24);
    sub_100020AFC(v41, v42);
    swift_release(v39);
    sub_1000208D8(v34, v36);
    sub_1000AAB60(v41, v42);
    memcpy(v73, v74, 0x802uLL);
  }

  if (*(_BYTE *)(v22 + 32)) {
    char v43 = 2;
  }
  else {
    char v43 = 1;
  }
  LOBYTE(v90) = v43;
  HIBYTE(v89) = *(_BYTE *)(v22 + v21[13]);
  char v91 = 0x1008040100uLL >> (8 * *(_BYTE *)(v22 + v21[10]));
  uint64_t v44 = sub_100172848();
  uint64_t v46 = v65;
  uint64_t v45 = v66;
  *unsigned int v65 = 0x80000LL;
  uint64_t v47 = v67;
  (*(void (**)(void *, void, uint64_t))(v45 + 104))( v46,  enum case for DispatchTimeInterval.microseconds(_:),  v67);
  uint64_t v48 = sub_100172848();
  (*(void (**)(void *, uint64_t))(v45 + 8))(v46, v47);
  if (!v48) {
    goto LABEL_33;
  }
  if (v44 == 0x8000000000000000LL && v48 == -1) {
LABEL_34:
  }
    __break(1u);
  if (((v44 / v48) & 0x8000000000000000LL) == 0)
  {
    if ((unint64_t)(v44 / v48) >> 32)
    {
LABEL_36:
      uint64_t result = _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  "Not enough bits to represent the passed value",  45LL,  2LL,  "Swift/Integers.swift",  20LL,  2,  3455LL,  0);
      goto LABEL_37;
    }

    uint64_t v71 = v44 / v48;
    uint64_t v49 = v21[14];
    if (*(_BYTE *)(v22 + 33)) {
      int v50 = 194;
    }
    else {
      int v50 = 192;
    }
    if (*(_BYTE *)(v22 + 33)) {
      int v51 = 2;
    }
    else {
      int v51 = 0;
    }
    if (*(_BYTE *)(v22 + v21[15])) {
      int v52 = v50;
    }
    else {
      int v52 = v51;
    }
    uint64_t v53 = (uint64_t *)(v22 + v49);
    __int16 v54 = *(_WORD *)(v22 + v49 + 16);
    if ((v54 & 0xFF00) == 0x200) {
      goto LABEL_31;
    }
    uint64_t v55 = *v53;
    unint64_t v56 = v53[1];
    v96[0] = v55;
    v96[1] = v56;
    sub_100020AFC(v55, v56);
    unint64_t v57 = DataProtocol.copyBytes(to:)(&v92[5], v93, &type metadata for Data, v69);
    if ((v57 & 0x8000000000000000LL) == 0)
    {
      if (!HIDWORD(v57))
      {
        *(_DWORD *)unint64_t v92 = v57;
        sub_1000AA7B4(v55, v56, v54);
        v92[4] = v54;
        if ((v54 & 0x100) != 0) {
          int v58 = 8;
        }
        else {
          int v58 = 12;
        }
        v52 |= v58;
LABEL_31:
        LODWORD(v69) = v52;
        memcpy((char *)v96 + 6, v70, 0x102uLL);
        memcpy(v97, v81, sizeof(v97));
        memcpy(v98, v82, sizeof(v98));
        memcpy(v99, v73, sizeof(v99));
        LODWORD(v96[0]) = *(_DWORD *)v79;
        WORD2(v96[0]) = *(_WORD *)&v79[4];
        __int128 v100 = *(_OWORD *)&v83[2050];
        __int128 v101 = v84;
        __int128 v102 = v85;
        __int128 v103 = v86;
        __int128 v104 = v87;
        __int128 v105 = v88;
        int v106 = v89;
        __int16 v107 = v90;
        char v108 = v91;
        __int16 v109 = v77;
        char v110 = v78;
        int v111 = *(_DWORD *)v92;
        __int128 v112 = *(_OWORD *)&v92[4];
        __int128 v113 = *(_OWORD *)&v92[20];
        __int128 v114 = *(_OWORD *)&v92[36];
        __int128 v115 = *(_OWORD *)&v92[52];
        char v116 = v92[68];
        __int16 v117 = v75;
        char v118 = v76;
        int v119 = *(_DWORD *)&v93[3];
        int v120 = v71;
        int v121 = -1;
        int v122 = v52;
        int v123 = *(_DWORD *)&v93[19];
        __int16 v124 = *(_WORD *)&v93[23];
        uint64_t v59 = v63[5];
        uint64_t v60 = v63[2];
        uint64_t v61 = v63[3];
        swift_retain();
        swift_bridgeObjectRetain(v61);
        AppleDevice.setRequest(requestType:data:on:)(0x12FuLL, (uint64_t)v96, (uint64_t)&v125, 0, v60, v61);
        swift_bridgeObjectRelease(v61);
        return swift_release(v59);
      }

      goto LABEL_36;
    }
  }

  uint64_t result = _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  "Negative value is not representable",  35LL,  2LL,  "Swift/Integers.swift",  20LL,  2,  3451LL,  0);
LABEL_37:
  __break(1u);
  return result;
}

uint64_t IO80211Driver<>.start(configuration:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v74 = a2;
  uint64_t v72 = a4;
  uint64_t v73 = a3;
  uint64_t v5 = type metadata accessor for DispatchTimeInterval(0LL);
  uint64_t v77 = *(void *)(v5 - 8);
  uint64_t v78 = v5;
  __chkstk_darwin(v5);
  char v76 = (unint64_t *)((char *)&v71 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0LL));
  uint64_t v7 = type metadata accessor for SHA256Digest(0LL);
  uint64_t v82 = *(void *)(v7 - 8);
  uint64_t v83 = v7;
  __chkstk_darwin(v7);
  uint64_t v9 = (char *)&v71 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v10 = (void *)type metadata accessor for SHA256(0LL);
  uint64_t v80 = *(v10 - 1);
  char v81 = v10;
  __chkstk_darwin(v10);
  uint64_t v12 = (char *)&v71 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  char v102 = 0;
  memset(v90, 0, sizeof(v90));
  bzero(&v91, 0xCA9uLL);
  memset(v103, 0, sizeof(v103));
  memset(&v104[3], 0, 22);
  HIBYTE(v101) = *(_BYTE *)a1;
  uint64_t v13 = *(void *)(a1 + 16);
  uint64_t v79 = *(void *)(a1 + 8);
  uint64_t v75 = a1;
  uint64_t v14 = swift_bridgeObjectRetain(v13);
  SHA256.init()(v14);
  Swift::String v15 = String.lowercased()();
  swift_bridgeObjectRelease(v13);
  swift_bridgeObjectRetain(v15._object);
  unint64_t v16 = v84;
  sub_10016B208( v15._countAndFlagsBits,  (uint64_t)v15._object,  (uint64_t)v12,  v15._countAndFlagsBits,  (uint64_t)v15._object,  v17);
  uint64_t v18 = swift_bridgeObjectRelease(v15._object);
  SHA256.finalize()(v18);
  SHA256Digest.withUnsafeBytes<A>(_:)(v107, sub_10016BB10, 0LL, &type metadata for Data);
  (*(void (**)(char *, uint64_t))(v82 + 8))(v9, v83);
  uint64_t v19 = v107[0];
  unint64_t v20 = v107[1];
  (*(void (**)(char *, _BYTE *))(v80 + 8))(v12, v81);
  v107[0] = v19;
  v107[1] = v20;
  unint64_t v71 = sub_10005D508();
  DataProtocol.copyBytes(to:)(v90, &v90[6], &type metadata for Data, v71);
  sub_1000208D8(v19, v20);
  uint64_t KeyPath = swift_getKeyPath(&unk_10033EA88);
  char v81 = &v90[6];
  v105[2] = &v90[6];
  v105[3] = KeyPath;
  v105[4] = 255LL;
  uint64_t v22 = (uint64_t)sub_10003B5A4( (void *(*)(uint64_t *__return_ptr, void *))sub_100054614,  (uint64_t)v105,  v79,  v13);
  swift_release(KeyPath);
  uint64_t v23 = 254LL;
  if (v22 < 254) {
    uint64_t v23 = v22;
  }
  if (v23 < 0)
  {
    __break(1u);
LABEL_33:
    __break(1u);
    goto LABEL_34;
  }

  __int128 v84 = v94;
  __int16 v91 = v23;
  uint64_t v24 = type metadata accessor for NANSubscribe.Configuration(0LL);
  uint64_t v25 = v75;
  uint64_t v26 = (unsigned __int8 *)(v75 + *(int *)(v24 + 48));
  uint64_t v27 = *((void *)v26 + 1);
  uint64_t v28 = *v26;
  uint64_t v29 = swift_getKeyPath(&unk_10033EAA8);
  uint64_t v30 = swift_getKeyPath(&unk_10033EAC8);
  sub_1000A2EDC(v90, v29, v30, v28, v27);
  swift_release(v29);
  swift_release(v30);
  uint64_t v83 = v24;
  uint64_t v31 = (unsigned __int8 *)(v25 + *(int *)(v24 + 44));
  uint64_t v32 = *((void *)v31 + 1);
  uint64_t v33 = *v31;
  uint64_t v34 = swift_getKeyPath(&unk_10033EAE8);
  uint64_t v35 = swift_getKeyPath(&unk_10033EB08);
  sub_1000A2EDC(v90, v34, v35, v33, v32);
  swift_release(v34);
  swift_release(v35);
  LODWORD(v82) = NANSubscribe.Configuration.serviceInfo.getter();
  uint64_t v37 = v36;
  unint64_t v39 = v38;
  sub_100020AFC(v36, v38);
  unint64_t v40 = sub_10000D9B0((uint64_t)_swiftEmptyArrayStorage);
  uint64_t v41 = type metadata accessor for BinaryEncoder();
  uint64_t v42 = swift_allocObject(v41, 40LL, 7LL);
  *(_OWORD *)(v42 + 16) = xmmword_1003398F0;
  *(void *)(v42 + 32) = v40;
  v107[3] = v41;
  v107[4] = sub_10000AF70( (unint64_t *)&qword_1004064B0,  (uint64_t (*)(uint64_t))type metadata accessor for BinaryEncoder,  (uint64_t)&protocol conformance descriptor for BinaryEncoder);
  v107[0] = v42;
  sub_100020AFC(v37, v39);
  swift_retain();
  NANServiceInfo.encode(to:)((uint64_t)v107, v82, v37, v39);
  if (v16)
  {
    sub_100002AC4(v107);
    sub_1000208D8(v37, v39);
    sub_1000208D8(v37, v39);
    swift_release(v42);
    swift_errorRelease(v16);
    sub_1000208D8(v37, v39);
    uint64_t v82 = 0LL;
  }

  else
  {
    uint64_t v82 = 0LL;
    sub_100002AC4(v107);
    sub_1000208D8(v37, v39);
    sub_1000208D8(v37, v39);
    swift_beginAccess(v42 + 16, &v106, 0LL, 0LL);
    uint64_t v43 = *(void *)(v42 + 16);
    unint64_t v44 = *(void *)(v42 + 24);
    sub_100020AFC(v43, v44);
    swift_release(v42);
    sub_1000208D8(v37, v39);
    sub_1000AAB60(v43, v44);
    memcpy(v84, v85, 0x802uLL);
  }

  if (*(_BYTE *)(v25 + 32)) {
    char v45 = 2;
  }
  else {
    char v45 = 1;
  }
  LOBYTE(v101) = v45;
  uint64_t v46 = v83;
  HIBYTE(v100) = *(_BYTE *)(v25 + *(int *)(v83 + 52));
  char v102 = 0x1008040100uLL >> (8 * *(_BYTE *)(v25 + *(int *)(v83 + 40)));
  uint64_t v47 = sub_100172848();
  uint64_t v49 = v76;
  uint64_t v48 = v77;
  *char v76 = 0x80000LL;
  uint64_t v50 = v78;
  (*(void (**)(void *, void, uint64_t))(v48 + 104))( v49,  enum case for DispatchTimeInterval.microseconds(_:),  v78);
  uint64_t v51 = sub_100172848();
  (*(void (**)(void *, uint64_t))(v48 + 8))(v49, v50);
  if (!v51) {
    goto LABEL_33;
  }
  if (v47 == 0x8000000000000000LL && v51 == -1) {
LABEL_34:
  }
    __break(1u);
  if (((v47 / v51) & 0x8000000000000000LL) == 0)
  {
    if ((unint64_t)(v47 / v51) >> 32)
    {
LABEL_36:
      uint64_t result = _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  "Not enough bits to represent the passed value",  45LL,  2LL,  "Swift/Integers.swift",  20LL,  2,  3455LL,  0);
      goto LABEL_37;
    }

    uint64_t v80 = v47 / v51;
    uint64_t v52 = *(int *)(v46 + 56);
    if (*(_BYTE *)(v25 + 33)) {
      int v53 = 194;
    }
    else {
      int v53 = 192;
    }
    if (*(_BYTE *)(v25 + 33)) {
      int v54 = 2;
    }
    else {
      int v54 = 0;
    }
    else {
      int v55 = v54;
    }
    unint64_t v56 = (uint64_t *)(v25 + v52);
    __int16 v57 = *(_WORD *)(v25 + v52 + 16);
    if ((v57 & 0xFF00) == 0x200) {
      goto LABEL_31;
    }
    uint64_t v58 = *v56;
    unint64_t v59 = v56[1];
    v107[0] = v58;
    v107[1] = v59;
    sub_100020AFC(v58, v59);
    unint64_t v60 = DataProtocol.copyBytes(to:)(&v103[5], v104, &type metadata for Data, v71);
    if ((v60 & 0x8000000000000000LL) == 0)
    {
      if (!HIDWORD(v60))
      {
        *(_DWORD *)__int128 v103 = v60;
        sub_1000AA7B4(v58, v59, v57);
        v103[4] = v57;
        if ((v57 & 0x100) != 0) {
          int v61 = 8;
        }
        else {
          int v61 = 12;
        }
        v55 |= v61;
LABEL_31:
        LODWORD(v83) = v55;
        memcpy((char *)v107 + 6, v81, 0x102uLL);
        memcpy(v108, v92, sizeof(v108));
        memcpy(v109, v93, sizeof(v109));
        memcpy(v110, v84, sizeof(v110));
        LODWORD(v107[0]) = *(_DWORD *)v90;
        WORD2(v107[0]) = *(_WORD *)&v90[4];
        __int128 v111 = *(_OWORD *)&v94[2050];
        __int128 v112 = v95;
        __int128 v113 = v96;
        __int128 v114 = v97;
        __int128 v115 = v98;
        __int128 v116 = v99;
        int v117 = v100;
        __int16 v118 = v101;
        char v119 = v102;
        __int16 v120 = v88;
        char v121 = v89;
        int v122 = *(_DWORD *)v103;
        __int128 v123 = *(_OWORD *)&v103[4];
        __int128 v124 = *(_OWORD *)&v103[20];
        __int128 v125 = *(_OWORD *)&v103[36];
        __int128 v126 = *(_OWORD *)&v103[52];
        char v127 = v103[68];
        __int16 v128 = v86;
        char v129 = v87;
        int v130 = *(_DWORD *)&v104[3];
        int v131 = v80;
        int v132 = -1;
        int v133 = v55;
        int v134 = *(_DWORD *)&v104[19];
        __int16 v135 = *(_WORD *)&v104[23];
        type metadata accessor for apple80211_nan_subscribe_data(0LL);
        uint64_t v63 = v62;
        uint64_t v64 = v73;
        uint64_t v65 = *(void *)(v73 + 8);
        uint64_t v66 = *(void *)(v72 + 16);
        uint64_t v67 = v74;
        uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v65,  v74,  &protocol requirements base descriptor for DeviceDriver);
        uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v64,  v67,  AssociatedTypeWitness,  &protocol requirements base descriptor for IO80211Driver,  &associated conformance descriptor for IO80211Driver.DeviceDriver.Device: IO80211Device);
        return sub_1000A0728(303LL, (uint64_t)v107, v67, v63, v65, v66, AssociatedConformanceWitness);
      }

      goto LABEL_36;
    }
  }

  uint64_t result = _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  "Negative value is not representable",  35LL,  2LL,  "Swift/Integers.swift",  20LL,  2,  3451LL,  0);
LABEL_37:
  __break(1u);
  return result;
}

{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  char *v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  uint64_t v14;
  Swift::String v15;
  uint64_t v16;
  void *v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;
  unint64_t v21;
  uint64_t v22;
  uint64_t KeyPath;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  unint64_t v39;
  unint64_t v40;
  unint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  unint64_t v46;
  uint64_t v47;
  char v48;
  int *v49;
  uint64_t v50;
  void *v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  unint64_t v55;
  int v56;
  uint64_t v57;
  __int16 v58;
  int v59;
  __int16 v60;
  __int16 v61;
  __int16 v62;
  int v63;
  uint64_t v64;
  char v65;
  char v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  unint64_t v70;
  unint64_t v71;
  uint64_t v72;
  unint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  unint64_t v78;
  uint64_t v79;
  uint64_t v80;
  unint64_t v81;
  uint64_t v82;
  unint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t AssociatedTypeWitness;
  uint64_t AssociatedConformanceWitness;
  uint64_t result;
  uint64_t v94;
  void *v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  void *v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  unint64_t v103;
  uint64_t v104;
  __int128 v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  _BYTE v109[2050];
  _BYTE v110[2050];
  void v111[698];
  void v112[6];
  uint64_t v113;
  uint64_t v114;
  void v115[697];
  __int128 v98 = a2;
  __int128 v96 = a4;
  __int128 v97 = a3;
  uint64_t v5 = type metadata accessor for DispatchTimeInterval(0LL);
  int v100 = *(void *)(v5 - 8);
  __int16 v101 = v5;
  __chkstk_darwin(v5);
  __int128 v99 = (uint64_t *)((char *)&v94 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0LL));
  uint64_t v106 = type metadata accessor for SHA256Digest(0LL);
  uint64_t v7 = *(void *)(v106 - 8);
  __chkstk_darwin(v106);
  uint64_t v9 = (char *)&v94 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v10 = type metadata accessor for SHA256(0LL);
  __int128 v103 = *(void *)(v10 - 8);
  __int128 v104 = v10;
  __chkstk_darwin(v10);
  uint64_t v12 = (char *)&v94 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  *(void *)&__int128 v105 = (char *)v111 + 6;
  LOBYTE(v111[426]) = 0;
  LOWORD(v111[434]) = 0;
  memset(v111, 0, 261);
  bzero((char *)&v111[32] + 6, 0xC49uLL);
  *(_OWORD *)((char *)&v111[431] + 7) = 0u;
  *(_OWORD *)((char *)&v111[428] + 4) = 0u;
  *(_OWORD *)((char *)&v111[430] + 4) = 0u;
  *(_OWORD *)((char *)&v111[426] + 4) = 0u;
  *(void *)((char *)&v111[434] + 4) = 0LL;
  BYTE4(v111[435]) = 0;
  *(void *)((char *)&v111[436] + 5) = 0LL;
  v111[436] = 0LL;
  __int128 v95 = (char *)&v111[437] + 6;
  bzero((char *)&v111[437] + 6, 0x818uLL);
  HIBYTE(v111[425]) = *(_BYTE *)a1;
  uint64_t v13 = *(void *)(a1 + 16);
  char v102 = *(void *)(a1 + 8);
  char v108 = a1;
  uint64_t v14 = swift_bridgeObjectRetain(v13);
  SHA256.init()(v14);
  Swift::String v15 = String.lowercased()();
  swift_bridgeObjectRelease(v13);
  swift_bridgeObjectRetain(v15._object);
  unint64_t v16 = v107;
  sub_10016B208( v15._countAndFlagsBits,  (uint64_t)v15._object,  (uint64_t)v12,  v15._countAndFlagsBits,  (uint64_t)v15._object,  v17);
  uint64_t v18 = swift_bridgeObjectRelease(v15._object);
  SHA256.finalize()(v18);
  SHA256Digest.withUnsafeBytes<A>(_:)(v115, sub_10016BB10, 0LL, &type metadata for Data);
  (*(void (**)(char *, uint64_t))(v7 + 8))(v9, v106);
  uint64_t v19 = v115[0];
  unint64_t v20 = v115[1];
  (*(void (**)(char *, uint64_t))(v103 + 8))(v12, v104);
  v115[0] = v19;
  v115[1] = v20;
  int v21 = sub_10005D508();
  uint64_t v22 = v105;
  __int128 v103 = v21;
  DataProtocol.copyBytes(to:)(v111, v105, &type metadata for Data, v21);
  sub_1000208D8(v19, v20);
  uint64_t KeyPath = swift_getKeyPath(&unk_10033EA88);
  v112[2] = v22;
  v112[3] = KeyPath;
  v112[4] = 255LL;
  uint64_t v24 = (uint64_t)sub_10003B5A4( (void *(*)(uint64_t *__return_ptr, void *))sub_100054614,  (uint64_t)v112,  v102,  v13);
  swift_release(KeyPath);
  uint64_t v25 = 254LL;
  if (v24 < 254) {
    uint64_t v25 = v24;
  }
  if (v25 < 0)
  {
    __break(1u);
LABEL_51:
    __break(1u);
    goto LABEL_52;
  }

  HIWORD(v111[32]) = v25;
  uint64_t v26 = v108;
  uint64_t v27 = *(void *)(v108 + 48);
  uint64_t v28 = *(unsigned __int8 *)(v108 + 40);
  uint64_t v29 = swift_getKeyPath(&unk_10033EB28);
  __int16 v107 = v16;
  uint64_t v30 = v29;
  uint64_t v31 = swift_getKeyPath(&unk_10033EB48);
  sub_1000A2FC0(v111, v30, v31, v28, v27);
  swift_release(v30);
  swift_release(v31);
  uint64_t v32 = *(void *)(v26 + 64);
  uint64_t v33 = *(unsigned __int8 *)(v26 + 56);
  uint64_t v34 = swift_getKeyPath(&unk_10033EB68);
  uint64_t v35 = swift_getKeyPath(&unk_10033EB88);
  sub_1000A2FC0(v111, v34, v35, v33, v32);
  swift_release(v34);
  swift_release(v35);
  uint64_t v36 = NANPublish.Configuration.serviceInfo.getter();
  unint64_t v38 = v37;
  unint64_t v40 = v39;
  sub_100020AFC(v37, v39);
  uint64_t v41 = sub_10000D9B0((uint64_t)_swiftEmptyArrayStorage);
  uint64_t v42 = type metadata accessor for BinaryEncoder();
  uint64_t v43 = swift_allocObject(v42, 40LL, 7LL);
  __int128 v105 = xmmword_1003398F0;
  *(_OWORD *)(v43 + 16) = xmmword_1003398F0;
  *(void *)(v43 + 32) = v41;
  uint64_t v106 = v42;
  v115[3] = v42;
  __int128 v104 = sub_10000AF70( (unint64_t *)&qword_1004064B0,  (uint64_t (*)(uint64_t))type metadata accessor for BinaryEncoder,  (uint64_t)&protocol conformance descriptor for BinaryEncoder);
  v115[4] = v104;
  v115[0] = v43;
  sub_100020AFC(v38, v40);
  swift_retain();
  unint64_t v44 = v107;
  NANServiceInfo.encode(to:)((uint64_t)v115, v36, v38, v40);
  if (v44)
  {
    sub_100002AC4(v115);
    sub_1000208D8(v38, v40);
    sub_1000208D8(v38, v40);
    swift_release(v43);
    swift_errorRelease(v44);
    sub_1000208D8(v38, v40);
    __int16 v107 = 0LL;
  }

  else
  {
    __int16 v107 = 0LL;
    sub_100002AC4(v115);
    sub_1000208D8(v38, v40);
    sub_1000208D8(v38, v40);
    swift_beginAccess(v43 + 16, &v113, 0LL, 0LL);
    char v45 = *(void *)(v43 + 16);
    uint64_t v46 = *(void *)(v43 + 24);
    sub_100020AFC(v45, v46);
    swift_release(v43);
    sub_1000208D8(v38, v40);
    sub_1000AAB60(v45, v46);
    memcpy(&v111[169], v109, 0x802uLL);
  }

  uint64_t v47 = v108;
  BYTE4(v111[436]) = *(_BYTE *)(v108 + 32);
  BYTE5(v111[425]) = *(_BYTE *)(v108 + 72) + 1;
  if (*(_BYTE *)(v108 + 73)) {
    uint64_t v48 = 1;
  }
  else {
    uint64_t v48 = 2;
  }
  BYTE6(v111[425]) = v48;
  BYTE4(v111[425]) = *(_BYTE *)(v108 + 75);
  uint64_t v49 = (int *)type metadata accessor for NANPublish.Configuration(0LL);
  LOBYTE(v111[426]) = 0x1008040100uLL >> (8 * *(_BYTE *)(v47 + v49[19]));
  uint64_t v50 = sub_100172848();
  uint64_t v51 = v99;
  uint64_t v52 = v100;
  *__int128 v99 = 0x80000LL;
  int v53 = v101;
  (*(void (**)(void *, void, uint64_t))(v52 + 104))( v51,  enum case for DispatchTimeInterval.microseconds(_:),  v101);
  int v54 = sub_100172848();
  (*(void (**)(void *, uint64_t))(v52 + 8))(v51, v53);
  if (!v54) {
    goto LABEL_51;
  }
  if (v50 == 0x8000000000000000LL && v54 == -1) {
LABEL_52:
  }
    __break(1u);
  int v55 = v50 / v54;
  if (v50 / v54 < 0)
  {
    uint64_t result = _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  "Negative value is not representable",  35LL,  2LL,  "Swift/Integers.swift",  20LL,  2,  3451LL,  0);
LABEL_55:
    __break(1u);
    return result;
  }

  if (HIDWORD(v55))
  {
    uint64_t result = _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  "Not enough bits to represent the passed value",  45LL,  2LL,  "Swift/Integers.swift",  20LL,  2,  3455LL,  0);
    goto LABEL_55;
  }

  v111[427] = v55 | 0xFFFFFFFF00000000LL;
  LODWORD(v111[428]) = *(unsigned __int8 *)(v47 + 74);
  if ((*(_BYTE *)(v47 + 76) & 1) != 0)
  {
    HIDWORD(v111[428]) = 2;
    if (*(_BYTE *)(v47 + v49[20]) != 1) {
      goto LABEL_21;
    }
    unint64_t v56 = 50;
  }

  else
  {
    HIDWORD(v111[428]) = 0;
    if ((*(_BYTE *)(v47 + v49[20]) & 1) == 0) {
      goto LABEL_21;
    }
    unint64_t v56 = 48;
  }

  HIDWORD(v111[428]) = v56;
LABEL_21:
  __int16 v57 = v47 + v49[21];
  if (*(void *)(*(void *)(v57 + 16) + 16LL)) {
    uint64_t v58 = 580;
  }
  else {
    uint64_t v58 = 516;
  }
  unint64_t v59 = *(unsigned __int8 *)(v47 + 77);
  if ((v59 & 1) != 0) {
    unint64_t v60 = 3;
  }
  else {
    unint64_t v60 = 1;
  }
  if (v59 == 2) {
    int v61 = 0;
  }
  else {
    int v61 = v60;
  }
  LOWORD(v111[429]) = v61 | v58;
  uint64_t v62 = *(_WORD *)(v47 + 88);
  LODWORD(v111[694]) = *(_DWORD *)(v47 + 84);
  WORD2(v111[694]) = v62;
  uint64_t v63 = *(unsigned __int8 *)(v57 + 2);
  if (*(_BYTE *)(v57 + 2))
  {
    if (v63 != 1)
    {
      LODWORD(v111[436]) = 5;
      swift_bridgeObjectRelease(0xEA00000000007963LL);
      uint64_t v66 = 1;
      goto LABEL_36;
    }

    uint64_t v64 = 0x656D69746C616572LL;
    uint64_t v63 = 5;
  }

  else
  {
    uint64_t v64 = 0x6576697470616461LL;
  }

  LODWORD(v111[436]) = v63;
  uint64_t v65 = _stringCompareWithSmolCheck(_:_:expecting:)( v64,  0xE800000000000000LL,  0x6E6574614C776F6CLL,  0xEA00000000007963LL,  0LL);
  swift_bridgeObjectRelease(0xE800000000000000LL);
  uint64_t v66 = v65 & 1;
LABEL_36:
  BYTE4(v111[435]) = v66;
  uint64_t v67 = *(void *)(v57 + 8);
  swift_bridgeObjectRetain(v67);
  NANGenericServiceProtocol.packetData(for:)(3LL, v67);
  unint64_t v69 = v68;
  unint64_t v71 = v70;
  swift_bridgeObjectRelease(v67);
  if (v71 >> 60 == 15) {
    uint64_t v72 = 0LL;
  }
  else {
    uint64_t v72 = v69;
  }
  if (v71 >> 60 == 15) {
    unint64_t v71 = 0xC000000000000000LL;
  }
  sub_100020AFC(v72, v71);
  uint64_t v73 = sub_10000D9B0((uint64_t)_swiftEmptyArrayStorage);
  uint64_t v74 = v106;
  uint64_t v75 = swift_allocObject(v106, 40LL, 7LL);
  *(_OWORD *)(v75 + 16) = v105;
  *(void *)(v75 + 32) = v73;
  v115[3] = v74;
  v115[4] = v104;
  v115[0] = v75;
  sub_100020AFC(v72, v71);
  swift_retain();
  char v76 = v107;
  NANServiceInfo.encode(to:)((uint64_t)v115, 2LL, v72, v71);
  sub_100002AC4(v115);
  sub_1000208D8(v72, v71);
  sub_1000208D8(v72, v71);
  if (v76)
  {
    swift_release(v75);
    swift_errorRelease(v76);
    sub_1000208D8(v72, v71);
  }

  else
  {
    swift_beginAccess(v75 + 16, &v114, 0LL, 0LL);
    uint64_t v77 = *(void *)(v75 + 16);
    uint64_t v78 = *(void *)(v75 + 24);
    sub_100020AFC(v77, v78);
    swift_release(v75);
    sub_1000208D8(v72, v71);
    sub_1000AAB60(v77, v78);
    memcpy(v95, v110, 0x802uLL);
  }

  uint64_t v79 = *(void *)(v57 + 16);
  if (*(void *)(v79 + 16))
  {
    char v108 = 0LL;
    uint64_t v80 = *(void *)(v79 + 40);
    char v81 = *(void *)(v79 + 48);
    uint64_t v82 = *(void *)(v79 + 56);
    uint64_t v83 = *(void *)(v79 + 64);
    __int128 v84 = *(void *)(v79 + 80);
    BYTE6(v111[429]) = *(_BYTE *)(v79 + 32) + 1;
    v115[0] = v80;
    v115[1] = v81;
    sub_100020AFC(v80, v81);
    sub_10002255C(v82, v83);
    __int16 v107 = v84;
    swift_bridgeObjectRetain(v84);
    DataProtocol.copyBytes(to:)((char *)&v111[429] + 7, (char *)&v111[433] + 7, &type metadata for Data, v103);
    if (v83 >> 60 == 15)
    {
      sub_1000208D8(v80, v81);
      sub_100020B40(v82, v83);
      swift_bridgeObjectRelease(v107);
    }

    else
    {
      v115[0] = v82;
      v115[1] = v83;
      sub_100020AFC(v82, v83);
      DataProtocol.copyBytes(to:)((char *)&v111[694] + 6, (char *)&v111[696] + 6, &type metadata for Data, v103);
      sub_1000208D8(v80, v81);
      sub_100020B40(v82, v83);
      swift_bridgeObjectRelease(v107);
      sub_100020B40(v82, v83);
    }
  }

  else
  {
    BYTE6(v111[429]) = 0;
  }

  memcpy(v115, v111, sizeof(v115));
  type metadata accessor for apple80211_nan_publish_data(0LL);
  __int16 v86 = v85;
  char v87 = v97;
  __int16 v88 = *(void *)(v97 + 8);
  char v89 = *(void *)(v96 + 16);
  __int16 v90 = v98;
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v88,  v98,  &protocol requirements base descriptor for DeviceDriver);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v87,  v90,  AssociatedTypeWitness,  &protocol requirements base descriptor for IO80211Driver,  &associated conformance descriptor for IO80211Driver.DeviceDriver.Device: IO80211Device);
  return sub_1000A0728(300LL, (uint64_t)v115, v90, v86, v88, v89, AssociatedConformanceWitness);
}

{
  uint64_t v5;
  uint64_t v6;
  char *v7;
  uint64_t v8;
  uint64_t v9;
  char *v10;
  int32x2_t v11;
  int32x2_t v12;
  uint64_t v13;
  uint64_t v14;
  Swift::String v15;
  uint64_t v16;
  void *v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;
  int v21;
  uint64_t v22;
  char v23;
  char v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  unint64_t v28;
  unint64_t v29;
  uint64_t v30;
  unint64_t v31;
  unint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  unint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  unint64_t v42;
  unint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t AssociatedTypeWitness;
  uint64_t AssociatedConformanceWitness;
  uint64_t v53;
  void *v54;
  uint64_t v55;
  char *v56;
  uint64_t v57;
  uint64_t v58;
  unint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  _BYTE v64[2050];
  void v65[269];
  _BYTE v66[24];
  void v67[269];
  int v61 = a4;
  uint64_t v63 = a2;
  uint64_t v62 = a3;
  uint64_t v5 = type metadata accessor for SHA256Digest(0LL);
  uint64_t v58 = *(void *)(v5 - 8);
  unint64_t v59 = v5;
  __chkstk_darwin(v5);
  uint64_t v7 = (char *)&v53 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  int v55 = type metadata accessor for SHA256(0LL);
  uint64_t v8 = *(void *)(v55 - 8);
  __chkstk_darwin(v55);
  uint64_t v10 = (char *)&v53 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  BYTE1(v65[0]) = 0;
  unint64_t v56 = (char *)&v65[1] + 2;
  __int16 v57 = (uint64_t)v65 + 4;
  WORD2(v65[263]) = 0;
  HIDWORD(v65[0]) = 0;
  *(_DWORD *)((char *)v65 + 7) = 0;
  int v54 = &v65[3];
  bzero(&v65[3], 0x823uLL);
  LOBYTE(v65[265]) = 0;
  v65[264] = 0LL;
  *(void *)((char *)&v65[266] + 4) = 0LL;
  *(void *)((char *)&v65[267] + 4) = 0LL;
  *(void *)((char *)&v65[265] + 4) = 0LL;
  HIDWORD(v65[268]) = 0;
  LOBYTE(v65[0]) = *(_BYTE *)a1;
  BYTE2(v65[0]) = *(_BYTE *)(a1 + 24);
  uint64_t v11 = *(int32x2_t *)(a1 + 25);
  *(_WORD *)((char *)&v65[2] + 5) = *(_WORD *)(a1 + 29);
  uint64_t v12 = *(int32x2_t *)(a1 + 3);
  *(_WORD *)((char *)&v65[1] + 3) = *(_WORD *)(a1 + 1);
  *(int32x2_t *)((char *)&v65[1] + 5) = vzip1_s32(v12, v11);
  BYTE3(v65[0]) = *(_BYTE *)(a1 + 7);
  uint64_t v13 = *(void *)(a1 + 16);
  uint64_t v14 = swift_bridgeObjectRetain(v13);
  SHA256.init()(v14);
  Swift::String v15 = String.lowercased()();
  swift_bridgeObjectRelease(v13);
  swift_bridgeObjectRetain(v15._object);
  unint64_t v16 = v60;
  sub_10016B208( v15._countAndFlagsBits,  (uint64_t)v15._object,  (uint64_t)v10,  v15._countAndFlagsBits,  (uint64_t)v15._object,  v17);
  uint64_t v18 = swift_bridgeObjectRelease(v15._object);
  SHA256.finalize()(v18);
  SHA256Digest.withUnsafeBytes<A>(_:)(v67, sub_10016BB10, 0LL, &type metadata for Data);
  (*(void (**)(char *, unint64_t))(v58 + 8))(v7, v59);
  uint64_t v19 = v67[0];
  unint64_t v20 = v67[1];
  (*(void (**)(char *, uint64_t))(v8 + 8))(v10, v55);
  v67[0] = v19;
  v67[1] = v20;
  unint64_t v59 = sub_10005D508();
  DataProtocol.copyBytes(to:)(v57, v56, &type metadata for Data, v59);
  sub_1000208D8(v19, v20);
  int v21 = *(unsigned __int8 *)(a1 + 32);
  unint64_t v60 = v16;
  if (v21)
  {
    if (v21 != 1)
    {
      HIDWORD(v65[265]) = 5;
      swift_bridgeObjectRelease(0xEA00000000007963LL);
      goto LABEL_8;
    }

    uint64_t v22 = 0x656D69746C616572LL;
    int v21 = 5;
  }

  else
  {
    uint64_t v22 = 0x6576697470616461LL;
  }

  HIDWORD(v65[265]) = v21;
  uint64_t v23 = _stringCompareWithSmolCheck(_:_:expecting:)( v22,  0xE800000000000000LL,  0x6E6574614C776F6CLL,  0xEA00000000007963LL,  0LL);
  swift_bridgeObjectRelease(0xE800000000000000LL);
  uint64_t v24 = 0;
  if ((v23 & 1) != 0) {
LABEL_8:
  }
    uint64_t v24 = 1;
  LOBYTE(v65[265]) = v24;
  uint64_t v25 = *(void *)(a1 + 40);
  swift_bridgeObjectRetain(v25);
  NANGenericServiceProtocol.packetData(for:)(3LL, v25);
  uint64_t v27 = v26;
  uint64_t v29 = v28;
  swift_bridgeObjectRelease(v25);
  if (v29 >> 60 == 15) {
    uint64_t v30 = 0LL;
  }
  else {
    uint64_t v30 = v27;
  }
  if (v29 >> 60 == 15) {
    uint64_t v31 = 0xC000000000000000LL;
  }
  else {
    uint64_t v31 = v29;
  }
  sub_100020AFC(v30, v31);
  uint64_t v32 = sub_10000D9B0((uint64_t)_swiftEmptyArrayStorage);
  uint64_t v33 = type metadata accessor for BinaryEncoder();
  uint64_t v34 = swift_allocObject(v33, 40LL, 7LL);
  *(_OWORD *)(v34 + 16) = xmmword_1003398F0;
  *(void *)(v34 + 32) = v32;
  v67[3] = v33;
  v67[4] = sub_10000AF70( (unint64_t *)&qword_1004064B0,  (uint64_t (*)(uint64_t))type metadata accessor for BinaryEncoder,  (uint64_t)&protocol conformance descriptor for BinaryEncoder);
  v67[0] = v34;
  sub_100020AFC(v30, v31);
  swift_retain();
  uint64_t v35 = v60;
  NANServiceInfo.encode(to:)((uint64_t)v67, 2LL, v30, v31);
  sub_100002AC4(v67);
  sub_1000208D8(v30, v31);
  sub_1000208D8(v30, v31);
  if (v35)
  {
    swift_release(v34);
    swift_errorRelease(v35);
    sub_1000208D8(v30, v31);
  }

  else
  {
    swift_beginAccess(v34 + 16, v66, 0LL, 0LL);
    uint64_t v36 = *(void *)(v34 + 16);
    uint64_t v37 = *(void *)(v34 + 24);
    sub_100020AFC(v36, v37);
    swift_release(v34);
    sub_1000208D8(v30, v31);
    sub_1000AAB60(v36, v37);
    memcpy(v54, v64, 0x802uLL);
  }

  unint64_t v38 = *(void *)(a1 + 96);
  if (v38 == 1)
  {
    BYTE2(v65[259]) = 0;
  }

  else
  {
    unint64_t v60 = 0LL;
    unint64_t v39 = *(void *)(a1 + 48);
    unint64_t v40 = *(void *)(a1 + 56);
    uint64_t v42 = *(void *)(a1 + 64);
    uint64_t v41 = *(void *)(a1 + 72);
    uint64_t v43 = *(void *)(a1 + 80);
    uint64_t v58 = *(void *)(a1 + 88);
    unint64_t v56 = (char *)&v65[259] + 3;
    __int16 v57 = v39;
    BYTE2(v65[259]) = v39 + 1;
    v67[0] = v40;
    v67[1] = v42;
    sub_100020AFC(v40, v42);
    sub_10002255C(v41, v43);
    swift_bridgeObjectRetain(v38);
    DataProtocol.copyBytes(to:)(v56, (char *)&v65[263] + 3, &type metadata for Data, v59);
    if (v43 >> 60 == 15)
    {
      sub_1000AADB0(v57, v40, v42, v41, v43, v58, v38);
    }

    else
    {
      unint64_t v56 = (char *)&v65[267];
      v67[0] = v41;
      v67[1] = v43;
      sub_100020AFC(v41, v43);
      DataProtocol.copyBytes(to:)(v56, v66, &type metadata for Data, v59);
      sub_1000AADB0(v57, v40, v42, v41, v43, v58, v38);
      sub_100020B40(v41, v43);
    }
  }

  memcpy(v67, v65, sizeof(v67));
  type metadata accessor for apple80211_nan_dp_request(0LL);
  char v45 = v44;
  uint64_t v46 = v62;
  uint64_t v47 = *(void *)(v62 + 8);
  uint64_t v48 = *(void *)(v61 + 16);
  uint64_t v49 = v63;
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v47,  v63,  &protocol requirements base descriptor for DeviceDriver);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v46,  v49,  AssociatedTypeWitness,  &protocol requirements base descriptor for IO80211Driver,  &associated conformance descriptor for IO80211Driver.DeviceDriver.Device: IO80211Device);
  return sub_1000A0728(315LL, (uint64_t)v67, v49, v45, v47, v48, AssociatedConformanceWitness);
}

uint64_t sub_10009830C(uint64_t a1)
{
  return sub_10009832C(a1);
}

uint64_t sub_10009832C(uint64_t a1)
{
  uint64_t v2 = type metadata accessor for DispatchTimeInterval(0LL);
  uint64_t v90 = *(void *)(v2 - 8);
  uint64_t v91 = v2;
  __chkstk_darwin(v2);
  char v89 = (void **)((char *)&v87 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0LL));
  uint64_t v97 = type metadata accessor for SHA256Digest(0LL);
  uint64_t v4 = *(void *)(v97 - 8);
  __chkstk_darwin(v97);
  uint64_t v6 = (char *)&v87 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v7 = type metadata accessor for SHA256(0LL);
  unint64_t v93 = *(void *)(v7 - 8);
  uint64_t v94 = v7;
  __chkstk_darwin(v7);
  uint64_t v9 = (char *)&v87 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  *(void *)&__int128 v95 = (char *)v101 + 6;
  LOBYTE(v101[426]) = 0;
  LOWORD(v101[434]) = 0;
  memset(v101, 0, 261);
  bzero((char *)&v101[32] + 6, 0xC49uLL);
  *(_OWORD *)((char *)&v101[431] + 7) = 0u;
  *(_OWORD *)((char *)&v101[428] + 4) = 0u;
  *(_OWORD *)((char *)&v101[430] + 4) = 0u;
  *(_OWORD *)((char *)&v101[426] + 4) = 0u;
  *(void *)((char *)&v101[434] + 4) = 0LL;
  BYTE4(v101[435]) = 0;
  *(void *)((char *)&v101[436] + 5) = 0LL;
  v101[436] = 0LL;
  char v87 = (char *)&v101[437] + 6;
  bzero((char *)&v101[437] + 6, 0x818uLL);
  HIBYTE(v101[425]) = *(_BYTE *)a1;
  uint64_t v10 = *(void *)(a1 + 16);
  uint64_t v92 = *(void *)(a1 + 8);
  uint64_t v98 = a1;
  uint64_t v11 = swift_bridgeObjectRetain(v10);
  SHA256.init()(v11);
  Swift::String v12 = String.lowercased()();
  swift_bridgeObjectRelease(v10);
  swift_bridgeObjectRetain(v12._object);
  uint64_t v13 = v96;
  sub_10016B208( v12._countAndFlagsBits,  (uint64_t)v12._object,  (uint64_t)v9,  v12._countAndFlagsBits,  (uint64_t)v12._object,  v14);
  uint64_t v15 = swift_bridgeObjectRelease(v12._object);
  SHA256.finalize()(v15);
  SHA256Digest.withUnsafeBytes<A>(_:)(v105, sub_10016BB10, 0LL, &type metadata for Data);
  (*(void (**)(char *, uint64_t))(v4 + 8))(v6, v97);
  uint64_t v16 = v105[0];
  unint64_t v17 = v105[1];
  (*(void (**)(char *, uint64_t))(v93 + 8))(v9, v94);
  v105[0] = v16;
  v105[1] = v17;
  unint64_t v18 = sub_10005D508();
  uint64_t v19 = v95;
  unint64_t v93 = v18;
  DataProtocol.copyBytes(to:)(v101, v95, &type metadata for Data, v18);
  sub_1000208D8(v16, v17);
  uint64_t KeyPath = swift_getKeyPath(&unk_10033EA88);
  v102[2] = v19;
  v102[3] = KeyPath;
  v102[4] = 255LL;
  uint64_t v21 = (uint64_t)sub_10003B5A4( (void *(*)(uint64_t *__return_ptr, void *))sub_100054614,  (uint64_t)v102,  v92,  v10);
  swift_release(KeyPath);
  uint64_t v22 = 254LL;
  if (v21 < 254) {
    uint64_t v22 = v21;
  }
  if (v22 < 0)
  {
    __break(1u);
LABEL_52:
    __break(1u);
    goto LABEL_53;
  }

  HIWORD(v101[32]) = v22;
  uint64_t v23 = v98;
  uint64_t v24 = *(void *)(v98 + 48);
  uint64_t v25 = *(unsigned __int8 *)(v98 + 40);
  uint64_t v26 = swift_getKeyPath(&unk_10033EB28);
  uint64_t v97 = v13;
  uint64_t v27 = v26;
  uint64_t v28 = swift_getKeyPath(&unk_10033EB48);
  sub_1000A2FC0(v101, v27, v28, v25, v24);
  swift_release(v27);
  swift_release(v28);
  uint64_t v29 = *(void *)(v23 + 64);
  uint64_t v30 = *(unsigned __int8 *)(v23 + 56);
  uint64_t v31 = swift_getKeyPath(&unk_10033EB68);
  uint64_t v32 = swift_getKeyPath(&unk_10033EB88);
  sub_1000A2FC0(v101, v31, v32, v30, v29);
  swift_release(v31);
  swift_release(v32);
  uint64_t v33 = NANPublish.Configuration.serviceInfo.getter();
  uint64_t v35 = v34;
  unint64_t v37 = v36;
  sub_100020AFC(v34, v36);
  unint64_t v38 = sub_10000D9B0((uint64_t)_swiftEmptyArrayStorage);
  uint64_t v39 = type metadata accessor for BinaryEncoder();
  uint64_t v40 = swift_allocObject(v39, 40LL, 7LL);
  __int128 v95 = xmmword_1003398F0;
  *(_OWORD *)(v40 + 16) = xmmword_1003398F0;
  *(void *)(v40 + 32) = v38;
  uint64_t v96 = v39;
  v105[3] = v39;
  uint64_t v94 = sub_10000AF70( (unint64_t *)&qword_1004064B0,  (uint64_t (*)(uint64_t))type metadata accessor for BinaryEncoder,  (uint64_t)&protocol conformance descriptor for BinaryEncoder);
  v105[4] = v94;
  v105[0] = v40;
  sub_100020AFC(v35, v37);
  swift_retain();
  uint64_t v41 = v97;
  NANServiceInfo.encode(to:)((uint64_t)v105, v33, v35, v37);
  if (v41)
  {
    sub_100002AC4(v105);
    sub_1000208D8(v35, v37);
    sub_1000208D8(v35, v37);
    swift_release(v40);
    swift_errorRelease(v41);
    sub_1000208D8(v35, v37);
    uint64_t v97 = 0LL;
  }

  else
  {
    uint64_t v97 = 0LL;
    sub_100002AC4(v105);
    sub_1000208D8(v35, v37);
    sub_1000208D8(v35, v37);
    swift_beginAccess(v40 + 16, &v103, 0LL, 0LL);
    uint64_t v42 = *(void *)(v40 + 16);
    unint64_t v43 = *(void *)(v40 + 24);
    sub_100020AFC(v42, v43);
    swift_release(v40);
    sub_1000208D8(v35, v37);
    sub_1000AAB60(v42, v43);
    memcpy(&v101[169], v99, 0x802uLL);
  }

  uint64_t v44 = v98;
  BYTE4(v101[436]) = *(_BYTE *)(v98 + 32);
  BYTE5(v101[425]) = *(_BYTE *)(v98 + 72) + 1;
  if (*(_BYTE *)(v98 + 73)) {
    char v45 = 1;
  }
  else {
    char v45 = 2;
  }
  BYTE6(v101[425]) = v45;
  BYTE4(v101[425]) = *(_BYTE *)(v98 + 75);
  uint64_t v46 = (int *)type metadata accessor for NANPublish.Configuration(0LL);
  LOBYTE(v101[426]) = 0x1008040100uLL >> (8 * *(_BYTE *)(v44 + v46[19]));
  uint64_t v47 = sub_100172848();
  uint64_t v48 = v89;
  uint64_t v49 = v90;
  *char v89 = 0x80000LL;
  uint64_t v50 = v91;
  (*(void (**)(void *, void, uint64_t))(v49 + 104))( v48,  enum case for DispatchTimeInterval.microseconds(_:),  v91);
  uint64_t v51 = sub_100172848();
  (*(void (**)(void *, uint64_t))(v49 + 8))(v48, v50);
  if (!v51) {
    goto LABEL_52;
  }
  if (v47 == 0x8000000000000000LL && v51 == -1) {
LABEL_53:
  }
    __break(1u);
  unint64_t v52 = v47 / v51;
  if (v47 / v51 < 0)
  {
    uint64_t result = _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  "Negative value is not representable",  35LL,  2LL,  "Swift/Integers.swift",  20LL,  2,  3451LL,  0);
LABEL_56:
    __break(1u);
    return result;
  }

  if (HIDWORD(v52))
  {
    uint64_t result = _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  "Not enough bits to represent the passed value",  45LL,  2LL,  "Swift/Integers.swift",  20LL,  2,  3455LL,  0);
    goto LABEL_56;
  }

  v101[427] = v52 | 0xFFFFFFFF00000000LL;
  LODWORD(v101[428]) = *(unsigned __int8 *)(v44 + 74);
  if (*(_BYTE *)(v44 + 76) == 1)
  {
    HIDWORD(v101[428]) = 2;
    if ((*(_BYTE *)(v44 + v46[20]) & 1) == 0) {
      goto LABEL_21;
    }
    int v53 = 50;
  }

  else
  {
    HIDWORD(v101[428]) = 0;
    if (*(_BYTE *)(v44 + v46[20]) != 1) {
      goto LABEL_21;
    }
    int v53 = 48;
  }

  HIDWORD(v101[428]) = v53;
LABEL_21:
  uint64_t v54 = v44 + v46[21];
  if (*(void *)(*(void *)(v54 + 16) + 16LL)) {
    __int16 v55 = 580;
  }
  else {
    __int16 v55 = 516;
  }
  int v56 = *(unsigned __int8 *)(v44 + 77);
  if ((v56 & 1) != 0) {
    __int16 v57 = 3;
  }
  else {
    __int16 v57 = 1;
  }
  if (v56 == 2) {
    __int16 v58 = 0;
  }
  else {
    __int16 v58 = v57;
  }
  LOWORD(v101[429]) = v58 | v55;
  __int16 v59 = *(_WORD *)(v44 + 88);
  LODWORD(v101[694]) = *(_DWORD *)(v44 + 84);
  WORD2(v101[694]) = v59;
  int v60 = *(unsigned __int8 *)(v54 + 2);
  if (*(_BYTE *)(v54 + 2))
  {
    if (v60 != 1)
    {
      LODWORD(v101[436]) = 5;
      swift_bridgeObjectRelease(0xEA00000000007963LL);
      char v63 = 1;
      goto LABEL_36;
    }

    uint64_t v61 = 0x656D69746C616572LL;
    int v60 = 5;
  }

  else
  {
    uint64_t v61 = 0x6576697470616461LL;
  }

  LODWORD(v101[436]) = v60;
  char v62 = _stringCompareWithSmolCheck(_:_:expecting:)( v61,  0xE800000000000000LL,  0x6E6574614C776F6CLL,  0xEA00000000007963LL,  0LL);
  swift_bridgeObjectRelease(0xE800000000000000LL);
  char v63 = v62 & 1;
LABEL_36:
  BYTE4(v101[435]) = v63;
  uint64_t v64 = *(void *)(v54 + 8);
  swift_bridgeObjectRetain(v64);
  NANGenericServiceProtocol.packetData(for:)(3LL, v64);
  uint64_t v66 = v65;
  unint64_t v68 = v67;
  swift_bridgeObjectRelease(v64);
  if (v68 >> 60 == 15) {
    uint64_t v69 = 0LL;
  }
  else {
    uint64_t v69 = v66;
  }
  if (v68 >> 60 == 15) {
    unint64_t v70 = 0xC000000000000000LL;
  }
  else {
    unint64_t v70 = v68;
  }
  sub_100020AFC(v69, v70);
  unint64_t v71 = sub_10000D9B0((uint64_t)_swiftEmptyArrayStorage);
  uint64_t v72 = v96;
  uint64_t v73 = swift_allocObject(v96, 40LL, 7LL);
  *(_OWORD *)(v73 + 16) = v95;
  *(void *)(v73 + 32) = v71;
  v105[3] = v72;
  v105[4] = v94;
  v105[0] = v73;
  sub_100020AFC(v69, v70);
  swift_retain();
  uint64_t v74 = v97;
  NANServiceInfo.encode(to:)((uint64_t)v105, 2LL, v69, v70);
  sub_100002AC4(v105);
  sub_1000208D8(v69, v70);
  sub_1000208D8(v69, v70);
  if (v74)
  {
    swift_release(v73);
    swift_errorRelease(v74);
    sub_1000208D8(v69, v70);
  }

  else
  {
    swift_beginAccess(v73 + 16, &v104, 0LL, 0LL);
    uint64_t v75 = *(void *)(v73 + 16);
    unint64_t v76 = *(void *)(v73 + 24);
    sub_100020AFC(v75, v76);
    swift_release(v73);
    sub_1000208D8(v69, v70);
    sub_1000AAB60(v75, v76);
    memcpy(v87, v100, 0x802uLL);
  }

  uint64_t v77 = *(void *)(v54 + 16);
  if (*(void *)(v77 + 16))
  {
    uint64_t v98 = 0LL;
    uint64_t v78 = *(void *)(v77 + 40);
    unint64_t v79 = *(void *)(v77 + 48);
    uint64_t v80 = *(void *)(v77 + 56);
    unint64_t v81 = *(void *)(v77 + 64);
    uint64_t v82 = *(void *)(v77 + 80);
    BYTE6(v101[429]) = *(_BYTE *)(v77 + 32) + 1;
    v105[0] = v78;
    v105[1] = v79;
    sub_100020AFC(v78, v79);
    sub_10002255C(v80, v81);
    uint64_t v97 = v82;
    swift_bridgeObjectRetain(v82);
    DataProtocol.copyBytes(to:)((char *)&v101[429] + 7, (char *)&v101[433] + 7, &type metadata for Data, v93);
    if (v81 >> 60 == 15)
    {
      sub_1000208D8(v78, v79);
      sub_100020B40(v80, v81);
      swift_bridgeObjectRelease(v97);
    }

    else
    {
      v105[0] = v80;
      v105[1] = v81;
      sub_100020AFC(v80, v81);
      DataProtocol.copyBytes(to:)((char *)&v101[694] + 6, (char *)&v101[696] + 6, &type metadata for Data, v93);
      sub_1000208D8(v78, v79);
      sub_100020B40(v80, v81);
      swift_bridgeObjectRelease(v97);
      sub_100020B40(v80, v81);
    }
  }

  else
  {
    BYTE6(v101[429]) = 0;
  }

  memcpy(v105, v101, sizeof(v105));
  uint64_t v83 = v88[5];
  uint64_t v84 = v88[2];
  uint64_t v85 = v88[3];
  swift_retain();
  swift_bridgeObjectRetain(v85);
  AppleDevice.setRequest(requestType:data:on:)(0x12CuLL, (uint64_t)v105, (uint64_t)v106, 0, v84, v85);
  swift_bridgeObjectRelease(v85);
  return swift_release(v83);
}

uint64_t sub_100099A90(uint64_t a1)
{
  return sub_100099AB0(a1);
}

uint64_t sub_100099AB0(uint64_t a1)
{
  unint64_t v50 = type metadata accessor for SHA256Digest(0LL);
  uint64_t v2 = *(void *)(v50 - 8);
  __chkstk_darwin(v50);
  uint64_t v4 = (char *)&v45 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v47 = (char *)type metadata accessor for SHA256(0LL);
  uint64_t v5 = *((void *)v47 - 1);
  __chkstk_darwin(v47);
  uint64_t v7 = (char *)&v45 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  BYTE1(v54[0]) = 0;
  uint64_t v48 = (uint64_t)&v54[1] + 2;
  uint64_t v49 = (uint64_t)v54 + 4;
  WORD2(v54[263]) = 0;
  HIDWORD(v54[0]) = 0;
  *(_DWORD *)((char *)v54 + 7) = 0;
  uint64_t v46 = &v54[3];
  bzero(&v54[3], 0x823uLL);
  LOBYTE(v54[265]) = 0;
  v54[264] = 0LL;
  *(void *)((char *)&v54[266] + 4) = 0LL;
  *(void *)((char *)&v54[267] + 4) = 0LL;
  *(void *)((char *)&v54[265] + 4) = 0LL;
  HIDWORD(v54[268]) = 0;
  LOBYTE(v54[0]) = *(_BYTE *)a1;
  BYTE2(v54[0]) = *(_BYTE *)(a1 + 24);
  int32x2_t v8 = *(int32x2_t *)(a1 + 25);
  *(_WORD *)((char *)&v54[2] + 5) = *(_WORD *)(a1 + 29);
  int32x2_t v9 = *(int32x2_t *)(a1 + 3);
  *(_WORD *)((char *)&v54[1] + 3) = *(_WORD *)(a1 + 1);
  *(int32x2_t *)((char *)&v54[1] + 5) = vzip1_s32(v9, v8);
  BYTE3(v54[0]) = *(_BYTE *)(a1 + 7);
  uint64_t v10 = *(void *)(a1 + 16);
  uint64_t v11 = swift_bridgeObjectRetain(v10);
  SHA256.init()(v11);
  Swift::String v12 = String.lowercased()();
  swift_bridgeObjectRelease(v10);
  swift_bridgeObjectRetain(v12._object);
  uint64_t v13 = v51;
  sub_10016B208( v12._countAndFlagsBits,  (uint64_t)v12._object,  (uint64_t)v7,  v12._countAndFlagsBits,  (uint64_t)v12._object,  v14);
  uint64_t v15 = swift_bridgeObjectRelease(v12._object);
  SHA256.finalize()(v15);
  SHA256Digest.withUnsafeBytes<A>(_:)(v56, sub_10016BB10, 0LL, &type metadata for Data);
  uint64_t v51 = v13;
  (*(void (**)(char *, unint64_t))(v2 + 8))(v4, v50);
  uint64_t v16 = v56[0];
  unint64_t v17 = v56[1];
  (*(void (**)(char *, char *))(v5 + 8))(v7, v47);
  v56[0] = v16;
  v56[1] = v17;
  unint64_t v50 = sub_10005D508();
  DataProtocol.copyBytes(to:)(v49, v48, &type metadata for Data, v50);
  sub_1000208D8(v16, v17);
  int v18 = *(unsigned __int8 *)(a1 + 32);
  if (!*(_BYTE *)(a1 + 32))
  {
    uint64_t v19 = 0x6576697470616461LL;
    goto LABEL_5;
  }

  if (v18 == 1)
  {
    uint64_t v19 = 0x656D69746C616572LL;
    int v18 = 5;
LABEL_5:
    HIDWORD(v54[265]) = v18;
    char v20 = _stringCompareWithSmolCheck(_:_:expecting:)( v19,  0xE800000000000000LL,  0x6E6574614C776F6CLL,  0xEA00000000007963LL,  0LL);
    swift_bridgeObjectRelease(0xE800000000000000LL);
    char v21 = v20 & 1;
    goto LABEL_7;
  }

  HIDWORD(v54[265]) = 5;
  swift_bridgeObjectRelease(0xEA00000000007963LL);
  char v21 = 1;
LABEL_7:
  LOBYTE(v54[265]) = v21;
  uint64_t v22 = *(void *)(a1 + 40);
  swift_bridgeObjectRetain(v22);
  NANGenericServiceProtocol.packetData(for:)(3LL, v22);
  uint64_t v24 = v23;
  unint64_t v26 = v25;
  swift_bridgeObjectRelease(v22);
  if (v26 >> 60 == 15) {
    uint64_t v27 = 0LL;
  }
  else {
    uint64_t v27 = v24;
  }
  if (v26 >> 60 == 15) {
    unint64_t v28 = 0xC000000000000000LL;
  }
  else {
    unint64_t v28 = v26;
  }
  sub_100020AFC(v27, v28);
  unint64_t v29 = sub_10000D9B0((uint64_t)_swiftEmptyArrayStorage);
  uint64_t v30 = type metadata accessor for BinaryEncoder();
  uint64_t v31 = swift_allocObject(v30, 40LL, 7LL);
  *(_OWORD *)(v31 + 16) = xmmword_1003398F0;
  *(void *)(v31 + 32) = v29;
  v56[3] = v30;
  v56[4] = sub_10000AF70( (unint64_t *)&qword_1004064B0,  (uint64_t (*)(uint64_t))type metadata accessor for BinaryEncoder,  (uint64_t)&protocol conformance descriptor for BinaryEncoder);
  v56[0] = v31;
  sub_100020AFC(v27, v28);
  swift_retain();
  uint64_t v32 = v51;
  NANServiceInfo.encode(to:)((uint64_t)v56, 2LL, v27, v28);
  sub_100002AC4(v56);
  sub_1000208D8(v27, v28);
  sub_1000208D8(v27, v28);
  if (v32)
  {
    swift_release(v31);
    swift_errorRelease(v32);
    sub_1000208D8(v27, v28);
  }

  else
  {
    swift_beginAccess(v31 + 16, v55, 0LL, 0LL);
    uint64_t v33 = *(void *)(v31 + 16);
    unint64_t v34 = *(void *)(v31 + 24);
    sub_100020AFC(v33, v34);
    swift_release(v31);
    sub_1000208D8(v27, v28);
    sub_1000AAB60(v33, v34);
    memcpy(v46, v53, 0x802uLL);
  }

  uint64_t v35 = *(void *)(a1 + 96);
  if (v35 == 1)
  {
    BYTE2(v54[259]) = 0;
  }

  else
  {
    uint64_t v51 = 0LL;
    uint64_t v36 = *(void *)(a1 + 48);
    uint64_t v37 = *(void *)(a1 + 56);
    unint64_t v39 = *(void *)(a1 + 64);
    uint64_t v38 = *(void *)(a1 + 72);
    unint64_t v40 = *(void *)(a1 + 80);
    uint64_t v49 = *(void *)(a1 + 88);
    uint64_t v47 = (char *)&v54[259] + 3;
    uint64_t v48 = v36;
    BYTE2(v54[259]) = v36 + 1;
    v56[0] = v37;
    v56[1] = v39;
    sub_100020AFC(v37, v39);
    sub_10002255C(v38, v40);
    swift_bridgeObjectRetain(v35);
    DataProtocol.copyBytes(to:)(v47, (char *)&v54[263] + 3, &type metadata for Data, v50);
    if (v40 >> 60 == 15)
    {
      sub_1000AADB0(v48, v37, v39, v38, v40, v49, v35);
    }

    else
    {
      uint64_t v47 = (char *)&v54[267];
      v56[0] = v38;
      v56[1] = v40;
      sub_100020AFC(v38, v40);
      DataProtocol.copyBytes(to:)(v47, v55, &type metadata for Data, v50);
      sub_1000AADB0(v48, v37, v39, v38, v40, v49, v35);
      sub_100020B40(v38, v40);
    }
  }

  memcpy(v56, v54, sizeof(v56));
  uint64_t v41 = v52[5];
  uint64_t v42 = v52[2];
  uint64_t v43 = v52[3];
  swift_retain();
  swift_bridgeObjectRetain(v43);
  AppleDevice.setRequest(requestType:data:on:)(0x13BuLL, (uint64_t)v56, (uint64_t)&v57, 0, v42, v43);
  swift_bridgeObjectRelease(v43);
  return swift_release(v41);
}

uint64_t BroadcomDriver<>.update(configuration:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a4 + 184))(a1, a2, a4);
}

{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a4 + 192))(a1, a2, a4);
}

{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a4 + 200))(a1, a2, a4);
}

uint64_t sub_10009A7CC(unsigned __int8 a1, uint64_t a2)
{
  return sub_10004F0BC(0x13EuLL, a1, a2 & 0xFFFFFFFFFFFFLL, 0);
}

uint64_t IO80211Driver<>.terminate(datapathID:initiatorAddress:)( char a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  v15[0] = a1;
  v15[1] = 0;
  int v16 = 0;
  __int16 v17 = a2;
  char v18 = BYTE2(a2);
  char v19 = BYTE3(a2);
  char v20 = BYTE4(a2);
  char v21 = BYTE5(a2);
  type metadata accessor for apple80211_nan_dp_terminate(0LL);
  uint64_t v9 = v8;
  int v22 = 0;
  __int16 v23 = 0;
  uint64_t v10 = *(void *)(a4 + 8);
  uint64_t v11 = *(void *)(a5 + 16);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v10,  a3,  &protocol requirements base descriptor for DeviceDriver);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a4,  a3,  AssociatedTypeWitness,  &protocol requirements base descriptor for IO80211Driver,  &associated conformance descriptor for IO80211Driver.DeviceDriver.Device: IO80211Device);
  return sub_1000A0728(318LL, (uint64_t)v15, a3, v9, v10, v11, AssociatedConformanceWitness);
}

uint64_t sub_10009A8F4(char a1)
{
  return sub_10004EDA4(0x132uLL, a1);
}

uint64_t IO80211Driver<>.terminate(subscribeID:)(char a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return sub_10009A984( a1,  a2,  a3,  a4,  (uint64_t (*)(void))type metadata accessor for apple80211_nan_cancel_subscribe_data,  306LL);
}

uint64_t sub_10009A93C(char a1)
{
  return sub_10004EDA4(0x12DuLL, a1);
}

uint64_t IO80211Driver<>.terminate(publishID:)(char a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return sub_10009A984( a1,  a2,  a3,  a4,  (uint64_t (*)(void))type metadata accessor for apple80211_nan_cancel_publish_data,  301LL);
}

uint64_t sub_10009A984( char a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t (*a5)(void), uint64_t a6)
{
  char v16 = a1;
  uint64_t v10 = a5(0LL);
  uint64_t v11 = *(void *)(a3 + 8);
  uint64_t v12 = *(void *)(a4 + 16);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v11,  a2,  &protocol requirements base descriptor for DeviceDriver);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a3,  a2,  AssociatedTypeWitness,  &protocol requirements base descriptor for IO80211Driver,  &associated conformance descriptor for IO80211Driver.DeviceDriver.Device: IO80211Device);
  return sub_1000A0728(a6, (uint64_t)&v16, a2, v10, v11, v12, AssociatedConformanceWitness);
}

uint64_t sub_10009AA40(uint64_t a1, unint64_t a2, char a3, unint64_t a4, char a5)
{
  char v6 = a4;
  unint64_t v10 = a4 >> 8;
  unint64_t v11 = a4 >> 16;
  unint64_t v15 = a4 >> 24;
  unint64_t v12 = HIDWORD(a4);
  unint64_t v13 = a4 >> 40;
  sub_100020AFC(a1, a2);
  sub_1000AAB60(a1, a2);
  v16[0] = a3;
  v16[1] = a5;
  __int16 v17 = 0;
  char v18 = v6;
  char v19 = v10;
  char v20 = v11;
  char v21 = v15;
  char v22 = v12;
  char v23 = v13;
  return sub_10004F1E0(0x133uLL, v16);
}

uint64_t IO80211Driver<>.transmit(followUp:for:to:with:)( uint64_t a1, unint64_t a2, char a3, unint64_t a4, char a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char v10 = a4;
  unint64_t v14 = a4 >> 8;
  unint64_t v15 = a4 >> 16;
  unint64_t v16 = a4 >> 24;
  unint64_t v24 = HIDWORD(a4);
  unint64_t v25 = a4 >> 40;
  sub_100020AFC(a1, a2);
  sub_1000AAB60(a1, a2);
  v28[0] = a3;
  v28[1] = a5;
  __int16 v29 = 0;
  char v30 = v10;
  char v31 = v14;
  char v32 = v15;
  char v33 = v16;
  char v34 = v24;
  char v35 = v25;
  type metadata accessor for apple80211_nan_follow_up_transmit_data(0LL);
  uint64_t v18 = v17;
  uint64_t v19 = *(void *)(a7 + 8);
  uint64_t v20 = *(void *)(a8 + 16);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v19,  a6,  &protocol requirements base descriptor for DeviceDriver);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a7,  a6,  AssociatedTypeWitness,  &protocol requirements base descriptor for IO80211Driver,  &associated conformance descriptor for IO80211Driver.DeviceDriver.Device: IO80211Device);
  return sub_1000A0728(307LL, (uint64_t)v28, a6, v18, v19, v20, AssociatedConformanceWitness);
}

uint64_t sub_10009AC44( char a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, unint64_t a9, unint64_t a10, unint64_t a11)
{
  return sub_10009AC88( a1,  a2,  a3,  a4,  a5 & 0xFFFFFFFFFFFFLL,  a6 & 0xFFFFFFFFFFFFLL,  a7 & 0xFFFFFFFFFFFFLL,  a8,  a9,  a10,  a11);
}

uint64_t sub_10009AC88( char a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, unint64_t a9, unint64_t a10, unint64_t a11)
{
  unint64_t v11 = a9;
  bzero(v44, 0x3C4uLL);
  unint64_t v12 = a10 - a9;
  if (a10 < a9) {
    goto LABEL_13;
  }
  unint64_t v13 = _swiftEmptyArrayStorage;
  if (v12 >= 0x80)
  {
    unint64_t v21 = v12 >> 7;
    v45[0] = _swiftEmptyArrayStorage;
    sub_10006972C(0, v12 >> 7, 0);
    unint64_t v22 = a11;
    unint64_t v13 = (void *)v45[0];
    unint64_t v23 = a9 >> 7;
    unint64_t v24 = *(void *)(v45[0] + 16LL);
    unint64_t v25 = HIBYTE(a11);
    unint64_t v26 = HIWORD(a11);
    unint64_t v27 = a11 >> 40;
    unint64_t v28 = HIDWORD(a11);
    unint64_t v29 = a11 >> 24;
    while (1)
    {
      char v46 = v22;
      __int16 v47 = *(_WORD *)((char *)&a11 + 1);
      char v48 = v29;
      char v49 = v28;
      char v50 = v27;
      char v51 = v26;
      char v52 = v25;
      char v30 = *(&v46 + v23);
      unint64_t v31 = v13[3];
      v45[0] = v13;
      if (v24 >= v31 >> 1)
      {
        unint64_t v42 = v25;
        unint64_t v43 = v22;
        unint64_t v40 = v27;
        unint64_t v41 = v26;
        unint64_t v38 = v29;
        unint64_t v39 = v28;
        sub_10006972C(v31 > 1, v24 + 1, 1);
        unint64_t v29 = v38;
        unint64_t v28 = v39;
        unint64_t v27 = v40;
        unint64_t v26 = v41;
        unint64_t v25 = v42;
        unint64_t v22 = v43;
        unint64_t v13 = (void *)v45[0];
      }

      v13[2] = v24 + 1;
      *((_BYTE *)v13 + v24 + 32) = v30;
      if (v11 >= 0xFFFFFFFFFFFFFF80LL) {
        break;
      }
      v11 += 128LL;
      ++v23;
      ++v24;
      if (!--v21) {
        goto LABEL_3;
      }
    }

    __break(1u);
LABEL_13:
    __break(1u);
    JUMPOUT(0x10009B234LL);
  }

uint64_t IO80211Driver<>.transmit(outOfBoundActionFrame:from:to:on:mapID:using:)( char a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, unint64_t a9, unint64_t a10, unint64_t a11)
{
  unint64_t v11 = a9;
  bzero(v44, 0x3C4uLL);
  unint64_t v12 = a10 - a9;
  if (a10 < a9) {
    goto LABEL_13;
  }
  unint64_t v13 = _swiftEmptyArrayStorage;
  if (v12 >= 0x80)
  {
    unint64_t v21 = v12 >> 7;
    v45[0] = _swiftEmptyArrayStorage;
    sub_10006972C(0, v12 >> 7, 0);
    unint64_t v22 = a11;
    unint64_t v13 = (void *)v45[0];
    unint64_t v23 = a9 >> 7;
    unint64_t v24 = *(void *)(v45[0] + 16LL);
    unint64_t v25 = HIBYTE(a11);
    unint64_t v26 = HIWORD(a11);
    unint64_t v27 = a11 >> 40;
    unint64_t v28 = HIDWORD(a11);
    unint64_t v29 = a11 >> 24;
    while (1)
    {
      char v46 = v22;
      __int16 v47 = *(_WORD *)((char *)&a11 + 1);
      char v48 = v29;
      char v49 = v28;
      char v50 = v27;
      char v51 = v26;
      char v52 = v25;
      char v30 = *(&v46 + v23);
      unint64_t v31 = v13[3];
      v45[0] = v13;
      if (v24 >= v31 >> 1)
      {
        unint64_t v42 = v25;
        unint64_t v43 = v22;
        unint64_t v40 = v27;
        unint64_t v41 = v26;
        unint64_t v38 = v29;
        unint64_t v39 = v28;
        sub_10006972C(v31 > 1, v24 + 1, 1);
        unint64_t v29 = v38;
        unint64_t v28 = v39;
        unint64_t v27 = v40;
        unint64_t v26 = v41;
        unint64_t v25 = v42;
        unint64_t v22 = v43;
        unint64_t v13 = (void *)v45[0];
      }

      v13[2] = v24 + 1;
      *((_BYTE *)v13 + v24 + 32) = v30;
      if (v11 >= 0xFFFFFFFFFFFFFF80LL) {
        break;
      }
      v11 += 128LL;
      ++v23;
      ++v24;
      if (!--v21) {
        goto LABEL_3;
      }
    }

    __break(1u);
LABEL_13:
    __break(1u);
    JUMPOUT(0x10009B8C4LL);
  }

uint64_t sub_10009B968(uint64_t a1)
{
  return sub_10009B988(a1);
}

uint64_t sub_10009B988(uint64_t a1)
{
  uint64_t v2 = type metadata accessor for SHA256Digest(0LL);
  uint64_t v31 = *(void *)(v2 - 8);
  unint64_t v32 = v2;
  __chkstk_darwin(v2);
  uint64_t v4 = (char *)&v28 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v29 = type metadata accessor for SHA256(0LL);
  uint64_t v5 = *(void *)(v29 - 8);
  __chkstk_darwin(v29);
  uint64_t v7 = (char *)&v28 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  unint64_t v28 = (char *)v36 + 4;
  char v30 = (char *)&v36[1] + 2;
  char v33 = (char *)&v36[3] + 4;
  HIDWORD(v36[262]) = 0;
  LOWORD(v36[263]) = 0;
  bzero((char *)v36 + 4, 0x822uLL);
  LOBYTE(v36[262]) = 0;
  v36[261] = 0LL;
  *(void *)((char *)&v36[263] + 4) = 0LL;
  BYTE4(v36[264]) = 0;
  memset(&v36[265], 0, 53);
  LOBYTE(v36[0]) = *(_BYTE *)a1;
  BYTE1(v36[0]) = *(_BYTE *)(a1 + 74);
  WORD1(v36[0]) = *(unsigned __int8 *)(a1 + 1);
  uint64_t v8 = *(void *)(a1 + 64);
  uint64_t v9 = swift_bridgeObjectRetain(v8);
  SHA256.init()(v9);
  Swift::String v10 = String.lowercased()();
  swift_bridgeObjectRelease(v8);
  swift_bridgeObjectRetain(v10._object);
  uint64_t v11 = v34;
  sub_10016B208( v10._countAndFlagsBits,  (uint64_t)v10._object,  (uint64_t)v7,  v10._countAndFlagsBits,  (uint64_t)v10._object,  v12);
  uint64_t v13 = swift_bridgeObjectRelease(v10._object);
  SHA256.finalize()(v13);
  SHA256Digest.withUnsafeBytes<A>(_:)(v37, sub_10016BB10, 0LL, &type metadata for Data);
  uint64_t v34 = v11;
  (*(void (**)(char *, unint64_t))(v31 + 8))(v4, v32);
  uint64_t v14 = v37[0];
  unint64_t v15 = v37[1];
  (*(void (**)(char *, uint64_t))(v5 + 8))(v7, v29);
  v37[0] = v14;
  v37[1] = v15;
  unint64_t v32 = sub_10005D508();
  DataProtocol.copyBytes(to:)(v28, v30, &type metadata for Data, v32);
  sub_1000208D8(v14, v15);
  __int128 v16 = *(_OWORD *)(a1 + 8);
  WORD2(v16) = *(_OWORD *)(a1 + 12);
  WORD3(v16) = *(_OWORD *)(a1 + 2);
  DWORD2(v16) = *(_DWORD *)(a1 + 4);
  HIDWORD(v16) = *(_DWORD *)(a1 + 46);
  __int16 v17 = *(_WORD *)(a1 + 50);
  *(_OWORD *)((char *)&v36[1] + 2) = v16;
  WORD1(v36[3]) = v17;
  HIDWORD(v36[262]) = 0;
  LOWORD(v36[263]) = 0;
  LODWORD(v36[265]) = 0;
  bzero(v33, 0x80AuLL);
  LOBYTE(v36[262]) = 0;
  v36[261] = 0LL;
  *(void *)((char *)&v36[263] + 4) = 0LL;
  BYTE4(v36[264]) = 0;
  uint64_t v18 = *(void *)(a1 + 128);
  if (v18 == 1)
  {
    BYTE4(v36[265]) = 0;
  }

  else
  {
    uint64_t v19 = *(void *)(a1 + 80);
    uint64_t v20 = *(void *)(a1 + 88);
    unint64_t v22 = *(void *)(a1 + 96);
    uint64_t v21 = *(void *)(a1 + 104);
    unint64_t v23 = *(void *)(a1 + 112);
    char v33 = *(void **)(a1 + 120);
    uint64_t v31 = v19;
    BYTE4(v36[265]) = v19 + 1;
    v37[0] = v20;
    v37[1] = v22;
    sub_100020AFC(v20, v22);
    sub_10002255C(v21, v23);
    swift_bridgeObjectRetain(v18);
    DataProtocol.copyBytes(to:)((char *)&v36[265] + 5, (char *)&v36[269] + 5, &type metadata for Data, v32);
    if (v23 >> 60 == 15)
    {
      sub_1000AADB0(v31, v20, v22, v21, v23, (uint64_t)v33, v18);
    }

    else
    {
      v37[0] = v21;
      v37[1] = v23;
      sub_100020AFC(v21, v23);
      DataProtocol.copyBytes(to:)((char *)&v36[269] + 5, (char *)&v36[271] + 5, &type metadata for Data, v32);
      sub_1000AADB0(v31, v20, v22, v21, v23, (uint64_t)v33, v18);
      sub_100020B40(v21, v23);
    }
  }

  memcpy(v37, v36, sizeof(v37));
  uint64_t v24 = v35[5];
  uint64_t v25 = v35[2];
  uint64_t v26 = v35[3];
  swift_retain();
  swift_bridgeObjectRetain(v26);
  AppleDevice.setRequest(requestType:data:on:)(0x13CuLL, (uint64_t)v37, (uint64_t)&v38, 0, v25, v26);
  swift_bridgeObjectRelease(v26);
  return swift_release(v24);
}

uint64_t IO80211Driver<>.send(datapathResponse:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v44 = a4;
  uint64_t v46 = a2;
  uint64_t v45 = a3;
  uint64_t v5 = type metadata accessor for SHA256Digest(0LL);
  uint64_t v40 = *(void *)(v5 - 8);
  unint64_t v41 = v5;
  __chkstk_darwin(v5);
  uint64_t v7 = (char *)&v36 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v38 = type metadata accessor for SHA256(0LL);
  uint64_t v8 = *(void *)(v38 - 8);
  __chkstk_darwin(v38);
  Swift::String v10 = (char *)&v36 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v37 = (char *)v47 + 4;
  unint64_t v39 = (char *)&v47[1] + 2;
  unint64_t v42 = (char *)&v47[3] + 4;
  HIDWORD(v47[262]) = 0;
  LOWORD(v47[263]) = 0;
  bzero((char *)v47 + 4, 0x822uLL);
  LOBYTE(v47[262]) = 0;
  v47[261] = 0LL;
  *(void *)((char *)&v47[263] + 4) = 0LL;
  BYTE4(v47[264]) = 0;
  memset(&v47[265], 0, 53);
  LOBYTE(v47[0]) = *(_BYTE *)a1;
  BYTE1(v47[0]) = *(_BYTE *)(a1 + 74);
  WORD1(v47[0]) = *(unsigned __int8 *)(a1 + 1);
  uint64_t v11 = *(void *)(a1 + 64);
  uint64_t v12 = swift_bridgeObjectRetain(v11);
  SHA256.init()(v12);
  Swift::String v13 = String.lowercased()();
  swift_bridgeObjectRelease(v11);
  swift_bridgeObjectRetain(v13._object);
  uint64_t v14 = v43;
  sub_10016B208( v13._countAndFlagsBits,  (uint64_t)v13._object,  (uint64_t)v10,  v13._countAndFlagsBits,  (uint64_t)v13._object,  v15);
  uint64_t v16 = swift_bridgeObjectRelease(v13._object);
  SHA256.finalize()(v16);
  SHA256Digest.withUnsafeBytes<A>(_:)(v48, sub_10016BB10, 0LL, &type metadata for Data);
  uint64_t v43 = v14;
  (*(void (**)(char *, unint64_t))(v40 + 8))(v7, v41);
  uint64_t v17 = v48[0];
  unint64_t v18 = v48[1];
  (*(void (**)(char *, uint64_t))(v8 + 8))(v10, v38);
  v48[0] = v17;
  v48[1] = v18;
  unint64_t v41 = sub_10005D508();
  DataProtocol.copyBytes(to:)(v37, v39, &type metadata for Data, v41);
  sub_1000208D8(v17, v18);
  __int128 v19 = *(_OWORD *)(a1 + 8);
  WORD2(v19) = *(_OWORD *)(a1 + 12);
  WORD3(v19) = *(_OWORD *)(a1 + 2);
  DWORD2(v19) = *(_DWORD *)(a1 + 4);
  HIDWORD(v19) = *(_DWORD *)(a1 + 46);
  __int16 v20 = *(_WORD *)(a1 + 50);
  *(_OWORD *)((char *)&v47[1] + 2) = v19;
  WORD1(v47[3]) = v20;
  HIDWORD(v47[262]) = 0;
  LOWORD(v47[263]) = 0;
  LODWORD(v47[265]) = 0;
  bzero(v42, 0x80AuLL);
  LOBYTE(v47[262]) = 0;
  v47[261] = 0LL;
  *(void *)((char *)&v47[263] + 4) = 0LL;
  BYTE4(v47[264]) = 0;
  uint64_t v21 = *(void *)(a1 + 128);
  if (v21 == 1)
  {
    BYTE4(v47[265]) = 0;
  }

  else
  {
    uint64_t v22 = *(void *)(a1 + 80);
    uint64_t v23 = *(void *)(a1 + 88);
    unint64_t v25 = *(void *)(a1 + 96);
    uint64_t v24 = *(void *)(a1 + 104);
    unint64_t v26 = *(void *)(a1 + 112);
    unint64_t v42 = *(void **)(a1 + 120);
    uint64_t v40 = v22;
    BYTE4(v47[265]) = v22 + 1;
    v48[0] = v23;
    v48[1] = v25;
    sub_100020AFC(v23, v25);
    sub_10002255C(v24, v26);
    swift_bridgeObjectRetain(v21);
    DataProtocol.copyBytes(to:)((char *)&v47[265] + 5, (char *)&v47[269] + 5, &type metadata for Data, v41);
    if (v26 >> 60 == 15)
    {
      sub_1000AADB0(v40, v23, v25, v24, v26, (uint64_t)v42, v21);
    }

    else
    {
      v48[0] = v24;
      v48[1] = v26;
      sub_100020AFC(v24, v26);
      DataProtocol.copyBytes(to:)((char *)&v47[269] + 5, (char *)&v47[271] + 5, &type metadata for Data, v41);
      sub_1000AADB0(v40, v23, v25, v24, v26, (uint64_t)v42, v21);
      sub_100020B40(v24, v26);
    }
  }

  memcpy(v48, v47, sizeof(v48));
  type metadata accessor for apple80211_nan_dp_response(0LL);
  uint64_t v28 = v27;
  uint64_t v29 = v45;
  uint64_t v30 = *(void *)(v45 + 8);
  uint64_t v31 = *(void *)(v44 + 16);
  uint64_t v32 = v46;
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v30,  v46,  &protocol requirements base descriptor for DeviceDriver);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v29,  v32,  AssociatedTypeWitness,  &protocol requirements base descriptor for IO80211Driver,  &associated conformance descriptor for IO80211Driver.DeviceDriver.Device: IO80211Device);
  return sub_1000A0728(316LL, (uint64_t)v48, v32, v28, v30, v31, AssociatedConformanceWitness);
}

uint64_t sub_10009C220(unint64_t a1)
{
  return sub_10004EC24(0x13FuLL, HIWORD(a1) & 0xFF00u | a1 | (a1 >> 8 << 16));
}

uint64_t IO80211Driver<>.send(datapathConfirmation:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v14[0] = a1;
  v14[1] = HIBYTE(a1);
  _DWORD v14[2] = BYTE1(a1);
  void v14[3] = BYTE2(a1);
  v14[4] = BYTE3(a1);
  v14[5] = BYTE4(a1);
  _BYTE v14[6] = BYTE5(a1);
  v14[7] = BYTE6(a1);
  type metadata accessor for apple80211_nan_dp_confirm(0LL);
  uint64_t v8 = v7;
  uint64_t v9 = *(void *)(a3 + 8);
  uint64_t v10 = *(void *)(a4 + 16);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v9,  a2,  &protocol requirements base descriptor for DeviceDriver);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a3,  a2,  AssociatedTypeWitness,  &protocol requirements base descriptor for IO80211Driver,  &associated conformance descriptor for IO80211Driver.DeviceDriver.Device: IO80211Device);
  return sub_1000A0728(319LL, (uint64_t)v14, a2, v8, v9, v10, AssociatedConformanceWitness);
}

uint64_t sub_10009C344(uint64_t a1)
{
  return IO80211Driver<>.update(availability:)(a1);
}

uint64_t IO80211Driver<>.update(availability:)(uint64_t a1)
{
  __int16 v3 = 0;
  __int128 v36 = 0u;
  memset(v37, 0, sizeof(v37));
  __int128 v34 = 0u;
  __int128 v35 = 0u;
  uint64_t v38 = 0LL;
  __int128 v40 = 0u;
  __int128 v41 = 0u;
  __int128 v42 = 0u;
  memset(v43, 0, sizeof(v43));
  uint64_t v44 = 0LL;
  __int128 v46 = 0u;
  __int128 v47 = 0u;
  __int128 v48 = 0u;
  memset(v49, 0, sizeof(v49));
  uint64_t v50 = 0LL;
  __int128 v52 = 0u;
  __int128 v53 = 0u;
  __int128 v54 = 0u;
  memset(v55, 0, sizeof(v55));
  uint64_t v56 = 0LL;
  __int128 v58 = 0u;
  __int128 v59 = 0u;
  __int128 v60 = 0u;
  memset(v61, 0, sizeof(v61));
  uint64_t v62 = 0LL;
  __int128 v64 = 0u;
  __int128 v65 = 0u;
  __int128 v66 = 0u;
  memset(v67, 0, sizeof(v67));
  uint64_t v68 = 0LL;
  __int128 v72 = 0u;
  memset(v73, 0, sizeof(v73));
  __int128 v70 = 0u;
  __int128 v71 = 0u;
  uint64_t v74 = 0LL;
  __int128 v78 = 0u;
  memset(v79, 0, sizeof(v79));
  __int128 v76 = 0u;
  __int128 v77 = 0u;
  uint64_t v80 = 0LL;
  __int128 v82 = 0u;
  __int128 v83 = 0u;
  __int128 v84 = 0u;
  memset(v85, 0, sizeof(v85));
  uint64_t v86 = 0LL;
  __int128 v90 = 0u;
  memset(v91, 0, sizeof(v91));
  __int128 v88 = 0u;
  __int128 v89 = 0u;
  uint64_t v92 = 0LL;
  __int128 v96 = 0u;
  memset(v97, 0, sizeof(v97));
  __int128 v94 = 0u;
  __int128 v95 = 0u;
  uint64_t v98 = 0LL;
  __int128 v102 = 0u;
  memset(v103, 0, sizeof(v103));
  __int128 v100 = 0u;
  __int128 v101 = 0u;
  uint64_t v104 = 0LL;
  __int128 v108 = 0u;
  memset(v109, 0, sizeof(v109));
  __int128 v106 = 0u;
  __int128 v107 = 0u;
  uint64_t v110 = 0LL;
  __int128 v114 = 0u;
  memset(v115, 0, sizeof(v115));
  __int128 v112 = 0u;
  __int128 v113 = 0u;
  uint64_t v116 = 0LL;
  __int128 v120 = 0u;
  memset(v121, 0, sizeof(v121));
  __int128 v118 = 0u;
  __int128 v119 = 0u;
  uint64_t v122 = 0LL;
  __int128 v126 = 0u;
  memset(v127, 0, sizeof(v127));
  __int128 v124 = 0u;
  __int128 v125 = 0u;
  uint64_t v128 = 0LL;
  __int128 v134 = 0u;
  memset(v135, 0, sizeof(v135));
  __int128 v132 = 0u;
  __int128 v133 = 0u;
  uint64_t v136 = 0LL;
  __int128 v140 = 0u;
  memset(v141, 0, sizeof(v141));
  __int128 v138 = 0u;
  __int128 v139 = 0u;
  uint64_t v142 = 0LL;
  __int128 v146 = 0u;
  memset(v147, 0, sizeof(v147));
  __int128 v144 = 0u;
  __int128 v145 = 0u;
  uint64_t v148 = 0LL;
  __int128 v152 = 0u;
  memset(v153, 0, sizeof(v153));
  __int128 v150 = 0u;
  __int128 v151 = 0u;
  uint64_t v154 = 0LL;
  __int128 v158 = 0u;
  memset(v159, 0, sizeof(v159));
  __int128 v156 = 0u;
  __int128 v157 = 0u;
  uint64_t v160 = 0LL;
  __int128 v164 = 0u;
  memset(v165, 0, sizeof(v165));
  __int128 v162 = 0u;
  __int128 v163 = 0u;
  uint64_t v166 = 0LL;
  __int128 v170 = 0u;
  memset(v171, 0, sizeof(v171));
  __int128 v168 = 0u;
  __int128 v169 = 0u;
  uint64_t v172 = 0LL;
  __int128 v176 = 0u;
  memset(v177, 0, sizeof(v177));
  __int128 v174 = 0u;
  __int128 v175 = 0u;
  uint64_t v178 = 0LL;
  __int128 v182 = 0u;
  memset(v183, 0, sizeof(v183));
  __int128 v180 = 0u;
  __int128 v181 = 0u;
  uint64_t v184 = 0LL;
  __int128 v188 = 0u;
  memset(v189, 0, sizeof(v189));
  __int128 v186 = 0u;
  __int128 v187 = 0u;
  uint64_t v190 = 0LL;
  __int128 v194 = 0u;
  memset(v195, 0, sizeof(v195));
  __int128 v192 = 0u;
  __int128 v193 = 0u;
  uint64_t v196 = 0LL;
  __int128 v200 = 0u;
  memset(v201, 0, sizeof(v201));
  __int128 v198 = 0u;
  __int128 v199 = 0u;
  uint64_t v202 = 0LL;
  __int128 v206 = 0u;
  memset(v207, 0, sizeof(v207));
  __int128 v204 = 0u;
  __int128 v205 = 0u;
  uint64_t v208 = 0LL;
  __int128 v212 = 0u;
  memset(v213, 0, sizeof(v213));
  __int128 v210 = 0u;
  __int128 v211 = 0u;
  uint64_t v214 = 0LL;
  __int128 v218 = 0u;
  memset(v219, 0, sizeof(v219));
  __int128 v216 = 0u;
  __int128 v217 = 0u;
  uint64_t v220 = 0LL;
  __int128 v224 = 0u;
  memset(v225, 0, sizeof(v225));
  __int128 v222 = 0u;
  __int128 v223 = 0u;
  int v226 = 0;
  __int16 v30 = 0;
  char v31 = 0;
  __int16 v32 = 0;
  char v33 = 0;
  __int16 v130 = 0;
  char v131 = 0;
  __int128 v13 = 0u;
  __int128 v14 = 0u;
  __int128 v15 = 0u;
  __int128 v16 = 0u;
  __int128 v17 = 0u;
  __int128 v18 = 0u;
  __int128 v19 = 0u;
  __int128 v20 = 0u;
  __int128 v21 = 0u;
  __int128 v22 = 0u;
  __int128 v23 = 0u;
  __int128 v24 = 0u;
  __int128 v25 = 0u;
  __int128 v26 = 0u;
  __int128 v27 = 0u;
  __int128 v28 = 0u;
  memset(v29, 0, sizeof(v29));
  uint64_t v4 = 0LL;
  __int16 v5 = 0;
  __int128 v6 = 0u;
  __int128 v7 = 0u;
  __int128 v8 = 0u;
  __int128 v9 = 0u;
  __int128 v10 = 0u;
  __int128 v11 = 0u;
  __int128 v12 = 0u;
  char v39 = 0;
  char v45 = 0;
  char v51 = 0;
  char v57 = 0;
  char v63 = 0;
  char v69 = 0;
  char v75 = 0;
  char v81 = 0;
  char v87 = 0;
  char v93 = 0;
  char v99 = 0;
  char v105 = 0;
  char v111 = 0;
  char v117 = 0;
  char v123 = 0;
  char v129 = 0;
  char v137 = 0;
  char v143 = 0;
  char v149 = 0;
  char v155 = 0;
  char v161 = 0;
  char v167 = 0;
  char v173 = 0;
  char v179 = 0;
  char v185 = 0;
  char v191 = 0;
  char v197 = 0;
  char v203 = 0;
  char v209 = 0;
  char v215 = 0;
  char v221 = 0;
  __int16 v227 = 0;
  return sub_1000A30C0((uint64_t)&v30, (uint64_t)&v228, a1, &v2);
}

uint64_t sub_10009C7B4(uint64_t a1)
{
  return sub_1000AB11C(a1);
}

uint64_t IO80211Driver<>.update(potentialAvailability:)(uint64_t result)
{
  uint64_t v2 = v1;
  uint64_t v3 = *(void *)(result + 16);
  if (v3)
  {
    uint64_t v4 = result + 32;
    uint64_t v18 = result;
    swift_bridgeObjectRetain(result);
    unint64_t v5 = 0LL;
    while (1)
    {
      if (v5 < 2)
      {
        unint64_t v6 = v4 + 16 * v5;
        uint64_t v7 = *(void *)(v6 + 8);
        __int16 v8 = *(_WORD *)(v6 + 2);
        swift_bridgeObjectRetain(v7);
        sub_100071514(0LL, 4LL, v8);
        if (v2)
        {
          uint64_t result = swift_unexpectedError(v2, "CoreP2P/NANAttribute.swift", 26LL, 1LL);
          __break(1u);
          return result;
        }

        uint64_t v9 = *(void *)(v7 + 16);
        if (v9)
        {
          swift_bridgeObjectRetain(v7);
          unsigned int v10 = 0;
          uint64_t v11 = 32LL;
          do
          {
            __int128 v12 = *(_OWORD *)(v7 + v11);
            __int128 v13 = *(_OWORD *)(v7 + v11 + 16);
            __int128 v14 = *(_OWORD *)(v7 + v11 + 32);
            char v17 = *(_BYTE *)(v7 + v11 + 48);
            v16[1] = v13;
            _BYTE v16[2] = v14;
            v16[0] = v12;
            if (v10 <= 0xF)
            {
              sub_1000AAE04(v16);
              sub_1000A32E4((unint64_t)&v15);
              sub_1000AAE3C(v16);
              ++v10;
            }

            v11 += 56LL;
            --v9;
          }

          while (v9);
          swift_bridgeObjectRelease(v7);
        }

        swift_bridgeObjectRelease(v7);
      }

      if (++v5 == v3) {
        return swift_bridgeObjectRelease(v18);
      }
    }
  }

  return result;
}

uint64_t sub_10009C944(uint64_t a1, uint64_t a2)
{
  return IO80211Driver<>.update(dataCluster:)(a1 & 0xFFFFFFFFFFFFFFLL, a2);
}

uint64_t IO80211Driver<>.update(dataCluster:)(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 16);
  if (v2)
  {
    uint64_t v5 = *(void *)(a2 + 48);
    unint64_t v4 = *(void *)(a2 + 56);
    __int16 v6 = *(_WORD *)(a2 + 40);
    swift_bridgeObjectRetain(a2);
    sub_100020AFC(v5, v4);
    sub_1000A36C4(v6, v5, v4);
    sub_1000208D8(v5, v4);
    if (v2 != 1)
    {
      uint64_t v8 = *(void *)(a2 + 80);
      unint64_t v7 = *(void *)(a2 + 88);
      __int16 v9 = *(_WORD *)(a2 + 72);
      sub_100020AFC(v8, v7);
      sub_1000A36C4(v9, v8, v7);
      sub_1000208D8(v8, v7);
    }

    return swift_bridgeObjectRelease(a2);
  }

  return result;
}

uint64_t sub_10009CA4C(uint64_t a1, void *a2)
{
  return sub_10009CA6C(a1, a2);
}

uint64_t sub_10009CA6C(uint64_t a1, void *a2)
{
  unint64_t v3 = a1;
  v22[4] = 0;
  v22[76] = 0;
  memset(&v22[6], 0, 69);
  memset(&v22[78], 0, 69);
  if (!a2)
  {
    void v22[2] = 0;
    sub_1000A398C((uint64_t)&v22[4], (uint64_t)&v23, a1, 0LL);
    LODWORD(v3) = 0;
    char v4 = 0;
    goto LABEL_6;
  }

  if (a2[2] < 0x100uLL)
  {
    void v22[2] = a2[2];
    sub_1000A398C((uint64_t)&v22[4], (uint64_t)&v23, a1, a2);
    if (!HIDWORD(v3))
    {
      char v4 = 1;
LABEL_6:
      __int128 v17 = *(_OWORD *)&v22[98];
      __int128 v18 = *(_OWORD *)&v22[114];
      __int128 v19 = *(_OWORD *)&v22[130];
      __int128 v13 = *(_OWORD *)&v22[34];
      __int128 v14 = *(_OWORD *)&v22[50];
      __int128 v15 = *(_OWORD *)&v22[66];
      __int128 v16 = *(_OWORD *)&v22[82];
      __int128 v11 = *(_OWORD *)&v22[2];
      __int16 v20 = *(_WORD *)&v22[146];
      __int128 v12 = *(_OWORD *)&v22[18];
      v9[0] = v4;
      int v10 = v3;
      int v21 = 0;
      uint64_t v5 = v2[5];
      uint64_t v6 = v2[2];
      uint64_t v7 = v2[3];
      swift_retain();
      swift_bridgeObjectRetain(v7);
      AppleDevice.setRequest(requestType:data:on:)(0x14DuLL, (uint64_t)v9, (uint64_t)v22, 0, v6, v7);
      swift_bridgeObjectRelease(v7);
      return swift_release(v5);
    }
  }

  uint64_t result = _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  "Not enough bits to represent the passed value",  45LL,  2LL,  "Swift/Integers.swift",  20LL,  2,  3455LL,  0);
  __break(1u);
  return result;
}

uint64_t IO80211Driver<>.update(discoveryBeaconTransmissionSchedule:)( uint64_t a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  unint64_t v8 = a1;
  v30[2] = 0;
  v30[74] = 0;
  memset(&v30[4], 0, 69);
  memset(&v30[76], 0, 69);
  if (!a2)
  {
    v30[0] = 0;
    sub_1000A398C((uint64_t)&v30[2], (uint64_t)&v31, a1, 0LL);
    LODWORD(v8) = 0;
    char v9 = 0;
    goto LABEL_6;
  }

  if (a2[2] < 0x100uLL)
  {
    v30[0] = a2[2];
    sub_1000A398C((uint64_t)&v30[2], (uint64_t)&v31, a1, a2);
    if (!HIDWORD(v8))
    {
      char v9 = 1;
LABEL_6:
      __int128 v25 = *(_OWORD *)&v30[96];
      __int128 v26 = *(_OWORD *)&v30[112];
      __int128 v27 = *(_OWORD *)&v30[128];
      __int128 v21 = *(_OWORD *)&v30[32];
      __int128 v22 = *(_OWORD *)&v30[48];
      __int128 v23 = *(_OWORD *)&v30[64];
      __int128 v24 = *(_OWORD *)&v30[80];
      __int128 v19 = *(_OWORD *)v30;
      __int16 v28 = *(_WORD *)&v30[144];
      __int128 v20 = *(_OWORD *)&v30[16];
      v17[0] = v9;
      int v18 = v8;
      int v29 = 0;
      type metadata accessor for apple80211_nan_forced_disc_beacon_transmission(0LL);
      uint64_t v11 = v10;
      uint64_t v12 = *(void *)(a4 + 8);
      uint64_t v13 = *(void *)(a5 + 16);
      uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v12,  a3,  &protocol requirements base descriptor for DeviceDriver);
      uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a4,  a3,  AssociatedTypeWitness,  &protocol requirements base descriptor for IO80211Driver,  &associated conformance descriptor for IO80211Driver.DeviceDriver.Device: IO80211Device);
      return sub_1000A0728(333LL, (uint64_t)v17, a3, v11, v12, v13, AssociatedConformanceWitness);
    }
  }

  uint64_t result = _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  "Not enough bits to represent the passed value",  45LL,  2LL,  "Swift/Integers.swift",  20LL,  2,  3455LL,  0);
  __break(1u);
  return result;
}

uint64_t sub_10009CE5C(uint64_t a1, uint64_t a2)
{
  return sub_10004F2B4(0x181uLL, a2 & 0xFFFFFFFFFFFFFFLL, a1 != 0);
}

uint64_t IO80211Driver<>.update(linkStatus:for:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  __int16 v15 = a2;
  char v16 = BYTE2(a2);
  char v17 = BYTE3(a2);
  char v18 = BYTE4(a2);
  char v19 = BYTE5(a2);
  char v20 = BYTE6(a2);
  BOOL v21 = a1 != 0;
  type metadata accessor for apple80211_nan_dp_link_status(0LL);
  uint64_t v9 = v8;
  uint64_t v10 = *(void *)(a4 + 8);
  uint64_t v11 = *(void *)(a5 + 16);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v10,  a3,  &protocol requirements base descriptor for DeviceDriver);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a4,  a3,  AssociatedTypeWitness,  &protocol requirements base descriptor for IO80211Driver,  &associated conformance descriptor for IO80211Driver.DeviceDriver.Device: IO80211Device);
  return sub_1000A0728(385LL, (uint64_t)&v15, a3, v9, v10, v11, AssociatedConformanceWitness);
}

uint64_t sub_10009CF80(char a1)
{
  return sub_10004F3A4(0x18EuLL, (unint64_t)&_mh_execute_header & 0xFFFFFFFFFFFFFFFELL | a1 & 1);
}

uint64_t IO80211Driver<>.update(powerSaveRestriction:)(char a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v14[0] = a1;
  int v15 = 1;
  type metadata accessor for apple80211_nan_ps_restriction(0LL);
  uint64_t v8 = v7;
  uint64_t v9 = *(void *)(a3 + 8);
  uint64_t v10 = *(void *)(a4 + 16);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v9,  a2,  &protocol requirements base descriptor for DeviceDriver);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a3,  a2,  AssociatedTypeWitness,  &protocol requirements base descriptor for IO80211Driver,  &associated conformance descriptor for IO80211Driver.DeviceDriver.Device: IO80211Device);
  return sub_1000A0728(398LL, (uint64_t)v14, a2, v8, v9, v10, AssociatedConformanceWitness);
}

uint64_t sub_10009D06C(unsigned int a1)
{
  if ((a1 & 0x100) != 0) {
    char v1 = 0;
  }
  else {
    char v1 = a1;
  }
  uint64_t v2 = 0x200000000LL;
  if ((a1 & 0x100) == 0) {
    uint64_t v2 = (uint64_t)&_mh_execute_header;
  }
  return sub_10004F468(0x190uLL, v2 | HIWORD(a1) & 1, v1);
}

uint64_t IO80211Driver<>.update(internetSharingActivity:)(int a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if ((a1 & 0x100) != 0) {
    char v7 = 0;
  }
  else {
    char v7 = a1;
  }
  v16[0] = BYTE2(a1) & 1;
  if ((a1 & 0x100) != 0) {
    int v8 = 2;
  }
  else {
    int v8 = 1;
  }
  int v17 = v8;
  char v18 = v7;
  type metadata accessor for apple80211_nan_ir_status(0LL);
  uint64_t v10 = v9;
  uint64_t v11 = *(void *)(a3 + 8);
  uint64_t v12 = *(void *)(a4 + 16);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v11,  a2,  &protocol requirements base descriptor for DeviceDriver);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a3,  a2,  AssociatedTypeWitness,  &protocol requirements base descriptor for IO80211Driver,  &associated conformance descriptor for IO80211Driver.DeviceDriver.Device: IO80211Device);
  return sub_1000A0728(400LL, (uint64_t)v16, a2, v10, v11, v12, AssociatedConformanceWitness);
}

id sub_10009D180(uint64_t a1)
{
  return sub_10009D1A4(a1 & 0xFFFFFFFFFFFFLL);
}

id sub_10009D1A4(unint64_t a1)
{
  unint64_t v3 = a1 >> 8;
  unint64_t v4 = a1 >> 16;
  unint64_t v5 = a1 >> 24;
  unint64_t v6 = HIDWORD(a1);
  unint64_t v7 = a1 >> 40;
  uint64_t v8 = type metadata accessor for String.Encoding(0LL);
  __chkstk_darwin(v8);
  uint64_t v75 = (uint64_t)&v40 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  int v102 = 0;
  int v101 = 0;
  int v100 = 0;
  __int128 v103 = 0u;
  __int128 v104 = 0u;
  __int128 v105 = 0u;
  __int128 v106 = 0u;
  __int128 v107 = 0u;
  __int128 v108 = 0u;
  __int128 v109 = 0u;
  __int128 v110 = 0u;
  __int128 v111 = 0u;
  __int128 v112 = 0u;
  memset(v113, 0, 27);
  bzero(&v114, 0x408uLL);
  v99[0] = a1;
  v99[1] = v3;
  v99[2] = v4;
  v99[3] = v5;
  v99[4] = v6;
  v99[5] = v7;
  uint64_t v10 = v1[5];
  uint64_t v11 = v1[2];
  uint64_t v12 = v1[3];
  swift_retain();
  swift_bridgeObjectRetain(v12);
  Class v13 = isa;
  AppleDevice.getRequest(requestType:data:on:)(0x16CuLL, (uint64_t)v99, (uint64_t)v200, 0, v11, v12);
  swift_bridgeObjectRelease(v12);
  id result = (id)swift_release(v10);
  if (!v13)
  {
    id v70 = [objc_allocWithZone(WiFiMACAddress) initWithAddress:a1 & 0xFFFFFFFFFFFFLL];
    v15.super.super.Class isa = UInt8._bridgeToObjectiveC()().super.super.isa;
    __int128 v78 = v114;
    uint64_t v79 = v115;
    __int128 v80 = v116;
    uint64_t v81 = v117;
    __int128 v82 = v118;
    uint64_t v83 = v119;
    __int128 v84 = v120;
    uint64_t v85 = v121;
    __int128 v86 = v122;
    __int128 v88 = v124;
    uint64_t v87 = v123;
    uint64_t v89 = v125;
    __int128 v90 = v126;
    __int128 v92 = v128;
    uint64_t v91 = v127;
    uint64_t v93 = v129;
    __int128 v94 = v130;
    __int128 v96 = v132;
    uint64_t v95 = v131;
    uint64_t v97 = v133;
    sub_1000A3BD8((uint64_t)&v78, (uint64_t)&v98, &v77);
    uint64_t v16 = v77;
    __int128 v78 = v134;
    uint64_t v79 = v135;
    __int128 v80 = v136;
    uint64_t v81 = v137;
    __int128 v82 = v138;
    uint64_t v83 = v139;
    __int128 v84 = v140;
    uint64_t v85 = v141;
    sub_1000A3BD8((uint64_t)&v78, (uint64_t)&v86, &v77);
    uint64_t v61 = 0LL;
    uint64_t v17 = v77;
    v18.super.super.Class isa = UInt8._bridgeToObjectiveC()().super.super.isa;
    Class isa = UInt8._bridgeToObjectiveC()().super.super.isa;
    Class v74 = UInt8._bridgeToObjectiveC()().super.super.isa;
    Class v73 = UInt32._bridgeToObjectiveC()().super.super.isa;
    Class v72 = UInt32._bridgeToObjectiveC()().super.super.isa;
    Class v71 = UInt64._bridgeToObjectiveC()().super.super.isa;
    v19.super.super.Class isa = UInt64._bridgeToObjectiveC()().super.super.isa;
    Class v69 = UInt64._bridgeToObjectiveC()().super.super.isa;
    Class v68 = UInt64._bridgeToObjectiveC()().super.super.isa;
    Class v67 = UInt64._bridgeToObjectiveC()().super.super.isa;
    Class v66 = UInt64._bridgeToObjectiveC()().super.super.isa;
    sub_100058CD0(0LL, (unint64_t *)&unk_10040D590, &OBJC_CLASS___NSNumber_ptr);
    v20.super.super.Class isa = NSNumber.init(integerLiteral:)(0LL).super.super.isa;
    Class v65 = UInt64._bridgeToObjectiveC()().super.super.isa;
    Class v64 = UInt64._bridgeToObjectiveC()().super.super.isa;
    Class v63 = UInt64._bridgeToObjectiveC()().super.super.isa;
    Class v62 = UInt64._bridgeToObjectiveC()().super.super.isa;
    v21.super.super.Class isa = UInt64._bridgeToObjectiveC()().super.super.isa;
    if (__CFADD__(*((void *)&v106 + 1), (void)v109)) {
      __break(1u);
    }
    Class v59 = v18.super.super.isa;
    uint64_t v60 = v17;
    Class v58 = v21.super.super.isa;
    Class v57 = UInt64._bridgeToObjectiveC()().super.super.isa;
    Class v56 = UInt64._bridgeToObjectiveC()().super.super.isa;
    Class v55 = UInt64._bridgeToObjectiveC()().super.super.isa;
    Class v54 = UInt64._bridgeToObjectiveC()().super.super.isa;
    Class v53 = UInt64._bridgeToObjectiveC()().super.super.isa;
    Class v52 = UInt64._bridgeToObjectiveC()().super.super.isa;
    Class v51 = UInt64._bridgeToObjectiveC()().super.super.isa;
    Class v50 = UInt64._bridgeToObjectiveC()().super.super.isa;
    Class v49 = UInt32._bridgeToObjectiveC()().super.super.isa;
    Class v48 = UInt32._bridgeToObjectiveC()().super.super.isa;
    Class v46 = UInt32._bridgeToObjectiveC()().super.super.isa;
    Class v44 = UInt32._bridgeToObjectiveC()().super.super.isa;
    Class v42 = UInt32._bridgeToObjectiveC()().super.super.isa;
    Class v47 = v20.super.super.isa;
    __int16 v22 = v113[12];
    uint64_t v23 = sub_100002274(&qword_1004040A8);
    uint64_t v24 = swift_allocObject(v23, 34LL, 7LL);
    uint64_t v45 = v16;
    uint64_t v25 = v24;
    *(_OWORD *)(v24 + 16) = xmmword_10033B810;
    *(_WORD *)(v24 + 32) = v22;
    *(void *)&__int128 v78 = v24;
    Class v43 = v19.super.super.isa;
    uint64_t v26 = v75;
    static String.Encoding.utf8.getter(v24);
    uint64_t v27 = sub_100002274(&qword_100406978);
    Class v41 = v15.super.super.isa;
    uint64_t v28 = v27;
    uint64_t v29 = sub_1000572E4( (unint64_t *)&qword_100406980,  &qword_100406978,  (uint64_t)&protocol conformance descriptor for [A]);
    uint64_t v30 = String.init<A>(bytes:encoding:)(&v78, v26, v28, v29);
    unint64_t v32 = v31;
    swift_bridgeObjectRelease(v25);
    if (v32) {
      uint64_t v33 = v30;
    }
    else {
      uint64_t v33 = 0LL;
    }
    uint64_t v75 = v33;
    unint64_t v34 = 0xE000000000000000LL;
    if (v32) {
      unint64_t v34 = v32;
    }
    unint64_t v40 = v34;
    __int128 v78 = v190;
    uint64_t v79 = v191;
    __int128 v80 = v192;
    uint64_t v81 = v193;
    __int128 v82 = v194;
    uint64_t v83 = v195;
    __int128 v84 = v196;
    uint64_t v85 = v197;
    __int128 v86 = v198;
    uint64_t v87 = v199;
    sub_1000A3BD8((uint64_t)&v78, (uint64_t)&v88, &v77);
    uint64_t v35 = v77;
    __int128 v78 = v162;
    uint64_t v79 = v163;
    __int128 v80 = v164;
    uint64_t v81 = v165;
    __int128 v82 = v166;
    uint64_t v83 = v167;
    __int128 v84 = v168;
    uint64_t v85 = v169;
    __int128 v86 = v170;
    __int128 v88 = v172;
    uint64_t v87 = v171;
    uint64_t v89 = v173;
    __int128 v90 = v174;
    __int128 v92 = v176;
    uint64_t v91 = v175;
    uint64_t v93 = v177;
    __int128 v94 = v178;
    __int128 v96 = v180;
    uint64_t v95 = v179;
    uint64_t v97 = v181;
    sub_1000A3BD8((uint64_t)&v78, (uint64_t)&v98, &v77);
    uint64_t v36 = v77;
    __int128 v78 = v142;
    uint64_t v79 = v143;
    __int128 v80 = v144;
    uint64_t v81 = v145;
    __int128 v82 = v146;
    uint64_t v83 = v147;
    __int128 v84 = v148;
    uint64_t v85 = v149;
    __int128 v86 = v150;
    __int128 v88 = v152;
    uint64_t v87 = v151;
    uint64_t v89 = v153;
    __int128 v90 = v154;
    __int128 v92 = v156;
    uint64_t v91 = v155;
    uint64_t v93 = v157;
    __int128 v94 = v158;
    __int128 v96 = v160;
    uint64_t v95 = v159;
    uint64_t v97 = v161;
    sub_1000A3BD8((uint64_t)&v78, (uint64_t)&v98, &v77);
    uint64_t v37 = v77;
    __int128 v78 = v182;
    uint64_t v79 = v183;
    __int128 v80 = v184;
    uint64_t v81 = v185;
    __int128 v82 = v186;
    uint64_t v83 = v187;
    __int128 v84 = v188;
    uint64_t v85 = v189;
    sub_1000A3BD8((uint64_t)&v78, (uint64_t)&v86, &v77);
    uint64_t v38 = v77;
    id v39 = objc_allocWithZone(&OBJC_CLASS___WiFiAwareDataSessionStatisticsReport);
    return sub_1000A5B78( v70,  v41,  v45,  v60,  v59,  isa,  v74,  v73,  v72,  v71,  v43,  v69,  v68,  v67,  v66,  0,  v47,  v65,  v64,  v63,  v62,  v58,  v57,  v56,  v55,  v54,  v53,  v52,  v51,  v50,  v49,  v48,  v46,  v44,  v42,  v75,  v40,  v35,  v36,  v37,  v38);
  }

  return result;
}

id IO80211Driver<>.generateStatisticsReport(for:)(unint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v83 = a3;
  uint64_t v84 = a4;
  uint64_t v85 = a2;
  unint64_t v5 = a1 >> 8;
  unint64_t v6 = a1 >> 16;
  unint64_t v7 = a1 >> 24;
  unint64_t v8 = HIDWORD(a1);
  unint64_t v9 = a1 >> 40;
  uint64_t v10 = type metadata accessor for String.Encoding(0LL);
  __chkstk_darwin(v10);
  uint64_t v12 = (char *)&v42 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  int v109 = 0;
  int v108 = 0;
  int v107 = 0;
  __int128 v110 = 0u;
  __int128 v111 = 0u;
  __int128 v112 = 0u;
  __int128 v113 = 0u;
  __int128 v114 = 0u;
  __int128 v115 = 0u;
  __int128 v116 = 0u;
  __int128 v117 = 0u;
  __int128 v118 = 0u;
  __int128 v119 = 0u;
  memset(v120, 0, 27);
  bzero(&v121, 0x408uLL);
  v106[0] = a1;
  v106[1] = v5;
  v106[2] = v6;
  uint64_t v106[3] = v7;
  v106[4] = v8;
  v106[5] = v9;
  uint64_t v13 = v85;
  uint64_t v14 = v82;
  id result = (id)sub_1000A3A94((uint64_t)v106, (uint64_t)v198, (uint64_t)isa, v85, v83, v84, &v86);
  if (!v14)
  {
    uint64_t v82 = 0LL;
    id v70 = v12;
    id v16 = [objc_allocWithZone(WiFiMACAddress) initWithAddress:a1 & 0xFFFFFFFFFFFFLL];
    Class isa = UInt8._bridgeToObjectiveC()().super.super.isa;
    __int128 v86 = v121;
    uint64_t v87 = v122;
    __int128 v88 = v123;
    uint64_t v89 = v124;
    __int128 v90 = v125;
    uint64_t v91 = v126;
    __int128 v92 = v127;
    uint64_t v93 = v128;
    __int128 v94 = v129;
    uint64_t v95 = v130;
    __int128 v96 = v131;
    uint64_t v97 = v132;
    __int128 v98 = v133;
    __int128 v100 = v135;
    uint64_t v99 = v134;
    uint64_t v101 = v136;
    __int128 v102 = v137;
    __int128 v104 = v139;
    uint64_t v103 = v138;
    uint64_t v105 = v140;
    uint64_t v74 = sub_100002274(&qword_100406968);
    uint64_t v80 = sub_1000A3B64((uint64_t)&v86, v13, v74);
    __int128 v86 = v141;
    uint64_t v87 = v142;
    __int128 v88 = v143;
    uint64_t v89 = v144;
    __int128 v90 = v145;
    uint64_t v91 = v146;
    __int128 v92 = v147;
    uint64_t v93 = v148;
    uint64_t v72 = sub_100002274(&qword_100406970);
    uint64_t v17 = sub_1000A3B64((uint64_t)&v86, v13, v72);
    Class v79 = UInt8._bridgeToObjectiveC()().super.super.isa;
    Class v78 = UInt8._bridgeToObjectiveC()().super.super.isa;
    Class v77 = UInt8._bridgeToObjectiveC()().super.super.isa;
    Class v76 = UInt32._bridgeToObjectiveC()().super.super.isa;
    Class v75 = UInt32._bridgeToObjectiveC()().super.super.isa;
    Class v73 = UInt64._bridgeToObjectiveC()().super.super.isa;
    Class v71 = UInt64._bridgeToObjectiveC()().super.super.isa;
    v18.super.super.Class isa = UInt64._bridgeToObjectiveC()().super.super.isa;
    Class v69 = UInt64._bridgeToObjectiveC()().super.super.isa;
    Class v68 = UInt64._bridgeToObjectiveC()().super.super.isa;
    Class v67 = UInt64._bridgeToObjectiveC()().super.super.isa;
    sub_100058CD0(0LL, (unint64_t *)&unk_10040D590, &OBJC_CLASS___NSNumber_ptr);
    v19.super.super.Class isa = NSNumber.init(integerLiteral:)(0LL).super.super.isa;
    Class v66 = UInt64._bridgeToObjectiveC()().super.super.isa;
    Class v65 = UInt64._bridgeToObjectiveC()().super.super.isa;
    Class v64 = UInt64._bridgeToObjectiveC()().super.super.isa;
    Class v63 = UInt64._bridgeToObjectiveC()().super.super.isa;
    v20.super.super.Class isa = UInt64._bridgeToObjectiveC()().super.super.isa;
    if (__CFADD__(*((void *)&v113 + 1), (void)v116)) {
      __break(1u);
    }
    Class v42 = (__int128 *)v191;
    Class v44 = v173;
    Class v61 = v20.super.super.isa;
    uint64_t v62 = v17;
    Class v60 = UInt64._bridgeToObjectiveC()().super.super.isa;
    Class v59 = UInt64._bridgeToObjectiveC()().super.super.isa;
    Class v58 = UInt64._bridgeToObjectiveC()().super.super.isa;
    Class v57 = UInt64._bridgeToObjectiveC()().super.super.isa;
    Class v56 = UInt64._bridgeToObjectiveC()().super.super.isa;
    Class v55 = UInt64._bridgeToObjectiveC()().super.super.isa;
    Class v54 = UInt64._bridgeToObjectiveC()().super.super.isa;
    Class v53 = UInt64._bridgeToObjectiveC()().super.super.isa;
    Class v52 = UInt32._bridgeToObjectiveC()().super.super.isa;
    Class v51 = UInt32._bridgeToObjectiveC()().super.super.isa;
    Class v50 = UInt32._bridgeToObjectiveC()().super.super.isa;
    Class v49 = UInt32._bridgeToObjectiveC()().super.super.isa;
    Class v47 = UInt32._bridgeToObjectiveC()().super.super.isa;
    __int16 v21 = v120[12];
    uint64_t v22 = sub_100002274(&qword_1004040A8);
    uint64_t v23 = swift_allocObject(v22, 34LL, 7LL);
    Class v48 = v19.super.super.isa;
    uint64_t v24 = v23;
    *(_OWORD *)(v23 + 16) = xmmword_10033B810;
    *(_WORD *)(v23 + 32) = v21;
    *(void *)&__int128 v86 = v23;
    uint64_t v25 = (uint64_t)v70;
    static String.Encoding.utf8.getter(v23);
    Class v46 = v16;
    uint64_t v26 = sub_100002274(&qword_100406978);
    Class v45 = v18.super.super.isa;
    uint64_t v27 = v26;
    uint64_t v28 = sub_1000572E4( (unint64_t *)&qword_100406980,  &qword_100406978,  (uint64_t)&protocol conformance descriptor for [A]);
    uint64_t v29 = String.init<A>(bytes:encoding:)(&v86, v25, v27, v28);
    unint64_t v31 = v30;
    swift_bridgeObjectRelease(v24);
    if (v31) {
      uint64_t v32 = v29;
    }
    else {
      uint64_t v32 = 0LL;
    }
    id v70 = (char *)v32;
    unint64_t v33 = 0xE000000000000000LL;
    if (v31) {
      unint64_t v33 = v31;
    }
    unint64_t v43 = v33;
    __int128 v86 = *v42;
    uint64_t v87 = v191[2];
    __int128 v88 = v192;
    uint64_t v89 = v193;
    __int128 v90 = v42[3];
    uint64_t v91 = v194;
    __int128 v92 = v195;
    uint64_t v93 = v196;
    __int128 v94 = v42[6];
    uint64_t v95 = v197;
    uint64_t v34 = sub_100002274(&qword_100406988);
    uint64_t v35 = v85;
    Class v42 = (__int128 *)sub_1000A3B64((uint64_t)&v86, v85, v34);
    __int128 v86 = v169;
    uint64_t v87 = v170;
    __int128 v88 = v171;
    uint64_t v89 = v172;
    uint64_t v36 = v44;
    __int128 v90 = *v44;
    uint64_t v91 = v173[2];
    __int128 v92 = v174;
    uint64_t v93 = v175;
    __int128 v94 = v44[3];
    uint64_t v95 = v176;
    __int128 v96 = v177;
    uint64_t v97 = v178;
    __int128 v98 = v44[6];
    __int128 v100 = v180;
    uint64_t v99 = v179;
    uint64_t v101 = v181;
    __int128 v102 = v44[9];
    __int128 v104 = v183;
    uint64_t v103 = v182;
    uint64_t v105 = v184;
    uint64_t v37 = v74;
    uint64_t v38 = sub_1000A3B64((uint64_t)&v86, v35, v74);
    __int128 v86 = v149;
    uint64_t v87 = v150;
    __int128 v88 = v151;
    uint64_t v89 = v152;
    __int128 v90 = v153;
    uint64_t v91 = v154;
    __int128 v92 = v155;
    uint64_t v93 = v156;
    __int128 v94 = v157;
    uint64_t v95 = v158;
    __int128 v96 = v159;
    uint64_t v97 = v160;
    __int128 v98 = v161;
    __int128 v100 = v163;
    uint64_t v99 = v162;
    uint64_t v101 = v164;
    __int128 v102 = v165;
    __int128 v104 = v167;
    uint64_t v103 = v166;
    uint64_t v105 = v168;
    uint64_t v39 = sub_1000A3B64((uint64_t)&v86, v35, v37);
    __int128 v86 = v36[12];
    uint64_t v87 = v185;
    __int128 v88 = v186;
    uint64_t v89 = v187;
    __int128 v90 = v36[15];
    uint64_t v91 = v188;
    __int128 v92 = v189;
    uint64_t v93 = v190;
    uint64_t v40 = sub_1000A3B64((uint64_t)&v86, v35, v72);
    id v41 = objc_allocWithZone(&OBJC_CLASS___WiFiAwareDataSessionStatisticsReport);
    return sub_1000A5B78( v46,  isa,  v80,  v62,  v79,  v78,  v77,  v76,  v75,  v73,  v71,  v45,  v69,  v68,  v67,  0,  v48,  v66,  v65,  v64,  v63,  v61,  v60,  v59,  v58,  v57,  v56,  v55,  v54,  v53,  v52,  v51,  v50,  v49,  v47,  (uint64_t)v70,  v43,  (uint64_t)v42,  v38,  v39,  v40);
  }

  return result;
}

double static InfraStatistics.none.getter@<D0>(_OWORD *a1@<X8>)
{
  double result = 0.0;
  a1[5] = 0u;
  a1[6] = 0u;
  a1[3] = 0u;
  a1[4] = 0u;
  a1[1] = 0u;
  a1[2] = 0u;
  *a1 = 0u;
  return result;
}

uint64_t sub_10009E3E4(uint64_t a1)
{
  return sub_10009E404(a1);
}

uint64_t sub_10009E404(uint64_t result)
{
  unint64_t v2 = *(void *)(result + 16);
  if (v2)
  {
    uint64_t v3 = result;
    unint64_t v31 = v2 - 8;
    unint64_t v32 = *(void *)(result + 16);
    if (v2 >= 8) {
      int64_t v4 = 8LL;
    }
    else {
      int64_t v4 = *(void *)(result + 16);
    }
    memset(v40, 0, 61);
    BYTE4(v40[0]) = v4;
    uint64_t v30 = result + 32;
    *(void *)uint64_t v35 = _swiftEmptyArrayStorage;
    swift_bridgeObjectRetain(result);
    sub_1000698B8(0, v4, 0);
    uint64_t v5 = 0LL;
    unint64_t v6 = _swiftEmptyArrayStorage;
    unint64_t v7 = _swiftEmptyArrayStorage[2];
    uint64_t v8 = 7 * v7;
    uint64_t v9 = 7 * v4;
    do
    {
      v1.i32[0] = *(_DWORD *)(v3 + v5 + 32);
      char v10 = *(_BYTE *)(v3 + v5 + 36);
      char v11 = *(_BYTE *)(v3 + v5 + 37);
      char v12 = *(_BYTE *)(v3 + v5 + 38);
      *(void *)uint64_t v35 = v6;
      unint64_t v13 = v6[3];
      unint64_t v14 = v7 + 1;
      if (v7 >= v13 >> 1)
      {
        sub_1000698B8(v13 > 1, v7 + 1, 1);
        unint64_t v6 = *(void **)v35;
      }

      _BYTE v6[2] = v14;
      NSNumber v15 = (char *)v6 + v8 + v5;
      *((_DWORD *)v15 + 8) = vmovn_s16((int16x8_t)vmovl_u8(v1)).u32[0];
      v15[36] = v10;
      v15[37] = v11;
      v15[38] = v12;
      v5 += 7LL;
      unint64_t v7 = v14;
    }

    while (v9 != v5);
    swift_bridgeObjectRelease(v3);
    uint64_t v16 = v6[2];
    if (v16)
    {
      uint64_t v17 = (char *)v6 + 38;
      NSNumber v18 = (_BYTE *)((unint64_t)v40 | 0xB);
      do
      {
        __int16 v19 = *((_WORD *)v17 - 1);
        char v20 = *v17;
        *(_DWORD *)(v18 - 6) = *(_DWORD *)(v17 - 6);
        *((_WORD *)v18 - 1) = v19;
        *NSNumber v18 = v20;
        v18 += 7;
        v17 += 7;
        --v16;
      }

      while (v16);
    }

    swift_bridgeObjectRelease(v6);
    *(_DWORD *)uint64_t v35 = v40[0];
    *(_OWORD *)&v35[4] = *(_OWORD *)((char *)v40 + 4);
    __int128 v36 = *(_OWORD *)((char *)&v40[1] + 4);
    __int128 v37 = *(_OWORD *)((char *)&v40[2] + 4);
    uint64_t v38 = *(void *)((char *)&v40[3] + 4);
    char v39 = BYTE12(v40[3]);
    uint64_t v21 = v33[5];
    uint64_t v22 = v33[2];
    uint64_t v23 = v33[3];
    swift_retain();
    swift_bridgeObjectRetain(v23);
    AppleDevice.setRequest(requestType:data:on:)(0x16FuLL, (uint64_t)v35, (uint64_t)v40, 0, v22, v23);
    swift_bridgeObjectRelease(v23);
    double result = swift_release(v21);
    if (!v34 && v32 >= 9)
    {
      uint64_t v24 = type metadata accessor for __ContiguousArrayStorageBase(0LL);
      uint64_t v25 = swift_bridgeObjectRetain(v3);
      uint64_t v26 = swift_unknownObjectRetain_n(v25, 2LL);
      uint64_t v27 = (void *)swift_dynamicCastClass(v26, v24);
      if (!v27)
      {
        swift_bridgeObjectRelease(v3);
        uint64_t v27 = _swiftEmptyArrayStorage;
      }

      uint64_t v28 = v27[2];
      swift_release(v27);
      if (v28 == v31)
      {
        uint64_t v29 = (char *)swift_dynamicCastClass(v3, v24);
        if (!v29)
        {
          swift_bridgeObjectRelease(v3);
          uint64_t v29 = (char *)_swiftEmptyArrayStorage;
        }
      }

      else
      {
        swift_bridgeObjectRelease(v3);
        uint64_t v29 = sub_1000810C8(v3, v30, 8LL, (2 * v32) | 1);
      }

      swift_bridgeObjectRelease(v3);
      sub_10009E404(v29);
      return swift_release(v29);
    }
  }

  return result;
}

uint64_t IO80211Driver<>.received(keepAliveDatapathIdentifiers:)( uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v6 = *(void *)(result + 16);
  if (v6)
  {
    uint64_t v7 = result;
    unint64_t v38 = v6 - 8;
    unint64_t v39 = *(void *)(result + 16);
    if (v6 >= 8) {
      int64_t v8 = 8LL;
    }
    else {
      int64_t v8 = *(void *)(result + 16);
    }
    memset(v48, 0, 61);
    BYTE4(v48[0]) = v8;
    uint64_t v37 = result + 32;
    *(void *)unint64_t v43 = _swiftEmptyArrayStorage;
    swift_bridgeObjectRetain(result);
    sub_1000698B8(0, v8, 0);
    uint64_t v9 = 0LL;
    char v10 = _swiftEmptyArrayStorage;
    unint64_t v11 = _swiftEmptyArrayStorage[2];
    uint64_t v12 = 7 * v11;
    uint64_t v13 = 7 * v8;
    do
    {
      v5.i32[0] = *(_DWORD *)(v7 + v9 + 32);
      char v14 = *(_BYTE *)(v7 + v9 + 36);
      char v15 = *(_BYTE *)(v7 + v9 + 37);
      char v16 = *(_BYTE *)(v7 + v9 + 38);
      *(void *)unint64_t v43 = v10;
      unint64_t v17 = v10[3];
      unint64_t v18 = v11 + 1;
      if (v11 >= v17 >> 1)
      {
        sub_1000698B8(v17 > 1, v11 + 1, 1);
        char v10 = *(void **)v43;
      }

      v10[2] = v18;
      __int16 v19 = (char *)v10 + v12 + v9;
      *((_DWORD *)v19 + 8) = vmovn_s16((int16x8_t)vmovl_u8(v5)).u32[0];
      v19[36] = v14;
      v19[37] = v15;
      v19[38] = v16;
      v9 += 7LL;
      unint64_t v11 = v18;
    }

    while (v13 != v9);
    swift_bridgeObjectRelease(v7);
    uint64_t v20 = v10[2];
    if (v20)
    {
      uint64_t v21 = (char *)v10 + 38;
      uint64_t v22 = (_BYTE *)((unint64_t)v48 | 0xB);
      do
      {
        __int16 v23 = *((_WORD *)v21 - 1);
        char v24 = *v21;
        *(_DWORD *)(v22 - 6) = *(_DWORD *)(v21 - 6);
        *((_WORD *)v22 - 1) = v23;
        *uint64_t v22 = v24;
        v22 += 7;
        v21 += 7;
        --v20;
      }

      while (v20);
    }

    swift_bridgeObjectRelease(v10);
    *(_DWORD *)unint64_t v43 = v48[0];
    *(_OWORD *)&v43[4] = *(_OWORD *)((char *)v48 + 4);
    __int128 v44 = *(_OWORD *)((char *)&v48[1] + 4);
    __int128 v45 = *(_OWORD *)((char *)&v48[2] + 4);
    uint64_t v46 = *(void *)((char *)&v48[3] + 4);
    char v47 = BYTE12(v48[3]);
    type metadata accessor for apple80211_nan_keep_alive_dp_identifer(0LL);
    uint64_t v26 = v25;
    uint64_t v27 = *(void *)(a3 + 8);
    uint64_t v28 = *(void *)(a4 + 16);
    uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v27,  a2,  &protocol requirements base descriptor for DeviceDriver);
    uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a3,  a2,  AssociatedTypeWitness,  &protocol requirements base descriptor for IO80211Driver,  &associated conformance descriptor for IO80211Driver.DeviceDriver.Device: IO80211Device);
    double result = sub_1000A0728(367LL, (uint64_t)v43, a2, v26, v27, v28, AssociatedConformanceWitness);
    if (!v4 && v39 >= 9)
    {
      uint64_t v31 = type metadata accessor for __ContiguousArrayStorageBase(0LL);
      uint64_t v32 = swift_bridgeObjectRetain(v7);
      uint64_t v33 = swift_unknownObjectRetain_n(v32, 2LL);
      uint64_t v34 = (void *)swift_dynamicCastClass(v33, v31);
      if (!v34)
      {
        swift_bridgeObjectRelease(v7);
        uint64_t v34 = _swiftEmptyArrayStorage;
      }

      uint64_t v35 = v34[2];
      swift_release(v34);
      if (v35 == v38)
      {
        __int128 v36 = (char *)swift_dynamicCastClass(v7, v31);
        if (!v36)
        {
          swift_bridgeObjectRelease(v7);
          __int128 v36 = (char *)_swiftEmptyArrayStorage;
        }
      }

      else
      {
        swift_bridgeObjectRelease(v7);
        __int128 v36 = sub_1000810C8(v7, v37, 8LL, (2 * v39) | 1);
      }

      swift_bridgeObjectRelease(v7);
      (*(void (**)(char *, uint64_t, uint64_t))(a4 + 360))(v36, a2, a4);
      return swift_release(v36);
    }
  }

  return result;
}

void sub_10009EA78(uint64_t *a1@<X0>, char a2@<W1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t *a5@<X8>)
{
  uint64_t v10 = *a1;
  uint64_t v11 = swift_allocObject(v5, *(unsigned int *)(v5 + 48), *(unsigned __int16 *)(v5 + 52));
  AppleIO80211Driver.init(device:role:name:)(v10, a2, a3, a4);
  *a5 = v11;
}

uint64_t sub_10009EAE0@<X0>(void *a1@<X8>)
{
  uint64_t v2 = *(void *)(*(void *)v1 + 40LL);
  *a1 = v2;
  return swift_retain(v2);
}

uint64_t sub_10009EAF0@<X0>(uint64_t *a1@<X8>)
{
  uint64_t v3 = (void *)*v1;
  swift_beginAccess(v3 + 6, v8, 0LL, 0LL);
  uint64_t v4 = v3[6];
  uint64_t v5 = v3[7];
  uint64_t v6 = v3[8];
  *a1 = v4;
  a1[1] = v5;
  a1[2] = v6;
  return sub_1000A9C00(v4, v5, v6);
}

uint64_t sub_10009EB40(__int128 *a1)
{
  __int128 v8 = *a1;
  uint64_t v2 = *((void *)a1 + 2);
  uint64_t v3 = (void *)*v1;
  swift_beginAccess(v3 + 6, v9, 1LL, 0LL);
  uint64_t v4 = v3[6];
  uint64_t v5 = v3[7];
  uint64_t v6 = v3[8];
  *((_OWORD *)v3 + 3) = v8;
  v3[8] = v2;
  return sub_1000A9C2C(v4, v5, v6);
}

void *sub_10009EB9C(uint64_t a1)
{
  return &j_j__swift_endAccess;
}

void *sub_10009EBDC()
{
  return AppleIO80211Driver.capabilities.getter();
}

uint64_t sub_10009EBFC(uint64_t *a1)
{
  return sub_10009EC30( *a1,  (void *(*)(uint64_t *__return_ptr, void *))sub_100054614,  (void *(*)(uint64_t *__return_ptr, void *))sub_100054614);
}

uint64_t sub_10009EC30( uint64_t a1, void *(*a2)(uint64_t *__return_ptr, void *), void *(*a3)(uint64_t *__return_ptr, void *))
{
  if (*(_BYTE *)(a1 + 32) == 4)
  {
    memset(v26, 0, sizeof(v26));
    uint64_t v9 = *(void *)(a1 + 16);
    uint64_t v10 = *(void *)(a1 + 24);
    uint64_t KeyPath = swift_getKeyPath(&unk_10033EBC8);
    uint64_t v22 = v26;
    uint64_t v23 = __chkstk_darwin(KeyPath);
    uint64_t v24 = 16LL;
    swift_bridgeObjectRetain(v10);
    sub_10003B5A4(a2, (uint64_t)v21, v9, v10);
    swift_bridgeObjectRelease(v10);
    swift_release(KeyPath);
    v25[0] = v26[0];
    *(_OWORD *)&v25[1] = *(_OWORD *)&v26[1];
    uint64_t v12 = (char *)v26;
    uint64_t v13 = v3[5];
    uint64_t v14 = v3[2];
    uint64_t v15 = v3[3];
    swift_retain();
    swift_bridgeObjectRetain(v15);
    unint64_t v16 = 293LL;
  }

  else
  {
    if (!*(_BYTE *)(a1 + 32))
    {
      unint64_t v4 = sub_1000033FC();
      uint64_t v5 = swift_allocError(&type metadata for WiFiError, v4, 0LL, 0LL);
      *(_OWORD *)uint64_t v6 = xmmword_10033A970;
      *(_BYTE *)(v6 + 16) = 0;
      return swift_willThrow(v5);
    }

    memset(v26, 0, 20);
    uint64_t v18 = *(void *)(a1 + 16);
    uint64_t v19 = *(void *)(a1 + 24);
    uint64_t v20 = swift_getKeyPath(&unk_10033EBA8);
    uint64_t v22 = v26;
    uint64_t v23 = __chkstk_darwin(v20);
    uint64_t v24 = 16LL;
    swift_bridgeObjectRetain(v19);
    sub_10003B5A4(a3, (uint64_t)v21, v18, v19);
    swift_bridgeObjectRelease(v19);
    swift_release(v20);
    LODWORD(v25[0]) = v26[0];
    *(_OWORD *)((char *)v25 + 4) = *(_OWORD *)((char *)v26 + 4);
    uint64_t v12 = (char *)&v25[2] + 4;
    uint64_t v13 = v3[5];
    uint64_t v14 = v3[2];
    uint64_t v15 = v3[3];
    swift_retain();
    swift_bridgeObjectRetain(v15);
    unint64_t v16 = 95LL;
  }

  AppleDevice.setRequest(requestType:data:on:)(v16, (uint64_t)v25, (uint64_t)v12, 0, v14, v15);
  swift_bridgeObjectRelease(v15);
  return swift_release(v13);
}

uint64_t DeviceDriver<>.destroyInterface(_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v6 = v5;
  int v11 = (*(unsigned __int8 (**)(uint64_t, uint64_t))(a4 + 32))(a2, a4);
  if (v11 == 4)
  {
    memset(v33, 0, sizeof(v33));
    uint64_t v16 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 40))(a2, a4);
    uint64_t v18 = v17;
    uint64_t KeyPath = swift_getKeyPath(&unk_10033EBC8);
    uint64_t v34 = v6;
    uint64_t v29 = v33;
    uint64_t v30 = __chkstk_darwin(KeyPath);
    uint64_t v31 = 16LL;
    sub_10003B5A4((void *(*)(uint64_t *__return_ptr, void *))sub_100054614, (uint64_t)v28, v16, v18);
    swift_bridgeObjectRelease(v18);
    swift_release(KeyPath);
    v32[0] = v33[0];
    *(_OWORD *)&v32[1] = *(_OWORD *)&v33[1];
    type metadata accessor for apple80211_companion_skywalk_if_create(0LL);
    uint64_t v21 = v20;
    uint64_t v22 = 293LL;
  }

  else
  {
    if (!v11)
    {
      unint64_t v12 = sub_1000033FC();
      uint64_t v13 = swift_allocError(&type metadata for WiFiError, v12, 0LL, 0LL);
      *(_OWORD *)uint64_t v14 = xmmword_10033A970;
      *(_BYTE *)(v14 + 16) = 0;
      return swift_willThrow(v13);
    }

    memset(v33, 0, 20);
    uint64_t v23 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 40))(a2, a4);
    uint64_t v25 = v24;
    uint64_t v26 = swift_getKeyPath(&unk_10033EBA8);
    uint64_t v34 = v6;
    uint64_t v29 = v33;
    uint64_t v30 = __chkstk_darwin(v26);
    uint64_t v31 = 16LL;
    sub_10003B5A4((void *(*)(uint64_t *__return_ptr, void *))sub_100054614, (uint64_t)v28, v23, v25);
    swift_bridgeObjectRelease(v25);
    swift_release(v26);
    LODWORD(v32[0]) = v33[0];
    *(_OWORD *)((char *)v32 + 4) = *(_OWORD *)((char *)v33 + 4);
    type metadata accessor for apple80211_virt_if_delete_data(0LL);
    uint64_t v21 = v27;
    uint64_t v22 = 95LL;
  }

  return sub_1000A0728(v22, (uint64_t)v32, a2, v21, a3, a4, a5);
}

uint64_t sub_10009F0EC()
{
  return *(unsigned __int8 *)(*(void *)v0 + 32LL);
}

uint64_t sub_10009F0F8()
{
  uint64_t v1 = *(void *)(*(void *)v0 + 16LL);
  swift_bridgeObjectRetain(*(void *)(*(void *)v0 + 24LL));
  return v1;
}

uint64_t sub_10009F128(uint64_t a1, uint64_t a2)
{
  return sub_1000A5A20(a1, a2, (uint64_t (*)(_BYTE *, _BYTE *, _BYTE *))sub_1000ABCAC);
}

uint64_t DeviceDriver<>.supportedChannels.getter(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return v10;
}

uint64_t sub_10009F290(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_1000AB298(a1 & 0xFFFFFFFFFFFFLL, a2, a3);
}

uint64_t IO80211Driver<>.postPeerPresence(macAddress:ipv6Address:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v32 = a5;
  uint64_t v29 = a3;
  uint64_t v30 = a4;
  v27[2] = a8;
  uint64_t v28 = a2;
  uint64_t v13 = *(void *)(a8 + 8);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v13,  a6,  &protocol requirements base descriptor for DeviceDriver);
  uint64_t v31 = *(void *)(AssociatedTypeWitness - 8);
  __chkstk_darwin(AssociatedTypeWitness);
  uint64_t v16 = (char *)v27 - v15;
  (*(void (**)(uint64_t, uint64_t))(v13 + 56))(a6, v13);
  uint64_t v17 = *(void *)(a7 + 8);
  uint64_t v18 = *(uint64_t (**)(uint64_t, uint64_t))(v17 + 40);
  v27[0] = v9;
  uint64_t v19 = v18(a6, v17);
  uint64_t v21 = v20;
  uint64_t v22 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(a9 + 24);
  v27[1] = a1;
  uint64_t v23 = v33;
  v22(a1 & 0xFFFFFFFFFFFFLL, v28, v29, v30, v32, v19, v20, 1LL, AssociatedTypeWitness, a9);
  if (!v23)
  {
    (*(void (**)(char *, uint64_t))(v31 + 8))(v16, AssociatedTypeWitness);
    swift_bridgeObjectRelease(v21);
    uint64_t v25 = *(unsigned __int8 (**)(uint64_t, uint64_t))(v17 + 32);
    uint64_t v33 = v17;
    uint64_t v26 = (char *)&loc_10009F45C + 4 * byte_10033E86E[v25(a6, v17)];
    __asm { BR              X10 }
  }

  (*(void (**)(char *, uint64_t))(v31 + 8))(v16, AssociatedTypeWitness);
  return swift_bridgeObjectRelease(v21);
}

uint64_t sub_10009F598(uint64_t a1, uint64_t a2)
{
  return sub_10009F5C0(a1, a2, (uint64_t (*)(void *))sub_1000ABCD4);
}

uint64_t sub_10009F5C0(uint64_t a1, uint64_t a2, uint64_t (*a3)(void *))
{
  v5[4] = 0x3D67736D2D2069LL;
  void v5[5] = 0xE700000000000000LL;
  String.append(_:)(*(Swift::String *)&a1);
  v5[2] = &v6;
  sub_10003B82C(a3, (uint64_t)v5, 0x3D67736D2D2069LL, 0xE700000000000000LL, &v6);
  return swift_bridgeObjectRelease(0xE700000000000000LL);
}

uint64_t DeviceDriver<>.triggerCoreCapture(reason:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v15 = 0x3D67736D2D2069LL;
  unint64_t v16 = 0xE700000000000000LL;
  String.append(_:)(*(Swift::String *)&a1);
  v13[2] = a3;
  void v13[3] = a4;
  v13[4] = a5;
  v13[5] = a6;
  uint64_t v14 = v6;
  sub_10003B82C( (uint64_t (*)(void *))sub_1000AAE74,  (uint64_t)v13,  0x3D67736D2D2069LL,  0xE700000000000000LL,  v11);
  return swift_bridgeObjectRelease(0xE700000000000000LL);
}

void *sub_10009F6EC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return sub_1000A5B3C(a1, a2, a3, a4, (uint64_t (*)(void *))sub_1000ABCC0);
}

void *DeviceDriver<>.triggerWiFiChipReset(reason:)( uint64_t a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  v7[2] = a3;
  _OWORD v7[3] = a4;
  v7[4] = a5;
  v7[5] = a6;
  return sub_10003B82C((uint64_t (*)(void *))sub_1000AAE94, (uint64_t)v7, a1, (uint64_t)a2, a2);
}

uint64_t sub_10009F74C@<X0>(uint64_t a1@<X8>)
{
  uint64_t v3 = *v1 + OBJC_IVAR____TtC7CoreP2P18AppleIO80211Driver_logger;
  uint64_t v4 = type metadata accessor for Logger(0LL);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v4 - 8) + 16LL))(a1, v3, v4);
}

void AppleIO80211Driver.description.getter()
{
  __asm { BR              X10 }

uint64_t sub_10009F828()
{
  v1._countAndFlagsBits = 1279547201LL;
  v1._object = (void *)0xE400000000000000LL;
  String.append(_:)(v1);
  swift_bridgeObjectRelease(0xE400000000000000LL);
  v2._countAndFlagsBits = 8250LL;
  v2._object = (void *)0xE200000000000000LL;
  String.append(_:)(v2);
  uint64_t v4 = *(void *)(v0 + 16);
  uint64_t v3 = *(void **)(v0 + 24);
  swift_bridgeObjectRetain(v3);
  v5._countAndFlagsBits = v4;
  v5._object = v3;
  String.append(_:)(v5);
  swift_bridgeObjectRelease(v3);
  v6._countAndFlagsBits = 93LL;
  v6._object = (void *)0xE100000000000000LL;
  String.append(_:)(v6);
  return v8;
}

void sub_10009F8EC()
{
}

uint64_t sub_10009F90C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v20 = a2;
  uint64_t v21 = a3;
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  a5,  a4,  &protocol requirements base descriptor for DeviceDriver,  &associated type descriptor for DeviceDriver.Device);
  uint64_t v13 = *(void *)(AssociatedTypeWitness - 8);
  __chkstk_darwin(AssociatedTypeWitness);
  uint64_t v15 = (char *)&v20 - v14;
  (*(void (**)(uint64_t, uint64_t))(a5 + 56))(a4, a5);
  uint64_t v16 = (*(uint64_t (**)(uint64_t, uint64_t))(a6 + 40))(a4, a6);
  uint64_t v18 = v17;
  (*(void (**)(uint64_t, uint64_t, uint64_t, void, uint64_t, uint64_t, uint64_t, uint64_t))(a7 + 24))( a1,  v20,  v21,  0LL,  v16,  v17,  AssociatedTypeWitness,  a7);
  (*(void (**)(char *, uint64_t))(v13 + 8))(v15, AssociatedTypeWitness);
  return swift_bridgeObjectRelease(v18);
}

uint64_t sub_10009FA28(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v20 = a2;
  uint64_t v21 = a3;
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  a5,  a4,  &protocol requirements base descriptor for DeviceDriver,  &associated type descriptor for DeviceDriver.Device);
  uint64_t v13 = *(void *)(AssociatedTypeWitness - 8);
  __chkstk_darwin(AssociatedTypeWitness);
  uint64_t v15 = (char *)&v20 - v14;
  (*(void (**)(uint64_t, uint64_t))(a5 + 56))(a4, a5);
  uint64_t v16 = (*(uint64_t (**)(uint64_t, uint64_t))(a6 + 40))(a4, a6);
  uint64_t v18 = v17;
  (*(void (**)(uint64_t, uint64_t, uint64_t, void, uint64_t, uint64_t, uint64_t, uint64_t))(a7 + 32))( a1,  v20,  v21,  0LL,  v16,  v17,  AssociatedTypeWitness,  a7);
  (*(void (**)(char *, uint64_t))(v13 + 8))(v15, AssociatedTypeWitness);
  return swift_bridgeObjectRelease(v18);
}

uint64_t sub_10009FB44(unint64_t a1)
{
  uint64_t v3 = v2;
  uint64_t v5 = swift_slowAlloc(12LL, -1LL);
  *(void *)uint64_t v5 = 0LL;
  *(_DWORD *)(v5 + 8) = 0;
  uint64_t v6 = v1[5];
  uint64_t v7 = v1[2];
  uint64_t v8 = v1[3];
  swift_retain();
  swift_bridgeObjectRetain(v8);
  AppleDevice.getRequest(requestType:data:on:)(a1, v5, v5 + 12, 0, v7, v8);
  swift_bridgeObjectRelease(v8);
  swift_release(v6);
  if (!v2) {
    uint64_t v3 = *(void *)v5;
  }
  swift_slowDealloc(v5, -1LL, -1LL);
  return v3;
}

uint64_t sub_10009FC24(unint64_t a1)
{
  uint64_t v3 = v2;
  uint64_t v5 = (uint64_t *)swift_slowAlloc(24LL, -1LL);
  v5[1] = 0LL;
  v5[2] = 0LL;
  uint64_t *v5 = 0LL;
  uint64_t v6 = v1[5];
  uint64_t v7 = v1[2];
  uint64_t v8 = v1[3];
  swift_retain();
  swift_bridgeObjectRetain(v8);
  AppleDevice.getRequest(requestType:data:on:)(a1, (uint64_t)v5, (uint64_t)(v5 + 3), 0, v7, v8);
  swift_bridgeObjectRelease(v8);
  swift_release(v6);
  if (!v2) {
    uint64_t v3 = *v5;
  }
  swift_slowDealloc(v5, -1LL, -1LL);
  return v3;
}

uint64_t sub_10009FD0C(unint64_t a1)
{
  uint64_t v3 = v2;
  uint64_t v5 = swift_slowAlloc(12LL, -1LL);
  *(void *)uint64_t v5 = 0LL;
  *(_DWORD *)(v5 + 8) = 0;
  uint64_t v6 = v1[5];
  uint64_t v7 = v1[2];
  uint64_t v8 = v1[3];
  swift_retain();
  swift_bridgeObjectRetain(v8);
  AppleDevice.getRequest(requestType:data:on:)(a1, v5, v5 + 12, 0, v7, v8);
  swift_bridgeObjectRelease(v8);
  swift_release(v6);
  if (!v2) {
    uint64_t v3 = *(void *)v5;
  }
  swift_slowDealloc(v5, -1LL, -1LL);
  return v3;
}

uint64_t sub_10009FDEC@<X0>(unint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t v6 = (_OWORD *)swift_slowAlloc(400LL, -1LL);
  *uint64_t v6 = 0u;
  v6[1] = 0u;
  _BYTE v6[2] = 0u;
  v6[3] = 0u;
  v6[4] = 0u;
  v6[5] = 0u;
  v6[6] = 0u;
  v6[7] = 0u;
  v6[8] = 0u;
  void v6[9] = 0u;
  v6[10] = 0u;
  v6[11] = 0u;
  v6[12] = 0u;
  v6[13] = 0u;
  v6[14] = 0u;
  v6[15] = 0u;
  v6[16] = 0u;
  v6[17] = 0u;
  v6[18] = 0u;
  v6[19] = 0u;
  v6[20] = 0u;
  v6[21] = 0u;
  v6[22] = 0u;
  _BYTE v6[23] = 0u;
  v6[24] = 0u;
  uint64_t v7 = v2[5];
  uint64_t v8 = v2[2];
  uint64_t v9 = v2[3];
  swift_retain();
  swift_bridgeObjectRetain(v9);
  AppleDevice.getRequest(requestType:data:on:)(a1, (uint64_t)v6, (uint64_t)(v6 + 25), 0, v8, v9);
  swift_bridgeObjectRelease(v9);
  swift_release(v7);
  if (!v3) {
    memcpy(a2, v6, 0x190uLL);
  }
  return swift_slowDealloc(v6, -1LL, -1LL);
}

uint64_t sub_10009FEEC(unint64_t a1)
{
  uint64_t v3 = v2;
  uint64_t v5 = (uint64_t *)swift_slowAlloc(8LL, -1LL);
  uint64_t *v5 = 0LL;
  uint64_t v6 = v1[5];
  uint64_t v7 = v1[2];
  uint64_t v8 = v1[3];
  swift_retain();
  swift_bridgeObjectRetain(v8);
  AppleDevice.getRequest(requestType:data:on:)(a1, (uint64_t)v5, (uint64_t)(v5 + 1), 0, v7, v8);
  swift_bridgeObjectRelease(v8);
  swift_release(v6);
  if (!v2) {
    uint64_t v3 = *v5;
  }
  swift_slowDealloc(v5, -1LL, -1LL);
  return v3;
}

uint64_t sub_10009FFAC@<X0>(unint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t v4 = v3;
  uint64_t v7 = (void *)swift_slowAlloc(3712LL, -1LL);
  bzero(v7, 0xE80uLL);
  uint64_t v8 = v2[5];
  uint64_t v9 = v2[2];
  uint64_t v10 = v2[3];
  swift_retain();
  swift_bridgeObjectRetain(v10);
  AppleDevice.getRequest(requestType:data:on:)(a1, (uint64_t)v7, (uint64_t)v7 + 3712, 0, v9, v10);
  swift_bridgeObjectRelease(v10);
  swift_release(v8);
  if (!v4) {
    memcpy(a2, v7, 0xE80uLL);
  }
  return swift_slowDealloc(v7, -1LL, -1LL);
}

uint64_t sub_1000A007C@<X0>(unint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t v4 = v3;
  uint64_t v7 = (void *)swift_slowAlloc(4016LL, -1LL);
  bzero(v7, 0xFB0uLL);
  uint64_t v8 = v2[5];
  uint64_t v9 = v2[2];
  uint64_t v10 = v2[3];
  swift_retain();
  swift_bridgeObjectRetain(v10);
  AppleDevice.getRequest(requestType:data:on:)(a1, (uint64_t)v7, (uint64_t)v7 + 4016, 0, v9, v10);
  swift_bridgeObjectRelease(v10);
  swift_release(v8);
  if (!v4) {
    memcpy(a2, v7, 0xFB0uLL);
  }
  return swift_slowDealloc(v7, -1LL, -1LL);
}

uint64_t sub_1000A014C@<X0>(unint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v6 = swift_slowAlloc(12LL, -1LL);
  *(void *)uint64_t v6 = 0LL;
  *(_DWORD *)(v6 + 8) = 0;
  uint64_t v7 = v2[5];
  uint64_t v8 = v2[2];
  uint64_t v9 = v2[3];
  swift_retain();
  swift_bridgeObjectRetain(v9);
  AppleDevice.getRequest(requestType:data:on:)(a1, v6, v6 + 12, 0, v8, v9);
  swift_bridgeObjectRelease(v9);
  swift_release(v7);
  if (!v3)
  {
    *(void *)a2 = *(void *)v6;
    *(_DWORD *)(a2 + 8) = *(_DWORD *)(v6 + 8);
  }

  return swift_slowDealloc(v6, -1LL, -1LL);
}

uint64_t sub_1000A021C(unint64_t a1)
{
  uint64_t v3 = v2;
  uint64_t v5 = (_WORD *)swift_slowAlloc(2LL, -1LL);
  _WORD *v5 = 0;
  uint64_t v6 = v1[5];
  uint64_t v7 = v1[2];
  uint64_t v8 = v1[3];
  swift_retain();
  swift_bridgeObjectRetain(v8);
  AppleDevice.getRequest(requestType:data:on:)(a1, (uint64_t)v5, (uint64_t)(v5 + 1), 0, v7, v8);
  swift_bridgeObjectRelease(v8);
  swift_release(v6);
  if (!v2) {
    uint64_t v3 = (unsigned __int16)*v5;
  }
  swift_slowDealloc(v5, -1LL, -1LL);
  return v3;
}

uint64_t sub_1000A02F0(unint64_t a1)
{
  uint64_t v3 = v2;
  uint64_t v5 = (_BYTE *)swift_slowAlloc(1LL, -1LL);
  _BYTE *v5 = 0;
  uint64_t v6 = v1[5];
  uint64_t v7 = v1[2];
  uint64_t v8 = v1[3];
  swift_retain();
  swift_bridgeObjectRetain(v8);
  AppleDevice.getRequest(requestType:data:on:)(a1, (uint64_t)v5, (uint64_t)(v5 + 1), 0, v7, v8);
  swift_bridgeObjectRelease(v8);
  swift_release(v6);
  if (!v2) {
    uint64_t v3 = *v5;
  }
  swift_slowDealloc(v5, -1LL, -1LL);
  return v3;
}

uint64_t sub_1000A03B0(unint64_t a1)
{
  uint64_t v4 = (unsigned __int16 *)swift_slowAlloc(3LL, -1LL);
  unsigned __int16 *v4 = 0;
  *((_BYTE *)v4 + 2) = 0;
  uint64_t v5 = v1[5];
  uint64_t v6 = v1[2];
  uint64_t v7 = v1[3];
  swift_retain();
  swift_bridgeObjectRetain(v7);
  AppleDevice.getRequest(requestType:data:on:)(a1, (uint64_t)v4, (uint64_t)v4 + 3, 0, v6, v7);
  swift_bridgeObjectRelease(v7);
  swift_release(v5);
  if (v2) {
    return swift_slowDealloc(v4, -1LL, -1LL);
  }
  int v9 = *((unsigned __int8 *)v4 + 2);
  int v10 = *v4;
  swift_slowDealloc(v4, -1LL, -1LL);
  return v10 | (v9 << 16);
}

uint64_t sub_1000A048C(unint64_t a1)
{
  uint64_t v3 = v2;
  uint64_t v5 = (void *)swift_slowAlloc(16LL, -1LL);
  void *v5 = 0LL;
  v5[1] = 0LL;
  uint64_t v6 = v1[5];
  uint64_t v7 = v1[2];
  uint64_t v8 = v1[3];
  swift_retain();
  swift_bridgeObjectRetain(v8);
  AppleDevice.getRequest(requestType:data:on:)(a1, (uint64_t)v5, (uint64_t)(v5 + 2), 0, v7, v8);
  swift_bridgeObjectRelease(v8);
  swift_release(v6);
  if (!v2) {
    uint64_t v3 = *(unsigned int *)v5;
  }
  swift_slowDealloc(v5, -1LL, -1LL);
  return v3;
}

uint64_t sub_1000A0568@<X0>(unint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t v4 = v3;
  uint64_t v7 = (void *)swift_slowAlloc(10016LL, -1LL);
  bzero(v7, 0x2720uLL);
  uint64_t v8 = v2[5];
  uint64_t v9 = v2[2];
  uint64_t v10 = v2[3];
  swift_retain();
  swift_bridgeObjectRetain(v10);
  AppleDevice.getRequest(requestType:data:on:)(a1, (uint64_t)v7, (uint64_t)v7 + 10016, 0, v9, v10);
  swift_bridgeObjectRelease(v10);
  swift_release(v8);
  if (!v4) {
    memcpy(a2, v7, 0x2720uLL);
  }
  return swift_slowDealloc(v7, -1LL, -1LL);
}

uint64_t sub_1000A063C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v12 = *(void *)(a4 - 8);
  unsigned int v13 = *(unsigned __int8 *)(v12 + 80);
  if (v13 > 0xF) {
    uint64_t v14 = v13 + 1;
  }
  else {
    uint64_t v14 = 0LL;
  }
  size_t v15 = *(void *)(v12 + 64);
  uint64_t v16 = (void *)swift_slowAlloc(v15, v14 - 1);
  uint64_t v17 = (uint64_t)v16;
  uint64_t v18 = (uint64_t)v16 + v15;
  if (v15) {
    bzero(v16, v15);
  }
  sub_10009F90C(a1, v17, v18, a3, a5, a6, a7);
  if (!v22) {
    UnsafeMutableRawBufferPointer.load<A>(fromByteOffset:as:)(0LL, a2, v17, v18, a4);
  }
  return swift_slowDealloc(v17, -1LL, -1LL);
}

uint64_t sub_1000A0728(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v14 = *(void *)(a4 - 8);
  __chkstk_darwin(a1);
  uint64_t v16 = (char *)&v19 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  (*(void (**)(char *))(v14 + 16))(v16);
  uint64_t v22 = a3;
  uint64_t v23 = a4;
  uint64_t v24 = a5;
  uint64_t v25 = a6;
  uint64_t v26 = a7;
  uint64_t v27 = v7;
  uint64_t v28 = a1;
  uint64_t v17 = sub_100002274((uint64_t *)&unk_10040C5B0);
  sub_10016D190( (uint64_t)v16,  (uint64_t)sub_1000ABC20,  (uint64_t)v21,  a4,  v17,  (uint64_t)(&type metadata for () + 1),  (uint64_t)&protocol self-conformance witness table for Error,  (uint64_t)&v20);
  return (*(uint64_t (**)(char *, uint64_t))(v14 + 8))(v16, a4);
}

unint64_t CountryCode.apple80211Value.getter(__int16 a1)
{
  return ((unint64_t)a1 << 32) | ((unint64_t)HIBYTE(a1) << 40);
}

uint64_t sub_1000A086C@<X0>(uint64_t result@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  int v3 = *(unsigned __int16 *)(a2 + 12);
  if (*(_WORD *)(a2 + 12))
  {
    uint64_t v4 = result;
    int v5 = 0;
    uint64_t v6 = _swiftEmptyArrayStorage;
    do
    {
      unsigned __int16 v14 = v5;
      double result = sub_1000A09C4(&v14, v4, (uint64_t)&v12);
      unint64_t v8 = v12 | ((unint64_t)v13 << 32);
      if ((v8 & 0xFF00000000LL) != 0x300000000LL)
      {
        double result = swift_isUniquelyReferenced_nonNull_native(v6);
        if ((result & 1) == 0)
        {
          double result = (uint64_t)sub_1000A65E8(0LL, v6[2] + 1LL, 1, v6);
          uint64_t v6 = (void *)result;
        }

        unint64_t v10 = v6[2];
        unint64_t v9 = v6[3];
        if (v10 >= v9 >> 1)
        {
          double result = (uint64_t)sub_1000A65E8((void *)(v9 > 1), v10 + 1, 1, v6);
          uint64_t v6 = (void *)result;
        }

        _BYTE v6[2] = v10 + 1;
        uint64_t v7 = &v6[v10];
        *((_DWORD *)v7 + 8) = v8;
        *((_BYTE *)v7 + 36) = BYTE4(v8);
        *((_BYTE *)v7 + 37) = BYTE5(v8);
      }

      ++v5;
    }

    while (v5 != v3);
  }

  else
  {
    uint64_t v6 = _swiftEmptyArrayStorage;
  }

  *a3 = v6;
  return result;
}

unint64_t sub_1000A09C4@<X0>(unsigned __int16 *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v5 = *a1;
  uint64_t KeyPath = swift_getKeyPath(&unk_10033EE58);
  unint64_t result = dispatch thunk of AnyKeyPath._storedInlineOffset.getter(KeyPath);
  if ((v8 & 1) != 0)
  {
    __break(1u);
    goto LABEL_13;
  }

  uint64_t v9 = *(&type metadata for UInt8 - 1);
  uint64_t v10 = *(void *)(v9 + 72) * v5;
  int v11 = *(void (**)(unsigned __int8 *, unint64_t))(v9 + 16);
  v11(&v26, a2 + result + v10);
  swift_release(KeyPath);
  unsigned int v12 = v26;
  uint64_t v13 = swift_getKeyPath(&unk_10033EE78);
  unint64_t result = dispatch thunk of AnyKeyPath._storedInlineOffset.getter(v13);
  if ((v14 & 1) != 0)
  {
LABEL_13:
    __break(1u);
    goto LABEL_14;
  }

  ((void (*)(unsigned __int8 *, unint64_t, void *))v11)( &v25,  a2 + result + v10,  &type metadata for UInt8);
  swift_release(v13);
  int v15 = v25;
  uint64_t v16 = swift_getKeyPath(&unk_10033EE98);
  unint64_t result = dispatch thunk of AnyKeyPath._storedInlineOffset.getter(v16);
  if ((v17 & 1) != 0)
  {
LABEL_14:
    __break(1u);
    goto LABEL_15;
  }

  ((void (*)(unsigned __int8 *, unint64_t, void *))v11)( &v24,  a2 + result + v10,  &type metadata for UInt8);
  swift_release(v16);
  int v18 = v24;
  uint64_t v19 = swift_getKeyPath(&unk_10033EEB8);
  unint64_t result = dispatch thunk of AnyKeyPath._storedInlineOffset.getter(v19);
  if ((v20 & 1) != 0)
  {
LABEL_15:
    __break(1u);
    return result;
  }

  if (v18) {
    int v21 = ((v15 != 0) << 8) | 4;
  }
  else {
    int v21 = (v15 != 0) << 8;
  }
  ((void (*)(char *, unint64_t, void *))v11)(&v23, a2 + result + v10, &type metadata for UInt8);
  swift_release(v19);
  if (v23) {
    unsigned int v22 = v21 | 0x400;
  }
  else {
    unsigned int v22 = v21;
  }
  unint64_t result = sub_1000A810C(v12, v22);
  *(_DWORD *)a3 = result;
  *(_WORD *)(a3 + 4) = WORD2(result);
  return result;
}

void sub_1000A0B5C(uint64_t a1, void *a2)
{
  uint64_t v8 = 0LL;
  int v3 = sub_100333A78(a1, &v8);
  uint64_t v4 = (uint64_t)v3 + v8;
  uint64_t v5 = a2[5];
  uint64_t v6 = a2[2];
  uint64_t v7 = a2[3];
  swift_retain();
  swift_bridgeObjectRetain(v7);
  AppleDevice.setRequest(requestType:data:on:)(0x9DuLL, (uint64_t)v3, v4, 0, v6, v7);
  swift_bridgeObjectRelease(v7);
  swift_release(v5);
  free(v3);
}

void sub_1000A0C34(uint64_t a1, void *a2)
{
  uint64_t v8 = 0LL;
  int v3 = sub_100333B58(a1, &v8);
  uint64_t v4 = (uint64_t)&v3[v8];
  uint64_t v5 = a2[5];
  uint64_t v6 = a2[2];
  uint64_t v7 = a2[3];
  swift_retain();
  swift_bridgeObjectRetain(v7);
  AppleDevice.setRequest(requestType:data:on:)(0xEFuLL, (uint64_t)v3, v4, 0, v6, v7);
  swift_bridgeObjectRelease(v7);
  swift_release(v5);
  free(v3);
}

void sub_1000A0D0C( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t (*a7)(uint64_t, uint64_t *), uint64_t a8)
{
  uint64_t v14 = 0LL;
  uint64_t v13 = (void *)a7(a1, &v14);
  sub_10009FA28(a8, (uint64_t)v13, (uint64_t)v13 + v14, a3, a4, a5, a6);
  free(v13);
}

uint64_t sub_1000A0DD8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  if ((v41 & 1) != 0)
  {
    int v13 = 0;
    char v14 = 0;
    char v15 = 0;
    uint64_t v17 = v40[0];
    uint64_t v16 = v40[1];
    char v18 = 28;
    char v19 = 30;
  }

  else
  {
    uint64_t v17 = 0LL;
    uint64_t v16 = 0LL;
    char v19 = 0;
    char v18 = 0;
    char v15 = 16;
    int v13 = v40[0];
    char v14 = 2;
  }

  int v22 = 1;
  __int16 v23 = a1;
  char v24 = BYTE2(a1);
  char v25 = BYTE3(a1);
  char v26 = BYTE4(a1);
  char v27 = BYTE5(a1);
  char v28 = v15;
  char v29 = v14;
  __int16 v30 = 0;
  int v31 = v13;
  uint64_t v32 = 0LL;
  char v33 = v18;
  char v34 = v19;
  __int16 v35 = 0;
  int v36 = 0;
  uint64_t v37 = v17;
  uint64_t v38 = v16;
  int v39 = 0;
  type metadata accessor for apple80211_infra_peer_address_data(0LL);
  return sub_1000A0728(a3, (uint64_t)&v22, a4, v20, a5, *(void *)(a6 + 16), a7);
}

uint64_t sub_1000A0F14@<X0>( uint64_t *a1@<X0>, void *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X5>, uint64_t a6@<X7>, uint64_t a7@<X8>, uint64_t a8)
{
  v31[7] = a6;
  uint64_t v37 = a3;
  uint64_t v33 = a8;
  char v34 = a2;
  uint64_t v11 = *a1;
  uint64_t v12 = *a2;
  uint64_t v13 = type metadata accessor for Optional(0LL, a5);
  v31[4] = *(void *)(v13 - 8);
  v31[5] = v13;
  uint64_t v14 = __chkstk_darwin(v13);
  uint64_t v16 = (char *)v31 - v15;
  v31[6] = *(void *)(a5 - 8);
  uint64_t v17 = __chkstk_darwin(v14);
  void v31[3] = (char *)v31 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v32 = *(void *)(class metadata base offset for KeyPath + v12 + 8);
  v31[10] = *(void *)(v32 - 8);
  uint64_t v19 = __chkstk_darwin(v17);
  v31[9] = (char *)v31 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  __chkstk_darwin(v19);
  v31[8] = (char *)v31 - v21;
  uint64_t v23 = *(void *)(v11 + v22);
  uint64_t v24 = type metadata accessor for Optional(0LL, v23);
  uint64_t v25 = __chkstk_darwin(v24);
  uint64_t v36 = *(void *)(v23 - 8);
  uint64_t v26 = __chkstk_darwin(v25);
  __int16 v35 = (char *)v31 - v27;
  dispatch thunk of AnyKeyPath._storedInlineOffset.getter(v26);
  if ((v28 & 1) == 0)
  {
    _OWORD v31[2] = v16;
    __asm { BR              X10 }
  }

  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0LL, v23, a5, 0LL, 0LL);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(TupleTypeMetadata2 - 8) + 56LL))( a7,  1LL,  1LL,  TupleTypeMetadata2);
}

void sub_1000A132C(uint64_t a1)
{
  *(void *)(v6 - 112) = a1;
  *(void *)(v6 - 104) = BYTE6(v5);
  unint64_t v7 = sub_100024970();
  uint64_t v8 = *(void **)(v6 - 176);
  uint64_t v9 = *(void *)(v6 - 152);
  uint64_t v10 = *(void *)(v6 - 144);
  dispatch thunk of BinaryInteger.init<A>(_:)(v6 - 104, &type metadata for Int, v7, v9, v10);
  uint64_t v11 = *(void **)(v6 - 168);
  swift_getAtKeyPath(v11, v1, *(void *)(v6 - 136));
  char v12 = dispatch thunk of static Equatable.== infix(_:_:)(v8, v11, v9, *(void *)(*(void *)(v10 + 16) + 8LL));
  uint64_t v13 = v1;
  uint64_t v14 = *(void (**)(void *, uint64_t))(*(void *)(v6 - 160) + 8LL);
  v14(v11, v9);
  v14(v8, v9);
  if ((v12 & 1) != 0)
  {
    type metadata accessor for BinaryDecoder();
    uint64_t v15 = *(void *)(v6 - 224);
    uint64_t v16 = *(void *)(v6 - 112);
    static BinaryDecoder.decode<A>(_:data:)(v3, v16, v5);
    if (v2)
    {
      swift_errorRelease(v2);
      sub_1000208D8(v16, v5);
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(v6 - 192) + 56LL))(v15, 1LL, 1LL, v3);
      (*(void (**)(void, uint64_t))(*(void *)(v6 - 120) + 8LL))(*(void *)(v6 - 128), v4);
      JUMPOUT(0x1000A145CLL);
    }

    sub_1000208D8(v16, v5);
    uint64_t v17 = *(void *)(v6 - 192);
    (*(void (**)(uint64_t, void, uint64_t, uint64_t))(v17 + 56))(v15, 0LL, 1LL, v3);
    uint64_t v18 = *(void (**)(uint64_t, uint64_t, uint64_t))(v17 + 32);
    uint64_t v19 = *(void *)(v6 - 216);
    v18(v19, v15, v3);
    uint64_t v20 = *(void *)(v6 - 232) + *(int *)(swift_getTupleTypeMetadata2(0LL, v4, v3, 0LL, 0LL) + 48);
    (*(void (**)(void, void, uint64_t))(v6 - 240))(*(void *)(v6 - 232), *(void *)(v6 - 128), v4);
    v18(v20, v19, v3);
    JUMPOUT(0x1000A1490LL);
  }

  (*(void (**)(uint64_t, uint64_t))(*(void *)(v6 - 120) + 8LL))(v13, v4);
  sub_1000208D8(*(void *)(v6 - 112), v5);
  JUMPOUT(0x1000A1460LL);
}

uint64_t sub_1000A15CC(uint64_t a1, uint64_t a2, unint64_t a3)
{
  return ((uint64_t (*)(uint64_t, void, uint64_t, unint64_t))((char *)&loc_1000A15E4
                                                                             + dword_1000A162C[a3 >> 62]))( a1,  0LL,  a2,  a3);
}

uint64_t sub_1000A15F8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (BYTE6(a4) < a1)
  {
    __break(1u);
    JUMPOUT(0x1000A162CLL);
  }

  return Data._Representation.subscript.getter();
}

void sub_1000A163C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  __asm { BR              X11 }

uint64_t sub_1000A167C@<X0>(uint64_t a1@<X0>, uint64_t a2@<X2>, uint64_t a3@<X8>)
{
  if (a3 == BYTE6(a2))
  {
    Data.load<A>(as:)(a1);
    uint64_t v6 = 0LL;
  }

  else
  {
    uint64_t v6 = 1LL;
  }

  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v5 + 56))(v4, v6, 1LL, v3);
}

unint64_t sub_1000A171C(unsigned __int16 a1, uint64_t a2)
{
  if (BYTE6(a2) == 24) {
    _s7CoreP2P21NANActionFrameSubtypeO8rawValueACSgs5UInt8V_tcfC_0(HIBYTE(a2));
  }
  return a1 | (unint64_t)(a2 << 16);
}

  ;
}

unint64_t sub_1000A17D4(unsigned __int16 a1, unint64_t a2, unsigned int a3)
{
  return a1 | (HIDWORD(a2) << 16) | ((unint64_t)a3 << 48) | ((unint64_t)(a3 >> 8) << 56);
}

uint64_t sub_1000A1804(unint64_t a1, __int16 a2)
{
  LOWORD(v6) = HIWORD(a1);
  HIWORD(v6) = a2;
  unsigned int v2 = (a1 >> 16) - 1;
  if (v2 >= 4) {
    int v3 = 0x40000;
  }
  else {
    int v3 = v2 << 16;
  }
  else {
    int v4 = (v6 - 1) << 24;
  }
  return v3 & 0xFFFF0000 | (unsigned __int16)a1 | v4;
}

void sub_1000A184C()
{
  __int128 v1 = *(_OWORD *)(v0 + 49);
  __src[0] = *(_OWORD *)(v0 + 33);
  __src[1] = v1;
  __int128 v2 = *(_OWORD *)(v0 + 81);
  __src[2] = *(_OWORD *)(v0 + 65);
  __src[3] = v2;
  __int128 v3 = *(_OWORD *)(v0 + 113);
  __src[4] = *(_OWORD *)(v0 + 97);
  __src[5] = v3;
  __int128 v4 = *(_OWORD *)(v0 + 145);
  __src[6] = *(_OWORD *)(v0 + 129);
  __src[7] = v4;
  __int128 v5 = *(_OWORD *)(v0 + 177);
  __src[8] = *(_OWORD *)(v0 + 161);
  __src[9] = v5;
  __int128 v6 = *(_OWORD *)(v0 + 209);
  __src[10] = *(_OWORD *)(v0 + 193);
  __src[11] = v6;
  __int128 v7 = *(_OWORD *)(v0 + 241);
  __src[12] = *(_OWORD *)(v0 + 225);
  __src[13] = v7;
  __int128 v8 = *(_OWORD *)(v0 + 273);
  __src[14] = *(_OWORD *)(v0 + 257);
  __src[15] = v8;
  __int128 v9 = *(_OWORD *)(v0 + 305);
  __src[16] = *(_OWORD *)(v0 + 289);
  __src[17] = v9;
  __int128 v10 = *(_OWORD *)(v0 + 337);
  __src[18] = *(_OWORD *)(v0 + 321);
  __src[19] = v10;
  __int128 v11 = *(_OWORD *)(v0 + 369);
  __src[20] = *(_OWORD *)(v0 + 353);
  __src[21] = v11;
  __int128 v12 = *(_OWORD *)(v0 + 401);
  __src[22] = *(_OWORD *)(v0 + 385);
  __src[23] = v12;
  __int128 v13 = *(_OWORD *)(v0 + 433);
  __src[24] = *(_OWORD *)(v0 + 417);
  __src[25] = v13;
  __int128 v14 = *(_OWORD *)(v0 + 465);
  __src[26] = *(_OWORD *)(v0 + 449);
  __src[27] = v14;
  __int128 v15 = *(_OWORD *)(v0 + 497);
  __src[28] = *(_OWORD *)(v0 + 481);
  __src[29] = v15;
  __int128 v16 = *(_OWORD *)(v0 + 529);
  __src[30] = *(_OWORD *)(v0 + 513);
  __src[31] = v16;
  __int128 v17 = *(_OWORD *)(v0 + 561);
  __src[32] = *(_OWORD *)(v0 + 545);
  __src[33] = v17;
  __int128 v18 = *(_OWORD *)(v0 + 593);
  __src[34] = *(_OWORD *)(v0 + 577);
  __src[35] = v18;
  __int128 v19 = *(_OWORD *)(v0 + 625);
  __src[36] = *(_OWORD *)(v0 + 609);
  __src[37] = v19;
  __int128 v20 = *(_OWORD *)(v0 + 657);
  __src[38] = *(_OWORD *)(v0 + 641);
  __src[39] = v20;
  __int128 v21 = *(_OWORD *)(v0 + 689);
  __src[40] = *(_OWORD *)(v0 + 673);
  __src[41] = v21;
  __int128 v22 = *(_OWORD *)(v0 + 721);
  __src[42] = *(_OWORD *)(v0 + 705);
  __src[43] = v22;
  __int128 v23 = *(_OWORD *)(v0 + 753);
  __src[44] = *(_OWORD *)(v0 + 737);
  __src[45] = v23;
  __int128 v24 = *(_OWORD *)(v0 + 785);
  __src[46] = *(_OWORD *)(v0 + 769);
  __src[47] = v24;
  __int128 v25 = *(_OWORD *)(v0 + 817);
  __src[48] = *(_OWORD *)(v0 + 801);
  __src[49] = v25;
  __int128 v26 = *(_OWORD *)(v0 + 849);
  __src[50] = *(_OWORD *)(v0 + 833);
  __src[51] = v26;
  __int128 v27 = *(_OWORD *)(v0 + 881);
  __src[52] = *(_OWORD *)(v0 + 865);
  __src[53] = v27;
  __int128 v28 = *(_OWORD *)(v0 + 913);
  __src[54] = *(_OWORD *)(v0 + 897);
  __src[55] = v28;
  __int128 v29 = *(_OWORD *)(v0 + 945);
  __src[56] = *(_OWORD *)(v0 + 929);
  __src[57] = v29;
  __int128 v30 = *(_OWORD *)(v0 + 977);
  __src[58] = *(_OWORD *)(v0 + 961);
  __src[59] = v30;
  uint64_t v31 = sub_100211E68(__src, *(unsigned __int16 *)(v0 + 31));
  unint64_t v33 = v32;
  unint64_t v34 = v32 >> 62;
  sub_100020AFC(v31, v32);
  sub_10000D9B0((uint64_t)_swiftEmptyArrayStorage);
  uint64_t v35 = type metadata accessor for BinaryDecoder();
  uint64_t v36 = (void *)swift_allocObject(v35, 48LL, 7LL);
  v36[5] = &_swiftEmptyDictionarySingleton;
  v36[2] = v31;
  v36[3] = v33;
  __asm { BR              X10 }

uint64_t sub_1000A1A08(uint64_t a1)
{
  *(void *)(v7 + 32) = (int)v5;
  swift_beginAccess(a1, v8 - 112, 1LL, 0LL);
  uint64_t v9 = *(void *)(v7 + 40);
  *(void *)(v7 + 40) = v3;
  swift_bridgeObjectRelease(v9);
  *(void *)(v8 - 128) = v6;
  *(void *)(v8 - 120) = sub_10000AF70( (unint64_t *)&qword_100405DE8,  (uint64_t (*)(uint64_t))type metadata accessor for BinaryDecoder,  (uint64_t)&protocol conformance descriptor for BinaryDecoder);
  *(void *)(v8 - 152) = v7;
  char v10 = sub_100165754((void *)(v8 - 152));
  uint64_t v12 = v11;
  uint64_t v14 = v13;
  uint64_t v16 = v15;
  uint64_t result = sub_1000208D8(v5, v4);
  int32x2_t v19 = *v2;
  int32x2_t v18 = v2[1];
  __int16 v20 = v2->i16[2];
  *(_WORD *)uint64_t v1 = v2->i16[3];
  *(int32x2_t *)(v1 + 2) = vzip1_s32(v18, v19);
  *(_WORD *)(v1 + 10) = v20;
  *(_BYTE *)(v1 + 16) = v10;
  *(void *)(v1 + 24) = v12;
  *(void *)(v1 + 32) = v14;
  *(void *)(v1 + 40) = v16;
  return result;
}

CoreP2P::Channel::Band_optional __swiftcall Channel.Band.init(apple80211:)(__C::apple80211_channel_band apple80211)
{
  if (apple80211.rawValue >= 4) {
    return (CoreP2P::Channel::Band_optional)3;
  }
  else {
    return (CoreP2P::Channel::Band_optional)(0x2010003u >> (8 * LOBYTE(apple80211.rawValue)));
  }
}

uint64_t sub_1000A1B34@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4 = sub_100002274(&qword_100406B80);
  __chkstk_darwin(v4);
  uint64_t v6 = (char *)&v51 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v7 = type metadata accessor for AWDLStatistics.LowLatencyStatistics.Configuration(0LL);
  uint64_t v8 = *(void *)(v7 - 8);
  __chkstk_darwin(v7);
  char v10 = (char *)&v51 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  __int128 v11 = *(_OWORD *)(a1 + 152);
  v83[8] = *(_OWORD *)(a1 + 136);
  v83[9] = v11;
  __int128 v12 = *(_OWORD *)(a1 + 184);
  v83[10] = *(_OWORD *)(a1 + 168);
  v83[11] = v12;
  __int128 v13 = *(_OWORD *)(a1 + 88);
  v83[4] = *(_OWORD *)(a1 + 72);
  v83[5] = v13;
  __int128 v14 = *(_OWORD *)(a1 + 120);
  v83[6] = *(_OWORD *)(a1 + 104);
  v83[7] = v14;
  __int128 v15 = *(_OWORD *)(a1 + 24);
  v83[0] = *(_OWORD *)(a1 + 8);
  v83[1] = v15;
  __int128 v16 = *(_OWORD *)(a1 + 56);
  v83[2] = *(_OWORD *)(a1 + 40);
  v83[3] = v16;
  sub_1000A4C4C((unsigned __int8 *)v83, (uint64_t)v6);
  if ((*(unsigned int (**)(char *, uint64_t, uint64_t))(v8 + 48))(v6, 1LL, v7) == 1)
  {
    sub_1000225EC((uint64_t)v6, &qword_100406B80);
LABEL_5:
    uint64_t v34 = type metadata accessor for AWDLStatistics.LowLatencyStatistics(0LL);
    return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(v34 - 8) + 56LL))( a2,  1LL,  1LL,  v34);
  }

  sub_100022628((uint64_t)v6, (uint64_t)v10, type metadata accessor for AWDLStatistics.LowLatencyStatistics.Configuration);
  uint64_t v17 = *(void *)(a1 + 200);
  uint64_t v69 = *(void *)(a1 + 216);
  uint64_t v70 = v17;
  uint64_t v18 = *(void *)(a1 + 224);
  uint64_t v67 = *(void *)(a1 + 232);
  uint64_t v68 = v18;
  uint64_t v19 = *(void *)(a1 + 240);
  uint64_t v65 = *(void *)(a1 + 248);
  uint64_t v66 = v19;
  uint64_t v20 = *(void *)(a1 + 256);
  uint64_t v21 = *(void *)(a1 + 272);
  uint64_t v63 = *(void *)(a1 + 264);
  uint64_t v64 = v20;
  uint64_t v22 = *(void *)(a1 + 280);
  uint64_t v61 = *(void *)(a1 + 288);
  uint64_t v62 = v22;
  uint64_t v23 = *(void *)(a1 + 296);
  uint64_t v59 = *(void *)(a1 + 304);
  uint64_t v60 = v23;
  uint64_t v24 = *(void *)(a1 + 312);
  uint64_t v57 = *(void *)(a1 + 320);
  uint64_t v58 = v24;
  uint64_t v25 = *(void *)(a1 + 328);
  uint64_t v55 = *(void *)(a1 + 336);
  uint64_t v56 = v25;
  uint64_t v26 = *(void *)(a1 + 344);
  uint64_t v53 = *(void *)(a1 + 352);
  uint64_t v54 = v26;
  uint64_t v27 = *(void *)(a1 + 368);
  uint64_t v52 = *(void *)(a1 + 360);
  uint64_t v29 = *(void *)(a1 + 376);
  uint64_t v28 = *(void *)(a1 + 384);
  uint64_t v30 = *(void *)(a1 + 392);
  uint64_t v31 = *(void *)(a1 + 400);
  unint64_t v32 = (const void *)(a1 + 416);
  uint64_t v33 = *(void *)(a1 + 408);
  memcpy(v82, v32, sizeof(v82));
  sub_1000A83BC(v82, (uint64_t)v80);
  sub_1000586C0((uint64_t)v80, (uint64_t)v81, &qword_100406B88);
  if (sub_1000ABC70((uint64_t *)v81) == 1)
  {
    sub_10005802C((uint64_t)v10, type metadata accessor for AWDLStatistics.LowLatencyStatistics.Configuration);
    goto LABEL_5;
  }

  __int128 v77 = v81[6];
  __int128 v78 = v81[7];
  __int128 v79 = v81[8];
  __int128 v73 = v81[2];
  __int128 v74 = v81[3];
  __int128 v75 = v81[4];
  __int128 v76 = v81[5];
  __int128 v71 = v81[0];
  __int128 v72 = v81[1];
  sub_100022628((uint64_t)v10, a2, type metadata accessor for AWDLStatistics.LowLatencyStatistics.Configuration);
  uint64_t v36 = type metadata accessor for AWDLStatistics.LowLatencyStatistics(0LL);
  uint64_t v37 = a2 + *(int *)(v36 + 20);
  __int128 v38 = v72;
  *(_OWORD *)(v37 + 216) = v71;
  __int128 v39 = v79;
  *(_OWORD *)(v37 + 328) = v78;
  *(_OWORD *)(v37 + 344) = v39;
  __int128 v40 = v77;
  *(_OWORD *)(v37 + 296) = v76;
  *(_OWORD *)(v37 + 312) = v40;
  __int128 v41 = v75;
  __int128 v42 = v73;
  *(_OWORD *)(v37 + 264) = v74;
  *(_OWORD *)(v37 + 280) = v41;
  *(_OWORD *)(v37 + 248) = v42;
  *(void *)uint64_t v37 = v70;
  *(void *)(v37 + 8) = v21;
  uint64_t v43 = v68;
  *(void *)(v37 + 16) = v69;
  *(void *)(v37 + 24) = v43;
  uint64_t v44 = v66;
  *(void *)(v37 + 32) = v67;
  *(void *)(v37 + 40) = v44;
  uint64_t v45 = v64;
  *(void *)(v37 + 48) = v65;
  *(void *)(v37 + 56) = v45;
  *(void *)(v37 + 64) = v63;
  *(void *)(v37 + 72) = v21;
  uint64_t v46 = v61;
  *(void *)(v37 + 80) = v62;
  *(void *)(v37 + 88) = v46;
  uint64_t v47 = v59;
  *(void *)(v37 + 96) = v60;
  *(void *)(v37 + 104) = v47;
  uint64_t v48 = v57;
  *(void *)(v37 + 112) = v58;
  *(void *)(v37 + 120) = v48;
  uint64_t v49 = v55;
  *(void *)(v37 + 128) = v56;
  *(void *)(v37 + 136) = v49;
  uint64_t v50 = v53;
  *(void *)(v37 + 144) = v54;
  *(void *)(v37 + 152) = v50;
  *(void *)(v37 + 160) = v52;
  *(void *)(v37 + 168) = v27;
  *(void *)(v37 + 176) = v29;
  *(void *)(v37 + 184) = v28;
  *(void *)(v37 + 192) = v30;
  *(void *)(v37 + 200) = v31;
  *(void *)(v37 + 208) = v33;
  *(_OWORD *)(v37 + 232) = v38;
  return (*(uint64_t (**)(uint64_t, void, uint64_t, uint64_t))(*(void *)(v36 - 8) + 56LL))(a2, 0LL, 1LL, v36);
}

uint64_t sub_1000A1EAC@<X0>(uint64_t a1@<X8>)
{
  uint64_t v4 = type metadata accessor for DispatchTimeInterval(0LL);
  uint64_t v5 = *(void *)(v4 - 8);
  uint64_t v6 = __chkstk_darwin(v4);
  uint64_t v8 = (uint64_t *)((char *)v24.i64 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0LL));
  __chkstk_darwin(v6);
  char v10 = (uint64_t *)((char *)v24.i64 - v9);
  uint64_t v11 = *v1;
  v2.i32[0] = *((_DWORD *)v1 + 2);
  unint64_t v12 = sub_1000A810C(*((_DWORD *)v1 + 4), *((_DWORD *)v1 + 5));
  if ((v12 & 0xFF00000000LL) == 0x300000000LL)
  {
    if (qword_100404388 != -1) {
      swift_once(&qword_100404388, sub_1001863C8);
    }
    int v13 = static Channel.awdlSocial2GHz;
    unint64_t v31 = byte_10041088C;
    unint64_t v14 = byte_10041088D;
  }

  else
  {
    int v13 = v12;
    unint64_t v31 = HIDWORD(v12);
    unint64_t v14 = v12 >> 40;
  }

  unint64_t v30 = v14;
  int v29 = *((_DWORD *)v1 + 6);
  *char v10 = *((unsigned int *)v1 + 7);
  uint64_t v15 = enum case for DispatchTimeInterval.milliseconds(_:);
  __int128 v16 = *(void (**)(void *, uint64_t, uint64_t))(v5 + 104);
  v16(v10, enum case for DispatchTimeInterval.milliseconds(_:), v4);
  *uint64_t v8 = *((unsigned int *)v1 + 8);
  v16(v8, v15, v4);
  int v17 = *((_DWORD *)v1 + 16);
  if (v17 < 0)
  {
    uint64_t result = _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  "Negative value is not representable",  35LL,  2LL,  "Swift/Integers.swift",  20LL,  2,  3451LL,  0);
    __break(1u);
  }

  else
  {
    int16x8_t v24 = (int16x8_t)vmovl_u8(v2);
    int v18 = *((_DWORD *)v1 + 9);
    int v25 = *((_DWORD *)v1 + 10);
    uint64_t v26 = *((int *)v1 + 11);
    int v27 = *((_DWORD *)v1 + 12);
    uint64_t v28 = v1[7];
    uint64_t v19 = sub_100002274(&qword_100406B90);
    uint64_t v20 = swift_allocObject(v19, 36LL, 7LL);
    *(_OWORD *)(v20 + 16) = xmmword_10033E830;
    *(_DWORD *)(v20 + 32) = *((_DWORD *)v1 + 17);
    *(void *)a1 = v11;
    *(_DWORD *)(a1 + 8) = vmovn_s16(v24).u32[0];
    *(_DWORD *)(a1 + 12) = v13;
    *(_BYTE *)(a1 + 16) = v31;
    *(_BYTE *)(a1 + 17) = v30;
    *(_DWORD *)(a1 + 20) = v29;
    uint64_t v21 = (int *)type metadata accessor for AWDLActionFrame.Header(0LL);
    uint64_t v22 = *(void (**)(uint64_t, void *, uint64_t))(v5 + 32);
    v22(a1 + v21[8], v10, v4);
    uint64_t result = ((uint64_t (*)(uint64_t, void *, uint64_t))v22)(a1 + v21[9], v8, v4);
    *(_DWORD *)(a1 + v21[10]) = v18;
    *(_DWORD *)(a1 + v21[11]) = v25;
    *(void *)(a1 + v21[12]) = v26;
    *(_DWORD *)(a1 + v21[13]) = v27;
    *(void *)(a1 + v21[14]) = v28;
    *(_DWORD *)(a1 + v21[15]) = v17;
    *(void *)(a1 + v21[16]) = v20;
  }

  return result;
}

unint64_t sub_1000A2168()
{
  uint8x8_t v2 = v0;
  memcpy(__dst, v0 + 4, 0x1B8uLL);
  uint64_t v23 = _swiftEmptyArrayStorage;
  sub_100069864(0, 10LL, 0);
  uint64_t v3 = 0LL;
  uint64_t v4 = _swiftEmptyArrayStorage;
  do
  {
    __int16 v5 = *(_WORD *)&__dst[v3 + 4];
    int v6 = *(_DWORD *)&__dst[v3 + 40];
    int v14 = *(_DWORD *)&__dst[v3];
    __int16 v15 = v5;
    __int128 v16 = *(_OWORD *)&__dst[v3 + 8];
    __int128 v17 = *(_OWORD *)&__dst[v3 + 24];
    int v18 = v6;
    sub_1000A3F74((uint64_t)&v14, (uint64_t)&v19);
    v1.i32[0] = v19;
    char v7 = v20;
    char v8 = v21;
    uint64_t v9 = v22;
    uint64_t v23 = v4;
    unint64_t v11 = v4[2];
    unint64_t v10 = v4[3];
    if (v11 >= v10 >> 1)
    {
      sub_100069864(v10 > 1, v11 + 1, 1);
      uint64_t v4 = v23;
    }

    v4[2] = v11 + 1;
    unint64_t v12 = (char *)v4 + 14 * v11;
    *((_DWORD *)v12 + 8) = vmovn_s16((int16x8_t)vmovl_u8(v1)).u32[0];
    v12[36] = v7;
    v12[37] = v8;
    *(void *)(v12 + 38) = v9;
    v3 += 44LL;
  }

  while (v3 != 440);
  return *v2 | ((unint64_t)*((unsigned __int8 *)v2 + 4) << 32) | ((unint64_t)*((unsigned __int8 *)v2 + 5) << 40);
}

__n128 sub_1000A22C4@<Q0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  __int16 v4 = a1;
  uint64_t v6 = a1 & 0xFFFF0000;
  if ((a1 & 0xFFFF0000) != 0)
  {
    uint64_t v28 = a2;
    uint64_t v29 = a3;
    uint64_t v7 = sub_1000EF854((uint64_t)&v28, (uint64_t)v30);
    unint64_t v9 = v8;
    sub_100208BAC(v7, v8);
    uint64_t v15 = v14;
    uint64_t v17 = v16;
    sub_1000208D8(v7, v9);
  }

  else
  {
    LOBYTE(v28) = BYTE4(a1);
    BYTE1(v28) = BYTE5(a1);
    BYTE2(v28) = BYTE6(a1);
    BYTE3(v28) = HIBYTE(a1);
    uint64_t v10 = sub_1000EF854((uint64_t)&v28, (uint64_t)&v28 + 4);
    unint64_t v12 = v11;
    sub_100208DB4(v10, v11);
    LODWORD(v15) = v13;
    sub_1000208D8(v10, v12);
    uint64_t v17 = 0LL;
    uint64_t v15 = v15;
  }

  char v18 = v6 != 0;
  uint64_t v28 = v15;
  uint64_t v29 = v17;
  v30[0] = 0LL;
  v30[1] = 0LL;
  BOOL v31 = v6 != 0;
  sub_100089F58((uint64_t)&v28, (uint64_t)&v24);
  __n128 v23 = v24;
  uint64_t v19 = v25;
  uint64_t v20 = v26;
  char v21 = v27;
  sub_1000ABC88(v15, v17, 0LL, 0LL, v18);
  *(_WORD *)a4 = v4;
  __n128 result = v23;
  *(__n128 *)(a4 + 8) = v23;
  *(void *)(a4 + 24) = v19;
  *(void *)(a4 + 32) = v20;
  *(_BYTE *)(a4 + 40) = v21;
  return result;
}

void *sub_1000A24E8()
{
  uint64_t v1 = *v0;
  uint64_t v86 = v0[1];
  __int128 v2 = *(_OWORD *)(v0 + 18);
  __int128 v3 = *(_OWORD *)(v0 + 34);
  __int128 v4 = *(_OWORD *)(v0 + 50);
  __int128 v5 = *(_OWORD *)(v0 + 66);
  __int128 v6 = *(_OWORD *)(v0 + 82);
  __int128 v7 = *(_OWORD *)(v0 + 98);
  __int128 v8 = *(_OWORD *)(v0 + 114);
  __int128 v9 = *(_OWORD *)(v0 + 130);
  __int128 v10 = *(_OWORD *)(v0 + 146);
  __int128 v11 = *(_OWORD *)(v0 + 162);
  __int128 v12 = *(_OWORD *)(v0 + 178);
  __int128 v13 = *(_OWORD *)(v0 + 194);
  __int128 v14 = *(_OWORD *)(v0 + 210);
  __int128 v15 = *(_OWORD *)(v0 + 226);
  __int128 v16 = *(_OWORD *)(v0 + 242);
  __int128 v17 = *(_OWORD *)(v0 + 258);
  __int128 v18 = *(_OWORD *)(v0 + 274);
  __int128 v19 = *(_OWORD *)(v0 + 290);
  __int128 v20 = *(_OWORD *)(v0 + 306);
  v87[0] = *(_OWORD *)(v0 + 2);
  v87[1] = v2;
  v87[2] = v3;
  v87[3] = v4;
  __int128 v21 = *(_OWORD *)(v0 + 322);
  __int128 v22 = *(_OWORD *)(v0 + 338);
  __int128 v23 = *(_OWORD *)(v0 + 354);
  __int128 v24 = *(_OWORD *)(v0 + 370);
  __int128 v25 = *(_OWORD *)(v0 + 386);
  v87[4] = v5;
  v87[5] = v6;
  v87[6] = v7;
  v87[7] = v8;
  v87[8] = v9;
  v87[9] = v10;
  v87[10] = v11;
  v87[11] = v12;
  v87[12] = v13;
  v87[13] = v14;
  v87[14] = v15;
  v87[15] = v16;
  v87[16] = v17;
  v87[17] = v18;
  v87[18] = v19;
  v87[19] = v20;
  v87[20] = v21;
  v87[21] = v22;
  uint64_t v26 = (unsigned __int8 *)v87 + v1;
  v87[22] = v23;
  v87[23] = v24;
  v87[24] = v25;
  if (v1)
  {
    if (qword_100404370 != -1) {
      swift_once(&qword_100404370, sub_10018635C);
    }
    char v27 = _swiftEmptyArrayStorage;
    uint64_t v28 = (unsigned __int8 *)v87;
    while (1)
    {
      uint64_t v30 = *v28;
      BOOL v31 = off_10040A198;
      if (*((void *)off_10040A198 + 2))
      {
        uint64_t v32 = static Hasher._hash(seed:bytes:count:)(*((void *)off_10040A198 + 5), *v28, 4LL);
        uint64_t v33 = -1LL << v31[32];
        unint64_t v34 = v32 & ~v33;
        if (((*(void *)&v31[((v34 >> 3) & 0xFFFFFFFFFFFFF8LL) + 56] >> v34) & 1) != 0)
        {
          uint64_t v35 = *((void *)v31 + 6);
          if (*(_DWORD *)(v35 + 4 * v34) == (_DWORD)v30)
          {
LABEL_13:
            char v37 = 0;
            char v38 = 3;
            goto LABEL_32;
          }

          uint64_t v36 = ~v33;
          while (1)
          {
            unint64_t v34 = (v34 + 1) & v36;
            if (((*(void *)&v31[((v34 >> 3) & 0xFFFFFFFFFFFFF8LL) + 56] >> v34) & 1) == 0) {
              break;
            }
            if (*(_DWORD *)(v35 + 4 * v34) == (_DWORD)v30) {
              goto LABEL_13;
            }
          }
        }
      }

      if (qword_100404378 != -1) {
        swift_once(&qword_100404378, sub_100186380);
      }
      __int128 v39 = off_10040A1A0;
      if (*((void *)off_10040A1A0 + 2))
      {
        uint64_t v40 = static Hasher._hash(seed:bytes:count:)(*((void *)off_10040A1A0 + 5), v30, 4LL);
        uint64_t v41 = -1LL << v39[32];
        unint64_t v42 = v40 & ~v41;
        if (((*(void *)&v39[((v42 >> 3) & 0xFFFFFFFFFFFFF8LL) + 56] >> v42) & 1) != 0)
        {
          uint64_t v43 = *((void *)v39 + 6);
          if (*(_DWORD *)(v43 + 4 * v42) == (_DWORD)v30)
          {
LABEL_22:
            char v37 = 1;
            char v38 = 4;
            goto LABEL_32;
          }

          uint64_t v44 = ~v41;
          while (1)
          {
            unint64_t v42 = (v42 + 1) & v44;
            if (((*(void *)&v39[((v42 >> 3) & 0xFFFFFFFFFFFFF8LL) + 56] >> v42) & 1) == 0) {
              break;
            }
            if (*(_DWORD *)(v43 + 4 * v42) == (_DWORD)v30) {
              goto LABEL_22;
            }
          }
        }
      }

      if (qword_100404380 != -1) {
        swift_once(&qword_100404380, sub_1001863A4);
      }
      uint64_t v45 = off_10040A1A8;
      if (!*((void *)off_10040A1A8 + 2)) {
        goto LABEL_6;
      }
      uint64_t v46 = static Hasher._hash(seed:bytes:count:)(*((void *)off_10040A1A8 + 5), v30, 4LL);
      uint64_t v47 = -1LL << v45[32];
      unint64_t v48 = v46 & ~v47;
      if (((*(void *)&v45[((v48 >> 3) & 0xFFFFFFFFFFFFF8LL) + 56] >> v48) & 1) == 0) {
        goto LABEL_6;
      }
      uint64_t v49 = *((void *)v45 + 6);
      if (*(_DWORD *)(v49 + 4 * v48) != (_DWORD)v30)
      {
        uint64_t v50 = ~v47;
        do
        {
          unint64_t v48 = (v48 + 1) & v50;
          if (((*(void *)&v45[((v48 >> 3) & 0xFFFFFFFFFFFFF8LL) + 56] >> v48) & 1) == 0) {
            goto LABEL_6;
          }
        }

        while (*(_DWORD *)(v49 + 4 * v48) != (_DWORD)v30);
      }

      char v37 = 2;
      char v38 = 5;
LABEL_32:
      LODWORD(v88) = v30;
      BYTE4(v88) = v37;
      BYTE5(v88) = v38;
      sub_100185C58();
      int v51 = (int)v88;
      char v52 = BYTE4(v88);
      char v53 = BYTE5(v88);
      if ((swift_isUniquelyReferenced_nonNull_native(v27) & 1) == 0) {
        char v27 = sub_1000A65E8(0LL, v27[2] + 1LL, 1, v27);
      }
      unint64_t v55 = v27[2];
      unint64_t v54 = v27[3];
      if (v55 >= v54 >> 1) {
        char v27 = sub_1000A65E8((void *)(v54 > 1), v55 + 1, 1, v27);
      }
      v27[2] = v55 + 1;
      uint64_t v29 = &v27[v55];
      *((_DWORD *)v29 + 8) = v51;
      *((_BYTE *)v29 + 36) = v52;
      *((_BYTE *)v29 + 37) = v53;
LABEL_6:
      if (++v28 == v26) {
        goto LABEL_37;
      }
    }
  }

  char v27 = _swiftEmptyArrayStorage;
LABEL_37:
  if ((_DWORD)v86)
  {
    if (qword_100404370 != -1) {
      swift_once(&qword_100404370, sub_10018635C);
    }
    uint64_t v56 = &v26[v86];
    uint64_t v57 = _swiftEmptyArrayStorage;
    while (1)
    {
      uint64_t v59 = *v26;
      uint64_t v60 = off_10040A198;
      if (*((void *)off_10040A198 + 2))
      {
        uint64_t v61 = static Hasher._hash(seed:bytes:count:)(*((void *)off_10040A198 + 5), *v26, 4LL);
        uint64_t v62 = -1LL << v60[32];
        unint64_t v63 = v61 & ~v62;
        if (((*(void *)&v60[((v63 >> 3) & 0xFFFFFFFFFFFFF8LL) + 56] >> v63) & 1) != 0)
        {
          uint64_t v64 = *((void *)v60 + 6);
          if (*(_DWORD *)(v64 + 4 * v63) == (_DWORD)v59)
          {
LABEL_49:
            char v66 = 0;
            char v67 = 3;
            goto LABEL_68;
          }

          uint64_t v65 = ~v62;
          while (1)
          {
            unint64_t v63 = (v63 + 1) & v65;
            if (((*(void *)&v60[((v63 >> 3) & 0xFFFFFFFFFFFFF8LL) + 56] >> v63) & 1) == 0) {
              break;
            }
            if (*(_DWORD *)(v64 + 4 * v63) == (_DWORD)v59) {
              goto LABEL_49;
            }
          }
        }
      }

      if (qword_100404378 != -1) {
        swift_once(&qword_100404378, sub_100186380);
      }
      uint64_t v68 = off_10040A1A0;
      if (*((void *)off_10040A1A0 + 2))
      {
        uint64_t v69 = static Hasher._hash(seed:bytes:count:)(*((void *)off_10040A1A0 + 5), v59, 4LL);
        uint64_t v70 = -1LL << v68[32];
        unint64_t v71 = v69 & ~v70;
        if (((*(void *)&v68[((v71 >> 3) & 0xFFFFFFFFFFFFF8LL) + 56] >> v71) & 1) != 0)
        {
          uint64_t v72 = *((void *)v68 + 6);
          if (*(_DWORD *)(v72 + 4 * v71) == (_DWORD)v59)
          {
LABEL_58:
            char v66 = 1;
            char v67 = 4;
            goto LABEL_68;
          }

          uint64_t v73 = ~v70;
          while (1)
          {
            unint64_t v71 = (v71 + 1) & v73;
            if (((*(void *)&v68[((v71 >> 3) & 0xFFFFFFFFFFFFF8LL) + 56] >> v71) & 1) == 0) {
              break;
            }
            if (*(_DWORD *)(v72 + 4 * v71) == (_DWORD)v59) {
              goto LABEL_58;
            }
          }
        }
      }

      if (qword_100404380 != -1) {
        swift_once(&qword_100404380, sub_1001863A4);
      }
      __int128 v74 = off_10040A1A8;
      if (!*((void *)off_10040A1A8 + 2)) {
        goto LABEL_42;
      }
      uint64_t v75 = static Hasher._hash(seed:bytes:count:)(*((void *)off_10040A1A8 + 5), v59, 4LL);
      uint64_t v76 = -1LL << v74[32];
      unint64_t v77 = v75 & ~v76;
      if (((*(void *)&v74[((v77 >> 3) & 0xFFFFFFFFFFFFF8LL) + 56] >> v77) & 1) == 0) {
        goto LABEL_42;
      }
      uint64_t v78 = *((void *)v74 + 6);
      if (*(_DWORD *)(v78 + 4 * v77) != (_DWORD)v59)
      {
        uint64_t v79 = ~v76;
        do
        {
          unint64_t v77 = (v77 + 1) & v79;
          if (((*(void *)&v74[((v77 >> 3) & 0xFFFFFFFFFFFFF8LL) + 56] >> v77) & 1) == 0) {
            goto LABEL_42;
          }
        }

        while (*(_DWORD *)(v78 + 4 * v77) != (_DWORD)v59);
      }

      char v66 = 2;
      char v67 = 5;
LABEL_68:
      LODWORD(v88) = v59;
      BYTE4(v88) = v66;
      BYTE5(v88) = v67;
      sub_100185C58();
      int v80 = (int)v88;
      char v81 = BYTE4(v88);
      char v82 = BYTE5(v88);
      if ((swift_isUniquelyReferenced_nonNull_native(v57) & 1) == 0) {
        uint64_t v57 = sub_1000A65E8(0LL, v57[2] + 1LL, 1, v57);
      }
      unint64_t v84 = v57[2];
      unint64_t v83 = v57[3];
      if (v84 >= v83 >> 1) {
        uint64_t v57 = sub_1000A65E8((void *)(v83 > 1), v84 + 1, 1, v57);
      }
      v57[2] = v84 + 1;
      uint64_t v58 = &v57[v84];
      *((_DWORD *)v58 + 8) = v80;
      *((_BYTE *)v58 + 36) = v81;
      *((_BYTE *)v58 + 37) = v82;
LABEL_42:
      if (++v26 == v56) {
        goto LABEL_73;
      }
    }
  }

  uint64_t v57 = _swiftEmptyArrayStorage;
LABEL_73:
  __int128 v88 = v27;
  sub_10019D9E4((uint64_t)v57);
  return v88;
}

uint64_t sub_1000A2BBC(uint64_t a1)
{
  if ((a1 & 1) != 0)
  {
    if ((a1 & 2) != 0)
    {
      uint64_t v1 = 10LL;
      if ((a1 & 0x100000000LL) != 0) {
        goto LABEL_4;
      }
    }

    else
    {
      uint64_t v1 = 2LL;
      if ((a1 & 0x100000000LL) != 0) {
        goto LABEL_4;
      }
    }
  }

  else
  {
    if ((a1 & 2) == 0)
    {
      uint64_t v1 = 0LL;
      if ((a1 & 0x100000000LL) == 0) {
        goto LABEL_5;
      }
      goto LABEL_4;
    }

    uint64_t v1 = 8LL;
    if ((a1 & 0x100000000LL) != 0) {
LABEL_4:
    }
      uint64_t v1 = v1 | 0x20;
  }

void sub_1000A2C24(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v9 = 0LL;
  __int128 v4 = sub_100333ADC(a1, a2, &v9);
  uint64_t v5 = (uint64_t)v4 + v9;
  uint64_t v6 = a3[5];
  uint64_t v7 = a3[2];
  uint64_t v8 = a3[3];
  swift_retain();
  swift_bridgeObjectRetain(v8);
  AppleDevice.setRequest(requestType:data:on:)(0xA2uLL, (uint64_t)v4, v5, 0, v7, v8);
  swift_bridgeObjectRelease(v8);
  swift_release(v6);
  free(v4);
}

void sub_1000A2CFC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v15 = 0LL;
  uint64_t v9 = sub_100333ADC(a1, a2, &v15);
  uint64_t v10 = (uint64_t)v9 + v15;
  uint64_t v11 = *(void *)(a6 + 8);
  uint64_t v12 = *(void *)(a5 + 8);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v11,  a4,  &protocol requirements base descriptor for DeviceDriver);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a6,  a4,  AssociatedTypeWitness,  &protocol requirements base descriptor for IO80211Driver,  &associated conformance descriptor for IO80211Driver.DeviceDriver.Device: IO80211Device);
  sub_10009FA28(162LL, (uint64_t)v9, v10, a4, v11, v12, AssociatedConformanceWitness);
  free(v9);
}

uint64_t sub_1000A2E0C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, void *a7)
{
  uint64_t v13 = *(void *)(a6 + 8);
  uint64_t v14 = *(void *)(a5 + 8);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v13,  a4,  &protocol requirements base descriptor for DeviceDriver);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a6,  a4,  AssociatedTypeWitness,  &protocol requirements base descriptor for IO80211Driver,  &associated conformance descriptor for IO80211Driver.DeviceDriver.Device: IO80211Device);
  uint64_t result = sub_10009FA28(120LL, a1, a2, a4, v13, v14, AssociatedConformanceWitness);
  if (v7) {
    *a7 = v7;
  }
  return result;
}

uint64_t sub_1000A2EDC(const void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (*(void *)(a5 + 16) >= 0x10uLL) {
    unint64_t v10 = 16LL;
  }
  else {
    unint64_t v10 = *(void *)(a5 + 16);
  }
  uint64_t v11 = (void (*)(_BYTE *, void))swift_modifyAtWritableKeyPath(__dst, a1, a2);
  sub_1000A4558(v12, v12 + 544, a4, a5, v10);
  v11(__dst, 0LL);
  __dst[0] = v10;
  return swift_setAtWritableKeyPath(a1, a3, __dst);
}

uint64_t sub_1000A2FC0(const void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (*(void *)(a5 + 16) >= 0x10uLL) {
    unint64_t v10 = 16LL;
  }
  else {
    unint64_t v10 = *(void *)(a5 + 16);
  }
  uint64_t v11 = (void (*)(_BYTE *, void))swift_modifyAtWritableKeyPath(__dst, a1, a2);
  sub_1000A4558(v12, v12 + 544, a4, a5, v10);
  v11(__dst, 0LL);
  __dst[0] = v10;
  return swift_setAtWritableKeyPath(a1, a3, __dst);
}

uint64_t sub_1000A30C0(uint64_t result, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v5 = v4;
  uint64_t v6 = *(void *)(a3 + 16);
  if (v6)
  {
    uint64_t v7 = result;
    uint64_t v8 = a3 + 32;
    uint64_t v31 = a3;
    swift_bridgeObjectRetain(a3);
    unint64_t v9 = 0LL;
    unint64_t v10 = (_OWORD *)(v7 + 4);
    uint64_t v25 = v8;
    uint64_t v26 = v7;
    while (1)
    {
      if (v9 < 2)
      {
        uint64_t v11 = *(void *)(v8 + 16 * v9 + 8);
        unint64_t v12 = *(void *)(v11 + 16);
        if (v12 >= 0x100)
        {
          uint64_t result = _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  "Not enough bits to represent the passed value",  45LL,  2LL,  "Swift/Integers.swift",  20LL,  2,  3455LL,  0);
          __break(1u);
          return result;
        }

        unint64_t v13 = v7 + 1284 * v9;
        *(_BYTE *)(v13 + 1) = v12;
        *(_BYTE *)(v13 + 2) = v9;
        uint64_t v14 = *(void *)(v11 + 16);
        if (v14) {
          break;
        }
      }

uint64_t sub_1000A32E4@<X0>(unint64_t a1@<X8>)
{
  uint64_t v4 = *v1;
  unint64_t v5 = sub_100071694(3LL, 2LL, *v1, a1);
  uint64_t v6 = v2;
  if (v2) {
    goto LABEL_23;
  }
  unsigned __int8 v7 = _s7CoreP2P20NANAvailabilityEntryV15UsagePreferenceO8rawValueAESgSi_tcfC_0(v5);
  if (v7 == 4)
  {
LABEL_22:
    unint64_t v30 = sub_1000033FC();
    uint64_t v6 = swift_allocError(&type metadata for WiFiError, v30, 0LL, 0LL);
    *(_OWORD *)uint64_t v31 = xmmword_100337020;
    *(_BYTE *)(v31 + 16) = 2;
    swift_willThrow(v6);
LABEL_23:
    swift_unexpectedError(v6, "CoreP2P/NANAvailability.swift", 29LL, 1LL);
    __break(1u);
    swift_unexpectedError(v4, "CoreP2P/NANAvailability.swift", 29LL, 1LL);
    __break(1u);
    goto LABEL_24;
  }

  unsigned __int8 v8 = v7;
  uint64_t v9 = sub_100071694(5LL, 2LL, v4, v7);
  double v11 = 0.0;
  if (v9 >= 5) {
    goto LABEL_7;
  }
  double v11 = (double)v9 * 0.2 * 5.0;
  if ((~*(void *)&v11 & 0x7FF0000000000000LL) == 0)
  {
LABEL_21:
    __break(1u);
    goto LABEL_22;
  }

  if (v11 <= -1.0)
  {
    __break(1u);
    goto LABEL_20;
  }

  unint64_t v10 = 0x4070000000000000LL;
  if (v11 >= 256.0)
  {
LABEL_20:
    __break(1u);
    goto LABEL_21;
  }

void sub_1000A36C4(__int16 a1, uint64_t a2, uint64_t a3)
{
  unint64_t v5 = sub_100071298(6LL, 9LL, a1, __stack_chk_guard);
  if ((v5 & 0x8000000000000000LL) != 0)
  {
    _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  "Negative value is not representable",  35LL,  2LL,  "Swift/Integers.swift",  20LL,  2,  3451LL,  0);
  }

  else
  {
    if (v5 < 0x10000)
    {
      unint64_t v6 = sub_1000713C8(3uLL, 3LL, a1);
      _s7CoreP2P14IEEE80211FrameV10ManagementO14AuthenticationO0F9AlgorithmO8rawValueAISgs5UInt8V_tcfC_0(v6);
      unint64_t v7 = sub_1000713C8(0LL, 3LL, a1);
      if (_s7CoreP2P19NANIntervalDurationO8rawValueACSgs5UInt8V_tcfC_0(v7) == 4) {
        __asm { BR              X11 }
      }

      __asm { BR              X11 }
    }

    _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  "Not enough bits to represent the passed value",  45LL,  2LL,  "Swift/Integers.swift",  20LL,  2,  3455LL,  0);
  }

  __break(1u);
  JUMPOUT(0x1000A396CLL);
}

uint64_t sub_1000A398C(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  if (a4) {
    uint64_t v4 = a4;
  }
  else {
    uint64_t v4 = _swiftEmptyArrayStorage;
  }
  uint64_t v5 = v4[2];
  if (v5)
  {
    swift_bridgeObjectRetain(a4);
    unint64_t v7 = v4 + 7;
    unsigned __int8 v8 = (_BYTE *)(a1 + 70);
    do
    {
      char v9 = *((_BYTE *)v7 - 24);
      uint64_t v10 = *(v7 - 1);
      unint64_t v11 = *v7;
      __int16 v12 = *((_WORD *)v7 - 8);
      sub_100020AFC(v10, *v7);
      sub_1000A36C4(v12, v10, v11);
      *(v8 - 70) = v9;
      *((_WORD *)v8 - 34) = v14;
      *(_OWORD *)(v8 - 66) = v15;
      *(_OWORD *)(v8 - 50) = v16;
      *(_OWORD *)(v8 - 34) = v17;
      *(_OWORD *)(v8 - 18) = v18;
      *((_WORD *)v8 - 1) = v19;
      *unsigned __int8 v8 = v20;
      v8 += 72;
      sub_1000208D8(v10, v11);
      v7 += 4;
      --v5;
    }

    while (v5);
  }

  else
  {
    swift_bridgeObjectRetain(a4);
  }

  return swift_bridgeObjectRelease(v4);
}

uint64_t sub_1000A3A94(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, void *a7)
{
  uint64_t v13 = *(void *)(a5 + 8);
  uint64_t v14 = *(void *)(a6 + 16);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v13,  a4,  &protocol requirements base descriptor for DeviceDriver);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a5,  a4,  AssociatedTypeWitness,  &protocol requirements base descriptor for IO80211Driver,  &associated conformance descriptor for IO80211Driver.DeviceDriver.Device: IO80211Device);
  uint64_t result = sub_10009F90C(364LL, a1, a2, a4, v13, v14, AssociatedConformanceWitness);
  if (v7) {
    *a7 = v7;
  }
  return result;
}

uint64_t sub_1000A3B64(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = sub_100002274(&qword_100406B20);
  sub_10016D190( a1,  (uint64_t)sub_1000A3BD8,  0LL,  a3,  (uint64_t)&type metadata for Never,  v5,  (uint64_t)&protocol witness table for Never,  v6);
  return v8;
}

uint64_t sub_1000A3BD8@<X0>(uint64_t result@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  if (!result) {
    goto LABEL_6;
  }
  uint64_t v4 = result;
  uint64_t v5 = a2 - result;
  uint64_t v6 = v5 / 24;
  uint64_t result = specialized ContiguousArray.reserveCapacity(_:)(v5 / 24);
  if (v5 >= -23)
  {
    uint64_t v7 = (double *)(v4 + 16);
    do
    {
      double v8 = *(v7 - 2);
      double v9 = *(v7 - 1);
      double v10 = *v7;
      v7 += 3;
      id v11 = [objc_allocWithZone(WiFiAwareDataSessionStatisticsHistogramBin) initWithBinStart:v8 binEnd:v9 value:v10];
      specialized ContiguousArray._makeUniqueAndReserveCapacityIfNotUnique()();
      uint64_t v12 = _swiftEmptyArrayStorage[2];
      specialized ContiguousArray._reserveCapacityAssumingUniqueBuffer(oldCount:)(v12);
      uint64_t v13 = specialized ContiguousArray._appendElementAssumeUniqueAndCapacity(_:newElement:)(v12, v11);
      uint64_t result = specialized ContiguousArray._endMutation()(v13);
      --v6;
    }

    while (v6);
LABEL_6:
    *a3 = _swiftEmptyArrayStorage;
    return result;
  }

  __break(1u);
  return result;
}

uint64_t sub_1000A3D0C(unsigned int a1)
{
  if (a1 > 0x14) {
    return 3LL;
  }
  else {
    return qword_10033F110[a1];
  }
}

uint64_t sub_1000A3D2C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = sub_10000AF70( &qword_100406AE8,  (uint64_t (*)(uint64_t))type metadata accessor for apple80211_virtual_if_role,  (uint64_t)&unk_100338398);
  return RawRepresentable<>.init(from:)(a1, a2, a3, v6);
}

uint64_t sub_1000A3DA0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = sub_10000AF70( &qword_100406AE8,  (uint64_t (*)(uint64_t))type metadata accessor for apple80211_virtual_if_role,  (uint64_t)&unk_100338398);
  return RawRepresentable<>.encode(to:)(a1, a2, a3, v6);
}

uint64_t Channel.apple80211Channel.getter(uint64_t a1)
{
  if (qword_100404368 != -1) {
    swift_once(&qword_100404368, sub_100185C34);
  }
  sub_10008F720(a1, qword_10040A190);
  return (a1 << 32) | 1;
}

uint64_t sub_1000A3EC0(uint64_t a1)
{
  unsigned int v1 = a1;
  if ((BYTE5(a1) - 2) >= 5u)
  {
    if ((a1 & 0x10000000000LL) != 0) {
      int v2 = 516;
    }
    else {
      int v2 = 4;
    }
  }

  else
  {
    int v2 = dword_10033F1C4[(char)(BYTE5(a1) - 2)];
  }

  int v3 = dword_10033F1B8[a1 << 24 >> 56];
  if (qword_100404368 != -1) {
    swift_once(&qword_100404368, sub_100185C34);
  }
  unsigned int v4 = v3 | v2;
  if (sub_10008F720(v1, qword_10040A190)) {
    return v4 | 0x100;
  }
  else {
    return v4;
  }
}

int8x8_t sub_1000A3F74@<D0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  v2.i32[0] = *(_DWORD *)a1;
  char v4 = *(_BYTE *)(a1 + 4);
  char v5 = *(_BYTE *)(a1 + 5);
  int v6 = *(_DWORD *)(a1 + 8);
  int v8 = *(_DWORD *)(a1 + 20);
  int v7 = *(_DWORD *)(a1 + 24);
  int v9 = *(_DWORD *)(a1 + 28);
  int v36 = *(_DWORD *)(a1 + 32);
  int v37 = *(_DWORD *)(a1 + 36);
  int v38 = *(_DWORD *)(a1 + 40);
  if ((v6 & 1) != 0)
  {
    int v16 = *(_DWORD *)(a1 + 24);
    int v7 = *(_DWORD *)(a1 + 28);
    char v17 = *(_BYTE *)(a1 + 5);
    char v18 = *(_BYTE *)(a1 + 4);
    __int16 v19 = *(_WORD *)(a1 + 16);
    char v20 = _s7CoreP2P15IEEE80211StatusO8rawValueACSgs6UInt16V_tcfC_0(*(_WORD *)(a1 + 12) & 0x1FF);
    if (v20 == 54) {
      char v21 = 1;
    }
    else {
      char v21 = v20;
    }
    char v4 = v18;
    char v5 = v17;
    LOWORD(v9) = v7;
    LOWORD(v7) = v16;
    unsigned __int8 v22 = v21;
    __int16 v23 = _s7CoreP2P15IEEE80211ReasonO8rawValueACSgs6UInt16V_tcfC_0(v19 & 0x1FF);
    else {
      __int16 v24 = v23;
    }
    __int16 v10 = v22 | (unsigned __int16)(v24 << 8);
    if ((v6 & 2) != 0) {
      goto LABEL_3;
    }
LABEL_17:
    __int16 v15 = 8704;
    goto LABEL_18;
  }

  __int16 v10 = 8704;
  if ((v6 & 2) == 0) {
    goto LABEL_17;
  }
LABEL_3:
  unsigned __int8 v11 = _s7CoreP2P15IEEE80211StatusO8rawValueACSgs6UInt16V_tcfC_0(v8 & 0x1FF);
  if (v11 == 54) {
    unsigned __int8 v12 = 1;
  }
  else {
    unsigned __int8 v12 = v11;
  }
  __int16 v13 = _s7CoreP2P15IEEE80211ReasonO8rawValueACSgs6UInt16V_tcfC_0(v7 & 0x1FF);
  else {
    __int16 v14 = v13;
  }
  __int16 v15 = v12 | (unsigned __int16)(v14 << 8);
LABEL_18:
  int16x8_t v39 = (int16x8_t)vmovl_u8(v2);
  if ((v6 & 4) != 0)
  {
    unsigned __int8 v31 = _s7CoreP2P15IEEE80211StatusO8rawValueACSgs6UInt16V_tcfC_0(v9 & 0x1FF);
    if (v31 == 54) {
      unsigned __int8 v32 = 1;
    }
    else {
      unsigned __int8 v32 = v31;
    }
    __int16 v33 = _s7CoreP2P15IEEE80211ReasonO8rawValueACSgs6UInt16V_tcfC_0(v36 & 0x1FF);
    else {
      __int16 v34 = v33;
    }
    __int16 v25 = v32 | (unsigned __int16)(v34 << 8);
    if ((v6 & 8) != 0) {
      goto LABEL_20;
    }
LABEL_34:
    __int16 v30 = 8704;
    goto LABEL_35;
  }

  __int16 v25 = 8704;
  if ((v6 & 8) == 0) {
    goto LABEL_34;
  }
LABEL_20:
  unsigned __int8 v26 = _s7CoreP2P15IEEE80211StatusO8rawValueACSgs6UInt16V_tcfC_0(v37 & 0x1FF);
  if (v26 == 54) {
    unsigned __int8 v27 = 1;
  }
  else {
    unsigned __int8 v27 = v26;
  }
  __int16 v28 = _s7CoreP2P15IEEE80211ReasonO8rawValueACSgs6UInt16V_tcfC_0(v38 & 0x1FF);
  else {
    __int16 v29 = v28;
  }
  __int16 v30 = v27 | (unsigned __int16)(v29 << 8);
LABEL_35:
  int8x8_t result = vmovn_s16(v39);
  *(_DWORD *)a2 = result.i32[0];
  *(_BYTE *)(a2 + 4) = v4;
  *(_BYTE *)(a2 + 5) = v5;
  *(_WORD *)(a2 + 6) = v10;
  *(_WORD *)(a2 + 8) = v15;
  *(_WORD *)(a2 + 10) = v25;
  *(_WORD *)(a2 + 12) = v30;
  return result;
}

unint64_t WiFiNetwork.createRecord()( uint64_t a1, unint64_t a2, unint64_t a3, uint64_t a4)
{
  char v5 = a3;
  unint64_t v8 = a3 >> 8;
  unint64_t v9 = a3 >> 16;
  unint64_t v10 = a3 >> 24;
  unint64_t v11 = HIDWORD(a3);
  unint64_t v22 = a3 >> 40;
  uint64_t v12 = sub_100002274(qword_100405EA0);
  uint64_t inited = swift_initStackObject(v12, v23);
  *(_OWORD *)(inited + 16) = xmmword_10033E840;
  *(void *)(inited + 32) = 0x5254535F44495353LL;
  *(void *)(inited + 40) = 0xE800000000000000LL;
  *(void *)(inited + 48) = a1;
  *(void *)(inited + 56) = a2;
  *(void *)(inited + 72) = &type metadata for String;
  *(void *)(inited + 80) = 1145656147LL;
  *(void *)(inited + 88) = 0xE400000000000000LL;
  swift_bridgeObjectRetain_n(a2, 2LL);
  *(void *)(inited + 96) = sub_1000EF90C(a1, a2);
  *(void *)(inited + 104) = v14;
  *(void *)(inited + 120) = &type metadata for Data;
  *(void *)(inited + 128) = 0x4449535342LL;
  *(void *)(inited + 136) = 0xE500000000000000LL;
  uint64_t v15 = sub_100002274(&qword_1004040A8);
  uint64_t v16 = swift_allocObject(v15, 38LL, 7LL);
  *(_OWORD *)(v16 + 16) = xmmword_10033A980;
  *(_BYTE *)(v16 + 32) = v5;
  *(_BYTE *)(v16 + 33) = v8;
  *(_BYTE *)(v16 + 34) = v9;
  *(_BYTE *)(v16 + 35) = v10;
  *(_BYTE *)(v16 + 36) = v11;
  *(_BYTE *)(v16 + 37) = v22;
  uint64_t v17 = sub_1000FB08C(v16);
  uint64_t v19 = v18;
  swift_bridgeObjectRelease(v16);
  *(void *)(inited + 144) = v17;
  *(void *)(inited + 152) = v19;
  *(void *)(inited + 168) = &type metadata for Data;
  *(void *)(inited + 176) = 0x4C454E4E414843LL;
  *(void *)(inited + 184) = 0xE700000000000000LL;
  *(_DWORD *)(inited + 192) = a4;
  *(void *)(inited + 216) = &type metadata for UInt32;
  strcpy((char *)(inited + 224), "CHANNEL_FLAGS");
  *(_WORD *)(inited + 238) = -4864;
  int v20 = sub_1000A3EC0(a4 & 0xFFFFFFFFFFFFLL);
  *(void *)(inited + 264) = &type metadata for UInt32;
  *(_DWORD *)(inited + 240) = v20;
  return sub_10000D658(inited);
}

void sub_1000A4300(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  __asm { BR              X9 }

uint64_t sub_1000A4344(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v9 = sub_1000F048C(0LL, *(unsigned __int8 *)(a6 + 4), v7, v6);
  return ((uint64_t (*)(uint64_t, uint64_t))((char *)&loc_1000A436C + *((int *)qword_1000A4450 + v8)))(v9, v9);
}

uint64_t sub_1000A4380(uint64_t a1, uint64_t a2)
{
  if (a2 < 0)
  {
    __break(1u);
    JUMPOUT(0x1000A4440LL);
  }

  uint64_t v3 = ((uint64_t (*)(void))Data._Representation.subscript.getter)(0LL);
  unint64_t v5 = v4;
  sub_100046974(v3, v4, v2);
  return sub_1000208D8(v3, v5);
}

void sub_1000A4460(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  __asm { BR              X11 }

uint64_t sub_1000A44B0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (a5 < 0)
  {
    __break(1u);
    JUMPOUT(0x1000A4548LL);
  }

  uint64_t v8 = ((uint64_t (*)(void, uint64_t))Data._Representation.subscript.getter)(0LL, a5);
  unint64_t v10 = v9;
  unint64_t v11 = sub_10005D508();
  uint64_t v12 = DataProtocol.copyBytes(to:)(v7, v6, &type metadata for Data, v11);
  uint64_t result = sub_1000208D8(v8, v10);
  uint64_t *v5 = v12;
  return result;
}

uint64_t sub_1000A4558(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  if ((a5 & 0x8000000000000000LL) != 0)
  {
    __break(1u);
LABEL_12:
    __break(1u);
  }

  if (*(void *)(a4 + 16) < a5) {
    goto LABEL_12;
  }
  if (a5)
  {
    swift_bridgeObjectRetain(a4);
    sub_1000698D4(0, a5, 0);
    if (a5) {
      __asm { BR              X11 }
    }

    __break(1u);
    JUMPOUT(0x1000A4760LL);
  }

  uint64_t v7 = _swiftEmptyArrayStorage[2];
  if (v7)
  {
    uint64_t v8 = (_WORD *)(a1 + 32);
    unint64_t v9 = &_swiftEmptyArrayStorage[8];
    do
    {
      __int16 v10 = *v9;
      __int128 v11 = *((_OWORD *)v9 - 1);
      *((_OWORD *)v8 - 2) = *((_OWORD *)v9 - 2);
      *((_OWORD *)v8 - 1) = v11;
      *uint64_t v8 = v10;
      v8 += 17;
      v9 += 17;
      --v7;
    }

    while (v7);
  }

  return swift_bridgeObjectRelease(_swiftEmptyArrayStorage);
}

uint64_t AWDLActionFrame.Header.init(from:)@<X0>(void *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v5 = a1[3];
  uint64_t v6 = a1[4];
  sub_100021104(a1, v5);
  dispatch thunk of Decoder.unkeyedContainer()(v19, v5, v6);
  if (!v2)
  {
    uint64_t v7 = v20;
    uint64_t v8 = v21;
    sub_1000237C8((uint64_t)v19, v20);
    uint64_t v9 = UnkeyedDecodingContainer.decodeData(with:)(72LL, v7, v8);
    uint64_t v11 = v9;
    unint64_t v12 = v10;
    sub_100209318(v9, v10);
    sub_1000208D8(v11, v12);
    __int128 v24 = v16;
    __int128 v25 = v17;
    uint64_t v26 = v18;
    __int128 v22 = v14;
    __int128 v23 = v15;
    sub_1000A1EAC(a2);
    sub_100002AC4(v19);
  }

  return sub_100002AC4(a1);
}

uint64_t sub_1000A4908@<X0>(void *a1@<X0>, uint64_t a2@<X8>)
{
  return AWDLActionFrame.Header.init(from:)(a1, a2);
}

unint64_t sub_1000A491C@<X0>(unint64_t result@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  int64_t v4 = *(unsigned __int8 *)(a2 + 5);
  if (*(_BYTE *)(a2 + 5))
  {
    unint64_t v5 = result;
    sub_100069808(0, v4, 0);
    uint64_t v6 = (unsigned int *)(v5 + 4);
    do
    {
      unsigned int v7 = *v6;
      v6 += 3;
      uint64_t result = sub_1001889D8(v7);
      unint64_t v8 = result;
      unint64_t v10 = _swiftEmptyArrayStorage[2];
      unint64_t v9 = _swiftEmptyArrayStorage[3];
      if (v10 >= v9 >> 1) {
        uint64_t result = sub_100069808(v9 > 1, v10 + 1, 1);
      }
      _swiftEmptyArrayStorage[2] = v10 + 1;
      uint64_t v11 = &_swiftEmptyArrayStorage[v10];
      *((_DWORD *)v11 + 8) = v8;
      *((_WORD *)v11 + 18) = WORD2(v8);
      --v4;
    }

    while (v4);
  }

  *a3 = _swiftEmptyArrayStorage;
  return result;
}

unint64_t sub_1000A49F8@<X0>(unint64_t result@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  int64_t v4 = *(unsigned __int8 *)(a2 + 5);
  if (*(_BYTE *)(a2 + 5))
  {
    unint64_t v5 = result;
    sub_100069808(0, v4, 0);
    uint64_t v6 = (unsigned int *)(v5 + 8);
    do
    {
      uint64_t result = sub_1000A810C(*(v6 - 1), *v6);
      unint64_t v7 = result;
      unint64_t v9 = _swiftEmptyArrayStorage[2];
      unint64_t v8 = _swiftEmptyArrayStorage[3];
      if (v9 >= v8 >> 1) {
        uint64_t result = sub_100069808(v8 > 1, v9 + 1, 1);
      }
      v6 += 3;
      _swiftEmptyArrayStorage[2] = v9 + 1;
      unint64_t v10 = &_swiftEmptyArrayStorage[v9];
      *((_DWORD *)v10 + 8) = v7;
      *((_WORD *)v10 + 18) = WORD2(v7);
      --v4;
    }

    while (v4);
  }

  *a3 = _swiftEmptyArrayStorage;
  return result;
}

BOOL static apple80211_p2p_airplay_statistics.== infix(_:_:)(_OWORD *a1, _OWORD *a2)
{
  __int128 v2 = a1[11];
  __s1[10] = a1[10];
  __s1[11] = v2;
  __s1[12] = a1[12];
  __int128 v3 = a1[7];
  __s1[6] = a1[6];
  __s1[7] = v3;
  __int128 v4 = a1[9];
  __s1[8] = a1[8];
  __s1[9] = v4;
  __int128 v5 = a1[3];
  __s1[2] = a1[2];
  __s1[3] = v5;
  __int128 v6 = a1[5];
  __s1[4] = a1[4];
  __s1[5] = v6;
  __int128 v7 = a1[1];
  __s1[0] = *a1;
  __s1[1] = v7;
  __int128 v8 = a2[11];
  v15[10] = a2[10];
  v15[11] = v8;
  v15[12] = a2[12];
  __int128 v9 = a2[7];
  v15[6] = a2[6];
  v15[7] = v9;
  __int128 v10 = a2[9];
  v15[8] = a2[8];
  v15[9] = v10;
  __int128 v11 = a2[3];
  v15[2] = a2[2];
  void v15[3] = v11;
  __int128 v12 = a2[5];
  _BYTE v15[4] = a2[4];
  v15[5] = v12;
  __int128 v13 = a2[1];
  v15[0] = *a2;
  v15[1] = v13;
  return memcmp(__s1, v15, 0xD0uLL) == 0;
}

BOOL static apple80211_awdl_low_latency_statistics.== infix(_:_:)(const void *a1, const void *a2)
{
  return memcmp(__dst, __s2, 0xFB0uLL) == 0;
}

unint64_t sub_1000A4C4C@<X0>(unsigned __int8 *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4 = type metadata accessor for DispatchTimeInterval(0LL);
  uint64_t v5 = *(void *)(v4 - 8);
  __chkstk_darwin(v4);
  __int128 v7 = (uint64_t *)((char *)&v25 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0LL));
  *(_WORD *)(a2 + 36) = 3;
  *(_DWORD *)(a2 + 32) = 0;
  *(_WORD *)(a2 + 44) = 3;
  *(_DWORD *)(a2 + 40) = 0;
  *(_WORD *)(a2 + 52) = 3;
  *(_DWORD *)(a2 + 48) = 0;
  *(_WORD *)(a2 + 60) = 3;
  *(_DWORD *)(a2 + 56) = 0;
  int v8 = *a1;
  __int16 v9 = a1[8];
  int v47 = a1[9];
  uint64_t v10 = *((int *)a1 + 3);
  uint64_t v11 = *((int *)a1 + 4);
  uint64_t v12 = *((unsigned int *)a1 + 5);
  unint64_t v46 = sub_1000A810C(*((_DWORD *)a1 + 7), *((_DWORD *)a1 + 8));
  unint64_t v45 = sub_1000A810C(*((_DWORD *)a1 + 10), *((_DWORD *)a1 + 11));
  unint64_t v44 = sub_1000A810C(*((_DWORD *)a1 + 13), *((_DWORD *)a1 + 14));
  unint64_t result = sub_1000A810C(*((_DWORD *)a1 + 16), *((_DWORD *)a1 + 17));
  uint64_t v14 = *((void *)a1 + 13);
  if (v14 < 0)
  {
    __break(1u);
  }

  else
  {
    int v43 = a1[96];
    uint64_t v42 = *((unsigned int *)a1 + 23);
    uint64_t v41 = *((unsigned int *)a1 + 22);
    *((void *)&v40 + 1) = *((unsigned int *)a1 + 21);
    *(void *)&__int128 v40 = *((unsigned int *)a1 + 20);
    *((void *)&v39 + 1) = *((unsigned int *)a1 + 19);
    *(void *)&__int128 v39 = *((unsigned int *)a1 + 18);
    *__int128 v7 = v14;
    __int128 v15 = *(void (**)(void *, void, uint64_t))(v5 + 104);
    unint64_t v27 = result;
    v15(v7, enum case for DispatchTimeInterval.seconds(_:), v4);
    uint64_t v34 = *((unsigned int *)a1 + 28);
    uint64_t v33 = *((unsigned int *)a1 + 29);
    uint64_t v32 = *((unsigned int *)a1 + 30);
    uint64_t v31 = *((unsigned int *)a1 + 31);
    uint64_t v30 = *((unsigned int *)a1 + 32);
    uint64_t v29 = *((unsigned int *)a1 + 33);
    uint64_t v28 = *((unsigned int *)a1 + 34);
    uint64_t v26 = *((unsigned int *)a1 + 35);
    HIDWORD(v25) = *((unsigned __int16 *)a1 + 72);
    uint64_t v37 = v12;
    uint64_t v38 = v11;
    char v16 = a1[146];
    char v17 = a1[147];
    char v18 = a1[148];
    int v36 = v8;
    char v19 = a1[149];
    uint64_t v35 = v10;
    char v20 = a1[150];
    char v21 = a1[151];
    uint64_t v22 = WiFiAddress.description.getter(*((unsigned __int16 *)a1 + 76) | ((unint64_t)*(unsigned int *)(a1 + 154) << 16));
    sub_1001460C4( v36,  v9 | ((_WORD)v47 << 8),  v35,  v38,  v37,  v46 & 0xFFFFFFFFFFFFLL,  v45 & 0xFFFFFFFFFFFFLL,  v44 & 0xFFFFFFFFFFFFLL,  a2,  *((double *)a1 + 23),  v27,  (v27 & 0xFFFFFFFFFFFFLL) >> 32,  v39,  v40,  v41,  v42,  v43,  (uint64_t)v7,  v34,  v33,  v32,  v31,  v30,  v29,  v28,  v26,  SWORD2(v25),  v16,  v17,  v18,  v19,  v20,  v21,  v22,  v23,  a1[158],  *((unsigned int *)a1 + 40),  *((unsigned int *)a1 + 41),  *((unsigned int *)a1 + 42),  *((unsigned int *)a1 + 43),  *((void *)a1 + 22));
    uint64_t v24 = type metadata accessor for AWDLStatistics.LowLatencyStatistics.Configuration(0LL);
    return (*(uint64_t (**)(uint64_t, void, uint64_t, uint64_t))(*(void *)(v24 - 8) + 56LL))( a2,  0LL,  1LL,  v24);
  }

  return result;
}

void *sub_1000A4F60(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 40);
  uint64_t v2 = *(void *)(a1 + 64);
  uint64_t v3 = *(void *)(a1 + 88);
  uint64_t v4 = *(void *)(a1 + 112);
  uint64_t v5 = *(void *)(a1 + 136);
  uint64_t v6 = *(void *)(a1 + 160);
  uint64_t v7 = *(void *)(a1 + 184);
  uint64_t v8 = *(void *)(a1 + 208);
  uint64_t v9 = *(void *)(a1 + 232);
  uint64_t v17 = *(void *)(a1 + 16);
  __int128 v18 = *(_OWORD *)(a1 + 24);
  uint64_t v19 = v1;
  __int128 v20 = *(_OWORD *)(a1 + 48);
  uint64_t v21 = v2;
  __int128 v22 = *(_OWORD *)(a1 + 72);
  uint64_t v23 = v3;
  __int128 v24 = *(_OWORD *)(a1 + 96);
  __int128 v26 = *(_OWORD *)(a1 + 120);
  uint64_t v25 = v4;
  uint64_t v27 = v5;
  __int128 v28 = *(_OWORD *)(a1 + 144);
  __int128 v30 = *(_OWORD *)(a1 + 168);
  uint64_t v29 = v6;
  uint64_t v31 = v7;
  __int128 v32 = *(_OWORD *)(a1 + 192);
  __int128 v34 = *(_OWORD *)(a1 + 216);
  uint64_t v33 = v8;
  uint64_t v35 = v9;
  sub_100069848(0, 10LL, 0);
  unint64_t result = _swiftEmptyArrayStorage;
  unint64_t v11 = _swiftEmptyArrayStorage[2];
  for (uint64_t i = 16LL; i != 256; i += 24LL)
  {
    uint64_t v13 = *(void *)&v16[i];
    __int128 v15 = result;
    unint64_t v14 = result[3];
    if (v11 >= v14 >> 1)
    {
      sub_100069848(v14 > 1, v11 + 1, 1);
      unint64_t result = v15;
    }

    result[2] = v11 + 1;
    result[v11++ + 4] = v13;
  }

  return result;
}

void *sub_1000A50E4(void *a1)
{
  uint64_t v1 = a1[2];
  uint64_t v2 = a1[5];
  uint64_t v3 = a1[8];
  uint64_t v4 = a1[11];
  uint64_t v5 = a1[14];
  uint64_t v6 = a1[17];
  sub_100069848(0, 6LL, 0);
  unint64_t result = _swiftEmptyArrayStorage;
  unint64_t v9 = _swiftEmptyArrayStorage[2];
  unint64_t v8 = _swiftEmptyArrayStorage[3];
  unint64_t v10 = v8 >> 1;
  unint64_t v11 = v9 + 1;
  if (v8 >> 1 <= v9)
  {
    sub_100069848(v8 > 1, v9 + 1, 1);
    unint64_t result = _swiftEmptyArrayStorage;
    unint64_t v8 = _swiftEmptyArrayStorage[3];
    unint64_t v10 = v8 >> 1;
  }

  _swiftEmptyArrayStorage[2] = v11;
  _swiftEmptyArrayStorage[v9 + 4] = v1;
  int64_t v12 = v9 + 2;
  if (v10 <= v11)
  {
    sub_100069848(v8 > 1, v12, 1);
    unint64_t result = _swiftEmptyArrayStorage;
  }

  _swiftEmptyArrayStorage[2] = v12;
  _swiftEmptyArrayStorage[v11 + 4] = v2;
  unint64_t v14 = _swiftEmptyArrayStorage[2];
  unint64_t v13 = _swiftEmptyArrayStorage[3];
  unint64_t v15 = v13 >> 1;
  unint64_t v16 = v14 + 1;
  if (v13 >> 1 <= v14)
  {
    sub_100069848(v13 > 1, v14 + 1, 1);
    unint64_t result = _swiftEmptyArrayStorage;
    unint64_t v13 = _swiftEmptyArrayStorage[3];
    unint64_t v15 = v13 >> 1;
  }

  _swiftEmptyArrayStorage[2] = v16;
  _swiftEmptyArrayStorage[v14 + 4] = v3;
  int64_t v17 = v14 + 2;
  if (v15 <= v16)
  {
    sub_100069848(v13 > 1, v17, 1);
    unint64_t result = _swiftEmptyArrayStorage;
  }

  _swiftEmptyArrayStorage[2] = v17;
  _swiftEmptyArrayStorage[v16 + 4] = v4;
  unint64_t v19 = _swiftEmptyArrayStorage[2];
  unint64_t v18 = _swiftEmptyArrayStorage[3];
  unint64_t v20 = v18 >> 1;
  unint64_t v21 = v19 + 1;
  if (v18 >> 1 <= v19)
  {
    sub_100069848(v18 > 1, v19 + 1, 1);
    unint64_t result = _swiftEmptyArrayStorage;
    unint64_t v18 = _swiftEmptyArrayStorage[3];
    unint64_t v20 = v18 >> 1;
  }

  _swiftEmptyArrayStorage[2] = v21;
  _swiftEmptyArrayStorage[v19 + 4] = v5;
  int64_t v22 = v19 + 2;
  if (v20 <= v21)
  {
    sub_100069848(v18 > 1, v22, 1);
    unint64_t result = _swiftEmptyArrayStorage;
  }

  _swiftEmptyArrayStorage[2] = v22;
  _swiftEmptyArrayStorage[v21 + 4] = v6;
  return result;
}

void *sub_1000A5320(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 40);
  uint64_t v2 = *(void *)(a1 + 64);
  uint64_t v3 = *(void *)(a1 + 88);
  uint64_t v4 = *(void *)(a1 + 112);
  uint64_t v5 = *(void *)(a1 + 136);
  uint64_t v6 = *(void *)(a1 + 160);
  uint64_t v7 = *(void *)(a1 + 184);
  uint64_t v8 = *(void *)(a1 + 208);
  uint64_t v16 = *(void *)(a1 + 16);
  __int128 v17 = *(_OWORD *)(a1 + 24);
  uint64_t v18 = v1;
  __int128 v19 = *(_OWORD *)(a1 + 48);
  uint64_t v20 = v2;
  __int128 v21 = *(_OWORD *)(a1 + 72);
  uint64_t v22 = v3;
  __int128 v23 = *(_OWORD *)(a1 + 96);
  __int128 v25 = *(_OWORD *)(a1 + 120);
  uint64_t v24 = v4;
  uint64_t v26 = v5;
  __int128 v27 = *(_OWORD *)(a1 + 144);
  __int128 v29 = *(_OWORD *)(a1 + 168);
  uint64_t v28 = v6;
  uint64_t v30 = v7;
  __int128 v31 = *(_OWORD *)(a1 + 192);
  uint64_t v32 = v8;
  sub_100069848(0, 9LL, 0);
  unint64_t result = _swiftEmptyArrayStorage;
  unint64_t v10 = _swiftEmptyArrayStorage[2];
  for (uint64_t i = 16LL; i != 232; i += 24LL)
  {
    uint64_t v12 = *(void *)&v15[i];
    unint64_t v14 = result;
    unint64_t v13 = result[3];
    if (v10 >= v13 >> 1)
    {
      sub_100069848(v13 > 1, v10 + 1, 1);
      unint64_t result = v14;
    }

    result[2] = v10 + 1;
    result[v10++ + 4] = v12;
  }

  return result;
}

void *sub_1000A5494(void *a1)
{
  uint64_t v1 = a1[2];
  uint64_t v2 = a1[5];
  uint64_t v3 = a1[8];
  uint64_t v4 = a1[11];
  sub_100069848(0, 4LL, 0);
  unint64_t result = _swiftEmptyArrayStorage;
  unint64_t v7 = _swiftEmptyArrayStorage[2];
  unint64_t v6 = _swiftEmptyArrayStorage[3];
  unint64_t v8 = v6 >> 1;
  unint64_t v9 = v7 + 1;
  if (v6 >> 1 <= v7)
  {
    sub_100069848(v6 > 1, v7 + 1, 1);
    unint64_t result = _swiftEmptyArrayStorage;
    unint64_t v6 = _swiftEmptyArrayStorage[3];
    unint64_t v8 = v6 >> 1;
  }

  _swiftEmptyArrayStorage[2] = v9;
  _swiftEmptyArrayStorage[v7 + 4] = v1;
  int64_t v10 = v7 + 2;
  if (v8 <= v9)
  {
    sub_100069848(v6 > 1, v10, 1);
    unint64_t result = _swiftEmptyArrayStorage;
  }

  _swiftEmptyArrayStorage[2] = v10;
  _swiftEmptyArrayStorage[v9 + 4] = v2;
  unint64_t v12 = _swiftEmptyArrayStorage[2];
  unint64_t v11 = _swiftEmptyArrayStorage[3];
  unint64_t v13 = v11 >> 1;
  unint64_t v14 = v12 + 1;
  if (v11 >> 1 <= v12)
  {
    sub_100069848(v11 > 1, v12 + 1, 1);
    unint64_t result = _swiftEmptyArrayStorage;
    unint64_t v11 = _swiftEmptyArrayStorage[3];
    unint64_t v13 = v11 >> 1;
  }

  _swiftEmptyArrayStorage[2] = v14;
  _swiftEmptyArrayStorage[v12 + 4] = v3;
  int64_t v15 = v12 + 2;
  if (v13 <= v14)
  {
    sub_100069848(v11 > 1, v15, 1);
    unint64_t result = _swiftEmptyArrayStorage;
  }

  _swiftEmptyArrayStorage[2] = v15;
  _swiftEmptyArrayStorage[v14 + 4] = v4;
  return result;
}

uint64_t sub_1000A5638()
{
  if (*(_BYTE *)(*(void *)v0 + 32LL) == 4)
  {
    if (qword_1004041A8 != -1) {
      swift_once(&qword_1004041A8, sub_100122F4C);
    }
    return (unsigned __int16)static CountryCode.unknown;
  }

  else
  {
    return (unsigned __int16)sub_1000A03B0(0x33uLL);
  }

uint64_t sub_1000A56DC( __int16 a1, uint64_t a2, uint64_t a3, uint64_t (*a4)(uint64_t, unint64_t))
{
  return a4(51LL, ((unint64_t)a1 << 32) | ((unint64_t)HIBYTE(a1) << 40));
}

uint64_t sub_1000A5710()
{
  return v0;
}

uint64_t sub_1000A5760( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t (*a5)(uint64_t, int *))
{
  if ((v16 & 1) != 0)
  {
    int v7 = 0;
    char v8 = 0;
    char v9 = 0;
    uint64_t v11 = v15[0];
    uint64_t v10 = v15[1];
    char v12 = 28;
    char v13 = 30;
  }

  else
  {
    uint64_t v11 = 0LL;
    uint64_t v10 = 0LL;
    char v13 = 0;
    char v12 = 0;
    char v9 = 16;
    int v7 = v15[0];
    char v8 = 2;
  }

  int v17 = 1;
  __int16 v18 = a1;
  char v19 = BYTE2(a1);
  char v20 = BYTE3(a1);
  char v21 = BYTE4(a1);
  char v22 = BYTE5(a1);
  char v23 = v9;
  char v24 = v8;
  __int16 v25 = 0;
  int v26 = v7;
  uint64_t v27 = 0LL;
  char v28 = v12;
  char v29 = v13;
  __int16 v30 = 0;
  int v31 = 0;
  uint64_t v32 = v11;
  uint64_t v33 = v10;
  int v34 = 0;
  return a5(450LL, &v17);
}

uint64_t sub_1000A5864( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t (*a5)(uint64_t, int *))
{
  if ((v16 & 1) != 0)
  {
    int v7 = 0;
    char v8 = 0;
    char v9 = 0;
    uint64_t v11 = v15[0];
    uint64_t v10 = v15[1];
    char v12 = 28;
    char v13 = 30;
  }

  else
  {
    uint64_t v11 = 0LL;
    uint64_t v10 = 0LL;
    char v13 = 0;
    char v12 = 0;
    char v9 = 16;
    int v7 = v15[0];
    char v8 = 2;
  }

  int v17 = 1;
  __int16 v18 = a1;
  char v19 = BYTE2(a1);
  char v20 = BYTE3(a1);
  char v21 = BYTE4(a1);
  char v22 = BYTE5(a1);
  char v23 = v9;
  char v24 = v8;
  __int16 v25 = 0;
  int v26 = v7;
  uint64_t v27 = 0LL;
  char v28 = v12;
  char v29 = v13;
  __int16 v30 = 0;
  int v31 = 0;
  uint64_t v32 = v11;
  uint64_t v33 = v10;
  int v34 = 0;
  return a5(451LL, &v17);
}

void sub_1000A5968(char a1)
{
  __asm { BR              X10 }

uint64_t sub_1000A5994( uint64_t a1, char a2, uint64_t a3, uint64_t a4, uint64_t (*a5)(uint64_t, uint64_t, uint64_t, void))
{
  return a5(503LL, ((a2 & 1) != 0) | 0x600000000LL, 1LL, 0LL);
}

uint64_t sub_1000A59D4(uint64_t a1, uint64_t a2)
{
  return sub_1000A5A20( a1,  a2,  (uint64_t (*)(_BYTE *, _BYTE *, _BYTE *))variable initialization expression of NANMatchingFilter.matchingFilterList);
}

uint64_t sub_1000A5A20(uint64_t a1, uint64_t a2, uint64_t (*a3)(_BYTE *, _BYTE *, _BYTE *))
{
  return a3(__src, v7, v5);
}

uint64_t sub_1000A5AF8(uint64_t a1, uint64_t a2)
{
  return sub_10009F5C0(a1, a2, (uint64_t (*)(void *))sub_1000AB0F8);
}

void *sub_1000A5B20(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return sub_1000A5B3C(a1, a2, a3, a4, (uint64_t (*)(void *))sub_1000AB0DC);
}

void *sub_1000A5B3C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t (*a5)(void *))
{
  uint64_t v8 = *v5;
  v7[2] = &v8;
  return sub_10003B82C(a5, (uint64_t)v7, a1, a2, &v8);
}

id sub_1000A5B78( void *a1, void *a2, uint64_t a3, uint64_t a4, void *a5, void *a6, void *a7, void *a8, void *a9, void *a10, void *a11, void *a12, void *a13, void *a14, void *a15, char a16, void *a17, void *a18, void *a19, void *a20, void *a21, void *a22, void *a23, void *a24, void *a25, void *a26, void *a27, void *a28, void *a29, void *a30, void *a31, void *a32, void *a33, void *a34, void *a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41)
{
  Class isa = Array._bridgeToObjectiveC()().super.isa;
  swift_bridgeObjectRelease(a3);
  Class v51 = Array._bridgeToObjectiveC()().super.isa;
  swift_bridgeObjectRelease(a4);
  NSString v46 = String._bridgeToObjectiveC()();
  swift_bridgeObjectRelease(a37);
  Class v47 = Array._bridgeToObjectiveC()().super.isa;
  swift_bridgeObjectRelease(a38);
  Class v48 = Array._bridgeToObjectiveC()().super.isa;
  swift_bridgeObjectRelease(a39);
  Class v49 = Array._bridgeToObjectiveC()().super.isa;
  swift_bridgeObjectRelease(a40);
  Class v50 = Array._bridgeToObjectiveC()().super.isa;
  swift_bridgeObjectRelease(a41);
  LOBYTE(v45) = a16;
  id v57 = [v56 initWithPeerAddress:a1 infrastructureChannel:a2 txCCAHistogram:isa rxRSSIHistogram:v51 preferred2GChannelsCount:a5 preferred5GC hannelsCount:a6 dfsChannelsCount:a7 csaCount:a8 quietIECount:a9 txErrorCount:a10 packetsOn2GCount:a11 packetsNAVOn2GCount:a12 packetsH OFOn2GCount:a13 packetsOn5GCount:a14 packetsOverridenOn5GCount:a15 infraRelayOperationStatus:v45 infraRelayRequestersCount:a17 txE xpiredCount:a18 txNoACKCount:a19 txFailedCount:a20 txNoResourcesCount:a21 txIOErrorCount:a22 txMemoryErrorCount:a23 txChipModeErrorCou nt:a24 txNoRemotePeerCount:a25 txInternalErrorCount:a26 txDroppedCount:a27 txFirmwareFreePacketCount:a28 txMaxRetriesCount:a29 txForce LifetimeExpiredCount:a30 channelSequenceMismatchOn5GCount:a31 channelSequenceMismatchOn2GCount:a32 infraScanCount:a33 infraAss ocCount:a34 infraDisassocCount:a35 countryCode:v46 txConsecutiveErrorsHistogram:v47 rxFWDelayHistogram:v48 rxIPCDelayHistogram:v49 txP acketExpiryHistogram:v50];

  return v57;
}

void *sub_1000A5F88(void *result, int64_t a2, char a3, void *a4)
{
  char v5 = (char)result;
  if ((a3 & 1) == 0)
  {
    uint64_t v7 = a2;
    goto LABEL_8;
  }

  unint64_t v6 = a4[3];
  uint64_t v7 = v6 >> 1;
  if (v7 + 0x4000000000000000LL >= 0)
  {
    uint64_t v7 = v6 & 0xFFFFFFFFFFFFFFFELL;
LABEL_8:
    uint64_t v8 = a4[2];
    if (v7 <= v8) {
      uint64_t v9 = a4[2];
    }
    else {
      uint64_t v9 = v7;
    }
    if (v9)
    {
      uint64_t v10 = sub_100002274(&qword_100406B50);
      uint64_t v11 = (void *)swift_allocObject(v10, 16 * v9 + 32, 7LL);
      int64_t v12 = j__malloc_size(v11);
      uint64_t v13 = v12 - 32;
      if (v12 < 32) {
        uint64_t v13 = v12 - 17;
      }
      v11[2] = v8;
      v11[3] = 2 * (v13 >> 4);
      unint64_t v14 = v11 + 4;
      if ((v5 & 1) != 0) {
        goto LABEL_15;
      }
    }

    else
    {
      uint64_t v11 = _swiftEmptyArrayStorage;
      unint64_t v14 = &_swiftEmptyArrayStorage[4];
      if ((result & 1) != 0)
      {
LABEL_15:
        if (v11 != a4 || v14 >= &a4[2 * v8 + 4]) {
          memmove(v14, a4 + 4, 16 * v8);
        }
        a4[2] = 0LL;
        goto LABEL_24;
      }
    }

    sub_1000A7E28(0LL, v8, (unint64_t)v14, (uint64_t)a4);
LABEL_24:
    swift_bridgeObjectRelease(a4);
    return v11;
  }

  __break(1u);
  return result;
}

void *sub_1000A6094(void *a1, int64_t a2, char a3, void *a4)
{
  return sub_1000A6EA4(a1, a2, a3, a4, &qword_1004040A8);
}

void *sub_1000A60A0(void *result, int64_t a2, char a3, void *a4)
{
  char v5 = (char)result;
  if ((a3 & 1) == 0)
  {
    uint64_t v7 = a2;
    goto LABEL_8;
  }

  unint64_t v6 = a4[3];
  uint64_t v7 = v6 >> 1;
  if (v7 + 0x4000000000000000LL >= 0)
  {
    uint64_t v7 = v6 & 0xFFFFFFFFFFFFFFFELL;
LABEL_8:
    uint64_t v8 = a4[2];
    if (v7 <= v8) {
      uint64_t v9 = a4[2];
    }
    else {
      uint64_t v9 = v7;
    }
    if (v9)
    {
      uint64_t v10 = sub_100002274((uint64_t *)&unk_10040CD70);
      uint64_t v11 = (void *)swift_allocObject(v10, 16 * v9 + 32, 7LL);
      int64_t v12 = j__malloc_size(v11);
      uint64_t v13 = v12 - 32;
      if (v12 < 32) {
        uint64_t v13 = v12 - 17;
      }
      v11[2] = v8;
      v11[3] = 2 * (v13 >> 4);
      unint64_t v14 = v11 + 4;
      if ((v5 & 1) != 0) {
        goto LABEL_15;
      }
    }

    else
    {
      uint64_t v11 = _swiftEmptyArrayStorage;
      unint64_t v14 = &_swiftEmptyArrayStorage[4];
      if ((result & 1) != 0)
      {
LABEL_15:
        if (v11 != a4 || v14 >= &a4[2 * v8 + 4]) {
          memmove(v14, a4 + 4, 16 * v8);
        }
        a4[2] = 0LL;
        goto LABEL_24;
      }
    }

    sub_1000A7F30(0LL, v8, (unint64_t)v14, (uint64_t)a4);
LABEL_24:
    swift_bridgeObjectRelease(a4);
    return v11;
  }

  __break(1u);
  return result;
}

void *sub_1000A61AC(void *result, int64_t a2, char a3, void *a4)
{
  char v5 = (char)result;
  if ((a3 & 1) == 0)
  {
    uint64_t v7 = a2;
    goto LABEL_8;
  }

  unint64_t v6 = a4[3];
  uint64_t v7 = v6 >> 1;
  if (v7 + 0x4000000000000000LL >= 0)
  {
    uint64_t v7 = v6 & 0xFFFFFFFFFFFFFFFELL;
LABEL_8:
    uint64_t v8 = a4[2];
    if (v7 <= v8) {
      uint64_t v9 = a4[2];
    }
    else {
      uint64_t v9 = v7;
    }
    if (v9)
    {
      uint64_t v10 = sub_100002274(&qword_100406B40);
      uint64_t v11 = (void *)swift_allocObject(v10, 16 * v9 + 32, 7LL);
      int64_t v12 = j__malloc_size(v11);
      uint64_t v13 = v12 - 32;
      if (v12 < 32) {
        uint64_t v13 = v12 - 17;
      }
      v11[2] = v8;
      v11[3] = 2 * (v13 >> 4);
      unint64_t v14 = v11 + 4;
      if ((v5 & 1) != 0) {
        goto LABEL_15;
      }
    }

    else
    {
      uint64_t v11 = _swiftEmptyArrayStorage;
      unint64_t v14 = &_swiftEmptyArrayStorage[4];
      if ((result & 1) != 0)
      {
LABEL_15:
        if (v11 != a4 || v14 >= &a4[2 * v8 + 4]) {
          memmove(v14, a4 + 4, 16 * v8);
        }
        a4[2] = 0LL;
        goto LABEL_24;
      }
    }

    sub_1000A7D20(0LL, v8, (unint64_t)v14, (uint64_t)a4);
LABEL_24:
    swift_bridgeObjectRelease(a4);
    return v11;
  }

  __break(1u);
  return result;
}

uint64_t sub_1000A62B8(char a1, int64_t a2, char a3, unint64_t a4)
{
  if ((a3 & 1) != 0)
  {
    unint64_t v6 = *(void *)(a4 + 24);
    uint64_t v7 = v6 >> 1;
    if ((uint64_t)(v6 >> 1) < a2)
    {
      if (v7 + 0x4000000000000000LL < 0)
      {
        __break(1u);
LABEL_29:
        uint64_t result = _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  "Division by zero",  16LL,  2LL,  "Swift/IntegerTypes.swift",  24LL,  2,  14377LL,  0);
LABEL_31:
        __break(1u);
        return result;
      }

      uint64_t v7 = v6 & 0xFFFFFFFFFFFFFFFELL;
    }
  }

  else
  {
    uint64_t v7 = a2;
  }

  uint64_t v8 = *(void *)(a4 + 16);
  if (v7 <= v8) {
    uint64_t v9 = *(void *)(a4 + 16);
  }
  else {
    uint64_t v9 = v7;
  }
  if (!v9)
  {
    int64_t v15 = _swiftEmptyArrayStorage;
    goto LABEL_19;
  }

  uint64_t v10 = sub_100002274(&qword_100406B60);
  uint64_t v11 = *(void *)(sub_100002274(&qword_100405120) - 8);
  uint64_t v12 = *(void *)(v11 + 72);
  uint64_t v13 = *(unsigned __int8 *)(v11 + 80);
  uint64_t v14 = (v13 + 32) & ~v13;
  int64_t v15 = (void *)swift_allocObject(v10, v14 + v12 * v9, v13 | 7);
  size_t v16 = j__malloc_size(v15);
  if (!v12) {
    goto LABEL_29;
  }
  if (v16 - v14 == 0x8000000000000000LL && v12 == -1)
  {
    uint64_t result = _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  "Division results in an overflow",  31LL,  2LL,  "Swift/IntegerTypes.swift",  24LL,  2,  14384LL,  0);
    goto LABEL_31;
  }

  v15[2] = v8;
  void v15[3] = 2 * ((uint64_t)(v16 - v14) / v12);
LABEL_19:
  uint64_t v18 = sub_100002274(&qword_100405120);
  uint64_t v19 = *(void *)(v18 - 8);
  unint64_t v20 = (*(unsigned __int8 *)(v19 + 80) + 32LL) & ~(unint64_t)*(unsigned __int8 *)(v19 + 80);
  unint64_t v21 = (unint64_t)v15 + v20;
  if ((a1 & 1) != 0)
  {
    unint64_t v22 = a4 + v20;
    if ((unint64_t)v15 < a4 || v21 >= v22 + *(void *)(v19 + 72) * v8)
    {
      swift_arrayInitWithTakeFrontToBack((char *)v15 + v20, v22, v8, v18);
    }

    else if (v15 != (void *)a4)
    {
      swift_arrayInitWithTakeBackToFront((char *)v15 + v20);
    }

    *(void *)(a4 + 16) = 0LL;
  }

  else
  {
    sub_1000A81B8(0LL, v8, v21, a4);
  }

  swift_bridgeObjectRelease(a4);
  return (uint64_t)v15;
}

void *sub_1000A64C8(void *result, int64_t a2, char a3, void *a4)
{
  char v5 = (char)result;
  if ((a3 & 1) == 0)
  {
    uint64_t v7 = a2;
    goto LABEL_8;
  }

  unint64_t v6 = a4[3];
  uint64_t v7 = v6 >> 1;
  if (v7 + 0x4000000000000000LL >= 0)
  {
    uint64_t v7 = v6 & 0xFFFFFFFFFFFFFFFELL;
LABEL_8:
    uint64_t v8 = a4[2];
    if (v7 <= v8) {
      uint64_t v9 = a4[2];
    }
    else {
      uint64_t v9 = v7;
    }
    if (v9)
    {
      uint64_t v10 = sub_100002274(&qword_100406B00);
      uint64_t v11 = (void *)swift_allocObject(v10, 6 * v9 + 32, 7LL);
      size_t v12 = j__malloc_size(v11);
      v11[2] = v8;
      v11[3] = 2 * ((uint64_t)(v12 - 32) / 6);
      uint64_t v13 = v11 + 4;
      if ((v5 & 1) != 0)
      {
LABEL_13:
        a4[2] = 0LL;
        goto LABEL_22;
      }
    }

    else
    {
      uint64_t v11 = _swiftEmptyArrayStorage;
      uint64_t v13 = &_swiftEmptyArrayStorage[4];
    }

    sub_1000A8020(0LL, v8, (char *)v13, (uint64_t)a4);
LABEL_22:
    swift_bridgeObjectRelease(a4);
    return v11;
  }

  __break(1u);
  return result;
}

void *sub_1000A65E8(void *result, int64_t a2, char a3, void *a4)
{
  char v5 = (char)result;
  if ((a3 & 1) == 0)
  {
    uint64_t v7 = a2;
    goto LABEL_8;
  }

  unint64_t v6 = a4[3];
  uint64_t v7 = v6 >> 1;
  if (v7 + 0x4000000000000000LL >= 0)
  {
    uint64_t v7 = v6 & 0xFFFFFFFFFFFFFFFELL;
LABEL_8:
    uint64_t v8 = a4[2];
    if (v7 <= v8) {
      uint64_t v9 = a4[2];
    }
    else {
      uint64_t v9 = v7;
    }
    if (v9)
    {
      uint64_t v10 = sub_100002274(&qword_10040F230);
      uint64_t v11 = (void *)swift_allocObject(v10, 8 * v9 + 32, 7LL);
      int64_t v12 = j__malloc_size(v11);
      uint64_t v13 = v12 - 32;
      if (v12 < 32) {
        uint64_t v13 = v12 - 25;
      }
      v11[2] = v8;
      v11[3] = 2 * (v13 >> 3);
      uint64_t v14 = v11 + 4;
      if ((v5 & 1) != 0) {
        goto LABEL_15;
      }
    }

    else
    {
      uint64_t v11 = _swiftEmptyArrayStorage;
      uint64_t v14 = &_swiftEmptyArrayStorage[4];
      if ((result & 1) != 0)
      {
LABEL_15:
        if (v11 != a4 || v14 >= &a4[v8 + 4]) {
          memmove(v14, a4 + 4, 8 * v8);
        }
        a4[2] = 0LL;
        goto LABEL_24;
      }
    }

    sub_1000A82D4(0LL, v8, (char *)v14, (uint64_t)a4);
LABEL_24:
    swift_bridgeObjectRelease(a4);
    return v11;
  }

  __break(1u);
  return result;
}

void *sub_1000A66F4(void *result, int64_t a2, char a3, void *a4)
{
  char v5 = (char)result;
  if ((a3 & 1) == 0)
  {
    uint64_t v7 = a2;
    goto LABEL_8;
  }

  unint64_t v6 = a4[3];
  uint64_t v7 = v6 >> 1;
  if (v7 + 0x4000000000000000LL >= 0)
  {
    uint64_t v7 = v6 & 0xFFFFFFFFFFFFFFFELL;
LABEL_8:
    uint64_t v8 = a4[2];
    if (v7 <= v8) {
      uint64_t v9 = a4[2];
    }
    else {
      uint64_t v9 = v7;
    }
    if (v9)
    {
      uint64_t v10 = sub_100002274(&qword_10040F260);
      uint64_t v11 = (void *)swift_allocObject(v10, 8 * v9 + 32, 7LL);
      int64_t v12 = j__malloc_size(v11);
      uint64_t v13 = v12 - 32;
      if (v12 < 32) {
        uint64_t v13 = v12 - 25;
      }
      v11[2] = v8;
      v11[3] = 2 * (v13 >> 3);
      uint64_t v14 = v11 + 4;
      if ((v5 & 1) != 0) {
        goto LABEL_15;
      }
    }

    else
    {
      uint64_t v11 = _swiftEmptyArrayStorage;
      uint64_t v14 = &_swiftEmptyArrayStorage[4];
      if ((result & 1) != 0)
      {
LABEL_15:
        if (v11 != a4 || v14 >= &a4[v8 + 4]) {
          memmove(v14, a4 + 4, 8 * v8);
        }
        a4[2] = 0LL;
        goto LABEL_24;
      }
    }

    sub_1000A82D4(0LL, v8, (char *)v14, (uint64_t)a4);
LABEL_24:
    swift_bridgeObjectRelease(a4);
    return v11;
  }

  __break(1u);
  return result;
}

void *sub_1000A6800(void *result, int64_t a2, char a3, void *a4)
{
  char v5 = (char)result;
  if ((a3 & 1) == 0)
  {
    uint64_t v7 = a2;
    goto LABEL_8;
  }

  unint64_t v6 = a4[3];
  uint64_t v7 = v6 >> 1;
  if (v7 + 0x4000000000000000LL >= 0)
  {
    uint64_t v7 = v6 & 0xFFFFFFFFFFFFFFFELL;
LABEL_8:
    uint64_t v8 = a4[2];
    if (v7 <= v8) {
      uint64_t v9 = a4[2];
    }
    else {
      uint64_t v9 = v7;
    }
    if (v9)
    {
      uint64_t v10 = sub_100002274(&qword_100406B78);
      uint64_t v11 = (void *)swift_allocObject(v10, 72 * v9 + 32, 7LL);
      size_t v12 = j__malloc_size(v11);
      v11[2] = v8;
      v11[3] = 2 * ((uint64_t)(v12 - 32) / 72);
      uint64_t v13 = v11 + 4;
      if ((v5 & 1) != 0)
      {
LABEL_13:
        if (v11 != a4 || v13 >= &a4[9 * v8 + 4]) {
          memmove(v13, a4 + 4, 72 * v8);
        }
        a4[2] = 0LL;
        goto LABEL_22;
      }
    }

    else
    {
      uint64_t v11 = _swiftEmptyArrayStorage;
      uint64_t v13 = &_swiftEmptyArrayStorage[4];
    }

    sub_1000A9C58(0LL, v8, (unint64_t)v13, (uint64_t)a4);
LABEL_22:
    swift_bridgeObjectRelease(a4);
    return v11;
  }

  __break(1u);
  return result;
}

void *sub_1000A6928(void *result, int64_t a2, char a3, void *a4)
{
  char v5 = (char)result;
  if ((a3 & 1) == 0)
  {
    uint64_t v7 = a2;
    goto LABEL_8;
  }

  unint64_t v6 = a4[3];
  uint64_t v7 = v6 >> 1;
  if (v7 + 0x4000000000000000LL >= 0)
  {
    uint64_t v7 = v6 & 0xFFFFFFFFFFFFFFFELL;
LABEL_8:
    uint64_t v8 = a4[2];
    if (v7 <= v8) {
      uint64_t v9 = a4[2];
    }
    else {
      uint64_t v9 = v7;
    }
    if (v9)
    {
      uint64_t v10 = sub_100002274(&qword_100406B70);
      uint64_t v11 = (void *)swift_allocObject(v10, 4 * v9 + 32, 7LL);
      int64_t v12 = j__malloc_size(v11);
      uint64_t v13 = v12 - 32;
      if (v12 < 32) {
        uint64_t v13 = v12 - 29;
      }
      v11[2] = v8;
      v11[3] = 2 * (v13 >> 2);
      uint64_t v14 = v11 + 4;
      if ((v5 & 1) != 0) {
        goto LABEL_15;
      }
    }

    else
    {
      uint64_t v11 = _swiftEmptyArrayStorage;
      uint64_t v14 = &_swiftEmptyArrayStorage[4];
      if ((result & 1) != 0)
      {
LABEL_15:
        a4[2] = 0LL;
        goto LABEL_24;
      }
    }

    sub_1000A9E3C(0LL, v8, (char *)v14, (uint64_t)a4);
LABEL_24:
    swift_bridgeObjectRelease(a4);
    return v11;
  }

  __break(1u);
  return result;
}

void *sub_1000A6A34(void *result, int64_t a2, char a3, void *a4)
{
  char v5 = (char)result;
  if ((a3 & 1) == 0)
  {
    uint64_t v7 = a2;
    goto LABEL_8;
  }

  unint64_t v6 = a4[3];
  uint64_t v7 = v6 >> 1;
  if (v7 + 0x4000000000000000LL >= 0)
  {
    uint64_t v7 = v6 & 0xFFFFFFFFFFFFFFFELL;
LABEL_8:
    uint64_t v8 = a4[2];
    if (v7 <= v8) {
      uint64_t v9 = a4[2];
    }
    else {
      uint64_t v9 = v7;
    }
    if (v9)
    {
      uint64_t v10 = sub_100002274((uint64_t *)&unk_100410470);
      uint64_t v11 = (void *)swift_allocObject(v10, 32 * v9 + 32, 7LL);
      int64_t v12 = j__malloc_size(v11);
      uint64_t v13 = v12 - 32;
      if (v12 < 32) {
        uint64_t v13 = v12 - 1;
      }
      v11[2] = v8;
      v11[3] = 2 * (v13 >> 5);
      uint64_t v14 = v11 + 4;
      if ((v5 & 1) != 0) {
        goto LABEL_15;
      }
    }

    else
    {
      uint64_t v11 = _swiftEmptyArrayStorage;
      uint64_t v14 = &_swiftEmptyArrayStorage[4];
      if ((result & 1) != 0)
      {
LABEL_15:
        if (v11 != a4 || v14 >= &a4[4 * v8 + 4]) {
          memmove(v14, a4 + 4, 32 * v8);
        }
        a4[2] = 0LL;
        goto LABEL_24;
      }
    }

    sub_1000A9F24(0LL, v8, (unint64_t)v14, (uint64_t)a4);
LABEL_24:
    swift_bridgeObjectRelease(a4);
    return v11;
  }

  __break(1u);
  return result;
}

uint64_t sub_1000A6B40(char a1, int64_t a2, char a3, unint64_t a4)
{
  return sub_1000A6B68(a1, a2, a3, a4, &qword_100406358, type metadata accessor for LongTermPairingKeys.PublicIdentity);
}

uint64_t sub_1000A6B54(char a1, int64_t a2, char a3, unint64_t a4)
{
  return sub_1000A6B68( a1,  a2,  a3,  a4,  &qword_100406B08,  (uint64_t (*)(void))&type metadata accessor for UUID);
}

uint64_t sub_1000A6B68( char a1, int64_t a2, char a3, unint64_t a4, uint64_t *a5, uint64_t (*a6)(void))
{
  if ((a3 & 1) != 0)
  {
    unint64_t v9 = *(void *)(a4 + 24);
    uint64_t v10 = v9 >> 1;
    if ((uint64_t)(v9 >> 1) < a2)
    {
      if (v10 + 0x4000000000000000LL < 0)
      {
        __break(1u);
LABEL_29:
        uint64_t result = _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  "Division by zero",  16LL,  2LL,  "Swift/IntegerTypes.swift",  24LL,  2,  14377LL,  0);
LABEL_31:
        __break(1u);
        return result;
      }

      uint64_t v10 = v9 & 0xFFFFFFFFFFFFFFFELL;
    }
  }

  else
  {
    uint64_t v10 = a2;
  }

  uint64_t v11 = *(void *)(a4 + 16);
  if (v10 <= v11) {
    uint64_t v12 = *(void *)(a4 + 16);
  }
  else {
    uint64_t v12 = v10;
  }
  if (!v12)
  {
    uint64_t v18 = _swiftEmptyArrayStorage;
    goto LABEL_19;
  }

  uint64_t v13 = sub_100002274(a5);
  uint64_t v14 = *(void *)(a6(0LL) - 8);
  uint64_t v15 = *(void *)(v14 + 72);
  uint64_t v16 = *(unsigned __int8 *)(v14 + 80);
  uint64_t v17 = (v16 + 32) & ~v16;
  uint64_t v18 = (void *)swift_allocObject(v13, v17 + v15 * v12, v16 | 7);
  size_t v19 = j__malloc_size(v18);
  if (!v15) {
    goto LABEL_29;
  }
  if (v19 - v17 == 0x8000000000000000LL && v15 == -1)
  {
    uint64_t result = _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  "Division results in an overflow",  31LL,  2LL,  "Swift/IntegerTypes.swift",  24LL,  2,  14384LL,  0);
    goto LABEL_31;
  }

  _BYTE v18[2] = v11;
  uint64_t v18[3] = 2 * ((uint64_t)(v19 - v17) / v15);
LABEL_19:
  uint64_t v21 = a6(0LL);
  uint64_t v22 = *(void *)(v21 - 8);
  unint64_t v23 = (*(unsigned __int8 *)(v22 + 80) + 32LL) & ~(unint64_t)*(unsigned __int8 *)(v22 + 80);
  unint64_t v24 = (unint64_t)v18 + v23;
  if ((a1 & 1) != 0)
  {
    unint64_t v25 = a4 + v23;
    if ((unint64_t)v18 < a4 || v24 >= v25 + *(void *)(v22 + 72) * v11)
    {
      swift_arrayInitWithTakeFrontToBack((char *)v18 + v23, v25, v11, v21);
    }

    else if (v18 != (void *)a4)
    {
      swift_arrayInitWithTakeBackToFront((char *)v18 + v23);
    }

    *(void *)(a4 + 16) = 0LL;
  }

  else
  {
    sub_1000AB5C8(0LL, v11, v24, a4, a6);
  }

  swift_bridgeObjectRelease(a4);
  return (uint64_t)v18;
}

void *sub_1000A6D74(void *result, int64_t a2, char a3, void *a4)
{
  char v5 = (char)result;
  if ((a3 & 1) == 0)
  {
    uint64_t v7 = a2;
    goto LABEL_8;
  }

  unint64_t v6 = a4[3];
  uint64_t v7 = v6 >> 1;
  if (v7 + 0x4000000000000000LL >= 0)
  {
    uint64_t v7 = v6 & 0xFFFFFFFFFFFFFFFELL;
LABEL_8:
    uint64_t v8 = a4[2];
    if (v7 <= v8) {
      uint64_t v9 = a4[2];
    }
    else {
      uint64_t v9 = v7;
    }
    if (v9)
    {
      uint64_t v10 = sub_100002274(&qword_100406B68);
      uint64_t v11 = (void *)swift_allocObject(v10, 24 * v9 + 32, 7LL);
      size_t v12 = j__malloc_size(v11);
      v11[2] = v8;
      v11[3] = 2 * ((uint64_t)(v12 - 32) / 24);
      uint64_t v13 = v11 + 4;
      if ((v5 & 1) != 0)
      {
LABEL_13:
        if (v11 != a4 || v13 >= &a4[3 * v8 + 4]) {
          memmove(v13, a4 + 4, 24 * v8);
        }
        a4[2] = 0LL;
        goto LABEL_22;
      }
    }

    else
    {
      uint64_t v11 = _swiftEmptyArrayStorage;
      uint64_t v13 = &_swiftEmptyArrayStorage[4];
    }

    sub_1000AA120(0LL, v8, (unint64_t)v13, (uint64_t)a4);
LABEL_22:
    swift_bridgeObjectRelease(a4);
    return v11;
  }

  __break(1u);
  return result;
}

void *sub_1000A6E98(void *a1, int64_t a2, char a3, void *a4)
{
  return sub_1000A6EA4(a1, a2, a3, a4, (uint64_t *)&unk_10040F280);
}

void *sub_1000A6EA4(void *result, int64_t a2, char a3, void *a4, uint64_t *a5)
{
  char v6 = (char)result;
  if ((a3 & 1) == 0)
  {
    int64_t v8 = a2;
    goto LABEL_8;
  }

  unint64_t v7 = a4[3];
  int64_t v8 = v7 >> 1;
  if (v8 + 0x4000000000000000LL >= 0)
  {
    int64_t v8 = v7 & 0xFFFFFFFFFFFFFFFELL;
LABEL_8:
    int64_t v9 = a4[2];
    if (v8 <= v9) {
      int64_t v10 = a4[2];
    }
    else {
      int64_t v10 = v8;
    }
    if (v10)
    {
      uint64_t v11 = sub_100002274(a5);
      size_t v12 = (void *)swift_allocObject(v11, v10 + 32, 7LL);
      size_t v13 = j__malloc_size(v12);
      v12[2] = v9;
      void v12[3] = 2 * v13 - 64;
      uint64_t v14 = v12 + 4;
      if ((v6 & 1) != 0)
      {
LABEL_13:
        a4[2] = 0LL;
        goto LABEL_22;
      }
    }

    else
    {
      size_t v12 = _swiftEmptyArrayStorage;
      uint64_t v14 = &_swiftEmptyArrayStorage[4];
    }

    sub_1000AA22C(0LL, v9, (char *)v14, (uint64_t)a4);
LABEL_22:
    swift_bridgeObjectRelease(a4);
    return v12;
  }

  __break(1u);
  return result;
}

void *sub_1000A6F98(void *result, int64_t a2, char a3, void *a4)
{
  char v5 = (char)result;
  if ((a3 & 1) == 0)
  {
    uint64_t v7 = a2;
    goto LABEL_8;
  }

  unint64_t v6 = a4[3];
  uint64_t v7 = v6 >> 1;
  if (v7 + 0x4000000000000000LL >= 0)
  {
    uint64_t v7 = v6 & 0xFFFFFFFFFFFFFFFELL;
LABEL_8:
    uint64_t v8 = a4[2];
    if (v7 <= v8) {
      uint64_t v9 = a4[2];
    }
    else {
      uint64_t v9 = v7;
    }
    if (v9)
    {
      uint64_t v10 = sub_100002274(&qword_10040F270);
      uint64_t v11 = (void *)swift_allocObject(v10, 10 * v9 + 32, 7LL);
      size_t v12 = j__malloc_size(v11);
      v11[2] = v8;
      v11[3] = 2 * ((uint64_t)(v12 - 32) / 10);
      size_t v13 = v11 + 4;
      if ((v5 & 1) != 0)
      {
LABEL_13:
        a4[2] = 0LL;
        goto LABEL_22;
      }
    }

    else
    {
      uint64_t v11 = _swiftEmptyArrayStorage;
      size_t v13 = &_swiftEmptyArrayStorage[4];
    }

    sub_1000AA310(0LL, v8, (char *)v13, (uint64_t)a4);
LABEL_22:
    swift_bridgeObjectRelease(a4);
    return v11;
  }

  __break(1u);
  return result;
}

void *sub_1000A70B4(void *result, int64_t a2, char a3, void *a4)
{
  char v5 = (char)result;
  if ((a3 & 1) == 0)
  {
    uint64_t v7 = a2;
    goto LABEL_8;
  }

  unint64_t v6 = a4[3];
  uint64_t v7 = v6 >> 1;
  if (v7 + 0x4000000000000000LL >= 0)
  {
    uint64_t v7 = v6 & 0xFFFFFFFFFFFFFFFELL;
LABEL_8:
    uint64_t v8 = a4[2];
    if (v7 <= v8) {
      uint64_t v9 = a4[2];
    }
    else {
      uint64_t v9 = v7;
    }
    if (v9)
    {
      uint64_t v10 = sub_100002274(&qword_100406B38);
      uint64_t v11 = (void *)swift_allocObject(v10, 56 * v9 + 32, 7LL);
      size_t v12 = j__malloc_size(v11);
      v11[2] = v8;
      v11[3] = 2 * ((uint64_t)(v12 - 32) / 56);
      size_t v13 = v11 + 4;
      if ((v5 & 1) != 0)
      {
LABEL_13:
        if (v11 != a4 || v13 >= &a4[7 * v8 + 4]) {
          memmove(v13, a4 + 4, 56 * v8);
        }
        a4[2] = 0LL;
        goto LABEL_22;
      }
    }

    else
    {
      uint64_t v11 = _swiftEmptyArrayStorage;
      size_t v13 = &_swiftEmptyArrayStorage[4];
    }

    sub_1000AA3FC(0LL, v8, (unint64_t)v13, (uint64_t)a4);
LABEL_22:
    swift_bridgeObjectRelease(a4);
    return v11;
  }

  __break(1u);
  return result;
}

void *sub_1000A71D8(void *result, int64_t a2, char a3, void *a4)
{
  char v5 = (char)result;
  if ((a3 & 1) == 0)
  {
    uint64_t v7 = a2;
    goto LABEL_8;
  }

  unint64_t v6 = a4[3];
  uint64_t v7 = v6 >> 1;
  if (v7 + 0x4000000000000000LL >= 0)
  {
    uint64_t v7 = v6 & 0xFFFFFFFFFFFFFFFELL;
LABEL_8:
    uint64_t v8 = a4[2];
    if (v7 <= v8) {
      uint64_t v9 = a4[2];
    }
    else {
      uint64_t v9 = v7;
    }
    if (v9)
    {
      uint64_t v10 = sub_100002274((uint64_t *)&unk_10040F250);
      uint64_t v11 = (void *)swift_allocObject(v10, 16 * v9 + 32, 7LL);
      int64_t v12 = j__malloc_size(v11);
      uint64_t v13 = v12 - 32;
      if (v12 < 32) {
        uint64_t v13 = v12 - 17;
      }
      v11[2] = v8;
      v11[3] = 2 * (v13 >> 4);
      uint64_t v14 = v11 + 4;
      if ((v5 & 1) != 0) {
        goto LABEL_15;
      }
    }

    else
    {
      uint64_t v11 = _swiftEmptyArrayStorage;
      uint64_t v14 = &_swiftEmptyArrayStorage[4];
      if ((result & 1) != 0)
      {
LABEL_15:
        if (v11 != a4 || v14 >= &a4[2 * v8 + 4]) {
          memmove(v14, a4 + 4, 16 * v8);
        }
        a4[2] = 0LL;
        goto LABEL_24;
      }
    }

    sub_1000AA4F0(0LL, v8, (unint64_t)v14, (uint64_t)a4);
LABEL_24:
    swift_bridgeObjectRelease(a4);
    return v11;
  }

  __break(1u);
  return result;
}

void *sub_1000A72E4(void *result, int64_t a2, char a3, void *a4)
{
  char v5 = (char)result;
  if ((a3 & 1) == 0)
  {
    uint64_t v7 = a2;
    goto LABEL_8;
  }

  unint64_t v6 = a4[3];
  uint64_t v7 = v6 >> 1;
  if (v7 + 0x4000000000000000LL >= 0)
  {
    uint64_t v7 = v6 & 0xFFFFFFFFFFFFFFFELL;
LABEL_8:
    uint64_t v8 = a4[2];
    if (v7 <= v8) {
      uint64_t v9 = a4[2];
    }
    else {
      uint64_t v9 = v7;
    }
    if (v9)
    {
      uint64_t v10 = sub_100002274(&qword_1004063F8);
      uint64_t v11 = (void *)swift_allocObject(v10, 2 * v9 + 32, 7LL);
      int64_t v12 = j__malloc_size(v11);
      int64_t v13 = v12 - 32;
      if (v12 < 32) {
        int64_t v13 = v12 - 31;
      }
      v11[2] = v8;
      v11[3] = v13 & 0xFFFFFFFFFFFFFFFELL;
      uint64_t v14 = v11 + 4;
      if ((v5 & 1) != 0) {
        goto LABEL_15;
      }
    }

    else
    {
      uint64_t v11 = _swiftEmptyArrayStorage;
      uint64_t v14 = &_swiftEmptyArrayStorage[4];
      if ((result & 1) != 0)
      {
LABEL_15:
        a4[2] = 0LL;
        goto LABEL_24;
      }
    }

    sub_1000AA6CC(0LL, v8, (char *)v14, (uint64_t)a4);
LABEL_24:
    swift_bridgeObjectRelease(a4);
    return v11;
  }

  __break(1u);
  return result;
}

void *sub_1000A73EC(void *result, int64_t a2, char a3, void *a4)
{
  char v5 = (char)result;
  if ((a3 & 1) == 0)
  {
    uint64_t v7 = a2;
    goto LABEL_8;
  }

  unint64_t v6 = a4[3];
  uint64_t v7 = v6 >> 1;
  if (v7 + 0x4000000000000000LL >= 0)
  {
    uint64_t v7 = v6 & 0xFFFFFFFFFFFFFFFELL;
LABEL_8:
    uint64_t v8 = a4[2];
    if (v7 <= v8) {
      uint64_t v9 = a4[2];
    }
    else {
      uint64_t v9 = v7;
    }
    if (v9)
    {
      uint64_t v10 = sub_100002274(&qword_100406410);
      uint64_t v11 = (void *)swift_allocObject(v10, 16 * v9 + 32, 7LL);
      int64_t v12 = j__malloc_size(v11);
      uint64_t v13 = v12 - 32;
      if (v12 < 32) {
        uint64_t v13 = v12 - 17;
      }
      v11[2] = v8;
      v11[3] = 2 * (v13 >> 4);
      uint64_t v14 = v11 + 4;
      if ((v5 & 1) != 0) {
        goto LABEL_15;
      }
    }

    else
    {
      uint64_t v11 = _swiftEmptyArrayStorage;
      uint64_t v14 = &_swiftEmptyArrayStorage[4];
      if ((result & 1) != 0)
      {
LABEL_15:
        if (v11 != a4 || v14 >= &a4[2 * v8 + 4]) {
          memmove(v14, a4 + 4, 16 * v8);
        }
        a4[2] = 0LL;
        goto LABEL_24;
      }
    }

    sub_1000A9D4C(0LL, v8, (unint64_t)v14, (uint64_t)a4);
LABEL_24:
    swift_bridgeObjectRelease(a4);
    return v11;
  }

  __break(1u);
  return result;
}

void *sub_1000A74F8(void *result, int64_t a2, char a3, void *a4)
{
  char v5 = (char)result;
  if ((a3 & 1) == 0)
  {
    uint64_t v7 = a2;
    goto LABEL_8;
  }

  unint64_t v6 = a4[3];
  uint64_t v7 = v6 >> 1;
  if (v7 + 0x4000000000000000LL >= 0)
  {
    uint64_t v7 = v6 & 0xFFFFFFFFFFFFFFFELL;
LABEL_8:
    uint64_t v8 = a4[2];
    if (v7 <= v8) {
      uint64_t v9 = a4[2];
    }
    else {
      uint64_t v9 = v7;
    }
    if (v9)
    {
      uint64_t v10 = sub_100002274(&qword_100406B10);
      uint64_t v11 = (void *)swift_allocObject(v10, 16 * v9 + 32, 7LL);
      int64_t v12 = j__malloc_size(v11);
      uint64_t v13 = v12 - 32;
      if (v12 < 32) {
        uint64_t v13 = v12 - 17;
      }
      v11[2] = v8;
      v11[3] = 2 * (v13 >> 4);
      uint64_t v14 = v11 + 4;
      if ((v5 & 1) != 0) {
        goto LABEL_15;
      }
    }

    else
    {
      uint64_t v11 = _swiftEmptyArrayStorage;
      uint64_t v14 = &_swiftEmptyArrayStorage[4];
      if ((result & 1) != 0)
      {
LABEL_15:
        if (v11 != a4 || v14 >= &a4[2 * v8 + 4]) {
          memmove(v14, a4 + 4, 16 * v8);
        }
        a4[2] = 0LL;
        goto LABEL_24;
      }
    }

    sub_1000AB4C0(0LL, v8, (unint64_t)v14, (uint64_t)a4);
LABEL_24:
    swift_bridgeObjectRelease(a4);
    return v11;
  }

  __break(1u);
  return result;
}

void *sub_1000A7604(void *result, int64_t a2, char a3, void *a4)
{
  char v5 = (char)result;
  if ((a3 & 1) == 0)
  {
    uint64_t v7 = a2;
    goto LABEL_8;
  }

  unint64_t v6 = a4[3];
  uint64_t v7 = v6 >> 1;
  if (v7 + 0x4000000000000000LL >= 0)
  {
    uint64_t v7 = v6 & 0xFFFFFFFFFFFFFFFELL;
LABEL_8:
    uint64_t v8 = a4[2];
    if (v7 <= v8) {
      uint64_t v9 = a4[2];
    }
    else {
      uint64_t v9 = v7;
    }
    if (v9)
    {
      uint64_t v10 = sub_100002274(&qword_1004063E0);
      uint64_t v11 = (void *)swift_allocObject(v10, 24 * v9 + 32, 7LL);
      size_t v12 = j__malloc_size(v11);
      v11[2] = v8;
      v11[3] = 2 * ((uint64_t)(v12 - 32) / 24);
      uint64_t v13 = v11 + 4;
      if ((v5 & 1) != 0)
      {
LABEL_13:
        if (v11 != a4 || v13 >= &a4[3 * v8 + 4]) {
          memmove(v13, a4 + 4, 24 * v8);
        }
        a4[2] = 0LL;
        goto LABEL_22;
      }
    }

    else
    {
      uint64_t v11 = _swiftEmptyArrayStorage;
      uint64_t v13 = &_swiftEmptyArrayStorage[4];
    }

    sub_1000AA014(0LL, v8, (unint64_t)v13, (uint64_t)a4);
LABEL_22:
    swift_bridgeObjectRelease(a4);
    return v11;
  }

  __break(1u);
  return result;
}

void *sub_1000A7728(void *result, int64_t a2, char a3, void *a4)
{
  char v5 = (char)result;
  if ((a3 & 1) == 0)
  {
    uint64_t v7 = a2;
    goto LABEL_8;
  }

  unint64_t v6 = a4[3];
  uint64_t v7 = v6 >> 1;
  if (v7 + 0x4000000000000000LL >= 0)
  {
    uint64_t v7 = v6 & 0xFFFFFFFFFFFFFFFELL;
LABEL_8:
    uint64_t v8 = a4[2];
    if (v7 <= v8) {
      uint64_t v9 = a4[2];
    }
    else {
      uint64_t v9 = v7;
    }
    if (v9)
    {
      uint64_t v10 = sub_100002274(&qword_100406400);
      uint64_t v11 = (void *)swift_allocObject(v10, 8 * v9 + 32, 7LL);
      int64_t v12 = j__malloc_size(v11);
      uint64_t v13 = v12 - 32;
      if (v12 < 32) {
        uint64_t v13 = v12 - 25;
      }
      v11[2] = v8;
      v11[3] = 2 * (v13 >> 3);
      uint64_t v14 = v11 + 4;
      if ((v5 & 1) != 0) {
        goto LABEL_15;
      }
    }

    else
    {
      uint64_t v11 = _swiftEmptyArrayStorage;
      uint64_t v14 = &_swiftEmptyArrayStorage[4];
      if ((result & 1) != 0)
      {
LABEL_15:
        if (v11 != a4 || v14 >= &a4[v8 + 4]) {
          memmove(v14, a4 + 4, 8 * v8);
        }
        a4[2] = 0LL;
        goto LABEL_24;
      }
    }

    sub_1000AB7EC(0LL, v8, (unint64_t)v14, (uint64_t)a4);
LABEL_24:
    swift_bridgeObjectRelease(a4);
    return v11;
  }

  __break(1u);
  return result;
}

void *sub_1000A7834(void *result, int64_t a2, char a3, void *a4)
{
  char v5 = (char)result;
  if ((a3 & 1) == 0)
  {
    uint64_t v7 = a2;
    goto LABEL_8;
  }

  unint64_t v6 = a4[3];
  uint64_t v7 = v6 >> 1;
  if (v7 + 0x4000000000000000LL >= 0)
  {
    uint64_t v7 = v6 & 0xFFFFFFFFFFFFFFFELL;
LABEL_8:
    uint64_t v8 = a4[2];
    if (v7 <= v8) {
      uint64_t v9 = a4[2];
    }
    else {
      uint64_t v9 = v7;
    }
    if (v9)
    {
      uint64_t v10 = sub_100002274(qword_100405EA0);
      uint64_t v11 = (void *)swift_allocObject(v10, 48 * v9 + 32, 7LL);
      size_t v12 = j__malloc_size(v11);
      v11[2] = v8;
      v11[3] = 2 * ((uint64_t)(v12 - 32) / 48);
      uint64_t v13 = v11 + 4;
      if ((v5 & 1) != 0)
      {
LABEL_13:
        if (v11 != a4 || v13 >= &a4[6 * v8 + 4]) {
          memmove(v13, a4 + 4, 48 * v8);
        }
        a4[2] = 0LL;
        goto LABEL_22;
      }
    }

    else
    {
      uint64_t v11 = _swiftEmptyArrayStorage;
      uint64_t v13 = &_swiftEmptyArrayStorage[4];
    }

    sub_1000AB8F4(0LL, v8, (unint64_t)v13, (uint64_t)a4);
LABEL_22:
    swift_bridgeObjectRelease(a4);
    return v11;
  }

  __break(1u);
  return result;
}

uint64_t sub_1000A7958(char a1, int64_t a2, char a3, unint64_t a4)
{
  return sub_1000A6B68(a1, a2, a3, a4, &qword_10040D7E0, type metadata accessor for NANAttribute);
}

void *sub_1000A796C(void *result, int64_t a2, char a3, void *a4)
{
  char v5 = (char)result;
  if ((a3 & 1) == 0)
  {
    uint64_t v7 = a2;
    goto LABEL_8;
  }

  unint64_t v6 = a4[3];
  uint64_t v7 = v6 >> 1;
  if (v7 + 0x4000000000000000LL >= 0)
  {
    uint64_t v7 = v6 & 0xFFFFFFFFFFFFFFFELL;
LABEL_8:
    uint64_t v8 = a4[2];
    if (v7 <= v8) {
      uint64_t v9 = a4[2];
    }
    else {
      uint64_t v9 = v7;
    }
    if (v9)
    {
      uint64_t v10 = sub_100002274(&qword_100406138);
      uint64_t v11 = (void *)swift_allocObject(v10, 8 * v9 + 32, 7LL);
      int64_t v12 = j__malloc_size(v11);
      uint64_t v13 = v12 - 32;
      if (v12 < 32) {
        uint64_t v13 = v12 - 25;
      }
      v11[2] = v8;
      v11[3] = 2 * (v13 >> 3);
      uint64_t v14 = v11 + 4;
      if ((v5 & 1) != 0) {
        goto LABEL_15;
      }
    }

    else
    {
      uint64_t v11 = _swiftEmptyArrayStorage;
      uint64_t v14 = &_swiftEmptyArrayStorage[4];
      if ((result & 1) != 0)
      {
LABEL_15:
        if (v11 != a4 || v14 >= &a4[v8 + 4]) {
          memmove(v14, a4 + 4, 8 * v8);
        }
        a4[2] = 0LL;
        goto LABEL_24;
      }
    }

    sub_1000ABAF0(0LL, v8, (unint64_t)v14, (uint64_t)a4);
LABEL_24:
    swift_bridgeObjectRelease(a4);
    return v11;
  }

  __break(1u);
  return result;
}

void *sub_1000A7A78(void *result, int64_t a2, char a3, void *a4)
{
  char v5 = (char)result;
  if ((a3 & 1) == 0)
  {
    uint64_t v7 = a2;
    goto LABEL_8;
  }

  unint64_t v6 = a4[3];
  uint64_t v7 = v6 >> 1;
  if (v7 + 0x4000000000000000LL >= 0)
  {
    uint64_t v7 = v6 & 0xFFFFFFFFFFFFFFFELL;
LABEL_8:
    uint64_t v8 = a4[2];
    if (v7 <= v8) {
      uint64_t v9 = a4[2];
    }
    else {
      uint64_t v9 = v7;
    }
    if (v9)
    {
      uint64_t v10 = sub_100002274(&qword_100406388);
      uint64_t v11 = (void *)swift_allocObject(v10, 32 * v9 + 32, 7LL);
      int64_t v12 = j__malloc_size(v11);
      uint64_t v13 = v12 - 32;
      if (v12 < 32) {
        uint64_t v13 = v12 - 1;
      }
      v11[2] = v8;
      v11[3] = 2 * (v13 >> 5);
      uint64_t v14 = v11 + 4;
      if ((v5 & 1) != 0) {
        goto LABEL_15;
      }
    }

    else
    {
      uint64_t v11 = _swiftEmptyArrayStorage;
      uint64_t v14 = &_swiftEmptyArrayStorage[4];
      if ((result & 1) != 0)
      {
LABEL_15:
        if (v11 != a4 || v14 >= &a4[4 * v8 + 4]) {
          memmove(v14, a4 + 4, 32 * v8);
        }
        a4[2] = 0LL;
        goto LABEL_24;
      }
    }

    sub_1000ABA00(0LL, v8, (unint64_t)v14, (uint64_t)a4);
LABEL_24:
    swift_bridgeObjectRelease(a4);
    return v11;
  }

  __break(1u);
  return result;
}

void *sub_1000A7B84(void *result, int64_t a2, char a3, void *a4)
{
  char v5 = (char)result;
  if ((a3 & 1) == 0)
  {
    uint64_t v7 = a2;
    goto LABEL_8;
  }

  unint64_t v6 = a4[3];
  uint64_t v7 = v6 >> 1;
  if (v7 + 0x4000000000000000LL >= 0)
  {
    uint64_t v7 = v6 & 0xFFFFFFFFFFFFFFFELL;
LABEL_8:
    uint64_t v8 = a4[2];
    if (v7 <= v8) {
      uint64_t v9 = a4[2];
    }
    else {
      uint64_t v9 = v7;
    }
    if (v9)
    {
      uint64_t v10 = sub_100002274(&qword_100406AF0);
      uint64_t v11 = (void *)swift_allocObject(v10, 24 * v9 + 32, 7LL);
      size_t v12 = j__malloc_size(v11);
      v11[2] = v8;
      v11[3] = 2 * ((uint64_t)(v12 - 32) / 24);
      uint64_t v13 = v11 + 4;
      if ((v5 & 1) != 0)
      {
LABEL_13:
        if (v11 != a4 || v13 >= &a4[3 * v8 + 4]) {
          memmove(v13, a4 + 4, 24 * v8);
        }
        a4[2] = 0LL;
        goto LABEL_22;
      }
    }

    else
    {
      uint64_t v11 = _swiftEmptyArrayStorage;
      uint64_t v13 = &_swiftEmptyArrayStorage[4];
    }

    sub_1000AB6E0(0LL, v8, (unint64_t)v13, (uint64_t)a4);
LABEL_22:
    swift_bridgeObjectRelease(a4);
    return v11;
  }

  __break(1u);
  return result;
}

unint64_t sub_1000A7CA8(unint64_t result)
{
  if ((result & 0x8000000000000000LL) != 0)
  {
    __break(1u);
  }

  else
  {
    unint64_t v1 = result;
    if (result)
    {
      uint64_t v2 = sub_100002274(&qword_1004050A8);
      uint64_t v3 = (void *)static Array._allocateBufferUninitialized(minimumCapacity:)(v1, v2);
      v3[2] = v1;
    }

    else
    {
      uint64_t v3 = _swiftEmptyArrayStorage;
    }

    sub_100002274(&qword_1004050A8);
    return (unint64_t)v3;
  }

  return result;
}

uint64_t sub_1000A7D20(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  uint64_t v4 = a2 - a1;
  if (__OFSUB__(a2, a1))
  {
    __break(1u);
  }

  else
  {
    if (v4 < 0)
    {
      uint64_t result = _fatalErrorMessage(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  "UnsafeMutablePointer.initialize with negative count",  51LL,  2LL,  "Swift/UnsafePointer.swift",  25LL,  2,  1090LL,  0);
      goto LABEL_9;
    }

    unint64_t v6 = a4 + 16 * a1 + 32;
    unint64_t v7 = a3 + 16 * v4;
    if (v6 >= v7 || v6 + 16 * v4 <= a3)
    {
      sub_100002274(&qword_100406B48);
      swift_arrayInitWithCopy(a3);
      return v7;
    }
  }

  uint64_t result = _fatalErrorMessage(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  "UnsafeMutablePointer.initialize overlapping range",  49LL,  2LL,  "Swift/UnsafePointer.swift",  25LL,  2,  1092LL,  0);
LABEL_9:
  __break(1u);
  return result;
}

uint64_t sub_1000A7E28(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  uint64_t v4 = a2 - a1;
  if (__OFSUB__(a2, a1))
  {
    __break(1u);
  }

  else
  {
    if (v4 < 0)
    {
      uint64_t result = _fatalErrorMessage(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  "UnsafeMutablePointer.initialize with negative count",  51LL,  2LL,  "Swift/UnsafePointer.swift",  25LL,  2,  1090LL,  0);
      goto LABEL_9;
    }

    unint64_t v6 = a4 + 16 * a1 + 32;
    unint64_t v7 = a3 + 16 * v4;
    if (v6 >= v7 || v6 + 16 * v4 <= a3)
    {
      sub_100002274(&qword_100406B58);
      swift_arrayInitWithCopy(a3);
      return v7;
    }
  }

  uint64_t result = _fatalErrorMessage(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  "UnsafeMutablePointer.initialize overlapping range",  49LL,  2LL,  "Swift/UnsafePointer.swift",  25LL,  2,  1092LL,  0);
LABEL_9:
  __break(1u);
  return result;
}

uint64_t sub_1000A7F30(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  uint64_t v4 = a2 - a1;
  if (__OFSUB__(a2, a1))
  {
    __break(1u);
  }

  else
  {
    if (v4 < 0)
    {
      uint64_t result = _fatalErrorMessage(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  "UnsafeMutablePointer.initialize with negative count",  51LL,  2LL,  "Swift/UnsafePointer.swift",  25LL,  2,  1090LL,  0);
      goto LABEL_9;
    }

    unint64_t v5 = a4 + 16 * a1 + 32;
    unint64_t v6 = a3 + 16 * v4;
    if (v5 >= v6 || v5 + 16 * v4 <= a3)
    {
      swift_arrayInitWithCopy(a3);
      return v6;
    }
  }

  uint64_t result = _fatalErrorMessage(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  "UnsafeMutablePointer.initialize overlapping range",  49LL,  2LL,  "Swift/UnsafePointer.swift",  25LL,  2,  1092LL,  0);
LABEL_9:
  __break(1u);
  return result;
}

char *sub_1000A8020(uint64_t a1, uint64_t a2, char *__dst, uint64_t a4)
{
  uint64_t v4 = a2 - a1;
  if (__OFSUB__(a2, a1))
  {
    __break(1u);
    goto LABEL_9;
  }

  if (v4 < 0)
  {
LABEL_9:
    uint64_t result = (char *)_fatalErrorMessage(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  "UnsafeMutablePointer.initialize with negative count",  51LL,  2LL,  "Swift/UnsafePointer.swift",  25LL,  2,  1090LL,  0);
    goto LABEL_11;
  }

  unint64_t v5 = (char *)(a4 + 6 * a1 + 32);
  size_t v6 = 6 * v4;
  unint64_t v7 = &__dst[v6];
  if (v5 >= &__dst[v6] || &v5[v6] <= __dst)
  {
    memcpy(__dst, v5, v6);
    return v7;
  }

  uint64_t result = (char *)_fatalErrorMessage(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  "UnsafeMutablePointer.initialize overlapping range",  49LL,  2LL,  "Swift/UnsafePointer.swift",  25LL,  2,  1092LL,  0);
LABEL_11:
  __break(1u);
  return result;
}

unint64_t sub_1000A810C(unsigned int a1, unsigned int a2)
{
  if ((a2 & 0x800) != 0) {
    char v2 = 5;
  }
  else {
    char v2 = 3;
  }
  if ((a2 & 0x400) != 0) {
    LOBYTE(v3) = 4;
  }
  else {
    LOBYTE(v3) = v2;
  }
  if ((a2 & 4) != 0) {
    int v3 = (a2 >> 9) & 1;
  }
  if ((a2 & 2) != 0) {
    char v4 = 3;
  }
  else {
    char v4 = v3;
  }
  if ((a2 & 1) != 0) {
    char v5 = 2;
  }
  else {
    char v5 = v4;
  }
  if ((a2 & 8) != 0)
  {
    char v7 = 0;
  }

  else if ((a2 & 0x10) != 0)
  {
    char v7 = 1;
  }

  else
  {
    if ((a2 & 0x2000) == 0) {
      return 0x300000000LL;
    }
    char v7 = 2;
  }

  unsigned __int8 v9 = v7;
  unsigned __int8 v10 = v5;
  sub_100185C58();
  return a1 | ((unint64_t)v9 << 32) | ((unint64_t)v10 << 40);
}

uint64_t sub_1000A81B8(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  uint64_t v4 = a2 - a1;
  if (__OFSUB__(a2, a1))
  {
    __break(1u);
    goto LABEL_9;
  }

  if (v4 < 0)
  {
LABEL_9:
    uint64_t result = _fatalErrorMessage(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  "UnsafeMutablePointer.initialize with negative count",  51LL,  2LL,  "Swift/UnsafePointer.swift",  25LL,  2,  1090LL,  0);
    goto LABEL_11;
  }

  uint64_t v8 = *(void *)(sub_100002274(&qword_100405120) - 8);
  uint64_t v9 = *(unsigned __int8 *)(v8 + 80);
  uint64_t v10 = *(void *)(v8 + 72);
  unint64_t v11 = a4 + ((v9 + 32) & ~v9) + v10 * a1;
  uint64_t v12 = v10 * v4;
  unint64_t v13 = a3 + v12;
  unint64_t v14 = v11 + v12;
  if (v11 >= v13 || v14 <= a3)
  {
    swift_arrayInitWithCopy(a3);
    return v13;
  }

  uint64_t result = _fatalErrorMessage(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  "UnsafeMutablePointer.initialize overlapping range",  49LL,  2LL,  "Swift/UnsafePointer.swift",  25LL,  2,  1092LL,  0);
LABEL_11:
  __break(1u);
  return result;
}

char *sub_1000A82D4(uint64_t a1, uint64_t a2, char *__dst, uint64_t a4)
{
  uint64_t v4 = a2 - a1;
  if (__OFSUB__(a2, a1))
  {
    __break(1u);
  }

  else
  {
    if (v4 < 0)
    {
      uint64_t result = (char *)_fatalErrorMessage(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  "UnsafeMutablePointer.initialize with negative count",  51LL,  2LL,  "Swift/UnsafePointer.swift",  25LL,  2,  1090LL,  0);
      goto LABEL_9;
    }

    char v5 = (char *)(a4 + 8 * a1 + 32);
    size_t v6 = 8 * v4;
    char v7 = &__dst[v6];
    if (v5 >= &__dst[v6] || &v5[v6] <= __dst)
    {
      memcpy(__dst, v5, v6);
      return v7;
    }
  }

  uint64_t result = (char *)_fatalErrorMessage(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  "UnsafeMutablePointer.initialize overlapping range",  49LL,  2LL,  "Swift/UnsafePointer.swift",  25LL,  2,  1092LL,  0);
LABEL_9:
  __break(1u);
  return result;
}

uint64_t sub_1000A83BC@<X0>(__int128 *a1@<X0>, uint64_t a2@<X8>)
{
  __int128 v3 = a1[3];
  __int128 v187 = a1[2];
  __int128 v188 = v3;
  __int128 v189 = a1[4];
  __int128 v4 = a1[1];
  __int128 v185 = *a1;
  __int128 v186 = v4;
  sub_100069848(0, 10LL, 0);
  uint64_t v5 = 0LL;
  unint64_t v6 = _swiftEmptyArrayStorage[2];
  do
  {
    uint64_t v7 = *(void *)((char *)&v185 + v5);
    unint64_t v8 = _swiftEmptyArrayStorage[3];
    if (v6 >= v8 >> 1) {
      sub_100069848(v8 > 1, v6 + 1, 1);
    }
    _swiftEmptyArrayStorage[2] = v6 + 1;
    _swiftEmptyArrayStorage[v6 + 4] = v7;
    v5 += 8LL;
    ++v6;
  }

  while (v5 != 80);
  __int128 v9 = a1[8];
  __int128 v187 = a1[7];
  __int128 v188 = v9;
  __int128 v189 = a1[9];
  __int128 v10 = a1[6];
  __int128 v185 = a1[5];
  __int128 v186 = v10;
  sub_100069848(0, 10LL, 0);
  uint64_t v11 = 0LL;
  uint64_t v12 = _swiftEmptyArrayStorage;
  unint64_t v13 = _swiftEmptyArrayStorage[2];
  do
  {
    uint64_t v14 = *(void *)((char *)&v185 + v11);
    uint64_t v178 = v12;
    unint64_t v15 = v12[3];
    if (v13 >= v15 >> 1)
    {
      sub_100069848(v15 > 1, v13 + 1, 1);
      uint64_t v12 = v178;
    }

    v12[2] = v13 + 1;
    v12[v13 + 4] = v14;
    v11 += 8LL;
    ++v13;
  }

  while (v11 != 80);
  __int128 v177 = v12;
  __int128 v16 = a1[13];
  __int128 v187 = a1[12];
  __int128 v188 = v16;
  __int128 v189 = a1[14];
  __int128 v17 = a1[11];
  __int128 v185 = a1[10];
  __int128 v186 = v17;
  sub_100069848(0, 10LL, 0);
  uint64_t v18 = 0LL;
  size_t v19 = _swiftEmptyArrayStorage;
  unint64_t v20 = _swiftEmptyArrayStorage[2];
  do
  {
    uint64_t v21 = *(void *)((char *)&v185 + v18);
    uint64_t v179 = v19;
    unint64_t v22 = v19[3];
    if (v20 >= v22 >> 1)
    {
      sub_100069848(v22 > 1, v20 + 1, 1);
      size_t v19 = v179;
    }

    __int128 v19[2] = v20 + 1;
    v19[v20 + 4] = v21;
    v18 += 8LL;
    ++v20;
  }

  while (v18 != 80);
  uint64_t v176 = v19;
  __int128 v23 = a1[18];
  __int128 v187 = a1[17];
  __int128 v188 = v23;
  __int128 v189 = a1[19];
  __int128 v24 = a1[16];
  __int128 v185 = a1[15];
  __int128 v186 = v24;
  sub_100069848(0, 10LL, 0);
  uint64_t v25 = 0LL;
  int v26 = _swiftEmptyArrayStorage;
  unint64_t v27 = _swiftEmptyArrayStorage[2];
  do
  {
    uint64_t v28 = *(void *)((char *)&v185 + v25);
    __int128 v180 = v26;
    unint64_t v29 = v26[3];
    if (v27 >= v29 >> 1)
    {
      sub_100069848(v29 > 1, v27 + 1, 1);
      int v26 = v180;
    }

    v26[2] = v27 + 1;
    v26[v27 + 4] = v28;
    v25 += 8LL;
    ++v27;
  }

  while (v25 != 80);
  uint64_t v175 = v26;
  __int128 v30 = a1[23];
  __int128 v187 = a1[22];
  __int128 v188 = v30;
  __int128 v189 = a1[24];
  __int128 v31 = a1[21];
  __int128 v185 = a1[20];
  __int128 v186 = v31;
  sub_100069848(0, 10LL, 0);
  uint64_t v32 = 0LL;
  uint64_t v33 = _swiftEmptyArrayStorage;
  unint64_t v34 = _swiftEmptyArrayStorage[2];
  do
  {
    uint64_t v35 = *(void *)((char *)&v185 + v32);
    uint64_t v181 = v33;
    unint64_t v36 = v33[3];
    if (v34 >= v36 >> 1)
    {
      sub_100069848(v36 > 1, v34 + 1, 1);
      uint64_t v33 = v181;
    }

    v33[2] = v34 + 1;
    v33[v34 + 4] = v35;
    v32 += 8LL;
    ++v34;
  }

  while (v32 != 80);
  __int128 v174 = v33;
  __int128 v37 = a1[28];
  __int128 v187 = a1[27];
  __int128 v188 = v37;
  __int128 v189 = a1[29];
  __int128 v38 = a1[26];
  __int128 v185 = a1[25];
  __int128 v186 = v38;
  sub_100069848(0, 10LL, 0);
  uint64_t v39 = 0LL;
  __int128 v40 = _swiftEmptyArrayStorage;
  unint64_t v41 = _swiftEmptyArrayStorage[2];
  do
  {
    uint64_t v42 = *(void *)((char *)&v185 + v39);
    uint64_t v182 = v40;
    unint64_t v43 = v40[3];
    if (v41 >= v43 >> 1)
    {
      sub_100069848(v43 > 1, v41 + 1, 1);
      __int128 v40 = v182;
    }

    v40[2] = v41 + 1;
    v40[v41 + 4] = v42;
    v39 += 8LL;
    ++v41;
  }

  while (v39 != 80);
  uint64_t v173 = v40;
  uint64_t v45 = *((void *)a1 + 60);
  uint64_t v44 = *((void *)a1 + 61);
  uint64_t v47 = *((void *)a1 + 62);
  uint64_t v46 = *((void *)a1 + 63);
  uint64_t v48 = *((void *)a1 + 64);
  uint64_t v49 = *((void *)a1 + 65);
  *(void *)&__int128 v185 = _swiftEmptyArrayStorage;
  sub_100069848(0, 6LL, 0);
  uint64_t v50 = v185;
  unint64_t v52 = *(void *)(v185 + 16);
  unint64_t v51 = *(void *)(v185 + 24);
  unint64_t v53 = v51 >> 1;
  unint64_t v54 = v52 + 1;
  if (v51 >> 1 <= v52)
  {
    sub_100069848(v51 > 1, v52 + 1, 1);
    uint64_t v50 = v185;
    unint64_t v51 = *(void *)(v185 + 24);
    unint64_t v53 = v51 >> 1;
  }

  *(void *)(v50 + 16) = v54;
  *(void *)(v50 + 8 * v52 + 32) = v45;
  *(void *)&__int128 v185 = v50;
  if (v53 <= v54)
  {
    sub_100069848(v51 > 1, v52 + 2, 1);
    uint64_t v50 = v185;
  }

  *(void *)(v50 + 16) = v52 + 2;
  *(void *)(v50 + 8 * v54 + 32) = v44;
  *(void *)&__int128 v185 = v50;
  unint64_t v56 = *(void *)(v50 + 16);
  unint64_t v55 = *(void *)(v50 + 24);
  unint64_t v57 = v55 >> 1;
  unint64_t v58 = v56 + 1;
  if (v55 >> 1 <= v56)
  {
    sub_100069848(v55 > 1, v56 + 1, 1);
    uint64_t v50 = v185;
    unint64_t v55 = *(void *)(v185 + 24);
    unint64_t v57 = v55 >> 1;
  }

  *(void *)(v50 + 16) = v58;
  *(void *)(v50 + 8 * v56 + 32) = v47;
  *(void *)&__int128 v185 = v50;
  if (v57 <= v58)
  {
    sub_100069848(v55 > 1, v56 + 2, 1);
    uint64_t v50 = v185;
  }

  *(void *)(v50 + 16) = v56 + 2;
  *(void *)(v50 + 8 * v58 + 32) = v46;
  *(void *)&__int128 v185 = v50;
  unint64_t v60 = *(void *)(v50 + 16);
  unint64_t v59 = *(void *)(v50 + 24);
  unint64_t v61 = v59 >> 1;
  unint64_t v62 = v60 + 1;
  if (v59 >> 1 <= v60)
  {
    sub_100069848(v59 > 1, v60 + 1, 1);
    uint64_t v50 = v185;
    unint64_t v59 = *(void *)(v185 + 24);
    unint64_t v61 = v59 >> 1;
  }

  *(void *)(v50 + 16) = v62;
  *(void *)(v50 + 8 * v60 + 32) = v48;
  *(void *)&__int128 v185 = v50;
  if (v61 <= v62)
  {
    sub_100069848(v59 > 1, v60 + 2, 1);
    uint64_t v50 = v185;
  }

  *(void *)(v50 + 16) = v60 + 2;
  uint64_t v172 = v50;
  *(void *)(v50 + 8 * v62 + 32) = v49;
  __int128 v63 = a1[36];
  __int128 v187 = a1[35];
  __int128 v188 = v63;
  *(void *)&__int128 v189 = *((void *)a1 + 74);
  __int128 v64 = a1[34];
  __int128 v185 = a1[33];
  __int128 v186 = v64;
  sub_100069848(0, 9LL, 0);
  uint64_t v65 = 0LL;
  char v66 = _swiftEmptyArrayStorage;
  unint64_t v67 = _swiftEmptyArrayStorage[2];
  do
  {
    uint64_t v68 = *(void *)((char *)&v185 + v65);
    __int128 v183 = v66;
    unint64_t v69 = v66[3];
    if (v67 >= v69 >> 1)
    {
      sub_100069848(v69 > 1, v67 + 1, 1);
      char v66 = v183;
    }

    v66[2] = v67 + 1;
    v66[v67 + 4] = v68;
    v65 += 8LL;
    ++v67;
  }

  while (v65 != 72);
  __int128 v171 = v66;
  __int128 v70 = *(__int128 *)((char *)a1 + 648);
  __int128 v187 = *(__int128 *)((char *)a1 + 632);
  __int128 v188 = v70;
  *(void *)&__int128 v189 = *((void *)a1 + 83);
  __int128 v71 = *(__int128 *)((char *)a1 + 616);
  __int128 v185 = *(__int128 *)((char *)a1 + 600);
  __int128 v186 = v71;
  sub_100069848(0, 9LL, 0);
  uint64_t v72 = 0LL;
  uint64_t v73 = _swiftEmptyArrayStorage;
  unint64_t v74 = _swiftEmptyArrayStorage[2];
  do
  {
    uint64_t v75 = *(void *)((char *)&v185 + v72);
    uint64_t v184 = v73;
    unint64_t v76 = v73[3];
    if (v74 >= v76 >> 1)
    {
      sub_100069848(v76 > 1, v74 + 1, 1);
      uint64_t v73 = v184;
    }

    v73[2] = v74 + 1;
    v73[v74 + 4] = v75;
    v72 += 8LL;
    ++v74;
  }

  while (v72 != 72);
  uint64_t v170 = v73;
  uint64_t v77 = *((void *)a1 + 84);
  uint64_t v78 = *((void *)a1 + 85);
  uint64_t v79 = *((void *)a1 + 86);
  uint64_t v80 = *((void *)a1 + 87);
  *(void *)&__int128 v185 = _swiftEmptyArrayStorage;
  sub_100069848(0, 4LL, 0);
  uint64_t v81 = v185;
  unint64_t v83 = *(void *)(v185 + 16);
  unint64_t v82 = *(void *)(v185 + 24);
  unint64_t v84 = v82 >> 1;
  unint64_t v85 = v83 + 1;
  if (v82 >> 1 <= v83)
  {
    sub_100069848(v82 > 1, v83 + 1, 1);
    uint64_t v81 = v185;
    unint64_t v82 = *(void *)(v185 + 24);
    unint64_t v84 = v82 >> 1;
  }

  *(void *)(v81 + 16) = v85;
  *(void *)(v81 + 8 * v83 + 32) = v77;
  *(void *)&__int128 v185 = v81;
  int64_t v86 = v83 + 2;
  if (v84 <= v85)
  {
    sub_100069848(v82 > 1, v86, 1);
    uint64_t v81 = v185;
  }

  *(void *)(v81 + 16) = v86;
  *(void *)(v81 + 8 * v85 + 32) = v78;
  *(void *)&__int128 v185 = v81;
  unint64_t v88 = *(void *)(v81 + 16);
  unint64_t v87 = *(void *)(v81 + 24);
  unint64_t v89 = v87 >> 1;
  unint64_t v90 = v88 + 1;
  if (v87 >> 1 <= v88)
  {
    sub_100069848(v87 > 1, v88 + 1, 1);
    uint64_t v81 = v185;
    unint64_t v87 = *(void *)(v185 + 24);
    unint64_t v89 = v87 >> 1;
  }

  *(void *)(v81 + 16) = v90;
  *(void *)(v81 + 8 * v88 + 32) = v79;
  *(void *)&__int128 v185 = v81;
  int64_t v91 = v88 + 2;
  if (v89 <= v90)
  {
    sub_100069848(v87 > 1, v91, 1);
    uint64_t v81 = v185;
  }

  *(void *)(v81 + 16) = v91;
  uint64_t v169 = v81;
  *(void *)(v81 + 8 * v90 + 32) = v80;
  uint64_t v92 = *((void *)a1 + 88);
  uint64_t v93 = *((void *)a1 + 89);
  uint64_t v94 = *((void *)a1 + 90);
  uint64_t v95 = *((void *)a1 + 91);
  uint64_t v96 = *((void *)a1 + 92);
  *(void *)&__int128 v185 = _swiftEmptyArrayStorage;
  sub_100069848(0, 5LL, 0);
  uint64_t v97 = v185;
  unint64_t v99 = *(void *)(v185 + 16);
  unint64_t v98 = *(void *)(v185 + 24);
  unint64_t v100 = v98 >> 1;
  unint64_t v101 = v99 + 1;
  if (v98 >> 1 <= v99)
  {
    sub_100069848(v98 > 1, v99 + 1, 1);
    uint64_t v97 = v185;
    unint64_t v98 = *(void *)(v185 + 24);
    unint64_t v100 = v98 >> 1;
  }

  *(void *)(v97 + 16) = v101;
  *(void *)(v97 + 8 * v99 + 32) = v92;
  *(void *)&__int128 v185 = v97;
  int64_t v102 = v99 + 2;
  if (v100 <= v101)
  {
    sub_100069848(v98 > 1, v102, 1);
    uint64_t v97 = v185;
  }

  *(void *)(v97 + 16) = v102;
  *(void *)(v97 + 8 * v101 + 32) = v93;
  *(void *)&__int128 v185 = v97;
  unint64_t v104 = *(void *)(v97 + 16);
  unint64_t v103 = *(void *)(v97 + 24);
  unint64_t v105 = v103 >> 1;
  unint64_t v106 = v104 + 1;
  if (v103 >> 1 <= v104)
  {
    sub_100069848(v103 > 1, v104 + 1, 1);
    uint64_t v97 = v185;
    unint64_t v103 = *(void *)(v185 + 24);
    unint64_t v105 = v103 >> 1;
  }

  *(void *)(v97 + 16) = v106;
  *(void *)(v97 + 8 * v104 + 32) = v94;
  *(void *)&__int128 v185 = v97;
  int64_t v107 = v104 + 2;
  if (v105 <= v106)
  {
    sub_100069848(v103 > 1, v107, 1);
    uint64_t v97 = v185;
  }

  *(void *)(v97 + 16) = v107;
  *(void *)(v97 + 8 * v106 + 32) = v95;
  *(void *)&__int128 v185 = v97;
  unint64_t v109 = *(void *)(v97 + 16);
  unint64_t v108 = *(void *)(v97 + 24);
  if (v109 >= v108 >> 1)
  {
    sub_100069848(v108 > 1, v109 + 1, 1);
    uint64_t v97 = v185;
  }

  *(void *)(v97 + 16) = v109 + 1;
  uint64_t v168 = v97;
  *(void *)(v97 + 8 * v109 + 32) = v96;
  __int128 v110 = *(__int128 *)((char *)a1 + 792);
  __int128 v187 = *(__int128 *)((char *)a1 + 776);
  __int128 v188 = v110;
  __int128 v189 = *(__int128 *)((char *)a1 + 808);
  __int128 v111 = *(__int128 *)((char *)a1 + 760);
  __int128 v185 = *(__int128 *)((char *)a1 + 744);
  __int128 v186 = v111;
  sub_100069848(0, 10LL, 0);
  uint64_t v112 = 0LL;
  unint64_t v113 = _swiftEmptyArrayStorage[2];
  do
  {
    uint64_t v114 = *(void *)((char *)&v185 + v112);
    unint64_t v115 = _swiftEmptyArrayStorage[3];
    if (v113 >= v115 >> 1) {
      sub_100069848(v115 > 1, v113 + 1, 1);
    }
    _swiftEmptyArrayStorage[2] = v113 + 1;
    _swiftEmptyArrayStorage[v113 + 4] = v114;
    v112 += 8LL;
    ++v113;
  }

  while (v112 != 80);
  uint64_t v116 = *((void *)a1 + 103);
  uint64_t v117 = *((void *)a1 + 104);
  uint64_t v118 = *((void *)a1 + 105);
  *(void *)&__int128 v185 = _swiftEmptyArrayStorage;
  sub_100069848(0, 3LL, 0);
  uint64_t v119 = v185;
  unint64_t v121 = *(void *)(v185 + 16);
  unint64_t v120 = *(void *)(v185 + 24);
  unint64_t v122 = v120 >> 1;
  unint64_t v123 = v121 + 1;
  if (v120 >> 1 <= v121)
  {
    sub_100069848(v120 > 1, v121 + 1, 1);
    uint64_t v119 = v185;
    unint64_t v120 = *(void *)(v185 + 24);
    unint64_t v122 = v120 >> 1;
  }

  *(void *)(v119 + 16) = v123;
  *(void *)(v119 + 8 * v121 + 32) = v116;
  *(void *)&__int128 v185 = v119;
  int64_t v124 = v121 + 2;
  if (v122 <= v123)
  {
    sub_100069848(v120 > 1, v124, 1);
    uint64_t v119 = v185;
  }

  *(void *)(v119 + 16) = v124;
  *(void *)(v119 + 8 * v123 + 32) = v117;
  *(void *)&__int128 v185 = v119;
  unint64_t v126 = *(void *)(v119 + 16);
  unint64_t v125 = *(void *)(v119 + 24);
  if (v126 >= v125 >> 1)
  {
    sub_100069848(v125 > 1, v126 + 1, 1);
    uint64_t v119 = v185;
  }

  *(void *)(v119 + 16) = v126 + 1;
  uint64_t v167 = v119;
  *(void *)(v119 + 8 * v126 + 32) = v118;
  __int128 v127 = a1[56];
  __int128 v187 = a1[55];
  __int128 v188 = v127;
  __int128 v189 = a1[57];
  __int128 v128 = a1[54];
  __int128 v185 = a1[53];
  __int128 v186 = v128;
  sub_100069848(0, 10LL, 0);
  uint64_t v129 = 0LL;
  unint64_t v130 = _swiftEmptyArrayStorage[2];
  do
  {
    uint64_t v131 = *(void *)((char *)&v185 + v129);
    unint64_t v132 = _swiftEmptyArrayStorage[3];
    if (v130 >= v132 >> 1) {
      sub_100069848(v132 > 1, v130 + 1, 1);
    }
    _swiftEmptyArrayStorage[2] = v130 + 1;
    _swiftEmptyArrayStorage[v130 + 4] = v131;
    v129 += 8LL;
    ++v130;
  }

  while (v129 != 80);
  __int128 v133 = a1[61];
  __int128 v187 = a1[60];
  __int128 v188 = v133;
  __int128 v189 = a1[62];
  __int128 v134 = a1[59];
  __int128 v185 = a1[58];
  __int128 v186 = v134;
  sub_100069848(0, 10LL, 0);
  uint64_t v135 = 0LL;
  unint64_t v136 = _swiftEmptyArrayStorage[2];
  do
  {
    uint64_t v137 = *(void *)((char *)&v185 + v135);
    unint64_t v138 = _swiftEmptyArrayStorage[3];
    if (v136 >= v138 >> 1) {
      sub_100069848(v138 > 1, v136 + 1, 1);
    }
    _swiftEmptyArrayStorage[2] = v136 + 1;
    _swiftEmptyArrayStorage[v136 + 4] = v137;
    v135 += 8LL;
    ++v136;
  }

  while (v135 != 80);
  __int128 v139 = a1[66];
  __int128 v187 = a1[65];
  __int128 v188 = v139;
  __int128 v189 = a1[67];
  __int128 v140 = a1[64];
  __int128 v185 = a1[63];
  __int128 v186 = v140;
  sub_100069848(0, 10LL, 0);
  uint64_t v141 = 0LL;
  unint64_t v142 = _swiftEmptyArrayStorage[2];
  do
  {
    uint64_t v143 = *(void *)((char *)&v185 + v141);
    unint64_t v144 = _swiftEmptyArrayStorage[3];
    if (v142 >= v144 >> 1) {
      sub_100069848(v144 > 1, v142 + 1, 1);
    }
    _swiftEmptyArrayStorage[2] = v142 + 1;
    _swiftEmptyArrayStorage[v142 + 4] = v143;
    v141 += 8LL;
    ++v142;
  }

  while (v141 != 80);
  __int128 v145 = a1[69];
  __int128 v146 = a1[71];
  __int128 v187 = a1[70];
  __int128 v188 = v146;
  __int128 v189 = a1[72];
  __int128 v185 = a1[68];
  __int128 v186 = v145;
  sub_100069848(0, 10LL, 0);
  uint64_t v147 = 0LL;
  unint64_t v148 = _swiftEmptyArrayStorage[2];
  do
  {
    uint64_t v149 = *(void *)((char *)&v185 + v147);
    unint64_t v150 = _swiftEmptyArrayStorage[3];
    if (v148 >= v150 >> 1) {
      sub_100069848(v150 > 1, v148 + 1, 1);
    }
    _swiftEmptyArrayStorage[2] = v148 + 1;
    _swiftEmptyArrayStorage[v148 + 4] = v149;
    v147 += 8LL;
    ++v148;
  }

  while (v147 != 80);
  uint64_t v151 = *((void *)a1 + 146);
  uint64_t v152 = *((void *)a1 + 147);
  uint64_t v153 = *((void *)a1 + 148);
  uint64_t v154 = *((void *)a1 + 149);
  sub_100069848(0, 4LL, 0);
  unint64_t v156 = _swiftEmptyArrayStorage[2];
  unint64_t v155 = _swiftEmptyArrayStorage[3];
  unint64_t v157 = v155 >> 1;
  unint64_t v158 = v156 + 1;
  if (v155 >> 1 <= v156)
  {
    sub_100069848(v155 > 1, v156 + 1, 1);
    unint64_t v155 = _swiftEmptyArrayStorage[3];
    unint64_t v157 = v155 >> 1;
  }

  _swiftEmptyArrayStorage[2] = v158;
  _swiftEmptyArrayStorage[v156 + 4] = v151;
  int64_t v159 = v156 + 2;
  if (v157 <= v158) {
    sub_100069848(v155 > 1, v159, 1);
  }
  _swiftEmptyArrayStorage[2] = v159;
  _swiftEmptyArrayStorage[v158 + 4] = v152;
  unint64_t v161 = _swiftEmptyArrayStorage[2];
  unint64_t v160 = _swiftEmptyArrayStorage[3];
  unint64_t v162 = v160 >> 1;
  unint64_t v163 = v161 + 1;
  if (v160 >> 1 <= v161)
  {
    sub_100069848(v160 > 1, v161 + 1, 1);
    unint64_t v160 = _swiftEmptyArrayStorage[3];
    unint64_t v162 = v160 >> 1;
  }

  _swiftEmptyArrayStorage[2] = v163;
  _swiftEmptyArrayStorage[v161 + 4] = v153;
  int64_t v164 = v161 + 2;
  if (v162 <= v163) {
    sub_100069848(v160 > 1, v164, 1);
  }
  _swiftEmptyArrayStorage[2] = v164;
  _swiftEmptyArrayStorage[v163 + 4] = v154;
  *(void *)&__int128 v185 = _swiftEmptyArrayStorage;
  *((void *)&v185 + 1) = v177;
  *(void *)&__int128 v186 = v176;
  *((void *)&v186 + 1) = v175;
  *(void *)&__int128 v187 = v174;
  *((void *)&v187 + 1) = v173;
  *(void *)&__int128 v188 = v172;
  *((void *)&v188 + 1) = v171;
  *(void *)&__int128 v189 = v170;
  *((void *)&v189 + 1) = v169;
  uint64_t v190 = v168;
  uint64_t v191 = _swiftEmptyArrayStorage;
  uint64_t v192 = v167;
  uint64_t v193 = _swiftEmptyArrayStorage;
  uint64_t v194 = _swiftEmptyArrayStorage;
  __int128 v195 = _swiftEmptyArrayStorage;
  uint64_t v196 = _swiftEmptyArrayStorage;
  uint64_t v197 = _swiftEmptyArrayStorage;
  NANBitmap.Channel.operatingClass.getter(&v185);
  return sub_1000586C0((uint64_t)&v185, a2, &qword_100406B88);
}

__n128 sub_1000A9378@<Q0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  int v4 = *(_DWORD *)(a1 + 80);
  int v5 = *(_DWORD *)(a1 + 88);
  int v6 = *(_DWORD *)(a1 + 96);
  int v7 = *(_DWORD *)(a1 + 104);
  sub_10006989C(0, 4LL, 0);
  unint64_t v9 = _swiftEmptyArrayStorage[2];
  unint64_t v8 = _swiftEmptyArrayStorage[3];
  unint64_t v10 = v8 >> 1;
  unint64_t v11 = v9 + 1;
  if (v8 >> 1 <= v9)
  {
    sub_10006989C(v8 > 1, v9 + 1, 1);
    unint64_t v8 = _swiftEmptyArrayStorage[3];
    unint64_t v10 = v8 >> 1;
  }

  _swiftEmptyArrayStorage[2] = v11;
  *((_DWORD *)&_swiftEmptyArrayStorage[4] + v9) = v4;
  if (v10 <= v11) {
    sub_10006989C(v8 > 1, v9 + 2, 1);
  }
  _swiftEmptyArrayStorage[2] = v9 + 2;
  *((_DWORD *)&_swiftEmptyArrayStorage[4] + v11) = v5;
  unint64_t v13 = _swiftEmptyArrayStorage[2];
  unint64_t v12 = _swiftEmptyArrayStorage[3];
  unint64_t v14 = v12 >> 1;
  unint64_t v15 = v13 + 1;
  if (v12 >> 1 <= v13)
  {
    sub_10006989C(v12 > 1, v13 + 1, 1);
    unint64_t v12 = _swiftEmptyArrayStorage[3];
    unint64_t v14 = v12 >> 1;
  }

  _swiftEmptyArrayStorage[2] = v15;
  *((_DWORD *)&_swiftEmptyArrayStorage[4] + v13) = v6;
  int64_t v16 = v13 + 2;
  if (v14 <= v15) {
    sub_10006989C(v12 > 1, v16, 1);
  }
  _swiftEmptyArrayStorage[2] = v16;
  *((_DWORD *)&_swiftEmptyArrayStorage[4] + v15) = v7;
  int v17 = *(_DWORD *)(a1 + 112);
  int v18 = *(_DWORD *)(a1 + 120);
  int v67 = *(_DWORD *)(a1 + 128);
  int v19 = *(_DWORD *)(a1 + 136);
  sub_10006989C(0, 4LL, 0);
  unint64_t v21 = _swiftEmptyArrayStorage[2];
  unint64_t v20 = _swiftEmptyArrayStorage[3];
  unint64_t v22 = v20 >> 1;
  unint64_t v23 = v21 + 1;
  if (v20 >> 1 <= v21)
  {
    sub_10006989C(v20 > 1, v21 + 1, 1);
    unint64_t v20 = _swiftEmptyArrayStorage[3];
    unint64_t v22 = v20 >> 1;
  }

  _swiftEmptyArrayStorage[2] = v23;
  *((_DWORD *)&_swiftEmptyArrayStorage[4] + v21) = v17;
  if (v22 <= v23) {
    sub_10006989C(v20 > 1, v21 + 2, 1);
  }
  _swiftEmptyArrayStorage[2] = v21 + 2;
  *((_DWORD *)&_swiftEmptyArrayStorage[4] + v23) = v18;
  unint64_t v25 = _swiftEmptyArrayStorage[2];
  unint64_t v24 = _swiftEmptyArrayStorage[3];
  unint64_t v26 = v24 >> 1;
  unint64_t v27 = v25 + 1;
  if (v24 >> 1 <= v25)
  {
    sub_10006989C(v24 > 1, v25 + 1, 1);
    unint64_t v24 = _swiftEmptyArrayStorage[3];
    unint64_t v26 = v24 >> 1;
  }

  _swiftEmptyArrayStorage[2] = v27;
  *((_DWORD *)&_swiftEmptyArrayStorage[4] + v25) = v67;
  int64_t v28 = v25 + 2;
  if (v26 <= v27) {
    sub_10006989C(v24 > 1, v28, 1);
  }
  _swiftEmptyArrayStorage[2] = v28;
  *((_DWORD *)&_swiftEmptyArrayStorage[4] + v27) = v19;
  int v29 = *(_DWORD *)(a1 + 144);
  int v30 = *(_DWORD *)(a1 + 152);
  int v65 = *(_DWORD *)(a1 + 160);
  int v68 = *(_DWORD *)(a1 + 168);
  sub_10006989C(0, 4LL, 0);
  unint64_t v32 = _swiftEmptyArrayStorage[2];
  unint64_t v31 = _swiftEmptyArrayStorage[3];
  unint64_t v33 = v31 >> 1;
  unint64_t v34 = v32 + 1;
  if (v31 >> 1 <= v32)
  {
    sub_10006989C(v31 > 1, v32 + 1, 1);
    unint64_t v31 = _swiftEmptyArrayStorage[3];
    unint64_t v33 = v31 >> 1;
  }

  _swiftEmptyArrayStorage[2] = v34;
  *((_DWORD *)&_swiftEmptyArrayStorage[4] + v32) = v29;
  if (v33 <= v34) {
    sub_10006989C(v31 > 1, v32 + 2, 1);
  }
  _swiftEmptyArrayStorage[2] = v32 + 2;
  *((_DWORD *)&_swiftEmptyArrayStorage[4] + v34) = v30;
  unint64_t v36 = _swiftEmptyArrayStorage[2];
  unint64_t v35 = _swiftEmptyArrayStorage[3];
  unint64_t v37 = v35 >> 1;
  unint64_t v38 = v36 + 1;
  if (v35 >> 1 <= v36)
  {
    sub_10006989C(v35 > 1, v36 + 1, 1);
    unint64_t v35 = _swiftEmptyArrayStorage[3];
    unint64_t v37 = v35 >> 1;
  }

  _swiftEmptyArrayStorage[2] = v38;
  *((_DWORD *)&_swiftEmptyArrayStorage[4] + v36) = v65;
  int64_t v39 = v36 + 2;
  if (v37 <= v38) {
    sub_10006989C(v35 > 1, v39, 1);
  }
  _swiftEmptyArrayStorage[2] = v39;
  *((_DWORD *)&_swiftEmptyArrayStorage[4] + v38) = v68;
  int v40 = *(_DWORD *)(a1 + 176);
  int v41 = *(_DWORD *)(a1 + 184);
  int v66 = *(_DWORD *)(a1 + 192);
  int v69 = *(_DWORD *)(a1 + 200);
  sub_10006989C(0, 4LL, 0);
  unint64_t v43 = _swiftEmptyArrayStorage[2];
  unint64_t v42 = _swiftEmptyArrayStorage[3];
  unint64_t v44 = v42 >> 1;
  unint64_t v45 = v43 + 1;
  if (v42 >> 1 <= v43)
  {
    sub_10006989C(v42 > 1, v43 + 1, 1);
    unint64_t v42 = _swiftEmptyArrayStorage[3];
    unint64_t v44 = v42 >> 1;
  }

  _swiftEmptyArrayStorage[2] = v45;
  *((_DWORD *)&_swiftEmptyArrayStorage[4] + v43) = v40;
  if (v44 <= v45) {
    sub_10006989C(v42 > 1, v43 + 2, 1);
  }
  _swiftEmptyArrayStorage[2] = v43 + 2;
  *((_DWORD *)&_swiftEmptyArrayStorage[4] + v45) = v41;
  unint64_t v47 = _swiftEmptyArrayStorage[2];
  unint64_t v46 = _swiftEmptyArrayStorage[3];
  unint64_t v48 = v46 >> 1;
  unint64_t v49 = v47 + 1;
  if (v46 >> 1 <= v47)
  {
    sub_10006989C(v46 > 1, v47 + 1, 1);
    unint64_t v46 = _swiftEmptyArrayStorage[3];
    unint64_t v48 = v46 >> 1;
  }

  _swiftEmptyArrayStorage[2] = v49;
  *((_DWORD *)&_swiftEmptyArrayStorage[4] + v47) = v66;
  int64_t v50 = v47 + 2;
  if (v48 <= v49) {
    sub_10006989C(v46 > 1, v50, 1);
  }
  _swiftEmptyArrayStorage[2] = v50;
  *((_DWORD *)&_swiftEmptyArrayStorage[4] + v49) = v69;
  uint64_t v51 = *(void *)(a1 + 32);
  uint64_t v52 = *(unsigned __int8 *)(a1 + 72);
  unint64_t v53 = *(unsigned int *)(a1 + 40) | ((unint64_t)*(unsigned __int8 *)(a1 + 44) << 32);
  unint64_t v54 = *(unsigned int *)(a1 + 48) | ((unint64_t)*(unsigned __int8 *)(a1 + 52) << 32);
  uint64_t v55 = 0x1000000000000LL;
  if (!*(_BYTE *)(a1 + 62)) {
    uint64_t v55 = 0LL;
  }
  uint64_t v56 = 0x100000000000000LL;
  if (!*(_BYTE *)(a1 + 63)) {
    uint64_t v56 = 0LL;
  }
  unint64_t v57 = *(unsigned int *)(a1 + 56) | ((unint64_t)*(unsigned __int8 *)(a1 + 60) << 32) | ((unint64_t)*(unsigned __int8 *)(a1 + 61) << 40) | v55 | v56;
  uint64_t v58 = 256LL;
  if (!*(_BYTE *)(a1 + 65)) {
    uint64_t v58 = 0LL;
  }
  uint64_t v59 = v58 | *(unsigned __int8 *)(a1 + 64);
  uint64_t v60 = 0x10000LL;
  if (!*(_BYTE *)(a1 + 66)) {
    uint64_t v60 = 0LL;
  }
  uint64_t v61 = 0x1000000LL;
  if (!*(_BYTE *)(a1 + 67)) {
    uint64_t v61 = 0LL;
  }
  unint64_t v62 = v59 | v60 | v61 | ((unint64_t)*(unsigned __int8 *)(a1 + 68) << 32) | ((unint64_t)*(unsigned __int8 *)(a1 + 69) << 40) | ((unint64_t)*(unsigned __int8 *)(a1 + 70) << 48) | ((unint64_t)*(unsigned __int8 *)(a1 + 71) << 56);
  __n128 result = *(__n128 *)a1;
  __int128 v64 = *(_OWORD *)(a1 + 16);
  *(_OWORD *)a2 = *(_OWORD *)a1;
  *(_OWORD *)(a2 + 16) = v64;
  *(void *)(a2 + 32) = v51;
  *(void *)(a2 + 40) = v53;
  *(void *)(a2 + 48) = v54;
  *(void *)(a2 + 56) = v57;
  *(void *)(a2 + 64) = v62;
  *(void *)(a2 + 72) = v52;
  *(void *)(a2 + 80) = _swiftEmptyArrayStorage;
  *(void *)(a2 + 88) = _swiftEmptyArrayStorage;
  *(void *)(a2 + 96) = _swiftEmptyArrayStorage;
  *(void *)(a2 + 104) = _swiftEmptyArrayStorage;
  return result;
}

NSString sub_1000A99DC(uint64_t a1)
{
  unsigned int v1 = *(_DWORD *)(a1 + 36);
  __int128 v2 = *(_OWORD *)(a1 + 16);
  v9[0] = *(_OWORD *)a1;
  v9[1] = v2;
  uint64_t v10 = *(void *)(a1 + 32);
  if (v1 > 2) {
    return 0LL;
  }
  BYTE3(v10) = 0;
  uint64_t v3 = String.init(cString:)((char *)v9 + 4);
  unint64_t v5 = v4;
  uint64_t v6 = HIBYTE(v4) & 0xF;
  if ((v4 & 0x2000000000000000LL) == 0) {
    uint64_t v6 = v3 & 0xFFFFFFFFFFFFLL;
  }
  if (!v6)
  {
    swift_bridgeObjectRelease(v4);
    return 0LL;
  }

  NSString v7 = String._bridgeToObjectiveC()();
  swift_bridgeObjectRelease(v5);
  return v7;
}

uint64_t sub_1000A9AA4(__int16 a1)
{
  LODWORD(result) = _s7CoreP2P15IEEE80211StatusO8rawValueACSgs6UInt16V_tcfC_0(a1 & 0x1FF);
  else {
    return result;
  }
}

uint64_t sub_1000A9AC8(__int16 a1)
{
  LODWORD(result) = _s7CoreP2P15IEEE80211ReasonO8rawValueACSgs6UInt16V_tcfC_0(a1 & 0x1FF);
  else {
    return result;
  }
}

uint64_t sub_1000A9AEC()
{
  return swift_deallocObject(v0, 48LL, 7LL);
}

unint64_t sub_1000A9AFC()
{
  unint64_t result = qword_100406928;
  if (!qword_100406928)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for IEEE80211Frame,  &type metadata for IEEE80211Frame);
    atomic_store(result, (unint64_t *)&qword_100406928);
  }

  return result;
}

unint64_t sub_1000A9B40()
{
  unint64_t result = qword_100406930;
  if (!qword_100406930)
  {
    unint64_t result = swift_getWitnessTable(&protocol conformance descriptor for UInt16, &type metadata for UInt16);
    atomic_store(result, (unint64_t *)&qword_100406930);
  }

  return result;
}

unint64_t sub_1000A9B84()
{
  unint64_t result = qword_100406938;
  if (!qword_100406938)
  {
    uint64_t v1 = sub_1000022F8(&qword_100405E78);
    sub_10000AF70( &qword_100406940,  type metadata accessor for NANAttribute,  (uint64_t)&protocol conformance descriptor for NANAttribute);
    unint64_t result = swift_getWitnessTable(&protocol conformance descriptor for <A> [A], v1);
    atomic_store(result, (unint64_t *)&qword_100406938);
  }

  return result;
}

uint64_t sub_1000A9C00(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a3)
  {
    swift_unownedRetain();
    return swift_bridgeObjectRetain(a3);
  }

  return result;
}

uint64_t sub_1000A9C2C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a3)
  {
    swift_unownedRelease();
    return swift_bridgeObjectRelease(a3);
  }

  return result;
}

uint64_t sub_1000A9C58(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  uint64_t v4 = a2 - a1;
  if (__OFSUB__(a2, a1))
  {
    __break(1u);
    goto LABEL_9;
  }

  if (v4 < 0)
  {
LABEL_9:
    uint64_t result = _fatalErrorMessage(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  "UnsafeMutablePointer.initialize with negative count",  51LL,  2LL,  "Swift/UnsafePointer.swift",  25LL,  2,  1090LL,  0);
    goto LABEL_11;
  }

  unint64_t v5 = a4 + 72 * a1 + 32;
  unint64_t v6 = a3 + 72 * v4;
  if (v5 >= v6 || v5 + 72 * v4 <= a3)
  {
    swift_arrayInitWithCopy(a3);
    return v6;
  }

  uint64_t result = _fatalErrorMessage(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  "UnsafeMutablePointer.initialize overlapping range",  49LL,  2LL,  "Swift/UnsafePointer.swift",  25LL,  2,  1092LL,  0);
LABEL_11:
  __break(1u);
  return result;
}

uint64_t sub_1000A9D4C(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  uint64_t v4 = a2 - a1;
  if (__OFSUB__(a2, a1))
  {
    __break(1u);
  }

  else
  {
    if (v4 < 0)
    {
      uint64_t result = _fatalErrorMessage(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  "UnsafeMutablePointer.initialize with negative count",  51LL,  2LL,  "Swift/UnsafePointer.swift",  25LL,  2,  1090LL,  0);
      goto LABEL_9;
    }

    unint64_t v5 = a4 + 16 * a1 + 32;
    unint64_t v6 = a3 + 16 * v4;
    if (v5 >= v6 || v5 + 16 * v4 <= a3)
    {
      swift_arrayInitWithCopy(a3);
      return v6;
    }
  }

  uint64_t result = _fatalErrorMessage(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  "UnsafeMutablePointer.initialize overlapping range",  49LL,  2LL,  "Swift/UnsafePointer.swift",  25LL,  2,  1092LL,  0);
LABEL_9:
  __break(1u);
  return result;
}

char *sub_1000A9E3C(uint64_t a1, uint64_t a2, char *__dst, uint64_t a4)
{
  uint64_t v4 = a2 - a1;
  if (__OFSUB__(a2, a1))
  {
    __break(1u);
  }

  else
  {
    if (v4 < 0)
    {
      uint64_t result = (char *)_fatalErrorMessage(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  "UnsafeMutablePointer.initialize with negative count",  51LL,  2LL,  "Swift/UnsafePointer.swift",  25LL,  2,  1090LL,  0);
      goto LABEL_9;
    }

    unint64_t v5 = (char *)(a4 + 4 * a1 + 32);
    size_t v6 = 4 * v4;
    NSString v7 = &__dst[v6];
    if (v5 >= &__dst[v6] || &v5[v6] <= __dst)
    {
      memcpy(__dst, v5, v6);
      return v7;
    }
  }

  uint64_t result = (char *)_fatalErrorMessage(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  "UnsafeMutablePointer.initialize overlapping range",  49LL,  2LL,  "Swift/UnsafePointer.swift",  25LL,  2,  1092LL,  0);
LABEL_9:
  __break(1u);
  return result;
}

uint64_t sub_1000A9F24(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  uint64_t v4 = a2 - a1;
  if (__OFSUB__(a2, a1))
  {
    __break(1u);
  }

  else
  {
    if (v4 < 0)
    {
      uint64_t result = _fatalErrorMessage(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  "UnsafeMutablePointer.initialize with negative count",  51LL,  2LL,  "Swift/UnsafePointer.swift",  25LL,  2,  1090LL,  0);
      goto LABEL_9;
    }

    unint64_t v5 = a4 + 32 * a1 + 32;
    unint64_t v6 = a3 + 32 * v4;
    if (v5 >= v6 || v5 + 32 * v4 <= a3)
    {
      swift_arrayInitWithCopy(a3);
      return v6;
    }
  }

  uint64_t result = _fatalErrorMessage(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  "UnsafeMutablePointer.initialize overlapping range",  49LL,  2LL,  "Swift/UnsafePointer.swift",  25LL,  2,  1092LL,  0);
LABEL_9:
  __break(1u);
  return result;
}

uint64_t sub_1000AA014(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  uint64_t v4 = a2 - a1;
  if (__OFSUB__(a2, a1))
  {
    __break(1u);
    goto LABEL_9;
  }

  if (v4 < 0)
  {
LABEL_9:
    uint64_t result = _fatalErrorMessage(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  "UnsafeMutablePointer.initialize with negative count",  51LL,  2LL,  "Swift/UnsafePointer.swift",  25LL,  2,  1090LL,  0);
    goto LABEL_11;
  }

  unint64_t v6 = a4 + 24 * a1 + 32;
  unint64_t v7 = a3 + 24 * v4;
  if (v6 >= v7 || v6 + 24 * v4 <= a3)
  {
    sub_100002274(&qword_1004063E8);
    swift_arrayInitWithCopy(a3);
    return v7;
  }

  uint64_t result = _fatalErrorMessage(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  "UnsafeMutablePointer.initialize overlapping range",  49LL,  2LL,  "Swift/UnsafePointer.swift",  25LL,  2,  1092LL,  0);
LABEL_11:
  __break(1u);
  return result;
}

uint64_t sub_1000AA120(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  uint64_t v4 = a2 - a1;
  if (__OFSUB__(a2, a1))
  {
    __break(1u);
    goto LABEL_9;
  }

  if (v4 < 0)
  {
LABEL_9:
    uint64_t result = _fatalErrorMessage(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  "UnsafeMutablePointer.initialize with negative count",  51LL,  2LL,  "Swift/UnsafePointer.swift",  25LL,  2,  1090LL,  0);
    goto LABEL_11;
  }

  unint64_t v6 = a4 + 24 * a1 + 32;
  unint64_t v7 = a3 + 24 * v4;
  if (v6 >= v7 || v6 + 24 * v4 <= a3)
  {
    sub_100002274(&qword_100406478);
    swift_arrayInitWithCopy(a3);
    return v7;
  }

  uint64_t result = _fatalErrorMessage(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  "UnsafeMutablePointer.initialize overlapping range",  49LL,  2LL,  "Swift/UnsafePointer.swift",  25LL,  2,  1092LL,  0);
LABEL_11:
  __break(1u);
  return result;
}

char *sub_1000AA22C(uint64_t a1, uint64_t a2, char *__dst, uint64_t a4)
{
  size_t v4 = a2 - a1;
  if (__OFSUB__(a2, a1))
  {
    __break(1u);
  }

  else
  {
    if ((v4 & 0x8000000000000000LL) != 0)
    {
      uint64_t result = (char *)_fatalErrorMessage(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  "UnsafeMutablePointer.initialize with negative count",  51LL,  2LL,  "Swift/UnsafePointer.swift",  25LL,  2,  1090LL,  0);
      goto LABEL_9;
    }

    unint64_t v5 = (char *)(a4 + a1 + 32);
    unint64_t v6 = &__dst[v4];
    if (v5 >= &__dst[v4] || &v5[v4] <= __dst)
    {
      memcpy(__dst, v5, v4);
      return v6;
    }
  }

  uint64_t result = (char *)_fatalErrorMessage(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  "UnsafeMutablePointer.initialize overlapping range",  49LL,  2LL,  "Swift/UnsafePointer.swift",  25LL,  2,  1092LL,  0);
LABEL_9:
  __break(1u);
  return result;
}

char *sub_1000AA310(uint64_t a1, uint64_t a2, char *__dst, uint64_t a4)
{
  uint64_t v4 = a2 - a1;
  if (__OFSUB__(a2, a1))
  {
    __break(1u);
    goto LABEL_9;
  }

  if (v4 < 0)
  {
LABEL_9:
    uint64_t result = (char *)_fatalErrorMessage(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  "UnsafeMutablePointer.initialize with negative count",  51LL,  2LL,  "Swift/UnsafePointer.swift",  25LL,  2,  1090LL,  0);
    goto LABEL_11;
  }

  unint64_t v5 = (char *)(a4 + 10 * a1 + 32);
  size_t v6 = 10 * v4;
  unint64_t v7 = &__dst[v6];
  if (v5 >= &__dst[v6] || &v5[v6] <= __dst)
  {
    memcpy(__dst, v5, v6);
    return v7;
  }

  uint64_t result = (char *)_fatalErrorMessage(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  "UnsafeMutablePointer.initialize overlapping range",  49LL,  2LL,  "Swift/UnsafePointer.swift",  25LL,  2,  1092LL,  0);
LABEL_11:
  __break(1u);
  return result;
}

uint64_t sub_1000AA3FC(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  uint64_t v4 = a2 - a1;
  if (__OFSUB__(a2, a1))
  {
    __break(1u);
    goto LABEL_9;
  }

  if (v4 < 0)
  {
LABEL_9:
    uint64_t result = _fatalErrorMessage(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  "UnsafeMutablePointer.initialize with negative count",  51LL,  2LL,  "Swift/UnsafePointer.swift",  25LL,  2,  1090LL,  0);
    goto LABEL_11;
  }

  unint64_t v5 = a4 + 56 * a1 + 32;
  unint64_t v6 = a3 + 56 * v4;
  if (v5 >= v6 || v5 + 56 * v4 <= a3)
  {
    swift_arrayInitWithCopy(a3);
    return v6;
  }

  uint64_t result = _fatalErrorMessage(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  "UnsafeMutablePointer.initialize overlapping range",  49LL,  2LL,  "Swift/UnsafePointer.swift",  25LL,  2,  1092LL,  0);
LABEL_11:
  __break(1u);
  return result;
}

uint64_t sub_1000AA4F0(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  uint64_t v4 = a2 - a1;
  if (__OFSUB__(a2, a1))
  {
    __break(1u);
  }

  else
  {
    if (v4 < 0)
    {
      uint64_t result = _fatalErrorMessage(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  "UnsafeMutablePointer.initialize with negative count",  51LL,  2LL,  "Swift/UnsafePointer.swift",  25LL,  2,  1090LL,  0);
      goto LABEL_9;
    }

    unint64_t v5 = a4 + 16 * a1 + 32;
    unint64_t v6 = a3 + 16 * v4;
    if (v5 >= v6 || v5 + 16 * v4 <= a3)
    {
      swift_arrayInitWithCopy(a3);
      return v6;
    }
  }

  uint64_t result = _fatalErrorMessage(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  "UnsafeMutablePointer.initialize overlapping range",  49LL,  2LL,  "Swift/UnsafePointer.swift",  25LL,  2,  1092LL,  0);
LABEL_9:
  __break(1u);
  return result;
}

uint64_t sub_1000AA5E0(uint64_t a1)
{
  __int128 v2 = (const void *)(a1 + 12);
  if (*(_BYTE *)(a1 + 6))
  {
    memcpy(__dst, v2, sizeof(__dst));
    sub_1000A49F8((unint64_t)__dst, a1, &v5);
  }

  else
  {
    memcpy(__dst, v2, sizeof(__dst));
    sub_1000A491C((unint64_t)__dst, a1, &v5);
  }

  return v5;
}

void sub_1000AA684(_BYTE *a1)
{
  a1[3712] = 1;
}

uint64_t sub_1000AA6B0(uint64_t result)
{
  *(_BYTE *)(result + 3712) = 0;
  return result;
}

void sub_1000AA6B8(_OWORD *a1)
{
  *a1 = xmmword_10033A9E0;
  bzero(a1 + 1, 0xFA0uLL);
}

char *sub_1000AA6CC(uint64_t a1, uint64_t a2, char *__dst, uint64_t a4)
{
  uint64_t v4 = a2 - a1;
  if (__OFSUB__(a2, a1))
  {
    __break(1u);
  }

  else
  {
    if (v4 < 0)
    {
      uint64_t result = (char *)_fatalErrorMessage(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  "UnsafeMutablePointer.initialize with negative count",  51LL,  2LL,  "Swift/UnsafePointer.swift",  25LL,  2,  1090LL,  0);
      goto LABEL_9;
    }

    uint64_t v5 = (char *)(a4 + 2 * a1 + 32);
    size_t v6 = 2 * v4;
    unint64_t v7 = &__dst[v6];
    if (v5 >= &__dst[v6] || &v5[v6] <= __dst)
    {
      memcpy(__dst, v5, v6);
      return v7;
    }
  }

  uint64_t result = (char *)_fatalErrorMessage(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  "UnsafeMutablePointer.initialize overlapping range",  49LL,  2LL,  "Swift/UnsafePointer.swift",  25LL,  2,  1092LL,  0);
LABEL_9:
  __break(1u);
  return result;
}

uint64_t sub_1000AA7B4(uint64_t result, unint64_t a2, __int16 a3)
{
  if ((a3 & 0xFF00) != 0x200) {
    return sub_1000208D8(result, a2);
  }
  return result;
}

uint64_t sub_1000AA7C8(uint64_t a1)
{
  uint64_t v2 = v1;
  unint64_t v4 = sub_10000D9B0((uint64_t)_swiftEmptyArrayStorage);
  uint64_t v5 = type metadata accessor for BinaryEncoder();
  size_t v6 = (uint64_t *)swift_allocObject(v5, 40LL, 7LL);
  *((_OWORD *)v6 + 1) = xmmword_1003398F0;
  v6[4] = v4;
  v11[3] = v5;
  unint64_t v11[4] = sub_10000AF70( (unint64_t *)&qword_1004064B0,  (uint64_t (*)(uint64_t))type metadata accessor for BinaryEncoder,  (uint64_t)&protocol conformance descriptor for BinaryEncoder);
  v11[0] = v6;
  uint64_t v7 = type metadata accessor for NANAttribute(0LL);
  uint64_t v8 = sub_10000AF70( &qword_100406960,  type metadata accessor for NANAttribute,  (uint64_t)&protocol conformance descriptor for NANAttribute);
  swift_bridgeObjectRetain(a1);
  swift_retain();
  Array<A>.encode(to:)(v11, a1, v7, v8);
  sub_100002AC4(v11);
  if (!v2)
  {
    swift_bridgeObjectRelease(a1);
    swift_beginAccess(v6 + 2, v11, 0LL, 0LL);
    unint64_t v10 = v6[3];
    sub_100020AFC(v6[2], v10);
    swift_release(v6);
    __asm { BR              X9 }
  }

  swift_release(v6);
  return swift_bridgeObjectRelease(a1);
}

void sub_1000AAB60(uint64_t a1, unint64_t a2)
{
  unint64_t v2 = a2 >> 62;
  bzero(&v3, 0x802uLL);
  __asm { BR              X9 }

uint64_t sub_1000AADB0( uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, unint64_t a5, uint64_t a6, uint64_t a7)
{
  if (a7 != 1)
  {
    sub_1000208D8(a2, a3);
    sub_100020B40(a4, a5);
    return swift_bridgeObjectRelease(a7);
  }

  return result;
}

void *sub_1000AAE04(void *a1)
{
  uint64_t v2 = a1[5];
  sub_100058430(a1[1], a1[2], a1[3]);
  swift_bridgeObjectRetain(v2);
  return a1;
}

void *sub_1000AAE3C(void *a1)
{
  uint64_t v2 = a1[5];
  sub_100057CA0(a1[1], a1[2], a1[3]);
  swift_bridgeObjectRelease(v2);
  return a1;
}

void sub_1000AAE74(uint64_t a1)
{
}

void sub_1000AAE94(uint64_t a1)
{
}

void sub_1000AAEB4(uint64_t a1, uint64_t (*a2)(uint64_t, uint64_t *), uint64_t a3)
{
}

uint64_t sub_1000AAEDC()
{
  return sub_10000AF70( &qword_1004053A8,  type metadata accessor for AppleDevice,  (uint64_t)&protocol conformance descriptor for AppleDevice);
}

uint64_t sub_1000AAF08(uint64_t a1)
{
  uint64_t result = sub_10000AF70( (unint64_t *)&unk_100405E80,  type metadata accessor for AppleIO80211Driver,  (uint64_t)&protocol conformance descriptor for AppleIO80211Driver);
  *(void *)(a1 + 8) = result;
  return result;
}

uint64_t type metadata accessor for AppleIO80211Driver(uint64_t a1)
{
  uint64_t result = qword_100406A38;
  if (!qword_100406A38) {
    return swift_getSingletonMetadata(a1, &nominal type descriptor for AppleIO80211Driver);
  }
  return result;
}

uint64_t sub_1000AAF80()
{
  return sub_10000AF70( &qword_1004053B0,  type metadata accessor for AppleDevice,  (uint64_t)&protocol conformance descriptor for AppleDevice);
}

uint64_t sub_1000AAFAC()
{
  return sub_1000572E4( &qword_1004069A8,  &qword_1004069B0,  (uint64_t)&protocol conformance descriptor for AppleDevice.EventSource<A>);
}

void *sub_1000AAFD8@<X0>(void *a1@<X8>)
{
  uint64_t result = AppleIO80211Driver.capabilities.getter();
  *a1 = result;
  return result;
}

uint64_t sub_1000AB000(uint64_t *a1, uint64_t a2)
{
  uint64_t v2 = *a1;
  uint64_t v3 = *(void *)(*(void *)a2 + 72LL);
  *(void *)(*(void *)a2 + 72LL) = v2;
  swift_bridgeObjectRetain(v2);
  return swift_bridgeObjectRelease(v3);
}

uint64_t sub_1000AB030()
{
  return type metadata accessor for AppleIO80211Driver(0LL);
}

uint64_t sub_1000AB038(uint64_t a1)
{
  v4[0] = &unk_10033EDF8;
  v4[1] = &unk_10033EE10;
  v4[2] = (char *)&value witness table for Builtin.NativeObject + 64;
  v4[3] = &unk_10033EE28;
  __int128 v4[4] = &unk_10033EE40;
  uint64_t result = type metadata accessor for Logger(319LL);
  if (v3 <= 0x3F)
  {
    v4[5] = *(void *)(result - 8) + 64LL;
    uint64_t result = swift_updateClassMetadata2(a1, 256LL, 6LL, v4, a1 + 80);
    if (!result) {
      return 0LL;
    }
  }

  return result;
}

void sub_1000AB0DC(uint64_t a1)
{
}

void sub_1000AB0F8(uint64_t a1)
{
}

uint64_t sub_1000AB114(uint64_t a1, uint64_t a2)
{
  return sub_1001C59F4(a1, a2, *(void *)(v2 + 16), *(void **)(v2 + 24));
}

uint64_t sub_1000AB11C(uint64_t result)
{
  uint64_t v2 = v1;
  uint64_t v3 = *(void *)(result + 16);
  if (v3)
  {
    uint64_t v4 = result + 32;
    uint64_t v18 = result;
    swift_bridgeObjectRetain(result);
    unint64_t v5 = 0LL;
    while (1)
    {
      if (v5 <= 1)
      {
        unint64_t v6 = v4 + 16 * v5;
        uint64_t v7 = *(void *)(v6 + 8);
        __int16 v8 = *(_WORD *)(v6 + 2);
        swift_bridgeObjectRetain(v7);
        sub_100071514(0LL, 4LL, v8);
        if (v2)
        {
          uint64_t result = swift_unexpectedError(v2, "CoreP2P/NANAttribute.swift", 26LL, 1LL);
          __break(1u);
          return result;
        }

        uint64_t v9 = *(void *)(v7 + 16);
        if (v9)
        {
          swift_bridgeObjectRetain(v7);
          unsigned int v10 = 0;
          uint64_t v11 = 32LL;
          do
          {
            __int128 v12 = *(_OWORD *)(v7 + v11);
            __int128 v13 = *(_OWORD *)(v7 + v11 + 16);
            __int128 v14 = *(_OWORD *)(v7 + v11 + 32);
            char v17 = *(_BYTE *)(v7 + v11 + 48);
            v16[1] = v13;
            _BYTE v16[2] = v14;
            v16[0] = v12;
            if (v10 <= 0xF)
            {
              sub_1000AAE04(v16);
              sub_1000A32E4((unint64_t)&v15);
              sub_1000AAE3C(v16);
              ++v10;
            }

            v11 += 56LL;
            --v9;
          }

          while (v9);
          swift_bridgeObjectRelease(v7);
        }

        swift_bridgeObjectRelease(v7);
      }

      if (++v5 == v3) {
        return swift_bridgeObjectRelease(v18);
      }
    }
  }

  return result;
}

uint64_t sub_1000AB298(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = v3;
  uint64_t v8 = *(void *)(v3 + 40);
  uint64_t v10 = *(void *)(v5 + 16);
  uint64_t v9 = *(void *)(v5 + 24);
  uint64_t v11 = a1 & 0xFFFFFFFFFFFFLL;
  swift_retain();
  swift_bridgeObjectRetain(v9);
  sub_1000543AC(v11, a2, a3, v10, v9, 1u);
  swift_bridgeObjectRelease(v9);
  uint64_t result = swift_release(v8);
  if (!v4) {
    __asm { BR              X10 }
  }

  return result;
}

void sub_1000AB4A4(uint64_t a1)
{
}

uint64_t sub_1000AB4C0(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  uint64_t v4 = a2 - a1;
  if (__OFSUB__(a2, a1))
  {
    __break(1u);
  }

  else
  {
    if (v4 < 0)
    {
      uint64_t result = _fatalErrorMessage(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  "UnsafeMutablePointer.initialize with negative count",  51LL,  2LL,  "Swift/UnsafePointer.swift",  25LL,  2,  1090LL,  0);
      goto LABEL_9;
    }

    unint64_t v6 = a4 + 16 * a1 + 32;
    unint64_t v7 = a3 + 16 * v4;
    if (v6 >= v7 || v6 + 16 * v4 <= a3)
    {
      sub_100002274(&qword_1004068A0);
      swift_arrayInitWithCopy(a3);
      return v7;
    }
  }

  uint64_t result = _fatalErrorMessage(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  "UnsafeMutablePointer.initialize overlapping range",  49LL,  2LL,  "Swift/UnsafePointer.swift",  25LL,  2,  1092LL,  0);
LABEL_9:
  __break(1u);
  return result;
}

uint64_t sub_1000AB5C8( uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t (*a5)(void))
{
  uint64_t v5 = a2 - a1;
  if (__OFSUB__(a2, a1))
  {
    __break(1u);
    goto LABEL_9;
  }

  if (v5 < 0)
  {
LABEL_9:
    uint64_t result = _fatalErrorMessage(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  "UnsafeMutablePointer.initialize with negative count",  51LL,  2LL,  "Swift/UnsafePointer.swift",  25LL,  2,  1090LL,  0);
    goto LABEL_11;
  }

  uint64_t v9 = *(void *)(a5(0LL) - 8);
  uint64_t v10 = *(unsigned __int8 *)(v9 + 80);
  uint64_t v11 = *(void *)(v9 + 72);
  unint64_t v12 = a4 + ((v10 + 32) & ~v10) + v11 * a1;
  uint64_t v13 = v11 * v5;
  unint64_t v14 = a3 + v13;
  unint64_t v15 = v12 + v13;
  if (v12 >= v14 || v15 <= a3)
  {
    swift_arrayInitWithCopy(a3);
    return v14;
  }

  uint64_t result = _fatalErrorMessage(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  "UnsafeMutablePointer.initialize overlapping range",  49LL,  2LL,  "Swift/UnsafePointer.swift",  25LL,  2,  1092LL,  0);
LABEL_11:
  __break(1u);
  return result;
}

uint64_t sub_1000AB6E0(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  uint64_t v4 = a2 - a1;
  if (__OFSUB__(a2, a1))
  {
    __break(1u);
    goto LABEL_9;
  }

  if (v4 < 0)
  {
LABEL_9:
    uint64_t result = _fatalErrorMessage(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  "UnsafeMutablePointer.initialize with negative count",  51LL,  2LL,  "Swift/UnsafePointer.swift",  25LL,  2,  1090LL,  0);
    goto LABEL_11;
  }

  unint64_t v6 = a4 + 24 * a1 + 32;
  unint64_t v7 = a3 + 24 * v4;
  if (v6 >= v7 || v6 + 24 * v4 <= a3)
  {
    sub_100002274(&qword_100406AF8);
    swift_arrayInitWithCopy(a3);
    return v7;
  }

  uint64_t result = _fatalErrorMessage(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  "UnsafeMutablePointer.initialize overlapping range",  49LL,  2LL,  "Swift/UnsafePointer.swift",  25LL,  2,  1092LL,  0);
LABEL_11:
  __break(1u);
  return result;
}

uint64_t sub_1000AB7EC(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  uint64_t v4 = a2 - a1;
  if (__OFSUB__(a2, a1))
  {
    __break(1u);
  }

  else
  {
    if (v4 < 0)
    {
      uint64_t result = _fatalErrorMessage(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  "UnsafeMutablePointer.initialize with negative count",  51LL,  2LL,  "Swift/UnsafePointer.swift",  25LL,  2,  1090LL,  0);
      goto LABEL_9;
    }

    unint64_t v6 = a4 + 8 * a1 + 32;
    unint64_t v7 = a3 + 8 * v4;
    if (v6 >= v7 || v6 + 8 * v4 <= a3)
    {
      sub_100002274((uint64_t *)&unk_10040D5A0);
      swift_arrayInitWithCopy(a3);
      return v7;
    }
  }

  uint64_t result = _fatalErrorMessage(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  "UnsafeMutablePointer.initialize overlapping range",  49LL,  2LL,  "Swift/UnsafePointer.swift",  25LL,  2,  1092LL,  0);
LABEL_9:
  __break(1u);
  return result;
}

uint64_t sub_1000AB8F4(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  uint64_t v4 = a2 - a1;
  if (__OFSUB__(a2, a1))
  {
    __break(1u);
    goto LABEL_9;
  }

  if (v4 < 0)
  {
LABEL_9:
    uint64_t result = _fatalErrorMessage(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  "UnsafeMutablePointer.initialize with negative count",  51LL,  2LL,  "Swift/UnsafePointer.swift",  25LL,  2,  1090LL,  0);
    goto LABEL_11;
  }

  unint64_t v6 = a4 + 48 * a1 + 32;
  unint64_t v7 = a3 + 48 * v4;
  if (v6 >= v7 || v6 + 48 * v4 <= a3)
  {
    sub_100002274(&qword_100405110);
    swift_arrayInitWithCopy(a3);
    return v7;
  }

  uint64_t result = _fatalErrorMessage(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  "UnsafeMutablePointer.initialize overlapping range",  49LL,  2LL,  "Swift/UnsafePointer.swift",  25LL,  2,  1092LL,  0);
LABEL_11:
  __break(1u);
  return result;
}

uint64_t sub_1000ABA00(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  uint64_t v4 = a2 - a1;
  if (__OFSUB__(a2, a1))
  {
    __break(1u);
  }

  else
  {
    if (v4 < 0)
    {
      uint64_t result = _fatalErrorMessage(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  "UnsafeMutablePointer.initialize with negative count",  51LL,  2LL,  "Swift/UnsafePointer.swift",  25LL,  2,  1090LL,  0);
      goto LABEL_9;
    }

    unint64_t v5 = a4 + 32 * a1 + 32;
    unint64_t v6 = a3 + 32 * v4;
    if (v5 >= v6 || v5 + 32 * v4 <= a3)
    {
      swift_arrayInitWithCopy(a3);
      return v6;
    }
  }

  uint64_t result = _fatalErrorMessage(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  "UnsafeMutablePointer.initialize overlapping range",  49LL,  2LL,  "Swift/UnsafePointer.swift",  25LL,  2,  1092LL,  0);
LABEL_9:
  __break(1u);
  return result;
}

uint64_t sub_1000ABAF0(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  uint64_t v4 = a2 - a1;
  if (__OFSUB__(a2, a1))
  {
    __break(1u);
  }

  else
  {
    if (v4 < 0)
    {
      uint64_t result = _fatalErrorMessage(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  "UnsafeMutablePointer.initialize with negative count",  51LL,  2LL,  "Swift/UnsafePointer.swift",  25LL,  2,  1090LL,  0);
      goto LABEL_9;
    }

    unint64_t v5 = a4 + 8 * a1 + 32;
    unint64_t v6 = a3 + 8 * v4;
    if (v5 >= v6 || v5 + 8 * v4 <= a3)
    {
      swift_arrayInitWithCopy(a3);
      return v6;
    }
  }

  uint64_t result = _fatalErrorMessage(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  "UnsafeMutablePointer.initialize overlapping range",  49LL,  2LL,  "Swift/UnsafePointer.swift",  25LL,  2,  1092LL,  0);
LABEL_9:
  __break(1u);
  return result;
}

void sub_1000ABBE0(uint64_t a1, uint64_t a2)
{
}

void sub_1000ABC00(uint64_t a1)
{
}

uint64_t sub_1000ABC20(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t result = sub_10009FA28(v3[8], a1, a2, v3[2], v3[4], v3[5], v3[6]);
  if (v4) {
    *a3 = v4;
  }
  return result;
}

uint64_t sub_1000ABC68(unint64_t a1, unint64_t a2)
{
  return sub_1001FF2B0(a1, a2, *(void **)(v2 + 16), *(uint64_t **)(v2 + 24));
}

uint64_t sub_1000ABC70(uint64_t *a1)
{
  uint64_t v1 = *a1;
  return (v1 + 1);
}

uint64_t sub_1000ABC88(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, char a5)
{
  if ((a5 & 1) != 0) {
    return sub_1000ABC94(a1, a2, a3, a4);
  }
  return a1;
}

uint64_t sub_1000ABC94(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a4 != 1) {
    return swift_bridgeObjectRelease(a4);
  }
  return result;
}

void *sub_1000ABCAC()
{
  return variable initialization expression of NANMatchingFilter.matchingFilterList();
}

void sub_1000ABCC0(uint64_t a1)
{
}

void sub_1000ABCD4(uint64_t a1)
{
}

uint64_t *SCPreferencesRef.p2pPreferences.unsafeMutableAddressor()
{
  if (qword_100404148 != -1) {
    swift_once(&qword_100404148, sub_1000B0ED8);
  }
  return &static SCPreferencesRef.p2pPreferences;
}

uint64_t CachedPreferenceStorage.init(_:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t *a4@<X8>)
{
  uint64_t v8 = type metadata accessor for InMemoryPreferenceStorage();
  uint64_t v9 = swift_allocObject(v8, 24LL, 7LL);
  *(void *)(v9 + 16) = &_swiftEmptyDictionarySingleton;
  *a4 = v9;
  uint64_t v11 = (char *)a4 + *(int *)(type metadata accessor for CachedPreferenceStorage(0LL, a2, a3, v10) + 36);
  return (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(void *)(a2 - 8) + 32LL))(v11, a1, a2);
}

uint64_t LockedPreferencesStorage.init(_:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t *a4@<X8>)
{
  uint64_t v8 = type metadata accessor for Lock();
  uint64_t v9 = swift_allocObject(v8, 24LL, 7LL);
  uint64_t v10 = (_DWORD *)swift_slowAlloc(4LL, -1LL);
  *(void *)(v9 + 16) = v10;
  *uint64_t v10 = 0;
  *a4 = v9;
  unint64_t v12 = (char *)a4 + *(int *)(type metadata accessor for LockedPreferencesStorage(0LL, a2, a3, v11) + 36);
  return (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(void *)(a2 - 8) + 32LL))(v12, a1, a2);
}

Swift::Void __swiftcall CachedPreferenceStorage.invalidateCache()()
{
  uint64_t v1 = *v0;
  swift_beginAccess(*v0 + 16, v3, 1LL, 0LL);
  uint64_t v2 = *(void *)(v1 + 16);
  *(void *)(v1 + 16) = &_swiftEmptyDictionarySingleton;
  swift_bridgeObjectRelease(v2);
}

void LockedPreferencesStorage.withBackingStorage(_:)(void (*a1)(uint64_t), uint64_t a2, uint64_t a3)
{
  unint64_t v6 = *(os_unfair_lock_s **)(*(void *)v3 + 16LL);
  os_unfair_lock_lock(v6);
  a1(v3 + *(int *)(a3 + 36));
  os_unfair_lock_unlock(v6);
}

uint64_t CachedPreferenceStorage.withBackingStorage(_:)( uint64_t (*a1)(uint64_t), uint64_t a2, uint64_t a3)
{
  return a1(v3 + *(int *)(a3 + 36));
}

void *PreferenceDefaults.EnableUserspaceP2POptions.none.unsafeMutableAddressor()
{
  return &static PreferenceDefaults.EnableUserspaceP2POptions.none;
}

void *PreferenceDefaults.EnableUserspaceP2POptions.localeManager.unsafeMutableAddressor()
{
  return &static PreferenceDefaults.EnableUserspaceP2POptions.localeManager;
}

void *PreferenceDefaults.EnableUserspaceP2POptions.infraManager.unsafeMutableAddressor()
{
  return &static PreferenceDefaults.EnableUserspaceP2POptions.infraManager;
}

void *PreferenceDefaults.EnableUserspaceP2POptions.rawEventPayload.unsafeMutableAddressor()
{
  return &static PreferenceDefaults.EnableUserspaceP2POptions.rawEventPayload;
}

void *PreferenceDefaults.EnableUserspaceP2POptions.awdlToWiFiAwareMigration.unsafeMutableAddressor()
{
  return &static PreferenceDefaults.EnableUserspaceP2POptions.awdlToWiFiAwareMigration;
}

void *PreferenceDefaults.EnableUserspaceP2POptions.keepAliveTermination.unsafeMutableAddressor()
{
  return &static PreferenceDefaults.EnableUserspaceP2POptions.keepAliveTermination;
}

void *PreferenceDefaults.EnableUserspaceP2POptions.infraRealTimePacketThreshold.unsafeMutableAddressor()
{
  return &static PreferenceDefaults.EnableUserspaceP2POptions.infraRealTimePacketThreshold;
}

void *PreferenceDefaults.EnableUserspaceP2POptions.remoteScreenRTGSyncElection.unsafeMutableAddressor()
{
  return &static PreferenceDefaults.EnableUserspaceP2POptions.remoteScreenRTGSyncElection;
}

void *PreferenceDefaults.EnableUserspaceP2POptions.all.unsafeMutableAddressor()
{
  return &static PreferenceDefaults.EnableUserspaceP2POptions.all;
}

uint64_t static PreferenceDefaults.EnableUserspaceP2POptions.all.getter()
{
  return 127LL;
}

uint64_t PreferenceDefaults.EnableUserspaceP2POptions.description.getter(char a1)
{
  uint64_t v24 = dispatch thunk of CustomStringConvertible.description.getter( &type metadata for UInt64,  &protocol witness table for UInt64);
  unint64_t v25 = v2;
  v3._countAndFlagsBits = 10272LL;
  v3._object = (void *)0xE200000000000000LL;
  String.append(_:)(v3);
  if ((a1 & 0x7F) != 0)
  {
    if ((a1 & 1) != 0)
    {
      v18._object = (void *)0x8000000100364110LL;
      v18._countAndFlagsBits = 0xD000000000000010LL;
      String.append(_:)(v18);
      if ((a1 & 2) == 0)
      {
LABEL_4:
        if ((a1 & 4) == 0) {
          goto LABEL_5;
        }
        goto LABEL_15;
      }
    }

    else if ((a1 & 2) == 0)
    {
      goto LABEL_4;
    }

    v19._countAndFlagsBits = 0x614D206172666E49LL;
    v19._object = (void *)0xEF202C726567616ELL;
    String.append(_:)(v19);
    if ((a1 & 4) == 0)
    {
LABEL_5:
      if ((a1 & 8) == 0) {
        goto LABEL_6;
      }
      goto LABEL_16;
    }

LABEL_9:
      v4._countAndFlagsBits = 0xD000000000000021LL;
      v4._object = (void *)0x8000000100364050LL;
      String.append(_:)(v4);
      goto LABEL_10;
    }

  uint64_t result = (uint64_t)sub_10019EA0C((void *)v6);
  uint64_t v6 = result;
  *uint64_t v7 = result;
  if ((a1 & 0x8000000000000000LL) != 0) {
    goto LABEL_10;
  }
LABEL_5:
  if (*(void *)(v6 + 16) > a1)
  {
    *(_BYTE *)(v6 + a1 + 32) |= a2;
    return a4(v13, 0LL);
  }

  uint64_t result = (uint64_t)sub_10019EA0C((void *)v6);
  uint64_t v6 = result;
  *uint64_t v7 = result;
  if ((a1 & 0x8000000000000000LL) != 0) {
    goto LABEL_10;
  }
LABEL_5:
  if (*(void *)(v6 + 16) > a1)
  {
    *(_BYTE *)(v6 + a1 + 32) &= a2;
    return a4(v13, 0LL);
  }

  uint64_t result = (uint64_t)sub_10019EA0C((void *)v6);
  uint64_t v6 = result;
  *uint64_t v7 = result;
  if ((a1 & 0x8000000000000000LL) != 0) {
    goto LABEL_10;
  }
LABEL_5:
  if (*(void *)(v6 + 16) > a1)
  {
    *(_BYTE *)(v6 + a1 + 32) &= ~(_BYTE)a2;
    return a4(v13, 0LL);
  }

  uint64_t result = (uint64_t)sub_10019EA0C(v6);
  uint64_t v6 = (void *)result;
  if ((v5 & 0x8000000000000000LL) != 0) {
    goto LABEL_10;
  }
LABEL_5:
  if (v6[2] > v5)
  {
    *((_BYTE *)v6 + v5 + 32) &= v7;
    void *v4 = v6;
    return result;
  }

  uint64_t result = (uint64_t)sub_10019EA0C(v6);
  uint64_t v6 = (void *)result;
  if ((v5 & 0x8000000000000000LL) != 0) {
    goto LABEL_10;
  }
LABEL_5:
  if (v6[2] > v5)
  {
    *((_BYTE *)v6 + v5 + 32) &= ~v7;
    void *v4 = v6;
    return result;
  }

  uint64_t v11 = *((void *)v2 + 4);
  uint64_t v12 = *((void *)v2 + 5);
  uint64_t v13 = *((unsigned __int16 *)v2 + 24) | (*((unsigned __int8 *)v2 + 50) << 16);
  sub_1001CDEAC(v11, v12, v13);
  sub_1001C5834(a1, v11, v12, v13);
  sub_1001062BC(v11, v12, v13);
  uint64_t v14 = *((void *)v2 + 7);
  if (v14 == 4LL)
  {
    Hasher._combine(_:)(0);
  }

  else
  {
    Swift::String v17 = v2 + 4;
    Swift::String v15 = *((void *)v2 + 8);
    int64_t v16 = *((void *)v17 + 1);
    Hasher._combine(_:)(1u);
    Hasher._combine(_:)(v14);
    sub_100020AFC(v15, v16);
    Data.hash(into:)(a1, v15, v16);
    sub_1001062E0(v14, v15, v16);
  }

    if (i < *(void *)(v13 + 16))
    {
      uint64_t result = v22(v13 + v15);
      *int64_t v16 = v13;
      return result;
    }

  uint64_t result = (uint64_t)sub_10019EA0C(v6);
  uint64_t v6 = (void *)result;
  if ((v5 & 0x8000000000000000LL) != 0) {
    goto LABEL_10;
  }
LABEL_5:
  if (v6[2] > v5)
  {
    *((_BYTE *)v6 + v5 + 32) &= v7;
    void *v4 = v6;
    return result;
  }

  uint64_t result = (uint64_t)sub_10019EA0C(v6);
  uint64_t v6 = (void *)result;
  if ((v5 & 0x8000000000000000LL) != 0) {
    goto LABEL_10;
  }
LABEL_5:
  if (v6[2] > v5)
  {
    *((_BYTE *)v6 + v5 + 32) |= v7;
    void *v4 = v6;
    return result;
  }

    unsigned __int32 v377 = v41;
    unint64_t v47 = v378;
    sub_100057FE8(a1, (uint64_t)v35, type metadata accessor for DriverEvent);
    unint64_t v48 = v47;
    unint64_t v49 = (os_log_s *)Logger.logObject.getter(v48);
    int64_t v50 = static os_log_type_t.error.getter(v49);
    if (os_log_type_enabled(v49, v50))
    {
      uint64_t v51 = swift_slowAlloc(22LL, -1LL);
      uint64x2_t v376 = (void *)swift_slowAlloc(8LL, -1LL);
      __int8 v378 = (void *)swift_slowAlloc(32LL, -1LL);
      v398[0] = (uint64_t)v378;
      *(_DWORD *)uint64_t v51 = 138412546;
      uint64_t v396 = (uint64_t)v48;
      uint64_t v52 = v48;
      UnsafeMutableRawBufferPointer.copyMemory(from:)(&v396, v397);
      unint64_t v53 = v376;
      *uint64x2_t v376 = v48;

      *(_WORD *)(v51 + 12) = 2080;
      DriverEvent.description.getter();
      uint64_t v55 = v54;
      uint64_t v396 = sub_10000235C(v56, v54, v398);
      UnsafeMutableRawBufferPointer.copyMemory(from:)(&v396, v397);
      swift_bridgeObjectRelease(v55);
      sub_10005802C((uint64_t)v35, type metadata accessor for DriverEvent);
      _os_log_impl((void *)&_mh_execute_header, v49, v50, "%@ received an unexpected %s", (uint8_t *)v51, 0x16u);
      unint64_t v57 = sub_100002274(&qword_100404DE0);
      swift_arrayDestroy(v53, 1LL, v57);
      swift_slowDealloc(v53, -1LL, -1LL);
      uint64_t v58 = (uint64_t)v378;
      swift_arrayDestroy(v378, 1LL, &type metadata for Any[8]);
      swift_slowDealloc(v58, -1LL, -1LL);
      swift_slowDealloc(v51, -1LL, -1LL);
    }

    else
    {

      sub_10005802C((uint64_t)v35, type metadata accessor for DriverEvent);
    }

    goto LABEL_23;
  }

  if (EnumCaseMultiPayload) {
    goto LABEL_9;
  }
  sub_100057FE8((uint64_t)v41, (uint64_t)v39, type metadata accessor for DriverEvent);
  sub_100058090(v39, &v396);
  sub_100058090(&v396, v398);
  switch(sub_1001073D8((uint64_t)v398))
  {
    case 3u:
      NANBitmap.Channel.operatingClass.getter(v398);
      goto LABEL_22;
    case 5u:
      uint64_t v59 = (unsigned __int8 *)NANBitmap.Channel.operatingClass.getter(v398);
      uint64_t v60 = *v59;
      uint64_t v61 = v59[2];
      unint64_t v62 = v59[3];
      __int128 v63 = v59[4];
      __int128 v64 = v59[5];
      int v65 = v59[6];
      int v66 = v59[7];
      int v67 = v59[8];
      int v68 = v59[9];
      int v69 = v59[10];
      __int128 v70 = v59[11];
      __int128 v71 = v59[12];
      uint64_t v72 = v59[13];
      uint64_t v73 = (uint64_t)v378;
      unint64_t v74 = *((unsigned __int8 *)v378 + qword_100410A30);
      unsigned __int32 v377 = v41;
      uint64_t v374 = (char *)v60;
      uint64_t v371 = v62;
      unint64_t v372 = v61;
      v370 = v63;
      uint64_t v367 = v65;
      unint64_t v368 = v64;
      uint64_t v366 = v66;
      if (v74 == 1)
      {
        unint64_t v353 = v59[1];
        uint64_t v360 = *((void *)v59 + 2);
        LOBYTE(v394) = v67;
        HIBYTE(v394) = v68;
        LOBYTE(v395) = v69;
        BYTE1(v395) = v70;
        BYTE2(v395) = v71;
        HIBYTE(v395) = v72;
        uint64_t v75 = (v63 << 16) | (v62 << 8) | (v64 << 24) | (v65 << 32) | (v66 << 40) | v61;
        unint64_t v373 = WiFiAddress.description.getter(v75);
        uint64_t v77 = v76;
        uint64_t v78 = v67 | (v68 << 8) | (v69 << 16) | (v70 << 24) | (v71 << 32);
        uint64_t v79 = v75;
        uint64_t v80 = v78 | (v72 << 40);
        if (static NANClusterChangeEvent.__derived_struct_equals(_:_:)(v75, v80))
        {
          uint64_t v81 = 0LL;
          unint64_t v82 = (void *)0xE000000000000000LL;
        }

        else
        {
          uint64_t v392 = 0x203A49444E5BLL;
          uint64_t v393 = (void *)0xE600000000000000LL;
          v123._countAndFlagsBits = WiFiAddress.description.getter(v80);
          object = v123._object;
          String.append(_:)(v123);
          swift_bridgeObjectRelease(object);
          v125._countAndFlagsBits = 93LL;
          v125._object = (void *)0xE100000000000000LL;
          String.append(_:)(v125);
          uint64_t v81 = v392;
          unint64_t v82 = v393;
        }

        uint64_t v392 = v373;
        uint64_t v393 = (void *)v77;
        swift_bridgeObjectRetain(v77);
        v126._countAndFlagsBits = v81;
        v126._object = v82;
        String.append(_:)(v126);
        swift_bridgeObjectRelease(v77);
        swift_bridgeObjectRelease(v82);
        __int128 v127 = v392;
        __int128 v128 = (uint64_t)v378;
        uint64_t v129 = (uint64_t)v378 + qword_100410A38;
        unint64_t v373 = (uint64_t)v393;
        unint64_t v130 = swift_bridgeObjectRetain_n(v393, 2LL);
        uint64_t v359 = v129;
        uint64_t v131 = (os_log_s *)Logger.logObject.getter(v130);
        unint64_t v132 = static os_log_type_t.default.getter();
        __int128 v133 = os_log_type_enabled(v131, v132);
        uint64_t v364 = v80;
        if (v133)
        {
          __int128 v134 = (uint8_t *)swift_slowAlloc(12LL, -1LL);
          uint64_t v135 = swift_slowAlloc(32LL, -1LL);
          uint64_t v392 = v135;
          *(_DWORD *)__int128 v134 = 136315138;
          unint64_t v136 = v79;
          uint64_t v137 = v373;
          swift_bridgeObjectRetain(v373);
          __int8 v387 = sub_10000235C(v127, v137, &v392);
          uint64_t v80 = v364;
          __int128 v128 = (uint64_t)v378;
          UnsafeMutableRawBufferPointer.copyMemory(from:)(&v387, &v388);
          unint64_t v138 = v137;
          uint64_t v79 = v136;
          swift_bridgeObjectRelease_n(v138, 3LL);
          _os_log_impl( (void *)&_mh_execute_header,  v131,  v132,  "Received a new datapath request from peer: %s",  v134,  0xCu);
          swift_arrayDestroy(v135, 1LL, &type metadata for Any[8]);
          swift_slowDealloc(v135, -1LL, -1LL);
          swift_slowDealloc(v134, -1LL, -1LL);
        }

        else
        {
          swift_bridgeObjectRelease_n(v373, 2LL);
        }

        __int128 v139 = v360;
        __int128 v140 = v362;
        uint64_t v141 = v363;
        sub_100058090(&v396, &v392);
        unint64_t v142 = NANBitmap.Channel.operatingClass.getter(&v392);
        swift_bridgeObjectRetain(*(void *)(v142 + 16));
        Array<A>.retrieve(attribute:)(41, v139, (uint64_t)v140);
        sub_1001074E8( (uint64_t)&v396,  (void (*)(void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, __int16))sub_1000578CC);
        uint64_t v143 = type metadata accessor for NANAttribute(0LL);
        unint64_t v144 = *(unsigned int (**)(unsigned __int8 *, uint64_t, uint64_t))(*(void *)(v143 - 8) + 48LL);
        if (v144(v140, 1LL, v143) == 1)
        {
          sub_1000225EC((uint64_t)v140, &qword_10040D440);
        }

        else
        {
          if (swift_getEnumCaseMultiPayload(v140, v143) == 36)
          {
            v349 = v127;
            v350 = v79;
            unint64_t v348 = *v140;
            __int128 v145 = v140[3];
            __int128 v146 = v140[4];
            uint64_t v147 = v140[5];
            unint64_t v148 = v140[6];
            uint64_t v149 = v140[7];
            unint64_t v150 = v140[8];
            LODWORD(v362) = v140[10];
            uint64_t v151 = *((void *)v140 + 4);
            uint64_t v363 = (unsigned __int8 *)*((void *)v140 + 3);
            uint64_t v152 = v140;
            uint64_t v153 = *((void *)v140 + 5);
            unint64_t v155 = *((void *)v152 + 6);
            uint64_t v154 = *((void *)v152 + 7);
            LOBYTE(v394) = v145;
            HIBYTE(v394) = v146;
            LOBYTE(v395) = v147;
            BYTE1(v395) = v148;
            ObjectType = v149;
            BYTE2(v395) = v149;
            uint64x2_t v365 = v150;
            HIBYTE(v395) = v150;
            sub_1001062A0(v153, v155, v154);
            unint64_t v156 = *(unsigned __int8 *)NANAttribute.DatapathExtension.Control.security.unsafeMutableAddressor();
            sub_100020B40((uint64_t)v363, v151);
            uint64_t v351 = v154;
            unint64_t v352 = v153;
            uint64_t v363 = (unsigned __int8 *)v155;
            unint64_t v157 = v155;
            unint64_t v158 = v146;
            int64_t v159 = v145;
            sub_1001062E0(v153, v157, v154);
            unint64_t v160 = (v156 & ~(_DWORD)v362) == 0;
            goto LABEL_39;
          }

          sub_10005802C((uint64_t)v140, type metadata accessor for NANAttribute);
        }

        sub_100058090(&v396, &v387);
        unint64_t v162 = NANBitmap.Channel.operatingClass.getter(&v387);
        swift_bridgeObjectRetain(*(void *)(v162 + 16));
        Array<A>.retrieve(attribute:)(16, v139, (uint64_t)v141);
        sub_1001074E8( (uint64_t)&v396,  (void (*)(void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, __int16))sub_1000578CC);
        if (v144(v141, 1LL, v143) == 1)
        {
          swift_bridgeObjectRelease(v373);
          sub_1000225EC((uint64_t)v141, &qword_10040D440);
LABEL_46:
          uint64_t v190 = *(void *)(v128 + qword_10040D290);
          uint64_t v191 = swift_unownedRetainStrong(v190);
          __int128 v195 = sub_1002E8D68(v191, v192, v193, v194);
          swift_release(v190);
          sub_10027EBBC((uint64_t)v374, v80, v79, 0xD00000000000002FLL, 0x80000001003684A0LL);
          sub_1001074E8( (uint64_t)&v396,  (void (*)(void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, __int16))sub_1000578CC);
          swift_release(v195);
          goto LABEL_23;
        }

        if (swift_getEnumCaseMultiPayload(v141, v143) != 16)
        {
          swift_bridgeObjectRelease(v373);
          sub_10005802C((uint64_t)v141, type metadata accessor for NANAttribute);
          goto LABEL_46;
        }

        v349 = v127;
        v350 = v79;
        unint64_t v348 = *v141;
        int64_t v159 = v141[3];
        uint64_t v147 = v141[5];
        unint64_t v148 = v141[6];
        unint64_t v163 = v141[7];
        int64_t v164 = v141[8];
        __int128 v165 = v141[10];
        uint64_t v166 = *((void *)v141 + 3);
        uint64_t v167 = *((void *)v141 + 4);
        uint64_t v168 = *((void *)v141 + 5);
        unint64_t v158 = v141[4];
        LOBYTE(v394) = v159;
        HIBYTE(v394) = v158;
        LOBYTE(v395) = v147;
        BYTE1(v395) = v148;
        ObjectType = v163;
        BYTE2(v395) = v163;
        uint64x2_t v365 = v164;
        HIBYTE(v395) = v164;
        sub_1001062A0(v166, v167, v168);
        uint64_t v169 = *(unsigned __int8 *)NANAttribute.Datapath.Control.security.unsafeMutableAddressor();
        uint64_t v351 = v168;
        unint64_t v352 = v166;
        uint64_t v363 = (unsigned __int8 *)v167;
        sub_1001062E0(v166, v167, v168);
        unint64_t v160 = (v169 & ~v165) == 0;
LABEL_39:
        uint64_t v170 = v160;
        uint64_t v347 = v170;
        __int128 v171 = static WiFiAddress.!= infix(_:_:)( (ObjectType << 32) | (v365 << 40) | ((unint64_t)v148 << 24) | ((unint64_t)v147 << 16) | ((unint64_t)v158 << 8) | v159,  v364);
        uint64_t v172 = (char *)v378;
        uint64_t v173 = (int *)v361;
        if (v171)
        {
          sub_1001074E8( (uint64_t)&v396,  (void (*)(void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, __int16))sub_100107584);
          __int128 v174 = v172;
          sub_1001074E8( (uint64_t)&v396,  (void (*)(void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, __int16))sub_100107584);
          uint64_t v175 = v174;
          uint64_t v176 = (os_log_s *)Logger.logObject.getter(v175);
          __int128 v177 = static os_log_type_t.error.getter(v176);
          if (os_log_type_enabled(v176, v177))
          {
            uint64_t v178 = swift_slowAlloc(32LL, -1LL);
            uint64_t v179 = (char **)swift_slowAlloc(8LL, -1LL);
            ObjectType = swift_slowAlloc(64LL, -1LL);
            __int8 v387 = ObjectType;
            *(_DWORD *)uint64_t v178 = 138412802;
            *(void *)&uint64_t v399 = v175;
            __int128 v180 = v175;
            UnsafeMutableRawBufferPointer.copyMemory(from:)(&v399, (char *)&v399 + 8);
            *uint64_t v179 = v175;

            *(_WORD *)(v178 + 12) = 2080;
            uint64_t v181 = WiFiAddress.description.getter(v364);
            __int128 v183 = v182;
            *(void *)&uint64_t v399 = sub_10000235C(v181, v182, &v387);
            UnsafeMutableRawBufferPointer.copyMemory(from:)(&v399, (char *)&v399 + 8);
            swift_bridgeObjectRelease(v183);
            sub_1001074E8( (uint64_t)&v396,  (void (*)(void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, __int16))sub_1000578CC);
            sub_1001074E8( (uint64_t)&v396,  (void (*)(void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, __int16))sub_1000578CC);
            *(_WORD *)(v178 + 22) = 2080;
            uint64_t v173 = (int *)v361;
            swift_beginAccess(&v394, &v379, 0LL, 0LL);
            uint64_t v184 = WiFiAddress.description.getter(v394 | ((unint64_t)v395 << 16));
            __int128 v186 = v185;
            *(void *)&uint64_t v399 = sub_10000235C(v184, v185, &v387);
            UnsafeMutableRawBufferPointer.copyMemory(from:)(&v399, (char *)&v399 + 8);
            swift_bridgeObjectRelease(v186);
            _os_log_impl( (void *)&_mh_execute_header,  v176,  v177,  "%@ bad initiator data address in the event %s compared to attributes %s",  (uint8_t *)v178,  0x20u);
            __int128 v187 = sub_100002274(&qword_100404DE0);
            swift_arrayDestroy(v179, 1LL, v187);
            __int128 v188 = v179;
            uint64_t v172 = (char *)v378;
            swift_slowDealloc(v188, -1LL, -1LL);
            __int128 v189 = ObjectType;
            swift_arrayDestroy(ObjectType, 2LL, &type metadata for Any[8]);
            swift_slowDealloc(v189, -1LL, -1LL);
            swift_slowDealloc(v178, -1LL, -1LL);
          }

          else
          {

            sub_1001074E8( (uint64_t)&v396,  (void (*)(void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, __int16))sub_1000578CC);
            sub_1001074E8( (uint64_t)&v396,  (void (*)(void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, __int16))sub_1000578CC);
          }
        }

        uint64_t v196 = &v172[qword_100410A28];
        swift_beginAccess(&v172[qword_100410A28], &v386, 0LL, 0LL);
        sub_1000226B0((uint64_t)&v196[v173[22]], (uint64_t)&v387, &qword_100409E58);
        if (v391 == 255)
        {
          uint64_t v197 = &qword_100409E58;
          __int128 v198 = &v387;
LABEL_62:
          sub_1000225EC((uint64_t)v198, v197);
LABEL_63:
          uint64_t v219 = *(void *)&v196[v173[21] + 16];
          if (!*(void *)(v219 + 16))
          {
            uint64_t v237 = *(void *)&v172[qword_10040D290];
            swift_unownedRetainStrong(v237);
            uint64_t v238 = v356;
            WiFiInterface.preferences.getter();
            swift_release(v237);
            uint64_t v239 = v358;
            LOBYTE(v237) = Preferences.automaticallyUseEncryption.getter(v358);
            (*(void (**)(unint64_t, uint64_t))(v357 + 8))(v238, v239);
            char v215 = 1LL;
            if ((v237 & 1) != 0)
            {
              uint64_t v362 = 0LL;
              ObjectType = 0LL;
              uint64x2_t v365 = 0LL;
              uint64_t v235 = 0LL;
              unint64_t v372 = 0LL;
              uint64_t v240 = 2;
            }

            else
            {
              uint64_t v362 = 0LL;
              ObjectType = 0LL;
              uint64x2_t v365 = 0LL;
              uint64_t v235 = 0LL;
              unint64_t v372 = 0LL;
              if (v196[v173[24]]) {
                uint64_t v240 = 1;
              }
              else {
                uint64_t v240 = 2;
              }
            }

            LODWORD(v366) = v240;
LABEL_100:
            unint64_t v284 = swift_bridgeObjectRetain(v373);
            uint64_t v285 = (os_log_s *)Logger.logObject.getter(v284);
            uint64_t v286 = static os_log_type_t.default.getter();
            uint64_t v287 = os_log_type_enabled(v285, v286);
            uint64_t v367 = v235;
            if (v287)
            {
              uint64_t v288 = swift_slowAlloc(22LL, -1LL);
              uint64_t v289 = swift_slowAlloc(64LL, -1LL);
              __int8 v387 = v289;
              *(_DWORD *)uint64_t v288 = 136315394;
              uint64_t v290 = v215;
              uint64_t v291 = v373;
              swift_bridgeObjectRetain(v373);
              *(void *)&uint64_t v399 = sub_10000235C(v349, v291, &v387);
              uint64_t v371 = (uint64_t)v196;
              UnsafeMutableRawBufferPointer.copyMemory(from:)(&v399, (char *)&v399 + 8);
              uint64_t v292 = v291;
              char v215 = v290;
              swift_bridgeObjectRelease_n(v292, 3LL);
              *(_WORD *)(v288 + 12) = 2080;
              else {
                uint64_t v293 = 0x6465747065636361LL;
              }
              *(void *)&uint64_t v399 = sub_10000235C(v293, 0xE800000000000000LL, &v387);
              uint64_t v196 = (char *)v371;
              uint64_t v172 = (char *)v378;
              UnsafeMutableRawBufferPointer.copyMemory(from:)(&v399, (char *)&v399 + 8);
              swift_bridgeObjectRelease(0xE800000000000000LL);
              _os_log_impl( (void *)&_mh_execute_header,  v285,  v286,  "Configuring datapath responder for peer: %s, with status: %s",  (uint8_t *)v288,  0x16u);
              swift_arrayDestroy(v289, 2LL, &type metadata for Any[8]);
              uint64_t v294 = v289;
              uint64_t v173 = (int *)v361;
              swift_slowDealloc(v294, -1LL, -1LL);
              swift_slowDealloc(v288, -1LL, -1LL);
            }

            else
            {
              swift_bridgeObjectRelease_n(v373, 2LL);
            }

            swift_beginAccess(&v394, &v385, 0LL, 0LL);
            __int16 v295 = v394;
            uint64_t v296 = HIBYTE(v394);
            uint64_t v297 = v395;
            uint64_t v371 = BYTE1(v395);
            v370 = BYTE2(v395);
            unint64_t v368 = HIBYTE(v395);
            uint64_t v298 = *(void *)&v172[qword_10040D290];
            uint64_t v299 = swift_unownedRetainStrong(v298);
            v303 = sub_1002E8D68(v299, v300, v301, v302);
            swift_release(v298);
            swift_unownedRetainStrong(v298);
            unint64_t v357 = WiFiInterface.macAddress.getter();
            swift_release(v298);
            uint64_t v304 = v196[84];
            uint64_t v305 = v196[85];
            uint64_t v306 = (unint64_t)*(unsigned int *)(v196 + 86) << 16;
            __int16 v307 = *((void *)v196 + 1);
            uint64_t v308 = *((void *)v196 + 2);
            uint64_t v309 = v196[v173[21] + 2];
            uint64_t v364 = v296;
            unint64_t v373 = v297;
            uint64_t v360 = v295;
            uint64_t v361 = v303;
            uint64_t v359 = v307;
            LODWORD(v358) = v309;
            __int8 v355 = v305;
            unint64_t v356 = v304;
            v349 = v306;
            if (v215)
            {
              uint64_t v310 = v215;
              if (v347)
              {
                uint64_t v311 = type metadata accessor for __DataStorage(0LL);
                swift_allocObject(v311, *(unsigned int *)(v311 + 48), *(unsigned __int16 *)(v311 + 52));
                swift_bridgeObjectRetain(v308);
                uint64_t v312 = __DataStorage.init(length:)(32LL);
                uint64_t v313 = 0LL;
                uint64_t v314 = 0LL;
                v315 = 0LL;
                v316 = v312 | 0x4000000000000000LL;
                uint64_t v317 = 0xF000000000000000LL;
                unint64_t v318 = 0x2000000000LL;
              }

              else
              {
                swift_bridgeObjectRetain(v308);
                uint64_t v313 = 0LL;
                unint64_t v318 = 0LL;
                v316 = 0LL;
                uint64_t v314 = 0LL;
                uint64_t v317 = 0LL;
                v315 = 1LL;
              }

              unint64_t v319 = (uint64_t)v362;
              __int8 v321 = v372;
              uint64_t v320 = v367;
            }

            else
            {
              uint64_t v310 = 0LL;
              swift_bridgeObjectRetain(v308);
              v315 = 0LL;
              unint64_t v319 = (uint64_t)v362;
              uint64_t v313 = (uint64_t)v362;
              unint64_t v318 = ObjectType;
              v316 = v365;
              uint64_t v314 = v367;
              uint64_t v320 = v367;
              uint64_t v317 = v372;
              __int8 v321 = v372;
            }

            uint64_t v362 = (unsigned __int8 *)v319;
            *(void *)&uint64_t v399 = v313;
            *((void *)&v399 + 1) = v318;
            *(void *)&uint64_t v400 = v316;
            *((void *)&v400 + 1) = v314;
            uint64_t v401 = v317;
            unint64_t v402 = 0LL;
            uint64_t v403 = v315;
            sub_1000226B0((uint64_t)&v196[v173[22]], (uint64_t)&v383, &qword_100409E58);
            unint64_t v322 = &v196[v173[26]];
            unint64_t v323 = *(unsigned int *)v322 | ((unint64_t)*((unsigned __int16 *)v322 + 2) << 32);
            unint64_t v324 = v322[6];
            uint64_t v325 = v196[v173[27]];
            unint64_t v372 = v321;
            uint64_t v354 = v310;
            sub_10017D3D0(v319, ObjectType, v365, v320, v321, 0LL, v310);
            uint64_t v327 = v351;
            uint64_t v326 = v352;
            uint64_t v328 = (uint64_t)v363;
            sub_1001062A0(v352, (uint64_t)v363, v351);
            uint64_t v329 = v360;
            uint64_t v330 = v364;
            LOBYTE(v387) = v324;
            uint64_t v346 = v325;
            BYTE2(v345) = v366;
            BYTE1(v345) = v348;
            LOBYTE(v345) = v358;
            uint64_t v344 = v308;
            uint64_t v331 = (char)v374;
            v332 = v326;
            NANDatapath.ResponseConfiguration.init(instanceID:publishID:initiatorManagementAddress:initiatorDataAddress:initiatorServiceInfo:responderManagementAddress:responderDataAddress:serviceName:serviceType:dialogToken:status:securityConfiguration:internetSharingConfiguration:multicastAddress:multicastServiceType:)( (char)v374,  v353,  v350,  v360 | (v364 << 8) | (v373 << 16) | (v371 << 24) | (v370 << 32) | (v368 << 40),  v326,  v328,  v327,  v357 & 0xFFFFFFFFFFFFLL,  (uint64_t)&v387,  v356 | (v355 << 8) | v349,  v359,  v344,  v345,  (uint64_t)&v399,  (uint64_t)&v383,  v323,  (v323 | ((unint64_t)v324 << 48)) >> 32,  (v323 | ((unint64_t)v324 << 48)) >> 48,  (v323 | ((unint64_t)v324 << 48)) >> 56,  v346);
            sub_1001074E8( (uint64_t)&v396,  (void (*)(void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, __int16))sub_1000578CC);
            v333 = (uint64_t)v378;
            uint64_t v334 = v361;
            uint64_t v337 = sub_10027F0CC((uint64_t)&v387, (uint64_t)v378, v335, v336);
            swift_release(v334);
            sub_10022B4C0((uint64_t)&v387);
            uint64_t v383 = (uint64_t)v337;
            v382[0] = v331;
            v382[1] = v329;
            v382[2] = v330;
            v382[3] = v373;
            v382[4] = v371;
            v382[5] = v370;
            v382[6] = v368;
            __int8 v338 = (uint64_t *)(v333 + qword_100410A48);
            swift_beginAccess(v333 + qword_100410A48, &v387, 0LL, 0LL);
            __int8 v339 = *v338;
            uint64_t v381 = v339;
            unint64_t v341 = _s17ResponderInstanceCMa(255LL, v375, (uint64_t)v376, v340);
            uint64_t v342 = sub_10017B5C8();
            uint64_t v343 = type metadata accessor for Dictionary(0LL, &type metadata for NANPeerServiceIdentifier, v341, v342);
            swift_bridgeObjectRetain(v339);
            Dictionary.subscript.setter(&v383, v382, v343);
            sub_100257EE0(v381);
            sub_1001062E0(v332, (uint64_t)v363, v327);
            sub_1000AADB0((uint64_t)v362, ObjectType, v365, v367, v372, 0LL, v354);
            goto LABEL_23;
          }

          uint64_t v220 = *(unsigned __int8 *)(v219 + 32);
          ObjectType = *(void *)(v219 + 40);
          char v221 = *(void *)(v219 + 56);
          uint64x2_t v365 = *(void *)(v219 + 48);
          __int128 v222 = *(void *)(v219 + 64);
          __int128 v223 = *(void *)(v219 + 80);
          __int128 v224 = v196[v173[24]];
          uint64_t v362 = (unsigned __int8 *)v220;
          if ((v224 & 1) != 0)
          {
            v225 = type metadata accessor for __DataStorage(0LL);
            swift_allocObject(v225, *(unsigned int *)(v225 + 48), *(unsigned __int16 *)(v225 + 52));
            int v226 = ObjectType;
            __int16 v227 = v365;
            sub_100020AFC(ObjectType, v365);
            uint64_t v228 = v221;
            sub_10002255C(v221, v222);
            swift_bridgeObjectRetain(v223);
            uint64_t v229 = __DataStorage.init(length:)(32LL);
            _s7CoreP2P6NANPMKV23__derived_struct_equalsySbAC_ACtFZ_0(v226, v227);
            uint64_t v231 = v230;
            swift_release(v229);
            unsigned int v232 = (uint64_t)v374;
            if ((v231 & 1) == 0)
            {
              if (v222 >> 60 == 15)
              {
                uint64_t v233 = ObjectType;
                uint64_t v234 = v365;
                sub_100020AFC(ObjectType, v365);
                sub_1000208D8(v233, v234);
                uint64_t v235 = v228;
                uint64_t v236 = v228;
              }

              else
              {
                uint64_t v235 = v228;
                sub_10002255C(v228, v222);
                unint64_t v282 = ObjectType;
                unint64_t v283 = v365;
                sub_100020AFC(ObjectType, v365);
                sub_1000208D8(v282, v283);
                uint64_t v236 = v235;
              }

              sub_100020B40(v236, v222);
              swift_bridgeObjectRelease(v223);
              uint64_t v245 = 1;
              goto LABEL_98;
            }
          }

          else
          {
            sub_100020AFC(ObjectType, v365);
            uint64_t v228 = v221;
            sub_10002255C(v221, v222);
            swift_bridgeObjectRetain(v223);
            unsigned int v232 = (uint64_t)v374;
          }

          v241 = sub_10025C988( v232 | (v353 << 8) | (v372 << 16) | (v371 << 24) | (v370 << 32) | (v368 << 40) | (v367 << 48) | (v366 << 56),  v364,  v360,  v352,  (uint64_t)v363,  v351);
          if (v242 >> 60 != 15)
          {
            uint64_t v246 = v241;
            uint64_t v247 = v242;
            sub_1000208D8(ObjectType, v365);
            sub_100020B40(v228, v222);
            swift_bridgeObjectRelease(v223);
            __int128 v222 = 0xF000000000000000LL;
            LODWORD(v366) = 1;
            ObjectType = v246;
            uint64_t v235 = 0LL;
            uint64x2_t v365 = v247;
LABEL_99:
            unint64_t v372 = v222;
            char v215 = 0LL;
            uint64_t v172 = (char *)v378;
            goto LABEL_100;
          }

          unint64_t v243 = type metadata accessor for __DataStorage(0LL);
          swift_allocObject(v243, *(unsigned int *)(v243 + 48), *(unsigned __int16 *)(v243 + 52));
          unint64_t v244 = __DataStorage.init(length:)(32LL);
          sub_1000208D8(ObjectType, v365);
          sub_100020B40(v228, v222);
          swift_bridgeObjectRelease(v223);
          uint64_t v235 = 0LL;
          uint64x2_t v365 = v244 | 0x4000000000000000LL;
          ObjectType = 0x2000000000LL;
          __int128 v222 = 0xF000000000000000LL;
          uint64_t v245 = 2;
LABEL_98:
          LODWORD(v366) = v245;
          goto LABEL_99;
        }

        if ((v391 & 1) != 0)
        {
          sub_10017B2A8((uint64_t)&v387);
          goto LABEL_63;
        }

        swift_bridgeObjectRelease(v388);
        uint64_t v199 = *(void *)&v172[qword_10040D2A8];
        if (v199
          && (uint64_t v383 = *(void *)&v172[qword_10040D2A8],
              swift_unknownObjectRetain(v199),
              __int128 v200 = sub_100002274(&qword_10040D450),
              uint64_t v201 = sub_100002274(&qword_10040D458),
              (swift_dynamicCast(&v399, &v383, v200, v201, 6LL) & 1) != 0))
        {
          if (*((void *)&v400 + 1))
          {
            sub_1000589F8(&v399, (uint64_t)&v387);
            uint64_t v202 = v389;
            char v203 = v390;
            sub_100021104(&v387, v389);
            ObjectType = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v203 + 24))(v350, v202, v203);
            uint64x2_t v365 = v204;
            if (v204 >> 60 != 15)
            {
              __int128 v205 = *(void *)&v172[qword_10040D290];
              swift_unownedRetainStrong(v205);
              __int128 v206 = v205 + *(void *)(*(void *)v205 + 656LL);
              swift_beginAccess(v206, &v380, 0LL, 0LL);
              __int8 v207 = v354;
              sub_100057FE8(v206, v354, type metadata accessor for NANDriverCapabilities);
              swift_release(v205);
              uint64_t v208 = *(void *)(v207 + 8);
              swift_bridgeObjectRetain(v208);
              sub_10005802C(v207, type metadata accessor for NANDriverCapabilities);
              *(void *)&uint64_t v399 = v208;
              char v209 = sub_100002274((uint64_t *)&unk_10040D460);
              __int128 v210 = sub_1000E7D6C();
              __int128 v211 = Collection<>.strongestSupportedSharedKeySuite.getter(v209, v210);
              swift_bridgeObjectRelease(v208);
              if (v211 != 8)
              {
                char v215 = 0LL;
                __int128 v216 = v211;
                LODWORD(v366) = 1;
                __int128 v217 = 0xF000000000000000LL;
LABEL_118:
                unint64_t v372 = v217;
                uint64_t v362 = (unsigned __int8 *)v216;
                sub_100002AC4(&v387);
                uint64_t v235 = 0LL;
                goto LABEL_100;
              }

              sub_100020B40(ObjectType, v365);
            }

            __int128 v212 = *(void *)&v172[qword_10040D290];
            swift_unownedRetainStrong(v212);
            uint64_t v213 = (char *)v355;
            WiFiInterface.preferences.getter();
            swift_release(v212);
            uint64_t v214 = v358;
            LOBYTE(v212) = Preferences.automaticallyUseEncryption.getter(v358);
            (*(void (**)(char *, uint64_t))(v357 + 8))(v213, v214);
            char v215 = 1LL;
            __int128 v216 = 0LL;
            if ((v212 & 1) != 0)
            {
              ObjectType = 0LL;
              uint64x2_t v365 = 0LL;
              __int128 v217 = 0LL;
              __int128 v218 = 2;
            }

            else
            {
              ObjectType = 0LL;
              uint64x2_t v365 = 0LL;
              __int128 v217 = 0LL;
              if (v196[v173[24]]) {
                __int128 v218 = 1;
              }
              else {
                __int128 v218 = 2;
              }
            }

            LODWORD(v366) = v218;
            goto LABEL_118;
          }
        }

        else
        {
          uint64_t v401 = 0LL;
          uint64_t v399 = 0u;
          uint64_t v400 = 0u;
        }

        uint64_t v197 = (uint64_t *)&unk_10040D448;
        __int128 v198 = (uint64_t *)&v399;
        goto LABEL_62;
      }

      unint64_t v108 = *(void *)((char *)v378 + qword_10040D290);
      unint64_t v109 = swift_unownedRetainStrong(v108);
      unint64_t v113 = sub_1002E8D68(v109, v110, v111, v112);
      swift_release(v108);
      uint64_t v392 = 0LL;
      uint64_t v393 = (void *)0xE000000000000000LL;
      __int8 v387 = v73;
      uint64_t v114 = ObjectType;
      WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for NSObject, ObjectType);
      DefaultStringInterpolation.appendInterpolation<A>(_:)(&v387, v114, WitnessTable);
      v116._countAndFlagsBits = 0x63616E6920736920LL;
      v116._object = (void *)0xEC00000065766974LL;
      String.append(_:)(v116);
      uint64_t v117 = (unint64_t)v393;
      sub_10027EBBC( (uint64_t)v374,  v67 | (v68 << 8) | (v69 << 16) | (v70 << 24) | (v71 << 32) | (v72 << 40),  v372 | (v371 << 8) | (v370 << 16) | (v368 << 24) | (v367 << 32) | (v366 << 40),  v392,  (unint64_t)v393);
      int v41 = v377;
      swift_release(v113);
      swift_bridgeObjectRelease(v117);
LABEL_22:
      sub_1001074E8( (uint64_t)&v396,  (void (*)(void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, __int16))sub_1000578CC);
      break;
    case 0xCu:
      unsigned __int32 v377 = v41;
      ObjectType = *(void *)(NANBitmap.Channel.operatingClass.getter(v398) + 8);
      unint64_t v83 = v378;
      uint64_t v363 = (unsigned __int8 *)qword_100410A30;
      unint64_t v84 = (void *)&unk_10040D000;
      if (*((_BYTE *)v378 + qword_100410A30) != 1) {
        goto LABEL_84;
      }
      unint64_t v85 = type metadata accessor for P2PTimer(0LL);
      int64_t v86 = v372;
      variable initialization expression of AWDLPeer.lastUpdated();
      unint64_t v87 = (uint64_t)v83 + qword_10040D298;
      unint64_t v88 = swift_beginAccess((char *)v83 + qword_10040D298, &v387, 0LL, 0LL);
      unint64_t v90 = v373;
      unint64_t v89 = (uint64_t)v374;
      int64_t v91 = v364;
      (*(void (**)(unint64_t, uint64_t, char *, __n128))(v373 + 16))(v364, v87, v374, v88);
      uint64_t v92 = v365;
      DispatchTime.distance(to:)(v86);
      uint64_t v93 = *(void (**)(unint64_t, uint64_t))(v90 + 8);
      v93(v91, v89);
      v93(v86, v89);
      uint64_t v94 = NANConstants.maximumServiceRetryRate.unsafeMutableAddressor();
      uint64_t v96 = v366;
      uint64_t v95 = v367;
      uint64_t v97 = v368;
      (*(void (**)(uint64_t, uint64_t, uint64_t))(v367 + 16))(v366, v94, v368);
      LOBYTE(v91) = static DispatchTimeInterval.< infix(_:_:)(v96, v92);
      unint64_t v98 = *(void (**)(uint64_t, uint64_t))(v95 + 8);
      v98(v96, v97);
      v98(v92, v97);
      if ((v91 & 1) != 0)
      {
        unint64_t v99 = v83;
        unint64_t v100 = (os_log_s *)Logger.logObject.getter(v99);
        unint64_t v101 = static os_log_type_t.error.getter(v100);
        if (os_log_type_enabled(v100, (os_log_type_t)v101))
        {
          LODWORD(v365) = v101;
          uint64_t v367 = v87;
          unint64_t v368 = v85;
          int64_t v102 = swift_slowAlloc(22LL, -1LL);
          unint64_t v103 = (char **)swift_slowAlloc(8LL, -1LL);
          uint64_t v366 = swift_slowAlloc(32LL, -1LL);
          uint64_t v392 = v366;
          *(_DWORD *)int64_t v102 = 138412546;
          *(void *)&uint64_t v399 = v99;
          unint64_t v104 = v99;
          UnsafeMutableRawBufferPointer.copyMemory(from:)(&v399, (char *)&v399 + 8);
          *unint64_t v103 = v99;

          *(_WORD *)(v102 + 12) = 2080;
          unint64_t v105 = 0xD000000000000011LL;
          unint64_t v106 = 0x8000000100364DC0LL;
          switch(ObjectType)
          {
            case -1LL:
              break;
            case 1LL:
              unint64_t v105 = 0x754F2064656D6954LL;
              unint64_t v106 = 0xE900000000000074LL;
              break;
            case 2LL:
              unint64_t v105 = 0x7165522072657355LL;
              unint64_t v106 = 0xEE00646574736575LL;
              break;
            case 3LL:
              unint64_t v105 = 0x6961462070696843LL;
              unint64_t v106 = 0xEC0000006572756CLL;
              break;
            case 4LL:
              unint64_t v105 = 0xD000000000000018LL;
              unint64_t v106 = 0x8000000100364D20LL;
              break;
            default:
              unint64_t v106 = 0xE700000000000000LL;
              unint64_t v105 = 0x6E776F6E6B6E55LL;
              break;
          }

          *(void *)&uint64_t v399 = sub_10000235C(v105, v106, &v392);
          UnsafeMutableRawBufferPointer.copyMemory(from:)(&v399, (char *)&v399 + 8);
          swift_bridgeObjectRelease(v106);
          _os_log_impl( (void *)&_mh_execute_header,  v100,  (os_log_type_t)v365,  "%@ got an early termination with reason: %s. Retrying",  (uint8_t *)v102,  0x16u);
          unsigned int v248 = sub_100002274(&qword_100404DE0);
          swift_arrayDestroy(v103, 1LL, v248);
          swift_slowDealloc(v103, -1LL, -1LL);
          unint64_t v249 = v366;
          swift_arrayDestroy(v366, 1LL, &type metadata for Any[8]);
          swift_slowDealloc(v249, -1LL, -1LL);
          swift_slowDealloc(v102, -1LL, -1LL);

          unint64_t v161 = v359;
          unint64_t v87 = v367;
        }

        else
        {

          unint64_t v161 = v359;
        }

        unsigned __int16 v250 = v372;
        variable initialization expression of AWDLPeer.lastUpdated();
        uint64_t v251 = swift_beginAccess(v87, &v392, 33LL, 0LL);
        (*(void (**)(uint64_t, unint64_t, char *, __n128))(v373 + 40))(v87, v250, v374, v251);
        swift_endAccess(&v392);
        uint64_t v252 = *(void *)&v99[qword_10040D290];
        swift_unownedRetainStrong(v252);
        sub_1002E8C08();
        uint64_t v253 = v360;
        swift_release(v252);
        swift_unownedRetainStrong(v252);
        uint64_t v255 = v370;
        uint64_t v254 = v371;
        (*(void (**)(uint64_t, uint64_t, uint64_t))(v370 + 16))( v161,  v252 + *(void *)(*(void *)v252 + 96LL),  v371);
        swift_release(v252);
        __int8 v256 = (uint64_t)&v99[qword_100410A28];
        swift_beginAccess(&v99[qword_100410A28], &v399, 0LL, 0LL);
        sub_100057FE8(v256, v253, type metadata accessor for NANPublish.Configuration);
        uint64_t v257 = swift_getAssociatedConformanceWitness( v376,  v375,  v254,  &protocol requirements base descriptor for NANController,  &associated conformance descriptor for NANController.P2PControls.Driver: NANWiFiDriver);
        (*(void (**)(uint64_t, uint64_t, uint64_t))(v257 + 192))(v253, v254, v257);
        sub_10005802C(v253, type metadata accessor for NANPublish.Configuration);
        (*(void (**)(uint64_t, uint64_t))(v255 + 8))(v161, v254);
      }

      else
      {
LABEL_84:
        v258 = v83;
        v259 = (os_log_s *)Logger.logObject.getter(v258);
        uint64_t v260 = static os_log_type_t.default.getter();
        if (os_log_type_enabled(v259, v260))
        {
          unint64_t v261 = swift_slowAlloc(22LL, -1LL);
          unint64_t v262 = (char **)swift_slowAlloc(8LL, -1LL);
          uint64_t v374 = (char *)swift_slowAlloc(32LL, -1LL);
          uint64_t v392 = (uint64_t)v374;
          *(_DWORD *)unint64_t v261 = 138412546;
          uint64_t v383 = (uint64_t)v258;
          uint64_t v263 = v258;
          UnsafeMutableRawBufferPointer.copyMemory(from:)(&v383, v384);
          *unint64_t v262 = v258;

          *(_WORD *)(v261 + 12) = 2080;
          __int8 v264 = 0xD000000000000011LL;
          unint64_t v265 = 0x8000000100364DC0LL;
          switch(ObjectType)
          {
            case -1LL:
              break;
            case 1LL:
              __int8 v264 = 0x754F2064656D6954LL;
              unint64_t v265 = 0xE900000000000074LL;
              break;
            case 2LL:
              __int8 v264 = 0x7165522072657355LL;
              unint64_t v265 = 0xEE00646574736575LL;
              break;
            case 3LL:
              __int8 v264 = 0x6961462070696843LL;
              unint64_t v265 = 0xEC0000006572756CLL;
              break;
            case 4LL:
              __int8 v264 = 0xD000000000000018LL;
              unint64_t v265 = 0x8000000100364D20LL;
              break;
            default:
              unint64_t v265 = 0xE700000000000000LL;
              __int8 v264 = 0x6E776F6E6B6E55LL;
              break;
          }

          uint64_t v383 = sub_10000235C(v264, v265, &v392);
          UnsafeMutableRawBufferPointer.copyMemory(from:)(&v383, v384);
          swift_bridgeObjectRelease(v265);
          _os_log_impl( (void *)&_mh_execute_header,  v259,  v260,  "%@ was terminated with reason %s",  (uint8_t *)v261,  0x16u);
          unint64_t v266 = sub_100002274(&qword_100404DE0);
          swift_arrayDestroy(v262, 1LL, v266);
          swift_slowDealloc(v262, -1LL, -1LL);
          unint64_t v267 = (uint64_t)v374;
          swift_arrayDestroy(v374, 1LL, &type metadata for Any[8]);
          swift_slowDealloc(v267, -1LL, -1LL);
          swift_slowDealloc(v261, -1LL, -1LL);

          unint64_t v83 = v378;
          unint64_t v84 = &unk_10040D000;
        }

        else
        {
        }

        v363[(void)v83] = 0;
        uint64_t v268 = *(void *)&v258[qword_10040D2A0];
        *(void *)&v258[qword_10040D2A0] = 0LL;
        swift_release(v268);
        uint64_t v269 = qword_10040D2A8;
        uint64_t v270 = *(void **)&v258[qword_10040D2A8];
        if (v270)
        {
          [v270 publishTerminatedWithReason:ObjectType];
          uint64_t v270 = *(void **)&v258[v269];
        }

        *(void *)&v258[v269] = 0LL;
        swift_unknownObjectRelease(v270);
        uint64_t v271 = (uint64_t *)&v258[qword_100410A48];
        swift_beginAccess(&v258[qword_100410A48], &v392, 0LL, 0LL);
        uint64_t v272 = *v271;
        uint64_t v383 = v272;
        v274 = _s17ResponderInstanceCMa(255LL, v375, (uint64_t)v376, v273);
        v275 = sub_10017B5C8();
        type metadata accessor for Dictionary(0LL, &type metadata for NANPeerServiceIdentifier, v274, v275);
        swift_bridgeObjectRetain(v272);
        Dictionary.removeAll(keepingCapacity:)(0);
        sub_100257EE0(v383);
        v276 = *(void *)&v258[v84[82]];
        uint64_t v277 = swift_unownedRetainStrong(v276);
        __int8 v281 = sub_1002E8D68(v277, v278, v279, v280);
        swift_release(v276);
        sub_10027F264((uint64_t)v258);
        swift_release(v281);
      }

      goto LABEL_23;
    case 0xDu:
      int64_t v107 = NANBitmap.Channel.operatingClass.getter(v398);
      sub_10025D2D4(*(void *)v107, *(void *)(v107 + 8), *(void *)(v107 + 16));
      goto LABEL_22;
    default:
      sub_1001074E8( (uint64_t)&v396,  (void (*)(void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, __int16))sub_1000578CC);
      goto LABEL_9;
  }

  return sub_10005802C((uint64_t)v41, type metadata accessor for DriverEvent);
}

  unint64_t v26 = 4;
LABEL_14:
  *((_BYTE *)v1 + 16) = v26;
  return sub_10028BF74(v22);
}

  unint64_t v74 = v146;
  variable initialization expression of AWDLPeer.lastUpdated();
  uint64_t v75 = v130 + qword_10040DD50;
  unint64_t v76 = swift_beginAccess(v130 + qword_10040DD50, &v149, 0LL, 0LL);
  uint64_t v77 = v143;
  __int128 v134 = v75;
  uint64_t v78 = v75;
  uint64_t v79 = v147;
  v124(v143, v78, v147, v76);
  DispatchTime.distance(to:)(v74);
  uint64_t v80 = v77;
  uint64_t v81 = v125;
  v125(v80, v79);
  v81(v74, v79);
  *unint64_t v38 = 5LL;
  unint64_t v82 = v123;
  v126(v38, v129, v123);
  LODWORD(v135) = static DispatchTimeInterval.< infix(_:_:)(v52, (uint64_t)v38);
  LODWORD(v143) = v135 ^ 1;
  v37(v38, v82);
  v37((void *)v52, v82);
  unint64_t v83 = swift_allocObject(&unk_1003F5810, 24LL, 7LL);
  *(void *)(v83 + 16) = _swiftEmptyDictionarySingleton;
  unint64_t v84 = (uint64_t *)(v83 + 16);
  swift_unownedRetainStrong(v18);
  unint64_t v85 = v139;
  int64_t v86 = *(void (**)(char *, uint64_t, uint64_t))(v139 + 16);
  unint64_t v87 = v138;
  unint64_t v88 = AssociatedTypeWitness;
  v86(v138, v18 + *(void *)(*(void *)v18 + 96LL), AssociatedTypeWitness);
  swift_release(v18);
  unint64_t v89 = swift_getAssociatedConformanceWitness( v44,  v51,  v88,  &protocol requirements base descriptor for NANController,  &associated conformance descriptor for NANController.P2PControls.Driver: NANWiFiDriver);
  unint64_t v90 = (*(uint64_t (**)(uint64_t, uint64_t))(v89 + 32))(v88, v89);
  int64_t v91 = *(void (**)(char *, uint64_t))(v85 + 8);
  v91(v87, v88);
  swift_unownedRetainStrong(v18);
  uint64_t v92 = v140;
  v86(v140, v18 + *(void *)(*(void *)v18 + 96LL), v88);
  swift_release(v18);
  uint64_t v93 = (*(uint64_t (**)(uint64_t, uint64_t))(v89 + 24))(v88, v89);
  v91(v92, v88);
  swift_unownedRetainStrong(v18);
  uint64_t v94 = WiFiInterface.capabilities.getter();
  swift_release(v18);
  uint64_t v95 = *WiFiDriverCapabilities.supportsSimultaneousDualBand.unsafeMutableAddressor();
  unint64_t v156 = v94;
  unint64_t v157 = v95;
  uint64_t v96 = sub_100270384();
  swift_bridgeObjectRetain_n(v95, 2LL);
  ExtendableOptionSet.formIntersection(_:)( (uint64_t (*)(_BYTE *, void))&v156,  &type metadata for WiFiDriverCapabilities.Kind,  v96);
  uint64_t v97 = v157;
  LOBYTE(v96) = sub_10007990C(v157, v95);
  swift_bridgeObjectRelease(v94);
  swift_bridgeObjectRelease(v95);
  swift_bridgeObjectRelease(v97);
  if ((v96 & 1) != 0) {
    unint64_t v98 = 0;
  }
  else {
    unint64_t v98 = *(_DWORD *)NANAttribute.CustomDeviceInformation.Flags.doesNotSupportSimultaneousDualBand.unsafeMutableAddressor();
  }
  unint64_t v99 = (uint64_t)v137;
  unint64_t v100 = v144;
  unint64_t v101 = v145;
  int64_t v102 = v130;
  unint64_t v103 = (char)v135;
  NANAttribute.CustomDeviceInformation.CustomAttributes.init()((uint64_t)&v137[*(int *)(v136 + 28)]);
  *(_BYTE *)unint64_t v99 = v90;
  *(_BYTE *)(v99 + 1) = v93;
  *(_DWORD *)(v99 + 4) = v98;
  unint64_t v104 = (uint64_t *)(v102 + qword_10040DD20);
  swift_beginAccess(v102 + qword_10040DD20, &v157, 0LL, 0LL);
  unint64_t v105 = *v104;
  int64_t v107 = v101;
  unint64_t v108 = _s17InitiatorInstanceCMa(0LL, v101, v100, v106);
  swift_bridgeObjectRetain(v105);
  unint64_t v109 = swift_getWitnessTable(&unk_10035EA58, v108);
  __int128 v110 = v143 & 1;
  sub_10028A5EC(v105, v143 & 1, v83, v99, v102, v108, v109);
  swift_bridgeObjectRelease(v105);
  __int128 v111 = (uint64_t *)(v102 + qword_10040DD28);
  swift_beginAccess(v102 + qword_10040DD28, &v156, 0LL, 0LL);
  uint64_t v112 = *v111;
  uint64_t v114 = _s17ResponderInstanceCMa(0LL, v107, v100, v113);
  swift_bridgeObjectRetain(v112);
  unint64_t v115 = swift_getWitnessTable(&unk_10035D5D8, v114);
  sub_10028A5EC(v112, v110, v83, v99, v102, v114, v115);
  swift_bridgeObjectRelease(v112);
  if ((v103 & 1) != 0)
  {
    sub_10005802C(v99, type metadata accessor for NANAttribute.CustomDeviceInformation);
  }

  else
  {
    swift_beginAccess(v84, v155, 0LL, 0LL);
    uint64_t v116 = *v84;
    swift_bridgeObjectRetain(*v84);
    sub_1002FFE64((void (*)(uint64_t))sub_10029FE6C, v102, v116);
    swift_bridgeObjectRelease(v116);
    uint64_t v117 = v146;
    variable initialization expression of AWDLPeer.lastUpdated();
    sub_10005802C(v99, type metadata accessor for NANAttribute.CustomDeviceInformation);
    uint64_t v118 = v134;
    uint64_t v119 = swift_beginAccess(v134, v154, 33LL, 0LL);
    (*(void (**)(uint64_t, char *, uint64_t, __n128))(v142 + 40))(v118, v117, v147, v119);
    swift_endAccess(v154);
  }

  return swift_release(v83);
}

    swift_bridgeObjectRelease(v11);
    uint64_t v5 = v42;
    a1 = v43;
    uint64_t v6 = v41;
    unint64_t v32 = v24;
LABEL_11:
    unint64_t v33 = v6 >> 8;
    isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native(*v5);
    v47[0] = *v5;
    char *v5 = 0x8000000000000000LL;
    swift_bridgeObjectRetain(v46);
    sub_10032F428(v27, v46, v32, v16, isUniquelyReferenced_nonNull_native);
    unint64_t v35 = *v5;
    char *v5 = v47[0];
    swift_bridgeObjectRelease(v35);
    *(void *)a1 = v27;
    *(void *)(a1 + 8) = v46;
    *(_BYTE *)(a1 + 16) = v44;
    uint64_t result = 1LL;
    *(_BYTE *)(a1 + 17) = v33;
    return result;
  }

    swift_bridgeObjectRelease(v4);
LABEL_10:
    Swift::String v19 = 0LL;
    Swift::String v18 = 1;
    return v19 | ((unint64_t)v18 << 48);
  }

uint64_t sub_1000AC1A0()
{
  return PreferenceDefaults.EnableUserspaceP2POptions.description.getter(*v0);
}

_UNKNOWN **static PreferenceDefaults.InternetSharingOptions.allCases.getter()
{
  return &off_1003D6F40;
}

uint64_t PreferenceDefaults.InternetSharingOptions.rawValue.getter(char a1)
{
  if (!a1) {
    return 6710895LL;
  }
  if (a1 == 1) {
    return 0x6775626564LL;
  }
  return 0x61427963696C6F70LL;
}

uint64_t sub_1000AC20C(unsigned __int8 *a1, unsigned __int8 *a2)
{
  return sub_10002A610(*a1, *a2);
}

Swift::Int sub_1000AC218()
{
  int v1 = *v0;
  Hasher.init(_seed:)(v7, 0LL);
  unint64_t v2 = 0xE500000000000000LL;
  uint64_t v3 = 0x6775626564LL;
  if (v1 != 1)
  {
    uint64_t v3 = 0x61427963696C6F70LL;
    unint64_t v2 = 0xEB00000000646573LL;
  }

  if (v1) {
    uint64_t v4 = v3;
  }
  else {
    uint64_t v4 = 6710895LL;
  }
  if (v1) {
    unint64_t v5 = v2;
  }
  else {
    unint64_t v5 = 0xE300000000000000LL;
  }
  String.hash(into:)(v7, v4, v5);
  swift_bridgeObjectRelease(v5);
  return Hasher._finalize()();
}

uint64_t sub_1000AC2B4(uint64_t a1)
{
  unint64_t v2 = 0xE500000000000000LL;
  uint64_t v3 = 0x6775626564LL;
  if (*v1 != 1)
  {
    uint64_t v3 = 0x61427963696C6F70LL;
    unint64_t v2 = 0xEB00000000646573LL;
  }

  if (*v1) {
    uint64_t v4 = v3;
  }
  else {
    uint64_t v4 = 6710895LL;
  }
  if (*v1) {
    unint64_t v5 = v2;
  }
  else {
    unint64_t v5 = 0xE300000000000000LL;
  }
  String.hash(into:)(a1, v4, v5);
  return swift_bridgeObjectRelease(v5);
}

Swift::Int sub_1000AC32C(uint64_t a1)
{
  int v2 = *v1;
  Hasher.init(_seed:)(v8, a1);
  unint64_t v3 = 0xE500000000000000LL;
  uint64_t v4 = 0x6775626564LL;
  if (v2 != 1)
  {
    uint64_t v4 = 0x61427963696C6F70LL;
    unint64_t v3 = 0xEB00000000646573LL;
  }

  if (v2) {
    uint64_t v5 = v4;
  }
  else {
    uint64_t v5 = 6710895LL;
  }
  if (v2) {
    unint64_t v6 = v3;
  }
  else {
    unint64_t v6 = 0xE300000000000000LL;
  }
  String.hash(into:)(v8, v5, v6);
  swift_bridgeObjectRelease(v6);
  return Hasher._finalize()();
}

unint64_t sub_1000AC3C4@<X0>(Swift::String *a1@<X0>, _BYTE *a2@<X8>)
{
  unint64_t result = _s7CoreP2P18PreferenceDefaultsV22InternetSharingOptionsO8rawValueAESgSS_tcfC_0(*a1);
  *a2 = result;
  return result;
}

void sub_1000AC3F0(uint64_t *a1@<X8>)
{
  int v2 = *v1;
  unint64_t v3 = 0xE300000000000000LL;
  unint64_t v4 = 0xE500000000000000LL;
  uint64_t v5 = 0x6775626564LL;
  if (v2 != 1)
  {
    uint64_t v5 = 0x61427963696C6F70LL;
    unint64_t v4 = 0xEB00000000646573LL;
  }

  BOOL v6 = v2 == 0;
  if (*v1) {
    uint64_t v7 = v5;
  }
  else {
    uint64_t v7 = 6710895LL;
  }
  if (!v6) {
    unint64_t v3 = v4;
  }
  *a1 = v7;
  a1[1] = v3;
}

void sub_1000AC44C(void *a1@<X8>)
{
  *a1 = &off_1003D6F68;
}

void *PreferenceDefaults.enableUserspaceP2POptions.unsafeMutableAddressor()
{
  return &static PreferenceDefaults.enableUserspaceP2POptions;
}

uint64_t sub_1000AC468()
{
  uint64_t result = os_variant_allows_internal_security_policies(0LL);
  static PreferenceDefaults.isAppleInternal = result;
  return result;
}

char *PreferenceDefaults.isAppleInternal.unsafeMutableAddressor()
{
  if (qword_100404138 != -1) {
    swift_once(&qword_100404138, sub_1000AC468);
  }
  return &static PreferenceDefaults.isAppleInternal;
}

uint64_t static PreferenceDefaults.isAppleInternal.getter()
{
  return sub_1000AC5FC(&qword_100404138, (unsigned __int8 *)&static PreferenceDefaults.isAppleInternal);
}

id static PreferenceDefaults.deviceName.getter()
{
  id result = (id)MobileGestalt_get_current_device();
  if (result)
  {
    int v1 = result;
    id v2 = (id)MobileGestalt_copy_userAssignedDeviceName_obj();

    if (!v2) {
      return 0LL;
    }
    uint64_t v3 = static String._unconditionallyBridgeFromObjectiveC(_:)(v2);

    return (id)v3;
  }

  else
  {
    __break(1u);
  }

  return result;
}

void sub_1000AC55C()
{
  id v0 = (id)MobileGestalt_get_current_device();
  if (v0)
  {
    int v1 = v0;
    char iPadCapability = MobileGestalt_get_iPadCapability();

    static PreferenceDefaults.isiPad = iPadCapability;
  }

  else
  {
    __break(1u);
  }

char *PreferenceDefaults.isiPad.unsafeMutableAddressor()
{
  if (qword_100404140 != -1) {
    swift_once(&qword_100404140, sub_1000AC55C);
  }
  return &static PreferenceDefaults.isiPad;
}

uint64_t static PreferenceDefaults.isiPad.getter()
{
  return sub_1000AC5FC(&qword_100404140, (unsigned __int8 *)&static PreferenceDefaults.isiPad);
}

uint64_t sub_1000AC5FC(void *a1, unsigned __int8 *a2)
{
  if (*a1 != -1LL) {
    swift_once();
  }
  return *a2;
}

uint64_t PreferencesName.rawValue.getter(unsigned __int8 a1)
{
  return ((uint64_t (*)(unint64_t, unint64_t))((char *)sub_1000AC674 + 4 * byte_10033F1E0[a1]))( 0xD00000000000001ALL,  0x8000000100361590LL);
}

uint64_t sub_1000AC674()
{
  return v0 - 1;
}

uint64_t sub_1000AC80C(unsigned __int8 *a1, unsigned __int8 *a2)
{
  unsigned __int8 v2 = *a2;
  uint64_t v3 = PreferencesName.rawValue.getter(*a1);
  uint64_t v5 = v4;
  uint64_t v6 = PreferencesName.rawValue.getter(v2);
  if (v3 == v6 && v5 == v7)
  {
    char v10 = 1;
    uint64_t v9 = v5;
  }

  else
  {
    uint64_t v9 = v7;
    char v10 = _stringCompareWithSmolCheck(_:_:expecting:)(v3, v5, v6, v7, 0LL);
  }

  swift_bridgeObjectRelease(v5);
  swift_bridgeObjectRelease(v9);
  return v10 & 1;
}

Swift::Int sub_1000AC894()
{
  unsigned __int8 v1 = *v0;
  Hasher.init(_seed:)(v6, 0LL);
  uint64_t v2 = PreferencesName.rawValue.getter(v1);
  uint64_t v4 = v3;
  String.hash(into:)(v6, v2, v3);
  swift_bridgeObjectRelease(v4);
  return Hasher._finalize()();
}

uint64_t sub_1000AC8F4(uint64_t a1)
{
  uint64_t v3 = PreferencesName.rawValue.getter(*v1);
  uint64_t v5 = v4;
  String.hash(into:)(a1, v3, v4);
  return swift_bridgeObjectRelease(v5);
}

Swift::Int sub_1000AC934(uint64_t a1)
{
  unsigned __int8 v2 = *v1;
  Hasher.init(_seed:)(v7, a1);
  uint64_t v3 = PreferencesName.rawValue.getter(v2);
  uint64_t v5 = v4;
  String.hash(into:)(v7, v3, v4);
  swift_bridgeObjectRelease(v5);
  return Hasher._finalize()();
}

uint64_t sub_1000AC990@<X0>(uint64_t *a1@<X0>, _BYTE *a2@<X8>)
{
  uint64_t result = _s7CoreP2P15PreferencesNameO8rawValueACSgSS_tcfC_0(*a1, a1[1]);
  *a2 = result;
  return result;
}

uint64_t sub_1000AC9BC@<X0>(uint64_t *a1@<X8>)
{
  uint64_t result = PreferencesName.rawValue.getter(*v1);
  *a1 = result;
  a1[1] = v4;
  return result;
}

uint64_t Preferences.Preference.wrappedValue.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v5 = *(void *)(a1 - 8);
  uint64_t v6 = __chkstk_darwin(a1);
  uint64_t v8 = (char *)&v16 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v9 = *(void *)(v6 + 24);
  uint64_t v10 = type metadata accessor for Optional(0LL, v9);
  uint64_t v11 = *(void *)(v10 - 8);
  __chkstk_darwin(v10);
  uint64_t v13 = (char *)&v16 - v12;
  if (*(_BYTE *)(v2 + *(int *)(a1 + 52)) != 1) {
    return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v9 - 8) + 16LL))( a2,  v2 + *(int *)(a1 + 48),  v9);
  }
  (*(void (**)(void, uint64_t, void))(*(void *)(a1 + 32) + 8LL))( *(unsigned __int8 *)(v2 + *(int *)(a1 + 44)),  v9,  *(void *)(a1 + 16));
  (*(void (**)(char *, uint64_t, uint64_t))(v5 + 16))(v8, v2, a1);
  uint64_t v14 = *(void *)(v9 - 8);
  if ((*(unsigned int (**)(char *, uint64_t, uint64_t))(v14 + 48))(v13, 1LL, v9) == 1)
  {
    (*(void (**)(uint64_t, char *, uint64_t))(v14 + 16))(a2, &v8[*(int *)(a1 + 48)], v9);
    (*(void (**)(char *, uint64_t))(v5 + 8))(v8, a1);
    return (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v13, v10);
  }

  else
  {
    (*(void (**)(char *, uint64_t))(v5 + 8))(v8, a1);
    return (*(uint64_t (**)(uint64_t, char *, uint64_t))(v14 + 32))(a2, v13, v9);
  }

uint64_t Preferences.Preference.wrappedValue.setter(uint64_t a1, uint64_t a2)
{
  return sub_1000AD0C4(a1, a2, (void (*)(void))sub_1000B2CC4);
}

void (*Preferences.Preference.wrappedValue.modify(void *a1, uint64_t a2))(uint64_t **a1, char a2)
{
  uint64_t v5 = malloc(0x30uLL);
  *a1 = v5;
  void *v5 = a2;
  v5[1] = v2;
  uint64_t v6 = *(void *)(a2 + 24);
  v5[2] = v6;
  uint64_t v7 = *(void *)(v6 - 8);
  _OWORD v5[3] = v7;
  size_t v8 = *(void *)(v7 + 64);
  v5[4] = malloc(v8);
  uint64_t v9 = malloc(v8);
  void v5[5] = v9;
  Preferences.Preference.wrappedValue.getter(a2, (uint64_t)v9);
  return sub_1000ACC1C;
}

void sub_1000ACC1C(uint64_t **a1, char a2)
{
}

uint64_t MutableDriverProperty.projectedValue.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(a1 - 8) + 16LL))(a2, v2);
}

Swift::Void __swiftcall Preferences.Preference.reset()()
{
}

uint64_t Preferences.Preference.description.getter(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 24);
  uint64_t v4 = *(void *)(v3 - 8);
  uint64_t v5 = __chkstk_darwin(a1);
  uint64_t v7 = (char *)&v10 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  v12[0] = 0LL;
  v12[1] = 0xE000000000000000LL;
  char v11 = *(_BYTE *)(v1 + *(int *)(v5 + 44));
  _print_unlocked<A, B>(_:_:)( &v11,  v12,  &type metadata for PreferencesName,  &type metadata for DefaultStringInterpolation,  &protocol witness table for DefaultStringInterpolation);
  v8._countAndFlagsBits = 2112800LL;
  v8._object = (void *)0xE300000000000000LL;
  String.append(_:)(v8);
  Preferences.Preference.wrappedValue.getter(a1, (uint64_t)v7);
  DefaultStringInterpolation.appendInterpolation<A>(_:)(v7, v3);
  (*(void (**)(char *, uint64_t))(v4 + 8))(v7, v3);
  return v12[0];
}

uint64_t sub_1000ACD44@<X0>( uint64_t a1@<X0>, int a2@<W1>, uint64_t a3@<X2>, int a4@<W3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X6>, uint64_t a8@<X7>, uint64_t a9@<X8>)
{
  uint64_t v26 = a3;
  uint64_t v27 = a7;
  int v29 = a2;
  int v30 = a4;
  uint64_t v28 = a9;
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  a8,  a6,  &protocol requirements base descriptor for RawRepresentable);
  uint64_t v14 = *(void *)(AssociatedTypeWitness - 8);
  __chkstk_darwin();
  uint64_t v16 = (char *)&v26 - v15;
  uint64_t v17 = *(void *)(a5 - 8);
  __chkstk_darwin();
  Swift::String v19 = (char *)&v26 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  (*(void (**)(char *, uint64_t, uint64_t))(v17 + 16))(v19, a1, a5);
  dispatch thunk of RawRepresentable.rawValue.getter(a6, a8);
  (*(void (**)(uint64_t, uint64_t))(v17 + 8))(a1, a5);
  v31[0] = a5;
  v31[1] = a6;
  uint64_t v20 = v27;
  _OWORD v31[2] = v27;
  void v31[3] = a8;
  uint64_t v21 = type metadata accessor for Preferences.EnumPreference(0LL, (uint64_t)v31);
  uint64_t v22 = v28;
  uint64_t v23 = v28 + *(int *)(v21 + 52);
  (*(void (**)(uint64_t, char *, uint64_t))(v17 + 32))(v23, v19, a5);
  uint64_t v24 = (int *)type metadata accessor for Preferences.Preference(0LL, a5, AssociatedTypeWitness, v20);
  *(_BYTE *)(v23 + v24[11]) = v29;
  (*(void (**)(uint64_t, char *, uint64_t))(v14 + 32))(v23 + v24[12], v16, AssociatedTypeWitness);
  *(_BYTE *)(v23 + v24[13]) = v30;
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a6 - 8) + 32LL))(v22, v26, a6);
}

uint64_t Preferences.EnumPreference.wrappedValue.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v22 = a2;
  uint64_t v4 = *(void *)(a1 - 8);
  uint64_t v5 = __chkstk_darwin(a1);
  uint64_t v7 = (char *)&v19 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v8 = *(void *)(v5 + 40);
  uint64_t v9 = *(void *)(v5 + 24);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v8,  v9,  &protocol requirements base descriptor for RawRepresentable);
  __chkstk_darwin(AssociatedTypeWitness);
  uint64_t v12 = (char *)&v19 - v11;
  uint64_t v13 = type metadata accessor for Optional(0LL, v9);
  uint64_t v20 = *(void *)(v13 - 8);
  uint64_t v21 = v13;
  __chkstk_darwin(v13);
  uint64_t v15 = (char *)&v19 - v14;
  uint64_t v16 = type metadata accessor for Preferences.Preference( 0LL,  *(void *)(a1 + 16),  AssociatedTypeWitness,  *(void *)(a1 + 32));
  Preferences.Preference.wrappedValue.getter(v16, (uint64_t)v12);
  dispatch thunk of RawRepresentable.init(rawValue:)(v12, v9, v8);
  (*(void (**)(char *, uint64_t, uint64_t))(v4 + 16))(v7, v2, a1);
  uint64_t v17 = *(void *)(v9 - 8);
  if ((*(unsigned int (**)(char *, uint64_t, uint64_t))(v17 + 48))(v15, 1LL, v9) == 1)
  {
    (*(void (**)(uint64_t, char *, uint64_t))(v17 + 16))(v22, v7, v9);
    (*(void (**)(char *, uint64_t))(v4 + 8))(v7, a1);
    return (*(uint64_t (**)(char *, uint64_t))(v20 + 8))(v15, v21);
  }

  else
  {
    (*(void (**)(char *, uint64_t))(v4 + 8))(v7, a1);
    return (*(uint64_t (**)(uint64_t, char *, uint64_t))(v17 + 32))(v22, v15, v9);
  }

uint64_t Preferences.EnumPreference.wrappedValue.setter(uint64_t a1, uint64_t a2)
{
  return sub_1000AD0C4(a1, a2, (void (*)(void))sub_1000B2D98);
}

uint64_t sub_1000AD0C4(uint64_t a1, uint64_t a2, void (*a3)(void))
{
  return (*(uint64_t (**)(uint64_t))(*(void *)(*(void *)(a2 + 24) - 8LL) + 8LL))(a1);
}

void (*Preferences.EnumPreference.wrappedValue.modify( void *a1, uint64_t a2))(uint64_t **a1, char a2)
{
  uint64_t v5 = malloc(0x30uLL);
  *a1 = v5;
  void *v5 = a2;
  v5[1] = v2;
  uint64_t v6 = *(void *)(a2 + 24);
  v5[2] = v6;
  uint64_t v7 = *(void *)(v6 - 8);
  _OWORD v5[3] = v7;
  size_t v8 = *(void *)(v7 + 64);
  v5[4] = malloc(v8);
  uint64_t v9 = malloc(v8);
  void v5[5] = v9;
  Preferences.EnumPreference.wrappedValue.getter(a2, (uint64_t)v9);
  return sub_1000AD184;
}

void sub_1000AD184(uint64_t **a1, char a2)
{
}

void sub_1000AD190(uint64_t **a1, char a2, void (*a3)(void *, uint64_t))
{
  uint64_t v4 = *a1;
  uint64_t v5 = (void *)(*a1)[4];
  uint64_t v6 = (void *)(*a1)[5];
  uint64_t v7 = (*a1)[2];
  uint64_t v8 = (*a1)[3];
  uint64_t v9 = **a1;
  if ((a2 & 1) != 0)
  {
    (*(void (**)(uint64_t, void *, uint64_t))(v8 + 16))((*a1)[4], v6, v7);
    a3(v5, v9);
    uint64_t v10 = *(void (**)(void *, uint64_t))(v8 + 8);
    v10(v5, v7);
  }

  else
  {
    a3((void *)(*a1)[5], v9);
    uint64_t v10 = *(void (**)(void *, uint64_t))(v8 + 8);
  }

  v10(v6, v7);
  free(v6);
  free(v5);
  free(v4);
}

Swift::Void __swiftcall Preferences.EnumPreference.reset()()
{
  uint64_t v2 = v0;
  uint64_t v3 = v1 + *(int *)(v0 + 52);
  uint64_t v4 = *(void *)(v0 + 16);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  *(void *)(v0 + 40),  *(void *)(v0 + 24),  &protocol requirements base descriptor for RawRepresentable);
  uint64_t v6 = type metadata accessor for Preferences.Preference(0LL, v4, AssociatedTypeWitness, *(void *)(v2 + 32));
  (*(void (**)(void, void))(*(void *)(v6 + 32) + 32LL))( *(unsigned __int8 *)(v3 + *(int *)(v6 + 44)),  *(void *)(v6 + 16));
}

uint64_t Preferences.EnumPreference.description.getter(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 24);
  uint64_t v4 = *(void *)(v3 - 8);
  uint64_t v5 = __chkstk_darwin(a1);
  uint64_t v7 = (char *)&v13 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  v15[0] = 0LL;
  v15[1] = 0xE000000000000000LL;
  uint64_t v8 = v1 + *(int *)(v5 + 52);
  uint64_t v9 = *(void *)(v5 + 16);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  *(void *)(v5 + 40),  v3,  &protocol requirements base descriptor for RawRepresentable);
  char v14 = *(_BYTE *)(v8
                 + *(int *)(type metadata accessor for Preferences.Preference( 0LL,  v9,  AssociatedTypeWitness,  *(void *)(a1 + 32))
                          + 44));
  _print_unlocked<A, B>(_:_:)( &v14,  v15,  &type metadata for PreferencesName,  &type metadata for DefaultStringInterpolation,  &protocol witness table for DefaultStringInterpolation);
  v11._countAndFlagsBits = 2112800LL;
  v11._object = (void *)0xE300000000000000LL;
  String.append(_:)(v11);
  Preferences.EnumPreference.wrappedValue.getter(a1, (uint64_t)v7);
  DefaultStringInterpolation.appendInterpolation<A>(_:)(v7, v3);
  (*(void (**)(char *, uint64_t))(v4 + 8))(v7, v3);
  return v15[0];
}

uint64_t sub_1000AD3E8@<X0>(char a1@<W1>, char a2@<W2>, uint64_t a3@<X3>, uint64_t a4@<X4>, uint64_t a5@<X8>)
{
  Swift::String v11 = (char *)&v16 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v13 = *(void (**)(char *))(v12 + 32);
  v13(v11);
  __int128 v16 = xmmword_1003398F0;
  ((void (*)(uint64_t, char *, uint64_t))v13)(a5, v11, a3);
  char v14 = (int *)type metadata accessor for Preferences.Preference(0LL, a3, (uint64_t)&type metadata for Data, a4);
  *(_BYTE *)(a5 + v14[11]) = a1;
  uint64_t result = (*(uint64_t (**)(uint64_t, __int128 *, void *))(*(&type metadata for Data - 1) + 32LL))( a5 + v14[12],  &v16,  &type metadata for Data);
  *(_BYTE *)(a5 + v14[13]) = a2;
  return result;
}

uint64_t Preferences.WiFiAddressPreference.wrappedValue.getter(uint64_t a1)
{
  uint64_t v1 = type metadata accessor for Preferences.Preference( 0LL,  *(void *)(a1 + 16),  (uint64_t)&type metadata for Data,  *(void *)(a1 + 24));
  Preferences.Preference.wrappedValue.getter(v1, (uint64_t)v4);
  unint64_t v2 = sub_100212134(v4[0], v4[1]);
  return v2 & 0xFFFFFFFFFFFFLL | ((HIWORD(v2) & 1) << 48);
}

uint64_t Preferences.WiFiAddressPreference.wrappedValue.setter(unint64_t a1, uint64_t a2)
{
  if ((a1 & 0x1000000000000LL) != 0)
  {
    uint64_t v17 = type metadata accessor for Preferences.Preference( 0LL,  *(void *)(a2 + 16),  (uint64_t)&type metadata for Data,  *(void *)(a2 + 24));
    return (*(uint64_t (**)(void, void))(*(void *)(v17 + 32) + 32LL))( *(unsigned __int8 *)(v2 + *(int *)(v17 + 44)),  *(void *)(v17 + 16));
  }

  else
  {
    char v4 = a1;
    unint64_t v5 = a1 >> 8;
    unint64_t v6 = a1 >> 16;
    unint64_t v7 = a1 >> 24;
    unint64_t v8 = HIDWORD(a1);
    unint64_t v9 = a1 >> 40;
    uint64_t v10 = sub_100002274(&qword_1004040A8);
    uint64_t v11 = swift_allocObject(v10, 38LL, 7LL);
    *(_OWORD *)(v11 + 16) = xmmword_10033A980;
    *(_BYTE *)(v11 + 32) = v4;
    *(_BYTE *)(v11 + 33) = v5;
    *(_BYTE *)(v11 + 34) = v6;
    *(_BYTE *)(v11 + 35) = v7;
    *(_BYTE *)(v11 + 36) = v8;
    *(_BYTE *)(v11 + 37) = v9;
    uint64_t v12 = sub_1000FB08C(v11);
    unint64_t v14 = v13;
    swift_bridgeObjectRelease(v11);
    v18[0] = v12;
    v18[1] = v14;
    uint64_t v15 = type metadata accessor for Preferences.Preference( 0LL,  *(void *)(a2 + 16),  (uint64_t)&type metadata for Data,  *(void *)(a2 + 24));
    sub_1000B2CC4((uint64_t)v18, v15);
    return sub_1000208D8(v12, v14);
  }

uint64_t (*Preferences.WiFiAddressPreference.wrappedValue.modify( uint64_t *a1, uint64_t a2))(uint64_t a1)
{
  uint64_t v3 = a1;
  *a1 = a2;
  a1[1] = v2;
  uint64_t v4 = Preferences.WiFiAddressPreference.wrappedValue.getter(a2);
  *((_DWORD *)v3 + 4) = v4;
  v3 += 2;
  *((_WORD *)v3 + 2) = WORD2(v4);
  *((_BYTE *)v3 + 6) = BYTE6(v4) & 1;
  return sub_1000AD698;
}

uint64_t sub_1000AD698(uint64_t a1)
{
  return Preferences.WiFiAddressPreference.wrappedValue.setter( (*(unsigned int *)(a1 + 16) | ((unint64_t)*(unsigned __int16 *)(a1 + 20) << 32)) & 0xFFFFFFFFFFFFLL | ((unint64_t)*(unsigned __int8 *)(a1 + 22) << 48),  *(void *)a1);
}

Swift::Void __swiftcall Preferences.WiFiAddressPreference.reset()()
{
  uint64_t v2 = type metadata accessor for Preferences.Preference( 0LL,  *(void *)(v0 + 16),  (uint64_t)&type metadata for Data,  *(void *)(v0 + 24));
  (*(void (**)(void, void))(*(void *)(v2 + 32) + 32LL))( *(unsigned __int8 *)(v1 + *(int *)(v2 + 44)),  *(void *)(v2 + 16));
}

uint64_t Preferences.WiFiAddressPreference.description.getter(uint64_t a1)
{
  uint64_t v3 = Preferences.WiFiAddressPreference.wrappedValue.getter(a1);
  if ((v3 & 0x1000000000000LL) != 0)
  {
    uint64_t v11 = 0LL;
    unint64_t v12 = 0xE000000000000000LL;
    char v10 = *(_BYTE *)(v1
                   + *(int *)(type metadata accessor for Preferences.Preference( 0LL,  *(void *)(a1 + 16),  (uint64_t)&type metadata for Data,  *(void *)(a1 + 24))
                            + 44));
    _print_unlocked<A, B>(_:_:)( &v10,  &v11,  &type metadata for PreferencesName,  &type metadata for DefaultStringInterpolation,  &protocol witness table for DefaultStringInterpolation);
    v8._countAndFlagsBits = 0x6F646E6172203D20LL;
    v8._object = (void *)0xE90000000000006DLL;
    String.append(_:)(v8);
  }

  else
  {
    uint64_t v4 = v3;
    uint64_t v11 = 0LL;
    unint64_t v12 = 0xE000000000000000LL;
    char v10 = *(_BYTE *)(v1
                   + *(int *)(type metadata accessor for Preferences.Preference( 0LL,  *(void *)(a1 + 16),  (uint64_t)&type metadata for Data,  *(void *)(a1 + 24))
                            + 44));
    _print_unlocked<A, B>(_:_:)( &v10,  &v11,  &type metadata for PreferencesName,  &type metadata for DefaultStringInterpolation,  &protocol witness table for DefaultStringInterpolation);
    v5._countAndFlagsBits = 2112800LL;
    v5._object = (void *)0xE300000000000000LL;
    String.append(_:)(v5);
    v6._countAndFlagsBits = WiFiAddress.description.getter(v4 & 0xFFFFFFFFFFFFLL);
    object = v6._object;
    String.append(_:)(v6);
    swift_bridgeObjectRelease(object);
  }

  return v11;
}

uint64_t Preferences.automaticallyUseEncryption.getter(uint64_t a1)
{
  uint64_t v1 = type metadata accessor for Preferences.Preference( 0LL,  *(void *)(a1 + 16),  (uint64_t)&type metadata for Bool,  *(void *)(a1 + 24));
  Preferences.Preference.wrappedValue.getter(v1, (uint64_t)&v3);
  return v3;
}

uint64_t Preferences.automaticallyUseEncryption.setter(char a1, uint64_t a2)
{
  char v4 = a1;
  uint64_t v2 = type metadata accessor for Preferences.Preference( 0LL,  *(void *)(a2 + 16),  (uint64_t)&type metadata for Bool,  *(void *)(a2 + 24));
  return sub_1000B2CC4((uint64_t)&v4, v2);
}

uint64_t (*Preferences.automaticallyUseEncryption.modify(uint64_t *a1, uint64_t a2))()
{
  uint64_t v3 = (uint64_t)(a1 + 3);
  uint64_t v4 = type metadata accessor for Preferences.Preference( 0LL,  *(void *)(a2 + 16),  (uint64_t)&type metadata for Bool,  *(void *)(a2 + 24));
  *a1 = v4;
  uint64_t v5 = *(void *)(v4 - 8);
  a1[1] = v5;
  a1[2] = (uint64_t)malloc(*(void *)(v5 + 64));
  (*(void (**)(void))(v5 + 16))();
  Preferences.Preference.wrappedValue.getter(v4, v3);
  return sub_1000AD948;
}

uint64_t Preferences.$automaticallyUseEncryption.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4 = type metadata accessor for Preferences.Preference( 0LL,  *(void *)(a1 + 16),  (uint64_t)&type metadata for Bool,  *(void *)(a1 + 24));
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v4 - 8) + 16LL))(a2, v2, v4);
}

uint64_t Preferences.disableAuthentication.getter(uint64_t a1)
{
  uint64_t v1 = type metadata accessor for Preferences.Preference( 0LL,  *(void *)(a1 + 16),  (uint64_t)&type metadata for Bool,  *(void *)(a1 + 24));
  Preferences.Preference.wrappedValue.getter(v1, (uint64_t)&v3);
  return v3;
}

uint64_t Preferences.disableAuthentication.setter(char a1, uint64_t a2)
{
  char v4 = a1;
  uint64_t v2 = type metadata accessor for Preferences.Preference( 0LL,  *(void *)(a2 + 16),  (uint64_t)&type metadata for Bool,  *(void *)(a2 + 24));
  return sub_1000B2CC4((uint64_t)&v4, v2);
}

uint64_t (*Preferences.disableAuthentication.modify(uint64_t *a1, uint64_t a2))()
{
  uint64_t v3 = (uint64_t)(a1 + 3);
  uint64_t v4 = type metadata accessor for Preferences.Preference( 0LL,  *(void *)(a2 + 16),  (uint64_t)&type metadata for Bool,  *(void *)(a2 + 24));
  *a1 = v4;
  uint64_t v5 = *(void *)(v4 - 8);
  a1[1] = v5;
  a1[2] = (uint64_t)malloc(*(void *)(v5 + 64));
  (*(void (**)(void))(v5 + 16))();
  Preferences.Preference.wrappedValue.getter(v4, v3);
  return sub_1000AD948;
}

uint64_t Preferences.$disableAuthentication.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4 = v2 + *(int *)(a1 + 36);
  uint64_t v5 = type metadata accessor for Preferences.Preference( 0LL,  *(void *)(a1 + 16),  (uint64_t)&type metadata for Bool,  *(void *)(a1 + 24));
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v5 - 8) + 16LL))(a2, v4, v5);
}

uint64_t Preferences.subscribeFilterEnabled.getter(uint64_t a1)
{
  uint64_t v1 = type metadata accessor for Preferences.Preference( 0LL,  *(void *)(a1 + 16),  (uint64_t)&type metadata for Bool,  *(void *)(a1 + 24));
  Preferences.Preference.wrappedValue.getter(v1, (uint64_t)&v3);
  return v3;
}

uint64_t Preferences.subscribeFilterEnabled.setter(char a1, uint64_t a2)
{
  char v4 = a1;
  uint64_t v2 = type metadata accessor for Preferences.Preference( 0LL,  *(void *)(a2 + 16),  (uint64_t)&type metadata for Bool,  *(void *)(a2 + 24));
  return sub_1000B2CC4((uint64_t)&v4, v2);
}

uint64_t (*Preferences.subscribeFilterEnabled.modify(uint64_t *a1, uint64_t a2))()
{
  uint64_t v3 = (uint64_t)(a1 + 3);
  uint64_t v4 = type metadata accessor for Preferences.Preference( 0LL,  *(void *)(a2 + 16),  (uint64_t)&type metadata for Bool,  *(void *)(a2 + 24));
  *a1 = v4;
  uint64_t v5 = *(void *)(v4 - 8);
  a1[1] = v5;
  a1[2] = (uint64_t)malloc(*(void *)(v5 + 64));
  (*(void (**)(void))(v5 + 16))();
  Preferences.Preference.wrappedValue.getter(v4, v3);
  return sub_1000AD948;
}

uint64_t Preferences.$subscribeFilterEnabled.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4 = v2 + *(int *)(a1 + 40);
  uint64_t v5 = type metadata accessor for Preferences.Preference( 0LL,  *(void *)(a1 + 16),  (uint64_t)&type metadata for Bool,  *(void *)(a1 + 24));
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v5 - 8) + 16LL))(a2, v4, v5);
}

uint64_t Preferences.unsolicitedPublishOnUpdate.getter(uint64_t a1)
{
  uint64_t v1 = type metadata accessor for Preferences.Preference( 0LL,  *(void *)(a1 + 16),  (uint64_t)&type metadata for Bool,  *(void *)(a1 + 24));
  Preferences.Preference.wrappedValue.getter(v1, (uint64_t)&v3);
  return v3;
}

uint64_t Preferences.unsolicitedPublishOnUpdate.setter(char a1, uint64_t a2)
{
  char v4 = a1;
  uint64_t v2 = type metadata accessor for Preferences.Preference( 0LL,  *(void *)(a2 + 16),  (uint64_t)&type metadata for Bool,  *(void *)(a2 + 24));
  return sub_1000B2CC4((uint64_t)&v4, v2);
}

uint64_t (*Preferences.unsolicitedPublishOnUpdate.modify(uint64_t *a1, uint64_t a2))()
{
  uint64_t v3 = (uint64_t)(a1 + 3);
  uint64_t v4 = type metadata accessor for Preferences.Preference( 0LL,  *(void *)(a2 + 16),  (uint64_t)&type metadata for Bool,  *(void *)(a2 + 24));
  *a1 = v4;
  uint64_t v5 = *(void *)(v4 - 8);
  a1[1] = v5;
  a1[2] = (uint64_t)malloc(*(void *)(v5 + 64));
  (*(void (**)(void))(v5 + 16))();
  Preferences.Preference.wrappedValue.getter(v4, v3);
  return sub_1000AD948;
}

uint64_t Preferences.$unsolicitedPublishOnUpdate.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4 = v2 + *(int *)(a1 + 44);
  uint64_t v5 = type metadata accessor for Preferences.Preference( 0LL,  *(void *)(a1 + 16),  (uint64_t)&type metadata for Bool,  *(void *)(a1 + 24));
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v5 - 8) + 16LL))(a2, v4, v5);
}

uint64_t Preferences.unsolicitedPublishSeconds.getter(uint64_t a1)
{
  uint64_t v1 = type metadata accessor for Preferences.Preference( 0LL,  *(void *)(a1 + 16),  (uint64_t)&type metadata for UInt32,  *(void *)(a1 + 24));
  Preferences.Preference.wrappedValue.getter(v1, (uint64_t)&v3);
  return v3;
}

uint64_t Preferences.unsolicitedPublishSeconds.setter(int a1, uint64_t a2)
{
  int v4 = a1;
  uint64_t v2 = type metadata accessor for Preferences.Preference( 0LL,  *(void *)(a2 + 16),  (uint64_t)&type metadata for UInt32,  *(void *)(a2 + 24));
  return sub_1000B2CC4((uint64_t)&v4, v2);
}

uint64_t (*Preferences.unsolicitedPublishSeconds.modify(void *a1, uint64_t a2))()
{
  int v4 = malloc(0x28uLL);
  *a1 = v4;
  uint64_t v5 = type metadata accessor for Preferences.Preference( 0LL,  *(void *)(a2 + 16),  (uint64_t)&type metadata for UInt32,  *(void *)(a2 + 24));
  void *v4 = v5;
  uint64_t v6 = *(void *)(v5 - 8);
  v4[1] = v6;
  uint64_t v4[2] = malloc(*(void *)(v6 + 64));
  (*(void (**)(void))(v6 + 16))();
  Preferences.Preference.wrappedValue.getter(v5, (uint64_t)(v4 + 3));
  return sub_1000ADF70;
}

uint64_t Preferences.$unsolicitedPublishSeconds.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4 = v2 + *(int *)(a1 + 48);
  uint64_t v5 = type metadata accessor for Preferences.Preference( 0LL,  *(void *)(a1 + 16),  (uint64_t)&type metadata for UInt32,  *(void *)(a1 + 24));
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v5 - 8) + 16LL))(a2, v4, v5);
}

uint64_t Preferences.internetSharingOptions.getter(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 24);
  v4[0] = *(void *)(a1 + 16);
  v4[1] = &type metadata for PreferenceDefaults.InternetSharingOptions;
  uint64_t v4[2] = v1;
  v4[3] = sub_1000B2E80();
  uint64_t v2 = type metadata accessor for Preferences.EnumPreference(0LL, (uint64_t)v4);
  Preferences.EnumPreference.wrappedValue.getter(v2, (uint64_t)v4);
  return LOBYTE(v4[0]);
}

uint64_t Preferences.internetSharingOptions.setter(char a1, uint64_t a2)
{
  char v6 = a1;
  uint64_t v2 = *(void *)(a2 + 24);
  v5[0] = *(void *)(a2 + 16);
  v5[1] = &type metadata for PreferenceDefaults.InternetSharingOptions;
  v5[2] = v2;
  _OWORD v5[3] = sub_1000B2E80();
  unsigned int v3 = (uint64_t *)type metadata accessor for Preferences.EnumPreference(0LL, (uint64_t)v5);
  return sub_1000B2D98((uint64_t)&v6, v3);
}

void (*Preferences.internetSharingOptions.modify(void *a1, uint64_t a2))(uint64_t a1, char a2)
{
  uint64_t v4 = malloc(0x40uLL);
  *a1 = v4;
  uint64_t v5 = *(void *)(a2 + 16);
  uint64_t v6 = *(void *)(a2 + 24);
  unint64_t v7 = sub_1000B2E80();
  void *v4 = v5;
  v4[1] = &type metadata for PreferenceDefaults.InternetSharingOptions;
  uint64_t v4[2] = v6;
  v4[3] = v7;
  uint64_t v8 = type metadata accessor for Preferences.EnumPreference(0LL, (uint64_t)v4);
  void v4[4] = v8;
  uint64_t v9 = *(void *)(v8 - 8);
  v4[5] = v9;
  void v4[6] = malloc(*(void *)(v9 + 64));
  (*(void (**)(void))(v9 + 16))();
  Preferences.EnumPreference.wrappedValue.getter(v8, (uint64_t)(v4 + 7));
  return sub_1000AE144;
}

void sub_1000AE144(uint64_t a1, char a2)
{
  uint64_t v2 = *(_BYTE **)a1;
  char v3 = *(_BYTE *)(*(void *)a1 + 56LL);
  uint64_t v5 = *(void *)(*(void *)a1 + 40LL);
  uint64_t v4 = *(void **)(*(void *)a1 + 48LL);
  uint64_t v6 = *(uint64_t **)(*(void *)a1 + 32LL);
  uint64_t v7 = 57LL;
  if ((a2 & 1) != 0)
  {
    uint64_t v8 = *(void *)a1 + 57LL;
  }

  else
  {
    uint64_t v7 = 58LL;
    uint64_t v8 = *(void *)a1 + 58LL;
  }

  v2[v7] = v3;
  sub_1000B2D98(v8, v6);
  (*(void (**)(void *, uint64_t *))(v5 + 8))(v4, v6);
  free(v4);
  free(v2);
}

uint64_t Preferences.$internetSharingOptions.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4 = v2 + *(int *)(a1 + 52);
  uint64_t v5 = *(void *)(a1 + 24);
  v8[0] = *(void *)(a1 + 16);
  v8[1] = &type metadata for PreferenceDefaults.InternetSharingOptions;
  _DWORD v8[2] = v5;
  v8[3] = sub_1000B2E80();
  uint64_t v6 = type metadata accessor for Preferences.EnumPreference(0LL, (uint64_t)v8);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v6 - 8) + 16LL))(a2, v4, v6);
}

uint64_t Preferences.createNetworkAgent.getter(uint64_t a1)
{
  uint64_t v1 = type metadata accessor for Preferences.Preference( 0LL,  *(void *)(a1 + 16),  (uint64_t)&type metadata for Bool,  *(void *)(a1 + 24));
  Preferences.Preference.wrappedValue.getter(v1, (uint64_t)&v3);
  return v3;
}

uint64_t Preferences.createNetworkAgent.setter(char a1, uint64_t a2)
{
  char v4 = a1;
  uint64_t v2 = type metadata accessor for Preferences.Preference( 0LL,  *(void *)(a2 + 16),  (uint64_t)&type metadata for Bool,  *(void *)(a2 + 24));
  return sub_1000B2CC4((uint64_t)&v4, v2);
}

uint64_t (*Preferences.createNetworkAgent.modify(uint64_t *a1, uint64_t a2))()
{
  uint64_t v3 = (uint64_t)(a1 + 3);
  uint64_t v4 = type metadata accessor for Preferences.Preference( 0LL,  *(void *)(a2 + 16),  (uint64_t)&type metadata for Bool,  *(void *)(a2 + 24));
  *a1 = v4;
  uint64_t v5 = *(void *)(v4 - 8);
  a1[1] = v5;
  a1[2] = (uint64_t)malloc(*(void *)(v5 + 64));
  (*(void (**)(void))(v5 + 16))();
  Preferences.Preference.wrappedValue.getter(v4, v3);
  return sub_1000AD948;
}

uint64_t Preferences.$createNetworkAgent.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4 = v2 + *(int *)(a1 + 56);
  uint64_t v5 = type metadata accessor for Preferences.Preference( 0LL,  *(void *)(a1 + 16),  (uint64_t)&type metadata for Bool,  *(void *)(a1 + 24));
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v5 - 8) + 16LL))(a2, v4, v5);
}

uint64_t Preferences.edgeKitSupport.getter(uint64_t a1)
{
  uint64_t v1 = type metadata accessor for Preferences.Preference( 0LL,  *(void *)(a1 + 16),  (uint64_t)&type metadata for Bool,  *(void *)(a1 + 24));
  Preferences.Preference.wrappedValue.getter(v1, (uint64_t)&v3);
  return v3;
}

uint64_t Preferences.edgeKitSupport.setter(char a1, uint64_t a2)
{
  char v4 = a1;
  uint64_t v2 = type metadata accessor for Preferences.Preference( 0LL,  *(void *)(a2 + 16),  (uint64_t)&type metadata for Bool,  *(void *)(a2 + 24));
  return sub_1000B2CC4((uint64_t)&v4, v2);
}

uint64_t (*Preferences.edgeKitSupport.modify(uint64_t *a1, uint64_t a2))()
{
  uint64_t v3 = (uint64_t)(a1 + 3);
  uint64_t v4 = type metadata accessor for Preferences.Preference( 0LL,  *(void *)(a2 + 16),  (uint64_t)&type metadata for Bool,  *(void *)(a2 + 24));
  *a1 = v4;
  uint64_t v5 = *(void *)(v4 - 8);
  a1[1] = v5;
  a1[2] = (uint64_t)malloc(*(void *)(v5 + 64));
  (*(void (**)(void))(v5 + 16))();
  Preferences.Preference.wrappedValue.getter(v4, v3);
  return sub_1000AD948;
}

uint64_t Preferences.$edgeKitSupport.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4 = v2 + *(int *)(a1 + 60);
  uint64_t v5 = type metadata accessor for Preferences.Preference( 0LL,  *(void *)(a1 + 16),  (uint64_t)&type metadata for Bool,  *(void *)(a1 + 24));
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v5 - 8) + 16LL))(a2, v4, v5);
}

uint64_t Preferences.linkTestIntervalMinutes.getter(uint64_t a1)
{
  uint64_t v1 = type metadata accessor for Preferences.Preference( 0LL,  *(void *)(a1 + 16),  (uint64_t)&type metadata for UInt32,  *(void *)(a1 + 24));
  Preferences.Preference.wrappedValue.getter(v1, (uint64_t)&v3);
  return v3;
}

uint64_t Preferences.linkTestIntervalMinutes.setter(int a1, uint64_t a2)
{
  int v4 = a1;
  uint64_t v2 = type metadata accessor for Preferences.Preference( 0LL,  *(void *)(a2 + 16),  (uint64_t)&type metadata for UInt32,  *(void *)(a2 + 24));
  return sub_1000B2CC4((uint64_t)&v4, v2);
}

uint64_t (*Preferences.linkTestIntervalMinutes.modify(void *a1, uint64_t a2))()
{
  int v4 = malloc(0x28uLL);
  *a1 = v4;
  uint64_t v5 = type metadata accessor for Preferences.Preference( 0LL,  *(void *)(a2 + 16),  (uint64_t)&type metadata for UInt32,  *(void *)(a2 + 24));
  void *v4 = v5;
  uint64_t v6 = *(void *)(v5 - 8);
  v4[1] = v6;
  uint64_t v4[2] = malloc(*(void *)(v6 + 64));
  (*(void (**)(void))(v6 + 16))();
  Preferences.Preference.wrappedValue.getter(v5, (uint64_t)(v4 + 3));
  return sub_1000ADF70;
}

void sub_1000AE67C(uint64_t **a1, char a2)
{
  uint64_t v2 = *a1;
  int v3 = *((_DWORD *)*a1 + 6);
  uint64_t v5 = (*a1)[1];
  int v4 = (void *)(*a1)[2];
  uint64_t v6 = **a1;
  uint64_t v7 = 32LL;
  if ((a2 & 1) != 0)
  {
    uint64_t v7 = 28LL;
    uint64_t v8 = (uint64_t)*a1 + 28;
  }

  else
  {
    uint64_t v8 = (uint64_t)(*a1 + 4);
  }

  *(_DWORD *)((char *)v2 + v7) = v3;
  sub_1000B2CC4(v8, v6);
  (*(void (**)(void *, uint64_t))(v5 + 8))(v4, v6);
  free(v4);
  free(v2);
}

uint64_t Preferences.$linkTestIntervalMinutes.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4 = v2 + *(int *)(a1 + 64);
  uint64_t v5 = type metadata accessor for Preferences.Preference( 0LL,  *(void *)(a1 + 16),  (uint64_t)&type metadata for UInt32,  *(void *)(a1 + 24));
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v5 - 8) + 16LL))(a2, v4, v5);
}

uint64_t Preferences.disableAWDLLinkWhenInactive.getter(uint64_t a1)
{
  uint64_t v1 = type metadata accessor for Preferences.Preference( 0LL,  *(void *)(a1 + 16),  (uint64_t)&type metadata for Bool,  *(void *)(a1 + 24));
  Preferences.Preference.wrappedValue.getter(v1, (uint64_t)&v3);
  return v3;
}

uint64_t Preferences.disableAWDLLinkWhenInactive.setter(char a1, uint64_t a2)
{
  char v4 = a1;
  uint64_t v2 = type metadata accessor for Preferences.Preference( 0LL,  *(void *)(a2 + 16),  (uint64_t)&type metadata for Bool,  *(void *)(a2 + 24));
  return sub_1000B2CC4((uint64_t)&v4, v2);
}

uint64_t (*Preferences.disableAWDLLinkWhenInactive.modify(uint64_t *a1, uint64_t a2))()
{
  uint64_t v3 = (uint64_t)(a1 + 3);
  uint64_t v4 = type metadata accessor for Preferences.Preference( 0LL,  *(void *)(a2 + 16),  (uint64_t)&type metadata for Bool,  *(void *)(a2 + 24));
  *a1 = v4;
  uint64_t v5 = *(void *)(v4 - 8);
  a1[1] = v5;
  a1[2] = (uint64_t)malloc(*(void *)(v5 + 64));
  (*(void (**)(void))(v5 + 16))();
  Preferences.Preference.wrappedValue.getter(v4, v3);
  return sub_1000AD948;
}

uint64_t Preferences.$disableAWDLLinkWhenInactive.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4 = v2 + *(int *)(a1 + 68);
  uint64_t v5 = type metadata accessor for Preferences.Preference( 0LL,  *(void *)(a1 + 16),  (uint64_t)&type metadata for Bool,  *(void *)(a1 + 24));
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v5 - 8) + 16LL))(a2, v4, v5);
}

uint64_t Preferences.disableMulticastRateAdapter.getter(uint64_t a1)
{
  uint64_t v1 = type metadata accessor for Preferences.Preference( 0LL,  *(void *)(a1 + 16),  (uint64_t)&type metadata for Bool,  *(void *)(a1 + 24));
  Preferences.Preference.wrappedValue.getter(v1, (uint64_t)&v3);
  return v3;
}

uint64_t Preferences.disableMulticastRateAdapter.setter(char a1, uint64_t a2)
{
  char v4 = a1;
  uint64_t v2 = type metadata accessor for Preferences.Preference( 0LL,  *(void *)(a2 + 16),  (uint64_t)&type metadata for Bool,  *(void *)(a2 + 24));
  return sub_1000B2CC4((uint64_t)&v4, v2);
}

uint64_t (*Preferences.disableMulticastRateAdapter.modify(uint64_t *a1, uint64_t a2))()
{
  uint64_t v3 = (uint64_t)(a1 + 3);
  uint64_t v4 = type metadata accessor for Preferences.Preference( 0LL,  *(void *)(a2 + 16),  (uint64_t)&type metadata for Bool,  *(void *)(a2 + 24));
  *a1 = v4;
  uint64_t v5 = *(void *)(v4 - 8);
  a1[1] = v5;
  a1[2] = (uint64_t)malloc(*(void *)(v5 + 64));
  (*(void (**)(void))(v5 + 16))();
  Preferences.Preference.wrappedValue.getter(v4, v3);
  return sub_1000AD948;
}

uint64_t Preferences.$disableMulticastRateAdapter.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4 = v2 + *(int *)(a1 + 72);
  uint64_t v5 = type metadata accessor for Preferences.Preference( 0LL,  *(void *)(a1 + 16),  (uint64_t)&type metadata for Bool,  *(void *)(a1 + 24));
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v5 - 8) + 16LL))(a2, v4, v5);
}

double Preferences.multicastRateAdapterSettlingPER.getter(uint64_t a1)
{
  uint64_t v1 = type metadata accessor for Preferences.Preference( 0LL,  *(void *)(a1 + 16),  (uint64_t)&type metadata for Double,  *(void *)(a1 + 24));
  Preferences.Preference.wrappedValue.getter(v1, (uint64_t)&v3);
  return v3;
}

uint64_t Preferences.multicastRateAdapterSettlingPER.setter(uint64_t a1, double a2)
{
  double v4 = a2;
  uint64_t v2 = type metadata accessor for Preferences.Preference( 0LL,  *(void *)(a1 + 16),  (uint64_t)&type metadata for Double,  *(void *)(a1 + 24));
  return sub_1000B2CC4((uint64_t)&v4, v2);
}

uint64_t (*Preferences.multicastRateAdapterSettlingPER.modify(void *a1, uint64_t a2))()
{
  double v4 = malloc(0x30uLL);
  *a1 = v4;
  uint64_t v5 = type metadata accessor for Preferences.Preference( 0LL,  *(void *)(a2 + 16),  (uint64_t)&type metadata for Double,  *(void *)(a2 + 24));
  v4[3] = v5;
  uint64_t v6 = *(void *)(v5 - 8);
  void v4[4] = v6;
  v4[5] = malloc(*(void *)(v6 + 64));
  (*(void (**)(void))(v6 + 16))();
  Preferences.Preference.wrappedValue.getter(v5, (uint64_t)v4);
  return sub_1000AEB84;
}

uint64_t Preferences.$multicastRateAdapterSettlingPER.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4 = v2 + *(int *)(a1 + 76);
  uint64_t v5 = type metadata accessor for Preferences.Preference( 0LL,  *(void *)(a1 + 16),  (uint64_t)&type metadata for Double,  *(void *)(a1 + 24));
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v5 - 8) + 16LL))(a2, v4, v5);
}

double Preferences.multicastRateAdapterInitialFeedbackInterval.getter(uint64_t a1)
{
  uint64_t v1 = type metadata accessor for Preferences.Preference( 0LL,  *(void *)(a1 + 16),  (uint64_t)&type metadata for Double,  *(void *)(a1 + 24));
  Preferences.Preference.wrappedValue.getter(v1, (uint64_t)&v3);
  return v3;
}

uint64_t Preferences.multicastRateAdapterInitialFeedbackInterval.setter(uint64_t a1, double a2)
{
  double v4 = a2;
  uint64_t v2 = type metadata accessor for Preferences.Preference( 0LL,  *(void *)(a1 + 16),  (uint64_t)&type metadata for Double,  *(void *)(a1 + 24));
  return sub_1000B2CC4((uint64_t)&v4, v2);
}

uint64_t (*Preferences.multicastRateAdapterInitialFeedbackInterval.modify( void *a1, uint64_t a2))()
{
  double v4 = malloc(0x30uLL);
  *a1 = v4;
  uint64_t v5 = type metadata accessor for Preferences.Preference( 0LL,  *(void *)(a2 + 16),  (uint64_t)&type metadata for Double,  *(void *)(a2 + 24));
  v4[3] = v5;
  uint64_t v6 = *(void *)(v5 - 8);
  void v4[4] = v6;
  v4[5] = malloc(*(void *)(v6 + 64));
  (*(void (**)(void))(v6 + 16))();
  Preferences.Preference.wrappedValue.getter(v5, (uint64_t)v4);
  return sub_1000AEB84;
}

void sub_1000AED0C(uint64_t **a1, char a2)
{
  uint64_t v2 = *a1;
  uint64_t v3 = **a1;
  uint64_t v5 = (*a1)[4];
  double v4 = (void *)(*a1)[5];
  uint64_t v6 = (*a1)[3];
  uint64_t v7 = 2LL;
  if ((a2 & 1) != 0)
  {
    uint64_t v7 = 1LL;
    uint64_t v8 = (uint64_t)(*a1 + 1);
  }

  else
  {
    uint64_t v8 = (uint64_t)(*a1 + 2);
  }

  v2[v7] = v3;
  sub_1000B2CC4(v8, v6);
  (*(void (**)(void *, uint64_t))(v5 + 8))(v4, v6);
  free(v4);
  free(v2);
}

uint64_t Preferences.$multicastRateAdapterInitialFeedbackInterval.getter@<X0>( uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4 = v2 + *(int *)(a1 + 80);
  uint64_t v5 = type metadata accessor for Preferences.Preference( 0LL,  *(void *)(a1 + 16),  (uint64_t)&type metadata for Double,  *(void *)(a1 + 24));
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v5 - 8) + 16LL))(a2, v4, v5);
}

uint64_t Preferences.awdl.getter(uint64_t a1)
{
  uint64_t v1 = type metadata accessor for Preferences.Preference( 0LL,  *(void *)(a1 + 16),  (uint64_t)&type metadata for Bool,  *(void *)(a1 + 24));
  Preferences.Preference.wrappedValue.getter(v1, (uint64_t)&v3);
  return v3;
}

uint64_t Preferences.awdl.setter(char a1, uint64_t a2)
{
  char v4 = a1;
  uint64_t v2 = type metadata accessor for Preferences.Preference( 0LL,  *(void *)(a2 + 16),  (uint64_t)&type metadata for Bool,  *(void *)(a2 + 24));
  return sub_1000B2CC4((uint64_t)&v4, v2);
}

uint64_t (*Preferences.awdl.modify(uint64_t *a1, uint64_t a2))()
{
  uint64_t v3 = (uint64_t)(a1 + 3);
  uint64_t v4 = type metadata accessor for Preferences.Preference( 0LL,  *(void *)(a2 + 16),  (uint64_t)&type metadata for Bool,  *(void *)(a2 + 24));
  *a1 = v4;
  uint64_t v5 = *(void *)(v4 - 8);
  a1[1] = v5;
  a1[2] = (uint64_t)malloc(*(void *)(v5 + 64));
  (*(void (**)(void))(v5 + 16))();
  Preferences.Preference.wrappedValue.getter(v4, v3);
  return sub_1000AD948;
}

uint64_t Preferences.$awdl.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4 = v2 + *(int *)(a1 + 84);
  uint64_t v5 = type metadata accessor for Preferences.Preference( 0LL,  *(void *)(a1 + 16),  (uint64_t)&type metadata for Bool,  *(void *)(a1 + 24));
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v5 - 8) + 16LL))(a2, v4, v5);
}

uint64_t Preferences.awdlMACAddress.getter(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = type metadata accessor for Preferences.WiFiAddressPreference(0LL, *(void *)(a1 + 16), *(void *)(a1 + 24), a4);
  unint64_t v5 = Preferences.WiFiAddressPreference.wrappedValue.getter(v4);
  return v5 & 0xFFFFFFFFFFFFLL | ((HIWORD(v5) & 1) << 48);
}

uint64_t Preferences.awdlMACAddress.setter(unint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = type metadata accessor for Preferences.WiFiAddressPreference(0LL, *(void *)(a2 + 16), *(void *)(a2 + 24), a4);
  return Preferences.WiFiAddressPreference.wrappedValue.setter(a1 & 0xFFFFFFFFFFFFLL | ((HIWORD(a1) & 1) << 48), v5);
}

uint64_t (*Preferences.awdlMACAddress.modify(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4))()
{
  uint64_t v5 = type metadata accessor for Preferences.WiFiAddressPreference(0LL, *(void *)(a2 + 16), *(void *)(a2 + 24), a4);
  *(void *)a1 = v5;
  uint64_t v6 = *(void *)(v5 - 8);
  *(void *)(a1 + 8) = v6;
  *(void *)(a1 + 16) = malloc(*(void *)(v6 + 64));
  (*(void (**)(void))(v6 + 16))();
  uint64_t v7 = Preferences.WiFiAddressPreference.wrappedValue.getter(v5);
  *(_DWORD *)(a1 + 24) = v7;
  a1 += 24LL;
  *(_WORD *)(a1 + 4) = WORD2(v7);
  *(_BYTE *)(a1 + 6) = BYTE6(v7) & 1;
  return sub_1000AF088;
}

uint64_t Preferences.$awdlMACAddress.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X3>, uint64_t a3@<X8>)
{
  uint64_t v5 = v3 + *(int *)(a1 + 88);
  uint64_t v6 = type metadata accessor for Preferences.WiFiAddressPreference(0LL, *(void *)(a1 + 16), *(void *)(a1 + 24), a2);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v6 - 8) + 16LL))(a3, v5, v6);
}

uint64_t Preferences.nan.getter(uint64_t a1)
{
  uint64_t v1 = type metadata accessor for Preferences.Preference( 0LL,  *(void *)(a1 + 16),  (uint64_t)&type metadata for Bool,  *(void *)(a1 + 24));
  Preferences.Preference.wrappedValue.getter(v1, (uint64_t)&v3);
  return v3;
}

uint64_t Preferences.nan.setter(char a1, uint64_t a2)
{
  char v4 = a1;
  uint64_t v2 = type metadata accessor for Preferences.Preference( 0LL,  *(void *)(a2 + 16),  (uint64_t)&type metadata for Bool,  *(void *)(a2 + 24));
  return sub_1000B2CC4((uint64_t)&v4, v2);
}

uint64_t (*Preferences.nan.modify(uint64_t *a1, uint64_t a2))()
{
  uint64_t v3 = (uint64_t)(a1 + 3);
  uint64_t v4 = type metadata accessor for Preferences.Preference( 0LL,  *(void *)(a2 + 16),  (uint64_t)&type metadata for Bool,  *(void *)(a2 + 24));
  *a1 = v4;
  uint64_t v5 = *(void *)(v4 - 8);
  a1[1] = v5;
  a1[2] = (uint64_t)malloc(*(void *)(v5 + 64));
  (*(void (**)(void))(v5 + 16))();
  Preferences.Preference.wrappedValue.getter(v4, v3);
  return sub_1000AD948;
}

uint64_t Preferences.$nan.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4 = v2 + *(int *)(a1 + 92);
  uint64_t v5 = type metadata accessor for Preferences.Preference( 0LL,  *(void *)(a1 + 16),  (uint64_t)&type metadata for Bool,  *(void *)(a1 + 24));
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v5 - 8) + 16LL))(a2, v4, v5);
}

uint64_t Preferences.nanMACAddress.getter(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = type metadata accessor for Preferences.WiFiAddressPreference(0LL, *(void *)(a1 + 16), *(void *)(a1 + 24), a4);
  unint64_t v5 = Preferences.WiFiAddressPreference.wrappedValue.getter(v4);
  return v5 & 0xFFFFFFFFFFFFLL | ((HIWORD(v5) & 1) << 48);
}

uint64_t Preferences.nanMACAddress.setter(unint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = type metadata accessor for Preferences.WiFiAddressPreference(0LL, *(void *)(a2 + 16), *(void *)(a2 + 24), a4);
  return Preferences.WiFiAddressPreference.wrappedValue.setter(a1 & 0xFFFFFFFFFFFFLL | ((HIWORD(a1) & 1) << 48), v5);
}

uint64_t (*Preferences.nanMACAddress.modify(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4))()
{
  uint64_t v5 = type metadata accessor for Preferences.WiFiAddressPreference(0LL, *(void *)(a2 + 16), *(void *)(a2 + 24), a4);
  *(void *)a1 = v5;
  uint64_t v6 = *(void *)(v5 - 8);
  *(void *)(a1 + 8) = v6;
  *(void *)(a1 + 16) = malloc(*(void *)(v6 + 64));
  (*(void (**)(void))(v6 + 16))();
  uint64_t v7 = Preferences.WiFiAddressPreference.wrappedValue.getter(v5);
  *(_DWORD *)(a1 + 24) = v7;
  a1 += 24LL;
  *(_WORD *)(a1 + 4) = WORD2(v7);
  *(_BYTE *)(a1 + 6) = BYTE6(v7) & 1;
  return sub_1000AF088;
}

uint64_t Preferences.$nanMACAddress.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X3>, uint64_t a3@<X8>)
{
  uint64_t v5 = v3 + *(int *)(a1 + 96);
  uint64_t v6 = type metadata accessor for Preferences.WiFiAddressPreference(0LL, *(void *)(a1 + 16), *(void *)(a1 + 24), a2);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v6 - 8) + 16LL))(a3, v5, v6);
}

uint64_t Preferences.nanDataMACAddress.getter(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = type metadata accessor for Preferences.WiFiAddressPreference(0LL, *(void *)(a1 + 16), *(void *)(a1 + 24), a4);
  unint64_t v5 = Preferences.WiFiAddressPreference.wrappedValue.getter(v4);
  return v5 & 0xFFFFFFFFFFFFLL | ((HIWORD(v5) & 1) << 48);
}

uint64_t Preferences.nanDataMACAddress.setter(unint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = type metadata accessor for Preferences.WiFiAddressPreference(0LL, *(void *)(a2 + 16), *(void *)(a2 + 24), a4);
  return Preferences.WiFiAddressPreference.wrappedValue.setter(a1 & 0xFFFFFFFFFFFFLL | ((HIWORD(a1) & 1) << 48), v5);
}

uint64_t (*Preferences.nanDataMACAddress.modify(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4))()
{
  uint64_t v5 = type metadata accessor for Preferences.WiFiAddressPreference(0LL, *(void *)(a2 + 16), *(void *)(a2 + 24), a4);
  *(void *)a1 = v5;
  uint64_t v6 = *(void *)(v5 - 8);
  *(void *)(a1 + 8) = v6;
  *(void *)(a1 + 16) = malloc(*(void *)(v6 + 64));
  (*(void (**)(void))(v6 + 16))();
  uint64_t v7 = Preferences.WiFiAddressPreference.wrappedValue.getter(v5);
  *(_DWORD *)(a1 + 24) = v7;
  a1 += 24LL;
  *(_WORD *)(a1 + 4) = WORD2(v7);
  *(_BYTE *)(a1 + 6) = BYTE6(v7) & 1;
  return sub_1000AF088;
}

void sub_1000AF504(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v1 = *(void **)(a1 + 16);
  uint64_t v3 = *(void *)a1;
  Preferences.WiFiAddressPreference.wrappedValue.setter( (*(unsigned int *)(a1 + 24) | ((unint64_t)*(unsigned __int16 *)(a1 + 28) << 32)) & 0xFFFFFFFFFFFFLL | ((unint64_t)*(unsigned __int8 *)(a1 + 30) << 48),  *(void *)a1);
  (*(void (**)(void *, uint64_t))(v2 + 8))(v1, v3);
  free(v1);
}

uint64_t Preferences.$nanDataMACAddress.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X3>, uint64_t a3@<X8>)
{
  uint64_t v5 = v3 + *(int *)(a1 + 100);
  uint64_t v6 = type metadata accessor for Preferences.WiFiAddressPreference(0LL, *(void *)(a1 + 16), *(void *)(a1 + 24), a2);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v6 - 8) + 16LL))(a3, v5, v6);
}

uint64_t Preferences.enableUserspaceP2POptions.getter(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 24);
  v4[0] = *(void *)(a1 + 16);
  v4[1] = &type metadata for PreferenceDefaults.EnableUserspaceP2POptions;
  uint64_t v4[2] = v1;
  v4[3] = sub_1000B2EDC();
  uint64_t v2 = type metadata accessor for Preferences.EnumPreference(0LL, (uint64_t)v4);
  Preferences.EnumPreference.wrappedValue.getter(v2, (uint64_t)v4);
  return v4[0];
}

uint64_t Preferences.enableUserspaceP2POptions.setter(uint64_t a1, uint64_t a2)
{
  uint64_t v6 = a1;
  uint64_t v2 = *(void *)(a2 + 24);
  v5[0] = *(void *)(a2 + 16);
  v5[1] = &type metadata for PreferenceDefaults.EnableUserspaceP2POptions;
  v5[2] = v2;
  _OWORD v5[3] = sub_1000B2EDC();
  uint64_t v3 = (uint64_t *)type metadata accessor for Preferences.EnumPreference(0LL, (uint64_t)v5);
  return sub_1000B2D98((uint64_t)&v6, v3);
}

void (*Preferences.enableUserspaceP2POptions.modify(void *a1, uint64_t a2))(char **a1, char a2)
{
  uint64_t v4 = malloc(0x50uLL);
  *a1 = v4;
  uint64_t v5 = *(void *)(a2 + 16);
  uint64_t v6 = *(void *)(a2 + 24);
  unint64_t v7 = sub_1000B2EDC();
  void *v4 = v5;
  v4[1] = &type metadata for PreferenceDefaults.EnableUserspaceP2POptions;
  uint64_t v4[2] = v6;
  v4[3] = v7;
  uint64_t v8 = type metadata accessor for Preferences.EnumPreference(0LL, (uint64_t)v4);
  v4[7] = v8;
  uint64_t v9 = *(void *)(v8 - 8);
  v4[8] = v9;
  void v4[9] = malloc(*(void *)(v9 + 64));
  (*(void (**)(void))(v9 + 16))();
  Preferences.EnumPreference.wrappedValue.getter(v8, (uint64_t)(v4 + 4));
  return sub_1000AF730;
}

void sub_1000AF730(char **a1, char a2)
{
  uint64_t v2 = *a1;
  uint64_t v3 = *((void *)*a1 + 4);
  uint64_t v5 = *((void *)*a1 + 8);
  uint64_t v4 = (void *)*((void *)*a1 + 9);
  uint64_t v6 = (uint64_t *)*((void *)*a1 + 7);
  uint64_t v7 = 48LL;
  if ((a2 & 1) != 0)
  {
    uint64_t v7 = 40LL;
    uint64_t v8 = (uint64_t)(*a1 + 40);
  }

  else
  {
    uint64_t v8 = (uint64_t)(*a1 + 48);
  }

  *(void *)&v2[v7] = v3;
  sub_1000B2D98(v8, v6);
  (*(void (**)(void *, uint64_t *))(v5 + 8))(v4, v6);
  free(v4);
  free(v2);
}

uint64_t Preferences.$enableUserspaceP2POptions.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4 = v2 + *(int *)(a1 + 104);
  uint64_t v5 = *(void *)(a1 + 24);
  v8[0] = *(void *)(a1 + 16);
  v8[1] = &type metadata for PreferenceDefaults.EnableUserspaceP2POptions;
  _DWORD v8[2] = v5;
  v8[3] = sub_1000B2EDC();
  uint64_t v6 = type metadata accessor for Preferences.EnumPreference(0LL, (uint64_t)v8);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v6 - 8) + 16LL))(a2, v4, v6);
}

uint64_t Preferences.reportSoftErrorsWithTTR.getter(uint64_t a1)
{
  uint64_t v1 = type metadata accessor for Preferences.Preference( 0LL,  *(void *)(a1 + 16),  (uint64_t)&type metadata for Bool,  *(void *)(a1 + 24));
  Preferences.Preference.wrappedValue.getter(v1, (uint64_t)&v3);
  return v3;
}

uint64_t Preferences.reportSoftErrorsWithTTR.setter(char a1, uint64_t a2)
{
  char v4 = a1;
  uint64_t v2 = type metadata accessor for Preferences.Preference( 0LL,  *(void *)(a2 + 16),  (uint64_t)&type metadata for Bool,  *(void *)(a2 + 24));
  return sub_1000B2CC4((uint64_t)&v4, v2);
}

uint64_t (*Preferences.reportSoftErrorsWithTTR.modify(uint64_t *a1, uint64_t a2))()
{
  uint64_t v3 = (uint64_t)(a1 + 3);
  uint64_t v4 = type metadata accessor for Preferences.Preference( 0LL,  *(void *)(a2 + 16),  (uint64_t)&type metadata for Bool,  *(void *)(a2 + 24));
  *a1 = v4;
  uint64_t v5 = *(void *)(v4 - 8);
  a1[1] = v5;
  a1[2] = (uint64_t)malloc(*(void *)(v5 + 64));
  (*(void (**)(void))(v5 + 16))();
  Preferences.Preference.wrappedValue.getter(v4, v3);
  return sub_1000AD948;
}

uint64_t Preferences.$reportSoftErrorsWithTTR.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4 = v2 + *(int *)(a1 + 108);
  uint64_t v5 = type metadata accessor for Preferences.Preference( 0LL,  *(void *)(a1 + 16),  (uint64_t)&type metadata for Bool,  *(void *)(a1 + 24));
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v5 - 8) + 16LL))(a2, v4, v5);
}

uint64_t Preferences.disableWiFiDisconnectRemoteCamera.getter(uint64_t a1)
{
  uint64_t v1 = type metadata accessor for Preferences.Preference( 0LL,  *(void *)(a1 + 16),  (uint64_t)&type metadata for Bool,  *(void *)(a1 + 24));
  Preferences.Preference.wrappedValue.getter(v1, (uint64_t)&v3);
  return v3;
}

uint64_t Preferences.disableWiFiDisconnectRemoteCamera.setter(char a1, uint64_t a2)
{
  char v4 = a1;
  uint64_t v2 = type metadata accessor for Preferences.Preference( 0LL,  *(void *)(a2 + 16),  (uint64_t)&type metadata for Bool,  *(void *)(a2 + 24));
  return sub_1000B2CC4((uint64_t)&v4, v2);
}

uint64_t (*Preferences.disableWiFiDisconnectRemoteCamera.modify(uint64_t *a1, uint64_t a2))()
{
  uint64_t v3 = (uint64_t)(a1 + 3);
  uint64_t v4 = type metadata accessor for Preferences.Preference( 0LL,  *(void *)(a2 + 16),  (uint64_t)&type metadata for Bool,  *(void *)(a2 + 24));
  *a1 = v4;
  uint64_t v5 = *(void *)(v4 - 8);
  a1[1] = v5;
  a1[2] = (uint64_t)malloc(*(void *)(v5 + 64));
  (*(void (**)(void))(v5 + 16))();
  Preferences.Preference.wrappedValue.getter(v4, v3);
  return sub_1000AD948;
}

uint64_t Preferences.$disableWiFiDisconnectRemoteCamera.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4 = v2 + *(int *)(a1 + 112);
  uint64_t v5 = type metadata accessor for Preferences.Preference( 0LL,  *(void *)(a1 + 16),  (uint64_t)&type metadata for Bool,  *(void *)(a1 + 24));
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v5 - 8) + 16LL))(a2, v4, v5);
}

uint64_t Preferences.allowOnenessWombatCoex.getter(uint64_t a1)
{
  uint64_t v1 = type metadata accessor for Preferences.Preference( 0LL,  *(void *)(a1 + 16),  (uint64_t)&type metadata for Bool,  *(void *)(a1 + 24));
  Preferences.Preference.wrappedValue.getter(v1, (uint64_t)&v3);
  return v3;
}

uint64_t Preferences.allowOnenessWombatCoex.setter(char a1, uint64_t a2)
{
  char v4 = a1;
  uint64_t v2 = type metadata accessor for Preferences.Preference( 0LL,  *(void *)(a2 + 16),  (uint64_t)&type metadata for Bool,  *(void *)(a2 + 24));
  return sub_1000B2CC4((uint64_t)&v4, v2);
}

uint64_t (*Preferences.allowOnenessWombatCoex.modify(uint64_t *a1, uint64_t a2))()
{
  uint64_t v3 = (uint64_t)(a1 + 3);
  uint64_t v4 = type metadata accessor for Preferences.Preference( 0LL,  *(void *)(a2 + 16),  (uint64_t)&type metadata for Bool,  *(void *)(a2 + 24));
  *a1 = v4;
  uint64_t v5 = *(void *)(v4 - 8);
  a1[1] = v5;
  a1[2] = (uint64_t)malloc(*(void *)(v5 + 64));
  (*(void (**)(void))(v5 + 16))();
  Preferences.Preference.wrappedValue.getter(v4, v3);
  return sub_1000AD948;
}

void sub_1000AFC60(uint64_t a1, char a2)
{
  char v2 = *(_BYTE *)(a1 + 24);
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v3 = *(void **)(a1 + 16);
  uint64_t v5 = *(void *)a1;
  if ((a2 & 1) != 0)
  {
    *(_BYTE *)(a1 + 25) = v2;
    uint64_t v6 = a1 + 25;
  }

  else
  {
    *(_BYTE *)(a1 + 26) = v2;
    uint64_t v6 = a1 + 26;
  }

  sub_1000B2CC4(v6, v5);
  (*(void (**)(void *, uint64_t))(v4 + 8))(v3, v5);
  free(v3);
}

uint64_t Preferences.$allowOnenessWombatCoex.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4 = v2 + *(int *)(a1 + 116);
  uint64_t v5 = type metadata accessor for Preferences.Preference( 0LL,  *(void *)(a1 + 16),  (uint64_t)&type metadata for Bool,  *(void *)(a1 + 24));
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v5 - 8) + 16LL))(a2, v4, v5);
}

uint64_t Preferences.init(storage:)@<X0>(uint64_t a1@<X1>, uint64_t a2@<X2>, uint64_t a3@<X8>)
{
  uint64_t v6 = *(void *)(a1 - 8);
  __chkstk_darwin();
  uint64_t v8 = (char *)&v75 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  char v10 = v9;
  unint64_t v82 = *(void (**)(char *))(v6 + 16);
  v82(v8);
  LOBYTE(v84) = 1;
  if (qword_100404138 != -1) {
    swift_once(&qword_100404138, sub_1000AC468);
  }
  char v11 = static PreferenceDefaults.isAppleInternal;
  LODWORD(v77) = static PreferenceDefaults.isAppleInternal;
  unint64_t v12 = *(void (**)(uint64_t, char *, uint64_t))(v6 + 32);
  v12(a3, v8, a1);
  uint64_t v13 = type metadata accessor for Preferences.Preference(0LL, a1, (uint64_t)&type metadata for Bool, a2);
  uint64_t v80 = a2;
  unint64_t v14 = (int *)v13;
  *(_BYTE *)(a3 + *(int *)(v13 + 44)) = 0;
  uint64_t v15 = *(void (**)(uint64_t, uint64_t *, void *))(*(&type metadata for Bool - 1) + 32LL);
  v15(a3 + *(int *)(v13 + 48), &v84, &type metadata for Bool);
  *(_BYTE *)(a3 + v14[13]) = v11;
  __int128 v16 = (void (*)(char *, uint64_t, uint64_t))v82;
  ((void (*)(char *, char *, uint64_t))v82)(v8, v10, a1);
  LOBYTE(v84) = 0;
  uint64_t v18 = (int *)type metadata accessor for Preferences(0LL, a1, a2, v17);
  uint64_t v19 = a3 + v18[9];
  v12(v19, v8, a1);
  *(_BYTE *)(v19 + v14[11]) = 1;
  v15(v19 + v14[12], &v84, &type metadata for Bool);
  *(_BYTE *)(v19 + v14[13]) = (_BYTE)v77;
  v16(v8, (uint64_t)v10, a1);
  LOBYTE(v84) = 1;
  uint64_t v20 = a3 + v18[10];
  v12(v20, v8, a1);
  *(_BYTE *)(v20 + v14[11]) = 2;
  v15(v20 + v14[12], &v84, &type metadata for Bool);
  unint64_t v83 = v15;
  *(_BYTE *)(v20 + v14[13]) = 1;
  v16(v8, (uint64_t)v10, a1);
  LOBYTE(v84) = 1;
  uint64_t v21 = v18[11];
  uint64_t v81 = v18;
  uint64_t v22 = a3 + v21;
  v12(a3 + v21, v8, a1);
  uint64_t v79 = v12;
  *(_BYTE *)(v22 + v14[11]) = 3;
  v15(v22 + v14[12], &v84, &type metadata for Bool);
  *(_BYTE *)(v22 + v14[13]) = 1;
  v16(v8, (uint64_t)v10, a1);
  LODWORD(v84) = 4;
  uint64_t v23 = a3 + v18[12];
  v12(v23, v8, a1);
  uint64_t v24 = v80;
  unint64_t v25 = (int *)type metadata accessor for Preferences.Preference(0LL, a1, (uint64_t)&type metadata for UInt32, v80);
  *(_BYTE *)(v23 + v25[11]) = 4;
  uint64_t v26 = v23 + v25[12];
  uint64_t v77 = *(void (**)(uint64_t, uint64_t *, void *))(*(&type metadata for UInt32 - 1) + 32LL);
  v77(v26, &v84, &type metadata for UInt32);
  *(_BYTE *)(v23 + v25[13]) = 1;
  v16(v8, (uint64_t)v10, a1);
  LOBYTE(v84) = 2;
  uint64_t v27 = v81;
  uint64_t v28 = a3 + v81[13];
  unint64_t v29 = sub_1000B2E80();
  sub_1000ACD44( (uint64_t)v8,  5,  (uint64_t)&v84,  1,  a1,  (uint64_t)&type metadata for PreferenceDefaults.InternetSharingOptions,  v24,  v29,  v28);
  v16(v8, (uint64_t)v10, a1);
  LOBYTE(v84) = 0;
  uint64_t v30 = a3;
  uint64_t v78 = a3;
  unint64_t v31 = v27;
  uint64_t v32 = v30 + v27[14];
  unint64_t v33 = v16;
  unint64_t v34 = v79;
  v79(v32, v8, a1);
  *(_BYTE *)(v32 + v14[11]) = 6;
  unint64_t v35 = v83;
  v83(v32 + v14[12], &v84, &type metadata for Bool);
  *(_BYTE *)(v32 + v14[13]) = 1;
  v33(v8, (uint64_t)v10, a1);
  LOBYTE(v84) = 0;
  uint64_t v36 = v31[15];
  uint64_t v37 = v78;
  uint64_t v38 = v78 + v36;
  v34(v78 + v36, v8, a1);
  *(_BYTE *)(v38 + v14[11]) = 13;
  v35(v38 + v14[12], &v84, &type metadata for Bool);
  *(_BYTE *)(v38 + v14[13]) = 1;
  v33(v8, (uint64_t)v10, a1);
  LODWORD(v84) = 60;
  int64_t v39 = v81;
  uint64_t v40 = v37 + v81[16];
  v34(v40, v8, a1);
  *(_BYTE *)(v40 + v25[11]) = 14;
  v77(v40 + v25[12], &v84, &type metadata for UInt32);
  *(_BYTE *)(v40 + v25[13]) = 1;
  int v41 = v82;
  ((void (*)(char *, char *, uint64_t))v82)(v8, v10, a1);
  LOBYTE(v84) = 1;
  uint64_t v42 = v37 + v39[21];
  v34(v42, v8, a1);
  unint64_t v43 = v34;
  *(_BYTE *)(v42 + v14[11]) = 7;
  unint64_t v44 = v83;
  v83(v42 + v14[12], &v84, &type metadata for Bool);
  *(_BYTE *)(v42 + v14[13]) = 1;
  unint64_t v45 = (void (*)(char *, uint64_t, uint64_t))v41;
  ((void (*)(char *, char *, uint64_t))v41)(v8, v10, a1);
  uint64_t v47 = v80;
  unint64_t v46 = v81;
  sub_1000AD3E8(8, 1, a1, v80, v37 + v81[22]);
  v45(v8, (uint64_t)v10, a1);
  LOBYTE(v84) = 1;
  uint64_t v48 = v37 + v46[23];
  v43(v48, v8, a1);
  *(_BYTE *)(v48 + v14[11]) = 9;
  v44(v48 + v14[12], &v84, &type metadata for Bool);
  *(_BYTE *)(v48 + v14[13]) = 1;
  unint64_t v49 = (void (*)(char *, uint64_t, uint64_t))v82;
  ((void (*)(char *, char *, uint64_t))v82)(v8, v10, a1);
  sub_1000AD3E8(10, 1, a1, v47, v37 + v46[24]);
  v49(v8, (uint64_t)v10, a1);
  sub_1000AD3E8(11, 1, a1, v47, v37 + v46[25]);
  v49(v8, (uint64_t)v10, a1);
  uint64_t v84 = 32LL;
  int64_t v50 = v46;
  uint64_t v51 = v37 + v46[26];
  unint64_t v52 = sub_1000B2EDC();
  sub_1000ACD44( (uint64_t)v8,  12,  (uint64_t)&v84,  1,  a1,  (uint64_t)&type metadata for PreferenceDefaults.EnableUserspaceP2POptions,  v47,  v52,  v51);
  unint64_t v53 = v10;
  v49(v8, (uint64_t)v10, a1);
  LOBYTE(v84) = 0;
  uint64_t v54 = v50[27];
  uint64_t v55 = v50;
  uint64_t v56 = v78;
  unint64_t v57 = v79;
  uint64_t v58 = v78 + v54;
  v79(v78 + v54, v8, a1);
  *(_BYTE *)(v58 + v14[11]) = 15;
  uint64_t v59 = v83;
  v83(v58 + v14[12], &v84, &type metadata for Bool);
  *(_BYTE *)(v58 + v14[13]) = 1;
  unint64_t v76 = v53;
  uint64_t v60 = v82;
  ((void (*)(char *, char *, uint64_t))v82)(v8, v53, a1);
  LOBYTE(v84) = 0;
  uint64_t v61 = v56 + v55[28];
  uint64_t v62 = v56;
  v57(v61, v8, a1);
  *(_BYTE *)(v61 + v14[11]) = 16;
  v59(v61 + v14[12], &v84, &type metadata for Bool);
  *(_BYTE *)(v61 + v14[13]) = 1;
  __int128 v63 = (void (*)(char *, uint64_t, uint64_t))v60;
  ((void (*)(char *, char *, uint64_t))v60)(v8, v53, a1);
  LOBYTE(v84) = 1;
  __int128 v64 = v81;
  uint64_t v65 = v62 + v81[29];
  v57(v65, v8, a1);
  *(_BYTE *)(v65 + v14[11]) = 17;
  int v66 = v83;
  v83(v65 + v14[12], &v84, &type metadata for Bool);
  *(_BYTE *)(v65 + v14[13]) = 1;
  int v67 = v76;
  v63(v8, (uint64_t)v76, a1);
  LOBYTE(v84) = 0;
  uint64_t v68 = v62 + v64[17];
  v57(v68, v8, a1);
  *(_BYTE *)(v68 + v14[11]) = 18;
  v66(v68 + v14[12], &v84, &type metadata for Bool);
  *(_BYTE *)(v68 + v14[13]) = 1;
  v63(v8, (uint64_t)v67, a1);
  LOBYTE(v84) = 0;
  uint64_t v69 = v62 + v64[18];
  v57(v69, v8, a1);
  *(_BYTE *)(v69 + v14[11]) = 19;
  v66(v69 + v14[12], &v84, &type metadata for Bool);
  *(_BYTE *)(v69 + v14[13]) = 1;
  v63(v8, (uint64_t)v67, a1);
  uint64_t v84 = 0x3FC999999999999ALL;
  uint64_t v70 = v62 + v64[19];
  v57(v70, v8, a1);
  __int128 v71 = (int *)type metadata accessor for Preferences.Preference(0LL, a1, (uint64_t)&type metadata for Double, v80);
  *(_BYTE *)(v70 + v71[11]) = 20;
  uint64_t v72 = *(void (**)(uint64_t, uint64_t *, void *))(*(&type metadata for Double - 1) + 32LL);
  v72(v70 + v71[12], &v84, &type metadata for Double);
  *(_BYTE *)(v70 + v71[13]) = 1;
  uint64_t v84 = 0x3FE0000000000000LL;
  uint64_t v73 = v62 + v64[20];
  v57(v73, v67, a1);
  *(_BYTE *)(v73 + v71[11]) = 21;
  uint64_t result = ((uint64_t (*)(uint64_t, uint64_t *, void *))v72)(v73 + v71[12], &v84, &type metadata for Double);
  *(_BYTE *)(v73 + v71[13]) = 1;
  return result;
}

uint64_t Preferences.description.getter(uint64_t a1)
{
  uint64_t v2 = v1;
  uint64_t v5 = *(void *)(a1 + 16);
  uint64_t v4 = *(void *)(a1 + 24);
  uint64_t v6 = type metadata accessor for Preferences.Preference(0LL, v5, (uint64_t)&type metadata for Double, v4);
  uint64_t v99 = *(void *)(v6 - 8);
  uint64_t v100 = v6;
  __chkstk_darwin(v6);
  unint64_t v98 = (char *)&v83 - v7;
  unint64_t v8 = sub_1000B2EDC();
  uint64_t v106 = v5;
  int64_t v107 = &type metadata for PreferenceDefaults.EnableUserspaceP2POptions;
  uint64_t v108 = v4;
  unint64_t v109 = v8;
  uint64_t v9 = type metadata accessor for Preferences.EnumPreference(0LL, (uint64_t)&v106);
  uint64_t v10 = *(void *)(v9 - 8);
  uint64_t v96 = v9;
  uint64_t v97 = v10;
  __chkstk_darwin(v9);
  uint64_t v95 = (uint64_t)&v83 - v11;
  unint64_t v12 = sub_1000B2E80();
  uint64_t v106 = v5;
  int64_t v107 = &type metadata for PreferenceDefaults.InternetSharingOptions;
  uint64_t v108 = v4;
  unint64_t v109 = v12;
  uint64_t v13 = type metadata accessor for Preferences.EnumPreference(0LL, (uint64_t)&v106);
  uint64_t v14 = *(void *)(v13 - 8);
  uint64_t v90 = v13;
  uint64_t v91 = v14;
  __chkstk_darwin(v13);
  uint64_t v89 = (uint64_t)&v83 - v15;
  uint64_t v105 = type metadata accessor for Preferences.Preference(0LL, v5, (uint64_t)&type metadata for UInt32, v4);
  uint64_t v92 = *(void *)(v105 - 8);
  __chkstk_darwin(v105);
  unint64_t v104 = (char *)&v83 - v16;
  uint64_t v18 = type metadata accessor for Preferences.WiFiAddressPreference(0LL, v5, v4, v17);
  uint64_t v19 = *(void *)(v18 - 8);
  __chkstk_darwin(v18);
  uint64_t v21 = (char *)&v83 - v20;
  uint64_t v22 = type metadata accessor for Preferences.Preference(0LL, v5, (uint64_t)&type metadata for Bool, v4);
  uint64_t v23 = *(void *)(v22 - 8);
  __chkstk_darwin(v22);
  unint64_t v25 = (char *)&v83 - v24;
  uint64_t v106 = 0LL;
  int64_t v107 = (ValueMetadata *)0xE000000000000000LL;
  uint64_t v26 = v2 + *(int *)(a1 + 84);
  int64_t v102 = *(void (**)(char *, uint64_t, uint64_t))(v23 + 16);
  v102((char *)&v83 - v24, v26, v22);
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for Preferences<A>.Preference<A1>, v22);
  DefaultStringInterpolation.appendInterpolation<A>(_:)(v25, v22, WitnessTable);
  uint64_t v28 = *(void (**)(char *, uint64_t))(v23 + 8);
  v28(v25, v22);
  v29._countAndFlagsBits = 10LL;
  v29._object = (void *)0xE100000000000000LL;
  String.append(_:)(v29);
  uint64_t v30 = v2 + *(int *)(a1 + 88);
  unint64_t v88 = *(void (**)(char *, uint64_t, uint64_t))(v19 + 16);
  unint64_t v85 = v21;
  v88(v21, v30, v18);
  uint64_t v87 = swift_getWitnessTable(&protocol conformance descriptor for Preferences<A>.WiFiAddressPreference, v18);
  DefaultStringInterpolation.appendInterpolation<A>(_:)(v21, v18, v87);
  int64_t v86 = *(void (**)(char *, uint64_t))(v19 + 8);
  v86(v21, v18);
  uint64_t v84 = v106;
  unint64_t v83 = v107;
  uint64_t v106 = 0LL;
  int64_t v107 = (ValueMetadata *)0xE000000000000000LL;
  _StringGuts.grow(_:)(62LL);
  unint64_t v31 = v102;
  v102(v25, v2, v22);
  DefaultStringInterpolation.appendInterpolation<A>(_:)(v25, v22, WitnessTable);
  v28(v25, v22);
  v32._countAndFlagsBits = 10LL;
  v32._object = (void *)0xE100000000000000LL;
  String.append(_:)(v32);
  v31(v25, v2 + *(int *)(a1 + 36), v22);
  DefaultStringInterpolation.appendInterpolation<A>(_:)(v25, v22, WitnessTable);
  v28(v25, v22);
  v33._countAndFlagsBits = 10LL;
  v33._object = (void *)0xE100000000000000LL;
  String.append(_:)(v33);
  v31(v25, v2 + *(int *)(a1 + 40), v22);
  uint64_t v103 = WitnessTable;
  DefaultStringInterpolation.appendInterpolation<A>(_:)(v25, v22, WitnessTable);
  v28(v25, v22);
  unint64_t v101 = v28;
  v34._countAndFlagsBits = 10LL;
  v34._object = (void *)0xE100000000000000LL;
  String.append(_:)(v34);
  v31(v25, v2 + *(int *)(a1 + 44), v22);
  DefaultStringInterpolation.appendInterpolation<A>(_:)(v25, v22, WitnessTable);
  v28(v25, v22);
  v35._countAndFlagsBits = 10LL;
  v35._object = (void *)0xE100000000000000LL;
  String.append(_:)(v35);
  uint64_t v36 = v2 + *(int *)(a1 + 48);
  uint64_t v37 = v92;
  uint64_t v94 = *(void (**)(char *, uint64_t, uint64_t))(v92 + 16);
  int64_t v39 = v104;
  uint64_t v38 = v105;
  v94(v104, v36, v105);
  uint64_t v93 = swift_getWitnessTable(&protocol conformance descriptor for Preferences<A>.Preference<A1>, v38);
  DefaultStringInterpolation.appendInterpolation<A>(_:)(v39, v38, v93);
  uint64_t v92 = *(void *)(v37 + 8);
  ((void (*)(char *, uint64_t))v92)(v39, v38);
  v40._countAndFlagsBits = 10LL;
  v40._object = (void *)0xE100000000000000LL;
  String.append(_:)(v40);
  uint64_t v41 = v89;
  Preferences.$internetSharingOptions.getter(a1, v89);
  uint64_t v42 = v90;
  uint64_t v43 = swift_getWitnessTable(&protocol conformance descriptor for Preferences<A>.EnumPreference<A1>, v90);
  DefaultStringInterpolation.appendInterpolation<A>(_:)(v41, v42, v43);
  (*(void (**)(uint64_t, uint64_t))(v91 + 8))(v41, v42);
  v44._countAndFlagsBits = 10LL;
  v44._object = (void *)0xE100000000000000LL;
  String.append(_:)(v44);
  unint64_t v45 = v31;
  v31(v25, v2 + *(int *)(a1 + 56), v22);
  uint64_t v46 = v103;
  DefaultStringInterpolation.appendInterpolation<A>(_:)(v25, v22, v103);
  uint64_t v47 = v101;
  v101(v25, v22);
  v48._countAndFlagsBits = 10LL;
  v48._object = (void *)0xE100000000000000LL;
  String.append(_:)(v48);
  v49._countAndFlagsBits = v84;
  int64_t v50 = v83;
  v49._object = v83;
  String.append(_:)(v49);
  swift_bridgeObjectRelease(v50);
  v51._countAndFlagsBits = 10LL;
  v51._object = (void *)0xE100000000000000LL;
  String.append(_:)(v51);
  v45(v25, v2 + *(int *)(a1 + 92), v22);
  DefaultStringInterpolation.appendInterpolation<A>(_:)(v25, v22, v46);
  v47(v25, v22);
  v52._countAndFlagsBits = 10LL;
  v52._object = (void *)0xE100000000000000LL;
  String.append(_:)(v52);
  unint64_t v53 = v85;
  uint64_t v54 = v88;
  v88(v85, v2 + *(int *)(a1 + 96), v18);
  uint64_t v55 = v87;
  DefaultStringInterpolation.appendInterpolation<A>(_:)(v53, v18, v87);
  uint64_t v56 = v86;
  v86(v53, v18);
  v57._countAndFlagsBits = 10LL;
  v57._object = (void *)0xE100000000000000LL;
  String.append(_:)(v57);
  v54(v53, v2 + *(int *)(a1 + 100), v18);
  DefaultStringInterpolation.appendInterpolation<A>(_:)(v53, v18, v55);
  v56(v53, v18);
  v58._countAndFlagsBits = 10LL;
  v58._object = (void *)0xE100000000000000LL;
  String.append(_:)(v58);
  uint64_t v59 = v95;
  Preferences.$enableUserspaceP2POptions.getter(a1, v95);
  uint64_t v60 = v96;
  uint64_t v61 = swift_getWitnessTable(&protocol conformance descriptor for Preferences<A>.EnumPreference<A1>, v96);
  DefaultStringInterpolation.appendInterpolation<A>(_:)(v59, v60, v61);
  (*(void (**)(uint64_t, uint64_t))(v97 + 8))(v59, v60);
  v62._countAndFlagsBits = 10LL;
  v62._object = (void *)0xE100000000000000LL;
  String.append(_:)(v62);
  __int128 v63 = v102;
  v102(v25, v2 + *(int *)(a1 + 108), v22);
  uint64_t v64 = v103;
  DefaultStringInterpolation.appendInterpolation<A>(_:)(v25, v22, v103);
  uint64_t v65 = v101;
  v101(v25, v22);
  v66._countAndFlagsBits = 10LL;
  v66._object = (void *)0xE100000000000000LL;
  String.append(_:)(v66);
  v63(v25, v2 + *(int *)(a1 + 112), v22);
  DefaultStringInterpolation.appendInterpolation<A>(_:)(v25, v22, v64);
  v65(v25, v22);
  v67._countAndFlagsBits = 10LL;
  v67._object = (void *)0xE100000000000000LL;
  String.append(_:)(v67);
  v63(v25, v2 + *(int *)(a1 + 116), v22);
  DefaultStringInterpolation.appendInterpolation<A>(_:)(v25, v22, v64);
  v65(v25, v22);
  v68._countAndFlagsBits = 10LL;
  v68._object = (void *)0xE100000000000000LL;
  String.append(_:)(v68);
  v63(v25, v2 + *(int *)(a1 + 60), v22);
  DefaultStringInterpolation.appendInterpolation<A>(_:)(v25, v22, v64);
  v65(v25, v22);
  v69._countAndFlagsBits = 10LL;
  v69._object = (void *)0xE100000000000000LL;
  String.append(_:)(v69);
  uint64_t v70 = v104;
  uint64_t v71 = v105;
  v94(v104, v2 + *(int *)(a1 + 64), v105);
  DefaultStringInterpolation.appendInterpolation<A>(_:)(v70, v71, v93);
  ((void (*)(char *, uint64_t))v92)(v70, v71);
  v72._countAndFlagsBits = 10LL;
  v72._object = (void *)0xE100000000000000LL;
  String.append(_:)(v72);
  v63(v25, v2 + *(int *)(a1 + 68), v22);
  DefaultStringInterpolation.appendInterpolation<A>(_:)(v25, v22, v64);
  v65(v25, v22);
  v73._countAndFlagsBits = 10LL;
  v73._object = (void *)0xE100000000000000LL;
  String.append(_:)(v73);
  v63(v25, v2 + *(int *)(a1 + 72), v22);
  DefaultStringInterpolation.appendInterpolation<A>(_:)(v25, v22, v64);
  v65(v25, v22);
  v74._countAndFlagsBits = 10LL;
  v74._object = (void *)0xE100000000000000LL;
  String.append(_:)(v74);
  unint64_t v76 = v98;
  uint64_t v75 = v99;
  uint64_t v77 = *(void (**)(char *, uint64_t, uint64_t))(v99 + 16);
  uint64_t v78 = v100;
  v77(v98, v2 + *(int *)(a1 + 76), v100);
  uint64_t v79 = swift_getWitnessTable(&protocol conformance descriptor for Preferences<A>.Preference<A1>, v78);
  DefaultStringInterpolation.appendInterpolation<A>(_:)(v76, v78, v79);
  uint64_t v80 = *(void (**)(char *, uint64_t))(v75 + 8);
  v80(v76, v78);
  v81._countAndFlagsBits = 10LL;
  v81._object = (void *)0xE100000000000000LL;
  String.append(_:)(v81);
  v77(v76, v2 + *(int *)(a1 + 80), v78);
  DefaultStringInterpolation.appendInterpolation<A>(_:)(v76, v78, v79);
  v80(v76, v78);
  return v106;
}

SCPreferencesRef sub_1000B0ED8()
{
  SCPreferencesRef result = sub_1000B0EF4();
  static SCPreferencesRef.p2pPreferences = (uint64_t)result;
  return result;
}

SCPreferencesRef sub_1000B0EF4()
{
  id v0 = [(id)objc_opt_self(NSFileManager) defaultManager];
  NSString v1 = String._bridgeToObjectiveC()();
  unsigned int v2 = [v0 fileExistsAtPath:v1];

  if (v2)
  {
    NSString v3 = String._bridgeToObjectiveC()();
    unsigned __int8 v4 = [v0 fileExistsAtPath:v3];

    if ((v4 & 1) == 0)
    {
      NSString v5 = String._bridgeToObjectiveC()();
      NSString v6 = String._bridgeToObjectiveC()();
      id v19 = 0LL;
      unsigned int v7 = [v0 moveItemAtPath:v5 toPath:v6 error:&v19];

      id v8 = v19;
      if (v7)
      {
        id v9 = v19;
      }

      else
      {
        id v10 = v19;
        uint64_t v11 = _convertNSErrorToError(_:)(v8);

        swift_willThrow();
        swift_errorRelease(v11);
      }
    }
  }

  id v12 = [(id)objc_opt_self(NSProcessInfo) processInfo];
  uint64_t v13 = (__CFString *)[v12 processName];

  if (!v13)
  {
    static String._unconditionallyBridgeFromObjectiveC(_:)(0LL);
    uint64_t v15 = v14;
    uint64_t v13 = (__CFString *)String._bridgeToObjectiveC()();
    swift_bridgeObjectRelease(v15);
  }

  uint64_t v16 = (__CFString *)String._bridgeToObjectiveC()();
  SCPreferencesRef v17 = SCPreferencesCreate(kCFAllocatorDefault, v13, v16);

  if (!v17) {
    __break(1u);
  }

  return v17;
}

id static SCPreferencesRef.p2pPreferences.getter()
{
  if (qword_100404148 != -1) {
    swift_once(&qword_100404148, sub_1000B0ED8);
  }
  return (id)static SCPreferencesRef.p2pPreferences;
}

uint64_t SCPreferencesRef.subscript.getter@<X0>(unsigned __int8 a1@<W0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v8 = v7;
  id v9 = (__CFString *)String._bridgeToObjectiveC()();
  swift_bridgeObjectRelease(v8);
  CFPropertyListRef v10 = (id)SCPreferencesGetValue(v3, v9);

  CFPropertyListRef v14 = v10;
  uint64_t v11 = sub_100002274(&qword_100406BB0);
  int v12 = swift_dynamicCast(a3, &v14, v11, a2, 6LL);
  (*(void (**)(uint64_t, void, uint64_t, uint64_t))(*(void *)(a2 - 8) + 56LL))(a3, v12 ^ 1u, 1LL, a2);
  return SCPreferencesUnlock(v3);
}

uint64_t SCPreferencesRef.subscript.setter(uint64_t a1, unsigned __int8 a2, uint64_t a3)
{
  unsigned __int8 v4 = v3;
  uint64_t v8 = type metadata accessor for Optional(0LL, a3);
  uint64_t v9 = *(void *)(v8 - 8);
  uint64_t v10 = __chkstk_darwin(v8);
  int v12 = (char *)&v21 - v11;
  uint64_t v13 = *(void *)(a3 - 8);
  __chkstk_darwin(v10);
  uint64_t v15 = (char *)&v21 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  (*(void (**)(char *, uint64_t, uint64_t))(v9 + 16))(v12, a1, v8);
  if ((*(unsigned int (**)(char *, uint64_t, uint64_t))(v13 + 48))(v12, 1LL, a3) == 1)
  {
    uint64_t v16 = *(void (**)(char *, uint64_t))(v9 + 8);
    v16(v12, v8);
    SCPreferencesLock(v4, 1u);
    SCPreferencesSynchronize(v4);
    PreferencesName.rawValue.getter(a2);
    uint64_t v18 = v17;
    id v19 = (__CFString *)String._bridgeToObjectiveC()();
    swift_bridgeObjectRelease(v18);
    SCPreferencesRemoveValue(v4, v19);

    SCPreferencesCommitChanges(v4);
    SCPreferencesApplyChanges(v4);
    SCPreferencesUnlock(v4);
    return ((uint64_t (*)(uint64_t, uint64_t))v16)(a1, v8);
  }

  else
  {
    (*(void (**)(char *, char *, uint64_t))(v13 + 32))(v15, v12, a3);
    SCPreferencesLock(v4, 1u);
    SCPreferencesSynchronize(v4);
    sub_1000B1490(v4, a2, (uint64_t)v15, a3);
    SCPreferencesCommitChanges(v4);
    SCPreferencesApplyChanges(v4);
    SCPreferencesUnlock(v4);
    (*(void (**)(uint64_t, uint64_t))(v9 + 8))(a1, v8);
    return (*(uint64_t (**)(char *, uint64_t))(v13 + 8))(v15, a3);
  }

Swift::Void __swiftcall SCPreferencesRef.removeValue(forKey:)(CoreP2P::PreferencesName forKey)
{
  uint64_t v4 = v3;
  NSString v5 = (__CFString *)String._bridgeToObjectiveC()();
  swift_bridgeObjectRelease(v4);
  SCPreferencesRemoveValue(v1, v5);

  SCPreferencesCommitChanges(v1);
  SCPreferencesApplyChanges(v1);
  SCPreferencesUnlock(v1);
}

uint64_t sub_1000B1490(const __SCPreferences *a1, unsigned __int8 a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8 = v7;
  uint64_t v9 = (__CFString *)String._bridgeToObjectiveC()();
  swift_bridgeObjectRelease(v8);
  uint64_t v10 = (const void *)_bridgeAnythingToObjectiveC<A>(_:)(a3, a4);
  SCPreferencesSetValue(a1, v9, v10);

  return swift_unknownObjectRelease(v10);
}

void (*SCPreferencesRef.subscript.modify( void *a1, unsigned __int8 a2, uint64_t a3))(uint64_t *a1, char a2)
{
  uint64_t v7 = malloc(0x38uLL);
  *a1 = v7;
  *uint64_t v7 = a3;
  v7[1] = v3;
  *((_BYTE *)v7 + 48) = a2;
  uint64_t v8 = type metadata accessor for Optional(0LL, a3);
  v7[2] = v8;
  uint64_t v9 = *(void *)(v8 - 8);
  void v7[3] = v9;
  size_t v10 = *(void *)(v9 + 64);
  v7[4] = malloc(v10);
  uint64_t v11 = malloc(v10);
  v7[5] = v11;
  SCPreferencesRef.subscript.getter(a2, a3, (uint64_t)v11);
  return sub_1000B15A8;
}

void sub_1000B15A8(uint64_t *a1, char a2)
{
  uint64_t v2 = *a1;
  uint64_t v3 = *(void **)(*a1 + 32);
  uint64_t v4 = *(void **)(*a1 + 40);
  if ((a2 & 1) != 0)
  {
    uint64_t v5 = *(void *)(v2 + 16);
    uint64_t v6 = *(void *)(v2 + 24);
    uint64_t v7 = *(void *)v2;
    unsigned __int8 v8 = *(_BYTE *)(v2 + 48);
    (*(void (**)(void, void *, uint64_t))(v6 + 16))(*(void *)(*a1 + 32), v4, v5);
    SCPreferencesRef.subscript.setter((uint64_t)v3, v8, v7);
    (*(void (**)(void *, uint64_t))(v6 + 8))(v4, v5);
  }

  else
  {
    SCPreferencesRef.subscript.setter(*(void *)(*a1 + 40), *(_BYTE *)(v2 + 48), *(void *)v2);
  }

  free(v4);
  free(v3);
  free((void *)v2);
}

uint64_t sub_1000B164C@<X0>(unsigned __int8 a1@<W0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  return SCPreferencesRef.subscript.getter(a1, a2, a3);
}

uint64_t sub_1000B166C(uint64_t a1, unsigned __int8 a2, uint64_t a3)
{
  return SCPreferencesRef.subscript.setter(a1, a2, a3);
}

void (*sub_1000B168C(void *a1, unsigned __int8 a2, uint64_t a3))(uint64_t *a1, char a2)
{
  uint64_t v7 = malloc(0x38uLL);
  *a1 = v7;
  *(void *)uint64_t v7 = a3;
  v7[48] = a2;
  uint64_t v8 = type metadata accessor for Optional(0LL, a3);
  *((void *)v7 + 1) = v8;
  uint64_t v9 = *(void *)(v8 - 8);
  *((void *)v7 + 2) = v9;
  size_t v10 = *(void *)(v9 + 64);
  *((void *)v7 + 3) = malloc(v10);
  uint64_t v11 = malloc(v10);
  uint64_t v12 = *v3;
  *((void *)v7 + 4) = v11;
  *((void *)v7 + 5) = v12;
  SCPreferencesRef.subscript.getter(a2, a3, (uint64_t)v11);
  return sub_1000B1730;
}

void sub_1000B1730(uint64_t *a1, char a2)
{
  uint64_t v2 = *a1;
  uint64_t v3 = *(void **)(*a1 + 32);
  uint64_t v4 = *(void **)(*a1 + 24);
  if ((a2 & 1) != 0)
  {
    uint64_t v5 = *(void *)(v2 + 8);
    uint64_t v6 = *(void *)(v2 + 16);
    uint64_t v7 = *(void *)v2;
    unsigned __int8 v8 = *(_BYTE *)(v2 + 48);
    (*(void (**)(void, void *, uint64_t))(v6 + 16))(*(void *)(*a1 + 24), v3, v5);
    SCPreferencesRef.subscript.setter((uint64_t)v4, v8, v7);
    (*(void (**)(void *, uint64_t))(v6 + 8))(v3, v5);
  }

  else
  {
    SCPreferencesRef.subscript.setter(*(void *)(*a1 + 32), *(_BYTE *)(v2 + 48), *(void *)v2);
  }

  free(v3);
  free(v4);
  free((void *)v2);
}

uint64_t sub_1000B17D8(unsigned __int8 a1)
{
  uint64_t v3 = *v1;
  SCPreferencesLock(v3, 1u);
  SCPreferencesSynchronize(v3);
  PreferencesName.rawValue.getter(a1);
  uint64_t v5 = v4;
  uint64_t v6 = (__CFString *)String._bridgeToObjectiveC()();
  swift_bridgeObjectRelease(v5);
  SCPreferencesRemoveValue(v3, v6);

  SCPreferencesCommitChanges(v3);
  SCPreferencesApplyChanges(v3);
  return SCPreferencesUnlock(v3);
}

uint64_t InMemoryPreferenceStorage.__allocating_init()()
{
  uint64_t result = swift_allocObject(v0, 24LL, 7LL);
  *(void *)(result + 16) = &_swiftEmptyDictionarySingleton;
  return result;
}

uint64_t type metadata accessor for InMemoryPreferenceStorage()
{
  return objc_opt_self(&OBJC_CLASS____TtC7CoreP2P25InMemoryPreferenceStorage);
}

uint64_t InMemoryPreferenceStorage.init()()
{
  uint64_t result = v0;
  *(void *)(v0 + 16) = &_swiftEmptyDictionarySingleton;
  return result;
}

uint64_t type metadata accessor for CachedPreferenceStorage(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return sub_1000227C8(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for CachedPreferenceStorage);
}

uint64_t type metadata accessor for LockedPreferencesStorage(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return sub_1000227C8(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for LockedPreferencesStorage);
}

uint64_t InMemoryPreferenceStorage.subscript.getter@<X0>( unsigned __int8 a1@<W0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v6 = PreferencesName.rawValue.getter(a1);
  uint64_t v8 = v7;
  swift_beginAccess(v3 + 16, v18, 0LL, 0LL);
  uint64_t v9 = *(void *)(v3 + 16);
  if (*(void *)(v9 + 16))
  {
    swift_bridgeObjectRetain(v9);
    uint64_t v10 = sub_10001C008(v6, v8);
    if ((v11 & 1) != 0)
    {
      sub_100002AE4(*(void *)(v9 + 56) + 32 * v10, (uint64_t)&v16);
    }

    else
    {
      __int128 v16 = 0u;
      __int128 v17 = 0u;
    }

    swift_bridgeObjectRelease(v8);
    uint64_t v12 = v9;
  }

  else
  {
    __int128 v16 = 0u;
    __int128 v17 = 0u;
    uint64_t v12 = v8;
  }

  swift_bridgeObjectRelease(v12);
  uint64_t v13 = sub_100002274(&qword_100405280);
  int v14 = swift_dynamicCast(a3, &v16, v13, a2, 6LL);
  return (*(uint64_t (**)(uint64_t, void, uint64_t, uint64_t))(*(void *)(a2 - 8) + 56LL))( a3,  v14 ^ 1u,  1LL,  a2);
}

uint64_t InMemoryPreferenceStorage.subscript.setter(uint64_t a1, unsigned __int8 a2, uint64_t a3)
{
  uint64_t v5 = type metadata accessor for Optional(0LL, a3);
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(v5 - 8) + 8LL))(a1, v5);
}

void (*InMemoryPreferenceStorage.subscript.modify( void *a1, unsigned __int8 a2, uint64_t a3))(uint64_t **a1, char a2)
{
  uint64_t v7 = malloc(0x38uLL);
  *a1 = v7;
  *uint64_t v7 = a3;
  v7[1] = v3;
  *((_BYTE *)v7 + 48) = a2;
  uint64_t v8 = type metadata accessor for Optional(0LL, a3);
  v7[2] = v8;
  uint64_t v9 = *(void *)(v8 - 8);
  void v7[3] = v9;
  size_t v10 = *(void *)(v9 + 64);
  v7[4] = malloc(v10);
  char v11 = malloc(v10);
  v7[5] = v11;
  InMemoryPreferenceStorage.subscript.getter(a2, a3, (uint64_t)v11);
  return sub_1000B1AAC;
}

void sub_1000B1AAC(uint64_t **a1, char a2)
{
  uint64_t v2 = *a1;
  uint64_t v3 = (void *)(*a1)[4];
  uint64_t v4 = (void *)(*a1)[5];
  uint64_t v5 = (*a1)[2];
  uint64_t v6 = (*a1)[3];
  uint64_t v7 = **a1;
  unsigned __int8 v8 = *((_BYTE *)*a1 + 48);
  if ((a2 & 1) != 0)
  {
    (*(void (**)(uint64_t, void *, uint64_t))(v6 + 16))((*a1)[4], v4, v5);
    sub_1000B2978((uint64_t)v3, v8, v7);
    uint64_t v9 = *(void (**)(void *, uint64_t))(v6 + 8);
    v9(v3, v5);
  }

  else
  {
    sub_1000B2978((*a1)[5], v8, v7);
    uint64_t v9 = *(void (**)(void *, uint64_t))(v6 + 8);
  }

  v9(v4, v5);
  free(v4);
  free(v3);
  free(v2);
}

Swift::Void __swiftcall InMemoryPreferenceStorage.removeValue(forKey:)(CoreP2P::PreferencesName forKey)
{
  uint64_t v2 = PreferencesName.rawValue.getter(forKey);
  uint64_t v4 = v3;
  swift_beginAccess(v1 + 16, v5, 33LL, 0LL);
  sub_10001E720(v2, v4, v6);
  sub_1000B2F2C((uint64_t)v6);
  swift_endAccess(v5);
  swift_bridgeObjectRelease(v4);
}

Swift::Void __swiftcall InMemoryPreferenceStorage.removeAll()()
{
  uint64_t v1 = *(void *)(v0 + 16);
  *(void *)(v0 + 16) = &_swiftEmptyDictionarySingleton;
  swift_bridgeObjectRelease(v1);
}

uint64_t InMemoryPreferenceStorage.deinit()
{
  return v0;
}

uint64_t InMemoryPreferenceStorage.__deallocating_deinit()
{
  return swift_deallocClassInstance(v0, 24LL, 7LL);
}

uint64_t sub_1000B1C54@<X0>(unsigned __int8 a1@<W0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  return InMemoryPreferenceStorage.subscript.getter(a1, a2, a3);
}

uint64_t sub_1000B1C74(uint64_t a1, unsigned __int8 a2, uint64_t a3)
{
  uint64_t v5 = type metadata accessor for Optional(0LL, a3);
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(v5 - 8) + 8LL))(a1, v5);
}

void (*sub_1000B1CC0(void *a1, unsigned __int8 a2, uint64_t a3))(uint64_t **a1, char a2)
{
  uint64_t v7 = malloc(0x38uLL);
  *a1 = v7;
  *(void *)uint64_t v7 = a3;
  v7[48] = a2;
  uint64_t v8 = type metadata accessor for Optional(0LL, a3);
  *((void *)v7 + 1) = v8;
  uint64_t v9 = *(void *)(v8 - 8);
  *((void *)v7 + 2) = v9;
  size_t v10 = *(void *)(v9 + 64);
  *((void *)v7 + 3) = malloc(v10);
  char v11 = malloc(v10);
  uint64_t v12 = *v3;
  *((void *)v7 + 4) = v11;
  *((void *)v7 + 5) = v12;
  InMemoryPreferenceStorage.subscript.getter(a2, a3, (uint64_t)v11);
  return sub_1000B1D64;
}

void sub_1000B1D64(uint64_t **a1, char a2)
{
  uint64_t v2 = *a1;
  uint64_t v3 = (void *)(*a1)[4];
  uint64_t v5 = (*a1)[2];
  uint64_t v4 = (void *)(*a1)[3];
  uint64_t v7 = **a1;
  uint64_t v6 = (*a1)[1];
  unsigned __int8 v8 = *((_BYTE *)*a1 + 48);
  if ((a2 & 1) != 0)
  {
    (*(void (**)(uint64_t, void *, uint64_t))(v5 + 16))((*a1)[3], v3, v6);
    sub_1000B2978((uint64_t)v4, v8, v7);
    uint64_t v9 = *(void (**)(void *, uint64_t))(v5 + 8);
    v9(v4, v6);
  }

  else
  {
    sub_1000B2978((*a1)[4], v8, v7);
    uint64_t v9 = *(void (**)(void *, uint64_t))(v5 + 8);
  }

  v9(v3, v6);
  free(v3);
  free(v4);
  free(v2);
}

uint64_t sub_1000B1E18(unsigned __int8 a1)
{
  uint64_t v2 = *v1;
  uint64_t v3 = PreferencesName.rawValue.getter(a1);
  uint64_t v5 = v4;
  swift_beginAccess(v2 + 16, v7, 33LL, 0LL);
  sub_10001E720(v3, v5, v8);
  sub_1000B2F2C((uint64_t)v8);
  swift_endAccess(v7);
  return swift_bridgeObjectRelease(v5);
}

void LockedPreferencesStorage.subscript.getter( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v5 = v4;
  uint64_t v10 = type metadata accessor for Optional(0LL, a3);
  uint64_t v11 = *(void *)(v10 - 8);
  __chkstk_darwin(v10);
  uint64_t v13 = (char *)&v16 - v12;
  os_unfair_lock_lock(*(os_unfair_lock_t *)(*(void *)v4 + 16LL));
  (*(void (**)(uint64_t, uint64_t, void))(*(void *)(a2 + 24) + 8LL))(a1, a3, *(void *)(a2 + 16));
  uint64_t v14 = *(void *)(a3 - 8);
  if ((*(unsigned int (**)(char *, uint64_t, uint64_t))(v14 + 48))(v13, 1LL, a3) == 1)
  {
    (*(void (**)(char *, uint64_t))(v11 + 8))(v13, v10);
    uint64_t v15 = 1LL;
  }

  else
  {
    (*(void (**)(uint64_t, char *, uint64_t))(v14 + 32))(a4, v13, a3);
    uint64_t v15 = 0LL;
  }

  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v14 + 56))(a4, v15, 1LL, a3);
  os_unfair_lock_unlock(*(os_unfair_lock_t *)(*(void *)v5 + 16LL));
}

uint64_t LockedPreferencesStorage.subscript.setter(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return sub_1000B2534(a1, a2, a3, a4, (void (*)(void))sub_1000B2B40);
}

void (*LockedPreferencesStorage.subscript.modify( void *a1, uint64_t a2, uint64_t a3, uint64_t a4))(uint64_t **a1, char a2)
{
  uint64_t v9 = malloc(0x40uLL);
  *a1 = v9;
  v9[1] = a4;
  _OWORD v9[2] = v4;
  void *v9 = a3;
  *((_BYTE *)v9 + 56) = a2;
  uint64_t v10 = type metadata accessor for Optional(0LL, a4);
  void v9[3] = v10;
  uint64_t v11 = *(void *)(v10 - 8);
  char v9[4] = v11;
  size_t v12 = *(void *)(v11 + 64);
  void v9[5] = malloc(v12);
  uint64_t v13 = malloc(v12);
  v9[6] = v13;
  LockedPreferencesStorage.subscript.getter(a2, a3, a4, (uint64_t)v13);
  return sub_1000B206C;
}

void sub_1000B206C(uint64_t **a1, char a2)
{
}

Swift::Void __swiftcall LockedPreferencesStorage.removeValue(forKey:)(CoreP2P::PreferencesName forKey)
{
  uint64_t v3 = v1;
  uint64_t v4 = forKey;
  os_unfair_lock_lock(*(os_unfair_lock_t *)(*(void *)v2 + 16LL));
  (*(void (**)(uint64_t, void))(*(void *)(v3 + 24) + 32LL))(v4, *(void *)(v3 + 16));
  os_unfair_lock_unlock(*(os_unfair_lock_t *)(*(void *)v2 + 16LL));
}

void sub_1000B20D0(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
}

uint64_t sub_1000B20E0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return sub_1000B27A0(a1, a2, a3, a4, a5, sub_1000B2B40);
}

void (*sub_1000B20EC(void *a1, uint64_t a2, uint64_t a3, uint64_t a4))(uint64_t **a1, char a2)
{
  uint64_t v9 = malloc(0x40uLL);
  *a1 = v9;
  v9[1] = v4;
  _OWORD v9[2] = a4;
  void *v9 = a3;
  *((_BYTE *)v9 + 56) = a2;
  uint64_t v10 = type metadata accessor for Optional(0LL, a3);
  void v9[3] = v10;
  uint64_t v11 = *(void *)(v10 - 8);
  char v9[4] = v11;
  size_t v12 = *(void *)(v11 + 64);
  void v9[5] = malloc(v12);
  uint64_t v13 = malloc(v12);
  v9[6] = v13;
  LockedPreferencesStorage.subscript.getter(a2, a4, a3, (uint64_t)v13);
  return sub_1000B2198;
}

void sub_1000B2198(uint64_t **a1, char a2)
{
}

uint64_t LockedPreferencesStorage<>.init()()
{
  uint64_t v0 = type metadata accessor for InMemoryPreferenceStorage();
  *(void *)(swift_allocObject(v0, 24LL, 7LL) + 16) = &_swiftEmptyDictionarySingleton;
  uint64_t v1 = type metadata accessor for Lock();
  uint64_t v2 = swift_allocObject(v1, 24LL, 7LL);
  uint64_t v3 = (_DWORD *)swift_slowAlloc(4LL, -1LL);
  *(void *)(v2 + 16) = v3;
  *uint64_t v3 = 0;
  return v2;
}

uint64_t CachedPreferenceStorage.subscript.getter@<X0>( unsigned int a1@<W0>, uint64_t a2@<X1>, uint64_t a3@<X2>, char *a4@<X8>)
{
  uint64_t v51 = a2;
  uint64_t v54 = a4;
  uint64_t v53 = type metadata accessor for Optional(0LL, a3);
  int64_t v50 = *(uint64_t **)(v53 - 8);
  uint64_t v7 = __chkstk_darwin(v53);
  uint64_t v9 = (char *)v45 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v10 = __chkstk_darwin(v7);
  size_t v12 = (char *)v45 - v11;
  uint64_t v13 = __chkstk_darwin(v10);
  uint64_t v15 = (char *)v45 - v14;
  uint64_t v16 = *(void *)(a3 - 8);
  uint64_t v17 = __chkstk_darwin(v13);
  id v19 = (char *)v45 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  __chkstk_darwin(v17);
  uint64_t v21 = (char *)v45 - v20;
  unsigned int v52 = a1;
  InMemoryPreferenceStorage.subscript.getter(a1, a3, (uint64_t)v15);
  uint64_t v22 = *(unsigned int (**)(char *, uint64_t, uint64_t))(v16 + 48);
  if (v22(v15, 1LL, a3) != 1)
  {
    uint64_t v37 = *(void (**)(char *, char *, uint64_t))(v16 + 32);
    v37(v21, v15, a3);
    uint64_t v38 = v54;
    v37(v54, v21, a3);
    return (*(uint64_t (**)(char *, void, uint64_t, uint64_t))(v16 + 56))(v38, 0LL, 1LL, a3);
  }

  Swift::String v48 = v9;
  Swift::String v49 = v12;
  uint64_t v47 = v19;
  uint64_t v23 = (void (*)(char *, uint64_t))v50[1];
  v23(v15, v53);
  int64_t v50 = v4;
  uint64_t v24 = *v4;
  uint64_t v25 = *(void *)(v51 + 16);
  uint64_t v26 = *(void *)(v51 + 24);
  uint64_t v28 = type metadata accessor for CachedPreferenceStorage.EmptyPreference(0LL, v25, v26, v27);
  uint64_t v29 = v52;
  InMemoryPreferenceStorage.subscript.getter(v52, v28, (uint64_t)&v56);
  if ((v56 & 1) != 0)
  {
    v45[0] = v28;
    v45[1] = v24;
    uint64_t v46 = (void (*)(uint64_t, uint64_t))v23;
    uint64_t v30 = v49;
    unsigned __int8 v31 = v29;
    (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v26 + 8))(v29, a3, v25, v26);
    unsigned int v32 = v22(v30, 1LL, a3);
    uint64_t v34 = v53;
    Swift::String v33 = v54;
    if (v32 != 1)
    {
      Swift::String v40 = *(void (**)(char *, char *, uint64_t))(v16 + 32);
      uint64_t v41 = v47;
      v40(v47, v30, a3);
      uint64_t v42 = (uint64_t)v48;
      (*(void (**)(char *, char *, uint64_t))(v16 + 16))(v48, v41, a3);
      unsigned __int8 v43 = v31;
      Swift::String v44 = *(uint64_t (**)(char *, void, uint64_t, uint64_t))(v16 + 56);
      v44((char *)v42, 0LL, 1LL, a3);
      sub_1000B2978(v42, v43, a3);
      v46(v42, v34);
      v40(v33, v41, a3);
      return v44(v33, 0LL, 1LL, a3);
    }

    v46((uint64_t)v30, v53);
    char v55 = 0;
    sub_1000B2978((uint64_t)&v55, v29, v45[0]);
    Swift::String v35 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v16 + 56);
    uint64_t v36 = v33;
  }

  else
  {
    Swift::String v35 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v16 + 56);
    uint64_t v36 = v54;
  }

  return v35((uint64_t)v36, 1LL, 1LL, a3);
}

uint64_t CachedPreferenceStorage.subscript.setter(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return sub_1000B2534(a1, a2, a3, a4, (void (*)(void))sub_1000B2BF4);
}

uint64_t sub_1000B2534(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(void))
{
  uint64_t v7 = type metadata accessor for Optional(0LL, a4);
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(v7 - 8) + 8LL))(a1, v7);
}

void (*CachedPreferenceStorage.subscript.modify( void *a1, unsigned int a2, uint64_t a3, uint64_t a4))(uint64_t **a1, char a2)
{
  uint64_t v9 = malloc(0x40uLL);
  *a1 = v9;
  v9[1] = a4;
  _OWORD v9[2] = v4;
  void *v9 = a3;
  *((_BYTE *)v9 + 56) = a2;
  uint64_t v10 = type metadata accessor for Optional(0LL, a4);
  void v9[3] = v10;
  uint64_t v11 = *(void *)(v10 - 8);
  char v9[4] = v11;
  size_t v12 = *(void *)(v11 + 64);
  void v9[5] = malloc(v12);
  uint64_t v13 = (char *)malloc(v12);
  v9[6] = v13;
  CachedPreferenceStorage.subscript.getter(a2, a3, a4, v13);
  return sub_1000B2628;
}

void sub_1000B2628(uint64_t **a1, char a2)
{
}

void sub_1000B2634(uint64_t **a1, char a2, void (*a3)(void *, uint64_t, uint64_t, uint64_t))
{
  uint64_t v4 = *a1;
  uint64_t v5 = (void *)(*a1)[5];
  uint64_t v6 = (void *)(*a1)[6];
  uint64_t v7 = (*a1)[3];
  uint64_t v8 = (*a1)[4];
  uint64_t v9 = (*a1)[1];
  uint64_t v10 = **a1;
  uint64_t v11 = *((unsigned __int8 *)*a1 + 56);
  if ((a2 & 1) != 0)
  {
    (*(void (**)(uint64_t, void *, uint64_t))(v8 + 16))((*a1)[5], v6, v7);
    a3(v5, v11, v10, v9);
    size_t v12 = *(void (**)(void *, uint64_t))(v8 + 8);
    v12(v5, v7);
  }

  else
  {
    a3((void *)(*a1)[6], v11, v10, v9);
    size_t v12 = *(void (**)(void *, uint64_t))(v8 + 8);
  }

  v12(v6, v7);
  free(v6);
  free(v5);
  free(v4);
}

Swift::Void __swiftcall CachedPreferenceStorage.removeValue(forKey:)(CoreP2P::PreferencesName forKey)
{
  uint64_t v3 = forKey;
  uint64_t v4 = *(void *)(v1 + 16);
  uint64_t v5 = *(void *)(v1 + 24);
  char v7 = 0;
  uint64_t v6 = type metadata accessor for CachedPreferenceStorage.EmptyPreference(0LL, v4, v5, v2);
  sub_1000B2978((uint64_t)&v7, v3, v6);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v5 + 32))(v3, v4, v5);
}

uint64_t sub_1000B2784@<X0>(unsigned int a1@<W0>, uint64_t a2@<X1>, uint64_t a3@<X2>, char *a4@<X8>)
{
  return CachedPreferenceStorage.subscript.getter(a1, a3, a2, a4);
}

uint64_t sub_1000B2794(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return sub_1000B27A0(a1, a2, a3, a4, a5, (void (*)(uint64_t, uint64_t, uint64_t, uint64_t))sub_1000B2BF4);
}

uint64_t sub_1000B27A0( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, void (*a6)(uint64_t, uint64_t, uint64_t, uint64_t))
{
  uint64_t v8 = type metadata accessor for Optional(0LL, a3);
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(v8 - 8) + 8LL))(a1, v8);
}

void (*sub_1000B27F0(void *a1, unsigned int a2, uint64_t a3, uint64_t a4))(uint64_t **a1, char a2)
{
  uint64_t v9 = malloc(0x40uLL);
  *a1 = v9;
  v9[1] = v4;
  _OWORD v9[2] = a4;
  void *v9 = a3;
  *((_BYTE *)v9 + 56) = a2;
  uint64_t v10 = type metadata accessor for Optional(0LL, a3);
  void v9[3] = v10;
  uint64_t v11 = *(void *)(v10 - 8);
  char v9[4] = v11;
  size_t v12 = *(void *)(v11 + 64);
  void v9[5] = malloc(v12);
  uint64_t v13 = (char *)malloc(v12);
  v9[6] = v13;
  CachedPreferenceStorage.subscript.getter(a2, a4, a3, v13);
  return sub_1000B289C;
}

void sub_1000B289C(uint64_t **a1, char a2)
{
}

void sub_1000B28A8(uint64_t **a1, char a2, void (*a3)(void *, uint64_t, uint64_t, uint64_t))
{
  uint64_t v4 = *a1;
  uint64_t v5 = (void *)(*a1)[5];
  uint64_t v6 = (void *)(*a1)[6];
  uint64_t v7 = (*a1)[3];
  uint64_t v8 = (*a1)[4];
  uint64_t v9 = (*a1)[2];
  uint64_t v10 = **a1;
  uint64_t v11 = *((unsigned __int8 *)*a1 + 56);
  if ((a2 & 1) != 0)
  {
    (*(void (**)(uint64_t, void *, uint64_t))(v8 + 16))((*a1)[5], v6, v7);
    a3(v5, v11, v9, v10);
    size_t v12 = *(void (**)(void *, uint64_t))(v8 + 8);
    v12(v5, v7);
  }

  else
  {
    a3((void *)(*a1)[6], v11, v9, v10);
    size_t v12 = *(void (**)(void *, uint64_t))(v8 + 8);
  }

  v12(v6, v7);
  free(v6);
  free(v5);
  free(v4);
}

uint64_t sub_1000B2978(uint64_t a1, unsigned __int8 a2, uint64_t a3)
{
  uint64_t v6 = PreferencesName.rawValue.getter(a2);
  uint64_t v8 = v7;
  uint64_t v9 = type metadata accessor for Optional(0LL, a3);
  void v13[3] = v9;
  uint64_t v10 = sub_10002278C(v13);
  (*(void (**)(void *, uint64_t, uint64_t))(*(void *)(v9 - 8) + 16LL))(v10, a1, v9);
  swift_beginAccess(v3 + 16, v12, 33LL, 0LL);
  sub_100013AA8((uint64_t)v13, v6, v8);
  return swift_endAccess(v12);
}

uint64_t _s7CoreP2P15PreferencesNameO8rawValueACSgSS_tcfC_0(uint64_t a1, uint64_t a2)
{
  unint64_t v3 = _findStringSwitchCaseWithCache(cases:string:cache:)(&off_1003D5F38, a1, a2, &unk_100404498);
  swift_bridgeObjectRelease(a2);
  if (v3 >= 0x16) {
    return 22LL;
  }
  else {
    return v3;
  }
}

unint64_t _s7CoreP2P18PreferenceDefaultsV22InternetSharingOptionsO8rawValueAESgSS_tcfC_0( Swift::String string)
{
  object = string._object;
  v2._countAndFlagsBits = string._countAndFlagsBits;
  v2._object = object;
  unint64_t v3 = _findStringSwitchCase(cases:string:)((Swift::OpaquePointer)&off_1003D6380, v2);
  swift_bridgeObjectRelease(object);
  if (v3 >= 3) {
    return 3LL;
  }
  else {
    return v3;
  }
}

uint64_t sub_1000B2AB8(uint64_t result, uint64_t a2, unint64_t a3)
{
  if (result < 0)
  {
    __break(1u);
  }

  else
  {
    uint64_t v5 = HIBYTE(a3) & 0xF;
    if ((a3 & 0x2000000000000000LL) == 0) {
      uint64_t v5 = a2;
    }
    uint64_t v6 = 7LL;
    if (((a3 >> 60) & ((a2 & 0x800000000000000LL) == 0)) != 0) {
      uint64_t v6 = 11LL;
    }
    uint64_t v7 = String.index(_:offsetBy:limitedBy:)(v6 | (v5 << 16), -result, 15LL, a2, a3);
    if ((v8 & 1) != 0) {
      uint64_t v9 = 15LL;
    }
    else {
      uint64_t v9 = v7;
    }
    return String.subscript.getter(15LL, v9, a2, a3);
  }

  return result;
}

void sub_1000B2B40(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v9 = type metadata accessor for Optional(0LL, a4);
  v11[3] = v9;
  uint64_t v10 = sub_10002278C(v11);
  (*(void (**)(void *, uint64_t, uint64_t))(*(void *)(v9 - 8) + 16LL))(v10, a1, v9);
  (*(void (**)(void *, uint64_t, char *, void))(*(void *)(a3 + 24) + 16LL))( v11,  a2,  &type metadata for Any[8],  *(void *)(a3 + 16));
  os_unfair_lock_unlock(*(os_unfair_lock_t *)(*(void *)v4 + 16LL));
}

uint64_t sub_1000B2BF4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8 = type metadata accessor for Optional(0LL, a4);
  uint64_t v9 = *(void *)(v8 - 8);
  __chkstk_darwin(v8);
  uint64_t v11 = (char *)&v13 - v10;
  sub_1000B2978(a1, a2, a4);
  (*(void (**)(char *, uint64_t, uint64_t))(v9 + 16))(v11, a1, v8);
  return (*(uint64_t (**)(char *, uint64_t, uint64_t, void))(*(void *)(a3 + 24) + 16LL))( v11,  a2,  a4,  *(void *)(a3 + 16));
}

uint64_t sub_1000B2CC4(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = *(void *)(a2 + 24);
  uint64_t v6 = type metadata accessor for Optional(0LL, v5);
  __chkstk_darwin(v6);
  uint64_t v8 = (char *)&v12 - v7;
  uint64_t v9 = *(void *)(v5 - 8);
  uint64_t v10 = *(unsigned __int8 *)(v2 + *(int *)(a2 + 44));
  (*(void (**)(char *, uint64_t, uint64_t))(v9 + 16))((char *)&v12 - v7, a1, v5);
  (*(void (**)(char *, void, uint64_t, uint64_t))(v9 + 56))(v8, 0LL, 1LL, v5);
  return (*(uint64_t (**)(char *, uint64_t, uint64_t, void))(*(void *)(a2 + 32) + 16LL))( v8,  v10,  v5,  *(void *)(a2 + 16));
}

uint64_t type metadata accessor for Preferences.Preference(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return sub_1000227C8(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for Preferences.Preference);
}

uint64_t sub_1000B2D98(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = a2[5];
  uint64_t v4 = a2[3];
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v3,  v4,  &protocol requirements base descriptor for RawRepresentable);
  uint64_t v6 = *(void *)(AssociatedTypeWitness - 8);
  __chkstk_darwin(AssociatedTypeWitness);
  uint64_t v8 = (char *)&v11 - v7;
  dispatch thunk of RawRepresentable.rawValue.getter(v4, v3);
  uint64_t v9 = type metadata accessor for Preferences.Preference(0LL, a2[2], AssociatedTypeWitness, a2[4]);
  sub_1000B2CC4((uint64_t)v8, v9);
  return (*(uint64_t (**)(char *, uint64_t))(v6 + 8))(v8, AssociatedTypeWitness);
}

unint64_t sub_1000B2E80()
{
  unint64_t result = qword_100406BA0;
  if (!qword_100406BA0)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for PreferenceDefaults.InternetSharingOptions,  &type metadata for PreferenceDefaults.InternetSharingOptions);
    atomic_store(result, (unint64_t *)&qword_100406BA0);
  }

  return result;
}

uint64_t type metadata accessor for Preferences.EnumPreference(uint64_t a1, uint64_t a2)
{
  return swift_getGenericMetadata(a1, a2, &nominal type descriptor for Preferences.EnumPreference);
}

uint64_t type metadata accessor for Preferences.WiFiAddressPreference( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return sub_1000227C8(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for Preferences.WiFiAddressPreference);
}

unint64_t sub_1000B2EDC()
{
  unint64_t result = qword_100406BA8;
  if (!qword_100406BA8)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for PreferenceDefaults.EnableUserspaceP2POptions,  &type metadata for PreferenceDefaults.EnableUserspaceP2POptions);
    atomic_store(result, (unint64_t *)&qword_100406BA8);
  }

  return result;
}

uint64_t type metadata accessor for Preferences(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return sub_1000227C8(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for Preferences);
}

uint64_t sub_1000B2F2C(uint64_t a1)
{
  uint64_t v2 = sub_100002274(&qword_100405280);
  (*(void (**)(uint64_t, uint64_t))(*(void *)(v2 - 8) + 8LL))(a1, v2);
  return a1;
}

uint64_t type metadata accessor for CachedPreferenceStorage.EmptyPreference( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return sub_1000227C8(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for CachedPreferenceStorage.EmptyPreference);
}

unint64_t sub_1000B2F80()
{
  unint64_t result = qword_100406BB8;
  if (!qword_100406BB8)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for PreferenceDefaults.EnableUserspaceP2POptions,  &type metadata for PreferenceDefaults.EnableUserspaceP2POptions);
    atomic_store(result, (unint64_t *)&qword_100406BB8);
  }

  return result;
}

unint64_t sub_1000B2FC8()
{
  unint64_t result = qword_100406BC0;
  if (!qword_100406BC0)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for PreferenceDefaults.EnableUserspaceP2POptions,  &type metadata for PreferenceDefaults.EnableUserspaceP2POptions);
    atomic_store(result, (unint64_t *)&qword_100406BC0);
  }

  return result;
}

unint64_t sub_1000B3010()
{
  unint64_t result = qword_100406BC8;
  if (!qword_100406BC8)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for PreferenceDefaults.EnableUserspaceP2POptions,  &type metadata for PreferenceDefaults.EnableUserspaceP2POptions);
    atomic_store(result, (unint64_t *)&qword_100406BC8);
  }

  return result;
}

unint64_t sub_1000B3058()
{
  unint64_t result = qword_100406BD0;
  if (!qword_100406BD0)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for PreferenceDefaults.InternetSharingOptions,  &type metadata for PreferenceDefaults.InternetSharingOptions);
    atomic_store(result, (unint64_t *)&qword_100406BD0);
  }

  return result;
}

unint64_t sub_1000B30A0()
{
  unint64_t result = qword_100406BD8;
  if (!qword_100406BD8)
  {
    uint64_t v1 = sub_1000022F8(&qword_100406BE0);
    unint64_t result = swift_getWitnessTable(&protocol conformance descriptor for [A], v1);
    atomic_store(result, (unint64_t *)&qword_100406BD8);
  }

  return result;
}

unint64_t sub_1000B30F0()
{
  unint64_t result = qword_100406BE8[0];
  if (!qword_100406BE8[0])
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for PreferencesName,  &type metadata for PreferencesName);
    atomic_store(result, qword_100406BE8);
  }

  return result;
}

ValueMetadata *type metadata accessor for PreferenceDefaults()
{
  return &type metadata for PreferenceDefaults;
}

ValueMetadata *type metadata accessor for PreferenceDefaults.EnableUserspaceP2POptions()
{
  return &type metadata for PreferenceDefaults.EnableUserspaceP2POptions;
}

uint64_t storeEnumTagSinglePayload for PreferenceDefaults.InternetSharingOptions( _BYTE *a1, unsigned int a2, unsigned int a3)
{
  if (a3 + 2 >= 0xFFFF00) {
    int v3 = 4;
  }
  else {
    int v3 = 2;
  }
  if ((a3 + 2) >> 8 < 0xFF) {
    LODWORD(v4) = 1;
  }
  else {
    LODWORD(v4) = v3;
  }
  if (a3 >= 0xFE) {
    uint64_t v4 = v4;
  }
  else {
    uint64_t v4 = 0LL;
  }
  if (a2 <= 0xFD) {
    return ((uint64_t (*)(void))((char *)&loc_1000B31A0 + 4 * byte_10033F1FB[v4]))();
  }
  *a1 = a2 + 2;
  return ((uint64_t (*)(void))((char *)sub_1000B31D4 + 4 * byte_10033F1F6[v4]))();
}

uint64_t sub_1000B31D4(uint64_t result)
{
  *(_BYTE *)(result + 1) = v1;
  return result;
}

uint64_t sub_1000B31DC(uint64_t result, int a2)
{
  *(_WORD *)(result + 1) = 0;
  if (a2) {
    JUMPOUT(0x1000B31E4LL);
  }
  return result;
}

uint64_t sub_1000B31F0(uint64_t result, int a2)
{
  *(_DWORD *)(result + 1) = 0;
  if (!a2) {
    JUMPOUT(0x1000B31F8LL);
  }
  *(_BYTE *)unint64_t result = a2 + 2;
  return result;
}

uint64_t sub_1000B31FC(uint64_t result)
{
  *(_DWORD *)(result + 1) = v1;
  return result;
}

uint64_t sub_1000B3204(uint64_t result)
{
  *(_WORD *)(result + 1) = v1;
  return result;
}

ValueMetadata *type metadata accessor for PreferenceDefaults.InternetSharingOptions()
{
  return &type metadata for PreferenceDefaults.InternetSharingOptions;
}

uint64_t getEnumTagSinglePayload for PreferencesName(unsigned __int8 *a1, unsigned int a2)
{
  if (!a2) {
    return 0LL;
  }
  if (a2 < 0xEB) {
    goto LABEL_17;
  }
  if (a2 + 21 >= 0xFFFF00) {
    int v2 = 4;
  }
  else {
    int v2 = 2;
  }
  if ((a2 + 21) >> 8 < 0xFF) {
    int v3 = 1;
  }
  else {
    int v3 = v2;
  }
  if (v3 == 4)
  {
    int v4 = *(_DWORD *)(a1 + 1);
    if (v4) {
      return (*a1 | (v4 << 8)) - 21;
    }
  }

  else
  {
    if (v3 == 2)
    {
      int v4 = *(unsigned __int16 *)(a1 + 1);
      if (!*(_WORD *)(a1 + 1)) {
        goto LABEL_17;
      }
      return (*a1 | (v4 << 8)) - 21;
    }

    int v4 = a1[1];
    if (a1[1]) {
      return (*a1 | (v4 << 8)) - 21;
    }
  }

uint64_t storeEnumTagSinglePayload for PreferencesName(_BYTE *a1, unsigned int a2, unsigned int a3)
{
  if (a3 + 21 >= 0xFFFF00) {
    int v3 = 4;
  }
  else {
    int v3 = 2;
  }
  if ((a3 + 21) >> 8 < 0xFF) {
    LODWORD(v4) = 1;
  }
  else {
    LODWORD(v4) = v3;
  }
  if (a3 >= 0xEB) {
    uint64_t v4 = v4;
  }
  else {
    uint64_t v4 = 0LL;
  }
  if (a2 <= 0xEA) {
    return ((uint64_t (*)(void))((char *)&loc_1000B32FC + 4 * byte_10033F205[v4]))();
  }
  *a1 = a2 + 21;
  return ((uint64_t (*)(void))((char *)sub_1000B3330 + 4 * byte_10033F200[v4]))();
}

uint64_t sub_1000B3330(uint64_t result)
{
  *(_BYTE *)(result + 1) = v1;
  return result;
}

uint64_t sub_1000B3338(uint64_t result, int a2)
{
  *(_WORD *)(result + 1) = 0;
  if (a2) {
    JUMPOUT(0x1000B3340LL);
  }
  return result;
}

uint64_t sub_1000B334C(uint64_t result, int a2)
{
  *(_DWORD *)(result + 1) = 0;
  if (!a2) {
    JUMPOUT(0x1000B3354LL);
  }
  *(_BYTE *)unint64_t result = a2 + 21;
  return result;
}

uint64_t sub_1000B3358(uint64_t result)
{
  *(_DWORD *)(result + 1) = v1;
  return result;
}

uint64_t sub_1000B3360(uint64_t result)
{
  *(_WORD *)(result + 1) = v1;
  return result;
}

ValueMetadata *type metadata accessor for PreferencesName()
{
  return &type metadata for PreferencesName;
}

uint64_t sub_1000B337C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return swift_allocateGenericValueMetadata(a1, a2, a3, 104LL);
}

uint64_t sub_1000B3384(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 16);
  uint64_t v2 = *(void *)(a1 + 24);
  uint64_t result = type metadata accessor for Preferences.Preference(319LL, v3, (uint64_t)&type metadata for Bool, v2);
  if (v5 <= 0x3F)
  {
    uint64_t v6 = *(void *)(result - 8) + 64LL;
    v18[0] = v6;
    v18[1] = v6;
    void v18[2] = v6;
    uint64_t v18[3] = v6;
    uint64_t result = type metadata accessor for Preferences.Preference(319LL, v3, (uint64_t)&type metadata for UInt32, v2);
    if (v7 <= 0x3F)
    {
      uint64_t v8 = *(void *)(result - 8) + 64LL;
      v18[4] = v8;
      uint64_t v14 = v3;
      uint64_t v15 = &type metadata for PreferenceDefaults.InternetSharingOptions;
      uint64_t v16 = v2;
      unint64_t v17 = sub_1000B2E80();
      uint64_t result = type metadata accessor for Preferences.EnumPreference(319LL, (uint64_t)&v14);
      if (v9 <= 0x3F)
      {
        v18[5] = *(void *)(result - 8) + 64LL;
        v18[6] = v6;
        v18[7] = v6;
        _OWORD v18[8] = v8;
        v18[9] = v6;
        v18[10] = v6;
        uint64_t result = type metadata accessor for Preferences.Preference(319LL, v3, (uint64_t)&type metadata for Double, v2);
        if (v10 <= 0x3F)
        {
          uint64_t v19 = *(void *)(result - 8) + 64LL;
          uint64_t v20 = v19;
          uint64_t v21 = v6;
          uint64_t result = type metadata accessor for Preferences.Preference(319LL, v3, (uint64_t)&type metadata for Data, v2);
          if (v11 <= 0x3F)
          {
            uint64_t v22 = *(void *)(result - 8) + 64LL;
            uint64_t v23 = v6;
            uint64_t v24 = v22;
            uint64_t v25 = v22;
            unint64_t v12 = sub_1000B2EDC();
            uint64_t v14 = v3;
            uint64_t v15 = &type metadata for PreferenceDefaults.EnableUserspaceP2POptions;
            uint64_t v16 = v2;
            unint64_t v17 = v12;
            uint64_t result = type metadata accessor for Preferences.EnumPreference(319LL, (uint64_t)&v14);
            if (v13 <= 0x3F)
            {
              uint64_t v26 = *(void *)(result - 8) + 64LL;
              uint64_t v27 = v6;
              uint64_t v28 = v6;
              uint64_t v29 = v6;
              swift_initStructMetadata(a1, 0LL, 22LL, v18, a1 + 32);
              return 0LL;
            }
          }
        }
      }
    }
  }

  return result;
}

void *sub_1000B3514(void *a1, void *a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a3 + 16);
  uint64_t v6 = *(void *)(v5 - 8);
  int v7 = *(_DWORD *)(v6 + 80);
  uint64_t v8 = v7 | 7LL;
  uint64_t v9 = ~v8;
  if ((v7 & 0x100000) != 0) {
    goto LABEL_5;
  }
  uint64_t v10 = *(void *)(v6 + 64);
  uint64_t v11 = v10 + 3 + v7;
  unint64_t v12 = (v10 & 0xFFFFFFFFFFFFFFFCLL) + 9;
  unint64_t v13 = (v10 & 0xFFFFFFFFFFFFFFF8LL) + 25;
  unint64_t v14 = v12 + v7;
  unint64_t v15 = (v11
       + ((v14
         + (((v7 | 3LL)
           + v10
           + 3
           + ((v11
             + ((v13
               + v7
               + ((v8 + 1) & ~v8)
               + ((v8
                 + v12
                 + (((v7 | 3LL)
                   + v10
                   + 3
                   + ((v11
                     + ((v11 + (v11 & ~(unint64_t)v7)) & ~(unint64_t)v7)) & ~(unint64_t)v7)) & ~(v7 | 3LL))) & ~v8)) & ~(unint64_t)v7)) & ~(unint64_t)v7)) & ~(v7 | 3LL))) & ~(unint64_t)v7)) & ~(unint64_t)v7;
  uint64_t v16 = v8 + v10 + 3;
  unint64_t v17 = (v10 & 0xFFFFFFFFFFFFFFF8LL) + 17;
  unint64_t v18 = (v8 + v17 + ((v16 + v15) & ~v8)) & ~v8;
  unint64_t v19 = v17 + v7;
  if (((v11
       + ((v11
         + ((v19
           + ((v7 + 8LL) & ~v8)
           + ((v8
             + v13
             + ((v8
               + v13
               + ((v16
                 + ((v13 + v7 + ((v16 + ((v19 + v18) & ~(unint64_t)v7)) & ~v8)) & ~(unint64_t)v7)) & ~v8)) & ~v8)) & ~v8)) & ~(unint64_t)v7)) & ~(unint64_t)v7)) & ~(unint64_t)v7)
     + v10
     + 3 > 0x18)
  {
LABEL_5:
    uint64_t v111 = *a2;
    *a1 = *a2;
    int64_t v102 = (void *)(v111 + ((v7 + 16LL) & v9));
    swift_retain();
  }

  else
  {
    unint64_t v20 = ~(unint64_t)v7;
    uint64_t v122 = (v7 | 3LL) + v10 + 3;
    uint64_t v123 = ~(v7 | 3LL);
    uint64_t v21 = *(void (**)(unint64_t, unint64_t, uint64_t))(v6 + 16);
    unint64_t v118 = v13 + v7;
    unint64_t v119 = v19 + ((v7 + 8LL) & ~v8);
    unint64_t v117 = v19;
    unint64_t v114 = v118 + ((v8 + 1) & ~v8);
    unint64_t v115 = v14;
    v21((unint64_t)a1, (unint64_t)a2, v5);
    unint64_t v120 = a1;
    uint64_t v23 = (char *)a1 + v10;
    _BYTE *v23 = *((_BYTE *)a2 + v10);
    v23[1] = *((_BYTE *)a2 + v10 + 1);
    v23[2] = *((_BYTE *)a2 + v10 + 2);
    uint64_t v24 = v11;
    unint64_t v25 = ((unint64_t)a1 + v11) & v20;
    unint64_t v26 = ((unint64_t)a2 + v24) & v20;
    v21(v25, v26, v5);
    uint64_t v27 = (_BYTE *)(v25 + v10);
    *uint64_t v27 = *(_BYTE *)(v26 + v10);
    v27[1] = *(_BYTE *)(v26 + v10 + 1);
    v27[2] = *(_BYTE *)(v26 + v10 + 2);
    unint64_t v28 = (v24 + v25) & v20;
    unint64_t v29 = (v24 + v26) & v20;
    v21(v28, v29, v5);
    uint64_t v30 = (_BYTE *)(v28 + v10);
    *uint64_t v30 = *(_BYTE *)(v29 + v10);
    v30[1] = *(_BYTE *)(v29 + v10 + 1);
    void v30[2] = *(_BYTE *)(v29 + v10 + 2);
    unint64_t v31 = (v24 + v28) & v20;
    unint64_t v32 = (v24 + v29) & v20;
    v21(v31, v32, v5);
    Swift::String v33 = (_BYTE *)(v31 + v10);
    _BYTE *v33 = *(_BYTE *)(v32 + v10);
    v33[1] = *(_BYTE *)(v32 + v10 + 1);
    v33[2] = *(_BYTE *)(v32 + v10 + 2);
    uint64_t v34 = (v122 + v31) & v123;
    uint64_t v35 = (v122 + v32) & v123;
    v21(v34, v35, v5);
    *(_BYTE *)(v34 + v10) = *(_BYTE *)(v35 + v10);
    unint64_t v36 = (v34 + v10) & 0xFFFFFFFFFFFFFFFCLL;
    unint64_t v37 = (v35 + v10) & 0xFFFFFFFFFFFFFFFCLL;
    *(_DWORD *)(v36 + 4) = *(_DWORD *)(v37 + 4);
    *(_BYTE *)(v36 + 8) = *(_BYTE *)(v37 + 8);
    uint64_t v38 = (_BYTE *)((v10 + 16 + v35) & v9);
    uint64_t v39 = v9;
    Swift::String v40 = (_BYTE *)((v10 + 16 + v34) & v9);
    *Swift::String v40 = *v38;
    uint64_t v41 = (unint64_t)(v40 + 8) & v39;
    uint64_t v42 = (unint64_t)(v38 + 8) & v39;
    v21(v41, v42, v5);
    *(_BYTE *)(v41 + v10) = *(_BYTE *)(v42 + v10);
    unint64_t v43 = (v41 + v10) & 0xFFFFFFFFFFFFFFF8LL;
    unint64_t v44 = (v42 + v10) & 0xFFFFFFFFFFFFFFF8LL;
    *(void *)(v43 + 8) = *(void *)(v44 + 8);
    uint64_t v45 = *(void *)(v44 + 16);
    *(void *)(v43 + 16) = v45;
    *(_BYTE *)(v43 + 24) = *(_BYTE *)(v44 + 24);
    unint64_t v46 = (unint64_t)&v40[v114] & v20;
    unint64_t v47 = (unint64_t)&v38[v114] & v20;
    swift_bridgeObjectRetain(v45);
    v21(v46, v47, v5);
    Swift::String v48 = (_BYTE *)(v46 + v10);
    *Swift::String v48 = *(_BYTE *)(v47 + v10);
    v48[1] = *(_BYTE *)(v47 + v10 + 1);
    v48[2] = *(_BYTE *)(v47 + v10 + 2);
    unint64_t v49 = (v24 + v46) & v20;
    unint64_t v50 = (v24 + v47) & v20;
    v21(v49, v50, v5);
    uint64_t v51 = (_BYTE *)(v49 + v10);
    *uint64_t v51 = *(_BYTE *)(v50 + v10);
    v51[1] = *(_BYTE *)(v50 + v10 + 1);
    v51[2] = *(_BYTE *)(v50 + v10 + 2);
    uint64_t v52 = (v122 + v49) & v123;
    uint64_t v53 = (v122 + v50) & v123;
    v21(v52, v53, v5);
    *(_BYTE *)(v52 + v10) = *(_BYTE *)(v53 + v10);
    unint64_t v54 = (v52 + v10) & 0xFFFFFFFFFFFFFFFCLL;
    unint64_t v55 = (v53 + v10) & 0xFFFFFFFFFFFFFFFCLL;
    *(_DWORD *)(v54 + 4) = *(_DWORD *)(v55 + 4);
    *(_BYTE *)(v54 + 8) = *(_BYTE *)(v55 + 8);
    unint64_t v56 = (v115 + v52) & v20;
    unint64_t v57 = (v115 + v53) & v20;
    v21(v56, v57, v5);
    Swift::String v58 = (_BYTE *)(v56 + v10);
    *Swift::String v58 = *(_BYTE *)(v57 + v10);
    v58[1] = *(_BYTE *)(v57 + v10 + 1);
    v58[2] = *(_BYTE *)(v57 + v10 + 2);
    uint64_t v116 = v24;
    unint64_t v59 = (v24 + v56) & v20;
    unint64_t v60 = (v24 + v57) & v20;
    v21(v59, v60, v5);
    uint64_t v61 = (_BYTE *)(v59 + v10);
    *uint64_t v61 = *(_BYTE *)(v60 + v10);
    v61[1] = *(_BYTE *)(v60 + v10 + 1);
    v61[2] = *(_BYTE *)(v60 + v10 + 2);
    uint64_t v62 = (v10 + 10 + v59) & v39;
    uint64_t v63 = (v10 + 10 + v60) & v39;
    v21(v62, v63, v5);
    *(_BYTE *)(v62 + v10) = *(_BYTE *)(v63 + v10);
    unint64_t v64 = (v62 + v10) & 0xFFFFFFFFFFFFFFF8LL;
    unint64_t v65 = (v63 + v10) & 0xFFFFFFFFFFFFFFF8LL;
    *(void *)(v64 + 8) = *(void *)(v65 + 8);
    *(_BYTE *)(v64 + 16) = *(_BYTE *)(v65 + 16);
    uint64_t v66 = (v10 + 24 + v62) & v39;
    uint64_t v67 = (v10 + 24 + v63) & v39;
    v21(v66, v67, v5);
    *(_BYTE *)(v66 + v10) = *(_BYTE *)(v67 + v10);
    unint64_t v68 = (v66 + v10) & 0xFFFFFFFFFFFFFFF8LL;
    unint64_t v69 = (v67 + v10) & 0xFFFFFFFFFFFFFFF8LL;
    *(void *)(v68 + 8) = *(void *)(v69 + 8);
    *(_BYTE *)(v68 + 16) = *(_BYTE *)(v69 + 16);
    unint64_t v70 = (v117 + v66) & v20;
    unint64_t v71 = (v117 + v67) & v20;
    uint64_t v113 = v5;
    v21(v70, v71, v5);
    unint64_t v121 = v21;
    Swift::String v72 = (_BYTE *)(v70 + v10);
    *Swift::String v72 = *(_BYTE *)(v71 + v10);
    v72[1] = *(_BYTE *)(v71 + v10 + 1);
    v72[2] = *(_BYTE *)(v71 + v10 + 2);
    uint64_t v73 = (v10 + 10 + v70) & v39;
    uint64_t v74 = (v10 + 10 + v71) & v39;
    v21(v73, v74, v5);
    *(_BYTE *)(v73 + v10) = *(_BYTE *)(v74 + v10);
    unint64_t v75 = (v73 + v10) & 0xFFFFFFFFFFFFFFF8LL;
    unint64_t v76 = (v74 + v10) & 0xFFFFFFFFFFFFFFF8LL;
    uint64_t v77 = *(void *)(v76 + 8);
    unint64_t v78 = *(void *)(v76 + 16);
    sub_100020AFC(v77, v78);
    *(void *)(v75 + 8) = v77;
    *(void *)(v75 + 16) = v78;
    *(_BYTE *)(v75 + 24) = *(_BYTE *)(v76 + 24);
    unint64_t v79 = (v118 + v73) & v20;
    unint64_t v80 = (v118 + v74) & v20;
    v121(v79, v80, v113);
    Swift::String v81 = (_BYTE *)(v79 + v10);
    *Swift::String v81 = *(_BYTE *)(v80 + v10);
    v81[1] = *(_BYTE *)(v80 + v10 + 1);
    v81[2] = *(_BYTE *)(v80 + v10 + 2);
    uint64_t v82 = (v10 + 10 + v79) & v39;
    uint64_t v83 = (v10 + 10 + v80) & v39;
    v121(v82, v83, v113);
    *(_BYTE *)(v82 + v10) = *(_BYTE *)(v83 + v10);
    unint64_t v84 = (v82 + v10) & 0xFFFFFFFFFFFFFFF8LL;
    unint64_t v85 = (v83 + v10) & 0xFFFFFFFFFFFFFFF8LL;
    uint64_t v86 = *(void *)(v85 + 8);
    unint64_t v87 = *(void *)(v85 + 16);
    sub_100020AFC(v86, v87);
    *(void *)(v84 + 8) = v86;
    *(void *)(v84 + 16) = v87;
    *(_BYTE *)(v84 + 24) = *(_BYTE *)(v85 + 24);
    uint64_t v88 = (v10 + 32 + v82) & v39;
    uint64_t v89 = (v10 + 32 + v83) & v39;
    v121(v88, v89, v113);
    *(_BYTE *)(v88 + v10) = *(_BYTE *)(v89 + v10);
    unint64_t v90 = (v88 + v10) & 0xFFFFFFFFFFFFFFF8LL;
    unint64_t v91 = (v89 + v10) & 0xFFFFFFFFFFFFFFF8LL;
    uint64_t v92 = *(void *)(v91 + 8);
    unint64_t v93 = *(void *)(v91 + 16);
    sub_100020AFC(v92, v93);
    *(void *)(v90 + 8) = v92;
    *(void *)(v90 + 16) = v93;
    *(_BYTE *)(v90 + 24) = *(_BYTE *)(v91 + 24);
    uint64_t v94 = (void *)((v10 + 32 + v89) & v39);
    uint64_t v95 = (void *)((v10 + 32 + v88) & v39);
    *uint64_t v95 = *v94;
    uint64_t v96 = ((unint64_t)v95 + 15) & v39;
    uint64_t v97 = ((unint64_t)v94 + 15) & v39;
    v121(v96, v97, v113);
    *(_BYTE *)(v96 + v10) = *(_BYTE *)(v97 + v10);
    unint64_t v98 = (v96 + v10) & 0xFFFFFFFFFFFFFFF8LL;
    unint64_t v99 = (v97 + v10) & 0xFFFFFFFFFFFFFFF8LL;
    *(void *)(v98 + 8) = *(void *)(v99 + 8);
    *(_BYTE *)(v98 + 16) = *(_BYTE *)(v99 + 16);
    unint64_t v100 = ((unint64_t)v95 + v119) & v20;
    unint64_t v101 = (unint64_t)v94 + v119;
    int64_t v102 = v120;
    unint64_t v103 = v101 & v20;
    v121(v100, v101 & v20, v113);
    unint64_t v104 = (_BYTE *)(v100 + v10);
    _BYTE *v104 = *(_BYTE *)(v103 + v10);
    v104[1] = *(_BYTE *)(v103 + v10 + 1);
    v104[2] = *(_BYTE *)(v103 + v10 + 2);
    unint64_t v105 = (v116 + v100) & v20;
    unint64_t v106 = (v116 + v103) & v20;
    v121(v105, v106, v113);
    int64_t v107 = (_BYTE *)(v105 + v10);
    *int64_t v107 = *(_BYTE *)(v106 + v10);
    v107[1] = *(_BYTE *)(v106 + v10 + 1);
    v107[2] = *(_BYTE *)(v106 + v10 + 2);
    unint64_t v108 = (v116 + v105) & v20;
    unint64_t v109 = (v116 + v106) & v20;
    v121(v108, v109, v113);
    __int128 v110 = (_BYTE *)(v108 + v10);
    *__int128 v110 = *(_BYTE *)(v109 + v10);
    v110[1] = *(_BYTE *)(v109 + v10 + 1);
    v110[2] = *(_BYTE *)(v109 + v10 + 2);
  }

  return v102;
}

uint64_t sub_1000B3D50(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 16);
  uint64_t v4 = *(void *)(v3 - 8);
  uint64_t v35 = *(void (**)(uint64_t, uint64_t))(v4 + 8);
  v35(a1, v3);
  uint64_t v5 = *(void *)(v4 + 64);
  uint64_t v6 = *(unsigned __int8 *)(v4 + 80);
  uint64_t v33 = v5 + 3 + v6;
  uint64_t v7 = (v33 + a1) & ~v6;
  v35(v7, v3);
  uint64_t v8 = (v33 + v7) & ~v6;
  v35(v8, v3);
  uint64_t v9 = (v33 + v8) & ~v6;
  v35(v9, v3);
  uint64_t v10 = (v6 | 3) + v5 + 3;
  uint64_t v11 = (v10 + v9) & ~(v6 | 3);
  v35(v11, v3);
  unint64_t v12 = (v5 & 0xFFFFFFFFFFFFFFFCLL) + 9;
  uint64_t v13 = v6 | 7;
  uint64_t v14 = ((v6 | 7) + v12 + v11) & ~(v6 | 7);
  uint64_t v15 = (v6 | 7) + 1;
  v35((v15 + v14) & ~(v6 | 7), v3);
  swift_bridgeObjectRelease(*(void *)(((((v15 + v14) & ~(v6 | 7)) + v5) & 0xFFFFFFFFFFFFF8LL) + 0x10));
  unint64_t v34 = (v5 & 0xFFFFFFFFFFFFFFF8LL) + 25;
  v35((v34 + v6 + (v15 & ~(v6 | 7)) + v14) & ~v6, v3);
  uint64_t v16 = (v33 + ((v34 + v6 + (v15 & ~(v6 | 7)) + v14) & ~v6)) & ~v6;
  v35(v16, v3);
  uint64_t v17 = (v10 + v16) & ~(v6 | 3);
  v35(v17, v3);
  unint64_t v18 = (v12 + v6 + v17) & ~v6;
  v35(v18, v3);
  unint64_t v19 = (v33 + v18) & ~v6;
  v35(v19, v3);
  uint64_t v20 = (v6 | 7) + v5 + 3;
  uint64_t v21 = (v13 + v5 + 3 + v19) & ~v13;
  v35(v21, v3);
  unint64_t v22 = (v5 & 0xFFFFFFFFFFFFFFF8LL) + 17;
  unint64_t v23 = (v13 + v22 + v21) & ~v13;
  v35(v23, v3);
  unint64_t v24 = (v22 + v6 + v23) & ~v6;
  v35(v24, v3);
  uint64_t v25 = (v20 + v24) & ~(v6 | 7);
  v35(v25, v3);
  sub_1000208D8( *(void *)(((v25 + v5) & 0xFFFFFFFFFFFFFFF8LL) + 8),  *(void *)(((v25 + v5) & 0xFFFFFFFFFFFFFFF8LL) + 16));
  unint64_t v26 = (v34 + v6 + v25) & ~v6;
  v35(v26, v3);
  uint64_t v27 = (v20 + v26) & ~(v6 | 7);
  v35(v27, v3);
  sub_1000208D8( *(void *)(((v27 + v5) & 0xFFFFFFFFFFFFFFF8LL) + 8),  *(void *)(((v27 + v5) & 0xFFFFFFFFFFFFFFF8LL) + 16));
  unint64_t v28 = (v13 + v34 + v27) & ~v13;
  v35(v28, v3);
  sub_1000208D8( *(void *)(((v28 + v5) & 0xFFFFFFFFFFFFFFF8LL) + 8),  *(void *)(((v28 + v5) & 0xFFFFFFFFFFFFFFF8LL) + 16));
  uint64_t v29 = ((v6 | 7) + v34 + v28) & ~(v6 | 7);
  v35((v6 + 8 + v29) & ~(v6 | 7), v3);
  uint64_t v30 = (v22 + v6 + ((v6 + 8) & ~(v6 | 7)) + v29) & ~v6;
  v35(v30, v3);
  uint64_t v31 = (v33 + v30) & ~v6;
  v35(v31, v3);
  return ((uint64_t (*)(uint64_t, uint64_t))v35)((v33 + v31) & ~v6, v3);
}

uint64_t sub_1000B4074(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a3 + 16);
  uint64_t v6 = *(void *)(v5 - 8);
  uint64_t v7 = *(void (**)(void))(v6 + 16);
  uint64_t v8 = v5;
  v7();
  uint64_t v9 = v7;
  uint64_t v10 = *(void *)(v6 + 64);
  uint64_t v11 = (_BYTE *)(v10 + a1);
  uint64_t v114 = a1;
  *uint64_t v11 = *(_BYTE *)(v10 + a2);
  v11[1] = *(_BYTE *)(v10 + a2 + 1);
  v11[2] = *(_BYTE *)(v10 + a2 + 2);
  uint64_t v12 = *(unsigned __int8 *)(v6 + 80);
  uint64_t v13 = v10 + 3 + v12;
  uint64_t v14 = (v13 + a1) & ~v12;
  uint64_t v15 = (v13 + a2) & ~v12;
  uint64_t v16 = v8;
  ((void (*)(uint64_t, uint64_t, uint64_t))v9)(v14, v15, v8);
  uint64_t v17 = (_BYTE *)(v14 + v10);
  *uint64_t v17 = *(_BYTE *)(v15 + v10);
  v17[1] = *(_BYTE *)(v15 + v10 + 1);
  _BYTE v17[2] = *(_BYTE *)(v15 + v10 + 2);
  uint64_t v18 = (v13 + v14) & ~v12;
  uint64_t v19 = (v13 + v15) & ~v12;
  ((void (*)(uint64_t, uint64_t, uint64_t))v9)(v18, v19, v8);
  uint64_t v20 = (_BYTE *)(v18 + v10);
  *uint64_t v20 = *(_BYTE *)(v19 + v10);
  v20[1] = *(_BYTE *)(v19 + v10 + 1);
  v20[2] = *(_BYTE *)(v19 + v10 + 2);
  uint64_t v116 = v13;
  uint64_t v21 = (v13 + v18) & ~v12;
  uint64_t v22 = (v13 + v19) & ~v12;
  ((void (*)(uint64_t, uint64_t, uint64_t))v9)(v21, v22, v8);
  unint64_t v23 = (_BYTE *)(v21 + v10);
  _BYTE *v23 = *(_BYTE *)(v22 + v10);
  v23[1] = *(_BYTE *)(v22 + v10 + 1);
  v23[2] = *(_BYTE *)(v22 + v10 + 2);
  uint64_t v111 = (v12 | 3) + v10 + 3;
  uint64_t v24 = (v111 + v21) & ~(v12 | 3);
  uint64_t v25 = (v111 + v22) & ~(v12 | 3);
  ((void (*)(uint64_t, uint64_t, uint64_t))v9)(v24, v25, v8);
  unint64_t v26 = v9;
  unint64_t v117 = v9;
  *(_BYTE *)(v24 + v10) = *(_BYTE *)(v25 + v10);
  unint64_t v27 = (v24 + v10) & 0xFFFFFFFFFFFFFFFCLL;
  unint64_t v28 = (v25 + v10) & 0xFFFFFFFFFFFFFFFCLL;
  *(_DWORD *)(v27 + 4) = *(_DWORD *)(v28 + 4);
  *(_BYTE *)(v27 + 8) = *(_BYTE *)(v28 + 8);
  unint64_t v110 = (v10 & 0xFFFFFFFFFFFFFFFCLL) + 9;
  uint64_t v29 = v12 | 7;
  unint64_t v30 = (v12 | 7) + v110;
  uint64_t v31 = (_BYTE *)((v30 + v24) & ~(v12 | 7));
  unint64_t v32 = (_BYTE *)((v30 + v25) & ~(v12 | 7));
  *uint64_t v31 = *v32;
  uint64_t v33 = (v12 | 7) + 1;
  uint64_t v34 = (unint64_t)&v31[v33] & ~(v12 | 7);
  uint64_t v35 = (unint64_t)&v32[v33] & ~(v12 | 7);
  ((void (*)(uint64_t, uint64_t, uint64_t))v26)(v34, v35, v16);
  *(_BYTE *)(v34 + v10) = *(_BYTE *)(v35 + v10);
  unint64_t v36 = (v34 + v10) & 0xFFFFFFFFFFFFFFF8LL;
  unint64_t v37 = (v35 + v10) & 0xFFFFFFFFFFFFFFF8LL;
  *(void *)(v36 + 8) = *(void *)(v37 + 8);
  uint64_t v38 = *(void *)(v37 + 16);
  *(void *)(v36 + 16) = v38;
  *(_BYTE *)(v36 + 24) = *(_BYTE *)(v37 + 24);
  unint64_t v113 = (v10 & 0xFFFFFFFFFFFFFFF8LL) + 25;
  uint64_t v39 = v113 + v12 + (v33 & ~(v12 | 7));
  unint64_t v40 = (unint64_t)&v31[v39] & ~v12;
  unint64_t v41 = (unint64_t)&v32[v39] & ~v12;
  swift_bridgeObjectRetain(v38);
  ((void (*)(unint64_t, unint64_t, uint64_t))v117)(v40, v41, v16);
  uint64_t v42 = (_BYTE *)(v40 + v10);
  *uint64_t v42 = *(_BYTE *)(v41 + v10);
  v42[1] = *(_BYTE *)(v41 + v10 + 1);
  v42[2] = *(_BYTE *)(v41 + v10 + 2);
  unint64_t v43 = (v116 + v40) & ~v12;
  unint64_t v44 = (v116 + v41) & ~v12;
  ((void (*)(unint64_t, unint64_t, uint64_t))v117)(v43, v44, v16);
  uint64_t v45 = (_BYTE *)(v43 + v10);
  *uint64_t v45 = *(_BYTE *)(v44 + v10);
  v45[1] = *(_BYTE *)(v44 + v10 + 1);
  uint64_t v45[2] = *(_BYTE *)(v44 + v10 + 2);
  uint64_t v46 = (v111 + v43) & ~(v12 | 3);
  uint64_t v47 = (v111 + v44) & ~(v12 | 3);
  ((void (*)(uint64_t, uint64_t, uint64_t))v117)(v46, v47, v16);
  *(_BYTE *)(v46 + v10) = *(_BYTE *)(v47 + v10);
  unint64_t v48 = (v46 + v10) & 0xFFFFFFFFFFFFFFFCLL;
  unint64_t v49 = (v47 + v10) & 0xFFFFFFFFFFFFFFFCLL;
  *(_DWORD *)(v48 + 4) = *(_DWORD *)(v49 + 4);
  *(_BYTE *)(v48 + 8) = *(_BYTE *)(v49 + 8);
  unint64_t v50 = (v110 + v12 + v46) & ~v12;
  unint64_t v51 = (v110 + v12 + v47) & ~v12;
  ((void (*)(unint64_t, unint64_t, uint64_t))v117)(v50, v51, v16);
  uint64_t v52 = (_BYTE *)(v50 + v10);
  *uint64_t v52 = *(_BYTE *)(v51 + v10);
  v52[1] = *(_BYTE *)(v51 + v10 + 1);
  v52[2] = *(_BYTE *)(v51 + v10 + 2);
  unint64_t v53 = (v116 + v50) & ~v12;
  unint64_t v54 = (v116 + v51) & ~v12;
  ((void (*)(unint64_t, unint64_t, uint64_t))v117)(v53, v54, v16);
  unint64_t v55 = (_BYTE *)(v53 + v10);
  *unint64_t v55 = *(_BYTE *)(v54 + v10);
  v55[1] = *(_BYTE *)(v54 + v10 + 1);
  v55[2] = *(_BYTE *)(v54 + v10 + 2);
  uint64_t v56 = (v12 | 7) + v10 + 3;
  uint64_t v57 = (v29 + v10 + 3 + v53) & ~v29;
  uint64_t v58 = (v29 + v10 + 3 + v54) & ~v29;
  ((void (*)(uint64_t, uint64_t, uint64_t))v117)(v57, v58, v16);
  *(_BYTE *)(v57 + v10) = *(_BYTE *)(v58 + v10);
  unint64_t v59 = (v57 + v10) & 0xFFFFFFFFFFFFFFF8LL;
  unint64_t v60 = (v58 + v10) & 0xFFFFFFFFFFFFFFF8LL;
  *(void *)(v59 + 8) = *(void *)(v60 + 8);
  *(_BYTE *)(v59 + 16) = *(_BYTE *)(v60 + 16);
  unint64_t v61 = (v10 & 0xFFFFFFFFFFFFFFF8LL) + 17;
  unint64_t v62 = (v12 | 7) + v61;
  uint64_t v63 = (v62 + v57) & ~(v12 | 7);
  uint64_t v64 = (v62 + v58) & ~(v12 | 7);
  ((void (*)(uint64_t, uint64_t, uint64_t))v117)(v63, v64, v16);
  *(_BYTE *)(v63 + v10) = *(_BYTE *)(v64 + v10);
  unint64_t v65 = (v63 + v10) & 0xFFFFFFFFFFFFFFF8LL;
  unint64_t v66 = (v64 + v10) & 0xFFFFFFFFFFFFFFF8LL;
  *(void *)(v65 + 8) = *(void *)(v66 + 8);
  *(_BYTE *)(v65 + 16) = *(_BYTE *)(v66 + 16);
  uint64_t v112 = v61 + v12;
  unint64_t v67 = (v61 + v12 + v63) & ~v12;
  unint64_t v68 = (v61 + v12 + v64) & ~v12;
  uint64_t v115 = v16;
  ((void (*)(unint64_t, unint64_t, uint64_t))v117)(v67, v68, v16);
  unint64_t v69 = (_BYTE *)(v67 + v10);
  _BYTE *v69 = *(_BYTE *)(v68 + v10);
  v69[1] = *(_BYTE *)(v68 + v10 + 1);
  v69[2] = *(_BYTE *)(v68 + v10 + 2);
  uint64_t v70 = (v56 + v67) & ~(v12 | 7);
  uint64_t v71 = (v56 + v68) & ~(v12 | 7);
  ((void (*)(uint64_t, uint64_t, uint64_t))v117)(v70, v71, v16);
  *(_BYTE *)(v70 + v10) = *(_BYTE *)(v71 + v10);
  unint64_t v72 = (v70 + v10) & 0xFFFFFFFFFFFFFFF8LL;
  unint64_t v73 = (v71 + v10) & 0xFFFFFFFFFFFFFFF8LL;
  uint64_t v74 = *(void *)(v73 + 8);
  unint64_t v75 = *(void *)(v73 + 16);
  sub_100020AFC(v74, v75);
  *(void *)(v72 + 8) = v74;
  *(void *)(v72 + 16) = v75;
  *(_BYTE *)(v72 + 24) = *(_BYTE *)(v73 + 24);
  unint64_t v76 = (v113 + v12 + v70) & ~v12;
  unint64_t v77 = (v113 + v12 + v71) & ~v12;
  ((void (*)(unint64_t, unint64_t, uint64_t))v117)(v76, v77, v115);
  unint64_t v78 = (_BYTE *)(v76 + v10);
  *unint64_t v78 = *(_BYTE *)(v77 + v10);
  v78[1] = *(_BYTE *)(v77 + v10 + 1);
  v78[2] = *(_BYTE *)(v77 + v10 + 2);
  uint64_t v79 = (v56 + v76) & ~(v12 | 7);
  uint64_t v80 = (v56 + v77) & ~(v12 | 7);
  ((void (*)(uint64_t, uint64_t, uint64_t))v117)(v79, v80, v115);
  *(_BYTE *)(v79 + v10) = *(_BYTE *)(v80 + v10);
  unint64_t v81 = (v79 + v10) & 0xFFFFFFFFFFFFFFF8LL;
  unint64_t v82 = (v80 + v10) & 0xFFFFFFFFFFFFFFF8LL;
  uint64_t v83 = *(void *)(v82 + 8);
  unint64_t v84 = *(void *)(v82 + 16);
  sub_100020AFC(v83, v84);
  *(void *)(v81 + 8) = v83;
  *(void *)(v81 + 16) = v84;
  *(_BYTE *)(v81 + 24) = *(_BYTE *)(v82 + 24);
  unint64_t v85 = (v12 | 7) + v113;
  unint64_t v86 = (v29 + v113 + v79) & ~v29;
  unint64_t v87 = (v29 + v113 + v80) & ~v29;
  ((void (*)(unint64_t, unint64_t, uint64_t))v117)(v86, v87, v115);
  *(_BYTE *)(v86 + v10) = *(_BYTE *)(v87 + v10);
  unint64_t v88 = (v86 + v10) & 0xFFFFFFFFFFFFFFF8LL;
  unint64_t v89 = (v87 + v10) & 0xFFFFFFFFFFFFFFF8LL;
  uint64_t v90 = *(void *)(v89 + 8);
  unint64_t v91 = *(void *)(v89 + 16);
  sub_100020AFC(v90, v91);
  *(void *)(v88 + 8) = v90;
  *(void *)(v88 + 16) = v91;
  *(_BYTE *)(v88 + 24) = *(_BYTE *)(v89 + 24);
  uint64_t v92 = (void *)((v85 + v86) & ~(v12 | 7));
  unint64_t v93 = (void *)((v85 + v87) & ~(v12 | 7));
  *uint64_t v92 = *v93;
  uint64_t v94 = ((unint64_t)v92 + v12 + 8) & ~(v12 | 7);
  uint64_t v95 = ((unint64_t)v93 + v12 + 8) & ~(v12 | 7);
  ((void (*)(unint64_t, unint64_t, uint64_t))v117)( ((unint64_t)v92 + v12 + 8) & ~v29,  ((unint64_t)v93 + v12 + 8) & ~v29,  v115);
  *(_BYTE *)(v94 + v10) = *(_BYTE *)(v95 + v10);
  unint64_t v96 = (v94 + v10) & 0xFFFFFFFFFFFFFFF8LL;
  unint64_t v97 = (v95 + v10) & 0xFFFFFFFFFFFFFFF8LL;
  *(void *)(v96 + 8) = *(void *)(v97 + 8);
  *(_BYTE *)(v96 + 16) = *(_BYTE *)(v97 + 16);
  uint64_t v98 = v112 + ((v12 + 8) & ~(v12 | 7));
  unint64_t v99 = ((unint64_t)v92 + v98) & ~v12;
  unint64_t v100 = ((unint64_t)v93 + v98) & ~v12;
  ((void (*)(unint64_t, unint64_t, uint64_t))v117)(v99, v100, v115);
  unint64_t v101 = (_BYTE *)(v99 + v10);
  *unint64_t v101 = *(_BYTE *)(v100 + v10);
  v101[1] = *(_BYTE *)(v100 + v10 + 1);
  v101[2] = *(_BYTE *)(v100 + v10 + 2);
  unint64_t v102 = (v116 + v99) & ~v12;
  uint64_t v103 = v10 + 3 + v12;
  unint64_t v104 = (v116 + v100) & ~v12;
  ((void (*)(unint64_t, unint64_t, uint64_t))v117)(v102, v104, v115);
  unint64_t v105 = (_BYTE *)(v102 + v10);
  *unint64_t v105 = *(_BYTE *)(v104 + v10);
  v105[1] = *(_BYTE *)(v104 + v10 + 1);
  v105[2] = *(_BYTE *)(v104 + v10 + 2);
  unint64_t v106 = (v103 + v102) & ~v12;
  unint64_t v107 = (v103 + v104) & ~v12;
  ((void (*)(unint64_t, unint64_t, uint64_t))v117)(v106, v107, v115);
  unint64_t v108 = (_BYTE *)(v106 + v10);
  *unint64_t v108 = *(_BYTE *)(v107 + v10);
  v108[1] = *(_BYTE *)(v107 + v10 + 1);
  v108[2] = *(_BYTE *)(v107 + v10 + 2);
  return v114;
}

uint64_t sub_1000B47C0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a3 + 16);
  uint64_t v6 = *(void *)(v5 - 8);
  uint64_t v7 = *(void (**)(void))(v6 + 24);
  uint64_t v8 = v5;
  v7();
  uint64_t v9 = v7;
  uint64_t v10 = *(void *)(v6 + 64);
  uint64_t v11 = (_BYTE *)(v10 + a1);
  uint64_t v122 = a1;
  *uint64_t v11 = *(_BYTE *)(v10 + a2);
  v11[1] = *(_BYTE *)(v10 + a2 + 1);
  v11[2] = *(_BYTE *)(v10 + a2 + 2);
  uint64_t v12 = *(unsigned __int8 *)(v6 + 80);
  uint64_t v13 = v10 + 3 + v12;
  uint64_t v14 = (v13 + a1) & ~v12;
  uint64_t v15 = (v13 + a2) & ~v12;
  uint64_t v16 = v8;
  ((void (*)(uint64_t, uint64_t, uint64_t))v9)(v14, v15, v8);
  uint64_t v17 = (_BYTE *)(v14 + v10);
  *uint64_t v17 = *(_BYTE *)(v15 + v10);
  v17[1] = *(_BYTE *)(v15 + v10 + 1);
  _BYTE v17[2] = *(_BYTE *)(v15 + v10 + 2);
  uint64_t v18 = (v13 + v14) & ~v12;
  uint64_t v19 = (v13 + v15) & ~v12;
  ((void (*)(uint64_t, uint64_t, uint64_t))v9)(v18, v19, v8);
  uint64_t v20 = (_BYTE *)(v18 + v10);
  *uint64_t v20 = *(_BYTE *)(v19 + v10);
  v20[1] = *(_BYTE *)(v19 + v10 + 1);
  v20[2] = *(_BYTE *)(v19 + v10 + 2);
  uint64_t v124 = v13;
  uint64_t v21 = (v13 + v18) & ~v12;
  uint64_t v22 = (v13 + v19) & ~v12;
  ((void (*)(uint64_t, uint64_t, uint64_t))v9)(v21, v22, v8);
  unint64_t v23 = (_BYTE *)(v21 + v10);
  _BYTE *v23 = *(_BYTE *)(v22 + v10);
  v23[1] = *(_BYTE *)(v22 + v10 + 1);
  v23[2] = *(_BYTE *)(v22 + v10 + 2);
  uint64_t v119 = (v12 | 3) + v10 + 3;
  uint64_t v24 = (v119 + v21) & ~(v12 | 3);
  uint64_t v25 = (v119 + v22) & ~(v12 | 3);
  ((void (*)(uint64_t, uint64_t, uint64_t))v9)(v24, v25, v8);
  unint64_t v26 = v9;
  unint64_t v125 = v9;
  *(_BYTE *)(v24 + v10) = *(_BYTE *)(v25 + v10);
  unint64_t v27 = (v24 + v10) & 0xFFFFFFFFFFFFFFFCLL;
  unint64_t v28 = (v25 + v10) & 0xFFFFFFFFFFFFFFFCLL;
  *(_DWORD *)(v27 + 4) = *(_DWORD *)(v28 + 4);
  *(_BYTE *)(v27 + 8) = *(_BYTE *)(v28 + 8);
  unint64_t v118 = (v10 & 0xFFFFFFFFFFFFFFFCLL) + 9;
  uint64_t v29 = v12 | 7;
  unint64_t v30 = (v12 | 7) + v118;
  uint64_t v31 = (_BYTE *)((v30 + v24) & ~(v12 | 7));
  unint64_t v32 = (_BYTE *)((v30 + v25) & ~(v12 | 7));
  *uint64_t v31 = *v32;
  uint64_t v33 = (v12 | 7) + 1;
  uint64_t v34 = (unint64_t)&v31[v33] & ~(v12 | 7);
  uint64_t v35 = (unint64_t)&v32[v33] & ~(v12 | 7);
  ((void (*)(uint64_t, uint64_t, uint64_t))v26)(v34, v35, v16);
  uint64_t v36 = v35 + v10;
  *(_BYTE *)(v34 + v10) = *(_BYTE *)(v35 + v10);
  unint64_t v37 = (v34 + v10) & 0xFFFFFFFFFFFFFFF8LL;
  unint64_t v38 = v36 & 0xFFFFFFFFFFFFFFF8LL;
  *(void *)(v37 + 8) = *(void *)((v36 & 0xFFFFFFFFFFFFFFF8LL) + 8);
  uint64_t v39 = *(void *)((v36 & 0xFFFFFFFFFFFFFFF8LL) + 16);
  uint64_t v40 = *(void *)(v37 + 16);
  *(void *)(v37 + 16) = v39;
  swift_bridgeObjectRetain(v39);
  swift_bridgeObjectRelease(v40);
  *(_BYTE *)(v37 + 24) = *(_BYTE *)(v38 + 24);
  unint64_t v121 = (v10 & 0xFFFFFFFFFFFFFFF8LL) + 25;
  uint64_t v41 = v121 + v12 + (v33 & ~(v12 | 7));
  unint64_t v42 = (unint64_t)&v31[v41] & ~v12;
  unint64_t v43 = (unint64_t)&v32[v41] & ~v12;
  ((void (*)(unint64_t, unint64_t, uint64_t))v125)(v42, v43, v16);
  unint64_t v44 = (_BYTE *)(v42 + v10);
  *unint64_t v44 = *(_BYTE *)(v43 + v10);
  v44[1] = *(_BYTE *)(v43 + v10 + 1);
  v44[2] = *(_BYTE *)(v43 + v10 + 2);
  unint64_t v45 = (v124 + v42) & ~v12;
  unint64_t v46 = (v124 + v43) & ~v12;
  ((void (*)(unint64_t, unint64_t, uint64_t))v125)(v45, v46, v16);
  uint64_t v47 = (_BYTE *)(v45 + v10);
  *uint64_t v47 = *(_BYTE *)(v46 + v10);
  v47[1] = *(_BYTE *)(v46 + v10 + 1);
  v47[2] = *(_BYTE *)(v46 + v10 + 2);
  uint64_t v48 = (v119 + v45) & ~(v12 | 3);
  uint64_t v49 = (v119 + v46) & ~(v12 | 3);
  ((void (*)(uint64_t, uint64_t, uint64_t))v125)(v48, v49, v16);
  *(_BYTE *)(v48 + v10) = *(_BYTE *)(v49 + v10);
  unint64_t v50 = (v48 + v10) & 0xFFFFFFFFFFFFFFFCLL;
  unint64_t v51 = (v49 + v10) & 0xFFFFFFFFFFFFFFFCLL;
  *(_DWORD *)(v50 + 4) = *(_DWORD *)(v51 + 4);
  *(_BYTE *)(v50 + 8) = *(_BYTE *)(v51 + 8);
  unint64_t v52 = (v118 + v12 + v48) & ~v12;
  unint64_t v53 = (v118 + v12 + v49) & ~v12;
  ((void (*)(unint64_t, unint64_t, uint64_t))v125)(v52, v53, v16);
  unint64_t v54 = (_BYTE *)(v52 + v10);
  _BYTE *v54 = *(_BYTE *)(v53 + v10);
  v54[1] = *(_BYTE *)(v53 + v10 + 1);
  v54[2] = *(_BYTE *)(v53 + v10 + 2);
  unint64_t v55 = (v124 + v52) & ~v12;
  unint64_t v56 = (v124 + v53) & ~v12;
  ((void (*)(unint64_t, unint64_t, uint64_t))v125)(v55, v56, v16);
  uint64_t v57 = (_BYTE *)(v55 + v10);
  *uint64_t v57 = *(_BYTE *)(v56 + v10);
  v57[1] = *(_BYTE *)(v56 + v10 + 1);
  v57[2] = *(_BYTE *)(v56 + v10 + 2);
  uint64_t v58 = (v12 | 7) + v10 + 3;
  uint64_t v59 = (v29 + v10 + 3 + v55) & ~v29;
  uint64_t v60 = (v29 + v10 + 3 + v56) & ~v29;
  ((void (*)(uint64_t, uint64_t, uint64_t))v125)(v59, v60, v16);
  *(_BYTE *)(v59 + v10) = *(_BYTE *)(v60 + v10);
  unint64_t v61 = (v59 + v10) & 0xFFFFFFFFFFFFFFF8LL;
  unint64_t v62 = (v60 + v10) & 0xFFFFFFFFFFFFFFF8LL;
  *(void *)(v61 + 8) = *(void *)(v62 + 8);
  *(_BYTE *)(v61 + 16) = *(_BYTE *)(v62 + 16);
  unint64_t v63 = (v10 & 0xFFFFFFFFFFFFFFF8LL) + 17;
  unint64_t v64 = (v12 | 7) + v63;
  uint64_t v65 = (v64 + v59) & ~(v12 | 7);
  uint64_t v66 = (v64 + v60) & ~(v12 | 7);
  ((void (*)(uint64_t, uint64_t, uint64_t))v125)(v65, v66, v16);
  *(_BYTE *)(v65 + v10) = *(_BYTE *)(v66 + v10);
  unint64_t v67 = (v65 + v10) & 0xFFFFFFFFFFFFFFF8LL;
  unint64_t v68 = (v66 + v10) & 0xFFFFFFFFFFFFFFF8LL;
  *(void *)(v67 + 8) = *(void *)(v68 + 8);
  *(_BYTE *)(v67 + 16) = *(_BYTE *)(v68 + 16);
  uint64_t v120 = v63 + v12;
  unint64_t v69 = (v63 + v12 + v65) & ~v12;
  unint64_t v70 = (v63 + v12 + v66) & ~v12;
  uint64_t v123 = v16;
  ((void (*)(unint64_t, unint64_t, uint64_t))v125)(v69, v70, v16);
  uint64_t v71 = (_BYTE *)(v69 + v10);
  *uint64_t v71 = *(_BYTE *)(v70 + v10);
  v71[1] = *(_BYTE *)(v70 + v10 + 1);
  v71[2] = *(_BYTE *)(v70 + v10 + 2);
  uint64_t v72 = (v58 + v69) & ~(v12 | 7);
  uint64_t v73 = (v58 + v70) & ~(v12 | 7);
  ((void (*)(uint64_t, uint64_t, uint64_t))v125)(v72, v73, v16);
  *(_BYTE *)(v72 + v10) = *(_BYTE *)(v73 + v10);
  unint64_t v74 = (v72 + v10) & 0xFFFFFFFFFFFFFFF8LL;
  unint64_t v75 = (v73 + v10) & 0xFFFFFFFFFFFFFFF8LL;
  uint64_t v76 = *(void *)(v75 + 8);
  unint64_t v77 = *(void *)(v75 + 16);
  sub_100020AFC(v76, v77);
  uint64_t v78 = *(void *)(v74 + 8);
  unint64_t v79 = *(void *)(v74 + 16);
  *(void *)(v74 + 8) = v76;
  *(void *)(v74 + 16) = v77;
  sub_1000208D8(v78, v79);
  *(_BYTE *)(v74 + 24) = *(_BYTE *)(v75 + 24);
  unint64_t v80 = (v121 + v12 + v72) & ~v12;
  unint64_t v81 = (v121 + v12 + v73) & ~v12;
  ((void (*)(unint64_t, unint64_t, uint64_t))v125)(v80, v81, v123);
  unint64_t v82 = (_BYTE *)(v80 + v10);
  *unint64_t v82 = *(_BYTE *)(v81 + v10);
  v82[1] = *(_BYTE *)(v81 + v10 + 1);
  v82[2] = *(_BYTE *)(v81 + v10 + 2);
  uint64_t v83 = (v58 + v80) & ~(v12 | 7);
  uint64_t v84 = (v58 + v81) & ~(v12 | 7);
  ((void (*)(uint64_t, uint64_t, uint64_t))v125)(v83, v84, v123);
  *(_BYTE *)(v83 + v10) = *(_BYTE *)(v84 + v10);
  unint64_t v85 = (v83 + v10) & 0xFFFFFFFFFFFFFFF8LL;
  unint64_t v86 = (v84 + v10) & 0xFFFFFFFFFFFFFFF8LL;
  uint64_t v87 = *(void *)(v86 + 8);
  unint64_t v88 = *(void *)(v86 + 16);
  sub_100020AFC(v87, v88);
  uint64_t v89 = *(void *)(v85 + 8);
  unint64_t v90 = *(void *)(v85 + 16);
  *(void *)(v85 + 8) = v87;
  *(void *)(v85 + 16) = v88;
  sub_1000208D8(v89, v90);
  *(_BYTE *)(v85 + 24) = *(_BYTE *)(v86 + 24);
  unint64_t v91 = (v12 | 7) + v121;
  unint64_t v92 = (v29 + v121 + v83) & ~v29;
  unint64_t v93 = (v29 + v121 + v84) & ~v29;
  ((void (*)(unint64_t, unint64_t, uint64_t))v125)(v92, v93, v123);
  *(_BYTE *)(v92 + v10) = *(_BYTE *)(v93 + v10);
  unint64_t v94 = (v92 + v10) & 0xFFFFFFFFFFFFFFF8LL;
  unint64_t v95 = (v93 + v10) & 0xFFFFFFFFFFFFFFF8LL;
  uint64_t v96 = *(void *)(v95 + 8);
  unint64_t v97 = *(void *)(v95 + 16);
  sub_100020AFC(v96, v97);
  uint64_t v98 = *(void *)(v94 + 8);
  unint64_t v99 = *(void *)(v94 + 16);
  *(void *)(v94 + 8) = v96;
  *(void *)(v94 + 16) = v97;
  sub_1000208D8(v98, v99);
  *(_BYTE *)(v94 + 24) = *(_BYTE *)(v95 + 24);
  unint64_t v100 = (void *)((v91 + v92) & ~(v12 | 7));
  unint64_t v101 = (void *)((v91 + v93) & ~(v12 | 7));
  *unint64_t v100 = *v101;
  uint64_t v102 = ((unint64_t)v100 + v12 + 8) & ~(v12 | 7);
  uint64_t v103 = ((unint64_t)v101 + v12 + 8) & ~(v12 | 7);
  ((void (*)(unint64_t, unint64_t, uint64_t))v125)( ((unint64_t)v100 + v12 + 8) & ~v29,  ((unint64_t)v101 + v12 + 8) & ~v29,  v123);
  *(_BYTE *)(v102 + v10) = *(_BYTE *)(v103 + v10);
  unint64_t v104 = (v102 + v10) & 0xFFFFFFFFFFFFFFF8LL;
  unint64_t v105 = (v103 + v10) & 0xFFFFFFFFFFFFFFF8LL;
  *(void *)(v104 + 8) = *(void *)(v105 + 8);
  *(_BYTE *)(v104 + 16) = *(_BYTE *)(v105 + 16);
  uint64_t v106 = v120 + ((v12 + 8) & ~(v12 | 7));
  unint64_t v107 = ((unint64_t)v100 + v106) & ~v12;
  unint64_t v108 = ((unint64_t)v101 + v106) & ~v12;
  ((void (*)(unint64_t, unint64_t, uint64_t))v125)(v107, v108, v123);
  unint64_t v109 = (_BYTE *)(v107 + v10);
  *unint64_t v109 = *(_BYTE *)(v108 + v10);
  v109[1] = *(_BYTE *)(v108 + v10 + 1);
  v109[2] = *(_BYTE *)(v108 + v10 + 2);
  unint64_t v110 = (v124 + v107) & ~v12;
  uint64_t v111 = v10 + 3 + v12;
  unint64_t v112 = (v124 + v108) & ~v12;
  ((void (*)(unint64_t, unint64_t, uint64_t))v125)(v110, v112, v123);
  unint64_t v113 = (_BYTE *)(v110 + v10);
  *unint64_t v113 = *(_BYTE *)(v112 + v10);
  v113[1] = *(_BYTE *)(v112 + v10 + 1);
  v113[2] = *(_BYTE *)(v112 + v10 + 2);
  unint64_t v114 = (v111 + v110) & ~v12;
  unint64_t v115 = (v111 + v112) & ~v12;
  ((void (*)(unint64_t, unint64_t, uint64_t))v125)(v114, v115, v123);
  uint64_t v116 = (_BYTE *)(v114 + v10);
  _BYTE *v116 = *(_BYTE *)(v115 + v10);
  v116[1] = *(_BYTE *)(v115 + v10 + 1);
  v116[2] = *(_BYTE *)(v115 + v10 + 2);
  return v122;
}

uint64_t sub_1000B4F30(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a3 + 16);
  uint64_t v6 = *(void *)(v5 - 8);
  uint64_t v7 = *(void (**)(uint64_t, uint64_t, uint64_t))(v6 + 32);
  v7(a1, a2, v5);
  uint64_t v8 = v7;
  uint64_t v9 = *(void *)(v6 + 64);
  uint64_t v10 = (_BYTE *)(v9 + a1);
  uint64_t v106 = a1;
  *uint64_t v10 = *(_BYTE *)(v9 + a2);
  v10[1] = *(_BYTE *)(v9 + a2 + 1);
  v10[2] = *(_BYTE *)(v9 + a2 + 2);
  uint64_t v11 = *(unsigned __int8 *)(v6 + 80);
  uint64_t v12 = v9 + 3 + v11;
  uint64_t v13 = (v12 + a1) & ~v11;
  uint64_t v14 = (v12 + a2) & ~v11;
  v8(v13, v14, v5);
  uint64_t v15 = (_BYTE *)(v13 + v9);
  *uint64_t v15 = *(_BYTE *)(v14 + v9);
  v15[1] = *(_BYTE *)(v14 + v9 + 1);
  void v15[2] = *(_BYTE *)(v14 + v9 + 2);
  uint64_t v16 = (v12 + v13) & ~v11;
  uint64_t v17 = (v12 + v14) & ~v11;
  v8(v16, v17, v5);
  uint64_t v18 = (_BYTE *)(v16 + v9);
  *uint64_t v18 = *(_BYTE *)(v17 + v9);
  v18[1] = *(_BYTE *)(v17 + v9 + 1);
  void v18[2] = *(_BYTE *)(v17 + v9 + 2);
  uint64_t v19 = (v12 + v16) & ~v11;
  uint64_t v20 = (v12 + v17) & ~v11;
  v8(v19, v20, v5);
  uint64_t v21 = (_BYTE *)(v19 + v9);
  *uint64_t v21 = *(_BYTE *)(v20 + v9);
  v21[1] = *(_BYTE *)(v20 + v9 + 1);
  v21[2] = *(_BYTE *)(v20 + v9 + 2);
  uint64_t v104 = (v11 | 3) + v9 + 3;
  uint64_t v22 = (v104 + v19) & ~(v11 | 3);
  uint64_t v23 = (v104 + v20) & ~(v11 | 3);
  uint64_t v102 = v5;
  v8(v22, v23, v5);
  uint64_t v24 = v8;
  *(_BYTE *)(v22 + v9) = *(_BYTE *)(v23 + v9);
  unint64_t v25 = (v22 + v9) & 0xFFFFFFFFFFFFFFFCLL;
  unint64_t v26 = (v23 + v9) & 0xFFFFFFFFFFFFFFFCLL;
  *(_DWORD *)(v25 + 4) = *(_DWORD *)(v26 + 4);
  *(_BYTE *)(v25 + 8) = *(_BYTE *)(v26 + 8);
  unint64_t v103 = (v9 & 0xFFFFFFFFFFFFFFFCLL) + 9;
  uint64_t v27 = v11 | 7;
  unint64_t v28 = (v11 | 7) + v103;
  uint64_t v29 = (_BYTE *)((v28 + v22) & ~(v11 | 7));
  unint64_t v30 = (_BYTE *)((v28 + v23) & ~(v11 | 7));
  _BYTE *v29 = *v30;
  uint64_t v31 = (v11 | 7) + 1;
  uint64_t v32 = (unint64_t)&v29[v31] & ~(v11 | 7);
  uint64_t v33 = (unint64_t)&v30[v31] & ~(v11 | 7);
  uint64_t v34 = v5;
  uint64_t v35 = (void (*)(unint64_t, unint64_t, uint64_t))v24;
  v24(v32, v33, v34);
  *(_BYTE *)(v32 + v9) = *(_BYTE *)(v33 + v9);
  unint64_t v36 = (v32 + v9) & 0xFFFFFFFFFFFFFFF8LL;
  unint64_t v37 = (v33 + v9) & 0xFFFFFFFFFFFFFFF8LL;
  *(_OWORD *)(v36 + 8) = *(_OWORD *)(v37 + 8);
  *(_BYTE *)(v36 + 24) = *(_BYTE *)(v37 + 24);
  unint64_t v105 = (v9 & 0xFFFFFFFFFFFFFFF8LL) + 25;
  uint64_t v38 = v105 + v11 + (v31 & ~(v11 | 7));
  unint64_t v39 = (unint64_t)&v29[v38] & ~v11;
  unint64_t v40 = (unint64_t)&v30[v38] & ~v11;
  v35(v39, v40, v102);
  uint64_t v41 = (_BYTE *)(v39 + v9);
  *uint64_t v41 = *(_BYTE *)(v40 + v9);
  v41[1] = *(_BYTE *)(v40 + v9 + 1);
  v41[2] = *(_BYTE *)(v40 + v9 + 2);
  unint64_t v42 = (v12 + v39) & ~v11;
  unint64_t v43 = (v12 + v40) & ~v11;
  v35(v42, v43, v102);
  unint64_t v44 = (_BYTE *)(v42 + v9);
  *unint64_t v44 = *(_BYTE *)(v43 + v9);
  v44[1] = *(_BYTE *)(v43 + v9 + 1);
  v44[2] = *(_BYTE *)(v43 + v9 + 2);
  uint64_t v45 = (v104 + v42) & ~(v11 | 3);
  uint64_t v46 = (v104 + v43) & ~(v11 | 3);
  v35(v45, v46, v102);
  *(_BYTE *)(v45 + v9) = *(_BYTE *)(v46 + v9);
  unint64_t v47 = (v45 + v9) & 0xFFFFFFFFFFFFFFFCLL;
  unint64_t v48 = (v46 + v9) & 0xFFFFFFFFFFFFFFFCLL;
  *(_DWORD *)(v47 + 4) = *(_DWORD *)(v48 + 4);
  *(_BYTE *)(v47 + 8) = *(_BYTE *)(v48 + 8);
  unint64_t v49 = (v103 + v11 + v45) & ~v11;
  unint64_t v50 = (v103 + v11 + v46) & ~v11;
  v35(v49, v50, v102);
  unint64_t v51 = (_BYTE *)(v49 + v9);
  *unint64_t v51 = *(_BYTE *)(v50 + v9);
  v51[1] = *(_BYTE *)(v50 + v9 + 1);
  v51[2] = *(_BYTE *)(v50 + v9 + 2);
  unint64_t v52 = (v12 + v49) & ~v11;
  unint64_t v53 = (v12 + v50) & ~v11;
  v35(v52, v53, v102);
  unint64_t v54 = (_BYTE *)(v52 + v9);
  _BYTE *v54 = *(_BYTE *)(v53 + v9);
  v54[1] = *(_BYTE *)(v53 + v9 + 1);
  v54[2] = *(_BYTE *)(v53 + v9 + 2);
  uint64_t v55 = (v11 | 7) + v9 + 3;
  uint64_t v56 = (v27 + v9 + 3 + v52) & ~v27;
  uint64_t v57 = (v27 + v9 + 3 + v53) & ~v27;
  v35(v56, v57, v102);
  *(_BYTE *)(v56 + v9) = *(_BYTE *)(v57 + v9);
  unint64_t v58 = (v56 + v9) & 0xFFFFFFFFFFFFFFF8LL;
  unint64_t v59 = (v57 + v9) & 0xFFFFFFFFFFFFFFF8LL;
  *(void *)(v58 + 8) = *(void *)(v59 + 8);
  *(_BYTE *)(v58 + 16) = *(_BYTE *)(v59 + 16);
  unint64_t v60 = (v9 & 0xFFFFFFFFFFFFFFF8LL) + 17;
  unint64_t v61 = (v11 | 7) + v60;
  uint64_t v62 = (v61 + v56) & ~(v11 | 7);
  uint64_t v63 = (v61 + v57) & ~(v11 | 7);
  v35(v62, v63, v102);
  *(_BYTE *)(v62 + v9) = *(_BYTE *)(v63 + v9);
  unint64_t v64 = (v62 + v9) & 0xFFFFFFFFFFFFFFF8LL;
  unint64_t v65 = (v63 + v9) & 0xFFFFFFFFFFFFFFF8LL;
  *(void *)(v64 + 8) = *(void *)(v65 + 8);
  *(_BYTE *)(v64 + 16) = *(_BYTE *)(v65 + 16);
  unint64_t v66 = (v60 + v11 + v62) & ~v11;
  unint64_t v67 = (v60 + v11 + v63) & ~v11;
  v35(v66, v67, v102);
  unint64_t v68 = (_BYTE *)(v66 + v9);
  _BYTE *v68 = *(_BYTE *)(v67 + v9);
  v68[1] = *(_BYTE *)(v67 + v9 + 1);
  v68[2] = *(_BYTE *)(v67 + v9 + 2);
  uint64_t v69 = (v55 + v66) & ~(v11 | 7);
  uint64_t v70 = (v55 + v67) & ~(v11 | 7);
  v35(v69, v70, v102);
  *(_BYTE *)(v69 + v9) = *(_BYTE *)(v70 + v9);
  unint64_t v71 = (v69 + v9) & 0xFFFFFFFFFFFFFFF8LL;
  unint64_t v72 = (v70 + v9) & 0xFFFFFFFFFFFFFFF8LL;
  *(_OWORD *)(v71 + 8) = *(_OWORD *)(v72 + 8);
  *(_BYTE *)(v71 + 24) = *(_BYTE *)(v72 + 24);
  unint64_t v73 = (v105 + v11 + v69) & ~v11;
  unint64_t v74 = (v105 + v11 + v70) & ~v11;
  v35(v73, v74, v102);
  unint64_t v75 = (_BYTE *)(v73 + v9);
  *unint64_t v75 = *(_BYTE *)(v74 + v9);
  v75[1] = *(_BYTE *)(v74 + v9 + 1);
  v75[2] = *(_BYTE *)(v74 + v9 + 2);
  uint64_t v76 = (v55 + v73) & ~(v11 | 7);
  uint64_t v77 = (v55 + v74) & ~(v11 | 7);
  v35(v76, v77, v102);
  *(_BYTE *)(v76 + v9) = *(_BYTE *)(v77 + v9);
  unint64_t v78 = (v76 + v9) & 0xFFFFFFFFFFFFFFF8LL;
  unint64_t v79 = (v77 + v9) & 0xFFFFFFFFFFFFFFF8LL;
  *(_OWORD *)(v78 + 8) = *(_OWORD *)(v79 + 8);
  *(_BYTE *)(v78 + 24) = *(_BYTE *)(v79 + 24);
  unint64_t v80 = (v11 | 7) + v105;
  unint64_t v81 = (v27 + v105 + v76) & ~v27;
  unint64_t v82 = (v27 + v105 + v77) & ~v27;
  v35(v81, v82, v102);
  *(_BYTE *)(v81 + v9) = *(_BYTE *)(v82 + v9);
  unint64_t v83 = (v81 + v9) & 0xFFFFFFFFFFFFFFF8LL;
  unint64_t v84 = (v82 + v9) & 0xFFFFFFFFFFFFFFF8LL;
  *(_OWORD *)(v83 + 8) = *(_OWORD *)(v84 + 8);
  *(_BYTE *)(v83 + 24) = *(_BYTE *)(v84 + 24);
  unint64_t v85 = (void *)((v80 + v81) & ~(v11 | 7));
  unint64_t v86 = (void *)((v80 + v82) & ~(v11 | 7));
  *unint64_t v85 = *v86;
  uint64_t v87 = ((unint64_t)v85 + v11 + 8) & ~(v11 | 7);
  uint64_t v88 = ((unint64_t)v86 + v11 + 8) & ~(v11 | 7);
  v35(((unint64_t)v85 + v11 + 8) & ~v27, ((unint64_t)v86 + v11 + 8) & ~v27, v102);
  *(_BYTE *)(v87 + v9) = *(_BYTE *)(v88 + v9);
  unint64_t v89 = (v87 + v9) & 0xFFFFFFFFFFFFFFF8LL;
  unint64_t v90 = (v88 + v9) & 0xFFFFFFFFFFFFFFF8LL;
  *(void *)(v89 + 8) = *(void *)(v90 + 8);
  *(_BYTE *)(v89 + 16) = *(_BYTE *)(v90 + 16);
  uint64_t v91 = v60 + v11 + ((v11 + 8) & ~(v11 | 7));
  unint64_t v92 = ((unint64_t)v85 + v91) & ~v11;
  unint64_t v93 = ((unint64_t)v86 + v91) & ~v11;
  v35(v92, v93, v102);
  unint64_t v94 = (_BYTE *)(v92 + v9);
  *unint64_t v94 = *(_BYTE *)(v93 + v9);
  v94[1] = *(_BYTE *)(v93 + v9 + 1);
  v94[2] = *(_BYTE *)(v93 + v9 + 2);
  unint64_t v95 = (v12 + v92) & ~v11;
  unint64_t v96 = (v12 + v93) & ~v11;
  v35(v95, v96, v102);
  unint64_t v97 = (_BYTE *)(v95 + v9);
  *unint64_t v97 = *(_BYTE *)(v96 + v9);
  v97[1] = *(_BYTE *)(v96 + v9 + 1);
  v97[2] = *(_BYTE *)(v96 + v9 + 2);
  unint64_t v98 = (v12 + v95) & ~v11;
  unint64_t v99 = (v12 + v96) & ~v11;
  v35(v98, v99, v102);
  unint64_t v100 = (_BYTE *)(v98 + v9);
  *unint64_t v100 = *(_BYTE *)(v99 + v9);
  v100[1] = *(_BYTE *)(v99 + v9 + 1);
  v100[2] = *(_BYTE *)(v99 + v9 + 2);
  return v106;
}

uint64_t sub_1000B563C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a3 + 16);
  uint64_t v6 = *(void *)(v5 - 8);
  uint64_t v7 = *(void (**)(uint64_t, uint64_t, uint64_t))(v6 + 40);
  v7(a1, a2, v5);
  uint64_t v8 = v7;
  uint64_t v9 = *(void *)(v6 + 64);
  uint64_t v10 = (_BYTE *)(v9 + a1);
  uint64_t v117 = a1;
  *uint64_t v10 = *(_BYTE *)(v9 + a2);
  v10[1] = *(_BYTE *)(v9 + a2 + 1);
  v10[2] = *(_BYTE *)(v9 + a2 + 2);
  uint64_t v11 = *(unsigned __int8 *)(v6 + 80);
  uint64_t v12 = v9 + 3 + v11;
  uint64_t v13 = (v12 + a1) & ~v11;
  uint64_t v14 = (v12 + a2) & ~v11;
  v8(v13, v14, v5);
  uint64_t v15 = (_BYTE *)(v13 + v9);
  *uint64_t v15 = *(_BYTE *)(v14 + v9);
  v15[1] = *(_BYTE *)(v14 + v9 + 1);
  void v15[2] = *(_BYTE *)(v14 + v9 + 2);
  uint64_t v16 = (v12 + v13) & ~v11;
  uint64_t v17 = (v12 + v14) & ~v11;
  v8(v16, v17, v5);
  uint64_t v18 = (_BYTE *)(v16 + v9);
  *uint64_t v18 = *(_BYTE *)(v17 + v9);
  v18[1] = *(_BYTE *)(v17 + v9 + 1);
  void v18[2] = *(_BYTE *)(v17 + v9 + 2);
  uint64_t v118 = v12;
  uint64_t v19 = (v12 + v16) & ~v11;
  uint64_t v20 = (v12 + v17) & ~v11;
  uint64_t v21 = v5;
  v8(v19, v20, v5);
  uint64_t v22 = (_BYTE *)(v19 + v9);
  *uint64_t v22 = *(_BYTE *)(v20 + v9);
  v22[1] = *(_BYTE *)(v20 + v9 + 1);
  void v22[2] = *(_BYTE *)(v20 + v9 + 2);
  uint64_t v114 = (v11 | 3) + v9 + 3;
  uint64_t v23 = (v114 + v19) & ~(v11 | 3);
  uint64_t v24 = (v114 + v20) & ~(v11 | 3);
  v8(v23, v24, v5);
  unint64_t v25 = v8;
  *(_BYTE *)(v23 + v9) = *(_BYTE *)(v24 + v9);
  unint64_t v26 = (v23 + v9) & 0xFFFFFFFFFFFFFFFCLL;
  unint64_t v27 = (v24 + v9) & 0xFFFFFFFFFFFFFFFCLL;
  *(_DWORD *)(v26 + 4) = *(_DWORD *)(v27 + 4);
  *(_BYTE *)(v26 + 8) = *(_BYTE *)(v27 + 8);
  unint64_t v113 = (v9 & 0xFFFFFFFFFFFFFFFCLL) + 9;
  uint64_t v28 = v11 | 7;
  unint64_t v29 = (v11 | 7) + v113;
  unint64_t v30 = (_BYTE *)((v29 + v23) & ~(v11 | 7));
  uint64_t v31 = (_BYTE *)((v29 + v24) & ~(v11 | 7));
  *unint64_t v30 = *v31;
  uint64_t v32 = (v11 | 7) + 1;
  uint64_t v33 = (unint64_t)&v30[v32] & ~(v11 | 7);
  uint64_t v34 = (unint64_t)&v31[v32] & ~(v11 | 7);
  v25(v33, v34, v21);
  *(_BYTE *)(v33 + v9) = *(_BYTE *)(v34 + v9);
  unint64_t v35 = (v33 + v9) & 0xFFFFFFFFFFFFFFF8LL;
  unint64_t v36 = (v34 + v9) & 0xFFFFFFFFFFFFFFF8LL;
  *(void *)(v35 + 8) = *(void *)(v36 + 8);
  uint64_t v37 = *(void *)(v35 + 16);
  *(void *)(v35 + 16) = *(void *)(v36 + 16);
  swift_bridgeObjectRelease(v37);
  *(_BYTE *)(v35 + 24) = *(_BYTE *)(v36 + 24);
  unint64_t v116 = (v9 & 0xFFFFFFFFFFFFFFF8LL) + 25;
  uint64_t v38 = v116 + v11 + (v32 & ~(v11 | 7));
  unint64_t v39 = (unint64_t)&v30[v38] & ~v11;
  unint64_t v40 = (unint64_t)&v31[v38] & ~v11;
  uint64_t v41 = (void (*)(unint64_t, unint64_t, uint64_t))v25;
  v25(v39, v40, v21);
  unint64_t v42 = (_BYTE *)(v39 + v9);
  *unint64_t v42 = *(_BYTE *)(v40 + v9);
  v42[1] = *(_BYTE *)(v40 + v9 + 1);
  v42[2] = *(_BYTE *)(v40 + v9 + 2);
  unint64_t v43 = (v118 + v39) & ~v11;
  uint64_t v44 = v9 + 3 + v11;
  unint64_t v45 = (v118 + v40) & ~v11;
  uint64_t v46 = v21;
  v41(v43, v45, v21);
  unint64_t v47 = v41;
  unint64_t v48 = (_BYTE *)(v43 + v9);
  *unint64_t v48 = *(_BYTE *)(v45 + v9);
  v48[1] = *(_BYTE *)(v45 + v9 + 1);
  v48[2] = *(_BYTE *)(v45 + v9 + 2);
  uint64_t v49 = (v114 + v43) & ~(v11 | 3);
  uint64_t v50 = (v114 + v45) & ~(v11 | 3);
  v41(v49, v50, v46);
  *(_BYTE *)(v49 + v9) = *(_BYTE *)(v50 + v9);
  unint64_t v51 = (v49 + v9) & 0xFFFFFFFFFFFFFFFCLL;
  unint64_t v52 = (v50 + v9) & 0xFFFFFFFFFFFFFFFCLL;
  *(_DWORD *)(v51 + 4) = *(_DWORD *)(v52 + 4);
  *(_BYTE *)(v51 + 8) = *(_BYTE *)(v52 + 8);
  unint64_t v53 = (v113 + v11 + v49) & ~v11;
  unint64_t v54 = (v113 + v11 + v50) & ~v11;
  v41(v53, v54, v46);
  uint64_t v55 = (_BYTE *)(v53 + v9);
  *uint64_t v55 = *(_BYTE *)(v54 + v9);
  v55[1] = *(_BYTE *)(v54 + v9 + 1);
  v55[2] = *(_BYTE *)(v54 + v9 + 2);
  unint64_t v56 = (v44 + v53) & ~v11;
  unint64_t v57 = (v44 + v54) & ~v11;
  v41(v56, v57, v46);
  unint64_t v58 = (_BYTE *)(v56 + v9);
  *unint64_t v58 = *(_BYTE *)(v57 + v9);
  v58[1] = *(_BYTE *)(v57 + v9 + 1);
  v58[2] = *(_BYTE *)(v57 + v9 + 2);
  uint64_t v59 = (v11 | 7) + v9 + 3;
  uint64_t v60 = (v28 + v9 + 3 + v56) & ~v28;
  uint64_t v61 = (v28 + v9 + 3 + v57) & ~v28;
  v41(v60, v61, v46);
  *(_BYTE *)(v60 + v9) = *(_BYTE *)(v61 + v9);
  unint64_t v62 = (v60 + v9) & 0xFFFFFFFFFFFFFFF8LL;
  unint64_t v63 = (v61 + v9) & 0xFFFFFFFFFFFFFFF8LL;
  *(void *)(v62 + 8) = *(void *)(v63 + 8);
  *(_BYTE *)(v62 + 16) = *(_BYTE *)(v63 + 16);
  unint64_t v64 = (v9 & 0xFFFFFFFFFFFFFFF8LL) + 17;
  unint64_t v65 = (v11 | 7) + v64;
  uint64_t v66 = (v65 + v60) & ~(v11 | 7);
  uint64_t v67 = (v65 + v61) & ~(v11 | 7);
  v41(v66, v67, v46);
  *(_BYTE *)(v66 + v9) = *(_BYTE *)(v67 + v9);
  unint64_t v68 = (v66 + v9) & 0xFFFFFFFFFFFFFFF8LL;
  unint64_t v69 = (v67 + v9) & 0xFFFFFFFFFFFFFFF8LL;
  *(void *)(v68 + 8) = *(void *)(v69 + 8);
  *(_BYTE *)(v68 + 16) = *(_BYTE *)(v69 + 16);
  uint64_t v115 = v64 + v11;
  unint64_t v70 = (v64 + v11 + v66) & ~v11;
  unint64_t v71 = (v64 + v11 + v67) & ~v11;
  v41(v70, v71, v46);
  unint64_t v72 = (_BYTE *)(v70 + v9);
  *unint64_t v72 = *(_BYTE *)(v71 + v9);
  v72[1] = *(_BYTE *)(v71 + v9 + 1);
  v72[2] = *(_BYTE *)(v71 + v9 + 2);
  uint64_t v73 = (v59 + v70) & ~(v11 | 7);
  uint64_t v74 = (v59 + v71) & ~(v11 | 7);
  v41(v73, v74, v46);
  *(_BYTE *)(v73 + v9) = *(_BYTE *)(v74 + v9);
  unint64_t v75 = (v73 + v9) & 0xFFFFFFFFFFFFFFF8LL;
  unint64_t v76 = (v74 + v9) & 0xFFFFFFFFFFFFFFF8LL;
  uint64_t v77 = *(void *)(v75 + 8);
  unint64_t v78 = *(void *)(v75 + 16);
  *(_OWORD *)(v75 + 8) = *(_OWORD *)(v76 + 8);
  sub_1000208D8(v77, v78);
  *(_BYTE *)(v75 + 24) = *(_BYTE *)(v76 + 24);
  unint64_t v79 = (v116 + v11 + v73) & ~v11;
  unint64_t v80 = (v116 + v11 + v74) & ~v11;
  v47(v79, v80, v46);
  unint64_t v81 = (_BYTE *)(v79 + v9);
  *unint64_t v81 = *(_BYTE *)(v80 + v9);
  v81[1] = *(_BYTE *)(v80 + v9 + 1);
  v81[2] = *(_BYTE *)(v80 + v9 + 2);
  uint64_t v82 = (v59 + v79) & ~(v11 | 7);
  uint64_t v83 = (v59 + v80) & ~(v11 | 7);
  v47(v82, v83, v46);
  *(_BYTE *)(v82 + v9) = *(_BYTE *)(v83 + v9);
  unint64_t v84 = (v82 + v9) & 0xFFFFFFFFFFFFFFF8LL;
  unint64_t v85 = (v83 + v9) & 0xFFFFFFFFFFFFFFF8LL;
  uint64_t v86 = *(void *)(v84 + 8);
  unint64_t v87 = *(void *)(v84 + 16);
  *(_OWORD *)(v84 + 8) = *(_OWORD *)(v85 + 8);
  sub_1000208D8(v86, v87);
  *(_BYTE *)(v84 + 24) = *(_BYTE *)(v85 + 24);
  unint64_t v88 = (v11 | 7) + v116;
  unint64_t v89 = (v28 + v116 + v82) & ~v28;
  unint64_t v90 = (v28 + v116 + v83) & ~v28;
  v47(v89, v90, v46);
  *(_BYTE *)(v89 + v9) = *(_BYTE *)(v90 + v9);
  unint64_t v91 = (v89 + v9) & 0xFFFFFFFFFFFFFFF8LL;
  unint64_t v92 = (v90 + v9) & 0xFFFFFFFFFFFFFFF8LL;
  uint64_t v93 = *(void *)(v91 + 8);
  unint64_t v94 = *(void *)(v91 + 16);
  *(_OWORD *)(v91 + 8) = *(_OWORD *)(v92 + 8);
  sub_1000208D8(v93, v94);
  *(_BYTE *)(v91 + 24) = *(_BYTE *)(v92 + 24);
  unint64_t v95 = (void *)((v88 + v89) & ~(v11 | 7));
  unint64_t v96 = (void *)((v88 + v90) & ~(v11 | 7));
  *unint64_t v95 = *v96;
  uint64_t v97 = ((unint64_t)v95 + v11 + 8) & ~(v11 | 7);
  uint64_t v98 = ((unint64_t)v96 + v11 + 8) & ~(v11 | 7);
  v47(((unint64_t)v95 + v11 + 8) & ~v28, ((unint64_t)v96 + v11 + 8) & ~v28, v46);
  *(_BYTE *)(v97 + v9) = *(_BYTE *)(v98 + v9);
  unint64_t v99 = (v97 + v9) & 0xFFFFFFFFFFFFFFF8LL;
  unint64_t v100 = (v98 + v9) & 0xFFFFFFFFFFFFFFF8LL;
  *(void *)(v99 + 8) = *(void *)(v100 + 8);
  *(_BYTE *)(v99 + 16) = *(_BYTE *)(v100 + 16);
  uint64_t v101 = v115 + ((v11 + 8) & ~(v11 | 7));
  unint64_t v102 = ((unint64_t)v95 + v101) & ~v11;
  unint64_t v103 = ((unint64_t)v96 + v101) & ~v11;
  v47(v102, v103, v46);
  uint64_t v104 = (_BYTE *)(v102 + v9);
  _BYTE *v104 = *(_BYTE *)(v103 + v9);
  v104[1] = *(_BYTE *)(v103 + v9 + 1);
  v104[2] = *(_BYTE *)(v103 + v9 + 2);
  unint64_t v105 = (v118 + v102) & ~v11;
  uint64_t v106 = v9 + 3 + v11;
  unint64_t v107 = (v118 + v103) & ~v11;
  v47(v105, v107, v46);
  unint64_t v108 = (_BYTE *)(v105 + v9);
  *unint64_t v108 = *(_BYTE *)(v107 + v9);
  v108[1] = *(_BYTE *)(v107 + v9 + 1);
  v108[2] = *(_BYTE *)(v107 + v9 + 2);
  unint64_t v109 = (v106 + v105) & ~v11;
  unint64_t v110 = (v106 + v107) & ~v11;
  v47(v109, v110, v46);
  uint64_t v111 = (_BYTE *)(v109 + v9);
  *uint64_t v111 = *(_BYTE *)(v110 + v9);
  v111[1] = *(_BYTE *)(v110 + v9 + 1);
  v111[2] = *(_BYTE *)(v110 + v9 + 2);
  return v117;
}

uint64_t sub_1000B5D70(uint64_t a1, unsigned int a2, uint64_t a3)
{
  uint64_t v4 = *(void *)(*(void *)(a3 + 16) - 8LL);
  unsigned int v5 = *(_DWORD *)(v4 + 84);
  if (v5 <= 0xFE) {
    unsigned int v6 = 254;
  }
  else {
    unsigned int v6 = *(_DWORD *)(v4 + 84);
  }
  if (v5 <= 0x7FFFFFFF) {
    unsigned int v7 = 0x7FFFFFFF;
  }
  else {
    unsigned int v7 = *(_DWORD *)(v4 + 84);
  }
  if (v7 <= v6) {
    unsigned int v8 = v6;
  }
  else {
    unsigned int v8 = v7;
  }
  if (!a2) {
    return 0LL;
  }
  uint64_t v9 = *(void *)(v4 + 64);
  uint64_t v11 = *(unsigned __int8 *)(v4 + 80);
  uint64_t v12 = v9 + 3 + v11;
  uint64_t v13 = v11 | 3;
  uint64_t v14 = (v11 | 3) + v9 + 3;
  unint64_t v15 = (v9 & 0xFFFFFFFFFFFFFFFCLL) + 9;
  uint64_t v16 = v11 | 7;
  unint64_t v17 = (v11 | 7) + v15;
  uint64_t v18 = (v11 | 7) + 1;
  BOOL v19 = a2 >= v8;
  unsigned int v20 = a2 - v8;
  if (v20 != 0 && v19)
  {
    unint64_t v21 = (v9 & 0xFFFFFFFFFFFFFFF8LL) + 25;
    unint64_t v22 = (v9 & 0xFFFFFFFFFFFFFFF8LL) + 17;
    uint64_t v10 = v9 + 3;
    uint64_t v23 = ((v12
          + ((v12
            + ((v22
              + v11
              + ((v11 + 8) & ~v16)
              + ((v16
                + v21
                + ((v16
                  + v21
                  + ((v16
                    + v10
                    + ((v21
                      + v11
                      + ((v16
                        + v10
                        + ((v22
                          + v11
                          + ((v16
                            + v22
                            + ((v16
                              + v10
                              + ((v12
                                + ((v15
                                  + v11
                                  + ((v14
                                    + ((v12
                                      + ((v21
                                        + v11
                                        + (v18 & ~v16)
                                        + ((v17 + ((v14 + ((v12 + ((v12 + (v12 & ~v11)) & ~v11)) & ~v11)) & ~v13)) & ~v16)) & ~v11)) & ~v11)) & ~v13)) & ~v11)) & ~v11)) & ~v16)) & ~v16)) & ~v11)) & ~v16)) & ~v11)) & ~v16)) & ~v16)) & ~v16)) & ~v11)) & ~v11)) & ~v11)
        + v10;
    char v24 = 8 * v23;
    if (v23 <= 3)
    {
      unsigned int v26 = ((v20 + ~(-1 << v24)) >> v24) + 1;
      if (HIWORD(v26))
      {
        int v25 = *(_DWORD *)(a1 + v23);
        if (!v25) {
          goto LABEL_30;
        }
        goto LABEL_21;
      }

      if (v26 > 0xFF)
      {
        int v25 = *(unsigned __int16 *)(a1 + v23);
        if (!*(_WORD *)(a1 + v23)) {
          goto LABEL_30;
        }
        goto LABEL_21;
      }

      if (v26 < 2) {
        goto LABEL_30;
      }
    }

    int v25 = *(unsigned __int8 *)(a1 + v23);
    if (!*(_BYTE *)(a1 + v23)) {
      goto LABEL_30;
    }
LABEL_21:
    int v27 = (v25 - 1) << v24;
    if ((_DWORD)v23)
    {
      else {
        int v28 = 4;
      }
      __asm { BR              X12 }
    }

    int v32 = v8 + v27;
    return (v32 + 1);
  }

void sub_1000B6058(_WORD *a1, unsigned int a2, unsigned int a3, uint64_t a4)
{
  uint64_t v6 = *(void *)(*(void *)(a4 + 16) - 8LL);
  unsigned int v7 = *(_DWORD *)(v6 + 84);
  if (v7 <= 0xFE) {
    unsigned int v8 = 254;
  }
  else {
    unsigned int v8 = *(_DWORD *)(v6 + 84);
  }
  if (v7 <= 0x7FFFFFFF) {
    unsigned int v9 = 0x7FFFFFFF;
  }
  else {
    unsigned int v9 = *(_DWORD *)(v6 + 84);
  }
  if (v9 <= v8) {
    unsigned int v10 = v8;
  }
  else {
    unsigned int v10 = v9;
  }
  uint64_t v11 = *(void *)(v6 + 64);
  uint64_t v12 = *(unsigned __int8 *)(v6 + 80);
  uint64_t v13 = v11 + 3 + v12;
  unint64_t v14 = (v11 & 0xFFFFFFFFFFFFFFF8LL) + 25;
  uint64_t v15 = (v12 | 7) + v11 + 3;
  unint64_t v16 = (v11 & 0xFFFFFFFFFFFFFFF8LL) + 17;
  size_t v17 = ((v13
        + ((v13
          + ((v16
            + v12
            + ((v12 + 8) & ~(v12 | 7))
            + (((v12 | 7)
              + v14
              + (((v12 | 7)
                + v14
                + ((v15
                  + ((v14
                    + v12
                    + ((v15
                      + ((v16
                        + v12
                        + (((v12 | 7)
                          + v16
                          + ((v15
                            + ((v13
                              + (((v11 & 0xFFFFFFFFFFFFFFFCLL)
                                + 9
                                + v12
                                + (((v12 | 3)
                                  + v11
                                  + 3
                                  + ((v13
                                    + (((((v12 | 7) + 1) & ~(v12 | 7))
                                      + v14
                                      + v12
                                      + (((v12 | 7)
                                        + (v11 & 0xFFFFFFFFFFFFFFFCLL)
                                        + 9
                                        + (((v12 | 3) + v11 + 3 + ((v13 + ((v13 + (v13 & ~v12)) & ~v12)) & ~v12)) & ~(v12 | 3))) & ~(v12 | 7))) & ~v12)) & ~v12)) & ~(v12 | 3))) & ~v12)) & ~v12)) & ~(v12 | 7))) & ~(v12 | 7))) & ~v12)) & ~(v12 | 7))) & ~v12)) & ~(v12 | 7))) & ~(v12 | 7))) & ~(v12 | 7))) & ~v12)) & ~v12)) & ~v12)
      + v11
      + 3;
  BOOL v18 = a3 >= v10;
  unsigned int v19 = a3 - v10;
  if (v19 != 0 && v18)
  {
    if (v17 <= 3)
    {
      unsigned int v22 = ((v19 + ~(-1 << (8 * v17))) >> (8 * v17)) + 1;
      if (HIWORD(v22))
      {
        unsigned int v20 = &dword_100000004;
      }

      else if (v22 >= 0x100)
      {
        unsigned int v20 = 2;
      }

      else
      {
        unsigned int v20 = v22 > 1;
      }
    }

    else
    {
      unsigned int v20 = &_mh_execute_header.magic + 1;
    }
  }

  else
  {
    unsigned int v20 = 0;
  }

  if (v10 < a2)
  {
    int v21 = ~v10 + a2;
    if (v17 < 4)
    {
      if ((_DWORD)v17)
      {
        int v23 = v21 & ~(-1 << (8 * v17));
        bzero(a1, v17);
        if ((_DWORD)v17 == 3)
        {
          *a1 = v23;
          *((_BYTE *)a1 + 2) = BYTE2(v23);
        }

        else if ((_DWORD)v17 == 2)
        {
          *a1 = v23;
        }

        else
        {
          *(_BYTE *)a1 = v23;
        }
      }
    }

    else
    {
      bzero(a1, v17);
      *(_DWORD *)a1 = v21;
    }

    __asm { BR              X10 }
  }

  __asm { BR              X7 }

uint64_t sub_1000B64AC(uint64_t a1)
{
  uint64_t result = swift_checkMetadataState(319LL, *(void *)(a1 + 16));
  if (v3 <= 0x3F)
  {
    v5[0] = *(void *)(result - 8) + 64LL;
    v5[1] = &unk_10033F788;
    uint64_t result = swift_checkMetadataState(319LL, *(void *)(a1 + 24));
    if (v4 <= 0x3F)
    {
      v5[2] = *(void *)(result - 8) + 64LL;
      _OWORD v5[3] = &unk_10033F7A0;
      swift_initStructMetadata(a1, 0LL, 4LL, v5, a1 + 40);
      return 0LL;
    }
  }

  return result;
}

void *sub_1000B6548(void *a1, void *a2, uint64_t a3)
{
  unint64_t v4 = a1;
  uint64_t v5 = *(void *)(a3 + 24);
  uint64_t v6 = *(void *)(*(void *)(a3 + 16) - 8LL);
  uint64_t v7 = *(void *)(v6 + 64);
  uint64_t v8 = *(void *)(v5 - 8);
  uint64_t v9 = *(_DWORD *)(v8 + 80);
  uint64_t v10 = *(void *)(v8 + 64);
  uint64_t v11 = (*(_BYTE *)(v6 + 80) | *(_BYTE *)(v8 + 80));
  if (v11 > 7
    || ((*(_DWORD *)(v6 + 80) | *(_DWORD *)(v8 + 80)) & 0x100000) != 0
    || v10 + ((v9 + v7 + 1) & (unint64_t)~v9) + 1 > 0x18)
  {
    uint64_t v14 = *a2;
    void *v4 = *a2;
    unint64_t v4 = (void *)(v14 + ((v11 + 16) & ~v11));
    swift_retain(v14);
  }

  else
  {
    (*(void (**)(void *, void *))(v6 + 16))(a1, a2);
    *((_BYTE *)v4 + v7) = *((_BYTE *)a2 + v7);
    uint64_t v15 = (char *)a2 + v7 + v9;
    uint64_t v16 = ((unint64_t)v4 + v7 + v9 + 1) & ~v9;
    uint64_t v17 = (unint64_t)(v15 + 1) & ~v9;
    (*(void (**)(uint64_t, uint64_t, uint64_t))(v8 + 16))(v16, v17, v5);
    *(_BYTE *)(v16 + v10) = *(_BYTE *)(v17 + v10);
  }

  return v4;
}

uint64_t sub_1000B6650(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(*(void *)(a2 + 16) - 8LL);
  (*(void (**)(void))(v4 + 8))();
  return (*(uint64_t (**)(unint64_t))(*(void *)(*(void *)(a2 + 24) - 8LL) + 8LL))((a1 + *(void *)(v4 + 64) + *(unsigned __int8 *)(*(void *)(*(void *)(a2 + 24) - 8LL) + 80LL) + 1) & ~(unint64_t)*(unsigned __int8 *)(*(void *)(*(void *)(a2 + 24) - 8LL) + 80LL));
}

uint64_t sub_1000B66AC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(void *)(*(void *)(a3 + 16) - 8LL);
  (*(void (**)(void))(v6 + 16))();
  uint64_t v7 = *(void *)(v6 + 64);
  uint64_t v8 = (_BYTE *)(v7 + a1);
  uint64_t v9 = (_BYTE *)(v7 + a2);
  *uint64_t v8 = *v9;
  uint64_t v10 = *(void *)(*(void *)(a3 + 24) - 8LL);
  uint64_t v11 = *(unsigned __int8 *)(v10 + 80);
  uint64_t v12 = (unint64_t)&v8[v11 + 1] & ~v11;
  uint64_t v13 = (unint64_t)&v9[v11 + 1] & ~v11;
  (*(void (**)(uint64_t, uint64_t))(v10 + 16))(v12, v13);
  *(_BYTE *)(v12 + *(void *)(v10 + 64)) = *(_BYTE *)(v13 + *(void *)(v10 + 64));
  return a1;
}

uint64_t sub_1000B673C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(void *)(*(void *)(a3 + 16) - 8LL);
  (*(void (**)(void))(v6 + 24))();
  uint64_t v7 = *(void *)(v6 + 64);
  uint64_t v8 = (_BYTE *)(v7 + a1);
  uint64_t v9 = (_BYTE *)(v7 + a2);
  *uint64_t v8 = *v9;
  uint64_t v10 = *(void *)(*(void *)(a3 + 24) - 8LL);
  uint64_t v11 = *(unsigned __int8 *)(v10 + 80);
  uint64_t v12 = (unint64_t)&v8[v11 + 1] & ~v11;
  uint64_t v13 = (unint64_t)&v9[v11 + 1] & ~v11;
  (*(void (**)(uint64_t, uint64_t))(v10 + 24))(v12, v13);
  *(_BYTE *)(v12 + *(void *)(v10 + 64)) = *(_BYTE *)(v13 + *(void *)(v10 + 64));
  return a1;
}

uint64_t sub_1000B67CC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(void *)(*(void *)(a3 + 16) - 8LL);
  (*(void (**)(void))(v6 + 32))();
  uint64_t v7 = *(void *)(v6 + 64);
  uint64_t v8 = (_BYTE *)(v7 + a1);
  uint64_t v9 = (_BYTE *)(v7 + a2);
  *uint64_t v8 = *v9;
  uint64_t v10 = *(void *)(*(void *)(a3 + 24) - 8LL);
  uint64_t v11 = *(unsigned __int8 *)(v10 + 80);
  uint64_t v12 = (unint64_t)&v8[v11 + 1] & ~v11;
  uint64_t v13 = (unint64_t)&v9[v11 + 1] & ~v11;
  (*(void (**)(uint64_t, uint64_t))(v10 + 32))(v12, v13);
  *(_BYTE *)(v12 + *(void *)(v10 + 64)) = *(_BYTE *)(v13 + *(void *)(v10 + 64));
  return a1;
}

uint64_t sub_1000B685C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(void *)(*(void *)(a3 + 16) - 8LL);
  (*(void (**)(void))(v6 + 40))();
  uint64_t v7 = *(void *)(v6 + 64);
  uint64_t v8 = (_BYTE *)(v7 + a1);
  uint64_t v9 = (_BYTE *)(v7 + a2);
  *uint64_t v8 = *v9;
  uint64_t v10 = *(void *)(*(void *)(a3 + 24) - 8LL);
  uint64_t v11 = *(unsigned __int8 *)(v10 + 80);
  uint64_t v12 = (unint64_t)&v8[v11 + 1] & ~v11;
  uint64_t v13 = (unint64_t)&v9[v11 + 1] & ~v11;
  (*(void (**)(uint64_t, uint64_t))(v10 + 40))(v12, v13);
  *(_BYTE *)(v12 + *(void *)(v10 + 64)) = *(_BYTE *)(v13 + *(void *)(v10 + 64));
  return a1;
}

uint64_t sub_1000B68EC(uint64_t a1, unsigned int a2, uint64_t a3)
{
  uint64_t v4 = *(void *)(*(void *)(a3 + 16) - 8LL);
  unsigned int v5 = *(_DWORD *)(v4 + 84);
  uint64_t v6 = *(void *)(*(void *)(a3 + 24) - 8LL);
  unsigned int v7 = *(_DWORD *)(v6 + 84);
  if (v5 <= v7) {
    unsigned int v8 = *(_DWORD *)(v6 + 84);
  }
  else {
    unsigned int v8 = *(_DWORD *)(v4 + 84);
  }
  if (v8 <= 0xFE) {
    unsigned int v8 = 254;
  }
  if (!a2) {
    return 0LL;
  }
  uint64_t v9 = *(void *)(v4 + 64);
  uint64_t v10 = *(unsigned __int8 *)(v6 + 80);
  uint64_t v11 = *(void *)(v6 + 64);
  int v12 = a2 - v8;
  if (a2 <= v8) {
    goto LABEL_25;
  }
  uint64_t v13 = v11 + ((v9 + v10 + 1) & ~v10) + 1;
  char v14 = 8 * v13;
  unsigned int v16 = ((v12 + ~(-1 << v14)) >> v14) + 1;
  if (HIWORD(v16))
  {
    int v15 = *(_DWORD *)(a1 + v13);
    if (v15) {
      goto LABEL_16;
    }
  }

  else
  {
    if (v16 <= 0xFF)
    {
      if (v16 < 2) {
        goto LABEL_25;
      }
LABEL_9:
      int v15 = *(unsigned __int8 *)(a1 + v13);
      if (!*(_BYTE *)(a1 + v13)) {
        goto LABEL_25;
      }
LABEL_16:
      int v17 = (v15 - 1) << v14;
      if ((_DWORD)v11 + (((_DWORD)v9 + (_DWORD)v10 + 1) & ~(_DWORD)v10) == -1) {
        return v8 + v17 + 1;
      }
      else {
        int v18 = 4;
      }
      return ((uint64_t (*)(void))((char *)&loc_1000B69D4 + 4 * byte_10033F21C[v18 - 1]))();
    }

    int v15 = *(unsigned __int16 *)(a1 + v13);
    if (*(_WORD *)(a1 + v13)) {
      goto LABEL_16;
    }
  }

void sub_1000B6A7C(_WORD *a1, unsigned int a2, unsigned int a3, uint64_t a4)
{
  uint64_t v5 = *(void *)(*(void *)(a4 + 16) - 8LL);
  uint64_t v6 = *(void *)(*(void *)(a4 + 24) - 8LL);
  if (*(_DWORD *)(v5 + 84) <= *(_DWORD *)(v6 + 84)) {
    unsigned int v7 = *(_DWORD *)(v6 + 84);
  }
  else {
    unsigned int v7 = *(_DWORD *)(v5 + 84);
  }
  if (v7 <= 0xFE) {
    unsigned int v8 = 254;
  }
  else {
    unsigned int v8 = v7;
  }
  size_t v9 = *(void *)(v6 + 64)
  if (a3 > v8)
  {
    if (v9 <= 3)
    {
      unsigned int v12 = ((a3 - v8 + ~(-1 << (8 * v9))) >> (8 * v9)) + 1;
      if (HIWORD(v12))
      {
        unsigned int v10 = &dword_100000004;
      }

      else if (v12 >= 0x100)
      {
        unsigned int v10 = 2;
      }

      else
      {
        unsigned int v10 = v12 > 1;
      }
    }

    else
    {
      unsigned int v10 = &_mh_execute_header.magic + 1;
    }
  }

  else
  {
    unsigned int v10 = 0;
  }

  if (v8 < a2)
  {
    int v11 = ~v8 + a2;
    if (v9 < 4)
    {
      if (*(_DWORD *)(v6 + 64)
         + ((*(_DWORD *)(v5 + 64) + *(unsigned __int8 *)(v6 + 80) + 1) & ~*(unsigned __int8 *)(v6 + 80)) != -1)
      {
        int v13 = v11 & ~(-1 << (8 * v9));
        bzero(a1, v9);
        if ((_DWORD)v9 == 3)
        {
          *a1 = v13;
          *((_BYTE *)a1 + 2) = BYTE2(v13);
        }

        else if ((_DWORD)v9 == 2)
        {
          *a1 = v13;
        }

        else
        {
          *(_BYTE *)a1 = v13;
        }
      }
    }

    else
    {
      bzero(a1, v9);
      *(_DWORD *)a1 = v11;
    }

    __asm { BR              X10 }
  }

  __asm { BR              X4 }

uint64_t sub_1000B6CA8(void *a1)
{
  uint64_t v2 = swift_checkMetadataState(319LL, a1[3]);
  uint64_t v3 = v2;
  if (v4 <= 0x3F)
  {
    v10[0] = *(void *)(v2 - 8) + 64LL;
    uint64_t v5 = a1[2];
    uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  a1[5],  v2,  &protocol requirements base descriptor for RawRepresentable);
    uint64_t v7 = type metadata accessor for Preferences.Preference(319LL, v5, AssociatedTypeWitness, a1[4]);
    uint64_t v3 = v7;
    if (v8 <= 0x3F)
    {
      v10[1] = *(void *)(v7 - 8) + 64LL;
      swift_initStructMetadata(a1, 0LL, 2LL, v10, a1 + 6);
      return 0LL;
    }
  }

  return v3;
}

uint64_t *sub_1000B6D68(uint64_t *a1, uint64_t *a2, void *a3)
{
  uint64_t v6 = a3[2];
  uint64_t v5 = a3[3];
  uint64_t v7 = *(void *)(v5 - 8);
  uint64_t v8 = *(void *)(v7 + 64);
  uint64_t v9 = *(void *)(v6 - 8);
  int v10 = *(_DWORD *)(v9 + 80);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  a3[5],  v5,  &protocol requirements base descriptor for RawRepresentable,  &associated type descriptor for RawRepresentable.RawValue);
  uint64_t v12 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v13 = *(_DWORD *)(v12 + 80);
  int v14 = *(_DWORD *)(v12 + 80) | v10;
  uint64_t v15 = (*(_BYTE *)(v12 + 80) | v10);
  uint64_t v16 = v8 + v15;
  uint64_t v17 = *(void *)(v9 + 64);
  uint64_t v18 = v13 + 1;
  int v19 = *(_DWORD *)(v7 + 80) | v14;
  uint64_t v20 = (*(_BYTE *)(v7 + 80) | v14);
  int v21 = v19 & 0x100000;
  if (v20 > 7
    || v21 != 0
    || *(void *)(v12 + 64) + ((v13 + 1 + v17) & ~v13) + (v16 & (unint64_t)~v15) + 1 > 0x18)
  {
    uint64_t v24 = *a2;
    *a1 = *a2;
    a1 = (uint64_t *)(v24 + ((v20 + 16) & ~v20));
    swift_retain(v24);
  }

  else
  {
    uint64_t v34 = v6;
    uint64_t v25 = ~v15;
    uint64_t v35 = ~v13;
    uint64_t v36 = AssociatedTypeWitness;
    unsigned int v26 = *(void (**)(uint64_t *, uint64_t *, uint64_t))(v7 + 16);
    uint64_t v27 = *(void *)(v12 + 64);
    v26(a1, a2, v5);
    unint64_t v28 = ((unint64_t)a1 + v16) & v25;
    unint64_t v29 = ((unint64_t)a2 + v16) & v25;
    (*(void (**)(unint64_t, unint64_t, uint64_t))(v9 + 16))(v28, v29, v34);
    uint64_t v30 = v29 + v17;
    *(_BYTE *)(v28 + v17) = *(_BYTE *)(v29 + v17);
    unint64_t v31 = (v18 + v28 + v17) & v35;
    uint64_t v32 = (v18 + v30) & v35;
    (*(void (**)(unint64_t, uint64_t, uint64_t))(v12 + 16))(v31, v32, v36);
    *(_BYTE *)(v31 + v27) = *(_BYTE *)(v32 + v27);
  }

  return a1;
}

uint64_t sub_1000B6EE8(uint64_t a1, void *a2)
{
  uint64_t v4 = a2[3];
  uint64_t v5 = *(void *)(v4 - 8);
  (*(void (**)(uint64_t, uint64_t))(v5 + 8))(a1, v4);
  uint64_t v6 = *(void *)(v5 + 64) + a1;
  uint64_t v7 = a2[2];
  uint64_t v8 = *(void *)(v7 - 8);
  unsigned int v9 = *(unsigned __int8 *)(v8 + 80);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  a2[5],  v4,  &protocol requirements base descriptor for RawRepresentable,  &associated type descriptor for RawRepresentable.RawValue);
  uint64_t v11 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v12 = *(_DWORD *)(v11 + 80);
  uint64_t v13 = *(_DWORD *)(v11 + 80) | v9;
  uint64_t v14 = (v6 + v13) & ~v13;
  (*(void (**)(uint64_t, uint64_t))(v8 + 8))(v14, v7);
  return (*(uint64_t (**)(uint64_t, uint64_t))(v11 + 8))( (v12 + *(void *)(v8 + 64) + v14 + 1) & ~v12,  AssociatedTypeWitness);
}

uint64_t sub_1000B6FB4(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v6 = a3[3];
  uint64_t v7 = *(void *)(v6 - 8);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v7 + 16))(a1, a2, v6);
  uint64_t v8 = *(void *)(v7 + 64);
  uint64_t v9 = a3[2];
  uint64_t v10 = *(void *)(v9 - 8);
  unsigned int v11 = *(unsigned __int8 *)(v10 + 80);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  a3[5],  v6,  &protocol requirements base descriptor for RawRepresentable,  &associated type descriptor for RawRepresentable.RawValue);
  uint64_t v13 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v14 = *(_DWORD *)(v13 + 80);
  uint64_t v15 = *(_DWORD *)(v13 + 80) | v11;
  uint64_t v16 = (v8 + v15 + a1) & ~v15;
  uint64_t v17 = (v8 + v15 + a2) & ~v15;
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v10 + 16))(v16, v17, v9);
  uint64_t v18 = *(void *)(v10 + 64);
  int v19 = (_BYTE *)(v16 + v18);
  uint64_t v20 = (_BYTE *)(v17 + v18);
  *int v19 = *v20;
  uint64_t v21 = (unint64_t)&v19[v14 + 1] & ~v14;
  uint64_t v22 = (unint64_t)&v20[v14 + 1] & ~v14;
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v13 + 16))(v21, v22, AssociatedTypeWitness);
  *(_BYTE *)(v21 + *(void *)(v13 + 64)) = *(_BYTE *)(v22 + *(void *)(v13 + 64));
  return a1;
}

uint64_t sub_1000B70C8(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v6 = a3[3];
  uint64_t v7 = *(void *)(v6 - 8);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v7 + 24))(a1, a2, v6);
  uint64_t v8 = *(void *)(v7 + 64);
  uint64_t v9 = a3[2];
  uint64_t v10 = *(void *)(v9 - 8);
  unsigned int v11 = *(unsigned __int8 *)(v10 + 80);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  a3[5],  v6,  &protocol requirements base descriptor for RawRepresentable,  &associated type descriptor for RawRepresentable.RawValue);
  uint64_t v13 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v14 = *(_DWORD *)(v13 + 80);
  uint64_t v15 = *(_DWORD *)(v13 + 80) | v11;
  uint64_t v16 = (v8 + v15 + a1) & ~v15;
  uint64_t v17 = (v8 + v15 + a2) & ~v15;
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v10 + 24))(v16, v17, v9);
  uint64_t v18 = *(void *)(v10 + 64);
  int v19 = (_BYTE *)(v16 + v18);
  uint64_t v20 = (_BYTE *)(v17 + v18);
  *int v19 = *v20;
  uint64_t v21 = (unint64_t)&v19[v14 + 1] & ~v14;
  uint64_t v22 = (unint64_t)&v20[v14 + 1] & ~v14;
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v13 + 24))(v21, v22, AssociatedTypeWitness);
  *(_BYTE *)(v21 + *(void *)(v13 + 64)) = *(_BYTE *)(v22 + *(void *)(v13 + 64));
  return a1;
}

uint64_t sub_1000B71DC(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v6 = a3[3];
  uint64_t v7 = *(void *)(v6 - 8);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v7 + 32))(a1, a2, v6);
  uint64_t v8 = *(void *)(v7 + 64);
  uint64_t v9 = a3[2];
  uint64_t v10 = *(void *)(v9 - 8);
  unsigned int v11 = *(unsigned __int8 *)(v10 + 80);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  a3[5],  v6,  &protocol requirements base descriptor for RawRepresentable,  &associated type descriptor for RawRepresentable.RawValue);
  uint64_t v13 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v14 = *(_DWORD *)(v13 + 80);
  uint64_t v15 = *(_DWORD *)(v13 + 80) | v11;
  uint64_t v16 = (v8 + v15 + a1) & ~v15;
  uint64_t v17 = (v8 + v15 + a2) & ~v15;
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v10 + 32))(v16, v17, v9);
  uint64_t v18 = *(void *)(v10 + 64);
  int v19 = (_BYTE *)(v16 + v18);
  uint64_t v20 = (_BYTE *)(v17 + v18);
  *int v19 = *v20;
  uint64_t v21 = (unint64_t)&v19[v14 + 1] & ~v14;
  uint64_t v22 = (unint64_t)&v20[v14 + 1] & ~v14;
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v13 + 32))(v21, v22, AssociatedTypeWitness);
  *(_BYTE *)(v21 + *(void *)(v13 + 64)) = *(_BYTE *)(v22 + *(void *)(v13 + 64));
  return a1;
}

uint64_t sub_1000B72F0(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v6 = a3[3];
  uint64_t v7 = *(void *)(v6 - 8);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v7 + 40))(a1, a2, v6);
  uint64_t v8 = *(void *)(v7 + 64);
  uint64_t v9 = a3[2];
  uint64_t v10 = *(void *)(v9 - 8);
  unsigned int v11 = *(unsigned __int8 *)(v10 + 80);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  a3[5],  v6,  &protocol requirements base descriptor for RawRepresentable,  &associated type descriptor for RawRepresentable.RawValue);
  uint64_t v13 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v14 = *(_DWORD *)(v13 + 80);
  uint64_t v15 = *(_DWORD *)(v13 + 80) | v11;
  uint64_t v16 = (v8 + v15 + a1) & ~v15;
  uint64_t v17 = (v8 + v15 + a2) & ~v15;
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v10 + 40))(v16, v17, v9);
  uint64_t v18 = *(void *)(v10 + 64);
  int v19 = (_BYTE *)(v16 + v18);
  uint64_t v20 = (_BYTE *)(v17 + v18);
  *int v19 = *v20;
  uint64_t v21 = (unint64_t)&v19[v14 + 1] & ~v14;
  uint64_t v22 = (unint64_t)&v20[v14 + 1] & ~v14;
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v13 + 40))(v21, v22, AssociatedTypeWitness);
  *(_BYTE *)(v21 + *(void *)(v13 + 64)) = *(_BYTE *)(v22 + *(void *)(v13 + 64));
  return a1;
}

uint64_t sub_1000B7404(uint64_t a1, unsigned int a2, void *a3)
{
  uint64_t v5 = a3[2];
  uint64_t v6 = a3[3];
  uint64_t v7 = *(void *)(v6 - 8);
  uint64_t v8 = *(unsigned int *)(v7 + 84);
  uint64_t v9 = *(void *)(v5 - 8);
  uint64_t v10 = *(unsigned int *)(v9 + 84);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  a3[5],  v6,  &protocol requirements base descriptor for RawRepresentable,  &associated type descriptor for RawRepresentable.RawValue);
  uint64_t v12 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v13 = *(unsigned int *)(v12 + 84);
  else {
    unsigned int v14 = v10;
  }
  if (v14 <= 0xFE) {
    unsigned int v15 = 254;
  }
  else {
    unsigned int v15 = v14;
  }
  else {
    unsigned int v16 = v15;
  }
  if (!a2) {
    return 0LL;
  }
  uint64_t v17 = AssociatedTypeWitness;
  uint64_t v18 = *(_DWORD *)(v12 + 80);
  uint64_t v19 = *(_DWORD *)(v12 + 80) | *(unsigned __int8 *)(v9 + 80);
  uint64_t v20 = *(void *)(v7 + 64) + v19;
  uint64_t v21 = *(void *)(v9 + 64) + v18 + 1;
  uint64_t v22 = *(void *)(v12 + 64);
  if (a2 <= v16) {
    goto LABEL_29;
  }
  uint64_t v23 = v22 + (v21 & ~v18) + (v20 & ~v19) + 1;
  char v24 = 8 * v23;
  unsigned int v26 = ((a2 - v16 + ~(-1 << v24)) >> v24) + 1;
  if (HIWORD(v26))
  {
    int v25 = *(_DWORD *)(a1 + v23);
    if (v25) {
      goto LABEL_20;
    }
  }

  else
  {
    if (v26 <= 0xFF)
    {
      if (v26 < 2) {
        goto LABEL_29;
      }
LABEL_13:
      int v25 = *(unsigned __int8 *)(a1 + v23);
      if (!*(_BYTE *)(a1 + v23)) {
        goto LABEL_29;
      }
LABEL_20:
      int v27 = (v25 - 1) << v24;
      if ((_DWORD)v22 + (v21 & ~(_DWORD)v18) + (v20 & ~(_DWORD)v19) != -1)
      {
        else {
          int v28 = 4;
        }
        __asm { BR              X12 }
      }

      int v33 = v16 + v27;
      return (v33 + 1);
    }

    int v25 = *(unsigned __int16 *)(a1 + v23);
    if (*(_WORD *)(a1 + v23)) {
      goto LABEL_20;
    }
  }

void sub_1000B7648(_BYTE *a1, unsigned int a2, unsigned int a3, void *a4)
{
  uint64_t v7 = a4[3];
  uint64_t v8 = *(void *)(v7 - 8);
  unsigned int v9 = *(_DWORD *)(v8 + 84);
  uint64_t v10 = *(void *)(a4[2] - 8LL);
  unsigned int v11 = *(_DWORD *)(v10 + 84);
  uint64_t v12 = *(void *)(swift_getAssociatedTypeWitness( 0LL,  a4[5],  v7,  &protocol requirements base descriptor for RawRepresentable,  &associated type descriptor for RawRepresentable.RawValue)
                  - 8);
  if (v11 <= *(_DWORD *)(v12 + 84)) {
    unsigned int v13 = *(_DWORD *)(v12 + 84);
  }
  else {
    unsigned int v13 = v11;
  }
  if (v13 <= 0xFE) {
    unsigned int v13 = 254;
  }
  if (v13 <= v9) {
    unsigned int v14 = v9;
  }
  else {
    unsigned int v14 = v13;
  }
  uint64_t v15 = *(_DWORD *)(v12 + 80) | *(unsigned __int8 *)(v10 + 80);
  size_t v16 = ((*(void *)(v8 + 64) + v15) & ~v15)
      + *(void *)(v12 + 64)
  if (a3 <= v14)
  {
    unsigned int v17 = 0;
  }

  else if (v16 <= 3)
  {
    unsigned int v19 = ((a3 - v14 + ~(-1 << (8 * v16))) >> (8 * v16)) + 1;
    if (HIWORD(v19))
    {
      unsigned int v17 = &dword_100000004;
    }

    else if (v19 >= 0x100)
    {
      unsigned int v17 = 2;
    }

    else
    {
      unsigned int v17 = v19 > 1;
    }
  }

  else
  {
    unsigned int v17 = &_mh_execute_header.magic + 1;
  }

  if (v14 < a2)
  {
    int v18 = ~v14 + a2;
    if (v16 < 4)
    {
      if ((_DWORD)v16)
      {
        int v20 = v18 & ~(-1 << (8
                           * (((*(_BYTE *)(v8 + 64) + v15) & ~(_BYTE)v15)
                            + *(_BYTE *)(v12 + 64)
        bzero(a1, v16);
        if ((_DWORD)v16 == 3)
        {
          *(_WORD *)a1 = v20;
          a1[2] = BYTE2(v20);
        }

        else if ((_DWORD)v16 == 2)
        {
          *(_WORD *)a1 = v20;
        }

        else
        {
          *a1 = v20;
        }
      }
    }

    else
    {
      bzero(a1, v16);
      *(_DWORD *)a1 = v18;
    }

    __asm { BR              X10 }
  }

  __asm { BR              X17 }

void sub_1000B796C()
{
  *(_WORD *)uint64_t v0 = v1;
  *(_BYTE *)(v0 + 2) = BYTE2(v1);
  JUMPOUT(0x1000B7924LL);
}

void sub_1000B797C()
{
  _WORD *v0 = v1;
  JUMPOUT(0x1000B7924LL);
}

void sub_1000B7984()
{
  _DWORD *v0 = v1;
  JUMPOUT(0x1000B7924LL);
}

uint64_t sub_1000B7990(uint64_t a1)
{
  uint64_t result = type metadata accessor for Preferences.Preference( 319LL,  *(void *)(a1 + 16),  (uint64_t)&type metadata for Data,  *(void *)(a1 + 24));
  if (v3 <= 0x3F)
  {
    uint64_t v4 = *(void *)(result - 8) + 64LL;
    swift_initStructMetadata(a1, 0LL, 1LL, &v4, a1 + 32);
    return 0LL;
  }

  return result;
}

void *sub_1000B7A04(void *a1, void *a2, uint64_t a3)
{
  uint64_t v4 = a1;
  uint64_t v5 = *(void *)(*(void *)(a3 + 16) - 8LL);
  uint64_t v6 = *(void *)(v5 + 64);
  int v7 = *(_DWORD *)(v5 + 80);
  if ((v6 & 0xFFFFFFFFFFFFFFF8LL) >= 0xFFFFFFFFFFFFFFE7LL && (v7 & 0x1000F8) == 0)
  {
    (*(void (**)(void *, void *))(v5 + 16))(a1, a2);
    *((_BYTE *)v4 + v6) = *((_BYTE *)a2 + v6);
    unint64_t v10 = ((unint64_t)v4 + v6) & 0xFFFFFFFFFFFFFFF8LL;
    unint64_t v11 = ((unint64_t)a2 + v6) & 0xFFFFFFFFFFFFFFF8LL;
    uint64_t v12 = *(void *)(v11 + 8);
    unint64_t v13 = *(void *)(v11 + 16);
    sub_100020AFC(v12, v13);
    *(void *)(v10 + 8) = v12;
    *(void *)(v10 + 16) = v13;
    *(_BYTE *)(v10 + 24) = *(_BYTE *)(v11 + 24);
  }

  else
  {
    uint64_t v9 = *a2;
    void *v4 = *a2;
    uint64_t v4 = (void *)(v9 + ((unsigned __int16)((v7 & 0xF8) + 23) & (unsigned __int16)~(v7 & 0xF8) & 0x1F8));
    swift_retain();
  }

  return v4;
}

uint64_t sub_1000B7AC8(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(*(void *)(a2 + 16) - 8LL);
  (*(void (**)(void))(v3 + 8))();
  return sub_1000208D8( *(void *)(((*(void *)(v3 + 64) + a1) & 0xFFFFFFFFFFFFFFF8LL) + 8),  *(void *)(((*(void *)(v3 + 64) + a1) & 0xFFFFFFFFFFFFFFF8LL) + 16));
}

uint64_t sub_1000B7B04(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(*(void *)(a3 + 16) - 8LL);
  (*(void (**)(void))(v5 + 16))();
  uint64_t v6 = *(void *)(v5 + 64);
  unint64_t v7 = v6 + a1;
  unint64_t v8 = v6 + a2;
  *(_BYTE *)unint64_t v7 = *(_BYTE *)v8;
  unint64_t v9 = v7 & 0xFFFFFFFFFFFFFFF8LL;
  unint64_t v10 = v8 & 0xFFFFFFFFFFFFFFF8LL;
  uint64_t v11 = *(void *)((v8 & 0xFFFFFFFFFFFFFFF8LL) + 8);
  unint64_t v12 = *(void *)((v8 & 0xFFFFFFFFFFFFFFF8LL) + 16);
  sub_100020AFC(v11, v12);
  *(void *)(v9 + 8) = v11;
  *(void *)(v9 + 16) = v12;
  *(_BYTE *)(v9 + 24) = *(_BYTE *)(v10 + 24);
  return a1;
}

uint64_t sub_1000B7B80(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(*(void *)(a3 + 16) - 8LL);
  (*(void (**)(void))(v5 + 24))();
  uint64_t v6 = *(void *)(v5 + 64);
  unint64_t v7 = v6 + a1;
  unint64_t v8 = v6 + a2;
  *(_BYTE *)unint64_t v7 = *(_BYTE *)v8;
  unint64_t v9 = v7 & 0xFFFFFFFFFFFFFFF8LL;
  unint64_t v10 = v8 & 0xFFFFFFFFFFFFFFF8LL;
  uint64_t v11 = *(void *)((v8 & 0xFFFFFFFFFFFFFFF8LL) + 8);
  unint64_t v12 = *(void *)((v8 & 0xFFFFFFFFFFFFFFF8LL) + 16);
  sub_100020AFC(v11, v12);
  uint64_t v13 = *(void *)(v9 + 8);
  unint64_t v14 = *(void *)(v9 + 16);
  *(void *)(v9 + 8) = v11;
  *(void *)(v9 + 16) = v12;
  sub_1000208D8(v13, v14);
  *(_BYTE *)(v9 + 24) = *(_BYTE *)(v10 + 24);
  return a1;
}

uint64_t sub_1000B7C04(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(*(void *)(a3 + 16) - 8LL);
  (*(void (**)(void))(v5 + 32))();
  uint64_t v6 = *(void *)(v5 + 64);
  uint64_t v7 = v6 + a1;
  uint64_t v8 = v6 + a2;
  *(_BYTE *)uint64_t v7 = *(_BYTE *)v8;
  v7 &= 0xFFFFFFFFFFFFFFF8LL;
  v8 &= 0xFFFFFFFFFFFFFFF8LL;
  *(_OWORD *)(v7 + 8) = *(_OWORD *)(v8 + 8);
  *(_BYTE *)(v7 + 24) = *(_BYTE *)(v8 + 24);
  return a1;
}

uint64_t sub_1000B7C6C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(*(void *)(a3 + 16) - 8LL);
  (*(void (**)(void))(v5 + 40))();
  uint64_t v6 = *(void *)(v5 + 64);
  unint64_t v7 = v6 + a1;
  unint64_t v8 = v6 + a2;
  *(_BYTE *)unint64_t v7 = *(_BYTE *)v8;
  unint64_t v9 = v7 & 0xFFFFFFFFFFFFFFF8LL;
  unint64_t v10 = v8 & 0xFFFFFFFFFFFFFFF8LL;
  uint64_t v11 = *(void *)((v7 & 0xFFFFFFFFFFFFFFF8LL) + 8);
  unint64_t v12 = *(void *)((v7 & 0xFFFFFFFFFFFFFFF8LL) + 16);
  *(_OWORD *)((v7 & 0xFFFFFFFFFFFFFFF8LL) + 8) = *(_OWORD *)((v8 & 0xFFFFFFFFFFFFFFF8LL) + 8);
  sub_1000208D8(v11, v12);
  *(_BYTE *)(v9 + 24) = *(_BYTE *)(v10 + 24);
  return a1;
}

uint64_t sub_1000B7CDC(uint64_t a1, unsigned int a2, uint64_t a3)
{
  uint64_t v4 = *(void *)(*(void *)(a3 + 16) - 8LL);
  unsigned int v5 = *(_DWORD *)(v4 + 84);
  if (v5 <= 0xFE) {
    unsigned int v6 = 254;
  }
  else {
    unsigned int v6 = *(_DWORD *)(v4 + 84);
  }
  if (!a2) {
    return 0LL;
  }
  uint64_t v7 = *(void *)(v4 + 64);
  if (v6 >= a2)
  {
    if (v5 >= 0xFE) {
      return (*(uint64_t (**)(void))(v4 + 48))();
    }
    unsigned int v14 = *(unsigned __int8 *)(((v7 + a1) & 0xFFFFFFFFFFFFF8LL) + 0x18);
    if (v14 >= 2) {
      return ((v14 + 2147483646) & 0x7FFFFFFF) + 1;
    }
    return 0LL;
  }

  unsigned int v8 = (v7 & 0xFFFFFFF8) + 25;
  unsigned int v9 = (a2 - v6 + 255) >> (8 * v8);
  if (v8 < 4) {
    unsigned int v10 = v9 + 1;
  }
  else {
    unsigned int v10 = 2;
  }
  if (v10 >= 0x10000) {
    unsigned int v11 = 4;
  }
  else {
    unsigned int v11 = 2;
  }
  if (v10 < 0x100) {
    unsigned int v11 = 1;
  }
  if (v10 >= 2) {
    uint64_t v12 = v11;
  }
  else {
    uint64_t v12 = 0LL;
  }
  return ((uint64_t (*)(void))((char *)&loc_1000B7D60 + 4 * byte_10033F23C[v12]))();
}

void sub_1000B7DF4(_BYTE *a1, unsigned int a2, unsigned int a3, uint64_t a4)
{
  uint64_t v5 = *(void *)(*(void *)(a4 + 16) - 8LL);
  if (*(_DWORD *)(v5 + 84) <= 0xFEu) {
    unsigned int v6 = 254;
  }
  else {
    unsigned int v6 = *(_DWORD *)(v5 + 84);
  }
  size_t v7 = (*(void *)(v5 + 64) & 0xFFFFFFFFFFFFFFF8LL) + 25;
  if (v6 >= a3)
  {
    int v10 = 0;
    if (v6 >= a2) {
      goto LABEL_17;
    }
  }

  else
  {
    else {
      unsigned int v8 = 2;
    }
    if (v8 >= 0x10000) {
      int v9 = 4;
    }
    else {
      int v9 = 2;
    }
    if (v8 < 0x100) {
      int v9 = 1;
    }
    if (v8 >= 2) {
      int v10 = v9;
    }
    else {
      int v10 = 0;
    }
    if (v6 >= a2) {
LABEL_17:
    }
      __asm { BR              X12 }
  }

  else {
    unsigned int v11 = (~(_BYTE)v6 + a2);
  }
  bzero(a1, v7);
  if ((_DWORD)v7 == 1) {
    *a1 = v11;
  }
  else {
    *(_DWORD *)a1 = v11;
  }
  __asm { BR              X10 }

void sub_1000B7F0C()
{
  *(_BYTE *)(v0 + (*(void (**)(uint64_t, uint64_t, uint64_t))(v4 + 32))( v0 + OBJC_IVAR____TtC7CoreP2P18AppleIO80211Driver_logger,  v3, v1) = v2;
}

void sub_1000B7F14(uint64_t a1, int a2)
{
  *(_DWORD *)(v2 + v3) = 0;
  if (a2) {
    JUMPOUT(0x1000B7F1CLL);
  }
}

void sub_1000B7F58()
{
  *(_WORD *)(v0 + (*(void (**)(uint64_t, uint64_t, uint64_t))(v4 + 32))( v0 + OBJC_IVAR____TtC7CoreP2P18AppleIO80211Driver_logger,  v3, v1) = v2;
}

void sub_1000B7F60()
{
  *(_DWORD *)(v0 + (*(void (**)(uint64_t, uint64_t, uint64_t))(v4 + 32))( v0 + OBJC_IVAR____TtC7CoreP2P18AppleIO80211Driver_logger,  v3, v1) = v2;
}

uint64_t sub_1000B7F68(uint64_t a1, int a2, unsigned int a3)
{
  *(_WORD *)(v6 + v7) = 0;
  if (!a2) {
LABEL_2:
  }
    JUMPOUT(0x1000B7F70LL);
  if (a3 < 0xFE)
  {
    *(_BYTE *)(((v5 + v6) & 0xFFFFFFFFFFFFFFF8LL) + 24) = a2 + 1;
    goto LABEL_2;
  }

  return (*(uint64_t (**)(uint64_t))(v4 + 56))(v6);
}

uint64_t sub_1000B7FAC(uint64_t a1)
{
  v4[0] = (char *)&value witness table for Builtin.NativeObject + 64;
  uint64_t result = swift_checkMetadataState(319LL, *(void *)(a1 + 16));
  if (v3 <= 0x3F)
  {
    v4[1] = *(void *)(result - 8) + 64LL;
    swift_initStructMetadata(a1, 0LL, 2LL, v4, a1 + 32);
    return 0LL;
  }

  return result;
}

uint64_t *sub_1000B8028(uint64_t *a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v4 = *(void *)(a3 + 16);
  uint64_t v5 = *(void *)(v4 - 8);
  uint64_t v6 = *(_DWORD *)(v5 + 80);
  unint64_t v7 = ((v6 + 8) & ~v6) + *(void *)(v5 + 64);
  int v8 = *(_DWORD *)(v5 + 80) & 0x100000;
  uint64_t v9 = *a2;
  *a1 = *a2;
  if (v6 > 7 || v8 != 0 || v7 > 0x18)
  {
    a1 = (uint64_t *)(v9 + ((v6 & 0xF8 ^ 0x1F8) & (v6 + 16)));
    swift_retain(v9);
  }

  else
  {
    uint64_t v12 = ((unint64_t)a1 + v6 + 8) & ~v6;
    uint64_t v13 = ((unint64_t)a2 + v6 + 8) & ~v6;
    unsigned int v14 = *(void (**)(uint64_t, uint64_t, uint64_t))(v5 + 16);
    swift_retain(v9);
    v14(v12, v13, v4);
  }

  return a1;
}

uint64_t sub_1000B80E4(void *a1, uint64_t a2)
{
  return (*(uint64_t (**)(unint64_t))(*(void *)(*(void *)(a2 + 16) - 8LL) + 8LL))(((unint64_t)a1 + *(unsigned __int8 *)(*(void *)(*(void *)(a2 + 16) - 8LL) + 80LL) + 8) & ~(unint64_t)*(unsigned __int8 *)(*(void *)(*(void *)(a2 + 16) - 8LL) + 80LL));
}

uint64_t *sub_1000B8128(uint64_t *a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v4 = *a2;
  *a1 = *a2;
  uint64_t v5 = *(void *)(a3 + 16);
  uint64_t v6 = *(void *)(v5 - 8);
  uint64_t v7 = *(unsigned __int8 *)(v6 + 80);
  uint64_t v8 = ((unint64_t)a1 + v7 + 8) & ~v7;
  uint64_t v9 = ((unint64_t)a2 + v7 + 8) & ~v7;
  int v10 = *(void (**)(uint64_t, uint64_t, uint64_t))(v6 + 16);
  swift_retain(v4);
  v10(v8, v9, v5);
  return a1;
}

uint64_t *sub_1000B8198(uint64_t *a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v6 = *a2;
  uint64_t v7 = *a1;
  *a1 = *a2;
  swift_retain(v6);
  swift_release(v7);
  uint64_t v8 = *(void *)(*(void *)(a3 + 16) - 8LL);
  (*(void (**)(unint64_t, unint64_t))(v8 + 24))( ((unint64_t)a1 + *(unsigned __int8 *)(v8 + 80) + 8) & ~(unint64_t)*(unsigned __int8 *)(v8 + 80),  ((unint64_t)a2 + *(unsigned __int8 *)(v8 + 80) + 8) & ~(unint64_t)*(unsigned __int8 *)(v8 + 80));
  return a1;
}

void *sub_1000B8208(void *a1, void *a2, uint64_t a3)
{
  *a1 = *a2;
  uint64_t v4 = *(void *)(*(void *)(a3 + 16) - 8LL);
  (*(void (**)(unint64_t, unint64_t))(v4 + 32))( ((unint64_t)a1 + *(unsigned __int8 *)(v4 + 80) + 8) & ~(unint64_t)*(unsigned __int8 *)(v4 + 80),  ((unint64_t)a2 + *(unsigned __int8 *)(v4 + 80) + 8) & ~(unint64_t)*(unsigned __int8 *)(v4 + 80));
  return a1;
}

uint64_t *sub_1000B8258(uint64_t *a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v6 = *a1;
  *a1 = *a2;
  swift_release(v6);
  uint64_t v7 = *(void *)(*(void *)(a3 + 16) - 8LL);
  (*(void (**)(unint64_t, unint64_t))(v7 + 40))( ((unint64_t)a1 + *(unsigned __int8 *)(v7 + 80) + 8) & ~(unint64_t)*(unsigned __int8 *)(v7 + 80),  ((unint64_t)a2 + *(unsigned __int8 *)(v7 + 80) + 8) & ~(unint64_t)*(unsigned __int8 *)(v7 + 80));
  return a1;
}

uint64_t sub_1000B82C0(void *a1, unsigned int a2, uint64_t a3)
{
  uint64_t v4 = *(void *)(*(void *)(a3 + 16) - 8LL);
  unsigned int v5 = *(_DWORD *)(v4 + 84);
  if (v5 <= 0x7FFFFFFF) {
    unsigned int v6 = 0x7FFFFFFF;
  }
  else {
    unsigned int v6 = *(_DWORD *)(v4 + 84);
  }
  if (!a2) {
    return 0LL;
  }
  uint64_t v7 = *(unsigned __int8 *)(v4 + 80);
  int v8 = a2 - v6;
  if (a2 <= v6) {
    goto LABEL_22;
  }
  uint64_t v9 = ((v7 + 8) & ~v7) + *(void *)(v4 + 64);
  char v10 = 8 * v9;
  if (v9 <= 3)
  {
    unsigned int v13 = ((v8 + ~(-1 << v10)) >> v10) + 1;
    if (HIWORD(v13))
    {
      int v11 = *(_DWORD *)((char *)a1 + v9);
      if (!v11) {
        goto LABEL_22;
      }
      goto LABEL_15;
    }

    if (v13 > 0xFF)
    {
      int v11 = *(unsigned __int16 *)((char *)a1 + v9);
      goto LABEL_15;
    }

    if (v13 < 2)
    {
LABEL_22:
      if ((v5 & 0x80000000) != 0) {
        return (*(uint64_t (**)(unint64_t))(v4 + 48))(((unint64_t)a1 + v7 + 8) & ~v7);
      }
      uint64_t v15 = *a1;
      if (*a1 >= 0xFFFFFFFFuLL) {
        LODWORD(v15) = -1;
      }
      return (v15 + 1);
    }
  }

  int v11 = *((unsigned __int8 *)a1 + v9);
  if (!*((_BYTE *)a1 + v9)) {
    goto LABEL_22;
  }
LABEL_15:
  int v14 = (v11 - 1) << v10;
  if (!(_DWORD)v9) {
    return v6 + v14 + 1;
  }
  return ((uint64_t (*)(void))((char *)&loc_1000B8394 + 4 * byte_10033F24B[(v9 - 1)]))();
}

void sub_1000B8404(_WORD *a1, unsigned int a2, unsigned int a3, uint64_t a4)
{
  uint64_t v5 = *(void *)(*(void *)(a4 + 16) - 8LL);
  if (*(_DWORD *)(v5 + 84) <= 0x7FFFFFFFu) {
    unsigned int v6 = 0x7FFFFFFF;
  }
  else {
    unsigned int v6 = *(_DWORD *)(v5 + 84);
  }
  size_t v7 = ((*(unsigned __int8 *)(v5 + 80) + 8LL) & ~(unint64_t)*(unsigned __int8 *)(v5 + 80)) + *(void *)(v5 + 64);
  if (a3 > v6)
  {
    if (v7 <= 3)
    {
      unsigned int v10 = ((a3 - v6 + ~(-1 << (8 * v7))) >> (8 * v7)) + 1;
      if (HIWORD(v10))
      {
        unsigned int v8 = &dword_100000004;
      }

      else if (v10 >= 0x100)
      {
        unsigned int v8 = 2;
      }

      else
      {
        unsigned int v8 = v10 > 1;
      }
    }

    else
    {
      unsigned int v8 = &_mh_execute_header.magic + 1;
    }
  }

  else
  {
    unsigned int v8 = 0;
  }

  if (v6 < a2)
  {
    int v9 = ~v6 + a2;
    if (v7 < 4)
    {
      if ((_DWORD)v7)
      {
        int v11 = v9 & ~(-1 << (8 * v7));
        bzero(a1, v7);
        if ((_DWORD)v7 == 3)
        {
          *a1 = v11;
          *((_BYTE *)a1 + 2) = BYTE2(v11);
        }

        else if ((_DWORD)v7 == 2)
        {
          *a1 = v11;
        }

        else
        {
          *(_BYTE *)a1 = v11;
        }
      }
    }

    else
    {
      bzero(a1, v7);
      *(_DWORD *)a1 = v9;
    }

    __asm { BR              X10 }
  }

  __asm { BR              X13 }

uint64_t sub_1000B85F8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return swift_allocateGenericValueMetadata(a1, a2, a3, 16LL);
}

uint64_t InfraAssociationStartEvent.init(channel:)(uint64_t a1)
{
  return a1 & 0xFFFFFFFFFFFFLL;
}

void __swiftcall InfraAssociationJoinStatus.SubstateInformation.init(bssid:authorizationStatus:associationStatus:setSSIDStatus:supplicantEventStatus:)( CoreP2P::InfraAssociationJoinStatus::SubstateInformation *__return_ptr retstr, CoreP2P::WiFiAddress *bssid, CoreP2P::IEEE80211StatusAndReason_optional authorizationStatus, CoreP2P::IEEE80211StatusAndReason_optional associationStatus, CoreP2P::IEEE80211StatusAndReason_optional setSSIDStatus, CoreP2P::IEEE80211StatusAndReason_optional supplicantEventStatus)
{
}

__n128 InfraAssociationReadyEvent.init(status:ipAddress:)@<Q0>( __int16 a1@<W0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  char v5 = v9;
  __n128 result = (__n128)v8[0];
  __int128 v7 = v8[1];
  *(_WORD *)a3  = a1;
  *(__n128 *)(a3 + 8)  = result;
  *(_OWORD *)(a3 + 24)  = v7;
  *(_BYTE *)(a3 + 40)  = v5;
  return result;
}

uint64_t sub_1000B8674(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = sub_100002274(&qword_100407050);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v4 - 8) + 32LL))(a2, a1, v4);
  return a2;
}

void InfraScanStartEvent.hash(into:)(uint64_t a1, uint64_t a2)
{
  Swift::UInt v3 = *(void *)(a2 + 16);
  Hasher._combine(_:)(v3);
  if (v3)
  {
    uint64_t v4 = (unsigned __int8 *)(a2 + 37);
    do
    {
      char v6 = *(v4 - 1);
      int v7 = *v4;
      Hasher._combine(_:)(*(_DWORD *)(v4 - 5));
      Hasher._combine(_:)(0x801004u >> (8 * v6));
      switch(v7)
      {
        case 2:
          Swift::UInt v5 = 0LL;
          goto LABEL_4;
        case 3:
          Swift::UInt v5 = 1LL;
          goto LABEL_4;
        case 4:
          Swift::UInt v5 = 3LL;
          goto LABEL_4;
        case 5:
          Swift::UInt v5 = 4LL;
          goto LABEL_4;
        case 6:
          Swift::UInt v5 = 5LL;
LABEL_4:
          Hasher._combine(_:)(v5);
          break;
        default:
          Hasher._combine(_:)(2uLL);
          Hasher._combine(_:)(v7 & 1);
          break;
      }

      v4 += 8;
      --v3;
    }

    while (v3);
  }

Swift::Int InfraScanStartEvent.hashValue.getter(uint64_t a1)
{
  return Hasher._finalize()();
}

Swift::Int sub_1000B87E8()
{
  uint64_t v1 = *v0;
  Hasher.init(_seed:)(v3, 0LL);
  sub_100082BA0((uint64_t)v3, v1);
  return Hasher._finalize()();
}

void sub_1000B882C(uint64_t a1)
{
}

Swift::Int sub_1000B8834(uint64_t a1)
{
  uint64_t v2 = *v1;
  Hasher.init(_seed:)(v4, a1);
  InfraScanStartEvent.hash(into:)((uint64_t)v4, v2);
  return Hasher._finalize()();
}

uint64_t sub_1000B8874(uint64_t *a1, uint64_t *a2)
{
  return _s7CoreP2P19InfraScanStartEventV23__derived_struct_equalsySbAC_ACtFZ_0(*a1, *a2);
}

uint64_t InfraAssociationStartEvent.channel.setter(uint64_t result)
{
  *(_DWORD *)uint64_t v1 = result;
  *(_BYTE *)(v1 + 4)  = BYTE4(result);
  *(_BYTE *)(v1 + 5)  = BYTE5(result);
  return result;
}

void InfraAssociationStartEvent.hash(into:)(int a1, unint64_t a2)
{
  switch(BYTE5(a2))
  {
    case 2:
      Swift::UInt v3 = 0LL;
      goto LABEL_8;
    case 3:
      Swift::UInt v3 = 1LL;
      goto LABEL_8;
    case 4:
      Swift::UInt v3 = 3LL;
      goto LABEL_8;
    case 5:
      Swift::UInt v3 = 4LL;
      goto LABEL_8;
    case 6:
      Swift::UInt v3 = 5LL;
LABEL_8:
      Hasher._combine(_:)(v3);
      break;
    default:
      Hasher._combine(_:)(2uLL);
      Hasher._combine(_:)(BYTE5(a2) & 1);
      break;
  }

uint64_t static InfraAssociationStartEvent.__derived_struct_equals(_:_:)( unint64_t a1, unint64_t a2)
{
  if ((_DWORD)a1 != (_DWORD)a2
    || ((0x801004u >> ((a1 >> 29) & 0xF8)) & 0xFFC) != ((0x801004u >> ((a2 >> 29) & 0xF8)) & 0xFFC))
  {
    return 0LL;
  }

  switch(BYTE5(a1))
  {
    case 2:
      if (BYTE5(a2) != 2) {
        return 0LL;
      }
      uint64_t result = 1LL;
      break;
    case 3:
      if (BYTE5(a2) != 3) {
        return 0LL;
      }
      uint64_t result = 1LL;
      break;
    case 4:
      if (BYTE5(a2) != 4) {
        return 0LL;
      }
      uint64_t result = 1LL;
      break;
    case 5:
      if (BYTE5(a2) != 5) {
        return 0LL;
      }
      uint64_t result = 1LL;
      break;
    case 6:
      if (BYTE5(a2) != 6) {
        return 0LL;
      }
      uint64_t result = 1LL;
      break;
    default:
      uint64_t result = 1LL;
      break;
  }

  return result;
}

Swift::Int InfraAssociationStartEvent.hashValue.getter(unint64_t a1)
{
  switch(BYTE5(a1))
  {
    case 2:
      Swift::UInt v2 = 0LL;
      goto LABEL_8;
    case 3:
      Swift::UInt v2 = 1LL;
      goto LABEL_8;
    case 4:
      Swift::UInt v2 = 3LL;
      goto LABEL_8;
    case 5:
      Swift::UInt v2 = 4LL;
      goto LABEL_8;
    case 6:
      Swift::UInt v2 = 5LL;
LABEL_8:
      Hasher._combine(_:)(v2);
      break;
    default:
      Hasher._combine(_:)(2uLL);
      Hasher._combine(_:)(BYTE5(a1) & 1);
      break;
  }

  return Hasher._finalize()();
}

Swift::Int sub_1000B8B04()
{
  return InfraAssociationStartEvent.hashValue.getter(*v0 | ((unint64_t)*((unsigned __int8 *)v0 + 4) << 32) | ((unint64_t)*((unsigned __int8 *)v0 + 5) << 40));
}

void sub_1000B8B1C(int a1)
{
}

Swift::Int sub_1000B8B34(uint64_t a1)
{
  Swift::UInt32 v2 = *(_DWORD *)v1;
  char v3 = *(_BYTE *)(v1 + 4);
  int v4 = *(unsigned __int8 *)(v1 + 5);
  Hasher.init(_seed:)(v7, a1);
  Hasher._combine(_:)(v2);
  Hasher._combine(_:)(0x801004u >> (8 * v3));
  switch(v4)
  {
    case 2:
      Swift::UInt v5 = 0LL;
      goto LABEL_8;
    case 3:
      Swift::UInt v5 = 1LL;
      goto LABEL_8;
    case 4:
      Swift::UInt v5 = 3LL;
      goto LABEL_8;
    case 5:
      Swift::UInt v5 = 4LL;
      goto LABEL_8;
    case 6:
      Swift::UInt v5 = 5LL;
LABEL_8:
      Hasher._combine(_:)(v5);
      break;
    default:
      Hasher._combine(_:)(2uLL);
      Hasher._combine(_:)(v4 & 1);
      break;
  }

  return Hasher._finalize()();
}

uint64_t sub_1000B8C1C(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)a1 != *(_DWORD *)a2
    || ((0x801004u >> (8 * *(_BYTE *)(a1 + 4))) & 0xFFC) != ((0x801004u >> (8 * *(_BYTE *)(a2 + 4))) & 0xFFC))
  {
    return 0LL;
  }

  int v2 = *(unsigned __int8 *)(a2 + 5);
  switch(*(_BYTE *)(a1 + 5))
  {
    case 2:
      if (v2 != 2) {
        return 0LL;
      }
      break;
    case 3:
      if (v2 != 3) {
        return 0LL;
      }
      break;
    case 4:
      if (v2 != 4) {
        return 0LL;
      }
      break;
    case 5:
      if (v2 != 5) {
        return 0LL;
      }
      break;
    case 6:
      if (v2 != 6) {
        return 0LL;
      }
      break;
    default:
      break;
  }

  return 1LL;
}

uint64_t InfraAssociationJoinStatus.SubstateInformation.bssid.setter(uint64_t result)
{
  *(_WORD *)uint64_t v1 = result;
  *(_BYTE *)(v1 + 2)  = BYTE2(result);
  *(_BYTE *)(v1 + 3)  = BYTE3(result);
  *(_BYTE *)(v1 + 4)  = BYTE4(result);
  *(_BYTE *)(v1 + 5)  = BYTE5(result);
  return result;
}

unint64_t IEEE80211InformationElement.VeryHighThroughputCapability.rxHighLGIRate.getter( unint64_t a1)
{
  return HIWORD(a1);
}

uint64_t IEEE80211InformationElement.VeryHighThroughputCapability.rxHighLGIRate.setter(uint64_t result)
{
  *(_WORD *)(v1 + 6)  = result;
  return result;
}

uint64_t IEEE80211InformationElement.VeryHighThroughputCapability.txMCSMap.setter(uint64_t result)
{
  *(_WORD *)(v1 + 8)  = result;
  return result;
}

unint64_t InfraAssociationJoinStatus.SubstateInformation.setSSIDStatus.getter( uint64_t a1, unint64_t a2)
{
  return a2 >> 16;
}

uint64_t IEEE80211InformationElement.VeryHighThroughputCapability.txHighLGIRate.setter(uint64_t result)
{
  *(_WORD *)(v1 + 10)  = result;
  return result;
}

uint64_t (*IEEE80211InformationElement.VeryHighThroughputCapability.txHighLGIRate.modify())()
{
  return NANBitmap.Channel.operatingClass.getter;
}

unint64_t InfraAssociationJoinStatus.SubstateInformation.supplicantEventStatus.getter( uint64_t a1, unint64_t a2)
{
  return HIDWORD(a2);
}

uint64_t InfraAssociationJoinStatus.SubstateInformation.supplicantEventStatus.setter(uint64_t result)
{
  *(_WORD *)(v1 + 12)  = result;
  return result;
}

uint64_t (*InfraAssociationJoinStatus.SubstateInformation.supplicantEventStatus.modify())()
{
  return NANBitmap.Channel.operatingClass.getter;
}

void InfraAssociationJoinStatus.SubstateInformation.hash(into:)(int a1, unint64_t a2, uint64_t a3)
{
  unint64_t v5 = a2 >> 8;
  unint64_t v6 = a2 >> 16;
  unint64_t v7 = a2 >> 24;
  unint64_t v8 = HIDWORD(a2);
  unint64_t v9 = a2 >> 40;
  Hasher._combine(_:)(a2);
  Hasher._combine(_:)(v5);
  Hasher._combine(_:)(v6);
  Hasher._combine(_:)(v7);
  Hasher._combine(_:)(v8);
  Hasher._combine(_:)(v9);
  if (HIBYTE(a2) == 34)
  {
    Hasher._combine(_:)(0);
  }

  else
  {
    Hasher._combine(_:)(1u);
    Hasher._combine(_:)(word_10033FC1E[(uint64_t)(a2 << 8) >> 56]);
    Hasher._combine(_:)(word_10033FC8A[(uint64_t)a2 >> 56]);
  }

  if ((a3 & 0xFF00) == 0x2200)
  {
    Hasher._combine(_:)(0);
  }

  else
  {
    Hasher._combine(_:)(1u);
    Hasher._combine(_:)(word_10033FC1E[(char)a3]);
    Hasher._combine(_:)(word_10033FC8A[(uint64_t)(__int16)a3 >> 8]);
  }

  if ((a3 & 0xFF000000) == 0x22000000)
  {
    Hasher._combine(_:)(0);
  }

  else
  {
    Hasher._combine(_:)(1u);
    Hasher._combine(_:)(word_10033FC1E[a3 << 40 >> 56]);
    Hasher._combine(_:)(word_10033FC8A[(uint64_t)(int)a3 >> 24]);
  }

  if ((a3 & 0xFF0000000000LL) == 0x220000000000LL)
  {
    Hasher._combine(_:)(0);
  }

  else
  {
    Hasher._combine(_:)(1u);
    Hasher._combine(_:)(word_10033FC1E[a3 << 24 >> 56]);
    Hasher._combine(_:)(word_10033FC8A[a3 << 16 >> 56]);
  }

BOOL static InfraAssociationJoinStatus.SubstateInformation.__derived_struct_equals(_:_:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return sub_1000B9838(a1, a2 & 0xFFFFFFFFFFFFLL, a3, a4 & 0xFFFFFFFFFFFFLL);
}

Swift::Int InfraAssociationJoinStatus.SubstateInformation.hashValue.getter(unint64_t a1, uint64_t a2)
{
  return Hasher._finalize()();
}

Swift::Int sub_1000B8F4C()
{
  uint64_t v1 = *(unsigned int *)(v0 + 8);
  uint64_t v2 = *(unsigned __int16 *)(v0 + 12);
  unint64_t v3 = *(void *)v0;
  Hasher.init(_seed:)(v5, 0LL);
  InfraAssociationJoinStatus.SubstateInformation.hash(into:)((int)v5, v3, v1 | (v2 << 32));
  return Hasher._finalize()();
}

void sub_1000B8FA4(int a1)
{
}

Swift::Int sub_1000B8FB8(uint64_t a1)
{
  uint64_t v2 = *(unsigned int *)(v1 + 8);
  uint64_t v3 = *(unsigned __int16 *)(v1 + 12);
  unint64_t v4 = *(void *)v1;
  Hasher.init(_seed:)(v6, a1);
  InfraAssociationJoinStatus.SubstateInformation.hash(into:)((int)v6, v4, v2 | (v3 << 32));
  return Hasher._finalize()();
}

BOOL sub_1000B900C(uint64_t a1, uint64_t a2)
{
  return sub_1000B9838( *(void *)a1,  *(unsigned int *)(a1 + 8) | ((unint64_t)*(unsigned __int16 *)(a1 + 12) << 32),  *(void *)a2,  *(unsigned int *)(a2 + 8) | ((unint64_t)*(unsigned __int16 *)(a2 + 12) << 32));
}

uint64_t InfraAssociationJoinStatus.returnValue.setter(uint64_t result)
{
  *(_DWORD *)(v1 + 8)  = result;
  return result;
}

uint64_t InfraAssociationJoinStatus.ieeeStatus.setter(uint64_t result)
{
  *(_DWORD *)(v1 + 12)  = result;
  return result;
}

uint64_t NANDataRequestReceivedEvent.attributes.getter(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return swift_bridgeObjectRetain(a3);
}

uint64_t IEEE80211InformationElement.RSNCapability.authenticationKeyManagementSuites.setter(uint64_t a1)
{
  uint64_t result = swift_bridgeObjectRelease(*(void *)(v1 + 16));
  *(void *)(v1 + 16)  = a1;
  return result;
}

uint64_t NANBeacon.Metadata.tsf.getter(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return a4;
}

uint64_t InfraAssociationJoinStatus.extensionReturnValue.setter(uint64_t result)
{
  *(_DWORD *)(v1 + 24)  = result;
  return result;
}

uint64_t (*NANBeacon.Metadata.tsf.modify())()
{
  return NANBitmap.Channel.operatingClass.getter;
}

void InfraAssociationJoinStatus.hash(into:)( uint64_t a1, unint64_t a2, unint64_t a3, uint64_t a4, Swift::UInt32 a5)
{
  Swift::UInt32 v7 = a3;
  unint64_t v9 = a2 >> 8;
  unint64_t v10 = a2 >> 16;
  unint64_t v11 = a2 >> 24;
  unint64_t v12 = HIDWORD(a2);
  unint64_t v13 = a2 >> 40;
  unint64_t v14 = HIDWORD(a3);
  Hasher._combine(_:)(a2);
  Hasher._combine(_:)(v9);
  Hasher._combine(_:)(v10);
  Hasher._combine(_:)(v11);
  Hasher._combine(_:)(v12);
  Hasher._combine(_:)(v13);
  Hasher._combine(_:)(v7);
  Hasher._combine(_:)(v14);
  sub_1000828C4(a1, a4);
  Hasher._combine(_:)(a5);
}

uint64_t static InfraAssociationJoinStatus.__derived_struct_equals(_:_:)( uint64_t a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5, uint64_t a6, uint64_t a7, int a8)
{
  return sub_1000B9A80(a1 & 0xFFFFFFFFFFFFLL, a2, a3, a4, a5 & 0xFFFFFFFFFFFFLL, a6, a7, a8);
}

Swift::Int InfraAssociationJoinStatus.hashValue.getter( unint64_t a1, unint64_t a2, uint64_t a3, Swift::UInt32 a4)
{
  Swift::UInt32 v5 = a2;
  Swift::UInt8 v6 = a1;
  unint64_t v7 = a1 >> 8;
  unint64_t v8 = a1 >> 16;
  unint64_t v9 = a1 >> 24;
  unint64_t v10 = HIDWORD(a1);
  unint64_t v11 = a1 >> 40;
  unint64_t v12 = HIDWORD(a2);
  Hasher.init(_seed:)(v15, 0LL);
  Hasher._combine(_:)(v6);
  Hasher._combine(_:)(v7);
  Hasher._combine(_:)(v8);
  Hasher._combine(_:)(v9);
  Hasher._combine(_:)(v10);
  Hasher._combine(_:)(v11);
  Hasher._combine(_:)(v5);
  Hasher._combine(_:)(v12);
  sub_1000828C4((uint64_t)v15, a3);
  Hasher._combine(_:)(a4);
  return Hasher._finalize()();
}

Swift::Int sub_1000B9248()
{
  Swift::UInt32 v1 = *(_DWORD *)(v0 + 8);
  Swift::UInt32 v2 = *(_DWORD *)(v0 + 12);
  uint64_t v3 = *(void *)(v0 + 16);
  Swift::UInt32 v11 = *(_DWORD *)(v0 + 24);
  Swift::UInt8 v4 = *(_BYTE *)v0;
  Swift::UInt8 v5 = *(_BYTE *)(v0 + 1);
  Swift::UInt8 v6 = *(_BYTE *)(v0 + 2);
  Swift::UInt8 v7 = *(_BYTE *)(v0 + 3);
  Swift::UInt8 v8 = *(_BYTE *)(v0 + 4);
  Swift::UInt8 v9 = *(_BYTE *)(v0 + 5);
  Hasher.init(_seed:)(v12, 0LL);
  Hasher._combine(_:)(v4);
  Hasher._combine(_:)(v5);
  Hasher._combine(_:)(v6);
  Hasher._combine(_:)(v7);
  Hasher._combine(_:)(v8);
  Hasher._combine(_:)(v9);
  Hasher._combine(_:)(v1);
  Hasher._combine(_:)(v2);
  sub_1000828C4((uint64_t)v12, v3);
  Hasher._combine(_:)(v11);
  return Hasher._finalize()();
}

void sub_1000B933C(uint64_t a1)
{
  Swift::UInt32 v3 = *(_DWORD *)(v1 + 8);
  Swift::UInt32 v4 = *(_DWORD *)(v1 + 12);
  uint64_t v5 = *(void *)(v1 + 16);
  Swift::UInt32 v11 = *(_DWORD *)(v1 + 24);
  Swift::UInt8 v6 = *(_BYTE *)(v1 + 1);
  Swift::UInt8 v7 = *(_BYTE *)(v1 + 2);
  Swift::UInt8 v8 = *(_BYTE *)(v1 + 3);
  Swift::UInt8 v9 = *(_BYTE *)(v1 + 4);
  Swift::UInt8 v10 = *(_BYTE *)(v1 + 5);
  Hasher._combine(_:)(*(_BYTE *)v1);
  Hasher._combine(_:)(v6);
  Hasher._combine(_:)(v7);
  Hasher._combine(_:)(v8);
  Hasher._combine(_:)(v9);
  Hasher._combine(_:)(v10);
  Hasher._combine(_:)(v3);
  Hasher._combine(_:)(v4);
  sub_1000828C4(a1, v5);
  Hasher._combine(_:)(v11);
}

Swift::Int sub_1000B93FC(uint64_t a1)
{
  Swift::UInt32 v2 = *(_DWORD *)(v1 + 8);
  Swift::UInt32 v3 = *(_DWORD *)(v1 + 12);
  uint64_t v4 = *(void *)(v1 + 16);
  Swift::UInt32 v12 = *(_DWORD *)(v1 + 24);
  Swift::UInt8 v5 = *(_BYTE *)v1;
  Swift::UInt8 v6 = *(_BYTE *)(v1 + 1);
  Swift::UInt8 v7 = *(_BYTE *)(v1 + 2);
  Swift::UInt8 v8 = *(_BYTE *)(v1 + 3);
  Swift::UInt8 v9 = *(_BYTE *)(v1 + 4);
  Swift::UInt8 v10 = *(_BYTE *)(v1 + 5);
  Hasher.init(_seed:)(v13, a1);
  Hasher._combine(_:)(v5);
  Hasher._combine(_:)(v6);
  Hasher._combine(_:)(v7);
  Hasher._combine(_:)(v8);
  Hasher._combine(_:)(v9);
  Hasher._combine(_:)(v10);
  Hasher._combine(_:)(v2);
  Hasher._combine(_:)(v3);
  sub_1000828C4((uint64_t)v13, v4);
  Hasher._combine(_:)(v12);
  return Hasher._finalize()();
}

uint64_t sub_1000B94EC(unsigned int *a1, unsigned int *a2)
{
  return sub_1000B9A80( *a1 | ((unint64_t)*((unsigned __int8 *)a1 + 4) << 32) | ((unint64_t)*((unsigned __int8 *)a1 + 5) << 40),  *((void *)a1 + 1),  *((void *)a1 + 2),  a1[6],  *a2 | ((unint64_t)*((unsigned __int8 *)a2 + 4) << 32) | ((unint64_t)*((unsigned __int8 *)a2 + 5) << 40),  *((void *)a2 + 1),  *((void *)a2 + 2),  a2[6]);
}

uint64_t InfraAssociationReadyEvent.ipAddress.getter@<X0>(uint64_t a1@<X8>)
{
  return sub_1000B9B50(v1 + 8, a1);
}

uint64_t InfraAssociationReadyEvent.ipAddress.setter(uint64_t a1)
{
  return sub_1000B9B98(a1, v1 + 8);
}

void InfraAssociationReadyEvent.hash(into:)(uint64_t a1)
{
  uint64_t v2 = v1;
  Hasher._combine(_:)(*(_WORD *)v2);
  int v4 = *(unsigned __int8 *)(v2 + 40);
  if (v4 == 255)
  {
    Hasher._combine(_:)(0);
    return;
  }

  uint64_t v5 = *(void *)(v2 + 8);
  uint64_t v6 = *(void *)(v2 + 16);
  uint64_t v7 = *(void *)(v2 + 24);
  uint64_t v8 = *(void *)(v2 + 32);
  Hasher._combine(_:)(1u);
  if ((v4 & 1) != 0)
  {
    v12[0]  = v5;
    v12[1]  = v6;
    swift_bridgeObjectRetain_n(v8, 3LL);
    uint64_t v9 = sub_1000EF854((uint64_t)v12, (uint64_t)&v13);
    unint64_t v11 = v10;
    Data.hash(into:)(a1, v9, v10);
    sub_1000208D8(v9, v11);
    if (v8)
    {
      Hasher._combine(_:)(1u);
      swift_bridgeObjectRetain(v8);
      String.hash(into:)(a1, v7, v8);
      sub_1000BA574(v2, (void (*)(void, void, void, void, void))sub_100056B0C);
      sub_1000BA574(v2, (void (*)(void, void, void, void, void))sub_100056B0C);
      sub_1000BA574(v2, (void (*)(void, void, void, void, void))sub_100056B0C);
      sub_100056B24(v5, v6, v7, v8, 1);
      return;
    }

    Hasher._combine(_:)(0);
    sub_1000BA574(v2, (void (*)(void, void, void, void, void))sub_100056B0C);
  }

  else
  {
    Hasher._combine(_:)(v5);
  }

  sub_1000BA574(v2, (void (*)(void, void, void, void, void))sub_100056B0C);
  sub_1000BA574(v2, (void (*)(void, void, void, void, void))sub_100056B0C);
}

Swift::Int InfraAssociationReadyEvent.hashValue.getter()
{
  return Hasher._finalize()();
}

Swift::Int sub_1000B971C()
{
  __int128 v1 = v0[1];
  __int128 v4 = *v0;
  v5[0]  = v1;
  *(_OWORD *)((char *)v5 + 9)  = *(__int128 *)((char *)v0 + 25);
  Hasher.init(_seed:)(v3, 0LL);
  InfraAssociationReadyEvent.hash(into:)((uint64_t)v3);
  return Hasher._finalize()();
}

void sub_1000B976C(uint64_t a1)
{
}

Swift::Int sub_1000B97A4(uint64_t a1)
{
  __int128 v2 = v1[1];
  __int128 v5 = *v1;
  v6[0]  = v2;
  *(_OWORD *)((char *)v6 + 9)  = *(__int128 *)((char *)v1 + 25);
  Hasher.init(_seed:)(v4, a1);
  InfraAssociationReadyEvent.hash(into:)((uint64_t)v4);
  return Hasher._finalize()();
}

uint64_t sub_1000B97F0(__int128 *a1, __int128 *a2)
{
  __int128 v2 = a1[1];
  __int128 v5 = *a1;
  v6[0]  = v2;
  *(_OWORD *)((char *)v6 + 9)  = *(__int128 *)((char *)a1 + 25);
  __int128 v3 = a2[1];
  __int128 v7 = *a2;
  v8[0]  = v3;
  *(_OWORD *)((char *)v8 + 9)  = *(__int128 *)((char *)a2 + 25);
  return _s7CoreP2P26InfraAssociationReadyEventV23__derived_struct_equalsySbAC_ACtFZ_0( (unsigned __int16 *)&v5,  (unsigned __int16 *)&v7) & 1;
}

BOOL sub_1000B9838(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  LOBYTE(v11)  = BYTE4(a1);
  HIBYTE(v11)  = BYTE5(a1);
  LOBYTE(v10)  = BYTE4(a3);
  HIBYTE(v10)  = BYTE5(a3);
  if ((_DWORD)a1 != (_DWORD)a3 || v11 != v10) {
    return 0LL;
  }
  unint64_t v6 = a3 & 0xFF00000000000000LL;
  if (HIBYTE(a1) == 34)
  {
    if (v6 != 0x2200000000000000LL) {
      return 0LL;
    }
  }

  else if (v6 == 0x2200000000000000LL {
         || word_10033FC1E[a1 << 8 >> 56] != word_10033FC1E[a3 << 8 >> 56]
  }
         || word_10033FC8A[a1 >> 56] != word_10033FC8A[a3 >> 56])
  {
    return 0LL;
  }

  uint64_t v7 = (unsigned __int16)a4 & 0xFF00;
  if ((a2 & 0xFF00) == 0x2200)
  {
    if (v7 != 8704) {
      return 0LL;
    }
  }

  else if (v7 == 8704 {
         || word_10033FC1E[(char)a2] != word_10033FC1E[(char)a4]
  }
         || word_10033FC8A[(uint64_t)(__int16)a2 >> 8] != word_10033FC8A[(uint64_t)(__int16)a4 >> 8])
  {
    return 0LL;
  }

  uint64_t v8 = a4 & 0xFF000000;
  if ((a2 & 0xFF000000) == 0x22000000)
  {
    if (v8 != 570425344) {
      return 0LL;
    }
  }

  else if (v8 == 570425344 {
         || word_10033FC1E[a2 << 40 >> 56] != word_10033FC1E[a4 << 40 >> 56]
  }
         || word_10033FC8A[(uint64_t)(int)a2 >> 24] != word_10033FC8A[(uint64_t)(int)a4 >> 24])
  {
    return 0LL;
  }

  uint64_t v9 = a4 & 0xFF0000000000LL;
  if ((a2 & 0xFF0000000000LL) != 0x220000000000LL) {
    return v9 != 0x220000000000LL
  }
        && word_10033FC1E[a2 << 24 >> 56] == word_10033FC1E[a4 << 24 >> 56]
        && word_10033FC8A[a2 << 16 >> 56] == word_10033FC8A[a4 << 16 >> 56];
  return v9 == 0x220000000000LL;
}

uint64_t sub_1000B9A80( uint64_t a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5, uint64_t a6, uint64_t a7, int a8)
{
  LOBYTE(v14)  = BYTE4(a1);
  HIBYTE(v14)  = BYTE5(a1);
  LOBYTE(v13)  = BYTE4(a5);
  HIBYTE(v13)  = BYTE5(a5);
  if ((_DWORD)a1 == (_DWORD)a5 && v14 == v13 && (_DWORD)a2 == (_DWORD)a6 && HIDWORD(a2) == HIDWORD(a6)) {
    return sub_10007D5BC(a3, a7) & (a4 == a8);
  }
  else {
    return 0LL;
  }
}

uint64_t sub_1000B9B50(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = sub_100002274(&qword_100407050);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v4 - 8) + 16LL))(a2, a1, v4);
  return a2;
}

uint64_t sub_1000B9B98(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = sub_100002274(&qword_100407050);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v4 - 8) + 40LL))(a2, a1, v4);
  return a2;
}

uint64_t _s7CoreP2P26InfraAssociationReadyEventV23__derived_struct_equalsySbAC_ACtFZ_0( unsigned __int16 *a1, unsigned __int16 *a2)
{
  if (*a1 == *a2)
  {
    int v4 = *((unsigned __int8 *)a1 + 40);
    int v5 = *((unsigned __int8 *)a2 + 40);
    if (v4 == 255)
    {
      if (v5 == 255) {
        return 1LL;
      }
    }

    else if (v5 != 255)
    {
      uint64_t v7 = *((void *)a1 + 1);
      uint64_t v8 = *((void *)a2 + 1);
      if ((v4 & 1) != 0)
      {
        if ((v5 & 1) != 0)
        {
          uint64_t v9 = *((void *)a1 + 3);
          uint64_t v15 = *((void *)a1 + 2);
          uint64_t v10 = *((void *)a1 + 4);
          uint64_t v11 = *((void *)a2 + 2);
          uint64_t v12 = *((void *)a2 + 3);
          uint64_t v13 = *((void *)a2 + 4);
          sub_1000BA574((uint64_t)a2, (void (*)(void, void, void, void, void))sub_1000BA5AC);
          sub_1000BA574((uint64_t)a1, (void (*)(void, void, void, void, void))sub_1000BA5AC);
          char v14 = _s7CoreP2P11IPv6AddressV2eeoiySbAC_ACtFZ_0(v7, v15, v9, v10, v8, v11, v12, v13);
          sub_1000BA574((uint64_t)a2, (void (*)(void, void, void, void, void))sub_100056B0C);
          sub_1000BA574((uint64_t)a1, (void (*)(void, void, void, void, void))sub_100056B0C);
          if ((v14 & 1) != 0) {
            return 1LL;
          }
        }
      }

      else if ((v5 & 1) == 0 && (_DWORD)v7 == (_DWORD)v8)
      {
        return 1LL;
      }
    }
  }

  return 0LL;
}

unint64_t sub_1000B9D08()
{
  unint64_t result = qword_100407058;
  if (!qword_100407058)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for InfraScanStartEvent,  &type metadata for InfraScanStartEvent);
    atomic_store(result, (unint64_t *)&qword_100407058);
  }

  return result;
}

unint64_t sub_1000B9D50()
{
  unint64_t result = qword_100407060;
  if (!qword_100407060)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for InfraScanCompleteEvent,  &type metadata for InfraScanCompleteEvent);
    atomic_store(result, (unint64_t *)&qword_100407060);
  }

  return result;
}

unint64_t sub_1000B9D98()
{
  unint64_t result = qword_100407068;
  if (!qword_100407068)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for InfraAssociationStartEvent,  &type metadata for InfraAssociationStartEvent);
    atomic_store(result, (unint64_t *)&qword_100407068);
  }

  return result;
}

unint64_t sub_1000B9DE0()
{
  unint64_t result = qword_100407070;
  if (!qword_100407070)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for InfraAssociationJoinStatus.SubstateInformation,  &type metadata for InfraAssociationJoinStatus.SubstateInformation);
    atomic_store(result, (unint64_t *)&qword_100407070);
  }

  return result;
}

unint64_t sub_1000B9E28()
{
  unint64_t result = qword_100407078;
  if (!qword_100407078)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for InfraAssociationJoinStatus,  &type metadata for InfraAssociationJoinStatus);
    atomic_store(result, (unint64_t *)&qword_100407078);
  }

  return result;
}

unint64_t sub_1000B9E70()
{
  unint64_t result = qword_100407080;
  if (!qword_100407080)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for InfraAssociationReadyEvent,  &type metadata for InfraAssociationReadyEvent);
    atomic_store(result, (unint64_t *)&qword_100407080);
  }

  return result;
}

ValueMetadata *type metadata accessor for InfraScanStartEvent()
{
  return &type metadata for InfraScanStartEvent;
}

ValueMetadata *type metadata accessor for InfraScanCompleteEvent()
{
  return &type metadata for InfraScanCompleteEvent;
}

uint64_t initializeBufferWithCopyOfBuffer for Channel(uint64_t result, int *a2)
{
  int v2 = *a2;
  *(_WORD *)(result + 4)  = *((_WORD *)a2 + 2);
  *(_DWORD *)unint64_t result = v2;
  return result;
}

uint64_t getEnumTagSinglePayload for Channel(uint64_t a1, unsigned int a2)
{
  if (!a2) {
    return 0LL;
  }
  if (a2 >= 0xFE && *(_BYTE *)(a1 + 6)) {
    return (*(_DWORD *)a1 + 254);
  }
  unsigned int v3 = *(unsigned __int8 *)(a1 + 4);
  BOOL v4 = v3 >= 3;
  int v5 = v3 - 3;
  if (!v4) {
    int v5 = -1;
  }
  return (v5 + 1);
}

uint64_t storeEnumTagSinglePayload for Channel(uint64_t result, unsigned int a2, unsigned int a3)
{
  if (a2 > 0xFD)
  {
    *(_WORD *)(result + 4)  = 0;
    *(_DWORD *)unint64_t result = a2 - 254;
    if (a3 >= 0xFE) {
      *(_BYTE *)(result + 6)  = 1;
    }
  }

  else
  {
    if (a3 >= 0xFE) {
      *(_BYTE *)(result + 6)  = 0;
    }
    if (a2) {
      *(_BYTE *)(result + 4)  = a2 + 2;
    }
  }

  return result;
}

ValueMetadata *type metadata accessor for InfraAssociationStartEvent()
{
  return &type metadata for InfraAssociationStartEvent;
}

uint64_t destroy for NANAttribute.RangingSetup(uint64_t a1)
{
  return swift_bridgeObjectRelease(*(void *)(a1 + 16));
}

uint64_t initializeWithCopy for InfraAssociationJoinStatus(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)a1  = *(_DWORD *)a2;
  *(_WORD *)(a1 + 4)  = *(_WORD *)(a2 + 4);
  *(void *)(a1 + 8)  = *(void *)(a2 + 8);
  uint64_t v3 = *(void *)(a2 + 16);
  *(void *)(a1 + 16)  = v3;
  *(_DWORD *)(a1 + 24)  = *(_DWORD *)(a2 + 24);
  swift_bridgeObjectRetain(v3);
  return a1;
}

uint64_t assignWithCopy for InfraAssociationJoinStatus(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)a1  = *(_BYTE *)a2;
  *(_BYTE *)(a1 + 1)  = *(_BYTE *)(a2 + 1);
  *(_BYTE *)(a1 + 2)  = *(_BYTE *)(a2 + 2);
  *(_BYTE *)(a1 + 3)  = *(_BYTE *)(a2 + 3);
  *(_BYTE *)(a1 + 4)  = *(_BYTE *)(a2 + 4);
  *(_BYTE *)(a1 + 5)  = *(_BYTE *)(a2 + 5);
  *(_DWORD *)(a1 + 8)  = *(_DWORD *)(a2 + 8);
  *(_DWORD *)(a1 + 12)  = *(_DWORD *)(a2 + 12);
  uint64_t v4 = *(void *)(a2 + 16);
  uint64_t v5 = *(void *)(a1 + 16);
  *(void *)(a1 + 16)  = v4;
  swift_bridgeObjectRetain(v4);
  swift_bridgeObjectRelease(v5);
  *(_DWORD *)(a1 + 24)  = *(_DWORD *)(a2 + 24);
  return a1;
}

__n128 initializeWithTake for InfraAssociationJoinStatus(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)a2;
  *(_OWORD *)(a1 + 12)  = *(_OWORD *)(a2 + 12);
  *(__n128 *)a1  = result;
  return result;
}

uint64_t assignWithTake for InfraAssociationJoinStatus(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)a1  = *(_DWORD *)a2;
  *(_WORD *)(a1 + 4)  = *(_WORD *)(a2 + 4);
  *(void *)(a1 + 8)  = *(void *)(a2 + 8);
  uint64_t v4 = *(void *)(a1 + 16);
  *(void *)(a1 + 16)  = *(void *)(a2 + 16);
  swift_bridgeObjectRelease(v4);
  *(_DWORD *)(a1 + 24)  = *(_DWORD *)(a2 + 24);
  return a1;
}

uint64_t getEnumTagSinglePayload for InfraAssociationJoinStatus(uint64_t a1, int a2)
{
  if (!a2) {
    return 0LL;
  }
  if (a2 < 0 && *(_BYTE *)(a1 + 28)) {
    return *(_DWORD *)a1 + 0x80000000;
  }
  unint64_t v2 = *(void *)(a1 + 16);
  if (v2 >= 0xFFFFFFFF) {
    LODWORD(v2)  = -1;
  }
  return (v2 + 1);
}

uint64_t storeEnumTagSinglePayload for InfraAssociationJoinStatus(uint64_t result, int a2, int a3)
{
  if (a2 < 0)
  {
    *(void *)(result + 8)  = 0LL;
    *(void *)(result + 16)  = 0LL;
    *(_DWORD *)(result + 24)  = 0;
    *(void *)__n128 result = a2 ^ 0x80000000;
    if (a3 < 0) {
      *(_BYTE *)(result + 28)  = 1;
    }
  }

  else
  {
    if ((a3 & 0x80000000) == 0)
    {
      if (!a2) {
        return result;
      }
LABEL_8:
      *(void *)(result + 16)  = (a2 - 1);
      return result;
    }

    *(_BYTE *)(result + 28)  = 0;
    if (a2) {
      goto LABEL_8;
    }
  }

  return result;
}

ValueMetadata *type metadata accessor for InfraAssociationJoinStatus()
{
  return &type metadata for InfraAssociationJoinStatus;
}

void *initializeBufferWithCopyOfBuffer for NANDataEstablishedEvent(void *result, uint64_t *a2)
{
  uint64_t v2 = *a2;
  *(void *)((char *)result + 6)  = *(uint64_t *)((char *)a2 + 6);
  *__n128 result = v2;
  return result;
}

uint64_t getEnumTagSinglePayload for InfraAssociationJoinStatus.SubstateInformation( uint64_t a1, unsigned int a2)
{
  if (!a2) {
    return 0LL;
  }
  if (a2 >= 0xDE && *(_BYTE *)(a1 + 14)) {
    return (*(_DWORD *)a1 + 222);
  }
  else {
    int v3 = *(unsigned __int8 *)(a1 + 7);
  }
  int v4 = v3 - 35;
  else {
    int v5 = v4;
  }
  return (v5 + 1);
}

uint64_t storeEnumTagSinglePayload for InfraAssociationJoinStatus.SubstateInformation( uint64_t result, unsigned int a2, unsigned int a3)
{
  if (a2 > 0xDD)
  {
    *(_WORD *)(result + 12)  = 0;
    *(_DWORD *)(result + 8)  = 0;
    *(void *)__n128 result = a2 - 222;
    if (a3 >= 0xDE) {
      *(_BYTE *)(result + 14)  = 1;
    }
  }

  else
  {
    if (a3 >= 0xDE) {
      *(_BYTE *)(result + 14)  = 0;
    }
    if (a2) {
      *(_BYTE *)(result + 7)  = a2 + 34;
    }
  }

  return result;
}

ValueMetadata *type metadata accessor for InfraAssociationJoinStatus.SubstateInformation()
{
  return &type metadata for InfraAssociationJoinStatus.SubstateInformation;
}

uint64_t destroy for InfraAssociationReadyEvent(uint64_t result)
{
  int v1 = *(unsigned __int8 *)(result + 40);
  if (v1 != 255) {
    return sub_100056B24( *(void *)(result + 8),  *(void *)(result + 16),  *(void *)(result + 24),  *(void *)(result + 32),  v1 & 1);
  }
  return result;
}

uint64_t initializeWithCopy for InfraAssociationReadyEvent(uint64_t a1, uint64_t a2)
{
  *(_WORD *)a1  = *(_WORD *)a2;
  int v3 = *(unsigned __int8 *)(a2 + 40);
  if (v3 == 255)
  {
    __int128 v4 = *(_OWORD *)(a2 + 24);
    *(_OWORD *)(a1 + 8)  = *(_OWORD *)(a2 + 8);
    *(_OWORD *)(a1 + 24)  = v4;
    *(_BYTE *)(a1 + 40)  = *(_BYTE *)(a2 + 40);
  }

  else
  {
    char v5 = v3 & 1;
    uint64_t v6 = *(void *)(a2 + 8);
    uint64_t v7 = *(void *)(a2 + 16);
    uint64_t v8 = *(void *)(a2 + 24);
    uint64_t v9 = *(void *)(a2 + 32);
    sub_100057070(v6, v7, v8, v9, v3 & 1);
    *(void *)(a1 + 8)  = v6;
    *(void *)(a1 + 16)  = v7;
    *(void *)(a1 + 24)  = v8;
    *(void *)(a1 + 32)  = v9;
    *(_BYTE *)(a1 + 40)  = v5;
  }

  return a1;
}

uint64_t assignWithCopy for InfraAssociationReadyEvent(uint64_t a1, uint64_t a2)
{
  *(_WORD *)a1  = *(_WORD *)a2;
  uint64_t v3 = a1 + 8;
  __int128 v4 = (__int128 *)(a2 + 8);
  int v5 = *(unsigned __int8 *)(a2 + 40);
  if (*(unsigned __int8 *)(a1 + 40) == 255)
  {
    if (v5 == 255)
    {
      __int128 v8 = *v4;
      __int128 v9 = *(_OWORD *)(a2 + 24);
      *(_BYTE *)(a1 + 40)  = *(_BYTE *)(a2 + 40);
      *(_OWORD *)uint64_t v3 = v8;
      *(_OWORD *)(a1 + 24)  = v9;
    }

    else
    {
      char v20 = v5 & 1;
      uint64_t v21 = *(void *)(a2 + 8);
      uint64_t v22 = *(void *)(a2 + 16);
      uint64_t v23 = *(void *)(a2 + 24);
      uint64_t v24 = *(void *)(a2 + 32);
      sub_100057070(v21, v22, v23, v24, v5 & 1);
      *(void *)(a1 + 8)  = v21;
      *(void *)(a1 + 16)  = v22;
      *(void *)(a1 + 24)  = v23;
      *(void *)(a1 + 32)  = v24;
      *(_BYTE *)(a1 + 40)  = v20;
    }
  }

  else if (v5 == 255)
  {
    sub_1000BA3DC(a1 + 8);
    char v6 = *((_BYTE *)v4 + 32);
    __int128 v7 = v4[1];
    *(_OWORD *)uint64_t v3 = *v4;
    *(_OWORD *)(v3 + 16)  = v7;
    *(_BYTE *)(v3 + 32)  = v6;
  }

  else
  {
    char v10 = v5 & 1;
    uint64_t v11 = *(void *)(a2 + 8);
    uint64_t v12 = *(void *)(a2 + 16);
    uint64_t v13 = *(void *)(a2 + 24);
    uint64_t v14 = *(void *)(a2 + 32);
    sub_100057070(v11, v12, v13, v14, v5 & 1);
    uint64_t v15 = *(void *)(a1 + 8);
    uint64_t v16 = *(void *)(a1 + 16);
    uint64_t v17 = *(void *)(a1 + 24);
    uint64_t v18 = *(void *)(a1 + 32);
    char v19 = *(_BYTE *)(a1 + 40);
    *(void *)(a1 + 8)  = v11;
    *(void *)(a1 + 16)  = v12;
    *(void *)(a1 + 24)  = v13;
    *(void *)(a1 + 32)  = v14;
    *(_BYTE *)(a1 + 40)  = v10;
    sub_100056B24(v15, v16, v17, v18, v19);
  }

  return a1;
}

uint64_t sub_1000BA3DC(uint64_t a1)
{
  uint64_t v2 = sub_100002274(&qword_100405D50);
  (*(void (**)(uint64_t, uint64_t))(*(void *)(v2 - 8) + 8LL))(a1, v2);
  return a1;
}

__n128 initializeWithTake for NANAttribute.WLANInfrastructure(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)a2;
  __int128 v3 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)(a1 + 25)  = *(_OWORD *)(a2 + 25);
  *(__n128 *)a1  = result;
  *(_OWORD *)(a1 + 16)  = v3;
  return result;
}

uint64_t assignWithTake for InfraAssociationReadyEvent(uint64_t a1, uint64_t a2)
{
  *(_WORD *)a1  = *(_WORD *)a2;
  uint64_t v3 = a1 + 8;
  uint64_t v4 = a2 + 8;
  int v5 = *(unsigned __int8 *)(a1 + 40);
  if (v5 != 255)
  {
    int v6 = *(unsigned __int8 *)(a2 + 40);
    if (v6 != 255)
    {
      char v8 = v5 & 1;
      uint64_t v9 = *(void *)(a1 + 8);
      uint64_t v10 = *(void *)(a1 + 16);
      uint64_t v11 = *(void *)(a1 + 24);
      uint64_t v12 = *(void *)(a1 + 32);
      *(_OWORD *)(a1 + 8)  = *(_OWORD *)(a2 + 8);
      *(_OWORD *)(a1 + 24)  = *(_OWORD *)(a2 + 24);
      *(_BYTE *)(a1 + 40)  = v6 & 1;
      sub_100056B24(v9, v10, v11, v12, v8);
      return a1;
    }

    sub_1000BA3DC(a1 + 8);
  }

  __int128 v7 = *(_OWORD *)(v4 + 16);
  *(_OWORD *)uint64_t v3 = *(_OWORD *)v4;
  *(_OWORD *)(v3 + 16)  = v7;
  *(_BYTE *)(v3 + 32)  = *(_BYTE *)(v4 + 32);
  return a1;
}

uint64_t getEnumTagSinglePayload for InfraAssociationReadyEvent(uint64_t a1, unsigned int a2)
{
  if (!a2) {
    return 0LL;
  }
  if (a2 >= 0xFE && *(_BYTE *)(a1 + 41)) {
    return (*(_DWORD *)a1 + 254);
  }
  unsigned int v3 = *(unsigned __int8 *)(a1 + 40);
  if (v3 <= 1) {
    int v4 = -1;
  }
  else {
    int v4 = (v3 ^ 0xFF) - 1;
  }
  return (v4 + 1);
}

uint64_t storeEnumTagSinglePayload for InfraAssociationReadyEvent( uint64_t result, unsigned int a2, unsigned int a3)
{
  if (a2 > 0xFD)
  {
    *(_OWORD *)(result + 24)  = 0u;
    *(_OWORD *)(result + 8)  = 0u;
    *(_BYTE *)(result + 40)  = 0;
    *(void *)__n128 result = a2 - 254;
    if (a3 >= 0xFE) {
      *(_BYTE *)(result + 41)  = 1;
    }
  }

  else
  {
    if (a3 >= 0xFE) {
      *(_BYTE *)(result + 41)  = 0;
    }
    if (a2) {
      *(_BYTE *)(result + 40)  = ~(_BYTE)a2;
    }
  }

  return result;
}

ValueMetadata *type metadata accessor for InfraAssociationReadyEvent()
{
  return &type metadata for InfraAssociationReadyEvent;
}

uint64_t sub_1000BA574(uint64_t a1, void (*a2)(void, void, void, void, void))
{
  return a1;
}

uint64_t sub_1000BA5AC(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, unsigned __int8 a5)
{
  if (a5 != 255) {
    return sub_100057070(result, a2, a3, a4, a5 & 1);
  }
  return result;
}

BOOL sub_1000BA5C4(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = type metadata accessor for DispatchTimeInterval(0LL);
  uint64_t v5 = *(void *)(v4 - 8);
  __chkstk_darwin(v4);
  __int128 v7 = (char *)&v15 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v8 = enum case for DispatchTimeInterval.never(_:);
  uint64_t v9 = *(void (**)(char *, uint64_t, uint64_t))(v5 + 104);
  v9(v7, enum case for DispatchTimeInterval.never(_:), v4);
  char v10 = static DispatchTimeInterval.== infix(_:_:)(a1, v7);
  uint64_t v11 = *(void (**)(char *, uint64_t))(v5 + 8);
  v11(v7, v4);
  if ((v10 & 1) != 0) {
    return 1LL;
  }
  v9(v7, v8, v4);
  char v13 = static DispatchTimeInterval.== infix(_:_:)(a2, v7);
  v11(v7, v4);
  if ((v13 & 1) != 0) {
    return 0LL;
  }
  uint64_t v14 = sub_100172848();
  return v14 >= sub_100172848();
}

uint64_t sub_1000BA6D4(char a1, unsigned __int8 a2)
{
  int v4 = a2;
  uint64_t v5 = sub_100002274(&qword_100407088);
  if (v4 == 2) {
    return 1LL;
  }
  if (a1 == 2) {
    return 0LL;
  }
  if (a2 == 3) {
    return 1LL;
  }
  if (a1 == 3) {
    return 0LL;
  }
  if (a2 == 4) {
    return 1LL;
  }
  if (a1 == 4) {
    return 0LL;
  }
  if (a2 == 5) {
    return 1LL;
  }
  if (a1 == 5) {
    return 0LL;
  }
  if (a2 == 6) {
    return 1LL;
  }
  if (a1 == 6) {
    return 0LL;
  }
  uint64_t result = _diagnoseUnexpectedEnumCase<A>(type:)(v5, v5);
  __break(1u);
  return result;
}

BOOL sub_1000BA7E0(uint64_t a1, uint64_t a2)
{
  if ((a1 & 0x100000000LL) != 0) {
    LODWORD(a1)  = dword_1003404B0[(int)a1];
  }
  if ((a2 & 0x100000000LL) != 0) {
    LODWORD(a2)  = dword_1003404B0[(int)a2];
  }
  return a1 >= a2;
}

void sub_1000BA80C()
{
  static Bandwidth.allCases  = (uint64_t)&off_1003D6F90;
}

uint64_t *Bandwidth.allCases.unsafeMutableAddressor()
{
  if (qword_100404150 != -1) {
    swift_once(&qword_100404150, sub_1000BA80C);
  }
  return &static Bandwidth.allCases;
}

uint64_t static Bandwidth.allCases.getter()
{
  if (qword_100404150 != -1) {
    swift_once(&qword_100404150, sub_1000BA80C);
  }
  swift_beginAccess(&static Bandwidth.allCases, v1, 0LL, 0LL);
  return swift_bridgeObjectRetain(static Bandwidth.allCases);
}

uint64_t static Bandwidth.allCases.setter(uint64_t a1)
{
  if (qword_100404150 != -1) {
    swift_once(&qword_100404150, sub_1000BA80C);
  }
  swift_beginAccess(&static Bandwidth.allCases, v4, 1LL, 0LL);
  uint64_t v2 = static Bandwidth.allCases;
  static Bandwidth.allCases  = a1;
  return swift_bridgeObjectRelease(v2);
}

uint64_t (*static Bandwidth.allCases.modify(uint64_t a1))(void)
{
  if (qword_100404150 != -1) {
    swift_once(&qword_100404150, sub_1000BA80C);
  }
  swift_beginAccess(&static Bandwidth.allCases, a1, 33LL, 0LL);
  return j__swift_endAccess;
}

uint64_t Bandwidth.suffix.getter(unsigned __int8 a1)
{
  int v1 = a1;
  uint64_t result = 0LL;
  switch(v1)
  {
    case 2:
    case 3:
      return result;
    case 4:
      uint64_t result = 11051LL;
      break;
    case 5:
      uint64_t result = 30840LL;
      break;
    case 6:
      uint64_t result = 31097LL;
      break;
    default:
      if ((v1 & 1) != 0) {
        uint64_t result = 43LL;
      }
      else {
        uint64_t result = 45LL;
      }
      break;
  }

  return result;
}

uint64_t Bandwidth.description.getter(unsigned __int8 a1)
{
  int v1 = a1;
  uint64_t result = 0x7A484D203031LL;
  switch(v1)
  {
    case 2:
      return result;
    case 3:
      uint64_t result = 0x7A484D203032LL;
      break;
    case 4:
      uint64_t result = 0x7A484D203038LL;
      break;
    case 5:
      uint64_t result = 0x7A484D20303631LL;
      break;
    case 6:
      uint64_t result = 0x7A484D20303233LL;
      break;
    default:
      if ((v1 & 1) != 0) {
        uint64_t result = 0x7A484D202B3034LL;
      }
      else {
        uint64_t result = 0x7A484D202D3034LL;
      }
      break;
  }

  return result;
}

uint64_t Bandwidth.updateWithFloor(bandwidth:)(unsigned __int8 a1)
{
  int v3 = *v1;
  uint64_t result = sub_100002274(&qword_100407088);
  if (v3 == 2) {
    goto LABEL_5;
  }
  if (a1 == 2) {
    goto LABEL_3;
  }
  if (v3 == 3) {
    goto LABEL_5;
  }
  if (a1 == 3) {
    goto LABEL_3;
  }
  if (v3 == 4) {
    goto LABEL_5;
  }
  if (a1 == 4) {
    goto LABEL_3;
  }
  if (v3 == 5) {
    goto LABEL_5;
  }
  if (a1 == 5)
  {
LABEL_3:
    a1  = v3;
LABEL_5:
    unsigned __int8 *v1 = a1;
    return result;
  }

  if (v3 == 6) {
    goto LABEL_5;
  }
  int v5 = a1;
  a1  = v3;
  if (v5 == 6) {
    goto LABEL_5;
  }
  uint64_t result = _diagnoseUnexpectedEnumCase<A>(type:)(result, result);
  __break(1u);
  return result;
}

void Bandwidth.hash(into:)(uint64_t a1, char a2)
{
  switch(a2)
  {
    case 2:
      Swift::UInt v2 = 0LL;
      goto LABEL_8;
    case 3:
      Swift::UInt v2 = 1LL;
      goto LABEL_8;
    case 4:
      Swift::UInt v2 = 3LL;
      goto LABEL_8;
    case 5:
      Swift::UInt v2 = 4LL;
      goto LABEL_8;
    case 6:
      Swift::UInt v2 = 5LL;
LABEL_8:
      Hasher._combine(_:)(v2);
      break;
    default:
      Swift::UInt8 v3 = a2 & 1;
      Hasher._combine(_:)(2uLL);
      Hasher._combine(_:)(v3);
      break;
  }

uint64_t static Bandwidth.__derived_enum_equals(_:_:)(char a1, unsigned __int8 a2)
{
  switch(a1)
  {
    case 2:
      if (a2 != 2) {
        goto LABEL_13;
      }
      goto LABEL_11;
    case 3:
      if (a2 != 3) {
        goto LABEL_13;
      }
      goto LABEL_11;
    case 4:
      if (a2 != 4) {
        goto LABEL_13;
      }
      goto LABEL_11;
    case 5:
      if (a2 != 5) {
        goto LABEL_13;
      }
      goto LABEL_11;
    case 6:
      if (a2 != 6) {
        goto LABEL_13;
      }
LABEL_11:
      uint64_t result = 1LL;
      break;
    default:
      else {
LABEL_13:
      }
        uint64_t result = 0LL;
      break;
  }

  return result;
}

uint64_t sub_1000BACD0()
{
  return ((uint64_t (*)(uint64_t, unint64_t))((char *)sub_1000BACFC + 4 * byte_10033FCE4[*v0]))( 0x7A484D6E6574LL,  0xE600000000000000LL);
}

uint64_t sub_1000BACFC()
{
  return 0x484D79746E657774LL;
}

uint64_t sub_1000BAD3C()
{
  return 0x7974786953656E6FLL;
}

uint64_t sub_1000BAD5C()
{
  return 0x6577546565726874LL;
}

uint64_t sub_1000BAD80@<X0>(uint64_t a1@<X0>, unint64_t a2@<X1>, _BYTE *a3@<X8>)
{
  uint64_t result = sub_1000BCB28(a1, a2);
  *a3  = result;
  return result;
}

void sub_1000BADA4(_BYTE *a1@<X8>)
{
  *a1  = 6;
}

uint64_t sub_1000BADB0(uint64_t a1)
{
  unint64_t v2 = sub_1000BB9A8();
  return CodingKey.description.getter(a1, v2);
}

uint64_t sub_1000BADD8(uint64_t a1)
{
  unint64_t v2 = sub_1000BB9A8();
  return CodingKey.debugDescription.getter(a1, v2);
}

uint64_t sub_1000BAE00(uint64_t a1)
{
  unint64_t v2 = sub_1000BBA74();
  return CodingKey.description.getter(a1, v2);
}

uint64_t sub_1000BAE28(uint64_t a1)
{
  unint64_t v2 = sub_1000BBA74();
  return CodingKey.debugDescription.getter(a1, v2);
}

unint64_t sub_1000BAE50()
{
  return 0xD000000000000015LL;
}

uint64_t sub_1000BAE6C@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, _BYTE *a3@<X8>)
{
  uint64_t result = sub_1000BCDF4(a1, a2);
  *a3  = result & 1;
  return result;
}

uint64_t sub_1000BAE94(uint64_t a1)
{
  unint64_t v2 = sub_1000BBAB8();
  return CodingKey.description.getter(a1, v2);
}

uint64_t sub_1000BAEBC(uint64_t a1)
{
  unint64_t v2 = sub_1000BBAB8();
  return CodingKey.debugDescription.getter(a1, v2);
}

uint64_t sub_1000BAEE4(uint64_t a1)
{
  unint64_t v2 = sub_1000BBA30();
  return CodingKey.description.getter(a1, v2);
}

uint64_t sub_1000BAF0C(uint64_t a1)
{
  unint64_t v2 = sub_1000BBA30();
  return CodingKey.debugDescription.getter(a1, v2);
}

uint64_t sub_1000BAF34(uint64_t a1)
{
  unint64_t v2 = sub_1000BBB40();
  return CodingKey.description.getter(a1, v2);
}

uint64_t sub_1000BAF5C(uint64_t a1)
{
  unint64_t v2 = sub_1000BBB40();
  return CodingKey.debugDescription.getter(a1, v2);
}

uint64_t sub_1000BAF84(uint64_t a1)
{
  unint64_t v2 = sub_1000BB9EC();
  return CodingKey.description.getter(a1, v2);
}

uint64_t sub_1000BAFAC(uint64_t a1)
{
  unint64_t v2 = sub_1000BB9EC();
  return CodingKey.debugDescription.getter(a1, v2);
}

uint64_t sub_1000BAFD4(uint64_t a1)
{
  unint64_t v2 = sub_1000BBAFC();
  return CodingKey.description.getter(a1, v2);
}

uint64_t sub_1000BAFFC(uint64_t a1)
{
  unint64_t v2 = sub_1000BBAFC();
  return CodingKey.debugDescription.getter(a1, v2);
}

uint64_t Bandwidth.encode(to:)(void *a1, unsigned __int8 a2)
{
  int v55 = a2;
  uint64_t v3 = sub_100002274(&qword_100407090);
  uint64_t v51 = *(void *)(v3 - 8);
  uint64_t v52 = v3;
  __chkstk_darwin(v3);
  uint64_t v50 = (char *)&v39 - ((v4 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v5 = sub_100002274(&qword_100407098);
  uint64_t v48 = *(void *)(v5 - 8);
  uint64_t v49 = v5;
  __chkstk_darwin(v5);
  unint64_t v47 = (char *)&v39 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v7 = sub_100002274(&qword_1004070A0);
  uint64_t v45 = *(void *)(v7 - 8);
  uint64_t v46 = v7;
  __chkstk_darwin(v7);
  uint64_t v44 = (char *)&v39 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v9 = sub_100002274(&qword_1004070A8);
  uint64_t v42 = *(void *)(v9 - 8);
  uint64_t v43 = v9;
  __chkstk_darwin(v9);
  uint64_t v11 = (char *)&v39 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v12 = sub_100002274(&qword_1004070B0);
  uint64_t v40 = *(void *)(v12 - 8);
  uint64_t v41 = v12;
  __chkstk_darwin(v12);
  uint64_t v14 = (char *)&v39 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v15 = sub_100002274(&qword_1004070B8);
  uint64_t v16 = *(void *)(v15 - 8);
  __chkstk_darwin(v15);
  uint64_t v18 = (char *)&v39 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v19 = sub_100002274(&qword_1004070C0);
  uint64_t v53 = *(void *)(v19 - 8);
  uint64_t v54 = v19;
  __chkstk_darwin(v19);
  uint64_t v21 = (char *)&v39 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v22 = a1[3];
  uint64_t v23 = a1[4];
  sub_100021104(a1, v22);
  unint64_t v24 = sub_1000BB9A8();
  dispatch thunk of Encoder.container<A>(keyedBy:)( &type metadata for Bandwidth.CodingKeys,  &type metadata for Bandwidth.CodingKeys,  v24,  v22,  v23);
  switch(v55)
  {
    case 2:
      char v56 = 0;
      unint64_t v25 = sub_1000BBB40();
      uint64_t v26 = v54;
      KeyedEncodingContainer.nestedContainer<A>(keyedBy:forKey:)( &type metadata for Bandwidth.TenMHzCodingKeys,  &v56,  v54,  &type metadata for Bandwidth.TenMHzCodingKeys,  v25);
      (*(void (**)(char *, uint64_t))(v16 + 8))(v18, v15);
      goto LABEL_9;
    case 3:
      char v57 = 1;
      unint64_t v32 = sub_1000BBAFC();
      uint64_t v26 = v54;
      KeyedEncodingContainer.nestedContainer<A>(keyedBy:forKey:)( &type metadata for Bandwidth.TwentyMHzCodingKeys,  &v57,  v54,  &type metadata for Bandwidth.TwentyMHzCodingKeys,  v32);
      (*(void (**)(char *, uint64_t))(v40 + 8))(v14, v41);
      goto LABEL_9;
    case 4:
      char v59 = 3;
      unint64_t v33 = sub_1000BBA74();
      uint64_t v34 = v44;
      uint64_t v26 = v54;
      KeyedEncodingContainer.nestedContainer<A>(keyedBy:forKey:)( &type metadata for Bandwidth.EightyMHzCodingKeys,  &v59,  v54,  &type metadata for Bandwidth.EightyMHzCodingKeys,  v33);
      uint64_t v36 = v45;
      uint64_t v35 = v46;
      goto LABEL_8;
    case 5:
      char v60 = 4;
      unint64_t v37 = sub_1000BBA30();
      uint64_t v34 = v47;
      uint64_t v26 = v54;
      KeyedEncodingContainer.nestedContainer<A>(keyedBy:forKey:)( &type metadata for Bandwidth.OneSixtyMHzCodingKeys,  &v60,  v54,  &type metadata for Bandwidth.OneSixtyMHzCodingKeys,  v37);
      uint64_t v36 = v48;
      uint64_t v35 = v49;
      goto LABEL_8;
    case 6:
      char v61 = 5;
      unint64_t v38 = sub_1000BB9EC();
      uint64_t v34 = v50;
      uint64_t v26 = v54;
      KeyedEncodingContainer.nestedContainer<A>(keyedBy:forKey:)( &type metadata for Bandwidth.ThreeTwentyMHzCodingKeys,  &v61,  v54,  &type metadata for Bandwidth.ThreeTwentyMHzCodingKeys,  v38);
      uint64_t v36 = v51;
      uint64_t v35 = v52;
LABEL_8:
      (*(void (**)(char *, uint64_t))(v36 + 8))(v34, v35);
LABEL_9:
      uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v53 + 8))(v21, v26);
      break;
    default:
      uint64_t v27 = v55 & 1;
      char v58 = 2;
      unint64_t v28 = sub_1000BBAB8();
      uint64_t v29 = v54;
      KeyedEncodingContainer.nestedContainer<A>(keyedBy:forKey:)( &type metadata for Bandwidth.FortyMHzCodingKeys,  &v58,  v54,  &type metadata for Bandwidth.FortyMHzCodingKeys,  v28);
      uint64_t v30 = v43;
      KeyedEncodingContainer.encode(_:forKey:)(v27);
      (*(void (**)(char *, uint64_t))(v42 + 8))(v11, v30);
      uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v53 + 8))(v21, v29);
      break;
  }

  return result;
}

Swift::Int Bandwidth.hashValue.getter(char a1)
{
  switch(a1)
  {
    case 2:
      Swift::UInt v2 = 0LL;
      goto LABEL_8;
    case 3:
      Swift::UInt v2 = 1LL;
      goto LABEL_8;
    case 4:
      Swift::UInt v2 = 3LL;
      goto LABEL_8;
    case 5:
      Swift::UInt v2 = 4LL;
      goto LABEL_8;
    case 6:
      Swift::UInt v2 = 5LL;
LABEL_8:
      Hasher._combine(_:)(v2);
      break;
    default:
      Hasher._combine(_:)(2uLL);
      Hasher._combine(_:)(a1 & 1);
      break;
  }

  return Hasher._finalize()();
}

uint64_t Bandwidth.init(from:)(void *a1)
{
  return sub_1000BBB84(a1);
}

Swift::Int sub_1000BB53C()
{
  return Bandwidth.hashValue.getter(*v0);
}

void sub_1000BB544()
{
  switch(*v0)
  {
    case 2:
      Swift::UInt v1 = 0LL;
      goto LABEL_8;
    case 3:
      Swift::UInt v1 = 1LL;
      goto LABEL_8;
    case 4:
      Swift::UInt v1 = 3LL;
      goto LABEL_8;
    case 5:
      Swift::UInt v1 = 4LL;
      goto LABEL_8;
    case 6:
      Swift::UInt v1 = 5LL;
LABEL_8:
      Hasher._combine(_:)(v1);
      break;
    default:
      Swift::UInt8 v2 = *v0 & 1;
      Hasher._combine(_:)(2uLL);
      Hasher._combine(_:)(v2);
      break;
  }

Swift::Int sub_1000BB5CC(uint64_t a1)
{
  int v2 = *v1;
  Hasher.init(_seed:)(v5, a1);
  switch(v2)
  {
    case 2:
      Swift::UInt v3 = 0LL;
      goto LABEL_8;
    case 3:
      Swift::UInt v3 = 1LL;
      goto LABEL_8;
    case 4:
      Swift::UInt v3 = 3LL;
      goto LABEL_8;
    case 5:
      Swift::UInt v3 = 4LL;
      goto LABEL_8;
    case 6:
      Swift::UInt v3 = 5LL;
LABEL_8:
      Hasher._combine(_:)(v3);
      break;
    default:
      Hasher._combine(_:)(2uLL);
      Hasher._combine(_:)(v2 & 1);
      break;
  }

  return Hasher._finalize()();
}

uint64_t sub_1000BB680@<X0>(void *a1@<X8>)
{
  if (qword_100404150 != -1) {
    swift_once(&qword_100404150, sub_1000BA80C);
  }
  swift_beginAccess(&static Bandwidth.allCases, v4, 0LL, 0LL);
  uint64_t v2 = static Bandwidth.allCases;
  *a1  = static Bandwidth.allCases;
  return swift_bridgeObjectRetain(v2);
}

uint64_t sub_1000BB6F4()
{
  uint64_t result = 0x7A484D203031LL;
  switch(*v0)
  {
    case 2:
      return result;
    case 3:
      uint64_t result = 0x7A484D203032LL;
      break;
    case 4:
      uint64_t result = 0x7A484D203038LL;
      break;
    case 5:
      uint64_t result = 0x7A484D20303631LL;
      break;
    case 6:
      uint64_t result = 0x7A484D20303233LL;
      break;
    default:
      if ((*v0 & 1) != 0) {
        uint64_t result = 0x7A484D202B3034LL;
      }
      else {
        uint64_t result = 0x7A484D202D3034LL;
      }
      break;
  }

  return result;
}

uint64_t sub_1000BB794(char *a1, unsigned __int8 *a2)
{
  return _s7CoreP2P9BandwidthO1loiySbAC_ACtFZ_0(*a1, *a2);
}

uint64_t sub_1000BB7A0(unsigned __int8 *a1, char *a2)
{
  return sub_100172640(*a1, *a2);
}

uint64_t sub_1000BB7AC(char *a1, unsigned __int8 *a2)
{
  return sub_1000BA6D4(*a1, *a2);
}

uint64_t sub_1000BB7B8(unsigned __int8 *a1, char *a2)
{
  return sub_1001443C0(*a1, *a2);
}

uint64_t sub_1000BB7C4@<X0>(void *a1@<X0>, _BYTE *a2@<X8>)
{
  uint64_t result = sub_1000BBB84(a1);
  if (!v2) {
    *a2  = result;
  }
  return result;
}

uint64_t sub_1000BB7EC(void *a1)
{
  return Bandwidth.encode(to:)(a1, *v1);
}

uint64_t sub_1000BB804(_BYTE *a1, unsigned __int8 *a2)
{
  int v2 = *a2;
  switch(*a1)
  {
    case 2:
      if (v2 == 2) {
        goto LABEL_11;
      }
      goto LABEL_13;
    case 3:
      if (v2 != 3) {
        goto LABEL_13;
      }
      goto LABEL_11;
    case 4:
      if (v2 != 4) {
        goto LABEL_13;
      }
      goto LABEL_11;
    case 5:
      if (v2 != 5) {
        goto LABEL_13;
      }
      goto LABEL_11;
    case 6:
      if (v2 != 6) {
        goto LABEL_13;
      }
LABEL_11:
      uint64_t result = 1LL;
      break;
    default:
      else {
LABEL_13:
      }
        uint64_t result = 0LL;
      break;
  }

  return result;
}

uint64_t _s7CoreP2P9BandwidthO1loiySbAC_ACtFZ_0(char a1, unsigned __int8 a2)
{
  int v4 = a2;
  uint64_t v5 = sub_100002274(&qword_100407088);
  if (v4 == 2) {
    return 0LL;
  }
  if (a1 == 2) {
    return 1LL;
  }
  if (a2 == 3) {
    return 0LL;
  }
  if (a1 == 3) {
    return 1LL;
  }
  if (a2 == 4) {
    return 0LL;
  }
  if (a1 == 4) {
    return 1LL;
  }
  if (a2 == 5) {
    return 0LL;
  }
  if (a1 == 5) {
    return 1LL;
  }
  if (a2 == 6) {
    return 0LL;
  }
  if (a1 == 6) {
    return 1LL;
  }
  uint64_t result = _diagnoseUnexpectedEnumCase<A>(type:)(v5, v5);
  __break(1u);
  return result;
}

unint64_t sub_1000BB9A8()
{
  unint64_t result = qword_1004070C8;
  if (!qword_1004070C8)
  {
    unint64_t result = swift_getWitnessTable(&unk_10034045C, &type metadata for Bandwidth.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_1004070C8);
  }

  return result;
}

unint64_t sub_1000BB9EC()
{
  unint64_t result = qword_1004070D0;
  if (!qword_1004070D0)
  {
    unint64_t result = swift_getWitnessTable(&unk_10034040C, &type metadata for Bandwidth.ThreeTwentyMHzCodingKeys);
    atomic_store(result, (unint64_t *)&qword_1004070D0);
  }

  return result;
}

unint64_t sub_1000BBA30()
{
  unint64_t result = qword_1004070D8;
  if (!qword_1004070D8)
  {
    unint64_t result = swift_getWitnessTable(&unk_1003403BC, &type metadata for Bandwidth.OneSixtyMHzCodingKeys);
    atomic_store(result, (unint64_t *)&qword_1004070D8);
  }

  return result;
}

unint64_t sub_1000BBA74()
{
  unint64_t result = qword_1004070E0;
  if (!qword_1004070E0)
  {
    unint64_t result = swift_getWitnessTable(&unk_10034036C, &type metadata for Bandwidth.EightyMHzCodingKeys);
    atomic_store(result, (unint64_t *)&qword_1004070E0);
  }

  return result;
}

unint64_t sub_1000BBAB8()
{
  unint64_t result = qword_1004070E8;
  if (!qword_1004070E8)
  {
    unint64_t result = swift_getWitnessTable(&unk_10034031C, &type metadata for Bandwidth.FortyMHzCodingKeys);
    atomic_store(result, (unint64_t *)&qword_1004070E8);
  }

  return result;
}

unint64_t sub_1000BBAFC()
{
  unint64_t result = qword_1004070F0;
  if (!qword_1004070F0)
  {
    unint64_t result = swift_getWitnessTable(&unk_1003402CC, &type metadata for Bandwidth.TwentyMHzCodingKeys);
    atomic_store(result, (unint64_t *)&qword_1004070F0);
  }

  return result;
}

unint64_t sub_1000BBB40()
{
  unint64_t result = qword_1004070F8;
  if (!qword_1004070F8)
  {
    unint64_t result = swift_getWitnessTable(&unk_10034027C, &type metadata for Bandwidth.TenMHzCodingKeys);
    atomic_store(result, (unint64_t *)&qword_1004070F8);
  }

  return result;
}

uint64_t sub_1000BBB84(void *a1)
{
  uint64_t v33 = sub_100002274(&qword_100407198);
  uint64_t v39 = *(void *)(v33 - 8);
  __chkstk_darwin(v33);
  unint64_t v38 = (char *)v28 - ((v2 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v32 = sub_100002274(&qword_1004071A0);
  v28[7]  = *(void *)(v32 - 8);
  __chkstk_darwin(v32);
  unint64_t v37 = (char *)v28 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v4 = sub_100002274(&qword_1004071A8);
  uint64_t v30 = *(void *)(v4 - 8);
  uint64_t v31 = v4;
  __chkstk_darwin(v4);
  uint64_t v36 = (char *)v28 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v29 = sub_100002274(&qword_1004071B0);
  v28[6]  = *(void *)(v29 - 8);
  __chkstk_darwin(v29);
  uint64_t v35 = (char *)v28 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v7 = sub_100002274(&qword_1004071B8);
  v28[4]  = *(void *)(v7 - 8);
  _OWORD v28[5] = v7;
  __chkstk_darwin(v7);
  uint64_t v34 = (char *)v28 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v9 = sub_100002274(&qword_1004071C0);
  uint64_t v10 = *(void *)(v9 - 8);
  __chkstk_darwin(v9);
  uint64_t v12 = (char *)v28 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v13 = sub_100002274(&qword_1004071C8);
  uint64_t v14 = *(void *)(v13 - 8);
  __chkstk_darwin(v13);
  uint64_t v16 = (char *)v28 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v17 = a1[3];
  uint64_t v18 = a1[4];
  uint64_t v40 = a1;
  sub_100021104(a1, v17);
  unint64_t v19 = sub_1000BB9A8();
  uint64_t v20 = v41;
  dispatch thunk of Decoder.container<A>(keyedBy:)( &type metadata for Bandwidth.CodingKeys,  &type metadata for Bandwidth.CodingKeys,  v19,  v17,  v18);
  if (!v20)
  {
    _BYTE v28[2] = v9;
    void v28[3] = v12;
    v28[1]  = v10;
    uint64_t v41 = v14;
    uint64_t v21 = KeyedDecodingContainer.allKeys.getter(v13);
    uint64_t v22 = v21;
    if (*(void *)(v21 + 16) == 1LL) {
      __asm { BR              X10 }
    }

    uint64_t v17 = type metadata accessor for DecodingError(0LL);
    swift_allocError(v17, &protocol witness table for DecodingError, 0LL, 0LL);
    unint64_t v24 = v23;
    sub_100002274(&qword_100406230);
    *unint64_t v24 = &type metadata for Bandwidth;
    uint64_t v25 = KeyedDecodingContainer.codingPath.getter(v13);
    DecodingError.Context.init(codingPath:debugDescription:underlyingError:)( v25,  0xD00000000000002BLL,  0x8000000100363D90LL,  0LL);
    uint64_t v26 = (*(uint64_t (**)(void *, void, uint64_t))(*(void *)(v17 - 8) + 104LL))( v24,  enum case for DecodingError.typeMismatch(_:),  v17);
    swift_willThrow(v26);
    swift_bridgeObjectRelease(v22);
    (*(void (**)(char *, uint64_t))(v41 + 8))(v16, v13);
  }

  sub_100002AC4(v40);
  return v17;
}

void sub_1000BC154()
{
  *(_BYTE *)(v7 - 65)  = 5;
  unint64_t v8 = sub_1000BB9EC();
  KeyedDecodingContainer.nestedContainer<A>(keyedBy:forKey:)( &type metadata for Bandwidth.ThreeTwentyMHzCodingKeys,  v7 - 65,  v0,  &type metadata for Bandwidth.ThreeTwentyMHzCodingKeys,  v8);
  if (v1)
  {
    swift_bridgeObjectRelease(v6);
    JUMPOUT(0x1000BBF3CLL);
  }

  (*(void (**)(uint64_t, void))(v5 + 8))(v3, *(void *)(v7 - 160));
  swift_bridgeObjectRelease(v6);
  (*(void (**)(uint64_t, uint64_t))(v4 + 8))(v2, v0);
  JUMPOUT(0x1000BC20CLL);
}

unint64_t sub_1000BC21C()
{
  unint64_t result = qword_100407100;
  if (!qword_100407100)
  {
    unint64_t result = swift_getWitnessTable(&protocol conformance descriptor for Bandwidth, &type metadata for Bandwidth);
    atomic_store(result, (unint64_t *)&qword_100407100);
  }

  return result;
}

unint64_t sub_1000BC264()
{
  unint64_t result = qword_100407108;
  if (!qword_100407108)
  {
    uint64_t v1 = sub_1000022F8(&qword_100407110);
    unint64_t result = swift_getWitnessTable(&protocol conformance descriptor for [A], v1);
    atomic_store(result, (unint64_t *)&qword_100407108);
  }

  return result;
}

uint64_t getEnumTagSinglePayload for Bandwidth(unsigned __int8 *a1, unsigned int a2)
{
  if (!a2) {
    return 0LL;
  }
  if (a2 < 0xFA)
  {
    unsigned int v6 = *a1;
    if (v6 >= 2)
    {
      unsigned int v7 = (v6 + 2147483646) & 0x7FFFFFFF;
      uint64_t result = v7 - 4;
      if (v7 > 4) {
        return result;
      }
    }

    return 0LL;
  }

  unsigned int v2 = a2 + 6;
  if (a2 + 6 >= 0xFFFF00) {
    unsigned int v3 = 4;
  }
  else {
    unsigned int v3 = 2;
  }
  if (v2 >> 8 < 0xFF) {
    unsigned int v3 = 1;
  }
  if (v2 >= 0x100) {
    uint64_t v4 = v3;
  }
  else {
    uint64_t v4 = 0LL;
  }
  return ((uint64_t (*)(void))((char *)&loc_1000BC300 + 4 * byte_10033FD0E[v4]))();
}

uint64_t storeEnumTagSinglePayload for Bandwidth(_BYTE *a1, unsigned int a2, unsigned int a3)
{
  unsigned int v3 = a3 + 6;
  if (a3 + 6 >= 0xFFFF00) {
    int v4 = 4;
  }
  else {
    int v4 = 2;
  }
  if (v3 >> 8 < 0xFF) {
    int v4 = 1;
  }
  if (v3 >= 0x100) {
    LODWORD(v5)  = v4;
  }
  else {
    LODWORD(v5)  = 0;
  }
  if (a3 >= 0xFA) {
    uint64_t v5 = v5;
  }
  else {
    uint64_t v5 = 0LL;
  }
  if (a2 <= 0xF9) {
    return ((uint64_t (*)(void))((char *)&loc_1000BC3AC + 4 * byte_10033FD18[v5]))();
  }
  *a1  = a2 + 6;
  return ((uint64_t (*)(void))((char *)sub_1000BC3E0 + 4 * byte_10033FD13[v5]))();
}

uint64_t sub_1000BC3E0(uint64_t result)
{
  *(_BYTE *)(result + 1)  = v1;
  return result;
}

uint64_t sub_1000BC3E8(uint64_t result, int a2)
{
  *(_WORD *)(result + 1)  = 0;
  if (a2) {
    JUMPOUT(0x1000BC3F0LL);
  }
  return result;
}

uint64_t sub_1000BC3FC(uint64_t result, int a2)
{
  *(_DWORD *)(result + 1)  = 0;
  if (!a2) {
    JUMPOUT(0x1000BC404LL);
  }
  *(_BYTE *)uint64_t result = a2 + 6;
  return result;
}

uint64_t sub_1000BC408(uint64_t result)
{
  *(_DWORD *)(result + 1)  = v1;
  return result;
}

uint64_t sub_1000BC410(uint64_t result)
{
  *(_WORD *)(result + 1)  = v1;
  return result;
}

uint64_t sub_1000BC41C(unsigned __int8 *a1)
{
  unsigned int v1 = *a1;
  BOOL v2 = v1 >= 2;
  int v3 = (v1 + 2147483646) & 0x7FFFFFFF;
  if (v2) {
    return (v3 + 1);
  }
  else {
    return 0LL;
  }
}

_BYTE *sub_1000BC438(_BYTE *result, int a2)
{
  if (a2) {
    *uint64_t result = a2 + 1;
  }
  return result;
}

ValueMetadata *type metadata accessor for Bandwidth()
{
  return &type metadata for Bandwidth;
}

uint64_t getEnumTagSinglePayload for WatchdogResetStatus(unsigned __int8 *a1, unsigned int a2)
{
  if (!a2) {
    return 0LL;
  }
  if (a2 < 0xFB) {
    goto LABEL_17;
  }
  if (a2 + 5 >= 0xFFFF00) {
    int v2 = 4;
  }
  else {
    int v2 = 2;
  }
  if ((a2 + 5) >> 8 < 0xFF) {
    int v3 = 1;
  }
  else {
    int v3 = v2;
  }
  if (v3 == 4)
  {
    int v4 = *(_DWORD *)(a1 + 1);
    if (v4) {
      return (*a1 | (v4 << 8)) - 5;
    }
  }

  else
  {
    if (v3 == 2)
    {
      int v4 = *(unsigned __int16 *)(a1 + 1);
      if (!*(_WORD *)(a1 + 1)) {
        goto LABEL_17;
      }
      return (*a1 | (v4 << 8)) - 5;
    }

    int v4 = a1[1];
    if (a1[1]) {
      return (*a1 | (v4 << 8)) - 5;
    }
  }

uint64_t storeEnumTagSinglePayload for Bandwidth.CodingKeys(_BYTE *a1, unsigned int a2, unsigned int a3)
{
  if (a3 + 5 >= 0xFFFF00) {
    int v3 = 4;
  }
  else {
    int v3 = 2;
  }
  if ((a3 + 5) >> 8 < 0xFF) {
    LODWORD(v4)  = 1;
  }
  else {
    LODWORD(v4)  = v3;
  }
  if (a3 >= 0xFB) {
    uint64_t v4 = v4;
  }
  else {
    uint64_t v4 = 0LL;
  }
  if (a2 <= 0xFA) {
    return ((uint64_t (*)(void))((char *)&loc_1000BC53C + 4 * byte_10033FD22[v4]))();
  }
  *a1  = a2 + 5;
  return ((uint64_t (*)(void))((char *)sub_1000BC570 + 4 * byte_10033FD1D[v4]))();
}

uint64_t sub_1000BC570(uint64_t result)
{
  *(_BYTE *)(result + 1)  = v1;
  return result;
}

uint64_t sub_1000BC578(uint64_t result, int a2)
{
  *(_WORD *)(result + 1)  = 0;
  if (a2) {
    JUMPOUT(0x1000BC580LL);
  }
  return result;
}

uint64_t sub_1000BC58C(uint64_t result, int a2)
{
  *(_DWORD *)(result + 1)  = 0;
  if (!a2) {
    JUMPOUT(0x1000BC594LL);
  }
  *(_BYTE *)uint64_t result = a2 + 5;
  return result;
}

uint64_t sub_1000BC598(uint64_t result)
{
  *(_DWORD *)(result + 1)  = v1;
  return result;
}

uint64_t sub_1000BC5A0(uint64_t result)
{
  *(_WORD *)(result + 1)  = v1;
  return result;
}

ValueMetadata *type metadata accessor for Bandwidth.CodingKeys()
{
  return &type metadata for Bandwidth.CodingKeys;
}

ValueMetadata *type metadata accessor for Bandwidth.TenMHzCodingKeys()
{
  return &type metadata for Bandwidth.TenMHzCodingKeys;
}

ValueMetadata *type metadata accessor for Bandwidth.TwentyMHzCodingKeys()
{
  return &type metadata for Bandwidth.TwentyMHzCodingKeys;
}

uint64_t storeEnumTagSinglePayload for Bandwidth.FortyMHzCodingKeys(uint64_t a1, int a2, int a3)
{
  else {
    int v3 = 2;
  }
  else {
    LODWORD(v4)  = v3;
  }
  if (a3) {
    uint64_t v4 = v4;
  }
  else {
    uint64_t v4 = 0LL;
  }
  if (a2) {
    return ((uint64_t (*)(void))((char *)sub_1000BC61C + 4 * byte_10033FD27[v4]))();
  }
  else {
    return ((uint64_t (*)(void))((char *)sub_1000BC63C + 4 * byte_10033FD2C[v4]))();
  }
}

_BYTE *sub_1000BC61C(_BYTE *result, char a2)
{
  *uint64_t result = a2;
  return result;
}

_BYTE *sub_1000BC63C(_BYTE *result)
{
  *uint64_t result = 0;
  return result;
}

_DWORD *sub_1000BC644(_DWORD *result, int a2)
{
  *uint64_t result = a2;
  return result;
}

_WORD *sub_1000BC64C(_WORD *result, __int16 a2)
{
  *uint64_t result = a2;
  return result;
}

_WORD *sub_1000BC654(_WORD *result)
{
  *uint64_t result = 0;
  return result;
}

_DWORD *sub_1000BC65C(_DWORD *result)
{
  *uint64_t result = 0;
  return result;
}

ValueMetadata *type metadata accessor for Bandwidth.FortyMHzCodingKeys()
{
  return &type metadata for Bandwidth.FortyMHzCodingKeys;
}

ValueMetadata *type metadata accessor for Bandwidth.EightyMHzCodingKeys()
{
  return &type metadata for Bandwidth.EightyMHzCodingKeys;
}

ValueMetadata *type metadata accessor for Bandwidth.OneSixtyMHzCodingKeys()
{
  return &type metadata for Bandwidth.OneSixtyMHzCodingKeys;
}

ValueMetadata *type metadata accessor for Bandwidth.ThreeTwentyMHzCodingKeys()
{
  return &type metadata for Bandwidth.ThreeTwentyMHzCodingKeys;
}

unint64_t sub_1000BC6AC()
{
  unint64_t result = qword_100407118;
  if (!qword_100407118)
  {
    unint64_t result = swift_getWitnessTable(&unk_1003400FC, &type metadata for Bandwidth.FortyMHzCodingKeys);
    atomic_store(result, (unint64_t *)&qword_100407118);
  }

  return result;
}

unint64_t sub_1000BC6F4()
{
  unint64_t result = qword_100407120;
  if (!qword_100407120)
  {
    unint64_t result = swift_getWitnessTable(&unk_100340254, &type metadata for Bandwidth.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_100407120);
  }

  return result;
}

unint64_t sub_1000BC73C()
{
  unint64_t result = qword_100407128;
  if (!qword_100407128)
  {
    unint64_t result = swift_getWitnessTable(&unk_100340174, &type metadata for Bandwidth.TenMHzCodingKeys);
    atomic_store(result, (unint64_t *)&qword_100407128);
  }

  return result;
}

unint64_t sub_1000BC784()
{
  unint64_t result = qword_100407130;
  if (!qword_100407130)
  {
    unint64_t result = swift_getWitnessTable(&unk_10034019C, &type metadata for Bandwidth.TenMHzCodingKeys);
    atomic_store(result, (unint64_t *)&qword_100407130);
  }

  return result;
}

unint64_t sub_1000BC7CC()
{
  unint64_t result = qword_100407138;
  if (!qword_100407138)
  {
    unint64_t result = swift_getWitnessTable(&unk_100340124, &type metadata for Bandwidth.TwentyMHzCodingKeys);
    atomic_store(result, (unint64_t *)&qword_100407138);
  }

  return result;
}

unint64_t sub_1000BC814()
{
  unint64_t result = qword_100407140;
  if (!qword_100407140)
  {
    unint64_t result = swift_getWitnessTable(&unk_10034014C, &type metadata for Bandwidth.TwentyMHzCodingKeys);
    atomic_store(result, (unint64_t *)&qword_100407140);
  }

  return result;
}

unint64_t sub_1000BC85C()
{
  unint64_t result = qword_100407148;
  if (!qword_100407148)
  {
    unint64_t result = swift_getWitnessTable(&unk_10034006C, &type metadata for Bandwidth.FortyMHzCodingKeys);
    atomic_store(result, (unint64_t *)&qword_100407148);
  }

  return result;
}

unint64_t sub_1000BC8A4()
{
  unint64_t result = qword_100407150;
  if (!qword_100407150)
  {
    unint64_t result = swift_getWitnessTable(&unk_100340094, &type metadata for Bandwidth.FortyMHzCodingKeys);
    atomic_store(result, (unint64_t *)&qword_100407150);
  }

  return result;
}

unint64_t sub_1000BC8EC()
{
  unint64_t result = qword_100407158;
  if (!qword_100407158)
  {
    unint64_t result = swift_getWitnessTable(&unk_10034001C, &type metadata for Bandwidth.EightyMHzCodingKeys);
    atomic_store(result, (unint64_t *)&qword_100407158);
  }

  return result;
}

unint64_t sub_1000BC934()
{
  unint64_t result = qword_100407160;
  if (!qword_100407160)
  {
    unint64_t result = swift_getWitnessTable(&unk_100340044, &type metadata for Bandwidth.EightyMHzCodingKeys);
    atomic_store(result, (unint64_t *)&qword_100407160);
  }

  return result;
}

unint64_t sub_1000BC97C()
{
  unint64_t result = qword_100407168;
  if (!qword_100407168)
  {
    unint64_t result = swift_getWitnessTable(&unk_10033FFCC, &type metadata for Bandwidth.OneSixtyMHzCodingKeys);
    atomic_store(result, (unint64_t *)&qword_100407168);
  }

  return result;
}

unint64_t sub_1000BC9C4()
{
  unint64_t result = qword_100407170;
  if (!qword_100407170)
  {
    unint64_t result = swift_getWitnessTable(&unk_10033FFF4, &type metadata for Bandwidth.OneSixtyMHzCodingKeys);
    atomic_store(result, (unint64_t *)&qword_100407170);
  }

  return result;
}

unint64_t sub_1000BCA0C()
{
  unint64_t result = qword_100407178;
  if (!qword_100407178)
  {
    unint64_t result = swift_getWitnessTable(&unk_10033FF7C, &type metadata for Bandwidth.ThreeTwentyMHzCodingKeys);
    atomic_store(result, (unint64_t *)&qword_100407178);
  }

  return result;
}

unint64_t sub_1000BCA54()
{
  unint64_t result = qword_100407180;
  if (!qword_100407180)
  {
    unint64_t result = swift_getWitnessTable(&unk_10033FFA4, &type metadata for Bandwidth.ThreeTwentyMHzCodingKeys);
    atomic_store(result, (unint64_t *)&qword_100407180);
  }

  return result;
}

unint64_t sub_1000BCA9C()
{
  unint64_t result = qword_100407188;
  if (!qword_100407188)
  {
    unint64_t result = swift_getWitnessTable(&unk_1003401C4, &type metadata for Bandwidth.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_100407188);
  }

  return result;
}

unint64_t sub_1000BCAE4()
{
  unint64_t result = qword_100407190;
  if (!qword_100407190)
  {
    unint64_t result = swift_getWitnessTable(&unk_1003401EC, &type metadata for Bandwidth.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_100407190);
  }

  return result;
}

uint64_t sub_1000BCB28(uint64_t a1, unint64_t a2)
{
  if (a1 == 0x7A484D6E6574LL && a2 == 0xE600000000000000LL)
  {
    unint64_t v5 = 0xE600000000000000LL;
    goto LABEL_8;
  }

  if ((_stringCompareWithSmolCheck(_:_:expecting:)(0x7A484D6E6574LL, 0xE600000000000000LL, a1, a2, 0LL) & 1) != 0)
  {
    unint64_t v5 = a2;
LABEL_8:
    swift_bridgeObjectRelease(v5);
    return 0LL;
  }

  if (a1 == 0x484D79746E657774LL && a2 == 0xE90000000000007ALL)
  {
    unint64_t v7 = 0xE90000000000007ALL;
LABEL_14:
    swift_bridgeObjectRelease(v7);
    return 1LL;
  }

  if ((_stringCompareWithSmolCheck(_:_:expecting:)(0x484D79746E657774LL, 0xE90000000000007ALL, a1, a2, 0LL) & 1) != 0)
  {
    unint64_t v7 = a2;
    goto LABEL_14;
  }

  if (a1 == 0x7A484D7974726F66LL && a2 == 0xE800000000000000LL)
  {
    unint64_t v8 = 0xE800000000000000LL;
LABEL_20:
    swift_bridgeObjectRelease(v8);
    return 2LL;
  }

  if ((_stringCompareWithSmolCheck(_:_:expecting:)(0x7A484D7974726F66LL, 0xE800000000000000LL, a1, a2, 0LL) & 1) != 0)
  {
    unint64_t v8 = a2;
    goto LABEL_20;
  }

  if (a1 == 0x484D797468676965LL && a2 == 0xE90000000000007ALL)
  {
    unint64_t v9 = 0xE90000000000007ALL;
LABEL_26:
    swift_bridgeObjectRelease(v9);
    return 3LL;
  }

  if ((_stringCompareWithSmolCheck(_:_:expecting:)(0x484D797468676965LL, 0xE90000000000007ALL, a1, a2, 0LL) & 1) != 0)
  {
    unint64_t v9 = a2;
    goto LABEL_26;
  }

  if (a1 == 0x7974786953656E6FLL && a2 == 0xEB000000007A484DLL)
  {
    unint64_t v10 = 0xEB000000007A484DLL;
LABEL_32:
    swift_bridgeObjectRelease(v10);
    return 4LL;
  }

  if ((_stringCompareWithSmolCheck(_:_:expecting:)(0x7974786953656E6FLL, 0xEB000000007A484DLL, a1, a2, 0LL) & 1) != 0)
  {
    unint64_t v10 = a2;
    goto LABEL_32;
  }

  if (a1 == 0x6577546565726874LL && a2 == 0xEE007A484D79746ELL)
  {
    swift_bridgeObjectRelease(0xEE007A484D79746ELL);
    return 5LL;
  }

  else
  {
    char v11 = _stringCompareWithSmolCheck(_:_:expecting:)(0x6577546565726874LL, 0xEE007A484D79746ELL, a1, a2, 0LL);
    swift_bridgeObjectRelease(a2);
    if ((v11 & 1) != 0) {
      return 5LL;
    }
    else {
      return 6LL;
    }
  }

uint64_t sub_1000BCDF4(uint64_t a1, uint64_t a2)
{
  if (a1 == 0xD000000000000015LL && a2 == 0x8000000100364220LL)
  {
    swift_bridgeObjectRelease(0x8000000100364220LL);
    char v3 = 0;
  }

  else
  {
    char v4 = _stringCompareWithSmolCheck(_:_:expecting:)(0xD000000000000015LL, 0x8000000100364220LL, a1, a2, 0LL);
    swift_bridgeObjectRelease(a2);
    char v3 = v4 ^ 1;
  }

  return v3 & 1;
}

uint64_t UnkeyedDecodingContainer.inferredDecode<A>()(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return dispatch thunk of UnkeyedDecodingContainer.decode<A>(_:)(a2, a2, a4, a1, a3);
}

void static BinaryDecoder.decode<A>(_:data:)(uint64_t a1, uint64_t a2, unint64_t a3)
{
  unint64_t v5 = a3 >> 62;
  sub_100020AFC(a2, a3);
  sub_10000D9B0((uint64_t)_swiftEmptyArrayStorage);
  uint64_t v6 = type metadata accessor for BinaryDecoder();
  unint64_t v7 = (void *)swift_allocObject(v6, 48LL, 7LL);
  v7[5]  = &_swiftEmptyDictionarySingleton;
  v7[2]  = a2;
  void v7[3] = a3;
  __asm { BR              X10 }

uint64_t sub_1000BCF38(uint64_t a1)
{
  *(void *)(v4 + 32)  = v6;
  swift_beginAccess(a1, &v9, 1LL, 0LL);
  uint64_t v7 = *(void *)(v4 + 40);
  *(void *)(v4 + 40)  = v5;
  swift_bridgeObjectRelease(v7);
  BinaryDecoder.decode<A>(_:)(v2, (uint64_t)v2, v1, v3);
  return swift_release(v4);
}

uint64_t UnkeyedDecodingContainer.decodeData(with:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = v4;
  uint64_t v9 = *(void *)(a2 - 8);
  __chkstk_darwin(a1);
  char v11 = (char *)v16 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  (*(void (**)(char *, uint64_t, uint64_t))(v9 + 16))(v11, v3, a2);
  if (swift_dynamicCast(v16, v11, a2, &type metadata for BinaryDecoder.UnkeyedContainer, 0LL))
  {
    uint64_t v12 = v16[0];
    swift_retain();
    BinaryDecoder.decodeData(with:)(a1);
    uint64_t v5 = v13;
    swift_release_n(v12, 2LL);
  }

  else
  {
    unint64_t v14 = sub_1000702C8();
    dispatch thunk of UnkeyedDecodingContainer.decode<A>(_:)( &type metadata for Data,  &type metadata for Data,  v14,  a2,  a3);
    if (!v4) {
      __asm { BR              X10 }
    }
  }

  (*(void (**)(char *, uint64_t))(v9 + 8))(v11, a2);
  return v5;
}

void BinaryDecoder.__allocating_init(data:userInfo:)(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = (void *)swift_allocObject(v2, 48LL, 7LL);
  void v5[5] = &_swiftEmptyDictionarySingleton;
  v5[2]  = a1;
  _OWORD v5[3] = a2;
  __asm { BR              X11 }

uint64_t sub_1000BD204(uint64_t a1)
{
  *(void *)(v2 + 32)  = v3;
  swift_beginAccess(a1, &v6, 1LL, 0LL);
  uint64_t v4 = *(void *)(v2 + 40);
  *(void *)(v2 + 40)  = v1;
  swift_bridgeObjectRelease(v4);
  return v2;
}

void static BinaryDecoder.decode<A>(_:data:)(uint64_t a1, unint64_t a2)
{
  unint64_t v4 = a2 >> 62;
  sub_100020AFC(a1, a2);
  sub_10000D9B0((uint64_t)_swiftEmptyArrayStorage);
  uint64_t v5 = type metadata accessor for BinaryDecoder();
  uint64_t v6 = (void *)swift_allocObject(v5, 48LL, 7LL);
  v6[5]  = &_swiftEmptyDictionarySingleton;
  _OWORD v6[2] = a1;
  v6[3]  = a2;
  __asm { BR              X10 }

uint64_t sub_1000BD2D0(uint64_t a1)
{
  *(void *)(v3 + 32)  = v4;
  swift_beginAccess(a1, &v9, 1LL, 0LL);
  uint64_t v5 = *(void *)(v3 + 40);
  *(void *)(v3 + 40)  = v2;
  swift_bridgeObjectRelease(v5);
  BinaryDecoder.decode<A>(_:)(v1);
  uint64_t v7 = v6;
  swift_release(v3);
  return v7;
}

uint64_t CodingUserInfoKey.channelInformationHasAuxillaryBitmap.unsafeMutableAddressor()
{
  return sub_1000BD3A0( &qword_100404160,  (uint64_t)static CodingUserInfoKey.channelInformationHasAuxillaryBitmap,  (uint64_t)sub_1000BD3FC);
}

uint64_t sub_1000BD360(uint64_t a1)
{
  return sub_1000BD420(a1, static CodingUserInfoKey.fourByteAlignedValue, 0xD000000000000014LL, 0x8000000100364270LL);
}

uint64_t CodingUserInfoKey.fourByteAlignedValue.unsafeMutableAddressor()
{
  return sub_1000BD3A0(&qword_100404158, (uint64_t)static CodingUserInfoKey.fourByteAlignedValue, (uint64_t)sub_1000BD360);
}

uint64_t sub_1000BD3A0(void *a1, uint64_t a2, uint64_t a3)
{
  if (*a1 != -1LL) {
    swift_once(a1, a3);
  }
  uint64_t v4 = type metadata accessor for CodingUserInfoKey(0LL);
  return sub_1000032DC(v4, a2);
}

uint64_t static CodingUserInfoKey.fourByteAlignedValue.getter@<X0>(uint64_t a1@<X8>)
{
  return sub_1000BD518( &qword_100404158,  (uint64_t)static CodingUserInfoKey.fourByteAlignedValue,  (uint64_t)sub_1000BD360,  a1);
}

uint64_t sub_1000BD3FC(uint64_t a1)
{
  return sub_1000BD420( a1,  static CodingUserInfoKey.channelInformationHasAuxillaryBitmap,  0xD000000000000024LL,  0x8000000100364290LL);
}

uint64_t sub_1000BD420(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7 = sub_100002274(&qword_1004073F8);
  __chkstk_darwin(v7);
  uint64_t v9 = (char *)&v14 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v10 = type metadata accessor for CodingUserInfoKey(0LL);
  sub_10000B0D0(v10, a2);
  uint64_t v11 = sub_1000032DC(v10, (uint64_t)a2);
  CodingUserInfoKey.init(rawValue:)(a3, a4);
  uint64_t v12 = *(void *)(v10 - 8);
  uint64_t result = (*(uint64_t (**)(char *, uint64_t, uint64_t))(v12 + 48))(v9, 1LL, v10);
  if ((_DWORD)result != 1) {
    return (*(uint64_t (**)(uint64_t, char *, uint64_t))(v12 + 32))(v11, v9, v10);
  }
  __break(1u);
  return result;
}

uint64_t static CodingUserInfoKey.channelInformationHasAuxillaryBitmap.getter@<X0>(uint64_t a1@<X8>)
{
  return sub_1000BD518( &qword_100404160,  (uint64_t)static CodingUserInfoKey.channelInformationHasAuxillaryBitmap,  (uint64_t)sub_1000BD3FC,  a1);
}

uint64_t sub_1000BD518@<X0>(void *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  if (*a1 != -1LL) {
    swift_once(a1, a3);
  }
  uint64_t v6 = type metadata accessor for CodingUserInfoKey(0LL);
  uint64_t v7 = sub_1000032DC(v6, a2);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v6 - 8) + 16LL))(a4, v7, v6);
}

void sub_1000BD580(uint64_t a1@<X1>, void *a2@<X8>)
{
  if (!v2)
  {
    uint64_t v6 = v5;
    a2[3]  = type metadata accessor for Array(0LL, a1);
    *a2  = v6;
  }

void sub_1000BD5DC(uint64_t a1@<X1>, void *a2@<X8>)
{
}

void BinaryDecoder.init(data:userInfo:)(uint64_t a1, uint64_t a2)
{
  v2[5]  = &_swiftEmptyDictionarySingleton;
  v2[2]  = a1;
  v2[3]  = a2;
  __asm { BR              X12 }

uint64_t sub_1000BD644@<X0>(uint64_t a1@<X0>, int a2@<W8>)
{
  *(void *)(v3 + 32)  = a2;
  swift_beginAccess(a1, &v6, 1LL, 0LL);
  uint64_t v4 = *(void *)(v3 + 40);
  *(void *)(v3 + 40)  = v2;
  swift_bridgeObjectRelease(v4);
  return v3;
}

uint64_t BinaryDecoder.userInfo.getter()
{
  return swift_bridgeObjectRetain(*(void *)(v0 + 40));
}

uint64_t BinaryDecoder.userInfo.setter(uint64_t a1)
{
  uint64_t v3 = *(void *)(v1 + 40);
  *(void *)(v1 + 40)  = a1;
  return swift_bridgeObjectRelease(v3);
}

void *BinaryDecoder.userInfo.modify(uint64_t a1)
{
  return &j__swift_endAccess;
}

void sub_1000BD738( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_1000BD764(void *a1@<X4>, uint64_t a2@<X6>, uint64_t a3@<X8>)
{
}

uint64_t sub_1000BD790(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  return BinaryDecoder.container<A>(keyedBy:)(a1, a5, a7, a4);
}

uint64_t sub_1000BD7B8@<X0>(uint64_t a1@<X1>, void *a2@<X8>)
{
  a2[3]  = &type metadata for BinaryDecoder.UnkeyedContainer;
  a2[4]  = sub_100070240();
  *a2  = a1;
  return swift_retain();
}

uint64_t sub_1000BD808@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  a2[3]  = type metadata accessor for BinaryDecoder();
  a2[4]  = sub_1000BFB60();
  *a2  = a1;
  return swift_retain();
}

uint64_t sub_1000BD854@<X0>(uint64_t a1@<X1>, void *a2@<X8>)
{
  a2[3]  = type metadata accessor for BinaryDecoder();
  a2[4]  = sub_1000BFB60();
  *a2  = a1;
  return swift_retain();
}

uint64_t sub_1000BD8A0(uint64_t a1)
{
  return sub_1000C0158(*(void *)(a1 + 16));
}

uint64_t sub_1000BD8AC()
{
  if (!v0) {
    char v1 = v3;
  }
  return v1 & 1;
}

void sub_1000BD900()
{
}

double sub_1000BD950()
{
  if (!v0) {
    return v2;
  }
  return result;
}

float sub_1000BD9A0()
{
  if (!v0) {
    return v2;
  }
  return result;
}

void sub_1000BD9F0(uint64_t a1, uint64_t a2, uint64_t a3)
{
}

void sub_1000BDA1C(uint64_t a1, uint64_t a2, uint64_t a3)
{
}

void sub_1000BDA48(uint64_t a1, uint64_t a2, uint64_t a3)
{
}

void sub_1000BDA74(uint64_t a1, uint64_t a2, uint64_t a3)
{
}

void sub_1000BDAA0(uint64_t a1, uint64_t a2, uint64_t a3)
{
}

uint64_t sub_1000BDACC()
{
  return KeyedDecodingContainerProtocol.decode(_:forKey:)();
}

void sub_1000BDAE0(uint64_t a1, uint64_t a2, uint64_t a3)
{
}

void sub_1000BDB0C(uint64_t a1, uint64_t a2, uint64_t a3)
{
}

void sub_1000BDB38(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t (*a4)(void), uint64_t a5, uint64_t a6)
{
  uint64_t v10 = *v6;
  uint64_t v11 = *(void *)(a2 + 16);
  uint64_t v12 = *(void *)(a2 + 24);
  uint64_t v13 = a4();
  sub_1000BD738(a5, a1, v10, v11, a5, v12, a6, v13);
}

void sub_1000BDBBC(uint64_t a1, uint64_t a2, uint64_t a3)
{
}

void sub_1000BDBE8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t (*a4)(void), uint64_t a5, uint64_t a6)
{
  uint64_t v10 = *v6;
  uint64_t v11 = *(void *)(a2 + 16);
  uint64_t v12 = *(void *)(a2 + 24);
  uint64_t v13 = a4();
  sub_1000BD738(a5, a1, v10, v11, a5, v12, a6, v13);
}

void sub_1000BDC6C(uint64_t a1, uint64_t a2, uint64_t a3)
{
}

void sub_1000BDC98(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t (*a4)(void), uint64_t a5, uint64_t a6)
{
  uint64_t v10 = *v6;
  uint64_t v11 = *(void *)(a2 + 16);
  uint64_t v12 = *(void *)(a2 + 24);
  uint64_t v13 = a4();
  sub_1000BD738(a5, a1, v10, v11, a5, v12, a6, v13);
}

void sub_1000BDD1C(uint64_t a1, uint64_t a2, uint64_t a3)
{
}

void sub_1000BDD48(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t (*a4)(void), uint64_t a5, uint64_t a6)
{
  uint64_t v10 = *v6;
  uint64_t v11 = *(void *)(a2 + 16);
  uint64_t v12 = *(void *)(a2 + 24);
  uint64_t v13 = a4();
  sub_1000BD738(a5, a1, v10, v11, a5, v12, a6, v13);
}

uint64_t sub_1000BDDCC()
{
  return KeyedDecodingContainerProtocol.decode(_:forKey:)();
}

void sub_1000BDDE0(void *a1@<X2>, uint64_t a2@<X3>, uint64_t a3@<X8>)
{
}

uint64_t sub_1000BDE08()
{
  return KeyedDecodingContainerProtocol.decodeIfPresent(_:forKey:)();
}

uint64_t sub_1000BDE1C()
{
  return KeyedDecodingContainerProtocol.decodeIfPresent(_:forKey:)();
}

uint64_t sub_1000BDE30()
{
  uint64_t result = KeyedDecodingContainerProtocol.decodeIfPresent(_:forKey:)();
  if (v0) {
    return v2;
  }
  return result;
}

uint64_t sub_1000BDE50(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_1000BDFE0(a1, a2, a3, (uint64_t (*)(void))&KeyedDecodingContainerProtocol.decodeIfPresent(_:forKey:));
}

uint64_t sub_1000BDE6C()
{
  uint64_t result = KeyedDecodingContainerProtocol.decodeIfPresent(_:forKey:)();
  if (v0) {
    return v2;
  }
  return result;
}

uint64_t sub_1000BDE8C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_1000BDF58(a1, a2, a3, (uint64_t (*)(void))&KeyedDecodingContainerProtocol.decodeIfPresent(_:forKey:));
}

uint64_t sub_1000BDEA8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_1000BDF9C(a1, a2, a3, (uint64_t (*)(void))&KeyedDecodingContainerProtocol.decodeIfPresent(_:forKey:));
}

uint64_t sub_1000BDEC4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_1000BDFE0(a1, a2, a3, (uint64_t (*)(void))&KeyedDecodingContainerProtocol.decodeIfPresent(_:forKey:));
}

uint64_t sub_1000BDEE0()
{
  uint64_t result = KeyedDecodingContainerProtocol.decodeIfPresent(_:forKey:)();
  if (v0) {
    return v2;
  }
  return result;
}

uint64_t sub_1000BDF00(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_1000BE04C(a1, a2, a3, (uint64_t (*)(void))&KeyedDecodingContainerProtocol.decodeIfPresent(_:forKey:));
}

uint64_t sub_1000BDF1C()
{
  uint64_t result = KeyedDecodingContainerProtocol.decodeIfPresent(_:forKey:)();
  if (v0) {
    return v2;
  }
  return result;
}

uint64_t sub_1000BDF3C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_1000BDF58(a1, a2, a3, (uint64_t (*)(void))&KeyedDecodingContainerProtocol.decodeIfPresent(_:forKey:));
}

uint64_t sub_1000BDF58(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t (*a4)(void))
{
  return a4() & 0x1FF;
}

uint64_t sub_1000BDF80(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_1000BDF9C(a1, a2, a3, (uint64_t (*)(void))&KeyedDecodingContainerProtocol.decodeIfPresent(_:forKey:));
}

uint64_t sub_1000BDF9C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t (*a4)(void))
{
  return a4() & 0x1FFFF;
}

uint64_t sub_1000BDFC4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_1000BDFE0(a1, a2, a3, (uint64_t (*)(void))&KeyedDecodingContainerProtocol.decodeIfPresent(_:forKey:));
}

uint64_t sub_1000BDFE0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t (*a4)(void))
{
  unint64_t v4 = a4();
  return v4 | ((HIDWORD(v4) & 1) << 32);
}

uint64_t sub_1000BE010()
{
  uint64_t result = KeyedDecodingContainerProtocol.decodeIfPresent(_:forKey:)();
  if (v0) {
    return v2;
  }
  return result;
}

uint64_t sub_1000BE030(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_1000BE04C(a1, a2, a3, (uint64_t (*)(void))&KeyedDecodingContainerProtocol.decodeIfPresent(_:forKey:));
}

uint64_t sub_1000BE04C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t (*a4)(void))
{
  uint64_t result = a4();
  if (v4) {
    return v6;
  }
  return result;
}

uint64_t sub_1000BE070(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  return KeyedDecodingContainerProtocol.decodeIfPresent<A>(_:forKey:)(a1, a2, a5, a3, a6, a4);
}

uint64_t sub_1000BE098(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return sub_1000BD790(a1, a2, *v5, *(void *)(a5 + 16), a3, *(void *)(a5 + 24), a4);
}

uint64_t sub_1000BE0C0@<X0>(void *a1@<X8>)
{
  return sub_1000BD7B8(*v1, a1);
}

uint64_t sub_1000BE0E0@<X0>(void *a1@<X8>)
{
  return sub_1000BD808(*v1, a1);
}

uint64_t sub_1000BE100@<X0>(void *a1@<X8>)
{
  return sub_1000BD854(*v1, a1);
}

void sub_1000BE120(void *a1@<X0>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X8>)
{
}

uint64_t sub_1000BE148(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return BinaryDecoder.container<A>(keyedBy:)(a1, a3, a4, a4);
}

uint64_t sub_1000BE170()
{
  return ((uint64_t (*)(void))((char *)sub_1000BE19C + 4 * byte_1003404E0[*(void *)(*(void *)v0 + 24LL) >> 62]))();
}

BOOL sub_1000BE19C@<W0>(uint64_t a1@<X8>)
{
  return a1 == BYTE6(v1);
}

BOOL sub_1000BE1BC()
{
  return v0 != 0;
}

uint64_t sub_1000BE1EC()
{
  uint64_t v1 = *v0;
  v3[3]  = type metadata accessor for BinaryDecoder();
  void v3[4] = sub_1000BFB60();
  v3[0]  = v1;
  swift_retain();
  return String.init(from:)(v3);
}

double sub_1000BE23C()
{
  return v0;
}

uint64_t sub_1000BE268()
{
  uint64_t v1 = *v0;
  v3[3]  = type metadata accessor for BinaryDecoder();
  void v3[4] = sub_1000BFB60();
  v3[0]  = v1;
  swift_retain();
  return Float.init(from:)(v3);
}

void sub_1000BE2B8()
{
}

void sub_1000BE2E0()
{
}

void sub_1000BE308()
{
}

void sub_1000BE330()
{
}

uint64_t sub_1000BE358(uint64_t a1, uint64_t a2)
{
  unint64_t v4 = sub_1000BFB1C();
  return SingleValueDecodingContainer<>.decode(_:)(a1, v4, a2);
}

uint64_t sub_1000BE39C(uint64_t a1, uint64_t a2)
{
  unint64_t v4 = sub_1000BFB1C();
  return SingleValueDecodingContainer<>.decode(_:)(a1, v4, a2);
}

void sub_1000BE3E0(void *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
}

uint64_t sub_1000BE400()
{
  return UnkeyedDecodingContainer.decodeIfPresent(_:)();
}

uint64_t sub_1000BE414()
{
  return UnkeyedDecodingContainer.decodeIfPresent(_:)();
}

uint64_t sub_1000BE428()
{
  uint64_t result = UnkeyedDecodingContainer.decodeIfPresent(_:)();
  if (v0) {
    return v2;
  }
  return result;
}

uint64_t sub_1000BE448(uint64_t a1, uint64_t a2)
{
  return sub_1000BE5D8(a1, a2, (uint64_t (*)(void))&UnkeyedDecodingContainer.decodeIfPresent(_:));
}

uint64_t sub_1000BE464()
{
  uint64_t result = UnkeyedDecodingContainer.decodeIfPresent(_:)();
  if (v0) {
    return v2;
  }
  return result;
}

uint64_t sub_1000BE484(uint64_t a1, uint64_t a2)
{
  return sub_1000BE550(a1, a2, (uint64_t (*)(void))&UnkeyedDecodingContainer.decodeIfPresent(_:));
}

uint64_t sub_1000BE4A0(uint64_t a1, uint64_t a2)
{
  return sub_1000BE594(a1, a2, (uint64_t (*)(void))&UnkeyedDecodingContainer.decodeIfPresent(_:));
}

uint64_t sub_1000BE4BC(uint64_t a1, uint64_t a2)
{
  return sub_1000BE5D8(a1, a2, (uint64_t (*)(void))&UnkeyedDecodingContainer.decodeIfPresent(_:));
}

uint64_t sub_1000BE4D8()
{
  uint64_t result = UnkeyedDecodingContainer.decodeIfPresent(_:)();
  if (v0) {
    return v2;
  }
  return result;
}

uint64_t sub_1000BE4F8(uint64_t a1, uint64_t a2)
{
  return sub_1000BE644(a1, a2, (uint64_t (*)(void))&UnkeyedDecodingContainer.decodeIfPresent(_:));
}

uint64_t sub_1000BE514()
{
  uint64_t result = UnkeyedDecodingContainer.decodeIfPresent(_:)();
  if (v0) {
    return v2;
  }
  return result;
}

uint64_t sub_1000BE534(uint64_t a1, uint64_t a2)
{
  return sub_1000BE550(a1, a2, (uint64_t (*)(void))&UnkeyedDecodingContainer.decodeIfPresent(_:));
}

uint64_t sub_1000BE550(uint64_t a1, uint64_t a2, uint64_t (*a3)(void))
{
  return a3() & 0x1FF;
}

uint64_t sub_1000BE578(uint64_t a1, uint64_t a2)
{
  return sub_1000BE594(a1, a2, (uint64_t (*)(void))&UnkeyedDecodingContainer.decodeIfPresent(_:));
}

uint64_t sub_1000BE594(uint64_t a1, uint64_t a2, uint64_t (*a3)(void))
{
  return a3() & 0x1FFFF;
}

uint64_t sub_1000BE5BC(uint64_t a1, uint64_t a2)
{
  return sub_1000BE5D8(a1, a2, (uint64_t (*)(void))&UnkeyedDecodingContainer.decodeIfPresent(_:));
}

uint64_t sub_1000BE5D8(uint64_t a1, uint64_t a2, uint64_t (*a3)(void))
{
  unint64_t v3 = a3();
  return v3 | ((HIDWORD(v3) & 1) << 32);
}

uint64_t sub_1000BE608()
{
  uint64_t result = UnkeyedDecodingContainer.decodeIfPresent(_:)();
  if (v0) {
    return v2;
  }
  return result;
}

uint64_t sub_1000BE628(uint64_t a1, uint64_t a2)
{
  return sub_1000BE644(a1, a2, (uint64_t (*)(void))&UnkeyedDecodingContainer.decodeIfPresent(_:));
}

uint64_t sub_1000BE644(uint64_t a1, uint64_t a2, uint64_t (*a3)(void))
{
  uint64_t result = a3();
  if (v3) {
    return v5;
  }
  return result;
}

uint64_t sub_1000BE668(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return UnkeyedDecodingContainer.decodeIfPresent<A>(_:)(a1, a4, a2, a5, a3);
}

uint64_t sub_1000BE690(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_1000BE148(a1, *v3, a2, a3);
}

uint64_t sub_1000BE6B0@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  uint64_t v4 = *v3;
  a3[3]  = a1;
  a3[4]  = a2;
  *a3  = v4;
  return swift_retain(v4);
}

uint64_t sub_1000BE6D4@<X0>(void *a1@<X8>)
{
  uint64_t v3 = *v1;
  a1[3]  = type metadata accessor for BinaryDecoder();
  a1[4]  = sub_1000BFB60();
  *a1  = v3;
  return swift_retain();
}

uint64_t sub_1000BE720(uint64_t a1, uint64_t a2)
{
  unint64_t v4 = sub_100070240();
  return SingleValueDecodingContainer<>.decode(_:)(a1, a2, v4);
}

uint64_t sub_1000BE764(uint64_t a1, uint64_t a2)
{
  unint64_t v4 = sub_100070240();
  return SingleValueDecodingContainer<>.decode(_:)(a1, a2, v4);
}

uint64_t BinaryDecoder.container<A>(keyedBy:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = type metadata accessor for BinaryDecoder.KeyedContainer(0LL, a2, a3, a4);
  swift_retain();
  uint64_t WitnessTable = swift_getWitnessTable(&unk_1003408FC, v5);
  return KeyedDecodingContainer.init<A>(_:)(&v8, a2, v5, WitnessTable);
}

uint64_t BinaryDecoder.unkeyedContainer()@<X0>(void *a1@<X8>)
{
  return sub_1000BE858((uint64_t (*)(void))sub_100070240, a1);
}

uint64_t BinaryDecoder.singleValueContainer()@<X0>(void *a1@<X8>)
{
  return sub_1000BE858((uint64_t (*)(void))sub_1000BFB1C, a1);
}

uint64_t sub_1000BE858@<X0>(uint64_t (*a1)(void)@<X0>, void *a2@<X8>)
{
  a2[3]  = &type metadata for BinaryDecoder.UnkeyedContainer;
  a2[4]  = a1();
  *a2  = v2;
  return swift_retain(v2);
}

void BinaryDecoder.peekBytes(_:)(uint64_t a1)
{
  if (!__OFADD__(*(void *)(v1 + 32), a1)) {
    __asm { BR              X10 }
  }

  __break(1u);
  JUMPOUT(0x1000BE968LL);
}

void BinaryDecoder.decode<A>(_:)(void *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  if (a1 == &type metadata for Data)
  {
    sub_1000BFBA4();
    if (v5) {
      return;
    }
    v18[0]  = v14;
    v18[1]  = v15;
    uint64_t v13 = (char *)&type metadata for Data;
    goto LABEL_19;
  }

  if (a1 == (void *)&type metadata for Bool)
  {
    sub_1000BEDA8();
    if (v5) {
      return;
    }
    LOBYTE(v18[0])  = v16 != 0;
    uint64_t v13 = (char *)&type metadata for Bool;
    goto LABEL_19;
  }

  if (a1 == (void *)&type metadata for Double)
  {
    sub_1000BF1B0();
    if (v5) {
      return;
    }
    v18[0]  = v17;
    uint64_t v13 = (char *)&type metadata for Double;
    goto LABEL_19;
  }

  uint64_t v10 = swift_conformsToProtocol2(a1, &protocol descriptor for BinaryDecodableArray);
  if (v10) {
    uint64_t v11 = v10;
  }
  else {
    uint64_t v11 = 0LL;
  }
  if (v10) {
    uint64_t v12 = a1;
  }
  else {
    uint64_t v12 = 0LL;
  }
  if (v12)
  {
    (*(void (**)(void *__return_ptr, uint64_t))(v11 + 8))(v18, v4);
    if (v5) {
      return;
    }
    uint64_t v13 = (char *)&type metadata for Any + 8;
LABEL_19:
    swift_dynamicCast(a4, v18, v13, a2, 7LL);
    return;
  }

  uint64_t v18[3] = type metadata accessor for BinaryDecoder();
  v18[4]  = sub_1000BFB60();
  v18[0]  = v4;
  swift_retain();
  dispatch thunk of Decodable.init(from:)(v18, a2, a3);
}

void BinaryDecoder.decode<A>(_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7 = __chkstk_darwin(a1);
  uint64_t v9 = (char *)&v11 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  sub_1000BF308(v7, v10);
  if (!v4) {
    dispatch thunk of FixedWidthInteger.init(littleEndian:)(v9, a2, a4);
  }
}

double BinaryDecoder.decode(_:)()
{
  return v0;
}

void BinaryDecoder.decode(_:)()
{
}

BOOL BinaryDecoder.decode(_:)()
{
  return v0 != 0;
}

void BinaryDecoder.decode<A>(_:)(uint64_t a1)
{
  uint64_t v2 = __chkstk_darwin(a1);
  Array.init()(v2);
  __asm { BR              X10 }

uint64_t sub_1000BECB4@<X0>(uint64_t a1@<X8>)
{
  if (a1 >= *(void *)(v5 - 128)) {
    return *(void *)(v5 - 72);
  }
  BinaryDecoder.decode<A>(_:)(v3, (uint64_t)v3, v2, v4);
  if (!v1) {
    JUMPOUT(0x1000BEC80LL);
  }
  *(void *)(v5 - 88)  = v1;
  swift_errorRetain(v1);
  uint64_t v6 = sub_100002274((uint64_t *)&unk_10040C5B0);
  if (swift_dynamicCast(v5 - 112, v5 - 88, v6, &type metadata for WiFiError, 0LL))
  {
    uint64_t v7 = *(void *)(v5 - 112);
    int v8 = *(unsigned __int8 *)(v5 - 96);
    if (v8 == 2)
    {
      if ((v7 & 1) != 0)
      {
        swift_errorRelease(v1);
        swift_errorRelease(*(void *)(v5 - 88));
        JUMPOUT(0x1000BEC9CLL);
      }
    }

    else
    {
      sub_10007030C(v7, *(void *)(v5 - 104), v8);
    }
  }

  swift_bridgeObjectRelease(*(void *)(v5 - 72));
  return swift_errorRelease(*(void *)(v5 - 88));
}

void sub_1000BEDA8()
{
  if (!__OFADD__(*(void *)(v0 + 32), 1LL)) {
    __asm { BR              X10 }
  }

  __break(1u);
  JUMPOUT(0x1000BEEECLL);
}

void sub_1000BEF00()
{
  if (!__OFADD__(*(void *)(v0 + 32), 4LL)) {
    __asm { BR              X10 }
  }

  __break(1u);
  JUMPOUT(0x1000BF044LL);
}

void sub_1000BF058()
{
  if (!__OFADD__(*(void *)(v0 + 32), 2LL)) {
    __asm { BR              X10 }
  }

  __break(1u);
  JUMPOUT(0x1000BF19CLL);
}

void sub_1000BF1B0()
{
  if (!__OFADD__(*(void *)(v0 + 32), 8LL)) {
    __asm { BR              X10 }
  }

  __break(1u);
  JUMPOUT(0x1000BF2F4LL);
}

void sub_1000BF308(uint64_t a1, uint64_t a2)
{
  if (!__OFADD__(*(void *)(v2 + 32), *(void *)(*(void *)(a2 - 8) + 64LL))) {
    __asm { BR              X10 }
  }

  __break(1u);
  JUMPOUT(0x1000BF460LL);
}

void BinaryDecoder.inferredDecode<A>()(void *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
}

void BinaryDecoder.decodeData(with:)(uint64_t a1)
{
  if (!__OFADD__(*(void *)(v1 + 32), a1)) {
    __asm { BR              X11 }
  }

  __break(1u);
  JUMPOUT(0x1000BF568LL);
}

uint64_t IEEE80211InformationElement.MessageIntegrityCode.code.setter(uint64_t a1, uint64_t a2)
{
  uint64_t result = sub_1000208D8(*(void *)v2, *(void *)(v2 + 8));
  *(void *)uint64_t v2 = a1;
  *(void *)(v2 + 8)  = a2;
  return result;
}

void BinaryDecoder.DataCopy.init(_:)(uint64_t a1, uint64_t a2)
{
  __asm { BR              X10 }

uint64_t sub_1000BF5EC()
{
  uint64_t v2 = Data.subdata(in:)(0LL, BYTE6(v0), v1, v0);
  sub_1000208D8(v1, v0);
  return v2;
}

uint64_t BinaryDecoder.DataCopy.init(from:)(void *a1)
{
  return sub_1000BFCF0(a1);
}

uint64_t InterfaceIdentifier.encode(to:)(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = a1[3];
  uint64_t v6 = a1[4];
  sub_100021104(a1, v5);
  dispatch thunk of Encoder.singleValueContainer()(v12, v5, v6);
  v11[0]  = a2;
  v11[1]  = a3;
  uint64_t v7 = v13;
  uint64_t v8 = v14;
  sub_1000237C8((uint64_t)v12, v13);
  unint64_t v9 = sub_10005CD78();
  dispatch thunk of SingleValueEncodingContainer.encode<A>(_:)(v11, &type metadata for Data, v9, v7, v8);
  return sub_100002AC4(v12);
}

uint64_t sub_1000BF718@<X0>(void *a1@<X0>, uint64_t *a2@<X8>)
{
  uint64_t result = BinaryDecoder.DataCopy.init(from:)(a1);
  if (!v2)
  {
    *a2  = result;
    a2[1]  = v5;
  }

  return result;
}

uint64_t sub_1000BF740(void *a1)
{
  uint64_t v2 = *v1;
  uint64_t v3 = v1[1];
  uint64_t v4 = a1[3];
  uint64_t v5 = a1[4];
  sub_100021104(a1, v4);
  dispatch thunk of Encoder.singleValueContainer()(v11, v4, v5);
  v10[0]  = v2;
  v10[1]  = v3;
  uint64_t v6 = v12;
  uint64_t v7 = v13;
  sub_1000237C8((uint64_t)v11, v12);
  unint64_t v8 = sub_10005CD78();
  dispatch thunk of SingleValueEncodingContainer.encode<A>(_:)(v10, &type metadata for Data, v8, v6, v7);
  return sub_100002AC4(v11);
}

uint64_t sub_1000BF7E4()
{
  uint64_t v1 = *v0;
  unint64_t v2 = v0[1];
  sub_100020AFC(v1, v2);
  sub_100020B54(0LL, 0xE000000000000000LL, v1, v2);
  uint64_t v4 = v3;
  sub_1000208D8(v1, v2);
  return v4;
}

void *BinaryDecoder.deinit()
{
  return v0;
}

uint64_t BinaryDecoder.__deallocating_deinit()
{
  return swift_deallocClassInstance(v0, 48LL, 7LL);
}

uint64_t sub_1000BF8A0()
{
  uint64_t v1 = *v0;
  swift_beginAccess(*v0 + 40, v3, 0LL, 0LL);
  return swift_bridgeObjectRetain(*(void *)(v1 + 40));
}

uint64_t sub_1000BF8E0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return BinaryDecoder.container<A>(keyedBy:)(a1, a2, a3, a4);
}

uint64_t sub_1000BF900@<X0>(void *a1@<X8>)
{
  return sub_1000BF938((uint64_t (*)(void))sub_100070240, a1);
}

uint64_t sub_1000BF91C@<X0>(void *a1@<X8>)
{
  return sub_1000BF938((uint64_t (*)(void))sub_1000BFB1C, a1);
}

uint64_t sub_1000BF938@<X0>(uint64_t (*a1)(void)@<X2>, void *a2@<X8>)
{
  uint64_t v4 = *v2;
  a2[3]  = &type metadata for BinaryDecoder.UnkeyedContainer;
  a2[4]  = a1();
  *a2  = v4;
  return swift_retain(v4);
}

uint64_t UnkeyedDecodingContainer.inferredArrayDecode<A>()(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6 = v5;
  uint64_t v11 = *(void *)(a1 - 8);
  __chkstk_darwin(a1);
  uint64_t v13 = (char *)&v19 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v13, v4, a1);
  if (swift_dynamicCast(&v20, v13, a1, &type metadata for BinaryDecoder.UnkeyedContainer, 0LL))
  {
    uint64_t v14 = v20;
    swift_retain();
    BinaryDecoder.decode<A>(_:)(a2);
    uint64_t v6 = v15;
    swift_release_n(v14, 2LL);
  }

  else
  {
    uint64_t v16 = type metadata accessor for Array(0LL, a2);
    uint64_t v19 = a4;
    uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for <A> [A], v16);
    dispatch thunk of UnkeyedDecodingContainer.decode<A>(_:)(v16, v16, WitnessTable, a1, a3);
    if (!v5) {
      uint64_t v6 = v20;
    }
  }

  (*(void (**)(char *, uint64_t))(v11 + 8))(v13, a1);
  return v6;
}

uint64_t type metadata accessor for BinaryDecoder()
{
  return objc_opt_self(&OBJC_CLASS____TtC7CoreP2P13BinaryDecoder);
}

uint64_t type metadata accessor for BinaryDecoder.KeyedContainer( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return sub_1000227C8(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for BinaryDecoder.KeyedContainer);
}

unint64_t sub_1000BFB1C()
{
  unint64_t result = qword_1004071D0;
  if (!qword_1004071D0)
  {
    unint64_t result = swift_getWitnessTable(&unk_1003406D4, &type metadata for BinaryDecoder.UnkeyedContainer);
    atomic_store(result, (unint64_t *)&qword_1004071D0);
  }

  return result;
}

unint64_t sub_1000BFB60()
{
  unint64_t result = qword_100405DE8;
  if (!qword_100405DE8)
  {
    uint64_t v1 = type metadata accessor for BinaryDecoder();
    unint64_t result = swift_getWitnessTable(&protocol conformance descriptor for BinaryDecoder, v1);
    atomic_store(result, (unint64_t *)&qword_100405DE8);
  }

  return result;
}

void sub_1000BFBA4()
{
  __asm { BR              X9 }

uint64_t sub_1000BFCF0(void *a1)
{
  uint64_t v3 = a1[3];
  uint64_t v4 = a1[4];
  sub_100021104(a1, v3);
  dispatch thunk of Decoder.unkeyedContainer()(v10, v3, v4);
  if (!v1)
  {
    uint64_t v5 = v11;
    uint64_t v6 = v12;
    sub_1000237C8((uint64_t)v10, v11);
    unint64_t v7 = sub_1000702C8();
    dispatch thunk of UnkeyedDecodingContainer.decode<A>(_:)( &type metadata for Data,  &type metadata for Data,  v7,  v5,  v6);
    __asm { BR              X10 }
  }

  sub_100002AC4(a1);
  return v4;
}

void sub_1000BFDDC(uint64_t a1, uint64_t a2, uint64_t a3, ...)
{
}

unint64_t sub_1000BFE4C()
{
  unint64_t result = qword_1004071D8;
  if (!qword_1004071D8)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for BinaryDecoder.DataCopy,  &type metadata for BinaryDecoder.DataCopy);
    atomic_store(result, (unint64_t *)&qword_1004071D8);
  }

  return result;
}

ValueMetadata *type metadata accessor for BinaryDecoder.DataCopy()
{
  return &type metadata for BinaryDecoder.DataCopy;
}

ValueMetadata *type metadata accessor for BinaryDecoder.UnkeyedContainer()
{
  return &type metadata for BinaryDecoder.UnkeyedContainer;
}

unint64_t sub_1000BFEB0()
{
  unint64_t result = qword_1004073B0;
  if (!qword_1004073B0)
  {
    unint64_t result = swift_getWitnessTable(&protocol conformance descriptor for UInt64, &type metadata for UInt64);
    atomic_store(result, (unint64_t *)&qword_1004073B0);
  }

  return result;
}

unint64_t sub_1000BFEF4()
{
  unint64_t result = qword_1004073B8;
  if (!qword_1004073B8)
  {
    unint64_t result = swift_getWitnessTable(&protocol conformance descriptor for UInt32, &type metadata for UInt32);
    atomic_store(result, (unint64_t *)&qword_1004073B8);
  }

  return result;
}

unint64_t sub_1000BFF38()
{
  unint64_t result = qword_1004073C0;
  if (!qword_1004073C0)
  {
    unint64_t result = swift_getWitnessTable(&protocol conformance descriptor for UInt16, &type metadata for UInt16);
    atomic_store(result, (unint64_t *)&qword_1004073C0);
  }

  return result;
}

unint64_t sub_1000BFF7C()
{
  unint64_t result = qword_1004073C8;
  if (!qword_1004073C8)
  {
    unint64_t result = swift_getWitnessTable(&protocol conformance descriptor for UInt8, &type metadata for UInt8);
    atomic_store(result, (unint64_t *)&qword_1004073C8);
  }

  return result;
}

unint64_t sub_1000BFFC0()
{
  unint64_t result = qword_1004073D0;
  if (!qword_1004073D0)
  {
    unint64_t result = swift_getWitnessTable(&protocol conformance descriptor for UInt, &type metadata for UInt);
    atomic_store(result, (unint64_t *)&qword_1004073D0);
  }

  return result;
}

unint64_t sub_1000C0004()
{
  unint64_t result = qword_1004073D8;
  if (!qword_1004073D8)
  {
    unint64_t result = swift_getWitnessTable(&protocol conformance descriptor for Int64, &type metadata for Int64);
    atomic_store(result, (unint64_t *)&qword_1004073D8);
  }

  return result;
}

unint64_t sub_1000C0048()
{
  unint64_t result = qword_1004073E0;
  if (!qword_1004073E0)
  {
    unint64_t result = swift_getWitnessTable(&protocol conformance descriptor for Int32, &type metadata for Int32);
    atomic_store(result, (unint64_t *)&qword_1004073E0);
  }

  return result;
}

unint64_t sub_1000C008C()
{
  unint64_t result = qword_1004073E8;
  if (!qword_1004073E8)
  {
    unint64_t result = swift_getWitnessTable(&protocol conformance descriptor for Int16, &type metadata for Int16);
    atomic_store(result, (unint64_t *)&qword_1004073E8);
  }

  return result;
}

unint64_t sub_1000C00D0()
{
  unint64_t result = qword_1004073F0;
  if (!qword_1004073F0)
  {
    unint64_t result = swift_getWitnessTable(&protocol conformance descriptor for Int8, &type metadata for Int8);
    atomic_store(result, (unint64_t *)&qword_1004073F0);
  }

  return result;
}

unint64_t sub_1000C0114()
{
  unint64_t result = qword_100410440;
  if (!qword_100410440)
  {
    unint64_t result = swift_getWitnessTable(&protocol conformance descriptor for Int, &type metadata for Int);
    atomic_store(result, (unint64_t *)&qword_100410440);
  }

  return result;
}

uint64_t sub_1000C0158(uint64_t a1)
{
  return static Array._allocateUninitialized(_:)(0LL, a1);
}

unint64_t sub_1000C0164(__int16 a1, uint64_t a2)
{
  uint64_t v3 = (HIBYTE(a1) - a1);
  unsigned int v26 = HIBYTE(a1);
  unsigned __int8 v27 = a1;
  else {
    uint64_t v4 = (HIBYTE(a1) - a1);
  }
  if (!v4) {
    return (unint64_t)_swiftEmptyArrayStorage;
  }
  unint64_t result = sub_100069708(0, v4 & ~(v4 >> 63), 0);
  if ((v4 & 0x8000000000000000LL) == 0)
  {
    LODWORD(v7)  = v26 - v27;
    if (v26 >= v27) {
      uint64_t v7 = v7;
    }
    else {
      uint64_t v7 = 0LL;
    }
    uint64_t v8 = -v7;
    while (v4)
    {
      uint64_t v9 = *(void *)(a2 + 24);
      uint64_t v10 = *(void *)(a2 + 32);
      sub_1000237C8(a2, v9);
      char v11 = dispatch thunk of UnkeyedDecodingContainer.decode(_:)(v9, v10);
      if (v2) {
        goto LABEL_23;
      }
      char v12 = v11;
      uint64_t v29 = v4;
      uint64_t v13 = *(void *)(a2 + 24);
      uint64_t v14 = *(void *)(a2 + 32);
      sub_1000237C8(a2, v13);
      LOBYTE(v14)  = dispatch thunk of UnkeyedDecodingContainer.decode(_:)(v13, v14);
      uint64_t v28 = v3;
      uint64_t v15 = *(void *)(a2 + 24);
      uint64_t v16 = *(void *)(a2 + 32);
      sub_1000237C8(a2, v15);
      char v17 = dispatch thunk of UnkeyedDecodingContainer.decode(_:)(v15, v16);
      unint64_t result = sub_1000D2134(v12, v14);
      if ((result & 0xFF00000000LL) == 0x300000000LL || BYTE4(result) < 2u)
      {
        unint64_t v23 = sub_1000033FC();
        uint64_t v24 = swift_allocError(&type metadata for WiFiError, v23, 0LL, 0LL);
        *(_OWORD *)uint64_t v25 = xmmword_100337020;
        *(_BYTE *)(v25 + 16)  = 2;
        swift_willThrow(v24);
LABEL_23:
        swift_release(_swiftEmptyArrayStorage);
        return (unint64_t)_swiftEmptyArrayStorage;
      }

      unint64_t v19 = result;
      unint64_t v21 = _swiftEmptyArrayStorage[2];
      unint64_t v20 = _swiftEmptyArrayStorage[3];
      if (v21 >= v20 >> 1) {
        unint64_t result = sub_100069708(v20 > 1, v21 + 1, 1);
      }
      _swiftEmptyArrayStorage[2]  = v21 + 1;
      uint64_t v22 = &_swiftEmptyArrayStorage[v21];
      *((_DWORD *)v22 + 8)  = v19;
      *((_BYTE *)v22 + 36)  = BYTE4(v19);
      *((_BYTE *)v22 + 37)  = BYTE5(v19);
      *((_BYTE *)v22 + 38)  = v17;
      if (v26 < v27) {
        goto LABEL_26;
      }
      if (!v8) {
        goto LABEL_27;
      }
      ++v8;
      uint64_t v4 = v29 - 1;
      uint64_t v3 = v28 - 1;
      if (v28 == 1) {
        return (unint64_t)_swiftEmptyArrayStorage;
      }
    }

    __break(1u);
LABEL_26:
    __break(1u);
LABEL_27:
    __break(1u);
  }

  __break(1u);
  return result;
}

void sub_1000C03A8(__int16 a1, uint64_t a2)
{
  unsigned int v41 = HIBYTE(a1);
  uint64_t v40 = (HIBYTE(a1) - a1);
  else {
    uint64_t v3 = (HIBYTE(a1) - a1);
  }
  if (!v3) {
    return;
  }
  unsigned __int8 v5 = a1;
  sub_100069808(0, v3 & ~(v3 >> 63), 0);
  if (v3 < 0) {
    goto LABEL_52;
  }
  uint64_t v6 = 0LL;
  LODWORD(v7)  = v41 - v5;
  if (v41 >= v5) {
    uint64_t v7 = v7;
  }
  else {
    uint64_t v7 = 0LL;
  }
  uint64_t v38 = v3;
  uint64_t v39 = v7;
  while (v6 != v3)
  {
    uint64_t v8 = *(void *)(a2 + 24);
    uint64_t v9 = *(void *)(a2 + 32);
    sub_1000237C8(a2, v8);
    unsigned __int8 v10 = dispatch thunk of UnkeyedDecodingContainer.decode(_:)(v8, v9);
    if (v2)
    {
      swift_release(_swiftEmptyArrayStorage);
      return;
    }

    unsigned __int8 v11 = v10;
    if (qword_100404370 != -1) {
      swift_once(&qword_100404370, sub_10018635C);
    }
    char v12 = off_10040A198;
    if (*((void *)off_10040A198 + 2))
    {
      uint64_t v13 = static Hasher._hash(seed:bytes:count:)(*((void *)off_10040A198 + 5), v11, 4LL);
      uint64_t v14 = -1LL << v12[32];
      unint64_t v15 = v13 & ~v14;
      if (((*(void *)&v12[((v15 >> 3) & 0xFFFFFFFFFFFFF8LL) + 56] >> v15) & 1) != 0)
      {
        uint64_t v16 = *((void *)v12 + 6);
        if (*(_DWORD *)(v16 + 4 * v15) == v11)
        {
LABEL_20:
          char v18 = 0;
          char v19 = 3;
          goto LABEL_36;
        }

        uint64_t v17 = ~v14;
        while (1)
        {
          unint64_t v15 = (v15 + 1) & v17;
          if (((*(void *)&v12[((v15 >> 3) & 0xFFFFFFFFFFFFF8LL) + 56] >> v15) & 1) == 0) {
            break;
          }
          if (*(_DWORD *)(v16 + 4 * v15) == v11) {
            goto LABEL_20;
          }
        }
      }
    }

    if (qword_100404378 != -1) {
      swift_once(&qword_100404378, sub_100186380);
    }
    unint64_t v20 = off_10040A1A0;
    if (*((void *)off_10040A1A0 + 2))
    {
      uint64_t v21 = static Hasher._hash(seed:bytes:count:)(*((void *)off_10040A1A0 + 5), v11, 4LL);
      uint64_t v22 = -1LL << v20[32];
      unint64_t v23 = v21 & ~v22;
      if (((*(void *)&v20[((v23 >> 3) & 0xFFFFFFFFFFFFF8LL) + 56] >> v23) & 1) != 0)
      {
        uint64_t v24 = *((void *)v20 + 6);
        if (*(_DWORD *)(v24 + 4 * v23) == v11)
        {
LABEL_29:
          char v18 = 1;
          char v19 = 4;
          goto LABEL_36;
        }

        uint64_t v25 = ~v22;
        while (1)
        {
          unint64_t v23 = (v23 + 1) & v25;
          if (((*(void *)&v20[((v23 >> 3) & 0xFFFFFFFFFFFFF8LL) + 56] >> v23) & 1) == 0) {
            break;
          }
          if (*(_DWORD *)(v24 + 4 * v23) == v11) {
            goto LABEL_29;
          }
        }
      }
    }

    if (qword_100404380 != -1) {
      swift_once(&qword_100404380, sub_1001863A4);
    }
    unsigned int v26 = off_10040A1A8;
    if (*((void *)off_10040A1A8 + 2))
    {
      uint64_t v27 = static Hasher._hash(seed:bytes:count:)(*((void *)off_10040A1A8 + 5), v11, 4LL);
      uint64_t v28 = -1LL << v26[32];
      unint64_t v29 = v27 & ~v28;
      uint64_t v30 = v26 + 56;
      if (((*(void *)&v26[((v29 >> 3) & 0xFFFFFFFFFFFFF8LL) + 56] >> v29) & 1) != 0)
      {
        uint64_t v31 = *((void *)v26 + 6);
        if (*(_DWORD *)(v31 + 4 * v29) == v11) {
          goto LABEL_35;
        }
        uint64_t v33 = ~v28;
        unint64_t v34 = (v29 + 1) & v33;
        if (((*(void *)&v30[(v34 >> 3) & 0xFFFFFFFFFFFFF8LL] >> v34) & 1) != 0)
        {
          while (*(_DWORD *)(v31 + 4 * v34) != v11)
          {
            unint64_t v34 = (v34 + 1) & v33;
            if (((*(void *)&v30[(v34 >> 3) & 0xFFFFFFFFFFFFF8LL] >> v34) & 1) == 0) {
              goto LABEL_40;
            }
          }

LABEL_35:
          char v18 = 2;
          char v19 = 5;
LABEL_36:
          unsigned __int8 v42 = v18;
          unsigned __int8 v43 = v19;
          sub_100185C58();
          unint64_t v32 = v11 | ((unint64_t)v42 << 32) | ((unint64_t)v43 << 40);
          goto LABEL_41;
        }
      }
    }

          char v12 = __clz(__rbit64(v33)) + (v31 << 6);
        }
      }

    swift_release(v1);
    return (uint64_t)v7;
  }

  __break(1u);
LABEL_37:
  __break(1u);
  return result;
}

        LOWORD(v8)  = 0;
        uint64_t v9 = 1;
LABEL_38:
        swift_bridgeObjectRelease(a2);
        goto LABEL_39;
      }

      __break(1u);
    }

    __break(1u);
    goto LABEL_53;
  }

  uint64_t v8 = sub_1002DC100(a1, a2, 10LL);
  swift_bridgeObjectRelease(a2);
  uint64_t v9 = HIWORD(v8) & 1;
LABEL_39:
  char v18 = (unsigned __int16)v8;
  if (v9) {
    char v18 = 0;
  }
  return v18 | (v9 << 16);
}

          swift_endAccess(aBlock);
          __break(1u);
          return;
        }
      }

      else
      {
        ((void (*)(uint64_t *, void))v31)(aBlock, 0LL);
        swift_endAccess(&v137);
        uint64_t v9 = (void *)v25[1];
        ((void (*)(char *, void *))v9)(v14, a1);
      }

      unint64_t v70 = v130;
      unint64_t v69 = (uint64_t)v131;
      unint64_t v71 = ((uint64_t (*)(char *, char *, void *))v115)(v130, v131, a1);
      unint64_t v72 = (os_log_s *)Logger.logObject.getter(v71);
      uint64_t v73 = static os_log_type_t.info.getter();
      if (os_log_type_enabled(v72, v73))
      {
        uint64_t v74 = (uint8_t *)swift_slowAlloc(12LL, -1LL);
        unint64_t v75 = swift_slowAlloc(32LL, -1LL);
        uint64_t v114 = (void (*)(char *, void *))v9;
        unint64_t v76 = v75;
        aBlock[0]  = v75;
        *(_DWORD *)uint64_t v74 = 136315138;
        uint64_t v77 = sub_10000AF70( (unint64_t *)&qword_10040D5B0,  (uint64_t (*)(uint64_t))&type metadata accessor for UUID,  (uint64_t)&protocol conformance descriptor for UUID);
        unint64_t v78 = dispatch thunk of CustomStringConvertible.description.getter(a1, v77);
        unint64_t v80 = v79;
        *(void *)&uint64_t v137 = sub_10000235C(v78, v79, aBlock);
        UnsafeMutableRawBufferPointer.copyMemory(from:)(&v137, (char *)&v137 + 8);
        unint64_t v81 = swift_bridgeObjectRelease(v80);
        uint64_t v82 = (void (*)(uint64_t, void *))v114;
        ((void (*)(char *, void *, __n128))v114)(v70, a1, v81);
        _os_log_impl((void *)&_mh_execute_header, v72, v73, "No client previously asserted for %s", v74, 0xCu);
        swift_arrayDestroy(v76, 1LL, &type metadata for Any[8]);
        swift_slowDealloc(v76, -1LL, -1LL);
        swift_slowDealloc(v74, -1LL, -1LL);

        v82(v69, a1);
      }

      else
      {
        ((void (*)(char *, void *))v9)(v70, a1);

        ((void (*)(uint64_t, void *))v9)(v69, a1);
      }

      return;
    }
  }

  else
  {
    sub_1000225EC((uint64_t)&v137, &qword_100405280);
    ((void (*)(char *, uint64_t, uint64_t, void *))v25[7])(v8, 1LL, 1LL, v9);
  }

  unint64_t v65 = sub_1000225EC((uint64_t)v8, qword_100410330);
  uint64_t v66 = (os_log_s *)Logger.logObject.getter(v65);
  uint64_t v67 = static os_log_type_t.error.getter(v66);
  if (os_log_type_enabled(v66, v67))
  {
    unint64_t v68 = (uint8_t *)swift_slowAlloc(2LL, -1LL);
    *(_WORD *)unint64_t v68 = 0;
    _os_log_impl((void *)&_mh_execute_header, v66, v67, "Failed to unassert because no UUID found", v68, 2u);
    swift_slowDealloc(v68, -1LL, -1LL);
  }
}

void sub_1000C07A4(__int16 a1, uint64_t a2)
{
  uint64_t v3 = v2;
  uint64_t v4 = (HIBYTE(a1) - a1);
  unsigned int v15 = HIBYTE(a1);
  unsigned __int8 v16 = a1;
  else {
    uint64_t v5 = (HIBYTE(a1) - a1);
  }
  if (v5)
  {
    unint64_t v20 = _swiftEmptyArrayStorage;
    sub_100069808(0, v5 & ~(v5 >> 63), 0);
    if ((v5 & 0x8000000000000000LL) == 0)
    {
      uint64_t v6 = v20;
      LODWORD(v7)  = v15 - v16;
      if (v15 >= v16) {
        uint64_t v7 = v7;
      }
      else {
        uint64_t v7 = 0LL;
      }
      uint64_t v8 = -v7;
      while (v5)
      {
        sub_1000D1F00(a2, &v17, (uint64_t)&v18);
        if (v3)
        {
          swift_release(v6);
          return;
        }

        uint64_t v3 = 0LL;
        uint64_t v9 = v19;
        uint64_t v10 = v18;
        unint64_t v20 = v6;
        unint64_t v12 = v6[2];
        unint64_t v11 = v6[3];
        if (v12 >= v11 >> 1)
        {
          sub_100069808(v11 > 1, v12 + 1, 1);
          uint64_t v6 = v20;
        }

        _OWORD v6[2] = v12 + 1;
        uint64_t v13 = &v6[v12];
        *((_DWORD *)v13 + 8)  = v10;
        *((_WORD *)v13 + 18)  = (v10 | (unint64_t)(v9 << 32)) >> 32;
        if (v15 < v16) {
          goto LABEL_21;
        }
        if (!v8) {
          goto LABEL_22;
        }
        ++v8;
        --v5;
        if (!--v4) {
          return;
        }
      }

      __break(1u);
LABEL_21:
      __break(1u);
LABEL_22:
      __break(1u);
    }

    __break(1u);
  }

void *sub_1000C090C(__int16 a1, uint64_t a2)
{
  uint64_t v3 = (HIBYTE(a1) - a1);
  unsigned int v21 = HIBYTE(a1);
  unsigned __int8 v22 = a1;
  else {
    uint64_t v4 = (HIBYTE(a1) - a1);
  }
  unint64_t result = _swiftEmptyArrayStorage;
  if (v4)
  {
    unint64_t result = (void *)sub_100069808(0, v4 & ~(v4 >> 63), 0);
    if ((v4 & 0x8000000000000000LL) == 0)
    {
      unint64_t result = _swiftEmptyArrayStorage;
      LODWORD(v7)  = v21 - v22;
      if (v21 >= v22) {
        uint64_t v7 = v7;
      }
      else {
        uint64_t v7 = 0LL;
      }
      uint64_t v8 = -v7;
      while (v4)
      {
        uint64_t v23 = v3;
        uint64_t v9 = result;
        uint64_t v10 = *(void *)(a2 + 24);
        uint64_t v11 = *(void *)(a2 + 32);
        sub_1000237C8(a2, v10);
        char v12 = dispatch thunk of UnkeyedDecodingContainer.decode(_:)(v10, v11);
        if (v2) {
          return (void *)swift_release(v9);
        }
        char v13 = v12;
        uint64_t v14 = *(void *)(a2 + 24);
        uint64_t v15 = *(void *)(a2 + 32);
        sub_1000237C8(a2, v14);
        char v16 = dispatch thunk of UnkeyedDecodingContainer.decode(_:)(v14, v15);
        unint64_t v17 = sub_1000D2134(v13, v16);
        unint64_t result = v9;
        unint64_t v19 = v9[2];
        unint64_t v18 = v9[3];
        if (v19 >= v18 >> 1)
        {
          sub_100069808(v18 > 1, v19 + 1, 1);
          unint64_t result = v9;
        }

        result[2]  = v19 + 1;
        unint64_t v20 = &result[v19];
        *((_DWORD *)v20 + 8)  = v17;
        *((_WORD *)v20 + 18)  = WORD2(v17);
        if (v21 < v22) {
          goto LABEL_21;
        }
        if (!v8) {
          goto LABEL_22;
        }
        ++v8;
        --v4;
        uint64_t v3 = v23 - 1;
        if (v23 == 1) {
          return result;
        }
      }

      __break(1u);
LABEL_21:
      __break(1u);
LABEL_22:
      __break(1u);
    }

    __break(1u);
  }

  return result;
}

uint64_t AWDLActionFrame.DataPathState.UnicastMasterIndicationOptions.rawValue.getter(char a1)
{
  return dword_100345098[a1];
}

BOOL AWDLActionFrame.OUIType.init(rawValue:)(char a1)
{
  return a1 != 8;
}

_BYTE *sub_1000C0AE0@<X0>(_BYTE *result@<X0>, BOOL *a2@<X8>)
{
  *a2  = *result != 8;
  return result;
}

void sub_1000C0AF4(_BYTE *a1@<X8>)
{
  *a1  = 8;
}

uint64_t sub_1000C0B00(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v6 = sub_1000E4DFC();
  return RawRepresentable<>.init(from:)(a1, a2, a3, v6);
}

uint64_t sub_1000C0B5C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v6 = sub_1000E4DFC();
  return RawRepresentable<>.encode(to:)(a1, a2, a3, v6);
}

Swift::Int sub_1000C0BA8()
{
  return Hasher._finalize()();
}

void sub_1000C0BE8()
{
}

Swift::Int sub_1000C0C0C(uint64_t a1)
{
  return Hasher._finalize()();
}

CoreP2P::AWDLActionFrame::OUISubtype_optional __swiftcall AWDLActionFrame.OUISubtype.init(rawValue:)( Swift::UInt8 rawValue)
{
  if (rawValue == 3) {
    v1.value  = CoreP2P_AWDLActionFrame_OUISubtype_masterIndication;
  }
  else {
    v1.value  = CoreP2P_AWDLActionFrame_OUISubtype_unknownDefault;
  }
  if (rawValue) {
    return v1;
  }
  else {
    return 0;
  }
}

uint64_t AWDLActionFrame.OUISubtype.rawValue.getter(int a1)
{
  return (a1 << 31 >> 31) & 3;
}

_BYTE *sub_1000C0C70@<X0>(_BYTE *result@<X0>, char *a2@<X8>)
{
  if (*result == 3) {
    char v2 = 1;
  }
  else {
    char v2 = 2;
  }
  if (*result) {
    char v3 = v2;
  }
  else {
    char v3 = 0;
  }
  *a2  = v3;
  return result;
}

void sub_1000C0C90(char *a1@<X8>)
{
  if (*v1) {
    char v2 = 3;
  }
  else {
    char v2 = 0;
  }
  *a1  = v2;
}

uint64_t sub_1000C0CA8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v6 = sub_1000E4DB8();
  return RawRepresentable<>.init(from:)(a1, a2, a3, v6);
}

uint64_t sub_1000C0D04(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v6 = sub_1000E4DB8();
  return RawRepresentable<>.encode(to:)(a1, a2, a3, v6);
}

Swift::Int sub_1000C0D50()
{
  int v1 = *v0;
  Hasher.init(_seed:)(v4, 0LL);
  if (v1) {
    Swift::UInt8 v2 = 3;
  }
  else {
    Swift::UInt8 v2 = 0;
  }
  Hasher._combine(_:)(v2);
  return Hasher._finalize()();
}

void sub_1000C0D9C()
{
  if (*v0) {
    Swift::UInt8 v1 = 3;
  }
  else {
    Swift::UInt8 v1 = 0;
  }
  Hasher._combine(_:)(v1);
}

Swift::Int sub_1000C0DD0(uint64_t a1)
{
  int v2 = *v1;
  Hasher.init(_seed:)(v5, a1);
  if (v2) {
    Swift::UInt8 v3 = 3;
  }
  else {
    Swift::UInt8 v3 = 0;
  }
  Hasher._combine(_:)(v3);
  return Hasher._finalize()();
}

uint64_t NANInternetSharingStatistics.Provider.onEthernet.getter(unsigned int a1)
{
  return (a1 >> 8) & 1;
}

uint64_t AWDLActionFrame.AirDrop.state.setter(uint64_t result)
{
  *(_BYTE *)(v1 + 1)  = result & 1;
  return result;
}

uint64_t AWDLActionFrame.ProMode.status.setter(uint64_t result)
{
  *(_DWORD *)(v1 + 4)  = result;
  return result;
}

uint64_t NANDiscoveryBeaconTransmissionSchedule.entries.getter(uint64_t a1, uint64_t a2)
{
  return swift_bridgeObjectRetain(a2);
}

void AWDLActionFrame.ServiceRequest.hash(into:)(int a1, unsigned int a2, uint64_t a3)
{
  unsigned int v4 = HIWORD(a2);
  Hasher._combine(_:)(a2);
  Hasher._combine(_:)(v4);
  Swift::UInt v5 = *(void *)(a3 + 16);
  Hasher._combine(_:)(v5);
  if (v5)
  {
    unint64_t v6 = (Swift::UInt8 *)(a3 + 32);
    do
    {
      Swift::UInt8 v7 = *v6++;
      Hasher._combine(_:)(v7);
      --v5;
    }

    while (v5);
  }

uint64_t static AWDLActionFrame.ServiceRequest.__derived_struct_equals(_:_:)( int a1, uint64_t a2, int a3, uint64_t a4)
{
  if (a1 == a3) {
    return sub_10007990C(a2, a4);
  }
  else {
    return 0LL;
  }
}

uint64_t sub_1000C0EB8()
{
  uint64_t v1 = 7955819LL;
  if (*v0 == 1) {
    uint64_t v1 = 0x6574736575716572LL;
  }
  if (*v0) {
    return v1;
  }
  else {
    return 0x6574736575716572LL;
  }
}

uint64_t sub_1000C0F14@<X0>(uint64_t a1@<X0>, unint64_t a2@<X1>, _BYTE *a3@<X8>)
{
  uint64_t result = sub_1000E2F60(a1, a2);
  *a3  = result;
  return result;
}

uint64_t sub_1000C0F38(uint64_t a1)
{
  unint64_t v2 = sub_1000C1108();
  return CodingKey.description.getter(a1, v2);
}

uint64_t sub_1000C0F60(uint64_t a1)
{
  unint64_t v2 = sub_1000C1108();
  return CodingKey.debugDescription.getter(a1, v2);
}

uint64_t AWDLActionFrame.ServiceRequest.encode(to:)(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v7 = sub_100002274(&qword_100407400);
  uint64_t v8 = *(void *)(v7 - 8);
  __chkstk_darwin(v7);
  uint64_t v10 = (char *)&v17 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v11 = a1[3];
  uint64_t v12 = a1[4];
  sub_100021104(a1, v11);
  unint64_t v13 = sub_1000C1108();
  dispatch thunk of Encoder.container<A>(keyedBy:)( &type metadata for AWDLActionFrame.ServiceRequest.CodingKeys,  &type metadata for AWDLActionFrame.ServiceRequest.CodingKeys,  v13,  v11,  v12);
  char v21 = 0;
  KeyedEncodingContainer.encode(_:forKey:)(a2, &v21, v7);
  if (!v3)
  {
    char v20 = 1;
    KeyedEncodingContainer.encode(_:forKey:)(WORD1(a2), &v20, v7);
    uint64_t v18 = a3;
    char v19 = 2;
    uint64_t v14 = sub_100002274(&qword_100406978);
    uint64_t v15 = sub_1000E5170( (unint64_t *)&qword_100407410,  (uint64_t)&protocol witness table for UInt8,  (uint64_t)&protocol conformance descriptor for <A> [A]);
    KeyedEncodingContainer.encode<A>(_:forKey:)(&v18, &v19, v7, v14, v15);
  }

  return (*(uint64_t (**)(char *, uint64_t))(v8 + 8))(v10, v7);
}

unint64_t sub_1000C1108()
{
  unint64_t result = qword_100407408;
  if (!qword_100407408)
  {
    unint64_t result = swift_getWitnessTable(&unk_100344B0C, &type metadata for AWDLActionFrame.ServiceRequest.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_100407408);
  }

  return result;
}

Swift::Int AWDLActionFrame.ServiceRequest.hashValue.getter(unsigned int a1, uint64_t a2)
{
  Swift::UInt16 v3 = a1;
  unsigned int v4 = HIWORD(a1);
  Hasher.init(_seed:)(v9, 0LL);
  Hasher._combine(_:)(v3);
  Hasher._combine(_:)(v4);
  Swift::UInt v5 = *(void *)(a2 + 16);
  Hasher._combine(_:)(v5);
  if (v5)
  {
    unint64_t v6 = (Swift::UInt8 *)(a2 + 32);
    do
    {
      Swift::UInt8 v7 = *v6++;
      Hasher._combine(_:)(v7);
      --v5;
    }

    while (v5);
  }

  return Hasher._finalize()();
}

uint64_t AWDLActionFrame.ServiceRequest.init(from:)(void *a1)
{
  return sub_1000D8D2C(a1);
}

uint64_t sub_1000C11EC@<X0>(void *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t result = sub_1000D8D2C(a1);
  if (!v2)
  {
    *(_DWORD *)a2  = result;
    *(void *)(a2 + 8)  = v5;
  }

  return result;
}

uint64_t sub_1000C1220(void *a1)
{
  return AWDLActionFrame.ServiceRequest.encode(to:)(a1, *v1, *((void *)v1 + 1));
}

Swift::Int sub_1000C123C()
{
  return AWDLActionFrame.ServiceRequest.hashValue.getter(*(_DWORD *)v0, *(void *)(v0 + 8));
}

void sub_1000C1248(int a1)
{
}

Swift::Int sub_1000C1254(uint64_t a1)
{
  uint64_t v2 = *(void *)(v1 + 8);
  Swift::UInt16 v3 = *(_WORD *)v1;
  Swift::UInt16 v4 = *(_WORD *)(v1 + 2);
  Hasher.init(_seed:)(v9, a1);
  Hasher._combine(_:)(v3);
  Hasher._combine(_:)(v4);
  Swift::UInt v5 = *(void *)(v2 + 16);
  Hasher._combine(_:)(v5);
  if (v5)
  {
    unint64_t v6 = (Swift::UInt8 *)(v2 + 32);
    do
    {
      Swift::UInt8 v7 = *v6++;
      Hasher._combine(_:)(v7);
      --v5;
    }

    while (v5);
  }

  return Hasher._finalize()();
}

uint64_t sub_1000C12DC(unsigned __int16 *a1, unsigned __int16 *a2)
{
  if (*a1 == *a2 && a1[1] == a2[1]) {
    return sub_10007990C(*((void *)a1 + 1), *((void *)a2 + 1));
  }
  else {
    return 0LL;
  }
}

uint64_t AWDLActionFrame.ServiceResponse.hash(into:)(uint64_t a1)
{
  uint64_t v2 = v1;
  Swift::UInt16 v4 = (int *)type metadata accessor for DNSRecords.SRV(0LL);
  __chkstk_darwin(v4);
  unint64_t v6 = (char *)&v41 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v7 = type metadata accessor for AWDLActionFrame.ServiceResponse(0LL);
  __chkstk_darwin(v7);
  uint64_t v9 = (char *)&v41 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  sub_100057FE8(v2, (uint64_t)v9, v10);
  int EnumCaseMultiPayload = swift_getEnumCaseMultiPayload(v9, v7);
  if (EnumCaseMultiPayload)
  {
    if (EnumCaseMultiPayload == 1)
    {
      uint64_t v12 = *((void *)v9 + 1);
      uint64_t v13 = *((void *)v9 + 3);
      int v14 = v9[32];
      uint64_t v15 = *((void *)v9 + 5);
      unint64_t v16 = *((void *)v9 + 6);
      Swift::UInt8 v17 = v9[33];
      Hasher._combine(_:)(1uLL);
      Swift::String v18 = String.lowercased()();
      swift_bridgeObjectRetain(v12);
      swift_bridgeObjectRetain(v13);
      String.hash(into:)(a1, v18._countAndFlagsBits, v18._object);
      swift_bridgeObjectRelease(v18._object);
      Swift::String v19 = String.lowercased()();
      swift_bridgeObjectRetain(v13);
      String.hash(into:)(a1, v19._countAndFlagsBits, v19._object);
      swift_bridgeObjectRelease(v19._object);
      if (v14) {
        uint64_t v20 = 7365749LL;
      }
      else {
        uint64_t v20 = 7365492LL;
      }
      String.hash(into:)(a1, v20, 0xE300000000000000LL);
      swift_bridgeObjectRelease(0xE300000000000000LL);
      Hasher._combine(_:)(v17);
      swift_bridgeObjectRelease(v12);
      swift_bridgeObjectRelease_n(v13, 2LL);
      sub_100020AFC(v15, v16);
      Data.hash(into:)(a1, v15, v16);
      sub_1000208D8(v15, v16);
      swift_bridgeObjectRelease(v13);
      swift_bridgeObjectRelease(v12);
      return sub_1000208D8(v15, v16);
    }

    else
    {
      sub_100022628((uint64_t)v9, (uint64_t)v6, type metadata accessor for DNSRecords.SRV);
      Hasher._combine(_:)(2uLL);
      uint64_t v29 = *((void *)v6 + 1);
      uint64_t v30 = *((void *)v6 + 3);
      int v31 = v6[32];
      Swift::UInt8 v32 = v6[33];
      Swift::String v33 = String.lowercased()();
      swift_bridgeObjectRetain(v29);
      swift_bridgeObjectRetain(v30);
      String.hash(into:)(a1, v33._countAndFlagsBits, v33._object);
      swift_bridgeObjectRelease(v33._object);
      Swift::String v34 = String.lowercased()();
      swift_bridgeObjectRetain(v30);
      String.hash(into:)(a1, v34._countAndFlagsBits, v34._object);
      swift_bridgeObjectRelease(v34._object);
      if (v31) {
        uint64_t v35 = 7365749LL;
      }
      else {
        uint64_t v35 = 7365492LL;
      }
      String.hash(into:)(a1, v35, 0xE300000000000000LL);
      swift_bridgeObjectRelease(0xE300000000000000LL);
      Hasher._combine(_:)(v32);
      swift_bridgeObjectRelease(v29);
      swift_bridgeObjectRelease_n(v30, 2LL);
      uint64_t v36 = type metadata accessor for NWEndpoint.Port(0LL);
      uint64_t v37 = sub_10000AF70( &qword_100406338,  (uint64_t (*)(uint64_t))&type metadata accessor for NWEndpoint.Port,  (uint64_t)&protocol conformance descriptor for NWEndpoint.Port);
      dispatch thunk of Hashable.hash(into:)(a1, v36, v37);
      uint64_t v38 = &v6[v4[6]];
      uint64_t v39 = *(void *)v38;
      uint64_t v40 = *((void *)v38 + 1);
      swift_bridgeObjectRetain(v40);
      String.hash(into:)(a1, v39, v40);
      swift_bridgeObjectRelease(v40);
      Hasher._combine(_:)(*(_WORD *)&v6[v4[7]]);
      Hasher._combine(_:)(*(_WORD *)&v6[v4[8]]);
      return sub_10005802C((uint64_t)v6, type metadata accessor for DNSRecords.SRV);
    }
  }

  else
  {
    uint64_t v22 = *((void *)v9 + 1);
    uint64_t v23 = *((void *)v9 + 3);
    int v24 = v9[32];
    Swift::UInt8 v25 = v9[33];
    Hasher._combine(_:)(0LL);
    Swift::String v26 = String.lowercased()();
    String.hash(into:)(a1, v26._countAndFlagsBits, v26._object);
    swift_bridgeObjectRelease(v26._object);
    Swift::String v27 = String.lowercased()();
    swift_bridgeObjectRetain(v23);
    String.hash(into:)(a1, v27._countAndFlagsBits, v27._object);
    swift_bridgeObjectRelease(v27._object);
    if (v24) {
      uint64_t v28 = 7365749LL;
    }
    else {
      uint64_t v28 = 7365492LL;
    }
    String.hash(into:)(a1, v28, 0xE300000000000000LL);
    swift_bridgeObjectRelease(0xE300000000000000LL);
    Hasher._combine(_:)(v25);
    swift_bridgeObjectRelease(v22);
    return swift_bridgeObjectRelease_n(v23, 2LL);
  }

Swift::Int AWDLActionFrame.ServiceResponse.hashValue.getter()
{
  return sub_1000D3134((void (*)(void *))AWDLActionFrame.ServiceResponse.hash(into:));
}

uint64_t sub_1000C1760@<X0>(void *a1@<X0>, uint64_t a2@<X8>)
{
  return AWDLActionFrame.ServiceResponse.init(from:)(a1, a2);
}

uint64_t sub_1000C1774(void *a1)
{
  return AWDLActionFrame.ServiceResponse.encode(to:)(a1);
}

Swift::Int sub_1000C1788(uint64_t a1, uint64_t a2)
{
  return sub_1000D3180(a1, a2, (void (*)(void *))AWDLActionFrame.ServiceResponse.hash(into:));
}

Swift::Int sub_1000C1798(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_1000CBB80(a1, a2, a3, (void (*)(void *))AWDLActionFrame.ServiceResponse.hash(into:));
}

void AWDLActionFrame.AWDLChannelSequenceParameter.hash(into:)(uint64_t a1, uint64_t a2)
{
  Swift::UInt v3 = *(void *)(a2 + 16);
  Hasher._combine(_:)(v3);
  if (v3)
  {
    Swift::UInt16 v4 = (unsigned int *)(a2 + 32);
    do
    {
      unint64_t v6 = *v4 | ((unint64_t)*((unsigned __int16 *)v4 + 2) << 32);
      if ((v6 & 0xFF00000000LL) == 0x300000000LL)
      {
        Swift::UInt8 v5 = 0;
LABEL_4:
        Hasher._combine(_:)(v5);
      }

      else
      {
        Hasher._combine(_:)(1u);
        Hasher._combine(_:)(v6);
        Hasher._combine(_:)(0x801004u >> ((v6 >> 29) & 0xF8));
        switch(v6 >> 40)
        {
          case 2uLL:
            Hasher._combine(_:)(0LL);
            break;
          case 3uLL:
            Hasher._combine(_:)(1uLL);
            break;
          case 4uLL:
            Hasher._combine(_:)(3uLL);
            break;
          case 5uLL:
            Hasher._combine(_:)(4uLL);
            break;
          case 6uLL:
            Hasher._combine(_:)(5uLL);
            break;
          default:
            Hasher._combine(_:)(2uLL);
            Swift::UInt8 v5 = BYTE5(v6) & 1;
            goto LABEL_4;
        }
      }

      v4 += 2;
      --v3;
    }

    while (v3);
  }

Swift::Int ChannelSequence.hashValue.getter(uint64_t a1)
{
  return Hasher._finalize()();
}

uint64_t sub_1000C1908@<X0>(void *a1@<X0>, uint64_t *a2@<X8>)
{
  uint64_t result = AWDLActionFrame.AWDLChannelSequenceParameter.init(from:)(a1);
  if (!v2) {
    *a2  = result;
  }
  return result;
}

uint64_t AWDLActionFrame.AWDLChannelSequenceParameter.init(from:)(void *a1)
{
  return sub_1000DB1B4(a1);
}

uint64_t sub_1000C1944(void *a1)
{
  uint64_t v3 = *v1;
  uint64_t v4 = a1[3];
  uint64_t v5 = a1[4];
  sub_100021104(a1, v4);
  dispatch thunk of Encoder.unkeyedContainer()(v11, v4, v5);
  sub_1000D1778((uint64_t)v11, 3u, v3);
  if (!v2)
  {
    uint64_t v6 = v12;
    uint64_t v7 = v13;
    sub_1000237C8((uint64_t)v11, v12);
    dispatch thunk of UnkeyedEncodingContainer.encode(_:)(0LL, v6, v7);
    uint64_t v8 = v12;
    uint64_t v9 = v13;
    sub_1000237C8((uint64_t)v11, v12);
    dispatch thunk of UnkeyedEncodingContainer.encode(_:)(0LL, v8, v9);
  }

  return sub_100002AC4(v11);
}

uint64_t AWDLActionFrame.AWDLChannelSequenceParameter.encode(to:)(void *a1, uint64_t a2)
{
  uint64_t v4 = a1[3];
  uint64_t v5 = a1[4];
  sub_100021104(a1, v4);
  dispatch thunk of Encoder.unkeyedContainer()(v11, v4, v5);
  sub_1000D1778((uint64_t)v11, 3u, a2);
  if (!v2)
  {
    uint64_t v6 = v12;
    uint64_t v7 = v13;
    sub_1000237C8((uint64_t)v11, v12);
    dispatch thunk of UnkeyedEncodingContainer.encode(_:)(0LL, v6, v7);
    uint64_t v8 = v12;
    uint64_t v9 = v13;
    sub_1000237C8((uint64_t)v11, v12);
    dispatch thunk of UnkeyedEncodingContainer.encode(_:)(0LL, v8, v9);
  }

  return sub_100002AC4(v11);
}

Swift::Int sub_1000C1AFC()
{
  uint64_t v1 = *v0;
  Hasher.init(_seed:)(v3, 0LL);
  sub_100082C84((uint64_t)v3, v1);
  return Hasher._finalize()();
}

void sub_1000C1B40(uint64_t a1)
{
}

Swift::Int sub_1000C1B48(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_1000C8768( a1,  a2,  a3,  (void (*)(void *, uint64_t))AWDLActionFrame.AWDLChannelSequenceParameter.hash(into:));
}

uint64_t sub_1000C1B54(uint64_t *a1, uint64_t *a2)
{
  return _s7CoreP2P15AWDLActionFrameV28AWDLChannelSequenceParameterV23__derived_struct_equalsySbAE_AEtFZ_0(*a1, *a2);
}

uint64_t AWDLPeer.AdvertisedService.instanceID.getter()
{
  return *v0;
}

uint64_t AWDLActionFrame.SynchronizationParameter.downCounter.getter()
{
  return *(unsigned __int16 *)(v0 + 2);
}

uint64_t AWDLActionFrame.SynchronizationParameter.masterHomeChannel.getter()
{
  return *(unsigned __int8 *)(v0 + 4);
}

uint64_t AWDLActionFrame.SynchronizationParameter.guardTime.getter()
{
  return *(unsigned __int8 *)(v0 + 5);
}

uint64_t Channel.bandwidth.setter(uint64_t result)
{
  *(_BYTE *)(v1 + 5)  = result;
  return result;
}

uint64_t (*Channel.bandwidth.modify())()
{
  return NANBitmap.Channel.operatingClass.getter;
}

uint64_t AWDLActionFrame.SynchronizationParameter.availabilityWindowPeriod.getter()
{
  return *(unsigned __int16 *)(v0 + 6);
}

uint64_t AWDLActionFrame.SynchronizationParameter.actionFramePeriod.getter()
{
  return *(unsigned __int16 *)(v0 + 8);
}

uint64_t AWDLActionFrame.SynchronizationParameter.flags.getter()
{
  return *(unsigned __int16 *)(v0 + 10);
}

uint64_t AWDLActionFrame.SynchronizationParameter.availabilityWindowExtensionLength.getter()
{
  return *(unsigned __int16 *)(v0 + 12);
}

uint64_t AWDLActionFrame.SynchronizationParameter.availabilityWindowLength.getter()
{
  return *(unsigned __int16 *)(v0 + 14);
}

uint64_t AWDLActionFrame.SynchronizationParameter.availabilityWindowLength.setter(uint64_t result)
{
  *(_WORD *)(v1 + 14)  = result;
  return result;
}

uint64_t (*AWDLActionFrame.SynchronizationParameter.availabilityWindowLength.modify())()
{
  return NANBitmap.Channel.operatingClass.getter;
}

uint64_t AWDLActionFrame.SynchronizationParameter.availabilityWindowRemain.getter()
{
  return *(unsigned __int16 *)(v0 + 16);
}

uint64_t AWDLActionFrame.SynchronizationParameter.availabilityWindowRemain.setter(uint64_t result)
{
  *(_WORD *)(v1 + 16)  = result;
  return result;
}

uint64_t AWDLActionFrame.SynchronizationParameter.minimumExtensions.getter()
{
  return *(unsigned __int8 *)(v0 + 18);
}

uint64_t AWDLActionFrame.SynchronizationParameter.minimumExtensions.setter(uint64_t result)
{
  *(_BYTE *)(v1 + 18)  = result;
  return result;
}

uint64_t (*AWDLActionFrame.SynchronizationParameter.minimumExtensions.modify())()
{
  return NANBitmap.Channel.operatingClass.getter;
}

uint64_t NANCoreAnalyticsMetrics.singleBandPeers.getter()
{
  return *(unsigned __int8 *)(v0 + 19);
}

uint64_t NANCoreAnalyticsMetrics.singleBandPeers.setter(uint64_t result)
{
  *(_BYTE *)(v1 + 19)  = result;
  return result;
}

uint64_t (*NANCoreAnalyticsMetrics.singleBandPeers.modify())()
{
  return NANBitmap.Channel.operatingClass.getter;
}

uint64_t AWDLActionFrame.SynchronizationParameter.maximumUnicastExtensions.getter()
{
  return *(unsigned __int8 *)(v0 + 20);
}

uint64_t AWDLActionFrame.SynchronizationParameter.maximumUnicastExtensions.setter(uint64_t result)
{
  *(_BYTE *)(v1 + 20)  = result;
  return result;
}

uint64_t (*AWDLActionFrame.Header.flags.modify())()
{
  return NANBitmap.Channel.operatingClass.getter;
}

uint64_t AWDLActionFrame.SynchronizationParameter.maximumActionFrameExtensions.getter()
{
  return *(unsigned __int8 *)(v0 + 21);
}

uint64_t AWDLActionFrame.SynchronizationParameter.maximumActionFrameExtensions.setter(uint64_t result)
{
  *(_BYTE *)(v1 + 21)  = result;
  return result;
}

uint64_t (*AWDLActionFrame.SynchronizationParameter.maximumActionFrameExtensions.modify())()
{
  return NANBitmap.Channel.operatingClass.getter;
}

unint64_t AWDLActionFrame.SynchronizationParameter.master.getter()
{
  return *(unsigned __int16 *)(v0 + 22) | ((unint64_t)*(unsigned int *)(v0 + 24) << 16);
}

uint64_t AWDLActionFrame.SynchronizationParameter.master.setter(uint64_t result)
{
  *(_WORD *)(v1 + 22)  = result;
  *(_BYTE *)(v1 + 24)  = BYTE2(result);
  *(_BYTE *)(v1 + 25)  = BYTE3(result);
  *(_BYTE *)(v1 + 26)  = BYTE4(result);
  *(_BYTE *)(v1 + 27)  = BYTE5(result);
  return result;
}

uint64_t (*AWDLActionFrame.SynchronizationParameter.master.modify())()
{
  return NANBitmap.Channel.operatingClass.getter;
}

uint64_t AWDLActionFrame.SynchronizationParameter.presenceMode.getter()
{
  return *(unsigned __int8 *)(v0 + 28);
}

uint64_t AWDLActionFrame.SynchronizationParameter.presenceMode.setter(uint64_t result)
{
  *(_BYTE *)(v1 + 28)  = result;
  return result;
}

uint64_t (*AWDLActionFrame.SynchronizationParameter.presenceMode.modify())()
{
  return NANBitmap.Channel.operatingClass.getter;
}

uint64_t AWDLActionFrame.SynchronizationParameter.reserved.getter()
{
  return *(unsigned __int8 *)(v0 + 29);
}

uint64_t AWDLActionFrame.SynchronizationParameter.reserved.setter(uint64_t result)
{
  *(_BYTE *)(v1 + 29)  = result;
  return result;
}

uint64_t (*AWDLActionFrame.SynchronizationParameter.reserved.modify())()
{
  return NANBitmap.Channel.operatingClass.getter;
}

uint64_t AWDLActionFrame.SynchronizationParameter.sequence.getter()
{
  return *(unsigned __int16 *)(v0 + 30);
}

uint64_t AWDLActionFrame.SynchronizationParameter.sequence.setter(uint64_t result)
{
  *(_WORD *)(v1 + 30)  = result;
  return result;
}

uint64_t (*AWDLActionFrame.SynchronizationParameter.sequence.modify())()
{
  return NANBitmap.Channel.operatingClass.getter;
}

uint64_t AWDLActionFrame.SynchronizationParameter.accessPointBeaconDeltaAlignment.getter()
{
  return *(unsigned __int16 *)(v0 + 32);
}

uint64_t AWDLActionFrame.SynchronizationParameter.accessPointBeaconDeltaAlignment.setter(uint64_t result)
{
  *(_WORD *)(v1 + 32)  = result;
  return result;
}

uint64_t AWDLActionFrame.SynchronizationParameter.channelSequence.getter()
{
  uint64_t v1 = *(void *)(v0 + 40);
  sub_1000DB390(v0);
  return v1;
}

void AWDLActionFrame.SynchronizationParameter.hash(into:)(uint64_t a1)
{
  uint64_t v2 = v1;
  Hasher._combine(_:)(*(_BYTE *)v2);
  Hasher._combine(_:)(*(_WORD *)(v2 + 2));
  Hasher._combine(_:)(*(_BYTE *)(v2 + 4));
  Hasher._combine(_:)(*(_BYTE *)(v2 + 5));
  Hasher._combine(_:)(*(_WORD *)(v2 + 6));
  Hasher._combine(_:)(*(_WORD *)(v2 + 8));
  Hasher._combine(_:)(*(_WORD *)(v2 + 10));
  Hasher._combine(_:)(*(_WORD *)(v2 + 12));
  Hasher._combine(_:)(*(_WORD *)(v2 + 14));
  Hasher._combine(_:)(*(_WORD *)(v2 + 16));
  Hasher._combine(_:)(*(_BYTE *)(v2 + 18));
  Hasher._combine(_:)(*(_BYTE *)(v2 + 19));
  Hasher._combine(_:)(*(_BYTE *)(v2 + 20));
  Hasher._combine(_:)(*(_BYTE *)(v2 + 21));
  Swift::UInt8 v4 = *(_BYTE *)(v2 + 23);
  Swift::UInt8 v5 = *(_BYTE *)(v2 + 24);
  Swift::UInt8 v6 = *(_BYTE *)(v2 + 25);
  Swift::UInt8 v7 = *(_BYTE *)(v2 + 26);
  Swift::UInt8 v8 = *(_BYTE *)(v2 + 27);
  Hasher._combine(_:)(*(_BYTE *)(v2 + 22));
  Hasher._combine(_:)(v4);
  Hasher._combine(_:)(v5);
  Hasher._combine(_:)(v6);
  Hasher._combine(_:)(v7);
  Hasher._combine(_:)(v8);
  Hasher._combine(_:)(*(_BYTE *)(v2 + 28));
  Hasher._combine(_:)(*(_BYTE *)(v2 + 29));
  Hasher._combine(_:)(*(_WORD *)(v2 + 30));
  Hasher._combine(_:)(*(_WORD *)(v2 + 32));
  sub_100082C84(a1, *(void *)(v2 + 40));
}

uint64_t sub_1000C1E68(unsigned __int8 a1)
{
  return ((uint64_t (*)(uint64_t, unint64_t))((char *)sub_1000C1EA8 + 4 * byte_100340A85[a1]))( 0x74696D736E617274LL,  0xEF6C656E6E616843LL);
}

uint64_t sub_1000C1EA8()
{
  return 0x6E756F436E776F64LL;
}

unint64_t sub_1000C1EC8()
{
  return 0xD000000000000011LL;
}

uint64_t sub_1000C2050()
{
  return sub_1000C1E68(*v0);
}

uint64_t sub_1000C2058@<X0>(uint64_t a1@<X0>, unint64_t a2@<X1>, _BYTE *a3@<X8>)
{
  uint64_t result = sub_1000E30E4(a1, a2);
  *a3  = result;
  return result;
}

void sub_1000C207C(_BYTE *a1@<X8>)
{
  *a1  = 20;
}

uint64_t sub_1000C2088(uint64_t a1)
{
  unint64_t v2 = sub_1000E5348();
  return CodingKey.description.getter(a1, v2);
}

uint64_t sub_1000C20B0(uint64_t a1)
{
  unint64_t v2 = sub_1000E5348();
  return CodingKey.debugDescription.getter(a1, v2);
}

Swift::Int AWDLActionFrame.SynchronizationParameter.hashValue.getter()
{
  Swift::UInt8 v1 = *(_BYTE *)(v0 + 23);
  Swift::UInt8 v2 = *(_BYTE *)(v0 + 24);
  Swift::UInt8 v3 = *(_BYTE *)(v0 + 25);
  Swift::UInt8 v4 = *(_BYTE *)(v0 + 26);
  Swift::UInt8 v5 = *(_BYTE *)(v0 + 27);
  Hasher._combine(_:)(*(_BYTE *)(v0 + 22));
  Hasher._combine(_:)(v1);
  Hasher._combine(_:)(v2);
  Hasher._combine(_:)(v3);
  Hasher._combine(_:)(v4);
  Hasher._combine(_:)(v5);
  Hasher._combine(_:)(*(_BYTE *)(v0 + 28));
  Hasher._combine(_:)(*(_BYTE *)(v0 + 29));
  Hasher._combine(_:)(*(_WORD *)(v0 + 30));
  Hasher._combine(_:)(*(_WORD *)(v0 + 32));
  sub_100082C84((uint64_t)v7, *(void *)(v0 + 40));
  return Hasher._finalize()();
}

double AWDLActionFrame.SynchronizationParameter.init(from:)@<D0>(void *a1@<X0>, _OWORD *a2@<X8>)
{
  if (!v2)
  {
    __int128 v5 = v6[1];
    *a2  = v6[0];
    a2[1]  = v5;
    double result = *(double *)&v7;
    a2[2]  = v7;
  }

  return result;
}

uint64_t sub_1000C22A8(void *a1)
{
  return AWDLActionFrame.SynchronizationParameter.encode(to:)(a1);
}

uint64_t AWDLActionFrame.SynchronizationParameter.encode(to:)(void *a1)
{
  Swift::UInt8 v3 = v1;
  uint64_t v4 = a1[3];
  uint64_t v5 = a1[4];
  sub_100021104(a1, v4);
  dispatch thunk of Encoder.unkeyedContainer()(v66, v4, v5);
  uint64_t v6 = v67;
  uint64_t v7 = v68;
  uint64_t v8 = *v1;
  sub_1000237C8((uint64_t)v66, v67);
  dispatch thunk of UnkeyedEncodingContainer.encode(_:)(v8, v6, v7);
  if (!v2)
  {
    uint64_t v9 = v67;
    uint64_t v10 = v68;
    uint64_t v11 = *((unsigned __int16 *)v3 + 1);
    sub_1000237C8((uint64_t)v66, v67);
    dispatch thunk of UnkeyedEncodingContainer.encode(_:)(v11, v9, v10);
    uint64_t v12 = v67;
    uint64_t v13 = v68;
    uint64_t v14 = v3[4];
    sub_1000237C8((uint64_t)v66, v67);
    dispatch thunk of UnkeyedEncodingContainer.encode(_:)(v14, v12, v13);
    uint64_t v15 = v67;
    uint64_t v16 = v68;
    uint64_t v17 = v3[5];
    sub_1000237C8((uint64_t)v66, v67);
    dispatch thunk of UnkeyedEncodingContainer.encode(_:)(v17, v15, v16);
    uint64_t v18 = v67;
    uint64_t v19 = v68;
    uint64_t v20 = *((unsigned __int16 *)v3 + 3);
    sub_1000237C8((uint64_t)v66, v67);
    dispatch thunk of UnkeyedEncodingContainer.encode(_:)(v20, v18, v19);
    uint64_t v21 = v67;
    uint64_t v22 = v68;
    uint64_t v23 = *((unsigned __int16 *)v3 + 4);
    sub_1000237C8((uint64_t)v66, v67);
    dispatch thunk of UnkeyedEncodingContainer.encode(_:)(v23, v21, v22);
    uint64_t v24 = v67;
    uint64_t v25 = v68;
    uint64_t v26 = *((unsigned __int16 *)v3 + 5);
    sub_1000237C8((uint64_t)v66, v67);
    dispatch thunk of UnkeyedEncodingContainer.encode(_:)(v26, v24, v25);
    uint64_t v27 = v67;
    uint64_t v28 = v68;
    uint64_t v29 = *((unsigned __int16 *)v3 + 6);
    sub_1000237C8((uint64_t)v66, v67);
    dispatch thunk of UnkeyedEncodingContainer.encode(_:)(v29, v27, v28);
    uint64_t v30 = v67;
    uint64_t v31 = v68;
    uint64_t v32 = *((unsigned __int16 *)v3 + 7);
    sub_1000237C8((uint64_t)v66, v67);
    dispatch thunk of UnkeyedEncodingContainer.encode(_:)(v32, v30, v31);
    uint64_t v33 = v67;
    uint64_t v34 = v68;
    uint64_t v35 = *((unsigned __int16 *)v3 + 8);
    sub_1000237C8((uint64_t)v66, v67);
    dispatch thunk of UnkeyedEncodingContainer.encode(_:)(v35, v33, v34);
    uint64_t v36 = v67;
    uint64_t v37 = v68;
    uint64_t v38 = v3[18];
    sub_1000237C8((uint64_t)v66, v67);
    dispatch thunk of UnkeyedEncodingContainer.encode(_:)(v38, v36, v37);
    uint64_t v39 = v67;
    uint64_t v40 = v68;
    uint64_t v41 = v3[19];
    sub_1000237C8((uint64_t)v66, v67);
    dispatch thunk of UnkeyedEncodingContainer.encode(_:)(v41, v39, v40);
    uint64_t v42 = v67;
    uint64_t v43 = v68;
    uint64_t v44 = v3[20];
    sub_1000237C8((uint64_t)v66, v67);
    dispatch thunk of UnkeyedEncodingContainer.encode(_:)(v44, v42, v43);
    uint64_t v45 = v67;
    uint64_t v46 = v68;
    uint64_t v47 = v3[21];
    sub_1000237C8((uint64_t)v66, v67);
    dispatch thunk of UnkeyedEncodingContainer.encode(_:)(v47, v45, v46);
    int v69 = *(_DWORD *)(v3 + 22);
    __int16 v70 = *((_WORD *)v3 + 13);
    uint64_t v48 = v67;
    uint64_t v49 = v68;
    sub_1000237C8((uint64_t)v66, v67);
    unint64_t v50 = sub_1000286C4();
    dispatch thunk of UnkeyedEncodingContainer.encode<A>(_:)(&v69, &type metadata for WiFiAddress, v50, v48, v49);
    uint64_t v51 = v67;
    uint64_t v52 = v68;
    uint64_t v53 = v3[28];
    sub_1000237C8((uint64_t)v66, v67);
    dispatch thunk of UnkeyedEncodingContainer.encode(_:)(v53, v51, v52);
    uint64_t v54 = v67;
    uint64_t v55 = v68;
    uint64_t v56 = v3[29];
    sub_1000237C8((uint64_t)v66, v67);
    dispatch thunk of UnkeyedEncodingContainer.encode(_:)(v56, v54, v55);
    uint64_t v57 = v67;
    uint64_t v58 = v68;
    uint64_t v59 = *((unsigned __int16 *)v3 + 15);
    sub_1000237C8((uint64_t)v66, v67);
    dispatch thunk of UnkeyedEncodingContainer.encode(_:)(v59, v57, v58);
    uint64_t v60 = v67;
    uint64_t v61 = v68;
    uint64_t v62 = *((unsigned __int16 *)v3 + 16);
    sub_1000237C8((uint64_t)v66, v67);
    dispatch thunk of UnkeyedEncodingContainer.encode(_:)(v62, v60, v61);
    sub_1000D1778((uint64_t)v66, 1u, *((void *)v3 + 5));
    uint64_t v63 = v67;
    uint64_t v64 = v68;
    sub_1000237C8((uint64_t)v66, v67);
    dispatch thunk of UnkeyedEncodingContainer.encode(_:)(0LL, v63, v64);
  }

  return sub_100002AC4(v66);
}

Swift::Int sub_1000C27B0(uint64_t a1)
{
  uint64_t v27 = *(void *)(v1 + 40);
  Swift::UInt8 v2 = *(_BYTE *)v1;
  Swift::UInt16 v3 = *(_WORD *)(v1 + 2);
  Swift::UInt8 v4 = *(_BYTE *)(v1 + 4);
  Swift::UInt8 v5 = *(_BYTE *)(v1 + 5);
  Swift::UInt16 v6 = *(_WORD *)(v1 + 6);
  Swift::UInt16 v7 = *(_WORD *)(v1 + 8);
  Swift::UInt16 v8 = *(_WORD *)(v1 + 10);
  Swift::UInt16 v9 = *(_WORD *)(v1 + 12);
  Swift::UInt16 v10 = *(_WORD *)(v1 + 14);
  Swift::UInt16 v12 = *(_WORD *)(v1 + 16);
  Swift::UInt8 v13 = *(_BYTE *)(v1 + 18);
  Swift::UInt8 v14 = *(_BYTE *)(v1 + 19);
  Swift::UInt8 v15 = *(_BYTE *)(v1 + 20);
  Swift::UInt8 v16 = *(_BYTE *)(v1 + 21);
  Swift::UInt8 v17 = *(_BYTE *)(v1 + 22);
  Swift::UInt8 v18 = *(_BYTE *)(v1 + 23);
  Swift::UInt8 v19 = *(_BYTE *)(v1 + 24);
  Swift::UInt8 v20 = *(_BYTE *)(v1 + 25);
  Swift::UInt8 v21 = *(_BYTE *)(v1 + 26);
  Swift::UInt8 v22 = *(_BYTE *)(v1 + 27);
  Swift::UInt8 v23 = *(_BYTE *)(v1 + 28);
  Swift::UInt8 v24 = *(_BYTE *)(v1 + 29);
  Swift::UInt16 v25 = *(_WORD *)(v1 + 30);
  Swift::UInt16 v26 = *(_WORD *)(v1 + 32);
  Hasher.init(_seed:)(v28, a1);
  Hasher._combine(_:)(v2);
  Hasher._combine(_:)(v3);
  Hasher._combine(_:)(v4);
  Hasher._combine(_:)(v5);
  Hasher._combine(_:)(v6);
  Hasher._combine(_:)(v7);
  Hasher._combine(_:)(v8);
  Hasher._combine(_:)(v9);
  Hasher._combine(_:)(v10);
  Hasher._combine(_:)(v12);
  Hasher._combine(_:)(v13);
  Hasher._combine(_:)(v14);
  Hasher._combine(_:)(v15);
  Hasher._combine(_:)(v16);
  Hasher._combine(_:)(v17);
  Hasher._combine(_:)(v18);
  Hasher._combine(_:)(v19);
  Hasher._combine(_:)(v20);
  Hasher._combine(_:)(v21);
  Hasher._combine(_:)(v22);
  Hasher._combine(_:)(v23);
  Hasher._combine(_:)(v24);
  Hasher._combine(_:)(v25);
  Hasher._combine(_:)(v26);
  sub_100082C84((uint64_t)v28, v27);
  return Hasher._finalize()();
}

uint64_t sub_1000C29B4(_OWORD *a1, __int128 *a2)
{
  __int128 v2 = a1[1];
  v7[0]  = *a1;
  v7[1]  = v2;
  __int128 v3 = *a2;
  __int128 v4 = a2[1];
  v7[2]  = a1[2];
  v8[0]  = v3;
  __int128 v5 = a2[2];
  v8[1]  = v4;
  _OWORD v8[2] = v5;
  return _s7CoreP2P15AWDLActionFrameV24SynchronizationParameterV23__derived_struct_equalsySbAE_AEtFZ_0( (unsigned __int8 *)v7,  (unsigned __int8 *)v8) & 1;
}

unint64_t Channel.bandwidth.getter(unint64_t a1)
{
  return a1 >> 40;
}

unint64_t AWDLActionFrame.DeprecatedElectionParameter.address.getter( unint64_t a1, unsigned int a2)
{
  return HIWORD(a1) & 0xFFFF00000000FFFFLL | ((unint64_t)a2 << 16);
}

uint64_t AWDLActionFrame.Header.bssid.setter(uint64_t result)
{
  *(_WORD *)(v1 + 6)  = result;
  *(_BYTE *)(v1 + 8)  = BYTE2(result);
  *(_BYTE *)(v1 + 9)  = BYTE3(result);
  *(_BYTE *)(v1 + 10)  = BYTE4(result);
  *(_BYTE *)(v1 + 11)  = BYTE5(result);
  return result;
}

uint64_t AWDLActionFrame.DeprecatedElectionParameter.topMasterMetric.getter(uint64_t a1, uint64_t a2, char a3)
{
  *((void *)&v4 + 1)  = a3 & 1;
  *(void *)&__int128 v4 = a2;
  return v4 >> 32;
}

uint64_t AWDLActionFrame.DeprecatedElectionParameter.topMasterMetric.setter(uint64_t result)
{
  *(_DWORD *)(v1 + 12)  = result;
  *(_BYTE *)(v1 + 16)  = BYTE4(result) & 1;
  return result;
}

uint64_t AWDLActionFrame.DeprecatedElectionParameter.selfElectionMetric.getter( uint64_t a1, uint64_t a2, uint64_t a3, char a4)
{
  *((void *)&v5 + 1)  = a4 & 1;
  *(void *)&__int128 v5 = a3;
  return v5 >> 32;
}

uint64_t AWDLActionFrame.DeprecatedElectionParameter.selfElectionMetric.setter(uint64_t result)
{
  *(_DWORD *)(v1 + 20)  = result;
  *(_BYTE *)(v1 + 24)  = BYTE4(result) & 1;
  return result;
}

void AWDLActionFrame.DeprecatedElectionParameter.hash(into:)( int a1, unint64_t a2, unint64_t a3, uint64_t a4, char a5)
{
  unint64_t v18 = HIDWORD(a4);
  unint64_t v7 = a2 >> 16;
  unint64_t v8 = HIDWORD(a2);
  unint64_t v9 = a2 >> 40;
  unint64_t v10 = HIWORD(a2);
  unint64_t v11 = HIBYTE(a2);
  unint64_t v12 = a3 >> 8;
  unint64_t v13 = a3 >> 16;
  *(void *)Swift::UInt8 v16 = a3 >> 24;
  Hasher._combine(_:)(a2);
  Hasher._combine(_:)(v7);
  Hasher._combine(_:)(v8);
  Hasher._combine(_:)(v9);
  Hasher._combine(_:)(v10);
  Hasher._combine(_:)(v11);
  Hasher._combine(_:)(a3);
  Hasher._combine(_:)(v12);
  Hasher._combine(_:)(v13);
  Hasher._combine(_:)(v16[0]);
  if ((a4 & 1) != 0) {
    LODWORD(v14)  = dword_100345064[(uint64_t)a3 >> 32];
  }
  else {
    unint64_t v14 = HIDWORD(a3);
  }
  Hasher._combine(_:)(v14);
  Swift::UInt32 v15 = v18;
  if ((a5 & 1) != 0) {
    Swift::UInt32 v15 = dword_100345064[a4 >> 32];
  }
  Hasher._combine(_:)(v15);
}

uint64_t static AWDLActionFrame.DeprecatedElectionParameter.__derived_struct_equals(_:_:)( uint64_t a1, uint64_t a2, uint64_t a3, char a4, uint64_t a5, uint64_t a6, uint64_t a7, char a8)
{
  return sub_1000D69AC( a1 & 0xFFFFFFFFFFFF00FFLL,  a2,  a3 & 0xFFFFFFFF00000001LL,  a4 & 1,  a5 & 0xFFFFFFFFFFFF00FFLL,  a6,  a7 & 0xFFFFFFFF00000001LL,  a8 & 1);
}

uint64_t sub_1000C2BD0(unsigned __int8 a1)
{
  return ((uint64_t (*)(uint64_t, unint64_t))((char *)sub_1000C2C00 + 4 * byte_100340A99[a1]))( 0x7367616C66LL,  0xE500000000000000LL);
}

uint64_t sub_1000C2C00()
{
  return 0x6E6F697463656C65LL;
}

uint64_t sub_1000C2C1C()
{
  return 0x65636E6174736964LL;
}

uint64_t sub_1000C2C40()
{
  return 0x6465767265736572LL;
}

uint64_t sub_1000C2C64()
{
  return 0x73736572646461LL;
}

uint64_t sub_1000C2C7C()
{
  return 0x657473614D706F74LL;
}

unint64_t sub_1000C2CA0()
{
  return 0xD000000000000012LL;
}

uint64_t sub_1000C2CBC()
{
  return sub_1000C2BD0(*v0);
}

uint64_t sub_1000C2CC4@<X0>(uint64_t a1@<X0>, unint64_t a2@<X1>, _BYTE *a3@<X8>)
{
  uint64_t result = sub_1000E3888(a1, a2);
  *a3  = result;
  return result;
}

void sub_1000C2CE8(_BYTE *a1@<X8>)
{
  *a1  = 7;
}

uint64_t sub_1000C2CF4(uint64_t a1)
{
  unint64_t v2 = sub_1000E5304();
  return CodingKey.description.getter(a1, v2);
}

uint64_t sub_1000C2D1C(uint64_t a1)
{
  unint64_t v2 = sub_1000E5304();
  return CodingKey.debugDescription.getter(a1, v2);
}

Swift::Int AWDLActionFrame.DeprecatedElectionParameter.hashValue.getter( uint64_t a1, unint64_t a2, uint64_t a3, char a4)
{
  char v5 = a3;
  unint64_t v8 = a3 & 0xFFFFFFFF00000000LL;
  Hasher.init(_seed:)(v10, 0LL);
  AWDLActionFrame.DeprecatedElectionParameter.hash(into:)((int)v10, a1 & 0xFFFFFFFFFFFF00FFLL, a2, v8 | v5 & 1, a4 & 1);
  return Hasher._finalize()();
}

unint64_t AWDLActionFrame.DeprecatedElectionParameter.init(from:)(void *a1)
{
  unint64_t result = sub_1000D9408(a1);
  if (!v1) {
    result &= 0xFFFFFFFFFFFF00FFLL;
  }
  return result;
}

unint64_t sub_1000C2E04@<X0>(void *a1@<X0>, uint64_t a2@<X8>)
{
  unint64_t result = sub_1000D9408(a1);
  if (!v2)
  {
    *(_BYTE *)a2  = result;
    *(_WORD *)(a2 + 2)  = WORD1(result);
    *(_BYTE *)(a2 + 4)  = BYTE4(result);
    *(_BYTE *)(a2 + 5)  = BYTE5(result);
    *(_BYTE *)(a2 + 6)  = BYTE6(result);
    *(_BYTE *)(a2 + 7)  = HIBYTE(result);
    *(void *)(a2 + 8)  = v5;
    *(_BYTE *)(a2 + 16)  = v6 & 1;
    *(_DWORD *)(a2 + 20)  = v7;
    *(_BYTE *)(a2 + 24)  = v8 & 1;
  }

  return result;
}

uint64_t sub_1000C2E90(void *a1)
{
  return AWDLActionFrame.DeprecatedElectionParameter.encode(to:)( a1,  *v1 | ((unint64_t)*((unsigned __int16 *)v1 + 1) << 16) | ((unint64_t)v1[4] << 32) | ((unint64_t)v1[5] << 40) | ((unint64_t)v1[6] << 48) | ((unint64_t)v1[7] << 56),  *((void *)v1 + 1),  v1[16] | ((unint64_t)*((unsigned int *)v1 + 5) << 32),  v1[24]);
}

uint64_t AWDLActionFrame.DeprecatedElectionParameter.encode(to:)( void *a1, unint64_t a2, uint64_t a3, uint64_t a4, char a5)
{
  uint64_t v10 = a1[3];
  uint64_t v11 = a1[4];
  sub_100021104(a1, v10);
  dispatch thunk of Encoder.unkeyedContainer()(v34, v10, v11);
  uint64_t v12 = v35;
  uint64_t v13 = v36;
  sub_1000237C8((uint64_t)v34, v35);
  dispatch thunk of UnkeyedEncodingContainer.encode(_:)(a2, v12, v13);
  if (!v5)
  {
    uint64_t v14 = v35;
    uint64_t v15 = v36;
    sub_1000237C8((uint64_t)v34, v35);
    dispatch thunk of UnkeyedEncodingContainer.encode(_:)(a2 >> 16, v14, v15);
    uint64_t v16 = v35;
    uint64_t v17 = v36;
    sub_1000237C8((uint64_t)v34, v35);
    dispatch thunk of UnkeyedEncodingContainer.encode(_:)(HIDWORD(a2), v16, v17);
    uint64_t v18 = v35;
    uint64_t v19 = v36;
    sub_1000237C8((uint64_t)v34, v35);
    dispatch thunk of UnkeyedEncodingContainer.encode(_:)(a2 >> 40, v18, v19);
    LOBYTE(v31)  = BYTE6(a2);
    BYTE1(v31)  = HIBYTE(a2);
    HIWORD(v31)  = a3;
    char v32 = BYTE2(a3);
    char v33 = BYTE3(a3);
    uint64_t v20 = v35;
    uint64_t v21 = v36;
    sub_1000237C8((uint64_t)v34, v35);
    unint64_t v22 = sub_1000286C4();
    dispatch thunk of UnkeyedEncodingContainer.encode<A>(_:)(&v31, &type metadata for WiFiAddress, v22, v20, v21);
    int v31 = HIDWORD(a3);
    char v32 = a4 & 1;
    uint64_t v23 = v35;
    uint64_t v24 = v36;
    sub_1000237C8((uint64_t)v34, v35);
    unint64_t v25 = sub_1000DB3B8();
    dispatch thunk of UnkeyedEncodingContainer.encode<A>(_:)(&v31, &type metadata for AWDLElectionMetric, v25, v23, v24);
    int v31 = HIDWORD(a4);
    char v32 = a5 & 1;
    uint64_t v26 = v35;
    uint64_t v27 = v36;
    sub_1000237C8((uint64_t)v34, v35);
    dispatch thunk of UnkeyedEncodingContainer.encode<A>(_:)(&v31, &type metadata for AWDLElectionMetric, v25, v26, v27);
    uint64_t v28 = v35;
    uint64_t v29 = v36;
    sub_1000237C8((uint64_t)v34, v35);
    dispatch thunk of UnkeyedEncodingContainer.encode(_:)(0LL, v28, v29);
  }

  return sub_100002AC4(v34);
}

Swift::Int sub_1000C3180()
{
  uint64_t v1 = *v0;
  uint64_t v2 = *((unsigned __int16 *)v0 + 1);
  uint64_t v3 = v0[4];
  uint64_t v4 = v0[5];
  uint64_t v5 = v0[6];
  unsigned __int8 v6 = v0[16];
  char v7 = v0[24];
  uint64_t v8 = v0[7];
  unint64_t v9 = *((void *)v0 + 1);
  uint64_t v10 = *((unsigned int *)v0 + 5);
  Hasher.init(_seed:)(v12, 0LL);
  AWDLActionFrame.DeprecatedElectionParameter.hash(into:)( (int)v12,  v1 | (v2 << 16) | (v3 << 32) | (v4 << 40) | (v5 << 48) | (v8 << 56),  v9,  v6 | (unint64_t)(v10 << 32),  v7);
  return Hasher._finalize()();
}

void sub_1000C3230(int a1)
{
}

Swift::Int sub_1000C3284(uint64_t a1)
{
  uint64_t v2 = *v1;
  uint64_t v3 = *((unsigned __int16 *)v1 + 1);
  uint64_t v4 = v1[4];
  uint64_t v5 = v1[5];
  uint64_t v6 = v1[6];
  unsigned __int8 v7 = v1[16];
  char v8 = v1[24];
  uint64_t v9 = v1[7];
  unint64_t v10 = *((void *)v1 + 1);
  uint64_t v11 = *((unsigned int *)v1 + 5);
  Hasher.init(_seed:)(v13, a1);
  AWDLActionFrame.DeprecatedElectionParameter.hash(into:)( (int)v13,  v2 | (v3 << 16) | (v4 << 32) | (v5 << 40) | (v6 << 48) | (v9 << 56),  v10,  v7 | (unint64_t)(v11 << 32),  v8);
  return Hasher._finalize()();
}

uint64_t sub_1000C3330(unsigned __int8 *a1, unsigned __int8 *a2)
{
  return sub_1000D69AC( *a1 | ((unint64_t)*((unsigned __int16 *)a1 + 1) << 16) | ((unint64_t)a1[4] << 32) | ((unint64_t)a1[5] << 40) | ((unint64_t)a1[6] << 48) | ((unint64_t)a1[7] << 56),  *((void *)a1 + 1),  a1[16] | ((unint64_t)*((unsigned int *)a1 + 5) << 32),  a1[24],  *a2 | ((unint64_t)*((unsigned __int16 *)a2 + 1) << 16) | ((unint64_t)a2[4] << 32) | ((unint64_t)a2[5] << 40) | ((unint64_t)a2[6] << 48) | ((unint64_t)a2[7] << 56),  *((void *)a2 + 1),  a2[16] | ((unint64_t)*((unsigned int *)a2 + 5) << 32),  a2[24]);
}

void *AWDLActionFrame.ServiceParameter.Flags.serviceRequests.unsafeMutableAddressor()
{
  return &static AWDLActionFrame.ServiceParameter.Flags.serviceRequests;
}

void *AWDLActionFrame.ServiceParameter.Flags.missingBits.unsafeMutableAddressor()
{
  return &static AWDLActionFrame.ServiceParameter.Flags.missingBits;
}

void *AWDLActionFrame.ServiceParameter.Flags.duplicates.unsafeMutableAddressor()
{
  return &static AWDLActionFrame.ServiceParameter.Flags.duplicates;
}

void *AWDLActionFrame.ServiceParameter.Flags.autoGenerateAAAA.unsafeMutableAddressor()
{
  return &static AWDLActionFrame.ServiceParameter.Flags.autoGenerateAAAA;
}

void *AWDLActionFrame.ServiceParameter.Flags.allKeys.unsafeMutableAddressor()
{
  return &static AWDLActionFrame.ServiceParameter.Flags.allKeys;
}

void *AWDLActionFrame.ServiceParameter.Flags.serviceResponseOverflow.unsafeMutableAddressor()
{
  return &static AWDLActionFrame.ServiceParameter.Flags.serviceResponseOverflow;
}

void *AWDLActionFrame.ServiceParameter.Flags.supportsWiFiAwareMigration.unsafeMutableAddressor()
{
  return &static AWDLActionFrame.ServiceParameter.Flags.supportsWiFiAwareMigration;
}

uint64_t sub_1000C3434(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v6 = sub_1000DC418();
  return RawRepresentable<>.init(from:)(a1, a2, a3, v6);
}

uint64_t sub_1000C3490(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v6 = sub_1000DC418();
  return RawRepresentable<>.encode(to:)(a1, a2, a3, v6);
}

uint64_t sub_1000C34DC()
{
  uint64_t result = Data.subdata(in:)(0LL, 0LL, 0LL, 0xC000000000000000LL);
  static AWDLActionFrame.ServiceParameter.SSTH.zero  = 0;
  qword_100410740  = result;
  unk_100410748  = v1;
  return result;
}

uint64_t AWDLActionFrame.ServiceParameter.SSTH.init(ssthByteMap:compressedSSTH:)( uint64_t a1, uint64_t a2, unint64_t a3)
{
  if (!v4) {
    uint64_t v3 = v7;
  }
  sub_1000208D8(a2, a3);
  return v3;
}

int *AWDLActionFrame.ServiceParameter.SSTH.zero.unsafeMutableAddressor()
{
  if (qword_100404168 != -1) {
    swift_once(&qword_100404168, sub_1000C34DC);
  }
  return &static AWDLActionFrame.ServiceParameter.SSTH.zero;
}

uint64_t static AWDLActionFrame.ServiceParameter.SSTH.zero.getter()
{
  if (qword_100404168 != -1) {
    swift_once(&qword_100404168, sub_1000C34DC);
  }
  uint64_t v0 = static AWDLActionFrame.ServiceParameter.SSTH.zero;
  sub_100020AFC(qword_100410740, unk_100410748);
  return v0;
}

uint64_t AWDLActionFrame.ServiceParameter.SSTH.init(from:)(void *a1)
{
  LODWORD(result)  = sub_1000DAD6C(a1);
  if (v1) {
    return v3;
  }
  else {
    return result;
  }
}

uint64_t AWDLActionFrame.ServiceParameter.SSTH.hash(into:)( uint64_t a1, Swift::UInt32 a2, uint64_t a3, unint64_t a4)
{
  return sub_1000208D8(a3, a4);
}

void static AWDLActionFrame.ServiceParameter.SSTH.__derived_struct_equals(_:_:)( int a1, uint64_t a2, uint64_t a3, int a4)
{
  if (a1 == a4) {
    _s7CoreP2P6NANPMKV23__derived_struct_equalsySbAC_ACtFZ_0(a2, a3);
  }
}

uint64_t sub_1000C36D4()
{
  if (*v0) {
    return 0x73736572706D6F63LL;
  }
  else {
    return 0x6574794268747373LL;
  }
}

uint64_t sub_1000C3724@<X0>(uint64_t a1@<X0>, unint64_t a2@<X1>, _BYTE *a3@<X8>)
{
  uint64_t result = sub_1000E3BD8(a1, a2);
  *a3  = result;
  return result;
}

uint64_t sub_1000C3748(uint64_t a1)
{
  unint64_t v2 = sub_1000DB3FC();
  return CodingKey.description.getter(a1, v2);
}

uint64_t sub_1000C3770(uint64_t a1)
{
  unint64_t v2 = sub_1000DB3FC();
  return CodingKey.debugDescription.getter(a1, v2);
}

uint64_t AWDLActionFrame.ServiceParameter.SSTH.encode(to:)(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v18 = a4;
  uint64_t v8 = sub_100002274(&qword_100407420);
  uint64_t v9 = *(void *)(v8 - 8);
  __chkstk_darwin(v8);
  uint64_t v11 = (char *)&v17 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v12 = a1[3];
  uint64_t v13 = a1[4];
  sub_100021104(a1, v12);
  unint64_t v14 = sub_1000DB3FC();
  dispatch thunk of Encoder.container<A>(keyedBy:)( &type metadata for AWDLActionFrame.ServiceParameter.SSTH.CodingKeys,  &type metadata for AWDLActionFrame.ServiceParameter.SSTH.CodingKeys,  v14,  v12,  v13);
  LOBYTE(v19[0])  = 0;
  KeyedEncodingContainer.encode(_:forKey:)(a2, v19, v8);
  if (!v4)
  {
    v19[0]  = a3;
    v19[1]  = v18;
    char v20 = 1;
    unint64_t v15 = sub_10005CD78();
    KeyedEncodingContainer.encode<A>(_:forKey:)(v19, &v20, v8, &type metadata for Data, v15);
  }

  return (*(uint64_t (**)(char *, uint64_t))(v9 + 8))(v11, v8);
}

Swift::Int AWDLActionFrame.ServiceParameter.SSTH.hashValue.getter( Swift::UInt32 a1, uint64_t a2, unint64_t a3)
{
  return Hasher._finalize()();
}

Swift::Int sub_1000C3950()
{
  Swift::UInt32 v1 = *(_DWORD *)v0;
  uint64_t v2 = *(void *)(v0 + 8);
  unint64_t v3 = *(void *)(v0 + 16);
  Hasher.init(_seed:)(v5, 0LL);
  Hasher._combine(_:)(v1);
  sub_100020AFC(v2, v3);
  Data.hash(into:)(v5, v2, v3);
  sub_1000208D8(v2, v3);
  return Hasher._finalize()();
}

uint64_t sub_1000C39C8(uint64_t a1)
{
  uint64_t v3 = *(void *)(v1 + 8);
  unint64_t v4 = *(void *)(v1 + 16);
  Hasher._combine(_:)(*(_DWORD *)v1);
  sub_100020AFC(v3, v4);
  Data.hash(into:)(a1, v3, v4);
  return sub_1000208D8(v3, v4);
}

Swift::Int sub_1000C3A20(uint64_t a1)
{
  Swift::UInt32 v2 = *(_DWORD *)v1;
  uint64_t v3 = *(void *)(v1 + 8);
  unint64_t v4 = *(void *)(v1 + 16);
  Hasher.init(_seed:)(v6, a1);
  Hasher._combine(_:)(v2);
  sub_100020AFC(v3, v4);
  Data.hash(into:)(v6, v3, v4);
  sub_1000208D8(v3, v4);
  return Hasher._finalize()();
}

void *sub_1000C3A94@<X0>(void *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t result = sub_1000DAD6C(a1);
  if (!v2)
  {
    *(_DWORD *)a2  = (_DWORD)result;
    *(void *)(a2 + 8)  = v5;
    *(void *)(a2 + 16)  = v6;
  }

  return result;
}

uint64_t sub_1000C3AC0(void *a1)
{
  return AWDLActionFrame.ServiceParameter.SSTH.encode(to:)(a1, *v1, *((void *)v1 + 1), *((void *)v1 + 2));
}

void sub_1000C3ADC(uint64_t a1, _DWORD *a2)
{
  if (*(_DWORD *)a1 == *a2) {
    _s7CoreP2P6NANPMKV23__derived_struct_equalsySbAC_ACtFZ_0(*(void *)(a1 + 8), *(void *)(a1 + 16));
  }
}

uint64_t IEEE80211InformationElement.VeryHighThroughputCapability.rxMCSMap.setter(uint64_t result)
{
  *(_WORD *)(v1 + 4)  = result;
  return result;
}

uint64_t AWDLActionFrame.ServiceParameter.ssth.setter(int a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = sub_1000208D8(*(void *)(v3 + 16), *(void *)(v3 + 24));
  *(_DWORD *)(v3 + 8)  = a1;
  *(void *)(v3 + 16)  = a2;
  *(void *)(v3 + 24)  = a3;
  return result;
}

uint64_t AWDLActionFrame.ServiceParameter.hash(into:)( uint64_t a1, unint64_t a2, Swift::UInt32 a3, uint64_t a4, unint64_t a5)
{
  unint64_t v9 = a2 >> 16;
  unint64_t v10 = HIDWORD(a2);
  Hasher._combine(_:)(a2);
  Hasher._combine(_:)(v9);
  Hasher._combine(_:)(v10);
  Hasher._combine(_:)(a3);
  sub_100020AFC(a4, a5);
  Data.hash(into:)(a1, a4, a5);
  return sub_1000208D8(a4, a5);
}

BOOL static AWDLActionFrame.ServiceParameter.__derived_struct_equals(_:_:)( unint64_t a1, int a2, uint64_t a3, uint64_t a4, unint64_t a5, int a6)
{
  BOOL result = 0LL;
  if (a1 == a5 && (a1 >> 16) == (a5 >> 16))
  {
    BOOL result = 0;
    if (a2 == a6)
    {
      _s7CoreP2P6NANPMKV23__derived_struct_equalsySbAC_ACtFZ_0(a3, a4);
      if ((v8 & 1) != 0) {
        return 1;
      }
    }
  }

  return result;
}

uint64_t sub_1000C3C28()
{
  return ((uint64_t (*)(uint64_t, unint64_t))((char *)sub_1000C3C54 + 4 * byte_100340AA0[*v0]))( 0x7367616C66LL,  0xE500000000000000LL);
}

uint64_t sub_1000C3C54()
{
  return 0x6D69546C6C657764LL;
}

unint64_t sub_1000C3C70()
{
  return 0xD000000000000016LL;
}

uint64_t sub_1000C3C8C()
{
  return 1752462195LL;
}

uint64_t sub_1000C3C9C@<X0>(uint64_t a1@<X0>, unint64_t a2@<X1>, _BYTE *a3@<X8>)
{
  uint64_t result = sub_1000E3D04(a1, a2);
  *a3  = result;
  return result;
}

uint64_t sub_1000C3CC0(uint64_t a1)
{
  unint64_t v2 = sub_1000DB440();
  return CodingKey.description.getter(a1, v2);
}

uint64_t sub_1000C3CE8(uint64_t a1)
{
  unint64_t v2 = sub_1000DB440();
  return CodingKey.debugDescription.getter(a1, v2);
}

uint64_t AWDLActionFrame.ServiceParameter.encode(to:)( void *a1, unint64_t a2, int a3, uint64_t a4, uint64_t a5)
{
  uint64_t v23 = a4;
  uint64_t v24 = a5;
  uint64_t v9 = sub_100002274(&qword_100407430);
  uint64_t v10 = *(void *)(v9 - 8);
  __chkstk_darwin(v9);
  uint64_t v12 = (char *)&v22 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v14 = a1[3];
  uint64_t v13 = a1[4];
  sub_100021104(a1, v14);
  unint64_t v15 = sub_1000DB440();
  dispatch thunk of Encoder.container<A>(keyedBy:)( &type metadata for AWDLActionFrame.ServiceParameter.CodingKeys,  &type metadata for AWDLActionFrame.ServiceParameter.CodingKeys,  v15,  v14,  v13);
  LOBYTE(v25)  = a2;
  char v28 = 0;
  unint64_t v16 = sub_1000DB484();
  KeyedEncodingContainer.encode<A>(_:forKey:)( &v25,  &v28,  v9,  &type metadata for AWDLActionFrame.ServiceParameter.Flags,  v16);
  if (!v5)
  {
    int v17 = a3;
    uint64_t v18 = v23;
    uint64_t v19 = v24;
    LOBYTE(v25)  = 1;
    KeyedEncodingContainer.encode(_:forKey:)(a2 >> 16, &v25, v9);
    LOBYTE(v25)  = 2;
    KeyedEncodingContainer.encode(_:forKey:)(HIDWORD(a2), &v25, v9);
    int v25 = v17;
    uint64_t v26 = v18;
    uint64_t v27 = v19;
    char v28 = 3;
    unint64_t v20 = sub_1000DB4C8();
    KeyedEncodingContainer.encode<A>(_:forKey:)( &v25,  &v28,  v9,  &type metadata for AWDLActionFrame.ServiceParameter.SSTH,  v20);
  }

  return (*(uint64_t (**)(char *, uint64_t))(v10 + 8))(v12, v9);
}

Swift::Int AWDLActionFrame.ServiceParameter.hashValue.getter( unint64_t a1, Swift::UInt32 a2, uint64_t a3, unint64_t a4)
{
  Swift::UInt8 v7 = a1;
  unint64_t v8 = a1 >> 16;
  unint64_t v9 = HIDWORD(a1);
  Hasher.init(_seed:)(v11, 0LL);
  Hasher._combine(_:)(v7);
  Hasher._combine(_:)(v8);
  Hasher._combine(_:)(v9);
  Hasher._combine(_:)(a2);
  sub_100020AFC(a3, a4);
  Data.hash(into:)(v11, a3, a4);
  sub_1000208D8(a3, a4);
  return Hasher._finalize()();
}

unint64_t sub_1000C3F74@<X0>(void *a1@<X0>, uint64_t a2@<X8>)
{
  unint64_t result = AWDLActionFrame.ServiceParameter.init(from:)(a1);
  if (!v2)
  {
    *(_BYTE *)a2  = result;
    *(_WORD *)(a2 + 2)  = WORD1(result);
    *(_WORD *)(a2 + 4)  = WORD2(result);
    *(_DWORD *)(a2 + 8)  = v5;
    *(void *)(a2 + 16)  = v6;
    *(void *)(a2 + 24)  = v7;
  }

  return result;
}

unint64_t AWDLActionFrame.ServiceParameter.init(from:)(void *a1)
{
  return sub_1000DB708(a1) & 0xFFFFFFFF00FFLL;
}

uint64_t sub_1000C3FE4(void *a1)
{
  return AWDLActionFrame.ServiceParameter.encode(to:)( a1,  *v1 | ((unint64_t)*((unsigned __int16 *)v1 + 1) << 16) | ((unint64_t)*((unsigned __int16 *)v1 + 2) << 32),  *((_DWORD *)v1 + 2),  *((void *)v1 + 2),  *((void *)v1 + 3));
}

Swift::Int sub_1000C4014()
{
  Swift::UInt32 v1 = *(_DWORD *)(v0 + 8);
  uint64_t v2 = *(void *)(v0 + 16);
  unint64_t v3 = *(void *)(v0 + 24);
  Swift::UInt8 v4 = *(_BYTE *)v0;
  Swift::UInt16 v5 = *(_WORD *)(v0 + 2);
  Swift::UInt16 v6 = *(_WORD *)(v0 + 4);
  Hasher.init(_seed:)(v8, 0LL);
  Hasher._combine(_:)(v4);
  Hasher._combine(_:)(v5);
  Hasher._combine(_:)(v6);
  Hasher._combine(_:)(v1);
  sub_100020AFC(v2, v3);
  Data.hash(into:)(v8, v2, v3);
  sub_1000208D8(v2, v3);
  return Hasher._finalize()();
}

uint64_t sub_1000C40CC(uint64_t a1)
{
  Swift::UInt32 v3 = *(_DWORD *)(v1 + 8);
  uint64_t v4 = *(void *)(v1 + 16);
  unint64_t v5 = *(void *)(v1 + 24);
  Swift::UInt16 v6 = *(_WORD *)(v1 + 2);
  Swift::UInt16 v7 = *(_WORD *)(v1 + 4);
  Hasher._combine(_:)(*(_BYTE *)v1);
  Hasher._combine(_:)(v6);
  Hasher._combine(_:)(v7);
  Hasher._combine(_:)(v3);
  sub_100020AFC(v4, v5);
  Data.hash(into:)(a1, v4, v5);
  return sub_1000208D8(v4, v5);
}

Swift::Int sub_1000C4158(uint64_t a1)
{
  Swift::UInt32 v2 = *(_DWORD *)(v1 + 8);
  uint64_t v3 = *(void *)(v1 + 16);
  unint64_t v4 = *(void *)(v1 + 24);
  Swift::UInt8 v5 = *(_BYTE *)v1;
  Swift::UInt16 v6 = *(_WORD *)(v1 + 2);
  Swift::UInt16 v7 = *(_WORD *)(v1 + 4);
  Hasher.init(_seed:)(v9, a1);
  Hasher._combine(_:)(v5);
  Hasher._combine(_:)(v6);
  Hasher._combine(_:)(v7);
  Hasher._combine(_:)(v2);
  sub_100020AFC(v3, v4);
  Data.hash(into:)(v9, v3, v4);
  sub_1000208D8(v3, v4);
  return Hasher._finalize()();
}

BOOL sub_1000C420C(unsigned __int8 *a1, unsigned __int8 *a2)
{
  BOOL v3 = *a1 == *a2
  BOOL result = 0;
  if (v3 && *((_DWORD *)a1 + 2) == *((_DWORD *)a2 + 2))
  {
    _s7CoreP2P6NANPMKV23__derived_struct_equalsySbAC_ACtFZ_0(*((void *)a1 + 2), *((void *)a1 + 3));
    if ((v4 & 1) != 0) {
      return 1;
    }
  }

  return result;
}

uint64_t sub_1000C427C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v6 = sub_1000E2304();
  return RawRepresentable<>.init(from:)(a1, a2, a3, v6);
}

uint64_t sub_1000C42D8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v6 = sub_1000E2304();
  return RawRepresentable<>.encode(to:)(a1, a2, a3, v6);
}

uint64_t sub_1000C4324(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v6 = sub_1000E2424();
  return RawRepresentable<>.init(from:)(a1, a2, a3, v6);
}

uint64_t sub_1000C4380(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v6 = sub_1000E2424();
  return RawRepresentable<>.encode(to:)(a1, a2, a3, v6);
}

BOOL sub_1000C43D0(char *a1, char *a2)
{
  return dword_100345098[*a1] == dword_100345098[*a2];
}

uint64_t sub_1000C43F4@<X0>(int *a1@<X0>, _BYTE *a2@<X8>)
{
  uint64_t result = _s7CoreP2P15AWDLActionFrameV13DataPathStateV30UnicastMasterIndicationOptionsO8rawValueAGSgs6UInt32V_tcfC_0(*a1);
  *a2  = result;
  return result;
}

void sub_1000C441C(_DWORD *a1@<X8>)
{
  *a1  = dword_100345098[*v1];
}

Swift::Int sub_1000C4434()
{
  uint64_t v1 = *v0;
  Hasher.init(_seed:)(v3, 0LL);
  Hasher._combine(_:)(dword_100345098[v1]);
  return Hasher._finalize()();
}

void sub_1000C4480()
{
}

Swift::Int sub_1000C44B4(uint64_t a1)
{
  uint64_t v2 = *v1;
  Hasher.init(_seed:)(v4, a1);
  Hasher._combine(_:)(dword_100345098[v2]);
  return Hasher._finalize()();
}

uint64_t sub_1000C44FC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v6 = sub_1000E4D74();
  return RawRepresentable<>.init(from:)(a1, a2, a3, v6);
}

uint64_t sub_1000C4558(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v6 = sub_1000E4D74();
  return RawRepresentable<>.encode(to:)(a1, a2, a3, v6);
}

uint64_t AWDLActionFrame.DataPathState.countryCode.getter()
{
  return *v0 | (*((unsigned __int8 *)v0 + 2) << 16);
}

uint64_t AWDLActionFrame.DataPathState.countryCode.setter(uint64_t result)
{
  *(_WORD *)uint64_t v1 = result;
  *(_BYTE *)(v1 + 2)  = BYTE2(result) & 1;
  return result;
}

unint64_t AWDLActionFrame.DataPathState.socialChannelMap.getter()
{
  return *(unsigned int *)(v0 + 4) | ((unint64_t)*(unsigned __int16 *)(v0 + 8) << 32);
}

uint64_t AWDLActionFrame.DataPathState.socialChannelMap.setter(uint64_t result)
{
  *(_DWORD *)(v1 + 4)  = result;
  *(_WORD *)(v1 + 8)  = WORD2(result);
  return result;
}

unint64_t AWDLActionFrame.DataPathState.infraBSSID.getter()
{
  return *(unsigned int *)(v0 + 10) | ((unint64_t)*(unsigned __int16 *)(v0 + 14) << 32) | ((unint64_t)*(unsigned __int8 *)(v0 + 16) << 48);
}

uint64_t AWDLActionFrame.DataPathState.infraBSSID.setter(uint64_t result)
{
  *(_DWORD *)(v1 + 10)  = result;
  *(_WORD *)(v1 + 14)  = WORD2(result);
  *(_BYTE *)(v1 + 16)  = BYTE6(result) & 1;
  return result;
}

unint64_t AWDLActionFrame.DataPathState.infraChannel.getter()
{
  return *(unsigned int *)(v0 + 20) | ((unint64_t)*(unsigned __int16 *)(v0 + 24) << 32);
}

uint64_t AWDLActionFrame.DataPathState.infraChannel.setter(uint64_t result)
{
  *(_DWORD *)(v1 + 20)  = result;
  *(_WORD *)(v1 + 24)  = WORD2(result);
  return result;
}

unint64_t AWDLActionFrame.DataPathState.infraAddress.getter()
{
  return *(unsigned int *)(v0 + 26) | ((unint64_t)*(unsigned __int16 *)(v0 + 30) << 32) | ((unint64_t)*(unsigned __int8 *)(v0 + 32) << 48);
}

uint64_t AWDLActionFrame.DataPathState.infraAddress.setter(uint64_t result)
{
  *(_DWORD *)(v1 + 26)  = result;
  *(_WORD *)(v1 + 30)  = WORD2(result);
  *(_BYTE *)(v1 + 32)  = BYTE6(result) & 1;
  return result;
}

uint64_t (*AWDLActionFrame.DataPathState.infraAddress.modify())()
{
  return NANBitmap.Channel.operatingClass.getter;
}

uint64_t AWDLActionFrame.DataPathState.infraSSID.getter()
{
  uint64_t v1 = *(void *)(v0 + 40);
  swift_bridgeObjectRetain(*(void *)(v0 + 48));
  return v1;
}

uint64_t AWDLActionFrame.DataPathState.infraSSID.setter(uint64_t a1, uint64_t a2)
{
  uint64_t result = swift_bridgeObjectRelease(*(void *)(v2 + 48));
  *(void *)(v2 + 40)  = a1;
  *(void *)(v2 + 48)  = a2;
  return result;
}

uint64_t (*IEEE80211InformationElement.RSNCapability.groupManagementCipherSuite.modify())()
{
  return NANBitmap.Channel.operatingClass.getter;
}

unint64_t AWDLActionFrame.DataPathState.awdlAddress.getter()
{
  return *(unsigned int *)(v0 + 56) | ((unint64_t)*(unsigned __int16 *)(v0 + 60) << 32) | ((unint64_t)*(unsigned __int8 *)(v0 + 62) << 48);
}

uint64_t AWDLActionFrame.DataPathState.awdlAddress.setter(uint64_t result)
{
  *(_DWORD *)(v1 + 56)  = result;
  *(_WORD *)(v1 + 60)  = WORD2(result);
  *(_BYTE *)(v1 + 62)  = BYTE6(result) & 1;
  return result;
}

uint64_t (*InfraStatistics.viOutputBytes.modify())()
{
  return NANBitmap.Channel.operatingClass.getter;
}

uint64_t AWDLActionFrame.DataPathState.isUnicast.getter()
{
  return *(unsigned __int8 *)(v0 + 63);
}

uint64_t AWDLActionFrame.DataPathState.isUnicast.setter(uint64_t result)
{
  *(_BYTE *)(v1 + 63)  = result;
  return result;
}

uint64_t (*AWDLActionFrame.DataPathState.isUnicast.modify())()
{
  return NANBitmap.Channel.operatingClass.getter;
}

uint64_t AWDLActionFrame.DataPathState.unicastOptions.getter()
{
  return *(unsigned __int8 *)(v0 + 64);
}

uint64_t AWDLActionFrame.DataPathState.unicastOptions.setter(uint64_t result)
{
  *(_BYTE *)(v1 + 64)  = result;
  return result;
}

uint64_t (*InfraStatistics.ctlOutputPackets.modify())()
{
  return NANBitmap.Channel.operatingClass.getter;
}

uint64_t AWDLActionFrame.DataPathState.unicastPeerCachingIndication.getter()
{
  return *(unsigned __int8 *)(v0 + 65);
}

uint64_t AWDLActionFrame.DataPathState.unicastPeerCachingIndication.setter(uint64_t result)
{
  *(_BYTE *)(v1 + 65)  = result;
  return result;
}

uint64_t (*AWDLActionFrame.DataPathState.unicastPeerCachingIndication.modify())()
{
  return NANBitmap.Channel.operatingClass.getter;
}

uint64_t AWDLActionFrame.DataPathState.portUniqueLogID.getter()
{
  return *(unsigned __int16 *)(v0 + 66) | (*(unsigned __int8 *)(v0 + 68) << 16);
}

uint64_t AWDLActionFrame.DataPathState.portUniqueLogID.setter(uint64_t result)
{
  *(_WORD *)(v1 + 66)  = result;
  *(_BYTE *)(v1 + 68)  = BYTE2(result) & 1;
  return result;
}

uint64_t (*AWDLActionFrame.DataPathState.portUniqueLogID.modify())()
{
  return NANBitmap.Channel.operatingClass.getter;
}

unint64_t AWDLActionFrame.DataPathState.rootLoopFreeCounter.getter()
{
  return *(unsigned int *)(v0 + 72) | ((unint64_t)*(unsigned __int8 *)(v0 + 76) << 32);
}

uint64_t AWDLActionFrame.DataPathState.rootLoopFreeCounter.setter(uint64_t result)
{
  *(_DWORD *)(v1 + 72)  = result;
  *(_BYTE *)(v1 + 76)  = BYTE4(result) & 1;
  return result;
}

uint64_t (*InfraStatistics.inputPackets.modify())()
{
  return NANBitmap.Channel.operatingClass.getter;
}

uint64_t AWDLActionFrame.DataPathState.supportsDualBand.getter()
{
  return *(unsigned __int8 *)(v0 + 77);
}

uint64_t AWDLActionFrame.DataPathState.supportsDualBand.setter(uint64_t result)
{
  *(_BYTE *)(v1 + 77)  = result;
  return result;
}

uint64_t (*AWDLActionFrame.DataPathState.supportsDualBand.modify())()
{
  return NANBitmap.Channel.operatingClass.getter;
}

uint64_t AWDLActionFrame.DataPathState.isAirPlaySink.getter()
{
  return *(unsigned __int8 *)(v0 + 78);
}

uint64_t AWDLActionFrame.DataPathState.isAirPlaySink.setter(uint64_t result)
{
  *(_BYTE *)(v1 + 78)  = result;
  return result;
}

uint64_t (*AWDLActionFrame.DataPathState.isAirPlaySink.modify())()
{
  return NANBitmap.Channel.operatingClass.getter;
}

uint64_t AWDLActionFrame.DataPathState.followChannelSequence.getter()
{
  return *(unsigned __int8 *)(v0 + 79);
}

uint64_t AWDLActionFrame.DataPathState.followChannelSequence.setter(uint64_t result)
{
  *(_BYTE *)(v1 + 79)  = result;
  return result;
}

uint64_t (*AWDLActionFrame.DataPathState.followChannelSequence.modify())()
{
  return NANBitmap.Channel.operatingClass.getter;
}

uint64_t AWDLActionFrame.DataPathState.supportsAirPlaySolo.getter()
{
  return *(unsigned __int8 *)(v0 + 80);
}

uint64_t AWDLActionFrame.DataPathState.supportsAirPlaySolo.setter(uint64_t result)
{
  *(_BYTE *)(v1 + 80)  = result;
  return result;
}

uint64_t (*InfraStatistics.inputBytes.modify())()
{
  return NANBitmap.Channel.operatingClass.getter;
}

uint64_t AWDLActionFrame.DataPathState.supportsUnicastMasterIndication.getter()
{
  return *(unsigned __int8 *)(v0 + 81);
}

uint64_t AWDLActionFrame.DataPathState.supportsUnicastMasterIndication.setter(uint64_t result)
{
  *(_BYTE *)(v1 + 81)  = result;
  return result;
}

uint64_t (*AWDLActionFrame.DataPathState.supportsUnicastMasterIndication.modify())()
{
  return NANBitmap.Channel.operatingClass.getter;
}

uint64_t AWDLActionFrame.DataPathState.infraRealTimeActive.getter()
{
  return *(unsigned __int8 *)(v0 + 82);
}

uint64_t AWDLActionFrame.DataPathState.infraRealTimeActive.setter(uint64_t result)
{
  *(_BYTE *)(v1 + 82)  = result;
  return result;
}

uint64_t (*AWDLActionFrame.DataPathState.infraRealTimeActive.modify())()
{
  return NANBitmap.Channel.operatingClass.getter;
}

uint64_t AWDLActionFrame.DataPathState.isRangeable.getter()
{
  return *(unsigned __int8 *)(v0 + 83);
}

uint64_t AWDLActionFrame.DataPathState.isRangeable.setter(uint64_t result)
{
  *(_BYTE *)(v1 + 83)  = result;
  return result;
}

uint64_t (*AWDLActionFrame.DataPathState.isRangeable.modify())()
{
  return NANBitmap.Channel.operatingClass.getter;
}

uint64_t AWDLActionFrame.DataPathState.supportsSimultaneousDualBand.getter()
{
  return *(unsigned __int8 *)(v0 + 84);
}

uint64_t AWDLActionFrame.DataPathState.supportsSimultaneousDualBand.setter(uint64_t result)
{
  *(_BYTE *)(v1 + 84)  = result;
  return result;
}

uint64_t (*AWDLActionFrame.DataPathState.supportsSimultaneousDualBand.modify())()
{
  return NANBitmap.Channel.operatingClass.getter;
}

uint64_t AWDLActionFrame.DataPathState.supportsDFSProxy.getter()
{
  return *(unsigned __int8 *)(v0 + 85);
}

uint64_t AWDLActionFrame.DataPathState.supportsDFSProxy.setter(uint64_t result)
{
  *(_BYTE *)(v1 + 85)  = result;
  return result;
}

uint64_t (*AWDLActionFrame.DataPathState.supportsDFSProxy.modify())()
{
  return NANBitmap.Channel.operatingClass.getter;
}

uint64_t AWDLActionFrame.DataPathState.assistedDiscoveryActive.getter()
{
  return *(unsigned __int8 *)(v0 + 86);
}

uint64_t AWDLActionFrame.DataPathState.assistedDiscoveryActive.setter(uint64_t result)
{
  *(_BYTE *)(v1 + 86)  = result;
  return result;
}

uint64_t (*AWDLActionFrame.DataPathState.assistedDiscoveryActive.modify())()
{
  return NANBitmap.Channel.operatingClass.getter;
}

uint64_t AWDLActionFrame.DataPathState.supportsSocialChannelMap.getter()
{
  return *(unsigned __int8 *)(v0 + 87);
}

uint64_t AWDLActionFrame.DataPathState.supportsSocialChannelMap.setter(uint64_t result)
{
  *(_BYTE *)(v1 + 87)  = result;
  return result;
}

uint64_t (*AWDLActionFrame.DataPathState.supportsSocialChannelMap.modify())()
{
  return NANBitmap.Channel.operatingClass.getter;
}

uint64_t AWDLActionFrame.DataPathState.nanConcurrencyEnabled.getter()
{
  return *(unsigned __int8 *)(v0 + 88);
}

uint64_t AWDLActionFrame.DataPathState.nanConcurrencyEnabled.setter(uint64_t result)
{
  *(_BYTE *)(v1 + 88)  = result;
  return result;
}

uint64_t (*InfraStatistics.linkRate.modify())()
{
  return NANBitmap.Channel.operatingClass.getter;
}

uint64_t AWDLActionFrame.DataPathState.supportsHighEfficiencyRate.getter()
{
  return *(unsigned __int8 *)(v0 + 89);
}

uint64_t AWDLActionFrame.DataPathState.supportsHighEfficiencyRate.setter(uint64_t result)
{
  *(_BYTE *)(v1 + 89)  = result;
  return result;
}

uint64_t (*AWDLActionFrame.DataPathState.supportsHighEfficiencyRate.modify())()
{
  return NANBitmap.Channel.operatingClass.getter;
}

uint64_t AWDLActionFrame.DataPathState.isSidekickHub.getter()
{
  return *(unsigned __int8 *)(v0 + 90);
}

uint64_t AWDLActionFrame.DataPathState.isSidekickHub.setter(uint64_t result)
{
  *(_BYTE *)(v1 + 90)  = result;
  return result;
}

uint64_t (*AWDLActionFrame.DataPathState.isSidekickHub.modify())()
{
  return NANBitmap.Channel.operatingClass.getter;
}

uint64_t AWDLActionFrame.DataPathState.supports6GHz.getter()
{
  return *(unsigned __int8 *)(v0 + 91);
}

uint64_t AWDLActionFrame.DataPathState.supports6GHz.setter(uint64_t result)
{
  *(_BYTE *)(v1 + 91)  = result;
  return result;
}

uint64_t (*AWDLActionFrame.DataPathState.supports6GHz.modify())()
{
  return NANBitmap.Channel.operatingClass.getter;
}

uint64_t AWDLActionFrame.DataPathState.supportsUltraLowLatencyInfra.getter()
{
  return *(unsigned __int8 *)(v0 + 92);
}

uint64_t AWDLActionFrame.DataPathState.supportsUltraLowLatencyInfra.setter(uint64_t result)
{
  *(_BYTE *)(v1 + 92)  = result;
  return result;
}

uint64_t (*AWDLActionFrame.DataPathState.supportsUltraLowLatencyInfra.modify())()
{
  return NANBitmap.Channel.operatingClass.getter;
}

uint64_t AWDLActionFrame.DataPathState.proModeActive.getter()
{
  return *(unsigned __int8 *)(v0 + 93);
}

uint64_t AWDLActionFrame.DataPathState.proModeActive.setter(uint64_t result)
{
  *(_BYTE *)(v1 + 93)  = result;
  return result;
}

uint64_t (*AWDLActionFrame.DataPathState.proModeActive.modify())()
{
  return NANBitmap.Channel.operatingClass.getter;
}

uint64_t AWDLActionFrame.DataPathState.hasChannelSequence.getter()
{
  return *(unsigned __int8 *)(v0 + 94);
}

uint64_t AWDLActionFrame.DataPathState.hasChannelSequence.setter(uint64_t result)
{
  *(_BYTE *)(v1 + 94)  = result;
  return result;
}

uint64_t (*AWDLActionFrame.DataPathState.hasChannelSequence.modify())()
{
  return NANBitmap.Channel.operatingClass.getter;
}

uint64_t AWDLActionFrame.DataPathState.awdlOnSince.getter@<X0>(uint64_t a1@<X8>)
{
  uint64_t v3 = v1 + *(int *)(type metadata accessor for AWDLActionFrame.DataPathState(0LL) + 136);
  return sub_1000DB8E8(v3, a1);
}

uint64_t AWDLActionFrame.DataPathState.awdlOnSince.setter(uint64_t a1)
{
  uint64_t v3 = v1 + *(int *)(type metadata accessor for AWDLActionFrame.DataPathState(0LL) + 136);
  return sub_1000DB930(a1, v3);
}

uint64_t (*AWDLActionFrame.DataPathState.awdlOnSince.modify())(void)
{
  return NANBitmap.Channel.operatingClass.getter;
}

unint64_t AWDLActionFrame.DataPathState.availabilityWindowSequenceNumber.getter()
{
  uint64_t v1 = (unsigned int *)(v0 + *(int *)(type metadata accessor for AWDLActionFrame.DataPathState(0LL) + 140));
  return *v1 | ((unint64_t)*((unsigned __int8 *)v1 + 4) << 32);
}

uint64_t AWDLActionFrame.DataPathState.availabilityWindowSequenceNumber.setter(uint64_t a1)
{
  uint64_t result = type metadata accessor for AWDLActionFrame.DataPathState(0LL);
  uint64_t v4 = v1 + *(int *)(result + 140);
  *(_DWORD *)uint64_t v4 = a1;
  *(_BYTE *)(v4 + 4)  = BYTE4(a1) & 1;
  return result;
}

uint64_t (*AWDLActionFrame.DataPathState.availabilityWindowSequenceNumber.modify())(void)
{
  return NANBitmap.Channel.operatingClass.getter;
}

unint64_t AWDLActionFrame.DataPathState.actionFrameUpdateCounter.getter()
{
  uint64_t v1 = (unsigned int *)(v0 + *(int *)(type metadata accessor for AWDLActionFrame.DataPathState(0LL) + 144));
  return *v1 | ((unint64_t)*((unsigned __int8 *)v1 + 4) << 32);
}

uint64_t AWDLActionFrame.DataPathState.actionFrameUpdateCounter.setter(uint64_t a1)
{
  uint64_t result = type metadata accessor for AWDLActionFrame.DataPathState(0LL);
  uint64_t v4 = v1 + *(int *)(result + 144);
  *(_DWORD *)uint64_t v4 = a1;
  *(_BYTE *)(v4 + 4)  = BYTE4(a1) & 1;
  return result;
}

uint64_t (*AWDLActionFrame.DataPathState.actionFrameUpdateCounter.modify())(void)
{
  return NANBitmap.Channel.operatingClass.getter;
}

void AWDLActionFrame.DataPathState.hash(into:)(uint64_t a1)
{
  uint64_t v2 = v1;
  uint64_t v4 = type metadata accessor for DispatchTimeInterval(0LL);
  uint64_t v5 = *(void *)(v4 - 8);
  __chkstk_darwin(v4);
  uint64_t v54 = (char *)&v53 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v7 = sub_100002274(&qword_100407450);
  __chkstk_darwin(v7);
  unint64_t v9 = (char *)&v53 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  LOBYTE(v8)  = *((_BYTE *)v2 + 2);
  uint64_t v55 = v5;
  if ((v8 & 1) != 0)
  {
    LOBYTE(v10)  = 0;
  }

  else
  {
    unsigned int v11 = *v2;
    unsigned int v10 = v11 >> 8;
    Hasher._combine(_:)(1u);
    Hasher._combine(_:)(v11);
  }

  Hasher._combine(_:)(v10);
  unint64_t v12 = *((unsigned int *)v2 + 1) | ((unint64_t)v2[4] << 32);
  if ((v12 & 0xFF00000000LL) == 0x300000000LL)
  {
    Swift::UInt8 v13 = 0;
LABEL_6:
    Hasher._combine(_:)(v13);
  }

  else
  {
    Hasher._combine(_:)(1u);
    Hasher._combine(_:)(v12);
    Hasher._combine(_:)(0x801004u >> ((v12 >> 29) & 0xF8));
    switch(v12 >> 40)
    {
      case 2uLL:
        Swift::UInt v14 = 0LL;
        break;
      case 3uLL:
        Swift::UInt v14 = 1LL;
        break;
      case 4uLL:
        Swift::UInt v14 = 3LL;
        break;
      case 5uLL:
        Swift::UInt v14 = 4LL;
        break;
      case 6uLL:
        Swift::UInt v14 = 5LL;
        break;
      default:
        Hasher._combine(_:)(2uLL);
        Swift::UInt8 v13 = BYTE5(v12) & 1;
        goto LABEL_6;
    }

    Hasher._combine(_:)(v14);
  }

  char v15 = *((_BYTE *)v2 + 16);
  uint64_t v56 = v4;
  if ((v15 & 1) != 0)
  {
    LOBYTE(v16)  = 0;
  }

  else
  {
    unsigned int v17 = v2[7];
    unsigned int v18 = *(_DWORD *)(v2 + 5);
    unint64_t v19 = v18 | ((unint64_t)v2[7] << 32);
    unint64_t v20 = v19 >> 8;
    unint64_t v21 = v19 >> 16;
    unint64_t v22 = v19 >> 24;
    unsigned int v16 = v17 >> 8;
    Hasher._combine(_:)(1u);
    Hasher._combine(_:)(v18);
    Hasher._combine(_:)(v20);
    Hasher._combine(_:)(v21);
    Hasher._combine(_:)(v22);
    Hasher._combine(_:)(v17);
  }

  Hasher._combine(_:)(v16);
  unint64_t v23 = *((unsigned int *)v2 + 5) | ((unint64_t)v2[12] << 32);
  if ((v23 & 0xFF00000000LL) == 0x300000000LL)
  {
    Swift::UInt8 v24 = 0;
LABEL_20:
    Hasher._combine(_:)(v24);
    if ((v2[16] & 1) != 0)
    {
LABEL_21:
      LOBYTE(v25)  = 0;
      goto LABEL_31;
    }
  }

  else
  {
    Hasher._combine(_:)(1u);
    Hasher._combine(_:)(v23);
    Hasher._combine(_:)(0x801004u >> ((v23 >> 29) & 0xF8));
    switch(v23 >> 40)
    {
      case 2uLL:
        Swift::UInt v26 = 0LL;
        break;
      case 3uLL:
        Swift::UInt v26 = 1LL;
        break;
      case 4uLL:
        Swift::UInt v26 = 3LL;
        break;
      case 5uLL:
        Swift::UInt v26 = 4LL;
        break;
      case 6uLL:
        Swift::UInt v26 = 5LL;
        break;
      default:
        Hasher._combine(_:)(2uLL);
        Swift::UInt8 v24 = BYTE5(v23) & 1;
        goto LABEL_20;
    }

    Hasher._combine(_:)(v26);
    if ((v2[16] & 1) != 0) {
      goto LABEL_21;
    }
  }

  unsigned int v27 = v2[15];
  unsigned int v28 = *(_DWORD *)(v2 + 13);
  unint64_t v29 = v28 | ((unint64_t)v2[15] << 32);
  unint64_t v30 = v29 >> 8;
  unint64_t v31 = v29 >> 16;
  unint64_t v32 = v29 >> 24;
  unsigned int v25 = v27 >> 8;
  Hasher._combine(_:)(1u);
  Hasher._combine(_:)(v28);
  Hasher._combine(_:)(v30);
  Hasher._combine(_:)(v31);
  Hasher._combine(_:)(v32);
  Hasher._combine(_:)(v27);
LABEL_31:
  Hasher._combine(_:)(v25);
  uint64_t v33 = *((void *)v2 + 6);
  if (v33)
  {
    uint64_t v34 = *((void *)v2 + 5);
    Hasher._combine(_:)(1u);
    swift_bridgeObjectRetain(v33);
    String.hash(into:)(a1, v34, v33);
    swift_bridgeObjectRelease(v33);
    if ((v2[31] & 1) != 0)
    {
LABEL_33:
      LOBYTE(v35)  = 0;
      goto LABEL_36;
    }
  }

  else
  {
    Hasher._combine(_:)(0);
    if ((v2[31] & 1) != 0) {
      goto LABEL_33;
    }
  }

  unsigned int v36 = v2[30];
  unsigned int v37 = *((_DWORD *)v2 + 14);
  unint64_t v38 = v37 | ((unint64_t)v2[30] << 32);
  unint64_t v39 = v38 >> 8;
  unint64_t v40 = v38 >> 16;
  unint64_t v41 = v38 >> 24;
  unsigned int v35 = v36 >> 8;
  Hasher._combine(_:)(1u);
  Hasher._combine(_:)(v37);
  Hasher._combine(_:)(v39);
  Hasher._combine(_:)(v40);
  Hasher._combine(_:)(v41);
  Hasher._combine(_:)(v36);
LABEL_36:
  uint64_t v43 = v55;
  uint64_t v42 = v56;
  Hasher._combine(_:)(v35);
  Hasher._combine(_:)(*((_BYTE *)v2 + 63));
  uint64_t v44 = *((char *)v2 + 64);
  if (v44 == 43)
  {
    Hasher._combine(_:)(0);
  }

  else
  {
    Hasher._combine(_:)(1u);
    Hasher._combine(_:)(dword_100345098[v44]);
  }

  Hasher._combine(_:)(*((_BYTE *)v2 + 65));
  if (*((_BYTE *)v2 + 68) == 1)
  {
    Hasher._combine(_:)(0);
  }

  else
  {
    Swift::UInt16 v45 = v2[33];
    Hasher._combine(_:)(1u);
    Hasher._combine(_:)(v45);
  }

  if (*((_BYTE *)v2 + 76) == 1)
  {
    Hasher._combine(_:)(0);
  }

  else
  {
    Swift::UInt32 v46 = *((_DWORD *)v2 + 18);
    Hasher._combine(_:)(1u);
    Hasher._combine(_:)(v46);
  }

  Hasher._combine(_:)(*((_BYTE *)v2 + 77));
  Hasher._combine(_:)(*((_BYTE *)v2 + 78));
  Hasher._combine(_:)(*((_BYTE *)v2 + 79));
  Hasher._combine(_:)(*((_BYTE *)v2 + 80));
  Hasher._combine(_:)(*((_BYTE *)v2 + 81));
  Hasher._combine(_:)(*((_BYTE *)v2 + 82));
  Hasher._combine(_:)(*((_BYTE *)v2 + 83));
  Hasher._combine(_:)(*((_BYTE *)v2 + 84));
  Hasher._combine(_:)(*((_BYTE *)v2 + 85));
  Hasher._combine(_:)(*((_BYTE *)v2 + 86));
  Hasher._combine(_:)(*((_BYTE *)v2 + 87));
  Hasher._combine(_:)(*((_BYTE *)v2 + 88));
  Hasher._combine(_:)(*((_BYTE *)v2 + 89));
  Hasher._combine(_:)(*((_BYTE *)v2 + 90));
  Hasher._combine(_:)(*((_BYTE *)v2 + 91));
  Hasher._combine(_:)(*((_BYTE *)v2 + 92));
  Hasher._combine(_:)(*((_BYTE *)v2 + 93));
  Hasher._combine(_:)(*((_BYTE *)v2 + 94));
  uint64_t v47 = (int *)type metadata accessor for AWDLActionFrame.DataPathState(0LL);
  sub_1000DB8E8((uint64_t)v2 + v47[34], (uint64_t)v9);
  if ((*(unsigned int (**)(char *, uint64_t, uint64_t))(v43 + 48))(v9, 1LL, v42) == 1)
  {
    Hasher._combine(_:)(0);
  }

  else
  {
    uint64_t v48 = v54;
    (*(void (**)(char *, char *, uint64_t))(v43 + 32))(v54, v9, v42);
    Hasher._combine(_:)(1u);
    DispatchTimeInterval.hash(into:)();
    (*(void (**)(char *, uint64_t))(v43 + 8))(v48, v42);
  }

  uint64_t v49 = (char *)v2 + v47[35];
  if (v49[4] == 1)
  {
    Hasher._combine(_:)(0);
  }

  else
  {
    Swift::UInt32 v50 = *(_DWORD *)v49;
    Hasher._combine(_:)(1u);
    Hasher._combine(_:)(v50);
  }

  uint64_t v51 = (char *)v2 + v47[36];
  if (v51[4] == 1)
  {
    Hasher._combine(_:)(0);
  }

  else
  {
    Swift::UInt32 v52 = *(_DWORD *)v51;
    Hasher._combine(_:)(1u);
    Hasher._combine(_:)(v52);
  }

Swift::Int AWDLActionFrame.DataPathState.hashValue.getter()
{
  return sub_1000D3134((void (*)(void *))AWDLActionFrame.DataPathState.hash(into:));
}

uint64_t sub_1000C52AC@<X0>(void *a1@<X0>, uint64_t a2@<X8>)
{
  return AWDLActionFrame.DataPathState.init(from:)(a1, a2);
}

uint64_t AWDLActionFrame.DataPathState.init(from:)@<X0>(void *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v97 = a2;
  uint64_t v3 = type metadata accessor for String.Encoding(0LL);
  __chkstk_darwin(v3);
  unint64_t v96 = (char *)&v93 - ((v4 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v5 = type metadata accessor for AWDLActionFrame.DataPathState(0LL);
  uint64_t v6 = __chkstk_darwin(v5);
  uint64_t v8 = (char *)&v93 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  *(_WORD *)uint64_t v8 = 0;
  _OWORD v8[2] = 1;
  *((_WORD *)v8 + 4)  = 3;
  *((_DWORD *)v8 + 1)  = 0;
  *((_WORD *)v8 + 7)  = 0;
  *(_DWORD *)(v8 + 10)  = 0;
  v8[16]  = 1;
  *((_WORD *)v8 + 12)  = 3;
  *((_DWORD *)v8 + 5)  = 0;
  *((_WORD *)v8 + 15)  = 0;
  *(_DWORD *)(v8 + 26)  = 0;
  _BYTE v8[32] = 1;
  *((void *)v8 + 5)  = 0LL;
  *((void *)v8 + 6)  = 0LL;
  *(void *)(v8 + 54)  = 0LL;
  v8[62]  = 1;
  v8[64]  = 43;
  *((_WORD *)v8 + 33)  = 0;
  v8[68]  = 1;
  *((_DWORD *)v8 + 18)  = 0;
  uint64_t v9 = (uint64_t)&v8[*(int *)(v6 + 136)];
  v8[76]  = 1;
  uint64_t v10 = type metadata accessor for DispatchTimeInterval(0LL);
  uint64_t v11 = *(void *)(v10 - 8);
  unint64_t v12 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v11 + 56);
  uint64_t v98 = (void *)v9;
  v12(v9, 1LL, 1LL, v10);
  Swift::UInt8 v13 = &v8[*(int *)(v5 + 140)];
  *(_DWORD *)Swift::UInt8 v13 = 0;
  void v13[4] = 1;
  uint64_t v14 = *(int *)(v5 + 144);
  uint64_t v101 = v8;
  char v15 = &v8[v14];
  *(_DWORD *)char v15 = 0;
  void v15[4] = 1;
  uint64_t v17 = a1[3];
  uint64_t v16 = a1[4];
  unint64_t v99 = a1;
  sub_100021104(a1, v17);
  uint64_t v18 = v100;
  dispatch thunk of Decoder.unkeyedContainer()(v102, v17, v16);
  if (v18)
  {
    Swift::UInt8 v24 = v101;
    sub_100002AC4(v99);
    swift_bridgeObjectRelease(*((void *)v24 + 6));
    return sub_1000225EC((uint64_t)v98, &qword_100407450);
  }

  uint64_t v100 = v11;
  unint64_t v94 = v15;
  unint64_t v95 = v13;
  uint64_t v19 = v97;
  uint64_t v20 = v103;
  uint64_t v21 = v104;
  sub_1000237C8((uint64_t)v102, v103);
  unint64_t v22 = sub_1000DB978();
  dispatch thunk of UnkeyedDecodingContainer.decode<A>(_:)( &type metadata for AWDLActionFrame.DataPathState.Flags,  &type metadata for AWDLActionFrame.DataPathState.Flags,  v22,  v20,  v21);
  unsigned int v26 = (__int16)v105;
  uint64_t v27 = (uint64_t)v101;
  v101[77]  = (v105 & 0x20) != 0;
  *(_BYTE *)(v27 + 78)  = (v26 & 0x40) != 0;
  *(_BYTE *)(v27 + 94)  = (v26 & 0x10) != 0;
  *(_BYTE *)(v27 + 79)  = (v26 & 0x80) != 0;
  v23.i64[0]  = *(void *)&vshl_u16((uint16x4_t)vdup_n_s16(v26), (uint16x4_t)0xFFF2FFF3FFF5FFF6LL) & 0xFFC1FFC1FFC1FFC1LL;
  *(_DWORD *)(v27 + 80)  = vmovn_s16(v23).u32[0];
  if ((v26 & 0x100) != 0)
  {
    uint64_t v36 = v103;
    uint64_t v37 = v104;
    sub_1000237C8((uint64_t)v102, v103);
    LOBYTE(v37)  = dispatch thunk of UnkeyedDecodingContainer.decode(_:)(v36, v37);
    uint64_t v38 = v103;
    uint64_t v93 = v104;
    sub_1000237C8((uint64_t)v102, v103);
    *(_WORD *)uint64_t v27 = v37 | (unsigned __int16)((unsigned __int16)dispatch thunk of UnkeyedDecodingContainer.decode(_:)( v38,  v93) << 8);
    *(_BYTE *)(v27 + 2)  = 0;
    uint64_t v39 = v103;
    uint64_t v40 = v104;
    sub_1000237C8((uint64_t)v102, v103);
    dispatch thunk of UnkeyedDecodingContainer.decode(_:)(v39, v40);
  }

  if ((v26 & 0x200) != 0)
  {
    uint64_t v28 = v103;
    uint64_t v29 = v104;
    sub_1000237C8((uint64_t)v102, v103);
    unsigned __int16 v30 = dispatch thunk of UnkeyedDecodingContainer.decode(_:)(v28, v29);
    unint64_t v31 = sub_1001889D8(v30);
    *(_DWORD *)(v27 + 4)  = v31;
    *(_WORD *)(v27 + 8)  = WORD2(v31);
  }

  if ((v26 & 1) == 0)
  {
    if ((v26 & 2) == 0) {
      goto LABEL_12;
    }
    goto LABEL_10;
  }

  LODWORD(v93)  = v26;
  uint64_t v41 = v103;
  uint64_t v42 = v104;
  sub_1000237C8((uint64_t)v102, v103);
  unint64_t v43 = sub_1000290F8();
  dispatch thunk of UnkeyedDecodingContainer.decode<A>(_:)( &type metadata for WiFiAddress,  &type metadata for WiFiAddress,  v43,  v41,  v42);
  unint64_t v44 = ((unint64_t)v107 << 40) | ((unint64_t)v106 << 32);
  *(_DWORD *)(v27 + 10)  = v105;
  *(_WORD *)(v27 + 14)  = WORD2(v44);
  *(_BYTE *)(v27 + 16)  = 0;
  uint64_t v45 = v103;
  uint64_t v46 = v104;
  sub_1000237C8((uint64_t)v102, v103);
  unsigned __int16 v47 = dispatch thunk of UnkeyedDecodingContainer.decode(_:)(v45, v46);
  unint64_t v48 = sub_1001889D8(v47);
  *(_DWORD *)(v27 + 20)  = v48;
  *(_WORD *)(v27 + 24)  = WORD2(v48);
  unsigned int v26 = v93;
  if ((v93 & 2) != 0)
  {
LABEL_10:
    uint64_t v32 = v103;
    uint64_t v33 = v104;
    sub_1000237C8((uint64_t)v102, v103);
    unint64_t v34 = sub_1000290F8();
    dispatch thunk of UnkeyedDecodingContainer.decode<A>(_:)( &type metadata for WiFiAddress,  &type metadata for WiFiAddress,  v34,  v32,  v33);
    unint64_t v35 = ((unint64_t)v107 << 40) | ((unint64_t)v106 << 32);
    *(_DWORD *)(v27 + 26)  = v105;
    *(_WORD *)(v27 + 30)  = WORD2(v35);
    *(_BYTE *)(v27 + 32)  = 0;
  }

uint64_t sub_1000C5B30(unsigned __int16 *a1)
{
  return AWDLActionFrame.DataPathState.encode(to:)(a1);
}

uint64_t AWDLActionFrame.DataPathState.encode(to:)(unsigned __int16 *a1)
{
  uint64_t v2 = v1;
  uint64_t v4 = sub_100002274(&qword_100407450);
  __chkstk_darwin(v4);
  uint64_t v6 = (char *)&v144 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v7 = type metadata accessor for DispatchTimeInterval(0LL);
  __chkstk_darwin(v7);
  uint64_t v147 = (char *)&v144 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  char v9 = *((_BYTE *)v2 + 78);
  int v10 = *((unsigned __int8 *)v2 + 94);
  int v11 = *((unsigned __int8 *)v2 + 79);
  int v12 = *((unsigned __int8 *)v2 + 80);
  char v13 = *((_BYTE *)v2 + 81);
  BOOL v14 = *((_BYTE *)v2 + 77) == 1;
  uint64_t v149 = v15;
  unint64_t v148 = v6;
  if (!v14)
  {
    if ((v9 & 1) != 0)
    {
      if ((v10 & 1) != 0)
      {
        if (v11)
        {
          if (v12)
          {
            if ((v13 & 1) != 0)
            {
              int v16 = 3280;
              goto LABEL_97;
            }

            if ((v2[41] & 1) != 0)
            {
              int v16 = 1232;
              goto LABEL_98;
            }

            int v16 = 1232;
            if ((*((_BYTE *)v2 + 83) & 1) == 0) {
              goto LABEL_101;
            }
LABEL_100:
            v16 |= 0x4000u;
            goto LABEL_101;
          }

          if ((v13 & 1) == 0)
          {
            if ((v2[41] & 1) != 0)
            {
              int v16 = 208;
              goto LABEL_98;
            }

            int v16 = 208;
            if ((*((_BYTE *)v2 + 83) & 1) == 0) {
              goto LABEL_101;
            }
            goto LABEL_100;
          }

          int v16 = 2256;
        }

        else if (v12)
        {
          if ((v13 & 1) == 0)
          {
            if ((v2[41] & 1) != 0)
            {
              int v16 = 1104;
              goto LABEL_98;
            }

            int v16 = 1104;
            if ((*((_BYTE *)v2 + 83) & 1) == 0) {
              goto LABEL_101;
            }
            goto LABEL_100;
          }

          int v16 = 3152;
        }

        else
        {
          if ((v13 & 1) == 0)
          {
            if ((v2[41] & 1) != 0)
            {
              int v16 = 80;
              goto LABEL_98;
            }

            int v16 = 80;
            if ((*((_BYTE *)v2 + 83) & 1) == 0) {
              goto LABEL_101;
            }
            goto LABEL_100;
          }

          int v16 = 2128;
        }
      }

      else if (v11)
      {
        if (v12)
        {
          if ((v13 & 1) == 0)
          {
            if ((v2[41] & 1) != 0)
            {
              int v16 = 1216;
              goto LABEL_98;
            }

            int v16 = 1216;
            if ((*((_BYTE *)v2 + 83) & 1) == 0) {
              goto LABEL_101;
            }
            goto LABEL_100;
          }

          int v16 = 3264;
        }

        else
        {
          if ((v13 & 1) == 0)
          {
            if ((v2[41] & 1) != 0)
            {
              int v16 = 192;
              goto LABEL_98;
            }

            int v16 = 192;
            if ((*((_BYTE *)v2 + 83) & 1) == 0) {
              goto LABEL_101;
            }
            goto LABEL_100;
          }

          int v16 = 2240;
        }
      }

      else if (v12)
      {
        if ((v13 & 1) == 0)
        {
          if ((v2[41] & 1) != 0)
          {
            int v16 = 1088;
            goto LABEL_98;
          }

          int v16 = 1088;
          if ((*((_BYTE *)v2 + 83) & 1) == 0) {
            goto LABEL_101;
          }
          goto LABEL_100;
        }

        int v16 = 3136;
      }

      else
      {
        if ((v13 & 1) == 0)
        {
          if ((v2[41] & 1) != 0)
          {
            int v16 = 64;
            goto LABEL_98;
          }

          int v16 = 64;
          if ((*((_BYTE *)v2 + 83) & 1) == 0) {
            goto LABEL_101;
          }
          goto LABEL_100;
        }

        int v16 = 2112;
      }
    }

    else if (v10)
    {
      if ((v11 & 1) != 0)
      {
        if ((v12 & 1) != 0)
        {
          if ((v13 & 1) == 0)
          {
            if ((v2[41] & 1) != 0)
            {
              int v16 = 1168;
              goto LABEL_98;
            }

            int v16 = 1168;
            if ((*((_BYTE *)v2 + 83) & 1) == 0) {
              goto LABEL_101;
            }
            goto LABEL_100;
          }

          int v16 = 3216;
        }

        else
        {
          if ((v13 & 1) == 0)
          {
            if ((v2[41] & 1) != 0)
            {
              int v16 = 144;
              goto LABEL_98;
            }

            int v16 = 144;
            if ((*((_BYTE *)v2 + 83) & 1) == 0) {
              goto LABEL_101;
            }
            goto LABEL_100;
          }

          int v16 = 2192;
        }
      }

      else if ((v12 & 1) != 0)
      {
        if ((v13 & 1) == 0)
        {
          if ((v2[41] & 1) != 0)
          {
            int v16 = 1040;
            goto LABEL_98;
          }

          int v16 = 1040;
          if ((*((_BYTE *)v2 + 83) & 1) == 0) {
            goto LABEL_101;
          }
          goto LABEL_100;
        }

        int v16 = 3088;
      }

      else
      {
        if ((v13 & 1) == 0)
        {
          if ((v2[41] & 1) != 0)
          {
            int v16 = 16;
            goto LABEL_98;
          }

          int v16 = 16;
          if ((*((_BYTE *)v2 + 83) & 1) == 0) {
            goto LABEL_101;
          }
          goto LABEL_100;
        }

        int v16 = 2064;
      }
    }

    else if (v11)
    {
      if (v12)
      {
        if ((v13 & 1) == 0)
        {
          if ((v2[41] & 1) != 0)
          {
            int v16 = 1152;
            goto LABEL_98;
          }

          int v16 = 1152;
          if ((*((_BYTE *)v2 + 83) & 1) == 0) {
            goto LABEL_101;
          }
          goto LABEL_100;
        }

        int v16 = 3200;
      }

      else
      {
        if ((v13 & 1) == 0)
        {
          if ((v2[41] & 1) != 0)
          {
            int v16 = 128;
            goto LABEL_98;
          }

          int v16 = 128;
          if ((*((_BYTE *)v2 + 83) & 1) == 0) {
            goto LABEL_101;
          }
          goto LABEL_100;
        }

        int v16 = 2176;
      }
    }

    else if (v12)
    {
      if ((v13 & 1) == 0)
      {
        if ((v2[41] & 1) != 0)
        {
          int v16 = 1024;
          goto LABEL_98;
        }

        int v16 = 1024;
        if ((*((_BYTE *)v2 + 83) & 1) == 0) {
          goto LABEL_101;
        }
        goto LABEL_100;
      }

      int v16 = 3072;
    }

    else
    {
      if ((v13 & 1) == 0)
      {
        if ((v2[41] & 1) != 0)
        {
          int v16 = 0;
          goto LABEL_98;
        }

        int v16 = 0;
        if ((*((_BYTE *)v2 + 83) & 1) == 0) {
          goto LABEL_101;
        }
        goto LABEL_100;
      }

      int v16 = 2048;
    }

    goto LABEL_97;
  }

  if ((v9 & 1) == 0)
  {
    if ((v10 & 1) != 0)
    {
      if ((v11 & 1) != 0)
      {
        if (v12)
        {
          if ((v13 & 1) == 0)
          {
            if ((v2[41] & 1) != 0)
            {
              int v16 = 1200;
              goto LABEL_98;
            }

            int v16 = 1200;
            if ((*((_BYTE *)v2 + 83) & 1) == 0) {
              goto LABEL_101;
            }
            goto LABEL_100;
          }

          int v16 = 3248;
        }

        else
        {
          if ((v13 & 1) == 0)
          {
            if ((v2[41] & 1) != 0)
            {
              int v16 = 176;
              goto LABEL_98;
            }

            int v16 = 176;
            if ((*((_BYTE *)v2 + 83) & 1) == 0) {
              goto LABEL_101;
            }
            goto LABEL_100;
          }

          int v16 = 2224;
        }
      }

      else if (v12)
      {
        if ((v13 & 1) == 0)
        {
          if ((v2[41] & 1) != 0)
          {
            int v16 = 1072;
            goto LABEL_98;
          }

          int v16 = 1072;
          if ((*((_BYTE *)v2 + 83) & 1) == 0) {
            goto LABEL_101;
          }
          goto LABEL_100;
        }

        int v16 = 3120;
      }

      else
      {
        if ((v13 & 1) == 0)
        {
          if ((v2[41] & 1) != 0)
          {
            int v16 = 48;
            goto LABEL_98;
          }

          int v16 = 48;
          if ((*((_BYTE *)v2 + 83) & 1) == 0) {
            goto LABEL_101;
          }
          goto LABEL_100;
        }

        int v16 = 2096;
      }
    }

    else if (v11)
    {
      if (v12)
      {
        if ((v13 & 1) == 0)
        {
          if ((v2[41] & 1) != 0)
          {
            int v16 = 1184;
            goto LABEL_98;
          }

          int v16 = 1184;
          if ((*((_BYTE *)v2 + 83) & 1) == 0) {
            goto LABEL_101;
          }
          goto LABEL_100;
        }

        int v16 = 3232;
      }

      else
      {
        if ((v13 & 1) == 0)
        {
          if ((v2[41] & 1) != 0)
          {
            int v16 = 160;
            goto LABEL_98;
          }

          int v16 = 160;
          if ((*((_BYTE *)v2 + 83) & 1) == 0) {
            goto LABEL_101;
          }
          goto LABEL_100;
        }

        int v16 = 2208;
      }
    }

    else if (v12)
    {
      if ((v13 & 1) == 0)
      {
        if ((v2[41] & 1) != 0)
        {
          int v16 = 1056;
          goto LABEL_98;
        }

        int v16 = 1056;
        if ((*((_BYTE *)v2 + 83) & 1) == 0) {
          goto LABEL_101;
        }
        goto LABEL_100;
      }

      int v16 = 3104;
    }

    else
    {
      if ((v13 & 1) == 0)
      {
        if ((v2[41] & 1) != 0)
        {
          int v16 = 32;
          goto LABEL_98;
        }

        int v16 = 32;
        if ((*((_BYTE *)v2 + 83) & 1) == 0) {
          goto LABEL_101;
        }
        goto LABEL_100;
      }

      int v16 = 2080;
    }

LABEL_384:
                      swift_release(v20);
                      swift_release(v94);
LABEL_385:
                      sub_100002AC4(v159);
                      return sub_100002AC4(&v162);
                    }
                  }

                  else
                  {
                    uint64_t v96 = v2[33];
                    sub_1000237C8((uint64_t)v159, (uint64_t)&type metadata for BinaryEncoder.UnkeyedContainer);
                    swift_retain();
                    uint64_t v97 = *(void *)&v152[4];
                    dispatch thunk of UnkeyedEncodingContainer.encode(_:)( v96,  &type metadata for BinaryEncoder.UnkeyedContainer,  v91);
                    *(void *)&v152[4]  = v97;
                    if (v97) {
                      goto LABEL_384;
                    }
                    v95 |= 1u;
                    if ((v2[38] & 1) != 0) {
                      goto LABEL_358;
                    }
                  }

                  uint64_t v98 = *((unsigned int *)v2 + 18);
                  unint64_t v99 = v160;
                  unint64_t v100 = v161;
                  sub_1000237C8((uint64_t)v159, (uint64_t)v160);
                  uint64_t v101 = *(void *)&v152[4];
                  dispatch thunk of UnkeyedEncodingContainer.encode(_:)(v98, v99, v100);
                  *(void *)&v152[4]  = v101;
                  if (v101) {
                    goto LABEL_384;
                  }
                  *(void *)&__int128 v150 = v94;
                  v95 |= 4u;
                  goto LABEL_363;
                }

LABEL_355:
                v95 |= 0x2000u;
                goto LABEL_356;
              }

              int v95 = 458;
            }

            else
            {
              if ((v2[44] & 1) == 0)
              {
                if ((v2[45] & 1) != 0)
                {
                  int v95 = 328;
                  goto LABEL_349;
                }

                if ((*((_BYTE *)v2 + 91) & 1) != 0)
                {
                  int v95 = 328;
                  goto LABEL_351;
                }

                if ((v2[46] & 1) != 0)
                {
                  int v95 = 328;
                  goto LABEL_353;
                }

                int v95 = 328;
                if ((*((_BYTE *)v2 + 93) & 1) == 0) {
                  goto LABEL_356;
                }
                goto LABEL_355;
              }

              int v95 = 456;
            }
          }

          else if (*((_BYTE *)v2 + 86))
          {
            if ((v2[44] & 1) == 0)
            {
              if ((v2[45] & 1) != 0)
              {
                int v95 = 74;
                goto LABEL_349;
              }

              if ((*((_BYTE *)v2 + 91) & 1) != 0)
              {
                int v95 = 74;
                goto LABEL_351;
              }

              if ((v2[46] & 1) != 0)
              {
                int v95 = 74;
                goto LABEL_353;
              }

              int v95 = 74;
              if ((*((_BYTE *)v2 + 93) & 1) == 0) {
                goto LABEL_356;
              }
              goto LABEL_355;
            }

            int v95 = 202;
          }

          else
          {
            if ((v2[44] & 1) == 0)
            {
              if ((v2[45] & 1) != 0)
              {
                int v95 = 72;
                goto LABEL_349;
              }

              if ((*((_BYTE *)v2 + 91) & 1) != 0)
              {
                int v95 = 72;
                goto LABEL_351;
              }

              if ((v2[46] & 1) != 0)
              {
                int v95 = 72;
                goto LABEL_353;
              }

              int v95 = 72;
              if ((*((_BYTE *)v2 + 93) & 1) == 0) {
                goto LABEL_356;
              }
              goto LABEL_355;
            }

            int v95 = 200;
          }
        }

        else if (*((_BYTE *)v2 + 89))
        {
          if (*((_BYTE *)v2 + 86))
          {
            if ((v2[44] & 1) == 0)
            {
              if ((v2[45] & 1) != 0)
              {
                int v95 = 322;
                goto LABEL_349;
              }

              if ((*((_BYTE *)v2 + 91) & 1) != 0)
              {
                int v95 = 322;
                goto LABEL_351;
              }

              if ((v2[46] & 1) != 0)
              {
                int v95 = 322;
                goto LABEL_353;
              }

              int v95 = 322;
              if ((*((_BYTE *)v2 + 93) & 1) == 0) {
                goto LABEL_356;
              }
              goto LABEL_355;
            }

            int v95 = 450;
          }

          else
          {
            if ((v2[44] & 1) == 0)
            {
              if ((v2[45] & 1) != 0)
              {
                int v95 = 320;
                goto LABEL_349;
              }

              if ((*((_BYTE *)v2 + 91) & 1) != 0)
              {
                int v95 = 320;
                goto LABEL_351;
              }

              if ((v2[46] & 1) != 0)
              {
                int v95 = 320;
                goto LABEL_353;
              }

              int v95 = 320;
              if ((*((_BYTE *)v2 + 93) & 1) == 0) {
                goto LABEL_356;
              }
              goto LABEL_355;
            }

            int v95 = 448;
          }
        }

        else if (*((_BYTE *)v2 + 86))
        {
          if ((v2[44] & 1) == 0)
          {
            if ((v2[45] & 1) != 0)
            {
              int v95 = 66;
              goto LABEL_349;
            }

            if ((*((_BYTE *)v2 + 91) & 1) != 0)
            {
              int v95 = 66;
              goto LABEL_351;
            }

            if ((v2[46] & 1) != 0)
            {
              int v95 = 66;
              goto LABEL_353;
            }

            int v95 = 66;
            if ((*((_BYTE *)v2 + 93) & 1) == 0) {
              goto LABEL_356;
            }
            goto LABEL_355;
          }

          int v95 = 194;
        }

        else
        {
          if ((v2[44] & 1) == 0)
          {
            if ((v2[45] & 1) != 0)
            {
              int v95 = 64;
              goto LABEL_349;
            }

            if ((*((_BYTE *)v2 + 91) & 1) != 0)
            {
              int v95 = 64;
              goto LABEL_351;
            }

            if ((v2[46] & 1) != 0)
            {
              int v95 = 64;
              goto LABEL_353;
            }

            int v95 = 64;
            if ((*((_BYTE *)v2 + 93) & 1) == 0) {
              goto LABEL_356;
            }
            goto LABEL_355;
          }

          int v95 = 192;
        }
      }

      else if (*((_BYTE *)v2 + 87))
      {
        if ((*((_BYTE *)v2 + 89) & 1) != 0)
        {
          if ((v2[43] & 1) != 0)
          {
            if ((v2[44] & 1) == 0)
            {
              if ((v2[45] & 1) != 0)
              {
                int v95 = 266;
                goto LABEL_349;
              }

              if ((*((_BYTE *)v2 + 91) & 1) != 0)
              {
                int v95 = 266;
                goto LABEL_351;
              }

              if ((v2[46] & 1) != 0)
              {
                int v95 = 266;
                goto LABEL_353;
              }

              int v95 = 266;
              if ((*((_BYTE *)v2 + 93) & 1) == 0) {
                goto LABEL_356;
              }
              goto LABEL_355;
            }

            int v95 = 394;
          }

          else
          {
            if ((v2[44] & 1) == 0)
            {
              if ((v2[45] & 1) != 0)
              {
                int v95 = 264;
                goto LABEL_349;
              }

              if ((*((_BYTE *)v2 + 91) & 1) != 0)
              {
                int v95 = 264;
                goto LABEL_351;
              }

              if ((v2[46] & 1) != 0)
              {
                int v95 = 264;
                goto LABEL_353;
              }

              int v95 = 264;
              if ((*((_BYTE *)v2 + 93) & 1) == 0) {
                goto LABEL_356;
              }
              goto LABEL_355;
            }

            int v95 = 392;
          }
        }

        else if ((v2[43] & 1) != 0)
        {
          if ((v2[44] & 1) == 0)
          {
            if ((v2[45] & 1) != 0)
            {
              int v95 = 10;
              goto LABEL_349;
            }

            if ((*((_BYTE *)v2 + 91) & 1) != 0)
            {
              int v95 = 10;
              goto LABEL_351;
            }

            if ((v2[46] & 1) != 0)
            {
              int v95 = 10;
              goto LABEL_353;
            }

            int v95 = 10;
            if ((*((_BYTE *)v2 + 93) & 1) == 0) {
              goto LABEL_356;
            }
            goto LABEL_355;
          }

          int v95 = 138;
        }

        else
        {
          if ((v2[44] & 1) == 0)
          {
            if ((v2[45] & 1) != 0)
            {
              int v95 = 8;
              goto LABEL_349;
            }

            if ((*((_BYTE *)v2 + 91) & 1) != 0)
            {
              int v95 = 8;
              goto LABEL_351;
            }

            if ((v2[46] & 1) != 0)
            {
              int v95 = 8;
              goto LABEL_353;
            }

            int v95 = 8;
            if ((*((_BYTE *)v2 + 93) & 1) == 0) {
              goto LABEL_356;
            }
            goto LABEL_355;
          }

          int v95 = 136;
        }
      }

      else if (*((_BYTE *)v2 + 89))
      {
        if (*((_BYTE *)v2 + 86))
        {
          if ((v2[44] & 1) == 0)
          {
            if ((v2[45] & 1) != 0)
            {
              int v95 = 258;
              goto LABEL_349;
            }

            if ((*((_BYTE *)v2 + 91) & 1) != 0)
            {
              int v95 = 258;
              goto LABEL_351;
            }

            if ((v2[46] & 1) != 0)
            {
              int v95 = 258;
              goto LABEL_353;
            }

            int v95 = 258;
            if ((*((_BYTE *)v2 + 93) & 1) == 0) {
              goto LABEL_356;
            }
            goto LABEL_355;
          }

          int v95 = 386;
        }

        else
        {
          if ((v2[44] & 1) == 0)
          {
            if ((v2[45] & 1) != 0)
            {
              int v95 = 256;
              goto LABEL_349;
            }

            if ((*((_BYTE *)v2 + 91) & 1) != 0)
            {
              int v95 = 256;
              goto LABEL_351;
            }

            if ((v2[46] & 1) != 0)
            {
              int v95 = 256;
              goto LABEL_353;
            }

            int v95 = 256;
            if ((*((_BYTE *)v2 + 93) & 1) == 0) {
              goto LABEL_356;
            }
            goto LABEL_355;
          }

          int v95 = 384;
        }
      }

      else if (*((_BYTE *)v2 + 86))
      {
        if ((v2[44] & 1) == 0)
        {
          if ((v2[45] & 1) != 0)
          {
            int v95 = 2;
            goto LABEL_349;
          }

          if ((*((_BYTE *)v2 + 91) & 1) != 0)
          {
            int v95 = 2;
            goto LABEL_351;
          }

          if ((v2[46] & 1) != 0)
          {
            int v95 = 2;
            goto LABEL_353;
          }

          int v95 = 2;
          if ((*((_BYTE *)v2 + 93) & 1) == 0) {
            goto LABEL_356;
          }
          goto LABEL_355;
        }

        int v95 = 130;
      }

      else
      {
        if ((v2[44] & 1) == 0)
        {
          if ((v2[45] & 1) != 0)
          {
            int v95 = 0;
            goto LABEL_349;
          }

          if ((*((_BYTE *)v2 + 91) & 1) != 0)
          {
            int v95 = 0;
            goto LABEL_351;
          }

          if ((v2[46] & 1) != 0)
          {
            int v95 = 0;
            goto LABEL_353;
          }

          int v95 = 0;
          if ((*((_BYTE *)v2 + 93) & 1) == 0) {
            goto LABEL_356;
          }
          goto LABEL_355;
        }

        int v95 = 128;
      }

LABEL_348:
      if ((v2[45] & 1) == 0) {
        goto LABEL_350;
      }
      goto LABEL_349;
    }

    uint64_t v32 = v2[7];
    unint64_t v33 = *(unsigned int *)(v2 + 5) | (unint64_t)(v32 << 32);
    LOBYTE(v159[0])  = *(_DWORD *)(v2 + 5);
    v34.i64[0]  = 0xFFFFFFFFFFFFLL;
    v34.i64[1]  = 0xFFFFFFFFFFFFLL;
    uint64x2_t v35 = (uint64x2_t)vandq_s8((int8x16_t)vdupq_n_s64(v33), v34);
    int16x8_t v36 = (int16x8_t)vshlq_u64(v35, (uint64x2_t)xmmword_10033A8F0);
    *(int32x2_t *)v35.i8  = vmovn_s64((int64x2_t)vshlq_u64(v35, (uint64x2_t)xmmword_10033A8E0));
    *(int32x2_t *)v36.i8  = vmovn_s64((int64x2_t)v36);
    v36.i16[1]  = v36.i16[2];
    v36.i16[2]  = v35.i16[0];
    v36.i16[3]  = v35.i16[2];
    *(_DWORD *)((char *)v159 + 1)  = vmovn_s16(v36).u32[0];
    BYTE5(v159[0])  = BYTE1(v32);
    uint64_t v37 = v163;
    unint64_t v38 = v164;
    sub_1000237C8((uint64_t)&v162, (uint64_t)v163);
    unint64_t v39 = sub_1000286C4();
    uint64_t v40 = *(void *)&v152[4];
    dispatch thunk of UnkeyedEncodingContainer.encode<A>(_:)(v159, &type metadata for WiFiAddress, v39, v37, v38);
    *(void *)&v152[4]  = v40;
    if (!v40)
    {
      if ((v31 & 0xFFFF0000) == 0)
      {
        *(_DWORD *)v152 |= 1u;
        LOWORD(v156[0])  = v31;
        uint64_t v41 = sub_1000EF854((uint64_t)v156, (uint64_t)v156 + 2);
        unint64_t v43 = v42;
        swift_beginAccess(v151, v159, 33LL, 0LL);
        sub_1000FA9C4(v41, v43);
        swift_endAccess(v159);
        sub_1000208D8(v41, v43);
        unint64_t v22 = v146;
        goto LABEL_112;
      }

LABEL_645:
      _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  "Not enough bits to represent the passed value",  45LL,  2LL,  "Swift/Integers.swift",  20LL,  2,  3455LL,  0);
      __break(1u);
      JUMPOUT(0x1000C7C38LL);
    }
  }

LABEL_121:
  swift_release(v20);
  return sub_100002AC4(&v162);
}

Swift::Int sub_1000C7CF8(uint64_t a1, uint64_t a2)
{
  return sub_1000D3180(a1, a2, (void (*)(void *))AWDLActionFrame.DataPathState.hash(into:));
}

Swift::Int sub_1000C7D08(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_1000CBB80(a1, a2, a3, (void (*)(void *))AWDLActionFrame.DataPathState.hash(into:));
}

void *AWDLActionFrame.Arpa.Flags.isLinkLocal.unsafeMutableAddressor()
{
  return &static AWDLActionFrame.Arpa.Flags.isLinkLocal;
}

void *AWDLActionFrame.Arpa.Flags.isIPv6.unsafeMutableAddressor()
{
  return &static AWDLActionFrame.Arpa.Flags.isIPv6;
}

void *AWDLActionFrame.Arpa.Flags.isIPv4.unsafeMutableAddressor()
{
  return &static AWDLActionFrame.Arpa.Flags.isIPv4;
}

uint64_t sub_1000C7D3C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v6 = sub_1000DC63C();
  return RawRepresentable<>.init(from:)(a1, a2, a3, v6);
}

uint64_t sub_1000C7D98(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v6 = sub_1000DC63C();
  return RawRepresentable<>.encode(to:)(a1, a2, a3, v6);
}

uint64_t AWDLActionFrame.Arpa.hostname.getter(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return a2;
}

uint64_t AWDLActionFrame.Arpa.hostname.setter(uint64_t a1, uint64_t a2)
{
  uint64_t result = swift_bridgeObjectRelease(*(void *)(v2 + 16));
  *(void *)(v2 + 8)  = a1;
  *(void *)(v2 + 16)  = a2;
  return result;
}

uint64_t AWDLActionFrame.Arpa.hash(into:)(uint64_t a1, Swift::UInt8 a2, uint64_t a3, uint64_t a4)
{
  return swift_bridgeObjectRelease(a4);
}

uint64_t static AWDLActionFrame.Arpa.__derived_struct_equals(_:_:)( char a1, uint64_t a2, uint64_t a3, char a4, uint64_t a5, uint64_t a6)
{
  if (a1 != a4) {
    return 0LL;
  }
  if (a2 == a5 && a3 == a6) {
    return 1LL;
  }
  return _stringCompareWithSmolCheck(_:_:expecting:)(a2, a3, a5, a6, 0LL);
}

Swift::Int AWDLActionFrame.Arpa.hashValue.getter(Swift::UInt8 a1, uint64_t a2, uint64_t a3)
{
  return Hasher._finalize()();
}

uint64_t sub_1000C7F50@<X0>(void *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t result = AWDLActionFrame.Arpa.init(from:)(a1);
  if (!v2)
  {
    *(_BYTE *)a2  = result;
    *(void *)(a2 + 8)  = v5;
    *(void *)(a2 + 16)  = v6;
  }

  return result;
}

uint64_t AWDLActionFrame.Arpa.init(from:)(void *a1)
{
  return sub_1000DB50C(a1);
}

uint64_t sub_1000C7F9C(void *a1)
{
  return AWDLActionFrame.Arpa.encode(to:)(a1, *(_BYTE *)v1, *(void *)(v1 + 8), *(void *)(v1 + 16));
}

uint64_t AWDLActionFrame.Arpa.encode(to:)(void *a1, char a2, uint64_t a3, unint64_t a4)
{
  uint64_t v8 = a1[3];
  uint64_t v9 = a1[4];
  sub_100021104(a1, v8);
  dispatch thunk of Encoder.unkeyedContainer()(v16, v8, v9);
  LOBYTE(v15)  = a2;
  uint64_t v10 = v17;
  uint64_t v11 = v18;
  sub_1000237C8((uint64_t)v16, v17);
  unint64_t v12 = sub_1000DBA88();
  dispatch thunk of UnkeyedEncodingContainer.encode<A>(_:)( &v15,  &type metadata for AWDLActionFrame.Arpa.Flags,  v12,  v10,  v11);
  if (!v4)
  {
    swift_bridgeObjectRetain(a4);
    sub_1000EF90C(a3, a4);
    __asm { BR              X10 }
  }

  return sub_100002AC4(v16);
}

Swift::Int sub_1000C8268()
{
  uint64_t v1 = *(void *)(v0 + 8);
  uint64_t v2 = *(void *)(v0 + 16);
  Swift::UInt8 v3 = *(_BYTE *)v0;
  Hasher.init(_seed:)(v5, 0LL);
  Hasher._combine(_:)(v3);
  swift_bridgeObjectRetain(v2);
  String.hash(into:)(v5, v1, v2);
  swift_bridgeObjectRelease(v2);
  return Hasher._finalize()();
}

uint64_t sub_1000C82D8(uint64_t a1)
{
  uint64_t v3 = *(void *)(v1 + 8);
  uint64_t v4 = *(void *)(v1 + 16);
  Hasher._combine(_:)(*(_BYTE *)v1);
  swift_bridgeObjectRetain(v4);
  String.hash(into:)(a1, v3, v4);
  return swift_bridgeObjectRelease(v4);
}

Swift::Int sub_1000C8328(uint64_t a1)
{
  uint64_t v2 = *(void *)(v1 + 8);
  uint64_t v3 = *(void *)(v1 + 16);
  Swift::UInt8 v4 = *(_BYTE *)v1;
  Hasher.init(_seed:)(v6, a1);
  Hasher._combine(_:)(v4);
  swift_bridgeObjectRetain(v3);
  String.hash(into:)(v6, v2, v3);
  swift_bridgeObjectRelease(v3);
  return Hasher._finalize()();
}

uint64_t sub_1000C8394(unsigned __int8 *a1, unsigned __int8 *a2)
{
  if (*a1 != *a2) {
    return 0LL;
  }
  uint64_t v4 = *((void *)a1 + 1);
  uint64_t v5 = *((void *)a1 + 2);
  uint64_t v6 = *((void *)a2 + 1);
  uint64_t v7 = *((void *)a2 + 2);
  if (v4 == v6 && v5 == v7) {
    return 1LL;
  }
  else {
    return _stringCompareWithSmolCheck(_:_:expecting:)(v4, v5, v6, v7, 0LL);
  }
}

void AWDLActionFrame.SyncTreePath.hash(into:)(uint64_t a1, uint64_t a2)
{
  Swift::UInt v3 = *(void *)(a2 + 16);
  Hasher._combine(_:)(v3);
  if (v3)
  {
    uint64_t v4 = (Swift::UInt8 *)(a2 + 37);
    do
    {
      Swift::UInt8 v5 = *(v4 - 5);
      Swift::UInt8 v6 = *(v4 - 4);
      Swift::UInt8 v7 = *(v4 - 3);
      Swift::UInt8 v8 = *(v4 - 2);
      Swift::UInt8 v9 = *(v4 - 1);
      Swift::UInt8 v10 = *v4;
      v4 += 6;
      Hasher._combine(_:)(v5);
      Hasher._combine(_:)(v6);
      Hasher._combine(_:)(v7);
      Hasher._combine(_:)(v8);
      Hasher._combine(_:)(v9);
      Hasher._combine(_:)(v10);
      --v3;
    }

    while (v3);
  }

uint64_t sub_1000C8478()
{
  return 1752457584LL;
}

uint64_t sub_1000C8488@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, _BYTE *a3@<X8>)
{
  if (a1 == 1752457584 && a2 == 0xE400000000000000LL)
  {
    uint64_t result = swift_bridgeObjectRelease(0xE400000000000000LL);
    char v8 = 0;
  }

  else
  {
    char v6 = _stringCompareWithSmolCheck(_:_:expecting:)(1752457584LL, 0xE400000000000000LL, a1, a2, 0LL);
    uint64_t result = swift_bridgeObjectRelease(a2);
    char v8 = v6 ^ 1;
  }

  *a3  = v8 & 1;
  return result;
}

uint64_t sub_1000C850C(uint64_t a1)
{
  unint64_t v2 = sub_1000DBACC();
  return CodingKey.description.getter(a1, v2);
}

uint64_t sub_1000C8534(uint64_t a1)
{
  unint64_t v2 = sub_1000DBACC();
  return CodingKey.debugDescription.getter(a1, v2);
}

uint64_t AWDLActionFrame.SyncTreePath.encode(to:)(void *a1, uint64_t a2)
{
  uint64_t v4 = sub_100002274(&qword_100407480);
  uint64_t v5 = *(void *)(v4 - 8);
  __chkstk_darwin(v4);
  Swift::UInt8 v7 = (char *)&v15 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v8 = a1[3];
  uint64_t v9 = a1[4];
  sub_100021104(a1, v8);
  unint64_t v10 = sub_1000DBACC();
  dispatch thunk of Encoder.container<A>(keyedBy:)( &type metadata for AWDLActionFrame.SyncTreePath.CodingKeys,  &type metadata for AWDLActionFrame.SyncTreePath.CodingKeys,  v10,  v8,  v9);
  uint64_t v16 = a2;
  uint64_t v11 = sub_100002274(&qword_100407490);
  uint64_t v12 = sub_1000E51D0( &qword_100407498,  (void (*)(void))sub_1000286C4,  (uint64_t)&protocol conformance descriptor for <A> [A]);
  KeyedEncodingContainer.encode<A>(_:forKey:)(&v16, v13, v4, v11, v12);
  return (*(uint64_t (**)(char *, uint64_t))(v5 + 8))(v7, v4);
}

Swift::Int AWDLActionFrame.SyncTreePath.hashValue.getter(uint64_t a1)
{
  return Hasher._finalize()();
}

void *AWDLActionFrame.SyncTreePath.init(from:)(void *a1)
{
  return sub_1000D8BE8(a1);
}

void *sub_1000C86D0@<X0>(void *a1@<X0>, void *a2@<X8>)
{
  uint64_t result = sub_1000D8BE8(a1);
  if (!v2) {
    *a2  = result;
  }
  return result;
}

uint64_t sub_1000C86F8(void *a1)
{
  return AWDLActionFrame.SyncTreePath.encode(to:)(a1, *v1);
}

Swift::Int sub_1000C8710()
{
  uint64_t v1 = *v0;
  Hasher.init(_seed:)(v3, 0LL);
  AWDLActionFrame.SyncTreePath.hash(into:)((uint64_t)v3, v1);
  return Hasher._finalize()();
}

void sub_1000C8754(uint64_t a1)
{
}

Swift::Int sub_1000C875C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_1000C8768(a1, a2, a3, (void (*)(void *, uint64_t))AWDLActionFrame.SyncTreePath.hash(into:));
}

Swift::Int sub_1000C8768(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(void *, uint64_t))
{
  uint64_t v6 = *v4;
  Hasher.init(_seed:)(v8, a1);
  a4(v8, v6);
  return Hasher._finalize()();
}

BOOL sub_1000C87AC(uint64_t *a1, uint64_t *a2)
{
  return _s7CoreP2P15AWDLActionFrameV12SyncTreePathV23__derived_struct_equalsySbAE_AEtFZ_0(*a1, *a2);
}

CoreP2P::AWDLActionFrame::AWDLVersion __swiftcall AWDLActionFrame.AWDLVersion.init(majorVersion:minorVersion:)( Swift::UInt8 majorVersion, Swift::UInt8 minorVersion)
{
  return (CoreP2P::AWDLActionFrame::AWDLVersion)(minorVersion & 0xF | (16 * majorVersion));
}

void *AWDLActionFrame.AWDLVersion.latest.unsafeMutableAddressor()
{
  return &static AWDLActionFrame.AWDLVersion.latest;
}

uint64_t static AWDLActionFrame.AWDLVersion.latest.getter()
{
  return 146LL;
}

uint64_t static AWDLActionFrame.AWDLVersion.< infix(_:_:)(unsigned __int8 a1, unsigned __int8 a2)
{
  unsigned int v2 = a1 >> 4;
  unsigned int v3 = a2 >> 4;
  BOOL v4 = (a1 & 0xFu) < (a2 & 0xFu);
  if (v2 != v3) {
    BOOL v4 = 0;
  }
  return v2 < v3 || v4;
}

BOOL AWDLActionFrame.AWDLVersion.supportsLoopFreeAlgorithm.getter(unsigned __int8 a1)
{
  BOOL v1 = (a1 & 0xF0) != 0x30 || (a1 & 0xFu) > 2;
  return a1 >= 0x30u && v1;
}

BOOL AWDLActionFrame.AWDLVersion.supportsDynamicSDB.getter(unsigned __int8 a1)
{
  BOOL v1 = (a1 & 0xF0) != 0x30 || (a1 & 0xC) != 0;
  return a1 >= 0x30u && v1;
}

BOOL AWDLActionFrame.AWDLVersion.supportsServiceDiscoverySize.getter(unsigned __int8 a1)
{
  return a1 > 0x3Fu;
}

BOOL AWDLActionFrame.AWDLVersion.isSDBAware.getter(unsigned __int8 a1)
{
  return a1 > 0x2Fu;
}

uint64_t sub_1000C8880()
{
  return 0x65756C6156776172LL;
}

uint64_t sub_1000C8898@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, _BYTE *a3@<X8>)
{
  if (a1 == 0x65756C6156776172LL && a2 == 0xE800000000000000LL)
  {
    uint64_t result = swift_bridgeObjectRelease(0xE800000000000000LL);
    char v8 = 0;
  }

  else
  {
    char v6 = _stringCompareWithSmolCheck(_:_:expecting:)(0x65756C6156776172LL, 0xE800000000000000LL, a1, a2, 0LL);
    uint64_t result = swift_bridgeObjectRelease(a2);
    char v8 = v6 ^ 1;
  }

  *a3  = v8 & 1;
  return result;
}

uint64_t sub_1000C892C(uint64_t a1)
{
  unint64_t v2 = sub_1000DBB10();
  return CodingKey.description.getter(a1, v2);
}

uint64_t sub_1000C8954(uint64_t a1)
{
  unint64_t v2 = sub_1000DBB10();
  return CodingKey.debugDescription.getter(a1, v2);
}

uint64_t AWDLActionFrame.AWDLVersion.encode(to:)(void *a1, uint64_t a2)
{
  uint64_t v4 = sub_100002274(&qword_1004074A0);
  uint64_t v5 = *(void *)(v4 - 8);
  __chkstk_darwin(v4);
  Swift::UInt8 v7 = (char *)&v13 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v8 = a1[3];
  uint64_t v9 = a1[4];
  sub_100021104(a1, v8);
  unint64_t v10 = sub_1000DBB10();
  dispatch thunk of Encoder.container<A>(keyedBy:)( &type metadata for AWDLActionFrame.AWDLVersion.CodingKeys,  &type metadata for AWDLActionFrame.AWDLVersion.CodingKeys,  v10,  v8,  v9);
  KeyedEncodingContainer.encode(_:forKey:)(a2, v11, v4);
  return (*(uint64_t (**)(char *, uint64_t))(v5 + 8))(v7, v4);
}

void *AWDLActionFrame.AWDLVersion.init(from:)(void *a1)
{
  uint64_t v3 = sub_100002274(&qword_1004074B0);
  uint64_t v4 = *(void *)(v3 - 8);
  __chkstk_darwin(v3);
  uint64_t v6 = (char *)&v13 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v7 = a1[3];
  uint64_t v8 = a1[4];
  uint64_t v9 = sub_100021104(a1, v7);
  unint64_t v10 = sub_1000DBB10();
  uint64_t v11 = dispatch thunk of Decoder.container<A>(keyedBy:)( &type metadata for AWDLActionFrame.AWDLVersion.CodingKeys,  &type metadata for AWDLActionFrame.AWDLVersion.CodingKeys,  v10,  v7,  v8);
  if (!v1)
  {
    uint64_t v9 = (void *)KeyedDecodingContainer.decode(_:forKey:)(v11, v3);
    (*(void (**)(char *, uint64_t))(v4 + 8))(v6, v3);
  }

  sub_100002AC4(a1);
  return v9;
}

uint64_t sub_1000C8B64(unsigned __int8 *a1, unsigned __int8 *a2)
{
  unsigned int v2 = *a1;
  unsigned int v3 = *a2;
  unsigned int v4 = v2 >> 4;
  BOOL v5 = (v2 & 0xF) < (v3 & 0xF);
  if (v4 != v3 >> 4) {
    BOOL v5 = 0;
  }
  return v4 < v3 >> 4 || v5;
}

uint64_t sub_1000C8B98(unsigned __int8 *a1, unsigned __int8 *a2)
{
  unsigned int v2 = *a1;
  unsigned int v3 = *a2;
  unsigned int v4 = v2 >> 4;
  if (v3 >> 4 < v2 >> 4) {
    return 0LL;
  }
  BOOL v6 = (v3 & 0xF) >= (v2 & 0xF);
  return v3 >> 4 != v4 || v6;
}

uint64_t sub_1000C8BD8(unsigned __int8 *a1, unsigned __int8 *a2)
{
  unsigned int v2 = *a1;
  unsigned int v3 = *a2;
  unsigned int v4 = v2 >> 4;
  if (v2 >> 4 < v3 >> 4) {
    return 0LL;
  }
  BOOL v6 = (v2 & 0xF) >= (v3 & 0xF);
  return v4 != v3 >> 4 || v6;
}

uint64_t sub_1000C8C18(unsigned __int8 *a1, unsigned __int8 *a2)
{
  unsigned int v2 = *a1;
  unsigned int v3 = *a2;
  unsigned int v4 = v2 >> 4;
  BOOL v5 = (v3 & 0xF) < (v2 & 0xF);
  if (v3 >> 4 != v4) {
    BOOL v5 = 0;
  }
  return v3 >> 4 < v4 || v5;
}

uint64_t sub_1000C8C4C@<X0>(void *a1@<X0>, _BYTE *a2@<X8>)
{
  uint64_t v5 = sub_100002274(&qword_1004074B0);
  uint64_t v6 = *(void *)(v5 - 8);
  __chkstk_darwin(v5);
  uint64_t v8 = (char *)&v15 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v9 = a1[3];
  uint64_t v10 = a1[4];
  sub_100021104(a1, v9);
  unint64_t v11 = sub_1000DBB10();
  uint64_t v12 = dispatch thunk of Decoder.container<A>(keyedBy:)( &type metadata for AWDLActionFrame.AWDLVersion.CodingKeys,  &type metadata for AWDLActionFrame.AWDLVersion.CodingKeys,  v11,  v9,  v10);
  if (v2) {
    return sub_100002AC4(a1);
  }
  char v13 = KeyedDecodingContainer.decode(_:forKey:)(v12, v5);
  (*(void (**)(char *, uint64_t))(v6 + 8))(v8, v5);
  uint64_t result = sub_100002AC4(a1);
  *a2  = v13;
  return result;
}

uint64_t sub_1000C8D5C(void *a1)
{
  uint64_t v3 = sub_100002274(&qword_1004074A0);
  uint64_t v4 = *(void *)(v3 - 8);
  __chkstk_darwin(v3);
  uint64_t v6 = (char *)&v13 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v7 = a1[3];
  uint64_t v8 = a1[4];
  uint64_t v9 = *v1;
  sub_100021104(a1, v7);
  unint64_t v10 = sub_1000DBB10();
  dispatch thunk of Encoder.container<A>(keyedBy:)( &type metadata for AWDLActionFrame.AWDLVersion.CodingKeys,  &type metadata for AWDLActionFrame.AWDLVersion.CodingKeys,  v10,  v7,  v8);
  KeyedEncodingContainer.encode(_:forKey:)(v9, v11, v3);
  return (*(uint64_t (**)(char *, uint64_t))(v4 + 8))(v6, v3);
}

unint64_t AWDLActionFrame.Version.PlatformType.rawValue.getter(char a1)
{
  return 0x1008040201uLL >> (8 * a1);
}

BOOL sub_1000C8E64(_BYTE *a1, _BYTE *a2)
{
  return ((0x1008040201uLL >> (8 * *a1)) & 0x1F) == ((0x1008040201uLL >> (8 * *a2)) & 0x1F);
}

uint64_t sub_1000C8E9C@<X0>(unsigned __int8 *a1@<X0>, _BYTE *a2@<X8>)
{
  uint64_t result = _s7CoreP2P15AWDLActionFrameV7VersionV12PlatformTypeO8rawValueAGSgs5UInt8V_tcfC_0(*a1);
  *a2  = result;
  return result;
}

void sub_1000C8EC4(_BYTE *a1@<X8>)
{
  *a1  = 0x1008040201uLL >> (8 * *v1);
}

Swift::Int sub_1000C8EE4()
{
  char v1 = *v0;
  Hasher.init(_seed:)(v3, 0LL);
  Hasher._combine(_:)(0x1008040201uLL >> (8 * v1));
  return Hasher._finalize()();
}

void sub_1000C8F38()
{
}

Swift::Int sub_1000C8F74(uint64_t a1)
{
  char v2 = *v1;
  Hasher.init(_seed:)(v4, a1);
  Hasher._combine(_:)(0x1008040201uLL >> (8 * v2));
  return Hasher._finalize()();
}

uint64_t sub_1000C8FC4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v6 = sub_1000E4D30();
  return RawRepresentable<>.init(from:)(a1, a2, a3, v6);
}

uint64_t AWDLActionFrame.Version.platformType.getter(__int16 a1)
{
  int v1 = HIBYTE(a1) - 1;
  uint64_t result = 0LL;
  switch(v1)
  {
    case 0:
      return result;
    case 1:
      uint64_t result = 1LL;
      break;
    case 3:
      uint64_t result = 2LL;
      break;
    case 7:
      uint64_t result = 3LL;
      break;
    case 15:
      uint64_t result = 4LL;
      break;
    default:
      uint64_t result = 5LL;
      break;
  }

  return result;
}

CoreP2P::AWDLActionFrame::Version __swiftcall AWDLActionFrame.Version.init(version:platformType:)( CoreP2P::AWDLActionFrame::AWDLVersion version, CoreP2P::AWDLActionFrame::Version::PlatformType platformType)
{
  return (CoreP2P::AWDLActionFrame::Version)(version.rawValue | ((0x1008040201uLL >> (8 * platformType)) << 8));
}

void AWDLThreadCoexistenceEvent.hash(into:)(int a1, __int16 a2)
{
  Swift::UInt8 v2 = HIBYTE(a2);
  Hasher._combine(_:)(a2);
  Hasher._combine(_:)(v2);
}

BOOL static AWDLThreadCoexistenceEvent.__derived_struct_equals(_:_:)(__int16 a1, __int16 a2)
{
  return a1 == a2;
}

uint64_t sub_1000C90D8()
{
  if (*v0) {
    return 0x726F6674616C705FLL;
  }
  else {
    return 0x6E6F6973726576LL;
  }
}

uint64_t sub_1000C9120@<X0>(uint64_t a1@<X0>, unint64_t a2@<X1>, _BYTE *a3@<X8>)
{
  uint64_t result = sub_1000E3EA8(a1, a2);
  *a3  = result;
  return result;
}

uint64_t sub_1000C9144(uint64_t a1)
{
  unint64_t v2 = sub_1000DBB54();
  return CodingKey.description.getter(a1, v2);
}

uint64_t sub_1000C916C(uint64_t a1)
{
  unint64_t v2 = sub_1000DBB54();
  return CodingKey.debugDescription.getter(a1, v2);
}

uint64_t AWDLActionFrame.Version.encode(to:)(void *a1, __int16 a2)
{
  uint64_t v5 = sub_100002274(&qword_1004074B8);
  uint64_t v6 = *(void *)(v5 - 8);
  __chkstk_darwin(v5);
  uint64_t v8 = (char *)&v14 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v9 = a1[3];
  uint64_t v10 = a1[4];
  sub_100021104(a1, v9);
  unint64_t v11 = sub_1000DBB54();
  dispatch thunk of Encoder.container<A>(keyedBy:)( &type metadata for AWDLActionFrame.Version.CodingKeys,  &type metadata for AWDLActionFrame.Version.CodingKeys,  v11,  v9,  v10);
  char v17 = a2;
  char v16 = 0;
  unint64_t v12 = sub_1000DBB98();
  KeyedEncodingContainer.encode<A>(_:forKey:)(&v17, &v16, v5, &type metadata for AWDLActionFrame.AWDLVersion, v12);
  if (!v2)
  {
    char v15 = 1;
    KeyedEncodingContainer.encode(_:forKey:)(HIBYTE(a2), &v15, v5);
  }

  return (*(uint64_t (**)(char *, uint64_t))(v6 + 8))(v8, v5);
}

Swift::Int AWDLThreadCoexistenceEvent.hashValue.getter(__int16 a1)
{
  Swift::UInt8 v1 = a1;
  Swift::UInt8 v2 = HIBYTE(a1);
  Hasher.init(_seed:)(v4, 0LL);
  Hasher._combine(_:)(v1);
  Hasher._combine(_:)(v2);
  return Hasher._finalize()();
}

uint64_t AWDLActionFrame.Version.init(from:)(void *a1)
{
  return sub_1000D96D4(a1);
}

uint64_t sub_1000C932C@<X0>(void *a1@<X0>, _WORD *a2@<X8>)
{
  uint64_t result = sub_1000D96D4(a1);
  if (!v2) {
    *a2  = result;
  }
  return result;
}

uint64_t sub_1000C9354(void *a1)
{
  return AWDLActionFrame.Version.encode(to:)(a1, *v1);
}

Swift::Int sub_1000C936C()
{
  Swift::UInt8 v1 = *v0;
  Swift::UInt8 v2 = v0[1];
  Hasher.init(_seed:)(v4, 0LL);
  Hasher._combine(_:)(v1);
  Hasher._combine(_:)(v2);
  return Hasher._finalize()();
}

void sub_1000C93C8()
{
  Swift::UInt8 v1 = v0[1];
  Hasher._combine(_:)(*v0);
  Hasher._combine(_:)(v1);
}

Swift::Int sub_1000C9404(uint64_t a1)
{
  Swift::UInt8 v2 = *v1;
  Swift::UInt8 v3 = v1[1];
  Hasher.init(_seed:)(v5, a1);
  Hasher._combine(_:)(v2);
  Hasher._combine(_:)(v3);
  return Hasher._finalize()();
}

BOOL sub_1000C945C(unsigned __int8 *a1, unsigned __int8 *a2)
{
  return *a1 == *a2 && a1[1] == a2[1];
}

void AWDLActionFrame.PeerMACAddressListBloomFilter.hash(into:)(int a1, __int16 a2, uint64_t a3)
{
  Swift::UInt8 v4 = HIBYTE(a2);
  Hasher._combine(_:)(a2);
  Hasher._combine(_:)(v4);
  Swift::UInt v5 = *(void *)(a3 + 16);
  Hasher._combine(_:)(v5);
  if (v5)
  {
    uint64_t v6 = (Swift::UInt8 *)(a3 + 32);
    do
    {
      Swift::UInt8 v7 = *v6++;
      Hasher._combine(_:)(v7);
      --v5;
    }

    while (v5);
  }

uint64_t static AWDLActionFrame.PeerMACAddressListBloomFilter.__derived_struct_equals(_:_:)( __int16 a1, uint64_t a2, __int16 a3, uint64_t a4)
{
  if (a1 == a3) {
    return sub_10007990C(a2, a4);
  }
  else {
    return 0LL;
  }
}

unint64_t sub_1000C94FC()
{
  uint64_t v1 = 0x746E756F63LL;
  if (*v0 != 1) {
    uint64_t v1 = 0x6D6F6F6C62LL;
  }
  if (*v0) {
    return v1;
  }
  else {
    return 0xD000000000000014LL;
  }
}

uint64_t sub_1000C9554@<X0>(uint64_t a1@<X0>, unint64_t a2@<X1>, _BYTE *a3@<X8>)
{
  uint64_t result = sub_1000E3FBC(a1, a2);
  *a3  = result;
  return result;
}

uint64_t sub_1000C9578(uint64_t a1)
{
  unint64_t v2 = sub_1000DBBDC();
  return CodingKey.description.getter(a1, v2);
}

uint64_t sub_1000C95A0(uint64_t a1)
{
  unint64_t v2 = sub_1000DBBDC();
  return CodingKey.debugDescription.getter(a1, v2);
}

uint64_t AWDLActionFrame.PeerMACAddressListBloomFilter.encode(to:)(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v7 = sub_100002274(&qword_1004074D0);
  uint64_t v8 = *(void *)(v7 - 8);
  __chkstk_darwin(v7);
  uint64_t v10 = (char *)&v17 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v11 = a1[3];
  uint64_t v12 = a1[4];
  sub_100021104(a1, v11);
  unint64_t v13 = sub_1000DBBDC();
  dispatch thunk of Encoder.container<A>(keyedBy:)( &type metadata for AWDLActionFrame.PeerMACAddressListBloomFilter.CodingKeys,  &type metadata for AWDLActionFrame.PeerMACAddressListBloomFilter.CodingKeys,  v13,  v11,  v12);
  char v21 = 0;
  KeyedEncodingContainer.encode(_:forKey:)(a2, &v21, v7);
  if (!v3)
  {
    char v20 = 1;
    KeyedEncodingContainer.encode(_:forKey:)(BYTE1(a2), &v20, v7);
    uint64_t v18 = a3;
    char v19 = 2;
    uint64_t v14 = sub_100002274(&qword_100406978);
    uint64_t v15 = sub_1000E5170( (unint64_t *)&qword_100407410,  (uint64_t)&protocol witness table for UInt8,  (uint64_t)&protocol conformance descriptor for <A> [A]);
    KeyedEncodingContainer.encode<A>(_:forKey:)(&v18, &v19, v7, v14, v15);
  }

  return (*(uint64_t (**)(char *, uint64_t))(v8 + 8))(v10, v7);
}

Swift::Int AWDLActionFrame.PeerMACAddressListBloomFilter.hashValue.getter(__int16 a1, uint64_t a2)
{
  Swift::UInt8 v3 = a1;
  Swift::UInt8 v4 = HIBYTE(a1);
  Hasher.init(_seed:)(v9, 0LL);
  Hasher._combine(_:)(v3);
  Hasher._combine(_:)(v4);
  Swift::UInt v5 = *(void *)(a2 + 16);
  Hasher._combine(_:)(v5);
  if (v5)
  {
    uint64_t v6 = (Swift::UInt8 *)(a2 + 32);
    do
    {
      Swift::UInt8 v7 = *v6++;
      Hasher._combine(_:)(v7);
      --v5;
    }

    while (v5);
  }

  return Hasher._finalize()();
}

uint64_t AWDLActionFrame.PeerMACAddressListBloomFilter.init(from:)(void *a1)
{
  return sub_1000D9838(a1);
}

uint64_t sub_1000C97E8@<X0>(void *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t result = sub_1000D9838(a1);
  if (!v2)
  {
    *(_WORD *)a2  = result;
    *(void *)(a2 + 8)  = v5;
  }

  return result;
}

uint64_t sub_1000C981C(void *a1)
{
  return AWDLActionFrame.PeerMACAddressListBloomFilter.encode(to:)(a1, *v1, *((void *)v1 + 1));
}

Swift::Int sub_1000C9838()
{
  return AWDLActionFrame.PeerMACAddressListBloomFilter.hashValue.getter(*(_WORD *)v0, *(void *)(v0 + 8));
}

void sub_1000C9844(int a1)
{
}

Swift::Int sub_1000C9850(uint64_t a1)
{
  uint64_t v2 = *(void *)(v1 + 8);
  Swift::UInt8 v3 = *(_BYTE *)v1;
  Swift::UInt8 v4 = *(_BYTE *)(v1 + 1);
  Hasher.init(_seed:)(v9, a1);
  Hasher._combine(_:)(v3);
  Hasher._combine(_:)(v4);
  Swift::UInt v5 = *(void *)(v2 + 16);
  Hasher._combine(_:)(v5);
  if (v5)
  {
    uint64_t v6 = (Swift::UInt8 *)(v2 + 32);
    do
    {
      Swift::UInt8 v7 = *v6++;
      Hasher._combine(_:)(v7);
      --v5;
    }

    while (v5);
  }

  return Hasher._finalize()();
}

uint64_t sub_1000C98D8(unsigned __int8 *a1, unsigned __int8 *a2)
{
  if (*a1 == *a2 && a1[1] == a2[1]) {
    return sub_10007990C(*((void *)a1 + 1), *((void *)a2 + 1));
  }
  else {
    return 0LL;
  }
}

unint64_t NANElectionParameters.clusterID.getter()
{
  return *(unsigned __int16 *)(v0 + 2) | ((unint64_t)*(unsigned int *)(v0 + 4) << 16);
}

uint64_t NANElectionParameters.clusterID.setter(uint64_t result)
{
  *(_WORD *)(v1 + 2)  = result;
  *(_BYTE *)(v1 + 4)  = BYTE2(result);
  *(_BYTE *)(v1 + 5)  = BYTE3(result);
  *(_BYTE *)(v1 + 6)  = BYTE4(result);
  *(_BYTE *)(v1 + 7)  = BYTE5(result);
  return result;
}

unint64_t AWDLActionFrame.NANSynchronization.clusterID.getter()
{
  return *(unsigned __int16 *)(v0 + 8) | ((unint64_t)*(unsigned int *)(v0 + 10) << 16);
}

uint64_t AWDLActionFrame.NANSynchronization.clusterID.setter(uint64_t result)
{
  *(_WORD *)(v1 + 8)  = result;
  *(_BYTE *)(v1 + 10)  = BYTE2(result);
  *(_BYTE *)(v1 + 11)  = BYTE3(result);
  *(_BYTE *)(v1 + 12)  = BYTE4(result);
  *(_BYTE *)(v1 + 13)  = BYTE5(result);
  return result;
}

uint64_t IEEE80211InformationElement.RSNCapability.capabilities.getter()
{
  return *(unsigned __int16 *)(v0 + 24);
}

uint64_t IEEE80211InformationElement.RSNCapability.capabilities.setter(uint64_t result)
{
  *(_WORD *)(v1 + 24)  = result;
  return result;
}

unint64_t AWDLActionFrame.NANSynchronization.anchorMasterRank.getter()
{
  return __rev16(*(unsigned __int16 *)(v0 + 32)) | ((unint64_t)*(unsigned __int8 *)(v0 + 26) << 16) | ((unint64_t)*(unsigned __int8 *)(v0 + 27) << 24) | ((unint64_t)*(unsigned int *)(v0 + 28) << 32);
}

unint64_t AWDLActionFrame.NANSynchronization.anchorMasterCluster.getter()
{
  return __rev16(*(unsigned __int16 *)(v0 + 32)) | ((unint64_t)*(unsigned __int8 *)(v0 + 26) << 16) | ((unint64_t)*(unsigned __int8 *)(v0 + 27) << 24) | ((unint64_t)*(unsigned __int8 *)(v0 + 28) << 32) | ((unint64_t)*(unsigned __int8 *)(v0 + 29) << 40) | ((unint64_t)*(unsigned __int8 *)(v0 + 30) << 48) | ((unint64_t)*(unsigned __int8 *)(v0 + 31) << 56);
}

void AWDLActionFrame.NANSynchronization.hash(into:)()
{
  Swift::UInt8 v1 = *(_BYTE *)(v0 + 3);
  Swift::UInt8 v2 = *(_BYTE *)(v0 + 4);
  Swift::UInt8 v3 = *(_BYTE *)(v0 + 5);
  Swift::UInt8 v4 = *(_BYTE *)(v0 + 6);
  Swift::UInt8 v5 = *(_BYTE *)(v0 + 7);
  Hasher._combine(_:)(*(_BYTE *)(v0 + 2));
  Hasher._combine(_:)(v1);
  Hasher._combine(_:)(v2);
  Hasher._combine(_:)(v3);
  Hasher._combine(_:)(v4);
  Hasher._combine(_:)(v5);
  Swift::UInt8 v6 = *(_BYTE *)(v0 + 9);
  Swift::UInt8 v7 = *(_BYTE *)(v0 + 10);
  Swift::UInt8 v8 = *(_BYTE *)(v0 + 11);
  Swift::UInt8 v9 = *(_BYTE *)(v0 + 12);
  Swift::UInt8 v10 = *(_BYTE *)(v0 + 13);
  Hasher._combine(_:)(*(_BYTE *)(v0 + 8));
  Hasher._combine(_:)(v6);
  Hasher._combine(_:)(v7);
  Hasher._combine(_:)(v8);
  Hasher._combine(_:)(v9);
  Hasher._combine(_:)(v10);
  Hasher._combine(_:)(*(void *)(v0 + 16));
  Swift::UInt8 v11 = *(_BYTE *)(v0 + 25);
  Hasher._combine(_:)(*(_BYTE *)(v0 + 24));
  Hasher._combine(_:)(v11);
  Swift::UInt8 v12 = *(_BYTE *)(v0 + 27);
  Swift::UInt8 v13 = *(_BYTE *)(v0 + 28);
  Swift::UInt8 v14 = *(_BYTE *)(v0 + 29);
  Swift::UInt8 v15 = *(_BYTE *)(v0 + 30);
  Swift::UInt8 v16 = *(_BYTE *)(v0 + 31);
  Hasher._combine(_:)(*(_BYTE *)(v0 + 26));
  Hasher._combine(_:)(v12);
  Hasher._combine(_:)(v13);
  Hasher._combine(_:)(v14);
  Hasher._combine(_:)(v15);
  Hasher._combine(_:)(v16);
  Hasher._combine(_:)(*(_BYTE *)(v0 + 32));
  Hasher._combine(_:)(*(_BYTE *)(v0 + 33));
  Hasher._combine(_:)(*(_WORD *)(v0 + 34));
  Hasher._combine(_:)(*(_DWORD *)(v0 + 36));
}

uint64_t sub_1000C9B50(unsigned __int8 a1)
{
  return ((uint64_t (*)(uint64_t, unint64_t))((char *)sub_1000C9B84 + 4 * byte_100340ABE[a1]))( 0x746E756F43706F68LL,  0xE800000000000000LL);
}

uint64_t sub_1000C9B84()
{
  return 0x6F4E656372756F73LL;
}

uint64_t sub_1000C9BA0()
{
  return 0x4972657473756C63LL;
}

unint64_t sub_1000C9BBC()
{
  return 0xD00000000000001BLL;
}

uint64_t sub_1000C9C74()
{
  return sub_1000C9B50(*v0);
}

uint64_t sub_1000C9C7C@<X0>(uint64_t a1@<X0>, unint64_t a2@<X1>, _BYTE *a3@<X8>)
{
  uint64_t result = sub_1000E40FC(a1, a2);
  *a3  = result;
  return result;
}

void sub_1000C9CA0(_BYTE *a1@<X8>)
{
  *a1  = 10;
}

uint64_t sub_1000C9CAC(uint64_t a1)
{
  unint64_t v2 = sub_1000DBC20();
  return CodingKey.description.getter(a1, v2);
}

uint64_t sub_1000C9CD4(uint64_t a1)
{
  unint64_t v2 = sub_1000DBC20();
  return CodingKey.debugDescription.getter(a1, v2);
}

uint64_t AWDLActionFrame.NANSynchronization.encode(to:)(void *a1)
{
  Swift::UInt8 v3 = v1;
  uint64_t v5 = sub_100002274(&qword_1004074E0);
  uint64_t v6 = *(void *)(v5 - 8);
  __chkstk_darwin(v5);
  Swift::UInt8 v8 = (char *)&v21 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v9 = a1[3];
  uint64_t v10 = a1[4];
  sub_100021104(a1, v9);
  unint64_t v11 = sub_1000DBC20();
  dispatch thunk of Encoder.container<A>(keyedBy:)( &type metadata for AWDLActionFrame.NANSynchronization.CodingKeys,  &type metadata for AWDLActionFrame.NANSynchronization.CodingKeys,  v11,  v9,  v10);
  uint64_t v12 = *v3;
  LOBYTE(v21)  = 0;
  KeyedEncodingContainer.encode(_:forKey:)(v12, &v21, v5);
  if (!v2)
  {
    LODWORD(v21)  = *(_DWORD *)(v3 + 1);
    WORD2(v21)  = v3[3];
    char v22 = 1;
    unint64_t v13 = sub_1000286C4();
    KeyedEncodingContainer.encode<A>(_:forKey:)(&v21, &v22, v5, &type metadata for WiFiAddress, v13);
    LODWORD(v21)  = *((_DWORD *)v3 + 2);
    WORD2(v21)  = v3[6];
    char v22 = 2;
    KeyedEncodingContainer.encode<A>(_:forKey:)(&v21, &v22, v5, &type metadata for WiFiAddress, v13);
    uint64_t v21 = *((void *)v3 + 2);
    char v22 = 3;
    unint64_t v14 = sub_1000DBC64();
    KeyedEncodingContainer.encode<A>(_:forKey:)(&v21, &v22, v5, &type metadata for NANTimeSynchronizationFunction, v14);
    LOWORD(v21)  = v3[12];
    char v22 = 4;
    unint64_t v15 = sub_1000DBCA8();
    KeyedEncodingContainer.encode<A>(_:forKey:)(&v21, &v22, v5, &type metadata for NANAttribute.MasterIndication, v15);
    LODWORD(v21)  = *(_DWORD *)(v3 + 13);
    WORD2(v21)  = v3[15];
    char v22 = 5;
    KeyedEncodingContainer.encode<A>(_:forKey:)(&v21, &v22, v5, &type metadata for WiFiAddress, v13);
    uint64_t v16 = *((unsigned __int8 *)v3 + 32);
    LOBYTE(v21)  = 6;
    KeyedEncodingContainer.encode(_:forKey:)(v16, &v21, v5);
    uint64_t v17 = *((unsigned __int8 *)v3 + 33);
    LOBYTE(v21)  = 7;
    KeyedEncodingContainer.encode(_:forKey:)(v17, &v21, v5);
    uint64_t v18 = v3[17];
    LOBYTE(v21)  = 8;
    KeyedEncodingContainer.encode(_:forKey:)(v18, &v21, v5);
    uint64_t v19 = *((unsigned int *)v3 + 9);
    LOBYTE(v21)  = 9;
    KeyedEncodingContainer.encode(_:forKey:)(v19, &v21, v5);
  }

  return (*(uint64_t (**)(char *, uint64_t))(v6 + 8))(v8, v5);
}

Swift::Int AWDLActionFrame.NANSynchronization.hashValue.getter()
{
  Swift::UInt8 v1 = *(_BYTE *)(v0 + 3);
  Swift::UInt8 v2 = *(_BYTE *)(v0 + 4);
  Swift::UInt8 v3 = *(_BYTE *)(v0 + 5);
  Swift::UInt8 v4 = *(_BYTE *)(v0 + 6);
  Swift::UInt8 v5 = *(_BYTE *)(v0 + 7);
  Hasher._combine(_:)(*(_BYTE *)(v0 + 2));
  Hasher._combine(_:)(v1);
  Hasher._combine(_:)(v2);
  Hasher._combine(_:)(v3);
  Hasher._combine(_:)(v4);
  Hasher._combine(_:)(v5);
  Swift::UInt8 v6 = *(_BYTE *)(v0 + 9);
  Swift::UInt8 v7 = *(_BYTE *)(v0 + 10);
  Swift::UInt8 v8 = *(_BYTE *)(v0 + 11);
  Swift::UInt8 v9 = *(_BYTE *)(v0 + 12);
  Swift::UInt8 v10 = *(_BYTE *)(v0 + 13);
  Hasher._combine(_:)(*(_BYTE *)(v0 + 8));
  Hasher._combine(_:)(v6);
  Hasher._combine(_:)(v7);
  Hasher._combine(_:)(v8);
  Hasher._combine(_:)(v9);
  Hasher._combine(_:)(v10);
  Hasher._combine(_:)(*(void *)(v0 + 16));
  Swift::UInt8 v11 = *(_BYTE *)(v0 + 25);
  Hasher._combine(_:)(*(_BYTE *)(v0 + 24));
  Hasher._combine(_:)(v11);
  Swift::UInt8 v12 = *(_BYTE *)(v0 + 27);
  Swift::UInt8 v13 = *(_BYTE *)(v0 + 28);
  Swift::UInt8 v14 = *(_BYTE *)(v0 + 29);
  Swift::UInt8 v15 = *(_BYTE *)(v0 + 30);
  Swift::UInt8 v16 = *(_BYTE *)(v0 + 31);
  Hasher._combine(_:)(*(_BYTE *)(v0 + 26));
  Hasher._combine(_:)(v12);
  Hasher._combine(_:)(v13);
  Hasher._combine(_:)(v14);
  Hasher._combine(_:)(v15);
  Hasher._combine(_:)(v16);
  Hasher._combine(_:)(*(_BYTE *)(v0 + 32));
  Hasher._combine(_:)(*(_BYTE *)(v0 + 33));
  Hasher._combine(_:)(*(_WORD *)(v0 + 34));
  Hasher._combine(_:)(*(_DWORD *)(v0 + 36));
  return Hasher._finalize()();
}

double AWDLActionFrame.NANSynchronization.init(from:)@<D0>(void *a1@<X0>, uint64_t a2@<X8>)
{
  if (!v2)
  {
    double result = *(double *)v6;
    __int128 v5 = v6[1];
    *(_OWORD *)a2  = v6[0];
    *(_OWORD *)(a2 + 16)  = v5;
    *(void *)(a2 + 32)  = v7;
  }

  return result;
}

uint64_t sub_1000CA1E8(void *a1)
{
  return AWDLActionFrame.NANSynchronization.encode(to:)(a1);
}

Swift::Int sub_1000CA204(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_1000CBB80(a1, a2, a3, (void (*)(void *))AWDLActionFrame.NANSynchronization.hash(into:));
}

BOOL sub_1000CA210(uint64_t a1, uint64_t a2)
{
  __int128 v2 = *(_OWORD *)(a1 + 16);
  v5[0]  = *(_OWORD *)a1;
  v5[1]  = v2;
  uint64_t v6 = *(void *)(a1 + 32);
  __int128 v3 = *(_OWORD *)(a2 + 16);
  v7[0]  = *(_OWORD *)a2;
  v7[1]  = v3;
  uint64_t v8 = *(void *)(a2 + 32);
  return _s7CoreP2P15AWDLActionFrameV18NANSynchronizationV23__derived_struct_equalsySbAE_AEtFZ_0( (unsigned __int16 *)v5,  (unsigned __int16 *)v7);
}

unint64_t NANOOBActionFrameReceivedEvent.peerAddress.getter()
{
  return *v0 | ((unint64_t)*(unsigned int *)(v0 + 1) << 16);
}

unint64_t NANOOBActionFrameReceivedEvent.localAddress.getter()
{
  return *(unsigned __int16 *)(v0 + 6) | ((unint64_t)*(unsigned int *)(v0 + 8) << 16);
}

uint64_t AWDLActionFrame.ElectionParameter.rootLoopFreeCounter.getter()
{
  return *(unsigned int *)(v0 + 12);
}

uint64_t Socket.rawValue.getter()
{
  return *(unsigned int *)(v0 + 16);
}

uint64_t AWDLActionFrame.ElectionParameter.hopCount.setter(uint64_t result)
{
  *(_DWORD *)(v1 + 16)  = result;
  return result;
}

unint64_t AWDLActionFrame.ElectionParameter.rootMetric.getter()
{
  return *(unsigned int *)(v0 + 20) | ((unint64_t)*(unsigned __int8 *)(v0 + 24) << 32);
}

unint64_t AWDLActionFrame.ElectionParameter.selfMetric.getter()
{
  return *(unsigned int *)(v0 + 28) | ((unint64_t)*(unsigned __int8 *)(v0 + 32) << 32);
}

uint64_t AWDLActionFrame.ElectionParameter.selfMetric.setter(uint64_t result)
{
  *(_DWORD *)(v1 + 28)  = result;
  *(_BYTE *)(v1 + 32)  = BYTE4(result) & 1;
  return result;
}

uint64_t AWDLActionFrame.ElectionParameter.electionID.getter()
{
  return *(unsigned int *)(v0 + 36);
}

uint64_t AWDLActionFrame.ElectionParameter.electionID.setter(uint64_t result)
{
  *(_DWORD *)(v1 + 36)  = result;
  return result;
}

uint64_t (*AWDLActionFrame.ElectionParameter.electionID.modify())()
{
  return NANBitmap.Channel.operatingClass.getter;
}

uint64_t AWDLActionFrame.ElectionParameter.electionFlags.getter()
{
  return *(unsigned int *)(v0 + 40);
}

uint64_t AWDLActionFrame.ElectionParameter.electionFlags.setter(uint64_t result)
{
  *(_DWORD *)(v1 + 40)  = result;
  return result;
}

uint64_t AWDLActionFrame.ElectionParameter.selfLoopFreeCounter.getter()
{
  return *(unsigned int *)(v0 + 44);
}

uint64_t AWDLActionFrame.ElectionParameter.selfLoopFreeCounter.setter(uint64_t result)
{
  *(_DWORD *)(v1 + 44)  = result;
  return result;
}

uint64_t (*AWDLActionFrame.ElectionParameter.selfLoopFreeCounter.modify())()
{
  return NANBitmap.Channel.operatingClass.getter;
}

uint64_t AWDLActionFrame.ElectionParameter.init(rootNode:parentNode:rootLoopFreeCounter:hopCount:rootMetric:selfMetric:electionID:electionFlags:selfLoopFreeCounter:)@<X0>( uint64_t result@<X0>, uint64_t a2@<X1>, int a3@<W2>, int a4@<W3>, uint64_t a5@<X4>, uint64_t a6@<X5>, int a7@<W6>, int a8@<W7>, uint64_t a9@<X8>, int a10)
{
  *(_WORD *)a9  = result;
  *(_BYTE *)(a9 + 2)  = BYTE2(result);
  *(_BYTE *)(a9 + 3)  = BYTE3(result);
  *(_BYTE *)(a9 + 4)  = BYTE4(result);
  *(_BYTE *)(a9 + 5)  = BYTE5(result);
  *(_WORD *)(a9 + 6)  = a2;
  *(_BYTE *)(a9 + 8)  = BYTE2(a2);
  *(_BYTE *)(a9 + 9)  = BYTE3(a2);
  *(_BYTE *)(a9 + 10)  = BYTE4(a2);
  *(_BYTE *)(a9 + 11)  = BYTE5(a2);
  *(_DWORD *)(a9 + 12)  = a3;
  *(_DWORD *)(a9 + 16)  = a4;
  *(_DWORD *)(a9 + 20)  = a5;
  *(_BYTE *)(a9 + 24)  = BYTE4(a5) & 1;
  *(_DWORD *)(a9 + 28)  = a6;
  *(_BYTE *)(a9 + 32)  = BYTE4(a6) & 1;
  *(_DWORD *)(a9 + 36)  = a7;
  *(_DWORD *)(a9 + 40)  = a8;
  *(_DWORD *)(a9 + 44)  = a10;
  return result;
}

void AWDLActionFrame.ElectionParameter.hash(into:)()
{
  Swift::UInt8 v1 = *(_BYTE *)(v0 + 1);
  Swift::UInt8 v2 = *(_BYTE *)(v0 + 2);
  Swift::UInt8 v3 = *(_BYTE *)(v0 + 3);
  Swift::UInt8 v4 = *(_BYTE *)(v0 + 4);
  Swift::UInt8 v5 = *(_BYTE *)(v0 + 5);
  Hasher._combine(_:)(*(_BYTE *)v0);
  Hasher._combine(_:)(v1);
  Hasher._combine(_:)(v2);
  Hasher._combine(_:)(v3);
  Hasher._combine(_:)(v4);
  Hasher._combine(_:)(v5);
  Swift::UInt8 v6 = *(_BYTE *)(v0 + 7);
  Swift::UInt8 v7 = *(_BYTE *)(v0 + 8);
  Swift::UInt8 v8 = *(_BYTE *)(v0 + 9);
  Swift::UInt8 v9 = *(_BYTE *)(v0 + 10);
  Swift::UInt8 v10 = *(_BYTE *)(v0 + 11);
  Hasher._combine(_:)(*(_BYTE *)(v0 + 6));
  Hasher._combine(_:)(v6);
  Hasher._combine(_:)(v7);
  Hasher._combine(_:)(v8);
  Hasher._combine(_:)(v9);
  Hasher._combine(_:)(v10);
  Hasher._combine(_:)(*(_DWORD *)(v0 + 12));
  Hasher._combine(_:)(*(_DWORD *)(v0 + 16));
  sub_1000DBCEC((int *)(v0 + 20), (uint64_t)&v14);
  sub_1000DBCEC(&v14, (uint64_t)&v15);
  Swift::UInt32 v11 = v15;
  if (v16 == 1) {
    Swift::UInt32 v11 = dword_100345064[v15];
  }
  Hasher._combine(_:)(v11);
  sub_1000DBCEC((int *)(v0 + 28), (uint64_t)&v13);
  sub_1000DBCEC(&v13, (uint64_t)&v17);
  Swift::UInt32 v12 = v17;
  if (v18 == 1) {
    Swift::UInt32 v12 = dword_100345064[v17];
  }
  Hasher._combine(_:)(v12);
  Hasher._combine(_:)(*(_DWORD *)(v0 + 36));
  Hasher._combine(_:)(*(_DWORD *)(v0 + 40));
  Hasher._combine(_:)(*(_DWORD *)(v0 + 44));
}

uint64_t sub_1000CA518(unsigned __int8 a1)
{
  return ((uint64_t (*)(uint64_t, unint64_t))((char *)sub_1000CA54C + 4 * byte_100340AC8[a1]))( 0x65646F4E746F6F72LL,  0xE800000000000000LL);
}

uint64_t sub_1000CA54C()
{
  return 0x6F4E746E65726170LL;
}

unint64_t sub_1000CA56C()
{
  return 0xD000000000000013LL;
}

uint64_t sub_1000CA600()
{
  return sub_1000CA518(*v0);
}

uint64_t sub_1000CA608@<X0>(uint64_t a1@<X0>, unint64_t a2@<X1>, _BYTE *a3@<X8>)
{
  uint64_t result = sub_1000E44DC(a1, a2);
  *a3  = result;
  return result;
}

void sub_1000CA62C(_BYTE *a1@<X8>)
{
  *a1  = 9;
}

uint64_t sub_1000CA638(uint64_t a1)
{
  unint64_t v2 = sub_1000DBD28();
  return CodingKey.description.getter(a1, v2);
}

uint64_t sub_1000CA660(uint64_t a1)
{
  unint64_t v2 = sub_1000DBD28();
  return CodingKey.debugDescription.getter(a1, v2);
}

uint64_t AWDLActionFrame.ElectionParameter.encode(to:)(void *a1)
{
  Swift::UInt8 v3 = v1;
  uint64_t v5 = sub_100002274(&qword_100407500);
  uint64_t v6 = *(void *)(v5 - 8);
  __chkstk_darwin(v5);
  Swift::UInt8 v8 = (char *)&v20 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v9 = a1[3];
  uint64_t v10 = a1[4];
  sub_100021104(a1, v9);
  unint64_t v11 = sub_1000DBD28();
  dispatch thunk of Encoder.container<A>(keyedBy:)( &type metadata for AWDLActionFrame.ElectionParameter.CodingKeys,  &type metadata for AWDLActionFrame.ElectionParameter.CodingKeys,  v11,  v9,  v10);
  int v21 = *v3;
  __int16 v22 = *((_WORD *)v3 + 2);
  HIBYTE(v20)  = 0;
  unint64_t v12 = sub_1000286C4();
  KeyedEncodingContainer.encode<A>(_:forKey:)(&v21, (char *)&v20 + 7, v5, &type metadata for WiFiAddress, v12);
  if (!v2)
  {
    int v21 = *(int *)((char *)v3 + 6);
    __int16 v22 = *((_WORD *)v3 + 5);
    HIBYTE(v20)  = 1;
    KeyedEncodingContainer.encode<A>(_:forKey:)(&v21, (char *)&v20 + 7, v5, &type metadata for WiFiAddress, v12);
    uint64_t v13 = v3[3];
    LOBYTE(v21)  = 2;
    KeyedEncodingContainer.encode(_:forKey:)(v13, &v21, v5);
    uint64_t v14 = v3[4];
    LOBYTE(v21)  = 3;
    KeyedEncodingContainer.encode(_:forKey:)(v14, &v21, v5);
    sub_1000DBCEC(v3 + 5, (uint64_t)&v24);
    sub_1000DBCEC(&v24, (uint64_t)&v21);
    HIBYTE(v20)  = 4;
    unint64_t v15 = sub_1000DB3B8();
    KeyedEncodingContainer.encode<A>(_:forKey:)(&v21, (char *)&v20 + 7, v5, &type metadata for AWDLElectionMetric, v15);
    sub_1000DBCEC(v3 + 7, (uint64_t)&v23);
    sub_1000DBCEC(&v23, (uint64_t)&v21);
    HIBYTE(v20)  = 5;
    KeyedEncodingContainer.encode<A>(_:forKey:)(&v21, (char *)&v20 + 7, v5, &type metadata for AWDLElectionMetric, v15);
    uint64_t v16 = v3[9];
    LOBYTE(v21)  = 6;
    KeyedEncodingContainer.encode(_:forKey:)(v16, &v21, v5);
    uint64_t v17 = v3[10];
    LOBYTE(v21)  = 7;
    KeyedEncodingContainer.encode(_:forKey:)(v17, &v21, v5);
    uint64_t v18 = v3[11];
    LOBYTE(v21)  = 8;
    KeyedEncodingContainer.encode(_:forKey:)(v18, &v21, v5);
  }

  return (*(uint64_t (**)(char *, uint64_t))(v6 + 8))(v8, v5);
}

Swift::Int AWDLActionFrame.ElectionParameter.hashValue.getter()
{
  return Hasher._finalize()();
}

double AWDLActionFrame.ElectionParameter.init(from:)@<D0>(void *a1@<X0>, _OWORD *a2@<X8>)
{
  if (!v2)
  {
    __int128 v5 = v6[1];
    *a2  = v6[0];
    a2[1]  = v5;
    double result = *(double *)&v7;
    a2[2]  = v7;
  }

  return result;
}

uint64_t sub_1000CA9C0(void *a1)
{
  return AWDLActionFrame.ElectionParameter.encode(to:)(a1);
}

Swift::Int sub_1000CA9F8()
{
  __int128 v1 = v0[1];
  __int128 v4 = *v0;
  __int128 v5 = v1;
  __int128 v6 = v0[2];
  Hasher.init(_seed:)(v3, 0LL);
  AWDLActionFrame.ElectionParameter.hash(into:)();
  return Hasher._finalize()();
}

void sub_1000CAA48()
{
}

Swift::Int sub_1000CAA80(uint64_t a1)
{
  __int128 v2 = v1[1];
  __int128 v5 = *v1;
  __int128 v6 = v2;
  __int128 v7 = v1[2];
  Hasher.init(_seed:)(v4, a1);
  AWDLActionFrame.ElectionParameter.hash(into:)();
  return Hasher._finalize()();
}

BOOL sub_1000CAACC(_OWORD *a1, __int128 *a2)
{
  __int128 v2 = a1[1];
  v7[0]  = *a1;
  v7[1]  = v2;
  __int128 v3 = *a2;
  __int128 v4 = a2[1];
  v7[2]  = a1[2];
  v8[0]  = v3;
  __int128 v5 = a2[2];
  v8[1]  = v4;
  _OWORD v8[2] = v5;
  return _s7CoreP2P15AWDLActionFrameV17ElectionParameterV23__derived_struct_equalsySbAE_AEtFZ_0( (uint64_t)v7,  (uint64_t)v8);
}

uint64_t sub_1000CAB14@<X0>(unsigned __int8 *a1@<X0>, _BYTE *a2@<X8>)
{
  uint64_t result = _s7CoreP2P15AWDLActionFrameV20MultiPeerBSSSteeringV17SteeringMessageIDO8rawValueAGSgs5UInt8V_tcfC_0(*a1);
  *a2  = result;
  return result;
}

uint64_t sub_1000CAB3C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v6 = sub_1000E4CEC();
  return RawRepresentable<>.init(from:)(a1, a2, a3, v6);
}

uint64_t sub_1000CAB98(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v6 = sub_1000E4CEC();
  return RawRepresentable<>.encode(to:)(a1, a2, a3, v6);
}

uint64_t sub_1000CABE4()
{
  return 0x496567617373656DLL;
}

uint64_t sub_1000CAC00@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, _BYTE *a3@<X8>)
{
  if (a1 == 0x496567617373656DLL && a2 == 0xE900000000000044LL)
  {
    uint64_t result = swift_bridgeObjectRelease(0xE900000000000044LL);
    char v8 = 0;
  }

  else
  {
    char v6 = _stringCompareWithSmolCheck(_:_:expecting:)(0x496567617373656DLL, 0xE900000000000044LL, a1, a2, 0LL);
    uint64_t result = swift_bridgeObjectRelease(a2);
    char v8 = v6 ^ 1;
  }

  *a3  = v8 & 1;
  return result;
}

uint64_t sub_1000CACA0(uint64_t a1)
{
  unint64_t v2 = sub_1000DBD6C();
  return CodingKey.description.getter(a1, v2);
}

uint64_t sub_1000CACC8(uint64_t a1)
{
  unint64_t v2 = sub_1000DBD6C();
  return CodingKey.debugDescription.getter(a1, v2);
}

uint64_t AWDLActionFrame.MultiPeerBSSSteering.encode(to:)(void *a1, char a2)
{
  uint64_t v4 = sub_100002274(&qword_100407510);
  uint64_t v5 = *(void *)(v4 - 8);
  __chkstk_darwin(v4);
  __int128 v7 = (char *)&v14 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v8 = a1[3];
  uint64_t v9 = a1[4];
  sub_100021104(a1, v8);
  unint64_t v10 = sub_1000DBD6C();
  dispatch thunk of Encoder.container<A>(keyedBy:)( &type metadata for AWDLActionFrame.MultiPeerBSSSteering.CodingKeys,  &type metadata for AWDLActionFrame.MultiPeerBSSSteering.CodingKeys,  v10,  v8,  v9);
  char v15 = a2;
  unint64_t v11 = sub_1000DBDB0();
  KeyedEncodingContainer.encode<A>(_:forKey:)( &v15,  v12,  v4,  &type metadata for AWDLActionFrame.MultiPeerBSSSteering.SteeringMessageID,  v11);
  return (*(uint64_t (**)(char *, uint64_t))(v5 + 8))(v7, v4);
}

unint64_t AWDLActionFrame.MultiPeerBSSSteering.init(from:)(void *a1)
{
  return sub_1000DA148(a1);
}

unint64_t sub_1000CADFC@<X0>(void *a1@<X0>, _BYTE *a2@<X8>)
{
  unint64_t result = sub_1000DA148(a1);
  if (!v2) {
    *a2  = result;
  }
  return result;
}

uint64_t sub_1000CAE24(void *a1)
{
  return AWDLActionFrame.MultiPeerBSSSteering.encode(to:)(a1, *v1);
}

uint64_t sub_1000CAE3C()
{
  if (*v0) {
    return 0x44496E656B6F74LL;
  }
  else {
    return 0x7367616C66LL;
  }
}

uint64_t sub_1000CAE74@<X0>(uint64_t a1@<X0>, unint64_t a2@<X1>, _BYTE *a3@<X8>)
{
  uint64_t result = sub_1000E48A8(a1, a2);
  *a3  = result;
  return result;
}

uint64_t sub_1000CAE98(uint64_t a1)
{
  unint64_t v2 = sub_1000DBDF4();
  return CodingKey.description.getter(a1, v2);
}

uint64_t sub_1000CAEC0(uint64_t a1)
{
  unint64_t v2 = sub_1000DBDF4();
  return CodingKey.debugDescription.getter(a1, v2);
}

uint64_t AWDLActionFrame.Ranging.encode(to:)(void *a1, uint64_t a2)
{
  uint64_t v5 = sub_100002274(&qword_100407528);
  uint64_t v6 = *(void *)(v5 - 8);
  __chkstk_darwin(v5);
  uint64_t v8 = (char *)&v14 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v9 = a1[3];
  uint64_t v10 = a1[4];
  sub_100021104(a1, v9);
  unint64_t v11 = sub_1000DBDF4();
  dispatch thunk of Encoder.container<A>(keyedBy:)( &type metadata for AWDLActionFrame.Ranging.CodingKeys,  &type metadata for AWDLActionFrame.Ranging.CodingKeys,  v11,  v9,  v10);
  char v17 = 0;
  KeyedEncodingContainer.encode(_:forKey:)(a2, &v17, v5);
  if (!v2)
  {
    v16[0]  = BYTE1(a2);
    v16[1]  = BYTE2(a2);
    void v16[2] = BYTE3(a2);
    void v16[3] = BYTE4(a2);
    _BYTE v16[4] = BYTE5(a2);
    v16[5]  = BYTE6(a2);
    char v15 = 1;
    unint64_t v12 = sub_1000286C4();
    KeyedEncodingContainer.encode<A>(_:forKey:)(v16, &v15, v5, &type metadata for WiFiAddress, v12);
  }

  return (*(uint64_t (**)(char *, uint64_t))(v6 + 8))(v8, v5);
}

uint64_t AWDLActionFrame.Ranging.init(from:)(void *a1)
{
  return sub_1000DA268(a1) & 0xFFFFFFFFFFFFFFLL;
}

uint64_t sub_1000CB054@<X0>(void *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t result = sub_1000DA268(a1);
  if (!v2)
  {
    *(_WORD *)a2  = result;
    *(_BYTE *)(a2 + 2)  = BYTE2(result);
    *(_BYTE *)(a2 + 3)  = BYTE3(result);
    *(_BYTE *)(a2 + 4)  = BYTE4(result);
    *(_BYTE *)(a2 + 5)  = BYTE5(result);
    *(_BYTE *)(a2 + 6)  = BYTE6(result);
  }

  return result;
}

uint64_t sub_1000CB0AC(void *a1)
{
  return AWDLActionFrame.Ranging.encode(to:)( a1,  *v1 | ((unint64_t)*((unsigned __int8 *)v1 + 2) << 16) | ((unint64_t)*(unsigned int *)((char *)v1 + 3) << 24));
}

void *AWDLActionFrame.RealtimeGroup.Flags.airPlaySender.unsafeMutableAddressor()
{
  return &static AWDLActionFrame.RealtimeGroup.Flags.airPlaySender;
}

void *AWDLActionFrame.RealtimeGroup.Flags.universalControl.unsafeMutableAddressor()
{
  return &static AWDLActionFrame.RealtimeGroup.Flags.universalControl;
}

void *AWDLActionFrame.RealtimeGroup.Flags.sidecar.unsafeMutableAddressor()
{
  return &static AWDLActionFrame.RealtimeGroup.Flags.sidecar;
}

void *AWDLActionFrame.RealtimeGroup.Flags.airPlay.unsafeMutableAddressor()
{
  return &static AWDLActionFrame.RealtimeGroup.Flags.airPlay;
}

void *AWDLActionFrame.RealtimeGroup.Flags.mpRemoteCamera.unsafeMutableAddressor()
{
  return &static AWDLActionFrame.RealtimeGroup.Flags.mpRemoteCamera;
}

void *AWDLActionFrame.RealtimeGroup.Flags.ultraLowLatencyInfrastructure.unsafeMutableAddressor()
{
  return &static AWDLActionFrame.RealtimeGroup.Flags.ultraLowLatencyInfrastructure;
}

void *AWDLActionFrame.RealtimeGroup.Flags.discoveryActive.unsafeMutableAddressor()
{
  return &static AWDLActionFrame.RealtimeGroup.Flags.discoveryActive;
}

void *AWDLActionFrame.RealtimeGroup.Flags.forceRetro.unsafeMutableAddressor()
{
  return &static AWDLActionFrame.RealtimeGroup.Flags.forceRetro;
}

uint64_t sub_1000CB134(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v6 = sub_1000DCA74();
  return RawRepresentable<>.init(from:)(a1, a2, a3, v6);
}

uint64_t sub_1000CB190(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v6 = sub_1000DCA74();
  return RawRepresentable<>.encode(to:)(a1, a2, a3, v6);
}

void *AWDLActionFrame.RealtimeGroup.AdditionalFlags.alwaysPrioritizeInfra.unsafeMutableAddressor()
{
  return &static AWDLActionFrame.RealtimeGroup.AdditionalFlags.alwaysPrioritizeInfra;
}

void *AWDLActionFrame.RealtimeGroup.AdditionalFlags.twoGHzRetroModeSupported.unsafeMutableAddressor()
{
  return &static AWDLActionFrame.RealtimeGroup.AdditionalFlags.twoGHzRetroModeSupported;
}

void *AWDLActionFrame.RealtimeGroup.AdditionalFlags.edgeKit.unsafeMutableAddressor()
{
  return &static AWDLActionFrame.RealtimeGroup.AdditionalFlags.edgeKit;
}

void *AWDLActionFrame.RealtimeGroup.AdditionalFlags.disableWiFiDisconnect.unsafeMutableAddressor()
{
  return &static AWDLActionFrame.RealtimeGroup.AdditionalFlags.disableWiFiDisconnect;
}

void *AWDLActionFrame.RealtimeGroup.AdditionalFlags.disableRemoteScreenRTGSync.unsafeMutableAddressor()
{
  return &static AWDLActionFrame.RealtimeGroup.AdditionalFlags.disableRemoteScreenRTGSync;
}

void *AWDLActionFrame.RealtimeGroup.AdditionalFlags.remoteCamera.unsafeMutableAddressor()
{
  return &static AWDLActionFrame.RealtimeGroup.AdditionalFlags.remoteCamera;
}

void *AWDLActionFrame.RealtimeGroup.AdditionalFlags.tvRemoteCamera.unsafeMutableAddressor()
{
  return &static AWDLActionFrame.RealtimeGroup.AdditionalFlags.tvRemoteCamera;
}

void *AWDLActionFrame.RealtimeGroup.AdditionalFlags.remoteScreen.unsafeMutableAddressor()
{
  return &static AWDLActionFrame.RealtimeGroup.AdditionalFlags.remoteScreen;
}

uint64_t sub_1000CB23C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v6 = sub_1000DCB94();
  return RawRepresentable<>.init(from:)(a1, a2, a3, v6);
}

uint64_t sub_1000CB298(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v6 = sub_1000DCB94();
  return RawRepresentable<>.encode(to:)(a1, a2, a3, v6);
}

unint64_t AWDLActionFrame.RealtimeGroup.groupID.getter()
{
  return *(unsigned __int16 *)(v0 + 1) | ((unint64_t)*(unsigned int *)(v0 + 3) << 16);
}

unint64_t AWDLActionFrame.RealtimeGroup.infrastructureChannel.getter()
{
  return *(unsigned int *)(v0 + 8) | ((unint64_t)*(unsigned __int16 *)(v0 + 12) << 32);
}

uint64_t AWDLActionFrame.RealtimeGroup.infrastructureChannel.setter(uint64_t result)
{
  *(_DWORD *)(v1 + 8)  = result;
  *(_WORD *)(v1 + 12)  = WORD2(result);
  return result;
}

uint64_t InfraStatistics.bkOutputPackets.getter()
{
  return *(void *)(v0 + 16);
}

uint64_t NANBeacon.Metadata.rate.setter(uint64_t result)
{
  *(void *)(v1 + 16)  = result;
  return result;
}

uint64_t IEEE80211InformationElement.PreAssociationSecurityNegotiationParameters.finiteCylicGroupID.getter()
{
  return *(unsigned __int8 *)(v0 + 24);
}

uint64_t AWDLActionFrame.RealtimeGroup.additionalFlags.setter(uint64_t result)
{
  *(_BYTE *)(v1 + 24)  = result;
  return result;
}

unint64_t AWDLActionFrame.RealtimeGroup.customRealtimeGroupInfraChannel.getter()
{
  return *(unsigned int *)(v0 + 28) | ((unint64_t)*(unsigned __int16 *)(v0 + 32) << 32);
}

uint64_t AWDLActionFrame.RealtimeGroup.customRealtimeGroupInfraChannel.setter(uint64_t result)
{
  *(_DWORD *)(v1 + 28)  = result;
  *(_WORD *)(v1 + 32)  = WORD2(result);
  return result;
}

void *AWDLActionFrame.RealtimeGroup.activeServiceIdentifiers.getter()
{
  uint64_t v5 = &_swiftEmptySetSingleton;
  char v1 = *v0;
  if ((*v0 & 4) != 0)
  {
    sub_1000D32C8(&v4, AWDLTrafficRegistrationServiceSidecar);
  }

  if ((v1 & 2) != 0)
  {
    sub_1000D32C8(&v4, AWDLTrafficRegistrationServiceUniversalControl);
  }

  if ((v1 & 9) != 0)
  {
    sub_1000D32C8(&v4, AWDLTrafficRegistrationServiceAirPlay);
  }

  if ((v1 & 0x10) != 0)
  {
    sub_1000D32C8(&v4, AWDLTrafficRegistrationServiceMPRemoteCamera);

    char v2 = v0[24];
    if ((v2 & 4) == 0)
    {
LABEL_9:
      if ((v2 & 0x20) == 0) {
        goto LABEL_10;
      }
      goto LABEL_15;
    }
  }

  else
  {
    char v2 = v0[24];
    if ((v2 & 4) == 0) {
      goto LABEL_9;
    }
  }

  sub_1000D32C8(&v4, AWDLTrafficRegistrationServiceEdgeKit);

  if ((v2 & 0x20) == 0)
  {
LABEL_10:
    if ((v2 & 0x40) == 0) {
      goto LABEL_11;
    }
LABEL_16:
    sub_1000D32C8(&v4, AWDLTrafficRegistrationServiceTVRemoteCamera);

    if ((v2 & 0x80) == 0) {
      return v5;
    }
LABEL_17:
    sub_1000D32C8(&v4, AWDLTrafficRegistrationServiceRemoteScreen);

    return v5;
  }

void AWDLActionFrame.RealtimeGroup.hash(into:)()
{
  Swift::UInt8 v1 = *(_BYTE *)(v0 + 2);
  Swift::UInt8 v2 = *(_BYTE *)(v0 + 3);
  Swift::UInt8 v3 = *(_BYTE *)(v0 + 4);
  Swift::UInt8 v4 = *(_BYTE *)(v0 + 5);
  Swift::UInt8 v5 = *(_BYTE *)(v0 + 6);
  Hasher._combine(_:)(*(_BYTE *)(v0 + 1));
  Hasher._combine(_:)(v1);
  Hasher._combine(_:)(v2);
  Hasher._combine(_:)(v3);
  Hasher._combine(_:)(v4);
  Hasher._combine(_:)(v5);
  unint64_t v6 = *(unsigned int *)(v0 + 8) | ((unint64_t)*(unsigned __int16 *)(v0 + 12) << 32);
  if ((v6 & 0xFF00000000LL) == 0x300000000LL)
  {
    Swift::UInt8 v7 = 0;
LABEL_3:
    Hasher._combine(_:)(v7);
  }

  else
  {
    Hasher._combine(_:)(1u);
    Hasher._combine(_:)(v6);
    Hasher._combine(_:)(0x801004u >> ((v6 >> 29) & 0xF8));
    switch(v6 >> 40)
    {
      case 2uLL:
        Hasher._combine(_:)(0LL);
        break;
      case 3uLL:
        Hasher._combine(_:)(1uLL);
        break;
      case 4uLL:
        Hasher._combine(_:)(3uLL);
        break;
      case 5uLL:
        Hasher._combine(_:)(4uLL);
        break;
      case 6uLL:
        Hasher._combine(_:)(5uLL);
        break;
      default:
        Hasher._combine(_:)(2uLL);
        Swift::UInt8 v7 = BYTE5(v6) & 1;
        goto LABEL_3;
    }
  }

  Hasher._combine(_:)(*(void *)(v0 + 16));
  Hasher._combine(_:)(*(_BYTE *)(v0 + 24));
  unint64_t v8 = *(unsigned int *)(v0 + 28) | ((unint64_t)*(unsigned __int16 *)(v0 + 32) << 32);
  if ((v8 & 0xFF00000000LL) == 0x300000000LL)
  {
    Swift::UInt8 v9 = 0;
LABEL_6:
    Hasher._combine(_:)(v9);
  }

  else
  {
    Hasher._combine(_:)(1u);
    Hasher._combine(_:)(v8);
    Hasher._combine(_:)(0x801004u >> ((v8 >> 29) & 0xF8));
    switch(v8 >> 40)
    {
      case 2uLL:
        Hasher._combine(_:)(0LL);
        break;
      case 3uLL:
        Hasher._combine(_:)(1uLL);
        break;
      case 4uLL:
        Hasher._combine(_:)(3uLL);
        break;
      case 5uLL:
        Hasher._combine(_:)(4uLL);
        break;
      case 6uLL:
        Hasher._combine(_:)(5uLL);
        break;
      default:
        Hasher._combine(_:)(2uLL);
        Swift::UInt8 v9 = BYTE5(v8) & 1;
        goto LABEL_6;
    }
  }

  Swift::UInt8 v10 = *(_BYTE *)(v0 + 35);
  Swift::UInt8 v11 = *(_BYTE *)(v0 + 36);
  Swift::UInt8 v12 = *(_BYTE *)(v0 + 37);
  Swift::UInt8 v13 = *(_BYTE *)(v0 + 38);
  Swift::UInt8 v14 = *(_BYTE *)(v0 + 39);
  Hasher._combine(_:)(*(_BYTE *)(v0 + 34));
  Hasher._combine(_:)(v10);
  Hasher._combine(_:)(v11);
  Hasher._combine(_:)(v12);
  Hasher._combine(_:)(v13);
  Hasher._combine(_:)(v14);
}

Swift::Int AWDLActionFrame.RealtimeGroup.hashValue.getter()
{
  return Hasher._finalize()();
}

double sub_1000CB7A8@<D0>(void *a1@<X0>, uint64_t a2@<X8>)
{
  double result = AWDLActionFrame.RealtimeGroup.init(from:)(a1, (uint64_t)v6);
  if (!v2)
  {
    double result = *(double *)v6;
    __int128 v5 = v6[1];
    *(_OWORD *)a2  = v6[0];
    *(_OWORD *)(a2 + 16)  = v5;
    *(void *)(a2 + 32)  = v7;
  }

  return result;
}

double AWDLActionFrame.RealtimeGroup.init(from:)@<D0>(void *a1@<X0>, uint64_t a2@<X8>)
{
  if (!v2)
  {
    double result = *(double *)v6;
    __int128 v5 = v6[1];
    *(_OWORD *)a2  = v6[0];
    *(_OWORD *)(a2 + 16)  = v5;
    *(void *)(a2 + 32)  = v7;
  }

  return result;
}

uint64_t sub_1000CB830(void *a1)
{
  return AWDLActionFrame.RealtimeGroup.encode(to:)(a1);
}

uint64_t AWDLActionFrame.RealtimeGroup.encode(to:)(void *a1)
{
  uint64_t v3 = v1;
  uint64_t v4 = a1[3];
  uint64_t v5 = a1[4];
  sub_100021104(a1, v4);
  dispatch thunk of Encoder.unkeyedContainer()(v29, v4, v5);
  LOBYTE(v27)  = *(_BYTE *)v1;
  uint64_t v6 = v30;
  uint64_t v7 = v31;
  sub_1000237C8((uint64_t)v29, v30);
  unint64_t v8 = sub_1000DBE38();
  dispatch thunk of UnkeyedEncodingContainer.encode<A>(_:)( &v27,  &type metadata for AWDLActionFrame.RealtimeGroup.Flags,  v8,  v6,  v7);
  if (v2) {
    return sub_100002AC4(v29);
  }
  int v27 = *(_DWORD *)(v1 + 1);
  __int16 v28 = *(_WORD *)(v1 + 5);
  uint64_t v9 = v30;
  uint64_t v10 = v31;
  sub_1000237C8((uint64_t)v29, v30);
  unint64_t v11 = sub_1000286C4();
  dispatch thunk of UnkeyedEncodingContainer.encode<A>(_:)(&v27, &type metadata for WiFiAddress, v11, v9, v10);
  sub_1000DBE7C(v1 + 8, (uint64_t)v33);
  sub_1000DBE7C((uint64_t)v33, (uint64_t)&v34);
  unint64_t v12 = v34 | ((unint64_t)v35 << 32);
  if ((v12 & 0xFF00000000LL) == 0x300000000LL)
  {
    unint64_t v12 = 0LL;
  }

  else if (v34 >= 0x100)
  {
    goto LABEL_19;
  }

  uint64_t v13 = v30;
  uint64_t v14 = v31;
  sub_1000237C8((uint64_t)v29, v30);
  dispatch thunk of UnkeyedEncodingContainer.encode(_:)(v12, v13, v14);
  uint64_t v15 = *(void *)(v3 + 16);
  if (v15 < -128)
  {
    __break(1u);
  }

  else if (v15 <= 127)
  {
    uint64_t v16 = v30;
    uint64_t v17 = v31;
    sub_1000237C8((uint64_t)v29, v30);
    dispatch thunk of UnkeyedEncodingContainer.encode(_:)(v15, v16, v17);
    LOBYTE(v27)  = *(_BYTE *)(v3 + 24);
    uint64_t v18 = v30;
    uint64_t v19 = v31;
    sub_1000237C8((uint64_t)v29, v30);
    unint64_t v20 = sub_1000DBEC4();
    dispatch thunk of UnkeyedEncodingContainer.encode<A>(_:)( &v27,  &type metadata for AWDLActionFrame.RealtimeGroup.AdditionalFlags,  v20,  v18,  v19);
    sub_1000DBE7C(v3 + 28, (uint64_t)v32);
    sub_1000DBE7C((uint64_t)v32, (uint64_t)&v36);
    else {
      uint64_t v21 = v36;
    }
    uint64_t v22 = v30;
    uint64_t v23 = v31;
    sub_1000237C8((uint64_t)v29, v30);
    dispatch thunk of UnkeyedEncodingContainer.encode(_:)(v21, v22, v23);
    int v27 = *(_DWORD *)(v3 + 34);
    __int16 v28 = *(_WORD *)(v3 + 38);
    uint64_t v24 = v30;
    uint64_t v25 = v31;
    sub_1000237C8((uint64_t)v29, v30);
    dispatch thunk of UnkeyedEncodingContainer.encode<A>(_:)(&v27, &type metadata for WiFiAddress, v11, v24, v25);
    return sub_100002AC4(v29);
  }

  __break(1u);
LABEL_19:
  uint64_t result = _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  "Not enough bits to represent the passed value",  45LL,  2LL,  "Swift/Integers.swift",  20LL,  2,  3455LL,  0);
  __break(1u);
  return result;
}

Swift::Int sub_1000CBB74(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_1000CBB80(a1, a2, a3, (void (*)(void *))AWDLActionFrame.RealtimeGroup.hash(into:));
}

Swift::Int sub_1000CBB80(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(void *))
{
  return Hasher._finalize()();
}

BOOL sub_1000CBBBC(uint64_t a1, uint64_t a2)
{
  __int128 v2 = *(_OWORD *)(a1 + 16);
  v5[0]  = *(_OWORD *)a1;
  v5[1]  = v2;
  uint64_t v6 = *(void *)(a1 + 32);
  __int128 v3 = *(_OWORD *)(a2 + 16);
  v7[0]  = *(_OWORD *)a2;
  v7[1]  = v3;
  uint64_t v8 = *(void *)(a2 + 32);
  return _s7CoreP2P15AWDLActionFrameV13RealtimeGroupV23__derived_struct_equalsySbAE_AEtFZ_0( (unsigned __int8 *)v5,  (unsigned __int8 *)v7);
}

uint64_t sub_1000CBC04(uint64_t a1)
{
  unint64_t v2 = sub_1000DBF08();
  return CodingKey.description.getter(a1, v2);
}

uint64_t sub_1000CBC2C(uint64_t a1)
{
  unint64_t v2 = sub_1000DBF08();
  return CodingKey.debugDescription.getter(a1, v2);
}

uint64_t AWDLActionFrame.ExtendedChannelSequence.encode(to:)(void *a1)
{
  uint64_t v2 = sub_100002274(&qword_100407548);
  uint64_t v3 = *(void *)(v2 - 8);
  __chkstk_darwin(v2);
  uint64_t v5 = (char *)&v10 - ((v4 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v6 = a1[3];
  uint64_t v7 = a1[4];
  sub_100021104(a1, v6);
  unint64_t v8 = sub_1000DBF08();
  dispatch thunk of Encoder.container<A>(keyedBy:)( &type metadata for AWDLActionFrame.ExtendedChannelSequence.CodingKeys,  &type metadata for AWDLActionFrame.ExtendedChannelSequence.CodingKeys,  v8,  v6,  v7);
  return (*(uint64_t (**)(char *, uint64_t))(v3 + 8))(v5, v2);
}

Swift::Int NANBeacon.hashValue.getter()
{
  return Hasher._finalize()();
}

uint64_t IEEE80211InformationElement.VeryHighThroughputOperation.init(from:)(void *a1)
{
  return sub_100002AC4(a1);
}

Swift::Int sub_1000CBD70(uint64_t a1)
{
  return Hasher._finalize()();
}

uint64_t AWDLActionFrame.PreferredChannels.PreferredChannel.txPower.setter(uint64_t result)
{
  *(_BYTE *)(v1 + 6)  = result;
  return result;
}

void AWDLActionFrame.PreferredChannels.PreferredChannel.hash(into:)(int a1, unint64_t a2)
{
  switch(BYTE5(a2))
  {
    case 2:
      Swift::UInt v3 = 0LL;
      goto LABEL_8;
    case 3:
      Swift::UInt v3 = 1LL;
      goto LABEL_8;
    case 4:
      Swift::UInt v3 = 3LL;
      goto LABEL_8;
    case 5:
      Swift::UInt v3 = 4LL;
      goto LABEL_8;
    case 6:
      Swift::UInt v3 = 5LL;
LABEL_8:
      Hasher._combine(_:)(v3);
      break;
    default:
      Hasher._combine(_:)(2uLL);
      Hasher._combine(_:)(BYTE5(a2) & 1);
      break;
  }

  Hasher._combine(_:)(BYTE6(a2));
}

BOOL static AWDLActionFrame.PreferredChannels.PreferredChannel.__derived_struct_equals(_:_:)( uint64_t a1, uint64_t a2)
{
  return sub_1000D66BC(a1 & 0xFFFFFFFFFFFFFFLL, a2 & 0xFFFFFFFFFFFFFFLL);
}

Swift::Int AWDLActionFrame.PreferredChannels.PreferredChannel.hashValue.getter(uint64_t a1)
{
  return Hasher._finalize()();
}

Swift::Int sub_1000CBEA4()
{
  uint64_t v1 = *(unsigned int *)v0;
  uint64_t v2 = v0[4];
  uint64_t v3 = v0[5];
  uint64_t v4 = v0[6];
  Hasher.init(_seed:)(v6, 0LL);
  AWDLActionFrame.PreferredChannels.PreferredChannel.hash(into:)((int)v6, v1 | (v2 << 32) | (v3 << 40) | (v4 << 48));
  return Hasher._finalize()();
}

void sub_1000CBF04(int a1)
{
}

Swift::Int sub_1000CBF24(uint64_t a1)
{
  uint64_t v2 = *(unsigned int *)v1;
  uint64_t v3 = v1[4];
  uint64_t v4 = v1[5];
  uint64_t v5 = v1[6];
  Hasher.init(_seed:)(v7, a1);
  AWDLActionFrame.PreferredChannels.PreferredChannel.hash(into:)((int)v7, v2 | (v3 << 32) | (v4 << 40) | (v5 << 48));
  return Hasher._finalize()();
}

BOOL sub_1000CBF80(unsigned __int8 *a1, unsigned __int8 *a2)
{
  return sub_1000D66BC( *(unsigned int *)a1 | ((unint64_t)a1[4] << 32) | ((unint64_t)a1[5] << 40) | ((unint64_t)a1[6] << 48),  *(unsigned int *)a2 | ((unint64_t)a2[4] << 32) | ((unint64_t)a2[5] << 40) | ((unint64_t)a2[6] << 48));
}

void AWDLActionFrame.PreferredChannels.hash(into:)(uint64_t a1, unint64_t a2, uint64_t a3)
{
  switch(BYTE5(a2))
  {
    case 2:
      Swift::UInt v6 = 0LL;
      goto LABEL_8;
    case 3:
      Swift::UInt v6 = 1LL;
      goto LABEL_8;
    case 4:
      Swift::UInt v6 = 3LL;
      goto LABEL_8;
    case 5:
      Swift::UInt v6 = 4LL;
      goto LABEL_8;
    case 6:
      Swift::UInt v6 = 5LL;
LABEL_8:
      Hasher._combine(_:)(v6);
      break;
    default:
      Hasher._combine(_:)(2uLL);
      Hasher._combine(_:)(BYTE5(a2) & 1);
      break;
  }

  sub_100082DA0(a1, a3);
}

uint64_t static AWDLActionFrame.PreferredChannels.__derived_struct_equals(_:_:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return sub_1000D679C(a1 & 0xFFFFFFFFFFFFLL, a2, a3 & 0xFFFFFFFFFFFFLL, a4);
}

Swift::Int AWDLActionFrame.PreferredChannels.hashValue.getter(unint64_t a1, uint64_t a2)
{
  switch(BYTE5(a1))
  {
    case 2:
      Swift::UInt v4 = 0LL;
      goto LABEL_8;
    case 3:
      Swift::UInt v4 = 1LL;
      goto LABEL_8;
    case 4:
      Swift::UInt v4 = 3LL;
      goto LABEL_8;
    case 5:
      Swift::UInt v4 = 4LL;
      goto LABEL_8;
    case 6:
      Swift::UInt v4 = 5LL;
LABEL_8:
      Hasher._combine(_:)(v4);
      break;
    default:
      Hasher._combine(_:)(2uLL);
      Hasher._combine(_:)(BYTE5(a1) & 1);
      break;
  }

  sub_100082DA0((uint64_t)v6, a2);
  return Hasher._finalize()();
}

uint64_t sub_1000CC178@<X0>(void *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t result = sub_1000DA3E0(a1);
  if (!v2)
  {
    *(_DWORD *)a2  = result;
    *(_BYTE *)(a2 + 4)  = BYTE4(result);
    *(_BYTE *)(a2 + 5)  = BYTE5(result);
    *(void *)(a2 + 8)  = v5;
  }

  return result;
}

uint64_t AWDLActionFrame.PreferredChannels.init(from:)(void *a1)
{
  return sub_1000DA3E0(a1) & 0xFFFFFFFFFFFFLL;
}

uint64_t sub_1000CC1D8(void *a1)
{
  return AWDLActionFrame.PreferredChannels.encode(to:)( a1,  *v1 | ((unint64_t)*((unsigned __int8 *)v1 + 4) << 32) | ((unint64_t)*((unsigned __int8 *)v1 + 5) << 40),  *((void *)v1 + 1));
}

uint64_t AWDLActionFrame.PreferredChannels.encode(to:)(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = a1[3];
  uint64_t v7 = a1[4];
  sub_100021104(a1, v6);
  dispatch thunk of Encoder.unkeyedContainer()(v31, v6, v7);
  uint64_t v8 = v32;
  uint64_t v9 = v33;
  sub_1000237C8((uint64_t)v31, v32);
  dispatch thunk of UnkeyedEncodingContainer.encode(_:)(0LL, v8, v9);
  if (!v3)
  {
    if ((a2 & 0xFFFFFF00) != 0) {
      goto LABEL_15;
    }
    uint64_t v10 = v32;
    uint64_t v11 = v33;
    sub_1000237C8((uint64_t)v31, v32);
    dispatch thunk of UnkeyedEncodingContainer.encode(_:)(a2, v10, v11);
    uint64_t v12 = Channel.operatingClass.getter(a2 & 0xFFFFFFFFFFFFLL);
    uint64_t v13 = v32;
    uint64_t v14 = v33;
    sub_1000237C8((uint64_t)v31, v32);
    dispatch thunk of UnkeyedEncodingContainer.encode(_:)(v12, v13, v14);
    unint64_t v15 = *(void *)(a3 + 16);
    if (v15 >= 0x100) {
      goto LABEL_15;
    }
    uint64_t v16 = v32;
    uint64_t v17 = v33;
    sub_1000237C8((uint64_t)v31, v32);
    dispatch thunk of UnkeyedEncodingContainer.encode(_:)(v15, v16, v17);
    if (v15)
    {
      uint64_t v18 = *(unsigned int *)(a3 + 32);
      if (v18 <= 0xFF)
      {
        unsigned int v34 = *(unsigned __int8 *)(a3 + 38);
        uint64_t v19 = *(unsigned __int8 *)(a3 + 37);
        uint64_t v20 = *(unsigned __int8 *)(a3 + 36);
        swift_bridgeObjectRetain(a3);
        uint64_t v30 = a3;
        uint64_t v21 = (unsigned __int8 *)(a3 + 46);
        while (1)
        {
          uint64_t v22 = v32;
          uint64_t v23 = v33;
          sub_1000237C8((uint64_t)v31, v32);
          dispatch thunk of UnkeyedEncodingContainer.encode(_:)(v18, v22, v23);
          uint64_t v24 = Channel.operatingClass.getter((v19 << 40) | (v20 << 32) | v18);
          uint64_t v25 = v32;
          uint64_t v26 = v33;
          sub_1000237C8((uint64_t)v31, v32);
          dispatch thunk of UnkeyedEncodingContainer.encode(_:)(v24, v25, v26);
          uint64_t v27 = v32;
          uint64_t v28 = v33;
          sub_1000237C8((uint64_t)v31, v32);
          dispatch thunk of UnkeyedEncodingContainer.encode(_:)(v34, v27, v28);
          if (!--v15) {
            goto LABEL_16;
          }
          unsigned int v34 = *v21;
          uint64_t v19 = *(v21 - 1);
          uint64_t v20 = *(v21 - 2);
          uint64_t v18 = *(unsigned int *)(v21 - 6);
          v21 += 8;
        }
      }

      swift_bridgeObjectRetain(a3);
LABEL_15:
      _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  "Not enough bits to represent the passed value",  45LL,  2LL,  "Swift/Integers.swift",  20LL,  2,  3455LL,  0);
      __break(1u);
LABEL_16:
      swift_bridgeObjectRelease(v30);
    }
  }

  return sub_100002AC4(v31);
}

Swift::Int sub_1000CC4C0()
{
  return AWDLActionFrame.PreferredChannels.hashValue.getter( *v0 | ((unint64_t)*((unsigned __int8 *)v0 + 4) << 32) | ((unint64_t)*((unsigned __int8 *)v0 + 5) << 40),  *((void *)v0 + 1));
}

void sub_1000CC4DC(uint64_t a1)
{
}

Swift::Int sub_1000CC4F8(uint64_t a1)
{
  Swift::UInt32 v2 = *(_DWORD *)v1;
  char v3 = *(_BYTE *)(v1 + 4);
  int v4 = *(unsigned __int8 *)(v1 + 5);
  uint64_t v5 = *(void *)(v1 + 8);
  Hasher.init(_seed:)(v8, a1);
  Hasher._combine(_:)(v2);
  Hasher._combine(_:)(0x801004u >> (8 * v3));
  switch(v4)
  {
    case 2:
      Swift::UInt v6 = 0LL;
      goto LABEL_8;
    case 3:
      Swift::UInt v6 = 1LL;
      goto LABEL_8;
    case 4:
      Swift::UInt v6 = 3LL;
      goto LABEL_8;
    case 5:
      Swift::UInt v6 = 4LL;
      goto LABEL_8;
    case 6:
      Swift::UInt v6 = 5LL;
LABEL_8:
      Hasher._combine(_:)(v6);
      break;
    default:
      Hasher._combine(_:)(2uLL);
      Hasher._combine(_:)(v4 & 1);
      break;
  }

  sub_100082DA0((uint64_t)v8, v5);
  return Hasher._finalize()();
}

uint64_t sub_1000CC5F8(unsigned int *a1, unsigned int *a2)
{
  return sub_1000D679C( *a1 | ((unint64_t)*((unsigned __int8 *)a1 + 4) << 32) | ((unint64_t)*((unsigned __int8 *)a1 + 5) << 40),  *((void *)a1 + 1),  *a2 | ((unint64_t)*((unsigned __int8 *)a2 + 4) << 32) | ((unint64_t)*((unsigned __int8 *)a2 + 5) << 40),  *((void *)a2 + 1));
}

CoreP2P::AWDLActionFrame::ProMode::Command_optional __swiftcall AWDLActionFrame.ProMode.Command.init(rawValue:)( Swift::UInt8 rawValue)
{
  if ((rawValue & 0xFC) != 0) {
    return (CoreP2P::AWDLActionFrame::ProMode::Command_optional)3;
  }
  else {
    return (CoreP2P::AWDLActionFrame::ProMode::Command_optional)(0x2010003u >> (8 * rawValue));
  }
}

uint64_t IEEE80211InformationElement.AuthenticationKeyManagementSuite.rawValue.getter(int a1)
{
  return (a1 + 1);
}

unsigned __int8 *sub_1000CC65C@<X0>(unsigned __int8 *result@<X0>, char *a2@<X8>)
{
  unsigned int v2 = *result;
  if (v2 <= 3) {
    char v3 = 0x2010003u >> (8 * v2);
  }
  else {
    char v3 = 3;
  }
  *a2  = v3;
  return result;
}

void sub_1000CC684(_BYTE *a1@<X8>)
{
  *a1  = *v1 + 1;
}

uint64_t sub_1000CC694(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v6 = sub_1000E4CA8();
  return RawRepresentable<>.init(from:)(a1, a2, a3, v6);
}

uint64_t sub_1000CC6F0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v6 = sub_1000E4CA8();
  return RawRepresentable<>.encode(to:)(a1, a2, a3, v6);
}

Swift::Int sub_1000CC73C()
{
  char v1 = *v0;
  Hasher.init(_seed:)(v3, 0LL);
  Hasher._combine(_:)(v1 + 1);
  return Hasher._finalize()();
}

void sub_1000CC780()
{
}

Swift::Int sub_1000CC7AC(uint64_t a1)
{
  char v2 = *v1;
  Hasher.init(_seed:)(v4, a1);
  Hasher._combine(_:)(v2 + 1);
  return Hasher._finalize()();
}

void *AWDLActionFrame.ProMode.Flags.running.unsafeMutableAddressor()
{
  return &static AWDLActionFrame.ProMode.Flags.running;
}

void *AWDLActionFrame.ProMode.Flags.entering.unsafeMutableAddressor()
{
  return &static AWDLActionFrame.ProMode.Flags.entering;
}

void *AWDLActionFrame.ProMode.Flags.exiting.unsafeMutableAddressor()
{
  return &static AWDLActionFrame.ProMode.Flags.exiting;
}

void *AWDLActionFrame.ProMode.Flags.waitingForResponse.unsafeMutableAddressor()
{
  return &static AWDLActionFrame.ProMode.Flags.waitingForResponse;
}

void *AWDLActionFrame.ProMode.Flags.waitingToEnter.unsafeMutableAddressor()
{
  return &static AWDLActionFrame.ProMode.Flags.waitingToEnter;
}

void *AWDLActionFrame.ProMode.Flags.sendingResponse.unsafeMutableAddressor()
{
  return &static AWDLActionFrame.ProMode.Flags.sendingResponse;
}

uint64_t sub_1000CC83C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v6 = sub_1000DCE1C();
  return RawRepresentable<>.init(from:)(a1, a2, a3, v6);
}

uint64_t sub_1000CC898(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v6 = sub_1000DCE1C();
  return RawRepresentable<>.encode(to:)(a1, a2, a3, v6);
}

void sub_1000CC8E4(_DWORD *a1@<X8>)
{
  *a1  = 0;
}

uint64_t sub_1000CC8EC@<X0>(uint64_t a1@<X0>, _DWORD *a2@<X8>)
{
  int v4 = sub_10019AD24();
  uint64_t result = swift_bridgeObjectRelease(a1);
  *a2  = v4;
  return result;
}

unint64_t NANFollowUpTransferCompleteEvent.peerInstanceID.getter(unint64_t a1)
{
  return a1 >> 8;
}

void AWDLActionFrame.ProMode.hash(into:)(int a1, unint64_t a2, Swift::UInt32 a3)
{
  unint64_t v4 = a2 >> 8;
  unint64_t v5 = HIDWORD(a2);
  Hasher._combine(_:)(a2);
  Hasher._combine(_:)(v4 + 1);
  Hasher._combine(_:)(v5);
  Hasher._combine(_:)(a3);
}

BOOL static AWDLActionFrame.ProMode.__derived_struct_equals(_:_:)(uint64_t a1, int a2, uint64_t a3, int a4)
{
  BOOL v6 = BYTE1(a1) == BYTE1(a3) && HIDWORD(a1) == HIDWORD(a3) && a2 == a4;
  return a1 == a3 && v6;
}

uint64_t sub_1000CC9B0()
{
  return ((uint64_t (*)(uint64_t, unint64_t))((char *)sub_1000CC9E0 + 4 * byte_100340AEF[*v0]))( 0x6E6F6973726576LL,  0xE700000000000000LL);
}

uint64_t sub_1000CC9E0()
{
  return 0x646E616D6D6F63LL;
}

uint64_t sub_1000CC9F4()
{
  return 0x737574617473LL;
}

uint64_t sub_1000CCA08()
{
  return 0x7367616C66LL;
}

uint64_t sub_1000CCA1C@<X0>(uint64_t a1@<X0>, unint64_t a2@<X1>, _BYTE *a3@<X8>)
{
  uint64_t result = sub_1000E4990(a1, a2);
  *a3  = result;
  return result;
}

uint64_t sub_1000CCA40(uint64_t a1)
{
  unint64_t v2 = sub_1000DBF4C();
  return CodingKey.description.getter(a1, v2);
}

uint64_t sub_1000CCA68(uint64_t a1)
{
  unint64_t v2 = sub_1000DBF4C();
  return CodingKey.debugDescription.getter(a1, v2);
}

uint64_t AWDLActionFrame.ProMode.encode(to:)(void *a1, unint64_t a2, int a3)
{
  uint64_t v7 = sub_100002274(&qword_100407558);
  uint64_t v8 = *(void *)(v7 - 8);
  __chkstk_darwin(v7);
  uint64_t v10 = (char *)&v17 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v11 = a1[3];
  uint64_t v12 = a1[4];
  sub_100021104(a1, v11);
  unint64_t v13 = sub_1000DBF4C();
  dispatch thunk of Encoder.container<A>(keyedBy:)( &type metadata for AWDLActionFrame.ProMode.CodingKeys,  &type metadata for AWDLActionFrame.ProMode.CodingKeys,  v13,  v11,  v12);
  char v23 = 0;
  KeyedEncodingContainer.encode(_:forKey:)(a2, &v23, v7);
  if (!v3)
  {
    char v22 = BYTE1(a2);
    char v21 = 1;
    unint64_t v14 = sub_1000DBF90();
    KeyedEncodingContainer.encode<A>(_:forKey:)(&v22, &v21, v7, &type metadata for AWDLActionFrame.ProMode.Command, v14);
    char v20 = 2;
    KeyedEncodingContainer.encode(_:forKey:)(HIDWORD(a2), &v20, v7);
    int v19 = a3;
    char v18 = 3;
    unint64_t v15 = sub_1000DBFD4();
    KeyedEncodingContainer.encode<A>(_:forKey:)(&v19, &v18, v7, &type metadata for AWDLActionFrame.ProMode.Flags, v15);
  }

  return (*(uint64_t (**)(char *, uint64_t))(v8 + 8))(v10, v7);
}

Swift::Int AWDLActionFrame.ProMode.hashValue.getter(unint64_t a1, Swift::UInt32 a2)
{
  Swift::UInt8 v3 = a1;
  unint64_t v4 = a1 >> 8;
  unint64_t v5 = HIDWORD(a1);
  Hasher.init(_seed:)(v7, 0LL);
  Hasher._combine(_:)(v3);
  Hasher._combine(_:)(v4 + 1);
  Hasher._combine(_:)(v5);
  Hasher._combine(_:)(a2);
  return Hasher._finalize()();
}

unint64_t AWDLActionFrame.ProMode.init(from:)(void *a1)
{
  return sub_1000DA5A4(a1) & 0xFFFFFFFF0000FFFFLL;
}

uint64_t sub_1000CCCD4@<X0>(void *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t result = sub_1000DA5A4(a1);
  if (!v2)
  {
    *(_WORD *)a2  = result;
    *(_DWORD *)(a2 + 4)  = HIDWORD(result);
    *(_DWORD *)(a2 + 8)  = v5;
  }

  return result;
}

uint64_t sub_1000CCD0C(void *a1)
{
  return AWDLActionFrame.ProMode.encode(to:)( a1,  *v1 | ((unint64_t)*((unsigned int *)v1 + 1) << 32),  *((_DWORD *)v1 + 2));
}

Swift::Int sub_1000CCD2C()
{
  char v1 = *(_BYTE *)(v0 + 1);
  Swift::UInt32 v2 = *(_DWORD *)(v0 + 4);
  Swift::UInt32 v3 = *(_DWORD *)(v0 + 8);
  Swift::UInt8 v4 = *(_BYTE *)v0;
  Hasher.init(_seed:)(v6, 0LL);
  Hasher._combine(_:)(v4);
  Hasher._combine(_:)(v1 + 1);
  Hasher._combine(_:)(v2);
  Hasher._combine(_:)(v3);
  return Hasher._finalize()();
}

void sub_1000CCDAC()
{
  char v1 = *(_BYTE *)(v0 + 1);
  Swift::UInt32 v2 = *(_DWORD *)(v0 + 4);
  Swift::UInt32 v3 = *(_DWORD *)(v0 + 8);
  Hasher._combine(_:)(*(_BYTE *)v0);
  Hasher._combine(_:)(v1 + 1);
  Hasher._combine(_:)(v2);
  Hasher._combine(_:)(v3);
}

Swift::Int sub_1000CCE04(uint64_t a1)
{
  char v2 = *(_BYTE *)(v1 + 1);
  Swift::UInt32 v3 = *(_DWORD *)(v1 + 4);
  Swift::UInt32 v4 = *(_DWORD *)(v1 + 8);
  Swift::UInt8 v5 = *(_BYTE *)v1;
  Hasher.init(_seed:)(v7, a1);
  Hasher._combine(_:)(v5);
  Hasher._combine(_:)(v2 + 1);
  Hasher._combine(_:)(v3);
  Hasher._combine(_:)(v4);
  return Hasher._finalize()();
}

BOOL sub_1000CCE80(unsigned __int8 *a1, unsigned __int8 *a2)
{
  if (*a1 != *a2) {
    return 0LL;
  }
  return a1[1] == a2[1] && *((_DWORD *)a1 + 1) == *((_DWORD *)a2 + 1) && *((_DWORD *)a1 + 2) == *((_DWORD *)a2 + 2);
}

uint64_t sub_1000CCEBC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v6 = sub_1000E4C64();
  return RawRepresentable<>.init(from:)(a1, a2, a3, v6);
}

uint64_t sub_1000CCF18(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v6 = sub_1000E4C64();
  return RawRepresentable<>.encode(to:)(a1, a2, a3, v6);
}

void AWDLActionFrame.AirDrop.hash(into:)(int a1, __int16 a2)
{
  char v2 = HIBYTE(a2);
  Hasher._combine(_:)(a2);
  Hasher._combine(_:)(v2 & 1);
}

uint64_t static AWDLActionFrame.AirDrop.__derived_struct_equals(_:_:)(__int16 a1, __int16 a2)
{
  else {
    return 0LL;
  }
}

uint64_t sub_1000CCFB4()
{
  if (*v0) {
    return 0x6574617473LL;
  }
  else {
    return 0x6E6F6973726576LL;
  }
}

uint64_t sub_1000CCFEC@<X0>(uint64_t a1@<X0>, unint64_t a2@<X1>, _BYTE *a3@<X8>)
{
  uint64_t result = sub_1000E4B38(a1, a2);
  *a3  = result;
  return result;
}

uint64_t sub_1000CD010(uint64_t a1)
{
  unint64_t v2 = sub_1000DC018();
  return CodingKey.description.getter(a1, v2);
}

uint64_t sub_1000CD038(uint64_t a1)
{
  unint64_t v2 = sub_1000DC018();
  return CodingKey.debugDescription.getter(a1, v2);
}

uint64_t AWDLActionFrame.AirDrop.encode(to:)(void *a1, uint64_t a2)
{
  uint64_t v5 = sub_100002274(&qword_100407578);
  uint64_t v6 = *(void *)(v5 - 8);
  __chkstk_darwin(v5);
  uint64_t v8 = (char *)&v14 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v9 = a1[3];
  uint64_t v10 = a1[4];
  sub_100021104(a1, v9);
  unint64_t v11 = sub_1000DC018();
  dispatch thunk of Encoder.container<A>(keyedBy:)( &type metadata for AWDLActionFrame.AirDrop.CodingKeys,  &type metadata for AWDLActionFrame.AirDrop.CodingKeys,  v11,  v9,  v10);
  char v17 = 0;
  KeyedEncodingContainer.encode(_:forKey:)(a2, &v17, v5);
  if (!v2)
  {
    char v16 = BYTE1(a2) & 1;
    char v15 = 1;
    unint64_t v12 = sub_1000DC05C();
    KeyedEncodingContainer.encode<A>(_:forKey:)(&v16, &v15, v5, &type metadata for AWDLActionFrame.AirDrop.State, v12);
  }

  return (*(uint64_t (**)(char *, uint64_t))(v6 + 8))(v8, v5);
}

Swift::Int AWDLActionFrame.AirDrop.hashValue.getter(__int16 a1)
{
  return Hasher._finalize()();
}

uint64_t AWDLActionFrame.AirDrop.init(from:)(void *a1)
{
  return sub_1000DA780(a1) & 0x1FF;
}

uint64_t sub_1000CD1F4@<X0>(void *a1@<X0>, _BYTE *a2@<X8>)
{
  uint64_t result = sub_1000DA780(a1);
  if (!v2)
  {
    *a2  = result;
    a2[1]  = BYTE1(result) & 1;
  }

  return result;
}

uint64_t sub_1000CD224(void *a1)
{
  if (v1[1]) {
    int v2 = 256;
  }
  else {
    int v2 = 0;
  }
  return AWDLActionFrame.AirDrop.encode(to:)(a1, v2 | *v1);
}

Swift::Int sub_1000CD250()
{
  Swift::UInt8 v1 = v0[1];
  Swift::UInt8 v2 = *v0;
  Hasher.init(_seed:)(v4, 0LL);
  Hasher._combine(_:)(v2);
  Hasher._combine(_:)(v1);
  return Hasher._finalize()();
}

void sub_1000CD2AC()
{
  Swift::UInt8 v1 = v0[1];
  Hasher._combine(_:)(*v0);
  Hasher._combine(_:)(v1);
}

Swift::Int sub_1000CD2E8(uint64_t a1)
{
  Swift::UInt8 v2 = v1[1];
  Swift::UInt8 v3 = *v1;
  Hasher.init(_seed:)(v5, a1);
  Hasher._combine(_:)(v3);
  Hasher._combine(_:)(v2);
  return Hasher._finalize()();
}

uint64_t sub_1000CD340(unsigned __int8 *a1, unsigned __int8 *a2)
{
  return (*a1 == *a2) & (a2[1] ^ a1[1] ^ 1u);
}

uint64_t AWDLActionFrame.AWDLAttribute.AttributeType.rawValue.getter(char a1)
{
  return byte_100345080[a1];
}

BOOL sub_1000CD380(char *a1, char *a2)
{
  return byte_100345080[*a1] == byte_100345080[*a2];
}

Swift::Int sub_1000CD3A4()
{
  uint64_t v1 = *v0;
  Hasher.init(_seed:)(v3, 0LL);
  Hasher._combine(_:)(byte_100345080[v1]);
  return Hasher._finalize()();
}

void sub_1000CD3F0()
{
}

Swift::Int sub_1000CD424(uint64_t a1)
{
  uint64_t v2 = *v1;
  Hasher.init(_seed:)(v4, a1);
  Hasher._combine(_:)(byte_100345080[v2]);
  return Hasher._finalize()();
}

uint64_t sub_1000CD46C@<X0>(unsigned __int8 *a1@<X0>, _BYTE *a2@<X8>)
{
  uint64_t result = _s7CoreP2P15AWDLActionFrameV13AWDLAttributeO13AttributeTypeO8rawValueAGSgs5UInt8V_tcfC_0(*a1);
  *a2  = result;
  return result;
}

void sub_1000CD494(_BYTE *a1@<X8>)
{
  *a1  = byte_100345080[*v1];
}

uint64_t sub_1000CD4AC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v6 = sub_1000E4C20();
  return RawRepresentable<>.init(from:)(a1, a2, a3, v6);
}

uint64_t sub_1000CD508(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v6 = sub_1000E4C20();
  return RawRepresentable<>.encode(to:)(a1, a2, a3, v6);
}

uint64_t AWDLActionFrame.AWDLAttribute.init(from:)@<X0>(void *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v63 = a2;
  uint64_t v62 = type metadata accessor for AWDLActionFrame.AWDLAttribute(0LL);
  uint64_t v3 = __chkstk_darwin(v62);
  v61[20]  = (char *)v61 - ((v4 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v5 = __chkstk_darwin(v3);
  v61[9]  = (char *)v61 - v6;
  uint64_t v7 = __chkstk_darwin(v5);
  v61[8]  = (char *)v61 - v8;
  uint64_t v9 = __chkstk_darwin(v7);
  uint64_t v64 = (char *)v61 - v10;
  uint64_t v11 = __chkstk_darwin(v9);
  uint64_t v65 = (char *)v61 - v12;
  uint64_t v13 = __chkstk_darwin(v11);
  v61[7]  = (char *)v61 - v14;
  uint64_t v15 = __chkstk_darwin(v13);
  v61[19]  = (char *)v61 - v16;
  uint64_t v17 = __chkstk_darwin(v15);
  v61[18]  = (char *)v61 - v18;
  uint64_t v19 = __chkstk_darwin(v17);
  v61[17]  = (char *)v61 - v20;
  uint64_t v21 = __chkstk_darwin(v19);
  v61[16]  = (char *)v61 - v22;
  uint64_t v23 = __chkstk_darwin(v21);
  v61[15]  = (char *)v61 - v24;
  uint64_t v25 = __chkstk_darwin(v23);
  v61[14]  = (char *)v61 - v26;
  uint64_t v27 = __chkstk_darwin(v25);
  v61[13]  = (char *)v61 - v28;
  uint64_t v29 = __chkstk_darwin(v27);
  v61[12]  = (char *)v61 - v30;
  uint64_t v31 = __chkstk_darwin(v29);
  v61[11]  = (char *)v61 - v32;
  uint64_t v33 = __chkstk_darwin(v31);
  v61[10]  = (char *)v61 - v34;
  uint64_t v35 = __chkstk_darwin(v33);
  v61[5]  = (char *)v61 - v36;
  uint64_t v37 = __chkstk_darwin(v35);
  v61[4]  = (char *)v61 - v38;
  uint64_t v39 = __chkstk_darwin(v37);
  v61[6]  = (char *)v61 - v40;
  uint64_t v41 = __chkstk_darwin(v39);
  unint64_t v43 = (char *)v61 - v42;
  uint64_t v44 = __chkstk_darwin(v41);
  unint64_t v46 = (char *)v61 - v45;
  uint64_t v47 = __chkstk_darwin(v44);
  uint64_t v49 = (char *)v61 - v48;
  __chkstk_darwin(v47);
  uint64_t v51 = (char *)v61 - v50;
  uint64_t v53 = a1[3];
  uint64_t v52 = a1[4];
  sub_100021104(a1, v53);
  int16x8_t v54 = v70;
  dispatch thunk of Decoder.unkeyedContainer()(v67, v53, v52);
  if (!v54)
  {
    v61[1]  = v49;
    v61[2]  = v46;
    v61[0]  = v43;
    v61[3]  = v51;
    int16x8_t v70 = a1;
    uint64_t v55 = sub_100002274(&qword_100406478);
    uint64_t v57 = v68;
    uint64_t v56 = v69;
    sub_1000237C8((uint64_t)v67, v68);
    uint64_t v58 = sub_1000572E4( &qword_100406470,  &qword_100406478,  (uint64_t)&protocol conformance descriptor for TypeLengthValue<A, B>);
    dispatch thunk of UnkeyedDecodingContainer.decode<A>(_:)(v55, v55, v58, v57, v56);
    uint64_t v59 = (char *)&loc_1000CD968
        + 4
        * word_100340AF4[_s7CoreP2P15AWDLActionFrameV13AWDLAttributeO13AttributeTypeO8rawValueAGSgs5UInt8V_tcfC_0(v66)];
    __asm { BR              X10 }
  }

  return sub_100002AC4(a1);
}

void AWDLActionFrame.AWDLAttribute.encode(to:)(uint64_t a1)
{
  uint64_t v20 = a1;
  uint64_t v16 = sub_100002274(&qword_100407548);
  v15[6]  = *(void *)(v16 - 8);
  __chkstk_darwin(v16);
  void v15[4] = (char *)v15 - ((v2 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v18 = sub_100002274(&qword_100407510);
  void v15[2] = *(void *)(v18 - 8);
  __chkstk_darwin(v18);
  v15[7]  = (char *)v15 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v17 = sub_100002274(&qword_100407480);
  v15[1]  = *(void *)(v17 - 8);
  __chkstk_darwin(v17);
  v15[5]  = (char *)v15 - ((v4 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v5 = type metadata accessor for AWDLActionFrame.DataPathState(0LL);
  __chkstk_darwin(v5);
  void v15[3] = (char *)v15 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v7 = type metadata accessor for AWDLActionFrame.ServiceResponse(0LL);
  __chkstk_darwin(v7);
  uint64_t v8 = type metadata accessor for AWDLActionFrame.AWDLAttribute(0LL);
  __chkstk_darwin(v8);
  uint64_t v10 = (char *)v15 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  unint64_t v11 = sub_10000D9B0((uint64_t)_swiftEmptyArrayStorage);
  uint64_t v12 = type metadata accessor for BinaryEncoder();
  uint64_t v13 = swift_allocObject(v12, 40LL, 7LL);
  *(_OWORD *)(v13 + 16)  = xmmword_1003398F0;
  uint64_t v19 = v13 + 16;
  *(void *)(v13 + 32)  = v11;
  uint64_t v21 = v1;
  sub_100057FE8(v1, (uint64_t)v10, type metadata accessor for AWDLActionFrame.AWDLAttribute);
  uint64_t v14 = (char *)&loc_1000CF6B4 + dword_1000D0444[swift_getEnumCaseMultiPayload(v10, v8)];
  __asm { BR              X10 }

uint64_t sub_1000CF6C8()
{
  uint64_t v5 = *v1;
  uint64_t v6 = *((void *)v1 + 1);
  *(void *)(v0 + 176)  = v2;
  *(void *)(v0 + 184)  = sub_10000AF70( (unint64_t *)&qword_1004064B0,  (uint64_t (*)(uint64_t))type metadata accessor for BinaryEncoder,  (uint64_t)&protocol conformance descriptor for BinaryEncoder);
  *(void *)(v0 + 152)  = v3;
  swift_bridgeObjectRetain(v6);
  swift_retain();
  AWDLActionFrame.ServiceRequest.encode(to:)((void *)(v0 + 152), v5, v6);
  sub_100002AC4((void *)(v0 + 152));
  if (!v4)
  {
    swift_bridgeObjectRelease_n(v6, 2LL);
    uint64_t v8 = *(void **)(v0 + 96);
    uint64_t v9 = v8[3];
    uint64_t v10 = v8[4];
    sub_100021104(v8, v9);
    dispatch thunk of Encoder.unkeyedContainer()((void *)(v0 + 152), v9, v10);
    AWDLActionFrame.AWDLAttribute.attributeType.getter();
    *(_BYTE *)(v0 + 128)  = v11;
    uint64_t v12 = *(void *)(v0 + 176);
    uint64_t v13 = *(void *)(v0 + 184);
    sub_1000237C8(v0 + 152, v12);
    unint64_t v14 = sub_1000DC0B4();
    dispatch thunk of UnkeyedEncodingContainer.encode<A>(_:)( v0 + 128,  &type metadata for AWDLActionFrame.AWDLAttribute.AttributeType,  v14,  v12,  v13);
    swift_beginAccess(*(void *)(v0 + 88), v0 + 128, 0LL, 0LL);
    __asm { BR              X12 }
  }

  swift_release(v3);
  return swift_bridgeObjectRelease_n(v6, 2LL);
}

void AWDLActionFrame.AWDLAttribute.attributeType.getter()
{
  uint64_t v1 = type metadata accessor for AWDLActionFrame.AWDLAttribute(0LL);
  __chkstk_darwin(v1);
  uint64_t v3 = (char *)&v6 - ((v2 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  sub_100057FE8(v0, (uint64_t)v3, v4);
  uint64_t v5 = (char *)sub_1000D053C + 4 * byte_100340BCC[swift_getEnumCaseMultiPayload(v3, v1)];
  __asm { BR              X10 }

uint64_t sub_1000D053C()
{
  return 1LL;
}

void AWDLActionFrame.AWDLAttribute.hash(into:)()
{
  uint64_t v1 = v0;
  uint64_t v2 = type metadata accessor for AWDLActionFrame.DataPathState(0LL);
  __chkstk_darwin(v2);
  uint64_t v3 = type metadata accessor for AWDLActionFrame.ServiceResponse(0LL);
  __chkstk_darwin(v3);
  uint64_t v4 = type metadata accessor for AWDLActionFrame.AWDLAttribute(0LL);
  __chkstk_darwin(v4);
  uint64_t v6 = (char *)&v9 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  sub_100057FE8(v1, (uint64_t)v6, v7);
  uint64_t v8 = (char *)sub_1000D07C0 + 4 * word_100340BE4[swift_getEnumCaseMultiPayload(v6, v4)];
  __asm { BR              X10 }

uint64_t sub_1000D07C0()
{
  uint64_t v1 = *(void *)(v0 + 8);
  Swift::UInt16 v2 = *(_WORD *)v0;
  Swift::UInt16 v3 = *(_WORD *)(v0 + 2);
  Hasher._combine(_:)(1uLL);
  Hasher._combine(_:)(v2);
  Hasher._combine(_:)(v3);
  Hasher._combine(_:)(*(void *)(v1 + 16));
  uint64_t v4 = *(void *)(v1 + 16);
  if (v4)
  {
    for (uint64_t i = 0LL; i != v4; ++i)
    {
      uint64_t v6 = v1 + i;
      Hasher._combine(_:)(*(_BYTE *)(v6 + 32));
    }
  }

  return swift_bridgeObjectRelease(v1);
}

Swift::Int AWDLActionFrame.AWDLAttribute.hashValue.getter()
{
  return sub_1000D3134((void (*)(void *))AWDLActionFrame.AWDLAttribute.hash(into:));
}

uint64_t sub_1000D1094@<X0>(void *a1@<X0>, uint64_t a2@<X8>)
{
  return AWDLActionFrame.AWDLAttribute.init(from:)(a1, a2);
}

void sub_1000D10A8(uint64_t a1)
{
}

Swift::Int sub_1000D10BC(uint64_t a1, uint64_t a2)
{
  return sub_1000D3180(a1, a2, (void (*)(void *))AWDLActionFrame.AWDLAttribute.hash(into:));
}

Swift::Int sub_1000D10CC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_1000CBB80(a1, a2, a3, (void (*)(void *))AWDLActionFrame.AWDLAttribute.hash(into:));
}

void AWDLActionFrame.hash(into:)(uint64_t a1, unint64_t a2, Swift::UInt32 a3, uint64_t a4)
{
  __int16 v6 = a2;
  unint64_t v7 = a2 >> 16;
  unint64_t v8 = HIDWORD(a2);
  Hasher._combine(_:)(8u);
  Hasher._combine(_:)(v6);
  if ((v6 & 0x100) != 0) {
    Swift::UInt8 v9 = 3;
  }
  else {
    Swift::UInt8 v9 = 0;
  }
  Hasher._combine(_:)(v9);
  Hasher._combine(_:)(v7);
  Hasher._combine(_:)(v8);
  Hasher._combine(_:)(a3);
  Swift::UInt v10 = *(void *)(a4 + 16);
  Hasher._combine(_:)(v10);
  if (v10)
  {
    uint64_t v11 = *(void *)(type metadata accessor for AWDLActionFrame.AWDLAttribute(0LL) - 8);
    uint64_t v12 = a4 + ((*(unsigned __int8 *)(v11 + 80) + 32LL) & ~(unint64_t)*(unsigned __int8 *)(v11 + 80));
    uint64_t v13 = *(void *)(v11 + 72);
    swift_bridgeObjectRetain(a4);
    do
    {
      AWDLActionFrame.AWDLAttribute.hash(into:)();
      v12 += v13;
      --v10;
    }

    while (v10);
    swift_bridgeObjectRelease(a4);
  }

uint64_t static AWDLActionFrame.__derived_struct_equals(_:_:)( uint64_t a1, int a2, uint64_t a3, uint64_t a4, int a5, uint64_t a6)
{
  return sub_1000D6B34(a1 & 0xFFFFFFFF00FF01FFLL, a2, a3, a4 & 0xFFFFFFFF00FF01FFLL, a5, a6);
}

Swift::Int AWDLActionFrame.hashValue.getter(unint64_t a1, Swift::UInt32 a2, uint64_t a3)
{
  __int16 v5 = a1;
  unint64_t v6 = a1 >> 16;
  unint64_t v7 = HIDWORD(a1);
  Hasher.init(_seed:)(v14, 0LL);
  Hasher._combine(_:)(8u);
  Hasher._combine(_:)(v5);
  if ((v5 & 0x100) != 0) {
    Swift::UInt8 v8 = 3;
  }
  else {
    Swift::UInt8 v8 = 0;
  }
  Hasher._combine(_:)(v8);
  Hasher._combine(_:)(v6);
  Hasher._combine(_:)(v7);
  Hasher._combine(_:)(a2);
  Swift::UInt v9 = *(void *)(a3 + 16);
  Hasher._combine(_:)(v9);
  if (v9)
  {
    uint64_t v10 = *(void *)(type metadata accessor for AWDLActionFrame.AWDLAttribute(0LL) - 8);
    uint64_t v11 = a3 + ((*(unsigned __int8 *)(v10 + 80) + 32LL) & ~(unint64_t)*(unsigned __int8 *)(v10 + 80));
    uint64_t v12 = *(void *)(v10 + 72);
    swift_bridgeObjectRetain(a3);
    do
    {
      AWDLActionFrame.AWDLAttribute.hash(into:)();
      v11 += v12;
      --v9;
    }

    while (v9);
    swift_bridgeObjectRelease(a3);
  }

  return Hasher._finalize()();
}

uint64_t sub_1000D12DC@<X0>(void *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t result = sub_1000DAA9C(a1);
  if (!v2)
  {
    *(_BYTE *)a2  = result;
    *(_BYTE *)(a2 + 1)  = BYTE1(result) & 1;
    *(_BYTE *)(a2 + 2)  = BYTE2(result);
    *(_DWORD *)(a2 + 4)  = HIDWORD(result);
    *(_DWORD *)(a2 + 8)  = v5;
    *(void *)(a2 + 16)  = v6;
  }

  return result;
}

unint64_t AWDLActionFrame.init(from:)(void *a1)
{
  return sub_1000DAA9C(a1) & 0xFFFFFFFF00FF01FFLL;
}

uint64_t sub_1000D1350(void *a1)
{
  uint64_t v2 = 256LL;
  if (!v1[1]) {
    uint64_t v2 = 0LL;
  }
  return AWDLActionFrame.encode(to:)( a1,  v2 | *v1 | ((unint64_t)v1[2] << 16) | ((unint64_t)*((unsigned int *)v1 + 1) << 32),  *((unsigned int *)v1 + 2),  *((void *)v1 + 2));
}

uint64_t AWDLActionFrame.encode(to:)(void *a1, unint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8 = a1[3];
  uint64_t v9 = a1[4];
  sub_100021104(a1, v8);
  dispatch thunk of Encoder.unkeyedContainer()(v31, v8, v9);
  uint64_t v10 = v32;
  uint64_t v11 = v33;
  sub_1000237C8((uint64_t)v31, v32);
  unint64_t v12 = sub_1000DC120();
  dispatch thunk of UnkeyedEncodingContainer.encode<A>(_:)( v12,  &type metadata for AWDLActionFrame.OUIType,  v12,  v10,  v11);
  if (!v4)
  {
    LOBYTE(v34)  = a2;
    uint64_t v13 = v32;
    uint64_t v14 = v33;
    sub_1000237C8((uint64_t)v31, v32);
    unint64_t v15 = sub_1000DBB98();
    dispatch thunk of UnkeyedEncodingContainer.encode<A>(_:)( &v34,  &type metadata for AWDLActionFrame.AWDLVersion,  v15,  v13,  v14);
    LOBYTE(v34)  = BYTE1(a2) & 1;
    uint64_t v16 = v32;
    uint64_t v17 = v33;
    sub_1000237C8((uint64_t)v31, v32);
    unint64_t v18 = sub_1000DC164();
    dispatch thunk of UnkeyedEncodingContainer.encode<A>(_:)( &v34,  &type metadata for AWDLActionFrame.OUISubtype,  v18,  v16,  v17);
    uint64_t v19 = v32;
    uint64_t v20 = v33;
    sub_1000237C8((uint64_t)v31, v32);
    dispatch thunk of UnkeyedEncodingContainer.encode(_:)(a2 >> 16, v19, v20);
    unint64_t v21 = HIDWORD(a2);
    uint64_t v22 = v32;
    uint64_t v23 = v33;
    sub_1000237C8((uint64_t)v31, v32);
    dispatch thunk of UnkeyedEncodingContainer.encode(_:)(v21, v22, v23);
    uint64_t v24 = v32;
    uint64_t v25 = v33;
    sub_1000237C8((uint64_t)v31, v32);
    dispatch thunk of UnkeyedEncodingContainer.encode(_:)(a3, v24, v25);
    uint64_t v34 = a4;
    uint64_t v26 = v32;
    uint64_t v27 = v33;
    sub_1000237C8((uint64_t)v31, v32);
    uint64_t v28 = sub_100002274(&qword_1004075D8);
    unint64_t v29 = sub_1000DC1A8();
    dispatch thunk of UnkeyedEncodingContainer.encode<A>(_:)(&v34, v28, v29, v26, v27);
  }

  return sub_100002AC4(v31);
}

Swift::Int sub_1000D15B8()
{
  uint64_t v1 = 256LL;
  if (!v0[1]) {
    uint64_t v1 = 0LL;
  }
  return AWDLActionFrame.hashValue.getter( v1 | *v0 | ((unint64_t)v0[2] << 16) | ((unint64_t)*((unsigned int *)v0 + 1) << 32),  *((_DWORD *)v0 + 2),  *((void *)v0 + 2));
}

void sub_1000D15E8(uint64_t a1)
{
  uint64_t v2 = 256LL;
  if (!v1[1]) {
    uint64_t v2 = 0LL;
  }
  AWDLActionFrame.hash(into:)( a1,  v2 | *v1 | ((unint64_t)v1[2] << 16) | ((unint64_t)*((unsigned int *)v1 + 1) << 32),  *((_DWORD *)v1 + 2),  *((void *)v1 + 2));
}

Swift::Int sub_1000D1618(uint64_t a1)
{
  int v2 = *(unsigned __int8 *)(v1 + 1);
  Swift::UInt32 v3 = *(_DWORD *)(v1 + 4);
  Swift::UInt32 v4 = *(_DWORD *)(v1 + 8);
  uint64_t v5 = *(void *)(v1 + 16);
  Swift::UInt8 v6 = *(_BYTE *)v1;
  Swift::UInt8 v7 = *(_BYTE *)(v1 + 2);
  Hasher.init(_seed:)(v14, a1);
  Hasher._combine(_:)(8u);
  Hasher._combine(_:)(v6);
  if (v2) {
    Swift::UInt8 v8 = 3;
  }
  else {
    Swift::UInt8 v8 = 0;
  }
  Hasher._combine(_:)(v8);
  Hasher._combine(_:)(v7);
  Hasher._combine(_:)(v3);
  Hasher._combine(_:)(v4);
  Swift::UInt v9 = *(void *)(v5 + 16);
  Hasher._combine(_:)(v9);
  if (v9)
  {
    uint64_t v10 = *(void *)(type metadata accessor for AWDLActionFrame.AWDLAttribute(0LL) - 8);
    uint64_t v11 = v5 + ((*(unsigned __int8 *)(v10 + 80) + 32LL) & ~(unint64_t)*(unsigned __int8 *)(v10 + 80));
    uint64_t v12 = *(void *)(v10 + 72);
    swift_bridgeObjectRetain(v5);
    do
    {
      AWDLActionFrame.AWDLAttribute.hash(into:)();
      v11 += v12;
      --v9;
    }

    while (v9);
    swift_bridgeObjectRelease(v5);
  }

  return Hasher._finalize()();
}

uint64_t sub_1000D171C(unsigned __int8 *a1, unsigned __int8 *a2)
{
  uint64_t v2 = *((void *)a1 + 2);
  uint64_t v3 = 256LL;
  if (a1[1]) {
    uint64_t v4 = 256LL;
  }
  else {
    uint64_t v4 = 0LL;
  }
  int v5 = *((_DWORD *)a1 + 2);
  unint64_t v6 = v4 | *a1 | ((unint64_t)a1[2] << 16) | ((unint64_t)*((unsigned int *)a1 + 1) << 32);
  if (!a2[1]) {
    uint64_t v3 = 0LL;
  }
  return static AWDLActionFrame.__derived_struct_equals(_:_:)( v6,  v5,  v2,  v3 | *a2 | ((unint64_t)a2[2] << 16) | ((unint64_t)*((unsigned int *)a2 + 1) << 32),  *((_DWORD *)a2 + 2),  *((void *)a2 + 2));
}

uint64_t sub_1000D1778(uint64_t a1, unsigned __int8 a2, uint64_t a3)
{
  uint64_t v4 = *(void *)(a3 + 16);
  if (!v4)
  {
    uint64_t result = _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  "Negative value is not representable",  35LL,  2LL,  "Swift/Integers.swift",  20LL,  2,  3451LL,  0);
LABEL_38:
    __break(1u);
    return result;
  }

  if ((unint64_t)(v4 - 1) >= 0x100)
  {
LABEL_37:
    uint64_t result = _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  "Not enough bits to represent the passed value",  45LL,  2LL,  "Swift/Integers.swift",  20LL,  2,  3455LL,  0);
    goto LABEL_38;
  }

  uint64_t v8 = *(void *)(a1 + 24);
  uint64_t v9 = *(void *)(a1 + 32);
  sub_1000237C8(a1, v8);
  uint64_t result = dispatch thunk of UnkeyedEncodingContainer.encode(_:)(v4 - 1, v8, v9);
  if (!v3)
  {
    unsigned __int8 v51 = a2;
    uint64_t v11 = *(void *)(a1 + 24);
    uint64_t v12 = *(void *)(a1 + 32);
    sub_1000237C8(a1, v11);
    unint64_t v13 = sub_1000E53D0();
    dispatch thunk of UnkeyedEncodingContainer.encode<A>(_:)( &v51,  &type metadata for AWDLActionFrame.AWDLChannelSequenceParameter.Encoding,  v13,  v11,  v12);
    uint64_t v14 = *(void *)(a1 + 24);
    uint64_t v15 = *(void *)(a1 + 32);
    sub_1000237C8(a1, v14);
    dispatch thunk of UnkeyedEncodingContainer.encode(_:)(0LL, v14, v15);
    uint64_t v16 = *(void *)(a1 + 24);
    uint64_t v17 = *(void *)(a1 + 32);
    sub_1000237C8(a1, v16);
    dispatch thunk of UnkeyedEncodingContainer.encode(_:)(3LL, v16, v17);
    uint64_t v18 = *(void *)(a1 + 24);
    uint64_t v19 = *(void *)(a1 + 32);
    sub_1000237C8(a1, v18);
    dispatch thunk of UnkeyedEncodingContainer.encode(_:)(0xFFFFLL, v18, v19);
    if (a2 - 2 < 2)
    {
      swift_bridgeObjectRetain(a3);
      for (uint64_t i = 32LL; ; i += 8LL)
      {
        unint64_t v21 = *(unsigned int *)(a3 + i) | ((unint64_t)*(unsigned __int16 *)(a3 + i + 4) << 32);
        if ((v21 & 0xFF00000000LL) == 0x300000000LL)
        {
          uint64_t v22 = *(void *)(a1 + 24);
          uint64_t v23 = *(void *)(a1 + 32);
          sub_1000237C8(a1, v22);
          dispatch thunk of UnkeyedEncodingContainer.encode(_:)(0LL, v22, v23);
          uint64_t v24 = *(void *)(a1 + 24);
          uint64_t v25 = *(void *)(a1 + 32);
          sub_1000237C8(a1, v24);
          dispatch thunk of UnkeyedEncodingContainer.encode(_:)(0LL, v24, v25);
        }

        else
        {
          if ((*(_DWORD *)(a3 + i) & 0xFFFFFF00) != 0) {
            goto LABEL_37;
          }
          uint64_t v26 = *(void *)(a1 + 24);
          uint64_t v27 = *(void *)(a1 + 32);
          sub_1000237C8(a1, v26);
          dispatch thunk of UnkeyedEncodingContainer.encode(_:)(v21, v26, v27);
          uint64_t v28 = Channel.operatingClass.getter(v21);
          uint64_t v29 = *(void *)(a1 + 24);
          uint64_t v30 = *(void *)(a1 + 32);
          sub_1000237C8(a1, v29);
          dispatch thunk of UnkeyedEncodingContainer.encode(_:)(v28, v29, v30);
        }

        if (!--v4) {
          return swift_bridgeObjectRelease(a3);
        }
      }
    }

    if (a2)
    {
      swift_bridgeObjectRetain(a3);
      for (j  = 32LL; ; j += 8LL)
      {
        unint64_t v36 = *(unsigned int *)(a3 + j) | ((unint64_t)*(unsigned __int16 *)(a3 + j + 4) << 32);
        if ((v36 & 0xFF00000000LL) == 0x300000000LL)
        {
          uint64_t v37 = *(void *)(a1 + 24);
          uint64_t v38 = *(void *)(a1 + 32);
          sub_1000237C8(a1, v37);
          dispatch thunk of UnkeyedEncodingContainer.encode(_:)(0LL, v37, v38);
          uint64_t v39 = *(void *)(a1 + 24);
          uint64_t v40 = *(void *)(a1 + 32);
          sub_1000237C8(a1, v39);
          dispatch thunk of UnkeyedEncodingContainer.encode(_:)(0LL, v39, v40);
        }

        else
        {
          char v41 = sub_1000D8634(SBYTE4(v36), BYTE5(v36));
          char v50 = v41;
          uint64_t v42 = *(void *)(a1 + 24);
          uint64_t v49 = *(void *)(a1 + 32);
          sub_1000237C8(a1, v42);
          unint64_t v43 = sub_1000E5414();
          dispatch thunk of UnkeyedEncodingContainer.encode<A>(_:)( &v50,  &type metadata for AWDLActionFrame.AWDLChannelSequenceParameter.NChannelOperatingClass,  v43,  v42,  v49);
          if (sub_100071528(0LL, 2LL, v41) == 2 && v36 > 2)
          {
            unint64_t v36 = (v36 - 2);
          }

          else
          {
            int v45 = sub_100071528(0LL, 2LL, v41);
            else {
              unint64_t v36 = v36;
            }
          }

          uint64_t v47 = *(void *)(a1 + 24);
          uint64_t v48 = *(void *)(a1 + 32);
          sub_1000237C8(a1, v47);
          dispatch thunk of UnkeyedEncodingContainer.encode(_:)(v36, v47, v48);
        }

        if (!--v4) {
          return swift_bridgeObjectRelease(a3);
        }
      }
    }

    swift_bridgeObjectRetain(a3);
    uint64_t v31 = 32LL;
    do
    {
      unint64_t v32 = *(unsigned int *)(a3 + v31) | ((unint64_t)*(unsigned __int16 *)(a3 + v31 + 4) << 32);
      if ((v32 & 0xFF00000000LL) == 0x300000000LL)
      {
        unint64_t v32 = 0LL;
      }

      else if (*(_DWORD *)(a3 + v31) >= 0x100u)
      {
        goto LABEL_37;
      }

      uint64_t v33 = *(void *)(a1 + 24);
      uint64_t v34 = *(void *)(a1 + 32);
      sub_1000237C8(a1, v33);
      dispatch thunk of UnkeyedEncodingContainer.encode(_:)(v32, v33, v34);
      v31 += 8LL;
      --v4;
    }

    while (v4);
    return swift_bridgeObjectRelease(a3);
  }

  return result;
}

uint64_t sub_1000D1CE0@<X0>(unsigned __int8 *a1@<X0>, _BYTE *a2@<X8>)
{
  uint64_t result = _s7CoreP2P19NANIntervalDurationO8rawValueACSgs5UInt8V_tcfC_0(*a1);
  *a2  = result;
  return result;
}

uint64_t sub_1000D1D08(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v6 = sub_1000E5B8C();
  return RawRepresentable<>.init(from:)(a1, a2, a3, v6);
}

uint64_t sub_1000D1D64(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v6 = sub_1000E5B8C();
  return RawRepresentable<>.encode(to:)(a1, a2, a3, v6);
}

uint64_t sub_1000D1DB0(char a1)
{
  char v2 = sub_100071528(2uLL, 2LL, a1);
  if (v2 == 1) {
    return 2LL;
  }
  if (v2 == 3) {
    return sub_100071528(0LL, 2LL, a1) == 2;
  }
  return 3LL;
}

uint64_t sub_1000D1E58(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v6 = sub_1000E59E0();
  return RawRepresentable<>.init(from:)(a1, a2, a3, v6);
}

uint64_t sub_1000D1EB4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v6 = sub_1000E59E0();
  return RawRepresentable<>.encode(to:)(a1, a2, a3, v6);
}

void sub_1000D1F00(uint64_t a1@<X1>, void *a2@<X2>, uint64_t a3@<X8>)
{
  uint64_t v7 = *(void *)(a1 + 24);
  uint64_t v8 = *(void *)(a1 + 32);
  sub_1000237C8(a1, v7);
  unint64_t v9 = sub_1000E549C();
  dispatch thunk of UnkeyedDecodingContainer.decode<A>(_:)( &type metadata for AWDLActionFrame.AWDLChannelSequenceParameter.NChannelOperatingClass,  &type metadata for AWDLActionFrame.AWDLChannelSequenceParameter.NChannelOperatingClass,  v9,  v7,  v8);
  if (v3)
  {
    *a2  = v3;
  }

  else
  {
    uint64_t v10 = *(void *)(a1 + 24);
    uint64_t v11 = *(void *)(a1 + 32);
    sub_1000237C8(a1, v10);
    unsigned __int8 v12 = dispatch thunk of UnkeyedDecodingContainer.decode(_:)(v10, v11);
    unsigned __int8 v13 = v12;
    if (!v12) {
      goto LABEL_18;
    }
    char v14 = sub_100071528(0LL, 2LL, v22);
    if (v13 <= 0xDDu && v14 == 2)
    {
      v13 += 2;
    }

    else if (sub_100071528(0LL, 2LL, v22) == 1 && v13 > 2u)
    {
      v13 -= 2;
    }

    char v17 = sub_100071528(4uLL, 4LL, v22) == 1;
    int v18 = sub_1000D1DB0(v22);
    if ((_s7CoreP2P7ChannelV7isValid7channel2on4withSbs6UInt32V_AC4BandOAA9BandwidthOtFZ_0(v13, v17, v18) & 1) != 0)
    {
      BOOL v19 = sub_100071528(4uLL, 4LL, v22) == 1;
      unsigned __int8 v21 = sub_1000D1DB0(v22);
      sub_100185C58();
      *(_DWORD *)a3  = v13;
      unint64_t v20 = (v13 | ((unint64_t)v19 << 32) | ((unint64_t)v21 << 40)) >> 32;
    }

    else
    {
LABEL_18:
      *(_DWORD *)a3  = 0;
      LOWORD(v20)  = 3;
    }

    *(_WORD *)(a3 + 4)  = v20;
  }

unint64_t sub_1000D2134(char a1, char a2)
{
  LOBYTE(v2)  = a2;
  LOBYTE(v3)  = a1;
  if (qword_1004043B8 != -1) {
    goto LABEL_66;
  }
  while (1)
  {
    uint64_t v4 = off_10040A1B0;
    uint64_t v5 = *((void *)off_10040A1B0 + 2);
    if (!v5) {
      return 0x300000000LL;
    }
    unsigned int v6 = v3;
    int v7 = v2;
    uint64_t v8 = (char *)off_10040A1B0 + 32;
    swift_bridgeObjectRetain(off_10040A1B0);
    unint64_t v9 = 0LL;
    p_base_meths  = (__objc2_meth_list **)(&WiFiP2PtvOSUIAgent + 32);
    uint64_t v11 = (void *)&unk_10040A000;
    while (1)
    {
      if (v9 >= v4[2]) {
        goto LABEL_64;
      }
      unsigned __int8 v12 = &v8[16 * v9];
      unsigned __int8 v13 = v12[1];
      LODWORD(v2)  = v12[2];
      uint64_t v3 = *((void *)v12 + 1);
      uint64_t v20 = *(void *)(v3 + 16);
      if (v20)
      {
        if (*(_DWORD *)(v3 + 32) == v6) {
          goto LABEL_61;
        }
        if (v20 != 1)
        {
          if (*(_DWORD *)(v3 + 36) == v6) {
            goto LABEL_61;
          }
          if (v20 != 2)
          {
            if (*(_DWORD *)(v3 + 40) == v6) {
              goto LABEL_61;
            }
            if (v20 != 3)
            {
              uint64_t v21 = 11LL;
              while (1)
              {
                uint64_t v22 = v21 - 7;
                if (__OFADD__(v21 - 8, 1LL)) {
                  goto LABEL_65;
                }
                if (*(_DWORD *)(v3 + 4 * v21) == v6) {
                  break;
                }
                ++v21;
                if (v22 == v20) {
                  goto LABEL_6;
                }
              }

LABEL_61:
              swift_bridgeObjectRetain(v3);
LABEL_58:
              swift_bridgeObjectRelease(v4);
              sub_100185C58();
              swift_bridgeObjectRelease(v3);
              return v6 | ((unint64_t)v13 << 32) | ((unint64_t)v2 << 40);
            }
          }
        }
      }

        sub_1000225EC((uint64_t)v72, &qword_100409F68);
        return 0LL;
      }

      sub_1000226B0((uint64_t)v72, (uint64_t)v71, (uint64_t *)&unk_10040DCB0);
      if (v75 == 1)
      {
        sub_1000225EC((uint64_t)v76, (uint64_t *)&unk_10040DCB0);
        sub_1000225EC((uint64_t)v77, (uint64_t *)&unk_10040DCB0);
        sub_10017B1A0(v71);
        goto LABEL_61;
      }

      sub_1000589F8(&v74, (uint64_t)v70);
      sub_10017B140(v71, (uint64_t)v67);
      sub_10017B140(v70, (uint64_t)v68);
      if (v67[3])
      {
        if (v69)
        {
          sub_10017B1A0(v68);
LABEL_67:
          sub_10017B1A0(v67);
          unint64_t v46 = 1;
LABEL_68:
          sub_10017B1A0(v70);
          sub_1000225EC((uint64_t)v76, (uint64_t *)&unk_10040DCB0);
          sub_1000225EC((uint64_t)v77, (uint64_t *)&unk_10040DCB0);
          sub_10017B1A0(v71);
          sub_1000225EC((uint64_t)v72, (uint64_t *)&unk_10040DCB0);
          if ((v46 & 1) == 0) {
            return 0LL;
          }
          goto LABEL_69;
        }
      }

      else if (!v69)
      {
        goto LABEL_67;
      }

      sub_1000225EC((uint64_t)v67, &qword_100409E48);
      unint64_t v46 = 0;
      goto LABEL_68;
    }

    uint64_t v38 = *((void *)a2 + 6);
    unint64_t v60 = *((void *)a2 + 7);
    uint64_t v39 = *((void *)a2 + 8);
    uint64_t v58 = v37;
    uint64_t v63 = v28;
    uint64_t v65 = v29;
    int v40 = v30;
    sub_10017D3D0(v24, v25, v27, v26, v29, v28, v30);
    sub_10017D3D0(v38, v60, v39, v34, v36, v35, v58);
    sub_1000AADB0(v24, v25, v27, v26, v65, v63, v40);
    sub_1000AADB0(v38, v60, v39, v34, v36, v35, v58);
    return 0LL;
  }

  return result;
}

        uint64_t v141 = v243 & 0xFF00FFFFFFFFFFFFLL | ((unint64_t)v52 << 48);
        __int128 v140 = (uint64_t)v57;
        goto LABEL_81;
      }

unint64_t AWDLActionFrame.Header.channel.getter()
{
  return *(unsigned int *)(v0 + 12) | ((unint64_t)*(unsigned __int8 *)(v0 + 16) << 32) | ((unint64_t)*(unsigned __int8 *)(v0 + 17) << 40);
}

uint64_t AWDLActionFrame.Header.channel.setter(uint64_t result)
{
  *(_DWORD *)(v1 + 12)  = result;
  *(_BYTE *)(v1 + 16)  = BYTE4(result);
  *(_BYTE *)(v1 + 17)  = BYTE5(result);
  return result;
}

uint64_t Channel.channel.setter(uint64_t result)
{
  _DWORD *v1 = result;
  return result;
}

void *AWDLActionFrame.Header.Flags.updateHardwareTSF.unsafeMutableAddressor()
{
  return &static AWDLActionFrame.Header.Flags.updateHardwareTSF;
}

void *AWDLActionFrame.Header.Flags.updateSynchronizationParameters.unsafeMutableAddressor()
{
  return &static AWDLActionFrame.Header.Flags.updateSynchronizationParameters;
}

void *AWDLActionFrame.Header.Flags.updateElectionParameters.unsafeMutableAddressor()
{
  return &static AWDLActionFrame.Header.Flags.updateElectionParameters;
}

void *AWDLActionFrame.Header.Flags.isProbeResponse.unsafeMutableAddressor()
{
  return &static AWDLActionFrame.Header.Flags.isProbeResponse;
}

_DWORD *sub_1000D255C@<X0>(_DWORD *result@<X0>, _DWORD *a2@<X8>)
{
  *a2  = *result;
  return result;
}

Swift::Int sub_1000D2568()
{
  Swift::UInt32 v1 = *v0;
  Hasher.init(_seed:)(v3, 0LL);
  Hasher._combine(_:)(v1);
  return Hasher._finalize()();
}

void sub_1000D25AC()
{
}

Swift::Int sub_1000D25D4(uint64_t a1)
{
  Swift::UInt32 v2 = *v1;
  Hasher.init(_seed:)(v4, a1);
  Hasher._combine(_:)(v2);
  return Hasher._finalize()();
}

_DWORD *sub_1000D2614@<X0>(_DWORD *result@<X0>, int *a2@<X8>)
{
  *a2  = *v2 | *result;
  return result;
}

_DWORD *sub_1000D2628@<X0>(_DWORD *result@<X0>, int *a2@<X8>)
{
  *a2  = *v2 & *result;
  return result;
}

_DWORD *sub_1000D263C@<X0>(_DWORD *result@<X0>, int *a2@<X8>)
{
  *a2  = *v2 ^ *result;
  return result;
}

BOOL sub_1000D2650(_DWORD *a1, int *a2)
{
  int v3 = *a2;
  int v4 = *v2 & *a2;
  if (v4 != *a2) {
    *v2 |= v3;
  }
  *a1  = v3;
  return v4 != v3;
}

_DWORD *sub_1000D2680@<X0>(_DWORD *result@<X0>, uint64_t a2@<X8>)
{
  int v3 = *v2 & *result;
  if (v3) {
    *v2 &= ~*result;
  }
  *(_DWORD *)a2  = v3;
  *(_BYTE *)(a2 + 4)  = v3 == 0;
  return result;
}

int *sub_1000D26AC@<X0>(int *result@<X0>, uint64_t a2@<X8>)
{
  int v3 = *result;
  int v4 = *v2;
  *v2 |= *result;
  int v5 = v4 & v3;
  *(_DWORD *)a2  = v5;
  *(_BYTE *)(a2 + 4)  = v5 == 0;
  return result;
}

_DWORD *sub_1000D26D0(_DWORD *result)
{
  *v1 |= *result;
  return result;
}

_DWORD *sub_1000D26E4(_DWORD *result)
{
  *v1 &= *result;
  return result;
}

_DWORD *sub_1000D26F8(_DWORD *result)
{
  *v1 ^= *result;
  return result;
}

_DWORD *sub_1000D270C@<X0>(_DWORD *result@<X0>, int *a2@<X8>)
{
  *a2  = *v2 & ~*result;
  return result;
}

BOOL sub_1000D2720(_DWORD *a1)
{
  return (*v1 & ~*a1) == 0;
}

BOOL sub_1000D2734(_DWORD *a1)
{
  return (*v1 & *a1) == 0;
}

BOOL sub_1000D2748(_DWORD *a1)
{
  return (*a1 & ~*v1) == 0;
}

BOOL sub_1000D275C()
{
  return *v0 == 0;
}

_DWORD *sub_1000D276C(_DWORD *result)
{
  *v1 &= ~*result;
  return result;
}

uint64_t AWDLActionFrame.Header.flags.getter()
{
  return *(unsigned int *)(v0 + 20);
}

uint64_t AWDLActionFrame.Header.flags.setter(uint64_t result)
{
  *(_DWORD *)(v1 + 20)  = result;
  return result;
}

uint64_t AWDLActionFrame.Header.dwellTime.getter@<X0>(uint64_t a1@<X8>)
{
  uint64_t v3 = v1 + *(int *)(type metadata accessor for AWDLActionFrame.Header(0LL) + 32);
  uint64_t v4 = type metadata accessor for DispatchTimeInterval(0LL);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v4 - 8) + 16LL))(a1, v3, v4);
}

uint64_t AWDLActionFrame.Header.dwellTime.setter(uint64_t a1)
{
  uint64_t v3 = v1 + *(int *)(type metadata accessor for AWDLActionFrame.Header(0LL) + 32);
  uint64_t v4 = type metadata accessor for DispatchTimeInterval(0LL);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v4 - 8) + 40LL))(v3, a1, v4);
}

uint64_t (*AWDLActionFrame.Header.dwellTime.modify())(void)
{
  return NANBitmap.Channel.operatingClass.getter;
}

uint64_t AWDLActionFrame.Header.lifetime.getter@<X0>(uint64_t a1@<X8>)
{
  uint64_t v3 = v1 + *(int *)(type metadata accessor for AWDLActionFrame.Header(0LL) + 36);
  uint64_t v4 = type metadata accessor for DispatchTimeInterval(0LL);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v4 - 8) + 16LL))(a1, v3, v4);
}

uint64_t AWDLActionFrame.Header.lifetime.setter(uint64_t a1)
{
  uint64_t v3 = v1 + *(int *)(type metadata accessor for AWDLActionFrame.Header(0LL) + 36);
  uint64_t v4 = type metadata accessor for DispatchTimeInterval(0LL);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v4 - 8) + 40LL))(v3, a1, v4);
}

uint64_t (*AWDLActionFrame.Header.lifetime.modify())(void)
{
  return NANBitmap.Channel.operatingClass.getter;
}

uint64_t AWDLActionFrame.Header.token.getter()
{
  return *(unsigned int *)(v0 + *(int *)(type metadata accessor for AWDLActionFrame.Header(0LL) + 40));
}

uint64_t AWDLActionFrame.Header.token.setter(int a1)
{
  uint64_t result = type metadata accessor for AWDLActionFrame.Header(0LL);
  *(_DWORD *)(v1 + *(int *)(result + 40))  = a1;
  return result;
}

uint64_t (*AWDLActionFrame.Header.token.modify())(void)
{
  return NANBitmap.Channel.operatingClass.getter;
}

uint64_t AWDLActionFrame.Header.rate.getter()
{
  return *(unsigned int *)(v0 + *(int *)(type metadata accessor for AWDLActionFrame.Header(0LL) + 44));
}

uint64_t AWDLActionFrame.Header.rate.setter(int a1)
{
  uint64_t result = type metadata accessor for AWDLActionFrame.Header(0LL);
  *(_DWORD *)(v1 + *(int *)(result + 44))  = a1;
  return result;
}

uint64_t (*AWDLActionFrame.Header.rate.modify())(void)
{
  return NANBitmap.Channel.operatingClass.getter;
}

uint64_t AWDLActionFrame.Header.rssi.getter()
{
  return *(void *)(v0 + *(int *)(type metadata accessor for AWDLActionFrame.Header(0LL) + 48));
}

uint64_t AWDLActionFrame.Header.rssi.setter(uint64_t a1)
{
  uint64_t result = type metadata accessor for AWDLActionFrame.Header(0LL);
  *(void *)(v1 + *(int *)(result + 4Hasher._combine(_:)(*(_WORD *)(v0 + 8)) = a1;
  return result;
}

uint64_t (*AWDLActionFrame.Header.rssi.modify())(void)
{
  return NANBitmap.Channel.operatingClass.getter;
}

uint64_t AWDLActionFrame.Header.mactime.getter()
{
  return *(unsigned int *)(v0 + *(int *)(type metadata accessor for AWDLActionFrame.Header(0LL) + 52));
}

uint64_t AWDLActionFrame.Header.mactime.setter(int a1)
{
  uint64_t result = type metadata accessor for AWDLActionFrame.Header(0LL);
  *(_DWORD *)(v1 + *(int *)(result + 52))  = a1;
  return result;
}

uint64_t (*AWDLActionFrame.Header.mactime.modify())(void)
{
  return NANBitmap.Channel.operatingClass.getter;
}

uint64_t AWDLActionFrame.Header.tsf.getter()
{
  return *(void *)(v0 + *(int *)(type metadata accessor for AWDLActionFrame.Header(0LL) + 56));
}

uint64_t AWDLActionFrame.Header.tsf.setter(uint64_t a1)
{
  uint64_t result = type metadata accessor for AWDLActionFrame.Header(0LL);
  *(void *)(v1 + *(int *)(result + 56))  = a1;
  return result;
}

uint64_t (*AWDLActionFrame.Header.tsf.modify())(void)
{
  return NANBitmap.Channel.operatingClass.getter;
}

uint64_t AWDLActionFrame.Header.chainRSSIPresent.getter()
{
  return *(unsigned int *)(v0 + *(int *)(type metadata accessor for AWDLActionFrame.Header(0LL) + 60));
}

uint64_t AWDLActionFrame.Header.chainRSSIPresent.setter(int a1)
{
  uint64_t result = type metadata accessor for AWDLActionFrame.Header(0LL);
  *(_DWORD *)(v1 + *(int *)(result + 60))  = a1;
  return result;
}

uint64_t (*AWDLActionFrame.Header.chainRSSIPresent.modify())(void)
{
  return NANBitmap.Channel.operatingClass.getter;
}

uint64_t AWDLActionFrame.Header.chainRSSI.getter()
{
  uint64_t v1 = type metadata accessor for AWDLActionFrame.Header(0LL);
  return swift_bridgeObjectRetain(*(void *)(v0 + *(int *)(v1 + 64)));
}

uint64_t AWDLActionFrame.Header.chainRSSI.setter(uint64_t a1)
{
  uint64_t v3 = *(int *)(type metadata accessor for AWDLActionFrame.Header(0LL) + 64);
  uint64_t result = swift_bridgeObjectRelease(*(void *)(v1 + v3));
  *(void *)(v1 + v3)  = a1;
  return result;
}

uint64_t (*AWDLActionFrame.Header.chainRSSI.modify())(void)
{
  return NANBitmap.Channel.operatingClass.getter;
}

void AWDLActionFrame.Header.hash(into:)()
{
  uint64_t v1 = type metadata accessor for DispatchTimeInterval(0LL);
  uint64_t v2 = *(void *)(v1 - 8);
  uint64_t v3 = __chkstk_darwin(v1);
  uint64_t v47 = (uint64_t *)((char *)&v46 - ((v4 + 15) & 0xFFFFFFFFFFFFFFF0LL));
  __chkstk_darwin(v3);
  unsigned int v6 = (uint64_t *)((char *)&v46 - v5);
  Swift::UInt8 v7 = *(_BYTE *)(v0 + 1);
  Swift::UInt8 v8 = *(_BYTE *)(v0 + 2);
  Swift::UInt8 v9 = *(_BYTE *)(v0 + 3);
  Swift::UInt8 v10 = *(_BYTE *)(v0 + 4);
  Swift::UInt8 v11 = *(_BYTE *)(v0 + 5);
  Hasher._combine(_:)(*(_BYTE *)v0);
  Hasher._combine(_:)(v7);
  Hasher._combine(_:)(v8);
  Hasher._combine(_:)(v9);
  Hasher._combine(_:)(v10);
  Hasher._combine(_:)(v11);
  Swift::UInt8 v12 = *(_BYTE *)(v0 + 7);
  Swift::UInt8 v13 = *(_BYTE *)(v0 + 8);
  Swift::UInt8 v14 = *(_BYTE *)(v0 + 9);
  Swift::UInt8 v15 = *(_BYTE *)(v0 + 10);
  Swift::UInt8 v16 = *(_BYTE *)(v0 + 11);
  Hasher._combine(_:)(*(_BYTE *)(v0 + 6));
  Hasher._combine(_:)(v12);
  Hasher._combine(_:)(v13);
  Hasher._combine(_:)(v14);
  Hasher._combine(_:)(v15);
  Hasher._combine(_:)(v16);
  char v17 = *(_BYTE *)(v0 + 16);
  int v18 = *(unsigned __int8 *)(v0 + 17);
  Hasher._combine(_:)(*(_DWORD *)(v0 + 12));
  Hasher._combine(_:)(0x801004u >> (8 * v17));
  switch(v18)
  {
    case 2:
      Swift::UInt v19 = 0LL;
      goto LABEL_8;
    case 3:
      Swift::UInt v19 = 1LL;
      goto LABEL_8;
    case 4:
      Swift::UInt v19 = 3LL;
      goto LABEL_8;
    case 5:
      Swift::UInt v19 = 4LL;
      goto LABEL_8;
    case 6:
      Swift::UInt v19 = 5LL;
LABEL_8:
      Hasher._combine(_:)(v19);
      break;
    default:
      Hasher._combine(_:)(2uLL);
      Hasher._combine(_:)(v18 & 1);
      break;
  }

  Hasher._combine(_:)(*(_DWORD *)(v0 + 20));
  uint64_t v20 = (int *)type metadata accessor for AWDLActionFrame.Header(0LL);
  uint64_t v21 = *(void (**)(uint64_t *, uint64_t, uint64_t))(v2 + 16);
  v21(v6, v0 + v20[8], v1);
  uint64_t v22 = *(uint64_t (**)(uint64_t *, uint64_t))(v2 + 88);
  int v23 = v22(v6, v1);
  int v24 = enum case for DispatchTimeInterval.seconds(_:);
  if (v23 == enum case for DispatchTimeInterval.seconds(_:))
  {
    (*(void (**)(uint64_t *, uint64_t))(v2 + 96))(v6, v1);
    unint64_t v25 = 0x7FFFFFFFFFFFFFFFLL;
    if (*v6 <= 0) {
      unint64_t v25 = 0x8000000000000000LL;
    }
    else {
      Swift::UInt64 v26 = v25;
    }
    goto LABEL_24;
  }

  if (v23 == enum case for DispatchTimeInterval.milliseconds(_:))
  {
    (*(void (**)(uint64_t *, uint64_t))(v2 + 96))(v6, v1);
    uint64_t v27 = *v6;
    uint64_t v28 = 1000000LL;
LABEL_19:
    Swift::UInt64 v29 = v27 * v28;
    BOOL v30 = (unsigned __int128)(v27 * (__int128)v28) >> 64 != (v27 * v28) >> 63;
    BOOL v31 = v27 <= 0;
    unint64_t v32 = 0x7FFFFFFFFFFFFFFFLL;
    if (v31) {
      unint64_t v32 = 0x8000000000000000LL;
    }
    if (v30) {
      Swift::UInt64 v26 = v32;
    }
    else {
      Swift::UInt64 v26 = v29;
    }
    goto LABEL_24;
  }

  if (v23 == enum case for DispatchTimeInterval.microseconds(_:))
  {
    (*(void (**)(uint64_t *, uint64_t))(v2 + 96))(v6, v1);
    uint64_t v27 = *v6;
    uint64_t v28 = 1000LL;
    goto LABEL_19;
  }

  if (v23 == enum case for DispatchTimeInterval.nanoseconds(_:))
  {
    (*(void (**)(uint64_t *, uint64_t))(v2 + 96))(v6, v1);
    Swift::UInt64 v26 = *v6;
  }

  else
  {
    if (v23 != enum case for DispatchTimeInterval.never(_:)) {
      (*(void (**)(uint64_t *, uint64_t))(v2 + 8))(v6, v1);
    }
    Swift::UInt64 v26 = 0x7FFFFFFFFFFFFFFFLL;
  }

LABEL_39:
  Hasher._combine(_:)(v36);
  Hasher._combine(_:)(*(_DWORD *)(v0 + v20[10]));
  Hasher._combine(_:)(*(_DWORD *)(v0 + v20[11]));
  Hasher._combine(_:)(*(void *)(v0 + v20[12]));
  Hasher._combine(_:)(*(_DWORD *)(v0 + v20[13]));
  Hasher._combine(_:)(*(void *)(v0 + v20[14]));
  Hasher._combine(_:)(*(_DWORD *)(v0 + v20[15]));
  uint64_t v42 = *(void *)(v0 + v20[16]);
  Hasher._combine(_:)(*(void *)(v42 + 16));
  uint64_t v43 = *(void *)(v42 + 16);
  if (v43)
  {
    uint64_t v44 = (Swift::UInt8 *)(v42 + 32);
    do
    {
      Swift::UInt8 v45 = *v44++;
      Hasher._combine(_:)(v45);
      --v43;
    }

    while (v43);
  }

                __break(1u);
LABEL_40:
                __break(1u);
LABEL_41:
                __break(1u);
                goto LABEL_42;
              }

              uint64_t v20 = v31;
            }
          }
        }

  __break(1u);
  return result;
}

  __break(1u);
  return result;
}

  __break(1u);
LABEL_40:
  __break(1u);
LABEL_41:
  __break(1u);
  return result;
}

  __break(1u);
LABEL_40:
  __break(1u);
LABEL_41:
  __break(1u);
  return result;
}

  __break(1u);
LABEL_40:
  __break(1u);
LABEL_41:
  __break(1u);
  return result;
}

  __break(1u);
LABEL_40:
  __break(1u);
LABEL_41:
  __break(1u);
  return result;
}

  __break(1u);
LABEL_40:
  __break(1u);
LABEL_41:
  __break(1u);
  return result;
}

Swift::Int AWDLActionFrame.Header.hashValue.getter()
{
  return sub_1000D3134((void (*)(void *))AWDLActionFrame.Header.hash(into:));
}

Swift::Int sub_1000D3134(void (*a1)(void *))
{
  return Hasher._finalize()();
}

Swift::Int sub_1000D3174(uint64_t a1, uint64_t a2)
{
  return sub_1000D3180(a1, a2, (void (*)(void *))AWDLActionFrame.Header.hash(into:));
}

Swift::Int sub_1000D3180(uint64_t a1, uint64_t a2, void (*a3)(void *))
{
  return Hasher._finalize()();
}

Swift::Int sub_1000D31C4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_1000CBB80(a1, a2, a3, (void (*)(void *))AWDLActionFrame.Header.hash(into:));
}

uint64_t sub_1000D31D0(uint64_t *a1, uint64_t a2)
{
  uint64_t v3 = v2;
  uint64_t v6 = *v2;
  uint64_t v7 = static Hasher._hash(seed:_:)(*(void *)(v6 + 40), a2);
  uint64_t v8 = -1LL << *(_BYTE *)(v6 + 32);
  unint64_t v9 = v7 & ~v8;
  if (((*(void *)(v6 + 56 + ((v9 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> v9) & 1) == 0)
  {
LABEL_7:
    isUniquelyReferenced_nonNull_native  = swift_isUniquelyReferenced_nonNull_native(*v3);
    uint64_t v15 = *v3;
    *uint64_t v3 = 0x8000000000000000LL;
    sub_1000D4598(a2, v9, isUniquelyReferenced_nonNull_native);
    uint64_t v14 = *v3;
    *uint64_t v3 = v15;
    swift_bridgeObjectRelease(v14);
    uint64_t result = 1LL;
    goto LABEL_8;
  }

  uint64_t v10 = *(void *)(v6 + 48);
  if (*(void *)(v10 + 8 * v9) != a2)
  {
    uint64_t v11 = ~v8;
    do
    {
      unint64_t v9 = (v9 + 1) & v11;
      if (((*(void *)(v6 + 56 + ((v9 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> v9) & 1) == 0) {
        goto LABEL_7;
      }
    }

    while (*(void *)(v10 + 8 * v9) != a2);
  }

  uint64_t result = 0LL;
LABEL_8:
  *a1  = a2;
  return result;
}

uint64_t sub_1000D32C8(void *a1, void *a2)
{
  uint64_t v3 = v2;
  uint64_t v6 = *v2;
  uint64_t v7 = *(void *)(*v2 + 40LL);
  uint64_t v8 = static String._unconditionallyBridgeFromObjectiveC(_:)(a2);
  uint64_t v10 = v9;
  Hasher.init(_seed:)(v36, v7);
  swift_bridgeObjectRetain(v6);
  String.hash(into:)(v36, v8, v10);
  Swift::Int v11 = Hasher._finalize()();
  swift_bridgeObjectRelease(v10);
  uint64_t v12 = -1LL << *(_BYTE *)(v6 + 32);
  unint64_t v13 = v11 & ~v12;
  if (((*(void *)(v6 + 56 + ((v13 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> v13) & 1) == 0)
  {
LABEL_15:
    swift_bridgeObjectRelease(v6);
    isUniquelyReferenced_nonNull_native  = swift_isUniquelyReferenced_nonNull_native(*v3);
    v36[0]  = *v3;
    *uint64_t v3 = 0x8000000000000000LL;
    id v31 = a2;
    sub_1000D46B8((uint64_t)v31, v13, isUniquelyReferenced_nonNull_native);
    uint64_t v32 = *v3;
    *uint64_t v3 = v36[0];
    swift_bridgeObjectRelease(v32);
    *a1  = v31;
    return 1LL;
  }

  uint64_t v14 = static String._unconditionallyBridgeFromObjectiveC(_:)(*(void *)(*(void *)(v6 + 48) + 8 * v13));
  uint64_t v16 = v15;
  uint64_t v17 = static String._unconditionallyBridgeFromObjectiveC(_:)(a2);
  if (v14 == v17 && v16 == v18)
  {
LABEL_16:
    swift_bridgeObjectRelease_n(v16, 2LL);
  }

  else
  {
    uint64_t v20 = v18;
    char v21 = _stringCompareWithSmolCheck(_:_:expecting:)(v14, v16, v17, v18, 0LL);
    swift_bridgeObjectRelease(v16);
    swift_bridgeObjectRelease(v20);
    if ((v21 & 1) == 0)
    {
      uint64_t v22 = ~v12;
      do
      {
        unint64_t v13 = (v13 + 1) & v22;
        if (((*(void *)(v6 + 56 + ((v13 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> v13) & 1) == 0) {
          goto LABEL_15;
        }
        uint64_t v23 = static String._unconditionallyBridgeFromObjectiveC(_:)(*(void *)(*(void *)(v6 + 48) + 8 * v13));
        uint64_t v16 = v24;
        uint64_t v25 = static String._unconditionallyBridgeFromObjectiveC(_:)(a2);
        if (v23 == v25 && v16 == v26) {
          goto LABEL_16;
        }
        uint64_t v28 = v26;
        char v29 = _stringCompareWithSmolCheck(_:_:expecting:)(v23, v16, v25, v26, 0LL);
        swift_bridgeObjectRelease(v16);
        swift_bridgeObjectRelease(v28);
      }

      while ((v29 & 1) == 0);
    }
  }

  swift_bridgeObjectRelease(v6);
  int v34 = *(void **)(*(void *)(*v3 + 48LL) + 8 * v13);
  *a1  = v34;
  id v35 = v34;
  return 0LL;
}

uint64_t sub_1000D34F0(uint64_t a1, uint64_t a2)
{
  uint64_t v34 = a1;
  uint64_t v4 = *(void *)(type metadata accessor for AWDLPeer.AdvertisedService(0LL) - 8);
  __chkstk_darwin();
  uint64_t v6 = (char *)&v32 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  __chkstk_darwin();
  uint64_t v8 = (char *)&v32 - v7;
  uint64_t v33 = v2;
  uint64_t v9 = *v2;
  Hasher.init(_seed:)(&v46, *(void *)(*v2 + 40));
  swift_bridgeObjectRetain(v9);
  AWDLPeer.AdvertisedService.hash(into:)((uint64_t)&v46);
  Swift::Int v10 = Hasher._finalize()();
  uint64_t v11 = -1LL << *(_BYTE *)(v9 + 32);
  unint64_t v12 = v10 & ~v11;
  uint64_t v39 = v9 + 56;
  if (((*(void *)(v9 + 56 + ((v12 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> v12) & 1) == 0)
  {
    swift_bridgeObjectRelease(v9);
    goto LABEL_20;
  }

  uint64_t v32 = v8;
  uint64_t v36 = ~v11;
  uint64_t v38 = *(void *)(v4 + 72);
  unint64_t v13 = type metadata accessor for AWDLPeer.AdvertisedService;
  uint64_t v37 = v9;
  do
  {
    uint64_t v14 = *(void *)(v9 + 48);
    unint64_t v35 = v38 * v12;
    uint64_t v15 = v13;
    sub_100057FE8(v14 + v38 * v12, (uint64_t)v6, v13);
    uint64_t v16 = *((void *)v6 + 1);
    uint64_t v17 = *((void *)v6 + 2);
    uint64_t v18 = *((void *)v6 + 3);
    uint64_t v19 = *((void *)v6 + 4);
    int v43 = v6[40];
    int v41 = v6[41];
    uint64_t v20 = *(void *)(a2 + 8);
    uint64_t v21 = *(void *)(a2 + 16);
    uint64_t v23 = *(void *)(a2 + 24);
    uint64_t v22 = *(void *)(a2 + 32);
    int v42 = *(unsigned __int8 *)(a2 + 40);
    int v40 = *(unsigned __int8 *)(a2 + 41);
    uint64_t v46 = v16;
    uint64_t v47 = v17;
    uint64_t v44 = v20;
    uint64_t v45 = v21;
    unint64_t v24 = sub_10000B08C();
    if (StringProtocol.caseInsensitiveCompare<A>(_:)( &v44,  &type metadata for String,  &type metadata for String,  v24,  v24)
      || (uint64_t v46 = v18,
          uint64_t v47 = v19,
          uint64_t v44 = v23,
          uint64_t v45 = v22,
          StringProtocol.caseInsensitiveCompare<A>(_:)( &v44,  &type metadata for String,  &type metadata for String,  v24,  v24)))
    {
LABEL_3:
      unint64_t v13 = v15;
      sub_10005802C((uint64_t)v6, v15);
      uint64_t v9 = v37;
      goto LABEL_4;
    }

    if (v43) {
      uint64_t v25 = 7365749LL;
    }
    else {
      uint64_t v25 = 7365492LL;
    }
    if (v42) {
      uint64_t v26 = 7365749LL;
    }
    else {
      uint64_t v26 = 7365492LL;
    }
    if (v25 == v26)
    {
      swift_bridgeObjectRelease_n(0xE300000000000000LL, 2LL);
    }

    else
    {
      char v27 = _stringCompareWithSmolCheck(_:_:expecting:)(v25, 0xE300000000000000LL, v26, 0xE300000000000000LL, 0LL);
      swift_bridgeObjectRelease_n(0xE300000000000000LL, 2LL);
      if ((v27 & 1) == 0) {
        goto LABEL_3;
      }
    }

    unint64_t v13 = v15;
    sub_10005802C((uint64_t)v6, v15);
    uint64_t v9 = v37;
    if (v41 == v40)
    {
      swift_bridgeObjectRelease(v37);
      sub_10005802C(a2, type metadata accessor for AWDLPeer.AdvertisedService);
      sub_100057FE8(*(void *)(*v33 + 48) + v35, v34, type metadata accessor for AWDLPeer.AdvertisedService);
      return 0LL;
    }

uint64_t sub_1000D3834(_BYTE *a1, uint64_t a2)
{
  uint64_t v3 = v2;
  uint64_t v6 = *v2;
  uint64_t v7 = static Hasher._hash(seed:bytes:count:)(*(void *)(v6 + 40), a2, 1LL);
  uint64_t v8 = -1LL << *(_BYTE *)(v6 + 32);
  unint64_t v9 = v7 & ~v8;
  if (((*(void *)(v6 + 56 + ((v9 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> v9) & 1) == 0)
  {
LABEL_7:
    isUniquelyReferenced_nonNull_native  = swift_isUniquelyReferenced_nonNull_native(*v3);
    uint64_t v15 = *v3;
    *uint64_t v3 = 0x8000000000000000LL;
    sub_1000D4BD4(a2, v9, isUniquelyReferenced_nonNull_native);
    uint64_t v14 = *v3;
    *uint64_t v3 = v15;
    swift_bridgeObjectRelease(v14);
    uint64_t result = 1LL;
    goto LABEL_8;
  }

  uint64_t v10 = *(void *)(v6 + 48);
  if (*(unsigned __int8 *)(v10 + v9) != a2)
  {
    uint64_t v11 = ~v8;
    do
    {
      unint64_t v9 = (v9 + 1) & v11;
      if (((*(void *)(v6 + 56 + ((v9 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> v9) & 1) == 0) {
        goto LABEL_7;
      }
    }

    while (*(unsigned __int8 *)(v10 + v9) != a2);
  }

  uint64_t result = 0LL;
LABEL_8:
  *a1  = a2;
  return result;
}

uint64_t sub_1000D3934(uint64_t a1)
{
  uint64_t v2 = v1;
  uint64_t v3 = *v1;
  if (*(void *)(*v1 + 24) <= a1) {
    uint64_t v4 = a1;
  }
  else {
    uint64_t v4 = *(void *)(*v1 + 24);
  }
  sub_100002274(&qword_100407CB0);
  uint64_t result = static _SetStorage.resize(original:capacity:move:)(v3, v4, 1LL);
  uint64_t v6 = result;
  if (*(void *)(v3 + 16))
  {
    int64_t v7 = 0LL;
    uint64_t v8 = (uint64_t *)(v3 + 56);
    uint64_t v9 = 1LL << *(_BYTE *)(v3 + 32);
    uint64_t v28 = -1LL << v9;
    char v29 = v2;
    if (v9 < 64) {
      uint64_t v10 = ~(-1LL << v9);
    }
    else {
      uint64_t v10 = -1LL;
    }
    unint64_t v11 = v10 & *(void *)(v3 + 56);
    uint64_t v30 = 1LL << *(_BYTE *)(v3 + 32);
    int64_t v12 = (unint64_t)(v9 + 63) >> 6;
    uint64_t v13 = result + 56;
    while (1)
    {
      if (v11)
      {
        unint64_t v15 = __clz(__rbit64(v11));
        v11 &= v11 - 1;
        unint64_t v16 = v15 | (v7 << 6);
      }

      else
      {
        int64_t v17 = v7 + 1;
        if (__OFADD__(v7, 1LL))
        {
LABEL_41:
          __break(1u);
LABEL_42:
          __break(1u);
          return result;
        }

        if (v17 >= v12) {
          goto LABEL_36;
        }
        unint64_t v18 = v8[v17];
        ++v7;
        if (!v18)
        {
          int64_t v7 = v17 + 1;
          if (v17 + 1 >= v12) {
            goto LABEL_36;
          }
          unint64_t v18 = v8[v7];
          if (!v18)
          {
            int64_t v7 = v17 + 2;
            if (v17 + 2 >= v12) {
              goto LABEL_36;
            }
            unint64_t v18 = v8[v7];
            if (!v18)
            {
              int64_t v19 = v17 + 3;
              if (v19 >= v12)
              {
LABEL_36:
                if (v30 >= 64) {
                  bzero((void *)(v3 + 56), 8 * v12);
                }
                else {
                  *uint64_t v8 = v28;
                }
                uint64_t v2 = v29;
                *(void *)(v3 + 16)  = 0LL;
                break;
              }

              unint64_t v18 = v8[v19];
              if (!v18)
              {
                while (1)
                {
                  int64_t v7 = v19 + 1;
                  if (__OFADD__(v19, 1LL)) {
                    goto LABEL_42;
                  }
                  if (v7 >= v12) {
                    goto LABEL_36;
                  }
                  unint64_t v18 = v8[v7];
                  ++v19;
                  if (v18) {
                    goto LABEL_26;
                  }
                }
              }

              int64_t v7 = v19;
            }
          }
        }

void sub_1000D3BB4(uint64_t a1)
{
  uint64_t v2 = v1;
  uint64_t v3 = *v1;
  if (*(void *)(*v1 + 24) <= a1) {
    uint64_t v4 = a1;
  }
  else {
    uint64_t v4 = *(void *)(*v1 + 24);
  }
  sub_100002274(&qword_100407D18);
  uint64_t v5 = static _SetStorage.resize(original:capacity:move:)(v3, v4, 1LL);
  uint64_t v6 = v5;
  if (*(void *)(v3 + 16))
  {
    uint64_t v32 = v2;
    uint64_t v7 = 1LL << *(_BYTE *)(v3 + 32);
    uint64_t v34 = (void *)(v3 + 56);
    if (v7 < 64) {
      uint64_t v8 = ~(-1LL << v7);
    }
    else {
      uint64_t v8 = -1LL;
    }
    unint64_t v9 = v8 & *(void *)(v3 + 56);
    int64_t v33 = (unint64_t)(v7 + 63) >> 6;
    uint64_t v10 = v5 + 56;
    swift_retain();
    int64_t v11 = 0LL;
    while (1)
    {
      if (v9)
      {
        unint64_t v13 = __clz(__rbit64(v9));
        v9 &= v9 - 1;
        unint64_t v14 = v13 | (v11 << 6);
      }

      else
      {
        int64_t v15 = v11 + 1;
        if (__OFADD__(v11, 1LL))
        {
LABEL_41:
          __break(1u);
LABEL_42:
          __break(1u);
          return;
        }

        if (v15 >= v33) {
          goto LABEL_36;
        }
        unint64_t v16 = v34[v15];
        ++v11;
        if (!v16)
        {
          int64_t v11 = v15 + 1;
          if (v15 + 1 >= v33) {
            goto LABEL_36;
          }
          unint64_t v16 = v34[v11];
          if (!v16)
          {
            int64_t v11 = v15 + 2;
            if (v15 + 2 >= v33) {
              goto LABEL_36;
            }
            unint64_t v16 = v34[v11];
            if (!v16)
            {
              int64_t v17 = v15 + 3;
              if (v17 >= v33)
              {
LABEL_36:
                swift_release(v3);
                uint64_t v2 = v32;
                uint64_t v31 = 1LL << *(_BYTE *)(v3 + 32);
                if (v31 > 63) {
                  bzero(v34, ((unint64_t)(v31 + 63) >> 3) & 0x1FFFFFFFFFFFFFF8LL);
                }
                else {
                  *uint64_t v34 = -1LL << v31;
                }
                *(void *)(v3 + 16)  = 0LL;
                break;
              }

              unint64_t v16 = v34[v17];
              if (!v16)
              {
                while (1)
                {
                  int64_t v11 = v17 + 1;
                  if (__OFADD__(v17, 1LL)) {
                    goto LABEL_42;
                  }
                  if (v11 >= v33) {
                    goto LABEL_36;
                  }
                  unint64_t v16 = v34[v11];
                  ++v17;
                  if (v16) {
                    goto LABEL_26;
                  }
                }
              }

              int64_t v11 = v17;
            }
          }
        }

void sub_1000D3EC4(uint64_t a1)
{
  uint64_t v2 = v1;
  uint64_t v43 = *(void *)(type metadata accessor for AWDLPeer.AdvertisedService(0LL) - 8);
  __chkstk_darwin();
  uint64_t v5 = (char *)&v38 - ((v4 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v6 = *v2;
  if (*(void *)(*v2 + 24) > a1) {
    a1  = *(void *)(*v2 + 24);
  }
  sub_100002274((uint64_t *)&unk_10040ECF0);
  uint64_t v7 = static _SetStorage.resize(original:capacity:move:)(v6, a1, 1LL);
  uint64_t v8 = v7;
  if (!*(void *)(v6 + 16)) {
    goto LABEL_42;
  }
  uint64_t v9 = 1LL << *(_BYTE *)(v6 + 32);
  uint64_t v10 = *(void *)(v6 + 56);
  int v41 = (void *)(v6 + 56);
  if (v9 < 64) {
    uint64_t v11 = ~(-1LL << v9);
  }
  else {
    uint64_t v11 = -1LL;
  }
  unint64_t v12 = v11 & v10;
  uint64_t v39 = v2;
  int64_t v40 = (unint64_t)(v9 + 63) >> 6;
  uint64_t v13 = v7 + 56;
  swift_retain();
  int64_t v14 = 0LL;
  uint64_t v42 = v6;
  while (1)
  {
    if (v12)
    {
      int64_t v45 = v14;
      uint64_t v46 = (v12 - 1) & v12;
      unint64_t v16 = __clz(__rbit64(v12)) | (v14 << 6);
      goto LABEL_26;
    }

    int64_t v17 = v14 + 1;
    if (__OFADD__(v14, 1LL))
    {
LABEL_43:
      __break(1u);
LABEL_44:
      __break(1u);
      return;
    }

    if (v17 >= v40) {
      goto LABEL_38;
    }
    unint64_t v18 = v41[v17];
    int64_t v19 = v14 + 1;
    if (!v18)
    {
      int64_t v19 = v14 + 2;
      if (v14 + 2 >= v40) {
        goto LABEL_38;
      }
      unint64_t v18 = v41[v19];
      if (!v18)
      {
        int64_t v19 = v14 + 3;
        if (v14 + 3 >= v40) {
          goto LABEL_38;
        }
        unint64_t v18 = v41[v19];
        if (!v18) {
          break;
        }
      }
    }

void sub_1000D4304(uint64_t a1)
{
  uint64_t v2 = v1;
  uint64_t v3 = *v1;
  if (*(void *)(*v1 + 24) <= a1) {
    uint64_t v4 = a1;
  }
  else {
    uint64_t v4 = *(void *)(*v1 + 24);
  }
  sub_100002274((uint64_t *)&unk_100404AB0);
  uint64_t v5 = static _SetStorage.resize(original:capacity:move:)(v3, v4, 1LL);
  uint64_t v6 = v5;
  if (*(void *)(v3 + 16))
  {
    uint64_t v30 = v2;
    int64_t v7 = 0LL;
    uint64_t v8 = (void *)(v3 + 56);
    uint64_t v9 = 1LL << *(_BYTE *)(v3 + 32);
    if (v9 < 64) {
      uint64_t v10 = ~(-1LL << v9);
    }
    else {
      uint64_t v10 = -1LL;
    }
    unint64_t v11 = v10 & *(void *)(v3 + 56);
    int64_t v12 = (unint64_t)(v9 + 63) >> 6;
    uint64_t v13 = v5 + 56;
    while (1)
    {
      if (v11)
      {
        unint64_t v15 = __clz(__rbit64(v11));
        v11 &= v11 - 1;
        unint64_t v16 = v15 | (v7 << 6);
      }

      else
      {
        int64_t v17 = v7 + 1;
        if (__OFADD__(v7, 1LL))
        {
LABEL_41:
          __break(1u);
LABEL_42:
          __break(1u);
          return;
        }

        if (v17 >= v12) {
          goto LABEL_36;
        }
        unint64_t v18 = v8[v17];
        ++v7;
        if (!v18)
        {
          int64_t v7 = v17 + 1;
          if (v17 + 1 >= v12) {
            goto LABEL_36;
          }
          unint64_t v18 = v8[v7];
          if (!v18)
          {
            int64_t v7 = v17 + 2;
            if (v17 + 2 >= v12) {
              goto LABEL_36;
            }
            unint64_t v18 = v8[v7];
            if (!v18)
            {
              int64_t v19 = v17 + 3;
              if (v19 >= v12)
              {
LABEL_36:
                uint64_t v29 = 1LL << *(_BYTE *)(v3 + 32);
                if (v29 > 63) {
                  bzero((void *)(v3 + 56), ((unint64_t)(v29 + 63) >> 3) & 0x1FFFFFFFFFFFFFF8LL);
                }
                else {
                  *uint64_t v8 = -1LL << v29;
                }
                uint64_t v2 = v30;
                *(void *)(v3 + 16)  = 0LL;
                break;
              }

              unint64_t v18 = v8[v19];
              if (!v18)
              {
                while (1)
                {
                  int64_t v7 = v19 + 1;
                  if (__OFADD__(v19, 1LL)) {
                    goto LABEL_42;
                  }
                  if (v7 >= v12) {
                    goto LABEL_36;
                  }
                  unint64_t v18 = v8[v7];
                  ++v19;
                  if (v18) {
                    goto LABEL_26;
                  }
                }
              }

              int64_t v7 = v19;
            }
          }
        }

uint64_t sub_1000D4598(uint64_t result, unint64_t a2, char a3)
{
  uint64_t v5 = result;
  unint64_t v6 = *(void *)(*v3 + 16);
  unint64_t v7 = *(void *)(*v3 + 24);
  if (v7 > v6 && (a3 & 1) != 0) {
    goto LABEL_14;
  }
  uint64_t v8 = v6 + 1;
  if ((a3 & 1) != 0)
  {
    sub_1000D3934(v8);
  }

  else
  {
    if (v7 > v6)
    {
      uint64_t result = (uint64_t)sub_10013ED54();
      goto LABEL_14;
    }

    sub_1000D4CF8(v8);
  }

  uint64_t v9 = *v3;
  uint64_t result = static Hasher._hash(seed:_:)(*(void *)(*v3 + 40), v5);
  uint64_t v10 = -1LL << *(_BYTE *)(v9 + 32);
  a2  = result & ~v10;
  if (((*(void *)(v9 + 56 + ((a2 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> a2) & 1) != 0)
  {
    uint64_t v11 = *(void *)(v9 + 48);
    if (*(void *)(v11 + 8 * a2) == v5)
    {
LABEL_13:
      uint64_t result = ELEMENT_TYPE_OF_SET_VIOLATES_HASHABLE_REQUIREMENTS(_:)(&type metadata for UInt64);
      __break(1u);
    }

    else
    {
      uint64_t v12 = ~v10;
      while (1)
      {
        a2  = (a2 + 1) & v12;
        if (((*(void *)(v9 + 56 + ((a2 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> a2) & 1) == 0) {
          break;
        }
        if (*(void *)(v11 + 8 * a2) == v5) {
          goto LABEL_13;
        }
      }
    }
  }

void sub_1000D46B8(uint64_t a1, unint64_t a2, char a3)
{
  uint64_t v4 = (uint64_t *)v3;
  unint64_t v7 = *(void *)(*(void *)v3 + 16LL);
  unint64_t v8 = *(void *)(*(void *)v3 + 24LL);
  if (v8 > v7 && (a3 & 1) != 0) {
    goto LABEL_22;
  }
  uint64_t v9 = v7 + 1;
  if ((a3 & 1) != 0)
  {
    sub_1000D3BB4(v9);
  }

  else
  {
    if (v8 > v7)
    {
      sub_10013EEE8();
LABEL_22:
      uint64_t v31 = *v4;
      *(void *)(*v4 + 8 * (a2 >> 6) + 56) |= 1LL << a2;
      *(void *)(*(void *)(v31 + 48) + 8 * a2)  = a1;
      uint64_t v32 = *(void *)(v31 + 16);
      BOOL v33 = __OFADD__(v32, 1LL);
      uint64_t v34 = v32 + 1;
      if (!v33)
      {
        *(void *)(v31 + 16)  = v34;
        return;
      }

      __break(1u);
      goto LABEL_25;
    }

    sub_1000D4F58(v9);
  }

  uint64_t v10 = *(void *)v3;
  uint64_t v11 = *(void *)(*(void *)v3 + 40LL);
  uint64_t v12 = static String._unconditionallyBridgeFromObjectiveC(_:)(a1);
  uint64_t v14 = v13;
  Hasher.init(_seed:)(v36, v11);
  String.hash(into:)(v36, v12, v14);
  Swift::Int v3 = Hasher._finalize()();
  swift_bridgeObjectRelease(v14);
  uint64_t v15 = -1LL << *(_BYTE *)(v10 + 32);
  a2  = v3 & ~v15;
  if (((*(void *)(v10 + 56 + ((a2 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> a2) & 1) == 0) {
    goto LABEL_22;
  }
  uint64_t v16 = static String._unconditionallyBridgeFromObjectiveC(_:)(*(void *)(*(void *)(v10 + 48) + 8 * a2));
  Swift::Int v3 = v17;
  uint64_t v18 = static String._unconditionallyBridgeFromObjectiveC(_:)(a1);
  if (v16 == v18 && v3 == v19)
  {
LABEL_25:
    swift_bridgeObjectRelease_n(v3, 2LL);
    goto LABEL_26;
  }

  uint64_t v21 = v19;
  char v22 = _stringCompareWithSmolCheck(_:_:expecting:)(v16, v3, v18, v19, 0LL);
  swift_bridgeObjectRelease(v3);
  swift_bridgeObjectRelease(v21);
  if ((v22 & 1) == 0)
  {
    uint64_t v23 = ~v15;
    do
    {
      a2  = (a2 + 1) & v23;
      if (((*(void *)(v10 + 56 + ((a2 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> a2) & 1) == 0) {
        goto LABEL_22;
      }
      uint64_t v24 = static String._unconditionallyBridgeFromObjectiveC(_:)(*(void *)(*(void *)(v10 + 48) + 8 * a2));
      Swift::Int v3 = v25;
      uint64_t v26 = static String._unconditionallyBridgeFromObjectiveC(_:)(a1);
      if (v24 == v26 && v3 == v27) {
        goto LABEL_25;
      }
      uint64_t v29 = v27;
      char v30 = _stringCompareWithSmolCheck(_:_:expecting:)(v24, v3, v26, v27, 0LL);
      swift_bridgeObjectRelease(v3);
      swift_bridgeObjectRelease(v29);
    }

    while ((v30 & 1) == 0);
  }

uint64_t sub_1000D48E4(uint64_t a1, unint64_t a2, char a3)
{
  uint64_t v7 = type metadata accessor for AWDLPeer.AdvertisedService(0LL);
  uint64_t v8 = *(void *)(v7 - 8);
  __chkstk_darwin();
  uint64_t v10 = (char *)&v36 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  unint64_t v11 = *(void *)(*v3 + 16);
  unint64_t v12 = *(void *)(*v3 + 24);
  uint64_t v38 = v8;
  uint64_t v39 = v3;
  if (v12 > v11 && (a3 & 1) != 0) {
    goto LABEL_25;
  }
  uint64_t v13 = v11 + 1;
  if ((a3 & 1) != 0)
  {
    sub_1000D3EC4(v13);
  }

  else
  {
    if (v12 > v11)
    {
      sub_10013F090();
      goto LABEL_25;
    }

    sub_1000D5234(v13);
  }

  uint64_t v14 = *v3;
  Hasher.init(_seed:)(&v50, *(void *)(*v3 + 40));
  AWDLPeer.AdvertisedService.hash(into:)((uint64_t)&v50);
  Swift::Int v15 = Hasher._finalize()();
  uint64_t v16 = -1LL << *(_BYTE *)(v14 + 32);
  a2  = v15 & ~v16;
  uint64_t v42 = v14 + 56;
  uint64_t v43 = v14;
  if (((*(void *)(v14 + 56 + ((a2 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> a2) & 1) != 0)
  {
    uint64_t v37 = v7;
    uint64_t v41 = ~v16;
    uint64_t v40 = *(void *)(v8 + 72);
    Swift::Int v17 = type metadata accessor for AWDLPeer.AdvertisedService;
    while (1)
    {
      uint64_t v18 = v17;
      sub_100057FE8(*(void *)(v43 + 48) + v40 * a2, (uint64_t)v10, v17);
      uint64_t v19 = *((void *)v10 + 1);
      uint64_t v20 = *((void *)v10 + 2);
      uint64_t v21 = *((void *)v10 + 3);
      uint64_t v22 = *((void *)v10 + 4);
      int v47 = v10[40];
      int v45 = v10[41];
      uint64_t v23 = *(void *)(a1 + 8);
      uint64_t v24 = *(void *)(a1 + 16);
      uint64_t v25 = *(void *)(a1 + 24);
      uint64_t v26 = *(void *)(a1 + 32);
      int v46 = *(unsigned __int8 *)(a1 + 40);
      int v44 = *(unsigned __int8 *)(a1 + 41);
      uint64_t v50 = v19;
      uint64_t v51 = v20;
      uint64_t v48 = v23;
      uint64_t v49 = v24;
      unint64_t v27 = sub_10000B08C();
      if (StringProtocol.caseInsensitiveCompare<A>(_:)( &v48,  &type metadata for String,  &type metadata for String,  v27,  v27))
      {
        break;
      }

      uint64_t v50 = v21;
      uint64_t v51 = v22;
      uint64_t v48 = v25;
      uint64_t v49 = v26;
      if (StringProtocol.caseInsensitiveCompare<A>(_:)( &v48,  &type metadata for String,  &type metadata for String,  v27,  v27))
      {
        break;
      }

      if (v47) {
        uint64_t v28 = 7365749LL;
      }
      else {
        uint64_t v28 = 7365492LL;
      }
      if (v46) {
        uint64_t v29 = 7365749LL;
      }
      else {
        uint64_t v29 = 7365492LL;
      }
      if (v28 == v29)
      {
        swift_bridgeObjectRelease_n(0xE300000000000000LL, 2LL);
      }

      else
      {
        char v30 = _stringCompareWithSmolCheck(_:_:expecting:)(v28, 0xE300000000000000LL, v29, 0xE300000000000000LL, 0LL);
        swift_bridgeObjectRelease_n(0xE300000000000000LL, 2LL);
        if ((v30 & 1) == 0) {
          break;
        }
      }

      Swift::Int v17 = v18;
      sub_10005802C((uint64_t)v10, v18);
      if (v45 == v44)
      {
        ELEMENT_TYPE_OF_SET_VIOLATES_HASHABLE_REQUIREMENTS(_:)(v37);
        __break(1u);
        goto LABEL_25;
      }

uint64_t sub_1000D4BD4(uint64_t result, unint64_t a2, char a3)
{
  uint64_t v5 = result;
  unint64_t v6 = *(void *)(*v3 + 16);
  unint64_t v7 = *(void *)(*v3 + 24);
  if (v7 > v6 && (a3 & 1) != 0) {
    goto LABEL_14;
  }
  uint64_t v8 = v6 + 1;
  if ((a3 & 1) != 0)
  {
    sub_1000D4304(v8);
  }

  else
  {
    if (v7 > v6)
    {
      uint64_t result = (uint64_t)sub_10013F2B0();
      goto LABEL_14;
    }

    sub_1000D5640(v8);
  }

  uint64_t v9 = *v3;
  uint64_t result = static Hasher._hash(seed:bytes:count:)(*(void *)(*v3 + 40), v5, 1LL);
  uint64_t v10 = -1LL << *(_BYTE *)(v9 + 32);
  a2  = result & ~v10;
  if (((*(void *)(v9 + 56 + ((a2 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> a2) & 1) != 0)
  {
    uint64_t v11 = *(void *)(v9 + 48);
    if (*(unsigned __int8 *)(v11 + a2) == (_DWORD)v5)
    {
LABEL_13:
      uint64_t result = ELEMENT_TYPE_OF_SET_VIOLATES_HASHABLE_REQUIREMENTS(_:)(&type metadata for UInt8);
      __break(1u);
    }

    else
    {
      uint64_t v12 = ~v10;
      while (1)
      {
        a2  = (a2 + 1) & v12;
        if (((*(void *)(v9 + 56 + ((a2 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> a2) & 1) == 0) {
          break;
        }
      }
    }
  }

uint64_t sub_1000D4CF8(uint64_t a1)
{
  uint64_t v2 = v1;
  uint64_t v3 = *v1;
  if (*(void *)(*v1 + 24) <= a1) {
    uint64_t v4 = a1;
  }
  else {
    uint64_t v4 = *(void *)(*v1 + 24);
  }
  sub_100002274(&qword_100407CB0);
  uint64_t result = static _SetStorage.resize(original:capacity:move:)(v3, v4, 0LL);
  uint64_t v6 = result;
  if (!*(void *)(v3 + 16))
  {
    uint64_t result = swift_release(v3);
LABEL_38:
    *uint64_t v2 = v6;
    return result;
  }

  uint64_t v28 = v2;
  int64_t v7 = 0LL;
  uint64_t v8 = v3 + 56;
  uint64_t v9 = 1LL << *(_BYTE *)(v3 + 32);
  if (v9 < 64) {
    uint64_t v10 = ~(-1LL << v9);
  }
  else {
    uint64_t v10 = -1LL;
  }
  unint64_t v11 = v10 & *(void *)(v3 + 56);
  int64_t v12 = (unint64_t)(v9 + 63) >> 6;
  uint64_t v13 = result + 56;
  while (1)
  {
    if (v11)
    {
      unint64_t v15 = __clz(__rbit64(v11));
      v11 &= v11 - 1;
      unint64_t v16 = v15 | (v7 << 6);
      goto LABEL_27;
    }

    int64_t v17 = v7 + 1;
    if (__OFADD__(v7, 1LL))
    {
LABEL_39:
      __break(1u);
      goto LABEL_40;
    }

    if (v17 >= v12) {
      goto LABEL_36;
    }
    unint64_t v18 = *(void *)(v8 + 8 * v17);
    ++v7;
    if (!v18)
    {
      int64_t v7 = v17 + 1;
      if (v17 + 1 >= v12) {
        goto LABEL_36;
      }
      unint64_t v18 = *(void *)(v8 + 8 * v7);
      if (!v18)
      {
        int64_t v7 = v17 + 2;
        if (v17 + 2 >= v12) {
          goto LABEL_36;
        }
        unint64_t v18 = *(void *)(v8 + 8 * v7);
        if (!v18) {
          break;
        }
      }
    }

void sub_1000D4F58(uint64_t a1)
{
  uint64_t v2 = v1;
  uint64_t v3 = *v1;
  if (*(void *)(*v1 + 24) <= a1) {
    uint64_t v4 = a1;
  }
  else {
    uint64_t v4 = *(void *)(*v1 + 24);
  }
  sub_100002274(&qword_100407D18);
  uint64_t v5 = static _SetStorage.resize(original:capacity:move:)(v3, v4, 0LL);
  uint64_t v6 = v5;
  if (!*(void *)(v3 + 16))
  {
    swift_release(v3);
LABEL_38:
    *uint64_t v2 = v6;
    return;
  }

  uint64_t v7 = 1LL << *(_BYTE *)(v3 + 32);
  uint64_t v32 = v2;
  uint64_t v33 = v3 + 56;
  if (v7 < 64) {
    uint64_t v8 = ~(-1LL << v7);
  }
  else {
    uint64_t v8 = -1LL;
  }
  unint64_t v9 = v8 & *(void *)(v3 + 56);
  int64_t v34 = (unint64_t)(v7 + 63) >> 6;
  uint64_t v10 = v5 + 56;
  swift_retain();
  int64_t v11 = 0LL;
  while (1)
  {
    if (v9)
    {
      unint64_t v13 = __clz(__rbit64(v9));
      v9 &= v9 - 1;
      unint64_t v14 = v13 | (v11 << 6);
      goto LABEL_27;
    }

    int64_t v15 = v11 + 1;
    if (__OFADD__(v11, 1LL))
    {
LABEL_39:
      __break(1u);
      goto LABEL_40;
    }

    if (v15 >= v34) {
      goto LABEL_36;
    }
    unint64_t v16 = *(void *)(v33 + 8 * v15);
    ++v11;
    if (!v16)
    {
      int64_t v11 = v15 + 1;
      if (v15 + 1 >= v34) {
        goto LABEL_36;
      }
      unint64_t v16 = *(void *)(v33 + 8 * v11);
      if (!v16)
      {
        int64_t v11 = v15 + 2;
        if (v15 + 2 >= v34) {
          goto LABEL_36;
        }
        unint64_t v16 = *(void *)(v33 + 8 * v11);
        if (!v16) {
          break;
        }
      }
    }

void sub_1000D5234(uint64_t a1)
{
  uint64_t v2 = v1;
  uint64_t v42 = *(void *)(type metadata accessor for AWDLPeer.AdvertisedService(0LL) - 8);
  __chkstk_darwin();
  uint64_t v5 = (char *)&v37 - ((v4 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v6 = *v2;
  if (*(void *)(*v2 + 24) > a1) {
    a1  = *(void *)(*v2 + 24);
  }
  sub_100002274((uint64_t *)&unk_10040ECF0);
  uint64_t v7 = static _SetStorage.resize(original:capacity:move:)(v6, a1, 0LL);
  uint64_t v8 = v7;
  if (!*(void *)(v6 + 16))
  {
    swift_release(v6);
LABEL_40:
    *uint64_t v2 = v8;
    return;
  }

  uint64_t v9 = 1LL << *(_BYTE *)(v6 + 32);
  uint64_t v10 = *(void *)(v6 + 56);
  uint64_t v38 = v2;
  uint64_t v39 = v6 + 56;
  if (v9 < 64) {
    uint64_t v11 = ~(-1LL << v9);
  }
  else {
    uint64_t v11 = -1LL;
  }
  unint64_t v12 = v11 & v10;
  int64_t v40 = (unint64_t)(v9 + 63) >> 6;
  uint64_t v13 = v7 + 56;
  swift_retain();
  int64_t v14 = 0LL;
  uint64_t v41 = v6;
  while (1)
  {
    if (v12)
    {
      int64_t v44 = v14;
      uint64_t v45 = (v12 - 1) & v12;
      unint64_t v16 = __clz(__rbit64(v12)) | (v14 << 6);
      goto LABEL_26;
    }

    int64_t v17 = v14 + 1;
    if (__OFADD__(v14, 1LL))
    {
LABEL_41:
      __break(1u);
      goto LABEL_42;
    }

    if (v17 >= v40) {
      goto LABEL_38;
    }
    unint64_t v18 = *(void *)(v39 + 8 * v17);
    int64_t v19 = v14 + 1;
    if (!v18)
    {
      int64_t v19 = v14 + 2;
      if (v14 + 2 >= v40) {
        goto LABEL_38;
      }
      unint64_t v18 = *(void *)(v39 + 8 * v19);
      if (!v18)
      {
        int64_t v19 = v14 + 3;
        if (v14 + 3 >= v40) {
          goto LABEL_38;
        }
        unint64_t v18 = *(void *)(v39 + 8 * v19);
        if (!v18) {
          break;
        }
      }
    }

void sub_1000D5640(uint64_t a1)
{
  uint64_t v2 = v1;
  uint64_t v3 = *v1;
  if (*(void *)(*v1 + 24) <= a1) {
    uint64_t v4 = a1;
  }
  else {
    uint64_t v4 = *(void *)(*v1 + 24);
  }
  sub_100002274((uint64_t *)&unk_100404AB0);
  uint64_t v5 = static _SetStorage.resize(original:capacity:move:)(v3, v4, 0LL);
  uint64_t v6 = v5;
  if (!*(void *)(v3 + 16))
  {
    swift_release(v3);
LABEL_38:
    *uint64_t v2 = v6;
    return;
  }

  Swift::Int v29 = v2;
  int64_t v7 = 0LL;
  uint64_t v8 = v3 + 56;
  uint64_t v9 = 1LL << *(_BYTE *)(v3 + 32);
  if (v9 < 64) {
    uint64_t v10 = ~(-1LL << v9);
  }
  else {
    uint64_t v10 = -1LL;
  }
  unint64_t v11 = v10 & *(void *)(v3 + 56);
  int64_t v12 = (unint64_t)(v9 + 63) >> 6;
  uint64_t v13 = v5 + 56;
  while (1)
  {
    if (v11)
    {
      unint64_t v15 = __clz(__rbit64(v11));
      v11 &= v11 - 1;
      unint64_t v16 = v15 | (v7 << 6);
      goto LABEL_27;
    }

    int64_t v17 = v7 + 1;
    if (__OFADD__(v7, 1LL))
    {
LABEL_39:
      __break(1u);
      goto LABEL_40;
    }

    if (v17 >= v12) {
      goto LABEL_36;
    }
    unint64_t v18 = *(void *)(v8 + 8 * v17);
    ++v7;
    if (!v18)
    {
      int64_t v7 = v17 + 1;
      if (v17 + 1 >= v12) {
        goto LABEL_36;
      }
      unint64_t v18 = *(void *)(v8 + 8 * v7);
      if (!v18)
      {
        int64_t v7 = v17 + 2;
        if (v17 + 2 >= v12) {
          goto LABEL_36;
        }
        unint64_t v18 = *(void *)(v8 + 8 * v7);
        if (!v18) {
          break;
        }
      }
    }

uint64_t _s7CoreP2P15AWDLActionFrameV15ServiceResponseO21__derived_enum_equalsySbAE_AEtFZ_0( uint64_t a1, uint64_t a2)
{
  uint64_t v77 = (int *)type metadata accessor for DNSRecords.SRV(0LL);
  __chkstk_darwin(v77);
  uint64_t v5 = (char *)&v71 - ((v4 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v6 = type metadata accessor for AWDLActionFrame.ServiceResponse(0LL);
  uint64_t v7 = __chkstk_darwin(v6);
  uint64_t v9 = (char *)&v71 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v10 = __chkstk_darwin(v7);
  int64_t v12 = (char *)&v71 - v11;
  __chkstk_darwin(v10);
  unint64_t v14 = (char *)&v71 - v13;
  uint64_t v15 = sub_100002274(&qword_100407DE8);
  uint64_t v16 = __chkstk_darwin(v15);
  unint64_t v18 = (char *)&v71 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v19 = (uint64_t)&v18[*(int *)(v16 + 48)];
  sub_100057FE8(a1, (uint64_t)v18, type metadata accessor for AWDLActionFrame.ServiceResponse);
  sub_100057FE8(a2, v19, type metadata accessor for AWDLActionFrame.ServiceResponse);
  int EnumCaseMultiPayload = swift_getEnumCaseMultiPayload(v18, v6);
  if (EnumCaseMultiPayload)
  {
    if (EnumCaseMultiPayload == 1)
    {
      sub_100057FE8((uint64_t)v18, (uint64_t)v12, type metadata accessor for AWDLActionFrame.ServiceResponse);
      uint64_t v21 = *((void *)v12 + 1);
      uint64_t v77 = (int *)*((void *)v12 + 2);
      uint64_t v22 = *((void *)v12 + 3);
      __int16 v23 = v12[32];
      __int16 v24 = v12[33];
      uint64_t v26 = *((void *)v12 + 5);
      unint64_t v25 = *((void *)v12 + 6);
      if (swift_getEnumCaseMultiPayload(v19, v6) == 1)
      {
        uint64_t v75 = v26;
        unint64_t v76 = v25;
        uint64_t v27 = *(void *)v12;
        uint64_t v28 = *(void *)v19;
        uint64_t v29 = *(void *)(v19 + 8);
        uint64_t v30 = *(void *)(v19 + 24);
        uint64_t v74 = *(void *)(v19 + 16);
        int v31 = *(unsigned __int8 *)(v19 + 32);
        int v72 = *(unsigned __int8 *)(v19 + 33);
        int v73 = v31;
        uint64_t v33 = *(void *)(v19 + 40);
        unint64_t v32 = *(void *)(v19 + 48);
        uint64_t v80 = v27;
        uint64_t v81 = v21;
        uint64_t v78 = v28;
        uint64_t v79 = v29;
        unint64_t v34 = sub_10000B08C();
        if (!StringProtocol.caseInsensitiveCompare<A>(_:)( &v78,  &type metadata for String,  &type metadata for String,  v34,  v34)
          && sub_1000FAC64((uint64_t)v77, v22, v23 | (v24 << 8), v74, v30, v73 | ((_WORD)v72 << 8)))
        {
          uint64_t v36 = v75;
          unint64_t v35 = v76;
          _s7CoreP2P6NANPMKV23__derived_struct_equalsySbAC_ACtFZ_0(v75, v76);
          char v38 = v37;
          swift_bridgeObjectRelease(v30);
          swift_bridgeObjectRelease(v29);
          sub_1000208D8(v33, v32);
          swift_bridgeObjectRelease(v22);
          swift_bridgeObjectRelease(v21);
          sub_1000208D8(v36, v35);
          if ((v38 & 1) == 0) {
            goto LABEL_29;
          }
LABEL_28:
          sub_10005802C((uint64_t)v18, type metadata accessor for AWDLActionFrame.ServiceResponse);
          return 1LL;
        }

        swift_bridgeObjectRelease(v30);
        swift_bridgeObjectRelease(v29);
        sub_1000208D8(v33, v32);
        swift_bridgeObjectRelease(v22);
        swift_bridgeObjectRelease(v21);
        sub_1000208D8(v75, v76);
        goto LABEL_29;
      }

      swift_bridgeObjectRelease(v22);
      swift_bridgeObjectRelease(v21);
      sub_1000208D8(v26, v25);
    }

    else
    {
      sub_100057FE8((uint64_t)v18, (uint64_t)v9, type metadata accessor for AWDLActionFrame.ServiceResponse);
      if (swift_getEnumCaseMultiPayload(v19, v6) == 2)
      {
        sub_100022628(v19, (uint64_t)v5, type metadata accessor for DNSRecords.SRV);
        uint64_t v44 = *(void *)v9;
        uint64_t v45 = *((void *)v9 + 1);
        unint64_t v46 = *((void *)v9 + 2);
        uint64_t v75 = *((void *)v9 + 3);
        unint64_t v76 = v46;
        __int16 v47 = v9[32];
        __int16 v48 = v9[33];
        uint64_t v49 = *(void *)v5;
        uint64_t v50 = *((void *)v5 + 1);
        uint64_t v51 = *((void *)v5 + 2);
        uint64_t v52 = *((void *)v5 + 3);
        __int16 v53 = v5[32];
        __int16 v54 = v5[33];
        uint64_t v80 = v44;
        uint64_t v81 = v45;
        uint64_t v78 = v49;
        uint64_t v79 = v50;
        unint64_t v55 = sub_10000B08C();
        if (!StringProtocol.caseInsensitiveCompare<A>(_:)( &v78,  &type metadata for String,  &type metadata for String,  v55,  v55)
          && sub_1000FAC64(v76, v75, v47 | (v48 << 8), v51, v52, v53 | (v54 << 8)))
        {
          uint64_t v56 = type metadata accessor for NWEndpoint.Port(0LL);
          uint64_t v57 = sub_10000AF70( &qword_100406350,  (uint64_t (*)(uint64_t))&type metadata accessor for NWEndpoint.Port,  (uint64_t)&protocol conformance descriptor for NWEndpoint.Port);
          dispatch thunk of RawRepresentable.rawValue.getter(v56, v57);
          dispatch thunk of RawRepresentable.rawValue.getter(v56, v57);
          if ((unsigned __int16)v80 == (unsigned __int16)v78)
          {
            if ((uint64_t v58 = v77[6],
                  uint64_t v59 = *(void *)&v9[v58],
                  uint64_t v60 = *(void *)&v9[v58 + 8],
                  uint64_t v61 = &v5[v58],
                  uint64_t v62 = *((void *)v61 + 1),
                  v59 == *(void *)v61)
              && v60 == v62
              || (_stringCompareWithSmolCheck(_:_:expecting:)(v59, v60, *(void *)v61, v62, 0LL) & 1) != 0)
            {
              if (*(unsigned __int16 *)&v9[v77[7]] == *(unsigned __int16 *)&v5[v77[7]]
                && *(unsigned __int16 *)&v9[v77[8]] == *(unsigned __int16 *)&v5[v77[8]])
              {
                sub_10005802C((uint64_t)v5, type metadata accessor for DNSRecords.SRV);
                sub_10005802C((uint64_t)v9, type metadata accessor for DNSRecords.SRV);
                goto LABEL_28;
              }
            }
          }
        }

        sub_10005802C((uint64_t)v5, type metadata accessor for DNSRecords.SRV);
        sub_10005802C((uint64_t)v9, type metadata accessor for DNSRecords.SRV);
LABEL_29:
        sub_10005802C((uint64_t)v18, type metadata accessor for AWDLActionFrame.ServiceResponse);
        return 0LL;
      }

      sub_10005802C((uint64_t)v9, type metadata accessor for DNSRecords.SRV);
    }
  }

  else
  {
    sub_100057FE8((uint64_t)v18, (uint64_t)v14, type metadata accessor for AWDLActionFrame.ServiceResponse);
    uint64_t v39 = *((void *)v14 + 1);
    uint64_t v40 = *((void *)v14 + 2);
    uint64_t v41 = *((void *)v14 + 3);
    __int16 v42 = v14[32];
    __int16 v43 = v14[33];
    if (!swift_getEnumCaseMultiPayload(v19, v6))
    {
      uint64_t v63 = *(void *)v14;
      uint64_t v64 = *(void *)v19;
      uint64_t v65 = *(void *)(v19 + 8);
      uint64_t v66 = *(void *)(v19 + 24);
      uint64_t v77 = *(int **)(v19 + 16);
      uint64_t v78 = v64;
      LODWORD(v76)  = *(unsigned __int8 *)(v19 + 32);
      __int16 v67 = *(unsigned __int8 *)(v19 + 33);
      uint64_t v80 = v63;
      uint64_t v81 = v39;
      uint64_t v79 = v65;
      unint64_t v68 = sub_10000B08C();
      if (StringProtocol.caseInsensitiveCompare<A>(_:)( &v78,  &type metadata for String,  &type metadata for String,  v68,  v68))
      {
        swift_bridgeObjectRelease(v66);
        swift_bridgeObjectRelease(v65);
        swift_bridgeObjectRelease(v41);
        swift_bridgeObjectRelease(v39);
      }

      else
      {
        BOOL v69 = sub_1000FAC64(v40, v41, v42 | (v43 << 8), (uint64_t)v77, v66, v76 | (v67 << 8));
        swift_bridgeObjectRelease(v66);
        swift_bridgeObjectRelease(v65);
        swift_bridgeObjectRelease(v41);
        swift_bridgeObjectRelease(v39);
        if (v69) {
          goto LABEL_28;
        }
      }

      goto LABEL_29;
    }

    swift_bridgeObjectRelease(v41);
    swift_bridgeObjectRelease(v39);
  }

  sub_1000225EC((uint64_t)v18, &qword_100407DE8);
  return 0LL;
}

uint64_t _s7CoreP2P15AWDLActionFrameV24SynchronizationParameterV23__derived_struct_equalsySbAE_AEtFZ_0( unsigned __int8 *a1, unsigned __int8 *a2)
{
  if (*a1 == *a2
    && *((unsigned __int16 *)a1 + 1) == *((unsigned __int16 *)a2 + 1)
    && a1[4] == a2[4]
    && a1[5] == a2[5]
    && *((unsigned __int16 *)a1 + 3) == *((unsigned __int16 *)a2 + 3)
    && *((unsigned __int16 *)a1 + 4) == *((unsigned __int16 *)a2 + 4)
    && *((unsigned __int16 *)a1 + 5) == *((unsigned __int16 *)a2 + 5)
    && *((unsigned __int16 *)a1 + 6) == *((unsigned __int16 *)a2 + 6)
    && *((unsigned __int16 *)a1 + 7) == *((unsigned __int16 *)a2 + 7)
    && *((unsigned __int16 *)a1 + 8) == *((unsigned __int16 *)a2 + 8)
    && a1[18] == a2[18]
    && a1[19] == a2[19]
    && a1[20] == a2[20]
    && a1[21] == a2[21]
    && (*(_DWORD *)(a1 + 22) == *(_DWORD *)(a2 + 22)
      ? (BOOL v2 = *((unsigned __int16 *)a1 + 13) == *((unsigned __int16 *)a2 + 13))
      : (BOOL v2 = 0),
        v2
     && a1[28] == a2[28]
     && a1[29] == a2[29]
     && *((unsigned __int16 *)a1 + 15) == *((unsigned __int16 *)a2 + 15)
     && *((unsigned __int16 *)a1 + 16) == *((unsigned __int16 *)a2 + 16)))
  {
    return _s7CoreP2P15AWDLActionFrameV28AWDLChannelSequenceParameterV23__derived_struct_equalsySbAE_AEtFZ_0( *((void *)a1 + 5),  *((void *)a2 + 5));
  }

  else
  {
    return 0LL;
  }

uint64_t _s7CoreP2P15AWDLActionFrameV6HeaderV23__derived_struct_equalsySbAE_AEtFZ_0(uint64_t a1, uint64_t a2)
{
  BOOL v5 = *(_DWORD *)(a1 + 6) == *(_DWORD *)(a2 + 6) && *(unsigned __int16 *)(a1 + 10) == *(unsigned __int16 *)(a2 + 10);
  if (!v5
    || *(_DWORD *)(a1 + 12) != *(_DWORD *)(a2 + 12)
    || ((0x801004u >> (8 * *(_BYTE *)(a1 + 16))) & 0xFFC) != ((0x801004u >> (8 * *(_BYTE *)(a2 + 16))) & 0xFFC))
  {
    return 0LL;
  }

  int v6 = *(unsigned __int8 *)(a2 + 17);
  switch(*(_BYTE *)(a1 + 17))
  {
    case 2:
      if (v6 != 2) {
        return 0LL;
      }
      break;
    case 3:
      if (v6 != 3) {
        return 0LL;
      }
      break;
    case 4:
      if (v6 != 4) {
        return 0LL;
      }
      break;
    case 5:
      if (v6 != 5) {
        return 0LL;
      }
      break;
    case 6:
      if (v6 != 6) {
        return 0LL;
      }
      break;
    default:
      break;
  }

  if (*(_DWORD *)(a1 + 20) == *(_DWORD *)(a2 + 20)
    && (uint64_t v7 = (int *)type metadata accessor for AWDLActionFrame.Header(0LL),
        (static DispatchTimeInterval.== infix(_:_:)(a1 + v7[8], a2 + v7[8]) & 1) != 0)
    && (static DispatchTimeInterval.== infix(_:_:)(a1 + v7[9], a2 + v7[9]) & 1) != 0
    && *(_DWORD *)(a1 + v7[10]) == *(_DWORD *)(a2 + v7[10])
    && *(_DWORD *)(a1 + v7[11]) == *(_DWORD *)(a2 + v7[11])
    && *(void *)(a1 + v7[12]) == *(void *)(a2 + v7[12])
    && *(_DWORD *)(a1 + v7[13]) == *(_DWORD *)(a2 + v7[13])
    && *(void *)(a1 + v7[14]) == *(void *)(a2 + v7[14])
    && *(_DWORD *)(a1 + v7[15]) == *(_DWORD *)(a2 + v7[15]))
  {
    return sub_10007990C(*(void *)(a1 + v7[16]), *(void *)(a2 + v7[16]));
  }

  else
  {
    return 0LL;
  }

BOOL _s7CoreP2P15AWDLActionFrameV13RealtimeGroupV23__derived_struct_equalsySbAE_AEtFZ_0( unsigned __int8 *a1, unsigned __int8 *a2)
{
  if (*a1 != *a2) {
    return 0LL;
  }
  unint64_t v4 = *((unsigned int *)a1 + 2) | ((unint64_t)*((unsigned __int16 *)a1 + 6) << 32);
  unint64_t v5 = *((unsigned int *)a2 + 2) | ((unint64_t)*((unsigned __int16 *)a2 + 6) << 32);
  uint64_t v6 = v5 & 0xFF00000000LL;
  if ((v4 & 0xFF00000000LL) != 0x300000000LL)
  {
    if (v6 != 0x300000000LL
      && *((_DWORD *)a1 + 2) == *((_DWORD *)a2 + 2)
      && ((0x801004u >> ((v4 >> 29) & 0xF8)) & 0xFFC) == ((0x801004u >> ((v5 >> 29) & 0xF8)) & 0xFFC))
    {
      unint64_t v11 = v5 >> 40;
      switch(v4 >> 40)
      {
        case 2uLL:
          if ((_DWORD)v11 == 2) {
            goto LABEL_9;
          }
          return 0LL;
        case 3uLL:
          if ((_DWORD)v11 == 3) {
            goto LABEL_9;
          }
          return 0LL;
        case 4uLL:
          if ((_DWORD)v11 == 4) {
            goto LABEL_9;
          }
          return 0LL;
        case 5uLL:
          if ((_DWORD)v11 == 5) {
            goto LABEL_9;
          }
          return 0LL;
        case 6uLL:
          if ((_DWORD)v11 == 6) {
            goto LABEL_9;
          }
          return 0LL;
        default:
          return 0LL;
      }
    }

    return 0LL;
  }

  if (v6 != 0x300000000LL) {
    return 0LL;
  }
LABEL_9:
  if (*((void *)a1 + 2) != *((void *)a2 + 2) || a1[24] != a2[24]) {
    return 0LL;
  }
  unint64_t v7 = *((unsigned int *)a1 + 7) | ((unint64_t)*((unsigned __int16 *)a1 + 16) << 32);
  unint64_t v8 = *((unsigned int *)a2 + 7) | ((unint64_t)*((unsigned __int16 *)a2 + 16) << 32);
  uint64_t v9 = v8 & 0xFF00000000LL;
  if ((v7 & 0xFF00000000LL) != 0x300000000LL)
  {
    if (v9 != 0x300000000LL
      && *((_DWORD *)a1 + 7) == *((_DWORD *)a2 + 7)
      && ((0x801004u >> ((v7 >> 29) & 0xF8)) & 0xFFC) == ((0x801004u >> ((v8 >> 29) & 0xF8)) & 0xFFC))
    {
      unint64_t v12 = v8 >> 40;
      switch(v7 >> 40)
      {
        case 2uLL:
          if ((_DWORD)v12 == 2) {
            return *(_DWORD *)(a1 + 34) == *(_DWORD *)(a2 + 34)
          }
                && *((unsigned __int16 *)a1 + 19) == *((unsigned __int16 *)a2 + 19);
          return 0LL;
        case 3uLL:
          if ((_DWORD)v12 == 3) {
            return *(_DWORD *)(a1 + 34) == *(_DWORD *)(a2 + 34)
          }
                && *((unsigned __int16 *)a1 + 19) == *((unsigned __int16 *)a2 + 19);
          return 0LL;
        case 4uLL:
          if ((_DWORD)v12 == 4) {
            return *(_DWORD *)(a1 + 34) == *(_DWORD *)(a2 + 34)
          }
                && *((unsigned __int16 *)a1 + 19) == *((unsigned __int16 *)a2 + 19);
          return 0LL;
        case 5uLL:
          if ((_DWORD)v12 == 5) {
            return *(_DWORD *)(a1 + 34) == *(_DWORD *)(a2 + 34)
          }
                && *((unsigned __int16 *)a1 + 19) == *((unsigned __int16 *)a2 + 19);
          return 0LL;
        case 6uLL:
          if ((_DWORD)v12 == 6) {
            return *(_DWORD *)(a1 + 34) == *(_DWORD *)(a2 + 34)
          }
                && *((unsigned __int16 *)a1 + 19) == *((unsigned __int16 *)a2 + 19);
          return 0LL;
        default:
          if ((v12 - 2) >= 5 && ((v7 & 0x10000000000LL) == 0) != ((v8 >> 40) & 1)) {
            return *(_DWORD *)(a1 + 34) == *(_DWORD *)(a2 + 34)
          }
                && *((unsigned __int16 *)a1 + 19) == *((unsigned __int16 *)a2 + 19);
          return 0LL;
      }
    }

    return 0LL;
  }

  if (v9 != 0x300000000LL) {
    return 0LL;
  }
  return *(_DWORD *)(a1 + 34) == *(_DWORD *)(a2 + 34)
      && *((unsigned __int16 *)a1 + 19) == *((unsigned __int16 *)a2 + 19);
}

BOOL _s7CoreP2P15AWDLActionFrameV17ElectionParameterV23__derived_struct_equalsySbAE_AEtFZ_0( uint64_t a1, uint64_t a2)
{
  BOOL v2 = *(_DWORD *)a1 == *(_DWORD *)a2 && *(unsigned __int16 *)(a1 + 4) == *(unsigned __int16 *)(a2 + 4);
  if (v2
    && (*(_DWORD *)(a1 + 6) == *(_DWORD *)(a2 + 6)
      ? (BOOL v5 = *(unsigned __int16 *)(a1 + 10) == *(unsigned __int16 *)(a2 + 10))
      : (BOOL v5 = 0),
        v5
     && *(_DWORD *)(a1 + 12) == *(_DWORD *)(a2 + 12)
     && *(_DWORD *)(a1 + 16) == *(_DWORD *)(a2 + 16)
     && (sub_100144A10( *(unsigned int *)(a1 + 20) | ((unint64_t)*(unsigned __int8 *)(a1 + 24) << 32),  *(unsigned int *)(a2 + 20) | ((unint64_t)*(unsigned __int8 *)(a2 + 24) << 32)) & 1) != 0 && (sub_100144A10( *(unsigned int *)(a1 + 28) | ((unint64_t)*(unsigned __int8 *)(a1 + 32) << 32),  *(unsigned int *)(a2 + 28) | ((unint64_t)*(unsigned __int8 *)(a2 + 32) << 32)) & 1) != 0 && *(_DWORD *)(a1 + 36) == *(_DWORD *)(a2 + 36)
     && *(_DWORD *)(a1 + 40) == *(_DWORD *)(a2 + 40)))
  {
    return *(_DWORD *)(a1 + 44) == *(_DWORD *)(a2 + 44);
  }

  else
  {
    return 0LL;
  }

BOOL sub_1000D66BC(unint64_t a1, unint64_t a2)
{
  if ((_DWORD)a1 != (_DWORD)a2
    || ((0x801004u >> ((a1 >> 29) & 0xF8)) & 0xFFC) != ((0x801004u >> ((a2 >> 29) & 0xF8)) & 0xFFC))
  {
    return 0LL;
  }

  switch(BYTE5(a1))
  {
    case 2:
      if (BYTE5(a2) != 2) {
        return 0LL;
      }
      break;
    case 3:
      if (BYTE5(a2) != 3) {
        return 0LL;
      }
      break;
    case 4:
      if (BYTE5(a2) != 4) {
        return 0LL;
      }
      break;
    case 5:
      if (BYTE5(a2) != 5) {
        return 0LL;
      }
      break;
    case 6:
      if (BYTE5(a2) != 6) {
        return 0LL;
      }
      break;
    default:
      break;
  }

  return BYTE6(a1) == BYTE6(a2);
}

uint64_t sub_1000D679C(unint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  if ((_DWORD)a1 != (_DWORD)a3
    || ((0x801004u >> ((a1 >> 29) & 0xF8)) & 0xFFC) != ((0x801004u >> ((a3 >> 29) & 0xF8)) & 0xFFC))
  {
    return 0LL;
  }

  switch(BYTE5(a1))
  {
    case 2:
      if (BYTE5(a3) != 2) {
        return 0LL;
      }
      break;
    case 3:
      if (BYTE5(a3) != 3) {
        return 0LL;
      }
      break;
    case 4:
      if (BYTE5(a3) != 4) {
        return 0LL;
      }
      break;
    case 5:
      if (BYTE5(a3) != 5) {
        return 0LL;
      }
      break;
    case 6:
      if (BYTE5(a3) != 6) {
        return 0LL;
      }
      break;
    default:
      break;
  }

  return sub_10007A4D0(a2, a4);
}

BOOL _s7CoreP2P15AWDLActionFrameV18NANSynchronizationV23__derived_struct_equalsySbAE_AEtFZ_0( unsigned __int16 *a1, unsigned __int16 *a2)
{
  if (*a1 == *a2
    && (*(_DWORD *)(a1 + 1) == *(_DWORD *)(a2 + 1) ? (BOOL v2 = a1[3] == a2[3]) : (BOOL v2 = 0),
        v2
     && (*((_DWORD *)a1 + 2) == *((_DWORD *)a2 + 2) ? (BOOL v3 = a1[6] == a2[6]) : (BOOL v3 = 0),
         v3
      && *((void *)a1 + 2) == *((void *)a2 + 2)
      && *((unsigned __int8 *)a1 + 24) == *((unsigned __int8 *)a2 + 24)
      && *((unsigned __int8 *)a1 + 25) == *((unsigned __int8 *)a2 + 25)
      && (*(_DWORD *)(a1 + 13) == *(_DWORD *)(a2 + 13) ? (BOOL v4 = a1[15] == a2[15]) : (BOOL v4 = 0),
          v4
       && *((unsigned __int8 *)a1 + 32) == *((unsigned __int8 *)a2 + 32)
       && *((unsigned __int8 *)a1 + 33) == *((unsigned __int8 *)a2 + 33)
       && a1[17] == a2[17]))))
  {
    return *((_DWORD *)a1 + 9) == *((_DWORD *)a2 + 9);
  }

  else
  {
    return 0LL;
  }

uint64_t sub_1000D69AC( uint64_t a1, uint64_t a2, uint64_t a3, char a4, uint64_t a5, uint64_t a6, uint64_t a7, char a8)
{
  if (a1 != a5
    || WORD1(a1) != WORD1(a5)
    || BYTE4(a1) != BYTE4(a5)
    || BYTE5(a1) != BYTE5(a5))
  {
    return 0LL;
  }

  LOBYTE(v20)  = BYTE6(a1);
  BYTE1(v20)  = HIBYTE(a1);
  HIWORD(v20)  = a2;
  LOBYTE(v21)  = BYTE2(a2);
  HIBYTE(v21)  = BYTE3(a2);
  LOBYTE(v18)  = BYTE6(a5);
  BYTE1(v18)  = HIBYTE(a5);
  HIWORD(v18)  = a6;
  LOBYTE(v19)  = BYTE2(a6);
  HIBYTE(v19)  = BYTE3(a6);
  if (v20 != v18 || v21 != v19) {
    return 0LL;
  }
  *((void *)&v14 + 1)  = a3 & 1;
  *(void *)&__int128 v14 = a2;
  uint64_t v13 = v14 >> 32;
  *((void *)&v14 + 1)  = a7 & 1;
  *(void *)&__int128 v14 = a6;
  if ((sub_100144A10(v13, v14 >> 32) & 1) == 0) {
    return 0LL;
  }
  *((void *)&v16 + 1)  = a4 & 1;
  *(void *)&__int128 v16 = a3;
  uint64_t v15 = v16 >> 32;
  *((void *)&v16 + 1)  = a8 & 1;
  *(void *)&__int128 v16 = a7;
  return sub_100144A10(v15, v16 >> 32);
}

uint64_t sub_1000D6B34(uint64_t a1, int a2, uint64_t a3, unint64_t a4, int a5, uint64_t a6)
{
  if (a1 == a4
    && HIDWORD(a1) == HIDWORD(a4)
    && BYTE2(a1) == BYTE2(a4)
    && ((a1 & 0x100) == 0) != ((a4 >> 8) & 1)
    && a2 == a5)
  {
    return sub_10007E460(a3, a6);
  }

  else
  {
    return 0LL;
  }

uint64_t _s7CoreP2P15AWDLActionFrameV13DataPathStateV23__derived_struct_equalsySbAE_AEtFZ_0( unsigned __int16 *a1, unsigned __int16 *a2)
{
  uint64_t v4 = type metadata accessor for DispatchTimeInterval(0LL);
  uint64_t v5 = *(void *)(v4 - 8);
  __chkstk_darwin(v4);
  unint64_t v7 = (char *)&v81 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v8 = sub_100002274((uint64_t *)&unk_10040E3F0);
  __chkstk_darwin(v8);
  uint64_t v10 = (char *)&v81 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v11 = sub_100002274(&qword_100407450);
  uint64_t v12 = __chkstk_darwin(v11);
  __int128 v14 = (char *)&v81 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v15 = __chkstk_darwin(v12);
  uint64_t v17 = (char *)&v81 - v16;
  __chkstk_darwin(v15);
  __int16 v19 = (char *)&v81 - v18;
  char v20 = *((_BYTE *)a2 + 2);
  if ((a1[1] & 1) != 0)
  {
    if (!*((_BYTE *)a2 + 2)) {
      return 0LL;
    }
  }

  else
  {
    if (*a1 != *a2) {
      char v20 = 1;
    }
    if ((v20 & 1) != 0) {
      return 0LL;
    }
  }

  unint64_t v21 = *((unsigned int *)a1 + 1) | ((unint64_t)a1[4] << 32);
  unint64_t v22 = *((unsigned int *)a2 + 1) | ((unint64_t)a2[4] << 32);
  uint64_t v23 = v22 & 0xFF00000000LL;
  if ((v21 & 0xFF00000000LL) != 0x300000000LL)
  {
    if (v23 != 0x300000000LL
      && *((_DWORD *)a1 + 1) == *((_DWORD *)a2 + 1)
      && ((0x801004u >> ((v21 >> 29) & 0xF8)) & 0xFFC) == ((0x801004u >> ((v22 >> 29) & 0xF8)) & 0xFFC))
    {
      unint64_t v24 = v22 >> 40;
      switch(v21 >> 40)
      {
        case 2uLL:
          if ((_DWORD)v24 != 2) {
            return 0LL;
          }
          goto LABEL_9;
        case 3uLL:
          if ((_DWORD)v24 != 3) {
            return 0LL;
          }
          goto LABEL_9;
        case 4uLL:
          if ((_DWORD)v24 != 4) {
            return 0LL;
          }
          goto LABEL_9;
        case 5uLL:
          if ((_DWORD)v24 != 5) {
            return 0LL;
          }
          goto LABEL_9;
        case 6uLL:
          if ((_DWORD)v24 != 6) {
            return 0LL;
          }
          goto LABEL_9;
        default:
          goto LABEL_9;
      }
    }

    return 0LL;
  }

  if (v23 != 0x300000000LL) {
    return 0LL;
  }
LABEL_9:
  if ((a1[8] & 1) != 0)
  {
    if (!*((_BYTE *)a2 + 16)) {
      return 0LL;
    }
  }

  else
  {
    if ((a2[8] & 1) != 0) {
      return 0LL;
    }
    unint64_t v25 = *(unsigned int *)(a1 + 5) | ((unint64_t)a1[7] << 32);
    unint64_t v26 = *(unsigned int *)(a2 + 5) | ((unint64_t)a2[7] << 32);
    v27.i64[0]  = 0xFFFFFFFFFFFFLL;
    v27.i64[1]  = 0xFFFFFFFFFFFFLL;
    uint64x2_t v28 = (uint64x2_t)vandq_s8((int8x16_t)vdupq_n_s64(v25), v27);
    int16x8_t v29 = (int16x8_t)vshlq_u64(v28, (uint64x2_t)xmmword_10033A8F0);
    uint64x2_t v30 = (uint64x2_t)vandq_s8((int8x16_t)vdupq_n_s64(v26), v27);
    int64x2_t v31 = (int64x2_t)vshlq_u64(v30, (uint64x2_t)xmmword_10033A8F0);
    int16x8_t v32 = (int16x8_t)vshlq_u64(v30, (uint64x2_t)xmmword_10033A8E0);
    v85[0]  = *(_DWORD *)(a1 + 5);
    *(int32x2_t *)v28.i8  = vmovn_s64((int64x2_t)vshlq_u64(v28, (uint64x2_t)xmmword_10033A8E0));
    *(int32x2_t *)v29.i8  = vmovn_s64((int64x2_t)v29);
    v29.i16[1]  = v29.i16[2];
    v29.i16[2]  = v28.i16[0];
    v29.i16[3]  = v28.i16[2];
    *(_DWORD *)&v85[1]  = vmovn_s16(v29).u32[0];
    v85[5]  = BYTE5(v25);
    v84[0]  = v26;
    *(int32x2_t *)v28.i8  = vmovn_s64((int64x2_t)v32);
    *(int32x2_t *)v32.i8  = vmovn_s64(v31);
    v32.i16[1]  = v32.i16[2];
    v32.i16[2]  = v28.i16[0];
    v32.i16[3]  = v28.i16[2];
    *(_DWORD *)&v84[1]  = vmovn_s16(v32).u32[0];
    v84[5]  = BYTE5(v26);
  }

  unint64_t v34 = *((unsigned int *)a1 + 5) | ((unint64_t)a1[12] << 32);
  unint64_t v35 = *((unsigned int *)a2 + 5) | ((unint64_t)a2[12] << 32);
  uint64_t v36 = v35 & 0xFF00000000LL;
  if ((v34 & 0xFF00000000LL) != 0x300000000LL)
  {
    if (v36 != 0x300000000LL
      && *((_DWORD *)a1 + 5) == *((_DWORD *)a2 + 5)
      && ((0x801004u >> ((v34 >> 29) & 0xF8)) & 0xFFC) == ((0x801004u >> ((v35 >> 29) & 0xF8)) & 0xFFC))
    {
      unint64_t v37 = v35 >> 40;
      switch(v34 >> 40)
      {
        case 2uLL:
          if ((_DWORD)v37 != 2) {
            return 0LL;
          }
          goto LABEL_26;
        case 3uLL:
          if ((_DWORD)v37 != 3) {
            return 0LL;
          }
          goto LABEL_26;
        case 4uLL:
          if ((_DWORD)v37 != 4) {
            return 0LL;
          }
          goto LABEL_26;
        case 5uLL:
          if ((_DWORD)v37 != 5) {
            return 0LL;
          }
          goto LABEL_26;
        case 6uLL:
          if ((_DWORD)v37 != 6) {
            return 0LL;
          }
          goto LABEL_26;
        default:
          goto LABEL_26;
      }
    }

    return 0LL;
  }

  if (v36 != 0x300000000LL) {
    return 0LL;
  }
LABEL_26:
  if ((a1[16] & 1) != 0)
  {
    if (!*((_BYTE *)a2 + 32)) {
      return 0LL;
    }
  }

  else
  {
    if ((a2[16] & 1) != 0) {
      return 0LL;
    }
    unint64_t v38 = *(unsigned int *)(a1 + 13) | ((unint64_t)a1[15] << 32);
    unint64_t v39 = *(unsigned int *)(a2 + 13) | ((unint64_t)a2[15] << 32);
    v40.i64[0]  = 0xFFFFFFFFFFFFLL;
    v40.i64[1]  = 0xFFFFFFFFFFFFLL;
    uint64x2_t v41 = (uint64x2_t)vandq_s8((int8x16_t)vdupq_n_s64(v38), v40);
    int16x8_t v42 = (int16x8_t)vshlq_u64(v41, (uint64x2_t)xmmword_10033A8F0);
    uint64x2_t v43 = (uint64x2_t)vandq_s8((int8x16_t)vdupq_n_s64(v39), v40);
    int64x2_t v44 = (int64x2_t)vshlq_u64(v43, (uint64x2_t)xmmword_10033A8F0);
    int16x8_t v45 = (int16x8_t)vshlq_u64(v43, (uint64x2_t)xmmword_10033A8E0);
    v85[0]  = *(_DWORD *)(a1 + 13);
    *(int32x2_t *)v41.i8  = vmovn_s64((int64x2_t)vshlq_u64(v41, (uint64x2_t)xmmword_10033A8E0));
    *(int32x2_t *)v42.i8  = vmovn_s64((int64x2_t)v42);
    v42.i16[1]  = v42.i16[2];
    v42.i16[2]  = v41.i16[0];
    v42.i16[3]  = v41.i16[2];
    *(_DWORD *)&v85[1]  = vmovn_s16(v42).u32[0];
    v85[5]  = BYTE5(v38);
    v84[0]  = v39;
    *(int32x2_t *)v41.i8  = vmovn_s64((int64x2_t)v45);
    *(int32x2_t *)v45.i8  = vmovn_s64(v44);
    v45.i16[1]  = v45.i16[2];
    v45.i16[2]  = v41.i16[0];
    v45.i16[3]  = v41.i16[2];
    *(_DWORD *)&v84[1]  = vmovn_s16(v45).u32[0];
    v84[5]  = BYTE5(v39);
  }

  uint64_t v47 = *((void *)a1 + 6);
  uint64_t v48 = *((void *)a2 + 6);
  if (!v47)
  {
    if (v48) {
      return 0LL;
    }
    goto LABEL_59;
  }

  if (!v48) {
    return 0LL;
  }
  uint64_t v49 = *((void *)a1 + 5);
  uint64_t v50 = *((void *)a2 + 5);
  if (v49 == v50 && v47 == v48
    || (v51 = _stringCompareWithSmolCheck(_:_:expecting:)(v49, v47, v50, v48, 0LL), uint64_t result = 0LL, (v51 & 1) != 0))
  {
LABEL_59:
    if ((a1[31] & 1) != 0)
    {
      if (!*((_BYTE *)a2 + 62)) {
        return 0LL;
      }
    }

    else
    {
      if ((a2[31] & 1) != 0) {
        return 0LL;
      }
      unint64_t v53 = *((unsigned int *)a1 + 14) | ((unint64_t)a1[30] << 32);
      unint64_t v54 = *((unsigned int *)a2 + 14) | ((unint64_t)a2[30] << 32);
      v55.i64[0]  = 0xFFFFFFFFFFFFLL;
      v55.i64[1]  = 0xFFFFFFFFFFFFLL;
      uint64x2_t v56 = (uint64x2_t)vandq_s8((int8x16_t)vdupq_n_s64(v53), v55);
      int16x8_t v57 = (int16x8_t)vshlq_u64(v56, (uint64x2_t)xmmword_10033A8F0);
      uint64x2_t v58 = (uint64x2_t)vandq_s8((int8x16_t)vdupq_n_s64(v54), v55);
      int64x2_t v59 = (int64x2_t)vshlq_u64(v58, (uint64x2_t)xmmword_10033A8F0);
      int16x8_t v60 = (int16x8_t)vshlq_u64(v58, (uint64x2_t)xmmword_10033A8E0);
      v85[0]  = *((_DWORD *)a1 + 14);
      *(int32x2_t *)v56.i8  = vmovn_s64((int64x2_t)vshlq_u64(v56, (uint64x2_t)xmmword_10033A8E0));
      *(int32x2_t *)v57.i8  = vmovn_s64((int64x2_t)v57);
      v57.i16[1]  = v57.i16[2];
      v57.i16[2]  = v56.i16[0];
      v57.i16[3]  = v56.i16[2];
      *(_DWORD *)&v85[1]  = vmovn_s16(v57).u32[0];
      v85[5]  = BYTE5(v53);
      v84[0]  = v54;
      *(int32x2_t *)v56.i8  = vmovn_s64((int64x2_t)v60);
      *(int32x2_t *)v60.i8  = vmovn_s64(v59);
      v60.i16[1]  = v60.i16[2];
      v60.i16[2]  = v56.i16[0];
      v60.i16[3]  = v56.i16[2];
      *(_DWORD *)&v84[1]  = vmovn_s16(v60).u32[0];
      v84[5]  = BYTE5(v54);
    }

    uint64_t v62 = *((char *)a1 + 64);
    uint64_t v63 = *((char *)a2 + 64);
    if (v62 == 43)
    {
      if ((_DWORD)v63 != 43) {
        return 0LL;
      }
    }

    else if ((_DWORD)v63 == 43 || dword_100345098[v62] != dword_100345098[v63])
    {
      return 0LL;
    }

    char v64 = *((_BYTE *)a2 + 68);
    if ((a1[34] & 1) != 0)
    {
      if (!*((_BYTE *)a2 + 68)) {
        return 0LL;
      }
    }

    else
    {
      if (a1[33] != a2[33]) {
        char v64 = 1;
      }
      if ((v64 & 1) != 0) {
        return 0LL;
      }
    }

    char v65 = *((_BYTE *)a2 + 76);
    if ((a1[38] & 1) != 0)
    {
      if (!*((_BYTE *)a2 + 76)) {
        return 0LL;
      }
    }

    else
    {
      if (*((_DWORD *)a1 + 18) != *((_DWORD *)a2 + 18)) {
        char v65 = 1;
      }
      if ((v65 & 1) != 0) {
        return 0LL;
      }
    }

    if (*((unsigned __int8 *)a1 + 77) != *((unsigned __int8 *)a2 + 77)
      || *((unsigned __int8 *)a1 + 78) != *((unsigned __int8 *)a2 + 78)
      || *((unsigned __int8 *)a1 + 79) != *((unsigned __int8 *)a2 + 79)
      || *((unsigned __int8 *)a1 + 80) != *((unsigned __int8 *)a2 + 80)
      || *((unsigned __int8 *)a1 + 81) != *((unsigned __int8 *)a2 + 81)
      || *((unsigned __int8 *)a1 + 82) != *((unsigned __int8 *)a2 + 82)
      || *((unsigned __int8 *)a1 + 83) != *((unsigned __int8 *)a2 + 83)
      || *((unsigned __int8 *)a1 + 84) != *((unsigned __int8 *)a2 + 84)
      || *((unsigned __int8 *)a1 + 85) != *((unsigned __int8 *)a2 + 85)
      || *((unsigned __int8 *)a1 + 86) != *((unsigned __int8 *)a2 + 86)
      || *((unsigned __int8 *)a1 + 87) != *((unsigned __int8 *)a2 + 87)
      || *((unsigned __int8 *)a1 + 88) != *((unsigned __int8 *)a2 + 88)
      || *((unsigned __int8 *)a1 + 89) != *((unsigned __int8 *)a2 + 89)
      || *((unsigned __int8 *)a1 + 90) != *((unsigned __int8 *)a2 + 90)
      || *((unsigned __int8 *)a1 + 91) != *((unsigned __int8 *)a2 + 91)
      || *((unsigned __int8 *)a1 + 92) != *((unsigned __int8 *)a2 + 92)
      || *((unsigned __int8 *)a1 + 93) != *((unsigned __int8 *)a2 + 93)
      || *((unsigned __int8 *)a1 + 94) != *((unsigned __int8 *)a2 + 94))
    {
      return 0LL;
    }

    uint64_t v83 = (int *)type metadata accessor for AWDLActionFrame.DataPathState(0LL);
    sub_1000DB8E8((uint64_t)a1 + v83[34], (uint64_t)v19);
    sub_1000DB8E8((uint64_t)a2 + v83[34], (uint64_t)v17);
    uint64_t v66 = (uint64_t)&v10[*(int *)(v8 + 48)];
    sub_1000DB8E8((uint64_t)v19, (uint64_t)v10);
    uint64_t v82 = v66;
    sub_1000DB8E8((uint64_t)v17, v66);
    __int16 v67 = *(unsigned int (**)(uint64_t, uint64_t, uint64_t))(v5 + 48);
    if (v67((uint64_t)v10, 1LL, v4) == 1)
    {
      sub_1000225EC((uint64_t)v17, &qword_100407450);
      sub_1000225EC((uint64_t)v19, &qword_100407450);
      if (v67(v82, 1LL, v4) == 1)
      {
        sub_1000225EC((uint64_t)v10, &qword_100407450);
        goto LABEL_124;
      }
    }

    else
    {
      sub_1000DB8E8((uint64_t)v10, (uint64_t)v14);
      if (v67(v82, 1LL, v4) != 1)
      {
        (*(void (**)(char *, uint64_t, uint64_t))(v5 + 32))(v7, v82, v4);
        uint64_t v68 = sub_10000AF70( (unint64_t *)&unk_10040E400,  (uint64_t (*)(uint64_t))&type metadata accessor for DispatchTimeInterval,  (uint64_t)&protocol conformance descriptor for DispatchTimeInterval);
        char v69 = dispatch thunk of static Equatable.== infix(_:_:)(v14, v7, v4, v68);
        int16x8_t v70 = *(void (**)(char *, uint64_t))(v5 + 8);
        v70(v7, v4);
        sub_1000225EC((uint64_t)v17, &qword_100407450);
        sub_1000225EC((uint64_t)v19, &qword_100407450);
        v70(v14, v4);
        sub_1000225EC((uint64_t)v10, &qword_100407450);
        if ((v69 & 1) == 0) {
          return 0LL;
        }
LABEL_124:
        uint64_t v71 = v83[35];
        int v72 = (_DWORD *)((char *)a1 + v71);
        char v73 = *((_BYTE *)a1 + v71 + 4);
        uint64_t v74 = (_DWORD *)((char *)a2 + v71);
        int v75 = *((unsigned __int8 *)a2 + v71 + 4);
        if ((v73 & 1) != 0)
        {
          if (!v75) {
            return 0LL;
          }
        }

        else
        {
          if (*v72 != *v74) {
            LOBYTE(v75)  = 1;
          }
          if ((v75 & 1) != 0) {
            return 0LL;
          }
        }

        uint64_t v76 = v83[36];
        uint64_t v77 = (_DWORD *)((char *)a1 + v76);
        char v78 = *((_BYTE *)a1 + v76 + 4);
        uint64_t v79 = (_DWORD *)((char *)a2 + v76);
        char v80 = *((_BYTE *)a2 + v76 + 4);
        if ((v78 & 1) != 0)
        {
          if ((v80 & 1) == 0) {
            return 0LL;
          }
        }

        else
        {
          if (*v77 != *v79) {
            char v80 = 1;
          }
          if ((v80 & 1) != 0) {
            return 0LL;
          }
        }

        return 1LL;
      }

      sub_1000225EC((uint64_t)v17, &qword_100407450);
      sub_1000225EC((uint64_t)v19, &qword_100407450);
      (*(void (**)(char *, uint64_t))(v5 + 8))(v14, v4);
    }

    sub_1000225EC((uint64_t)v10, (uint64_t *)&unk_10040E3F0);
    return 0LL;
  }

  return result;
}

void _s7CoreP2P15AWDLActionFrameV13AWDLAttributeO21__derived_enum_equalsySbAE_AEtFZ_0( uint64_t a1, uint64_t a2)
{
  uint64_t v50 = a2;
  uint64_t v49 = a1;
  uint64_t v2 = type metadata accessor for AWDLActionFrame.DataPathState(0LL);
  __chkstk_darwin(v2);
  v47[2]  = (char *)v47 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v4 = type metadata accessor for AWDLActionFrame.ServiceResponse(0LL);
  __chkstk_darwin(v4);
  v47[1]  = (char *)v47 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v48 = type metadata accessor for AWDLActionFrame.AWDLAttribute(0LL);
  uint64_t v6 = __chkstk_darwin(v48);
  v47[16]  = (char *)v47 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v8 = __chkstk_darwin(v6);
  v47[15]  = (char *)v47 - v9;
  uint64_t v10 = __chkstk_darwin(v8);
  v47[14]  = (char *)v47 - v11;
  uint64_t v12 = __chkstk_darwin(v10);
  v47[12]  = (char *)v47 - v13;
  uint64_t v14 = __chkstk_darwin(v12);
  v47[13]  = (char *)v47 - v15;
  uint64_t v16 = __chkstk_darwin(v14);
  v47[11]  = (char *)v47 - v17;
  uint64_t v18 = __chkstk_darwin(v16);
  v47[10]  = (char *)v47 - v19;
  uint64_t v20 = __chkstk_darwin(v18);
  v47[9]  = (char *)v47 - v21;
  uint64_t v22 = __chkstk_darwin(v20);
  v47[8]  = (char *)v47 - v23;
  uint64_t v24 = __chkstk_darwin(v22);
  v47[6]  = (char *)v47 - v25;
  uint64_t v26 = __chkstk_darwin(v24);
  v47[7]  = (char *)v47 - v27;
  uint64_t v28 = __chkstk_darwin(v26);
  v47[5]  = (char *)v47 - v29;
  uint64_t v30 = __chkstk_darwin(v28);
  uint64_t v31 = __chkstk_darwin(v30);
  v47[3]  = (char *)v47 - v32;
  uint64_t v33 = __chkstk_darwin(v31);
  v47[4]  = (char *)v47 - v34;
  uint64_t v35 = __chkstk_darwin(v33);
  uint64_t v36 = __chkstk_darwin(v35);
  uint64_t v37 = __chkstk_darwin(v36);
  uint64_t v38 = __chkstk_darwin(v37);
  uint64_t v39 = __chkstk_darwin(v38);
  __chkstk_darwin(v39);
  uint64_t v40 = sub_100002274(&qword_100407CD8);
  uint64_t v41 = __chkstk_darwin(v40);
  uint64x2_t v43 = (char *)v47 - ((v42 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v44 = (uint64_t)&v43[*(int *)(v41 + 48)];
  sub_100057FE8(v49, (uint64_t)v43, type metadata accessor for AWDLActionFrame.AWDLAttribute);
  uint64_t v45 = v50;
  uint64_t v50 = v44;
  sub_100057FE8(v45, v44, type metadata accessor for AWDLActionFrame.AWDLAttribute);
  unint64_t v46 = (char *)sub_1000D7A38 + 4 * word_100340C40[swift_getEnumCaseMultiPayload(v43, v48)];
  __asm { BR              X10 }

uint64_t sub_1000D7A38()
{
  int v4 = v0[1];
  uint64_t v5 = *((void *)v0 + 1);
  uint64_t v6 = *(unsigned __int16 **)(v3 - 264);
  if (swift_getEnumCaseMultiPayload(v6, v1))
  {
    swift_bridgeObjectRelease(v5);
    sub_1000225EC(v2, &qword_100407CD8);
  }

  else
  {
    uint64_t v7 = *((void *)v6 + 1);
    if (*v0 == *v6 && v4 == v6[1])
    {
      char v10 = sub_10007990C(v5, *((void *)v6 + 1));
      swift_bridgeObjectRelease(v7);
      swift_bridgeObjectRelease(v5);
      if ((v10 & 1) != 0)
      {
        sub_10005802C(v2, type metadata accessor for AWDLActionFrame.AWDLAttribute);
        char v8 = 1;
        return v8 & 1;
      }
    }

    else
    {
      swift_bridgeObjectRelease(*((void *)v6 + 1));
      swift_bridgeObjectRelease(v5);
    }

    sub_10005802C(v2, type metadata accessor for AWDLActionFrame.AWDLAttribute);
  }

  char v8 = 0;
  return v8 & 1;
}

unint64_t sub_1000D8634(char a1, unsigned __int8 a2)
{
  if (a1)
  {
    if (a1 != 1)
    {
LABEL_7:
      unint64_t v7 = sub_1000033FC();
      uint64_t v8 = swift_allocError(&type metadata for WiFiError, v7, 0LL, 0LL);
      *(_OWORD *)uint64_t v9 = xmmword_100337020;
      *(_BYTE *)(v9 + 16)  = 2;
      return swift_willThrow(v8);
    }

    unsigned __int8 v4 = 1;
  }

  else
  {
    unsigned __int8 v4 = 2;
  }

  unint64_t result = sub_1001A05C4(v4, 4uLL, 4LL);
  if (v2) {
    return result;
  }
  int v6 = result;
  if (a2 == 2)
  {
    unsigned __int8 v10 = 1;
    goto LABEL_13;
  }

  if (a2 == 3)
  {
    unsigned __int8 v10 = 2;
LABEL_13:
    int v11 = sub_1001A05C4(v10, 2uLL, 2LL);
    int v12 = sub_1001A05C4(3u, 0LL, 2LL);
    else {
      int v13 = 0;
    }
    int v14 = v13 | v6;
    else {
      int v15 = 0;
    }
    return v15 | v14;
  }

  int v16 = sub_1001A05C4(3u, 2uLL, 2LL);
  else {
    int v17 = 0;
  }
  int v18 = v17 | v6;
  if ((a2 & 1) != 0) {
    unsigned __int8 v19 = 2;
  }
  else {
    unsigned __int8 v19 = 1;
  }
  int v20 = sub_1001A05C4(v19, 0LL, 2LL);
  else {
    int v21 = 0;
  }
  return v21 | v18;
}

uint64_t _s7CoreP2P15AWDLActionFrameV13AWDLAttributeO13AttributeTypeO8rawValueAGSgs5UInt8V_tcfC_0( unsigned __int8 a1)
{
  if (a1 > 0x23u) {
    return 23LL;
  }
  else {
    return byte_100345144[(char)a1];
  }
}

uint64_t _s7CoreP2P15AWDLActionFrameV13DataPathStateV30UnicastMasterIndicationOptionsO8rawValueAGSgs6UInt32V_tcfC_0( int a1)
{
  if (a1 >= 0x200000)
  {
    if (a1 > 150994943)
    {
      if (a1 <= 234881023)
      {
        if (a1 <= 184549375)
        {
          if (a1 == 150994944) {
            return 35LL;
          }
          if (a1 == 167772160) {
            return 36LL;
          }
        }

        else
        {
          switch(a1)
          {
            case 184549376:
              return 37LL;
            case 201326592:
              return 38LL;
            case 218103808:
              return 39LL;
          }
        }
      }

      else if (a1 > 301989887)
      {
        switch(a1)
        {
          case 0x12000000:
            return 42LL;
          case 0x20000000:
            return 27LL;
          case 0x40000000:
            return 33LL;
        }
      }

      else
      {
        switch(a1)
        {
          case 234881024:
            return 40LL;
          case 268435456:
            return 26LL;
          case 285212672:
            return 41LL;
        }
      }
    }

    else if (a1 <= 50331647)
    {
      if (a1 < 0x800000)
      {
        if (a1 == 0x200000) {
          return 19LL;
        }
        if (a1 == 0x400000) {
          return 20LL;
        }
      }

      else
      {
        switch(a1)
        {
          case 0x800000:
            return 21LL;
          case 0x1000000:
            return 22LL;
          case 0x2000000:
            return 23LL;
        }
      }
    }

    else if (a1 > 83886079)
    {
      switch(a1)
      {
        case 0x5000000:
          return 31LL;
        case 0x6000000:
          return 32LL;
        case 0x8000000:
          return 3LL;
      }
    }

    else
    {
      switch(a1)
      {
        case 50331648:
          return 30LL;
        case 67108864:
          return 2LL;
        case 67108866:
          return 4LL;
      }
    }

    return 43LL;
  }

  if (a1 > 1023)
  {
    if (a1 < 0x8000)
    {
      if (a1 <= 4095)
      {
        if (a1 == 1024) {
          return 28LL;
        }
        if (a1 == 2048) {
          return 29LL;
        }
      }

      else
      {
        switch(a1)
        {
          case 0x1000:
            return 25LL;
          case 0x2000:
            return 13LL;
          case 0x4000:
            return 15LL;
        }
      }
    }

    else if (a1 >= 0x40000)
    {
      switch(a1)
      {
        case 0x40000:
          return 18LL;
        case 0x80000:
          return 1LL;
        case 0x100000:
          return 14LL;
      }
    }

    else
    {
      switch(a1)
      {
        case 0x8000:
          return 16LL;
        case 0x10000:
          return 5LL;
        case 0x20000:
          return 17LL;
      }
    }

    return 43LL;
  }

  if (a1 > 63)
  {
    if (a1 > 255)
    {
      if (a1 == 256) {
        return 12LL;
      }
      if (a1 == 512) {
        return 24LL;
      }
    }

    else
    {
      if (a1 == 64) {
        return 10LL;
      }
      if (a1 == 128) {
        return 11LL;
      }
    }

    return 43LL;
  }

  switch(a1)
  {
    case 2:
      uint64_t result = 0LL;
      break;
    case 3:
    case 5:
    case 6:
    case 7:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
    case 29:
    case 30:
    case 31:
      return 43LL;
    case 4:
      uint64_t result = 6LL;
      break;
    case 8:
      uint64_t result = 7LL;
      break;
    case 16:
      uint64_t result = 8LL;
      break;
    case 32:
      uint64_t result = 9LL;
      break;
    default:
      if (a1 != 0x80000000) {
        return 43LL;
      }
      uint64_t result = 34LL;
      break;
  }

  return result;
}

uint64_t _s7CoreP2P15AWDLActionFrameV20MultiPeerBSSSteeringV17SteeringMessageIDO8rawValueAGSgs5UInt8V_tcfC_0( uint64_t result)
{
  else {
    return result;
  }
}

uint64_t _s7CoreP2P19NANIntervalDurationO8rawValueACSgs5UInt8V_tcfC_0(uint64_t result)
{
  if ((result & 0xFC) != 0) {
    return 4LL;
  }
  else {
    return result;
  }
}

uint64_t _s7CoreP2P15AWDLActionFrameV7VersionV12PlatformTypeO8rawValueAGSgs5UInt8V_tcfC_0(unsigned __int8 a1)
{
  int v1 = a1 - 1;
  uint64_t result = 1LL;
  switch(v1)
  {
    case 0:
      uint64_t result = 0LL;
      break;
    case 1:
      return result;
    case 3:
      uint64_t result = 2LL;
      break;
    case 7:
      uint64_t result = 3LL;
      break;
    case 15:
      uint64_t result = 4LL;
      break;
    default:
      uint64_t result = 5LL;
      break;
  }

  return result;
}

void *sub_1000D8BE8(void *a1)
{
  uint64_t v3 = sub_100002274(&qword_100407D78);
  uint64_t v4 = *(void *)(v3 - 8);
  __chkstk_darwin(v3);
  int v6 = (char *)&v15 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v7 = a1[3];
  uint64_t v8 = a1[4];
  uint64_t v9 = sub_100021104(a1, v7);
  unint64_t v10 = sub_1000DBACC();
  dispatch thunk of Decoder.container<A>(keyedBy:)( &type metadata for AWDLActionFrame.SyncTreePath.CodingKeys,  &type metadata for AWDLActionFrame.SyncTreePath.CodingKeys,  v10,  v7,  v8);
  if (v1)
  {
    sub_100002AC4(a1);
  }

  else
  {
    uint64_t v11 = sub_100002274(&qword_100407490);
    uint64_t v12 = sub_1000E51D0( &qword_100407D80,  (void (*)(void))sub_1000290F8,  (uint64_t)&protocol conformance descriptor for <A> [A]);
    KeyedDecodingContainer.decode<A>(_:forKey:)(&v16, v11, v13, v3, v11, v12);
    (*(void (**)(char *, uint64_t))(v4 + 8))(v6, v3);
    uint64_t v9 = v16;
    sub_100002AC4(a1);
  }

  return v9;
}

uint64_t sub_1000D8D2C(void *a1)
{
  uint64_t v3 = sub_100002274(&qword_100407DF0);
  uint64_t v4 = *(void *)(v3 - 8);
  __chkstk_darwin(v3);
  int v6 = (char *)&v15 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v7 = a1[3];
  uint64_t v8 = a1[4];
  sub_100021104(a1, v7);
  unint64_t v9 = sub_1000C1108();
  dispatch thunk of Decoder.container<A>(keyedBy:)( &type metadata for AWDLActionFrame.ServiceRequest.CodingKeys,  &type metadata for AWDLActionFrame.ServiceRequest.CodingKeys,  v9,  v7,  v8);
  if (v1)
  {
    sub_100002AC4(a1);
  }

  else
  {
    char v19 = 0;
    unsigned __int16 v10 = KeyedDecodingContainer.decode(_:forKey:)(&v19, v3);
    char v18 = 1;
    unsigned __int16 v12 = KeyedDecodingContainer.decode(_:forKey:)(&v18, v3);
    uint64_t v13 = sub_100002274(&qword_100406978);
    char v16 = 2;
    uint64_t v14 = sub_1000E5170( &qword_100407D68,  (uint64_t)&protocol witness table for UInt8,  (uint64_t)&protocol conformance descriptor for <A> [A]);
    KeyedDecodingContainer.decode<A>(_:forKey:)(&v17, v13, &v16, v3, v13, v14);
    (*(void (**)(char *, uint64_t))(v4 + 8))(v6, v3);
    sub_100002AC4(a1);
    return v10 | (v12 << 16);
  }

  return v7;
}

uint64_t type metadata accessor for AWDLActionFrame.ServiceResponse(uint64_t a1)
{
  return sub_100020E48(a1, qword_100407830, (uint64_t)&nominal type descriptor for AWDLActionFrame.ServiceResponse);
}

uint64_t sub_1000D8EF4@<X0>(void *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v6 = sub_100002274(&qword_100407DB0);
  uint64_t v7 = *(void *)(v6 - 8);
  __chkstk_darwin(v6);
  unint64_t v9 = &v19.i8[-((v8 + 15) & 0xFFFFFFFFFFFFFFF0LL)];
  uint64_t v10 = a1[3];
  uint64_t v11 = a1[4];
  sub_100021104(a1, v10);
  unint64_t v12 = sub_1000E5348();
  dispatch thunk of Decoder.container<A>(keyedBy:)( &type metadata for AWDLActionFrame.SynchronizationParameter.CodingKeys,  &type metadata for AWDLActionFrame.SynchronizationParameter.CodingKeys,  v12,  v10,  v11);
  if (v2) {
    return sub_100002AC4(a1);
  }
  LOBYTE(v38)  = 0;
  char v13 = KeyedDecodingContainer.decode(_:forKey:)(&v38, v6);
  LOBYTE(v38)  = 1;
  __int16 v14 = KeyedDecodingContainer.decode(_:forKey:)(&v38, v6);
  LOBYTE(v38)  = 2;
  int v37 = KeyedDecodingContainer.decode(_:forKey:)(&v38, v6);
  LOBYTE(v38)  = 3;
  int v36 = KeyedDecodingContainer.decode(_:forKey:)(&v38, v6);
  LOBYTE(v38)  = 4;
  int v35 = KeyedDecodingContainer.decode(_:forKey:)(&v38, v6);
  LOBYTE(v38)  = 5;
  int v34 = KeyedDecodingContainer.decode(_:forKey:)(&v38, v6);
  LOBYTE(v38)  = 6;
  int v33 = KeyedDecodingContainer.decode(_:forKey:)(&v38, v6);
  LOBYTE(v38)  = 7;
  int v32 = KeyedDecodingContainer.decode(_:forKey:)(&v38, v6);
  LOBYTE(v38)  = 8;
  int v31 = KeyedDecodingContainer.decode(_:forKey:)(&v38, v6);
  LOBYTE(v38)  = 9;
  int v30 = KeyedDecodingContainer.decode(_:forKey:)(&v38, v6);
  LOBYTE(v38)  = 10;
  int v29 = KeyedDecodingContainer.decode(_:forKey:)(&v38, v6);
  LOBYTE(v38)  = 11;
  int v28 = KeyedDecodingContainer.decode(_:forKey:)(&v38, v6);
  LOBYTE(v38)  = 12;
  int v27 = KeyedDecodingContainer.decode(_:forKey:)(&v38, v6);
  LOBYTE(v38)  = 13;
  int v26 = KeyedDecodingContainer.decode(_:forKey:)(&v38, v6);
  char v39 = 14;
  unint64_t v15 = sub_1000290F8();
  KeyedDecodingContainer.decode<A>(_:forKey:)( &v38,  &type metadata for WiFiAddress,  &v39,  v6,  &type metadata for WiFiAddress,  v15);
  v3.i32[0]  = v38;
  int v24 = BYTE5(v38);
  int v25 = BYTE4(v38);
  LOBYTE(v38)  = 15;
  int v23 = KeyedDecodingContainer.decode(_:forKey:)(&v38, v6);
  LOBYTE(v38)  = 16;
  int v22 = KeyedDecodingContainer.decode(_:forKey:)(&v38, v6);
  LOBYTE(v38)  = 17;
  int v21 = KeyedDecodingContainer.decode(_:forKey:)(&v38, v6);
  LOBYTE(v38)  = 18;
  int v20 = KeyedDecodingContainer.decode(_:forKey:)(&v38, v6);
  char v39 = 19;
  unint64_t v16 = sub_1000E538C();
  KeyedDecodingContainer.decode<A>(_:forKey:)( &v38,  &type metadata for AWDLActionFrame.AWDLChannelSequenceParameter,  &v39,  v6,  &type metadata for AWDLActionFrame.AWDLChannelSequenceParameter,  v16);
  (*(void (**)(__int8 *, uint64_t))(v7 + 8))(v9, v6);
  int16x8_t v19 = (int16x8_t)vmovl_u8(v3);
  uint64_t v17 = v38;
  uint64_t result = sub_100002AC4(a1);
  *(_BYTE *)a2  = v13;
  *(_WORD *)(a2 + 2)  = v14;
  *(_BYTE *)(a2 + 4)  = v37;
  *(_BYTE *)(a2 + 5)  = v36;
  *(_WORD *)(a2 + 6)  = v35;
  *(_WORD *)(a2 + 8)  = v34;
  *(_WORD *)(a2 + 10)  = v33;
  *(_WORD *)(a2 + 12)  = v32;
  *(_WORD *)(a2 + 14)  = v31;
  *(_WORD *)(a2 + 16)  = v30;
  *(_BYTE *)(a2 + 18)  = v29;
  *(_BYTE *)(a2 + 19)  = v28;
  *(_BYTE *)(a2 + 20)  = v27;
  *(_BYTE *)(a2 + 21)  = v26;
  *(_DWORD *)(a2 + 22)  = vmovn_s16(v19).u32[0];
  *(_BYTE *)(a2 + 26)  = v25;
  *(_BYTE *)(a2 + 27)  = v24;
  *(_BYTE *)(a2 + 28)  = v23;
  *(_BYTE *)(a2 + 29)  = v22;
  *(_WORD *)(a2 + 30)  = v21;
  *(_WORD *)(a2 + 32)  = v20;
  *(void *)(a2 + 40)  = v17;
  return result;
}

unint64_t sub_1000D9408(void *a1)
{
  uint64_t v3 = sub_100002274(&qword_100407DA0);
  uint64_t v4 = *(void *)(v3 - 8);
  __chkstk_darwin(v3);
  uint64_t v6 = (char *)v15 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v7 = a1[3];
  uint64_t v8 = a1[4];
  sub_100021104(a1, v7);
  unint64_t v9 = sub_1000E5304();
  dispatch thunk of Decoder.container<A>(keyedBy:)( &type metadata for AWDLActionFrame.DeprecatedElectionParameter.CodingKeys,  &type metadata for AWDLActionFrame.DeprecatedElectionParameter.CodingKeys,  v9,  v7,  v8);
  if (v1) {
    return sub_100002AC4(a1);
  }
  LOBYTE(v23)  = 0;
  unsigned __int8 v10 = KeyedDecodingContainer.decode(_:forKey:)(&v23, v3);
  LOBYTE(v23)  = 1;
  unsigned __int16 v11 = KeyedDecodingContainer.decode(_:forKey:)(&v23, v3);
  LOBYTE(v23)  = 2;
  unsigned __int8 v12 = KeyedDecodingContainer.decode(_:forKey:)(&v23, v3);
  LOBYTE(v23)  = 3;
  int v21 = KeyedDecodingContainer.decode(_:forKey:)(&v23, v3);
  v22[0]  = 4;
  unint64_t v13 = sub_1000290F8();
  KeyedDecodingContainer.decode<A>(_:forKey:)( &v23,  &type metadata for WiFiAddress,  v22,  v3,  &type metadata for WiFiAddress,  v13);
  uint64_t v19 = v23;
  uint64_t v18 = BYTE1(v23);
  uint64_t v17 = *(unsigned int *)((char *)&v23 + 2);
  v22[0]  = 5;
  unint64_t v20 = sub_1000E50A4();
  KeyedDecodingContainer.decode<A>(_:forKey:)( &v23,  &type metadata for AWDLElectionMetric,  v22,  v3,  &type metadata for AWDLElectionMetric,  v20);
  uint64_t v16 = v23;
  v15[1]  = BYTE4(v23);
  v22[0]  = 6;
  KeyedDecodingContainer.decode<A>(_:forKey:)( &v23,  &type metadata for AWDLElectionMetric,  v22,  v3,  &type metadata for AWDLElectionMetric,  v20);
  (*(void (**)(char *, uint64_t))(v4 + 8))(v6, v3);
  sub_100002AC4(a1);
  return v10 | ((unint64_t)v11 << 16) | ((unint64_t)v12 << 32) | ((unint64_t)v21 << 40) | (v19 << 48) | (v18 << 56);
}

uint64_t sub_1000D96D4(void *a1)
{
  uint64_t v3 = sub_100002274(&qword_100407D70);
  uint64_t v4 = *(void *)(v3 - 8);
  __chkstk_darwin(v3);
  uint64_t v6 = (char *)&v14 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v7 = a1[3];
  uint64_t v8 = a1[4];
  sub_100021104(a1, v7);
  unint64_t v9 = sub_1000DBB54();
  dispatch thunk of Decoder.container<A>(keyedBy:)( &type metadata for AWDLActionFrame.Version.CodingKeys,  &type metadata for AWDLActionFrame.Version.CodingKeys,  v9,  v7,  v8);
  if (v1) {
    return sub_100002AC4(a1);
  }
  char v16 = 0;
  unint64_t v10 = sub_1000E4E84();
  KeyedDecodingContainer.decode<A>(_:forKey:)( &v17,  &type metadata for AWDLActionFrame.AWDLVersion,  &v16,  v3,  &type metadata for AWDLActionFrame.AWDLVersion,  v10);
  int v11 = v17;
  char v15 = 1;
  int v12 = KeyedDecodingContainer.decode(_:forKey:)(&v15, v3);
  (*(void (**)(char *, uint64_t))(v4 + 8))(v6, v3);
  sub_100002AC4(a1);
  return v11 | (v12 << 8);
}

uint64_t sub_1000D9838(void *a1)
{
  uint64_t v3 = sub_100002274(&qword_100407D60);
  uint64_t v4 = *(void *)(v3 - 8);
  __chkstk_darwin(v3);
  uint64_t v6 = (char *)&v15 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v7 = a1[3];
  uint64_t v8 = a1[4];
  sub_100021104(a1, v7);
  unint64_t v9 = sub_1000DBBDC();
  dispatch thunk of Decoder.container<A>(keyedBy:)( &type metadata for AWDLActionFrame.PeerMACAddressListBloomFilter.CodingKeys,  &type metadata for AWDLActionFrame.PeerMACAddressListBloomFilter.CodingKeys,  v9,  v7,  v8);
  if (v1)
  {
    sub_100002AC4(a1);
  }

  else
  {
    char v19 = 0;
    unsigned __int8 v10 = KeyedDecodingContainer.decode(_:forKey:)(&v19, v3);
    char v18 = 1;
    int v12 = KeyedDecodingContainer.decode(_:forKey:)(&v18, v3);
    uint64_t v13 = sub_100002274(&qword_100406978);
    char v16 = 2;
    uint64_t v14 = sub_1000E5170( &qword_100407D68,  (uint64_t)&protocol witness table for UInt8,  (uint64_t)&protocol conformance descriptor for <A> [A]);
    KeyedDecodingContainer.decode<A>(_:forKey:)(&v17, v13, &v16, v3, v13, v14);
    (*(void (**)(char *, uint64_t))(v4 + 8))(v6, v3);
    sub_100002AC4(a1);
    return v10 | (v12 << 8);
  }

  return v7;
}

uint64_t sub_1000D99EC@<X0>(void *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v8 = sub_100002274(&qword_100407D48);
  uint64_t v9 = *(void *)(v8 - 8);
  __chkstk_darwin(v8);
  int v11 = &v24.i8[-((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL)];
  uint64_t v12 = a1[3];
  uint64_t v13 = a1[4];
  sub_100021104(a1, v12);
  unint64_t v14 = sub_1000DBC20();
  dispatch thunk of Decoder.container<A>(keyedBy:)( &type metadata for AWDLActionFrame.NANSynchronization.CodingKeys,  &type metadata for AWDLActionFrame.NANSynchronization.CodingKeys,  v14,  v12,  v13);
  if (v2) {
    return sub_100002AC4(a1);
  }
  LOBYTE(v39)  = 0;
  int v15 = KeyedDecodingContainer.decode(_:forKey:)(&v39, v8);
  char v40 = 1;
  unint64_t v16 = sub_1000290F8();
  KeyedDecodingContainer.decode<A>(_:forKey:)( &v39,  &type metadata for WiFiAddress,  &v40,  v8,  &type metadata for WiFiAddress,  v16);
  v3.i32[0]  = v39;
  int v37 = v15;
  int v38 = BYTE4(v39);
  int v17 = BYTE5(v39);
  char v40 = 2;
  KeyedDecodingContainer.decode<A>(_:forKey:)( &v39,  &type metadata for WiFiAddress,  &v40,  v8,  &type metadata for WiFiAddress,  v16);
  v4.i32[0]  = v39;
  int v35 = BYTE4(v39);
  int v36 = v17;
  int v18 = BYTE5(v39);
  char v40 = 3;
  unint64_t v19 = sub_1000E50E8();
  KeyedDecodingContainer.decode<A>(_:forKey:)( &v39,  &type metadata for NANTimeSynchronizationFunction,  &v40,  v8,  &type metadata for NANTimeSynchronizationFunction,  v19);
  int v34 = v18;
  uint64_t v20 = v39;
  char v40 = 4;
  unint64_t v21 = sub_1000E512C();
  KeyedDecodingContainer.decode<A>(_:forKey:)( &v39,  &type metadata for NANAttribute.MasterIndication,  &v40,  v8,  &type metadata for NANAttribute.MasterIndication,  v21);
  uint64_t v32 = v20;
  int v33 = v39;
  LODWORD(v20)  = BYTE1(v39);
  char v40 = 5;
  KeyedDecodingContainer.decode<A>(_:forKey:)( &v39,  &type metadata for WiFiAddress,  &v40,  v8,  &type metadata for WiFiAddress,  v16);
  int v31 = v20;
  v5.i32[0]  = v39;
  LODWORD(v16)  = BYTE4(v39);
  LODWORD(v20)  = BYTE5(v39);
  LOBYTE(v39)  = 6;
  int v28 = KeyedDecodingContainer.decode(_:forKey:)(&v39, v8);
  int v29 = v16;
  int v30 = v20;
  LOBYTE(v39)  = 7;
  int v27 = KeyedDecodingContainer.decode(_:forKey:)(&v39, v8);
  LOBYTE(v39)  = 8;
  LOWORD(v20)  = KeyedDecodingContainer.decode(_:forKey:)(&v39, v8);
  LOBYTE(v39)  = 9;
  int v22 = KeyedDecodingContainer.decode(_:forKey:)(&v39, v8);
  (*(void (**)(__int8 *, uint64_t))(v9 + 8))(v11, v8);
  int16x8_t v24 = (int16x8_t)vmovl_u8(v3);
  int16x8_t v25 = (int16x8_t)vmovl_u8(v4);
  int16x8_t v26 = (int16x8_t)vmovl_u8(v5);
  uint64_t result = sub_100002AC4(a1);
  *(_WORD *)a2  = v37;
  *(_DWORD *)(a2 + 2)  = vmovn_s16(v24).u32[0];
  *(_BYTE *)(a2 + 6)  = v38;
  *(_BYTE *)(a2 + 7)  = v36;
  *(_DWORD *)(a2 + 8)  = vmovn_s16(v25).u32[0];
  *(_BYTE *)(a2 + 12)  = v35;
  *(_BYTE *)(a2 + 13)  = v34;
  *(void *)(a2 + 16)  = v32;
  *(_BYTE *)(a2 + 24)  = v33;
  *(_BYTE *)(a2 + 25)  = v31;
  *(_DWORD *)(a2 + 26)  = vmovn_s16(v26).u32[0];
  *(_BYTE *)(a2 + 30)  = v29;
  *(_BYTE *)(a2 + 31)  = v30;
  *(_BYTE *)(a2 + 32)  = v28;
  *(_BYTE *)(a2 + 33)  = v27;
  *(_WORD *)(a2 + 34)  = v20;
  *(_DWORD *)(a2 + 36)  = v22;
  return result;
}

uint64_t sub_1000D9DD8@<X0>(void *a1@<X0>, _DWORD *a2@<X8>)
{
  uint64_t v7 = sub_100002274(&qword_100407D38);
  uint64_t v8 = *(void *)(v7 - 8);
  __chkstk_darwin(v7);
  uint64_t v10 = &v22.i8[-((v9 + 15) & 0xFFFFFFFFFFFFFFF0LL)];
  uint64_t v11 = a1[3];
  uint64_t v12 = a1[4];
  sub_100021104(a1, v11);
  unint64_t v13 = sub_1000DBD28();
  dispatch thunk of Decoder.container<A>(keyedBy:)( &type metadata for AWDLActionFrame.ElectionParameter.CodingKeys,  &type metadata for AWDLActionFrame.ElectionParameter.CodingKeys,  v13,  v11,  v12);
  if (v2) {
    return sub_100002AC4(a1);
  }
  HIBYTE(v34)  = 0;
  unint64_t v14 = sub_1000290F8();
  KeyedDecodingContainer.decode<A>(_:forKey:)( &v34,  &type metadata for WiFiAddress,  (char *)&v34 + 7,  v7,  &type metadata for WiFiAddress,  v14);
  int v33 = a2;
  v3.i32[0]  = v34;
  int v15 = BYTE4(v34);
  int v16 = BYTE5(v34);
  HIBYTE(v34)  = 1;
  KeyedDecodingContainer.decode<A>(_:forKey:)( &v34,  &type metadata for WiFiAddress,  (char *)&v34 + 7,  v7,  &type metadata for WiFiAddress,  v14);
  int v31 = v15;
  int v32 = v16;
  v4.i32[0]  = v34;
  LOBYTE(v15)  = BYTE4(v34);
  LOBYTE(v16)  = BYTE5(v34);
  LOBYTE(v34)  = 2;
  LODWORD(v14)  = KeyedDecodingContainer.decode(_:forKey:)(&v34, v7);
  LOBYTE(v34)  = 3;
  int v29 = KeyedDecodingContainer.decode(_:forKey:)(&v34, v7);
  int v30 = v14;
  HIBYTE(v34)  = 4;
  unint64_t v17 = sub_1000E50A4();
  KeyedDecodingContainer.decode<A>(_:forKey:)( &v34,  &type metadata for AWDLElectionMetric,  (char *)&v34 + 7,  v7,  &type metadata for AWDLElectionMetric,  v17);
  int v27 = v34;
  int v28 = BYTE4(v34);
  HIBYTE(v34)  = 5;
  KeyedDecodingContainer.decode<A>(_:forKey:)( &v34,  &type metadata for AWDLElectionMetric,  (char *)&v34 + 7,  v7,  &type metadata for AWDLElectionMetric,  v17);
  int v26 = v34;
  LODWORD(v17)  = BYTE4(v34);
  LOBYTE(v34)  = 6;
  int v24 = KeyedDecodingContainer.decode(_:forKey:)(&v34, v7);
  int v25 = v17;
  LOBYTE(v34)  = 7;
  LODWORD(v17)  = KeyedDecodingContainer.decode(_:forKey:)(&v34, v7);
  LOBYTE(v34)  = 8;
  int v18 = KeyedDecodingContainer.decode(_:forKey:)(&v34, v7);
  (*(void (**)(__int8 *, uint64_t))(v8 + 8))(v10, v7);
  int16x8_t v22 = (int16x8_t)vmovl_u8(v3);
  int16x8_t v23 = (int16x8_t)vmovl_u8(v4);
  uint64_t result = sub_100002AC4(a1);
  uint64_t v20 = v33;
  _DWORD *v33 = vmovn_s16(v22).u32[0];
  *((_BYTE *)v20 + 4)  = v31;
  *((_BYTE *)v20 + 5)  = v32;
  *(_DWORD *)((char *)v20 + 6)  = vmovn_s16(v23).u32[0];
  *((_BYTE *)v20 + 10)  = v15;
  *((_BYTE *)v20 + 11)  = v16;
  int v21 = v29;
  v20[3]  = v30;
  v20[4]  = v21;
  v20[5]  = v27;
  *((_BYTE *)v20 + 24)  = v28;
  v20[7]  = v26;
  *((_BYTE *)v20 + 32)  = v25;
  v20[9]  = v24;
  v20[10]  = v17;
  v20[11]  = v18;
  return result;
}

unint64_t sub_1000DA148(void *a1)
{
  uint64_t v3 = sub_100002274(&qword_100407D28);
  uint64_t v4 = *(void *)(v3 - 8);
  __chkstk_darwin(v3);
  uint64_t v6 = (char *)&v14 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v7 = a1[3];
  uint64_t v8 = a1[4];
  unint64_t v9 = (unint64_t)sub_100021104(a1, v7);
  unint64_t v10 = sub_1000DBD6C();
  dispatch thunk of Decoder.container<A>(keyedBy:)( &type metadata for AWDLActionFrame.MultiPeerBSSSteering.CodingKeys,  &type metadata for AWDLActionFrame.MultiPeerBSSSteering.CodingKeys,  v10,  v7,  v8);
  if (v1)
  {
    sub_100002AC4(a1);
  }

  else
  {
    unint64_t v11 = sub_1000E5060();
    KeyedDecodingContainer.decode<A>(_:forKey:)( &v15,  &type metadata for AWDLActionFrame.MultiPeerBSSSteering.SteeringMessageID,  v12,  v3,  &type metadata for AWDLActionFrame.MultiPeerBSSSteering.SteeringMessageID,  v11);
    (*(void (**)(char *, uint64_t))(v4 + 8))(v6, v3);
    unint64_t v9 = v15;
    sub_100002AC4(a1);
  }

  return v9;
}

uint64_t sub_1000DA268(void *a1)
{
  uint64_t v3 = sub_100002274(&qword_100407D20);
  uint64_t v4 = *(void *)(v3 - 8);
  __chkstk_darwin(v3);
  uint64_t v6 = (char *)&v16 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v7 = a1[3];
  uint64_t v8 = a1[4];
  sub_100021104(a1, v7);
  unint64_t v9 = sub_1000DBDF4();
  dispatch thunk of Decoder.container<A>(keyedBy:)( &type metadata for AWDLActionFrame.Ranging.CodingKeys,  &type metadata for AWDLActionFrame.Ranging.CodingKeys,  v9,  v7,  v8);
  if (v1) {
    return sub_100002AC4(a1);
  }
  BYTE6(v18)  = 0;
  unsigned __int8 v10 = KeyedDecodingContainer.decode(_:forKey:)((char *)&v18 + 6, v3);
  char v17 = 1;
  unint64_t v11 = sub_1000290F8();
  KeyedDecodingContainer.decode<A>(_:forKey:)( &v18,  &type metadata for WiFiAddress,  &v17,  v3,  &type metadata for WiFiAddress,  v11);
  (*(void (**)(char *, uint64_t))(v4 + 8))(v6, v3);
  uint64_t v12 = v18;
  uint64_t v13 = BYTE1(v18);
  uint64_t v14 = *(unsigned int *)((char *)&v18 + 2);
  sub_100002AC4(a1);
  return v10 | (unint64_t)(v12 << 8) | (v13 << 16) | (v14 << 24);
}

uint64_t sub_1000DA3E0(void *a1)
{
  uint64_t v3 = a1[3];
  uint64_t v4 = a1[4];
  sub_100021104(a1, v3);
  dispatch thunk of Decoder.unkeyedContainer()(v21, v3, v4);
  if (!v1)
  {
    uint64_t v5 = v22;
    uint64_t v6 = v23;
    sub_1000237C8((uint64_t)v21, v22);
    dispatch thunk of UnkeyedDecodingContainer.decode(_:)(v5, v6);
    uint64_t v7 = v22;
    uint64_t v8 = v23;
    sub_1000237C8((uint64_t)v21, v22);
    LOBYTE(v7)  = dispatch thunk of UnkeyedDecodingContainer.decode(_:)(v7, v8);
    uint64_t v9 = v22;
    uint64_t v10 = v23;
    sub_1000237C8((uint64_t)v21, v22);
    char v11 = dispatch thunk of UnkeyedDecodingContainer.decode(_:)(v9, v10);
    unint64_t v12 = sub_1000D2134(v7, v11);
    if ((v12 & 0xFF00000000LL) != 0x300000000LL)
    {
      unint64_t v16 = v12;
      uint64_t v17 = v22;
      uint64_t v18 = v23;
      sub_1000237C8((uint64_t)v21, v22);
      __int16 v19 = dispatch thunk of UnkeyedDecodingContainer.decode(_:)(v17, v18);
      sub_1000C0164(v19 << 8, (uint64_t)v21);
      sub_100002AC4(v21);
      sub_100002AC4(a1);
      return v16 & 0xFFFFFFFFFFFFLL;
    }

    unint64_t v13 = sub_1000033FC();
    uint64_t v14 = swift_allocError(&type metadata for WiFiError, v13, 0LL, 0LL);
    *(_OWORD *)uint64_t v15 = xmmword_100337020;
    *(_BYTE *)(v15 + 16)  = 2;
    swift_willThrow(v14);
    sub_100002AC4(v21);
  }

  return sub_100002AC4(a1);
}

uint64_t sub_1000DA5A4(void *a1)
{
  uint64_t v3 = sub_100002274(&qword_100407CF0);
  uint64_t v4 = *(void *)(v3 - 8);
  __chkstk_darwin(v3);
  uint64_t v6 = (char *)&v16 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v7 = a1[3];
  uint64_t v8 = a1[4];
  sub_100021104(a1, v7);
  unint64_t v9 = sub_1000DBF4C();
  dispatch thunk of Decoder.container<A>(keyedBy:)( &type metadata for AWDLActionFrame.ProMode.CodingKeys,  &type metadata for AWDLActionFrame.ProMode.CodingKeys,  v9,  v7,  v8);
  if (v1) {
    return sub_100002AC4(a1);
  }
  HIBYTE(v18)  = 0;
  unsigned __int8 v10 = KeyedDecodingContainer.decode(_:forKey:)((char *)&v18 + 7, v3);
  BYTE5(v18)  = 1;
  unint64_t v11 = sub_1000E4F50();
  KeyedDecodingContainer.decode<A>(_:forKey:)( (uint64_t *)((char *)&v18 + 6),  &type metadata for AWDLActionFrame.ProMode.Command,  (char *)&v18 + 5,  v3,  &type metadata for AWDLActionFrame.ProMode.Command,  v11);
  uint64_t v12 = BYTE6(v18);
  BYTE4(v18)  = 2;
  uint64_t v13 = KeyedDecodingContainer.decode(_:forKey:)((char *)&v18 + 4, v3);
  char v17 = 3;
  unint64_t v14 = sub_1000E4F94();
  KeyedDecodingContainer.decode<A>(_:forKey:)( &v18,  &type metadata for AWDLActionFrame.ProMode.Flags,  &v17,  v3,  &type metadata for AWDLActionFrame.ProMode.Flags,  v14);
  (*(void (**)(char *, uint64_t))(v4 + 8))(v6, v3);
  sub_100002AC4(a1);
  return v10 | (unint64_t)(v12 << 8) | (v13 << 32);
}

uint64_t sub_1000DA780(void *a1)
{
  uint64_t v3 = sub_100002274(&qword_100407CE0);
  uint64_t v4 = *(void *)(v3 - 8);
  __chkstk_darwin(v3);
  uint64_t v6 = (char *)&v15 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v7 = a1[3];
  uint64_t v8 = a1[4];
  sub_100021104(a1, v7);
  unint64_t v9 = sub_1000DC018();
  dispatch thunk of Decoder.container<A>(keyedBy:)( &type metadata for AWDLActionFrame.AirDrop.CodingKeys,  &type metadata for AWDLActionFrame.AirDrop.CodingKeys,  v9,  v7,  v8);
  if (v1) {
    return sub_100002AC4(a1);
  }
  BYTE1(v17)  = 0;
  unsigned __int8 v10 = KeyedDecodingContainer.decode(_:forKey:)((char *)&v17 + 1, v3);
  char v16 = 1;
  unint64_t v11 = sub_1000E4F0C();
  KeyedDecodingContainer.decode<A>(_:forKey:)( &v17,  &type metadata for AWDLActionFrame.AirDrop.State,  &v16,  v3,  &type metadata for AWDLActionFrame.AirDrop.State,  v11);
  (*(void (**)(char *, uint64_t))(v4 + 8))(v6, v3);
  int v13 = v17;
  sub_100002AC4(a1);
  if (v13) {
    int v14 = 256;
  }
  else {
    int v14 = 0;
  }
  return v14 & 0xFFFFFF00 | v10;
}

void sub_1000DA8F0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  __asm { BR              X11 }

void sub_1000DA92C(int a1@<W8>)
{
  uint64_t v2 = 0LL;
  while (((v1 >> v2) & 1) == 0)
  {
    if (++v2 == 32) {
      __asm { BR              X12 }
    }
  }

  __asm { BR              X14 }

uint64_t sub_1000DAA9C(void *a1)
{
  uint64_t v3 = a1[3];
  uint64_t v4 = a1[4];
  sub_100021104(a1, v3);
  dispatch thunk of Decoder.unkeyedContainer()(v30, v3, v4);
  if (v1) {
    return sub_100002AC4(a1);
  }
  uint64_t v5 = v31;
  uint64_t v6 = v32;
  sub_1000237C8((uint64_t)v30, v31);
  unint64_t v7 = sub_1000E4E40();
  UnkeyedDecodingContainer.inferredDecode<A>()(v5, (uint64_t)&type metadata for AWDLActionFrame.OUIType, v6, v7);
  uint64_t v8 = v31;
  uint64_t v9 = v32;
  sub_1000237C8((uint64_t)v30, v31);
  unint64_t v10 = sub_1000E4E84();
  UnkeyedDecodingContainer.inferredDecode<A>()(v8, (uint64_t)&type metadata for AWDLActionFrame.AWDLVersion, v9, v10);
  uint64_t v11 = v33;
  uint64_t v12 = v31;
  uint64_t v13 = v32;
  sub_1000237C8((uint64_t)v30, v31);
  unint64_t v14 = sub_1000E4EC8();
  UnkeyedDecodingContainer.inferredDecode<A>()(v12, (uint64_t)&type metadata for AWDLActionFrame.OUISubtype, v13, v14);
  int v15 = v33;
  uint64_t v16 = v31;
  uint64_t v17 = v32;
  sub_1000237C8((uint64_t)v30, v31);
  UnkeyedDecodingContainer.inferredDecode<A>()( v16,  (uint64_t)&type metadata for UInt8,  v17,  (uint64_t)&protocol witness table for UInt8);
  uint64_t v18 = v33;
  uint64_t v19 = v31;
  uint64_t v20 = v32;
  sub_1000237C8((uint64_t)v30, v31);
  UnkeyedDecodingContainer.inferredDecode<A>()( v19,  (uint64_t)&type metadata for UInt32,  v20,  (uint64_t)&protocol witness table for UInt32);
  uint64_t v21 = v33;
  uint64_t v22 = v31;
  uint64_t v23 = v32;
  sub_1000237C8((uint64_t)v30, v31);
  UnkeyedDecodingContainer.inferredDecode<A>()( v22,  (uint64_t)&type metadata for UInt32,  v23,  (uint64_t)&protocol witness table for UInt32);
  uint64_t v25 = v31;
  uint64_t v29 = v32;
  sub_1000237C8((uint64_t)v30, v31);
  uint64_t v26 = type metadata accessor for AWDLActionFrame.AWDLAttribute(0LL);
  uint64_t v27 = sub_10000AF70( &qword_100407CD0,  type metadata accessor for AWDLActionFrame.AWDLAttribute,  (uint64_t)&protocol conformance descriptor for AWDLActionFrame.AWDLAttribute);
  UnkeyedDecodingContainer.inferredArrayDecode<A>()(v25, v26, v29, v27);
  sub_100002AC4(v30);
  sub_100002AC4(a1);
  uint64_t v28 = 256LL;
  if (!v15) {
    uint64_t v28 = 0LL;
  }
  return v28 | v11 | (v18 << 16) | (v21 << 32);
}

void *sub_1000DAD6C(void *a1)
{
  uint64_t v3 = a1[3];
  uint64_t v4 = a1[4];
  uint64_t v5 = sub_100021104(a1, v3);
  dispatch thunk of Decoder.unkeyedContainer()(v19, v3, v4);
  if (v1)
  {
    sub_100002AC4(a1);
  }

  else
  {
    uint64_t v6 = v20;
    uint64_t v7 = v21;
    sub_1000237C8((uint64_t)v19, v20);
    uint64_t v8 = dispatch thunk of UnkeyedDecodingContainer.decode(_:)(v6, v7);
    uint64_t v10 = v8;
    if ((_DWORD)v8)
    {
      uint64_t v11 = v20;
      uint64_t v12 = v21;
      sub_1000237C8((uint64_t)v19, v20);
      unint64_t v13 = sub_1000702C8();
      dispatch thunk of UnkeyedDecodingContainer.decode<A>(_:)( &type metadata for Data,  &type metadata for Data,  v13,  v11,  v12);
      uint64_t v14 = v17;
      unint64_t v15 = v18;
    }

    else
    {
      uint64_t v14 = 0LL;
      unint64_t v15 = 0xC000000000000000LL;
    }

    sub_1000DA8F0(v10, v14, v15);
    uint64_t v5 = v16;
    sub_1000208D8(v14, v15);
    sub_100002AC4(v19);
    sub_100002AC4(a1);
  }

  return v5;
}

uint64_t sub_1000DAED8@<X0>(void *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v6 = a1[3];
  uint64_t v7 = a1[4];
  sub_100021104(a1, v6);
  dispatch thunk of Decoder.unkeyedContainer()(v32, v6, v7);
  if (v2) {
    return sub_100002AC4(a1);
  }
  uint64_t v8 = v33;
  uint64_t v9 = v34;
  sub_1000237C8((uint64_t)v32, v33);
  unint64_t v10 = sub_1000E4FD8();
  UnkeyedDecodingContainer.inferredDecode<A>()( v8,  (uint64_t)&type metadata for AWDLActionFrame.RealtimeGroup.Flags,  v9,  v10);
  uint64_t v11 = v33;
  uint64_t v12 = v34;
  sub_1000237C8((uint64_t)v32, v33);
  unint64_t v13 = sub_1000290F8();
  UnkeyedDecodingContainer.inferredDecode<A>()(v11, (uint64_t)&type metadata for WiFiAddress, v12, v13);
  v3.i32[0]  = v30;
  uint64_t v14 = v33;
  uint64_t v15 = v34;
  sub_1000237C8((uint64_t)v32, v33);
  unsigned __int8 v16 = dispatch thunk of UnkeyedDecodingContainer.decode(_:)(v14, v15);
  unint64_t v17 = sub_1001889D8(v16);
  uint64_t v18 = v33;
  uint64_t v19 = v34;
  sub_1000237C8((uint64_t)v32, v33);
  LOBYTE(v18)  = dispatch thunk of UnkeyedDecodingContainer.decode(_:)(v18, v19);
  uint64_t v20 = v33;
  uint64_t v21 = v34;
  sub_1000237C8((uint64_t)v32, v33);
  unint64_t v22 = sub_1000E501C();
  UnkeyedDecodingContainer.inferredDecode<A>()( v20,  (uint64_t)&type metadata for AWDLActionFrame.RealtimeGroup.AdditionalFlags,  v21,  v22);
  uint64_t v24 = v33;
  uint64_t v23 = v34;
  sub_1000237C8((uint64_t)v32, v33);
  unsigned __int8 v25 = dispatch thunk of UnkeyedDecodingContainer.decode(_:)(v24, v23);
  unint64_t v26 = sub_1001889D8(v25);
  uint64_t v27 = v33;
  uint64_t v28 = v34;
  sub_1000237C8((uint64_t)v32, v33);
  UnkeyedDecodingContainer.inferredDecode<A>()(v27, (uint64_t)&type metadata for WiFiAddress, v28, v13);
  sub_100002AC4(v32);
  uint64_t result = sub_100002AC4(a1);
  *(_BYTE *)a2  = v30;
  *(_DWORD *)(a2 + 1)  = vmovn_s16((int16x8_t)vmovl_u8(v3)).u32[0];
  *(_WORD *)(a2 + 5)  = v31;
  *(_WORD *)(a2 + 12)  = WORD2(v17);
  *(_DWORD *)(a2 + 8)  = v17;
  *(void *)(a2 + 16)  = (char)v18;
  *(_BYTE *)(a2 + 24)  = v30;
  *(_WORD *)(a2 + 32)  = WORD2(v26);
  *(_DWORD *)(a2 + 28)  = v26;
  *(_DWORD *)(a2 + 34)  = v30;
  *(_WORD *)(a2 + 38)  = v31;
  return result;
}

uint64_t sub_1000DB1B4(void *a1)
{
  uint64_t v3 = a1[3];
  uint64_t v4 = a1[4];
  uint64_t v5 = sub_100021104(a1, v3);
  dispatch thunk of Decoder.unkeyedContainer()(v22, v3, v4);
  if (v1)
  {
    sub_100002AC4(a1);
    return (uint64_t)v5;
  }

  uint64_t v6 = v23;
  uint64_t v7 = v24;
  sub_1000237C8((uint64_t)v22, v23);
  uint64_t result = dispatch thunk of UnkeyedDecodingContainer.decode(_:)(v6, v7);
  __int16 v9 = result + 1;
  if ((v9 & 0x100) == 0)
  {
    uint64_t v10 = v23;
    uint64_t v11 = v24;
    sub_1000237C8((uint64_t)v22, v23);
    unint64_t v12 = sub_1000E5458();
    dispatch thunk of UnkeyedDecodingContainer.decode<A>(_:)( &type metadata for AWDLActionFrame.AWDLChannelSequenceParameter.Encoding,  &type metadata for AWDLActionFrame.AWDLChannelSequenceParameter.Encoding,  v12,  v10,  v11);
    int v13 = v25;
    uint64_t v14 = v23;
    uint64_t v15 = v24;
    sub_1000237C8((uint64_t)v22, v23);
    dispatch thunk of UnkeyedDecodingContainer.decode(_:)(v14, v15);
    uint64_t v16 = v23;
    uint64_t v17 = v24;
    sub_1000237C8((uint64_t)v22, v23);
    dispatch thunk of UnkeyedDecodingContainer.decode(_:)(v16, v17);
    uint64_t v18 = v23;
    uint64_t v19 = v24;
    sub_1000237C8((uint64_t)v22, v23);
    dispatch thunk of UnkeyedDecodingContainer.decode(_:)(v18, v19);
    __int16 v20 = v9 << 8;
    if ((v13 - 2) >= 2)
    {
      if (v13) {
        sub_1000C07A4(v20, (uint64_t)v22);
      }
      else {
        sub_1000C03A8(v20, (uint64_t)v22);
      }
    }

    else
    {
      uint64_t v21 = sub_1000C090C(v20, (uint64_t)v22);
    }

    uint64_t v5 = v21;
    sub_100002AC4(v22);
    sub_100002AC4(a1);
    return (uint64_t)v5;
  }

  __break(1u);
  return result;
}

uint64_t sub_1000DB390(uint64_t a1)
{
  return a1;
}

unint64_t sub_1000DB3B8()
{
  unint64_t result = qword_100407418;
  if (!qword_100407418)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for AWDLElectionMetric,  &type metadata for AWDLElectionMetric);
    atomic_store(result, (unint64_t *)&qword_100407418);
  }

  return result;
}

unint64_t sub_1000DB3FC()
{
  unint64_t result = qword_100407428;
  if (!qword_100407428)
  {
    unint64_t result = swift_getWitnessTable(&unk_100344ABC, &type metadata for AWDLActionFrame.ServiceParameter.SSTH.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_100407428);
  }

  return result;
}

unint64_t sub_1000DB440()
{
  unint64_t result = qword_100407438;
  if (!qword_100407438)
  {
    unint64_t result = swift_getWitnessTable(&unk_100344A6C, &type metadata for AWDLActionFrame.ServiceParameter.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_100407438);
  }

  return result;
}

unint64_t sub_1000DB484()
{
  unint64_t result = qword_100407440;
  if (!qword_100407440)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for AWDLActionFrame.ServiceParameter.Flags,  &type metadata for AWDLActionFrame.ServiceParameter.Flags);
    atomic_store(result, (unint64_t *)&qword_100407440);
  }

  return result;
}

unint64_t sub_1000DB4C8()
{
  unint64_t result = qword_100407448;
  if (!qword_100407448)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for AWDLActionFrame.ServiceParameter.SSTH,  &type metadata for AWDLActionFrame.ServiceParameter.SSTH);
    atomic_store(result, (unint64_t *)&qword_100407448);
  }

  return result;
}

uint64_t sub_1000DB50C(void *a1)
{
  uint64_t v3 = type metadata accessor for String.Encoding(0LL);
  __chkstk_darwin(v3);
  uint64_t v5 = (char *)&v28[-1] - ((v4 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v6 = a1[3];
  uint64_t v7 = a1[4];
  sub_100021104(a1, v6);
  dispatch thunk of Decoder.unkeyedContainer()(v28, v6, v7);
  if (!v1)
  {
    uint64_t v8 = v29;
    uint64_t v9 = v30;
    sub_1000237C8((uint64_t)v28, v29);
    unint64_t v10 = sub_1000E5238();
    dispatch thunk of UnkeyedDecodingContainer.decode<A>(_:)( &type metadata for AWDLActionFrame.Arpa.Flags,  &type metadata for AWDLActionFrame.Arpa.Flags,  v10,  v8,  v9);
    uint64_t v6 = v31;
    uint64_t v11 = v29;
    uint64_t v12 = v30;
    sub_1000237C8((uint64_t)v28, v29);
    unsigned __int8 v13 = dispatch thunk of UnkeyedDecodingContainer.decode(_:)(v11, v12);
    uint64_t v14 = v13;
    uint64_t v15 = v29;
    uint64_t v16 = v30;
    sub_1000237C8((uint64_t)v28, v29);
    uint64_t v17 = UnkeyedDecodingContainer.decodeData(with:)(v14, v15, v16);
    uint64_t v20 = v17;
    unint64_t v21 = v18;
    static String.Encoding.utf8.getter(v17);
    String.init(data:encoding:)(v20, v21, v5);
    uint64_t v23 = v22;
    sub_1000208D8(v20, v21);
    if (v23)
    {
      sub_100002AC4(v28);
      sub_100002AC4(a1);
      return v6;
    }

    unint64_t v24 = sub_1000033FC();
    uint64_t v25 = swift_allocError(&type metadata for WiFiError, v24, 0LL, 0LL);
    *(_OWORD *)uint64_t v26 = xmmword_100337020;
    *(_BYTE *)(v26 + 16)  = 2;
    swift_willThrow(v25);
    sub_100002AC4(v28);
  }

  sub_100002AC4(a1);
  return v6;
}

unint64_t sub_1000DB708(void *a1)
{
  uint64_t v3 = a1[3];
  uint64_t v4 = a1[4];
  sub_100021104(a1, v3);
  dispatch thunk of Decoder.unkeyedContainer()(v17, v3, v4);
  if (v1) {
    return sub_100002AC4(a1);
  }
  uint64_t v5 = v18;
  uint64_t v6 = v19;
  sub_1000237C8((uint64_t)v17, v18);
  unint64_t v7 = sub_1000E527C();
  UnkeyedDecodingContainer.inferredDecode<A>()( v5,  (uint64_t)&type metadata for AWDLActionFrame.ServiceParameter.Flags,  v6,  v7);
  uint64_t v8 = v18;
  uint64_t v9 = v19;
  sub_1000237C8((uint64_t)v17, v18);
  UnkeyedDecodingContainer.inferredDecode<A>()( v8,  (uint64_t)&type metadata for UInt16,  v9,  (uint64_t)&protocol witness table for UInt16);
  uint64_t v10 = v18;
  uint64_t v11 = v19;
  sub_1000237C8((uint64_t)v17, v18);
  UnkeyedDecodingContainer.inferredDecode<A>()( v10,  (uint64_t)&type metadata for UInt16,  v11,  (uint64_t)&protocol witness table for UInt16);
  uint64_t v12 = v18;
  uint64_t v13 = v19;
  sub_1000237C8((uint64_t)v17, v18);
  unint64_t v14 = sub_1000E52C0();
  UnkeyedDecodingContainer.inferredDecode<A>()( v12,  (uint64_t)&type metadata for AWDLActionFrame.ServiceParameter.SSTH,  v13,  v14);
  sub_100002AC4(v17);
  sub_100002AC4(a1);
  return v16 | ((unint64_t)v16 << 16) | ((unint64_t)v16 << 32);
}

uint64_t type metadata accessor for AWDLActionFrame.DataPathState(uint64_t a1)
{
  return sub_100020E48( a1,  (uint64_t *)&unk_1004078C0,  (uint64_t)&nominal type descriptor for AWDLActionFrame.DataPathState);
}

uint64_t sub_1000DB8E8(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = sub_100002274(&qword_100407450);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v4 - 8) + 16LL))(a2, a1, v4);
  return a2;
}

uint64_t sub_1000DB930(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = sub_100002274(&qword_100407450);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v4 - 8) + 40LL))(a2, a1, v4);
  return a2;
}

unint64_t sub_1000DB978()
{
  unint64_t result = qword_100407458;
  if (!qword_100407458)
  {
    unint64_t result = swift_getWitnessTable(&unk_100344A44, &type metadata for AWDLActionFrame.DataPathState.Flags);
    atomic_store(result, (unint64_t *)&qword_100407458);
  }

  return result;
}

unint64_t sub_1000DB9BC()
{
  unint64_t result = qword_100407460;
  if (!qword_100407460)
  {
    unint64_t result = swift_getWitnessTable(&unk_100344A1C, &type metadata for AWDLActionFrame.DataPathState.ExtensionFlags);
    atomic_store(result, (unint64_t *)&qword_100407460);
  }

  return result;
}

unint64_t sub_1000DBA00()
{
  unint64_t result = qword_100407468;
  if (!qword_100407468)
  {
    unint64_t result = swift_getWitnessTable(&unk_1003449F4, &type metadata for AWDLActionFrame.DataPathState.Flags);
    atomic_store(result, (unint64_t *)&qword_100407468);
  }

  return result;
}

unint64_t sub_1000DBA44()
{
  unint64_t result = qword_100407470;
  if (!qword_100407470)
  {
    unint64_t result = swift_getWitnessTable(&unk_1003449CC, &type metadata for AWDLActionFrame.DataPathState.ExtensionFlags);
    atomic_store(result, (unint64_t *)&qword_100407470);
  }

  return result;
}

unint64_t sub_1000DBA88()
{
  unint64_t result = qword_100407478;
  if (!qword_100407478)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for AWDLActionFrame.Arpa.Flags,  &type metadata for AWDLActionFrame.Arpa.Flags);
    atomic_store(result, (unint64_t *)&qword_100407478);
  }

  return result;
}

unint64_t sub_1000DBACC()
{
  unint64_t result = qword_100407488;
  if (!qword_100407488)
  {
    unint64_t result = swift_getWitnessTable(&unk_10034497C, &type metadata for AWDLActionFrame.SyncTreePath.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_100407488);
  }

  return result;
}

unint64_t sub_1000DBB10()
{
  unint64_t result = qword_1004074A8;
  if (!qword_1004074A8)
  {
    unint64_t result = swift_getWitnessTable(&unk_10034492C, &type metadata for AWDLActionFrame.AWDLVersion.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_1004074A8);
  }

  return result;
}

unint64_t sub_1000DBB54()
{
  unint64_t result = qword_1004074C0;
  if (!qword_1004074C0)
  {
    unint64_t result = swift_getWitnessTable(&unk_1003448DC, &type metadata for AWDLActionFrame.Version.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_1004074C0);
  }

  return result;
}

unint64_t sub_1000DBB98()
{
  unint64_t result = qword_1004074C8;
  if (!qword_1004074C8)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for AWDLActionFrame.AWDLVersion,  &type metadata for AWDLActionFrame.AWDLVersion);
    atomic_store(result, (unint64_t *)&qword_1004074C8);
  }

  return result;
}

unint64_t sub_1000DBBDC()
{
  unint64_t result = qword_1004074D8;
  if (!qword_1004074D8)
  {
    unint64_t result = swift_getWitnessTable( &unk_10034488C,  &type metadata for AWDLActionFrame.PeerMACAddressListBloomFilter.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_1004074D8);
  }

  return result;
}

unint64_t sub_1000DBC20()
{
  unint64_t result = qword_1004074E8;
  if (!qword_1004074E8)
  {
    unint64_t result = swift_getWitnessTable(&unk_10034483C, &type metadata for AWDLActionFrame.NANSynchronization.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_1004074E8);
  }

  return result;
}

unint64_t sub_1000DBC64()
{
  unint64_t result = qword_1004074F0;
  if (!qword_1004074F0)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for NANTimeSynchronizationFunction,  &type metadata for NANTimeSynchronizationFunction);
    atomic_store(result, (unint64_t *)&qword_1004074F0);
  }

  return result;
}

unint64_t sub_1000DBCA8()
{
  unint64_t result = qword_1004074F8;
  if (!qword_1004074F8)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for NANAttribute.MasterIndication,  &type metadata for NANAttribute.MasterIndication);
    atomic_store(result, (unint64_t *)&qword_1004074F8);
  }

  return result;
}

uint64_t sub_1000DBCEC(int *a1, uint64_t a2)
{
  return a2;
}

unint64_t sub_1000DBD28()
{
  unint64_t result = qword_100407508;
  if (!qword_100407508)
  {
    unint64_t result = swift_getWitnessTable(&unk_1003447EC, &type metadata for AWDLActionFrame.ElectionParameter.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_100407508);
  }

  return result;
}

unint64_t sub_1000DBD6C()
{
  unint64_t result = qword_100407518;
  if (!qword_100407518)
  {
    unint64_t result = swift_getWitnessTable(&unk_10034479C, &type metadata for AWDLActionFrame.MultiPeerBSSSteering.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_100407518);
  }

  return result;
}

unint64_t sub_1000DBDB0()
{
  unint64_t result = qword_100407520;
  if (!qword_100407520)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for AWDLActionFrame.MultiPeerBSSSteering.SteeringMessageID,  &type metadata for AWDLActionFrame.MultiPeerBSSSteering.SteeringMessageID);
    atomic_store(result, (unint64_t *)&qword_100407520);
  }

  return result;
}

unint64_t sub_1000DBDF4()
{
  unint64_t result = qword_100407530;
  if (!qword_100407530)
  {
    unint64_t result = swift_getWitnessTable(&unk_10034474C, &type metadata for AWDLActionFrame.Ranging.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_100407530);
  }

  return result;
}

unint64_t sub_1000DBE38()
{
  unint64_t result = qword_100407538;
  if (!qword_100407538)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for AWDLActionFrame.RealtimeGroup.Flags,  &type metadata for AWDLActionFrame.RealtimeGroup.Flags);
    atomic_store(result, (unint64_t *)&qword_100407538);
  }

  return result;
}

uint64_t sub_1000DBE7C(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = sub_100002274((uint64_t *)&unk_10040FD40);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v4 - 8) + 32LL))(a2, a1, v4);
  return a2;
}

unint64_t sub_1000DBEC4()
{
  unint64_t result = qword_100407540;
  if (!qword_100407540)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for AWDLActionFrame.RealtimeGroup.AdditionalFlags,  &type metadata for AWDLActionFrame.RealtimeGroup.AdditionalFlags);
    atomic_store(result, (unint64_t *)&qword_100407540);
  }

  return result;
}

unint64_t sub_1000DBF08()
{
  unint64_t result = qword_100407550;
  if (!qword_100407550)
  {
    unint64_t result = swift_getWitnessTable( &unk_1003446FC,  &type metadata for AWDLActionFrame.ExtendedChannelSequence.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_100407550);
  }

  return result;
}

unint64_t sub_1000DBF4C()
{
  unint64_t result = qword_100407560;
  if (!qword_100407560)
  {
    unint64_t result = swift_getWitnessTable(&unk_1003446AC, &type metadata for AWDLActionFrame.ProMode.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_100407560);
  }

  return result;
}

unint64_t sub_1000DBF90()
{
  unint64_t result = qword_100407568;
  if (!qword_100407568)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for AWDLActionFrame.ProMode.Command,  &type metadata for AWDLActionFrame.ProMode.Command);
    atomic_store(result, (unint64_t *)&qword_100407568);
  }

  return result;
}

unint64_t sub_1000DBFD4()
{
  unint64_t result = qword_100407570;
  if (!qword_100407570)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for AWDLActionFrame.ProMode.Flags,  &type metadata for AWDLActionFrame.ProMode.Flags);
    atomic_store(result, (unint64_t *)&qword_100407570);
  }

  return result;
}

unint64_t sub_1000DC018()
{
  unint64_t result = qword_100407580;
  if (!qword_100407580)
  {
    unint64_t result = swift_getWitnessTable(&unk_10034465C, &type metadata for AWDLActionFrame.AirDrop.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_100407580);
  }

  return result;
}

unint64_t sub_1000DC05C()
{
  unint64_t result = qword_100407588;
  if (!qword_100407588)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for AWDLActionFrame.AirDrop.State,  &type metadata for AWDLActionFrame.AirDrop.State);
    atomic_store(result, (unint64_t *)&qword_100407588);
  }

  return result;
}

uint64_t type metadata accessor for AWDLActionFrame.AWDLAttribute(uint64_t a1)
{
  return sub_100020E48(a1, qword_1004079F0, (uint64_t)&nominal type descriptor for AWDLActionFrame.AWDLAttribute);
}

unint64_t sub_1000DC0B4()
{
  unint64_t result = qword_100407590;
  if (!qword_100407590)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for AWDLActionFrame.AWDLAttribute.AttributeType,  &type metadata for AWDLActionFrame.AWDLAttribute.AttributeType);
    atomic_store(result, (unint64_t *)&qword_100407590);
  }

  return result;
}

uint64_t sub_1000DC0F8(uint64_t a1)
{
  return a1;
}

unint64_t sub_1000DC120()
{
  unint64_t result = qword_1004075C8;
  if (!qword_1004075C8)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for AWDLActionFrame.OUIType,  &type metadata for AWDLActionFrame.OUIType);
    atomic_store(result, (unint64_t *)&qword_1004075C8);
  }

  return result;
}

unint64_t sub_1000DC164()
{
  unint64_t result = qword_1004075D0;
  if (!qword_1004075D0)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for AWDLActionFrame.OUISubtype,  &type metadata for AWDLActionFrame.OUISubtype);
    atomic_store(result, (unint64_t *)&qword_1004075D0);
  }

  return result;
}

unint64_t sub_1000DC1A8()
{
  unint64_t result = qword_1004075E0;
  if (!qword_1004075E0)
  {
    uint64_t v1 = sub_1000022F8(&qword_1004075D8);
    sub_10000AF70( &qword_1004075E8,  type metadata accessor for AWDLActionFrame.AWDLAttribute,  (uint64_t)&protocol conformance descriptor for AWDLActionFrame.AWDLAttribute);
    unint64_t result = swift_getWitnessTable(&protocol conformance descriptor for <A> [A], v1);
    atomic_store(result, (unint64_t *)&qword_1004075E0);
  }

  return result;
}

uint64_t type metadata accessor for AWDLActionFrame.Header(uint64_t a1)
{
  return sub_100020E48(a1, qword_100407A80, (uint64_t)&nominal type descriptor for AWDLActionFrame.Header);
}

unint64_t sub_1000DC23C()
{
  unint64_t result = qword_1004075F0;
  if (!qword_1004075F0)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for AWDLActionFrame.OUIType,  &type metadata for AWDLActionFrame.OUIType);
    atomic_store(result, (unint64_t *)&qword_1004075F0);
  }

  return result;
}

unint64_t sub_1000DC284()
{
  unint64_t result = qword_1004075F8;
  if (!qword_1004075F8)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for AWDLActionFrame.OUISubtype,  &type metadata for AWDLActionFrame.OUISubtype);
    atomic_store(result, (unint64_t *)&qword_1004075F8);
  }

  return result;
}

unint64_t sub_1000DC2CC()
{
  unint64_t result = qword_100407600;
  if (!qword_100407600)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for AWDLActionFrame.ServiceRequest,  &type metadata for AWDLActionFrame.ServiceRequest);
    atomic_store(result, (unint64_t *)&qword_100407600);
  }

  return result;
}

uint64_t sub_1000DC310()
{
  return sub_10000AF70( &qword_100407608,  type metadata accessor for AWDLActionFrame.ServiceResponse,  (uint64_t)&protocol conformance descriptor for AWDLActionFrame.ServiceResponse);
}

unint64_t sub_1000DC340()
{
  unint64_t result = qword_100407610;
  if (!qword_100407610)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for AWDLActionFrame.AWDLChannelSequenceParameter,  &type metadata for AWDLActionFrame.AWDLChannelSequenceParameter);
    atomic_store(result, (unint64_t *)&qword_100407610);
  }

  return result;
}

unint64_t sub_1000DC388()
{
  unint64_t result = qword_100407618;
  if (!qword_100407618)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for AWDLActionFrame.SynchronizationParameter,  &type metadata for AWDLActionFrame.SynchronizationParameter);
    atomic_store(result, (unint64_t *)&qword_100407618);
  }

  return result;
}

unint64_t sub_1000DC3D0()
{
  unint64_t result = qword_100407620;
  if (!qword_100407620)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for AWDLActionFrame.DeprecatedElectionParameter,  &type metadata for AWDLActionFrame.DeprecatedElectionParameter);
    atomic_store(result, (unint64_t *)&qword_100407620);
  }

  return result;
}

unint64_t sub_1000DC418()
{
  unint64_t result = qword_100407628;
  if (!qword_100407628)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for AWDLActionFrame.ServiceParameter.Flags,  &type metadata for AWDLActionFrame.ServiceParameter.Flags);
    atomic_store(result, (unint64_t *)&qword_100407628);
  }

  return result;
}

unint64_t sub_1000DC460()
{
  unint64_t result = qword_100407630;
  if (!qword_100407630)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for AWDLActionFrame.ServiceParameter.Flags,  &type metadata for AWDLActionFrame.ServiceParameter.Flags);
    atomic_store(result, (unint64_t *)&qword_100407630);
  }

  return result;
}

unint64_t sub_1000DC4A8()
{
  unint64_t result = qword_100407638;
  if (!qword_100407638)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for AWDLActionFrame.ServiceParameter.Flags,  &type metadata for AWDLActionFrame.ServiceParameter.Flags);
    atomic_store(result, (unint64_t *)&qword_100407638);
  }

  return result;
}

unint64_t sub_1000DC4F0()
{
  unint64_t result = qword_100407640;
  if (!qword_100407640)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for AWDLActionFrame.ServiceParameter.Flags,  &type metadata for AWDLActionFrame.ServiceParameter.Flags);
    atomic_store(result, (unint64_t *)&qword_100407640);
  }

  return result;
}

unint64_t sub_1000DC538()
{
  unint64_t result = qword_100407648;
  if (!qword_100407648)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for AWDLActionFrame.ServiceParameter.SSTH,  &type metadata for AWDLActionFrame.ServiceParameter.SSTH);
    atomic_store(result, (unint64_t *)&qword_100407648);
  }

  return result;
}

unint64_t sub_1000DC580()
{
  unint64_t result = qword_100407650;
  if (!qword_100407650)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for AWDLActionFrame.ServiceParameter,  &type metadata for AWDLActionFrame.ServiceParameter);
    atomic_store(result, (unint64_t *)&qword_100407650);
  }

  return result;
}

unint64_t sub_1000DC5C8()
{
  unint64_t result = qword_100407658;
  if (!qword_100407658)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for AWDLActionFrame.DataPathState.UnicastMasterIndicationOptions,  &type metadata for AWDLActionFrame.DataPathState.UnicastMasterIndicationOptions);
    atomic_store(result, (unint64_t *)&qword_100407658);
  }

  return result;
}

uint64_t sub_1000DC60C()
{
  return sub_10000AF70( &qword_100407660,  type metadata accessor for AWDLActionFrame.DataPathState,  (uint64_t)&protocol conformance descriptor for AWDLActionFrame.DataPathState);
}

unint64_t sub_1000DC63C()
{
  unint64_t result = qword_100407668;
  if (!qword_100407668)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for AWDLActionFrame.Arpa.Flags,  &type metadata for AWDLActionFrame.Arpa.Flags);
    atomic_store(result, (unint64_t *)&qword_100407668);
  }

  return result;
}

unint64_t sub_1000DC684()
{
  unint64_t result = qword_100407670;
  if (!qword_100407670)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for AWDLActionFrame.Arpa.Flags,  &type metadata for AWDLActionFrame.Arpa.Flags);
    atomic_store(result, (unint64_t *)&qword_100407670);
  }

  return result;
}

unint64_t sub_1000DC6CC()
{
  unint64_t result = qword_100407678;
  if (!qword_100407678)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for AWDLActionFrame.Arpa.Flags,  &type metadata for AWDLActionFrame.Arpa.Flags);
    atomic_store(result, (unint64_t *)&qword_100407678);
  }

  return result;
}

unint64_t sub_1000DC714()
{
  unint64_t result = qword_100407680;
  if (!qword_100407680)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for AWDLActionFrame.Arpa.Flags,  &type metadata for AWDLActionFrame.Arpa.Flags);
    atomic_store(result, (unint64_t *)&qword_100407680);
  }

  return result;
}

unint64_t sub_1000DC75C()
{
  unint64_t result = qword_100407688;
  if (!qword_100407688)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for AWDLActionFrame.Arpa,  &type metadata for AWDLActionFrame.Arpa);
    atomic_store(result, (unint64_t *)&qword_100407688);
  }

  return result;
}

unint64_t sub_1000DC7A4()
{
  unint64_t result = qword_100407690;
  if (!qword_100407690)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for AWDLActionFrame.SyncTreePath,  &type metadata for AWDLActionFrame.SyncTreePath);
    atomic_store(result, (unint64_t *)&qword_100407690);
  }

  return result;
}

unint64_t sub_1000DC7EC()
{
  unint64_t result = qword_100407698;
  if (!qword_100407698)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for AWDLActionFrame.AWDLVersion,  &type metadata for AWDLActionFrame.AWDLVersion);
    atomic_store(result, (unint64_t *)&qword_100407698);
  }

  return result;
}

unint64_t sub_1000DC834()
{
  unint64_t result = qword_1004076A0;
  if (!qword_1004076A0)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for AWDLActionFrame.Version.PlatformType,  &type metadata for AWDLActionFrame.Version.PlatformType);
    atomic_store(result, (unint64_t *)&qword_1004076A0);
  }

  return result;
}

unint64_t sub_1000DC87C()
{
  unint64_t result = qword_1004076A8;
  if (!qword_1004076A8)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for AWDLActionFrame.Version,  &type metadata for AWDLActionFrame.Version);
    atomic_store(result, (unint64_t *)&qword_1004076A8);
  }

  return result;
}

unint64_t sub_1000DC8C4()
{
  unint64_t result = qword_1004076B0;
  if (!qword_1004076B0)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for AWDLActionFrame.PeerMACAddressListBloomFilter,  &type metadata for AWDLActionFrame.PeerMACAddressListBloomFilter);
    atomic_store(result, (unint64_t *)&qword_1004076B0);
  }

  return result;
}

unint64_t sub_1000DC90C()
{
  unint64_t result = qword_1004076B8;
  if (!qword_1004076B8)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for AWDLActionFrame.NANSynchronization,  &type metadata for AWDLActionFrame.NANSynchronization);
    atomic_store(result, (unint64_t *)&qword_1004076B8);
  }

  return result;
}

unint64_t sub_1000DC954()
{
  unint64_t result = qword_1004076C0;
  if (!qword_1004076C0)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for AWDLActionFrame.ElectionParameter,  &type metadata for AWDLActionFrame.ElectionParameter);
    atomic_store(result, (unint64_t *)&qword_1004076C0);
  }

  return result;
}

unint64_t sub_1000DC99C()
{
  unint64_t result = qword_1004076C8;
  if (!qword_1004076C8)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for AWDLActionFrame.MultiPeerBSSSteering.SteeringMessageID,  &type metadata for AWDLActionFrame.MultiPeerBSSSteering.SteeringMessageID);
    atomic_store(result, (unint64_t *)&qword_1004076C8);
  }

  return result;
}

unint64_t sub_1000DC9E4()
{
  unint64_t result = qword_1004076D0;
  if (!qword_1004076D0)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for AWDLActionFrame.MultiPeerBSSSteering,  &type metadata for AWDLActionFrame.MultiPeerBSSSteering);
    atomic_store(result, (unint64_t *)&qword_1004076D0);
  }

  return result;
}

unint64_t sub_1000DCA2C()
{
  unint64_t result = qword_1004076D8;
  if (!qword_1004076D8)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for AWDLActionFrame.Ranging,  &type metadata for AWDLActionFrame.Ranging);
    atomic_store(result, (unint64_t *)&qword_1004076D8);
  }

  return result;
}

unint64_t sub_1000DCA74()
{
  unint64_t result = qword_1004076E0;
  if (!qword_1004076E0)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for AWDLActionFrame.RealtimeGroup.Flags,  &type metadata for AWDLActionFrame.RealtimeGroup.Flags);
    atomic_store(result, (unint64_t *)&qword_1004076E0);
  }

  return result;
}

unint64_t sub_1000DCABC()
{
  unint64_t result = qword_1004076E8;
  if (!qword_1004076E8)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for AWDLActionFrame.RealtimeGroup.Flags,  &type metadata for AWDLActionFrame.RealtimeGroup.Flags);
    atomic_store(result, (unint64_t *)&qword_1004076E8);
  }

  return result;
}

unint64_t sub_1000DCB04()
{
  unint64_t result = qword_1004076F0;
  if (!qword_1004076F0)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for AWDLActionFrame.RealtimeGroup.Flags,  &type metadata for AWDLActionFrame.RealtimeGroup.Flags);
    atomic_store(result, (unint64_t *)&qword_1004076F0);
  }

  return result;
}

unint64_t sub_1000DCB4C()
{
  unint64_t result = qword_1004076F8;
  if (!qword_1004076F8)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for AWDLActionFrame.RealtimeGroup.Flags,  &type metadata for AWDLActionFrame.RealtimeGroup.Flags);
    atomic_store(result, (unint64_t *)&qword_1004076F8);
  }

  return result;
}

unint64_t sub_1000DCB94()
{
  unint64_t result = qword_100407700;
  if (!qword_100407700)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for AWDLActionFrame.RealtimeGroup.AdditionalFlags,  &type metadata for AWDLActionFrame.RealtimeGroup.AdditionalFlags);
    atomic_store(result, (unint64_t *)&qword_100407700);
  }

  return result;
}

unint64_t sub_1000DCBDC()
{
  unint64_t result = qword_100407708;
  if (!qword_100407708)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for AWDLActionFrame.RealtimeGroup.AdditionalFlags,  &type metadata for AWDLActionFrame.RealtimeGroup.AdditionalFlags);
    atomic_store(result, (unint64_t *)&qword_100407708);
  }

  return result;
}

unint64_t sub_1000DCC24()
{
  unint64_t result = qword_100407710;
  if (!qword_100407710)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for AWDLActionFrame.RealtimeGroup.AdditionalFlags,  &type metadata for AWDLActionFrame.RealtimeGroup.AdditionalFlags);
    atomic_store(result, (unint64_t *)&qword_100407710);
  }

  return result;
}

unint64_t sub_1000DCC6C()
{
  unint64_t result = qword_100407718;
  if (!qword_100407718)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for AWDLActionFrame.RealtimeGroup.AdditionalFlags,  &type metadata for AWDLActionFrame.RealtimeGroup.AdditionalFlags);
    atomic_store(result, (unint64_t *)&qword_100407718);
  }

  return result;
}

unint64_t sub_1000DCCB4()
{
  unint64_t result = qword_100407720;
  if (!qword_100407720)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for AWDLActionFrame.RealtimeGroup,  &type metadata for AWDLActionFrame.RealtimeGroup);
    atomic_store(result, (unint64_t *)&qword_100407720);
  }

  return result;
}

unint64_t sub_1000DCCFC()
{
  unint64_t result = qword_100407728;
  if (!qword_100407728)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for AWDLActionFrame.ExtendedChannelSequence,  &type metadata for AWDLActionFrame.ExtendedChannelSequence);
    atomic_store(result, (unint64_t *)&qword_100407728);
  }

  return result;
}

unint64_t sub_1000DCD44()
{
  unint64_t result = qword_100407730;
  if (!qword_100407730)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for AWDLActionFrame.PreferredChannels.PreferredChannel,  &type metadata for AWDLActionFrame.PreferredChannels.PreferredChannel);
    atomic_store(result, (unint64_t *)&qword_100407730);
  }

  return result;
}

unint64_t sub_1000DCD8C()
{
  unint64_t result = qword_100407738;
  if (!qword_100407738)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for AWDLActionFrame.PreferredChannels,  &type metadata for AWDLActionFrame.PreferredChannels);
    atomic_store(result, (unint64_t *)&qword_100407738);
  }

  return result;
}

unint64_t sub_1000DCDD4()
{
  unint64_t result = qword_100407740;
  if (!qword_100407740)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for AWDLActionFrame.ProMode.Command,  &type metadata for AWDLActionFrame.ProMode.Command);
    atomic_store(result, (unint64_t *)&qword_100407740);
  }

  return result;
}

unint64_t sub_1000DCE1C()
{
  unint64_t result = qword_100407748;
  if (!qword_100407748)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for AWDLActionFrame.ProMode.Flags,  &type metadata for AWDLActionFrame.ProMode.Flags);
    atomic_store(result, (unint64_t *)&qword_100407748);
  }

  return result;
}

unint64_t sub_1000DCE64()
{
  unint64_t result = qword_100407750;
  if (!qword_100407750)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for AWDLActionFrame.ProMode.Flags,  &type metadata for AWDLActionFrame.ProMode.Flags);
    atomic_store(result, (unint64_t *)&qword_100407750);
  }

  return result;
}

unint64_t sub_1000DCEAC()
{
  unint64_t result = qword_100407758;
  if (!qword_100407758)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for AWDLActionFrame.ProMode.Flags,  &type metadata for AWDLActionFrame.ProMode.Flags);
    atomic_store(result, (unint64_t *)&qword_100407758);
  }

  return result;
}

unint64_t sub_1000DCEF4()
{
  unint64_t result = qword_100407760;
  if (!qword_100407760)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for AWDLActionFrame.ProMode.Flags,  &type metadata for AWDLActionFrame.ProMode.Flags);
    atomic_store(result, (unint64_t *)&qword_100407760);
  }

  return result;
}

unint64_t sub_1000DCF3C()
{
  unint64_t result = qword_100407768;
  if (!qword_100407768)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for AWDLActionFrame.ProMode,  &type metadata for AWDLActionFrame.ProMode);
    atomic_store(result, (unint64_t *)&qword_100407768);
  }

  return result;
}

unint64_t sub_1000DCF84()
{
  unint64_t result = qword_100407770;
  if (!qword_100407770)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for AWDLActionFrame.AirDrop.State,  &type metadata for AWDLActionFrame.AirDrop.State);
    atomic_store(result, (unint64_t *)&qword_100407770);
  }

  return result;
}

unint64_t sub_1000DCFCC()
{
  unint64_t result = qword_100407778;
  if (!qword_100407778)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for AWDLActionFrame.AirDrop,  &type metadata for AWDLActionFrame.AirDrop);
    atomic_store(result, (unint64_t *)&qword_100407778);
  }

  return result;
}

unint64_t sub_1000DD014()
{
  unint64_t result = qword_100407780;
  if (!qword_100407780)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for AWDLActionFrame.AWDLAttribute.AttributeType,  &type metadata for AWDLActionFrame.AWDLAttribute.AttributeType);
    atomic_store(result, (unint64_t *)&qword_100407780);
  }

  return result;
}

uint64_t sub_1000DD058()
{
  return sub_10000AF70( &qword_100407788,  type metadata accessor for AWDLActionFrame.AWDLAttribute,  (uint64_t)&protocol conformance descriptor for AWDLActionFrame.AWDLAttribute);
}

unint64_t sub_1000DD088()
{
  unint64_t result = qword_100407790;
  if (!qword_100407790)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for AWDLActionFrame,  &type metadata for AWDLActionFrame);
    atomic_store(result, (unint64_t *)&qword_100407790);
  }

  return result;
}

unint64_t sub_1000DD0D0()
{
  unint64_t result = qword_100407798;
  if (!qword_100407798)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for AWDLActionFrame.Header.Flags,  &type metadata for AWDLActionFrame.Header.Flags);
    atomic_store(result, (unint64_t *)&qword_100407798);
  }

  return result;
}

unint64_t sub_1000DD118()
{
  unint64_t result = qword_1004077A0;
  if (!qword_1004077A0)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for AWDLActionFrame.Header.Flags,  &type metadata for AWDLActionFrame.Header.Flags);
    atomic_store(result, (unint64_t *)&qword_1004077A0);
  }

  return result;
}

unint64_t sub_1000DD160()
{
  unint64_t result = qword_1004077A8;
  if (!qword_1004077A8)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for AWDLActionFrame.Header.Flags,  &type metadata for AWDLActionFrame.Header.Flags);
    atomic_store(result, (unint64_t *)&qword_1004077A8);
  }

  return result;
}

unint64_t sub_1000DD1A8()
{
  unint64_t result = qword_1004077B0;
  if (!qword_1004077B0)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for AWDLActionFrame.Header.Flags,  &type metadata for AWDLActionFrame.Header.Flags);
    atomic_store(result, (unint64_t *)&qword_1004077B0);
  }

  return result;
}

uint64_t sub_1000DD1EC()
{
  return sub_10000AF70( &qword_1004077B8,  type metadata accessor for AWDLActionFrame.Header,  (uint64_t)&protocol conformance descriptor for AWDLActionFrame.Header);
}

uint64_t sub_1000DD21C(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)a1  = *(_BYTE *)a2;
  *(_BYTE *)(a1 + 1)  = *(_BYTE *)(a2 + 1);
  *(_BYTE *)(a1 + 2)  = *(_BYTE *)(a2 + 2);
  *(void *)(a1 + 4)  = *(void *)(a2 + 4);
  uint64_t v3 = *(void *)(a2 + 16);
  *(void *)(a1 + 16)  = v3;
  swift_bridgeObjectRetain(v3);
  return a1;
}

uint64_t assignWithCopy for AWDLActionFrame(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)a1  = *(_BYTE *)a2;
  *(_BYTE *)(a1 + 1)  = *(_BYTE *)(a2 + 1);
  *(_BYTE *)(a1 + 2)  = *(_BYTE *)(a2 + 2);
  *(_DWORD *)(a1 + 4)  = *(_DWORD *)(a2 + 4);
  *(_DWORD *)(a1 + 8)  = *(_DWORD *)(a2 + 8);
  uint64_t v3 = *(void *)(a2 + 16);
  uint64_t v4 = *(void *)(a1 + 16);
  *(void *)(a1 + 16)  = v3;
  swift_bridgeObjectRetain(v3);
  swift_bridgeObjectRelease(v4);
  return a1;
}

uint64_t assignWithTake for AWDLActionFrame(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)a1  = *(_BYTE *)a2;
  *(_BYTE *)(a1 + 1)  = *(_BYTE *)(a2 + 1);
  *(_BYTE *)(a1 + 2)  = *(_BYTE *)(a2 + 2);
  *(void *)(a1 + 4)  = *(void *)(a2 + 4);
  uint64_t v3 = *(void *)(a1 + 16);
  *(void *)(a1 + 16)  = *(void *)(a2 + 16);
  swift_bridgeObjectRelease(v3);
  return a1;
}

ValueMetadata *type metadata accessor for AWDLActionFrame()
{
  return &type metadata for AWDLActionFrame;
}

ValueMetadata *type metadata accessor for AWDLActionFrame.OUIType()
{
  return &type metadata for AWDLActionFrame.OUIType;
}

ValueMetadata *type metadata accessor for AWDLActionFrame.OUISubtype()
{
  return &type metadata for AWDLActionFrame.OUISubtype;
}

uint64_t initializeBufferWithCopyOfBuffer for Channel.ChannelBitmap(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)a1  = *(_DWORD *)a2;
  uint64_t v3 = *(void *)(a2 + 8);
  *(void *)(a1 + 8)  = v3;
  swift_bridgeObjectRetain(v3);
  return a1;
}

uint64_t assignWithCopy for AWDLActionFrame.ServiceRequest(uint64_t a1, uint64_t a2)
{
  *(_WORD *)a1  = *(_WORD *)a2;
  *(_WORD *)(a1 + 2)  = *(_WORD *)(a2 + 2);
  uint64_t v3 = *(void *)(a2 + 8);
  uint64_t v4 = *(void *)(a1 + 8);
  *(void *)(a1 + 8)  = v3;
  swift_bridgeObjectRetain(v3);
  swift_bridgeObjectRelease(v4);
  return a1;
}

uint64_t assignWithTake for AWDLActionFrame.ServiceRequest(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)a1  = *(_DWORD *)a2;
  uint64_t v3 = *(void *)(a1 + 8);
  *(void *)(a1 + 8)  = *(void *)(a2 + 8);
  swift_bridgeObjectRelease(v3);
  return a1;
}

ValueMetadata *type metadata accessor for AWDLActionFrame.ServiceRequest()
{
  return &type metadata for AWDLActionFrame.ServiceRequest;
}

uint64_t initializeBufferWithCopyOfBuffer for AWDLActionFrame.ServiceResponse( uint64_t a1, uint64_t *a2, uint64_t a3)
{
  int v5 = *(_DWORD *)(*(void *)(a3 - 8) + 80LL);
  if ((v5 & 0x20000) != 0)
  {
    uint64_t v15 = *a2;
    *(void *)a1  = *a2;
    a1  = v15 + ((v5 + 16LL) & ~(unint64_t)v5);
    swift_retain();
  }

  else
  {
    int EnumCaseMultiPayload = swift_getEnumCaseMultiPayload(a2, a3);
    if (EnumCaseMultiPayload == 2)
    {
      uint64_t v16 = a2[1];
      *(void *)a1  = *a2;
      *(void *)(a1 + 8)  = v16;
      uint64_t v17 = a2[3];
      *(void *)(a1 + 16)  = a2[2];
      *(void *)(a1 + 24)  = v17;
      *(_BYTE *)(a1 + 32)  = *((_BYTE *)a2 + 32);
      *(_BYTE *)(a1 + 33)  = *((_BYTE *)a2 + 33);
      uint64_t v18 = (int *)type metadata accessor for DNSRecords.SRV(0LL);
      uint64_t v19 = v18[5];
      uint64_t v20 = a1 + v19;
      uint64_t v21 = (uint64_t)a2 + v19;
      uint64_t v22 = type metadata accessor for NWEndpoint.Port(0LL);
      uint64_t v23 = *(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v22 - 8) + 16LL);
      swift_bridgeObjectRetain(v16);
      swift_bridgeObjectRetain(v17);
      v23(v20, v21, v22);
      uint64_t v24 = v18[6];
      uint64_t v25 = (void *)(a1 + v24);
      uint64_t v26 = (uint64_t *)((char *)a2 + v24);
      uint64_t v27 = v26[1];
      *uint64_t v25 = *v26;
      v25[1]  = v27;
      *(_WORD *)(a1 + v18[7])  = *(_WORD *)((char *)a2 + v18[7]);
      *(_WORD *)(a1 + v18[8])  = *(_WORD *)((char *)a2 + v18[8]);
      swift_bridgeObjectRetain(v27);
      uint64_t v12 = a1;
      uint64_t v13 = a3;
      uint64_t v14 = 2LL;
    }

    else if (EnumCaseMultiPayload == 1)
    {
      uint64_t v8 = a2[1];
      *(void *)a1  = *a2;
      *(void *)(a1 + 8)  = v8;
      uint64_t v9 = a2[3];
      *(void *)(a1 + 16)  = a2[2];
      *(void *)(a1 + 24)  = v9;
      *(_BYTE *)(a1 + 32)  = *((_BYTE *)a2 + 32);
      *(_BYTE *)(a1 + 33)  = *((_BYTE *)a2 + 33);
      uint64_t v11 = a2[5];
      unint64_t v10 = a2[6];
      swift_bridgeObjectRetain(v8);
      swift_bridgeObjectRetain(v9);
      sub_100020AFC(v11, v10);
      *(void *)(a1 + 40)  = v11;
      *(void *)(a1 + 48)  = v10;
      uint64_t v12 = a1;
      uint64_t v13 = a3;
      uint64_t v14 = 1LL;
    }

    else
    {
      uint64_t v28 = a2[1];
      *(void *)a1  = *a2;
      *(void *)(a1 + 8)  = v28;
      uint64_t v29 = a2[3];
      *(void *)(a1 + 16)  = a2[2];
      *(void *)(a1 + 24)  = v29;
      *(_BYTE *)(a1 + 32)  = *((_BYTE *)a2 + 32);
      *(_BYTE *)(a1 + 33)  = *((_BYTE *)a2 + 33);
      swift_bridgeObjectRetain(v28);
      swift_bridgeObjectRetain(v29);
      uint64_t v12 = a1;
      uint64_t v13 = a3;
      uint64_t v14 = 0LL;
    }

    swift_storeEnumTagMultiPayload(v12, v13, v14);
  }

  return a1;
}

uint64_t destroy for AWDLActionFrame.ServiceResponse(void *a1, uint64_t a2)
{
  uint64_t result = swift_getEnumCaseMultiPayload(a1, a2);
  if ((_DWORD)result == 2)
  {
    swift_bridgeObjectRelease(a1[1]);
    swift_bridgeObjectRelease(a1[3]);
    uint64_t v5 = type metadata accessor for DNSRecords.SRV(0LL);
    uint64_t v6 = (char *)a1 + *(int *)(v5 + 20);
    uint64_t v7 = type metadata accessor for NWEndpoint.Port(0LL);
    (*(void (**)(char *, uint64_t))(*(void *)(v7 - 8) + 8LL))(v6, v7);
    uint64_t v4 = *(void *)((char *)a1 + *(int *)(v5 + 24) + 8);
    return swift_bridgeObjectRelease(v4);
  }

  if ((_DWORD)result != 1)
  {
    if ((_DWORD)result) {
      return result;
    }
    swift_bridgeObjectRelease(a1[1]);
    uint64_t v4 = a1[3];
    return swift_bridgeObjectRelease(v4);
  }

  swift_bridgeObjectRelease(a1[1]);
  swift_bridgeObjectRelease(a1[3]);
  return sub_1000208D8(a1[5], a1[6]);
}

uint64_t initializeWithCopy for AWDLActionFrame.ServiceResponse(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t EnumCaseMultiPayload = swift_getEnumCaseMultiPayload(a2, a3);
  uint64_t v7 = EnumCaseMultiPayload;
  if ((_DWORD)EnumCaseMultiPayload == 2)
  {
    uint64_t v12 = *(void *)(a2 + 8);
    *(void *)a1  = *(void *)a2;
    *(void *)(a1 + 8)  = v12;
    uint64_t v13 = *(void *)(a2 + 24);
    *(void *)(a1 + 16)  = *(void *)(a2 + 16);
    *(void *)(a1 + 24)  = v13;
    *(_BYTE *)(a1 + 32)  = *(_BYTE *)(a2 + 32);
    *(_BYTE *)(a1 + 33)  = *(_BYTE *)(a2 + 33);
    uint64_t v14 = (int *)type metadata accessor for DNSRecords.SRV(0LL);
    uint64_t v15 = v14[5];
    uint64_t v26 = a1 + v15;
    uint64_t v16 = a2 + v15;
    uint64_t v17 = type metadata accessor for NWEndpoint.Port(0LL);
    uint64_t v18 = *(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v17 - 8) + 16LL);
    swift_bridgeObjectRetain(v12);
    swift_bridgeObjectRetain(v13);
    v18(v26, v16, v17);
    uint64_t v19 = v14[6];
    uint64_t v20 = (void *)(a1 + v19);
    uint64_t v21 = (void *)(a2 + v19);
    uint64_t v22 = v21[1];
    *uint64_t v20 = *v21;
    v20[1]  = v22;
    *(_WORD *)(a1 + v14[7])  = *(_WORD *)(a2 + v14[7]);
    *(_WORD *)(a1 + v14[8])  = *(_WORD *)(a2 + v14[8]);
LABEL_6:
    swift_bridgeObjectRetain(v22);
    goto LABEL_7;
  }

  if ((_DWORD)EnumCaseMultiPayload != 1)
  {
    uint64_t v23 = *(void *)(a2 + 8);
    *(void *)a1  = *(void *)a2;
    *(void *)(a1 + 8)  = v23;
    uint64_t v24 = *(void *)(a2 + 24);
    *(void *)(a1 + 16)  = *(void *)(a2 + 16);
    *(void *)(a1 + 24)  = v24;
    *(_BYTE *)(a1 + 32)  = *(_BYTE *)(a2 + 32);
    *(_BYTE *)(a1 + 33)  = *(_BYTE *)(a2 + 33);
    swift_bridgeObjectRetain(v23);
    uint64_t v22 = v24;
    goto LABEL_6;
  }

  uint64_t v8 = *(void *)(a2 + 8);
  *(void *)a1  = *(void *)a2;
  *(void *)(a1 + 8)  = v8;
  uint64_t v9 = *(void *)(a2 + 24);
  *(void *)(a1 + 16)  = *(void *)(a2 + 16);
  *(void *)(a1 + 24)  = v9;
  *(_BYTE *)(a1 + 32)  = *(_BYTE *)(a2 + 32);
  *(_BYTE *)(a1 + 33)  = *(_BYTE *)(a2 + 33);
  uint64_t v11 = *(void *)(a2 + 40);
  unint64_t v10 = *(void *)(a2 + 48);
  swift_bridgeObjectRetain(v8);
  swift_bridgeObjectRetain(v9);
  sub_100020AFC(v11, v10);
  *(void *)(a1 + 40)  = v11;
  *(void *)(a1 + 48)  = v10;
LABEL_7:
  swift_storeEnumTagMultiPayload(a1, a3, v7);
  return a1;
}

uint64_t assignWithCopy for AWDLActionFrame.ServiceResponse(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1 != a2)
  {
    sub_10005802C(a1, type metadata accessor for AWDLActionFrame.ServiceResponse);
    uint64_t EnumCaseMultiPayload = swift_getEnumCaseMultiPayload(a2, a3);
    uint64_t v7 = EnumCaseMultiPayload;
    if ((_DWORD)EnumCaseMultiPayload == 2)
    {
      *(void *)a1  = *(void *)a2;
      uint64_t v12 = *(void *)(a2 + 8);
      *(void *)(a1 + 8)  = v12;
      *(void *)(a1 + 16)  = *(void *)(a2 + 16);
      uint64_t v13 = *(void *)(a2 + 24);
      *(void *)(a1 + 24)  = v13;
      *(_BYTE *)(a1 + 32)  = *(_BYTE *)(a2 + 32);
      *(_BYTE *)(a1 + 33)  = *(_BYTE *)(a2 + 33);
      uint64_t v14 = (int *)type metadata accessor for DNSRecords.SRV(0LL);
      uint64_t v15 = v14[5];
      uint64_t v26 = a1 + v15;
      uint64_t v16 = a2 + v15;
      uint64_t v17 = type metadata accessor for NWEndpoint.Port(0LL);
      uint64_t v18 = *(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v17 - 8) + 16LL);
      swift_bridgeObjectRetain(v12);
      swift_bridgeObjectRetain(v13);
      v18(v26, v16, v17);
      uint64_t v19 = v14[6];
      uint64_t v20 = (void *)(a1 + v19);
      uint64_t v21 = (void *)(a2 + v19);
      *uint64_t v20 = *v21;
      uint64_t v22 = v21[1];
      v20[1]  = v22;
      *(_WORD *)(a1 + v14[7])  = *(_WORD *)(a2 + v14[7]);
      *(_WORD *)(a1 + v14[8])  = *(_WORD *)(a2 + v14[8]);
    }

    else
    {
      if ((_DWORD)EnumCaseMultiPayload == 1)
      {
        *(void *)a1  = *(void *)a2;
        uint64_t v8 = *(void *)(a2 + 8);
        *(void *)(a1 + 8)  = v8;
        *(void *)(a1 + 16)  = *(void *)(a2 + 16);
        uint64_t v9 = *(void *)(a2 + 24);
        *(void *)(a1 + 24)  = v9;
        *(_BYTE *)(a1 + 32)  = *(_BYTE *)(a2 + 32);
        *(_BYTE *)(a1 + 33)  = *(_BYTE *)(a2 + 33);
        uint64_t v11 = *(void *)(a2 + 40);
        unint64_t v10 = *(void *)(a2 + 48);
        swift_bridgeObjectRetain(v8);
        swift_bridgeObjectRetain(v9);
        sub_100020AFC(v11, v10);
        *(void *)(a1 + 40)  = v11;
        *(void *)(a1 + 48)  = v10;
LABEL_8:
        swift_storeEnumTagMultiPayload(a1, a3, v7);
        return a1;
      }

      *(void *)a1  = *(void *)a2;
      uint64_t v23 = *(void *)(a2 + 8);
      *(void *)(a1 + 8)  = v23;
      *(void *)(a1 + 16)  = *(void *)(a2 + 16);
      uint64_t v24 = *(void *)(a2 + 24);
      *(void *)(a1 + 24)  = v24;
      *(_BYTE *)(a1 + 32)  = *(_BYTE *)(a2 + 32);
      *(_BYTE *)(a1 + 33)  = *(_BYTE *)(a2 + 33);
      swift_bridgeObjectRetain(v23);
      uint64_t v22 = v24;
    }

    swift_bridgeObjectRetain(v22);
    goto LABEL_8;
  }

  return a1;
}

_OWORD *initializeWithTake for AWDLActionFrame.ServiceResponse(_OWORD *a1, _OWORD *a2, uint64_t a3)
{
  if (swift_getEnumCaseMultiPayload(a2, a3) == 2)
  {
    __int128 v6 = a2[1];
    *a1  = *a2;
    a1[1]  = v6;
    *((_WORD *)a1 + 16)  = *((_WORD *)a2 + 16);
    uint64_t v7 = (int *)type metadata accessor for DNSRecords.SRV(0LL);
    uint64_t v8 = v7[5];
    uint64_t v9 = (char *)a1 + v8;
    unint64_t v10 = (char *)a2 + v8;
    uint64_t v11 = type metadata accessor for NWEndpoint.Port(0LL);
    (*(void (**)(char *, char *, uint64_t))(*(void *)(v11 - 8) + 32LL))(v9, v10, v11);
    *(_OWORD *)((char *)a1 + v7[6])  = *(_OWORD *)((char *)a2 + v7[6]);
    *(_WORD *)((char *)a1 + v7[7])  = *(_WORD *)((char *)a2 + v7[7]);
    *(_WORD *)((char *)a1 + v7[8])  = *(_WORD *)((char *)a2 + v7[8]);
    swift_storeEnumTagMultiPayload(a1, a3, 2LL);
  }

  else
  {
    memcpy(a1, a2, *(void *)(*(void *)(a3 - 8) + 64LL));
  }

  return a1;
}

_OWORD *assignWithTake for AWDLActionFrame.ServiceResponse(_OWORD *a1, _OWORD *a2, uint64_t a3)
{
  if (a1 != a2)
  {
    sub_10005802C((uint64_t)a1, type metadata accessor for AWDLActionFrame.ServiceResponse);
    if (swift_getEnumCaseMultiPayload(a2, a3) == 2)
    {
      __int128 v6 = a2[1];
      *a1  = *a2;
      a1[1]  = v6;
      *((_WORD *)a1 + 16)  = *((_WORD *)a2 + 16);
      uint64_t v7 = (int *)type metadata accessor for DNSRecords.SRV(0LL);
      uint64_t v8 = v7[5];
      uint64_t v9 = (char *)a1 + v8;
      unint64_t v10 = (char *)a2 + v8;
      uint64_t v11 = type metadata accessor for NWEndpoint.Port(0LL);
      (*(void (**)(char *, char *, uint64_t))(*(void *)(v11 - 8) + 32LL))(v9, v10, v11);
      *(_OWORD *)((char *)a1 + v7[6])  = *(_OWORD *)((char *)a2 + v7[6]);
      *(_WORD *)((char *)a1 + v7[7])  = *(_WORD *)((char *)a2 + v7[7]);
      *(_WORD *)((char *)a1 + v7[8])  = *(_WORD *)((char *)a2 + v7[8]);
      swift_storeEnumTagMultiPayload(a1, a3, 2LL);
    }

    else
    {
      memcpy(a1, a2, *(void *)(*(void *)(a3 - 8) + 64LL));
    }
  }

  return a1;
}

uint64_t sub_1000DDC04(uint64_t a1)
{
  v4[0]  = "";
  v4[1]  = &unk_100343458;
  uint64_t result = type metadata accessor for DNSRecords.SRV(319LL);
  if (v3 <= 0x3F)
  {
    void v4[2] = *(void *)(result - 8) + 64LL;
    swift_initEnumMetadataMultiPayload(a1, 256LL, 3LL, v4);
    return 0LL;
  }

  return result;
}

ValueMetadata *type metadata accessor for AWDLActionFrame.AWDLChannelSequenceParameter()
{
  return &type metadata for AWDLActionFrame.AWDLChannelSequenceParameter;
}

uint64_t destroy for AWDLActionFrame.SynchronizationParameter(uint64_t a1)
{
  return swift_bridgeObjectRelease(*(void *)(a1 + 40));
}

uint64_t initializeWithCopy for AWDLActionFrame.SynchronizationParameter(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)a1  = *(_BYTE *)a2;
  *(_DWORD *)(a1 + 2)  = *(_DWORD *)(a2 + 2);
  *(void *)(a1 + 6)  = *(void *)(a2 + 6);
  *(_DWORD *)(a1 + 14)  = *(_DWORD *)(a2 + 14);
  *(_DWORD *)(a1 + 18)  = *(_DWORD *)(a2 + 18);
  *(void *)(a1 + 22)  = *(void *)(a2 + 22);
  *(_DWORD *)(a1 + 30)  = *(_DWORD *)(a2 + 30);
  uint64_t v3 = *(void *)(a2 + 40);
  *(void *)(a1 + 40)  = v3;
  swift_bridgeObjectRetain(v3);
  return a1;
}

uint64_t assignWithCopy for AWDLActionFrame.SynchronizationParameter(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)a1  = *(_BYTE *)a2;
  *(_WORD *)(a1 + 2)  = *(_WORD *)(a2 + 2);
  *(_BYTE *)(a1 + 4)  = *(_BYTE *)(a2 + 4);
  *(_BYTE *)(a1 + 5)  = *(_BYTE *)(a2 + 5);
  *(_WORD *)(a1 + 6)  = *(_WORD *)(a2 + 6);
  *(_WORD *)(a1 + 8)  = *(_WORD *)(a2 + 8);
  *(_WORD *)(a1 + 10)  = *(_WORD *)(a2 + 10);
  *(_WORD *)(a1 + 12)  = *(_WORD *)(a2 + 12);
  *(_WORD *)(a1 + 14)  = *(_WORD *)(a2 + 14);
  *(_WORD *)(a1 + 16)  = *(_WORD *)(a2 + 16);
  *(_BYTE *)(a1 + 18)  = *(_BYTE *)(a2 + 18);
  *(_BYTE *)(a1 + 19)  = *(_BYTE *)(a2 + 19);
  *(_BYTE *)(a1 + 20)  = *(_BYTE *)(a2 + 20);
  *(_BYTE *)(a1 + 21)  = *(_BYTE *)(a2 + 21);
  *(_BYTE *)(a1 + 22)  = *(_BYTE *)(a2 + 22);
  *(_BYTE *)(a1 + 23)  = *(_BYTE *)(a2 + 23);
  *(_BYTE *)(a1 + 24)  = *(_BYTE *)(a2 + 24);
  *(_BYTE *)(a1 + 25)  = *(_BYTE *)(a2 + 25);
  *(_BYTE *)(a1 + 26)  = *(_BYTE *)(a2 + 26);
  *(_BYTE *)(a1 + 27)  = *(_BYTE *)(a2 + 27);
  *(_BYTE *)(a1 + 28)  = *(_BYTE *)(a2 + 28);
  *(_BYTE *)(a1 + 29)  = *(_BYTE *)(a2 + 29);
  *(_WORD *)(a1 + 30)  = *(_WORD *)(a2 + 30);
  *(_WORD *)(a1 + 32)  = *(_WORD *)(a2 + 32);
  uint64_t v3 = *(void *)(a2 + 40);
  uint64_t v4 = *(void *)(a1 + 40);
  *(void *)(a1 + 40)  = v3;
  swift_bridgeObjectRetain(v3);
  swift_bridgeObjectRelease(v4);
  return a1;
}

uint64_t assignWithTake for AWDLActionFrame.SynchronizationParameter(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)a1  = *(_BYTE *)a2;
  *(_DWORD *)(a1 + 2)  = *(_DWORD *)(a2 + 2);
  *(void *)(a1 + 6)  = *(void *)(a2 + 6);
  *(_DWORD *)(a1 + 14)  = *(_DWORD *)(a2 + 14);
  *(void *)(a1 + 18)  = *(void *)(a2 + 18);
  *(_DWORD *)(a1 + 26)  = *(_DWORD *)(a2 + 26);
  *(_DWORD *)(a1 + 30)  = *(_DWORD *)(a2 + 30);
  uint64_t v3 = *(void *)(a1 + 40);
  *(void *)(a1 + 40)  = *(void *)(a2 + 40);
  swift_bridgeObjectRelease(v3);
  return a1;
}

uint64_t getEnumTagSinglePayload for AWDLActionFrame.SynchronizationParameter(uint64_t a1, int a2)
{
  if (!a2) {
    return 0LL;
  }
  if (a2 < 0 && *(_BYTE *)(a1 + 48)) {
    return *(_DWORD *)a1 + 0x80000000;
  }
  unint64_t v2 = *(void *)(a1 + 40);
  if (v2 >= 0xFFFFFFFF) {
    LODWORD(v2)  = -1;
  }
  return (v2 + 1);
}

uint64_t storeEnumTagSinglePayload for AWDLActionFrame.SynchronizationParameter( uint64_t result, int a2, int a3)
{
  if (a2 < 0)
  {
    *(void *)(result + 40)  = 0LL;
    *(_OWORD *)(result + 24)  = 0u;
    *(_OWORD *)(result + 8)  = 0u;
    *(void *)uint64_t result = a2 ^ 0x80000000;
    if (a3 < 0) {
      *(_BYTE *)(result + 48)  = 1;
    }
  }

  else
  {
    if ((a3 & 0x80000000) == 0)
    {
      if (!a2) {
        return result;
      }
LABEL_8:
      *(void *)(result + 40)  = (a2 - 1);
      return result;
    }

    *(_BYTE *)(result + 48)  = 0;
    if (a2) {
      goto LABEL_8;
    }
  }

  return result;
}

ValueMetadata *type metadata accessor for AWDLActionFrame.SynchronizationParameter()
{
  return &type metadata for AWDLActionFrame.SynchronizationParameter;
}

__n128 initializeWithCopy for AWDLActionFrame.DeprecatedElectionParameter(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)a2;
  *(_OWORD *)(a1 + 9)  = *(_OWORD *)(a2 + 9);
  *(__n128 *)a1  = result;
  return result;
}

uint64_t getEnumTagSinglePayload for AWDLActionFrame.DeprecatedElectionParameter(uint64_t a1, int a2)
{
  if (a2 && *(_BYTE *)(a1 + 25)) {
    return (*(_DWORD *)a1 + 1);
  }
  else {
    return 0LL;
  }
}

uint64_t storeEnumTagSinglePayload for AWDLActionFrame.DeprecatedElectionParameter( uint64_t result, int a2, int a3)
{
  if (a2)
  {
    *(void *)(result + 8)  = 0LL;
    *(void *)(result + 16)  = 0LL;
    *(_BYTE *)(result + 24)  = 0;
    *(void *)__n128 result = (a2 - 1);
    if (!a3) {
      return result;
    }
    char v3 = 1;
  }

  else
  {
    if (!a3) {
      return result;
    }
    char v3 = 0;
  }

  *(_BYTE *)(result + 25)  = v3;
  return result;
}

ValueMetadata *type metadata accessor for AWDLActionFrame.DeprecatedElectionParameter()
{
  return &type metadata for AWDLActionFrame.DeprecatedElectionParameter;
}

uint64_t initializeWithCopy for AWDLActionFrame.ServiceParameter(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)a1  = *(_BYTE *)a2;
  *(_DWORD *)(a1 + 2)  = *(_DWORD *)(a2 + 2);
  *(_DWORD *)(a1 + 8)  = *(_DWORD *)(a2 + 8);
  uint64_t v3 = *(void *)(a2 + 16);
  unint64_t v4 = *(void *)(a2 + 24);
  sub_100020AFC(v3, v4);
  *(void *)(a1 + 16)  = v3;
  *(void *)(a1 + 24)  = v4;
  return a1;
}

uint64_t assignWithCopy for AWDLActionFrame.ServiceParameter(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)a1  = *(_BYTE *)a2;
  *(_WORD *)(a1 + 2)  = *(_WORD *)(a2 + 2);
  *(_WORD *)(a1 + 4)  = *(_WORD *)(a2 + 4);
  *(_DWORD *)(a1 + 8)  = *(_DWORD *)(a2 + 8);
  uint64_t v3 = *(void *)(a2 + 16);
  unint64_t v4 = *(void *)(a2 + 24);
  sub_100020AFC(v3, v4);
  uint64_t v5 = *(void *)(a1 + 16);
  unint64_t v6 = *(void *)(a1 + 24);
  *(void *)(a1 + 16)  = v3;
  *(void *)(a1 + 24)  = v4;
  sub_1000208D8(v5, v6);
  return a1;
}

uint64_t assignWithTake for AWDLActionFrame.ServiceParameter(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)a1  = *(_BYTE *)a2;
  *(_DWORD *)(a1 + 2)  = *(_DWORD *)(a2 + 2);
  *(_DWORD *)(a1 + 8)  = *(_DWORD *)(a2 + 8);
  uint64_t v3 = *(void *)(a1 + 16);
  unint64_t v4 = *(void *)(a1 + 24);
  *(_OWORD *)(a1 + 16)  = *(_OWORD *)(a2 + 16);
  sub_1000208D8(v3, v4);
  return a1;
}

ValueMetadata *type metadata accessor for AWDLActionFrame.ServiceParameter()
{
  return &type metadata for AWDLActionFrame.ServiceParameter;
}

ValueMetadata *type metadata accessor for AWDLActionFrame.ServiceParameter.Flags()
{
  return &type metadata for AWDLActionFrame.ServiceParameter.Flags;
}

uint64_t sub_1000DE09C(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)a1  = *(_DWORD *)a2;
  uint64_t v3 = *(void *)(a2 + 8);
  unint64_t v4 = *(void *)(a2 + 16);
  sub_100020AFC(v3, v4);
  *(void *)(a1 + 8)  = v3;
  *(void *)(a1 + 16)  = v4;
  return a1;
}

uint64_t assignWithCopy for AWDLActionFrame.ServiceParameter.SSTH(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)a1  = *(_DWORD *)a2;
  uint64_t v3 = *(void *)(a2 + 8);
  unint64_t v4 = *(void *)(a2 + 16);
  sub_100020AFC(v3, v4);
  uint64_t v5 = *(void *)(a1 + 8);
  unint64_t v6 = *(void *)(a1 + 16);
  *(void *)(a1 + 8)  = v3;
  *(void *)(a1 + 16)  = v4;
  sub_1000208D8(v5, v6);
  return a1;
}

uint64_t assignWithTake for AWDLActionFrame.ServiceParameter.SSTH(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)a1  = *(_DWORD *)a2;
  uint64_t v3 = *(void *)(a1 + 8);
  unint64_t v4 = *(void *)(a1 + 16);
  *(_OWORD *)(a1 + 8)  = *(_OWORD *)(a2 + 8);
  sub_1000208D8(v3, v4);
  return a1;
}

ValueMetadata *type metadata accessor for AWDLActionFrame.ServiceParameter.SSTH()
{
  return &type metadata for AWDLActionFrame.ServiceParameter.SSTH;
}

void *initializeBufferWithCopyOfBuffer for AWDLActionFrame.DataPathState(uint64_t a1, uint64_t *a2, int *a3)
{
  unint64_t v4 = (void *)a1;
  int v5 = *(_DWORD *)(*((void *)a3 - 1) + 80LL);
  if ((v5 & 0x20000) != 0)
  {
    uint64_t v18 = *a2;
    void *v4 = *a2;
    unint64_t v4 = (void *)(v18 + ((v5 + 16LL) & ~(unint64_t)v5));
    swift_retain();
  }

  else
  {
    *(_WORD *)a1  = *(_WORD *)a2;
    *(_BYTE *)(a1 + 2)  = *((_BYTE *)a2 + 2);
    *(_DWORD *)(a1 + 4)  = *((_DWORD *)a2 + 1);
    *(_WORD *)(a1 + 8)  = *((_WORD *)a2 + 4);
    *(_DWORD *)(a1 + 10)  = *(_DWORD *)((char *)a2 + 10);
    *(_DWORD *)(a1 + 13)  = *(_DWORD *)((char *)a2 + 13);
    *(_WORD *)(a1 + 24)  = *((_WORD *)a2 + 12);
    *(_DWORD *)(a1 + 20)  = *((_DWORD *)a2 + 5);
    int v7 = *(_DWORD *)((char *)a2 + 26);
    *(_DWORD *)(a1 + 29)  = *(_DWORD *)((char *)a2 + 29);
    *(_DWORD *)(a1 + 26)  = v7;
    uint64_t v8 = a2[6];
    *(void *)(a1 + 40)  = a2[5];
    *(void *)(a1 + 48)  = v8;
    *(_DWORD *)(a1 + 56)  = *((_DWORD *)a2 + 14);
    *(_DWORD *)(a1 + 59)  = *(_DWORD *)((char *)a2 + 59);
    *(_BYTE *)(a1 + 63)  = *((_BYTE *)a2 + 63);
    *(_DWORD *)(a1 + 64)  = *((_DWORD *)a2 + 16);
    *(_BYTE *)(a1 + 68)  = *((_BYTE *)a2 + 68);
    int v9 = *((_DWORD *)a2 + 18);
    *(_BYTE *)(a1 + 76)  = *((_BYTE *)a2 + 76);
    *(_DWORD *)(a1 + 72)  = v9;
    __int128 v10 = *(_OWORD *)((char *)a2 + 77);
    *(_WORD *)(a1 + 93)  = *(_WORD *)((char *)a2 + 93);
    uint64_t v11 = a3[34];
    uint64_t v12 = (void *)(a1 + v11);
    uint64_t v13 = (char *)a2 + v11;
    *(_OWORD *)(a1 + 77)  = v10;
    uint64_t v14 = type metadata accessor for DispatchTimeInterval(0LL);
    uint64_t v15 = *(void *)(v14 - 8);
    uint64_t v16 = *(unsigned int (**)(const void *, uint64_t, uint64_t))(v15 + 48);
    swift_bridgeObjectRetain(v8);
    if (v16(v13, 1LL, v14))
    {
      uint64_t v17 = sub_100002274(&qword_100407450);
      memcpy(v12, v13, *(void *)(*(void *)(v17 - 8) + 64LL));
    }

    else
    {
      (*(void (**)(void *, char *, uint64_t))(v15 + 16))(v12, v13, v14);
      (*(void (**)(void *, void, uint64_t, uint64_t))(v15 + 56))(v12, 0LL, 1LL, v14);
    }

    uint64_t v19 = a3[35];
    uint64_t v20 = a3[36];
    uint64_t v21 = (char *)v4 + v19;
    uint64_t v22 = (uint64_t)a2 + v19;
    *(_DWORD *)uint64_t v21 = *(_DWORD *)v22;
    v21[4]  = *(_BYTE *)(v22 + 4);
    uint64_t v23 = (char *)v4 + v20;
    uint64_t v24 = (uint64_t)a2 + v20;
    *(_DWORD *)uint64_t v23 = *(_DWORD *)v24;
    v23[4]  = *(_BYTE *)(v24 + 4);
  }

  return v4;
}

uint64_t destroy for AWDLActionFrame.DataPathState(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = a1 + *(int *)(a2 + 136);
  uint64_t v5 = type metadata accessor for DispatchTimeInterval(0LL);
  uint64_t v6 = *(void *)(v5 - 8);
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v6 + 48))(v4, 1LL, v5);
  if (!(_DWORD)result) {
    return (*(uint64_t (**)(uint64_t, uint64_t))(v6 + 8))(v4, v5);
  }
  return result;
}

uint64_t initializeWithCopy for AWDLActionFrame.DataPathState(uint64_t a1, uint64_t a2, int *a3)
{
  *(_WORD *)a1  = *(_WORD *)a2;
  *(_BYTE *)(a1 + 2)  = *(_BYTE *)(a2 + 2);
  *(_DWORD *)(a1 + 4)  = *(_DWORD *)(a2 + 4);
  *(_WORD *)(a1 + 8)  = *(_WORD *)(a2 + 8);
  *(_DWORD *)(a1 + 10)  = *(_DWORD *)(a2 + 10);
  *(_DWORD *)(a1 + 13)  = *(_DWORD *)(a2 + 13);
  *(_WORD *)(a1 + 24)  = *(_WORD *)(a2 + 24);
  *(_DWORD *)(a1 + 20)  = *(_DWORD *)(a2 + 20);
  int v6 = *(_DWORD *)(a2 + 26);
  *(_DWORD *)(a1 + 29)  = *(_DWORD *)(a2 + 29);
  *(_DWORD *)(a1 + 26)  = v6;
  uint64_t v7 = *(void *)(a2 + 48);
  *(void *)(a1 + 40)  = *(void *)(a2 + 40);
  *(void *)(a1 + 48)  = v7;
  *(_DWORD *)(a1 + 56)  = *(_DWORD *)(a2 + 56);
  *(_DWORD *)(a1 + 59)  = *(_DWORD *)(a2 + 59);
  *(_BYTE *)(a1 + 63)  = *(_BYTE *)(a2 + 63);
  *(_DWORD *)(a1 + 64)  = *(_DWORD *)(a2 + 64);
  *(_BYTE *)(a1 + 68)  = *(_BYTE *)(a2 + 68);
  int v8 = *(_DWORD *)(a2 + 72);
  *(_BYTE *)(a1 + 76)  = *(_BYTE *)(a2 + 76);
  *(_DWORD *)(a1 + 72)  = v8;
  __int128 v9 = *(_OWORD *)(a2 + 77);
  *(_WORD *)(a1 + 93)  = *(_WORD *)(a2 + 93);
  uint64_t v10 = a3[34];
  uint64_t v11 = (void *)(a1 + v10);
  uint64_t v12 = (const void *)(a2 + v10);
  *(_OWORD *)(a1 + 77)  = v9;
  uint64_t v13 = type metadata accessor for DispatchTimeInterval(0LL);
  uint64_t v14 = *(void *)(v13 - 8);
  uint64_t v15 = *(unsigned int (**)(const void *, uint64_t, uint64_t))(v14 + 48);
  swift_bridgeObjectRetain(v7);
  if (v15(v12, 1LL, v13))
  {
    uint64_t v16 = sub_100002274(&qword_100407450);
    memcpy(v11, v12, *(void *)(*(void *)(v16 - 8) + 64LL));
  }

  else
  {
    (*(void (**)(void *, const void *, uint64_t))(v14 + 16))(v11, v12, v13);
    (*(void (**)(void *, void, uint64_t, uint64_t))(v14 + 56))(v11, 0LL, 1LL, v13);
  }

  uint64_t v17 = a3[35];
  uint64_t v18 = a3[36];
  uint64_t v19 = a1 + v17;
  uint64_t v20 = a2 + v17;
  *(_DWORD *)uint64_t v19 = *(_DWORD *)v20;
  *(_BYTE *)(v19 + 4)  = *(_BYTE *)(v20 + 4);
  uint64_t v21 = a1 + v18;
  uint64_t v22 = a2 + v18;
  *(_DWORD *)uint64_t v21 = *(_DWORD *)v22;
  *(_BYTE *)(v21 + 4)  = *(_BYTE *)(v22 + 4);
  return a1;
}

uint64_t assignWithCopy for AWDLActionFrame.DataPathState(uint64_t a1, __int16 *a2, int *a3)
{
  __int16 v6 = *a2;
  *(_BYTE *)(a1 + 2)  = *((_BYTE *)a2 + 2);
  *(_WORD *)a1  = v6;
  int v7 = *((_DWORD *)a2 + 1);
  *(_WORD *)(a1 + 8)  = a2[4];
  *(_DWORD *)(a1 + 4)  = v7;
  int v8 = *(_DWORD *)(a2 + 5);
  *(_DWORD *)(a1 + 13)  = *(_DWORD *)((char *)a2 + 13);
  *(_DWORD *)(a1 + 10)  = v8;
  int v9 = *((_DWORD *)a2 + 5);
  *(_WORD *)(a1 + 24)  = a2[12];
  *(_DWORD *)(a1 + 20)  = v9;
  int v10 = *(_DWORD *)(a2 + 13);
  *(_DWORD *)(a1 + 29)  = *(_DWORD *)((char *)a2 + 29);
  *(_DWORD *)(a1 + 26)  = v10;
  *(void *)(a1 + 40)  = *((void *)a2 + 5);
  uint64_t v11 = *((void *)a2 + 6);
  uint64_t v12 = *(void *)(a1 + 48);
  *(void *)(a1 + 48)  = v11;
  swift_bridgeObjectRetain(v11);
  swift_bridgeObjectRelease(v12);
  int v13 = *((_DWORD *)a2 + 14);
  *(_DWORD *)(a1 + 59)  = *(_DWORD *)((char *)a2 + 59);
  *(_DWORD *)(a1 + 56)  = v13;
  *(_BYTE *)(a1 + 63)  = *((_BYTE *)a2 + 63);
  *(_BYTE *)(a1 + 64)  = *((_BYTE *)a2 + 64);
  *(_BYTE *)(a1 + 65)  = *((_BYTE *)a2 + 65);
  LOWORD(v13)  = a2[33];
  *(_BYTE *)(a1 + 68)  = *((_BYTE *)a2 + 68);
  *(_WORD *)(a1 + 66)  = v13;
  int v14 = *((_DWORD *)a2 + 18);
  *(_BYTE *)(a1 + 76)  = *((_BYTE *)a2 + 76);
  *(_DWORD *)(a1 + 72)  = v14;
  *(_BYTE *)(a1 + 77)  = *((_BYTE *)a2 + 77);
  *(_BYTE *)(a1 + 78)  = *((_BYTE *)a2 + 78);
  *(_BYTE *)(a1 + 79)  = *((_BYTE *)a2 + 79);
  *(_BYTE *)(a1 + 80)  = *((_BYTE *)a2 + 80);
  *(_BYTE *)(a1 + 81)  = *((_BYTE *)a2 + 81);
  *(_BYTE *)(a1 + 82)  = *((_BYTE *)a2 + 82);
  *(_BYTE *)(a1 + 83)  = *((_BYTE *)a2 + 83);
  *(_BYTE *)(a1 + 84)  = *((_BYTE *)a2 + 84);
  *(_BYTE *)(a1 + 85)  = *((_BYTE *)a2 + 85);
  *(_BYTE *)(a1 + 86)  = *((_BYTE *)a2 + 86);
  *(_BYTE *)(a1 + 87)  = *((_BYTE *)a2 + 87);
  *(_BYTE *)(a1 + 88)  = *((_BYTE *)a2 + 88);
  *(_BYTE *)(a1 + 89)  = *((_BYTE *)a2 + 89);
  *(_BYTE *)(a1 + 90)  = *((_BYTE *)a2 + 90);
  *(_BYTE *)(a1 + 91)  = *((_BYTE *)a2 + 91);
  *(_BYTE *)(a1 + 92)  = *((_BYTE *)a2 + 92);
  *(_BYTE *)(a1 + 93)  = *((_BYTE *)a2 + 93);
  *(_BYTE *)(a1 + 94)  = *((_BYTE *)a2 + 94);
  uint64_t v15 = a3[34];
  uint64_t v16 = (void *)(a1 + v15);
  uint64_t v17 = (char *)a2 + v15;
  uint64_t v18 = type metadata accessor for DispatchTimeInterval(0LL);
  uint64_t v19 = *(void *)(v18 - 8);
  uint64_t v20 = *(uint64_t (**)(void *, uint64_t, uint64_t))(v19 + 48);
  int v21 = v20(v16, 1LL, v18);
  int v22 = v20(v17, 1LL, v18);
  if (!v21)
  {
    if (!v22)
    {
      (*(void (**)(void *, char *, uint64_t))(v19 + 24))(v16, v17, v18);
      goto LABEL_7;
    }

    (*(void (**)(void *, uint64_t))(v19 + 8))(v16, v18);
    goto LABEL_6;
  }

  if (v22)
  {
LABEL_6:
    uint64_t v23 = sub_100002274(&qword_100407450);
    memcpy(v16, v17, *(void *)(*(void *)(v23 - 8) + 64LL));
    goto LABEL_7;
  }

  (*(void (**)(void *, char *, uint64_t))(v19 + 16))(v16, v17, v18);
  (*(void (**)(void *, void, uint64_t, uint64_t))(v19 + 56))(v16, 0LL, 1LL, v18);
LABEL_7:
  uint64_t v24 = a3[35];
  uint64_t v25 = a1 + v24;
  uint64_t v26 = (int *)((char *)a2 + v24);
  int v27 = *v26;
  *(_BYTE *)(v25 + 4)  = *((_BYTE *)v26 + 4);
  *(_DWORD *)uint64_t v25 = v27;
  uint64_t v28 = a3[36];
  uint64_t v29 = a1 + v28;
  uint64_t v30 = (int *)((char *)a2 + v28);
  int v31 = *v30;
  *(_BYTE *)(v29 + 4)  = *((_BYTE *)v30 + 4);
  *(_DWORD *)uint64_t v29 = v31;
  return a1;
}

uint64_t initializeWithTake for AWDLActionFrame.DataPathState(uint64_t a1, uint64_t a2, int *a3)
{
  *(_WORD *)a1  = *(_WORD *)a2;
  *(_BYTE *)(a1 + 2)  = *(_BYTE *)(a2 + 2);
  *(_DWORD *)(a1 + 4)  = *(_DWORD *)(a2 + 4);
  *(_WORD *)(a1 + 8)  = *(_WORD *)(a2 + 8);
  *(_DWORD *)(a1 + 10)  = *(_DWORD *)(a2 + 10);
  *(_DWORD *)(a1 + 13)  = *(_DWORD *)(a2 + 13);
  *(_WORD *)(a1 + 24)  = *(_WORD *)(a2 + 24);
  *(_DWORD *)(a1 + 20)  = *(_DWORD *)(a2 + 20);
  int v6 = *(_DWORD *)(a2 + 26);
  *(_DWORD *)(a1 + 29)  = *(_DWORD *)(a2 + 29);
  *(_DWORD *)(a1 + 26)  = v6;
  *(_OWORD *)(a1 + 40)  = *(_OWORD *)(a2 + 40);
  *(_DWORD *)(a1 + 56)  = *(_DWORD *)(a2 + 56);
  *(_DWORD *)(a1 + 59)  = *(_DWORD *)(a2 + 59);
  *(_BYTE *)(a1 + 63)  = *(_BYTE *)(a2 + 63);
  *(_DWORD *)(a1 + 64)  = *(_DWORD *)(a2 + 64);
  *(_BYTE *)(a1 + 68)  = *(_BYTE *)(a2 + 68);
  *(_DWORD *)(a1 + 72)  = *(_DWORD *)(a2 + 72);
  *(_BYTE *)(a1 + 76)  = *(_BYTE *)(a2 + 76);
  __int128 v7 = *(_OWORD *)(a2 + 77);
  *(_WORD *)(a1 + 93)  = *(_WORD *)(a2 + 93);
  uint64_t v8 = a3[34];
  int v9 = (void *)(a1 + v8);
  int v10 = (const void *)(a2 + v8);
  *(_OWORD *)(a1 + 77)  = v7;
  uint64_t v11 = type metadata accessor for DispatchTimeInterval(0LL);
  uint64_t v12 = *(void *)(v11 - 8);
  if ((*(unsigned int (**)(const void *, uint64_t, uint64_t))(v12 + 48))(v10, 1LL, v11))
  {
    uint64_t v13 = sub_100002274(&qword_100407450);
    memcpy(v9, v10, *(void *)(*(void *)(v13 - 8) + 64LL));
  }

  else
  {
    (*(void (**)(void *, const void *, uint64_t))(v12 + 32))(v9, v10, v11);
    (*(void (**)(void *, void, uint64_t, uint64_t))(v12 + 56))(v9, 0LL, 1LL, v11);
  }

  uint64_t v14 = a3[35];
  uint64_t v15 = a3[36];
  uint64_t v16 = a1 + v14;
  uint64_t v17 = a2 + v14;
  *(_DWORD *)uint64_t v16 = *(_DWORD *)v17;
  *(_BYTE *)(v16 + 4)  = *(_BYTE *)(v17 + 4);
  uint64_t v18 = a1 + v15;
  uint64_t v19 = a2 + v15;
  *(_DWORD *)uint64_t v18 = *(_DWORD *)v19;
  *(_BYTE *)(v18 + 4)  = *(_BYTE *)(v19 + 4);
  return a1;
}

uint64_t assignWithTake for AWDLActionFrame.DataPathState(uint64_t a1, uint64_t a2, int *a3)
{
  *(_WORD *)a1  = *(_WORD *)a2;
  *(_BYTE *)(a1 + 2)  = *(_BYTE *)(a2 + 2);
  *(_DWORD *)(a1 + 4)  = *(_DWORD *)(a2 + 4);
  *(_WORD *)(a1 + 8)  = *(_WORD *)(a2 + 8);
  *(_DWORD *)(a1 + 10)  = *(_DWORD *)(a2 + 10);
  *(_DWORD *)(a1 + 13)  = *(_DWORD *)(a2 + 13);
  *(_WORD *)(a1 + 24)  = *(_WORD *)(a2 + 24);
  *(_DWORD *)(a1 + 20)  = *(_DWORD *)(a2 + 20);
  int v6 = *(_DWORD *)(a2 + 26);
  *(_DWORD *)(a1 + 29)  = *(_DWORD *)(a2 + 29);
  *(_DWORD *)(a1 + 26)  = v6;
  uint64_t v7 = *(void *)(a2 + 48);
  uint64_t v8 = *(void *)(a1 + 48);
  *(void *)(a1 + 40)  = *(void *)(a2 + 40);
  *(void *)(a1 + 48)  = v7;
  swift_bridgeObjectRelease(v8);
  *(_DWORD *)(a1 + 56)  = *(_DWORD *)(a2 + 56);
  *(_DWORD *)(a1 + 59)  = *(_DWORD *)(a2 + 59);
  *(_BYTE *)(a1 + 63)  = *(_BYTE *)(a2 + 63);
  *(_BYTE *)(a1 + 64)  = *(_BYTE *)(a2 + 64);
  *(_BYTE *)(a1 + 65)  = *(_BYTE *)(a2 + 65);
  *(_WORD *)(a1 + 66)  = *(_WORD *)(a2 + 66);
  *(_BYTE *)(a1 + 68)  = *(_BYTE *)(a2 + 68);
  *(_BYTE *)(a1 + 76)  = *(_BYTE *)(a2 + 76);
  *(_DWORD *)(a1 + 72)  = *(_DWORD *)(a2 + 72);
  *(_BYTE *)(a1 + 77)  = *(_BYTE *)(a2 + 77);
  *(_BYTE *)(a1 + 78)  = *(_BYTE *)(a2 + 78);
  *(_BYTE *)(a1 + 79)  = *(_BYTE *)(a2 + 79);
  *(_BYTE *)(a1 + 80)  = *(_BYTE *)(a2 + 80);
  *(_BYTE *)(a1 + 81)  = *(_BYTE *)(a2 + 81);
  *(_BYTE *)(a1 + 82)  = *(_BYTE *)(a2 + 82);
  *(_BYTE *)(a1 + 83)  = *(_BYTE *)(a2 + 83);
  *(_BYTE *)(a1 + 84)  = *(_BYTE *)(a2 + 84);
  *(_BYTE *)(a1 + 85)  = *(_BYTE *)(a2 + 85);
  *(_BYTE *)(a1 + 86)  = *(_BYTE *)(a2 + 86);
  *(_BYTE *)(a1 + 87)  = *(_BYTE *)(a2 + 87);
  *(_BYTE *)(a1 + 88)  = *(_BYTE *)(a2 + 88);
  *(_BYTE *)(a1 + 89)  = *(_BYTE *)(a2 + 89);
  *(_BYTE *)(a1 + 90)  = *(_BYTE *)(a2 + 90);
  *(_BYTE *)(a1 + 91)  = *(_BYTE *)(a2 + 91);
  *(_BYTE *)(a1 + 92)  = *(_BYTE *)(a2 + 92);
  *(_BYTE *)(a1 + 93)  = *(_BYTE *)(a2 + 93);
  *(_BYTE *)(a1 + 94)  = *(_BYTE *)(a2 + 94);
  uint64_t v9 = a3[34];
  int v10 = (void *)(a1 + v9);
  uint64_t v11 = (void *)(a2 + v9);
  uint64_t v12 = type metadata accessor for DispatchTimeInterval(0LL);
  uint64_t v13 = *(void *)(v12 - 8);
  uint64_t v14 = *(uint64_t (**)(void *, uint64_t, uint64_t))(v13 + 48);
  int v15 = v14(v10, 1LL, v12);
  int v16 = v14(v11, 1LL, v12);
  if (!v15)
  {
    if (!v16)
    {
      (*(void (**)(void *, void *, uint64_t))(v13 + 40))(v10, v11, v12);
      goto LABEL_7;
    }

    (*(void (**)(void *, uint64_t))(v13 + 8))(v10, v12);
    goto LABEL_6;
  }

  if (v16)
  {
LABEL_6:
    uint64_t v17 = sub_100002274(&qword_100407450);
    memcpy(v10, v11, *(void *)(*(void *)(v17 - 8) + 64LL));
    goto LABEL_7;
  }

  (*(void (**)(void *, void *, uint64_t))(v13 + 32))(v10, v11, v12);
  (*(void (**)(void *, void, uint64_t, uint64_t))(v13 + 56))(v10, 0LL, 1LL, v12);
LABEL_7:
  uint64_t v18 = a3[35];
  uint64_t v19 = a3[36];
  uint64_t v20 = a1 + v18;
  uint64_t v21 = a2 + v18;
  *(_DWORD *)uint64_t v20 = *(_DWORD *)v21;
  *(_BYTE *)(v20 + 4)  = *(_BYTE *)(v21 + 4);
  uint64_t v22 = a1 + v19;
  uint64_t v23 = a2 + v19;
  *(_DWORD *)uint64_t v22 = *(_DWORD *)v23;
  *(_BYTE *)(v22 + 4)  = *(_BYTE *)(v23 + 4);
  return a1;
}

uint64_t getEnumTagSinglePayload for AWDLActionFrame.DataPathState(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return swift_getEnumTagSinglePayloadGeneric(a1, a2, a3, sub_1000DEC24);
}

uint64_t sub_1000DEC24(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if ((_DWORD)a2 == 2147483646)
  {
    unint64_t v4 = *(void *)(a1 + 48);
    if (v4 >= 0xFFFFFFFF) {
      LODWORD(v4)  = -1;
    }
    int v5 = v4 - 1;
    if (v5 < 0) {
      int v5 = -1;
    }
    return (v5 + 1);
  }

  else
  {
    uint64_t v9 = sub_100002274(&qword_100407450);
    return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v9 - 8) + 48LL))( a1 + *(int *)(a3 + 136),  a2,  v9);
  }

uint64_t storeEnumTagSinglePayload for AWDLActionFrame.DataPathState( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return swift_storeEnumTagSinglePayloadGeneric(a1, a2, a3, a4, sub_1000DECBC);
}

uint64_t sub_1000DECBC(uint64_t result, uint64_t a2, int a3, uint64_t a4)
{
  uint64_t v5 = result;
  if (a3 == 2147483646)
  {
    *(void *)(result + 48)  = a2;
  }

  else
  {
    uint64_t v7 = sub_100002274(&qword_100407450);
    return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(v7 - 8) + 56LL))( v5 + *(int *)(a4 + 136),  a2,  a2,  v7);
  }

  return result;
}

void sub_1000DED34(uint64_t a1)
{
  v4[0]  = &unk_100343500;
  v4[1]  = &unk_100343518;
  void v4[2] = &unk_100343530;
  v4[3]  = &unk_100343518;
  void v4[4] = &unk_100343530;
  v4[5]  = &unk_100343548;
  void v4[6] = &unk_100343530;
  v4[7]  = &unk_100343560;
  v4[8]  = &unk_100343578;
  void v4[9] = &unk_100343560;
  v4[10]  = &unk_100343590;
  v4[11]  = &unk_1003435A8;
  v4[12]  = &unk_100343560;
  v4[13]  = &unk_100343560;
  v4[14]  = &unk_100343560;
  v4[15]  = &unk_100343560;
  v4[16]  = &unk_100343560;
  v4[17]  = &unk_100343560;
  v4[18]  = &unk_100343560;
  v4[19]  = &unk_100343560;
  v4[20]  = &unk_100343560;
  v4[21]  = &unk_100343560;
  v4[22]  = &unk_100343560;
  v4[23]  = &unk_100343560;
  v4[24]  = &unk_100343560;
  v4[25]  = &unk_100343560;
  v4[26]  = &unk_100343560;
  v4[27]  = &unk_100343560;
  v4[28]  = &unk_100343560;
  v4[29]  = &unk_100343560;
  sub_1000DEE24(319LL);
  if (v3 <= 0x3F)
  {
    v4[30]  = *(void *)(v2 - 8) + 64LL;
    v4[31]  = &unk_1003435A8;
    v4[32]  = &unk_1003435A8;
    swift_initStructMetadata(a1, 256LL, 33LL, v4, a1 + 16);
  }

void sub_1000DEE24(uint64_t a1)
{
  if (!qword_1004078D0)
  {
    uint64_t v2 = type metadata accessor for DispatchTimeInterval(255LL);
    unint64_t v3 = type metadata accessor for Optional(a1, v2);
    if (!v4) {
      atomic_store(v3, (unint64_t *)&qword_1004078D0);
    }
  }

uint64_t getEnumTagSinglePayload for AWDLActionFrame.DataPathState.UnicastMasterIndicationOptions( unsigned __int8 *a1, unsigned int a2)
{
  if (!a2) {
    return 0LL;
  }
  if (a2 < 0xD6) {
    goto LABEL_17;
  }
  if (a2 + 42 >= 0xFFFF00) {
    int v2 = 4;
  }
  else {
    int v2 = 2;
  }
  if ((a2 + 42) >> 8 < 0xFF) {
    int v3 = 1;
  }
  else {
    int v3 = v2;
  }
  if (v3 == 4)
  {
    int v4 = *(_DWORD *)(a1 + 1);
    if (v4) {
      return (*a1 | (v4 << 8)) - 42;
    }
  }

  else
  {
    if (v3 == 2)
    {
      int v4 = *(unsigned __int16 *)(a1 + 1);
      if (!*(_WORD *)(a1 + 1)) {
        goto LABEL_17;
      }
      return (*a1 | (v4 << 8)) - 42;
    }

    int v4 = a1[1];
    if (a1[1]) {
      return (*a1 | (v4 << 8)) - 42;
    }
  }

uint64_t storeEnumTagSinglePayload for AWDLActionFrame.DataPathState.UnicastMasterIndicationOptions( _BYTE *a1, unsigned int a2, unsigned int a3)
{
  if (a3 + 42 >= 0xFFFF00) {
    int v3 = 4;
  }
  else {
    int v3 = 2;
  }
  if ((a3 + 42) >> 8 < 0xFF) {
    LODWORD(v4)  = 1;
  }
  else {
    LODWORD(v4)  = v3;
  }
  if (a3 >= 0xD6) {
    uint64_t v4 = v4;
  }
  else {
    uint64_t v4 = 0LL;
  }
  if (a2 <= 0xD5) {
    return ((uint64_t (*)(void))((char *)&loc_1000DEF54 + 4 * byte_100340CA9[v4]))();
  }
  *a1  = a2 + 42;
  return ((uint64_t (*)(void))((char *)sub_1000DEF88 + 4 * byte_100340CA4[v4]))();
}

uint64_t sub_1000DEF88(uint64_t result)
{
  *(_BYTE *)(result + 1)  = v1;
  return result;
}

uint64_t sub_1000DEF90(uint64_t result, int a2)
{
  *(_WORD *)(result + 1)  = 0;
  if (a2) {
    JUMPOUT(0x1000DEF98LL);
  }
  return result;
}

uint64_t sub_1000DEFA4(uint64_t result, int a2)
{
  *(_DWORD *)(result + 1)  = 0;
  if (!a2) {
    JUMPOUT(0x1000DEFACLL);
  }
  *(_BYTE *)uint64_t result = a2 + 42;
  return result;
}

uint64_t sub_1000DEFB0(uint64_t result)
{
  *(_DWORD *)(result + 1)  = v1;
  return result;
}

uint64_t sub_1000DEFB8(uint64_t result)
{
  *(_WORD *)(result + 1)  = v1;
  return result;
}

ValueMetadata *type metadata accessor for AWDLActionFrame.DataPathState.UnicastMasterIndicationOptions()
{
  return &type metadata for AWDLActionFrame.DataPathState.UnicastMasterIndicationOptions;
}

uint64_t sub_1000DEFD8(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)a1  = *(_BYTE *)a2;
  uint64_t v3 = *(void *)(a2 + 16);
  *(void *)(a1 + 8)  = *(void *)(a2 + 8);
  *(void *)(a1 + 16)  = v3;
  swift_bridgeObjectRetain(v3);
  return a1;
}

uint64_t assignWithCopy for AWDLActionFrame.Arpa(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)a1  = *(_BYTE *)a2;
  *(void *)(a1 + 8)  = *(void *)(a2 + 8);
  uint64_t v3 = *(void *)(a2 + 16);
  uint64_t v4 = *(void *)(a1 + 16);
  *(void *)(a1 + 16)  = v3;
  swift_bridgeObjectRetain(v3);
  swift_bridgeObjectRelease(v4);
  return a1;
}

uint64_t assignWithTake for AWDLActionFrame.Arpa(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)a1  = *(_BYTE *)a2;
  uint64_t v3 = *(void *)(a2 + 16);
  uint64_t v4 = *(void *)(a1 + 16);
  *(void *)(a1 + 8)  = *(void *)(a2 + 8);
  *(void *)(a1 + 16)  = v3;
  swift_bridgeObjectRelease(v4);
  return a1;
}

ValueMetadata *type metadata accessor for AWDLActionFrame.Arpa()
{
  return &type metadata for AWDLActionFrame.Arpa;
}

ValueMetadata *type metadata accessor for AWDLActionFrame.Arpa.Flags()
{
  return &type metadata for AWDLActionFrame.Arpa.Flags;
}

ValueMetadata *type metadata accessor for AWDLActionFrame.SyncTreePath()
{
  return &type metadata for AWDLActionFrame.SyncTreePath;
}

ValueMetadata *type metadata accessor for AWDLActionFrame.AWDLVersion()
{
  return &type metadata for AWDLActionFrame.AWDLVersion;
}

uint64_t storeEnumTagSinglePayload for AWDLActionFrame.Version(_WORD *a1, int a2, int a3)
{
  else {
    int v3 = 4;
  }
  else {
    LODWORD(v4)  = v3;
  }
  if (a3) {
    uint64_t v4 = v4;
  }
  else {
    uint64_t v4 = 0LL;
  }
  if (!a2) {
    return ((uint64_t (*)(void))((char *)sub_1000DF144 + 4 * byte_100340CB3[v4]))();
  }
  *a1  = a2 - 1;
  return ((uint64_t (*)(void))((char *)sub_1000DF124 + 4 * byte_100340CAE[v4]))();
}

uint64_t sub_1000DF124(uint64_t result)
{
  *(_BYTE *)(result + 2)  = v1;
  return result;
}

uint64_t sub_1000DF144(uint64_t result)
{
  *(_BYTE *)(result + 2)  = 0;
  return result;
}

uint64_t sub_1000DF14C(uint64_t result)
{
  *(_DWORD *)(result + 2)  = v1;
  return result;
}

uint64_t sub_1000DF154(uint64_t result)
{
  *(_WORD *)(result + 2)  = v1;
  return result;
}

uint64_t sub_1000DF15C(uint64_t result)
{
  *(_WORD *)(result + 2)  = 0;
  return result;
}

uint64_t sub_1000DF164(uint64_t result)
{
  *(_DWORD *)(result + 2)  = 0;
  return result;
}

ValueMetadata *type metadata accessor for AWDLActionFrame.Version()
{
  return &type metadata for AWDLActionFrame.Version;
}

uint64_t getEnumTagSinglePayload for NANInternetSharingStatistics.Requester.InternetSharingPolicyChannelState( unsigned __int8 *a1, unsigned int a2)
{
  if (!a2) {
    return 0LL;
  }
  if (a2 < 0xFC) {
    goto LABEL_17;
  }
  if (a2 + 4 >= 0xFFFF00) {
    int v2 = 4;
  }
  else {
    int v2 = 2;
  }
  if ((a2 + 4) >> 8 < 0xFF) {
    int v3 = 1;
  }
  else {
    int v3 = v2;
  }
  if (v3 == 4)
  {
    int v4 = *(_DWORD *)(a1 + 1);
    if (v4) {
      return (*a1 | (v4 << 8)) - 4;
    }
  }

  else
  {
    if (v3 == 2)
    {
      int v4 = *(unsigned __int16 *)(a1 + 1);
      if (!*(_WORD *)(a1 + 1)) {
        goto LABEL_17;
      }
      return (*a1 | (v4 << 8)) - 4;
    }

    int v4 = a1[1];
    if (a1[1]) {
      return (*a1 | (v4 << 8)) - 4;
    }
  }

uint64_t storeEnumTagSinglePayload for AWDLActionFrame.Version.PlatformType( _BYTE *a1, unsigned int a2, unsigned int a3)
{
  if (a3 + 4 >= 0xFFFF00) {
    int v3 = 4;
  }
  else {
    int v3 = 2;
  }
  if ((a3 + 4) >> 8 < 0xFF) {
    LODWORD(v4)  = 1;
  }
  else {
    LODWORD(v4)  = v3;
  }
  if (a3 >= 0xFC) {
    uint64_t v4 = v4;
  }
  else {
    uint64_t v4 = 0LL;
  }
  if (a2 <= 0xFB) {
    return ((uint64_t (*)(void))((char *)&loc_1000DF25C + 4 * byte_100340CBD[v4]))();
  }
  *a1  = a2 + 4;
  return ((uint64_t (*)(void))((char *)sub_1000DF290 + 4 * byte_100340CB8[v4]))();
}

uint64_t sub_1000DF290(uint64_t result)
{
  *(_BYTE *)(result + 1)  = v1;
  return result;
}

uint64_t sub_1000DF298(uint64_t result, int a2)
{
  *(_WORD *)(result + 1)  = 0;
  if (a2) {
    JUMPOUT(0x1000DF2A0LL);
  }
  return result;
}

uint64_t sub_1000DF2AC(uint64_t result, int a2)
{
  *(_DWORD *)(result + 1)  = 0;
  if (!a2) {
    JUMPOUT(0x1000DF2B4LL);
  }
  *(_BYTE *)uint64_t result = a2 + 4;
  return result;
}

uint64_t sub_1000DF2B8(uint64_t result)
{
  *(_DWORD *)(result + 1)  = v1;
  return result;
}

uint64_t sub_1000DF2C0(uint64_t result)
{
  *(_WORD *)(result + 1)  = v1;
  return result;
}

ValueMetadata *type metadata accessor for AWDLActionFrame.Version.PlatformType()
{
  return &type metadata for AWDLActionFrame.Version.PlatformType;
}

uint64_t sub_1000DF2E0(uint64_t a1, uint64_t a2)
{
  *(_WORD *)a1  = *(_WORD *)a2;
  uint64_t v3 = *(void *)(a2 + 8);
  *(void *)(a1 + 8)  = v3;
  swift_bridgeObjectRetain(v3);
  return a1;
}

uint64_t assignWithCopy for AWDLActionFrame.PeerMACAddressListBloomFilter(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)a1  = *(_BYTE *)a2;
  *(_BYTE *)(a1 + 1)  = *(_BYTE *)(a2 + 1);
  uint64_t v3 = *(void *)(a2 + 8);
  uint64_t v4 = *(void *)(a1 + 8);
  *(void *)(a1 + 8)  = v3;
  swift_bridgeObjectRetain(v3);
  swift_bridgeObjectRelease(v4);
  return a1;
}

uint64_t assignWithTake for AWDLActionFrame.PeerMACAddressListBloomFilter(uint64_t a1, uint64_t a2)
{
  *(_WORD *)a1  = *(_WORD *)a2;
  uint64_t v3 = *(void *)(a1 + 8);
  *(void *)(a1 + 8)  = *(void *)(a2 + 8);
  swift_bridgeObjectRelease(v3);
  return a1;
}

ValueMetadata *type metadata accessor for AWDLActionFrame.PeerMACAddressListBloomFilter()
{
  return &type metadata for AWDLActionFrame.PeerMACAddressListBloomFilter;
}

ValueMetadata *type metadata accessor for AWDLActionFrame.NANSynchronization()
{
  return &type metadata for AWDLActionFrame.NANSynchronization;
}

ValueMetadata *type metadata accessor for AWDLActionFrame.ElectionParameter()
{
  return &type metadata for AWDLActionFrame.ElectionParameter;
}

ValueMetadata *type metadata accessor for AWDLActionFrame.MultiPeerBSSSteering()
{
  return &type metadata for AWDLActionFrame.MultiPeerBSSSteering;
}

ValueMetadata *type metadata accessor for AWDLActionFrame.MultiPeerBSSSteering.SteeringMessageID()
{
  return &type metadata for AWDLActionFrame.MultiPeerBSSSteering.SteeringMessageID;
}

ValueMetadata *type metadata accessor for AWDLActionFrame.Ranging()
{
  return &type metadata for AWDLActionFrame.Ranging;
}

uint64_t getEnumTagSinglePayload for AWDLActionFrame.RealtimeGroup(uint64_t a1, unsigned int a2)
{
  if (!a2) {
    return 0LL;
  }
  if (a2 >= 0xFD && *(_BYTE *)(a1 + 40)) {
    return (*(_DWORD *)a1 + 253);
  }
  else {
    int v3 = *(unsigned __int8 *)(a1 + 12);
  }
  int v4 = v3 - 4;
  else {
    int v5 = v4;
  }
  return (v5 + 1);
}

uint64_t storeEnumTagSinglePayload for AWDLActionFrame.RealtimeGroup( uint64_t result, unsigned int a2, unsigned int a3)
{
  if (a2 > 0xFC)
  {
    *(_OWORD *)(result + 8)  = 0u;
    *(_OWORD *)(result + 24)  = 0u;
    *(void *)uint64_t result = a2 - 253;
    if (a3 >= 0xFD) {
      *(_BYTE *)(result + 40)  = 1;
    }
  }

  else
  {
    if (a3 >= 0xFD) {
      *(_BYTE *)(result + 40)  = 0;
    }
    if (a2) {
      *(_BYTE *)(result + 12)  = a2 + 3;
    }
  }

  return result;
}

ValueMetadata *type metadata accessor for AWDLActionFrame.RealtimeGroup()
{
  return &type metadata for AWDLActionFrame.RealtimeGroup;
}

ValueMetadata *type metadata accessor for AWDLActionFrame.RealtimeGroup.Flags()
{
  return &type metadata for AWDLActionFrame.RealtimeGroup.Flags;
}

ValueMetadata *type metadata accessor for AWDLActionFrame.RealtimeGroup.AdditionalFlags()
{
  return &type metadata for AWDLActionFrame.RealtimeGroup.AdditionalFlags;
}

ValueMetadata *type metadata accessor for AWDLActionFrame.ExtendedChannelSequence()
{
  return &type metadata for AWDLActionFrame.ExtendedChannelSequence;
}

uint64_t initializeBufferWithCopyOfBuffer for AWDLActionFrame.PreferredChannels(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)a1  = *(_DWORD *)a2;
  *(_WORD *)(a1 + 4)  = *(_WORD *)(a2 + 4);
  uint64_t v3 = *(void *)(a2 + 8);
  *(void *)(a1 + 8)  = v3;
  swift_bridgeObjectRetain(v3);
  return a1;
}

uint64_t assignWithCopy for AWDLActionFrame.PreferredChannels(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)a1  = *(_DWORD *)a2;
  *(_BYTE *)(a1 + 4)  = *(_BYTE *)(a2 + 4);
  *(_BYTE *)(a1 + 5)  = *(_BYTE *)(a2 + 5);
  uint64_t v3 = *(void *)(a2 + 8);
  uint64_t v4 = *(void *)(a1 + 8);
  *(void *)(a1 + 8)  = v3;
  swift_bridgeObjectRetain(v3);
  swift_bridgeObjectRelease(v4);
  return a1;
}

uint64_t assignWithTake for AWDLActionFrame.PreferredChannels(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)a1  = *(_DWORD *)a2;
  *(_WORD *)(a1 + 4)  = *(_WORD *)(a2 + 4);
  uint64_t v3 = *(void *)(a1 + 8);
  *(void *)(a1 + 8)  = *(void *)(a2 + 8);
  swift_bridgeObjectRelease(v3);
  return a1;
}

ValueMetadata *type metadata accessor for AWDLActionFrame.PreferredChannels()
{
  return &type metadata for AWDLActionFrame.PreferredChannels;
}

_DWORD *initializeBufferWithCopyOfBuffer for AWDLActionFrame.PreferredChannels.PreferredChannel( _DWORD *result, int *a2)
{
  int v2 = *a2;
  *(_DWORD *)((char *)result + 3)  = *(int *)((char *)a2 + 3);
  *uint64_t result = v2;
  return result;
}

uint64_t getEnumTagSinglePayload for AWDLActionFrame.PreferredChannels.PreferredChannel( uint64_t a1, unsigned int a2)
{
  if (!a2) {
    return 0LL;
  }
  if (a2 >= 0xFE && *(_BYTE *)(a1 + 7)) {
    return (*(_DWORD *)a1 + 254);
  }
  unsigned int v3 = *(unsigned __int8 *)(a1 + 4);
  BOOL v4 = v3 >= 3;
  int v5 = v3 - 3;
  if (!v4) {
    int v5 = -1;
  }
  return (v5 + 1);
}

uint64_t storeEnumTagSinglePayload for AWDLActionFrame.PreferredChannels.PreferredChannel( uint64_t result, unsigned int a2, unsigned int a3)
{
  if (a2 > 0xFD)
  {
    *(_BYTE *)(result + 6)  = 0;
    *(_WORD *)(result + 4)  = 0;
    *(_DWORD *)uint64_t result = a2 - 254;
    if (a3 >= 0xFE) {
      *(_BYTE *)(result + 7)  = 1;
    }
  }

  else
  {
    if (a3 >= 0xFE) {
      *(_BYTE *)(result + 7)  = 0;
    }
    if (a2) {
      *(_BYTE *)(result + 4)  = a2 + 2;
    }
  }

  return result;
}

ValueMetadata *type metadata accessor for AWDLActionFrame.PreferredChannels.PreferredChannel()
{
  return &type metadata for AWDLActionFrame.PreferredChannels.PreferredChannel;
}

uint64_t getEnumTagSinglePayload for AWDLActionFrame.ProMode(uint64_t a1, unsigned int a2)
{
  if (!a2) {
    return 0LL;
  }
  if (a2 >= 0xFE && *(_BYTE *)(a1 + 12)) {
    return (*(_DWORD *)a1 + 254);
  }
  unsigned int v3 = *(unsigned __int8 *)(a1 + 1);
  BOOL v4 = v3 >= 3;
  int v5 = v3 - 3;
  if (!v4) {
    int v5 = -1;
  }
  return (v5 + 1);
}

uint64_t storeEnumTagSinglePayload for AWDLActionFrame.ProMode( uint64_t result, unsigned int a2, unsigned int a3)
{
  if (a2 > 0xFD)
  {
    *(_DWORD *)(result + 8)  = 0;
    *(void *)uint64_t result = a2 - 254;
    if (a3 >= 0xFE) {
      *(_BYTE *)(result + 12)  = 1;
    }
  }

  else
  {
    if (a3 >= 0xFE) {
      *(_BYTE *)(result + 12)  = 0;
    }
    if (a2) {
      *(_BYTE *)(result + 1)  = a2 + 2;
    }
  }

  return result;
}

ValueMetadata *type metadata accessor for AWDLActionFrame.ProMode()
{
  return &type metadata for AWDLActionFrame.ProMode;
}

ValueMetadata *type metadata accessor for AWDLActionFrame.ProMode.Command()
{
  return &type metadata for AWDLActionFrame.ProMode.Command;
}

ValueMetadata *type metadata accessor for AWDLActionFrame.ProMode.Flags()
{
  return &type metadata for AWDLActionFrame.ProMode.Flags;
}

uint64_t getEnumTagSinglePayload for AWDLActionFrame.AirDrop(unsigned __int16 *a1, unsigned int a2)
{
  if (!a2) {
    return 0LL;
  }
  if (a2 < 0xFF) {
    goto LABEL_17;
  }
  if (a2 + 65281 <= 0xFFFEFFFF) {
    int v2 = 2;
  }
  else {
    int v2 = 4;
  }
  if (a2 + 65281 < 0xFF0000) {
    int v3 = 1;
  }
  else {
    int v3 = v2;
  }
  if (v3 == 4)
  {
    int v4 = *(_DWORD *)(a1 + 1);
    if (v4) {
      return (*a1 | (v4 << 16)) - 65281;
    }
  }

  else
  {
    if (v3 == 2)
    {
      int v4 = a1[1];
      if (!a1[1]) {
        goto LABEL_17;
      }
      return (*a1 | (v4 << 16)) - 65281;
    }

    int v4 = *((unsigned __int8 *)a1 + 2);
    if (*((_BYTE *)a1 + 2)) {
      return (*a1 | (v4 << 16)) - 65281;
    }
  }

uint64_t storeEnumTagSinglePayload for AWDLActionFrame.AirDrop(_WORD *a1, unsigned int a2, unsigned int a3)
{
  if (a3 + 65281 <= 0xFFFEFFFF) {
    int v3 = 2;
  }
  else {
    int v3 = 4;
  }
  if (a3 + 65281 < 0xFF0000) {
    LODWORD(v4)  = 1;
  }
  else {
    LODWORD(v4)  = v3;
  }
  if (a3 >= 0xFF) {
    uint64_t v4 = v4;
  }
  else {
    uint64_t v4 = 0LL;
  }
  if (a2 <= 0xFE) {
    return ((uint64_t (*)(void))((char *)&loc_1000DF804 + 4 * byte_100340CC7[v4]))();
  }
  *a1  = a2 - 255;
  return ((uint64_t (*)(void))((char *)sub_1000DF838 + 4 * byte_100340CC2[v4]))();
}

uint64_t sub_1000DF838(uint64_t result)
{
  *(_BYTE *)(result + 2)  = v1;
  return result;
}

uint64_t sub_1000DF840(uint64_t result, int a2)
{
  *(_WORD *)(result + 2)  = 0;
  if (a2) {
    JUMPOUT(0x1000DF848LL);
  }
  return result;
}

uint64_t sub_1000DF854(uint64_t result, int a2)
{
  *(_DWORD *)(result + 2)  = 0;
  if (!a2) {
    JUMPOUT(0x1000DF85CLL);
  }
  *(_BYTE *)(result + 1)  = a2 + 1;
  return result;
}

uint64_t sub_1000DF860(uint64_t result)
{
  *(_DWORD *)(result + 2)  = v1;
  return result;
}

uint64_t sub_1000DF868(uint64_t result)
{
  *(_WORD *)(result + 2)  = v1;
  return result;
}

ValueMetadata *type metadata accessor for AWDLActionFrame.AirDrop()
{
  return &type metadata for AWDLActionFrame.AirDrop;
}

ValueMetadata *type metadata accessor for AWDLActionFrame.AirDrop.State()
{
  return &type metadata for AWDLActionFrame.AirDrop.State;
}

char *initializeBufferWithCopyOfBuffer for AWDLActionFrame.AWDLAttribute(char *a1, char *a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a3 - 8);
  int v6 = *(_DWORD *)(v5 + 80);
  if ((v6 & 0x20000) == 0)
  {
    switch(swift_getEnumCaseMultiPayload(a2, a3))
    {
      case 0u:
        *(_DWORD *)a1  = *(_DWORD *)a2;
        uint64_t v8 = *((void *)a2 + 1);
        *((void *)a1 + 1)  = v8;
        swift_bridgeObjectRetain(v8);
        swift_storeEnumTagMultiPayload(a1, a3, 0LL);
        return a1;
      case 1u:
        uint64_t v11 = type metadata accessor for AWDLActionFrame.ServiceResponse(0LL);
        uint64_t EnumCaseMultiPayload = swift_getEnumCaseMultiPayload(a2, v11);
        uint64_t v13 = EnumCaseMultiPayload;
        if ((_DWORD)EnumCaseMultiPayload == 2)
        {
          uint64_t v52 = *((void *)a2 + 1);
          *(void *)a1  = *(void *)a2;
          *((void *)a1 + 1)  = v52;
          uint64_t v53 = *((void *)a2 + 3);
          *((void *)a1 + 2)  = *((void *)a2 + 2);
          *((void *)a1 + 3)  = v53;
          a1[32]  = a2[32];
          a1[33]  = a2[33];
          unint64_t v54 = (int *)type metadata accessor for DNSRecords.SRV(0LL);
          uint64_t v55 = v54[5];
          char v64 = &a2[v55];
          char v65 = &a1[v55];
          uint64_t v56 = type metadata accessor for NWEndpoint.Port(0LL);
          int16x8_t v57 = *(void (**)(char *, char *, uint64_t))(*(void *)(v56 - 8) + 16LL);
          swift_bridgeObjectRetain(v52);
          swift_bridgeObjectRetain(v53);
          v57(v65, v64, v56);
          uint64_t v58 = v54[6];
          int64x2_t v59 = &a1[v58];
          int16x8_t v60 = &a2[v58];
          uint64_t v61 = *((void *)v60 + 1);
          *(void *)int64x2_t v59 = *(void *)v60;
          *((void *)v59 + 1)  = v61;
          *(_WORD *)&a1[v54[7]]  = *(_WORD *)&a2[v54[7]];
          *(_WORD *)&a1[v54[8]]  = *(_WORD *)&a2[v54[8]];
        }

        else
        {
          if ((_DWORD)EnumCaseMultiPayload == 1)
          {
            uint64_t v14 = *((void *)a2 + 1);
            *(void *)a1  = *(void *)a2;
            *((void *)a1 + 1)  = v14;
            uint64_t v15 = *((void *)a2 + 3);
            *((void *)a1 + 2)  = *((void *)a2 + 2);
            *((void *)a1 + 3)  = v15;
            a1[32]  = a2[32];
            a1[33]  = a2[33];
            uint64_t v17 = *((void *)a2 + 5);
            unint64_t v16 = *((void *)a2 + 6);
            swift_bridgeObjectRetain(v14);
            swift_bridgeObjectRetain(v15);
            sub_100020AFC(v17, v16);
            *((void *)a1 + 5)  = v17;
            *((void *)a1 + 6)  = v16;
LABEL_26:
            swift_storeEnumTagMultiPayload(a1, v11, v13);
            swift_storeEnumTagMultiPayload(a1, a3, 1LL);
            return a1;
          }

          uint64_t v62 = *((void *)a2 + 1);
          *(void *)a1  = *(void *)a2;
          *((void *)a1 + 1)  = v62;
          uint64_t v63 = *((void *)a2 + 3);
          *((void *)a1 + 2)  = *((void *)a2 + 2);
          *((void *)a1 + 3)  = v63;
          a1[32]  = a2[32];
          a1[33]  = a2[33];
          swift_bridgeObjectRetain(v62);
          uint64_t v61 = v63;
        }

        swift_bridgeObjectRetain(v61);
        goto LABEL_26;
      case 2u:
        *a1  = *a2;
        *(_DWORD *)(a1 + 2)  = *(_DWORD *)(a2 + 2);
        *(void *)(a1 + 6)  = *(void *)(a2 + 6);
        *(_DWORD *)(a1 + 14)  = *(_DWORD *)(a2 + 14);
        *(_DWORD *)(a1 + 18)  = *(_DWORD *)(a2 + 18);
        *(void *)(a1 + 22)  = *(void *)(a2 + 22);
        *(_DWORD *)(a1 + 30)  = *(_DWORD *)(a2 + 30);
        uint64_t v18 = *((void *)a2 + 5);
        *((void *)a1 + 5)  = v18;
        swift_bridgeObjectRetain(v18);
        swift_storeEnumTagMultiPayload(a1, a3, 2LL);
        return a1;
      case 4u:
        uint64_t v19 = *(void *)a2;
        *(void *)a1  = *(void *)a2;
        swift_bridgeObjectRetain(v19);
        swift_storeEnumTagMultiPayload(a1, a3, 4LL);
        return a1;
      case 5u:
        *a1  = *a2;
        *(_DWORD *)(a1 + 2)  = *(_DWORD *)(a2 + 2);
        *((_DWORD *)a1 + 2)  = *((_DWORD *)a2 + 2);
        uint64_t v21 = *((void *)a2 + 2);
        unint64_t v20 = *((void *)a2 + 3);
        sub_100020AFC(v21, v20);
        *((void *)a1 + 2)  = v21;
        *((void *)a1 + 3)  = v20;
        swift_storeEnumTagMultiPayload(a1, a3, 5LL);
        return a1;
      case 6u:
        *(_WORD *)a1  = *(_WORD *)a2;
        a1[2]  = a2[2];
        *((_DWORD *)a1 + 1)  = *((_DWORD *)a2 + 1);
        *((_WORD *)a1 + 4)  = *((_WORD *)a2 + 4);
        *(_DWORD *)(a1 + 10)  = *(_DWORD *)(a2 + 10);
        *(_DWORD *)(a1 + 13)  = *(_DWORD *)(a2 + 13);
        *((_WORD *)a1 + 12)  = *((_WORD *)a2 + 12);
        *((_DWORD *)a1 + 5)  = *((_DWORD *)a2 + 5);
        int v22 = *(_DWORD *)(a2 + 26);
        *(_DWORD *)(a1 + 29)  = *(_DWORD *)(a2 + 29);
        *(_DWORD *)(a1 + 26)  = v22;
        uint64_t v23 = *((void *)a2 + 6);
        *((void *)a1 + 5)  = *((void *)a2 + 5);
        *((void *)a1 + 6)  = v23;
        *((_DWORD *)a1 + 14)  = *((_DWORD *)a2 + 14);
        *(_DWORD *)(a1 + 59)  = *(_DWORD *)(a2 + 59);
        a1[63]  = a2[63];
        *((_DWORD *)a1 + 16)  = *((_DWORD *)a2 + 16);
        a1[68]  = a2[68];
        int v24 = *((_DWORD *)a2 + 18);
        a1[76]  = a2[76];
        *((_DWORD *)a1 + 18)  = v24;
        *(_OWORD *)(a1 + 77)  = *(_OWORD *)(a2 + 77);
        *(_WORD *)(a1 + 93)  = *(_WORD *)(a2 + 93);
        uint64_t v25 = (int *)type metadata accessor for AWDLActionFrame.DataPathState(0LL);
        uint64_t v26 = v25[34];
        int v27 = &a1[v26];
        uint64_t v28 = &a2[v26];
        uint64_t v29 = type metadata accessor for DispatchTimeInterval(0LL);
        uint64_t v30 = *(void *)(v29 - 8);
        int v31 = *(unsigned int (**)(char *, uint64_t, uint64_t))(v30 + 48);
        swift_bridgeObjectRetain(v23);
        if (v31(v28, 1LL, v29))
        {
          uint64_t v32 = sub_100002274(&qword_100407450);
          memcpy(v27, v28, *(void *)(*(void *)(v32 - 8) + 64LL));
        }

        else
        {
          (*(void (**)(char *, char *, uint64_t))(v30 + 16))(v27, v28, v29);
          (*(void (**)(char *, void, uint64_t, uint64_t))(v30 + 56))(v27, 0LL, 1LL, v29);
        }

        uint64_t v46 = v25[35];
        uint64_t v47 = &a1[v46];
        uint64_t v48 = &a2[v46];
        *(_DWORD *)uint64_t v47 = *(_DWORD *)v48;
        v47[4]  = v48[4];
        uint64_t v49 = v25[36];
        uint64_t v50 = &a1[v49];
        char v51 = &a2[v49];
        v50[4]  = v51[4];
        *(_DWORD *)uint64_t v50 = *(_DWORD *)v51;
        swift_storeEnumTagMultiPayload(a1, a3, 6LL);
        return a1;
      case 7u:
        *a1  = *a2;
        uint64_t v33 = *((void *)a2 + 2);
        *((void *)a1 + 1)  = *((void *)a2 + 1);
        *((void *)a1 + 2)  = v33;
        swift_bridgeObjectRetain(v33);
        swift_storeEnumTagMultiPayload(a1, a3, 7LL);
        return a1;
      case 8u:
        uint64_t v34 = *(void *)a2;
        *(void *)a1  = *(void *)a2;
        swift_bridgeObjectRetain(v34);
        swift_storeEnumTagMultiPayload(a1, a3, 8LL);
        return a1;
      case 0xAu:
        *(_WORD *)a1  = *(_WORD *)a2;
        uint64_t v45 = *((void *)a2 + 1);
        *((void *)a1 + 1)  = v45;
        swift_bridgeObjectRetain(v45);
        swift_storeEnumTagMultiPayload(a1, a3, 10LL);
        return a1;
      case 0xDu:
        uint64_t v35 = *(void *)a2;
        unint64_t v36 = *((void *)a2 + 1);
        unint64_t v37 = *((void *)a2 + 2);
        uint64_t v38 = *((void *)a2 + 3);
        uint64_t v39 = *((void *)a2 + 4);
        unint64_t v40 = *((void *)a2 + 5);
        char v41 = a2[48];
        sub_100058460(v35, v36, v37, v38, v39, v40, v41);
        *(void *)a1  = v35;
        *((void *)a1 + 1)  = v36;
        *((void *)a1 + 2)  = v37;
        *((void *)a1 + 3)  = v38;
        *((void *)a1 + 4)  = v39;
        *((void *)a1 + 5)  = v40;
        a1[48]  = v41;
        swift_storeEnumTagMultiPayload(a1, a3, 13LL);
        return a1;
      case 0xEu:
        *(_DWORD *)a1  = *(_DWORD *)a2;
        a1[4]  = a2[4];
        uint64_t v43 = *((void *)a2 + 1);
        unint64_t v42 = *((void *)a2 + 2);
        sub_100020AFC(v43, v42);
        *((void *)a1 + 1)  = v43;
        *((void *)a1 + 2)  = v42;
        swift_storeEnumTagMultiPayload(a1, a3, 14LL);
        return a1;
      case 0x12u:
        *(_DWORD *)a1  = *(_DWORD *)a2;
        *((_WORD *)a1 + 2)  = *((_WORD *)a2 + 2);
        uint64_t v44 = *((void *)a2 + 1);
        *((void *)a1 + 1)  = v44;
        swift_bridgeObjectRetain(v44);
        swift_storeEnumTagMultiPayload(a1, a3, 18LL);
        return a1;
      default:
        memcpy(a1, a2, *(void *)(v5 + 64));
        return a1;
    }
  }

  uint64_t v9 = *(void *)a2;
  *(void *)a1  = *(void *)a2;
  a1  = (char *)(v9 + ((v6 + 16LL) & ~(unint64_t)v6));
  swift_retain();
  return a1;
}

uint64_t destroy for AWDLActionFrame.AWDLAttribute(uint64_t a1, uint64_t a2)
{
  uint64_t result = swift_getEnumCaseMultiPayload(a1, a2);
  switch((int)result)
  {
    case 0:
    case 10:
    case 18:
      uint64_t v4 = *(void *)(a1 + 8);
      return swift_bridgeObjectRelease(v4);
    case 1:
      uint64_t v5 = type metadata accessor for AWDLActionFrame.ServiceResponse(0LL);
      uint64_t result = swift_getEnumCaseMultiPayload(a1, v5);
      if ((_DWORD)result == 2)
      {
        swift_bridgeObjectRelease(*(void *)(a1 + 8));
        swift_bridgeObjectRelease(*(void *)(a1 + 24));
        uint64_t v11 = type metadata accessor for DNSRecords.SRV(0LL);
        uint64_t v12 = a1 + *(int *)(v11 + 20);
        uint64_t v13 = type metadata accessor for NWEndpoint.Port(0LL);
        (*(void (**)(uint64_t, uint64_t))(*(void *)(v13 - 8) + 8LL))(v12, v13);
        uint64_t v4 = *(void *)(a1 + *(int *)(v11 + 24) + 8);
        return swift_bridgeObjectRelease(v4);
      }

      if ((_DWORD)result != 1)
      {
        if ((_DWORD)result) {
          return result;
        }
        swift_bridgeObjectRelease(*(void *)(a1 + 8));
        uint64_t v4 = *(void *)(a1 + 24);
        return swift_bridgeObjectRelease(v4);
      }

      swift_bridgeObjectRelease(*(void *)(a1 + 8));
      swift_bridgeObjectRelease(*(void *)(a1 + 24));
      uint64_t v6 = *(void *)(a1 + 40);
      unint64_t v7 = *(void *)(a1 + 48);
      return sub_1000208D8(v6, v7);
    case 2:
      uint64_t v4 = *(void *)(a1 + 40);
      return swift_bridgeObjectRelease(v4);
    case 4:
    case 8:
      uint64_t v4 = *(void *)a1;
      return swift_bridgeObjectRelease(v4);
    case 5:
      uint64_t v6 = *(void *)(a1 + 16);
      unint64_t v7 = *(void *)(a1 + 24);
      return sub_1000208D8(v6, v7);
    case 6:
      swift_bridgeObjectRelease(*(void *)(a1 + 48));
      uint64_t v8 = a1 + *(int *)(type metadata accessor for AWDLActionFrame.DataPathState(0LL) + 136);
      uint64_t v9 = type metadata accessor for DispatchTimeInterval(0LL);
      uint64_t v10 = *(void *)(v9 - 8);
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v10 + 48))(v8, 1LL, v9);
      if (!(_DWORD)result) {
        return (*(uint64_t (**)(uint64_t, uint64_t))(v10 + 8))(v8, v9);
      }
      return result;
    case 7:
      uint64_t v4 = *(void *)(a1 + 16);
      return swift_bridgeObjectRelease(v4);
    case 13:
      return sub_100057CD0( *(void *)a1,  *(void *)(a1 + 8),  *(void *)(a1 + 16),  *(void *)(a1 + 24),  *(void *)(a1 + 32),  *(void *)(a1 + 40),  *(_BYTE *)(a1 + 48));
    case 14:
      uint64_t v6 = *(void *)(a1 + 8);
      unint64_t v7 = *(void *)(a1 + 16);
      return sub_1000208D8(v6, v7);
    default:
      return result;
  }

char *initializeWithCopy for AWDLActionFrame.AWDLAttribute(char *a1, char *a2, uint64_t a3)
{
  switch(swift_getEnumCaseMultiPayload(a2, a3))
  {
    case 0u:
      *(_DWORD *)a1  = *(_DWORD *)a2;
      uint64_t v6 = *((void *)a2 + 1);
      *((void *)a1 + 1)  = v6;
      swift_bridgeObjectRetain(v6);
      unint64_t v7 = a1;
      uint64_t v8 = a3;
      uint64_t v9 = 0LL;
      goto LABEL_24;
    case 1u:
      uint64_t v10 = type metadata accessor for AWDLActionFrame.ServiceResponse(0LL);
      uint64_t EnumCaseMultiPayload = swift_getEnumCaseMultiPayload(a2, v10);
      uint64_t v12 = EnumCaseMultiPayload;
      if ((_DWORD)EnumCaseMultiPayload == 2)
      {
        uint64_t v51 = *((void *)a2 + 1);
        *(void *)a1  = *(void *)a2;
        *((void *)a1 + 1)  = v51;
        uint64_t v52 = *((void *)a2 + 3);
        *((void *)a1 + 2)  = *((void *)a2 + 2);
        *((void *)a1 + 3)  = v52;
        a1[32]  = a2[32];
        a1[33]  = a2[33];
        uint64_t v53 = (int *)type metadata accessor for DNSRecords.SRV(0LL);
        uint64_t v54 = v53[5];
        char v64 = &a2[v54];
        char v65 = &a1[v54];
        uint64_t v55 = type metadata accessor for NWEndpoint.Port(0LL);
        uint64_t v56 = *(void (**)(char *, char *, uint64_t))(*(void *)(v55 - 8) + 16LL);
        swift_bridgeObjectRetain(v51);
        swift_bridgeObjectRetain(v52);
        v56(v65, v64, v55);
        uint64_t v57 = v53[6];
        uint64_t v58 = &a1[v57];
        int64x2_t v59 = &a2[v57];
        uint64_t v60 = *((void *)v59 + 1);
        *(void *)uint64_t v58 = *(void *)v59;
        *((void *)v58 + 1)  = v60;
        *(_WORD *)&a1[v53[7]]  = *(_WORD *)&a2[v53[7]];
        *(_WORD *)&a1[v53[8]]  = *(_WORD *)&a2[v53[8]];
      }

      else
      {
        if ((_DWORD)EnumCaseMultiPayload == 1)
        {
          uint64_t v13 = *((void *)a2 + 1);
          *(void *)a1  = *(void *)a2;
          *((void *)a1 + 1)  = v13;
          uint64_t v14 = *((void *)a2 + 3);
          *((void *)a1 + 2)  = *((void *)a2 + 2);
          *((void *)a1 + 3)  = v14;
          a1[32]  = a2[32];
          a1[33]  = a2[33];
          uint64_t v16 = *((void *)a2 + 5);
          unint64_t v15 = *((void *)a2 + 6);
          swift_bridgeObjectRetain(v13);
          swift_bridgeObjectRetain(v14);
          sub_100020AFC(v16, v15);
          *((void *)a1 + 5)  = v16;
          *((void *)a1 + 6)  = v15;
          goto LABEL_23;
        }

        uint64_t v61 = *((void *)a2 + 1);
        *(void *)a1  = *(void *)a2;
        *((void *)a1 + 1)  = v61;
        uint64_t v62 = *((void *)a2 + 3);
        *((void *)a1 + 2)  = *((void *)a2 + 2);
        *((void *)a1 + 3)  = v62;
        a1[32]  = a2[32];
        a1[33]  = a2[33];
        swift_bridgeObjectRetain(v61);
        uint64_t v60 = v62;
      }

      swift_bridgeObjectRetain(v60);
LABEL_23:
      swift_storeEnumTagMultiPayload(a1, v10, v12);
      unint64_t v7 = a1;
      uint64_t v8 = a3;
      uint64_t v9 = 1LL;
LABEL_24:
      swift_storeEnumTagMultiPayload(v7, v8, v9);
      return a1;
    case 2u:
      *a1  = *a2;
      *(_DWORD *)(a1 + 2)  = *(_DWORD *)(a2 + 2);
      *(void *)(a1 + 6)  = *(void *)(a2 + 6);
      *(_DWORD *)(a1 + 14)  = *(_DWORD *)(a2 + 14);
      *(_DWORD *)(a1 + 18)  = *(_DWORD *)(a2 + 18);
      *(void *)(a1 + 22)  = *(void *)(a2 + 22);
      *(_DWORD *)(a1 + 30)  = *(_DWORD *)(a2 + 30);
      uint64_t v17 = *((void *)a2 + 5);
      *((void *)a1 + 5)  = v17;
      swift_bridgeObjectRetain(v17);
      unint64_t v7 = a1;
      uint64_t v8 = a3;
      uint64_t v9 = 2LL;
      goto LABEL_24;
    case 4u:
      uint64_t v18 = *(void *)a2;
      *(void *)a1  = *(void *)a2;
      swift_bridgeObjectRetain(v18);
      unint64_t v7 = a1;
      uint64_t v8 = a3;
      uint64_t v9 = 4LL;
      goto LABEL_24;
    case 5u:
      *a1  = *a2;
      *(_DWORD *)(a1 + 2)  = *(_DWORD *)(a2 + 2);
      *((_DWORD *)a1 + 2)  = *((_DWORD *)a2 + 2);
      uint64_t v20 = *((void *)a2 + 2);
      unint64_t v19 = *((void *)a2 + 3);
      sub_100020AFC(v20, v19);
      *((void *)a1 + 2)  = v20;
      *((void *)a1 + 3)  = v19;
      unint64_t v7 = a1;
      uint64_t v8 = a3;
      uint64_t v9 = 5LL;
      goto LABEL_24;
    case 6u:
      *(_WORD *)a1  = *(_WORD *)a2;
      a1[2]  = a2[2];
      *((_DWORD *)a1 + 1)  = *((_DWORD *)a2 + 1);
      *((_WORD *)a1 + 4)  = *((_WORD *)a2 + 4);
      *(_DWORD *)(a1 + 10)  = *(_DWORD *)(a2 + 10);
      *(_DWORD *)(a1 + 13)  = *(_DWORD *)(a2 + 13);
      *((_WORD *)a1 + 12)  = *((_WORD *)a2 + 12);
      *((_DWORD *)a1 + 5)  = *((_DWORD *)a2 + 5);
      int v21 = *(_DWORD *)(a2 + 26);
      *(_DWORD *)(a1 + 29)  = *(_DWORD *)(a2 + 29);
      *(_DWORD *)(a1 + 26)  = v21;
      uint64_t v22 = *((void *)a2 + 6);
      *((void *)a1 + 5)  = *((void *)a2 + 5);
      *((void *)a1 + 6)  = v22;
      *((_DWORD *)a1 + 14)  = *((_DWORD *)a2 + 14);
      *(_DWORD *)(a1 + 59)  = *(_DWORD *)(a2 + 59);
      a1[63]  = a2[63];
      *((_DWORD *)a1 + 16)  = *((_DWORD *)a2 + 16);
      a1[68]  = a2[68];
      int v23 = *((_DWORD *)a2 + 18);
      a1[76]  = a2[76];
      *((_DWORD *)a1 + 18)  = v23;
      *(_OWORD *)(a1 + 77)  = *(_OWORD *)(a2 + 77);
      *(_WORD *)(a1 + 93)  = *(_WORD *)(a2 + 93);
      int v24 = (int *)type metadata accessor for AWDLActionFrame.DataPathState(0LL);
      uint64_t v25 = v24[34];
      uint64_t v26 = &a1[v25];
      int v27 = &a2[v25];
      uint64_t v28 = type metadata accessor for DispatchTimeInterval(0LL);
      uint64_t v29 = *(void *)(v28 - 8);
      uint64_t v30 = *(unsigned int (**)(char *, uint64_t, uint64_t))(v29 + 48);
      swift_bridgeObjectRetain(v22);
      if (v30(v27, 1LL, v28))
      {
        uint64_t v31 = sub_100002274(&qword_100407450);
        memcpy(v26, v27, *(void *)(*(void *)(v31 - 8) + 64LL));
      }

      else
      {
        (*(void (**)(char *, char *, uint64_t))(v29 + 16))(v26, v27, v28);
        (*(void (**)(char *, void, uint64_t, uint64_t))(v29 + 56))(v26, 0LL, 1LL, v28);
      }

      uint64_t v45 = v24[35];
      uint64_t v46 = &a1[v45];
      uint64_t v47 = &a2[v45];
      *(_DWORD *)uint64_t v46 = *(_DWORD *)v47;
      v46[4]  = v47[4];
      uint64_t v48 = v24[36];
      uint64_t v49 = &a1[v48];
      uint64_t v50 = &a2[v48];
      v49[4]  = v50[4];
      *(_DWORD *)uint64_t v49 = *(_DWORD *)v50;
      unint64_t v7 = a1;
      uint64_t v8 = a3;
      uint64_t v9 = 6LL;
      goto LABEL_24;
    case 7u:
      *a1  = *a2;
      uint64_t v32 = *((void *)a2 + 2);
      *((void *)a1 + 1)  = *((void *)a2 + 1);
      *((void *)a1 + 2)  = v32;
      swift_bridgeObjectRetain(v32);
      unint64_t v7 = a1;
      uint64_t v8 = a3;
      uint64_t v9 = 7LL;
      goto LABEL_24;
    case 8u:
      uint64_t v33 = *(void *)a2;
      *(void *)a1  = *(void *)a2;
      swift_bridgeObjectRetain(v33);
      unint64_t v7 = a1;
      uint64_t v8 = a3;
      uint64_t v9 = 8LL;
      goto LABEL_24;
    case 0xAu:
      *(_WORD *)a1  = *(_WORD *)a2;
      uint64_t v44 = *((void *)a2 + 1);
      *((void *)a1 + 1)  = v44;
      swift_bridgeObjectRetain(v44);
      unint64_t v7 = a1;
      uint64_t v8 = a3;
      uint64_t v9 = 10LL;
      goto LABEL_24;
    case 0xDu:
      uint64_t v34 = *(void *)a2;
      unint64_t v35 = *((void *)a2 + 1);
      unint64_t v36 = *((void *)a2 + 2);
      uint64_t v37 = *((void *)a2 + 3);
      uint64_t v38 = *((void *)a2 + 4);
      unint64_t v39 = *((void *)a2 + 5);
      char v40 = a2[48];
      sub_100058460(v34, v35, v36, v37, v38, v39, v40);
      *(void *)a1  = v34;
      *((void *)a1 + 1)  = v35;
      *((void *)a1 + 2)  = v36;
      *((void *)a1 + 3)  = v37;
      *((void *)a1 + 4)  = v38;
      *((void *)a1 + 5)  = v39;
      a1[48]  = v40;
      unint64_t v7 = a1;
      uint64_t v8 = a3;
      uint64_t v9 = 13LL;
      goto LABEL_24;
    case 0xEu:
      *(_DWORD *)a1  = *(_DWORD *)a2;
      a1[4]  = a2[4];
      uint64_t v42 = *((void *)a2 + 1);
      unint64_t v41 = *((void *)a2 + 2);
      sub_100020AFC(v42, v41);
      *((void *)a1 + 1)  = v42;
      *((void *)a1 + 2)  = v41;
      unint64_t v7 = a1;
      uint64_t v8 = a3;
      uint64_t v9 = 14LL;
      goto LABEL_24;
    case 0x12u:
      *(_DWORD *)a1  = *(_DWORD *)a2;
      *((_WORD *)a1 + 2)  = *((_WORD *)a2 + 2);
      uint64_t v43 = *((void *)a2 + 1);
      *((void *)a1 + 1)  = v43;
      swift_bridgeObjectRetain(v43);
      unint64_t v7 = a1;
      uint64_t v8 = a3;
      uint64_t v9 = 18LL;
      goto LABEL_24;
    default:
      memcpy(a1, a2, *(void *)(*(void *)(a3 - 8) + 64LL));
      return a1;
  }

char *assignWithCopy for AWDLActionFrame.AWDLAttribute(char *a1, char *a2, uint64_t a3)
{
  if (a1 != a2)
  {
    sub_10005802C((uint64_t)a1, type metadata accessor for AWDLActionFrame.AWDLAttribute);
    switch(swift_getEnumCaseMultiPayload(a2, a3))
    {
      case 0u:
        *(_WORD *)a1  = *(_WORD *)a2;
        *((_WORD *)a1 + 1)  = *((_WORD *)a2 + 1);
        uint64_t v6 = *((void *)a2 + 1);
        *((void *)a1 + 1)  = v6;
        swift_bridgeObjectRetain(v6);
        unint64_t v7 = a1;
        uint64_t v8 = a3;
        uint64_t v9 = 0LL;
        goto LABEL_25;
      case 1u:
        uint64_t v10 = type metadata accessor for AWDLActionFrame.ServiceResponse(0LL);
        uint64_t EnumCaseMultiPayload = swift_getEnumCaseMultiPayload(a2, v10);
        uint64_t v12 = EnumCaseMultiPayload;
        if ((_DWORD)EnumCaseMultiPayload == 2)
        {
          *(void *)a1  = *(void *)a2;
          uint64_t v60 = *((void *)a2 + 1);
          *((void *)a1 + 1)  = v60;
          *((void *)a1 + 2)  = *((void *)a2 + 2);
          uint64_t v61 = *((void *)a2 + 3);
          *((void *)a1 + 3)  = v61;
          a1[32]  = a2[32];
          a1[33]  = a2[33];
          uint64_t v62 = (int *)type metadata accessor for DNSRecords.SRV(0LL);
          uint64_t v63 = v62[5];
          char v73 = &a2[v63];
          uint64_t v74 = &a1[v63];
          uint64_t v64 = type metadata accessor for NWEndpoint.Port(0LL);
          char v65 = *(void (**)(char *, char *, uint64_t))(*(void *)(v64 - 8) + 16LL);
          swift_bridgeObjectRetain(v60);
          swift_bridgeObjectRetain(v61);
          v65(v74, v73, v64);
          uint64_t v66 = v62[6];
          __int16 v67 = &a1[v66];
          uint64_t v68 = &a2[v66];
          *(void *)__int16 v67 = *(void *)v68;
          uint64_t v69 = *((void *)v68 + 1);
          *((void *)v67 + 1)  = v69;
          *(_WORD *)&a1[v62[7]]  = *(_WORD *)&a2[v62[7]];
          *(_WORD *)&a1[v62[8]]  = *(_WORD *)&a2[v62[8]];
        }

        else
        {
          if ((_DWORD)EnumCaseMultiPayload == 1)
          {
            *(void *)a1  = *(void *)a2;
            uint64_t v13 = *((void *)a2 + 1);
            *((void *)a1 + 1)  = v13;
            *((void *)a1 + 2)  = *((void *)a2 + 2);
            uint64_t v14 = *((void *)a2 + 3);
            *((void *)a1 + 3)  = v14;
            a1[32]  = a2[32];
            a1[33]  = a2[33];
            uint64_t v16 = *((void *)a2 + 5);
            unint64_t v15 = *((void *)a2 + 6);
            swift_bridgeObjectRetain(v13);
            swift_bridgeObjectRetain(v14);
            sub_100020AFC(v16, v15);
            *((void *)a1 + 5)  = v16;
            *((void *)a1 + 6)  = v15;
            goto LABEL_24;
          }

          *(void *)a1  = *(void *)a2;
          uint64_t v70 = *((void *)a2 + 1);
          *((void *)a1 + 1)  = v70;
          *((void *)a1 + 2)  = *((void *)a2 + 2);
          uint64_t v71 = *((void *)a2 + 3);
          *((void *)a1 + 3)  = v71;
          a1[32]  = a2[32];
          a1[33]  = a2[33];
          swift_bridgeObjectRetain(v70);
          uint64_t v69 = v71;
        }

        swift_bridgeObjectRetain(v69);
LABEL_24:
        swift_storeEnumTagMultiPayload(a1, v10, v12);
        unint64_t v7 = a1;
        uint64_t v8 = a3;
        uint64_t v9 = 1LL;
LABEL_25:
        swift_storeEnumTagMultiPayload(v7, v8, v9);
        break;
      case 2u:
        *a1  = *a2;
        *((_WORD *)a1 + 1)  = *((_WORD *)a2 + 1);
        a1[4]  = a2[4];
        a1[5]  = a2[5];
        *((_WORD *)a1 + 3)  = *((_WORD *)a2 + 3);
        *((_WORD *)a1 + 4)  = *((_WORD *)a2 + 4);
        *((_WORD *)a1 + 5)  = *((_WORD *)a2 + 5);
        *((_WORD *)a1 + 6)  = *((_WORD *)a2 + 6);
        *((_WORD *)a1 + 7)  = *((_WORD *)a2 + 7);
        *((_WORD *)a1 + 8)  = *((_WORD *)a2 + 8);
        a1[18]  = a2[18];
        a1[19]  = a2[19];
        a1[20]  = a2[20];
        a1[21]  = a2[21];
        int v17 = *(_DWORD *)(a2 + 22);
        *((_WORD *)a1 + 13)  = *((_WORD *)a2 + 13);
        *(_DWORD *)(a1 + 22)  = v17;
        a1[28]  = a2[28];
        a1[29]  = a2[29];
        *((_WORD *)a1 + 15)  = *((_WORD *)a2 + 15);
        *((_WORD *)a1 + 16)  = *((_WORD *)a2 + 16);
        uint64_t v18 = *((void *)a2 + 5);
        *((void *)a1 + 5)  = v18;
        swift_bridgeObjectRetain(v18);
        unint64_t v7 = a1;
        uint64_t v8 = a3;
        uint64_t v9 = 2LL;
        goto LABEL_25;
      case 4u:
        uint64_t v19 = *(void *)a2;
        *(void *)a1  = *(void *)a2;
        swift_bridgeObjectRetain(v19);
        unint64_t v7 = a1;
        uint64_t v8 = a3;
        uint64_t v9 = 4LL;
        goto LABEL_25;
      case 5u:
        *a1  = *a2;
        *((_WORD *)a1 + 1)  = *((_WORD *)a2 + 1);
        *((_WORD *)a1 + 2)  = *((_WORD *)a2 + 2);
        *((_DWORD *)a1 + 2)  = *((_DWORD *)a2 + 2);
        uint64_t v21 = *((void *)a2 + 2);
        unint64_t v20 = *((void *)a2 + 3);
        sub_100020AFC(v21, v20);
        *((void *)a1 + 2)  = v21;
        *((void *)a1 + 3)  = v20;
        unint64_t v7 = a1;
        uint64_t v8 = a3;
        uint64_t v9 = 5LL;
        goto LABEL_25;
      case 6u:
        __int16 v22 = *(_WORD *)a2;
        a1[2]  = a2[2];
        *(_WORD *)a1  = v22;
        int v23 = *((_DWORD *)a2 + 1);
        *((_WORD *)a1 + 4)  = *((_WORD *)a2 + 4);
        *((_DWORD *)a1 + 1)  = v23;
        int v24 = *(_DWORD *)(a2 + 10);
        *(_DWORD *)(a1 + 13)  = *(_DWORD *)(a2 + 13);
        *(_DWORD *)(a1 + 10)  = v24;
        int v25 = *((_DWORD *)a2 + 5);
        *((_WORD *)a1 + 12)  = *((_WORD *)a2 + 12);
        *((_DWORD *)a1 + 5)  = v25;
        int v26 = *(_DWORD *)(a2 + 26);
        *(_DWORD *)(a1 + 29)  = *(_DWORD *)(a2 + 29);
        *(_DWORD *)(a1 + 26)  = v26;
        *((void *)a1 + 5)  = *((void *)a2 + 5);
        uint64_t v27 = *((void *)a2 + 6);
        *((void *)a1 + 6)  = v27;
        int v28 = *((_DWORD *)a2 + 14);
        *(_DWORD *)(a1 + 59)  = *(_DWORD *)(a2 + 59);
        *((_DWORD *)a1 + 14)  = v28;
        a1[63]  = a2[63];
        a1[64]  = a2[64];
        a1[65]  = a2[65];
        LOWORD(v28)  = *((_WORD *)a2 + 33);
        a1[68]  = a2[68];
        *((_WORD *)a1 + 33)  = v28;
        int v29 = *((_DWORD *)a2 + 18);
        a1[76]  = a2[76];
        *((_DWORD *)a1 + 18)  = v29;
        a1[77]  = a2[77];
        a1[78]  = a2[78];
        a1[79]  = a2[79];
        a1[80]  = a2[80];
        a1[81]  = a2[81];
        a1[82]  = a2[82];
        a1[83]  = a2[83];
        a1[84]  = a2[84];
        a1[85]  = a2[85];
        a1[86]  = a2[86];
        a1[87]  = a2[87];
        a1[88]  = a2[88];
        a1[89]  = a2[89];
        a1[90]  = a2[90];
        a1[91]  = a2[91];
        a1[92]  = a2[92];
        a1[93]  = a2[93];
        a1[94]  = a2[94];
        uint64_t v30 = (int *)type metadata accessor for AWDLActionFrame.DataPathState(0LL);
        uint64_t v31 = v30[34];
        uint64_t v32 = &a1[v31];
        uint64_t v33 = &a2[v31];
        uint64_t v34 = type metadata accessor for DispatchTimeInterval(0LL);
        uint64_t v35 = *(void *)(v34 - 8);
        unint64_t v36 = *(unsigned int (**)(char *, uint64_t, uint64_t))(v35 + 48);
        swift_bridgeObjectRetain(v27);
        if (v36(v33, 1LL, v34))
        {
          uint64_t v37 = sub_100002274(&qword_100407450);
          memcpy(v32, v33, *(void *)(*(void *)(v37 - 8) + 64LL));
        }

        else
        {
          (*(void (**)(char *, char *, uint64_t))(v35 + 16))(v32, v33, v34);
          (*(void (**)(char *, void, uint64_t, uint64_t))(v35 + 56))(v32, 0LL, 1LL, v34);
        }

        uint64_t v52 = v30[35];
        uint64_t v53 = &a1[v52];
        uint64_t v54 = &a2[v52];
        int v55 = *(_DWORD *)v54;
        v53[4]  = v54[4];
        *(_DWORD *)uint64_t v53 = v55;
        uint64_t v56 = v30[36];
        uint64_t v57 = &a1[v56];
        uint64_t v58 = &a2[v56];
        int v59 = *(_DWORD *)v58;
        v57[4]  = v58[4];
        *(_DWORD *)uint64_t v57 = v59;
        unint64_t v7 = a1;
        uint64_t v8 = a3;
        uint64_t v9 = 6LL;
        goto LABEL_25;
      case 7u:
        *a1  = *a2;
        *((void *)a1 + 1)  = *((void *)a2 + 1);
        uint64_t v38 = *((void *)a2 + 2);
        *((void *)a1 + 2)  = v38;
        swift_bridgeObjectRetain(v38);
        unint64_t v7 = a1;
        uint64_t v8 = a3;
        uint64_t v9 = 7LL;
        goto LABEL_25;
      case 8u:
        uint64_t v39 = *(void *)a2;
        *(void *)a1  = *(void *)a2;
        swift_bridgeObjectRetain(v39);
        unint64_t v7 = a1;
        uint64_t v8 = a3;
        uint64_t v9 = 8LL;
        goto LABEL_25;
      case 0xAu:
        *a1  = *a2;
        a1[1]  = a2[1];
        uint64_t v51 = *((void *)a2 + 1);
        *((void *)a1 + 1)  = v51;
        swift_bridgeObjectRetain(v51);
        unint64_t v7 = a1;
        uint64_t v8 = a3;
        uint64_t v9 = 10LL;
        goto LABEL_25;
      case 0xDu:
        uint64_t v40 = *(void *)a2;
        unint64_t v41 = *((void *)a2 + 1);
        unint64_t v42 = *((void *)a2 + 2);
        uint64_t v43 = *((void *)a2 + 3);
        uint64_t v44 = *((void *)a2 + 4);
        unint64_t v45 = *((void *)a2 + 5);
        char v46 = a2[48];
        sub_100058460(v40, v41, v42, v43, v44, v45, v46);
        *(void *)a1  = v40;
        *((void *)a1 + 1)  = v41;
        *((void *)a1 + 2)  = v42;
        *((void *)a1 + 3)  = v43;
        *((void *)a1 + 4)  = v44;
        *((void *)a1 + 5)  = v45;
        a1[48]  = v46;
        unint64_t v7 = a1;
        uint64_t v8 = a3;
        uint64_t v9 = 13LL;
        goto LABEL_25;
      case 0xEu:
        *(_WORD *)a1  = *(_WORD *)a2;
        *((_WORD *)a1 + 1)  = *((_WORD *)a2 + 1);
        a1[4]  = a2[4];
        uint64_t v48 = *((void *)a2 + 1);
        unint64_t v47 = *((void *)a2 + 2);
        sub_100020AFC(v48, v47);
        *((void *)a1 + 1)  = v48;
        *((void *)a1 + 2)  = v47;
        unint64_t v7 = a1;
        uint64_t v8 = a3;
        uint64_t v9 = 14LL;
        goto LABEL_25;
      case 0x12u:
        int v49 = *(_DWORD *)a2;
        *((_WORD *)a1 + 2)  = *((_WORD *)a2 + 2);
        *(_DWORD *)a1  = v49;
        uint64_t v50 = *((void *)a2 + 1);
        *((void *)a1 + 1)  = v50;
        swift_bridgeObjectRetain(v50);
        unint64_t v7 = a1;
        uint64_t v8 = a3;
        uint64_t v9 = 18LL;
        goto LABEL_25;
      default:
        memcpy(a1, a2, *(void *)(*(void *)(a3 - 8) + 64LL));
        return a1;
    }
  }

  return a1;
}

char *initializeWithTake for AWDLActionFrame.AWDLAttribute(char *a1, char *a2, uint64_t a3)
{
  int EnumCaseMultiPayload = swift_getEnumCaseMultiPayload(a2, a3);
  if (EnumCaseMultiPayload == 6)
  {
    *(_WORD *)a1  = *(_WORD *)a2;
    a1[2]  = a2[2];
    *((_DWORD *)a1 + 1)  = *((_DWORD *)a2 + 1);
    *((_WORD *)a1 + 4)  = *((_WORD *)a2 + 4);
    *(_DWORD *)(a1 + 10)  = *(_DWORD *)(a2 + 10);
    *(_DWORD *)(a1 + 13)  = *(_DWORD *)(a2 + 13);
    *((_WORD *)a1 + 12)  = *((_WORD *)a2 + 12);
    *((_DWORD *)a1 + 5)  = *((_DWORD *)a2 + 5);
    int v14 = *(_DWORD *)(a2 + 26);
    *(_DWORD *)(a1 + 29)  = *(_DWORD *)(a2 + 29);
    *(_DWORD *)(a1 + 26)  = v14;
    *(_OWORD *)(a1 + 40)  = *(_OWORD *)(a2 + 40);
    *((_DWORD *)a1 + 14)  = *((_DWORD *)a2 + 14);
    *(_DWORD *)(a1 + 59)  = *(_DWORD *)(a2 + 59);
    a1[63]  = a2[63];
    *((_DWORD *)a1 + 16)  = *((_DWORD *)a2 + 16);
    a1[68]  = a2[68];
    *((_DWORD *)a1 + 18)  = *((_DWORD *)a2 + 18);
    a1[76]  = a2[76];
    *(_OWORD *)(a1 + 77)  = *(_OWORD *)(a2 + 77);
    *(_WORD *)(a1 + 93)  = *(_WORD *)(a2 + 93);
    unint64_t v15 = (int *)type metadata accessor for AWDLActionFrame.DataPathState(0LL);
    uint64_t v16 = v15[34];
    int v17 = &a1[v16];
    uint64_t v18 = &a2[v16];
    uint64_t v19 = type metadata accessor for DispatchTimeInterval(0LL);
    uint64_t v20 = *(void *)(v19 - 8);
    if ((*(unsigned int (**)(char *, uint64_t, uint64_t))(v20 + 48))(v18, 1LL, v19))
    {
      uint64_t v21 = sub_100002274(&qword_100407450);
      memcpy(v17, v18, *(void *)(*(void *)(v21 - 8) + 64LL));
    }

    else
    {
      (*(void (**)(char *, char *, uint64_t))(v20 + 32))(v17, v18, v19);
      (*(void (**)(char *, void, uint64_t, uint64_t))(v20 + 56))(v17, 0LL, 1LL, v19);
    }

    uint64_t v25 = v15[35];
    int v26 = &a1[v25];
    uint64_t v27 = &a2[v25];
    *(_DWORD *)int v26 = *(_DWORD *)v27;
    v26[4]  = v27[4];
    uint64_t v28 = v15[36];
    int v29 = &a1[v28];
    uint64_t v30 = &a2[v28];
    void v29[4] = v30[4];
    *(_DWORD *)int v29 = *(_DWORD *)v30;
    __int16 v22 = a1;
    uint64_t v23 = a3;
    uint64_t v24 = 6LL;
    goto LABEL_12;
  }

  if (EnumCaseMultiPayload == 1)
  {
    uint64_t v7 = type metadata accessor for AWDLActionFrame.ServiceResponse(0LL);
    if (swift_getEnumCaseMultiPayload(a2, v7) == 2)
    {
      __int128 v8 = *((_OWORD *)a2 + 1);
      *(_OWORD *)a1  = *(_OWORD *)a2;
      *((_OWORD *)a1 + 1)  = v8;
      *((_WORD *)a1 + 16)  = *((_WORD *)a2 + 16);
      uint64_t v9 = (int *)type metadata accessor for DNSRecords.SRV(0LL);
      uint64_t v10 = v9[5];
      uint64_t v11 = &a1[v10];
      uint64_t v12 = &a2[v10];
      uint64_t v13 = type metadata accessor for NWEndpoint.Port(0LL);
      (*(void (**)(char *, char *, uint64_t))(*(void *)(v13 - 8) + 32LL))(v11, v12, v13);
      *(_OWORD *)&a1[v9[6]]  = *(_OWORD *)&a2[v9[6]];
      *(_WORD *)&a1[v9[7]]  = *(_WORD *)&a2[v9[7]];
      *(_WORD *)&a1[v9[8]]  = *(_WORD *)&a2[v9[8]];
      swift_storeEnumTagMultiPayload(a1, v7, 2LL);
    }

    else
    {
      memcpy(a1, a2, *(void *)(*(void *)(v7 - 8) + 64LL));
    }

    __int16 v22 = a1;
    uint64_t v23 = a3;
    uint64_t v24 = 1LL;
LABEL_12:
    swift_storeEnumTagMultiPayload(v22, v23, v24);
    return a1;
  }

  memcpy(a1, a2, *(void *)(*(void *)(a3 - 8) + 64LL));
  return a1;
}

char *assignWithTake for AWDLActionFrame.AWDLAttribute(char *a1, char *a2, uint64_t a3)
{
  if (a1 != a2)
  {
    sub_10005802C((uint64_t)a1, type metadata accessor for AWDLActionFrame.AWDLAttribute);
    int EnumCaseMultiPayload = swift_getEnumCaseMultiPayload(a2, a3);
    if (EnumCaseMultiPayload == 6)
    {
      *(_WORD *)a1  = *(_WORD *)a2;
      a1[2]  = a2[2];
      *((_DWORD *)a1 + 1)  = *((_DWORD *)a2 + 1);
      *((_WORD *)a1 + 4)  = *((_WORD *)a2 + 4);
      *(_DWORD *)(a1 + 10)  = *(_DWORD *)(a2 + 10);
      *(_DWORD *)(a1 + 13)  = *(_DWORD *)(a2 + 13);
      *((_WORD *)a1 + 12)  = *((_WORD *)a2 + 12);
      *((_DWORD *)a1 + 5)  = *((_DWORD *)a2 + 5);
      int v14 = *(_DWORD *)(a2 + 26);
      *(_DWORD *)(a1 + 29)  = *(_DWORD *)(a2 + 29);
      *(_DWORD *)(a1 + 26)  = v14;
      *(_OWORD *)(a1 + 40)  = *(_OWORD *)(a2 + 40);
      *((_DWORD *)a1 + 14)  = *((_DWORD *)a2 + 14);
      *(_DWORD *)(a1 + 59)  = *(_DWORD *)(a2 + 59);
      a1[63]  = a2[63];
      *((_DWORD *)a1 + 16)  = *((_DWORD *)a2 + 16);
      a1[68]  = a2[68];
      *((_DWORD *)a1 + 18)  = *((_DWORD *)a2 + 18);
      a1[76]  = a2[76];
      *(_OWORD *)(a1 + 77)  = *(_OWORD *)(a2 + 77);
      *(_WORD *)(a1 + 93)  = *(_WORD *)(a2 + 93);
      unint64_t v15 = (int *)type metadata accessor for AWDLActionFrame.DataPathState(0LL);
      uint64_t v16 = v15[34];
      int v17 = &a1[v16];
      uint64_t v18 = &a2[v16];
      uint64_t v19 = type metadata accessor for DispatchTimeInterval(0LL);
      uint64_t v20 = *(void *)(v19 - 8);
      if ((*(unsigned int (**)(char *, uint64_t, uint64_t))(v20 + 48))(v18, 1LL, v19))
      {
        uint64_t v21 = sub_100002274(&qword_100407450);
        memcpy(v17, v18, *(void *)(*(void *)(v21 - 8) + 64LL));
      }

      else
      {
        (*(void (**)(char *, char *, uint64_t))(v20 + 32))(v17, v18, v19);
        (*(void (**)(char *, void, uint64_t, uint64_t))(v20 + 56))(v17, 0LL, 1LL, v19);
      }

      uint64_t v25 = v15[35];
      int v26 = &a1[v25];
      uint64_t v27 = &a2[v25];
      *(_DWORD *)int v26 = *(_DWORD *)v27;
      v26[4]  = v27[4];
      uint64_t v28 = v15[36];
      int v29 = &a1[v28];
      uint64_t v30 = &a2[v28];
      void v29[4] = v30[4];
      *(_DWORD *)int v29 = *(_DWORD *)v30;
      __int16 v22 = a1;
      uint64_t v23 = a3;
      uint64_t v24 = 6LL;
      goto LABEL_13;
    }

    if (EnumCaseMultiPayload == 1)
    {
      uint64_t v7 = type metadata accessor for AWDLActionFrame.ServiceResponse(0LL);
      if (swift_getEnumCaseMultiPayload(a2, v7) == 2)
      {
        __int128 v8 = *((_OWORD *)a2 + 1);
        *(_OWORD *)a1  = *(_OWORD *)a2;
        *((_OWORD *)a1 + 1)  = v8;
        *((_WORD *)a1 + 16)  = *((_WORD *)a2 + 16);
        uint64_t v9 = (int *)type metadata accessor for DNSRecords.SRV(0LL);
        uint64_t v10 = v9[5];
        uint64_t v11 = &a1[v10];
        uint64_t v12 = &a2[v10];
        uint64_t v13 = type metadata accessor for NWEndpoint.Port(0LL);
        (*(void (**)(char *, char *, uint64_t))(*(void *)(v13 - 8) + 32LL))(v11, v12, v13);
        *(_OWORD *)&a1[v9[6]]  = *(_OWORD *)&a2[v9[6]];
        *(_WORD *)&a1[v9[7]]  = *(_WORD *)&a2[v9[7]];
        *(_WORD *)&a1[v9[8]]  = *(_WORD *)&a2[v9[8]];
        swift_storeEnumTagMultiPayload(a1, v7, 2LL);
      }

      else
      {
        memcpy(a1, a2, *(void *)(*(void *)(v7 - 8) + 64LL));
      }

      __int16 v22 = a1;
      uint64_t v23 = a3;
      uint64_t v24 = 1LL;
LABEL_13:
      swift_storeEnumTagMultiPayload(v22, v23, v24);
      return a1;
    }

    memcpy(a1, a2, *(void *)(*(void *)(a3 - 8) + 64LL));
  }

  return a1;
}

uint64_t sub_1000E1184(uint64_t a1)
{
  v5[0]  = &unk_100343760;
  uint64_t result = type metadata accessor for AWDLActionFrame.ServiceResponse(319LL);
  if (v3 <= 0x3F)
  {
    v5[1]  = *(void *)(result - 8) + 64LL;
    v5[2]  = &unk_100343778;
    _OWORD v5[3] = &unk_100343790;
    void v5[4] = (char *)&value witness table for Builtin.BridgeObject + 64;
    void v5[5] = &unk_1003437A8;
    uint64_t result = type metadata accessor for AWDLActionFrame.DataPathState(319LL);
    if (v4 <= 0x3F)
    {
      void v5[6] = *(void *)(result - 8) + 64LL;
      v5[7]  = &unk_1003437C0;
      v5[8]  = (char *)&value witness table for Builtin.BridgeObject + 64;
      void v5[9] = &unk_1003437D8;
      v5[10]  = &unk_100343760;
      v5[11]  = &unk_1003437F0;
      v5[12]  = &unk_100343808;
      v5[13]  = &unk_100343820;
      v5[14]  = &unk_100343838;
      v5[15]  = &unk_100343850;
      _BYTE v5[16] = &unk_100343530;
      v5[17]  = &unk_100343868;
      v5[18]  = &unk_100343760;
      v5[19]  = &unk_100343880;
      v5[20]  = &unk_100343898;
      swift_initEnumMetadataMultiPayload(a1, 256LL, 21LL, v5);
      return 0LL;
    }
  }

  return result;
}

uint64_t getEnumTagSinglePayload for AWDLActionFrame.AWDLAttribute.AttributeType( unsigned __int8 *a1, unsigned int a2)
{
  if (!a2) {
    return 0LL;
  }
  if (a2 < 0xEA) {
    goto LABEL_17;
  }
  if (a2 + 22 >= 0xFFFF00) {
    int v2 = 4;
  }
  else {
    int v2 = 2;
  }
  if ((a2 + 22) >> 8 < 0xFF) {
    int v3 = 1;
  }
  else {
    int v3 = v2;
  }
  if (v3 == 4)
  {
    int v4 = *(_DWORD *)(a1 + 1);
    if (v4) {
      return (*a1 | (v4 << 8)) - 22;
    }
  }

  else
  {
    if (v3 == 2)
    {
      int v4 = *(unsigned __int16 *)(a1 + 1);
      if (!*(_WORD *)(a1 + 1)) {
        goto LABEL_17;
      }
      return (*a1 | (v4 << 8)) - 22;
    }

    int v4 = a1[1];
    if (a1[1]) {
      return (*a1 | (v4 << 8)) - 22;
    }
  }

uint64_t storeEnumTagSinglePayload for AWDLActionFrame.AWDLAttribute.AttributeType( _BYTE *a1, unsigned int a2, unsigned int a3)
{
  if (a3 + 22 >= 0xFFFF00) {
    int v3 = 4;
  }
  else {
    int v3 = 2;
  }
  if ((a3 + 22) >> 8 < 0xFF) {
    LODWORD(v4)  = 1;
  }
  else {
    LODWORD(v4)  = v3;
  }
  if (a3 >= 0xEA) {
    uint64_t v4 = v4;
  }
  else {
    uint64_t v4 = 0LL;
  }
  if (a2 <= 0xE9) {
    return ((uint64_t (*)(void))((char *)&loc_1000E1394 + 4 * byte_100340D31[v4]))();
  }
  *a1  = a2 + 22;
  return ((uint64_t (*)(void))((char *)sub_1000E13C8 + 4 * byte_100340D2C[v4]))();
}

uint64_t sub_1000E13C8(uint64_t result)
{
  *(_BYTE *)(result + 1)  = v1;
  return result;
}

uint64_t sub_1000E13D0(uint64_t result, int a2)
{
  *(_WORD *)(result + 1)  = 0;
  if (a2) {
    JUMPOUT(0x1000E13D8LL);
  }
  return result;
}

uint64_t sub_1000E13E4(uint64_t result, int a2)
{
  *(_DWORD *)(result + 1)  = 0;
  if (!a2) {
    JUMPOUT(0x1000E13ECLL);
  }
  *(_BYTE *)uint64_t result = a2 + 22;
  return result;
}

uint64_t sub_1000E13F0(uint64_t result)
{
  *(_DWORD *)(result + 1)  = v1;
  return result;
}

uint64_t sub_1000E13F8(uint64_t result)
{
  *(_WORD *)(result + 1)  = v1;
  return result;
}

ValueMetadata *type metadata accessor for AWDLActionFrame.AWDLAttribute.AttributeType()
{
  return &type metadata for AWDLActionFrame.AWDLAttribute.AttributeType;
}

void *initializeBufferWithCopyOfBuffer for AWDLActionFrame.Header(uint64_t a1, uint64_t *a2, int *a3)
{
  uint64_t v4 = (void *)a1;
  int v5 = *(_DWORD *)(*((void *)a3 - 1) + 80LL);
  if ((v5 & 0x20000) != 0)
  {
    uint64_t v17 = *a2;
    void *v4 = *a2;
    uint64_t v4 = (void *)(v17 + ((v5 + 16LL) & ~(unint64_t)v5));
    swift_retain(v17);
  }

  else
  {
    *(_DWORD *)a1  = *(_DWORD *)a2;
    *(_WORD *)(a1 + 4)  = *((_WORD *)a2 + 2);
    *(_DWORD *)(a1 + 6)  = *(_DWORD *)((char *)a2 + 6);
    *(_WORD *)(a1 + 10)  = *((_WORD *)a2 + 5);
    *(_DWORD *)(a1 + 12)  = *((_DWORD *)a2 + 3);
    *(_WORD *)(a1 + 16)  = *((_WORD *)a2 + 8);
    *(_DWORD *)(a1 + 20)  = *((_DWORD *)a2 + 5);
    uint64_t v7 = a3[8];
    uint64_t v8 = a1 + v7;
    uint64_t v9 = (uint64_t)a2 + v7;
    uint64_t v10 = type metadata accessor for DispatchTimeInterval(0LL);
    uint64_t v11 = *(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v10 - 8) + 16LL);
    v11(v8, v9, v10);
    v11((uint64_t)v4 + a3[9], (uint64_t)a2 + a3[9], v10);
    uint64_t v12 = a3[11];
    *(_DWORD *)((char *)v4 + a3[10])  = *(_DWORD *)((char *)a2 + a3[10]);
    *(_DWORD *)((char *)v4 + v12)  = *(_DWORD *)((char *)a2 + v12);
    uint64_t v13 = a3[13];
    *(void *)((char *)v4 + a3[12])  = *(uint64_t *)((char *)a2 + a3[12]);
    *(_DWORD *)((char *)v4 + v13)  = *(_DWORD *)((char *)a2 + v13);
    uint64_t v14 = a3[15];
    *(void *)((char *)v4 + a3[14])  = *(uint64_t *)((char *)a2 + a3[14]);
    *(_DWORD *)((char *)v4 + v14)  = *(_DWORD *)((char *)a2 + v14);
    uint64_t v15 = a3[16];
    uint64_t v16 = *(uint64_t *)((char *)a2 + v15);
    *(void *)((char *)v4 + v15)  = v16;
    swift_bridgeObjectRetain(v16);
  }

  return v4;
}

uint64_t destroy for AWDLActionFrame.Header(uint64_t a1, int *a2)
{
  uint64_t v4 = a1 + a2[8];
  uint64_t v5 = type metadata accessor for DispatchTimeInterval(0LL);
  unsigned int v6 = *(void (**)(uint64_t, uint64_t))(*(void *)(v5 - 8) + 8LL);
  v6(v4, v5);
  v6(a1 + a2[9], v5);
  return swift_bridgeObjectRelease(*(void *)(a1 + a2[16]));
}

uint64_t initializeWithCopy for AWDLActionFrame.Header(uint64_t a1, uint64_t a2, int *a3)
{
  *(_DWORD *)a1  = *(_DWORD *)a2;
  *(_WORD *)(a1 + 4)  = *(_WORD *)(a2 + 4);
  *(_DWORD *)(a1 + 6)  = *(_DWORD *)(a2 + 6);
  *(_WORD *)(a1 + 10)  = *(_WORD *)(a2 + 10);
  *(_DWORD *)(a1 + 12)  = *(_DWORD *)(a2 + 12);
  *(_WORD *)(a1 + 16)  = *(_WORD *)(a2 + 16);
  *(_DWORD *)(a1 + 20)  = *(_DWORD *)(a2 + 20);
  uint64_t v6 = a3[8];
  uint64_t v7 = a1 + v6;
  uint64_t v8 = a2 + v6;
  uint64_t v9 = type metadata accessor for DispatchTimeInterval(0LL);
  uint64_t v10 = *(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v9 - 8) + 16LL);
  v10(v7, v8, v9);
  v10(a1 + a3[9], a2 + a3[9], v9);
  uint64_t v11 = a3[11];
  *(_DWORD *)(a1 + a3[10])  = *(_DWORD *)(a2 + a3[10]);
  *(_DWORD *)(a1 + v11)  = *(_DWORD *)(a2 + v11);
  uint64_t v12 = a3[13];
  *(void *)(a1 + a3[12])  = *(void *)(a2 + a3[12]);
  *(_DWORD *)(a1 + v12)  = *(_DWORD *)(a2 + v12);
  uint64_t v13 = a3[15];
  *(void *)(a1 + a3[14])  = *(void *)(a2 + a3[14]);
  *(_DWORD *)(a1 + v13)  = *(_DWORD *)(a2 + v13);
  uint64_t v14 = a3[16];
  uint64_t v15 = *(void *)(a2 + v14);
  *(void *)(a1 + v14)  = v15;
  swift_bridgeObjectRetain(v15);
  return a1;
}

uint64_t assignWithCopy for AWDLActionFrame.Header(uint64_t a1, uint64_t a2, int *a3)
{
  *(_BYTE *)a1  = *(_BYTE *)a2;
  *(_BYTE *)(a1 + 1)  = *(_BYTE *)(a2 + 1);
  *(_BYTE *)(a1 + 2)  = *(_BYTE *)(a2 + 2);
  *(_BYTE *)(a1 + 3)  = *(_BYTE *)(a2 + 3);
  *(_BYTE *)(a1 + 4)  = *(_BYTE *)(a2 + 4);
  *(_BYTE *)(a1 + 5)  = *(_BYTE *)(a2 + 5);
  *(_BYTE *)(a1 + 6)  = *(_BYTE *)(a2 + 6);
  *(_BYTE *)(a1 + 7)  = *(_BYTE *)(a2 + 7);
  *(_BYTE *)(a1 + 8)  = *(_BYTE *)(a2 + 8);
  *(_BYTE *)(a1 + 9)  = *(_BYTE *)(a2 + 9);
  *(_BYTE *)(a1 + 10)  = *(_BYTE *)(a2 + 10);
  *(_BYTE *)(a1 + 11)  = *(_BYTE *)(a2 + 11);
  *(_DWORD *)(a1 + 12)  = *(_DWORD *)(a2 + 12);
  *(_BYTE *)(a1 + 16)  = *(_BYTE *)(a2 + 16);
  *(_BYTE *)(a1 + 17)  = *(_BYTE *)(a2 + 17);
  *(_DWORD *)(a1 + 20)  = *(_DWORD *)(a2 + 20);
  uint64_t v6 = a3[8];
  uint64_t v7 = a1 + v6;
  uint64_t v8 = a2 + v6;
  uint64_t v9 = type metadata accessor for DispatchTimeInterval(0LL);
  uint64_t v10 = *(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v9 - 8) + 24LL);
  v10(v7, v8, v9);
  v10(a1 + a3[9], a2 + a3[9], v9);
  *(_DWORD *)(a1 + a3[10])  = *(_DWORD *)(a2 + a3[10]);
  *(_DWORD *)(a1 + a3[11])  = *(_DWORD *)(a2 + a3[11]);
  *(void *)(a1 + a3[12])  = *(void *)(a2 + a3[12]);
  *(_DWORD *)(a1 + a3[13])  = *(_DWORD *)(a2 + a3[13]);
  *(void *)(a1 + a3[14])  = *(void *)(a2 + a3[14]);
  *(_DWORD *)(a1 + a3[15])  = *(_DWORD *)(a2 + a3[15]);
  uint64_t v11 = a3[16];
  uint64_t v12 = *(void *)(a2 + v11);
  uint64_t v13 = *(void *)(a1 + v11);
  *(void *)(a1 + v11)  = v12;
  swift_bridgeObjectRetain(v12);
  swift_bridgeObjectRelease(v13);
  return a1;
}

uint64_t initializeWithTake for AWDLActionFrame.Header(uint64_t a1, uint64_t a2, int *a3)
{
  *(_DWORD *)a1  = *(_DWORD *)a2;
  *(_WORD *)(a1 + 4)  = *(_WORD *)(a2 + 4);
  *(_DWORD *)(a1 + 6)  = *(_DWORD *)(a2 + 6);
  *(_WORD *)(a1 + 10)  = *(_WORD *)(a2 + 10);
  *(_DWORD *)(a1 + 12)  = *(_DWORD *)(a2 + 12);
  *(_WORD *)(a1 + 16)  = *(_WORD *)(a2 + 16);
  *(_DWORD *)(a1 + 20)  = *(_DWORD *)(a2 + 20);
  uint64_t v6 = a3[8];
  uint64_t v7 = a1 + v6;
  uint64_t v8 = a2 + v6;
  uint64_t v9 = type metadata accessor for DispatchTimeInterval(0LL);
  uint64_t v10 = *(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v9 - 8) + 32LL);
  v10(v7, v8, v9);
  v10(a1 + a3[9], a2 + a3[9], v9);
  uint64_t v11 = a3[11];
  *(_DWORD *)(a1 + a3[10])  = *(_DWORD *)(a2 + a3[10]);
  *(_DWORD *)(a1 + v11)  = *(_DWORD *)(a2 + v11);
  uint64_t v12 = a3[13];
  *(void *)(a1 + a3[12])  = *(void *)(a2 + a3[12]);
  *(_DWORD *)(a1 + v12)  = *(_DWORD *)(a2 + v12);
  uint64_t v13 = a3[15];
  *(void *)(a1 + a3[14])  = *(void *)(a2 + a3[14]);
  *(_DWORD *)(a1 + v13)  = *(_DWORD *)(a2 + v13);
  *(void *)(a1 + a3[16])  = *(void *)(a2 + a3[16]);
  return a1;
}

uint64_t assignWithTake for AWDLActionFrame.Header(uint64_t a1, uint64_t a2, int *a3)
{
  *(void *)a1  = *(void *)a2;
  int v6 = *(_DWORD *)(a2 + 12);
  *(_DWORD *)(a1 + 8)  = *(_DWORD *)(a2 + 8);
  *(_DWORD *)(a1 + 12)  = v6;
  *(_WORD *)(a1 + 16)  = *(_WORD *)(a2 + 16);
  *(_DWORD *)(a1 + 20)  = *(_DWORD *)(a2 + 20);
  uint64_t v7 = a3[8];
  uint64_t v8 = a1 + v7;
  uint64_t v9 = a2 + v7;
  uint64_t v10 = type metadata accessor for DispatchTimeInterval(0LL);
  uint64_t v11 = *(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v10 - 8) + 40LL);
  v11(v8, v9, v10);
  v11(a1 + a3[9], a2 + a3[9], v10);
  uint64_t v12 = a3[11];
  *(_DWORD *)(a1 + a3[10])  = *(_DWORD *)(a2 + a3[10]);
  *(_DWORD *)(a1 + v12)  = *(_DWORD *)(a2 + v12);
  uint64_t v13 = a3[13];
  *(void *)(a1 + a3[12])  = *(void *)(a2 + a3[12]);
  *(_DWORD *)(a1 + v13)  = *(_DWORD *)(a2 + v13);
  uint64_t v14 = a3[15];
  *(void *)(a1 + a3[14])  = *(void *)(a2 + a3[14]);
  *(_DWORD *)(a1 + v14)  = *(_DWORD *)(a2 + v14);
  uint64_t v15 = a3[16];
  uint64_t v16 = *(void *)(a1 + v15);
  *(void *)(a1 + v15)  = *(void *)(a2 + v15);
  swift_bridgeObjectRelease(v16);
  return a1;
}

uint64_t getEnumTagSinglePayload for AWDLActionFrame.Header(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return swift_getEnumTagSinglePayloadGeneric(a1, a2, a3, sub_1000E1A2C);
}

uint64_t sub_1000E1A2C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = type metadata accessor for DispatchTimeInterval(0LL);
  uint64_t v7 = *(void *)(v6 - 8);
  if (*(_DWORD *)(v7 + 84) == (_DWORD)a2) {
    return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v7 + 48))(a1 + *(int *)(a3 + 32), a2, v6);
  }
  unint64_t v9 = *(void *)(a1 + *(int *)(a3 + 64));
  if (v9 >= 0xFFFFFFFF) {
    LODWORD(v9)  = -1;
  }
  return (v9 + 1);
}

uint64_t storeEnumTagSinglePayload for AWDLActionFrame.Header(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return swift_storeEnumTagSinglePayloadGeneric(a1, a2, a3, a4, sub_1000E1AB8);
}

uint64_t sub_1000E1AB8(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  uint64_t result = type metadata accessor for DispatchTimeInterval(0LL);
  uint64_t v9 = *(void *)(result - 8);
  if (*(_DWORD *)(v9 + 84) == a3) {
    return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v9 + 56))( a1 + *(int *)(a4 + 32),  a2,  a2,  result);
  }
  *(void *)(a1 + *(int *)(a4 + 64))  = (a2 - 1);
  return result;
}

uint64_t sub_1000E1B34(uint64_t a1)
{
  v4[0]  = &unk_1003438C8;
  v4[1]  = &unk_1003438C8;
  void v4[2] = &unk_1003438E0;
  v4[3]  = (char *)&value witness table for Builtin.Int32 + 64;
  uint64_t result = type metadata accessor for DispatchTimeInterval(319LL);
  if (v3 <= 0x3F)
  {
    uint64_t v5 = *(void *)(result - 8) + 64LL;
    uint64_t v6 = v5;
    uint64_t v7 = (char *)&value witness table for Builtin.Int32 + 64;
    uint64_t v8 = (char *)&value witness table for Builtin.Int32 + 64;
    uint64_t v9 = (char *)&value witness table for Builtin.Int64 + 64;
    uint64_t v10 = (char *)&value witness table for Builtin.Int32 + 64;
    uint64_t v11 = (char *)&value witness table for Builtin.Int64 + 64;
    uint64_t v12 = (char *)&value witness table for Builtin.Int32 + 64;
    uint64_t v13 = (char *)&value witness table for Builtin.BridgeObject + 64;
    swift_initStructMetadata(a1, 256LL, 13LL, v4, a1 + 16);
    return 0LL;
  }

  return result;
}

ValueMetadata *type metadata accessor for AWDLActionFrame.Header.Flags()
{
  return &type metadata for AWDLActionFrame.Header.Flags;
}

ValueMetadata *type metadata accessor for AWDLActionFrame.AirDrop.CodingKeys()
{
  return &type metadata for AWDLActionFrame.AirDrop.CodingKeys;
}

ValueMetadata *type metadata accessor for AWDLActionFrame.ProMode.CodingKeys()
{
  return &type metadata for AWDLActionFrame.ProMode.CodingKeys;
}

ValueMetadata *type metadata accessor for AWDLActionFrame.ExtendedChannelSequence.CodingKeys()
{
  return &type metadata for AWDLActionFrame.ExtendedChannelSequence.CodingKeys;
}

ValueMetadata *type metadata accessor for AWDLActionFrame.Ranging.CodingKeys()
{
  return &type metadata for AWDLActionFrame.Ranging.CodingKeys;
}

ValueMetadata *type metadata accessor for AWDLActionFrame.MultiPeerBSSSteering.CodingKeys()
{
  return &type metadata for AWDLActionFrame.MultiPeerBSSSteering.CodingKeys;
}

uint64_t getEnumTagSinglePayload for AWDLActionFrame.ElectionParameter.CodingKeys( unsigned __int8 *a1, unsigned int a2)
{
  if (!a2) {
    return 0LL;
  }
  if (a2 < 0xF8) {
    goto LABEL_17;
  }
  if (a2 + 8 >= 0xFFFF00) {
    int v2 = 4;
  }
  else {
    int v2 = 2;
  }
  if ((a2 + 8) >> 8 < 0xFF) {
    int v3 = 1;
  }
  else {
    int v3 = v2;
  }
  if (v3 == 4)
  {
    int v4 = *(_DWORD *)(a1 + 1);
    if (v4) {
      return (*a1 | (v4 << 8)) - 8;
    }
  }

  else
  {
    if (v3 == 2)
    {
      int v4 = *(unsigned __int16 *)(a1 + 1);
      if (!*(_WORD *)(a1 + 1)) {
        goto LABEL_17;
      }
      return (*a1 | (v4 << 8)) - 8;
    }

    int v4 = a1[1];
    if (a1[1]) {
      return (*a1 | (v4 << 8)) - 8;
    }
  }

uint64_t storeEnumTagSinglePayload for AWDLActionFrame.ElectionParameter.CodingKeys( _BYTE *a1, unsigned int a2, unsigned int a3)
{
  if (a3 + 8 >= 0xFFFF00) {
    int v3 = 4;
  }
  else {
    int v3 = 2;
  }
  if ((a3 + 8) >> 8 < 0xFF) {
    LODWORD(v4)  = 1;
  }
  else {
    LODWORD(v4)  = v3;
  }
  if (a3 >= 0xF8) {
    uint64_t v4 = v4;
  }
  else {
    uint64_t v4 = 0LL;
  }
  if (a2 <= 0xF7) {
    return ((uint64_t (*)(void))((char *)&loc_1000E1D28 + 4 * byte_100340D3B[v4]))();
  }
  *a1  = a2 + 8;
  return ((uint64_t (*)(void))((char *)sub_1000E1D5C + 4 * byte_100340D36[v4]))();
}

uint64_t sub_1000E1D5C(uint64_t result)
{
  *(_BYTE *)(result + 1)  = v1;
  return result;
}

uint64_t sub_1000E1D64(uint64_t result, int a2)
{
  *(_WORD *)(result + 1)  = 0;
  if (a2) {
    JUMPOUT(0x1000E1D6CLL);
  }
  return result;
}

uint64_t sub_1000E1D78(uint64_t result, int a2)
{
  *(_DWORD *)(result + 1)  = 0;
  if (!a2) {
    JUMPOUT(0x1000E1D80LL);
  }
  *(_BYTE *)uint64_t result = a2 + 8;
  return result;
}

uint64_t sub_1000E1D84(uint64_t result)
{
  *(_DWORD *)(result + 1)  = v1;
  return result;
}

uint64_t sub_1000E1D8C(uint64_t result)
{
  *(_WORD *)(result + 1)  = v1;
  return result;
}

ValueMetadata *type metadata accessor for AWDLActionFrame.ElectionParameter.CodingKeys()
{
  return &type metadata for AWDLActionFrame.ElectionParameter.CodingKeys;
}

uint64_t getEnumTagSinglePayload for NANDataHostAssistRequest.Reason(unsigned __int8 *a1, unsigned int a2)
{
  if (!a2) {
    return 0LL;
  }
  if (a2 < 0xF7) {
    goto LABEL_17;
  }
  if (a2 + 9 >= 0xFFFF00) {
    int v2 = 4;
  }
  else {
    int v2 = 2;
  }
  if ((a2 + 9) >> 8 < 0xFF) {
    int v3 = 1;
  }
  else {
    int v3 = v2;
  }
  if (v3 == 4)
  {
    int v4 = *(_DWORD *)(a1 + 1);
    if (v4) {
      return (*a1 | (v4 << 8)) - 9;
    }
  }

  else
  {
    if (v3 == 2)
    {
      int v4 = *(unsigned __int16 *)(a1 + 1);
      if (!*(_WORD *)(a1 + 1)) {
        goto LABEL_17;
      }
      return (*a1 | (v4 << 8)) - 9;
    }

    int v4 = a1[1];
    if (a1[1]) {
      return (*a1 | (v4 << 8)) - 9;
    }
  }

uint64_t storeEnumTagSinglePayload for AWDLActionFrame.NANSynchronization.CodingKeys( _BYTE *a1, unsigned int a2, unsigned int a3)
{
  if (a3 + 9 >= 0xFFFF00) {
    int v3 = 4;
  }
  else {
    int v3 = 2;
  }
  if ((a3 + 9) >> 8 < 0xFF) {
    LODWORD(v4)  = 1;
  }
  else {
    LODWORD(v4)  = v3;
  }
  if (a3 >= 0xF7) {
    uint64_t v4 = v4;
  }
  else {
    uint64_t v4 = 0LL;
  }
  if (a2 <= 0xF6) {
    return ((uint64_t (*)(void))((char *)&loc_1000E1E84 + 4 * byte_100340D45[v4]))();
  }
  *a1  = a2 + 9;
  return ((uint64_t (*)(void))((char *)sub_1000E1EB8 + 4 * byte_100340D40[v4]))();
}

uint64_t sub_1000E1EB8(uint64_t result)
{
  *(_BYTE *)(result + 1)  = v1;
  return result;
}

uint64_t sub_1000E1EC0(uint64_t result, int a2)
{
  *(_WORD *)(result + 1)  = 0;
  if (a2) {
    JUMPOUT(0x1000E1EC8LL);
  }
  return result;
}

uint64_t sub_1000E1ED4(uint64_t result, int a2)
{
  *(_DWORD *)(result + 1)  = 0;
  if (!a2) {
    JUMPOUT(0x1000E1EDCLL);
  }
  *(_BYTE *)uint64_t result = a2 + 9;
  return result;
}

uint64_t sub_1000E1EE0(uint64_t result)
{
  *(_DWORD *)(result + 1)  = v1;
  return result;
}

uint64_t sub_1000E1EE8(uint64_t result)
{
  *(_WORD *)(result + 1)  = v1;
  return result;
}

ValueMetadata *type metadata accessor for AWDLActionFrame.NANSynchronization.CodingKeys()
{
  return &type metadata for AWDLActionFrame.NANSynchronization.CodingKeys;
}

ValueMetadata *type metadata accessor for AWDLActionFrame.PeerMACAddressListBloomFilter.CodingKeys()
{
  return &type metadata for AWDLActionFrame.PeerMACAddressListBloomFilter.CodingKeys;
}

ValueMetadata *type metadata accessor for AWDLActionFrame.Version.CodingKeys()
{
  return &type metadata for AWDLActionFrame.Version.CodingKeys;
}

ValueMetadata *type metadata accessor for AWDLActionFrame.AWDLVersion.CodingKeys()
{
  return &type metadata for AWDLActionFrame.AWDLVersion.CodingKeys;
}

uint64_t _s7CoreP2P15AWDLActionFrameV7OUITypeOwst_0(uint64_t a1, int a2, int a3)
{
  else {
    int v3 = 2;
  }
  else {
    LODWORD(v4)  = v3;
  }
  if (a3) {
    uint64_t v4 = v4;
  }
  else {
    uint64_t v4 = 0LL;
  }
  if (a2) {
    return ((uint64_t (*)(void))((char *)sub_1000E1F74 + 4 * byte_100340D4A[v4]))();
  }
  else {
    return ((uint64_t (*)(void))((char *)sub_1000E1F94 + 4 * byte_100340D4F[v4]))();
  }
}

_BYTE *sub_1000E1F74(_BYTE *result, char a2)
{
  *uint64_t result = a2;
  return result;
}

_BYTE *sub_1000E1F94(_BYTE *result)
{
  *uint64_t result = 0;
  return result;
}

_DWORD *sub_1000E1F9C(_DWORD *result, int a2)
{
  *uint64_t result = a2;
  return result;
}

_WORD *sub_1000E1FA4(_WORD *result, __int16 a2)
{
  *uint64_t result = a2;
  return result;
}

_WORD *sub_1000E1FAC(_WORD *result)
{
  *uint64_t result = 0;
  return result;
}

_DWORD *sub_1000E1FB4(_DWORD *result)
{
  *uint64_t result = 0;
  return result;
}

ValueMetadata *type metadata accessor for AWDLActionFrame.SyncTreePath.CodingKeys()
{
  return &type metadata for AWDLActionFrame.SyncTreePath.CodingKeys;
}

ValueMetadata *type metadata accessor for AWDLActionFrame.DataPathState.ExtensionFlags()
{
  return &type metadata for AWDLActionFrame.DataPathState.ExtensionFlags;
}

ValueMetadata *type metadata accessor for AWDLActionFrame.DataPathState.Flags()
{
  return &type metadata for AWDLActionFrame.DataPathState.Flags;
}

ValueMetadata *type metadata accessor for AWDLActionFrame.ServiceParameter.CodingKeys()
{
  return &type metadata for AWDLActionFrame.ServiceParameter.CodingKeys;
}

uint64_t _s7CoreP2P15AWDLActionFrameV10OUISubtypeOwst_0(_BYTE *a1, unsigned int a2, unsigned int a3)
{
  if (a3 + 1 >= 0xFFFF00) {
    int v3 = 4;
  }
  else {
    int v3 = 2;
  }
  if ((a3 + 1) >> 8 < 0xFF) {
    LODWORD(v4)  = 1;
  }
  else {
    LODWORD(v4)  = v3;
  }
  if (a3 >= 0xFF) {
    uint64_t v4 = v4;
  }
  else {
    uint64_t v4 = 0LL;
  }
  if (a2 <= 0xFE) {
    return ((uint64_t (*)(void))((char *)&loc_1000E204C + 4 * byte_100340D59[v4]))();
  }
  *a1  = a2 + 1;
  return ((uint64_t (*)(void))((char *)sub_1000E2080 + 4 * byte_100340D54[v4]))();
}

uint64_t sub_1000E2080(uint64_t result)
{
  *(_BYTE *)(result + 1)  = v1;
  return result;
}

uint64_t sub_1000E2088(uint64_t result, int a2)
{
  *(_WORD *)(result + 1)  = 0;
  if (a2) {
    JUMPOUT(0x1000E2090LL);
  }
  return result;
}

uint64_t sub_1000E209C(uint64_t result, int a2)
{
  *(_DWORD *)(result + 1)  = 0;
  if (!a2) {
    JUMPOUT(0x1000E20A4LL);
  }
  *(_BYTE *)uint64_t result = a2 + 1;
  return result;
}

uint64_t sub_1000E20A8(uint64_t result)
{
  *(_DWORD *)(result + 1)  = v1;
  return result;
}

uint64_t sub_1000E20B0(uint64_t result)
{
  *(_WORD *)(result + 1)  = v1;
  return result;
}

ValueMetadata *type metadata accessor for AWDLActionFrame.ServiceParameter.SSTH.CodingKeys()
{
  return &type metadata for AWDLActionFrame.ServiceParameter.SSTH.CodingKeys;
}

uint64_t _s7CoreP2P15AWDLActionFrameV7ProModeV7CommandOwst_0(_BYTE *a1, unsigned int a2, unsigned int a3)
{
  if (a3 + 2 >= 0xFFFF00) {
    int v3 = 4;
  }
  else {
    int v3 = 2;
  }
  if ((a3 + 2) >> 8 < 0xFF) {
    LODWORD(v4)  = 1;
  }
  else {
    LODWORD(v4)  = v3;
  }
  if (a3 >= 0xFE) {
    uint64_t v4 = v4;
  }
  else {
    uint64_t v4 = 0LL;
  }
  if (a2 <= 0xFD) {
    return ((uint64_t (*)(void))((char *)&loc_1000E2118 + 4 * byte_100340D63[v4]))();
  }
  *a1  = a2 + 2;
  return ((uint64_t (*)(void))((char *)sub_1000E214C + 4 * byte_100340D5E[v4]))();
}

uint64_t sub_1000E214C(uint64_t result)
{
  *(_BYTE *)(result + 1)  = v1;
  return result;
}

uint64_t sub_1000E2154(uint64_t result, int a2)
{
  *(_WORD *)(result + 1)  = 0;
  if (a2) {
    JUMPOUT(0x1000E215CLL);
  }
  return result;
}

uint64_t sub_1000E2168(uint64_t result, int a2)
{
  *(_DWORD *)(result + 1)  = 0;
  if (!a2) {
    JUMPOUT(0x1000E2170LL);
  }
  *(_BYTE *)uint64_t result = a2 + 2;
  return result;
}

uint64_t sub_1000E2174(uint64_t result)
{
  *(_DWORD *)(result + 1)  = v1;
  return result;
}

uint64_t sub_1000E217C(uint64_t result)
{
  *(_WORD *)(result + 1)  = v1;
  return result;
}

ValueMetadata *type metadata accessor for AWDLActionFrame.ServiceRequest.CodingKeys()
{
  return &type metadata for AWDLActionFrame.ServiceRequest.CodingKeys;
}

unint64_t sub_1000E219C()
{
  unint64_t result = qword_100407AE8;
  if (!qword_100407AE8)
  {
    unint64_t result = swift_getWitnessTable(&unk_1003439A4, &type metadata for AWDLActionFrame.ServiceRequest.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_100407AE8);
  }

  return result;
}

unint64_t sub_1000E21E4()
{
  unint64_t result = qword_100407AF0;
  if (!qword_100407AF0)
  {
    unint64_t result = swift_getWitnessTable(&unk_100343A5C, &type metadata for AWDLActionFrame.ServiceParameter.SSTH.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_100407AF0);
  }

  return result;
}

unint64_t sub_1000E222C()
{
  unint64_t result = qword_100407AF8;
  if (!qword_100407AF8)
  {
    unint64_t result = swift_getWitnessTable(&unk_100343B14, &type metadata for AWDLActionFrame.ServiceParameter.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_100407AF8);
  }

  return result;
}

unint64_t sub_1000E2274()
{
  unint64_t result = qword_100407B00;
  if (!qword_100407B00)
  {
    unint64_t result = swift_getWitnessTable(&unk_100343B6C, &type metadata for AWDLActionFrame.DataPathState.Flags);
    atomic_store(result, (unint64_t *)&qword_100407B00);
  }

  return result;
}

unint64_t sub_1000E22BC()
{
  unint64_t result = qword_100407B08;
  if (!qword_100407B08)
  {
    unint64_t result = swift_getWitnessTable(&unk_100343B3C, &type metadata for AWDLActionFrame.DataPathState.Flags);
    atomic_store(result, (unint64_t *)&qword_100407B08);
  }

  return result;
}

unint64_t sub_1000E2304()
{
  unint64_t result = qword_100407B10;
  if (!qword_100407B10)
  {
    unint64_t result = swift_getWitnessTable(&unk_100343B94, &type metadata for AWDLActionFrame.DataPathState.Flags);
    atomic_store(result, (unint64_t *)&qword_100407B10);
  }

  return result;
}

unint64_t sub_1000E234C()
{
  unint64_t result = qword_100407B18;
  if (!qword_100407B18)
  {
    unint64_t result = swift_getWitnessTable(&unk_100343BCC, &type metadata for AWDLActionFrame.DataPathState.Flags);
    atomic_store(result, (unint64_t *)&qword_100407B18);
  }

  return result;
}

unint64_t sub_1000E2394()
{
  unint64_t result = qword_100407B20;
  if (!qword_100407B20)
  {
    unint64_t result = swift_getWitnessTable(&unk_100343D3C, &type metadata for AWDLActionFrame.DataPathState.ExtensionFlags);
    atomic_store(result, (unint64_t *)&qword_100407B20);
  }

  return result;
}

unint64_t sub_1000E23DC()
{
  unint64_t result = qword_100407B28;
  if (!qword_100407B28)
  {
    unint64_t result = swift_getWitnessTable(&unk_100343D0C, &type metadata for AWDLActionFrame.DataPathState.ExtensionFlags);
    atomic_store(result, (unint64_t *)&qword_100407B28);
  }

  return result;
}

unint64_t sub_1000E2424()
{
  unint64_t result = qword_100407B30;
  if (!qword_100407B30)
  {
    unint64_t result = swift_getWitnessTable(&unk_100343D64, &type metadata for AWDLActionFrame.DataPathState.ExtensionFlags);
    atomic_store(result, (unint64_t *)&qword_100407B30);
  }

  return result;
}

unint64_t sub_1000E246C()
{
  unint64_t result = qword_100407B38;
  if (!qword_100407B38)
  {
    unint64_t result = swift_getWitnessTable(&unk_100343D9C, &type metadata for AWDLActionFrame.DataPathState.ExtensionFlags);
    atomic_store(result, (unint64_t *)&qword_100407B38);
  }

  return result;
}

unint64_t sub_1000E24B4()
{
  unint64_t result = qword_100407B40;
  if (!qword_100407B40)
  {
    unint64_t result = swift_getWitnessTable(&unk_100343F6C, &type metadata for AWDLActionFrame.SyncTreePath.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_100407B40);
  }

  return result;
}

unint64_t sub_1000E24FC()
{
  unint64_t result = qword_100407B48;
  if (!qword_100407B48)
  {
    unint64_t result = swift_getWitnessTable(&unk_100344024, &type metadata for AWDLActionFrame.AWDLVersion.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_100407B48);
  }

  return result;
}

unint64_t sub_1000E2544()
{
  unint64_t result = qword_100407B50;
  if (!qword_100407B50)
  {
    unint64_t result = swift_getWitnessTable(&unk_1003440DC, &type metadata for AWDLActionFrame.Version.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_100407B50);
  }

  return result;
}

unint64_t sub_1000E258C()
{
  unint64_t result = qword_100407B58;
  if (!qword_100407B58)
  {
    unint64_t result = swift_getWitnessTable( &unk_100344194,  &type metadata for AWDLActionFrame.PeerMACAddressListBloomFilter.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_100407B58);
  }

  return result;
}

unint64_t sub_1000E25D4()
{
  unint64_t result = qword_100407B60;
  if (!qword_100407B60)
  {
    unint64_t result = swift_getWitnessTable(&unk_10034424C, &type metadata for AWDLActionFrame.NANSynchronization.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_100407B60);
  }

  return result;
}

unint64_t sub_1000E261C()
{
  unint64_t result = qword_100407B68;
  if (!qword_100407B68)
  {
    unint64_t result = swift_getWitnessTable(&unk_100344304, &type metadata for AWDLActionFrame.ElectionParameter.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_100407B68);
  }

  return result;
}

unint64_t sub_1000E2664()
{
  unint64_t result = qword_100407B70;
  if (!qword_100407B70)
  {
    unint64_t result = swift_getWitnessTable(&unk_1003443BC, &type metadata for AWDLActionFrame.MultiPeerBSSSteering.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_100407B70);
  }

  return result;
}

unint64_t sub_1000E26AC()
{
  unint64_t result = qword_100407B78;
  if (!qword_100407B78)
  {
    unint64_t result = swift_getWitnessTable(&unk_100344474, &type metadata for AWDLActionFrame.Ranging.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_100407B78);
  }

  return result;
}

unint64_t sub_1000E26F4()
{
  unint64_t result = qword_100407B80;
  if (!qword_100407B80)
  {
    unint64_t result = swift_getWitnessTable(&unk_10034457C, &type metadata for AWDLActionFrame.ProMode.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_100407B80);
  }

  return result;
}

unint64_t sub_1000E273C()
{
  unint64_t result = qword_100407B88;
  if (!qword_100407B88)
  {
    unint64_t result = swift_getWitnessTable(&unk_100344634, &type metadata for AWDLActionFrame.AirDrop.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_100407B88);
  }

  return result;
}

unint64_t sub_1000E2784()
{
  unint64_t result = qword_100407B90;
  if (!qword_100407B90)
  {
    unint64_t result = swift_getWitnessTable(&unk_1003445A4, &type metadata for AWDLActionFrame.AirDrop.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_100407B90);
  }

  return result;
}

unint64_t sub_1000E27CC()
{
  unint64_t result = qword_100407B98;
  if (!qword_100407B98)
  {
    unint64_t result = swift_getWitnessTable(&unk_1003445CC, &type metadata for AWDLActionFrame.AirDrop.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_100407B98);
  }

  return result;
}

unint64_t sub_1000E2814()
{
  unint64_t result = qword_100407BA0;
  if (!qword_100407BA0)
  {
    unint64_t result = swift_getWitnessTable(&unk_1003444EC, &type metadata for AWDLActionFrame.ProMode.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_100407BA0);
  }

  return result;
}

unint64_t sub_1000E285C()
{
  unint64_t result = qword_100407BA8;
  if (!qword_100407BA8)
  {
    unint64_t result = swift_getWitnessTable(&unk_100344514, &type metadata for AWDLActionFrame.ProMode.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_100407BA8);
  }

  return result;
}

unint64_t sub_1000E28A4()
{
  unint64_t result = qword_100407BB0;
  if (!qword_100407BB0)
  {
    unint64_t result = swift_getWitnessTable( &unk_10034449C,  &type metadata for AWDLActionFrame.ExtendedChannelSequence.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_100407BB0);
  }

  return result;
}

unint64_t sub_1000E28EC()
{
  unint64_t result = qword_100407BB8;
  if (!qword_100407BB8)
  {
    unint64_t result = swift_getWitnessTable( &unk_1003444C4,  &type metadata for AWDLActionFrame.ExtendedChannelSequence.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_100407BB8);
  }

  return result;
}

unint64_t sub_1000E2934()
{
  unint64_t result = qword_100407BC0;
  if (!qword_100407BC0)
  {
    unint64_t result = swift_getWitnessTable(&unk_1003443E4, &type metadata for AWDLActionFrame.Ranging.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_100407BC0);
  }

  return result;
}

unint64_t sub_1000E297C()
{
  unint64_t result = qword_100407BC8;
  if (!qword_100407BC8)
  {
    unint64_t result = swift_getWitnessTable(&unk_10034440C, &type metadata for AWDLActionFrame.Ranging.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_100407BC8);
  }

  return result;
}

unint64_t sub_1000E29C4()
{
  unint64_t result = qword_100407BD0;
  if (!qword_100407BD0)
  {
    unint64_t result = swift_getWitnessTable(&unk_10034432C, &type metadata for AWDLActionFrame.MultiPeerBSSSteering.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_100407BD0);
  }

  return result;
}

unint64_t sub_1000E2A0C()
{
  unint64_t result = qword_100407BD8;
  if (!qword_100407BD8)
  {
    unint64_t result = swift_getWitnessTable(&unk_100344354, &type metadata for AWDLActionFrame.MultiPeerBSSSteering.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_100407BD8);
  }

  return result;
}

unint64_t sub_1000E2A54()
{
  unint64_t result = qword_100407BE0;
  if (!qword_100407BE0)
  {
    unint64_t result = swift_getWitnessTable(&unk_100344274, &type metadata for AWDLActionFrame.ElectionParameter.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_100407BE0);
  }

  return result;
}

unint64_t sub_1000E2A9C()
{
  unint64_t result = qword_100407BE8;
  if (!qword_100407BE8)
  {
    unint64_t result = swift_getWitnessTable(&unk_10034429C, &type metadata for AWDLActionFrame.ElectionParameter.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_100407BE8);
  }

  return result;
}

unint64_t sub_1000E2AE4()
{
  unint64_t result = qword_100407BF0;
  if (!qword_100407BF0)
  {
    unint64_t result = swift_getWitnessTable(&unk_1003441BC, &type metadata for AWDLActionFrame.NANSynchronization.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_100407BF0);
  }

  return result;
}

unint64_t sub_1000E2B2C()
{
  unint64_t result = qword_100407BF8;
  if (!qword_100407BF8)
  {
    unint64_t result = swift_getWitnessTable(&unk_1003441E4, &type metadata for AWDLActionFrame.NANSynchronization.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_100407BF8);
  }

  return result;
}

unint64_t sub_1000E2B74()
{
  unint64_t result = qword_100407C00;
  if (!qword_100407C00)
  {
    unint64_t result = swift_getWitnessTable( &unk_100344104,  &type metadata for AWDLActionFrame.PeerMACAddressListBloomFilter.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_100407C00);
  }

  return result;
}

unint64_t sub_1000E2BBC()
{
  unint64_t result = qword_100407C08;
  if (!qword_100407C08)
  {
    unint64_t result = swift_getWitnessTable( &unk_10034412C,  &type metadata for AWDLActionFrame.PeerMACAddressListBloomFilter.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_100407C08);
  }

  return result;
}

unint64_t sub_1000E2C04()
{
  unint64_t result = qword_100407C10;
  if (!qword_100407C10)
  {
    unint64_t result = swift_getWitnessTable(&unk_10034404C, &type metadata for AWDLActionFrame.Version.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_100407C10);
  }

  return result;
}

unint64_t sub_1000E2C4C()
{
  unint64_t result = qword_100407C18;
  if (!qword_100407C18)
  {
    unint64_t result = swift_getWitnessTable(&unk_100344074, &type metadata for AWDLActionFrame.Version.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_100407C18);
  }

  return result;
}

unint64_t sub_1000E2C94()
{
  unint64_t result = qword_100407C20;
  if (!qword_100407C20)
  {
    unint64_t result = swift_getWitnessTable(&unk_100343F94, &type metadata for AWDLActionFrame.AWDLVersion.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_100407C20);
  }

  return result;
}

unint64_t sub_1000E2CDC()
{
  unint64_t result = qword_100407C28;
  if (!qword_100407C28)
  {
    unint64_t result = swift_getWitnessTable(&unk_100343FBC, &type metadata for AWDLActionFrame.AWDLVersion.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_100407C28);
  }

  return result;
}

unint64_t sub_1000E2D24()
{
  unint64_t result = qword_100407C30;
  if (!qword_100407C30)
  {
    unint64_t result = swift_getWitnessTable(&unk_100343EDC, &type metadata for AWDLActionFrame.SyncTreePath.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_100407C30);
  }

  return result;
}

unint64_t sub_1000E2D6C()
{
  unint64_t result = qword_100407C38;
  if (!qword_100407C38)
  {
    unint64_t result = swift_getWitnessTable(&unk_100343F04, &type metadata for AWDLActionFrame.SyncTreePath.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_100407C38);
  }

  return result;
}

unint64_t sub_1000E2DB4()
{
  unint64_t result = qword_100407C40;
  if (!qword_100407C40)
  {
    unint64_t result = swift_getWitnessTable(&unk_100343A84, &type metadata for AWDLActionFrame.ServiceParameter.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_100407C40);
  }

  return result;
}

unint64_t sub_1000E2DFC()
{
  unint64_t result = qword_100407C48;
  if (!qword_100407C48)
  {
    unint64_t result = swift_getWitnessTable(&unk_100343AAC, &type metadata for AWDLActionFrame.ServiceParameter.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_100407C48);
  }

  return result;
}

unint64_t sub_1000E2E44()
{
  unint64_t result = qword_100407C50;
  if (!qword_100407C50)
  {
    unint64_t result = swift_getWitnessTable(&unk_1003439CC, &type metadata for AWDLActionFrame.ServiceParameter.SSTH.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_100407C50);
  }

  return result;
}

unint64_t sub_1000E2E8C()
{
  unint64_t result = qword_100407C58;
  if (!qword_100407C58)
  {
    unint64_t result = swift_getWitnessTable(&unk_1003439F4, &type metadata for AWDLActionFrame.ServiceParameter.SSTH.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_100407C58);
  }

  return result;
}

unint64_t sub_1000E2ED4()
{
  unint64_t result = qword_100407C60;
  if (!qword_100407C60)
  {
    unint64_t result = swift_getWitnessTable(&unk_100343914, &type metadata for AWDLActionFrame.ServiceRequest.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_100407C60);
  }

  return result;
}

unint64_t sub_1000E2F1C()
{
  unint64_t result = qword_100407C68;
  if (!qword_100407C68)
  {
    unint64_t result = swift_getWitnessTable(&unk_10034393C, &type metadata for AWDLActionFrame.ServiceRequest.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_100407C68);
  }

  return result;
}

uint64_t sub_1000E2F60(uint64_t a1, unint64_t a2)
{
  if (a1 == 0x6574736575716572LL && a2 == 0xEF74657366664F64LL)
  {
    unint64_t v5 = 0xEF74657366664F64LL;
    goto LABEL_8;
  }

  if ((_stringCompareWithSmolCheck(_:_:expecting:)(0x6574736575716572LL, 0xEF74657366664F64LL, a1, a2, 0LL) & 1) != 0)
  {
    unint64_t v5 = a2;
LABEL_8:
    swift_bridgeObjectRelease(v5);
    return 0LL;
  }

  if (a1 == 0x6574736575716572LL && a2 == 0xEF6874676E654C64LL)
  {
    unint64_t v7 = 0xEF6874676E654C64LL;
LABEL_14:
    swift_bridgeObjectRelease(v7);
    return 1LL;
  }

  if ((_stringCompareWithSmolCheck(_:_:expecting:)(0x6574736575716572LL, 0xEF6874676E654C64LL, a1, a2, 0LL) & 1) != 0)
  {
    unint64_t v7 = a2;
    goto LABEL_14;
  }

  if (a1 == 7955819 && a2 == 0xE300000000000000LL)
  {
    swift_bridgeObjectRelease(0xE300000000000000LL);
    return 2LL;
  }

  else
  {
    char v8 = _stringCompareWithSmolCheck(_:_:expecting:)(7955819LL, 0xE300000000000000LL, a1, a2, 0LL);
    swift_bridgeObjectRelease(a2);
    if ((v8 & 1) != 0) {
      return 2LL;
    }
    else {
      return 3LL;
    }
  }

uint64_t sub_1000E30E4(uint64_t a1, unint64_t a2)
{
  if (a1 == 0x74696D736E617274LL && a2 == 0xEF6C656E6E616843LL)
  {
    unint64_t v5 = 0xEF6C656E6E616843LL;
    goto LABEL_8;
  }

  if ((_stringCompareWithSmolCheck(_:_:expecting:)(0x74696D736E617274LL, 0xEF6C656E6E616843LL, a1, a2, 0LL) & 1) != 0)
  {
    unint64_t v5 = a2;
LABEL_8:
    swift_bridgeObjectRelease(v5);
    return 0LL;
  }

  if (a1 == 0x6E756F436E776F64LL && a2 == 0xEB00000000726574LL)
  {
    unint64_t v7 = 0xEB00000000726574LL;
LABEL_14:
    swift_bridgeObjectRelease(v7);
    return 1LL;
  }

  if ((_stringCompareWithSmolCheck(_:_:expecting:)(0x6E756F436E776F64LL, 0xEB00000000726574LL, a1, a2, 0LL) & 1) != 0)
  {
    unint64_t v7 = a2;
    goto LABEL_14;
  }

  if (a1 == 0xD000000000000011LL)
  {
    unint64_t v8 = 0x8000000100364450LL;
    if (a2 == 0x8000000100364450LL) {
      goto LABEL_19;
    }
  }

  if ((_stringCompareWithSmolCheck(_:_:expecting:)(0xD000000000000011LL, 0x8000000100364450LL, a1, a2, 0LL) & 1) != 0)
  {
    unint64_t v8 = a2;
LABEL_19:
    swift_bridgeObjectRelease(v8);
    return 2LL;
  }

  if (a1 == 0x6D69546472617567LL && a2 == 0xE900000000000065LL)
  {
    unint64_t v9 = 0xE900000000000065LL;
LABEL_25:
    swift_bridgeObjectRelease(v9);
    return 3LL;
  }

  if ((_stringCompareWithSmolCheck(_:_:expecting:)(0x6D69546472617567LL, 0xE900000000000065LL, a1, a2, 0LL) & 1) != 0)
  {
    unint64_t v9 = a2;
    goto LABEL_25;
  }

  if (a1 == 0xD000000000000018LL)
  {
    unint64_t v10 = 0x8000000100364470LL;
    if (a2 == 0x8000000100364470LL) {
      goto LABEL_30;
    }
  }

  if ((_stringCompareWithSmolCheck(_:_:expecting:)(0xD000000000000018LL, 0x8000000100364470LL, a1, a2, 0LL) & 1) != 0)
  {
    unint64_t v10 = a2;
LABEL_30:
    swift_bridgeObjectRelease(v10);
    return 4LL;
  }

  if (a1 == 0xD000000000000011LL)
  {
    unint64_t v11 = 0x8000000100364490LL;
    if (a2 == 0x8000000100364490LL) {
      goto LABEL_35;
    }
  }

  if ((_stringCompareWithSmolCheck(_:_:expecting:)(0xD000000000000011LL, 0x8000000100364490LL, a1, a2, 0LL) & 1) != 0)
  {
    unint64_t v11 = a2;
LABEL_35:
    swift_bridgeObjectRelease(v11);
    return 5LL;
  }

  if (a1 == 0x7367616C66LL && a2 == 0xE500000000000000LL)
  {
    unint64_t v12 = 0xE500000000000000LL;
LABEL_41:
    swift_bridgeObjectRelease(v12);
    return 6LL;
  }

  if ((_stringCompareWithSmolCheck(_:_:expecting:)(0x7367616C66LL, 0xE500000000000000LL, a1, a2, 0LL) & 1) != 0)
  {
    unint64_t v12 = a2;
    goto LABEL_41;
  }

  if (a1 == 0xD000000000000021LL && a2 == 0x80000001003644B0LL)
  {
    unint64_t v13 = 0x80000001003644B0LL;
LABEL_47:
    swift_bridgeObjectRelease(v13);
    return 7LL;
  }

  if ((_stringCompareWithSmolCheck(_:_:expecting:)(0xD000000000000021LL, 0x80000001003644B0LL, a1, a2, 0LL) & 1) != 0)
  {
    unint64_t v13 = a2;
    goto LABEL_47;
  }

  if (a1 == 0xD000000000000018LL)
  {
    unint64_t v14 = 0x80000001003644E0LL;
    if (a2 == 0x80000001003644E0LL) {
      goto LABEL_52;
    }
  }

  if ((_stringCompareWithSmolCheck(_:_:expecting:)(0xD000000000000018LL, 0x80000001003644E0LL, a1, a2, 0LL) & 1) != 0)
  {
    unint64_t v14 = a2;
LABEL_52:
    swift_bridgeObjectRelease(v14);
    return 8LL;
  }

  if (a1 == 0xD000000000000018LL)
  {
    unint64_t v15 = 0x8000000100364500LL;
    if (a2 == 0x8000000100364500LL) {
      goto LABEL_57;
    }
  }

  if ((_stringCompareWithSmolCheck(_:_:expecting:)(0xD000000000000018LL, 0x8000000100364500LL, a1, a2, 0LL) & 1) != 0)
  {
    unint64_t v15 = a2;
LABEL_57:
    swift_bridgeObjectRelease(v15);
    return 9LL;
  }

  if (a1 == 0xD000000000000011LL)
  {
    unint64_t v16 = 0x8000000100364520LL;
    if (a2 == 0x8000000100364520LL) {
      goto LABEL_62;
    }
  }

  if ((_stringCompareWithSmolCheck(_:_:expecting:)(0xD000000000000011LL, 0x8000000100364520LL, a1, a2, 0LL) & 1) != 0)
  {
    unint64_t v16 = a2;
LABEL_62:
    swift_bridgeObjectRelease(v16);
    return 10LL;
  }

  if (a1 == 0xD00000000000001ALL && a2 == 0x8000000100364540LL)
  {
    unint64_t v17 = 0x8000000100364540LL;
LABEL_68:
    swift_bridgeObjectRelease(v17);
    return 11LL;
  }

  if ((_stringCompareWithSmolCheck(_:_:expecting:)(0xD00000000000001ALL, 0x8000000100364540LL, a1, a2, 0LL) & 1) != 0)
  {
    unint64_t v17 = a2;
    goto LABEL_68;
  }

  if (a1 == 0xD000000000000018LL)
  {
    unint64_t v18 = 0x8000000100364560LL;
    if (a2 == 0x8000000100364560LL) {
      goto LABEL_73;
    }
  }

  if ((_stringCompareWithSmolCheck(_:_:expecting:)(0xD000000000000018LL, 0x8000000100364560LL, a1, a2, 0LL) & 1) != 0)
  {
    unint64_t v18 = a2;
LABEL_73:
    swift_bridgeObjectRelease(v18);
    return 12LL;
  }

  if (a1 == 0xD00000000000001CLL && a2 == 0x8000000100364580LL)
  {
    unint64_t v19 = 0x8000000100364580LL;
LABEL_79:
    swift_bridgeObjectRelease(v19);
    return 13LL;
  }

  if ((_stringCompareWithSmolCheck(_:_:expecting:)(0xD00000000000001CLL, 0x8000000100364580LL, a1, a2, 0LL) & 1) != 0)
  {
    unint64_t v19 = a2;
    goto LABEL_79;
  }

  if (a1 == 0x72657473616DLL && a2 == 0xE600000000000000LL)
  {
    unint64_t v20 = 0xE600000000000000LL;
LABEL_85:
    swift_bridgeObjectRelease(v20);
    return 14LL;
  }

  if ((_stringCompareWithSmolCheck(_:_:expecting:)(0x72657473616DLL, 0xE600000000000000LL, a1, a2, 0LL) & 1) != 0)
  {
    unint64_t v20 = a2;
    goto LABEL_85;
  }

  if (a1 == 0x65636E6573657270LL && a2 == 0xEC00000065646F4DLL)
  {
    unint64_t v21 = 0xEC00000065646F4DLL;
LABEL_91:
    swift_bridgeObjectRelease(v21);
    return 15LL;
  }

  if ((_stringCompareWithSmolCheck(_:_:expecting:)(0x65636E6573657270LL, 0xEC00000065646F4DLL, a1, a2, 0LL) & 1) != 0)
  {
    unint64_t v21 = a2;
    goto LABEL_91;
  }

  if (a1 == 0x6465767265736572LL && a2 == 0xE800000000000000LL)
  {
    unint64_t v22 = 0xE800000000000000LL;
LABEL_97:
    swift_bridgeObjectRelease(v22);
    return 16LL;
  }

  if ((_stringCompareWithSmolCheck(_:_:expecting:)(0x6465767265736572LL, 0xE800000000000000LL, a1, a2, 0LL) & 1) != 0)
  {
    unint64_t v22 = a2;
    goto LABEL_97;
  }

  if (a1 == 0x65636E6575716573LL && a2 == 0xE800000000000000LL)
  {
    unint64_t v23 = 0xE800000000000000LL;
LABEL_103:
    swift_bridgeObjectRelease(v23);
    return 17LL;
  }

  if ((_stringCompareWithSmolCheck(_:_:expecting:)(0x65636E6575716573LL, 0xE800000000000000LL, a1, a2, 0LL) & 1) != 0)
  {
    unint64_t v23 = a2;
    goto LABEL_103;
  }

  if (a1 == 0xD00000000000001FLL && a2 == 0x80000001003645A0LL)
  {
    unint64_t v24 = 0x80000001003645A0LL;
LABEL_109:
    swift_bridgeObjectRelease(v24);
    return 18LL;
  }

  if ((_stringCompareWithSmolCheck(_:_:expecting:)(0xD00000000000001FLL, 0x80000001003645A0LL, a1, a2, 0LL) & 1) != 0)
  {
    unint64_t v24 = a2;
    goto LABEL_109;
  }

  if (a1 == 0xD000000000000018LL && a2 == 0x80000001003645C0LL)
  {
    swift_bridgeObjectRelease(0x80000001003645C0LL);
    return 19LL;
  }

  else
  {
    char v25 = _stringCompareWithSmolCheck(_:_:expecting:)(0xD000000000000018LL, 0x80000001003645C0LL, a1, a2, 0LL);
    swift_bridgeObjectRelease(a2);
    if ((v25 & 1) != 0) {
      return 19LL;
    }
    else {
      return 20LL;
    }
  }

uint64_t sub_1000E3888(uint64_t a1, unint64_t a2)
{
  if (a1 == 0x7367616C66LL && a2 == 0xE500000000000000LL)
  {
    unint64_t v5 = 0xE500000000000000LL;
    goto LABEL_8;
  }

  if ((_stringCompareWithSmolCheck(_:_:expecting:)(0x7367616C66LL, 0xE500000000000000LL, a1, a2, 0LL) & 1) != 0)
  {
    unint64_t v5 = a2;
LABEL_8:
    swift_bridgeObjectRelease(v5);
    return 0LL;
  }

  if (a1 == 0x6E6F697463656C65LL && a2 == 0xEA00000000004449LL)
  {
    unint64_t v7 = 0xEA00000000004449LL;
LABEL_14:
    swift_bridgeObjectRelease(v7);
    return 1LL;
  }

  if ((_stringCompareWithSmolCheck(_:_:expecting:)(0x6E6F697463656C65LL, 0xEA00000000004449LL, a1, a2, 0LL) & 1) != 0)
  {
    unint64_t v7 = a2;
    goto LABEL_14;
  }

  if (a1 == 0x65636E6174736964LL && a2 == 0xEF706F546D6F7246LL)
  {
    unint64_t v8 = 0xEF706F546D6F7246LL;
LABEL_20:
    swift_bridgeObjectRelease(v8);
    return 2LL;
  }

  if ((_stringCompareWithSmolCheck(_:_:expecting:)(0x65636E6174736964LL, 0xEF706F546D6F7246LL, a1, a2, 0LL) & 1) != 0)
  {
    unint64_t v8 = a2;
    goto LABEL_20;
  }

  if (a1 == 0x6465767265736572LL && a2 == 0xED0000646C656946LL)
  {
    unint64_t v9 = 0xED0000646C656946LL;
LABEL_26:
    swift_bridgeObjectRelease(v9);
    return 3LL;
  }

  if ((_stringCompareWithSmolCheck(_:_:expecting:)(0x6465767265736572LL, 0xED0000646C656946LL, a1, a2, 0LL) & 1) != 0)
  {
    unint64_t v9 = a2;
    goto LABEL_26;
  }

  if (a1 == 0x73736572646461LL && a2 == 0xE700000000000000LL)
  {
    unint64_t v10 = 0xE700000000000000LL;
LABEL_32:
    swift_bridgeObjectRelease(v10);
    return 4LL;
  }

  if ((_stringCompareWithSmolCheck(_:_:expecting:)(0x73736572646461LL, 0xE700000000000000LL, a1, a2, 0LL) & 1) != 0)
  {
    unint64_t v10 = a2;
    goto LABEL_32;
  }

  if (a1 == 0x657473614D706F74LL && a2 == 0xEF63697274654D72LL)
  {
    unint64_t v11 = 0xEF63697274654D72LL;
LABEL_38:
    swift_bridgeObjectRelease(v11);
    return 5LL;
  }

  if ((_stringCompareWithSmolCheck(_:_:expecting:)(0x657473614D706F74LL, 0xEF63697274654D72LL, a1, a2, 0LL) & 1) != 0)
  {
    unint64_t v11 = a2;
    goto LABEL_38;
  }

  if (a1 == 0xD000000000000012LL && a2 == 0x8000000100364430LL)
  {
    swift_bridgeObjectRelease(0x8000000100364430LL);
    return 6LL;
  }

  else
  {
    char v12 = _stringCompareWithSmolCheck(_:_:expecting:)(0xD000000000000012LL, 0x8000000100364430LL, a1, a2, 0LL);
    swift_bridgeObjectRelease(a2);
    if ((v12 & 1) != 0) {
      return 6LL;
    }
    else {
      return 7LL;
    }
  }

uint64_t sub_1000E3BD8(uint64_t a1, unint64_t a2)
{
  if (a1 == 0x6574794268747373LL && a2 == 0xEB0000000070614DLL)
  {
    unint64_t v5 = 0xEB0000000070614DLL;
    goto LABEL_8;
  }

  if ((_stringCompareWithSmolCheck(_:_:expecting:)(0x6574794268747373LL, 0xEB0000000070614DLL, a1, a2, 0LL) & 1) != 0)
  {
    unint64_t v5 = a2;
LABEL_8:
    swift_bridgeObjectRelease(v5);
    return 0LL;
  }

  if (a1 == 0x73736572706D6F63LL && a2 == 0xEE00485453536465LL)
  {
    swift_bridgeObjectRelease(0xEE00485453536465LL);
    return 1LL;
  }

  else
  {
    char v7 = _stringCompareWithSmolCheck(_:_:expecting:)(0x73736572706D6F63LL, 0xEE00485453536465LL, a1, a2, 0LL);
    swift_bridgeObjectRelease(a2);
    if ((v7 & 1) != 0) {
      return 1LL;
    }
    else {
      return 2LL;
    }
  }

uint64_t sub_1000E3D04(uint64_t a1, unint64_t a2)
{
  if (a1 == 0x7367616C66LL && a2 == 0xE500000000000000LL)
  {
    unint64_t v5 = 0xE500000000000000LL;
    goto LABEL_8;
  }

  if ((_stringCompareWithSmolCheck(_:_:expecting:)(0x7367616C66LL, 0xE500000000000000LL, a1, a2, 0LL) & 1) != 0)
  {
    unint64_t v5 = a2;
LABEL_8:
    swift_bridgeObjectRelease(v5);
    return 0LL;
  }

  if (a1 == 0x6D69546C6C657764LL && a2 == 0xE900000000000065LL)
  {
    unint64_t v7 = 0xE900000000000065LL;
LABEL_14:
    swift_bridgeObjectRelease(v7);
    return 1LL;
  }

  if ((_stringCompareWithSmolCheck(_:_:expecting:)(0x6D69546C6C657764LL, 0xE900000000000065LL, a1, a2, 0LL) & 1) != 0)
  {
    unint64_t v7 = a2;
    goto LABEL_14;
  }

  if (a1 == 0xD000000000000016LL)
  {
    unint64_t v8 = 0x80000001003642C0LL;
    if (a2 == 0x80000001003642C0LL) {
      goto LABEL_19;
    }
  }

  if ((_stringCompareWithSmolCheck(_:_:expecting:)(0xD000000000000016LL, 0x80000001003642C0LL, a1, a2, 0LL) & 1) != 0)
  {
    unint64_t v8 = a2;
LABEL_19:
    swift_bridgeObjectRelease(v8);
    return 2LL;
  }

  if (a1 == 1752462195 && a2 == 0xE400000000000000LL)
  {
    swift_bridgeObjectRelease(0xE400000000000000LL);
    return 3LL;
  }

  else
  {
    char v9 = _stringCompareWithSmolCheck(_:_:expecting:)(1752462195LL, 0xE400000000000000LL, a1, a2, 0LL);
    swift_bridgeObjectRelease(a2);
    if ((v9 & 1) != 0) {
      return 3LL;
    }
    else {
      return 4LL;
    }
  }

uint64_t sub_1000E3EA8(uint64_t a1, unint64_t a2)
{
  if (a1 == 0x6E6F6973726576LL && a2 == 0xE700000000000000LL)
  {
    unint64_t v5 = 0xE700000000000000LL;
    goto LABEL_8;
  }

  if ((_stringCompareWithSmolCheck(_:_:expecting:)(0x6E6F6973726576LL, 0xE700000000000000LL, a1, a2, 0LL) & 1) != 0)
  {
    unint64_t v5 = a2;
LABEL_8:
    swift_bridgeObjectRelease(v5);
    return 0LL;
  }

  if (a1 == 0x726F6674616C705FLL && a2 == 0xED0000657079546DLL)
  {
    swift_bridgeObjectRelease(0xED0000657079546DLL);
    return 1LL;
  }

  else
  {
    char v7 = _stringCompareWithSmolCheck(_:_:expecting:)(0x726F6674616C705FLL, 0xED0000657079546DLL, a1, a2, 0LL);
    swift_bridgeObjectRelease(a2);
    if ((v7 & 1) != 0) {
      return 1LL;
    }
    else {
      return 2LL;
    }
  }

uint64_t sub_1000E3FBC(uint64_t a1, unint64_t a2)
{
  if (a1 == 0xD000000000000014LL)
  {
    unint64_t v4 = 0x80000001003642E0LL;
    if (a2 == 0x80000001003642E0LL) {
      goto LABEL_5;
    }
  }

  if ((_stringCompareWithSmolCheck(_:_:expecting:)(0xD000000000000014LL, 0x80000001003642E0LL, a1, a2, 0LL) & 1) != 0)
  {
    unint64_t v4 = a2;
LABEL_5:
    swift_bridgeObjectRelease(v4);
    return 0LL;
  }

  if (a1 == 0x746E756F63LL && a2 == 0xE500000000000000LL)
  {
    unint64_t v6 = 0xE500000000000000LL;
LABEL_11:
    swift_bridgeObjectRelease(v6);
    return 1LL;
  }

  if ((_stringCompareWithSmolCheck(_:_:expecting:)(0x746E756F63LL, 0xE500000000000000LL, a1, a2, 0LL) & 1) != 0)
  {
    unint64_t v6 = a2;
    goto LABEL_11;
  }

  if (a1 == 0x6D6F6F6C62LL && a2 == 0xE500000000000000LL)
  {
    swift_bridgeObjectRelease(0xE500000000000000LL);
    return 2LL;
  }

  else
  {
    char v7 = _stringCompareWithSmolCheck(_:_:expecting:)(0x6D6F6F6C62LL, 0xE500000000000000LL, a1, a2, 0LL);
    swift_bridgeObjectRelease(a2);
    if ((v7 & 1) != 0) {
      return 2LL;
    }
    else {
      return 3LL;
    }
  }

uint64_t sub_1000E40FC(uint64_t a1, unint64_t a2)
{
  if (a1 == 0x746E756F43706F68LL && a2 == 0xE800000000000000LL)
  {
    unint64_t v5 = 0xE800000000000000LL;
    goto LABEL_8;
  }

  if ((_stringCompareWithSmolCheck(_:_:expecting:)(0x746E756F43706F68LL, 0xE800000000000000LL, a1, a2, 0LL) & 1) != 0)
  {
    unint64_t v5 = a2;
LABEL_8:
    swift_bridgeObjectRelease(v5);
    return 0LL;
  }

  if (a1 == 0x6F4E656372756F73LL && a2 == 0xEA00000000006564LL)
  {
    unint64_t v7 = 0xEA00000000006564LL;
LABEL_14:
    swift_bridgeObjectRelease(v7);
    return 1LL;
  }

  if ((_stringCompareWithSmolCheck(_:_:expecting:)(0x6F4E656372756F73LL, 0xEA00000000006564LL, a1, a2, 0LL) & 1) != 0)
  {
    unint64_t v7 = a2;
    goto LABEL_14;
  }

  if (a1 == 0x4972657473756C63LL && a2 == 0xE900000000000044LL)
  {
    unint64_t v8 = 0xE900000000000044LL;
LABEL_20:
    swift_bridgeObjectRelease(v8);
    return 2LL;
  }

  if ((_stringCompareWithSmolCheck(_:_:expecting:)(0x4972657473756C63LL, 0xE900000000000044LL, a1, a2, 0LL) & 1) != 0)
  {
    unint64_t v8 = a2;
    goto LABEL_20;
  }

  if (a1 == 0xD00000000000001BLL)
  {
    unint64_t v9 = 0x8000000100364300LL;
    if (a2 == 0x8000000100364300LL) {
      goto LABEL_25;
    }
  }

  if ((_stringCompareWithSmolCheck(_:_:expecting:)(0xD00000000000001BLL, 0x8000000100364300LL, a1, a2, 0LL) & 1) != 0)
  {
    unint64_t v9 = a2;
LABEL_25:
    swift_bridgeObjectRelease(v9);
    return 3LL;
  }

  if (a1 == 0xD000000000000010LL)
  {
    unint64_t v10 = 0x8000000100364320LL;
    if (a2 == 0x8000000100364320LL) {
      goto LABEL_30;
    }
  }

  if ((_stringCompareWithSmolCheck(_:_:expecting:)(0xD000000000000010LL, 0x8000000100364320LL, a1, a2, 0LL) & 1) != 0)
  {
    unint64_t v10 = a2;
LABEL_30:
    swift_bridgeObjectRelease(v10);
    return 4LL;
  }

  if (a1 == 0xD000000000000013LL && a2 == 0x8000000100364340LL)
  {
    unint64_t v11 = 0x8000000100364340LL;
LABEL_36:
    swift_bridgeObjectRelease(v11);
    return 5LL;
  }

  if ((_stringCompareWithSmolCheck(_:_:expecting:)(0xD000000000000013LL, 0x8000000100364340LL, a1, a2, 0LL) & 1) != 0)
  {
    unint64_t v11 = a2;
    goto LABEL_36;
  }

  if (a1 == 0xD000000000000018LL && a2 == 0x8000000100364360LL)
  {
    unint64_t v12 = 0x8000000100364360LL;
LABEL_42:
    swift_bridgeObjectRelease(v12);
    return 6LL;
  }

  if ((_stringCompareWithSmolCheck(_:_:expecting:)(0xD000000000000018LL, 0x8000000100364360LL, a1, a2, 0LL) & 1) != 0)
  {
    unint64_t v12 = a2;
    goto LABEL_42;
  }

  if (a1 == 0xD000000000000016LL && a2 == 0x8000000100364380LL)
  {
    unint64_t v13 = 0x8000000100364380LL;
LABEL_48:
    swift_bridgeObjectRelease(v13);
    return 7LL;
  }

  if ((_stringCompareWithSmolCheck(_:_:expecting:)(0xD000000000000016LL, 0x8000000100364380LL, a1, a2, 0LL) & 1) != 0)
  {
    unint64_t v13 = a2;
    goto LABEL_48;
  }

  if (a1 == 0xD000000000000014LL && a2 == 0x80000001003643A0LL)
  {
    unint64_t v14 = 0x80000001003643A0LL;
LABEL_54:
    swift_bridgeObjectRelease(v14);
    return 8LL;
  }

  if ((_stringCompareWithSmolCheck(_:_:expecting:)(0xD000000000000014LL, 0x80000001003643A0LL, a1, a2, 0LL) & 1) != 0)
  {
    unint64_t v14 = a2;
    goto LABEL_54;
  }

  if (a1 == 0xD000000000000022LL && a2 == 0x80000001003643C0LL)
  {
    swift_bridgeObjectRelease(0x80000001003643C0LL);
    return 9LL;
  }

  else
  {
    char v15 = _stringCompareWithSmolCheck(_:_:expecting:)(0xD000000000000022LL, 0x80000001003643C0LL, a1, a2, 0LL);
    swift_bridgeObjectRelease(a2);
    if ((v15 & 1) != 0) {
      return 9LL;
    }
    else {
      return 10LL;
    }
  }

uint64_t sub_1000E44DC(uint64_t a1, unint64_t a2)
{
  if (a1 == 0x65646F4E746F6F72LL && a2 == 0xE800000000000000LL)
  {
    unint64_t v5 = 0xE800000000000000LL;
    goto LABEL_8;
  }

  if ((_stringCompareWithSmolCheck(_:_:expecting:)(0x65646F4E746F6F72LL, 0xE800000000000000LL, a1, a2, 0LL) & 1) != 0)
  {
    unint64_t v5 = a2;
LABEL_8:
    swift_bridgeObjectRelease(v5);
    return 0LL;
  }

  if (a1 == 0x6F4E746E65726170LL && a2 == 0xEA00000000006564LL)
  {
    unint64_t v7 = 0xEA00000000006564LL;
LABEL_14:
    swift_bridgeObjectRelease(v7);
    return 1LL;
  }

  if ((_stringCompareWithSmolCheck(_:_:expecting:)(0x6F4E746E65726170LL, 0xEA00000000006564LL, a1, a2, 0LL) & 1) != 0)
  {
    unint64_t v7 = a2;
    goto LABEL_14;
  }

  if (a1 == 0xD000000000000013LL)
  {
    unint64_t v8 = 0x80000001003643F0LL;
    if (a2 == 0x80000001003643F0LL) {
      goto LABEL_19;
    }
  }

  if ((_stringCompareWithSmolCheck(_:_:expecting:)(0xD000000000000013LL, 0x80000001003643F0LL, a1, a2, 0LL) & 1) != 0)
  {
    unint64_t v8 = a2;
LABEL_19:
    swift_bridgeObjectRelease(v8);
    return 2LL;
  }

  if (a1 == 0x746E756F43706F68LL && a2 == 0xE800000000000000LL)
  {
    unint64_t v9 = 0xE800000000000000LL;
LABEL_25:
    swift_bridgeObjectRelease(v9);
    return 3LL;
  }

  if ((_stringCompareWithSmolCheck(_:_:expecting:)(0x746E756F43706F68LL, 0xE800000000000000LL, a1, a2, 0LL) & 1) != 0)
  {
    unint64_t v9 = a2;
    goto LABEL_25;
  }

  if (a1 == 0x7274654D746F6F72LL && a2 == 0xEA00000000006369LL)
  {
    unint64_t v10 = 0xEA00000000006369LL;
LABEL_31:
    swift_bridgeObjectRelease(v10);
    return 4LL;
  }

  if ((_stringCompareWithSmolCheck(_:_:expecting:)(0x7274654D746F6F72LL, 0xEA00000000006369LL, a1, a2, 0LL) & 1) != 0)
  {
    unint64_t v10 = a2;
    goto LABEL_31;
  }

  if (a1 == 0x7274654D666C6573LL && a2 == 0xEA00000000006369LL)
  {
    unint64_t v11 = 0xEA00000000006369LL;
LABEL_37:
    swift_bridgeObjectRelease(v11);
    return 5LL;
  }

  if ((_stringCompareWithSmolCheck(_:_:expecting:)(0x7274654D666C6573LL, 0xEA00000000006369LL, a1, a2, 0LL) & 1) != 0)
  {
    unint64_t v11 = a2;
    goto LABEL_37;
  }

  if (a1 == 0x6E6F697463656C65LL && a2 == 0xEA00000000004449LL)
  {
    unint64_t v12 = 0xEA00000000004449LL;
LABEL_43:
    swift_bridgeObjectRelease(v12);
    return 6LL;
  }

  if ((_stringCompareWithSmolCheck(_:_:expecting:)(0x6E6F697463656C65LL, 0xEA00000000004449LL, a1, a2, 0LL) & 1) != 0)
  {
    unint64_t v12 = a2;
    goto LABEL_43;
  }

  if (a1 == 0x6E6F697463656C65LL && a2 == 0xED00007367616C46LL)
  {
    unint64_t v13 = 0xED00007367616C46LL;
LABEL_49:
    swift_bridgeObjectRelease(v13);
    return 7LL;
  }

  if ((_stringCompareWithSmolCheck(_:_:expecting:)(0x6E6F697463656C65LL, 0xED00007367616C46LL, a1, a2, 0LL) & 1) != 0)
  {
    unint64_t v13 = a2;
    goto LABEL_49;
  }

  if (a1 == 0xD000000000000013LL && a2 == 0x8000000100364410LL)
  {
    swift_bridgeObjectRelease(0x8000000100364410LL);
    return 8LL;
  }

  else
  {
    char v14 = _stringCompareWithSmolCheck(_:_:expecting:)(0xD000000000000013LL, 0x8000000100364410LL, a1, a2, 0LL);
    swift_bridgeObjectRelease(a2);
    if ((v14 & 1) != 0) {
      return 8LL;
    }
    else {
      return 9LL;
    }
  }

uint64_t sub_1000E48A8(uint64_t a1, unint64_t a2)
{
  if (a1 == 0x7367616C66LL && a2 == 0xE500000000000000LL)
  {
    unint64_t v5 = 0xE500000000000000LL;
    goto LABEL_8;
  }

  if ((_stringCompareWithSmolCheck(_:_:expecting:)(0x7367616C66LL, 0xE500000000000000LL, a1, a2, 0LL) & 1) != 0)
  {
    unint64_t v5 = a2;
LABEL_8:
    swift_bridgeObjectRelease(v5);
    return 0LL;
  }

  if (a1 == 0x44496E656B6F74LL && a2 == 0xE700000000000000LL)
  {
    swift_bridgeObjectRelease(0xE700000000000000LL);
    return 1LL;
  }

  else
  {
    char v7 = _stringCompareWithSmolCheck(_:_:expecting:)(0x44496E656B6F74LL, 0xE700000000000000LL, a1, a2, 0LL);
    swift_bridgeObjectRelease(a2);
    if ((v7 & 1) != 0) {
      return 1LL;
    }
    else {
      return 2LL;
    }
  }

uint64_t sub_1000E4990(uint64_t a1, unint64_t a2)
{
  if (a1 == 0x6E6F6973726576LL && a2 == 0xE700000000000000LL)
  {
    unint64_t v5 = 0xE700000000000000LL;
    goto LABEL_8;
  }

  if ((_stringCompareWithSmolCheck(_:_:expecting:)(0x6E6F6973726576LL, 0xE700000000000000LL, a1, a2, 0LL) & 1) != 0)
  {
    unint64_t v5 = a2;
LABEL_8:
    swift_bridgeObjectRelease(v5);
    return 0LL;
  }

  if (a1 == 0x646E616D6D6F63LL && a2 == 0xE700000000000000LL)
  {
    unint64_t v7 = 0xE700000000000000LL;
LABEL_14:
    swift_bridgeObjectRelease(v7);
    return 1LL;
  }

  if ((_stringCompareWithSmolCheck(_:_:expecting:)(0x646E616D6D6F63LL, 0xE700000000000000LL, a1, a2, 0LL) & 1) != 0)
  {
    unint64_t v7 = a2;
    goto LABEL_14;
  }

  if (a1 == 0x737574617473LL && a2 == 0xE600000000000000LL)
  {
    unint64_t v8 = 0xE600000000000000LL;
LABEL_20:
    swift_bridgeObjectRelease(v8);
    return 2LL;
  }

  if ((_stringCompareWithSmolCheck(_:_:expecting:)(0x737574617473LL, 0xE600000000000000LL, a1, a2, 0LL) & 1) != 0)
  {
    unint64_t v8 = a2;
    goto LABEL_20;
  }

  if (a1 == 0x7367616C66LL && a2 == 0xE500000000000000LL)
  {
    swift_bridgeObjectRelease(0xE500000000000000LL);
    return 3LL;
  }

  else
  {
    char v9 = _stringCompareWithSmolCheck(_:_:expecting:)(0x7367616C66LL, 0xE500000000000000LL, a1, a2, 0LL);
    swift_bridgeObjectRelease(a2);
    if ((v9 & 1) != 0) {
      return 3LL;
    }
    else {
      return 4LL;
    }
  }

uint64_t sub_1000E4B38(uint64_t a1, unint64_t a2)
{
  if (a1 == 0x6E6F6973726576LL && a2 == 0xE700000000000000LL)
  {
    unint64_t v5 = 0xE700000000000000LL;
    goto LABEL_8;
  }

  if ((_stringCompareWithSmolCheck(_:_:expecting:)(0x6E6F6973726576LL, 0xE700000000000000LL, a1, a2, 0LL) & 1) != 0)
  {
    unint64_t v5 = a2;
LABEL_8:
    swift_bridgeObjectRelease(v5);
    return 0LL;
  }

  if (a1 == 0x6574617473LL && a2 == 0xE500000000000000LL)
  {
    swift_bridgeObjectRelease(0xE500000000000000LL);
    return 1LL;
  }

  else
  {
    char v7 = _stringCompareWithSmolCheck(_:_:expecting:)(0x6574617473LL, 0xE500000000000000LL, a1, a2, 0LL);
    swift_bridgeObjectRelease(a2);
    if ((v7 & 1) != 0) {
      return 1LL;
    }
    else {
      return 2LL;
    }
  }

unint64_t sub_1000E4C20()
{
  unint64_t result = qword_100407C70;
  if (!qword_100407C70)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for AWDLActionFrame.AWDLAttribute.AttributeType,  &type metadata for AWDLActionFrame.AWDLAttribute.AttributeType);
    atomic_store(result, (unint64_t *)&qword_100407C70);
  }

  return result;
}

unint64_t sub_1000E4C64()
{
  unint64_t result = qword_100407C78;
  if (!qword_100407C78)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for AWDLActionFrame.AirDrop.State,  &type metadata for AWDLActionFrame.AirDrop.State);
    atomic_store(result, (unint64_t *)&qword_100407C78);
  }

  return result;
}

unint64_t sub_1000E4CA8()
{
  unint64_t result = qword_100407C80;
  if (!qword_100407C80)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for AWDLActionFrame.ProMode.Command,  &type metadata for AWDLActionFrame.ProMode.Command);
    atomic_store(result, (unint64_t *)&qword_100407C80);
  }

  return result;
}

unint64_t sub_1000E4CEC()
{
  unint64_t result = qword_100407C88;
  if (!qword_100407C88)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for AWDLActionFrame.MultiPeerBSSSteering.SteeringMessageID,  &type metadata for AWDLActionFrame.MultiPeerBSSSteering.SteeringMessageID);
    atomic_store(result, (unint64_t *)&qword_100407C88);
  }

  return result;
}

unint64_t sub_1000E4D30()
{
  unint64_t result = qword_100407C90;
  if (!qword_100407C90)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for AWDLActionFrame.Version.PlatformType,  &type metadata for AWDLActionFrame.Version.PlatformType);
    atomic_store(result, (unint64_t *)&qword_100407C90);
  }

  return result;
}

unint64_t sub_1000E4D74()
{
  unint64_t result = qword_100407C98;
  if (!qword_100407C98)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for AWDLActionFrame.DataPathState.UnicastMasterIndicationOptions,  &type metadata for AWDLActionFrame.DataPathState.UnicastMasterIndicationOptions);
    atomic_store(result, (unint64_t *)&qword_100407C98);
  }

  return result;
}

unint64_t sub_1000E4DB8()
{
  unint64_t result = qword_100407CA0;
  if (!qword_100407CA0)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for AWDLActionFrame.OUISubtype,  &type metadata for AWDLActionFrame.OUISubtype);
    atomic_store(result, (unint64_t *)&qword_100407CA0);
  }

  return result;
}

unint64_t sub_1000E4DFC()
{
  unint64_t result = qword_100407CA8;
  if (!qword_100407CA8)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for AWDLActionFrame.OUIType,  &type metadata for AWDLActionFrame.OUIType);
    atomic_store(result, (unint64_t *)&qword_100407CA8);
  }

  return result;
}

unint64_t sub_1000E4E40()
{
  unint64_t result = qword_100407CB8;
  if (!qword_100407CB8)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for AWDLActionFrame.OUIType,  &type metadata for AWDLActionFrame.OUIType);
    atomic_store(result, (unint64_t *)&qword_100407CB8);
  }

  return result;
}

unint64_t sub_1000E4E84()
{
  unint64_t result = qword_100407CC0;
  if (!qword_100407CC0)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for AWDLActionFrame.AWDLVersion,  &type metadata for AWDLActionFrame.AWDLVersion);
    atomic_store(result, (unint64_t *)&qword_100407CC0);
  }

  return result;
}

unint64_t sub_1000E4EC8()
{
  unint64_t result = qword_100407CC8;
  if (!qword_100407CC8)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for AWDLActionFrame.OUISubtype,  &type metadata for AWDLActionFrame.OUISubtype);
    atomic_store(result, (unint64_t *)&qword_100407CC8);
  }

  return result;
}

unint64_t sub_1000E4F0C()
{
  unint64_t result = qword_100407CE8;
  if (!qword_100407CE8)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for AWDLActionFrame.AirDrop.State,  &type metadata for AWDLActionFrame.AirDrop.State);
    atomic_store(result, (unint64_t *)&qword_100407CE8);
  }

  return result;
}

unint64_t sub_1000E4F50()
{
  unint64_t result = qword_100407CF8;
  if (!qword_100407CF8)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for AWDLActionFrame.ProMode.Command,  &type metadata for AWDLActionFrame.ProMode.Command);
    atomic_store(result, (unint64_t *)&qword_100407CF8);
  }

  return result;
}

unint64_t sub_1000E4F94()
{
  unint64_t result = qword_100407D00;
  if (!qword_100407D00)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for AWDLActionFrame.ProMode.Flags,  &type metadata for AWDLActionFrame.ProMode.Flags);
    atomic_store(result, (unint64_t *)&qword_100407D00);
  }

  return result;
}

unint64_t sub_1000E4FD8()
{
  unint64_t result = qword_100407D08;
  if (!qword_100407D08)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for AWDLActionFrame.RealtimeGroup.Flags,  &type metadata for AWDLActionFrame.RealtimeGroup.Flags);
    atomic_store(result, (unint64_t *)&qword_100407D08);
  }

  return result;
}

unint64_t sub_1000E501C()
{
  unint64_t result = qword_100407D10;
  if (!qword_100407D10)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for AWDLActionFrame.RealtimeGroup.AdditionalFlags,  &type metadata for AWDLActionFrame.RealtimeGroup.AdditionalFlags);
    atomic_store(result, (unint64_t *)&qword_100407D10);
  }

  return result;
}

unint64_t sub_1000E5060()
{
  unint64_t result = qword_100407D30;
  if (!qword_100407D30)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for AWDLActionFrame.MultiPeerBSSSteering.SteeringMessageID,  &type metadata for AWDLActionFrame.MultiPeerBSSSteering.SteeringMessageID);
    atomic_store(result, (unint64_t *)&qword_100407D30);
  }

  return result;
}

unint64_t sub_1000E50A4()
{
  unint64_t result = qword_100407D40;
  if (!qword_100407D40)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for AWDLElectionMetric,  &type metadata for AWDLElectionMetric);
    atomic_store(result, (unint64_t *)&qword_100407D40);
  }

  return result;
}

unint64_t sub_1000E50E8()
{
  unint64_t result = qword_100407D50;
  if (!qword_100407D50)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for NANTimeSynchronizationFunction,  &type metadata for NANTimeSynchronizationFunction);
    atomic_store(result, (unint64_t *)&qword_100407D50);
  }

  return result;
}

unint64_t sub_1000E512C()
{
  unint64_t result = qword_100407D58;
  if (!qword_100407D58)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for NANAttribute.MasterIndication,  &type metadata for NANAttribute.MasterIndication);
    atomic_store(result, (unint64_t *)&qword_100407D58);
  }

  return result;
}

uint64_t sub_1000E5170(unint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = *a1;
  if (!result)
  {
    uint64_t v6 = sub_1000022F8(&qword_100406978);
    uint64_t result = swift_getWitnessTable(a3, v6);
    atomic_store(result, a1);
  }

  return result;
}

uint64_t sub_1000E51D0(unint64_t *a1, void (*a2)(void), uint64_t a3)
{
  uint64_t result = *a1;
  if (!result)
  {
    uint64_t v7 = sub_1000022F8(&qword_100407490);
    a2();
    uint64_t result = swift_getWitnessTable(a3, v7);
    atomic_store(result, a1);
  }

  return result;
}

unint64_t sub_1000E5238()
{
  unint64_t result = qword_100407D88;
  if (!qword_100407D88)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for AWDLActionFrame.Arpa.Flags,  &type metadata for AWDLActionFrame.Arpa.Flags);
    atomic_store(result, (unint64_t *)&qword_100407D88);
  }

  return result;
}

unint64_t sub_1000E527C()
{
  unint64_t result = qword_100407D90;
  if (!qword_100407D90)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for AWDLActionFrame.ServiceParameter.Flags,  &type metadata for AWDLActionFrame.ServiceParameter.Flags);
    atomic_store(result, (unint64_t *)&qword_100407D90);
  }

  return result;
}

unint64_t sub_1000E52C0()
{
  unint64_t result = qword_100407D98;
  if (!qword_100407D98)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for AWDLActionFrame.ServiceParameter.SSTH,  &type metadata for AWDLActionFrame.ServiceParameter.SSTH);
    atomic_store(result, (unint64_t *)&qword_100407D98);
  }

  return result;
}

unint64_t sub_1000E5304()
{
  unint64_t result = qword_100407DA8;
  if (!qword_100407DA8)
  {
    unint64_t result = swift_getWitnessTable( &unk_100345010,  &type metadata for AWDLActionFrame.DeprecatedElectionParameter.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_100407DA8);
  }

  return result;
}

unint64_t sub_1000E5348()
{
  unint64_t result = qword_100407DB8;
  if (!qword_100407DB8)
  {
    unint64_t result = swift_getWitnessTable( &unk_100344FC0,  &type metadata for AWDLActionFrame.SynchronizationParameter.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_100407DB8);
  }

  return result;
}

unint64_t sub_1000E538C()
{
  unint64_t result = qword_100407DC0;
  if (!qword_100407DC0)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for AWDLActionFrame.AWDLChannelSequenceParameter,  &type metadata for AWDLActionFrame.AWDLChannelSequenceParameter);
    atomic_store(result, (unint64_t *)&qword_100407DC0);
  }

  return result;
}

unint64_t sub_1000E53D0()
{
  unint64_t result = qword_100407DC8;
  if (!qword_100407DC8)
  {
    unint64_t result = swift_getWitnessTable( &unk_100344F98,  &type metadata for AWDLActionFrame.AWDLChannelSequenceParameter.Encoding);
    atomic_store(result, (unint64_t *)&qword_100407DC8);
  }

  return result;
}

unint64_t sub_1000E5414()
{
  unint64_t result = qword_100407DD0;
  if (!qword_100407DD0)
  {
    unint64_t result = swift_getWitnessTable( &unk_100344F70,  &type metadata for AWDLActionFrame.AWDLChannelSequenceParameter.NChannelOperatingClass);
    atomic_store(result, (unint64_t *)&qword_100407DD0);
  }

  return result;
}

unint64_t sub_1000E5458()
{
  unint64_t result = qword_100407DD8;
  if (!qword_100407DD8)
  {
    unint64_t result = swift_getWitnessTable( &unk_100344F48,  &type metadata for AWDLActionFrame.AWDLChannelSequenceParameter.Encoding);
    atomic_store(result, (unint64_t *)&qword_100407DD8);
  }

  return result;
}

unint64_t sub_1000E549C()
{
  unint64_t result = qword_100407DE0;
  if (!qword_100407DE0)
  {
    unint64_t result = swift_getWitnessTable( &unk_100344F20,  &type metadata for AWDLActionFrame.AWDLChannelSequenceParameter.NChannelOperatingClass);
    atomic_store(result, (unint64_t *)&qword_100407DE0);
  }

  return result;
}

ValueMetadata *type metadata accessor for AWDLActionFrame.AWDLChannelSequenceParameter.NChannelOperatingClass()
{
  return &type metadata for AWDLActionFrame.AWDLChannelSequenceParameter.NChannelOperatingClass;
}

uint64_t _s7CoreP2P15AWDLActionFrameV7ProModeV10CodingKeysOwst_0(_BYTE *a1, unsigned int a2, unsigned int a3)
{
  if (a3 + 3 >= 0xFFFF00) {
    int v3 = 4;
  }
  else {
    int v3 = 2;
  }
  if ((a3 + 3) >> 8 < 0xFF) {
    LODWORD(v4)  = 1;
  }
  else {
    LODWORD(v4)  = v3;
  }
  if (a3 >= 0xFD) {
    uint64_t v4 = v4;
  }
  else {
    uint64_t v4 = 0LL;
  }
  if (a2 <= 0xFC) {
    return ((uint64_t (*)(void))((char *)&loc_1000E553C + 4 * byte_100340D6D[v4]))();
  }
  *a1  = a2 + 3;
  return ((uint64_t (*)(void))((char *)sub_1000E5570 + 4 * byte_100340D68[v4]))();
}

uint64_t sub_1000E5570(uint64_t result)
{
  *(_BYTE *)(result + 1)  = v1;
  return result;
}

uint64_t sub_1000E5578(uint64_t result, int a2)
{
  *(_WORD *)(result + 1)  = 0;
  if (a2) {
    JUMPOUT(0x1000E5580LL);
  }
  return result;
}

uint64_t sub_1000E558C(uint64_t result, int a2)
{
  *(_DWORD *)(result + 1)  = 0;
  if (!a2) {
    JUMPOUT(0x1000E5594LL);
  }
  *(_BYTE *)unint64_t result = a2 + 3;
  return result;
}

uint64_t sub_1000E5598(uint64_t result)
{
  *(_DWORD *)(result + 1)  = v1;
  return result;
}

uint64_t sub_1000E55A0(uint64_t result)
{
  *(_WORD *)(result + 1)  = v1;
  return result;
}

ValueMetadata *type metadata accessor for AWDLActionFrame.AWDLChannelSequenceParameter.Encoding()
{
  return &type metadata for AWDLActionFrame.AWDLChannelSequenceParameter.Encoding;
}

uint64_t getEnumTagSinglePayload for AWDLActionFrame.SynchronizationParameter.CodingKeys( unsigned __int8 *a1, unsigned int a2)
{
  if (!a2) {
    return 0LL;
  }
  if (a2 < 0xED) {
    goto LABEL_17;
  }
  if (a2 + 19 >= 0xFFFF00) {
    int v2 = 4;
  }
  else {
    int v2 = 2;
  }
  if ((a2 + 19) >> 8 < 0xFF) {
    int v3 = 1;
  }
  else {
    int v3 = v2;
  }
  if (v3 == 4)
  {
    int v4 = *(_DWORD *)(a1 + 1);
    if (v4) {
      return (*a1 | (v4 << 8)) - 19;
    }
  }

  else
  {
    if (v3 == 2)
    {
      int v4 = *(unsigned __int16 *)(a1 + 1);
      if (!*(_WORD *)(a1 + 1)) {
        goto LABEL_17;
      }
      return (*a1 | (v4 << 8)) - 19;
    }

    int v4 = a1[1];
    if (a1[1]) {
      return (*a1 | (v4 << 8)) - 19;
    }
  }

uint64_t storeEnumTagSinglePayload for AWDLActionFrame.SynchronizationParameter.CodingKeys( _BYTE *a1, unsigned int a2, unsigned int a3)
{
  if (a3 + 19 >= 0xFFFF00) {
    int v3 = 4;
  }
  else {
    int v3 = 2;
  }
  if ((a3 + 19) >> 8 < 0xFF) {
    LODWORD(v4)  = 1;
  }
  else {
    LODWORD(v4)  = v3;
  }
  if (a3 >= 0xED) {
    uint64_t v4 = v4;
  }
  else {
    uint64_t v4 = 0LL;
  }
  if (a2 <= 0xEC) {
    return ((uint64_t (*)(void))((char *)&loc_1000E5698 + 4 * byte_100340D77[v4]))();
  }
  *a1  = a2 + 19;
  return ((uint64_t (*)(void))((char *)sub_1000E56CC + 4 * byte_100340D72[v4]))();
}

uint64_t sub_1000E56CC(uint64_t result)
{
  *(_BYTE *)(result + 1)  = v1;
  return result;
}

uint64_t sub_1000E56D4(uint64_t result, int a2)
{
  *(_WORD *)(result + 1)  = 0;
  if (a2) {
    JUMPOUT(0x1000E56DCLL);
  }
  return result;
}

uint64_t sub_1000E56E8(uint64_t result, int a2)
{
  *(_DWORD *)(result + 1)  = 0;
  if (!a2) {
    JUMPOUT(0x1000E56F0LL);
  }
  *(_BYTE *)unint64_t result = a2 + 19;
  return result;
}

uint64_t sub_1000E56F4(uint64_t result)
{
  *(_DWORD *)(result + 1)  = v1;
  return result;
}

uint64_t sub_1000E56FC(uint64_t result)
{
  *(_WORD *)(result + 1)  = v1;
  return result;
}

ValueMetadata *type metadata accessor for AWDLActionFrame.SynchronizationParameter.CodingKeys()
{
  return &type metadata for AWDLActionFrame.SynchronizationParameter.CodingKeys;
}

uint64_t getEnumTagSinglePayload for IEEE80211Frame.Management.ActionFrame.Category( unsigned __int8 *a1, unsigned int a2)
{
  if (!a2) {
    return 0LL;
  }
  if (a2 < 0xFA) {
    goto LABEL_17;
  }
  if (a2 + 6 >= 0xFFFF00) {
    int v2 = 4;
  }
  else {
    int v2 = 2;
  }
  if ((a2 + 6) >> 8 < 0xFF) {
    int v3 = 1;
  }
  else {
    int v3 = v2;
  }
  if (v3 == 4)
  {
    int v4 = *(_DWORD *)(a1 + 1);
    if (v4) {
      return (*a1 | (v4 << 8)) - 6;
    }
  }

  else
  {
    if (v3 == 2)
    {
      int v4 = *(unsigned __int16 *)(a1 + 1);
      if (!*(_WORD *)(a1 + 1)) {
        goto LABEL_17;
      }
      return (*a1 | (v4 << 8)) - 6;
    }

    int v4 = a1[1];
    if (a1[1]) {
      return (*a1 | (v4 << 8)) - 6;
    }
  }

uint64_t _s7CoreP2P15AWDLActionFrameV20MultiPeerBSSSteeringV17SteeringMessageIDOwst_0( _BYTE *a1, unsigned int a2, unsigned int a3)
{
  if (a3 + 6 >= 0xFFFF00) {
    int v3 = 4;
  }
  else {
    int v3 = 2;
  }
  if ((a3 + 6) >> 8 < 0xFF) {
    LODWORD(v4)  = 1;
  }
  else {
    LODWORD(v4)  = v3;
  }
  if (a3 >= 0xFA) {
    uint64_t v4 = v4;
  }
  else {
    uint64_t v4 = 0LL;
  }
  if (a2 <= 0xF9) {
    return ((uint64_t (*)(void))((char *)&loc_1000E57F4 + 4 * byte_100340D81[v4]))();
  }
  *a1  = a2 + 6;
  return ((uint64_t (*)(void))((char *)sub_1000E5828 + 4 * byte_100340D7C[v4]))();
}

uint64_t sub_1000E5828(uint64_t result)
{
  *(_BYTE *)(result + 1)  = v1;
  return result;
}

uint64_t sub_1000E5830(uint64_t result, int a2)
{
  *(_WORD *)(result + 1)  = 0;
  if (a2) {
    JUMPOUT(0x1000E5838LL);
  }
  return result;
}

uint64_t sub_1000E5844(uint64_t result, int a2)
{
  *(_DWORD *)(result + 1)  = 0;
  if (!a2) {
    JUMPOUT(0x1000E584CLL);
  }
  *(_BYTE *)unint64_t result = a2 + 6;
  return result;
}

uint64_t sub_1000E5850(uint64_t result)
{
  *(_DWORD *)(result + 1)  = v1;
  return result;
}

uint64_t sub_1000E5858(uint64_t result)
{
  *(_WORD *)(result + 1)  = v1;
  return result;
}

ValueMetadata *type metadata accessor for AWDLActionFrame.DeprecatedElectionParameter.CodingKeys()
{
  return &type metadata for AWDLActionFrame.DeprecatedElectionParameter.CodingKeys;
}

unint64_t sub_1000E5878()
{
  unint64_t result = qword_100407DF8;
  if (!qword_100407DF8)
  {
    unint64_t result = swift_getWitnessTable( &unk_100344C10,  &type metadata for AWDLActionFrame.DeprecatedElectionParameter.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_100407DF8);
  }

  return result;
}

unint64_t sub_1000E58C0()
{
  unint64_t result = qword_100407E00;
  if (!qword_100407E00)
  {
    unint64_t result = swift_getWitnessTable( &unk_100344CC8,  &type metadata for AWDLActionFrame.SynchronizationParameter.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_100407E00);
  }

  return result;
}

unint64_t sub_1000E5908()
{
  unint64_t result = qword_100407E08;
  if (!qword_100407E08)
  {
    unint64_t result = swift_getWitnessTable( &unk_100344D68,  &type metadata for AWDLActionFrame.AWDLChannelSequenceParameter.Encoding);
    atomic_store(result, (unint64_t *)&qword_100407E08);
  }

  return result;
}

unint64_t sub_1000E5950()
{
  unint64_t result = qword_100407E10;
  if (!qword_100407E10)
  {
    unint64_t result = swift_getWitnessTable( &unk_100344DC0,  &type metadata for AWDLActionFrame.AWDLChannelSequenceParameter.NChannelOperatingClass);
    atomic_store(result, (unint64_t *)&qword_100407E10);
  }

  return result;
}

unint64_t sub_1000E5998()
{
  unint64_t result = qword_100407E18;
  if (!qword_100407E18)
  {
    unint64_t result = swift_getWitnessTable( &unk_100344D90,  &type metadata for AWDLActionFrame.AWDLChannelSequenceParameter.NChannelOperatingClass);
    atomic_store(result, (unint64_t *)&qword_100407E18);
  }

  return result;
}

unint64_t sub_1000E59E0()
{
  unint64_t result = qword_100407E20;
  if (!qword_100407E20)
  {
    unint64_t result = swift_getWitnessTable( &unk_100344DE8,  &type metadata for AWDLActionFrame.AWDLChannelSequenceParameter.NChannelOperatingClass);
    atomic_store(result, (unint64_t *)&qword_100407E20);
  }

  return result;
}

unint64_t sub_1000E5A28()
{
  unint64_t result = qword_100407E28;
  if (!qword_100407E28)
  {
    unint64_t result = swift_getWitnessTable( &unk_100344E20,  &type metadata for AWDLActionFrame.AWDLChannelSequenceParameter.NChannelOperatingClass);
    atomic_store(result, (unint64_t *)&qword_100407E28);
  }

  return result;
}

unint64_t sub_1000E5A70()
{
  unint64_t result = qword_100407E30;
  if (!qword_100407E30)
  {
    unint64_t result = swift_getWitnessTable( &unk_100344C38,  &type metadata for AWDLActionFrame.SynchronizationParameter.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_100407E30);
  }

  return result;
}

unint64_t sub_1000E5AB8()
{
  unint64_t result = qword_100407E38;
  if (!qword_100407E38)
  {
    unint64_t result = swift_getWitnessTable( &unk_100344C60,  &type metadata for AWDLActionFrame.SynchronizationParameter.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_100407E38);
  }

  return result;
}

unint64_t sub_1000E5B00()
{
  unint64_t result = qword_100407E40;
  if (!qword_100407E40)
  {
    unint64_t result = swift_getWitnessTable( &unk_100344B80,  &type metadata for AWDLActionFrame.DeprecatedElectionParameter.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_100407E40);
  }

  return result;
}

unint64_t sub_1000E5B48()
{
  unint64_t result = qword_100407E48;
  if (!qword_100407E48)
  {
    unint64_t result = swift_getWitnessTable( &unk_100344BA8,  &type metadata for AWDLActionFrame.DeprecatedElectionParameter.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_100407E48);
  }

  return result;
}

unint64_t sub_1000E5B8C()
{
  unint64_t result = qword_100407E50;
  if (!qword_100407E50)
  {
    unint64_t result = swift_getWitnessTable( &unk_100344CF0,  &type metadata for AWDLActionFrame.AWDLChannelSequenceParameter.Encoding);
    atomic_store(result, (unint64_t *)&qword_100407E50);
  }

  return result;
}

uint64_t NANAwakeDWInterval.interval.getter(char a1)
{
  return qword_1003453C8[a1];
}

CoreP2P::NANAwakeDWInterval_optional __swiftcall NANAwakeDWInterval.init(numberString:)(Swift::String numberString)
{
  object  = numberString._object;
  countAndFlagsBits  = numberString._countAndFlagsBits;
  if (numberString._countAndFlagsBits == 48 && numberString._object == (void *)0xE100000000000000LL)
  {
    unint64_t v3 = 0xE100000000000000LL;
LABEL_6:
    swift_bridgeObjectRelease(v3);
    return 0;
  }

  if ((_stringCompareWithSmolCheck(_:_:expecting:)( 48LL,  0xE100000000000000LL,  numberString._countAndFlagsBits,  numberString._object,  0LL) & 1) != 0)
  {
    unint64_t v3 = (unint64_t)object;
    goto LABEL_6;
  }

  if (countAndFlagsBits == 49 && object == (void *)0xE100000000000000LL)
  {
    unint64_t v5 = 0xE100000000000000LL;
LABEL_12:
    swift_bridgeObjectRelease(v5);
    return (CoreP2P::NANAwakeDWInterval_optional)1;
  }

  if ((_stringCompareWithSmolCheck(_:_:expecting:)(49LL, 0xE100000000000000LL, countAndFlagsBits, object, 0LL) & 1) != 0)
  {
    unint64_t v5 = (unint64_t)object;
    goto LABEL_12;
  }

  if (countAndFlagsBits == 52 && object == (void *)0xE100000000000000LL)
  {
    unint64_t v6 = 0xE100000000000000LL;
LABEL_18:
    swift_bridgeObjectRelease(v6);
    return (CoreP2P::NANAwakeDWInterval_optional)2;
  }

  if ((_stringCompareWithSmolCheck(_:_:expecting:)(52LL, 0xE100000000000000LL, countAndFlagsBits, object, 0LL) & 1) != 0)
  {
    unint64_t v6 = (unint64_t)object;
    goto LABEL_18;
  }

  if (countAndFlagsBits == 56 && object == (void *)0xE100000000000000LL)
  {
    unint64_t v7 = 0xE100000000000000LL;
LABEL_24:
    swift_bridgeObjectRelease(v7);
    return (CoreP2P::NANAwakeDWInterval_optional)3;
  }

  if ((_stringCompareWithSmolCheck(_:_:expecting:)(56LL, 0xE100000000000000LL, countAndFlagsBits, object, 0LL) & 1) != 0)
  {
    unint64_t v7 = (unint64_t)object;
    goto LABEL_24;
  }

  if (countAndFlagsBits == 13873 && object == (void *)0xE200000000000000LL)
  {
    swift_bridgeObjectRelease(0xE200000000000000LL);
    return (CoreP2P::NANAwakeDWInterval_optional)4;
  }

  else
  {
    char v8 = _stringCompareWithSmolCheck(_:_:expecting:)(13873LL, 0xE200000000000000LL, countAndFlagsBits, object, 0LL);
    swift_bridgeObjectRelease(object);
    if ((v8 & 1) != 0) {
      return (CoreP2P::NANAwakeDWInterval_optional)4;
    }
    else {
      return (CoreP2P::NANAwakeDWInterval_optional)5;
    }
  }

void *NANAwakeDWInterval.defaultValue.unsafeMutableAddressor()
{
  return &static NANAwakeDWInterval.defaultValue;
}

uint64_t NANAwakeDWInterval.rawValue.getter(unsigned __int8 a1)
{
  return ((uint64_t (*)(uint64_t, unint64_t))((char *)sub_1000E5E2C + 4 * byte_100345180[a1]))( 1869768058LL,  0xE400000000000000LL);
}

uint64_t sub_1000E5E2C()
{
  return 6647407LL;
}

uint64_t sub_1000E5E3C()
{
  return 1920298854LL;
}

uint64_t sub_1000E5E48()
{
  return 0x7468676965LL;
}

uint64_t sub_1000E5E5C()
{
  return 0x6E656574786973LL;
}

uint64_t sub_1000E5E74(unsigned __int8 *a1, unsigned __int8 *a2)
{
  return sub_10002A720(*a1, *a2);
}

unint64_t sub_1000E5E80@<X0>(Swift::String *a1@<X0>, _BYTE *a2@<X8>)
{
  unint64_t result = _s7CoreP2P18NANAwakeDWIntervalO8rawValueACSgSS_tcfC_0(*a1);
  *a2  = result;
  return result;
}

uint64_t sub_1000E5EAC()
{
  return ((uint64_t (*)(void))((char *)sub_1000E5ED4 + 4 * byte_100345185[*v0]))();
}

void sub_1000E5ED4(void *a1@<X8>)
{
  *a1  = 6647407LL;
  a1[1]  = 0xE300000000000000LL;
}

void sub_1000E5EE8(void *a1@<X8>)
{
  *a1  = 1920298854LL;
  a1[1]  = v1;
}

void sub_1000E5EF8(void *a1@<X8>)
{
  *a1  = 0x7468676965LL;
  a1[1]  = 0xE500000000000000LL;
}

void sub_1000E5F10(void *a1@<X8>)
{
  *a1  = 0x6E656574786973LL;
  a1[1]  = 0xE700000000000000LL;
}

void sub_1000E5F2C()
{
  uint64_t v1 = *v0;
  Hasher.init(_seed:)(v2, 0LL);
  __asm { BR              X9 }

Swift::Int sub_1000E5F70()
{
  return Hasher._finalize()();
}

void sub_1000E5FE0()
{
  __asm { BR              X10 }

uint64_t sub_1000E6014(uint64_t a1)
{
  return swift_bridgeObjectRelease(0xE300000000000000LL);
}

void sub_1000E6070(uint64_t a1)
{
  uint64_t v2 = *v1;
  Hasher.init(_seed:)(v3, a1);
  __asm { BR              X9 }

Swift::Int sub_1000E60B0()
{
  return Hasher._finalize()();
}

uint64_t sub_1000E6120(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v6 = sub_1000E6B40();
  return RawRepresentable<>.init(from:)(a1, a2, a3, v6);
}

uint64_t sub_1000E617C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v6 = sub_1000E6B40();
  return RawRepresentable<>.encode(to:)(a1, a2, a3, v6);
}

uint64_t NANAwakeDWInterval.description.getter(unsigned __int8 a1)
{
  return ((uint64_t (*)(uint64_t, unint64_t))((char *)sub_1000E61F4 + 4 * byte_100345199[a1]))( 1869768058LL,  0xE400000000000000LL);
}

uint64_t sub_1000E61F4()
{
  return 6647407LL;
}

uint64_t sub_1000E6204()
{
  return 1920298854LL;
}

uint64_t sub_1000E6210()
{
  return 0x7468676965LL;
}

uint64_t sub_1000E6224()
{
  return 0x6E656574786973LL;
}

uint64_t NANAwakeDWInterval.customMirror.getter(char a1)
{
  uint64_t v2 = type metadata accessor for Mirror.AncestorRepresentation(0LL);
  uint64_t v3 = *(void *)(v2 - 8);
  __chkstk_darwin(v2);
  unint64_t v5 = &v14[-((v4 + 15) & 0xFFFFFFFFFFFFFFF0LL)];
  uint64_t v6 = sub_100002274((uint64_t *)&unk_100408800);
  __chkstk_darwin(v6);
  char v8 = &v14[-((v7 + 15) & 0xFFFFFFFFFFFFFFF0LL)];
  char v15 = a1;
  uint64_t v9 = sub_100002274(qword_100405EA0);
  uint64_t v10 = swift_allocObject(v9, 80LL, 7LL);
  *(_OWORD *)(v10 + 16)  = xmmword_100339900;
  *(void *)(v10 + 32)  = 0x6C61767265746E69LL;
  *(void *)(v10 + 40)  = 0xE800000000000000LL;
  uint64_t v11 = qword_1003453C8[a1];
  *(void *)(v10 + 72)  = &type metadata for NANTimeUnit;
  *(void *)(v10 + 48)  = v11;
  uint64_t v12 = type metadata accessor for Mirror.DisplayStyle(0LL);
  (*(void (**)(_BYTE *, uint64_t, uint64_t, uint64_t))(*(void *)(v12 - 8) + 56LL))(v8, 1LL, 1LL, v12);
  (*(void (**)(_BYTE *, void, uint64_t))(v3 + 104))( v5,  enum case for Mirror.AncestorRepresentation.generated(_:),  v2);
  return Mirror.init<A>(_:children:displayStyle:ancestorRepresentation:)( &v15,  v10,  v8,  v5,  &type metadata for NANAwakeDWInterval);
}

uint64_t sub_1000E63B0()
{
  return ((uint64_t (*)(uint64_t, unint64_t))((char *)sub_1000E63D8 + 4 * byte_10034519E[*v0]))( 1869768058LL,  0xE400000000000000LL);
}

uint64_t sub_1000E63D8()
{
  return 6647407LL;
}

uint64_t sub_1000E63E8()
{
  return 1920298854LL;
}

uint64_t sub_1000E63F4()
{
  return 0x7468676965LL;
}

uint64_t sub_1000E6408()
{
  return 0x6E656574786973LL;
}

uint64_t sub_1000E6420()
{
  return NANAwakeDWInterval.customMirror.getter(*v0);
}

void NANAwakeDWPeriods.hash(into:)(uint64_t a1, char a2)
{
  __asm { BR              X10 }

uint64_t sub_1000E646C(uint64_t a1, __int16 a2)
{
  uint64_t v3 = HIBYTE(a2);
  String.hash(into:)(v2, 6647407LL, 0xE300000000000000LL);
  uint64_t v4 = swift_bridgeObjectRelease(0xE300000000000000LL);
  return ((uint64_t (*)(uint64_t))((char *)sub_1000E64E8 + 4 * byte_1003451A8[v3]))(v4);
}

uint64_t sub_1000E64E8()
{
  return swift_bridgeObjectRelease(0xE300000000000000LL);
}

void static NANAwakeDWPeriods.__derived_struct_equals(_:_:)(char a1)
{
  __asm { BR              X10 }

uint64_t sub_1000E659C()
{
  return ((uint64_t (*)(uint64_t))((char *)sub_1000E6600 + 4 * byte_1003451B2[v0]))(6647407LL);
}

uint64_t sub_1000E6600(uint64_t a1)
{
  if (a1 == 6647407 && v3 == 0xE300000000000000LL)
  {
    swift_bridgeObjectRelease_n(0xE300000000000000LL, 2LL);
    return sub_10002A720(HIBYTE(v1), HIBYTE(v2));
  }

  char v4 = _stringCompareWithSmolCheck(_:_:expecting:)(a1, v3, 6647407LL, 0xE300000000000000LL, 0LL);
  swift_bridgeObjectRelease(v3);
  swift_bridgeObjectRelease(0xE300000000000000LL);
  if ((v4 & 1) != 0) {
    return sub_10002A720(HIBYTE(v1), HIBYTE(v2));
  }
  return 0LL;
}

Swift::Int NANAwakeDWPeriods.hashValue.getter(char a1)
{
  return Hasher._finalize()();
}

Swift::Int sub_1000E6718()
{
  __int16 v1 = *v0;
  Hasher.init(_seed:)(v3, 0LL);
  NANAwakeDWPeriods.hash(into:)((uint64_t)v3, v1);
  return Hasher._finalize()();
}

void sub_1000E675C(uint64_t a1)
{
}

Swift::Int sub_1000E6764(uint64_t a1)
{
  __int16 v2 = *v1;
  Hasher.init(_seed:)(v4, a1);
  NANAwakeDWPeriods.hash(into:)((uint64_t)v4, v2);
  return Hasher._finalize()();
}

uint64_t sub_1000E67A4(unsigned __int8 *a1, unsigned __int8 *a2)
{
  uint64_t v2 = a1[1];
  uint64_t v3 = a2[1];
  if ((sub_10002A720(*a1, *a2) & 1) != 0) {
    return sub_10002A720(v2, v3);
  }
  else {
    return 0LL;
  }
}

unint64_t _s7CoreP2P18NANAwakeDWIntervalO8rawValueACSgSS_tcfC_0(Swift::String string)
{
  object  = string._object;
  v2._countAndFlagsBits  = string._countAndFlagsBits;
  v2._object  = object;
  unint64_t v3 = _findStringSwitchCase(cases:string:)((Swift::OpaquePointer)&off_1003D62E8, v2);
  swift_bridgeObjectRelease(object);
  if (v3 >= 5) {
    return 5LL;
  }
  else {
    return v3;
  }
}

uint64_t _s7CoreP2P18NANAwakeDWIntervalO8intervalACSgAA11NANTimeUnitV_tcfC_0(uint64_t a1)
{
  uint64_t result = 0LL;
  switch(a1)
  {
    case 0LL:
      return result;
    case 1LL:
      uint64_t result = 1LL;
      break;
    case 4LL:
      uint64_t result = 2LL;
      break;
    case 8LL:
      uint64_t result = 3LL;
      break;
    case 16LL:
      uint64_t result = 4LL;
      break;
    default:
      uint64_t result = 5LL;
      break;
  }

  return result;
}

unint64_t sub_1000E6888()
{
  unint64_t result = qword_100407E58;
  if (!qword_100407E58)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for NANAwakeDWInterval,  &type metadata for NANAwakeDWInterval);
    atomic_store(result, (unint64_t *)&qword_100407E58);
  }

  return result;
}

unint64_t sub_1000E68D0()
{
  unint64_t result = qword_100407E60;
  if (!qword_100407E60)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for NANAwakeDWPeriods,  &type metadata for NANAwakeDWPeriods);
    atomic_store(result, (unint64_t *)&qword_100407E60);
  }

  return result;
}

uint64_t storeEnumTagSinglePayload for NANAwakeDWInterval(_BYTE *a1, unsigned int a2, unsigned int a3)
{
  if (a3 + 4 >= 0xFFFF00) {
    int v3 = 4;
  }
  else {
    int v3 = 2;
  }
  if ((a3 + 4) >> 8 < 0xFF) {
    LODWORD(v4)  = 1;
  }
  else {
    LODWORD(v4)  = v3;
  }
  if (a3 >= 0xFC) {
    uint64_t v4 = v4;
  }
  else {
    uint64_t v4 = 0LL;
  }
  if (a2 <= 0xFB) {
    return ((uint64_t (*)(void))((char *)&loc_1000E6960 + 4 * byte_1003451CD[v4]))();
  }
  *a1  = a2 + 4;
  return ((uint64_t (*)(void))((char *)sub_1000E6994 + 4 * byte_1003451C8[v4]))();
}

uint64_t sub_1000E6994(uint64_t result)
{
  *(_BYTE *)(result + 1)  = v1;
  return result;
}

uint64_t sub_1000E699C(uint64_t result, int a2)
{
  *(_WORD *)(result + 1)  = 0;
  if (a2) {
    JUMPOUT(0x1000E69A4LL);
  }
  return result;
}

uint64_t sub_1000E69B0(uint64_t result, int a2)
{
  *(_DWORD *)(result + 1)  = 0;
  if (!a2) {
    JUMPOUT(0x1000E69B8LL);
  }
  *(_BYTE *)unint64_t result = a2 + 4;
  return result;
}

uint64_t sub_1000E69BC(uint64_t result)
{
  *(_DWORD *)(result + 1)  = v1;
  return result;
}

uint64_t sub_1000E69C4(uint64_t result)
{
  *(_WORD *)(result + 1)  = v1;
  return result;
}

ValueMetadata *type metadata accessor for NANAwakeDWInterval()
{
  return &type metadata for NANAwakeDWInterval;
}

uint64_t getEnumTagSinglePayload for NANAwakeDWPeriods(unsigned __int16 *a1, unsigned int a2)
{
  if (!a2) {
    return 0LL;
  }
  if (a2 < 0xFC) {
    goto LABEL_17;
  }
  if (a2 + 65284 <= 0xFFFEFFFF) {
    int v2 = 2;
  }
  else {
    int v2 = 4;
  }
  if (a2 + 65284 < 0xFF0000) {
    int v3 = 1;
  }
  else {
    int v3 = v2;
  }
  if (v3 == 4)
  {
    int v4 = *(_DWORD *)(a1 + 1);
    if (v4) {
      return (*a1 | (v4 << 16)) - 65284;
    }
  }

  else
  {
    if (v3 == 2)
    {
      int v4 = a1[1];
      if (!a1[1]) {
        goto LABEL_17;
      }
      return (*a1 | (v4 << 16)) - 65284;
    }

    int v4 = *((unsigned __int8 *)a1 + 2);
    if (*((_BYTE *)a1 + 2)) {
      return (*a1 | (v4 << 16)) - 65284;
    }
  }

uint64_t storeEnumTagSinglePayload for NANAwakeDWPeriods(_WORD *a1, unsigned int a2, unsigned int a3)
{
  if (a3 + 65284 <= 0xFFFEFFFF) {
    int v3 = 2;
  }
  else {
    int v3 = 4;
  }
  if (a3 + 65284 < 0xFF0000) {
    LODWORD(v4)  = 1;
  }
  else {
    LODWORD(v4)  = v3;
  }
  if (a3 >= 0xFC) {
    uint64_t v4 = v4;
  }
  else {
    uint64_t v4 = 0LL;
  }
  if (a2 <= 0xFB) {
    return ((uint64_t (*)(void))((char *)&loc_1000E6AC0 + 4 * byte_1003451D7[v4]))();
  }
  *a1  = a2 - 252;
  return ((uint64_t (*)(void))((char *)sub_1000E6AF4 + 4 * byte_1003451D2[v4]))();
}

uint64_t sub_1000E6AF4(uint64_t result)
{
  *(_BYTE *)(result + 2)  = v1;
  return result;
}

uint64_t sub_1000E6AFC(uint64_t result, int a2)
{
  *(_WORD *)(result + 2)  = 0;
  if (a2) {
    JUMPOUT(0x1000E6B04LL);
  }
  return result;
}

uint64_t sub_1000E6B10(uint64_t result, int a2)
{
  *(_DWORD *)(result + 2)  = 0;
  if (!a2) {
    JUMPOUT(0x1000E6B18LL);
  }
  *(_BYTE *)unint64_t result = a2 + 4;
  return result;
}

uint64_t sub_1000E6B1C(uint64_t result)
{
  *(_DWORD *)(result + 2)  = v1;
  return result;
}

uint64_t sub_1000E6B24(uint64_t result)
{
  *(_WORD *)(result + 2)  = v1;
  return result;
}

ValueMetadata *type metadata accessor for NANAwakeDWPeriods()
{
  return &type metadata for NANAwakeDWPeriods;
}

unint64_t sub_1000E6B40()
{
  unint64_t result = qword_100407E68;
  if (!qword_100407E68)
  {
    unint64_t result = swift_getWitnessTable( &protocol conformance descriptor for NANAwakeDWInterval,  &type metadata for NANAwakeDWInterval);
    atomic_store(result, (unint64_t *)&qword_100407E68);
  }

  return result;
}

uint64_t sub_1000E6B88(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v7 = a1[5];
  uint64_t v8 = swift_unownedRetain(v7);
  uint64_t v10 = a1[2];
  uint64_t v9 = a1[3];
  swift_unownedRetainStrong(v8);
  swift_bridgeObjectRetain_n(v9, 2LL);
  AppleDevice.startMonitoringEvents(on:eventHandler:)(v10, v9, a2, a3);
  swift_release(v7);
  swift_release(a1);
  swift_release(a3);
  swift_bridgeObjectRelease(v9);
  if (v3)
  {
    swift_unownedRelease(v7);
    swift_bridgeObjectRelease(v9);
  }

  return v7;
}

uint64_t _s7CoreP2P6DevicePAAE12customMirrors0E0Vvg_0(uint64_t a1)
{
  uint64_t v3 = type metadata accessor for Mirror.AncestorRepresentation(0LL);
  uint64_t v4 = *(void *)(v3 - 8);
  __chkstk_darwin(v3);
  unsigned int v6 = (char *)&v18 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v7 = sub_100002274((uint64_t *)&unk_100408800);
  uint64_t v8 = __chkstk_darwin(v7);
  uint64_t v10 = (char *)&v18 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  __chkstk_darwin(v8);
  uint64_t v12 = (char *)&v18 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  (*(void (**)(char *, uint64_t, uint64_t))(v13 + 16))(v12, v1, a1);
  unint64_t v19 = _swiftEmptyArrayStorage;
  uint64_t v14 = type metadata accessor for Mirror.DisplayStyle(0LL);
  (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(*(void *)(v14 - 8) + 56LL))(v10, 1LL, 1LL, v14);
  uint64_t v15 = sub_100002274(&qword_100405DC0);
  unint64_t v16 = sub_10005CFF4();
  (*(void (**)(char *, void, uint64_t))(v4 + 104))( v6,  enum case for Mirror.AncestorRepresentation.generated(_:),  v3);
  return Mirror.init<A, B>(_:children:displayStyle:ancestorRepresentation:)(v12, &v19, v10, v6, a1, v15, v16);
}

uint64_t sub_1000E6DCC@<X0>(uint64_t a1@<X8>)
{
  uint64_t v2 = enum case for Mirror.AncestorRepresentation.generated(_:);
  uint64_t v3 = type metadata accessor for Mirror.AncestorRepresentation(0LL);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v3 - 8) + 104LL))(a1, v2, v3);
}

uint64_t sub_1000E6E10(uint64_t a1, uint64_t a2)
{
  return sub_1000E6E48( a1,  a2,  &OBJC_IVAR____TtC7CoreP2P18AppleIO80211Driver_logger,  (uint64_t)&unk_1003E3B40,  (uint64_t)sub_1000E76E4);
}

uint64_t sub_1000E6E48(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v31 = a1;
  uint64_t v10 = type metadata accessor for Logger(0LL);
  uint64_t v11 = *(void *)(v10 - 8);
  uint64_t v12 = *(void *)(v11 + 64);
  __chkstk_darwin(v10);
  uint64_t v13 = (char *)&v30 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  __n128 v14 = swift_beginAccess(v5 + 48, v33, 1LL, 0LL);
  if (*((void *)v5 + 8))
  {
    unint64_t v15 = sub_1000033FC();
    uint64_t v16 = swift_allocError(&type metadata for WiFiError, v15, 0LL, 0LL);
    *(_OWORD *)uint64_t v17 = xmmword_1003453F0;
    *(_BYTE *)(v17 + 16)  = 1;
    return swift_willThrow(v16);
  }

  else
  {
    (*(void (**)(char *, char *, uint64_t, __n128))(v11 + 16))( (char *)&v30 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL),  &v5[*a3],  v10,  v14);
    uint64_t v19 = *(unsigned __int8 *)(v11 + 80);
    uint64_t v30 = a5;
    uint64_t v20 = (v19 + 16) & ~v19;
    unint64_t v21 = (v12 + v20 + 7) & 0xFFFFFFFFFFFFFFF8LL;
    uint64_t v22 = swift_allocObject(a4, v21 + 16, v19 | 7);
    (*(void (**)(uint64_t, char *, uint64_t))(v11 + 32))(v22 + v20, v13, v10);
    unint64_t v23 = (void *)(v22 + v21);
    void *v23 = v31;
    v23[1]  = a2;
    swift_retain();
    swift_retain();
    uint64_t v24 = v32;
    uint64_t result = sub_1000E6B88(v5, v30, v22);
    if (!v24)
    {
      uint64_t v27 = *((void *)v5 + 6);
      uint64_t v28 = *((void *)v5 + 7);
      uint64_t v29 = *((void *)v5 + 8);
      *((void *)v5 + 6)  = result;
      *((void *)v5 + 7)  = v25;
      *((void *)v5 + 8)  = v26;
      return sub_1000A9C2C(v27, v28, v29);
    }
  }

  return result;
}

uint64_t DeviceDriver.startMonitoringEvents(_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v51 = a2;
  uint64_t v50 = a1;
  uint64_t v7 = type metadata accessor for Logger(0LL);
  uint64_t v53 = *(void *)(v7 - 8);
  uint64_t v54 = v7;
  uint64_t v8 = *(void *)(v53 + 64);
  uint64_t v9 = __chkstk_darwin(v7);
  uint64_t v48 = (char *)&v45 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v10 = __chkstk_darwin(v9);
  uint64_t v57 = (char *)&v45 - v11;
  uint64_t v47 = *(void *)(a3 - 8);
  __chkstk_darwin(v10);
  uint64_t v56 = (char *)&v45 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  a4,  a3,  &protocol requirements base descriptor for DeviceDriver);
  uint64_t v14 = type metadata accessor for Optional(0LL, AssociatedTypeWitness);
  uint64_t v15 = *(void *)(v14 - 8);
  uint64_t v16 = __chkstk_darwin(v14);
  int v49 = (char *)&v45 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  __chkstk_darwin(v16);
  uint64_t v19 = (char *)&v45 - v18;
  uint64_t v20 = *(void (**)(uint64_t, uint64_t))(a4 + 64);
  uint64_t v21 = v4;
  uint64_t v55 = a4;
  v20(a3, a4);
  uint64_t v22 = *(void *)(AssociatedTypeWitness - 8);
  int v23 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(v22 + 48))(v19, 1LL, AssociatedTypeWitness);
  (*(void (**)(char *, uint64_t))(v15 + 8))(v19, v14);
  if (v23 == 1)
  {
    uint64_t v46 = v22;
    uint64_t v24 = v21;
    (*(void (**)(char *, uint64_t, uint64_t))(v47 + 16))(v56, v21, a3);
    uint64_t v25 = v55;
    uint64_t v26 = *(void (**)(uint64_t))(*(void *)(v55 + 8) + 8LL);
    uint64_t v27 = v57;
    uint64_t v47 = v24;
    v26(a3);
    uint64_t v29 = v53;
    uint64_t v28 = v54;
    uint64_t v30 = v48;
    (*(void (**)(char *, char *, uint64_t))(v53 + 16))(v48, v27, v54);
    uint64_t v31 = *(unsigned __int8 *)(v29 + 80);
    uint64_t v32 = (v31 + 16) & ~v31;
    unint64_t v33 = (v8 + v32 + 7) & 0xFFFFFFFFFFFFFFF8LL;
    uint64_t v34 = swift_allocObject(&unk_1003E3AF0, v33 + 16, v31 | 7);
    (*(void (**)(uint64_t, char *, uint64_t))(v29 + 32))(v34 + v32, v30, v28);
    uint64_t v35 = (void *)(v34 + v33);
    uint64_t v36 = v51;
    *uint64_t v35 = v50;
    v35[1]  = v36;
    uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v25,  a3,  AssociatedTypeWitness,  &protocol requirements base descriptor for DeviceDriver,  &associated conformance descriptor for DeviceDriver.DeviceDriver.EventSource: DriverEventSource);
    uint64_t v38 = *(void (**)(char *, uint64_t (*)(), uint64_t, uint64_t, uint64_t))(AssociatedConformanceWitness
                                                                                             + 32);
    swift_retain();
    uint64_t v39 = v49;
    uint64_t v40 = v52;
    v38(v56, sub_1000E76E4, v34, AssociatedTypeWitness, AssociatedConformanceWitness);
    if (v40)
    {
      return (*(uint64_t (**)(char *, uint64_t))(v29 + 8))(v57, v28);
    }

    else
    {
      (*(void (**)(char *, uint64_t))(v29 + 8))(v57, v28);
      (*(void (**)(char *, void, uint64_t, uint64_t))(v46 + 56))(v39, 0LL, 1LL, AssociatedTypeWitness);
      return (*(uint64_t (**)(char *, uint64_t, uint64_t))(v25 + 72))(v39, a3, v25);
    }
  }

  else
  {
    unint64_t v42 = sub_1000033FC();
    uint64_t v43 = swift_allocError(&type metadata for WiFiError, v42, 0LL, 0LL);
    *(_OWORD *)uint64_t v44 = xmmword_1003453F0;
    *(_BYTE *)(v44 + 16)  = 1;
    return swift_willThrow(v43);
  }

uint64_t DeviceDriver.init(device:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v26 = a4;
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  a3,  a2,  &protocol requirements base descriptor for DeviceDriver);
  uint64_t v8 = *(void *)(AssociatedTypeWitness - 8);
  __chkstk_darwin(AssociatedTypeWitness);
  uint64_t v10 = (char *)&v24 - v9;
  uint64_t v25 = type metadata accessor for Optional(0LL, a2);
  uint64_t v11 = *(void *)(v25 - 8);
  __chkstk_darwin(v25);
  uint64_t v13 = (char *)&v24 - v12;
  unint64_t v14 = sub_1002136D8();
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a3,  a2,  AssociatedTypeWitness,  &protocol requirements base descriptor for DeviceDriver,  &associated conformance descriptor for DeviceDriver.DeviceDriver.Device: Device);
  uint64_t v16 = (*(uint64_t (**)(void, void, unint64_t, unint64_t, uint64_t, uint64_t))(AssociatedConformanceWitness + 72))( 0LL,  0LL,  0xE000000000000000LL,  v14 & 0xFFFFFFFFFFFCLL | 2,  AssociatedTypeWitness,  AssociatedConformanceWitness);
  if (v17)
  {
    uint64_t v18 = v16;
    uint64_t v19 = v17;
    (*(void (**)(char *, uint64_t, uint64_t))(v8 + 16))(v10, a1, AssociatedTypeWitness);
    (*(void (**)(char *, void, uint64_t, uint64_t, uint64_t, uint64_t))(a3 + 48))(v10, 0LL, v18, v19, a2, a3);
    (*(void (**)(uint64_t, uint64_t))(v8 + 8))(a1, AssociatedTypeWitness);
    uint64_t v20 = *(void *)(a2 - 8);
    if (!(*(unsigned int (**)(char *, uint64_t, uint64_t))(v20 + 48))(v13, 1LL, a2))
    {
      uint64_t v22 = v26;
      (*(void (**)(uint64_t, char *, uint64_t))(v20 + 32))(v26, v13, a2);
      uint64_t v21 = 0LL;
      return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v20 + 56))(v22, v21, 1LL, a2);
    }

    (*(void (**)(char *, uint64_t))(v11 + 8))(v13, v25);
  }

  else
  {
    (*(void (**)(uint64_t, uint64_t))(v8 + 8))(a1, AssociatedTypeWitness);
    uint64_t v20 = *(void *)(a2 - 8);
  }

  uint64_t v21 = 1LL;
  uint64_t v22 = v26;
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v20 + 56))(v22, v21, 1LL, a2);
}

uint64_t sub_1000E7528(uint64_t a1, uint64_t a2, uint64_t (*a3)(uint64_t), uint64_t a4)
{
  uint64_t v7 = type metadata accessor for DriverEvent(0LL);
  __chkstk_darwin(v7);
  uint64_t v9 = (char *)v19 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v10 = sub_1000E77F4(a1, (uint64_t)v9);
  uint64_t v11 = (os_log_s *)Logger.logObject.getter(v10);
  os_log_type_t v12 = static os_log_type_t.debug.getter();
  if (os_log_type_enabled(v11, v12))
  {
    v19[1]  = a4;
    uint64_t v13 = (uint8_t *)swift_slowAlloc(12LL, -1LL);
    uint64_t v14 = swift_slowAlloc(32LL, -1LL);
    uint64_t v21 = v14;
    *(_DWORD *)uint64_t v13 = 136315138;
    DriverEvent.shortDescription.getter();
    unint64_t v16 = v15;
    uint64_t v20 = sub_10000235C(v17, v15, &v21);
    UnsafeMutableRawBufferPointer.copyMemory(from:)(&v20, &v21);
    swift_bridgeObjectRelease(v16);
    sub_1000E7838((uint64_t)v9);
    _os_log_impl((void *)&_mh_execute_header, v11, v12, "Received event %s", v13, 0xCu);
    swift_arrayDestroy(v14, 1LL, &type metadata for Any[8]);
    swift_slowDealloc(v14, -1LL, -1LL);
    swift_slowDealloc(v13, -1LL, -1LL);

    return a3(a1);
  }

  else
  {

    sub_1000E7838((uint64_t)v9);
    return a3(a1);
  }

uint64_t sub_1000E76E8(uint64_t a1, uint64_t a2)
{
  return sub_1000E6E48( a1,  a2,  &OBJC_IVAR____TtC7CoreP2P19AppleBroadcomDriver_logger,  (uint64_t)&unk_1003E3B18,  (uint64_t)sub_1000E76E4);
}

uint64_t sub_1000E7728()
{
  uint64_t v1 = type metadata accessor for Logger(0LL);
  uint64_t v2 = *(void *)(v1 - 8);
  uint64_t v3 = *(unsigned __int8 *)(v2 + 80);
  uint64_t v4 = (v3 + 16) & ~v3;
  uint64_t v5 = v3 | 7;
  unint64_t v6 = (*(void *)(v2 + 64) + v4 + 7) & 0xFFFFFFFFFFFFFFF8LL;
  (*(void (**)(uint64_t, uint64_t))(v2 + 8))(v0 + v4, v1);
  swift_release(*(void *)(v0 + v6 + 8));
  return swift_deallocObject(v0, v6 + 16, v5);
}

uint64_t sub_1000E77A0(uint64_t a1)
{
  uint64_t v3 = *(void *)(type metadata accessor for Logger(0LL) - 8);
  unint64_t v4 = (*(unsigned __int8 *)(v3 + 80) + 16LL) & ~(unint64_t)*(unsigned __int8 *)(v3 + 80);
  uint64_t v5 = v1 + ((*(void *)(v3 + 64) + v4 + 7) & 0xFFFFFFFFFFFFFFF8LL);
  return sub_1000E7528(a1, v1 + v4, *(uint64_t (**)(uint64_t))v5, *(void *)(v5 + 8));
}

uint64_t sub_1000E77F4(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = type metadata accessor for DriverEvent(0LL);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v4 - 8) + 16LL))(a2, a1, v4);
  return a2;
}

uint64_t sub_1000E7838(uint64_t a1)
{
  uint64_t v2 = type metadata accessor for DriverEvent(0LL);
  (*(void (**)(uint64_t, uint64_t))(*(void *)(v2 - 8) + 8LL))(a1, v2);
  return a1;
}

uint64_t sub_1000E7874(uint64_t a1, uint64_t a2)
{
  return sub_1000E6E10(a1, a2);
}

uint64_t sub_1000E7888(uint64_t a1, uint64_t a2)
{
  return sub_1000E76E8(a1, a2);
}

void *NANCipherSuite.defaultValue.unsafeMutableAddressor()
{
  return &static NANCipherSuite.defaultValue;
}

uint64_t NANCipherSuite.description.getter(unsigned __int8 a1)
{
  return ((uint64_t (*)(uint64_t, unint64_t))((char *)sub_1000E78E4
                                                            + 4 * asc_100345498[a1]))( 0x312D4D43432D4B53LL,  0xEA00000000003832LL);
}

uint64_t sub_1000E78E4()
{
  return 0x322D4D43472D4B53LL;
}

uint64_t sub_1000E7900()
{
  return 0x2D484457322D4B50LL;
}

uint64_t sub_1000E7938()
{
  return 0x504D43432D4B5447LL;
}

uint64_t sub_1000E7958()
{
  return 0x504D43472D4B5447LL;
}